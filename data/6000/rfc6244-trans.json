{
  "title": {
    "text": "RFC 6244 - An Architecture for Network Management Using NETCONF and YANG",
    "ja": "RFC 6244 - NETCONFとYANGを使用したネットワーク管理のためのアーキテクチャ"
  },
  "number": 6244,
  "created_at": "2019-11-01 02:43:55.264922+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         P. Shafer\nRequest for Comments: 6244                              Juniper Networks\nCategory: Informational                                        June 2011\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 5,
      "text": "An Architecture for Network Management Using NETCONF and YANG",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Network Configuration Protocol (NETCONF) gives access to native capabilities of the devices within a network, defining methods for manipulating configuration databases, retrieving operational data, and invoking specific operations. YANG provides the means to define the content carried via NETCONF, both data and operations. Using both technologies, standard modules can be defined to give interoperability and commonality to devices, while still allowing devices to express their unique capabilities.",
      "ja": "ネットワーク構成プロトコル（NETCONF）、構成データベースを操作する運用データを取得し、特定の操作を呼び出すためのメソッドを定義し、ネットワーク内のデバイスのネイティブ機能へのアクセスを提供します。 YANGはNETCONF、両方のデータおよびオペレーションを介して搬送されるコンテンツを定義するための手段を提供します。それでもデバイスが彼らのユニークな機能を発現させる一方で、両方の技術を使用して、標準モジュールは、デバイスへの相互運用性と共通性を与えるように定義することができます。"
    },
    {
      "indent": 3,
      "text": "This document describes how NETCONF and YANG help build network management applications that meet the needs of network operators.",
      "ja": "この文書では、NETCONFとYANGは、ネットワーク事業者のニーズを満たすネットワーク管理アプリケーションの構築を支援する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6244.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6244で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2011 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Origins of NETCONF and YANG  . . . . . . . . . . . . . . . . .  4\n2.  Elements of the Architecture . . . . . . . . . . . . . . . . .  5\n  2.1.  NETCONF  . . . . . . . . . . . . . . . . . . . . . . . . .  5\n    2.1.1.  NETCONF Transport Mappings . . . . . . . . . . . . . .  7\n  2.2.  YANG . . . . . . . . . . . . . . . . . . . . . . . . . . .  8\n    2.2.1.  Constraints  . . . . . . . . . . . . . . . . . . . . . 10\n    2.2.2.  Flexibility  . . . . . . . . . . . . . . . . . . . . . 11\n    2.2.3.  Extensibility Model  . . . . . . . . . . . . . . . . . 12\n  2.3.  YANG Translations  . . . . . . . . . . . . . . . . . . . . 13\n    2.3.1.  YIN  . . . . . . . . . . . . . . . . . . . . . . . . . 13\n    2.3.2.  DSDL (RELAX NG)  . . . . . . . . . . . . . . . . . . . 14\n  2.4.  YANG Types . . . . . . . . . . . . . . . . . . . . . . . . 14\n  2.5.  IETF Guidelines  . . . . . . . . . . . . . . . . . . . . . 14\n3.  Working with YANG  . . . . . . . . . . . . . . . . . . . . . . 14\n  3.1.  Building NETCONF- and YANG-Based Solutions . . . . . . . . 14\n  3.2.  Addressing Operator Requirements . . . . . . . . . . . . . 16\n  3.3.  Roles in Building Solutions  . . . . . . . . . . . . . . . 18\n    3.3.1.  Modeler  . . . . . . . . . . . . . . . . . . . . . . . 19\n    3.3.2.  Reviewer . . . . . . . . . . . . . . . . . . . . . . . 19\n    3.3.3.  Device Developer . . . . . . . . . . . . . . . . . . . 19\n    3.3.4.  Application Developer  . . . . . . . . . . . . . . . . 20\n4.  Modeling Considerations  . . . . . . . . . . . . . . . . . . . 22\n  4.1.  Default Values . . . . . . . . . . . . . . . . . . . . . . 22\n  4.2.  Compliance . . . . . . . . . . . . . . . . . . . . . . . . 23\n  4.3.  Data Distinctions  . . . . . . . . . . . . . . . . . . . . 24\n    4.3.1.  Background . . . . . . . . . . . . . . . . . . . . . . 24\n    4.3.2.  Definitions  . . . . . . . . . . . . . . . . . . . . . 25\n    4.3.3.  Implications . . . . . . . . . . . . . . . . . . . . . 27\n  4.4.  Direction  . . . . . . . . . . . . . . . . . . . . . . . . 27\n5.  Security Considerations  . . . . . . . . . . . . . . . . . . . 28\n6.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n  6.1.  Normative References . . . . . . . . . . . . . . . . . . . 28\n  6.2.  Informative References . . . . . . . . . . . . . . . . . . 29",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Origins of NETCONF and YANG",
      "section_title": true,
      "ja": "NETCONFとYANGの1起源"
    },
    {
      "indent": 3,
      "text": "Networks are increasing in complexity and capacity, as well as the density of the services deployed upon them. Uptime, reliability, and predictable latency requirements drive the need for automation. The problems with network management are not simple. They are complex and intricate. But these problems must be solved for networks to meet the stability needs of existing services while incorporating new services in a world where the growth of networks is exhausting the supply of qualified networking engineers.",
      "ja": "ネットワークは複雑さと能力だけでなく、彼らの上にデプロイされたサービスの密度に増加しています。稼働時間、信頼性、および予測可能な待ち時間要件は、自動化の必要性をドライブ。ネットワーク管理に問題は単純ではありません。彼らは、複雑で入り組んだです。しかし、これらの問題は、ネットワークの成長は、資格のあるネットワークエンジニアの供給を消耗される世の中に新しいサービスを取り入れながら、既存のサービスの安定性のニーズを満たすためにネットワークのために解決しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In June of 2002, the Internet Architecture Board (IAB) held a workshop on Network Management [RFC3535]. The members of this workshop made a number of observations and recommendations for the IETF's consideration concerning the issues operators were facing in their network management-related work as well as issues they were having with the direction of the IETF activities in this area.",
      "ja": "2002年6月には、インターネットアーキテクチャ委員会（IAB）は、ネットワーク管理[RFC3535]でワークショップを開催しました。このワークショップのメンバーは、事業者がネットワーク管理関連の仕事だけでなく、問題彼らはこの分野でのIETF活動の方向性を持ったに直面した問題に関するIETFの検討のための観察と提言の数を作りました。"
    },
    {
      "indent": 3,
      "text": "The output of this workshop was focused on current problems. The observations were reasonable and straightforward, including the need for transactions, rollback, low implementation costs, and the ability to save and restore the device's configuration data. Many of the observations give insight into the problems operators were having with existing network management solutions, such as the lack of full coverage of device capabilities and the ability to distinguish between configuration data and other types of data.",
      "ja": "このワークショップの出力は、現在の問題に焦点を当てました。観察は、トランザクションの必要性、ロールバック、低実装コスト、およびデバイスの構成データを保存し、復元する機能を含め、合理的かつ単純明快でした。観察の多くは、オペレータは、デバイス機能の完全なカバレッジの欠如及び構成データおよびデータの他のタイプを区別する能力などの既存のネットワーク管理ソリューションとを有するされた問題への洞察を与えます。"
    },
    {
      "indent": 3,
      "text": "Based on these directions, the NETCONF working group was formed and the Network Configuration (NETCONF) protocol was created. This protocol defines a simple mechanism where network management applications, acting as clients, can invoke operations on the devices, which act as servers. The NETCONF specification [RFC4741] defines a small set of operations, but goes out of its way to avoid making any requirements on the data carried in those operations, preferring to allow the protocol to carry any data. This \"data model agnostic\" approach allows data models to be defined independently.",
      "ja": "これらの方向に基づいて、NETCONFワーキンググループが形成され、ネットワーク設定（NETCONF）プロトコルが作成されました。このプロトコルは、ネットワーク管理アプリケーションは、クライアントとして動作する、サーバとして動作するデバイス、上の操作を呼び出すことができ、簡単なメカニズムを定義します。 NETCONF仕様[RFC4741]はオペレーションの小さなセットを定義するが、プロトコルは、任意のデータを搬送することを可能にすることを好む、これらの操作で搬送されたデータの任意の要件を避けるために、その方法の外に出ます。この「データモデルにとらわれない」アプローチは、データモデルは、独立して定義することができます。"
    },
    {
      "indent": 3,
      "text": "But lacking a means of defining data models, the NETCONF protocol was not usable for standards-based work. Existing data modeling languages such as the XML Schema Definition (XSD) [W3CXSD] and the Document Schema Definition Languages (DSDL) [ISODSDL] were considered, but were rejected because of the problem that domains have little natural overlap. Defining a data model or protocol that is encoded in XML is a distinct problem from defining an XML document. The use of NETCONF operations places requirements on the data content that are not shared with the static document problem domain addressed by schema languages like XSD or RELAX NG.",
      "ja": "しかし、データモデルを定義する手段を欠いている、NETCONFプロトコルは、標準ベースの作業には使用できませんでした。既存のデータモデリングなどのXMLスキーマ定義（XSD）[W3CXSD]と[ISODSDL]と考えられた文書スキーマ定義言語（DSDL）などの言語、しかしがあるためドメインは少し自然なオーバーラップを持つ問題で拒否されました。 XMLでエンコードされたデータモデルまたはプロトコルを定義するXMLドキュメントを定義するとは異なる問題です。 NETCONF操作の使用は、XSD様またはRELAX NGのスキーマ言語によって対処静的ドキュメントの問題領域と共有されないデータ内容に要件を課します。"
    },
    {
      "indent": 3,
      "text": "In 2007 and 2008, the issue of a data modeling language for NETCONF was discussed in the OPS and APP areas of IETF 70 and 71, and a design team was tasked with creating a requirements document [RCDML]. After discussing the available options at the CANMOD BoF at IETF 71, the community wrote a charter for the NETMOD working group. An excellent description of this time period is available at <http://www.ietf.org/mail-archive/web/ietf/current/msg51644.html>.",
      "ja": "2007年と2008年には、NETCONFのためのデータモデリング言語の問題は、OPSとIETF 70と71のAPPの分野で議論された、および設計チームは、要件ドキュメント[RCDML]を作成する使命を帯びました。 IETF 71でCANMODのBoFで利用可能なオプションを議論した後、コミュニティはNETMODワーキンググループのチャーターを書きました。この期間の優れた説明は、<http://www.ietf.org/mail-archive/web/ietf/current/msg51644.html>でご利用いただけます。"
    },
    {
      "indent": 3,
      "text": "In 2008 and 2009, the NETMOD working group produced a specification for YANG [RFC6020] as a means for defining data models for NETCONF, allowing both standard and proprietary data models to be published in a form that is easily digestible by human readers and satisfies many of the issues raised in the IAB NM workshop. This brings NETCONF to a point where is can be used to develop standard data models within the IETF.",
      "ja": "2008年および2009年に、NETMODワーキンググループは、標準および独自の両方のデータモデルは、多くの人間の読者を満足することにより、容易に消化された形態で公開できるように、NETCONFのためのデータモデルを定義するための手段として、YANG [RFC6020]の仕様を生成しましたIAB NMのワークショップで提起された問題の。これは、IETF内の標準データモデルを開発するために使用することができているポイントにNETCONFをもたらします。"
    },
    {
      "indent": 3,
      "text": "YANG allows a modeler to create a data model, to define the organization of the data in that model, and to define constraints on that data. Once published, the YANG module acts as a contract between the client and server, with both parties understanding how their peer will expect them to behave. A client knows how to create valid data for the server, and knows what data will be sent from the server. A server knows the rules that govern the data and how it should behave.",
      "ja": "YANGはモデラーが、データモデルを作成するために、そのモデル内のデータの編成を定義し、そのデータ上の制約を定義することができます。公表された後、YANGモジュールは、両方の当事者がそのピアは、それらが動作するように期待する方法を理解して、クライアントとサーバの間の契約として機能します。クライアントは、サーバのための有効なデータを作成する方法を知っており、データをサーバから送信されます知っています。サーバーは、データを管理し、それがどのように振る舞うべきかのルールを知っています。"
    },
    {
      "indent": 3,
      "text": "YANG also incorporates a level of extensibility and flexibility not present in other model languages. New modules can augment the data hierarchies defined in other modules, seamlessly adding data at appropriate places in the existing data organization. YANG also allows new statements to be defined, allowing the language itself to be expanded in a consistent way.",
      "ja": "YANGも拡張性と他のモデルの言語に存在しない柔軟性のレベルが組み込まれています。新モジュールは、シームレスに既存のデータ、組織内の適切な場所にデータを追加して、他のモジュールで定義されたデータの階層を増やすことができます。 YANGまた、言語自体が一貫した方法で展開できるように、新しいステートメントを定義することができます。"
    },
    {
      "indent": 3,
      "text": "This document presents an architecture for YANG, describing how YANG-related technologies work and how solutions built on them can address the network management problem domain.",
      "ja": "この文書では、YANG関連技術がどのように動作するかを記述し、どのようにそれらの上に構築されたソリューションは、ネットワーク管理問題領域に対処することができ、YANGためのアーキテクチャを提示します。"
    },
    {
      "indent": 0,
      "text": "2. Elements of the Architecture",
      "section_title": true,
      "ja": "アーキテクチャの2要素"
    },
    {
      "indent": 0,
      "text": "2.1. NETCONF",
      "section_title": true,
      "ja": "2.1。 NETCONF"
    },
    {
      "indent": 3,
      "text": "NETCONF defines an XML-based remote procedure call (RPC) mechanism that leverages the simplicity and availability of high-quality XML parsers. XML gives a rich, flexible, hierarchical, standard representation of data that matches the needs of networking devices. NETCONF carries configuration data and operations as requests and replies using RPCs encoded in XML over a connection-oriented transport.",
      "ja": "NETCONFは、高品質のXMLパーサーの単純さと可用性を活用XMLベースのリモートプロシージャコール（RPC）メカニズムを定義します。 XMLは、ネットワークデバイスのニーズに合致するデータの豊富な、柔軟な、階層的な、標準的な表現を提供します。 NETCONFはコネクション型トランスポートを介してXMLでエンコードされたRPCを使用して、要求と応答のような構成データおよび操作を運びます。"
    },
    {
      "indent": 3,
      "text": "XML's hierarchical data representation allows complex networking data to be rendered in a natural way. For example, the following configuration places interfaces in OSPF areas. The <ospf> element contains a list of <area> elements, each of which contain a list of <interface> elements. The <name> element identifies the specific area or interface. Additional configuration for each area or interface appears directly inside the appropriate element.",
      "ja": "XMLの階層データ表現は、複雑なネットワークのデータが自然な方法でレンダリングすることができます。例えば、以下の構成がOSPFエリアにインターフェースを配置します。 <OSPF>要素は、<インターフェース>要素のリストを含むそれぞれが<エリア>要素のリストを含みます。 <name>要素は、特定の領域またはインタフェースを識別する。各領域またはインタフェースのための追加の構成が適切な要素内に直接表示されます。"
    },
    {
      "indent": 9,
      "text": "<ospf xmlns=\"http://example.org/netconf/ospf\">",
      "ja": "<OSPFのxmlns = \"http://example.org/netconf/ospf\">"
    },
    {
      "indent": 11,
      "text": "<area> <name>0.0.0.0</name>",
      "ja": "<地域> <名前> 0.0.0.0 </名前>"
    },
    {
      "indent": 13,
      "text": "<interface> <name>ge-0/0/0.0</name> <!-- The priority for this interface --> <priority>30</priority> <metric>100</metric> <dead-interval>120</dead-interval> </interface>",
      "ja": "<インターフェース> <名前> GE-0/0 / 0.0 </名前> <！ - このインタフェースの優先順位 - > <優先順位> 30 </優先順位> <メトリック> 100 </メトリック> <デッド間隔> 120 </デッドインターバル> </インターフェース>"
    },
    {
      "indent": 11,
      "text": " <interface> <name>ge-0/0/1.0</name> <metric>140</metric> </interface> </area>",
      "ja": "<インターフェース> <名前> GE-0/0 / 1.0 </名前> <メトリック> 140 </メトリック> </インターフェイス> </地域>"
    },
    {
      "indent": 11,
      "text": "<area> <name>10.1.2.0</name>",
      "ja": "<地域> <名前> 10.1.2.0 </名前>"
    },
    {
      "indent": 13,
      "text": "<interface> <name>ge-0/0/2.0</name> <metric>100</metric> </interface>",
      "ja": "<インターフェース> <名前> GE-0/0 / 2.0 </名前> <メトリック> 100 </メトリック> </インターフェース>"
    },
    {
      "indent": 9,
      "text": " <interface> <name>ge-0/0/3.0</name> <metric>140</metric> <dead-interval>120</dead-interval> </interface> </area> </ospf>",
      "ja": "<インターフェース> <名前> GE-0/0 / 3.0 </名前> <メトリック> 140 </メトリック> <デッドインターバル> 120 </デッドインターバル> </インターフェイス> </地域> </ OSPF>"
    },
    {
      "indent": 3,
      "text": "NETCONF includes mechanisms for controlling configuration datastores. Each datastore is a specific collection of configuration data that can be used as source or target of the configuration-related operations. The device can indicate whether it has a distinct \"startup\" configuration datastore, whether the current or \"running\" datastore is directly writable, or whether there is a \"candidate\" configuration datastore where configuration changes can be made that will not affect the device until a \"commit-configuration\" operation is invoked.",
      "ja": "NETCONFは、構成データストアを制御するための機構を含みます。各データストアは、構成関連の操作のソースまたはターゲットとして使用することができるコンフィギュレーションデータの特定の集合です。デバイスは、現在またはデータストア「を実行しているが、」直接書き込み可能であるか、または構成の変更を行うことができる「候補」の構成データストアがあるかどうかまではデバイスに影響を与えないということ、それは明確な「スタートアップ」の構成データストアを持っているかどうかを示すことができます「コミットの設定」操作が呼び出されます。"
    },
    {
      "indent": 3,
      "text": "NETCONF defines operations that are invoked as RPCs from the client (the application) to the server (running on the device). The following table lists some of these operations:",
      "ja": "NETCONFは、サーバ（デバイス上で実行されている）へのクライアント（アプリケーション）からのRPCとして呼び出される動作を定義します。以下の表は、これらの操作の一部を示しています。"
    },
    {
      "indent": 3,
      "text": "+---------------+---------------------------------------------------+\n| Operation     | Description                                       |\n+---------------+---------------------------------------------------+\n| commit        | Commit the \"candidate\" configuration to \"running\" |\n| copy-config   | Copy one configuration datastore to another       |\n| delete-config | Delete a configuration datastore                  |\n| edit-config   | Change the contents of a configuration datastore  |\n| get-config    | Retrieve all or part of a configuration datastore |\n| lock          | Prevent changes to a datastore from another party |\n| unlock        | Release a lock on a datastore                     |\n+---------------+---------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "NETCONF's \"capability\" mechanism allows the device to announce the set of capabilities that the device supports, including protocol operations, datastores, data models, and other abilities. These are announced during session establishment as part of the <hello> message. A client can inspect the hello message to determine what the device is capable of and how to interact with the device to perform the desired tasks.",
      "ja": "NETCONFの「機能」のメカニズムは、デバイスがプロトコル動作、データストア、データモデル、およびその他の能力を含むデバイスがサポートする機能のセットを、発表することができます。これらは、<ハロー>メッセージの一部としてセッション確立中に発表しています。クライアントは、デバイスが可能であるものを、目的のタスクを実行するデバイスと対話する方法を決定するためにhelloメッセージを調べることができます。"
    },
    {
      "indent": 3,
      "text": "NETCONF also defines a means of sending asynchronous notifications from the server to the client, described in [RFC5277].",
      "ja": "NETCONFはまた、[RFC5277]に記載のサーバからクライアントへの非同期通知を送信する手段を定義します。"
    },
    {
      "indent": 3,
      "text": "In addition, NETCONF can fetch state data, receive notifications, and invoke additional RPC methods defined as part of a capability. Complete information about NETCONF can be found in [RFC4741].",
      "ja": "また、NETCONFは、状態データを取得通知を受信し、機能の一部として定義され、追加のRPCメソッドを呼び出すことができます。 NETCONFについての完全な情報は、[RFC4741]で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "2.1.1. NETCONF Transport Mappings",
      "section_title": true,
      "ja": "2.1.1。 NETCONF交通マッピング"
    },
    {
      "indent": 3,
      "text": "NETCONF can run over any transport protocol that meets the requirements defined in RFC 4741, including",
      "ja": "NETCONFには、RFC 4741で定義された要件を満たす任意のトランスポートプロトコル上で実行することができ"
    },
    {
      "indent": 3,
      "text": "o connection-oriented operation",
      "ja": "O接続指向の操作"
    },
    {
      "indent": 3,
      "text": "o authentication",
      "ja": "O認証"
    },
    {
      "indent": 3,
      "text": "o integrity",
      "ja": "Oの整合性"
    },
    {
      "indent": 3,
      "text": "o confidentiality",
      "ja": "Oの機密性"
    },
    {
      "indent": 3,
      "text": "[RFC4742] defines a mapping for the Secure Shell (SSH) [RFC4251] protocol, which is the mandatory transport protocol. Others include SOAP [RFC4743], the Blocks Extensible Exchange Protocol (BEEP) [RFC4744], and Transport Layer Security (TLS) [RFC5539].",
      "ja": "[RFC4742]は必須のトランスポートプロトコルであるセキュアシェル（SSH）[RFC4251]プロトコルのマッピングを定義します。その他には、SOAP [RFC4743]、ブロック拡張可能交換プロトコル（BEEP）[RFC4744]、およびTransport Layer Security（TLS）[RFC5539]を含んでいます。"
    },
    {
      "indent": 0,
      "text": "2.2. YANG",
      "section_title": true,
      "ja": "2.2。 THE"
    },
    {
      "indent": 3,
      "text": "YANG is a data modeling language for NETCONF. It allows the description of hierarchies of data nodes (\"nodes\") and the constraints that exist among them. YANG defines data models and how to manipulate those models via NETCONF protocol operations.",
      "ja": "YANGは、NETCONFのためのデータモデリング言語です。これは、データノードの階層（「ノード」）とそれらの間に存在する制約を記述することができます。 YANGは、データモデルを定義し、どのNETCONFプロトコル操作を介してこれらのモデルを操作します。"
    },
    {
      "indent": 3,
      "text": "Each YANG module defines a data model, uniquely identified by a namespace URI. These data models are extensible in a manner that allows tight integration of standard data models and proprietary data models. Models are built from organizational containers, lists of data nodes, and data-node-forming leafs of the data tree.",
      "ja": "各YANGモジュールは一意の名前空間URIによって識別され、データ・モデルを定義します。これらのデータ・モデルは、標準データモデルと独自のデータモデルの緊密な統合を可能にする方法で、拡張可能です。モデルは、組織コンテナ、データノードのリスト、およびデータツリーのデータノードを形成するリーフから構築されます。"
    },
    {
      "indent": 7,
      "text": "module example-ospf {\n    namespace \"http://example.org/netconf/ospf\";\n    prefix ospf;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "import network-types {  // Access another module's def'ns\n    prefix nett;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    container ospf {   // Declare the top-level tag\n        list area {    // Declare a list of \"area\" nodes\n            key name;  // The key \"name\" identifies list members\n            leaf name {\n                type nett:area-id;\n            }\n            list interface {\n                key name;\n                leaf name {\n                    type nett:interface-name;\n                }\n                leaf priority {\n                    description \"Designated router priority\";\n                    type uint8;  // The type is a constraint on\n                                 // valid values for \"priority\".\n                }\n                leaf metric {\n                    type uint16 {\n                        range 1..65535;\n                    }\n                }\n                leaf dead-interval {\n                    units seconds;\n                    type uint16 {\n                        range 1..65535;\n                    }\n                }\n            }\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A YANG module defines a data model in terms of the data, its hierarchical organization, and the constraints on that data. YANG defines how this data is represented in XML and how that data is used in NETCONF operations.",
      "ja": "YANGモジュールは、データ、その階層構造、およびそのデータの制約の観点からデータ・モデルを定義します。 YANGは、このデータは、XMLで表現する方法と、そのデータはNETCONFの操作に使用される方法を定義します。"
    },
    {
      "indent": 3,
      "text": "The following table briefly describes some common YANG statements:",
      "ja": "次の表は、簡単にいくつかの一般的なYANG文について説明します。"
    },
    {
      "indent": 3,
      "text": "+--------------+----------------------------------------------------+\n| Statement    | Description                                        |\n+--------------+----------------------------------------------------+\n| augment      | Extends existing data hierarchies                  |\n| choice       | Defines mutually exclusive alternatives            |\n| container    | Defines a layer of the data hierarchy              |\n| extension    | Allows new statements to be added to YANG          |\n| feature      | Indicates parts of the model that are optional     |\n| grouping     | Groups data definitions into reusable sets         |\n| key          | Defines the key leafs for lists                    |\n| leaf         | Defines a leaf node in the data hierarchy          |\n| leaf-list    | A leaf node that can appear multiple times         |\n| list         | A hierarchy that can appear multiple times         |\n| notification | Defines notification                               |\n| rpc          | Defines input and output parameters for an RPC     |\n|              | operation                                          |\n| typedef      | Defines a new type                                 |\n| uses         | Incorporates the contents of a \"grouping\"          |\n+--------------+----------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.2.1. Constraints",
      "section_title": true,
      "ja": "2.2.1。制約"
    },
    {
      "indent": 3,
      "text": "YANG allows the modeler to add constraints to the data model to prevent impossible or illogical data. These constraints give clients information about the data being sent from the device, and also allow the client to know as much as possible about the data the device will accept, so the client can send correct data. These constraints apply to configuration data, but can also be used for rpc and notification data.",
      "ja": "YANGは、モデラーが不可能または非論理的なデータを防ぐために、データモデルに制約を追加することができます。これらの制約は、デバイスから送信されたデータについてのクライアントの情報を提供し、またクライアントは、デバイスが受け入れるので、クライアントは正しいデータを送信できるデータについてできるだけ多くを知ることができます。これらの制約は、データを構成に適用するだけでなく、RPCと通知データに使用することができます。"
    },
    {
      "indent": 3,
      "text": "The principal constraint is the \"type\" statement, which limits the contents of a leaf node to that of the named type. The following table briefly describes some other common YANG constraints:",
      "ja": "主な制約は、名前付きの型のようにリーフノードの内容を制限し、「タイプ」声明、です。次の表は、簡単にいくつかの他の一般的なYANG制約について説明します。"
    },
    {
      "indent": 3,
      "text": "+--------------+----------------------------------------------------+\n| Statement    | Description                                        |\n+--------------+----------------------------------------------------+\n| length       | Limits the length of a string                      |\n| mandatory    | Requires the node appear                           |\n| max-elements | Limits the number of instances in a list           |\n| min-elements | Limits the number of instances in a list           |\n| must         | XPath expression must be true                      |\n| pattern      | Regular expression must be satisfied               |\n| range        | Value must appear in range                         |\n| reference    | Value must appear elsewhere in the data            |\n| unique       | Value must be unique within the data               |\n| when         | Node is only present when XPath expression is true |\n+--------------+----------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"must\" and \"when\" statements use XPath [W3CXPATH] expressions to specify conditions that are semantically evaluated against the data hierarchy, but neither the client nor the server are required to implement the XPath specification. Instead they can use any means to ensure these conditions are met.",
      "ja": "「しなければならない」と「とき」の文は、意味的にデータ階層に対して評価されますが、クライアントとサーバーのいずれもがXPath仕様を実装するために必要とされる条件を指定したXPath [W3CXPATH]表現を使用します。その代わりに、これらの条件が満たされていることを確認するためのあらゆる手段を使用することができます。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Flexibility",
      "section_title": true,
      "ja": "2.2.2。柔軟性"
    },
    {
      "indent": 3,
      "text": "YANG uses the \"union\" type and the \"choice\" and \"feature\" statements to give modelers flexibility in defining their data models. The \"union\" type allows a single leaf to accept multiple types, like an integer or the word \"unbounded\":",
      "ja": "YANGは、「労働組合」の種類とそのデータモデルを定義するのにモデラーに柔軟性を与えるために「選択」と「機能」の文を使用しています。 「労働組合」タイプは、整数またはワード「無制限」のように、複数のタイプを受け入れるように単一の葉を許可します。"
    },
    {
      "indent": 5,
      "text": "type union {\n    type int32;\n    type enumeration {\n        enum \"unbounded\";\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"choice\" statement lists a set of mutually exclusive nodes, so a valid configuration can choose any one node (or case). The \"feature\" statement allows the modeler to identify parts of the model that can be optional, and allows the device to indicate whether it implements these optional portions.",
      "ja": "「選択」のステートメントは、相互に排他的なノードのセットを示していますので、有効な構成は、いずれかのノード（またはケース）を選択することができます。 「機能」ステートメントはモデラーは任意とすることができるモデルの部分を識別することができ、デバイスは、これらの任意の部分を実装するかどうかを示すことができます。"
    },
    {
      "indent": 3,
      "text": "The \"deviation\" statement allows the device to indicate parts of a YANG module that the device does not faithfully implement. While devices are encouraged to fully abide according to the contract presented in the YANG module, real-world situations may force the device to break the contract. Deviations give a means of declaring this limitation, rather than leaving it to be discovered via run-time errors.",
      "ja": "「ずれ」の文では、デバイスはデバイスが忠実に実装していないYANGモジュールの一部を示すことができます。デバイスはYANGモジュールで提供契約に従って完全に遵守することが奨励されていますが、現実の世界の状況は、契約を破るために、デバイスを強制する場合があります。偏差は、この制限を宣言するのではなく、それは、実行時エラーを経て発見されるのを残しての手段を与えます。"
    },
    {
      "indent": 0,
      "text": "2.2.3. Extensibility Model",
      "section_title": true,
      "ja": "2.2.3。拡張性モデル"
    },
    {
      "indent": 3,
      "text": "XML includes the concept of namespaces, allowing XML elements from different sources to be combined in the same hierarchy without risking collision. YANG modules define content for specific namespaces, but one module may augment the definition of another module, introducing elements from that module's namespace into the first module's hierarchy.",
      "ja": "XMLは、異なるソースからのXML要素は、衝突の危険を冒すことなく、同一階層で組み合わせることができるように、名前空間の概念を含みます。 YANGモジュールは、特定の名前空間の内容を定義するが、1つのモジュールが第一のモジュールの階層にそのモジュールの名前空間からの要素を導入すること、他のモジュールの定義を増強することができます。"
    },
    {
      "indent": 3,
      "text": "Since one module can augment another module's definition, hierarchies of definitions are allowed to grow, as definitions from multiple sources are added to the base hierarchy. These augmentations are qualified using the namespace of the source module, helping to avoid issues with name conflicts as the modules change over time.",
      "ja": "1つのモジュールは別のモジュールの定義を拡張することができるので、複数のソースからの定義は、基本階層に追加されると、定義の階層は、成長させています。これらの拡張製品は、モジュールは、時間の経過とともに変化として名前の競合の問題を回避するために支援し、ソース・モジュールの名前空間を使用して修飾されます。"
    },
    {
      "indent": 3,
      "text": "For example, if the above OSPF configuration were the standard, a vendor module may augment this with vendor-specific extensions.",
      "ja": "上記OSPF構成が標準であれば、例えば、ベンダモジュールは、ベンダー固有の拡張機能でこれを増強することができます。"
    },
    {
      "indent": 7,
      "text": "module vendorx-ospf {\n    namespace \"http://vendorx.example.com/ospf\";\n    prefix vendorx;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "import example-ospf {\n    prefix ospf;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    augment /ospf:ospf/ospf:area/ospf:interfaces {\n        leaf no-neighbor-down-notification {\n            type empty;\n            description \"Don't inform other protocols about\"\n                      + \" neighbor down events\";\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The <no-neighbor-down-notification> element is then placed in the vendorx namespace:",
      "ja": "<無隣人ダウン通知>要素は、その後vendorx名前空間に配置されています。"
    },
    {
      "indent": 7,
      "text": "<ospf xmlns=\"http://example.org/netconf/ospf\"\n      xmlns:vendorx=\"http://vendorx.example.com/ospf\">",
      "raw": true
    },
    {
      "indent": 9,
      "text": "<area> <name>0.0.0.0</name>",
      "ja": "<地域> <名前> 0.0.0.0 </名前>"
    },
    {
      "indent": 11,
      "text": "<interface> <name>ge-0/0/0.0</name> <priority>30</priority> <vendorx:no-neighbor-down-notification/> </interface>",
      "ja": "<インターフェース> <名前> GE-0/0 / 0.0 </名前> <優先度> 30 </優先> <vendorx：非隣接ダウン通知/> </インターフェース>"
    },
    {
      "indent": 7,
      "text": " </area> </ospf>",
      "ja": "</エリア> </ OSPF>"
    },
    {
      "indent": 3,
      "text": "Augmentations are seamlessly integrated with base modules, allowing them to be fetched, archived, loaded, and deleted within their natural hierarchy. If a client application asks for the configuration for a specific OSPF area, it will receive the sub-hierarchy for that area, complete with any augmented data.",
      "ja": "拡張製品は、シームレスに、彼らは、フェッチアーカイブすることができ、ベースモジュールと統合ロードされ、その自然の階層内で削除されます。クライアント・アプリケーションは、特定のOSPFエリアの設定を要求した場合、それはどんな増補データと完全にその領域のためのサブ階層を、受け取ることになります。"
    },
    {
      "indent": 0,
      "text": "2.3. YANG Translations",
      "section_title": true,
      "ja": "2.3。翻訳"
    },
    {
      "indent": 3,
      "text": "The YANG data modeling language is the central piece of a group of related technologies. The YANG language itself, described in [RFC6020], defines the syntax of the language and its statements, the meaning of those statements, and how to combine them to build the hierarchy of nodes that describe a data model.",
      "ja": "YANGデータモデリング言語は、関連技術のグループの中心部分です。 [RFC6020]で説明YANG言語自体は、言語とその文、それらのステートメントの意味、そしてどのようにデータモデルを記述するノードの階層を構築するためにそれらを組み合わせることの構文を定義します。"
    },
    {
      "indent": 3,
      "text": "That document also defines the \"on the wire\" XML content for NETCONF operations on data models defined in YANG modules. This includes the basic mapping between YANG data tree nodes and XML elements, as well as mechanisms used in <edit-config> content to manipulate that data, such as arranging the order of nodes within a list.",
      "ja": "その文書はまた、YANGモジュールで定義されたデータモデルにNETCONF操作のための「ワイヤ上」XMLコンテンツを定義します。これは、基本的なYANGデータツリーノードとXML要素との間のマッピング、並びにこのようなリスト内のノードの順序を配置するなど、そのデータを操作するために、<編集設定>コンテンツに使用されるメカニズムを含みます。"
    },
    {
      "indent": 3,
      "text": "YANG uses a syntax that is regular and easily described, primarily designed for human readability. YANG's syntax is friendly to email, diff, patch, and the constraints of RFC formatting.",
      "ja": "YANGは、定期的かつ簡単に説明し、主に人間の読みやすさのために設計されている構文を使用しています。 YANGの構文は、電子メール、デフ、パッチ、およびRFCフォーマットの制約に優しいです。"
    },
    {
      "indent": 0,
      "text": "2.3.1. YIN",
      "section_title": true,
      "ja": "2.3.1。陰"
    },
    {
      "indent": 3,
      "text": "In some environments, incorporating a YANG parser may not be an acceptable option. For those scenarios, an XML grammar for YANG is defined as YIN (YANG Independent Notation). YIN allows the use of XML parsers that are readily available in both open source and commercial versions. Conversion between YANG and YIN is direct, loss-less, and reversible. YANG statements are converted to XML elements, preserving the structure and content of YANG, but enabling the use of off-the-shelf XML parsers rather than requiring the integration of a YANG parser. YIN maintains complete semantic equivalence with YANG.",
      "ja": "一部の環境では、YANGパーサーを組み込むことは許容オプションではないかもしれません。これらのシナリオのために、YANGのXML文法はYIN（YANG独立表記）として定義されます。 YINは、オープンソースと商用版の両方で容易に入手可能であるXMLパーサーを使用することができます。陰と陽の間の変換は、直接、無損失、および可逆的です。 YANG文はYANGの構造及びコンテンツを保存するが、既製のXMLパーサの使用を可能にするのではなくYANGパーサーの統合を必要とする、XML要素に変換されます。 YIN YANGは、との完全な意味的な等価性を維持します。"
    },
    {
      "indent": 0,
      "text": "2.3.2. DSDL (RELAX NG)",
      "section_title": true,
      "ja": "2.3.2。 DSDL（NGをRELAX）"
    },
    {
      "indent": 3,
      "text": "Since NETCONF content is encoded in XML, it is natural to use XML schema languages for their validation. To facilitate this, YANG offers a standardized mapping of YANG modules into Document Schema Definition Languages [RFC6110], of which RELAX NG is a major component.",
      "ja": "NETCONFのコンテンツはXMLでエンコードされているので、彼らの検証のためのXMLスキーマ言語を使用するのが自然です。これを容易にするために、YANGはNGが主要成分であるRELAXその文書スキーマ定義言語[RFC6110]、にYANGモジュールの標準化されたマッピングを提供しています。"
    },
    {
      "indent": 3,
      "text": "DSDL is considered to be the best choice as a standard schema language because it addresses not only grammar and datatypes of XML documents but also semantic constraints and rules for modifying the information set of the document.",
      "ja": "DSDLは、それが文法やXML文書のデータ型だけでなく、文書の設定情報を変更するための意味制約やルールだけでなく、対処しているため、標準のスキーマ言語として最良の選択であると考えられています。"
    },
    {
      "indent": 3,
      "text": "In addition, DSDL offers formal means for coordinating multiple independent schemas and specifying how to apply the schemas to the various parts of the document. This is useful since YANG content is typically composed of multiple vocabularies.",
      "ja": "また、DSDLは、複数の独立したスキーマを調整し、文書の様々な部分にスキーマを適用する方法を指定するための正式な手段を提供しています。 YANGコンテンツは、通常、複数の語彙で構成されているので、これは便利です。"
    },
    {
      "indent": 0,
      "text": "2.4. YANG Types",
      "section_title": true,
      "ja": "2.4。タイプTHAT"
    },
    {
      "indent": 3,
      "text": "YANG supports a number of builtin types, and allows additional types to be derived from those types in an extensible manner. New types can add additional restrictions to allowable data values.",
      "ja": "YANGは、組み込み型の数をサポートし、追加のタイプは、拡張可能な方法でそれらの型から誘導されることを可能にします。新しいタイプの許容データ値に追加の制限を追加することができます。"
    },
    {
      "indent": 3,
      "text": "A standard type library for use by YANG is available [RFC6021]. These YANG modules define commonly used data types for IETF-related standards.",
      "ja": "YANGで使用するための標準的なタイプライブラリが利用できる[RFC6021]です。これらYANGモジュールは、IETF関連の標準のために一般的に使用されるデータ型を定義します。"
    },
    {
      "indent": 0,
      "text": "2.5. IETF Guidelines",
      "section_title": true,
      "ja": "2.5。 IETFガイドライン"
    },
    {
      "indent": 3,
      "text": "A set of additional guidelines is defined that indicate desirable usage for authors and reviewers of Standards-Track specifications containing YANG data model modules [RFC6087]. These guidelines should be used as a basis for reviews of other YANG data model documents.",
      "ja": "追加のガイドラインのセットは、YANGデータ・モデル・モジュール[RFC6087]を含む標準トラック仕様の作成者と校閲のための望ましい使用量を示すように定義されています。これらのガイドラインは、他のYANGデータモデル文書のレビューのための基礎として使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "3. Working with YANG",
      "section_title": true,
      "ja": "3. YANGでの作業"
    },
    {
      "indent": 0,
      "text": "3.1. Building NETCONF- and YANG-Based Solutions",
      "section_title": true,
      "ja": "3.1。ビルNETCONF-とYANGベースのソリューション"
    },
    {
      "indent": 3,
      "text": "In the typical YANG-based solution, the client and server are driven by the content of YANG modules. The server includes the definitions of the modules as meta-data that is available to the NETCONF engine. This engine processes incoming requests, uses the meta-data to parse and verify the request, performs the requested operation, and returns the results to the client.",
      "ja": "典型的なYANGベースのソリューションでは、クライアントとサーバは、YANGモジュールの内容によって駆動されます。サーバは、NETCONFエンジンに利用可能であるメタデータとしてモジュールの定義を含みます。このエンジンは、着信要求を処理し、要求を解析し、検証するためのメタデータを使用して、要求された操作を実行し、結果をクライアントに返します。"
    },
    {
      "indent": 5,
      "text": "                  +----------------------------+\n                  |Server (device)             |\n                  |    +--------------------+  |\n                  |    |      configuration |  |\n       +----+     |    |     ---------------|  |\n       |YANG|+    |    | m d  state data    |  |\n       |mods||+   |    | e a ---------------|  |\n       +----+|| -----> | t t  notifications |  |\n        +----+|   |    | a a ---------------|  |\n         +----+   |    |      operations    |  |\n                  |    +--------------------+  |\n                  |           ^                |\n                  |           |                |\n                  |           v                |\n+------+          |     +-------------+        |\n|      | -------------> |             |        |\n|Client| <rpc>    |     |  NETCONF    |        |\n| (app)|          |     |   engine    |        |\n|      | <------------  |             |        |\n+------+ <rpc-reply>    +-------------+        |\n                  |       /        \\           |\n                  |      /          \\          |\n                  |     /            \\         |\n                  | +--------+   +---------+   |\n                  | | config |   |system   |+  |\n                  | |  data- |   |software ||+ |\n                  | |   base |   |component||| |\n                  | +--------+   +---------+|| |\n                  |               +---------+| |\n                  |                +---------+ |\n                  +----------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To use YANG, YANG modules must be defined to model the specific problem domain. These modules are then loaded, compiled, or coded into the server.",
      "ja": "YANGを使用するには、YANGモジュールは、特定の問題領域をモデル化するために定義する必要があります。これらのモジュールは、その後、ロードされたコンパイル、またはサーバーにコード化されています。"
    },
    {
      "indent": 3,
      "text": "The sequence of events for the typical client/server interaction may be as follows:",
      "ja": "次のように一般的なクライアント/サーバの対話のためのイベントのシーケンスは次のようになります。"
    },
    {
      "indent": 3,
      "text": "o A client application ([C]) opens a NETCONF session to the server (device) ([S])",
      "ja": "クライアント・アプリケーションO（[C]）サーバ（装置）（[S]）にNETCONFセッションを開き"
    },
    {
      "indent": 3,
      "text": "o [C] and [S] exchange <hello> messages containing the list of capabilities supported by each side, allowing [C] to learn the modules supported by [S]",
      "ja": "O [C]と[S]交換<こんにちは>それぞれの側でサポートされている機能のリストを含むメッセージは、許可[C]でサポートされているモジュールを学習する[S]"
    },
    {
      "indent": 3,
      "text": "o [C] builds and sends an operation defined in the YANG module, encoded in XML, within NETCONF's <rpc> element",
      "ja": "O [C]はNETCONFの<RPC>要素内で、XMLでエンコードさYANGモジュールで定義された動作を構築し、送信します。"
    },
    {
      "indent": 3,
      "text": "o [S] receives and parses the <rpc> element",
      "ja": "O [S]は、<RPC>要素を受信し、解析します"
    },
    {
      "indent": 3,
      "text": "o [S] verifies the contents of the request against the data model defined in the YANG module",
      "ja": "O [S]はYANGモジュールで定義されたデータ・モデルに対する要求の内容を検証します"
    },
    {
      "indent": 3,
      "text": "o [S] performs the requested operation, possibly changing the configuration datastore",
      "ja": "O [S]は、おそらく、構成データストアを変更すること、要求された動作を実行します"
    },
    {
      "indent": 3,
      "text": "o [S] builds the response, containing the response, any requested data, and any errors",
      "ja": "O [S]は、応答、任意の要求されたデータ、およびエラーを含む応答を構築します"
    },
    {
      "indent": 3,
      "text": "o [S] sends the response, encoded in XML, within NETCONF's <rpc-reply> element",
      "ja": "O [S]はNETCONFの<RPC返信>要素内で、XMLでエンコードされ、応答を送信します"
    },
    {
      "indent": 3,
      "text": "o [C] receives and parses the <rpc-reply> element",
      "ja": "O [C]は、<RPC返信>要素を受信して​​解析します"
    },
    {
      "indent": 3,
      "text": "o [C] inspects the response and processes it as needed",
      "ja": "O [C]は、応答を検査し、必要に応じてそれを処理します"
    },
    {
      "indent": 3,
      "text": "Note that there is no requirement for the client or server to process the YANG modules in this way. The server may hard code the contents of the data model, rather than handle the content via a generic engine. Or the client may be targeted at the specific YANG model, rather than being driven generically. Such a client might be a simple shell script that stuffs arguments into an XML payload template and sends it to the server.",
      "ja": "このようにYANGモジュールを処理するために、クライアントまたはサーバのための必要はないことに注意してください。サーバーは、ハードデータモデルの内容をコーディングするのではなく、一般的なエンジンを介してコンテンツを処理することができます。またはクライアントではなく、一般的に駆動されることよりも、特定のYANGモデルを対象とすることができます。このようなクライアントは、XMLペイロードテンプレートに引数を詰め込むと、サーバーに送信し、簡単なシェルスクリプトであるかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.2. Addressing Operator Requirements",
      "section_title": true,
      "ja": "3.2。オペレータの要件に対応"
    },
    {
      "indent": 3,
      "text": "NETCONF and YANG address many of the issues raised in the IAB NM workshop.",
      "ja": "NETCONFとYANGは、IAB NMのワークショップで提起された問題の多くを解決します。"
    },
    {
      "indent": 3,
      "text": "o Ease of use: YANG is designed to be human friendly, simple, and readable. Many tricky issues remain due to the complexity of the problem domain, but YANG strives to make them more visible and easier to deal with.",
      "ja": "O使いやすさ：YANGは、優しい人間シンプル、かつ読みやすいように設計されています。多くの厄介な問題は、問題のドメインの複雑さのために残っているが、YANGは、彼らがより多くの目に見えるし、対処しやすい作りに努めています。"
    },
    {
      "indent": 3,
      "text": "o Configuration and state data: YANG clearly divides configuration data from other types of data.",
      "ja": "O構成と状態データ：YANGは明らかに他の種類のデータから構成データを分割します。"
    },
    {
      "indent": 3,
      "text": "o Transactions: NETCONF provides a simple transaction mechanism.",
      "ja": "Oトランザクション：NETCONFは、単純な取引メカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "o Generation of deltas: A YANG module gives enough information to generate the delta needed to change between two configuration data sets.",
      "ja": "Oデルタの生成：YANGモジュールは、2つの構成データ・セット間で変更するために必要なデルタを生成するのに十分な情報を与えます。"
    },
    {
      "indent": 3,
      "text": "o Dump and restore: NETCONF gives the ability to save and restore configuration data. This can also be performed for a specific YANG module.",
      "ja": "Oダンプとリストア：NETCONFは、構成データを保存し、復元する機能を提供します。また、これは、特定のYANGモジュールに対して実行することができます。"
    },
    {
      "indent": 3,
      "text": "o Network-wide configuration: NETCONF supports robust network-wide configuration transactions via the commit and confirmed-commit capabilities. When a change is attempted that affects multiple devices, these capabilities simplify the management of failure scenarios, resulting in the ability to have transactions that will dependably succeed or fail atomically.",
      "ja": "Oネットワーク全体の設定：NETCONFはコミットして確認し、コミット機能を介して、堅牢なネットワーク全体の設定トランザクションをサポートしています。変更が複数のデバイスに影響を与えるしようとしているときは、これらの機能はdependably成功するか失敗するアトミックトランザクションを持っている能力で、その結果、障害シナリオの管理を簡素化。"
    },
    {
      "indent": 3,
      "text": "o Text-friendly: YANG modules are very text friendly, as is the data they define.",
      "ja": "Oテキストに優しい：それらが定義するデータがあるとしてYANGモジュールは非常に、友好テキストです。"
    },
    {
      "indent": 3,
      "text": "o Configuration handling: NETCONF addresses the ability to distinguish between distributing configuration data and activating it.",
      "ja": "O構成の取り扱い：NETCONFは、構成データを配布し、それを活性化区別する能力に対応しています。"
    },
    {
      "indent": 3,
      "text": "o Task-oriented: A YANG module can define specific tasks as RPC operations. A client can choose to invoke the RPC operation or to access any underlying data directly.",
      "ja": "Oタスク指向：YANGモジュールは、RPC操作のような特定のタスクを定義することができます。クライアントがRPC操作を呼び出すために、または直接任意の基礎となるデータにアクセスすることを選択することができます。"
    },
    {
      "indent": 3,
      "text": "o Full coverage: YANG modules can be defined that give full coverage to all the native abilities of the device. Giving this access avoids the need to resort to the command line interface (CLI) using tools such as Expect [SWEXPECT].",
      "ja": "完全なカバレッジ○：YANGモジュールは、デバイスのすべてのネイティブの能力への完全なカバレッジを与えるように定義することができます。このアクセス権を与えることは、このような[SWEXPECT]期待などのツールを使用して、コマンドラインインタフェース（CLI）に頼る必要がなくなります。"
    },
    {
      "indent": 3,
      "text": "o Timeliness: YANG modules can be tied to CLI operations, so all native operations and data are immediately available.",
      "ja": "Oの適時性：YANGモジュールは、CLI操作に接続することができますので、すべてのネイティブの操作とデータがすぐに利用できます。"
    },
    {
      "indent": 3,
      "text": "o Implementation difficulty: YANG's flexibility enables modules that can be more easily implemented. Adding \"features\" and replacing \"third normal form\" with a natural data hierarchy should reduce complexity.",
      "ja": "O実装の難易度：YANGの柔軟性がより容易に実現することができ、モジュールを可能にします。 「機能」を追加し、複雑さを低減する必要があり、天然データ階層で「第3正規形」を置き換えます。"
    },
    {
      "indent": 3,
      "text": "o Simple data modeling language: YANG has sufficient power to be usable in other situations. In particular, on-box API and native CLI can be integrated to achieve simplification of the infrastructure.",
      "ja": "単純なデータモデリング言語O：YANGは、他の状況で使用できるように十分なパワーを持っています。具体的には、上のボックスAPIとネイティブCLIは、インフラストラクチャの簡素化を達成するために統合することができます。"
    },
    {
      "indent": 3,
      "text": "o Internationalization: YANG uses UTF-8 [RFC3629] encoded Unicode characters.",
      "ja": "O国際：YANGは、UTF-8 [RFC3629]は、Unicode文字をエンコードされた使用します。"
    },
    {
      "indent": 3,
      "text": "o Event correlation: YANG integrates RPC operations, notification, configuration, and state data, enabling internal references. For example, a field in a notification can be tagged as pointing to a BGP peer, and the client application can easily find that peer in the configuration data.",
      "ja": "Oイベント相関：YANGは、内部参照を可能にする、RPC動作、通知、設定、および状態データを統合します。例えば、通知におけるフィールドは、BGPピアを指しとしてタグ付けすることができ、クライアントアプリケーションは容易コンフィギュレーションデータにそのピアを見つけることができます。"
    },
    {
      "indent": 3,
      "text": "o Implementation costs: Significant effort has been made to keep implementation costs as low as possible.",
      "ja": "O実装コスト：重要な努力は、できるだけ低い実装コストを維持するために行われています。"
    },
    {
      "indent": 3,
      "text": "o Human-friendly syntax: YANG's syntax is optimized for the reader, specifically the reviewer on the basis that this is the most common human interaction.",
      "ja": "O人にやさしい構文：YANGの構文は、これが最も一般的な人間の相互作用であることに基づいて、読者のために特別に審査を最適化されています。"
    },
    {
      "indent": 3,
      "text": "o Post-processing: Use of XML will maximize the opportunities for post-processing of data, possibly using XML-based technologies like XPath [W3CXPATH], XQuery [W3CXQUERY], and XSLT [W3CXSLT].",
      "ja": "O後処理：XMLの使用は、おそらくXPathの[W3CXPATH]、XQueryの[W3CXQUERY]、およびXSLT [W3CXSLT]のようなXMLベースの技術を使用して、データの後処理のための機会を最大化します。"
    },
    {
      "indent": 3,
      "text": "o Semantic mismatch: Richer, more descriptive data models will reduce the possibility of semantic mismatch. With the ability to define new primitives, YANG modules will be more specific in content, allowing more enforcement of rules and constraints.",
      "ja": "Oセマンティック不一致：より豊かな、より記述データモデルは、セマンティック不一致の可能性を削減します。新しいプリミティブを定義する機能と、YANGモジュールは、ルールや制約のより多くの執行を許可する、コンテンツでより具体的になります。"
    },
    {
      "indent": 3,
      "text": "o Security: NETCONF runs over transport protocols secured by SSH or TLS, allowing secure communications and authentication using well-trusted technology. The secure transport can use existing key and credential management infrastructure, reducing deployment costs.",
      "ja": "Oセキュリティ：NETCONFは、SSHまたはTLS、よく信頼できる技術を使用して安全な通信と認証を可能にすることにより確保のトランスポートプロトコル上で動作します。安全な輸送は、導入コストの削減、既存の鍵と資格情報管理インフラストラクチャを使用することができます。"
    },
    {
      "indent": 3,
      "text": "o Reliable: NETCONF and YANG are solid and reliable technologies. NETCONF is connection based, and includes automatic recovery mechanisms when the connection is lost.",
      "ja": "O信頼性：NETCONFとYANGは、固体と信頼性の高い技術です。 NETCONFは、接続ベースで、接続が失われたときに自動回復メカニズムを含んでいます。"
    },
    {
      "indent": 3,
      "text": "o Delta friendly: YANG-based models support operations that are delta friendly. Add, change, insert, and delete operations are all well defined.",
      "ja": "Oデルタ優しい：YANGベースのモデルは、デルタフレンドリーな操作をサポートしています。 、変更、追加の挿入、および削除の操作はすべてが順調に定義されています。"
    },
    {
      "indent": 3,
      "text": "o Method-oriented: YANG allows new RPC operations to be defined, including an operation name, which is essentially a method. The input and output parameters of the RPC operations are also defined in the YANG module.",
      "ja": "Oメソッド指向：YANGは、本質的な方法である操作名を含む、新しいRPC操作が定義されることを可能にします。 RPC操作の入力および出力パラメータもYANGモジュールで定義されています。"
    },
    {
      "indent": 0,
      "text": "3.3. Roles in Building Solutions",
      "section_title": true,
      "ja": "3.3。ビルソリューションのロール"
    },
    {
      "indent": 3,
      "text": "Building NETCONF- and YANG-based solutions requires interacting with many distinct groups. Modelers must understand how to build useful models that give structure and meaning to data while maximizing the flexibility of that data to \"future proof\" their work. Reviewers need to quickly determine if that structure is accurate. Device developers need to code that data model into their devices, and application developers need to code their applications to take advantage of that data model. There are a variety of strategies for performing each piece of this work. This section discusses some of those strategies.",
      "ja": "ビルNETCONF-とYANGベースのソリューションは、多くの異なるグループとの対話が必要です。モデラーは、「未来の証拠」自分の仕事にそのデータの柔軟性を最大化しながら、データに構造と意味を与える有用なモデルを構築する方法を理解する必要があります。レビュアーは、その構造が正確であるかどうかを迅速に判定する必要があります。デバイスの開発者は、デバイスにそのデータモデルをコーディングする必要があり、アプリケーション開発者は、そのデータモデルを活用するためにアプリケーションをコーディングする必要があります。この作品の各部分を実行するための様々な戦略があります。ここでは、これらの戦略のいくつかを説明します。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Modeler",
      "section_title": true,
      "ja": "3.3.1。モデラ"
    },
    {
      "indent": 3,
      "text": "The modeler defines a data model based on their in-depth knowledge of the problem domain being modeled. This model should be as simple as possible, but should balance complexity with expressiveness. The organization of the model not only should target the current model but also should allow for extensibility from other modules and for adaptability to future changes.",
      "ja": "モデラーはモデル化されている問題のドメインのそれらの深い知識に基づいて、データ・モデルを定義します。このモデルは、できるだけ簡単にする必要がありますが、表現力と複雑さのバランスをとる必要があります。モデルの組織は、現在のモデルを対象とすべきであるだけでなく、他のモジュールからの拡張のためと将来の変化への適応を可能にしなければならないだけではなく。"
    },
    {
      "indent": 3,
      "text": "Additional modeling issues are discussed in Section 4.",
      "ja": "追加のモデリングの問題は、第4節で議論されています。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Reviewer",
      "section_title": true,
      "ja": "3.3.2。レビュー"
    },
    {
      "indent": 3,
      "text": "The reviewer role is perhaps the most important and the time reviewers are willing to give is precious. To help the reviewer, YANG stresses readability, with a human-friendly syntax, natural data hierarchy, and simple, concise statements.",
      "ja": "校閲者の役割は、おそらく最も重要であり、レビューアが与えて喜んでいる時間は貴重です。校閲者を支援するために、YANGは、人に優しい構文、自然なデータ階層、および簡単な、簡潔な文で、読みやすさを強調しています。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Device Developer",
      "section_title": true,
      "ja": "3.3.3。デバイスの開発"
    },
    {
      "indent": 3,
      "text": "The YANG model tells the device developer what data is being modeled. The developer reads the YANG models and writes code that supports the model. The model describes the data hierarchy and associated constraints, and the description and reference material helps the developer understand how to transform the model's view into the device's native implementation.",
      "ja": "YANGモデルは、モデル化されているもののデータ機器の開発者に伝えます。開発者は、YANGモデルを読み込み、モデルをサポートするコードを書き込みます。このモデルは、データの階層構造とそれに関連する制約、および説明を説明し、参考資料は、開発者がデバイスのネイティブ実装に、モデルのビューを変換する方法を理解するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "3.3.3.1. Generic Content Support",
      "section_title": true,
      "ja": "3.3.3.1。汎用コンテンツのサポート"
    },
    {
      "indent": 3,
      "text": "The YANG model can be compiled into a YANG-based engine for either the client or server side. Incoming data can be validated, as can outgoing data. The complete configuration datastore may be validated in accordance with the constraints described in the data model.",
      "ja": "YANGモデルは、クライアントまたはサーバ側のいずれかのためYANGベースのエンジンにコンパイルすることができます。受信データは、缶発信データとして、検証することができます。完全なコンフィギュレーションデータストアは、データモデルに記載制約に従って検証することができます。"
    },
    {
      "indent": 3,
      "text": "Serializers and de-serializers for generating and receiving NETCONF content can be driven by the meta-data in the model. As data is received, the meta-data is consulted to ensure the validity of incoming XML elements.",
      "ja": "NETCONFコンテンツを生成し、受信するためのシリアライザとデシリアライザーは、モデル内のメタデータによって駆動することができます。データが受信されると、メタデータが入ってくるXML要素の妥当性を確保するために参照されます。"
    },
    {
      "indent": 0,
      "text": "3.3.3.2. XML Definitions",
      "section_title": true,
      "ja": "3.3.3.2。 XMLの定義"
    },
    {
      "indent": 3,
      "text": "The YANG module dictates the XML encoding for data sent via NETCONF. The rules that define the encoding are fixed, so the YANG module can be used to ascertain whether a specific NETCONF payload is obeying the rules.",
      "ja": "YANGモジュールはNETCONFを介して送信されたデータのXMLエンコーディングを決定します。 YANGモジュールは、特定のNETCONFペイロードがルールに従っているかどうかを確認するために使用することができるように符号化を定義する規則は、固定されています。"
    },
    {
      "indent": 0,
      "text": "3.3.4. Application Developer",
      "section_title": true,
      "ja": "3.3.4。アプリケーション開発"
    },
    {
      "indent": 3,
      "text": "The YANG module tells the application developer what data can be modeled. Developers can inspect the modules and take one of three distinct views. In this section, we will consider them and the impact of YANG on their design. In the real world, most applications are a mixture of these approaches.",
      "ja": "YANGモジュールは、データをモデル化することができるか、アプリケーション開発者に伝えます。開発者は、モジュールを検査し、三つの異なるビューのいずれかを取ることができます。このセクションでは、我々は彼らとその設計上のYANGの影響を検討します。現実の世界では、ほとんどのアプリケーションは、これらのアプローチの混合物です。"
    },
    {
      "indent": 0,
      "text": "3.3.4.1. Hard Coded",
      "section_title": true,
      "ja": "3.3.4.1。ハードコードされました"
    },
    {
      "indent": 3,
      "text": "An application can be coded against the specific, well-known contents of YANG modules, implementing their organization, rules, and logic directly with explicit knowledge. For example, a script could be written to change the domain name of a set of devices using a standard YANG module that includes such a leaf node. This script takes the new domain name as an argument and inserts it into a string containing the rest of the XML encoding as required by the YANG module. This content is then sent via NETCONF to each of the devices.",
      "ja": "アプリケーションは、明示的な知識を直接、組織、ルール、及びロジックを実装する、YANGモジュールの特定、周知のコンテンツに対して符号化することができます。例えば、スクリプトは、リーフノードを含む標準YANGモジュールを使用してデバイスのセットのドメイン名を変更するために書くことができます。このスクリプトは、引数として新しいドメイン名を取り、YANGモジュールで必要とされるXMLエンコーディングの残りの部分を含む文字列に挿入します。このコンテンツは、デバイスのそれぞれにNETCONFを経由して送信されます。"
    },
    {
      "indent": 3,
      "text": "This type of application is useful for small, fixed problems where the cost and complexity of flexibility are overwhelmed by the ease of hard coding direct knowledge into the application.",
      "ja": "このタイプのアプリケーションは、柔軟性のコストと複雑さをアプリケーションにハードコーディング直接的な知識の容易さに圧倒されている小さな、修正された問題のために有用です。"
    },
    {
      "indent": 0,
      "text": "3.3.4.2. Bottom Up",
      "section_title": true,
      "ja": "3.3.4.2。一気飲み"
    },
    {
      "indent": 3,
      "text": "An application may take a generic, bottom-up approach to configuration, concentrating on the device's data directly and treating that data without specific understanding.",
      "ja": "アプリケーションが直接デバイスのデータに集中し、具体的な理解せずに、そのデータを処理し、コンフィギュレーションへの一般的な、ボトムアップアプローチを取ることがあります。"
    },
    {
      "indent": 3,
      "text": "YANG modules may be used to drive the operation of the YANG equivalent of a \"MIB browser\". Such an application manipulates the device's configuration data based on the data organization contained in the YANG module. For example, a GUI may present a straightforward visualization where elements of the YANG hierarchy are depicted in a hierarchy of folders or GUI panels. Clicking on a line expands to the contents of the matching XML hierarchy.",
      "ja": "YANGモジュールは、「MIBブラウザ」のYANGと同等の動作を駆動するために使用されてもよいです。そのようなアプリケーションは、YANGモジュールに含まれるデータの編成に基づいて、デバイスのコンフィギュレーション・データを操作します。例えば、GUIは、YANG階層の要素はフォルダまたはGUIパネルの階層に示されている直接的視覚化を提示することができます。行をクリックすると、一致するXMLの階層の内容に展開されます。"
    },
    {
      "indent": 3,
      "text": "This type of GUI can easily be built by generating XSLT stylesheets from the YANG data models. An XSLT engine can then be used to turn configuration data into a set of web pages.",
      "ja": "GUIのこのタイプは、容易YANGデータモデルからXSLTスタイルシートを生成することによって構築することができます。 XSLTエンジンは、ウェブページのセットに設定データを有効に使用することができます。"
    },
    {
      "indent": 3,
      "text": "The YANG modules allow the application to enforce a set of constraints without understanding the semantics of the YANG module.",
      "ja": "YANGモジュールは、アプリケーションがYANGモジュールの意味を理解せずに一連の制約を強制することができます。"
    },
    {
      "indent": 0,
      "text": "3.3.4.3. Top Down",
      "section_title": true,
      "ja": "3.3.4.3。トップダウン"
    },
    {
      "indent": 3,
      "text": "In contrast to the bottom-up approach, the top-down approach allows the application to take a view of the configuration data that is distinct from the standard and/or proprietary YANG modules. The application is free to construct its own model for data organization and to present this model to the user. When the application needs to transmit data to a device, the application transforms its data from the problem-oriented view of the world into the data needed for that particular device. This transformation is under the control and maintenance of the application, allowing the transformation to be changed and updated without affecting the device.",
      "ja": "ボトムアップアプローチとは対照的に、トップダウンアプローチでは、アプリケーションは、標準および/またはプロプライエタリYANGモジュールとは区別されるコンフィギュレーションデータのビューを取ることを可能にします。アプリケーションは、データ編成のための独自のモデルを構築し、ユーザーにこのモデルを提示する自由です。アプリケーションがデバイスにデータを送信する必要がある場合、アプリケーションは、その特定のデバイスに必要なデータへの世界の問題指向のビューからそのデータを変換します。この変換は、変換装置に影響を与えることなく変更および更新することができるように、アプリケーションの制御及びメンテナンス中です。"
    },
    {
      "indent": 3,
      "text": "For example, an application could be written that models VPNs in a network-oriented view. The application would need to transform these high-level VPN definitions into the configuration data that would be handed to any particular device within a VPN.",
      "ja": "例えば、アプリケーションは、ネットワーク指向のビューにおけるモデルのVPNのことを書くことができます。アプリケーションは、VPN内の任意の特定の装置に渡されるであろうコンフィギュレーションデータにこれらの高レベルのVPNの定義を変換する必要があります。"
    },
    {
      "indent": 3,
      "text": "Even in this approach, YANG is useful since it can be used to model the VPN. For example, the following VPN straw-man models a list of VPNs, each with a protocol, a topology, a list of member interfaces, and a list of classifiers.",
      "ja": "VPNをモデル化するために使用することができますので、でも、このアプローチでは、YANGは便利です。例えば、以下のVPNストローマンモデルのVPNのリスト、プロトコル、トポロジー、メンバーインターフェイスのリスト、および分類のリストをそれぞれ。"
    },
    {
      "indent": 7,
      "text": "list example-bgpvpn {\n    key name;\n    leaf name { ... }\n    leaf protocol {\n        type enumeration {\n            enum bgpvpn;\n            enum l2vpn;\n        }\n    }\n    leaf topology {\n        type enumeration {\n            enum hub-n-spoke;\n            enum mesh;\n        }\n    }\n    list members {\n        key \"device interface\";\n        leaf device { ... }\n        leaf interface { ... }\n    }\n    list classifiers {\n        ...\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The application can use such a YANG module to drive its operation, building VPN instances in a database and then pushing the configuration for those VPNs to individual devices either using a standard device model (e.g., example-bgpvpn.yang) or by transforming that standard device content into some proprietary format for devices that do not support that standard.",
      "ja": "アプリケーションは、データベース内のVPNインスタンスを構築した後、個々のデバイスにそれらのVPNの構成を押すいずれかの標準的なデバイス・モデル（例えば、実施例-bgpvpn.yang）を使用して、またはその標準を形質転換することにより、その動作を駆動するようYANGモジュールを使用することができその標準をサポートしていないデバイスのためのいくつかの独自のフォーマットへのデバイスのコンテンツ。"
    },
    {
      "indent": 0,
      "text": "4. Modeling Considerations",
      "section_title": true,
      "ja": "4.モデルの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section discusses considerations the modeler should be aware of while developing models in YANG.",
      "ja": "このセクションでは、モデラーがYANGでモデルを開発中に注意すべき考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Default Values",
      "section_title": true,
      "ja": "4.1。デフォルト値"
    },
    {
      "indent": 3,
      "text": "The concept of default values is simple, but their details, representation, and interaction with configuration data can be difficult issues. NETCONF leaves default values as a data model issue, and YANG gives flexibility to the device implementation in terms of how default values are handled. The requirement is that the device \"MUST operationally behave as if the leaf was present in the data tree with the default value as its value\". This gives the device implementation choices in how default values are handled.",
      "ja": "デフォルト値の概念は簡単ですが、その詳細、表現、およびコンフィギュレーション・データとの相互作用が困難な問題ことができます。 NETCONFは、データモデルの問題としてデフォルト値を残して、YANGは、デフォルト値をどのように扱うかという点でデバイスの実装に柔軟性を提供します。要件は、デバイスが「運用上の葉は、その値としてデフォルト値を持つデータツリーに存在したかのように振る舞うしなければならない」ということです。これは、デフォルト値の処理方法でデバイスの実装の選択肢を提供します。"
    },
    {
      "indent": 3,
      "text": "One choice is to view the configuration as a set of instructions for how the device should be configured. If a data value that is given as part of those instructions is the default value, then it should be retained as part of the configuration, but if it is not explicitly given, then the value is not considered to be part of the configuration.",
      "ja": "一つの選択肢は、デバイスが構成されるべきかについての命令セットとして構成を表示することです。これらの命令の一部として与えられているデータ値が既定値であれば、それは構成の一部として保持しなければならないが、それが明示的に指定されていない場合、その値は、構成の一部とは見なされません。"
    },
    {
      "indent": 3,
      "text": "Another choice is to trim values that are identical to the default values, implicitly removing them from the configuration datastore. The act of setting a leaf to its default value effectively deletes that leaf.",
      "ja": "もう一つの選択肢は、暗黙のうちに、構成データストアから削除し、デフォルト値と同じである値をトリミングすることです。デフォルト値に葉を設定する行為は、効果的にその葉を削除します。"
    },
    {
      "indent": 3,
      "text": "The device could also choose to report all default values, regardless of whether they were explicitly set. This choice eases the work of a client that needs default values, but may significantly increase the size of the configuration data.",
      "ja": "デバイスはまたかかわらずが明示的に設定されているかどうかの、すべてのデフォルト値を報告することを選択することができます。この選択は、デフォルト値を必要とするクライアントの作業を容易にしますが、大幅にコンフィギュレーション・データのサイズを増大させることができます。"
    },
    {
      "indent": 3,
      "text": "These choices reflect the default handling schemes of widely deployed networking devices and supporting them allows YANG to reduce implementation and deployment costs of YANG-based models.",
      "ja": "これらの選択肢は広く展開されているネットワーク機器のデフォルト処理の仕組みを反映し、それらをサポートすることYANG YANGは、ベースモデルの実装と展開コストを削減することができます。"
    },
    {
      "indent": 3,
      "text": "When the client retrieves data from the device, it must be prepared to handle the absence of leaf nodes with the default value, since the server is not required to send such leaf elements. This permits the device to implement either of the first two default handling schemes given above.",
      "ja": "クライアントがデバイスからデータを取得すると、サーバーは、このようなリーフ要素を送信する必要がないので、デフォルト値を持つリーフノードが存在しないことを処理するために準備する必要があります。これは、上記の最初の2つのデフォルト処理の仕組みのいずれかを実装するために、デバイスを許可します。"
    },
    {
      "indent": 3,
      "text": "Regardless of the implementation choice, the device can support the \"with-defaults\" capability [RFC6243] and give the client the ability to select the desired handling of default values.",
      "ja": "かかわらず、実装の選択の、デバイスが「と、デフォルトで」機能[RFC6243]をサポートし、クライアントをデフォルト値の所望の取り扱いを選択する機能を与えることができます。"
    },
    {
      "indent": 3,
      "text": "When evaluating the XPath expressions for constraints like \"must\" and \"when\", the evaluation context for the expressions will include any appropriate default values, so the modeler can depend on consistent behavior from all devices.",
      "ja": "「しなければならない」と「」のような制約のために、XPath式を評価する際モデラーがすべてのデバイスからの一貫した動作に依存することができますので、式の評価コンテキストは、任意の適切なデフォルト値が含まれます。"
    },
    {
      "indent": 0,
      "text": "4.2. Compliance",
      "section_title": true,
      "ja": "4.2。コンプライアンス"
    },
    {
      "indent": 3,
      "text": "In developing good data models, there are many conflicting interests the data modeler must keep in mind. Modelers need to be aware of five issues with models and devices:",
      "ja": "優れたデータモデルを開発する際に、データモデラーが心に留めておく必要があり、多くの利害対立があります。モデラーは、モデルやデバイスとの5つの課題に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "o usefulness",
      "ja": "Oの有用性"
    },
    {
      "indent": 3,
      "text": "o compliance",
      "ja": "Oのコンプライアンス"
    },
    {
      "indent": 3,
      "text": "o flexibility",
      "ja": "Oの柔軟性"
    },
    {
      "indent": 3,
      "text": "o extensibility",
      "ja": "Oの拡張性"
    },
    {
      "indent": 3,
      "text": "o deviations",
      "ja": "O偏差"
    },
    {
      "indent": 3,
      "text": "For a model to be interesting, it must be useful, solving a problem in a more direct or more powerful way than can be accomplished without the model. The model should maximize the usefulness of the model within the problem domain.",
      "ja": "モデルは興味深いものにするためには、モデルすることなく達成することができるよりも直接的またはより強力な方法で問題を解決する、便利でなければなりません。モデルは、問題ドメイン内のモデルの有用性を最大化すべきです。"
    },
    {
      "indent": 3,
      "text": "Modelers should build models that maximize the number of devices that can faithfully implement the model. If the model is drawn too narrowly, or includes too many assumptions about the device, then the difficulty and cost of accurately implementing the model will lead to low-quality implementations and interoperability issues, and will reduce the value of the model.",
      "ja": "モデラーは忠実にモデルを実装できるデバイスの数を最大化モデルを構築すべきです。モデルがあまりにも狭く描かれた、またはデバイスについて、あまりにも多くの仮定が含まれている場合は、正確なモデルを実装することの難しさとコストが低品質の実装と相互運用性の問題につながる、とモデルの値を小さくします。"
    },
    {
      "indent": 3,
      "text": "Modelers can use the \"feature\" statement in their models to give the device some flexibility by partitioning their model and allowing the device to indicate which portions of the model are implemented on the device. For example, if the model includes some \"logging\" feature, a device with no storage facilities for the log can tell the client that it does not support this feature of the model.",
      "ja": "モデラーは、モデルの部分は、デバイスに実装されているかを示すために、デバイスを彼らのモデルを分割し、許可することで、デバイスにいくつかの柔軟性を与えるために彼らのモデルでは、「機能」ステートメントを使用することができます。モデルは、いくつかの「ログ」機能が含まれている場合たとえば、ログの無い貯蔵施設を備えたデバイスは、それがモデルのこの機能をサポートしていないことをクライアントに伝えることができます。"
    },
    {
      "indent": 3,
      "text": "Models can be extended via the \"augment\" statement, and the modeler should consider how their model is likely to be extended. These augmentations can be defined by vendors, applications, or standards bodies.",
      "ja": "モデルは「強化」声明を経由して拡張することができ、かつモデラーは、彼らのモデルが拡張される可能性が高い方法を検討する必要があります。これらの拡張製品は、ベンダー、アプリケーション、または標準化団体によって定義することができます。"
    },
    {
      "indent": 3,
      "text": "Deviations are a means of allowing the devices to indicate where its implementation is not in full compliance with the model. For example, once a model is published, an implementer may decide to make a particular node configurable, where the standard model describes it as state data. The implementation reports the value normally and may declare a deviation that this device behaves in a different manner than the standard. Applications capable of discovering this deviation can make allowances, but applications that do not discover the deviation can continue treating the implementation as if it were compliant.",
      "ja": "偏差は、その実装がモデルを完全に遵守していない場所を示すためにデバイスを可能にする手段です。モデルが公開されると、例えば、実装者は、標準モデルは、状態データとして説明設定特定のノードを作成することを決定することができます。実装は、通常、値を報告し、このデバイスは、標準とは異なるように動作偏差を宣言することができます。この偏差を発見できるアプリケーションは、手当を作ることができますが、それに準拠しているかのように偏差を発見していないアプリケーションでは、実装の治療を続けることができます。"
    },
    {
      "indent": 3,
      "text": "Rarely, implementations may make decisions that prevent compliance with the standard. Such occasions are regrettable, but they remain a part of reality, and modelers and application writers ignore them at their own risk. An implementation that emits an integer leaf as \"cow\" would be difficult to manage, but applications should expect to encounter such misbehaving devices in the field.",
      "ja": "まれに、実装は、標準の遵守を妨げる意思決定を行うことがありません。このような機会は残念ですが、彼らは現実の一部残り、モデラーやアプリケーションの作成者は、自分の責任でそれらを無視します。 「牛」として、整数の葉を発する実装が管理するのは難しいだろうが、アプリケーションは、フィールドに、このような誤動作デバイスに遭遇することを期待すべきです。"
    },
    {
      "indent": 3,
      "text": "Despite this, both client and server should view the YANG module as a contract, with both sides agreeing to abide by the terms. The modeler should be explicit about the terms of such a contract, and both client and server implementations should strive to faithfully and accurately implement the data model described in the YANG module.",
      "ja": "それにもかかわらず、クライアントとサーバの両方は両側が条件に従うことに同意し、契約としてYANGモジュールを表示しなければなりません。モデラーは、このような契約条件について明示的であるべきであり、クライアントとサーバーの両方の実装を忠実かつ正確YANGモジュールに記述されたデータモデルを実装するために努力すべきです。"
    },
    {
      "indent": 0,
      "text": "4.3. Data Distinctions",
      "section_title": true,
      "ja": "4.3。データの区別"
    },
    {
      "indent": 3,
      "text": "The distinction between configuration data, operational state data, and statistics is important to understand for data model writers and people who plan to extend the NETCONF protocol. This section first discusses some background and then provides a definition and some examples.",
      "ja": "コンフィギュレーション・データ、動作状態データ、および統計の区別はNETCONFプロトコルを拡張することを計画し、データモデルの作家や人々のために理解することが重要です。このセクションでは、最初のいくつかの背景を説明した後、定義といくつかの例を提供します。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Background",
      "section_title": true,
      "ja": "4.3.1。バックグラウンド"
    },
    {
      "indent": 3,
      "text": "During the IAB NM workshop, operators did formulate the following two requirements, as listed in [RFC3535]:",
      "ja": "[RFC3535]に記載されているようIAB NMのワークショップで、事業者は、次の二つの要件を策定しました："
    },
    {
      "indent": 4,
      "text": "2. It is necessary to make a clear distinction between configuration data, data that describes operational state, and statistics. Some devices make it very hard to determine which parameters were administratively configured and which were obtained via other mechanisms such as routing protocols.",
      "ja": "2.コンフィギュレーション・データ、動作状態を記述するデータ、および統計の間に明確な区別をする必要があります。いくつかのデバイスは、それが非常に難しい管理構成し、ルーティングプロトコルなどの他の機構を介して取得したどのパラメータを決定することを可能にします。"
    },
    {
      "indent": 4,
      "text": "3. It is required to be able to fetch separately configuration data, operational state data, and statistics from devices, and to be able to compare these between devices.",
      "ja": "3.デバイスとは別に設定データ、動作状態データ、および統計情報を取得するために、これらのデバイス間で比較できるようにすることが可能であることが要求されます。"
    },
    {
      "indent": 3,
      "text": "The NETCONF protocol defined in RFC 4741 distinguishes two types of data -- namely, configuration data and state data:",
      "ja": "RFC 4741で定義されたNETCONFプロトコルは、データの2種類の区別 - すなわち、構成データと状態データ："
    },
    {
      "indent": 6,
      "text": "Configuration data is the set of writable data that is required to transform a system from its initial default state into its current state.",
      "ja": "コンフィギュレーション・データは、現在の状態にその初期デフォルト状態からシステムを変換するために必要とする書き込み可能なデータのセットです。"
    },
    {
      "indent": 6,
      "text": "State data is the additional data on a system that is not configuration data such as read-only status information and collected statistics.",
      "ja": "状態データは、読み取り専用のステータス情報などのデータを設定および統計情報を収集されていないシステム上の追加データです。"
    },
    {
      "indent": 3,
      "text": "NETCONF does not follow the distinction formulated by the operators between configuration data, operational state data, and statistical data, since it considers state data to include both statistics and operational state data.",
      "ja": "それは統計および動作状態データの両方を含む状態データを考慮するのでNETCONFは、コンフィギュレーションデータ、動作状態データ、統計データとの間のオペレータによって処方区別に従いません。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Definitions",
      "section_title": true,
      "ja": "4.3.2。定義"
    },
    {
      "indent": 3,
      "text": "Below is a definition for configuration data, operational state data, and statistical data. The definition borrows from previous work.",
      "ja": "以下は、構成データ、動作状態データ、及び統計データの定義です。定義は、前作から借ります。"
    },
    {
      "indent": 3,
      "text": "o Configuration data is the set of writable data that is required to transform a system from its initial default state into its current state [RFC4741].",
      "ja": "Oコンフィギュレーション・データは、現在の状態[RFC4741]にその初期デフォルト状態からシステムを変換するために必要とする書き込み可能なデータのセットです。"
    },
    {
      "indent": 3,
      "text": "o Operational state data is a set of data that has been obtained by the system at runtime and influences the system's behavior similar to configuration data. In contrast to configuration data, operational state is transient and modified by interactions with internal components or other systems via specialized protocols.",
      "ja": "O動作状態データは、実行時にシステムによって得られたデータの集合であり、コンフィギュレーションデータと同様、システムの動作に影響を与えます。コンフィギュレーションデータとは対照的に、動作状態が過渡及び内部コンポーネントまたは専用プロトコルを介して他のシステムとの相互作用によって修飾されます。"
    },
    {
      "indent": 3,
      "text": "o Statistical data is the set of read-only data created by a system itself. It describes the performance of the system and its components.",
      "ja": "O統計データは、システム自体によって作成された読み取り専用データの集合です。これは、システムのパフォーマンスとそのコンポーネントについて説明します。"
    },
    {
      "indent": 3,
      "text": "The following examples help to clarify the difference between configuration data, operational state data, and statistical data.",
      "ja": "次の例では、構成データ、動作状態データ、及び統計データとの違いを明確にするのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "4.3.2.1. Example 1: IP Routing Table",
      "section_title": true,
      "ja": "4.3.2.1。例1：IPルーティングテーブル"
    },
    {
      "indent": 3,
      "text": "IP routing tables can contain entries that are statically configured (configuration data) as well as entries obtained from routing protocols such as OSPF (operational state data). In addition, a routing engine might collect statistics like how often a particular routing table entry has been used.",
      "ja": "IPルーティングテーブルは、静的に構成されているエントリ（構成データ）ならびにOSPF（動作状態データ）などのルーティングプロトコルから取得したエントリを含むことができます。また、ルーティングエンジンは、特定のルーティングテーブルのエントリが使用されているどのくらいの頻度などの統計情報を収集する場合があります。"
    },
    {
      "indent": 0,
      "text": "4.3.2.2. Example 2: Interfaces",
      "section_title": true,
      "ja": "4.3.2.2。例2：インタフェース"
    },
    {
      "indent": 3,
      "text": "Network interfaces usually come with a large number of attributes that are specific to the interface type and in some cases specific to the cable plugged into an interface. Examples are the maximum transmission unit of an interface or the speed detected by an Ethernet interface.",
      "ja": "ネットワークインタフェースは、通常、インターフェイスタイプおよびインターフェイスに接続ケーブルに固有のいくつかの場合に特定の属性の多くが付属しています。例としては、インターフェースの最大送信単位またはイーサネットインターフェイスによって検出された速度です。"
    },
    {
      "indent": 3,
      "text": "In many deployments, systems use the interface attributes detected when an interface is initialized. As such, these attributes constitute operational state. However, there are usually provisions to overwrite the discovered attributes with static configuration data, like for example configuring the interface MTU to use a specific value or forcing an Ethernet interface to run at a given speed.",
      "ja": "多くの配備で、システムはインターフェイスが初期化されるときに検出されたインタフェースの属性を使用します。そのため、これらの属性は、動作状態を構成しています。しかし、通常、例えば特定の値を使用するようにインターフェイスMTUを設定するか、所定の速度で実行するようにイーサネットインターフェイスを強制するように、静的構成データで発見された属性を上書きする規定があります。"
    },
    {
      "indent": 3,
      "text": "The system will record statistics (counters) measuring the number of packets, bytes, and errors received and transmitted on each interface.",
      "ja": "システムは、受信された各インタフェース上で送信されたパケット、バイト、およびエラーの数を測定統計（カウンタ）を記録します。"
    },
    {
      "indent": 0,
      "text": "4.3.2.3. Example 3: Account Information",
      "section_title": true,
      "ja": "4.3.2.3。例3：アカウント情報"
    },
    {
      "indent": 3,
      "text": "Systems usually maintain static configuration information about the accounts on the system. In addition, systems can obtain information about accounts from other sources (e.g., Lightweight Directory Access Protocol (LDAP), Network Information Service (NIS)) dynamically, leading to operational state data. Information about account usage is an example of statistical data.",
      "ja": "システムは、通常、システム上のアカウントに関する静的な設定情報を維持します。また、システムは動作状態データにつながる、動的に（例えば、LDAP（Lightweight Directory Access Protocol）を、ネットワーク情報サービス（NIS））他のソースからのアカウントに関する情報を取得することができます。アカウントの使用状況に関する情報は、統計データの一例です。"
    },
    {
      "indent": 3,
      "text": "Note that configuration data supplied to a system in order to create a new account might be supplemented with additional configuration information determined by the system when the account is being created (such as a unique account id). Even though the system might create such information, it usually becomes part of the static configuration of the system since this data is not transient.",
      "ja": "アカウントは、（例えば、一意のアカウントIDとして）作成されているときに新しいアカウントを作成するためにシステムに供給される構成データは、システムによって決定される追加の構成情報を補充する場合があります。システムは、このような情報を作成する場合でも、このデータが一時的ではないので、それは通常、システムの静的な構成の一部になります。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Implications",
      "section_title": true,
      "ja": "4.3.3。含意"
    },
    {
      "indent": 3,
      "text": "The primary focus of YANG is configuration data. There is no single mechanism defined for the separation of operational state data and statistics since NETCONF treats them both as state data. This section describes several different options for addressing this issue.",
      "ja": "YANGの主な焦点は、コンフィギュレーション・データです。 NETCONFは、状態データとしてそれらの両方を扱いますので、動作状態データと統計の分離のために定義された単一のメカニズムはありません。このセクションでは、この問題に対処するためのいくつかの異なるオプションについて説明します。"
    },
    {
      "indent": 0,
      "text": "4.3.3.1. Data Models",
      "section_title": true,
      "ja": "4.3.3.1。データモデル"
    },
    {
      "indent": 3,
      "text": "The first option is to have data models that explicitly differentiate between configuration data and operational state data. This leads to duplication of data structures and might not scale well from a modeling perspective.",
      "ja": "最初のオプションは、明示的に構成データと動作状態のデータを区別するデータモデルを持つことです。これは、データ構造の重複につながり、モデリングの観点からうまくスケールしない場合があります。"
    },
    {
      "indent": 3,
      "text": "For example, the configured duplex value and the operational duplex value would be distinct leafs in the data model.",
      "ja": "たとえば、構成された二重値と演算二重値は、データモデル内の異なる葉であろう。"
    },
    {
      "indent": 0,
      "text": "4.3.3.2. Additional Operations to Retrieve Operational State",
      "section_title": true,
      "ja": "4.3.3.2。その他の操作は、動作状態を取得するために、"
    },
    {
      "indent": 3,
      "text": "The NETCONF protocol can be extended with new protocol operations that specifically allow the retrieval of all operational state, e.g., by introducing a <get-ops> operation (and perhaps also a <get-stats> operation).",
      "ja": "NETCONFプロトコルは（おそらくも及び<GET-統計>操作）<GET-OPS>操作を導入することにより、具体的には例えば、全ての動作状態の取得を可能にする新しいプロトコル操作で拡張することができます。"
    },
    {
      "indent": 0,
      "text": "4.3.3.3. Introduction of an Operational State Datastore",
      "section_title": true,
      "ja": "4.3.3.3。オペレーショナル・ステートデータストアのご紹介"
    },
    {
      "indent": 3,
      "text": "Another option could be to introduce a new \"configuration\" data store that represents the operational state. A <get-config> operation on the <operational> data store would then return the operational state determining the behavior of the box instead of its static and explicit configuration state.",
      "ja": "別のオプションは、動作状態を表す新しい「設定」データストアを導入する可能性があります。 <操作>データストアの<GET-config>の操作は、代わりにその静的および明示的な設定状態のボックスの動作を決定する動作状態を返します。"
    },
    {
      "indent": 0,
      "text": "4.4. Direction",
      "section_title": true,
      "ja": "4.4。方向"
    },
    {
      "indent": 3,
      "text": "At this time, the only viable solution is to distinctly model the configuration and operational values. The configuration leaf would indicate the desired value, as given by the user, and the operational leaf would indicate the current value, as observed on the device.",
      "ja": "この時点では、唯一の実行可能な解決策は明らかに設定し、動作値をモデル化することです。ユーザによって与えられたような構成の葉は、所望の値を示すであろう、そしてデバイス上に観察されるように動作リーフは、現在の値を示すであろう。"
    },
    {
      "indent": 3,
      "text": "In the duplex example, this would result in two distinct leafs being defined, \"duplex\" and \"op-duplex\", one with \"config true\" and one with \"config false\".",
      "ja": "デュプレックスの例では、これは、2つの別個の葉が、「両面」および「OP二重」、「偽の設定」と「真の設定」と一つを有するものに定義されることになります。"
    },
    {
      "indent": 3,
      "text": "In some cases, distinct leafs would be used, but in others, distinct lists might be used. Distinct lists allows the list to be organized in different ways, with different constraints. Keys, sorting, and constraint statements like must, unique, or when may differ between configuration data and operational data.",
      "ja": "いくつかのケースでは、個別の葉が使用されますが、その他に、別個のリストが使用される可能性があります。別個のリストは異なる制約で、リストはさまざまな方法で整理することができます。キー、並べ替え、および必須のような制約文、ユニークな場合、またはコンフィギュレーション・データおよび運用データ間で異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "For example, configured static routes might be a distinct list from the operational routing table, since the use of keys and sorting might differ.",
      "ja": "例えば、設定されたスタティックルートは、キーとソートの使用が異なるかもしれないので、動作ルーティングテーブルとは異なるリストであるかもしれません。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This document discusses an architecture for network management using NETCONF and YANG. It has no security impact on the Internet.",
      "ja": "この文書では、NETCONFとYANGを使用して、ネットワーク管理のためのアーキテクチャについて説明します。これは、インターネット上ではセキュリティへの影響はありません。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[ISODSDL] International Organization for Standardization, \"Document Schema Definition Languages (DSDL) - Part 1: Overview\", ISO/IEC 19757-1, November 2004.",
      "ja": "[ISODSDL]国際標準化機構、 \"文書スキーマ定義言語（DSDL） - 第1部：概要\"、ISO / IEC 19757から1、2004年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3535] Schoenwaelder, J., \"Overview of the 2002 IAB Network Management Workshop\", RFC 3535, May 2003.",
      "ja": "[RFC3535] Schoenwaelder、J.、RFC 3535、2003年5月 \"2002 IABネットワーク管理ワークショップの概要\" を参照してください。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4251] Ylonen, T. and C. Lonvick, \"The Secure Shell (SSH) Protocol Architecture\", RFC 4251, January 2006.",
      "ja": "[RFC4251] Ylonenと、T.とC. Lonvick、 \"セキュアシェル（SSH）プロトコルアーキテクチャ\"、RFC 4251、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4741] Enns, R., \"NETCONF Configuration Protocol\", RFC 4741, December 2006.",
      "ja": "[RFC4741]エンス、R.、 \"NETCONF構成プロトコル\"、RFC 4741、2006年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4742] Wasserman, M. and T. Goddard, \"Using the NETCONF Configuration Protocol over Secure SHell (SSH)\", RFC 4742, December 2006.",
      "ja": "[RFC4742]ワッサーマン、M.とT.ゴダード、 \"セキュアシェル上でNETCONF構成プロトコルを使用して（SSH）\"、RFC 4742、2006年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4743] Goddard, T., \"Using NETCONF over the Simple Object Access Protocol (SOAP)\", RFC 4743, December 2006.",
      "ja": "[RFC4743]ゴダード、T.、RFC 4743、2006年12月 \"簡易オブジェクトアクセスプロトコル（SOAP）の上にNETCONFを使用します\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4744] Lear, E. and K. Crozier, \"Using the NETCONF Protocol over the Blocks Extensible Exchange Protocol (BEEP)\", RFC 4744, December 2006.",
      "ja": "[RFC4744]リア、E.およびK.クロージャー、 \"ブロック拡張可能交換プロトコル（BEEP）の上にNETCONFプロトコルの使用\"、RFC 4744、2006年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5277] Chisholm, S. and H. Trevino, \"NETCONF Event Notifications\", RFC 5277, July 2008.",
      "ja": "[RFC5277]チザム、S.およびH.トレビノ、 \"NETCONFイベント通知\"、RFC 5277、2008年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5539] Badra, M., \"NETCONF over Transport Layer Security (TLS)\", RFC 5539, May 2009.",
      "ja": "[RFC5539] Badra、M.、RFC 5539、2009年5月、 \"トランスポート層セキュリティ（TLS）の上にNETCONF\"。"
    },
    {
      "indent": 3,
      "text": "[RFC6020] Bjorklund, M., \"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)\", RFC 6020, October 2010.",
      "ja": "[RFC6020] Bjorklund、M.、 \"YANG  - ネットワーク構成プロトコルのためのデータモデリング言語（NETCONF）\"、RFC 6020、2010年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC6021] Schoenwaelder, J., \"Common YANG Data Types\", RFC 6021, October 2010.",
      "ja": "[RFC6021] Schoenwaelder、J.、 \"共通YANGデータ型\"、RFC 6021、2010年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC6087] Bierman, A., \"Guidelines for Authors and Reviewers of YANG Data Model Documents\", RFC 6087, January 2011.",
      "ja": "[RFC6087] Bierman、A.、 \"YANGデータモデルドキュメントの著者と査読のためのガイドライン\"、RFC 6087、2011年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6110] Lhotka, L., \"Mapping YANG to Document Schema Definition Languages and Validating NETCONF Content\", RFC 6110, February 2011.",
      "ja": "[RFC6110] Lhotka、L.、 \"文書スキーマ定義言語へのマッピングYANGおよびコンテンツの検証NETCONF\"、RFC 6110、2011年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6243] Bierman, A. and B. Lengyel, \"With-defaults Capability for NETCONF\", RFC 6243, June 2011.",
      "ja": "[RFC6243] Bierman、A.およびB. Lengyel、 \"NETCONFのためで、デフォルト機能\"、RFC 6243、2011年6月。"
    },
    {
      "indent": 3,
      "text": "[SWEXPECT] \"The Expect Home Page\", <http://expect.sourceforge.net/>.",
      "ja": "[SWEXPECT]、<http://expect.sourceforge.net/> \"ホームページを期待\"。"
    },
    {
      "indent": 3,
      "text": "[W3CXPATH] DeRose, S. and J. Clark, \"XML Path Language (XPath) Version 1.0\", World Wide Web Consortium Recommendation REC-xpath-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xpath-19991116>.",
      "ja": "[W3CXPATH] DeRose、S.とJ.クラーク、 \"XMLパス言語（XPath）バージョン1.0\"、World Wide Web Consortium（W3C）の勧告REC-のxpath-19991116、1999年11月、<http://www.w3.org/TR/ 1999 / REC-のxpath-19991116>。"
    },
    {
      "indent": 3,
      "text": "[W3CXQUERY] Boag, S., \"XQuery 1.0: An XML Query Language\", W3C WD WD-xquery-20050915, September 2005.",
      "ja": "[W3CXQUERY]ボーグ、S.、 \"XQueryの1.0：XMLクエリ言語\"、W3C WD WD-のXQuery-20050915、2005年9月。"
    },
    {
      "indent": 3,
      "text": "[W3CXSD] Walmsley, P. and D. Fallside, \"XML Schema Part 0: Primer Second Edition\", World Wide Web Consortium Recommendation REC-xmlschema-0-20041028, October 2004, <http://www.w3.org/TR/2004/REC-xmlschema-0-20041028>.",
      "ja": "[W3CXSD] Walmsley、P。およびD.フォールサイド、 \"XMLスキーマパート0：入門第二版\"、World Wide Web Consortium（W3C）の勧告REC-XMLSCHEMA-0から20041028、2004年10月、<http://www.w3.org/ TR / 2004 / REC-XMLSCHEMA-0から20041028>。"
    },
    {
      "indent": 3,
      "text": "[W3CXSLT] Clark, J., \"XSL Transformations (XSLT) Version 1.0\", World Wide Web Consortium Recommendation REC-xslt-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xslt-19991116>.",
      "ja": "[W3CXSLT]クラーク、J.、 \"XSL変換（XSLT）バージョン1.0\"、World Wide Web Consortium（W3C）の勧告REC-XSLT-19991116、1999年11月、<http://www.w3.org/TR/1999/REC-xslt -19991116>。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RCDML] Presuhn, R., Ed., \"Requirements for a Configuration Data Modeling Language\", Work in Progress, February 2008.",
      "ja": "[RCDML] Presuhn、R.、エド。、 \"コンフィギュレーションデータモデリング言語のための要件\"、進歩、2008年2月に作業します。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Phil Shafer Juniper Networks",
      "ja": "フィル・シェーファージュニパーネットワークス"
    },
    {
      "indent": 3,
      "text": "EMail: phil@juniper.net",
      "ja": "メールアドレス：phil@juniper.net"
    }
  ]
}