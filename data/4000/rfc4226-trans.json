{
  "title": {
    "text": "RFC 4226 - HOTP: An HMAC-Based One-Time Password Algorithm",
    "ja": "RFC 4226 - HOTP：HMACベースのワンタイムパスワードアルゴリズム"
  },
  "number": 4226,
  "created_at": "2019-10-22 06:18:18.087760+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         D. M'Raihi\nRequest for Comments: 4226                                      VeriSign\nCategory: Informational                                       M. Bellare\n                                                                    UCSD\n                                                            F. Hoornaert\n                                                                   Vasco\n                                                             D. Naccache\n                                                                 Gemplus\n                                                                O. Ranen\n                                                                 Aladdin\n                                                           December 2005",
      "raw": true
    },
    {
      "indent": 11,
      "text": "HOTP: An HMAC-Based One-Time Password Algorithm",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes an algorithm to generate one-time password values, based on Hashed Message Authentication Code (HMAC). A security analysis of the algorithm is presented, and important parameters related to the secure deployment of the algorithm are discussed. The proposed algorithm can be used across a wide range of network applications ranging from remote Virtual Private Network (VPN) access, Wi-Fi network logon to transaction-oriented Web applications.",
      "ja": "この文書では、ハッシュメッセージ認証コード（HMAC）に基づいて、ワンタイムパスワード値を生成するアルゴリズムを説明しています。アルゴリズムのセキュリティ分析が提示され、アルゴリズムの安全な展開に関連する重要なパラメータが議論されています。提案したアルゴリズムは、トランザクション指向のWebアプリケーションへのリモート仮想プライベートネットワーク（VPN）アクセス、のWi-Fiネットワークへのログオンに至るまでのネットワークアプリケーションの広い範囲にわたって使用することができます。"
    },
    {
      "indent": 3,
      "text": "This work is a joint effort by the OATH (Open AuTHentication) membership to specify an algorithm that can be freely distributed to the technical community. The authors believe that a common and shared algorithm will facilitate adoption of two-factor authentication on the Internet by enabling interoperability across commercial and open-source implementations.",
      "ja": "この作品は、自由に技術的なコミュニティに配布することができるアルゴリズムを指定するには、OATH（オープン認証）の会員による共同の努力です。著者は、共通の共有アルゴリズムは、商用およびオープンソース実装で相互運用性を可能にすることにより、インターネット上の二要素認証の採用を容易にするであろうと信じています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Overview ........................................................3\n2. Introduction ....................................................3\n3. Requirements Terminology ........................................4\n4. Algorithm Requirements ..........................................4\n5. HOTP Algorithm ..................................................5\n   5.1. Notation and Symbols .......................................5\n   5.2. Description ................................................6\n   5.3. Generating an HOTP Value ...................................6\n   5.4. Example of HOTP Computation for Digit = 6 ..................7\n6. Security Considerations .........................................8\n7. Security Requirements ...........................................9\n   7.1. Authentication Protocol Requirements .......................9\n   7.2. Validation of HOTP Values .................................10\n   7.3. Throttling at the Server ..................................10\n   7.4. Resynchronization of the Counter ..........................11\n   7.5. Management of Shared Secrets ..............................11\n8. Composite Shared Secrets .......................................14\n9. Bi-Directional Authentication ..................................14\n10. Conclusion ....................................................15\n11. Acknowledgements ..............................................15\n12. Contributors ..................................................15\n13. References ....................................................15\n   13.1. Normative References .....................................15\n   13.2. Informative References ...................................16\nAppendix A - HOTP Algorithm Security: Detailed Analysis ...........17\n   A.1. Definitions and Notations .................................17\n   A.2. The Idealized Algorithm: HOTP-IDEAL .......................17\n   A.3. Model of Security .........................................18\n   A.4. Security of the Ideal Authentication Algorithm ............19\n        A.4.1. From Bits to Digits ................................19\n        A.4.2. Brute Force Attacks ................................21\n        A.4.3. Brute force attacks are the best possible attacks ..22\n   A.5. Security Analysis of HOTP .................................23\nAppendix B - SHA-1 Attacks ........................................25\n   B.1. SHA-1 Status ..............................................25\n   B.2. HMAC-SHA-1 Status .........................................26\n   B.3. HOTP Status ...............................................26\nAppendix C - HOTP Algorithm: Reference Implementation .............27\nAppendix D - HOTP Algorithm: Test Values ..........................32\nAppendix E - Extensions ...........................................33\n   E.1. Number of Digits ..........................................33\n   E.2. Alphanumeric Values .......................................33\n   E.3. Sequence of HOTP values ...................................34\n   E.4. A Counter-Based Resynchronization Method ..................34\n   E.5. Data Field ................................................35",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Overview",
      "section_title": true,
      "ja": "1。概要"
    },
    {
      "indent": 3,
      "text": "The document introduces first the context around an algorithm that generates one-time password values based on HMAC [BCK1] and, thus, is named the HMAC-Based One-Time Password (HOTP) algorithm. In Section 4, the algorithm requirements are listed and in Section 5, the HOTP algorithm is described. Sections 6 and 7 focus on the algorithm security. Section 8 proposes some extensions and improvements, and Section 10 concludes this document. In Appendix A, the interested reader will find a detailed, full-fledged analysis of the algorithm security: an idealized version of the algorithm is evaluated, and then the HOTP algorithm security is analyzed.",
      "ja": "ドキュメントは、このように、HMACベースのワンタイムパスワード（HOTP）アルゴリズム命名さHMAC [BCK1]と、に基づいて、ワンタイムパスワード値を生成するアルゴリズムの周りに最初のコンテキストを紹介します。 4節では、アルゴリズムの要件が記載されている、セクション5で、HOTPアルゴリズムが記載されています。セクション6およびアルゴリズムの安全保障上の7つの焦点。第8章では、いくつかの拡張機能や改善点を提案し、そして第10節は、この文書を終わります。付録Aでは、興味のある読者は、アルゴリズムのセキュリティの詳細、本格的な分析を見つける：アルゴリズムの理想化されたバージョンが評価され、その後、HOTPアルゴリズムセキュリティが分析されます。"
    },
    {
      "indent": 0,
      "text": "2. Introduction",
      "section_title": true,
      "ja": "2.はじめに"
    },
    {
      "indent": 3,
      "text": "Today, deployment of two-factor authentication remains extremely limited in scope and scale. Despite increasingly higher levels of threats and attacks, most Internet applications still rely on weak authentication schemes for policing user access. The lack of interoperability among hardware and software technology vendors has been a limiting factor in the adoption of two-factor authentication technology. In particular, the absence of open specifications has led to solutions where hardware and software components are tightly coupled through proprietary technology, resulting in high-cost solutions, poor adoption, and limited innovation.",
      "ja": "今日は、二要素認証の展開は、範囲と規模で非常に制限されたままです。脅威や攻撃のますます高いレベルにもかかわらず、ほとんどのインターネットアプリケーションは、まだユーザーアクセスをポリシングに弱い認証スキームに依存しています。ハードウェアとソフトウェアの技術ベンダー間の相互運用性の欠如は、二要素認証技術の採用を制限する要因となっています。特に、オープン仕様の欠如は、ハードウェアおよびソフトウェアコンポーネントがしっかり高コストのソリューション、乏しい採用し、限られた技術革新をもたらす、独自の技術を介して結合されているソリューションにつながっています。"
    },
    {
      "indent": 3,
      "text": "In the last two years, the rapid rise of network threats has exposed the inadequacies of static passwords as the primary mean of authentication on the Internet. At the same time, the current approach that requires an end user to carry an expensive, single-function device that is only used to authenticate to the network is clearly not the right answer. For two-factor authentication to propagate on the Internet, it will have to be embedded in more flexible devices that can work across a wide range of applications.",
      "ja": "最後の2年間で、ネットワークの脅威の急速な上昇は、インターネット上の認証の主な手段として、静的なパスワードの不備を公開しました。同時に、唯一のネットワークへの認証に使用される高価な単機能デバイスを運ぶために、エンドユーザーが必要とし、現在のアプローチは明らかに正しい答えではありません。二要素認証は、インターネット上で伝播するためには、アプリケーションの広い範囲で動作することができ、より柔軟なデバイスに埋め込まれる必要があります。"
    },
    {
      "indent": 3,
      "text": "The ability to embed this base technology while ensuring broad interoperability requires that it be made freely available to the broad technical community of hardware and software developers. Only an open-system approach will ensure that basic two-factor authentication primitives can be built into the next generation of consumer devices such as USB mass storage devices, IP phones, and personal digital assistants.",
      "ja": "幅広い相互運用性を確保しながら、この基本技術を埋め込む機能は、それがハードウェアとソフトウェア開発者の幅広い技術コミュニティに自由に利用できるようにする必要があります。唯一のオープン・システム・アプローチの基本的な二要素認証プリミティブは、USBマスストレージデバイス、IP電話、及びパーソナルデジタルアシスタントのような民生機器の次世代に組み込むことができることを保証します。"
    },
    {
      "indent": 3,
      "text": "One-Time Password is certainly one of the simplest and most popular forms of two-factor authentication for securing network access. For example, in large enterprises, Virtual Private Network access often requires the use of One-Time Password tokens for remote user authentication. One-Time Passwords are often preferred to stronger forms of authentication such as Public-Key Infrastructure (PKI) or biometrics because an air-gap device does not require the installation of any client desktop software on the user machine, therefore allowing them to roam across multiple machines including home computers, kiosks, and personal digital assistants.",
      "ja": "ワンタイムパスワードは、確かにネットワークへのアクセスを確保するための二要素認証の最も簡単で最も人気のある形態の一つです。例えば、大企業では、仮想プライベートネットワークへのアクセスは、多くの場合、リモートユーザ認証のためのワンタイムパスワードトークンを使用する必要があります。エアギャップデバイスは、ユーザーのマシン上の任意のクライアントデスクトップソフトウェアのインストールを必要としないため、ワンタイムパスワードは、多くの場合、したがって、それらは全体のローミングすることができ、そのような公開鍵基盤（PKI）やバイオメトリクスなどの認証の強いフォームに好まれます家庭用コンピュータ、キオスク、およびパーソナルデジタルアシスタントを含む複数のマシン。"
    },
    {
      "indent": 3,
      "text": "This document proposes a simple One-Time Password algorithm that can be implemented by any hardware manufacturer or software developer to create interoperable authentication devices and software agents. The algorithm is event-based so that it can be embedded in high-volume devices such as Java smart cards, USB dongles, and GSM SIM cards. The presented algorithm is made freely available to the developer community under the terms and conditions of the IETF Intellectual Property Rights [RFC3979].",
      "ja": "この文書では、相互運用可能な認証デバイスとソフトウェアエージェントを作成するために、任意のハードウェアメーカーやソフトウェア開発者によって実装することができるシンプルなワンタイムパスワードアルゴリズムを提案しています。それは、Java（登録商標）、スマートカード、USBドングル、およびGSM SIMカードなどの大容量のデバイスに埋め込むことができるように、アルゴリズムは、イベントベースです。提示したアルゴリズムは[RFC3979] IETF知的財産権の契約条件の下で、開発者コミュニティに自由に利用できるようになります。"
    },
    {
      "indent": 3,
      "text": "The authors of this document are members of the Open AuTHentication initiative [OATH]. The initiative was created in 2004 to facilitate collaboration among strong authentication technology providers.",
      "ja": "本書の著者は、オープン認証イニシアチブ[OATH]のメンバーです。イニシアチブは、強力な認証技術プロバイダ間の連携を促進するために2004年に作成されました。"
    },
    {
      "indent": 0,
      "text": "3. Requirements Terminology",
      "section_title": true,
      "ja": "3.要件用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "4. Algorithm Requirements",
      "section_title": true,
      "ja": "4.アルゴリズムの要件"
    },
    {
      "indent": 3,
      "text": "This section presents the main requirements that drove this algorithm design. A lot of emphasis was placed on end-consumer usability as well as the ability for the algorithm to be implemented by low-cost hardware that may provide minimal user interface capabilities. In particular, the ability to embed the algorithm into high-volume SIM and Java cards was a fundamental prerequisite.",
      "ja": "このセクションでは、このアルゴリズムの設計を運転した主な要件を提示します。重点の多くは、最終消費者の利便性だけでなく、最小限のユーザインターフェース機能を提供することができる低コストのハードウェアにより実現されるアルゴリズムの能力の上に置きました。特に、大容量SIMおよびJavaカードにアルゴリズムを埋め込む能力は、基本的な前提条件でした。"
    },
    {
      "indent": 3,
      "text": "R1 - The algorithm MUST be sequence- or counter-based: one of the goals is to have the HOTP algorithm embedded in high-volume devices such as Java smart cards, USB dongles, and GSM SIM cards.",
      "ja": "目標の一つは、Javaスマートカード、USBドングル、およびGSM SIMカードなどの大容量のデバイス内に埋め込まれたHOTPアルゴリズムを有することである： -  R1は、アルゴリズムは、配列または反基づかなければなりません。"
    },
    {
      "indent": 3,
      "text": "R2 - The algorithm SHOULD be economical to implement in hardware by minimizing requirements on battery, number of buttons, computational horsepower, and size of LCD display.",
      "ja": "R2  - アルゴリズムは、バッテリー、ボタンの数、計算馬力、及びLCDディスプレイのサイズに関する要件を最小化することにより、ハードウェアで実装するのに経済的であるべきです。"
    },
    {
      "indent": 3,
      "text": "R3 - The algorithm MUST work with tokens that do not support any numeric input, but MAY also be used with more sophisticated devices such as secure PIN-pads.",
      "ja": "R3  - このアルゴリズムは、任意の数値入力をサポートしていませんが、また、安全なPIN-パッドのような、より洗練されたデバイスに使用されるかもしれトークンと連携しなければなりません。"
    },
    {
      "indent": 3,
      "text": "R4 - The value displayed on the token MUST be easily read and entered by the user: This requires the HOTP value to be of reasonable length.",
      "ja": "R4  - トークンに表示される値は、容易に読み取り、ユーザが入力する必要があります。これは、合理的長さであることがHOTP値を必要とします。"
    },
    {
      "indent": 3,
      "text": "The HOTP value must be at least a 6-digit value. It is also desirable that the HOTP value be 'numeric only' so that it can be easily entered on restricted devices such as phones.",
      "ja": "HOTP値は、少なくとも6桁の値でなければなりません。簡単な電話などの制限されたデバイス上で入力することができるようにHOTP値が「数字のみ」であることも望ましいです。"
    },
    {
      "indent": 3,
      "text": "R5 - There MUST be user-friendly mechanisms available to resynchronize the counter. Section 7.4 and Appendix E.4 details the resynchronization mechanism proposed in this document",
      "ja": "R5  - カウンタを再同期するために利用できるユーザーフレンドリーなメカニズムがあるに違いありません。 7.4節および付録E.4は、この文書で提案された再同期メカニズムを詳細に"
    },
    {
      "indent": 3,
      "text": "R6 - The algorithm MUST use a strong shared secret. The length of the shared secret MUST be at least 128 bits. This document RECOMMENDs a shared secret length of 160 bits.",
      "ja": "R6  - アルゴリズムは、強力な共有秘密を使用しなければなりません。共有秘密鍵の長さは、少なくとも128ビットでなければなりません。この文書では、160ビットの共有秘密鍵の長さをお勧めします。"
    },
    {
      "indent": 0,
      "text": "5. HOTP Algorithm",
      "section_title": true,
      "ja": "5. HOTPアルゴリズム"
    },
    {
      "indent": 3,
      "text": "In this section, we introduce the notation and describe the HOTP algorithm basic blocks -- the base function to compute an HMAC-SHA-1 value and the truncation method to extract an HOTP value.",
      "ja": "このセクションでは、我々は、表記法を導入し、HOTPアルゴリズムの基本ブロック記述 -  HOTP値を抽出するためにHMAC-SHA-1値およびトランケーション方法を計算する基底関数を。"
    },
    {
      "indent": 0,
      "text": "5.1. Notation and Symbols",
      "section_title": true,
      "ja": "5.1. 表記と記号"
    },
    {
      "indent": 3,
      "text": "A string always means a binary string, meaning a sequence of zeros and ones.",
      "ja": "文字列は、常に0と1のシーケンスを意味し、バイナリ文字列を意味します。"
    },
    {
      "indent": 3,
      "text": "If s is a string, then |s| denotes its length.",
      "ja": "sが文字列の場合、| |よその長さを示します。"
    },
    {
      "indent": 3,
      "text": "If n is a number, then |n| denotes its absolute value.",
      "ja": "nは数字がある場合は、| N |その絶対値を示しています。"
    },
    {
      "indent": 3,
      "text": "If s is a string, then s[i] denotes its i-th bit. We start numbering the bits at 0, so s = s[0]s[1]...s[n-1] where n = |s| is the length of s.",
      "ja": "sが文字列である場合、S [i]は、そのi番目のビットを表します。我々は0ビットの番号を開始するので、S = Sで[0]、S [1] ... S [N-1] N = |です| Sの長さがあります。"
    },
    {
      "indent": 3,
      "text": "Let StToNum (String to Number) denote the function that as input a string s returns the number whose binary representation is s. (For example, StToNum(110) = 6.)",
      "ja": "StToNum（数値文字列）を入力として文字列sは、バイナリ表現の数値を返すこと関数を表すものとします。 （例えば、StToNum（110）= 6）"
    },
    {
      "indent": 3,
      "text": "Here is a list of symbols used in this document.",
      "ja": "ここでは、本書で使用する記号の一覧です。"
    },
    {
      "indent": 3,
      "text": "Symbol  Represents\n-------------------------------------------------------------------\nC       8-byte counter value, the moving factor.  This counter\n        MUST be synchronized between the HOTP generator (client)\n        and the HOTP validator (server).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "K shared secret between client and server; each HOTP generator has a different and unique secret K.",
      "ja": "Kは、クライアントとサーバ間の秘密を共有し、各HOTPジェネレータは異なるユニークな秘密を持っているK."
    },
    {
      "indent": 3,
      "text": "T throttling parameter: the server will refuse connections from a user after T unsuccessful authentication attempts.",
      "ja": "Tスロットリングパラメータ：サーバがT不成功の認証試行後にユーザーからの接続を拒否します。"
    },
    {
      "indent": 3,
      "text": "s resynchronization parameter: the server will attempt to verify a received authenticator across s consecutive counter values.",
      "ja": "sの再同期パラメータ：サーバーが連続カウンタ値の間で受け取った認証子を検証しようとします。"
    },
    {
      "indent": 3,
      "text": "Digit number of digits in an HOTP value; system parameter.",
      "ja": "HOTP値の桁の桁数。システム・パラメータ。"
    },
    {
      "indent": 0,
      "text": "5.2. Description",
      "section_title": true,
      "ja": "5.2. 説明"
    },
    {
      "indent": 3,
      "text": "The HOTP algorithm is based on an increasing counter value and a static symmetric key known only to the token and the validation service. In order to create the HOTP value, we will use the HMAC-SHA-1 algorithm, as defined in RFC 2104 [BCK2].",
      "ja": "HOTPアルゴリズムは、増加するカウンタ値とのみトークンと検証サービスに知られている静的対称鍵に基づいています。 RFC 2104 [BCK2]で定義されるようHOTP値を作成するために、我々は、HMAC-SHA-1アルゴリズムを使用します。"
    },
    {
      "indent": 3,
      "text": "As the output of the HMAC-SHA-1 calculation is 160 bits, we must truncate this value to something that can be easily entered by a user.",
      "ja": "HMAC-SHA-1計算の出力は160ビットであるように、我々は、ユーザによって容易に入力することができるものには、この値を切り捨てなければなりません。"
    },
    {
      "indent": 19,
      "text": "HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))",
      "ja": "HOTP（K、C）=切捨て（HMAC-SHA-1（K、C））"
    },
    {
      "indent": 3,
      "text": "Where:",
      "ja": "どこ："
    },
    {
      "indent": 5,
      "text": "- Truncate represents the function that converts an HMAC-SHA-1 value into an HOTP value as defined in Section 5.3.",
      "ja": " - 切り捨ては、セクション5.3で定義されるようにHOTP値にHMAC-SHA-1値を変換する関数を表します。"
    },
    {
      "indent": 3,
      "text": "The Key (K), the Counter (C), and Data values are hashed high-order byte first.",
      "ja": "キー（K）、カウンタ（C）、およびデータ値は、最初上位バイトをハッシュしています。"
    },
    {
      "indent": 3,
      "text": "The HOTP values generated by the HOTP generator are treated as big endian.",
      "ja": "HOTPジェネレータによって生成されたHOTP値はビッグエンディアンとして扱われます。"
    },
    {
      "indent": 0,
      "text": "5.3. Generating an HOTP Value",
      "section_title": true,
      "ja": "5.3.  HOTP値を生成します"
    },
    {
      "indent": 3,
      "text": "We can describe the operations in 3 distinct steps:",
      "ja": "私たちは、3つの異なる手順で操作を記述することができます："
    },
    {
      "indent": 3,
      "text": "Step 1: Generate an HMAC-SHA-1 value Let HS = HMAC-SHA-1(K,C) // HS is a 20-byte string",
      "ja": "ステップ1：HMAC-SHA-1値は、HS = HMAC-SHA-1（K、C）を生成しよう// HSは、20バイトの文字列であります"
    },
    {
      "indent": 3,
      "text": "Step 2: Generate a 4-byte string (Dynamic Truncation) Let Sbits = DT(HS) // DT, defined below, // returns a 31-bit string",
      "ja": "ステップ2：4バイトの文字列（動的切り捨て）を生成させるSBITS = DT（HS）// DTは、以下に定義される、// 31ビットの文字列を返します"
    },
    {
      "indent": 3,
      "text": "Step 3: Compute an HOTP value Let Snum = StToNum(Sbits) // Convert S to a number in 0...2^{31}-1 Return D = Snum mod 10^Digit // D is a number in the range 0...10^{Digit}-1",
      "ja": "ステップ3：// HOTP値うSNUM = StToNum（SBITS）を計算0で番号にSを変換... 2 ^ {31} -1戻りD = SNUM MOD 10 ^桁Dは、範囲内の数である// 0 ... 10 ^ {桁} -1-"
    },
    {
      "indent": 3,
      "text": "The Truncate function performs Step 2 and Step 3, i.e., the dynamic truncation and then the reduction modulo 10^Digit. The purpose of the dynamic offset truncation technique is to extract a 4-byte dynamic binary code from a 160-bit (20-byte) HMAC-SHA-1 result.",
      "ja": "切り捨て機能は、ステップ2とステップ3、すなわち、動的トランケーション及び10 ^桁モジュロ次いで還元を行います。ダイナミックオフセット切捨て技術の目的は、160ビット（20バイト）のHMAC-SHA-1の結果から4バイトの動的バイナリコードを抽出することです。"
    },
    {
      "indent": 4,
      "text": "DT(String) // String = String[0]...String[19] Let OffsetBits be the low-order 4 bits of String[19] Offset = StToNum(OffsetBits) // 0 <= OffSet <= 15 Let P = String[OffSet]...String[OffSet+3] Return the Last 31 bits of P",
      "ja": "DT（文字列）//文字列= [0] ...文字列[19] OffsetBitsは// 0 <オフセット= <= 15 Pレット下位文字列の4ビット[19]オフセット= StToNum（OffsetBits）とします=文字列[オフセット] ...文字列[3 +オフセット] Pの最後の31ビットを返します"
    },
    {
      "indent": 3,
      "text": "The reason for masking the most significant bit of P is to avoid confusion about signed vs. unsigned modulo computations. Different processors perform these operations differently, and masking out the signed bit removes all ambiguity.",
      "ja": "Pの最上位ビットをマスクする理由は、符号なしのモジュロ計算対署名についての混乱を避けるためです。異なるプロセッサが異なり、これらの操作を実行し、符号ビットをマスキングすると、すべての曖昧さを取り除きます。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST extract a 6-digit code at a minimum and possibly 7 and 8-digit code. Depending on security requirements, Digit = 7 or more SHOULD be considered in order to extract a longer HOTP value.",
      "ja": "実装は、最小およびおそらく7及び8桁のコードで6桁のコードを抽出しなければなりません。セキュリティ要件に応じて、桁= 7以上の長いHOTP値を抽出するために考慮されるべきです。"
    },
    {
      "indent": 3,
      "text": "The following paragraph is an example of using this technique for Digit = 6, i.e., that a 6-digit HOTP value is calculated from the HMAC value.",
      "ja": "以下の段落は、6桁のHOTP値が、HMAC値から算出される、桁= 6、即ち、この技術の使用例です。"
    },
    {
      "indent": 0,
      "text": "5.4. Example of HOTP Computation for Digit = 6",
      "section_title": true,
      "ja": "5.4. 桁のHOTP計算の例= 6"
    },
    {
      "indent": 3,
      "text": "The following code example describes the extraction of a dynamic binary code given that hmac_result is a byte array with the HMAC-SHA-1 result:",
      "ja": "以下のコード例はhmac_resultはHMAC-SHA-1の結果のバイトアレイであることを考えると、動的バイナリコードの抽出を記載しています。"
    },
    {
      "indent": 8,
      "text": "int offset   =  hmac_result[19] & 0xf ;\nint bin_code = (hmac_result[offset]  & 0x7f) << 24\n   | (hmac_result[offset+1] & 0xff) << 16\n   | (hmac_result[offset+2] & 0xff) <<  8\n   | (hmac_result[offset+3] & 0xff) ;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SHA-1 HMAC Bytes (Example)",
      "ja": "SHA-1 HMACバイト（実施例）"
    },
    {
      "indent": 3,
      "text": "-------------------------------------------------------------\n| Byte Number                                               |\n-------------------------------------------------------------\n|00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|\n-------------------------------------------------------------\n| Byte Value                                                |\n-------------------------------------------------------------\n|1f|86|98|69|0e|02|ca|16|61|85|50|ef|7f|19|da|8e|94|5b|55|5a|\n-------------------------------***********----------------++|",
      "raw": true
    },
    {
      "indent": 3,
      "text": "* The last byte (byte 19) has the hex value 0x5a. * The value of the lower 4 bits is 0xa (the offset value). * The offset value is byte 10 (0xa). * The value of the 4 bytes starting at byte 10 is 0x50ef7f19, which is the dynamic binary code DBC1. * The MSB of DBC1 is 0x50 so DBC2 = DBC1 = 0x50ef7f19 . * HOTP = DBC2 modulo 10^6 = 872921.",
      "ja": "*最後のバイト（バイト19）が16進値0x5aを持っています。 *下位4ビットの値は0xa（オフセット値）です。 *オフセット値はバイト10（は0xa）です。 *バイト10で始まる4バイトの値は、動的バイナリコードDBC1ある0x50ef7f19、です。 * DBC1のMSBは0x50をそうDBC2 = DBC1 = 0x50ef7f19です。 * HOTP = DBC2モジュロ10 ^ 6 = 872921。"
    },
    {
      "indent": 3,
      "text": "We treat the dynamic binary code as a 31-bit, unsigned, big-endian integer; the first byte is masked with a 0x7f.",
      "ja": "我々は、31ビット符号なし、ビッグエンディアン整数として動的バイナリコードを扱います。最初のバイトは0x7fのでマスクされます。"
    },
    {
      "indent": 3,
      "text": "We then take this number modulo 1,000,000 (10^6) to generate the 6- digit HOTP value 872921 decimal.",
      "ja": "我々は、次に、6-桁のHOTP値を872921小数を生成するために、この番号モジュロ1,000,000（^ 6〜10）を取ります。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The conclusion of the security analysis detailed in the Appendix is that, for all practical purposes, the outputs of the Dynamic Truncation (DT) on distinct counter inputs are uniformly and independently distributed 31-bit strings.",
      "ja": "付録の詳細なセキュリティ解析の結論は、すべての実用的な目的のために、別個のカウンタ入力の動的切り捨て（DT）の出力が一様にかつ独立して31ビット列を分散している、ということです。"
    },
    {
      "indent": 3,
      "text": "The security analysis then details the impact of the conversion from a string to an integer and the final reduction modulo 10^Digit, where Digit is the number of digits in an HOTP value.",
      "ja": "セキュリティ分析は、次に桁のHOTP値の桁数である整数であり、最終減速モジュロ10 ^桁の文字列からの変換の影響を詳述します。"
    },
    {
      "indent": 3,
      "text": "The analysis demonstrates that these final steps introduce a negligible bias, which does not impact the security of the HOTP algorithm, in the sense that the best possible attack against the HOTP function is the brute force attack.",
      "ja": "分析は、これらの最終ステップは、HOTP機能に対する最善の攻撃はブルートフォース攻撃であるという意味で、HOTPアルゴリズムのセキュリティに影響を与えません無視できるバイアスを導入することを実証します。"
    },
    {
      "indent": 3,
      "text": "Assuming an adversary is able to observe numerous protocol exchanges and collect sequences of successful authentication values. This adversary, trying to build a function F to generate HOTP values based on his observations, will not have a significant advantage over a random guess.",
      "ja": "敵と仮定すると、多数のプロトコル交換を観察し、成功した認証値のシーケンスを収集することができます。この敵は、彼の観察に基づいて、HOTP値を生成する関数Fを構築しようと、ランダムな推測上の重要な利点を持っていません。"
    },
    {
      "indent": 3,
      "text": "The logical conclusion is simply that the best strategy will once again be to perform a brute force attack to enumerate and try all the possible values.",
      "ja": "論理的な結論は、最善の戦略が再び列挙し、すべての可能な値をしようとするブルートフォース攻撃を実行することであろうということだけです。"
    },
    {
      "indent": 3,
      "text": "Considering the security analysis in the Appendix of this document, without loss of generality, we can approximate closely the security of the HOTP algorithm by the following formula:",
      "ja": "このドキュメントの付録のセキュリティ分析を考慮すると、一般性を失うことなく、我々は以下の式で密接HOTPアルゴリズムのセキュリティを近似することができます。"
    },
    {
      "indent": 28,
      "text": "Sec = sv/10^Digit",
      "ja": "秒= SV / 10 ^桁"
    },
    {
      "indent": 3,
      "text": "Where:\n  - Sec is the probability of success of the adversary;\n  - s is the look-ahead synchronization window size;\n  - v is the number of verification attempts;\n  - Digit is the number of digits in HOTP values.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Obviously, we can play with s, T (the Throttling parameter that would limit the number of attempts by an attacker), and Digit until achieving a certain level of security, still preserving the system usability.",
      "ja": "もちろん、我々はまだ、システムの使いやすさを維持し、あるレベルのセキュリティを実現するまでのS、T（攻撃者が試行回数を制限するスロットルパラメータ）、および数字で遊ぶことができます。"
    },
    {
      "indent": 0,
      "text": "7. Security Requirements",
      "section_title": true,
      "ja": "7.セキュリティ要件"
    },
    {
      "indent": 3,
      "text": "Any One-Time Password algorithm is only as secure as the application and the authentication protocols that implement it. Therefore, this section discusses the critical security requirements that our choice of algorithm imposes on the authentication protocol and validation software.",
      "ja": "どれワンタイムパスワードアルゴリズムは、アプリケーションとそれを実装する認証プロトコルと同じくらい安全です。したがって、このセクションでは、アルゴリズムの私達の選択は、認証プロトコルと検証ソフトウェアに課す重要なセキュリティ要件について説明します。"
    },
    {
      "indent": 3,
      "text": "The parameters T and s discussed in this section have a significant impact on the security -- further details in Section 6 elaborate on the relations between these parameters and their impact on the system security.",
      "ja": "これらのパラメータ及びシステムセキュリティに対するそれらの影響との間の関係に精巧なセクション6で詳細 - パラメータTと、このセクションで説明するのは、セキュリティに大きな影響を与えます。"
    },
    {
      "indent": 3,
      "text": "It is also important to remark that the HOTP algorithm is not a substitute for encryption and does not provide for the privacy of data transmission. Other mechanisms should be used to defeat attacks aimed at breaking confidentiality and privacy of transactions.",
      "ja": "HOTPアルゴリズムは、暗号化に代わるものではありませんし、データ伝送のプライバシーのために提供していないことを発言することも重要です。他のメカニズムは、トランザクションの機密性とプライバシーを破壊を目的とした攻撃を倒すために使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "7.1. Authentication Protocol Requirements",
      "section_title": true,
      "ja": "7.1. 認証プロトコルの要件"
    },
    {
      "indent": 3,
      "text": "We introduce in this section some requirements for a protocol P implementing HOTP as the authentication method between a prover and a verifier.",
      "ja": "我々は、このセクションでは、証明者と検証者との間の認証方法としてHOTPを実現するプロトコルPのためのいくつかの要件を紹介します。"
    },
    {
      "indent": 3,
      "text": "RP1 - P MUST support two-factor authentication, i.e., the communication and verification of something you know (secret code such as a Password, Pass phrase, PIN code, etc.) and something you have (token). The secret code is known only to the user and usually entered with the One-Time Password value for authentication purpose (two-factor authentication).",
      "ja": "RP1  -  Pは、つまり、あなたが知っている何か（秘密のパスワードなどのコード、パスフレーズ、PINコードなど）と、あなたが持っている何か（トークン）の通信と検証が二要素認証をサポートしなければなりません。秘密のコードは、ユーザーに知られており、通常は認証目的（二要素認証）のためのワンタイムパスワードの値を入力します。"
    },
    {
      "indent": 3,
      "text": "RP2 - P SHOULD NOT be vulnerable to brute force attacks. This implies that a throttling/lockout scheme is RECOMMENDED on the validation server side.",
      "ja": "RP2  -  Pはブルートフォース攻撃に対して脆弱であるべきではありません。これは、絞り/ロックアウト方式は、検証サーバ側で推奨されていることを意味します。"
    },
    {
      "indent": 3,
      "text": "RP3 - P SHOULD be implemented over a secure channel in order to protect users' privacy and avoid replay attacks.",
      "ja": "RP3  -  Pは、ユーザーのプライバシーを保護し、リプレイ攻撃を避けるために、安全なチャネルを介して実施されるべきです。"
    },
    {
      "indent": 0,
      "text": "7.2. Validation of HOTP Values",
      "section_title": true,
      "ja": "7.2.  HOTP値の検証"
    },
    {
      "indent": 3,
      "text": "The HOTP client (hardware or software token) increments its counter and then calculates the next HOTP value HOTP client. If the value received by the authentication server matches the value calculated by the client, then the HOTP value is validated. In this case, the server increments the counter value by one.",
      "ja": "HOTPクライアント（ハードウェアまたはソフトウェアトークン）は、そのカウンタをインクリメントし、その後、次のHOTP値HOTPクライアントを算出します。認証サーバが受信した値がクライアントによって計算された値と一致した場合、HOTP値が検証されます。この場合、サーバは、いずれかによって、カウンタ値をインクリメントします。"
    },
    {
      "indent": 3,
      "text": "If the value received by the server does not match the value calculated by the client, the server initiate the resynch protocol (look-ahead window) before it requests another pass.",
      "ja": "サーバーが受信した値がクライアントによって計算された値と一致しない場合、それは別のパスを要求する前に、サーバーが再同期プロトコル（先読みウィンドウ）を開始します。"
    },
    {
      "indent": 3,
      "text": "If the resynch fails, the server asks then for another authentication pass of the protocol to take place, until the maximum number of authorized attempts is reached.",
      "ja": "再同期が失敗した場合は、許可試行の最大数に達するまで、サーバは、場所を取るためのプロトコルの別の認証パスのために、次に求められます。"
    },
    {
      "indent": 3,
      "text": "If and when the maximum number of authorized attempts is reached, the server SHOULD lock out the account and initiate a procedure to inform the user.",
      "ja": "もしおよび認可の最大試行回数に達したときに、サーバーは、アカウントをロックアウトし、ユーザーに通知する手続きを開始すべきです。"
    },
    {
      "indent": 0,
      "text": "7.3. Throttling at the Server",
      "section_title": true,
      "ja": "7.3. サーバーで絞ります"
    },
    {
      "indent": 3,
      "text": "Truncating the HMAC-SHA-1 value to a shorter value makes a brute force attack possible. Therefore, the authentication server needs to detect and stop brute force attacks.",
      "ja": "短い値にHMAC-SHA-1値を切り捨てることはブルートフォース攻撃が可能になります。そのため、認証サーバは、ブルートフォース攻撃を検出して停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "We RECOMMEND setting a throttling parameter T, which defines the maximum number of possible attempts for One-Time Password validation. The validation server manages individual counters per HOTP device in order to take note of any failed attempt. We RECOMMEND T not to be too large, particularly if the resynchronization method used on the server is window-based, and the window size is large. T SHOULD be set as low as possible, while still ensuring that usability is not significantly impacted.",
      "ja": "我々は、ワンタイムパスワードの検証のための可能な試みの最大数を定義調整パラメータTを設定することをお勧めします。検証サーバは、任意の失敗した試行のノートを取るためにHOTPデバイスごとに個別のカウンタを管理します。私たちは、サーバ上で使用される再同期方法は、ウィンドウベースで、ウィンドウサイズが大きい場合は特に、大きくなりすぎないようにTをお勧めします。まだ使い勝手が大幅に影響されないことを保証しながらTは、可能な限り低く設定されてください。"
    },
    {
      "indent": 3,
      "text": "Another option would be to implement a delay scheme to avoid a brute force attack. After each failed attempt A, the authentication server would wait for an increased T*A number of seconds, e.g., say T = 5, then after 1 attempt, the server waits for 5 seconds, at the second failed attempt, it waits for 5*2 = 10 seconds, etc.",
      "ja": "別のオプションは、ブルートフォース攻撃を避けるために、遅延スキームを実装することであろう。各試行Aを失敗した後、認証サーバは*秒数、例えば、T = 5と言う増加Tを待つでしょう、そして、1つの試みの後、5秒間、サーバーが待機は、第二未遂で、それは5を待ち* 2 = 10秒、など"
    },
    {
      "indent": 3,
      "text": "The delay or lockout schemes MUST be across login sessions to prevent attacks based on multiple parallel guessing techniques.",
      "ja": "遅延またはロックアウト方式は、複数の並列推測技術に基づく攻撃を防ぐために、ログインセッションにわたってなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.4. Resynchronization of the Counter",
      "section_title": true,
      "ja": "7.4. カウンターの再同期"
    },
    {
      "indent": 3,
      "text": "Although the server's counter value is only incremented after a successful HOTP authentication, the counter on the token is incremented every time a new HOTP is requested by the user. Because of this, the counter values on the server and on the token might be out of synchronization.",
      "ja": "サーバのカウンタ値が唯一成功したHOTP認証の後にインクリメントされますが、トークン上のカウンタは、新たなHOTPがユーザによって要求されるたびにインクリメントされます。このため、サーバー上のトークンのカウンタ値は、同期が外れている可能性があります。"
    },
    {
      "indent": 3,
      "text": "We RECOMMEND setting a look-ahead parameter s on the server, which defines the size of the look-ahead window. In a nutshell, the server can recalculate the next s HOTP-server values, and check them against the received HOTP client.",
      "ja": "私たちは、ルックアヘッドウィンドウのサイズを定義して、サーバー上のルックアヘッドパラメータsを設定することをお勧めします。一言で言えば、サーバーは、次のs HOTPサーバ値を再計算することができ、受信したHOTPクライアントに対してそれらを確認してください。"
    },
    {
      "indent": 3,
      "text": "Synchronization of counters in this scenario simply requires the server to calculate the next HOTP values and determine if there is a match. Optionally, the system MAY require the user to send a sequence of (say, 2, 3) HOTP values for resynchronization purpose, since forging a sequence of consecutive HOTP values is even more difficult than guessing a single HOTP value.",
      "ja": "このシナリオでは、カウンタの同期は、単純に次のHOTP値を計算し、一致があるかどうかを決定するためにサーバを必要とします。連続HOTP値のシーケンスを偽造することはさらに困難単一HOTP値を推測未満であるので必要に応じて、システムは、再同期目的のためのHOTP値（3、2、例えば）のシーケンスを送信するためにユーザを必要とする場合があります。"
    },
    {
      "indent": 3,
      "text": "The upper bound set by the parameter s ensures the server does not go on checking HOTP values forever (causing a denial-of-service attack) and also restricts the space of possible solutions for an attacker trying to manufacture HOTP values. s SHOULD be set as low as possible, while still ensuring that usability is not impacted.",
      "ja": "パラメータsによって上限セットは、サーバーが（サービス拒否攻撃を引き起こす）永遠HOTP値をチェックしに行くともHOTP値を製造しようとする攻撃者のための可能な解決策のスペースを制限しません保証します。まだ使い勝手が影響を受けないことを保証しながら、Sは、できるだけ低く設定されてください。"
    },
    {
      "indent": 0,
      "text": "7.5. Management of Shared Secrets",
      "section_title": true,
      "ja": "7.5. 共有秘密の管理"
    },
    {
      "indent": 3,
      "text": "The operations dealing with the shared secrets used to generate and verify OTP values must be performed securely, in order to mitigate risks of any leakage of sensitive information. We describe in this section different modes of operations and techniques to perform these different operations with respect to the state of the art in data security.",
      "ja": "OTP値を生成し、検証するために使用される共有秘密を扱う操作は、機密情報の漏洩のリスクを軽減するために、確実に行わなければなりません。我々は、データセキュリティにおける技術の状態に関して、これらの異なる操作を実行するために、このセクションでの操作および技術の異なるモードを記述する。"
    },
    {
      "indent": 3,
      "text": "We can consider two different avenues for generating and storing (securely) shared secrets in the Validation system:",
      "ja": "私たちは、生成および検証システムに（安全に）共有秘密を格納するための2つの異なった道を考えることができます。"
    },
    {
      "indent": 6,
      "text": "* Deterministic Generation: secrets are derived from a master seed, both at provisioning and verification stages and generated on-the-fly whenever it is required. * Random Generation: secrets are generated randomly at provisioning stage and must be stored immediately and kept secure during their life cycle.",
      "ja": "*確定生成：秘密は、両方のプロビジョニングおよび検証段階で、マスターシードに由来し、オンザフライことが要求されるたびに生成されます。 *ランダム生成：秘密がステージをプロビジョニングでランダムに生成され、すぐに保存され、そのライフサイクルの間に安全に保管しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Deterministic Generation\n------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A possible strategy is to derive the shared secrets from a master secret. The master secret will be stored at the server only. A tamper-resistant device MUST be used to store the master key and derive the shared secrets from the master key and some public information. The main benefit would be to avoid the exposure of the shared secrets at any time and also avoid specific requirements on storage, since the shared secrets could be generated on-demand when needed at provisioning and validation time.",
      "ja": "可能な戦略は、マスターシークレットから共有秘密を導出することです。マスターシークレットは、サーバで保存されます。耐タンパデバイスは、マスターキーを格納したマスター鍵と、いくつかの公開情報から共有秘密を導出するために使用されなければなりません。主な利点は、プロビジョニングと検証時に、必要なときに共有秘密は、オンデマンドで生成される可能性があるため、いつでも共有秘密の暴露を避け、また、ストレージ上の特定の要件を避けることであろう。"
    },
    {
      "indent": 3,
      "text": "We distinguish two different cases:",
      "ja": "我々は2つの異なるケースを区別します："
    },
    {
      "indent": 6,
      "text": "- A single master key MK is used to derive the shared secrets; each HOTP device has a different secret, K_i = SHA-1 (MK,i) where i stands for a public piece of information that identifies uniquely the HOTP device such as a serial number, a token ID, etc. Obviously, this is in the context of an application or service -- different application or service providers will have different secrets and settings. - Several master keys MK_i are used and each HOTP device stores a set of different derived secrets, {K_i,j = SHA-1(MK_i,j)} where j stands for a public piece of information identifying the device. The idea would be to store ONLY the active master key at the validation server, in the Hardware Security Module (HSM), and keep in a safe place, using secret sharing methods such as [Shamir] for instance. In this case, if a master secret MK_i is compromised, then it is possible to switch to another secret without replacing all the devices.",
      "ja": " - 単一のマスターキーMKは、共有秘密を導出するために使用されます。各HOTPデバイスは、異なる秘密を有し、K_I = SHA-1（MK、I）iは等シリアル番号、トークンID、などのHOTPデバイスは明らかに、これはである一意に識別する情報の公開部分を表す場合アプリケーションやサービスのコンテキスト - 異なるアプリケーションやサービスプロバイダは、異なる秘密と設定があります。 - いくつかの使用されているMK_iマスターキー及び各HOTPデバイス格納jがデバイスを識別する情報の公開部分を表す異なる派生秘密の集合{K_I、J = SHA-1（MK_i、J）}。アイデアは、このような場合のために[シャミール]として秘密分散法を使用して、ハードウェアセキュリティモジュール（HSM）で、検証サーバでのみアクティブマスターキーを格納し、安全な場所に保管することです。マスタシークレットMK_iが損なわれている場合この場合、すべてのデバイスを交換することなく別の秘密に切り替えることが可能です。"
    },
    {
      "indent": 3,
      "text": "The drawback in the deterministic case is that the exposure of the master secret would obviously enable an attacker to rebuild any shared secret based on correct public information. The revocation of all secrets would be required, or switching to a new set of secrets in the case of multiple master keys.",
      "ja": "決定論的な場合の欠点は、マスターシークレットの露出は明らかに正しい公開情報に基づいて任意の共有秘密を再構築するために、攻撃者が可能になるであろうということです。すべての秘密の取り消しは必要、または複数のマスターキーの場合の秘密の新しいセットに切り替えることになります。"
    },
    {
      "indent": 3,
      "text": "On the other hand, the device used to store the master key(s) and generate the shared secrets MUST be tamper resistant. Furthermore, the HSM will not be exposed outside the security perimeter of the validation system, therefore reducing the risk of leakage.",
      "ja": "一方、マスターキー（S）を保存し、共有秘密を生成するために使用されるデバイスは、耐タンパ性でなければなりません。また、HSMは、したがって、漏れの危険性を低減する、検証システムのセキュリティ境界の外側に露出されません。"
    },
    {
      "indent": 3,
      "text": "Random Generation\n-----------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The shared secrets are randomly generated. We RECOMMEND following the recommendations in [RFC4086] and selecting a good and secure random source for generating these secrets. A (true) random generator requires a naturally occurring source of randomness. Practically, there are two possible avenues to consider for the generation of the shared secrets:",
      "ja": "共有シークレットはランダムに生成されます。私たちは、[RFC4086]の勧告に従い、これらの秘密を生成するために良いと安全な乱数ソースを選択することをお勧めします。 （真）乱数発生器は、ランダム性の天然の供給源が必要です。実際には、共有秘密の世代のために考慮するための2つの可能な道があります。"
    },
    {
      "indent": 3,
      "text": " * Hardware-based generators: they exploit the randomness that occurs in physical phenomena. A nice implementation can be based on oscillators and built in such ways that active attacks are more difficult to perform.",
      "ja": "*ハードウェアベースの発電機：彼らは物理現象で発生するランダム性を利用します。素敵な実装では、発振器に基づいて、アクティブな攻撃を実行することがより困難になるような方法で構築することができます。"
    },
    {
      "indent": 3,
      "text": " * Software-based generators: designing a good software random generator is not an easy task. A simple, but efficient, implementation should be based on various sources and apply to the sampled sequence a one-way function such as SHA-1.",
      "ja": "*ソフトウェアベースの発電機：良いソフトウェア乱数生成器を設計することは簡単な作業ではありません。単純な、しかし効率的な実装は、さまざまなソースに基づいており、そのようなSHA-1のようにサンプリングされた配列に一方向関数を適用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "We RECOMMEND selecting proven products, being hardware or software generators, for the computation of shared secrets.",
      "ja": "私たちは、共有秘密の計算のために、ハードウェアまたはソフトウェアの発電機である、実績のある製品を選択することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "We also RECOMMEND storing the shared secrets securely, and more specifically encrypting the shared secrets when stored using tamper-resistant hardware encryption and exposing them only when required: for example, the shared secret is decrypted when needed to verify an HOTP value, and re-encrypted immediately to limit exposure in the RAM for a short period of time. The data store holding the shared secrets MUST be in a secure area, to avoid as much as possible direct attack on the validation system and secrets database.",
      "ja": "我々はまた、確実に共有秘密を格納するお勧めし、より具体的に保存した場合、耐タンパハードウェア暗号化を使用して共有秘密を暗号化し、必要な場合にのみ、それらを露出：HOTP値を確認する必要がある場合、例えば、共有秘密を解読し、再短時間のRAMでの露出を制限するために、すぐに暗号化されました。共有秘密を保持するデータストアは、検証システムと秘密データベース上で可能な直接攻撃な限り避けるために、安全な場所になければなりません。"
    },
    {
      "indent": 3,
      "text": "Particularly, access to the shared secrets should be limited to programs and processes required by the validation system only. We will not elaborate on the different security mechanisms to put in place, but obviously, the protection of shared secrets is of the uttermost importance.",
      "ja": "特に、共有秘密へのアクセスは、検証システムで必要なプログラムやプロセスに限定されるべきです。私たちは、場所に置くために、異なるセキュリティ・メカニズムについて詳しく説明しませんが、明らかに、共有秘密の保護はuttermost重要です。"
    },
    {
      "indent": 0,
      "text": "8. Composite Shared Secrets",
      "section_title": true,
      "ja": "8.コンポジット共有の秘密"
    },
    {
      "indent": 3,
      "text": "It may be desirable to include additional authentication factors in the shared secret K. These additional factors can consist of any data known at the token but not easily obtained by others. Examples of such data include:",
      "ja": "これらの追加の因子はトークンで知られているが、容易に他の人によって得られていない任意のデータで構成することができ、共有秘密K.における追加の認証要素を含むことが望ましいです。このようなデータの例としては、"
    },
    {
      "indent": 6,
      "text": "* PIN or Password obtained as user input at the token * Phone number * Any unique identifier programmatically available at the token",
      "ja": "* PINまたはパスワードトークンにおけるプログラムで利用可能なトークン*電話番号*任意の一意の識別子のユーザ入力として得られました"
    },
    {
      "indent": 3,
      "text": "In this scenario, the composite shared secret K is constructed during the provisioning process from a random seed value combined with one or more additional authentication factors. The server could either build on-demand or store composite secrets -- in any case, depending on implementation choice, the token only stores the seed value. When the token performs the HOTP calculation, it computes K from the seed value and the locally derived or input values of the other authentication factors.",
      "ja": "このシナリオでは、複合共有秘密Kは、1つの以上の追加認証要素と組み合わせたランダムシード値からプロビジョニング・プロセス中に構成されています。サーバーは、オンデマンドで構築したり、複合秘密を格納することができどちらか - どのような場合には、実装の選択に応じて、トークンは唯一のシード値を格納します。トークンがHOTP計算を行う場合には、シード値と他の認証要素の局所的に誘導された、または入力値からKを計算します。"
    },
    {
      "indent": 3,
      "text": "The use of composite shared secrets can strengthen HOTP-based authentication systems through the inclusion of additional authentication factors at the token. To the extent that the token is a trusted device, this approach has the further benefit of not requiring exposure of the authentication factors (such as the user input PIN) to other devices.",
      "ja": "複合共有シークレットを使用することは、トークンに追加の認証要素を含めることによってHOTPベースの認証システムを強化することができます。トークンは、信頼できるデバイスである程度まで、このアプローチは、他のデバイスに（例えば、ユーザ入力PINのような）認証要素の露出を必要としないというさらなる利点を有します。"
    },
    {
      "indent": 0,
      "text": "9. Bi-Directional Authentication",
      "section_title": true,
      "ja": "9.双方向認証"
    },
    {
      "indent": 3,
      "text": "Interestingly enough, the HOTP client could also be used to authenticate the validation server, claiming that it is a genuine entity knowing the shared secret.",
      "ja": "興味深いことに、HOTPクライアントはまた、共有秘密を知っている本物のエンティティであることを主張し、検証サーバを認証するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Since the HOTP client and the server are synchronized and share the\nsame secret (or a method to recompute it), a simple 3-pass protocol\ncould be put in place:\n1- The end user enter the TokenID and a first OTP value OTP1;\n2- The server checks OTP1 and if correct, sends back OTP2;\n3- The end user checks OTP2 using his HOTP device and if correct,\n   uses the web site.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Obviously, as indicated previously, all the OTP communications have to take place over a secure channel, e.g., SSL/TLS, IPsec connections.",
      "ja": "以前に示したように明らかに、すべてのOTPの通信が保護されたチャネル、例えば、SSL / TLS、IPsec接続を介して行わなければなりません。"
    },
    {
      "indent": 0,
      "text": "10. Conclusion",
      "section_title": true,
      "ja": "10.おわりに"
    },
    {
      "indent": 3,
      "text": "This document describes HOTP, a HMAC-based One-Time Password algorithm. It also recommends the preferred implementation and related modes of operations for deploying the algorithm.",
      "ja": "この文書では、HOTP、HMACベースのワンタイムパスワードアルゴリズムを記述しています。また、アルゴリズムを展開するための好ましい実施し、業務の関連モードを推奨しています。"
    },
    {
      "indent": 3,
      "text": "The document also exhibits elements of security and demonstrates that the HOTP algorithm is practical and sound, the best possible attack being a brute force attack that can be prevented by careful implementation of countermeasures in the validation server.",
      "ja": "文書はまた、セキュリティの要素を示し、HOTPアルゴリズムは、検証サーバでの対策を慎重に実装することによって防止することができるブルートフォース攻撃をされて可能な限り最高の攻撃は、実用的かつ健全であることを示しています。"
    },
    {
      "indent": 3,
      "text": "Eventually, several enhancements have been proposed, in order to improve security if needed for specific applications.",
      "ja": "最終的には、いくつかの拡張機能は、特定の用途のために必要であれば、セキュリティを向上させるためには、提案されています。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "ja": "11.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Siddharth Bajaj, Alex Deacon, Loren Hart, and Nico Popp for their help during the conception and redaction of this document.",
      "ja": "著者は、この文書の概念と改訂の際に彼らの助けのためシッダールタバジャジ、アレックス・ディーコン、ローレン・ハート、そしてニコPoppのを感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "12. Contributors",
      "section_title": true,
      "ja": "12.協力者"
    },
    {
      "indent": 3,
      "text": "The authors of this document would like to emphasize the role of three persons who have made a key contribution to this document:",
      "ja": "本書の著者は、この文書への重要な貢献をした3つの者の役割を強調したいと思います："
    },
    {
      "indent": 3,
      "text": "- Laszlo Elteto is system architect with SafeNet, Inc.",
      "ja": " - ラズロEltetoはSafeNetの社とのシステムアーキテクトであります"
    },
    {
      "indent": 3,
      "text": "- Ernesto Frutos is director of Engineering with Authenex, Inc.",
      "ja": " - エルネスト・フルートスはAuthenex社とエンジニアリングのディレクターであります"
    },
    {
      "indent": 3,
      "text": "- Fred McClain is Founder and CTO with Boojum Mobile, Inc.",
      "ja": " - フレッド・マクレーンはBoojumモバイル社と創業者兼CTOであります"
    },
    {
      "indent": 3,
      "text": "Without their advice and valuable inputs, this document would not be the same.",
      "ja": "彼らのアドバイスや貴重な入力がなければ、この文書は同じではないでしょう。"
    },
    {
      "indent": 0,
      "text": "13. References",
      "section_title": true,
      "ja": "13.参考文献"
    },
    {
      "indent": 0,
      "text": "13.1. Normative References",
      "section_title": true,
      "ja": "13.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[BCK1] M. Bellare, R. Canetti and H. Krawczyk, \"Keyed Hash Functions and Message Authentication\", Proceedings of Crypto'96, LNCS Vol. 1109, pp. 1-15.",
      "ja": "【BCK1] M.ベラー、R.カネッティおよびH. Krawczyk、 \"鍵付きハッシュ関数及びメッセージ認証\"、Crypto'96、LNCS VOLの議事。 1109年、頁1-15。"
    },
    {
      "indent": 3,
      "text": "[BCK2] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "【BCK2] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3979] Bradner, S., \"Intellectual Property Rights in IETF Technology\", BCP 79, RFC 3979, March 2005.",
      "ja": "[RFC3979]ブラドナーの、S.、 \"IETF技術の知的財産権\"、BCP 79、RFC 3979、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、3、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 0,
      "text": "13.2. Informative References",
      "section_title": true,
      "ja": "13.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[OATH] Initiative for Open AuTHentication http://www.openauthentication.org",
      "ja": "[OATH]オープン認証のためのイニシアティブhttp://www.openauthentication.org"
    },
    {
      "indent": 3,
      "text": "[PrOo] B. Preneel and P. van Oorschot, \"MD-x MAC and building fast MACs from hash functions\", Advances in Cryptology CRYPTO '95, Lecture Notes in Computer Science Vol. 963, D. Coppersmith ed., Springer-Verlag, 1995.",
      "ja": "[PrOo] B. PreneelとP.バンOorschot、「MD-X MACおよびハッシュ関数から速いMACを構築する」は、暗号学CRYPTO '95の進歩、コンピュータサイエンス巻で講義ノート。 963、D.銅細工編、シュプリンガー・フェアラーク、1995。"
    },
    {
      "indent": 3,
      "text": "[Crack] Crack in SHA-1 code 'stuns' security gurus http://www.eetimes.com/showArticle.jhtml? articleID=60402150",
      "ja": "SHA-1のコード「スタン」セキュリティの達人で[クラック]クラックhttp://www.eetimes.com/showArticle.jhtml？情報でarticleID = 60402150"
    },
    {
      "indent": 3,
      "text": "[Sha1] Bruce Schneier. SHA-1 broken. February 15, 2005. http://www.schneier.com/blog/archives/2005/02/ sha1_broken.html",
      "ja": "[SHA1]ブルース・シュナイアー。 SHA-1壊れました。 2月15日、2005年http://www.schneier.com/blog/archives/2005/02/ sha1_broken.html"
    },
    {
      "indent": 3,
      "text": "[Res] Researchers: Digital encryption standard flawed http://news.com.com/ Researchers+Digital+encryption+standard+flawed/ 2100-1002-5579881.html?part=dht&tag=ntop&tag=nl.e703",
      "ja": "[RES]研究者：？不備デジタル暗号化標準http://news.com.com/研究者+デジタル+暗号化+標準+不備/ 2100-1002-5579881.html一部= DHT＆タグ= NTOP＆タグ= nl.e703"
    },
    {
      "indent": 3,
      "text": "[Shamir] How to Share a Secret, by Adi Shamir. In Communications of the ACM, Vol. 22, No. 11, pp. 612-613, November, 1979.",
      "ja": "[シャミール]アディ・シャミアによって秘密を、共有する方法。 ACM、巻のコミュニケーションで。 22、第11、頁612から613まで、1979年11月。"
    },
    {
      "indent": 0,
      "text": "Appendix A - HOTP Algorithm Security: Detailed Analysis",
      "ja": "付録A  -  HOTPアルゴリズムセキュリティ：詳細な分析"
    },
    {
      "indent": 3,
      "text": "The security analysis of the HOTP algorithm is summarized in this section. We first detail the best attack strategies, and then elaborate on the security under various assumptions and the impact of the truncation and make some recommendations regarding the number of digits.",
      "ja": "HOTPアルゴリズムのセキュリティ分析は、このセクションに要約されています。私たちは最初の詳細最高の攻撃戦略、そしてその後、様々な仮定の下で、セキュリティと切り捨ての影響について詳しく説明し、桁数に関するいくつかの提言を行います。"
    },
    {
      "indent": 3,
      "text": "We focus this analysis on the case where Digit = 6, i.e., an HOTP function that produces 6-digit values, which is the bare minimum recommended in this document.",
      "ja": "我々は、この文書で推奨最小限である6桁の値を生成する場合ここ桁= 6、即ち、HOTP関数でこの分析を集中します。"
    },
    {
      "indent": 0,
      "text": "A.1. Definitions and Notations",
      "ja": "A.1。定義と表記法"
    },
    {
      "indent": 3,
      "text": "We denote by {0,1}^l the set of all strings of length l.",
      "ja": "我々は、{0,1} ^ Lにより長さlのすべての文字列の集合を表します。"
    },
    {
      "indent": 3,
      "text": "Let Z_{n} = {0,.., n - 1}.",
      "ja": "Z_ {N} = { -  0,1、...、N}をしましょう。"
    },
    {
      "indent": 3,
      "text": "Let IntDiv(a,b) denote the integer division algorithm that takes input integers a, b where a >= b >= 1 and returns integers (q,r)",
      "ja": "INTDIVは（a、b）は、ここで> = B> = 1 bは整数および整数（Q、R）を返す入力をとる整数除算アルゴリズムを示すものと"
    },
    {
      "indent": 3,
      "text": "the quotient and remainder, respectively, of the division of a by b. (Thus, a = bq + r and 0 <= r < b.)",
      "ja": "Bによる分割のそれぞれ商と余り、、。 （したがって、A = BQ + R 0 <= R <B。）"
    },
    {
      "indent": 3,
      "text": "Let H: {0,1}^k x {0,1}^c --> {0,1}^n be the base function that takes a k-bit key K and c-bit counter C and returns an n-bit output H(K,C). (In the case of HOTP, H is HMAC-SHA-1; we use this formal definition for generalizing our proof of security.)",
      "ja": "Hしましょう：{0,1} ^ KX {0,1} ^ C  - > {0,1} ^ nはkビットの鍵KとCビットカウンタCを取り、N-を返す基底関数でありますビットの出力H（K、C）。 （HOTPの場合、HはHMAC-SHA-1であり、私たちは、セキュリティの私達の証明を一般化のため、この形式的な定義を使用します。）"
    },
    {
      "indent": 0,
      "text": "A.2. The Idealized Algorithm: HOTP-IDEAL",
      "ja": "A.2。理想化されたアルゴリズム：HOTP  -  IDEAL"
    },
    {
      "indent": 3,
      "text": "We now define an idealized counterpart of the HOTP algorithm. In this algorithm, the role of H is played by a random function that forms the key.",
      "ja": "私たちは今、HOTPアルゴリズムの理想的な対応を定義します。このアルゴリズムでは、Hの役割は、キーを形成してランダム関数によって再生されます。"
    },
    {
      "indent": 3,
      "text": "To be more precise, let Maps(c,n) denote the set of all functions mapping from {0,1}^c to {0,1}^n. The idealized algorithm has key space Maps(c,n), so that a \"key\" for such an algorithm is a function h from {0,1}^c to {0,1}^n. We imagine this key (function) to be drawn at random. It is not feasible to implement this idealized algorithm, since the key, being a function from {0,1}^c to {0,1}^n, is way too large to even store. So why consider it?",
      "ja": "具体的には、マップ（C、N）が{0,1} ^ nに{0,1} ^ Cからのすべての関数マッピングの集合を示すものとします。このようなアルゴリズムのための「キー」が{0,1} ^ nは{0,1} ^ Cから関数hされるようになっている。理想的なアルゴリズムは、鍵空間マップ（C、N）を有しています私たちは、このキー（機能）がランダムに描画する想像してください。キーは、{0,1} ^ Cから{0,1} ^ nまでの関数であっても店にあまりにも大きいので、この理想化されたアルゴリズムを実装することは不可能です。では、なぜそれを考慮？"
    },
    {
      "indent": 3,
      "text": "Our security analysis will show that as long as H satisfies a certain well-accepted assumption, the security of the actual and idealized algorithms is for all practical purposes the same. The task that really faces us, then, is to assess the security of the idealized algorithm.",
      "ja": "当社のセキュリティ分析は限りHは、特定の広く受け入れられ仮定を満たすように、実際と理想的なアルゴリズムのセキュリティは、すべての実用的な目的のために同じであることが表示されます。本当に私たちに直面している課題は、それから、理想的なアルゴリズムの安全性を評価することです。"
    },
    {
      "indent": 3,
      "text": "In analyzing the idealized algorithm, we are concentrating on assessing the quality of the design of the algorithm itself, independently of HMAC-SHA-1. This is in fact the important issue.",
      "ja": "理想的なアルゴリズムの分析では、我々は独立してHMAC-SHA-1の、アルゴリズム自体の設計の品質を評価することに集中しています。これは実際には重要な問題です。"
    },
    {
      "indent": 0,
      "text": "A.3. Model of Security",
      "ja": "A.3。セキュリティ・モデル"
    },
    {
      "indent": 3,
      "text": "The model exhibits the type of threats or attacks that are being considered and enables one to assess the security of HOTP and HOTP-IDEAL. We denote ALG as either HOTP or HOTP-IDEAL for the purpose of this security analysis.",
      "ja": "モデルが考慮され、HOTPとHOTP  -  IDEALのセキュリティを評価することを可能している脅威や攻撃の種類を示します。私たちは、このセキュリティ分析の目的のためにHOTPまたはHOTP  -  IDEALのいずれかとしALGを示します。"
    },
    {
      "indent": 3,
      "text": "The scenario we are considering is that a user and server share a key K for ALG. Both maintain a counter C, initially zero, and the user authenticates itself by sending ALG(K,C) to the server. The latter accepts if this value is correct.",
      "ja": "我々が検討しているシナリオは、ユーザとサーバを共有することをALGのための鍵Kです。双方は、カウンタC、最初にゼロを維持し、ユーザがサーバにALG（K、C）を送信することによって自身を認証します。この値が正しい場合、後者は受け入れ。"
    },
    {
      "indent": 3,
      "text": "In order to protect against accidental increment of the user counter, the server, upon receiving a value z, will accept as long as z equals ALG(K,i) for some i in the range C,...,C + s-1, where s is the resynchronization parameter and C is the server counter. If it accepts with some value of i, it then increments its counter to i+1. If it does not accept, it does not change its counter value.",
      "ja": "ユーザカウンタの偶発的な増加から保護するために、サーバは、値zを受信すると、いくつかのI範囲Cにおいて、...、C + S-ため限りzがALG（K、I）に等しいとして受け入れますsは再同期化パラメータであり、Cは、サーバカウンタ1、。それは私のいくつかの値を受け入れた場合、それは、私+ 1にそのカウンタをインクリメント。それが受け入れない場合は、そのカウンタ値を変更しません。"
    },
    {
      "indent": 3,
      "text": "The model we specify captures what an adversary can do and what it needs to achieve in order to \"win\". First, the adversary is assumed to be able to eavesdrop, meaning, to see the authenticator transmitted by the user. Second, the adversary wins if it can get the server to accept an authenticator relative to a counter value for which the user has never transmitted an authenticator.",
      "ja": "私たちが指定したモデルでは、敵が何ができるかをキャプチャし、それが「勝つ」ために達成するために必要なもの。まず、敵は、ユーザーが送信した認証子を見て、意味を盗聴することを想定しています。それは、ユーザがオーセンティケータを送信したことのないするカウンタ値にオーセンティケータの相対を受け入れるようにサーバーを取得することができれば第二に、敵対者は勝ちます。"
    },
    {
      "indent": 3,
      "text": "The formal adversary, which we denote by B, starts out knowing which algorithm ALG is being used, knowing the system design, and knowing all system parameters. The one and only thing it is not given a priori is the key K shared between the user and the server.",
      "ja": "我々はBで表す正式な敵は、アルゴリズムALGは、システム設計を知って、使用されている知って開始し、すべてのシステムパラメータを知ります。それが先験的に与えられていない唯一の事はユーザとサーバとの間で共有されるキーKです。"
    },
    {
      "indent": 3,
      "text": "The model gives B full control of the scheduling of events. It has access to an authenticator oracle representing the user. By calling this oracle, the adversary can ask the user to authenticate itself and get back the authenticator in return. It can call this oracle as often as it wants and when it wants, using the authenticators it accumulates to perhaps \"learn\" how to make authenticators itself. At any time, it may also call a verification oracle, supplying the latter with a candidate authenticator of its choice. It wins if the server accepts this accumulator.",
      "ja": "モデルは、イベントのスケジューリングのB完全に制御できます。これは、ユーザーを表すオーセンティケータオラクルへのアクセス権を持っています。この神託を呼び出すことによって、敵は自分自身を認証し、見返りにオーセンティケータを取り戻すためにユーザーに確認することができます。それはおそらく、認証デバイス自体を作る方法を「学習」するために蓄積認証デバイスを使用して、できるだけ頻繁にそれは望んでいるし、それが望んでいるときのように、この神託を呼び出すことができます。いつでも、それはまた、その選択の候補オーセンティケータと後者を供給、検証神託を呼び出すことができます。サーバは、このアキュムレータを受け入れるかどうかは勝ちます。"
    },
    {
      "indent": 3,
      "text": "Consider the following game involving an adversary B that is attempting to compromise the security of an authentication algorithm ALG: K x {0,1}^c --> R.",
      "ja": "認証アルゴリズムALGのセキュリティを侵害しようとしている敵のBを含む、以下のゲームを考える：KのX {0,1} ^ C  - > R."
    },
    {
      "indent": 3,
      "text": "Initializations - A key K is selected at random from K, a counter C is initialized to 0, and the Boolean value win is set to false.",
      "ja": "初期化 - キーKがKからランダムに選択され、カウンタCを0に初期化され、およびブール値の勝利はfalseに設定されています。"
    },
    {
      "indent": 3,
      "text": "Game execution - Adversary B is provided with the two following oracles:",
      "ja": "ゲームの実行 - 敵対Bは、次の二つの神託を備えています。"
    },
    {
      "indent": 3,
      "text": "Oracle AuthO()\n--------------\n   A = ALG(K,C)\n   C = C + 1\n   Return O to B",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Oracle VerO(A)\n--------------\n   i = C\n   While (i <= C + s - 1 and Win == FALSE) do\n      If A == ALG(K,i) then Win = TRUE; C = i + 1\n      Else i = i + 1\n   Return Win to B",
      "raw": true
    },
    {
      "indent": 3,
      "text": "AuthO() is the authenticator oracle and VerO(A) is the verification oracle.",
      "ja": "AuthO（）は、オーセンティケータオラクルであるとVERO（A）は、検証オラクルです。"
    },
    {
      "indent": 3,
      "text": "Upon execution, B queries the two oracles at will. Let Adv(B) be the probability that win gets set to true in the above game. This is the probability that the adversary successfully impersonates the user.",
      "ja": "実行されると、Bは意志で2つの神託を照会します。前売（B）は上記のゲームでtrueに設定されます勝つ確率とします。これは、敵が成功したユーザーを偽装する確率です。"
    },
    {
      "indent": 3,
      "text": "Our goal is to assess how large this value can be as a function of the number v of verification queries made by B, the number a of authenticator oracle queries made by B, and the running time t of B. This will tell us how to set the throttle, which effectively upper bounds v.",
      "ja": "私たちの目標は、これはどのように私たちに教えてくれます。この値はB、数Bによって作られたオーセンティケータのOracleクエリの、とBの実行中の時間tによる検証クエリの数vの関数としてすることができますどのように大きな評価することですスロットル、有効上限Vを設定します。"
    },
    {
      "indent": 0,
      "text": "A.4. Security of the Ideal Authentication Algorithm",
      "ja": "A.4。理想認証アルゴリズムのセキュリティ"
    },
    {
      "indent": 3,
      "text": "This section summarizes the security analysis of HOTP-IDEAL, starting with the impact of the conversion modulo 10^Digit and then focusing on the different possible attacks.",
      "ja": "このセクションでは、変換モジュロ10 ^桁の影響で始まり、その後、別の攻撃の可能性に焦点を当て、HOTP  -  IDEALのセキュリティ分析をまとめました。"
    },
    {
      "indent": 0,
      "text": "A.4.1. From Bits to Digits",
      "ja": "A.4.1。ビットから数字へ"
    },
    {
      "indent": 3,
      "text": "The dynamic offset truncation of a random n-bit string yields a random 31-bit string. What happens to the distribution when it is taken modulo m = 10^Digit, as done in HOTP?",
      "ja": "ランダムなnビットストリングのダイナミックオフセット切捨ては、ランダム31ビットのビット列が得られます。何がHOTPに行ったようそれは、モジュロM = 10 ^桁取られる分布はどうなりますか？"
    },
    {
      "indent": 3,
      "text": "The following lemma estimates the biases in the outputs in this case.",
      "ja": "次の補題は、この場合の出力のバイアスを推定します。"
    },
    {
      "indent": 3,
      "text": "Lemma 1\n-------\nLet N >= m >= 1 be integers, and let (q,r) = IntDiv(N,m).  For z in\nZ_{m} let:",
      "raw": true
    },
    {
      "indent": 10,
      "text": "P_{N,m}(z) = Pr [x mod m = z : x randomly pick in Z_{n}]",
      "ja": "P_ {N、M}（Z）= Prの[X MOD M = Z：ランダム{N} Z_に選ぶX]"
    },
    {
      "indent": 3,
      "text": "Then for any z in Z_{m}",
      "ja": "次いでZ_ {M}内の任意のZのための"
    },
    {
      "indent": 3,
      "text": "P_{N,m}(z) = (q + 1) / N if 0 <= z < r q / N if r <= z < m",
      "ja": "P_ {N、M}（Z）=（Q + 1）/ Nであれば、0 <= Z <R Q / N <= Z <M rの場合"
    },
    {
      "indent": 3,
      "text": "Proof of Lemma 1\n----------------\nLet the random variable X be uniformly distributed over Z_{N}.  Then:",
      "raw": true
    },
    {
      "indent": 3,
      "text": "P_{N,m}(z) = Pr [X mod m = z]",
      "ja": "（[= Z Q z上順に）] P_ {NOT IN}"
    },
    {
      "indent": 16,
      "text": "= Pr [X < mq] * Pr [X mod m = z| X < mq]\n+ Pr [mq <= X < N] * Pr [X mod m = z| mq <= X < N]",
      "raw": true
    },
    {
      "indent": 16,
      "text": "= mq/N * 1/m + (N - mq)/N * 1 / (N - mq) if 0 <= z < N - mq 0 if N - mq <= z <= m",
      "ja": "= MQ / N * 1 / M +（N  -  MQ）/ N * 1 /（N  -  MQ）であれば、0 <= Z <N  -  MQ 0であればN  -  MQ <= Z <= M"
    },
    {
      "indent": 16,
      "text": "= q/N + r/N * 1 / r if 0 <= z < N - mq 0 if r <= z <= m",
      "ja": "= Q / N + R / N * 1 / Rであれば、0 <= Z <N  -  MQ 0の場合、R <= Z <= M"
    },
    {
      "indent": 3,
      "text": "Simplifying yields the claimed equation.",
      "ja": "簡素化は、特許請求の方程式が得られます。"
    },
    {
      "indent": 3,
      "text": "Let N = 2^31, d = 6, and m = 10^d. If x is chosen at random from Z_{N} (meaning, is a random 31-bit string), then reducing it to a 6- digit number by taking x mod m does not yield a random 6-digit number.",
      "ja": "N = 2 ^ 31、D = 6、M = 10 ^ Dをしましょう。 XがZ_ {N}（意味は、ランダムな31ビットのビット列である）からランダムに選択された場合、X MOD Mを取ることによって、6-桁数にそれを減少させることランダム6桁の数字が得られません。"
    },
    {
      "indent": 3,
      "text": "Rather, x mod m is distributed as shown in the following table:",
      "ja": "むしろ、以下の表に示すようにMOD Mが配布される×："
    },
    {
      "indent": 3,
      "text": "Values               Probability that each appears as output\n----------------------------------------------------------------\n0,1,...,483647       2148/2^31 roughly equals to 1.00024045/10^6\n483648,...,999999    2147/2^31 roughly equals to 0.99977478/10^6",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If X is uniformly distributed over Z_{2^31} (meaning, is a random 31-bit string), then the above shows the probabilities for different outputs of X mod 10^6. The first set of values appears with probability slightly greater than 10^-6, the rest with probability slightly less, meaning that the distribution is slightly non-uniform.",
      "ja": "Xが均一Z_ {2 ^ 31}（意味は、ランダムな31ビットのビット列である）上に分散されている場合、上記のX MOD 10 ^ 6の異なる出力の確率を示します。値の最初の組は、分布がやや不均一であることを意味し、10 ^ -6よりもわずかに大きい確率、わずかに低い確率で、残りが表示されます。"
    },
    {
      "indent": 3,
      "text": "However, as the table above indicates, the bias is small, and as we will see later, negligible: the probabilities are very close to 10^-6.",
      "ja": "上記の表が示すようしかし、バイアスが小さく、我々は後で見るように、無視できる：確率は、10 ^ -6に非常に近いです。"
    },
    {
      "indent": 0,
      "text": "A.4.2. Brute Force Attacks",
      "ja": "A.4.2。ブルートフォース攻撃"
    },
    {
      "indent": 3,
      "text": "If the authenticator consisted of d random digits, then a brute force attack using v verification attempts would succeed with probability sv/10^Digit.",
      "ja": "オーセンティケータは、Dランダム数字で構成した場合、その後、V検証の試みを使用してブルートフォース攻撃は確率SV / 10 ^桁で成功するでしょう。"
    },
    {
      "indent": 3,
      "text": "However, an adversary can exploit the bias in the outputs of HOTP-IDEAL, predicted by Lemma 1, to mount a slightly better attack.",
      "ja": "しかし、敵はわずかに良い攻撃をマウントし、補題1により予測HOTP  -  IDEALの出力におけるバイアスを、利用することができます。"
    },
    {
      "indent": 3,
      "text": "Namely, it makes authentication attempts with authenticators that are the most likely values, meaning the ones in the range 0,...,r - 1, where (q,r) = IntDiv(2^31,10^Digit).",
      "ja": "1、（Q、R）= INTDIV（2 ^ ^ 31,10桁） - すなわち、それは範囲0、...、Rでものを意味し、最も可能性の高い値であり、認証者と認証試行を行います。"
    },
    {
      "indent": 3,
      "text": "The following specifies an adversary in our model of security that mounts the attack. It estimates the success probability as a function of the number of verification queries.",
      "ja": "以下は、攻撃をマウントし、セキュリティの我々のモデルで敵を指定します。これは、検証クエリの数の関数としての成功確率を推定します。"
    },
    {
      "indent": 3,
      "text": "For simplicity, we assume that the number of verification queries is at most r. With N = 2^31 and m = 10^6, we have r = 483,648, and the throttle value is certainly less than this, so this assumption is not much of a restriction.",
      "ja": "簡単にするために、我々は検証クエリの数が多くともrであることを前提としています。 N = 2 ^ 31、M = 10 ^ 6は、我々は、r = 483648を有する、スロットル値はこれより確かに小さいので、この仮定は制限のあまりないと。"
    },
    {
      "indent": 3,
      "text": "Proposition 1\n-------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Suppose m = 10^Digit < 2^31, and let (q,r) = IntDiv(2^31,m). Assume s <= m. The brute-force-attack adversary B-bf attacks HOTP using v <= r verification oracle queries. This adversary makes no authenticator oracle queries, and succeeds with probability",
      "ja": "M = 10 ^桁<2 ^ 31仮定する、及び（Q、R）= INTDIV（2 ^ 31、M）とします。 S <= Mをとります。ブルートフォース攻撃を敵B-BF攻撃は、V <= R検証オラクルクエリを使用HOTP。この敵は何のオーセンティケータのOracleクエリを行うものではありません、そして確率で成功します"
    },
    {
      "indent": 20,
      "text": "Adv(B-bf) = 1 - (1 - v(q+1)/2^31)^s",
      "ja": "ADV（B-BF）= 1  - （1  -  V（Q + 1）/ 2 ^ 31）^ S"
    },
    {
      "indent": 3,
      "text": "which is roughly equal to",
      "ja": "これにほぼ等しいです。"
    },
    {
      "indent": 29,
      "text": "sv * (q+1)/2^31",
      "ja": "ST *（S + 1）/ 2 ^ 31"
    },
    {
      "indent": 3,
      "text": "With m = 10^6 we get q = 2,147. In that case, the brute force attack using v verification attempts succeeds with probability",
      "ja": "mは= 10 ^ 6は、我々は、Q = 2147を取得します。その場合には、V検証試行を使用してブルートフォース攻撃は確率で成功します"
    },
    {
      "indent": 9,
      "text": "Adv(B-bf) roughly = sv * 2148/2^31 = sv * 1.00024045/10^6",
      "ja": "ADV（B-BF）おおよそ= SV * 2分の2148 ^ 31 = SV * 1.00024045 / 10 ^ 6"
    },
    {
      "indent": 3,
      "text": "As this equation shows, the resynchronization parameter s has a significant impact in that the adversary's success probability is proportional to s. This means that s cannot be made too large without compromising security.",
      "ja": "敵の成功確率はSに比例しているという点で、この式が示すように、再同期パラメータsは大きな影響を与えます。これは、sが、セキュリティを損なうことなく、あまり大きくできないことを意味します。"
    },
    {
      "indent": 0,
      "text": "A.4.3. Brute force attacks are the best possible attacks.",
      "ja": "A.4.3。ブルートフォース攻撃は、可能な限り最高の攻撃です。"
    },
    {
      "indent": 3,
      "text": "A central question is whether there are attacks any better than the brute force one. In particular, the brute force attack did not attempt to collect authenticators sent by the user and try to cryptanalyze them in an attempt to learn how to better construct authenticators. Would doing this help? Is there some way to \"learn\" how to build authenticators that result in a higher success rate than given by the brute-force attack?",
      "ja": "中央の質問は、ブルートフォース1よりも良く攻撃があるかどうかです。具体的には、ブルートフォース攻撃は、ユーザーが送信認証子を収集し、より優れた認証子を構築する方法を学習しようとする試みでそれらをcryptanalyzeしようとしようとしませんでした。このヘルプをしていますか？ブルートフォース攻撃によって与えられるよりも高い成功率につながる認証子を構築する方法を「学習」するためにいくつかの方法はありますか？"
    },
    {
      "indent": 3,
      "text": "The following says the answer to these questions is no. No matter what strategy the adversary uses, and even if it sees, and tries to exploit, the authenticators from authentication attempts of the user, its success probability will not be above that of the brute force attack -- this is true as long as the number of authentications it observes is not incredibly large. This is valuable information regarding the security of the scheme.",
      "ja": "以下は、これらの質問への答えはノーであると言います。どんな戦略敵対者が使用しており、それが見ても、そして活用しようとすると、利用者の認証試行からのオーセンティケータ、その成功確率がブルートフォース攻撃のそれを超えることはありません - これは限り真実ではありませんそれは観察認証の数が非常に大規模ではありません。これは、スキームのセキュリティに関する貴重な情報です。"
    },
    {
      "indent": 3,
      "text": "Proposition 2 ------------- Suppose m = 10^Digit < 2^31, and let\n(q,r) = IntDiv(2^31,m).  Let B be any adversary attacking HOTP-IDEAL\nusing v verification oracle queries and a <= 2^c - s authenticator\noracle queries.  Then",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Adv(B) < = sv * (q+1)/ 2^31",
      "ja": "ADV（B）<= SV *（Q + 1）/ 2 ^ 31"
    },
    {
      "indent": 3,
      "text": "Note: This result is conditional on the adversary not seeing more than 2^c - s authentications performed by the user, which is hardly restrictive as long as c is large enough.",
      "ja": "注：この結果は以上2 ^ Cが表示されない敵を条件と -  S限りcが十分な大きさであるようにほとんど限定されたユーザによって実行さ認証。"
    },
    {
      "indent": 3,
      "text": "With m = 10^6, we get q = 2,147. In that case, Proposition 2 says that any adversary B attacking HOTP-IDEAL and making v verification attempts succeeds with probability at most",
      "ja": "M = 10 ^ 6で、我々は、Q = 2147を取得します。その場合には、命題2は、任意の敵B HOTP  -  IDEAL攻撃とV検証の試行を行うことがせいぜい確率で成功することを言います"
    },
    {
      "indent": 3,
      "text": "Equation 1\n----------\n           sv * 2148/2^31 roughly = sv * 1.00024045/10^6",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Meaning, B's success rate is not more than that achieved by the brute force attack.",
      "ja": "つまり、Bの成功率は、ブルートフォース攻撃によって達成されるよりも多くのではありません。"
    },
    {
      "indent": 0,
      "text": "A.5. Security Analysis of HOTP",
      "ja": "A.5。 HOTPのセキュリティ分析"
    },
    {
      "indent": 3,
      "text": "We have analyzed, in the previous sections, the security of the idealized counterparts HOTP-IDEAL of the actual authentication algorithm HOTP. We now show that, under appropriate and well-believed assumption on H, the security of the actual algorithms is essentially the same as that of its idealized counterpart.",
      "ja": "我々は、前のセクションでは、実際の認証アルゴリズムHOTPの理想的な相手のHOTP  -  IDEALのセキュリティを分析しました。私たちは今、H上の適切な、よく考えられて仮定の下で、実際のアルゴリズムのセキュリティは、基本的にその理想的な対応のものと同じであることを示しています。"
    },
    {
      "indent": 3,
      "text": "The assumption in question is that H is a secure pseudorandom function, or PRF, meaning that its input-output values are indistinguishable from those of a random function in practice.",
      "ja": "問題の仮定は、Hがその入力 - 出力値は実際にはランダム関数のものと区別がつかないことを意味し、安全な擬似ランダム機能、またはPRFであるということです。"
    },
    {
      "indent": 3,
      "text": "Consider an adversary A that is given an oracle for a function f: {0,1}^c --> {0, 1}^n and eventually outputs a bit. We denote Adv(A) as the prf-advantage of A, which represents how well the adversary does at distinguishing the case where its oracle is H(K,.) from the case where its oracle is a random function of {0,1}^c to {0,1}^n.",
      "ja": "関数fは、Oracleが与えられる攻撃者Aを考える：{0,1} ^ C  - > {0,1} ^ nは、最終的にビットを出力します。我々は、Oracleが{0,1のランダム関数である場合の敵対者がそのOracleがH（K ,.）である場合を区別でない方法も表すAのPRF-利点として、広告主（A）を示します} ^ {0,1} ^ nとC。"
    },
    {
      "indent": 3,
      "text": "One possible attack is based on exhaustive search for the key K. If A runs for t steps and T denotes the time to perform one computation of H, its prf-advantage from this attack turns out to be (t/T)2^-k. Another possible attack is a birthday one [PrOo], whereby A can attain advantage p^2/2^n in p oracle queries and running time about pT.",
      "ja": "一つの可能​​な攻撃は鍵KもしAがt手順について実行され、Tは、Hのいずれかの計算を実行する時間を意味するため、この攻撃からのPRF-利点は、（T / T）であることが判明した徹底的な検索に基づいている2 ^  - K。別の可能な攻撃は、Pt約利点P ^ 2/2 ^ Pオラクルクエリでnおよび実行時間を達成することができる誕生日1 [PrOo]、です。"
    },
    {
      "indent": 3,
      "text": "Our assumption is that these are the best possible attacks. This translates into the following.",
      "ja": "私たちの仮定は、これらは可能な限り最高の攻撃があるということです。これは、次のように変換されます。"
    },
    {
      "indent": 3,
      "text": "Assumption 1\n------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Let T denotes the time to perform one computation of H. Then if A is any adversary with running time at most t and making at most p oracle queries,",
      "ja": "TはHの1の計算を実行するための時間を示してみましょうその後、Aが最もtの時間を実行すると、ほとんどのpのOracleクエリで作るとどんな敵がいる場合には、"
    },
    {
      "indent": 23,
      "text": "Adv(A) <= (t/T)/2^k + p^2/2^n",
      "ja": "ADV（A）<=（T / T）/ 2 ^ K + P ^ 2/2 ^ n個"
    },
    {
      "indent": 3,
      "text": "In practice, this assumption means that H is very secure as PRF. For example, given that k = n = 160, an attacker with running time 2^60 and making 2^40 oracle queries has advantage at most (about) 2^-80.",
      "ja": "実際には、この仮定は、HがPRFとして非常に安全であることを意味しています。例えば、そのK = N = 160が与えられると、時間2 ^ 60を実行し、2 ^ 40のOracleクエリを作成すると、攻撃者は、最も^ -80 2（約）であるという利点を有します。"
    },
    {
      "indent": 3,
      "text": "Theorem 1\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Suppose m = 10^Digit < 2^31, and let (q,r) = IntDiv(2^31,m). Let B be any adversary attacking HOTP using v verification oracle queries, a <= 2^c - s authenticator oracle queries, and running time t. Let T denote the time to perform one computation of H. If Assumption 1 is true, then",
      "ja": "M = 10 ^桁<2 ^ 31仮定する、及び（Q、R）= INTDIV（2 ^ 31、M）とします。 sのオーセンティケータオラクルクエリ、および時間tを実行している -  Bは、任意の敵V検証神託クエリ、<= 2 ^ Cを使用してHOTPを攻撃しよう。仮定1がtrueの場合、TはHの1つの計算を実行するための時間を示すものとし、"
    },
    {
      "indent": 9,
      "text": "Adv(B) <= sv * (q + 1)/2^31 + (t/T)/2^k + ((sv + a)^2)/2^n",
      "ja": "ADV（B）<= SV *（Q + 1）/ 2 ^ 31 +（T / T）/ 2 ^ K +（（SV + A）^ 2）/ 2 ^ n個"
    },
    {
      "indent": 3,
      "text": "In practice, the (t/T)2^-k + ((sv + a)^2)2^-n term is much smaller than the sv(q + 1)/2^n term, so that the above says that for all practical purposes the success rate of an adversary attacking HOTP is sv(q + 1)/2^n, just as for HOTP-IDEAL, meaning the HOTP algorithm is in practice essentially as good as its idealized counterpart.",
      "ja": "実際には、（T / T）2 ^ -k +（（SV + A）^ 2）^ 2 -N用語がSVよりもはるかに小さい（Q + 1）/ 2 ^ n個の用語、上記と言うようにすべての実用的な目的のためにHOTPを攻撃する敵の成功率はSVがあること（Q + 1）nは、ちょうどHOTP  -  IDEALのためとして、HOTPアルゴリズムを意味することは、その理想的な対応として、本質的に良い習慣である^ / 2。"
    },
    {
      "indent": 3,
      "text": "In the case m = 10^6 of a 6-digit output, this means that an adversary making v authentication attempts will have a success rate that is at most that of Equation 1.",
      "ja": "6桁の出力の場合、M = 10 ^ 6において、このことは、敵対者がV認証試行は、式1の最もものである成功率を持って行うことを意味します。"
    },
    {
      "indent": 3,
      "text": "For example, consider an adversary with running time at most 2^60 that sees at most 2^40 authentication attempts of the user. Both these choices are very generous to the adversary, who will typically not have these resources, but we are saying that even such a powerful adversary will not have more success than indicated by Equation 1.",
      "ja": "たとえば、ユーザーの大半で2 ^ 40回の認証の試みを見ている時には、ほとんどの2 ^ 60を実行している敵を考えてみます。これらの両方の選択肢は通常、これらのリソースを持っていませんが、私たちも、このような強力な敵は、式1で示されているよりも多くの成功を持っていないことを言っている敵に非常に寛大です。"
    },
    {
      "indent": 3,
      "text": "We can safely assume sv <= 2^40 due to the throttling and bounds on s. So:",
      "ja": "私たちは、安全に起因するのでスロットリングとの境界にSV <= 2 ^ 40を想定することができます。そう："
    },
    {
      "indent": 7,
      "text": "(t/T)/2^k + ((sv + a)^2)/2^n  <= 2^60/2^160 + (2^41)^2/2^160\n                             roughly <= 2^-78",
      "raw": true
    },
    {
      "indent": 3,
      "text": "which is much smaller than the success probability of Equation 1 and negligible compared to it.",
      "ja": "それに比べて、式1と無視できるの成功確率よりもはるかに小さいです。"
    },
    {
      "indent": 0,
      "text": "Appendix B - SHA-1 Attacks",
      "ja": "付録B  -  SHA-1攻撃"
    },
    {
      "indent": 3,
      "text": "This sections addresses the impact of the recent attacks on SHA-1 on the security of the HMAC-SHA-1-based HOTP. We begin with some discussion of the situation of SHA-1 and then discuss the relevance to HMAC-SHA-1 and HOTP. Cited references are in Section 13.",
      "ja": "このセクションでは、HMAC-SHA-1ベースのHOTPのセキュリティ上のSHA-1の最近の攻撃の影響に対処しています。私たちは、SHA-1のような状況のいくつかの議論で始まり、その後、HMAC-SHA-1およびHOTPとの関連性を議論します。引用された文献は、セクション13です。"
    },
    {
      "indent": 0,
      "text": "B.1. SHA-1 Status",
      "ja": "B.1。 SHA-1ステータス"
    },
    {
      "indent": 3,
      "text": "A collision for a hash function h means a pair x,y of different inputs such that h(x)=h(y). Since SHA-1 outputs 160 bits, a birthday attack finds a collision in 2^{80} trials. (A trial means one computation of the function.) This was thought to be the best possible until Wang, Yin, and Yu announced on February 15, 2005, that they had an attack finding collisions in 2^{69} trials.",
      "ja": "ハッシュ関数H用の衝突は、ペアX、例えばH（X）= H（y）は、異なる入力のYを意味します。 SHA-1の出力160ビットであるので、誕生日攻撃は2 ^ {80}試験における衝突を見つけます。 （裁判は、関数の1つの計算を意味します。）これは、彼らが2 ^ {69}試験で衝突を見つけるの攻撃があったことを、王は、陰、とゆう2005年2月15日に発表されるまで、可能な限り最良であると考えられていました。"
    },
    {
      "indent": 3,
      "text": "Is SHA-1 broken? For most practical purposes, we would say probably not, since the resources needed to mount the attack are huge. Here is one way to get a sense of it: we can estimate it is about the same as the time we would need to factor a 760-bit RSA modulus, and this is currently considered out of reach.",
      "ja": "SHA-1が壊れていますか？攻撃を仕掛けるために必要な資源が巨大であるため、最も実用的な目的のために、私たちは、おそらくないと言うでしょう。ここでの感覚を得るための一つの方法は次のとおりです。我々はそれが我々が760ビットのRSAモジュラスを考慮する必要があるだろう時間とほぼ同じである推定することができ、これは現在、手の届かないと考えられています。"
    },
    {
      "indent": 3,
      "text": "Burr of NIST is quoted in [Crack] as saying \"Large national intelligence agencies could do this in a reasonable amount of time with a few million dollars in computer time\". However, the computation may be out of reach of all but such well-funded agencies.",
      "ja": "NISTのバリは、「大規模な国家の諜報機関は、コンピュータの時間で数百万ドルで、妥当な時間でこれを行うことができます」と言って[亀裂]で引用されます。しかし、計算は、このような、よく資金を供給機関が、すべての手の届かないかもしれません。"
    },
    {
      "indent": 3,
      "text": "One should also ask what impact finding SHA-1 collisions actually has on security of real applications such as signatures. To exploit a collision x,y to forge signatures, you need to somehow obtain a signature of x and then you can forge a signature of y. How damaging this is depends on the content of y: the y created by the attack may not be meaningful in the application context. Also, one needs a chosen-message attack to get the signature of x. This seems possible in some contexts, but not others. Overall, it is not clear that the impact on the security of signatures is significant.",
      "ja": "一つは、実際に、そのような署名などの実際のアプリケーションのセキュリティを持っているどのような影響SHA-1の衝突を見つけることに依頼する必要があります。署名を偽造する衝突のx、yのを活用するためには、何らかの形でxの署名を取得する必要があり、その後、あなたは、yの署名を偽造することができます。どのようにダメージを与えるこれはしても、yの内容に依存します：攻撃によって作成され、Yは、アプリケーションのコンテキストで意味がないかもしれません。また、1はxの署名を取得するために選択したメッセージの攻撃を必要とします。これは、いくつかの状況ではなく、他に可能と思われます。全体的に、署名の安全性への影響が重大であることは明らかではありません。"
    },
    {
      "indent": 3,
      "text": "Indeed, one can read in the press that SHA-1 is \"broken\" [Sha1] and that encryption and SSL are \"broken\" [Res]. The media have a tendency to magnify events: it would hardly be interesting to announce in the news that a team of cryptanalysts did very interesting theoretical work in attacking SHA-1.",
      "ja": "確かに、人はSHA-1は[SHA1]「壊れた」であり、その暗号化とSSLは[RES]「壊れた」であることをプレスで読むことができます。メディアは、イベントを拡大する傾向を持っている：ほとんど暗号解読のチームは、SHA-1の攻撃に非常に興味深い理論的な仕事をしたというニュースで発表することは興味深いことないだろう。"
    },
    {
      "indent": 3,
      "text": "Cryptographers are excited too. But mainly because this is an important theoretical breakthrough. Attacks can only get better with time: it is therefore important to monitor any progress in hash functions cryptanalysis and be prepared for any really practical break with a sound migration plan for the future.",
      "ja": "暗号技術はあまりにも興奮しています。しかし、主な理由は、これは重要な理論的な画期的な製品です。攻撃は時間だけで良くなることができます：ハッシュ関数解読法における任意の進行状況を監視することが重要であり、将来のための健全な移行計画を持つ任意の本当に実用的な休憩のために準備されます。"
    },
    {
      "indent": 0,
      "text": "B.2. HMAC-SHA-1 Status",
      "ja": "B.2。 HMAC-SHA-1ステータス"
    },
    {
      "indent": 3,
      "text": "The new attacks on SHA-1 have no impact on the security of HMAC-SHA-1. The best attack on the latter remains one needing a sender to authenticate 2^{80} messages before an adversary can create a forgery. Why?",
      "ja": "SHA-1の新しい攻撃はHMAC-SHA-1の安全性に影響を与えません。後者で最高の攻撃は、1つの敵が偽造を作成することができます前に、2 ^ {80}のメッセージを認証するために、送信者を必要と残っています。どうして？"
    },
    {
      "indent": 3,
      "text": "HMAC is not a hash function. It is a message authentication code (MAC) that uses a hash function internally. A MAC depends on a secret key, while hash functions don't. What one needs to worry about with a MAC is forgery, not collisions. HMAC was designed so that collisions in the hash function (here SHA-1) do not yield forgeries for HMAC.",
      "ja": "HMACは、ハッシュ関数ではありません。これは、内部ハッシュ関数を使用するメッセージ認証コード（MAC）です。ハッシュ関数がいない間MACは、秘密鍵に依存します。何1は、MACと心配する必要は偽造ではなく、衝突です。 （ここではSHA-1）ハッシュ関数における衝突がHMACのための偽造が得られないようにHMACを設計しました。"
    },
    {
      "indent": 3,
      "text": "Recall that HMAC-SHA-1(K,x) = SHA-1(K_o,SHA-1(K_i,x)) where the keys K_o,K_i are derived from K. Suppose the attacker finds a pair x,y such that SHA-1(K_i,x) = SHA-1(K_i,y). (Call this a hidden-key collision.) Then if it can obtain the MAC of x (itself a tall order), it can forge the MAC of y. (These values are the same.) But finding hidden-key collisions is harder than finding collisions, because the attacker does not know the hidden key K_i. All it may have is some outputs of HMAC-SHA-1 with key K. To date, there are no claims or evidence that the recent attacks on SHA-1 extend to find hidden-key collisions.",
      "ja": "（X K）キーK_o、K_IがK.由来するSHA-1（K_o、SHA-1（K_I、X））は、攻撃者がペアxを見つけると仮定= HMAC-SHA-1ということを思い出し、そのYようSHA-1（K_I、x）はSHA-1（K_I、y）を=。 （この隠されたキーの衝突を呼び出す。）それは、xのMAC（自体背の高い順）を得ることができれば、それは、yのMACを偽造することができます。 （これらの値は同じです）。しかし、攻撃者が隠されたキーK_Iを知らないので、隠された鍵の衝突を見つけることは、衝突を見つけることよりも硬いです。それは持っていることのすべては、これまでに鍵KとHMAC-SHA-1のいくつかの出力で、SHA-1の最近の攻撃が隠されたキーの衝突を見つけるために拡張するという主張や証拠はありません。"
    },
    {
      "indent": 3,
      "text": "Historically, the HMAC design has already proven itself in this regard. MD5 is considered broken in that collisions in this hash function can be found relatively easily. But there is still no attack on HMAC-MD5 better than the trivial 2^{64} time birthday one. (MD5 outputs 128 bits, not 160.) We are seeing this strength of HMAC coming into play again in the SHA-1 context.",
      "ja": "歴史的に、HMACの設計は、すでにこの点で自分自身を証明しています。 MD5は、比較的容易に見つけることができ、このハッシュ関数でその衝突で壊れたと考えられています。しかし、まだ些細な2 ^ {64}時間の誕生日の1よりも優れてHMAC-MD5には攻撃はありません。我々は、HMACのこの強度は、SHA-1のコンテキストで再度プレーに入る見ている（MD5は、128ビットではなく、160を出力します）。"
    },
    {
      "indent": 0,
      "text": "B.3. HOTP Status",
      "ja": "B.3。 HOTPステータス"
    },
    {
      "indent": 3,
      "text": "Since no new weakness has surfaced in HMAC-SHA-1, there is no impact on HOTP. The best attacks on HOTP remain those described in the document, namely, to try to guess output values.",
      "ja": "新たな弱点はHMAC-SHA-1で浮上していないので、HOTPに影響はありません。 HOTPで最高の攻撃は、出力値を推測しようとする、すなわち、文書に記載されているもの残ります。"
    },
    {
      "indent": 3,
      "text": "The security proof of HOTP requires that HMAC-SHA-1 behave like a pseudorandom function. The quality of HMAC-SHA-1 as a pseudorandom function is not impacted by the new attacks on SHA-1, and so neither is this proven guarantee.",
      "ja": "HOTPのセキュリティ証明はHMAC-SHA-1は、擬似ランダム関数のように振る舞うことが必要です。擬似ランダム関数としてHMAC-SHA-1の品質は、SHA-1の新しい攻撃の影響を受け、そしてそのどちらもが、この実績のある保証はされません。"
    },
    {
      "indent": 0,
      "text": "Appendix C - HOTP Algorithm: Reference Implementation",
      "ja": "付録C  -  HOTPアルゴリズム：リファレンス実装"
    },
    {
      "indent": 3,
      "text": "/*\n * OneTimePasswordAlgorithm.java\n * OATH Initiative,\n * HOTP one-time password algorithm\n *\n */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Copyright (C) 2004, OATH.  All rights reserved.\n *\n * License to copy and use this software is granted provided that it\n * is identified as the \"OATH HOTP Algorithm\" in all material\n * mentioning or referencing this software or this function.\n *\n * License is also granted to make and use derivative works provided\n * that such works are identified as\n *  \"derived from OATH HOTP algorithm\"\n * in all material mentioning or referencing the derived work.\n *\n * OATH (Open AuTHentication) and its members make no\n * representations concerning either the merchantability of this\n * software or the suitability of this software for any particular\n * purpose.\n *\n * It is provided \"as is\" without express or implied warranty\n * of any kind and OATH AND ITS MEMBERS EXPRESSaLY DISCLAIMS\n * ANY WARRANTY OR LIABILITY OF ANY KIND relating to this software.\n *\n * These notices must be retained in any copies of any part of this\n * documentation and/or software.\n */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "package org.openauthentication.otp;",
      "ja": "パッケージorg.openauthentication.otp。"
    },
    {
      "indent": 3,
      "text": "import java.io.IOException;\nimport java.io.File;\nimport java.io.DataInputStream;\nimport java.io.FileInputStream ;\nimport java.lang.reflect.UndeclaredThrowableException;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "import java.security.GeneralSecurityException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidKeyException;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "import javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/**\n * This class contains static methods that are used to calculate the\n * One-Time Password (OTP) using\n * JCE to provide the HMAC-SHA-1.\n *\n * @author Loren Hart\n * @version 1.0\n */\npublic class OneTimePasswordAlgorithm {\n    private OneTimePasswordAlgorithm() {}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "// These are used to calculate the check-sum digits.\n//                                0  1  2  3  4  5  6  7  8  9\nprivate static final int[] doubleDigits =\n                { 0, 2, 4, 6, 8, 1, 3, 5, 7, 9 };",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/**\n * Calculates the checksum using the credit card algorithm.\n * This algorithm has the advantage that it detects any single\n * mistyped digit and any single transposition of\n * adjacent digits.\n *\n * @param num the number to calculate the checksum for\n * @param digits number of significant places in the number\n *\n * @return the checksum of num\n */\npublic static int calcChecksum(long num, int digits) {\n    boolean doubleDigit = true;\n    int     total = 0;\n    while (0 < digits--) {\n        int digit = (int) (num % 10);\n        num /= 10;\n        if (doubleDigit) {\n            digit = doubleDigits[digit];\n        }\n        total += digit;\n        doubleDigit = !doubleDigit;\n    }\n    int result = total % 10;\n    if (result > 0) {\n        result = 10 - result;\n    }\n    return result;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/**\n * This method uses the JCE to provide the HMAC-SHA-1",
      "raw": true
    },
    {
      "indent": 8,
      "text": "* algorithm. * HMAC computes a Hashed Message Authentication Code and * in this case SHA1 is the hash algorithm used. * * @param keyBytes the bytes to use for the HMAC-SHA-1 key * @param text the message or text to be authenticated. * * @throws NoSuchAlgorithmException if no provider makes * either HmacSHA1 or HMAC-SHA-1 * digest algorithms available. * @throws InvalidKeyException * The secret provided was not a valid HMAC-SHA-1 key. * */",
      "ja": "*アルゴリズム。 * HMACは、ハッシュ・メッセージ認証コードを計算し、*この場合、SHA1が使用されるハッシュアルゴリズムです。認証されるHMAC-SHA-1キー* @paramテキストメッセージまたはテキストに使用する* * @param keyBytesバイト。何プロバイダが* HmacSHA1またはHMAC-SHA-1 *のいずれかは、アルゴリズムが利用可能で消化させるない場合*持つNoSuchAlgorithmExceptionを@throws。 * @throws例外：InvalidKeyException *提供秘密は、有効なHMAC-SHA-1キーではありませんでした。 * * /"
    },
    {
      "indent": 3,
      "text": "    public static byte[] hmac_sha1(byte[] keyBytes, byte[] text)\n        throws NoSuchAlgorithmException, InvalidKeyException\n    {\n//        try {\n            Mac hmacSha1;\n            try {\n                hmacSha1 = Mac.getInstance(\"HmacSHA1\");\n            } catch (NoSuchAlgorithmException nsae) {\n                hmacSha1 = Mac.getInstance(\"HMAC-SHA-1\");\n            }\n            SecretKeySpec macKey =\n        new SecretKeySpec(keyBytes, \"RAW\");\n            hmacSha1.init(macKey);\n            return hmacSha1.doFinal(text);\n//        } catch (GeneralSecurityException gse) {\n//            throw new UndeclaredThrowableException(gse);\n//        }\n    }",
      "raw": true
    },
    {
      "indent": 5,
      "text": " private static final int[] DIGITS_POWER // 0 1 2 3 4 5 6 7 8 = {1,10,100,1000,10000,100000,1000000,10000000,100000000};",
      "ja": "プライベート静的最終int型= {1,10,100,1000,10000,100000,1000000,10000000,100000000} // 0 1 2 3 4 5 6 7 8 [] DIGITS_POWER。"
    },
    {
      "indent": 7,
      "text": "/**\n * This method generates an OTP value for the given\n * set of parameters.\n *\n * @param secret       the shared secret\n * @param movingFactor the counter, time, or other value that\n *                     changes on a per use basis.\n * @param codeDigits   the number of digits in the OTP, not\n *                     including the checksum, if any.\n * @param addChecksum  a flag that indicates if a checksum digit",
      "raw": true
    },
    {
      "indent": 5,
      "text": "   *                     should be appended to the OTP.\n   * @param truncationOffset the offset into the MAC result to\n   *                     begin truncation.  If this value is out of\n   *                     the range of 0 ... 15, then dynamic\n   *                     truncation  will be used.\n   *                     Dynamic truncation is when the last 4\n   *                     bits of the last byte of the MAC are\n   *                     used to determine the start offset.\n   * @throws NoSuchAlgorithmException if no provider makes\n   *                     either HmacSHA1 or HMAC-SHA-1\n   *                     digest algorithms available.\n   * @throws InvalidKeyException\n   *                     The secret provided was not\n   *                     a valid HMAC-SHA-1 key.\n   *\n   * @return A numeric String in base 10 that includes\n   * {@link codeDigits} digits plus the optional checksum\n   * digit if requested.\n   */\n  static public String generateOTP(byte[] secret,\n             long movingFactor,\n        int codeDigits,\n             boolean addChecksum,\n        int truncationOffset)\n      throws NoSuchAlgorithmException, InvalidKeyException\n  {\n      // put movingFactor value into text byte array\nString result = null;\nint digits = addChecksum ? (codeDigits + 1) : codeDigits;\n      byte[] text = new byte[8];\n      for (int i = text.length - 1; i >= 0; i--) {\n          text[i] = (byte) (movingFactor & 0xff);\n          movingFactor >>= 8;\n      }",
      "raw": true
    },
    {
      "indent": 11,
      "text": "// compute hmac hash\nbyte[] hash = hmac_sha1(secret, text);",
      "raw": true
    },
    {
      "indent": 5,
      "text": "      // put selected bytes into result int\n      int offset = hash[hash.length - 1] & 0xf;\nif ( (0<=truncationOffset) &&\n       (truncationOffset<(hash.length-4)) ) {\n    offset = truncationOffset;\n}\n      int binary =\n          ((hash[offset] & 0x7f) << 24)\n          | ((hash[offset + 1] & 0xff) << 16)\n          | ((hash[offset + 2] & 0xff) << 8)",
      "raw": true
    },
    {
      "indent": 15,
      "text": "| (hash[offset + 3] & 0xff);",
      "ja": "| （ハッシュ[+ 3のオフセット]＆0xffで）。"
    },
    {
      "indent": 3,
      "text": "        int otp = binary % DIGITS_POWER[codeDigits];\n  if (addChecksum) {\n      otp =  (otp * 10) + calcChecksum(otp, codeDigits);\n  }\n  result = Integer.toString(otp);\n  while (result.length() < digits) {\n      result = \"0\" + result;\n  }\n  return result;\n    }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix D - HOTP Algorithm: Test Values",
      "ja": "付録D  -  HOTPアルゴリズム：テスト値"
    },
    {
      "indent": 3,
      "text": "The following test data uses the ASCII string \"12345678901234567890\" for the secret:",
      "ja": "次のテストデータは、秘密のASCII文字列「12345678901234567890」を使用しています。"
    },
    {
      "indent": 3,
      "text": "Secret = 0x3132333435363738393031323334353637383930",
      "ja": "シークレット= 0x3132333435363738393031323334353637383930"
    },
    {
      "indent": 3,
      "text": "Table 1 details for each count, the intermediate HMAC value.",
      "ja": "各カウントは表1の詳細、中間HMAC値。"
    },
    {
      "indent": 3,
      "text": "Count Hexadecimal HMAC-SHA-1(secret, count) 0 cc93cf18508d94934c64b65d8ba7667fb7cde4b0 1 75a48a19d4cbe100644e8ac1397eea747a2d33ab 2 0bacb7fa082fef30782211938bc1c5e70416ff44 3 66c28227d03a2d5529262ff016a1e6ef76557ece 4 a904c900a64b35909874b33e61c5938a8e15ed1c 5 a37e783d7b7233c083d4f62926c7a25f238d0316 6 bc9cd28561042c83f219324d3c607256c03272ae 7 a4fb960c0bc06e1eabb804e5b397cdc4b45596fa 8 1b3c89f65e6c9e883012052823443f048b4332db 9 1637409809a679dc698207310c8c7fc07290d9e5",
      "ja": "0 cc93cf18508d94934c64b65d8ba7667fb7cde4b0 1 75a48a19d4cbe100644e8ac1397eea747a2d33ab 2 0bacb7fa082fef30782211938bc1c5e70416ff44 3 66c28227d03a2d5529262ff016a1e6ef76557ece 4 a904c900a64b35909874b33e61c5938a8e15ed1c 5 a37e783d7b7233c083d4f62926c7a25f238d0316 6 bc9cd28561042c83f219324d3c607256c03272ae 7 a4fb960c0bc06e1eabb804e5b397cdc4b45596fa 8 1b3c89f65e6c9e883012052823443f048b4332db 9 1637409809a679dc698207310c8c7fc07290d9e5（カウント、シークレット）進HMAC-SHA-1を数えます"
    },
    {
      "indent": 3,
      "text": "Table 2 details for each count the truncated values (both in hexadecimal and decimal) and then the HOTP value.",
      "ja": "それぞれについて、表2の詳細は、次に、切り捨てられた値（両方とも16進数と10進数）とHOTP値を数えます。"
    },
    {
      "indent": 3,
      "text": " Truncated Count Hexadecimal Decimal HOTP 0 4c93cf18 1284755224 755224 1 41397eea 1094287082 287082 2 82fef30 137359152 359152 3 66ef7655 1726969429 969429 4 61c5938a 1640338314 338314 5 33c083d4 868254676 254676 6 7256c032 1918287922 287922 7 4e5b397 82162583 162583 8 2823443f 673399871 399871 9 2679dc69 645520489 520489",
      "ja": "切り捨てられたカウント進小数点HOTP 0 4c93cf18 1284755224 755224 1 41397eea 1094287082 287082 2 82fef30 137359152 359152 3 66ef7655 1726969429 969429 4 61c5938a 1640338314 338314 5 33c083d4 868254676 254676 6 7256c032 1918287922 287922 7 4e5b397 82162583 162583 8 2823443f 673399871 399871 9 2679dc69 645520489 520489"
    },
    {
      "indent": 0,
      "text": "Appendix E - Extensions",
      "ja": "付録E  - 拡張機能"
    },
    {
      "indent": 3,
      "text": "We introduce in this section several enhancements to the HOTP algorithm. These are not recommended extensions or part of the standard algorithm, but merely variations that could be used for customized implementations.",
      "ja": "私たちは、HOTPアルゴリズムにこのセクションでは、いくつかの拡張機能を紹介します。これらは、カスタマイズされた実装を使用することができるお勧めの拡張または標準アルゴリズムの一部が、単なるバリエーションはありません。"
    },
    {
      "indent": 0,
      "text": "E.1. Number of Digits",
      "ja": "E.1。桁数"
    },
    {
      "indent": 3,
      "text": "A simple enhancement in terms of security would be to extract more digits from the HMAC-SHA-1 value.",
      "ja": "セキュリティの観点から簡単増強はHMAC-SHA-1値からより多くの数字を抽出することであろう。"
    },
    {
      "indent": 3,
      "text": "For instance, calculating the HOTP value modulo 10^8 to build an 8- digit HOTP value would reduce the probability of success of the adversary from sv/10^6 to sv/10^8.",
      "ja": "例えば、HOTP値を計算すること/ 10 ^ 8 SVに/ 10 ^ 6をSVからの敵の成功の確率を減らすことが8桁のHOTP値を構築するために10 ^ 8を法。"
    },
    {
      "indent": 3,
      "text": "This could give the opportunity to improve usability, e.g., by increasing T and/or s, while still achieving a better security overall. For instance, s = 10 and 10v/10^8 = v/10^7 < v/10^6 which is the theoretical optimum for 6-digit code when s = 1.",
      "ja": "これはまだ全体的により高いセキュリティを実現しながら、Tおよび/またはSを増やすことで、例えば、ユーザビリティを改善する機会を与えることができます。例えば、S 10及びS = 1〜6桁のコードの理論的最適である10V / 10 ^ 8 = V / 10 ^ 7 <V / 10 ^ 6 =。"
    },
    {
      "indent": 0,
      "text": "E.2. Alphanumeric Values",
      "ja": "E.2。英数字の値"
    },
    {
      "indent": 3,
      "text": "Another option is to use A-Z and 0-9 values; or rather a subset of 32 symbols taken from the alphanumerical alphabet in order to avoid any confusion between characters: 0, O, and Q as well as l, 1, and I are very similar, and can look the same on a small display.",
      "ja": "別のオプションは-Zおよび0-9の値を使用することです。むしろ文字間の混乱を避けるために、英数アルファベットから取られた32個のシンボルのサブセット：0、O、およびQ、ならびにL、1、及びIは非常に類似しており、小さなディスプレイ上で同じように見えることができます。"
    },
    {
      "indent": 3,
      "text": "The immediate consequence is that the security is now in the order of sv/32^6 for a 6-digit HOTP value and sv/32^8 for an 8-digit HOTP value.",
      "ja": "即時の結果は、セキュリティが8桁のHOTP値の6桁のHOTP値およびSV / 32 ^ 8のためのSV / ^ 6〜32の順になっていることです。"
    },
    {
      "indent": 3,
      "text": "32^6 > 10^9 so the security of a 6-alphanumeric HOTP code is slightly better than a 9-digit HOTP value, which is the maximum length of an HOTP code supported by the proposed algorithm.",
      "ja": "32 ^ 6> ^ 9 10それほど6英数字HOTPコードのセキュリティは、提案したアルゴリズムでサポートされているHOTPコードの最大長さである9桁のHOTP値よりもわずかに良好です。"
    },
    {
      "indent": 3,
      "text": "32^8 > 10^12 so the security of an 8-alphanumeric HOTP code is significantly better than a 9-digit HOTP value.",
      "ja": "^ 12 32 ^ 8> 10そう8英数字HOTPコードのセキュリティは9桁のHOTP値よりも有意に良好です。"
    },
    {
      "indent": 3,
      "text": "Depending on the application and token/interface used for displaying and entering the HOTP value, the choice of alphanumeric values could be a simple and efficient way to improve security at a reduced cost and impact on users.",
      "ja": "HOTP値を表示し、入力するために使用されるアプリケーションとトークン/インターフェイスによっては、英数字の値の選択は、ユーザーのコスト削減とインパクト時のセキュリティを向上させるための簡単かつ効率的な方法かもしれません。"
    },
    {
      "indent": 0,
      "text": "E.3. Sequence of HOTP Values",
      "ja": "E.3。 HOTP値のシーケンス"
    },
    {
      "indent": 3,
      "text": "As we suggested for the resynchronization to enter a short sequence (say, 2 or 3) of HOTP values, we could generalize the concept to the protocol, and add a parameter L that would define the length of the HOTP sequence to enter.",
      "ja": "我々はHOTP値の短い配列を（例えば、2または3）を入力して再同期のために示唆したように、私たちはプロトコルに概念を一般化し、入力するためにHOTP配列の長さを定義するパラメータLを追加することができます。"
    },
    {
      "indent": 3,
      "text": "Per default, the value L SHOULD be set to 1, but if security needs to be increased, users might be asked (possibly for a short period of time, or a specific operation) to enter L HOTP values.",
      "ja": "LのHOTP値を入力するようにデフォルトでは、値Lを1に設定する必要がありますが、セキュリティが向上する必要がある場合、ユーザーが求められる場合があります（時間の短い期間のために、おそらく、または特定の操作）。"
    },
    {
      "indent": 3,
      "text": "This is another way, without increasing the HOTP length or using alphanumeric values to tighten security.",
      "ja": "これは、HOTPの長さを増加させるか、セキュリティを強化するために英数字の値を使用せずに、別の方法です。"
    },
    {
      "indent": 3,
      "text": "Note: The system MAY also be programmed to request synchronization on a regular basis (e.g., every night, twice a week, etc.) and to achieve this purpose, ask for a sequence of L HOTP values.",
      "ja": "注：システムはまた、定期的に同期を要求するようにプログラムすることができる（例えば、毎晩、週二回、など）と、この目的を達成するために、LのHOTP値のシーケンスを求めます。"
    },
    {
      "indent": 0,
      "text": "E.4. A Counter-Based Resynchronization Method",
      "ja": "E.4。カウンタベースの再同期方法"
    },
    {
      "indent": 3,
      "text": "In this case, we assume that the client can access and send not only the HOTP value but also other information, more specifically, the counter value.",
      "ja": "この場合、私たちは、クライアントがアクセスし、HOTP値だけでなく、他の情報、具体的には、カウンタ値だけでなく送信できることを前提としています。"
    },
    {
      "indent": 3,
      "text": "A more efficient and secure method for resynchronization is possible in this case. The client application will not send the HOTP-client value only, but the HOTP-client and the related C-client counter value, the HOTP value acting as a message authentication code of the counter.",
      "ja": "再同期のためのより効率的かつ安全な方法は、この場合に可能です。クライアントアプリケーションは、唯一のHOTPクライアント値が、HOTPクライアントおよび関連C-クライアントカウンタ値、カウンタのメッセージ認証コードとして機能するHOTP値を送信しません。"
    },
    {
      "indent": 3,
      "text": "Resynchronization Counter-based Protocol (RCP)\n----------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The server accepts if the following are all true, where C-server is its own current counter value:",
      "ja": "C-サーバは、自身の現在のカウンタ値であり、次は、すべて該当する場合、サーバは受け付けます。"
    },
    {
      "indent": 3,
      "text": "1) C-client >= C-server 2) C-client - C-server <= s 3) Check that HOTP client is valid HOTP(K,C-Client) 4) If true, the server sets C to C-client + 1 and client is authenticated",
      "ja": "1）C-クライアント> = C-サーバ2）C-クライアント -  C-サーバ<= S 3）HOTPクライアントが有効なHOTP（K、C-クライアントであることを確認してください）trueの場合4）、サーバCはC-するセットクライアント+ 1とクライアントが認証されます"
    },
    {
      "indent": 3,
      "text": "In this case, there is no need for managing a look-ahead window anymore. The probability of success of the adversary is only v/10^6 or roughly v in one million. A side benefit is obviously to be able to increase s \"infinitely\" and therefore improve the system usability without impacting the security.",
      "ja": "この場合、もう先読みウィンドウを管理する必要はありません。敵の成功の確率は百万で唯一のV / 10 ^ 6または略Vです。副次的な利点は、「無限」のを高めるため、セキュリティに影響を与えることなく、システムのユーザビリティを向上させることができるように明らかです。"
    },
    {
      "indent": 3,
      "text": "This resynchronization protocol SHOULD be used whenever the related impact on the client and server applications is deemed acceptable.",
      "ja": "クライアントとサーバーアプリケーションに関連する影響が許容されるとみなされるたびに、この再同期プロトコルを使用すべきです。"
    },
    {
      "indent": 0,
      "text": "E.5. Data Field",
      "ja": "E.5。データフィールド"
    },
    {
      "indent": 3,
      "text": "Another interesting option is the introduction of a Data field, which would be used for generating the One-Time Password values: HOTP (K, C, [Data]) where Data is an optional field that can be the concatenation of various pieces of identity-related information, e.g., Data = Address | PIN.",
      "ja": "HOTP（K、C、[データ]）データはオプションのフィールドであるアイデンティティのさまざまな部分を連結することができる別の興味深いオプションは、ワンタイムパスワード値を生成するために使用されるデータフィールドの導入、です関連の情報、例えば、データ=住所|ピン。"
    },
    {
      "indent": 3,
      "text": "We could also use a Timer, either as the only moving factor or in combination with the Counter -- in this case, e.g., Data = Timer, where Timer could be the UNIX-time (GMT seconds since 1/1/1970) divided by some factor (8, 16, 32, etc.) in order to give a specific time step. The time window for the One-Time Password is then equal to the time step multiplied by the resynchronization parameter as defined before. For example, if we take 64 seconds as the time step and 7 for the resynchronization parameter, we obtain an acceptance window of +/- 3 minutes.",
      "ja": "我々はまた、唯一の移動の要因として、あるいはカウンターと組み合わせて、タイマーを使用することができます - この場合には、例えば、タイマーは、UNIXタイム可能性があり、データ=タイマー、（GMT秒1970年1月1日以降）に分割します特定の時間ステップを与えるために、いくつかの要因（8、16、32、等）によって。ワンタイムパスワードのための時間ウィンドウは、前に定義されている再同期パラメータを乗じた時間ステップに等しいです。我々は再同期パラメータの時間ステップと7と64秒かかる場合たとえば、私たちは+/- 3分の受け入れウィンドウを得ます。"
    },
    {
      "indent": 3,
      "text": "Using a Data field opens for more flexibility in the algorithm implementation, provided that the Data field is clearly specified.",
      "ja": "データフィールドを使用すると、アルゴリズムの実装の柔軟性のために開いて、データフィールドが明確に指定されていることを条件とします。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "David M'Raihi (primary contact for sending comments and questions) VeriSign, Inc. 685 E. Middlefield Road Mountain View, CA 94043 USA",
      "ja": "デビッドM'Raihiベリサイン社685 E.ミドルロード、マウンテンビュー、CA 94043 USA（コメントや質問を送信するための主要な連絡先）"
    },
    {
      "indent": 3,
      "text": "Phone: 1-650-426-3832 EMail: dmraihi@verisign.com",
      "ja": "電話：1-650-426-3832 Eメール：dmraihi@verisign.com"
    },
    {
      "indent": 3,
      "text": "Mihir Bellare Dept of Computer Science and Engineering, Mail Code 0114 University of California at San Diego 9500 Gilman Drive La Jolla, CA 92093, USA",
      "ja": "コンピュータ理工学のミアール・ベレア部門、サンディエゴのカリフォルニアのメールコード0114大学9500ギルマンドライブラ・ホーヤ、CA 92093、USA"
    },
    {
      "indent": 3,
      "text": "EMail: mihir@cs.ucsd.edu",
      "ja": "メールアドレス：mihir@cs.ucsd.edu"
    },
    {
      "indent": 3,
      "text": "Frank Hoornaert VASCO Data Security, Inc. Koningin Astridlaan 164 1780 Wemmel, Belgium",
      "ja": "フランクHoornaert VASCO Data Security社女王Astridlaan 164 1780 Wemmelの、ベルギー"
    },
    {
      "indent": 3,
      "text": "EMail: frh@vasco.com",
      "ja": "メールアドレス：frh@vasco.com"
    },
    {
      "indent": 3,
      "text": "David Naccache Gemplus Innovation 34 rue Guynemer, 92447, Issy les Moulineaux, France and Information Security Group, Royal Holloway, University of London, Egham, Surrey TW20 0EX, UK",
      "ja": "デイビット・ナキャッシュジェムプラスイノベーション34 RUE Guynemer、92447、イシレムリノー、フランスと情報セキュリティグループ、ロイヤル・ホロウェイ、ロンドン大学、エガム、サリーTW20 0EX、英国"
    },
    {
      "indent": 3,
      "text": "EMail: david.naccache@gemplus.com, david.naccache@rhul.ac.uk",
      "ja": "電子メール：david.naccache@gemplus.com、david.naccache@rhul.ac.uk"
    },
    {
      "indent": 3,
      "text": "Ohad Ranen Aladdin Knowledge Systems Ltd. 15 Beit Oved Street Tel Aviv, Israel 61110",
      "ja": "オハッドRanenアラジンナレッジシステムズ株式会社15ベイトOvedストリートテルアビブ、イスラエル61110"
    },
    {
      "indent": 3,
      "text": "EMail: Ohad.Ranen@ealaddin.com",
      "ja": "メールアドレス：Ohad.Ranen@ealaddin.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}