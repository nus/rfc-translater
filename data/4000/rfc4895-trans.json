{
  "title": {
    "text": "RFC 4895 - Authenticated Chunks for the Stream Control Transmission Protocol (SCTP)",
    "ja": "RFC 4895 - ストリーム制御伝送プロトコルのための認証済みチャンク（SCTP）"
  },
  "number": 4895,
  "created_at": "2019-10-28 06:38:09.635426+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          M. Tuexen\nRequest for Comments: 4895            Muenster Univ. of Applied Sciences\nCategory: Standards Track                                     R. Stewart\n                                                                  P. Lei\n                                                     Cisco Systems, Inc.\n                                                             E. Rescorla\n                                                              RTFM, Inc.\n                                                             August 2007",
      "raw": true
    },
    {
      "indent": 12,
      "text": "           Authenticated Chunks for\nthe Stream Control Transmission Protocol (SCTP)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a new chunk type, several parameters, and procedures for the Stream Control Transmission Protocol (SCTP). This new chunk type can be used to authenticate SCTP chunks by using shared keys between the sender and receiver. The new parameters are used to establish the shared keys.",
      "ja": "この文書は、新しいチャンクタイプ、いくつかのパラメータ、およびストリーム制御伝送プロトコル（SCTP）のための手順を説明します。この新しいチャンクタイプは、送信者と受信者の間で共有キーを使用してSCTPチャンクを認証するために使用することができます。新しいパラメータは、共有キーを確立するために使用されています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n2.  Conventions  . . . . . . . . . . . . . . . . . . . . . . . . .  3\n3.  New Parameter Types  . . . . . . . . . . . . . . . . . . . . .  4\n  3.1.  Random Parameter (RANDOM)  . . . . . . . . . . . . . . . .  4\n  3.2.  Chunk List Parameter (CHUNKS)  . . . . . . . . . . . . . .  5\n  3.3.  Requested HMAC Algorithm Parameter (HMAC-ALGO) . . . . . .  6\n4.  New Error Cause  . . . . . . . . . . . . . . . . . . . . . . .  7\n  4.1.  Unsupported HMAC Identifier Error Cause  . . . . . . . . .  7\n5.  New Chunk Type . . . . . . . . . . . . . . . . . . . . . . . .  8\n  5.1.  Authentication Chunk (AUTH)  . . . . . . . . . . . . . . .  8\n6.  Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n  6.1.  Establishment of an Association Shared Key . . . . . . . . 10\n  6.2.  Sending Authenticated Chunks . . . . . . . . . . . . . . . 11\n  6.3.  Receiving Authenticated Chunks . . . . . . . . . . . . . . 12\n7.  Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 15\n  8.1.  A New Chunk Type . . . . . . . . . . . . . . . . . . . . . 15\n  8.2.  Three New Parameter Types  . . . . . . . . . . . . . . . . 15\n  8.3.  A New Error Cause  . . . . . . . . . . . . . . . . . . . . 15\n  8.4.  A New Table for HMAC Identifiers . . . . . . . . . . . . . 16\n9.  Security Considerations  . . . . . . . . . . . . . . . . . . . 16\n10. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 17\n11. Normative References . . . . . . . . . . . . . . . . . . . . . 17",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "SCTP uses 32-bit verification tags to protect itself against blind attackers. These values are not changed during the lifetime of an SCTP association.",
      "ja": "SCTPは、盲目の攻撃に対して自分自身を守るために32ビットの検証タグを使用しています。これらの値は、SCTPアソシエーションのライフタイム中に変更されていません。"
    },
    {
      "indent": 3,
      "text": "Looking at new SCTP extensions, there is the need to have a method of proving that an SCTP chunk(s) was really sent by the original peer that started the association and not by a malicious attacker.",
      "ja": "新しいSCTP拡張を見ると、SCTPのチャンク（複数可）本当に悪意のある攻撃者ではない関連付けを開始し、元のピアによって送信されたことを証明する方法を持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "Using Transport Layer Security (TLS), as defined in RFC 3436 [6], does not help because it only secures SCTP user data.",
      "ja": "RFC 3436で定義され、それが唯一のSCTPユーザデータを確保しているため、トランスポート層セキュリティ（TLS）を使用して、[6]、助けにはなりません。"
    },
    {
      "indent": 3,
      "text": "Therefore, an SCTP extension that provides a mechanism for deriving shared keys for each association is presented. These association shared keys are derived from endpoint pair shared keys, which are configured and might be empty, and data that is exchanged during the SCTP association setup.",
      "ja": "したがって、各アソシエーションのための共有鍵を導出するためのメカニズムを提供するSCTP拡張が提示されます。これらの関連付け共有鍵は、SCTPアソシエーションのセットアップ中に交換されたエンドポイント・ペア共有設定され、空であるかもしれないキー、及びデータから導出されます。"
    },
    {
      "indent": 3,
      "text": "The extension presented in this document allows an SCTP sender to authenticate chunks using shared keys between the sender and receiver. The receiver can then verify that the chunks are sent from the sender and not from a malicious attacker (as long as the attacker does not know an association shared key).",
      "ja": "この文書の拡張は、SCTP送信者が送信者と受信者間の共有キーを使用してチャンクを認証することを可能にします。受信機は、次にチャンクを（あれば、攻撃者がアソシエーション共有鍵を知らないような）悪意のある攻撃者から送信者から送信されていないことを検証することができます。"
    },
    {
      "indent": 3,
      "text": "The extension described in this document places the result of a Hashed Message Authentication Code (HMAC) computation before the data covered by that computation. Placing it at the end of the packet would have required placing a control chunk after DATA chunks in case of authenticating DATA chunks. This would break the rule that control chunks occur before DATA chunks in SCTP packets. It should also be noted that putting the result of the HMAC computation after the data being covered would not allow sending the packet during the computation of the HMAC because the result of the HMAC computation is needed to compute the CRC32C checksum of the SCTP packet, which is placed in the common header of the SCTP packet.",
      "ja": "この文書に記載され拡張された演算対象データの前にハッシュメッセージ認証コード（HMAC）の演算結果を配置します。パケットの終わりにそれを置くことはDATAチャンクを認証する場合のDATAチャンクの後に制御チャンクを置く必要としました。これはチャンクがSCTPパケット内のデータの塊の前に発生する制御ルールを破るだろう。また、留意すべきデータは、HMAC計算の結果は、SCTPパケットのCRC32Cチェックサムを計算するために必要とされているので、HMACの計算中にパケットを送信することができませんでし覆われた後、HMAC計算の結果を入れていますSCTPパケットの共通ヘッダに配置されます。"
    },
    {
      "indent": 3,
      "text": "The SCTP extension for Dynamic Address Reconfiguration (ADD-IP) requires the usage of the extension described in this document. The SCTP Partial Reliability Extension (PR-SCTP) can be used in conjunction with the extension described in this document.",
      "ja": "動的アドレスの再構成（ADD-IP）のためのSCTPの拡張子は、この文書で説明する拡張機能の使用を必要とします。 SCTP部分信頼性拡張（PR-SCTP）は、この文書で説明拡張と併せて使用することができます。"
    },
    {
      "indent": 0,
      "text": "2. Conventions",
      "section_title": true,
      "ja": "2.表記"
    },
    {
      "indent": 3,
      "text": "The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\", when they appear in this document, are to be interpreted as described in RFC 2119 [3].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"NOT SHALL\"、 \"推奨\"、 \"すべきではない\" \"べきである\" \"ないものと\"、 \"MAY\"、 \"推奨NOT\"、および \"OPTIONAL\"彼らは、この文書に現れる場合、RFC 2119に記載されるように解釈されるべきである[3]。"
    },
    {
      "indent": 0,
      "text": "3. New Parameter Types",
      "section_title": true,
      "ja": "3.新規パラメータの種類"
    },
    {
      "indent": 3,
      "text": "This section defines the new parameter types that will be used to negotiate the authentication during association setup. Table 1 illustrates the new parameter types.",
      "ja": "このセクションでは、協会のセットアップ時に認証を交渉するために使用される新しいパラメータの型を定義します。表1は、新たなパラメータの型を示しています。"
    },
    {
      "indent": 4,
      "text": "+----------------+------------------------------------------------+\n| Parameter Type | Parameter Name                                 |\n+----------------+------------------------------------------------+\n| 0x8002         | Random Parameter (RANDOM)                      |\n| 0x8003         | Chunk List Parameter (CHUNKS)                  |\n| 0x8004         | Requested HMAC Algorithm Parameter (HMAC-ALGO) |\n+----------------+------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 3,
      "text": "Note that the parameter format requires the receiver to ignore the parameter and continue processing if the parameter is not understood. This is accomplished (as described in RFC 2960 [5], Section 3.2.1.) by the use of the upper bits of the parameter type.",
      "ja": "パラメータ形式パラメータを無視し、パラメータが理解されていない場合は処理を継続するために受信機を必要とすることに留意されたいです。パラメータタイプの上位ビットを利用して（RFC 2960 [5]、セクション3.2.1。に記載されているように）これが達成されます。"
    },
    {
      "indent": 0,
      "text": "3.1. Random Parameter (RANDOM)",
      "section_title": true,
      "ja": "3.1. ランダムパラメータ（RANDOM）"
    },
    {
      "indent": 3,
      "text": "This parameter is used to carry a random number of an arbitrary length.",
      "ja": "このパラメータは、任意の長さの乱数を搬送するために使用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Parameter Type = 0x8002   |       Parameter Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n\\                          Random Number                        /\n/                               +-------------------------------\\\n|                               |           Padding             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "Parameter Type: 2 bytes (unsigned integer) This value MUST be set to 0x8002.",
      "ja": "パラメータタイプ：2バイト（符号なし整数）この値は0x8002に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Parameter Length: 2 bytes (unsigned integer) This value is the length of the Random Number in bytes plus 4.",
      "ja": "パラメータ長：2バイト（符号なし整数）この値は、バイト+ 4乱数の長さです。"
    },
    {
      "indent": 3,
      "text": "Random Number: n bytes (unsigned integer) This value represents an arbitrary Random Number in network byte order.",
      "ja": "乱数：nバイト（符号なし整数）この値は、ネットワークバイト順で任意の乱数を表します。"
    },
    {
      "indent": 3,
      "text": "Padding: 0, 1, 2, or 3 bytes (unsigned integer) If the length of the Random Number is not a multiple of 4 bytes, the sender MUST pad the parameter with all zero bytes to make the parameter 32-bit aligned. The Padding MUST NOT be longer than 3 bytes and it MUST be ignored by the receiver.",
      "ja": "パディング：0、1、2、または3バイト（符号なし整数）乱数の長さが4バイトの倍数、全てゼロバイトのパラメータはパラメータ32ビット整列させるために、送信者MUSTパッドない場合。パディングは3バイトより長くてはならず、それが受信機で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The RANDOM parameter MUST be included once in the INIT or INIT-ACK chunk, if the sender wants to send or receive authenticated chunks, to provide a 32-byte Random Number. For 32-byte Random Numbers, the Padding is empty.",
      "ja": "送信者が32バイトの乱数を提供するために、認証されたチャンクを送信または受信したい場合RANDOMパラメータは、一度INITまたはINIT-ACKチャンクに含まれなければなりません。 32バイトの乱数の場合、パディングは空です。"
    },
    {
      "indent": 0,
      "text": "3.2. Chunk List Parameter (CHUNKS)",
      "section_title": true,
      "ja": "3.2. チャンクリストパラメータ（CHUNKS）"
    },
    {
      "indent": 3,
      "text": "This parameter is used to specify which chunk types are required to be authenticated before being sent by the peer.",
      "ja": "このパラメータは、チャンクタイプは、ピアによって送信される前に認証される必要があるかを指定するために使用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Parameter Type = 0x8003   |       Parameter Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Chunk Type 1  | Chunk Type 2  | Chunk Type 3  | Chunk Type 4  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n\\                              ...                              \\\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Chunk Type n  |                   Padding                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 3,
      "text": "Parameter Type: 2 bytes (unsigned integer) This value MUST be set to 0x8003.",
      "ja": "パラメータタイプ：2バイト（符号なし整数）この値は0x8003に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Parameter Length: 2 bytes (unsigned integer) This value is the number of listed Chunk Types plus 4.",
      "ja": "パラメータ長：2バイト（符号なし整数）この値は、列挙された塊タイププラス4の数です。"
    },
    {
      "indent": 3,
      "text": "Chunk Type n: 1 byte (unsigned integer) Each Chunk Type listed is required to be authenticated when sent by the peer.",
      "ja": "チャンクタイプN：1バイト（符号なし整数）列挙された各チャンクタイプは、ピアによって送信されたときに認証される必要があります。"
    },
    {
      "indent": 3,
      "text": "Padding: 0, 1, 2, or 3 bytes (unsigned integer) If the number of Chunk Types is not a multiple of 4, the sender MUST pad the parameter with all zero bytes to make the parameter 32-bit aligned. The Padding MUST NOT be longer than 3 bytes and it MUST be ignored by the receiver.",
      "ja": "パディング：0、1、2、または3バイト（符号なし整数）塊タイプの数は4の倍数、送信側MUSTパッドパラメーター32ビット整列させるためにすべてのゼロバイトのパラメータではない場合。パディングは3バイトより長くてはならず、それが受信機で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The CHUNKS parameter MUST be included once in the INIT or INIT-ACK chunk if the sender wants to receive authenticated chunks. Its maximum length is 260 bytes.",
      "ja": "送信者が認証されたチャンクを受信したい場合はチャンクパラメータは一度INITまたはINIT-ACKチャンクに含まれなければなりません。その最大長は260バイトです。"
    },
    {
      "indent": 3,
      "text": "The chunk types for INIT, INIT-ACK, SHUTDOWN-COMPLETE, and AUTH chunks MUST NOT be listed in the CHUNKS parameter. However, if a CHUNKS parameter is received then the types for INIT, INIT-ACK, SHUTDOWN-COMPLETE, and AUTH chunks MUST be ignored.",
      "ja": "INIT、INIT-ACK、SHUTDOWN-COMPLETE、およびAUTHチャンクのためのチャンクタイプは、チャンクパラメータにリストされてはなりません。チャンクパラメータはその後、INITのためのタイプを受信した場合には、INIT-ACK、SHUTDOWN-COMPLETE、およびAUTHチャンクを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3. Requested HMAC Algorithm Parameter (HMAC-ALGO)",
      "section_title": true,
      "ja": "3.3. 要求されたHMACアルゴリズムパラメータ（HMAC-ALGO）"
    },
    {
      "indent": 3,
      "text": "This parameter is used to list the HMAC Identifiers the peer MUST use.",
      "ja": "このパラメータは、ピアが使用しなければならないHMAC識別子のリストを表示するために使用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Parameter Type = 0x8004   |       Parameter Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          HMAC Identifier 1    |      HMAC Identifier 2        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n\\                              ...                              \\\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        HMAC Identifier n      |           Padding             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 3,
      "text": "Parameter Type: 2 bytes (unsigned integer) This value MUST be set to 0x8004.",
      "ja": "パラメータタイプ：2バイト（符号なし整数）この値は0x8004に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Parameter Length: 2 bytes (unsigned integer) This value is the number of HMAC Identifiers multiplied by 2, plus 4.",
      "ja": "パラメータ長：2バイト（符号なし整数）この値は2、プラス4を乗じたHMAC識別子の数です。"
    },
    {
      "indent": 3,
      "text": "HMAC Identifier n: 2 bytes (unsigned integer) The values expressed are a list of HMAC Identifiers that may be used by the peer. The values are listed by preference, with respect to the sender, where the first HMAC Identifier listed is the one most preferable to the sender.",
      "ja": "N HMAC識別子：2バイト（符号なし整数）発現値がピアによって使用されてもよいHMAC識別子のリストです。値は、列挙された最初のHMAC識別子は、送信者に最も好ましいものである送信者に対して、嗜好によって記載されています。"
    },
    {
      "indent": 3,
      "text": "Padding: 0 or 2 bytes (unsigned integer) If the number of HMAC Identifiers is not even, the sender MUST pad the parameter with all zero bytes to make the parameter 32-bit aligned. The Padding MUST be 0 or 2 bytes long and it MUST be ignored by the receiver.",
      "ja": "パディング：0または2バイト（符号なし整数）HMAC識別子の数が偶数でない場合は、すべてのゼロバイトのパラメータはパラメータ32ビット整列させるために、送信者MUSTパッド。パディングは0又は2バイト長でなければならず、受信機によって無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The HMAC-ALGO parameter MUST be included once in the INIT or INIT-ACK chunk if the sender wants to send or receive authenticated chunks.",
      "ja": "送信者が認証されたチャンクを送信または受信したい場合HMAC-ALGOパラメータは一度INITまたはINIT-ACKチャンクに含まれなければなりません。"
    },
    {
      "indent": 3,
      "text": "Table 2 shows the currently defined values for HMAC Identifiers.",
      "ja": "表2は、HMAC識別子に現在定義されている値を示しています。"
    },
    {
      "indent": 14,
      "text": "+-----------------+--------------------------+\n| HMAC Identifier | Message Digest Algorithm |\n+-----------------+--------------------------+\n| 0               | Reserved                 |\n| 1               | SHA-1 defined in [8]     |\n| 2               | Reserved                 |\n| 3               | SHA-256 defined in [8]   |\n+-----------------+--------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 2",
      "ja": "表2"
    },
    {
      "indent": 3,
      "text": "Every endpoint supporting SCTP chunk authentication MUST support the HMAC based on the SHA-1 algorithm.",
      "ja": "SCTPチャンクの認証をサポートしているすべてのエンドポイントは、SHA-1アルゴリズムに基づいてHMACをサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "4. New Error Cause",
      "section_title": true,
      "ja": "4.新しいエラー原因"
    },
    {
      "indent": 3,
      "text": "This section defines a new error cause that will be sent if an AUTH chunk is received with an unsupported HMAC Identifier. Table 3 illustrates the new error cause.",
      "ja": "このセクションでは、AUTHチャンクがサポートされていないHMAC識別子を受信した場合に送信されます新しいエラー原因を定義します。表3は、新たなエラーの原因を示しています。"
    },
    {
      "indent": 15,
      "text": "+------------+-----------------------------+\n| Cause Code | Error Cause Name            |\n+------------+-----------------------------+\n| 0x0105     | Unsupported HMAC Identifier |\n+------------+-----------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 3",
      "ja": "表3"
    },
    {
      "indent": 0,
      "text": "4.1. Unsupported HMAC Identifier Error Cause",
      "section_title": true,
      "ja": "4.1. サポートされていないHMAC識別子エラー原因"
    },
    {
      "indent": 3,
      "text": "This error cause is used to indicate that an AUTH chunk has been received with an unsupported HMAC Identifier.",
      "ja": "このエラーの原因は、AUTHチャンクがサポートされていないHMAC識別子で受信されたことを示すために使用されています。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Cause Code = 0x0105      |       Cause Length = 6        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         HMAC Identifier       |            Padding            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 3,
      "text": "Cause Code: 2 bytes (unsigned integer) This value MUST be set to 0x0105.",
      "ja": "原因コード：2バイト（符号なし整数）この値は0x0105に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Cause Length: 2 bytes (unsigned integer) This value MUST be set to 6.",
      "ja": "原因長さ：2バイト（符号なし整数）この値は6に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "HMAC Identifier: 2 bytes (unsigned integer) This value is the HMAC Identifier which is not supported.",
      "ja": "HMAC識別子：2バイト（符号なし整数）この値は、サポートされていないHMAC識別子です。"
    },
    {
      "indent": 3,
      "text": "Padding: 2 bytes (unsigned integer) The sender MUST pad the error cause with all zero bytes to make the cause 32-bit aligned. The Padding MUST be 2 bytes long and it MUST be ignored by the receiver.",
      "ja": "パディング：2バイト（符号なし整数）全てゼロバイトのエラー要因が原因32ビット整列させるために、送信者MUSTパッド。パディングは2バイト長でなければならず、受信機で無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. New Chunk Type",
      "section_title": true,
      "ja": "5.新しいチャンクタイプ"
    },
    {
      "indent": 3,
      "text": "This section defines the new chunk type that will be used to authenticate chunks. Table 4 illustrates the new chunk type.",
      "ja": "このセクションでは、チャンクを認証するために使用される新しいチャンクタイプを定義します。表4は、新しいチャンクタイプを示しています。"
    },
    {
      "indent": 15,
      "text": "+------------+-----------------------------+\n| Chunk Type | Chunk Name                  |\n+------------+-----------------------------+\n| 0x0F       | Authentication Chunk (AUTH) |\n+------------+-----------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 4",
      "ja": "表4"
    },
    {
      "indent": 3,
      "text": "It should be noted that the AUTH-chunk format requires the receiver to ignore the chunk if it is not understood and silently discard all chunks that follow. This is accomplished (as described in RFC 2960 [5], Section 3.2.) by the use of the upper bits of the chunk type.",
      "ja": "AUTH-チャンク形式は、それが理解されていない場合は、チャンクを無視して、静かに続くすべてのチャンクを破棄するために受信機を必要とすることに留意すべきです。チャンクタイプの上位ビットを利用して（RFC 2960 [5]、セクション3.2。に記載されているように）これが達成されます。"
    },
    {
      "indent": 0,
      "text": "5.1. Authentication Chunk (AUTH)",
      "section_title": true,
      "ja": "5.1. 認証チャンク（AUTH）"
    },
    {
      "indent": 3,
      "text": "This chunk is used to hold the result of the HMAC calculation.",
      "ja": "このチャンクは、HMAC計算の結果を保持するために使用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Type = 0x0F   |   Flags=0     |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Shared Key Identifier      |        HMAC Identifier        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n\\                             HMAC                              /\n/                                                               \\\n/                               +-------------------------------\\\n|                               |           Padding             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 5",
      "ja": "図5"
    },
    {
      "indent": 3,
      "text": "Type: 1 byte (unsigned integer) This value MUST be set to 0x0F for all AUTH-chunks.",
      "ja": "タイプ：1バイト（符号なし整数）この値は、すべてのAUTHチャンクため0x0Fのに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Flags: 1 byte (unsigned integer) SHOULD be set to zero on transmit and MUST be ignored on receipt.",
      "ja": "フラグ：1バイト（符号なし整数）の送信にゼロに設定されるべきであり、領収書の上で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Length: 2 bytes (unsigned integer) This value holds the length of the HMAC in bytes plus 8.",
      "ja": "長さ：2バイト（符号なし整数）この値は、バイト+ 8におけるHMACの長さを保持します。"
    },
    {
      "indent": 3,
      "text": "Shared Key Identifier: 2 bytes (unsigned integer) This value describes which endpoint pair shared key is used.",
      "ja": "共有鍵識別子：2バイト（符号なし整数）この値は、共有鍵が使用されるエンドポイントペア記載されています。"
    },
    {
      "indent": 3,
      "text": "HMAC Identifier: 2 bytes (unsigned integer) This value describes which message digest is being used. Table 2 shows the currently defined values.",
      "ja": "HMAC識別子：2バイト（符号なし整数）この値は、ダイジェストが使用されているメッセージが記載されています。表2は、現在定義された値を示しています。"
    },
    {
      "indent": 3,
      "text": "HMAC: n bytes (unsigned integer) This holds the result of the HMAC calculation.",
      "ja": "HMAC：nバイト（符号なし整数）これは、HMAC計算の結果を保持しています。"
    },
    {
      "indent": 3,
      "text": "Padding: 0, 1, 2, or 3 bytes (unsigned integer) If the length of the HMAC is not a multiple of 4 bytes, the sender MUST pad the chunk with all zero bytes to make the chunk 32-bit aligned. The Padding MUST NOT be longer than 3 bytes and it MUST be ignored by the receiver.",
      "ja": "チャンク32ビット整列させるためにすべてゼロバイト0、1、2、または3バイト（符号なし整数）HMACの長さが4バイトの倍数でない場合、送信者MUSTパッドチャンク：パディング。パディングは3バイトより長くてはならず、それが受信機で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The control chunk AUTH MUST NOT appear more than once in an SCTP packet. All control and data chunks that are placed after the AUTH chunk in the packet are sent in an authenticated way. Those chunks placed in a packet before the AUTH chunk are not authenticated. Please note that DATA chunks can not appear before control chunks in an SCTP packet.",
      "ja": "制御チャンクAUTHは、SCTPパケット内に複数回現れてはなりません。パケット内のAUTHチャンクの後に配置されている全てのコントロールとデータチャンクが認証された方法で送信されます。 AUTHチャンクの前にパケットに配置されたこれらのチャンクは認証されません。 DATAチャンクはSCTPパケット内の制御チャンクの前に現れることはできませんのでご注意ください。"
    },
    {
      "indent": 0,
      "text": "6. Procedures",
      "section_title": true,
      "ja": "6.手順"
    },
    {
      "indent": 0,
      "text": "6.1. Establishment of an Association Shared Key",
      "section_title": true,
      "ja": "6.1. 協会共有鍵の確立"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint willing to receive or send authenticated chunks MUST send one RANDOM parameter in its INIT or INIT-ACK chunk. The RANDOM parameter MUST contain a 32-byte Random Number. The Random Number should be generated in accordance with RFC 4086 [7]. If the Random Number is not 32 bytes, the association MUST be aborted. The ABORT chunk SHOULD contain the error cause 'Protocol Violation'. In case of INIT collision, the rules governing the handling of this Random Number follow the same pattern as those for the Verification Tag, as explained in Section 5.2.4 of RFC 2960 [5]. Therefore, each endpoint knows its own Random Number and the peer's Random Number after the association has been established.",
      "ja": "認証されたチャンクを受信または送信するために喜んSCTP終点は、そのINITまたはINIT-ACKチャンクに1つのRANDOMパラメータを送らなければなりません。 RANDOMパラメータは32バイトの乱数を含まなければなりません。乱数は、RFC 4086に従って生成されるべきである[7]。乱数が32バイトではない場合、協会は中止されなければなりません。 ABORTチャンクは、エラーの原因「プロトコル違反」を含むべきです。 [5] RFC 2960の5.2.4項で説明したようにINITの衝突の場合には、この乱数の取り扱いを管理する規則は、検証タグと同じパターンに従ってください。アソシエーションが確立された後にそのため、各エンドポイントは、独自の乱数とピアの乱数を知っています。"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint has a list of chunks it only accepts if they are received in an authenticated way. This list is included in the INIT and INIT-ACK, and MAY be omitted if it is empty. Since this list does not change during the lifetime of the SCTP endpoint there is no problem in case of INIT collision.",
      "ja": "SCTP終点は、彼らが認証された方法で受信された場合にのみ受け付けチャンクのリストを持っています。このリストは、INITとINIT-ACKに含まれており、それが空の場合省略されるかもしれません。このリストはSCTP終点の存続期間中に変更されませんので、INITの衝突の場合には問題はありません。"
    },
    {
      "indent": 3,
      "text": "Each SCTP endpoint MUST include in the INIT and INIT-ACK a HMAC-ALGO parameter containing a list of HMAC Identifiers it requests the peer to use. The receiver of an HMAC-ALGO parameter SHOULD use the first listed algorithm it supports. The HMAC algorithm based on SHA-1 MUST be supported and included in the HMAC-ALGO parameter. An SCTP endpoint MUST NOT change the parameters listed in the HMAC-ALGO parameter during the lifetime of the endpoint.",
      "ja": "それぞれのSCTP終点はINITとINIT-ACK、それはピアが使用することを要求したHMAC識別子のリストを含むHMAC-ALGOパラメータに含まなければなりません。 HMAC-ALGOパラメータの受信機は、それがサポートしている最初にリストされているアルゴリズムを使用すべきです。 SHA-1に基づいてHMACアルゴリズムがサポートされ、HMAC-ALGOパラメータに含まれなければなりません。 SCTP終点は、エンドポイントの存続期間中にHMAC-ALGOパラメータにリストされているパラメータを変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "Both endpoints of an association MAY have endpoint pair shared keys that are byte vectors and pre-configured or established by another mechanism. They are identified by the Shared Key Identifier. For each endpoint pair shared key, an association shared key is computed. If there is no endpoint pair shared key, only one association shared key is computed by using an empty byte vector as the endpoint pair shared key.",
      "ja": "アソシエーションの両方のエンドポイントは、バイトベクターおよび事前構成または他の機構によって確立されているエンドポイントのペア共有鍵があるかもしれません。彼らは、共有キー識別子によって識別されます。キーを共有し、各エンドポイントのペアに対して、関連共有鍵が計算されます。キーを共有しないエンドポイントのペアが存在しない場合、唯一の関連共有鍵は、エンドポイントのペア共有キーとして、空のバイトベクトルを用いて計算されます。"
    },
    {
      "indent": 3,
      "text": "The RANDOM parameter, the CHUNKS parameter, and the HMAC-ALGO parameter sent by each endpoint are concatenated as byte vectors. These parameters include the parameter type, parameter length, and the parameter value, but padding is omitted; all padding MUST be removed from this concatenation before proceeding with further computation of keys. Parameters that were not sent are simply omitted from the concatenation process. The resulting two vectors are called the two key vectors.",
      "ja": "RANDOMパラメータ、チャンクパラメータ、および各エンドポイントによって送信されたHMAC-ALGOパラメータはバイトベクトルとして連結されています。これらのパラメータは、パラメータ・タイプ、パラメータ長、およびパラメータ値を含むが、パディングを省略しています。すべてのパディングは、キーの更なる計算を続行する前に、この連結から除去されなければなりません。送信されなかったパラメータは、単に連結プロセスから省略されています。結果として二つのベクトルは、次の2つの主要ベクトルと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "From the endpoint pair shared keys and the key vectors, the association shared keys are computed. This is performed by selecting the numerically smaller key vector and concatenating it to the endpoint pair shared key, and then concatenating the numerically larger key vector to that. If the key vectors are equal as numbers but differ in length, then the concatenation order is the endpoint shared key, followed by the shorter key vector, followed by the longer key vector. Otherwise, the key vectors are identical, and may be concatenated to the endpoint pair key in any order. The concatenation is performed on byte vectors, and all numerical comparisons use network byte order to convert the key vectors to a number. The result of the concatenation is the association shared key.",
      "ja": "キーとキーベクトル共有エンドポイント対から、関連共有鍵が計算されます。これは、数値的に小さい鍵ベクトルを選択し、キーを共有エンドポイントペアにそれを連結し、その数値的により大きな鍵ベクトルを連結することによって行われます。鍵ベクトルが数値として同じであるが、長さが異なる場合には、連結の順序は、エンドポイントが長い鍵ベクトル続く短い鍵ベクトル、続いて、キーを共有しました。そうでなければ、鍵ベクトルは同一であり、任意の順序でエンドポイントペアキーに連結されてもよいです。連結バイトベクトルに行われ、全ての数値比較は数に鍵ベクトルを変換するために、ネットワークバイト順を使用します。連結の結果は、関連共有鍵です。"
    },
    {
      "indent": 0,
      "text": "6.2. Sending Authenticated Chunks",
      "section_title": true,
      "ja": "6.2. 認証されたチャンクを送信"
    },
    {
      "indent": 3,
      "text": "Endpoints MUST send all requested chunks that have been authenticated where this has been requested by the peer. The other chunks MAY be sent whether or not they have been authenticated. If endpoint pair shared keys are used, one of them MUST be selected for authentication.",
      "ja": "エンドポイントは、これはピアによって要求された場所に認証されたすべての要求されたチャンクを送らなければなりません。他のチャンクは、彼らが認証されているかどうかを送るかもしれません。エンドポイントのペア共有キーを使用する場合は、そのうちの一つは、認証のために選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "To send chunks in an authenticated way, the sender MUST include these chunks after an AUTH chunk. This means that a sender MUST bundle chunks in order to authenticate them.",
      "ja": "認証された方法でチャンクを送信するには、送信者は、AUTHチャンクの後にこれらのチャンクを含まなければなりません。これは、送信者がそれらを認証するためにチャンクをバンドルしなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "If the endpoint has no endpoint pair shared key for the peer, it MUST use Shared Key Identifier zero with an empty endpoint pair shared key. If there are multiple endpoint shared keys the sender selects one and uses the corresponding Shared Key Identifier.",
      "ja": "エンドポイントは、ピアのためのエンドポイントのペアの共有鍵を持っていない場合は、空のエンドポイント対共有鍵と共有鍵識別子ゼロを使用しなければなりません。複数のエンドポイント共有キーが存在する場合、送信者は、いずれかを選択し、対応する共有キー識別子を使用しています。"
    },
    {
      "indent": 3,
      "text": "The sender MUST calculate the Message Authentication Code (MAC) (as described in RFC 2104 [2]) using the hash function H as described by the HMAC Identifier and the shared association key K based on the endpoint pair shared key described by the Shared Key Identifier. The 'data' used for the computation of the AUTH-chunk is given by the AUTH chunk with its HMAC field set to zero (as shown in Figure 6) followed by all the chunks that are placed after the AUTH chunk in the SCTP packet.",
      "ja": "（RFC 2104に記載されているように[2]）共有キーによって記述エンドポイント対共有鍵に基づくHMAC識別子と共有会合キーKによって記載されるように、送信者は、ハッシュ関数Hを用いてメッセージ認証コード（MAC）を計算しなければなりません識別子。 AUTH-チャンクの計算に使用される「データは」SCTPパケット内AUTHチャンクの後に配置されているすべてのチャンクに続く（図6に示すように）ゼロに設定されたHMACフィールドとAUTHチャンクによって与えられます。"
    },
    {
      "indent": 3,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Type = 0x0F   |   Flags=0     |         Chunk Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Shared Key Identifier      |        HMAC Identifier        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n\\                               0                               /\n/                               +-------------------------------\\\n|                               |           Padding             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 6",
      "ja": "図6"
    },
    {
      "indent": 3,
      "text": "Please note that all fields are in network byte order and that the field that will contain the complete HMAC is filled with zeroes. The length of the field shown as zero is the length of the HMAC described by the HMAC Identifier. The padding of all chunks being authenticated MUST be included in the HMAC computation.",
      "ja": "すべてのフィールドは、ネットワークバイト順であること、完全なHMACが含まれていますフィールドがゼロで満たされていることに注意してください。ゼロとして示されているフィールドの長さは、HMAC識別子によって記述HMACの長さです。認証されているすべてのチャンクのパディングは、HMACの計算に含まれなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sender fills the HMAC into the HMAC field and sends the packet.",
      "ja": "送信者は、HMACフィールドにHMACを満たし、パケットを送信します。"
    },
    {
      "indent": 0,
      "text": "6.3. Receiving Authenticated Chunks",
      "section_title": true,
      "ja": "6.3. 認証されたチャンクを受信"
    },
    {
      "indent": 3,
      "text": "The receiver has a list of chunk types that it expects to be received only after an AUTH-chunk. This list has been sent to the peer during the association setup. It MUST silently discard these chunks if they are not placed after an AUTH chunk in the packet.",
      "ja": "受信機は、それだけAUTHチャンクの後に受信されることを期待するチャンク・タイプのリストを有します。このリストは、協会のセットアップ中にピアに送信されてきました。それらは、パケット内のAUTHチャンクの後に配置されていない場合は静かにこれらのチャンクを捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "The receiver MUST use the HMAC algorithm indicated in the HMAC Identifier field. If this algorithm was not specified by the receiver in the HMAC-ALGO parameter in the INIT or INIT-ACK chunk during association setup, the AUTH chunk and all the chunks after it MUST be discarded and an ERROR chunk SHOULD be sent with the error cause defined in Section 4.1.",
      "ja": "受信機は、HMAC識別子フィールドに示さHMACアルゴリズムを使用しなければなりません。このアルゴリズムは、関連のセットアップ時にINITまたはINIT-ACKチャンクでHMAC-ALGOパラメータの受信機で指定されていない場合は、AUTHチャンクと、それは捨てなければなりませんした後、すべてのチャンクとERRORチャンクは、エラーの原因を送ってくださいセクション4.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "If an endpoint with no shared key receives a Shared Key Identifier other than 0, it MUST silently discard all authenticated chunks. If the endpoint has at least one endpoint pair shared key for the peer, it MUST use the key specified by the Shared Key Identifier if a key has been configured for that Shared Key Identifier. If no endpoint pair shared key has been configured for that Shared Key Identifier, all authenticated chunks MUST be silently discarded.",
      "ja": "無共有キーを持つエンドポイントが0以外の共有鍵識別子を受信した場合、それは静かにすべての認証済みチャンクを捨てなければなりません。エンドポイントはピアの少なくとも1つのエンドポイントペア共有キーを持っている場合、キーは、その共有キー識別子のために構成されている場合、それは共有キー識別子で指定されたキーを使用しなければなりません。何のエンドポイントのペア共有キーは、その共有鍵識別子のために設定されていない場合は、すべての認証済みチャンクは静かに捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "The receiver now performs the same calculation as described for the sender based on Figure 6. If the result of the calculation is the same as given in the HMAC field, all the chunks following the AUTH chunk are processed. If the field does not match the result of the calculation, all the chunks following the AUTH chunk MUST be silently discarded.",
      "ja": "計算の結果は、HMACフィールドで与えられるように、AUTHチャンク以下のすべてのチャンクが処理されるのと同じである場合は、図6に基づいて、送信者のために記載したように、受信機は現在、同様の計算を行います。フィールドは、計算の結果と一致しない場合、AUTHチャンクを、以下のすべてのチャンクは静かに捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "It should be noted that if the receiver wants to tear down an association in an authenticated way only, the handling of malformed packets should not result in tearing down the association.",
      "ja": "受信機が認証された方法で関連を取り壊すしたい場合のみ、不正なパケットの処理が関連を解体につながるべきではないことに留意すべきです。"
    },
    {
      "indent": 3,
      "text": "An SCTP implementation has to maintain state for each SCTP association. In the following, we call this data structure the SCTP transmission control block (STCB).",
      "ja": "SCTPの実装は、各SCTPアソシエーションの状態を維持しなければなりません。以下では、このデータ構造SCTP送信制御ブロック（STCB）を呼び出します。"
    },
    {
      "indent": 3,
      "text": "When an endpoint requires COOKIE-ECHO chunks to be authenticated, some special procedures have to be followed because the reception of a COOKIE-ECHO chunk might result in the creation of an SCTP association. If a packet arrives containing an AUTH chunk as a first chunk, a COOKIE-ECHO chunk as the second chunk, and possibly more chunks after them, and the receiver does not have an STCB for that packet, then authentication is based on the contents of the COOKIE-ECHO chunk. In this situation, the receiver MUST authenticate the chunks in the packet by using the RANDOM parameters, CHUNKS parameters and HMAC_ALGO parameters obtained from the COOKIE-ECHO chunk, and possibly a local shared secret as inputs to the authentication procedure specified in Section 6.3. If authentication fails, then the packet is discarded. If the authentication is successful, the COOKIE-ECHO and all the chunks after the COOKIE-ECHO MUST be processed. If the receiver has an STCB, it MUST process the AUTH chunk as described above using the STCB from the existing association to authenticate the COOKIE-ECHO chunk and all the chunks after it.",
      "ja": "エンドポイントが認証されるCOOKIE-ECHOチャンクを必要とする場合、いくつかの特別な手順がCOOKIE-ECHOチャンクの受信がSCTP協会の創設につながる可能性があるため、その後する必要があります。パケットは、それらの後に第二のチャンクとして最初のチャンク、COOKIE-ECHOチャンク、およびおそらく複数のチャンクとしてAUTHチャンクを含む到着し、受信機はそのパケットのSTCBを有していない場合、認証は、内容に基づいていますCOOKIE-ECHOチャンク。この状況では、受信機は、セクション6.3で指定された認証手順への入力としてCOOKIE-ECHOチャンク、及びおそらくはローカル共有秘密から得られたパラメータ、チャンクパラメータとHMAC_ALGOパラメータRANDOMを使用して、パケット内のチャンクを認証する必要があります。認証が失敗した場合、パケットが破棄されます。認証が成功した場合、COOKIE-ECHO COOKIE-ECHOの後、すべてのチャンクが処理しなければなりません。受信機はSTCBを有する場合COOKIE-ECHOチャンクとすべての後のチャンクを認証するために、既存の関連付けからSTCBを用いて上述したように、それはAUTHチャンクを処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the receiver does not find an STCB for a packet containing an AUTH chunk as the first chunk and does not find a COOKIE-ECHO chunk as the second chunk, it MUST use the chunks after the AUTH chunk to look up an existing association. If no association is found, the packet MUST be considered as out of the blue. The out of the blue handling MUST be based on the packet without taking the AUTH chunk into account. If an association is found, it MUST process the AUTH chunk using the STCB from the existing association as described earlier.",
      "ja": "受信機は最初のチャンクとしてAUTHチャンクを含むパケットのためのSTCBを見つけていないと第二のチャンクとしてCOOKIE-ECHOチャンクが見つからない場合は、既存の関連付けをルックアップするためにAUTHチャンクの後のチャンクを使用しなければなりません。全く関連が見つからない場合、パケットは、青色のうちとして考慮されなければなりません。青取り扱いのうち考慮AUTHチャンクを取ることなく、パケットに基づいていなければなりません。アソシエーションが見つかった場合、それは、前述のように、既存の関連付けからSTCBを用いAUTHチャンクを処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Requiring ABORT chunks and COOKIE-ECHO chunks to be authenticated makes it impossible for an attacker to bring down or restart an association as long as the attacker does not know the association shared key. But it should also be noted that if an endpoint accepts ABORT chunks only in an authenticated way, it may take longer to detect that the peer is no longer available. If an endpoint accepts COOKIE-ECHO chunks only in an authenticated way, the restart procedure does not work, because the restarting endpoint most likely does not know the association shared key of the old association to be restarted. However, if the restarting endpoint does know the old association shared key, he can successfully send the COOKIE-ECHO chunk in a way that it is accepted by the peer by using this old association shared key for the packet containing the AUTH chunk. After this operation, both endpoints have to use the new association shared key.",
      "ja": "攻撃者がいる限り、攻撃者は、協会が鍵を共有知らないとの関連をダウンさせるか、再起動するために認証されるチャンクとCOOKIE-ECHOチャンクを中止要求することは不可能になります。しかし、また、エンドポイントが唯一の認証された方法でチャンクを中止受け入れる場合、それはピアが利用できなくなったことを検出しないために時間がかかることに留意すべきです。エンドポイントが認証された方法でのみCOOKIE-ECHOチャンクを受け入れた場合、再起動エンドポイントが最も可能性の高い再起動するために、古い協会の協会共有鍵を知らないので、再起動の手順は、動作しません。古い協会を知っているん再始動エンドポイントがキーを共有している場合しかし、彼は首尾よくAUTHチャンクを含むパケットのための鍵を共有し、この古い関連付けを使用することによって、それがピアによって受け入れられているような方法でCOOKIE-ECHOチャンクを送信することができます。この操作の後、両方のエンドポイントは、新しいアソシエーション共有キーを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a server has an endpoint pair shared key with some clients, it can request the COOKIE_ECHO chunk to be authenticated and can ensure that only associations from clients with a correct endpoint pair shared key are accepted.",
      "ja": "サーバーは、一部のクライアントでキーを共有し、エンドポイントのペアを持っている場合、それが認証されるCOOKIE_ECHOチャンクを要求することができ、キーを共有し、正しいエンドポイントのペアを持つクライアントからのみ関連が受け入れられることを保証することができます。"
    },
    {
      "indent": 3,
      "text": "Furthermore, it is important that the cookie contained in an INIT-ACK chunk and in a COOKIE-ECHO chunk MUST NOT contain any endpoint pair shared keys.",
      "ja": "さらに、クッキーがINIT-ACKチャンクに含まれているとCOOKIE-ECHOチャンクに任意のエンドポイントのペア共有キーを含んではならないことが重要です。"
    },
    {
      "indent": 0,
      "text": "7. Examples",
      "section_title": true,
      "ja": "7.例"
    },
    {
      "indent": 3,
      "text": "This section gives examples of message exchanges for association setup.",
      "ja": "このセクションでは、アソシエーションのセットアップのためのメッセージ交換の例を与えます。"
    },
    {
      "indent": 3,
      "text": "The simplest way of using the extension described in this document is given by the following message exchange.",
      "ja": "本書では説明拡張機能を使用する最も簡単な方法は、以下のメッセージ交換によって与えられます。"
    },
    {
      "indent": 7,
      "text": "---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n<------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n-------------------- COOKIE-ECHO -------------------->\n<-------------------- COOKIE-ACK ---------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Please note that the CHUNKS parameter is optional in the INIT and INIT-ACK.",
      "ja": "チャンクパラメータはINITとINIT-ACKにオプションであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the server wants to receive DATA chunks in an authenticated way, the following message exchange is possible:",
      "ja": "サーバが認証された方法でデータチャンクを受信したい場合は、以下のようなメッセージ交換が可能です。"
    },
    {
      "indent": 7,
      "text": "---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n<------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n--------------- COOKIE-ECHO; AUTH; DATA ------------->\n<----------------- COOKIE-ACK; SACK ------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Please note that if the endpoint pair shared key depends on the client and the server, and is only known by the upper layer, this message exchange requires an upper layer intervention between the processing of the COOKIE-ECHO chunk and the processing of the AUTH and DATA chunk at the server side. This intervention may be realized by a COMMUNICATION-UP notification followed by the presentation of the endpoint pair shared key by the upper layer to the SCTP stack, see for example Section 10 of RFC 2960 [5]. If this intervention is not possible due to limitations of the API (for example, the socket API), the server might discard the AUTH and DATA chunk, making a retransmission of the DATA chunk necessary. If the same endpoint pair shared key is used for multiple endpoints and does not depend on the client, this intervention might not be necessary.",
      "ja": "鍵を共有し、エンドポイントのペアは、クライアントとサーバに依存し、上層のみによって知られている場合、このメッセージ交換は、COOKIE-ECHOチャンクとAUTHの処理の処理の間に、上層の介入を必要とすることに注意してくださいとサーバ側でのデータチャンク。この介入は、SCTPスタックの上位レイヤがエンドポイント対共有鍵の提示に続いて通信UP通知によって実現されてもよい、RFC 2960の実施例のセクション10を参照されたい[5]。この介入が原因APIの制限（例えば、ソケットAPI）にできない場合は、サーバが必要なデータチャンクの再送信を行う、AUTHおよびDATAチャンクを捨てるかもしれません。同じエンドポイントペア共有キーは、複数のエンドポイントに使用され、クライアントに依存しない場合は、この介入は必要ではない可能性があります。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document (RFC 4895) is the reference for all registrations described in this section. All registrations need to be listed in the document available at SCTP-parameters [9]. The changes are described below.",
      "ja": "この文書（RFC 4895）は、このセクションで説明するすべての登録のための基準です。すべての登録がSCTPパラメータ[9]で入手可能なドキュメントに記載されていることが必要です。変更内容は以下の通りです。"
    },
    {
      "indent": 0,
      "text": "8.1. A New Chunk Type",
      "section_title": true,
      "ja": "8.1. 新しいチャンクタイプ"
    },
    {
      "indent": 3,
      "text": "A chunk type for the AUTH chunk has been assigned by IANA. IANA has assigned the value (15), as given in Table 4. An additional line has been added in the \"CHUNK TYPES\" table of SCTP-parameters [9]:",
      "ja": "AUTHチャンクのためのチャンクタイプは、IANAによって割り当てられています。 IANAは、表4に示すように、追加のラインはSCTPパラメータの「塊タイプ」テーブルに追加された、値（15）が割り当てられている[9]。"
    },
    {
      "indent": 3,
      "text": "CHUNK TYPES",
      "ja": "CHUNKの種類"
    },
    {
      "indent": 3,
      "text": "ID Value    Chunk Type                                     Reference\n-----       ----------                                     ---------\n15          Authentication Chunk (AUTH)                    [RFC4895]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.2. Three New Parameter Types",
      "section_title": true,
      "ja": "8.2. 三つの新規パラメータの種類"
    },
    {
      "indent": 3,
      "text": "Parameter types have been assigned for the RANDOM, CHUNKS, and HMAC-ALGO parameter by IANA. The values are as given in Table 1. This required two modifications to the \"CHUNK PARAMETER TYPES\" tables in SCTP-parameters [9]: the first is the addition of three new lines to the \"INIT Chunk Parameter Types\" table:",
      "ja": "パラメータタイプはIANAによってRANDOM、チャンクとHMAC-ALGOパラメータに割り当てられています。表1に与えられる値は、これは、SCTPパラメータの「CHUNK PARAMETERタイプ」テーブルに2つの変更が必要である[9]：最初は「INITチャンクパラメータタイプ」テーブルには3つの新しい行の追加です。"
    },
    {
      "indent": 3,
      "text": "Chunk Parameter Type                       Value\n--------------------                       -----\nRandom                             32770 (0x8002)\nChunk List                         32771 (0x8003)\nRequested HMAC Algorithm Parameter 32772 (0x8004)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The second required change is the addition of the same three lines to the to the \"INIT ACK Chunk Parameter Types\" table.",
      "ja": "二、必要な変更は、「INIT ACKチャンクパラメータの種類」テーブルへの同じ3行を追加することです。"
    },
    {
      "indent": 0,
      "text": "8.3. A New Error Cause",
      "section_title": true,
      "ja": "8.3. 新しいエラー原因"
    },
    {
      "indent": 3,
      "text": "An error cause for the Unsupported HMAC Identifier error cause has been assigned. The value (261) has been assigned as in Table 3.",
      "ja": "サポートされていないHMAC識別子のエラー原因のエラー原因が割り当てられています。値（261）を表3のように割り当てられています。"
    },
    {
      "indent": 3,
      "text": "This requires an additional line of the \"CAUSE CODES\" table in SCTP-parameters [9]:",
      "ja": "これは、[9] SCTPパラメータの「原因コード」テーブルの追加の行を必要とします。"
    },
    {
      "indent": 3,
      "text": "VALUE            CAUSE CODE                               REFERENCE\n-----            ----------------                         ---------\n261 (0x0105)     Unsupported HMAC Identifier              [RFC4895]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.4. A New Table for HMAC Identifiers",
      "section_title": true,
      "ja": "8.4.  HMAC識別子のための新しい表"
    },
    {
      "indent": 3,
      "text": "HMAC Identifiers have to be maintained by IANA. Four initial values have been assigned by IANA as described in Table 2. This required a new table \"HMAC IDENTIFIERS\" in SCTP-parameters [9]:",
      "ja": "HMAC識別子は、IANAによって維持されなければなりません。表2に記載のように、4つの初期値は、これは、SCTPパラメータ[9]に新しいテーブル「HMAC識別子」を必要とIANAによって割り当てられています："
    },
    {
      "indent": 3,
      "text": "HMAC Identifier      Message Digest Algorithm             REFERENCE\n---------------      ------------------------             ---------\n0                    Reserved                             [RFC4895]\n1                    SHA-1                                [RFC4895]\n2                    Reserved                             [RFC4895]\n3                    SHA-256                              [RFC4895]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For registering a new HMAC Identifier with IANA, in this table, a request has to be made to assign such a number. This number must be unique and a message digest algorithm usable with the HMAC defined in RFC 2104 [2] MUST be specified. The \"Specification Required\" policy of RFC 2434 [4] MUST be applied.",
      "ja": "IANAに新しいHMAC識別子を登録するために、このテーブルでは、要求は、そのような番号を割り当てるためになされなければなりません。この番号は一意である必要があり、メッセージはRFC 2104で定義されたHMACとアルゴリズムが使用可能ダイジェスト[2]が指定されなければなりません。 RFC 2434 [4]の「仕様が必要である」というポリシーが適用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Without using endpoint shared keys, this extension only protects against modification or injection of authenticated chunks by attackers who did not capture the initial handshake setting up the SCTP association.",
      "ja": "エンドポイントの共有キーを使用せずに、この拡張機能はSCTPアソシエーションを設定する最初のハンドシェイクをキャプチャしていない攻撃者によって変更または認証されたチャンクの注入から保護します。"
    },
    {
      "indent": 3,
      "text": "If an endpoint pair shared key is used, even a true man in the middle cannot inject chunks, which are required to be authenticated, even if he intercepts the initial message exchange. The endpoint also knows that it is accepting authenticated chunks from a peer who knows the endpoint pair shared key.",
      "ja": "鍵を共有し、エンドポイントのペアを使用する場合、途中でさえ、真の男は、彼が最初のメッセージ交換を傍受した場合でも、認証されるように要求されているチャンクを、注入することはできません。エンドポイントはまた、エンドポイントのペア共有キーを知っている相手からの認証されたチャンクを受け入れていることを知っています。"
    },
    {
      "indent": 3,
      "text": "The establishment of endpoint pair shared keys is out of the scope of this document. Other mechanisms can be used, like using TLS or manual configuration.",
      "ja": "エンドポイントのペア共有鍵の確立は、この文書の範囲外です。他の機構は、TLSまたは手動構成を使用してのように、使用することができます。"
    },
    {
      "indent": 3,
      "text": "When an endpoint accepts COOKIE-ECHO chunks only in an authenticated way the restart procedure does not work. Neither an attacker nor a restarted endpoint not knowing the association shared key can perform an restart. However, if the association shared key is known, it is possible to restart the association.",
      "ja": "エンドポイントが唯一の認証された方法で、COOKIE-ECHOチャンクを受け付けると、再起動の手順は動作しません。攻撃者や再起動を行うことができ協会共有キーを知らずに再起動したエンドポイントでもありません。関連が知られているキーを共有している場合しかし、関連付けを再起動することが可能です。"
    },
    {
      "indent": 3,
      "text": "Because SCTP already has a built-in mechanism that handles the reception of duplicated chunks, the presented solution makes use of this functionality and does not provide a method to avoid replay attacks by itself. Of course, this only works within each SCTP association. Therefore, a separate shared key is used for each SCTP association to handle replay attacks covering multiple SCTP associations.",
      "ja": "SCTPはすでに重複チャンクの受信を扱う組み込みのメカニズムを持っているので、提示ソリューションは、この機能を利用し、自身でリプレイ攻撃を回避するための方法を提供していません。もちろん、これは、各SCTPアソシエーション内で動作します。したがって、別の共有鍵は、複数のSCTPアソシエーションを覆うリプレイ攻撃を処理するために、各SCTPアソシエーションのために使用されます。"
    },
    {
      "indent": 3,
      "text": "Each endpoint presenting a list of more than one element in the HMAC-ALGO parameter must be prepared for the peer using the weakest algorithm listed.",
      "ja": "HMAC-ALGOパラメータで複数の要素のリストを提示し、各エンドポイントは、リストされた最も弱いアルゴリズムを使用してピアのために準備されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When an endpoint pair uses non-NULL endpoint pair shared keys and one of the endpoints still accepts a NULL key, an attacker who captured the initial handshake can still inject or modify authenticated chunks by using the NULL key.",
      "ja": "エンドポイントのペアが非NULLエンドポイント対共有鍵を使用し、エンドポイントの一つが依然としてNULLキーを受け付けると、初期ハンドシェークを捕捉し、攻撃者は依然としてNULLキーを使用して認証チャンクを注入または修正することができます。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgments",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank David Black, Sascha Grau, Russ Housley, Ivan Arias Rodriguez, Irene Ruengeler, and Magnus Westerlund for their invaluable comments.",
      "ja": "作者は彼らの貴重なコメントをデビッド・ブラック、サシャ・グラウ、ラスHousley、イバン・ロドリゲス・アリアス、アイリーンRuengeler、およびマグヌスウェスターに感謝したいです。"
    },
    {
      "indent": 0,
      "text": "11. Normative References",
      "section_title": true,
      "ja": "11.引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[1]リベスト、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[2] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[2] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[3] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[3]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[4] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[4] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[5] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L., and V. Paxson, \"Stream Control Transmission Protocol\", RFC 2960, October 2000.",
      "ja": "[5]スチュワート、R.、謝、Q.、Morneault、K.、シャープ、C.、Schwarzbauer、H.、テイラー、T.、Rytina、I.、カラ、M.、チャン、L.、およびV 。パクソン、 \"ストリーム制御伝送プロトコル\"、RFC 2960、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[6] Jungmaier, A., Rescorla, E., and M. Tuexen, \"Transport Layer Security over Stream Control Transmission Protocol\", RFC 3436, December 2002.",
      "ja": "[6] Jungmaier、A.、レスコラ、E.、およびM. Tuexen、 \"ストリーム制御伝送プロトコルを介してトランスポート層セキュリティ\"、RFC 3436、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[7] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[7]イーストレーク、D.、シラー、J.、およびS.クロッカーを、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[8] National Institute of Standards and Technology, \"Secure Hash Standard\", FIPS PUB 180-2, August 2002, <http://csrc.nist.gov/publications/fips/fips180-2/ fips180-2.pdf>.",
      "ja": "[8]アメリカ国立標準技術研究所、 \"セキュアハッシュ標準\"、FIPS PUB 180-2の、2002年8月、<http://csrc.nist.gov/publications/fips/fips180-2/ fips180-2.pdf> 。"
    },
    {
      "indent": 3,
      "text": "[9] <http://www.iana.org/assignments/sctp-parameters>",
      "ja": "「９」 ＜ｈっｔｐ：／／ｗっｗ。いあな。おｒｇ／あっしｇんめんｔｓ／ｓｃｔｐーぱらめてｒｓ＞"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Michael Tuexen Muenster Univ. of Applied Sciences Stegerwaldstr. 39 48565 Steinfurt Germany",
      "ja": "マイケルTuexenミュンスター大学。応用科学Stegerwaldstrの。 39 48565シュタインフルトドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: tuexen@fh-muenster.de",
      "ja": "メールアドレス：tuexen@fh-muenster.de"
    },
    {
      "indent": 3,
      "text": "Randall R. Stewart Cisco Systems, Inc. 4875 Forest Drive Suite 200 Columbia, SC 29206 USA",
      "ja": "ランドールR.スチュワートシスコシステムズ社4875森ドライブスイート200コロンビア、SC 29206 USA"
    },
    {
      "indent": 3,
      "text": "EMail: rrs@cisco.com",
      "ja": "メールアドレス：rrs@cisco.com"
    },
    {
      "indent": 3,
      "text": "Peter Lei Cisco Systems, Inc. 8735 West Higgins Road Suite 300 Chicago, IL 60631 USA",
      "ja": "ピーター・レイシスコシステムズ株式会社8735西ヒギンズロードスイート300シカゴ、IL 60631 USA"
    },
    {
      "indent": 3,
      "text": "Phone: EMail: peterlei@cisco.com",
      "ja": "電話番号：Eメール：peterlei@cisco.com"
    },
    {
      "indent": 3,
      "text": "Eric Rescorla RTFM, Inc. 2064 Edgewood Drive Palo Alto, CA 94303 USA",
      "ja": "エリックレスコラRTFM、Inc.の2064エッジウッドドライブパロアルト、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650-320-8549 EMail: ekr@rtfm.com",
      "ja": "電話：+1 650-320-8549電子メール：ekr@rtfm.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "著作権（C）IETFトラスト（2007）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットSOCIETY、（もしあれば）を後援し、IETF TRUST ANDインターネットエンジニアリングタスクフォース放棄ALLに設けられています。保証は、明示または黙示、この情報の利用および特定目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証がこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    }
  ]
}