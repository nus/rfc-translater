{
  "title": {
    "text": "RFC 4120 - The Kerberos Network Authentication Service (V5)",
    "ja": "RFC 4120 - ケルベロスネットワーク認証サービス（V5）"
  },
  "number": 4120,
  "created_at": "2019-10-20 01:41:24.915852+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          C. Neuman\nRequest for Comments: 4120                                       USC-ISI\nObsoletes: 1510                                                    T. Yu\nCategory: Standards Track                                     S. Hartman\n                                                              K. Raeburn\n                                                                     MIT\n                                                               July 2005",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "The Kerberos Network Authentication Service (V5)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態のためのインターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document provides an overview and specification of Version 5 of the Kerberos protocol, and it obsoletes RFC 1510 to clarify aspects of the protocol and its intended use that require more detailed or clearer explanation than was provided in RFC 1510. This document is intended to provide a detailed description of the protocol, suitable for implementation, together with descriptions of the appropriate use of protocol messages and fields within those messages.",
      "ja": "この文書では、Kerberosプロトコルのバージョン5の概要と仕様を提供し、それはRFC 1510はこの文書は提供することを意図しているRFC 1510に設けられたより詳細な又は明確な説明を必要とするプロトコルの態様およびその使用目的を明確にするために時代遅れインプリメンテーションのために適切なプロトコルの詳細な説明、一緒にそれらのメッセージ内のプロトコルメッセージとフィールドの適切な使用についての説明です。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n   1.1. The Kerberos Protocol ......................................6\n   1.2. Cross-Realm Operation ......................................8\n   1.3. Choosing a Principal with Which to Communicate .............9\n   1.4. Authorization .............................................10\n   1.5. Extending Kerberos without Breaking Interoperability ......11\n        1.5.1. Compatibility with RFC 1510 ........................11\n        1.5.2. Sending Extensible Messages ........................12\n   1.6. Environmental Assumptions .................................12\n   1.7. Glossary of Terms .........................................13\n2. Ticket Flag Uses and Requests ..................................16\n   2.1. Initial, Pre-authenticated, and\n        Hardware-Authenticated Tickets ............................17\n   2.2. Invalid Tickets ...........................................17\n   2.3. Renewable Tickets .........................................17\n   2.4. Postdated Tickets .........................................18\n   2.5. Proxiable and Proxy Tickets ...............................19\n   2.6. Forwardable Tickets .......................................19\n   2.7. Transited Policy Checking .................................20\n   2.8. OK as Delegate ............................................21\n   2.9. Other KDC Options .........................................21\n        2.9.1. Renewable-OK .......................................21\n        2.9.2. ENC-TKT-IN-SKEY ....................................22\n        2.9.3. Passwordless Hardware Authentication ...............22\n3. Message Exchanges ..............................................22\n   3.1. The Authentication Service Exchange .......................22\n        3.1.1. Generation of KRB_AS_REQ Message ...................24\n        3.1.2. Receipt of KRB_AS_REQ Message ......................24\n        3.1.3. Generation of KRB_AS_REP Message ...................24\n        3.1.4. Generation of KRB_ERROR Message ....................27\n        3.1.5. Receipt of KRB_AS_REP Message ......................27\n        3.1.6. Receipt of KRB_ERROR Message .......................28\n   3.2. The Client/Server Authentication Exchange .................29\n        3.2.1. The KRB_AP_REQ Message .............................29\n        3.2.2. Generation of a KRB_AP_REQ Message .................29\n        3.2.3. Receipt of KRB_AP_REQ Message ......................30\n        3.2.4. Generation of a KRB_AP_REP Message .................33\n        3.2.5. Receipt of KRB_AP_REP Message ......................33\n        3.2.6. Using the Encryption Key ...........................33\n   3.3. The Ticket-Granting Service (TGS) Exchange ................34\n        3.3.1. Generation of KRB_TGS_REQ Message ..................35\n        3.3.2. Receipt of KRB_TGS_REQ Message .....................37\n        3.3.3. Generation of KRB_TGS_REP Message ..................38\n        3.3.4. Receipt of KRB_TGS_REP Message .....................42",
      "raw": true,
      "ja": "1.はじめに\n   1.1。 Kerberosのプロトコル\n   1.2。クロスレルムオペレーション\n   1.3。通信することで校長を選びます\n   1.4。認定\n   1.5。相互運用性を壊すことなくKerberosを拡張\n        1.5.1。 RFC 1510との互換性\n        1.5.2。拡張可能なメッセージの送信\n   1.6。環境仮定\n   1.7。用語集\n2.チケット旗の用途および要求\n   2.1。初期、事前認証、および\n        ハードウェア認証チケット\n   2.2。無効なチケット\n   2.3。再生可能チケット\n   2.4。遅延チケット\n   2.5。代理可能とプロキシチケット\n   2.6。転送可能チケット\n   2.7。遷移ポリシーチェック\n   2.8。代理人としてOK\n   2.9。その他のKDCオプション\n        2.9.1。再生可能-OK\n        2.9.2。 ENC-TKT-IN-SKEY\n        2.9.3。パスワードなしのハードウェア認証\n3.メッセージ交換\n   3.1。認証サービスエクスチェンジ\n        3.1.1。 KRB_AS_REQメッセージの生成\n        3.1.2。 KRB_AS_REQメッセージの受信\n        3.1.3。 KRB_AS_REPメッセージの生成\n        3.1.4。 KRB_ERRORメッセージの生成\n        3.1.5。 KRB_AS_REPメッセージの受信\n        3.1.6。 KRB_ERRORメッセージの受信\n   3.2。クライアント/サーバー認証交換\n        3.2.1。 KRB_AP_REQメッセージ\n        3.2.2。 KRB_AP_REQメッセージの生成\n        3.2.3。 KRB_AP_REQメッセージの受信\n        3.2.4。 KRB_AP_REPメッセージの生成\n        3.2.5。 KRB_AP_REPメッセージの受信\n        3.2.6。暗号化キーを使用して\n   3.3。チケット認可サービス（TGS）交換\n        3.3.1。 KRB_TGS_REQメッセージの生成\n        3.3.2。 KRB_TGS_REQメッセージの受信\n        3.3.3。 KRB_TGS_REPメッセージの生成\n        3.3.4。 KRB_TGS_REPメッセージの受信"
    },
    {
      "indent": 3,
      "text": "   3.4. The KRB_SAFE Exchange .....................................42\n        3.4.1. Generation of a KRB_SAFE Message ...................42\n        3.4.2. Receipt of KRB_SAFE Message ........................43\n   3.5. The KRB_PRIV Exchange .....................................44\n        3.5.1. Generation of a KRB_PRIV Message ...................44\n        3.5.2. Receipt of KRB_PRIV Message ........................44\n   3.6. The KRB_CRED Exchange .....................................45\n        3.6.1. Generation of a KRB_CRED Message ...................45\n        3.6.2. Receipt of KRB_CRED Message ........................46\n   3.7. User-to-User Authentication Exchanges .....................47\n4. Encryption and Checksum Specifications .........................48\n5. Message Specifications .........................................50\n   5.1. Specific Compatibility Notes on ASN.1 .....................51\n        5.1.1. ASN.1 Distinguished Encoding Rules .................51\n        5.1.2. Optional Integer Fields ............................52\n        5.1.3. Empty SEQUENCE OF Types ............................52\n        5.1.4. Unrecognized Tag Numbers ...........................52\n        5.1.5. Tag Numbers Greater Than 30 ........................53\n   5.2. Basic Kerberos Types ......................................53\n        5.2.1. KerberosString .....................................53\n        5.2.2. Realm and PrincipalName ............................55\n        5.2.3. KerberosTime .......................................55\n        5.2.4. Constrained Integer Types ..........................55\n        5.2.5. HostAddress and HostAddresses ......................56\n        5.2.6. AuthorizationData ..................................57\n        5.2.7. PA-DATA ............................................60\n        5.2.8. KerberosFlags ......................................64\n        5.2.9. Cryptosystem-Related Types .........................65\n   5.3. Tickets ...................................................66\n   5.4. Specifications for the AS and TGS Exchanges ...............73\n        5.4.1. KRB_KDC_REQ Definition .............................73\n        5.4.2. KRB_KDC_REP Definition .............................81\n   5.5. Client/Server (CS) Message Specifications .................84\n        5.5.1. KRB_AP_REQ Definition ..............................84\n        5.5.2. KRB_AP_REP Definition ..............................88\n        5.5.3. Error Message Reply ................................89\n   5.6. KRB_SAFE Message Specification ............................89\n        5.6.1. KRB_SAFE definition ................................89\n   5.7. KRB_PRIV Message Specification ............................91\n        5.7.1. KRB_PRIV Definition ................................91\n   5.8. KRB_CRED Message Specification ............................92\n        5.8.1. KRB_CRED Definition ................................92\n   5.9. Error Message Specification ...............................94\n        5.9.1. KRB_ERROR Definition ...............................94\n   5.10. Application Tag Numbers ..................................96",
      "raw": true,
      "ja": "3.4。 KRB_SAFE交換\n        3.4.1。 KRB_SAFEメッセージの生成\n        3.4.2。 KRB_SAFEメッセージの受信\n   3.5。 KRB_PRIV交換\n        3.5.1。 KRB_PRIVメッセージの生成\n        3.5.2。 KRB_PRIVメッセージの受信\n   3.6。 KRB_CRED交換\n        3.6.1。 KRB_CREDメッセージの生成\n        3.6.2。 KRB_CREDメッセージの受信\n   3.7。ユーザ間の認証交換\n4.暗号化とチェックサム仕様\n5.メッセージの仕様\n   5.1。 ASN.1上の具体的な互換性に関する注意事項\n        5.1.1。 ASN.1の識別符号化規則\n        5.1.2。オプションの整数フィールド\n        5.1.3。型の空のシーケンス\n        5.1.4。認識できないタグ番号\n        5.1.5。 30よりも大きなタグ番号\n   5.2。基本的なKerberosのタイプ\n        5.2.1。 KerberosString\n        5.2.2。レルムとのPrincipalName\n        5.2.3。 KerberosTime\n        5.2.4。制約付き整数型\n        5.2.5。 HostAddressはとHostAddresses\n        5.2.6。 AuthorizationData\n        5.2.7。 PA-DATA\n        5.2.8。 KerberosFlags\n        5.2.9。暗号関連の種類\n   5.3。切符売場\n   5.4。 ASおよびTGS交換のための仕様\n        5.4.1。 KRB_KDC_REQ定義\n        5.4.2。 KRB_KDC_REP定義\n   5.5。クライアント/サーバー（CS）メッセージ仕様\n        5.5.1。 KRB_AP_REQの定義\n        5.5.2。 KRB_AP_REP定義\n        5.5.3。エラーメッセージに返信\n   5.6。 KRB_SAFEメッセージ仕様\n        5.6.1。 KRB_SAFE定義\n   5.7。 KRB_PRIVメッセージ仕様\n        5.7.1。 KRB_PRIVの定義\n   5.8。 KRB_CREDメッセージ仕様\n        5.8.1。 KRB_CRED定義\n   5.9。エラーメッセージ仕様\n        5.9.1。 KRB_ERRORの定義\n   5.10。アプリケーションタグ番号"
    },
    {
      "indent": 3,
      "text": "6. Naming Constraints .............................................97\n   6.1. Realm Names ...............................................97\n   6.2. Principal Names .......................................... 99\n        6.2.1. Name of Server Principals .........................100\n7. Constants and Other Defined Values ............................101\n   7.1. Host Address Types .......................................101\n   7.2. KDC Messaging: IP Transports .............................102\n        7.2.1. UDP/IP transport ..................................102\n        7.2.2. TCP/IP Transport ..................................103\n        7.2.3. KDC Discovery on IP Networks ......................104\n   7.3. Name of the TGS ..........................................105\n   7.4. OID Arc for KerberosV5 ...................................106\n   7.5. Protocol Constants and Associated Values .................106\n        7.5.1. Key Usage Numbers .................................106\n        7.5.2. PreAuthentication Data Types ......................108\n        7.5.3. Address Types .....................................109\n        7.5.4. Authorization Data Types ..........................109\n        7.5.5. Transited Encoding Types ..........................109\n        7.5.6. Protocol Version Number ...........................109\n        7.5.7. Kerberos Message Types ............................110\n        7.5.8. Name Types ........................................110\n        7.5.9. Error Codes .......................................110\n8. Interoperability Requirements .................................113\n   8.1. Specification 2 ..........................................113\n   8.2. Recommended KDC Values ...................................116\n9. IANA Considerations ...........................................116\n10. Security Considerations ......................................117\n11. Acknowledgements .............................................121\nA. ASN.1 Module ..................................................123\nB. Changes since RFC 1510 ........................................131\nNormative References .............................................134\nInformative References ...........................................135",
      "raw": true,
      "ja": "6.ネーミングの制約\n   6.1。レルム名\n   6.2。プリンシパル名.......................................... 99\n        6.2.1。サーバのプリンシパルの名前\n7.定数およびその他の定義された値\n   7.1。ホストアドレスタイプ\n   7.2。 KDCメッセージング：IPトランスポート\n        7.2.1。 UDP / IPトランスポート\n        7.2.2。 TCP / IPトランスポート\n        7.2.3。 IPネットワーク上のKDC発見\n   7.3。 TGSの名前\n   7.4。 KerberosV5のためのOIDアーク\n   7.5。プロトコル定数と関連する値\n        7.5.1。キー使用法番号\n        7.5.2。事前認証データの種類\n        7.5.3。アドレスの種類\n        7.5.4。認可データ・タイプ\n        7.5.5。遷移エンコーディング型\n        7.5.6。プロトコルバージョン番号\n        7.5.7。ケルベロスメッセージタイプ\n        7.5.8。名前の種類\n        7.5.9。エラーコード\n8.相互運用性の要件\n   8.1。仕様2\n   8.2。推奨されるKDC値\n9. IANAの考慮事項\n10.セキュリティの考慮事項\n11.謝辞\nA. ASN.1モジュール\nRFC 1510からの変更点B.\n引用規格\n参考文献"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the concepts and model upon which the Kerberos network authentication system is based. It also specifies Version 5 of the Kerberos protocol. The motivations, goals, assumptions, and rationale behind most design decisions are treated cursorily; they are more fully described in a paper available in IEEE communications [NT94] and earlier in the Kerberos portion of the Athena Technical Plan [MNSS87].",
      "ja": "このドキュメントは、Kerberosネットワーク認証システムが基づいている概念とモデルについて説明します。また、Kerberosプロトコルのバージョン5を指定します。ほとんどの設計上の決定の背後にある動機、目標、仮定、および論理的根拠はcursorily扱われます。それらは、より完全にIEEE通信[NT94]とアテナ技術プラン[MNSS87]のケルベロス部分で以前に利用可能な紙に記載されています。"
    },
    {
      "indent": 3,
      "text": "This document is not intended to describe Kerberos to the end user, system administrator, or application developer. Higher-level papers describing Version 5 of the Kerberos system [NT94] and documenting version 4 [SNS88] are available elsewhere.",
      "ja": "この文書は、エンドユーザー、システム管理者、またはアプリケーション開発者にKerberosを記載するものではありません。 Kerberosシステムのバージョン5を説明する高レベルの論文[NT94]及び文書バージョン4は、[SNS88】他の場所で利用可能です。"
    },
    {
      "indent": 3,
      "text": "The Kerberos model is based in part on Needham and Schroeder's trusted third-party authentication protocol [NS78] and on modifications suggested by Denning and Sacco [DS81]. The original design and implementation of Kerberos Versions 1 through 4 was the work of two former Project Athena staff members, Steve Miller of Digital Equipment Corporation and Clifford Neuman (now at the Information Sciences Institute of the University of Southern California), along with Jerome Saltzer, Technical Director of Project Athena, and Jeffrey Schiller, MIT Campus Network Manager. Many other members of Project Athena have also contributed to the work on Kerberos.",
      "ja": "ケルベロスモデルは[NS78]ニーダム及びシュローダーの信頼できるサードパーティの認証プロトコルとデニングとサッコ[DS81]によって提案された変更に基づいています。 4経由のKerberosバージョン1の元の設計と実装は、ジェロームSaltzerと一緒に、（今南カリフォルニア大学の情報科学研究所）2人の元Athenaプロジェクトスタッフ、ディジタル・イクイップメント・コーポレーションとクリフォード・ノイマンのスティーブ・ミラーの作品でした、Athenaプロジェクトのテクニカルディレクター、ジェフリー・シラー、MITキャンパスネットワークマネージャ。 Athenaプロジェクトの他の多くのメンバーがケルベロスの作業に貢献しています。"
    },
    {
      "indent": 3,
      "text": "Version 5 of the Kerberos protocol (described in this document) has evolved because of new requirements and desires for features not available in Version 4. The design of Version 5 was led by Clifford Neuman and John Kohl with much input from the community. The development of the MIT reference implementation was led at MIT by John Kohl and Theodore Ts'o, with help and contributed code from many others. Since RFC 1510 was issued, many individuals have proposed extensions and revisions to the protocol. This document reflects some of these proposals. Where such changes involved significant effort, the document cites the contribution of the proposer.",
      "ja": "（この文書で説明）Kerberosプロトコルのバージョン5があるため、コミュニティから多くの入力とクリフォード・ノイマンとジョン・コールズによって導かれたバージョン4バージョン5の設計では利用できない機能のための新たな要件と欲望の進化してきました。 MITリファレンス実装の開発は助けを借りて、ジョン・コールズとセオドア・ツォーでMITで主導し、多くの人からコードを寄贈されました。 RFC 1510が発行されて以来、多くの個人は、プロトコルの拡張や修正を提案しました。この文書では、これらの提案のいくつかを反映しています。このような変化は、多大な労力を伴った場合は、文書は、提案者の貢献を挙げています。"
    },
    {
      "indent": 3,
      "text": "Reference implementations of both Version 4 and Version 5 of Kerberos are publicly available, and commercial implementations have been developed and are widely used. Details on the differences between Versions 4 and 5 can be found in [KNT94].",
      "ja": "両方のバージョン4とKerberosのバージョン5のリファレンス実装では、公的に入手可能であり、および商用の実装が開発され、広く使用されています。バージョン4と5との間の違いについての詳細は[KNT94]に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.1. The Kerberos Protocol",
      "section_title": true,
      "ja": "1.1.  Kerberosのプロトコル"
    },
    {
      "indent": 3,
      "text": "Kerberos provides a means of verifying the identities of principals, (e.g., a workstation user or a network server) on an open (unprotected) network. This is accomplished without relying on assertions by the host operating system, without basing trust on host addresses, without requiring physical security of all the hosts on the network, and under the assumption that packets traveling along the network can be read, modified, and inserted at will. Kerberos performs authentication under these conditions as a trusted third-party authentication service by using conventional (shared secret key) cryptography. Extensions to Kerberos (outside the scope of this document) can provide for the use of public key cryptography during certain phases of the authentication protocol. Such extensions support Kerberos authentication for users registered with public key certification authorities and provide certain benefits of public key cryptography in situations where they are needed.",
      "ja": "Kerberosは、オープン（非保護）ネットワーク上（例えば、ワークステーションのユーザまたはネットワークサーバ）、プリンシパルのアイデンティティを検証する手段を提供します。これは、ホストアドレスの信頼を基づかせず、ネットワーク上のすべてのホストの物理的なセキュリティを必要とせずに、ネットワークに沿って移動するパケット仮定の下で、ホスト・オペレーティング・システムによってアサーションに依存することなく達成される読み取ることができ、修飾、挿入します意のままに。 Kerberosは、従来の（共有秘密鍵）暗号方式を使用して、信頼されたサードパーティ認証サービスとして、これらの条件下で認証を行います。 （この文書の範囲外）ケルベロスに対する拡張認証プロトコルの特定の段階で、公開鍵暗号の使用を提供することができます。このような拡張は、公開鍵証明機関と登録ユーザーのためのKerberos認証をサポートし、それらが必要とされる状況では、公開鍵暗号方式の特定の利点を提供します。"
    },
    {
      "indent": 3,
      "text": "The basic Kerberos authentication process proceeds as follows: A client sends a request to the authentication server (AS) for \"credentials\" for a given server. The AS responds with these credentials, encrypted in the client's key. The credentials consist of a \"ticket\" for the server and a temporary encryption key (often called a \"session key\"). The client transmits the ticket (which contains the client's identity and a copy of the session key, all encrypted in the server's key) to the server. The session key (now shared by the client and server) is used to authenticate the client and may optionally be used to authenticate the server. It may also be used to encrypt further communication between the two parties or to exchange a separate sub-session key to be used to encrypt further communication. Note that many applications use Kerberos' functions only upon the initiation of a stream-based network connection. Unless an application performs encryption or integrity protection for the data stream, the identity verification applies only to the initiation of the connection, and it does not guarantee that subsequent messages on the connection originate from the same principal.",
      "ja": "次のように基本的なKerberos認証プロセスが進行します。クライアントは、特定のサーバーのための「資格証明書」の認証サーバ（AS）に要求を送信します。 ASは、クライアントの鍵で暗号化されたこれらの資格情報で応答します。資格情報は、サーバーと（多くの場合、「セッション・キー」と呼ばれる）の一時的な暗号化キーのための「チケット」で構成されています。クライアントは、サーバーへの（クライアントのIDとセッション鍵のコピー、サーバーの鍵で暗号化されたすべてを含む）チケットを送信します。 （今、クライアントとサーバで共有）セッションキーは、クライアントを認証するために使用され、必要に応じてサーバーを認証するために使用することができます。また、2つの当事者間でさらに通信を暗号化したり、さらに通信を暗号化するために使用される別々のサブセッション鍵を交換するために使用されてもよいです。多くのアプリケーションが唯一のストリームベースのネットワーク接続の開始時にケルベロス機能を使用することに注意してください。アプリケーションがデータ・ストリームのための暗号化または完全性保護を実行しない限り、本人確認は、接続の開始に適用され、そしてそれは、接続上の後続のメッセージは、同じ主体に由来することを保証するものではありません。"
    },
    {
      "indent": 3,
      "text": "Implementation of the basic protocol consists of one or more authentication servers running on physically secure hosts. The authentication servers maintain a database of principals (i.e., users and servers) and their secret keys. Code libraries provide encryption and implement the Kerberos protocol. In order to add authentication to its transactions, a typical network application adds calls to the Kerberos library directly or through the Generic Security Services Application Programming Interface (GSS-API) described in a separate document [RFC4121]. These calls result in the transmission of the messages necessary to achieve authentication.",
      "ja": "基本的なプロトコルの実装は、物理的に安全なホスト上で実行されている1つ以上の認証サーバーで構成されます。認証サーバは、プリンシパル（つまり、ユーザーとサーバー）とその秘密鍵のデータベースを維持します。コードライブラリは、暗号化を提供し、Kerberosプロトコルを実装します。その取引に認証を追加するためには、一般的なネットワークアプリケーションは、直接、または別の文書[RFC4121]で説明した一般的なセキュリティサービスアプリケーションプログラミングインターフェイス（GSS-API）を通じてKerberosライブラリへの呼び出しを追加します。これらの呼び出しは、認証を達成するために必要なメッセージの送信につながります。"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocol consists of several sub-protocols (or exchanges). There are two basic methods by which a client can ask a Kerberos server for credentials. In the first approach, the client sends a cleartext request for a ticket for the desired server to the AS. The reply is sent encrypted in the client's secret key. Usually this request is for a ticket-granting ticket (TGT), which can later be used with the ticket-granting server (TGS). In the second method, the client sends a request to the TGS. The client uses the TGT to authenticate itself to the TGS in the same manner as if it were contacting any other application server that requires Kerberos authentication. The reply is encrypted in the session key from the TGT. Though the protocol specification describes the AS and the TGS as separate servers, in practice they are implemented as different protocol entry points within a single Kerberos server.",
      "ja": "Kerberosプロトコルは、いくつかのサブプロトコル（または交換）で構成されています。クライアントは資格証明書のためのKerberosサーバーを依頼することが可能な2つの基本的な方法があります。最初のアプローチでは、クライアントはASに必要なサーバのチケットのためのクリアテキスト要求を送信します。応答は、クライアントの秘密鍵で暗号化されて送信されます。通常、この要求は、後にチケット認可サーバー（TGS）で使用できるチケット認可チケット（TGT）のためのものです。第二の方法では、クライアントはTGSに要求を送信します。クライアントはKerberos認証を必要とする他のアプリケーションサーバーに接続しているかのように同じようにTGSに自分自身を認証するためにTGTを使用しています。応答はTGTからのセッション鍵で暗号化されます。プロトコル仕様は、別々のサーバとしてASおよびTGSを説明しますが、実際にはそれらは単一のKerberosサーバ内の異なるプロトコルのエントリポイントとして実装されています。"
    },
    {
      "indent": 3,
      "text": "Once obtained, credentials may be used to verify the identity of the principals in a transaction, to ensure the integrity of messages exchanged between them, or to preserve privacy of the messages. The application is free to choose whatever protection may be necessary.",
      "ja": "一旦得られると、資格情報は、それらの間で交換されるメッセージの整合性を確保するために、またはメッセージのプライバシーを保護するために、トランザクション内のプリンシパルの身元を確認するために使用することができます。アプリケーションが必要な場合があり何でも保護自由に選択することができます。"
    },
    {
      "indent": 3,
      "text": "To verify the identities of the principals in a transaction, the client transmits the ticket to the application server. Because the ticket is sent \"in the clear\" (parts of it are encrypted, but this encryption doesn't thwart replay) and might be intercepted and reused by an attacker, additional information is sent to prove that the message originated with the principal to whom the ticket was issued. This information (called the authenticator) is encrypted in the session key and includes a timestamp. The timestamp proves that the message was recently generated and is not a replay. Encrypting the authenticator in the session key proves that it was generated by a party possessing the session key. Since no one except the requesting principal and the server know the session key (it is never sent over the network in the clear), this guarantees the identity of the client.",
      "ja": "トランザクション内のプリンシパルの身元を確認するために、クライアントは、アプリケーションサーバーへのチケットを送信します。チケットは「クリアに」送られているので（その一部が暗号化されているが、この暗号化はリプレイを阻止しない）と、攻撃者によって傍受して再利用される可能性があります、追加情報は、メッセージが校長にして発信していることを証明するために送信されます誰チケットが発行されました。 （オーセンティケータと呼ばれる）この情報は、セッション鍵で暗号化し、タイムスタンプを含んでいます。タイムスタンプは、メッセージが最近生成されたことを証明し、リプレイではありません。セッションキーでオーセンティケータを暗号化すると、それがセッションキーを持つ当事者によって生成されたことを証明しています。要求校長を除いて誰とサーバは（それが明確で、ネットワーク経由で送信されることはありません）、セッション鍵を知らないので、これはクライアントの身元を保証します。"
    },
    {
      "indent": 3,
      "text": "The integrity of the messages exchanged between principals can also be guaranteed by using the session key (passed in the ticket and contained in the credentials). This approach provides detection of both replay attacks and message stream modification attacks. It is accomplished by generating and transmitting a collision-proof checksum (elsewhere called a hash or digest function) of the client's message, keyed with the session key. Privacy and integrity of the messages exchanged between principals can be secured by encrypting the data to be passed by using the session key contained in the ticket or the sub-session key found in the authenticator.",
      "ja": "プリンシパル間で交換されるメッセージの整合性は、セッションキー（チケットに合格し、資格証明書に含まれる）を使用して保証することができます。このアプローチは、リプレイ攻撃とメッセージストリーム変更攻撃の両方の検出を提供します。これは、セッションキーでキー止めクライアントのメッセージの衝突防止チェックサムを（他の場所でハッシュと呼ばれる、または機能をダイジェスト）を生成して送信することによって達成されます。プライバシーとプリンシパル間で交換されるメッセージの完全性は、チケットまたはオーセンティケータで見つかったサブセッション・キーに含まれるセッションキーを使用して渡されるデータを暗号化することにより固定することができます。"
    },
    {
      "indent": 3,
      "text": "The authentication exchanges mentioned above require read-only access to the Kerberos database. Sometimes, however, the entries in the database must be modified, such as when adding new principals or changing a principal's key. This is done using a protocol between a client and a third Kerberos server, the Kerberos Administration Server (KADM). There is also a protocol for maintaining multiple copies of the Kerberos database. Neither of these protocols are described in this document.",
      "ja": "上記の認証交換は、Kerberosデータベースへの読み取り専用アクセスを必要とします。しかし、時には、データベース内のエントリは、このような新しいプリンシパルを追加したり、プリンシパルのキーを変更するときのように、変更する必要があります。これは、クライアントと第三Kerberosサーバ、Kerberos管理サーバ（KADM）との間のプロトコルを使用して行われます。 Kerberosデータベースの複数のコピーを維持するためのプロトコルでもあります。これらのプロトコルのどちらも、このドキュメントで説明されています。"
    },
    {
      "indent": 0,
      "text": "1.2. Cross-Realm Operation",
      "section_title": true,
      "ja": "1.2. クロスレルムオペレーション"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocol is designed to operate across organizational boundaries. A client in one organization can be authenticated to a server in another. Each organization wishing to run a Kerberos server establishes its own \"realm\". The name of the realm in which a client is registered is part of the client's name and can be used by the end-service to decide whether to honor a request.",
      "ja": "Kerberosプロトコルは組織の境界を越えて動作するように設計されています。 1つの組織内のクライアントが別の内のサーバーに認証することができます。 Kerberosサーバを実行したい各組織は、独自の「王国」を確立します。クライアントが登録されているレルムの名前は、クライアントの名前の一部であり、要求を尊重するかどうかを決定するために、エンド・サービスで使用することができます。"
    },
    {
      "indent": 3,
      "text": "By establishing \"inter-realm\" keys, the administrators of two realms can allow a client authenticated in the local realm to prove its identity to servers in other realms. The exchange of inter-realm keys (a separate key may be used for each direction) registers the ticket-granting service of each realm as a principal in the other realm. A client is then able to obtain a TGT for the remote realm's ticket-granting service from its local realm. When that TGT is used, the remote ticket-granting service uses the inter-realm key (which usually differs from its own normal TGS key) to decrypt the TGT; thus it is certain that the ticket was issued by the client's own TGS. Tickets issued by the remote ticket-granting service will indicate to the end-service that the client was authenticated from another realm.",
      "ja": "「レルム間」キーを確立することにより、2つのレルムの管理者がローカルレルムで認証クライアントが他のレルム内のサーバーにその身元を証明できるようにすることができます。レルム間キーの交換は、（別々のキーが各方向に使用することができる）他のレルムのプリンシパルとして各レルムのチケット許可サービスを登録します。次に、クライアントはそのローカル領域からリモートレルムのチケット認可サービス用のTGTを取得することができます。そのTGTを使用した場合、遠隔チケット許可サービスはTGTを復号化する（通常、独自の通常TGSキーと異なる）レルム間キーを使用します。したがって、チケットがクライアント自身のTGSによって発行されたことは確かです。リモートチケット認可サービスによって発行されたチケットは、クライアントが別の領域から認証されたエンド・サービスに指示します。"
    },
    {
      "indent": 3,
      "text": "Without cross-realm operation, and with appropriate permission, the client can arrange registration of a separately-named principal in a remote realm and engage in normal exchanges with that realm's services. However, for even small numbers of clients this becomes cumbersome, and more automatic methods as described here are necessary.",
      "ja": "クロスレルム操作がなければ、適切な許可を得て、クライアントがリモートの分野で個別に名前の元本の登録をアレンジすることができますし、そのレルムのサービスで、通常の交換に従事します。しかし、クライアントの小さな数字のためにこれが面倒になり、ここで説明したような、より自動的な方法が必要です。"
    },
    {
      "indent": 3,
      "text": "A realm is said to communicate with another realm if the two realms share an inter-realm key, or if the local realm shares an inter-realm key with an intermediate realm that communicates with the remote realm. An authentication path is the sequence of intermediate realms that are transited in communicating from one realm to another.",
      "ja": "レルムは、2つのレルムがインターレルム鍵を共有する場合、またはローカル領域は、リモート領域に連通する中間領域との間レルム鍵を共有する場合、他の領域と通信するように言われています。認証経路は、別の領域からの通信に遷移する中間レルムの配列です。"
    },
    {
      "indent": 3,
      "text": "Realms may be organized hierarchically. Each realm shares a key with its parent and a different key with each child. If an inter-realm key is not directly shared by two realms, the hierarchical organization allows an authentication path to be easily constructed.",
      "ja": "レルムは階層的に編成することができます。各レルムには、その親を持つキーとそれぞれの子と異なる鍵を共有しています。レルム間キーが直接2つのレルムによって共有されていない場合は、階層的な組織は、認証パスを容易に構築することを可能にします。"
    },
    {
      "indent": 3,
      "text": "If a hierarchical organization is not used, it may be necessary to consult a database in order to construct an authentication path between realms.",
      "ja": "階層構造を使用しない場合、レルム間の認証パスを構築するためにデータベースを参照する必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Although realms are typically hierarchical, intermediate realms may be bypassed to achieve cross-realm authentication through alternate authentication paths. (These might be established to make communication between two realms more efficient.) It is important for the end-service to know which realms were transited when deciding how much faith to place in the authentication process. To facilitate this decision, a field in each ticket contains the names of the realms that were involved in authenticating the client.",
      "ja": "レルムは、典型的には、階層的であるが、中間レルムは、代替の認証パスを介してクロスレルム認証を達成するためにバイパスすることができます。 （これらは、2つのレルム間の通信をより効率的にするために設立される可能性があります。）エンド・サービスは、認証プロセスに配置するどのくらいの信仰を決定する際に遷移されたレルムを知ることが重要です。この決定を容易にするために、各チケットのフィールドは、クライアントの認証に関与していたのレルムの名前が含まれています。"
    },
    {
      "indent": 3,
      "text": "The application server is ultimately responsible for accepting or rejecting authentication and SHOULD check the transited field. The application server may choose to rely on the Key Distribution Center (KDC) for the application server's realm to check the transited field. The application server's KDC will set the TRANSITED-POLICY-CHECKED flag in this case. The KDCs for intermediate realms may also check the transited field as they issue TGTs for other realms, but they are encouraged not to do so. A client may request that the KDCs not check the transited field by setting the DISABLE-TRANSITED-CHECK flag. KDCs SHOULD honor this flag.",
      "ja": "アプリケーションサーバは、認証を受け入れるか拒否するための最終的な責任であると通過している分野をチェックする必要があります。アプリケーションサーバは、通過している分野をチェックするために、アプリケーション・サーバーのレルムのキー配布センター（KDC）に依存することもできます。アプリケーションサーバのKDCは、この場合には遷移-POLICY-CHECKEDフラグを設定します。彼らは他のレルム用のTGTを発行すると、中間のレルムのKDCも通過している分野をチェックするかもしれないが、彼らはそうすることは推奨されません。クライアントは、KDCには、DISABLE-TRANSITED-CHECKフラグを設定することにより、通過している分野をチェックしないことを要求することができます。 KDCは、このフラグを尊重すべきです。"
    },
    {
      "indent": 0,
      "text": "1.3. Choosing a Principal with Which to Communicate",
      "section_title": true,
      "ja": "1.3. 通信することで校長を選びます"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocol provides the means for verifying (subject to the assumptions in Section 1.6) that the entity with which one communicates is the same entity that was registered with the KDC using the claimed identity (principal name). It is still necessary to determine whether that identity corresponds to the entity with which one intends to communicate.",
      "ja": "Kerberosプロトコルは、1つの通信するエンティティが主張する識別情報（プリンシパル名）を使用してKDCに登録されたのと同じエンティティであること（第1.6節で仮定に従う）を検証するための手段を提供します。そのアイデンティティは、一方が通信しようとしているエンティティに対応するかどうかを決定することが必要です。"
    },
    {
      "indent": 3,
      "text": "When appropriate data has been exchanged in advance, the application may perform this determination syntactically based on the application protocol specification, information provided by the user, and configuration files. For example, the server principal name (including realm) for a telnet server might be derived from the user-specified host name (from the telnet command line), the \"host/\" prefix specified in the application protocol specification, and a mapping to a Kerberos realm derived syntactically from the domain part of the specified hostname and information from the local Kerberos realms database.",
      "ja": "適切なデータを事前に交換された場合、アプリケーションは、構文的にアプリケーションプロトコル仕様、ユーザによって提供される情報、およびコンフィギュレーションファイルに基づいて、この決意を実行することができます。例えば、Telnetサーバ用のサーバ（レルムを含む）プリンシパル名（telnetコマンドラインから）ユーザが指定したホスト名に由来する可能性があり、アプリケーションプロトコル仕様で指定された「ホスト/」プレフィックス、およびマッピングKerberos領域は、ローカルケルベロスレルムデータベースから指定されたホスト名と情報のドメイン部分から文法的に誘導されます。"
    },
    {
      "indent": 3,
      "text": "One can also rely on trusted third parties to make this determination, but only when the data obtained from the third party is suitably integrity-protected while resident on the third-party server and when transmitted. Thus, for example, one should not rely on an unprotected DNS record to map a host alias to the primary name of a server, accepting the primary name as the party that one intends to contact, since an attacker can modify the mapping and impersonate the party.",
      "ja": "一つは、また、この決意をするために、信頼できる第三者機関に頼ることができますが、サードパーティのサーバーに常駐してたときには、送信しながら、第三者から得られたデータは、適切に整合性で保護されている場合のみです。したがって、例えば、1は、攻撃者がマッピングを変更して偽装することができるので、1が接触するつもり当事者としてプライマリ名を受け入れ、サーバーのプライマリ名にホストエイリアスをマップするために保護されていないDNSレコードに頼るべきではありませんパーティー。"
    },
    {
      "indent": 3,
      "text": "Implementations of Kerberos and protocols based on Kerberos MUST NOT use insecure DNS queries to canonicalize the hostname components of the service principal names (i.e., they MUST NOT use insecure DNS queries to map one name to another to determine the host part of the principal name with which one is to communicate). In an environment without secure name service, application authors MAY append a statically configured domain name to unqualified hostnames before passing the name to the security mechanisms, but they should do no more than that. Secure name service facilities, if available, might be trusted for hostname canonicalization, but such canonicalization by the client SHOULD NOT be required by KDC implementations.",
      "ja": "ケルベロスに基づくKerberosとプロトコルの実装は、サービスプリンシパル名（つまり、彼らはプリンシパル名でのホスト部分を決定するために別の名前をマップするために安全でないDNSクエリを使用してはならないのホスト名コンポーネントを正規化するために、安全でないDNSクエリを使用してはなりませんどちらが通信することです）。安全なネームサービスのない環境では、アプリケーションの作成者は、セキュリティ・メカニズムに名前を渡す前に、資格のないホスト名に静的に設定されたドメイン名を追加するかもしれないが、彼らはそれよりも多くを行うべきではありません。セキュアネームサービス施設は、利用可能な場合、ホスト名の正規化のために、信頼される可能性がありますが、クライアントによって、このような正規化は、KDCの実装によって要求されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Many current implementations do some degree of canonicalization of the provided service name, often using DNS even though it creates security problems. However, there is no consistency among implementations as to whether the service name is case folded to lowercase or whether reverse resolution is used. To maximize interoperability and security, applications SHOULD provide security mechanisms with names that result from folding the user-entered name to lowercase without performing any other modifications or canonicalization.",
      "ja": "実装上の注意：多くの現在の実装では、多くの場合、それはセキュリティ上の問題を作成するにもかかわらず、DNSを使用して、提供されるサービス名の正規化をある程度行います。しかし、サービス名は小文字にまたは逆解像度が使用されているかどうかに折り畳まれた場合であるか否かの実装間には一貫性がありません。相互運用性とセキュリティを最大限にするために、アプリケーションは、他の修正や正規化を行うことなく、小文字にユーザーが入力した名前を折りたたみに起因名前でセキュリティメカニズムを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "1.4. Authorization",
      "section_title": true,
      "ja": "1.4. 認定"
    },
    {
      "indent": 3,
      "text": "As an authentication service, Kerberos provides a means of verifying the identity of principals on a network. Authentication is usually useful primarily as a first step in the process of authorization, determining whether a client may use a service, which objects the client is allowed to access, and the type of access allowed for each. Kerberos does not, by itself, provide authorization. Possession of a client ticket for a service provides only for authentication of the client to that service, and in the absence of a separate authorization procedure, an application should not consider it to authorize the use of that service.",
      "ja": "認証サービスとして、Kerberosは、ネットワーク上のプリンシパルの身元を確認する手段を提供します。認証は、クライアントは、クライアントがアクセスを許可されているオブジェクトサービス、およびそれぞれに許可されるアクセスのタイプを使用することができるかどうかを決定する、主に認可のプロセスの最初のステップとして通常有用です。 Kerberosは、それ自体で、承認を提供していません。サービスのクライアントチケットの所持だけで、そのサービスに対するクライアントの認証を提供し、個別の承認手続きが存在しない場合に、アプリケーションがそのサービスの利用を許可することを検討するべきではありません。"
    },
    {
      "indent": 3,
      "text": "Separate authorization methods MAY be implemented as application-specific access control functions and may utilize files on the application server, on separately issued authorization credentials such as those based on proxies [Neu93], or on other authorization services. Separately authenticated authorization credentials MAY be embedded in a ticket's authorization data when encapsulated by the KDC-issued authorization data element.",
      "ja": "別々の認証方法は、アプリケーション固有のアクセス制御機能として実装することができ、このようなプロキシ[Neu93]、または他の認証サービス上に基づくものとして、別途発行承認資格情報、アプリケーションサーバ上のファイルを利用することができます。 KDCが発行した認証データ要素によってカプセル化された際に別途、認証、認可の資格情報は、チケットの許可データに埋め込まれていてもよいです。"
    },
    {
      "indent": 3,
      "text": "Applications should not accept the mere issuance of a service ticket by the Kerberos server (even by a modified Kerberos server) as granting authority to use the service, since such applications may become vulnerable to the bypass of this authorization check in an environment where other options for application authentication are provided, or if they interoperate with other KDCs.",
      "ja": "このようなアプリケーションがどこ他のオプション環境でこの承認チェックのバイパスに対して脆弱になる可能性があるためアプリケーションは、サービスを使用する権限を付与すると（でも修正Kerberosサーバーによって）Kerberosサーバによるサービスチケットの単なる発行を受け入れるべきではありませんアプリケーション認証のために提供されている、またはそれらを他のKDCと相互運用ます。"
    },
    {
      "indent": 0,
      "text": "1.5. Extending Kerberos without Breaking Interoperability",
      "section_title": true,
      "ja": "1.5. 相互運用性を壊すことなくKerberosを拡張"
    },
    {
      "indent": 3,
      "text": "As the deployed base of Kerberos implementations grows, extending Kerberos becomes more important. Unfortunately, some extensions to the existing Kerberos protocol create interoperability issues because of uncertainty regarding the treatment of certain extensibility options by some implementations. This section includes guidelines that will enable future implementations to maintain interoperability.",
      "ja": "Kerberos実装の展開ベースが成長するにつれて、Kerberosを拡張することがより重要になってきます。残念ながら、既存のKerberosプロトコルにはいくつかの拡張機能は、いくつかの実装により、特定の拡張オプションの治療に関するので、不確実性の相互運用性の問題を作成します。このセクションでは、相互運用性を維持するために、将来の実装を可能にするガイドラインを含んでいます。"
    },
    {
      "indent": 3,
      "text": "Kerberos provides a general mechanism for protocol extensibility. Some protocol messages contain typed holes -- sub-messages that contain an octet-string along with an integer that defines how to interpret the octet-string. The integer types are registered centrally, but they can be used both for vendor extensions and for extensions standardized through the IETF.",
      "ja": "ケルベロスプロトコルの拡張のための一般的な機構を提供します。オクテット文字列を解釈する方法を定義する整数と一緒にオクテット文字列を含むサブメッセージ - いくつかのプロトコルメッセージは、入力された穴を含んでいます。整数型は、中央登録されているが、それらはベンダー拡張およびIETFによって標準化拡張機能の両方に使用することができます。"
    },
    {
      "indent": 3,
      "text": "In this document, the word \"extension\" refers to extension by defining a new type to insert into an existing typed hole in a protocol message. It does not refer to extension by addition of new fields to ASN.1 types, unless the text explicitly indicates otherwise.",
      "ja": "この文書では、用語「拡張」は、プロトコルメッセージ内の既存の型付き穴に挿入する新しいタイプを定義することによって、拡張を指します。テキストが明示的に示さない限りそれは、ASN.1タイプに新しいフィールドの追加によって拡張を参照していません。"
    },
    {
      "indent": 0,
      "text": "1.5.1. Compatibility with ",
      "section_title": true,
      "ja": "1.5.1. との互換性"
    },
    {
      "indent": 3,
      "text": "Note that existing Kerberos message formats cannot readily be extended by adding fields to the ASN.1 types. Sending additional fields often results in the entire message being discarded without an error indication. Future versions of this specification will provide guidelines to ensure that ASN.1 fields can be added without creating an interoperability problem.",
      "ja": "既存のケルベロスメッセージフォーマットは容易にASN.1タイプにフィールドを追加することによって拡張することができないことに留意されたいです。追加のフィールドを送信すると、多くの場合、エラー表示なしに廃棄されるメッセージ全体をもたらします。この仕様の将来のバージョンでは、ASN.1フィールドは相互運用性の問題を作成することなく追加することができることを確保するためのガイドラインを提供します。"
    },
    {
      "indent": 3,
      "text": "In the meantime, all new or modified implementations of Kerberos that receive an unknown message extension SHOULD preserve the encoding of the extension but otherwise ignore its presence. Recipients MUST NOT decline a request simply because an extension is present.",
      "ja": "一方、未知のメッセージ拡張を受信ケルベロスのすべての新規または変更された実装では、拡張の符号化を維持するが、そうでなければ、その存在を無視すべきです。受信者は、拡張子が存在しているという理由だけで、要求を拒否してはなりません。"
    },
    {
      "indent": 3,
      "text": "There is one exception to this rule. If an unknown authorization data element type is received by a server other than the ticket-granting service either in an AP-REQ or in a ticket contained in an AP-REQ, then authentication MUST fail. One of the primary uses of authorization data is to restrict the use of the ticket. If the service cannot determine whether the restriction applies to that service, then a security weakness may result if the ticket can be used for that service. Authorization elements that are optional SHOULD be enclosed in the AD-IF-RELEVANT element.",
      "ja": "この規則には例外が1つあります。未知の承認データ要素のタイプはAP-REQまたはAP-REQに含まれているチケットのいずれかでチケット認可サービス以外のサーバーによって受信された場合には、認証が失敗しなければなりません。認証データの主な用途の1つは、チケットの使用を制限することです。サービスは制限がそのサービスに適用されるかどうか判断できない場合、チケットはそのサービスのために使用することができる場合は、セキュリティ上の弱点となることがあります。オプションで承認要素はAD-IF-関連要素で囲む必要があります。"
    },
    {
      "indent": 3,
      "text": "The ticket-granting service MUST ignore but propagate to derivative tickets any unknown authorization data types, unless those data types are embedded in a MANDATORY-FOR-KDC element, in which case the request will be rejected. This behavior is appropriate because requiring that the ticket-granting service understand unknown authorization data types would require that KDC software be upgraded to understand new application-level restrictions before applications used these restrictions, decreasing the utility of authorization data as a mechanism for restricting the use of tickets. No security problem is created because services to which the tickets are issued will verify the authorization data.",
      "ja": "これらのデータ型は、要求が拒否される場合にはMANDATORY-FOR-KDC要素、中に埋め込まれている場合を除き、チケット認可サービスは、未知の承認データ型を無視するが、派生チケットに伝搬しなければなりません。使用を制限するためのメカニズムとして認証データの有用性を減少させ、チケット認可サービスはKDCソフトウェアは、アプリケーションがこれらの制限を使用する前に、新しいアプリケーションレベルの制限を理解するためにアップグレードすることを必要とするであろう未知の承認データのタイプを理解することを要求するので、この動作は適切ですチケットの。チケットが発行されたサービスは、認証データを検証しますので、何のセキュリティ上の問題は作成されません。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Many RFC 1510 implementations ignore unknown authorization data elements. Depending on these implementations to honor authorization data restrictions may create a security weakness.",
      "ja": "実装上の注意：多くのRFC 1510枚の実装は、未知の承認データ要素を無視します。認証データの制限を尊重するために、これらの実装によってはセキュリティ上の弱点を作成することができます。"
    },
    {
      "indent": 0,
      "text": "1.5.2. Sending Extensible Messages",
      "section_title": true,
      "ja": "1.5.2. 拡張可能なメッセージの送信"
    },
    {
      "indent": 3,
      "text": "Care must be taken to ensure that old implementations can understand messages sent to them, even if they do not understand an extension that is used. Unless the sender knows that an extension is supported, the extension cannot change the semantics of the core message or previously defined extensions.",
      "ja": "ケアは、古い実装では、彼らが使用されている拡張子を理解していない場合でも、それらに送信されたメッセージを理解できるように注意する必要があります。送信者は拡張機能がサポートされていることを知っている場合を除き、拡張子がコアメッセージの意味や、以前に定義された拡張子を変更することはできません。"
    },
    {
      "indent": 3,
      "text": "For example, an extension including key information necessary to decrypt the encrypted part of a KDC-REP could only be used in situations where the recipient was known to support the extension. Thus when designing such extensions it is important to provide a way for the recipient to notify the sender of support for the extension. For example in the case of an extension that changes the KDC-REP reply key, the client could indicate support for the extension by including a padata element in the AS-REQ sequence. The KDC should only use the extension if this padata element is present in the AS-REQ. Even if policy requires the use of the extension, it is better to return an error indicating that the extension is required than to use the extension when the recipient may not support it. Debugging implementations that do not interoperate is easier when errors are returned.",
      "ja": "例えば、KDC-REPの暗号化部分を解読するために必要な鍵情報を含む拡張は、受信者が拡張をサポートするために知られていた状況で使用することができます。そのような拡張を設計するときしたがって、受信者が拡張のサポートの送信者に通知する方法を提供することが重要です。例えばKDC-REPキー返信変化拡張の場合には、クライアントは、AS-REQ配列中PADATA要素を含むことによって拡張のサポートを示すことができます。このPADATA要素は、AS-REQに存在する場合、KDCは、拡張子のみを使用する必要があります。ポリシーは、拡張子を使用する必要がある場合であっても、拡張子が、受信者がそれをサポートしていない可能性際に拡張子を使用するよりも必要であることを示すエラーを返すことをお勧めします。エラーが返されたときに相互運用できませんデバッグの実装が容易です。"
    },
    {
      "indent": 0,
      "text": "1.6. Environmental Assumptions",
      "section_title": true,
      "ja": "1.6. 環境仮定"
    },
    {
      "indent": 3,
      "text": "Kerberos imposes a few assumptions on the environment in which it can properly function, including the following:",
      "ja": "Kerberosは、以下を含む、それが適切に機能できる環境には、いくつかの仮定を課します："
    },
    {
      "indent": 3,
      "text": "* \"Denial of service\" attacks are not solved with Kerberos. There are places in the protocols where an intruder can prevent an application from participating in the proper authentication steps. Detection and solution of such attacks (some of which can appear to be not-uncommon \"normal\" failure modes for the system) are usually best left to the human administrators and users.",
      "ja": "*「サービス拒否」攻撃はケルベロスで解決されていません。侵入者が適切な認証手順に参加するアプリケーションを防ぐことができますプロトコルでの場所があります。 （システム用-は珍しくない「通常の」故障モードのように見えることができますいくつかは）このような攻撃の検出と解決策は、通常、最高の人間の管理者とユーザーに委ねられています。"
    },
    {
      "indent": 3,
      "text": "* Principals MUST keep their secret keys secret. If an intruder somehow steals a principal's key, it will be able to masquerade as that principal or to impersonate any server to the legitimate principal.",
      "ja": "*プリンシパルは秘密自分の秘密鍵を保持しなければなりません。侵入者がどうにかプリンシパルの鍵を盗んだ場合は、その元本のふりをしたり、正当な主体に任意のサーバを偽装することができるようになります。"
    },
    {
      "indent": 3,
      "text": "* \"Password guessing\" attacks are not solved by Kerberos. If a user chooses a poor password, it is possible for an attacker to successfully mount an offline dictionary attack by repeatedly attempting to decrypt, with successive entries from a dictionary, messages obtained which are encrypted under a key derived from the user's password.",
      "ja": "*「パスワード推測」攻撃はケルベロスによって解決されていません。ユーザーが悪いパスワードを選択した場合、攻撃者が繰り返しユーザーのパスワード由来の鍵で暗号化されている辞書からの連続したエントリ、取得したメッセージと、解読しようとすることにより、オフライン辞書攻撃をマウントすることが可能です。"
    },
    {
      "indent": 3,
      "text": "* Each host on the network MUST have a clock which is \"loosely synchronized\" to the time of the other hosts; this synchronization is used to reduce the bookkeeping needs of application servers when they do replay detection. The degree of \"looseness\" can be configured on a per-server basis, but it is typically on the order of 5 minutes. If the clocks are synchronized over the network, the clock synchronization protocol MUST itself be secured from network attackers.",
      "ja": "*ネットワーク上の各ホストは他のホストの時に「緩やかに同期化」されたクロックを持たなければなりません。この同期は、彼らがリプレイ検出を行う際に、アプリケーションサーバーの簿記の必要性を低減するために使用されます。 「ゆるみ」の程度は、サーバ単位で設定することができますが、それは5分程度であるのが典型的です。クロックがネットワーク経由で同期されている場合は、クロック同期プロトコル自体は、ネットワーク攻撃から保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Principal identifiers are not recycled on a short-term basis. A typical mode of access control will use access control lists (ACLs) to grant permissions to particular principals. If a stale ACL entry remains for a deleted principal and the principal identifier is reused, the new principal will inherit rights specified in the stale ACL entry. By not re-using principal identifiers, the danger of inadvertent access is removed.",
      "ja": "*主な識別子は短期的にリサイクルされていません。アクセス制御の典型的なモードは、特定のプリンシパルに権限を付与するアクセス制御リスト（ACL）を使用します。古くなったACLエントリが削除されたプリンシパルのままで、主要な識別子が再利用されている場合は、新しいプリンシパルは、古いACLエントリで指定された権限を継承します。主要な識別子を再使用しないことにより、不用意なアクセスの危険性が取り除かれます。"
    },
    {
      "indent": 0,
      "text": "1.7. Glossary of Terms",
      "section_title": true,
      "ja": "1.7. 用語集"
    },
    {
      "indent": 3,
      "text": "Below is a list of terms used throughout this document.",
      "ja": "以下は、この文書全体で使用される用語のリストです。"
    },
    {
      "indent": 3,
      "text": "Authentication Verifying the claimed identity of a principal.",
      "ja": "校長の主張身元の確認認証。"
    },
    {
      "indent": 3,
      "text": "Authentication header A record containing a Ticket and an Authenticator to be presented to a server as part of the authentication process.",
      "ja": "認証ヘッダは、チケットと認証を含むレコードは、認証プロセスの一部としてサーバーに提示します。"
    },
    {
      "indent": 3,
      "text": "Authentication path A sequence of intermediate realms transited in the authentication process when communicating from one realm to another.",
      "ja": "認証パス別の領域からの通信時の認証プロセスに遷移中間レルムの配列。"
    },
    {
      "indent": 3,
      "text": "Authenticator A record containing information that can be shown to have been recently generated using the session key known only by the client and server.",
      "ja": "最近、クライアントとサーバによってのみ知られているセッションキーを使用して生成されていることを示すことができる情報を含むレコードをオーセンティケータ。"
    },
    {
      "indent": 3,
      "text": "Authorization The process of determining whether a client may use a service, which objects the client is allowed to access, and the type of access allowed for each.",
      "ja": "許可クライアントは、クライアントがアクセスを許可されているオブジェクトサービス、およびそれぞれに許可されるアクセスのタイプを使用することができるかどうかを決定するプロセス。"
    },
    {
      "indent": 3,
      "text": "Capability A token that grants the bearer permission to access an object or service. In Kerberos, this might be a ticket whose use is restricted by the contents of the authorization data field, but which lists no network addresses, together with the session key necessary to use the ticket.",
      "ja": "機能オブジェクトやサービスにアクセスするためのベアラ許可を与えるトークン。ケルベロスでは、これはその使用許可データフィールドの内容によって制限されているチケットをかもしれませんが、一緒にチケットを使用するために必要なセッションキーで、何のネットワークアドレスをリストしないいます。"
    },
    {
      "indent": 3,
      "text": "Ciphertext The output of an encryption function. Encryption transforms plaintext into ciphertext.",
      "ja": "暗号化機能の出力を暗号文。暗号化は、平文を暗号文に変換します。"
    },
    {
      "indent": 3,
      "text": "Client A process that makes use of a network service on behalf of a user. Note that in some cases a Server may itself be a client of some other server (e.g., a print server may be a client of a file server).",
      "ja": "ユーザーの代わりにネットワークサービスを使用するクライアントのプロセス。いくつかのケースではサーバー自体は、いくつかの他のサーバのクライアントであってもよいことに注意してください（例えば、プリントサーバは、ファイルサーバのクライアントでもよいです）。"
    },
    {
      "indent": 3,
      "text": "Credentials A ticket plus the secret session key necessary to use that ticket successfully in an authentication exchange.",
      "ja": "資格のチケットプラス認証交換に成功し、そのチケットを使用するために必要な秘密のセッション鍵。"
    },
    {
      "indent": 3,
      "text": "Encryption Type (etype) When associated with encrypted data, an encryption type identifies the algorithm used to encrypt the data and is used to select the appropriate algorithm for decrypting the data. Encryption type tags are communicated in other messages to enumerate algorithms that are desired, supported, preferred, or allowed to be used for encryption of data between parties. This preference is combined with local information and policy to select an algorithm to be used.",
      "ja": "暗号化されたデータに関連付けられている暗号化の種類（ETYPE）は、暗号化タイプは、データを暗号化するために使用されるアルゴリズムを識別し、データを復号化するための適切なアルゴリズムを選択するために使用されます。暗号化タイプのタグは、所望のサポートされている、好ましい、又は当事者間のデータの暗号化に使用することが許可されているアルゴリズムを列挙するために他のメッセージで通信されます。この設定は、使用するアルゴリズムを選択するために、ローカル情報とポリシーと組み合わされます。"
    },
    {
      "indent": 3,
      "text": "KDC Key Distribution Center. A network service that supplies tickets and temporary session keys; or an instance of that service or the host on which it runs. The KDC services both initial ticket and ticket-granting ticket requests. The initial ticket portion is sometimes referred to as the Authentication Server (or service). The ticket-granting ticket portion is sometimes referred to as the ticket-granting server (or service).",
      "ja": "KDCキー配布センター。チケットと一時セッション鍵を提供するネットワークサービス。またはそのサービスのインスタンスまたはそれが実行されているホスト。 KDCサービスの両方初期チケットとチケット認可チケット要求。初期チケット部分は時々、認証サーバ（またはサービス）と呼ばれます。チケット認可チケット部分は時々チケット認可サーバ（またはサービス）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Kerberos The name given to the Project Athena's authentication service, the protocol used by that service, or the code used to implement the authentication service. The name is adopted from the three-headed dog that guards Hades.",
      "ja": "KerberosのAthenaプロジェクトの認証サービスは、そのサービスが使用するプロトコル、または認証サービスを実装するために使用されるコードに与えられた名前。名前はハーデスを守る3つの頭の犬から採用されています。"
    },
    {
      "indent": 3,
      "text": "Key Version Number (kvno) A tag associated with encrypted data identifies which key was used for encryption when a long-lived key associated with a principal changes over time. It is used during the transition to a new key so that the party decrypting a message can tell whether the data was encrypted with the old or the new key.",
      "ja": "鍵のバージョン番号（KVNO）キーは暗号化に使用された暗号化されたデータの識別に関連するタグ際に時間をかけて主な変更点に関連した長寿命のキー。メッセージを復号化する当事者は、データが古いか新しいキーで暗号化されたかどうかを伝えることができるようにそれは、新しいキーへの移行の際に使用されます。"
    },
    {
      "indent": 3,
      "text": "Plaintext The input to an encryption function or the output of a decryption function. Decryption transforms ciphertext into plaintext.",
      "ja": "暗号化機能または復号化機能の入力を出力に平文。復号化は、暗号文を平文に変換します。"
    },
    {
      "indent": 3,
      "text": "Principal A named client or server entity that participates in a network communication, with one name that is considered canonical.",
      "ja": "標準的な考えられている一つの名前で、ネットワーク通信に参加校長という名前のクライアントまたはサーバエンティティ。"
    },
    {
      "indent": 3,
      "text": "Principal identifier The canonical name used to identify each different principal uniquely.",
      "ja": "プリンシパル識別子一意異なるプリンシパルを識別するために使用される正規名。"
    },
    {
      "indent": 3,
      "text": "Seal To encipher a record containing several fields in such a way that the fields cannot be individually replaced without knowledge of the encryption key or leaving evidence of tampering.",
      "ja": "フィールドが個別に暗号化キーの知識や改ざんの証拠を残さずに交換することができないように、いくつかのフィールドを含むレコードを暗号化するにはシール。"
    },
    {
      "indent": 3,
      "text": "Secret key An encryption key shared by a principal and the KDC, distributed outside the bounds of the system, with a long lifetime. In the case of a human user's principal, the secret key MAY be derived from a password.",
      "ja": "長寿命で、システムの境界の外側に分散プリンシパルとKDCによって共有された秘密鍵暗号化キー、。人間のユーザのプリンシパルの場合、秘密鍵はパスワードから導出することができます。"
    },
    {
      "indent": 3,
      "text": "Server A particular Principal that provides a resource to network clients. The server is sometimes referred to as the Application Server.",
      "ja": "サーバーネットワーククライアントにリソースを提供し、特定の校長。サーバーは時々アプリケーションサーバと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Service A resource provided to network clients; often provided by more than one server (for example, remote file service).",
      "ja": "サービスネットワーククライアントに提供するリソース。多くの場合、複数のサーバ（例えば、リモートファイルサービス）で提供。"
    },
    {
      "indent": 3,
      "text": "Session key A temporary encryption key used between two principals, with a lifetime limited to the duration of a single login \"session\". In the Kerberos system, a session key is generated by the KDC. The session key is distinct from the sub-session key, described next.",
      "ja": "セッションキー単一のログイン「セッション」の期間に限定寿命を持つ2つの主体間で使用される一時的な暗号化キー、。 Kerberosシステムでは、セッションキーは、KDCによって生成されます。セッション鍵は、次に説明するサブセッション鍵、区別されます。"
    },
    {
      "indent": 3,
      "text": "Sub-session key A temporary encryption key used between two principals, selected and exchanged by the principals using the session key, and with a lifetime limited to the duration of a single association. The sub-session key is also referred to as the subkey.",
      "ja": "サブセッション鍵A一時的な暗号化キーは、2つの主体との間で使用されるセッション鍵を使用してプリンシパルによって選択され、交換、及び単一アソシエーションの期間に限られた寿命を有します。サブセッション鍵もサブキーと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Ticket A record that helps a client authenticate itself to a server; it contains the client's identity, a session key, a timestamp, and other information, all sealed using the server's secret key. It only serves to authenticate a client when presented along with a fresh Authenticator.",
      "ja": "クライアントがサーバーに対して自身を認証できますチケットAレコード。それは、クライアントのID、セッションキー、タイムスタンプ、およびその他の情報については、すべてのサーバーの秘密鍵を使用してシールが含まれています。それだけで新鮮なオーセンティケータと一緒に提示されたときに、クライアントを認証するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "2. Ticket Flag Uses and Requests",
      "section_title": true,
      "ja": "2.チケット旗の用途および要求"
    },
    {
      "indent": 3,
      "text": "Each Kerberos ticket contains a set of flags that are used to indicate attributes of that ticket. Most flags may be requested by a client when the ticket is obtained; some are automatically turned on and off by a Kerberos server as required. The following sections explain what the various flags mean and give examples of reasons to use them. With the exception of the INVALID flag, clients MUST ignore ticket flags that are not recognized. KDCs MUST ignore KDC options that are not recognized. Some implementations of RFC 1510 are known to reject unknown KDC options, so clients may need to resend a request without new KDC options if the request was rejected when sent with options added since RFC 1510. Because new KDCs will ignore unknown options, clients MUST confirm that the ticket returned by the KDC meets their needs.",
      "ja": "各Kerberosチケットは、そのチケットの属性を示すために使用されているフラグのセットを含みます。チケットが得られた場合、ほとんどのフラグは、クライアントによって要求することができます。必要に応じて、いくつかは、自動的にKerberosサーバによってオン・オフされます。次のセクションでは、さまざまなフラグが何を意味するかを説明し、それらを使用する理由の例を与えます。 INVALID旗を除いて、クライアントが認識されないチケットフラグを無視しなければなりません。 KDCが認識されないKDCオプションを無視しなければなりません。 RFC 1510以降に追加されたオプションを使用して送信されたときに、要求が拒否された場合、新しいのKDCは、未知のオプションを無視しますので、クライアントが新しいKDCのオプションを指定せずに要求を再送信する必要があるかもしれませんので、RFC 1510の一部の実装では、未知のKDCオプションを拒否することが知られている、クライアントが確認する必要がありますKDCによって返されたチケットは、彼らのニーズを満たしていること。"
    },
    {
      "indent": 3,
      "text": "Note that it is not, in general, possible to determine whether an option was not honored because it was not understood or because it was rejected through either configuration or policy. When adding a new option to the Kerberos protocol, designers should consider whether the distinction is important for their option. If it is, a mechanism for the KDC to return an indication that the option was understood but rejected needs to be provided in the specification of the option. Often in such cases, the mechanism needs to be broad enough to permit an error or reason to be returned.",
      "ja": "理解されていなかったため、オプションが無視されたかどうかを決定するために、一般的に、不可能であることに留意されたいか、構成またはポリシーのいずれかを介して拒否されたためです。 Kerberosプロトコルに新しいオプションを追加する場合、設計者は区別が彼らのオプションのために重要であるかどうかを検討すべきです。それがある場合は、KDCのためのメカニズムはオプションでは理解したが、オプションの仕様で提供される必要が拒否されたという指示を戻します。多くの場合、このような場合には、メカニズムが返されるエラーや理由を可能にするのに十分に広くする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.1. Initial, Pre-authenticated, and Hardware-Authenticated Tickets",
      "section_title": true,
      "ja": "2.1.  、初期の事前認証、およびハードウェア認証チケット"
    },
    {
      "indent": 3,
      "text": "The INITIAL flag indicates that a ticket was issued using the AS protocol, rather than issued based on a TGT. Application servers that want to require the demonstrated knowledge of a client's secret key (e.g., a password-changing program) can insist that this flag be set in any tickets they accept, and can thus be assured that the client's key was recently presented to the authentication server.",
      "ja": "INITIAL旗がTGTに基づいて発行されるのではなく、チケットはASプロトコルを使用して発行されたことを示しています。クライアントの秘密鍵（例えば、パスワード変更プログラム）の実証された知識を必要とするアプリケーション・サーバーは、このフラグは、彼らが受け入れるどんなチケットに設定することを主張することができ、これにより、クライアントのキーが最近に提示されたことを保証することができます認証サーバ。"
    },
    {
      "indent": 3,
      "text": "The PRE-AUTHENT and HW-AUTHENT flags provide additional information about the initial authentication, regardless of whether the current ticket was issued directly (in which case INITIAL will also be set) or issued on the basis of a TGT (in which case the INITIAL flag is clear, but the PRE-AUTHENT and HW-AUTHENT flags are carried forward from the TGT).",
      "ja": "PRE-AUTHENTとHW-AUTHENTフラグは関係なく、現在のチケットが直接発行（ケースINITIALも設定されている）またはTGT（場合の初期に基づいて発行されたかどうかの、初期認証に関する追加情報を提供しますフラグ）は明らかであるが、PRE-AUTHENTとHW-AUTHENTフラグはTGTから繰り越されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Invalid Tickets",
      "section_title": true,
      "ja": "2.2. 無効なチケット"
    },
    {
      "indent": 3,
      "text": "The INVALID flag indicates that a ticket is invalid. Application servers MUST reject tickets that have this flag set. A postdated ticket will be issued in this form. Invalid tickets MUST be validated by the KDC before use, by being presented to the KDC in a TGS request with the VALIDATE option specified. The KDC will only validate tickets after their starttime has passed. The validation is required so that postdated tickets that have been stolen before their starttime can be rendered permanently invalid (through a hot-list mechanism) (see Section 3.3.3.1).",
      "ja": "INVALID旗は、チケットが無効であることを示しています。アプリケーションサーバーは、このフラグが設定されているチケットを拒絶しなければなりません。遅延チケットは、このフォームで発行されます。無効チケットは、指定されたVALIDATEオプションを使用してTGS要求でKDCに提示されることにより、使用前にKDCによって検証されなければなりません。そのSTARTTIMEが経過した後にKDCはチケットを検証します。そのSTARTTIMEは、（ホットリスト機構を介して）恒久的に無効とすることができます前に盗まれた遅延チケット（セクション3.3.3.1を参照）ように、検証が必要です。"
    },
    {
      "indent": 0,
      "text": "2.3. Renewable Tickets",
      "section_title": true,
      "ja": "2.3. 再生可能チケット"
    },
    {
      "indent": 3,
      "text": "Applications may desire to hold tickets that can be valid for long periods of time. However, this can expose their credentials to potential theft for equally long periods, and those stolen credentials would be valid until the expiration time of the ticket(s). Simply using short-lived tickets and obtaining new ones periodically would require the client to have long-term access to its secret key, an even greater risk. Renewable tickets can be used to mitigate the consequences of theft. Renewable tickets have two \"expiration times\": the first is when the current instance of the ticket expires, and the second is the latest permissible value for an individual expiration time. An application client must periodically (i.e., before it expires) present a renewable ticket to the KDC, with the RENEW option set in the KDC request. The KDC will issue a new ticket with a new session key and a later expiration time. All other fields of the ticket are left unmodified by the renewal process. When the latest permissible expiration time arrives, the ticket expires permanently. At each renewal, the KDC MAY consult a hot-list to determine whether the ticket had been reported stolen since its last renewal; it will refuse to renew stolen tickets, and thus the usable lifetime of stolen tickets is reduced.",
      "ja": "アプリケーションは、長い期間のために有効であることができ、チケットを保持することを望むかもしれません。しかし、これは同様に長期間の可能性盗難に資格情報を公開することができ、それらの盗まれた資格情報は、チケット（S）の有効期限まで有効となります。単純に短命のチケットを使用して、その秘密鍵、さらに大きなリスクへの長期的なアクセス権を持っているクライアントが必要になり、定期的に新しいものを得ました。再生可能なチケットは盗難の影響を緩和するために使用することができます。再生可能なチケットは二つの「有効期限」を持っている：チケットの現在のインスタンスの有効期限が切れたときに最初にあり、第二は、個々の有効期限の最新の許容値です。アプリケーションクライアントは、定期的に（すなわち、有効期限が切れる前）KDC要求に設定RENEWオプションを使用して、KDCに再生可能なチケットを提示する必要があります。 KDCは新しいセッションキーと後で有効期限を使用して新しいチケットを発行します。チケットの他のすべてのフィールドは、更新プロセスによってそのまま残されています。最新の許容有効期限が到来すると、チケットが永続的に有効期限が切れます。各リニューアルでは、KDCは、チケットが最後の更新以来、盗まれたと報告されていたかどうかを判断するためのホットリストを調べることができます。それが盗まれたチケットを更新することを拒否されますので、盗まれたチケットの使用可能な寿命が低下しています。"
    },
    {
      "indent": 3,
      "text": "The RENEWABLE flag in a ticket is normally only interpreted by the ticket-granting service (discussed below in Section 3.3). It can usually be ignored by application servers. However, some particularly careful application servers MAY disallow renewable tickets.",
      "ja": "チケットにおける再生可能フラグは、通常のみ（3.3節で後述）チケット認可サービスによって解釈されます。これは通常、アプリケーション・サーバによって無視することができます。しかし、いくつかの特に慎重なアプリケーションサーバーは、再生可能チケットを許可しない場合があります。"
    },
    {
      "indent": 3,
      "text": "If a renewable ticket is not renewed by its expiration time, the KDC will not renew the ticket. The RENEWABLE flag is reset by default, but a client MAY request it be set by setting the RENEWABLE option in the KRB_AS_REQ message. If it is set, then the renew-till field in the ticket contains the time after which the ticket may not be renewed.",
      "ja": "再生可能なチケットがその有効期限によって更新されていない場合、KDCはチケットを更新しません。再生可能フラグはデフォルトでリセットされますが、クライアントは、それがKRB_AS_REQメッセージにおける再生可能オプションを設定することによって設定される要求することができます。それが設定されている場合は、更新-までのフィールドチケットには、チケットが更新されないことがあり、その後の時間が含まれています。"
    },
    {
      "indent": 0,
      "text": "2.4. Postdated Tickets",
      "section_title": true,
      "ja": "2.4. 遅延チケット"
    },
    {
      "indent": 3,
      "text": "Applications may occasionally need to obtain tickets for use much later; e.g., a batch submission system would need tickets to be valid at the time the batch job is serviced. However, it is dangerous to hold valid tickets in a batch queue, since they will be on-line longer and more prone to theft. Postdated tickets provide a way to obtain these tickets from the KDC at job submission time, but to leave them \"dormant\" until they are activated and validated by a further request of the KDC. If a ticket theft were reported in the interim, the KDC would refuse to validate the ticket, and the thief would be foiled.",
      "ja": "アプリケーションは、時折ずっと後で使用するためにチケットを取得する必要があるかもしれません。例えば、バッチ服従システムは、バッチジョブがサービスされた時点で有効にするチケットが必要になります。しかし、彼らがより長く、より上のオンライン盗難が発生しやすいことになるので、バッチ・キュー内の有効なチケットを保持することは危険です。遅延チケットは、ジョブの投入時にKDCからこれらのチケットを入手する方法を提供し、彼らが活性化し、KDCのさらなる要求によって検証されるまで、「休止状態」にそれらを残すこと。チケットの盗難が暫定で報告された場合、KDCは、チケットを検証することを拒否う、と泥棒はくじかれることになります。"
    },
    {
      "indent": 3,
      "text": "The MAY-POSTDATE flag in a ticket is normally only interpreted by the ticket-granting service. It can be ignored by application servers. This flag MUST be set in a TGT in order to issue a postdated ticket based on the presented ticket. It is reset by default; a client MAY request it by setting the ALLOW-POSTDATE option in the KRB_AS_REQ message. This flag does not allow a client to obtain a postdated TGT; postdated TGTs can only be obtained by requesting the postdating in the KRB_AS_REQ message. The life (endtime-starttime) of a postdated ticket will be the remaining life of the TGT at the time of the request, unless the RENEWABLE option is also set, in which case it can be the full life (endtime-starttime) of the TGT. The KDC MAY limit how far in the future a ticket may be postdated.",
      "ja": "チケット5月-POSTDATEフラグは、通常のみチケット認可サービスによって解釈されます。これは、アプリケーションサーバによって無視することができます。このフラグは、提示されたチケットに基づいて遅延チケットを発行するためにTGTに設定しなければなりません。これはデフォルトでリセットされます。クライアントは、KRB_AS_REQメッセージにALLOW-POSTDATEオプションを設定することで、それを要求することができます。このフラグは、クライアントが先日付TGTを取得することはできません。先日付のTGTは、KRB_AS_REQメッセージにpostdatingを要求することによって得ることができます。再生可能オプションが設定されていない遅延チケットの人生（終了時刻-STARTTIME）は、それがのフルライフ（終了時刻-STARTTIME）することができ、その場合には、要求時のTGTの残存期間となりますTGT。 KDCはチケットが先日付を書かれるか遠い将来で制限される場合があります。"
    },
    {
      "indent": 3,
      "text": "The POSTDATED flag indicates that a ticket has been postdated. The application server can check the authtime field in the ticket to see when the original authentication occurred. Some services MAY choose to reject postdated tickets, or they may only accept them within a certain period after the original authentication. When the KDC issues a POSTDATED ticket, it will also be marked as INVALID, so that the application client MUST present the ticket to the KDC to be validated before use.",
      "ja": "POSTDATEDフラグは、チケットが先日付を書かされたことを示しています。アプリケーションサーバは、元の認証が発生したときに表示するチケットにauthtimeフィールドを確認することができます。一部のサービスは、遅延チケットを拒否することを選択したり、彼らは、元の認証後一定期間内にそれらを受け入れることができます。 KDCは遅延チケットを発行すると、アプリケーション・クライアントは、使用前に検証することがKDCにチケットを提示する必要がありますように、それはまた、無効とマークされます。"
    },
    {
      "indent": 0,
      "text": "2.5. Proxiable and Proxy Tickets",
      "section_title": true,
      "ja": "2.5. 代理可能とプロキシチケット"
    },
    {
      "indent": 3,
      "text": "At times it may be necessary for a principal to allow a service to perform an operation on its behalf. The service must be able to take on the identity of the client, but only for a particular purpose. A principal can allow a service to do this by granting it a proxy.",
      "ja": "プリンシパルはサービスが代わって操作を実行できるようにするために時にはそれが必要な場合があります。サービスは、しかし、特定の目的のために、クライアントのアイデンティティを取ることができなければなりません。主なサービスがそれにプロキシを付与することによってこれを行うことができるようにすることができます。"
    },
    {
      "indent": 3,
      "text": "The process of granting a proxy by using the proxy and proxiable flags is used to provide credentials for use with specific services. Though conceptually also a proxy, users wishing to delegate their identity in a form usable for all purposes MUST use the ticket forwarding mechanism described in the next section to forward a TGT.",
      "ja": "プロキシとプロキシが可能なフラグを使用してプロキシを付与するプロセスは、特定のサービスで使用するための資格情報を提供するために使用されます。概念的にもプロキシが、すべての目的のために使用可能な形で自分のアイデンティティを委任したいユーザーは、TGTを転送するために、次のセクションで説明したチケットの転送メカニズムを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The PROXIABLE flag in a ticket is normally only interpreted by the ticket-granting service. It can be ignored by application servers. When set, this flag tells the ticket-granting server that it is OK to issue a new ticket (but not a TGT) with a different network address based on this ticket. This flag is set if requested by the client on initial authentication. By default, the client will request that it be set when requesting a TGT, and that it be reset when requesting any other ticket.",
      "ja": "チケットにPROXIABLEフラグは、通常のみチケット認可サービスによって解釈されます。これは、アプリケーションサーバによって無視することができます。設定されている場合、このフラグは、このチケットに基づいて、異なるネットワークアドレスを使用して新しいチケット（ただし、TGT）を発行してOKですチケット交付サーバーに伝えます。初期認証にクライアントによって要求された場合は、このフラグが設定されています。デフォルトでは、クライアントがTGTを要求したときに、それを設定することを要求します、そして、他のチケットを要求するときにはリセットされていること。"
    },
    {
      "indent": 3,
      "text": "This flag allows a client to pass a proxy to a server to perform a remote request on its behalf (e.g., a print service client can give the print server a proxy to access the client's files on a particular file server in order to satisfy a print request).",
      "ja": "このフラグは、（例えば、印刷サービスクライアントが印刷を満たすために、プリントサーバーに特定のファイルサーバー上のクライアントのファイルにアクセスするためのプロキシを与えることができ、クライアントはその代わりに、リモート要求を実行するために、サーバーへのプロキシを渡すことができます要求）。"
    },
    {
      "indent": 3,
      "text": "In order to complicate the use of stolen credentials, Kerberos tickets are often valid only from those network addresses specifically included in the ticket, but it is permissible as a policy option to allow requests and to issue tickets with no network addresses specified. When granting a proxy, the client MUST specify the new network address from which the proxy is to be used or indicate that the proxy is to be issued for use from any address.",
      "ja": "盗まれた資格情報の使用を複雑にするためには、Kerberosチケットは、具体的には、チケットに含まれるもののネットワークアドレスからのみしばしば有効ですが、それは要求を許可するようにして指定されていないネットワークアドレスとチケットを発行するための政策オプションとして許容されます。プロキシを許可する場合、クライアントはプロキシが使用されるか、またはプロキシが任意のアドレスから使用するために発行されることを示すことがあり、そこから新しいネットワーク・アドレスを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The PROXY flag is set in a ticket by the TGS when it issues a proxy ticket. Application servers MAY check this flag; and at their option they MAY require additional authentication from the agent presenting the proxy in order to provide an audit trail.",
      "ja": "それがプロキシチケットを発行したときPROXYフラグはTGSでチケットに設定されています。アプリケーションサーバーは、このフラグをチェックすること。そして、そのオプションで、彼らは、監査証跡を提供するために、プロキシを提示するエージェントからの追加の認証が必要な場合があります。"
    },
    {
      "indent": 0,
      "text": "2.6. Forwardable Tickets",
      "section_title": true,
      "ja": "2.6. 転送可能チケット"
    },
    {
      "indent": 3,
      "text": "Authentication forwarding is an instance of a proxy where the service that is granted is complete use of the client's identity. An example of where it might be used is when a user logs in to a remote system and wants authentication to work from that system as if the login were local.",
      "ja": "認証転送が許可されたサービスは、クライアントのアイデンティティを完全に使用されたプロキシのインスタンスです。ユーザーのリモートシステムにログインし、ログインがローカルであるかのように、認証がそのシステムから作業したいときにそれが使用されるかもしれない場所の例があります。"
    },
    {
      "indent": 3,
      "text": "The FORWARDABLE flag in a ticket is normally only interpreted by the ticket-granting service. It can be ignored by application servers. The FORWARDABLE flag has an interpretation similar to that of the PROXIABLE flag, except TGTs may also be issued with different network addresses. This flag is reset by default, but users MAY request that it be set by setting the FORWARDABLE option in the AS request when they request their initial TGT.",
      "ja": "チケットにFORWARDABLEフラグは、通常のみチケット認可サービスによって解釈されます。これは、アプリケーションサーバによって無視することができます。 FORWARDABLEフラグのTGTは、異なるネットワークアドレスを発行することができる以外、PROXIABLEフラグと同様の解釈を持っています。このフラグはデフォルトでリセットされますが、ユーザーはそれが彼らの最初のTGTを要求したときAS要求でFORWARDABLEオプションを設定することによって設定されることを要求することができます。"
    },
    {
      "indent": 3,
      "text": "This flag allows for authentication forwarding without requiring the user to enter a password again. If the flag is not set, then authentication forwarding is not permitted, but the same result can still be achieved if the user engages in the AS exchange, specifies the requested network addresses, and supplies a password.",
      "ja": "このフラグは、もう一度パスワードを入力するようにユーザに要求することなく、認証転送が可能になります。フラグが設定されていない場合は、認証転送が許可されていないが、ユーザが、AS交換に取り組んで要求されたネットワークアドレスを指定し、パスワードを提供する場合も、同じ結果がまだ達成することができます。"
    },
    {
      "indent": 3,
      "text": "The FORWARDED flag is set by the TGS when a client presents a ticket with the FORWARDABLE flag set and requests a forwarded ticket by specifying the FORWARDED KDC option and supplying a set of addresses for the new ticket. It is also set in all tickets issued based on tickets with the FORWARDED flag set. Application servers may choose to process FORWARDED tickets differently than non-FORWARDED tickets.",
      "ja": "クライアントがFORWARDABLEフラグが設定されたチケットを提示し、FORWARDED KDCオプションを指定して、新しいチケットのためのアドレスのセットを供給することにより、転送チケットを要求したときFORWARDEDフラグはTGSで設定されています。また、FORWARDEDフラグがセットされたチケットに基づいて発行されたすべてのチケットに設定されています。アプリケーションサーバーは非FORWARDEDチケットとは異なるFORWARDEDチケットを処理することもできます。"
    },
    {
      "indent": 3,
      "text": "If addressless tickets are forwarded from one system to another, clients SHOULD still use this option to obtain a new TGT in order to have different session keys on the different systems.",
      "ja": "アドレスなしチケットがあるシステムから別のシステムに転送された場合、クライアントはまだ、異なるシステム上の別のセッション鍵を持っているために、新しいTGTを取得するために、このオプションを使用してください。"
    },
    {
      "indent": 0,
      "text": "2.7. Transited Policy Checking",
      "section_title": true,
      "ja": "2.7. 遷移ポリシーチェック"
    },
    {
      "indent": 3,
      "text": "In Kerberos, the application server is ultimately responsible for accepting or rejecting authentication, and it SHOULD check that only suitably trusted KDCs are relied upon to authenticate a principal. The transited field in the ticket identifies which realms (and thus which KDCs) were involved in the authentication process, and an application server would normally check this field. If any of these are untrusted to authenticate the indicated client principal (probably determined by a realm-based policy), the authentication attempt MUST be rejected. The presence of trusted KDCs in this list does not provide any guarantee; an untrusted KDC may have fabricated the list.",
      "ja": "ケルベロスでは、アプリケーション・サーバは、認証を受け入れるか拒否するための最終的な責任を負い、それが唯一の適切な信頼できるのKDCはプリンシパルを認証するために依拠していることを確認する必要があります。チケットで通過している分野は、認証プロセスに関与していた（KDCをこれと）どのレルムを識別し、アプリケーション・サーバは、通常はこのフィールドをチェックします。これらのいずれかが（おそらくレルムベースのポリシーによって決定される）を示し、クライアントのプリンシパルを認証するために信頼されていない場合は、認証の試行を拒絶しなければなりません。このリスト内の信頼のKDCの存在は、いかなる保証も提供しません。信頼できないKDCは、リストを作製している可能性があります。"
    },
    {
      "indent": 3,
      "text": "Although the end server ultimately decides whether authentication is valid, the KDC for the end server's realm MAY apply a realm-specific policy for validating the transited field and accepting credentials for cross-realm authentication. When the KDC applies such checks and accepts such cross-realm authentication, it will set the TRANSITED-POLICY-CHECKED flag in the service tickets it issues based on the cross-realm TGT. A client MAY request that the KDCs not check the transited field by setting the DISABLE-TRANSITED-CHECK flag. KDCs are encouraged but not required to honor this flag.",
      "ja": "エンドサーバーが最終的に認証が有効であるかどうかを決定しますが、エンドサーバーのレルムのKDCが通過している分野を検証し、クロスレルム認証のための資格情報を受け入れるためのレルム固有のポリシーを適用することができます。 KDCは、このようなチェックを適用し、そのようなクロスレルム認証を受け付けると、それがクロスレルムTGTに基づいて、それが発行するサービスチケットに遷移-POLICY確認済みフラグをセットします。クライアントは、KDCには、DISABLE-TRANSITED-CHECKフラグを設定することにより、通過している分野をチェックしないことを要求することができます。 KDCが奨励さが、このフラグを尊重する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Application servers MUST either do the transited-realm checks themselves or reject cross-realm tickets without TRANSITED-POLICY-CHECKED set.",
      "ja": "アプリケーションサーバーは遷移レルムが自分自身をチェックしませんかTRANSITED-POLICY-CHECKEDセットせずにクロスレルムチケットを拒絶しなければなりませんどちらか。"
    },
    {
      "indent": 0,
      "text": "2.8. OK as Delegate",
      "section_title": true,
      "ja": "2.8. 代理人としてOK"
    },
    {
      "indent": 3,
      "text": "For some applications, a client may need to delegate authority to a server to act on its behalf in contacting other services. This requires that the client forward credentials to an intermediate server. The ability for a client to obtain a service ticket to a server conveys no information to the client about whether the server should be trusted to accept delegated credentials. The OK-AS-DELEGATE provides a way for a KDC to communicate local realm policy to a client regarding whether an intermediate server is trusted to accept such credentials.",
      "ja": "一部のアプリケーションでは、クライアントは他のサービスとの接触にその代理として行動するためにサーバに権限を委任する必要があるかもしれません。これは、中間サーバへのクライアントの前方資格情報が必要です。サーバーにサービスチケットを取得するためのクライアントのための能力は、サーバが委任された資格情報を受け入れることを信頼すべきかどうかについて、クライアントに何も情報を伝えていません。 OK-AS-DELEGATEは、KDCは、中間サーバは、このような資格情報を受け入れるために、信頼されているかどうかについて、クライアントにローカル領域ポリシーを通信するための方法を提供します。"
    },
    {
      "indent": 3,
      "text": "The copy of the ticket flags in the encrypted part of the KDC reply may have the OK-AS-DELEGATE flag set to indicate to the client that the server specified in the ticket has been determined by the policy of the realm to be a suitable recipient of delegation. A client can use the presence of this flag to help it decide whether to delegate credentials (grant either a proxy or a forwarded TGT) to this server. It is acceptable to ignore the value of this flag. When setting this flag, an administrator should consider the security and placement of the server on which the service will run, as well as whether the service requires the use of delegated credentials.",
      "ja": "KDC応答の暗号化された部分でのチケットのフラグのコピーは、適切な受信者であることをチケットに指定されたサーバー、レルムのポリシーによって決定されたことをクライアントに示すように設定OK-AS-DELEGATEフラグを有することができます代表団の。クライアントは、このサーバに（プロキシまたは転送TGTのいずれかを付与する）、それが資格情報を委任するかどうかを決定するために、このフラグの存在を使用することができます。なお、このフラグの値を無視してもよいです。このフラグを設定する場合、管理者は、サービスを実行するサーバーのセキュリティと配置を考慮する必要があり、同様かどうかなどのサービスは、委任された資格情報を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.9. Other KDC Options",
      "section_title": true,
      "ja": "2.9. その他のKDCオプション"
    },
    {
      "indent": 3,
      "text": "There are three additional options that MAY be set in a client's request of the KDC.",
      "ja": "KDCのクライアントの要求に設定されるかもしれ三つの追加オプションがあります。"
    },
    {
      "indent": 0,
      "text": "2.9.1. Renewable-OK",
      "section_title": true,
      "ja": "2.9.1. 再生可能-OK"
    },
    {
      "indent": 3,
      "text": "The RENEWABLE-OK option indicates that the client will accept a renewable ticket if a ticket with the requested life cannot otherwise be provided. If a ticket with the requested life cannot be provided, then the KDC MAY issue a renewable ticket with a renew-till equal to the requested endtime. The value of the renew-till field MAY still be adjusted by site-determined limits or limits imposed by the individual principal or server.",
      "ja": "再生可能OKオプションは、要求された生活にチケットが別の方法で提供することができない場合、クライアントは再生可能なチケットを受け入れることを示しています。要求された生活にチケットが提供できない場合は、KDCは更新-まで要求された終了時刻に等しいと再生可能なチケットを発行することができます。更新-までフィールドの値は、まだ個々のプリンシパルまたはサーバによって課さサイト決定制限又は制限することによって調整することができます。"
    },
    {
      "indent": 0,
      "text": "2.9.2. ENC-TKT-IN-SKEY",
      "section_title": true,
      "ja": "2.9.2.  ENC-TKT-IN-SKEY"
    },
    {
      "indent": 3,
      "text": "In its basic form, the Kerberos protocol supports authentication in a client-server setting and is not well suited to authentication in a peer-to-peer environment because the long-term key of the user does not remain on the workstation after initial login. Authentication of such peers may be supported by Kerberos in its user-to-user variant. The ENC-TKT-IN-SKEY option supports user-to-user authentication by allowing the KDC to issue a service ticket encrypted using the session key from another TGT issued to another user. The ENC-TKT-IN-SKEY option is honored only by the ticket-granting service. It indicates that the ticket to be issued for the end server is to be encrypted in the session key from the additional second TGT provided with the request. See Section 3.3.3 for specific details.",
      "ja": "その基本的な形では、Kerberosプロトコルは、クライアント - サーバの設定で認証をサポートし、ユーザの長期鍵は最初のログイン後にワークステーション上に残っていないため、ピア・ツー・ピア環境での認証には適していません。そのようなピアの認証は、ユーザ対ユーザバリアントにケルベロスによって支持することができます。 ENC-TKT-IN-SKEYオプションは、KDCは別のTGTが別のユーザーに発行されたセッションキーを使用して暗号化されたサービスチケットを発行できるようにすることで、ユーザ・ユーザ認証をサポートしています。 ENC-TKT-IN-SKEYオプションはのみチケット認可サービスによって表彰されます。これは、エンド・サーバー用に発行されるチケットが要求して提供される追加の二TGTからのセッション鍵で暗号化されることを示します。具体的な詳細については、セクション3.3.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.9.3. Passwordless Hardware Authentication",
      "section_title": true,
      "ja": "2.9.3. パスワードなしのハードウェア認証"
    },
    {
      "indent": 3,
      "text": "The OPT-HARDWARE-AUTH option indicates that the client wishes to use some form of hardware authentication instead of or in addition to the client's password or other long-lived encryption key. OPT-HARDWARE-AUTH is honored only by the authentication service. If supported and allowed by policy, the KDC will return an error code of KDC_ERR_PREAUTH_REQUIRED and include the required METHOD-DATA to perform such authentication.",
      "ja": "OPT-HARDWARE-AUTHオプションは、クライアントの代わりにまたはクライアントのパスワードまたは他の長寿命の暗号化キーに加えて、ハードウェア認証のいくつかのフォームを使用することを望んでいることを示しています。 OPT-HARDWARE-AUTHは、唯一の認証サービスにより表彰されます。サポートされており、ポリシーで許可された場合、KDCはKDC_ERR_PREAUTH_REQUIREDのエラーコードを返すと、このような認証を行うために必要なMETHOD-DATAが含まれます。"
    },
    {
      "indent": 0,
      "text": "3. Message Exchanges",
      "section_title": true,
      "ja": "3.メッセージ交換"
    },
    {
      "indent": 3,
      "text": "The following sections describe the interactions between network clients and servers and the messages involved in those exchanges.",
      "ja": "次のセクションでは、ネットワーククライアントとサーバとそれらの交換に関与したメッセージの間の相互作用を記述する。"
    },
    {
      "indent": 0,
      "text": "3.1. The Authentication Service Exchange",
      "section_title": true,
      "ja": "3.1. 認証サービスエクスチェンジ"
    },
    {
      "indent": 29,
      "text": "Summary",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "Message direction Message type Section 1. Client to Kerberos KRB_AS_REQ 5.4.1 2. Kerberos to client KRB_AS_REP or 5.4.2 KRB_ERROR 5.9.1",
      "ja": "ケルベロスKRB_AS_REQへのメッセージ方向メッセージタイプセクション1.クライアント5.4.1 2.ケルベロスクライアントKRB_AS_REPまたは5.4.2 KRB_ERROR 5.9.1へ"
    },
    {
      "indent": 3,
      "text": "The Authentication Service (AS) Exchange between the client and the Kerberos Authentication Server is initiated by a client when it wishes to obtain authentication credentials for a given server but currently holds no credentials. In its basic form, the client's secret key is used for encryption and decryption. This exchange is typically used at the initiation of a login session to obtain credentials for a Ticket-Granting Server, which will subsequently be used to obtain credentials for other servers (see Section 3.3)",
      "ja": "認証サービスのクライアントとKerberos認証サーバー間（AS）取引所は、それが特定のサーバーの認証資格を取得したい場合、クライアントによって開始されたが、現在何の資格情報を保持していません。その基本的な形では、クライアントの秘密鍵は、暗号化と復号化に使用されています。この交換は、通常、その後に他のサーバーの証明書を取得するために使用されるチケット許可サーバーの資格を取得するには、ログインセッションの開始時に使用されている（3.3節を参照してください）"
    },
    {
      "indent": 3,
      "text": "without requiring further use of the client's secret key. This exchange is also used to request credentials for services that must not be mediated through the Ticket-Granting Service, but rather require knowledge of a principal's secret key, such as the password-changing service (the password-changing service denies requests unless the requester can demonstrate knowledge of the user's old password; requiring this knowledge prevents unauthorized password changes by someone walking up to an unattended session).",
      "ja": "クライアントの秘密鍵のさらなる使用を必要としません。この交換はまた、チケット認可サービスを介して媒介されてはならないサービスの資格情報を要求するために使用されるのではなく、パスワード変更サービスは、リクエスタない限り、要求を拒否し、このようなパスワード変更サービスとして校長の秘密鍵の知識を、（必要とされますユーザーの古いパスワードの知識を発揮することができ、この知識を必要とすることは無人のセッションまで歩いて誰かによって不正なパスワード変更を防止します）。"
    },
    {
      "indent": 3,
      "text": "This exchange does not by itself provide any assurance of the identity of the user. To authenticate a user logging on to a local system, the credentials obtained in the AS exchange may first be used in a TGS exchange to obtain credentials for a local server; those credentials must then be verified by a local server through successful completion of the Client/Server exchange.",
      "ja": "この交換は、それ自体で、ユーザーの身元のいずれかの保証を提供していません。ローカルシステムにログオンするユーザを認証するために、AS交換で得られた資格情報は、最初のローカル・サーバの資格を得るためTGS交換に使用することができます。これらの資格情報は、クライアント/サーバ交換が正常に完了して、ローカルサーバによって検証されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The AS exchange consists of two messages: KRB_AS_REQ from the client to Kerberos, and KRB_AS_REP or KRB_ERROR in reply. The formats for these messages are described in Sections 5.4.1, 5.4.2, and 5.9.1.",
      "ja": "応答で、クライアントからのKerberos、およびKRB_AS_REPまたはKRB_ERRORにKRB_AS_REQ：AS交換は二つのメッセージで構成されています。これらのメッセージのフォーマットは、セクション5.4.1、5.4.2、および5.9.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "In the request, the client sends (in cleartext) its own identity and the identity of the server for which it is requesting credentials, other information about the credentials it is requesting, and a randomly generated nonce, which can be used to detect replays and to associate replies with the matching requests. This nonce MUST be generated randomly by the client and remembered for checking against the nonce in the expected reply. The response, KRB_AS_REP, contains a ticket for the client to present to the server, and a session key that will be shared by the client and the server. The session key and additional information are encrypted in the client's secret key. The encrypted part of the KRB_AS_REP message also contains the nonce that MUST be matched with the nonce from the KRB_AS_REQ message.",
      "ja": "要求では、クライアントは、（クリアテキストで）独自のアイデンティティとそれが資格情報を要求されているサーバのアイデンティティ、それが要求している資格情報についてのその他の情報、およびリプレイを検出するために使用することができ、ランダムに生成されたnonceを、送信し、マッチング要求と応答を関連付けます。このナンスは、クライアントによってランダムに生成されたと予想される応答でナンスに対してチェックするために忘れてはなりません。応答、KRB_AS_REPは、クライアントがサーバに提示するためのチケット、およびクライアントとサーバによって共有されるセッションキーが含まれています。セッションキーと追加情報は、クライアントの秘密鍵で暗号化されています。 KRB_AS_REPメッセージの暗号化された部分もKRB_AS_REQメッセージからノンスと一致しなければならないナンスが含まれています。"
    },
    {
      "indent": 3,
      "text": "Without pre-authentication, the authentication server does not know whether the client is actually the principal named in the request. It simply sends a reply without knowing or caring whether they are the same. This is acceptable because nobody but the principal whose identity was given in the request will be able to use the reply. Its critical information is encrypted in that principal's key. However, an attacker can send a KRB_AS_REQ message to get known plaintext in order to attack the principal's key. Especially if the key is based on a password, this may create a security exposure. So the initial request supports an optional field that can be used to pass additional information that might be needed for the initial exchange. This field SHOULD be used for pre-authentication as described in sections 3.1.1 and 5.2.7.",
      "ja": "事前認証がなければ、認証サーバは、クライアントが実際に要求で指定された主要であるかどうか分かりません。それは単に知っているか、それらが同じであるかどうかを気にすることなく、応答を送信します。誰もが、そのアイデンティティ要求に与えられたプリンシパルが返事を使用することはできませんので、これは許容可能です。その重要な情報は、そのプリンシパルの鍵で暗号化されます。しかし、攻撃者は、プリンシパルの鍵を攻撃するために、既知の平文を取得するにはKRB_AS_REQメッセージを送ることができます。キーがパスワードに基づいている場合は特に、これはセキュリティ上のリスクを作成することができます。だから、最初の要求は、最初の交換のために必要とされるかもしれない追加情報を渡すために使用することができ、オプションのフィールドをサポートしています。セクション3.1.1および5.2.7に記載したようにこのフィールドには、事前認証に使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Various errors can occur; these are indicated by an error response (KRB_ERROR) instead of the KRB_AS_REP response. The error message is not encrypted. The KRB_ERROR message contains information that can be used to associate it with the message to which it replies. The contents of the KRB_ERROR message are not integrity-protected. As such, the client cannot detect replays, fabrications, or modifications. A solution to this problem will be included in a future version of the protocol.",
      "ja": "様々なエラーが発生する可能性があります。これらに代えKRB_AS_REP応答のエラー応答（KRB_ERROR）で示されています。エラーメッセージは暗号化されていません。 KRB_ERRORメッセージは、それが応答したメッセージに関連付けるために使用することができる情報を含みます。 KRB_ERRORメッセージの内容は整合性が保護されません。そのため、クライアントはリプレイ、捏造、または変更を検出することはできません。この問題を解決するには、プロトコルの将来のバージョンに含まれます。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Generation of KRB_AS_REQ Message",
      "section_title": true,
      "ja": "3.1.1.  KRB_AS_REQメッセージの生成"
    },
    {
      "indent": 3,
      "text": "The client may specify a number of options in the initial request. Among these options are whether pre-authentication is to be performed; whether the requested ticket is to be renewable, proxiable, or forwardable; whether it should be postdated or allow postdating of derivative tickets; and whether a renewable ticket will be accepted in lieu of a non-renewable ticket if the requested ticket expiration date cannot be satisfied by a non-renewable ticket (due to configuration constraints).",
      "ja": "クライアントが最初の要求で多くのオプションを指定することもできます。これらのオプションの中で事前認証を行うか否かです。要求されたチケットは、再生可能なプロキシ可能、または転送可能になることですか。それが先日付を書か又はその誘導体のチケットのpostdatingを許可すべきかどうか。要求されたチケットの有効期限は、（設定上の制約のために）非再生可能なチケットによって満たすことができない場合や、再生可能かどうか、チケットは非再生可能なチケットの代わりに受け入れられます。"
    },
    {
      "indent": 3,
      "text": "The client prepares the KRB_AS_REQ message and sends it to the KDC.",
      "ja": "クライアントは、KRB_AS_REQメッセージを準備し、KDCに送信します。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Receipt of KRB_AS_REQ Message",
      "section_title": true,
      "ja": "3.1.2.  KRB_AS_REQメッセージの受信"
    },
    {
      "indent": 3,
      "text": "If all goes well, processing the KRB_AS_REQ message will result in the creation of a ticket for the client to present to the server. The format for the ticket is described in Section 5.3.",
      "ja": "すべてがうまくいけば、クライアントがサーバーに提示するため、KRB_AS_REQメッセージを処理することは、チケットの作成になります。チケットのフォーマットは5.3節に記述されています。"
    },
    {
      "indent": 3,
      "text": "Because Kerberos can run over unreliable transports such as UDP, the KDC MUST be prepared to retransmit responses in case they are lost. If a KDC receives a request identical to one it has recently processed successfully, the KDC MUST respond with a KRB_AS_REP message rather than a replay error. In order to reduce ciphertext given to a potential attacker, KDCs MAY send the same response generated when the request was first handled. KDCs MUST obey this replay behavior even if the actual transport in use is reliable.",
      "ja": "KerberosがUDPのような信頼性の低いトランスポート上で実行できるため、KDCは、彼らが失われた場合の応答を再送信するために準備しなければなりません。 KDCはそれが最近、正常に処理されたものと同一のリクエストを受信した場合、KDCはKRB_AS_REPメッセージではなく、再生エラーで応じなければなりません。潜在的な攻撃者に与えられた暗号文を低減するために、KDCの要求が最初に処理されたときに発生する同一の応答を送信することができます。 KDCは、使用中の実際の輸送が信頼できる場合でも、この再生動作に従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.1.3. Generation of KRB_AS_REP Message",
      "section_title": true,
      "ja": "3.1.3.  KRB_AS_REPメッセージの生成"
    },
    {
      "indent": 3,
      "text": "The authentication server looks up the client and server principals named in the KRB_AS_REQ in its database, extracting their respective keys. If the requested client principal named in the request is unknown because it doesn't exist in the KDC's principal database, then an error message with a KDC_ERR_C_PRINCIPAL_UNKNOWN is returned.",
      "ja": "認証サーバは、それぞれのキーを抽出し、そのデータベースにKRB_AS_REQにという名前のクライアントとサーバのプリンシパルを検索します。それはKDCの主要なデータベースに存在していないため、要求で指定された要求されたクライアントの主体が不明な場合は、KDC_ERR_C_PRINCIPAL_UNKNOWNとエラーメッセージが返されます。"
    },
    {
      "indent": 3,
      "text": "If required to do so, the server pre-authenticates the request, and if the pre-authentication check fails, an error message with the code KDC_ERR_PREAUTH_FAILED is returned. If pre-authentication is required, but was not present in the request, an error message with the code KDC_ERR_PREAUTH_REQUIRED is returned, and a METHOD-DATA object will be stored in the e-data field of the KRB-ERROR message to specify which pre-authentication mechanisms are acceptable. Usually this will include PA-ETYPE-INFO and/or PA-ETYPE-INFO2 elements as described below. If the server cannot accommodate any encryption type requested by the client, an error message with code KDC_ERR_ETYPE_NOSUPP is returned. Otherwise, the KDC generates a 'random' session key, meaning that, among other things, it should be impossible to guess the next session key based on knowledge of past session keys. Although this can be achieved in a pseudo-random number generator if it is based on cryptographic principles, it is more desirable to use a truly random number generator, such as one based on measurements of random physical phenomena. See [RFC4086] for an in-depth discussion of randomness.",
      "ja": "そうするために必要な場合、サーバーは要求を事前認証、および事前認証チェックが失敗した場合、コードKDC_ERR_PREAUTH_FAILEDとエラーメッセージが返されます。事前認証が必要とするが、要求に存在していなかった場合、コードKDC_ERR_PREAUTH_REQUIREDとエラーメッセージが返され、メソッド・データ・オブジェクトは、事前に指定するKRB-ERRORメッセージの電子データフィールドに格納されます - 認証メカニズムが許容可能です。後述のように通常、これはPA-ETYPE  -  INFOおよび/またはPA-ETYPE-INFO2要素が含まれます。サーバがクライアントから要求されたすべての暗号化タイプに対応できない場合は、コードKDC_ERR_ETYPE_NOSUPPとエラーメッセージが返されます。そうしないと、KDCは、とりわけ、過去のセッション鍵の知識に基づいて、次のセッションキーを推測することは不可能であるべき、ということを意味し、「ランダム」セッション鍵を生成します。それは暗号原理に基づいている場合、これは、擬似乱数発生器で達成することができるが、そのようなランダムな物理現象の測定に基づくものとして、真の乱数発生器を使用することがより望ましいです。ランダム性の徹底的な議論のための[RFC4086]を参照してください。"
    },
    {
      "indent": 3,
      "text": "In response to an AS request, if there are multiple encryption keys registered for a client in the Kerberos database, then the etype field from the AS request is used by the KDC to select the encryption method to be used to protect the encrypted part of the KRB_AS_REP message that is sent to the client. If there is more than one supported strong encryption type in the etype list, the KDC SHOULD use the first valid strong etype for which an encryption key is available.",
      "ja": "Kerberosデータベースにクライアントのために登録された複数の暗号化キー、暗号化方式を選択するためにKDCによって使用されているAS要求から、その後のetypeのフィールドがあるかのように要求に応答して、の暗号化された部分を保護するために使用されますクライアントに送信されたKRB_AS_REPメッセージ。 ETYPEのリストに複数のサポート、強力な暗号化タイプがある場合は、KDCは、暗号化キーが利用可能な最初の有効強いのetypeを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "When the user's key is generated from a password or pass phrase, the string-to-key function for the particular encryption key type is used, as specified in [RFC3961]. The salt value and additional parameters for the string-to-key function have default values (specified by Section 4 and by the encryption mechanism specification, respectively) that may be overridden by pre-authentication data (PA-PW-SALT, PA-AFS3-SALT, PA-ETYPE-INFO, PA-ETYPE-INFO2, etc). Since the KDC is presumed to store a copy of the resulting key only, these values should not be changed for password-based keys except when changing the principal's key.",
      "ja": "ユーザーのキーがパスワードやパスフレーズから生成されている場合、特定の暗号化キーのタイプのための文字列からキーへの機能は、[RFC3961]で指定されるように、使用されています。ソルト値と文字列のキー機能のための追加のパラメータは、事前認証データ（PA-PW塩、PA-AFS3によってオーバーライドすることができる（それぞれ、セクション4によって暗号化機構の仕様で指定された）デフォルト値を持ちます - 塩、PA-ETYPE  -  INFO、PA-ETYPE-INFO2、など）。 KDCだけ結果のキーのコピーを保存すると推定されているので、これらの値は、プリンシパルのキーを変更する場合を除き、パスワードベースのキーに変更するべきではありません。"
    },
    {
      "indent": 3,
      "text": "When the AS server is to include pre-authentication data in a KRB-ERROR or in an AS-REP, it MUST use PA-ETYPE-INFO2, not PA-ETYPE-INFO, if the etype field of the client's AS-REQ lists at least one \"newer\" encryption type. Otherwise (when the etype field of the client's AS-REQ does not list any \"newer\" encryption types), it MUST send both PA-ETYPE-INFO2 and PA-ETYPE-INFO (both with an entry for each enctype). A \"newer\" enctype is any enctype first officially specified concurrently with or subsequent to the issue of this RFC. The enctypes DES, 3DES, or RC4 and any defined in [RFC1510] are not \"newer\" enctypes.",
      "ja": "ASサーバはKRB-ERRORまたはAS-REPで事前認証データが含まれるようになると、それはクライアントのAS-REQリストのETYPEフィールド場合は、いないPA-ETYPE  -  INFO、PA-ETYPE-INFO2を使用しなければなりません少なくとも1つの「新しい」暗号化の種類。 （クライアントのAS-REQのETYPEフィールドがどんな「新しい」暗号化の種類をリストしていない場合）それ以外の場合は、PA-ETYPE-INFO2およびPA-ETYPE  -  INFO（両方ともそれぞれのenctypeのためのエントリを含む）の両方を送らなければなりません。 「新しい」のenctypeは、任意のenctypeを最初に正式と同時に指定するか、このRFCの問題に続きます。 enctypes DES、3DES、またはRC4と[RFC1510]で定義された任意の \"新しい\" enctypesありません。"
    },
    {
      "indent": 3,
      "text": "It is not possible to generate a user's key reliably given a pass phrase without contacting the KDC, since it will not be known whether alternate salt or parameter values are required.",
      "ja": "代替塩またはパラメータ値が必要とされるかどうか分からないので、KDCに接触することなく確実にパスフレーズ所与のユーザのキーを生成することは不可能です。"
    },
    {
      "indent": 3,
      "text": "The KDC will attempt to assign the type of the random session key from the list of methods in the etype field. The KDC will select the appropriate type using the list of methods provided and information from the Kerberos database indicating acceptable encryption methods for the application server. The KDC will not issue tickets with a weak session key encryption type.",
      "ja": "KDCはETYPEフィールド内のメソッドのリストからランダムセッションキーのタイプを割り当てることを試みます。 KDCは、アプリケーションサーバの許容暗号化方式を示すKerberosデータベースから提供される方法および情報のリストを使用して適切なタイプを選択します。 KDCは弱いセッション鍵暗号化タイプとチケットを発行しません。"
    },
    {
      "indent": 3,
      "text": "If the requested starttime is absent, indicates a time in the past, or is within the window of acceptable clock skew for the KDC and the POSTDATE option has not been specified, then the starttime of the ticket is set to the authentication server's current time. If it indicates a time in the future beyond the acceptable clock skew, but the POSTDATED option has not been specified, then the error KDC_ERR_CANNOT_POSTDATE is returned. Otherwise the requested starttime is checked against the policy of the local realm (the administrator might decide to prohibit certain types or ranges of postdated tickets), and if the ticket's starttime is acceptable, it is set as requested, and the INVALID flag is set in the new ticket. The postdated ticket MUST be validated before use by presenting it to the KDC after the starttime has been reached.",
      "ja": "要求されたSTARTTIMEが存在しない場合は、過去の時間を示し、またはKDCのために許容可能なクロック・スキューのウィンドウ内にあり、POSTDATEオプションが指定されていない場合、チケットのSTARTTIMEは、認証サーバの現在の時間に設定されています。それが許容クロック・スキューを超えた未来の時間を示しますが、POSTDATEDオプションが指定されていない場合は、エラーKDC_ERR_CANNOT_POSTDATEが返されます。それ以外の場合は、要求さSTARTTIMEは、ローカル分野の方針に対してチェックされる（管理者は、特定の種類または遅延チケットの範囲を禁止することを決定するかもしれない）、およびチケットのSTARTTIMEが許容される場合、要求されたとして、それが設定され、無効なフラグがセットされ新しいチケット。遅延チケットはSTARTTIMEに達した後KDCにそれを提示することによって、使用前に検証されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The expiration time of the ticket will be set to the earlier of the requested endtime and a time determined by local policy, possibly by using realm- or principal-specific factors. For example, the expiration time MAY be set to the earliest of the following:",
      "ja": "チケットの有効期限は、おそらくrealm-又は主に特異的因子を用いて、要求された終了時刻以前とローカルポリシーによって決定される時間に設定されます。たとえば、有効期限は、次の初期に設定されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "* The expiration time (endtime) requested in the KRB_AS_REQ message.",
      "ja": "* KRB_AS_REQメッセージで要求された有効期限（終了時刻）。"
    },
    {
      "indent": 6,
      "text": "* The ticket's starttime plus the maximum allowable lifetime associated with the client principal from the authentication server's database.",
      "ja": "*チケットのSTARTTIMEプラス認証サーバのデータベースからクライアントプリンシパルに関連付けられた最大許容生涯。"
    },
    {
      "indent": 6,
      "text": "* The ticket's starttime plus the maximum allowable lifetime associated with the server principal.",
      "ja": "*チケットのSTARTTIMEプラスサーバープリンシパルに関連付けられた最大許容生涯。"
    },
    {
      "indent": 6,
      "text": "* The ticket's starttime plus the maximum lifetime set by the policy of the local realm.",
      "ja": "*チケットのstarttimeはプラスローカル分野の政策によって設定された最大寿命。"
    },
    {
      "indent": 3,
      "text": "If the requested expiration time minus the starttime (as determined above) is less than a site-determined minimum lifetime, an error message with code KDC_ERR_NEVER_VALID is returned. If the requested expiration time for the ticket exceeds what was determined as above, and if the 'RENEWABLE-OK' option was requested, then the 'RENEWABLE' flag is set in the new ticket, and the renew-till value is set as if the 'RENEWABLE' option were requested (the field and option names are described fully in Section 5.4.1).",
      "ja": "（上記決定された）要求された有効期限マイナスSTARTTIMEは、部位決定された最小寿命未満である場合、コードKDC_ERR_NEVER_VALIDとエラーメッセージが返されます。チケットの要求された有効期限は、上記のように決定された、と「再生可能OK」オプションが要求された場合は、「再生可能」フラグが新しいチケットに設定され、更新-まで値かのように設定されているものを超えている場合「再生可能」オプションは、（フィールドとオプション名は、セクション5.4.1に完全に記載されている）要求されました。"
    },
    {
      "indent": 3,
      "text": "If the RENEWABLE option has been requested or if the RENEWABLE-OK option has been set and a renewable ticket is to be issued, then the renew-till field MAY be set to the earliest of:",
      "ja": "再生可能オプションが要求されているか、再生可能OKオプションが設定されている場合は、再生可能チケットは、発行される場合は、更新-までのフィールドの最も初期に設定されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "* Its requested value.",
      "ja": "*その要求された値。"
    },
    {
      "indent": 6,
      "text": "* The starttime of the ticket plus the minimum of the two maximum renewable lifetimes associated with the principals' database entries.",
      "ja": "*チケットのstarttimeのプラス校長データベースエントリに関連付けられた2点の最大の再生可能ライフタイムの最小値。"
    },
    {
      "indent": 6,
      "text": "* The starttime of the ticket plus the maximum renewable lifetime set by the policy of the local realm.",
      "ja": "*チケットのstarttimeのプラスローカル分野の政策によって設定された最大の再生可能寿命。"
    },
    {
      "indent": 3,
      "text": "The flags field of the new ticket will have the following options set if they have been requested and if the policy of the local realm allows: FORWARDABLE, MAY-POSTDATE, POSTDATED, PROXIABLE, RENEWABLE. If the new ticket is postdated (the starttime is in the future), its INVALID flag will also be set.",
      "ja": "FORWARDABLE、MAY-POSTDATE、POSTDATED、PROXIABLEは、再生可能：新しいチケットのフラグフィールドは、彼らが要求されている場合は、地元分野の政策が許す場合に設定、次のオプションがあります。新しいチケットが（STARTTIMEは、将来的にある）先日付を書かされている場合は、その無効フラグも設定されます。"
    },
    {
      "indent": 3,
      "text": "If all of the above succeed, the server will encrypt the ciphertext part of the ticket using the encryption key extracted from the server principal's record in the Kerberos database using the encryption type associated with the server principal's key. (This choice is NOT affected by the etype field in the request.) It then formats a KRB_AS_REP message (see Section 5.4.2), copying the addresses in the request into the caddr of the response, placing any required pre-authentication data into the padata of the response, and encrypts the ciphertext part in the client's key using an acceptable encryption method requested in the etype field of the request, or in some key specified by pre-authentication mechanisms being used.",
      "ja": "上記のすべてが成功した場合、サーバは、サーバのプリンシパルのキーに関連付けられた暗号化タイプを使用してKerberosデータベースにサーバープリンシパルのレコードから抽出した暗号鍵を使用して、チケットの暗号文部分を暗号化します。 （この選択は、要求にETYPEフィールドの影響を受けません。）これは、その後KRB_AS_REPメッセージをフォーマット（5.4.2項を参照）、応答のCADDRに要求内のアドレスをコピーし、に必要な事前認証データを配置します応答のPADATA、および要求のetypeをフィールドに、または使用されている事前認証機構によって指定されたいくつかのキーで要求された許容可能な暗号化方式を使用してクライアントの鍵で暗号文の一部を暗号化します。"
    },
    {
      "indent": 0,
      "text": "3.1.4. Generation of KRB_ERROR Message",
      "section_title": true,
      "ja": "3.1.4.  KRB_ERRORメッセージの生成"
    },
    {
      "indent": 3,
      "text": "Several errors can occur, and the Authentication Server responds by returning an error message, KRB_ERROR, to the client, with the error-code and e-text fields set to appropriate values. The error message contents and details are described in Section 5.9.1.",
      "ja": "いくつかのエラーが発生する可能性があり、認証サーバは、適切な値に設定されたエラー・コードと電子テキストフィールドで、クライアントに、エラーメッセージ、KRB_ERRORを返すことによって応答します。エラーメッセージの内容や詳細は、5.9.1項で説明されています。"
    },
    {
      "indent": 0,
      "text": "3.1.5. Receipt of KRB_AS_REP Message",
      "section_title": true,
      "ja": "3.1.5.  KRB_AS_REPメッセージの受信"
    },
    {
      "indent": 3,
      "text": "If the reply message type is KRB_AS_REP, then the client verifies that the cname and crealm fields in the cleartext portion of the reply match what it requested. If any padata fields are present, they may be used to derive the proper secret key to decrypt the message. The client decrypts the encrypted part of the response using its secret key and verifies that the nonce in the encrypted part matches the nonce it supplied in its request (to detect replays). It also verifies that the sname and srealm in the response match those in the request (or are otherwise expected values), and that the host address field is also correct. It then stores the ticket, session key, start and expiration times, and other information for later use. The last-req field (and the deprecated key-expiration field) from the encrypted part of the response MAY be checked to notify the user of impending key expiration. This enables the client program to suggest remedial action, such as a password change.",
      "ja": "応答メッセージタイプがKRB_AS_REPであれば、クライアントは応答の平文部分でCNAMEとcrealmフィールドは、それが要求されたものと一致することを確認します。任意のPADATAフィールドが存在する場合、それらはメッセージを解読するために適切な秘密鍵を導出するために使用することができます。クライアントは、応答の暗号化された部分は、その秘密鍵を使って復号化し、暗号化された部分でnonceが（リプレイを検出するために）、それはその要求で提供ナンスと一致することを確認します。それはまた、応答SNAMEとsrealm要求（または他の値を期待されている）のものと一致することを確認し、ホストアドレスフィールドも正確です。これは、後の使用のためのチケット、セッションキー、開始と有効期限時刻、およびその他の情報を格納します。応答の暗号化された部分から最後-REQフィールド（および非推奨のキーの有効期限フィールド）が差し迫っているキーの有効期限をユーザに通知するためにチェックされます。これは、パスワードの変更など、是正措置を提案するために、クライアントプログラムを可能にします。"
    },
    {
      "indent": 3,
      "text": "Upon validation of the KRB_AS_REP message (by checking the returned nonce against that sent in the KRB_AS_REQ message), the client knows that the current time on the KDC is that read from the authtime field of the encrypted part of the reply. The client can optionally use this value for clock synchronization in subsequent messages by recording with the ticket the difference (offset) between the authtime value and the local clock. This offset can then be used by the same user to adjust the time read from the system clock when generating messages [DGT96].",
      "ja": "（KRB_AS_REQメッセージで送信されたことに対して返されたナンスをチェックして）KRB_AS_REPメッセージの検証の際に、クライアントはKDCの現在の時刻が応答の暗号化された部分のauthtimeフィールドからの読み取りであることを知っています。クライアントは、必要に応じてチケットにauthtime値とローカルクロック間の差（オフセット）を記録することにより、後続のメッセージ内のクロック同期のためにこの値を使用することができます。これは、次に、[DGT96]メッセージを生成するとき、システムクロックから読み出し時間を調整するために同じユーザーによって使用され得るオフセット。"
    },
    {
      "indent": 3,
      "text": "This technique MUST be used when adjusting for clock skew instead of directly changing the system clock, because the KDC reply is only authenticated to the user whose secret key was used, but not to the system or workstation. If the clock were adjusted, an attacker colluding with a user logging into a workstation could agree on a password, resulting in a KDC reply that would be correctly validated even though it did not originate from a KDC trusted by the workstation.",
      "ja": "KDC応答だけではなく、システムまたはワークステーションに、その秘密鍵を使用したユーザに対して認証されているので、代わりに直接システムクロックを変更するクロックスキューを調整すると、この手法を使用しなければなりません。クロックを調整した場合は、ワークステーションにログインしたユーザと共謀攻撃者が正しく、それがワークステーションから信頼KDCから生じていないにもかかわらず、検証されるだろうKDC応答が得られ、パスワードに同意することができます。"
    },
    {
      "indent": 3,
      "text": "Proper decryption of the KRB_AS_REP message is not sufficient for the host to verify the identity of the user; the user and an attacker could cooperate to generate a KRB_AS_REP format message that decrypts properly but is not from the proper KDC. If the host wishes to verify the identity of the user, it MUST require the user to present application credentials that can be verified using a securely-stored secret key for the host. If those credentials can be verified, then the identity of the user can be assured.",
      "ja": "ホストは、ユーザーの身元を確認するためKRB_AS_REPメッセージの適切な復号化は十分ではありません。ユーザと攻撃者が適切に復号化が、適切なKDCからのものではないKRB_AS_REP形式のメッセージを生成するために協働することができました。ホストは、ユーザーの身元を確認したい場合は、ホストのために安全に保存された秘密鍵を使用して検証することができるアプリケーションの資格情報を提示することをユーザに要求しなければなりません。これらの資格情報を検証できる場合には、ユーザーの身元を保証することができます。"
    },
    {
      "indent": 0,
      "text": "3.1.6. Receipt of KRB_ERROR Message",
      "section_title": true,
      "ja": "3.1.6.  KRB_ERRORメッセージの受信"
    },
    {
      "indent": 3,
      "text": "If the reply message type is KRB_ERROR, then the client interprets it as an error and performs whatever application-specific tasks are necessary for recovery.",
      "ja": "応答メッセージタイプがKRB_ERRORである場合、クライアントはエラーとしてそれを解釈し、アプリケーション固有のタスクは、回復のために必要なものは何でも実行します。"
    },
    {
      "indent": 0,
      "text": "3.2. The Client/Server Authentication Exchange",
      "section_title": true,
      "ja": "3.2. クライアント/サーバー認証交換"
    },
    {
      "indent": 32,
      "text": "Summary",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Message direction Message type Section Client to Application server KRB_AP_REQ 5.5.1 [optional] Application server to client KRB_AP_REP or 5.5.2 KRB_ERROR 5.9.1",
      "ja": "アプリケーションサーバーKRB_AP_REQ 5.5.1 [オプション]アプリケーションのクライアントKRB_AP_REPへのサーバーまたは5.5.2 KRB_ERRORへのメッセージ方向メッセージタイプセクションクライアント5.9.1"
    },
    {
      "indent": 3,
      "text": "The client/server authentication (CS) exchange is used by network applications to authenticate the client to the server and vice versa. The client MUST have already acquired credentials for the server using the AS or TGS exchange.",
      "ja": "クライアント/サーバー認証（CS）交換は、サーバーおよびその逆に、クライアントを認証するためにネットワークアプリケーションで使用されています。クライアントがすでにASまたはTGS交換を使用してサーバの資格を取得している必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.1. The KRB_AP_REQ Message",
      "section_title": true,
      "ja": "3.2.1.  KRB_AP_REQメッセージ"
    },
    {
      "indent": 3,
      "text": "The KRB_AP_REQ contains authentication information that SHOULD be part of the first message in an authenticated transaction. It contains a ticket, an authenticator, and some additional bookkeeping information (see Section 5.5.1 for the exact format). The ticket by itself is insufficient to authenticate a client, since tickets are passed across the network in cleartext (tickets contain both an encrypted and unencrypted portion, so cleartext here refers to the entire unit, which can be copied from one message and replayed in another without any cryptographic skill). The authenticator is used to prevent invalid replay of tickets by proving to the server that the client knows the session key of the ticket and thus is entitled to use the ticket. The KRB_AP_REQ message is referred to elsewhere as the 'authentication header'.",
      "ja": "KRB_AP_REQは認証されたトランザクションの最初のメッセージの一部である必要があり、認証情報が含まれています。それは、チケット、オーセンティケータ、およびいくつかの追加の簿記情報を（正確なフォーマットについては、セクション5.5.1を参照）が含まれています。チケットがクリアテキストでネットワークを介して渡されるので、それ自体でチケットは、クライアントを認証するには不十分である（チケットはそう平文ここで、暗号化および非暗号化部分の両方を含む1つのメッセージからコピーして、別に再生することができ、装置全体を指し任意の暗号スキルなし）。オーセンティケータは、クライアントが、チケットのセッション・キーを知っているので、チケットを使用する権利があるサーバに証明することによってチケットの不正な再生を防ぐために使用されます。 KRB_AP_REQメッセージは、「認証ヘッダー」と他の場所と呼ばれます。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Generation of a KRB_AP_REQ Message",
      "section_title": true,
      "ja": "3.2.2.  KRB_AP_REQメッセージの生成"
    },
    {
      "indent": 3,
      "text": "When a client wishes to initiate authentication to a server, it obtains (either through a credentials cache, the AS exchange, or the TGS exchange) a ticket and session key for the desired service. The client MAY re-use any tickets it holds until they expire. To use a ticket, the client constructs a new Authenticator from the system time and its name, and optionally from an application-specific checksum, an initial sequence number to be used in KRB_SAFE or KRB_PRIV messages, and/or a session subkey to be used in negotiations for a session key unique to this particular session. Authenticators MUST NOT be re-used and SHOULD be rejected if replayed to a server. Note that this can make applications based on unreliable transports difficult to code correctly. If the transport might deliver duplicated messages, either a new authenticator MUST be generated for each retry, or the application server MUST match requests and replies and replay the first reply in response to a detected duplicate.",
      "ja": "クライアントがサーバーに認証を開始したいとき、それは（資格キャッシュを通して、AS交換、またはTGS交換のどちらか）は、所望のサービスのチケットとセッション鍵を得ます。クライアントは、彼らが期限切れになるまでそれが保持している任意のチケットを再利用するかもしれません。チケットを使用するには、クライアントは、システムの時刻と、その名前から、必要に応じてアプリケーション固有のチェックサム、KRB_SAFEかKRB_PRIVメッセージで使用される初期シーケンス番号、および/または使用するセッションサブキーから新しい認証を構築しますこの特定のセッションに固有のセッションキー交渉インチオーセンティケータは、再使用してはいけませんし、サーバーに再演場合は拒絶されるべきです。これは正しくコードに難しい信頼性のないトランスポートに基づいてアプリケーションを作ることができることに注意してください。トランスポートは、重複したメッセージを配信する可能性がある場合はどちらかの新しいオーセンティケータは、各再試行のために生成しなければならない、またはアプリケーション・サーバーは、要求と応答と一致し、検出された重複に応答して第1の応答を再生する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a sequence number is to be included, it SHOULD be randomly chosen so that even after many messages have been exchanged it is not likely to collide with other sequence numbers in use.",
      "ja": "シーケンス番号が含まれる場合、使用中の他のシーケンス番号と衝突する可能性はない多くのメッセージが交換された後でもするように、それがランダムに選択されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client MAY indicate a requirement of mutual authentication or the use of a session-key based ticket (for user-to-user authentication, see section 3.7) by setting the appropriate flag(s) in the ap-options field of the message.",
      "ja": "クライアントは、相互認証の要求、またはセッションキーベースのチケットの使用を指示することができるメッセージのAP-オプションフィールドに適切なフラグ（S）を設定することにより、（ユーザ対ユーザ認証のために、セクション3.7を参照）。"
    },
    {
      "indent": 3,
      "text": "The Authenticator is encrypted in the session key and combined with the ticket to form the KRB_AP_REQ message, which is then sent to the end server along with any additional application-specific information.",
      "ja": "認証は、セッション鍵で暗号化した後、任意の追加のアプリケーション固有の情報とともにエンドサーバに送信されるKRB_AP_REQメッセージを形成するために、チケットと組み合わされます。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Receipt of KRB_AP_REQ Message",
      "section_title": true,
      "ja": "3.2.3.  KRB_AP_REQメッセージの受信"
    },
    {
      "indent": 3,
      "text": "Authentication is based on the server's current time of day (clocks MUST be loosely synchronized), the authenticator, and the ticket. Several errors are possible. If an error occurs, the server is expected to reply to the client with a KRB_ERROR message. This message MAY be encapsulated in the application protocol if its raw form is not acceptable to the protocol. The format of error messages is described in Section 5.9.1.",
      "ja": "認証は、サーバの現在の時刻（クロックが緩く同期させなければならない）、オーセンティケータ、およびチケットに基づいています。いくつかのエラーが可能です。エラーが発生した場合、サーバはKRB_ERRORメッセージでクライアントに返信することが期待されます。その生の形式はプロトコルに許容されない場合、このメッセージは、アプリケーションプロトコルでカプセル化され得ます。エラーメッセージのフォーマットは、5.9.1項で説明されています。"
    },
    {
      "indent": 3,
      "text": "The algorithm for verifying authentication information is as follows. If the message type is not KRB_AP_REQ, the server returns the KRB_AP_ERR_MSG_TYPE error. If the key version indicated by the Ticket in the KRB_AP_REQ is not one the server can use (e.g., it indicates an old key, and the server no longer possesses a copy of the old key), the KRB_AP_ERR_BADKEYVER error is returned. If the USE-SESSION-KEY flag is set in the ap-options field, it indicates to the server that user-to-user authentication is in use, and that the ticket is encrypted in the session key from the server's TGT rather than in the server's secret key. See Section 3.7 for a more complete description of the effect of user-to-user authentication on all messages in the Kerberos protocol.",
      "ja": "次のように認証情報を検証するためのアルゴリズムがあります。メッセージタイプがKRB_AP_REQされていない場合、サーバーはKRB_AP_ERR_MSG_TYPEエラーを返します。 KRB_AP_REQにチケットで示されるキーのバージョンは、サーバーが使用できるものでない場合（例えば、それは古いキーを示していない、とサーバーは、もはや古いキーのコピーを所有している）、KRB_AP_ERR_BADKEYVERエラーが返されます。 USE-SESSION-KEYフラグはAP-オプションフィールドに設定されている場合、それは、ユーザ対ユーザ認証を使用しているサーバーに示しており、チケットはではなく、サーバのTGTからセッション鍵で暗号化されていることサーバの秘密鍵。 Kerberosプロトコルのすべてのメッセージのユーザ・ユーザ認証の効果のより完全な説明については、3.7節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Because it is possible for the server to be registered in multiple realms, with different keys in each, the srealm field in the unencrypted portion of the ticket in the KRB_AP_REQ is used to specify which secret key the server should use to decrypt that ticket. The KRB_AP_ERR_NOKEY error code is returned if the server doesn't have the proper key to decipher the ticket.",
      "ja": "サーバはそれぞれに異なるキーを使用して、複数のレルムに登録することは可能であるので、KRB_AP_REQでチケットの暗号化されていない部分でsrealmフィールドは、サーバがそのチケットを復号化するために使用する秘密鍵を指定するには、使用されています。サーバーがチケットを解読するために適切なキーを持っていない場合KRB_AP_ERR_NOKEYのエラーコードが返されます。"
    },
    {
      "indent": 3,
      "text": "The ticket is decrypted using the version of the server's key specified by the ticket. If the decryption routines detect a modification of the ticket (each encryption system MUST provide safeguards to detect modified ciphertext), the",
      "ja": "チケットは、チケットで指定されたサーバーの鍵のバージョンを使用して復号化されます。復号化ルーチンは、チケットの変更を検出した場合（各暗号化システムが変更された暗号文を検出するための保護手段を提供しなければなりません）、"
    },
    {
      "indent": 3,
      "text": "KRB_AP_ERR_BAD_INTEGRITY error is returned (chances are good that different keys were used to encrypt and decrypt).",
      "ja": "KRB_AP_ERR_BAD_INTEGRITYエラーが（チャンスは異なる鍵が暗号化と復号化に使用されたことに優れている）が返されます。"
    },
    {
      "indent": 3,
      "text": "The authenticator is decrypted using the session key extracted from the decrypted ticket. If decryption shows that is has been modified, the KRB_AP_ERR_BAD_INTEGRITY error is returned. The name and realm of the client from the ticket are compared against the same fields in the authenticator. If they don't match, the KRB_AP_ERR_BADMATCH error is returned; normally this is caused by a client error or an attempted attack. The addresses in the ticket (if any) are then searched for an address matching the operating-system reported address of the client. If no match is found or the server insists on ticket addresses but none are present in the ticket, the KRB_AP_ERR_BADADDR error is returned. If the local (server) time and the client time in the authenticator differ by more than the allowable clock skew (e.g., 5 minutes), the KRB_AP_ERR_SKEW error is returned.",
      "ja": "オーセンティケータは、復号化されたチケットから抽出されたセッションキーを使用して復号化されます。ある復号ショーが変更されている場合、KRB_AP_ERR_BAD_INTEGRITYエラーが返されます。チケットからクライアントの名前とレルムは、オーセンティケータで同じフィールドと比較されます。それらが一致しない場合は、KRB_AP_ERR_BADMATCHエラーが返されます。通常、これは、クライアント・エラーまたは試行攻撃によって引き起こされます。チケット（もしあれば）のアドレスは、クライアントのオペレーティング・システムに報告アドレスに一致するアドレスが検索されています。一致が見つからないか、サーバーがチケットアドレスを主張したがどれもチケットに存在していない場合は、KRB_AP_がERR_BADADDRエラーが返されます。オーセンティケータ内のローカル（サーバ）時間とクライアントの時間が許容クロック・スキュー（例えば、5分）を超えて異なる場合、KRB_AP_ERR_SKEWエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Unless the application server provides its own suitable means to protect against replay (for example, a challenge-response sequence initiated by the server after authentication, or use of a server-generated encryption subkey), the server MUST utilize a replay cache to remember any authenticator presented within the allowable clock skew. Careful analysis of the application protocol and implementation is recommended before eliminating this cache. The replay cache will store at least the server name, along with the client name, time, and microsecond fields from the recently-seen authenticators, and if a matching tuple is found, the KRB_AP_ERR_REPEAT error is returned. Note that the rejection here is restricted to authenticators from the same principal to the same server. Other client principals communicating with the same server principal should not have their authenticators rejected if the time and microsecond fields happen to match some other client's authenticator.",
      "ja": "アプリケーションサーバはリプレイから保護するために、独自の適切な手段を提供しない限り（例えば、チャレンジレスポンスシーケンスが認証した後、サーバ、またはサーバが生成した暗号化サブキーを使用することにより開始される）、サーバーは、任意のを覚えてリプレイキャッシュを利用しなければなりませんオーセンティケータは、許容できる時計斜行の中に提示しました。アプリケーションプロトコルと実装の慎重な分析は、このキャッシュを排除する前にお勧めします。リプレイ・キャッシュは、最近見認証者からのクライアント名、時間、およびマイクロ秒のフィールドと一緒に、少なくともサーバーの名前を格納する、とのマッチングタプルが発見された場合、KRB_AP_ERR_REPEATエラーが返されます。ここでの拒否が同じサーバーに同じ校長からのオーセンティケータに制限されることに注意してください。時間やマイクロ秒のフィールドは、いくつかの他のクライアントの認証システムを一致させるために起こる場合は、同じサーバープリンシパルと通信し、他のクライアントのプリンシパルは、その認証者が拒否されてはいけません。"
    },
    {
      "indent": 3,
      "text": "If a server loses track of authenticators presented within the allowable clock skew, it MUST reject all requests until the clock skew interval has passed, providing assurance that any lost or replayed authenticators will fall outside the allowable clock skew and can no longer be successfully replayed. If this were not done, an attacker could subvert the authentication by recording the ticket and authenticator sent over the network to a server and replaying them following an event that caused the server to lose track of recently seen authenticators.",
      "ja": "サーバが許容できる時計斜行の中に提示し認証子のトラックを失った場合、クロックスキュー期間が経過するまで、それが失われたか、再生のオーセンティケータが許容クロック・スキューの範囲外になると、もはや、正常に再生できないことを保証を提供し、すべての要求を拒絶しなければなりません。これが行われなかった場合、攻撃者がサーバーにネットワーク経由で送信チケットとオーセンティケータを記録し、サーバーが最近見認証子のトラックを失うことを引き起こしたイベント以下にそれらを再生することによって認証を覆すことができます。"
    },
    {
      "indent": 3,
      "text": "Implementation note: If a client generates multiple requests to the KDC with the same timestamp, including the microsecond field, all but the first of the requests received will be rejected as replays. This might happen, for example, if the resolution of the client's clock is too coarse. Client implementations SHOULD ensure that the timestamps are not reused, possibly by incrementing the microseconds field in the time stamp when the clock returns the same time for multiple requests.",
      "ja": "実装上の注意：クライアントはすべて、マイクロ秒のフィールドを含む同じタイムスタンプを持つKDCへの複数の要求を、生成される場合が、受信要求の最初のリプレイとして拒否されます。クライアントのクロックの解像度が粗すぎる場合、これは、例えば、起こるかもしれません。クライアントの実装では、クロックは、複数の要求に同じ時間を返すときのタイムスタンプは、タイムスタンプにマイクロ秒のフィールドをインクリメントすることにより、おそらく、再利用されていないことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "If multiple servers (for example, different services on one machine, or a single service implemented on multiple machines) share a service principal (a practice that we do not recommend in general, but that we acknowledge will be used in some cases), either they MUST share this replay cache, or the application protocol MUST be designed so as to eliminate the need for it. Note that this applies to all of the services. If any of the application protocols does not have replay protection built in, an authenticator used with such a service could later be replayed to a different service with the same service principal but no replay protection, if the former doesn't record the authenticator information in the common replay cache.",
      "ja": "もし複数のサーバ（例えば、一台のマシン、または複数のマシン上に実装され、単一のサービスに異なるサービス）のいずれかのサービスプリンシパル共有（私たちは、一般的にはお勧めしません練習を、私たちはいくつかのケースで使用される認めること）、彼らはこのリプレイのキャッシュを共有しなければならない、またはそれのための必要性を排除するようにアプリケーションプロトコルを設計する必要があります。これは、サービスのすべてに適用されることに注意してください。アプリケーションプロトコルのいずれかがリプレイ保護が組み込まれていない場合は前者がでオーセンティケータの情報を記録していない場合、そのようなサービスで使用されるオーセンティケータは、後に、同じサービスプリンシパルと異なるサービスが、無リプレイ保護に再生することができ共通リプレイキャッシュ。"
    },
    {
      "indent": 3,
      "text": "If a sequence number is provided in the authenticator, the server saves it for later use in processing KRB_SAFE and/or KRB_PRIV messages. If a subkey is present, the server either saves it for later use or uses it to help generate its own choice for a subkey to be returned in a KRB_AP_REP message.",
      "ja": "シーケンス番号はオーセンティケータに提供されている場合、サーバは処理KRB_SAFEおよび/またはKRB_PRIVメッセージで後で使用するために保存します。サブキーが存在する場合、サーバは、後で使用するためにそれを保存したりKRB_AP_REPメッセージで返されるサブキーの独自の選択肢を生成を助けるためにそれを使用してのいずれか。"
    },
    {
      "indent": 3,
      "text": "The server computes the age of the ticket: local (server) time minus the starttime inside the Ticket. If the starttime is later than the current time by more than the allowable clock skew, or if the INVALID flag is set in the ticket, the KRB_AP_ERR_TKT_NYV error is returned. Otherwise, if the current time is later than end time by more than the allowable clock skew, the KRB_AP_ERR_TKT_EXPIRED error is returned.",
      "ja": "ローカル（サーバー）の時間マイナスチケット内側STARTTIME：サーバーは、チケットの年齢を計算します。 STARTTIMEが許容クロック・スキューよりも多くのことで、現在の時刻より後であれば無効フラグがチケットに設定されている場合、または、KRB_AP_ERR_TKT_NYVエラーが返されます。現在の時刻が許容クロック・スキューよりも多くすることにより終了時間よりもそれ以外の場合、KRB_AP_ERR_TKT_EXPIREDエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If all these checks succeed without an error, the server is assured that the client possesses the credentials of the principal named in the ticket, and thus, that the client has been authenticated to the server.",
      "ja": "すべてのこれらのチェックがエラーなしで成功した場合、サーバは、クライアントがサーバーに認証されたことを、これチケットで指定された主体の資格、および所有していることが保証されます。"
    },
    {
      "indent": 3,
      "text": "Passing these checks provides only authentication of the named principal; it does not imply authorization to use the named service. Applications MUST make a separate authorization decision based upon the authenticated name of the user, the requested operation, local access control information such as that contained in a .k5login or .k5users file, and possibly a separate distributed authorization service.",
      "ja": "これらのチェックを渡すと、名前のプリンシパルの認証のみを提供します。それは名前のサービスを使用する許可を意味するものではありません。アプリケーションは、このような.k5loginをか.k5usersファイルに含まれているように、ユーザー、要求された操作、ローカルアクセス制御情報の認証された名前に基づいて、別の許可決定を行い、そしておそらく別の分散型認証サービスしなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2.4. Generation of a KRB_AP_REP Message",
      "section_title": true,
      "ja": "3.2.4.  KRB_AP_REPメッセージの生成"
    },
    {
      "indent": 3,
      "text": "Typically, a client's request will include both the authentication information and its initial request in the same message, and the server need not explicitly reply to the KRB_AP_REQ. However, if mutual authentication (authenticating not only the client to the server, but also the server to the client) is being performed, the KRB_AP_REQ message will have MUTUAL-REQUIRED set in its ap-options field, and a KRB_AP_REP message is required in response. As with the error message, this message MAY be encapsulated in the application protocol if its \"raw\" form is not acceptable to the application's protocol. The timestamp and microsecond field used in the reply MUST be the client's timestamp and microsecond field (as provided in the authenticator). If a sequence number is to be included, it SHOULD be randomly chosen as described above for the authenticator. A subkey MAY be included if the server desires to negotiate a different subkey. The KRB_AP_REP message is encrypted in the session key extracted from the ticket.",
      "ja": "一般的に、クライアントの要求は、認証情報と同じメッセージでその初期の要求、および明示的にKRB_AP_REQに答える必要はありませんサーバーの両方が含まれます。相互認証（サーバーへのクライアントだけでなくを認証するだけでなく、クライアントへのサーバ）が実行されている場合は、KRB_AP_REQメッセージは、そのAP-オプションフィールドにMUTUAL-REQUIREDセットを持っていますし、KRB_AP_REPメッセージがで必要とされます応答。その「生」フォームは、アプリケーションのプロトコルに許容されない場合は、エラーメッセージと同様に、このメッセージは、アプリケーションプロトコルでカプセル化され得ます。 （オーセンティケータに提供される）応答で使用されるタイムスタンプとマイクロセカンド分野は、クライアントのタイムスタンプとマイクロフィールドでなければなりません。シーケンス番号が含まれる場合、オーセンティケータのために上述したように、それがランダムに選択されるべきです。サーバが別のサブキーを交渉することを希望する場合はサブキーが含まれるかもしれません。 KRB_AP_REPメッセージがチケットから抽出したセッション鍵で暗号化されています。"
    },
    {
      "indent": 3,
      "text": "Note that in the Kerberos Version 4 protocol, the timestamp in the reply was the client's timestamp plus one. This is not necessary in Version 5 because Version 5 messages are formatted in such a way that it is not possible to create the reply by judicious message surgery (even in encrypted form) without knowledge of the appropriate encryption keys.",
      "ja": "Kerberosバージョン4プロトコルでは、応答のタイムスタンプは、クライアントのタイムスタンプを加えたものであったことに注意してください。バージョン5メッセージは、適切な暗号化キーの知識がなくても（でも、暗号化された形で）賢明なメッセージ手術による返信を作成することはできないような方法でフォーマットされているので、これはバージョン5には必要ありません。"
    },
    {
      "indent": 0,
      "text": "3.2.5. Receipt of KRB_AP_REP Message",
      "section_title": true,
      "ja": "3.2.5.  KRB_AP_REPメッセージの受信"
    },
    {
      "indent": 3,
      "text": "If a KRB_AP_REP message is returned, the client uses the session key from the credentials obtained for the server to decrypt the message and verifies that the timestamp and microsecond fields match those in the Authenticator it sent to the server. If they match, then the client is assured that the server is genuine. The sequence number and subkey (if present) are retained for later use. (Note that for encrypting the KRB_AP_REP message, the sub-session key is not used, even if it is present in the Authentication.)",
      "ja": "KRB_AP_REPメッセージが返された場合、クライアントはメッセージを復号化するために、サーバー用に取得した資格情報からセッション鍵を使用して、タイムスタンプとマイクロセカンド分野は、それがサーバーに送信されたオーセンティケータのものと一致することを確認します。それらが一致する場合、クライアントはサーバーが本物であることが保証されます。シーケンス番号とサブキー（存在する場合）は、後の使用のために保持されます。 （KRB_AP_REPメッセージを暗号化するために、サブセッションキーは、認証に存在する場合であっても、使用されないことに注意してください。）"
    },
    {
      "indent": 0,
      "text": "3.2.6. Using the Encryption Key",
      "section_title": true,
      "ja": "3.2.6. 暗号化キーを使用して"
    },
    {
      "indent": 3,
      "text": "After the KRB_AP_REQ/KRB_AP_REP exchange has occurred, the client and server share an encryption key that can be used by the application. In some cases, the use of this session key will be implicit in the protocol; in others the method of use must be chosen from several alternatives. The application MAY choose the actual encryption key to be used for KRB_PRIV, KRB_SAFE, or other application-specific uses based on the session key from the ticket and subkeys in the KRB_AP_REP message and the authenticator. Implementations of the protocol MAY provide routines to choose subkeys based on session keys and random numbers and to generate a negotiated key to be returned in the KRB_AP_REP message.",
      "ja": "KRB_AP_REQ / KRB_AP_REP交換が行われた後、クライアントとサーバーの共有アプリケーションで使用できる暗号化キー。いくつかのケースでは、このセッションキーの使用はプロトコルで暗黙的になります。他人に使用する方法はいくつかの選択肢から選択する必要があります。アプリケーションがKRB_PRIV、KRB_SAFE、またはKRB_AP_REPメッセージとオーセンティケータでチケットとサブキーからのセッションキーに基づいて、他のアプリケーション固有の用途に使用される実際の暗号化キーを選択することができます。プロトコルの実装は、セッション鍵と乱数に基づいてサブキーを選択すると、KRB_AP_REPメッセージで返される交渉さの鍵を生成するためのルーチンを提供することができます。"
    },
    {
      "indent": 3,
      "text": "To mitigate the effect of failures in random number generation on the client, it is strongly encouraged that any key derived by an application for subsequent use include the full key entropy derived from the KDC-generated session key carried in the ticket. We leave the protocol negotiations of how to use the key (e.g., for selecting an encryption or checksum type) to the application programmer. The Kerberos protocol does not constrain the implementation options, but an example of how this might be done follows.",
      "ja": "クライアント上の乱数生成の障害の影響を軽減するために、強く、その後の使用のために、アプリケーションによって派生した任意のキーがチケットに運ばKDC-生成したセッション鍵から導出フルキーのエントロピーが含まれていることを奨励しています。私たちは、アプリケーションプログラマに（例えば、暗号化またはチェックサムタイプを選択するための）キーを使用する方法のプロトコルの交渉を残します。 Kerberosプロトコルが実装オプションを制限しませんが、これが行われるかもしれない方法の例を以下に示します。"
    },
    {
      "indent": 3,
      "text": "One way that an application may choose to negotiate a key to be used for subsequent integrity and privacy protection is for the client to propose a key in the subkey field of the authenticator. The server can then choose a key using the key proposed by the client as input, returning the new subkey in the subkey field of the application reply. This key could then be used for subsequent communication.",
      "ja": "アプリケーションは、その後の整合性とプライバシー保護のために使用する鍵を交渉することを選択することが一つの方法は、オーセンティケータのサブキーフィールドのキーを提案するために、クライアントのためです。その後、サーバは、アプリケーションの応答のサブキーフィールドに新しいサブキーを返し、入力としてクライアントによって提案されたキーを使用してキーを選択することができます。このキーは、その後の通信のために使用することができます。"
    },
    {
      "indent": 3,
      "text": "With both the one-way and mutual authentication exchanges, the peers should take care not to send sensitive information to each other without proper assurances. In particular, applications that require privacy or integrity SHOULD use the KRB_AP_REP response from the server to the client to assure both client and server of their peer's identity. If an application protocol requires privacy of its messages, it can use the KRB_PRIV message (section 3.5). The KRB_SAFE message (Section 3.4) can be used to ensure integrity.",
      "ja": "一方向および相互認証交換の両方を使用すると、ピアは、適切な保証なしで相互に機密情報を送信しないように注意する必要があります。具体的には、プライバシーや整合性を必要とするアプリケーションは、そのピアのアイデンティティのクライアントとサーバーの両方を保証するために、サーバからクライアントにKRB_AP_REP応答を使用すべきです。アプリケーションプロトコルは、そのメッセージのプライバシーを必要とする場合、それはKRB_PRIVメッセージ（セクション3.5）を使用することができます。 KRB_SAFEメッセージ（3.4節）は、整合性を確保するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.3. The Ticket-Granting Service (TGS) Exchange",
      "section_title": true,
      "ja": "3.3. チケット認可サービス（TGS）交換"
    },
    {
      "indent": 29,
      "text": "Summary",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "Message direction Message type Section 1. Client to Kerberos KRB_TGS_REQ 5.4.1 2. Kerberos to client KRB_TGS_REP or 5.4.2 KRB_ERROR 5.9.1",
      "ja": "ケルベロスKRB_TGS_REQへのメッセージ方向メッセージタイプセクション1.クライアント5.4.1 2.ケルベロスクライアントKRB_TGS_REPまたは5.4.2 KRB_ERROR 5.9.1へ"
    },
    {
      "indent": 3,
      "text": "The TGS exchange between a client and the Kerberos TGS is initiated by a client when it seeks to obtain authentication credentials for a given server (which might be registered in a remote realm), when it seeks to renew or validate an existing ticket, or when it seeks to obtain a proxy ticket. In the first case, the client must already have acquired a ticket for the Ticket-Granting Service using the AS exchange (the TGT is usually obtained when a client initially authenticates to the system, such as when a user logs in). The message format for the TGS exchange is almost identical to that for the AS exchange. The primary difference is that encryption and decryption in the TGS exchange does not take place under the client's key. Instead, the session key from the TGT or renewable ticket, or sub-session key from an Authenticator is used. As is the case for all application servers, expired tickets are not accepted by the TGS, so once a renewable or TGT expires, the client must use a separate exchange to obtain valid tickets.",
      "ja": "クライアントとKerberos TGSの間TGS交換は、それが（リモート領域に登録される可能性があります）指定されたサーバの認証資格情報を取得しようとするとき、それは既存のチケットを更新するか検証しようとするとき、クライアントによって開始されたとき、またはされますそれは、プロキシチケットを取得しようとしています。最初のケースでは、クライアントがすでに（クライアントが最初にシステムに認証するときにTGTは、通常、ユーザがログインするときのように、得られた）AS交換を使用してチケット認可サービスのチケットを取得している必要があります。 TGS交換のためのメッセージフォーマットは、AS交換とほぼ同じです。主な違いは、TGS交換における暗号化と復号化は、クライアントのキーの下に行われないということです。代わりに、TGTまたは再生可能なチケット、または認証からサブセッションキーからセッションキーが使用されています。すべてのアプリケーション・サーバーの場合のように、有効期限が切れたチケットはTGSによって受け入れられていないため、再生可能またはTGTの有効期限が切れた後は、クライアントが有効なチケットを取得するために別の交換を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The TGS exchange consists of two messages: a request (KRB_TGS_REQ) from the client to the Kerberos Ticket-Granting Server, and a reply (KRB_TGS_REP or KRB_ERROR). The KRB_TGS_REQ message includes information authenticating the client plus a request for credentials. The authentication information consists of the authentication header (KRB_AP_REQ), which includes the client's previously obtained ticket-granting, renewable, or invalid ticket. In the TGT and proxy cases, the request MAY include one or more of the following: a list of network addresses, a collection of typed authorization data to be sealed in the ticket for authorization use by the application server, or additional tickets (the use of which are described later). The TGS reply (KRB_TGS_REP) contains the requested credentials, encrypted in the session key from the TGT or renewable ticket, or, if present, in the sub-session key from the Authenticator (part of the authentication header). The KRB_ERROR message contains an error code and text explaining what went wrong. The KRB_ERROR message is not encrypted. The KRB_TGS_REP message contains information that can be used to detect replays, and to associate it with the message to which it replies. The KRB_ERROR message also contains information that can be used to associate it with the message to which it replies. The same comments about integrity protection of KRB_ERROR messages mentioned in Section 3.1 apply to the TGS exchange.",
      "ja": "Kerberosのチケット許可サーバーへのクライアントからの要求（KRB_TGS_REQ）、および返信（KRB_TGS_REPまたはKRB_ERROR）：TGS交換は二つのメッセージで構成されています。 KRB_TGS_REQメッセージは、クライアントプラス資格証明書の要求を認証する情報を含んでいます。認証情報は、クライアントの以前に得られたチケット許可、再生可能な、または無効なチケットを含む認証ヘッダー（KRB_AP_REQ）、から成ります。ネットワークアドレスのリスト、アプリケーションサーバによる認証用のチケット内に密封することが入力された認証データ、または追加のチケットの収集（使用：TGTとプロキシのケースでは、要求は、次の一つ以上を含むことができますそのうち）後述します。 TGS応答（KRB_TGS_REP）は、オーセンティケータ（認証ヘッダの一部）からのサブセッション鍵で要求されたTGTまたは再生可能なチケットからセッション鍵で暗号化された資格情報、または、存在する場合に、含まれています。 KRB_ERRORメッセージは、何が悪かったのかを説明するエラーコードとテキストが含まれています。 KRB_ERRORメッセージは暗号化されていません。 KRB_TGS_REPメッセージは、リプレイを検出するために、それが応答したメッセージに関連付けるために使用することができる情報を含みます。 KRB_ERRORメッセージはまた、返信するメッセージに関連付けるために使用することができる情報を含みます。 3.1節で述べたKRB_ERRORメッセージの完全性保護に関する同じコメントがTGS交換に適用されます。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Generation of KRB_TGS_REQ Message",
      "section_title": true,
      "ja": "3.3.1.  KRB_TGS_REQメッセージの生成"
    },
    {
      "indent": 3,
      "text": "Before sending a request to the ticket-granting service, the client MUST determine in which realm the application server is believed to be registered. This can be accomplished in several ways. It might be known beforehand (since the realm is part of the principal identifier), it might be stored in a nameserver, or it might be obtained from a configuration file. If the realm to be used is obtained from a nameserver, there is a danger of being spoofed if the nameservice providing the realm name is not authenticated. This might result in the use of a realm that has been compromised, which would result in an attacker's ability to compromise the authentication of the application server to the client.",
      "ja": "チケット認可サービスに要求を送信する前に、クライアントは、アプリケーションサーバが登録されると考えられている分野で決定する必要があります。これは、いくつかの方法で達成することができます。 （レルムは、プリンシパル識別子の一部であるので）、それは事前に知られているかもしれない、それは、ネームサーバに格納されている可能性があり、またはそれは、構成ファイルから取得されるかもしれません。使用するレルムがネームサーバから取得された場合は、レルム名を提供するネームサービスが認証されていない場合は詐称されている危険性があります。これは、クライアントへのアプリケーションサーバーの認証を危うくする攻撃者の能力につながる危険にさらされているレルムを使用することになる可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the client knows the service principal name and realm and it does not already possess a TGT for the appropriate realm, then one must be obtained. This is first attempted by requesting a TGT for the destination realm from a Kerberos server for which the client possesses a TGT (by using the KRB_TGS_REQ message recursively). The",
      "ja": "クライアントがサービスプリンシパル名とレルムを知っていて、それがすでに適切なレルムのためにTGTを持たない場合は、1を取得する必要があります。これは、最初のクライアントが（KRB_TGS_REQメッセージ再帰を使用して）TGTを持っているKerberosサーバから宛先レルムのTGTを要求することによって試みられます。ザ・"
    },
    {
      "indent": 3,
      "text": "Kerberos server MAY return a TGT for the desired realm, in which case one can proceed. Alternatively, the Kerberos server MAY return a TGT for a realm that is 'closer' to the desired realm (further along the standard hierarchical path between the client's realm and the requested realm server's realm). Note that in this case misconfiguration of the Kerberos servers may cause loops in the resulting authentication path, which the client should be careful to detect and avoid.",
      "ja": "Kerberosサーバは1つが進行することができ、その場合に、所望の領域のためにTGTを返すことができます。また、Kerberosサーバは（さらに、クライアントのレルムと要求されたレルムサーバーのレルム間の標準階層パスに沿って）希望分野に「近い」ですレルムのTGTを返す場合があります。この場合にはKerberosサーバの設定ミスは、クライアントが検出しないように注意する必要がありますその結果、認証パスにループを引き起こす可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the Kerberos server returns a TGT for a realm 'closer' than the desired realm, the client MAY use local policy configuration to verify that the authentication path used is an acceptable one. Alternatively, a client MAY choose its own authentication path, rather than rely on the Kerberos server to select one. In either case, any policy or configuration information used to choose or validate authentication paths, whether by the Kerberos server or by the client, MUST be obtained from a trusted source.",
      "ja": "Kerberosサーバが所望の領域よりも「より近い」レルムのTGTを返した場合、クライアントは、使用される認証パスは許容されるものであることを確認するために、ローカルポリシー設定を使用するかもしれません。また、クライアントは、独自の認証パスを選択するのではなく、いずれかを選択するためにKerberosサーバに依存してもよいです。いずれの場合においても、選択するか、認証パスを検証するために使用される任意のポリシーまたは設定情報は、Kerberosサーバによって、またはクライアントによってかどうか、信頼できるソースから取得しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a client obtains a TGT that is 'closer' to the destination realm, the client MAY cache this ticket and reuse it in future KRB-TGS exchanges with services in the 'closer' realm. However, if the client were to obtain a TGT for the 'closer' realm by starting at the initial KDC rather than as part of obtaining another ticket, then a shorter path to the 'closer' realm might be used. This shorter path may be desirable because fewer intermediate KDCs would know the session key of the ticket involved. For this reason, clients SHOULD evaluate whether they trust the realms transited in obtaining the 'closer' ticket when making a decision to use the ticket in future.",
      "ja": "クライアントは、宛先レルムに「近い」ですTGTを取得すると、クライアントはこのチケットをキャッシュし、「近い」分野でのサービスとの将来KRB-TGS交換にそれを再利用することができます。クライアントが最初のKDCから始まることではなく、別のチケットを取得するの一環として、「近い」レルムのTGTを取得した場合しかし、その後、「近い」分野への短いパスが使用される可能性があります。少数の中間のKDCが関与チケットのセッション・キーを知っているだろうので、これより短い経路が望ましいかもしれません。このため、クライアントは、彼らが将来的にチケットを使用するための意思決定をする際に「近い」チケットを取得するに遷移レルムを信頼するかどうかを評価する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once the client obtains a TGT for the appropriate realm, it determines which Kerberos servers serve that realm and contacts one of them. The list might be obtained through a configuration file or network service, or it MAY be generated from the name of the realm. As long as the secret keys exchanged by realms are kept secret, only denial of service results from using a false Kerberos server.",
      "ja": "クライアントは、適切なレルムのためのTGTを取得したら、それは、Kerberosサーバがその領域との接点それらのいずれかを提供するかを決定します。リストには、設定ファイルやネットワークサービスを介して取得される可能性があります、またはそれは、レルムの名前から生成することができます。限りレルムによって交換された秘密鍵として偽のKerberosサーバを使用してから、サービスの結果の唯一の否定、秘密にされています。"
    },
    {
      "indent": 3,
      "text": "As in the AS exchange, the client MAY specify a number of options in the KRB_TGS_REQ message. One of these options is the ENC-TKT-IN-SKEY option used for user-to-user authentication. An overview of user-to-user authentication can be found in Section 3.7. When generating the KRB_TGS_REQ message, this option indicates that the client is including a TGT obtained from the application server in the additional tickets field of the request and that the KDC SHOULD encrypt the ticket for the application server using the session key from this additional ticket, instead of a server key from the principal database.",
      "ja": "AS交換のように、クライアントはKRB_TGS_REQメッセージ内のオプションの数を指定することができます。これらのオプションの一つは、ユーザ・ユーザ認証に使用するENC-TKT-IN-SKEYオプションです。ユーザ・ユーザ認証の概要については、3.7節に記載されています。 KRB_TGS_REQメッセージを生成する場合、このオプションは、クライアントがTGTを要求の追加チケットフィールドに、アプリケーション・サーバから取得し、KDCは、この追加のチケットからセッションキーを使用して、アプリケーション・サーバーのためのチケットを暗号化すべきであるということを含めていることを示しています代わりに、プリンシパルデータベースからサーバキーの。"
    },
    {
      "indent": 3,
      "text": "The client prepares the KRB_TGS_REQ message, providing an authentication header as an element of the padata field, and including the same fields as used in the KRB_AS_REQ message along with several optional fields: the enc-authorizatfion-data field for application server use and additional tickets required by some options.",
      "ja": "アプリケーションサーバの使用と追加チケットのENC-authorizatfionデータフィールド：クライアントがPADATAフィールドの要素として認証ヘッダーを提供し、いくつかのオプションフィールドと共にKRB_AS_REQメッセージで使用されるのと同じフィールドを含む、KRB_TGS_REQメッセージを準備しますいくつかのオプションで必要とされます。"
    },
    {
      "indent": 3,
      "text": "In preparing the authentication header, the client can select a sub-session key under which the response from the Kerberos server will be encrypted. If the client selects a sub-session key, care must be taken to ensure the randomness of the selected sub-session key.",
      "ja": "認証ヘッダを調製する際に、クライアントは、Kerberosサーバからの応答が暗号化されるの下でサブセッションキーを選択することができます。クライアントは、サブセッションキーを選択した場合、注意が選択されたサブセッションキーのランダム性を確保するために注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the sub-session key is not specified, the session key from the TGT will be used. If the enc-authorization-data is present, it MUST be encrypted in the sub-session key, if present, from the authenticator portion of the authentication header, or, if not present, by using the session key from the TGT.",
      "ja": "サブセッションキーが指定されていない場合は、TGTからのセッションキーが使用されます。 ENC-許可データが存在する場合、それはTGTからセッション鍵を用いて、現在存在している場合は、認証ヘッダのオーセンティケータ部分から、サブセッション鍵で暗号化、または、そうでない場合れなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once prepared, the message is sent to a Kerberos server for the destination realm.",
      "ja": "用意したら、メッセージは、宛先レルムのKerberosサーバに送信されます。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Receipt of KRB_TGS_REQ Message",
      "section_title": true,
      "ja": "3.3.2.  KRB_TGS_REQメッセージの受信"
    },
    {
      "indent": 3,
      "text": "The KRB_TGS_REQ message is processed in a manner similar to the KRB_AS_REQ message, but there are many additional checks to be performed. First, the Kerberos server MUST determine which server the accompanying ticket is for, and it MUST select the appropriate key to decrypt it. For a normal KRB_TGS_REQ message, it will be for the ticket-granting service, and the TGS's key will be used. If the TGT was issued by another realm, then the appropriate inter-realm key MUST be used. If (a) the accompanying ticket is not a TGT for the current realm, but is for an application server in the current realm, (b) the RENEW, VALIDATE, or PROXY options are specified in the request, and (c) the server for which a ticket is requested is the server named in the accompanying ticket, then the KDC will decrypt the ticket in the authentication header using the key of the server for which it was issued. If no ticket can be found in the padata field, the KDC_ERR_PADATA_TYPE_NOSUPP error is returned.",
      "ja": "KRB_TGS_REQメッセージはKRB_AS_REQメッセージと同様に処理されるが、実行される多くの付加的なチェックがあります。まず、Kerberosサーバは、添付のチケットがためにあるサーバーを決定しなければならない、そしてそれは、それを復号化するための適切なキーを選択する必要があります。通常のKRB_TGS_REQメッセージの場合は、チケット認可サービスのためになり、およびTGSのキーが使用されます。 TGTが別のレルムによって発行された場合には、適切なレルム間のキーを使用しなければなりません。 （a）は、付随するチケットは、現在のレルムTGTではなく、現在のレルム内のアプリケーションサーバーのためのものである場合、（b）は、VALIDATEの更新、またはPROXYオプションが要求で指定され、および（c）サーバチケットが要求されている付属のチケットで指定されたサーバーである場合、KDCは、それが発行されたサーバーのキーを使用して認証ヘッダーでチケットを復号化します。何のチケットがPADATAフィールドに見つからない場合、KDC_ERR_PADATA_TYPE_NOSUPPエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Once the accompanying ticket has been decrypted, the user-supplied checksum in the Authenticator MUST be verified against the contents of the request, and the message MUST be rejected if the checksums do not match (with an error code of KRB_AP_ERR_MODIFIED) or if the checksum is not collision-proof (with an error code of KRB_AP_ERR_INAPP_CKSUM). If the checksum type is not supported, the KDC_ERR_SUMTYPE_NOSUPP error is returned. If the authorization-data are present, they are decrypted using the sub-session key from the Authenticator.",
      "ja": "付随するチケットを復号化された後、認証におけるユーザ供給のチェックサムは、要求の内容と照合しなければならない、及びチェックサムが（KRB_AP_ERR_MODIFIEDのエラーコードで）一致しない場合、メッセージは拒否されなければならない場合、またはチェックサム衝突防止（KRB_AP_ERR_INAPP_CKSUMのエラーコード）がありません。チェックサムのタイプがサポートされていない場合、KDC_ERR_SUMTYPE_NOSUPPエラーが返されます。認証データが存在する場合、それらはオーセンティケータからサブセッションキーを使用して復号化されます。"
    },
    {
      "indent": 3,
      "text": "If any of the decryptions indicate failed integrity checks, the KRB_AP_ERR_BAD_INTEGRITY error is returned.",
      "ja": "デクリプションのいずれかが失敗した整合性チェックを示している場合、KRB_AP_ERR_BAD_INTEGRITYエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 3.1.2, the KDC MUST send a valid KRB_TGS_REP message if it receives a KRB_TGS_REQ message identical to one it has recently processed. However, if the authenticator is a replay, but the rest of the request is not identical, then the KDC SHOULD return KRB_AP_ERR_REPEAT.",
      "ja": "3.1.2項で説明したように、それはそれは、最近処理したものと同一のKRB_TGS_REQメッセージを受信した場合、KDCは、有効なKRB_TGS_REPメッセージを送らなければなりません。オーセンティケータが再生されますが、要求の残りの部分が同一でない場合は、その後、KDCはKRB_AP_ERR_REPEATを返すべきです。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Generation of KRB_TGS_REP Message",
      "section_title": true,
      "ja": "3.3.3.  KRB_TGS_REPメッセージの生成"
    },
    {
      "indent": 3,
      "text": "The KRB_TGS_REP message shares its format with the KRB_AS_REP (KRB_KDC_REP), but with its type field set to KRB_TGS_REP. The detailed specification is in Section 5.4.2.",
      "ja": "KRB_TGS_REPメッセージはKRB_AS_REP（KRB_KDC_REP）とそのフォーマットを共有するが、そのタイプフィールドはKRB_TGS_REPに設定されています。詳細な仕様は、セクション5.4.2です。"
    },
    {
      "indent": 3,
      "text": "The response will include a ticket for the requested server or for a ticket granting server of an intermediate KDC to be contacted to obtain the requested ticket. The Kerberos database is queried to retrieve the record for the appropriate server (including the key with which the ticket will be encrypted). If the request is for a TGT for a remote realm, and if no key is shared with the requested realm, then the Kerberos server will select the realm 'closest' to the requested realm with which it does share a key and use that realm instead. This is the only case where the response for the KDC will be for a different server than that requested by the client.",
      "ja": "応答が要求されたチケットを取得するために連絡することを要求し、サーバ用または中間KDCのチケット付与サーバのチケットが含まれます。 Kerberosデータベースは（チケットが暗号化されると、キーを含む）適切なサーバーのレコードを取得するために照会されます。要求は、リモートレルム用のTGTのためのものであり、キーが要求されたレルムと共有されていない場合は、Kerberosサーバは、それが鍵を共有し、代わりにそのレルムを使用していたとレルムを要求されたレルムに「最も近い」を選択する場合は。これは、KDCの応答がクライアントによって要求されたものとは異なるサーバー用になります唯一のケースです。"
    },
    {
      "indent": 3,
      "text": "By default, the address field, the client's name and realm, the list of transited realms, the time of initial authentication, the expiration time, and the authorization data of the newly-issued ticket will be copied from the TGT or renewable ticket. If the transited field needs to be updated, but the transited type is not supported, the KDC_ERR_TRTYPE_NOSUPP error is returned.",
      "ja": "デフォルトでは、アドレスフィールド、クライアントの名前とレルム、遷移レルムのリスト、初期認証の際、有効期限、および新たに発行されたチケットの承認データは、TGTまたは再生可能なチケットからコピーされます。通過している分野を更新する必要があるが、遷移タイプがサポートされていない場合、KDC_ERR_TRTYPE_NOSUPPエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If the request specifies an endtime, then the endtime of the new ticket is set to the minimum of (a) that request, (b) the endtime from the TGT, and (c) the starttime of the TGT plus the minimum of the maximum life for the application server and the maximum life for the local realm (the maximum life for the requesting principal was already applied when the TGT was issued). If the new ticket is to be a renewal, then the endtime above is replaced by the minimum of (a) the value of the renew_till field of the ticket and (b) the starttime for the new ticket plus the life (endtime-starttime) of the old ticket.",
      "ja": "要求は終了時刻を指定している場合、新しいチケットの終了時刻は、（a）は、その要求の最小値に設定されている、（b）はTGTから終了時刻、および（c）TGTのSTARTTIMEプラス最大の最小アプリケーションサーバおよびローカルレルムの最大の人生の生活（要求主体の最大寿命はすでにTGTが発行されたときに適用されました）。新しいチケットが更新される場合、終了時刻は、上記の最小値に置き換えられる（a）のチケットとのrenew_tillフィールドの値（b）は、新たなチケットプラスライフ（終了時刻-STARTTIME）のためのSTARTTIME古いチケットの。"
    },
    {
      "indent": 3,
      "text": "If the FORWARDED option has been requested, then the resulting ticket will contain the addresses specified by the client. This option will only be honored if the FORWARDABLE flag is set in the TGT. The PROXY option is similar; the resulting ticket will contain the addresses specified by the client. It will be honored only if the PROXIABLE flag in the TGT is set. The PROXY option will not be honored on requests for additional TGTs.",
      "ja": "FORWARDEDオプションが要求されている場合は、その結果のチケットは、クライアントによって指定されたアドレスが含まれています。 FORWARDABLEフラグがTGTに設定されている場合、このオプションは光栄されます。 PROXYオプションは似ています。結果のチケットは、クライアントによって指定されたアドレスが含まれています。 TGTでPROXIABLEフラグが設定されている場合にのみ表彰されます。 PROXYオプションは追加のTGTの要求に表彰されることはありません。"
    },
    {
      "indent": 3,
      "text": "If the requested starttime is absent, indicates a time in the past, or is within the window of acceptable clock skew for the KDC and the POSTDATE option has not been specified, then the starttime of the ticket is set to the authentication server's current time. If it indicates a time in the future beyond the acceptable clock skew, but the POSTDATED option has not been specified or the MAY-POSTDATE flag is not set in the TGT, then the error KDC_ERR_CANNOT_POSTDATE is returned. Otherwise, if the TGT has the MAY-POSTDATE flag set, then the resulting ticket will be postdated, and the requested starttime is checked against the policy of the local realm. If acceptable, the ticket's starttime is set as requested, and the INVALID flag is set. The postdated ticket MUST be validated before use by presenting it to the KDC after the starttime has been reached. However, in no case may the starttime, endtime, or renew-till time of a newly-issued postdated ticket extend beyond the renew-till time of the TGT.",
      "ja": "要求されたSTARTTIMEが存在しない場合は、過去の時間を示し、またはKDCのために許容可能なクロック・スキューのウィンドウ内にあり、POSTDATEオプションが指定されていない場合、チケットのSTARTTIMEは、認証サーバの現在の時間に設定されています。それが許容クロック・スキューを超えた未来の時間を示しますが、POSTDATEDオプションが指定されていないか、MAY-POSTDATEフラグがTGTに設定されていない場合、エラーKDC_ERR_CANNOT_POSTDATEが返されます。 TGTは、MAY-POSTDATEフラグが設定されている場合はそうでない場合は、その結果のチケットが先日付を書かされ、要求されたSTARTTIMEは、地元の分野の方針に対してチェックされます。許容可能な場合は、チケットのSTARTTIMEは、要求として設定され、無効なフラグが設定されています。遅延チケットはSTARTTIMEに達した後KDCにそれを提示することによって、使用前に検証されなければなりません。ただし、いかなる場合にSTARTTIME、終了時刻、または更新-まで、新たに発行された遅延チケットの時間TGTの更新-までの時間を超えて延長することができます。"
    },
    {
      "indent": 3,
      "text": "If the ENC-TKT-IN-SKEY option has been specified and an additional ticket has been included in the request, it indicates that the client is using user-to-user authentication to prove its identity to a server that does not have access to a persistent key. Section 3.7 describes the effect of this option on the entire Kerberos protocol. When generating the KRB_TGS_REP message, this option in the KRB_TGS_REQ message tells the KDC to decrypt the additional ticket using the key for the server to which the additional ticket was issued and to verify that it is a TGT. If the name of the requested server is missing from the request, the name of the client in the additional ticket will be used. Otherwise, the name of the requested server will be compared to the name of the client in the additional ticket. If it is different, the request will be rejected. If the request succeeds, the session key from the additional ticket will be used to encrypt the new ticket that is issued instead of using the key of the server for which the new ticket will be used.",
      "ja": "ENC-TKT-IN-SKEYオプションが指定されていて、追加のチケットが要求に含まれている場合、それは、クライアントがアクセス権を持っていないサーバーにその身元を証明するためにユーザ・ユーザ認証を使用していることを示し永続キー。 3.7節は全体Kerberosプロトコルでこのオプションの効果を説明します。 KRB_TGS_REPメッセージを生成するとき、KRB_TGS_REQメッセージでこのオプションは、追加のチケットが発行され、それがTGTであることを確認しているサーバのキーを使用して追加のチケットを解読するためにKDCに指示します。要求されたサーバの名前が要求から欠落している場合、追加のチケットで、クライアントの名前が使用されます。それ以外の場合は、要求されたサーバーの名前は、追加のチケットにクライアント名と比較されます。それは異なっている場合、要求は拒否されます。リクエストが成功した場合、追加チケットから主要なセッションは、新しいチケットが使用されるため、サーバのキーを使用する代わりに発行された新しいチケットを暗号化するために使用されます。"
    },
    {
      "indent": 3,
      "text": "If (a) the name of the server in the ticket that is presented to the KDC as part of the authentication header is not that of the TGS itself, (b) the server is registered in the realm of the KDC, and (c) the RENEW option is requested, then the KDC will verify that the RENEWABLE flag is set in the ticket, that the INVALID flag is not set in the ticket, and that the renew_till time is still in the future. If the VALIDATE option is requested, the KDC will check that the starttime has passed and that the INVALID flag is set. If the PROXY option is requested, then the KDC will check that the PROXIABLE flag is set in the ticket. If the tests succeed and the ticket passes the hotlist check described in the next section, the KDC will issue the appropriate new ticket.",
      "ja": "（a）は、認証ヘッダーの一部としてKDCに提示されたチケット内のサーバの名前は、TGS自体のものでない場合、（b）は、サーバーはKDCの領域に登録されている、および（c） RENEWオプションが要求され、その後、KDCは、再生可能フラグが無効フラグがチケットに設定されていないことを、チケットに設定し、renew_till時間が将来的にまだあるとされていることを確認します。 VALIDATEオプションが要求された場合、KDCはSTARTTIMEが経過したとし、無効フラグが設定されていることを確認します。 PROXYオプションが要求された場合、KDCはPROXIABLEフラグがチケットに設定されていることを確認します。テストが成功すると、チケットは次のセクションで説明したホットリストのチェックを通過した場合、KDCは、適切な新しいチケットを発行します。"
    },
    {
      "indent": 3,
      "text": "The ciphertext part of the response in the KRB_TGS_REP message is encrypted in the sub-session key from the Authenticator, if present, or in the session key from the TGT. It is not encrypted using the client's secret key. Furthermore, the client's key's expiration date and the key version number fields are left out since these values are stored along with the client's database record, and that record is not needed to satisfy a request based on a TGT.",
      "ja": "KRB_TGS_REPメッセージにおける応答の暗号文部分が存在する場合、又はTGTからセッションキーに、オーセンティケータからのサブセッション鍵で暗号化されています。これは、クライアントの秘密鍵を使って暗号化されていません。これらの値は、クライアントのデータベースレコードと一緒に保存され、そのレコードがTGTに基づいて要求を満たすために必要されていないので、クライアントの鍵の有効期限と鍵のバージョン番号フィールドは省略されています。"
    },
    {
      "indent": 0,
      "text": "3.3.3.1. Checking for Revoked Tickets",
      "section_title": true,
      "ja": "3.3.3.1。取り消されたチケットの確認"
    },
    {
      "indent": 3,
      "text": "Whenever a request is made to the ticket-granting server, the presented ticket(s) is (are) checked against a hot-list of tickets that have been canceled. This hot-list might be implemented by storing a range of issue timestamps for 'suspect tickets'; if a presented ticket had an authtime in that range, it would be rejected. In this way, a stolen TGT or renewable ticket cannot be used to gain additional tickets (renewals or otherwise) once the theft has been reported to the KDC for the realm in which the server resides. Any normal ticket obtained before it was reported stolen will still be valid (because tickets require no interaction with the KDC), but only until its normal expiration time. If TGTs have been issued for cross-realm authentication, use of the cross-realm TGT will not be affected unless the hot-list is propagated to the KDCs for the realms for which such cross-realm tickets were issued.",
      "ja": "要求はチケット認可サーバに行われるたびに、提示されたチケット（複数可）でキャンセルされているチケットのホットリストと照合（しています）。このホットリストは、「疑わしい券」の発行タイムスタンプの範囲を格納することによって実装されるかもしれません。提示したチケットは、その範囲内authtimeを持っていたならば、それは拒否されるだろう。盗難は、サーバが存在する領域のためにKDCに報告された後、このように、盗まれたTGTまたは再生可能なチケットは、追加のチケット（更新またはその他）を得るために使用することができません。 （チケットはKDCとの相互作用を必要としないので）それが盗まれたと報告された前の任意の通常のチケットはまだ有効となりますが、唯一の通常の有効期限まで。 TGTがクロスレルム認証のために発行されている場合は、ホット・リストは、クロスレルムチケットが発行されたために、レルムのKDCに伝播されない限り、クロスレルムTGTの使用には影響しません。"
    },
    {
      "indent": 0,
      "text": "3.3.3.2. Encoding the Transited Field",
      "section_title": true,
      "ja": "3.3.3.2。通過している分野をコードします"
    },
    {
      "indent": 3,
      "text": "If the identity of the server in the TGT that is presented to the KDC as part of the authentication header is that of the ticket-granting service, but the TGT was issued from another realm, the KDC will look up the inter-realm key shared with that realm and use that key to decrypt the ticket. If the ticket is valid, then the KDC will honor the request, subject to the constraints outlined above in the section describing the AS exchange. The realm part of the client's identity will be taken from the TGT. The name of the realm that issued the TGT, if it is not the realm of the client principal, will be added to the transited field of the ticket to be issued. This is accomplished by reading the transited field from the TGT (which is treated as an unordered set of realm names), adding the new realm to the set, and then constructing and writing out its encoded (shorthand) form (this may involve a rearrangement of the existing encoding).",
      "ja": "認証ヘッダーの一部としてKDCに提示されたTGT内のサーバのアイデンティティがチケット許可サービスのことですが、TGTが別の分野から発行された場合、KDCは、共有レルム間のキーを検索しますそしてそのレルムでチケットを解読するためにそのキーを使用します。チケットが有効である場合、KDCはAS交換を記述するセクションで上記で概説した制約を受ける要求を、尊重します。クライアントのアイデンティティのレルム部分はTGTから取得されます。それは、クライアント主体の領域ではない場合、TGTを発行したレルムの名前は、発行されるチケットの通過している分野に追加されます。これは（これは再配列を含み得る、（レルム名の非順序集合として扱われる）TGTから遷移フィールドを読み取るセットに新しい領域を追加し、その符号化（短縮形）の形を構築して書き込むことによって達成されます。既存のエンコーディングの）。"
    },
    {
      "indent": 3,
      "text": "Note that the ticket-granting service does not add the name of its own realm. Instead, its responsibility is to add the name of the previous realm. This prevents a malicious Kerberos server from intentionally leaving out its own name (it could, however, omit other realms' names).",
      "ja": "チケット認可サービスは、独自のレルムの名前を追加しないことに注意してください。その代わり、その責任は、前のレルムの名前を追加することです。これは意図的に（それが、しかし、他のレルムの名前を省略することができ）、自身の名前を残してから悪意のあるKerberosサーバを防ぎます。"
    },
    {
      "indent": 3,
      "text": "The names of neither the local realm nor the principal's realm are to be included in the transited field. They appear elsewhere in the ticket and both are known to have taken part in authenticating the principal. Because the endpoints are not included, both local and single-hop inter-realm authentication result in a transited field that is empty.",
      "ja": "地元の分野でも校長のレルムどちらの名前が通過している分野に含まれています。彼らは、チケットの他の場所で表示され、両方がプリンシパルを認証に参加したことが知られています。エンドポイントが含まれていないので、空である遷移フィールドにおけるローカルおよびシングルホップ間レルム認証結果。"
    },
    {
      "indent": 3,
      "text": "Because this field has the name of each transited realm added to it, it might potentially be very long. To decrease the length of this field, its contents are encoded. The initially supported encoding is optimized for the normal case of inter-realm communication: a hierarchical arrangement of realms using either domain or X.500 style realm names. This encoding (called DOMAIN-X500-COMPRESS) is now described.",
      "ja": "このフィールドは、各遷移領域の名前がそれに追加しましたので、それは潜在的に非常に長いかもしれません。このフィールドの長さを短くするには、その内容がコード化されています。ドメインまたはX.500スタイルのレルム名のいずれかを使用してレルムの階層構成：最初にサポートされているエンコーディングはレルム間の通信の正常な場合のために最適化されています。 （DOMAIN-X500-COMPRESSと呼ばれる）は、この符号化について説明します。"
    },
    {
      "indent": 3,
      "text": "Realm names in the transited field are separated by a \",\". The \",\", \"\\\", trailing \".\"s, and leading spaces (\" \") are special characters, and if they are part of a realm name, they MUST be quoted in the transited field by preceding them with a \"\\\".",
      "ja": "通過している分野でのレルム名は「」で区切られます。 」、 『『\\』、末尾の』。 『の、および先頭のスペース（』 『）特殊文字であり、それらは、レルム名の一部である場合、それらは、それらを先行することによって通過している分野で引用されなければなりません』 \\」。"
    },
    {
      "indent": 3,
      "text": "A realm name ending with a \".\" is interpreted as being prepended to the previous realm. For example, we can encode traversal of EDU, MIT.EDU, ATHENA.MIT.EDU, WASHINGTON.EDU, and CS.WASHINGTON.EDU as:",
      "ja": "で終わるレルム名「」前レルムの前に付加されるものとして解釈されます。例えば、我々はとしてEDU、MIT.EDU、ATHENA.MIT.EDU、WASHINGTON.EDU、およびCS.WASHINGTON.EDUのトラバーサルをエンコードすることができます。"
    },
    {
      "indent": 6,
      "text": "\"EDU,MIT.,ATHENA.,WASHINGTON.EDU,CS.\".",
      "ja": "\"エドゥ、MIT。、アテナ。WASHINGTON.EDU、CS。\"。"
    },
    {
      "indent": 3,
      "text": "Note that if either ATHENA.MIT.EDU, or CS.WASHINGTON.EDU were endpoints, they would not be included in this field, and we would have:",
      "ja": "ATHENA.MIT.EDU、またはCS.WASHINGTON.EDUいずれかがエンドポイントであれば、彼らがこの分野に含まれていないだろう、と私たちは持っていることに注意してください："
    },
    {
      "indent": 6,
      "text": "\"EDU,MIT.,WASHINGTON.EDU\"",
      "ja": "\"EDU、MIT。、WASHINGTON.EDU\""
    },
    {
      "indent": 3,
      "text": "A realm name beginning with a \"/\" is interpreted as being appended to the previous realm. For the purpose of appending, the realm preceding the first listed realm is considered the null realm (\"\"). If a realm name beginning with a \"/\" is to stand by itself, then it SHOULD be preceded by a space (\" \"). For example, we can encode traversal of /COM/HP/APOLLO, /COM/HP, /COM, and /COM/DEC as:",
      "ja": "「/」で始まるレルム名は、以前の領域に付加されるものとして解釈されます。追加の目的のために、最初にリストされている領域に先行する領域がヌル領域（「」）であると考えられます。 「/」で始まるレルム名は、それ自体で立っている場合、それは（「」）のスペースが先行されるべきである（SHOULD）。例えば、我々は、AS / COM / HP / APOLLO、/ COM / HP、/ COM、および/ COM / 12月のトラバーサルをエンコードすることができます。"
    },
    {
      "indent": 6,
      "text": "\"/COM,/HP,/APOLLO, /COM/DEC\".",
      "ja": "\"/ COM / HP /アポロ/ COM / 12月\""
    },
    {
      "indent": 3,
      "text": "As in the example above, if /COM/HP/APOLLO and /COM/DEC were endpoints, they would not be included in this field, and we would have:",
      "ja": "/ COM / HP / APOLLOと/ COM / DECは、エンドポイントだった場合は、上記の例のように、彼らはこの分野に含まれていないだろう、と私たちは持っているでしょう："
    },
    {
      "indent": 6,
      "text": "\"/COM,/HP\"",
      "ja": "\"/ COM / HP\""
    },
    {
      "indent": 3,
      "text": "A null subfield preceding or following a \",\" indicates that all realms between the previous realm and the next realm have been traversed. For the purpose of interpreting null subfields, the client's realm is considered to precede those in the transited field, and the server's realm is considered to follow them. Thus, \",\" means that all realms along the path between the client and the server have been traversed. \",EDU, /COM,\" means that all realms from the client's realm up to EDU (in a domain style hierarchy) have been traversed, and that everything from /COM down to the server's realm in an X.500 style has also been traversed. This could occur if the EDU realm in one hierarchy shares an inter-realm key directly with the /COM realm in another hierarchy.",
      "ja": "前後のヌルサブフィールドは「」前領域と次の領域との間のすべてのレルムが横断されていることを示しています。ヌルサブフィールドを解釈するためには、クライアントのレルムが通過している分野でそれらに先行すると考えられ、そしてサーバーのレルムがそれに従うと考えられています。このように、「」クライアントとサーバ間のパスに沿ったすべてのレルムが横断されていることを意味します。 「EDU、/ COMは、」（ドメインスタイル階層内）EDUまでのクライアントのレルムからのすべてのレルムが横断、および/ COMダウンからX.500スタイルで、サーバの分野に至るまでもされていることをされていることを意味しトラバース。 1つの階層におけるEDUレルムは別の階層にある/ COMレルムと直接レルム間キーを共有する場合、これが発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.3.4. Receipt of KRB_TGS_REP Message",
      "section_title": true,
      "ja": "3.3.4.  KRB_TGS_REPメッセージの受信"
    },
    {
      "indent": 3,
      "text": "When the KRB_TGS_REP is received by the client, it is processed in the same manner as the KRB_AS_REP processing described above. The primary difference is that the ciphertext part of the response must be decrypted using the sub-session key from the Authenticator, if it was specified in the request, or the session key from the TGT, rather than the client's secret key. The server name returned in the reply is the true principal name of the service.",
      "ja": "KRB_TGS_REPがクライアントによって受信されると、それは、上述したKRB_AS_REP処理と同様に処理されます。主な違いは、それが要求、またはむしろ、クライアントの秘密鍵よりTGTからのセッションキーで指定された場合は、応答の暗号文部分は、オーセンティケータからサブセッションキーを使用して復号化しなければならないということです。応答で返されたサーバー名は、サービスの真のプリンシパル名です。"
    },
    {
      "indent": 0,
      "text": "3.4. The KRB_SAFE Exchange",
      "section_title": true,
      "ja": "3.4.  KRB_SAFE交換"
    },
    {
      "indent": 3,
      "text": "The KRB_SAFE message MAY be used by clients requiring the ability to detect modifications of messages they exchange. It achieves this by including a keyed collision-proof checksum of the user data and some control information. The checksum is keyed with an encryption key (usually the last key negotiated via subkeys, or the session key if no negotiation has occurred).",
      "ja": "KRB_SAFEメッセージは、それらが交換するメッセージの変更を検出する能力を必要とするクライアントによって使用されてもよいです。これは、ユーザデータと一部の制御情報の鍵付き衝突防止チェックサムを含めることによって、これを達成します。チェックサムは、暗号化キー（通常サブキーを経由して交渉し、最後のキー、または全く交渉が発生していない場合はセッションキー）とキー溝が付いています。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Generation of a KRB_SAFE Message",
      "section_title": true,
      "ja": "3.4.1.  KRB_SAFEメッセージの生成"
    },
    {
      "indent": 3,
      "text": "When an application wishes to send a KRB_SAFE message, it collects its data and the appropriate control information and computes a checksum over them. The checksum algorithm should be the keyed checksum mandated to be implemented along with the crypto system used for the sub-session or session key. The checksum is generated using the sub-session key, if present, or the session key. Some implementations use a different checksum algorithm for the KRB_SAFE messages, but doing so in an interoperable manner is not always possible.",
      "ja": "アプリケーションがKRB_SAFEメッセージを送信したい場合、そのデータおよび適切な制御情報を収集し、それらの上にチェックサムを計算します。チェックサムアルゴリズムは、サブセッションまたはセッションキーのために使用さ暗号化システムと共に実施する義務キー付きチェックサムであるべきです。チェックサムは、サブセッション鍵が存在する場合、またはセッション鍵を用いて生成されます。一部の実装では、KRB_SAFEメッセージのために別のチェックサムアルゴリズムを使用しますが、相互運用可能な方法でそうすることは常に可能ではありません。"
    },
    {
      "indent": 3,
      "text": "The control information for the KRB_SAFE message includes both a timestamp and a sequence number. The designer of an application using the KRB_SAFE message MUST choose at least one of the two mechanisms. This choice SHOULD be based on the needs of the application protocol.",
      "ja": "KRB_SAFEメッセージのための制御情報は、タイムスタンプとシーケンス番号の両方を含みます。 KRB_SAFEメッセージを使用するアプリケーションの設計者は、二つの機構の少なくともいずれかを選択しなければなりません。この選択は、アプリケーションプロトコルのニーズに基づくべきです。"
    },
    {
      "indent": 3,
      "text": "Sequence numbers are useful when all messages sent will be received by one's peer. Connection state is presently required to maintain the session key, so maintaining the next sequence number should not present an additional problem.",
      "ja": "送信されたすべてのメッセージが1のピアによって受信されるとき、シーケンス番号は便利です。接続状態は、現在のセッション鍵を維持するために必要とされるので、次のシーケンス番号を維持することは別の問題を提示してはなりません。"
    },
    {
      "indent": 3,
      "text": "If the application protocol is expected to tolerate lost messages without their being resent, the use of the timestamp is the appropriate replay detection mechanism. Using timestamps is also the appropriate mechanism for multi-cast protocols in which all of one's peers share a common sub-session key, but some messages will be sent to a subset of one's peers.",
      "ja": "アプリケーションプロトコルは、そのことを再送することなく、失われたメッセージを許容することが期待されている場合は、タイムスタンプの使用は、適切なリプレイ検出メカニズムです。タイムスタンプを使用すると、1のピアのすべてが共通のサブセッション鍵を共有するマルチキャストプロトコルのための適切なメカニズムですが、いくつかのメッセージが1のピアのサブセットに送信されます。"
    },
    {
      "indent": 3,
      "text": "After computing the checksum, the client then transmits the information and checksum to the recipient in the message format specified in Section 5.6.1.",
      "ja": "チェックサムを計算した後、クライアントは、次いで、セクション5.6.1で指定されたメッセージフォーマットで受信者に情報およびチェックサムを送信します。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Receipt of KRB_SAFE Message",
      "section_title": true,
      "ja": "3.4.2.  KRB_SAFEメッセージの受信"
    },
    {
      "indent": 3,
      "text": "When an application receives a KRB_SAFE message, it verifies it as follows. If any error occurs, an error code is reported for use by the application.",
      "ja": "アプリケーションがKRB_SAFEメッセージを受信した場合、以下のように、それを検証します。いずれかのエラーが発生した場合、エラーコードは、アプリケーションで使用するために報告されます。"
    },
    {
      "indent": 3,
      "text": "The message is first checked by verifying that the protocol version and type fields match the current version and KRB_SAFE, respectively. A mismatch generates a KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE error. The application verifies that the checksum used is a collision-proof keyed checksum that uses keys compatible with the sub-session or session key as appropriate (or with the application key derived from the session or sub-session keys). If it is not, a KRB_AP_ERR_INAPP_CKSUM error is generated. The sender's address MUST be included in the control information; the recipient verifies that the operating system's report of the sender's address matches the sender's address in the message, and (if a recipient address is specified or the recipient requires an address) that one of the recipient's addresses appears as the recipient's address in the message. To work with network address translation, senders MAY use the directional address type specified in Section 8.1 for the sender address and not include recipient addresses. A failed match for either case generates a KRB_AP_ERR_BADADDR error. Then the timestamp and usec and/or the sequence number fields are checked. If timestamp and usec are expected and not present, or if they are present but not current, the KRB_AP_ERR_SKEW error is generated. Timestamps are not required to be strictly ordered; they are only required to be in the skew window. If the server name, along with the client name, time, and microsecond fields from the Authenticator match any recently-seen (sent or received) such tuples, the KRB_AP_ERR_REPEAT error is generated. If an incorrect sequence number is included, or if a sequence number is expected but not present, the KRB_AP_ERR_BADORDER error is generated. If neither a time-stamp and usec nor a sequence number is present, a KRB_AP_ERR_MODIFIED error is generated. Finally, the checksum is computed over the data and control information, and if it doesn't match the received checksum, a KRB_AP_ERR_MODIFIED error is generated.",
      "ja": "メッセージは、第1のプロトコルバージョンとタイプのフィールドは、それぞれ、現在のバージョンとKRB_SAFEと一致することを検証することによって確認されます。不一致がKRB_AP_ERR_BADVERSIONまたはKRB_AP_ERR_MSG_TYPEエラーを生成します。アプリケーションは、使用されるチェックサムは、適切な（またはセッションに由来するアプリケーションキーまたはサブセッションキーを使用して）としてサブセッションまたはセッション鍵と互換性のあるキーを使用して衝突防止キー付きチェックサムであることを検証します。そうでない場合は、KRB_AP_ERR_INAPP_CKSUMエラーが生成されます。送信者のアドレスは、制御情報に含まれなければなりません。受信者は、（受信者のアドレスが指定されるか、または受信者がアドレスを必要とされている場合）、受信者のアドレスのいずれかがメッセージで受信者のアドレスとして表示されていることを送信者のアドレスのオペレーティング・システムのレポートは、メッセージに送信者のアドレスと一致し、ことを確認します。ネットワークアドレス変換を操作するには、送信者は送信者のアドレスについては、セクション8.1で指定された方向性アドレスタイプを使用して、受信者のアドレスが含まれない場合があります。いずれの場合のために失敗したマッチは、KRB_AP_がERR_BADADDR誤りで生成されます。そして、タイムスタンプとマイクロ秒および/またはシーケンス番号フィールドがチェックされます。タイムスタンプとマイクロ秒を期待して存在していない場合、彼らは存在するが、現在されていない場合、または、KRB_AP_ERR_SKEWエラーが生成されます。タイムスタンプは、厳密に注文する必要はありません。彼らは唯一のスキューのウィンドウであることが要求されています。場合は、サーバー名は、オーセンティケータマッチ任意の（送信または受信）最近見られ、このようなタプルからクライアント名、時間、およびマイクロ秒のフィールドと一緒に、KRB_AP_ERR_REPEATエラーが生成されます。間違ったシーケンス番号が含まれている場合、シーケンス番号は期待が、存在しない場合、または、KRB_AP_ERR_BADORDERエラーが生成されます。タイムスタンプとマイクロ秒も一連番号も存在​​していない場合は、KRB_AP_ERR_MODIFIEDエラーが生成されます。最後に、チェックサムはデータ上に計算され、制御情報を、それが受信したチェックサムと一致しない場合、KRB_AP_ERR_MODIFIEDエラーが生成されます。"
    },
    {
      "indent": 3,
      "text": "If all the checks succeed, the application is assured that the message was generated by its peer and was not modified in transit.",
      "ja": "全てのチェックが成功する場合、アプリケーションは、メッセージがピアによって生成されたトランジットで変更されなかったことが保証されます。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD accept any checksum algorithm they implement that has both adequate security and keys compatible with the sub-session or session key. Unkeyed or non-collision-proof checksums are not suitable for this use.",
      "ja": "実装は、彼らが十分なセキュリティとサブセッションまたはセッションキーと互換性のあるキーの両方を持っている実装する任意のチェックサムアルゴリズムを受け入れる必要があります。キーなしまたは非衝突防止チェックサムはこの使用には適していません。"
    },
    {
      "indent": 0,
      "text": "3.5. The KRB_PRIV Exchange",
      "section_title": true,
      "ja": "3.5.  KRB_PRIV交換"
    },
    {
      "indent": 3,
      "text": "The KRB_PRIV message MAY be used by clients requiring confidentiality and the ability to detect modifications of exchanged messages. It achieves this by encrypting the messages and adding control information.",
      "ja": "KRB_PRIVメッセージは秘密性と交換されたメッセージの変更を検出する能力を必要とするクライアントによって使用されてもよいです。これは、メッセージの暗号化と制御情報を追加することでこれを実現します。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Generation of a KRB_PRIV Message",
      "section_title": true,
      "ja": "3.5.1.  KRB_PRIVメッセージの生成"
    },
    {
      "indent": 3,
      "text": "When an application wishes to send a KRB_PRIV message, it collects its data and the appropriate control information (specified in Section 5.7.1) and encrypts them under an encryption key (usually the last key negotiated via subkeys, or the session key if no negotiation has occurred). As part of the control information, the client MUST choose to use either a timestamp or a sequence number (or both); see the discussion in Section 3.4.1 for guidelines on which to use. After the user data and control information are encrypted, the client transmits the ciphertext and some 'envelope' information to the recipient.",
      "ja": "アプリケーションがKRB_PRIVメッセージを送信したい場合は、そのデータと、（5.7.1項で指定された）適切な制御情報を収集し、暗号化キー（サブキーを経由して交渉し、通常は最後のキー、または全く交渉場合はセッションキーの下でそれらを暗号化）が発生しました。制御情報の一部として、クライアントは、タイムスタンプまたはシーケンス番号（または両方）を使用することを選択しなければなりません。使用上のガイドラインについては、セクション3.4.1での議論を参照してください。ユーザデータや制御情報が暗号化された後、クライアントは暗号文と受信者にいくつかの「封筒」情報を送信します。"
    },
    {
      "indent": 0,
      "text": "3.5.2. Receipt of KRB_PRIV Message",
      "section_title": true,
      "ja": "3.5.2.  KRB_PRIVメッセージの受信"
    },
    {
      "indent": 3,
      "text": "When an application receives a KRB_PRIV message, it verifies it as follows. If any error occurs, an error code is reported for use by the application.",
      "ja": "アプリケーションがKRB_PRIVメッセージを受信した場合、以下のように、それを検証します。いずれかのエラーが発生した場合、エラーコードは、アプリケーションで使用するために報告されます。"
    },
    {
      "indent": 3,
      "text": "The message is first checked by verifying that the protocol version and type fields match the current version and KRB_PRIV, respectively. A mismatch generates a KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE error. The application then decrypts the ciphertext and processes the resultant plaintext. If decryption shows that the data has been modified, a KRB_AP_ERR_BAD_INTEGRITY error is generated.",
      "ja": "メッセージは、第1のプロトコルバージョンとタイプのフィールドは、それぞれ、現在のバージョンとKRB_PRIVと一致することを検証することによって確認されます。不一致がKRB_AP_ERR_BADVERSIONまたはKRB_AP_ERR_MSG_TYPEエラーを生成します。次に、アプリケーションは、暗号文を解読し、得られた平文を処理します。復号化データが変更されたことを示す場合、KRB_AP_ERR_BAD_INTEGRITYエラーが生成されます。"
    },
    {
      "indent": 3,
      "text": "The sender's address MUST be included in the control information; the recipient verifies that the operating system's report of the sender's address matches the sender's address in the message. If a recipient address is specified or the recipient requires an address, then one of the recipient's addresses MUST also appear as the recipient's address in the message. Where a sender's or receiver's address might not otherwise match the address in a message because of network address translation, an application MAY be written to use addresses of the directional address type in place of the actual network address.",
      "ja": "送信者のアドレスは、制御情報に含まれなければなりません。受信者は送信者のアドレスのオペレーティング・システムのレポートは、メッセージに送信者のアドレスと一致することを確認します。受信者のアドレスが指定されるか、または受信者がアドレスを必要とされている場合は、受信者のアドレスのいずれも、メッセージに受信者のアドレスとして現れなければなりません。送信者または受信者のアドレスは、そうでない場合は、ネットワークのアドレス変換のメッセージ内のアドレスと一致しない場合があります場合は、アプリケーションは、実際のネットワークアドレスの代わりに、方向のアドレスタイプのアドレスを使用するように記述することができます。"
    },
    {
      "indent": 3,
      "text": "A failed match for either case generates a KRB_AP_ERR_BADADDR error. To work with network address translation, implementations MAY use the directional address type defined in Section 7.1 for the sender address and include no recipient address.",
      "ja": "いずれの場合のために失敗したマッチは、KRB_AP_がERR_BADADDR誤りで生成されます。ネットワークアドレス変換を操作するには、実装は、送信者のアドレスについては、セクション7.1で定義された方向性アドレスタイプを使用して、何の受信者アドレスを含まなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "Next the timestamp and usec and/or the sequence number fields are checked. If timestamp and usec are expected and not present, or if they are present but not current, the KRB_AP_ERR_SKEW error is generated. If the server name, along with the client name, time, and microsecond fields from the Authenticator match any such recently-seen tuples, the KRB_AP_ERR_REPEAT error is generated. If an incorrect sequence number is included, or if a sequence number is expected but not present, the KRB_AP_ERR_BADORDER error is generated. If neither a time-stamp and usec nor a sequence number is present, a KRB_AP_ERR_MODIFIED error is generated.",
      "ja": "タイムスタンプとマイクロ秒および/またはシーケンス番号フィールドの横にチェックされます。タイムスタンプとマイクロ秒を期待して存在していない場合、彼らは存在するが、現在されていない場合、または、KRB_AP_ERR_SKEWエラーが生成されます。サーバー名場合は、クライアント名、時間、および認証の試合からマイクロ秒のフィールドをどのように最近見タプルとともに、KRB_AP_ERR_REPEATエラーが生成されます。間違ったシーケンス番号が含まれている場合、シーケンス番号は期待が、存在しない場合、または、KRB_AP_ERR_BADORDERエラーが生成されます。タイムスタンプとマイクロ秒も一連番号も存在​​していない場合は、KRB_AP_ERR_MODIFIEDエラーが生成されます。"
    },
    {
      "indent": 3,
      "text": "If all the checks succeed, the application can assume the message was generated by its peer and was securely transmitted (without intruders seeing the unencrypted contents).",
      "ja": "全てのチェックが成功した場合、アプリケーションは、メッセージがそのピアによって生成された、しっかり（侵入者が暗号化されていないコンテンツを見ずに）送信されたと仮定することができます。"
    },
    {
      "indent": 0,
      "text": "3.6. The KRB_CRED Exchange",
      "section_title": true,
      "ja": "3.6.  KRB_CRED交換"
    },
    {
      "indent": 3,
      "text": "The KRB_CRED message MAY be used by clients requiring the ability to send Kerberos credentials from one host to another. It achieves this by sending the tickets together with encrypted data containing the session keys and other information associated with the tickets.",
      "ja": "KRB_CREDメッセージを別のホストからKerberos資格情報を送信する能力を必要とするクライアントによって使用されるかもしれません。これは、セッションキーとチケットに関連する他の情報を含む暗号化されたデータと一緒にチケットを送信することによって、これを達成します。"
    },
    {
      "indent": 0,
      "text": "3.6.1. Generation of a KRB_CRED Message",
      "section_title": true,
      "ja": "3.6.1.  KRB_CREDメッセージの生成"
    },
    {
      "indent": 3,
      "text": "When an application wishes to send a KRB_CRED message, it first (using the KRB_TGS exchange) obtains credentials to be sent to the remote host. It then constructs a KRB_CRED message using the ticket or tickets so obtained, placing the session key needed to use each ticket in the key field of the corresponding KrbCredInfo sequence of the encrypted part of the KRB_CRED message.",
      "ja": "アプリケーションはKRB_CREDメッセージを送信したいとき、これは、最初に（KRB_TGS交換を使用して）リモートホストに送信する認証情報を取得します。それはそのようにKRB_CREDメッセージの暗号化された部分の対応KrbCredInfo列のキーフィールドに各チケットを使用するために必要なセッションキーを配置し、取得したチケットまたはチケットを使用してKRB_CREDメッセージを構築します。"
    },
    {
      "indent": 3,
      "text": "Other information associated with each ticket and obtained during the KRB_TGS exchange is also placed in the corresponding KrbCredInfo sequence in the encrypted part of the KRB_CRED message. The current time and, if they are specifically required by the application, the nonce, s-address, and r-address fields are placed in the encrypted part of the KRB_CRED message, which is then encrypted under an encryption key previously exchanged in the KRB_AP exchange (usually the last key negotiated via subkeys, or the session key if no negotiation has occurred).",
      "ja": "KRB_TGS交換中に各チケットに関連付けられて得られた他の情報もKRB_CREDメッセージの暗号化された部分に対応するKrbCredInfo配列に配置されます。現在時刻と、それらは、特に、アプリケーションによって必要とされる場合、ノンス、S-アドレス、およびRアドレスフィールドは、以前にKRB_APで交換暗号鍵で暗号化されたKRB_CREDメッセージの暗号化部分に配置されます為替（通常サブキーを経由して交渉し、最後のキー、または全く交渉が発生していない場合はセッションキー）。"
    },
    {
      "indent": 3,
      "text": "Implementation note: When constructing a KRB_CRED message for inclusion in a GSSAPI initial context token, the MIT implementation of Kerberos will not encrypt the KRB_CRED message if the session key is a DES or triple DES key. For interoperability with MIT, the Microsoft implementation will not encrypt the KRB_CRED in a GSSAPI token if it is using a DES session key. Starting at version 1.2.5, MIT Kerberos can receive and decode either encrypted or unencrypted KRB_CRED tokens in the GSSAPI exchange. The Heimdal implementation of Kerberos can also accept either encrypted or unencrypted KRB_CRED messages. Since the KRB_CRED message in a GSSAPI token is encrypted in the authenticator, the MIT behavior does not present a security problem, although it is a violation of the Kerberos specification.",
      "ja": "実装上の注意：GSSAPI初期コンテキスト・トークンに含めるためKRB_CREDメッセージを構築する場合、セッション鍵がDESまたはトリプルDESキーであれば、ケルベロスのMITの実装がKRB_CREDメッセージを暗号化しないであろう。それはDESセッションキーを使用している場合はMITとの相互運用性については、Microsoftの実装はGSSAPIトークンにKRB_CREDを暗号化しません。バージョン1.2.5から開始し、MIT KerberosはGSSAPI交換内の暗号化または暗号化されていないのいずれかKRB_CREDトークンを受信して​​デコードすることができます。ケルベロスのHeimdalの実装は、また、暗号化または暗号化されていないのいずれかKRB_CREDメッセージを受け入れることができます。 GSSAPIトークンでKRB_CREDメッセージがオーセンティケータで暗号化されているので、それはケルベロス仕様に違反しているが、MITの動作は、セキュリティ上の問題はありません。"
    },
    {
      "indent": 0,
      "text": "3.6.2. Receipt of KRB_CRED Message",
      "section_title": true,
      "ja": "3.6.2.  KRB_CREDメッセージの受信"
    },
    {
      "indent": 3,
      "text": "When an application receives a KRB_CRED message, it verifies it. If any error occurs, an error code is reported for use by the application. The message is verified by checking that the protocol version and type fields match the current version and KRB_CRED, respectively. A mismatch generates a KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE error. The application then decrypts the ciphertext and processes the resultant plaintext. If decryption shows the data to have been modified, a KRB_AP_ERR_BAD_INTEGRITY error is generated.",
      "ja": "アプリケーションはKRB_CREDメッセージを受信すると、それを検証します。いずれかのエラーが発生した場合、エラーコードは、アプリケーションで使用するために報告されます。メッセージは、プロトコルバージョンとタイプのフィールドは、それぞれ、現在のバージョンとKRB_CREDと一致していることをチェックすることによって検証されます。不一致がKRB_AP_ERR_BADVERSIONまたはKRB_AP_ERR_MSG_TYPEエラーを生成します。次に、アプリケーションは、暗号文を解読し、得られた平文を処理します。復号化は、データが変更されたために表示された場合、KRB_AP_ERR_BAD_INTEGRITYエラーが生成されます。"
    },
    {
      "indent": 3,
      "text": "If present or required, the recipient MAY verify that the operating system's report of the sender's address matches the sender's address in the message, and that one of the recipient's addresses appears as the recipient's address in the message. The address check does not provide any added security, since the address, if present, has already been checked in the KRB_AP_REQ message and there is not any benefit to be gained by an attacker in reflecting a KRB_CRED message back to its originator. Thus, the recipient MAY ignore the address even if it is present in order to work better in Network Address Translation (NAT) environments. A failed match for either case generates a KRB_AP_ERR_BADADDR error. Recipients MAY skip the address check, as the KRB_CRED message cannot generally be reflected back to the originator. The timestamp and usec fields (and the nonce field, if required) are checked next. If the timestamp and usec are not present, or if they are present but not current, the KRB_AP_ERR_SKEW error is generated.",
      "ja": "現在または必要に応じて、受信者は送信者のアドレスのオペレーティング・システムのレポートは、メッセージに送信者のアドレスと一致することを確認することができ、受信者のアドレスの1つが、メッセージに受信者のアドレスとして表示されていること。アドレスチェックをアドレスするので、任意の追加のセキュリティを提供しない、存在する場合、すでにKRB_AP_REQメッセージで確認し、戻ってその発信元にKRB_CREDメッセージを反映するには、攻撃者によって獲得される任意の利点がありませんされています。したがって、受信者は、それがネットワークアドレス変換（NAT）環境でより良い仕事をするために存在する場合であってもアドレスを無視してもよいです。いずれの場合のために失敗したマッチは、KRB_AP_がERR_BADADDR誤りで生成されます。 KRB_CREDメッセージは、一般的に発信元に戻って反映させることができないよう受信者は、アドレスチェックをスキップすることができます。タイムスタンプとマイクロ秒フィールド（およびナンスフィールド、必要な場合には）次のチェックされます。タイムスタンプとマイクロ秒が存在しない場合、またはそれらが存在するが、現在ではありません場合は、KRB_AP_ERR_SKEWエラーが生成されます。"
    },
    {
      "indent": 3,
      "text": "If all the checks succeed, the application stores each of the new tickets in its credentials cache together with the session key and other information in the corresponding KrbCredInfo sequence from the encrypted part of the KRB_CRED message.",
      "ja": "すべてのチェックが成功した場合、アプリケーションストアでは、その資格情報で新しいチケットのそれぞれがKRB_CREDメッセージの暗号化された部分から、対応するKrbCredInfoシーケンスのセッションキーと他の情報と一緒にキャッシュします。"
    },
    {
      "indent": 0,
      "text": "3.7. User-to-User Authentication Exchanges",
      "section_title": true,
      "ja": "3.7. ユーザ間の認証交換"
    },
    {
      "indent": 3,
      "text": "User-to-User authentication provides a method to perform authentication when the verifier does not have a access to long-term service key. This might be the case when running a server (for example, a window server) as a user on a workstation. In such cases, the server may have access to the TGT obtained when the user logged in to the workstation, but because the server is running as an unprivileged user, it might not have access to system keys. Similar situations may arise when running peer-to-peer applications.",
      "ja": "ユーザ間の認証は、ベリファイアは、長期的なサービスキーへのアクセス権を持っていない場合に認証を実行する方法を提供します。ワークステーション上のユーザーとしてのサーバ（例えば、ウインドウサーバ）を実行しているとき、これがケースかもしれません。このような場合には、サーバは、ユーザがワークステーションにログインしたときにTGTへのアクセスが得られていますが、サーバは非特権ユーザーとして実行されているので、それはシステムキーへのアクセスを持っていない可能性があります。ピア・ツー・ピア・アプリケーションを実行している場合にも、同様の状況が発生する可能性があります。"
    },
    {
      "indent": 29,
      "text": "Summary",
      "ja": "概要"
    },
    {
      "indent": 7,
      "text": "Message direction Message type Sections 0. Message from application server Not specified 1. Client to Kerberos KRB_TGS_REQ 3.3 & 5.4.1 2. Kerberos to client KRB_TGS_REP or 3.3 & 5.4.2 KRB_ERROR 5.9.1 3. Client to application server KRB_AP_REQ 3.2 & 5.5.1",
      "ja": "アプリケーションサーバーのKerberos KRB_TGS_REQに1.クライアントを指定しない3.3＆5.4.1 2.ケルベロスからクライアントKRB_TGS_REPまたは3.3＆5.4.2 KRB_ERROR 5.9.1 3.クライアントへのメッセージ方向メッセージタイプセクション0メッセージアプリケーションサーバーのKRB_AP_REQ 3.2＆5.5へ0.1"
    },
    {
      "indent": 3,
      "text": "To address this problem, the Kerberos protocol allows the client to request that the ticket issued by the KDC be encrypted using a session key from a TGT issued to the party that will verify the authentication. This TGT must be obtained from the verifier by means of an exchange external to the Kerberos protocol, usually as part of the application protocol. This message is shown in the summary above as message 0. Note that because the TGT is encrypted in the KDC's secret key, it cannot be used for authentication without possession of the corresponding secret key. Furthermore, because the verifier does not reveal the corresponding secret key, providing a copy of the verifier's TGT does not allow impersonation of the verifier.",
      "ja": "この問題に対処するために、Kerberosプロトコルは、クライアントがKDCによって発行されたチケットは、認証を検証する当事者に発行したTGTからセッションキーを使用して暗号化することを要求することができます。このTGTは、通常、アプリケーションプロトコルの一部として、Kerberosプロトコルへ外部の交換によって検証者から取得しなければなりません。このメッセージは、TGTはKDCの秘密鍵で暗号化されているので、それは対応する秘密鍵を所有することなく、認証に使用することができないことをメッセージとして0注上記の概要に示されています。さらに、検証者は、検証の偽装を許可していません検証のTGTのコピーを提供し、対応する秘密鍵を明らかにしないので。"
    },
    {
      "indent": 3,
      "text": "Message 0 in the table above represents an application-specific negotiation between the client and server, at the end of which both have determined that they will use user-to-user authentication, and the client has obtained the server's TGT.",
      "ja": "上記表中のメッセージ0の両方は、それらがユーザ対ユーザ認証を使用することを決定し、そしてクライアントがサーバのTGTを取得したの終わりには、クライアントとサーバとの間のアプリケーション固有のネゴシエーションを表します。"
    },
    {
      "indent": 3,
      "text": "Next, the client includes the server's TGT as an additional ticket in its KRB_TGS_REQ request to the KDC (message 1 in the table above) and specifies the ENC-TKT-IN-SKEY option in its request.",
      "ja": "次に、クライアントは、KDC（上記の表のメッセージ1）へのKRB_TGS_REQ要求で追加のチケットとして、サーバーのTGTが含まれており、その要求でENC-TKT-IN-SKEYオプションを指定します。"
    },
    {
      "indent": 3,
      "text": "If validated according to the instructions in Section 3.3.3, the application ticket returned to the client (message 2 in the table above) will be encrypted using the session key from the additional ticket and the client will note this when it uses or stores the application ticket.",
      "ja": "第3.3.3項の指示に従って検証した場合、アプリケーションのチケットは、追加チケットからセッションキーを使用して暗号化されます、クライアント（上の表のメッセージ2）に戻り、それを使用するか、または保存するとき、クライアントは、この点に注意してくださいます応募券。"
    },
    {
      "indent": 3,
      "text": "When contacting the server using a ticket obtained for user-to-user authentication (message 3 in the table above), the client MUST specify the USE-SESSION-KEY flag in the ap-options field. This tells the application server to use the session key associated with its TGT to decrypt the server ticket provided in the application request.",
      "ja": "ユーザ対ユーザ認証（上記の表のメッセージ3）について得られたチケットを使用してサーバに接続するとき、クライアントは、AP-オプションフィールドにUSE-SESSION-KEYフラグを指定しなければなりません。これは、アプリケーション要求に提供して、サーバー・チケットを解読するためにそのTGTに関連したセッション・キーを使用するようにアプリケーションサーバーを伝えます。"
    },
    {
      "indent": 0,
      "text": "4. Encryption and Checksum Specifications",
      "section_title": true,
      "ja": "4.暗号化とチェックサム仕様"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocols described in this document are designed to encrypt messages of arbitrary sizes, using stream or block encryption ciphers. Encryption is used to prove the identities of the network entities participating in message exchanges. The Key Distribution Center for each realm is trusted by all principals registered in that realm to store a secret key in confidence. Proof of knowledge of this secret key is used to verify the authenticity of a principal.",
      "ja": "本書では説明ケルベロスプロトコルはストリームまたはブロック暗号化方式を使用して、任意のサイズのメッセージを暗号化するように設計されています。暗号化は、メッセージ交換に参加するネットワークエンティティの身元を証明するために使用されます。各レルムのキー配布センターは、マインドの秘密鍵を格納するためにそのレルムに登録されているすべてのプリンシパルに信頼されています。この秘密鍵の知識の証明は、元本の信憑性を検証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The KDC uses the principal's secret key (in the AS exchange) or a shared session key (in the TGS exchange) to encrypt responses to ticket requests; the ability to obtain the secret key or session key implies the knowledge of the appropriate keys and the identity of the KDC. The ability of a principal to decrypt the KDC response and to present a Ticket and a properly formed Authenticator (generated with the session key from the KDC response) to a service verifies the identity of the principal; likewise the ability of the service to extract the session key from the Ticket and to prove its knowledge thereof in a response verifies the identity of the service.",
      "ja": "KDCはプリンシパルの（AS交換で）秘密鍵やチケット要求への応答を暗号化する（TGS交換で）共有セッションキーを使用しています。秘密鍵やセッションキーを取得する機能は、適切なキーの知識とKDCのアイデンティティを意味します。 KDC応答を復号化し、チケットサービスへ（KDC応答からセッションキーを用いて生成された）適切に形成されたオーセンティケータを提示する主の能力は、プリンシパルのアイデンティティを検証します。同様にチケットからのセッションキーを抽出し、それに応答して、その知識を証明するために、サービスの能力は、サービスのIDを検証します。"
    },
    {
      "indent": 3,
      "text": "[RFC3961] defines a framework for defining encryption and checksum mechanisms for use with Kerberos. It also defines several such mechanisms, and more may be added in future updates to that document.",
      "ja": "[RFC3961]はケルベロスで使用するための暗号化とチェックサムメカニズムを定義するためのフレームワークを定義します。それはまた、いくつかのそのようなメカニズムを定義し、さらにその文書の将来のアップデートに加えてもよいです。"
    },
    {
      "indent": 3,
      "text": "The string-to-key operation provided by [RFC3961] is used to produce a long-term key for a principal (generally for a user). The default salt string, if none is provided via pre-authentication data, is the concatenation of the principal's realm and name components, in order, with no separators. Unless it is indicated otherwise, the default string-to-key opaque parameter set as defined in [RFC3961] is used.",
      "ja": "[RFC3961]によって与えられる文字列にキー操作が（一般ユーザ用）主体の長期鍵を生成するために使用されます。いずれも事前認証データを介して提供されていない場合、デフォルトの塩の列は、無セパレータと、順番に、プリンシパルのレルム名及び構成要素の連結です。それは他に示されない限り、[RFC3961]で定義されるように設定されたデフォルト文字列のキーの不透明なパラメータが使用されます。"
    },
    {
      "indent": 3,
      "text": "Encrypted data, keys, and checksums are transmitted using the EncryptedData, EncryptionKey, and Checksum data objects defined in Section 5.2.9. The encryption, decryption, and checksum operations described in this document use the corresponding encryption, decryption, and get_mic operations described in [RFC3961], with implicit \"specific key\" generation using the \"key usage\" values specified in the description of each EncryptedData or Checksum object to vary the key for each operation. Note that in some cases, the value to be used is dependent on the method of choosing the key or the context of the message.",
      "ja": "暗号化されたデータ、キー、およびチェックサムは、セクション5.2.9で定義されてはEncryptedData、EncryptionKey、およびチェックサム・データ・オブジェクトを使用して送信されます。この文書に記載され、暗号化、復号化、およびチェックサムオペレーションは、それぞれはEncryptedDataの説明で指定された「鍵の使用」値を使用して、暗黙的な「固有鍵」の生成と、対応する暗号化、復号化、および[RFC3961]に記載get_mic操作を使用するか、またはチェックサムは、各操作用のキーを変更することを目的。いくつかの場合において、使用される値は、キー又はメッセージのコンテキストを選択する方法に依存していることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Key usages are unsigned 32-bit integers; zero is not permitted. The key usage values for encrypting or checksumming Kerberos messages are indicated in Section 5 along with the message definitions. The key usage values 512-1023 are reserved for uses internal to a Kerberos implementation. (For example, seeding a pseudo-random number generator with a value produced by encrypting something with a session key and a key usage value not used for any other purpose.) Key usage values between 1024 and 2047 (inclusive) are reserved for application use; applications SHOULD use even values for encryption and odd values for checksums within this range. Key usage values are also summarized in a table in Section 7.5.1.",
      "ja": "主な用途は、符号なし32ビット整数です。ゼロは許可されていません。ケルベロスメッセージを暗号化またはチェックサムのための主要な用法値は、メッセージ定義と一緒に5章に示されています。キーの使用量の値512から1023には、Kerberos実装への内部使用のために予約されています。 （例えば、セッション鍵および他の目的のために使用されていない主要な用法値で何かを暗号化した値を用いて擬似乱数生成器を播種。）（包括的）1024から2047の間の主な使用値は、アプリケーションの使用のために予約されています;アプリケーションは、この範囲内のチェックサムのためにも、暗号化のための値と奇数値を使用する必要があります。主な使用量の値はまた、7.5.1項の表にまとめられています。"
    },
    {
      "indent": 3,
      "text": "There might exist other documents that define protocols in terms of the RFC 1510 encryption types or checksum types. These documents would not know about key usages. In order that these specifications continue to be meaningful until they are updated, if no key usage values are specified, then key usages 1024 and 1025 must be used to derive keys for encryption and checksums, respectively. (This does not apply to protocols that do their own encryption independent of this framework, by directly using the key resulting from the Kerberos authentication exchange.) New protocols defined in terms of the Kerberos encryption and checksum types SHOULD use their own key usage values.",
      "ja": "RFC 1510暗号化タイプまたはチェックサムの種類の面でのプロトコルを定義する他のドキュメントが存在する可能性があります。これらの文書は、キーの使用法について知ることはできません。彼らが更新されるまでは、キー使用量の値が指定されていない場合は、これらの仕様は、その後、有意義であり続けるようにするためのキーの使用法1024と1025は、それぞれ、暗号化とチェックサムのための鍵を導出するために使用する必要があります。 （これは直接Kerberos認証交換から生じたキーを使用することによって、このフレームワークの独自の暗号化の独立を行うプロトコルには適用されません。）ケルベロス暗号化の観点で定義された新しいプロトコルやチェックサムのタイプは、独自のキー使用の値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Unless it is indicated otherwise, no cipher state chaining is done from one encryption operation to another.",
      "ja": "それは特に指示されない限り、何の暗号状態の連鎖は、別の暗号化操作から行われません。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Although it is not recommended, some application protocols will continue to use the key data directly, even if only in currently existing protocol specifications. An implementation intended to support general Kerberos applications may therefore need to make key data available, as well as the attributes and operations described in [RFC3961]. One of the more common reasons for directly performing encryption is direct control over negotiation and selection of a \"sufficiently strong\" encryption algorithm (in the context of a given application). Although Kerberos does not directly provide a facility for negotiating encryption types between the application client and server, there are approaches for using Kerberos to facilitate this negotiation. For example, a client may request only \"sufficiently strong\" session key types from the KDC and expect that any type returned by the KDC will be understood and supported by the application server.",
      "ja": "実装上の注意：それはお勧めしませんが、いくつかのアプリケーションプロトコルは、現在、既存のプロトコル仕様にしても場合にのみ、直接キーデータを使用し続けます。したがって、キーデータを利用可能にする必要がある場合があり、一般的にKerberosアプリケーションをサポートすることを意図実装、ならびに[RFC3961]に記載の属性と操作。直接暗号化を実行するためのより一般的な理由の一つは、（所与の用途の文脈における）「十分に強い」暗号アルゴリズムのネゴシエーションおよび選択を直接制御です。 Kerberosは直接アプリケーションのクライアントとサーバ間の暗号化タイプを交渉するための機能を提供していませんが、この交渉を促進するためにKerberosを使用するためのアプローチがあります。例えば、クライアントがKDCからのみ「十分に強い」セッションキーの種類を要求し、KDCによって返されたいずれかのタイプがわかると、アプリケーション・サーバーによってサポートされることを期待します。"
    },
    {
      "indent": 0,
      "text": "5. Message Specifications",
      "section_title": true,
      "ja": "5.メッセージの仕様"
    },
    {
      "indent": 3,
      "text": "The ASN.1 collected here should be identical to the contents of Appendix A. In the case of a conflict, the contents of Appendix A shall take precedence.",
      "ja": "ここに集めASN.1は、付録Aの内容が優先するものと、競合が発生した場合には、付録Aの内容と同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocol is defined here in terms of Abstract Syntax Notation One (ASN.1) [X680], which provides a syntax for specifying both the abstract layout of protocol messages as well as their encodings. Implementors not utilizing an existing ASN.1 compiler or support library are cautioned to understand the actual ASN.1 specification thoroughly in order to ensure correct implementation behavior. There is more complexity in the notation than is immediately obvious, and some tutorials and guides to ASN.1 are misleading or erroneous.",
      "ja": "Kerberosプロトコルは、プロトコルメッセージならびにそれらのエンコーディングの抽象レイアウトの両方を指定するための構文を提供する抽象構文記法1（ASN.1）[X680]の用語でここに定義されています。既存のASN.1コンパイラやサポートライブラリを利用していない実装者は、正しい実装の動作を保証するために徹底的に実際のASN.1仕様を理解することが警告されています。そこすぐに明らかであるよりも、表記の複雑さがあり、ASN.1にいくつかのチュートリアルとガイドは、誤解を招くまたは誤っています。"
    },
    {
      "indent": 3,
      "text": "Note that in several places, changes to abstract types from RFC 1510 have been made. This is in part to address widespread assumptions that various implementors have made, in some cases resulting in unintentional violations of the ASN.1 standard. These are clearly flagged where they occur. The differences between the abstract types in RFC 1510 and abstract types in this document can cause incompatible encodings to be emitted when certain encoding rules, e.g., the Packed Encoding Rules (PER), are used. This theoretical incompatibility should not be relevant for Kerberos, since Kerberos explicitly specifies the use of the Distinguished Encoding Rules (DER). It might be an issue for protocols seeking to use Kerberos types with other encoding rules. (This practice is not recommended.) With very few exceptions (most notably the usages of BIT STRING), the encodings resulting from using the DER remain identical between the types defined in RFC 1510 and the types defined in this document.",
      "ja": "いくつかの場所では、RFC 1510から抽象型への変更が行われていることに注意してください。これは、様々な実装は、ASN.1標準の意図しない違反になるいくつかのケースでは、行われている広範な仮定に対処するための部分です。彼らは発生する場所、これらは明らかにフラグが付けられます。この文書に記載されているRFC 1510および抽象型で抽象型の違いは、特定の符号化規則は、例えば、圧縮符号化規則（PER）が、使用される場合、互換性のない符号化を放出させることができます。 Kerberosは、明示的に識別符号化規則（DER）の使用を指定するため、この理論的な非互換性は、Kerberosの関連ではありません。これは、他の符号化規則でKerberos型を使用しようとしているプロトコルのための問題になる可能性があります。 （この方法は推奨されません。）（最も顕著なビット列の使用法）非常に少数の例外を除いて、DERを使用して起因するエンコーディングは、RFC 1510で定義されたタイプと、この文書で定義されたタイプとの間で同一のまま。"
    },
    {
      "indent": 3,
      "text": "The type definitions in this section assume an ASN.1 module definition of the following form:",
      "ja": "このセクションのタイプの定義は、次の形式のASN.1モジュールの定義を前提としています。"
    },
    {
      "indent": 3,
      "text": "KerberosV5Spec2 {\n        iso(1) identified-organization(3) dod(6) internet(1)\n        security(5) kerberosV5(2) modules(4) krb5spec2(2)\n} DEFINITIONS EXPLICIT TAGS ::= BEGIN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- rest of definitions here",
      "ja": " - ここでの定義の残りの部分"
    },
    {
      "indent": 3,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 3,
      "text": "This specifies that the tagging context for the module will be explicit and non-automatic.",
      "ja": "これは、モジュールのタグ付けコンテキストは、明示的および非自動になることを指定します。"
    },
    {
      "indent": 3,
      "text": "Note that in some other publications (such as [RFC1510] and [RFC1964]), the \"dod\" portion of the object identifier is erroneously specified as having the value \"5\". In the case of RFC 1964, use of the \"correct\" OID value would result in a change in the wire protocol; therefore, it remains unchanged for now.",
      "ja": "（例えば、[RFC1510]及び[RFC1964]のような）いくつかの他の刊行物では、オブジェクト識別子の「DOD」部分が誤って値「5」を有するものとして指定されていることに留意されたいです。 RFC 1964の場合には、「正しい」OID値の使用は、ワイヤプロトコルの変化をもたらします。したがって、それは今のところ変わりません。"
    },
    {
      "indent": 3,
      "text": "Note that elsewhere in this document, nomenclature for various message types is inconsistent, but it largely follows C language conventions, including use of underscore (_) characters and all-caps spelling of names intended to be numeric constants. Also, in some places, identifiers (especially those referring to constants) are written in all-caps in order to distinguish them from surrounding explanatory text.",
      "ja": "他の場所で、この文書では、様々なメッセージタイプの命名法に一貫性がないことに注意してください、それは主に数値定数であることを意図した名前のアンダースコア（_）文字とすべて大文字のスペルの使用を含むC言語の規則に従います。また、いくつかの場所では、識別子（定数を参照特には）説明テキストを囲むと区別するために、すべて大文字で書かれています。"
    },
    {
      "indent": 3,
      "text": "The ASN.1 notation does not permit underscores in identifiers, so in actual ASN.1 definitions, underscores are replaced with hyphens (-). Additionally, structure member names and defined values in ASN.1 MUST begin with a lowercase letter, whereas type names MUST begin with an uppercase letter.",
      "ja": "（ - ）実際のASN.1定義では、アンダースコアをハイフンに置き換えられるように、ASN.1表記は、識別子にアンダースコアを許可していません。タイプ名は大文字で始まる必要があり、一方、また、構造体のメンバ名とASN.1で定義された値は、小文字で始まらなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1. Specific Compatibility Notes on ASN.1",
      "section_title": true,
      "ja": "5.1.  ASN.1上の具体的な互換性に関する注意事項"
    },
    {
      "indent": 3,
      "text": "For compatibility purposes, implementors should heed the following specific notes regarding the use of ASN.1 in Kerberos. These notes do not describe deviations from standard usage of ASN.1. The purpose of these notes is instead to describe some historical quirks and non-compliance of various implementations, as well as historical ambiguities, which, although they are valid ASN.1, can lead to confusion during implementation.",
      "ja": "互換性のために、実装は、KerberosでのASN.1の使用に関して、以下の具体的な注意事項を留意すべきです。これらのノートは、ASN.1の標準的な使用からの逸脱を記述しないでください。これらのノートの目的は、彼らが有効なASN.1あるが、実装の際に混乱を招くことができ、いくつかの歴史的な癖や様々な実装の不遵守だけでなく、歴史的なあいまいさを、記述する代わりにあります。"
    },
    {
      "indent": 0,
      "text": "5.1.1. ASN.1 Distinguished Encoding Rules",
      "section_title": true,
      "ja": "5.1.1.  ASN.1の識別符号化規則"
    },
    {
      "indent": 3,
      "text": "The encoding of Kerberos protocol messages shall obey the Distinguished Encoding Rules (DER) of ASN.1 as described in [X690]. Some implementations (believed primarily to be those derived from DCE 1.1 and earlier) are known to use the more general Basic Encoding",
      "ja": "[X690]に記載されているように、Kerberosプロトコルメッセージの符号化はASN.1の識別符号化規則（DER）に従わなければなりません。 （DCE 1.1以前から誘導されたものであることを主に考えられて）いくつかの実装は、より一般的な基本的なエンコーディングを使用することが知られています"
    },
    {
      "indent": 3,
      "text": "Rules (BER); in particular, these implementations send indefinite encodings of lengths. Implementations MAY accept such encodings in the interest of backward compatibility, though implementors are warned that decoding fully-general BER is fraught with peril.",
      "ja": "ルール（BER）。特に、これらの実装は、長さ不定エンコーディングを送ります。実装者は完全に一般的なBERをデコードすることは危険をはらんでいることを警告しているが、実装は、下位互換性の利益のために、このようなエンコーディングを受け入れることができます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Optional Integer Fields",
      "section_title": true,
      "ja": "5.1.2. オプションの整数フィールド"
    },
    {
      "indent": 3,
      "text": "Some implementations do not internally distinguish between an omitted optional integer value and a transmitted value of zero. The places in the protocol where this is relevant include various microseconds fields, nonces, and sequence numbers. Implementations SHOULD treat omitted optional integer values as having been transmitted with a value of zero, if the application is expecting this.",
      "ja": "いくつかの実装は、内部省略任意の整数値とゼロの送信値を区別しません。これは関連しているプロトコルにおける場所は、種々のマイクロフィールド、ノンス、およびシーケンス番号を含みます。実装は、アプリケーションがこれを期待している場合は、ゼロの値を用いて送信されたものとして省略任意の整数値を扱うべきです。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Empty SEQUENCE OF Types",
      "section_title": true,
      "ja": "5.1.3. 型の空のシーケンス"
    },
    {
      "indent": 3,
      "text": "There are places in the protocol where a message contains a SEQUENCE OF type as an optional member. This can result in an encoding that contains an empty SEQUENCE OF encoding. The Kerberos protocol does not semantically distinguish between an absent optional SEQUENCE OF type and a present optional but empty SEQUENCE OF type. Implementations SHOULD NOT send empty SEQUENCE OF encodings that are marked OPTIONAL, but SHOULD accept them as being equivalent to an omitted OPTIONAL type. In the ASN.1 syntax describing Kerberos messages, instances of these problematic optional SEQUENCE OF types are indicated with a comment.",
      "ja": "メッセージは、オプション部材としてのタイプの配列を含むプロトコルに場所があります。これは、符号化の空のシーケンスが含まれているエンコーディングをもたらす可能性があります。 Kerberosプロトコルは、意味のタイプの不在オプション配列および種の本オプションが、空のシーケンスを区別しません。実装はオプションとマークされているエンコーディングの空のシーケンスを送るべきではありませんが、省略オプションタイプと同等であるとしてそれらを受け入れるべきです。ケルベロスメッセージを記述するASN.1構文で、タイプこれらの問題の任意の配列のインスタンスは、コメントで示されています。"
    },
    {
      "indent": 0,
      "text": "5.1.4. Unrecognized Tag Numbers",
      "section_title": true,
      "ja": "5.1.4. 認識できないタグ番号"
    },
    {
      "indent": 3,
      "text": "Future revisions to this protocol may include new message types with different APPLICATION class tag numbers. Such revisions should protect older implementations by only sending the message types to parties that are known to understand them; e.g., by means of a flag bit set by the receiver in a preceding request. In the interest of robust error handling, implementations SHOULD gracefully handle receiving a message with an unrecognized tag anyway, and return an error message, if appropriate.",
      "ja": "このプロトコルの今後の改正は、異なるアプリケーションクラスのタグ番号を使用して新しいメッセージタイプを含むことができます。このような改正はそれらを理解することが知られている相手にメッセージタイプを送信することによって、古い実装を保護する必要があります。例えば、先行リクエストに受信機によって設定されたフラグビットによって。堅牢なエラー処理の関心では、実装が優雅とにかく、認識できないタグが付けられたメッセージを受信し処理する必要があり、かつ適切な場合には、エラーメッセージを返します。"
    },
    {
      "indent": 3,
      "text": "In particular, KDCs SHOULD return KRB_AP_ERR_MSG_TYPE if the incorrect tag is sent over a TCP transport. The KDCs SHOULD NOT respond to messages received with an unknown tag over UDP transport in order to avoid denial of service attacks. For non-KDC applications, the Kerberos implementation typically indicates an error to the application which takes appropriate steps based on the application protocol.",
      "ja": "間違ったタグがTCPトランスポートを介して送信された場合、特に、のKDCはKRB_AP_ERR_MSG_TYPEを返すべきです。 KDCは、サービス拒否攻撃を避けるために、UDPトランスポート上の未知のタグで受信したメッセージに応答すべきでありません。非KDCのアプリケーションのために、Kerberos実装は、典型的には、アプリケーションプロトコルに基づいて適切な措置をとるアプリケーションにエラーを示します。"
    },
    {
      "indent": 0,
      "text": "5.1.5. Tag Numbers Greater Than 30",
      "section_title": true,
      "ja": "5.1.5.  30よりも大きなタグ番号"
    },
    {
      "indent": 3,
      "text": "A naive implementation of a DER ASN.1 decoder may experience problems with ASN.1 tag numbers greater than 30, due to such tag numbers being encoded using more than one byte. Future revisions of this protocol may utilize tag numbers greater than 30, and implementations SHOULD be prepared to gracefully return an error, if appropriate, when they do not recognize the tag.",
      "ja": "DERのASN.1デコーダの単純な実装は、そのようなタグ番号に、30より大きいASN.1タグ番号の問題が発生する可能性があり、複数のバイトを使用して符号化されます。このプロトコルの将来の改訂は、30よりも大きなタグ番号を利用してもよいし、適切な場合、彼らはタグを認識しない場合の実装は、正常にエラーを返すように準備されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.2. Basic Kerberos Types",
      "section_title": true,
      "ja": "5.2. 基本的なKerberosのタイプ"
    },
    {
      "indent": 3,
      "text": "This section defines a number of basic types that are potentially used in multiple Kerberos protocol messages.",
      "ja": "このセクションでは、潜在的に複数のKerberosプロトコルメッセージで使用される基本的な種類の数を定義します。"
    },
    {
      "indent": 0,
      "text": "5.2.1. KerberosString",
      "section_title": true,
      "ja": "5.2.1.  KerberosString"
    },
    {
      "indent": 3,
      "text": "The original specification of the Kerberos protocol in RFC 1510 uses GeneralString in numerous places for human-readable string data. Historical implementations of Kerberos cannot utilize the full power of GeneralString. This ASN.1 type requires the use of designation and invocation escape sequences as specified in ISO-2022/ECMA-35 [ISO-2022/ECMA-35] to switch character sets, and the default character set that is designated as G0 is the ISO-646/ECMA-6 [ISO-646/ECMA-6] International Reference Version (IRV) (a.k.a. U.S. ASCII), which mostly works.",
      "ja": "RFC 1510でのKerberosプロトコルの元の仕様は、人間が読める文字列データのための多くの場所でGeneralStringを使用しています。ケルベロスの歴史的な実装はGeneralStringのフルパワーを利用することはできません。このASN.1タイプは文字セットを切り替えるISO-2022 / ECMA-35 [ISO-2022 / ECMA-35]で指定されるように指定し、呼び出しの使用は、エスケープシーケンスを必要とし、G0として指定されるデフォルトの文字セットでありますISO-646 / ECMA-6 [ISO-646 / ECMA-6]主に働く国際リファレンスバージョン（IRV）（別名米国ASCII）、。"
    },
    {
      "indent": 3,
      "text": "ISO-2022/ECMA-35 defines four character-set code elements (G0..G3) and two Control-function code elements (C0..C1). DER prohibits the designation of character sets as any but the G0 and C0 sets. Unfortunately, this seems to have the side effect of prohibiting the use of ISO-8859 (ISO Latin) [ISO-8859] character sets or any other character sets that utilize a 96-character set, as ISO-2022/ECMA-35 prohibits designating them as the G0 code element. This side effect is being investigated in the ASN.1 standards community.",
      "ja": "ISO-2022 / ECMA-35は、4つの文字セット符号要素（G0..G3）と二つの制御機能コード要素（C0..C1）を定義します。 DERはG0とC0セットが、どのような文字セットの指定を禁止しています。 ISO-2022 / ECMA-35は、禁止として残念ながら、これは、96文字のセットを利用するISO-8859（ISOラテン）[ISO-8859]の文字セットまたは任意の他の文字セットの使用を禁止する副作用を持っているようですG0コード要素としてそれらを指定します。この副作用は、ASN.1規格コミュニティで検討されています。"
    },
    {
      "indent": 3,
      "text": "In practice, many implementations treat GeneralStrings as if they were 8-bit strings of whichever character set the implementation defaults to, without regard to correct usage of character-set designation escape sequences. The default character set is often determined by the current user's operating system-dependent locale. At least one major implementation places unescaped UTF-8 encoded Unicode characters in the GeneralString. This failure to adhere to the GeneralString specifications results in interoperability issues when conflicting character encodings are utilized by the Kerberos clients, services, and KDC.",
      "ja": "彼らは文字が文字セットの指定のエスケープシーケンスの使用状況を修正するために関係なく、への実装のデフォルトを設定する方の8ビット文字列であるかのように実際には、多くの実装がGeneralStringsを扱います。デフォルトの文字セットは、多くの場合、現在のユーザのオペレーティング・システム依存のロケールによって決定されます。少なくとも一つの主要な実装がGeneralStringにエスケープされていないUTF-8でエンコードされたUnicode文字を配置します。競合の文字エンコーディングがKerberosクライアント、サービス、およびKDCによって利用される相互運用性の問題にGeneralString仕様の結果に付着するこの失敗。"
    },
    {
      "indent": 3,
      "text": "This unfortunate situation is the result of improper documentation of the restrictions of the ASN.1 GeneralString type in prior Kerberos specifications.",
      "ja": "この不幸な状況は、前ケルベロス仕様のASN.1 GeneralStringタイプの制約の不適切な文書化の結果です。"
    },
    {
      "indent": 3,
      "text": "The new (post-RFC 1510) type KerberosString, defined below, is a GeneralString that is constrained to contain only characters in IA5String.",
      "ja": "（ポストRFC 1510）KerberosStringを入力し、以下に定義され、新しいはIA5Stringで文字だけを含むように制約されているGeneralStringです。"
    },
    {
      "indent": 6,
      "text": "KerberosString  ::= GeneralString (IA5String)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In general, US-ASCII control characters should not be used in KerberosString. Control characters SHOULD NOT be used in principal names or realm names.",
      "ja": "一般的には、US-ASCIIの制御文字はKerberosStringでは使用しないでください。制御文字は、プリンシパル名またはレルム名では使用しないでください。"
    },
    {
      "indent": 3,
      "text": "For compatibility, implementations MAY choose to accept GeneralString values that contain characters other than those permitted by IA5String, but they should be aware that character set designation codes will likely be absent, and that the encoding should probably be treated as locale-specific in almost every way. Implementations MAY also choose to emit GeneralString values that are beyond those permitted by IA5String, but they should be aware that doing so is extraordinarily risky from an interoperability perspective.",
      "ja": "互換性のために、実装はIA5Stringで許可された以外の文字を含むGeneralString値を受け入れることを選択かもしれないが、彼らは、文字セット指定コードはおそらく存在しないことになることに注意する必要があり、およびエンコーディングは、おそらくほとんどすべてにロケール固有のものとして扱われるべきであること仕方。また、実装はIA5Stringで許可されたものを超えているGeneralString値を放出することを選択するかもしれないが、彼らはそうすることが、相互運用性の観点から非常に危険であることに注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some existing implementations use GeneralString to encode unescaped locale-specific characters. This is a violation of the ASN.1 standard. Most of these implementations encode US-ASCII in the left-hand half, so as long as the implementation transmits only US-ASCII, the ASN.1 standard is not violated in this regard. As soon as such an implementation encodes unescaped locale-specific characters with the high bit set, it violates the ASN.1 standard.",
      "ja": "いくつかの既存の実装には、エスケープされていないロケール固有の文字をエンコードするためにGeneralStringを使用しています。これは、ASN.1標準の違反です。これらの実装のほとんどはそう限り、実装が唯一のUS-ASCIIを送信して、ASN.1規格は、この点に違反しない、左半分にUS-ASCIIをコードします。このような実装は、高いビットセットでエスケープされていないロケール固有の文字をエンコードするや否や、それはASN.1の規格に違反します。"
    },
    {
      "indent": 3,
      "text": "Other implementations have been known to use GeneralString to contain a UTF-8 encoding. This also violates the ASN.1 standard, since UTF-8 is a different encoding, not a 94 or 96 character \"G\" set as defined by ISO 2022. It is believed that these implementations do not even use the ISO 2022 escape sequence to change the character encoding. Even if implementations were to announce the encoding change by using that escape sequence, the ASN.1 standard prohibits the use of any escape sequences other than those used to designate/invoke \"G\" or \"C\" sets allowed by GeneralString.",
      "ja": "他の実装は、UTF-8エンコーディングを含むようにGeneralStringを使用することが知られています。 UTF-8は、これらの実装もにISO 2022のエスケープシーケンスを使用していないと考えられているISO 2022で定義された設定の異なるエンコーディングではなく、94または96文字の「G」であるので、これはまた、ASN.1標準に違反します文字エンコーディングを変更します。実装がそのエスケープシーケンスを使用して符号変更を発表したとしても、ASN.1規格を指定するために使用されるもの以外の任意のエスケープシーケンスの使用を禁止/「G」又はGeneralStringによって許可され、「C」のセットを呼び出します。"
    },
    {
      "indent": 3,
      "text": "Future revisions to this protocol will almost certainly allow for a more interoperable representation of principal names, probably including UTF8String.",
      "ja": "このプロトコルの今後の改正はほぼ確実だろうUTF8Stringを含め、プリンシパル名のより相互運用可能な表現が可能になります。"
    },
    {
      "indent": 3,
      "text": "Note that applying a new constraint to a previously unconstrained type constitutes creation of a new ASN.1 type. In this particular case, the change does not result in a changed encoding under DER.",
      "ja": "以前に制約のない型に新しい制約を適用する新しいASN.1タイプの作成を構成していることに注意してください。この特定の場合では、変化は、DER下変更符号化をもたらしません。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Realm and PrincipalName",
      "section_title": true,
      "ja": "5.2.2. レルムとのPrincipalName"
    },
    {
      "indent": 3,
      "text": "Realm           ::= KerberosString",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "PrincipalName   ::= SEQUENCE {\n        name-type       [0] Int32,\n        name-string     [1] SEQUENCE OF KerberosString\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Kerberos realm names are encoded as KerberosStrings. Realms shall not contain a character with the code 0 (the US-ASCII NUL). Most realms will usually consist of several components separated by periods (.), in the style of Internet Domain Names, or separated by slashes (/), in the style of X.500 names. Acceptable forms for realm names are specified in Section 6.1. A PrincipalName is a typed sequence of components consisting of the following subfields:",
      "ja": "Kerberosレルム名はKerberosStringsとしてエンコードされています。レルムはコード0（US-ASCII NUL）で文字を含んではなりません。ほとんどのレルムが通常のインターネットドメイン名のスタイルで、ピリオド（。）で区切られたいくつかのコンポーネントから構成され、またはX.500名のスタイルで、スラッシュ（/）で区切られます。レルム名の許容可能な形態は、セクション6.1で指定されています。 PrincipalNameは、次のサブフィールドからなる成分の型付けされた配列です。"
    },
    {
      "indent": 3,
      "text": "name-type This field specifies the type of name that follows. Pre-defined values for this field are specified in Section 6.2. The name-type SHOULD be treated as a hint. Ignoring the name type, no two names can be the same (i.e., at least one of the components, or the realm, must be different).",
      "ja": "名前型は、このフィールドには、次の名前のタイプを指定します。このフィールドの事前定義された値はセクション6.2で指定されています。名前型は、ヒントとして扱われるべきです。名前タイプ無視し、どの2人の名前が（すなわち、少なくとも成分の一つ、またはレルム、異なっていなければならない）と同じになることはできません。"
    },
    {
      "indent": 3,
      "text": "name-string This field encodes a sequence of components that form a name, each component encoded as a KerberosString. Taken together, a PrincipalName and a Realm form a principal identifier. Most PrincipalNames will have only a few components (typically one or two).",
      "ja": "名前ストリングは、このフィールドは、名前、KerberosStringとしてエンコード各成分を形成する成分の配列をコードします。まとめると、のPrincipalNameとレルムは、プリンシパル識別子を形成します。ほとんどのPrincipalNamesはいくつかのコンポーネント（通常、1つまたは2）を持つことになります。"
    },
    {
      "indent": 0,
      "text": "5.2.3. KerberosTime",
      "section_title": true,
      "ja": "5.2.3.  KerberosTime"
    },
    {
      "indent": 3,
      "text": "KerberosTime    ::= GeneralizedTime -- with no fractional seconds",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The timestamps used in Kerberos are encoded as GeneralizedTimes. A KerberosTime value shall not include any fractional portions of the seconds. As required by the DER, it further shall not include any separators, and it shall specify the UTC time zone (Z). Example: The only valid format for UTC time 6 minutes, 27 seconds after 9 pm on 6 November 1985 is 19851106210627Z.",
      "ja": "ケルベロスに使用されるタイムスタンプはGeneralizedTimesとして符号化されます。 KerberosTime値は、秒の小数部分を含んではなりません。 DERによって要求されるように、それは、任意のセパレータを含んではならない、それはUTCタイムゾーン（Z）を指定しなければなりません。例：UTC時間に対してのみ有効な形式6分、9時以降27秒1985年11月6日には19851106210627Zです。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Constrained Integer Types",
      "section_title": true,
      "ja": "5.2.4. 制約付き整数型"
    },
    {
      "indent": 3,
      "text": "Some integer members of types SHOULD be constrained to values representable in 32 bits, for compatibility with reasonable implementation limits.",
      "ja": "タイプのいくつかの整数のメンバーは、合理的な実装の制限との互換性のために、32ビットで表現可能な値に制限されるべきです。"
    },
    {
      "indent": 3,
      "text": "Int32           ::= INTEGER (-2147483648..2147483647)\n                    -- signed values representable in 32 bits",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "UInt32          ::= INTEGER (0..4294967295)\n                    -- unsigned 32 bit values",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Microseconds    ::= INTEGER (0..999999)\n                    -- microseconds",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Although this results in changes to the abstract types from the RFC 1510 version, the encoding in DER should be unaltered. Historical implementations were typically limited to 32-bit integer values anyway, and assigned numbers SHOULD fall in the space of integer values representable in 32 bits in order to promote interoperability anyway.",
      "ja": "これはRFC 1510バージョンから抽象型に変更になりますが、DERでエンコードは不変でなければなりません。歴史的な実装は、典型的には、とにかく32ビット整数値に限定し、そして割り当てられた番号はとにかく相互運用性を促進するために32ビットで表現可能な整数値の空間に入るべきです。"
    },
    {
      "indent": 3,
      "text": "Several integer fields in messages are constrained to fixed values.",
      "ja": "メッセージにはいくつかの整数フィールドは固定値に制限されます。"
    },
    {
      "indent": 3,
      "text": "pvno also TKT-VNO or AUTHENTICATOR-VNO, this recurring field is always the constant integer 5. There is no easy way to make this field into a useful protocol version number, so its value is fixed.",
      "ja": "またPVNO TKT-VNOまたはAUTHENTICATOR-VNOは、この定期的なフィールドは、その値が固定されているので、便利なプロトコルバージョン番号には、このフィールドを作るための簡単な方法は、ありません常に一定の整数5です。"
    },
    {
      "indent": 3,
      "text": "msg-type this integer field is usually identical to the application tag number of the containing message type.",
      "ja": "MSG型は、この整数フィールドは含むメッセージタイプのアプリケーションタグ番号と通常同じです。"
    },
    {
      "indent": 0,
      "text": "5.2.5. HostAddress and HostAddresses",
      "section_title": true,
      "ja": "5.2.5. アドレスとホストアドレスのホスト"
    },
    {
      "indent": 3,
      "text": "HostAddress     ::= SEQUENCE  {\n        addr-type       [0] Int32,\n        address         [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- NOTE: HostAddresses is always used as an OPTIONAL field and\n-- should not be empty.\nHostAddresses   -- NOTE: subtly different from rfc1510,\n                -- but has a value mapping and encodes the same\n        ::= SEQUENCE OF HostAddress",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The host address encodings consist of two fields:",
      "ja": "ホストアドレスのエンコーディングには2つのフィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "addr-type This field specifies the type of address that follows. Pre-defined values for this field are specified in Section 7.5.3.",
      "ja": "addrの型は、このフィールドには、次のアドレスの種類を指定します。このフィールドの事前定義された値は、7.5.3項で規定されています。"
    },
    {
      "indent": 3,
      "text": "address This field encodes a single address of type addr-type.",
      "ja": "このフィールドに取り組むタイプaddrの型の単一のアドレスを符号化します。"
    },
    {
      "indent": 0,
      "text": "5.2.6. AuthorizationData",
      "section_title": true,
      "ja": "5.2.6.  AuthorizationData"
    },
    {
      "indent": 6,
      "text": "-- NOTE: AuthorizationData is always used as an OPTIONAL field and\n-- should not be empty.\nAuthorizationData       ::= SEQUENCE OF SEQUENCE {\n        ad-type         [0] Int32,\n        ad-data         [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ad-data This field contains authorization data to be interpreted according to the value of the corresponding ad-type field.",
      "ja": "広告データは、このフィールドは、対応する広告タイプフィールドの値に従って解釈されるべき許可データを含みます。"
    },
    {
      "indent": 3,
      "text": "ad-type This field specifies the format for the ad-data subfield. All negative values are reserved for local use. Non-negative values are reserved for registered use.",
      "ja": "広告型は、このフィールドは、広告データサブフィールドの形式を指定します。すべての負の値は、ローカル使用のために予約されています。非負の値は、登録用に予約されています。"
    },
    {
      "indent": 3,
      "text": "Each sequence of type and data is referred to as an authorization element. Elements MAY be application specific; however, there is a common set of recursive elements that should be understood by all implementations. These elements contain other elements embedded within them, and the interpretation of the encapsulating element determines which of the embedded elements must be interpreted, and which may be ignored.",
      "ja": "タイプとデータの各シーケンスは、許可要素と呼ばれています。要素は、アプリケーション特異的であってもよいです。ただし、すべての実装によって理解されるべきである再帰要素の共通セットがあります。これらの要素は、それらの中に埋め込まれた他の要素を含み、封止要素の解釈は解釈されなければならず、これは無視することができる埋め込み要素のかを決定します。"
    },
    {
      "indent": 3,
      "text": "These common authorization data elements are recursively defined, meaning that the ad-data for these types will itself contain a sequence of authorization data whose interpretation is affected by the encapsulating element. Depending on the meaning of the encapsulating element, the encapsulated elements may be ignored, might be interpreted as issued directly by the KDC, or might be stored in a separate plaintext part of the ticket. The types of the encapsulating elements are specified as part of the Kerberos specification because the behavior based on these values should be understood across implementations, whereas other elements need only be understood by the applications that they affect.",
      "ja": "これらの共通の認証データ要素を再帰的にこれらのタイプの広告データ自体が解釈カプセル化要素に影響される認証データの配列を含むことを意味、定義されています。 KDCによって直接発行された、またはチケットの別々の平文部分に格納されるかもしれないように封止要素の意味に応じて、カプセル化された要素は無視することができる、と解釈されるかもしれません。これらの値に基づいて動作が実装では理解されるべきであるため、他の要素は、それらが影響を与えるアプリケーションによって理解されるのみ必要一方、封止要素のタイプは、ケルベロス仕様の一部として指定されています。"
    },
    {
      "indent": 3,
      "text": "Authorization data elements are considered critical if present in a ticket or authenticator. If an unknown authorization data element type is received by a server either in an AP-REQ or in a ticket contained in an AP-REQ, then, unless it is encapsulated in a known authorization data element amending the criticality of the elements it contains, authentication MUST fail. Authorization data is intended to restrict the use of a ticket. If the service cannot determine whether the restriction applies to that service, then a security weakness may result if the ticket can be used for that service. Authorization elements that are optional can be enclosed in an AD-IF-RELEVANT element.",
      "ja": "チケットまたはオーセンティケータに存在する場合、承認データ要素が重要と考えられています。未知の承認データ要素タイプがサーバによって受信された場合のいずれかのAP-REQまたはAP-REQに含まれるチケットで、次いで、それは、それが含まれている要素の重要度を修正既知の認可データ要素中にカプセル化されていない限り、認証が失敗しなければなりません。認証データは、チケットの使用を制限することを意図しています。サービスは制限がそのサービスに適用されるかどうか判断できない場合、チケットはそのサービスのために使用することができる場合は、セキュリティ上の弱点となることがあります。オプションで承認要素はAD-IF-関連要素に封入することができます。"
    },
    {
      "indent": 3,
      "text": "In the definitions that follow, the value of the ad-type for the element will be specified as the least significant part of the subsection number, and the value of the ad-data will be as shown in the ASN.1 structure that follows the subsection heading.",
      "ja": "フォロー定義では、要素の広告タイプの値は、サブセクション番号の最下位一部として指定され、広告データの値として、以下のASN.1構造に表示されますサブセクションの見出し。"
    },
    {
      "indent": 3,
      "text": "Contents of ad-data ad-type",
      "ja": "広告データの広告型の内容"
    },
    {
      "indent": 3,
      "text": "DER encoding of AD-IF-RELEVANT 1",
      "ja": "DER符号化AD-IF関連1"
    },
    {
      "indent": 3,
      "text": "DER encoding of AD-KDCIssued 4",
      "ja": "AD-KDCIssued 4のDERエンコーディング"
    },
    {
      "indent": 3,
      "text": "DER encoding of AD-AND-OR 5",
      "ja": "AD-AND-OR 5のDERエンコーディング"
    },
    {
      "indent": 3,
      "text": "DER encoding of AD-MANDATORY-FOR-KDC 8",
      "ja": "AD-MANDATORY-FOR-KDC 8のDERエンコーディング"
    },
    {
      "indent": 0,
      "text": "5.2.6.1. IF-RELEVANT",
      "section_title": true,
      "ja": "5.2.6.1。 IF関連"
    },
    {
      "indent": 3,
      "text": "AD-IF-RELEVANT          ::= AuthorizationData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "AD elements encapsulated within the if-relevant element are intended for interpretation only by application servers that understand the particular ad-type of the embedded element. Application servers that do not understand the type of an element embedded within the if-relevant element MAY ignore the uninterpretable element. This element promotes interoperability across implementations that may have local extensions for authorization. The ad-type for AD-IF-RELEVANT is (1).",
      "ja": "もし関連の要素内にカプセル化されたAD要素のみを埋め込まれた要素の特定の広告タイプを理解し、アプリケーションサーバによって解釈のために意図されています。もし関連の要素内に埋め込まれた要素のタイプを理解していないアプリケーションサーバーは解釈不可能な要素を無視してもよいです。この要素は、認可のために地元の拡張子を持つかもしれ実装で相互運用性を促進します。 AD-IF関連の広告タイプは、（1）です。"
    },
    {
      "indent": 0,
      "text": "5.2.6.2. KDCIssued",
      "section_title": true,
      "ja": "5.2.6.2。 KDCIssued"
    },
    {
      "indent": 3,
      "text": "AD-KDCIssued            ::= SEQUENCE {\n        ad-checksum     [0] Checksum,\n        i-realm         [1] Realm OPTIONAL,\n        i-sname         [2] PrincipalName OPTIONAL,\n        elements        [3] AuthorizationData\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ad-checksum A cryptographic checksum computed over the DER encoding of the AuthorizationData in the \"elements\" field, keyed with the session key. Its checksumtype is the mandatory checksum type for the encryption type of the session key, and its key usage value is 19.",
      "ja": "広告チェックサムセッションキーとキー止め「要素」フィールドでAuthorizationDataのDER符号化に対して計算された暗号チェックサム。そのchecksumtypeは、セッション鍵の暗号化タイプのための必須チェックサムタイプであり、そのキーの使用値は19です。"
    },
    {
      "indent": 3,
      "text": "i-realm, i-sname The name of the issuing principal if different from that of the KDC itself. This field would be used when the KDC can verify the authenticity of elements signed by the issuing principal, and it allows this KDC to notify the application server of the validity of those elements.",
      "ja": "私レルムKDC自体のものとは異なる場合、発行プリンシパルの名前を私は、SNAME。 KDCは、発行プリンシパルによって署名された要素の真正性を検証することができる場合、このフィールドは使用されるであろう、それはこのKDCはこれらの要素の有効性のアプリケーションサーバに通知することを可能にします。"
    },
    {
      "indent": 3,
      "text": "elements A sequence of authorization data elements issued by the KDC.",
      "ja": "要素KDCによって発行された承認データ要素のシーケンス。"
    },
    {
      "indent": 3,
      "text": "The KDC-issued ad-data field is intended to provide a means for Kerberos principal credentials to embed within themselves privilege attributes and other mechanisms for positive authorization, amplifying the privileges of the principal beyond what can be done using credentials without such an a-data element.",
      "ja": "KDCが発行した広告データフィールドは、そのようなデータなしで資格情報を使用して行うことができるもの以外のプリンシパルの権限を増幅し、Kerberosプリンシパル資格情報は権限属性自分自身と正の承認のための他のメカニズムの中に埋め込むための手段を提供することを意図しています素子。"
    },
    {
      "indent": 3,
      "text": "The above means cannot be provided without this element because the definition of the authorization-data field allows elements to be added at will by the bearer of a TGT at the time when they request service tickets, and elements may also be added to a delegated ticket by inclusion in the authenticator.",
      "ja": "認可データ・フィールドの定義は、要素は、それらがサービスチケットを要求する時TGTのベアラによって自由に追加することを可能にするため、上記の手段は、この要素なしで提供することができず、要素は、委任チケットに追加することができますオーセンティケータに含めることもできます。"
    },
    {
      "indent": 3,
      "text": "For KDC-issued elements, this is prevented because the elements are signed by the KDC by including a checksum encrypted using the server's key (the same key used to encrypt the ticket or a key derived from that key). Elements encapsulated with in the KDC-issued element MUST be ignored by the application server if this \"signature\" is not present. Further, elements encapsulated within this element from a TGT MAY be interpreted by the KDC, and used as a basis according to policy for including new signed elements within derivative tickets, but they will not be copied to a derivative ticket directly. If they are copied directly to a derivative ticket by a KDC that is not aware of this element, the signature will not be correct for the application ticket elements, and the field will be ignored by the application server.",
      "ja": "要素は、サーバの鍵（チケット又はその鍵から導出鍵を暗号化するために使用されたのと同じ鍵）を使用して暗号化されたチェックサムを含めることによって、KDCによって署名されているので、KDC発行要素に対して、これが防止されます。この「署名」が存在しない場合、KDC-発行の要素にしてカプセル化された要素は、アプリケーションサーバによって無視されなければなりません。さらに、TGTからこの要素内にカプセル化要素はKDCによって解釈、及び誘導体チケット内の新しい署名された要素を含むためのポリシーに従って基礎として使用されるが、それらは直接誘導体チケットにコピーされないかもしれません。彼らがこの要素を認識していないKDCによって派生チケットに直接コピーされた場合、署名は応募券要素について正しいことではないだろう、とフィールドは、アプリケーション・サーバによって無視されます。"
    },
    {
      "indent": 3,
      "text": "This element and the elements it encapsulates MAY safely be ignored by applications, application servers, and KDCs that do not implement this element.",
      "ja": "この要素と、それがカプセル化要素が安全に、この要素を実装していないアプリケーション、アプリケーションサーバー、およびKDCをによって無視されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The ad-type for AD-KDC-ISSUED is (4).",
      "ja": "AD-KDC発行の広告タイプは、（4）です。"
    },
    {
      "indent": 0,
      "text": "5.2.6.3. AND-OR",
      "section_title": true,
      "ja": "5.2.6.3。 AND-OR"
    },
    {
      "indent": 3,
      "text": "AD-AND-OR               ::= SEQUENCE {\n        condition-count [0] Int32,\n        elements        [1] AuthorizationData\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When restrictive AD elements are encapsulated within the and-or element, the and-or element is considered satisfied if and only if at least the number of encapsulated elements specified in condition-count are satisfied. Therefore, this element MAY be used to implement an \"or\" operation by setting the condition-count field to 1, and it MAY specify an \"and\" operation by setting the condition count to the number of embedded elements. Application servers that do not implement this element MUST reject tickets that contain authorization data elements of this type.",
      "ja": "制限AD要素が内に封入されているときに、または要素、及び、又は要素が満たされているものとみなされる場合と、少なくとも条件カウントで指定されたカプセル化された要素の数が満たされた場合のみ。したがって、この要素は1に条件カウントフィールドを設定することによって、「または」動作を実現するために使用されてもよく、それが埋め込まれた要素の数に条件数を設定することによって「と」操作を指定するかもしれません。この要素を実装していないアプリケーションサーバーは、このタイプの承認データ要素が含まれているチケットを拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The ad-type for AD-AND-OR is (5).",
      "ja": "AD-AND-ORであるため、広告型（5）。"
    },
    {
      "indent": 0,
      "text": "5.2.6.4. MANDATORY-FOR-KDC",
      "section_title": true,
      "ja": "5.2.6.4。 MANDATORY-FOR-KDC"
    },
    {
      "indent": 3,
      "text": "AD-MANDATORY-FOR-KDC    ::= AuthorizationData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "AD elements encapsulated within the mandatory-for-kdc element are to be interpreted by the KDC. KDCs that do not understand the type of an element embedded within the mandatory-for-kdc element MUST reject the request.",
      "ja": "必須-FOR-KDC要素内に封入AD要素はKDCによって解釈されるべきです。要求を拒絶しなければなりません必須-ため、KDC要素内に埋め込まれた要素のタイプを理解していないのKDC。"
    },
    {
      "indent": 3,
      "text": "The ad-type for AD-MANDATORY-FOR-KDC is (8).",
      "ja": "AD-MANDATORY-FOR-KDCの広告タイプは、（8）です。"
    },
    {
      "indent": 0,
      "text": "5.2.7. PA-DATA",
      "section_title": true,
      "ja": "5.2.7.  PA-DATA"
    },
    {
      "indent": 3,
      "text": "Historically, PA-DATA have been known as \"pre-authentication data\", meaning that they were used to augment the initial authentication with the KDC. Since that time, they have also been used as a typed hole with which to extend protocol exchanges with the KDC.",
      "ja": "歴史的に、PA-DATAは、彼らがKDCとの最初の認証を強化するために使用されたことを意味し、「事前認証データ」として知られています。それ以来、彼らはまた、KDCとのプロトコル交換を拡張すると、型付きホールとして使用されてきました。"
    },
    {
      "indent": 3,
      "text": "PA-DATA         ::= SEQUENCE {\n        -- NOTE: first tag is [1], not [0]\n        padata-type     [1] Int32,\n        padata-value    [2] OCTET STRING -- might be encoded AP-REQ\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "padata-type Indicates the way that the padata-value element is to be interpreted. Negative values of padata-type are reserved for unregistered use; non-negative values are used for a registered interpretation of the element type.",
      "ja": "PADATA型PADATA値要素が解釈される方法を示します。 PADATA型の負の値は、未登録の使用のために予約されています。非負の値は、要素タイプの登録解釈するために使用されます。"
    },
    {
      "indent": 3,
      "text": "padata-value Usually contains the DER encoding of another type; the padata-type field identifies which type is encoded here.",
      "ja": "PADATA値は、通常、別のタイプのDERエンコーディングが含まれています。 PADATA型フィールドは、ここでは、符号化されたタイプを識別する。"
    },
    {
      "indent": 6,
      "text": "padata-type Name Contents of padata-value",
      "ja": "PADATA値のPADATA型名内容"
    },
    {
      "indent": 6,
      "text": "1 pa-tgs-req DER encoding of AP-REQ",
      "ja": "AP-REQの1 PA-TGS-REQのDERエンコーディング"
    },
    {
      "indent": 6,
      "text": "2 pa-enc-timestamp DER encoding of PA-ENC-TIMESTAMP",
      "ja": "PA-ENC-TIMESTAMPの2 PA-ENC-タイムスタンプDERエンコーディング"
    },
    {
      "indent": 6,
      "text": "3 pa-pw-salt salt (not ASN.1 encoded)",
      "ja": "3 PA-PW-塩塩（ASN.1符号化しません）"
    },
    {
      "indent": 6,
      "text": "11 pa-etype-info DER encoding of ETYPE-INFO",
      "ja": "ETYPE  -  INFOの11 PA-ETYPE-情報DERエンコーディング"
    },
    {
      "indent": 6,
      "text": "19 pa-etype-info2 DER encoding of ETYPE-INFO2",
      "ja": "ETYPE-INFO2の19 PA-ETYPE-INFO2のDERエンコーディング"
    },
    {
      "indent": 6,
      "text": "This field MAY also contain information needed by certain extensions to the Kerberos protocol. For example, it might be used to verify the identity of a client initially before any response is returned.",
      "ja": "また、このフィールドは、Kerberosプロトコルに特定の拡張子が必要とする情報を含むかもしれません。例えば、すべての応答が返される前に、最初はクライアントの身元を確認するために使用される可能性があります。"
    },
    {
      "indent": 6,
      "text": "The padata field can also contain information needed to help the KDC or the client select the key needed for generating or decrypting the response. This form of the padata is useful for supporting the use of certain token cards with Kerberos. The details of such extensions are specified in separate documents. See [Pat92] for additional uses of this field.",
      "ja": "PADATAフィールドも応答を生成するか、解読するために必要なキーを選択KDCやクライアントを支援するために必要な情報を含めることができます。 PADATAのこの形態は、Kerberosと特定のトークンカードの使用をサポートするために有用です。そのような拡張の詳細は、別の文書で指定されています。このフィールドの追加の用途のために[Pat92]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.7.1. PA-TGS-REQ",
      "section_title": true,
      "ja": "5.2.7.1。 PA-TGS-REQ"
    },
    {
      "indent": 3,
      "text": "In the case of requests for additional tickets (KRB_TGS_REQ), padata-value will contain an encoded AP-REQ. The checksum in the authenticator (which MUST be collision-proof) is to be computed over the KDC-REQ-BODY encoding.",
      "ja": "追加チケット（KRB_TGS_REQ）の要求の場合には、PADATA値は、符号化されたAP-REQを含むであろう。オーセンティケータ（衝突防止されなければならない）のチェックサムはKDC-REQ-BODYエンコードにわたって計算されます。"
    },
    {
      "indent": 0,
      "text": "5.2.7.2. Encrypted Timestamp Pre-authentication",
      "section_title": true,
      "ja": "5.2.7.2。暗号化されたタイムスタンプ事前認証"
    },
    {
      "indent": 3,
      "text": "There are pre-authentication types that may be used to pre-authenticate a client by means of an encrypted timestamp.",
      "ja": "暗号化されたタイムスタンプを用いてクライアントを事前認証するために使用することができる事前認証の種類があります。"
    },
    {
      "indent": 3,
      "text": "PA-ENC-TIMESTAMP        ::= EncryptedData -- PA-ENC-TS-ENC",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "PA-ENC-TS-ENC           ::= SEQUENCE {\n        patimestamp     [0] KerberosTime -- client's time --,\n        pausec          [1] Microseconds OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Patimestamp contains the client's time, and pausec contains the microseconds, which MAY be omitted if a client will not generate more than one request per second. The ciphertext (padata-value) consists of the PA-ENC-TS-ENC encoding, encrypted using the client's secret key and a key usage value of 1.",
      "ja": "Patimestampは、クライアントの時間が含まれており、pausecは、クライアントが秒ごとに複数の要求を生成しない場合は省略されるかもしれませんマイクロ秒が含まれています。暗号文（PADATA-値）は、クライアントの秘密鍵と1のキーの使用値を使用して暗号化PA-ENC-TS-ENCエンコーディング、から構成されています。"
    },
    {
      "indent": 3,
      "text": "This pre-authentication type was not present in RFC 1510, but many implementations support it.",
      "ja": "この事前認証タイプは、RFC 1510に存在しませんでしたが、多くの実装がそれをサポートしています。"
    },
    {
      "indent": 0,
      "text": "5.2.7.3. PA-PW-SALT",
      "section_title": true,
      "ja": "5.2.7.3。 PA-PW-塩"
    },
    {
      "indent": 3,
      "text": "The padata-value for this pre-authentication type contains the salt for the string-to-key to be used by the client to obtain the key for decrypting the encrypted part of an AS-REP message. Unfortunately, for historical reasons, the character set to be used is unspecified and probably locale-specific.",
      "ja": "この事前認証タイプのPADATA-値は、文字列からキーへのAS-REPメッセージの暗号化部分を復号するための鍵を取得するためにクライアントが使用するための塩が含まれています。残念ながら、歴史的な理由のために、使用する文字セットが指定されていないと、おそらくロケール固有です。"
    },
    {
      "indent": 3,
      "text": "This pre-authentication type was not present in RFC 1510, but many implementations support it. It is necessary in any case where the salt for the string-to-key algorithm is not the default.",
      "ja": "この事前認証タイプは、RFC 1510に存在しませんでしたが、多くの実装がそれをサポートしています。これは、文字列への鍵アルゴリズムの塩は、デフォルトではありませんどのような場合に必要です。"
    },
    {
      "indent": 3,
      "text": "In the trivial example, a zero-length salt string is very commonplace for realms that have converted their principal databases from Kerberos Version 4.",
      "ja": "簡単な例では、長さゼロの塩ストリングは、Kerberosバージョン4からそれらの主要データベースを変換したレルムのための非常に一般的です。"
    },
    {
      "indent": 3,
      "text": "A KDC SHOULD NOT send PA-PW-SALT when issuing a KRB-ERROR message that requests additional pre-authentication. Implementation note: Some KDC implementations issue an erroneous PA-PW-SALT when issuing a KRB-ERROR message that requests additional pre-authentication. Therefore, clients SHOULD ignore a PA-PW-SALT accompanying a KRB-ERROR message that requests additional pre-authentication. As noted in section 3.1.3, a KDC MUST NOT send PA-PW-SALT when the client's AS-REQ includes at least one \"newer\" etype.",
      "ja": "追加の事前認証を要求KRB-ERRORメッセージを発行するときにKDCは、PA-PW-SALTを送るべきではありません。実装上の注意：追加の事前認証を要求KRB-ERRORメッセージを発行する場合、一部のKDC実装は、誤ったPA-PW-SALTを発行します。そのため、クライアントは、追加の事前認証を要求KRB-ERRORメッセージを伴うPA-PW-SALTを無視すべきです。セクション3.1.3で述べたように、クライアントのAS-REQが少なくとも1つの「新しい」のetypeを含む場合、KDCは、PA-PW-SALTを送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "5.2.7.4. PA-ETYPE-INFO",
      "section_title": true,
      "ja": "5.2.7.4。 PA-ETYPE  -  INFO"
    },
    {
      "indent": 3,
      "text": "The ETYPE-INFO pre-authentication type is sent by the KDC in a KRB-ERROR indicating a requirement for additional pre-authentication. It is usually used to notify a client of which key to use for the encryption of an encrypted timestamp for the purposes of sending a PA-ENC-TIMESTAMP pre-authentication value. It MAY also be sent in an AS-REP to provide information to the client about which key salt to use for the string-to-key to be used by the client to obtain the key for decrypting the encrypted part the AS-REP.",
      "ja": "ETYPE-INFO事前認証タイプは、追加の事前認証のための要件を示すKRB-ERRORでKDCによって送られます。通常、PA-ENC-TIMESTAMP事前認証値を送信する目的のために暗号化されたタイムスタンプの暗号化に使用するキーのクライアントに通知するために使用されます。また、キー塩が暗号化された部分AS-REPを復号するための鍵を取得するためにクライアントが使用する文字列をキーに使用するかについての情報をクライアントに提供するために、AS-REPで送信することができます。"
    },
    {
      "indent": 3,
      "text": "ETYPE-INFO-ENTRY        ::= SEQUENCE {\n        etype           [0] Int32,\n        salt            [1] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ETYPE-INFO              ::= SEQUENCE OF ETYPE-INFO-ENTRY",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The salt, like that of PA-PW-SALT, is also completely unspecified with respect to character set and is probably locale-specific.",
      "ja": "塩は、PA-PW-SALTのことのように、また、文字セットに関しては完全に指定されていないと、おそらくロケール固有です。"
    },
    {
      "indent": 3,
      "text": "If ETYPE-INFO is sent in an AS-REP, there shall be exactly one ETYPE-INFO-ENTRY, and its etype shall match that of the enc-part in the AS-REP.",
      "ja": "ETYPE  -  INFOはAS-REPに送信された場合は、正確に一つETYPE-INFO-ENTRYがなければならない、そしてそのETYPEはAS-REPでENC-部分と一致するものとします。"
    },
    {
      "indent": 3,
      "text": "This pre-authentication type was not present in RFC 1510, but many implementations that support encrypted timestamps for pre-authentication need to support ETYPE-INFO as well. As noted in Section 3.1.3, a KDC MUST NOT send PA-ETYPE-INFO when the client's AS-REQ includes at least one \"newer\" etype.",
      "ja": "この事前認証タイプは、RFC 1510に存在しませんでしたが、事前認証のための暗号化されたタイムスタンプをサポートする多くの実装は、同様にETYPE  -  INFOをサポートする必要があります。 3.1.3項で述べたように、クライアントのAS-REQが少なくとも1つの「新しい」のetypeを含む場合、KDCは、PA-ETYPE  -  INFOを送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "5.2.7.5. PA-ETYPE-INFO2",
      "section_title": true,
      "ja": "5.2.7.5。 PA-ETYPE-INFO2"
    },
    {
      "indent": 3,
      "text": "The ETYPE-INFO2 pre-authentication type is sent by the KDC in a KRB-ERROR indicating a requirement for additional pre-authentication. It is usually used to notify a client of which key to use for the encryption of an encrypted timestamp for the purposes of sending a PA-ENC-TIMESTAMP pre-authentication value. It MAY also be sent in an AS-REP to provide information to the client about which key salt to use for the string-to-key to be used by the client to obtain the key for decrypting the encrypted part the AS-REP.",
      "ja": "ETYPE-INFO2プレ認証タイプは、追加の事前認証のための要件を示すKRB-ERRORでKDCによって送られます。通常、PA-ENC-TIMESTAMP事前認証値を送信する目的のために暗号化されたタイムスタンプの暗号化に使用するキーのクライアントに通知するために使用されます。また、キー塩が暗号化された部分AS-REPを復号するための鍵を取得するためにクライアントが使用する文字列をキーに使用するかについての情報をクライアントに提供するために、AS-REPで送信することができます。"
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO2-ENTRY       ::= SEQUENCE {\n        etype           [0] Int32,\n        salt            [1] KerberosString OPTIONAL,\n        s2kparams       [2] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO2              ::= SEQUENCE SIZE (1..MAX) OF ETYPE-INFO2-ENTRY",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The type of the salt is KerberosString, but existing installations might have locale-specific characters stored in salt strings, and implementors MAY choose to handle them.",
      "ja": "塩の種類はKerberosStringですが、既存のインストールには、塩文字列に格納されているロケールに固有の文字があるかもしれませんし、実装者はそれらを処理するために選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "The interpretation of s2kparams is specified in the cryptosystem description associated with the etype. Each cryptosystem has a default interpretation of s2kparams that will hold if that element is omitted from the encoding of ETYPE-INFO2-ENTRY.",
      "ja": "s2kparamsの解釈はETYPEに関連付けられている暗号の説明で指定されています。各暗号は、その要素がETYPE-INFO2  -  ENTRYのエンコーディングから省略された場合に開催するs2kparamsのデフォルトの解釈を持っています。"
    },
    {
      "indent": 3,
      "text": "If ETYPE-INFO2 is sent in an AS-REP, there shall be exactly one ETYPE-INFO2-ENTRY, and its etype shall match that of the enc-part in the AS-REP.",
      "ja": "ETYPE-INFO2はAS-REPに送信された場合は、正確に一つETYPE-INFO2  -  ENTRYがなければならない、そしてそのETYPEはAS-REPでENC-部分と一致するものとします。"
    },
    {
      "indent": 3,
      "text": "The preferred ordering of the \"hint\" pre-authentication data that affect client key selection is: ETYPE-INFO2, followed by ETYPE-INFO, followed by PW-SALT. As noted in Section 3.1.3, a KDC MUST NOT send ETYPE-INFO or PW-SALT when the client's AS-REQ includes at least one \"newer\" etype.",
      "ja": "クライアントキーの選択に影響を与える「ヒント」事前認証データの優先順序は次のとおりです。ETYPE-INFO2、PW-SALT続いETYPE  -  INFO、続きます。 3.1.3項で述べたように、クライアントのAS-REQが少なくとも1つの「新しい」のetypeを含む場合、KDCはETYPE  -  INFOまたはPW-SALTを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "The ETYPE-INFO2 pre-authentication type was not present in RFC 1510.",
      "ja": "ETYPE-INFO2プレ認証タイプは、RFC 1510には存在しませんでした。"
    },
    {
      "indent": 0,
      "text": "5.2.8. KerberosFlags",
      "section_title": true,
      "ja": "5.2.8.  KerberosFlags"
    },
    {
      "indent": 3,
      "text": "For several message types, a specific constrained bit string type, KerberosFlags, is used.",
      "ja": "いくつかのメッセージタイプのために、特定の制約のビット列型、KerberosFlagsは、使用されます。"
    },
    {
      "indent": 3,
      "text": "KerberosFlags   ::= BIT STRING (SIZE (32..MAX))\n                    -- minimum number of bits shall be sent,\n                    -- but no fewer than 32",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Compatibility note: The following paragraphs describe a change from the RFC 1510 description of bit strings that would result in incompatility in the case of an implementation that strictly conformed to ASN.1 DER and RFC 1510.",
      "ja": "互換性に関する注意：以下の段落では、厳密にASN.1 DERおよびRFC 1510に準拠した実装の場合にincompatilityにつながるビット列のRFC 1510の記述からの変更について説明します。"
    },
    {
      "indent": 3,
      "text": "ASN.1 bit strings have multiple uses. The simplest use of a bit string is to contain a vector of bits, with no particular meaning attached to individual bits. This vector of bits is not necessarily a multiple of eight bits long. The use in Kerberos of a bit string as a compact boolean vector wherein each element has a distinct meaning poses some problems. The natural notation for a compact boolean vector is the ASN.1 \"NamedBit\" notation, and the DER require that encodings of a bit string using \"NamedBit\" notation exclude any trailing zero bits. This truncation is easy to neglect, especially given C language implementations that naturally choose to store boolean vectors as 32-bit integers.",
      "ja": "ASN.1のビット列は、複数の用途を持っています。ビット列の最も簡単な使用は、個々のビットに取り付けられない特定の意味で、ビットのベクトルを含むことがあります。このビットベクトルは、必ずしも8ビット長の倍数ではありません。各要素は異なる意味を有するコンパクトブールベクトルとしてビット列のケルベロスにおける使用にはいくつかの問題を提起します。コンパクトブールベクトルの自然の表記はASN.1「NamedBit」表記法であり、DER「はNamedBit」表記を使用してビット列の符号化は、後続のゼロのビットを除外することを必要とします。この切り捨ては、特に、天然の32ビット整数としてブールベクトルを格納することを選択するC言語の実装を考慮すると、無視することは容易です。"
    },
    {
      "indent": 3,
      "text": "For example, if the notation for KDCOptions were to include the \"NamedBit\" notation, as in RFC 1510, and a KDCOptions value to be encoded had only the \"forwardable\" (bit number one) bit set, the DER encoding MUST include only two bits: the first reserved bit (\"reserved\", bit number zero, value zero) and the one-valued bit (bit number one) for \"forwardable\".",
      "ja": "KDCOptionsの表記法は、RFC 1510のように、「NamedBit」の表記を含むようにした、符号化されるべきKDCOptions値のみが「転送可能」（ビット番号1）ビットセットを有する場合、例えば、DER符号化は2つだけを含まなければなりませんビット：「転送可能」の最初の予約ビット（「予約」、ビット数ゼロ、ゼロの値）と1つの値のビット（ビット番号1）。"
    },
    {
      "indent": 3,
      "text": "Most existing implementations of Kerberos unconditionally send 32 bits on the wire when encoding bit strings used as boolean vectors. This behavior violates the ASN.1 syntax used for flag values in RFC 1510, but it occurs on such a widely installed base that the protocol description is being modified to accommodate it.",
      "ja": "ブールベクトルとして使用されるビット列を符号化する際にKerberosのほとんどの既存の実装では、無条件にワイヤ上で32ビットを送信します。この現象は、RFC 1510でフラグ値に使用されるASN.1構文に違反するが、それはプロトコルの記述は、それに適応するように変更されているように広く設置ベースで発生します。"
    },
    {
      "indent": 3,
      "text": "Consequently, this document removes the \"NamedBit\" notations for individual bits, relegating them to comments. The size constraint on the KerberosFlags type requires that at least 32 bits be encoded at all times, though a lenient implementation MAY choose to accept fewer than 32 bits and to treat the missing bits as set to zero.",
      "ja": "したがって、この文書は、コメントにそれらを格下げ、個々のビットのための「NamedBit」表記を削除します。 KerberosFlags型にサイズの制約が緩やか実装がより少ない32ビットを受け入れるために、ゼロに設定として欠落ビットを治療するために選択するかもしれませんが、少なくとも32ビットは、常に符号化されることを必要とします。"
    },
    {
      "indent": 3,
      "text": "Currently, no uses of KerberosFlags specify more than 32 bits' worth of flags, although future revisions of this document may do so. When more than 32 bits are to be transmitted in a KerberosFlags value, future revisions to this document will likely specify that the smallest number of bits needed to encode the highest-numbered one-valued bit should be sent. This is somewhat similar to the DER encoding of a bit string that is declared with the \"NamedBit\" notation.",
      "ja": "このドキュメントの将来の改訂はそうかもしれないが、現在、KerberosFlagsのない用途は、旗の32ビット以上の価値を指定していません。 32ビット以上がKerberosFlags値で送信する場合、この文書の将来の改訂は、おそらく最高の番号の一値化ビットを符号化するために必要なビットの最小数を送信するように指定します。これは、「NamedBit」表記で宣言されたビット列のDER符号化に幾分類似しています。"
    },
    {
      "indent": 0,
      "text": "5.2.9. Cryptosystem-Related Types",
      "section_title": true,
      "ja": "5.2.9. 暗号関連の種類"
    },
    {
      "indent": 3,
      "text": "Many Kerberos protocol messages contain an EncryptedData as a container for arbitrary encrypted data, which is often the encrypted encoding of another data type. Fields within EncryptedData assist the recipient in selecting a key with which to decrypt the enclosed data.",
      "ja": "多くのKerberosプロトコル・メッセージは、多くの場合、別のデータ型の暗号化された符号化され、任意の暗号化されたデータのためのコンテナとしてはEncryptedDataを含みます。 EncryptedData内のフィールドは、囲まれたデータを復号化するとキーを選択して受信者を支援します。"
    },
    {
      "indent": 3,
      "text": "EncryptedData   ::= SEQUENCE {\n        etype   [0] Int32 -- EncryptionType --,\n        kvno    [1] UInt32 OPTIONAL,\n        cipher  [2] OCTET STRING -- ciphertext\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "etype This field identifies which encryption algorithm was used to encipher the cipher.",
      "ja": "ETYPEこのフィールドは、暗号を暗号化するために使用された暗号化アルゴリズムを識別します。"
    },
    {
      "indent": 3,
      "text": "kvno This field contains the version number of the key under which data is encrypted. It is only present in messages encrypted under long lasting keys, such as principals' secret keys.",
      "ja": "KVNOこのフィールドは、データが暗号化されている下キーのバージョン番号が含まれています。それは、このようなプリンシパル秘密鍵などの長期的なキーの下に暗号化されたメッセージにのみ存在します。"
    },
    {
      "indent": 3,
      "text": "cipher This field contains the enciphered text, encoded as an OCTET STRING. (Note that the encryption mechanisms defined in [RFC3961] MUST incorporate integrity protection as well, so no additional checksum is required.)",
      "ja": "暗号このフィールドは、オクテット文字列としてエンコードされた暗号化テキストが含まれています。 （[RFC3961]で定義された暗号化メカニズムも同様に完全性保護を組み込まなければならないことに留意されたいので、追加のチェックサムが必要とされません。）"
    },
    {
      "indent": 3,
      "text": "The EncryptionKey type is the means by which cryptographic keys used for encryption are transferred.",
      "ja": "EncryptionKeyタイプは、暗号化に使用される暗号化キーが転送される手段です。"
    },
    {
      "indent": 3,
      "text": "EncryptionKey   ::= SEQUENCE {\n        keytype         [0] Int32 -- actually encryption type --,\n        keyvalue        [1] OCTET STRING\n} keytype\n   This field specifies the encryption type of the encryption key\n   that follows in the keyvalue field.  Although its name is\n   \"keytype\", it actually specifies an encryption type.  Previously,\n   multiple cryptosystems that performed encryption differently but\n   were capable of using keys with the same characteristics were\n   permitted to share an assigned number to designate the type of\n   key; this usage is now deprecated.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "keyvalue This field contains the key itself, encoded as an octet string.",
      "ja": "キー値このフィールドは、オクテット文字列として符号化された鍵自体を、含まれています。"
    },
    {
      "indent": 3,
      "text": "Messages containing cleartext data to be authenticated will usually do so by using a member of type Checksum. Most instances of Checksum use a keyed hash, though exceptions will be noted.",
      "ja": "認証される平文データを含むメッセージは、通常タイプのチェックサムの部材を用いて、そうします。例外が注目されるであろうけれども、チェックサムのほとんどの場合は、鍵付きハッシュを使用します。"
    },
    {
      "indent": 3,
      "text": "Checksum        ::= SEQUENCE {\n        cksumtype       [0] Int32,\n        checksum        [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cksumtype This field indicates the algorithm used to generate the accompanying checksum.",
      "ja": "cksumtypeこのフィールドには、添付のチェックサムを生成するために使用するアルゴリズムを示します。"
    },
    {
      "indent": 3,
      "text": "checksum This field contains the checksum itself, encoded as an octet string.",
      "ja": "チェックサムこのフィールドは、オクテット文字列としてエンコードされたチェックサム自体が、含まれています。"
    },
    {
      "indent": 3,
      "text": "See Section 4 for a brief description of the use of encryption and checksums in Kerberos.",
      "ja": "ケルベロスでの暗号化とチェックサムの使用の簡単な説明については、セクション4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3. Tickets",
      "section_title": true,
      "ja": "5.3. 切符売場"
    },
    {
      "indent": 3,
      "text": "This section describes the format and encryption parameters for tickets and authenticators. When a ticket or authenticator is included in a protocol message, it is treated as an opaque object. A ticket is a record that helps a client authenticate to a service. A Ticket contains the following information:",
      "ja": "このセクションでは、チケットと認証子のフォーマットと暗号化パラメータについて説明します。チケットまたはオーセンティケータは、プロトコルメッセージに含まれている場合、それは、不透明なオブジェクトとして扱われます。チケットは、クライアントがサービスを認証することができますレコードです。チケットは、以下の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "Ticket          ::= [APPLICATION 1] SEQUENCE {\n        tkt-vno         [0] INTEGER (5),\n        realm           [1] Realm,\n        sname           [2] PrincipalName,\n        enc-part        [3] EncryptedData -- EncTicketPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- Encrypted part of ticket",
      "ja": " - チケットの暗号化された部分"
    },
    {
      "indent": 3,
      "text": "EncTicketPart   ::= [APPLICATION 3] SEQUENCE {\n        flags                   [0] TicketFlags,\n        key                     [1] EncryptionKey,\n        crealm                  [2] Realm,\n        cname                   [3] PrincipalName,\n        transited               [4] TransitedEncoding,\n        authtime                [5] KerberosTime,\n        starttime               [6] KerberosTime OPTIONAL,\n        endtime                 [7] KerberosTime,\n        renew-till              [8] KerberosTime OPTIONAL,\n        caddr                   [9] HostAddresses OPTIONAL,\n        authorization-data      [10] AuthorizationData OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- encoded Transited field\nTransitedEncoding       ::= SEQUENCE {\n        tr-type         [0] Int32 -- must be registered --,\n        contents        [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TicketFlags     ::= KerberosFlags\n        -- reserved(0),\n        -- forwardable(1),\n        -- forwarded(2),\n        -- proxiable(3),\n        -- proxy(4),\n        -- may-postdate(5),\n        -- postdated(6),\n        -- invalid(7),\n        -- renewable(8),\n        -- initial(9),\n        -- pre-authent(10),\n        -- hw-authent(11),\n-- the following are new since 1510\n        -- transited-policy-checked(12),\n        -- ok-as-delegate(13)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tkt-vno This field specifies the version number for the ticket format. This document describes version number 5.",
      "ja": "TKT-VNOこのフィールドは、チケットフォーマットのバージョン番号を指定します。このドキュメントでは、バージョン番号5を説明します。"
    },
    {
      "indent": 3,
      "text": "realm This field specifies the realm that issued a ticket. It also serves to identify the realm part of the server's principal identifier. Since a Kerberos server can only issue tickets for servers within its realm, the two will always be identical.",
      "ja": "分野このフィールドは、チケットを発行したレルムを指定します。また、サーバーの主要な識別子の分野の部分を識別するのに役立ちます。 Kerberosサーバだけでその領域内のサーバのチケットを発行することができるので、二人は常に同じになります。"
    },
    {
      "indent": 3,
      "text": "sname This field specifies all components of the name part of the server's identity, including those parts that identify a specific instance of a service.",
      "ja": "SNAMEこのフィールドは、サービスの特定のインスタンスを識別し、それらの部品を含むサーバーのIDの名前の部分のすべてのコンポーネントを、指定します。"
    },
    {
      "indent": 3,
      "text": "enc-part This field holds the encrypted encoding of the EncTicketPart sequence. It is encrypted in the key shared by Kerberos and the end server (the server's secret key), using a key usage value of 2.",
      "ja": "ENC-部分は、このフィールドはEncTicketPartシーケンスの暗号化されたエンコーディングを保持しています。これは、2のキーの使用値を使用して、Kerberosとエンドサーバ（サーバの秘密鍵）で共有鍵で暗号化されます。"
    },
    {
      "indent": 3,
      "text": "flags This field indicates which of various options were used or requested when the ticket was issued. The meanings of the flags are as follows:",
      "ja": "フラグこのフィールドは、チケットが発行された際に使用されるか、または要求された様々なオプションのかを示します。次のようにフラグの意味は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Bit(s) Name Description",
      "ja": "ビット名前説明"
    },
    {
      "indent": 3,
      "text": "0 reserved Reserved for future expansion of this field.",
      "ja": "0は、この分野の将来の拡張のために予約を禁じます。"
    },
    {
      "indent": 3,
      "text": "1 forwardable The FORWARDABLE flag is normally only interpreted by the TGS, and can be ignored by end servers. When set, this flag tells the ticket-granting server that it is OK to issue a new TGT with a different network address based on the presented ticket.",
      "ja": "1通常のみTGSによって解釈さFORWARDABLEフラグを転送可能、とエンドサーバによって無視することができます。設定されている場合、このフラグは、提示されたチケットに基づいて、異なるネットワークアドレスを持つ新しいTGTを発行するには、[OK]でチケット交付サーバーに伝えます。"
    },
    {
      "indent": 3,
      "text": "2 forwarded When set, this flag indicates that the ticket has either been forwarded or was issued based on authentication involving a forwarded TGT.",
      "ja": "図2は、設定した場合、転送、このフラグは、チケットが転送されたいずれかまたは転送TGTを伴う認証に基づいて発行されたことを示しています。"
    },
    {
      "indent": 3,
      "text": "3 proxiable The PROXIABLE flag is normally only interpreted by the TGS, and can be ignored by end servers. The PROXIABLE flag has an interpretation identical to that of the FORWARDABLE flag, except that the PROXIABLE flag tells the ticket-granting server that only non-TGTs may be issued with different network addresses.",
      "ja": "3代理可能PROXIABLEフラグは、通常のみTGSによって解釈され、エンドサーバによって無視することができます。 PROXIABLEフラグはPROXIABLEフラグは唯一の非のTGTは、異なるネットワークアドレスを発行することができるチケット交付サーバーに伝えていることを除いて、FORWARDABLEフラグと同じ解釈を持っています。"
    },
    {
      "indent": 3,
      "text": "4 proxy When set, this flag indicates that a ticket is a proxy.",
      "ja": "セット4プ​​ロキシは、このフラグは、チケットがプロキシであることを示しています。"
    },
    {
      "indent": 3,
      "text": "5 may-postdate The MAY-POSTDATE flag is normally only interpreted by the TGS, and can be ignored by end servers. This flag tells the ticket-granting server that a post-dated ticket MAY be issued based on this TGT.",
      "ja": "5- POSTDATEもよい-POSTDATEフラグは、通常のみTGSによって解釈され、エンドサーバによって無視することができます。このフラグは、ポスト日付チケットは、このTGTに基づいて発行することができることをチケット交付サーバーに伝えます。"
    },
    {
      "indent": 3,
      "text": "6 postdated This flag indicates that this ticket has been postdated. The end-service can check the authtime field to see when the original authentication occurred.",
      "ja": "このフラグ先日付を書か図6は、このチケットが先日付を書かされたことを示しています。エンド・サービスは、元の認証が発生したときに表示するauthtimeフィールドを確認することができます。"
    },
    {
      "indent": 3,
      "text": "7 invalid This flag indicates that a ticket is invalid, and it must be validated by the KDC before use. Application servers must reject tickets which have this flag set.",
      "ja": "図7は、このフラグは、チケットが無効であることを示し、それは使用前にKDCによって検証されなければなら無効。アプリケーションサーバーは、このフラグを設定するチケットを拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "8 renewable The RENEWABLE flag is normally only interpreted by the TGS, and can usually be ignored by end servers (some particularly careful servers MAY disallow renewable tickets). A renewable ticket can be used to obtain a replacement ticket that expires at a later date.",
      "ja": "8再生可能な再生可能フラグは、通常、TGSが解釈するだけであり、通常は（いくつかの特に慎重なサーバが再生可能なチケットを許可しない場合があります）、エンドサーバは無視することができます。再生可能なチケットは後日満了する交換用のチケットを取得するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "9 initial This flag indicates that this ticket was issued using the AS protocol, and not issued based on a TGT.",
      "ja": "9このフラグを初期このチケットはASプロトコルを使用して発行され、TGTに基づいて発行されていなかったことを示しています。"
    },
    {
      "indent": 3,
      "text": "10 pre-authent This flag indicates that during initial authentication, the client was authenticated by the KDC before a ticket was issued. The strength of the pre-authentication method is not indicated, but is acceptable to the KDC.",
      "ja": "10前オーこのフラグは、チケットが発行される前の初期認証時に、クライアントはKDCによって認証されたことを示しています。事前認証方式の強度が示されていないが、KDCに受け入れられます。"
    },
    {
      "indent": 3,
      "text": "11 hw-authent This flag indicates that the protocol employed for initial authentication required the use of hardware expected to be possessed solely by the named client. The hardware authentication method is selected by the KDC and the strength of the method is not indicated.",
      "ja": "11 HW-オーこのフラグは、最初の認証に使用されるプロトコルが指定されたクライアントのみによって所有されることが予想ハードウェアの使用を必要としたことを示します。ハードウェア認証方法はKDCによって選択され、方法の強度が示されていません。"
    },
    {
      "indent": 3,
      "text": "12 transited- This flag indicates that the KDC for policy-checked the realm has checked the transited field against a realm-defined policy for trusted certifiers. If this flag is reset (0), then the application server must check the transited field itself, and if unable to do so, it must reject the authentication. If the flag is set (1), then the application server MAY skip its own validation of the transited field, relying on the validation performed by the KDC. At its option the application server MAY still apply its own validation based on a separate policy for acceptance.",
      "ja": "12このフラグが示すtransited-そのレルムは、信頼できる認証機関のレルムに定義されたポリシーに反する通過している分野をチェックしたポリシー確認のためにKDC。このフラグがリセットされた場合（0）、その後、アプリケーションサーバは、通過している分野自体をチェックしなければならず、そうすることができないならば、それは認証を拒否しなければなりません。フラグが（1）設定されている場合、アプリケーションサーバは、KDCによって実行される検証に依存する、遷移フィールドの独自の検証をスキップすることができます。そのオプションで、アプリケーション・サーバはまだ受け入れのために別々のポリシーに基づいて、独自の検証を適用することができます。"
    },
    {
      "indent": 28,
      "text": "This flag is new since RFC 1510.",
      "ja": "このフラグは、RFC 1510以降の新機能です。"
    },
    {
      "indent": 3,
      "text": "13 ok-as-delegate This flag indicates that the server (not the client) specified in the ticket has been determined by policy of the realm to be a suitable recipient of delegation. A client can use the presence of this flag to help it decide whether to delegate credentials (either grant a proxy or a forwarded TGT) to this server. The client is free to ignore the value of this flag. When setting this flag, an administrator should consider the security and placement of the server on which the service will run, as well as whether the service requires the use of delegated credentials.",
      "ja": "13 OK-AS-デリゲートこのフラグは、チケットで指定されたサーバ（クライアントではなく）が代表団のに適した受信者であることを分野の政策によって決定されていることを示しています。クライアントは、このサーバに認証情報を（いずれかのプロキシまたは転送TGTを付与）委任するかどうかを決定するために、このフラグの存在を使用することができます。クライアントは、このフラグの値を無視して自由です。このフラグを設定する場合、管理者は、サービスを実行するサーバーのセキュリティと配置を考慮する必要があり、同様かどうかなどのサービスは、委任された資格情報を使用する必要があります。"
    },
    {
      "indent": 28,
      "text": "This flag is new since RFC 1510.",
      "ja": "このフラグは、RFC 1510以降の新機能です。"
    },
    {
      "indent": 3,
      "text": "14-31 reserved Reserved for future use.",
      "ja": "14-31は、将来の使用のために予約を禁じます。"
    },
    {
      "indent": 3,
      "text": "key This field exists in the ticket and the KDC response and is used to pass the session key from Kerberos to the application server and the client.",
      "ja": "キーこのフィールドは、チケットとKDC応答で存在し、アプリケーションサーバとクライアントへのKerberosからセッションキーを渡すために使用されます。"
    },
    {
      "indent": 3,
      "text": "crealm This field contains the name of the realm in which the client is registered and in which initial authentication took place.",
      "ja": "crealmこのフィールドは、クライアントが登録された初期認証が行われたされているレルムの名前が含まれています。"
    },
    {
      "indent": 3,
      "text": "cname This field contains the name part of the client's principal identifier.",
      "ja": "CNAMEは、このフィールドは、クライアントの主要な識別子の名前の一部が含まれています。"
    },
    {
      "indent": 3,
      "text": "transited This field lists the names of the Kerberos realms that took part in authenticating the user to whom this ticket was issued. It does not specify the order in which the realms were transited. See Section 3.3.3.2 for details on how this field encodes the traversed realms. When the names of CAs are to be embedded in the transited field (as specified for some extensions to the protocol), the X.500 names of the CAs SHOULD be mapped into items in the transited field using the mapping defined by RFC 2253.",
      "ja": "このフィールドは、このチケットが発行された人にユーザを認証に参加したのKerberosレルムの名前が一覧表示されます遷移します。それは、レルムが遷移された順序を指定していません。このフィールドが横断レルムをエンコードする方法の詳細については、セクション3.3.3.2を参照してください。 CAの名前は（プロトコルのいくつかの拡張のために指定されるように）遷移フィールドに埋め込まれるべきである場合、CAのX.500名は、RFC 2253に定義されたマッピングを使用して遷移フィールド内のアイテムにマッピングされるべきです。"
    },
    {
      "indent": 3,
      "text": "authtime This field indicates the time of initial authentication for the named principal. It is the time of issue for the original ticket on which this ticket is based. It is included in the ticket to provide additional information to the end service, and to provide the necessary information for implementation of a \"hot list\" service at the KDC. An end service that is particularly paranoid could refuse to accept tickets for which the initial authentication occurred \"too far\" in the past. This field is also returned as part of the response from the KDC. When it is returned as part of the response to initial authentication (KRB_AS_REP), this is the current time on the Kerberos server. It is NOT recommended that this time value be used to adjust the workstation's clock, as the workstation cannot reliably determine that such a KRB_AS_REP actually came from the proper KDC in a timely manner.",
      "ja": "authtimeこのフィールドは、名前のプリンシパルの初期認証の時刻を示しています。これは、このチケットが基づいている、元のチケットの発行時です。エンド・サービスに追加情報を提供する、とKDCで「ホットリスト」サービスの実現のために必要な情報を提供するために、チケットに含まれています。特に被害妄想であるエンド・サービスは、初期認証は、過去に「遠すぎる」発生したチケットを受け入れることを拒否する可能性があります。このフィールドは、KDCからの応答の一部として返されます。それは初期の認証（KRB_AS_REP）への応答の一部として返された場合、これは、Kerberosサーバ上の現在の時間です。ワークステーションが確実なKRB_AS_REPが実際にタイムリーに適切なKDCから来たことを判断できないとして、この時間値は、ワークステーションの時計を調整するために使用することが推奨されていません。"
    },
    {
      "indent": 3,
      "text": "starttime This field in the ticket specifies the time after which the ticket is valid. Together with endtime, this field specifies the life of the ticket. If the starttime field is absent from the ticket, then the authtime field SHOULD be used in its place to determine the life of the ticket.",
      "ja": "STARTTIMEチケット内のこのフィールドは、チケットが有効になるまでの時間を指定します。一緒に終了時刻と、このフィールドは、チケットの寿命を指定します。 STARTTIMEフィールドは、チケットに存在しない場合は、authtimeフィールドは、チケットの寿命を決定するために、その場所で使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "endtime This field contains the time after which the ticket will not be honored (its expiration time). Note that individual services MAY place their own limits on the life of a ticket and MAY reject tickets which have not yet expired. As such, this is really an upper bound on the expiration time for the ticket.",
      "ja": "終了時刻このフィールドは、チケットが光栄にされることはありませんれるまでの時間（その有効期限）が含まれています。個々のサービスがチケットの人生に自分の限界を置くことができ、まだ期限が切れていないチケットを拒絶するかもしれないことに注意してください。そのため、これは本当にチケットの有効期限の上限です。"
    },
    {
      "indent": 3,
      "text": "renew-till This field is only present in tickets that have the RENEWABLE flag set in the flags field. It indicates the maximum endtime that may be included in a renewal. It can be thought of as the absolute expiration time for the ticket, including all renewals.",
      "ja": "更新-までこのフィールドは、flagsフィールドに設定された再生可能フラグを持っているチケットにのみ存在します。これは、更新中に含めることができる最大のendtimeを示しています。これは、すべての更新を含むチケットの絶対有効期限、と考えることができます。"
    },
    {
      "indent": 3,
      "text": "caddr This field in a ticket contains zero (if omitted) or more (if present) host addresses. These are the addresses from which the ticket can be used. If there are no addresses, the ticket can be used from any location. The decision by the KDC to issue or by the end server to accept addressless tickets is a policy decision and is left to the Kerberos and end-service administrators; they MAY refuse to issue or accept such tickets. Because of the wide deployment of network address translation, it is recommended that policy allow the issue and acceptance of such tickets.",
      "ja": "チケット内のこのフィールドCADDRは、ホストアドレス（存在する場合）、ゼロ（省略された場合）、またはそれ以上が含まれています。これらは、チケットを使用することができ、そこからアドレスです。何のアドレスが存在しない場合、チケットはどこからでも使用することができます。アドレスなしチケットを受け入れるために発行するか、エンドサーバによってKDCの決定は、政策決定で、Kerberosおよびエンド・サービスの管理者に任されています。彼らは、そのようなチケットを発行するか、受け入れることを拒否することができます。そのため、ネットワークアドレス変換の幅広い展開のために、それは政策が問題と、そのようなチケットの受け入れを許可することをお勧めします。"
    },
    {
      "indent": 6,
      "text": "Network addresses are included in the ticket to make it harder for an attacker to use stolen credentials. Because the session key is not sent over the network in cleartext, credentials can't be stolen simply by listening to the network; an attacker has to gain access to the session key (perhaps through operating system security breaches or a careless user's unattended session) to make use of stolen tickets.",
      "ja": "ネットワークアドレスは、それが難しく、攻撃者が盗まれた資格情報を使用できるようにすること、チケットに含まれています。セッション鍵がクリアテキストでネットワーク経由で送信されていないので、資格情報がネットワークを聞くことによって簡単に盗まれたことができません。攻撃者は、盗まれたチケットを利用するために（おそらく、オペレーティングシステムのセキュリティ侵害や不注意なユーザーの無人のセッションを介して）セッションキーへのアクセスを得るために持っています。"
    },
    {
      "indent": 6,
      "text": "Note that the network address from which a connection is received cannot be reliably determined. Even if it could be, an attacker who has compromised the client's workstation could use the credentials from there. Including the network addresses only makes it more difficult, not impossible, for an attacker to walk off with stolen credentials and then to use them from a \"safe\" location.",
      "ja": "接続が受信されたネットワークアドレスを確実に決定することができないことに留意されたいです。それができたとしても、クライアントのワークステーションを侵害した攻撃者は、そこからの資格情報を使用することができます。ネットワークアドレスを含むだけでは、不可能ではない、より困難な攻撃者は、「安全な」場所からそれらを使用するために、その後盗まれた資格情報を使用してオフに歩いてできるようになります。"
    },
    {
      "indent": 3,
      "text": "authorization-data The authorization-data field is used to pass authorization data from the principal on whose behalf a ticket was issued to the application service. If no authorization data is included, this field will be left out. Experience has shown that the name of this field is confusing, and that a better name would be \"restrictions\". Unfortunately, it is not possible to change the name at this time.",
      "ja": "認証データは、認証データフィールドは、チケットがアプリケーションサービスに発行されたその代わりに、校長からの認証データを渡すために使用されます。無許可のデータが含まれていない場合、このフィールドは省略されます。経験は、このフィールドの名前が混乱して、より良い名前が「制限」になることが示されました。残念ながら、この時点で名前を変更することはできません。"
    },
    {
      "indent": 6,
      "text": "This field contains restrictions on any authority obtained on the basis of authentication using the ticket. It is possible for any principal in possession of credentials to add entries to the authorization data field since these entries further restrict what can be done with the ticket. Such additions can be made by specifying the additional entries when a new ticket is obtained during the TGS exchange, or they MAY be added during chained delegation using the authorization data field of the authenticator.",
      "ja": "このフィールドは、チケットを使用した認証に基づいて得られたすべての権限の制限が含まれています。これらのエントリは、さらにチケットで何ができるかを制限するので資格情報を所持して元本が認証データフィールドにエントリを追加することが可能です。このような追加は、新しいチケットがTGS交換の際に得られる追加のエントリを指定することによって行うことができ、またはこれらは、認証の承認データフィールドを使用して連鎖委任中に添加してもよいです。"
    },
    {
      "indent": 6,
      "text": "Because entries may be added to this field by the holder of credentials, except when an entry is separately authenticated by encapsulation in the KDC-issued element, it is not allowable for the presence of an entry in the authorization data field of a ticket to amplify the privileges one would obtain from using a ticket.",
      "ja": "エントリはエントリが別途KDC-発行の要素にカプセル化によって認証された場合を除き、資格証明書の所有者がこのフィールドに追加することができるので、増幅するように、チケットの許可データフィールドにエントリが存在するために許容されていません特権は1は、チケットを使用することから得られるでしょう。"
    },
    {
      "indent": 6,
      "text": "The data in this field may be specific to the end service; the field will contain the names of service specific objects, and the rights to those objects. The format for this field is described in Section 5.2.6. Although Kerberos is not concerned with the format of the contents of the subfields, it does carry type information (ad-type).",
      "ja": "このフィールドのデータは、エンド・サービスに特異的であってもよいです。フィールドには、サービス固有のオブジェクト、およびそれらのオブジェクトへの権限の名前が含まれます。このフィールドの形式は、セクション5.2.6に記載されています。ケルベロスは、サブフィールドのコンテンツのフォーマットに関するものではないが、タイプ情報（広告型）を担持し。"
    },
    {
      "indent": 6,
      "text": "By using the authorization_data field, a principal is able to issue a proxy that is valid for a specific purpose. For example, a client wishing to print a file can obtain a file server proxy to be passed to the print server. By specifying the name of the file in the authorization_data field, the file server knows that the print server can only use the client's rights when accessing the particular file to be printed.",
      "ja": "authorization_dataフィールドを使用することにより、プリンシパルは特定の目的のために有効なプロキシを発行することができます。たとえば、ファイルを印刷したいクライアントは、プリントサーバに渡されるファイルサーバのプロキシを取得することができます。 authorization_dataフィールドにファイルの名前を指定することで、ファイルサーバは、印刷する特定のファイルにアクセスするとき、プリントサーバーのみ、クライアントの権利を使用することができることを知っています。"
    },
    {
      "indent": 6,
      "text": "A separate service providing authorization or certifying group membership may be built using the authorization-data field. In this case, the entity granting authorization (not the authorized entity) may obtain a ticket in its own name (e.g., the ticket is issued in the name of a privilege server), and this entity adds restrictions on its own authority and delegates the restricted authority through a proxy to the client. The client would then present this authorization credential to the application server separately from the authentication exchange. Alternatively, such authorization credentials MAY be embedded in the ticket authenticating the authorized entity, when the authorization is separately authenticated using the KDC-issued authorization data element (see 5.2.6.2).",
      "ja": "別のサービスの認可を提供するか、グループメンバーシップを証明するには、認証データフィールドを使用して構築することができます。この場合、承認（権限のある機関ではない）を付与するエンティティ（例えば、チケットは特権サーバの名前で発行された）独自の名前でチケットを入手することができ、このエンティティは、職権上の制約と、デリゲート追加しますクライアントへのプロキシ経由の権限を制限しました。次に、クライアントは認証交換とは別に、アプリケーションサーバに、この認証資格を提示します。あるいは、このような認証の資格情報は、権限のある機関を認証チケット、認証を別々にKDC-発行の承認データ要素を使用して認証された場合（5.2.6.2を参照）に埋め込まれていてもよいです。"
    },
    {
      "indent": 6,
      "text": "Similarly, if one specifies the authorization-data field of a proxy and leaves the host addresses blank, the resulting ticket and session key can be treated as a capability. See [Neu93] for some suggested uses of this field.",
      "ja": "1は、プロキシの認証データフィールドを指定し、空白のホストアドレスを離れた場合も同様に、結果のチケットとセッション鍵は、機能として扱うことができます。このフィールドのいくつかの提案用途のために[Neu93]を参照してください。"
    },
    {
      "indent": 6,
      "text": "The authorization-data field is optional and does not have to be included in a ticket.",
      "ja": "認証データフィールドはオプションで、チケットに含まれている必要はありません。"
    },
    {
      "indent": 0,
      "text": "5.4. Specifications for the AS and TGS Exchanges",
      "section_title": true,
      "ja": "5.4.  ASおよびTGS交換のための仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format of the messages used in the exchange between the client and the Kerberos server. The format of possible error messages appears in Section 5.9.1.",
      "ja": "このセクションでは、クライアントとKerberosサーバ間の交換に使用するメッセージの形式を指定します。可能なエラーメッセージの形式は、5.9.1項に表示されます。"
    },
    {
      "indent": 0,
      "text": "5.4.1. KRB_KDC_REQ Definition",
      "section_title": true,
      "ja": "5.4.1.  KRB_KDC_REQ定義"
    },
    {
      "indent": 3,
      "text": "The KRB_KDC_REQ message has no application tag number of its own. Instead, it is incorporated into either KRB_AS_REQ or KRB_TGS_REQ, each of which has an application tag, depending on whether the request is for an initial ticket or an additional ticket. In either case, the message is sent from the client to the KDC to request credentials for a service.",
      "ja": "KRB_KDC_REQメッセージは、独自のないアプリケーションタグ番号を持っていません。代わりに、要求は、初期チケットまたは追加のチケットのためのものであるかどうかに応じて、アプリケーション・タグをそれぞれ有する、KRB_AS_REQまたはKRB_TGS_REQのいずれかに組み込まれています。いずれの場合も、メッセージは、サービスの資格情報を要求するために、KDCにクライアントから送信されます。"
    },
    {
      "indent": 3,
      "text": "The message fields are as follows:",
      "ja": "次のようにメッセージのフィールドは次のとおりです。"
    },
    {
      "indent": 0,
      "text": "AS-REQ          ::= [APPLICATION 10] KDC-REQ",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "TGS-REQ         ::= [APPLICATION 12] KDC-REQ",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDC-REQ         ::= SEQUENCE {\n        -- NOTE: first tag is [1], not [0]\n        pvno            [1] INTEGER (5) ,\n        msg-type        [2] INTEGER (10 -- AS -- | 12 -- TGS --),\n        padata          [3] SEQUENCE OF PA-DATA OPTIONAL\n                            -- NOTE: not empty --,\n        req-body        [4] KDC-REQ-BODY\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDC-REQ-BODY    ::= SEQUENCE {\n        kdc-options             [0] KDCOptions,\n        cname                   [1] PrincipalName OPTIONAL\n                                    -- Used only in AS-REQ --,\n        realm                   [2] Realm\n                                    -- Server's realm\n                                    -- Also client's in AS-REQ --,\n        sname                   [3] PrincipalName OPTIONAL,\n        from                    [4] KerberosTime OPTIONAL,\n        till                    [5] KerberosTime,\n        rtime                   [6] KerberosTime OPTIONAL,\n        nonce                   [7] UInt32,\n        etype                   [8] SEQUENCE OF Int32 -- EncryptionType\n                                    -- in preference order --,\n        addresses               [9] HostAddresses OPTIONAL,\n        enc-authorization-data  [10] EncryptedData OPTIONAL\n                                    -- AuthorizationData --,\n        additional-tickets      [11] SEQUENCE OF Ticket OPTIONAL\n                                       -- NOTE: not empty\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDCOptions      ::= KerberosFlags\n        -- reserved(0),\n        -- forwardable(1),\n        -- forwarded(2),\n        -- proxiable(3),\n        -- proxy(4),\n        -- allow-postdate(5),\n        -- postdated(6),\n        -- unused7(7),\n        -- renewable(8),\n        -- unused9(9),\n        -- unused10(10),",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " -- opt-hardware-auth(11), -- unused12(12), -- unused13(13), -- 15 is reserved for canonicalize -- unused15(15), -- 26 was unused in 1510 -- disable-transited-check(26), -- -- renewable-ok(27), -- enc-tkt-in-skey(28), -- renew(30), -- validate(31)",
      "ja": " - オプトウェア-AUTH（11）、 -  unused12（12）、 -  unused13（13）、 -  15は、カノニカル化のために予約されている -  unused15（15）、 -  26 1510に未使用でした -  DISABLE-遷移チェック（26）、 -   - 再生可能なOK（27）、 -  ENC-TKTインSKEY（28） - （31）検証 - 、（30）を更新します"
    },
    {
      "indent": 3,
      "text": "The fields in this message are as follows:",
      "ja": "次のようにこのメッセージ内のフィールドは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "pvno This field is included in each message, and specifies the protocol version number. This document specifies protocol version 5.",
      "ja": "PVNOこのフィールドは、各メッセージに含まれ、プロトコルバージョン番号を指定しています。このドキュメントでは、プロトコルのバージョン5を指定します。"
    },
    {
      "indent": 3,
      "text": "msg-type This field indicates the type of a protocol message. It will almost always be the same as the application identifier associated with a message. It is included to make the identifier more readily accessible to the application. For the KDC-REQ message, this type will be KRB_AS_REQ or KRB_TGS_REQ.",
      "ja": "MSG-typeこのフィールドは、プロトコルメッセージのタイプを示します。それはほとんど常にメッセージに関連付けられたアプリケーション識別子と同じになります。アプリケーションの識別子がより容易にアクセスできるように含まれています。 KDC-REQメッセージの場合、このタイプはKRB_AS_REQまたはKRB_TGS_REQになります。"
    },
    {
      "indent": 3,
      "text": "padata Contains pre-authentication data. Requests for additional tickets (KRB_TGS_REQ) MUST contain a padata of PA-TGS-REQ.",
      "ja": "PADATAは、事前認証データが含まれています。追加チケット（KRB_TGS_REQ）の要求はPA-TGS-REQのPADATAを含まなければなりません。"
    },
    {
      "indent": 6,
      "text": "The padata (pre-authentication data) field contains a sequence of authentication information that may be needed before credentials can be issued or decrypted.",
      "ja": "PADATA（事前認証データ）フィールドには、証明書が発行されたり解読することができる前に必要とされる認証情報の配列を含みます。"
    },
    {
      "indent": 3,
      "text": "req-body This field is a placeholder delimiting the extent of the remaining fields. If a checksum is to be calculated over the request, it is calculated over an encoding of the KDC-REQ-BODY sequence which is enclosed within the req-body field.",
      "ja": "REQ-体は、このフィールドには、残りのフィールドの範囲を区切るプレースホルダです。チェックサムが要求にわたって計算される場合、それは、REQ-ボディフィールド内に封入されているKDC-REQ-BODYシーケンスの符号化に対して計算されます。"
    },
    {
      "indent": 3,
      "text": "kdc-options This field appears in the KRB_AS_REQ and KRB_TGS_REQ requests to the KDC and indicates the flags that the client wants set on the tickets as well as other information that is to modify the behavior of the KDC. Where appropriate, the name of an option may be the same as the flag that is set by that option. Although in most cases, the bit in the options field will be the same as that in the flags field, this is not guaranteed, so it is not acceptable simply to copy the options field to the flags field. There are various checks that must be made before an option is honored anyway.",
      "ja": "KDC-オプションをこのフィールドには、KDCへのKRB_AS_REQとKRB_TGS_REQ要求に表示され、クライアントがチケットに設定されただけでなく、KDCの動作を変更することで、他の情報望んでいるのフラグを示します。適切な場合、オプションの名前は、オプションで設定されるフラグと同じであってもよいです。ほとんどの場合、オプションフィールドのビットはフラグフィールドと同じになりますが、これは保証されませんので、flagsフィールドにオプションフィールドをコピーするだけで受け入れられないです。オプションはとにかく光栄れる前に行われなければならない様々なチェックがあります。"
    },
    {
      "indent": 6,
      "text": "The kdc_options field is a bit-field, where the selected options are indicated by the bit being set (1), and the unselected options and reserved fields being reset (0). The encoding of the bits is specified in Section 5.2. The options are described in more detail above in Section 2. The meanings of the options are as follows:",
      "ja": "kdc_optionsフィールドは、ビットが（1）に設定されることにより選択されたオプションが表示されているビットフィールドであり、非選択オプションおよび予約フィールドリセットされる（0）。ビットの符号化は、セクション5.2で指定されています。オプションは、以下のようにオプションの意味は、セクション2で上記により詳細に記載されています。"
    },
    {
      "indent": 3,
      "text": "Bits Name Description",
      "ja": "ビット名前説明"
    },
    {
      "indent": 3,
      "text": "0 RESERVED Reserved for future expansion of this field.",
      "ja": "この分野の将来の拡張のためReserved 0予約。"
    },
    {
      "indent": 3,
      "text": "1 FORWARDABLE The FORWARDABLE option indicates that the ticket to be issued is to have its forwardable flag set. It may only be set on the initial request, or in a subsequent request if the TGT on which it is based is also forwardable.",
      "ja": "1つのFORWARDABLEザ・FORWARDABLEオプションは、発行されるチケットがその転送可能フラグが設定されているべきであることを示します。それが基づいているTGTも転送可能である場合にのみ、最初のリクエストに応じて、または後続の要求に設定してもよいです。"
    },
    {
      "indent": 3,
      "text": "2 FORWARDED The FORWARDED option is only specified in a request to the ticket-granting server and will only be honored if the TGT in the request has its FORWARDABLE bit set. This option indicates that this is a request for forwarding. The address(es) of the host from which the resulting ticket is to be valid are included in the addresses field of the request.",
      "ja": "2は、転送されたオプションは、チケット交付サーバーへの要求で指定され、要求でTGTがFORWARDABLEビットがセットされている場合にのみ表彰されますFORWARDED。このオプションでは、これは、転送の要求であることを示しています。結果のチケットが有効であるとされたホストのアドレス（複数可）は、要求のアドレスフィールドに含まれています。"
    },
    {
      "indent": 3,
      "text": "3 PROXIABLE The PROXIABLE option indicates that the ticket to be issued is to have its proxiable flag set. It may only be set on the initial request, or a subsequent request if the TGT on which it is based is also proxiable.",
      "ja": "3 PROXIABLEザ・PROXIABLEオプションは、発行されるチケットがその代理可能フラグが設定されているべきであることを示します。それが基づいているTGTもプロキシ可能である場合にのみ、最初の要求、または後続の要求に設定してもよいです。"
    },
    {
      "indent": 3,
      "text": "4 PROXY The PROXY option indicates that this is a request for a proxy. This option will only be honored if the TGT in the request has its PROXIABLE bit set. The address(es) of the host from which the resulting ticket is to be valid are included in the addresses field of the request.",
      "ja": "4 PROXY PROXYオプションは、これは、プロキシの要求であることを示しています。リクエストでTGTがPROXIABLEビットがセットされている場合にだけ、このオプションは光栄されます。結果のチケットが有効であるとされたホストのアドレス（複数可）は、要求のアドレスフィールドに含まれています。"
    },
    {
      "indent": 3,
      "text": "5 ALLOW-POSTDATE The ALLOW-POSTDATE option indicates that the ticket to be issued is to have its MAY-POSTDATE flag set. It may only be set on the initial request, or in a subsequent request if the TGT on which it is based also has its MAY-POSTDATE flag set.",
      "ja": "5許可 -  POSTDATEザ・許可 -  POSTDATEオプションが発行されるチケットは、そのMAY-POSTDATEフラグが設定されているべきであることを示します。それだけで最初の要求に、またはそれにも基づいているTGTがMAY-POSTDATEフラグが設定されている場合、後続の要求に設定してもよいです。"
    },
    {
      "indent": 3,
      "text": "6 POSTDATED The POSTDATED option indicates that this is a request for a postdated ticket. This option will only be honored if the TGT on which it is based has its MAY-POSTDATE flag set. The resulting ticket will also have its INVALID flag set, and that flag may be reset by a subsequent request to the KDC after the starttime in the ticket has been reached.",
      "ja": "6 POSTDATEDザ・POSTDATEDオプションでは、これが遅延チケットの要求であることを示しています。それが基づいているTGTがそのMAY-POSTDATEフラグがセットされている場合にだけ、このオプションは光栄されます。得られたチケットは、その無効フラグが設定されているであろう、そしてチケットにSTARTTIMEに達した後、そのフラグは、KDCに後続の要求によってリセットすることができます。"
    },
    {
      "indent": 3,
      "text": "7 RESERVED This option is presently unused.",
      "ja": "7 RESERVEDこのオプションは、現在使用されていません。"
    },
    {
      "indent": 3,
      "text": "8 RENEWABLE The RENEWABLE option indicates that the ticket to be issued is to have its RENEWABLE flag set. It may only be set on the initial request, or when the TGT on which the request is based is also renewable. If this option is requested, then the rtime field in the request contains the desired absolute expiration time for the ticket.",
      "ja": "8再生可能再生可能オプションが発行されるチケットは、その再生可能フラグが設定されているべきであることを示します。それだけ初期の要求に設定されてもよいし、要求が基づいているTGTも再生可能である場合。このオプションが要求されている場合は、要求の中RTIMEフィールドは、チケットのために所望の絶対的な有効期限が含まれています。"
    },
    {
      "indent": 3,
      "text": "9 RESERVED Reserved for PK-Cross.",
      "ja": "PK-クロスのための9 RESERVED予約。"
    },
    {
      "indent": 3,
      "text": "10 RESERVED Reserved for future use.",
      "ja": "将来の使用のための10 RESERVED予約。"
    },
    {
      "indent": 3,
      "text": "11 RESERVED Reserved for opt-hardware-auth.",
      "ja": "オプトハードウェア認証のための11 RESERVED予約。"
    },
    {
      "indent": 3,
      "text": "12-25 RESERVED Reserved for future use.",
      "ja": "将来の使用のために12-25 RESERVED予約。"
    },
    {
      "indent": 3,
      "text": "26 DISABLE-TRANSITED-CHECK By default the KDC will check the transited field of a TGT against the policy of the local realm before it will issue derivative tickets based on the TGT. If this flag is set in the request, checking of the transited field is disabled. Tickets issued without the performance of this check will be noted by the reset (0) value of the TRANSITED-POLICY-CHECKED flag, indicating to the application server that the transited field must be checked locally. KDCs are encouraged but not required to honor the DISABLE-TRANSITED-CHECK option.",
      "ja": "それはTGTに基づいて派生チケットを発行します前に、26 DISABLE-TRANSITED-CHECKデフォルトでは、KDCは、地元の分野の政策に対するTGTの通過している分野をチェックします。このフラグは、要求に設定されている場合は、通過している分野のチェックが無効になっています。このチェックの性能をせずに発行したチケットは通過している分野は、ローカルにチェックされなければならないアプリケーションサーバに指示する、遷移-POLICY-CHECKEDフラグのリセット（0）の値によって注目されるであろう。 KDCは奨励が、DISABLE-TRANSITED-CHECKオプションを尊重する必要はありません。"
    },
    {
      "indent": 36,
      "text": "This flag is new since RFC 1510.",
      "ja": "このフラグは、RFC 1510以降の新機能です。"
    },
    {
      "indent": 3,
      "text": "27 RENEWABLE-OK The RENEWABLE-OK option indicates that a renewable ticket will be acceptable if a ticket with the requested life cannot otherwise be provided, in which case a renewable ticket may be issued with a renew-till equal to the requested endtime. The value of the renew-till field may still be limited by local limits, or limits selected by the individual principal or server.",
      "ja": "27再生可能-OK再生可能OKオプションは、要求された生活にチケットがそうでない再生可能なチケットが更新-まで要求された終了時刻に等しいで発行されてもよく、この場合には、提供することができない場合は、再生可能チケットが許容されることを示しています。更新-までフィールドの値は、まだローカル制限、または個々のプリンシパルまたはサーバによって選択された制限によって制限され得ます。"
    },
    {
      "indent": 3,
      "text": "28 ENC-TKT-IN-SKEY This option is used only by the ticket-granting service. The ENC-TKT-IN-SKEY option indicates that the ticket for the end server is to be encrypted in the session key from the additional TGT provided.",
      "ja": "28 ENC-TKT-IN-SKEYこのオプションは、チケット許可サービスによって使用されます。 ENC-TKT-IN-SKEYオプションは、エンドサーバのチケットが提供される追加のTGTからのセッション鍵で暗号化されることを示します。"
    },
    {
      "indent": 3,
      "text": "29 RESERVED Reserved for future use.",
      "ja": "将来の使用のための29 RESERVED予約。"
    },
    {
      "indent": 3,
      "text": "30 RENEW This option is used only by the ticket-granting service. The RENEW option indicates that the present request is for a renewal. The ticket provided is encrypted in the secret key for the server on which it is valid. This option will only be honored if the ticket to be renewed has its RENEWABLE flag set and if the time in its renew-till field has not passed. The ticket to be renewed is passed in the padata field as part of the authentication header.",
      "ja": "30このオプションは、チケット交付サービスで使用されRENEW。 RENEWオプションは、現在の要求が更新のためであることを示しています。提供チケットは、それが有効である上、サーバ用の秘密鍵で暗号化されています。更新するチケットは、その再生可能フラグがセットされている場合、その更新-までフィールド内の時間が経過していない場合は、このオプションは光栄されます。更新するためのチケットは、認証ヘッダの一部としてPADATAフィールドに渡されます。"
    },
    {
      "indent": 3,
      "text": "31 VALIDATE This option is used only by the ticket-granting service. The VALIDATE option indicates that the request is to validate a postdated ticket. It will only be honored if the ticket presented is postdated, presently has its INVALID flag set, and would otherwise be usable at this time. A ticket cannot be validated before its starttime. The ticket presented for validation is encrypted in the key of the server for which it is valid and is passed in the padata field as part of the authentication header.",
      "ja": "31 VALIDATEは、このオプションは、チケット認可サービスによって使用されています。 VALIDATEオプションは、要求が遅延チケットを検証することであることを示しています。提示チケットが先日付を書かれている場合のみ、現在その無効なフラグがセットされている、表彰されますし、そうでない場合は、この時点で使用可能になります。チケットは、そのSTARTTIME前に検証することはできません。検証のために提示したチケットは、それが有効であると認証ヘッダーの一部としてPADATAフィールドで渡されるため、サーバの鍵で暗号化されます。"
    },
    {
      "indent": 3,
      "text": "cname and sname These fields are the same as those described for the ticket in section 5.3. The sname may only be absent when the ENC-TKT-IN-SKEY option is specified. If the sname is absent, the name of the server is taken from the name of the client in the ticket passed as additional-tickets.",
      "ja": "これらのフィールドをCNAMEとSNAMEセクション5.3でのチケットのために説明したものと同じです。 ENC-TKT-IN-SKEYオプションが指定されている場合SNAMEにのみ存在しなくてもよいです。 SNAMEが存在しない場合は、サーバーの名前を追加、チケットとして渡されたチケットにクライアントの名前から取られています。"
    },
    {
      "indent": 3,
      "text": "enc-authorization-data The enc-authorization-data, if present (and it can only be present in the TGS_REQ form), is an encoding of the desired authorization-data encrypted under the sub-session key if present in the Authenticator, or alternatively from the session key in the TGT (both the Authenticator and TGT come from the padata field in the KRB_TGS_REQ). The key usage value used when encrypting is 5 if a sub-session key is used, or 4 if the session key is used.",
      "ja": "ENC-認可データENC-認可データ、認証中に存在する場合、サブセッションキーの下で暗号化された所望の認可データの符号化であるか、または（それが唯一TGS_REQの形態で存在することができる）存在する場合に代わりTGTのセッション鍵（認証及びTGT両方がKRB_TGS_REQにPADATAフィールドから来る）から。セッションキーが使用される場合、暗号化する際に使用される主要な用法値は、サブセッション鍵が使用される場合5、又は4です。"
    },
    {
      "indent": 3,
      "text": "realm This field specifies the realm part of the server's principal identifier. In the AS exchange, this is also the realm part of the client's principal identifier.",
      "ja": "分野このフィールドは、サーバーの主要な識別子の分野の部分を指定します。 AS交換では、これはまた、クライアントの主要な識別子のレルム部分です。"
    },
    {
      "indent": 3,
      "text": "from This field is included in the KRB_AS_REQ and KRB_TGS_REQ ticket requests when the requested ticket is to be postdated. It specifies the desired starttime for the requested ticket. If this field is omitted, then the KDC SHOULD use the current time instead.",
      "ja": "要求されたチケットが先日付を書かされる場合、このフィールドからKRB_AS_REQとKRB_TGS_REQチケット要求に含まれています。これは、要求されたチケットの希望のstarttimeを指定します。このフィールドを省略すると、KDCは、代わりに現在の時刻を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "till This field contains the expiration date requested by the client in a ticket request. It is not optional, but if the requested endtime is \"19700101000000Z\", the requested ticket is to have the maximum endtime permitted according to KDC policy. Implementation note: This special timestamp corresponds to a UNIX time_t value of zero on most systems.",
      "ja": "このフィールドまでのチケット要求でクライアントによって要求された有効期限が含まれています。これはオプションではありませんが、要求された終了時刻が「19700101000000Z」であれば、要求されたチケットは、KDCポリシーに従って許可された最大のendtimeを持つことです。実装上の注意：この特別なタイムスタンプは、ほとんどのシステム上のゼロのUNIXのtime_tの値に対応します。"
    },
    {
      "indent": 3,
      "text": "rtime This field is the requested renew-till time sent from a client to the KDC in a ticket request. It is optional.",
      "ja": "このフィールドをRTIME更新-までチケット要求でKDCにクライアントから送信された時間に要求されます。これはオプションです。"
    },
    {
      "indent": 3,
      "text": "nonce This field is part of the KDC request and response. It is intended to hold a random number generated by the client. If the same number is included in the encrypted response from the KDC, it provides evidence that the response is fresh and has not been replayed by an attacker. Nonces MUST NEVER be reused.",
      "ja": "ナンスこのフィールドは、KDC要求と応答の一部です。クライアントによって生成された乱数を保持することを目的としています。同じ番号がKDCからの暗号化された応答に含まれている場合は、それはレスポンスが新鮮で、攻撃者によって再演されていないという証拠を提供します。ナンスは再利用してはなりません。"
    },
    {
      "indent": 3,
      "text": "etype This field specifies the desired encryption algorithm to be used in the response.",
      "ja": "ETYPEこのフィールドは、応答で使用されるべき所望の暗号化アルゴリズムを指定します。"
    },
    {
      "indent": 3,
      "text": "addresses This field is included in the initial request for tickets, and it is optionally included in requests for additional tickets from the ticket-granting server. It specifies the addresses from which the requested ticket is to be valid. Normally it includes the addresses for the client's host. If a proxy is requested, this field will contain other addresses. The contents of this field are usually copied by the KDC into the caddr field of the resulting ticket.",
      "ja": "アドレスこのフィールドは、チケットの最初の要求に含まれており、それは、必要に応じてチケット認可サーバーからの追加チケットの要求に含まれています。これは、要求されたチケットが有効であるとされたアドレスを指定します。通常は、クライアントのホストのアドレスを含んでいます。プロキシが要求されている場合、このフィールドは、他のアドレスが含まれます。このフィールドの内容は、通常、結果のチケットのCADDRフィールドにKDCによってコピーされます。"
    },
    {
      "indent": 3,
      "text": "additional-tickets Additional tickets MAY be optionally included in a request to the ticket-granting server. If the ENC-TKT-IN-SKEY option has been specified, then the session key from the additional ticket will be used in place of the server's key to encrypt the new ticket. When the ENC-TKT-IN-SKEY option is used for user-to-user authentication, this additional ticket MAY be a TGT issued by the local realm or an inter-realm TGT issued for the current KDC's realm by a remote KDC. If more than one option that requires additional tickets has been specified, then the additional tickets are used in the order specified by the ordering of the options bits (see kdc-options, above).",
      "ja": "追加-のチケットの追加のチケットは、必要に応じて、チケット認可サーバへのリクエストに含まれるかもしれません。 ENC-TKT-IN-SKEYオプションが指定されている場合は、追加チケットから主要なセッションは、新しいチケットを暗号化するために、サーバーのキーの代わりに使用されます。 ENC-TKT-IN-SKEYオプションはユーザ・ユーザ認証のために使用されている場合、この追加のチケットは地元の分野によって発行されたTGTであってもよいし、レルム間TGTは、リモートKDCによって現在のKDCのレルムのために発行しました。追加のチケットを要求する複数のオプションが指定されている場合は、追加のチケットはオプションビットの順序で指定された順序で使用されている（上記、KDC-オプションを参照してください）。"
    },
    {
      "indent": 3,
      "text": "The application tag number will be either ten (10) or twelve (12) depending on whether the request is for an initial ticket (AS-REQ) or for an additional ticket (TGS-REQ).",
      "ja": "アプリケーションタグ番号は、要求が（AS-REQ）初期チケットまたは追加のチケット（TGS-REQ）のためのものであるかどうかに応じて（12）、10（10）、または12のいずれかであろう。"
    },
    {
      "indent": 3,
      "text": "The optional fields (addresses, authorization-data, and additional-tickets) are only included if necessary to perform the operation specified in the kdc-options field.",
      "ja": "KDC-optionsフィールドで指定された操作を実行するために必要に応じてオプションのフィールド（アドレス、認証データ、および追加の-チケット）のみ含まれています。"
    },
    {
      "indent": 3,
      "text": "Note that in KRB_TGS_REQ, the protocol version number appears twice and two different message types appear: the KRB_TGS_REQ message contains these fields as does the authentication header (KRB_AP_REQ) that is passed in the padata field.",
      "ja": "PADATAフィールドに渡され、認証ヘッダ（KRB_AP_REQ）がそうであるようKRB_TGS_REQメッセージは、これらのフィールドが含まれていますKRB_TGS_REQに、プロトコルバージョン番号が2回出現し、二つの異なるメッセージタイプが表示されることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "5.4.2. KRB_KDC_REP Definition",
      "section_title": true,
      "ja": "5.4.2.  KRB_KDC_REP定義"
    },
    {
      "indent": 3,
      "text": "The KRB_KDC_REP message format is used for the reply from the KDC for either an initial (AS) request or a subsequent (TGS) request. There is no message type for KRB_KDC_REP. Instead, the type will be either KRB_AS_REP or KRB_TGS_REP. The key used to encrypt the ciphertext part of the reply depends on the message type. For KRB_AS_REP, the ciphertext is encrypted in the client's secret key, and the client's key version number is included in the key version number for the encrypted data. For KRB_TGS_REP, the ciphertext is encrypted in the sub-session key from the Authenticator; if it is absent, the ciphertext is encrypted in the session key from the TGT used in the request. In that case, no version number will be present in the EncryptedData sequence.",
      "ja": "KRB_KDC_REPメッセージフォーマットは、初期（AS）要求または後続（TGS）要求のいずれかのためのKDCからの応答のために使用されます。 KRB_KDC_REPのためのメッセージタイプはありません。代わりに、タイプはKRB_AS_REPまたはKRB_TGS_REPのいずれかになります。応答の暗号文部分を暗号化するために使用される鍵は、メッセージのタイプに依存します。 KRB_AS_REPに関しては、暗号文は、クライアントの秘密鍵で暗号化され、クライアントの鍵バージョン番号は暗号化されたデータのための鍵のバージョン番号に含まれています。 KRB_TGS_REPため、暗号文を認証からサブセッション鍵で暗号化されています。それが存在しない場合、暗号文は、要求で使用さTGTからのセッション鍵で暗号化されます。その場合には、バージョン番号ははEncryptedData配列中に存在しないであろう。"
    },
    {
      "indent": 3,
      "text": "The KRB_KDC_REP message contains the following fields:",
      "ja": "KRB_KDC_REPメッセージは、次のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "AS-REP          ::= [APPLICATION 11] KDC-REP",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TGS-REP         ::= [APPLICATION 13] KDC-REP",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "KDC-REP         ::= SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (11 -- AS -- | 13 -- TGS --),\n        padata          [2] SEQUENCE OF PA-DATA OPTIONAL\n                                -- NOTE: not empty --,\n        crealm          [3] Realm,\n        cname           [4] PrincipalName,\n        ticket          [5] Ticket,\n        enc-part        [6] EncryptedData\n                                -- EncASRepPart or EncTGSRepPart,\n                                -- as appropriate\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EncASRepPart    ::= [APPLICATION 25] EncKDCRepPart",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EncTGSRepPart   ::= [APPLICATION 26] EncKDCRepPart",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EncKDCRepPart   ::= SEQUENCE {\n        key             [0] EncryptionKey,\n        last-req        [1] LastReq,\n        nonce           [2] UInt32,\n        key-expiration  [3] KerberosTime OPTIONAL,\n        flags           [4] TicketFlags,\n        authtime        [5] KerberosTime,\n        starttime       [6] KerberosTime OPTIONAL,\n        endtime         [7] KerberosTime,\n        renew-till      [8] KerberosTime OPTIONAL,\n        srealm          [9] Realm,\n        sname           [10] PrincipalName,\n        caddr           [11] HostAddresses OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "LastReq         ::=     SEQUENCE OF SEQUENCE {\n        lr-type         [0] Int32,\n        lr-value        [1] KerberosTime\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is either KRB_AS_REP or KRB_TGS_REP.",
      "ja": "PVNOとMSG型これらのフィールドは、5.4.1節で上記に記載されています。 MSG-タイプはKRB_AS_REPかKRB_TGS_REPのいずれかです。"
    },
    {
      "indent": 3,
      "text": "padata This field is described in detail in Section 5.4.1. One possible use for it is to encode an alternate \"salt\" string to be used with a string-to-key algorithm. This ability is useful for easing transitions if a realm name needs to change (e.g., when a company is acquired); in such a case all existing password-derived entries in the KDC database would be flagged as needing a special salt string until the next password change.",
      "ja": "PADATAこのフィールドは、5.4.1節で詳細に記載されています。そのための一つの可能​​な用途は、ストリングから鍵アルゴリズムで使用される代替的な「塩」の文字列を符号化することです。レルム名を変更する必要がある場合には、この能力は容易に移行するために有用である（例えば、会社が取得された場合）。このような場合にはKDCデータベース内のすべての既存のパスワード由来のエントリは、次のパスワードの変更まで、特別な塩文字列を必要としてフラグ付けされるだろう。"
    },
    {
      "indent": 3,
      "text": "crealm, cname, srealm, and sname These fields are the same as those described for the ticket in section 5.3.",
      "ja": "crealm、CNAME、srealm、およびこれらのフィールドをSNAMEは、セクション5.3でチケットのために説明したものと同じです。"
    },
    {
      "indent": 3,
      "text": "ticket The newly-issued ticket, from Section 5.3.",
      "ja": "チケットセクション5.3から新たに発行されたチケット、。"
    },
    {
      "indent": 3,
      "text": "enc-part This field is a place holder for the ciphertext and related information that forms the encrypted part of a message. The description of the encrypted part of the message follows each appearance of this field.",
      "ja": "ENC-部分は、このフィールドには、メッセージの暗号化された部分を形成して暗号文と関連情報のプレースホルダーです。メッセージの暗号化部分の説明はこの分野の各外観を以下。"
    },
    {
      "indent": 6,
      "text": "The key usage value for encrypting this field is 3 in an AS-REP message, using the client's long-term key or another key selected via pre-authentication mechanisms. In a TGS-REP message, the key usage value is 8 if the TGS session key is used, or 9 if a TGS authenticator subkey is used.",
      "ja": "このフィールドを暗号化するための鍵の使用値は、クライアントの長期的なキーまたは事前認証機構を介して選択された別のキーを使用して、AS-REPメッセージで3です。 TGS認証サブキーが使用される場合TGS-REPメッセージに、主要な用法値はTGSセッションキーが使用される場合8、または9です。"
    },
    {
      "indent": 6,
      "text": "Compatibility note: Some implementations unconditionally send an encrypted EncTGSRepPart (application tag number 26) in this field regardless of whether the reply is a AS-REP or a TGS-REP. In the interest of compatibility, implementors MAY relax the check on the tag number of the decrypted ENC-PART.",
      "ja": "互換性に関する注意：一部の実装では、無条件にかかわらず、返信はAS-REPまたはTGS-REPであるかどうかの、この分野では、暗号化さEncTGSRepPart（アプリケーションタグ番号26）を送ります。互換性の関心では、実装者は、復号化されたENC-PARTのタグ番号のチェックを緩和するかもしれません。"
    },
    {
      "indent": 3,
      "text": "key This field is the same as described for the ticket in Section 5.3.",
      "ja": "キーこのフィールドは、セクション5.3でのチケットのために説明と同じです。"
    },
    {
      "indent": 3,
      "text": "last-req This field is returned by the KDC and specifies the time(s) of the last request by a principal. Depending on what information is available, this might be the last time that a request for a TGT was made, or the last time that a request based on a TGT was successful. It also might cover all servers for a realm, or just the particular server. Some implementations MAY display this information to the user to aid in discovering unauthorized use of one's identity. It is similar in spirit to the last login time displayed when logging in to timesharing systems.",
      "ja": "最後-REQこのフィールドは、KDCによって返され、校長による最後の要求の時間（秒）を指定しています。利用可能なものの情報に応じて、これはTGTの要求が行われた最後の時間、またはTGTに基づいて要求が成功したことを最後の時間かもしれません。また、領域、または単に特定のサーバーのすべてのサーバーをカバーするかもしれません。一部の実装では、自分のアイデンティティの不正使用を発見を支援するために、ユーザーにこの情報を表示することができます。これは、タイムシェアリングシステムにログインするときに表示最終ログイン時刻とその精神において似ています。"
    },
    {
      "indent": 3,
      "text": "lr-type This field indicates how the following lr-value field is to be interpreted. Negative values indicate that the information pertains only to the responding server. Non-negative values pertain to all servers for the realm.",
      "ja": "LR-typeこのフィールドには、次のLR値フィールドを解釈する方法を示しています。負の値は情報のみの対応サーバーに関係することを示しています。非負の値は、レルムのすべてのサーバーに関係します。"
    },
    {
      "indent": 6,
      "text": "If the lr-type field is zero (0), then no information is conveyed by the lr-value subfield. If the absolute value of the lr-type field is one (1), then the lr-value subfield is the time of last initial request for a TGT. If it is two (2), then the lr-value subfield is the time of last initial request. If it is three (3), then the lr-value subfield is the time of issue for the newest TGT used. If it is four (4), then the lr-value subfield is the time of the last renewal. If it is five (5), then the lr-value subfield is the time of last request (of any type). If it is (6), then the lr-value subfield is the time when the password will expire. If it is (7), then the lr-value subfield is the time when the account will expire.",
      "ja": "LR-typeフィールドがゼロである場合（0）、その後、何の情報がLR-値サブフィールドによって搬送されていません。 LR-typeフィールドの絶対値が1である場合（1）、次いで、LR値サブフィールドは、TGTの最後の最初の要求時です。それは、2つ（2）の場合、LR-値サブフィールドは、最後の最初の要求時です。それは3つである場合、LR値のサブフィールドを使用最新TGTための問題の時間です。それは、4つ（4）の場合は、LR-値サブフィールドは、最後の更新の時間です。それは5（5）である場合、LR-値サブフィールドは、（任意の型の）最後の要求の時間です。それは（6）の場合、LR-値のサブフィールドは、パスワードの有効期限が切れる時間です。それは（7）の場合、LR-値のサブフィールドは、アカウントの有効期限が切れる時間です。"
    },
    {
      "indent": 3,
      "text": "lr-value This field contains the time of the last request. The time MUST be interpreted according to the contents of the accompanying lr-type subfield.",
      "ja": "LR-値は、このフィールドには、最後の要求の時間が含まれています。時間は、添付LR型サブフィールドの内容に従って解釈されなければなりません。"
    },
    {
      "indent": 3,
      "text": "nonce This field is described above in Section 5.4.1.",
      "ja": "ナンスこのフィールドは、セクション5.4.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "key-expiration The key-expiration field is part of the response from the KDC and specifies the time that the client's secret key is due to expire. The expiration might be the result of password aging or an account expiration. If present, it SHOULD be set to the earlier of the user's key expiration and account expiration. The use of this field is deprecated, and the last-req field SHOULD be used to convey this information instead. This field will usually be left out of the TGS reply since the response to the TGS request is encrypted in a session key and no client information has to be retrieved from the KDC database. It is up to the application client (usually the login program) to take appropriate action (such as notifying the user) if the expiration time is imminent.",
      "ja": "キーの有効期限キーの有効期限フィールドは、KDCからの応答の一部であり、クライアントの秘密鍵が期限切れにある時間を指定します。有効期限は、パスワードエージングやアカウントの有効期限の結果かもしれません。存在する場合、それはユーザーのキーの有効期限とアカウントの有効期限の以前に設定する必要があります。このフィールドの使用は推奨され、そして最後-REQフィールドには、代わりにこの情報を伝えるために使用されるべきです。 TGS要求に対する応答は、セッション鍵で暗号化されており、何のクライアント情報がKDCデータベースから取得する必要がないので、このフィールドには、通常TGS応答から除外されます。これは、有効期限が差し迫っている場合（例えば、ユーザーに通知するなど）適切な行動を取るようにアプリケーションクライアント（通常ログインプログラム）次第です。"
    },
    {
      "indent": 3,
      "text": "flags, authtime, starttime, endtime, renew-till and caddr These fields are duplicates of those found in the encrypted portion of the attached ticket (see Section 5.3), provided so the client MAY verify that they match the intended request and in order to assist in proper ticket caching. If the message is of type KRB_TGS_REP, the caddr field will only be filled in if the request was for a proxy or forwarded ticket, or if the user is substituting a subset of the addresses from the TGT. If the client-requested addresses are not present or not used, then the addresses contained in the ticket will be the same as those included in the TGT.",
      "ja": "旗、authtime、STARTTIME、終了時刻、まで-更新し、CADDRこれらのフィールドは、添付チケットの暗号化された部分に見られるものと重複している（5.3節を参照）、クライアントは、彼らが意図した要求と一致していることを確認し、するために、MAYように提供適切なチケットキャッシングを支援します。メッセージタイプKRB_TGS_REPである場合、要求がプロキシまたは転送チケットをした場合CADDRフィールドのみに充填されるか、またはユーザがTGTからアドレスのサブセットを置換されている場合。クライアントが要求したアドレスが使用される本かでない場合は、チケットに含まれるアドレスはTGTに含まれるものと同じになります。"
    },
    {
      "indent": 0,
      "text": "5.5. Client/Server (CS) Message Specifications",
      "section_title": true,
      "ja": "5.5. クライアント/サーバー（CS）メッセージ仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format of the messages used for the authentication of the client to the application server.",
      "ja": "このセクションでは、アプリケーションサーバへのクライアントの認証に使用するメッセージの形式を指定します。"
    },
    {
      "indent": 0,
      "text": "5.5.1. KRB_AP_REQ Definition",
      "section_title": true,
      "ja": "5.5.1.  KRB_AP_REQの定義"
    },
    {
      "indent": 3,
      "text": "The KRB_AP_REQ message contains the Kerberos protocol version number, the message type KRB_AP_REQ, an options field to indicate any options in use, and the ticket and authenticator themselves. The KRB_AP_REQ message is often referred to as the \"authentication header\".",
      "ja": "KRB_AP_REQメッセージは、Kerberosプロトコルバージョン番号、メッセージタイプKRB_AP_REQ、使用中の任意のオプションを示すために、オプションフィールド、およびチケットと自らをオーセンティケータが含まれています。 KRB_AP_REQメッセージは、多くの場合、「認証ヘッダ」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "AP-REQ          ::= [APPLICATION 14] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (14),\n        ap-options      [2] APOptions,\n        ticket          [3] Ticket,\n        authenticator   [4] EncryptedData -- Authenticator\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "APOptions       ::= KerberosFlags\n        -- reserved(0),\n        -- use-session-key(1),\n        -- mutual-required(2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is KRB_AP_REQ.",
      "ja": "PVNOとMSG型これらのフィールドは、5.4.1節で上記に記載されています。 MSG-typeはKRB_AP_REQです。"
    },
    {
      "indent": 3,
      "text": "ap-options This field appears in the application request (KRB_AP_REQ) and affects the way the request is processed. It is a bit-field, where the selected options are indicated by the bit being set (1), and the unselected options and reserved fields by being reset (0). The encoding of the bits is specified in Section 5.2. The meanings of the options are as follows:",
      "ja": "AP-オプションこのフィールドは、アプリケーション要求（KRB_AP_REQ）に表示され、要求が処理される方法に影響します。これは、ビットが（1）に設定されることにより選択されたオプションが表示されているビットフィールドであり、かつリセットされることにより選択されていないオプションと予約フィールド（0）。ビットの符号化は、セクション5.2で指定されています。次のようなオプションの意味は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Bit(s) Name Description",
      "ja": "ビット名前説明"
    },
    {
      "indent": 3,
      "text": "0 reserved Reserved for future expansion of this field.",
      "ja": "0は、この分野の将来の拡張のために予約を禁じます。"
    },
    {
      "indent": 3,
      "text": "1 use-session-key The USE-SESSION-KEY option indicates that the ticket the client is presenting to a server is encrypted in the session key from the server's TGT. When this option is not specified, the ticket is encrypted in the server's secret key.",
      "ja": "1使用-セッション・キーUSE-SESSION-KEYオプションは、クライアントがサーバに提示されたチケットは、サーバーのTGTからセッション鍵で暗号化されていることを示します。このオプションが指定されていない場合、チケットはサーバの秘密鍵で暗号化されています。"
    },
    {
      "indent": 3,
      "text": "2 mutual-required The MUTUAL-REQUIRED option tells the server that the client requires mutual authentication, and that it must respond with a KRB_AP_REP message.",
      "ja": "2相互必要MUTUAL-REQUIREDオプションは、クライアントが相互認証を必要とし、それがKRB_AP_REPメッセージで応答しなければならないことをサーバーに指示します。"
    },
    {
      "indent": 3,
      "text": "3-31 reserved Reserved for future use.",
      "ja": "3-31は、将来の使用のために予約を禁じます。"
    },
    {
      "indent": 3,
      "text": "ticket This field is a ticket authenticating the client to the server.",
      "ja": "チケットこのフィールドは、クライアントをサーバに認証チケットです。"
    },
    {
      "indent": 3,
      "text": "authenticator This contains the encrypted authenticator, which includes the client's choice of a subkey.",
      "ja": "オーセンティケータこれは、サブキーのクライアントの選択を含んで暗号化されたオーセンティケータが含まれています。"
    },
    {
      "indent": 3,
      "text": "The encrypted authenticator is included in the AP-REQ; it certifies to a server that the sender has recent knowledge of the encryption key in the accompanying ticket, to help the server detect replays. It also assists in the selection of a \"true session key\" to use with the particular session. The DER encoding of the following is encrypted in the ticket's session key, with a key usage value of 11 in normal application exchanges, or 7 when used as the PA-TGS-REQ PA-DATA field of a TGS-REQ exchange (see Section 5.4.1):",
      "ja": "暗号化されたオーセンティケータは、AP-REQに含まれています。それはリプレイを検出し、サーバーを支援するために、送信者が伴うチケットでの暗号化キーの最新の知識を持っているサーバに認証しています。また、特定のセッションで使用する「真のセッションキー」の選択を支援します。以下のDER符号化は、通常のアプリケーション交換における11の主要な用法値と、チケットのセッション鍵で暗号化、または7 TGS-REQ交換のPA-TGS-REQ PA-DATAフィールドとして使用される（セクションを参照され5.4.1）："
    },
    {
      "indent": 3,
      "text": "-- Unencrypted authenticator\nAuthenticator   ::= [APPLICATION 2] SEQUENCE  {\n        authenticator-vno       [0] INTEGER (5),\n        crealm                  [1] Realm,\n        cname                   [2] PrincipalName,\n        cksum                   [3] Checksum OPTIONAL,\n        cusec                   [4] Microseconds,\n        ctime                   [5] KerberosTime,\n        subkey                  [6] EncryptionKey OPTIONAL,\n        seq-number              [7] UInt32 OPTIONAL,\n        authorization-data      [8] AuthorizationData OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "authenticator-vno This field specifies the version number for the format of the authenticator. This document specifies version 5.",
      "ja": "オーセンティケータ-VNOこのフィールドは、オーセンティケータのフォーマットのバージョン番号を指定します。このドキュメントでは、バージョン5を指定します。"
    },
    {
      "indent": 3,
      "text": "crealm and cname These fields are the same as those described for the ticket in section 5.3.",
      "ja": "crealmとCNAMEこれらのフィールドは、セクション5.3でチケットのために説明したものと同様です。"
    },
    {
      "indent": 3,
      "text": "cksum This field contains a checksum of the application data that accompanies the KRB_AP_REQ, computed using a key usage value of 10 in normal application exchanges, or 6 when used in the TGS-REQ PA-TGS-REQ AP-DATA field.",
      "ja": "cksumのこのフィールドは、TGS-REQ PA-TGS-REQ AP-DATAフィールドで使用される場合、通常のアプリケーション交換、または6で10の主要な用法値を用いて計算KRB_AP_REQを伴うアプリケーションデータのチェックサムを含んでいます。"
    },
    {
      "indent": 3,
      "text": "cusec This field contains the microsecond part of the client's timestamp. Its value (before encryption) ranges from 0 to 999999. It often appears along with ctime. The two fields are used together to specify a reasonably accurate timestamp.",
      "ja": "このフィールドは、クライアントのタイムスタンプのマイクロ秒部分が含まれていcusec。 （暗号化前）その値は、それは多くの場合、ctimeのと一緒に表示されます0から999999の範囲です。 2つのフィールドは、合理的に正確なタイムスタンプを指定するために一緒に使用されています。"
    },
    {
      "indent": 3,
      "text": "ctime This field contains the current time on the client's host.",
      "ja": "このフィールドは、クライアントのホストの現在の時刻が含まれていCTIME。"
    },
    {
      "indent": 3,
      "text": "subkey This field contains the client's choice for an encryption key to be used to protect this specific application session. Unless an application specifies otherwise, if this field is left out, the session key from the ticket will be used.",
      "ja": "サブキーこのフィールドは、この特定のアプリケーションのセッションを保護するために使用される暗号化キーのためのクライアントの選択肢が含まれています。アプリケーションが別途定める場合を除き、このフィールドが省略された場合、チケットからセッションキーが使用されます。"
    },
    {
      "indent": 3,
      "text": "seq-number This optional field includes the initial sequence number to be used by the KRB_PRIV or KRB_SAFE messages when sequence numbers are used to detect replays. (It may also be used by application specific messages.) When included in the authenticator, this field specifies the initial sequence number for messages from the client to the server. When included in the AP-REP message, the initial sequence number is that for messages from the server to the client. When used in KRB_PRIV or KRB_SAFE messages, it is incremented by one after each message is sent. Sequence numbers fall in the range 0 through 2^32 - 1 and wrap to zero following the value 2^32 - 1.",
      "ja": "配列番号このオプションフィールドは、シーケンス番号がリプレイを検出するために使用されるKRB_PRIVまたはKRB_SAFEメッセージによって使用される初期シーケンス番号を含みます。 （また、アプリケーション固有のメッセージで使用することができる。）オーセンティケータに含まれる場合、このフィールドは、クライアントからサーバーへのメッセージの初期シーケンス番号を指定します。 AP-REPメッセージに含まれる場合には、初期シーケンス番号は、サーバーからクライアントへのメッセージのことです。 KRB_PRIVまたはKRB_SAFEメッセージで使用される場合、各メッセージが送信された後、それを1つインクリメントします。シーケンス番号は、2 ^ 32を介して範囲0に落ちる -  1と値2 ^ 32以下にゼロにラップ -  1。"
    },
    {
      "indent": 6,
      "text": "For sequence numbers to support the detection of replays adequately, they SHOULD be non-repeating, even across connection boundaries. The initial sequence number SHOULD be random and uniformly distributed across the full space of possible sequence numbers, so that it cannot be guessed by an attacker and so that it and the successive sequence numbers do not repeat other sequences. In the event that more than 2^32 messages are to be generated in a series of KRB_PRIV or KRB_SAFE messages, rekeying SHOULD be performed before sequence numbers are reused with the same encryption key.",
      "ja": "シーケンス番号が適切にリプレイの検出をサポートするために、彼らも、接続の境界を越えて、非反復であるべきです。初期シーケンス番号はランダムかつ均一にそれが攻撃者によって推測することができないようにし、それと連続したシーケンス番号が他の配列を繰り返さないように、可能なシーケンス番号の完全なスペースを分散する必要があります。シーケンス番号は、同一の暗号鍵を用いて再使用される前に、以上2 ^ 32メッセージがKRB_PRIVまたはKRB_SAFEメッセージの直列で生成されるた場合に、リキーを行うべきです。"
    },
    {
      "indent": 6,
      "text": "Implmentation note: Historically, some implementations transmit signed twos-complement numbers for sequence numbers. In the interests of compatibility, implementations MAY accept the equivalent negative number where a positive number greater than 2^31 - 1 is expected.",
      "ja": "Implmentationノート：歴史的に、いくつかの実装は、シーケンス番号のために署名2の補数を送信します。 1予想される - 互換性の利益のために、実装は、2 ^ 31より大きい正の数が等価負の数を受け入れることができます。"
    },
    {
      "indent": 6,
      "text": "Implementation note: As noted before, some implementations omit the optional sequence number when its value would be zero. Implementations MAY accept an omitted sequence number when expecting a value of zero, and SHOULD NOT transmit an Authenticator with a initial sequence number of zero.",
      "ja": "実装上の注意：前に述べたように、その値がゼロになるとき、いくつかの実装は、オプションのシーケンス番号を省略します。実装はゼロの値を期待する場合は省略シーケンス番号を受け入れることができ、ゼロの初期シーケンス番号で認証を送信すべきではありません。"
    },
    {
      "indent": 3,
      "text": "authorization-data This field is the same as described for the ticket in Section 5.3. It is optional and will only appear when additional restrictions are to be placed on the use of a ticket, beyond those carried in the ticket itself.",
      "ja": "認証データこのフィールドは、セクション5.3でのチケットのために説明したのと同じです。これはオプションで、追加の制限がチケット自体に運ばそれらを超えて、チケットの使用に配置する場合にのみ表示されます。"
    },
    {
      "indent": 0,
      "text": "5.5.2. KRB_AP_REP Definition",
      "section_title": true,
      "ja": "5.5.2.  KRB_AP_REP定義"
    },
    {
      "indent": 3,
      "text": "The KRB_AP_REP message contains the Kerberos protocol version number, the message type, and an encrypted time-stamp. The message is sent in response to an application request (KRB_AP_REQ) for which the mutual authentication option has been selected in the ap-options field.",
      "ja": "KRB_AP_REPメッセージはケルベロスプロトコルバージョン番号、メッセージタイプ、および暗号化されたタイムスタンプを含んでいます。メッセージは、相互認証オプションは、AP-オプションフィールドで選択されたアプリケーション要求（KRB_AP_REQ）に応答して送信されます。"
    },
    {
      "indent": 3,
      "text": "AP-REP          ::= [APPLICATION 15] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (15),\n        enc-part        [2] EncryptedData -- EncAPRepPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EncAPRepPart    ::= [APPLICATION 27] SEQUENCE {\n        ctime           [0] KerberosTime,\n        cusec           [1] Microseconds,\n        subkey          [2] EncryptionKey OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The encoded EncAPRepPart is encrypted in the shared session key of the ticket. The optional subkey field can be used in an application-arranged negotiation to choose a per association session key.",
      "ja": "エンコードされたEncAPRepPartはチケットの共有セッション鍵で暗号化されます。オプションのサブキーフィールドは、関連ごとにセッション・キーを選択するために、アプリケーションに配置ネゴシエーションで使用することができます。"
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is KRB_AP_REP.",
      "ja": "PVNOとMSG型これらのフィールドは、5.4.1節で上記に記載されています。 MSG-typeはKRB_AP_REPです。"
    },
    {
      "indent": 3,
      "text": "enc-part This field is described above in Section 5.4.2. It is computed with a key usage value of 12.",
      "ja": "ENC-一部このフィールドは、セクション5.4.2で説明しています。それは、12の主要な用法値で計算されます。"
    },
    {
      "indent": 3,
      "text": "ctime This field contains the current time on the client's host.",
      "ja": "このフィールドは、クライアントのホストの現在の時刻が含まれていCTIME。"
    },
    {
      "indent": 3,
      "text": "cusec This field contains the microsecond part of the client's timestamp.",
      "ja": "このフィールドは、クライアントのタイムスタンプのマイクロ秒部分が含まれていcusec。"
    },
    {
      "indent": 3,
      "text": "subkey This field contains an encryption key that is to be used to protect this specific application session. See Section 3.2.6 for specifics on how this field is used to negotiate a key. Unless an application specifies otherwise, if this field is left out, the sub-session key from the authenticator or if the latter is also left out, the session key from the ticket will be used.",
      "ja": "サブキーこのフィールドは、この特定のアプリケーションのセッションを保護するために使用される暗号化キーが含まれています。このフィールドは、キーを交渉するために使用される方法についての詳細については、セクション3.2.6を参照してください。アプリケーションが別途定める場合を除き、このフィールドが省略された場合、オーセンティケータからか、後者の場合は、サブセッションキーも取り残され、チケットからセッションキーが使用されます。"
    },
    {
      "indent": 3,
      "text": "seq-number This field is described above in Section 5.3.2.",
      "ja": "配列番号このフィールドは、セクション5.3.2で説明しました。"
    },
    {
      "indent": 0,
      "text": "5.5.3. Error Message Reply",
      "section_title": true,
      "ja": "5.5.3. エラーメッセージに返信"
    },
    {
      "indent": 3,
      "text": "If an error occurs while processing the application request, the KRB_ERROR message will be sent in response. See Section 5.9.1 for the format of the error message. The cname and crealm fields MAY be left out if the server cannot determine their appropriate values from the corresponding KRB_AP_REQ message. If the authenticator was decipherable, the ctime and cusec fields will contain the values from it.",
      "ja": "アプリケーション要求を処理中にエラーが発生した場合、KRB_ERRORメッセージが応答で送信されます。エラーメッセージのフォーマットについては、セクション5.9.1を参照してください。サーバが対応するKRB_AP_REQメッセージからそれらの適切な値を決定できない場合CNAMEとcrealmフィールドは省略されるかもしれません。オーセンティケータが解読した場合は、CTIMEとcusecフィールドはそれから値が含まれます。"
    },
    {
      "indent": 0,
      "text": "5.6. KRB_SAFE Message Specification",
      "section_title": true,
      "ja": "5.6.  KRB_SAFEメッセージ仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format of a message that can be used by either side (client or server) of an application to send a tamper-proof message to its peer. It presumes that a session key has previously been exchanged (for example, by using the KRB_AP_REQ/KRB_AP_REP messages).",
      "ja": "このセクションでは、そのピアにタンパープルーフメッセージを送信するアプリケーションのいずれかの側（クライアントまたはサーバ）によって使用することができるメッセージの形式を指定します。これは、セッションキーは以前に（例えば、KRB_AP_REQ / KRB_AP_REPメッセージを使用して）交換されたことを前提としています。"
    },
    {
      "indent": 0,
      "text": "5.6.1. KRB_SAFE definition",
      "section_title": true,
      "ja": "5.6.1.  KRB_SAFE定義"
    },
    {
      "indent": 3,
      "text": "The KRB_SAFE message contains user data along with a collision-proof checksum keyed with the last encryption key negotiated via subkeys, or with the session key if no negotiation has occurred. The message fields are as follows:",
      "ja": "KRB_SAFEメッセージはサブキーを経由して、あるいは全く交渉が発生していない場合はセッションキーと交渉の最後の暗号化キーとキーの衝突防止のチェックサムと一緒にユーザーデータが含まれています。次のようにメッセージのフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "KRB-SAFE        ::= [APPLICATION 20] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (20),\n        safe-body       [2] KRB-SAFE-BODY,\n        cksum           [3] Checksum\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "KRB-SAFE-BODY   ::= SEQUENCE {\n        user-data       [0] OCTET STRING,\n        timestamp       [1] KerberosTime OPTIONAL,\n        usec            [2] Microseconds OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL,\n        s-address       [4] HostAddress,\n        r-address       [5] HostAddress OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is KRB_SAFE.",
      "ja": "PVNOとMSG型これらのフィールドは、5.4.1節で上記に記載されています。 MSG-typeはKRB_SAFEです。"
    },
    {
      "indent": 3,
      "text": "safe-body This field is a placeholder for the body of the KRB-SAFE message.",
      "ja": "安全ボディは、このフィールドは、KRB-SAFEメッセージの本文のプレースホルダです。"
    },
    {
      "indent": 3,
      "text": "cksum This field contains the checksum of the application data, computed with a key usage value of 15.",
      "ja": "cksumのこのフィールドは、15の主要な用法値で計算アプリケーションデータのチェックサムを含んでいます。"
    },
    {
      "indent": 6,
      "text": "The checksum is computed over the encoding of the KRB-SAFE sequence. First, the cksum is set to a type zero, zero-length value, and the checksum is computed over the encoding of the KRB-SAFE sequence. Then the checksum is set to the result of that computation. Finally, the KRB-SAFE sequence is encoded again. This method, although different than the one specified in RFC 1510, corresponds to existing practice.",
      "ja": "チェックサムはKRB-SAFEシーケンスのエンコーディングにわたって計算されます。まず、cksumのは、タイプゼロ、長さゼロの値に設定され、チェックサムはKRB-SAFEシーケンスのエンコーディングにわたって計算されます。そして、チェックサムは、その計算の結果に設定されています。最後に、KRB-SAFEシーケンスが再びエンコードされています。この方法は、RFC 1510で指定されたものとは異なるものの、既存の慣行に対応します。"
    },
    {
      "indent": 3,
      "text": "user-data This field is part of the KRB_SAFE and KRB_PRIV messages, and contains the application-specific data that is being passed from the sender to the recipient.",
      "ja": "ユーザデータこのフィールドは、KRB_SAFEとKRB_PRIVメッセージの一部であり、受信者に送信者から渡されているアプリケーション固有のデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "timestamp This field is part of the KRB_SAFE and KRB_PRIV messages. Its contents are the current time as known by the sender of the message. By checking the timestamp, the recipient of the message is able to make sure that it was recently generated, and is not a replay.",
      "ja": "タイムスタンプこのフィールドは、KRB_SAFEとKRB_PRIVメッセージの一部です。その内容は、メッセージの送信者によって知られているように、現在の時刻です。タイムスタンプをチェックすることで、メッセージの受信者は、それが最近に生成されたことを確認することができ、かつリプレイではありません。"
    },
    {
      "indent": 3,
      "text": "usec This field is part of the KRB_SAFE and KRB_PRIV headers. It contains the microsecond part of the timestamp.",
      "ja": "このフィールドUSEC KRB_SAFEとKRB_PRIVヘッダーの一部です。これは、タイムスタンプのマイクロ秒の部分が含まれています。"
    },
    {
      "indent": 3,
      "text": "seq-number This field is described above in Section 5.3.2.",
      "ja": "配列番号このフィールドは、セクション5.3.2で説明しました。"
    },
    {
      "indent": 3,
      "text": "s-address Sender's address.",
      "ja": "S-アドレス送信者のアドレス。"
    },
    {
      "indent": 6,
      "text": "This field specifies the address in use by the sender of the message.",
      "ja": "このフィールドは、メッセージの送信者が使用しているアドレスを指定します。"
    },
    {
      "indent": 3,
      "text": "r-address This field specifies the address in use by the recipient of the message. It MAY be omitted for some uses (such as broadcast protocols), but the recipient MAY arbitrarily reject such messages. This field, along with s-address, can be used to help detect messages that have been incorrectly or maliciously delivered to the wrong recipient.",
      "ja": "R-アドレスは、このフィールドには、メッセージの受信者が使用しているアドレスを指定します。それは、（ブロードキャストプロトコルなど）いくつかの用途のために省略されるかもしれませんが、受信者が任意に、このようなメッセージを拒否するかもしれません。このフィールドは、S-アドレスと共に、間違ってまたは故意間違った受信者に配信されたメッセージを検出するために使用することができ。"
    },
    {
      "indent": 0,
      "text": "5.7. KRB_PRIV Message Specification",
      "section_title": true,
      "ja": "5.7.  KRB_PRIVメッセージ仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format of a message that can be used by either side (client or server) of an application to send a message to its peer securely and privately. It presumes that a session key has previously been exchanged (for example, by using the KRB_AP_REQ/KRB_AP_REP messages).",
      "ja": "このセクションでは、安全かつ個人ピアにメッセージを送信するアプリケーションのいずれかの側（クライアントまたはサーバ）によって使用することができるメッセージの形式を指定します。これは、セッションキーは以前に（例えば、KRB_AP_REQ / KRB_AP_REPメッセージを使用して）交換されたことを前提としています。"
    },
    {
      "indent": 0,
      "text": "5.7.1. KRB_PRIV Definition",
      "section_title": true,
      "ja": "5.7.1.  KRB_PRIVの定義"
    },
    {
      "indent": 3,
      "text": "The KRB_PRIV message contains user data encrypted in the Session Key. The message fields are as follows:",
      "ja": "KRB_PRIVメッセージは、セッション鍵で暗号化されたユーザデータが含まれています。次のようにメッセージのフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "KRB-PRIV        ::= [APPLICATION 21] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (21),\n                        -- NOTE: there is no [2] tag\n        enc-part        [3] EncryptedData -- EncKrbPrivPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EncKrbPrivPart  ::= [APPLICATION 28] SEQUENCE {\n        user-data       [0] OCTET STRING,\n        timestamp       [1] KerberosTime OPTIONAL,\n        usec            [2] Microseconds OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL,\n        s-address       [4] HostAddress -- sender's addr --,\n        r-address       [5] HostAddress OPTIONAL -- recip's addr\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is KRB_PRIV.",
      "ja": "PVNOとMSG型これらのフィールドは、5.4.1節で上記に記載されています。 MSG-typeはKRB_PRIVです。"
    },
    {
      "indent": 3,
      "text": "enc-part This field holds an encoding of the EncKrbPrivPart sequence encrypted under the session key, with a key usage value of 13. This encrypted encoding is used for the enc-part field of the KRB-PRIV message.",
      "ja": "ENC-部はこのフィールドには、この暗号化された符号化はKRB-PRIVメッセージのENC-一部のフィールドのために使用される13の主要な用法値と、セッション鍵で暗号化EncKrbPrivPartシーケンスのエンコーディングを保持します。"
    },
    {
      "indent": 3,
      "text": "user-data, timestamp, usec, s-address, and r-address These fields are described above in Section 5.6.1.",
      "ja": "ユーザデータ、タイムスタンプ、マイクロ秒、S-アドレス、およびR-アドレスこれらのフィールドは、セクション5.6.1で説明しています。"
    },
    {
      "indent": 3,
      "text": "seq-number This field is described above in Section 5.3.2.",
      "ja": "配列番号このフィールドは、セクション5.3.2で説明しました。"
    },
    {
      "indent": 0,
      "text": "5.8. KRB_CRED Message Specification",
      "section_title": true,
      "ja": "5.8.  KRB_CREDメッセージ仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format of a message that can be used to send Kerberos credentials from one principal to another. It is presented here to encourage a common mechanism to be used by applications when forwarding tickets or providing proxies to subordinate servers. It presumes that a session key has already been exchanged, perhaps by using the KRB_AP_REQ/KRB_AP_REP messages.",
      "ja": "このセクションでは、別の主からKerberos資格情報を送信するために使用することができるメッセージの形式を指定します。チケットを転送するか、下位のサーバにプロキシを提供するアプリケーションが使用する共通のメカニズムを奨励するために、ここで提示されます。これは、セッションキーはすでに、おそらくKRB_AP_REQ / KRB_AP_REPメッセージを使用することにより、交換されたことを前提としています。"
    },
    {
      "indent": 0,
      "text": "5.8.1. KRB_CRED Definition",
      "section_title": true,
      "ja": "5.8.1. 定義KRB_CRED"
    },
    {
      "indent": 3,
      "text": "The KRB_CRED message contains a sequence of tickets to be sent and information needed to use the tickets, including the session key from each. The information needed to use the tickets is encrypted under an encryption key previously exchanged or transferred alongside the KRB_CRED message. The message fields are as follows:",
      "ja": "KRB_CREDメッセージが送信された情報は、それぞれのセッションキーなどのチケットを、使用するのに必要されるチケットのシーケンスが含まれています。チケットを使用するために必要な情報は、以前KRB_CREDメッセージと一緒に交換または転送の暗号鍵で暗号化されています。次のようにメッセージのフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "KRB-CRED        ::= [APPLICATION 22] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (22),\n        tickets         [2] SEQUENCE OF Ticket,\n        enc-part        [3] EncryptedData -- EncKrbCredPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EncKrbCredPart  ::= [APPLICATION 29] SEQUENCE {\n        ticket-info     [0] SEQUENCE OF KrbCredInfo,\n        nonce           [1] UInt32 OPTIONAL,\n        timestamp       [2] KerberosTime OPTIONAL,\n        usec            [3] Microseconds OPTIONAL,\n        s-address       [4] HostAddress OPTIONAL,\n        r-address       [5] HostAddress OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "KrbCredInfo     ::= SEQUENCE {\n        key             [0] EncryptionKey,\n        prealm          [1] Realm OPTIONAL,\n        pname           [2] PrincipalName OPTIONAL,\n        flags           [3] TicketFlags OPTIONAL,\n        authtime        [4] KerberosTime OPTIONAL,\n        starttime       [5] KerberosTime OPTIONAL,\n        endtime         [6] KerberosTime OPTIONAL,\n        renew-till      [7] KerberosTime OPTIONAL,\n        srealm          [8] Realm OPTIONAL,\n        sname           [9] PrincipalName OPTIONAL,\n        caddr           [10] HostAddresses OPTIONAL\n} pvno and msg-type\n   These fields are described above in Section 5.4.1.  msg-type is\n   KRB_CRED.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tickets These are the tickets obtained from the KDC specifically for use by the intended recipient. Successive tickets are paired with the corresponding KrbCredInfo sequence from the enc-part of the KRB-CRED message.",
      "ja": "チケットはこれらの特別目的の受信者が使用するためにKDCから取得したチケットです。連続したチケットはKRB-CREDメッセージのENC-部から対応KrbCredInfo配列と対になっています。"
    },
    {
      "indent": 3,
      "text": "enc-part This field holds an encoding of the EncKrbCredPart sequence encrypted under the session key shared by the sender and the intended recipient, with a key usage value of 14. This encrypted encoding is used for the enc-part field of the KRB-CRED message.",
      "ja": "ENC-部はこのフィールドには、この暗号化された符号化はKRB-CREDのENC-一部のフィールドのために使用される14の主要な用法値と、送信者と意図した受信者で共有セッション鍵で暗号化EncKrbCredPartシーケンスのエンコーディングを保持しますメッセージ。"
    },
    {
      "indent": 6,
      "text": "Implementation note: Implementations of certain applications, most notably certain implementations of the Kerberos GSS-API mechanism, do not separately encrypt the contents of the EncKrbCredPart of the KRB-CRED message when sending it. In the case of those GSS-API mechanisms, this is not a security vulnerability, as the entire KRB-CRED message is itself embedded in an encrypted message.",
      "ja": "実装上の注意：それを送信するときに、特定のアプリケーションの実装は、KerberosのGSS-API機構の最も注目すべきは、特定のインプリメンテーションは、別途KRB-CREDメッセージのEncKrbCredPartの内容を暗号化しません。全体KRB-CREDメッセージ自体が暗号化されたメッセージに埋め込まれているように、それらのGSS-API機構の場合、これは、セキュリティ上の脆弱性ではありません。"
    },
    {
      "indent": 3,
      "text": "nonce If practical, an application MAY require the inclusion of a nonce generated by the recipient of the message. If the same value is included as the nonce in the message, it provides evidence that the message is fresh and has not been replayed by an attacker. A nonce MUST NEVER be reused.",
      "ja": "ナンスの実用的な場合、アプリケーションは、メッセージの受信者によって生成されたノンスを含めることを必要とする場合があります。同じ値がメッセージ内のnonceとして含まれている場合は、メッセージが新鮮で、攻撃者によって再演されていないという証拠を提供します。ナンスは再利用してはなりません。"
    },
    {
      "indent": 3,
      "text": "timestamp and usec These fields specify the time that the KRB-CRED message was generated. The time is used to provide assurance that the message is fresh.",
      "ja": "これらのフィールドをタイムスタンプとUSEC KRB-CREDメッセージが生成された時刻を指定します。時間は、メッセージが新鮮であるという保証を提供するために使用されます。"
    },
    {
      "indent": 3,
      "text": "s-address and r-address These fields are described above in Section 5.6.1. They are used optionally to provide additional assurance of the integrity of the KRB-CRED message.",
      "ja": "S-アドレスとRアドレスこれらのフィールドは、セクション5.6.1で上述されています。これらは、KRB-CREDメッセージの完全性の追加の保証を提供するために任意に使用されます。"
    },
    {
      "indent": 3,
      "text": "key This field exists in the corresponding ticket passed by the KRB-CRED message and is used to pass the session key from the sender to the intended recipient. The field's encoding is described in Section 5.2.9.",
      "ja": "キーこのフィールドは、KRB-CREDメッセージによって渡され、対応するチケットに存在し、目的の受信者に送信者からのセッションキーを渡すために使用されます。フィールドのエンコーディングは、5.2.9項で説明されています。"
    },
    {
      "indent": 3,
      "text": "The following fields are optional. If present, they can be associated with the credentials in the remote ticket file. If left out, then it is assumed that the recipient of the credentials already knows their values.",
      "ja": "次のフィールドはオプションです。存在する場合、それらは、リモートチケットファイル内の資格情報と関連付けることができます。取り残さ場合は、資格証明書の受領者が既にそれらの値を知っていることを想定しています。"
    },
    {
      "indent": 3,
      "text": "prealm and pname The name and realm of the delegated principal identity.",
      "ja": "委任主要なアイデンティティの名前とレルムをprealmとPNAME。"
    },
    {
      "indent": 3,
      "text": "flags, authtime, starttime, endtime, renew-till, srealm, sname, and caddr These fields contain the values of the corresponding fields from the ticket found in the ticket field. Descriptions of the fields are identical to the descriptions in the KDC-REP message.",
      "ja": "旗、authtime、STARTTIME、終了時刻、更新-まで、srealm、SNAME、およびこれらのフィールドは、チケットフィールドで見つかったチケットから、対応するフィールドの値が含まれていCADDR。フィールドの説明はKDC-REPメッセージの説明と同じです。"
    },
    {
      "indent": 0,
      "text": "5.9. Error Message Specification",
      "section_title": true,
      "ja": "5.9. エラーメッセージ仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format for the KRB_ERROR message. The fields included in the message are intended to return as much information as possible about an error. It is not expected that all the information required by the fields will be available for all types of errors. If the appropriate information is not available when the message is composed, the corresponding field will be left out of the message.",
      "ja": "このセクションでは、KRB_ERRORメッセージの形式を指定します。メッセージに含まれるフィールドは、エラーについてできるだけ多くの情報を返すように意図されています。フィールドで必要とされるすべての情報は、すべての種類のエラーのために利用可能になることが期待されていません。メッセージが構成されている場合、適切な情報が利用できない場合、対応するフィールドは、メッセージから除外されるであろう。"
    },
    {
      "indent": 3,
      "text": "Note that because the KRB_ERROR message is not integrity protected, it is quite possible for an intruder to synthesize or modify it. In particular, this means that the client SHOULD NOT use any fields in this message for security-critical purposes, such as setting a system clock or generating a fresh authenticator. The message can be useful, however, for advising a user on the reason for some failure.",
      "ja": "KRB_ERRORメッセージが完全性保護されていないため、侵入者が合成したり、それを修正するために、それは非常に可能であることに注意してください。特に、これは、クライアントが、そのようなシステムクロックを設定したり、新鮮なオーセンティケータの生成などのセキュリティ上重要な目的のために、このメッセージ内の任意のフィールドを使用してはならないことを意味します。メッセージには、いくつかの失敗の理由で、ユーザーに助言するために、しかし、便利です。"
    },
    {
      "indent": 0,
      "text": "5.9.1. KRB_ERROR Definition",
      "section_title": true,
      "ja": "5.9.1.  KRB_ERRORの定義"
    },
    {
      "indent": 3,
      "text": "The KRB_ERROR message consists of the following fields:",
      "ja": "KRB_ERRORメッセージは、次のフィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "KRB-ERROR       ::= [APPLICATION 30] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (30),\n        ctime           [2] KerberosTime OPTIONAL,\n        cusec           [3] Microseconds OPTIONAL,\n        stime           [4] KerberosTime,\n        susec           [5] Microseconds,\n        error-code      [6] Int32,\n        crealm          [7] Realm OPTIONAL,\n        cname           [8] PrincipalName OPTIONAL,\n        realm           [9] Realm -- service realm --,\n        sname           [10] PrincipalName -- service name --,\n        e-text          [11] KerberosString OPTIONAL, e-data          [12] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is KRB_ERROR.",
      "ja": "PVNOとMSG型これらのフィールドは、5.4.1節で上記に記載されています。 MSG-タイプがKRB_ERRORです。"
    },
    {
      "indent": 3,
      "text": "ctime and cusec These fields are described above in Section 5.5.2. If the values for these fields are known to the entity generating the error (as they would be if the KRB-ERROR is generated in reply to, e.g., a failed authentication service request), they should be populated in the KRB-ERROR. If the values are not available, these fields can be omitted.",
      "ja": "CTIMEとは、これらのフィールドは、セクション5.5.2で上記に記載されているcusec。これらのフィールドの値はエラーを生成するエンティティに知られている場合（それらがKRB-ERRORは、例えば、失敗した認証サービス要求に応答して生成されることになるかのように）、それらはKRB-ERRORに移入されるべきです。値が入手できない場合、これらのフィールドを省略することができます。"
    },
    {
      "indent": 3,
      "text": "stime This field contains the current time on the server. It is of type KerberosTime.",
      "ja": "STIMEこのフィールドは、サーバー上の現在の時刻が含まれています。これは、タイプKerberosTimeです。"
    },
    {
      "indent": 3,
      "text": "susec This field contains the microsecond part of the server's timestamp. Its value ranges from 0 to 999999. It appears along with stime. The two fields are used in conjunction to specify a reasonably accurate timestamp.",
      "ja": "susecこのフィールドは、サーバーのタイムスタンプのマイクロ秒の部分が含まれています。その値は、それがSTIMEと一緒に表示されます0から999999の範囲です。 2つのフィールドは、合理的に正確なタイムスタンプを指定するために一緒に使用されています。"
    },
    {
      "indent": 3,
      "text": "error-code This field contains the error code returned by Kerberos or the server when a request fails. To interpret the value of this field see the list of error codes in Section 7.5.9. Implementations are encouraged to provide for national language support in the display of error messages.",
      "ja": "エラー・コードは、このフィールドには、要求が失敗した場合Kerberosまたはサーバから返されたエラーコードが含まれています。このフィールドの値を解釈するには、セクション7.5.9でエラーコードのリストを参照してください。実装は、エラーメッセージの表示中国語サポートを提供することが奨励されています。"
    },
    {
      "indent": 3,
      "text": "crealm, and cname These fields are described above in Section 5.3. When the entity generating the error knows these values, they should be populated in the KRB-ERROR. If the values are not known, the crealm and cname fields SHOULD be omitted.",
      "ja": "crealm、およびCNAMEこれらのフィールドは、セクション5.3に説明しています。エラーを生成するエンティティは、これらの値を知っているとき、彼らはKRB-ERRORに移入されなければなりません。値が知られていない場合は、crealmとCNAMEのフィールドは省略します。"
    },
    {
      "indent": 3,
      "text": "realm and sname These fields are described above in Section 5.3.",
      "ja": "これらのフィールドは、セクション5.3で上記に記載されている領域とSNAME。"
    },
    {
      "indent": 3,
      "text": "e-text This field contains additional text to help explain the error code associated with the failed request (for example, it might include a principal name which was unknown).",
      "ja": "このフィールドは、失敗した要求に関連付けられたエラーコードを説明するために追加のテキストを含む電子テキストは、（例えば、それは不明であったプリンシパル名が含まれる場合があります）。"
    },
    {
      "indent": 3,
      "text": "e-data This field contains additional data about the error for use by the application to help it recover from or handle the error. If the errorcode is KDC_ERR_PREAUTH_REQUIRED, then the e-data field will contain an encoding of a sequence of padata fields, each corresponding to an acceptable pre-authentication method and optionally containing data for the method:",
      "ja": "電子データは、このフィールドはそれから回復したり、エラーを処理するのに役立つアプリケーションが使用するエラーに関する追加データが含まれています。 ErrorCodeがKDC_ERR_PREAUTH_REQUIREDある場合、電子データ・フィールドは、それぞれ許容される事前認証方式に対応し、必要に応じてメソッドのデータを含む、PADATAフィールドのシーケンスの符号化を含むであろう。"
    },
    {
      "indent": 6,
      "text": "METHOD-DATA     ::= SEQUENCE OF PA-DATA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For error codes defined in this document other than KDC_ERR_PREAUTH_REQUIRED, the format and contents of the e-data field are implementation-defined. Similarly, for future error codes, the format and contents of the e-data field are implementation-defined unless specified otherwise. Whether defined by the implementation or in a future document, the e-data field MAY take the form of TYPED-DATA:",
      "ja": "KDC_ERR_PREAUTH_REQUIRED以外本書で定義されたエラーコードについて、電子データフィールドのフォーマットと内容は実装定義です。特に断らない限り同様に、将来のエラーコードについて、電子データフィールドのフォーマットと内容は実装定義です。実装によって、または将来の文書で定義されているかどうか、電子データフィールドは型付け-DATAの形をとることができます。"
    },
    {
      "indent": 3,
      "text": "TYPED-DATA      ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {\n        data-type       [0] Int32,\n        data-value      [1] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.10. Application Tag Numbers",
      "section_title": true,
      "ja": "5.10. アプリケーションタグ番号"
    },
    {
      "indent": 3,
      "text": "The following table lists the application class tag numbers used by various data types defined in this section.",
      "ja": "次の表は、このセクションで定義された様々なデータタイプによって使用されるアプリケーションクラスのタグ番号を示します。"
    },
    {
      "indent": 3,
      "text": "Tag Number(s) Type Name Comments",
      "ja": "タグ番号（S）タイプ名コメント"
    },
    {
      "indent": 3,
      "text": "0 unused",
      "ja": "未使用0"
    },
    {
      "indent": 3,
      "text": "1 Ticket PDU",
      "ja": "1枚のチケットPDU"
    },
    {
      "indent": 3,
      "text": "2 Authenticator non-PDU",
      "ja": "2認証非PDU"
    },
    {
      "indent": 3,
      "text": "3 EncTicketPart non-PDU",
      "ja": "3 EncTicketPart非PDU"
    },
    {
      "indent": 3,
      "text": "4-9 unused",
      "ja": "未使用4-9"
    },
    {
      "indent": 3,
      "text": "10 AS-REQ PDU",
      "ja": "10 AS-REQ PDU"
    },
    {
      "indent": 3,
      "text": "11 AS-REP PDU",
      "ja": "AS-REP PDU 11"
    },
    {
      "indent": 3,
      "text": "12 TGS-REQ PDU",
      "ja": "12 TGS-REQのPDU"
    },
    {
      "indent": 3,
      "text": "13 TGS-REP PDU",
      "ja": "13 TGS-REPのPDU"
    },
    {
      "indent": 3,
      "text": "14 AP-REQ PDU",
      "ja": "14 AP-REQのPDU"
    },
    {
      "indent": 3,
      "text": "15 AP-REP PDU",
      "ja": "コストのかかる15あなたレイプ"
    },
    {
      "indent": 3,
      "text": "16 RESERVED16 TGT-REQ (for user-to-user)",
      "ja": "16 RESERVED16 TGT​​-REQ（ユーザ対ユーザのために）"
    },
    {
      "indent": 3,
      "text": "17 RESERVED17 TGT-REP (for user-to-user)",
      "ja": "（ユーザ対ユーザのための）17 RESERVED17 TGT-REP"
    },
    {
      "indent": 3,
      "text": "18-19 unused",
      "ja": "未使用18-19"
    },
    {
      "indent": 3,
      "text": "20 KRB-SAFE PDU",
      "ja": "20 KRB-SAFE PDU"
    },
    {
      "indent": 3,
      "text": "21 KRB-PRIV PDU",
      "ja": "21 KRB-PRIVのPDU"
    },
    {
      "indent": 3,
      "text": "22 KRB-CRED PDU",
      "ja": "KRB-CRED PDU 22"
    },
    {
      "indent": 3,
      "text": "23-24 unused",
      "ja": "未使用23-24"
    },
    {
      "indent": 3,
      "text": "25 EncASRepPart non-PDU",
      "ja": "25 EncASRepPart非PDU"
    },
    {
      "indent": 3,
      "text": "26 EncTGSRepPart non-PDU",
      "ja": "26 EncTGSRepPart非PDU"
    },
    {
      "indent": 3,
      "text": "27 EncApRepPart non-PDU",
      "ja": "27 EncApRepPart非PDU"
    },
    {
      "indent": 3,
      "text": "28 EncKrbPrivPart non-PDU",
      "ja": "28 EncKrbPrivPart非PDU"
    },
    {
      "indent": 3,
      "text": "29 EncKrbCredPart non-PDU",
      "ja": "29 EncKrbCredPart非PDU"
    },
    {
      "indent": 3,
      "text": "30 KRB-ERROR PDU",
      "ja": "30 KRB-ERRORのPDU"
    },
    {
      "indent": 3,
      "text": "The ASN.1 types marked above as \"PDU\" (Protocol Data Unit) are the only ASN.1 types intended as top-level types of the Kerberos protocol, and are the only types that may be used as elements in another protocol that makes use of Kerberos.",
      "ja": "「PDU」（プロトコルデータユニット）として上記マークASN.1タイプは、Kerberosプロトコルの最上位のタイプとして意図のみASN.1タイプであり、そしてなる他のプロトコルの要素として使用することができる唯一のタイプでありますケルベロスを使用します。"
    },
    {
      "indent": 0,
      "text": "6. Naming Constraints",
      "section_title": true,
      "ja": "6.ネーミングの制約"
    },
    {
      "indent": 0,
      "text": "6.1. Realm Names",
      "section_title": true,
      "ja": "6.1. レルム名"
    },
    {
      "indent": 3,
      "text": "Although realm names are encoded as GeneralStrings and technically a realm can select any name it chooses, interoperability across realm boundaries requires agreement on how realm names are to be assigned, and what information they imply.",
      "ja": "レルム名はGeneralStringsとしてエンコードされており、技術的にレルムは、それが選択した任意の名前を選択することができますが、領域の境界を越えて相互運用性は、レルム名が割り当てられる方法についての合意を必要とし、どのような情報彼らは示唆しています。"
    },
    {
      "indent": 3,
      "text": "To enforce these conventions, each realm MUST conform to the conventions itself, and it MUST require that any realms with which inter-realm keys are shared also conform to the conventions and require the same from its neighbors.",
      "ja": "これらの規則を適用するために、各領域は、規則自体に従わなければなりません、そして、それはレルム間キーは、共有される任意のレルムは、規則に適合し、その隣接からそれを必要とすることを要求しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Kerberos realm names are case sensitive. Realm names that differ only in the case of the characters are not equivalent. There are presently three styles of realm names: domain, X500, and other. Examples of each style follow:",
      "ja": "Kerberosレルム名は大文字と小文字が区別されます。文字の大文字小文字が違うだけレルム名は同じではありません。ドメイン、X500、およびその他：レルム名の3つのスタイルが現在あります。各スタイルのフォローの例："
    },
    {
      "indent": 8,
      "text": "domain:   ATHENA.MIT.EDU\n  X500:   C=US/O=OSF\n other:   NAMETYPE:rest/of.name=without-restrictions",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Domain style realm names MUST look like domain names: they consist of components separated by periods (.) and they contain neither colons (:) nor slashes (/). Though domain names themselves are case insensitive, in order for realms to match, the case must match as well. When establishing a new realm name based on an internet domain name it is recommended by convention that the characters be converted to uppercase.",
      "ja": "ドメインスタイルレルム名はドメイン名のようになります。（。）彼らは、ピリオドで区切られたコンポーネントで構成され、彼らはどちらもコロン（:)やスラッシュ（/）が含まれています。ドメイン名自体は大文字と小文字が区別されないものの、王国が一致するために、ケースにも一致している必要があります。インターネットドメイン名に基づいて新しいレルム名を確立するときには、文字が大文字に変換される大会で推奨されています。"
    },
    {
      "indent": 3,
      "text": "X.500 names contain an equals sign (=) and cannot contain a colon (:) before the equals sign. The realm names for X.500 names will be string representations of the names with components separated by slashes. Leading and trailing slashes will not be included. Note that the slash separator is consistent with Kerberos implementations based on RFC 1510, but it is different from the separator recommended in RFC 2253.",
      "ja": "X.500名は、等号（=）と（:)等号の前にコロンを含めることはできませんが含まれています。 X.500名のレルム名は、スラッシュで区切られたコンポーネントと名前の文字列表現であろう。先頭と最後のスラッシュは含まれません。スラッシュセパレータはRFC 1510に基づいて、Kerberosの実装と一致していることに注意してください、それはRFC 2253で推奨されるセパレータとは異なります。"
    },
    {
      "indent": 3,
      "text": "Names that fall into the other category MUST begin with a prefix that contains no equals sign (=) or period (.), and the prefix MUST be followed by a colon (:) and the rest of the name. All prefixes expect those beginning with used. Presently none are assigned.",
      "ja": "他のカテゴリに分類される名前は、記号（=）、またはピリオド（。）に等しい、とプレフィックスがコロン（:)と名前の残りの部分が続かなければならないノーが含まれている接頭辞で始まる必要があります。すべてのプレフィックスは、それらの使用で始まる期待しています。現在、何も割り当てられません。"
    },
    {
      "indent": 3,
      "text": "The reserved category includes strings that do not fall into the first three categories. All names in this category are reserved. It is unlikely that names will be assigned to this category unless there is a very strong argument for not using the 'other' category.",
      "ja": "予約カテゴリは最初の3つのカテゴリに分類されていない文字列が含まれています。このカテゴリ内のすべての名前は予約されています。 「その他」カテゴリを使用していないため、非常に強力な引数がない限り名前がこのカテゴリに割り当てされることはほとんどありません。"
    },
    {
      "indent": 3,
      "text": "These rules guarantee that there will be no conflicts between the various name styles. The following additional constraints apply to the assignment of realm names in the domain and X.500 categories: either the name of a realm for the domain or X.500 formats must be used by the organization owning (to whom it was assigned) an Internet domain name or X.500 name, or, in the case that no such names are registered, authority to use a realm name MAY be derived from the authority of the parent realm. For example, if there is no domain name for E40.MIT.EDU, then the administrator of the MIT.EDU realm can authorize the creation of a realm with that name.",
      "ja": "これらのルールは、さまざまな名前のスタイルの間には競合がないことを保証します。以下の追加の制約は、ドメインとX.500のカテゴリーでレルム名の割り当てに適用されます。ドメインまたはX.500形式のレルムの名前のいずれかが（それが割り当てられていた人に）組織所有するインターネットによって使用されなければなりませんドメイン名またはX.500名、またはには、そのような名前が登録されていないいる場合には、レルム名を使用する権限は、親レルムの権限から誘導することができます。 E40.MIT.EDUのためのドメイン名が存在しない場合たとえば、その後、MIT.EDUレルムの管理者がその名前を持つ領域の作成を許可することができます。"
    },
    {
      "indent": 3,
      "text": "This is acceptable because the organization to which the parent is assigned is presumably the organization authorized to assign names to its children in the X.500 and domain name systems as well. If the parent assigns a realm name without also registering it in the domain name or X.500 hierarchy, it is the parent's responsibility to make sure that in the future there will not exist a name identical to the realm name of the child unless it is assigned to the same entity as the realm name.",
      "ja": "親が割り当てられている組織は、おそらく同様X.500とドメインネームシステムでその子に名前を割り当てることを許可する組織ですので、これは許容可能です。親はまた、ドメイン名かX.500階層でそれを登録せずにレルム名を割り当てた場合、ある場合を除き、将来的に子供のレルム名と同じ名前が存在しないことを確認するために、親の責任ですレルム名と同じエンティティに割り当てられました。"
    },
    {
      "indent": 0,
      "text": "6.2. Principal Names",
      "section_title": true,
      "ja": "6.2. プリンシパル名"
    },
    {
      "indent": 3,
      "text": "As was the case for realm names, conventions are needed to ensure that all agree on what information is implied by a principal name. The name-type field that is part of the principal name indicates the kind of information implied by the name. The name-type SHOULD be treated only as a hint to interpreting the meaning of a name. It is not significant when checking for equivalence. Principal names that differ only in the name-type identify the same principal. The name type does not partition the name space. Ignoring the name type, no two names can be the same (i.e., at least one of the components, or the realm, MUST be different). The following name types are defined:",
      "ja": "レルム名の場合と同様に、規則はすべてのプリンシパル名によって示唆されているものを情報に同意することを保証するために必要になります。プリンシパル名の一部である名前型フィールドは、名前によって暗示される情報の種類を示します。名前型は、名前の意味を解釈するだけヒントとして扱われるべきです。等価をチェックするときにそれは重要ではありません。名前型のみが異なるプリンシパル名は同じ主体を特定します。名前タイプは、名前空間を分割しません。名前タイプ無視し、どの2人の名前が（すなわち、少なくとも成分の一つ、またはレルム、異なっていなければなりません）と同じになることはできません。次の名前のタイプが定義されています。"
    },
    {
      "indent": 3,
      "text": "Name Type Value Meaning",
      "ja": "種類値は、名前意味"
    },
    {
      "indent": 3,
      "text": "NT-UNKNOWN 0 Name type not known NT-PRINCIPAL 1 Just the name of the principal as in DCE, or for users NT-SRV-INST 2 Service and other unique instance (krbtgt) NT-SRV-HST 3 Service with host name as instance (telnet, rcommands) NT-SRV-XHST 4 Service with host as remaining components NT-UID 5 Unique ID NT-X500-PRINCIPAL 6 Encoded X.509 Distinguished name [RFC2253] NT-SMTP-NAME 7 Name in form of SMTP email name (e.g., user@example.com) NT-ENTERPRISE 10 Enterprise name - may be mapped to principal name",
      "ja": "ちょうどDCEのようなプリンシパルの名前、またはホスト名とユーザNT-SRV-INST 2サービスやそのほかの固有インスタンス（krbtgt）のためのNT-SRV-HST 3サービスとしてNT-PRINCIPAL 1知られていないNT-UNKNOWN 0名タイプインスタンス（TELNET、rcommands）SMTPの形で残りの成分NT-UID 5一意のID NT-X500-PRINCIPAL 6エンコードX.509識別名[RFC2253] NT-SMTP-NAME 7名とホストとNT-SRV-XHST 4サービス電子メールの名前（例えば、user@example.com）NT-ENTERPRISE 10企業名 - プリンシパル名にマッピングすることができます"
    },
    {
      "indent": 3,
      "text": "When a name implies no information other than its uniqueness at a particular time, the name type PRINCIPAL SHOULD be used. The principal name type SHOULD be used for users, and it might also be used for a unique server. If the name is a unique machine-generated ID that is guaranteed never to be reassigned, then the name type of UID SHOULD be used. (Note that it is generally a bad idea to reassign names of any type since stale entries might remain in access control lists.)",
      "ja": "名前は、特定の時間におけるその一意以外の情報を意味していない場合、名前タイププリンシパルが使用されるべきです。プリンシパル名のタイプは、ユーザーのために使用されるべきであり、それはまた、独自のサーバーに使用される可能性があります。名前は再割り当てないことを決して保証されているユニークな機械生成IDである場合は、UIDの名前タイプを使用する必要があります。 （古いエントリは、アクセス制御リストに残っている可能性があるため、任意の型の名前を再割り当てすることが一般的に悪い考えであることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "If the first component of a name identifies a service and the remaining components identify an instance of the service in a server-specified manner, then the name type of SRV-INST SHOULD be used. An example of this name type is the Kerberos ticket-granting service whose name has a first component of krbtgt and a second component identifying the realm for which the ticket is valid.",
      "ja": "名前の最初の成分はサービスを識別し、残りの構成要素は、サーバが指定した方法でサービスのインスタンスを識別する場合、SRV-INSTの名前のタイプを使用すべきです。この名前のタイプの例は、名前KRBTGTの第1成分とチケットが有効である領域を識別する第2の成分を有するケルベロスチケット許可サービスです。"
    },
    {
      "indent": 3,
      "text": "If the first component of a name identifies a service and there is a single component following the service name identifying the instance as the host on which the server is running, then the name type SRV-HST SHOULD be used. This type is typically used for Internet services such as telnet and the Berkeley R commands. If the separate components of the host name appear as successive components following the name of the service, then the name type SRV-XHST SHOULD be used. This type might be used to identify servers on hosts with X.500 names, where the slash (/) might otherwise be ambiguous.",
      "ja": "名前の最初の成分はサービスを識別し、サーバが稼働しているホストとしてインスタンスを識別するサービス名に続く単一の構成要素が存在する場合、名前タイプSRV-HSTを使用すべきです。このタイプは通常、telnetなどのインターネットサービスとバークレーRコマンドに使用されます。ホスト名の別個の構成要素は、サービスの名前、以下の連続成分として表示される場合、次いで、名前タイプSRV-XHSTを使用すべきです。このタイプは、スラッシュ（/）はそうでない場合は曖昧であるかもしれないX.500名を持つホスト上のサーバーを識別するために使用される可能性があります。"
    },
    {
      "indent": 3,
      "text": "A name type of NT-X500-PRINCIPAL SHOULD be used when a name from an X.509 certificate is translated into a Kerberos name. The encoding of the X.509 name as a Kerberos principal shall conform to the encoding rules specified in RFC 2253.",
      "ja": "X.509証明書から名前をKerberos名に翻訳されたときにNT-X500、プリンシパルの名前のタイプを使用すべきです。 KerberosプリンシパルとしてX.509名のエンコーディングは、RFC 2253で指定された符号化規則に適合しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A name type of SMTP allows a name to be of a form that resembles an SMTP email name. This name, including an \"@\" and a domain name, is used as the one component of the principal name.",
      "ja": "SMTPの名前タイプは、名前がSMTP電子メール名に似た形式にすることができます。 「@」とドメイン名を含むこの名前は、プリンシパル名の一の成分として使用されます。"
    },
    {
      "indent": 3,
      "text": "A name type of UNKNOWN SHOULD be used when the form of the name is not known. When comparing names, a name of type UNKNOWN will match principals authenticated with names of any type. A principal authenticated with a name of type UNKNOWN, however, will only match other names of type UNKNOWN.",
      "ja": "名前のフォームが知られていない場合UNKNOWNの名前のタイプを使用すべきです。名前を比較するとき、タイプUNKNOWNの名前は、任意の型の名前で認証されたプリンシパルと一致します。 UNKNOWNタイプの名前で認証されたプリンシパルは、しかし、唯一のタイプUNKNOWNの他の名前と一致します。"
    },
    {
      "indent": 3,
      "text": "Names of any type with an initial component of 'krbtgt' are reserved for the Kerberos ticket-granting service. See Section 7.3 for the form of such names.",
      "ja": "「のkrbtgt」の最初の要素を持つ任意の型の名前は、Kerberosチケット認可サービス用に予約されています。そのような名前の形式については、セクション7.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Name of Server Principals",
      "section_title": true,
      "ja": "6.2.1. サーバのプリンシパルの名前"
    },
    {
      "indent": 3,
      "text": "The principal identifier for a server on a host will generally be composed of two parts: (1) the realm of the KDC with which the server is registered, and (2) a two-component name of type NT-SRV-HST, if the host name is an Internet domain name, or a multi-component name of type NT-SRV-XHST, if the name of the host is of a form (such as X.500) that allows slash (/) separators. The first component of the two- or multi-component name will identify the service, and the latter components will identify the host. Where the name of the host is not case sensitive (for example, with Internet domain names) the name of the host MUST be lowercase. If specified by the application protocol for services such as telnet and the Berkeley R commands that run with system privileges, the first component MAY be the string 'host' instead of a service-specific identifier.",
      "ja": "ホスト上のサーバーのプリンシパル識別子は、一般的に2つの部分から構成されます：サーバが登録されているKDCの（1）領域、およびタイプNT-SRV-HSTの（2）二成分名、もしホスト名は、インターネットドメイン名、またはスラッシュ（/）区切りを可能タイプNT-SRV-XHSTの多成分名、ホスト名は、（例えば、X.500など）の形である場合です。第二の成分または多成分名は、サービスを識別し、後者のコンポーネントはホストを識別します。ホストの名前は、（例えば、インターネットドメイン名で）大文字と小文字を区別しない場合にはホストの名前は小文字でなければなりません。システム権限を持つその実行は、例えばtelnetやバークレーRなどのサービスのためのアプリケーションプロトコルでコマンドを指定した場合、第一成分は、文字列「ホスト」の代わりに、サービス固有の識別子であってもよいです。"
    },
    {
      "indent": 0,
      "text": "7. Constants and Other Defined Values",
      "section_title": true,
      "ja": "7.定数およびその他の定義された値"
    },
    {
      "indent": 0,
      "text": "7.1. Host Address Types",
      "section_title": true,
      "ja": "7.1. ホストアドレスタイプ"
    },
    {
      "indent": 3,
      "text": "All negative values for the host address type are reserved for local use. All non-negative values are reserved for officially assigned type fields and interpretations.",
      "ja": "ホストアドレスの種類のすべての負の値は、ローカル使用のために予約されています。すべての非負の値が正式に割り当てられたタイプ分野と解釈のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Internet (IPv4) Addresses",
      "ja": "インターネット（IPv4）のアドレス"
    },
    {
      "indent": 6,
      "text": "Internet (IPv4) addresses are 32-bit (4-octet) quantities, encoded in MSB order (most significant byte first). The IPv4 loopback address SHOULD NOT appear in a Kerberos PDU. The type of IPv4 addresses is two (2).",
      "ja": "インターネット（IPv4）のアドレスは、MSBの順に符号化された32ビット（4オクテット）の量、（最上位バイトが最初）です。 IPv4のループバックアドレスは、Kerberos PDUに表示されません。 IPv4アドレスのタイプは、2つ（2）です。"
    },
    {
      "indent": 3,
      "text": "Internet (IPv6) Addresses",
      "ja": "インターネット（IPv6）アドレス"
    },
    {
      "indent": 6,
      "text": "IPv6 addresses [RFC3513] are 128-bit (16-octet) quantities, encoded in MSB order (most significant byte first). The type of IPv6 addresses is twenty-four (24). The following addresses MUST NOT appear in any Kerberos PDU:",
      "ja": "IPv6アドレス[RFC3513]はMSBの順（最上位バイトが最初）でエンコードされた128ビット（16オクテット）の量です。 IPv6アドレスのタイプは、24（24）です。以下のアドレスは、いずれかのケルベロスPDUにも現れてはなりません。"
    },
    {
      "indent": 9,
      "text": "* the Unspecified Address * the Loopback Address * Link-Local addresses",
      "ja": "*未指定アドレス*ループバックアドレスは*リンクローカルアドレス"
    },
    {
      "indent": 6,
      "text": "This restriction applies to the inclusion in the address fields of Kerberos PDUs, but not to the address fields of packets that might carry such PDUs. The restriction is necessary because the use of an address with non-global scope could allow the acceptance of a message sent from a node that may have the same address, but which is not the host intended by the entity that added the restriction. If the link-local address type needs to be used for communication, then the address restriction in tickets must not be used (i.e., addressless tickets must be used).",
      "ja": "この制限は、KerberosのPDUのアドレスフィールドに含めるのではなく、そのようなPDUを運ぶかもしれないパケットのアドレスフィールドに適用されます。制限は、非グローバルスコープのアドレスの使用は、同一のアドレスを有していてもよく、ノードから送信されたメッセージの受け入れを可能にする可能性があるため必要であるが、制限を追加したエンティティによって意図ホストされていません。リンクローカルアドレスのタイプが通信に使用する必要がある場合、チケットのアドレス制限（すなわち、アドレスなしチケットが使用されなければならない）を使用してはなりません。"
    },
    {
      "indent": 6,
      "text": "IPv4-mapped IPv6 addresses MUST be represented as addresses of type 2.",
      "ja": "IPv4マップIPv6アドレスは、タイプ2のアドレスとして表現されなければなりません。"
    },
    {
      "indent": 3,
      "text": "DECnet Phase IV Addresses",
      "ja": "DECnetフェーズIVアドレス"
    },
    {
      "indent": 6,
      "text": "DECnet Phase IV addresses are 16-bit addresses, encoded in LSB order. The type of DECnet Phase IV addresses is twelve (12).",
      "ja": "DECnetフェーズIVアドレスは、LSBの順序でエンコードされた16ビットのアドレス、です。 DECnetフェーズIVアドレスのタイプは12（12）です。"
    },
    {
      "indent": 3,
      "text": "Netbios Addresses",
      "ja": "NetBIOSのアドレス"
    },
    {
      "indent": 6,
      "text": "Netbios addresses are 16-octet addresses typically composed of 1 to 15 alphanumeric characters and padded with the US-ASCII SPC character (code 32). The 16th octet MUST be the US-ASCII NUL character (code 0). The type of Netbios addresses is twenty (20).",
      "ja": "NetBIOSのアドレスは、通常、1〜15文字の英数字で構成され、US-ASCIIのSPCの文字（コード32）で埋め16オクテットのアドレスです。 16オクテットは、US-ASCII NUL文字（コード0）でなければなりません。 NetBIOSのアドレスのタイプは20（20）です。"
    },
    {
      "indent": 3,
      "text": "Directional Addresses",
      "ja": "方向性アドレス"
    },
    {
      "indent": 6,
      "text": "Including the sender address in KRB_SAFE and KRB_PRIV messages is undesirable in many environments because the addresses may be changed in transport by network address translators. However, if these addresses are removed, the messages may be subject to a reflection attack in which a message is reflected back to its originator. The directional address type provides a way to avoid transport addresses and reflection attacks. Directional addresses are encoded as four-byte unsigned integers in network byte order. If the message is originated by the party sending the original KRB_AP_REQ message, then an address of 0 SHOULD be used. If the message is originated by the party to whom that KRB_AP_REQ was sent, then the address 1 SHOULD be used. Applications involving multiple parties can specify the use of other addresses.",
      "ja": "アドレスは、ネットワークアドレス変換により輸送に変更することができるので、KRB_SAFEとKRB_PRIVメッセージで送信者アドレスを含めると多くの環境では望ましくありません。これらのアドレスが削除された場合は、メッセージは、メッセージが、その発信者に戻って反射された反射攻撃を受ける可能性があります。方向性アドレスタイプは、トランスポートアドレスおよび反射攻撃を回避するための方法を提供します。方向性のアドレスは、ネットワークバイト順で4バイトの符号なし整数としてエンコードされます。メッセージは、元のKRB_AP_REQメッセージを送信側で発信された場合は、0のアドレスを使用する必要があります。メッセージがそのKRB_AP_REQが送られた人の当事者によって発信されている場合は、アドレス1を使用する必要があります。複数の当事者が関与するアプリケーションは、他のアドレスの使用を指定することができます。"
    },
    {
      "indent": 6,
      "text": "Directional addresses MUST only be used for the sender address field in the KRB_SAFE or KRB_PRIV messages. They MUST NOT be used as a ticket address or in a KRB_AP_REQ message. This address type SHOULD only be used in situations where the sending party knows that the receiving party supports the address type. This generally means that directional addresses may only be used when the application protocol requires their support. Directional addresses are type (3).",
      "ja": "方向性のアドレスはKRB_SAFEかKRB_PRIVメッセージ内の送信元アドレスフィールドを使用しなければなりません。彼らは、チケットのアドレスとして、あるいはKRB_AP_REQメッセージで使用してはいけません。このアドレスの種類は送信のみ当事者は受信者がアドレスの種類をサポートしていることを知っているような状況で使用されるべきです。これは、一般的にアプリケーションプロトコルが彼らのサポートを必要とするとき、方向アドレスにのみ使用することができることを意味しています。方向性のアドレスがタイプされている（3）。"
    },
    {
      "indent": 0,
      "text": "7.2. KDC Messaging: IP Transports",
      "section_title": true,
      "ja": "7.2.  KDCメッセージング：IPトランスポート"
    },
    {
      "indent": 3,
      "text": "Kerberos defines two IP transport mechanisms for communication between clients and servers: UDP/IP and TCP/IP.",
      "ja": "UDP / IPおよびTCP / IP：Kerberosは、クライアントとサーバー間の通信のための2つのIPトランスポート・メカニズムを定義します。"
    },
    {
      "indent": 0,
      "text": "7.2.1. UDP/IP transport",
      "section_title": true,
      "ja": "7.2.1.  UDP / IPトランスポート"
    },
    {
      "indent": 3,
      "text": "Kerberos servers (KDCs) supporting IP transports MUST accept UDP requests and SHOULD listen for them on port 88 (decimal) unless specifically configured to listen on an alternative UDP port. Alternate ports MAY be used when running multiple KDCs for multiple realms on the same host.",
      "ja": "IPトランスポートをサポートするKerberosサーバ（KDCを）は、UDP要求を受け入れなければならないし、特に代替UDPポートでリッスンするように設定しない限り、ポート88（10進数）に彼らのために聞くべきです。同じホスト上で複数のレルムのために複数のKDCを実行している場合、代替ポートを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Kerberos clients supporting IP transports SHOULD support the sending of UDP requests. Clients SHOULD use KDC discovery [7.2.3] to identify the IP address and port to which they will send their request.",
      "ja": "IPトランスポートをサポートしているKerberosクライアントは、UDPリクエストの送信をサポートする必要があります。クライアントは、彼らは彼らの要求を送信する先のIPアドレスとポートを識別するために、KDCの発見[7.2.3]を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "When contacting a KDC for a KRB_KDC_REQ request using UDP/IP transport, the client shall send a UDP datagram containing only an encoding of the request to the KDC. The KDC will respond with a reply datagram containing only an encoding of the reply message (either a KRB_ERROR or a KRB_KDC_REP) to the sending port at the sender's IP address. The response to a request made through UDP/IP transport MUST also use UDP/IP transport. If the response cannot be handled using UDP (for example, because it is too large), the KDC MUST return KRB_ERR_RESPONSE_TOO_BIG, forcing the client to retry the request using the TCP transport.",
      "ja": "UDP / IPトランスポートを使用してKRB_KDC_REQ要求のためにKDCに連絡すると、クライアントは、KDCへの要求の唯一のエンコーディングを含むUDPデータグラムを送信しなければなりません。 KDCは、送信者のIPアドレスの送信ポートへの返信メッセージ（KRB_ERRORかKRB_KDC_REPのいずれか）の唯一のエンコーディングを含む応答データグラムで応答します。 UDP / IPトランスポートを介して行われた要求に対する応答はまた、UDP / IPトランスポートを使用しなければなりません。 （それは大きすぎるため、例えば）応答がUDPを使用して処理することができない場合は、KDCはTCPトランスポートを使用して要求を再試行するようにクライアントを強制的に、KRB_ERR_RESPONSE_TOO_BIGを返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.2.2. TCP/IP Transport",
      "section_title": true,
      "ja": "7.2.2.  TCP / IPトランスポート"
    },
    {
      "indent": 3,
      "text": "Kerberos servers (KDCs) supporting IP transports MUST accept TCP requests and SHOULD listen for them on port 88 (decimal) unless specifically configured to listen on an alternate TCP port. Alternate ports MAY be used when running multiple KDCs for multiple realms on the same host.",
      "ja": "Kerberosサーバは（KDCを）サポートするIPトランスポートはTCP要求を受け入れなければならないし、特に代替TCPポートをリッスンするように設定しない限り、ポート88（10進数）に彼らのために聞くべきです。同じホスト上で複数のレルムのために複数のKDCを実行している場合、代替ポートを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Clients MUST support the sending of TCP requests, but MAY choose to try a request initially using the UDP transport. Clients SHOULD use KDC discovery [7.2.3] to identify the IP address and port to which they will send their request.",
      "ja": "クライアントは、TCP要求の送信をサポートしなければならないが、最初にUDPトランスポートを使用して要求を試して選ぶかもしれません。クライアントは、彼らは彼らの要求を送信する先のIPアドレスとポートを識別するために、KDCの発見[7.2.3]を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Some extensions to the Kerberos protocol will not succeed if any client or KDC not supporting the TCP transport is involved. Implementations of RFC 1510 were not required to support TCP/IP transports.",
      "ja": "実装上の注意：任意のクライアントまたはKDCはTCPトランスポートが関与しているサポートしていない場合は、Kerberosプロトコルへのいくつかの拡張機能は成功しません。 RFC 1510の実装は、TCP / IPトランスポートをサポートするために必要とされませんでした。"
    },
    {
      "indent": 3,
      "text": "When the KRB_KDC_REQ message is sent to the KDC over a TCP stream, the response (KRB_KDC_REP or KRB_ERROR message) MUST be returned to the client on the same TCP stream that was established for the request. The KDC MAY close the TCP stream after sending a response, but MAY leave the stream open for a reasonable period of time if it expects a follow-up. Care must be taken in managing TCP/IP connections on the KDC to prevent denial of service attacks based on the number of open TCP/IP connections.",
      "ja": "KRB_KDC_REQメッセージはTCPストリーム上でKDCに送信されると、応答（KRB_KDC_REPまたはKRB_ERRORメッセージ）は、要求のために設立されたのと同じTCPストリーム上でクライアントに返さなければなりません。 KDCは応答を送信した後、TCPストリームを閉じるかもしれないが、それはフォローアップを期待していた場合、合理的な期間のためのオープンストリームを残すことができます。ケアは、オープンTCP / IP接続の数に基づいて、サービス拒否攻撃を防ぐために、KDC上のTCP / IP接続を管理に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client MUST be prepared to have the stream closed by the KDC at any time after the receipt of a response. A stream closure SHOULD NOT be treated as a fatal error. Instead, if multiple exchanges are required (e.g., certain forms of pre-authentication), the client may need to establish a new connection when it is ready to send subsequent messages. A client MAY close the stream after receiving a response, and SHOULD close the stream if it does not expect to send follow-up messages.",
      "ja": "クライアントは応答を受信した後、任意の時点でKDCによるストリームを閉じているために準備しなければなりません。ストリームの閉鎖は致命的なエラーとして扱われるべきではありません。複数の交換が必要な場合は代わりに、（例えば、事前認証の特定の形態）は、クライアントは、後続のメッセージを送信する準備ができたときに新しい接続を確立する必要があるかもしれません。クライアントが応答を受信した後、ストリームを閉じることができ、それはフォローアップメッセージを送信することを期待していない場合は、ストリームを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "A client MAY send multiple requests before receiving responses, though it must be prepared to handle the connection being closed after the first response.",
      "ja": "最初の応答の後に閉鎖されている接続を処理するために準備しなければならないものの、クライアントは、応答を受信する前に複数の要求を送信することができます。"
    },
    {
      "indent": 3,
      "text": "Each request (KRB_KDC_REQ) and response (KRB_KDC_REP or KRB_ERROR) sent over the TCP stream is preceded by the length of the request as 4 octets in network byte order. The high bit of the length is reserved for future expansion and MUST currently be set to zero. If a KDC that does not understand how to interpret a set high bit of the length encoding receives a request with the high order bit of the length set, it MUST return a KRB-ERROR message with the error KRB_ERR_FIELD_TOOLONG and MUST close the TCP stream.",
      "ja": "TCPストリーム上に送信される各要求（KRB_KDC_REQ）及び応答（KRB_KDC_REPまたはKRB_ERROR）は、ネットワークバイト順で4つのオクテットとして要求の長さが先行します。長さの高いビットは、将来の拡張のために予約され、現在はゼロに設定しなければなりません。可変長符号化の設定、高ビットを解釈する方法を理解していないKDCは、長さセットの上位ビットとの要求を受けた場合は、エラーKRB_ERR_FIELD_TOOLONGでKRB-ERRORメッセージを返さなければなりませんし、TCPストリームを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "If multiple requests are sent over a single TCP connection and the KDC sends multiple responses, the KDC is not required to send the responses in the order of the corresponding requests. This may permit some implementations to send each response as soon as it is ready, even if earlier requests are still being processed (for example, waiting for a response from an external device or database).",
      "ja": "複数の要求を単一のTCP接続を介して送信され、KDCは複数の応答を送信した場合、KDCは、対応する要求の順序で応答を送信するために必要とされていません。これは、すぐにそれが以前のリクエストがまだ（たとえば、外部機器やデータベースからの応答を待っている）処理されている場合でも、準備ができているとして各応答を送信するためにいくつかの実装を可能にすることができます。"
    },
    {
      "indent": 0,
      "text": "7.2.3. KDC Discovery on IP Networks",
      "section_title": true,
      "ja": "7.2.3.  IPネットワーク上のKDC発見"
    },
    {
      "indent": 3,
      "text": "Kerberos client implementations MUST provide a means for the client to determine the location of the Kerberos Key Distribution Centers (KDCs). Traditionally, Kerberos implementations have stored such configuration information in a file on each client machine. Experience has shown that this method of storing configuration information presents problems with out-of-date information and scaling, especially when using cross-realm authentication. This section describes a method for using the Domain Name System [RFC1035] for storing KDC location information.",
      "ja": "Kerberosクライアントの実装では、クライアントがKerberosキー配布センター（KDCを）の位置を決定するための手段を提供しなければなりません。伝統的に、Kerberosの実装は、各クライアントマシン上のファイルにこのような構成情報を格納しています。経験は、クロスレルム認証を使用する場合は特に、構成情報を格納するこのメソッドは、期限切れの情報とスケーリングの問題を提示することを示しています。このセクションでは、KDCの位置情報を記憶するためのドメインネームシステム[RFC1035]を使用する方法を記載しています。"
    },
    {
      "indent": 0,
      "text": "7.2.3.1. DNS vs. Kerberos: Case Sensitivity of Realm Names",
      "section_title": true,
      "ja": "7.2.3.1。 Kerberosの対DNS：レルム名の大文字小文字の区別"
    },
    {
      "indent": 3,
      "text": "In Kerberos, realm names are case sensitive. Although it is strongly encouraged that all realm names be all uppercase, this recommendation has not been adopted by all sites. Some sites use all lowercase names and other use mixed case. DNS, on the other hand, is case insensitive for queries. Because the realm names \"MYREALM\", \"myrealm\", and \"MyRealm\" are all different, but resolve the same in the domain name system, it is necessary that only one of the possible combinations of upper- and lowercase characters be used in realm names.",
      "ja": "ケルベロスでは、レルム名は大文字と小文字が区別されます。それは強く、すべてのレルム名はすべて大文字であることが奨励されているが、この勧告は、すべてのサイトで採用されていません。一部のサイトでは、すべて小文字の名前やその他の使用大文字と小文字を使用しています。 DNSは、他の一方で、クエリの大文字と小文字を区別しません。レルム名「MYREALM」、「MYREALM」、および「MYREALM」ので、すべて異なっているが、ドメインネームシステムで同じことを解決するには、大文字と小文字の可能な組み合わせの一方のみが分野で使用されることが必要です名前。"
    },
    {
      "indent": 0,
      "text": "7.2.3.2. Specifying KDC Location Information with DNS SRV records",
      "section_title": true,
      "ja": "7.2.3.2。 DNS SRVレコードとKDC位置情報を指定します"
    },
    {
      "indent": 3,
      "text": "KDC location information is to be stored using the DNS SRV RR [RFC2782]. The format of this RR is as follows:",
      "ja": "KDCの位置情報は、DNS SRVのRR [RFC2782]を使用して格納されます。次のようにこのRRの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "_Service._Proto.Realm TTL Class SRV Priority Weight Port Target",
      "ja": "_Service._Proto.Realm TTLクラスSRV優先重ポートターゲット"
    },
    {
      "indent": 3,
      "text": "The Service name for Kerberos is always \"kerberos\".",
      "ja": "Kerberosのサービス名は、常に「ケルベロス」です。"
    },
    {
      "indent": 3,
      "text": "The Proto can be either \"udp\" or \"tcp\". If these SRV records are to be used, both \"udp\" and \"tcp\" records MUST be specified for all KDC deployments.",
      "ja": "プロトは、「UDP」または「TCP」のいずれかになります。これらのSRVレコードは、両方の「udp」と「tcp」レコードを使用する場合、すべてのKDCの展開を指定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Realm is the Kerberos realm that this record corresponds to. The realm MUST be a domain-style realm name.",
      "ja": "レルムは、このレコードが対応するKerberosレルムです。レルムは、ドメインスタイルのレルム名でなければなりません。"
    },
    {
      "indent": 3,
      "text": "TTL, Class, SRV, Priority, Weight, and Target have the standard meaning as defined in RFC 2782.",
      "ja": "TTL、クラス、SRV、優先度、体重、およびターゲットRFC 2782で定義されている標準的な意味を持っています。"
    },
    {
      "indent": 3,
      "text": "As per RFC 2782, the Port number used for \"_udp\" and \"_tcp\" SRV records SHOULD be the value assigned to \"kerberos\" by the Internet Assigned Number Authority: 88 (decimal), unless the KDC is configured to listen on an alternate TCP port.",
      "ja": "RFC 2782あたりの通り、「_udp」と「_tcp」SRVレコードに使用するポート番号は、ナンバー当局割り当てられたインターネットによる「ケルベロス」に割り当てられた値であるべきである：88（10進数）、KDCが交互にリッスンするように構成されていない限り、 TCPポート。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Many existing client implementations do not support KDC Discovery and are configured to send requests to the IANA assigned port (88 decimal), so it is strongly recommended that KDCs be configured to listen on that port.",
      "ja": "実装上の注意：多くの既存のクライアントの実装は、KDCの発見をサポートしていないとIANAに割り当てられたポート（88進）に要求を送信するように設定されているので、強くのKDCがそのポートでリッスンするように設定することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "7.2.3.3. KDC Discovery for Domain Style Realm Names on IP Networks",
      "section_title": true,
      "ja": "7.2.3.3。 IPネットワーク上のドメインスタイルのレルム名のKDC発見"
    },
    {
      "indent": 3,
      "text": "These are DNS records for a Kerberos realm EXAMPLE.COM. It has two Kerberos servers, kdc1.example.com and kdc2.example.com. Queries should be directed to kdc1.example.com first as per the specified priority. Weights are not used in these sample records.",
      "ja": "これらは、KerberosレルムEXAMPLE.COMのDNSレコードです。これは、2台のKerberosサーバ、kdc1.example.comとkdc2.example.comを持っています。クエリは、指定された優先順位に従って最初kdc1.example.comに向けられるべきです。重みは、これらのサンプル・レコードに使用されていません。"
    },
    {
      "indent": 5,
      "text": "_kerberos._udp.EXAMPLE.COM. IN SRV 0 0 88 kdc1.example.com. _kerberos._udp.EXAMPLE.COM. IN SRV 1 0 88 kdc2.example.com. _kerberos._tcp.EXAMPLE.COM. IN SRV 0 0 88 kdc1.example.com. _kerberos._tcp.EXAMPLE.COM. IN SRV 1 0 88 kdc2.example.com.",
      "ja": "_kerberos._udp.EXAMPLE.COM。 SRV 0 0 88 kdc1.example.com。 _kerberos._udp.EXAMPLE.COM。 SRV 1 IN 0 88 kdc2.example.com。 _kerberos._tcp.EXAMPLE.COM。 SRV 0 0 88 kdc1.example.com。 _kerberos._tcp.EXAMPLE.COM。 SRV 1 IN 0 88 kdc2.example.com。"
    },
    {
      "indent": 0,
      "text": "7.3. Name of the TGS",
      "section_title": true,
      "ja": "7.3.  TGSの名前"
    },
    {
      "indent": 3,
      "text": "The principal identifier of the ticket-granting service shall be composed of three parts: the realm of the KDC issuing the TGS ticket, and a two-part name of type NT-SRV-INST, with the first part \"krbtgt\" and the second part the name of the realm that will accept the TGT. For example, a TGT issued by the ATHENA.MIT.EDU realm to be used to get tickets from the ATHENA.MIT.EDU KDC has a principal identifier of \"ATHENA.MIT.EDU\" (realm), (\"krbtgt\", \"ATHENA.MIT.EDU\") (name). A TGT issued by the ATHENA.MIT.EDU realm to be used to get tickets from the MIT.EDU realm has a principal identifier of \"ATHENA.MIT.EDU\" (realm), (\"krbtgt\", \"MIT.EDU\") (name).",
      "ja": "チケット許可サービスのプリンシパル識別子は、3つの部分で構成されなければならない：第一部「KRBTGT」と第二とのTGSチケッ​​トを発行するKDCの領域、及びタイプNT-SRV-INSTの2部構成の名前、 TGTを受け入れるレルムの名前を手放します。例えば、ATHENA.MIT.EDU KDCからチケットを取得するために使用されるATHENA.MIT.EDUレルムによって発行されたTGT」は、「ATHENA.MIT.EDU」（レルム）、（「KRBTGT」のプリンシパル識別子を有しますATHENA.MIT.EDU \"）（名）。 MIT.EDUレルムのチケットを取得するために使用されるATHENA.MIT.EDUレルムによって発行されたTGT「はATHENA.MIT.EDU」（レルム）、（「KRBTGT」、「MIT.EDU」）の主要な識別子を有します（名前）。"
    },
    {
      "indent": 0,
      "text": "7.4. OID Arc for KerberosV5",
      "section_title": true,
      "ja": "7.4.  KerberosV5のためのOIDアーク"
    },
    {
      "indent": 3,
      "text": "This OID MAY be used to identify Kerberos protocol messages encapsulated in other protocols. It also designates the OID arc for KerberosV5-related OIDs assigned by future IETF action. Implementation note: RFC 1510 had an incorrect value (5) for \"dod\" in its OID.",
      "ja": "このOIDは、他のプロトコルでカプセル化されたケルベロスプロトコルメッセージを識別するために使用されるかもしれません。それはまた、将来のIETF作用によって割り当てKerberosV5関連のOIDのためのOIDアークを指定します。実装上の注意：RFC 1510は、そのOIDで「DOD」の誤った値（5）を有していました。"
    },
    {
      "indent": 3,
      "text": "id-krb5         OBJECT IDENTIFIER ::= {\n        iso(1) identified-organization(3) dod(6) internet(1)\n        security(5) kerberosV5(2)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Assignment of OIDs beneath the id-krb5 arc must be obtained by contacting the registrar for the id-krb5 arc, or its designee. At the time of the issuance of this RFC, such registrations can be obtained by contacting krb5-oid-registrar@mit.edu.",
      "ja": "ID-krb5のアークの下のOIDの割り当ては、ID-krb5のアークのためのレジストラを接触させることによって得られる、またはその指名されなければなりません。このRFCの発行時に、そのような登録がkrb5-oid-registrar@mit.eduを接触させることによって得ることができます。"
    },
    {
      "indent": 0,
      "text": "7.5. Protocol Constants and Associated Values",
      "section_title": true,
      "ja": "7.5. プロトコル定数と関連する値"
    },
    {
      "indent": 3,
      "text": "The following tables list constants used in the protocol and define their meanings. In the \"specification\" section, ranges are specified that limit the values of constants for which values are defined here. This allows implementations to make assumptions about the maximum values that will be received for these constants. Implementations receiving values outside the range specified in the \"specification\" section MAY reject the request, but they MUST recover cleanly.",
      "ja": "以下の表は、プロトコルで使用される定数をリストアップし、その意味を定義します。 「仕様」のセクションで、範囲は、値がここで定義されている定数の値を制限するように指定されています。これは、実装はこれらの定数のために受信された最大値についての仮定を行うことができます。 「仕様」のセクションで指定された範囲外の値を受け取る実装は、要求を拒否するかもしれないが、彼らはきれいに回復しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.5.1. Key Usage Numbers",
      "section_title": true,
      "ja": "7.5.1. キー使用法番号"
    },
    {
      "indent": 3,
      "text": "The encryption and checksum specifications in [RFC3961] require as input a \"key usage number\", to alter the encryption key used in any specific message in order to make certain types of cryptographic attack more difficult. These are the key usage values assigned in this document:",
      "ja": "[RFC3961]で暗号化とチェックサム仕様は、暗号攻撃の特定の種類をより困難にするために、任意の特定のメッセージに使用される暗号化キーを変更するために、入力として「キー使用数」を必要。これらは、本文書に割り当てられたキーの使用量の値です。"
    },
    {
      "indent": 11,
      "text": "1.  AS-REQ PA-ENC-TIMESTAMP padata timestamp, encrypted with\n    the client key (Section 5.2.7.2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": " 2. AS-REP Ticket and TGS-REP Ticket (includes TGS session key or application session key), encrypted with the service key (Section 5.3) 3. AS-REP encrypted part (includes TGS session key or application session key), encrypted with the client key (Section 5.4.2) 4. TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with the TGS session key (Section 5.4.1) 5. TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with the TGS authenticator subkey (Section 5.4.1) 6. TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator cksum, keyed with the TGS session key (Section 5.5.1) 7. TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator (includes TGS authenticator subkey), encrypted with the TGS session key (Section 5.5.1) 8. TGS-REP encrypted part (includes application session key), encrypted with the TGS session key (Section 5.4.2) 9. TGS-REP encrypted part (includes application session key), encrypted with the TGS authenticator subkey (Section 5.4.2) 10. AP-REQ Authenticator cksum, keyed with the application session key (Section 5.5.1) 11. AP-REQ Authenticator (includes application authenticator subkey), encrypted with the application session key (Section 5.5.1) 12. AP-REP encrypted part (includes application session subkey), encrypted with the application session key (Section 5.5.2) 13. KRB-PRIV encrypted part, encrypted with a key chosen by the application (Section 5.7.1) 14. KRB-CRED encrypted part, encrypted with a key chosen by the application (Section 5.8.1) 15. KRB-SAFE cksum, keyed with a key chosen by the application (Section 5.6.1) 16-18. Reserved for future use in Kerberos and related protocols. 19. AD-KDC-ISSUED checksum (ad-checksum in 5.2.6.4) 20-21. Reserved for future use in Kerberos and related protocols. 22-25. Reserved for use in the Kerberos Version 5 GSS-API mechanisms [RFC4121]. 26-511. Reserved for future use in Kerberos and related protocols. 512-1023. Reserved for uses internal to a Kerberos implementation. 1024. Encryption for application use in protocols that do not specify key usage values",
      "ja": "2. AS-REPチケットおよびTGS-REPチケットサービスキー（5.3節）3. AS-REPが一部を暗号化して暗号化され、暗号化された（TGSセッションキーまたはアプリケーション・セッション・キー含む）（TGSセッションキーまたはアプリケーションセッションキーを含みます） TGSセッション鍵で暗号化されたクライアントキー（5.4.2項）4. TGS-REQ KDC-REQ-BODY AuthorizationData、TGSで暗号化された（5.4.1項）5. TGS-REQ KDC-REQ-BODY AuthorizationData、とオーセンティケータサブキー（5.4.1）6. TGSセッションキーとキー入力TGS-REQ PA-TGS-REQのPADATA AP-REQ認証プログラムcksumのは、（セクション5.5.1）7. TGS-REQ PA-TGS-REQ PADATA AP- TGSセッションキーで暗号化されたREQの認証（TGS認証サブキーを含む）、TGSセッションキーで暗号化された（セクション5.5.1）8. TGS-REPは、部分暗号化（アプリケーションセッションキーを含む）、（セクション5.4.2）9. TGS -rep暗号化された部分のアプリケーションsessiとキーイングTGS認証サブキー（セクション5.4.2）10 AP-REQ認証プログラムcksumので暗号化、（アプリケーションセッションキーを含みます）キー（5.5.1項）11. AP-REQのオーセンティケータ（アプリ認証サブキーを含む）、アプリケーション・セッション・キーで暗号化された（セクション5.5.1）12 AP-REPの一部を暗号化された上で暗号化、（アプリケーションセッションサブキーを含みます）アプリケーション・セッション・キー（5.5.2項）13. KRB-PRIV 14. KRB-CREDアプリケーション（セクション5.8によって選択されたキーで暗号化され、一部を暗号化アプリケーション（セクション5.7.1）によって選択されたキーで暗号化され、一部を暗号化0.1）15. KRB-SAFE cksumの、アプリケーション（セクション5.6.1）16-18によって選択されたキーとキー止め。 Kerberosおよび関連プロトコルでの将来の使用のために予約されています。 19. AD-KDC発行のチェックサム（5.2.6.4での広告のチェックサム）20-21。 Kerberosおよび関連プロトコルでの将来の使用のために予約されています。 22-25。 Kerberosバージョン5 GSS-APIメカニズム[RFC4121]で使用するために予約されています。 26から511まで。 Kerberosおよび関連プロトコルでの将来の使用のために予約されています。 512から1023。 Kerberos実装への内部使用のために予約されています。キーの使用量の値を指定しないプロトコルでのアプリケーションの使用のための1024の暗号化"
    },
    {
      "indent": 3,
      "text": " 1025. Checksums for application use in protocols that do not specify key usage values 1026-2047. Reserved for application use.",
      "ja": "キーの使用量の値1026から2047を指定していないプロトコルでのアプリケーションの使用のための1025のチェックサム。アプリケーションで使用するために予約されています。"
    },
    {
      "indent": 0,
      "text": "7.5.2. PreAuthentication Data Types",
      "section_title": true,
      "ja": "7.5.2. 事前認証データの種類"
    },
    {
      "indent": 3,
      "text": "Padata and Data Type Padata-type Comment Value",
      "ja": "PADATAとデータタイプPADATA型コメント値"
    },
    {
      "indent": 3,
      "text": "PA-TGS-REQ 1 PA-ENC-TIMESTAMP 2 PA-PW-SALT 3 [reserved] 4 PA-ENC-UNIX-TIME 5 (deprecated) PA-SANDIA-SECUREID 6 PA-SESAME 7 PA-OSF-DCE 8 PA-CYBERSAFE-SECUREID 9 PA-AFS3-SALT 10 PA-ETYPE-INFO 11 PA-SAM-CHALLENGE 12 (sam/otp) PA-SAM-RESPONSE 13 (sam/otp) PA-PK-AS-REQ_OLD 14 (pkinit) PA-PK-AS-REP_OLD 15 (pkinit) PA-PK-AS-REQ 16 (pkinit) PA-PK-AS-REP 17 (pkinit) PA-ETYPE-INFO2 19 (replaces pa-etype-info) PA-USE-SPECIFIED-KVNO 20 PA-SAM-REDIRECT 21 (sam/otp) PA-GET-FROM-TYPED-DATA 22 (embedded in typed data) TD-PADATA 22 (embeds padata) PA-SAM-ETYPE-INFO 23 (sam/otp) PA-ALT-PRINC 24 (crawdad@fnal.gov) PA-SAM-CHALLENGE2 30 (kenh@pobox.com) PA-SAM-RESPONSE2 31 (kenh@pobox.com) PA-EXTRA-TGT 41 Reserved extra TGT TD-PKINIT-CMS-CERTIFICATES 101 CertificateSet from CMS TD-KRB-PRINCIPAL 102 PrincipalName TD-KRB-REALM 103 Realm TD-TRUSTED-CERTIFIERS 104 from PKINIT TD-CERTIFICATE-INDEX 105 from PKINIT TD-APP-DEFINED-ERROR 106 application specific TD-REQ-NONCE 107 INTEGER TD-REQ-SEQ 108 INTEGER PA-PAC-REQUEST 128 (jbrezak@exchange.microsoft.com)",
      "ja": "PA-TGS-REQ 1 PA-ENC-TIMESTAMP 2 PA-PW-SALT 3 [予約] 4 PA-ENC-UNIX-TIME 5（旧式）PA-SANDIA-SECUREID 6 PA-SESAME 7 PA-OSF-DCE 8 PA -CYBERSAFE-SECUREID 9 PA-AFS3塩10 PA-ETYPE-INFO 11 PA-SAM-CHALLENGE 12（SAM / OTP）PA-SAM-RESPONSE 13（SAM / OTP）PA-PK-AS-REQ_OLD 14（PKINIT） PA-PK-AS-REP_OLD 15（PKINIT）PA-PK-AS-REQ 16（PKINIT）PA-PK-AS-REP 17（PKINIT）PA-ETYPE-INFO2 19は、（PA-ETYPE-情報を置き換える）PA-USE -SPECIFIED-KVNO 20 PA-SAM-REDIRECT 21（SAM / OTP）PA-GET-FROM型付け-DATA 22（入力したデータに埋め込まれた）TD-PADATA 22（埋め込みPADATA）PA-SAM-ETYPE-INFO 23（SAM / OTP）PA-ALT-のprinc 24（crawdad@fnal.gov）PA-SAM-CHALLENGE2 30（kenh@pobox.com）PA-SAM-RESPONSE2 31（kenh@pobox.com）PA-EXTRA-TGT 41予約エクストラTGT TD-PKINIT-CMS認証証明書101証明書群CMS TD-KRB-PRINCIPAL 102のPrincipalName TD-KRB-REALM 103レルムTD-信頼できる認証機関104からPKINIT TD-CERTIFICATE-INDEX 105からPKINIT TD-APP-DEFINED-ERROR 106からアプリケーション特定TD-REQ-NONCE 107 INTEGER TD-REQ-配列108 INTEGER PA-PA C-REQUEST 128（jbrezak@exchange.microsoft.com）"
    },
    {
      "indent": 0,
      "text": "7.5.3. Address Types",
      "section_title": true,
      "ja": "7.5.3. アドレスの種類"
    },
    {
      "indent": 3,
      "text": "Address Type Value",
      "ja": "アドレスタイプ値"
    },
    {
      "indent": 3,
      "text": "IPv4 2 Directional 3 ChaosNet 5 XNS 6 ISO 7 DECNET Phase IV 12 AppleTalk DDP 16 NetBios 20 IPv6 24",
      "ja": "IPv4の2指向3 ChaosNet 5 XNS 6 ISO 7 DECnetフェーズIV 12件のAppleTalk DDP 16件のNetBios 20のIPv6 24"
    },
    {
      "indent": 0,
      "text": "7.5.4. Authorization Data Types",
      "section_title": true,
      "ja": "7.5.4. 認可データ・タイプ"
    },
    {
      "indent": 3,
      "text": "Authorization Data Type Ad-type Value",
      "ja": "認可データ型広告型の値"
    },
    {
      "indent": 3,
      "text": "AD-IF-RELEVANT 1 AD-INTENDED-FOR-SERVER 2 AD-INTENDED-FOR-APPLICATION-CLASS 3 AD-KDC-ISSUED 4 AD-AND-OR 5 AD-MANDATORY-TICKET-EXTENSIONS 6 AD-IN-TICKET-EXTENSIONS 7 AD-MANDATORY-FOR-KDC 8 Reserved values 9-63 OSF-DCE 64 SESAME 65 AD-OSF-DCE-PKI-CERTID 66 (hemsath@us.ibm.com) AD-WIN2K-PAC 128 (jbrezak@exchange.microsoft.com) AD-ETYPE-NEGOTIATION 129 (lzhu@windows.microsoft.com)",
      "ja": "AD-IF関連1つのAD-対象用途-FOR-SERVER 2 AD-対象用途-FOR-APPLICATION-CLASS 3 AD-KDC発行4 AD-AND-OR 5 AD-MANDATORY-TICKET-EXTENSIONS 6 AD-IN-乗車券EXTENSIONS 7 AD-MANDATORY-FOR-KDC 8予約66（hemsath@us.ibm.com）AD-WIN2K-PAC 128（jbrezakする@交換9-63 OSF-DCE 64 SESAME 65 AD-OSF-DCE-PKI-CERTID値.microsoft.com）AD-ETYPEネゴシエーション129（lzhu@windows.microsoft.com）"
    },
    {
      "indent": 0,
      "text": "7.5.5. Transited Encoding Types",
      "section_title": true,
      "ja": "7.5.5. 遷移エンコーディング型"
    },
    {
      "indent": 3,
      "text": "Transited Encoding Type Tr-type Value",
      "ja": "遷移エンコードタイプTR-タイプの値"
    },
    {
      "indent": 3,
      "text": "DOMAIN-X500-COMPRESS 1 Reserved values All others",
      "ja": "DOMAIN-X500-COMPRESS 1つの予約済みの値その他すべて"
    },
    {
      "indent": 0,
      "text": "7.5.6. Protocol Version Number",
      "section_title": true,
      "ja": "7.5.6. プロトコルバージョン番号"
    },
    {
      "indent": 3,
      "text": "Label Value Meaning or MIT Code",
      "ja": "ラベル値意味やMITコード"
    },
    {
      "indent": 3,
      "text": "pvno 5 Current Kerberos protocol version number",
      "ja": "PVNO 5現在のKerberosプロトコルバージョン番号"
    },
    {
      "indent": 0,
      "text": "7.5.7. Kerberos Message Types",
      "section_title": true,
      "ja": "7.5.7. ケルベロスメッセージタイプ"
    },
    {
      "indent": 3,
      "text": "Message Type Value Meaning",
      "ja": "メッセージタイプ値意味"
    },
    {
      "indent": 3,
      "text": "KRB_AS_REQ 10 Request for initial authentication KRB_AS_REP 11 Response to KRB_AS_REQ request KRB_TGS_REQ 12 Request for authentication based on TGT KRB_TGS_REP 13 Response to KRB_TGS_REQ request KRB_AP_REQ 14 Application request to server KRB_AP_REP 15 Response to KRB_AP_REQ_MUTUAL KRB_RESERVED16 16 Reserved for user-to-user krb_tgt_request KRB_RESERVED17 17 Reserved for user-to-user krb_tgt_reply KRB_SAFE 20 Safe (checksummed) application message KRB_PRIV 21 Private (encrypted) application message KRB_CRED 22 Private (encrypted) message to forward credentials KRB_ERROR 30 Error response",
      "ja": "ユーザ対ユーザkrb_tgt_request KRB_RESERVED17 17予約のためKRB_AP_REQ_MUTUAL KRB_RESERVED16 16予約にサーバKRB_AP_REP 15応答にKRB_TGS_REQ要求KRB_AP_REQ 14アプリケーション要求にTGT KRB_TGS_REP 13の応答に基づいて認証のKRB_AS_REQ要求KRB_TGS_REQ 12要求に対する初期認証KRB_AS_REP 11の応答をKRB_AS_REQ 10依頼ユーザ対ユーザkrb_tgt_reply KRB_SAFE 20セーフクレデンシャルKRB_ERROR 30エラー応答を転送する（チェックサム）アプリケーションメッセージKRB_PRIV 21プライベート（暗号化された）アプリケーションメッセージKRB_CRED 22プライベート（暗号化された）メッセージの"
    },
    {
      "indent": 0,
      "text": "7.5.8. Name Types",
      "section_title": true,
      "ja": "7.5.8. 名前の種類"
    },
    {
      "indent": 3,
      "text": "Name Type Value Meaning",
      "ja": "種類値は、名前意味"
    },
    {
      "indent": 3,
      "text": "KRB_NT_UNKNOWN 0 Name type not known KRB_NT_PRINCIPAL 1 Just the name of the principal as in DCE, or for users KRB_NT_SRV_INST 2 Service and other unique instance (krbtgt) KRB_NT_SRV_HST 3 Service with host name as instance (telnet, rcommands) KRB_NT_SRV_XHST 4 Service with host as remaining components KRB_NT_UID 5 Unique ID KRB_NT_X500_PRINCIPAL 6 Encoded X.509 Distinguished name [RFC2253] KRB_NT_SMTP_NAME 7 Name in form of SMTP email name (e.g., user@example.com) KRB_NT_ENTERPRISE 10 Enterprise name; may be mapped to principal name",
      "ja": "（TELNET、rcommands）としてホストとKRB_NT_SRV_XHST 4サービスインスタンスとしてホスト名を持つKRB_NT_SRV_HST 3サービスDCEのようなプリンシパルの名前だけKRB_NT_PRINCIPAL 1既知、またはユーザKRB_NT_SRV_INST 2サービスやそのほかの固有インスタンス（krbtgt）のためのないKRB_NT_UNKNOWN 0名タイプSMTP電子メール名（例えば、user@example.com）KRB_NT_ENTERPRISE 10エンタープライズ名の形で残りの成分KRB_NT_UID 5ユニークID KRB_NT_X500_PRINCIPAL 6エンコードX.509識別名[RFC2253] KRB_NT_SMTP_NAME 7名。プリンシパル名にマッピングすることができます"
    },
    {
      "indent": 0,
      "text": "7.5.9. Error Codes",
      "section_title": true,
      "ja": "7.5.9. エラーコード"
    },
    {
      "indent": 3,
      "text": "Error Code Value Meaning",
      "ja": "エラーコード値意味します"
    },
    {
      "indent": 3,
      "text": "KDC_ERR_NONE 0 No error KDC_ERR_NAME_EXP 1 Client's entry in database has expired KDC_ERR_SERVICE_EXP 2 Server's entry in database has expired KDC_ERR_BAD_PVNO 3 Requested protocol version number not supported",
      "ja": "KDC_ERR_NONE 0は、データベース内のエラーなしKDC_ERR_NAME_EXP 1つのクライアントのエントリには、データベース内のKDC_ERR_SERVICE_EXP 2サーバーのエントリーがKDC_ERR_BAD_PVNO 3要求されたプロトコルのバージョン番号がサポートされていない、期限が切れています有効期限が切れていません"
    },
    {
      "indent": 3,
      "text": "KDC_ERR_C_OLD_MAST_KVNO 4 Client's key encrypted in old master key KDC_ERR_S_OLD_MAST_KVNO 5 Server's key encrypted in old master key KDC_ERR_C_PRINCIPAL_UNKNOWN 6 Client not found in Kerberos database KDC_ERR_S_PRINCIPAL_UNKNOWN 7 Server not found in Kerberos database KDC_ERR_PRINCIPAL_NOT_UNIQUE 8 Multiple principal entries in database KDC_ERR_NULL_KEY 9 The client or server has a null key KDC_ERR_CANNOT_POSTDATE 10 Ticket not eligible for postdating KDC_ERR_NEVER_VALID 11 Requested starttime is later than end time KDC_ERR_POLICY 12 KDC policy rejects request KDC_ERR_BADOPTION 13 KDC cannot accommodate requested option KDC_ERR_ETYPE_NOSUPP 14 KDC has no support for encryption type KDC_ERR_SUMTYPE_NOSUPP 15 KDC has no support for checksum type KDC_ERR_PADATA_TYPE_NOSUPP 16 KDC has no support for padata type KDC_ERR_TRTYPE_NOSUPP 17 KDC has no support for transited type KDC_ERR_CLIENT_REVOKED 18 Clients credentials have been revoked KDC_ERR_SERVICE_REVOKED 19 Credentials for server have been revoked KDC_ERR_TGT_REVOKED 20 TGT has been revoked KDC_ERR_CLIENT_NOTYET 21 Client not yet valid; try again later KDC_ERR_SERVICE_NOTYET 22 Server not yet valid; try again later KDC_ERR_KEY_EXPIRED 23 Password has expired; change password to reset KDC_ERR_PREAUTH_FAILED 24 Pre-authentication information was invalid KDC_ERR_PREAUTH_REQUIRED 25 Additional pre-authentication required KDC_ERR_SERVER_NOMATCH 26 Requested server and ticket don't match KDC_ERR_MUST_USE_USER2USER 27 Server principal valid for user2user only KDC_ERR_PATH_NOT_ACCEPTED 28 KDC Policy rejects transited path",
      "ja": "クライアントまたはサーバがnullを持っているKerberosデータベースに見つからない古いマスターキーKDC_ERR_S_OLD_MAST_KVNO 5サーバーの鍵古いマスターキーKDC_ERR_C_PRINCIPAL_UNKNOWNで暗号化された6クライアントKerberosデータベースに見つからないKDC_ERR_S_PRINCIPAL_UNKNOWN 7 ServerのデータベースKDC_ERR_NULL_KEY 9でKDC_ERR_PRINCIPAL_NOT_UNIQUE 8の複数の主要なエントリで暗号化されたKDC_ERR_C_OLD_MAST_KVNO 4クライアントの鍵要求されたKDC_ERR_NEVER_VALID 11 STARTTIMEをpostdatingの対象とならないキーKDC_ERR_CANNOT_POSTDATE 10チケットはKDC_ERR_POLICY 12 KDCポリシーはKDC_ERR_ETYPE_NOSUPP 14 KDCは、暗号化の種類KDC_ERR_SUMTYPE_NOSUPP 15 KDCをサポートしていませんKDC_ERR_BADOPTION 13 KDCが要求された収容できないオプションがKDC_ERR_PADATA_TYPE_NOSUPP 16チェックサムタイプをサポートしていません要求拒否終了時刻よりも遅いですKDCはPADATAタイプKDC_ERR_TRTYPE_NOSUPP 17 KDCのサポートは資格情報がサーバーHAVのためKDC_ERR_SERVICE_REVOKED 19資格情報を取り消された遷移タイプKDC_ERR_CLIENT_REVOKED 18クライアントをサポートしていませんしましたeはTGTがまだ有効ではありませんKDC_ERR_CLIENT_NOTYET 21クライアントを取り消されたKDC_ERR_TGT_REVOKED 20取り消され、まだ有効なKDC_ERR_SERVICE_NOTYET 22サーバー後でもう一度やり直し。 KDC_ERR_KEY_EXPIRED 23パスワードの有効期限が切れた後にもう一度お試しください。 24事前認証情報がKDC_ERR_PREAUTH_REQUIRED 25追加の事前認証に必要なKDC_ERR_SERVER_NOMATCH 26要求されたサーバとチケットがuser2userのみKDC_ERR_PATH_NOT_ACCEPTED 28 KDCポリシーは、遷移拒否パスの有効なKDC_ERR_MUST_USE_USER2USER 27サーバープリンシパルと一致しない無効でしたKDC_ERR_PREAUTH_FAILEDをリセットするためにパスワードを変更します"
    },
    {
      "indent": 3,
      "text": "KDC_ERR_SVC_UNAVAILABLE 29 A service is not available KRB_AP_ERR_BAD_INTEGRITY 31 Integrity check on decrypted field failed KRB_AP_ERR_TKT_EXPIRED 32 Ticket expired KRB_AP_ERR_TKT_NYV 33 Ticket not yet valid KRB_AP_ERR_REPEAT 34 Request is a replay KRB_AP_ERR_NOT_US 35 The ticket isn't for us KRB_AP_ERR_BADMATCH 36 Ticket and authenticator don't match KRB_AP_ERR_SKEW 37 Clock skew too great KRB_AP_ERR_BADADDR 38 Incorrect net address KRB_AP_ERR_BADVERSION 39 Protocol version mismatch KRB_AP_ERR_MSG_TYPE 40 Invalid msg type KRB_AP_ERR_MODIFIED 41 Message stream modified KRB_AP_ERR_BADORDER 42 Message out of order KRB_AP_ERR_BADKEYVER 44 Specified version of key is not available KRB_AP_ERR_NOKEY 45 Service key not available KRB_AP_ERR_MUT_FAIL 46 Mutual authentication failed KRB_AP_ERR_BADDIRECTION 47 Incorrect message direction KRB_AP_ERR_METHOD 48 Alternative authentication method required KRB_AP_ERR_BADSEQ 49 Incorrect sequence number in message KRB_AP_ERR_INAPP_CKSUM 50 Inappropriate type of checksum in message KRB_AP_PATH_NOT_ACCEPTED 51 Policy rejects transited path KRB_ERR_RESPONSE_TOO_BIG 52 Response too big for UDP; retry with TCP KRB_ERR_GENERIC 60 Generic error (description in e-text) KRB_ERR_FIELD_TOOLONG 61 Field is too long for this implementation KDC_ERROR_CLIENT_NOT_TRUSTED 62 Reserved for PKINIT KDC_ERROR_KDC_NOT_TRUSTED 63 Reserved for PKINIT KDC_ERROR_INVALID_SIG 64 Reserved for PKINIT KDC_ERR_KEY_TOO_WEAK 65 Reserved for PKINIT KDC_ERR_CERTIFICATE_MISMATCH 66 Reserved for PKINIT KRB_AP_ERR_NO_TGT 67 No TGT available to validate USER-TO-USER KDC_ERR_WRONG_REALM 68 Reserved for future use KRB_AP_ERR_USER_TO_USER_REQUIRED 69 Ticket must be for USER-TO-USER KDC_ERR_CANT_VERIFY_CERTIFICATE 70 Reserved for PKINIT KDC_ERR_INVALID_CERTIFICATE 71 Reserved for PKINIT KDC_ERR_REVOKED_CERTIFICATE 72 Reserved for PKINIT",
      "ja": "KDC_ERR_SVC_UNAVAILABLE 29サービスは33チケットがまだ有効なKRB_AP_ERR_REPEAT 34リクエストチケットは私たちがKRB_AP_ERR_BADMATCH 36チケットとKRB_AP_ERR_SKEWと一致しない認証サーバのない再生KRB_AP_ERR_NOT_US 35ですKRB_AP_ERR_BAD_INTEGRITY 31 KRB_AP_ERR_TKT_EXPIRED 32チケットはKRB_AP_ERR_TKT_NYV有効期限が切れた失敗復号化されたフィールド上の整合性チェックは利用できません37時計はあまりにも偉大なKRB_AP_がERR_BADADDR 38不正なネットアドレスKRB_AP_ERR_BADVERSION 39プロトコルのバージョンの不一致KRB_AP_ERR_MSG_TYPE 40は、無効なMSGタイプKRB_AP_ERR_MODIFIED 41メッセージ・ストリームは、キーの順序KRB_AP_ERR_BADKEYVER 44指定されたバージョンのうちKRB_AP_ERR_BADORDER 42のメッセージが利用可能KRB_AP_ERR_NOKEY 45サービスキーは使用できませんKRB_AP_ERR_MUT_FAIL 46相互認証ではありません修正スキューKRB_AP_ERR_BADDIRECTION 47誤ったメッセージ方向KRB_AP_ERR_METHOD 48代替認証方法は、50不適切KRB_AP_ERR_INAPP_CKSUMメッセージでKRB_AP_ERR_BADSEQ 49誤ったシーケンス番号を必要失敗メッセージKRB_AP_PATH_NOT_ACCEPTED 51ポリシー内のチェックサムのタイプがUDPのためにあまりにも大きな遷移パスKRB_ERR_RESPONSE_TOO_BIG 52レスポンスを拒否。 KRB_ERR_FIELD_TOOLONG 61フィールドがPKINIT KRB_AP_ERR_NO_TGT 67用PKINIT KDC_ERR_CERTIFICATE_MISMATCH 66予約のためのPKINIT KDC_ERR_KEY_TOO_WEAK 65予約のためのPKINIT KDC_ERROR_INVALID_SIG 64予約のためのPKINIT KDC_ERROR_KDC_NOT_TRUSTED 63予約のために、この実装KDC_ERROR_CLIENT_NOT_TRUSTED 62予約のために長すぎるTCP KRB_ERR_GENERICで60一般的なエラー（電子テキストの記述）をリトライ69チケットをKRB_AP_ERR_USER_TO_USER_REQUIRED将来の使用のためにUSER-TO-USER KDC_ERR_WRONG_REALM 68に予約を検証するために利用可能なTGTはPKINITのためPKINIT KDC_ERR_REVOKED_CERTIFICATE 72予約のためのUSER-TO-USER KDC_ERR_CANT_VERIFY_CERTIFICATE PKINIT KDC_ERR_INVALID_CERTIFICATE 71予約済み70予約済みのためである必要があります"
    },
    {
      "indent": 3,
      "text": "KDC_ERR_REVOCATION_STATUS_UNKNOWN 73 Reserved for PKINIT KDC_ERR_REVOCATION_STATUS_UNAVAILABLE 74 Reserved for PKINIT KDC_ERR_CLIENT_NAME_MISMATCH 75 Reserved for PKINIT KDC_ERR_KDC_NAME_MISMATCH 76 Reserved for PKINIT",
      "ja": "PKINITためPKINIT KDC_ERR_KDC_NAME_MISMATCH 76予約のためのPKINIT KDC_ERR_CLIENT_NAME_MISMATCH 75予約のためのPKINIT KDC_ERR_REVOCATION_STATUS_UNAVAILABLE 74予約のためKDC_ERR_REVOCATION_STATUS_UNKNOWN 73留保"
    },
    {
      "indent": 0,
      "text": "8. Interoperability Requirements",
      "section_title": true,
      "ja": "8.相互運用性の要件"
    },
    {
      "indent": 3,
      "text": "Version 5 of the Kerberos protocol supports a myriad of options.\nAmong these are multiple encryption and checksum types; alternative\nencoding schemes for the transited field; optional mechanisms for\npre-authentication; the handling of tickets with no addresses;\noptions for mutual authentication; user-to-user authentication;\nsupport for proxies; the format of realm names; the handling of\nauthorization data; and forwarding, postdating, and renewing tickets.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In order to ensure the interoperability of realms, it is necessary to define a minimal configuration that must be supported by all implementations. This minimal configuration is subject to change as technology does. For example, if at some later date it is discovered that one of the required encryption or checksum algorithms is not secure, it will be replaced.",
      "ja": "レルムの相互運用性を確保するためには、すべての実装によってサポートされなければならない最小限の構成を定義する必要があります。この最小構成では技術がないよう変更されることがあります。後日、それが必要な暗号化またはチェックサムアルゴリズムの一つが安全ではないことを発見された場合、それは置き換えられます。"
    },
    {
      "indent": 0,
      "text": "8.1. Specification 2",
      "section_title": true,
      "ja": "8.1. 仕様2"
    },
    {
      "indent": 3,
      "text": "This section defines the second specification of these options. Implementations which are configured in this way can be said to support Kerberos Version 5 Specification 2 (5.2). Specification 1 (deprecated) may be found in RFC 1510.",
      "ja": "このセクションでは、これらのオプションの第2の仕様を規定します。このように構成されている実装では、Kerberosバージョン5仕様2（5.2）をサポートすると言うことができます。仕様1は、（非推奨）RFC 1510に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "Transport",
      "ja": "輸送"
    },
    {
      "indent": 6,
      "text": "TCP/IP and UDP/IP transport MUST be supported by clients and KDCs claiming conformance to specification 2.",
      "ja": "TCP / IPおよびUDP / IPトランスポートは、仕様2への適合性を主張し、クライアントとのKDCでサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Encryption and Checksum Methods",
      "ja": "暗号化とチェックサムメソッド"
    },
    {
      "indent": 6,
      "text": "The following encryption and checksum mechanisms MUST be supported:",
      "ja": "次の暗号化とチェックサムのメカニズムをサポートしなければなりません。"
    },
    {
      "indent": 6,
      "text": "Encryption: AES256-CTS-HMAC-SHA1-96 [RFC3962] Checksums: HMAC-SHA1-96-AES256 [RFC3962]",
      "ja": "暗号化：AES256-CTS-HMAC-SHA1-96 [RFC3962]チェックサム：HMAC-SHA1-96-AES256 [RFC3962]"
    },
    {
      "indent": 6,
      "text": "Implementations SHOULD support other mechanisms as well, but the additional mechanisms may only be used when communicating with principals known to also support them. The following mechanisms from [RFC3961] and [RFC3962] SHOULD be supported:",
      "ja": "実装は、他のメカニズムをサポートすべきであるだけでなく、それらをサポートすることが知られているプリンシパルと通信するときに、追加の機構にのみ使用することができます。 [RFC3961]及び[RFC3962]から次のメカニズムがサポートされるべきです。"
    },
    {
      "indent": 6,
      "text": "Encryption: AES128-CTS-HMAC-SHA1-96, DES-CBC-MD5, DES3-CBC-SHA1-KD Checksums: DES-MD5, HMAC-SHA1-DES3-KD, HMAC-SHA1-96-AES128",
      "ja": "暗号化：AES128-CTS-HMAC-SHA1-96、DES-CBC-MD5、DES3-CBC-SHA1-KDチェックサム：DES-MD5、HMAC-SHA1-DES3-KD、HMAC-SHA1-96-AES128"
    },
    {
      "indent": 6,
      "text": "Implementations MAY support other mechanisms as well, but the additional mechanisms may only be used when communicating with principals known to support them also.",
      "ja": "実装は、他のメカニズムをサポートし得るが、それらをサポートすることが知られているプリンシパルと通信するときに、追加の機構にのみ使用することができます。"
    },
    {
      "indent": 6,
      "text": "Implementation note: Earlier implementations of Kerberos generate messages using the CRC-32 and RSA-MD5 checksum methods. For interoperability with these earlier releases, implementors MAY consider supporting these checksum methods but should carefully analyze the security implications to limit the situations within which these methods are accepted.",
      "ja": "実装上の注意：ケルベロスの以前の実装では、CRC-32およびRSA-MD5チェックサムメソッドを使用してメッセージを生成します。これらの以前のリリースとの相互運用性のために、実装者は、これらのチェックサムメソッドをサポート考えるかもしれませんが、慎重にこれらのメソッドが受け入れされている範囲内の状況を制限するために、セキュリティ上の影響を分析する必要があります。"
    },
    {
      "indent": 3,
      "text": "Realm Names",
      "ja": "レルム名"
    },
    {
      "indent": 6,
      "text": "All implementations MUST understand hierarchical realms in both the Internet Domain and the X.500 style. When a TGT for an unknown realm is requested, the KDC MUST be able to determine the names of the intermediate realms between the KDCs realm and the requested realm.",
      "ja": "すべての実装は、インターネットドメインとX.500スタイルの両方で階層的なレルムを理解する必要があります。未知のレルムTGTが要求された場合、KDCはKDCのレルムと要求されたレルムとの間の中間レルム名を決定できなければなりません。"
    },
    {
      "indent": 3,
      "text": "Transited Field Encoding",
      "ja": "通過している分野のエンコーディング"
    },
    {
      "indent": 6,
      "text": "DOMAIN-X500-COMPRESS (described in Section 3.3.3.2) MUST be supported. Alternative encodings MAY be supported, but they may only be used when that encoding is supported by ALL intermediate realms.",
      "ja": "DOMAIN-X500-COMPRESS（セクション3.3.3.2を参照）をサポートしなければなりません。代替のエンコーディングをサポートすることができるが、そのエンコーディングはすべての中間レルムによってサポートされているとき、彼らにのみ使用することができます。"
    },
    {
      "indent": 3,
      "text": "Pre-authentication Methods",
      "ja": "事前認証方法"
    },
    {
      "indent": 6,
      "text": "The TGS-REQ method MUST be supported. It is not used on the initial request. The PA-ENC-TIMESTAMP method MUST be supported by clients, but whether it is enabled by default MAY be determined on a realm-by-realm basis. If the method is not used in the initial request and the error KDC_ERR_PREAUTH_REQUIRED is returned specifying PA-ENC-TIMESTAMP as an acceptable method, the client SHOULD retry the initial request using the PA-ENC-TIMESTAMP pre-authentication method. Servers need not support the PA-ENC-TIMESTAMP method, but if it is not supported the server SHOULD ignore the presence of PA-ENC-TIMESTAMP pre-authentication in a request.",
      "ja": "TGS-REQ方式をサポートしなければなりません。これは、最初の要求で使用されていません。 PA-ENC-TIMESTAMP方法は、クライアントがサポートしなければならないが、それはデフォルトで有効になっているかどうかレルムによってレルムに基づいて決定することができます。この方法は、最初の要求とKDC_ERR_PREAUTH_REQUIREDが許容できる方法として、PA-ENC-TIMESTAMPを指定して返されるエラーに使用されていない場合、クライアントはPA-ENC-TIMESTAMP事前認証方式を使用して最初の要求を再試行する必要があります。サーバーは、PA-ENC-TIMESTAMPメソッドをサポートする必要はありませんが、それはサポートされていない場合、サーバーは、要求におけるPA-ENC-TIMESTAMP事前認証の存在を無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "The ETYPE-INFO2 method MUST be supported; this method is used to communicate the set of supported encryption types, and corresponding salt and string to key parameters. The ETYPE-INFO method SHOULD be supported for interoperability with older implementation.",
      "ja": "ETYPE-INFO2方法をサポートしなければなりません。この方法は、重要なパラメータに支持された暗号化タイプのセット、および対応する塩、文字列を通信するために使用されます。 ETYPE  -  INFOメソッドは、古い実装との相互運用性のためにサポートされる必要があります。"
    },
    {
      "indent": 3,
      "text": "Mutual Authentication",
      "ja": "相互認証"
    },
    {
      "indent": 6,
      "text": "Mutual authentication (via the KRB_AP_REP message) MUST be supported.",
      "ja": "（KRB_AP_REPメッセージを介して）相互認証をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Ticket Addresses and Flags",
      "ja": "チケットのアドレスとフラグ"
    },
    {
      "indent": 6,
      "text": "All KDCs MUST pass through tickets that carry no addresses (i.e., if a TGT contains no addresses, the KDC will return derivative tickets). Implementations SHOULD default to requesting addressless tickets, as this significantly increases interoperability with network address translation. In some cases, realms or application servers MAY require that tickets have an address.",
      "ja": "すべてのKDCは（TGTは何のアドレスが含まれていない場合、すなわち、KDC誘導体チケットを返します）何のアドレスを運ばないチケットを通過しなければなりません。これが大幅にネットワークアドレス変換との相互運用性を向上させるよう実装は、アドレスなしチケットを要求をデフォルトとすべきです。いくつかのケースでは、Realmsまたはアプリケーションサーバーはチケットがアドレスを持っていることを要求することができます。"
    },
    {
      "indent": 6,
      "text": "Implementations SHOULD accept directional address type for the KRB_SAFE and KRB_PRIV message and SHOULD include directional addresses in these messages when other address types are not available.",
      "ja": "実装はKRB_SAFEとKRB_PRIVメッセージの方向性アドレスタイプを受け入れるべきと他のアドレスタイプが利用できない場合、これらのメッセージには、方向のアドレスを含むべきです。"
    },
    {
      "indent": 6,
      "text": "Proxies and forwarded tickets MUST be supported. Individual realms and application servers can set their own policy on when such tickets will be accepted.",
      "ja": "プロキシと転送されたチケットをサポートしなければなりません。個々のレルムとアプリケーションサーバーは、そのようなチケットが受理されるときに、独自のポリシーを設定することができます。"
    },
    {
      "indent": 6,
      "text": "All implementations MUST recognize renewable and postdated tickets, but they need not actually implement them. If these options are not supported, the starttime and endtime in the ticket SHALL specify a ticket's entire useful life. When a postdated ticket is decoded by a server, all implementations SHALL make the presence of the postdated flag visible to the calling server.",
      "ja": "すべての実装は、再生可能エネルギーや遅延チケットを認識しなければならないが、彼らは実際にそれらを実装する必要はありません。これらのオプションがサポートされていない場合は、チケットでSTARTTIMEと終了時刻は、チケットの全体の耐用年数を指定しなければなりません。遅延チケットがサーバーによってデコードされると、すべての実装は、呼び出し側サーバーへの先日付フラグの存在が見えなければなりません。"
    },
    {
      "indent": 3,
      "text": "User-to-User Authentication",
      "ja": "ユーザ対ユーザ認証"
    },
    {
      "indent": 6,
      "text": "Support for user-to-user authentication (via the ENC-TKT-IN-SKEY KDC option) MUST be provided by implementations, but individual realms MAY decide as a matter of policy to reject such requests on a per-principal or realm-wide basis.",
      "ja": "（ENC-TKT-IN-SKEY KDCオプションを経由して）ユーザ間の認証のサポートは、実装によって提供されている必要がありますが、個々のレルムごとの元本またはレルムワイドの上、このような要求を拒否するためのポリシーの問題として判断してもよいです基礎。"
    },
    {
      "indent": 3,
      "text": "Authorization Data",
      "ja": "認可データ"
    },
    {
      "indent": 6,
      "text": "Implementations MUST pass all authorization data subfields from TGTs to any derivative tickets unless they are directed to suppress a subfield as part of the definition of that registered subfield type. (It is never incorrect to pass on a subfield, and no registered subfield types presently specify suppression at the KDC.)",
      "ja": "それらはその登録サブフィールドタイプの定義の一部としてサブフィールドを抑制するように指示されない限り、実装は任意の誘導体チケットへのTGTからすべての許可データサブフィールドを通過しなければなりません。 （サブフィールドに渡すことは決して間違っている、と何も登録されたサブフィールドの種類は、現在KDCで抑制を指定しません。）"
    },
    {
      "indent": 6,
      "text": "Implementations MUST make the contents of any authorization data subfields available to the server when a ticket is used. Implementations are not required to allow clients to specify the contents of the authorization data fields.",
      "ja": "チケットを使用する場合、実装は、サーバーへの認証データのサブフィールドの内容を利用できるようにしなければなりません。実装は、クライアントが認証データフィールドの内容を指定することを可能にする必要はありません。"
    },
    {
      "indent": 3,
      "text": "Constant Ranges",
      "ja": "一定の範囲"
    },
    {
      "indent": 6,
      "text": "All protocol constants are constrained to 32-bit (signed) values unless further constrained by the protocol definition. This limit is provided to allow implementations to make assumptions about the maximum values that will be received for these constants. Implementations receiving values outside this range MAY reject the request, but they MUST recover cleanly.",
      "ja": "さらに、プロトコル定義によって拘束されない限り、すべてのプロトコル定数は、32ビット（符号付き）の値に制約されています。この制限は、実装は、これらの定数のために受信された最大値に関する仮定を行うことを可能にするために提供されます。この範囲外の値を受け取る実装は、要求を拒否するかもしれないが、彼らはきれいに回復しなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.2. Recommended KDC Values",
      "section_title": true,
      "ja": "8.2. 推奨されるKDC値"
    },
    {
      "indent": 3,
      "text": "Following is a list of recommended values for a KDC configuration.",
      "ja": "以下は、KDCの設定の推奨値の一覧です。"
    },
    {
      "indent": 6,
      "text": "Minimum lifetime 5 minutes Maximum renewable lifetime 1 week Maximum ticket lifetime 1 day Acceptable clock skew 5 minutes Empty addresses Allowed Proxiable, etc. Allowed",
      "ja": "最小寿命5分最大再生可能寿命1週間の最大チケット有効期間1日の許容クロック・スキュー5分の空のアドレス等、PROXIABLE可可"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Section 7 of this document specifies protocol constants and other defined values required for the interoperability of multiple implementations. Until a subsequent RFC specifies otherwise, or the Kerberos working group is shut down, allocations of additional protocol constants and other defined values required for extensions to the Kerberos protocol will be administered by the Kerberos working group. Following the recommendations outlined in [RFC2434], guidance is provided to the IANA as follows:",
      "ja": "このドキュメントのセクション7はプロトコル定数と複数の実装の相互運用性のために必要な他の定義された値を指定します。その後のRFCは別段指定、またはKerberosワーキンググループがシャットダウンされるまで、追加のプロトコル定数とKerberosプロトコルの拡張に必要な他の定義された値の割り当ては、Kerberosワーキンググループによって投与されます。 [RFC2434]に概説され勧告に続いて、ガイダンスは、次のようにIANAに提供されています。"
    },
    {
      "indent": 3,
      "text": "\"reserved\" realm name types in Section 6.1 and \"other\" realm types except those beginning with \"X-\" or \"x-\" will not be registered without IETF standards action, at which point guidelines for further assignment will be specified. Realm name types beginning with \"X-\" or \"x-\" are for private use.",
      "ja": "6.1節および「X-」または「X-」で始まるものを除く「その他」分野の種類で「予約」レルム名の種類は、さらに割り当てのためのポイントのガイドラインが指定される時に、IETF標準化アクションなしで登録されません。 「X-」または「X-」で始まるレルム名の種類は、私的使用のためのものです。"
    },
    {
      "indent": 3,
      "text": "For host address types described in Section 7.1, negative values are for private use. Assignment of additional positive numbers is subject to review by the Kerberos working group or other expert review.",
      "ja": "7.1節で説明したホストアドレスのタイプについては、負の値は、私的使用のためのものです。追加の正の数の割り当ては、Kerberosワーキンググループや他の専門家レビューによる審査の対象です。"
    },
    {
      "indent": 3,
      "text": "Additional key usage numbers, as defined in Section 7.5.1, will be assigned subject to review by the Kerberos working group or other expert review.",
      "ja": "追加の鍵の使用番号は、7.5.1項で定義されるように、ケルベロスワーキンググループや他の専門家レビューによる審査の対象に割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Additional preauthentication data type values, as defined in section 7.5.2, will be assigned subject to review by the Kerberos working group or other expert review.",
      "ja": "追加の事前認証データ型の値は、セクション7.5.2で定義されているように、ケルベロスワーキンググループや他の専門家レビューによる審査の対象に割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Additional authorization data types as defined in Section 7.5.4, will be assigned subject to review by the Kerberos working group or other expert review. Although it is anticipated that there may be significant demand for private use types, provision is intentionally not made for a private use portion of the namespace because conflicts between privately assigned values could have detrimental security implications.",
      "ja": "第7.5.4項で定義されている追加の許可のデータ型は、ケルベロスワーキンググループや他の専門家レビューによる審査を受ける割り当てられます。私的使用のタイプのための重要な需要があるかもしれないことが予想されるが、個人的に割り当てられた値との間に矛盾が有害なセキュリティへの影響を持っている可能性があるため、引当金は意図的に名前空間の私的使用部分のために作られていません。"
    },
    {
      "indent": 3,
      "text": "Additional transited encoding types, as defined in Section 7.5.5, present special concerns for interoperability with existing implementations. As such, such assignments will only be made by standards action, except that the Kerberos working group or another other working group with competent jurisdiction may make preliminary assignments for documents that are moving through the standards process.",
      "ja": "第7.5.5項で定義されている追加の遷移符号化タイプ、既存の実装との相互運用性のために存在特別な懸念。そのため、そのような割り当ては唯一のKerberosワーキンググループまたは管轄権を持つ別の他のワーキンググループは、標準化プロセスを通じて移動する文書のための予備的な割り当てを行うことができることを除いて、標準のアクションによって行われます。"
    },
    {
      "indent": 3,
      "text": "Additional Kerberos message types, as described in Section 7.5.7, will be assigned subject to review by the Kerberos working group or other expert review.",
      "ja": "追加のケルベロスメッセージタイプは、7.5.7項で説明したように、ケルベロスワーキンググループや他の専門家レビューによる審査の対象に割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Additional name types, as described in Section 7.5.8, will be assigned subject to review by the Kerberos working group or other expert review.",
      "ja": "追加の名前タイプは、7.5.8項で説明したように、ケルベロスワーキンググループや他の専門家レビューによる審査の対象に割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Additional error codes described in Section 7.5.9 will be assigned subject to review by the Kerberos working group or other expert review.",
      "ja": "セクション7.5.9で説明した追加のエラーコードは、Kerberosワーキンググループや他の専門家レビューによる審査を受ける割り当てられます。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "As an authentication service, Kerberos provides a means of verifying the identity of principals on a network. By itself, Kerberos does not provide authorization. Applications should not accept the issuance of a service ticket by the Kerberos server as granting authority to use the service, since such applications may become vulnerable to the bypass of this authorization check in an environment where they inter-operate with other KDCs or where other options for application authentication are provided.",
      "ja": "認証サービスとして、Kerberosは、ネットワーク上のプリンシパルの身元を確認する手段を提供します。自分自身では、Kerberosは、認証を提供していません。このようなアプリケーションは、彼らが他のKDCまたは他のオプションと相互運用環境では、この承認チェックのバイパスに対して脆弱になる可能性があるためアプリケーションは、サービスを使用する権限を付与するようKerberosサーバによるサービスチケットの発行を受け入れるべきではありませんアプリケーション認証のために提供されています。"
    },
    {
      "indent": 3,
      "text": "Denial of service attacks are not solved with Kerberos. There are places in the protocols where an intruder can prevent an application from participating in the proper authentication steps. Because authentication is a required step for the use of many services, successful denial of service attacks on a Kerberos server might result in the denial of other network services that rely on Kerberos for authentication. Kerberos is vulnerable to many kinds of denial of service attacks: those on the network, which would prevent clients from contacting the KDC; those on the domain name system, which could prevent a client from finding the IP address of the Kerberos server; and those by overloading the Kerberos KDC itself with repeated requests.",
      "ja": "サービス妨害攻撃はケルベロスで解決されていません。侵入者が適切な認証手順に参加するアプリケーションを防ぐことができますプロトコルでの場所があります。認証は多くのサービスを使用するために必要なステップですので、Kerberosサーバ上のサービス攻撃の成功の拒否は、認証にKerberosに依存している他のネットワークサービス拒否が発生する可能性があります。 Kerberosは、サービス拒否攻撃の多くの種類に対して脆弱である：ネットワーク上のもの、KDCとの接触からクライアントを防止するであろう。 KerberosサーバのIPアドレスを見つけることからクライアントを防ぐことができるドメインネームシステム、上のもの。そして再三の要求でKerberos KDC自体に過負荷をかけることによって、それらの。"
    },
    {
      "indent": 3,
      "text": "Interoperability conflicts caused by incompatible character-set usage (see 5.2.1) can result in denial of service for clients that utilize character-sets in Kerberos strings other than those stored in the KDC database.",
      "ja": "互換性のない文字セットの使用によって生じた相互運用性の競合が（5.2.1を参照）KDCデータベースに保存されているもの以外のKerberosの文字列に文字セットを使用するクライアントのためにサービス拒否が発生することができます。"
    },
    {
      "indent": 3,
      "text": "Authentication servers maintain a database of principals (i.e., users and servers) and their secret keys. The security of the authentication server machines is critical. The breach of security of an authentication server will compromise the security of all servers that rely upon the compromised KDC, and will compromise the authentication of any principals registered in the realm of the compromised KDC.",
      "ja": "認証サーバーは、プリンシパル（つまり、ユーザーとサーバー）とその秘密鍵のデータベースを維持します。認証サーバー・マシンのセキュリティが重要です。認証サーバのセキュリティ違反が損なわKDCに依存しているすべてのサーバーのセキュリティを侵害し、妥協しKDCの領域に登録されているすべてのプリンシパルの認証を危うくします。"
    },
    {
      "indent": 3,
      "text": "Principals must keep their secret keys secret. If an intruder somehow steals a principal's key, it will be able to masquerade as that principal or impersonate any server to the legitimate principal.",
      "ja": "プリンシパルは秘密自分の秘密鍵を保持する必要があります。侵入者がどうにかプリンシパルの鍵を盗んだ場合は、その元本のふりまたは正当な主体に任意のサーバを偽装することができます。"
    },
    {
      "indent": 3,
      "text": "Password-guessing attacks are not solved by Kerberos. If a user chooses a poor password, it is possible for an attacker to successfully mount an off-line dictionary attack by repeatedly attempting to decrypt, with successive entries from a dictionary, messages obtained that are encrypted under a key derived from the user's password.",
      "ja": "パスワード推測攻撃はケルベロスによって解決されていません。ユーザーが悪いパスワードを選択した場合、攻撃者が繰り返しユーザーのパスワード由来の鍵で暗号化されている辞書からの連続したエントリ、取得したメッセージと、解読しようとすることで、オフライン辞書攻撃をすることが可能です。"
    },
    {
      "indent": 3,
      "text": "Unless pre-authentication options are required by the policy of a realm, the KDC will not know whether a request for authentication succeeds. An attacker can request a reply with credentials for any principal. These credentials will likely not be of much use to the attacker unless it knows the client's secret key, but the availability of the response encrypted in the client's secret key provides the attacker with ciphertext that may be used to mount brute force or dictionary attacks to decrypt the credentials, by guessing the user's password. For this reason it is strongly encouraged that Kerberos realms require the use of pre-authentication. Even with pre-authentication, attackers may try brute force or dictionary attacks against credentials that are observed by eavesdropping on the network.",
      "ja": "事前認証オプションは、領域の方針によって必要とされる場合を除き、KDCは、認証要求が成功したかどうかを知ることができません。攻撃者が任意のプリンシパルの資格情報を使用して応答を要求することができます。それは、クライアントの秘密鍵を知っているが、クライアントの秘密鍵で暗号化された応答の可用性を復号化するためにブルートフォースや辞書攻撃をマウントするために使用される暗号文を攻撃者を提供しない限り、これらの資格情報は、可能性が攻撃者に多くの使用ではありませんユーザーのパスワードを推測することにより資格情報、。このような理由から、強くケルベロスレルムが事前認証の使用を必要とすることを奨励しています。でも、事前認証で、攻撃者がネットワーク上の盗聴によって観察された資格情報に対するブルートフォースや辞書攻撃をしようとします。"
    },
    {
      "indent": 3,
      "text": "Because a client can request a ticket for any server principal and can attempt a brute force or dictionary attack against the server principal's key using that ticket, it is strongly encouraged that keys be randomly generated (rather than generated from passwords) for any principals that are usable as the target principal for a KRB_TGS_REQ or KRB_AS_REQ messages. [RFC4086]",
      "ja": "クライアントがサーバープリンシパルのチケットを要求し、そのチケットを使用してサーバのプリンシパルのキーに対してブルートフォースや辞書攻撃を試みることができ、キーがランダムに生成されることを強く推奨されているので（パスワードから生成されるのではなく）されているすべてのプリンシパルのためにKRB_TGS_REQ又はKRB_AS_REQメッセージのターゲット・プリンシパルとして使用できます。 [RFC4086]"
    },
    {
      "indent": 3,
      "text": "Although the DES-CBC-MD5 encryption method and DES-MD5 checksum methods are listed as SHOULD be implemented for backward compatibility, the single DES encryption algorithm on which these are based is weak, and stronger algorithms should be used whenever possible.",
      "ja": "DES-CBC-MD5暗号化方式とDES-MD5チェックサム方法は下位互換性のために実装されるべきであるとして記載されているが、これらの基礎となる単一のDES暗号化アルゴリズムは弱く、より強力なアルゴリズムが可能な限り使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Each host on the network must have a clock that is loosely synchronized to the time of the other hosts; this synchronization is used to reduce the bookkeeping needs of application servers when they do replay detection. The degree of \"looseness\" can be configured on a per-server basis, but it is typically on the order of 5 minutes. If the clocks are synchronized over the network, the clock synchronization protocol MUST itself be secured from network attackers.",
      "ja": "ネットワーク上の各ホストは緩く、他のホストの時刻に同期したクロックを持っている必要があります。この同期は、彼らがリプレイ検出を行う際に、アプリケーションサーバーの簿記の必要性を低減するために使用されます。 「ゆるみ」の程度は、サーバ単位で設定することができますが、それは5分程度であるのが典型的です。クロックがネットワーク経由で同期されている場合は、クロック同期プロトコル自体は、ネットワーク攻撃から保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "Principal identifiers must not recycled on a short-term basis. A typical mode of access control will use access control lists (ACLs) to grant permissions to particular principals. If a stale ACL entry remains for a deleted principal and the principal identifier is reused, the new principal will inherit rights specified in the stale ACL entry. By not reusing principal identifiers, the danger of inadvertent access is removed.",
      "ja": "主要な識別子は短期的にリサイクルしてはいけません。アクセス制御の典型的なモードは、特定のプリンシパルに権限を付与するアクセス制御リスト（ACL）を使用します。古くなったACLエントリが削除されたプリンシパルのままで、主要な識別子が再利用されている場合は、新しいプリンシパルは、古いACLエントリで指定された権限を継承します。主要な識別子を再利用しないことにより、不用意なアクセスの危険性が取り除かれます。"
    },
    {
      "indent": 3,
      "text": "Proper decryption of an KRB_AS_REP message from the KDC is not sufficient for the host to verify the identity of the user; the user and an attacker could cooperate to generate a KRB_AS_REP format message that decrypts properly but is not from the proper KDC. To authenticate a user logging on to a local system, the credentials obtained in the AS exchange may first be used in a TGS exchange to obtain credentials for a local server. Those credentials must then be verified by a local server through successful completion of the Client/Server exchange.",
      "ja": "ホストは、ユーザの身元を確認するためにKDCからKRB_AS_REPメッセージの適切な復号化は十分ではありません。ユーザと攻撃者が適切に復号化が、適切なKDCからのものではないKRB_AS_REP形式のメッセージを生成するために協働することができました。ローカルシステムにログオンするユーザを認証するために、AS交換で得られた資格情報は、最初のローカル・サーバの資格を得るためTGS交換に使用することができます。これらの資格情報は、クライアント/サーバ交換が正常に完了して、ローカルサーバによって検証されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Many RFC 1510-compliant implementations ignore unknown authorization data elements. Depending on these implementations to honor authorization data restrictions may create a security weakness.",
      "ja": "多くのRFC 1510に準拠した実装は、未知の承認データ要素を無視します。認証データの制限を尊重するために、これらの実装によってはセキュリティ上の弱点を作成することができます。"
    },
    {
      "indent": 3,
      "text": "Kerberos credentials contain clear-text information identifying the principals to which they apply. If privacy of this information is needed, this exchange should itself be encapsulated in a protocol providing for confidentiality on the exchange of these credentials.",
      "ja": "Kerberos証明書は、それらが適用されるプリンシパルを識別するクリアテキストの情報が含まれています。この情報のプライバシーが必要な場合は、この交換は、それ自体は、これらの資格情報の交換に機密性を提供するプロトコルでカプセル化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Applications must take care to protect communications subsequent to authentication, either by using the KRB_PRIV or KRB_SAFE messages as appropriate, or by applying their own confidentiality or integrity mechanisms on such communications. Completion of the KRB_AP_REQ and KRB_AP_REP exchange without subsequent use of confidentiality and integrity mechanisms provides only for authentication of the parties to the communication and not confidentiality and integrity of the subsequent communication. Applications applying confidentiality and integrity protection mechanisms other than KRB_PRIV and KRB_SAFE must make sure that the authentication step is appropriately linked with the protected communication channel that is established by the application.",
      "ja": "アプリケーションは、いずれかの適切なKRB_PRIVまたはKRB_SAFEメッセージを使用することによって、またはそのような通信上の自分の機密性や整合性のメカニズムを適用することにより、認証後に通信を保護するために注意しなければなりません。機密性と完全性メカニズムのその後の使用せずにKRB_AP_REQとKRB_AP_REP交換の完了は、その後の通信の通信ではなく機密性と完全性への当事者の認証を提供します。 KRB_PRIVとKRB_SAFE以外の機密性と完全性の保護メカニズムを適用するアプリケーションは、認証ステップが適切にアプリケーションによって確立され保護された通信チャネルとリンクされていることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Unless the application server provides its own suitable means to protect against replay (for example, a challenge-response sequence initiated by the server after authentication, or use of a server-generated encryption subkey), the server must utilize a replay cache to remember any authenticator presented within the allowable clock skew. All services sharing a key need to use the same replay cache. If separate replay caches are used, then an authenticator used with one such service could later be replayed to a different service with the same service principal.",
      "ja": "アプリケーションサーバはリプレイから保護するために、独自の適切な手段を提供しない限り（例えば、チャレンジレスポンスシーケンスが認証した後、サーバ、またはサーバが生成した暗号化サブキーを使用することにより開始される）、サーバーは、任意のを覚えてリプレイキャッシュを利用しなければなりませんオーセンティケータは、許容できる時計斜行の中に提示しました。キーを共有するすべてのサービスが同じリプレイキャッシュを使用する必要があります。別リプレイ・キャッシュが使用される場合、そのようなサービスを使用するオーセンティケータは、後で同じサービス主体とは異なるサービスに再生することができます。"
    },
    {
      "indent": 3,
      "text": "If a server loses track of authenticators presented within the allowable clock skew, it must reject all requests until the clock skew interval has passed, providing assurance that any lost or replayed authenticators will fall outside the allowable clock skew and can no longer be successfully replayed.",
      "ja": "サーバが許容できる時計斜行の中に提示し認証子のトラックを失った場合、クロックスキュー期間が経過するまで、それが失われたか、再生のオーセンティケータが許容クロック・スキューの範囲外になると、もはや、正常に再生できないことを保証を提供し、すべての要求を拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Implementations of Kerberos should not use untrusted directory servers to determine the realm of a host. To allow this would allow the compromise of the directory server to enable an attacker to direct the client to accept authentication with the wrong principal (i.e., one with a similar name, but in a realm with which the legitimate host was not registered).",
      "ja": "ケルベロスの実装はホストのレルムを決定するために信頼されていないディレクトリサーバーを使用しないでください。これは間違ったプリンシパルに認証を受け入れるようにクライアントを指示する攻撃を可能にするために、ディレクトリサーバの妥協を可能にできるようにするために（すなわち、類似した名前の1が、正当なホストが登録されなかったとの分野で）。"
    },
    {
      "indent": 3,
      "text": "Implementations of Kerberos must not use DNS to map one name to another (canonicalize) in order to determine the host part of the principal name with which one is to communicate. To allow this canonicalization would allow a compromise of the DNS to result in a client obtaining credentials and correctly authenticating to the wrong principal. Though the client will know who it is communicating with, it will not be the principal with which it intended to communicate.",
      "ja": "ケルベロスの実装は、一つが通信するプリンシパル名のホスト部分を決定するために、別の（カノニカル化）1つの名前をマップするためにDNSを使用してはなりません。できるようにするには、この正規化は、DNSの妥協が資格情報を取得し、正しく間違ったプリンシパルに認証クライアントをもたらすことができるようになります。クライアントは、それが通信しているかを知るでしょうけれども、それが通信することを目的とされて元本ではありません。"
    },
    {
      "indent": 3,
      "text": "If the Kerberos server returns a TGT for a realm 'closer' than the desired realm, the client may use local policy configuration to verify that the authentication path used is an acceptable one. Alternatively, a client may choose its own authentication path rather than rely on the Kerberos server to select one. In either case, any policy or configuration information used to choose or validate authentication paths, whether by the Kerberos server or client, must be obtained from a trusted source.",
      "ja": "Kerberosサーバが所望の領域よりも「より近い」レルムのTGTを返した場合、クライアントは、使用される認証パスは許容されるものであることを確認するために、ローカルポリシー設定を使用してもよいです。また、クライアントは、独自の認証パスを選択するのではなく1を選択するために、Kerberosサーバに依存してもよいです。いずれの場合においても、選択するか、認証パスを検証するために使用される任意のポリシーまたは設定情報は、Kerberosサーバまたはクライアントによってかどうか、信頼できるソースから取得されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocol in its basic form does not provide perfect forward secrecy for communications. If traffic has been recorded by an eavesdropper, then messages encrypted using the KRB_PRIV message, or messages encrypted using application-specific encryption under keys exchanged using Kerberos can be decrypted if the user's, application server's, or KDC's key is subsequently discovered. This is because the session key used to encrypt such messages, when transmitted over the network, is encrypted in the key of the application server. It is also encrypted under the session key from the user's TGT when it is returned to the user in the KRB_TGS_REP message. The session key from the TGT is sent to the user in the KRB_AS_REP message encrypted in the user's secret key and embedded in the TGT, which was encrypted in the key of the KDC. Applications requiring perfect forward secrecy must exchange keys through mechanisms that provide such assurance, but may use Kerberos for authentication of the encrypted channel established through such other means.",
      "ja": "その基本的な形でのKerberosプロトコルは、通信のための完全な前進の秘密保持を提供していません。トラフィックが盗聴者によって記録されている場合、メッセージがKRB_PRIVメッセージを使用して暗号化、またはメッセージがキーの下に、アプリケーション固有の暗号化を使用して暗号化使用して交換Kerberosは、ユーザの、アプリケーション・サーバーの場合、復号化することができ、またはKDCのキーはその後発見されました。ネットワークを介して送信する場合、このようなメッセージを暗号化するために使用されるセッションキーは、アプリケーションサーバの鍵で暗号化されているためです。それはKRB_TGS_REPメッセージでユーザーに返されたときにも、ユーザーのTGTからセッションキーの下で暗号化されています。 TGTからのセッションキーはKDCの鍵で暗号化されたKRB_AS_REPメッセージ、ユーザの秘密鍵で暗号化し、TGTに埋め込まれ、ユーザーに送信されます。完全転送秘密を必要とするアプリケーションには、このような保証を提供するメカニズムを介して鍵を交換しなければならないが、そのような他の手段を通じて確立暗号化チャネルの認証にKerberosを使用することができます。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "ja": "11.謝辞"
    },
    {
      "indent": 3,
      "text": "This document is a revision to RFC 1510 which was co-authored with John Kohl. The specification of the Kerberos protocol described in this document is the result of many years of effort. Over this period, many individuals have contributed to the definition of the protocol and to the writing of the specification. Unfortunately, it is not possible to list all contributors as authors of this document, though there are many not listed who are authors in spirit, including those who contributed text for parts of some sections, who contributed to the design of parts of the protocol, and who contributed significantly to the discussion of the protocol in the IETF common authentication technology (CAT) and Kerberos working groups.",
      "ja": "この文書では、ジョン・コールズとの共著たRFC 1510に改訂したものです。このドキュメントで説明するKerberosプロトコルの仕様は、努力の多くの年の結果です。この期間に、多くの個人は、プロトコルの定義に、仕様の執筆に貢献してきました。プロトコルの部品の設計に貢献したいくつかのセクションの部品のためのテキストを寄付者を含む精神で著者は、誰であるかに記載されていない多くありますが残念ながら、それは、この文書の著者として全ての貢献者のリストを表示することができず、誰がIETF共通認証技術（CAT）でのプロトコルとケルベロスワーキンググループの議論に大きく貢献しました。"
    },
    {
      "indent": 3,
      "text": "Among those contributing to the development and specification of Kerberos were Jeffrey Altman, John Brezak, Marc Colan, Johan Danielsson, Don Davis, Doug Engert, Dan Geer, Paul Hill, John Kohl, Marc Horowitz, Matt Hur, Jeffrey Hutzelman, Paul Leach, John Linn, Ari Medvinsky, Sasha Medvinsky, Steve Miller, Jon Rochlis, Jerome Saltzer, Jeffrey Schiller, Jennifer Steiner, Ralph Swick, Mike Swift, Jonathan Trostle, Theodore Ts'o, Brian Tung, Jacques Vidrine, Assar Westerlund, and Nicolas Williams. Many other members of MIT Project Athena, the MIT networking group, and the Kerberos and CAT working groups of the IETF contributed but are not listed.",
      "ja": "ケルベロスの開発や仕様にジェフリー・アルトマン、ジョンBrezak、マルク・Colan、ヨハン・ダニエルソン、ドン・デイビス、ダグEngert、ダン・ギア、ポール・ヒル、ジョン・コールズ、マーク・ホロウィッツ、マット・ハー、ジェフリーHutzelman、ポールリーチを寄与したもののうち、ジョン・リン、アリMedvinsky、サーシャMedvinsky、スティーブ・ミラー、ジョンRochlis、ジェロームSaltzer、ジェフリーシラー、ジェニファー・シュタイナー、ラルフ・スウィック、マイク・スウィフト、ジョナサンTrostle、セオドア・ツォー、ブライアン・トゥン、ジャック・Vidrine、Assarウェスター、そしてニコラス・ウィリアムズ。 MIT Athenaプロジェクト、MITのネットワーキンググループ、およびKerberosとIETFのCATワーキンググループの他の多くのメンバーが貢献したが、記載されていません。"
    },
    {
      "indent": 0,
      "text": "A. ASN.1 module",
      "ja": "A. ASN.1モジュール"
    },
    {
      "indent": 0,
      "text": "KerberosV5Spec2 {\n        iso(1) identified-organization(3) dod(6) internet(1)\n        security(5) kerberosV5(2) modules(4) krb5spec2(2)\n} DEFINITIONS EXPLICIT TAGS ::= BEGIN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- OID arc for KerberosV5\n--\n-- This OID may be used to identify Kerberos protocol messages\n-- encapsulated in other protocols.\n--\n-- This OID also designates the OID arc for KerberosV5-related OIDs.\n--\n-- NOTE: RFC 1510 had an incorrect value (5) for \"dod\" in its OID.\nid-krb5         OBJECT IDENTIFIER ::= {\n        iso(1) identified-organization(3) dod(6) internet(1)\n        security(5) kerberosV5(2)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Int32           ::= INTEGER (-2147483648..2147483647)\n                    -- signed values representable in 32 bits",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "UInt32          ::= INTEGER (0..4294967295)\n                    -- unsigned 32 bit values",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Microseconds    ::= INTEGER (0..999999)\n                    -- microseconds",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KerberosString  ::= GeneralString (IA5String)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Realm           ::= KerberosString",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PrincipalName   ::= SEQUENCE {\n        name-type       [0] Int32,\n        name-string     [1] SEQUENCE OF KerberosString\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KerberosTime    ::= GeneralizedTime -- with no fractional seconds",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "HostAddress     ::= SEQUENCE  {\n        addr-type       [0] Int32,\n        address         [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- NOTE: HostAddresses is always used as an OPTIONAL field and -- should not be empty. HostAddresses -- NOTE: subtly different from rfc1510,",
      "ja": " - 注：HostAddressesは常にオプションフィールドとして使用されていると - 空であってはなりません。 HostAddresses  - 注：RFC1510から微妙に異なります、"
    },
    {
      "indent": 8,
      "text": "        -- but has a value mapping and encodes the same\n::= SEQUENCE OF HostAddress",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- NOTE: AuthorizationData is always used as an OPTIONAL field and\n-- should not be empty.\nAuthorizationData       ::= SEQUENCE OF SEQUENCE {\n        ad-type         [0] Int32,\n        ad-data         [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PA-DATA         ::= SEQUENCE {\n        -- NOTE: first tag is [1], not [0]\n        padata-type     [1] Int32,\n        padata-value    [2] OCTET STRING -- might be encoded AP-REQ\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KerberosFlags   ::= BIT STRING (SIZE (32..MAX))\n                    -- minimum number of bits shall be sent,\n                    -- but no fewer than 32",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncryptedData   ::= SEQUENCE {\n        etype   [0] Int32 -- EncryptionType --,\n        kvno    [1] UInt32 OPTIONAL,\n        cipher  [2] OCTET STRING -- ciphertext\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncryptionKey   ::= SEQUENCE {\n        keytype         [0] Int32 -- actually encryption type --,\n        keyvalue        [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Checksum        ::= SEQUENCE {\n        cksumtype       [0] Int32,\n        checksum        [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Ticket          ::= [APPLICATION 1] SEQUENCE {\n        tkt-vno         [0] INTEGER (5),\n        realm           [1] Realm,\n        sname           [2] PrincipalName,\n        enc-part        [3] EncryptedData -- EncTicketPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Encrypted part of ticket\nEncTicketPart   ::= [APPLICATION 3] SEQUENCE {\n        flags                   [0] TicketFlags,\n        key                     [1] EncryptionKey,\n        crealm                  [2] Realm, cname                   [3] PrincipalName,\n        transited               [4] TransitedEncoding,\n        authtime                [5] KerberosTime,\n        starttime               [6] KerberosTime OPTIONAL,\n        endtime                 [7] KerberosTime,\n        renew-till              [8] KerberosTime OPTIONAL,\n        caddr                   [9] HostAddresses OPTIONAL,\n        authorization-data      [10] AuthorizationData OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- encoded Transited field\nTransitedEncoding       ::= SEQUENCE {\n        tr-type         [0] Int32 -- must be registered --,\n        contents        [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "TicketFlags     ::= KerberosFlags\n        -- reserved(0),\n        -- forwardable(1),\n        -- forwarded(2),\n        -- proxiable(3),\n        -- proxy(4),\n        -- may-postdate(5),\n        -- postdated(6),\n        -- invalid(7),\n        -- renewable(8),\n        -- initial(9),\n        -- pre-authent(10),\n        -- hw-authent(11),\n-- the following are new since 1510\n        -- transited-policy-checked(12),\n        -- ok-as-delegate(13)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AS-REQ          ::= [APPLICATION 10] KDC-REQ",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "TGS-REQ         ::= [APPLICATION 12] KDC-REQ",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDC-REQ         ::= SEQUENCE {\n        -- NOTE: first tag is [1], not [0]\n        pvno            [1] INTEGER (5) ,\n        msg-type        [2] INTEGER (10 -- AS -- | 12 -- TGS --),\n        padata          [3] SEQUENCE OF PA-DATA OPTIONAL\n                            -- NOTE: not empty --,\n        req-body        [4] KDC-REQ-BODY\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDC-REQ-BODY    ::= SEQUENCE {\n        kdc-options             [0] KDCOptions, cname                   [1] PrincipalName OPTIONAL\n                                    -- Used only in AS-REQ --,\n        realm                   [2] Realm\n                                    -- Server's realm\n                                    -- Also client's in AS-REQ --,\n        sname                   [3] PrincipalName OPTIONAL,\n        from                    [4] KerberosTime OPTIONAL,\n        till                    [5] KerberosTime,\n        rtime                   [6] KerberosTime OPTIONAL,\n        nonce                   [7] UInt32,\n        etype                   [8] SEQUENCE OF Int32 -- EncryptionType\n                                    -- in preference order --,\n        addresses               [9] HostAddresses OPTIONAL,\n        enc-authorization-data  [10] EncryptedData OPTIONAL\n                                    -- AuthorizationData --,\n        additional-tickets      [11] SEQUENCE OF Ticket OPTIONAL\n                                        -- NOTE: not empty\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDCOptions      ::= KerberosFlags\n        -- reserved(0),\n        -- forwardable(1),\n        -- forwarded(2),\n        -- proxiable(3),\n        -- proxy(4),\n        -- allow-postdate(5),\n        -- postdated(6),\n        -- unused7(7),\n        -- renewable(8),\n        -- unused9(9),\n        -- unused10(10),\n        -- opt-hardware-auth(11),\n        -- unused12(12),\n        -- unused13(13),\n-- 15 is reserved for canonicalize\n        -- unused15(15),\n-- 26 was unused in 1510\n        -- disable-transited-check(26),\n--\n        -- renewable-ok(27),\n        -- enc-tkt-in-skey(28),\n        -- renew(30),\n        -- validate(31)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AS-REP          ::= [APPLICATION 11] KDC-REP",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "TGS-REP         ::= [APPLICATION 13] KDC-REP",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDC-REP         ::= SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (11 -- AS -- | 13 -- TGS --),\n        padata          [2] SEQUENCE OF PA-DATA OPTIONAL\n                                -- NOTE: not empty --,\n        crealm          [3] Realm,\n        cname           [4] PrincipalName,\n        ticket          [5] Ticket,\n        enc-part        [6] EncryptedData\n                                -- EncASRepPart or EncTGSRepPart,\n                                -- as appropriate\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncASRepPart    ::= [APPLICATION 25] EncKDCRepPart",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncTGSRepPart   ::= [APPLICATION 26] EncKDCRepPart",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncKDCRepPart   ::= SEQUENCE {\n        key             [0] EncryptionKey,\n        last-req        [1] LastReq,\n        nonce           [2] UInt32,\n        key-expiration  [3] KerberosTime OPTIONAL,\n        flags           [4] TicketFlags,\n        authtime        [5] KerberosTime,\n        starttime       [6] KerberosTime OPTIONAL,\n        endtime         [7] KerberosTime,\n        renew-till      [8] KerberosTime OPTIONAL,\n        srealm          [9] Realm,\n        sname           [10] PrincipalName,\n        caddr           [11] HostAddresses OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "LastReq         ::=     SEQUENCE OF SEQUENCE {\n        lr-type         [0] Int32,\n        lr-value        [1] KerberosTime\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AP-REQ          ::= [APPLICATION 14] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (14),\n        ap-options      [2] APOptions,\n        ticket          [3] Ticket,\n        authenticator   [4] EncryptedData -- Authenticator\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "APOptions       ::= KerberosFlags\n        -- reserved(0),\n        -- use-session-key(1),",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "-- mutual-required(2)",
      "ja": " - 相互必須（2）"
    },
    {
      "indent": 0,
      "text": "-- Unencrypted authenticator\nAuthenticator   ::= [APPLICATION 2] SEQUENCE  {\n        authenticator-vno       [0] INTEGER (5),\n        crealm                  [1] Realm,\n        cname                   [2] PrincipalName,\n        cksum                   [3] Checksum OPTIONAL,\n        cusec                   [4] Microseconds,\n        ctime                   [5] KerberosTime,\n        subkey                  [6] EncryptionKey OPTIONAL,\n        seq-number              [7] UInt32 OPTIONAL,\n        authorization-data      [8] AuthorizationData OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AP-REP          ::= [APPLICATION 15] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (15),\n        enc-part        [2] EncryptedData -- EncAPRepPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncAPRepPart    ::= [APPLICATION 27] SEQUENCE {\n        ctime           [0] KerberosTime,\n        cusec           [1] Microseconds,\n        subkey          [2] EncryptionKey OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KRB-SAFE        ::= [APPLICATION 20] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (20),\n        safe-body       [2] KRB-SAFE-BODY,\n        cksum           [3] Checksum\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KRB-SAFE-BODY   ::= SEQUENCE {\n        user-data       [0] OCTET STRING,\n        timestamp       [1] KerberosTime OPTIONAL,\n        usec            [2] Microseconds OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL,\n        s-address       [4] HostAddress,\n        r-address       [5] HostAddress OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KRB-PRIV        ::= [APPLICATION 21] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (21),\n                        -- NOTE: there is no [2] tag",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " enc-part [3] EncryptedData -- EncKrbPrivPart }",
      "ja": "ENC-部[3]はEncryptedData  -  EncKrbPrivPart}"
    },
    {
      "indent": 0,
      "text": "EncKrbPrivPart  ::= [APPLICATION 28] SEQUENCE {\n        user-data       [0] OCTET STRING,\n        timestamp       [1] KerberosTime OPTIONAL,\n        usec            [2] Microseconds OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL,\n        s-address       [4] HostAddress -- sender's addr --,\n        r-address       [5] HostAddress OPTIONAL -- recip's addr\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KRB-CRED        ::= [APPLICATION 22] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (22),\n        tickets         [2] SEQUENCE OF Ticket,\n        enc-part        [3] EncryptedData -- EncKrbCredPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncKrbCredPart  ::= [APPLICATION 29] SEQUENCE {\n        ticket-info     [0] SEQUENCE OF KrbCredInfo,\n        nonce           [1] UInt32 OPTIONAL,\n        timestamp       [2] KerberosTime OPTIONAL,\n        usec            [3] Microseconds OPTIONAL,\n        s-address       [4] HostAddress OPTIONAL,\n        r-address       [5] HostAddress OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KrbCredInfo     ::= SEQUENCE {\n        key             [0] EncryptionKey,\n        prealm          [1] Realm OPTIONAL,\n        pname           [2] PrincipalName OPTIONAL,\n        flags           [3] TicketFlags OPTIONAL,\n        authtime        [4] KerberosTime OPTIONAL,\n        starttime       [5] KerberosTime OPTIONAL,\n        endtime         [6] KerberosTime OPTIONAL,\n        renew-till      [7] KerberosTime OPTIONAL,\n        srealm          [8] Realm OPTIONAL,\n        sname           [9] PrincipalName OPTIONAL,\n        caddr           [10] HostAddresses OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KRB-ERROR       ::= [APPLICATION 30] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (30),\n        ctime           [2] KerberosTime OPTIONAL,\n        cusec           [3] Microseconds OPTIONAL,\n        stime           [4] KerberosTime, susec           [5] Microseconds,\n        error-code      [6] Int32,\n        crealm          [7] Realm OPTIONAL,\n        cname           [8] PrincipalName OPTIONAL,\n        realm           [9] Realm -- service realm --,\n        sname           [10] PrincipalName -- service name --,\n        e-text          [11] KerberosString OPTIONAL,\n        e-data          [12] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "METHOD-DATA     ::= SEQUENCE OF PA-DATA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "TYPED-DATA      ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {\n        data-type       [0] Int32,\n        data-value      [1] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- preauth stuff follows",
      "ja": " -  PREAUTHものは以下の"
    },
    {
      "indent": 0,
      "text": "PA-ENC-TIMESTAMP        ::= EncryptedData -- PA-ENC-TS-ENC",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PA-ENC-TS-ENC           ::= SEQUENCE {\n        patimestamp     [0] KerberosTime -- client's time --,\n        pausec          [1] Microseconds OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO-ENTRY        ::= SEQUENCE {\n        etype           [0] Int32,\n        salt            [1] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO              ::= SEQUENCE OF ETYPE-INFO-ENTRY",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO2-ENTRY       ::= SEQUENCE {\n        etype           [0] Int32,\n        salt            [1] KerberosString OPTIONAL,\n        s2kparams       [2] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO2             ::= SEQUENCE SIZE (1..MAX) OF ETYPE-INFO2-ENTRY",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AD-IF-RELEVANT          ::= AuthorizationData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AD-KDCIssued            ::= SEQUENCE {\n        ad-checksum     [0] Checksum,\n        i-realm         [1] Realm OPTIONAL,\n        i-sname         [2] PrincipalName OPTIONAL,\n        elements        [3] AuthorizationData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 0,
      "text": "AD-AND-OR               ::= SEQUENCE {\n        condition-count [0] Int32,\n        elements        [1] AuthorizationData\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AD-MANDATORY-FOR-KDC    ::= AuthorizationData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 0,
      "text": "B. Changes since ",
      "ja": "B.からの変更点"
    },
    {
      "indent": 3,
      "text": "This document replaces RFC 1510 and clarifies specification of items that were not completely specified. Where changes to recommended implementation choices were made, or where new options were added, those changes are described within the document and listed in this section. More significantly, \"Specification 2\" in Section 8 changes the required encryption and checksum methods to bring them in line with the best current practices and to deprecate methods that are no longer considered sufficiently strong.",
      "ja": "この文書は、RFC 1510を置き換え、完全に指定されていない項目の仕様を明確にしています。推奨実装の選択にどこの変更が行われた、または新しいオプションが追加された場合は、これらの変更は、文書内に記述し、このセクションに記載されています。もっと重要なことは、第8章の「仕様書2には、」現在のベストプラクティスに沿ってそれらをもたらすためにもはや十分に強いと考えられている方法を廃止するために必要な暗号化とチェックサム方法を変更します。"
    },
    {
      "indent": 3,
      "text": "Discussion was added to Section 1 regarding the ability to rely on the KDC to check the transited field, and on the inclusion of a flag in a ticket indicating that this check has occurred. This is a new capability not present in RFC 1510. Pre-existing implementations may ignore or not set this flag without negative security implications.",
      "ja": "議論は遷移フィールドをチェックするためにKDCに依拠する能力に関して第1に添加し、そしてこのチェックが発生したことを示すチケット内のフラグを含めることにしました。これは、RFC 1510に存在する新たな機能ではないプレ既存の実装が負のセキュリティへの影響なしにこのフラグを設定無視するか、なくてもよいです。"
    },
    {
      "indent": 3,
      "text": "The definition of the secret key says that in the case of a user the key may be derived from a password. In RFC 1510, it said that the key was derived from the password. This change was made to accommodate situations where the user key might be stored on a smart-card, or otherwise obtained independently of a password.",
      "ja": "秘密鍵の定義は、利用者の場合には鍵はパスワードから導出することができると述べています。 RFC 1510では、それはキーがパスワードから導出されたと述べました。この変更は、ユーザーのキーはスマートカードに保存されている、あるいは独立して、パスワードの得られる可能性がある状況に対応するために作られました。"
    },
    {
      "indent": 3,
      "text": "The introduction mentions the use of public key cryptography for initial authentication in Kerberos by reference. RFC 1510 did not include such a reference.",
      "ja": "導入は、参照することによってケルベロスにおける初期認証のための公開鍵暗号の使用に言及しています。 RFC 1510は、このような参照が含まれていませんでした。"
    },
    {
      "indent": 3,
      "text": "Section 1.3 was added to explain that while Kerberos provides authentication of a named principal, it is still the responsibility of the application to ensure that the authenticated name is the entity with which the application wishes to communicate.",
      "ja": "第1.3節では、Kerberosは、名前のプリンシパルの認証を提供しながら、認証された名前は、アプリケーションが通信しようとして実体であることを確実にするためにも、アプリケーションの責任であることを説明するために追加されました。"
    },
    {
      "indent": 3,
      "text": "Discussion of extensibility has been added to the introduction.",
      "ja": "拡張性の議論は、導入に追加されました。"
    },
    {
      "indent": 3,
      "text": "Discussion of how extensibility affects ticket flags and KDC options was added to the introduction of Section 2. No changes were made to existing options and flags specified in RFC 1510, though some of the",
      "ja": "拡張性は、チケットフラグとKDCのオプションをどのように影響するかについての議論は、第2 RFC 1510で指定された既存のオプションとフラグに行われた変更なしの導入に加え、いくつかのいえ"
    },
    {
      "indent": 3,
      "text": "sections in the specification were renumbered, and text was revised to make the description and intent of existing options clearer, especially with respect to the ENC-TKT-IN-SKEY option (now section 2.9.2) which is used for user-to-user authentication. The new option and ticket flag transited policy checking (Section 2.7) was added.",
      "ja": "仕様のセクションを付け直された、そしてテキストは特に、ユーザー対のために使用されているENC-TKT-IN-SKEYオプション（今節2.9.2）に関しては、既存のオプションの説明と意図をより明確にするために改訂されましたユーザ認証。新しいオプションとチケットフラグ遷移ポリシーチェック（2.7節）を加えました。"
    },
    {
      "indent": 3,
      "text": "A warning regarding generation of session keys for application use was added to Section 3, urging the inclusion of key entropy from the KDC generated session key in the ticket. An example regarding use of the sub-session key was added to Section 3.2.6. Descriptions of the pa-etype-info, pa-etype-info2, and pa-pw-salt pre-authentication data items were added. The recommendation for use of pre-authentication was changed from \"MAY\" to \"SHOULD\" and a note was added regarding known plaintext attacks.",
      "ja": "アプリケーション用のセッションキーの生成に関する警告は、チケットにKDC生成したセッション鍵から鍵エントロピーを含めることを促す、セクション3に添加しました。サブセッションキーの使用に関する例は、セクション3.2.6に追加されました。 PA-のetype-情報の説明、PA-ETYPE-INFO2、およびPA-PW-塩の事前認証データ項目が追加されました。事前認証を使用するための勧告は、「SHOULD」へとノートがクリブに関する追加されました「MAY」から変更されました。"
    },
    {
      "indent": 3,
      "text": "In RFC 1510, Section 4 described the database in the KDC. This discussion was not necessary for interoperability and unnecessarily constrained implementation. The old Section 4 was removed.",
      "ja": "RFC 1510においては、第4節ではKDCにデータベースを記載しました。この議論は、相互運用性と不必要に制約の実施のために必要ではなかったです。古い第4節を除去しました。"
    },
    {
      "indent": 3,
      "text": "The current Section 4 was formerly Section 6 on encryption and checksum specifications. The major part of this section was brought up to date to support new encryption methods, and moved to a separate document. Those few remaining aspects of the encryption and checksum specification specific to Kerberos are now specified in Section 4.",
      "ja": "現在の第4章では、以前の暗号化とチェックサム仕様の第6節でした。このセクションの大部分は、新たな暗号化方式をサポートするために最新の状態にし、別の文書に移動しました。ケルベロスに固有の暗号化とチェックサム仕様のものをいくつかの残りの側面は、今第4節で指定されています。"
    },
    {
      "indent": 3,
      "text": "Significant changes were made to the layout of Section 5 to clarify the correct behavior for optional fields. Many of these changes were made necessary because of improper ASN.1 description in the original Kerberos specification which left the correct behavior underspecified. Additionally, the wording in this section was tightened wherever possible to ensure that implementations conforming to this specification will be extensible with the addition of new fields in future specifications.",
      "ja": "大幅な変更は、オプションのフィールドに正しい行動を明確にするため、セクション5のレイアウトに行われました。これらの変化の多くは、理由underspecifiedさ、正しい行動を残し、元のケルベロス仕様の不適切なASN.1記述の必要は作られました。また、このセクションの文言は、この仕様に準拠した実装が将来の仕様で新しいフィールドを追加して拡張できるようにするために可能な限り締めました。"
    },
    {
      "indent": 3,
      "text": "Text was added describing time_t=0 issues in the ASN.1. Text was also added, clarifying issues with implementations treating omitted optional integers as zero. Text was added clarifying behavior for optional SEQUENCE or SEQUENCE OF that may be empty. Discussion was added regarding sequence numbers and behavior of some implementations, including \"zero\" behavior and negative numbers. A compatibility note was added regarding the unconditional sending of EncTGSRepPart regardless of the enclosing reply type. Minor changes were made to the description of the HostAddresses type. Integer types were constrained. KerberosString was defined as a (significantly) constrained GeneralString. KerberosFlags was defined to reflect existing implementation behavior that departs from the definition in RFC 1510. The transited-policy-checked(12) and the ok-as-delegate(13) ticket flags were added. The disable-transited-check(26) KDC option was added.",
      "ja": "テキストは、ASN.1に= 0の問題を記述したのtime_tを追加しました。テキストはまた、ゼロとして省略オプションの整数を処理する実装の問題を明確に、追加されました。テキストは、空であってもよいそのオプションのシーケンスまたはシーケンスの動作を明確に添加しました。議論は「ゼロ」挙動と負の数を含む、シーケンス番号と、いくつかの実装の挙動に関する加えました。互換性ノートは無条件に関わらず囲む応答タイプのEncTGSRepPartの送信に関する加えました。マイナーな変更がHostAddressesタイプの説明に行われました。整数型は、制約されました。 KerberosStringが（有意に）拘束GeneralStringとして定義しました。 KerberosFlagsは、RFC 1510で定義から出発し、既存の実装の動作を反映するように定義された遷移チェックインポリシー（12）とOK-AS-デリゲート（13）チケットフラグが追加されました。無効に遷移さ-チェック（26）KDCオプションが追加されました。"
    },
    {
      "indent": 3,
      "text": "Descriptions of commonly implemented PA-DATA were added to Section 5. The description of KRB-SAFE has been updated to note the existing implementation behavior of double-encoding.",
      "ja": "一般的に実装PA-DATAの説明は第5に、二重エンコードの既存の実装の振る舞いを注意するように更新されましたKRB-SAFEの記述を追加しました。"
    },
    {
      "indent": 3,
      "text": "There were two definitions of METHOD-DATA in RFC 1510. The second one, intended for use with KRB_AP_ERR_METHOD was removed leaving the SEQUENCE OF PA-DATA definition.",
      "ja": "KRB_AP_ERR_METHODでの使用を意図二つ目は、PA-DATA定義のシーケンスを残して除去されたRFC 1510でMETHOD-DATAの二つの定義がありました。"
    },
    {
      "indent": 3,
      "text": "Section 7, naming constraints, from RFC 1510 was moved to Section 6.",
      "ja": "RFC 1510から7節、制約に名前を付けるには、第6節に移動しました。"
    },
    {
      "indent": 3,
      "text": "Words were added describing the convention that domain-based realm names for newly-created realms should be specified as uppercase. This recommendation does not make lowercase realm names illegal. Words were added highlighting that the slash-separated components in the X.500 style of realm names is consistent with existing RFC 1510 based implementations, but that it conflicts with the general recommendation of X.500 name representation specified in RFC 2253.",
      "ja": "単語は新しく作成されたレルムのためのドメインベースのレルム名は大文字で指定する必要がある規則を記述する追加されました。この勧告は、小文字のレルム名が違法ことはありません。単語は、レルム名のX.500スタイルで、スラッシュで区切られたコンポーネントは、既存のRFC 1510ベースの実装と一致しているが、それはRFC 2253で指定されたX.500名の表現の一般的な推薦と競合することを強調することを添加しました。"
    },
    {
      "indent": 3,
      "text": "Section 8, network transport, constants and defined values, from RFC 1510 was moved to Section 7. Since RFC 1510, the definition of the TCP transport for Kerberos messages was added, and the encryption and checksum number assignments have been moved into a separate document.",
      "ja": "RFC 1510のセクション8、ネットワーク・トランスポート、定数と定義された値は、RFC 1510ので部7に移動し、ケルベロスメッセージ用のTCPトランスポートの定義を添加し、そして暗号化とチェックサム番号の割り当ては、別個のドキュメントに移動されています。"
    },
    {
      "indent": 3,
      "text": "\"Specification 2\" in Section 8 of the current document changes the required encryption and checksum methods to bring them in line with the best current practices and to deprecate methods that are no longer considered sufficiently strong.",
      "ja": "現在のドキュメントの第8章の「仕様書2には、」現在のベストプラクティスに沿ってそれらをもたらすためにもはや十分に強いと考えられている方法を廃止するために必要な暗号化とチェックサム方法を変更します。"
    },
    {
      "indent": 3,
      "text": "Two new sections, on IANA considerations and security considerations were added.",
      "ja": "IANAの考慮事項とセキュリティの考慮事項の2つの新しいセクションが追加されました。"
    },
    {
      "indent": 3,
      "text": "The pseudo-code has been removed from the appendix. The pseudo-code was sometimes misinterpreted to limit implementation choices and in RFC 1510, it was not always consistent with the words in the specification. Effort was made to clear up any ambiguities in the specification, rather than to rely on the pseudo-code.",
      "ja": "擬似コードは付録から削除されました。擬似コードは、時々、実装の選択を制限するために誤解し、RFC 1510には、常に指定の単語と一致しませんでした。努力は擬似コードに依存するのではなく、仕様のいずれかのあいまいさを解消するためになされました。"
    },
    {
      "indent": 3,
      "text": "An appendix was added containing the complete ASN.1 module drawn from the discussion in Section 5 of the current document.",
      "ja": "付録には、現在のドキュメントのセクション5で議論から引き出された完全なASN.1モジュールを含む追加されました。"
    },
    {
      "indent": 0,
      "text": "END NOTES",
      "ja": "ENDの注意事項"
    },
    {
      "indent": 3,
      "text": "(*TM) Project Athena, Athena, and Kerberos are trademarks of the Massachusetts Institute of Technology (MIT).",
      "ja": "（* TM）Athenaプロジェクト、アテナ、およびKerberosは、マサチューセッツ工科大学（MIT）の商標です。"
    },
    {
      "indent": 0,
      "text": "Normative References",
      "ja": "引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC3961] Raeburn, K., \"Encryption and Checksum Specifications for Kerberos 5\", RFC 3961, February 2005.",
      "ja": "[RFC3961]レイバーン、K.、 \"暗号化とケルベロス5チェックサムの仕様\"、RFC 3961、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3962] Raeburn, K., \"Advanced Encryption Standard (AES) Encryption for Kerberos 5\", RFC 3962, February 2005.",
      "ja": "[RFC3962]レイバーン、K.、 \"Kerberos 5のためのAdvanced Encryption Standard（AES）暗号化\"、RFC 3962、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[ISO-646/ECMA-6] International Organization for Standardization, \"7-bit Coded Character Set for Information Interchange\", ISO/IEC 646:1991.",
      "ja": "[ISO-646 / ECMA-6]国際標準化機構、ISO / IEC 646 \"の情報交換のために設定し、7ビット符号化文字\"：1991。"
    },
    {
      "indent": 3,
      "text": "[ISO-2022/ECMA-35] International Organization for Standardization, \"Character code structure and extension techniques\", ISO/IEC 2022:1994.",
      "ja": "[ISO-2022 / ECMA-35]国際標準化機構、 \"文字コードの構造と拡張技術\"、ISO / IEC 2022：1994。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, November 1987.",
      "ja": "[RFC1035] Mockapetris、P.、 \"ドメイン名 - 実装及び仕様\"、STD 13、RFC 1035、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, February 2000.",
      "ja": "[RFC2782] Gulbrandsenの、A.、いるVixie、P.、およびL. Esibov、 \"サービスの場所を特定するためのDNS RR（DNSのSRV）\"、RFC 2782、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2253] Wahl, M., Kille, S., and T. Howes, \"Lightweight Directory Access Protocol (v3): UTF-8 String Representation of Distinguished Names\", RFC 2253, December 1997.",
      "ja": "[RFC2253]ワール、M.、Kille、S.、およびT.ハウズ、 \"ライトウェイトディレクトリアクセスプロトコル（v3の）：識別名のUTF-8文字列表現\"、RFC 2253、1997年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3513] Hinden, R. and S. Deering, \"Internet Protocol Version 6 (IPv6) Addressing Architecture\", RFC 3513, April 2003.",
      "ja": "[RFC3513] HindenとR.とS.デアリング、 \"インターネットプロトコルバージョン6（IPv6）のアドレス指定アーキテクチャ\"、RFC 3513、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[X680] Abstract Syntax Notation One (ASN.1): Specification of Basic Notation, ITU-T Recommendation X.680 (1997) | ISO/IEC International Standard 8824-1:1998.",
      "ja": "[X680]抽象構文記法1（ASN.1）：基本的な表記法、ITU-T勧告X.680（1997）の仕様| ISO / IEC国際規格8824から1：1998。"
    },
    {
      "indent": 3,
      "text": "[X690] ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER), ITU-T Recommendation X.690 (1997)| ISO/IEC International Standard 8825-1:1998.",
      "ja": "[X690] ASN.1符号化ルール：基本符号化規則（BER）の仕様、正規符号化規則（CER）と識別符号化規則（DER）、ITU-T勧告X.690（1997）| ISO / IEC国際規格8825から1：1998。"
    },
    {
      "indent": 0,
      "text": "Informative References",
      "ja": "参考文献"
    },
    {
      "indent": 3,
      "text": "[ISO-8859] International Organization for Standardization, \"8-bit Single-byte Coded Graphic Character Sets -- Latin Alphabet\", ISO/IEC 8859.",
      "ja": "[ISO-8859]国際標準化機構、 \"8ビットのシングルバイトコード化図形文字セット - ラテンアルファベット\"、ISO / IEC 8859。"
    },
    {
      "indent": 3,
      "text": "[RFC1964] Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\", RFC 1964, June 1996.",
      "ja": "[RFC1964]リン、J.、 \"Kerberosバージョン5 GSS-APIメカニズム\"、RFC 1964、1996年6月。"
    },
    {
      "indent": 3,
      "text": "[DGT96] Don Davis, Daniel Geer, and Theodore Ts'o, \"Kerberos With Clocks Adrift: History, Protocols, and Implementation\", USENIX Computing Systems 9:1, January 1996.",
      "ja": "[DGT96]ドン・デイヴィス、ダニエル・ギヤー、そしてセオドア・ツォー、「ケルベロス付き時計漂流：歴史、プロトコル、および実装」、USENIXコンピューティングシステム9：1、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[DS81] Dorothy E. Denning and Giovanni Maria Sacco, \"Time-stamps in Key Distribution Protocols,\" Communications of the ACM, Vol. 24 (8), p. 533- 536, August 1981.",
      "ja": "[DS81]ドロシーE.デニングとジョバンニ・マリア・サッコ、「鍵配布プロトコルにおけるタイムスタンプ、」ACMのコミュニケーション、巻。 24（8）、P。 533- 536、1981年8月。"
    },
    {
      "indent": 3,
      "text": "[KNT94] John T. Kohl, B. Clifford Neuman, and Theodore Y. Ts'o, \"The Evolution of the Kerberos Authentication System\". In Distributed Open Systems, pages 78-94. IEEE Computer Society Press, 1994.",
      "ja": "【KNT94】ジョンT.コールズ、B.クリフォードノイマン、およびセオドアY. Ts'oさん、「Kerberos認証システムの進化」。分散型オープンシステムでは、ページ78から94。 IEEEコンピュータ学会出版、1994。"
    },
    {
      "indent": 3,
      "text": "[MNSS87] S. P. Miller, B. C. Neuman, J. I. Schiller, and J. H. Saltzer, Section E.2.1: Kerberos Authentication and Authorization System, M.I.T. Project Athena, Cambridge, Massachusetts, December 21, 1987.",
      "ja": "【MNSS87] S. P.ミラー、B. C.ノイマン、J. I.シラー、及びJ. H. Saltzer、セクションE.2.1：Kerberos認証及び認可システム、M.I.T. Athenaプロジェクト、ケンブリッジ、マサチューセッツ州、1987年12月21日。"
    },
    {
      "indent": 3,
      "text": "[NS78] Roger M. Needham and Michael D. Schroeder, \"Using Encryption for Authentication in Large Networks of Computers,\" Communications of the ACM, Vol. 21 (12), pp. 993-999, December 1978.",
      "ja": "[NS78]ロジャー・M.ニーダムとマイケルD.シュローダー、「コンピュータの大規模ネットワークでの認証のための暗号化を使用し、」ACMのコミュニケーション、巻。 21（12）、頁993から999まで、1978年12月。"
    },
    {
      "indent": 3,
      "text": "[Neu93] B. Clifford Neuman, \"Proxy-Based Authorization and Accounting for Distributed Systems,\" in Proceedings of the 13th International Conference on Distributed Computing Systems, Pittsburgh, PA, May 1993.",
      "ja": "[Neu93] B.クリフォード・ノイマン、分散コンピューティングシステム上の第13回国際会議議事録、ピッツバーグ、PA、1993年5月に「認可をプロキシベースの分散システムの会計処理」。"
    },
    {
      "indent": 3,
      "text": "[NT94] B. Clifford Neuman and Theodore Y. Ts'o, \"An Authentication Service for Computer Networks,\" IEEE Communications Magazine, Vol. 32 (9), p. 33- 38, September 1994.",
      "ja": "[NT94] B.クリフォード・ノイマンとセオドアY. Ts'oさん、「コンピュータネットワークのためのアン認証サービス、」IEEEコミュニケーションズマガジン、巻。 32（9）、P。 33- 38、1994年9月。"
    },
    {
      "indent": 3,
      "text": "[Pat92] J. Pato, Using Pre-Authentication to Avoid Password Guessing Attacks, Open Software Foundation DCE Request for Comments 26 (December 1992.",
      "ja": "[Pat92] J.パト、パスワード推測攻撃を避けるために事前認証を使用して、オープンソフトウェア財団DCEコメント26のためのリクエスト（1992年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1510] Kohl, J. and C. Neuman, \"The Kerberos Network Authentication Service (V5)\", RFC 1510, September 1993.",
      "ja": "[RFC1510]コールズ、J.及びC.ノイマン、 \"ケルベロスネットワーク認証サービス（V5）\"、RFC 1510、1993年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、3、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[SNS88] J. G. Steiner, B. C. Neuman, and J. I. Schiller, \"Kerberos: An Authentication Service for Open Network Systems,\" p. 191-202, Usenix Conference Proceedings, Dallas, Texas, February 1988.",
      "ja": "[SNS88] J. G.シュタイナー、B. C.ノイマン、およびJ. I.シラー、 \"ケルベロス：オープンネットワークシステムの認証サービス、\" P。 191-202、Usenixの会議議事録、ダラス、テキサス州、1988年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4121] Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2\", RFC 4121, July 2005.",
      "ja": "[RFC4121]朱、L.、Jaganathan、K.、およびS.ハートマン、 \"Kerberosバージョン5の汎用セキュリティサービスアプリケーションプログラムインタフェース（GSS-API）メカニズム：バージョン2\"、RFC 4121、2005年7月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Clifford Neuman Information Sciences Institute University of Southern California 4676 Admiralty Way Marina del Rey, CA 90292, USA",
      "ja": "南カリフォルニアのクリフォード・ノイマン情報科学研究所大学4676アドミラルティWayマリナデルレイ、CA 90292、USA"
    },
    {
      "indent": 3,
      "text": "EMail: bcn@isi.edu",
      "ja": "メールアドレス：bcn@isi.edu"
    },
    {
      "indent": 3,
      "text": "Tom Yu Massachusetts Institute of Technology 77 Massachusetts Avenue Cambridge, MA 02139, USA",
      "ja": "テクノロジーのトム・ゆうマサチューセッツ工科大学77マサチューセッツアベニューケンブリッジ、MA 02139、USA"
    },
    {
      "indent": 3,
      "text": "EMail: tlyu@mit.edu",
      "ja": "メールアドレス：tlyu@mit.edu"
    },
    {
      "indent": 3,
      "text": "Sam Hartman Massachusetts Institute of Technology 77 Massachusetts Avenue Cambridge, MA 02139, USA",
      "ja": "テクノロジー77マサチューセッツアベニューケンブリッジ、MA 02139、USAのサム・ハートマンマサチューセッツ工科大学"
    },
    {
      "indent": 3,
      "text": "EMail: hartmans-ietf@mit.edu",
      "ja": "メールアドレス：hartmans-ietf@mit.edu"
    },
    {
      "indent": 3,
      "text": "Kenneth Raeburn Massachusetts Institute of Technology 77 Massachusetts Avenue Cambridge, MA 02139, USA",
      "ja": "テクノロジーのケネス・レイバーンマサチューセッツ工科大学77マサチューセッツアベニューケンブリッジ、MA 02139、USA"
    },
    {
      "indent": 3,
      "text": "EMail: raeburn@mit.edu",
      "ja": "メールアドレス：raeburn@mit.edu"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}