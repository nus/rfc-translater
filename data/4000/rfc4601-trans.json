{
  "title": {
    "text": "RFC 4601 - Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)",
    "ja": "RFC 4601 - プロトコル独立マルチキャスト - スパースモード（PIM-SM）：プロトコル仕様（改訂）"
  },
  "number": 4601,
  "created_at": "2019-10-23 20:07:41.825238+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          B. Fenner\nRequest for Comments: 4601                          AT&T Labs - Research\nObsoletes: 2362                                               M. Handley\nCategory: Standards Track                                            UCL\n                                                             H. Holbrook\n                                                                 Arastra\n                                                             I. Kouvelas\n                                                                   Cisco\n                                                             August 2006",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Protocol Independent Multicast - Sparse Mode (PIM-SM):\n           Protocol Specification (Revised)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies Protocol Independent Multicast - Sparse Mode (PIM-SM). PIM-SM is a multicast routing protocol that can use the underlying unicast routing information base or a separate multicast-capable routing information base. It builds unidirectional shared trees rooted at a Rendezvous Point (RP) per group, and optionally creates shortest-path trees per source.",
      "ja": "希薄モード（PIM-SM） - このドキュメントは、プロトコル独立マルチキャストを指定します。 PIM-SMは、基礎となるユニキャストルーティング情報ベース、または別個のマルチキャスト対応ルーティング情報ベースを使用することができるマルチキャストルーティングプロトコルです。これは、グループ当たりランデブーポイント（RP）をルート一方向共有ツリーを構築し、そして必要に応じてソースあたり最短パス木を作成します。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 2362, an Experimental version of PIM-SM.",
      "ja": "この文書はRFC 2362、PIM-SMの実験バージョンを廃止します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n2. Terminology .....................................................5\n   2.1. Definitions ................................................5\n   2.2. Pseudocode Notation ........................................7\n3. PIM-SM Protocol Overview ........................................7\n   3.1. Phase One: RP Tree .........................................8\n   3.2. Phase Two: Register-Stop ...................................8\n   3.3. Phase Three: Shortest-Path Tree ............................9\n   3.4. Source-Specific Joins .....................................10\n   3.5. Source-Specific Prunes ....................................11\n   3.6. Multi-Access Transit LANs .................................11\n   3.7. RP Discovery ..............................................12\n4. Protocol Specification .........................................12\n   4.1. PIM Protocol State ........................................13\n        4.1.1. General Purpose State ..............................14\n        4.1.2. (*,*,RP) State .....................................15\n        4.1.3. (*,G) State ........................................16\n        4.1.4. (S,G) State ........................................17\n        4.1.5. (S,G,rpt) State ....................................20\n        4.1.6. State Summarization Macros .........................21\n   4.2. Data Packet Forwarding Rules ..............................26\n        4.2.1. Last-Hop Switchover to the SPT .....................28\n        4.2.2. Setting and Clearing the (S,G) SPTbit ..............29\n   4.3. Designated Routers (DR) and Hello Messages ................30\n        4.3.1. Sending Hello Messages .............................30\n        4.3.2. DR Election ........................................32\n        4.3.3. Reducing Prune Propagation Delay on LANs ...........34\n        4.3.4. Maintaining Secondary Address Lists ................37\n   4.4. PIM Register Messages .....................................38\n        4.4.1. Sending Register Messages from the DR ..............38\n        4.4.2. Receiving Register Messages at the RP ..............43\n   4.5. PIM Join/Prune Messages ...................................45\n        4.5.1. Receiving (*,*,RP) Join/Prune Messages .............45\n        4.5.2. Receiving (*,G) Join/Prune Messages ................49\n        4.5.3. Receiving (S,G) Join/Prune Messages ................53\n        4.5.4. Receiving (S,G,rpt) Join/Prune Messages ............56\n        4.5.5. Sending (*,*,RP) Join/Prune Messages ...............62\n        4.5.6. Sending (*,G) Join/Prune Messages ..................66\n        4.5.7. Sending (S,G) Join/Prune Messages ..................71\n        4.5.8. (S,G,rpt) Periodic Messages ........................76\n        4.5.9. State Machine for (S,G,rpt) Triggered Messages .....77\n        4.5.10. Background: (*,*,RP) and (S,G,rpt) Interaction ....82\n   4.6. PIM Assert Messages .......................................83\n        4.6.1. (S,G) Assert Message State Machine .................83\n        4.6.2. (*,G) Assert Message State Machine .................91\n        4.6.3. Assert Metrics .....................................98",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        4.6.4. AssertCancel Messages ..............................99\n        4.6.5. Assert State Macros ...............................100\n   4.7. PIM Bootstrap and RP Discovery ...........................103\n        4.7.1. Group-to-RP Mapping ...............................104\n        4.7.2. Hash Function .....................................105\n   4.8. Source-Specific Multicast ................................106\n        4.8.1. Protocol Modifications for SSM Destination\n               Addresses .........................................106\n        4.8.2. PIM-SSM-Only Routers ..............................107\n   4.9. PIM Packet Formats .......................................108\n        4.9.1. Encoded Source and Group Address Formats ..........110\n        4.9.2. Hello Message Format ..............................113\n        4.9.3. Register Message Format ...........................116\n        4.9.4. Register-Stop Message Format ......................119\n        4.9.5. Join/Prune Message Format .........................119\n               4.9.5.1. Group Set Source List Rules ..............122\n               4.9.5.2. Group Set Fragmentation ..................126\n        4.9.6. Assert Message Format .............................126\n   4.10. PIM Timers ..............................................128\n   4.11. Timer Values ............................................129\n5. IANA Considerations ...........................................135\n   5.1. PIM Address Family .......................................135\n   5.2. PIM Hello Options ........................................136\n6. Security Considerations .......................................136\n   6.1. Attacks Based on Forged Messages .........................136\n        6.1.1. Forged Link-Local Messages ........................136\n        6.1.2. Forged Unicast Messages ...........................137\n   6.2. Non-Cryptographic Authentication Mechanisms ..............137\n   6.3. Authentication Using IPsec ...............................138\n        6.3.1. Protecting Link-Local Multicast Messages ..........138\n        6.3.2. Protecting Unicast Messages .......................139\n               6.3.2.1. Register Messages ........................139\n               6.3.2.2. Register-Stop Messages ...................139\n   6.4. Denial-of-Service Attacks ................................140\n7. Acknowledgements ..............................................140\n8. Normative References ..........................................141\n9. Informative References ........................................141\nAppendix A. PIM Multicast Border Router Behavior .................143\n   A.1. Sources External to the PIM-SM Domain ....................143\n   A.2.  Sources Internal to the PIM-SM Domain ...................144\nAppendix B. Index ................................................146",
      "raw": true
    },
    {
      "indent": 0,
      "text": "List of Figures",
      "ja": "数字のリスト"
    },
    {
      "indent": 3,
      "text": "Figure 1. Per-(S,G) register state machine at a DR ................38\nFigure 2. Downstream per-interface (*,*,RP) state machine .........46\nFigure 3. Downstream per-interface (*,G) state machine ............50\nFigure 4. Downstream per-interface (S,G) state machine ............53\nFigure 5. Downstream per-interface (S,G,rpt) state machine ........57\nFigure 6. Upstream (*,*,RP) state machine .........................62\nFigure 7. Upstream (*,G) state machine ............................67\nFigure 8. Upstream (S,G) state machine ............................71\nFigure 9. Upstream (S,G,rpt) state machine for triggered\n          messages ................................................77\nFigure 10. Per-interface (S,G) Assert State machine ...............84\nFigure 11. Per-interface (*,G) Assert State machine ...............92",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies a protocol for efficiently routing multicast groups that may span wide-area (and inter-domain) internets. This protocol is called Protocol Independent Multicast - Sparse Mode (PIM-SM) because, although it may use the underlying unicast routing to provide reverse-path information for multicast tree building, it is not dependent on any particular unicast routing protocol.",
      "ja": "この文書では、効率的に広域（およびドメイン間）のインターネットにまたがることができるマルチキャストグループをルーティングするためのプロトコルを指定します。それはマルチキャストツリー構築のためのリバースパス情報を提供するために、基礎となるユニキャストルーティングを使用することができるが、それは任意の特定のユニキャストルーティングプロトコルに依存しない、ためスパースモード（PIM-SM） - このプロトコルは、プロトコル独立マルチキャストと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "PIM-SM version 2 was originally specified in RFC 2117 and was revised in RFC 2362, both Experimental RFCs. This document is intended to obsolete RFC 2362, to correct a number of deficiencies that have been identified with the way PIM-SM was previously specified, and to bring PIM-SM onto the IETF Standards Track. As far as possible, this document specifies the same protocol as RFC 2362 and only diverges from the behavior intended by RFC 2362 when the previously specified behavior was clearly incorrect. Routers implemented according to the specification in this document will be able to interoperate successfully with routers implemented according to RFC 2362.",
      "ja": "PIM-SMのバージョン2は、実験的RFCの両方を元々RFC 2117で指定されたが、RFC 2362で修正されました。この文書は、PIM-SMは、以前に指定された方法で識別された欠陥の数を修正するために、およびIETF標準化過程の上にPIM-SMをもたらすために、廃止されたRFC 2362に意図されます。可能な限り、このドキュメントはRFC 2362と同じプロトコルを指定するだけで、以前に指定された行動は明らかに間違っていたとき、RFC 2362の意図した動作から発散します。この文書の仕様に従って実装ルータは、RFC 2362に従って実装ルータで正常に相互運用することができるようになります。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in RFC 2119 [1] and indicate requirement levels for compliant PIM-SM implementations.",
      "ja": "この文書では、キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"NOT SHALL\"、 \"推奨\"、 \"すべきではない\" \"べきである\" \"ないものと\"、 \"MAY\"、および \"オプション\" RFC 2119に記載されるように解釈されるべきである[1]と対応PIM-SMの実装に対する要求レベルを示します。"
    },
    {
      "indent": 0,
      "text": "2.1. Definitions",
      "section_title": true,
      "ja": "2.1。定義"
    },
    {
      "indent": 3,
      "text": "The following terms have special significance for PIM-SM:",
      "ja": "次の用語は、PIM-SMのための特別な意味を持っています。"
    },
    {
      "indent": 3,
      "text": "Rendezvous Point (RP): An RP is a router that has been configured to be used as the root of the non-source-specific distribution tree for a multicast group. Join messages from receivers for a group are sent towards the RP, and data from senders is sent to the RP so that receivers can discover who the senders are and start to receive traffic destined for the group.",
      "ja": "ランデブーポイント（RP）RPは、マルチキャストグループのための非ソース固有の配信ツリーのルートとして使用されるように構成されているルータです。グループの受信者からのメッセージをRPに向けて送信され、受信機は送信者が誰であるかを発見し、グループ宛てのトラフィックを受信するために始めることができるように送信者からのデータをRPに送信されましょう。"
    },
    {
      "indent": 3,
      "text": "Designated Router (DR): A shared-media LAN like Ethernet may have multiple PIM-SM routers connected to it. A single one of these routers, the DR, will act on behalf of directly connected hosts with respect to the PIM-SM protocol. A single DR is elected per interface (LAN or otherwise) using a simple election process.",
      "ja": "指定ルータ（DR）：イーサネットのような共有媒体LANは、それに接続された複数のPIM-SMルータを有していてもよいです。これらのルータの単一のもの、DRは、PIM-SMプロトコルに対して直接接続されたホストに代わって行動します。単一DRは、単純な選択プロセスを使用してインターフェイス（LANまたはその他）ごとに選出されます。"
    },
    {
      "indent": 3,
      "text": "MRIB Multicast Routing Information Base. This is the multicast topology table, which is typically derived from the unicast routing table, or routing protocols such as Multiprotocol BGP (MBGP) that carry multicast-specific topology information. In PIM-SM, the MRIB is used to decide where to send Join/Prune messages. A secondary function of the MRIB is to provide routing metrics for destination addresses; these metrics are used when sending and processing Assert messages.",
      "ja": "MRIBマルチキャストルーティング情報ベース。これは、典型的には、ユニキャストルーティングテーブル、又はそのようなマルチキャスト固有のトポロジ情報を運ぶマルチプロトコルBGP（MBGP）などのルーティングプロトコルに由来するマルチキャストトポロジーテーブルです。 PIM-SMでは、MRIBはどこ/参加プルーンメッセージを送信することを決定するために使用されます。 MRIBの二次関数は、宛先アドレスのルーティングメトリックを提供することです。これらのメトリックは、送信側とのAssertメッセージを処理するときに使用されています。"
    },
    {
      "indent": 3,
      "text": "RPF Neighbor RPF stands for \"Reverse Path Forwarding\". The RPF Neighbor of a router with respect to an address is the neighbor that the MRIB indicates should be used to forward packets to that address. In the case of a PIM-SM multicast group, the RPF neighbor is the router that a Join message for that group would be directed to, in the absence of modifying Assert state.",
      "ja": "RPF隣人RPFは、「リバースパス転送」の略です。アドレスに対するルータのRPFネイバーはMRIBがそのアドレスにパケットを転送するために使用されるべきであることを示している隣人です。 PIM-SMのマルチキャストグループの場合、RPF隣人がそのグループの参加メッセージが状態をアサート修飾の非存在下で、に向けられるルータです。"
    },
    {
      "indent": 3,
      "text": "TIB Tree Information Base. This is the collection of state at a PIM router that has been created by receiving PIM Join/Prune messages, PIM Assert messages, and Internet Group Management Protocol (IGMP) or Multicast Listener Discovery (MLD) information from local hosts. It essentially stores the state of all multicast distribution trees at that router.",
      "ja": "TIBツリー情報ベース。これは、PIMを受信することにより作成されたPIMルータの状態のコレクションです/プルーンのメッセージ、PIMアサートメッセージ、およびインターネットグループ管理プロトコル（IGMP）またはローカルホストからのマルチキャストリスナ発見（MLD）の情報に参加します。それは本質的にそのルータでは、すべてのマルチキャスト配信ツリーの状態を格納します。"
    },
    {
      "indent": 3,
      "text": "MFIB Multicast Forwarding Information Base. The TIB holds all the state that is necessary to forward multicast packets at a router. However, although this specification defines forwarding in terms of the TIB, to actually forward packets using the TIB is very inefficient. Instead, a real router implementation will normally build an efficient MFIB from the TIB state to perform forwarding. How this is done is implementation-specific and is not discussed in this document.",
      "ja": "MFIBマルチキャスト転送情報ベース。 TIBは、ルータでマルチキャストパケットを転送する必要があるすべての状態を保持しています。この仕様は、実際に前方にTIBを使用してパケットに、TIBの点で転送定義するものの、非常に非効率的です。代わりに、実際のルータの実装は、通常の転送を実行するためにTIB状態から効率的なMFIBを構築します。これはどのように行われている実装固有であり、この文書で説明されていません。"
    },
    {
      "indent": 3,
      "text": "Upstream Towards the root of the tree. The root of tree may be either the source or the RP, depending on the context.",
      "ja": "ツリーのルートに向けて上流。ツリーのルートは、文脈に応じて、ソースまたはRPのいずれであってもよいです。"
    },
    {
      "indent": 3,
      "text": "Downstream Away from the root of the tree.",
      "ja": "アウェイツリーのルートから下流。"
    },
    {
      "indent": 3,
      "text": "GenID Generation Identifier, used to detect reboots.",
      "ja": "再起動を検出するために使用られたGenID生成識別子。"
    },
    {
      "indent": 3,
      "text": "PMBR PIM Multicast Border Router, joining a PIM domain with another multicast domain.",
      "ja": "PMBR PIMマルチキャスト境界ルータ、別のマルチキャストドメインでPIMドメインに参加します。"
    },
    {
      "indent": 0,
      "text": "2.2. Pseudocode Notation",
      "section_title": true,
      "ja": "2.2。擬似コード表記"
    },
    {
      "indent": 3,
      "text": "We use set notation in several places in this specification.",
      "ja": "私たちは、この仕様では、いくつかの場所に設定された表記法を使用しています。"
    },
    {
      "indent": 3,
      "text": "A (+) B is the union of two sets, A and B.",
      "ja": "（+）Bは二組、AとBの和集合であります"
    },
    {
      "indent": 3,
      "text": "A (-) B is the elements of set A that are not in set B.",
      "ja": "（ - ）Bは、セットBにはない集合Aの要素であります"
    },
    {
      "indent": 3,
      "text": "NULL is the empty set or list.",
      "ja": "NULLは空のセットまたはリストです。"
    },
    {
      "indent": 3,
      "text": "In addition, we use C-like syntax:",
      "ja": "加えて、我々はCに似た構文を使用します。"
    },
    {
      "indent": 3,
      "text": "= denotes assignment of a variable.",
      "ja": "=変数の割り当てを示しています。"
    },
    {
      "indent": 3,
      "text": "== denotes a comparison for equality.",
      "ja": "==平等のための比較を示しています。"
    },
    {
      "indent": 3,
      "text": "!= denotes a comparison for inequality.",
      "ja": "！=不平等のための比較を示しています。"
    },
    {
      "indent": 3,
      "text": "Braces { and } are used for grouping.",
      "ja": "ブレースは、{と}グループ化するために使用されます。"
    },
    {
      "indent": 0,
      "text": "3. PIM-SM Protocol Overview",
      "section_title": true,
      "ja": "3. PIM-SMプロトコルの概要"
    },
    {
      "indent": 3,
      "text": "This section provides an overview of PIM-SM behavior. It is intended as an introduction to how PIM-SM works, and it is NOT definitive. For the definitive specification, see Section 4.",
      "ja": "このセクションでは、PIM-SMの動作の概要を説明します。これは、PIM-SMがどのように機能するかを紹介するもので、それは決定的ではありません。決定的な仕様については、第4章を参照してください。"
    },
    {
      "indent": 3,
      "text": "PIM relies on an underlying topology-gathering protocol to populate a routing table with routes. This routing table is called the Multicast Routing Information Base (MRIB). The routes in this table may be taken directly from the unicast routing table, or they may be different and provided by a separate routing protocol such as MBGP [10]. Regardless of how it is created, the primary role of the MRIB in the PIM protocol is to provide the next-hop router along a multicast-capable path to each destination subnet. The MRIB is used to determine the next-hop neighbor to which any PIM Join/Prune message is sent. Data flows along the reverse path of the Join messages. Thus, in contrast to the unicast RIB, which specifies the next hop that a data packet would take to get to some subnet, the MRIB gives reverse-path information and indicates the path that a multicast data packet would take from its origin subnet to the router that has the MRIB.",
      "ja": "PIMはルートにルーティングテーブルを埋めるために、基礎となるトポロジー収集プロトコルに依存しています。このルーティングテーブルは、マルチキャストルーティング情報ベース（MRIB）と呼ばれています。このテーブル内のルートは、ユニキャストルーティングテーブルから直接取得することができる、またはそれらは異なって、このようなMBGP [10]などの別のルーティングプロトコルによって提供されてもよいです。かかわらず、それが作成される方法の、PIMプロトコルにおけるMRIBの主な役割は、各宛先サブネットにマルチキャスト対応の経路に沿って次のホップルータを提供することです。 MRIBは、任意のPIM参加/プルーンメッセージが送信されるべき次のホップネイバーを決定するために使用されます。データは、参加メッセージの逆の経路に沿って流れます。従って、データパケットは、いくつかのサブネットに到達するためにかかる次のホップを指定するユニキャストRIBとは対照的に、MRIBは、逆パス情報を与え、マルチキャストデータパケットがその原点サブネットからに取る経路を示しますMRIBを持つルータ。"
    },
    {
      "indent": 3,
      "text": "Like all multicast routing protocols that implement the service model from RFC 1112 [3], PIM-SM must be able to route data packets from sources to receivers without either the sources or receivers knowing a priori of the existence of the others. This is essentially done in three phases, although as senders and receivers may come and go at any time, all three phases may occur simultaneously.",
      "ja": "RFC 1112からサービスモデルを実装するすべてのマルチキャストルーティングプロトコルのように、[3]、PIM-SMは、他人の存在のアプリオリに知ることソースまたは受信機のいずれかせずにソースから受信機までの経路データパケットにできなければなりません。送信側と受信側はいつでも行ったり来たりする可能性があるため、すべての3つのフェーズが同時に発生する可能性がありますが、これは基本的に、3つのフェーズで行われます。"
    },
    {
      "indent": 0,
      "text": "3.1. Phase One: RP Tree",
      "section_title": true,
      "ja": "3.1。フェーズワン：RPツリー"
    },
    {
      "indent": 3,
      "text": "In phase one, a multicast receiver expresses its interest in receiving traffic destined for a multicast group. Typically, it does this using IGMP [2] or MLD [4], but other mechanisms might also serve this purpose. One of the receiver's local routers is elected as the Designated Router (DR) for that subnet. On receiving the receiver's expression of interest, the DR then sends a PIM Join message towards the RP for that multicast group. This Join message is known as a (*,G) Join because it joins group G for all sources to that group. The (*,G) Join travels hop-by-hop towards the RP for the group, and in each router it passes through, multicast tree state for group G is instantiated. Eventually, the (*,G) Join either reaches the RP or reaches a router that already has (*,G) Join state for that group. When many receivers join the group, their Join messages converge on the RP and form a distribution tree for group G that is rooted at the RP. This is known as the RP Tree (RPT), and is also known as the shared tree because it is shared by all sources sending to that group. Join messages are resent periodically so long as the receiver remains in the group. When all receivers on a leaf-network leave the group, the DR will send a PIM (*,G) Prune message towards the RP for that multicast group. However, if the Prune message is not sent for any reason, the state will eventually time out.",
      "ja": "フェーズ1で、マルチキャスト受信側は、マルチキャストグループ宛のトラフィックの受信に関心を表現します。典型的には、この[2]またはMLD [4] IGMPを使用しないが、他のメカニズムもまた、この目的を果たすかもしれません。受信機のローカルルータの1つは、そのサブネットの代表ルータ（DR）として選出されます。興味の受信者の表現を受信すると、DRは、PIMは、そのマルチキャストグループのRPに向けてJoinメッセージを送信します。それは、そのグループのすべてのソースのグループGに加入するので、この参加メッセージは、（*、G）として知られている参加。 （*、G）は、ホップバイホップグループのためのRPに向かって、各ルータにそれが通過進行は、グループGのマルチキャストツリー状態がインスタンス化され参加します。最終的には、（*、G）は、どちらかがRPに達するか、すでに持っているルータ（*、G）、そのグループの状態を参加に達する参加します。多くの受信機がグループに参加すると、彼らの参加メッセージがRPに収束し、RPをルートとされ、グループGの配布ツリーを形成します。これは、RPツリー（RPT）として知られており、それはそのグループに送信するすべてのソースによって共有されているため、共有ツリーとして知られています。メッセージに参加していれば、受信機がグループに残るよう、定期的に再送されます。リーフ・ネットワーク上のすべての受信機がグループを離れたとき、DRはそのマルチキャストグループのRPに向かってPIM（*、G）プルーンメッセージを送信します。プルーンのメッセージが何らかの理由で送信されない場合は、状態は最終的にタイムアウトします。"
    },
    {
      "indent": 3,
      "text": "A multicast data sender just starts sending data destined for a multicast group. The sender's local router (DR) takes those data packets, unicast-encapsulates them, and sends them directly to the RP. The RP receives these encapsulated data packets, decapsulates them, and forwards them onto the shared tree. The packets then follow the (*,G) multicast tree state in the routers on the RP Tree, being replicated wherever the RP Tree branches, and eventually reaching all the receivers for that multicast group. The process of encapsulating data packets to the RP is called registering, and the encapsulation packets are known as PIM Register packets.",
      "ja": "マルチキャストデータ送信者は、単にマルチキャストグループ宛のデータの送信を開始します。送信者のローカルルータ（DR）は、それらをユニキャストは、カプセル化し、それらのデータ・パケットを受け取り、RPに直接送信します。 RPは、これらのカプセル化されたデータパケットを受信し、それらをデカプセル化し、共有ツリー上にそれらを転送します。パケットは複製され、RPツリー上のルータで（*、G）のマルチキャストツリーの状態を追跡どこRP木の枝、そして最終的にそのマルチキャストグループのすべての受信機に到達しました。 RPにデータパケットをカプセル化するプロセスは、登録と呼ばれ、カプセル化パケットは、PIM Registerパケットとして知られています。"
    },
    {
      "indent": 3,
      "text": "At the end of phase one, multicast traffic is flowing encapsulated to the RP, and then natively over the RP tree to the multicast receivers.",
      "ja": "、フェーズ1の終わりに、マルチキャストトラフィックはRPにカプセル化され、その後、ネイティブマルチキャストレシーバーへのRP木の上に流れています。"
    },
    {
      "indent": 0,
      "text": "3.2. Phase Two: Register-Stop",
      "section_title": true,
      "ja": "3.2。フェーズ2：登録ストップ"
    },
    {
      "indent": 3,
      "text": "Register-encapsulation of data packets is inefficient for two reasons:",
      "ja": "登録カプセル化データパケットの2つの理由のために非効率的です："
    },
    {
      "indent": 3,
      "text": "o Encapsulation and decapsulation may be relatively expensive operations for a router to perform, depending on whether or not the router has appropriate hardware for these tasks.",
      "ja": "Oカプセル化とカプセル化解除は、ルータがこれらのタスクのための適切なハードウェアを持っているかどうかに応じて、実行するためのルータのための比較的高価な操作かもしれません。"
    },
    {
      "indent": 3,
      "text": "o Traveling all the way to the RP, and then back down the shared tree may result in the packets traveling a relatively long distance to reach receivers that are close to the sender. For some applications, this increased latency or bandwidth consumption is undesirable.",
      "ja": "共有ツリーの下、当時のRPへのすべての道を旅し、oを送信者に近い受信機に到達するために、比較的長い距離を移動するパケットをもたらすことができます。一部のアプリケーションでは、この待ち時間の増加または帯域幅の消費は望ましくありません。"
    },
    {
      "indent": 3,
      "text": "Although Register-encapsulation may continue indefinitely, for these reasons, the RP will normally choose to switch to native forwarding. To do this, when the RP receives a register-encapsulated data packet from source S on group G, it will normally initiate an (S,G) source-specific Join towards S. This Join message travels hop-by-hop towards S, instantiating (S,G) multicast tree state in the routers along the path. (S,G) multicast tree state is used only to forward packets for group G if those packets come from source S. Eventually the Join message reaches S's subnet or a router that already has (S,G) multicast tree state, and then packets from S start to flow following the (S,G) tree state towards the RP. These data packets may also reach routers with (*,G) state along the path towards the RP; if they do, they can shortcut onto the RP tree at this point.",
      "ja": "登録-カプセル化は無期限に継続することがありますが、これらの理由のために、RPは、通常、ネイティブの転送に切り替えることを選択します。 RPはグループGにソースSからレジスタカプセル化されたデータパケットを受信したときにこれを行うには、それは通常（S、G）ソース特有を開始し、この参加メッセージは、ホップバイホップSに向かって走行するS.向かっ参加経路に沿ったルータで（S、G）マルチキャストツリーの状態をインスタンス化します。これらのパケットは、ソースSから来る場合には（S、G）マルチキャストツリー状態が唯一のグループGのためのパケットを転送するために使用される最終的参加メッセージは、Sのサブネットまたは既に（S、G）マルチキャストツリー状態を有するルータに到達し、その後、パケットSからRPに向かって（S、G）ツリーの状態を以下の流れ始めます。これらのデータパケットはまた、RPに向かう経路に沿って（*、G）ステートを持つルータに到達することができます。彼らがしなければ、彼らはこの時点でRPツリー上にショートカットすることができます。"
    },
    {
      "indent": 3,
      "text": "While the RP is in the process of joining the source-specific tree for S, the data packets will continue being encapsulated to the RP. When packets from S also start to arrive natively at the RP, the RP will be receiving two copies of each of these packets. At this point, the RP starts to discard the encapsulated copy of these packets, and it sends a Register-Stop message back to S's DR to prevent the DR from unnecessarily encapsulating the packets.",
      "ja": "RPはSのソース固有のツリーを結合する過程にある間に、データパケットはRPにカプセル化され続けます。 SからのパケットもRPにネイティブに到達するために起動すると、RPは、これらのパケットのそれぞれの2つのコピーを受信します。この時点で、RPは、これらのパケットのカプセル化されたコピーを破棄し始め、それが不必要にパケットをカプセル化からDRを防ぐために、バックSのDRに登録-Stopメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "At the end of phase 2, traffic will be flowing natively from S along a source-specific tree to the RP, and from there along the shared tree to the receivers. Where the two trees intersect, traffic may transfer from the source-specific tree to the RP tree and thus avoid taking a long detour via the RP.",
      "ja": "フェーズ2の終わりには、トラフィックはRPに、共有ツリーに沿ってそこから受信機にソース特有の木に沿ってSからネイティブに流れるであろう。 2本の木が交差する場合は、トラフィックは、RPツリーにソース特有の木から転送するため、RPを経由して、長い回り道を取って回避することができます。"
    },
    {
      "indent": 3,
      "text": "Note that a sender may start sending before or after a receiver joins the group, and thus phase two may happen before the shared tree to the receiver is built.",
      "ja": "受信機がグループに参加する前または後に、送信者が送信を開始することができ、したがって、受信機への共有ツリーが構築される前に、第二段階が起こるかもしれないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.3. Phase Three: Shortest-Path Tree",
      "section_title": true,
      "ja": "3.3。フェーズ3：最短パスツリー"
    },
    {
      "indent": 3,
      "text": "Although having the RP join back towards the source removes the encapsulation overhead, it does not completely optimize the forwarding paths. For many receivers, the route via the RP may involve a significant detour when compared with the shortest path from the source to the receiver.",
      "ja": "RPは、ソースに向かって戻って参加有するカプセル化オーバーヘッドを除去するが、それは完全に転送パスを最適化しません。受信機へのソースからの最短経路と比較した場合、多くの受信機のために、RPを経由する経路は、有意な迂回を含むことができます。"
    },
    {
      "indent": 3,
      "text": "To obtain lower latencies or more efficient bandwidth utilization, a router on the receiver's LAN, typically the DR, may optionally initiate a transfer from the shared tree to a source-specific shortest-path tree (SPT). To do this, it issues an (S,G) Join towards S. This instantiates state in the routers along the path to S. Eventually, this join either reaches S's subnet or reaches a router that already has (S,G) state. When this happens, data packets from S start to flow following the (S,G) state until they reach the receiver.",
      "ja": "低いレイテンシまたはより効率的な帯域幅利用を得るために、受信者のLAN、典型的には、DR上のルータは、必要に応じてソース固有の最短経路ツリー（SPT）への共有ツリーからの転送を開始することができます。これを行うには、これが参加、（S、G）これは最終的にS.へのパスに沿ったルータの状態をインスタンス化するS.方に参加発行のいずれかSのサブネットに到達したか、すでに（S、G）状態を持つルータに到達しました。このとき、Sのデータ・パケットは、それらが受信機に到達するまで（S、G）状態次流れ始めます。"
    },
    {
      "indent": 3,
      "text": "At this point, the receiver (or a router upstream of the receiver) will be receiving two copies of the data: one from the SPT and one from the RPT. When the first traffic starts to arrive from the SPT, the DR or upstream router starts to drop the packets for G from S that arrive via the RP tree. In addition, it sends an (S,G) Prune message towards the RP. This is known as an (S,G,rpt) Prune. The Prune message travels hop-by-hop, instantiating state along the path towards the RP indicating that traffic from S for G should NOT be forwarded in this direction. The prune is propagated until it reaches the RP or a router that still needs the traffic from S for other receivers.",
      "ja": "SPTから1とRPTから1：この時点では、受信機（又は受信機の上流のルータ）は、データの2つのコピーを受信します。最初のトラフィックはSPTから到着し始めたとき、DRまたは上流のルータは、RPツリーを介して到着SからGのパケットをドロップし始めます。また、RPに向かって（S、G）プルーンメッセージを送信します。これは（S、G、RPT）プルーンとして知られています。プルーンメッセージは、G用のSからのトラフィックがこの方向に転送されるべきでないことを示しているRPに向かって経路に沿って状態をインスタンス化する、ホップバイホップを移動します。それはRPか、まだ他の受信機のためにSからのトラフィックを必要とするルータに到達するまで、プルーンが伝播されます。"
    },
    {
      "indent": 3,
      "text": "By now, the receiver will be receiving traffic from S along the shortest-path tree between the receiver and S. In addition, the RP is receiving the traffic from S, but this traffic is no longer reaching the receiver along the RP tree. As far as the receiver is concerned, this is the final distribution tree.",
      "ja": "今、受信機はまた、受信機とSとの間の最短パス木に沿ってSからトラフィックを受信することにより、RPがSからのトラフィックを受信して​​いないが、このトラフィックはもはやRPツリーに沿って受信機に到達します。限り受信機に関しては、これは、最終的な配信ツリーです。"
    },
    {
      "indent": 0,
      "text": "3.4. Source-Specific Joins",
      "section_title": true,
      "ja": "3.4。ソース固有ジョイン"
    },
    {
      "indent": 3,
      "text": "IGMPv3 permits a receiver to join a group and specify that it only wants to receive traffic for a group if that traffic comes from a particular source. If a receiver does this, and no other receiver on the LAN requires all the traffic for the group, then the DR may omit performing a (*,G) join to set up the shared tree, and instead issue a source-specific (S,G) join only.",
      "ja": "IGMPv3がグループに参加し、そのトラフィックが特定のソースから来ている場合にのみグループのトラフィックを受信したいことを指定するための受信機を可能にします。受信機はこれを行い、そしてLAN上の他の受信機は、グループのすべてのトラフィックを必要とせず、その後、DRは（*、G）を実行省略してもよい場合は、共有ツリーを設定し、その代わりにソース固有の（Sを発行する参加します、Gは）のみ参加します。"
    },
    {
      "indent": 3,
      "text": "The range of multicast addresses from 232.0.0.0 to 232.255.255.255 is currently set aside for source-specific multicast in IPv4. For groups in this range, receivers should only issue source-specific IGMPv3 joins. If a PIM router receives a non-source-specific join for a group in this range, it should ignore it, as described in Section 4.8.",
      "ja": "232.0.0.0から232.255.255.255までのマルチキャストアドレスの範囲は、現在のIPv4ソース固有マルチキャストのために取っておかれます。この範囲のグループの場合、受信機は、ソース固有のIGMPv3が参加し発行する必要があります。 PIMルータが非ソース固有を受信した場合、この範囲内のグループのために参加し、セクション4.8で説明したように、それは、それを無視すべきです。"
    },
    {
      "indent": 0,
      "text": "3.5. Source-Specific Prunes",
      "section_title": true,
      "ja": "3.5。ソース固有プルーン"
    },
    {
      "indent": 3,
      "text": "IGMPv3 also permits a receiver to join a group and to specify that it only wants to receive traffic for a group if that traffic does not come from a specific source or sources. In this case, the DR will perform a (*,G) join as normal, but may combine this with an (S,G,rpt) prune for each of the sources the receiver does not wish to receive.",
      "ja": "IGMPv3が、グループに参加すると、それだけでそのトラフィックが特定のソースまたはソースから来ていない場合はグループのトラフィックを受信したいことを指定するには、受信を許可します。この場合、DRは（*、G）は、通常のように結合を実行しますが、受信機が受信したくないソースの各々に対して（S、G、RPT）と組み合わせる整理することができます。"
    },
    {
      "indent": 0,
      "text": "3.6. Multi-Access Transit LANs",
      "section_title": true,
      "ja": "3.6。マルチアクセストランジットのLAN"
    },
    {
      "indent": 3,
      "text": "The overview so far has concerned itself with point-to-point transit links. However, using multi-access LANs such as Ethernet for transit is not uncommon. This can cause complications for three reasons:",
      "ja": "概要では、これまでのポイント・ツー・ポイントトランジットリンクで自身を懸念しています。しかし、輸送用イーサネットなどのマルチアクセスLANを使用することは珍しいことではありません。これは、3つの理由合併症を引き起こす可能性があります："
    },
    {
      "indent": 3,
      "text": "o Two or more routers on the LAN may issue (*,G) Joins to different upstream routers on the LAN because they have inconsistent MRIB entries regarding how to reach the RP. Both paths on the RP tree will be set up, causing two copies of all the shared tree traffic to appear on the LAN.",
      "ja": "彼らはRPに到達する方法について、一貫性のないMRIBエントリーを持っているので、O LAN上の2つの以上のルータが発行することができる（*、G）は、LAN上の別のアップストリームルータに参加します。 RPツリー上の両方のパスは、LAN上で表示されるすべての共有ツリーのトラフィックの2つのコピーを引き起こし、設定されます。"
    },
    {
      "indent": 3,
      "text": "o Two or more routers on the LAN may issue (S,G) Joins to different upstream routers on the LAN because they have inconsistent MRIB entries regarding how to reach source S. Both paths on the source-specific tree will be set up, causing two copies of all the traffic from S to appear on the LAN.",
      "ja": "O LAN上の2つの以上のルータは（S、G）を発行することができるそれらがソース特有の木の両方のパスが原因、設定されるソースSに到達する方法に関する矛盾MRIBエントリーを持っているので、LAN上の異なるアップストリームルータに参加Sからのすべてのトラフィックの2つのコピーは、LAN上に表示します。"
    },
    {
      "indent": 3,
      "text": "o A router on the LAN may issue a (*,G) Join to one upstream router on the LAN, and another router on the LAN may issue an (S,G) Join to a different upstream router on the same LAN. Traffic from S may reach the LAN over both the RPT and the SPT. If the receiver behind the downstream (*,G) router doesn't issue an (S,G,rpt) prune, then this condition would persist.",
      "ja": "O LAN上のルータが（*、G）を発行する（S、G）は、同じLAN上の異なるアップストリームルータに参加を発行することができる1つのアップストリームLAN上のルータ、およびLAN上の他のルータに参加することができます。 SからのトラフィックはRPTとSPTの両方を介してLANに達する可能性があります。受信機下流の後ろに（*、G）ルータは（S、G、RPT）プルーンを発行しない場合、この状態が持続します。"
    },
    {
      "indent": 3,
      "text": "All of these problems are caused by there being more than one upstream router with join state for the group or source-group pair. PIM does not prevent such duplicate joins from occurring; instead, when duplicate data packets appear on the LAN from different routers, these routers notice this and then elect a single forwarder. This election is performed using PIM Assert messages, which resolve the problem in favor of the upstream router that has (S,G) state; or, if neither or both router has (S,G) state, then the problem is resolved in favor of the router with the best metric to the RP for RP trees, or the best metric to the source to source-specific trees.",
      "ja": "これらの問題のすべてがグループまたはソースグループのペアの状態を参加を持つ複数のアップストリームルータであることによって引き起こされます。 PIMは、このような重複が発生してから参加しなくなることはありません。重複したデータパケットが異なるルータからLAN上に表示されたときに代わりに、これらのルータは、このことを気づくと、単一フォワーダを選出します。この選挙は、（S、G）状態を持っている上流のルータを支持して問題を解決するPIMアサートメッセージを用いて行われます。どちらかまたは両方のルータは（S、G）状態を持っている場合は、問題はRP木、またはソース固有の樹木にソースへの最良のメトリックのためのRPへの最適なメトリックを持つルータを支持して解決されます。"
    },
    {
      "indent": 3,
      "text": "These Assert messages are also received by the downstream routers on the LAN, and these cause subsequent Join messages to be sent to the upstream router that won the Assert.",
      "ja": "これらのAssertメッセージもLAN上の下流のルータによって受信され、これらはアサートを獲得した上流のルータに送信されるように、後続のJoinメッセージを引き起こします。"
    },
    {
      "indent": 0,
      "text": "3.7. RP Discovery",
      "section_title": true,
      "ja": "3.7。 RPディスカバリー"
    },
    {
      "indent": 3,
      "text": "PIM-SM routers need to know the address of the RP for each group for which they have (*,G) state. This address is obtained automatically (e.g., embedded-RP), through a bootstrap mechanism, or through static configuration.",
      "ja": "PIM-SMルータは、彼らが（*、G）状態を持っている各グループのRPのアドレスを知っている必要があります。このアドレスは、ブートストラップ機構を介して、又は静的な構成を介して、（例えば、組み込みRP）が自動的に得られます。"
    },
    {
      "indent": 3,
      "text": "One dynamic way to do this is to use the Bootstrap Router (BSR) mechanism [11]. One router in each PIM domain is elected the Bootstrap Router through a simple election process. All the routers in the domain that are configured to be candidates to be RPs periodically unicast their candidacy to the BSR. From the candidates, the BSR picks an RP-set, and periodically announces this set in a Bootstrap message. Bootstrap messages are flooded hop-by-hop throughout the domain until all routers in the domain know the RP-Set.",
      "ja": "これを行う1つの動的方法は、ブートストラップルータ（BSR）メカニズム[11]を使用することです。各PIMドメイン内のルータは、単純な選挙プロセスをブートストラップルータに選出されます。 RPは定期的にBSRへの立候補をユニキャストであることを候補者になるように構成されているドメイン内のすべてのルータ。候補から、BSRはRP-設定を選び、そして定期的にブートストラップメッセージでこのセットを発表しました。ドメイン内のすべてのルータがRP-セットを知っているまで、ブートストラップメッセージは、ドメイン全体にホップバイホップに殺到しています。"
    },
    {
      "indent": 3,
      "text": "To map a group to an RP, a router hashes the group address into the RP-set using an order-preserving hash function (one that minimizes changes if the RP-Set changes). The resulting RP is the one that it uses as the RP for that group.",
      "ja": "RPにグループをマップするには、ルータがRPセット順序保存ハッシュ関数（RP-設定変更された場合、変更を最小限に抑える1）を使用してにグループアドレスをハッシュします。結果のRPは、それはそのグループのRPとして使用するものです。"
    },
    {
      "indent": 0,
      "text": "4. Protocol Specification",
      "section_title": true,
      "ja": "4.プロトコル仕様"
    },
    {
      "indent": 3,
      "text": "The specification of PIM-SM is broken into several parts:",
      "ja": "PIM-SMの仕様は、いくつかの部分に分割されます。"
    },
    {
      "indent": 3,
      "text": "o Section 4.1 details the protocol state stored.",
      "ja": "O 4.1節詳細プロトコル状態が記憶されます。"
    },
    {
      "indent": 3,
      "text": "o Section 4.2 specifies the data packet forwarding rules.",
      "ja": "O部4.2は、データパケットの転送ルールを指定します。"
    },
    {
      "indent": 3,
      "text": "o Section 4.3 specifies Designated Router (DR) election and the rules for sending and processing Hello messages.",
      "ja": "O部4.3指定ルータ（DR）選挙とメッセージを送信し、こんにちは処理するためのルールを指定します。"
    },
    {
      "indent": 3,
      "text": "o Section 4.4 specifies the PIM Register generation and processing rules.",
      "ja": "O部4.4は、PIM登録の生成および処理ルールを指定します。"
    },
    {
      "indent": 3,
      "text": "o Section 4.5 specifies the PIM Join/Prune generation and processing rules.",
      "ja": "O部4.5は、PIMは/プルーン生成および処理ルールに参加指定します。"
    },
    {
      "indent": 3,
      "text": "o Section 4.6 specifies the PIM Assert generation and processing rules.",
      "ja": "O部4.6は、PIMアサート生成および処理ルールを指定します。"
    },
    {
      "indent": 3,
      "text": "o Section 4.7 specifies the RP discovery mechanisms.",
      "ja": "O部4.7は、RPディスカバリメカニズムを指定します。"
    },
    {
      "indent": 3,
      "text": "o The subset of PIM required to support Source-Specific Multicast, PIM-SSM, is described in Section 4.8.",
      "ja": "ソース固有マルチキャスト、PIM-SSMをサポートするために必要なPIMのサブセットO、4.8節に記載されています。"
    },
    {
      "indent": 3,
      "text": "o PIM packet formats are specified in Section 4.9.",
      "ja": "O PIMパケットフォーマットは4.9節で指定されています。"
    },
    {
      "indent": 3,
      "text": "o A summary of PIM-SM timers and their default values is given in Section 4.10.",
      "ja": "O PIM-SMのタイマーとそのデフォルト値の概要は、セクション4.10に与えられています。"
    },
    {
      "indent": 3,
      "text": "o Appendix A specifies the PIM Multicast Border Router behavior.",
      "ja": "O付録Aは、PIMマルチキャスト境界ルータの動作を指定します。"
    },
    {
      "indent": 0,
      "text": "4.1. PIM Protocol State",
      "section_title": true,
      "ja": "4.1。 PIMプロトコルの状態"
    },
    {
      "indent": 3,
      "text": "This section specifies all the protocol state that a PIM implementation should maintain in order to function correctly. We term this state the Tree Information Base (TIB), as it holds the state of all the multicast distribution trees at this router. In this specification, we define PIM mechanisms in terms of the TIB. However, only a very simple implementation would actually implement packet forwarding operations in terms of this state. Most implementations will use this state to build a multicast forwarding table, which would then be updated when the relevant state in the TIB changes.",
      "ja": "このセクションでは、PIMの実装が正しく機能するために維持する必要があるすべてのプロトコル状態を指定します。それがこのルータで、すべてのマルチキャスト配信ツリーの状態を保持していると私たちは、ツリー情報ベース（TIB）この状態を名づけます。この仕様では、我々は、TIBの面でPIMメカニズムを定義します。しかし、唯一の非常に単純な実装では、実際にこのような状態の面でパケット転送の操作を実装します。ほとんどの実装では、TIBの関連する状態が変化したときに、その後更新されるマルチキャスト転送テーブルを構築するために、この状態を使用します。"
    },
    {
      "indent": 3,
      "text": "Although we specify precisely the state to be kept, this does not mean that an implementation of PIM-SM needs to hold the state in this form. This is actually an abstract state definition, which is needed in order to specify the router's behavior. A PIM-SM implementation is free to hold whatever internal state it requires and will still be conformant with this specification so long as it results in the same externally visible protocol behavior as an abstract router that holds the following state.",
      "ja": "我々が保持されるように、正確な状態を指定しますが、これは、PIM-SMの実装は、この形式で状態を保持する必要があることを意味するものではありません。これは実際にルータの動作を指定するために必要とされる抽象状態の定義、です。 PIM-SMの実装は、それが必要で、まだ、それが以下の状態を保持する抽象ルータと同じ外部から見えるプロトコルの動作になり、この仕様に準拠される内部どんな状態を保持して自由です。"
    },
    {
      "indent": 3,
      "text": "We divide TIB state into four sections:",
      "ja": "私たちは4つのセクションにTIB状態を分割します："
    },
    {
      "indent": 3,
      "text": "(*,*,RP) state State that maintains per-RP trees, for all groups served by a given RP.",
      "ja": "与えられたRPが提供するすべてのグループのために、あたり-RPツリーを維持して（*、*、RP）状態状態。"
    },
    {
      "indent": 3,
      "text": "(*,G) state State that maintains the RP tree for G.",
      "ja": "G.のためのRPツリーを維持して（*、G）ステート州"
    },
    {
      "indent": 3,
      "text": "(S,G) state State that maintains a source-specific tree for source S and group G.",
      "ja": "（S、G）ステート状態は、ソースSとグループGのソース固有のツリーを維持します"
    },
    {
      "indent": 3,
      "text": "(S,G,rpt) state State that maintains source-specific information about source S on the RP tree for G. For example, if a source is being received on the source-specific tree, it will normally have been pruned off the RP tree. This prune state is (S,G,rpt) state.",
      "ja": "（S、G、RPT）ソースは、ソース特有ツリー上で受信されている場合、たとえば、G.ためRPツリー上のソースSに関するソース固有の情報を保持する状態状態が、それは通常RPをオフに剪定されているであろう木。このプルーン状態は（S、G、RPT）の状態です。"
    },
    {
      "indent": 3,
      "text": "The state that should be kept is described below. Of course, implementations will only maintain state when it is relevant to forwarding operations; for example, the \"NoInfo\" state might be assumed from the lack of other state information rather than being held explicitly.",
      "ja": "維持されるべき状態は以下の通りです。それはフォワーディング業務に関連しているときもちろん、実装が唯一の状態を維持します。例えば、「NoInfo」状態が他の状態情報の不足から、想定される可能性があるのではなく、明示的に開催されています。"
    },
    {
      "indent": 0,
      "text": "4.1.1. General Purpose State",
      "section_title": true,
      "ja": "4.1.1。汎用州"
    },
    {
      "indent": 3,
      "text": "A router holds the following non-group-specific state:",
      "ja": "ルータは、次の非グループ固有の状態を保持します。"
    },
    {
      "indent": 3,
      "text": "For each interface:",
      "ja": "各インタフェースの場合："
    },
    {
      "indent": 8,
      "text": "o Effective Override Interval",
      "ja": "O有効オーバーライド間隔"
    },
    {
      "indent": 8,
      "text": "o Effective Propagation Delay",
      "ja": "Oの有効伝搬遅延"
    },
    {
      "indent": 8,
      "text": "o Suppression state: One of {\"Enable\", \"Disable\"}",
      "ja": "O抑制状態：{「有効」、「無効」}の一つ"
    },
    {
      "indent": 8,
      "text": "Neighbor State:",
      "ja": "近隣の状態："
    },
    {
      "indent": 10,
      "text": "For each neighbor:",
      "ja": "各隣人のために："
    },
    {
      "indent": 15,
      "text": "o Information from neighbor's Hello",
      "ja": "隣人のHelloからO情報"
    },
    {
      "indent": 15,
      "text": "o Neighbor's GenID.",
      "ja": "近隣の宋の。"
    },
    {
      "indent": 15,
      "text": "o Neighbor Liveness Timer (NLT)",
      "ja": "O隣接ライブネスタイマ（NLT）"
    },
    {
      "indent": 8,
      "text": "Designated Router (DR) State:",
      "ja": "指定ルータ（DR）状態："
    },
    {
      "indent": 10,
      "text": "o Designated Router's IP Address",
      "ja": "OルーターのIPアドレスを指定"
    },
    {
      "indent": 10,
      "text": "o DR's DR Priority",
      "ja": "O DRのDR優先順位"
    },
    {
      "indent": 3,
      "text": "The Effective Override Interval, the Effective Propagation Delay and the Interface suppression state are described in Section 4.3.3. Designated Router state is described in Section 4.3.",
      "ja": "有効なオーバーライド間隔、効果的な伝播遅延時間とインターフェイスの抑制状態は、セクション4.3.3で説明されています。指定ルータの状態は、セクション4.3に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.1.2. (*,*,RP) State",
      "section_title": true,
      "ja": "4.1.2。 （*、*、RP）州"
    },
    {
      "indent": 3,
      "text": "For every RP, a router keeps the following state:",
      "ja": "すべてのRPについて、ルータは次の状態を保持します。"
    },
    {
      "indent": 3,
      "text": "(*,*,RP) state: For each interface:",
      "ja": "（*、*、RP）状態：各インタフェースの場合："
    },
    {
      "indent": 13,
      "text": "PIM (*,*,RP) Join/Prune State:",
      "ja": "PIM（*、*、RP）/プルーンの状態に参加："
    },
    {
      "indent": 18,
      "text": "o State: One of {\"NoInfo\" (NI), \"Join\" (J), \"Prune-\n  Pending\" (PP)}",
      "raw": true
    },
    {
      "indent": 18,
      "text": "o Prune-Pending Timer (PPT)",
      "ja": "Oプルーン・ペンディングタイマ（PPT）"
    },
    {
      "indent": 18,
      "text": "o Join/Prune Expiry Timer (ET)",
      "ja": "O参加/プルーン有効期限タイマ（ET）"
    },
    {
      "indent": 8,
      "text": "Not interface specific:",
      "ja": "特定のインタフェースではありません。"
    },
    {
      "indent": 13,
      "text": "Upstream (*,*,RP) Join/Prune State:",
      "ja": "上流（*、*、RP）/プルーンの状態に参加："
    },
    {
      "indent": 18,
      "text": "o State: One of {\"NotJoined(*,*,RP)\",\n  \"Joined(*,*,RP)\"}",
      "raw": true
    },
    {
      "indent": 13,
      "text": "o Upstream Join/Prune Timer (JT)",
      "ja": "O上流には、/プルーンタイマー（JT）に参加します"
    },
    {
      "indent": 13,
      "text": "o Last RPF Neighbor towards RP that was used",
      "ja": "使用されたRPに向けた最後のRPFネイバーO"
    },
    {
      "indent": 3,
      "text": "PIM (*,*,RP) Join/Prune state is the result of receiving PIM (*,*,RP) Join/Prune messages on this interface and is specified in Section 4.5.1.",
      "ja": "PIMは（*、*、RP）/プルーンの状態に参加し、このインターフェイス上でPIM（*、*、RP）参加/プルーンのメッセージを受信した結果であると4.5.1項で規定されています。"
    },
    {
      "indent": 3,
      "text": "The upstream (*,*,RP) Join/Prune State reflects the state of the upstream (*,*,RP) state machine described in Section 4.5.5.",
      "ja": "上流（*、*、RP）参加/プルーンの状態は、セクション4.5.5で説明した上流（*、*、RP）ステートマシンの状態を反映しています。"
    },
    {
      "indent": 3,
      "text": "The upstream (*,*,RP) Join/Prune Timer is used to send out periodic Join(*,*,RP) messages, and to override Prune(*,*,RP) messages from peers on an upstream LAN interface.",
      "ja": "上流（*、*、RP）/プルーンタイマーに参加し、定期的な参加（*、*、RP）メッセージを送信すると、上流のLANインターフェイス上のピアからプルーン（*、*、RP）メッセージを無効にするために使用されます。"
    },
    {
      "indent": 3,
      "text": "The last RPF neighbor towards the RP is stored because if the MRIB changes, then the RPF neighbor towards the RP may change. If it does so, then we need to trigger a new Join(*,*,RP) to the new upstream neighbor and a Prune(*,*,RP) to the old upstream neighbor. Similarly, if a router detects through a changed GenID in a Hello message that the upstream neighbor towards the RP has rebooted, then it should re-instantiate state by sending a Join(*,*,RP). These mechanisms are specified in Section 4.5.5.",
      "ja": "RPに向けた最後のRPF隣人が原因MRIBが変化した場合、その後、RPへのRPF隣人が変化する可能性が保存されています。それがそうするならば、我々は新しいをトリガーする必要が古い上流隣接に新しい上流隣接し、プルーン（*、*、RP）に（*、*、RP）に参加。ルータがRPに向かった上流の隣人がリブートしていることをHelloメッセージに変えられたGenIDを通して検出された場合同様に、それは（*、*、RP）に参加送信することにより、状態を再インスタンス化する必要があります。これらのメカニズムは、セクション4.5.5で指定されています。"
    },
    {
      "indent": 0,
      "text": "4.1.3. (*,G) State",
      "section_title": true,
      "ja": "4.1.3。 （*、G）ステート"
    },
    {
      "indent": 3,
      "text": "For every group G, a router keeps the following state:",
      "ja": "各グループGの場合、ルータは次の状態を保持します。"
    },
    {
      "indent": 3,
      "text": "(*,G) state: For each interface:",
      "ja": "（*、G）ステート：各インタフェースの場合："
    },
    {
      "indent": 13,
      "text": "Local Membership:\n     State: One of {\"NoInfo\", \"Include\"}",
      "raw": true
    },
    {
      "indent": 13,
      "text": "PIM (*,G) Join/Prune State:",
      "ja": "PIM（*、G）/プルーンの状態に参加："
    },
    {
      "indent": 18,
      "text": "o State: One of {\"NoInfo\" (NI), \"Join\" (J), \"Prune-\n  Pending\" (PP)}",
      "raw": true
    },
    {
      "indent": 18,
      "text": "o Prune-Pending Timer (PPT)",
      "ja": "Oプルーン・ペンディングタイマ（PPT）"
    },
    {
      "indent": 18,
      "text": "o Join/Prune Expiry Timer (ET)",
      "ja": "O参加/プルーン有効期限タイマ（ET）"
    },
    {
      "indent": 13,
      "text": "(*,G) Assert Winner State",
      "ja": "（*、G）のAssert勝者状態"
    },
    {
      "indent": 18,
      "text": "o State: One of {\"NoInfo\" (NI), \"I lost Assert\" (L),\n  \"I won Assert\" (W)}",
      "raw": true
    },
    {
      "indent": 18,
      "text": "o Assert Timer (AT)",
      "ja": "Oアサートタイマー（AT）"
    },
    {
      "indent": 18,
      "text": "o Assert winner's IP Address (AssertWinner)",
      "ja": "Oアサート勝者のIPアドレス（AssertWinner）"
    },
    {
      "indent": 18,
      "text": "o Assert winner's Assert Metric (AssertWinnerMetric)",
      "ja": "Oアサート勝者のアサートメートル（AssertWinnerMetric）"
    },
    {
      "indent": 8,
      "text": "Not interface specific:",
      "ja": "特定のインタフェースではありません。"
    },
    {
      "indent": 13,
      "text": "Upstream (*,G) Join/Prune State:",
      "ja": "上流（*、G）/プルーンの状態に参加："
    },
    {
      "indent": 18,
      "text": "o State: One of {\"NotJoined(*,G)\", \"Joined(*,G)\"}",
      "ja": "O状態：の一つ{ \"NotJoined（*、G）\"、 \"参加（*、G）\"}"
    },
    {
      "indent": 13,
      "text": "o Upstream Join/Prune Timer (JT)",
      "ja": "O上流には、/プルーンタイマー（JT）に参加します"
    },
    {
      "indent": 13,
      "text": "o Last RP Used",
      "ja": "O最終RPが使用されます"
    },
    {
      "indent": 13,
      "text": "o Last RPF Neighbor towards RP that was used",
      "ja": "使用されたRPに向けた最後のRPFネイバーO"
    },
    {
      "indent": 3,
      "text": "Local membership is the result of the local membership mechanism (such as IGMP or MLD) running on that interface. It need not be kept if this router is not the DR on that interface unless this router won a (*,G) assert on this interface for this group, although implementations may optionally keep this state in case they become the DR or assert winner. We recommend storing this information if possible, as it reduces latency converging to stable operating conditions after a failure causing a change of DR. This information is used by the pim_include(*,G) macro described in Section 4.1.6.",
      "ja": "ローカル・メンバーシップは、そのインターフェイス上で実行されている（例えば、IGMPやMLDなど）ローカルメンバシップメカニズムの結果です。これは、このルータがそのインタフェース上DRでない場合は、このルータが（*、G）を獲得しない限り、実装は必要に応じて、それらがDRになるか、勝者をアサートする場合には、この状態を維持することができるが、このグループのために、このインターフェイス上でアサート維持する必要はありません。私たちは、可能であれば、それはDRの変化を引き起こす障害が発生した後、安定した動作条件に収束の待ち時間短縮など、この情報を格納するお勧めします。この情報は、セクション4.1.6に記載pim_include（*、G）マクロによって使用されます。"
    },
    {
      "indent": 3,
      "text": "PIM (*,G) Join/Prune state is the result of receiving PIM (*,G) Join/Prune messages on this interface and is specified in Section 4.5.2. The state is used by the macros that calculate the outgoing interface list in Section 4.1.6, and in the JoinDesired(*,G) macro (defined in Section 4.5.6) that is used in deciding whether a Join(*,G) should be sent upstream.",
      "ja": "PIM（*、G）/プルーン状態は、このインターフェイス上でPIM（*、G）参加/プルーンメッセージを受信した結果であり、セクション4.5.2で指定され参加。状態は、セクション4.1.6に発信インターフェイスリストを計算するマクロによって使用され、（G、*）に参加するかどうかを決定する際に使用される（セクション4.5.6で定義された）JoinDesired（*、G）マクロにあります上流送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "(*,G) Assert Winner state is the result of sending or receiving (*,G) Assert messages on this interface. It is specified in Section 4.6.2.",
      "ja": "（*、G）が勝者の状態が（*、G）は、このインターフェイス上でメッセージをアサート送信または受信の結果でアサート。これは、4.6.2項で規定されています。"
    },
    {
      "indent": 3,
      "text": "The upstream (*,G) Join/Prune State reflects the state of the upstream (*,G) state machine described in Section 4.5.6.",
      "ja": "上流（*、G）参加/プルーン状態は、セクション4.5.6に記載の上流（*、G）ステートマシンの状態を反映しています。"
    },
    {
      "indent": 3,
      "text": "The upstream (*,G) Join/Prune Timer is used to send out periodic Join(*,G) messages, and to override Prune(*,G) messages from peers on an upstream LAN interface.",
      "ja": "上流（*、G）参加/プルーンタイマは、周期的に参加（*、G）メッセージを送信するために、アップストリームLANインターフェース上のピアからプルーン（*、G）メッセージをオーバーライドするために使用されます。"
    },
    {
      "indent": 3,
      "text": "The last RP used must be stored because if the RP-Set changes (Section 4.7), then state must be torn down and rebuilt for groups whose RP changes.",
      "ja": "最後に使用したRPは、状態が取り壊され、そのRPの変化グループのために再構築されなければならない、なぜならRP-セットの変更（セクション4.7）場合に格納しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The last RPF neighbor towards the RP is stored because if the MRIB changes, then the RPF neighbor towards the RP may change. If it does so, then we need to trigger a new Join(*,G) to the new upstream neighbor and a Prune(*,G) to the old upstream neighbor. Similarly, if a router detects through a changed GenID in a Hello message that the upstream neighbor towards the RP has rebooted, then it should re-instantiate state by sending a Join(*,G). These mechanisms are specified in Section 4.5.6.",
      "ja": "RPに向けた最後のRPF隣人が原因MRIBが変化した場合、その後、RPへのRPF隣人が変化する可能性が保存されています。それがそうするならば、我々はトリガするために必要な新しい新しい上流隣接する（*、G）と昔の上流の隣人へのプルーン（*、G）が参加。同様に、ルータが参加（*、G）を送信することによって、HelloメッセージRPに向かって上流隣接が再起動したこと、それが再インスタンス化する状態に変化られたGenIDを通して検出した場合。これらのメカニズムは、セクション4.5.6で指定されています。"
    },
    {
      "indent": 0,
      "text": "4.1.4. (S,G) State",
      "section_title": true,
      "ja": "4.1.4。 （S、G）ステート"
    },
    {
      "indent": 3,
      "text": "For every source/group pair (S,G), a router keeps the following state:",
      "ja": "すべてのソース/グループペア（S、G）のために、ルータは、以下の状態を維持します。"
    },
    {
      "indent": 3,
      "text": "(S,G) state:",
      "ja": "（S、G）状態："
    },
    {
      "indent": 8,
      "text": "For each interface:",
      "ja": "各インタフェースの場合："
    },
    {
      "indent": 13,
      "text": "Local Membership:\n     State: One of {\"NoInfo\", \"Include\"}",
      "raw": true
    },
    {
      "indent": 13,
      "text": "PIM (S,G) Join/Prune State:",
      "ja": "PIM（S、G）/プルーンの状態に参加："
    },
    {
      "indent": 18,
      "text": "o State: One of {\"NoInfo\" (NI), \"Join\" (J), \"Prune-\n  Pending\" (PP)}",
      "raw": true
    },
    {
      "indent": 18,
      "text": "o Prune-Pending Timer (PPT)",
      "ja": "Oプルーン・ペンディングタイマ（PPT）"
    },
    {
      "indent": 18,
      "text": "o Join/Prune Expiry Timer (ET)",
      "ja": "O参加/プルーン有効期限タイマ（ET）"
    },
    {
      "indent": 13,
      "text": "(S,G) Assert Winner State",
      "ja": "（S、G）をアサート受賞状態"
    },
    {
      "indent": 18,
      "text": "o State: One of {\"NoInfo\" (NI), \"I lost Assert\" (L),\n  \"I won Assert\" (W)}",
      "raw": true
    },
    {
      "indent": 18,
      "text": "o Assert Timer (AT)",
      "ja": "Oアサートタイマー（AT）"
    },
    {
      "indent": 18,
      "text": "o Assert winner's IP Address (AssertWinner)",
      "ja": "Oアサート勝者のIPアドレス（AssertWinner）"
    },
    {
      "indent": 18,
      "text": "o Assert winner's Assert Metric (AssertWinnerMetric)",
      "ja": "Oアサート勝者のアサートメートル（AssertWinnerMetric）"
    },
    {
      "indent": 8,
      "text": "Not interface specific:",
      "ja": "特定のインタフェースではありません。"
    },
    {
      "indent": 13,
      "text": "Upstream (S,G) Join/Prune State:",
      "ja": "上流（S、G）/プルーンの状態に参加："
    },
    {
      "indent": 18,
      "text": "o State: One of {\"NotJoined(S,G)\", \"Joined(S,G)\"}",
      "ja": "O状態：{ \"NotJoined（S、G）\"、 \"（S、G）参加\"}の一つ"
    },
    {
      "indent": 13,
      "text": "o Upstream (S,G) Join/Prune Timer (JT)",
      "ja": "アップストリーム（S、G）O /プルーンタイマー（JT）に参加"
    },
    {
      "indent": 13,
      "text": "o Last RPF Neighbor towards S that was used",
      "ja": "使用されたSに向けた最後のRPFネイバーO"
    },
    {
      "indent": 13,
      "text": "o SPTbit (indicates (S,G) state is active)",
      "ja": "O SPTbit（示し（S、G）状態がアクティブです）"
    },
    {
      "indent": 13,
      "text": "o (S,G) Keepalive Timer (KAT)",
      "ja": "O（S、G）キープアライブタイマー（KAT）"
    },
    {
      "indent": 13,
      "text": "Additional (S,G) state at the DR:",
      "ja": "DRにおける追加の（S、G）状態："
    },
    {
      "indent": 18,
      "text": "o Register state: One of {\"Join\" (J), \"Prune\" (P),\n  \"Join-Pending\" (JP), \"NoInfo\" (NI)}",
      "raw": true
    },
    {
      "indent": 18,
      "text": "o Register-Stop timer",
      "ja": "Oレジスタストップタイマーを"
    },
    {
      "indent": 13,
      "text": "Additional (S,G) state at the RP:",
      "ja": "RPの追加（S、G）状態："
    },
    {
      "indent": 18,
      "text": "o PMBR: the first PMBR to send a Register for this\n  source with the Border bit set.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Local membership is the result of the local source-specific membership mechanism (such as IGMP version 3) running on that interface and specifying that this particular source should be included. As stored here, this state is the resulting state after any IGMPv3 inconsistencies have been resolved. It need not be kept if this router is not the DR on that interface unless this router won a (S,G) assert on this interface for this group. However, we recommend storing this information if possible, as it reduces latency converging to stable operating conditions after a failure causing a change of DR. This information is used by the pim_include(S,G) macro described in Section 4.1.6.",
      "ja": "ローカル・メンバーシップは、そのインターフェイス上で実行され、この特定のソースが含まれるべきであることを指定する（例えば、IGMPバージョン3のような）ローカルソース特有の会員機構の結果です。ここに保存されたとして任意のIGMPv3の矛盾が解決された後に、この状態は結果の状態です。このルータは、このルータは（S、G）は、このグループのために、このインターフェイス上でアサートを獲得していない限り、そのインターフェイス上のDRがない場合には、維持する必要はありません。それはDRの変化を引き起こす障害が発生した後、安定した動作条件に収束の待ち時間短縮などしかし、我々は、可能な場合は、この情報を格納するお勧めします。この情報は、セクション4.1.6に記載pim_include（S、G）マクロによって使用されます。"
    },
    {
      "indent": 3,
      "text": "PIM (S,G) Join/Prune state is the result of receiving PIM (S,G) Join/Prune messages on this interface and is specified in Section 4.5.2. The state is used by the macros that calculate the outgoing interface list in Section 4.1.6, and in the JoinDesired(S,G) macro (defined in Section 4.5.7) that is used in deciding whether a Join(S,G) should be sent upstream.",
      "ja": "PIM（S、G）/プルーン状態は、このインターフェイス上でPIM（S、G）参加/プルーンメッセージを受信した結果であり、セクション4.5.2で指定され参加。状態は、セクション4.1.6に発信インターフェイスリストを計算するマクロによって使用され、参加するかどうかを決定する際に使用されるJoinDesired（S、G）マクロ（セクション4.5.7で定義された）に（S、G）されています上流送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "(S,G) Assert Winner state is the result of sending or receiving (S,G) Assert messages on this interface. It is specified in Section 4.6.1.",
      "ja": "（S、G）受賞状態が送信またはこのインターフェイス上でメッセージをアサート（S、G）を受信した結果であるアサート。これは、4.6.1項で規定されています。"
    },
    {
      "indent": 3,
      "text": "The upstream (S,G) Join/Prune State reflects the state of the upstream (S,G) state machine described in Section 4.5.7.",
      "ja": "アップストリーム（S、G）参加/プルーン状態は、セクション4.5.7に記載のアップストリーム（S、G）ステートマシンの状態を反映しています。"
    },
    {
      "indent": 3,
      "text": "The upstream (S,G) Join/Prune Timer is used to send out periodic Join(S,G) messages, and to override Prune(S,G) messages from peers on an upstream LAN interface.",
      "ja": "アップストリーム（S、G）参加/プルーンタイマは（S、G）Joinメッセージを周期送出するように、上流LANインタフェース上のピアからプルーン（S、G）メッセージをオーバーライドするために使用されます。"
    },
    {
      "indent": 3,
      "text": "The last RPF neighbor towards S is stored because if the MRIB changes, then the RPF neighbor towards S may change. If it does so, then we need to trigger a new Join(S,G) to the new upstream neighbor and a Prune(S,G) to the old upstream neighbor. Similarly, if the router detects through a changed GenID in a Hello message that the upstream neighbor towards S has rebooted, then it should re-instantiate state by sending a Join(S,G). These mechanisms are specified in Section 4.5.7.",
      "ja": "Sに向けた最後のRPF隣人が原因MRIBが変化した場合、その後、SへのRPF隣人が変化する可能性が保存されています。それがそうなら、私たちは、新しい上流隣接し、古い上流隣接にプルーン（S、G）に新規入会（S、G）をトリガする必要があります。ルータがSに向かって上流隣接が再起動したことをHelloメッセージに変更られたGenIDを通して検出された場合も同様に、それは参加（S、G）を送信することによって状態を再インスタンス化するべきです。これらのメカニズムは、セクション4.5.7で指定されています。"
    },
    {
      "indent": 3,
      "text": "The SPTbit is used to indicate whether forwarding is taking place on the (S,G) Shortest Path Tree (SPT) or on the (*,G) tree. A router can have (S,G) state and still be forwarding on (*,G) state during the interval when the source-specific tree is being constructed. When SPTbit is FALSE, only (*,G) forwarding state is used to forward packets from S to G. When SPTbit is TRUE, both (*,G) and (S,G) forwarding state are used.",
      "ja": "SPTbitは、転送が（S、G）最短パスツリー（SPT）または（*、G）木に行われているかどうかを示すために使用されます。ルータは（S、G）状態を有することができ、依然としてソース固有のツリーが構築されている期間中に（*、G）状態に転送します。 SPTbitがFALSEである場合、のみ（*、G）SPTbitがTRUEである場合に転送状態がGにSからパケットを転送するために使用され、両方の（*、G）および（S、G）転送状態に使用されます。"
    },
    {
      "indent": 3,
      "text": "The (S,G) Keepalive Timer is updated by data being forwarded using this (S,G) forwarding state. It is used to keep (S,G) state alive in the absence of explicit (S,G) Joins. Amongst other things, this is necessary for the so-called \"turnaround rules\" -- when the RP uses (S,G) joins to stop encapsulation, and then (S,G) prunes to prevent traffic from unnecessarily reaching the RP.",
      "ja": "（S、G）キープアライブタイマがこの（S、G）転送状態を使用して転送されるデータによって更新されます。 （S、G）明示の非存在下で生きている状態（S、G）参加を維持するために使用されます。 RPが使用する（S、G）はカプセル化を停止するために参加したときに、不必要にRPに到達するトラフィックを防ぐために、その後、（S、G）プルーン - とりわけ、これは、いわゆる「ターンアラウンド・ルール」のために必要です。"
    },
    {
      "indent": 3,
      "text": "On a DR, the (S,G) Register State is used to keep track of whether to encapsulate data to the RP on the Register Tunnel; the (S,G) Register-Stop timer tracks how long before encapsulation begins again for a given (S,G).",
      "ja": "DRに、（S、G）ステートレジスタは、レジスタトンネル上のRPにデータをカプセル化するかどうかを追跡するために使用されます。 （S、G）の登録・ストップタイマトラックのカプセル化は、与えられた（S、G）のために再度開始する前にどのくらいの時間。"
    },
    {
      "indent": 3,
      "text": "On an RP, the PMBR value must be cleared when the Keepalive Timer expires.",
      "ja": "キープアライブタイマーの期限が切れるとRPで、PMBR値をクリアする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.5. (S,G,rpt) State",
      "section_title": true,
      "ja": "4.1.5。 （S、G、RPT）状態"
    },
    {
      "indent": 3,
      "text": "For every source/group pair (S,G) for which a router also has (*,G) state, it also keeps the following state:",
      "ja": "ルータはまた、（*、G）ステートを持っているすべてのソース/グループペア（S、G）のために、それはまた、以下の状態を維持します。"
    },
    {
      "indent": 3,
      "text": "(S,G,rpt) state:",
      "ja": "（S、G、RPT）状態："
    },
    {
      "indent": 8,
      "text": "For each interface:",
      "ja": "各インタフェースの場合："
    },
    {
      "indent": 13,
      "text": "Local Membership:\n     State: One of {\"NoInfo\", \"Exclude\"}",
      "raw": true
    },
    {
      "indent": 13,
      "text": "PIM (S,G,rpt) Join/Prune State:",
      "ja": "PIM（S、G、RPT）/プルーンの状態に参加："
    },
    {
      "indent": 18,
      "text": "o State: One of {\"NoInfo\", \"Pruned\", \"Prune-\n  Pending\"}",
      "raw": true
    },
    {
      "indent": 18,
      "text": "o Prune-Pending Timer (PPT)",
      "ja": "Oプルーン・ペンディングタイマ（PPT）"
    },
    {
      "indent": 18,
      "text": "o Join/Prune Expiry Timer (ET)",
      "ja": "O参加/プルーン有効期限タイマ（ET）"
    },
    {
      "indent": 8,
      "text": "Not interface specific:",
      "ja": "特定のインタフェースではありません。"
    },
    {
      "indent": 13,
      "text": "Upstream (S,G,rpt) Join/Prune State:",
      "ja": "上流（S、G、RPT）/プルーンの状態に参加："
    },
    {
      "indent": 18,
      "text": "o State: One of {\"RPTNotJoined(G)\",\n  \"NotPruned(S,G,rpt)\", \"Pruned(S,G,rpt)\"}",
      "raw": true
    },
    {
      "indent": 18,
      "text": "o Override Timer (OT)",
      "ja": "Oオーバーライドタイマー（OT）"
    },
    {
      "indent": 3,
      "text": "Local membership is the result of the local source-specific membership mechanism (such as IGMPv3) running on that interface and specifying that although there is (*,G) Include state, this particular source should be excluded. As stored here, this state is the resulting state after any IGMPv3 inconsistencies between LAN members have been resolved. It need not be kept if this router is not the DR on that interface unless this router won a (*,G) assert on this interface for this group. However, we recommend storing this information if possible, as it reduces latency converging to stable operating conditions after a failure causing a change of DR. This information is used by the pim_exclude(S,G) macro described in Section 4.1.6.",
      "ja": "ローカル・メンバーシップは、（例えばIGMPv3のような）ローカル・ソース特有の会員機構の結果、そのインターフェイス上で実行され、（*、G）ステートを含めるがあるが、この特定のソースを除外すべきであることを指定します。ここに保存されたようLANメンバー間の任意のIGMPv3の不整合が解消された後、この状態は結果の状態です。これは、このルータが（*、G）はこのグループのために、このインターフェイス上の主張を獲得しない限り、このルータは、そのインターフェイス上でDRでない場合に保持する必要はありません。それはDRの変化を引き起こす障害が発生した後、安定した動作条件に収束の待ち時間短縮などしかし、我々は、可能な場合は、この情報を格納するお勧めします。この情報は、セクション4.1.6に記載pim_exclude（S、G）マクロによって使用されます。"
    },
    {
      "indent": 3,
      "text": "PIM (S,G,rpt) Join/Prune state is the result of receiving PIM (S,G,rpt) Join/Prune messages on this interface and is specified in Section 4.5.4. The state is used by the macros that calculate the outgoing interface list in Section 4.1.6, and in the rules for adding Prune(S,G,rpt) messages to Join(*,G) messages specified in Section 4.5.8.",
      "ja": "PIM（S、G、RPT）/プルーン状態は、このインターフェイス上でPIM（S、G、RPT）参加/プルーンメッセージを受信した結果であり、セクション4.5.4で指定され参加。状態はセクション4.5.8で指定された（*、G）メッセージに参加するプルーン（S、G、RPT）メッセージを追加するためのセクション4.1.6において、ルールにおける発信インターフェイスリストを計算するマクロによって使用されます。"
    },
    {
      "indent": 3,
      "text": "The upstream (S,G,rpt) Join/Prune state is used along with the Override Timer to send the correct override messages in response to Join/Prune messages sent by upstream peers on a LAN. This state and behavior are specified in Section 4.5.9.",
      "ja": "アップストリーム（S、G、RPTは）/プルーン状態に参加LAN上の上流側ピアによって送信される/プルーンメッセージに参加する応答して正しいオーバーライドメッセージを送信するためにオーバーライドタイマーと共に使用されます。この状態と振る舞いは、セクション4.5.9で指定されています。"
    },
    {
      "indent": 0,
      "text": "4.1.6. State Summarization Macros",
      "section_title": true,
      "ja": "4.1.6。国家要約マクロ"
    },
    {
      "indent": 3,
      "text": "Using this state, we define the following \"macro\" definitions, which we will use in the descriptions of the state machines and pseudocode in the following sections.",
      "ja": "この状態を使用して、我々は次のセクションでは、ステートマシンと擬似コードの記述に使用されます、次の「マクロ」の定義を、定義します。"
    },
    {
      "indent": 3,
      "text": "The most important macros are those that define the outgoing interface list (or \"olist\") for the relevant state. An olist can be \"immediate\" if it is built directly from the state of the relevant type. For example, the immediate_olist(S,G) is the olist that would be built if the router only had (S,G) state and no (*,G) or (S,G,rpt) state. In contrast, the \"inherited\" olist inherits state from other types. For example, the inherited_olist(S,G) is the olist that is relevant for forwarding a packet from S to G using both source-specific and group-specific state.",
      "ja": "最も重要なマクロは、関連する状態のための発信インターフェイスリスト（または「OLIST」）を定義するものです。それは、関連するタイプの状態から直接構築されている場合OLISTは、「即時」することができます。例えば、immediate_olist（S、G）は、ルータのみであった場合に構築されるであろうOLIST（S、G）ステートなし（*、G）または（S、G、RPT）の状態です。これとは対照的に、「継承」OLISTは、他のタイプの状態を継承します。例えば、引き継いでいる_olist（S、G）は、ソース固有およびグループ固有の状態の両方を使用して、GにSからパケットを転送するための関連しOLISTあります。"
    },
    {
      "indent": 3,
      "text": "There is no immediate_olist(S,G,rpt) as (S,G,rpt) state is negative state; it removes interfaces in the (*,G) olist from the olist that is actually used to forward traffic. The inherited_olist(S,G,rpt) is therefore the olist that would be used for a packet from S to G forwarding on the RP tree. It is a strict subset of (immediate_olist(*,*,RP) (+) immediate_olist(*,G)).",
      "ja": "（S、G、RPT）状態が負の状態であるように何immediate_olist（S、G、RPT）がありません。実際にトラフィックを転送するために使用されるOLISTから（*、G）OLISTのインターフェイスを除去します。引き継いでいる_olist（S、G、RPT）は、従ってRPツリーに転送SからGへのパケットのために使用されるであろうOLISTあります。これは、（immediate_olist（*、*、RP）（+）immediate_olist（*、G））の厳密なサブセットです。"
    },
    {
      "indent": 3,
      "text": "Generally speaking, the inherited olists are used for forwarding, and the immediate_olists are used to make decisions about state maintenance.",
      "ja": "一般的に言って、継承されたolistsは転送のために使用され、immediate_olistsは、状態の維持に関する決定を行うために使用されています。"
    },
    {
      "indent": 3,
      "text": "immediate_olist(*,*,RP) = joins(*,*,RP)",
      "ja": "immediate_olist（*、*、RP）=（*、*、RP）加入"
    },
    {
      "indent": 3,
      "text": "immediate_olist(*,G) = joins(*,G) (+) pim_include(*,G) (-) lost_assert(*,G)",
      "ja": "immediate_olist（*、G）=ジョイン（*、G）（+）pim_include（*、G）（ - ）lost_assert（*、G）"
    },
    {
      "indent": 3,
      "text": "immediate_olist(S,G) = joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)",
      "ja": "immediate_olist（S、G）=参加する（S、G）（+）pim_include（S、G）（ - ）lost_assert（S、G）"
    },
    {
      "indent": 3,
      "text": "inherited_olist(S,G,rpt) = ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) ) (+) ( pim_include(*,G) (-) pim_exclude(S,G)) (-) ( lost_assert(*,G) (+) lost_assert(S,G,rpt) )",
      "ja": "引き継いでいる_olist（S、G、RPT）=（（*、*、RP（G）に参加）（+）ジョイン（*、G）（ - ）プルーン（S、G、RPT））（+）（pim_include（* G）（ - ）pim_exclude（S、G））（ - ）（lost_assert（*、G）（+）lost_assert（S、G、RPT））"
    },
    {
      "indent": 3,
      "text": "inherited_olist(S,G) = inherited_olist(S,G,rpt) (+) joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)",
      "ja": "引き継いでいる_olist（S、G）=引き継いでいる_olist（S、G、RPT）（+）が参加（S、G）（+）pim_include（S、G）（ - ）lost_assert（S、G）"
    },
    {
      "indent": 3,
      "text": "The macros pim_include(*,G) and pim_include(S,G) indicate the interfaces to which traffic might be forwarded because of hosts that are local members on that interface. Note that normally only the DR cares about local membership, but when an assert happens, the assert winner takes over responsibility for forwarding traffic to local members that have requested traffic on a group or source/group pair.",
      "ja": "マクロpim_include（*、G）とpim_include（S、G）は、トラフィックが原因で、そのインターフェイス上でローカルメンバーでホストから転送される可能性があるためにインターフェイスを示します。通常、唯一のDRは、地元の会員気遣うが、アサートが発生したときに、アサート勝者がグループまたはソース/グループのペアにトラフィックを要求したローカルメンバーにトラフィックを転送する責任を引き継ぐことに注意してください。"
    },
    {
      "indent": 3,
      "text": "pim_include(*,G) = { all interfaces I such that: ( ( I_am_DR( I ) AND lost_assert(*,G,I) == FALSE ) OR AssertWinner(*,G,I) == me ) AND local_receiver_include(*,G,I) }",
      "ja": "pim_include（*、G）= {すべてのインタフェースIように：（（I_am_DR（I）AND lost_assert（*、G、I）が== FALSE）OR AssertWinner（*、G、I）==私）AND local_receiver_include（* 、G、I）}"
    },
    {
      "indent": 3,
      "text": "pim_include(S,G) = { all interfaces I such that: ( (I_am_DR( I ) AND lost_assert(S,G,I) == FALSE ) OR AssertWinner(S,G,I) == me ) AND local_receiver_include(S,G,I) }",
      "ja": "pim_include（S、G）= {すべてのインタフェースIになるように：（（I_am_DR（I）AND lost_assert（S、G、I）== FALSE）OR AssertWinner（S、G、I）==私）AND local_receiver_include（S 、G、I）}"
    },
    {
      "indent": 3,
      "text": "pim_exclude(S,G) = { all interfaces I such that: ( (I_am_DR( I ) AND lost_assert(*,G,I) == FALSE ) OR AssertWinner(*,G,I) == me ) AND local_receiver_exclude(S,G,I) }",
      "ja": "pim_exclude（S、G）= {すべてのインタフェースIように：（（I_am_DR（I）AND lost_assert（*、G、I）が== FALSE）OR AssertWinner（*、G、I）が== ME）AND local_receiver_exclude（S 、G、I）}"
    },
    {
      "indent": 3,
      "text": "The clause \"local_receiver_include(S,G,I)\" is true if the IGMP/MLD module or other local membership mechanism has determined that local members on interface I desire to receive traffic sent specifically by S to G. \"local_receiver_include(*,G,I)\" is true if the IGMP/MLD module or other local membership mechanism has determined that local members on interface I desire to receive all traffic sent to G (possibly excluding traffic from a specific set of sources). \"local_receiver_exclude(S,G,I) is true if \"local_receiver_include(*,G,I)\" is true but none of the local members desire to receive traffic from S.",
      "ja": "IGMP / MLDモジュールまたは他のローカルメンバーシップ機構はインターフェイス上のローカルメンバーは、私はG.「local_receiver_include（*、GとSによって特異的に送信されたトラフィックを受信することを望んでいると判断した場合句「local_receiver_include（S、G、I）が」真でありますIGMP / MLDモジュールまたは他のローカルメンバーシップ機構はインターフェイス上のローカルメンバーは、私は（おそらく）源の特定のセットからのトラフィックを除くGに送信されたすべてのトラフィックを受信することを望んでいると判断した場合、I）」も同様です。 local_receiver_includeは、（*、G、I）は 『真のですが、地元のメンバーのいずれもSからトラフィックを受信することを望んでいない「場合local_receiver_exclude（S、G、I）が真です』"
    },
    {
      "indent": 3,
      "text": "The set \"joins(*,*,RP)\" is the set of all interfaces on which the router has received (*,*,RP) Joins:",
      "ja": "セット「ジョインは、（*、*、RP）」ルータが受信したすべてのインターフェイスのセットである（*、*、RP）は、ジョイン："
    },
    {
      "indent": 3,
      "text": "joins(*,*,RP) = { all interfaces I such that DownstreamJPState(*,*,RP,I) is either Join or Prune-Pending }",
      "ja": "ジョイン（*、*、RP）= {すべてのインタフェースIようDownstreamJPStateは（*、*、RP、I）であることのいずれかで参加又はプルーン保留}"
    },
    {
      "indent": 3,
      "text": "DownstreamJPState(*,*,RP,I) is the state of the finite state machine in Section 4.5.1.",
      "ja": "DownstreamJPStateは（*、*、RP、I）、セクション4.5.1における有限状態マシンの状態です。"
    },
    {
      "indent": 3,
      "text": "The set \"joins(*,G)\" is the set of all interfaces on which the router has received (*,G) Joins:",
      "ja": "セット「（G、*）ジョイン」は、ルータが受信したすべてのインタフェースのセット（*、G）は、ジョイン："
    },
    {
      "indent": 3,
      "text": "joins(*,G) = { all interfaces I such that DownstreamJPState(*,G,I) is either Join or Prune-Pending }",
      "ja": "（*、G）加入= {すべてのインタフェースIようDownstreamJPState（*、G、I）がいずれかの参加又はプルーン保留されていることを}"
    },
    {
      "indent": 3,
      "text": "DownstreamJPState(*,G,I) is the state of the finite state machine in Section 4.5.2.",
      "ja": "DownstreamJPState（*、G、I）、セクション4.5.2における有限状態マシンの状態です。"
    },
    {
      "indent": 3,
      "text": "The set \"joins(S,G)\" is the set of all interfaces on which the router has received (S,G) Joins:",
      "ja": "：セットは、ルータが受信した上で、すべてのインタフェースのセット（S、G）は結合「（S、G）ジョイン」"
    },
    {
      "indent": 3,
      "text": "joins(S,G) = { all interfaces I such that DownstreamJPState(S,G,I) is either Join or Prune-Pending }",
      "ja": "（S、G）加入= {すべてのインタフェースIようDownstreamJPState（S、Gは、I）であることのいずれかで参加又はプルーン保留}"
    },
    {
      "indent": 3,
      "text": "DownstreamJPState(S,G,I) is the state of the finite state machine in Section 4.5.3.",
      "ja": "DownstreamJPState（S、G、I）は、セクション4.5.3における有限状態機械の状態です。"
    },
    {
      "indent": 3,
      "text": "The set \"prunes(S,G,rpt)\" is the set of all interfaces on which the router has received (*,G) joins and (S,G,rpt) prunes.",
      "ja": "セット \"プルーン（S、G、RPT）\" は、ルータが受信したすべてのインターフェイス（*、G）結合および（S、G、RPT）プルーンの集合です。"
    },
    {
      "indent": 3,
      "text": "prunes(S,G,rpt) = { all interfaces I such that DownstreamJPState(S,G,rpt,I) is Prune or PruneTmp }",
      "ja": "プルーン（S、G、RPT）= {DownstreamJPState（S、Gは、RP​​Tは、I）は、そのようなすべてのインターフェースであるIことプルーンまたはPruneTmp}"
    },
    {
      "indent": 3,
      "text": "DownstreamJPState(S,G,rpt,I) is the state of the finite state machine in Section 4.5.4.",
      "ja": "DownstreamJPState（S、G、RPT、I）は、セクション4.5.4における有限状態機械の状態です。"
    },
    {
      "indent": 3,
      "text": "The set \"lost_assert(*,G)\" is the set of all interfaces on which the router has received (*,G) joins but has lost a (*,G) assert. The macro lost_assert(*,G,I) is defined in Section 4.6.5.",
      "ja": "セット「lost_assert（*、G）は」ルータが受信したすべてのインターフェイスのセット（*、G）が加入されているが（*、G）アサートを失っています。マクロlost_assert（*、G、I）は、セクション4.6.5で定義されています。"
    },
    {
      "indent": 3,
      "text": "lost_assert(*,G) = { all interfaces I such that lost_assert(*,G,I) == TRUE }",
      "ja": "lost_assert（*、G）= {すべてのインタフェースはIようlost_assert（*、G、I）== TRUE}"
    },
    {
      "indent": 3,
      "text": "The set \"lost_assert(S,G,rpt)\" is the set of all interfaces on which the router has received (*,G) joins but has lost an (S,G) assert. The macro lost_assert(S,G,rpt,I) is defined in Section 4.6.5.",
      "ja": "セット「lost_assert（S、G、RPT）」は、ルータが受信したすべてのインターフェイスのセット（*、G）が加入されているが（S、G）アサートを失っています。マクロlost_assert（S、G、RPTは、I）は、セクション4.6.5で定義されています。"
    },
    {
      "indent": 3,
      "text": "lost_assert(S,G,rpt) = { all interfaces I such that lost_assert(S,G,rpt,I) == TRUE }",
      "ja": "lost_assert（S、G、RPT）= {すべてのインタフェースIようlost_assert（S、G、RPT、I）== TRUE}"
    },
    {
      "indent": 3,
      "text": "The set \"lost_assert(S,G)\" is the set of all interfaces on which the router has received (S,G) joins but has lost an (S,G) assert. The macro lost_assert(S,G,I) is defined in Section 4.6.5.",
      "ja": "セット「lost_assert（S、G）」は、ルータが受信したすべてのインタフェースのセット（S、G）が加入されているが、（S、G）アサートを失っています。マクロlost_assert（S、G、I）は、セクション4.6.5で定義されています。"
    },
    {
      "indent": 3,
      "text": "lost_assert(S,G) = { all interfaces I such that lost_assert(S,G,I) == TRUE }",
      "ja": "lost_assert（S、G）= {すべてのインタフェースはIようlost_assert（S、G、I）== TRUE}"
    },
    {
      "indent": 3,
      "text": "The following pseudocode macro definitions are also used in many places in the specification. Basically, RPF' is the RPF neighbor towards an RP or source unless a PIM-Assert has overridden the normal choice of neighbor.",
      "ja": "次の擬似コードマクロ定義はまた、仕様の多くの場所で使用されています。 PIM-アサートが隣人の通常の選択をオーバーライドしている場合を除き基本的には、RPFは、」RPまたはソースへのRPF隣人です。"
    },
    {
      "indent": 5,
      "text": "neighbor RPF'(*,G) { if ( I_Am_Assert_Loser(*, G, RPF_interface(RP(G))) ) { return AssertWinner(*, G, RPF_interface(RP(G)) ) } else { return NBR( RPF_interface(RP(G)), MRIB.next_hop( RP(G) ) ) } }",
      "ja": "隣接RPF '（*、G）{（）I_Am_Assert_Loser（*、G、RPF_interface（RP（G）））であれば{AssertWinnerを返す（G、*、RPF_interface（RP（G）））}他{（RPF_interface（NBRを返しますRP（G））、MRIB.next_hop（RP（G）））}}"
    },
    {
      "indent": 5,
      "text": "neighbor RPF'(S,G,rpt) { if( I_Am_Assert_Loser(S, G, RPF_interface(RP(G)) ) ) { return AssertWinner(S, G, RPF_interface(RP(G)) ) } else { return RPF'(*,G) } } neighbor RPF'(S,G) { if ( I_Am_Assert_Loser(S, G, RPF_interface(S) )) { return AssertWinner(S, G, RPF_interface(S) ) } else { return NBR( RPF_interface(S), MRIB.next_hop( S ) ) } }",
      "ja": "隣接RPF '（S、G、RPT）{IF（I_Am_Assert_Loser（S、G、RPF_interface（RP（G））））{戻りAssertWinner（S、Gは、RP​​F_interface（RP（G）））}他{RPFを返します' （*、G）}}隣接RPF '（S、G）{IF（I_Am_Assert_Loser（S、G、RPF_interface（S）））{AssertWinnerを返す（S、G、RPF_interface（S））}他{NBR（RPF_interfaceを返します（S）、MRIB.next_hop（S））}}"
    },
    {
      "indent": 3,
      "text": "RPF'(*,G) and RPF'(S,G) indicate the neighbor from which data packets should be coming and to which joins should be sent on the RP tree and SPT, respectively.",
      "ja": "RPF「（*、G）とRPF」（S、G）を示すデータパケットが来なければならないとどの参加するために、そこから隣人は、それぞれ、RPツリーとSPT上で送信されるべきです。"
    },
    {
      "indent": 3,
      "text": "RPF'(S,G,rpt) is basically RPF'(*,G) modified by the result of an Assert(S,G) on RPF_interface(RP(G)). In such a case, packets from S will be originating from a different router than RPF'(*,G). If we only have active (*,G) Join state, we need to accept packets from RPF'(S,G,rpt) and add a Prune(S,G,rpt) to the periodic Join(*,G) messages that we send to RPF'(*,G) (see Section 4.5.8).",
      "ja": "RPF '（S、G、RPT）は、基本的にRPFである'（*、G）RPF_interface（RP（G））にアサート（S、G）の結果によって修飾します。このような場合には、Sからのパケットは、RPF '（*、G）とは異なるルータから発信されるであろう。我々は唯一の（*、G）に参加アクティブ状態を持っている場合は、私たちは '（S、G、RPT）をRPFからのパケットを受け入れ、定期的な参加（*、G）メッセージにプルーン（S、G、RPT）を追加する必要があること我々は（セクション4.5.8を参照）RPF '（*、G）に送ります。"
    },
    {
      "indent": 3,
      "text": "The function MRIB.next_hop( S ) returns an address of the next-hop PIM neighbor toward the host S, as indicated by the current MRIB. If S is directly adjacent, then MRIB.next_hop( S ) returns NULL. At the RP for G, MRIB.next_hop( RP(G)) returns NULL.",
      "ja": "現在のMRIBによって示されるように機能MRIB.next_hop（S）は、ホストSに向かって次のホップPIMネイバーのアドレスを返します。 Sが直接的に隣接している場合、MRIB.next_hop（S）はNULLを返します。 G用RPでは、MRIB.next_hop（RP（G））はNULLを返します。"
    },
    {
      "indent": 3,
      "text": "The function NBR( I, A ) uses information gathered through PIM Hello messages to map the IP address A of a directly connected PIM neighbor router on interface I to the primary IP address of the same router (Section 4.3.4). The primary IP address of a neighbor is the address that it uses as the source of its PIM Hello messages. Note that a neighbor's IP address may be non-unique within the PIM neighbor database due to scope issues. The address must, however, be unique amongst the addresses of all the PIM neighbors on a specific interface.",
      "ja": "機能NBR（I、A）は、同じルータ（4.3.4項）のプライマリIPアドレスへのインタフェースIに直接接続されているPIMネイバールータのIPアドレスAをマッピングするためにPIM Helloメッセージを通じて収集した情報を使用しています。隣人のプライマリIPアドレスは、そのPIM Helloメッセージの送信元として使用するアドレスです。ネイバーのIPアドレスは、スコープの問題に起因するPIMネイバーデータベース内の非一意であることに注意してください。アドレスは、しかし、特定のインターフェイス上のすべてのPIMネイバーのアドレスの中で一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "I_Am_Assert_Loser(S, G, I) is true if the Assert state machine (in Section 4.6.1) for (S,G) on Interface I is in \"I am Assert Loser\" state.",
      "ja": "インタフェースIの（S、G）のために（セクション4.6.1で）アサート状態マシンは \"私は敗者をアサートしています\" 状態である場合にI_Am_Assert_Loser（S、G、I）が真です。"
    },
    {
      "indent": 3,
      "text": "I_Am_Assert_Loser(*, G, I) is true if the Assert state machine (in Section 4.6.2) for (*,G) on Interface I is in \"I am Assert Loser\" state.",
      "ja": "インタフェースIのために（セクション4.6.2で）アサートステートマシン（*、G）は \"私は敗者をアサートしています\" 状態にある場合I_Am_Assert_Loserは（*、Gは、I）が真です。"
    },
    {
      "indent": 0,
      "text": "4.2. Data Packet Forwarding Rules",
      "section_title": true,
      "ja": "4.2。データパケット転送ルール"
    },
    {
      "indent": 3,
      "text": "The PIM-SM packet forwarding rules are defined below in pseudocode.",
      "ja": "PIM-SMパケット転送ルールは、擬似コードで以下に定義されます。"
    },
    {
      "indent": 6,
      "text": "iif is the incoming interface of the packet. S is the source address of the packet. G is the destination address of the packet (group address). RP is the address of the Rendezvous Point for this group. RPF_interface(S) is the interface the MRIB indicates would be used to route packets to S. RPF_interface(RP) is the interface the MRIB indicates would be used to route packets to RP, except at the RP when it is the decapsulation interface (the \"virtual\" interface on which register packets are received).",
      "ja": "IIFは、パケットの着信インターフェイスです。 Sは、パケットの送信元アドレスです。 Gはパケット（グループアドレス）の宛先アドレスです。 RPは、このグループのランデブーポイントのアドレスです。 RPF_interface（S）はMRIBそれはデカプセル化インターフェースであるRPを除いて、RPにパケットをルーティングするために使用される示すインタフェース（MRIBはS. RPF_interface（RP）にパケットをルーティングするために使用される示すインタフェースでありますパケットが受信されるどのレジスタの「仮想」インターフェイス）。"
    },
    {
      "indent": 3,
      "text": "First, we restart (or start) the Keepalive Timer if the source is on a directly connected subnet.",
      "ja": "ソースが直接接続されたサブネット上にある場合はまず、キープアライブタイマーは再起動（または開始します）。"
    },
    {
      "indent": 3,
      "text": "Second, we check to see if the SPTbit should be set because we've now switched from the RP tree to the SPT.",
      "ja": "第二に、我々は今、SPTにRPツリーから切り替えたのでSPTbitが設定されるべきかどうかを確認します。"
    },
    {
      "indent": 3,
      "text": "Next, we check to see whether the packet should be accepted based on TIB state and the interface that the packet arrived on.",
      "ja": "次に、我々はパケットがTIB状態とパケットが到着したインターフェイスに基づいて受け入れられるべきであるかどうかを確認します。"
    },
    {
      "indent": 3,
      "text": "If the packet should be forwarded using (S,G) state, we then build an outgoing interface list for the packet. If this list is not empty, then we restart the (S,G) state Keepalive Timer.",
      "ja": "パケットが（S、G）状態を使用して転送する必要がある場合、我々はその後、パケットの発信インターフェイスリストを構築します。このリストが空でない場合は、我々は（S、G）状態キープアライブタイマーを再起動します。"
    },
    {
      "indent": 3,
      "text": "If the packet should be forwarded using (*,*,RP) or (*,G) state, then we just build an outgoing interface list for the packet. We also check if we should initiate a switch to start receiving this source on a shortest path tree.",
      "ja": "パケットは（*、*、RP）または（*、G）状態を使用して転送する必要がある場合には、我々だけでパケットの発信インターフェイスリストを構築します。我々は最短パス木の上にこのソースの受信を開始するようにスイッチを開始する必要がある場合我々はまた、確認してください。"
    },
    {
      "indent": 3,
      "text": "Finally we remove the incoming interface from the outgoing interface list we've created, and if the resulting outgoing interface list is not empty, we forward the packet out of those interfaces.",
      "ja": "最後に、我々は我々が作成した発信インターフェイスリストから着信インターフェイスを削除し、そして得られた発信インターフェイスリストが空でない場合、我々は、これらのインタフェースのうち、パケットを転送します。"
    },
    {
      "indent": 3,
      "text": "On receipt of data from S to G on interface iif: if( DirectlyConnected(S) == TRUE AND iif == RPF_interface(S) ) { set KeepaliveTimer(S,G) to Keepalive_Period # Note: a register state transition or UpstreamJPState(S,G) # transition may happen as a result of restarting # KeepaliveTimer, and must be dealt with here. }",
      "ja": "IF（DirectlyConnected（S）== TRUE AND IIF == RPF_interface（S））{設定KeepaliveTimer（S、G）Keepalive_Period位注：：レジスタ状態遷移又はUpstreamJPState（IIFインターフェース上のGに対するSからデータを受信しますS、G）は＃遷移＃KeepaliveTimerを再起動の結果として起こるかもしれない、そしてここで扱われなければなりません。 }"
    },
    {
      "indent": 3,
      "text": "if( iif == RPF_interface(S) AND UpstreamJPState(S,G) == Joined AND inherited_olist(S,G) != NULL ) { set KeepaliveTimer(S,G) to Keepalive_Period }",
      "ja": "場合（IIF == RPF_interface（S）AND UpstreamJPState（S、G）==参加し、引き継いでいる_olist（S、G）！= NULL）{Keepalive_PeriodにKeepaliveTimer（S、G）を設定}"
    },
    {
      "indent": 3,
      "text": "Update_SPTbit(S,G,iif) oiflist = NULL",
      "ja": "Update_SPTbit（S、G、IIF）oiflist = NULL"
    },
    {
      "indent": 3,
      "text": "if( iif == RPF_interface(S) AND SPTbit(S,G) == TRUE ) { oiflist = inherited_olist(S,G) } else if( iif == RPF_interface(RP(G)) AND SPTbit(S,G) == FALSE) { oiflist = inherited_olist(S,G,rpt) CheckSwitchToSpt(S,G) } else { # Note: RPF check failed # A transition in an Assert FSM may cause an Assert(S,G) # or Assert(*,G) message to be sent out interface iif. # See section 4.6 for details. if ( SPTbit(S,G) == TRUE AND iif is in inherited_olist(S,G) ) { send Assert(S,G) on iif } else if ( SPTbit(S,G) == FALSE AND iif is in inherited_olist(S,G,rpt) { send Assert(*,G) on iif } }",
      "ja": "IF（IIF == RPF_interface（S）AND SPTbit（S、G）== TRUE）{oiflist =引き継いでいる_olist（S、G）}そうであれば（IIF == RPF_interface（RP（G））AND SPTbit（S、G） == FALSE）{oiflist =引き継いでいる_olistは（S、G、RPT）CheckSwitchToSpt（S、G）}他{＃注：RPFチェックがアサートFSMの遷移がアサート（S、G）＃またはアサートする（引き起こす可能性が＃失敗しました*、G）メッセージは、インターフェイスIIFを送出します。 ＃詳細については、セクション4.6を参照してください。 （TRUE AND IIF SPTbit（S、G）==が（S、G）引き継いでいる_olistにある）場合（SPTbit（S、G）は== FALSE AND IIFは引き継いでいる_olistであれば他{IIFにアサート（S、G）を送信} （S、G、RPT）} {IIFにアサート（*、G）を送信}"
    },
    {
      "indent": 3,
      "text": "oiflist = oiflist (-) iif forward packet on all interfaces in oiflist",
      "ja": "oiflist = oiflist（ - ）oiflist内のすべてのインターフェイス上でIIF転送パケット"
    },
    {
      "indent": 3,
      "text": "This pseudocode employs several \"macro\" definitions:",
      "ja": "この擬似コードは、いくつかの「マクロ」の定義を採用しています。"
    },
    {
      "indent": 3,
      "text": "DirectlyConnected(S) is TRUE if the source S is on any subnet that is directly connected to this router (or for packets originating on this router).",
      "ja": "ソースSは、直接ルータ（またはこのルータに発信パケット用）に接続されている任意のサブネット上にある場合DirectlyConnected（S）がTRUEです。"
    },
    {
      "indent": 3,
      "text": "inherited_olist(S,G) and inherited_olist(S,G,rpt) are defined in Section 4.1.",
      "ja": "引き継いでいる_olist（S、G）と引き継いでいる_olist（S、G、RPT）は、セクション4.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "Basically, inherited_olist(S,G) is the outgoing interface list for packets forwarded on (S,G) state, taking into account (*,*,RP) state, (*,G) state, asserts, etc.",
      "ja": "基本的に、引き継いでいる_olist（S、G）が（S、G）状態に転送されるパケットのための発信インターフェイスリスト等、アサート状態（*、*、RP）状態、（*、G）を考慮し、あります"
    },
    {
      "indent": 3,
      "text": "inherited_olist(S,G,rpt) is the outgoing interface list for packets forwarded on (*,*,RP) or (*,G) state, taking into account (S,G,rpt) prune state, asserts, etc.",
      "ja": "引き継いでいる_olist（S、G、RPT）を、（S、G、RPT）状態をプルーニング考慮し、アサート等（*、*、RP）に転送されるパケットまたは（*、G）ステートのための発信インターフェイスリストであります"
    },
    {
      "indent": 3,
      "text": "Update_SPTbit(S,G,iif) is defined in Section 4.2.2.",
      "ja": "Update_SPTbit（S、G、IIF）は、セクション4.2.2で定義されています。"
    },
    {
      "indent": 3,
      "text": "CheckSwitchToSpt(S,G) is defined in Section 4.2.1.",
      "ja": "CheckSwitchToSpt（S、G）は、セクション4.2.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "UpstreamJPState(S,G) is the state of the finite state machine in Section 4.5.7.",
      "ja": "UpstreamJPState（S、G）は、セクション4.5.7における有限状態機械の状態です。"
    },
    {
      "indent": 3,
      "text": "Keepalive_Period is defined in Section 4.10.",
      "ja": "Keepalive_Periodは4.10で定義されています。"
    },
    {
      "indent": 3,
      "text": "Data-triggered PIM-Assert messages sent from the above forwarding code should be rate-limited in a implementation-dependent manner.",
      "ja": "上記転送コードから送られてくるデータトリガPIMアサートメッセージは実装依存様式でレート制限されるべきです。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Last-Hop Switchover to the SPT",
      "section_title": true,
      "ja": "4.2.1。 SPTへのスイッチオーバー最終ホップ"
    },
    {
      "indent": 3,
      "text": "In Sparse-Mode PIM, last-hop routers join the shared tree towards the RP. Once traffic from sources to joined groups arrives at a last-hop router, it has the option of switching to receive the traffic on a shortest path tree (SPT).",
      "ja": "スパースモードPIMでは、ラストホップルータはRPに向けて共有ツリーに参加します。参加グループへのソースからのトラフィックが最後のホップルータに到着すると、それは最短パスツリー（SPT）上のトラフィックを受信するための切り替えのオプションがあります。"
    },
    {
      "indent": 3,
      "text": "The decision for a router to switch to the SPT is controlled as follows:",
      "ja": "次のようにSPTに切り替えるルータの決定が制御されます。"
    },
    {
      "indent": 5,
      "text": "void CheckSwitchToSpt(S,G) { if ( ( pim_include(*,G) (-) pim_exclude(S,G) (+) pim_include(S,G) != NULL ) AND SwitchToSptDesired(S,G) ) { # Note: Restarting the KAT will result in the SPT switch set KeepaliveTimer(S,G) to Keepalive_Period } }",
      "ja": "（！ - ）pim_exclude（S、G）（+）pim_include（S、G）= NULL）AND SwitchToSptDesired（S、G）（pim_include（*、G）（）{＃注CheckSwitchToSpt（S、G）{場合は無効：KATを再起動するとKeepaliveTimer Keepalive_Periodに（S、G）}}設定SPTスイッチもたらします"
    },
    {
      "indent": 3,
      "text": "SwitchToSptDesired(S,G) is a policy function that is implementation defined. An \"infinite threshold\" policy can be implemented by making SwitchToSptDesired(S,G) return false all the time. A \"switch on first packet\" policy can be implemented by making SwitchToSptDesired(S,G) return true once a single packet has been received for the source and group.",
      "ja": "SwitchToSptDesired（S、G）は、実装が定義されているポリシー関数です。 「無限の閾値」ポリシーは、すべての時間をfalseを返すSwitchToSptDesired（S、G）を行うことにより実現することができます。ポリシー「最初のパケットのスイッチ」は、単一のパケットがソースとグループに対して受信された後SwitchToSptDesired（S、G）がtrueを返すことによって実現することができます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Setting and Clearing the (S,G) SPTbit",
      "section_title": true,
      "ja": "4.2.2。設定及び（S、G）をクリアSPTbit"
    },
    {
      "indent": 3,
      "text": "The (S,G) SPTbit is used to distinguish whether to forward on (*,*,RP)/(*,G) or on (S,G) state. When switching from the RP tree to the source tree, there is a transition period when data is arriving due to upstream (*,*,RP)/(*,G) state while upstream (S,G) state is being established, during which time a router should continue to forward only on (*,*,RP)/(*,G) state. This prevents temporary black-holes that would be caused by sending a Prune(S,G,rpt) before the upstream (S,G) state has finished being established.",
      "ja": "（S、G）SPTbitは（*、*、RP）/（*、G）または（S、G）ステートオンに転送するかどうかを区別するために使用されます。ソースツリーにRPツリーから切り替えるときに上流（S、G）状態の間、確立されている間にデータが（*、*、RP）/（*、G）ステートを上流による到着したとき、移行期間がありますその時間のルータは（*、*、RP）/（*、G）状態に転送するために継続すべきです。これは、アップストリーム（S、G）状態が確立される前に終了したプルーン（S、G、RPT）を送信することに起因する一時的なブラックホールを防止します。"
    },
    {
      "indent": 3,
      "text": "Thus, when a packet arrives, the (S,G) SPTbit is updated as follows:",
      "ja": "パケットが到着したときに次のようにこのようにして、（S、G）SPTbitが更新されます。"
    },
    {
      "indent": 5,
      "text": "void Update_SPTbit(S,G,iif) { if ( iif == RPF_interface(S) AND JoinDesired(S,G) == TRUE AND ( DirectlyConnected(S) == TRUE OR RPF_interface(S) != RPF_interface(RP(G)) OR inherited_olist(S,G,rpt) == NULL OR ( ( RPF'(S,G) == RPF'(*,G) ) AND ( RPF'(S,G) != NULL ) ) OR ( I_Am_Assert_Loser(S,G,iif) ) { Set SPTbit(S,G) to TRUE } }",
      "ja": "空Update_SPTbit（S、G、IIF）{場合（IIF == RPF_interface（S）AND TRUE JoinDesired（S、G）== AND（DirectlyConnected（S）== TRUE OR RPF_interface（S）！= RPF_interface（RP（G ））OR引き継いでいる_olist（S、G、RPT）== NULL OR（（RPF '（S、G）== RPF'（*、G））AND（RPF '（S、G）！= NULL））OR（ I_Am_Assert_Loser（S、G、IIF））{trueに設定SPTbit（S、G）}}"
    },
    {
      "indent": 3,
      "text": "Additionally, a router can set SPTbit(S,G) to TRUE in other cases, such as when it receives an Assert(S,G) on RPF_interface(S) (see Section 4.6.1).",
      "ja": "また、ルータ（セクション4.6.1を参照）は、それがRPF_interface（S）上にアサート（S、G）を受信したときのように、他の場合にはTRUEにSPTbit（S、G）を設定することができます。"
    },
    {
      "indent": 3,
      "text": "JoinDesired(S,G) is defined in Section 4.5.7 and indicates whether we have the appropriate (S,G) Join state to wish to send a Join(S,G) upstream.",
      "ja": "JoinDesired（S、G）は、セクション4.5.7で定義されており、我々は適切な（S、G）上流の参加（S、G）を送信したいする状態への参加を持っているかどうかを示しています。"
    },
    {
      "indent": 3,
      "text": "Basically, Update_SPTbit will set the SPTbit if we have the appropriate (S,G) join state, and if the packet arrived on the correct upstream interface for S, and if one or more of the following conditions applies:",
      "ja": "私たちは、パケットがSの正しいアップストリームインターフェイスに到着した場合は、適切な（S、G）は状態に参加し、持っている場合は、次の条件の1つ以上が当てはまる場合は基本的に、Update_SPTbitはSPTbitを設定します："
    },
    {
      "indent": 3,
      "text": "1. The source is directly connected, in which case the switch to the SPT is a no-op.",
      "ja": "1.ソースが直接SPTへのスイッチは何もしません、その場合、接続されています。"
    },
    {
      "indent": 3,
      "text": "2. The RPF interface to S is different from the RPF interface to the RP. The packet arrived on RPF_interface(S), and so the SPT must have been completed.",
      "ja": "2. SへのRPFインターフェイスはRPへのRPFインターフェイスは異なっています。パケットはRPF_interface（S）に到着し、そのSPTが完了している必要があります。"
    },
    {
      "indent": 3,
      "text": "3. Noone wants the packet on the RP tree.",
      "section_title": true,
      "ja": "3.ヌーンはRPツリー上のパケットを望んでいます。"
    },
    {
      "indent": 3,
      "text": "4. RPF'(S,G) == RPF'(*,G). In this case, the router will never be able to tell if the SPT has been completed, so it should just switch immediately.",
      "ja": "4. RPF '（S、G）== RPF'（*、G）。この場合、ルータは、SPTが完了している場合伝えることができることはありませんので、それだけですぐに切り替える必要があります。"
    },
    {
      "indent": 3,
      "text": "In the case where the RPF interface is the same for the RP and for S, but RPF'(S,G) and RPF'(*,G) differ, we wait for an Assert(S,G), which indicates that the upstream router with (S,G) state believes the SPT has been completed. However, item (3) above is needed because there may not be any (*,G) state to trigger an Assert(S,G) to happen.",
      "ja": "RPFインターフェイスはRPおよびSについても同様であるが、RPF「（S、G）とRPF」（*、G）が異なる場合には、我々は示しアサート（S、G）、待ちます（S、G）状態と、上流ルータがSPTが完了したと考えています。起こるアサート（S、G）をトリガするために、任意の（*、G）ステートが存在しないためしかし、上記の項目（3）が必要です。"
    },
    {
      "indent": 3,
      "text": "The SPTbit is cleared in the (S,G) upstream state machine (see Section 4.5.7) when JoinDesired(S,G) becomes FALSE.",
      "ja": "JoinDesired（S、G）がFALSEになったときSPTbitは（S、G）上流の状態マシンでクリアされる（セクション4.5.7参照）。"
    },
    {
      "indent": 0,
      "text": "4.3. Designated Routers (DR) and Hello Messages",
      "section_title": true,
      "ja": "4.3。指定ルータ（DR）とhelloメッセージ"
    },
    {
      "indent": 3,
      "text": "A shared-media LAN like Ethernet may have multiple PIM-SM routers connected to it. A single one of these routers, the DR, will act on behalf of directly connected hosts with respect to the PIM-SM protocol. Because the distinction between LANs and point-to-point interfaces can sometimes be blurred, and because routers may also have multicast host functionality, the PIM-SM specification makes no distinction between the two. Thus, DR election will happen on all interfaces, LAN or otherwise.",
      "ja": "イーサネットなどの共有メディアLANは、それに接続された複数のPIM-SMルータを有することができます。これらのルータの単一のもの、DRは、PIM-SMプロトコルに対して直接接続されたホストに代わって行動します。 LANおよびポイントツーポイントインターフェイスとの間の区別が時々ぼかすことができ、ルータは、マルチキャストホスト機能を有することができるので、PIM-SM仕様は、二つを区別しないからです。したがって、DRの選出は、すべてのインターフェイス、LANまたはそれ以外で発生します。"
    },
    {
      "indent": 3,
      "text": "DR election is performed using Hello messages. Hello messages are also the way that option negotiation takes place in PIM, so that additional functionality can be enabled, or parameters tuned.",
      "ja": "DRの選出は、Helloメッセージを使用して行われます。 helloメッセージは、追加機能が有効、またはパラメータを調整することができるように、オプションのネゴシエーションは、PIMで行われること方法です。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Sending Hello Messages",
      "section_title": true,
      "ja": "4.3.1。 helloメッセージを送信"
    },
    {
      "indent": 3,
      "text": "PIM Hello messages are sent periodically on each PIM-enabled interface. They allow a router to learn about the neighboring PIM routers on each interface. Hello messages are also the mechanism used to elect a Designated Router (DR), and to negotiate additional capabilities. A router must record the Hello information received from each PIM neighbor.",
      "ja": "PIM Helloメッセージは、各PIM対応インターフェイス上で定期的に送信されます。彼らは、ルータが各インターフェイス上の隣接PIMルータについて学ぶことができます。ハローメッセージは、指定ルータ（DR）を選出し、追加機能をネゴシエートするために使用されるメカニズムです。ルータは、各PIMネイバーから受信したHello情報を記録しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Hello messages MUST be sent on all active interfaces, including physical point-to-point links, and are multicast to the 'ALL-PIM-ROUTERS' group address ('224.0.0.13' for IPv4 and 'ff02::d' for IPv6).",
      "ja": "ハローメッセージは、物理的なポイントツーポイントリンクを含む、すべてのアクティブなインターフェイス上で送信され、そして（「224.0.0.13」のIPv4および「FF02 :: D」IPv6のための「ALL-PIM-ルータのグループアドレスにマルチキャストされなければなりません）。"
    },
    {
      "indent": 5,
      "text": "We note that some implementations do not send Hello messages on point-to-point interfaces. This is non-compliant behavior. A compliant PIM router MUST send Hello messages, even on point-to-point interfaces.",
      "ja": "私たちは、いくつかの実装は、ポイントツーポイントインターフェイス上でHelloメッセージを送信しないことに注意してください。これは、非準拠の動作です。対応のPIMルータでもポイントツーポイントインターフェイス上で、Helloメッセージを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "A per-interface Hello Timer (HT(I)) is used to trigger sending Hello messages on each active interface. When PIM is enabled on an interface or a router first starts, the Hello Timer of that interface is set to a random value between 0 and Triggered_Hello_Delay. This prevents synchronization of Hello messages if multiple routers are powered on simultaneously. After the initial randomized interval, Hello messages must be sent every Hello_Period seconds. The Hello Timer should not be reset except when it expires.",
      "ja": "インターフェイス単位のハロー・タイマ（HT（I））は、各アクティブインターフェイス上でハローメッセージの送信トリガするために使用されます。 PIMがインターフェイスまたはルータ最初の始まりで有効になっている場合は、そのインターフェイスのhelloタイマーが0とTriggered_Hello_Delay間のランダムな値に設定されています。複数のルータが同時に電源が入っている場合、これはHelloメッセージの同期化を防ぐことができます。最初の無作為化間隔の後、helloメッセージは、すべてのHello_Period秒を送信する必要があります。こんにちはタイマーは、それが期限切れになったときを除いて、リセットすべきではありません。"
    },
    {
      "indent": 3,
      "text": "Note that neighbors will not accept Join/Prune or Assert messages from a router unless they have first heard a Hello message from that router. Thus, if a router needs to send a Join/Prune or Assert message on an interface on which it has not yet sent a Hello message with the currently configured IP address, then it MUST immediately send the relevant Hello message without waiting for the Hello Timer to expire, followed by the Join/Prune or Assert message.",
      "ja": "彼らが最初にそのルータからHelloメッセージを聞いたことがない限り、隣人が参加/プルーンを受け入れるか、またはルータからのメッセージを主張しないことに注意してください。したがって、ルータが参加/プルーンを送信するか、それはまだ現在設定されているIPアドレスを持つHelloメッセージを送信していない、それはすぐにhelloタイマーを待たずに、関連のHelloメッセージを送らなければなりませんしたインターフェイス上でメッセージをアサートする必要がある場合期限切れになるように、参加/プルーンまたはアサートメッセージが続きます。"
    },
    {
      "indent": 3,
      "text": "The DR_Priority Option allows a network administrator to give preference to a particular router in the DR election process by giving it a numerically larger DR Priority. The DR_Priority Option SHOULD be included in every Hello message, even if no DR Priority is explicitly configured on that interface. This is necessary because priority-based DR election is only enabled when all neighbors on an interface advertise that they are capable of using the DR_Priority Option. The default priority is 1.",
      "ja": "DR_Priorityオプションは、ネットワーク管理者はそれを数値的に大きなDRの優先順位を与えることによって、DR選出プロセスにおける特定のルータを優先することができます。 DR_PriorityオプションにはDR優先順位が明示的にそのインターフェイスに設定されていない場合でも、すべてのHelloメッセージに含まれるべきです。インターフェイス上のすべてのネイバーは、彼らがDR_Priorityオプションを使用することができることを宣伝する際に、優先度ベースのDRの選出がのみ有効になっているため、これが必要です。デフォルトの優先度は1です。"
    },
    {
      "indent": 3,
      "text": "The Generation_Identifier (GenID) Option SHOULD be included in all Hello messages. The GenID option contains a randomly generated 32-bit value that is regenerated each time PIM forwarding is started or restarted on the interface, including when the router itself restarts. When a Hello message with a new GenID is received from a neighbor, any old Hello information about that neighbor SHOULD be discarded and superseded by the information from the new Hello message. This may cause a new DR to be chosen on that interface.",
      "ja": "Generation_Identifier（られたGenID）オプションは、すべてのHelloメッセージに含まれるべきです。られたGenIDオプションは、各時間PIM転送がルータ自体が再起動したときなど、インターフェイス上で起動または再起動する再生成されるランダムに生成された32ビット値を含みます。新しいられたGenIDでHelloメッセージがネイバーから受信した場合、その隣人についての古いこんにちは情報は破棄され、新しいHelloメッセージからの情報に取って代わられるべきです。これは、新しいDRは、そのインターフェイス上で選択される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The LAN Prune Delay Option SHOULD be included in all Hello messages sent on multi-access LANs. This option advertises a router's capability to use values other than the defaults for the Propagation_Delay and Override_Interval, which affect the setting of the Prune-Pending, Upstream Join, and Override Timers (defined in Section 4.10).",
      "ja": "LANプルーン遅延オプションは、マルチアクセスLAN上で送信されるすべてのHelloメッセージに含まれるべきです。このオプションは、プルーン、保留中の設定に影響を与えるPROPAGATION_DELAYとOverride_Intervalのデフォルト以外の値を使用するようにルータの機能をアドバタイズし、上流参加、およびタイマーをオーバーライドします（4.10節で定義されています）。"
    },
    {
      "indent": 3,
      "text": "The Address List Option advertises all the secondary addresses associated with the source interface of the router originating the message. The option MUST be included in all Hello messages if there are secondary addresses associated with the source interface and MAY be omitted if no secondary addresses exist.",
      "ja": "アドレス一覧のオプションは、メッセージを発信するルータの送信元インターフェイスに関連付けられているすべてのセカンダリアドレスをアドバタイズします。オプションでは、送信元インターフェイスに関連付けられているセカンダリアドレスがある場合は、すべてのHelloメッセージに含まれなければならないと何のセカンダリアドレスが存在しない場合は省略されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "To allow new or rebooting routers to learn of PIM neighbors quickly, when a Hello message is received from a new neighbor, or a Hello message with a new GenID is received from an existing neighbor, a new Hello message should be sent on this interface after a randomized delay between 0 and Triggered_Hello_Delay. This triggered message need not change the timing of the scheduled periodic message. If a router needs to send a Join/Prune to the new neighbor or send an Assert message in response to an Assert message from the new neighbor before this randomized delay has expired, then it MUST immediately send the relevant Hello message without waiting for the Hello Timer to expire, followed by the Join/Prune or Assert message. If it does not do this, then the new neighbor will discard the Join/Prune or Assert message.",
      "ja": "Helloメッセージは、既存のネイバーから受信された新しい隣人、または新規られたGenIDとHelloメッセージから受信したときに、新規または再起動するルータが迅速PIMネイバーの学ぶことができるようにするには、新しいHelloメッセージがこのインタフェースの後に送られるべきです0とTriggered_Hello_Delay間無作為化遅延。このトリガーメッセージは、スケジュール定期的なメッセージのタイミングを変更する必要はありません。ルータが参加/この無作為化遅延が経過する前に、それはすぐにこんにちはを待たずに、関連のHelloメッセージを送らなければなりません新しいネイバーにプルーニングしたり、新しい隣人からのAssertメッセージに応答してアサートメッセージを送信を送信する必要がある場合有効期限が切れるようにタイマー、参加/プルーンが続いたり、メッセージをアサートします。それはこれをしない場合、新しい隣人は参加/プルーンを破棄するか、メッセージをアサートします。"
    },
    {
      "indent": 3,
      "text": "Before an interface goes down or changes primary IP address, a Hello message with a zero HoldTime should be sent immediately (with the old IP address if the IP address changed). This will cause PIM neighbors to remove this neighbor (or its old IP address) immediately. After an interface has changed its IP address, it MUST send a Hello message with its new IP address. If an interface changes one of its secondary IP addresses, a Hello message with an updated Address_List option and a non-zero HoldTime should be sent immediately. This will cause PIM neighbors to update this neighbor's list of secondary addresses immediately.",
      "ja": "インターフェイスがダウンしたり、変更のプライマリIPアドレス行く前に（IPアドレスが変更された場合、古いIPアドレスを使用して）、ゼロたHoldTimeとHelloメッセージを直ちに送信する必要があります。これは、PIMネイバーはすぐにこの隣人（またはその古いIPアドレス）を削除します。インターフェイスは、そのIPアドレスを変更した後は、その新しいIPアドレスでHelloメッセージを送らなければなりません。インターフェースは、そのセカンダリIPアドレスのいずれかを変更した場合、更新ADDRESS_LISTオプションと非ゼロのHoldTimeとHelloメッセージを直ちに送信する必要があります。これは、PIMネイバーがすぐにセカンダリアドレスのこの隣人のリストを更新するようになります。"
    },
    {
      "indent": 0,
      "text": "4.3.2. DR Election",
      "section_title": true,
      "ja": "4.3.2。 DR選挙"
    },
    {
      "indent": 3,
      "text": "When a PIM Hello message is received on interface I, the following information about the sending neighbor is recorded:",
      "ja": "PIM Helloメッセージが、私はインターフェイス上で受信されると、送信隣人について、以下の情報が記録されます。"
    },
    {
      "indent": 5,
      "text": "neighbor.interface The interface on which the Hello message arrived.",
      "ja": "Helloメッセージが到着したインターフェイスをneighbor.interface。"
    },
    {
      "indent": 5,
      "text": "neighbor.primary_ip_address The IP address that the PIM neighbor used as the source address of the Hello message.",
      "ja": "neighbor.primary_ip_address PIMネイバーがHelloメッセージの送信元アドレスとして使用するIPアドレス。"
    },
    {
      "indent": 5,
      "text": "neighbor.genid The Generation ID of the PIM neighbor.",
      "ja": "neighbor.genid PIMネイバーの生成ID。"
    },
    {
      "indent": 5,
      "text": "neighbor.dr_priority The DR Priority field of the PIM neighbor, if it is present in the Hello message.",
      "ja": "neighbor.dr_priority PIMネイバーのDR Priorityフィールド、それはHelloメッセージに存在している場合。"
    },
    {
      "indent": 5,
      "text": "neighbor.dr_priority_present A flag indicating if the DR Priority field was present in the Hello message.",
      "ja": "DRプライオリティフィールドは、Helloメッセージに存在したかどうかを示すフラグをneighbor.dr_priority_present。"
    },
    {
      "indent": 5,
      "text": "neighbor.timeout A timer value to time out the neighbor state when it becomes stale, also known as the Neighbor Liveness Timer.",
      "ja": "また、近隣ライブネスタイマーとして知られ、それは古くなった隣人の状態アウト時にタイマー値、neighbor.timeout。"
    },
    {
      "indent": 10,
      "text": "The Neighbor Liveness Timer (NLT(N,I)) is reset to\nHello_Holdtime (from the Hello Holdtime option) whenever a\nHello message is received containing a Holdtime option, or to\nDefault_Hello_Holdtime if the Hello message does not contain\nthe Holdtime option.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Neighbor state is deleted when the neighbor timeout expires.",
      "ja": "隣人タイムアウトが満了したときに隣人状態が削除されます。"
    },
    {
      "indent": 3,
      "text": "The function for computing the DR on interface I is:",
      "ja": "インターフェイスIにDRを計算するための関数です。"
    },
    {
      "indent": 5,
      "text": "host DR(I) { dr = me for each neighbor on interface I { if ( dr_is_better( neighbor, dr, I ) == TRUE ) { dr = neighbor } } return dr }",
      "ja": "ホストDR（I）{DR =私インターフェイス上の各隣接するためのI {IF（dr_is_better（隣人、DR、I）== TRUE）{DR =隣接}}戻りDR}"
    },
    {
      "indent": 3,
      "text": "The function used for comparing DR \"metrics\" on interface I is:",
      "ja": "インタフェースIにDR「メトリクス」を比較するために使用する関数は次のようになります。"
    },
    {
      "indent": 5,
      "text": "bool dr_is_better(a,b,I) { if( there is a neighbor n on I for which n.dr_priority_present is false ) { return a.primary_ip_address > b.primary_ip_address } else { return ( a.dr_priority > b.dr_priority ) OR ( a.dr_priority == b.dr_priority AND a.primary_ip_address > b.primary_ip_address ) } }",
      "ja": "ブールdr_is_better（A、B、I）{{戻りa.primary_ip_address> b.primary_ip_address}他{リターン（a.dr_priority> b.dr_priority）（n.dr_priority_presentが偽されたIに隣接nが存在する）場合、または（a.dr_priority == b.dr_priority AND a.primary_ip_address> b.primary_ip_address）}}"
    },
    {
      "indent": 3,
      "text": "The trivial function I_am_DR(I) is defined to aid readability:",
      "ja": "些細な機能I_am_DR（I）は、読みやすさを支援するために定義されています。"
    },
    {
      "indent": 5,
      "text": "bool I_am_DR(I) { return DR(I) == me }",
      "ja": "BOOL I_am_DR（I）{DR（I）を返す==私}"
    },
    {
      "indent": 3,
      "text": "The DR Priority is a 32-bit unsigned number, and the numerically larger priority is always preferred. A router's idea of the current DR on an interface can change when a PIM Hello message is received, when a neighbor times out, or when a router's own DR Priority changes. If the router becomes the DR or ceases to be the DR, this will normally cause the DR Register state machine to change state. Subsequent actions are determined by that state machine.",
      "ja": "DR優先順位は、32ビットの符号なしの数であり、数値的により大きな優先順位を常に好ましいです。 PIM Helloメッセージは、ときネイバータイムアウトする場合、またはルータ自身のDR優先順位の変更を受信したときのインターフェイスの現在のDRのルータのアイデアは変更することができます。ルータがDRになるか、またはDRでなくなった場合、これは通常、DRレジスタのステートマシンの状態が変化します。後続のアクションは、その状態マシンによって決定されます。"
    },
    {
      "indent": 5,
      "text": "We note that some PIM implementations do not send Hello messages on point-to-point interfaces and thus cannot perform DR election on such interfaces. This is non-compliant behavior. DR election MUST be performed on ALL active PIM-SM interfaces.",
      "ja": "我々はいくつかのPIM実装は、ポイントツーポイントインターフェイス上でHelloメッセージを送信しないので、そのようなインタフェースにDR選挙を行うことができないことに注意してください。これは、非準拠の動作です。 DR選挙は、すべてのアクティブPIM-SMのインターフェイス上で実行されなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Reducing Prune Propagation Delay on LANs",
      "section_title": true,
      "ja": "4.3.3。 LAN上プルーン伝搬遅延を削減"
    },
    {
      "indent": 3,
      "text": "In addition to the information recorded for the DR Election, the following per neighbor information is obtained from the LAN Prune Delay Hello option:",
      "ja": "DR選挙のために記録された情報に加えて、以下の隣あたりの情報は、LANプルーン遅延こんにちはオプションから取得されます。"
    },
    {
      "indent": 5,
      "text": "neighbor.lan_prune_delay_present A flag indicating if the LAN Prune Delay option was present in the Hello message.",
      "ja": "LANプルーンDelayオプションは、Helloメッセージに存在したかどうかを示すフラグをneighbor.lan_prune_delay_present。"
    },
    {
      "indent": 5,
      "text": "neighbor.tracking_support A flag storing the value of the T bit in the LAN Prune Delay option if it is present in the Hello message. This indicates the neighbor's capability to disable Join message suppression.",
      "ja": "それはHelloメッセージに存在する場合LANプルーン遅延オプションでTビットの値を格納するフラグneighbor.tracking_support。これは、メッセージ抑制に参加し無効にする隣人の能力を示します。"
    },
    {
      "indent": 5,
      "text": "neighbor.propagation_delay The Propagation Delay field of the LAN Prune Delay option (if present) in the Hello message.",
      "ja": "HelloメッセージにおけるLANプルーンDelayオプション（存在する場合）の伝播遅延フィールドをneighbor.propagation_delay。"
    },
    {
      "indent": 5,
      "text": "neighbor.override_interval The Override_Interval field of the LAN Prune Delay option (if present) in the Hello message.",
      "ja": "HelloメッセージにおけるLANプルーンDelayオプション（存在する場合）のOverride_Intervalフィールドneighbor.override_interval。"
    },
    {
      "indent": 3,
      "text": "The additional state described above is deleted along with the DR neighbor state when the neighbor timeout expires.",
      "ja": "近隣タイムアウトが満了すると、上述の追加の状態は、DR隣人状態と共に削除されます。"
    },
    {
      "indent": 3,
      "text": "Just like the DR_Priority option, the information provided in the LAN Prune Delay option is not used unless all neighbors on a link advertise the option. The function below computes this state:",
      "ja": "リンク上のすべてのネイバーがオプションを宣伝しない限り、ちょうどDR_Priorityオプションと同様に、LANプルーンDelayオプションで提供される情報は使用されません。以下の関数は、この状態を計算します。"
    },
    {
      "indent": 5,
      "text": "bool lan_delay_enabled(I) { for each neighbor on interface I { if ( neighbor.lan_prune_delay_present == false ) { return false } } return true }",
      "ja": "BOOL lan_delay_enabled（I）{Iは{場合（neighbor.lan_prune_delay_presentは==偽）{falseを返すインターフェイス上の各隣接ため}} trueを返します}"
    },
    {
      "indent": 3,
      "text": "The Propagation Delay inserted by a router in the LAN Prune Delay option expresses the expected message propagation delay on the link and should be configurable by the system administrator. It is used by upstream routers to figure out how long they should wait for a Join override message before pruning an interface.",
      "ja": "LANプルーンDelayオプションでルータによって挿入された伝搬遅延はリンク上で予想されるメッセージの伝播遅延を発現し、システム管理者が設定する必要があります。彼らはインターフェイスを剪定する前に、参加オーバーライド・メッセージを待機する時間を把握するために、上流ルータによって使用されます。"
    },
    {
      "indent": 3,
      "text": "PIM implementers should enforce a lower bound on the permitted values for this delay to allow for scheduling and processing delays within their router. Such delays may cause received messages to be processed later as well as triggered messages to be sent later than intended. Setting this Propagation Delay to too low a value may result in temporary forwarding outages because a downstream router will not be able to override a neighbor's Prune message before the upstream neighbor stops forwarding.",
      "ja": "PIMの実装は、そのルータ内のスケジューリングや処理遅延を許可するには、この遅延のために許可された値に下限を強制すべきです。このような遅延は、受信したメッセージは、同様のメッセージをトリガとして、後に処理されるように意図したよりも後に送信される可能性があります。下流ルータが上流の隣人が転送を停止する前に、隣人のプルーンのメッセージを上書きすることはできませんので、低すぎる値は、一時的な転送の停止をもたらすことができるし、この伝播遅延を設定します。"
    },
    {
      "indent": 3,
      "text": "When all routers on a link are in a position to negotiate a Propagation Delay different from the default, the largest value from those advertised by each neighbor is chosen. The function for computing the Effective_Propagation_Delay of interface I is:",
      "ja": "リンク上のすべてのルータがデフォルトと異なる伝搬遅延を交渉する立場にある場合は、各隣接によってアドバタイズたものから最大値が選択されています。インタフェースのEffective_Propagation_Delayを計算するための関数がIであります："
    },
    {
      "indent": 5,
      "text": "time_interval Effective_Propagation_Delay(I) { if ( lan_delay_enabled(I) == false ) { return Propagation_delay_default } delay = Propagation_Delay(I) for each neighbor on interface I { if ( neighbor.propagation_delay > delay ) { delay = neighbor.propagation_delay } } return delay }",
      "ja": "TIME_INTERVAL Effective_Propagation_Delay（I）{IF（lan_delay_enabled（I）== false）を返す{Propagation_delay_default}遅延= PROPAGATION_DELAYインタフェースI {IF（neighbor.propagation_delay>遅延）{遅延= neighbor.propagation_delay}}戻りの各隣人のため（I）遅延}"
    },
    {
      "indent": 3,
      "text": "To avoid synchronization of override messages when multiple downstream routers share a multi-access link, sending of such messages is delayed by a small random amount of time. The period of randomization should represent the size of the PIM router population on the link. Each router expresses its view of the amount of randomization necessary in the Override Interval field of the LAN Prune Delay option.",
      "ja": "複数のダウンストリームルータがマルチアクセスリンクを共有する場合、オーバーライドメッセージの同期化を避けるために、このようなメッセージの送信は、時間の小さなランダム量だけ遅延されます。ランダム化の期間は、リンク上のPIMルータ人口の大きさを表している必要があります。各ルータはLANプルーンDelayオプションのオーバーライドIntervalフィールドの必要なランダム化の量のその見解を表現しています。"
    },
    {
      "indent": 3,
      "text": "When all routers on a link are in a position to negotiate an Override Interval different from the default, the largest value from those advertised by each neighbor is chosen. The function for computing the Effective Override Interval of interface I is:",
      "ja": "リンク上のすべてのルータがデフォルトと異なる上書き間隔を交渉する立場にある場合は、各隣接によってアドバタイズたものから最大値が選択されています。インタフェースIの間隔が有効なオーバーライドを計算するための機能："
    },
    {
      "indent": 5,
      "text": "time_interval Effective_Override_Interval(I) { if ( lan_delay_enabled(I) == false ) { return t_override_default } delay = Override_Interval(I) for each neighbor on interface I { if ( neighbor.override_interval > delay ) { delay = neighbor.override_interval } } return delay }",
      "ja": "TIME_INTERVAL Effective_Override_Interval（I）{IF（lan_delay_enabled（I）==偽）{戻りt_override_default}遅延= Override_Intervalインターフェイス上の各隣人のため（I）I {IF（neighbor.override_interval>遅延）{遅延= neighbor.override_interval}}リターン遅延}"
    },
    {
      "indent": 3,
      "text": "Although the mechanisms are not specified in this document, it is possible for upstream routers to explicitly track the join membership of individual downstream routers if Join suppression is disabled. A router can advertise its willingness to disable Join suppression by using the T bit in the LAN Prune Delay Hello option. Unless all PIM routers on a link negotiate this capability, explicit tracking and the disabling of the Join suppression mechanism are not possible. The function for computing the state of Suppression on interface I is:",
      "ja": "メカニズムはこの文書で指定されていないが、参加抑制が無効になっている場合は、上流のルータが明示的に個々のダウンストリームルータの参加メンバーシップを追跡することが可能です。ルータはLANプルーン遅延こんにちはオプションでTビットを使用することにより抑制に参加し無効にするその意欲を宣伝することができます。リンク上のすべてのPIMルータがこの機能を交渉する場合を除き、明示的なトラッキングや参加抑制機構の無効化はできません。インターフェイス上の抑制の状態を計算するための関数がIであります："
    },
    {
      "indent": 5,
      "text": "bool Suppression_Enabled(I) { if ( lan_delay_enabled(I) == false ) { return true } for each neighbor on interface I { if ( neighbor.tracking_support == false ) { return true } } return false }",
      "ja": "BOOL Suppression_Enabled（I）{IF（lan_delay_enabled（I）== false）を{Iは{場合（neighbor.tracking_supportは==偽）{trueを返す}} falseを返すインターフェイス上の各隣接ため} trueを返します}"
    },
    {
      "indent": 3,
      "text": "Note that the setting of Suppression_Enabled(I) affects the value of t_suppressed (see Section 4.10).",
      "ja": "（4.10節を参照）Suppression_Enabled（I）の設定がt_suppressedの値に影響することに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.3.4. Maintaining Secondary Address Lists",
      "section_title": true,
      "ja": "4.3.4。セカンダリアドレス一覧を維持"
    },
    {
      "indent": 3,
      "text": "Communication of a router's interface secondary addresses to its PIM neighbors is necessary to provide the neighbors with a mechanism for mapping next_hop information obtained through their MRIB to a primary address that can be used as a destination for Join/Prune messages. The mapping is performed through the NBR macro. The primary address of a PIM neighbor is obtained from the source IP address used in its PIM Hello messages. Secondary addresses are carried within the Hello message in an Address List Hello option. The primary address of the source interface of the router MUST NOT be listed within the Address List Hello option.",
      "ja": "そのPIM隣人にルータのインターフェイスのセカンダリアドレスの通信は、参加/プルーンのメッセージの宛先として使用することができますプライマリアドレスに自分のMRIBによって得られたマッピングNEXT_HOP情報のためのメカニズムと隣人を提供することが必要です。マッピングは、NBRマクロを介して行われます。 PIMネイバーのプライマリアドレスは、PIM Helloメッセージで使用される送信元IPアドレスから取得されます。セカンダリアドレスは、アドレス一覧のHelloオプションでHelloメッセージの中に運ばれます。ルータのソースインターフェイスのプライマリアドレスは、アドレス一覧のHelloオプションの中にリストされてはなりません。"
    },
    {
      "indent": 3,
      "text": "In addition to the information recorded for the DR Election, the following per neighbor information is obtained from the Address List Hello option:",
      "ja": "DR選挙のために記録された情報に加えて、以下の隣あたりの情報は、アドレス一覧のHelloオプションから取得されます。"
    },
    {
      "indent": 5,
      "text": "neighbor.secondary_address_list The list of secondary addresses used by the PIM neighbor on the interface through which the Hello message was transmitted.",
      "ja": "neighbor.secondary_address_list Helloメッセージが送信された介してインターフェイス上のPIMネイバーによって使用される二次アドレスのリスト。"
    },
    {
      "indent": 3,
      "text": "When processing a received PIM Hello message containing an Address List Hello option, the list of secondary addresses in the message completely replaces any previously associated secondary addresses for that neighbor. If a received PIM Hello message does not contain an Address List Hello option, then all secondary addresses associated with the neighbor must be deleted. If a received PIM Hello message contains an Address List Hello option that includes the primary address of the sending router in the list of secondary addresses (although this is not expected), then the addresses listed in the message, excluding the primary address, are used to update the associated secondary addresses for that neighbor.",
      "ja": "アドレス一覧のHelloオプションを含む受信PIM Helloメッセージを処理するとき、メッセージ中の二次アドレスのリストは、完全にその隣人のために以前に関連付けられているセカンダリアドレスを置き換えます。受信PIM Helloメッセージは、アドレス一覧のHelloオプションが含まれていない場合は、ネイバーに関連付けられたすべてのセカンダリアドレスを削除する必要があります。受信PIM Helloメッセージは、アドレス一覧のHello（これが期待されていないが）、二次アドレスのリストにある送信ルータのプライマリアドレスを含んオプションが含まれている場合は、そのメッセージに記載されているアドレスは、プライマリアドレスを除いて、使用されていますその隣人のための関連するセカンダリアドレスを更新します。"
    },
    {
      "indent": 3,
      "text": "All the advertised secondary addresses in received Hello messages must be checked against those previously advertised by all other PIM neighbors on that interface. If there is a conflict and the same secondary address was previously advertised by another neighbor, then only the most recently received mapping MUST be maintained, and an error message SHOULD be logged to the administrator in a rate-limited manner.",
      "ja": "こんにちは、受信したメッセージのすべての広告を出してセカンダリアドレスは、以前にそのインターフェイス上の他のすべてのPIMネイバーによってアドバタイズたものと照合しなければなりません。衝突と同一の二次アドレスがある場合は、以前に別の隣人によってアドバタイズした後、唯一の最も最近に受信されたマッピングを維持しなければならない、エラーメッセージがレート制限された方法で管理者にログインする必要があります。"
    },
    {
      "indent": 3,
      "text": "Within one Address List Hello option, all the addresses MUST be of the same address family. It is not permitted to mix IPv4 and IPv6 addresses within the same message. In addition, the address family of the fields in the message SHOULD be the same as the IP source and destination addresses of the packet header.",
      "ja": "1本のアドレス一覧こんにちはオプションの中で、すべてのアドレスが同じアドレスファミリーのものでなければなりません。同じメッセージ内のIPv4アドレスとIPv6アドレスを混在することは許されません。加えて、メッセージ内のフィールドのアドレスファミリーは、パケットヘッダのIP送信元アドレスと宛先アドレスと同じでなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4. PIM Register Messages",
      "section_title": true,
      "ja": "4.4。 PIM Registerメッセージ"
    },
    {
      "indent": 3,
      "text": "The Designated Router (DR) on a LAN or point-to-point link encapsulates multicast packets from local sources to the RP for the relevant group unless it recently received a Register-Stop message for that (S,G) or (*,G) from the RP. When the DR receives a Register-Stop message from the RP, it starts a Register-Stop Timer to maintain this state. Just before the Register-Stop Timer expires, the DR sends a Null-Register Message to the RP to allow the RP to refresh the Register-Stop information at the DR. If the Register-Stop Timer actually expires, the DR will resume encapsulating packets from the source to the RP.",
      "ja": "それは最近登録 - ストップそのためのメッセージ（S、G）または（*、Gを受けない限り、LAN又はポイントツーポイントリンク上の指定ルータ（DR）は、関連するグループのためのRPにローカルソースからマルチキャストパケットをカプセル化）RPから。 DRは、RPからRegister-Stopメッセージを受信すると、それはこの状態を維持するために登録するストップタイマーを開始します。登録ストップタイマーの期限が切れる直前に、DRはRPがDRで登録ストップ情報を更新できるようにするためにRPにヌル登録メッセージを送信します。登録ストップタイマーが実際に有効期限が切れた場合、DRはソースからRPにカプセル化したパケットを再開します。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Sending Register Messages from the DR",
      "section_title": true,
      "ja": "4.4.1。 DRからの登録メッセージの送信"
    },
    {
      "indent": 3,
      "text": "Every PIM-SM router has the capability to be a DR. The state machine below is used to implement Register functionality. For the purposes of specification, we represent the mechanism to encapsulate packets to the RP as a Register-Tunnel interface, which is added to or removed from the (S,G) olist. The tunnel interface then takes part in the normal packet forwarding rules as specified in Section 4.2.",
      "ja": "すべてのPIM-SMルータがDRすべき能力を持っています。以下のステートマシンは、登録機能を実装するために使用されます。明細書の目的のために、我々は、追加または（S、G）OLISTから除去されるレジスタトンネルインタフェースとしてRPにパケットをカプセル化するメカニズムを表します。セクション4.2で指定されたトンネルインターフェースは、通常のパケット転送ルールに関与します。"
    },
    {
      "indent": 3,
      "text": "If register state is maintained, it is maintained only for directly connected sources and is per-(S,G). There are four states in the DR's per-(S,G) Register state machine:",
      "ja": "レジスタ状態が維持される場合、それが直接接続されたソースに対してのみ維持され、（S、G）パーです。 DRのパー（S、G）ステートマシンを登録するには4つの状態があります。"
    },
    {
      "indent": 3,
      "text": "Join (J) The register tunnel is \"joined\" (the join is actually implicit, but the DR acts as if the RP has joined the DR on the tunnel interface).",
      "ja": "参加（J）レジスタトンネルは、（参加実際には暗黙的であるが、DRはRPトンネルインターフェイス上DRに参加しているかのように作用する）「接合」されます。"
    },
    {
      "indent": 3,
      "text": "Prune (P) The register tunnel is \"pruned\" (this occurs when a Register-Stop is received).",
      "ja": "（登録ストップを受信したときにこれが起こる）プルーン（P）レジスタトンネルは「剪定」されます。"
    },
    {
      "indent": 3,
      "text": "Join-Pending (JP) The register tunnel is pruned but the DR is contemplating adding it back.",
      "ja": "ジョイン・ペンディングレジスタトンネルがプルーニングされているが、DRに戻ってそれを追加検討している（JP）。"
    },
    {
      "indent": 3,
      "text": "NoInfo (NI) No information. This is the initial state, and the state when the router is not the DR.",
      "ja": "NoInfo（NI）情報なし。ルータがDRでないとき、これは初期状態、および状態です。"
    },
    {
      "indent": 3,
      "text": "In addition, a Register-Stop Timer (RST) is kept if the state machine is not in the NoInfo state.",
      "ja": "ステートマシンがNoInfo状態にされていない場合も、登録ストップタイマー（RST）が保たれています。"
    },
    {
      "indent": 3,
      "text": "Figure 1: Per-(S,G) register state machine at a DR in tabular form",
      "ja": "図1：パー（S、G）は、表形式でDRにステートマシンを登録します"
    },
    {
      "indent": 0,
      "text": "+----------++----------------------------------------------------------+\n|          ||                          Event                           |\n|          ++----------+-----------+-----------+-----------+-----------+\n|Prev State||Register- | Could     | Could     | Register- | RP changed|\n|          ||Stop Timer| Register  | Register  | Stop      |           |\n|          ||expires   | ->True    | ->False   | received  |           |\n+----------++----------+-----------+-----------+-----------+-----------+\n|NoInfo    ||-         | -> J state| -         | -         | -         |\n|(NI)      ||          | add reg   |           |           |           |\n|          ||          | tunnel    |           |           |           |\n+----------++----------+-----------+-----------+-----------+-----------+\n|          ||-         | -         | -> NI     | -> P state| -> J state|\n|          ||          |           | state     |           |           |\n|          ||          |           | remove reg| remove reg| update reg|\n|Join (J)  ||          |           | tunnel    | tunnel;   | tunnel    |\n|          ||          |           |           | set       |           |\n|          ||          |           |           | Register- |           |\n|          ||          |           |           | Stop      |           |\n|          ||          |           |           | Timer(*)  |           |\n+----------++----------+-----------+-----------+-----------+-----------+\n|          ||-> J state| -         | -> NI     | -> P state| -> J state|\n|          ||          |           | state     |           |           |\n|Join-     ||add reg   |           |           | set       | add reg   |\n|Pending   ||tunnel    |           |           | Register- | tunnel;   |\n|(JP)      ||          |           |           | Stop      | cancel    |\n|          ||          |           |           | Timer(*)  | Register- |\n|          ||          |           |           |           | Stop Timer|\n+----------++----------+-----------+-----------+-----------+-----------+\n|          ||-> JP     | -         | -> NI     | -         | -> J state|\n|          ||state     |           | state     |           |           |\n|          ||set       |           |           |           | add reg   |\n|Prune (P) ||Register- |           |           |           | tunnel;   |\n|          ||Stop      |           |           |           | cancel    |\n|          ||Timer(**);|           |           |           | Register- |\n|          ||send Null-|           |           |           | Stop Timer|\n|          ||Register  |           |           |           |           |\n+----------++----------+-----------+-----------+-----------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 3,
      "text": "(*) The Register-Stop Timer is set to a random value chosen uniformly from the interval ( 0.5 * Register_Suppression_Time, 1.5 * Register_Suppression_Time) minus Register_Probe_Time.",
      "ja": "（*）レジスタストップタイマは、ランダム間隔（0.5 * Register_Suppression_Time、1.5 * Register_Suppression_Time）から一様に選択された値マイナスRegister_Probe_Timeに設定されています。"
    },
    {
      "indent": 8,
      "text": "Subtracting off Register_Probe_Time is a bit unnecessary because\nit is really small compared to Register_Suppression_Time, but\nthis was in the old spec and is kept for compatibility.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(**) The Register-Stop Timer is set to Register_Probe_Time.",
      "ja": "（**）登録-ストップタイマーをRegister_Probe_Timeに設定されています。"
    },
    {
      "indent": 3,
      "text": "The following three actions are defined:",
      "ja": "以下の3つのアクションが定義されています。"
    },
    {
      "indent": 3,
      "text": "Add Register Tunnel",
      "ja": "登録トンネルを追加"
    },
    {
      "indent": 6,
      "text": "A Register-Tunnel virtual interface, VI, is created (if it doesn't already exist) with its encapsulation target being RP(G). DownstreamJPState(S,G,VI) is set to Join state, causing the tunnel interface to be added to immediate_olist(S,G) and inherited_olist(S,G).",
      "ja": "登録-トンネル仮想インターフェイス、VIは、そのカプセル化対象のRP（G）と（それがまだ存在していない場合）が作成されます。 DownstreamJPState（S、G、VI）はimmediate_olist（S、G）と引き継いでいる_olist（S、G）に追加するトンネルインターフェイスを引き起こす状態に参加するように設定されています。"
    },
    {
      "indent": 3,
      "text": "Remove Register Tunnel",
      "ja": "登録トンネルを削除します"
    },
    {
      "indent": 6,
      "text": "VI is the Register-Tunnel virtual interface with encapsulation target of RP(G). DownstreamJPState(S,G,VI) is set to NoInfo state, causing the tunnel interface to be removed from immediate_olist(S,G) and inherited_olist(S,G). If DownstreamJPState(S,G,VI) is NoInfo for all (S,G), then VI can be deleted.",
      "ja": "VIはRP（G）のカプセル化対象と登録 - トンネルの仮想インターフェースです。 DownstreamJPState（S、G、VI）は、トンネルインターフェースがimmediate_olist（S、G）と引き継いでいる_olist（S、G）から除去させる、NoInfo状態に設定されています。 DownstreamJPState（S、G、VI）は、すべての（S、G）のためのNoInfoである場合には、VIを削除することができます。"
    },
    {
      "indent": 3,
      "text": "Update Register Tunnel",
      "ja": "更新登録のトンネル"
    },
    {
      "indent": 6,
      "text": "This action occurs when RP(G) changes.",
      "ja": "RP（G）が変化したときにこのアクションが発生します。"
    },
    {
      "indent": 6,
      "text": "VI_old is the Register-Tunnel virtual interface with encapsulation target old_RP(G). A Register-Tunnel virtual interface, VI_new, is created (if it doesn't already exist) with its encapsulation target being new_RP(G). DownstreamJPState(S,G,VI_old) is set to NoInfo state and DownstreamJPState(S,G,VI_new) is set to Join state. If DownstreamJPState(S,G,VI_old) is NoInfo for all (S,G), then VI_old can be deleted.",
      "ja": "VI_oldは、カプセル化対象old_RP（G）に登録-トンネル仮想インタフェースです。登録-トンネル仮想インターフェイス、VI_newは、そのカプセル化ターゲットはnew_RP（G）であることを（それがまだ存在していない場合）が作成されます。 DownstreamJPState（S、G、VI_old）はNoInfo状態に設定され、DownstreamJPState（S、G、VI_new）の状態に参加するように設定されています。 DownstreamJPState（S、G、VI_old）は全て（S、G）のためのNoInfoある場合、VI_oldを削除することができます。"
    },
    {
      "indent": 6,
      "text": "Note that we cannot simply change the encapsulation target of VI_old because not all groups using that encapsulation tunnel will have moved to the same new RP.",
      "ja": "そのカプセル化トンネルを使用していないすべてのグループが同じ新しいRPに移動しますので、我々は単にVI_oldのカプセル化目標を変更することはできません。"
    },
    {
      "indent": 3,
      "text": "CouldRegister(S,G)",
      "ja": "CouldRegister（S、G）"
    },
    {
      "indent": 6,
      "text": "The macro \"CouldRegister\" in the state machine is defined as:",
      "ja": "ステート・マシン内のマクロ「CouldRegisterは」のように定義されます。"
    },
    {
      "indent": 6,
      "text": "bool CouldRegister(S,G) { return ( I_am_DR( RPF_interface(S) ) AND KeepaliveTimer(S,G) is running AND DirectlyConnected(S) == TRUE ) }",
      "ja": "BOOL CouldRegister（S、G）{リターン（I_am_DR（RPF_interface（S））AND KeepaliveTimer（S、G）が実行され、DirectlyConnected（S）== TRUE）}"
    },
    {
      "indent": 6,
      "text": "Note that on reception of a packet at the DR from a directly connected source, KeepaliveTimer(S,G) needs to be set by the packet forwarding rules before computing CouldRegister(S,G) in the register state machine, or the first packet from a source won't be registered.",
      "ja": "直接接続されたソースからDRでのパケットの受信になお、KeepaliveTimer（S、G）は、レジスタ状態機械でCouldRegister（S、G）を計算する前に、パケット転送ルールが設定する必要がある、または最初のパケットからソースが登録されません。"
    },
    {
      "indent": 3,
      "text": "Encapsulating Data Packets in the Register Tunnel",
      "ja": "登録トンネル内のデータパケットをカプセル化"
    },
    {
      "indent": 6,
      "text": "Conceptually, the Register Tunnel is an interface with a smaller MTU than the underlying IP interface towards the RP. IP fragmentation on packets forwarded on the Register Tunnel is performed based upon this smaller MTU. The encapsulating DR may perform Path MTU Discovery to the RP to determine the effective MTU of the tunnel. Fragmentation for the smaller MTU should take both the outer IP header and the PIM register header overhead into account. If a multicast packet is fragmented on the way into the Register Tunnel, each fragment is encapsulated individually so it contains IP, PIM, and inner IP headers.",
      "ja": "概念的には、登録トンネルはRPに向けた基本的なIPインタフェースよりも小さいMTUとのインタフェースです。登録トンネルに転送されるパケットのIPフラグメンテーションは、この小さなMTUに基づいて行われます。封入DRは、トンネルの有効なMTUを決定するためにRPへのパスMTU探索を実行することができます。小さなMTUのフラグメンテーションは、外側IPヘッダおよびアカウントへPIMレジスタヘッダのオーバーヘッドの両方を取るべきです。マルチキャストパケットはレジスタトンネル内に途中で断片化されている場合、各フラグメントは、それがIP、PIM、および内側IPヘッダが含まれているように、個別にカプセル化されます。"
    },
    {
      "indent": 6,
      "text": "In IPv6, the DR MUST perform Path MTU discovery, and an ICMP Packet Too Big message MUST be sent by the encapsulating DR if it receives a packet that will not fit in the effective MTU of the tunnel. If the MTU between the DR and the RP results in the effective tunnel MTU being smaller than 1280 (the IPv6 minimum MTU), the DR MUST send Fragmentation Required messages with an MTU value of 1280 and MUST fragment its PIM register messages as required, using an IPv6 fragmentation header between the outer IPv6 header and the PIM Register header.",
      "ja": "IPv6では、DRは、パスMTU探索を実行しなければなりません、そして、それはトンネルの有効なMTUに収まらないパケットを受信した場合、ICMPパケット過大メッセージをカプセル化するDRによって送信されなければなりません。 DR及び有効なトンネルMTU 1280よりも小さい（IPv6の最小MTU）でRPの結果との間のMTU場合、DR 1280のMTU値がフラグメンテーション必要なメッセージを送信しなければならなくて、必要に応じて、そのPIMレジスタメッセージを断片化しなければならない、使用します外側のIPv6ヘッダとPIM登録ヘッダとの間のIPv6フラグメンテーションヘッダー。"
    },
    {
      "indent": 6,
      "text": "The TTL of a forwarded data packet is decremented before it is encapsulated in the Register Tunnel. The encapsulating packet uses the normal TTL that the router would use for any locally-generated IP packet.",
      "ja": "それは登録トンネルにカプセル化される前に、転送されたデータパケットのTTLが減算されます。カプセル化したパケットは、ルータが任意のローカルに生成されたIPパケットのために使用する通常のTTLを使用しています。"
    },
    {
      "indent": 6,
      "text": "The IP ECN bits should be copied from the original packet to the IP header of the encapsulating packet. They SHOULD NOT be set independently by the encapsulating router.",
      "ja": "IP ECNビットは、カプセル化パケットのIPヘッダにオリジナルのパケットからコピーされなければなりません。彼らは、カプセル化ルータによって個別に設定しないでください。"
    },
    {
      "indent": 6,
      "text": "The Diffserv Code Point (DSCP) should be copied from the original packet to the IP header of the encapsulating packet. It MAY be set independently by the encapsulating router, based upon static configuration or traffic classification. See [12] for more discussion on setting the DSCP on tunnels.",
      "ja": "Diffservのコードポイント（DSCP）は、カプセル化パケットのIPヘッダにオリジナルのパケットからコピーされなければなりません。これは、静的な構成やトラフィックの分類に基づいて、カプセル化ルータによって独立して設定することができます。トンネル上のDSCPの設定に関する詳細な議論のための[12]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Handling Register-Stop(*,G) Messages at the DR",
      "ja": "DRで登録・ストップ（*、G）メッセージの処理"
    },
    {
      "indent": 6,
      "text": "An old RP might send a Register-Stop message with the source address set to all zeros. This was the normal course of action in RFC 2362 when the Register message matched against (*,G) state at the RP, and it was defined as meaning \"stop encapsulating all sources for this group\". However, the behavior of such a Register-Stop(*,G) is ambiguous or incorrect in some circumstances.",
      "ja": "古いRPはすべてゼロに設定され、送信元アドレスを登録-Stopメッセージを送信することがあります。これは、RegisterメッセージをRPに（*、G）ステートに対して一致する場合、RFC 2362でのアクションの通常の過程であり、それは「このグループのすべてのソースをカプセル化ストップ」を意味するものとして定義されていました。しかし、そのような登録・停止（*、G）の挙動は、いくつかの状況ではあいまいなまたは不正確です。"
    },
    {
      "indent": 6,
      "text": "We specify that an RP should not send Register-Stop(*,G) messages, but for compatibility, a DR should be able to accept one if it is received.",
      "ja": "私たちは、RPレジスタ・ストップ（*、G）メッセージを送信してはならないことを指定し、互換性のために、DRは、それを受信した場合は、1つを受け入れることができるはずです。"
    },
    {
      "indent": 6,
      "text": "A Register-Stop(*,G) should be treated as a Register-Stop(S,G) for all (S,G) Register state machines that are not in the NoInfo state. A router should not apply a Register-Stop(*,G) to sources that become active after the Register-Stop(*,G) was received.",
      "ja": "登録 - 停止（*、G）は、すべてのためにレジスタストップ（S、G）（S、G）NoInfo状態にない状態レジスタマシンとして扱われるべきです。登録・停止（*、G）が受信された後にルータがアクティブになるソースに登録するストップ（*、G）を適用してはなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Receiving Register Messages at the RP",
      "section_title": true,
      "ja": "4.4.2。 RPに登録メッセージの受信"
    },
    {
      "indent": 3,
      "text": "When an RP receives a Register message, the course of action is decided according to the following pseudocode:",
      "ja": "RPはRegisterメッセージを受信すると、アクションのコースは、以下の擬似コードに応じて決定されます。"
    },
    {
      "indent": 3,
      "text": "packet_arrives_on_rp_tunnel( pkt ) {\n    if( outer.dst is not one of my addresses ) {\n        drop the packet silently.\n        # Note: this may be a spoofing attempt\n    }\n    if( I_am_RP(G) AND outer.dst == RP(G) ) {\n          sentRegisterStop = FALSE;\n          if ( register.borderbit == TRUE ) {\n               if ( PMBR(S,G) == unknown ) {\n                    PMBR(S,G) = outer.src\n               } else if ( outer.src != PMBR(S,G) ) {\n                    send Register-Stop(S,G) to outer.src\n                    drop the packet silently.\n               }\n          }\n          if ( SPTbit(S,G) OR\n           ( SwitchToSptDesired(S,G) AND\n             ( inherited_olist(S,G) == NULL ))) {\n            send Register-Stop(S,G) to outer.src\n            sentRegisterStop = TRUE;\n          }\n          if ( SPTbit(S,G) OR SwitchToSptDesired(S,G) ) {\n               if ( sentRegisterStop == TRUE ) {\n                    set KeepaliveTimer(S,G) to RP_Keepalive_Period;\n               } else {\n                    set KeepaliveTimer(S,G) to Keepalive_Period;\n               }\n          }\n          if( !SPTbit(S,G) AND ! pkt.NullRegisterBit ) {\n               decapsulate and forward the inner packet to\n               inherited_olist(S,G,rpt) # Note (+)\n          }\n    } else {\n        send Register-Stop(S,G) to outer.src\n        # Note (*)\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "outer.dst is the IP destination address of the encapsulating header.",
      "ja": "outer.dstはカプセル化ヘッダのIP宛先アドレスです。"
    },
    {
      "indent": 3,
      "text": "outer.src is the IP source address of the encapsulating header, i.e., the DR's address.",
      "ja": "outer.srcは、すなわち、DRのアドレスカプセル化ヘッダのIPソースアドレスです。"
    },
    {
      "indent": 3,
      "text": "I_am_RP(G) is true if the group-to-RP mapping indicates that this router is the RP for the group.",
      "ja": "グループ対RPマッピングはこのルータがグループのRPであることを示す場合I_am_RP（G）が真です。"
    },
    {
      "indent": 3,
      "text": "Note (*): This may block traffic from S for Register_Suppression_Time if the DR learned about a new group-to-RP mapping before the RP did. However, this doesn't matter unless we figure out some way for the RP also to accept (*,G) joins when it doesn't yet realize that it is about to become the RP for G. This will all get sorted out once the RP learns the new group-to-rp mapping. We decided to do nothing about this and just accept the fact that PIM may suffer interrupted (*,G) connectivity following an RP change.",
      "ja": "注（*）：DRがしたRP前に、新しいグループ-RPマッピングについて学んだ場合、これはRegister_Suppression_TimeのためのSからのトラフィックをブロックすることがあります。我々はまた、（*、G）を受け入れRPためのいくつかの方法を把握しない限り、それはまだすべてを一度整理れますG.このためRPになろうとしていることを認識していないときは、この結合は重要ではありません。 RPは、新しいグループ-RPマッピングを学習します。我々はこのことについて何もしないことを決定し、ちょうどPIMは、RPの変化を以下の中断（*、G）の接続性を被る可能性があるという事実を受け入れます。"
    },
    {
      "indent": 3,
      "text": "Note (+): Implementations are advised not to make this a special case, but to arrange that this path rejoin the normal packet forwarding path. All of the appropriate actions from the \"On receipt of data from S to G on interface iif\" pseudocode in Section 4.2 should be performed.",
      "ja": "注（+）：実装は、この特殊なケースにするために、このパスは、通常のパケット転送パスに再び参加することを手配しないことをお勧めします。 「IIFインターフェイス上のGに対するSからデータを受信すると、」セクション4.2の擬似コードが実行されなければならないから適切な行動の全て。"
    },
    {
      "indent": 3,
      "text": "KeepaliveTimer(S,G) is restarted at the RP when packets arrive on the proper tunnel interface and the RP desires to switch to the SPT or the SPTbit is already set. This may cause the upstream (S,G) state machine to trigger a join if the inherited_olist(S,G) is not NULL.",
      "ja": "パケットは適切なトンネルインタフェースに到着し、RPがSPTに切り替えることを望む又はSPTbitが既に設定されている場合KeepaliveTimer（S、G）がRPで再開されます。これは引き継いでいる_olist（S、G）がNULLでない場合参加トリガするために上流（S、G）ステートマシンを引き起こし得ます。"
    },
    {
      "indent": 3,
      "text": "An RP should preserve (S,G) state that was created in response to a Register message for at least ( 3 * Register_Suppression_Time ); otherwise, the RP may stop joining (S,G) before the DR for S has restarted sending registers. Traffic would then be interrupted until the Register-Stop Timer expires at the DR.",
      "ja": "RPは、少なくとも（3 * Register_Suppression_Time）用の登録メッセージに応答して作成された（S、G）状態を維持すべきです。そうでない場合、RPは、レジスタを送信する再起動したSのためのDRの前に（S、G）を接合停止してもよいです。登録・停止TimerがDRで期限が切れるまで、トラフィックは、その後中断されることでしょう。"
    },
    {
      "indent": 3,
      "text": "Thus, at the RP, KeepaliveTimer(S,G) should be restarted to ( 3 * Register_Suppression_Time + Register_Probe_Time ).",
      "ja": "したがって、RPで、KeepaliveTimer（S、G）は、（3 * Register_Suppression_Time + Register_Probe_Time）に再起動されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When forwarding a packet from the Register Tunnel, the TTL of the original data packet is decremented after it is decapsulated.",
      "ja": "登録トンネルからのパケットを転送するとき、それがカプセル化が解除された後、元のデータパケットのTTLが減算されます。"
    },
    {
      "indent": 3,
      "text": "The IP ECN bits should be copied from the IP header of the Register packet to the decapsulated packet.",
      "ja": "IP ECNビットはデカプセル化パケットに登録パケットのIPヘッダからコピーされなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Diffserv Code Point (DSCP) should be copied from the IP header of the Register packet to the decapsulated packet. The RP MAY retain the DSCP of the inner packet or re-classify the packet and apply a different DSCP. Scenarios where each of these might be useful are discussed in [12].",
      "ja": "Diffservのコードポイント（DSCP）をデカプセル化パケットに登録パケットのIPヘッダからコピーされなければなりません。 RPは、内部パケットのDSCPを保持するか、パケットを再分類し、異なるDSCPを適用することができます。これらの各々は有用かもしれないシナリオでは、[12]に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.5. PIM Join/Prune Messages",
      "section_title": true,
      "ja": "4.5。 PIM /プルーンのメッセージに参加"
    },
    {
      "indent": 3,
      "text": "A PIM Join/Prune message consists of a list of groups and a list of Joined and Pruned sources for each group. When processing a received Join/Prune message, each Joined or Pruned source for a Group is effectively considered individually, and applies to one or more of the following state machines. When considering a Join/Prune message whose Upstream Neighbor Address field addresses this router, (*,G) Joins and Prunes can affect both the (*,G) and (S,G,rpt) downstream state machines, while (*,*,RP), (S,G), and (S,G,rpt) Joins and Prunes can only affect their respective downstream state machines. When considering a Join/Prune message whose Upstream Neighbor Address field addresses another router, most Join or Prune messages could affect each upstream state machine.",
      "ja": "PIM参加/プルーンメッセージは、グループのリストと、各グループのメンバーと剪定ソースのリストから成ります。受信した参加/プルーンメッセージを処理するときに、グループの各メンバーまたはプルーニング源を効果的に個々に考えられ、以下の状態機械の一つ以上に適用されます。その上流隣接アドレスフィールドアドレスこのルータに参加/プルーンのメッセージ、（*、G）参加とプルーンは（*、G）の両方に影響を与えることができ、（S、G、RPT）を考慮すると、下流のステートマシン、しばらく（*、* 、RP）、（S、G）、および（S、G、RPT）ジョインとプルーンは、それぞれの下流のステートマシンに影響を与えることができます。その上流隣接アドレスフィールドには、別のルータに対処しましょう/プルーンのメッセージを考えるとき、ほとんどの参加やプルーンのメッセージは、各アップストリームステートマシンに影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "In general, a PIM Join/Prune message should only be accepted for processing if it comes from a known PIM neighbor. A PIM router hears about PIM neighbors through PIM Hello messages. If a router receives a Join/Prune message from a particular IP source address and it has not seen a PIM Hello message from that source address, then the Join/Prune message SHOULD be discarded without further processing. In addition, if the Hello message from a neighbor was authenticated using IPsec AH (see Section 6.3), then all Join/Prune messages from that neighbor MUST also be authenticated using IPsec AH.",
      "ja": "それが知られているPIMネイバーから来る場合一般的には、PIMに参加/プルーンのメッセージは、処理のために受理されなければなりません。 PIMルータはPIM Helloメッセージを通じてPIMネイバーについて聞きます。ルータが特定のIP送信元アドレスから/プルーンに参加メッセージを受信し、それがその送信元アドレスからのPIM Helloメッセージを見ていない場合は、/プルーンメッセージはさらに処理せずに廃棄すべきましょう。隣人からHelloメッセージがIPsecのAHを（6.3節を参照）を使用して認証された場合に加えて、その隣人からのすべての参加/プルーンのメッセージは、IPsecのAHを使用して認証されなければなりません。"
    },
    {
      "indent": 3,
      "text": "We note that some older PIM implementations incorrectly fail to send Hello messages on point-to-point interfaces, so we also RECOMMEND that a configuration option be provided to allow interoperation with such older routers, but that this configuration option SHOULD NOT be enabled by default.",
      "ja": "我々はいくつかの古いPIM実装は間違ってポイントツーポイントインターフェイス上でHelloメッセージを送信するために失敗することに注意してくださいので、私たちはまた、コンフィギュレーションオプションが、このような古いルータとの相互運用を可能にするために提供することをお勧めしますが、この設定オプションはデフォルトで有効にすべきではないこと。"
    },
    {
      "indent": 0,
      "text": "4.5.1. Receiving (*,*,RP) Join/Prune Messages",
      "section_title": true,
      "ja": "4.5.1。 （*、*、RP）受信/プルーンのメッセージに参加"
    },
    {
      "indent": 3,
      "text": "The per-interface state machine for receiving (*,*,RP) Join/Prune Messages is given below. There are three states:",
      "ja": "（*、*、RP）/プルーンメッセージに参加し受信するためのインターフェースごとの状態機械を以下に示します。 3つの状態があります。"
    },
    {
      "indent": 5,
      "text": "NoInfo (NI) The interface has no (*,*,RP) Join state and no timers running.",
      "ja": "NoInfo（NI）インタフェースには（*、*、RP）が参加状態を持っていないし、何のタイマーが動作していません。"
    },
    {
      "indent": 5,
      "text": "Join (J) The interface has (*,*,RP) Join state, which will cause the router to forward packets destined for any group handled by RP from this interface except if there is also (S,G,rpt) prune information (see Section 4.5.4) or the router lost an assert on this interface.",
      "ja": "（インターフェイスは、ルータがプルーン情報（S、G、RPT）も存在する場合を除いて、このインターフェイスからRPによって処理される任意のグループ宛てのパケットを転送するようになります（*、*、RP）参加状態、有する（J）に参加4.5.4項を参照）、またはルータがこのインターフェイスでアサートを失いました。"
    },
    {
      "indent": 5,
      "text": "Prune-Pending (PP) The router has received a Prune(*,*,RP) on this interface from a downstream neighbor and is waiting to see whether the prune will be overridden by another downstream router. For forwarding purposes, the Prune-Pending state functions exactly like the Join state.",
      "ja": "プルーン保留（PP）ルータは、ダウンストリームネイバーから、このインターフェイス上でプルーン（*、*、RP）を受信したとプルーンが別の下流のルータによって上書きされるかどうかを確認するために待機しています。正確に入会状態などの転送目的、プルーン・ペンディング状態関数の場合。"
    },
    {
      "indent": 3,
      "text": "In addition, the state machine uses two timers:",
      "ja": "また、ステートマシンは2つのタイマーを使用しています。"
    },
    {
      "indent": 5,
      "text": "ExpiryTimer (ET) This timer is restarted when a valid Join(*,*,RP) is received. Expiry of the ExpiryTimer causes the interface state to revert to NoInfo for this RP.",
      "ja": "有効な参加（*、*、RP）を受信したときにExpiryTimer（ET）このタイマーが再起動されます。 ExpiryTimerの有効期限は、このRPのためNoInfoに戻すためのインタフェースの状態を引き起こします。"
    },
    {
      "indent": 5,
      "text": "Prune-Pending Timer (PPT) This timer is set when a valid Prune(*,*,RP) is received. Expiry of the Prune-Pending Timer causes the interface state to revert to NoInfo for this RP.",
      "ja": "有効なプルーン（*、*、RP）が受信されると、プルーン、保留タイマー（PPT）このタイマーが設定されています。プルーン-保留タイマーの有効期限は、このRPのためNoInfoに戻すためのインタフェースの状態を引き起こします。"
    },
    {
      "indent": 7,
      "text": "Figure 2: Downstream per-interface (*,*,RP) state machine in tabular form",
      "ja": "図2：表形式の下流インターフェイス単位（*、*、RP）状態マシン"
    },
    {
      "indent": 0,
      "text": "+------------++--------------------------------------------------------+\n|            ||                          Event                         |\n|            ++-------------+-------------+--------------+-------------+\n|Prev State  ||Receive      | Receive     | Prune-       | Expiry Timer|\n|            ||Join(*,*,RP) | Prune       | Pending      | Expires     |\n|            ||             | (*,*,RP)    | Timer        |             |\n|            ||             |             | Expires      |             |\n+------------++-------------+-------------+--------------+-------------+\n|            ||-> J state   | -> NI state | -            | -           |\n|NoInfo (NI) ||start Expiry |             |              |             |\n|            ||Timer        |             |              |             |\n+------------++-------------+-------------+--------------+-------------+\n|            ||-> J state   | -> PP state | -            | -> NI state |\n|Join (J)    ||restart      | start Prune-|              |             |\n|            ||Expiry Timer | Pending     |              |             |\n|            ||             | Timer       |              |             |\n+------------++-------------+-------------+--------------+-------------+\n|Prune-      ||-> J state   | -> PP state | -> NI state  | -> NI state |\n|Pending (PP)||restart      |             | Send Prune-  |             |\n|            ||Expiry Timer |             | Echo(*,*,RP) |             |\n+------------++-------------+-------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The transition events \"Receive Join(*,*,RP)\" and \"Receive Prune(*,*,RP)\" imply receiving a Join or Prune targeted to this router's primary IP address on the received interface. If the upstream neighbor address field is not correct, these state transitions in this state machine must not occur, although seeing such a packet may cause state transitions in other state machines.",
      "ja": "遷移イベントは、受信したインターフェイス上でこのルータのプライマリIPアドレスを対象とJoinまたはプルーニング受け暗示「プルーン（*、*、RP）を受信」「（*、*、RP）に参加受信します」。上流隣接アドレスフィールドが正しくない場合は、このようなパケットを見てすることは、他のステートマシンの状態遷移を引き起こすかもしれないが、この状態のマシンでこれらの状態遷移は、発生してはいけません。"
    },
    {
      "indent": 3,
      "text": "On unnumbered interfaces on point-to-point links, the router's address should be the same as the source address it chose for the Hello message it sent over that interface. However, on point-to-point links we also recommend that for backwards compatibility PIM Join/Prune messages with an upstream neighbor address field of all zeros are also accepted.",
      "ja": "ポイントツーポイントリンク上のアンナンバードインターフェイスでは、ルータのアドレスは、それがそのインターフェイスを介して送信されるHelloメッセージのために選択した送信元アドレスと同じでなければなりません。しかし、ポイントツーポイントリンク上で、我々はまた、後方互換性のPIMのためにも受け入れられているすべてゼロの上流隣接アドレスフィールドに/プルーンのメッセージに参加することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Transitions from NoInfo State",
      "ja": "NoInfo状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in NoInfo state, the following event may trigger a transition:",
      "ja": "場合NoInfo状態で、次のイベントは、移行をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "Receive Join(*,*,RP) A Join(*,*,RP) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "参加（*、*、RP）Aを受信（*、*、RP）に参加私はI.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインターフェイスで受信されます"
    },
    {
      "indent": 10,
      "text": "The (*,*,RP) downstream state machine on interface I\ntransitions to the Join state.  The Expiry Timer (ET) is\nstarted and set to the HoldTime from the triggering Join/Prune\nmessage.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Note that it is possible to receive a Join(*,*,RP) message for an RP for which we do not have information telling us that it is an RP. In the case of (*,*,RP) state, so long as we have a route to the RP, this will not cause a problem, and the transition should still take place.",
      "ja": "我々はそれがRPであることを告げた情報を持っていないRPのための参加（*、*、RP）メッセージを受信することが可能であることに注意してください。 （*、*、RP）状態の場合には、あまりにも長い間、我々はRPへのルートを持っているように、これは問題を引き起こすことはありません、と移行がまだ行われるべきです。"
    },
    {
      "indent": 3,
      "text": "Transitions from Join State",
      "ja": "参加状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in Join state, the following events may trigger a transition:",
      "ja": "中には、国家に参加すると、次のイベントは、遷移を引き起こすことがあります。"
    },
    {
      "indent": 5,
      "text": "Receive Join(*,*,RP) A Join(*,*,RP) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "参加（*、*、RP）Aを受信（*、*、RP）に参加私はI.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインターフェイスで受信されます"
    },
    {
      "indent": 10,
      "text": "The (*,*,RP) downstream state machine on interface I remains\nin Join state, and the Expiry Timer (ET) is restarted, set to\nmaximum of its current value and the HoldTime from the\ntriggering Join/Prune message.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Receive Prune(*,*,RP) A Prune(*,*,RP) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "受信プルーン（*、*、RP）Aプルーン（*、*、RP）は、私はI.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインターフェイスで受信されます"
    },
    {
      "indent": 10,
      "text": "The (*,*,RP) downstream state machine on interface I\ntransitions to the Prune-Pending state.  The Prune-Pending\nTimer is started.  It is set to the J/P_Override_Interval(I)\nif the router has more than one neighbor on that interface;\notherwise, it is set to zero, causing it to expire\nimmediately.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Expiry Timer Expires The Expiry Timer for the (*,*,RP) downstream state machine on interface I expires.",
      "ja": "有効期限タイマーは私が満了したインターフェイス上で（*、*、RP）川下の状態マシンには有効期限タイマーが期限切れになります。"
    },
    {
      "indent": 10,
      "text": "The (*,*,RP) downstream state machine on interface I\ntransitions to the NoInfo state.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from Prune-Pending State",
      "ja": "プルーン保留状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in Prune-Pending state, the following events may trigger a transition:",
      "ja": "プルーン保留状態で、次のイベントが遷移をトリガすることができる場合。"
    },
    {
      "indent": 5,
      "text": "Receive Join(*,*,RP) A Join(*,*,RP) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "参加（*、*、RP）Aを受信（*、*、RP）に参加私はI.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインターフェイスで受信されます"
    },
    {
      "indent": 10,
      "text": "The (*,*,RP) downstream state machine on interface I\ntransitions to the Join state.  The Prune-Pending Timer is\ncanceled (without triggering an expiry event).  The Expiry\nTimer is restarted, set to maximum of its current value and\nthe HoldTime from the triggering Join/Prune message.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Expiry Timer Expires The Expiry Timer for the (*,*,RP) downstream state machine on interface I expires.",
      "ja": "有効期限タイマーは私が満了したインターフェイス上で（*、*、RP）川下の状態マシンには有効期限タイマーが期限切れになります。"
    },
    {
      "indent": 10,
      "text": "The (*,*,RP) downstream state machine on interface I\ntransitions to the NoInfo state.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Prune-Pending Timer Expires The Prune-Pending Timer for the (*,*,RP) downstream state machine on interface I expires.",
      "ja": "プルーン-保留タイマーは私が満了したインターフェイス上で（*、*、RP）川下の状態マシンにはプルーン、保留タイマーが期限切れになります。"
    },
    {
      "indent": 10,
      "text": "The (*,*,RP) downstream state machine on interface I\ntransitions to the NoInfo state.  A PruneEcho(*,*,RP) is sent\nonto the subnet connected to interface I.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "The action \"Send PruneEcho(*,*,RP)\" is triggered when the router stops forwarding on an interface as a result of a prune. A PruneEcho(*,*,RP) is simply a Prune(*,*,RP) message sent by the upstream router on a LAN with its own address in the Upstream Neighbor Address field. Its purpose is to add additional reliability so that if a Prune that should have been overridden by another router is lost locally on the LAN, then the PruneEcho may be received and cause the override to happen. A PruneEcho(*,*,RP) need not be sent on an interface that contains only a single PIM neighbor during the time this state machine was in Prune-Pending state.",
      "ja": "ルータはプルーンの結果としてインターフェイスに転送を停止したときにアクション「PruneEchoを送る（*、*、RP）は、」トリガされます。 PruneEchoは（*、*、RP）単に上流隣接アドレスフィールドに自身のアドレスをLAN上の上流のルータによって送られたプルーン（*、*、RP）メッセージです。その目的は、別のルータによって上書きされているはずプルーンは、LAN上でローカルに失われた場合、その後、PruneEchoを受信して​​オーバーライドが発生する原因となることができるように、追加の信頼性を追加することです。 PruneEcho（*、*、RP）は、このステートマシンはプルーン保留状態にあった時間の間にのみ、単一のPIMネイバーが含まれているインターフェイスで送信する必要はありません。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Receiving (*,G) Join/Prune Messages",
      "section_title": true,
      "ja": "4.5.2。 （*、G）参加/プルーンのメッセージの受信"
    },
    {
      "indent": 3,
      "text": "When a router receives a Join(*,G), it must first check to see whether the RP in the message matches RP(G) (the router's idea of who the RP is). If the RP in the message does not match RP(G), the Join(*,G) should be silently dropped. (Note that other source list entries, such as (S,G,rpt) or (S,G), in the same Group-Specific Set should still be processed.) If a router has no RP information (e.g., has not recently received a BSR message), then it may choose to accept Join(*,G) and treat the RP in the message as RP(G). Received Prune(*,G) messages are processed even if the RP in the message does not match RP(G).",
      "ja": "ルータが（*、G）Joinを受信すると、それは最初のメッセージ内のRPがRP（G）（RPが誰であるかのルータのアイデアを）一致するかどうかを確認しなければなりません。メッセージ内のRPがRP（G）、（*、G）参加に一致しない場合は黙って落とさなければなりません。 （例えば、同じグループ固有の設定では（S、G、RPT）または（S、G）、などの他のソースリストのエントリは、まだ処理されなければならないことに注意してください。）ルータは何のRP情報を持っていない場合（例えば、最近はしていませんそれは、*（G参加受け入れることを選択）とRP（G）としてメッセージにRPを扱うことができ、）BSRメッセージを受け取りました。メッセージ内のRPがRP（G）と一致しない場合でも、受信プルーン（*、G）メッセージが処理されます。"
    },
    {
      "indent": 3,
      "text": "The per-interface state machine for receiving (*,G) Join/Prune Messages is given below. There are three states:",
      "ja": "（*、G）参加/プルーンメッセージを受信するためのインターフェイス単位のステートマシンを以下に示します。 3つの状態があります。"
    },
    {
      "indent": 5,
      "text": "NoInfo (NI) The interface has no (*,G) Join state and no timers running.",
      "ja": "NoInfo（NI）インタフェースには（*、G）の状態となしタイマーの実行に参加していません。"
    },
    {
      "indent": 5,
      "text": "Join (J) The interface has (*,G) Join state, which will cause the router to forward packets destined for G from this interface except if there is also (S,G,rpt) prune information (see Section 4.5.4) or the router lost an assert on this interface.",
      "ja": "（4.5.4項を参照してください）インタフェースは（*、G）は、ルータは（S、G、RPT）プルーンの情報もある場合を除いて、このインターフェイスからG宛のパケットを転送するようになります状態を、参加している（J）に参加またはルータがこのインターフェイスでアサートを失いました。"
    },
    {
      "indent": 5,
      "text": "Prune-Pending (PP) The router has received a Prune(*,G) on this interface from a downstream neighbor and is waiting to see whether the prune will be overridden by another downstream router. For forwarding purposes, the Prune-Pending state functions exactly like the Join state.",
      "ja": "プルーン保留（PP）ルータは、ダウンストリームネイバーから、このインターフェイス上でプルーン（*、G）を受信したとプルーンが別の下流のルータによって上書きされるかどうかを確認するために待機しています。正確に入会状態などの転送目的、プルーン・ペンディング状態関数の場合。"
    },
    {
      "indent": 3,
      "text": "In addition, the state machine uses two timers:",
      "ja": "また、ステートマシンは2つのタイマーを使用しています。"
    },
    {
      "indent": 5,
      "text": "Expiry Timer (ET) This timer is restarted when a valid Join(*,G) is received. Expiry of the Expiry Timer causes the interface state to revert to NoInfo for this group.",
      "ja": "有効期限タイマ（ET）有効な参加時にこのタイマーが再起動されたが（*、G）が受信されます。有効期限タイマーの満了は、このグループのためにNoInfoに戻す界面状態を引き起こします。"
    },
    {
      "indent": 5,
      "text": "Prune-Pending Timer (PPT) This timer is set when a valid Prune(*,G) is received. Expiry of the Prune-Pending Timer causes the interface state to revert to NoInfo for this group.",
      "ja": "有効なプルーン（*、G）を受信したとき、プルーン、保留タイマー（PPT）このタイマーが設定されています。プルーン・保留タイマの満了は、このグループのNoInfoに戻す界面状態を引き起こします。"
    },
    {
      "indent": 1,
      "text": "Figure 3: Downstream per-interface (*,G) state machine in tabular form",
      "ja": "図3：表形式の下流インターフェイス単位（*、G）ステートマシン"
    },
    {
      "indent": 0,
      "text": "+------------++--------------------------------------------------------+\n|            ||                         Event                          |\n|            ++-------------+--------------+-------------+-------------+\n|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|\n|            ||Join(*,G)    | Prune(*,G)   | Pending     | Expires     |\n|            ||             |              | Timer       |             |\n|            ||             |              | Expires     |             |\n+------------++-------------+--------------+-------------+-------------+\n|            ||-> J state   | -> NI state  | -           | -           |\n|NoInfo (NI) ||start Expiry |              |             |             |\n|            ||Timer        |              |             |             |\n+------------++-------------+--------------+-------------+-------------+\n|            ||-> J state   | -> PP state  | -           | -> NI state |\n|Join (J)    ||restart      | start Prune- |             |             |\n|            ||Expiry Timer | Pending      |             |             |\n|            ||             | Timer        |             |             |\n+------------++-------------+--------------+-------------+-------------+\n|Prune-      ||-> J state   | -> PP state  | -> NI state | -> NI state |\n|Pending (PP)||restart      |              | Send Prune- |             |\n|            ||Expiry Timer |              | Echo(*,G)   |             |\n+------------++-------------+--------------+-------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The transition events \"Receive Join(*,G)\" and \"Receive Prune(*,G)\" imply receiving a Join or Prune targeted to this router's primary IP address on the received interface. If the upstream neighbor address field is not correct, these state transitions in this state machine must not occur, although seeing such a packet may cause state transitions in other state machines.",
      "ja": "遷移イベントは、「（*、G）が参加受信」と「プルーン（*、G）を受信」に参加受ける暗示やプルーンは、受信したインターフェイス上でこのルータのプライマリIPアドレスを対象。上流隣接アドレスフィールドが正しくない場合は、このようなパケットを見てすることは、他のステートマシンの状態遷移を引き起こすかもしれないが、この状態のマシンでこれらの状態遷移は、発生してはいけません。"
    },
    {
      "indent": 3,
      "text": "On unnumbered interfaces on point-to-point links, the router's address should be the same as the source address it chose for the Hello message it sent over that interface. However, on point-to- point links we also recommend that for backwards compatibility PIM Join/Prune messages with an upstream neighbor address field of all zeros are also accepted.",
      "ja": "ポイントツーポイントリンク上のアンナンバードインターフェイスでは、ルータのアドレスは、それがそのインターフェイスを介して送信されるHelloメッセージのために選択した送信元アドレスと同じでなければなりません。しかし、ポイントツーポイントリンク上で、我々はまた、後方互換性のPIMのためにも受け入れられているすべてゼロの上流隣接アドレスフィールドに/プルーンのメッセージに参加することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Transitions from NoInfo State",
      "ja": "NoInfo状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in NoInfo state, the following event may trigger a transition:",
      "ja": "場合NoInfo状態で、次のイベントは、移行をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "Receive Join(*,G) A Join(*,G) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "参加受信（*、G）Aは、（*、G）参加I.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインタフェース上でIを受信します"
    },
    {
      "indent": 10,
      "text": "The (*,G) downstream state machine on interface I transitions\nto the Join state.  The Expiry Timer (ET) is started and set\nto the HoldTime from the triggering Join/Prune message.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from Join State",
      "ja": "参加状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in Join state, the following events may trigger a transition:",
      "ja": "中には、国家に参加すると、次のイベントは、遷移を引き起こすことがあります。"
    },
    {
      "indent": 5,
      "text": "Receive Join(*,G) A Join(*,G) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "参加受信（*、G）Aは、（*、G）参加I.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインタフェース上でIを受信します"
    },
    {
      "indent": 10,
      "text": "The (*,G) downstream state machine on interface I remains in\nJoin state, and the Expiry Timer (ET) is restarted, set to\nmaximum of its current value and the HoldTime from the\ntriggering Join/Prune message.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Receive Prune(*,G) A Prune(*,G) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "受信プルーン（*、G）Aプルーン（*、G）が、私はI.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインターフェイスで受信されます"
    },
    {
      "indent": 10,
      "text": "The (*,G) downstream state machine on interface I transitions\nto the Prune-Pending state.  The Prune-Pending Timer is\nstarted.  It is set to the J/P_Override_Interval(I) if the\nrouter has more than one neighbor on that interface;\notherwise, it is set to zero, causing it to expire\nimmediately.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Expiry Timer Expires The Expiry Timer for the (*,G) downstream state machine on interface I expires.",
      "ja": "有効期限タイマーIが満了するインターフェイスに（*、G）下流のステートマシンの有効期限タイマーが期限切れ。"
    },
    {
      "indent": 10,
      "text": "The (*,G) downstream state machine on interface I transitions\nto the NoInfo state.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from Prune-Pending State",
      "ja": "プルーン保留状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in Prune-Pending state, the following events may trigger a transition:",
      "ja": "プルーン保留状態で、次のイベントが遷移をトリガすることができる場合。"
    },
    {
      "indent": 5,
      "text": "Receive Join(*,G) A Join(*,G) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "参加受信（*、G）Aは、（*、G）参加I.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインタフェース上でIを受信します"
    },
    {
      "indent": 10,
      "text": "The (*,G) downstream state machine on interface I transitions\nto the Join state.  The Prune-Pending Timer is canceled\n(without triggering an expiry event).  The Expiry Timer is\nrestarted, set to maximum of its current value and the\nHoldTime from the triggering Join/Prune message.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Expiry Timer Expires The Expiry Timer for the (*,G) downstream state machine on interface I expires.",
      "ja": "有効期限タイマーIが満了するインターフェイスに（*、G）下流のステートマシンの有効期限タイマーが期限切れ。"
    },
    {
      "indent": 10,
      "text": "The (*,G) downstream state machine on interface I transitions\nto the NoInfo state.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Prune-Pending Timer Expires The Prune-Pending Timer for the (*,G) downstream state machine on interface I expires.",
      "ja": "プルーン保留タイマーIが満了するインターフェイスに（*、G）下流ステートマシンのプルーン・保留タイマー期限切れ。"
    },
    {
      "indent": 10,
      "text": "The (*,G) downstream state machine on interface I transitions\nto the NoInfo state.  A PruneEcho(*,G) is sent onto the subnet\nconnected to interface I.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "The action \"Send PruneEcho(*,G)\" is triggered when the router stops forwarding on an interface as a result of a prune. A PruneEcho(*,G) is simply a Prune(*,G) message sent by the upstream router on a LAN with its own address in the Upstream Neighbor Address field. Its purpose is to add additional reliability so that if a Prune that should have been overridden by another router is lost locally on the LAN, then the PruneEcho may be received and cause the override to happen. A PruneEcho(*,G) need not be sent on an interface that contains only a single PIM neighbor during the time this state machine was in Prune-Pending state.",
      "ja": "ルータはプルーンの結果としてインタフェースに転送停止時アクション「PruneEcho（*、G）を送る」がトリガされます。 PruneEcho（*、G）は、単に上流隣接アドレスフィールドに自身のアドレスとLAN上の上流のルータによって送信されたプルーン（*、G）メッセージです。その目的は、別のルータによって上書きされているはずプルーンは、LAN上でローカルに失われた場合、その後、PruneEchoを受信して​​オーバーライドが発生する原因となることができるように、追加の信頼性を追加することです。 PruneEcho（*、G）は、この状態マシンはプルーン保留状態にあった時間の間のみ、単一のPIMネイバーを含んインターフェイス上で送信される必要はありません。"
    },
    {
      "indent": 0,
      "text": "4.5.3. Receiving (S,G) Join/Prune Messages",
      "section_title": true,
      "ja": "4.5.3。受信（S、G）/プルーンのメッセージに参加"
    },
    {
      "indent": 3,
      "text": "The per-interface state machine for receiving (S,G) Join/Prune messages is given below and is almost identical to that for (*,G) messages. There are three states:",
      "ja": "受信するためのインターフェイス単位ステートマシン（S、G）/プルーンメッセージを参加は、下記および（*、G）メッセージのためのものとほぼ同じです。 3つの状態があります。"
    },
    {
      "indent": 5,
      "text": "NoInfo (NI) The interface has no (S,G) Join state and no (S,G) timers running.",
      "ja": "NoInfo（NI）インタフェースには（S、G）の状態に参加していないとNO（S、G）タイマが動作していません。"
    },
    {
      "indent": 5,
      "text": "Join (J) The interface has (S,G) Join state, which will cause the router to forward packets from S destined for G from this interface if the (S,G) state is active (the SPTbit is set) except if the router lost an assert on this interface.",
      "ja": "参加（J）インターフェースが（S、G）状態がアクティブである場合、ルータは、このインターフェイスからG宛Sからパケットを転送します（S、G）参加状態は、（SPTbitが設定されている）を有している場合を除きルータは、このインターフェイスでアサートを失いました。"
    },
    {
      "indent": 5,
      "text": "Prune-Pending (PP) The router has received a Prune(S,G) on this interface from a downstream neighbor and is waiting to see whether the prune will be overridden by another downstream router. For forwarding purposes, the Prune-Pending state functions exactly like the Join state.",
      "ja": "プルーン保留（PP）ルータは、ダウンストリームネイバーから、このインターフェイス上でプルーン（S、G）を受信したとプルーンが別の下流のルータによって上書きされるかどうかを確認するために待機しています。正確に入会状態などの転送目的、プルーン・ペンディング状態関数の場合。"
    },
    {
      "indent": 3,
      "text": "In addition, there are two timers:",
      "ja": "また、2つのタイマがあります。"
    },
    {
      "indent": 5,
      "text": "Expiry Timer (ET) This timer is set when a valid Join(S,G) is received. Expiry of the Expiry Timer causes this state machine to revert to NoInfo state.",
      "ja": "有効な参加（S、G）を受信したときに有効期限タイマ（ET）このタイマーが設定されています。有効期限タイマーの有効期限はNoInfo状態に戻すには、このステート・マシンの原因となります。"
    },
    {
      "indent": 5,
      "text": "Prune-Pending Timer (PPT) This timer is set when a valid Prune(S,G) is received. Expiry of the Prune-Pending Timer causes this state machine to revert to NoInfo state.",
      "ja": "有効なプルーン（S、G）を受信したときプルーンペンディングタイマ（PPT）このタイマは設定されています。プルーン-保留タイマーの有効期限はNoInfo状態に戻すには、このステート・マシンの原因となります。"
    },
    {
      "indent": 1,
      "text": "Figure 4: Downstream per-interface (S,G) state machine in tabular form",
      "ja": "図4：表形式の下流あたりインタフェース（S、G）ステートマシン"
    },
    {
      "indent": 0,
      "text": "+------------++--------------------------------------------------------+\n|            ||                         Event                          |\n|            ++-------------+--------------+-------------+-------------+\n|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|\n|            ||Join(S,G)    | Prune(S,G)   | Pending     | Expires     |\n|            ||             |              | Timer       |             |\n|            ||             |              | Expires     |             |\n+------------++-------------+--------------+-------------+-------------+\n|            ||-> J state   | -> NI state  | -           | -           |\n|NoInfo (NI) ||start Expiry |              |             |             |\n|            ||Timer        |              |             |             |\n+------------++-------------+--------------+-------------+-------------+\n|            ||-> J state   | -> PP state  | -           | -> NI state |\n|Join (J)    ||restart      | start Prune- |             |             |\n|            ||Expiry Timer | Pending      |             |             |\n|            ||             | Timer        |             |             |\n+------------++-------------+--------------+-------------+-------------+\n|Prune-      ||-> J state   | -> PP state  | -> NI state | -> NI state |\n|Pending (PP)||restart      |              | Send Prune- |             |\n|            ||Expiry Timer |              | Echo(S,G)   |             |\n+------------++-------------+--------------+-------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The transition events \"Receive Join(S,G)\" and \"Receive Prune(S,G)\" imply receiving a Join or Prune targeted to this router's primary IP address on the received interface. If the upstream neighbor address field is not correct, these state transitions in this state machine must not occur, although seeing such a packet may cause state transitions in other state machines.",
      "ja": "遷移イベントは、「（S、G）に参加受信」し、受信したインターフェイス上でこのルータのプライマリIPアドレスを対象とJoinまたはプルーニング受け暗示「プルーン（S、G）を受信します」。上流隣接アドレスフィールドが正しくない場合は、このようなパケットを見てすることは、他のステートマシンの状態遷移を引き起こすかもしれないが、この状態のマシンでこれらの状態遷移は、発生してはいけません。"
    },
    {
      "indent": 3,
      "text": "On unnumbered interfaces on point-to-point links, the router's address should be the same as the source address it chose for the Hello message it sent over that interface. However, on point-to-point links we also recommend that for backwards compatibility PIM Join/Prune messages with an upstream neighbor address field of all zeros are also accepted.",
      "ja": "ポイントツーポイントリンク上のアンナンバードインターフェイスでは、ルータのアドレスは、それがそのインターフェイスを介して送信されるHelloメッセージのために選択した送信元アドレスと同じでなければなりません。しかし、ポイントツーポイントリンク上で、我々はまた、後方互換性のPIMのためにも受け入れられているすべてゼロの上流隣接アドレスフィールドに/プルーンのメッセージに参加することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Transitions from NoInfo State",
      "ja": "NoInfo状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in NoInfo state, the following event may trigger a transition:",
      "ja": "場合NoInfo状態で、次のイベントは、移行をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "Receive Join(S,G) A Join(S,G) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "（S、G）A参加（S、G）が参加受信I.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインタフェース上でIを受信します"
    },
    {
      "indent": 10,
      "text": "The (S,G) downstream state machine on interface I transitions\nto the Join state.  The Expiry Timer (ET) is started and set\nto the HoldTime from the triggering Join/Prune message.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from Join State",
      "ja": "参加状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in Join state, the following events may trigger a transition:",
      "ja": "中には、国家に参加すると、次のイベントは、遷移を引き起こすことがあります。"
    },
    {
      "indent": 5,
      "text": "Receive Join(S,G) A Join(S,G) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "（S、G）A参加（S、G）が参加受信I.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインタフェース上でIを受信します"
    },
    {
      "indent": 10,
      "text": "The (S,G) downstream state machine on interface I remains in\nJoin state, and the Expiry Timer (ET) is restarted, set to\nmaximum of its current value and the HoldTime from the\ntriggering Join/Prune message.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Receive Prune(S,G) A Prune(S,G) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "受信プルーン（S、G）プルーン（S、G）が、私はI.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインターフェイスで受信されます"
    },
    {
      "indent": 10,
      "text": "The (S,G) downstream state machine on interface I transitions\nto the Prune-Pending state.  The Prune-Pending Timer is\nstarted.  It is set to the J/P_Override_Interval(I) if the\nrouter has more than one neighbor on that interface;\notherwise, it is set to zero, causing it to expire\nimmediately.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Expiry Timer Expires The Expiry Timer for the (S,G) downstream state machine on interface I expires.",
      "ja": "有効期限タイマーIが満了するインターフェイス上で（S、G）下流のステートマシンの有効期限タイマーが期限切れ。"
    },
    {
      "indent": 10,
      "text": "The (S,G) downstream state machine on interface I transitions\nto the NoInfo state.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from Prune-Pending State",
      "ja": "プルーン保留状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in Prune-Pending state, the following events may trigger a transition:",
      "ja": "プルーン保留状態で、次のイベントが遷移をトリガすることができる場合。"
    },
    {
      "indent": 5,
      "text": "Receive Join(S,G) A Join(S,G) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "（S、G）A参加（S、G）が参加受信I.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインタフェース上でIを受信します"
    },
    {
      "indent": 10,
      "text": "The (S,G) downstream state machine on interface I transitions\nto the Join state.  The Prune-Pending Timer is canceled\n(without triggering an expiry event).  The Expiry Timer is\nrestarted, set to maximum of its current value and the\nHoldTime from the triggering Join/Prune message.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Expiry Timer Expires The Expiry Timer for the (S,G) downstream state machine on interface I expires.",
      "ja": "有効期限タイマーIが満了するインターフェイス上で（S、G）下流のステートマシンの有効期限タイマーが期限切れ。"
    },
    {
      "indent": 10,
      "text": "The (S,G) downstream state machine on interface I transitions\nto the NoInfo state.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Prune-Pending Timer Expires The Prune-Pending Timer for the (S,G) downstream state machine on interface I expires.",
      "ja": "プルーン保留タイマーIが満了するインターフェイスで（S、G）下流ステートマシンのプルーン・保留タイマー期限切れ。"
    },
    {
      "indent": 10,
      "text": "The (S,G) downstream state machine on interface I transitions\nto the NoInfo state.  A PruneEcho(S,G) is sent onto the subnet\nconnected to interface I.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "The action \"Send PruneEcho(S,G)\" is triggered when the router stops forwarding on an interface as a result of a prune. A PruneEcho(S,G) is simply a Prune(S,G) message sent by the upstream router on a LAN with its own address in the Upstream Neighbor Address field. Its purpose is to add additional reliability so that if a Prune that should have been overridden by another router is lost locally on the LAN, then the PruneEcho may be received and cause the override to happen. A PruneEcho(S,G) need not be sent on an interface that contains only a single PIM neighbor during the time this state machine was in Prune-Pending state.",
      "ja": "ルータはプルーンの結果としてインタフェースに転送停止時アクション「PruneEcho（S、G）を送る」がトリガされます。 PruneEcho（S、G）は、単に上流隣接アドレスフィールドに自身のアドレスとLAN上の上流のルータによって送信されたプルーン（S、G）メッセージです。その目的は、別のルータによって上書きされているはずプルーンは、LAN上でローカルに失われた場合、その後、PruneEchoを受信して​​オーバーライドが発生する原因となることができるように、追加の信頼性を追加することです。 PruneEcho（S、G）は、この状態マシンはプルーン保留状態にあった時間の間のみ、単一のPIMネイバーを含んインターフェイス上で送信される必要はありません。"
    },
    {
      "indent": 0,
      "text": "4.5.4. Receiving (S,G,rpt) Join/Prune Messages",
      "section_title": true,
      "ja": "4.5.4。 （S、G、RPT）/プルーンのメッセージを受信参加"
    },
    {
      "indent": 3,
      "text": "The per-interface state machine for receiving (S,G,rpt) Join/Prune messages is given below. There are five states:",
      "ja": "受信するためのインターフェイス単位ステートマシン（S、G、RPT）/プルーンメッセージに参加以下に示します。 5つの状態があります。"
    },
    {
      "indent": 5,
      "text": "NoInfo (NI) The interface has no (S,G,rpt) Prune state and no (S,G,rpt) timers running.",
      "ja": "NoInfo（NI）インタフェースには（S、G、RPT）プルーン状態と、実行中の（S、G、RPT）タイマーを有していません。"
    },
    {
      "indent": 5,
      "text": "Prune (P) The interface has (S,G,rpt) Prune state, which will cause the router not to forward packets from S destined for G from this interface even though the interface has active (*,G) Join state.",
      "ja": "プルーン（P）インタフェースはインタフェースは（*、G）状態が参加し、アクティブ持っているにもかかわらず、このインターフェイスからG宛てSからのパケットを転送しないルータが発生します（S、G、RPT）プルーンの状態を、持っています。"
    },
    {
      "indent": 5,
      "text": "Prune-Pending (PP) The router has received a Prune(S,G,rpt) on this interface from a downstream neighbor and is waiting to see whether the prune will be overridden by another downstream router. For forwarding purposes, the Prune-Pending state functions exactly like the NoInfo state.",
      "ja": "プルーン保留（PP）ルータは、ダウンストリームネイバーから、このインターフェイス上でプルーン（S、G、RPT）を受信したとプルーンが別の下流のルータによって上書きされるかどうかを確認するために待機しています。正確NoInfo状態などの転送目的、プルーン・ペンディング状態関数の場合。"
    },
    {
      "indent": 5,
      "text": "PruneTmp (P') This state is a transient state that for forwarding purposes behaves exactly like the Prune state. A (*,G) Join has been received (which may cancel the (S,G,rpt) Prune). As we parse the Join/Prune message from top to bottom, we first enter this state if the message contains a (*,G) Join. Later in the message, we will normally encounter an (S,G,rpt) prune to reinstate the Prune state. However, if we reach the end of the message without encountering such a (S,G,rpt) prune, then we will revert to NoInfo state in this state machine.",
      "ja": "PruneTmp（P '）この状態は、転送のために正確にプルーン状態のように振る舞うこと過渡的な状態です。 （*、G）（（S、G、RPT）プルーンをキャンセルすることができる）を受信した参加します。私たちは上から下への参加/プルーンのメッセージを解析するようメッセージが（*、G）が参加含まれている場合、我々は最初にこの状態に入ります。後でメッセージで、我々は、通常、（S、G、RPT）がプルーン状態を回復するために剪定遭遇します。我々は、（S、G、RPT）プルーンに遭遇せずにメッセージの終わりに達した場合は、我々は、この状態機械でNoInfo状態に戻ります。"
    },
    {
      "indent": 10,
      "text": "As no time is spent in this state, no timers can expire.",
      "ja": "もう時間がこの状態に費やされていないとして、何のタイマーが期限切れになることはできません。"
    },
    {
      "indent": 5,
      "text": "Prune-Pending-Tmp (PP') This state is a transient state that is identical to P' except that it is associated with the PP state rather than the P state. For forwarding purposes, PP' behaves exactly like PP state.",
      "ja": "プルーン係属-TMP（PP「）この状態は、Pと同一である過渡状態である」はPPの状態ではなく、Pの状態に関連付けられていることを除い。転送のために、PPは」正確PP状態のように振る舞います。"
    },
    {
      "indent": 3,
      "text": "In addition, there are two timers:",
      "ja": "また、2つのタイマがあります。"
    },
    {
      "indent": 5,
      "text": "Expiry Timer (ET) This timer is set when a valid Prune(S,G,rpt) is received. Expiry of the Expiry Timer causes this state machine to revert to NoInfo state.",
      "ja": "有効なプルーン（S、G、RPT）を受信したときに有効期限タイマ（ET）このタイマーが設定されています。有効期限タイマーの有効期限はNoInfo状態に戻すには、このステート・マシンの原因となります。"
    },
    {
      "indent": 5,
      "text": "Prune-Pending Timer (PPT) This timer is set when a valid Prune(S,G,rpt) is received. Expiry of the Prune-Pending Timer causes this state machine to move on to Prune state.",
      "ja": "有効なプルーン（S、G、RPT）を受信したときプルーンペンディングタイマ（PPT）このタイマは設定されています。プルーン-保留タイマーの有効期限は、この状態マシンが状態を剪定するために移動させます。"
    },
    {
      "indent": 6,
      "text": "Figure 5: Downstream per-interface (S,G,rpt) state machine in tabular form",
      "ja": "図5：表形式の下流あたりインタフェース（S、G、RPT）状態マシン"
    },
    {
      "indent": 0,
      "text": "+----------++----------------------------------------------------------+\n|          ||                          Event                           |\n|          ++---------+----------+----------+--------+--------+--------+\n|Prev      ||Receive  | Receive  | Receive  | End of | Prune- | Expiry |\n|State     ||Join(*,G)| Join     | Prune    | Message| Pending| Timer  |\n|          ||         | (S,G,rpt)| (S,G,rpt)|        | Timer  | Expires|\n|          ||         |          |          |        | Expires|        |\n+----------++---------+----------+----------+--------+--------+--------+\n|          ||-        | -        | -> PP    | -      | -      | -      |\n|          ||         |          | state    |        |        |        |\n|          ||         |          | start    |        |        |        |\n|NoInfo    ||         |          | Prune-   |        |        |        |\n|(NI)      ||         |          | Pending  |        |        |        |\n|          ||         |          | Timer;   |        |        |        |\n|          ||         |          | start    |        |        |        |\n|          ||         |          | Expiry   |        |        |        |\n|          ||         |          | Timer    |        |        |        |\n+----------++---------+----------+----------+--------+--------+--------+\n|          ||-> P'    | -> NI    | -> P     | -      | -      | -> NI  |\n|          ||state    | state    | state    |        |        | state  |\n|Prune (P) ||         |          | restart  |        |        |        |\n|          ||         |          | Expiry   |        |        |        |\n|          ||         |          | Timer    |        |        |        |\n+----------++---------+----------+----------+--------+--------+--------+\n|Prune-    ||-> PP'   | -> NI    | -        | -      | -> P   | -      |\n|Pending   ||state    | state    |          |        | state  |        |\n|(PP)      ||         |          |          |        |        |        |\n+----------++---------+----------+----------+--------+--------+--------+\n|          ||-        | -        | -> P     | -> NI  | -      | -      |\n|PruneTmp  ||         |          | state    | state  |        |        |\n|(P')      ||         |          | restart  |        |        |        |\n|          ||         |          | Expiry   |        |        |        |\n|          ||         |          | Timer    |        |        |        |\n+----------++---------+----------+----------+--------+--------+--------+\n|          ||-        | -        | -> PP    | -> NI  | -      | -      |\n|Prune-    ||         |          | state    | state  |        |        |\n|Pending-  ||         |          | restart  |        |        |        |\n|Tmp (PP') ||         |          | Expiry   |        |        |        |\n|          ||         |          | Timer    |        |        |        |\n+----------++---------+----------+----------+--------+--------+--------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The transition events \"Receive Join(S,G,rpt)\", \"Receive Prune(S,G,rpt)\", and \"Receive Join(*,G)\" imply receiving a Join or Prune targeted to this router's primary IP address on the received interface. If the upstream neighbor address field is not correct, these state transitions in this state machine must not occur, although seeing such a packet may cause state transitions in other state machines.",
      "ja": "遷移イベントは、「（S、G、RPT）を参加受信」、「（*、G）参加受信」「プルーン（S、G、RPT）を受信」、および入会受信暗示やプルーンがこのルータのプライマリIPアドレスを対象受信したインターフェイス上。上流隣接アドレスフィールドが正しくない場合は、このようなパケットを見てすることは、他のステートマシンの状態遷移を引き起こすかもしれないが、この状態のマシンでこれらの状態遷移は、発生してはいけません。"
    },
    {
      "indent": 3,
      "text": "On unnumbered interfaces on point-to-point links, the router's address should be the same as the source address it chose for the Hello message it sent over that interface. However, on point-to-point links we also recommend that PIM Join/Prune messages with an upstream neighbor address field of all zeros are also accepted.",
      "ja": "ポイントツーポイントリンク上のアンナンバードインターフェイスでは、ルータのアドレスは、それがそのインターフェイスを介して送信されるHelloメッセージのために選択した送信元アドレスと同じでなければなりません。しかし、ポイントツーポイントリンク上で、我々はまた、PIMも受け入れられているすべてゼロの上流隣接アドレスフィールドに/プルーンのメッセージに参加することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Transitions from NoInfo State",
      "ja": "NoInfo状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in NoInfo (NI) state, the following event may trigger a transition:",
      "ja": "NoInfoで（NI）状態、次のイベントが遷移をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "Receive Prune(S,G,rpt) A Prune(S,G,rpt) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "プルーン（S、G、RPT）を受信プルーン（S、G、RPTは）私はI.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインターフェイスで受信されます"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I\ntransitions to the Prune-Pending state.  The Expiry Timer (ET)\nis started and set to the HoldTime from the triggering\nJoin/Prune message.  The Prune-Pending Timer is started.  It\nis set to the J/P_Override_Interval(I) if the router has more\nthan one neighbor on that interface; otherwise, it is set to\nzero, causing it to expire immediately.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from Prune-Pending State",
      "ja": "プルーン保留状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in Prune-Pending (PP) state, the following events may trigger a transition:",
      "ja": "プルーン・保留（PP）の状態で、次のイベントが遷移をトリガすることができる場合。"
    },
    {
      "indent": 5,
      "text": "Receive Join(*,G) A Join(*,G) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "参加受信（*、G）Aは、（*、G）参加I.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインタフェース上でIを受信します"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I\ntransitions to Prune-Pending-Tmp state whilst the remainder of\nthe compound Join/Prune message containing the Join(*,G) is\nprocessed.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Receive Join(S,G,rpt) A Join(S,G,rpt) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "（S、G、RPT）A参加（S、G、RPT）を参加受信I.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインタフェース上でIを受信します"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I\ntransitions to NoInfo state.  ET and PPT are canceled.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Prune-Pending Timer Expires The Prune-Pending Timer for the (S,G,rpt) downstream state machine on interface I expires.",
      "ja": "プルーン保留タイマーIが満了するインターフェイスで（S、G、RPT）下流ステートマシンのプルーン・保留タイマー期限切れ。"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I\ntransitions to the Prune state.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from Prune State",
      "ja": "プルーンの状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in Prune (P) state, the following events may trigger a transition:",
      "ja": "プルーンに（P）状態で、次のイベントが遷移をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "Receive Join(*,G) A Join(*,G) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "参加受信（*、G）Aは、（*、G）参加I.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインタフェース上でIを受信します"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I\ntransitions to PruneTmp state whilst the remainder of the\ncompound Join/Prune message containing the Join(*,G) is\nprocessed.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Receive Join(S,G,rpt) A Join(S,G,rpt) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "（S、G、RPT）A参加（S、G、RPT）を参加受信I.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインタフェース上でIを受信します"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I\ntransitions to NoInfo state.  ET and PPT are canceled.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Receive Prune(S,G,rpt) A Prune(S,G,rpt) is received on interface I with its Upstream Neighbor Address set to the router's primary IP address on I.",
      "ja": "プルーン（S、G、RPT）を受信プルーン（S、G、RPTは）私はI.上のルータのプライマリIPアドレスに設定し、その上流隣接アドレスを持つインターフェイスで受信されます"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I remains\nin Prune state.  The Expiry Timer (ET) is restarted, set to\nmaximum of its current value and the HoldTime from the\ntriggering Join/Prune message.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Expiry Timer Expires The Expiry Timer for the (S,G,rpt) downstream state machine on interface I expires.",
      "ja": "有効期限タイマーIが満了するインターフェイス上で（S、G、RPT）下流のステートマシンの有効期限タイマーが期限切れ。"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I\ntransitions to the NoInfo state.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from Prune-Pending-Tmp State",
      "ja": "プルーン保留-TMPの状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in Prune-Pending-Tmp (PP') state and processing a compound Join/Prune message, the following events may trigger a transition:",
      "ja": "プルーン保留-TMP（PP '）状態と化合物処理/プルーンメッセージに参加すると、次のイベントが遷移をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "Receive Prune(S,G,rpt) The compound Join/Prune message contains a Prune(S,G,rpt).",
      "ja": "プルーン（S、G、RPT）参加/プルーンメッセージはプルーン（S、G、RPT）を含む化合物を受けます。"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I\ntransitions back to the Prune-Pending state.  The Expiry Timer\n(ET) is restarted, set to maximum of its current value and the\nHoldTime from the triggering Join/Prune message.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "End of Message The end of the compound Join/Prune message is reached.",
      "ja": "メッセージの最後には、化合物の終わりには、/プルーンのメッセージに達した参加します。"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I\ntransitions to the NoInfo state.  ET and PPT are canceled.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from PruneTmp State",
      "ja": "PruneTmp状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in PruneTmp (P') state and processing a compound Join/Prune message, the following events may trigger a transition:",
      "ja": "化合物PruneTmp（P '）状態にして処理/プルーンメッセージに参加すると、次のイベントが遷移をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "Receive Prune(S,G,rpt) The compound Join/Prune message contains a Prune(S,G,rpt).",
      "ja": "プルーン（S、G、RPT）参加/プルーンメッセージはプルーン（S、G、RPT）を含む化合物を受けます。"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I\ntransitions back to the Prune state.  The Expiry Timer (ET) is\nrestarted, set to maximum of its current value and the\nHoldTime from the triggering Join/Prune message.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "End of Message The end of the compound Join/Prune message is reached.",
      "ja": "メッセージの最後には、化合物の終わりには、/プルーンのメッセージに達した参加します。"
    },
    {
      "indent": 10,
      "text": "The (S,G,rpt) downstream state machine on interface I\ntransitions to the NoInfo state.  ET is canceled.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 3,
      "text": "Receiving a Prune(*,G) does not affect the (S,G,rpt) downstream state machine.",
      "ja": "プルーン（*、G）を受信すると、（S、G、RPT）下流のステートマシンには影響を与えません。"
    },
    {
      "indent": 3,
      "text": "Receiving a Join(*,*,RP) does not affect the (S,G,rpt) downstream state machine. If a router has originated Join(*,*,RP) and pruned a source off it using Prune(S,G,rpt), then to receive that source again it should explicitly re-join using Join(S,G,rpt) or Join(*,G). In some LAN topologies it is possible for a router sending a new Join(*,*,RP) to have to wait as much as a Join/Prune Interval before noticing that it needs to override a neighbor's preexisting Prune(S,G,rpt). This is considered acceptable, as (*,*,RP) state is intended to be used only in long-lived and persistent scenarios.",
      "ja": "（*、*、RP）に参加受信すると、（S、G、RPT）下流のステートマシンには影響を与えません。ルータが（*、*、RP）に参加起源とプルーン（S、G、RPT）を使用して、それをオフソースを剪定している場合は、それが明示的に参加使用して再加入する必要があり、再びそのソースを受信する（S、G、RPT）または（*、G）に参加。一部のLANのトポロジでは、新しい参加（*、*、RP）を送信するルータの可能性である、それは隣人の既存のプルーン（S、G、RPTを上書きする必要があることに気付い前に、参加/プルーン間隔限りを待つ必要がします）。 （*、*、RP）状態が長寿命と持続的なシナリオでのみ使用することを意図しているように、これは、許容できると考えられます。"
    },
    {
      "indent": 0,
      "text": "4.5.5. Sending (*,*,RP) Join/Prune Messages",
      "section_title": true,
      "ja": "4.5.5。 （*、*、RP）の送信/プルーンのメッセージに参加"
    },
    {
      "indent": 3,
      "text": "The per-interface state machines for (*,*,RP) hold join state from downstream PIM routers. This state then determines whether a router needs to propagate a Join(*,*,RP) upstream towards the RP.",
      "ja": "（*、*、RP）ごとのインターフェイスのステートマシン下流のPIMルータから状態を保持する参加。この状態は、ルータは、上流のRPに向けて参加（*、*、RP）を伝播する必要があるかどうかを判定する。"
    },
    {
      "indent": 3,
      "text": "If a router wishes to propagate a Join(*,*,RP) upstream, it must also watch for messages on its upstream interface from other routers on that subnet, and these may modify its behavior. If it sees a Join(*,*,RP) to the correct upstream neighbor, it should suppress its own Join(*,*,RP). If it sees a Prune(*,*,RP) to the correct upstream neighbor, it should be prepared to override that prune by sending a Join(*,*,RP) almost immediately. Finally, if it sees the Generation ID (see Section 4.3) of the correct upstream neighbor change, it knows that the upstream neighbor has lost state, and it should be prepared to refresh the state by sending a Join(*,*,RP) almost immediately.",
      "ja": "ルータが（*、*、RP）に参加伝播することを希望する場合は、上流、それはまた、そのサブネット上の他のルータからのアップストリームインターフェイス上のメッセージを監視しなければならない、これらはその動作を変更することがあります。それが正しい上流の隣人への参加（*、*、RP）を見れば、それは（*、*、RP）に参加、独自のを抑制すべきです。それが正しい上流の隣人にプルーン（*、*、RP）を見れば、ほとんどすぐに参加（*、*、RP）を送信することによって、そのプルーンを上書きするために準備する必要があります。それは世代のIDを見れば最終的に、それは上流の隣人が状態を失ったことを知っている、送信することにより、状態をリフレッシュするために準備する必要があり、正しい上流隣接変化（4.3節を参照）に参加（*、*、RP）ほぼすぐに。"
    },
    {
      "indent": 3,
      "text": "In addition, if the MRIB changes to indicate that the next hop towards the RP has changed, the router should prune off from the old next hop and join towards the new next hop.",
      "ja": "MRIBの変更はRPへのネクストホップが変更されたことを示すためにあればまた、ルータは古いネクストホップからオフ剪定すべきであり、新しい次のホップの方に参加します。"
    },
    {
      "indent": 3,
      "text": "The upstream (*,*,RP) state machine contains only two states:",
      "ja": "上流（*、*、RP）ステートマシンは、2つの状態しか含まれています。"
    },
    {
      "indent": 3,
      "text": "Not Joined The downstream state machines and local membership information do not indicate that the router needs to join the (*,*,RP) tree for this RP.",
      "ja": "下流のステートマシンとローカルメンバーシップ情報参加していないが、ルータがこのRPのために（*、*、RP）ツリーに加入する必要があることを示すものではありません。"
    },
    {
      "indent": 3,
      "text": "Joined The downstream state machines and local membership information indicate that the router should join the (*,*,RP) tree for this RP.",
      "ja": "入社下流のステートマシンとローカルメンバーシップ情報は、ルータがこのRPのために（*、*、RP）ツリーに参加すべきであることを示しています。"
    },
    {
      "indent": 3,
      "text": "In addition, one timer JT(*,*,RP) is kept that is used to trigger the sending of a Join(*,*,RP) to the upstream next hop towards the RP, NBR(RPF_interface(RP), MRIB.next_hop(RP)).",
      "ja": "また、1つのタイマーJT（*、*、RP）は、それはRP、NBR（RPF_interface（RP）、MRIBに向けて上流の次のホップへの参加（*、*、RP）の送信をトリガするために使用されて保持されます。 NEXT_HOP（RP））。"
    },
    {
      "indent": 7,
      "text": "Figure 6: Upstream (*,*,RP) state machine in tabular form",
      "ja": "図6：表形式の上流（*、*、RP）状態マシン"
    },
    {
      "indent": 0,
      "text": "+-------------------++-------------------------------------------------+\n|                   ||                      Event                      |\n|  Prev State       ++-------------------------+-----------------------+\n|                   ||   JoinDesired           |    JoinDesired        |\n|                   ||   (*,*,RP) ->True       |    (*,*,RP) ->False   |\n+-------------------++-------------------------+-----------------------+\n|                   ||   -> J state            |    -                  |\n|  NotJoined (NJ)   ||   Send Join(*,*,RP);    |                       |\n|                   ||   Set Join Timer to     |                       |\n|                   ||   t_periodic            |                       |\n+-------------------++-------------------------+-----------------------+\n|  Joined (J)       ||   -                     |    -> NJ state        |\n|                   ||                         |    Send Prune         |\n|                   ||                         |    (*,*,RP); Cancel   |\n|                   ||                         |    Join Timer         |\n+-------------------++-------------------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In addition, we have the following transitions, which occur within the Joined state:",
      "ja": "また、当社は、接合状態内で発生し、次の遷移を、持っています："
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                         In Joined (J) State                          |\n+-------------------+--------------------+-----------------------------+\n| Timer Expires     |  See               |   See                       |\n|                   |  Join(*,*,RP)      |   Prune(*,*,RP)             |\n|                   |  to MRIB.          |   to MRIB.                  |\n|                   |  next_hop(RP)      |   next_hop(RP)              |\n+-------------------+--------------------+-----------------------------+\n| Send              |  Increase Join     |   Decrease Join             |\n| Join(*,*,RP);     |  Timer to          |   Timer to                  |\n| Set Join Timer    |  t_joinsuppress    |   t_override                |\n| to t_periodic     |                    |                             |\n+-------------------+--------------------+-----------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                         In Joined (J) State                          |\n+-----------------------------------+----------------------------------+\n|    NBR(RPF_interface(RP),         |       MRIB.next_hop(RP) GenID    |\n|    MRIB.next_hop(RP))             |       changes                    |\n|    changes                        |                                  |\n+-----------------------------------+----------------------------------+\n|    Send Join(*,*,RP) to new       |       Decrease Join Timer to     |\n|    next hop; Send                 |       t_override                 |\n|    Prune(*,*,RP) to old           |                                  |\n|    next hop; set Join Timer       |                                  |\n|    to t_periodic                  |                                  |\n+-----------------------------------+----------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This state machine uses the following macro:",
      "ja": "このステートマシンは、次のマクロを使用しています："
    },
    {
      "indent": 5,
      "text": "bool JoinDesired(*,*,RP) { if immediate_olist(*,*,RP) != NULL return TRUE else return FALSE }",
      "ja": "BOOL JoinDesired（*、*、RP）{immediate_olist（*、*、RP）であればそうでない！= NULLリターンTRUEはFALSEを返します}"
    },
    {
      "indent": 3,
      "text": "JoinDesired(*,*,RP) is true when the router has received (*,*,RP) Joins from any downstream interface. Note that although JoinDesired is true, the router's sending of a Join(*,*,RP) message may be suppressed by another router sending a Join(*,*,RP) onto the upstream interface.",
      "ja": "JoinDesiredは（*、*、RP）ルータが受信したとき（*、*、RP）真である任意のダウンストリームインターフェイスから参加します。 JoinDesiredが真であるが、ルータの送信参加（*、*、RP）メッセージの上流インタフェースに参加（*、*、RP）を送信する別のルータによって抑制することができることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Transitions from NotJoined State",
      "ja": "NotJoined状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When the upstream (*,*,RP) state machine is in NotJoined state, the following event may trigger a state transition:",
      "ja": "上流（*、*、RP）状態マシンはNotJoined状態にある場合、次のイベントは、状態遷移をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "JoinDesired(*,*,RP) becomes True The downstream state for (*,*,RP) has changed so that at least one interface is in immediate_olist(*,*,RP), making JoinDesired(*,*,RP) become True.",
      "ja": "少なくとも1つのインタフェースがJoinDesired（*、*、RP）を製造する、（*、*、RP）immediate_olistになるようJoinDesired（*、*、RP）が（*、*、RP）のダウンストリーム状態が変更された真となるになります真。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,*,RP) state machine transitions to Joined\nstate.  Send Join(*,*,RP) to the appropriate upstream\nneighbor, which is NBR(RPF_interface(RP), MRIB.next_hop(RP)).\nSet the Join Timer (JT) to expire after t_periodic seconds.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from Joined State",
      "ja": "接合状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When the upstream (*,*,RP) state machine is in Joined state, the following events may trigger state transitions:",
      "ja": "上流（*、*、RP）状態機械が結合状態にあるときに、次のイベントは、状態遷移をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "JoinDesired(*,*,RP) becomes False The downstream state for (*,*,RP) has changed so no interface is in immediate_olist(*,*,RP), making JoinDesired(*,*,RP) become False.",
      "ja": "JoinDesiredは（*、*、RP）（*、*、RP）はfalse下流状態となるJoinDesired（*、*、RP）がFalseになる作り、（*、*、RP）がインターフェイスがimmediate_olistにないよう変更されています。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,*,RP) state machine transitions to NotJoined\nstate.  Send Prune(*,*,RP) to the appropriate upstream\nneighbor, which is NBR(RPF_interface(RP), MRIB.next_hop(RP)).\nCancel the Join Timer (JT).",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Join Timer Expires The Join Timer (JT) expires, indicating time to send a Join(*,*,RP)",
      "ja": "タイマーは、時間を示すことに参加送信するために満了するタイマー（JT）が参加期限切れに参加（*、*、RP）"
    },
    {
      "indent": 10,
      "text": "Send Join(*,*,RP) to the appropriate upstream neighbor, which\nis NBR(RPF_interface(RP), MRIB.next_hop(RP)).  Restart the\nJoin Timer (JT) to expire after t_periodic seconds.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "See Join(*,*,RP) to MRIB.next_hop(RP) This event is only relevant if RPF_interface(RP) is a shared medium. This router sees another router on RPF_interface(RP) send a Join(*,*,RP) to NBR(RPF_interface(RP), MRIB.next_hop(RP)). This causes this router to suppress its own Join.",
      "ja": "RPF_interface（RP）が共有メディアである場合、このイベントはのみ関連しMRIB.next_hop（RP）に（*、*、RP）に参加を参照してください。このルータは、NBR（RPF_interface（RP）、MRIB.next_hop（RP））に（RP）（*、*、RP）に参加を送るRPF_interfaceに別のルータを見ています。これは、このルータが参加し、独自のを抑制する原因となります。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,*,RP) state machine remains in Joined state.",
      "ja": "上流（*、*、RP）ステートマシンは、接合状態のままになります。"
    },
    {
      "indent": 10,
      "text": "Let t_joinsuppress be the minimum of t_suppressed and the HoldTime from the Join/Prune message triggering this event. If the Join Timer is set to expire in less than t_joinsuppress seconds, reset it so that it expires after t_joinsuppress seconds. If the Join Timer is set to expire in more than t_joinsuppress seconds, leave it unchanged.",
      "ja": "t_joinsuppressがt_suppressedの最小値と、このイベントをトリガ/プルーンに参加したメッセージからのHoldTimeとします。参加タイマーがt_joinsuppress秒未満で期限が切れるように設定されている場合、それはt_joinsuppress秒後に期限切れになるように、それをリセットします。参加タイマーがt_joinsuppress秒以上で有効期限が切れるように設定されている場合、それは変わらないまま。"
    },
    {
      "indent": 5,
      "text": "See Prune(*,*,RP) to MRIB.next_hop(RP) This event is only relevant if RPF_interface(RP) is a shared medium. This router sees another router on RPF_interface(RP) send a Prune(*,*,RP) to NBR(RPF_interface(RP), MRIB.next_hop(RP)). As this router is in Joined state, it must override the Prune after a short random interval.",
      "ja": "RPF_interface（RP）が共有メディアである場合、このイベントはのみ関連しMRIB.next_hop（RP）にプルーン（*、*、RP）を参照してください。このルータはRPF_interface上の別のルータを（RP）NBR（RPF_interface（RP）、MRIB.next_hop（RP））にプルーン（*、*、RP）を送る見ています。このルータが参加状態にあるとして、それは短いランダムな間隔の後にプルーンをオーバーライドする必要があります。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,*,RP) state machine remains in Joined state.\nIf the Join Timer is set to expire in more than t_override\nseconds, reset it so that it expires after t_override seconds.\nIf the Join Timer is set to expire in less than t_override\nseconds, leave it unchanged.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "NBR(RPF_interface(RP), MRIB.next_hop(RP)) changes A change in the MRIB routing base causes the next hop towards the RP to change.",
      "ja": "NBR（RPF_interface（RP）、MRIB.next_hop（RP））はMRIBルーティングベースの変化がRPに向かって次のホップを変更させる変更します。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,*,RP) state machine remains in Joined state.\nSend Join(*,*,RP) to the new upstream neighbor, which is the\nnew value of NBR(RPF_interface(RP), MRIB.next_hop(RP)).  Send\nPrune(*,*,RP) to the old upstream neighbor, which is the old\nvalue of NBR(RPF_interface(RP), MRIB.next_hop(RP)).  Set the\nJoin Timer (JT) to expire after t_periodic seconds.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "MRIB.next_hop(RP) GenID changes The Generation ID of the router that is MRIB.next_hop(RP) changes. This normally means that this neighbor has lost state, and so the state must be refreshed.",
      "ja": "MRIB.next_hop（RP）られたGenIDはMRIB.next_hop（RP）の変化であるルータの世代のIDを変更します。これは通常、この隣人が状態を失ったことを意味し、その状態をリフレッシュする必要があります。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,*,RP) state machine remains in Joined state.\nIf the Join Timer is set to expire in more than t_override\nseconds, reset it so that it expires after t_override seconds.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5.6. Sending (*,G) Join/Prune Messages",
      "section_title": true,
      "ja": "4.5.6。 （*、G）参加/プルーンのメッセージの送信"
    },
    {
      "indent": 3,
      "text": "The per-interface state machines for (*,G) hold join state from downstream PIM routers. This state then determines whether a router needs to propagate a Join(*,G) upstream towards the RP.",
      "ja": "（*、G）のためのインターフェイス単位のステートマシンは、下流のPIMルータから状態を結合保持します。この状態は、ルータは、上流のRPに向けて（*、G）が参加伝播する必要があるかどうかを判定する。"
    },
    {
      "indent": 3,
      "text": "If a router wishes to propagate a Join(*,G) upstream, it must also watch for messages on its upstream interface from other routers on that subnet, and these may modify its behavior. If it sees a Join(*,G) to the correct upstream neighbor, it should suppress its own Join(*,G). If it sees a Prune(*,G) to the correct upstream neighbor, it should be prepared to override that prune by sending a Join(*,G) almost immediately. Finally, if it sees the Generation ID (see Section 4.3) of the correct upstream neighbor change, it knows that the upstream neighbor has lost state, and it should be prepared to refresh the state by sending a Join(*,G) almost immediately.",
      "ja": "ルータが参加（*、G）上流を伝播することを希望する場合は、それはまた、そのサブネット上の他のルータからのアップストリームインターフェイス上のメッセージを監視しなければならない、これらはその動作を変更することがあります。それが正しい上流の隣人に（*、G）参加見れば、それは自身の参加抑える必要があります（*、G）。それが正しい上流の隣人へのプルーン（*、G）を見れば、ほとんどすぐに（*、G）に参加送信することによって、そのプルーンを上書きするために準備する必要があります。それは世代のIDを見れば最終的に、ほとんどすぐにそれが上流の隣人が状態を失ったことを知っている、参加（*、G）を送信することにより、状態をリフレッシュするために準備する必要があり、正しい上流隣接変化（4.3節を参照してください） 。"
    },
    {
      "indent": 3,
      "text": "If a (*,G) Assert occurs on the upstream interface, and this changes this router's idea of the upstream neighbor, it should be prepared to ensure that the Assert winner is aware of downstream routers by sending a Join(*,G) almost immediately.",
      "ja": "（*、G）アサートがアップストリームインターフェイス上で発生し、これが上流の隣人のこのルータのアイデアを変更した場合、それがアサート勝者が参加（*、G）を送信することにより、下流のルータを認識していることを確認するために準備する必要があり、ほとんどすぐに。"
    },
    {
      "indent": 3,
      "text": "In addition, if the MRIB changes to indicate that the next hop towards the RP has changed, and either the upstream interface changes or there is no Assert winner on the upstream interface, the router should prune off from the old next hop and join towards the new next hop.",
      "ja": "また、MRIBの変更はRPへのネクストホップが変更されたことを示しており、いずれかのアップストリームインターフェイスの変更またはアップストリームインターフェイスにはアサート勝者が存在しないためにあれば、ルータは古いネクストホップからオフ剪定に向かって参加する必要があります新しい次のホップ。"
    },
    {
      "indent": 3,
      "text": "The upstream (*,G) state machine only contains two states:",
      "ja": "上流（*、G）ステートマシンは、2つの状態しか含まれています。"
    },
    {
      "indent": 3,
      "text": "Not Joined The downstream state machines indicate that the router does not need to join the RP tree for this group.",
      "ja": "参加していない下流のステートマシンは、ルータがこのグループのRPツリーに参加する必要がないことを示しています。"
    },
    {
      "indent": 3,
      "text": "Joined The downstream state machines indicate that the router should join the RP tree for this group.",
      "ja": "下流のステートマシンは、ルータがこのグループのRPツリーに参加する必要があることを示し入社。"
    },
    {
      "indent": 3,
      "text": "In addition, one timer JT(*,G) is kept that is used to trigger the sending of a Join(*,G) to the upstream next hop towards the RP, RPF'(*,G).",
      "ja": "さらに、1つのタイマJT（*、G）は、それが（*、G） 'RPF、RPに向かって上流の次のホップに参加（*、G）の送信をトリガするために使用されて保持されます。"
    },
    {
      "indent": 9,
      "text": "Figure 7: Upstream (*,G) state machine in tabular form",
      "ja": "図7：表形式の上流（*、G）ステートマシン"
    },
    {
      "indent": 0,
      "text": "+-------------------++-------------------------------------------------+\n|                   ||                      Event                      |\n|  Prev State       ++------------------------+------------------------+\n|                   ||   JoinDesired(*,G)     |    JoinDesired(*,G)    |\n|                   ||   ->True               |    ->False             |\n+-------------------++------------------------+------------------------+\n|                   ||   -> J state           |    -                   |\n|  NotJoined (NJ)   ||   Send Join(*,G);      |                        |\n|                   ||   Set Join Timer to    |                        |\n|                   ||   t_periodic           |                        |\n+-------------------++------------------------+------------------------+\n|  Joined (J)       ||   -                    |    -> NJ state         |\n|                   ||                        |    Send Prune(*,G);    |\n|                   ||                        |    Cancel Join Timer   |\n+-------------------++------------------------+------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In addition, we have the following transitions, which occur within the Joined state:",
      "ja": "また、当社は、接合状態内で発生し、次の遷移を、持っています："
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                        In Joined (J) State                           |\n+----------------+-----------------+-----------------+-----------------+\n|Timer Expires   | See Join(*,G)   | See Prune(*,G)  | RPF'(*,G)       |\n|                | to RPF'(*,G)    | to RPF'(*,G)    | changes due to  |\n|                |                 |                 | an Assert       |\n+----------------+-----------------+-----------------+-----------------+\n|Send            | Increase Join   | Decrease Join   | Decrease Join   |\n|Join(*,G); Set  | Timer to        | Timer to        | Timer to        |\n|Join Timer to   | t_joinsuppress  | t_override      | t_override      |\n|t_periodic      |                 |                 |                 |\n+----------------+-----------------+-----------------+-----------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                         In Joined (J) State                          |\n+----------------------------------+-----------------------------------+\n|    RPF'(*,G) changes not         |       RPF'(*,G) GenID changes     |\n|    due to an Assert              |                                   |\n+----------------------------------+-----------------------------------+\n|    Send Join(*,G) to new         |       Decrease Join Timer to      |\n|    next hop; Send                |       t_override                  |\n|    Prune(*,G) to old next        |                                   |\n|    hop; Set Join Timer to        |                                   |\n|    t_periodic                    |                                   |\n+----------------------------------+-----------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This state machine uses the following macro:",
      "ja": "このステートマシンは、次のマクロを使用しています："
    },
    {
      "indent": 5,
      "text": "bool JoinDesired(*,G) { if (immediate_olist(*,G) != NULL OR (JoinDesired(*,*,RP(G)) AND AssertWinner(*, G, RPF_interface(RP(G))) != NULL)) return TRUE else return FALSE }",
      "ja": "BOOL JoinDesired（*、G）{場合（immediate_olist（*、G）！= NULL OR（JoinDesired（*、*、RP（G））AND AssertWinner（*、G、RPF_interface（RP（G）））！= NULL ））} FALSEを返す他にTRUEを返します"
    },
    {
      "indent": 3,
      "text": "JoinDesired(*,G) is true when the router has forwarding state that would cause it to forward traffic for G using shared tree state. Note that although JoinDesired is true, the router's sending of a Join(*,G) message may be suppressed by another router sending a Join(*,G) onto the upstream interface.",
      "ja": "ルータは共有ツリーの状態を使用してGのためのトラフィックを転送させるような状態を転送したときJoinDesired（*、G）が真です。 JoinDesiredが真であるが、ルータの送信参加（*、G）メッセージの上流インタフェースに参加（*、G）を送信する別のルータによって抑制することができることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Transitions from NotJoined State",
      "ja": "NotJoined状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When the upstream (*,G) state machine is in NotJoined state, the following event may trigger a state transition:",
      "ja": "上流（*、G）ステートマシンはNotJoined状態にある場合、次のイベントは、状態遷移をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "JoinDesired(*,G) becomes True The macro JoinDesired(*,G) becomes True, e.g., because the downstream state for (*,G) has changed so that at least one interface is in immediate_olist(*,G).",
      "ja": "JoinDesiredは（*、G）は、少なくとも1つのインターフェースがimmediate_olist（*、G）となるようにするための下流の状態（*、G）が変更されたため、マクロJoinDesired（*、G）は、例えば、真となる真となります。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,G) state machine transitions to Joined state.\nSend Join(*,G) to the appropriate upstream neighbor, which is\nRPF'(*,G).  Set the Join Timer (JT) to expire after t_periodic\nseconds.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from Joined State",
      "ja": "接合状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When the upstream (*,G) state machine is in Joined state, the following events may trigger state transitions:",
      "ja": "上流（*、G）ステートマシンは、接合状態にあるときに、次のイベントは、状態遷移をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "JoinDesired(*,G) becomes False The macro JoinDesired(*,G) becomes False, e.g., because the downstream state for (*,G) has changed so no interface is in immediate_olist(*,G).",
      "ja": "JoinDesired（*、G）がマクロJoinDesired（*、G）が偽となる偽となり、例えば、（*、G）のためのダウンストリーム状態ためにはインターフェースがimmediate_olist（*、G）になっていないので、変更されています。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,G) state machine transitions to NotJoined\nstate.  Send Prune(*,G) to the appropriate upstream neighbor,\nwhich is RPF'(*,G).  Cancel the Join Timer (JT).",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Join Timer Expires The Join Timer (JT) expires, indicating time to send a Join(*,G)",
      "ja": "参加（*、G）を送信する時間を示すタイマタイマー（JT）が経過に参加期限参加"
    },
    {
      "indent": 10,
      "text": "Send Join(*,G) to the appropriate upstream neighbor, which is\nRPF'(*,G).  Restart the Join Timer (JT) to expire after\nt_periodic seconds.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "See Join(*,G) to RPF'(*,G) This event is only relevant if RPF_interface(RP(G)) is a shared medium. This router sees another router on RPF_interface(RP(G)) send a Join(*,G) to RPF'(*,G). This causes this router to suppress its own Join.",
      "ja": "RPF_interface（RP（G））が共有メディアである場合、このイベントにのみ関連している（G、*） \"RPFに（G、*）に参加を参照してください。このルータはRPFに参加（*、G）を送るRPF_interface（RP（G））上の別のルータを見ている '（*、G）。これは、このルータが参加し、独自のを抑制する原因となります。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,G) state machine remains in Joined state.",
      "ja": "上流（*、G）ステートマシンは、接合状態のままです。"
    },
    {
      "indent": 10,
      "text": "Let t_joinsuppress be the minimum of t_suppressed and the HoldTime from the Join/Prune message triggering this event. If the Join Timer is set to expire in less than t_joinsuppress seconds, reset it so that it expires after t_joinsuppress seconds. If the Join Timer is set to expire in more than t_joinsuppress seconds, leave it unchanged.",
      "ja": "t_joinsuppressがt_suppressedの最小値と、このイベントをトリガ/プルーンに参加したメッセージからのHoldTimeとします。参加タイマーがt_joinsuppress秒未満で期限が切れるように設定されている場合、それはt_joinsuppress秒後に期限切れになるように、それをリセットします。参加タイマーがt_joinsuppress秒以上で有効期限が切れるように設定されている場合、それは変わらないまま。"
    },
    {
      "indent": 5,
      "text": "See Prune(*,G) to RPF'(*,G) This event is only relevant if RPF_interface(RP(G)) is a shared medium. This router sees another router on RPF_interface(RP(G)) send a Prune(*,G) to RPF'(*,G). As this router is in Joined state, it must override the Prune after a short random interval.",
      "ja": "RPF_interface（RP（G））が共有メディアであるかどうかを確認プルーンRPFに（*、G） '（*、G）は、このイベントにのみ関係します。このルータはRPF_interface（RP（G））上の別のルータを見て（*、G）「RPFにプルーン（*、G）を送ります。このルータが参加状態にあるとして、それは短いランダムな間隔の後にプルーンをオーバーライドする必要があります。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,G) state machine remains in Joined state.  If\nthe Join Timer is set to expire in more than t_override\nseconds, reset it so that it expires after t_override seconds.\nIf the Join Timer is set to expire in less than t_override\nseconds, leave it unchanged.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RPF'(*,G) changes due to an Assert The current next hop towards the RP changes due to an Assert(*,G) on the RPF_interface(RP(G)).",
      "ja": "RPF '（*、G）によりRPF_interfaceにアサート（*、G）（RP（G））にアサートRP変化に向かって現在の次のホップによる変化。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,G) state machine remains in Joined state.  If\nthe Join Timer is set to expire in more than t_override\nseconds, reset it so that it expires after t_override seconds.\nIf the Join Timer is set to expire in less than t_override\nseconds, leave it unchanged.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RPF'(*,G) changes not due to an Assert An event occurred that caused the next hop towards the RP for G to change. This may be caused by a change in the MRIB routing database or the group-to-RP mapping. Note that this transition does not occur if an Assert is active and the upstream interface does not change.",
      "ja": "RPF '（*、G）イベントをアサートによるものではない変更はGが変化するためにRPに向けて次のホップを引き起こしたこと起こりました。これはMRIBルーティングデータベースまたはグループ対RPマッピングの変化によって引き起こされ得ます。アサートがアクティブであり、アップストリームインターフェイスが変更されない場合は、この遷移が発生しないことに留意されたいです。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,G) state machine remains in Joined state.\nSend Join(*,G) to the new upstream neighbor, which is the new\nvalue of RPF'(*,G).  Send Prune(*,G) to the old upstream\nneighbor, which is the old value of RPF'(*,G).  Use the new\nvalue of RP(G) in the Prune(*,G) message or all zeros if RP(G)\nbecomes unknown (old value of RP(G) may be used instead to\nimprove behavior in routers implementing older versions of\nthis spec).  Set the Join Timer (JT) to expire after\nt_periodic seconds.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RPF'(*,G) GenID changes The Generation ID of the router that is RPF'(*,G) changes. This normally means that this neighbor has lost state, and so the state must be refreshed.",
      "ja": "RPFは、（*、G）が変化する '（*、G）られたGenIDはRPFあるルータの世代IDを変更します'。これは通常、この隣人が状態を失ったことを意味し、その状態をリフレッシュする必要があります。"
    },
    {
      "indent": 10,
      "text": "The upstream (*,G) state machine remains in Joined state.  If\nthe Join Timer is set to expire in more than t_override\nseconds, reset it so that it expires after t_override seconds.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5.7. Sending (S,G) Join/Prune Messages",
      "section_title": true,
      "ja": "4.5.7。送信（S、G）/プルーンメッセージに参加"
    },
    {
      "indent": 3,
      "text": "The per-interface state machines for (S,G) hold join state from downstream PIM routers. This state then determines whether a router needs to propagate a Join(S,G) upstream towards the source.",
      "ja": "（S、G）のためのインターフェイス単位のステートマシンは、下流のPIMルータから状態を結合保持します。この状態では、ルータは、上流のソースに向かって参加する（S、G）を伝播する必要があるか否かを判断します。"
    },
    {
      "indent": 3,
      "text": "If a router wishes to propagate a Join(S,G) upstream, it must also watch for messages on its upstream interface from other routers on that subnet, and these may modify its behavior. If it sees a Join(S,G) to the correct upstream neighbor, it should suppress its own Join(S,G). If it sees a Prune(S,G), Prune(S,G,rpt), or Prune(*,G) to the correct upstream neighbor towards S, it should be prepared to override that prune by scheduling a Join(S,G) to be sent almost immediately. Finally, if it sees the Generation ID of its upstream neighbor change, it knows that the upstream neighbor has lost state, and it should refresh the state by scheduling a Join(S,G) to be sent almost immediately.",
      "ja": "ルータは、上流（S、G）に参加伝播することを希望する場合は、それはまた、そのサブネット上の他のルータからのアップストリームインターフェイス上のメッセージを監視しなければならない、これらはその動作を変更することがあります。それが正しい上流の隣人に（S、G）に参加を見れば、それは（S、G）に参加、独自のを抑制すべきです。それはSに向けた正しい上流の隣人にプルーン（S、G）、プルーン（S、G、RPT）、またはプルーン（*、G）を見れば、参加（Sをスケジュールすることにより、そのプルーンを上書きするために準備する必要がありますG）は、ほぼ即座に送信されます。それはその上流隣接変更の生成IDを見れば最終的に、それは上流の隣人が状態を失ったことを知っている、それはほとんどすぐに送信される（S、G）に参加スケジュールすることにより、状態をリフレッシュする必要があります。"
    },
    {
      "indent": 3,
      "text": "If a (S,G) Assert occurs on the upstream interface, and this changes the this router's idea of the upstream neighbor, it should be prepared to ensure that the Assert winner is aware of downstream routers by scheduling a Join(S,G) to be sent almost immediately.",
      "ja": "（S、G）アサートがアップストリームインターフェイス上で発生し、これが上流の隣人のこのルータのアイデアを変更した場合、アサート勝者が参加（S、G）をスケジュールすることによって、下流のルータを認識していることを確認するために準備する必要がありますほとんどすぐに送信されます。"
    },
    {
      "indent": 3,
      "text": "In addition, if MRIB changes cause the next hop towards the source to change, and either the upstream interface changes or there is no Assert winner on the upstream interface, the router should send a prune to the old next hop and a join to the new next hop.",
      "ja": "MRIBの変更が元に向けた次のホップを変化させると、どちらかのアップストリームインターフェイスの変更またはアップストリームインターフェイスにはアサート勝者が存在しない場合はまた、ルータは古いネクストホップにプルーンを送信する必要があり、新たなに参加しますネクストホップ。"
    },
    {
      "indent": 3,
      "text": "The upstream (S,G) state machine only contains two states:",
      "ja": "アップストリーム（S、G）は、ステートマシンは、2つの状態しか含まれています。"
    },
    {
      "indent": 3,
      "text": "Not Joined The downstream state machines and local membership information do not indicate that the router needs to join the shortest-path tree for this (S,G).",
      "ja": "ルータがこの（S、G）のための最短パスツリーに加入する必要があることを示すものではありません下流のステートマシンとローカルメンバーシップ情報を参加していません。"
    },
    {
      "indent": 3,
      "text": "Joined The downstream state machines and local membership information indicate that the router should join the shortest-path tree for this (S,G).",
      "ja": "下流のステートマシンとローカルメンバーシップ情報をルータがこの（S、G）のための最短パスツリーに参加するべきであることを示す参加しました。"
    },
    {
      "indent": 3,
      "text": "In addition, one timer JT(S,G) is kept that is used to trigger the sending of a Join(S,G) to the upstream next hop towards S, RPF'(S,G).",
      "ja": "加えて、1つのタイマーJT（S、G）は、それがS、RPF '（S、G）に向かってアップストリームの次のホップに（S、G）結合の送信をトリガするために使用されて保持されます。"
    },
    {
      "indent": 9,
      "text": "Figure 8: Upstream (S,G) state machine in tabular form",
      "ja": "図8：表形式の上流（S、G）ステートマシン"
    },
    {
      "indent": 0,
      "text": "+-------------------+--------------------------------------------------+\n|                   |                      Event                       |\n|  Prev State       +-------------------------+------------------------+\n|                   |   JoinDesired(S,G)      |   JoinDesired(S,G)     |\n|                   |   ->True                |   ->False              |\n+-------------------+-------------------------+------------------------+\n|  NotJoined (NJ)   |   -> J state            |   -                    |\n|                   |   Send Join(S,G);       |                        |\n|                   |   Set Join Timer to     |                        |\n|                   |   t_periodic            |                        |\n+-------------------+-------------------------+------------------------+\n|  Joined (J)       |   -                     |   -> NJ state          |\n|                   |                         |   Send Prune(S,G);     |\n|                   |                         |   Set SPTbit(S,G) to   |\n|                   |                         |   FALSE; Cancel Join   |\n|                   |                         |   Timer                |\n+-------------------+-------------------------+------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In addition, we have the following transitions, which occur within the Joined state:",
      "ja": "また、当社は、接合状態内で発生し、次の遷移を、持っています："
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                         In Joined (J) State                          |\n+-----------------+-----------------+-----------------+----------------+\n| Timer Expires   | See Join(S,G)   | See Prune(S,G)  | See Prune      |\n|                 | to RPF'(S,G)    | to RPF'(S,G)    | (S,G,rpt) to   |\n|                 |                 |                 | RPF'(S,G)      |\n+-----------------+-----------------+-----------------+----------------+\n| Send            | Increase Join   | Decrease Join   | Decrease Join  |\n| Join(S,G); Set  | Timer to        | Timer to        | Timer to       |\n| Join Timer to   | t_joinsuppress  | t_override      | t_override     |\n| t_periodic      |                 |                 |                |\n+-----------------+-----------------+-----------------+----------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                        In Joined (J) State                           |\n+-----------------+-----------------+----------------+-----------------+\n| See Prune(*,G)  | RPF'(S,G)       | RPF'(S,G)      | RPF'(S,G)       |\n| to RPF'(S,G)    | changes not     | GenID changes  | changes due to  |\n|                 | due to an       |                | an Assert       |\n|                 | Assert          |                |                 |\n+-----------------+-----------------+----------------+-----------------+\n| Decrease Join   | Send Join(S,G)  | Decrease Join  | Decrease Join   |\n| Timer to        | to new next     | Timer to       | Timer to        |\n| t_override      | hop; Send       | t_override     | t_override      |\n|                 | Prune(S,G) to   |                |                 |\n|                 | old next hop;   |                |                 |\n|                 | Set Join Timer  |                |                 |\n|                 | to t_periodic   |                |                 |\n+-----------------+-----------------+----------------+-----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This state machine uses the following macro:",
      "ja": "このステートマシンは、次のマクロを使用しています："
    },
    {
      "indent": 5,
      "text": "bool JoinDesired(S,G) { return( immediate_olist(S,G) != NULL OR ( KeepaliveTimer(S,G) is running AND inherited_olist(S,G) != NULL ) ) }",
      "ja": "BOOL JoinDesired（S、G）{リターン（immediate_olist（S、G）！= NULL OR（KeepaliveTimer（S、G）が実行され、引き継いでいる_olist（S、G）！= NULL））}"
    },
    {
      "indent": 3,
      "text": "JoinDesired(S,G) is true when the router has forwarding state that would cause it to forward traffic for G using source tree state. The source tree state can be as a result of either active source-specific join state, or the (S,G) Keepalive Timer and active non-source-specific state. Note that although JoinDesired is true, the router's sending of a Join(S,G) message may be suppressed by another router sending a Join(S,G) onto the upstream interface.",
      "ja": "ルータは、それがソースツリーの状態を使用してGのためのトラフィックを転送させるような状態を転送したときJoinDesired（S、G）が真です。ソースツリーの状態がいずれかのアクティブソース固有参加状態、または（S、G）キープアライブタイマー及びアクティブ非ソース固有の状態の結果であり得ます。 JoinDesiredが真であるが、ルータの送信参加（S、G）メッセージの上流インタフェースに参加する（S、G）を送信する別のルータによって抑制することができることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Transitions from NotJoined State",
      "ja": "NotJoined状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When the upstream (S,G) state machine is in NotJoined state, the following event may trigger a state transition:",
      "ja": "アップストリーム（S、G）ステートマシンはNotJoined状態にある場合、次のイベントは、状態遷移をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "JoinDesired(S,G) becomes True The macro JoinDesired(S,G) becomes True, e.g., because the downstream state for (S,G) has changed so that at least one interface is in inherited_olist(S,G).",
      "ja": "JoinDesired（S、G）は、少なくとも1つのインターフェースが引き継いでいる_olist（S、G）となるように（S、G）のためのダウンストリーム状態が変更されたため、マクロJoinDesired（S、G）は、例えば、真となる真となります。"
    },
    {
      "indent": 10,
      "text": "The upstream (S,G) state machine transitions to Joined state.\nSend Join(S,G) to the appropriate upstream neighbor, which is\nRPF'(S,G).  Set the Join Timer (JT) to expire after t_periodic\nseconds.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transitions from Joined State",
      "ja": "接合状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When the upstream (S,G) state machine is in Joined state, the following events may trigger state transitions:",
      "ja": "アップストリーム（S、G）ステートマシンは、接合状態にあるときに、次のイベントは、状態遷移をトリガすることができます。"
    },
    {
      "indent": 5,
      "text": "JoinDesired(S,G) becomes False The macro JoinDesired(S,G) becomes False, e.g., because the downstream state for (S,G) has changed so no interface is in inherited_olist(S,G).",
      "ja": "JoinDesired（S、G）が（S、G）のためのダウンストリーム状態がないインターフェースを引き継いでいる_olist（S、G）になっていないので、変更されたため、マクロJoinDesired（S、G）は、例えば、偽になる偽となります。"
    },
    {
      "indent": 10,
      "text": "The upstream (S,G) state machine transitions to NotJoined\nstate.  Send Prune(S,G) to the appropriate upstream neighbor,\nwhich is RPF'(S,G).  Cancel the Join Timer (JT), and set\nSPTbit(S,G) to FALSE.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Join Timer Expires The Join Timer (JT) expires, indicating time to send a Join(S,G)",
      "ja": "タイマが満了参加、時間を示すこと参加（S、G）を送信する満了タイマー（JT）に参加"
    },
    {
      "indent": 10,
      "text": "Send Join(S,G) to the appropriate upstream neighbor, which is\nRPF'(S,G).  Restart the Join Timer (JT) to expire after\nt_periodic seconds.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "See Join(S,G) to RPF'(S,G) This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Join(S,G) to RPF'(S,G). This causes this router to suppress its own Join.",
      "ja": "RPF_interface（S）が共有メディアである場合、このイベントにのみ関連している（S、G）「RPFに（S、G）に参加を参照してください。このルータはRPF_interface（S）上の別のルータを見RPF '（S、G）に参加（S、G）を送ります。これは、このルータが参加し、独自のを抑制する原因となります。"
    },
    {
      "indent": 10,
      "text": "The upstream (S,G) state machine remains in Joined state.",
      "ja": "アップストリーム（S、G）ステートマシンは、接合状態のままです。"
    },
    {
      "indent": 10,
      "text": "Let t_joinsuppress be the minimum of t_suppressed and the HoldTime from the Join/Prune message triggering this event.",
      "ja": "t_joinsuppressがt_suppressedの最小値と、このイベントをトリガ/プルーンに参加したメッセージからのHoldTimeとします。"
    },
    {
      "indent": 10,
      "text": "If the Join Timer is set to expire in less than t_joinsuppress seconds, reset it so that it expires after t_joinsuppress seconds. If the Join Timer is set to expire in more than t_joinsuppress seconds, leave it unchanged.",
      "ja": "参加タイマーがt_joinsuppress秒未満で期限が切れるように設定されている場合、それはt_joinsuppress秒後に期限切れになるように、それをリセットします。参加タイマーがt_joinsuppress秒以上で有効期限が切れるように設定されている場合、それは変わらないまま。"
    },
    {
      "indent": 5,
      "text": "See Prune(S,G) to RPF'(S,G) This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Prune(S,G) to RPF'(S,G). As this router is in Joined state, it must override the Prune after a short random interval.",
      "ja": "RPF_interface（S）が共有メディアであるかどうかを確認プルーンRPFに（S、G） '（S、G）このイベントはのみ有効です。このルータはRPF_interface（S）プルーンRPFに（S、G） '（S、G）を送信上の別のルータを見ています。このルータが参加状態にあるとして、それは短いランダムな間隔の後にプルーンをオーバーライドする必要があります。"
    },
    {
      "indent": 10,
      "text": "The upstream (S,G) state machine remains in Joined state.  If\nthe Join Timer is set to expire in more than t_override\nseconds, reset it so that it expires after t_override seconds.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "See Prune(S,G,rpt) to RPF'(S,G) This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Prune(S,G,rpt) to RPF'(S,G). If the upstream router is an RFC-2362-compliant PIM router, then the Prune(S,G,rpt) will cause it to stop forwarding. For backwards compatibility, this router should override the prune so that forwarding continues.",
      "ja": "RPF_interface（S）が共有メディアである場合、このイベントはのみ関連しRPFへのプルーン（S、G、RPT） '（S、G）を参照してください。このルータはRPFにRPF_interface上の別のルータ（S）プルーン（S、G、RPT）を送る '（S、G）を見ています。上流のルータがRFC-2362準拠のPIMルータである場合には、プルーン（S、G、RPT）は、転送を停止します。転送が続行されるように、後方互換性のために、このルータはプルーンをオーバーライドする必要があります。"
    },
    {
      "indent": 10,
      "text": "The upstream (S,G) state machine remains in Joined state.  If\nthe Join Timer is set to expire in more than t_override\nseconds, reset it so that it expires after t_override seconds.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "See Prune(*,G) to RPF'(S,G) This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Prune(*,G) to RPF'(S,G). If the upstream router is an RFC-2362-compliant PIM router, then the Prune(*,G) will cause it to stop forwarding. For backwards compatibility, this router should override the prune so that forwarding continues.",
      "ja": "RPF_interface（S）が共有メディアであるかどうかを確認プルーンRPFに（*、G） '（S、G）このイベントはのみ有効です。このルータはRPF_interface（S）プルーンRPFに（*、G） '（S、G）を送信上の別のルータを見ています。上流のルータがRFC-2362準拠のPIMルータである場合には、プルーン（*、G）は、転送を停止します。転送が続行されるように、後方互換性のために、このルータはプルーンをオーバーライドする必要があります。"
    },
    {
      "indent": 10,
      "text": "The upstream (S,G) state machine remains in Joined state.  If\nthe Join Timer is set to expire in more than t_override\nseconds, reset it so that it expires after t_override seconds.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RPF'(S,G) changes due to an Assert The current next hop towards S changes due to an Assert(S,G) on the RPF_interface(S).",
      "ja": "RPF '（S、G）が原因アサートするRPF_interface（S）にアサート（S、G）によるSの変化に向かって現在の次のホップを変更します。"
    },
    {
      "indent": 10,
      "text": "The upstream (S,G) state machine remains in Joined state.  If\nthe Join Timer is set to expire in more than t_override\nseconds, reset it so that it expires after t_override seconds.\nIf the Join Timer is set to expire in less than t_override\nseconds, leave it unchanged.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RPF'(S,G) changes not due to an Assert An event occurred that caused the next hop towards S to change. Note that this transition does not occur if an Assert is active and the upstream interface does not change.",
      "ja": "RPF '（S、G）は、イベントをアサートするためではない変更Sに向かうネクストホップを変化させ、その発生しました。アサートがアクティブであり、アップストリームインターフェイスが変更されない場合は、この遷移が発生しないことに留意されたいです。"
    },
    {
      "indent": 10,
      "text": "The upstream (S,G) state machine remains in Joined state.\nSend Join(S,G) to the new upstream neighbor, which is the new\nvalue of RPF'(S,G).  Send Prune(S,G) to the old upstream\nneighbor, which is the old value of RPF'(S,G).  Set the Join\nTimer (JT) to expire after t_periodic seconds.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RPF'(S,G) GenID changes The Generation ID of the router that is RPF'(S,G) changes. This normally means that this neighbor has lost state, and so the state must be refreshed.",
      "ja": "RPF（S、G）が変化する '（S、G）られたGenIDはRPFあるルータの世代IDを変更します'。これは通常、この隣人が状態を失ったことを意味し、その状態をリフレッシュする必要があります。"
    },
    {
      "indent": 10,
      "text": "The upstream (S,G) state machine remains in Joined state.  If\nthe Join Timer is set to expire in more than t_override\nseconds, reset it so that it expires after t_override seconds.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5.8. (S,G,rpt) Periodic Messages",
      "section_title": true,
      "ja": "4.5.8。 （S、G、RPT）定期的なメッセージ"
    },
    {
      "indent": 3,
      "text": "(S,G,rpt) Joins and Prunes are (S,G) Joins or Prunes sent on the RP tree with the RPT bit set, either to modify the results of (*,G) Joins, or to override the behavior of other upstream LAN peers. The next section describes the rules for sending triggered messages. This section describes the rules for including a Prune(S,G,rpt) message with a Join(*,G).",
      "ja": "（S、G、RPT）は、ジョインとプルーンは（S、G）結合やRPTビットが設定されたRPツリー上で送信されたプルーン、されているか（*、G）の結果を修正する結合、または他の動作を無効にしますLANピアの上流。次のセクションでは、トリガメッセージを送信するためのルールを説明しています。このセクションでは、参加（*、G）とプルーン（S、G、RPT）メッセージを含めるためのルールが記載されています。"
    },
    {
      "indent": 3,
      "text": "When a router is going to send a Join(*,G), it should use the following pseudocode, for each (S,G) for which it has state, to decide whether to include a Prune(S,G,rpt) in the compound Join/Prune message:",
      "ja": "ルータが（*、G）に参加送信しようとしたとき、それはプルーン（S、G、RPT）内を含めるかどうかを決定するために、それは状態を持っているそれぞれの（S、G）のために、以下の擬似コードを使用する必要があります化合物は、join / pruneメッセージを："
    },
    {
      "indent": 5,
      "text": "if( SPTbit(S,G) == TRUE ) { # Note: If receiving (S,G) on the SPT, we only prune off the # shared tree if the RPF neighbors differ. if( RPF'(*,G) != RPF'(S,G) ) { add Prune(S,G,rpt) to compound message } } else if ( inherited_olist(S,G,rpt) == NULL ) { # Note: all (*,G) olist interfaces received RPT prunes for (S,G). add Prune(S,G,rpt) to compound message } else if ( RPF'(*,G) != RPF'(S,G,rpt) { # Note: we joined the shared tree, but there was an (S,G) assert # and the source tree RPF neighbor is different. add Prune(S,G,rpt) to compound message }",
      "ja": "（SPTbit（S、G）== TRUE）{＃注場合：SPTに（S、G）を受信した場合RPF隣人が異なる場合、我々は、共有ツリー位オフ剪定します。 IF（RPF '（*、G）！= RPF'（S、G））{メッセージを配合するプルーン（S、G、RPT）を追加}}そうでなければ{（引き継いでいる_olist（S、G、RPT）== NULL）場合＃注：すべての（*、G）OLISTインターフェイスは（S、G）のためにRPTのプルーンを受けました。 （RPF場合、他}メッセージを配合することプルーン（S、G、RPT）を追加（S、G、RPT）{＃（注） '（*、G）= RPF！'：私たちは共有ツリーに参加しましたが、（Sがありました、G）は＃をアサートし、ソースツリーRPFネイバーは異なる。メッセージを配合するプルーン（S、G、RPT）を追加します}"
    },
    {
      "indent": 3,
      "text": "Note that Join(S,G,rpt) is normally sent not as a periodic message, but only as a triggered message.",
      "ja": "（S、G、RPT）参加注が正常ではない定期的なメッセージとして、だけトリガメッセージとして送信されます。"
    },
    {
      "indent": 0,
      "text": "4.5.9. State Machine for (S,G,rpt) Triggered Messages",
      "section_title": true,
      "ja": "4.5.9。 （S、G、RPT）のためのステートマシンは、メッセージをトリガ"
    },
    {
      "indent": 3,
      "text": "The state machine for (S,G,rpt) triggered messages is required per-(S,G) when there is (*,G) or (*,*,RP) join state at a router, and the router or any of its upstream LAN peers wishes to prune S off the RP tree.",
      "ja": "（S、G、RPT）のためのステートマシンは（S、G）がある（*、G）または（*、*、RP）ルータの状態に加入パー必要とされるメッセージをトリガーし、およびルータまたは任意のその上流LANピアは、RPツリーオフSを剪定したいです。"
    },
    {
      "indent": 3,
      "text": "There are three states in the state machine. One of the states is when there is neither (*,G) nor (*,*,RP(G)) join state at this router. If there is (*,G) or (*,*,RP(G)) join state at the router, then the state machine must be at one of the other two states. The three states are:",
      "ja": "ステート・マシン内の3つの状態があります。どちらも（*、G）や（*、*、RP（G））このルータの状態に加入があるときの状態の一つがあります。 （*、G）または（*、*、RP（G））は、ルータの状態に加入がある場合、ステートマシンは、他の2つの状態のいずれかでなければなりません。三つの状態は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Pruned(S,G,rpt) (*,G) or (*,*,RP(G)) Joined, but (S,G,rpt) pruned",
      "ja": "（S、G、RPT）（*、G）または（*、*、RP（G））プルーニングメンバーが、（S、G、RPT）プルーニング"
    },
    {
      "indent": 3,
      "text": "NotPruned(S,G,rpt) (*,G) or (*,*,RP(G)) Joined, and (S,G,rpt) not pruned",
      "ja": "（S、G、RPT）（*、G）または（*、*、RP（G））参加NotPruned、及び（S、G、RPT）プルーニングされていません"
    },
    {
      "indent": 3,
      "text": "RPTNotJoined(G) neither (*,G) nor (*,*,RP(G)) has been joined.",
      "ja": "RPTNotJoined（G）もない（*、G）や（*、*、RP（G））が参加されました。"
    },
    {
      "indent": 3,
      "text": "In addition, there is an (S,G,rpt) Override Timer, OT(S,G,rpt), which is used to delay triggered Join(S,G,rpt) messages to prevent implosions of triggered messages.",
      "ja": "また、（S、G、RPT）タイマーは、遅延させるために使用されているOT（S、G、RPT）は、トリガメッセージの内破を防止する（S、G、RPT）Joinメッセージをトリガオーバーライドがあります。"
    },
    {
      "indent": 3,
      "text": "Figure 9: Upstream (S,G,rpt) state machine for triggered messages in tabular form",
      "ja": "図9：アップストリーム（S、G、RPT）表形式でトリガメッセージのためのステートマシン"
    },
    {
      "indent": 0,
      "text": "+------------++--------------------------------------------------------+\n|            ||                           Event                        |\n|            ++--------------+--------------+-------------+------------+\n|Prev State  || PruneDesired | PruneDesired | RPTJoin     | inherited_ |\n|            || (S,G,rpt)    | (S,G,rpt)    | Desired(G)  | olist      |\n|            || ->True       | ->False      | ->False     | (S,G,rpt)  |\n|            ||              |              |             | ->non-NULL |\n+------------++--------------+--------------+-------------+------------+\n|RPTNotJoined|| -> P state   | -            | -           | -> NP state|\n|(G) (NJ)    ||              |              |             |            |\n+------------++--------------+--------------+-------------+------------+\n|Pruned      || -            | -> NP state  | -> NJ state | -          |\n|(S,G,rpt)   ||              | Send Join    |             |            |\n|(P)         ||              | (S,G,rpt)    |             |            |\n+------------++--------------+--------------+-------------+------------+\n|NotPruned   || -> P state   | -            | -> NJ state | -          |\n|(S,G,rpt)   || Send Prune   |              | Cancel OT   |            |\n|(NP)        || (S,G,rpt);   |              |             |            |\n|            || Cancel OT    |              |             |            |\n+------------++--------------+--------------+-------------+------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Additionally, we have the following transitions within the NotPruned(S,G,rpt) state, which are all used for prune override behavior.",
      "ja": "さらに、我々はすべてのプルーンのオーバーライド動作のために使用されているNotPruned（S、G、RPT）状態の中、次の遷移を、持っています。"
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                    In NotPruned(S,G,rpt) State                       |\n+----------+--------------+--------------+--------------+--------------+\n|Override  | See Prune    | See Join     | See Prune    | RPF'         |\n|Timer     | (S,G,rpt) to | (S,G,rpt) to | (S,G) to     | (S,G,rpt) -> |\n|expires   | RPF'         | RPF'         | RPF'         | RPF' (*,G)   |\n|          | (S,G,rpt)    | (S,G,rpt)    | (S,G,rpt)    |              |\n+----------+--------------+--------------+--------------+--------------+\n|Send Join | OT = min(OT, | Cancel OT    | OT = min(OT, | OT = min(OT, |\n|(S,G,rpt);| t_override)  |              | t_override)  | t_override)  |\n|Leave OT  |              |              |              |              |\n|unset     |              |              |              |              |\n+----------+--------------+--------------+--------------+--------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that the min function in the above state machine considers a non-running timer to have an infinite value (e.g., min(not-running, t_override) = t_override).",
      "ja": "上記状態マシンでMIN関数は無限大の値（例えば、分（未実行、t_override）= t_override）を有するように、非ランニング・タイマを考慮することに注意してください。"
    },
    {
      "indent": 3,
      "text": "This state machine uses the following macros:",
      "ja": "このステートマシンは、次のマクロを使用しています："
    },
    {
      "indent": 5,
      "text": "bool RPTJoinDesired(G) { return (JoinDesired(*,G) OR JoinDesired(*,*,RP(G))) }",
      "ja": "BOOL RPTJoinDesired（G）{リターン（JoinDesired（*、G）OR JoinDesired（*、*、RP（G）））}"
    },
    {
      "indent": 3,
      "text": "RPTJoinDesired(G) is true when the router has forwarding state that would cause it to forward traffic for G using either (*,G) or (*,*,RP) shared tree state.",
      "ja": "ルータは、それはどちらか（*、G）または（*、*、RP）共有ツリーの状態を使用してGのためのトラフィックを転送させるような状態を転送したときRPTJoinDesired（G）が真です。"
    },
    {
      "indent": 5,
      "text": "bool PruneDesired(S,G,rpt) { return ( RPTJoinDesired(G) AND ( inherited_olist(S,G,rpt) == NULL OR (SPTbit(S,G)==TRUE AND (RPF'(*,G) != RPF'(S,G)) ))) }",
      "ja": "BOOL PruneDesired（S、G、RPT）{リターン（RPTJoinDesired（G）AND（引き継いでいる_olist（S、G、RPT）== NULL OR（SPTbit（S、G）== TRUE AND（RPF '（*、G）！ = RPF '（S、G）））））}"
    },
    {
      "indent": 3,
      "text": "PruneDesired(S,G,rpt) can only be true if RPTJoinDesired(G) is true. If RPTJoinDesired(G) is true, then PruneDesired(S,G,rpt) is true either if there are no outgoing interfaces that S would be forwarded on, or if the router has active (S,G) forwarding state but RPF'(*,G) != RPF'(S,G).",
      "ja": "RPTJoinDesired（G）が真である場合PruneDesired（S、G、RPT）は、唯一の真であることができます。 RPTJoinDesired（G）が真である場合、ルータはアクティブ（S、G）転送状態が、RPFを有する場合、Sは上で転送、またはされるであろう全く発信インターフェイスが存在しない場合、その後PruneDesiredは（S、G、RPT）」のいずれかで真です（ *、G）！= RPF '（S、G）。"
    },
    {
      "indent": 3,
      "text": "The state machine contains the following transition events:",
      "ja": "ステートマシンは、次の遷移イベントが含まれています。"
    },
    {
      "indent": 3,
      "text": "See Join(S,G,rpt) to RPF'(S,G,rpt) This event is only relevant in the \"Not Pruned\" state.",
      "ja": "このイベントは \"剪定ない\" 状態でのみ関連し（S、G、RPT）「RPFに（S、G、RPT）に参加を参照してください。"
    },
    {
      "indent": 6,
      "text": "The router sees a Join(S,G,rpt) from someone else to RPF'(S,G,rpt), which is the correct upstream neighbor. If we're in \"NotPruned\" state and the (S,G,rpt) Override Timer is running, then this is because we have been triggered to send our own Join(S,G,rpt) to RPF'(S,G,rpt). Someone else beat us to it, so there's no need to send our own Join.",
      "ja": "ルータが正しい上流の隣人であるRPF '（S、G、RPT）、に他の誰かから（S、G、RPT）を参加見ています。私たちは、タイマーが実行されているオーバーライド「NotPruned」状態と（S、G、RPT）にいるならば、我々はRPF '（S、Gに私たち自身の参加（S、G、RPT）を送信するためにトリガされているので、これはあります、RPT）。他の誰かがそれに私たちを打つので、参加私たち自身を送信する必要はありません。"
    },
    {
      "indent": 6,
      "text": "The action is to cancel the Override Timer.",
      "ja": "アクションはオーバーライドタイマーをキャンセルすることです。"
    },
    {
      "indent": 3,
      "text": "See Prune(S,G,rpt) to RPF'(S,G,rpt) This event is only relevant in the \"NotPruned\" state.",
      "ja": "このイベントは、 \"NotPruned\" 状態でのみ関連しRPFへのプルーン（S、G、RPT） '（S、G、RPT）を参照してください。"
    },
    {
      "indent": 6,
      "text": "The router sees a Prune(S,G,rpt) from someone else to RPF'(S,G,rpt), which is the correct upstream neighbor. If we're in the \"NotPruned\" state, then we want to continue to receive traffic from S destined for G, and that traffic is being supplied by RPF'(S,G,rpt). Thus, we need to override the Prune.",
      "ja": "ルータが正しい上流の隣人であるRPF '（S、G、RPT）、に他の誰かからプルーン（S、G、RPT）を見ています。私たちは「NotPruned」の状態であれば、我々はG宛てSからトラフィックを受信し、トラフィックがRPF '（S、G、RPT）によって供給されていることをしていきたいと思います。したがって、我々はプルーンをオーバーライドする必要があります。"
    },
    {
      "indent": 6,
      "text": "The action is to set the (S,G,rpt) Override Timer to the randomized prune-override interval, t_override. However, if the Override Timer is already running, we only set the timer if doing so would set it to a lower value. At the end of this interval, if noone else has sent a Join, then we will do so.",
      "ja": "アクションは、無作為プルーン・オーバーライド間隔にt_overrideを（S、G、RPT）オーバーライドタイマーを設定することです。オーバーライドタイマーがすでに実行されている場合はそうすることが、より低い値に設定するならばしかし、我々は唯一のタイマーを設定します。誰もが他の参加送信した場合には、この期間の終わりに、我々はそうするでしょう。"
    },
    {
      "indent": 3,
      "text": "See Prune(S,G) to RPF'(S,G,rpt) This event is only relevant in the \"NotPruned\" state.",
      "ja": "参照プルーンRPFに（S、G） '（S、G、RPT）このイベントは、 \"NotPruned\" 状態でのみ有効です。"
    },
    {
      "indent": 6,
      "text": "This transition and action are the same as the above transition and action, except that the Prune does not have the RPT bit set. This transition is necessary to be compatible with routers implemented from RFC2362 that don't maintain separate (S,G) and (S,G,rpt) state.",
      "ja": "この遷移とアクションは、プルーンがRPTビットが設定されていないことを除いて、上記遷移および動作と同じです。この遷移は、別個の（S、G）および（S、G、RPT）状態を維持していないRFC2362から実施ルータと互換性があることが必要です。"
    },
    {
      "indent": 3,
      "text": "The (S,G,rpt) prune Override Timer expires This event is only relevant in the \"NotPruned\" state.",
      "ja": "（S、G、RPT）プルーンオーバーライドタイマこのイベントは、「NotPruned」状態でのみ関連し満了します。"
    },
    {
      "indent": 6,
      "text": "When the Override Timer expires, we must send a Join(S,G,rpt) to RPF'(S,G,rpt) to override the Prune message that caused the timer to be running. We only send this if RPF'(S,G,rpt) equals RPF'(*,G); if this were not the case, then the Join might be sent to a router that does not have (*,G) or (*,*,RP(G)) Join state, and so the behavior would not be well defined. If RPF'(S,G,rpt) is not the same as RPF'(*,G), then it may stop forwarding S. However, if this happens, then the router will send an AssertCancel(S,G), which would then cause RPF'(S,G,rpt) to become equal to RPF'(*,G) (see below).",
      "ja": "オーバーライドタイマーの期限が切れると、私たちは、タイマーが実行されている原因とプルーンのメッセージをオーバーライドするためにRPF '（S、G、RPT）に参加（S、G、RPT）を送信する必要があります。 RPF（*、G） '（S、G、RPT）はRPF等しい' 場合我々はこれだけを送信します。これが当てはまらなかった場合、その後、持っていないルータ（*、G）または（*、*、RP（G））参加状態、及びその行動が明確に定義されていないでしょうに送信される可能性があります参加します。 RPF（*、G） '（S、G、RPT）はRPFと同じではない' 場合、それはこの問題が発生した場合、ルータはAssertCancel（S、G）を、送信されます、しかしS.の転送を停止することができますその後、RPF（下記参照）（*、G） '（S、G、RPT）はRPFに等しくなるように' 原因となります。"
    },
    {
      "indent": 3,
      "text": "RPF'(S,G,rpt) changes to become equal to RPF'(*,G) This event is only relevant in the \"NotPruned\" state.",
      "ja": "RPF '（S、G、RPT）変更RPFと等しくなるように'（*、G）このイベントは、 \"NotPruned\" 状態でのみ有効です。"
    },
    {
      "indent": 6,
      "text": "RPF'(S,G,rpt) can only be different from RPF'(*,G) if an (S,G) Assert has happened, which means that traffic from S is arriving on the SPT, and so Prune(S,G,rpt) will have been sent to RPF'(*,G). When RPF'(S,G,rpt) changes to become equal to RPF'(*,G), we need to trigger a Join(S,G,rpt) to RPF'(*,G) to cause that router to start forwarding S again.",
      "ja": "RPF、S（SからのトラフィックがプルーンをSPTに到着し、そうしていることを意味します（S、G）アサートが発生した場合には（*、G）、 '（S、G、RPT）が唯一のRPFと異なる場合があります' G、RPT）はRPF '（*、G）に送られてきたでしょう。 RPF '（S、G、RPT）の変化RPFと等しくなるための'（*、G）が、我々はそのルータを開始させるためにRPF '（*、G）に（S、G、RPT）を参加トリガーする必要がある場合再びSを転送します。"
    },
    {
      "indent": 6,
      "text": "The action is to set the (S,G,rpt) Override Timer to the randomized prune-override interval t_override. However, if the timer is already running, we only set the timer if doing so would set it to a lower value. At the end of this interval, if noone else has sent a Join, then we will do so.",
      "ja": "アクションは、（S、G、RPT）無作為プルーンオーバーライド間隔t_overrideするタイマーを上書きを設定することです。タイマーがすでに実行されている場合は、我々はそうすることが、より低い値に設定するならば、タイマーを設定します。誰もが他の参加送信した場合には、この期間の終わりに、我々はそうするでしょう。"
    },
    {
      "indent": 3,
      "text": "PruneDesired(S,G,rpt)->TRUE See macro above. This event is relevant in the \"NotPruned\" and \"RPTNotJoined(G)\" states.",
      "ja": "PruneDesired（S、G、RPT） - > TRUE上記のマクロを参照してください。このイベントは、「NotPruned」と「RPTNotJoined（G）」の状態に関連しています。"
    },
    {
      "indent": 6,
      "text": "The router wishes to receive traffic for G, but does not wish to receive traffic from S destined for G. This causes the router to transition into the Pruned state.",
      "ja": "ルータは、Gのトラフィックを受信したいが、Sからのトラフィックを受信したくない。これは、剪定された状態に移行するようにルータを引き起こしG.宛て。"
    },
    {
      "indent": 6,
      "text": "If the router was previously in NotPruned state, then the action is to send a Prune(S,G,rpt) to RPF'(S,G,rpt), and to cancel the Override Timer. If the router was previously in RPTNotJoined(G) state, then there is no need to trigger an action in this state machine because sending a Prune(S,G,rpt) is handled by the rules for sending the Join(*,G) or Join(*,*,RP).",
      "ja": "ルータはNotPruned状態で以前にあった場合、アクションは、RPFにプルーン（S、G、RPT） '（S、G、RPT）を送信すること、及び上書きタイマをキャンセルすることです。ルータがRPTNotJoined（G）の状態であったならば、その後プルーン送信するため、このステート・マシンでアクションをトリガーする必要はありません、（S、Gは、RP​​T）は（G、*）に参加を送信するためのルールによって処理されますまたは（*、*、RP）に参加。"
    },
    {
      "indent": 3,
      "text": "PruneDesired(S,G,rpt)->FALSE See macro above. This transition is only relevant in the \"Pruned\" state.",
      "ja": "PruneDesired（S、G、RPT） - >上記FALSE参照マクロ。この移行は、「剪定」状態でのみ有効です。"
    },
    {
      "indent": 6,
      "text": "If the router is in the Pruned(S,G,rpt) state, and PruneDesired(S,G,rpt) changes to FALSE, this could be because the router no longer has RPTJoinDesired(G) true, or it now wishes to receive traffic from S again. If it is the former, then this transition should not happen, but instead the \"RPTJoinDesired(G)->FALSE\" transition should happen. Thus, this transition should be interpreted as \"PruneDesired(S,G,rpt)->FALSE AND RPTJoinDesired(G)==TRUE\".",
      "ja": "ルータが剪定（S、G、RPT）の状態、およびPruneDesired（S、G、RPT）FALSEに変更している場合は、このルータは、もはや（G）真RPTJoinDesiredていない可能性があるため、またはそれが今で受信したいです再びSからのトラフィック。それはかつてのであれば、この移行は起こるべきではありませんが、その代わりに「RPTJoinDesired（G） - > FALSE」の移行が起こるはず。従って、この遷移は、 \" - > FALSE AND RPTJoinDesired（G）== TRUE PruneDesired（S、G、RPT）\" と解釈されるべきです。"
    },
    {
      "indent": 6,
      "text": "The action is to send a Join(S,G,rpt) to RPF'(S,G,rpt).",
      "ja": "アクションは '（S、G、RPT）RPFに参加（S、G、RPT）を送信することです。"
    },
    {
      "indent": 3,
      "text": "RPTJoinDesired(G)->FALSE This event is relevant in the \"Pruned\" and \"NotPruned\" states.",
      "ja": "RPTJoinDesired（G）は - > FALSEこのイベントは、「剪定」と「NotPruned」の状態で関連しています。"
    },
    {
      "indent": 6,
      "text": "The router no longer wishes to receive any traffic destined for G on the RP Tree. This causes a transition to the RPTNotJoined(G) state, and the Override Timer is canceled if it was running. Any further actions are handled by the appropriate upstream state machine for (*,G) or (*,*,RP).",
      "ja": "ルータは、もはやRP木の上にG宛てのトラフィックを受信することを希望しません。これはRPTNotJoined（G）状態への遷移を引き起こし、それが実行中であった場合は上書きタイマーはキャンセルされます。さらなるアクションは（*、G）または（*、*、RP）のために適切な上流の状態機械によって処理されます。"
    },
    {
      "indent": 3,
      "text": "inherited_olist(S,G,rpt) becomes non-NULL This transition is only relevant in the RPTNotJoined(G) state.",
      "ja": "引き継いでいる_olist（S、G、RPT）は、非NULLこの遷移はRPTNotJoined（G）状態にのみ関連してなります。"
    },
    {
      "indent": 6,
      "text": "The router has joined the RP tree (handled by the (*,G) or (*,*,RP) upstream state machine as appropriate) and wants to receive traffic from S. This does not trigger any events in this state machine, but causes a transition to the NotPruned(S,G,rpt) state.",
      "ja": "ルータは、（必要に応じて（*、G）または（*、*、RP）上流の状態機械によって処理される）RPツリーに参加し、これは、この状態マシンでイベントをトリガしないS.からのトラフィックを受信したいが、ましたNotPruned（S、G、RPT）状態に遷移します。"
    },
    {
      "indent": 0,
      "text": "4.5.10. Background: (*,*,RP) and (S,G,rpt) Interaction",
      "section_title": true,
      "ja": "4.5.10。背景：（*、*、RP）および（S、G、RPT）の相互作用"
    },
    {
      "indent": 3,
      "text": "In Sections 4.5.8 and 4.5.9, the mechanisms for sending periodic and triggered (S,G,rpt) messages are described. The astute reader will note that periodic Prune(S,G,rpt) messages are only sent in PIM Join/Prune messages containing a Join(*,G), whereas it is possible for a triggered Prune(S,G,rpt) message to be sent when the router has no (*,G) join state. This may seem like a contradiction, but in fact it is intentional and is a side effect of not optimizing (*,*,RP) behavior.",
      "ja": "セクション4.5.8と4.5.9において、周期的にトリガを送信するためのメカニズム（S、Gは、RP​​T）メッセージが記載されています。抜け目のない読者は、それがトリガプルーン（S、G、RPT）メッセージのことが可能である一方、周期プルーン（S、G、RPT）メッセージのみ、（G、*）参加を含むPIM参加/プルーンメッセージで送信されることに留意されたいですルータは何も（*、G）加入状態を持っていないときに送信されます。これは矛盾のように見えるかもしれませんが、実際には、それは意図的なもので、（*、*、RP）の動作を最適化していないの副作用です。"
    },
    {
      "indent": 3,
      "text": "We first note that reception of a Join(*,*,RP) by itself does not cancel (S,G,rpt) prune state on that interface, whereas receiving a Join(*,G) by itself does cancel (S,G,rpt) prune state on that interface. Similarly, reception of a Prune(*,G) on an interface with (*,*,RP) join state does not by itself prevent forwarding of G using the (*,*,RP) state; this is because a Prune(*,G) only serves to cancel (*,G) join state. Conceptually (*,*,RP) state functions \"above\" the normal (*,G) and (S,G) mechanisms, and so neither Join(*,*,RP) nor Prune(*,*,RP) messages affect any other state.",
      "ja": "我々は最初の受信を注意（S、Gをキャンセルない自身が参加（*、G）を受信し、一方、そのインターフェイス上で状態をプルーニング（S、G、RPT）をキャンセルしない単独で（*、*、RP）参加、RPT）そのインターフェイス上で状態を剪定。同様に、（*、*、RP）とのインタフェース上のプルーン（*、G）の受信状態は、それ自体で（*、*、RP）状態を使用してGの転送を妨げない参加。プルーン（*、G）がのみ（*、G）ステートを結合キャンセルするように働くためです。概念的に（*、*、RP）状態関数ノーマル（*、G） \"上\" と（S、G）のメカニズム、そしてそのどちらも参加（*、*、RP）やプルーン（*、*、RP）メッセージは影響しません他の状態。"
    },
    {
      "indent": 3,
      "text": "The upshot of this is that to prevent forwarding (S,G) on (*,*,RP) state, a Prune(S,G,rpt) must be used.",
      "ja": "この結論は、その転送を防止する（S、G）に（*、*、RP）状態、プルーン（S、G、RPT）を使用しなければならないです。"
    },
    {
      "indent": 3,
      "text": "We also note that for historical reasons there is no Assert(*,*,RP) message, so any forwarding contention is resolved using Assert(*,G) messages.",
      "ja": "我々はまた、歴史的な理由のためにそこにはアサート（*、*、RP）メッセージではありませんので、任意の転送の競合が（*、G）メッセージのAssertを使用して解決されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "We now need to consider the interaction between (*,*,RP) state and (*,G) state. If there is a need for an assert between two upstream routers on a LAN, we need to ensure that the correct thing happens for all combinations of (*,*,RP) and (*,G) forwarding state. As there is no Assert(*,*,RP) message, no router can tell whether the assert winner has (*,*,RP) state or (*,G) state. Thus, a downstream router has to treat the two the same and send its periodic Prune(S,G,rpt) messages to RPF'(*,G).",
      "ja": "私たちは今、（*、*、RP）状態と（*、G）状態の間の相互作用を考慮する必要があります。 LAN上の2つのアップストリームルータ間アサートする必要がある場合は、我々は正しいものは（*、*、RP）および（*、G）転送状態のすべての組み合わせのために起こっていることを確認する必要があります。何のアサート（*、*、RP）メッセージがないので、何のルータがアサート勝者は（*、*、RP）状態または（*、G）状態を持っているかどうかを伝えることはできません。このように、下流のルータは、同じ2つを治療し、その定期的なプルーン（S、G、RPT）RPFへのメッセージ '（*、G）を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "To avoid needing to specify all the complex override rules between (*,*,RP), (*,G), and (S,G,rpt), we simply require that to prune (S,G) off the (*,*,RP) tree, a Join(*,G) must also be sent.",
      "ja": "（*、G）、（*、*、RP）の間のすべての複雑な優先ルールを指定する必要があり、（S、G、RPT）を回避するために、我々は単に*（オフ（S、G）を剪定することが必要で、 *、RP）木、G、*（参加）も送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a router is receiving on (*,*,RP) state and has not yet had (*,G) state instantiated, it may still need to send a triggered Join(S,G,rpt) to override a Prune(S,G,rpt) that it sees directed to RPF'(*,G) on its upstream interface. Hence, triggered (S,G,rpt) messages may be sent when JoinDesired(*,G) is false but JoinDesired(*,*,RP) is true.",
      "ja": "ルータが（*、G）状態がインスタンス化（*、*、RP）状態で受信され、まだ持っていない場合、それはまだ（プルーンを上書きするためにSをトリガ参加（S、G、RPT）を送信する必要があるかもしれません、それは、そのアップストリームインタフェースにRPF '（*、G）に向け見ることG、RPT）。したがって、JoinDesired（*、G）が偽であるがJoinDesired（*、*、RP）が真であるときにメッセージを送信することができる（S、G、RPT）を誘発しました。"
    },
    {
      "indent": 3,
      "text": "Finally, we note that there is an unoptimized case when the upstream router on a LAN already has (*,G) join and (S,G,rpt) prune state caused by an existing downstream router. If at this time a new Join(*,*,RP) is sent to the upstream router from a different downstream router, this will not override the (S,G,rpt) prune state at the upstream router. The override will not occur until the next time the original downstream router resends its Prune(S,G,rpt). This case was not considered worth optimizing, as (*,*,RP) state is generally very long lived, and so any minor delays in getting traffic to a new PMBR seem unimportant.",
      "ja": "最後に、我々はLAN上の上流のルータがすでに持っているとき、最適化されていない場合があることに注意してください（*、G）に参加し、（S、G、RPT）既存の下流のルータによって引き起こされる状態を剪定。この時点では新しいが異なる下流ルータから上流のルータに送信される（*、*、RP）に参加した場合、これは（S、G、RPT）上流のルータの状態を剪定を上書きしません。オーバーライドは、元の下流ルータがプルーン（S、G、RPT）を再送信する次の時間まで起こらないであろう。この場合は、（*、*、RP）状態は一般的に非常に長く住んで、そしてので、新しいPMBRへのトラフィックを得ることにのわずかな遅れが重要でないように見えるよう、最適化する価値は考慮されませんでした。"
    },
    {
      "indent": 0,
      "text": "4.6. PIM Assert Messages",
      "section_title": true,
      "ja": "4.6。 PIMアサートメッセージ"
    },
    {
      "indent": 3,
      "text": "Where multiple PIM routers peer over a shared LAN, it is possible for more than one upstream router to have valid forwarding state for a packet, which can lead to packet duplication (see Section 3.6). PIM does not attempt to prevent this from occurring. Instead, it detects when this has happened and elects a single forwarder amongst the upstream routers to prevent further duplication. This election is performed using PIM Assert messages. Assert messages are also received by downstream routers on the LAN, and these cause subsequent Join/Prune messages to be sent to the upstream router that won the Assert.",
      "ja": "複数のPIMルータが共有LANを介してピアどこつ以上の上流のルータは、パケット重複（セクション3.6を参照）につながることができ、パケットのための有効な転送状態を持ってすることが可能です。 PIMは、これを防ぐためにしようとしません。これが起こったし、さらに重複を防ぐために、上流のルータ間で単一フォワーダを選出した場合に代わりに、それを検出します。この選挙は、PIMアサートメッセージを使用して行われます。アサートメッセージもLAN上の下流のルータによって受信され、これらはプルーン/参加後続のメッセージがアサートを獲得した上流のルータに送信することが原因。"
    },
    {
      "indent": 3,
      "text": "In general, a PIM Assert message should only be accepted for processing if it comes from a known PIM neighbor. A PIM router hears about PIM neighbors through PIM Hello messages. If a router receives an Assert message from a particular IP source address and it has not seen a PIM Hello message from that source address, then the Assert message SHOULD be discarded without further processing. In addition, if the Hello message from a neighbor was authenticated using the IPsec Authentication Header (AH) (see Section 6.3), then all Assert messages from that neighbor MUST also be authenticated using IPsec AH.",
      "ja": "それが知られているPIMネイバーから来る場合一般的には、PIMアサートメッセージは処理のために受理されなければなりません。 PIMルータはPIM Helloメッセージを通じてPIMネイバーについて聞きます。ルータは、特定のIP送信元アドレスからのAssertメッセージを受信し、その送信元アドレスからPIM Helloメッセージを見ていない場合、アサートメッセージはさらに処理することなく廃棄されるべきです。隣人からのHelloメッセージは、IPSec認証ヘッダ（AH）を使用して認証された場合に加えて、その隣人からのすべてのAssertメッセージものIPsec AHを使用して認証されなければならない、（セクション6.3を参照）。"
    },
    {
      "indent": 3,
      "text": "We note that some older PIM implementations incorrectly fail to send Hello messages on point-to-point interfaces, so we also RECOMMEND that a configuration option be provided to allow interoperation with such older routers, but that this configuration option SHOULD NOT be enabled by default.",
      "ja": "我々はいくつかの古いPIM実装は間違ってポイントツーポイントインターフェイス上でHelloメッセージを送信するために失敗することに注意してくださいので、私たちはまた、コンフィギュレーションオプションが、このような古いルータとの相互運用を可能にするために提供することをお勧めしますが、この設定オプションはデフォルトで有効にすべきではないこと。"
    },
    {
      "indent": 0,
      "text": "4.6.1. (S,G) Assert Message State Machine",
      "section_title": true,
      "ja": "4.6.1。 （S、G）のAssertメッセージステートマシン"
    },
    {
      "indent": 3,
      "text": "The (S,G) Assert state machine for interface I is shown in Figure 10. There are three states:",
      "ja": "（S、G）界面Iのための状態機械をアサート3つの状態があり、図10に示されています。"
    },
    {
      "indent": 3,
      "text": "NoInfo (NI) This router has no (S,G) assert state on interface I.",
      "ja": "NoInfo（NI）このルータがない（S、G）界面I.上の状態を主張しています"
    },
    {
      "indent": 3,
      "text": "I am Assert Winner (W) This router has won an (S,G) assert on interface I. It is now responsible for forwarding traffic from S destined for G out of interface I. Irrespective of whether it is the DR for I, while a router is the assert winner, it is also responsible for forwarding traffic onto I on behalf of local hosts on I that have made membership requests that specifically refer to S (and G).",
      "ja": "私は一方で、このルータは（S、G）獲得した受賞（W）をアサートそれはそれは私のためにDRであるかどうかにかかわらず、インターフェースIのうち、G宛てSからのトラフィックを転送するために、今責任があるインタフェースI.上で主張していますルータは、それはまた、特にS（およびG）を参照してくださいメンバーシップのリクエストをした私のローカルホストに代わって私にトラフィックを転送する責任があり、アサート勝者です。"
    },
    {
      "indent": 3,
      "text": "I am Assert Loser (L) This router has lost an (S,G) assert on interface I. It must not forward packets from S destined for G onto interface I. If it is the DR on I, it is no longer responsible for forwarding traffic onto I to satisfy local hosts with membership requests that specifically refer to S and G.",
      "ja": "私は（L）このルータは失ってしまった（S、G）は、インタフェースI.上で主張することは、インタフェースI.上にG宛てSからのパケットを転送してはならない、それは私にDRであれば、それはもはや責任があるアサート敗者です私は、特にSおよびGを参照して、会員のリクエストでローカルホストを満たすためにトラフィックを転送します"
    },
    {
      "indent": 3,
      "text": "In addition, there is also an Assert Timer (AT) that is used to time out asserts on the assert losers and to resend asserts on the assert winner.",
      "ja": "また、アウト時に使用アサート敗者にアサートし、アサート勝者にアサート再送するようにされてアサートタイマー（AT）もあります。"
    },
    {
      "indent": 2,
      "text": "Figure 10: Per-interface (S,G) Assert State machine in tabular form",
      "ja": "図10：表形式でごとのインタフェース（S、G）をアサート状態マシン"
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                         In NoInfo (NI) State                         |\n+---------------+-------------------+------------------+---------------+\n| Receive       |  Receive Assert   |  Data arrives    |  Receive      |\n| Inferior      |  with RPTbit      |  from S to G on  |  Acceptable   |\n| Assert with   |  set and          |  I and           |  Assert with  |\n| RPTbit clear  |  CouldAssert      |  CouldAssert     |  RPTbit clear |\n| and           |  (S,G,I)          |  (S,G,I)         |  and AssTrDes |\n| CouldAssert   |                   |                  |  (S,G,I)      |\n| (S,G,I)       |                   |                  |               |\n+---------------+-------------------+------------------+---------------+\n| -> W state    |  -> W state       |  -> W state      |  -> L state   |\n| [Actions A1]  |  [Actions A1]     |  [Actions A1]    |  [Actions A6] |\n+---------------+-------------------+------------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                   In I Am Assert Winner (W) State                    |\n+----------------+------------------+-----------------+----------------+\n| Assert Timer   |   Receive        |  Receive        |  CouldAssert   |\n| Expires        |   Inferior       |  Preferred      |  (S,G,I) ->    |\n|                |   Assert         |  Assert         |  FALSE         |\n+----------------+------------------+-----------------+----------------+\n| -> W state     |   -> W state     |  -> L state     |  -> NI state   |\n| [Actions A3]   |   [Actions A3]   |  [Actions A2]   |  [Actions A4]  |\n+----------------+------------------+-----------------+----------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "+---------------------------------------------------------------------+\n|                   In I Am Assert Loser (L) State                    |\n+-------------+-------------+-------------+-------------+-------------+\n|Receive      |Receive      |Receive      |Assert Timer |Current      |\n|Preferred    |Acceptable   |Inferior     |Expires      |Winner's     |\n|Assert       |Assert with  |Assert or    |             |GenID        |\n|             |RPTbit clear |Assert       |             |Changes or   |\n|             |from Current |Cancel from  |             |NLT Expires  |\n|             |Winner       |Current      |             |             |\n|             |             |Winner       |             |             |\n+-------------+-------------+-------------+-------------+-------------+\n|-> L state   |-> L state   |-> NI state  |-> NI state  |-> NI state  |\n|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |\n+-------------+-------------+-------------+-------------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                    In I Am Assert Loser (L) State                    |\n+----------------+-----------------+------------------+----------------+\n| AssTrDes       |  my_metric ->   |  RPF_interface   |  Receive       |\n| (S,G,I) ->     |  better than    |  (S) stops       |  Join(S,G) on  |\n| FALSE          |  winner's       |  being I         |  interface I   |\n|                |  metric         |                  |                |\n+----------------+-----------------+------------------+----------------+\n| -> NI state    |  -> NI state    |  -> NI state     |  -> NI State   |\n| [Actions A5]   |  [Actions A5]   |  [Actions A5]    |  [Actions A5]  |\n+----------------+-----------------+------------------+----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that for reasons of compactness, \"AssTrDes(S,G,I)\" is used in the state machine table to refer to AssertTrackingDesired(S,G,I).",
      "ja": "小型化の理由でなお、 \"AssTrDes（S、G、I）\" AssertTrackingDesiredを参照するためにステートマシンテーブルで使用されている（S、G、I）。"
    },
    {
      "indent": 3,
      "text": "Terminology:",
      "ja": "用語："
    },
    {
      "indent": 6,
      "text": "A \"preferred assert\" is one with a better metric than the current winner.",
      "ja": "「優先アサートは、」現在の勝者より良いメトリックを有するものです。"
    },
    {
      "indent": 6,
      "text": "An \"acceptable assert\" is one that has a better metric than my_assert_metric(S,G,I). An assert is never considered acceptable if its metric is infinite.",
      "ja": "「許容アサート」は、より良いメトリックmy_assert_metric（S、G、I）よりも有するものです。そのメトリックが無限であればアサートは許容できるとみなされることはありません。"
    },
    {
      "indent": 6,
      "text": "An \"inferior assert\" is one with a worse metric than my_assert_metric(S,G,I). An assert is never considered inferior if my_assert_metric(S,G,I) is infinite.",
      "ja": "「劣っアサートが」my_assert_metric（S、G、I）よりも悪いメトリックを有するものです。 （S、G、I）my_assert_metricが無限大である場合にはアサートが劣るとみなされることはありません。"
    },
    {
      "indent": 3,
      "text": "The state machine uses the following macros:",
      "ja": "ステートマシンは、次のマクロを使用しています："
    },
    {
      "indent": 0,
      "text": "CouldAssert(S,G,I) = SPTbit(S,G)==TRUE AND (RPF_interface(S) != I) AND (I in ( ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) ) (+) ( pim_include(*,G) (-) pim_exclude(S,G) ) (-) lost_assert(*,G) (+) joins(S,G) (+) pim_include(S,G) ) )",
      "ja": "CouldAssert（S、G、I）= SPTbit（S、G）== TRUE AND（RPF_interface（S）！= I）AND（中I（（（*、*、RP（G）を合流）（+）は、（加入します*、G）（ - ）プルーン（S、G、RPT））（+）（pim_include（*、G）（ - ）pim_exclude（S、G））（ - ）lost_assert（*、G）（+）ジョイン（ S、G）（+）pim_include（S、G）））"
    },
    {
      "indent": 3,
      "text": "CouldAssert(S,G,I) is true for downstream interfaces that would be in the inherited_olist(S,G) if (S,G) assert information was not taken into account.",
      "ja": "CouldAssert（S、G、I）が（S、G）アサート情報を考慮していなかった場合に引き継いでいる_olist（S、G）であろう下流インタフェースに対しても同様です。"
    },
    {
      "indent": 3,
      "text": "AssertTrackingDesired(S,G,I) = (I in ( ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) ) (+) ( pim_include(*,G) (-) pim_exclude(S,G) ) (-) lost_assert(*,G) (+) joins(S,G) ) ) OR (local_receiver_include(S,G,I) == TRUE AND (I_am_DR(I) OR (AssertWinner(S,G,I) == me))) OR ((RPF_interface(S) == I) AND (JoinDesired(S,G) == TRUE)) OR ((RPF_interface(RP(G)) == I) AND (JoinDesired(*,G) == TRUE) AND (SPTbit(S,G) == FALSE))",
      "ja": "AssertTrackingDesired（S、G、I）=（Iはで（（（*、*、RP（G）に参加）（+）ジョイン（*、G）（ - ）プルーン（S、G、RPT））（+）（ pim_include（*、G）（ - ）pim_exclude（S、G））（ - ）lost_assert（*、G）（+）参加する（S、G）））OR（local_receiver_include（S、G、I）== TRUEと（I_am_DR（I）OR（AssertWinner（S、G、I）==私）））OR（（RPF_interface（S）== I）AND（JoinDesired（S、G）== TRUE））OR（（RPF_interface（ RP（G））== I）AND（JoinDesired（*、G）== TRUE）AND（SPTbit（S、G）== FALSE））"
    },
    {
      "indent": 3,
      "text": "AssertTrackingDesired(S,G,I) is true on any interface in which an (S,G) assert might affect our behavior.",
      "ja": "AssertTrackingDesired（S、G、I）は、（S、G）アサートが私たちの行動に影響を与える可能性のあるすべてのインターフェイスに当てはまります。"
    },
    {
      "indent": 3,
      "text": "The first three lines of AssertTrackingDesired account for (*,G) join and local membership information received on I that might cause the router to be interested in asserts on I.",
      "ja": "ルータがI.にアサートに興味があることを引き起こすかもしれないIで受信した（*、G）に参加し、地元の会員情報についてAssertTrackingDesiredアカウントの最初の3行"
    },
    {
      "indent": 3,
      "text": "The 4th line accounts for (S,G) join information received on I that might cause the router to be interested in asserts on I.",
      "ja": "第四行は、ルータがI.にアサートに興味があることを引き起こすかもしれないIで受信した情報を結合する（S、G）を占め、"
    },
    {
      "indent": 3,
      "text": "The 5th and 6th lines account for (S,G) local membership information on I. Note that we can't use the pim_include(S,G) macro since it uses lost_assert(S,G,I) and would result in the router forgetting that it lost an assert if the only reason it was interested was local membership. The AssertWinner(S,G,I) check forces an assert winner to keep on being responsible for forwarding as long as local receivers are present. Removing this check would make the assert winner give up forwarding as soon as the information that originally caused it to forward went away, and the task of forwarding for local receivers would revert back to the DR.",
      "ja": "5番目と6番目の行は、（S、G）、我々はそれが（S、G、I）lost_assertを使用しているのでpim_include（S、G）マクロを使用することはできませんし、ルータにつながるI.注上のローカルメンバーシップ情報を占めますそれは興味があった唯一の理由は、地元の会員だった場合、それはアサートを失ったことを忘れます。 AssertWinner（S、G、I）のチェックが限り地元の受信機が存在しているとして転送する責任であることに保つためにアサート勝者を強制します。このチェックを削除すると、アサート勝者はもともとそれが離れていった転送するために引き起こされた情報、およびバックDRに戻りますローカル受信機のための転送のタスクとすぐに転送あきらめなるだろう。"
    },
    {
      "indent": 3,
      "text": "The last three lines account for the fact that a router must keep track of assert information on upstream interfaces in order to send joins and prunes to the proper neighbor.",
      "ja": "最後の3行は、ルータが適切な隣人に参加し、プルーンを送信するために、アップストリームインターフェイス上でのassert情報を追跡しなければならないという事実を占めています。"
    },
    {
      "indent": 3,
      "text": "Transitions from NoInfo State",
      "ja": "NoInfo状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in NoInfo state, the following events may trigger transitions:",
      "ja": "NoInfo状態で、次のイベントは、遷移を引き起こす可能時："
    },
    {
      "indent": 5,
      "text": "Receive Inferior Assert with RPTbit cleared AND CouldAssert(S,G,I)==TRUE An assert is received for (S,G) with the RPT bit cleared that is inferior to our own assert metric. The RPT bit cleared indicates that the sender of the assert had (S,G) forwarding state on this interface. If the assert is inferior to our metric, then we must also have (S,G) forwarding state (i.e., CouldAssert(S,G,I)==TRUE) as (S,G) asserts beat (*,G) asserts, and so we should be the assert winner. We transition to the \"I am Assert Winner\" state and perform Actions A1 (below).",
      "ja": "== TRUEアサートはRPTビットと（S、G）のために受信されRPTbitで劣るアサートを受信クリアしCouldAssert（S、G、I）それは私たち自身のアサートメトリックに劣るクリア。クリアRPTビットはアサートの送信者が（S、G）は、このインターフェイス上の転送状態を有していたことを示しています。アサートは、私たちのメトリックに劣っているなら、私たちはまた、（S、G）転送状態（すなわち、CouldAssert（S、G、I）== TRUE）（S、G）をアサートビート（*、G）をアサートしている必要があります、と私たちはアサート勝者でなければなりません。私たちは、状態「私は勝者をアサートしています」とA1（下）アクションを実行するために移行します。"
    },
    {
      "indent": 5,
      "text": "Receive Assert with RPTbit set AND CouldAssert(S,G,I)==TRUE An assert is received for (S,G) on I with the RPT bit set (it's a (*,G) assert). CouldAssert(S,G,I) is TRUE only if we have (S,G) forwarding state on this interface, so we should be the assert winner. We transition to the \"I am Assert Winner\" state and perform Actions A1 (below).",
      "ja": "RPTbitセットとCouldAssert（S、G、I）== TRUEアサートはRPTビットセット（それは（*、G）のassertだ）とIに（S、G）のために受信されるとアサートを受信します。 CouldAssert（S、G、I）は、我々は、このインターフェイス上で（S、G）転送状態を持っている場合にのみTRUEであるので、我々はアサート勝者でなければなりません。私たちは、状態「私は勝者をアサートしています」とA1（下）アクションを実行するために移行します。"
    },
    {
      "indent": 5,
      "text": "An (S,G) data packet arrives on interface I, AND CouldAssert(S,G,I)==TRUE An (S,G) data packet arrived on an downstream interface that is in our (S,G) outgoing interface list. We optimistically assume that we will be the assert winner for this (S,G), and so we transition to the \"I am Assert Winner\" state and perform Actions A1 (below), which will initiate the assert negotiation for (S,G).",
      "ja": "（S、G）のデータパケットは、私がインターフェイスに到着し、CouldAssert（S、G、I）== TRUEアン（S、G）のデータパケットは、私たちの（S、G）発信インターフェイスリストにあるダウンストリームインターフェイスに到着しました。私たちは楽観我々は、この（S、G）のためのアサート勝者になることを想定し、私たちは状態「私がアサート勝者だ」と（S、G用アサートネゴシエーションを開始した、（下）アクションA1を実行に移行します）。"
    },
    {
      "indent": 5,
      "text": "Receive Acceptable Assert with RPT bit clear AND AssertTrackingDesired(S,G,I)==TRUE We're interested in (S,G) Asserts, either because I is a downstream interface for which we have (S,G) or (*,G) forwarding state, or because I is the upstream interface for S and we have (S,G) forwarding state. The received assert has a better metric than our own, so we do not win the Assert. We transition to \"I am Assert Loser\" and perform Actions A6 (below).",
      "ja": "*（I、S、G）をクリアし、AssertTrackingDesired RPTビットで許容アサートを受信== TRUE我々は（S、G）に興味を表明し、いずれかの私たちは（S、G）持っているダウンストリームインターフェイスであるため、または（ 、G）転送状態、またはI Sのアップストリームインタフェースであり、我々は（S、G）転送状態を有するからです。受信アサートが私たち自身よりも優れたメトリックを持っているので、私たちはアサートを獲得していません。私たちは、「私は敗者をアサートしています」とA6（下）アクションを実行するように移行します。"
    },
    {
      "indent": 3,
      "text": "Transitions from \"I am Assert Winner\" State",
      "ja": "国家「私は勝者をアサートしています」からの遷移"
    },
    {
      "indent": 3,
      "text": "When in \"I am Assert Winner\" state, the following events trigger transitions:",
      "ja": "状態「私がアサート受賞しています」と、次のイベントが遷移をトリガ："
    },
    {
      "indent": 5,
      "text": "Assert Timer Expires The (S,G) Assert Timer expires. As we're in the Winner state, we must still have (S,G) forwarding state that is actively being kept alive. We resend the (S,G) Assert and restart the Assert Timer (Actions A3 below). Note that the assert winner's Assert Timer is engineered to expire shortly before timers on assert losers; this prevents unnecessary thrashing of the forwarder and periodic flooding of duplicate packets.",
      "ja": "アサートタイマ（S、G）をアサートタイマが満了する期限。我々は勝者の状態にしているように、我々はまだ積極的に生かされている（S、G）転送状態を持っている必要があります。我々は（S、G）アサートを再送信し、アサートタイマー（アクションA3以下）を再起動します。アサート勝者のアサートタイマーがアサート敗者のタイマー直前に期限が切れるように設計されていることに注意してください。これは、フォワーダの不要なスラッシングと重複パケットの定期的な氾濫を防ぐことができます。"
    },
    {
      "indent": 5,
      "text": "Receive Inferior Assert We receive an (S,G) assert or (*,G) assert mentioning S that has a worse metric than our own. Whoever sent the assert is in error, and so we resend an (S,G) Assert and restart the Assert Timer (Actions A3 below).",
      "ja": "私たちは、（S、G）をアサートまたは（*、G）は、私たち自身より悪いメトリックを持つSに言及主張受け取る劣るアサートを受信します。誰アサートを送ったことは誤りであり、そして私たちは（S、G）アサートを再送信し、アサートタイマー（アクションA3以下）を再起動します。"
    },
    {
      "indent": 5,
      "text": "Receive Preferred Assert We receive an (S,G) assert that has a better metric than our own. We transition to \"I am Assert Loser\" state and perform Actions A2 (below). Note that this may affect the value of JoinDesired(S,G) and PruneDesired(S,G,rpt), which could cause transitions in the upstream (S,G) or (S,G,rpt) state machines.",
      "ja": "私たちはより良いメトリック私たち自身よりも持っている（S、G）アサートを受け取る優先アサートを受信します。私たちは、状態「私は敗者をアサートしています」とA2（下記）アクションを実行するように移行します。これは上流の（S、G）または（S、G、RPT）ステートマシンの遷移を引き起こす可能性がJoinDesired（S、G）とPruneDesired（S、G、RPT）の値に影響を与えることができることに留意されたいです。"
    },
    {
      "indent": 5,
      "text": "CouldAssert(S,G,I) -> FALSE Our (S,G) forwarding state or RPF interface changed so as to make CouldAssert(S,G,I) become false. We can no longer perform the actions of the assert winner, and so we transition to NoInfo state and perform Actions A4 (below). This includes sending a \"canceling assert\" with an infinite metric.",
      "ja": "CouldAssert（S、G、I） - > FALSE私たちの（S、G）転送状態またはCouldAssert（S、G、I）が偽になるとなるように変更さRPFインターフェイス。私たちは、もはやアサート勝者のアクションを実行することはできません、と私たちはNoInfo状態に遷移し、アクション（下）A4を行います。これは、無限のメトリックで「キャンセルアサート」を送信することを含みます。"
    },
    {
      "indent": 3,
      "text": "Transitions from \"I am Assert Loser\" State",
      "ja": "国家「私は敗者をアサートしています」からの遷移"
    },
    {
      "indent": 3,
      "text": "When in \"I am Assert Loser\" state, the following transitions can occur:",
      "ja": "状態「私は敗者をアサートしています」ときで、次の遷移が発生する可能性があります。"
    },
    {
      "indent": 5,
      "text": "Receive Preferred Assert We receive an assert that is better than that of the current assert winner. We stay in Loser state and perform Actions A2 below.",
      "ja": "私たちは、現在のアサート勝者のそれよりも優れているアサートを受ける優先アサートを受信します。我々は敗者状態のままにし、以下のアクションA2を行います。"
    },
    {
      "indent": 5,
      "text": "Receive Acceptable Assert with RPTbit clear from Current Winner We receive an assert from the current assert winner that is better than our own metric for this (S,G) (although the metric may be worse than the winner's previous metric). We stay in Loser state and perform Actions A2 below.",
      "ja": "私たちは、この（S、G）（メトリックは勝者の前のメトリックよりも悪いかもしれないが）のために私たち自身のメトリックよりも優れている現在のアサート勝者からアサートを受ける現在の受賞者からの明確なRPTbitで許容アサートを受信します。我々は敗者状態のままにし、以下のアクションA2を行います。"
    },
    {
      "indent": 5,
      "text": "Receive Inferior Assert or Assert Cancel from Current Winner We receive an assert from the current assert winner that is worse than our own metric for this group (typically, because the winner's metric became worse or because it is an assert cancel). We transition to NoInfo state, deleting the (S,G) assert information and allowing the normal PIM Join/Prune mechanisms to operate. Usually, we will eventually re-assert and win when data packets from S have started flowing again.",
      "ja": "劣っアサートまたはアサートが現在の受賞者からキャンセルの受信我々は（勝者のメトリックが悪化したか、それがアサートされるので、キャンセルので、一般的に）このグループのために私たち自身のメトリックよりも悪化している現在のアサート勝者からアサートを受けます。我々は、（S、G）は情報をアサートし、通常のPIMは/動作するプルーンメカニズムに参加できるように削除、NoInfo状態に遷移します。通常、我々は最終的にアサートを再し、Sからのデータパケットが再び流れ始めた時に獲得します。"
    },
    {
      "indent": 5,
      "text": "Assert Timer Expires The (S,G) Assert Timer expires. We transition to NoInfo state, deleting the (S,G) assert information (Actions A5 below).",
      "ja": "アサートタイマ（S、G）をアサートタイマが満了する期限。我々は、（S、G）情報（以下アクションA5）をアサートを削除し、NoInfo状態に遷移します。"
    },
    {
      "indent": 5,
      "text": "Current Winner's GenID Changes or NLT Expires The Neighbor Liveness Timer associated with the current winner expires or we receive a Hello message from the current winner reporting a different GenID from the one it previously reported. This indicates that the current winner's interface or router has gone down (and may have come back up), and so we must assume it no longer knows it was the winner. We transition to the NoInfo state, deleting this (S,G) assert information (Actions A5 below).",
      "ja": "現在ウィナーズられたGenID変更またはNLTが満了し、現在の勝者に関連付けられた近隣ライブネスタイマーを期限切れになるか、私たちはそれが以前に報告されたものとは異なるられたGenIDを報告し、現在の勝者からHelloメッセージを受信します。これは、現在の勝者のインタフェースやルータがダウンした（と戻って来たかもしれない）ことを示している、と私たちは、それはもはや、それは勝者だった知っていると仮定してはなりません。我々は、この（S、G）情報（以下アクションA5）をアサートを削除し、NoInfo状態に遷移します。"
    },
    {
      "indent": 5,
      "text": "AssertTrackingDesired(S,G,I)->FALSE AssertTrackingDesired(S,G,I) becomes FALSE. Our forwarding state has changed so that (S,G) Asserts on interface I are no longer of interest to us. We transition to the NoInfo state, deleting the (S,G) assert information.",
      "ja": "AssertTrackingDesired（S、G、I） - > FALSE AssertTrackingDesired（S、G、I）がFALSEになります。 （S、G）がインターフェイスでアサートすることを私はもはや私たちに関心のあるように、私たちの転送状態は変わっていません。我々は、（S、G）は情報をアサート削除、NoInfo状態に遷移します。"
    },
    {
      "indent": 5,
      "text": "My metric becomes better than the assert winner's metric my_assert_metric(S,G,I) has changed so that now my assert metric for (S,G) is better than the metric we have stored for current assert winner. This might happen when the underlying routing metric changes, or when CouldAssert(S,G,I) becomes true; for example, when SPTbit(S,G) becomes true. We transition to NoInfo state, delete this (S,G) assert state (Actions A5 below), and allow the normal PIM Join/Prune mechanisms to operate. Usually, we will eventually re-assert and win when data packets from S have started flowing again.",
      "ja": "私のメトリックは今（S、G）のための私のアサートメトリックは、我々が現在アサート勝者のために保存されているメトリックよりも優れているように変更されたアサート勝者のメトリックmy_assert_metric（S、G、I）よりも良好となります。基礎となるメトリックの変更をルーティングするときに発生する可能性があります、またはCouldAssert（S、G、I）が真となったとき。例えば、SPTbit（S、G）が真となります。我々は、NoInfo状態に遷移この（S、G）アサート状態（アクション以下A5）を削除し、そして通常のPIMが動作する/プルーンメカニズムに参加可能。通常、我々は最終的にアサートを再し、Sからのデータパケットが再び流れ始めた時に獲得します。"
    },
    {
      "indent": 5,
      "text": "RPF_interface(S) stops being interface I Interface I used to be the RPF interface for S, and now it is not. We transition to NoInfo state, deleting this (S,G) assert state (Actions A5 below).",
      "ja": "RPF_interface（S）は、私はSのためのRPFインターフェイスであるために使用されるインタフェースであることインタフェースを停止し、今ではありません。我々は、この（S、G）状態（以下アクションA5）をアサートを削除し、NoInfo状態に遷移します。"
    },
    {
      "indent": 5,
      "text": "Receive Join(S,G) on Interface I We receive a Join(S,G) that has the Upstream Neighbor Address field set to my primary IP address on interface I. The action is to transition to NoInfo state, delete this (S,G) assert state (Actions A5 below), and allow the normal PIM Join/Prune mechanisms to operate. If whoever sent the Join was in error, then the normal assert mechanism will eventually re-apply, and we will lose the assert again. However, whoever sent the assert may know that the previous assert winner has died, and so we may end up being the new forwarder.",
      "ja": "インタフェースIの（S、G）が参加レシーブ我々は（Sのインタフェースアクションはこれを削除し、NoInfo状態に遷移することであるI.上で私のプライマリIPアドレスに設定上流隣接アドレスフィールドを持っている（S、G）が参加受け取り、 G）状態（アクション以下A5）をアサートし、通常のPIMが動作するように/プルーン機構に参加可能。誰でも参加を送ってもエラーにあった場合は、通常のアサートメカニズムは、最終的に再適用されます、そして我々は再びアサートを失うことになります。しかし、誰が以前アサート勝者が亡くなったことを知っている可能性がありアサートを送った、と私たちは新しいフォワーダになってしまうことがあります。"
    },
    {
      "indent": 3,
      "text": "(S,G) Assert State machine Actions",
      "ja": "（S、G）アサートステートマシンのアクション"
    },
    {
      "indent": 5,
      "text": "A1: Send Assert(S,G). Set Assert Timer to (Assert_Time - Assert_Override_Interval). Store self as AssertWinner(S,G,I). Store spt_assert_metric(S,I) as AssertWinnerMetric(S,G,I).",
      "ja": "A1：アサート（S、G）を送信します。 （ -  Assert_Override_Interval Assert_Time）にアサートタイマーを設定します。 AssertWinner（S、G、I）としてストアセルフ。ストアspt_assert_metric（S、I）AssertWinnerMetric（S、G、I）など。"
    },
    {
      "indent": 5,
      "text": "A2: Store new assert winner as AssertWinner(S,G,I) and assert winner metric as AssertWinnerMetric(S,G,I). Set Assert Timer to Assert_Time.",
      "ja": "A2：ストア新しいアサートAssertWinner（S、G、I）として勝者とAssertWinnerMetric（S、G、I）として勝者メトリックを主張しています。 Assert_Timeにアサートタイマーを設定します。"
    },
    {
      "indent": 5,
      "text": "A3: Send Assert(S,G). Set Assert Timer to (Assert_Time - Assert_Override_Interval).",
      "ja": "A3：アサート（S、G）を送信します。 （ -  Assert_Override_Interval Assert_Time）にアサートタイマーを設定します。"
    },
    {
      "indent": 5,
      "text": "A4: Send AssertCancel(S,G). Delete assert info (AssertWinner(S,G,I) and AssertWinnerMetric(S,G,I) will then return their default values).",
      "ja": "A4：AssertCancel（S、G）を送信します。 （AssertWinner（S、G、I）とAssertWinnerMetric（S、G、I）はその後、それらのデフォルト値を返します）の情報をアサート削除します。"
    },
    {
      "indent": 5,
      "text": "A5: Delete assert info (AssertWinner(S,G,I) and AssertWinnerMetric(S,G,I) will then return their default values).",
      "ja": "A5：主張削除情報（AssertWinner（S、G、I）とAssertWinnerMetric（S、G、I）は、その後、それらのデフォルト値を返します）。"
    },
    {
      "indent": 5,
      "text": "A6: Store new assert winner as AssertWinner(S,G,I) and assert winner metric as AssertWinnerMetric(S,G,I). Set Assert Timer to Assert_Time. If (I is RPF_interface(S)) AND (UpstreamJPState(S,G) == true) set SPTbit(S,G) to TRUE.",
      "ja": "A6：ストア新しいアサートAssertWinner（S、G、I）として勝者とAssertWinnerMetric（S、G、I）として勝者メトリックを主張しています。 Assert_Timeにアサートタイマーを設定します。 （私はあるRPF_interface（S））AND（真UpstreamJPState（S、G）==）がTRUEにSPTbit（S、G）を設定した場合。"
    },
    {
      "indent": 3,
      "text": "Note that some of these actions may cause the value of JoinDesired(S,G), PruneDesired(S,G,rpt), or RPF'(S,G) to change, which could cause further transitions in other state machines.",
      "ja": "他のステートマシンにさらに遷移を引き起こす可能性があり、変更するために、これらのアクションのいくつかはJoinDesired（S、G）、PruneDesired（S、G、RPT）の値を引き起こすことがあります、またはRPF '（S、G）。"
    },
    {
      "indent": 0,
      "text": "4.6.2. (*,G) Assert Message State Machine",
      "section_title": true,
      "ja": "4.6.2。 （*、G）のAssertメッセージステートマシン"
    },
    {
      "indent": 3,
      "text": "The (*,G) Assert state machine for interface I is shown in Figure 11. There are three states:",
      "ja": "（*、G）界面Iのための状態機械をアサート3つの状態があり、図11に示されています。"
    },
    {
      "indent": 3,
      "text": "NoInfo (NI) This router has no (*,G) assert state on interface I.",
      "ja": "NoInfo（NI）は、このルータは、インタフェースI.には（*、G）アサート状態を有していません"
    },
    {
      "indent": 3,
      "text": "I am Assert Winner (W) This router has won an (*,G) assert on interface I. It is now responsible for forwarding traffic destined for G onto interface I with the exception of traffic for which it has (S,G) \"I am Assert Loser\" state. Irrespective of whether it is the DR for I, it is also responsible for handling the membership requests for G from local hosts on I.",
      "ja": "私は \"（W）このルータは、（*、G）を獲得したことが、今、私はそれが（S、G）持っているトラフィックを除いて、インタフェース上にG宛てのトラフィックを転送する責任があるインタフェースI.上で主張アサート受賞しています私は敗者」状態をアサートしています。かかわらず、それは私のためにDRであるかどうかの、それはまた、I.上のローカルホストからGのメンバーシップ要求を処理する責任があります"
    },
    {
      "indent": 3,
      "text": "I am Assert Loser (L) This router has lost an (*,G) assert on interface I. It must not forward packets for G onto interface I with the exception of traffic from sources for which is has (S,G) \"I am Assert Winner\" state. If it is the DR, it is no longer responsible for handling the membership requests for group G from local hosts on I.",
      "ja": "私はそれは私が「持っている（S、G）されているソースからのトラフィックを除いてインターフェースI上にGのためにパケットを転送してはならない。このルータは（*、G）が失われた敗者（L）をアサートインタフェースI.上で主張しています勝者」状態をアサートしています。それはDRであるならば、それはもはやI.上のローカルホストからグループGのメンバーシップ要求を処理する責任がありません"
    },
    {
      "indent": 3,
      "text": "In addition, there is also an Assert Timer (AT) that is used to time out asserts on the assert losers and to resend asserts on the assert winner.",
      "ja": "また、アウト時に使用アサート敗者にアサートし、アサート勝者にアサート再送するようにされてアサートタイマー（AT）もあります。"
    },
    {
      "indent": 3,
      "text": "When an Assert message is received with a source address other than zero, a PIM implementation must first match it against the possible events in the (S,G) assert state machine and process any transitions and actions, before considering whether the Assert message matches against the (*,G) assert state machine.",
      "ja": "アサートメッセージがゼロ以外のソースアドレスで受信されると、PIMの実装では、最初のアサートメッセージは反対一致するかどうかを検討する前に、状態機械をアサートし、任意の遷移とアクションを処理する（S、G）の可能なイベントに対してそれと一致しなければなりません（*、G）アサート状態機械。"
    },
    {
      "indent": 3,
      "text": "It is important to note that NO TRANSITION CAN OCCUR in the (*,G) state machine as a result of receiving an Assert message unless the (S,G) assert state machine for the relevant S and G is in the \"NoInfo\" state after the (S,G) state machine has processed the message. Also, NO TRANSITION CAN OCCUR in the (*,G) state machine as a result of receiving an assert message if that message triggers any change of state in the (S,G) state machine. Obviously, when the source address in the received message is set to zero, an (S,G) state machine for the S and G does not exist and can be assumed to be in the \"NoInfo\" state.",
      "ja": "（S、G）は、関連するSのための状態機械をアサートしない限り、遷移がアサート・メッセージを受信した結果として、（*、G）ステートマシンで発生することができないことに留意することが重要であり、G「はNoInfo」状態であります（S、G）ステートマシンはメッセージを処理した後。また、NO TRANSITIONは、そのメッセージが（S、G）ステートマシンにおける状態の変化をトリガする場合にアサートメッセージを受信した結果として、（*、G）ステートマシンで発生することができません。受信したメッセージの送信元アドレスがゼロに設定されている場合、明らかに、（S、G）S及びGのためのステートマシンは存在せず、「NoInfo」状態であると仮定することができます。"
    },
    {
      "indent": 3,
      "text": "For example, if both the (S,G) and (*,G) assert state machines are in the NoInfo state when an Assert message arrives, and the message causes the (S,G) state machine to transition to either \"W\" or \"L\" state, then the assert will not be processed by the (*,G) assert state machine.",
      "ja": "例えば、（S、G）の両方の場合に（*、G）がアサート・メッセージが到着したときに、状態マシンはNoInfo状態であり、メッセージが「W」のいずれかに移行する（S、G）ステートマシンを引き起こすアサートまたは「L」の状態は、次にアサートは（*、G）アサート状態マシンによって処理されません。"
    },
    {
      "indent": 3,
      "text": "Another example: if the (S,G) assert state machine is in \"L\" state when an assert message is received, and the assert metric in the message is worse than my_assert_metric(S,G,I), then the (S,G) assert state machine will transition to NoInfo state. In such a case, if the (*,G) assert state machine were in NoInfo state, it might appear that it would transition to \"W\" state, but this is not the case because this message already triggered a transition in the (S,G) assert state machine.",
      "ja": "別の例：（S、G）アサート状態マシンがアサートメッセージを受信したときに「L」状態であり、メッセージにアサートメトリックは、（I、S、G）を（S my_assert_metricより悪い場合、 G）ステートマシンはNoInfo状態に遷移するアサート。 （*、G）ステートマシンをアサートがNoInfo状態であった場合、このような場合には、このメッセージが既に（S遷移を引き起こしたので、それが「W」の状態遷移になるが、これはそうではないように見えるかもしれません、G）は状態機械をアサート。"
    },
    {
      "indent": 2,
      "text": "Figure 11: Per-interface (*,G) Assert State machine in tabular form",
      "ja": "図11：表形式でごとのインタフェース（*、G）をアサート状態マシン"
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                         In NoInfo (NI) State                         |\n+-----------------------+-----------------------+----------------------+\n| Receive Inferior      |  Data arrives for G   |  Receive Acceptable  |\n| Assert with RPTbit    |  on I and             |  Assert with RPTbit  |\n| set and               |  CouldAssert          |  set and AssTrDes    |\n| CouldAssert(*,G,I)    |  (*,G,I)              |  (*,G,I)             |\n+-----------------------+-----------------------+----------------------+\n| -> W state            |  -> W state           |  -> L state          |\n| [Actions A1]          |  [Actions A1]         |  [Actions A2]        |\n+-----------------------+-----------------------+----------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "+---------------------------------------------------------------------+\n|                    In I Am Assert Winner (W) State                  |\n+----------------+-----------------+-----------------+----------------+\n| Assert Timer   |  Receive        |  Receive        |  CouldAssert   |\n| Expires        |  Inferior       |  Preferred      |  (*,G,I) ->    |\n|                |  Assert         |  Assert         |  FALSE         |\n+----------------+-----------------+-----------------+----------------+\n| -> W state     |  -> W state     |  -> L state     |  -> NI state   |\n| [Actions A3]   |  [Actions A3]   |  [Actions A2]   |  [Actions A4]  |\n+----------------+-----------------+-----------------+----------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "+---------------------------------------------------------------------+\n|                    In I Am Assert Loser (L) State                   |\n+-------------+-------------+-------------+-------------+-------------+\n|Receive      |Receive      |Receive      |Assert Timer |Current      |\n|Preferred    |Acceptable   |Inferior     |Expires      |Winner's     |\n|Assert with  |Assert from  |Assert or    |             |GenID        |\n|RPTbit set   |Current      |Assert       |             |Changes or   |\n|             |Winner with  |Cancel from  |             |NLT Expires  |\n|             |RPTbit set   |Current      |             |             |\n|             |             |Winner       |             |             |\n+-------------+-------------+-------------+-------------+-------------+\n|-> L state   |-> L state   |-> NI state  |-> NI state  |-> NI state  |\n|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |\n+-------------+-------------+-------------+-------------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "+----------------------------------------------------------------------+\n|                    In I Am Assert Loser (L) State                    |\n+----------------+----------------+-----------------+------------------+\n| AssTrDes       | my_metric ->   |  RPF_interface  |  Receive         |\n| (*,G,I) ->     | better than    |  (RP(G)) stops  |  Join(*,G) or    |\n| FALSE          | Winner's       |  being I        |  Join            |\n|                | metric         |                 |  (*,*,RP(G)) on  |\n|                |                |                 |  Interface I     |\n+----------------+----------------+-----------------+------------------+\n| -> NI state    | -> NI state    |  -> NI state    |  -> NI State     |\n| [Actions A5]   | [Actions A5]   |  [Actions A5]   |  [Actions A5]    |\n+----------------+----------------+-----------------+------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The state machine uses the following macros:",
      "ja": "ステートマシンは、次のマクロを使用しています："
    },
    {
      "indent": 3,
      "text": "CouldAssert(*,G,I) = ( I in ( joins(*,*,RP(G)) (+) joins(*,G) (+) pim_include(*,G)) ) AND (RPF_interface(RP(G)) != I)",
      "ja": "CouldAssert（*、G、I）=（I中（参加する（*、*、RP（G））（+）が参加する（*、G）（+）pim_include（*、G）））AND（RPF_interface（RP（ G））！= I）"
    },
    {
      "indent": 3,
      "text": "CouldAssert(*,G,I) is true on downstream interfaces for which we have (*,*,RP(G)) or (*,G) join state, or local members that requested any traffic destined for G.",
      "ja": "CouldAssert（*、G、I）は、我々が持っている（*、*、RP（G））または（*、G）状態に参加れるダウンストリームインターフェイス、またはG.宛てのすべてのトラフィックを要求したローカルメンバーに真であります"
    },
    {
      "indent": 3,
      "text": "AssertTrackingDesired(*,G,I) = CouldAssert(*,G,I) OR (local_receiver_include(*,G,I)==TRUE AND (I_am_DR(I) OR AssertWinner(*,G,I) == me)) OR (RPF_interface(RP(G)) == I AND RPTJoinDesired(G))",
      "ja": "AssertTrackingDesired（*、G、I）= CouldAssert（*、G、I）OR（local_receiver_include（*、G、I）==（I_am_DR（I）OR AssertWinner（*、G、I）TRUEと==私）） OR（RPF_interface（RP（G））== I AND RPTJoinDesired（G））"
    },
    {
      "indent": 3,
      "text": "AssertTrackingDesired(*,G,I) is true on any interface on which an (*,G) assert might affect our behavior.",
      "ja": "AssertTrackingDesired（*、G、I）（*、G）アサートが私たちの行動に影響を与える可能性があります上の任意のインターフェイスに当てはまります。"
    },
    {
      "indent": 3,
      "text": "Note that for reasons of compactness, \"AssTrDes(*,G,I)\" is used in the state machine table to refer to AssertTrackingDesired(*,G,I).",
      "ja": "小型化の理由でなお、 \"AssTrDesは（*、Gは、I）\"（*、G、I）AssertTrackingDesiredを参照するためにステートマシンテーブルで使用されています。"
    },
    {
      "indent": 3,
      "text": "Terminology:",
      "ja": "用語："
    },
    {
      "indent": 6,
      "text": "A \"preferred assert\" is one with a better metric than the current winner.",
      "ja": "「優先アサートは、」現在の勝者より良いメトリックを有するものです。"
    },
    {
      "indent": 6,
      "text": "An \"acceptable assert\" is one that has a better metric than my_assert_metric(*,G,I). An assert is never considered acceptable if its metric is infinite.",
      "ja": "「許容可能なアサートは、」より良いメトリックmy_assert_metricより（*、G、I）を有するものです。そのメトリックが無限であればアサートは許容できるとみなされることはありません。"
    },
    {
      "indent": 6,
      "text": "An \"inferior assert\" is one with a worse metric than my_assert_metric(*,G,I). An assert is never considered inferior if my_assert_metric(*,G,I) is infinite.",
      "ja": "「劣っアサートが」my_assert_metricより悪いメトリックを有するものである（*、G、I）。 my_assert_metric場合アサートが劣るとみなされることはありません（*、G、I）は無限大です。"
    },
    {
      "indent": 3,
      "text": "Transitions from NoInfo State",
      "ja": "NoInfo状態からの遷移"
    },
    {
      "indent": 3,
      "text": "When in NoInfo state, the following events trigger transitions, but only if the (S,G) assert state machine is in NoInfo state before and after consideration of the received message:",
      "ja": "NoInfo状態で、次のイベントが遷移をトリガするが、（S、G）は状態機械をアサートする場合にのみときに、受信したメッセージを考慮前後のNoInfo状態です。"
    },
    {
      "indent": 5,
      "text": "Receive Inferior Assert with RPTbit set AND CouldAssert(*,G,I)==TRUE An Inferior (*,G) assert is received for G on Interface I. If CouldAssert(*,G,I) is TRUE, then I is our downstream interface, and we have (*,G) forwarding state on this interface, so we should be the assert winner. We transition to the \"I am Assert Winner\" state and perform Actions A1 (below).",
      "ja": "RPTbitセットとCouldAssert（*、G、I）で劣るアサートを受信== TRUEアン劣る（*、G）アサートがインタフェースI.もしCouldAssertにGのために受信される（*、G、I）TRUEで、その後、私は私たちですダウンストリームインターフェイス、そして私たちは、このインターフェイス上で（*、G）転送状態を持っているので、我々はアサート勝者でなければなりません。私たちは、状態「私は勝者をアサートしています」とA1（下）アクションを実行するために移行します。"
    },
    {
      "indent": 5,
      "text": "A data packet destined for G arrives on interface I, AND CouldAssert(*,G,I)==TRUE A data packet destined for G arrived on a downstream interface that is in our (*,G) outgoing interface list. We therefore believe we should be the forwarder for this (*,G), and so we transition to the \"I am Assert Winner\" state and perform Actions A1 (below).",
      "ja": "G宛のデータパケットは、私がインターフェイスに到着し、G宛てCouldAssert（*、G、I）== TRUEデータパケットは、私たちの（*、G）発信インターフェイスリストにあるダウンストリームインターフェイスに到着しました。したがって、我々は、我々は、このためのフォワーダ（*、G）であるべき、と私たちは状態「私は勝者をアサートしています」とA1（下）アクションを実行するために移行すると考えています。"
    },
    {
      "indent": 5,
      "text": "Receive Acceptable Assert with RPT bit set AND AssertTrackingDesired(*,G,I)==TRUE We're interested in (*,G) Asserts, either because I is a downstream interface for which we have (*,G) forwarding state, or because I is the upstream interface for RP(G) and we have (*,G) forwarding state. We get a (*,G) Assert that has a better metric than our own, so we do not win the Assert. We transition to \"I am Assert Loser\" and perform Actions A2 (below).",
      "ja": "、RPTビットセットとAssertTrackingDesired（*、G、I）で許容アサートを受信== TRUE我々は（*、G）に興味を表明し、いずれかの私たちは（*、G）転送状態を持っているため、ダウンストリームインターフェイスであるため、または私はRPのためのアップストリームインターフェイス（G）であり、我々は（*、G）転送状態を持っているので。私たちはより良いメトリック私たち自身よりも持っている（*、G）アサートを取得するので、私たちはアサートを獲得していません。私たちは、「私は敗者をアサートしています」とA2（下記）アクションを実行するように移行します。"
    },
    {
      "indent": 3,
      "text": "Transitions from \"I am Assert Winner\" State",
      "ja": "国家「私は勝者をアサートしています」からの遷移"
    },
    {
      "indent": 3,
      "text": "When in \"I am Assert Winner\" state, the following events trigger transitions, but only if the (S,G) assert state machine is in NoInfo state before and after consideration of the received message:",
      "ja": "状態「私がアサート受賞しています」と、次のイベントは、トランジションをトリガーするが、（S、G）は、ステートマシンを主張する場合にのみ、受信したメッセージを考慮する前と後のNoInfo状態にあります。"
    },
    {
      "indent": 5,
      "text": "Receive Inferior Assert We receive a (*,G) assert that has a worse metric than our own. Whoever sent the assert has lost, and so we resend a (*,G) Assert and restart the Assert Timer (Actions A3 below).",
      "ja": "私たちは私たち自身よりも悪いメトリックを持っている（*、G）アサートを受け劣るアサートを受信します。誰がアサートが失われた送信され、私たちは（*、G）アサートを再送信し、アサートタイマー（アクションA3以下）を再起動します。"
    },
    {
      "indent": 5,
      "text": "Receive Preferred Assert We receive a (*,G) assert that has a better metric than our own. We transition to \"I am Assert Loser\" state and perform Actions A2 (below).",
      "ja": "私たちはより良いメトリック私たち自身よりも持っている（*、G）アサートを受け取る優先アサートを受信します。私たちは、状態「私は敗者をアサートしています」とA2（下記）アクションを実行するように移行します。"
    },
    {
      "indent": 3,
      "text": "When in \"I am Assert Winner\" state, the following events trigger transitions:",
      "ja": "状態「私がアサート受賞しています」と、次のイベントが遷移をトリガ："
    },
    {
      "indent": 5,
      "text": "Assert Timer Expires The (*,G) Assert Timer expires. As we're in the Winner state, then we must still have (*,G) forwarding state that is actively being kept alive. To prevent unnecessary thrashing of the forwarder and periodic flooding of duplicate packets, we resend the (*,G) Assert and restart the Assert Timer (Actions A3 below).",
      "ja": "アサートタイマ（*、G）アサートタイマが満了する期限。我々は勝者の状態にしているとして、我々はまだ積極的に生かされている（*、G）転送状態を持っている必要があります。フォワーダと重複パケットの定期的な洪水の不要なスラッシングを防ぐために、我々は、（*、G）アサートを再送信し、アサートタイマー（アクションA3以下）を再起動します。"
    },
    {
      "indent": 5,
      "text": "CouldAssert(*,G,I) -> FALSE Our (*,G) forwarding state or RPF interface changed so as to make CouldAssert(*,G,I) become false. We can no longer perform the actions of the assert winner, and so we transition to NoInfo state and perform Actions A4 (below).",
      "ja": "CouldAssert（*、G、I） - > FALSE私たちの（*、G）転送状態またはCouldAssert（*、G、I）が偽になるとなるように変更さRPFインターフェイス。私たちは、もはやアサート勝者のアクションを実行することはできません、と私たちはNoInfo状態に遷移し、アクション（下）A4を行います。"
    },
    {
      "indent": 3,
      "text": "Transitions from \"I am Assert Loser\" State",
      "ja": "国家「私は敗者をアサートしています」からの遷移"
    },
    {
      "indent": 3,
      "text": "When in \"I am Assert Loser\" state, the following events trigger transitions, but only if the (S,G) assert state machine is in NoInfo state before and after consideration of the received message:",
      "ja": "状態「私は敗者をアサートしています」と、次のイベントは、トランジションをトリガーするが、（S、G）は、ステートマシンを主張する場合にのみ、受信したメッセージを考慮する前と後のNoInfo状態にあります。"
    },
    {
      "indent": 5,
      "text": "Receive Preferred Assert with RPTbit set We receive a (*,G) assert that is better than that of the current assert winner. We stay in Loser state and perform Actions A2 below.",
      "ja": "私たちが受け取るRPTbitセットで優先アサートを受信（*、G）は、それが現在のアサート勝者のそれよりも優れて主張しています。我々は敗者状態のままにし、以下のアクションA2を行います。"
    },
    {
      "indent": 5,
      "text": "Receive Acceptable Assert from Current Winner with RPTbit set We receive a (*,G) assert from the current assert winner that is better than our own metric for this group (although the metric may be worse than the winner's previous metric). We stay in Loser state and perform Actions A2 below.",
      "ja": "私たちは、（*、G）が（メトリックは勝者の前のメトリックよりも悪いかもしれないが）、このグループのために私たち自身のメトリックよりも優れている現在のアサート勝者からの主張を受けるRPTbitセットで現在の受賞者から許容アサートを受けます。我々は敗者状態のままにし、以下のアクションA2を行います。"
    },
    {
      "indent": 5,
      "text": "Receive Inferior Assert or Assert Cancel from Current Winner We receive an assert from the current assert winner that is worse than our own metric for this group (typically because the winner's metric became worse or is now an assert cancel). We transition to NoInfo state, delete this (*,G) assert state (Actions A5), and allow the normal PIM Join/Prune mechanisms to operate. Usually, we will eventually re-assert and win when data packets for G have started flowing again.",
      "ja": "（勝者のメトリックが悪化したか、今アサートキャンセルされ、通常ので）私たちは、このグループのために私たち自身のメトリックよりも悪化している現在のアサート勝者からアサートを受ける劣るアサートまたはアサートが現在の受賞者からキャンセル受け取ります。私たちは、NoInfo状態に移行し、（*、G）は状態（アクションA5）をアサートし、通常のPIMが動作するように/プルーンのメカニズムに参加できるように、これを削除します。通常、我々は最終的にアサートを再とGのためのデータパケットが再び流れ始めた時に獲得します。"
    },
    {
      "indent": 3,
      "text": "When in \"I am Assert Loser\" state, the following events trigger transitions:",
      "ja": "状態「私は敗者をアサートしています」と、次のイベントが遷移をトリガ："
    },
    {
      "indent": 5,
      "text": "Assert Timer Expires The (*,G) Assert Timer expires. We transition to NoInfo state and delete this (*,G) assert info (Actions A5).",
      "ja": "アサートタイマ（*、G）アサートタイマが満了する期限。私たちは、NoInfo状態に遷移し、（*、G）をアサート情報（アクションA5）これを削除します。"
    },
    {
      "indent": 5,
      "text": "Current Winner's GenID Changes or NLT Expires The Neighbor Liveness Timer associated with the current winner expires or we receive a Hello message from the current winner reporting a different GenID from the one it previously reported. This indicates that the current winner's interface or router has gone down (and may have come back up), and so we must assume it no longer knows it was the winner. We transition to the NoInfo state, deleting the (*,G) assert information (Actions A5).",
      "ja": "現在ウィナーズられたGenID変更またはNLTが満了し、現在の勝者に関連付けられた近隣ライブネスタイマーを期限切れになるか、私たちはそれが以前に報告されたものとは異なるられたGenIDを報告し、現在の勝者からHelloメッセージを受信します。これは、現在の勝者のインタフェースやルータがダウンした（と戻って来たかもしれない）ことを示している、と私たちは、それはもはや、それは勝者だった知っていると仮定してはなりません。我々は、（*、G）アサート情報（アクションA5）を削除、NoInfo状態に遷移します。"
    },
    {
      "indent": 5,
      "text": "AssertTrackingDesired(*,G,I)->FALSE AssertTrackingDesired(*,G,I) becomes FALSE. Our forwarding state has changed so that (*,G) Asserts on interface I are no longer of interest to us. We transition to NoInfo state and delete this (*,G) assert info (Actions A5).",
      "ja": "AssertTrackingDesired（*、G、I） - > FALSE AssertTrackingDesired（*、G、I）はFALSEになります。ことは、（*、G）が、私はもはや私たちに関心のあるインターフェイスでアサートので、私たちの転送状態が変更されました。私たちは、NoInfo状態に遷移し、（*、G）をアサート情報（アクションA5）これを削除します。"
    },
    {
      "indent": 5,
      "text": "My metric becomes better than the assert winner's metric My routing metric, rpt_assert_metric(G,I), has changed so that now my assert metric for (*,G) is better than the metric we have stored for current assert winner. We transition to NoInfo state, delete this (*,G) assert state (Actions A5), and allow the normal PIM Join/Prune mechanisms to operate. Usually, we will eventually re-assert and win when data packets for G have started flowing again.",
      "ja": "私のメトリックがアサート勝者のメトリックマイルーティングメトリック、rpt_assert_metric（G、I）よりも良くなる、（*、G）のためになるように、今、私のアサートメトリックを変更した私たちは、現在のアサート勝者のために保存されているメトリックよりも優れています。私たちは、NoInfo状態に移行し、（*、G）は状態（アクションA5）をアサートし、通常のPIMが動作するように/プルーンのメカニズムに参加できるように、これを削除します。通常、我々は最終的にアサートを再とGのためのデータパケットが再び流れ始めた時に獲得します。"
    },
    {
      "indent": 5,
      "text": "RPF_interface(RP(G)) stops being interface I Interface I used to be the RPF interface for RP(G), and now it is not. We transition to NoInfo state and delete this (*,G) assert state (Actions A5).",
      "ja": "RPF_interface（RP（G））は私はRP（G）のためのRPFインターフェイスであることが使用されるインターフェースであるインターフェースを停止し、今ではありません。私たちは、NoInfo状態に遷移し、（*、G）をアサート状態（アクションA5）これを削除します。"
    },
    {
      "indent": 5,
      "text": "Receive Join(*,G) or Join(*,*,RP(G)) on interface I We receive a Join(*,G) or a Join(*,*,RP(G)) that has the Upstream Neighbor Address field set to my primary IP address on interface I. The action is to transition to NoInfo state, delete this (*,G) assert state (Actions A5), and allow the normal PIM Join/Prune mechanisms to operate. If whoever sent the Join was in error, then the normal assert mechanism will eventually re-apply, and we will lose the assert again. However, whoever sent the assert may know that the previous assert winner has died, so we may end up being the new forwarder.",
      "ja": "（*、*、RP（G））インターフェイス上で、私は我々が受け取る（*、G）に参加受信または参加しよう（*、G）または参加（*、*、RP（G））上流隣接アドレスを持っていますインターフェイスI.行動に私のプライマリIPアドレスに設定フィールドは、NoInfo状態に遷移この（*、G）をアサート状態（アクションA5）を削除し、通常のPIMは/動作するようにプルーンのメカニズムに参加できるようにすることです。誰でも参加を送ってもエラーにあった場合は、通常のアサートメカニズムは、最終的に再適用されます、そして我々は再びアサートを失うことになります。しかし、誰が以前アサート勝者が亡くなったことを知っている可能性がありアサートを送ったので、私たちは新しいフォワーダになってしまうことがあります。"
    },
    {
      "indent": 3,
      "text": "(*,G) Assert State machine Actions",
      "ja": "（*、G）アサートステートマシンのアクション"
    },
    {
      "indent": 5,
      "text": "A1: Send Assert(*,G). Set Assert Timer to (Assert_Time - Assert_Override_Interval). Store self as AssertWinner(*,G,I). Store rpt_assert_metric(G,I) as AssertWinnerMetric(*,G,I).",
      "ja": "A1：アサート（*、G）を送信します。 （ -  Assert_Override_Interval Assert_Time）にアサートタイマーを設定します。 AssertWinner（*、G、I）としてストアセルフ。店舗rpt_assert_metric AssertWinnerMetricとして（G、I）（*、G、I）。"
    },
    {
      "indent": 5,
      "text": "A2: Store new assert winner as AssertWinner(*,G,I) and assert winner metric as AssertWinnerMetric(*,G,I). Set Assert Timer to Assert_Time.",
      "ja": "A2：ストアAssertWinnerなどの新しいアサート勝者（*、G、I）AssertWinnerMetricとしてメトリックと主張勝者（*、G、I）。 Assert_Timeにアサートタイマーを設定します。"
    },
    {
      "indent": 5,
      "text": "A3: Send Assert(*,G) Set Assert Timer to (Assert_Time - Assert_Override_Interval).",
      "ja": "A3：（Assert_Time  -  Assert_Override_Interval）にアサート（*、G）の設定アサートタイマーを送信します。"
    },
    {
      "indent": 5,
      "text": "A4: Send AssertCancel(*,G). Delete assert info (AssertWinner(*,G,I) and AssertWinnerMetric(*,G,I) will then return their default values).",
      "ja": "A4：AssertCancel（*、G）を送信します。 （AssertWinner（*、G、I）とAssertWinnerMetric（*、G、I）はその後、それらのデフォルト値を返します）の情報をアサート削除します。"
    },
    {
      "indent": 5,
      "text": "A5: Delete assert info (AssertWinner(*,G,I) and AssertWinnerMetric(*,G,I) will then return their default values).",
      "ja": "A5：削除（AssertWinner（*、Gは、I）とAssertWinnerMetric（*、G、I）は、その後、それらのデフォルト値を返します）の情報を主張。"
    },
    {
      "indent": 3,
      "text": "Note that some of these actions may cause the value of JoinDesired(*,G) or RPF'(*,G)) to change, which could cause further transitions in other state machines.",
      "ja": "これらのアクションのいくつかはJoinDesired（*、G）またはRPF '（*、G））の値が他のステートマシンの更なる遷移を引き起こす可能性があり、変化させることがあります。"
    },
    {
      "indent": 0,
      "text": "4.6.3. Assert Metrics",
      "section_title": true,
      "ja": "4.6.3。メトリックをアサート"
    },
    {
      "indent": 3,
      "text": "Assert metrics are defined as:",
      "ja": "アサートメトリックは、以下のように定義されています。"
    },
    {
      "indent": 5,
      "text": "struct assert_metric {\n  rpt_bit_flag;\n  metric_preference;\n  route_metric;\n  ip_address;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When comparing assert_metrics, the rpt_bit_flag, metric_preference, and route_metric field are compared in order, where the first lower value wins. If all fields are equal, the primary IP address of the router that sourced the Assert message is used as a tie-breaker, with the highest IP address winning.",
      "ja": "assert_metricsを比較すると、rpt_bit_flag、metric_preference、及びroute_metricフィールドは、最初の低い値が勝つために比較されます。すべてのフィールドが等しい場合、アサートメッセージをソースルータのプライマリIPアドレスが最上位IPアドレスが勝利で、タイブレーカとして使用されます。"
    },
    {
      "indent": 3,
      "text": "An assert metric for (S,G) to include in (or compare against) an Assert message sent on interface I should be computed using the following pseudocode:",
      "ja": "（S、G）のためのアサートメトリックは、私は、次の擬似コードを使用して計算されなければならないインターフェイス上で送信されたアサートメッセージに含める（又はと比較）します。"
    },
    {
      "indent": 5,
      "text": "assert_metric my_assert_metric(S,G,I) { if( CouldAssert(S,G,I) == TRUE ) { return spt_assert_metric(S,I) } else if( CouldAssert(*,G,I) == TRUE ) { return rpt_assert_metric(G,I) } else { return infinite_assert_metric() } }",
      "ja": "assert_metric my_assert_metric（S、G、I）{IF（CouldAssert（S、G、I）== TRUE）{spt_assert_metric返す（S、I）}もしそうでなければ（CouldAssert（*、G、I）== TRUE）{リターンrpt_assert_metric他（G、I）}は{}}）（infinite_assert_metric返します"
    },
    {
      "indent": 3,
      "text": "spt_assert_metric(S,I) gives the assert metric we use if we're sending an assert based on active (S,G) forwarding state:",
      "ja": "我々は、アクティブ（S、G）転送状態に基づいてアサートを送信している場合spt_assert_metric（S、I）は、我々が使用アサートメトリックを与えます："
    },
    {
      "indent": 5,
      "text": "assert_metric spt_assert_metric(S,I) { return {0,MRIB.pref(S),MRIB.metric(S),my_ip_address(I)} }",
      "ja": "assert_metric spt_assert_metric（S、I）{リターン{0、MRIB.pref（S）、MRIB.metric（S）、my_ip_address（I）}}"
    },
    {
      "indent": 3,
      "text": "rpt_assert_metric(G,I) gives the assert metric we use if we're sending an assert based only on (*,G) forwarding state:",
      "ja": "我々は唯一の（*、G）転送状態に基づいてアサートを送信している場合rpt_assert_metric（G、I）は、我々が使用アサートメトリックを与えます："
    },
    {
      "indent": 5,
      "text": "assert_metric rpt_assert_metric(G,I) { return {1,MRIB.pref(RP(G)),MRIB.metric(RP(G)),my_ip_address(I)} }",
      "ja": "assert_metric rpt_assert_metric（G、I）{リターン{1、MRIB.pref（RP（G））、MRIB.metric（RP（G））、my_ip_address（I）}}"
    },
    {
      "indent": 3,
      "text": "MRIB.pref(X) and MRIB.metric(X) are the routing preference and routing metrics associated with the route to a particular (unicast) destination X, as determined by the MRIB. my_ip_address(I) is simply the router's primary IP address that is associated with the local interface I.",
      "ja": "MRIB.pref（X）とMRIB.metric（X）はMRIBによって決定されるように、特定の（ユニキャスト）宛先Xまでの経路に関連付けられたルーティング選好とルーティングメトリックです。 my_ip_address（I）は、単にローカルインタフェースI.に関連付けられているルータのプライマリIPアドレスです"
    },
    {
      "indent": 3,
      "text": "infinite_assert_metric() gives the assert metric we need to send an assert but don't match either (S,G) or (*,G) forwarding state:",
      "ja": "infinite_assert_metricは（）私たちはアサートを送信する必要がありますが、どちらかの（S、G）または（*、G）転送状態と一致しないアサートメトリックを与えます："
    },
    {
      "indent": 5,
      "text": "assert_metric infinite_assert_metric() { return {1,infinity,infinity,0} }",
      "ja": "assert_metric infinite_assert_metric（）{リターン{1、無限大、無限大、0}}"
    },
    {
      "indent": 0,
      "text": "4.6.4. AssertCancel Messages",
      "section_title": true,
      "ja": "4.6.4。 AssertCancelメッセージ"
    },
    {
      "indent": 3,
      "text": "An AssertCancel message is simply an RPT Assert message but with infinite metric. It is sent by the assert winner when it deletes the forwarding state that had caused the assert to occur. Other routers will see this metric, and it will cause any other router that has forwarding state to send its own assert, and to take over forwarding.",
      "ja": "AssertCancelメッセージは単にRPTアサートメッセージですが、無限のメトリックを持ちます。それはそれはアサートを発生させていた転送状態を削除アサート勝者によって送られます。他のルータは、このメトリックが表示され、それは自身のアサートを送信するために状態を転送している他のルータの原因となりますし、転送を引き継ぐために。"
    },
    {
      "indent": 3,
      "text": "An AssertCancel(S,G) is an infinite metric assert with the RPT bit set that names S as the source.",
      "ja": "AssertCancel（S、G）は、そのソースとして名S RPTビットが設定された無限のメトリックアサートあります。"
    },
    {
      "indent": 3,
      "text": "An AssertCancel(*,G) is an infinite metric assert with the RPT bit set and the source set to zero.",
      "ja": "AssertCancel（*、G）をRPTビットセットとゼロに設定ソースと無限メトリックアサートあります。"
    },
    {
      "indent": 3,
      "text": "AssertCancel messages are simply an optimization. The original Assert timeout mechanism will allow a subnet to eventually become consistent; the AssertCancel mechanism simply causes faster convergence. No special processing is required for an AssertCancel message, since it is simply an Assert message from the current winner.",
      "ja": "AssertCancelメッセージは単純に最適化されています。オリジナルのアサートタイムアウトメカニズムは、サブネットは、最終的に一貫性になることができます。 AssertCancelメカニズムは、単により速い収束が発生します。それは単に現在の勝者からのAssertメッセージであるため、特別な処理は、AssertCancelメッセージのために必要とされません。"
    },
    {
      "indent": 0,
      "text": "4.6.5. Assert State Macros",
      "section_title": true,
      "ja": "4.6.5。国家マクロをアサート"
    },
    {
      "indent": 3,
      "text": "The macros lost_assert(S,G,rpt,I), lost_assert(S,G,I), and lost_assert(*,G,I) are used in the olist computations of Section 4.1, and are defined as:",
      "ja": "マクロlost_assert（S、G、RPT、I）、lost_assert（S、G、I）、及びlost_assert（*、G、I）は、セクション4.1のOLIST計算に使用され、のように定義されます。"
    },
    {
      "indent": 5,
      "text": "bool lost_assert(S,G,rpt,I) { if ( RPF_interface(RP(G)) == I OR ( RPF_interface(S) == I AND SPTbit(S,G) == TRUE ) ) { return FALSE } else { return ( AssertWinner(S,G,I) != NULL AND AssertWinner(S,G,I) != me ) } }",
      "ja": "BOOL lost_assert（S、G、RPT、I）{IF（RPF_interface（RP（G））== I OR（RPF_interface（S）== I AND SPTbit（S、G）== TRUE））を{}そうでなければFALSEを返します{リターン（AssertWinner（S、G、I）！= NULL AND AssertWinner（S、G、I）！=私）}}"
    },
    {
      "indent": 5,
      "text": "bool lost_assert(S,G,I) { if ( RPF_interface(S) == I ) { return FALSE } else { return ( AssertWinner(S,G,I) != NULL AND AssertWinner(S,G,I) != me AND (AssertWinnerMetric(S,G,I) is better than spt_assert_metric(S,I) ) } }",
      "ja": "ブールlost_assert（S、G、I）{IF（RPF_interface（S）== I）{FALSEを返す}他{リターン（AssertWinner（S、G、I）！= NULL AND AssertWinner（S、G、I）！=私AND（AssertWinnerMetric（S、G、I）はspt_assert_metric（Sよりも優れている、I））}}"
    },
    {
      "indent": 3,
      "text": "Note: the term \"AssertWinnerMetric(S,G,I) is better than spt_assert_metric(S,I)\" is required to correctly handle the transition phase when a router has (S,G) join state, but has not yet set the SPT bit. In this case, it needs to ignore the assert state if it will win the assert once the SPTbit is set.",
      "ja": "注意：用語を正しくルータは（S、G）状態が参加している移行期を処理するために必要とされる「AssertWinnerMetric（S、G、I）が（私はS）spt_assert_metricよりも優れている」、まだSPT設定していませんビット。この場合、それはSPTbitが設定されると、それはアサートを獲得する場合はアサート状態を無視する必要があります。"
    },
    {
      "indent": 5,
      "text": "bool lost_assert(*,G,I) { if ( RPF_interface(RP(G)) == I ) { return FALSE } else { return ( AssertWinner(*,G,I) != NULL AND AssertWinner(*,G,I) != me ) } }",
      "ja": "ブールlost_assert（*、G、I）{場合（RPF_interface（RP（G））== I）{FALSEを返す}他{リターン（AssertWinner（*、G、I）！= NULL AND AssertWinner（*、G、I ）！=私）}}"
    },
    {
      "indent": 3,
      "text": "AssertWinner(S,G,I) is the IP source address of the Assert(S,G) packet that won an Assert.",
      "ja": "AssertWinner（S、G、I）がアサートを獲得したのAssert（S、G）パケットのIP送信元アドレスです。"
    },
    {
      "indent": 3,
      "text": "AssertWinner(*,G,I) is the IP source address of the Assert(*,G) packet that won an Assert.",
      "ja": "AssertWinner（*、G、I）のAssertを獲得したアサート（*、G）パケットのIP送信元アドレスです。"
    },
    {
      "indent": 3,
      "text": "AssertWinnerMetric(S,G,I) is the Assert metric of the Assert(S,G) packet that won an Assert.",
      "ja": "AssertWinnerMetric（S、G、I）がアサートを獲得アサート（S、G）パケットのアサートメトリックです。"
    },
    {
      "indent": 3,
      "text": "AssertWinnerMetric(*,G,I) is the Assert metric of the Assert(*,G) packet that won an Assert.",
      "ja": "AssertWinnerMetric（*、G、I）はアサートを獲得したアサート（*、G）パケットのアサートメトリックです。"
    },
    {
      "indent": 3,
      "text": "AssertWinner(S,G,I) defaults to NULL and AssertWinnerMetric(S,G,I) defaults to Infinity when in the NoInfo state.",
      "ja": "AssertWinner（S、G、I）デフォルト値はNULLとNoInfo状態で無限にAssertWinnerMetric（S、G、I）デフォルトに。"
    },
    {
      "indent": 3,
      "text": "Summary of Assert Rules and Rationale",
      "ja": "アサートルールと理論的根拠の概要"
    },
    {
      "indent": 3,
      "text": "This section summarizes the key rules for sending and reacting to asserts and the rationale for these rules. This section is not intended to be and should not be treated as a definitive specification of protocol behavior. The state machines and pseudocode should be consulted for that purpose. Rather, this section is intended to document important aspects of the Assert protocol behavior and to provide information that may prove helpful to the reader in understanding and implementing this part of the protocol.",
      "ja": "このセクションでは、送信と主張すると、これらの規則の根拠に反応させるためのキーのルールをまとめました。このセクションでは、であることが意図されておらず、プロトコル動作の決定的な仕様として扱われるべきではありません。ステートマシンと擬似コードは、その目的のために相談する必要があります。むしろ、このセクションはアサートプロトコルの動作の重要な側面を文書化し、理解とプロトコルのこの部分を実装するには、読者に役立つことを証明する情報を提供することを意図しています。"
    },
    {
      "indent": 3,
      "text": "1. Behavior: Downstream neighbors send Join(*,G) and Join(S,G) periodic messages to the appropriate RPF' neighbor, i.e., the RPF neighbor as modified by the assert process. They are not always sent to the RPF neighbor as indicated by the MRIB. Normal suppression and override rules apply.",
      "ja": "1.動作下流隣人（* G）に参加し、適切なRPF」隣接、アサートプロセスによって修正され、すなわち、RPF隣人に（S、G）定期的なJoinメッセージを送信します。 MRIBによって示されるように、彼らは常にRPFネイバーに送信されていません。通常の抑制とオーバーライドのルールが適用されます。"
    },
    {
      "indent": 7,
      "text": "Rationale: By sending the periodic and triggered Join messages to\nthe RPF' neighbor instead of to the RPF neighbor, the downstream\nrouter avoids re-triggering the Assert process with every Join.\nA side effect of sending Joins to the Assert winner is that\ntraffic will not switch back to the \"normal\" RPF neighbor until\nthe Assert times out.  This will not happen until data stops\nflowing, if item 8, below, is implemented.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. Behavior: The assert winner for (*,G) acts as the local DR for (*,G) on behalf of IGMP/MLD members.",
      "ja": "2.動作：（*、G）のためのアサート勝者はIGMP / MLD部材の代わりに（*、G）のための局所DRとして働きます。"
    },
    {
      "indent": 7,
      "text": "Rationale: This is required to allow a single router to merge PIM\nand IGMP/MLD joins and leaves.  Without this, overrides don't\nwork.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. Behavior: The assert winner for (S,G) acts as the local DR for (S,G) on behalf of IGMPv3 members.",
      "ja": "3.動作：（S、G）のためのアサート勝者は、IGMPv3メンバーの代わりに（S、G）のための局所DRとして働きます。"
    },
    {
      "indent": 7,
      "text": "Rationale: Same rationale as for item 2.",
      "ja": "理論的根拠：項目2の場合と同じ原理。"
    },
    {
      "indent": 3,
      "text": "4. Behavior: (S,G) and (*,G) prune overrides are sent to the RPF' neighbor and not to the regular RPF neighbor.",
      "ja": "4.行動：（S、G）および（*、G）プルーンオーバーライドは、RPF」隣人にしていない通常のRPFネイバーに送信されます。"
    },
    {
      "indent": 7,
      "text": "Rationale: Same rationale as for item 1.",
      "ja": "理論的根拠：項目1の場合と同じ原理。"
    },
    {
      "indent": 3,
      "text": "5. Behavior: An (S,G,rpt) prune override is not sent (at all) if RPF'(S,G,rpt) != RPF'(*,G).",
      "ja": "5.行動：RPF '！（S、G、RPT）= RPF'（*、G）場合には（S、G、RPT）プルーンオーバーライドは（すべてで）送信されません。"
    },
    {
      "indent": 7,
      "text": "Rationale: This avoids keeping state alive on the (S,G) tree when\nonly (*,G) downstream members are left.  Also, it avoids sending\n(S,G,rpt) joins to a router that is not on the (*,G) tree.  This\nbehavior might be confusing although this specification does\nindicate that such a join should be dropped.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6. Behavior: An assert loser that receives a Join(S,G) with an Upstream Neighbor Address that is its primary IP address on that interface cancels the (S,G) Assert Timer.",
      "ja": "6.行動：そのインターフェイス上のプライマリIPアドレスが（S、G）をアサート解除タイマである上流隣接アドレスに（S、G）に参加受信アサート敗者。"
    },
    {
      "indent": 7,
      "text": "Rationale: This is necessary in order to have rapid convergence\nin the event that the downstream router that initially sent a\njoin to the prior Assert winner has undergone a topology change.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7. Behavior: An assert loser that receives a Join(*,G) or a Join(*,*,RP(G)) with an Upstream Neighbor Address that is its primary IP address on that interface cancels the (*,G) Assert Timer and all (S,G) assert timers that do not have corresponding Prune(S,G,rpt) messages in the compound Join/Prune message.",
      "ja": "7.行動：参加（*、G）または（*、*、RP（G））そのインターフェイス上のプライマリIPアドレスをある上流隣接アドレスとは、（*、G）Joinを受信キャンセルアサート敗者アサートタイマー及び全て（S、G）は、化合物/プルーンメッセージを参加に対応するプルーン（S、G、RPT）を持っていないタイマメッセージをアサートします。"
    },
    {
      "indent": 7,
      "text": "Rationale: Same rationale as for item 6.",
      "ja": "理論的根拠：項目6の場合と同じ原理。"
    },
    {
      "indent": 3,
      "text": "8. Behavior: An assert winner for (*,G) or (S,G) sends a canceling assert when it is about to stop forwarding on a (*,G) or an (S,G) entry. This behavior does not apply to (S,G,rpt).",
      "ja": "8.動作：（*、G）に転送または（S、G）エントリを停止しようとしている場合のアサート勝者（*、G）または（S、G）はキャンセルアサートを送信します。この動作は、（S、G、RPT）には適用されません。"
    },
    {
      "indent": 7,
      "text": "Rationale: This allows switching back to the shared tree after\nthe last SPT router on the LAN leaves.  Doing this prevents\ndownstream routers on the shared tree from keeping SPT state\nalive.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "9. Behavior: Resend the assert messages before timing out an assert. (This behavior is optional.)",
      "ja": "9.行動：アサートをタイムアウトするまでのassertメッセージを再送信します。 （この動作はオプションです。）"
    },
    {
      "indent": 7,
      "text": "Rationale: This prevents the periodic duplicates that would\notherwise occur each time that an assert times out and is then\nre-established.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "10. Behavior: When RPF'(S,G,rpt) changes to be the same as RPF'(*,G) we need to trigger a Join(S,G,rpt) to RPF'(*,G).",
      "ja": "10.行動：RPF '（S、G、RPT）の変更はRPFと同じになるように'（*、G）は、我々はRPFに（S、G、RPT） '（*、G）が参加トリガする必要があります。"
    },
    {
      "indent": 7,
      "text": "Rationale: This allows switching back to the RPT after the last\nSPT member leaves.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.7. PIM Bootstrap and RP Discovery",
      "section_title": true,
      "ja": "4.7。 PIMブートストラップおよびRPディスカバリー"
    },
    {
      "indent": 3,
      "text": "For correct operation, every PIM router within a PIM domain must be able to map a particular multicast group address to the same RP. If this is not the case, then black holes may appear, where some receivers in the domain cannot receive some groups. A domain in this context is a contiguous set of routers that all implement PIM and are configured to operate within a common boundary.",
      "ja": "正しい動作のためには、PIMドメイン内のすべてのPIMルータが同じRPに特定のマルチキャストグループアドレスをマッピングすることができなければなりません。そうでない場合、次いで、ブラックホールは、ドメイン内のいくつかの受信機がいくつかのグループを受信することができない場合、表示されてもよいです。この文脈でのドメインは、すべてのPIMを実装し、共通の境界内で動作するように設定されているルータの連続したセットです。"
    },
    {
      "indent": 3,
      "text": "A notable exception to this is where a PIM domain is broken up into multiple administrative scope regions; these are regions where a border has been configured so that a range of multicast groups will not be forwarded across that border. For more information on Administratively Scoped IP Multicast, see RFC 2365. The modified criteria for admin-scoped regions are that the region is convex with respect to forwarding based on the MRIB, and that all PIM routers within the scope region map scoped groups to the same RP within that region.",
      "ja": "PIMドメインが複数の管理範囲の領域に分割される場合、これに注目すべき例外です。これらは、マルチキャストグループの範囲はその境界を横切って転送されないように境界が設定されている領域です。管理スコープのIPマルチキャストの詳細については、RFC管理スコープ領域についての修正基準2365は、領域はMRIBに基づいて転送に対して凸状であること、参照、および範囲領域マップ内のすべてのPIMルータは、にグループをスコープことその領域内の同じRP。"
    },
    {
      "indent": 3,
      "text": "This specification does not mandate the use of a single mechanism to provide routers with the information to perform the group-to-RP mapping. Currently four mechanisms are possible, and all four have associated problems:",
      "ja": "この仕様は、グループ・ツー・RPマッピングを実行するための情報を、ルータを提供するために、単一のメカニズムの使用を強制しません。現在、4つの機構が可能であり、4つのすべての関連する問題があります。"
    },
    {
      "indent": 3,
      "text": "Static Configuration A PIM router MUST support the static configuration of group-to-RP mappings. Such a mechanism is not robust to failures, but does at least provide a basic interoperability mechanism.",
      "ja": "静的構成A PIMルータは、グループ-RPマッピングの静的な構成をサポートしなければなりません。このようなメカニズムは、障害に対して堅牢ではありませんが、少なくとも基本的な相互運用性のメカニズムを提供しません。"
    },
    {
      "indent": 3,
      "text": "Embedded-RP Embedded-RP defines an address allocation policy in which the address of the Rendezvous Point (RP) is encoded in an IPv6 multicast group address [17].",
      "ja": "組み込みRP埋め込み-RPは、ランデブーポイント（RP）のアドレスがIPv6マルチキャストグループアドレス[17]で符号化されたアドレス割り当てポリシーを定義します。"
    },
    {
      "indent": 3,
      "text": "Cisco's Auto-RP Auto-RP uses a PIM Dense-Mode multicast group to announce group-to-RP mappings from a central location. This mechanism is not useful if PIM Dense-Mode is not being run in parallel with PIM Sparse-Mode, and was only intended for use with PIM Sparse-Mode Version 1. No standard specification currently exists.",
      "ja": "シスコのAuto-RP Auto-RPは中央の場所からグループ-RPマッピングを発表するPIMデンスモードマルチキャストグループを使用しています。 PIM denseモードは、PIMスパースモードと並行して実行されていない、とだけPIMスパースモードバージョン1の標準的な仕様は、現在、存在しないで使用するために意図されていた場合には、このメカニズムは有用ではありません。"
    },
    {
      "indent": 3,
      "text": "BootStrap Router (BSR) RFC 2362 specifies a bootstrap mechanism based on the automatic election of a bootstrap router (BSR). Any router in the domain that is configured to be a possible RP reports its candidacy to the BSR, and then a domain-wide flooding mechanism distributes the BSR's chosen set of RPs throughout the domain. As specified in RFC 2362, BSR is flawed in its handling of admin-scoped regions that are smaller than a PIM domain, but the mechanism does work for global-scoped groups.",
      "ja": "ブートストラップルータ（BSR）RFC 2362には、ブートストラップルータ（BSR）の自動選挙に基づくブートストラップメカニズムを指定します。可能RPなるように構成されているドメイン内の任意のルータはBSRへの立候補を報告し、その後、ドメイン全体の氾濫メカニズムは、ドメイン全体のRPのBSRの選択したセットを配布しています。 RFC 2362で指定されているように、BSRはPIMドメインよりも小さい管理スコープの地域のその取り扱いに欠陥があるが、メカニズムは、グローバルスコープのグループのための作業を行います。"
    },
    {
      "indent": 3,
      "text": "As far as PIM-SM is concerned, the only important requirement is that all routers in the domain (or admin scope zone for scoped regions) receive the same set of group-range-to-RP mappings. This may be achieved through the use of any of these mechanisms, or through alternative mechanisms not currently specified.",
      "ja": "限りPIM-SMに関しては、唯一の重要な要件は、ドメイン（またはスコープ領域について管理範囲ゾーン）内のすべてのルータは、グループ範囲ツーRPマッピングの同じセットを受け取ることです。これは、これらのメカニズムのいずれかを使用して達成、または代替の機構を介して、現在指定されていないことができます。"
    },
    {
      "indent": 3,
      "text": "It must be operationally ensured that any RP address configured, learned, or advertised is reachable from all routers in the PIM domain.",
      "ja": "運用上のPIMドメイン内のすべてのルータから到達可能であるよう構成された任意のRPアドレスは、学んだことを保証し、または宣伝する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.7.1. Group-to-RP Mapping",
      "section_title": true,
      "ja": "4.7.1。グループツーRPのマッピング"
    },
    {
      "indent": 3,
      "text": "Using one of the mechanisms described above, a PIM router receives one or more possible group-range-to-RP mappings. Each mapping specifies a range of multicast groups (expressed as a group and mask) and the RP to which such groups should be mapped. Each mapping may also have an associated priority. It is possible to receive multiple mappings, all of which might match the same multicast group; this is the common case with BSR. The algorithm for performing the group-to-RP mapping is as follows:",
      "ja": "上記のメカニズムのいずれかを使用して、PIMルータは、一つ以上の可能なグループ範囲ツーRPマッピングを受け取ります。各マッピングは、マルチキャストグループ（グループとマスクとして表される）と、そのようなグループがマッピングすべきRPの範囲を指定します。各マッピングは、関連する優先度を有していてもよいです。同一のマルチキャストグループに一致する可能性のあるすべてのそれらの複数のマッピングを、受信することが可能です。これはBSRと一般的なケースです。次のようにグループ-RPマッピングを実行するためのアルゴリズムは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Perform longest match on group-range to obtain a list of RPs.",
      "section_title": true,
      "ja": "1のRPのリストを取得するために、グループ範囲に最長一致を実行します。"
    },
    {
      "indent": 3,
      "text": "2. From this list of matching RPs, find the one with highest priority. Eliminate any RPs from the list that have lower priorities.",
      "ja": "マッチングのRPのこのリスト2.、最も優先度の高いものを見つけます。下の優先順位を持つリストから任意のRPを排除します。"
    },
    {
      "indent": 3,
      "text": "3. If only one RP remains in the list, use that RP.",
      "section_title": true,
      "ja": "3.唯一のRPは、RPを使用し、リスト内に残っている場合。"
    },
    {
      "indent": 3,
      "text": "4. If multiple RPs are in the list, use the PIM hash function to choose one.",
      "ja": "4.複数のRPは、いずれかを選択するPIMハッシュ関数を使用して、リストにある場合。"
    },
    {
      "indent": 3,
      "text": "Thus, if two or more group-range-to-RP mappings cover a particular group, the one with the longest mask is the mapping to use. If the mappings have the same mask length, then the one with the highest priority is chosen. If there is more than one matching entry with the same longest mask and the priorities are identical, then a hash function (see Section 4.7.2) is applied to choose the RP.",
      "ja": "二つ以上のグループ範囲ツーRPマッピングが特定のグループをカバーする場合したがって、最長のマスクを有するものは、使用するマッピングです。マッピングが同じマスク長を持っている場合は、最も優先順位の高いものが選択されています。最長同じマスクと優先度が同じである場合、ハッシュ関数を持つ複数の一致するエントリが存在する場合（セクション4.7.2を参照）RPを選択するために適用されます。"
    },
    {
      "indent": 3,
      "text": "This algorithm is invoked by a DR when it needs to determine an RP for a given group, e.g., upon reception of a packet or IGMP/MLD membership indication for a group for which the DR does not know the",
      "ja": "このアルゴリズムは、それがDRを知らないするグループのためのパケット又はIGMP / MLDメンバーシップ指示を受信すると、例えば、特定のグループのためのRPを決定する必要がDRによって呼び出され"
    },
    {
      "indent": 3,
      "text": "RP. It is invoked by any router that has (*,*,RP) state when a packet is received for which there is no corresponding (S,G) or (*,G) entry. Furthermore, the mapping function is invoked by all routers upon receiving a (*,G) or (*,*,RP) Join/Prune message.",
      "ja": "RP。これは、パケットが該当する（S、G）または（*、G）エントリが存在しないいる受信されたとき（*、*、RP）状態を有する任意のルータによって呼び出されます。さらに、マッピング関数は（*、G）または（*、*、RP）/プルーンメッセージを参加を受信するすべてのルータによって呼び出されます。"
    },
    {
      "indent": 3,
      "text": "Note that if the set of possible group-range-to-RP mappings changes, each router will need to check whether any existing groups are affected. This may, for example, cause a DR or acting DR to re-join a group, or cause it to restart register encapsulation to the new RP.",
      "ja": "可能なグループ範囲-RPマッピングの変更のセットならば、各ルータは、既存のグループが影響を受けているかどうかを確認する必要があることに注意してください。これは、例えば、DRや演技DRが再グループに参加させ、またはそれが新しいRPにカプセル化を登録し、再起動する場合があります。"
    },
    {
      "indent": 5,
      "text": "Implementation note: the bootstrap mechanism described in RFC 2362 omitted step 1 above. However, of the implementations we are aware of, approximately half performed step 1 anyway. Note that implementations of BSR that omit step 1 will not correctly interoperate with implementations of this specification when used with the BSR mechanism described in [11].",
      "ja": "実装注：上記の手順1を省略RFC 2362に記載されたブートストラップ機構。しかし、私たちが知っているの実装で、約半分とにかくステップ1を行いました。 [11]に記載のBSR機構を使用した場合、ステップ1を省略BSRの実装が正確にこの仕様の実装と相互運用しないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.7.2. Hash Function",
      "section_title": true,
      "ja": "4.7.2。ハッシュ関数"
    },
    {
      "indent": 3,
      "text": "The hash function is used by all routers within a domain, to map a group to one of the RPs from the matching set of group-range-to-RP mappings (this set all have the same longest mask length and same highest priority). The algorithm takes as input the group address, and the addresses of the candidate RPs from the mappings, and gives as output one RP address to be used.",
      "ja": "ハッシュ関数は、グループレンジツーRPマッピング（このセットは、全て同じ最長のマスク長と同じ最高優先度を有する）のマッチングセットからのRPのいずれかのグループをマッピングするために、ドメイン内のすべてのルータによって使用されます。このアルゴリズムは、入力として、グループアドレス、およびマッピングからの候補RPのアドレスを取得し、使用するために、出力1つのRPアドレスとして提供します。"
    },
    {
      "indent": 3,
      "text": "The protocol requires that all routers hash to the same RP within a domain (except for transients). The following hash function must be used in each router:",
      "ja": "プロトコルは、すべてのルータが（トランジェントを除く）ドメイン内の同じRPにハッシュことが必要です。以下のハッシュ関数は、各ルータで使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. For RP addresses in the matching group-range-to-RP mappings, compute a value:",
      "ja": "マッチンググループレンジツーRPマッピングにおけるRPアドレスについて1は、値を計算します。"
    },
    {
      "indent": 3,
      "text": "Value(G,M,C(i))= (1103515245 * ((1103515245 * (G&M)+12345) XOR C(i)) + 12345) mod 2^31",
      "ja": "値（G、M、C（I））=（1103515245 *（（1103515245 *（G＆M）12345）XOR C（I））+ 12345）MOD 2 ^ 31"
    },
    {
      "indent": 7,
      "text": "where C(i) is the RP address and M is a hash-mask.  If BSR is\nbeing used, the hash-mask is given in the Bootstrap messages.  If\nBSR is not being used, the alternative mechanism that supplies\nthe group-range-to-RP mappings may supply the value, or else it\ndefaults to a mask with the most significant 30 bits being one\nfor IPv4 and the most significant 126 bits being one for IPv6.\nThe hash-mask allows a small number of consecutive groups (e.g.,\n4) to always hash to the same RP.  For instance, hierarchically-\nencoded data can be sent on consecutive group addresses to get\nthe same delay and fate-sharing characteristics.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "For address families other than IPv4, a 32-bit digest to be used as C(i) and G must first be derived from the actual RP or group address. Such a digest method must be used consistently throughout the PIM domain. For IPv6 addresses, we recommend using the equivalent IPv4 address for an IPv4-compatible address, and the exclusive-or of each 32-bit segment of the address for all other IPv6 addresses. For example, the digest of the IPv6 address 3ffe:b00:c18:1::10 would be computed as 0x3ffe0b00 ^ 0x0c180001 ^ 0x00000000 ^ 0x00000010, where ^ represents the exclusive-or operation.",
      "ja": "IPv4の以外のアドレスファミリーのため、32ビットのC（i）とGとして使用するダイジェスト第1実RPまたはグループアドレスから導出されなければなりません。このようなダイジェストメソッドは、PIMドメイン全体で一貫して使用する必要があります。 IPv6アドレスのために、我々は、IPv4互換アドレスの等価IPv4アドレスを使用して、排他的または他のすべてのIPv6アドレスのアドレスの各32ビット・セグメントのをお勧めします。たとえば、IPv6アドレス3FFEのダイジェスト：B00：C18：1 :: 10は、^は排他的論理和演算を表す^ 0x0c180001 ^ 0x00000000の^ 0x00000010 0x3ffe0b00、として計算されます。"
    },
    {
      "indent": 3,
      "text": "2. The candidate RP with the highest resulting hash value is then the RP chosen by this Hash Function. If more than one RP has the same highest hash value, the RP with the highest IP address is chosen.",
      "ja": "2.最高の結果のハッシュ値を有する候補RPは、このハッシュ関数によって選択されたRPです。複数のRPが同じ最高のハッシュ値を持つ場合、最も高いIPアドレスを持つRPが選択されています。"
    },
    {
      "indent": 0,
      "text": "4.8. Source-Specific Multicast",
      "section_title": true,
      "ja": "4.8。ソース固有マルチキャスト"
    },
    {
      "indent": 3,
      "text": "The Source-Specific Multicast (SSM) service model [6] can be implemented with a strict subset of the PIM-SM protocol mechanisms. Both regular IP Multicast and SSM semantics can coexist on a single router, and both can be implemented using the PIM-SM protocol. A range of multicast addresses, currently 232.0.0.0/8 in IPv4 and FF3x::/32 for IPv6, is reserved for SSM, and the choice of semantics is determined by the multicast group address in both data packets and PIM messages.",
      "ja": "ソース固有マルチキャスト（SSM）サービスモデル[6] PIM-SMプロトコル機構の厳密なサブセットを用いて実施することができます。通常のIPマルチキャストおよびSSM意味論の両方が単一のルータ上に共存することができ、どちらもPIM-SMプロトコルを用いて実現することができます。現在232.0.0.0/8 IPv4およびFF3xにおけるマルチキャストアドレスの範囲、IPv6の:: / 32は、SSMのために予約され、及びセマンティクスの選択は、データパケットおよびPIMメッセージの両方にマルチキャストグループアドレスによって決定されます。"
    },
    {
      "indent": 0,
      "text": "4.8.1. Protocol Modifications for SSM Destination Addresses",
      "section_title": true,
      "ja": "4.8.1。 SSM宛先アドレスのためのプロトコルの変更"
    },
    {
      "indent": 3,
      "text": "The following rules override the normal PIM-SM behavior for a multicast address G in the SSM range:",
      "ja": "以下の規則はSSM範囲内のマルチキャストアドレスGの通常のPIM-SMの動作をオーバーライドします。"
    },
    {
      "indent": 3,
      "text": "o A router MUST NOT send a (*,G) Join/Prune message for any reason.",
      "ja": "Oルータが何らかの理由で（*、G）参加/プルーンのメッセージを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "o A router MUST NOT send an (S,G,rpt) Join/Prune message for any reason.",
      "ja": "Oルータが何らかの理由で/プルーンのメッセージを参加（S、G、RPT）を送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "o A router MUST NOT send a Register message for any packet that is destined to an SSM address.",
      "ja": "Oルータは、SSMアドレスを宛先とするすべてのパケットのためにRegisterメッセージを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "o A router MUST NOT forward packets based on (*,G) or (S,G,rpt) state. The (*,G)- and (S,G,rpt)-related state summarization macros are NULL for any SSM address, for the purposes of packet forwarding.",
      "ja": "Oルータが（*、G）または（S、G、RPT）状態に基づいてパケットを転送してはいけません。 （*、G） - および（S、G、RPTは）関連状態の要約マクロは、パケット転送のために、任意のSSMアドレスに対してNULLです。"
    },
    {
      "indent": 3,
      "text": "o A router acting as an RP MUST NOT forward any Register-encapsulated packet that has an SSM destination address.",
      "ja": "O RPとして動作するルータは、SSM宛先アドレスを持つ任意の登録、カプセル化されたパケットを転送してはなりません。"
    },
    {
      "indent": 3,
      "text": "The last two rules are present to deal with \"legacy\" routers unaware of SSM that may be sending (*,G) and (S,G,rpt) Join/Prunes, or Register messages for SSM destination addresses.",
      "ja": "最後の2つのルールがSSM宛先アドレスのメッセージを（*、G）を送信し、（S、G、RPT）参加/プルーン、または登録することができるSSMを知らない「レガシー」ルータに対処するために存在しています。"
    },
    {
      "indent": 3,
      "text": "Additionally:",
      "ja": "さらに："
    },
    {
      "indent": 3,
      "text": "o A router MAY be configured to advertise itself as a Candidate RP for an SSM address. If so, it SHOULD respond with a Register-Stop message to any Register message containing a packet destined for an SSM address.",
      "ja": "Oルータは、SSMアドレスの候補RPとして自分自身を宣伝するように構成され得ます。そうだとすれば、それはSSMアドレス宛のパケットを含む任意のRegisterメッセージに登録-Stopメッセージで応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "o A router MAY optimize out the creation and maintenance of (S,G,rpt) and (*,G) state for SSM destination addresses -- this state is not needed for SSM packets.",
      "ja": "ルータoをSSM宛先アドレスのために（S、G、RPT）の作成とメンテナンスを最適化し、（*、G）状態かもしれない - この状態は、SSMパケットには必要ありません。"
    },
    {
      "indent": 0,
      "text": "4.8.2. PIM-SSM-Only Routers",
      "section_title": true,
      "ja": "4.8.2。 PIM-SSM専用ルーター"
    },
    {
      "indent": 3,
      "text": "An implementer may choose to implement only the subset of PIM Sparse-Mode that provides SSM forwarding semantics.",
      "ja": "実装者は、SSM転送のセマンティクスを提供PIMスパースモードのサブセットのみを実装することを選択できます。"
    },
    {
      "indent": 3,
      "text": "A PIM-SSM-only router MUST implement the following portions of this specification:",
      "ja": "PIM-SSM-のみのルータは、本明細書の以下の部分を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Upstream (S,G) state machine (Section 4.5.7)",
      "ja": "Oアップストリーム（S、G）ステートマシン（セクション4.5.7）"
    },
    {
      "indent": 3,
      "text": "o Downstream (S,G) state machine (Section 4.5.3)",
      "ja": "ダウンストリーム（S、G）ステートマシンO（4.5.3）"
    },
    {
      "indent": 3,
      "text": "o (S,G) Assert state machine (Section 4.6.1)",
      "ja": "O（S、G）ステートマシンをアサート（4.6.1項）"
    },
    {
      "indent": 3,
      "text": "o Hello messages, neighbor discovery, and DR election (Section 4.3)",
      "ja": "こんにちはOメッセージ、近隣探索、およびDRの選出（4.3節）"
    },
    {
      "indent": 3,
      "text": "o Packet forwarding rules (Section 4.2)",
      "ja": "Oパケット転送ルール（4.2節）"
    },
    {
      "indent": 3,
      "text": "A PIM-SSM-only router does not need to implement the following protocol elements:",
      "ja": "PIM-SSM-のみのルータは、次のプロトコル要素を実装する必要はありません。"
    },
    {
      "indent": 3,
      "text": "o Register state machine (Section 4.4)",
      "ja": "Oステート・マシンを登録します（4.4節）"
    },
    {
      "indent": 3,
      "text": "o (*,G), (S,G,rpt), and (*,*,RP) Downstream state machines (Sections 4.5.2, 4.5.4, and 4.5.1)",
      "ja": "O（*、G）、（S、G、RPT）、および（*、*、RP）ダウンストリームステートマシン（セクション4.5.2、4.5.4および4.5.1）"
    },
    {
      "indent": 3,
      "text": "o (*,G), (S,G,rpt), and (*,*,RP) Upstream state machines (Sections 4.5.6, 4.5.8, and 4.5.5)",
      "ja": "O（*、G）、（S、G、RPT）、および（*、*、RP）アップストリームステートマシン（セクション4.5.6、4.5.8および4.5.5）"
    },
    {
      "indent": 3,
      "text": "o (*,G) Assert state machine (Section 4.6.2)",
      "ja": "O（*、G）ステートマシン（4.6.2）をアサート"
    },
    {
      "indent": 3,
      "text": "o Bootstrap RP Election (Section 4.7)",
      "ja": "OブートストラップRP選挙（4.7節）"
    },
    {
      "indent": 3,
      "text": "o Keepalive Timer",
      "ja": "Oキープアライブタイマー"
    },
    {
      "indent": 3,
      "text": "o SPTbit (Section 4.2.2)",
      "ja": "SPTbit O（4.2.2）"
    },
    {
      "indent": 3,
      "text": "The Keepalive Timer should be treated as always running, and SPTbit should be treated as always being set for an SSM address. Additionally, the Packet forwarding rules of Section 4.2 can be simplified in a PIM-SSM-only router:",
      "ja": "キープアライブタイマーは、常に実行しているとして扱われるべきである、とSPTbitは常にSSMアドレスの設定されているものとして扱われるべきです。また、セクション4.2のパケット転送ルールは、PIM-SSMのみルータに簡略化することができます。"
    },
    {
      "indent": 5,
      "text": "if( iif == RPF_interface(S) AND UpstreamJPState(S,G) == Joined ) { oiflist = inherited_olist(S,G) } else if( iif is in inherited_olist(S,G) ) { send Assert(S,G) on iif }",
      "ja": "（IIF == RPF_interface（S）と上流Upstate社（S、G）==メンバー）もしあれば他{（S、G）OLISTを継承=リストを}（IIFは引き継いでいる_olist（S、G）である）{（アサートを送信IIFにS、G）}"
    },
    {
      "indent": 5,
      "text": "oiflist = oiflist (-) iif forward packet on all interfaces in oiflist",
      "ja": "oiflist = oiflist（ - ）oiflist内のすべてのインターフェイス上でIIF転送パケット"
    },
    {
      "indent": 3,
      "text": "This is nothing more than the reduction of the normal PIM-SM forwarding rule, with all (S,G,rpt) and (*,G) clauses replaced with NULL.",
      "ja": "これは、すべての（S、G、RPT）とNULLに置き換え（*、G）の句と通常のPIM-SMの転送ルールの削減以外の何物でも、ありません。"
    },
    {
      "indent": 0,
      "text": "4.9. PIM Packet Formats",
      "section_title": true,
      "ja": "4.9。 PIMパケット形式"
    },
    {
      "indent": 3,
      "text": "This section describes the details of the packet formats for PIM control messages.",
      "ja": "このセクションでは、PIM制御メッセージのパケットフォーマットの詳細について説明します。"
    },
    {
      "indent": 3,
      "text": "All PIM control messages have IP protocol number 103.",
      "ja": "すべてのPIMコントロールメッセージは、IPプロトコル番号103を持っています。"
    },
    {
      "indent": 3,
      "text": "PIM messages are either unicast (e.g., Registers and Register-Stop) or multicast with TTL 1 to the 'ALL-PIM-ROUTERS' group (e.g., Join/Prune, Asserts, etc.). The source address used for unicast messages is a domain-wide reachable address; the source address used for multicast messages is the link-local address of the interface on which the message is being sent.",
      "ja": "PIMメッセージは、ユニキャスト（例えば、レジ​​スタ、レジスタ・停止）または「ALL-PIM-ルータのグループ（例えば、/プルーンに参加し、アサートなど）にTTL 1とマルチキャストのいずれかです。ユニキャストメッセージに使用される送信元アドレスは、ドメイン全体の到達可能なアドレスです。マルチキャストメッセージのために使用されるソースアドレスは、メッセージが送信されているインターフェイスのリンクローカルアドレスです。"
    },
    {
      "indent": 3,
      "text": "The IPv4 'ALL-PIM-ROUTERS' group is '224.0.0.13'. The IPv6 'ALL-PIM-ROUTERS' group is 'ff02::d'.",
      "ja": "IPv4の 'ALL-PIM-ルータのグループは、 '224.0.0.13' です。 IPv6の「ALL-PIM-ルータのグループは、 'FF02 :: D' です。"
    },
    {
      "indent": 3,
      "text": "The PIM header common to all PIM messages is:",
      "ja": "すべてのPIMメッセージに共通のPIMヘッダーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|PIM Ver| Type  |   Reserved    |           Checksum            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "PIM Ver PIM Version number is 2.",
      "ja": "PIM版PIMバージョン番号は2です。"
    },
    {
      "indent": 3,
      "text": "Type Types for specific PIM messages. PIM Types are:",
      "ja": "特定のPIMメッセージの種類を入力します。 PIMの種類は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Message Type                          Destination\n---------------------------------------------------------------------\n0 = Hello                             Multicast to ALL-PIM-ROUTERS\n1 = Register                          Unicast to RP\n2 = Register-Stop                     Unicast to source of Register\n                                         packet\n3 = Join/Prune                        Multicast to ALL-PIM-ROUTERS\n4 = Bootstrap                         Multicast to ALL-PIM-ROUTERS\n5 = Assert                            Multicast to ALL-PIM-ROUTERS\n6 = Graft (used in PIM-DM only)       Unicast to RPF'(S)\n7 = Graft-Ack (used in PIM-DM only)   Unicast to source of Graft\n                                         packet\n8 = Candidate-RP-Advertisement        Unicast to Domain's BSR",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Reserved Set to zero on transmission. Ignored upon receipt.",
      "ja": "送信時にゼロに設定された予約。受信時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Checksum The checksum is a standard IP checksum, i.e., the 16-bit one's complement of the one's complement sum of the entire PIM message, excluding the \"Multicast data packet\" section of the Register message. For computing the checksum, the checksum field is zeroed. If the packet's length is not an integral number of 16-bit words, the packet is padded with a trailing byte of zero before performing the checksum.",
      "ja": "チェックサムはチェックサムは、標準のIPチェックサム、Registerメッセージの「マルチキャストデータパケット」セクションを除く全体PIMメッセージの1の補数和の、すなわち、16ビットの1の補数です。チェックサムを計算するために、チェックサムフィールドがゼロにされます。パケットの長さは16ビットワードの整数倍でない場合、パケットは、チェックサムを実行する前に、ゼロの後続バイトでパディングされます。"
    },
    {
      "indent": 8,
      "text": "For IPv6, the checksum also includes the IPv6 \"pseudo-header\",\nas specified in RFC 2460, Section 8.1 [5].  This \"pseudo-header\"\nis prepended to the PIM header for the purposes of calculating\nthe checksum.  The \"Upper-Layer Packet Length\" in the pseudo-\nheader is set to the length of the PIM message, except in\nRegister messages where it is set to the length of the PIM\nregister header (8).  The Next Header value used in the pseudo-\nheader is 103.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If a message is received with an unrecognized PIM Ver or Type field, or if a message's destination does not correspond to the table above, the message MUST be discarded, and an error message SHOULD be logged to the administrator in a rate-limited manner.",
      "ja": "メッセージは認識されないPIM版またはタイプフィールドで受信される、またはメッセージの宛先は、上記の表に対応しない場合、メッセージは破棄されなければならない、およびエラーメッセージが速度制限のようにして管理者にログインする必要がある場合。"
    },
    {
      "indent": 0,
      "text": "4.9.1. Encoded Source and Group Address Formats",
      "section_title": true,
      "ja": "4.9.1。符号化されたソースとグループアドレス形式"
    },
    {
      "indent": 3,
      "text": "Encoded-Unicast Address",
      "ja": "エンコードされたユニキャストアドレス"
    },
    {
      "indent": 3,
      "text": "An Encoded-Unicast address takes the following format:",
      "ja": "エンコードされたユニキャストアドレスは次の形式を取ります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Addr Family  | Encoding Type |     Unicast Address\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Addr Family The PIM address family of the 'Unicast Address' field of this address.",
      "ja": "ADDR家族このアドレスの「ユニキャストアドレス」欄のPIMアドレスファミリ。"
    },
    {
      "indent": 8,
      "text": "Values 0-127 are as assigned by the IANA for Internet Address\nFamilies in [7].  Values 128-250 are reserved to be assigned by\nthe IANA for PIM-specific Address Families.  Values 251 though\n255 are designated for private use.  As there is no assignment\nauthority for this space, collisions should be expected.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Encoding Type The type of encoding used within a specific Address Family. The value '0' is reserved for this field and represents the native encoding of the Address Family.",
      "ja": "エンコーディングは、特定のアドレスファミリ内で使用されるエンコーディングの種類を入力します。値が「0」このフィールドのために確保し、アドレスファミリのネイティブエンコーディングを表しています。"
    },
    {
      "indent": 3,
      "text": "Unicast Address The unicast address as represented by the given Address Family and Encoding Type.",
      "ja": "与えられたアドレスファミリとエンコードタイプで表されるようにユニキャストユニキャストアドレスです。"
    },
    {
      "indent": 3,
      "text": "Encoded-Group Address",
      "ja": "エンコード・グループアドレス"
    },
    {
      "indent": 3,
      "text": "Encoded-Group addresses take the following format:",
      "ja": "エンコード・グループのアドレスは次の形式を取ります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Addr Family  | Encoding Type |B| Reserved  |Z|  Mask Len     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Group multicast Address\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Addr Family Described above.",
      "ja": "ADDRファミリーは、前述しました。"
    },
    {
      "indent": 3,
      "text": "Encoding Type Described above.",
      "ja": "エンコードの種類は、前述しました。"
    },
    {
      "indent": 3,
      "text": "[B]idirectional PIM Indicates the group range should use Bidirectional PIM [13]. For PIM-SM defined in this specification, this bit MUST be zero.",
      "ja": "[B] idirectional PIMグループ範囲は、双方向PIM [13]を使用しなければならないことを示します。本明細書で定義されているPIM-SMの場合、このビットはゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Reserved Transmitted as zero. Ignored upon receipt.",
      "ja": "予約ゼロとして送信します。受信時に無視されます。"
    },
    {
      "indent": 3,
      "text": "Admin Scope [Z]one indicates the group range is an admin scope zone. This is used in the Bootstrap Router Mechanism [11] only. For all other purposes, this bit is set to zero and ignored on receipt.",
      "ja": "管理範囲[Z]一つはグループ範囲は、管理スコープゾーンであることを示します。これが唯一のブートストラップルータのメカニズム[11]で使用されています。他のすべての目的のために、このビットがゼロに設定され、領収書の上で無視します。"
    },
    {
      "indent": 3,
      "text": "Mask Len The Mask length field is 8 bits. The value is the number of contiguous one bits that are left justified and used as a mask; when combined with the group address, it describes a range of groups. It is less than or equal to the address length in bits for the given Address Family and Encoding Type. If the message is sent for a single group, then the Mask length must equal the address length in bits for the given Address Family and Encoding Type (e.g., 32 for IPv4 native encoding, 128 for IPv6 native encoding).",
      "ja": "マスク長フィールドは8ビットであるレンマスク。値は左寄せとマスクとして使用される隣接1つのビットの数です。グループアドレスと組み合わされたとき、それがグループの範囲が記載されています。これは、指定されたアドレスファミリとエンコードタイプのためのビットのアドレスの長さ以下です。メッセージが単一のグループのために送られている場合、マスクの長さは、指定されたアドレスファミリとエンコードタイプ（IPv6のネイティブ符号化するための、例えば、IPv4のネイティブ符号化のための32、128）のためのビットのアドレスの長さに等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "Group multicast Address Contains the group address.",
      "ja": "グループのマルチキャストアドレスは、グループアドレスが含まれています。"
    },
    {
      "indent": 3,
      "text": "Encoded-Source Address",
      "ja": "エンコードされ、送信元アドレス"
    },
    {
      "indent": 3,
      "text": "Encoded-Source address takes the following format:",
      "ja": "エンコードされ、送信元アドレスは次の形式を取ります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Addr Family   | Encoding Type | Rsrvd   |S|W|R|  Mask Len     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Source Address\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Addr Family Described above.",
      "ja": "ADDRファミリーは、前述しました。"
    },
    {
      "indent": 3,
      "text": "Encoding Type Described above.",
      "ja": "エンコードの種類は、前述しました。"
    },
    {
      "indent": 3,
      "text": "Reserved Transmitted as zero, ignored on receipt.",
      "ja": "予約済み領収書の上で無視、ゼロとして送信します。"
    },
    {
      "indent": 3,
      "text": "S The Sparse bit is a 1-bit value, set to 1 for PIM-SM. It is used for PIM version 1 compatibility.",
      "ja": "Sスパースビットは、PIM-SMのために1に設定された1ビットの値です。これは、PIMバージョン1の互換性のために使用されています。"
    },
    {
      "indent": 3,
      "text": "W The WC (or WildCard) bit is a 1-bit value for use with PIM Join/Prune messages (see Section 4.9.5.1).",
      "ja": "WC（またはワイルドカード）Wビットは、PIM加入/プルーンメッセージ（セクション4.9.5.1を参照）と共に使用するための1ビットの値です。"
    },
    {
      "indent": 3,
      "text": "R The RPT (or Rendezvous Point Tree) bit is a 1-bit value for use with PIM Join/Prune messages (see Section 4.9.5.1). If the WC bit is 1, the RPT bit MUST be 1.",
      "ja": "Rザ・RPT（またはランデブーポイントツリー）ビットは、PIM参加/プルーンのメッセージ（セクション4.9.5.1を参照）で使用するための1ビットの値です。 WCビットが1の場合、RPTビットが1でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Mask Len The mask length field is 8 bits. The value is the number of contiguous one bits left justified used as a mask which, combined with the Source Address, describes a source subnet. The mask length MUST be equal to the mask length in bits for the given Address Family and Encoding Type (32 for IPv4 native and 128 for IPv6 native). A router SHOULD ignore any messages received with any other mask length.",
      "ja": "マスク長フィールドは8ビットであるレンマスク。値は、ソースアドレスと組み合わされ、ソースサブネットを記述するマスクとして左寄せ連続する1つのビットの数です。マスク長は、指定されたアドレスファミリとエンコードタイプのためのビットのマスク長（ネイティブIPv4の場合32とIPv6ネイティブ128）に等しくなければなりません。ルータは、他のマスク長で受信したすべてのメッセージを無視すべきです。"
    },
    {
      "indent": 3,
      "text": "Source Address The source address.",
      "ja": "ソースは、ソースアドレス。"
    },
    {
      "indent": 0,
      "text": "4.9.2. Hello Message Format",
      "section_title": true,
      "ja": "4.9.2。こんにちは、メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "It is sent periodically by routers on all interfaces.",
      "ja": "これは、すべてのインターフェイス上のルータによって定期的に送信されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|PIM Ver| Type  |   Reserved    |           Checksum            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          OptionType           |         OptionLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          OptionValue                          |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               .                               |\n|                               .                               |\n|                               .                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          OptionType           |         OptionLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          OptionValue                          |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "PIM Version, Type, Reserved, Checksum Described in Section 4.9.",
      "ja": "PIMバージョン、タイプは、予約済み、チェックサムは、4.9節で説明します。"
    },
    {
      "indent": 3,
      "text": "OptionType The type of the option given in the following OptionValue field.",
      "ja": "次OptionValue分野で与えられたオプションの種類でoptionType。"
    },
    {
      "indent": 3,
      "text": "OptionLength The length of the OptionValue field in bytes.",
      "ja": "バイト単位でOptionValueフィールドの長さOptionLength。"
    },
    {
      "indent": 3,
      "text": "OptionValue A variable length field, carrying the value of the option.",
      "ja": "オプションの値を運んで、可変長フィールドをOptionValue。"
    },
    {
      "indent": 3,
      "text": "The Option fields may contain the following values:",
      "ja": "オプションフィールドには、次の値が含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "o OptionType 1: Holdtime",
      "ja": "1でoptionType O：ホールドタイム"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type = 1             |         Length = 2            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Holdtime             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Holdtime is the amount of time a receiver must keep the neighbor reachable, in seconds. If the Holdtime is set to '0xffff', the receiver of this message never times out the neighbor. This may be used with dial-on-demand links, to avoid keeping the link up with periodic Hello messages.",
      "ja": "ホールドタイムは、受信機が数秒で、到達可能な隣人を維持しなければならない時間の量です。隣人アウトホールドタイムが「0xffffの」に設定されている場合は、このメッセージの受信者は決して回。これは、定期的にHelloメッセージでリンクを追いつい避けるために、ダイヤルオンデマンドリンクを使用することができます。"
    },
    {
      "indent": 5,
      "text": "Hello messages with a Holdtime value set to '0' are also sent by a router on an interface about to go down or changing IP address (see Section 4.3.1). These are effectively goodbye messages, and the receiving routers should immediately time out the neighbor information for the sender.",
      "ja": "こんにちは「0」に設定ホールドタイム値を持つメッセージは、（4.3.1項を参照）を下るまたはIPアドレスを変更する程度のインターフェイス上のルータによって送信されます。これらは、効果的にお別れのメッセージであり、受信ルータはすぐに送信者のネイバー情報をタイムアウトする必要があります。"
    },
    {
      "indent": 3,
      "text": "o OptionType 2: LAN Prune Delay",
      "ja": "OでoptionType 2：LANプルーン遅延"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type = 2             |          Length = 4           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|T|      Propagation_Delay      |      Override_Interval        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "The LAN Prune Delay option is used to tune the prune propagation delay on multi-access LANs. The T bit specifies the ability of the sending router to disable joins suppression. Propagation_Delay and Override_Interval are time intervals in units of milliseconds. A router originating a LAN Prune Delay option on interface I sets the Propagation_Delay field to the configured value of Propagation_Delay(I) and the value of the Override_Interval field to the value of Override_Interval(I). On a receiving router, the values of the fields are used to tune the value of the Effective_Override_Interval(I) and its derived timer values. Section 4.3.3 describes how these values affect the behavior of a router.",
      "ja": "LANプルーンDelayオプションは、マルチアクセスLANのプルーンの伝播遅延を調整するために使用されます。 Tビットは、抑制に参加し無効にするには、送信ルータの能力を指定します。 PROPAGATION_DELAYとOverride_Intervalは、ミリ秒単位の時間間隔です。インターフェイス上のLANプルーンDelayオプションを発信するルータは、私がPROPAGATION_DELAY（I）の設定された値とOverride_Interval（I）の値にOverride_Intervalフィールドの値にPROPAGATION_DELAYフィールドを設定します。受信ルータ上で、フィールドの値を調整するためにEffective_Override_Interval（I）及びその派生タイマ値の値を使用しています。 4.3.3は、これらの値は、ルータの動作に影響を与える方法を説明します。"
    },
    {
      "indent": 3,
      "text": "o OptionType 3 to 16: reserved to be defined in future versions of this document.",
      "ja": "3〜16でoptionType O：この文書の将来のバージョンで定義される予約済み。"
    },
    {
      "indent": 3,
      "text": "o OptionType 18: deprecated and should not be used.",
      "ja": "OでoptionType 18：非推奨と使用すべきではありません。"
    },
    {
      "indent": 3,
      "text": "o OptionType 19: DR Priority",
      "ja": "OでoptionType 19：DRプライオリティ"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type = 19            |          Length = 4           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         DR Priority                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "DR Priority is a 32-bit unsigned number and should be considered in the DR election as described in Section 4.3.2.",
      "ja": "DR優先順位は、32ビットの符号なしの数であり、セクション4.3.2に記載されているようにDR選挙において考慮されるべきです。"
    },
    {
      "indent": 3,
      "text": "o OptionType 20: Generation ID",
      "ja": "OでoptionType 20：ジェネレーションID"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type = 20            |          Length = 4           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Generation ID                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Generation ID is a random 32-bit value for the interface on which the Hello message is sent. The Generation ID is regenerated whenever PIM forwarding is started or restarted on the interface.",
      "ja": "世代IDは、Helloメッセージが送信されたインターフェイスのためのランダム32ビット値です。 PIMフォワーディングがインターフェイス上で起動または再起動されるたびに生成IDが再生成されます。"
    },
    {
      "indent": 3,
      "text": "o OptionType 24: Address List",
      "ja": "OでoptionType 24：アドレス一覧"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type = 24            |      Length = <Variable>      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Secondary Address 1 (Encoded-Unicast format)          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                               ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Secondary Address N (Encoded-Unicast format)          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "The contents of the Address List Hello option are described in Section 4.3.4. All addresses within a single Address List must belong to the same address family.",
      "ja": "アドレス一覧のHelloオプションの内容は、4.3.4項で説明されています。単一アドレス一覧内のすべてのアドレスは同じアドレスファミリーに属している必要があります。"
    },
    {
      "indent": 3,
      "text": "OptionTypes 17 through 65000 are assigned by the IANA. OptionTypes 65001 through 65535 are reserved for Private Use, as defined in [9].",
      "ja": "65000経由のオプションタイプ17は、IANAによって割り当てられます。 [9]で定義されるようにオプションタイプ65001〜65535は、プライベート使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Unknown options MUST be ignored and MUST NOT prevent a neighbor relationship from being formed. The \"Holdtime\" option MUST be implemented; the \"DR Priority\" and \"Generation ID\" options SHOULD be implemented. The \"Address List\" option MUST be implemented for IPv6.",
      "ja": "不明なオプションは無視されなければならないと形成されることから、ネイバー関係を妨げてはなりません。 「ホールドタイム」オプションを実装する必要があります。 「DR優先」と「世代ID」のオプションが実施されるべきです。 「アドレスリスト」オプションは、IPv6のために実装しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.9.3. Register Message Format",
      "section_title": true,
      "ja": "4.9.3。登録メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "A Register message is sent by the DR or a PMBR to the RP when a multicast packet needs to be transmitted on the RP-tree. The IP source address is set to the address of the DR, the destination address to the RP's address. The IP TTL of the PIM packet is the system's normal unicast TTL.",
      "ja": "マルチキャストパケットは、RP-ツリー上で送信する必要があるとき登録メッセージはDRまたはRPにPMBRによって送信されます。 IPソースアドレスがDR、RPのアドレスに送信先アドレスのアドレスに設定されています。 PIMパケットのIP TTLは、システムの正常なユニキャストTTLです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|PIM Ver| Type  |   Reserved    |           Checksum            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|B|N|                       Reserved2                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n.                     Multicast data packet                     .\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "PIM Version, Type, Reserved, Checksum Described in Section 4.9. Note that in order to reduce encapsulation overhead, the checksum for Registers is done only on the first 8 bytes of the packet, including the PIM header and the next 4 bytes, excluding the data packet portion. For interoperability reasons, a message carrying a checksum calculated over the entire PIM Register message should also be accepted. When calculating the checksum, the IPv6 pseudoheader \"Upper-Layer Packet Length\" is set to 8.",
      "ja": "PIMバージョン、タイプは、予約済み、チェックサムは、4.9節で説明します。データパケットの部分を除いた、カプセル化オーバヘッドを削減するために、レジスタのチェックサムのみPIMヘッダと次の4つのバイトを含むパケットの最初の8バイトで行われることに留意されたいです。相互運用性の理由から、全体のPIM Registerメッセージの上に計算されたチェックサムを運ぶメッセージも受け入れられるべきです。チェックサムを計算する場合、のIPv6擬似ヘッダ「上位層パケット長は」8に設定されています。"
    },
    {
      "indent": 3,
      "text": "B The Border bit. If the router is a DR for a source that it is directly connected to, it sets the B bit to 0. If the router is a PMBR for a source in a directly connected cloud, it sets the B bit to 1.",
      "ja": "境界ビットB。ルータは、それが直接に接続されているソースのDRである場合、ルータは直接接続されたクラウド内のソースのPMBRである場合、それは0にBビットを設定し、それは1にBビットをセットします。"
    },
    {
      "indent": 3,
      "text": "N The Null-Register bit. Set to 1 by a DR that is probing the RP before expiring its local Register-Suppression Timer. Set to 0 otherwise.",
      "ja": "Nザ・ヌル・レジスタのビット。そのローカル登録-抑制タイマーの期限切れ前にRPを探査されるDRによって1に設定します。それ以外の場合は0に設定します。"
    },
    {
      "indent": 3,
      "text": "Reserved2 Transmitted as zero, ignored on receipt.",
      "ja": "Reserved2は、領収書の上で無視、ゼロとして送信します。"
    },
    {
      "indent": 3,
      "text": "Multicast data packet The original packet sent by the source. This packet must be of the same address family as the encapsulating PIM packet, e.g., an IPv6 data packet must be encapsulated in an IPv6 PIM packet. Note that the TTL of the original packet is decremented before encapsulation, just like any other packet that is forwarded. In addition, the RP decrements the TTL after decapsulating, before forwarding the packet down the shared tree.",
      "ja": "マルチキャストデータは、ソースによって送信された元のパケットをパケット。このパケットがカプセル化PIMパケットと同じアドレスファミリーである必要があり、例えば、IPv6データパケットは、IPv6 PIMパケットにカプセル化されなければなりません。元のパケットのTTLがちょうど転送され、他のパケットと同様に、カプセル化の前に減算されることに注意してください。また、RPは、共有ツリーの下のパケットを転送する前に、カプセル化解除後のTTLを減少します。"
    },
    {
      "indent": 8,
      "text": "For (S,G) Null-Registers, the Multicast data packet portion\ncontains a dummy IP header with S as the source address, G as\nthe destination address.  When generating an IPv4 Null-Register\nmessage, the fields in the dummy IPv4 header SHOULD be filled in\naccording to the following table.  Other IPv4 header fields may\ncontain any value that is valid for that field.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Field                  Value\n---------------------------------------\nIP Version             4\nHeader Length          5\nChecksum               Header checksum\nFragmentation offset   0\nMore Fragments         0\nTotal Length           20\nIP Protocol            103 (PIM)",
      "raw": true
    },
    {
      "indent": 8,
      "text": "On receipt of an (S,G) Null-Register, if the Header Checksum field is non-zero, the recipient SHOULD check the checksum and discard null registers that have a bad checksum. The recipient SHOULD NOT check the value of any individual fields; a correct IP header checksum is sufficient. If the Header Checksum field is zero, the recipient MUST NOT check the checksum.",
      "ja": "ヘッダチェックサムフィールドが非ゼロである場合（S、G）ヌルレジスタを受信すると、受信者は、チェックサムをチェックし、不正なチェックサムを有するヌルレジスタを破棄すべきです。受信者は、任意の個々のフィールドの値をチェックするべきではありません。正しいIPヘッダチェックサムは十分です。ヘッダチェックサムフィールドがゼロの場合、受信者はチェックサムをチェックしてはなりません。"
    },
    {
      "indent": 8,
      "text": "With IPv6, an implementation generates a dummy IP header followed by a dummy PIM header with values according to the following table in addition to the source and group. Other IPv6 header fields may contain any value that is valid for that field.",
      "ja": "IPv6では、実装がソースグループに加えて、以下の表に従って値を持つダミーPIMヘッダに続くダミーIPヘッダを生成します。他のIPv6ヘッダフィールドは、そのフィールドに対して有効な任意の値が含まれていてもよいです。"
    },
    {
      "indent": 8,
      "text": "Header Field   Value\n--------------------------------------\nIP Version     6\nNext Header    103 (PIM)\nLength         4\nPIM Version    0\nPIM Type       0\nPIM Reserved   0\nPIM Checksum   PIM checksum including\n               IPv6 \"pseudo-header\";\n               see Section 4.9",
      "raw": true
    },
    {
      "indent": 8,
      "text": "On receipt of an IPv6 (S,G) Null-Register, if the dummy PIM header is present, the recipient SHOULD check the checksum and discard Null-Registers that have a bad checksum.",
      "ja": "ダミーPIMヘッダが存在する場合、IPv6の（S、G）ヌルレジスタを受信すると、受信者は、チェックサムをチェックし、不正なチェックサムを有するヌルレジスタを破棄すべきです。"
    },
    {
      "indent": 0,
      "text": "4.9.4. Register-Stop Message Format",
      "section_title": true,
      "ja": "4.9.4。登録停止メッセージの形式を"
    },
    {
      "indent": 3,
      "text": "A Register-Stop is unicast from the RP to the sender of the Register message. The IP source address is the address to which the register was addressed. The IP destination address is the source address of the register message.",
      "ja": "登録・停止は、Registerメッセージの送信者にRPからユニキャストです。 IPソースアドレスレジスタがアドレス指定された先のアドレスです。 IP宛先アドレスは、レジスタメッセージの送信元アドレスです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|PIM Ver| Type  |   Reserved    |           Checksum            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Group Address (Encoded-Group format)              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Source Address (Encoded-Unicast format)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "PIM Version, Type, Reserved, Checksum Described in Section 4.9.",
      "ja": "PIMバージョン、タイプは、予約済み、チェックサムは、4.9節で説明します。"
    },
    {
      "indent": 3,
      "text": "Group Address The group address from the multicast data packet in the Register. Format described in Section 4.9.1. Note that for Register-Stops the Mask Len field contains the full address length * 8 (e.g., 32 for IPv4 native encoding), if the message is sent for a single group.",
      "ja": "当社グループは、レジスタのマルチキャストデータパケットからグループアドレス。フォーマットは、セクション4.9.1で説明します。登録ストップ用マスクLENフィールドは、完全なアドレス長が含まれていることに注意してください* 8（例えば、IPv4のネイティブ符号化のための32）と、メッセージは、単一のグループのために送られている場合。"
    },
    {
      "indent": 3,
      "text": "Source Address The host address of the source from the multicast data packet in the register. The format for this address is given in the Encoded-Unicast address in Section 4.9.1. A special wild card value consisting of an address field of all zeros can be used to indicate any source.",
      "ja": "ソースは、レジスタ内のマルチキャストデータパケットから送信元のホストアドレス。このアドレスの形式は、セクション4.9.1でエンコードされたユニキャストアドレスに与えられています。すべてゼロのアドレスフィールドからなる特殊なワイルドカード値は、任意のソースを示すために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.9.5. Join/Prune Message Format",
      "section_title": true,
      "ja": "4.9.5。参加/プルーンメッセージ形式"
    },
    {
      "indent": 3,
      "text": "A Join/Prune message is sent by routers towards upstream sources and RPs. Joins are sent to build shared trees (RP trees) or source trees (SPT). Prunes are sent to prune source trees when members leave groups as well as sources that do not use the shared tree.",
      "ja": "参加/プルーンメッセージがアップストリームソースとのRPに向かってルータによって送信されます。参加は、共有ツリー（RP木）、あるいはソースツリー（SPT）を構築するために送信されます。プルーンは、メンバーが共有ツリーを使用していないグループだけでなく、ソースを離れるときにソースツリーを剪定するために送信されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|PIM Ver| Type  |   Reserved    |           Checksum            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Upstream Neighbor Address (Encoded-Unicast format)     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Reserved     | Num groups    |          Holdtime             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Multicast Group Address 1 (Encoded-Group format)      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Number of Joined Sources    |   Number of Pruned Sources    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Joined Source Address 1 (Encoded-Source format)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             .                                 |\n|                             .                                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Joined Source Address n (Encoded-Source format)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Pruned Source Address 1 (Encoded-Source format)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             .                                 |\n|                             .                                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Pruned Source Address n (Encoded-Source format)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           .                                   |\n|                           .                                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Multicast Group Address m (Encoded-Group format)      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Number of Joined Sources    |   Number of Pruned Sources    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Joined Source Address 1 (Encoded-Source format)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             .                                 |\n|                             .                                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Joined Source Address n (Encoded-Source format)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Pruned Source Address 1 (Encoded-Source format)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             .                                 |\n|                             .                                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Pruned Source Address n (Encoded-Source format)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "PIM Version, Type, Reserved, Checksum Described in Section 4.9.",
      "ja": "PIMバージョン、タイプは、予約済み、チェックサムは、4.9節で説明します。"
    },
    {
      "indent": 3,
      "text": "Unicast Upstream Neighbor Address The address of the upstream neighbor that is the target of the message. The format for this address is given in the Encoded-Unicast address in Section 4.9.1. For IPv6 the source address used for multicast messages is the link-local address of the interface on which the message is being sent. For IPv4, the source address is the primary address associated with that interface.",
      "ja": "ユニキャスト上流隣接には、メッセージのターゲットである上流ネイバーのアドレス。このアドレスの形式は、セクション4.9.1でエンコードされたユニキャストアドレスに与えられています。 IPv6のためのマルチキャストメッセージに使用される送信元アドレスは、メッセージが送信されているインターフェイスのリンクローカルアドレスです。 IPv4の場合、ソースアドレスは、そのインターフェイスに関連付けられたプライマリ・アドレスです。"
    },
    {
      "indent": 3,
      "text": "Reserved Transmitted as zero, ignored on receipt.",
      "ja": "予約済み領収書の上で無視、ゼロとして送信します。"
    },
    {
      "indent": 3,
      "text": "Holdtime The amount of time a receiver must keep the Join/Prune state alive, in seconds. If the Holdtime is set to '0xffff', the receiver of this message should hold the state until canceled by the appropriate canceling Join/Prune message, or timed out according to local policy. This may be used with dial-on-demand links, to avoid keeping the link up with periodic Join/Prune messages.",
      "ja": "ホールドタイムレシーバは秒で、生きて参加/プルーンの状態を維持しなければならない時間の量。ホールドタイムが「0xFFFFの」に設定されている場合、このメッセージの受信側は/プルーンメッセージを参加キャンセル適切によってキャンセルされるまでの状態を保持する、またはローカルポリシーに従ってタイムアウトしなければなりません。これは、定期的な参加/プルーンのメッセージでリンクを追いつい避けるために、ダイヤルオンデマンドリンクを使用することができます。"
    },
    {
      "indent": 8,
      "text": "Note that the HoldTime must be larger than the\nJ/P_Override_Interval(I).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Number of Groups The number of multicast group sets contained in the message.",
      "ja": "グループの数のメッセージに含まれるマルチキャストグループセットの数。"
    },
    {
      "indent": 3,
      "text": "Multicast group address For format description, see Section 4.9.1.",
      "ja": "フォーマットの説明については、マルチキャストグループアドレスは、セクション4.9.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Number of Joined Sources Number of joined source addresses listed for a given group.",
      "ja": "特定のグループのために記載されている参加送信元アドレスの参加源数の数。"
    },
    {
      "indent": 3,
      "text": "Joined Source Address 1 .. n This list contains the sources for a given group that the sending router will forward multicast datagrams from if received on the interface on which the Join/Prune message is sent.",
      "ja": "ソースアドレス1に参加した。.. nはこのリストには、送信側のルータが参加/プルーンメッセージが送信されているインターフェイス上で受信した場合のマルチキャストデータグラムを転送します特定のグループのためのソースが含まれています。"
    },
    {
      "indent": 8,
      "text": "See Encoded-Source-Address format in Section 4.9.1.",
      "ja": "セクション4.9.1でエンコードされ、ソース・アドレス・フォーマットを参照してください。"
    },
    {
      "indent": 3,
      "text": "Number of Pruned Sources Number of pruned source addresses listed for a group.",
      "ja": "グループのためにリストされて剪定されたソースアドレスの剪定源数の数。"
    },
    {
      "indent": 3,
      "text": "Pruned Source Address 1 .. n This list contains the sources for a given group that the sending router does not want to forward multicast datagrams from when received on the interface on which the Join/Prune message is sent.",
      "ja": "ソースアドレス1を剪定.. nはこのリストには、送信側のルータが参加/プルーンメッセージが送信されているインターフェイス上で受信したときからのマルチキャストデータグラムを転送したくない特定のグループのためのソースが含まれています。"
    },
    {
      "indent": 3,
      "text": "Within one PIM Join/Prune message, all the Multicast Group Addresses, Joined Source addresses, and Pruned Source addresses MUST be of the same address family. It is NOT PERMITTED to mix IPv4 and IPv6 addresses within the same message. In addition, the address family of the fields in the message SHOULD be the same as the IP source and destination addresses of the packet. This permits maximum implementation flexibility for dual-stack IPv4/IPv6 routers. If a router receives a message with mixed family addresses, it SHOULD only process the addresses that are of the same family as the unicast upstream neighbor address.",
      "ja": "1つのPIM内/プルーンのメッセージ、すべてのマルチキャストグループアドレス、参加ソースアドレス、剪定されたソースアドレスが同じアドレスファミリーのものでなければならない参加。同じメッセージ内のIPv4アドレスとIPv6アドレスを混在することは許されません。また、メッセージ内のフィールドのアドレスファミリは、パケットのIP送信元アドレスと宛先アドレスと同じでなければなりません。これは、デュアルスタックIPv4 / IPv6ルータの最大の実装の柔軟性を可能にします。ルータが混在家族アドレスを持つメッセージを受信した場合、それだけで、ユニキャスト上流隣接アドレスと同じファミリーであるアドレスを処理しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.9.5.1. Group Set Source List Rules",
      "section_title": true,
      "ja": "4.9.5.1。グループセットソースリストのルール"
    },
    {
      "indent": 3,
      "text": "As described above, Join/Prune messages are composed of one or more group sets. Each set contains two source lists, the Joined Sources and the Pruned Sources. This section describes the different types of group sets and source list entries that can exist in a Join/Prune message.",
      "ja": "上記のように、/プルーンメッセージは、1つまたは複数のグループセットで構成されている参加。各セットには、二つのソースリスト、参加ソースと剪定ソースが含まれています。このセクションでは、参加/プルーンメッセージで存在することができるグループセットとソースリストのエントリの異なるタイプを記述する。"
    },
    {
      "indent": 3,
      "text": "There are two valid group set types:",
      "ja": "2つの有効なグループセットの種類があります。"
    },
    {
      "indent": 3,
      "text": "Wildcard Group Set The wildcard group set is represented by the entire multicast range: the beginning of the multicast address range in the group address field and the prefix length of the multicast address range in the mask length field of the Multicast Group Address (i.e., '224.0.0.0/4' for IPv4 or 'ff00::/8' for IPv6). Each Join/Prune message SHOULD contain at most one wildcard group set. Each wildcard group set may contain one or more (*,*,RP) source list entries in either the Joined or Pruned lists.",
      "ja": "'、グループアドレスフィールドにマルチキャストアドレス範囲の開始とマルチキャストグループアドレス（すなわちのマスク長フィールド内のマルチキャストアドレス範囲のプレフィックス長：ワイルドカードグループセットのワイルドカードグループセットは、全マルチキャスト範囲で表され、 IPv6のFF00 :: / 8 '）IPv4またはのための' 224.0.0.0/4' 。それぞれ/プルーンのメッセージは最大で1つのワイルドカードグループセットに含まれているべきで参加します。各ワイルドカードグループセットは、いずれかの参加またはプルーニングリスト内の1つまたは複数の（*、*、RP）ソースリストのエントリが含まれていてもよいです。"
    },
    {
      "indent": 8,
      "text": "A (*,*,RP) source list entry may only exist in a wildcard group\nset.  When added to a Joined source list, this type of source\nentry expresses the router's interest in receiving traffic for\nall groups mapping to the specified RP.  When added to a Pruned\nsource list a (*,*,RP) entry expresses the router's interest to\nstop receiving such traffic.  Note that as indicated by the\nJoin/Prune state machines, such a Join or Prune will NOT\noverride Join/Prune state created using a Group-Specific Set\n(see below).",
      "raw": true
    },
    {
      "indent": 8,
      "text": "(*,*,RP) source list entries have the Source-Address set to the address of the RP, the Source-Address Mask-Len set to the full length of the IP address, and both the WC and RPT bits of the Source-Address set to 1.",
      "ja": "（*、*、RP）ソースリストのエントリは、RPのアドレスに設定ソース・アドレスは、送信元アドレスマスク - レンはIPアドレスの完全な長さに設定されている、とソースのWCとRPTビットの両方1に設定-address。"
    },
    {
      "indent": 3,
      "text": "Group-Specific Set A Group-Specific Set is represented by a valid IP multicast address in the group address field and the full length of the IP address in the mask length field of the Multicast Group Address. Each Join/Prune message SHOULD NOT contain more than one group-specific set for the same IP multicast address. Each group-specific set may contain (*,G), (S,G,rpt), and (S,G) source list entries in the Joined or Pruned lists.",
      "ja": "グループ固有のセットAグループ固有の設定は、グループアドレスフィールドに有効なIPマルチキャストアドレスおよびマルチキャストグループアドレスのマスク長フィールドでIPアドレスの完全な長さで表されます。各参加/プルーンのメッセージは、同じIPマルチキャストアドレスに対して複数のグループ固有のセットを含めることはできません。各グループ固有のセットは、参加又はプルーニングリストに（*、G）、（S、G、RPT）、及び（S、G）ソースリストのエントリを含んでいてもよいです。"
    },
    {
      "indent": 5,
      "text": "(*,G) The (*,G) source list entry is used in Join/Prune messages sent towards the RP for the specified group. It expresses interest (or lack thereof) in receiving traffic sent to the group through the Rendezvous-Point shared tree. There may only be one such entry in both the Joined and Pruned lists of a group-specific set.",
      "ja": "（*、G）（*、G）ソースリストエントリがで使用される指定されたグループのためのRPに向けて送信/プルーンメッセージに参加します。これは、ランデブーポイントの共有ツリーをグループに送信されたトラフィックの受信に関心（またはその欠如）を表します。唯一のグループ固有のセットの両方の参加およびプルーニングリスト内の1つのようなエントリがあるかもしれません。"
    },
    {
      "indent": 10,
      "text": "(*,G) source list entries have the Source-Address set to the\naddress of the RP for group G, the Source-Address Mask-Len set\nto the full length of the IP address, and both the WC and RPT\nbits of the Encoded-Source-Address set.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "(S,G,rpt) The (S,G,rpt) source list entry is used in Join/Prune messages sent towards the RP for the specified group. It expresses interest (or lack thereof) in receiving traffic through the shared tree sent by the specified source to this group. For each source address, the entry may exist in only one of the Joined and Pruned source lists of a group-specific set, but not both.",
      "ja": "（S、G、RPT）（S、G、RPT）ソースリストエントリがで使用される指定されたグループのためのRPに向けて送信/プルーンメッセージに参加します。これは、このグループに指定されたソースによって送信され、共有ツリーを通過するトラフィックを受信することに関心（またはその欠如）を表します。各送信元アドレスのために、エントリが両方ではなく、グループ固有のセットのメンバーと剪定ソースリストの一方のみに存在してもよいです。"
    },
    {
      "indent": 10,
      "text": "(S,G,rpt) source list entries have the Source-Address set to\nthe address of the source S, the Source-Address Mask-Len set\nto the full length of the IP address, and the WC bit cleared\nand the RPT bit set in the Encoded-Source-Address.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "(S,G) The (S,G) source list entry is used in Join/Prune messages sent towards the specified source. It expresses interest (or lack thereof) in receiving traffic through the shortest path tree sent by the source to the specified group. For each source address, the entry may exist in only one of the Joined and Pruned source lists of a group-specific set, but not both.",
      "ja": "（S、G）が（S、G）ソース・リスト・エントリは、指定した送信元に向けて送信/プルーンメッセージに参加して使用されます。これは、指定されたグループのソースによって送信された最短経路ツリーを介してトラフィックを受信することに関心（またはその欠如）を表します。各送信元アドレスのために、エントリが両方ではなく、グループ固有のセットのメンバーと剪定ソースリストの一方のみに存在してもよいです。"
    },
    {
      "indent": 10,
      "text": "(S,G) source list entries have the Source-Address set to the\naddress of the source S, the Source-Address Mask-Len set to\nthe full length of the IP address, and both the WC and RPT\nbits of the Encoded-Source-Address cleared.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The rules described above are sufficient to prevent invalid combinations of source list entries in group-specific sets. There are, however, a number of combinations that have a valid interpretation but that are not generated by the protocol as described in this specification:",
      "ja": "上記の規則はグループ固有のセットのソースリストのエントリの無効な組み合わせを防止するのに十分です。有効な解釈を持っているが、それは、本明細書に記載されたプロトコルによって生成されていない組み合わせの数は、しかし、があります。"
    },
    {
      "indent": 3,
      "text": "o Combining a (*,G) Join and a (S,G,rpt) Join entry in the same message is redundant as the (*,G) entry covers the information provided by the (S,G,rpt) entry.",
      "ja": "（*、G）エントリが（S、G、RPT）エントリによって提供される情報をカバーするように（*、G）に参加し、（S、G、RPT）同じメッセージ内のエントリに参加を組み合わせるoを冗長です。"
    },
    {
      "indent": 3,
      "text": "o The same applies for a (*,G) Prunes and (S,G,rpt) Prunes.",
      "ja": "同じことが（*、G）プルーン及び（S、G、RPT）プルーンに適用され、O。"
    },
    {
      "indent": 3,
      "text": "o The combination of a (*,G) Prune and a (S,G,rpt) Join is also not generated. (S,G,rpt) Joins are only sent when the router is receiving all traffic for a group on the shared tree and it wishes to indicate a change for the particular source. As a (*,G) prune indicates that the router no longer wishes to receive shared tree traffic, the (S,G,rpt) Join would be meaningless.",
      "ja": "O（*、G）プルーン及び（S、G、RPT）参加の組み合わせも発生しません。 （S、G、RPT）は、ルータが共有ツリー上のグループのすべてのトラフィックを受信して​​いる場合にのみ送信されジョイン、それが特定のソースの変更を指示することを望みます。 （*、G）プルーンは、ルータはもはや共有ツリーのトラフィックを受信したいことを示していないので、（S、G、RPT）が参加し意味がありません。"
    },
    {
      "indent": 3,
      "text": "o As Join/Prune messages are targeted to a single PIM neighbor, including both a (S,G) Join and a (S,G,rpt) Prune in the same message is usually redundant. The (S,G) Join informs the neighbor that the sender wishes to receive the particular source on the shortest path tree. It is therefore unnecessary for the router to say that it no longer wishes to receive it on the shared tree. However, there is a valid interpretation for this combination of entries. A downstream router may have to instruct its upstream only to start forwarding a specific source once it has started receiving the source on the shortest-path tree.",
      "ja": "Oなどが同じメッセージにプルーンメッセージが（S、G）に参加し、（S、G、RPT）の両方を含む、単一のPIMネイバーを標的とする/プルーンに参加することは通常は冗長です。 （S、G）参加は、送信者が最短経路ツリー上の特定のソースを受信したいことを隣人に通知します。ルータは、それはもはや共有ツリー上でそれを受信したいことを言っていないことがゆえ不要です。しかし、エントリのこの組み合わせのための有効な解釈があります。下流のルータは最短パスツリー上のソースの受信を開始した後にのみ、特定のソースの転送を開始するために、その上流に指示する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The combination of a (S,G) Prune and a (S,G,rpt) Join could possibly be used by a router to switch from receiving a particular source on the shortest-path tree back to receiving it on the shared tree (provided that the RPF neighbor for the shortest-path and shared trees is common). However, Sparse-Mode PIM does not provide a mechanism for explicitly switching back to the shared tree.",
      "ja": "O（S、G）プルーン及び（S、G、RPT）結合の組み合わせは、おそらく（共有ツリー上でそれを受信するバック最短パスツリー上の特定のソースを受けるから切り替えるためにルータにより使用することができます）最短パスと共有ツリーのためのRPF隣人が一般的であることを条件とします。しかし、スパースモードPIMは、明示的に共有ツリーに戻って切り替えるためのメカニズムを提供していません。"
    },
    {
      "indent": 3,
      "text": "The rules are summarized in the tables below.",
      "ja": "ルールは以下の表にまとめられています。"
    },
    {
      "indent": 3,
      "text": "+----------++------+-------+-----------+-----------+-------+-------+\n|          ||Join  | Prune | Join      | Prune     | Join  | Prune |\n|          ||(*,G) | (*,G) | (S,G,rpt) | (S,G,rpt) | (S,G) | (S,G) |\n+----------++------+-------+-----------+-----------+-------+-------+\n|Join      ||-     | no    | ?         | yes       | yes   | yes   |\n|(*,G)     ||      |       |           |           |       |       |\n+----------++------+-------+-----------+-----------+-------+-------+\n|Prune     ||no    | -     | ?         | ?         | yes   | yes   |\n|(*,G)     ||      |       |           |           |       |       |\n+----------++------+-------+-----------+-----------+-------+-------+\n|Join      ||?     | ?     | -         | no        | yes   | ?     |\n|(S,G,rpt) ||      |       |           |           |       |       |\n+----------++------+-------+-----------+-----------+-------+-------+\n|Prune     ||yes   | ?     | no        | -         | yes   | ?     |\n|(S,G,rpt) ||      |       |           |           |       |       |\n+----------++------+-------+-----------+-----------+-------+-------+\n|Join      ||yes   | yes   | yes       | yes       | -     | no    |\n|(S,G)     ||      |       |           |           |       |       |\n+----------++------+-------+-----------+-----------+-------+-------+\n|Prune     ||yes   | yes   | ?         | ?         | no    | -     |\n|(S,G)     ||      |       |           |           |       |       |\n+----------++------+-------+-----------+-----------+-------+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+---------------++--------------+----------------+------------+\n|               ||Join (*,*,RP) | Prune (*,*,RP) | all others |\n+---------------++--------------+----------------+------------+\n|Join (*,*,RP)  ||-             | no             | yes        |\n+---------------++--------------+----------------+------------+\n|Prune (*,*,RP) ||no            | -              | yes        |\n+---------------++--------------+----------------+------------+\n|all others     ||yes           | yes            | see above  |\n+---------------++--------------+----------------+------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "yes Allowed and expected.",
      "ja": "はい可と予想されます。"
    },
    {
      "indent": 3,
      "text": "no Combination is not allowed by the protocol and MUST NOT be generated by a router. A router MAY accept these messages, but the result is undefined. An error message MAY be logged to the administrator in a rate-limited manner.",
      "ja": "何のコンビネーションは、プロトコルによって許可されていないされていないと、ルータによって生成されてはなりません。ルータは、これらのメッセージを受け入れるかもしれが、結果は未定義です。エラーメッセージは、レート制限の方法で管理者に記録してもよいです。"
    },
    {
      "indent": 3,
      "text": "? Combination not expected by the protocol, but well-defined. A router MAY accept it but SHOULD NOT generate it.",
      "ja": "？組み合わせは、プロトコルによって期待されるが、明確に定義されていません。ルータはそれを受け入れるかもしれませんが、それを生成するべきではありません。"
    },
    {
      "indent": 3,
      "text": "The order of source list entries in a group set source list is not important, except where limited by the packet format itself.",
      "ja": "グループ設定ソースリスト内のソースリストのエントリの順序は、パケットフォーマット自体によって制限される場合を除いて、重要ではありません。"
    },
    {
      "indent": 0,
      "text": "4.9.5.2. Group Set Fragmentation",
      "section_title": true,
      "ja": "4.9.5.2。グループセットの断片化"
    },
    {
      "indent": 3,
      "text": "When building a Join/Prune for a particular neighbor, a router should try to include in the message as much of the information it needs to convey to the neighbor as possible. This implies adding one group set for each multicast group that has information pending transmission and within each set including all relevant source list entries.",
      "ja": "特定の隣人のために参加/プルーンを構築する場合、ルータは可能な限り隣人に伝えるために必要な情報をできるだけ多くのメッセージに含めるようにしてください。これは、情報、保留中の送信および関連するすべてのソース・リスト・エントリを含む各セット内にある各マルチキャストグループに対して1つのグループのセットを追加することを意味します。"
    },
    {
      "indent": 3,
      "text": "On a router with a large amount of multicast state, the number of entries that must be included may result in packets that are larger than the maximum IP packet size. In most such cases, the information may be split into multiple messages.",
      "ja": "マルチキャスト状態の大量有するルータで、含まれていなければならないエントリの数は、最大IPパケットサイズよりも大きいパケットをもたらすことができます。ほとんどのこのような場合には、情報が複数のメッセージに分割することができます。"
    },
    {
      "indent": 3,
      "text": "There is an exception with group sets that contain a (*,G) Joined source list entry. The group set expresses the router's interest in receiving all traffic for the specified group on the shared tree, and it MUST include an (S,G,rpt) Pruned source list entry for every source that the router does not wish to receive. This list of (S,G,rpt) Pruned source-list entries MUST not be split in multiple messages.",
      "ja": "（*、G）結合Sourceリストエントリを含むグループセットとの例外があります。グループセットは共有ツリー上の指定したグループのすべてのトラフィックの受信にルータの関心を表現し、そしてそれは、ルータが受信したくないすべてのソースの（S、G、RPT）剪定ソースリストの項目を含まなければなりません。 （S、G、RPT）のこのリストは、ソースリストのエントリを複数のメッセージに分割されてはいけません剪定します。"
    },
    {
      "indent": 3,
      "text": "If only N (S,G,rpt) Prune entries fit into a maximum-sized Join/Prune message, but the router has more than N (S,G,rpt) Prunes to add, then the router MUST choose to include the first N (numerically smallest in network byte order) IP addresses.",
      "ja": "場合にのみ、N（S、G、RPT）プルーン・エントリは、最大サイズの参加/プルーンメッセージに収まるが、ルータを追加するN（S、G、RPT）プルーン以上を有し、ルータは最初に含めるように選択しなければなりませんN（ネットワークバイト順で数値的に最小の）IPアドレス。"
    },
    {
      "indent": 0,
      "text": "4.9.6. Assert Message Format",
      "section_title": true,
      "ja": "4.9.6。メッセージフォーマットをアサート"
    },
    {
      "indent": 3,
      "text": "The Assert message is used to resolve forwarder conflicts between routers on a link. It is sent when a router receives a multicast data packet on an interface on which the router would normally have forwarded that packet. Assert messages may also be sent in response to an Assert message from another router.",
      "ja": "アサートメッセージは、リンク上のルータ間のフォワーダの競合を解決するために使用されます。ルータは、ルータが正常にそのパケットを転送しているだろうしたインターフェイス上のマルチキャストデータパケットを受信したときに送信されます。アサートメッセージも別のルータからのAssertメッセージに応答して送信することができます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|PIM Ver| Type  |   Reserved    |           Checksum            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|              Group Address (Encoded-Group format)             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Source Address (Encoded-Unicast format)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|R|                      Metric Preference                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Metric                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "PIM Version, Type, Reserved, Checksum Described in Section 4.9.",
      "ja": "PIMバージョン、タイプは、予約済み、チェックサムは、4.9節で説明します。"
    },
    {
      "indent": 3,
      "text": "Group Address The group address for which the router wishes to resolve the forwarding conflict. This is an Encoded-Group address, as specified in Section 4.9.1.",
      "ja": "グループでは、ルータが転送の競合を解決することを希望するグループアドレス。セクション4.9.1で指定されたように、これは、エンコード・グループアドレスです。"
    },
    {
      "indent": 3,
      "text": "Source Address Source address for which the router wishes to resolve the forwarding conflict. The source address MAY be set to zero for (*,G) asserts (see below). The format for this address is given in Encoded-Unicast-Address in Section 4.9.1.",
      "ja": "ルータが転送競合を解決することを望むの送信元アドレスを送信元アドレス。送信元アドレスは、（*、G）がゼロに設定されてもよい（下記参照）をアサートします。このアドレスの形式は、セクション4.9.1でエンコードされたユニキャスト・アドレスに与えられています。"
    },
    {
      "indent": 3,
      "text": "R RPT-bit is a 1-bit value. The RPT-bit is set to 1 for Assert(*,G) messages and 0 for Assert(S,G) messages.",
      "ja": "R RPTビットは、1ビットの値です。 RPTビットはアサート（S、G）メッセージにアサート（*、G）メッセージのための1と0に設定されています。"
    },
    {
      "indent": 3,
      "text": "Metric Preference Preference value assigned to the unicast routing protocol that provided the route to the multicast source or Rendezvous-Point.",
      "ja": "マルチキャストソースまたはランデブーポイントへの経路を提供し、ユニキャストルーティングプロトコルに割り当てられたメトリック嗜好プリファレンス値。"
    },
    {
      "indent": 3,
      "text": "Metric The unicast routing table metric associated with the route used to reach the multicast source or Rendezvous-Point. The metric is in units applicable to the unicast routing protocol used.",
      "ja": "メトリックユニキャストルーティングテーブルメトリックは、マルチキャストソースまたはランデブーポイントに到達するために使用される経路に関連付けられています。メトリックは、使用されるユニキャストルーティングプロトコルに適用単位です。"
    },
    {
      "indent": 3,
      "text": "Assert messages can be sent to resolve a forwarding conflict for all traffic to a given group or for a specific source and group.",
      "ja": "アサートメッセージが与えられたグループまたは特定のソースおよびグループのすべてのトラフィックの転送競合を解決するために送信することができます。"
    },
    {
      "indent": 3,
      "text": "Assert(S,G) Source-specific asserts are sent by routers forwarding a specific source on the shortest-path tree (SPTbit is TRUE). (S,G) Asserts have the Group-Address field set to the group G and the Source-Address field set to the source S. The RPT-bit is set to 0, the Metric-Preference is set to MRIB.pref(S) and the Metric is set to MRIB.metric(S).",
      "ja": "（S、G）ソース固有のアサートアサートする（SPTbitがTRUEである）最短パス木の特定のソースを転送するルータによって送信されます。 （S、G）は、グループGおよびSザRPTビットは0に設定されているソースに設定ソースアドレスフィールドに設定されたグループアドレスフィールドがアサートメトリック好ましくはMRIB.pref（Sに設定されています）とメトリックはMRIB.metric（S）に設定されています。"
    },
    {
      "indent": 3,
      "text": "Assert(*,G) Group-specific asserts are sent by routers forwarding data for the group and source(s) under contention on the shared tree. (*,G) asserts have the Group-Address field set to the group G. For data-triggered Asserts, the Source-Address field MAY be set to the IP source address of the data packet that triggered the Assert and is set to zero otherwise. The RPT-bit is set to 1, the Metric-Preference is set to MRIB.pref(RP(G)), and the Metric is set to MRIB.metric(RP(G)).",
      "ja": "アサート（*、G）グループ固有のアサートは、共有ツリー上の競合下でグループ及びソース（S）のデータを転送するルータによって送信されます。 （*、G）は、データ・トリガアサート、ソース・アドレス・フィールドはアサートをトリガーし、ゼロに設定されているデータパケットの送信元IPアドレスに設定されるかもしれについてグループGに設定し、グループアドレスフィールドを持って主張しますそうでなければ。 RPTビットが1に設定され、メトリック好ましくはMRIB.pref（RP（G））に設定され、メトリックはMRIB.metric（RP（G））に設定されています。"
    },
    {
      "indent": 0,
      "text": "4.10. PIM Timers",
      "section_title": true,
      "ja": "10.4。 PIMタイマー"
    },
    {
      "indent": 3,
      "text": "PIM-SM maintains the following timers, as discussed in Section 4.1. All timers are countdown timers; they are set to a value and count down to zero, at which point they typically trigger an action. Of course they can just as easily be implemented as count-up timers, where the absolute expiry time is stored and compared against a real-time clock, but the language in this specification assumes that they count downwards to zero.",
      "ja": "4.1節で述べたようにPIM-SMは、次のタイマーを維持します。すべてのタイマーはカウントダウンタイマーです。彼らは、値に設定され、それらは、典型的にはアクションをトリガその時点でゼロにカウントダウンされます。もちろん、彼らは同じように簡単に絶対有効期限の時間は、リアルタイムクロックに対して保存され、比較され、カウントアップタイマー、として実装されますが、この仕様では、言語は、彼らがゼロに下向きに数えることを前提としてすることができます。"
    },
    {
      "indent": 3,
      "text": "Global Timers",
      "ja": "グローバル営業時間"
    },
    {
      "indent": 3,
      "text": "Per interface (I):",
      "ja": "インターフェイスごとに（I）："
    },
    {
      "indent": 8,
      "text": "Hello Timer: HT(I)",
      "ja": "こんにちはタイマー：HT（I）"
    },
    {
      "indent": 8,
      "text": "Per neighbor (N):",
      "ja": "隣人（N）あたり："
    },
    {
      "indent": 13,
      "text": "Neighbor Liveness Timer: NLT(N,I)",
      "ja": "近隣ライブネスタイマー：NLT（N、I）"
    },
    {
      "indent": 8,
      "text": "Per active RP (RP):",
      "ja": "あたりのアクティブRP（RP）："
    },
    {
      "indent": 13,
      "text": "(*,*,RP) Join Expiry Timer: ET(*,*,RP,I)",
      "ja": "（*、*、RP）が有効期限タイマーに参加：ET（*、*、RP、I）"
    },
    {
      "indent": 13,
      "text": "(*,*,RP) Prune-Pending Timer: PPT(*,*,RP,I)",
      "ja": "（*、*、RP）プルーン-保留タイマー：PPT（*、*、RP、I）"
    },
    {
      "indent": 8,
      "text": "Per Group (G):",
      "ja": "グループごと（G）："
    },
    {
      "indent": 13,
      "text": "(*,G) Join Expiry Timer: ET(*,G,I) (*,G) Prune-Pending Timer: PPT(*,G,I)",
      "ja": "（*、G）が有効期限タイマーに参加：ET（*、G、I）（*、G）プルーン-保留タイマー：PPT（*、G、I）"
    },
    {
      "indent": 13,
      "text": "(*,G) Assert Timer: AT(*,G,I)",
      "ja": "（*、G）アサートタイマー：AT（*、G、I）"
    },
    {
      "indent": 13,
      "text": "Per Source (S):",
      "ja": "パーソース（S）："
    },
    {
      "indent": 18,
      "text": "(S,G) Join Expiry Timer: ET(S,G,I)",
      "ja": "（S、G）参加期限タイマー：ET（S、G、I）"
    },
    {
      "indent": 18,
      "text": "(S,G) Prune-Pending Timer: PPT(S,G,I)",
      "ja": "（S、G）プルーン保留タイマー：PPT（S、G、I）"
    },
    {
      "indent": 18,
      "text": "(S,G) Assert Timer: AT(S,G,I)",
      "ja": "（S、G）アサートタイマー：AT（S、G、I）"
    },
    {
      "indent": 18,
      "text": "(S,G,rpt) Prune Expiry Timer: ET(S,G,rpt,I)",
      "ja": "（S、G、RPT）プルーン期限タイマー：ET（S、G、RPT、I）"
    },
    {
      "indent": 18,
      "text": "(S,G,rpt) Prune-Pending Timer: PPT(S,G,rpt,I)",
      "ja": "（S、G、RPT）プルーン保留タイマー：PPT（S、G、RPT、I）"
    },
    {
      "indent": 3,
      "text": "Per active RP (RP):",
      "ja": "あたりのアクティブRP（RP）："
    },
    {
      "indent": 8,
      "text": "(*,*,RP) Upstream Join Timer: JT(*,*,RP)",
      "ja": "（*、*、RP）上流はタイマーに参加：JT（*、*、RP）"
    },
    {
      "indent": 3,
      "text": "Per Group (G):",
      "ja": "グループごと（G）："
    },
    {
      "indent": 8,
      "text": "(*,G) Upstream Join Timer: JT(*,G)",
      "ja": "（*、G）上流のタイマーに参加：JT（*、G）"
    },
    {
      "indent": 8,
      "text": "Per Source (S):",
      "ja": "パーソース（S）："
    },
    {
      "indent": 13,
      "text": "(S,G) Upstream Join Timer: JT(S,G)",
      "ja": "JT（S、G）：（S、G）上流タイマに参加します"
    },
    {
      "indent": 13,
      "text": "(S,G) Keepalive Timer: KAT(S,G)",
      "ja": "（S、G）キープアライブタイマー：KAT（S、G）"
    },
    {
      "indent": 13,
      "text": "(S,G,rpt) Upstream Override Timer: OT(S,G,rpt)",
      "ja": "（S、G、RPT）上流オーバーライドタイマ：OT（S、G、RPT）"
    },
    {
      "indent": 3,
      "text": "At the DRs or relevant Assert Winners only:",
      "ja": "DRまたは関連するアサート受賞者だけでは："
    },
    {
      "indent": 8,
      "text": "Per Source,Group pair (S,G):",
      "ja": "ソースごと、グループのペア（S、G）："
    },
    {
      "indent": 13,
      "text": "Register-Stop Timer: RST(S,G)",
      "ja": "登録ストップタイマー：RST（S、G）"
    },
    {
      "indent": 0,
      "text": "4.11. Timer Values",
      "section_title": true,
      "ja": "4.11。タイマー値"
    },
    {
      "indent": 3,
      "text": "When timers are started or restarted, they are set to default values. This section summarizes those default values.",
      "ja": "タイマーが起動または再起動されると、それらはデフォルト値に設定されています。ここでは、これらのデフォルト値をまとめたもの。"
    },
    {
      "indent": 3,
      "text": "Note that protocol events or configuration may change the default value of a timer on a specific interface. When timers are initialized in this document, the value specific to the interface in context must be used.",
      "ja": "プロトコルイベントや設定は、特定のインターフェイス上のタイマーのデフォルト値を変更することがあります。タイマーが本書で初期化されている場合は、コンテキストのインターフェイスに特定の値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some of the timers listed below (Prune-Pending, Upstream Join, Upstream Override) can be set to values that depend on the settings of the Propagation_Delay and Override_Interval of the corresponding interface. The default values for these are given below.",
      "ja": "下記タイマーの一部は、対応するインターフェースのPROPAGATION_DELAYとOverride_Intervalの設定に依存する値に設定することができる（プルーン-保留は、アップストリームは、アップストリームオーバーライドに参加します）。これらのデフォルト値は以下の通りです。"
    },
    {
      "indent": 3,
      "text": "Variable Name: Propagation_Delay(I)",
      "ja": "変数名：PROPAGATION_DELAY（I）"
    },
    {
      "indent": 0,
      "text": "+-------------------------------+--------------+----------------------+\n|  Value Name                   |  Value       |  Explanation         |\n+-------------------------------+--------------+----------------------+\n|  Propagation_delay_default    |  0.5 secs    |  Expected            |\n|                               |              |  propagation delay   |\n|                               |              |  over the local      |\n|                               |              |  link.               |\n+-------------------------------+--------------+----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The default value of the Propagation_delay_default is chosen to be relatively large to provide compatibility with older PIM implementations.",
      "ja": "Propagation_delay_defaultのデフォルト値は古いPIM実装との互換性を提供するために比較的大きくなるように選択されます。"
    },
    {
      "indent": 3,
      "text": "Variable Name: Override_Interval(I)",
      "ja": "変数名：Override_Interval（I）"
    },
    {
      "indent": 0,
      "text": "+--------------------------+-----------------+-------------------------+\n|  Value Name              |    Value        |    Explanation          |\n+--------------------------+-----------------+-------------------------+\n|  t_override_default      |    2.5 secs     |    Default delay        |\n|                          |                 |    interval over        |\n|                          |                 |    which to randomize   |\n|                          |                 |    when scheduling a    |\n|                          |                 |    delayed Join         |\n|                          |                 |    message.             |\n+--------------------------+-----------------+-------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Timer Name: Hello Timer (HT(I))",
      "ja": "タイマー名前：こんにちはタイマー（HT（I））"
    },
    {
      "indent": 0,
      "text": "+---------------------+--------+---------------------------------------+\n|Value Name           | Value  | Explanation                           |\n+---------------------+--------+---------------------------------------+\n|Hello_Period         | 30 secs| Periodic interval for Hello messages. |\n+---------------------+--------+---------------------------------------+\n|Triggered_Hello_Delay| 5 secs | Randomized interval for initial Hello |\n|                     |        | message on bootup or triggered Hello  |\n|                     |        | message to a rebooting neighbor.      |\n+---------------------+--------+---------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "At system power-up, the timer is initialized to rand(0, Triggered_Hello_Delay) to prevent synchronization. When a new or rebooting neighbor is detected, a responding Hello is sent within rand(0, Triggered_Hello_Delay).",
      "ja": "システムのパワーアップ時に、タイマが同期化を防ぐためのrand（0、Triggered_Hello_Delay）に初期化されます。新規または再起動ネイバーが検出されると、応答こんにちはは、ランド（0、Triggered_Hello_Delay）内で送信されます。"
    },
    {
      "indent": 3,
      "text": "Timer Name: Neighbor Liveness Timer (NLT(N,I))",
      "ja": "タイマー名：隣人ライブネスタイマー（NLT（N、I））"
    },
    {
      "indent": 0,
      "text": "+--------------------------+----------------------+--------------------+\n| Value Name               |  Value               |  Explanation       |\n+--------------------------+----------------------+--------------------+\n| Default_Hello_Holdtime   |  3.5 * Hello_Period  |  Default holdtime  |\n|                          |                      |  to keep neighbor  |\n|                          |                      |  state alive       |\n+--------------------------+----------------------+--------------------+\n| Hello_Holdtime           |  from message        |  Holdtime from     |\n|                          |                      |  Hello Message     |\n|                          |                      |  Holdtime option.  |\n+--------------------------+----------------------+--------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Holdtime in a Hello Message should be set to (3.5 * Hello_Period), giving a default value of 105 seconds.",
      "ja": "こんにちは、メッセージでのホールドタイムは105秒のデフォルト値を与える、（3.5 * Hello_Period）に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Timer Names: Expiry Timer (ET(*,*,RP,I), ET(*,G,I), ET(S,G,I), ET(S,G,rpt,I))",
      "ja": "H名称：タイマ満了（ET（*、*、RP、I）、（*、G、I）、（S、G、I）、（S、G、RPT、I））"
    },
    {
      "indent": 0,
      "text": "+----------------+----------------+------------------------------------+\n| Value Name     |  Value         |  Explanation                       |\n+----------------+----------------+------------------------------------+\n| J/P_HoldTime   |  from message  |  Holdtime from Join/Prune Message  |\n+----------------+----------------+------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "See details of JT(*,G) for the Holdtime that is included in Join/Prune Messages.",
      "ja": "参加に含まれているホールドタイムの​​ためのJT（*、G）の詳細/プルーンのメッセージを参照してください。"
    },
    {
      "indent": 3,
      "text": "Timer Names: Prune-Pending Timer (PPT(*,*,RP,I), PPT(*,G,I), PPT(S,G,I), PPT(S,G,rpt,I))",
      "ja": "タイマー名：プルーン-保留タイマー（PPT（*、*、RP、I）、PPT（*、G、I）、PPT（S、G、I）、PPT（S、G、RPT、I））"
    },
    {
      "indent": 0,
      "text": "+--------------------------+---------------------+---------------------+\n|Value Name                | Value               | Explanation         |\n+--------------------------+---------------------+---------------------+\n|J/P_Override_Interval(I)  | Default:            | Short period after  |\n|                          | Effective_          | a join or prune to  |\n|                          | Propagation_        | allow other         |\n|                          | Delay(I) +          | routers on the LAN  |\n|                          | EffectiveOverride_  | to override the     |\n|                          | Interval(I)         | join or prune       |\n+--------------------------+---------------------+---------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that both the Effective_Propagation_Delay(I) and the Effective_Override_Interval(I) are interface-specific values that may change when Hello messages are received (see Section 4.3.3).",
      "ja": "Effective_Propagation_Delay（I）及びEffective_Override_Interval（I）の両方が（セクション4.3.3を参照）Helloメッセージを受信したときに変更することができるインタフェース固有の値であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Timer Names: Assert Timer (AT(*,G,I), AT(S,G,I))",
      "ja": "タイマー名：アサートタイマー（AT（*、G、I）、AT（S、G、I））"
    },
    {
      "indent": 0,
      "text": "+---------------------------+---------------------+--------------------+\n| Value Name                | Value               | Explanation        |\n+---------------------------+---------------------+--------------------+\n| Assert_Override_Interval  | Default: 3 secs     | Short interval     |\n|                           |                     | before an assert   |\n|                           |                     | times out where    |\n|                           |                     | the assert winner  |\n|                           |                     | resends an Assert  |\n|                           |                     | message            |\n+---------------------------+---------------------+--------------------+\n| Assert_Time               | Default: 180 secs   | Period after last  |\n|                           |                     | assert before      |\n|                           |                     | assert state is    |\n|                           |                     | timed out          |\n+---------------------------+---------------------+--------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that for historical reasons, the Assert message lacks a Holdtime field. Thus, changing the Assert Time from the default value is not recommended.",
      "ja": "歴史的な理由のために、アサートメッセージはホールドタイムフィールドを欠いていることに留意されたいです。このように、デフォルト値からアサート期間を変更することは推奨されません。"
    },
    {
      "indent": 3,
      "text": "Timer Names: Upstream Join Timer (JT(*,*,RP), JT(*,G), JT(S,G))",
      "ja": "タイマー名：上流は、タイマー（JT（*、*、RP）、JT（*、G）、JT（S、G））を参加"
    },
    {
      "indent": 0,
      "text": "+-------------+--------------------+-----------------------------------+\n|Value Name   | Value              | Explanation                       |\n+-------------+--------------------+-----------------------------------+\n|t_periodic   | Default: 60 secs   | Period between Join/Prune Messages|\n+-------------+--------------------+-----------------------------------+\n|t_suppressed | rand(1.1 *         | Suppression period when someone   |\n|             | t_periodic, 1.4 *  | else sends a J/P message so we    |\n|             | t_periodic) when   | don't need to do so.              |\n|             | Suppression_       |                                   |\n|             | Enabled(I) is      |                                   |\n|             | true, 0 otherwise  |                                   |\n+-------------+--------------------+-----------------------------------+\n|t_override   | rand(0, Effective_ | Randomized delay to prevent       |\n|             | Override_          | response implosion when sending a |\n|             | Interval(I))       | join message to override someone  |\n|             |                    | else's Prune message.             |\n+-------------+--------------------+-----------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "t_periodic may be set to take into account such things as the configured bandwidth and expected average number of multicast route entries for the attached network or link (e.g., the period would be longer for lower-speed links, or for routers in the center of the network that expect to have a larger number of entries). If the Join/Prune-Period is modified during operation, these changes should be made relatively infrequently, and the router should continue to refresh at its previous Join/Prune-Period for at least Join/Prune-Holdtime, in order to allow the upstream router to adapt.",
      "ja": "t_periodicのアカウントに設定された帯域幅のようなものを取るように設定し、接続されたネットワークまたはリンクのためのマルチキャストルートエントリの平均数を予想（例えば、期間は低速リンクのため、またはの中心にあるルータに長くなりすることができますエントリのより大きな数を持つことを期待ネットワーク）。参加/プルーン期間は動作中に変更された場合、これらの変更は比較的まれにしか行われるべきである、とルータは、上流を可能にするために、少なくとも/プルーン-ホールドタイム参加のために、以前の参加/プルーン期間でリフレッシュし続けなければなりません適応するルータ。"
    },
    {
      "indent": 3,
      "text": "The holdtime specified in a Join/Prune message should be set to (3.5 * t_periodic).",
      "ja": "参加/プルーンのメッセージで指定されたホールドタイムは（3.5 * t_periodic）に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "t_override depends on the Effective_Override_Interval of the upstream interface, which may change when Hello messages are received.",
      "ja": "t_overrideは、Helloメッセージを受信したときに変更することができる上流インタフェースのEffective_Override_Interval、に依存します。"
    },
    {
      "indent": 3,
      "text": "t_suppressed depends on the Suppression State of the upstream interface (Section 4.3.3) and becomes zero when suppression is disabled.",
      "ja": "t_suppressed上流インタフェース（4.3.3）の抑制状態に依存して抑制が無効になっているときにはゼロとなります。"
    },
    {
      "indent": 3,
      "text": "Timer Name: Upstream Override Timer (OT(S,G,rpt))",
      "ja": "タイマ名：上流タイマー（OT（S、G、RPT））をオーバーライド"
    },
    {
      "indent": 0,
      "text": "+---------------+--------------------------+---------------------------+\n| Value Name    | Value                    |  Explanation              |\n+---------------+--------------------------+---------------------------+\n| t_override    | see Upstream Join Timer  |  see Upstream Join Timer  |\n+---------------+--------------------------+---------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The upstream Override Timer is only ever set to t_override; this value is defined in the section on Upstream Join Timers.",
      "ja": "上流のオーバーライドタイマーがしかt_overrideに設定されています。この値は、上流のセクションで定義されているタイマーに参加。"
    },
    {
      "indent": 3,
      "text": "Timer Name: Keepalive Timer (KAT(S,G))",
      "ja": "タイマ名：キープアライブタイマー（KAT（S、G））"
    },
    {
      "indent": 0,
      "text": "+-----------------------+-----------------------+----------------------+\n| Value Name            |  Value                |  Explanation         |\n+-----------------------+-----------------------+----------------------+\n| Keepalive_Period      |  Default: 210 secs    |  Period after last   |\n|                       |                       |  (S,G) data packet   |\n|                       |                       |  during which (S,G)  |\n|                       |                       |  Join state will be  |\n|                       |                       |  maintained even in  |\n|                       |                       |  the absence of      |\n|                       |                       |  (S,G) Join          |\n|                       |                       |  messages.           |\n+-----------------------+-----------------------+----------------------+\n| RP_Keepalive_Period   |  ( 3 * Register_      |  As                  |\n|                       |  Suppression_Time )   |  Keepalive_Period,   |\n|                       |  + Register_          |  but at the RP when  |\n|                       |  Probe_Time           |  a Register-Stop is  |\n|                       |                       |  sent.               |\n+-----------------------+-----------------------+----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The normal keepalive period for the KAT(S,G) defaults to 210 seconds. However, at the RP, the keepalive period must be at least the Register_Suppression_Time, or the RP may time out the (S,G) state before the next Null-Register arrives. Thus, the KAT(S,G) is set to max(Keepalive_Period, RP_Keepalive_Period) when a Register-Stop is sent.",
      "ja": "210秒KAT（S、G）のデフォルトの通常のキープアライブ期間。しかしながら、RPで、キープアライブ期間が少なくともRegister_Suppression_Timeなければならない、または次のヌル・レジスタが到着する前にRPは（S、G）ステートをタイムアウトすることができます。したがって、KAT（S、G）は、レジスタ・ストップが送信されるMAX（Keepalive_Period、RP_Keepalive_Period）に設定されています。"
    },
    {
      "indent": 3,
      "text": "Timer Name: Register-Stop Timer (RST(S,G))",
      "ja": "タイマー名：登録ストップタイマ（RST（S、G））"
    },
    {
      "indent": 0,
      "text": "+---------------------------+--------------------+---------------------+\n|Value Name                 | Value              | Explanation         |\n+---------------------------+--------------------+---------------------+\n|Register_Suppression_Time  | Default: 60 secs   | Period during       |\n|                           |                    | which a DR stops    |\n|                           |                    | sending Register-   |\n|                           |                    | encapsulated data   |\n|                           |                    | to the RP after     |\n|                           |                    | receiving a         |\n|                           |                    | Register-Stop       |\n|                           |                    | message.            |\n+---------------------------+--------------------+---------------------+\n|Register_Probe_Time        | Default: 5 secs    | Time before RST     |\n|                           |                    | expires when a DR   |\n|                           |                    | may send a Null-    |\n|                           |                    | Register to the RP  |\n|                           |                    | to cause it to      |\n|                           |                    | resend a Register-  |\n|                           |                    | Stop message.       |\n+---------------------------+--------------------+---------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the Register_Suppression_Time or the Register_Probe_Time are configured to values other than the defaults, it MUST be ensured that the value of the Register_Probe_Time is less than half the value of the Register_Suppression_Time to prevent a possible negative value in the setting of the Register-Stop Timer.",
      "ja": "Register_Suppression_Time又はRegister_Probe_Timeがデフォルト以外の値に設定されている場合、Register_Probe_Timeの値はレジスタ・ストップタイマの設定で可能な負の値を防ぐためRegister_Suppression_Timeの半分以下の値であることが保証されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "5.1. PIM Address Family",
      "section_title": true,
      "ja": "5.1。 PIMアドレスファミリ"
    },
    {
      "indent": 3,
      "text": "The PIM Address Family field was chosen to be 8 bits as a tradeoff between packet format and use of the IANA assigned numbers. Because when the PIM packet format was designed only 15 values were assigned for Address Families, and large numbers of new Address Family values were not envisioned, 8 bits seemed large enough. However, the IANA assigns Address Families in a 16-bit field. Therefore, the PIM Address Family is allocated as follows:",
      "ja": "PIMアドレスファミリフィールドは、IANA割り当てられた番号のパケットフォーマットと使用との間のトレードオフとして8ビットとなるように選択しました。 PIMパケットフォーマットは、わずか15の値がアドレスファミリ用に割り当てられていた設計された、新しいアドレスファミリ値の多くが想定されていなかったときなので、8ビットが十分に大きいように見えました。しかし、IANAは、16ビットのフィールドでアドレスファミリを割り当てます。次のようにそのため、PIMアドレスファミリが割り当てられています："
    },
    {
      "indent": 5,
      "text": "Values 0 through 127 are designated to have the same meaning as IANA-assigned Address Family Numbers [7].",
      "ja": "127までの値0は、IANAによって割り当てられたアドレスファミリ番号と同じ意味を持つように指定されている[7]。"
    },
    {
      "indent": 5,
      "text": "Values 128 through 250 are designated to be assigned for PIM by the IANA based upon IESG Approval, as defined in [9].",
      "ja": "250を介して128の値は、[9]で定義されるように、IESGの承認に基づいて、IANAによってPIMのために割り当てられるように指定されています。"
    },
    {
      "indent": 5,
      "text": "Values 251 through 255 are designated for Private Use, as defined in [9].",
      "ja": "で定義されている255までの値251は、私的使用のために指定されている[9]。"
    },
    {
      "indent": 0,
      "text": "5.2. PIM Hello Options",
      "section_title": true,
      "ja": "5.2。 PIMこんにちはオプション"
    },
    {
      "indent": 3,
      "text": "Values 17 through 65000 are to be assigned by the IANA. Since the space is large, they may be assigned as First Come First Served as defined in [9]. Such assignments are valid for one year and may be renewed. Permanent assignments require a specification (see \"Specification Required\" in [9].)",
      "ja": "65000までの値17は、IANAによって割り当てられることになっています。スペースが大きいため、[9]で定義されるようにまず最初に配信来るように、それらが割り当てられてもよいです。このような割り当ては1年間有効で、更新することができます。永久的な割り当ては、（[9]に「仕様が必要」を参照。）仕様を必要とします"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes various possible security concerns related to the PIM-SM protocol, including a description of how to use IPsec to secure the protocol. The reader is referred to [15] and [16] for further discussion of PIM-SM and multicast security. The IPsec authentication header [8] MAY be used to provide data integrity protection and groupwise data origin authentication of PIM protocol messages. Authentication of PIM messages can protect against unwanted behaviors caused by unauthorized or altered PIM messages.",
      "ja": "このセクションでは、プロトコルを保護するためにIPsecを使用する方法の説明を含むPIM-SMプロトコルに関連する様々な可能性のあるセキュリティの問題について説明します。読者は、PIM-SMおよびマルチキャストセキュリティのさらなる議論については[15]及び[16]と呼ばれます。 IPsec認証ヘッダ[8] PIMプロトコルメッセージのデータ保全性保護およびGroupWiseデータ発信元認証を提供するために使用され得ます。 PIMメッセージの認証は、不正または変更されたPIMメッセージによって引き起こされる不必要な行動から保護することができます。"
    },
    {
      "indent": 0,
      "text": "6.1. Attacks Based on Forged Messages",
      "section_title": true,
      "ja": "6.1。鍛造メッセージに基づく攻撃"
    },
    {
      "indent": 3,
      "text": "The extent of possible damage depends on the type of counterfeit messages accepted. We next consider the impact of possible forgeries, including forged link-local (Join/Prune, Hello, and Assert) and forged unicast (Register and Register-Stop) messages.",
      "ja": "損傷の程度は受け入れられた偽造メッセージの種類によって異なります。私たちは、次の鍛造リンクローカル（/プルーン、こんにちは、とアサートへの参加）と鍛造ユニキャスト（とレジスタ・ストップ）メッセージを含む可能偽造の影響を考慮する。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Forged Link-Local Messages",
      "section_title": true,
      "ja": "6.1.1。鍛造リンクローカルメッセージ"
    },
    {
      "indent": 3,
      "text": "Join/Prune, Hello, and Assert messages are all sent to the link-local ALL_PIM_ROUTERS multicast addresses and thus are not forwarded by a compliant router. A forged message of this type can only reach a LAN if it was sent by a local host or if it was allowed onto the LAN by a compromised or non-compliant router.",
      "ja": "こんにちは/プルーンを、参加、およびアサートメッセージは、すべてのマルチキャストアドレスリンクローカルALL_PIM_ROUTERSに送信され、これに準拠し、ルータによって転送されません。それがローカルホストによって送信された場合や、それが危険にさらさまたは非準拠のルータでLAN上に許可された場合には、この種の偽造メッセージは、LANに到達することができます。"
    },
    {
      "indent": 3,
      "text": "1. A forged Join/Prune message can cause multicast traffic to be delivered to links where there are no legitimate requesters, potentially wasting bandwidth on that link. A forged leave message on a multi-access LAN is generally not a significant attack in PIM, because any legitimately joined router on the LAN would override the leave with a join before the upstream router stops forwarding data to the LAN.",
      "ja": "1. Aはプルーンのメッセージは、マルチキャストトラフィックが潜在的にそのリンク上の帯域幅を浪費し、正当な要求者が存在しないリンクに配信されることがあります/参加鍛造しました。いずれかが合法的に上流のルータは、LANへのデータの転送を停止する前に、LAN上のルータが参加して休暇をオーバーライドします参加しているため、マルチアクセスLAN上の偽造Leaveメッセージは、一般的にPIMの重要な攻撃ではありません。"
    },
    {
      "indent": 3,
      "text": "2. By forging a Hello message, an unauthorized router can cause itself to be elected as the designated router on a LAN. The designated router on a LAN is (in the absence of asserts) responsible for forwarding traffic to that LAN on behalf of any local members. The designated router is also responsible for register-encapsulating to the RP any packets that are originated by hosts on the LAN. Thus, the ability of local hosts to send and receive multicast traffic may be compromised by a forged Hello message.",
      "ja": "2. Helloメッセージを鍛造することにより、不正なルータは自身がLAN上の指定ルータとして選出されることがあります。 LAN上の指定ルータは（が存在しない場合にアサート）任意のローカルメンバーに代わってそのLANにトラフィックを転送する責任があります。指定されたルータは、レジスタ封入RPにLAN上のホストから発信されているすべてのパケットをする責任があります。このように、マルチキャストトラフィックを送受信するローカルホストの能力は、偽造Helloメッセージによって損なわれる可能性があります。"
    },
    {
      "indent": 3,
      "text": "3. By forging an Assert message on a multi-access LAN, an attacker could cause the legitimate designated forwarder to stop forwarding traffic to the LAN. Such a forgery would prevent any hosts downstream of that LAN from receiving traffic.",
      "ja": "3.マルチアクセスLAN上のAssertメッセージを鍛造することにより、攻撃者は正当な指定フォワーダがLANへのトラフィックの転送を停止する可能性があります。このような偽造は、トラフィックを受信して​​いるLANの下流の任意のホストを防止するであろう。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Forged Unicast Messages",
      "section_title": true,
      "ja": "6.1.2。鍛造ユニキャストメッセージ"
    },
    {
      "indent": 3,
      "text": "Register messages and Register-Stop messages are forwarded by intermediate routers to their destination using normal IP forwarding. Without data origin authentication, an attacker who is located anywhere in the network may be able to forge a Register or Register-Stop message. We consider the effect of a forgery of each of these messages next.",
      "ja": "メッセージを登録し、登録-STOPメッセージは、通常のIP転送を使用して、その先に中間ルータによって転送されます。データ発信元認証、登録を偽造または登録-Stopメッセージをすることができるかもしれネットワーク内の任意の場所に位置して攻撃者はなし。私たちは、次のようなメッセージのそれぞれの偽造の影響を考慮してください。"
    },
    {
      "indent": 3,
      "text": "1. By forging a Register message, an attacker can cause the RP to inject forged traffic onto the shared multicast tree.",
      "ja": "1. Registerメッセージを鍛造することにより、攻撃者は共有マルチキャストツリー上に偽造トラフィックを注入するためにRPを引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "2. By forging a Register-stop message, an attacker can prevent a legitimate DR from Registering packets to the RP. This can prevent local hosts on that LAN from sending multicast packets.",
      "ja": "2.登録停止メッセージを鍛造により、攻撃者は、RPにパケットを登録から正当DRを防止することができます。これは、マルチキャストパケットを送信してから、そのLAN上のローカルホストを防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "The above two PIM messages are not changed by intermediate routers and need only be examined by the intended receiver. Thus, these messages can be authenticated end-to-end, using AH. Attacks on Register and Register-Stop messages do not apply to a PIM-SSM-only implementation, as these messages are not required for PIM-SSM.",
      "ja": "上記の二つのPIMメッセージは、中間ルータによって変更されないとのみ意図され、受信機により検査される必要があります。したがって、これらのメッセージは、AHを使用して、エンドツーエンドを認証することができます。これらのメッセージは、PIM-SSMのために必要とされていないとして登録への攻撃と登録-STOPメッセージは、PIM-SSMのみの実装には適用されません。"
    },
    {
      "indent": 0,
      "text": "6.2. Non-Cryptographic Authentication Mechanisms",
      "section_title": true,
      "ja": "6.2。非暗号化認証メカニズム"
    },
    {
      "indent": 3,
      "text": "A PIM router SHOULD provide an option to limit the set of neighbors from which it will accept Join/Prune, Assert, and Hello messages. Either static configuration of IP addresses or an IPsec security association may be used. Furthermore, a PIM router SHOULD NOT accept protocol messages from a router from which it has not yet received a valid Hello message.",
      "ja": "PIMルータは、それが/プルーン、アサート、およびHelloメッセージを参加受け入れるから、隣人のセットを制限するためのオプションを提供する必要があります。静的IPアドレスの設定やIPsecセキュリティ協会のどちらかを使用することができます。さらに、PIMルータは、それがまだ有効なHelloメッセージを受信して​​いない元のルータからのプロトコルメッセージを受け入れるべきではありません。"
    },
    {
      "indent": 3,
      "text": "A Designated Router MUST NOT register-encapsulate a packet and send it to the RP unless the source address of the packet is a legal address for the subnet on which the packet was received. Similarly, a Designated Router SHOULD NOT accept a Register-Stop packet whose IP source address is not a valid RP address for the local domain.",
      "ja": "指定ルータはパケットをカプセル化し、登録し、パケットの送信元アドレスは、パケットを受信したサブネットの法的アドレスでない限りRPにそれを送ってはいけません。同様に、指定ルータは、そのIP送信元アドレスがローカルドメインの有効なRPアドレスではありません登録-停止パケットを受け入れるべきではありません。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD provide a mechanism to allow an RP to restrict the range of source addresses from which it accepts Register-encapsulated packets.",
      "ja": "実装は、それが登録カプセル化パケットを受け入れ、そこからソースアドレスの範囲を制限するRPを可能にするメカニズムを提供するべきです。"
    },
    {
      "indent": 3,
      "text": "All options that restrict the range of addresses from which packets are accepted MUST default to allowing all packets.",
      "ja": "パケットが受け入れられているから、アドレスの範囲を制限するすべてのオプションはすべてのパケットを許可するデフォルトしなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.3. Authentication Using IPsec",
      "section_title": true,
      "ja": "6.3。 IPsecを使用した認証"
    },
    {
      "indent": 3,
      "text": "The IPsec [8] transport mode using the Authentication Header (AH) is the recommended method to prevent the above attacks against PIM. The specific AH authentication algorithm and parameters, including the choice of authentication algorithm and the choice of key, are configured by the network administrator. When IPsec authentication is used, a PIM router should reject (drop without processing) any unauthorized PIM protocol messages.",
      "ja": "認証ヘッダ（AH）を使用したIPsec [8]トランスポートモードは、PIMに対する上記の攻撃を防ぐために推奨される方法です。特定のAH認証アルゴリズムと認証アルゴリズムの選択とキーの選択を含むパラメータは、ネットワーク管理者によって設定されます。 IPsec認証を使用する場合、PIMルータは（処理なしドロップ）不正PIMプロトコルメッセージを拒否すべきです。"
    },
    {
      "indent": 3,
      "text": "To use IPsec, the administrator of a PIM network configures each PIM router with one or more security associations (SAs) and associated Security Parameter Indexes (SPIs) that are used by senders to authenticate PIM protocol messages and are used by receivers to authenticate received PIM protocol messages. This document does not describe protocols for establishing SAs. It assumes that manual configuration of SAs is performed, but it does not preclude the use of a negotiation protocol such as the Internet Key Exchange [14] to establish SAs.",
      "ja": "IPsecを使用するには、PIMネットワークの管理者は、PIMプロトコルメッセージを認証するために送信者によって使用され、受信PIMを認証するための受信機で使用される1つのまたは複数のセキュリティアソシエーション（SA）と関連するセキュリティパラメータインデックス（SPIの）で、各PIMルータを設定しますプロトコルメッセージ。この文書では、SAを確立するためのプロトコルを説明していません。これは、SAの手動設定が行われていることを前提としていますが、それは、SAを確立するために、このようなインターネット鍵交換などネゴシエーションプロトコル[14]の使用を排除するものではありません。"
    },
    {
      "indent": 3,
      "text": "IPsec [8] provides protection against replayed unicast and multicast messages. The anti-replay option for IPsec SHOULD be enabled on all SAs.",
      "ja": "IPsecは、[8]再生ユニキャストおよびマルチキャストメッセージに対する保護を提供します。 IPsecのためのアンチリプレイオプションは、すべてのSAで有効にする必要があります。"
    },
    {
      "indent": 3,
      "text": "The following sections describe the SAs required to protect PIM protocol messages.",
      "ja": "次のセクションでは、PIMプロトコルメッセージを保護するために必要なSAを記述する。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Protecting Link-Local Multicast Messages",
      "section_title": true,
      "ja": "6.3.1。リンクローカルマルチキャストメッセージの保護"
    },
    {
      "indent": 3,
      "text": "The network administrator defines an SA and SPI that are to be used to authenticate all link-local PIM protocol messages (Hello, Join/Prune, and Assert) on each link in a PIM domain.",
      "ja": "ネットワーク管理者は、PIMドメイン内の各リンク上で（こんにちは、/プルーン、およびアサート参加）すべてのリンクローカルPIMプロトコルメッセージを認証するために使用されることをSAとSPIを定義します。"
    },
    {
      "indent": 3,
      "text": "IPsec [8] allows (but does not require) different Security Policy Databases (SPD) for each router interface. If available, it may be desirable to configure the Security Policy Database at a PIM router such that all incoming and outgoing Join/Prune, Assert, and Hello packets use a different SA for each incoming or outgoing interface.",
      "ja": "IPsecは、[8]ことができます（ただし、必須ではありません）、各ルータインターフェイスごとに異なるセキュリティポリシーデータベース（SPD）を。利用可能ならば、それはPIMルータでのセキュリティポリシーデータベースを構成することが望ましいようにすべての着信および/プルーン、アサートに参加し、helloパケットがそれぞれ着信または発信インターフェイスのために別のSAを使用して、発信。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Protecting Unicast Messages",
      "section_title": true,
      "ja": "6.3.2。ユニキャストメッセージを保護します"
    },
    {
      "indent": 3,
      "text": "IPsec can also be used to provide data origin authentication and data integrity protection for the Register and Register-Stop unicast messages.",
      "ja": "IPsecはまた、登録のためのデータ発信元認証およびデータ整合性の保護を提供し、ユニキャストメッセージを登録し、停止するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "6.3.2.1. Register Messages",
      "section_title": true,
      "ja": "6.3.2.1。メッセージを登録します"
    },
    {
      "indent": 3,
      "text": "The Security Policy Database at every PIM router is configured to select an SA to use when sending PIM Register packets to each rendezvous point.",
      "ja": "すべてのPIMルータでのセキュリティポリシーデータベースは、それぞれのランデブーポイントにPIM Registerパケットを送信するときに使用するSAを選択するように構成されています。"
    },
    {
      "indent": 3,
      "text": "In the most general mode of operation, the Security Policy Database at each DR is configured to select a unique SA and SPI for traffic sent to each RP. This allows each DR to have a different authentication algorithm and key to talk to the RP. However, this creates a daunting key management and distribution problem for the network administrator. Therefore, it may be preferable in PIM domains where all Designated Routers are under a single administrative control that the same authentication algorithm parameters (including the key) be used for all Registered packets in a domain, regardless of who are the RP and the DR.",
      "ja": "操作の最も一般的なモードでは、各DRでのセキュリティポリシーデータベースは、各RPに送信されるトラフィックのためのユニークなSAとSPIを選択するように構成されています。これは、各DRはRPに話をするために、異なる認証アルゴリズムとキーを持つことができます。しかし、これは、ネットワーク管理者のための困難な鍵の管理と配布問題を作成します。したがって、それはすべての指定ルータに関係なくRPとDRている人の、（キーを含む）は、同じ認証アルゴリズムパラメータは、ドメインに登録されたすべてのパケットのために使用され、単一の管理制御下にあるPIMドメインに好ましいかもしれません。"
    },
    {
      "indent": 3,
      "text": "In this \"single shared key\" mode of operation, the network administrator must choose an SPI for each DR that will be used to send it PIM protocol packets. The Security Policy Database at every DR is configured to select an SA (including the authentication algorithm, authentication parameters, and this SPI) when sending Register messages to this RP.",
      "ja": "操作のこの「単一の共有キー」モードでは、ネットワーク管理者はそれをPIMプロトコルパケットを送信するために使用される各DRのためのSPIを選択する必要があります。すべてのDRのセキュリティポリシーデータベースは、このRPに登録メッセージを送信するとき（認証アルゴリズム、認証パラメータ、およびこのSPIを含む）SAを選択するように構成されています。"
    },
    {
      "indent": 3,
      "text": "By using a single authentication algorithm and associated parameters, the key distribution problem is simplified. Note, however, that this method has the property that, in order to change the authentication method or authentication key used, all routers in the domain must be updated.",
      "ja": "単一の認証アルゴリズムと関連するパラメータを用いて、鍵配送問題が簡略化されます。この方法は、使用する認証方式や認証キーを変更するためには、ドメイン内のすべてのルータが更新される必要があり、性質を持っていること、しかし、注意してください。"
    },
    {
      "indent": 0,
      "text": "6.3.2.2. Register-Stop Messages",
      "section_title": true,
      "ja": "6.3.2.2。 Register停止メッセージ"
    },
    {
      "indent": 3,
      "text": "Similarly, the Security Policy Database at each Rendezvous Point should be configured to choose an SA to use when sending Register-Stop messages. Because Register-Stop messages are unicast to the destination DR, a different SA and a potentially unique SPI are required for each DR.",
      "ja": "同様に、それぞれのランデブーポイントでのセキュリティポリシーデータベースは、登録・停止のメッセージを送信する際に使用するSAを選択するように設定する必要があります。登録・停止メッセージが送信先DRへのユニキャストであるため、異なるSAおよび潜在的にユニークなSPIは、各DRのために必要とされます。"
    },
    {
      "indent": 3,
      "text": "In order to simplify the management problem, it may be acceptable to use the same authentication algorithm and authentication parameters, regardless of the sending RP and regardless of the destination DR. Although a unique SA is needed for each DR, the same authentication algorithm and authentication algorithm parameters (secret key) can be shared by all DRs and by all RPs.",
      "ja": "管理問題を簡単にするために、関係なく送信RPのかかわらず先DRの、同じ認証アルゴリズムと認証パラメータを使用することが許容されることができます。一意のSAを各DRのために必要とされているが、同じ認証アルゴリズムと認証アルゴリズムパラメータ（秘密鍵）は、すべてのDRによって、すべてのRPで共有することができます。"
    },
    {
      "indent": 0,
      "text": "6.4. Denial-of-Service Attacks",
      "section_title": true,
      "ja": "6.4。サービス拒否攻撃"
    },
    {
      "indent": 3,
      "text": "There are a number of possible denial-of-service attacks against PIM that can be caused by generating false PIM protocol messages or even by generating data false traffic. Authenticating PIM protocol traffic prevents some, but not all, of these attacks. Three of the possible attacks include:",
      "ja": "偽PIMプロトコルメッセージを生成することによって、あるいはデータ虚偽のトラフィックを発生させることによって引き起こされる可能性がPIMに対して実行される可能性のあるサービス拒否攻撃の数があります。 PIMプロトコルトラフィックの認証は、いくつかのを防ぎ、すべてではないが、これらの攻撃の。攻撃の可能性のうち3つは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "- Sending packets to many different group addresses quickly can be a denial-of-service attack in and of itself. This will cause many register-encapsulated packets, loading the DR, the RP, and the routers between the DR and the RP.",
      "ja": " - すぐに多くの異なったグループアドレスにパケットを送信すると、それ自体のサービス拒否攻撃することができます。これはDR、RP、およびDRとRP間のルータをロードし、多くのレジスタカプセル化パケットが発生します。"
    },
    {
      "indent": 3,
      "text": "- Forging Join messages can cause a multicast tree to get set up. A large number of forged joins can consume router resources and result in denial of service.",
      "ja": " -  Joinメッセージを偽造することは、マルチキャストツリーが設定を取得することがあります。鍛造の大多数は、ルータのリソースを消費し、サービス拒否が発生することができます結合します。"
    },
    {
      "indent": 3,
      "text": "- Forging a (*,*,RP) join presents a possibility for a denial-of-service attack by causing all traffic in the domain to flow to the PMBR issuing the join. (*,*,RP) behavior is included here primarily for backwards compatibility with prior revisions of the spec. However, the implementation of (*,*,RP) and PMBR is optional. When using (*,*,RP), the security concerns should be carefully considered.",
      "ja": " - （*、*、RP）に参加を鍛造することは参加発行PMBRに流れるように、ドメイン内のすべてのトラフィックを発生させることにより、サービス拒否攻撃の可能性を提示します。 （*、*、RP）の動作は、主に仕様の前リビジョンとの後方互換性のためにここに含まれています。しかし、の実装（*、*、RP）とPMBRはオプションです。 （*、*、RP）を使用する場合は、セキュリティ上の懸念は、慎重に検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Acknowledgements",
      "section_title": true,
      "ja": "7.謝辞"
    },
    {
      "indent": 3,
      "text": "PIM-SM was designed over many years by a large group of people, including ideas, comments, and corrections from Deborah Estrin, Dino Farinacci, Ahmed Helmy, David Thaler, Steve Deering, Van Jacobson, C. Liu, Puneet Sharma, Liming Wei, Tom Pusateri, Tony Ballardie, Scott Brim, Jon Crowcroft, Paul Francis, Joel Halpern, Horst Hodel, Polly Huang, Stephen Ostrowski, Lixia Zhang, Girish Chandranmenon, Brian Haberman, Hal Sandick, Mike Mroz, Garry Kump, Pavlin Radoslavov, Mike Davison, James Huang, Christopher Thomas Brown, and James Lingard.",
      "ja": "PIM-SMはデボラ・エストリン、ディノファリナッチ、アーメド・ヘルミー、デビッド・ターラー、スティーブデアリング、バン・ジェイコブソン、C.劉、Puneetシャルマ、黎明魏からのアイデア、コメント、修正を含め、人々の大規模なグループで長年にわたり設計されました、トムPusateri、トニー・Ballardie、スコット・ブリム、ジョンクロウクロフト、ポール・フランシス、ジョエル・ハルパーン、ホルストHodel、ポリー黄、スティーブンOstrowski、Lixiaチャン、Girish Chandranmenon、ブライアンハーバーマン、ハルSandick、マイク・Mroz、ギャリーKump、Pavlin Radoslavov、マイクデイヴィソン、ジェームズ黄、クリストファー・トーマス・ブラウン、ジェームスリンガード。"
    },
    {
      "indent": 3,
      "text": "Thanks are due to the American Licorice Company, for its obscure but possibly essential role in the creation of this document.",
      "ja": "おかげで、この文書の作成におけるその曖昧しかし、おそらく重要な役割のために、アメリカの甘草会社によるものです。"
    },
    {
      "indent": 0,
      "text": "8. Normative References",
      "section_title": true,
      "ja": "8.引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[1]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[2] Cain, B., Deering, S., Kouvelas, I., Fenner, B., and A. Thyagarajan, \"Internet Group Management Protocol, Version 3\", RFC 3376, October 2002.",
      "ja": "[2]カイン、B.、デアリング、S.、Kouvelas、I.、フェナー、B.、およびA. Thyagarajan、 \"インターネットグループ管理プロトコル、バージョン3\"、RFC 3376、2002年10月。"
    },
    {
      "indent": 3,
      "text": "[3] Deering, S., \"Host extensions for IP multicasting\", STD 5, RFC 1112, August 1989.",
      "ja": "[3]デアリング、S.、 \"IPマルチキャスティングのためのホスト拡大\"、STD 5、RFC 1112、1989年8月。"
    },
    {
      "indent": 3,
      "text": "[4] Deering, S., Fenner, W., and B. Haberman, \"Multicast Listener Discovery (MLD) for IPv6\", RFC 2710, October 1999.",
      "ja": "[4]デアリング、S.、フェナー、W.、およびB.ハーバーマン、 \"マルチキャストリスナ発見IPv6の（MLD）\"、RFC 2710、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[5] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[5]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[6] Holbrook, H. and B. Cain, \"Source-Specific Multicast for IP\", RFC 4507, August 2006.",
      "ja": "[6]ホルブルック、H.、およびB.カイン、 \"IPのためのソース固有のマルチキャスト\"、RFC 4507、2006年8月。"
    },
    {
      "indent": 3,
      "text": "[7] IANA, \"Address Family Numbers\", <http://www.iana.org/assignments/address-family-numbers>.",
      "ja": "[7] IANA、 \"アドレスファミリ番号\"、<http://www.iana.org/assignments/address-family-numbers>。"
    },
    {
      "indent": 3,
      "text": "[8] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[8]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[9] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[9] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 0,
      "text": "9. Informative References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 3,
      "text": "[10] Bates, T., Rekhter, Y., Chandra, R., and D. Katz, \"Multiprotocol Extensions for BGP-4\", RFC 2858, June 2000.",
      "ja": "[10]ベイツ、T.、Rekhter、Y.、チャンドラ、R.、およびD.カッツ、 \"BGP-4のためのマルチプロトコルの拡張\"、RFC 2858、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[11] Bhaskar, N., Gall, A., Lingard, J., and S. Venaas, \"Bootstrap Router (BSR) Mechanism for PIM Sparse Mode\", Work in Progress, May 2006.",
      "ja": "[11] Bhaskar、N.、ガル、A.、リンガード、J.、およびS. Venaas、 \"PIMスパースモードのためのブートストラップルータ（BSR）メカニズム\"、進歩、2006年5月に働いています。"
    },
    {
      "indent": 3,
      "text": "[12] Black, D., \"Differentiated Services and Tunnels\", RFC 2983, October 2000.",
      "ja": "[12]ブラック、D.、 \"差別化サービスおよびトンネル\"、RFC 2983、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[13] Handley, M., Kouvelas, I., Speakman, T., and L. Vicisano, \"Bi-directional Protocol Independent Multicast\", Work in Progress, October 2005.",
      "ja": "[13]ハンドレー、M.、Kouvelas、I.、スピークマン、T.、およびL. Vicisano、 \"双方向プロトコル独立マルチキャスト\"、進歩、2005年10月に働いています。"
    },
    {
      "indent": 3,
      "text": "[14] Kaufman, C., \"Internet Key Exchange (IKEv2) Protocol\", RFC 4306, December 2005.",
      "ja": "[14]カウフマン、C.、 \"インターネットキーエクスチェンジ（IKEv2の）プロトコル\"、RFC 4306、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[15] Savola, P., Lehtonen, R., and D. Meyer, \"Protocol Independent Multicast - Sparse Mode (PIM-SM) Multicast Routing Security Issues and Enhancements\", RFC 4609, August 2006.",
      "ja": "[15] Savola、P.、Lehtonenの、R.、およびD.マイヤー、 \"プロトコル独立マルチキャスト - スパースモード（PIM-SM）マルチキャストルーティングセキュリティの問題と機能拡張\"、RFC 4609、2006年8月。"
    },
    {
      "indent": 3,
      "text": "[16] Savola, P. and J. Lingard, \"Last-hop Threats to Protocol Independent Multicast (PIM)\", Work in Progress, January 2005.",
      "ja": "[16] Savola、P.およびJ.リンガード、 \"プロトコル独立マルチキャスト（PIM）への最後のホップの脅威\"、進歩、2005年1月での作業。"
    },
    {
      "indent": 3,
      "text": "[17] Savola, P. and B. Haberman, \"Embedding the Rendezvous Point (RP) Address in an IPv6 Multicast Address\", RFC 3956, November 2004.",
      "ja": "[17] Savola、P.とB.ハーバーマン、 \"IPv6マルチキャストアドレスでのランデブーポイント（RP）アドレスを埋め込み\"、RFC 3956、2004年11月。"
    },
    {
      "indent": 3,
      "text": "[18] Thaler, D., \"Interoperability Rules for Multicast Routing Protocols\", RFC 2715, October 1999.",
      "ja": "[18]ターラー、D.、RFC 2715、1999年10月 \"マルチキャストルーティングプロトコルの相互運用性の規則\"。"
    },
    {
      "indent": 0,
      "text": "Appendix A. PIM Multicast Border Router Behavior",
      "ja": "付録A. PIMマルチキャスト境界ルータの動作"
    },
    {
      "indent": 3,
      "text": "In some cases, PIM-SM domains will interconnect with non-PIM multicast domains. In these cases, the border routers of the PIM domain speak PIM-SM on some interfaces and speak other multicast routing protocols on other interfaces. Such routers are termed PIM Multicast Border Routers (PMBRs). In general, RFC 2715 [18] provides rules for interoperability between different multicast routing protocols. In this appendix, we specify how PMBRs differ from regular PIM-SM routers.",
      "ja": "いくつかのケースでは、PIM-SMドメインは、非PIMマルチキャストドメインと相互接続します。これらのケースでは、PIMドメインの境界ルータは、いくつかのインターフェイス上でPIM-SMを話し、他のインターフェイス上の他のマルチキャストルーティングプロトコルを話します。このようなルータは、PIMマルチキャスト境界ルータ（PMBRs）と呼ばれています。一般的には、RFC 2715 [18]異なるマルチキャストルーティングプロトコル間の相互運用性のためのルールを提供します。この付録では、我々はPMBRsは、通常のPIM-SMルータと異なる方法を指定します。"
    },
    {
      "indent": 3,
      "text": "From the point of view of PIM-SM, a PMBR has two tasks:",
      "ja": "PIM-SMの観点から、PMBRは、2つのタスクがあります。"
    },
    {
      "indent": 3,
      "text": "o To ensure that traffic from sources outside the PIM-SM domain reaches receivers inside the domain.",
      "ja": "PIM-SMドメインの外部ソースからのトラフィックは、ドメイン内の受信機に到達することを確実にするために、O。"
    },
    {
      "indent": 3,
      "text": "o To ensure that traffic from sources inside the PIM-SM domain reaches receivers outside the domain.",
      "ja": "PIM-SMドメイン内のソースからのトラフィックは、ドメイン外の受信機に到達することを確実にするために、O。"
    },
    {
      "indent": 3,
      "text": "We note that multiple PIM-SM domains are sometimes connected together using protocols such as Multicast Source Discovery Protocol (MSDP), which provides information about active external sources, but does not follow RFC 2715. In such cases, the domains are not connected via PMBRs because Join(S,G) messages traverse the border between domains. A PMBR is required when no PIM messages can traverse the border.",
      "ja": "我々は、複数のPIM-SMドメインは時々そのようなアクティブ外部ソースに関する情報を提供し、マルチキャストソース発見プロトコル（MSDP）などのプロトコルを用いて互いに接続されているが、このような場合にはRFC 2715に従っていないことに注意して、ドメインはPMBRsを介して接続されていません参加するために（S、G）メッセージは、ドメイン間の境界を横切ります。何のPIMメッセージが国境を通過することはできませんときPMBRが必要です。"
    },
    {
      "indent": 0,
      "text": "A.1. Sources External to the PIM-SM Domain",
      "ja": "A.1。 PIM-SMドメインにソース外部"
    },
    {
      "indent": 3,
      "text": "A PMBR needs to ensure that traffic from multicast sources external to the PIM-SM domain reaches receivers inside the domain. The PMBR will follow the rules in RFC 2715, such that traffic from external sources reaches the PMBR itself.",
      "ja": "PMBRはPIM-SMドメインの外部のマルチキャスト送信元からのトラフィックは、ドメイン内の受信機に到達することを確認する必要があります。 PMBRは、外部ソースからのトラフィックがPMBR自体に到達するように、RFC 2715のルールに従います。"
    },
    {
      "indent": 3,
      "text": "According to RFC 2715, the PIM-SM component of the PMBR will receive an (S,G) Creation event when data from an (S,G) data packet from an external source first reaches the PMBR. If RPF_interface(S) is an interface in the PIM-SM domain, the packet cannot be originated into the PIM domain at this router, and the PIM-SM component of the PMBR will not process the packet. Otherwise, the PMBR will then act exactly as if it were the DR for this source (see Section 4.4.1), with the following modifications:",
      "ja": "RFC 2715によれば、PMBRのPIM-SMコンポーネントは、外部ソースからの（S、G）データパケットからのデータが最初PMBRに達したときに（S、G）作成イベントを受信します。 RPF_interface（S）は、PIM-SMドメインのインターフェイスである場合、パケットはこのルータにPIMドメインに由来することができず、PMBRのPIM-SMコンポーネントは、パケットを処理しません。それは、このソースのDRであるかのようにそれ以外の場合は、PMBRは、以下のように変更して、（4.4.1項を参照）を正確に動作します："
    },
    {
      "indent": 3,
      "text": "o The Border-bit is set in all PIM Register messages sent for these sources.",
      "ja": "Oボーダービットは、これらのソースのために送信されたすべてのPIM Registerメッセージに設定されています。"
    },
    {
      "indent": 3,
      "text": "o DirectlyConnected(S) is treated as being TRUE for these sources.",
      "ja": "O DirectlyConnected（S）は、これらのソースのTRUEであるとして扱われます。"
    },
    {
      "indent": 3,
      "text": "o The PIM-SM forwarding rule \"iif == RPF_interface(S)\" is relaxed to be TRUE if iif is any interface that is not part of the PIM-SM component of the PMBR (see Section 4.2).",
      "ja": "O PIM-SM転送ルール「IIF == RPF_interface（S）」IIFはPMBRのPIM-SMコンポーネントの一部ではない任意のインタフェースがある場合TRUEことが緩和される（セクション4.2参照）。"
    },
    {
      "indent": 0,
      "text": "A.2. Sources Internal to the PIM-SM Domain",
      "ja": "A.2。 PIM-SMドメインへの内部要因"
    },
    {
      "indent": 3,
      "text": "A PMBR needs to ensure that traffic from sources inside the PIM-SM domain reaches receivers outside the domain. Using terminology from RFC 2715, there are two possible scenarios for this:",
      "ja": "PMBRはPIM-SMドメインがドメイン外部の受信機に到達した内部ソースからのトラフィックを確保する必要があります。 RFC 2715からの用語を使用して、このための2つの可能なシナリオがあります。"
    },
    {
      "indent": 3,
      "text": "o Another component of the PMBR is a wildcard receiver. In this case, the PIM-SM component of the PMBR must ensure that traffic from all internal sources reaches the PMBR until it is informed otherwise.",
      "ja": "O PMBRの別の成分は、ワイルドカードの受信機です。この場合には、PMBRのPIM-SMの成分は、それがそうでなければ通知されるまで、すべての内部ソースからのトラフィックがPMBRに到達することを保証しなければなりません。"
    },
    {
      "indent": 5,
      "text": "Note that certain profiles of PIM-SM (e.g., PIM-SSM, PIM-SM with Embedded RP) cannot interoperate with a neighboring wildcard receiver domain.",
      "ja": "（埋め込みRPと例えば、PIM-SSM、PIM-SM）PIM-SMの特定のプロファイルが隣接ワイルドカードレシーバドメインと相互運用することができないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "o No other component of the PMBR is a wildcard receiver. In this case the PMBR will receive explicit information as to which groups or (source,group) pairs the external domains wish to receive.",
      "ja": "O PMBRの他の成分は、ワイルドカードの受信機ではありません。この場合PMBRは、グループまたは外部ドメインが受信を希望する（ソース、グループ）対として明示的な情報を受信します。"
    },
    {
      "indent": 3,
      "text": "In the former case, the PMBR will need to send a Join(*,*,RP) to all the active RPs in the PIM-SM domain. It may also send a Join(*,*,RP) to all the candidate RPs in the PIM-SM domain. This will cause all traffic in the domain to reach the PMBR. The PMBR may then act as if it were a DR with directly connected receivers and trigger the transition to a shortest path tree (see Section 4.2.1).",
      "ja": "前者の場合には、PMBRはPIM-SMドメイン内のすべてのアクティブのRPに参加（*、*、RP）を送信する必要があります。また、PIM-SMドメイン内のすべての候補RPに（*、*、RP）に参加送ることができます。これはPMBRに到達するために、ドメイン内のすべてのトラフィックが発生します。 PMBRは、それが直接接続された受信機とDRであるかのように作用し、最短パス木（セクション4.2.1を参照）への遷移をトリガすることができます。"
    },
    {
      "indent": 3,
      "text": "In the latter case, the PMBR will not need to send Join(*,*,RP) messages. However, the PMBR will still need to act as a DR with directly connected receivers on behalf of the external receivers in terms of being able to switch to the shortest-path tree for internally-reached sources.",
      "ja": "後者の場合、PMBRは（*、*、RP）Joinメッセージを送信する必要はありません。しかし、PMBRは依然として内部に達するソースの最短パスツリーに切り替えることができるという点で、外部受信機の代わりに直接接続された受信機とDRとして機能する必要があります。"
    },
    {
      "indent": 3,
      "text": "According to RFC 2715, the PIM-SM component of the PMBR may receive a number of alerts generated by events in the external routing components. To implement the above behavior, one reasonable way to map these alerts into PIM-SM state is as follows:",
      "ja": "RFC 2715によれば、PMBRのPIM-SMコンポーネントは、外部のルーティングコンポーネントのイベントによって生成されたアラートの数を受信することができます。次のように上記の動作を実装するには、PIM-SMの状態にこれらのアラートをマッピングする一つの合理的な方法は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o When a PIM-SM component receives an (S,G) Prune alert, it sets local_receiver_include(S,G,I) to FALSE for the discard interface.",
      "ja": "PIM-SM成分は（S、G）プルーンアラートを受信すると、O、それは廃棄インターフェイスのFALSEにlocal_receiver_include（S、G、I）を設定します。"
    },
    {
      "indent": 3,
      "text": "o When a PIM-SM component receives a (*,G) Prune alert, it sets local_receiver_include(*,G,I) to FALSE for the discard interface.",
      "ja": "PIM-SM成分は（*、G）プルーンアラートを受信すると、O、それは廃棄インターフェイスのFALSEにlocal_receiver_include（*、G、I）を設定します。"
    },
    {
      "indent": 3,
      "text": "o When a PIM-SM component receives an (S,G) Join alert, it sets local_receiver_include(S,G,I) to TRUE for the discard interface.",
      "ja": "PIM-SM成分は（S、G）警告を参加を受信すると、O、それは廃棄インターフェイスについてTRUEと（S、G、I）local_receiver_includeを設定します。"
    },
    {
      "indent": 3,
      "text": "o When a PIM-SM component receives a (*,G) Join alert, it sets local_receiver_include(*,G,I) to TRUE for the discard interface.",
      "ja": "PIM-SM成分は（*、G）参加通知を受信すると、O、それは廃棄インターフェイスのTRUEにlocal_receiver_includeに（*、G、I）を設定します。"
    },
    {
      "indent": 3,
      "text": "o When a PIM-SM component receives a (*,*) Join alert, it sets DownstreamJPState(*,*,RP,I) to Join state on the discard interface for all RPs in the PIM-SM domain.",
      "ja": "PIM-SMコンポーネントは、（*、*）アラートをJoinを受信すると、O、それはPIM-SMドメイン内のすべてのRPのための廃棄インターフェイス上の状態に参加するDownstreamJPState（*、*、RP、I）を設定します。"
    },
    {
      "indent": 3,
      "text": "o When a PIM-SM component receives a (*,*) Prune alert, it sets DownstreamJPState(*,*,RP,I) to NoInfo state on the discard interface for all RPs in the PIM-SM domain.",
      "ja": "PIM-SMコンポーネントは、（*、*）プルーンのアラートを受信すると、O、それはPIM-SMドメイン内のすべてのRPのための廃棄インターフェイス上NoInfo状態にDownstreamJPState（*、*、RP、I）を設定します。"
    },
    {
      "indent": 3,
      "text": "We refer above to the discard interface because the macros and state machines are interface specific, but we need to have PIM state that is not associated with any actual PIM-SM interface. Implementers are free to implement this in any reasonable manner.",
      "ja": "マクロやステートマシンがインタフェース固有であるので、我々は廃棄インターフェイスに上記参照してください、私たちは実際のPIM-SMインタフェースに関連付けられていないPIMの状態を持っている必要があります。実装者は、任意の合理的な方法でこれを実装するのは自由です。"
    },
    {
      "indent": 3,
      "text": "Note that these state changes will then cause additional PIM-SM state machine transitions in the normal way.",
      "ja": "これらの状態の変化は、通常の方法で、追加のPIM-SMステート・マシンの遷移を引き起こすことに注意してください。"
    },
    {
      "indent": 3,
      "text": "These rules are, however, not sufficient to allow pruning off the (*,*,RP) tree. Some additional rules provide guidance as to one way this may be done:",
      "ja": "これらのルールは、（*、*、RP）の木を剪定オフ可能にするのに十分なしかし、ではありません。いくつかの追加ルールはこれを実行することができる一つの方法に関して、ガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "o If the PMBR has joined on the (*,*,RP) tree, then it should set DownstreamJPState(*,G,I) to JOIN on the discard interface for all active groups.",
      "ja": "PMBRは（*、*、RP）ツリーに参加した場合、O、それはすべてのアクティブなグループのための廃棄インターフェイスに参加するDownstreamJPState（*、G、I）を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the router receives a (S,G) prune alert, it will need to set DownstreamJPState(S,G,rpt,I) to PRUNE on the discard interface.",
      "ja": "ルータは（S、G）プルーンのアラートを受信した場合、O、それは廃棄インターフェースでプルーニングするDownstreamJPState（S、G、RPT、I）を設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the router receives a (*,G) prune alert, it will need to set DownstreamJPState(S,G,rpt,I) to PRUNE on the discard interface for all active sources sending to G.",
      "ja": "ルータが（*、G）プルーンのアラートを受信した場合、O、それはすべてのアクティブなソースがG.に送信するための廃棄インターフェイスでプルーニングするDownstreamJPState（S、G、RPT、I）を設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The rationale for this is that there is no way in PIM-SM to prune traffic off the (*,*,RP) tree, except by Joining the (*,G) tree and then pruning each source individually.",
      "ja": "この理論的根拠は、（*、G）ツリーに参加した後、個々のソースをプルーニングする以外、（*、*、RP）ツリーオフトラフィックをプルーニングするPIM-SMに方法がないことです。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Index",
      "ja": "付録B.インデックス"
    },
    {
      "indent": 3,
      "text": "Address_List. . . . . . . . . . . . . . . . . . . . . . . . . . .  31\nAssert(*,G) . . . . . . . . . . . . . . . . . . . . . . . . . .27,128\nAssert(S,G) . . . . . . . . . . . . . . . . . . . . . . . . . .27,128\nAssertCancel(*,G) . . . . . . . . . . . . . . . . . . . . . . . 97,99\nAssertCancel(S,G) . . . . . . . . . . . . . . . . . . . . . .80,90,99\nAssertTimer(*,G,I). . . . . . . . . . . . . . . . . . . .16,24,91,132\nAssertTimer(S,G,I). . . . . . . . . . . . . . . . . . . .18,24,84,132\nAssertTrackingDesired(*,G,I). . . . . . . . . . . . . . . . .93,94,96\nAssertTrackingDesired(S,G,I). . . . . . . . . . . . . . . 85,86,87,89\nAssertWinner(*,G,I) . . . . . . . . . . . . . . . .16,22,24,93,97,100\nAssertWinner(S,G,I) . . . . . . . . . . . . . .18,22,24,86,90,100,100\nAssertWinnerMetric(*,G,I) . . . . . . . . . . . . . . . . . 16,97,101\nAssertWinnerMetric(S,G,I) . . . . . . . . . . . . . . . . . 18,90,101\nassert_metric . . . . . . . . . . . . . . . . . . . . . . . . . .  98\nAssert_Override_Interval. . . . . . . . . . . . . . . . . . 90,97,132\nAssert_Time . . . . . . . . . . . . . . . . . . . . . . . . 90,97,132\nAT(*,G,I) . . . . . . . . . . . . . . . . . . . . . .16,24,91,129,132\nAT(S,G,I) . . . . . . . . . . . . . . . . . . . . . .18,24,84,129,132\nCheckSwitchToSpt(S,G) . . . . . . . . . . . . . . . . . . . . . 27,28\nCouldAssert(*,G,I). . . . . . . . . . . . . . . . . . .92,93,94,95,98\nCouldAssert(S,G,I). . . . . . . . . . . . . . . . . 84,86,87,88,89,98\nCouldRegister(S,G). . . . . . . . . . . . . . . . . . . . . . . 39,41\nDefault_Hello_Holdtime. . . . . . . . . . . . . . . . . . . . . .  33\nDirectlyConnected(S). . . . . . . . . . . . . . . . . 27,27,29,41,143\nDownstreamJPState(*,*,RP,I) . . . . . . . . . . . . . . . . . .23,145\nDownstreamJPState(*,G,I). . . . . . . . . . . . . . . . . . . . .  23\nDownstreamJPState(S,G,I). . . . . . . . . . . . . . . . . . . . 23,40\nDownstreamJPState(S,G,rpt,I). . . . . . . . . . . . . . . . . . .  23\nDR(I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  33\ndr_is_better(a,b,I) . . . . . . . . . . . . . . . . . . . . . . 33,33\nDR_Priority . . . . . . . . . . . . . . . . . . . . . . . . .31,32,33\nEffective_Override_Interval(I). . . . . . . . . . . . . . .36,114,132\nEffective_Propagation_Delay(I). . . . . . . . . . . . . . . . .35,132\nET(*,*,RP,I). . . . . . . . . . . . . . . . . . . . . . 15,46,128,131\nET(*,G,I) . . . . . . . . . . . . . . . . . . . . . . . 16,50,128,131\nET(S,G,I) . . . . . . . . . . . . . . . . . . . . . . . 18,53,129,131\nET(S,G,rpt,I) . . . . . . . . . . . . . . . . . . . .20,57,59,129,131\nGenID . . . . . . . . . . . . . . . . . 15,17,19,31,64,68,70,73,85,93\nHash_Function . . . . . . . . . . . . . . . . . . . . . . . . .12,105\nHello_Holdtime. . . . . . . . . . . . . . . . . . . . . . . . .33,131\nHello_Period. . . . . . . . . . . . . . . . . . . . . . . . . .31,130\nHT(I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . .31,130\nIGMP. . . . . . . . . . . . . . . . . . . . . . . . 6,8,17,23,101,105\nimmediate_olist(*,*,RP) . . . . . . . . . . . . . . . . . . . . 22,64\nimmediate_olist(*,G). . . . . . . . . . . . . . . . . . . . . . 22,68\nimmediate_olist(S,G). . . . . . . . . . . . . . . . . . . . .22,40,73 infinite_assert_metric(). . . . . . . . . . . . . . . . . . . . .  99\ninherited_olist(S,G). . . . . . . . . . . . . . 22,27,40,43,73,86,108\ninherited_olist(S,G,rpt). . . . . . . . . . . . . . 22,27,29,76,79,81\nI_Am_Assert_Loser(*,G,I). . . . . . . . . . . . . . . . . . . . .  24\nI_Am_Assert_Loser(S,G,I). . . . . . . . . . . . . . . . . . . . .  24\nI_am_DR(I). . . . . . . . . . . . . . . . . . . . . . .22,33,41,86,93\nI_am_RP(G). . . . . . . . . . . . . . . . . . . . . . . . . . . 43,44\nJ/P_Holdtime. . . . . . . . . . . . .47,51,55,59,65,69,74,121,131,133\nJ/P_Override_Interval(I). . . . . . . . . . . . . 48,51,55,59,121,132\nJoinDesired(*,*,RP) . . . . . . . . . . . . . . . . . . . . . . 64,79\nJoinDesired(*,G). . . . . . . . . . . . . . . . . . . .17,68,79,86,97\nJoinDesired(S,G). . . . . . . . . . . . . . . . . . 19,29,73,86,88,90\njoins(*,*,RP(G)). . . . . . . . . . . . . . . . . . . . . . . . .  22\njoins(*,*,RP) . . . . . . . . . . . . . . . . . . . . . . 22,23,86,93\njoins(*,G). . . . . . . . . . . . . . . . . . . . . . . . 22,23,86,93\njoins(S,G). . . . . . . . . . . . . . . . . . . . . . . . . .22,23,86\nJT(*,*,RP). . . . . . . . . . . . . . . . . . . . . . . 15,62,129,133\nJT(*,G) . . . . . . . . . . . . . . . . . . . . . . . . 16,67,129,133\nJT(S,G) . . . . . . . . . . . . . . . . . . . . . . . . 18,71,129,133\nKAT(S,G). . . . . . . . . . . . . . .18,26,27,28,41,43,73,108,129,134\nKeepaliveTimer(S,G) . . . . . . . 18,26,27,27,28,41,43,73,108,129,134\nKeepalive_Period. . . . . . . . . . . . . . . . . . . . . . . .27,134\nlan_delay_enabled(I). . . . . . . . . . . . . . . . . . . . . . 35,36\nLAN_Prune_Delay . . . . . . . . . . . . . . . . . . . . . . . . .  31\nlocal_receiver_exclude(S,G,I) . . . . . . . . . . . . . . . . . .  23\nlocal_receiver_include(*,G,I) . . . . . . . . . . . . . . . 23,93,144\nlocal_receiver_include(S,G,I) . . . . . . . . . . . . . . . . . 23,86\nlocal_receiver_include(S,G,I).. . . . . . . . . . . . . . . . . . 144\nlost_assert(*,G). . . . . . . . . . . . . . . . . . . . . . .22,24,86\nlost_assert(*,G,I). . . . . . . . . . . . . . . . . . . . . 22,24,100\nlost_assert(S,G). . . . . . . . . . . . . . . . . . . . . . . . 22,24\nlost_assert(S,G,I). . . . . . . . . . . . . . . . . . . . . 22,24,100\nlost_assert(S,G,rpt). . . . . . . . . . . . . . . . . . . . . . .  24\nlost_assert(S,G,rpt,I). . . . . . . . . . . . . . . . . . . . .24,100\nMBGP. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6,7\nMFIB. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .6,13\nMLD . . . . . . . . . . . . . . . . . . . . . . . . 6,8,17,23,101,105\nMRIB. . . . . . . . . . . . . .6,7,11,15,19,25,62,66,66,75,98,103,128\nMRIB.next_hop(host) . . . . . . . . . . . . . . . . . . . 24,25,62,64\nmy_assert_metric(*,G,I) . . . . . . . . . . . . . . . . . . . . .  94\nmy_assert_metric(S,G,I) . . . . . . . . . . . . . . . . . 85,89,92,98\nNBR(Interface,IP_address) . . . . . . . . . . . . . . .25,37,62,64,66\nNLT(N,I). . . . . . . . . . . . . . . . . . . . . . . . 14,33,128,131\nOT(S,G,rpt) . . . . . . . . . . . . . . . . . . . . . . 20,77,129,134\nOverride_Interval(I). . . . . . . . . . . . . 14,31,34,36,114,130,132\npacket_arrives_on_rp_tunnel(pkt). . . . . . . . . . . . . . . . .  43\npim_exclude(S,G). . . . . . . . . . . . . . . . . . . . . 22,22,28,86\npim_include(*,G). . . . . . . . . . . . . . . . . . 17,22,22,28,86,93 pim_include(S,G). . . . . . . . . . . . . . . . . . . .19,22,22,28,86\nPPT(*,*,RP,I) . . . . . . . . . . . . . . . . . . . . . 15,46,128,132\nPPT(*,G,I). . . . . . . . . . . . . . . . . . . . . . . 16,50,129,132\nPPT(S,G,I). . . . . . . . . . . . . . . . . . . . . . . 18,53,129,132\nPPT(S,G,rpt,I). . . . . . . . . . . . . . . . . . . .20,57,59,129,132\nPropagation_Delay(I). . . . . . . . . . . . . . . . . . 31,35,130,132\nPropagation_delay_default . . . . . . . . . . . . . . . . . . .35,130\nPruneDesired(S,G,rpt) . . . . . . . . . . . . . . . . . . 79,80,88,90\nprunes(S,G,rpt) . . . . . . . . . . . . . . . . . . . . . . .22,23,86\nRegister-Stop(*,G). . . . . . . . . . . . . . . . . . . . . . . .  42\nRegister-Stop(S,G). . . . . . . . . . . . . . . . . . . . . . . .  43\nRegister-StopTimer(S,G) . . . . . . . . . . . . . . . . 38,39,129,135\nRegister_Probe_Time . . . . . . . . . . . . . . . . . . . . 39,44,135\nRegister_Suppression_Time . . . . . . . . . . . . . . . . . 39,44,135\nRP(G) . . . . . . . . . . . . 5,22,24,40,43,49,68,77,86,93,99,102,128\nRPF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   6\nRPF'(*,G) . . . . . . . . . . . . . . . . 24,29,67,68,70,76,79,97,101\nRPF'(S,G) . . . . . . . . . . . . . . . . . . . 25,29,71,76,79,90,101\nRPF'(S,G,rpt) . . . . . . . . . . . . . . . . . . . . . .24,76,79,102\nRPF_interface . . . . . . . . . . . . . . . . . . . . . . . . . .  93\nRPF_interface(host) . . . . . .24,27,29,41,68,69,74,86,93,100,108,143\nRPTJoinDesired(G) . . . . . . . . . . . . . . . . . . . . . .79,81,93\nrpt_assert_metric(G,I). . . . . . . . . . . . . . . . . . . .96,97,99\nRST(S,G). . . . . . . . . . . . . . . . . . . . . . . . 38,39,129,135\nSPTbit(S,G) . . . . . . . 19,27,29,43,53,74,76,79,86,86,89,90,100,108\nspt_assert_metric(S,I). . . . . . . . . . . . . . . . . . . 90,98,100\nSSM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10,106\nSuppression_Enabled(I). . . . . . . . . . . . . . . . . . . . .36,133\nSwitchToSptDesired(S,G) . . . . . . . . . . . . . . . . . . .28,28,43\nTIB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6,13,26\nTriggered_Hello_Delay . . . . . . . . . . . . . . . . . . . 31,32,130\nt_joinsuppress. . . . . . . . . . . . . . . . . . . . .64,65,68,69,74\nt_override. . . . . . . . . . . . . . . . . . . . 64,68,73,78,133,134\nt_override_default. . . . . . . . . . . . . . . . . . . . . . .36,130\nt_periodic. . . . . . . . . . . . . . . . . . . . . . . .64,68,73,133\nt_suppressed. . . . . . . . . . . . . . . . . . . .36,65,69,73,74,133\nUpdate_SPTbit(S,G,iif). . . . . . . . . . . . . . . . . . . . . 27,29\nUpstreamJPState(S,G). . . . . . . . . . . . . . . . . . . . . .27,108",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Bill Fenner AT&T Labs - Research 1 River Oaks Place San Jose, CA 95134",
      "ja": "ビルフェナーAT＆T研究所 - 研究1リバーオークス置き、サンノゼ、CA 95134"
    },
    {
      "indent": 3,
      "text": "EMail: fenner@research.att.com",
      "ja": "メールアドレス：fenner@research.att.com"
    },
    {
      "indent": 3,
      "text": "Mark Handley Department of Computer Science University College London Gower Street London WC1E 6BT United Kingdom",
      "ja": "コンピュータサイエンス大学ロンドンガウアーストリートロンドンWC1E 6BTイギリスのマーク・ハンドリー部門"
    },
    {
      "indent": 3,
      "text": "EMail: M.Handley@cs.ucl.ac.uk",
      "ja": "メールアドレス：M.Handley@cs.ucl.ac.uk"
    },
    {
      "indent": 3,
      "text": "Hugh Holbrook Arastra, Inc. P.O. Box 10905 Palo Alto, CA 94303",
      "ja": "ヒュー・ホルブルックArastra、株式会社私書箱ボックス10905パロアルト、CA 94303"
    },
    {
      "indent": 3,
      "text": "EMail: holbrook@arastra.com",
      "ja": "メールアドレス：holbrook@arastra.com"
    },
    {
      "indent": 3,
      "text": "Isidor Kouvelas Cisco Systems 170 W. Tasman Drive San Jose, CA 95134",
      "ja": "イジドールKouvelasシスコシステムズ170 W.タスマン・ドライブサンノゼ、CA 95134"
    },
    {
      "indent": 3,
      "text": "EMail: kouvelas@cisco.com",
      "ja": "メールアドレス：kouvelas@cisco.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディタ機能のための資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}