{
  "title": {
    "text": "RFC 4137 - State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator",
    "ja": "RFC 4137 - 拡張認証プロトコル（EAP）ピアと認証のためのステートマシン"
  },
  "number": 4137,
  "created_at": "2019-10-20 08:23:00.427792+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                      J. Vollbrecht\nRequest for Comments: 4137              Meetinghouse Data Communications\nCategory: Informational                                        P. Eronen\n                                                                   Nokia\n                                                              N. Petroni\n                                                  University of Maryland\n                                                                 Y. Ohba\n                                                                    TARI\n                                                             August 2005",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "State Machines for Extensible Authentication Protocol (EAP)\n                   Peer and Authenticator",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a set of state machines for Extensible Authentication Protocol (EAP) peer, EAP stand-alone authenticator (non-pass-through), EAP backend authenticator (for use on Authentication, Authorization, and Accounting (AAA) servers), and EAP full authenticator (for both local and pass-through). This set of state machines shows how EAP can be implemented to support deployment in either a peer/authenticator or peer/authenticator/AAA Server environment. The peer and stand-alone authenticator machines are illustrative of how the EAP protocol defined in RFC 3748 may be implemented. The backend and full/pass-through authenticators illustrate how EAP/AAA protocol support defined in RFC 3579 may be implemented. Where there are differences, RFC 3748 and RFC 3579 are authoritative.",
      "ja": "この文書では、拡張認証プロトコル（EAP）ピア、EAPスタンドアローンオーセンティケータ（非パススルー）（認証、認可、アカウンティング（AAA）サーバ上で使用するため）、EAPのバックエンド認証のためのステートマシンのセットを記述し、 （ローカルとパススルーの両方のための）EAPフルオーセンティケータ。ステートマシンのこのセットは、EAPピア/オーセンティケータまたはピア/オーセンティケータ/ AAA Server環境のいずれかでの展開をサポートするために実装する方法を示しています。ピアおよびスタンドアロン認証子機は、RFC 3748で定義されたEAPプロトコルが実装されてもよい方法の例示です。バックエンドフル/パススルーオーセンティケータは、RFC 3579で定義されたEAP / AAAプロトコルのサポートを実装することができる方法を示します。違いがある場合は、RFC 3748およびRFC 3579は権威あります。"
    },
    {
      "indent": 3,
      "text": "The state machines are based on the EAP \"Switch\" model. This model includes events and actions for the interaction between the EAP Switch and EAP methods. A brief description of the EAP \"Switch\" model is given in the Introduction section.",
      "ja": "ステート・マシンはEAP「スイッチ」モデルに基づいています。このモデルは、EAPスイッチとEAPメソッド間の相互作用のためのイベントとアクションが含まれています。 EAP「スイッチ」モデルの簡単な説明は、はじめのセクションに与えられています。"
    },
    {
      "indent": 3,
      "text": "The state machine and associated model are informative only. Implementations may achieve the same results using different methods.",
      "ja": "ステートマシンと関連したモデルにのみ有益です。実装は異なる方法を使用して同じ結果を達成することができます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction: The EAP Switch Model ..............................3\n2. Specification of Requirements ...................................4\n3. Notational Conventions Used in State Diagrams ...................5\n   3.1. Notational Specifics .......................................5\n   3.2. State Machine Symbols ......................................7\n   3.3. Document Authority .........................................8\n4. Peer State Machine ..............................................9\n   4.1. Interface between Peer State Machine and Lower Layer .......9\n   4.2. Interface between Peer State Machine and Methods ..........11\n   4.3. Peer State Machine Local Variables ........................13\n   4.4. Peer State Machine Procedures .............................14\n   4.5. Peer State Machine States .................................15\n5. Stand-Alone Authenticator State Machine ........................17\n   5.1. Interface between Stand-Alone Authenticator State\n        Machine and Lower Layer ...................................17\n   5.2. Interface between Stand-Alone Authenticator State\n        Machine and Methods .......................................19\n   5.3. Stand-Alone Authenticator State Machine Local Variables ...21\n   5.4. EAP Stand-Alone Authenticator Procedures ..................22\n   5.5. EAP Stand-Alone Authenticator States ......................24\n6. EAP Backend Authenticator ......................................26\n   6.1. Interface between Backend Authenticator State\n        Machine and Lower Layer ...................................26\n   6.2. Interface between Backend Authenticator State\n        Machine and Methods .......................................28\n   6.3. Backend Authenticator State Machine Local Variables .......28\n   6.4. EAP Backend Authenticator Procedures ......................28\n   6.5. EAP Backend Authenticator States ..........................29\n7. EAP Full Authenticator .........................................29\n   7.1. Interface between Full Authenticator State Machine\n        and Lower Layer ...........................................30\n   7.2. Interface between Full Authenticator State Machine\n        and Methods ...............................................31\n   7.3. Full Authenticator State Machine Local Variables ..........32\n   7.4. EAP Full Authenticator Procedures .........................32\n   7.5. EAP Full Authenticator States .............................32\n8. Implementation Considerations ..................................34\n   8.1. Robustness ................................................34\n   8.2. Method/Method and Method/Lower-Layer Interfaces ...........35\n   8.3. Peer State Machine Interoperability with Deployed\n        Implementations ...........................................35\n9. Security Considerations ........................................35\n10. Acknowledgements ..............................................36\n11. References ....................................................37\n    11.1. Normative References ....................................37\n    11.2. Informative References ..................................37",
      "raw": true,
      "ja": "1.はじめに：EAPのスイッチモデル\n要件の2仕様\n状態図で使用される3表記規則\n   3.1。表記細目\n   3.2。ステートマシンシンボル\n   3.3。ドキュメントの権限\n4.ピア状態マシン\n   4.1。ピアステートマシンと下層との間のインターフェイス\n   4.2。ピアステートマシンとメソッドの間のインタフェース\n   4.3。ステートマシンローカル変数をピア\n   4.4。ステートマシンの手順をピア\n   4.5。ステートマシンの状態をピア\n5.スタンドアロン認証ステートマシン\n   5.1。スタンドアロン認証状態との間のインタフェース\n        マシン下層\n   5.2。スタンドアロン認証状態との間のインタフェース\n        機械と方法\n   5.3。スタンドアロン認証ステートマシンにローカル変数を... 21\n   5.4。 EAPスタンドアロン認証手続き\n   5.5。 EAPは、スタンドアロン認証状態\n6. EAPバックエンド認証\n   6.1。バックエンド認証状態との間のインタフェース\n        マシン下層\n   6.2。バックエンド認証状態との間のインタフェース\n        機械と方法\n   6.3。バックエンド認証ステートマシンローカル変数\n   6.4。 EAPバックエンド認証手続き\n   6.5。 EAPバックエンド認証状態\n7. EAP完全認証\n   7.1。完全な認証ステートマシン間のインタフェース\n        下層\n   7.2。完全な認証ステートマシン間のインタフェース\n        そして、方法\n   7.3。完全な認証ステートマシンローカル変数\n   7.4。 EAP完全認証手順\n   7.5。 EAP完全認証州\n8.実装に関する考慮事項\n   8.1。丈夫\n   8.2。メソッド/メソッドとメソッド/下位層インターフェイス\n   8.3。配備とステートマシンの相互運用性をピア\n        実装\n9.セキュリティの考慮事項\n10.謝辞\n11.参考文献\n    11.1。引用規格\n    11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "Appendix. ASCII Versions of State Diagrams ........................38\n    A.1.  EAP Peer State Machine (Figure 3) .......................38\n    A.2.  EAP Stand-Alone Authenticator State Machine (Figure 4) ..41\n    A.3.  EAP Backend Authenticator State Machine (Figure 5) ......44\n    A.4.  EAP Full Authenticator State Machine (Figures 6 and 7) ..47",
      "raw": true,
      "ja": "付録。状態遷移図のASCIIのバージョン\n    A.1。 EAPピアステートマシン（図3）\n    A.2。 EAPは、スタンドアロン認証ステートマシン（図4）..41\n    A.3。 EAPバックエンド認証ステートマシン（図5）\n    A.4。 EAP完全認証ステートマシン（図6、図7）..47"
    },
    {
      "indent": 0,
      "text": "1. Introduction: The EAP Switch Model",
      "section_title": true,
      "ja": "1.はじめに：EAPのスイッチモデル"
    },
    {
      "indent": 3,
      "text": "This document offers a proposed state machine for RFCs [RFC3748] and [RFC3579]. There are state machines for the peer, the stand-alone authenticator, a backend authenticator, and a full/pass-through authenticator. Accompanying each state machine diagram is a description of the variables, the functions, and the states in the diagram. Whenever possible, the same notation has been used in each of the state machines.",
      "ja": "この文書は、RFCの[RFC3748]と[RFC3579]のために提案されたステートマシンを提供しています。ピアのステートマシン、スタンドアロンのオーセンティケータ、バックエンドのオーセンティケータ、およびフル/パススルー認証システムがあります。各ステートマシン図に付随する図面の変数、関数、および状態の説明です。可能な限り、同じ表記法は、状態マシンのそれぞれに使用されています。"
    },
    {
      "indent": 3,
      "text": "An EAP authentication consists of one or more EAP methods in sequence followed by an EAP Success or EAP Failure sent from the authenticator to the peer. The EAP switches control negotiation of EAP methods and sequences of methods.",
      "ja": "EAP認証は、ピアに認証者から送信されたEAP成功又はEAP失敗が続くシーケンス内の1つまたは複数のEAPメソッドで構成されています。 EAPは、EAPメソッドとメソッドの配列の制御ネゴシエーションを切り替えます。"
    },
    {
      "indent": 6,
      "text": "Peer             Peer  |  Authenticator       Auth\nMethod                 |                      Method\n        \\              |                    /\n         \\             |                   /\n          Peer         |             Auth\n          EAP    <-----|---------->  EAP\n          Switch       |             Switch",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 1: EAP Switch Model",
      "ja": "図1：EAPのスイッチモデル"
    },
    {
      "indent": 3,
      "text": "At both the peer and authenticator, one or more EAP methods exist. The EAP switches select which methods each is willing to use, and negotiate between themselves to pick a method or sequence of methods.",
      "ja": "ピア及びオーセンティケータの両方で、一つ以上のEAP方法が存在します。 EAPは、それぞれが使用しても構わないと思っている方法を選択し、及び方法の方法またはシーケンスを選択するためにそれらの間で交渉するスイッチ。"
    },
    {
      "indent": 3,
      "text": "Note that the methods may also have state machines. The details of these are outside the scope of this paper.",
      "ja": "方法はまた、ステートマシンを持っていることに注意してください。これらの詳細は、この論文の範囲外です。"
    },
    {
      "indent": 9,
      "text": " Peer  |  Authenticator              | Backend\n       |              /   Local      |\n       |             /    Method     |\n Peer  |        Auth                 |        Backend\n EAP  -|----->  EAP                  |    -->  EAP\nSwitch |       Switch                |   /    Server\n       |             \\               |  /\n       |              \\ pass-through |\n       |                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Figure 2: EAP Pass-Through Model",
      "ja": "図2：EAPパススルーモデル"
    },
    {
      "indent": 3,
      "text": "The Full/Pass-Through state machine allows an NAS or edge device to pass EAP Response messages to a backend server where the authentication method resides. This paper includes a state machine for the EAP authenticator that supports both local and pass-through methods as well as a state machine for the backend authenticator existing at the AAA server. A simple stand-alone authenticator is also provided to show a basic, non-pass-through authenticator's behavior.",
      "ja": "フル/パススルー状態マシンは、NASまたはエッジデバイスは、認証方式が存在するバックエンドサーバーにEAP応答メッセージを通過させます。本稿では、ローカルおよびパススルー方法ならびにAAAサーバに存在するバックエンド認証のためのステートマシンの両方をサポートするEAP認証のための状態機械を含みます。シンプルなスタンドアローンのオーセンティケータは、基本的な、非パススルー認証システムの動作を示すために提供されています。"
    },
    {
      "indent": 3,
      "text": "This document describes a set of state machines that can manage EAP authentication from the peer to an EAP method on the authenticator or from the peer through the authenticator pass-through method to the EAP method on the backend EAP server.",
      "ja": "この文書では、オーセンティケータ上の又はバックエンドEAPサーバ上のEAPメソッドにオーセンティケータパススルー法によりピアからのEAPメソッドにピアからのEAP認証を管理することができる状態機械のセットを記述する。"
    },
    {
      "indent": 3,
      "text": "Some environments where EAP is used, such as PPP, may support peer-to-peer operation. That is, both parties act as peers and authenticators at the same time, in two simultaneous and independent EAP conversations. In this case, the implementation at each node has to perform demultiplexing of incoming EAP packets. EAP packets with code set to Response are delivered to the authenticator state machine, and EAP packets with code set to Request, Success, or Failure are delivered to the peer state machine.",
      "ja": "PPPなどEAPが使用される環境によっては、ピア・ツー・ピア動作をサポートすることができます。これは、両方の当事者が2人の同時かつ独立したEAPの会話では、同時に仲間とのオーセンティケータとして機能しています。この場合、各ノードでの実装は、着信EAPパケットの逆多重化を実行しなければなりません。レスポンスに設定されたコードとEAPパケットは認証マシンに配信され、そして、成功を要求するように設定コード、または失敗してEAPパケットをピア状態のマシンに配信されます。"
    },
    {
      "indent": 3,
      "text": "The state diagrams presented in this document have been coordinated with the diagrams in [1X-2004]. The format of the diagrams is adapted from the format therein. The interface between the state machines defined here and the IEEE 802.1X-2004 state machines is also explained in Appendix F of [1X-2004].",
      "ja": "この文書の状態図は、[1X-2004]の図でコーディネートされています。図の形式は、内部フォーマットから適合されています。ここで定義されたステートマシンとIEEE 802.1X-2004ステートマシン間のインタフェースも[1X-2004]の付録Fで説明されています。"
    },
    {
      "indent": 0,
      "text": "2. Specification of Requirements",
      "section_title": true,
      "ja": "要件の2仕様"
    },
    {
      "indent": 3,
      "text": "In this document, several words are used to signify the requirements of the specification. These words are often capitalized. The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in [RFC2119].",
      "ja": "このドキュメントでは、いくつかの単語は、仕様の要件を意味するために使用されています。これらの言葉は、多くの場合、資産計上されます。キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"OPTIONAL\" は解釈されるべきです[RFC2119]に記載されているように。"
    },
    {
      "indent": 0,
      "text": "3. Notational Conventions Used in State Diagrams",
      "section_title": true,
      "ja": "状態図で使用される3表記規則"
    },
    {
      "indent": 0,
      "text": "3.1. Notational Specifics",
      "section_title": true,
      "ja": "3.1。表記細目"
    },
    {
      "indent": 3,
      "text": "The following state diagrams have been completed based on the conventions specified in [1X-2004], section 8.2.1. The complete text is reproduced here:",
      "ja": "以下の状態図は、[1X-2004]で指定された規則に基づいて、セクション8.2.1を完了しています。完全なテキストがここに再現されています。"
    },
    {
      "indent": 6,
      "text": "State diagrams are used to represent the operation of the protocol by a number of cooperating state machines, each comprising a group of connected, mutually exclusive states. Only one state of each machine can be active at any given time.",
      "ja": "状態図は、協働する状態機械の数でプロトコルの動作を表すために使用され、それぞれが接続され、相互に排他的な状態の基を含みます。各マシンの唯一の状態は、任意の時点でアクティブにできます。"
    },
    {
      "indent": 6,
      "text": "Each state is represented in the state diagram as a rectangular box, divided into two parts by a horizontal line. The upper part contains the state identifier, written in uppercase letters. The lower part contains any procedures that are executed upon entry to the state.",
      "ja": "各状態は、水平線によって二つの部分に分け、長方形の箱のような状態図に示されています。上部は大文字で書かれた状態識別子が含まれています。下部は、状態に入るときに実行される任意の手順を含んでいます。"
    },
    {
      "indent": 6,
      "text": "All permissible transitions between states are represented by arrows, the arrowhead denoting the direction of the possible transition. Labels attached to arrows denote the condition(s) that must be met in order for the transition to take place. All conditions are expressions that evaluate to TRUE or FALSE; if a condition evaluates to TRUE, then the condition is met. The label UCT denotes an unconditional transition (i.e., UCT always evaluates to TRUE). A transition that is global in nature (i.e., a transition that occurs from any of the possible states if the condition attached to the arrow is met) is denoted by an open arrow; i.e., no specific state is identified as the origin of the transition. When the condition associated with a global transition is met, it supersedes all other exit conditions including UCT. The special global condition BEGIN supersedes all other global conditions, and once asserted it remains asserted until all state blocks have executed to the point that variable assignments and other consequences of their execution remain unchanged.",
      "ja": "状態間の全ての許容遷移は、矢印で可能な遷移の方向を示す矢印で表されています。矢印に取り付けられたラベルは、場所を取るために遷移ために満たされなければならない条件（複数可）を意味します。すべての条件がTRUEまたはFALSEに評価式です。条件がTRUEと評価される場合、その条件が満たされています。ラベルUCTは無条件遷移（すなわち、UCTは常にTRUEに評価される）です。性質（すなわち、矢印に取り付けられた条件が満たされた場合に可能な状態のいずれかから生じる遷移）が白抜きの矢印で示されているのグローバルである遷移。すなわち、具体的な状態遷移の起源として同定されていません。グローバル遷移に関連付けられた条件が満たされたとき、それはUCTを含むすべての他の終了条件に取って代わります。特別なグローバルな条件の他のすべてのグローバルな条件を優先し、一度すべての状態ブロックは変数の代入とその実行の他の結果が変わらないことをポイントに実行されるまで、それがアサートされたままアサートBEGIN。"
    },
    {
      "indent": 6,
      "text": "On entry to a state, the procedures defined for the state (if any) are executed exactly once, in the order that they appear on the page. Each action is deemed to be atomic; i.e., execution of a procedure completes before the next sequential procedure starts to execute. No procedures execute outside a state block. The procedures in only one state block execute at a time, even if the conditions for execution of state blocks in different state machines are satisfied, and all procedures in an executing state block complete execution before the transition to and execution of any other state block occurs. That is, the execution of any state block appears to be atomic with respect to the execution of any other state block, and the transition condition to that state from the previous state is TRUE when execution commences. The order of execution of state blocks in different state machines is undefined except as constrained by their transition conditions. A variable that is set to a particular value in a state block retains this value until a subsequent state block executes a procedure that modifies the value.",
      "ja": "状態へのエントリでは、状態（もしあれば）のために定義された手順は、それらがページに表示される順序で、一度だけ実行されます。各アクションはアトミックであるとみなされます。次の連続手順が実行を開始する前に、すなわち、手順の実行が完了します。いいえ手順は、状態ブロックの外側で実行しません。唯一つの状態ブロック内の手順が異なる状態マシンの状態ブロックの実行条件が成立している場合でも、一度に実行し、他の状態ブロックに遷移し、実行前に実行状態ブロックの完全な実行中のすべての手順が発生します。すなわち、任意の状態ブロックの実行は、他の状態ブロックの実行に対してアトミックであるように見える、そして実行が始まるときに以前の状態からの状態への遷移条件がTRUEです。異なる状態マシンの状態ブロックの実行の順序は、それらの遷移条件によって制約される場合を除き定義されていません。その後の状態ブロックは、値を修正手順を実行するまで、状態ブロック内の特定の値に設定されている変数は、この値を保持します。"
    },
    {
      "indent": 6,
      "text": "On completion of all the procedures within a state, all exit conditions for the state (including all conditions associated with global transitions) are evaluated continuously until one of the conditions is met. The label ELSE denotes a transition that occurs if none of the other conditions for transitions from the state are met (i.e., ELSE evaluates to TRUE if all other possible exit conditions from the state evaluate to FALSE). Where two or more exit conditions with the same level of precedence become TRUE simultaneously, the choice as to which exit condition causes the state transition to take place is arbitrary.",
      "ja": "いずれかの条件が満たされるまで、状態内のすべての手順の完了時に、（グローバル遷移に関連するすべての状態を含む）状態のためのすべての終了条件を連続的に評価されます。状態からの遷移のための他の条件のいずれも満たされない場合、ラベルELSEが起こる遷移を示し（状態から他のすべての可能な終了条件がFALSEに評価された場合、すなわち、ELSE TRUEと評価）。同時にTRUEになる優先順位の同じレベルを持つ場合二つ以上の終了条件、終了条件は、状態遷移が起こるさせるようれた選択は任意です。"
    },
    {
      "indent": 6,
      "text": "Where it is necessary to split a state machine description across more than one diagram, a transition between two states that appear on different diagrams is represented by an exit arrow drawn with dashed lines, plus a reference to the diagram that contains the destination state. Similarly, dashed arrows and a dashed state box are used on the destination diagram to show the transition to the destination state. In a state machine that has been split in this way, any global transitions that can cause entry to states defined in one of the diagrams are deemed potential exit conditions for all the states of the state machine, regardless of which diagram the state boxes appear in.",
      "ja": "それは複数の図を横切って状態マシン記述を分割する必要がある場合、異なる図に表示される2つの状態間の遷移は、破線で描かれた出口矢印、プラス先の状態が含まれた図を参照することによって表現されます。同様に、矢印を破線と点線の状態ボックスが先状態への遷移を表示する宛先図に使用されています。このように分割されたステートマシンでは、図のいずれかで定義された状態へのエントリを生じさせることができる任意のグローバルな遷移は、状態ボックスを図式かかわらず、その状態マシンのすべての状態のための潜在的な終了条件は、で表示さとみなされます。"
    },
    {
      "indent": 6,
      "text": "Should a conflict exist between the interpretation of a state diagram and either the corresponding global transition tables or the textual description associated with the state machine, the state diagram takes precedence. The interpretation of the special symbols and operators used in the state diagrams is as defined in Section 3.2; these symbols and operators are derived from the notation of the C++ programming language, ISO/IEC 14882. If a boolean variable is described in this clause as being set, it has or is assigned the value TRUE; if it is described as being reset or clear, it has the value FALSE.",
      "ja": "状態図の解釈のいずれか対応するグローバル遷移テーブルまたは状態機械に関連付けられたテキスト記述との間に競合が存在する必要があり、状態図が優先されます。状態図で使用される特殊記号及びオペレータの解釈は、セクション3.2で定義された通りです。これらのシンボルとオペレータがC ++プログラミング言語の表記に由来する、ISO / IEC 14882.ブール変数が設定されているように、この節で説明されている場合は、それが有するかTRUE値が割り当てられます。それは、リセットまたはクリアであると記載されている場合、それは値FALSEを有しています。"
    },
    {
      "indent": 3,
      "text": "In addition to the above notation, there are a couple of clarifications specific to this document. First, all boolean variables are initialized to FALSE before the state machine execution begins. Second, the following notational shorthand is specific to this document:",
      "ja": "上記表記法に加えて、この文書に固有の明確化のカップルがあります。ステートマシンの実行を開始する前にまず、すべてのブール変数がFALSEに初期化されます。第二に、以下の表記速記は、この文書に固有のものです："
    },
    {
      "indent": 3,
      "text": "<variable> = <expression1> | <expression2> | ...",
      "ja": "<変数> = <式1> | <式2> | ..."
    },
    {
      "indent": 6,
      "text": "Execution of a statement of this form will result in <variable> having a value of exactly one of the expressions. The logic for which of those expressions gets executed is outside of the state machine and could be environmental, configurable, or based on another state machine, such as that of the method.",
      "ja": "この形式の文を実行すると、表現の正確に一つの値を持つ<変数>になります。実行されますこれらの表現の対象の論理は、ステートマシンの外であり、そのような方法と、環境設定、または別の状態機械に基づくことができます。"
    },
    {
      "indent": 0,
      "text": "3.2. State Machine Symbols",
      "section_title": true,
      "ja": "3.2。ステートマシンシンボル"
    },
    {
      "indent": 3,
      "text": "( )",
      "ja": "（ ）"
    },
    {
      "indent": 6,
      "text": "Used to force the precedence of operators in Boolean expressions and to delimit the argument(s) of actions within state boxes.",
      "ja": "ブール式での演算子の優先順位を強制すると、状態ボックス内のアクションの引数を区切るために使用されます。"
    },
    {
      "indent": 3,
      "text": ";",
      "ja": "；"
    },
    {
      "indent": 6,
      "text": "Used as a terminating delimiter for actions within state boxes. If a state box contains multiple actions, the order of execution follows the normal English language conventions for reading text.",
      "ja": "状態ボックス内のアクションのための終端区切り文字として使用されます。状態ボックスは、複数のアクションが含まれている場合は、実行の順序は、テキストを読むための通常の英語言語の規則に従います。"
    },
    {
      "indent": 3,
      "text": "=",
      "ja": "＝"
    },
    {
      "indent": 6,
      "text": "Assignment action. The value of the expression to the right of the operator is assigned to the variable to the left of the operator. If this operator is used to define multiple assignments (e.g., a = b = X), the action causes the value of the expression following the right-most assignment operator to be assigned to all the variables that appear to the left of the right-most assignment operator.",
      "ja": "割り当てアクション。演算子の右側の式の値は、オペレータの左側に変数に代入されます。この演算子は、複数の割り当て（例えば、A = B = X）を定義するために使用されている場合は、アクションは一番右の代入演算子を次の式の値が右の左側に表示されるすべての変数に代入されますほとんどの代入演算子。"
    },
    {
      "indent": 3,
      "text": "!",
      "ja": "！"
    },
    {
      "indent": 6,
      "text": "Logical NOT operator.",
      "ja": "NOT論理演算子。"
    },
    {
      "indent": 3,
      "text": "&&",
      "ja": "＆＆"
    },
    {
      "indent": 6,
      "text": "Logical AND operator.",
      "ja": "論理AND演算子。"
    },
    {
      "indent": 3,
      "text": "||",
      "ja": "｜｜"
    },
    {
      "indent": 6,
      "text": "Logical OR operator.",
      "ja": "論理OR演算子。"
    },
    {
      "indent": 3,
      "text": "if...then...",
      "ja": "そして...もし..."
    },
    {
      "indent": 6,
      "text": "Conditional action. If the Boolean expression following the \"if\" evaluates to TRUE, then the action following the \"then\" is executed.",
      "ja": "条件付きアクション。 「それから」実行され、次のTRUEと評価され、「場合」は、アクション以下のブール式は、If。"
    },
    {
      "indent": 3,
      "text": "{ statement 1, ... statement N }",
      "ja": "{文1、... N}ステートメント"
    },
    {
      "indent": 6,
      "text": "Compound statement. Braces are used to group statements that are executed together as if they were a single statement.",
      "ja": "複合文。中カッコは、それらが単一の文であるかのようにまとめて実行されているグループ文に使用されています。"
    },
    {
      "indent": 3,
      "text": "!=",
      "ja": "！＝"
    },
    {
      "indent": 6,
      "text": "Inequality. Evaluates to TRUE if the expression to the left of the operator is not equal in value to the expression to the right.",
      "ja": "不平等。演算子の左の式が右式の値に等しくない場合にTRUEと評価。"
    },
    {
      "indent": 3,
      "text": "==",
      "ja": "＝＝"
    },
    {
      "indent": 6,
      "text": "Equality. Evaluates to TRUE if the expression to the left of the operator is equal in value to the expression to the right.",
      "ja": "平等。演算子の左の式が右式の値に等しい場合にTRUEと評価。"
    },
    {
      "indent": 3,
      "text": ">",
      "ja": "＞"
    },
    {
      "indent": 6,
      "text": "Greater than. Evaluates to TRUE if the value of the expression to the left of the operator is greater than the value of the expression to the right.",
      "ja": "より大きい。演算子の左側の式の値が右に式の値よりも大きい場合にTRUEと評価。"
    },
    {
      "indent": 3,
      "text": "<=",
      "ja": "＜＝"
    },
    {
      "indent": 6,
      "text": "Less than or equal to. Evaluates to TRUE if the value of the expression to the left of the operator is either less than or equal to the value of the expression to the right.",
      "ja": "より小さいか等しいです。演算子の左側の式の値のいずれか未満または右に式の値と等しい場合にTRUEと評価。"
    },
    {
      "indent": 3,
      "text": "++",
      "ja": "＋＋"
    },
    {
      "indent": 6,
      "text": "Increment the preceding integer operator by 1.",
      "ja": "1によって先行整数演算子をインクリメント。"
    },
    {
      "indent": 3,
      "text": "+",
      "ja": "＋"
    },
    {
      "indent": 6,
      "text": "Arithmetic addition operator.",
      "ja": "算術加算演算子。"
    },
    {
      "indent": 3,
      "text": "&",
      "ja": "＆"
    },
    {
      "indent": 6,
      "text": "Bitwise AND operator.",
      "ja": "ビット単位のAND演算子。"
    },
    {
      "indent": 0,
      "text": "3.3. Document Authority",
      "section_title": true,
      "ja": "3.3。ドキュメントの権限"
    },
    {
      "indent": 3,
      "text": "Should a conflict exist between the interpretation of a state diagram and either the corresponding global transition tables or the textual description associated with the state machine, the state diagram takes precedence. When a discrepancy occurs between any part of this document (text or diagram) and any of the related documents ([RFC3748], [RFC3579], etc.), the latter (the other document) is considered authoritative and takes precedence.",
      "ja": "状態図の解釈のいずれか対応するグローバル遷移テーブルまたは状態機械に関連付けられたテキスト記述との間に競合が存在する必要があり、状態図が優先されます。不一致この文書（テキストまたは図）及び関連文書のいずれか（[RFC3748]、[RFC3579]など）、後者（他の文書）のいずれかの部分との間に発生したときに、権威とみなされ、優先されます。"
    },
    {
      "indent": 0,
      "text": "4. Peer State Machine",
      "section_title": true,
      "ja": "4.ピア状態マシン"
    },
    {
      "indent": 3,
      "text": "The following is a diagram of the EAP peer state machine. Also included is an explanation of the primitives and procedures referenced in the diagram, as well as a clarification of notation.",
      "ja": "以下は、EAPピア状態機械の図です。また、図中で参照プリミティブと手順の説明、ならびに表記の明確化も含まれます。"
    },
    {
      "indent": 12,
      "text": "   (see the .pdf version for missing diagram or\nrefer to Appendix A.1 if reading the .txt version)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 3: EAP Peer State Machine",
      "ja": "図3：EAPピアステートマシン"
    },
    {
      "indent": 0,
      "text": "4.1. Interface between Peer State Machine and Lower Layer",
      "section_title": true,
      "ja": "4.1。ピアステートマシンと下層との間のインターフェイス"
    },
    {
      "indent": 3,
      "text": "The lower layer presents messages to the EAP peer state machine by storing the packet in eapReqData and setting the eapReq signal to TRUE. Note that despite the name of the signal, the lower layer does not actually inspect the contents of the EAP packet (it could be a Success or Failure message instead of a Request).",
      "ja": "下層eapReqDataにパケットを格納し、TRUEにeapReq信号を設定することにより、EAPピア状態マシンにメッセージを提示します。信号の名称にもかかわらず、下層が実際EAPパケットの内容を検査しないことに注意してください（これは、代わりに要求の成功または失敗メッセージであってもよいです）。"
    },
    {
      "indent": 3,
      "text": "When the EAP peer state machine has finished processing the message, it sets either eapResp or eapNoResp. If it sets eapResp, the corresponding response packet is stored in eapRespData. The lower layer is responsible for actually transmitting this message. When the EAP peer state machine authentication is complete, it will set eapSuccess or eapFailure to indicate to the lower layer that the authentication has succeeded or failed.",
      "ja": "EAPピア状態マシンがメッセージの処理を終了したとき、それはeapResp又はeapNoRespのいずれかを設定します。それはeapRespを設定した場合、対応する応答パケットがeapRespDataに格納されます。下の層は、実際にこのメッセージを送信するための責任があります。 EAPピア状態のマシン認証が完了すると、認証が成功したか失敗したことを下位層に示すために、eapSuccessまたはeapFailureを設定します。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Variables (Lower Layer to Peer)",
      "section_title": true,
      "ja": "4.1.1。変数（ピアツーピア下層）"
    },
    {
      "indent": 3,
      "text": "eapReq (boolean)",
      "ja": "eapReq（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in lower layer, FALSE in peer state machine. Indicates that a request is available in the lower layer.",
      "ja": "ピア・ステート・マシンでFALSE、下層にTRUEに設定します。リクエストが下層に利用可能であることを示します。"
    },
    {
      "indent": 3,
      "text": "eapReqData (EAP packet)",
      "ja": "eapReqData（EAPパケット）"
    },
    {
      "indent": 6,
      "text": "Set in lower layer when eapReq is set to TRUE. The contents of the available request.",
      "ja": "eapReqがTRUEに設定されている下層に設定してください。利用できる要求の内容。"
    },
    {
      "indent": 3,
      "text": "portEnabled (boolean)",
      "ja": "portEnabled（ブール値）"
    },
    {
      "indent": 6,
      "text": "Indicates that the EAP peer state machine should be ready for communication. This is set to TRUE when the EAP conversation is started by the lower layer. If at any point the communication port or session is not available, portEnabled is set to FALSE, and the state machine transitions to DISABLED. To avoid unnecessary resets, the lower layer may dampen link down indications when it believes that the link is only temporarily down and that it will soon be back up (see [RFC3748], Section 7.12). In this case, portEnabled may not always be equal to the \"link up\" flag of the lower layer.",
      "ja": "EAPピアのステートマシンは、通信のための準備ができている必要があることを示します。 EAPの会話が下位層によって開始されたときにこれがTRUEに設定されています。任意の時点で通信ポートまたはセッションが使用できない場合、portEnabledがDISABLEDにFALSE、ステートマシン遷移に設定されています。それはすぐに戻ってくるというリンクが一時的にしかダウンしていると信じているとするとき、不要なリセットを回避するために、下位層が指摘ダウンリンクを減衰させること（[RFC3748]のセクション7.12を参照してください）。この場合、portEnabledは常に下層の「リンクアップ」フラグに等しくなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "idleWhile (integer)",
      "ja": "idleWhile（整数）"
    },
    {
      "indent": 6,
      "text": "Outside timer used to indicate how much time remains before the peer will time out while waiting for a valid request.",
      "ja": "外タイマーは有効な要求を待っている間に、ピアがタイムアウトするまでの残り時間を示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "eapRestart (boolean)",
      "ja": "eapRestart（ブール値）"
    },
    {
      "indent": 6,
      "text": "Indicates that the lower layer would like to restart authentication.",
      "ja": "下位層が認証を再起動したいことを示します。"
    },
    {
      "indent": 3,
      "text": "altAccept (boolean)",
      "ja": "altAccept（ブール値）"
    },
    {
      "indent": 6,
      "text": "Alternate indication of success, as described in [RFC3748].",
      "ja": "[RFC3748]に記載されているように、成功の代替指標、。"
    },
    {
      "indent": 3,
      "text": "altReject (boolean)",
      "ja": "altReject（ブール値）"
    },
    {
      "indent": 6,
      "text": "Alternate indication of failure, as described in [RFC3748].",
      "ja": "[RFC3748]に記載されているように、障害の代替指標、。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Variables (peer to lower layer)",
      "section_title": true,
      "ja": "4.1.2。変数（下層のピア）"
    },
    {
      "indent": 3,
      "text": "eapResp (boolean)",
      "ja": "eapResp（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in peer state machine, FALSE in lower layer. Indicates that a response is to be sent.",
      "ja": "下層にFALSE、ピアステートマシンでTRUEに設定します。応答が送信されることを示します。"
    },
    {
      "indent": 3,
      "text": "eapNoResp (boolean)",
      "ja": "eapNoResp（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in peer state machine, FALSE in lower layer. Indicates that the request has been processed, but that there is no response to send.",
      "ja": "下層にFALSE、ピアステートマシンでTRUEに設定します。リクエストが処理されたことはなく、送信する応答がないことを示します。"
    },
    {
      "indent": 3,
      "text": "eapSuccess (boolean)",
      "ja": "eapSuccess（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in peer state machine, FALSE in lower layer. Indicates that the peer has reached the SUCCESS state.",
      "ja": "下層にFALSE、ピアステートマシンでTRUEに設定します。ピアがSUCCESS状態に達したことを示します。"
    },
    {
      "indent": 3,
      "text": "eapFail (boolean)",
      "ja": "eapFail（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in peer state machine, FALSE in lower layer. Indicates that the peer has reached the FAILURE state.",
      "ja": "下層にFALSE、ピアステートマシンでTRUEに設定します。ピアがFAILURE状態に達したことを示します。"
    },
    {
      "indent": 3,
      "text": "eapRespData (EAP packet)",
      "ja": "eapRespData（EAPパケット）"
    },
    {
      "indent": 6,
      "text": "Set in peer state machine when eapResp is set to TRUE. The EAP packet that is the response to send.",
      "ja": "eapRespがTRUEに設定されている場合、ピアステートマシンに設定してください。送信する応答であるEAPパケット。"
    },
    {
      "indent": 3,
      "text": "eapKeyData (EAP key)",
      "ja": "eapKeyData（EAPキー）"
    },
    {
      "indent": 6,
      "text": "Set in peer state machine when keying material becomes available. Set during the METHOD state. Note that this document does not define the structure of the type \"EAP key\". We expect that it will be defined in [Keying].",
      "ja": "鍵材料が使用可能になったときに、ピア・ステート・マシンに設定してください。 METHOD状態の時に設定してください。この文書は、タイプ「EAPキー」の構造を定義していないことに注意してください。私たちは、それが[イング]で定義されることを期待しています。"
    },
    {
      "indent": 3,
      "text": "eapKeyAvailable (boolean)",
      "ja": "eapKeyAvailable（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in the SUCCESS state if keying material is available. The actual key is stored in eapKeyData.",
      "ja": "材料をキーイングが利用可能な場合SUCCESS状態でTRUEに設定します。実際のキーはeapKeyDataに格納されます。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Constants",
      "section_title": true,
      "ja": "4.1.3。定数"
    },
    {
      "indent": 3,
      "text": "ClientTimeout (integer)",
      "ja": "ClientTimeout（整数）"
    },
    {
      "indent": 6,
      "text": "Configurable amount of time to wait for a valid request before aborting, initialized by implementation-specific means (e.g., a configuration setting).",
      "ja": "実装固有の手段（例えば、構成設定）によって初期化中止する前に、有効な要求を待つ時間の設定可能な量、。"
    },
    {
      "indent": 0,
      "text": "4.2. Interface between Peer State Machine and Methods",
      "section_title": true,
      "ja": "4.2。ピアステートマシンとメソッドの間のインタフェース"
    },
    {
      "indent": 3,
      "text": "IN: eapReqData (includes reqId)",
      "ja": "IN：eapReqData（REQIDが含まれます）"
    },
    {
      "indent": 3,
      "text": "OUT: ignore, eapRespData, allowNotifications, decision",
      "ja": "OUT：無視、eapRespData、allowNotifications、意思決定"
    },
    {
      "indent": 3,
      "text": "IN/OUT: methodState, (method-specific state)",
      "ja": "IN / OUT：methodState、（メソッド固有の状態）"
    },
    {
      "indent": 3,
      "text": "The following describes the interaction between the state machine and EAP methods.",
      "ja": "以下は、ステートマシンとEAPメソッド間の相互作用を記述する。"
    },
    {
      "indent": 3,
      "text": "If methodState==INIT, the method starts by initializing its own method-specific state.",
      "ja": "methodState == INIT場合は、この方法では、独自のメソッド固有の状態を初期化することによって開始します。"
    },
    {
      "indent": 3,
      "text": "Next, the method must decide whether to process the packet or to discard it silently. If the packet appears to have been sent by someone other than the legitimate authenticator (for instance, if message integrity check fails) and the method is capable of treating such situations as non-fatal, the method can set ignore=TRUE. In this case, the method should not modify any other variables.",
      "ja": "次に、この方法は、パケットを処理するか、黙ってそれを破棄するかどうかを決定する必要があります。パケットが正当な認証システム以外の誰かによって送信されたと表示された場合（メッセージ整合性チェックが失敗した場合、たとえば、）および方法は致命的ではないとして、このような状況を処理することができ、この方法は、TRUE =無視を設定することができます。この場合、この方法は、他の変数を変更しないでください。"
    },
    {
      "indent": 3,
      "text": "If the method decides to process the packet, it behaves as follows.",
      "ja": "この方法は、パケットを処理することを決定した場合、次のように、それが動作します。"
    },
    {
      "indent": 3,
      "text": "o It updates its own method-specific state.",
      "ja": "Oそれは、独自のメソッド固有の状態を更新します。"
    },
    {
      "indent": 3,
      "text": "o If the method has derived keying material it wants to export, it stores the keying material to eapKeyData.",
      "ja": "この方法は、キーイング材料を得た場合、OそれはeapKeyDataにキーイング材料を格納し、エクスポートしたいと考えています。"
    },
    {
      "indent": 3,
      "text": "o It creates a response packet (with the same identifier as the request) and stores it to eapRespData.",
      "ja": "Oそれは、（要求と同じ識別子を有する）応答パケットを作成し、eapRespDataにそれを格納します。"
    },
    {
      "indent": 3,
      "text": "o It sets ignore=FALSE.",
      "ja": "OそれはFALSE =無視する設定します。"
    },
    {
      "indent": 3,
      "text": "Next, the method must update methodState and decision according to the following rules.",
      "ja": "次に、この方法は、次の規則に従ってmethodStateと意思決定を更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "methodState=CONT: The method always continues at this point (and the peer wants to continue it). The decision variable is always set to FAIL.",
      "ja": "methodState = CONT：メソッドは、常にこの時点で継続（およびピアは、それを続けたいです）。決定変数は常に失敗するように設定されています。"
    },
    {
      "indent": 3,
      "text": "methodState=MAY_CONT: At this point, the authenticator can decide either to continue the method or to end the conversation. The decision variable tells us what to do if the conversation ends. If the current situation does not satisfy the peer's security policy (that is, if the authenticator now decides to allow access, the peer will not use it), set decision=FAIL. Otherwise, set decision=COND_SUCC.",
      "ja": "methodState = MAY_CONT：この時点では、オーセンティケータは、メソッドを継続するか、会話を終了するかを決めることができます。決定変数は、会話が終了した場合に何をすべきかを教えてくれる。現在の状況は（オーセンティケータが、今のアクセスを許可することを決定した場合であること、ピアはそれを使用しません）ピアのセキュリティポリシーを満たさない場合は、= FAILを決定する設定。それ以外の場合は、意思決定= COND_SUCCを設定します。"
    },
    {
      "indent": 3,
      "text": "methodState=DONE: The method never continues at this point (or the peer sees no point in continuing it).",
      "ja": "methodState =はDONE：メソッドは、この時点で継続しません（またはピアは、それを続けるにはポイントを見ていません）。"
    },
    {
      "indent": 6,
      "text": "If either (a) the authenticator has informed us that it will not allow access, or (b) we're not willing to talk to this authenticator (e.g., our security policy is not satisfied), set decision=FAIL. (Note that this state can occur even if the method still has additional messages left, if continuing it cannot change the peer's decision to success).",
      "ja": "どちらかの（a）は、オーセンティケータは、それがアクセスを許可しない、または（b）私たちは、このオーセンティケータに話をして喜んじゃないことを私たちに伝えている場合（例えば、当社のセキュリティポリシーを満たしていない）、設定決定= FAIL。 （継続あれば、それは成功にピアの決定を変更することはできません、方法がまだ残って追加メッセージを持っている場合でも、この状態が発生する可能性があることに注意してください）。"
    },
    {
      "indent": 6,
      "text": "If both (a) the server has informed us that it will allow access, and the next packet will be EAP Success, and (b) we're willing to use this access, set decision=UNCOND_SUCC.",
      "ja": "（a）は、サーバは、アクセスを許可することを私たちに通知した、と次のパケットは、EAP成功となり、および（b）は、我々はこのアクセスを使用するために喜んでいる、設定の決定= UNCOND_SUCC。両方の場合"
    },
    {
      "indent": 6,
      "text": "Otherwise, we do not know what the server's decision is, but are willing to use the access if the server allows. In this case, set decision=COND_SUCC.",
      "ja": "そうでなければ、我々は、サーバーの決定が何であるかを知っているが、サーバーが許可する場合アクセスを使用して喜んでいるしないでください。この場合、決定= COND_SUCCを設定します。"
    },
    {
      "indent": 3,
      "text": "Finally, the method must set the allowNotifications variable. If the new methodState is either CONT or MAY_CONT, and if the method specification does not forbid the use of Notification messages, set allowNotifications=TRUE. Otherwise, set allowNotifications=FALSE.",
      "ja": "最後に、この方法は、allowNotifications変数を設定する必要があります。新しいmethodStateはCONTまたはMAY_CONTのいずれかである場合メソッドの仕様は、通知メッセージの使用を禁止していない場合、および、allowNotifications = TRUEを設定します。それ以外の場合は、allowNotifications =はFALSEに設定。"
    },
    {
      "indent": 0,
      "text": "4.3. Peer State Machine Local Variables",
      "section_title": true,
      "ja": "4.3。ステートマシンローカル変数をピア"
    },
    {
      "indent": 0,
      "text": "4.3.1. Long-Term (Maintained between Packets)",
      "section_title": true,
      "ja": "4.3.1。 （パケット間維持される）長期"
    },
    {
      "indent": 3,
      "text": "selectMethod (EAP type)",
      "ja": "selectMethod（EAPタイプ）"
    },
    {
      "indent": 6,
      "text": "Set in GET_METHOD state. The method that the peer believes is currently \"in progress\"",
      "ja": "GET_METHOD状態に設定してください。ピアが「進行中」、現在あると考えている方法"
    },
    {
      "indent": 3,
      "text": "methodState (enumeration)",
      "ja": "methodState（列挙）"
    },
    {
      "indent": 6,
      "text": "As described above.",
      "ja": "上記のように。"
    },
    {
      "indent": 3,
      "text": "lastId (integer)",
      "ja": "lastId（整数）"
    },
    {
      "indent": 6,
      "text": "0-255 or NONE. Set in SEND_RESPONSE state. The EAP identifier value of the last request.",
      "ja": "0-255またはNONE。 SEND_RESPONSE状態に設定してください。最後の要求のEAP識別子の値。"
    },
    {
      "indent": 3,
      "text": "lastRespData (EAP packet)",
      "ja": "lastRespData（EAPパケット）"
    },
    {
      "indent": 6,
      "text": "Set in SEND_RESPONSE state. The EAP packet last sent from the peer.",
      "ja": "SEND_RESPONSE状態に設定してください。 EAPパケットは、最後のピアから送信されました。"
    },
    {
      "indent": 3,
      "text": "decision (enumeration)",
      "ja": "決定（列挙）"
    },
    {
      "indent": 6,
      "text": "As described above.",
      "ja": "上記のように。"
    },
    {
      "indent": 3,
      "text": "NOTE: EAP type can be normal type (0..253,255), or an extended type consisting of type 254, Vendor-Id, and Vendor-Type.",
      "ja": "注：EAPタイプが正常タイプ（0..253,255）、またはタイプ254から成る拡張型、ベンダーID、ベンダー型とすることができます。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Short-Term (Not Maintained between Packets)",
      "section_title": true,
      "ja": "4.3.2。短期（パケットの間で維持されません）"
    },
    {
      "indent": 3,
      "text": "rxReq (boolean)",
      "ja": "rxReq（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set in RECEIVED state. Indicates that the current received packet is an EAP request.",
      "ja": "受信した状態で設定してください。現在の受信パケットがEAP要求であることを示します。"
    },
    {
      "indent": 3,
      "text": "rxSuccess (boolean)",
      "ja": "rxSuccess（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set in RECEIVED state. Indicates that the current received packet is an EAP Success.",
      "ja": "受信した状態で設定してください。現在の受信パケットがEAP成功であることを示します。"
    },
    {
      "indent": 3,
      "text": "rxFailure (boolean)",
      "ja": "rxFailure（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set in RECEIVED state. Indicates that the current received packet is an EAP Failure.",
      "ja": "受信した状態で設定してください。現在の受信パケットがEAPの失敗であることを示します。"
    },
    {
      "indent": 3,
      "text": "reqId (integer)",
      "ja": "REQID（整数）"
    },
    {
      "indent": 6,
      "text": "Set in RECEIVED state. The identifier value associated with the current EAP request.",
      "ja": "受信した状態で設定してください。現在のEAP要求に関連付けられた識別子の値。"
    },
    {
      "indent": 3,
      "text": "reqMethod (EAP type)",
      "ja": "reqMethod（EAPタイプ）"
    },
    {
      "indent": 6,
      "text": "Set in RECEIVED state. The method type of the current EAP request.",
      "ja": "受信した状態で設定してください。現在のEAP要求のメソッドタイプ。"
    },
    {
      "indent": 3,
      "text": "ignore (boolean)",
      "ja": "（boolean）を無視します"
    },
    {
      "indent": 6,
      "text": "Set in METHOD state. Indicates whether the method has decided to drop the current packet.",
      "ja": "METHOD状態に設定してください。この方法は、現在のパケットをドロップすることを決定したかどうかを示します。"
    },
    {
      "indent": 0,
      "text": "4.4. Peer State Machine Procedures",
      "section_title": true,
      "ja": "4.4。ステートマシンの手順をピア"
    },
    {
      "indent": 3,
      "text": "NOTE: For method procedures, the method uses its internal state in addition to the information provided by the EAP layer. The only arguments that are explicitly shown as inputs to the procedures are those provided to the method by EAP. Those inputs provided by the method's internal state remain implicit.",
      "ja": "注：この方法の手順については、本方法はEAP層によって提供される情報に加えて、その内部状態を使用します。明示的手順への入力として示されている唯一の引数はEAPによる方法を提供するものです。メソッドの内部状態によって提供される入力は暗黙のまま。"
    },
    {
      "indent": 3,
      "text": "parseEapReq()",
      "ja": "parseEapReq（）"
    },
    {
      "indent": 6,
      "text": "Determine the code, identifier value, and type of the current request. In the case of a parsing error (e.g., the length field is longer than the received packet), rxReq, rxSuccess, and rxFailure will all be set to FALSE. The values of reqId and reqMethod may be undefined as a result. Returns three booleans, one integer, and one EAP type.",
      "ja": "コード、識別子の値と、現在の要求のタイプを決定します。解析エラーの場合に（例えば、長さフィールドは長く、受信したパケットよりも）、rxReq、rxSuccess、及びrxFailureは全てがFALSEに設定されます。 REQIDとreqMethodの値は、結果として不定することができます。 3つのブール値、1つの整数であり、1つのEAPタイプを返します。"
    },
    {
      "indent": 3,
      "text": "processNotify()",
      "ja": "processNotify（）"
    },
    {
      "indent": 6,
      "text": "Process the contents of Notification Request (for instance, display it to the user or log it). The return value is undefined.",
      "ja": "通知要求（例えば、ユーザーにそれを表示するか、またはそれをログ）の内容を処理します。戻り値は未定義です。"
    },
    {
      "indent": 3,
      "text": "buildNotify()",
      "ja": "buildNotify（）"
    },
    {
      "indent": 6,
      "text": "Create the appropriate notification response. Returns an EAP packet.",
      "ja": "適切な通知応答を作成します。 EAPパケットを返します。"
    },
    {
      "indent": 3,
      "text": "processIdentity()",
      "ja": "processIdentity（）"
    },
    {
      "indent": 6,
      "text": "Process the contents of Identity Request. Return value is undefined.",
      "ja": "アイデンティティ要求の内容を処理します。戻り値は未定義です。"
    },
    {
      "indent": 3,
      "text": "buildIdentity()",
      "ja": "buildIdentity（）"
    },
    {
      "indent": 6,
      "text": "Create the appropriate identity response. Returns an EAP packet.",
      "ja": "適切なアイデンティティ応答を作成します。 EAPパケットを返します。"
    },
    {
      "indent": 3,
      "text": "m.check()",
      "ja": "m.check（）"
    },
    {
      "indent": 6,
      "text": "Method-specific procedure to test for the validity of a message. Returns a boolean.",
      "ja": "メッセージの有効性をテストするための方法、具体的な手順。ブール値を返します。"
    },
    {
      "indent": 3,
      "text": "m.process()",
      "ja": "m.process（）"
    },
    {
      "indent": 6,
      "text": "Method procedure to parse and process a request for that method. Returns a methodState enumeration, a decision enumeration, and a boolean.",
      "ja": "その方法のための要求を解析し、処理する方法の手順。 methodState列挙、決定列挙、およびブール値を返します。"
    },
    {
      "indent": 3,
      "text": "m.buildResp()",
      "ja": "m.buildResp（）"
    },
    {
      "indent": 6,
      "text": "Method procedure to create a response message. Returns an EAP packet.",
      "ja": "メソッドの手順は、応答メッセージを作成します。 EAPパケットを返します。"
    },
    {
      "indent": 3,
      "text": "m.getKey()",
      "ja": "m.getKey（）"
    },
    {
      "indent": 6,
      "text": "Method procedure to obtain key material for use by EAP or lower layers. Returns an EAP key.",
      "ja": "EAPまたは下位層で使用するための鍵材料を得る方法の手順。 EAPキーを返します。"
    },
    {
      "indent": 0,
      "text": "4.5. Peer State Machine States",
      "section_title": true,
      "ja": "4.5。ステートマシンの状態をピア"
    },
    {
      "indent": 3,
      "text": "DISABLED",
      "ja": "DISABLED"
    },
    {
      "indent": 6,
      "text": "This state is reached whenever service from the lower layer is interrupted or unavailable. Immediate transition to INITIALIZE occurs when the port becomes enabled.",
      "ja": "下位層からのサービスが中断または利用できない時はいつでも、この状態に到達します。ポートが有効になったときに初期化するために即時移行が起こります。"
    },
    {
      "indent": 3,
      "text": "INITIALIZE",
      "ja": "INITIALIZE"
    },
    {
      "indent": 6,
      "text": "Initializes variables when the state machine is activated.",
      "ja": "ステートマシンが起動されると、変数を初期化します。"
    },
    {
      "indent": 3,
      "text": "IDLE",
      "ja": "IDLE"
    },
    {
      "indent": 6,
      "text": "The state machine spends most of its time here, waiting for something to happen.",
      "ja": "ステートマシンは、何かが起こるのを待って、ここではそのほとんどの時間を費やしています。"
    },
    {
      "indent": 3,
      "text": "RECEIVED",
      "ja": "RECEIVED"
    },
    {
      "indent": 6,
      "text": "This state is entered when an EAP packet is received. The packet header is parsed here.",
      "ja": "EAPパケットを受信したとき、この状態が入力されます。パケットヘッダはここで解析されます。"
    },
    {
      "indent": 3,
      "text": "GET_METHOD",
      "ja": "GET_METHOD"
    },
    {
      "indent": 6,
      "text": "This state is entered when a request for a new type comes in. Either the correct method is started, or a Nak response is built.",
      "ja": "新しいタイプの要求が入ってきたときに、この状態は、いずれの正しい方法が開始される。入力された、またはNAK応答が構築されています。"
    },
    {
      "indent": 3,
      "text": "METHOD",
      "ja": "方法"
    },
    {
      "indent": 6,
      "text": "The method processing happens here. The request from the authenticator is processed, and an appropriate response packet is built.",
      "ja": "メソッドの処理はここで起こります。オーセンティケータからのリクエストが処理され、適切な応答パケットが構築されています。"
    },
    {
      "indent": 3,
      "text": "SEND_RESPONSE",
      "ja": "SEND_RESPONSE"
    },
    {
      "indent": 6,
      "text": "This state signals the lower layer that a response packet is ready to be sent.",
      "ja": "この状態は、応答パケットを送信する準備ができている下層に信号を送ります。"
    },
    {
      "indent": 3,
      "text": "DISCARD",
      "ja": "DISCARD"
    },
    {
      "indent": 6,
      "text": "This state signals the lower layer that the request was discarded, and no response packet will be sent at this time.",
      "ja": "この状態は、要求を捨て、下層の信号、および応答パケットは、この時点で送信されません。"
    },
    {
      "indent": 3,
      "text": "IDENTITY",
      "ja": "身元"
    },
    {
      "indent": 6,
      "text": "Handles requests for Identity method and builds a response.",
      "ja": "アイデンティティメソッドのリクエストを処理し、応答を構築します。"
    },
    {
      "indent": 3,
      "text": "NOTIFICATION",
      "ja": "通知"
    },
    {
      "indent": 6,
      "text": "Handles requests for Notification method and builds a response.",
      "ja": "通知方法の要求を処理し、応答を構築します。"
    },
    {
      "indent": 3,
      "text": "RETRANSMIT",
      "ja": "RETRANSMIT"
    },
    {
      "indent": 6,
      "text": "Retransmits the previous response packet.",
      "ja": "前回の応答パケットを再送します。"
    },
    {
      "indent": 3,
      "text": "SUCCESS",
      "ja": "成功"
    },
    {
      "indent": 6,
      "text": "A final state indicating success.",
      "ja": "成功を示す最終状態。"
    },
    {
      "indent": 3,
      "text": "FAILURE",
      "ja": "FAILURE"
    },
    {
      "indent": 6,
      "text": "A final state indicating failure.",
      "ja": "失敗したことを示す最終状態。"
    },
    {
      "indent": 0,
      "text": "5. Stand-Alone Authenticator State Machine",
      "section_title": true,
      "ja": "5.スタンドアロン認証ステートマシン"
    },
    {
      "indent": 3,
      "text": "The following is a diagram of the stand-alone EAP authenticator state machine. This diagram should be used for those interested in a self-contained, or non-pass-through, authenticator. Included is an explanation of the primitives and procedures referenced in the diagram, as well as a clarification of notation.",
      "ja": "以下は、スタンドアローンのEAP認証マシンの図です。この図は、自己完結型、または非パススルー、オーセンティケータに興味のある人のために使用されるべきです。付属図面で参照プリミティブと手順の説明、ならびに表記の明確化です。"
    },
    {
      "indent": 12,
      "text": "   (see the .pdf version for missing diagram or\nrefer to Appendix A.2 if reading the .txt version)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 4: EAP Stand-Alone Authenticator State Machine",
      "ja": "図4：EAPは、スタンドアロン認証ステートマシン"
    },
    {
      "indent": 0,
      "text": "5.1. Interface between Stand-Alone Authenticator State Machine and Lower Layer",
      "ja": "5.1。スタンドアロン認証ステートマシンと下層との間のインターフェイス"
    },
    {
      "indent": 3,
      "text": "The lower layer presents messages to the EAP authenticator state machine by storing the packet in eapRespData and setting the eapResp signal to TRUE.",
      "ja": "下層eapRespDataにパケットを格納し、TRUEにeapResp信号を設定することによって、EAP認証ステートマシンにメッセージを提示します。"
    },
    {
      "indent": 3,
      "text": "When the EAP authenticator state machine has finished processing the message, it sets one of the signals eapReq, eapNoReq, eapSuccess, and eapFail. If it sets eapReq, eapSuccess, or eapFail, the corresponding request (or success/failure) packet is stored in eapReqData. The lower layer is responsible for actually transmitting this message.",
      "ja": "EAP認証ステートマシンがメッセージの処理を終了したとき、それは、信号eapReq、eapNoReq、eapSuccess、及びeapFailのいずれかを設定します。それはeapReq、eapSuccess、又はeapFailを設定した場合、対応する要求（または成功/失敗）パケットがeapReqDataに格納されています。下の層は、実際にこのメッセージを送信するための責任があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Variables (Lower Layer to Stand-Alone Authenticator)",
      "section_title": true,
      "ja": "5.1.1。変数（スタンドアロンするオーセンティケータを下層）"
    },
    {
      "indent": 3,
      "text": "eapResp (boolean)",
      "ja": "eapResp（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in lower layer, FALSE in authenticator state machine. Indicates that an EAP response is available for processing.",
      "ja": "認証マシンでFALSE、下層にTRUEに設定します。 EAP応答が処理のために利用可能であることを示します。"
    },
    {
      "indent": 3,
      "text": "eapRespData (EAP packet)",
      "ja": "eapRespData（EAPパケット）"
    },
    {
      "indent": 6,
      "text": "Set in lower layer when eapResp is set to TRUE. The EAP packet to be processed.",
      "ja": "eapRespがTRUEに設定されている下層に設定してください。 EAPパケットを処理します。"
    },
    {
      "indent": 3,
      "text": "portEnabled (boolean)",
      "ja": "portEnabled（ブール値）"
    },
    {
      "indent": 6,
      "text": "Indicates that the EAP authenticator state machine should be ready for communication. This is set to TRUE when the EAP conversation is started by the lower layer. If at any point the communication port or session is not available, portEnabled is set to FALSE, and the state machine transitions to DISABLED. To avoid unnecessary resets, the lower layer may dampen link down indications when it believes that the link is only temporarily down and that it will soon be back up (see [RFC3748], Section 7.12). In this case, portEnabled may not always be equal to the \"link up\" flag of the lower layer.",
      "ja": "EAP認証ステートマシンが通信のための準備ができている必要があることを示します。 EAPの会話が下位層によって開始されたときにこれがTRUEに設定されています。任意の時点で通信ポートまたはセッションが使用できない場合、portEnabledがDISABLEDにFALSE、ステートマシン遷移に設定されています。それはすぐに戻ってくるというリンクが一時的にしかダウンしていると信じているとするとき、不要なリセットを回避するために、下位層が指摘ダウンリンクを減衰させること（[RFC3748]のセクション7.12を参照してください）。この場合、portEnabledは常に下層の「リンクアップ」フラグに等しくなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "retransWhile (integer)",
      "ja": "retransWhile（整数）"
    },
    {
      "indent": 6,
      "text": "Outside timer used to indicate how long the authenticator has waited for a new (valid) response.",
      "ja": "外タイマーは、オーセンティケータは、新たな（有効な）応答を待っている時間の長さを示すために使用します。"
    },
    {
      "indent": 3,
      "text": "eapRestart (boolean)",
      "ja": "eapRestart（ブール値）"
    },
    {
      "indent": 6,
      "text": "Indicates that the lower layer would like to restart authentication.",
      "ja": "下位層が認証を再起動したいことを示します。"
    },
    {
      "indent": 3,
      "text": "eapSRTT (integer)",
      "ja": "eapSRTT（整数）"
    },
    {
      "indent": 6,
      "text": "Smoothed round-trip time. (See [RFC3748], Section 4.3.)",
      "ja": "平滑化往復時間。 （[RFC3748]、セクション4.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "eapRTTVAR (integer)",
      "ja": "eapRTTVAR（整数）"
    },
    {
      "indent": 6,
      "text": "Round-trip time variation. (See [RFC3748], Section 4.3.)",
      "ja": "ラウンドトリップ時間変化。 （[RFC3748]、セクション4.3を参照してください。）"
    },
    {
      "indent": 0,
      "text": "5.1.2. Variables (Stand-Alone Authenticator To Lower Layer)",
      "section_title": true,
      "ja": "5.1.2。変数（スタンドアロン認証下位層に）"
    },
    {
      "indent": 3,
      "text": "eapReq (boolean)",
      "ja": "eapReq（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in authenticator state machine, FALSE in lower layer. Indicates that a new EAP request is ready to be sent.",
      "ja": "下層にFALSE、認証マシンでTRUEに設定します。新しいEAP要求を送信する準備ができていることを示します。"
    },
    {
      "indent": 3,
      "text": "eapNoReq (boolean)",
      "ja": "eapNoReq（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in authenticator state machine, FALSE in lower layer. Indicates the most recent response has been processed, but there is no new request to send.",
      "ja": "下層にFALSE、認証マシンでTRUEに設定します。最新の応答が処理されたことを示しますが、送信するための新たな要求がありません。"
    },
    {
      "indent": 3,
      "text": "eapSuccess (boolean)",
      "ja": "eapSuccess（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in authenticator state machine, FALSE in lower layer. Indicates that the state machine has reached the SUCCESS state.",
      "ja": "下層にFALSE、認証マシンでTRUEに設定します。ステートマシンがSUCCESS状態に達したことを示します。"
    },
    {
      "indent": 3,
      "text": "eapFail (boolean)",
      "ja": "eapFail（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in authenticator state machine, FALSE in lower layer. Indicates that the state machine has reached the FAILURE state.",
      "ja": "下層にFALSE、認証マシンでTRUEに設定します。ステートマシンがFAILURE状態に達したことを示します。"
    },
    {
      "indent": 3,
      "text": "eapTimeout (boolean)",
      "ja": "eapTimeout（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in the TIMEOUT_FAILURE state if the authenticator has reached its maximum number of retransmissions without receiving a response.",
      "ja": "オーセンティケータは、応答を受信せずに再送信の最大数に達した場合TIMEOUT_FAILURE状態でTRUEに設定します。"
    },
    {
      "indent": 3,
      "text": "eapReqData (EAP packet)",
      "ja": "eapReqData（EAPパケット）"
    },
    {
      "indent": 6,
      "text": "Set in authenticator state machine when eapReq, eapSuccess, or eapFail is set to TRUE. The actual EAP request to be sent (or success/failure).",
      "ja": "eapReq、eapSuccess、またはeapFailがTRUEに設定されている場合、認証マシンに設定してください。実際に送信されるEAP要求（または成功/失敗）。"
    },
    {
      "indent": 3,
      "text": "eapKeyData (EAP key)",
      "ja": "eapKeyData（EAPキー）"
    },
    {
      "indent": 6,
      "text": "Set in authenticator state machine when keying material becomes available. Set during the METHOD state. Note that this document does not define the structure of the type \"EAP key\". We expect that it will be defined in [Keying].",
      "ja": "鍵材料が使用可能になったときに認証マシンに設定してください。 METHOD状態の時に設定してください。この文書は、タイプ「EAPキー」の構造を定義していないことに注意してください。私たちは、それが[イング]で定義されることを期待しています。"
    },
    {
      "indent": 3,
      "text": "eapKeyAvailable (boolean)",
      "ja": "eapKeyAvailable（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in the SUCCESS state if keying material is available. The actual key is stored in eapKeyData.",
      "ja": "材料をキーイングが利用可能な場合SUCCESS状態でTRUEに設定します。実際のキーはeapKeyDataに格納されます。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Constants",
      "section_title": true,
      "ja": "5.1.3。定数"
    },
    {
      "indent": 3,
      "text": "MaxRetrans (integer)",
      "ja": "MaxRetrans（整数）"
    },
    {
      "indent": 6,
      "text": "Configurable maximum for how many retransmissions should be attempted before aborting.",
      "ja": "どのように多くの再送信のための設定可能な最大値は、中止する前に試みるべきです。"
    },
    {
      "indent": 0,
      "text": "5.2. Interface between Stand-Alone Authenticator State Machine and Methods",
      "ja": "5.2。スタンドアロン認証ステートマシンとメソッドの間のインタフェース"
    },
    {
      "indent": 3,
      "text": "IN: eapRespData, methodState",
      "ja": "以下の場合：eapRespData、methodState"
    },
    {
      "indent": 3,
      "text": "OUT: ignore, eapReqData",
      "ja": "OUT：、eapReqDataを無視"
    },
    {
      "indent": 3,
      "text": "IN/OUT: currentId, (method-specific state), (policy)",
      "ja": "IN / OUT：currentId、（メソッド固有の状態）、（ポリシー）"
    },
    {
      "indent": 3,
      "text": "The following describes the interaction between the state machine and EAP methods.",
      "ja": "以下は、ステートマシンとEAPメソッド間の相互作用を記述する。"
    },
    {
      "indent": 3,
      "text": "m.init (in: -, out: -)",
      "ja": "m.init（中： - 、アウト： - ）"
    },
    {
      "indent": 3,
      "text": "When the method is first started, it must initialize its own method-specific state, possibly using some information from Policy (e.g., identity).",
      "ja": "この方法は、最初に起動すると、それはおそらく政策（例えば、同一性）からいくつかの情報を使用して、独自のメソッド固有の状態を初期化する必要があります。"
    },
    {
      "indent": 3,
      "text": "m.buildReq (in: integer, out: EAP packet)",
      "ja": "（：整数、アウト：EAPパケット内の）m.buildReq"
    },
    {
      "indent": 3,
      "text": "Next, the method creates a new EAP Request packet, with the given identifier value, and updates its method-specific state accordingly.",
      "ja": "次に、この方法は、与えられた識別子値と、新しいEAP要求パケットを作成し、それに応じてそのメソッド固有の状態を更新します。"
    },
    {
      "indent": 3,
      "text": "m.getTimeout (in: -, out: integer or NONE)",
      "ja": "m.getTimeout（中： - 、アウト：整数またはNONE）"
    },
    {
      "indent": 3,
      "text": "The method can also provide a hint for retransmission timeout with m.getTimeout.",
      "ja": "この方法はまた、m.getTimeoutで再送信タイムアウトのためのヒントを提供することができます。"
    },
    {
      "indent": 3,
      "text": "m.check (in: EAP packet, out: boolean)",
      "ja": "m.check（中：EAPパケット、アウト：ブール）"
    },
    {
      "indent": 3,
      "text": "When a new EAP Response is received, the method must first decide whether to process the packet or to discard it silently. If the packet looks like it was not sent by the legitimate peer (e.g., if it has an invalid Message Integrity Check (MIC), which should never occur), the method can indicate this by returning FALSE. In this case, the method should not modify its own method-specific state.",
      "ja": "新しいEAPレスポンスを受信した場合、この方法は、最初のパケットを処理するか、黙ってそれを破棄するかどうかを決定する必要があります。それは正当なピアによって送信されなかったように、パケットが見えれば（それが起こることはありません、無効なメッセージ完全性チェック（MIC）を、持っている場合例えば、）、メソッドはfalseを返すことによって、これを示すことができます。この場合、この方法は、独自のメソッド固有の状態を変更するべきではありません。"
    },
    {
      "indent": 3,
      "text": "m.process (in: EAP packet, out: -)",
      "ja": "m.process（中：EAPパケット、アウト： - ）"
    },
    {
      "indent": 3,
      "text": "m.isDone (in: -, out: boolean)",
      "ja": "m.isDone（中： - 、アウト：ブール）"
    },
    {
      "indent": 3,
      "text": "m.getKey (in: -, out: EAP key or NONE)",
      "ja": "m.getKey（中： - 、アウト：EAPキーまたはNONE）"
    },
    {
      "indent": 3,
      "text": "Next, the method processes the EAP Response and updates its own method-specific state. Now the options are to continue the conversation (send another request) or to end this method.",
      "ja": "次に、本方法はEAP応答を処理し、独自の方法、特定の状態を更新します。今のオプションは会話を続けるために（別の要求を送信）、またはこのメソッドを終了します。"
    },
    {
      "indent": 3,
      "text": "If the method wants to end the conversation, it",
      "ja": "この方法は、会話を終了したい場合は、"
    },
    {
      "indent": 3,
      "text": "o Tells Policy about the outcome of the method and possibly other information.",
      "ja": "oは方法の結果およびおそらく他の情報についての方針を指示します。"
    },
    {
      "indent": 3,
      "text": "o If the method has derived keying material it wants to export, returns it from m.getKey().",
      "ja": "この方法は、キーイング材料を得た場合、Oそれはエクスポートしたい、）（m.getKeyからそれを返します。"
    },
    {
      "indent": 3,
      "text": "o Indicates that the method wants to end by returning TRUE from m.isDone().",
      "ja": "oは）メソッドはm.isDone（からTRUEを返すことによって終了したいことを示します。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the method continues by sending another request, as described earlier.",
      "ja": "そうでなければ、この方法は、前述したように、別の要求を送信することによって継続します。"
    },
    {
      "indent": 0,
      "text": "5.3. Stand-Alone Authenticator State Machine Local Variables",
      "section_title": true,
      "ja": "5.3。スタンドアロン認証ステートマシンローカル変数を"
    },
    {
      "indent": 0,
      "text": "5.3.1. Long-Term (Maintained between Packets)",
      "section_title": true,
      "ja": "5.3.1。 （パケット間維持される）長期"
    },
    {
      "indent": 3,
      "text": "currentMethod (EAP type)",
      "ja": "currentMethod（EAPタイプ）"
    },
    {
      "indent": 6,
      "text": "EAP type, IDENTITY, or NOTIFICATION.",
      "ja": "EAPタイプ、IDENTITY、または通知。"
    },
    {
      "indent": 3,
      "text": "currentId (integer)",
      "ja": "currentId（整数）"
    },
    {
      "indent": 6,
      "text": "0-255 or NONE. Usually updated in PROPOSE_METHOD state. Indicates the identifier value of the currently outstanding EAP request.",
      "ja": "0-255またはNONE。通常PROPOSE_METHODの状態に更新しました。現在、未解決のEAP要求の識別子の値を示します。"
    },
    {
      "indent": 3,
      "text": "methodState (enumeration)",
      "ja": "methodState（列挙）"
    },
    {
      "indent": 6,
      "text": "As described above.",
      "ja": "上記のように。"
    },
    {
      "indent": 3,
      "text": "retransCount (integer)",
      "ja": "retransCount（整数）"
    },
    {
      "indent": 6,
      "text": "Reset in SEND_REQUEST state and updated in RETRANSMIT state. Current number of retransmissions.",
      "ja": "SEND_REQUEST状態にリセットし、再送信状態に更新しました。再送信の現在の数。"
    },
    {
      "indent": 3,
      "text": "lastReqData (EAP packet)",
      "ja": "lastReqData（EAPパケット）"
    },
    {
      "indent": 6,
      "text": "Set in SEND_REQUEST state. EAP packet containing the last sent request.",
      "ja": "SEND_REQUEST状態に設定してください。最後に送信された要求を含むEAPパケット。"
    },
    {
      "indent": 3,
      "text": "methodTimeout (integer)",
      "ja": "methodTimeout（整数）"
    },
    {
      "indent": 6,
      "text": "Method-provided hint for suitable retransmission timeout, or NONE.",
      "ja": "適切な再送タイムアウト、またはNONEのための方法が提供ヒント。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Short-Term (Not Maintained between Packets)",
      "section_title": true,
      "ja": "5.3.2。短期（パケットの間で維持されません）"
    },
    {
      "indent": 3,
      "text": "rxResp (boolean)",
      "ja": "rxResp（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set in RECEIVED state. Indicates that the current received packet is an EAP response.",
      "ja": "受信した状態で設定してください。現在の受信パケットがEAP応答であることを示します。"
    },
    {
      "indent": 3,
      "text": "respId (integer)",
      "ja": "respId（整数）"
    },
    {
      "indent": 6,
      "text": "Set in RECEIVED state. The identifier from the current EAP response.",
      "ja": "受信した状態で設定してください。現在のEAP応答から識別子。"
    },
    {
      "indent": 3,
      "text": "respMethod (EAP type)",
      "ja": "respMethod（EAPタイプ）"
    },
    {
      "indent": 6,
      "text": "Set in RECEIVED state. The method type of the current EAP response.",
      "ja": "受信した状態で設定してください。現在のEAP応答のメソッドタイプ。"
    },
    {
      "indent": 3,
      "text": "ignore (boolean)",
      "ja": "（boolean）を無視します"
    },
    {
      "indent": 6,
      "text": "Set in METHOD state. Indicates whether the method has decided to drop the current packet.",
      "ja": "METHOD状態に設定してください。この方法は、現在のパケットをドロップすることを決定したかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "decision (enumeration)",
      "ja": "決定（列挙）"
    },
    {
      "indent": 6,
      "text": "Set in SELECT_ACTION state. Temporarily stores the policy decision to succeed, fail, or continue.",
      "ja": "SELECT_ACTION状態に設定してください。一時的に、成功失敗、または継続する方針の決定を格納します。"
    },
    {
      "indent": 0,
      "text": "5.4. EAP Stand-Alone Authenticator Procedures",
      "section_title": true,
      "ja": "5.4。 EAPスタンドアロン認証手続き"
    },
    {
      "indent": 3,
      "text": "NOTE: For method procedures, the method uses its internal state in addition to the information provided by the EAP layer. The only arguments that are explicitly shown as inputs to the procedures are those provided to the method by EAP. Those inputs provided by the method's internal state remain implicit.",
      "ja": "注：この方法の手順については、本方法はEAP層によって提供される情報に加えて、その内部状態を使用します。明示的手順への入力として示されている唯一の引数はEAPによる方法を提供するものです。メソッドの内部状態によって提供される入力は暗黙のまま。"
    },
    {
      "indent": 3,
      "text": "calculateTimeout()",
      "ja": "calculateTimeout（）"
    },
    {
      "indent": 6,
      "text": "Calculates the retransmission timeout, taking into account the retransmission count, round-trip time measurements, and method-specific timeout hint (see [RFC3748], Section 4.3). Returns an integer.",
      "ja": "アカウントに再送回数、ラウンドトリップ時間の測定、およびメソッド固有のタイムアウトヒントを取って、再送タイムアウトを計算します（[RFC3748]セクション4.3を参照してください）。整数を返します。"
    },
    {
      "indent": 3,
      "text": "parseEapResp()",
      "ja": "parseEapResp（）"
    },
    {
      "indent": 6,
      "text": "Determines the code, identifier value, and type of the current response. In the case of a parsing error (e.g., the length field is longer than the received packet), rxResp will be set to FALSE. The values of respId and respMethod may be undefined as a result. Returns a boolean, an integer, and an EAP type.",
      "ja": "コード、識別子の値、および電流応答のタイプを決定します。解析エラーの場合に（例えば、長さフィールドは長く、受信したパケットよりも）、rxRespはFALSEに設定されます。 respIdとrespMethodの値は、結果として不定することができます。ブール、整数、およびEAPの種類を返します。"
    },
    {
      "indent": 3,
      "text": "buildSuccess()",
      "ja": "buildSuccess（）"
    },
    {
      "indent": 6,
      "text": "Creates an EAP Success Packet. Returns an EAP packet.",
      "ja": "EAP成功パケットを作成します。 EAPパケットを返します。"
    },
    {
      "indent": 3,
      "text": "buildFailure()",
      "ja": "buildFailure（）"
    },
    {
      "indent": 6,
      "text": "Creates an EAP Failure Packet. Returns an EAP packet.",
      "ja": "EAP失敗パケットを作成します。 EAPパケットを返します。"
    },
    {
      "indent": 3,
      "text": "nextId()",
      "ja": "NEXTID（）"
    },
    {
      "indent": 6,
      "text": "Determines the next identifier value to use, based on the previous one. Returns an integer.",
      "ja": "前のいずれかに基づいて、使用する次の識別子の値を決定します。整数を返します。"
    },
    {
      "indent": 3,
      "text": "Policy.update()",
      "ja": "Policy.update（）"
    },
    {
      "indent": 6,
      "text": "Updates all variables related to internal policy state. The return value is undefined.",
      "ja": "内部ポリシーの状態に関連するすべての変数を更新します。戻り値は未定義です。"
    },
    {
      "indent": 3,
      "text": "Policy.getNextMethod()",
      "ja": "Policy.getNextメソッド（）"
    },
    {
      "indent": 6,
      "text": "Determines the method that should be used at this point in the conversation based on predefined policy. Policy.getNextMethod() MUST comply with [RFC3748] (Section 2.1), which forbids the use of sequences of authentication methods within an EAP conversation. Thus, if an authentication method has already been executed within an EAP dialog, Policy.getNextMethod() MUST NOT propose another authentication method within the same EAP dialog. Returns an EAP type.",
      "ja": "事前定義されたポリシーに基づいて会話のこの時点で使用されるべき方法を決定します。 Policy.getNextMethod（）EAP対話内の認証方法の配列の使用を禁止する[RFC3748]（セクション2.1）に従わなければなりません。このように、認証方法は、既にEAPダイアログ内で実行された場合、Policy.getNextMethod（）同じEAPダイアログ内の別の認証方式を提案してはなりません。 EAPタイプを返します。"
    },
    {
      "indent": 3,
      "text": "Policy.getDecision()",
      "ja": "Policy.getDecision（）"
    },
    {
      "indent": 6,
      "text": "Determines if the policy will allow SUCCESS, FAIL, or is yet to determine (CONTINUE). Returns a decision enumeration.",
      "ja": "ポリシーはSUCCESS、FAILを可能にするかどうかを決定し、又は（CONTINUE）を決定するためにまだあります。意思決定の列挙を返します。"
    },
    {
      "indent": 3,
      "text": "m.check()",
      "ja": "m.check（）"
    },
    {
      "indent": 6,
      "text": "Method-specific procedure to test for the validity of a message. Returns a boolean.",
      "ja": "メッセージの有効性をテストするための方法、具体的な手順。ブール値を返します。"
    },
    {
      "indent": 3,
      "text": "m.process()",
      "ja": "m.process（）"
    },
    {
      "indent": 6,
      "text": "Method procedure to parse and process a response for that method. The return value is undefined.",
      "ja": "その方法のための応答を解析し、処理する方法の手順。戻り値は未定義です。"
    },
    {
      "indent": 3,
      "text": "m.init()",
      "ja": "m.init（）"
    },
    {
      "indent": 6,
      "text": "Method procedure to initialize state just before use. The return value is undefined.",
      "ja": "メソッドの手順は、使用直前の状態を初期化します。戻り値は未定義です。"
    },
    {
      "indent": 3,
      "text": "m.reset()",
      "ja": "m.reset（）"
    },
    {
      "indent": 6,
      "text": "Method procedure to indicate that the method is ending in the middle of or before completion. The return value is undefined.",
      "ja": "この方法は、終了の前または途中で終了することを示すための方法手順。戻り値は未定義です。"
    },
    {
      "indent": 3,
      "text": "m.isDone()",
      "ja": "m.isDone（）"
    },
    {
      "indent": 6,
      "text": "Method procedure to check for method completion. Returns a boolean.",
      "ja": "メソッドの手順は、メソッドの完了を確認してください。ブール値を返します。"
    },
    {
      "indent": 3,
      "text": "m.getTimeout()",
      "ja": "m.getTimeout（）"
    },
    {
      "indent": 6,
      "text": "Method procedure to determine an appropriate timeout hint for that method. Returns an integer.",
      "ja": "その方法のために適切なタイムアウトヒントを決定する方法の手順。整数を返します。"
    },
    {
      "indent": 3,
      "text": "m.getKey()",
      "ja": "m.getKey（）"
    },
    {
      "indent": 6,
      "text": "Method procedure to obtain key material for use by EAP or lower layers. Returns an EAP key.",
      "ja": "EAPまたは下位層で使用するための鍵材料を得る方法の手順。 EAPキーを返します。"
    },
    {
      "indent": 3,
      "text": "m.buildReq()",
      "ja": "m.buildReq（）"
    },
    {
      "indent": 6,
      "text": "Method procedure to produce the next request. Returns an EAP packet.",
      "ja": "メソッドの手順は、次の要求を生成します。 EAPパケットを返します。"
    },
    {
      "indent": 0,
      "text": "5.5. EAP Stand-Alone Authenticator States",
      "section_title": true,
      "ja": "5.5。 EAPは、スタンドアロン認証状態"
    },
    {
      "indent": 3,
      "text": "DISABLED",
      "ja": "DISABLED"
    },
    {
      "indent": 6,
      "text": "The authenticator is disabled until the port is enabled by the lower layer.",
      "ja": "ポートが下位レイヤで有効にされるまで、オーセンティケータは無効になっています。"
    },
    {
      "indent": 3,
      "text": "INITIALIZE",
      "ja": "INITIALIZE"
    },
    {
      "indent": 6,
      "text": "Initializes variables when the state machine is activated.",
      "ja": "ステートマシンが起動されると、変数を初期化します。"
    },
    {
      "indent": 3,
      "text": "IDLE",
      "ja": "IDLE"
    },
    {
      "indent": 6,
      "text": "The state machine spends most of its time here, waiting for something to happen.",
      "ja": "ステートマシンは、何かが起こるのを待って、ここではそのほとんどの時間を費やしています。"
    },
    {
      "indent": 3,
      "text": "RECEIVED",
      "ja": "RECEIVED"
    },
    {
      "indent": 6,
      "text": "This state is entered when an EAP packet is received. The packet header is parsed here.",
      "ja": "EAPパケットを受信したとき、この状態が入力されます。パケットヘッダはここで解析されます。"
    },
    {
      "indent": 3,
      "text": "INTEGRITY_CHECK",
      "ja": "INTEGRITY_CHECK"
    },
    {
      "indent": 6,
      "text": "A method state in which the integrity of the incoming packet from the peer is verified by the method.",
      "ja": "ピアからの着信パケットの完全性が方法によって検証された方法状態。"
    },
    {
      "indent": 3,
      "text": "METHOD_RESPONSE",
      "ja": "METHOD_RESPONSE"
    },
    {
      "indent": 6,
      "text": "A method state in which the incoming packet is processed.",
      "ja": "着信パケットが処理される方法状態。"
    },
    {
      "indent": 3,
      "text": "METHOD_REQUEST",
      "ja": "METHOD_REQUEST"
    },
    {
      "indent": 6,
      "text": "A method state in which a new request is formulated if necessary.",
      "ja": "必要に応じて新たな要求を配合する方法状態。"
    },
    {
      "indent": 3,
      "text": "PROPOSE_METHOD",
      "ja": "PROPOSE_METHOD"
    },
    {
      "indent": 6,
      "text": "A state in which the authenticator decides which method to try next in the authentication.",
      "ja": "オーセンティケータは、認証に次試すためにどの方法を決定している状態。"
    },
    {
      "indent": 3,
      "text": "SELECT_ACTION",
      "ja": "SELECT_ACTION"
    },
    {
      "indent": 6,
      "text": "Between methods, the state machine re-evaluates whether its policy is satisfied and succeeds, fails, or remains undecided.",
      "ja": "方法の間に、ステートマシンは、そのポリシーが満たされているかどうかを再評価し、成功、失敗、または未定のまま。"
    },
    {
      "indent": 3,
      "text": "SEND_REQUEST",
      "ja": "SEND_REQUEST"
    },
    {
      "indent": 6,
      "text": "This state signals the lower layer that a request packet is ready to be sent.",
      "ja": "この状態は、要求パケットを送信する準備ができている下層に信号を送ります。"
    },
    {
      "indent": 3,
      "text": "DISCARD",
      "ja": "DISCARD"
    },
    {
      "indent": 6,
      "text": "This state signals the lower layer that the response was discarded, and no new request packet will be sent at this time.",
      "ja": "この状態は、応答が破棄されたことを下位層に信号を送り、そして新たな要求パケットは、この時点で送信されません。"
    },
    {
      "indent": 3,
      "text": "NAK",
      "ja": "NAK"
    },
    {
      "indent": 6,
      "text": "This state processes Nak responses from the peer.",
      "ja": "この状態は、ピアからのNAK応答を処理します。"
    },
    {
      "indent": 3,
      "text": "RETRANSMIT",
      "ja": "RETRANSMIT"
    },
    {
      "indent": 6,
      "text": "Retransmits the previous request packet.",
      "ja": "前の要求パケットを再送します。"
    },
    {
      "indent": 3,
      "text": "SUCCESS",
      "ja": "成功"
    },
    {
      "indent": 6,
      "text": "A final state indicating success.",
      "ja": "成功を示す最終状態。"
    },
    {
      "indent": 3,
      "text": "FAILURE",
      "ja": "FAILURE"
    },
    {
      "indent": 6,
      "text": "A final state indicating failure.",
      "ja": "失敗したことを示す最終状態。"
    },
    {
      "indent": 3,
      "text": "TIMEOUT_FAILURE",
      "ja": "TIMEOUT_FAILURE"
    },
    {
      "indent": 6,
      "text": "A final state indicating failure because no response has been received. Because no response was received, no new message (including failure) should be sent to the peer. Note that this is different from the FAILURE state, in which a message indicating failure is sent to the peer.",
      "ja": "応答が受信されなかったため失敗したことを示す最終状態。応答が受信されなかったため、（失敗を含む）は、新しいメッセージがピアに送信されるべきではありません。このメッセージを示す障害がピアに送信された故障状態とは異なることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "6. EAP Backend Authenticator",
      "section_title": true,
      "ja": "6. EAPバックエンド認証"
    },
    {
      "indent": 3,
      "text": "When operating in pass-through mode, there are conceptually two parts to the authenticator: the part that passes packets through, and the backend that actually implements the EAP method. The following diagram shows a state machine for the backend part of this model when using a AAA server. Note that this diagram is identical to Figure 4 except that no retransmit is included in the IDLE state because with RADIUS, retransmit is handled by the NAS. Also, a PICK_UP_METHOD state and variable in INITIALIZE state are added to allow the Method to \"pick up\" a method started in a NAS. Included is an explanation of the primitives and procedures referenced in the diagram, many of which are the same as above. Note that the \"lower layer\" in this case is some AAA protocol (e.g., RADIUS).",
      "ja": "パケットの通過部分、および実際にEAPメソッドを実装するバックエンド：パススルーモードで動作する場合、オーセンティケータには2つの部分は、概念的にあります。次の図は、AAAサーバを使用して、このモデルのバックエンド部分の状態マシンを示します。この図は、RADIUSと、再送信は、NASによって処理されているので何ら再送がIDLE状態に含まれていないことを除いて図4と同一であることに留意されたいです。また、INITIALIZE状態でPICK_UP_METHOD状態と変数は、メソッドは、メソッドがNASに始まった「拾う」できるようにするために追加されます。上記と同じである多くは図中で参照プリミティブおよび手順の説明が含まれます。この場合の「下層」は、いくつかのAAAプロトコル（例えば、RADIUS）であることに留意されたいです。"
    },
    {
      "indent": 12,
      "text": "   (see the .pdf version for missing diagram or\nrefer to Appendix A.3 if reading the .txt version)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Figure 5: EAP Backend Authenticator State Machine",
      "ja": "図5：EAPバックエンド認証ステートマシン"
    },
    {
      "indent": 0,
      "text": "6.1. Interface between Backend Authenticator State Machine and Lower Layer",
      "ja": "6.1。バックエンド認証ステートマシンと下層との間のインターフェイス"
    },
    {
      "indent": 3,
      "text": "The lower layer presents messages to the EAP backend authenticator state machine by storing the packet in aaaEapRespData and setting the aaaEapResp signal to TRUE.",
      "ja": "下層aaaEapRespDataにパケットを格納し、TRUEにaaaEapResp信号を設定することにより、EAPバックエンド認証ステートマシンにメッセージを提示します。"
    },
    {
      "indent": 3,
      "text": "When the EAP backend authenticator state machine has finished processing the message, it sets one of the signals aaaEapReq, aaaEapNoReq, aaaSuccess, and aaaFail. If it sets eapReq, eapSuccess, or eapFail, the corresponding request (or success/failure) packet is stored in aaaEapReqData. The lower layer is responsible for actually transmitting this message.",
      "ja": "EAPバックエンド認証ステートマシンがメッセージの処理を終了したとき、それは、信号aaaEapReq、aaaEapNoReq、aaaSuccess、及びaaaFailのいずれかを設定します。それはeapReq、eapSuccess、又はeapFailを設定した場合、対応する要求（または成功/失敗）パケットがaaaEapReqDataに格納されています。下の層は、実際にこのメッセージを送信するための責任があります。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Variables (AAA Interface to Backend Authenticator)",
      "section_title": true,
      "ja": "6.1.1。変数（バックエンド認証にAAAインターフェース）"
    },
    {
      "indent": 3,
      "text": "aaaEapResp (boolean)",
      "ja": "aaaEapResp（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in lower layer, FALSE in authenticator state machine. Usually indicates that an EAP response, stored in aaaEapRespData, is available for processing by the AAA server. If aaaEapRespData is set to NONE, it indicates that the AAA server should send the initial EAP request.",
      "ja": "認証マシンでFALSE、下層にTRUEに設定します。通常aaaEapRespDataに格納されたEAP応答は、AAAサーバによる処理のために利用可能であることを示しています。 aaaEapRespDataがNONEに設定されている場合は、AAAサーバが初期のEAP要求を送信する必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "aaaEapRespData (EAP packet)",
      "ja": "aaaEapRespData（EAPパケット）"
    },
    {
      "indent": 6,
      "text": "Set in lower layer when eapResp is set to TRUE. The EAP packet to be processed, or NONE.",
      "ja": "eapRespがTRUEに設定されている下層に設定してください。 EAPの処理されるべきパケット、またはNONE。"
    },
    {
      "indent": 3,
      "text": "backendEnabled (boolean)",
      "ja": "backendEnabled（ブール値）"
    },
    {
      "indent": 6,
      "text": "Indicates that there is a valid link to use for the communication. If at any point the port is not available, backendEnabled is set to FALSE, and the state machine transitions to DISABLED.",
      "ja": "通信に使用するための有効なリンクがあることを示します。任意の時点でのポートが使用できない場合は、backendEnabledはDISABLEDにFALSE、およびステート・マシンの遷移に設定されています。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Variables (Backend Authenticator to AAA Interface)",
      "section_title": true,
      "ja": "6.1.2。変数（AAAインタフェースにバックエンド認証）"
    },
    {
      "indent": 3,
      "text": "aaaEapReq (boolean)",
      "ja": "aaaEapReq（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in authenticator state machine, FALSE in lower layer. Indicates that a new EAP request is ready to be sent.",
      "ja": "下層にFALSE、認証マシンでTRUEに設定します。新しいEAP要求を送信する準備ができていることを示します。"
    },
    {
      "indent": 3,
      "text": "aaaEapNoReq (boolean)",
      "ja": "aaaEapNoReq（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in authenticator state machine, FALSE in lower layer. Indicates that the most recent response has been processed, but there is no new request to send.",
      "ja": "下層にFALSE、認証マシンでTRUEに設定します。最新の応答が処理されたことを示しますが、送信するための新たな要求がありません。"
    },
    {
      "indent": 3,
      "text": "aaaSuccess (boolean)",
      "ja": "aaaSuccess（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in authenticator state machine, FALSE in lower layer. Indicates that the state machine has reached the SUCCESS state.",
      "ja": "下層にFALSE、認証マシンでTRUEに設定します。ステートマシンがSUCCESS状態に達したことを示します。"
    },
    {
      "indent": 3,
      "text": "aaaFail (boolean)",
      "ja": "aaaFail（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in authenticator state machine, FALSE in lower layer. Indicates that the state machine has reached the FAILURE state.",
      "ja": "下層にFALSE、認証マシンでTRUEに設定します。ステートマシンがFAILURE状態に達したことを示します。"
    },
    {
      "indent": 3,
      "text": "aaaEapReqData (EAP packet)",
      "ja": "aaaEapReqData（EAPパケット）"
    },
    {
      "indent": 6,
      "text": "Set in authenticator state machine when aaaEapReq, aaaSuccess, or aaaFail is set to TRUE. The actual EAP request to be sent (or success/failure).",
      "ja": "aaaEapReq、aaaSuccess、またはaaaFailがTRUEに設定されている場合、認証マシンに設定してください。実際に送信されるEAP要求（または成功/失敗）。"
    },
    {
      "indent": 3,
      "text": "aaaEapKeyData (EAP key)",
      "ja": "aaaEapKeyData（EAPキー）"
    },
    {
      "indent": 6,
      "text": "Set in authenticator state machine when keying material becomes available. Set during the METHOD_RESPONSE state. Note that this document does not define the structure of the type \"EAP key\". We expect that it will be defined in [Keying].",
      "ja": "鍵材料が使用可能になったときに認証マシンに設定してください。 METHOD_RESPONSE状態の時に設定してください。この文書は、タイプ「EAPキー」の構造を定義していないことに注意してください。私たちは、それが[イング]で定義されることを期待しています。"
    },
    {
      "indent": 3,
      "text": "aaaEapKeyAvailable (boolean)",
      "ja": "aaaEapKeyAvailable（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in the SUCCESS state if keying material is available. The actual key is stored in aaaEapKeyData.",
      "ja": "材料をキーイングが利用可能な場合SUCCESS状態でTRUEに設定します。実際のキーはaaaEapKeyDataに格納されます。"
    },
    {
      "indent": 3,
      "text": "aaaMethodTimeout (integer)",
      "ja": "aaaMethodTimeout（整数）"
    },
    {
      "indent": 6,
      "text": "Method-provided hint for suitable retransmission timeout, or NONE. (Note that this hint is for the EAP retransmissions done by the pass-through authenticator, not for retransmissions of AAA packets.)",
      "ja": "適切な再送タイムアウト、またはNONEのための方法が提供ヒント。 （このヒントはないAAAパケットの再送信のために、パススルー認証によって行わEAP再送信のためのものであることに注意してください。）"
    },
    {
      "indent": 0,
      "text": "6.2. Interface between Backend Authenticator State Machine and Methods",
      "ja": "6.2。バックエンド認証ステートマシンとメソッドの間のインタフェース"
    },
    {
      "indent": 3,
      "text": "The backend method interface is almost the same as in stand-alone authenticator described in Section 5.2. The only difference is that some methods on the backend may support \"picking up\" a conversation started by the pass-through. That is, the EAP Request packet was sent by the pass-through, but the backend must process the corresponding EAP Response. Usually only the Identity method supports this, but others are possible.",
      "ja": "バックエンド・メソッド・インターフェースは、ほぼ5.2節に記載スタンドアロンオーセンティケータと同じです。唯一の違いは、バックエンドにいくつかの方法がパススルーによって開始された会話を「拾う」サポートすることが可能ということです。これは、EAP Requestパケットをパススルーによって送信されましたが、バックエンドは、対応するEAP応答を処理する必要があります。通常、唯一のアイデンティティメソッドはこれをサポートしていますが、他のものが可能です。"
    },
    {
      "indent": 3,
      "text": "When \"picking up\" a conversation, m.initPickUp() is called instead of m.init(). Next, m.process() must examine eapRespData and update its own method-specific state to match what it would have been if it had actually sent the corresponding request. (Obviously, this only works for methods that can determine what the initial request contained; Identity and EAP-TLS are good examples.)",
      "ja": "会話を「拾う」場合には、m.initPickUp（）の代わりにm.initのと呼ばれています（）。次に、m.process（）はeapRespDataを調べて、それが実際に対応する要求を送信した場合、それはあったであろうものを一致させるために、独自のメソッド固有の状態を更新する必要があります。 （もちろん、最初の要求が含まれているかを判断することができます方法については、この唯一の作品、アイデンティティおよびEAP-TLSが良い例です。）"
    },
    {
      "indent": 3,
      "text": "After this, the processing continues as described in Section 5.2.",
      "ja": "セクション5.2で説明したように、この後、処理は継続します。"
    },
    {
      "indent": 0,
      "text": "6.3. Backend Authenticator State Machine Local Variables",
      "section_title": true,
      "ja": "6.3。バックエンド認証ステートマシンローカル変数"
    },
    {
      "indent": 3,
      "text": "For definitions of the variables used in the Backend Authenticator, see Section 5.3.",
      "ja": "バックエンド認証で使用される変数の定義については、5.3節を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.4. EAP Backend Authenticator Procedures",
      "section_title": true,
      "ja": "6.4。 EAPバックエンド認証手続き"
    },
    {
      "indent": 3,
      "text": "Most of the procedures of the backend authenticator have already been defined in Section 5.4. This section contains definitions for those not existent in the stand-alone version, as well as those that are defined differently.",
      "ja": "バックエンド認証の手順のほとんどは、すでに5.4節で定義されています。このセクションでは、スタンドアロンバージョンと同様に、異なるように定義されているものには存在しないそれらのための定義が含まれています。"
    },
    {
      "indent": 3,
      "text": "NOTE: For method procedures, the method uses its internal state in addition to the information provided by the EAP layer. The only arguments that are explicitly shown as inputs to the procedures are those provided to the method by EAP. Those inputs provided by the method's internal state remain implicit.",
      "ja": "注：この方法の手順については、本方法はEAP層によって提供される情報に加えて、その内部状態を使用します。明示的手順への入力として示されている唯一の引数はEAPによる方法を提供するものです。メソッドの内部状態によって提供される入力は暗黙のまま。"
    },
    {
      "indent": 3,
      "text": "Policy.doPickUp()",
      "ja": "Policy.doPickUp（）"
    },
    {
      "indent": 6,
      "text": "Notifies the policy that an already-chosen method is being picked up and will be completed. Returns a boolean.",
      "ja": "既に選択した方法がピックアップされており、完成されたポリシーを通知します。ブール値を返します。"
    },
    {
      "indent": 3,
      "text": "m.initPickUp()",
      "ja": "m.initPickUp（）"
    },
    {
      "indent": 6,
      "text": "Method procedure to initialize state when continuing from an already-started method. The return value is undefined.",
      "ja": "既に始まっ方法から継続するときの状態を初期化する方法手順。戻り値は未定義です。"
    },
    {
      "indent": 0,
      "text": "6.5. EAP Backend Authenticator States",
      "section_title": true,
      "ja": "6.5。 EAPバックエンド認証状態"
    },
    {
      "indent": 3,
      "text": "Most of the states of the backend authenticator have already been defined in Section 5.5. This section contains definitions for those not existent in the stand-alone version, as well as those that are defined differently.",
      "ja": "バックエンドのオーセンティケータの状態のほとんどは、すでに5.5節で定義されています。このセクションでは、スタンドアロンバージョンと同様に、異なるように定義されているものには存在しないそれらのための定義が含まれています。"
    },
    {
      "indent": 3,
      "text": "PICK_UP_METHOD",
      "ja": "PICK_UP_METHOD"
    },
    {
      "indent": 6,
      "text": "Sets an initial state for a method that is being continued and that was started elsewhere.",
      "ja": "継続していると、それは他の場所で開始された方法のための初期状態を設定します。"
    },
    {
      "indent": 0,
      "text": "7. EAP Full Authenticator",
      "section_title": true,
      "ja": "7. EAP完全認証"
    },
    {
      "indent": 3,
      "text": "The following two diagrams show the state machine for a complete authenticator. The first diagram is identical to the stand-alone state machine, shown in Figure 4, with the exception that the SELECT_ACTION state has an added transition to PASSTHROUGH. The second diagram also keeps most of the logic, except the four method states, and it shows how the state machine works once it goes to pass-through mode.",
      "ja": "以下の2つの図は、完全な認証サーバのステート・マシンを示しています。最初の図は、SELECT_ACTION状態がパススルーに添加遷移を有することを除いて、図4に示されているスタンドアローン状態マシンと同一です。 2番目の図は、4つのメソッドの状態を除いて、ロジックのほとんどを保持し、それがパススルーするモードになったら、ステートマシンがどのように動作するかを示しています。"
    },
    {
      "indent": 3,
      "text": "The first diagram is largely a reproduction of that found above, with the added hooks for a transition to PASSTHROUGH mode.",
      "ja": "最初の図は、主にPASSTHROUGHモードへの移行のための追加フックと上記見られるの再生です。"
    },
    {
      "indent": 12,
      "text": "   (see the .pdf version for missing diagram or\nrefer to Appendix A.4 if reading the .txt version)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 6: EAP Full Authenticator State Machine (Part 1)",
      "ja": "図6：EAP完全認証ステートマシン（その1）"
    },
    {
      "indent": 3,
      "text": "The second diagram describes the functionality necessary for an authenticator operating in pass-through mode. This section of the diagram is the counterpart of the backend diagram above.",
      "ja": "2番目の図は、パススルーモードで動作しているオーセンティケータのために必要な機能を説明しています。図のこのセクションでは、上記のバックエンド・ダイヤグラムの対応物です。"
    },
    {
      "indent": 12,
      "text": "   (see the .pdf version for missing diagram or\nrefer to Appendix A.4 if reading the .txt version)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 7: EAP Full Authenticator State Machine (Part 2)",
      "ja": "図7：EAP完全認証ステートマシン（その2）"
    },
    {
      "indent": 0,
      "text": "7.1. Interface between Full Authenticator State Machine and Lower Layers",
      "ja": "7.1。完全な認証ステートマシンと下位層の間のインタフェース"
    },
    {
      "indent": 3,
      "text": "The full authenticator is unique in that it interfaces to multiple lower layers in order to support pass-through mode. The interface to the primary EAP transport layer is the same as described in Section 5. The following describes the interface to the second lower layer, which represents an interface to AAA. Note that there is not necessarily a direct interaction between the EAP layer and the AAA layer, as in the case of [1X-2004].",
      "ja": "フルオーセンティケータは、パススルーモードをサポートするために、複数の下位層へのそのインタフェースに固有です。以下はAAAへのインタフェースを表す第二の下層へのインタフェースを記述するセクション5に記載されているように、一次EAPトランスポート層へのインタフェースは同じです。 [1X-2004]の場合のように、必ずしもEAP層とAAA層との間の直接的な相互作用がないことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Variables (AAA Interface to Full Authenticator)",
      "section_title": true,
      "ja": "7.1.1。変数（フルオーセンティケータにAAAインターフェース）"
    },
    {
      "indent": 3,
      "text": "aaaEapReq (boolean)",
      "ja": "aaaEapReq（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in lower layer, FALSE in authenticator state machine. Indicates that a new EAP request is available from the AAA server.",
      "ja": "認証マシンでFALSE、下層にTRUEに設定します。新しいEAP要求がAAAサーバから利用可能であることを示します。"
    },
    {
      "indent": 3,
      "text": "aaaEapNoReq (boolean)",
      "ja": "aaaEapNoReq（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in lower layer, FALSE in authenticator state machine. Indicates that the most recent response has been processed, but that there is no new request to send.",
      "ja": "認証マシンでFALSE、下層にTRUEに設定します。最新の応答が処理されたことはなく、送信するための新たな要求がないことを示します。"
    },
    {
      "indent": 3,
      "text": "aaaSuccess (boolean)",
      "ja": "aaaSuccess（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in lower layer. Indicates that the AAA backend authenticator has reached the SUCCESS state.",
      "ja": "下層にTRUEに設定します。 AAAのバックエンドのオーセンティケータがSUCCESS状態に達したことを示します。"
    },
    {
      "indent": 3,
      "text": "aaaFail (boolean)",
      "ja": "aaaFail（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in lower layer. Indicates that the AAA backend authenticator has reached the FAILURE state.",
      "ja": "下層にTRUEに設定します。 AAAのバックエンドのオーセンティケータがFAILURE状態に達したことを示します。"
    },
    {
      "indent": 3,
      "text": "aaaEapReqData (EAP packet)",
      "ja": "aaaEapReqData（EAPパケット）"
    },
    {
      "indent": 6,
      "text": "Set in the lower layer when aaaEapReq, aaaSuccess, or aaaFail is set to TRUE. The actual EAP request to be sent (or success/ failure).",
      "ja": "aaaEapReq、aaaSuccess、又はaaaFailがTRUEに設定されている下層に設定。実際に送信されるEAP要求（または成功/失敗）。"
    },
    {
      "indent": 3,
      "text": "aaaEapKeyData (EAP key)",
      "ja": "aaaEapKeyData（EAPキー）"
    },
    {
      "indent": 6,
      "text": "Set in lower layer when keying material becomes available from the AAA server. Note that this document does not define the structure of the type \"EAP key\". We expect that it will be defined in [Keying].",
      "ja": "鍵材料は、AAAサーバから利用可能になったときに下層に設定してください。この文書は、タイプ「EAPキー」の構造を定義していないことに注意してください。私たちは、それが[イング]で定義されることを期待しています。"
    },
    {
      "indent": 3,
      "text": "aaaEapKeyAvailable (boolean)",
      "ja": "aaaEapKeyAvailable（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in the lower layer if keying material is available. The actual key is stored in aaaEapKeyData.",
      "ja": "鍵材料が使用可能である場合、下層にTRUEに設定します。実際のキーはaaaEapKeyDataに格納されます。"
    },
    {
      "indent": 3,
      "text": "aaaMethodTimeout (integer)",
      "ja": "aaaMethodTimeout（整数）"
    },
    {
      "indent": 6,
      "text": "Method-provided hint for suitable retransmission timeout, or NONE. (Note that this hint is for the EAP retransmissions done by the pass-through authenticator, not for retransmissions of AAA packets.)",
      "ja": "適切な再送タイムアウト、またはNONEのための方法が提供ヒント。 （このヒントはないAAAパケットの再送信のために、パススルー認証によって行わEAP再送信のためのものであることに注意してください。）"
    },
    {
      "indent": 0,
      "text": "7.1.2. Variables (full authenticator to AAA interface)",
      "section_title": true,
      "ja": "7.1.2。変数（AAAインタフェースへの完全なオーセンティケータ）"
    },
    {
      "indent": 3,
      "text": "aaaEapResp (boolean)",
      "ja": "aaaEapResp（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set to TRUE in authenticator state machine, FALSE in the lower layer. Indicates that an EAP response is available for processing by the AAA server.",
      "ja": "認証マシンでtrueに設定、下層にFALSE。 EAP応答は、AAAサーバによって処理のために利用可能であることを示します。"
    },
    {
      "indent": 3,
      "text": "aaaEapRespData (EAP packet)",
      "ja": "aaaEapRespData（EAPパケット）"
    },
    {
      "indent": 6,
      "text": "Set in authenticator state machine when eapResp is set to TRUE. The EAP packet to be processed.",
      "ja": "eapRespがTRUEに設定されている場合、認証マシンに設定してください。 EAPパケットを処理します。"
    },
    {
      "indent": 3,
      "text": "aaaIdentity (EAP packet)",
      "ja": "aaaIdentity（EAPパケット）"
    },
    {
      "indent": 6,
      "text": "Set in authenticator state machine when an IDENTITY response is received. Makes that identity available to AAA lower layer.",
      "ja": "IDENTITYレスポンスを受信したときに認証マシンに設定してください。 AAAにそのIDを使用できるようになり、下位層。"
    },
    {
      "indent": 3,
      "text": "aaaTimeout (boolean)",
      "ja": "aaaTimeout（ブール値）"
    },
    {
      "indent": 6,
      "text": "Set in AAA_IDLE if, after a configurable amount of time, there is no response from the AAA layer. The AAA layer in the NAS is itself alive and OK, but for some reason it has not received a valid Access-Accept/Reject indication from the backend.",
      "ja": "AAA_IDLEに設定し、時間の設定可能な量の後、AAA層からの応答がない場合。 NASでAAA層は生きているとOKが、それは、有効なアクセス-受け入れ/バックエンドからの指示を拒否を受信して​​いない何らかの理由そのものです。"
    },
    {
      "indent": 0,
      "text": "7.1.3. Constants",
      "section_title": true,
      "ja": "7.1.3。定数"
    },
    {
      "indent": 3,
      "text": "Same as Section 5.",
      "ja": "第5節と同じ。"
    },
    {
      "indent": 0,
      "text": "7.2. Interface between Full Authenticator State Machine and Methods",
      "section_title": true,
      "ja": "7.2。完全な認証ステートマシンとメソッドの間のインタフェース"
    },
    {
      "indent": 3,
      "text": "Same as stand-alone authenticator (Section 5.2).",
      "ja": "スタンドアロン認証システム（5.2節）と同じ。"
    },
    {
      "indent": 0,
      "text": "7.3. Full Authenticator State Machine Local Variables",
      "section_title": true,
      "ja": "7.3。完全な認証ステートマシンローカル変数"
    },
    {
      "indent": 3,
      "text": "Many of the variables of the full authenticator have already been defined in Section 5. This section contains definitions for those not existent in the stand-alone version, as well as those that are defined differently.",
      "ja": "フルオーセンティケータの変数の多くは、すでにこのセクションでは、スタンドアロンバージョンと同様に、異なるように定義されているものには存在しない人のための定義が含まれている第5節で定義されています。"
    },
    {
      "indent": 0,
      "text": "7.3.1. Short-Term (Not Maintained between Packets)",
      "section_title": true,
      "ja": "7.3.1。短期（パケットの間で維持されません）"
    },
    {
      "indent": 3,
      "text": "decision (enumeration)",
      "ja": "決定（列挙）"
    },
    {
      "indent": 6,
      "text": "Set in SELECT_ACTION state. Temporarily stores the policy decision to succeed, fail, continue with a local method, or continue in pass-through mode.",
      "ja": "SELECT_ACTION状態に設定してください。一時的にローカルの方法を継続、またはパススルーモードで継続、失敗、成功するために政策決定を格納します。"
    },
    {
      "indent": 0,
      "text": "7.4. EAP Full Authenticator Procedures",
      "section_title": true,
      "ja": "7.4。 EAP完全認証手順"
    },
    {
      "indent": 3,
      "text": "All the procedures defined in Section 5 exist in the full version. In addition, the following procedures are defined.",
      "ja": "第5節で定義されたすべての手順は、フルバージョンに存在します。加えて、以下の手順が定義されています。"
    },
    {
      "indent": 3,
      "text": "getId()",
      "ja": "getId（）"
    },
    {
      "indent": 6,
      "text": "Determines the identifier value chosen by the AAA server for the current EAP request. The return value is an integer.",
      "ja": "現在のEAP要求のAAAサーバによって選択された識別子の値を決定します。戻り値は整数です。"
    },
    {
      "indent": 0,
      "text": "7.5. EAP Full Authenticator States",
      "section_title": true,
      "ja": "7.5。 EAP完全認証州"
    },
    {
      "indent": 3,
      "text": "All the states defined in Section 5 exist in the full version. In addition, the following states are defined.",
      "ja": "第5節で定義されているすべての状態は、フルバージョンに存在します。また、以下の状態が定義されています。"
    },
    {
      "indent": 3,
      "text": "INITIALIZE_PASSTHROUGH",
      "ja": "INITIALIZE PASSTHROUGH"
    },
    {
      "indent": 6,
      "text": "Initializes variables when the pass-through portion of the state machine is activated.",
      "ja": "ステートマシンの通過部分が活性化されるときに変数を初期化します。"
    },
    {
      "indent": 3,
      "text": "IDLE2",
      "ja": "IDLE2"
    },
    {
      "indent": 6,
      "text": "The state machine waits for a response from the primary lower layer, which transports EAP traffic from the peer.",
      "ja": "状態マシンは、ピアからのEAPトラフィックを搬送する一次下位層からの応答を待ちます。"
    },
    {
      "indent": 3,
      "text": "IDLE",
      "ja": "IDLE"
    },
    {
      "indent": 6,
      "text": "The state machine spends most of its time here, waiting for something to happen.",
      "ja": "ステートマシンは、何かが起こるのを待って、ここではそのほとんどの時間を費やしています。"
    },
    {
      "indent": 3,
      "text": "RECEIVED2",
      "ja": "RECEIVED2"
    },
    {
      "indent": 6,
      "text": "This state is entered when an EAP packet is received and the authenticator is in PASSTHROUGH mode. The packet header is parsed here.",
      "ja": "EAPパケットを受信したときに、この状態が入力され、オーセンティケータがパススルー・モードです。パケットヘッダはここで解析されます。"
    },
    {
      "indent": 3,
      "text": "AAA_REQUEST",
      "ja": "AAA_REQUEST"
    },
    {
      "indent": 6,
      "text": "The incoming EAP packet is parsed for sending to the AAA server.",
      "ja": "入って来るEAPパケットをAAAサーバに送信するために解析されます。"
    },
    {
      "indent": 3,
      "text": "AAA_IDLE",
      "ja": "AAA_IDLE"
    },
    {
      "indent": 6,
      "text": "Idle state that tells the AAA layer that it has a response and then waits for a new request, a no-request signal, or success/failure.",
      "ja": "それは応答を有しており、新しい要求、無要求信号、または成功/失敗を待つAAA層を伝えるアイドル状態。"
    },
    {
      "indent": 3,
      "text": "AAA_RESPONSE",
      "ja": "AAA_RESPONSE"
    },
    {
      "indent": 6,
      "text": "State in which the request from the AAA interface is processed into an EAP request.",
      "ja": "AAAインターフェイスからの要求がEAP要求に加工さ​​れている状態。"
    },
    {
      "indent": 3,
      "text": "SEND_REQUEST2",
      "ja": "SEND_REQUEST2"
    },
    {
      "indent": 6,
      "text": "This state signals the lower layer that a request packet is ready to be sent.",
      "ja": "この状態は、要求パケットを送信する準備ができている下層に信号を送ります。"
    },
    {
      "indent": 3,
      "text": "DISCARD2",
      "ja": "DISCARD2"
    },
    {
      "indent": 6,
      "text": "This state signals the lower layer that the response was discarded, and that no new request packet will be sent at this time.",
      "ja": "この状態は、応答が破棄された下層の信号、および新たな要求パケットは、この時点で送信されないことを。"
    },
    {
      "indent": 3,
      "text": "RETRANSMIT2",
      "ja": "RETRANSMIT2"
    },
    {
      "indent": 6,
      "text": "Retransmits the previous request packet.",
      "ja": "前の要求パケットを再送します。"
    },
    {
      "indent": 3,
      "text": "SUCCESS2",
      "ja": "SUCCESS2"
    },
    {
      "indent": 6,
      "text": "A final state indicating success.",
      "ja": "成功を示す最終状態。"
    },
    {
      "indent": 3,
      "text": "FAILURE2",
      "ja": "FAILURE2"
    },
    {
      "indent": 6,
      "text": "A final state indicating failure.",
      "ja": "失敗したことを示す最終状態。"
    },
    {
      "indent": 3,
      "text": "TIMEOUT_FAILURE2",
      "ja": "TIMEOUT_FAILURE2"
    },
    {
      "indent": 6,
      "text": "A final state indicating failure because no response has been received. Because no response was received, no new message (including failure) should be sent to the peer. Note that this is different from the FAILURE2 state, in which a message indicating failure is sent to the peer.",
      "ja": "応答が受信されなかったため失敗したことを示す最終状態。応答が受信されなかったため、（失敗を含む）は、新しいメッセージがピアに送信されるべきではありません。このメッセージを示す障害がピアに送信されたFAILURE2状態とは異なることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "8. Implementation Considerations",
      "section_title": true,
      "ja": "8.実装に関する考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Robustness",
      "section_title": true,
      "ja": "8.1。丈夫"
    },
    {
      "indent": 3,
      "text": "In order to deal with erroneous cases that are not directly related to the protocol behavior, implementations may need additional considerations to provide robustness against errors.",
      "ja": "プロトコルの動作に直接関連していない誤った場合に対処するためには、実装は、エラーに対するロバスト性を提供するために、追加の考慮事項が必要な場合があります。"
    },
    {
      "indent": 3,
      "text": "For example, an implementation of a state machine may spend a significant amount of time in a particular state performing the procedure defined for the state without returning a response. If such an implementation is made on a multithreading system, the procedure may be performed in a separate thread so that the implementation can perform appropriate action without blocking on the state for a long time (or forever if the procedure never completes due to, e.g., a non-responding user or a bug in an application callback function).",
      "ja": "例えば、ステートマシンの実装では、応答を返さない状態に対して定義された手順を実行する特定の状態でかなりの時間を費やすことができます。このような実装は、マルチスレッドシステム上で行われている場合は、手順は実施が長時間状態にブロックせずに適切なアクションを実行できるように、別のスレッドで実行（またはすることができる永遠の手順がのために完了しない場合、例えば、非応答ユーザーまたはアプリケーションのコールバック関数のバグ）。"
    },
    {
      "indent": 3,
      "text": "The following states are identified as the possible places of blocking:",
      "ja": "以下の状態は、ブロッキングの可能な場所として識別されます。"
    },
    {
      "indent": 3,
      "text": "o IDENTITY state in the peer state machine. It may take some time to process Identity request when a user input is needed for obtaining an identity from the user. The user may never input an identity. An implementation may define an additional state transition from IDENTITY state to FAILURE state so that authentication can fail if no identity is obtained from the user before ClientTimeout timer expires.",
      "ja": "ピア状態機械でOアイデンティティ状態。これは、ユーザ入力がユーザからIDを取得するために必要とされるアイデンティティ要求を処理するためにいくつかの時間がかかることがあります。ユーザーは決して入力のアイデンティティがあります。 ClientTimeoutタイマが満了する前に、何もアイデンティティがユーザから取得されていない場合、認証は失敗することができるような実装は、故障状態にIDENTITY状態から追加の状態遷移を定義することができます。"
    },
    {
      "indent": 3,
      "text": "o METHOD state in the peer state machine and in METHOD_RESPONSE state in the authenticator state machines. It may take some time to perform method-specific procedures in these states. An implementation may define an additional state transition from METHOD state and METHOD_RESPONSE state to FAILURE or TIMEOUT_FAILURE state so that authentication can fail if no method processing result is obtained from the method before methodTimeout timer expires.",
      "ja": "オーセンティケータステートマシンでのピア状態のマシンでとMETHOD_RESPONSE状態でO方式状態。これは、これらの状態でメソッド固有の手順を実行するには時間がかかる場合があります。 methodTimeoutタイマが満了する前に、何方法の処理結果は、方法から得られない場合、認証は失敗することができるので、実装が失敗またはTIMEOUT_FAILURE状態にMETHOD状態とMETHOD_RESPONSE状態から追加の状態遷移を定義することができます。"
    },
    {
      "indent": 0,
      "text": "8.2. Method/Method and Method/Lower-Layer Interfaces",
      "section_title": true,
      "ja": "8.2。メソッド/メソッドとメソッド/下位層インターフェイス"
    },
    {
      "indent": 3,
      "text": "Implementations may define additional interfaces to pass method-specific information between methods and lower layers. These interfaces are beyond the scope of this document.",
      "ja": "実装は、方法と下層との間の方式固有の情報を渡すために追加のインタフェースを定義してもよいです。これらのインタフェースは、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "8.3. Peer State Machine Interoperability with Deployed Implementations",
      "section_title": true,
      "ja": "8.3。配備実装とステートマシンの相互運用性をピア"
    },
    {
      "indent": 3,
      "text": "Number of deployed EAP authenticator implementations, mainly in RADIUS authentication servers, have been observed to increment the Identifier field incorrectly when generating EAP Success and EAP Failure packets which is against the MUST requirement in RFC 3748 section 4.2. The peer state machine is based on RFC 3748, and as such it will discard such EAP Success and EAP Failure packets.",
      "ja": "展開EAP認証の実装の数は、主にRADIUS認証サーバに、RFC 3748のセクション4.2でMUST要件に反しているEAP成功とEAP失敗パケットを生成する際に誤っ識別子フィールドを増加することが観察されています。ピア・ステート・マシンは、RFC 3748に基づいており、そのように、それは、EAP成功とEAP失敗パケットを破棄します。"
    },
    {
      "indent": 3,
      "text": "As a workaround for the potential interoperability issue with existing implementations, conditions for peer state machine transitions from RECEIVED state to SUCCESS and FAILURE states MAY be changed from \"(reqId == lastId)\" to \"((reqId == lastId) || (reqId == (lastId + 1) & 255))\". However, because this behavior does not conform to RFC 3748, such a workaround is not recommended, and if included, it should be implemented as an optional workaround that can be disabled.",
      "ja": "既存の実装との潜在的相互運用性の問題の回避策として、成功および失敗の状態に対して、受信した状態からピアステートマシン遷移の条件「（REQID == lastId）」から「（（REQID == lastId）||（から変更することができますREQID ==（lastId + 1）＆255））」。しかし、この動作はRFC 3748に準拠していないので、このような回避策が推奨されていない、と含まれている場合、それを無効にすることができ、オプションの回避策として実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document's intent is to describe the EAP state machine fully. To this end, any security concerns with this document are likely a reflection of security concerns with EAP itself.",
      "ja": "このドキュメントの意図を完全にEAPステートマシンを記述することです。このため、このドキュメントでのセキュリティ上の懸念はおそらくEAP自体にセキュリティ上の懸念を反映しています。"
    },
    {
      "indent": 3,
      "text": "An accurate state machine can help reduce implementation errors. Although [RFC3748] remains the normative protocol description, this state machine should help in this regard.",
      "ja": "正確なステートマシンは、実装エラーを減らすことができます。 [RFC3748]は規範プロトコル記述ままであるが、この状態マシンは、この点で役立つはずです。"
    },
    {
      "indent": 3,
      "text": "As noted in [RFC3748], some security concerns arise because of the following EAP packets:",
      "ja": "[RFC3748]で述べたように、いくつかのセキュリティ上の懸念があるため、次のEAPパケットを発生します。"
    },
    {
      "indent": 6,
      "text": "1. EAP-Request/Response Identity 2. EAP-Response/NAK 3. EAP-Success/Failure",
      "ja": "1. EAP-要求/応答アイデンティティ2. EAP応答/ NAK 3. EAP-成功/失敗"
    },
    {
      "indent": 3,
      "text": "Because these packets are not cryptographically protected by themselves, an attacker can modify or insert them without immediate detection by the peer or authenticator.",
      "ja": "これらのパケットが暗号的に自分自身で保護されていないので、攻撃者は、ピアまたはオーセンティケータによって即時検出せずにそれらを変更したり、挿入することができます。"
    },
    {
      "indent": 3,
      "text": "Following Figure 3 specification, an attacker may cause denial of service by: o Sending an EAP-Failure to the peer before the peer has started an EAP authentication method. As long as the peer has not modified the methodState variable (initialized to NONE), the peer MUST accept an EAP-Failure.",
      "ja": "図3仕様に続いて、攻撃者はによりサービス拒否を引き起こす可能性があります。ピアは、EAP認証方式を開始する前にピアにEAP-失敗を送信O。限り、ピアは（NONEに初期化）methodState変数を変更していないとして、ピアはEAP-障害を受け入れなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Forcing the peer to engage in endless EAP-Request/Response Identity exchanges before it has started an EAP authentication method. As long as the peer has not modified the selectedMethod variable (initialized to NONE), the peer MUST accept an EAP-Request/Identity and respond to it with an EAP-Response/Identity.",
      "ja": "それはEAP認証方式を開始した前に、無限のEAP要求/応答アイデンティティ交換に従事するためにピアを強制O。限りピアが（NONEに初期化）selectedMethod変数を変更していないとして、ピアはEAP要求/アイデンティティを受け入れ、EAP応答/アイデンティティと、それに反応しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Following Figure 4 specification, an attacker may cause denial of service by:",
      "ja": "図4の仕様に続いて、攻撃者がサービス拒否をすることによって引き起こされることがあります。"
    },
    {
      "indent": 3,
      "text": "o Sending a NAK to the authenticator after the authenticator first proposes an EAP authentication method to the peer. When the methodState variable has the value PROPOSED, the authenticator is obliged to process a NAK that is received in response to its first packet of an EAP authentication method.",
      "ja": "オーセンティケータの後にオーセンティケータにNAKを送信oを最初のピアにEAP認証方式を提案します。 methodState変数提案値を有する場合、オーセンティケータはEAP認証方式の最初のパケットに応答して受信されるNAKを処理する義務があります。"
    },
    {
      "indent": 3,
      "text": "There MAY be some cases when it is desired to prevent such attacks. This can be done by modifying initial values of some variables of the EAP state machines. However, such modifications are NOT RECOMMENDED.",
      "ja": "このような攻撃を防ぐことが望まれる場合、いくつかの場合もあります。これは、EAPステートマシンのいくつかの変数の初期値を変更することで行うことができます。しかし、そのような変更はお勧めしません。"
    },
    {
      "indent": 3,
      "text": "There is a trade-off between mitigating these denial-of-service attacks and being able to deal with EAP peers and authenticators in general. For instance, if a NAK is ignored when it is sent to the authenticator after it has just proposed an EAP authentication method to the peer, then a legitimate peer that is not able or willing to process the proposed EAP authentication method would fail without an opportunity to negotiate another EAP method.",
      "ja": "これらのサービス拒否攻撃を軽減し、一般的なEAPピアとオーセンティケータに対処することができることとの間にはトレードオフがあります。それはオーセンティケータに送信された場合例えば、NAKはそれだけで相手にEAP認証方式を提案した後、その後、提案されたEAP認証方式を処理することができたり望んでいない正当なピアはチャンスなしで失敗していまし無視されている場合別のEAPメソッドを交渉します。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgements",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "The work in this document was done as part of the EAP Design Team. It was done primarily by Nick Petroni, John Vollbrecht, Pasi Eronen, and Yoshihiro Ohba. Nick started this work with Bryan Payne and Chuk Seng at the University of Maryland. John Vollbrecht of Meetinghouse Data Communications started independently with help from Dave Spence at Interlink Networks. John and Nick collaborated to create a common document, and then were joined by Pasi Eronen of Nokia, who has made major contributions in creating coherent state machines, and by Yoshihiro Ohba of Toshiba, who insisted on including pass-through documentation and provided significant support for understanding implementation issues.",
      "ja": "この文書に記載されている作品は、EAP設計チームの一部として行われました。それはニックペトローニ、ジョンVollbrecht、パシEronen、および義弘大場によって主に行われていました。ニックは、メリーランド大学のブライアン・ペインとチュク・センでこの仕事を始めました。集会所データ通信のジョンVollbrechtは、インターリンクNetworksのデイブ・スペンスからの助けを借りて独立して始めました。ジョンとニックは、共通の文書を作成するために協力して、コヒーレントステートマシンを作成する際に大きな貢献をしてきたノキアのパシEronen、が加わった、とパススルードキュメントを含むことを主張し、重要なサポートを提供し、東芝の義弘大場、によって実装上の問題を理解するため。"
    },
    {
      "indent": 3,
      "text": "In addition, significant response and conversation has come from the design team, especially Jari Arkko of Ericsson and Bernard Aboba of Microsoft, as well as the rest of the team. It has also been reviewed by IEEE 802.1, and has had input from Jim Burns of Meetinghouse and Paul Congdon of Hewlett Packard.",
      "ja": "また、有意な応答との会話は、デザインチーム、特にエリクソンのヤリArkkoとマイクロソフトのバーナードAboba、だけでなく、チームの残りの部分から来ています。また、IEEE 802.1によって検討されてきた、と集会所のジム・バーンズとヒューレット・パッカードのポールコングドンからの入力がありました。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3579] Aboba, B. and P. Calhoun, \"RADIUS (Remote Authentication Dial In User Service) Support For Extensible Authentication Protocol (EAP)\", RFC 3579, September 2003.",
      "ja": "[RFC3579] Aboba、B.およびP.カルフーン、 \"RADIUS（ユーザサービスにおけるリモート認証ダイヤル）拡張認証プロトコル（EAP）のサポート\"、RFC 3579、2003年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3748] Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H. Levkowetz, Ed., \"Extensible Authentication Protocol (EAP)\", RFC 3748, June 2004.",
      "ja": "[RFC3748] Aboba、B.、ブルンク、L.、Vollbrecht、J.、カールソン、J.、およびH. Levkowetz、編、 \"拡張認証プロトコル（EAP）\"、RFC 3748、2004年6月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[Keying] Aboba, B., Simon, D., Arkko, J., Eronen, P., Levkowetz, H., \"Extensible Authentication Protocol (EAP) Key Management Framework\", Work in Progress, July 2005.",
      "ja": "【キーイング] Aboba、B.、サイモン、D.、Arkko、J.、Eronen、P.、Levkowetz、H.、 \"拡張認証プロトコル（EAP）鍵管理フレームワーク\"、進歩、2005年7月ワーク。"
    },
    {
      "indent": 3,
      "text": "[1X-2004] Institute of Electrical and Electronics Engineers, \"Standard for Local and Metropolitan Area Networks: Port-Based Network Access Control\", IEEE 802.1X-2004, December 2004.",
      "ja": "電気電子技術者の[1X-2004]研究所、「ローカルおよびメトロポリタンエリアネットワークの標準：ポートベースのネットワークアクセス制御」、IEEE 802.1X-2004、2004年12月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. ASCII versions of state diagrams",
      "ja": "状態図の付録A.のASCIIバージョン"
    },
    {
      "indent": 3,
      "text": "This appendix contains the state diagrams in ASCII format. Please use the PDF version whenever possible; it is much easier to understand.",
      "ja": "この付録では、ASCII形式の状態図が含まれています。可能な限りPDFのバージョンを使用してください。理解することがはるかに簡単です。"
    },
    {
      "indent": 3,
      "text": "The notation is as follows: state name and pseudocode executed when entering it are shown on the left; outgoing transitions with their conditions are shown on the right.",
      "ja": "次のように表記がある：それは左側に示されている入力するときの状態名と疑似コードを実行します。その条件と出力遷移が右側に表示されます。"
    },
    {
      "indent": 0,
      "text": "A.1. EAP Peer State Machine (Figure 3)",
      "ja": "A.1。 EAPピアステートマシン（図3）"
    },
    {
      "indent": 0,
      "text": "---------------------------------------------------------------------\n(global transitions)         |      !portEnabled      |      DISABLED\n                             |------------------------+--------------\n                             |     eapRestart &&      |    INITIALIZE\n                             |      portEnabled       |\n-----------------------------+------------------------+--------------\nDISABLED                     |      portEnabled       |    INITIALIZE\n-----------------------------+------------------------+--------------\nINITIALIZE                   |                        |\n                             |                        |\nselectedMethod = NONE        |                        |\nmethodState = NONE           |                        |\nallowNotifications = TRUE    |                        |\ndecision = FAIL              |          UCT           |          IDLE\nidleWhile = ClientTimeout    |                        |\nlastId = NONE                |                        |\neapSuccess = FALSE           |                        |\neapFail = FALSE              |                        |\neapKeyData = NONE            |                        |\neapKeyAvailable = FALSE      |                        |\neapRestart = FALSE           |                        |\n-----------------------------+------------------------+--------------\nIDLE                         |         eapReq         |      RECEIVED\n                             |------------------------+--------------\n                             |     (altAccept &&      |\n                             |  decision != FAIL) ||  |\n                             |   (idleWhile == 0 &&   |       SUCCESS\n                             |      decision ==       |\n                             |      UNCOND_SUCC)      |\n                             |------------------------+--------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "                             |------------------------+--------------\n                             |      altReject ||      |\n                             |   (idleWhile == 0 &&   |\n                             |      decision !=       |\n                             |    UNCOND_SUCC) ||     |       FAILURE\n                             |     (altAccept &&      |\n                             | methodState != CONT && |\n                             |   decision == FAIL)    |\n-----------------------------+------------------------+--------------\nRECEIVED                     |        rxReq &&        |        METHOD\n                             |  (reqId != lastId) &&  |\n(rxReq,rxSuccess,rxFailure,  |     (reqMethod ==      |\n  reqId,reqMethod) =         |   selectedMethod) &&   |\n  parseEapReq(eapReqData)    | (methodState != DONE)  |\n                             |------------------------+--------------\n                             |        rxReq &&        |\n                             |  (reqId != lastId) &&  |\n                             |   (selectedMethod ==   |\n                             |        NONE) &&        |    GET_METHOD\n                             |     (reqMethod !=      |\n                             |      IDENTITY) &&      |\n                             |     (reqMethod !=      |\n                             |     NOTIFICATION)      |\n                             |------------------------+--------------\n                             |        rxReq &&        |\n                             |  (reqId != lastId) &&  |\n                             |   (selectedMethod ==   |      IDENTITY\n                             |        NONE) &&        |\n                             |     (reqMethod ==      |\n                             |       IDENTITY)        |\n                             |------------------------+--------------\n                             |        rxReq &&        |\n                             |  (reqId != lastId) &&  |\n                             |   (reqMethod ==        |  NOTIFICATION\n                             |    NOTIFICATION) &&    |\n                             |   allowNotifications   |\n                             |------------------------+--------------\n                             |        rxReq &&        |    RETRANSMIT\n                             |   (reqId == lastId)    |\n                             |------------------------+--------------\n                             |      rxSuccess &&      |\n                             |  (reqId == lastId) &&  |       SUCCESS\n                             |   (decision != FAIL)   |\n                             |------------------------+--------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "                             |------------------------+--------------\n                             | (methodState!=CONT) && |\n                             |     ((rxFailure &&     |\n                             |      decision !=       |\n                             |    UNCOND_SUCC) ||     |       FAILURE\n                             |     (rxSuccess &&      |\n                             | decision == FAIL)) &&  |\n                             |   (reqId == lastId)    |\n                             |------------------------+--------------\n                             |          else          |       DISCARD\n-----------------------------+------------------------+--------------\nMETHOD                       |                        |\n                             |                        |\nignore = m.check(eapReqData) |         ignore         |       DISCARD\nif (!ignore) {               |                        |\n  (methodState, decision,    |                        |\n  allowNotifications) =      |------------------------+--------------\n  m.process(eapReqData)      |                        |\n  /* methodState is CONT,    |                        |\n     MAY_CONT, or DONE */    | (methodState==DONE) && |       FAILURE\n  /* decision is FAIL,       |   (decision == FAIL)   |\n     COND_SUCC, or           |                        |\n     UNCOND_SUCC */          |                        |\n  eapRespData =              |------------------------+--------------\n    m.buildResp(reqId)       |                        |\n  if (m.isKeyAvailable())    |          else          | SEND_RESPONSE\n    eapKeyData = m.getKey()  |                        |\n}                            |                        |\n-----------------------------+------------------------+--------------\nGET_METHOD                   |                        |\n                             |   selectedMethod ==    |\nif (allowMethod(reqMethod)) {|       reqMethod        |        METHOD\n  selectedMethod = reqMethod |                        |\n  methodState = INIT         |                        |\n} else {                     |------------------------+--------------\n  eapRespData =              |                        |\n    buildNak(reqId)          |          else          | SEND_RESPONSE\n}                            |                        |\n-----------------------------+------------------------+--------------\nIDENTITY                     |                        |\n                             |                        |\nprocessIdentity(eapReqData)  |          UCT           | SEND_RESPONSE\neapRespData =                |                        |\n  buildIdentity(reqId)       |                        |\n-----------------------------+------------------------+--------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-----------------------------+------------------------+--------------\nNOTIFICATION                 |                        |\n                             |                        |\nprocessNotify(eapReqData)    |          UCT           | SEND_RESPONSE\neapRespData =                |                        |\n  buildNotify(reqId)         |                        |\n-----------------------------+------------------------+--------------\nRETRANSMIT                   |                        |\n                             |          UCT           | SEND_RESPONSE\neapRespData = lastRespData   |                        |\n-----------------------------+------------------------+--------------\nDISCARD                      |                        |\n                             |          UCT           |          IDLE\neapReq = FALSE               |                        |\neapNoResp = TRUE             |                        |\n-----------------------------+------------------------+--------------\nSEND_RESPONSE                |                        |\n                             |                        |\nlastId = reqId               |                        |\nlastRespData = eapRespData   |          UCT           |          IDLE\neapReq = FALSE               |                        |\neapResp = TRUE               |                        |\nidleWhile = ClientTimeout    |                        |\n-----------------------------+------------------------+--------------\nSUCCESS                      |                        |\n                             |                        |\nif (eapKeyData != NONE)      |                        |\n  eapKeyAvailable = TRUE     |                        |\neapSuccess = TRUE            |                        |\n-----------------------------+------------------------+--------------\nFAILURE                      |                        |\n                             |                        |\neapFail = TRUE               |                        |\n---------------------------------------------------------------------\n                                Figure 8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2. EAP Stand-Alone Authenticator State Machine (Figure 4)",
      "ja": "A.2。 EAPは、スタンドアロン認証ステートマシン（図4）"
    },
    {
      "indent": 0,
      "text": "---------------------------------------------------------------------\n(global transitions)          |    !portEnabled     |        DISABLED\n                              |---------------------+----------------\n                              |    eapRestart &&    |      INITIALIZE\n                              |     portEnabled     |\n------------------------------+---------------------+----------------\nDISABLED                      |     portEnabled     |      INITIALIZE\n------------------------------+---------------------+----------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "------------------------------+---------------------+----------------\nINITIALIZE                    |                     |\n                              |                     |\ncurrentId = NONE              |                     |\neapSuccess = FALSE            |                     |\neapFail = FALSE               |         UCT         |   SELECT_ACTION\neapTimeout = FALSE            |                     |\neapKeyData = NONE             |                     |\neapKeyAvailable = FALSE       |                     |\neapRestart = FALSE            |                     |\n------------------------------+---------------------+----------------\nIDLE                          |                     |\n                              |  retransWhile == 0  |      RETRANSMIT\nretransWhile =                |                     |\n  calculateTimeout(           |---------------------+----------------\n   retransCount, eapSRTT,     |       eapResp       |        RECEIVED\n   eapRTTVAR, methodTimeout)  |                     |\n------------------------------+---------------------+----------------\nRETRANSMIT                    |                     |\n                              |   retransCount >    | TIMEOUT_FAILURE\nretransCount++                |     MaxRetrans      |\nif (retransCount<=MaxRetrans){|                     |\n  eapReqData = lastReqData    |---------------------+----------------\n  eapReq = TRUE               |        else         |            IDLE\n}                             |                     |\n------------------------------+---------------------+----------------\nRECEIVED                      |      rxResp &&      |\n                              |     (respId ==      |\n(rxResp,respId,respMethod)=   |    currentId) &&    |\n  parseEapResp(eapRespData)   | (respMethod == NAK  |\n                              |         ||          |             NAK\n                              |    respMethod ==    |\n                              |  EXPANDED_NAK) &&   |\n                              |   (methodState ==   |\n                              |      PROPOSED)      |\n                              |---------------------+----------------\n                              |      rxResp &&      |\n                              |     (respId ==      |\n                              |    currentId) &&    | INTEGRITY_CHECK\n                              |   (respMethod ==    |\n                              |   currentMethod)    |\n                              |---------------------+----------------\n                              |        else         |         DISCARD\n------------------------------+---------------------+----------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "------------------------------+---------------------+----------------\nNAK                           |                     |\n                              |         UCT         |   SELECT_ACTION\nm.reset()                     |                     |\nPolicy.update(<...>)          |                     |\n------------------------------+---------------------+----------------\nSELECT_ACTION                 | decision == FAILURE |         FAILURE\n                              |                     |\ndecision =                    |---------------------+----------------\n  Policy.getDecision()        | decision == SUCCESS |         SUCCESS\n/* SUCCESS, FAILURE, or       |---------------------+----------------\n   CONTINUE */                |        else         |  PROPOSE_METHOD\n------------------------------+---------------------+----------------\nINTEGRITY_CHECK               |       ignore        |         DISCARD\n                              |---------------------+----------------\nignore = m.check(eapRespData) |       !ignore       | METHOD_RESPONSE\n------------------------------+---------------------+----------------\nMETHOD_RESPONSE               |                     |\n                              | methodState == END  |   SELECT_ACTION\nm.process(eapRespData)        |                     |\nif (m.isDone()) {             |                     |\n  Policy.update(<...>)        |---------------------+----------------\n  eapKeyData = m.getKey()     |                     |\n  methodState = END           |        else         |  METHOD_REQUEST\n} else                        |                     |\n  methodState = CONTINUE      |                     |\n------------------------------+---------------------+----------------\nPROPOSE_METHOD                |                     |\n                              |                     |\ncurrentMethod =               |                     |\n  Policy.getNextMethod()      |                     |\nm.init()                      |         UCT         |  METHOD_REQUEST\nif (currentMethod==IDENTITY |||                     |\n  currentMethod==NOTIFICATION)|                     |\n  methodState = CONTINUE      |                     |\nelse                          |                     |\n  methodState = PROPOSED      |                     |\n------------------------------+---------------------+----------------\nMETHOD_REQUEST                |                     |\n                              |                     |\ncurrentId = nextId(currentId) |         UCT         |    SEND_REQUEST\neapReqData =                  |                     |\n  m.buildReq(currentId)       |                     |\nmethodTimeout = m.getTimeout()|                     |\n------------------------------+---------------------+----------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "------------------------------+---------------------+----------------\nDISCARD                       |                     |\n                              |         UCT         |            IDLE\neapResp = FALSE               |                     |\neapNoReq = TRUE               |                     |\n------------------------------+---------------------+----------------\nSEND_REQUEST                  |                     |\n                              |                     |\nretransCount = 0              |         UCT         |            IDLE\nlastReqData = eapReqData      |                     |\neapResp = FALSE               |                     |\neapReq = TRUE                 |                     |\n------------------------------+---------------------+----------------\nTIMEOUT_FAILURE               |                     |\n                              |                     |\neapTimeout = TRUE             |                     |\n------------------------------+---------------------+----------------\nFAILURE                       |                     |\n                              |                     |\neapReqData =                  |                     |\n  buildFailure(currentId)     |                     |\neapFail = TRUE                |                     |\n------------------------------+---------------------+----------------\nSUCCESS                       |                     |\n                              |                     |\neapReqData =                  |                     |\n  buildSuccess(currentId)     |                     |\nif (eapKeyData != NONE)       |                     |\n  eapKeyAvailable = TRUE      |                     |\neapSuccess = TRUE             |                     |\n---------------------------------------------------------------------\n                                Figure 9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.3. EAP Backend Authenticator State Machine (Figure 5)",
      "ja": "A.3。 EAPバックエンド認証ステートマシン（図5）"
    },
    {
      "indent": 0,
      "text": "---------------------------------------------------------------------\n(global transitions)          |   !backendEnabled   |        DISABLED\n------------------------------+---------------------+----------------\nDISABLED                      |  backendEnabled &&  |      INITIALIZE\n                              |     aaaEapResp      |\n------------------------------+---------------------+----------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "------------------------------+---------------------+----------------\nINITIALIZE                    |       !rxResp       |   SELECT_ACTION\n                              |---------------------+----------------\ncurrentMethod = NONE          |      rxResp &&      |\n(rxResp,respId,respMethod)=   | (respMethod == NAK  |\n  parseEapResp(aaaEapRespData)|         ||          |             NAK\nif (rxResp)                   |    respMethod ==    |\n  currentId = respId          |    EXPANDED_NAK)    |\nelse                          |---------------------+----------------\n  currentId = NONE            |        else         |  PICK_UP_METHOD\n------------------------------+---------------------+----------------\nPICK_UP_METHOD                |                     |\n                              |  currentMethod ==   |   SELECT_ACTION\nif (Policy.doPickUp(          |        NONE         |\n    respMethod)) {            |                     |\n  currentMethod = respMethod  |---------------------+----------------\n  m.initPickUp()              |        else         | METHOD_RESPONSE\n}                             |                     |\n------------------------------+---------------------+----------------\nIDLE                          |     aaaEapResp      |        RECEIVED\n------------------------------+---------------------+----------------\nRECEIVED                      |      rxResp &&      |\n                              |     (respId ==      |\n(rxResp,respId,respMethod)=   |    currentId) &&    |\n  parseEapResp(aaaEapRespData)| (respMethod == NAK  |\n                              |         ||          |             NAK\n                              |    respMethod ==    |\n                              |  EXPANDED_NAK) &&   |\n                              |   (methodState ==   |\n                              |      PROPOSED)      |\n                              |---------------------+----------------\n                              |      rxResp &&      |\n                              |     (respId ==      |\n                              |    currentId) &&    | INTEGRITY_CHECK\n                              |   (respMethod ==    |\n                              |   currentMethod)    |\n                              |---------------------+----------------\n                              |        else         |         DISCARD\n------------------------------+---------------------+----------------\nNAK                           |                     |\n                              |         UCT         |   SELECT_ACTION\nm.reset()                     |                     |\nPolicy.update(<...>)          |                     |\n------------------------------+---------------------+----------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "------------------------------+---------------------+----------------\nSELECT_ACTION                 | decision == FAILURE |         FAILURE\n                              |                     |\ndecision =                    |---------------------+----------------\n  Policy.getDecision()        | decision == SUCCESS |         SUCCESS\n/* SUCCESS, FAILURE, or       |---------------------+----------------\n   CONTINUE */                |        else         |  PROPOSE_METHOD\n------------------------------+---------------------+----------------\nINTEGRITY_CHECK               |       ignore        |         DISCARD\n                              |                     |\nignore =                      |---------------------+----------------\n  m.check(aaaEapRespData)     |       !ignore       | METHOD_RESPONSE\n------------------------------+---------------------+----------------\nMETHOD_RESPONSE               |                     |\n                              | methodState == END  |   SELECT_ACTION\nm.process(aaaEapRespData)     |                     |\nif (m.isDone()) {             |                     |\n  Policy.update(<...>)        |---------------------+----------------\n  aaaEapKeyData = m.getKey()  |                     |\n  methodState = END           |        else         |  METHOD_REQUEST\n} else                        |                     |\n  methodState = CONTINUE      |                     |\n------------------------------+---------------------+----------------\nPROPOSE_METHOD                |                     |\n                              |                     |\ncurrentMethod =               |                     |\n  Policy.getNextMethod()      |                     |\nm.init()                      |         UCT         |  METHOD_REQUEST\nif (currentMethod==IDENTITY |||                     |\n  currentMethod==NOTIFICATION)|                     |\n  methodState = CONTINUE      |                     |\nelse                          |                     |\n  methodState = PROPOSED      |                     |\n------------------------------+---------------------+----------------\nMETHOD_REQUEST                |                     |\n                              |                     |\ncurrentId = nextId(currentId) |                     |\naaaEapReqData =               |         UCT         |    SEND_REQUEST\n  m.buildReq(currentId)       |                     |\naaaMethodTimeout =            |                     |\n  m.getTimeout()              |                     |\n------------------------------+---------------------+----------------\nDISCARD                       |                     |\n                              |         UCT         |            IDLE\naaaEapResp = FALSE            |                     |\naaaEapNoReq = TRUE            |                     |\n------------------------------+---------------------+----------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "------------------------------+---------------------+----------------\nSEND_REQUEST                  |                     |\n                              |         UCT         |            IDLE\naaaEapResp = FALSE            |                     |\naaaEapReq = TRUE              |                     |\n------------------------------+---------------------+----------------\nFAILURE                       |                     |\n                              |                     |\naaaEapReqData =               |                     |\n  buildFailure(currentId)     |                     |\naaaEapFail = TRUE             |                     |\n------------------------------+---------------------+----------------\nSUCCESS                       |                     |\n                              |                     |\naaaEapReqData =               |                     |\n  buildSuccess(currentId)     |                     |\nif (aaaEapKeyData != NONE)    |                     |\n  aaaEapKeyAvailable = TRUE   |                     |\naaaEapSuccess = TRUE          |                     |\n---------------------------------------------------------------------\n                               Figure 10",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4. EAP Full Authenticator State Machine (Figures 6 and 7)",
      "ja": "A.4。 EAP完全認証ステートマシン（図6および7）"
    },
    {
      "indent": 3,
      "text": "This state machine contains all the states from EAP stand-alone authenticator state machine, except that SELECT_ACTION state is replaced with the following:",
      "ja": "そのSELECT_ACTION状態は次のように置き換えることを除いて、このステートマシンは、EAPのスタンドアロンの認証マシンからすべての状態が含まれています。"
    },
    {
      "indent": 0,
      "text": "---------------------------------------------------------------------\nSELECT_ACTION                 | decision == FAILURE |         FAILURE\n                              |                     |\ndecision =                    |---------------------+----------------\n  Policy.getDecision()        | decision == SUCCESS |         SUCCESS\n/* SUCCESS, FAILURE, CONTINUE,|---------------------+----------------\n   or PASSTHROUGH */          |     decision ==     |     INITIALIZE_\n                              |     PASSTHROUGH     |     PASSTHROUGH\n                              |---------------------+----------------\n                              |        else         |  PROPOSE_METHOD\n---------------------------------------------------------------------\n                               Figure 11",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "And the following new states are added:",
      "ja": "そして、次の新しい状態が追加されます。"
    },
    {
      "indent": 0,
      "text": "---------------------------------------------------------------------\nINITIALIZE_PASSTHROUGH        |  currentId != NONE  |     AAA_REQUEST\n                              |---------------------+----------------\naaaEapRespData = NONE         |  currentId == NONE  |        AAA_IDLE\n------------------------------+---------------------+----------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "------------------------------+---------------------+----------------\nIDLE2                         |                     |\n                              |  retransWhile == 0  |     RETRANSMIT2\nretransWhile =                |                     |\n  calculateTimeout(           |---------------------+----------------\n   retransCount, eapSRTT,     |       eapResp       |       RECEIVED2\n   eapRTTVAR, methodTimeout)  |                     |\n------------------------------+---------------------+----------------\nRETRANSMIT2                   |                     |\n                              |   retransCount >    |        TIMEOUT_\nretransCount++                |     MaxRetrans      |        FAILURE2\nif (retransCount<=MaxRetrans){|                     |\n  eapReqData = lastReqData    |---------------------+----------------\n  eapReq = TRUE               |        else         |           IDLE2\n}                             |                     |\n------------------------------+---------------------+----------------\nRECEIVED2                     |      rxResp &&      |\n                              |     (respId ==      |     AAA_REQUEST\n(rxResp,respId,respMethod)=   |     currentId)      |\n  parseEapResp(eapRespData)   |---------------------+----------------\n                              |        else         |        DISCARD2\n------------------------------+---------------------+----------------\nAAA_REQUEST                   |                     |\n                              |                     |\nif (respMethod == IDENTITY) { |         UCT         |        AAA_IDLE\n  aaaIdentity = eapRespData   |                     |\naaaEapRespData = eapRespData  |                     |\n------------------------------+---------------------+----------------\nAAA_IDLE                      |     aaaEapNoReq     |        DISCARD2\n                              |---------------------+----------------\naaaFail = FALSE               |      aaaEapReq      |    AAA_RESPONSE\naaaSuccess = FALSE            |---------------------+----------------\naaaEapReq = FALSE             |     aaaTimeout      |        TIMEOUT_\naaaEapNoReq = FALSE           |                     |        FAILURE2\naaaEapResp = TRUE             |---------------------+----------------\n                              |       aaaFail       |        FAILURE2\n                              |---------------------+----------------\n                              |     aaaSuccess      |        SUCCESS2\n------------------------------+---------------------+----------------\nAAA_RESPONSE                  |                     |\n                              |                     |\neapReqData = aaaEapReqData    |         UCT         |   SEND_REQUEST2\ncurrentId = getId(eapReqData) |                     |\nmethodTimeout =               |                     |\n  aaaMethodTimeout            |                     |\n------------------------------+---------------------+----------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "------------------------------+---------------------+----------------\nDISCARD2                      |                     |\n                              |         UCT         |           IDLE2\neapResp = FALSE               |                     |\neapNoReq = TRUE               |                     |\n------------------------------+---------------------+----------------\nSEND_REQUEST2                 |                     |\n                              |                     |\nretransCount = 0              |         UCT         |           IDLE2\nlastReqData = eapReqData      |                     |\neapResp = FALSE               |                     |\neapReq = TRUE                 |                     |\n------------------------------+---------------------+----------------\nTIMEOUT_FAILURE2              |                     |\n                              |                     |\neapTimeout = TRUE             |                     |\n------------------------------+---------------------+----------------\nFAILURE2                      |                     |\n                              |                     |\neapReqData = aaaEapReqData    |                     |\neapFail = TRUE                |                     |\n------------------------------+---------------------+----------------\nSUCCESS2                      |                     |\n                              |                     |\neapReqData = aaaEapReqData    |                     |\neapKeyData = aaaEapKeyData    |                     |\neapKeyAvailable =             |                     |\n  aaaEapKeyAvailable          |                     |\neapSuccess = TRUE             |                     |\n---------------------------------------------------------------------\n                               Figure 12",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "John Vollbrecht Meetinghouse Data Communications 9682 Alice Hill Drive Dexter, MI 48130 USA",
      "ja": "ジョンVollbrecht集会所データ・コミュニケーションズ9682アリスの丘ドライブデクスター、MI 48130 USA"
    },
    {
      "indent": 3,
      "text": "EMail: jrv@mtghouse.com",
      "ja": "メールアドレス：jrv@mtghouse.com"
    },
    {
      "indent": 3,
      "text": "Pasi Eronen Nokia Research Center P.O. Box 407 FIN-00045 Nokia Group, Finland",
      "ja": "ノキア・リサーチセンター私書箱のパシEronenボックス407 FIN-00045ノキアグループ、フィンランド"
    },
    {
      "indent": 3,
      "text": "EMail: pasi.eronen@nokia.com",
      "ja": "メールアドレス：pasi.eronen@nokia.com"
    },
    {
      "indent": 3,
      "text": "Nick L. Petroni, Jr. University of Maryland, College Park A.V. Williams Building College Park, MD 20742 USA",
      "ja": "ニック・L.ペトローニ、メリーランド州のジュニア大学、カレッジパークA.V.ウィリアムズビルカレッジパーク、MD 20742 USA"
    },
    {
      "indent": 3,
      "text": "EMail: npetroni@cs.umd.edu",
      "ja": "メールアドレス：npetroni@cs.umd.edu"
    },
    {
      "indent": 3,
      "text": "Yoshihiro Ohba Toshiba America Research, Inc. 1 Telcordia Drive Piscataway, NJ 08854 USA",
      "ja": "義弘大場東芝アメリカリサーチ社1のTelcordiaドライブピスカタウェイ、NJ 08854 USA"
    },
    {
      "indent": 3,
      "text": "EMail: yohba@tari.toshiba.com",
      "ja": "メールアドレス：yohba@tari.toshiba.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}