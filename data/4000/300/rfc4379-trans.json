{
  "title": {
    "text": "RFC 4379 - Detecting Multi-Protocol Label Switched (MPLS) Data Plane Failures",
    "ja": "RFC 4379 - マルチプロトコルラベルスイッチド検出（MPLS）データプレーン障害"
  },
  "number": 4379,
  "created_at": "2019-10-24 07:26:17.648409+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        K. Kompella\nRequest for Comments: 4379                        Juniper Networks, Inc.\nUpdates: 1122                                                 G. Swallow\nCategory: Standards Track                            Cisco Systems, Inc.\n                                                           February 2006",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Detecting Multi-Protocol Label Switched (MPLS) Data Plane Failures",
      "ja": "マルチプロトコルラベルスイッチド検出（MPLS）データプレーン障害"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a simple and efficient mechanism that can be used to detect data plane failures in Multi-Protocol Label Switching (MPLS) Label Switched Paths (LSPs). There are two parts to this document: information carried in an MPLS \"echo request\" and \"echo reply\" for the purposes of fault detection and isolation, and mechanisms for reliably sending the echo reply.",
      "ja": "この文書は、マルチプロトコルラベルスイッチングにおけるデータプレーンの障害を検出するために使用することができる簡単で効率的なメカニズムについて説明（MPLS）ラベルスイッチパス（LSP）。この文書には2つの部分があります情報は、MPLS「エコー要求」と障害検出および分離の目的のための「エコー応答」、かつ確実にエコー応答を送信するための機構で運ば。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n   1.1. Conventions ................................................3\n   1.2. Structure of This Document .................................3\n   1.3. Contributors ...............................................3\n2. Motivation ......................................................4\n   2.1. Use of Address Range 127/8 .................................4\n3. Packet Format ...................................................6\n   3.1. Return Codes ..............................................10\n   3.2. Target FEC Stack ..........................................11\n        3.2.1. LDP IPv4 Prefix ....................................12\n        3.2.2. LDP IPv6 Prefix ....................................13\n        3.2.3. RSVP IPv4 LSP ......................................13\n        3.2.4. RSVP IPv6 LSP ......................................14\n        3.2.5. VPN IPv4 Prefix ....................................14\n        3.2.6. VPN IPv6 Prefix ....................................15\n        3.2.7. L2 VPN Endpoint ....................................16",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        3.2.8. FEC 128 Pseudowire (Deprecated) ....................16\n        3.2.9. FEC 128 Pseudowire (Current) .......................17\n        3.2.10. FEC 129 Pseudowire ................................18\n        3.2.11. BGP Labeled IPv4 Prefix ...........................19\n        3.2.12. BGP Labeled IPv6 Prefix ...........................20\n        3.2.13. Generic IPv4 Prefix ...............................20\n        3.2.14. Generic IPv6 Prefix ...............................21\n        3.2.15. Nil FEC ...........................................21\n   3.3. Downstream Mapping ........................................22\n        3.3.1. Multipath Information Encoding .....................26\n        3.3.2. Downstream Router and Interface ....................28\n   3.4. Pad TLV ...................................................29\n   3.5. Vendor Enterprise Number ..................................29\n   3.6. Interface and Label Stack .................................29\n   3.7. Errored TLVs ..............................................31\n   3.8. Reply TOS Byte TLV ........................................31\n4. Theory of Operation ............................................32\n   4.1. Dealing with Equal-Cost Multi-Path (ECMP) .................32\n   4.2. Testing LSPs That Are Used to Carry MPLS Payloads .........33\n   4.3. Sending an MPLS Echo Request ..............................33\n   4.4. Receiving an MPLS Echo Request ............................34\n        4.4.1. FEC Validation .....................................40\n   4.5. Sending an MPLS Echo Reply ................................41\n   4.6. Receiving an MPLS Echo Reply ..............................42\n   4.7. Issue with VPN IPv4 and IPv6 Prefixes .....................42\n   4.8. Non-compliant Routers .....................................43\n5. References .....................................................43\n   5.1. Normative References ......................................43\n   5.2. Informative References ....................................44\n6. Security Considerations ........................................44\n7. IANA Considerations ............................................46\n   7.1. Message Types, Reply Modes, Return Codes ..................46\n   7.2. TLVs ......................................................47\n8. Acknowledgements ...............................................48",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes a simple and efficient mechanism that can be used to detect data plane failures in MPLS Label Switched Paths (LSPs). There are two parts to this document: information carried in an MPLS \"echo request\" and \"echo reply\", and mechanisms for transporting the echo reply. The first part aims at providing enough information to check correct operation of the data plane, as well as a mechanism to verify the data plane against the control plane, and thereby localize faults. The second part suggests two methods of reliable reply channels for the echo request message for more robust fault isolation.",
      "ja": "この文書では、パスのスイッチMPLSラベル内のデータプレーンの障害を検出するために使用することができる簡単で効率的な機構（LSPを）記載されています。 MPLS「エコー要求」および「エコー応答」で運ばれた情報、およびエコーリプライを輸送するためのメカニズム：この文書には2つの部分があります。最初の部分は、データプレーン、並びに制御プレーンに対するデータプレーンを検証するメカニズムの正しい動作を確認し、それによって障害をローカライズするために十分な情報を提供することを目的とします。第二の部分は、より堅牢な障害分離のためのエコー要求メッセージのための信頼できる応答チャネルの二つの方法を示唆しています。"
    },
    {
      "indent": 3,
      "text": "An important consideration in this design is that MPLS echo requests follow the same data path that normal MPLS packets would traverse. MPLS echo requests are meant primarily to validate the data plane, and secondarily to verify the data plane against the control plane. Mechanisms to check the control plane are valuable, but are not covered in this document.",
      "ja": "この設計で考慮すべき重要な点は、それがエコー要求は、通常のMPLSパケットが通過するのと同じデータ・パスをたどるMPLSです。 MPLSエコー要求は、データプレーンを検証するために、および二次制御プレーンに対するデータプレーンを確認するために主に意図されています。コントロールプレーンをチェックするメカニズムは貴重であるが、この文書でカバーされていません。"
    },
    {
      "indent": 3,
      "text": "This document makes special use of the address range 127/8. This is an exception to the behavior defined in RFC 1122 [RFC1122] and updates that RFC. The motivation for this change and the details of this exceptional use are discussed in section 2.1 below.",
      "ja": "この文書では、アドレス範囲8分の127の特殊な使用しています。これは、RFC 1122 [RFC1122]で定義された動作の例外であり、そのRFCを更新します。この変更と、この例外的使用の詳細については、動機は以下のセクション2.1に記載されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions",
      "section_title": true,
      "ja": "1.1。表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [KEYWORDS].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [KEYWORDS]で説明されるように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The term \"Must Be Zero\" (MBZ) is used in object descriptions for reserved fields. These fields MUST be set to zero when sent and ignored on receipt.",
      "ja": "用語「ゼロでなければならない」（MBZ）は予約フィールドのためのオブジェクト記述に使用されています。送られて、領収書の上で無視する場合、これらのフィールドをゼロに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Terminology pertaining to L2 and L3 Virtual Private Networks (VPNs) is defined in [RFC4026].",
      "ja": "L2及びL3仮想プライベートネットワーク（VPN）に関連する用語は、[RFC4026]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Since this document refers to the MPLS Time to Live (TTL) far more frequently than the IP TTL, the authors have chosen the convention of using the unqualified \"TTL\" to mean \"MPLS TTL\" and using \"IP TTL\" for the TTL value in the IP header.",
      "ja": "この文書は生きるためのMPLS時間（TTL）これまでよりも頻繁にIP TTLを指しているので、著者は、TTL値は、「MPLS TTL」を意味する資格のない「TTL」を使って「IP TTL」を使用しての規則を選択していますIPヘッダです。"
    },
    {
      "indent": 0,
      "text": "1.2. Structure of This Document",
      "section_title": true,
      "ja": "1.2。このドキュメントの構造"
    },
    {
      "indent": 3,
      "text": "The body of this memo contains four main parts: motivation, MPLS echo request/reply packet format, LSP ping operation, and a reliable return path. It is suggested that first-time readers skip the actual packet formats and read the Theory of Operation first; the document is structured the way it is to avoid forward references.",
      "ja": "モチベーション、MPLSエコー要求/応答パケットフォーマット、LSPピング操作、および信頼性の高いリターンパス：このメモの本体は4つの主な部品を含んでいます。初めての読者は、実際のパケットフォーマットをスキップして、最初の動作原理を読むことが示唆されました。文書は、それが前方参照を避けるためにある方法を構成されています。"
    },
    {
      "indent": 0,
      "text": "1.3. Contributors",
      "section_title": true,
      "ja": "1.3。協力者"
    },
    {
      "indent": 3,
      "text": "The following made vital contributions to all aspects of this document, and much of the material came out of debate and discussion among this group.",
      "ja": "以下は、このドキュメントのすべての面に重要な貢献をした、と材料の多くは、このグループ間の議論から出てきました。"
    },
    {
      "indent": 6,
      "text": "Ronald P. Bonica, Juniper Networks, Inc. Dave Cooper, Global Crossing Ping Pan, Hammerhead Systems",
      "ja": "ロナルドP. Bonica、ジュニパーネットワークス社デイブ・クーパー、グローバル・クロッシングのPingパン、ハンマーヘッドシステム"
    },
    {
      "indent": 6,
      "text": "Nischal Sheth, Juniper Networks, Inc. Sanjay Wadhwa, Juniper Networks, Inc.",
      "ja": "Nischal Sheth、ジュニパーネットワークス社のSanjay Wadhwa、ジュニパーネットワークス株式会社"
    },
    {
      "indent": 0,
      "text": "2. Motivation",
      "section_title": true,
      "ja": "2.動機"
    },
    {
      "indent": 3,
      "text": "When an LSP fails to deliver user traffic, the failure cannot always be detected by the MPLS control plane. There is a need to provide a tool that would enable users to detect such traffic \"black holes\" or misrouting within a reasonable period of time, and a mechanism to isolate faults.",
      "ja": "LSPは、ユーザトラフィックを提供するために失敗した場合、障害は常にMPLS制御プレーンによって検出することができません。合理的な期間内に、このようなトラフィック「ブラックホール」またはmisroutingを検出するために、ユーザーを可能にするツール、および障害を隔離するためのメカニズムを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "In this document, we describe a mechanism that accomplishes these goals. This mechanism is modeled after the ping/traceroute paradigm: ping (ICMP echo request [ICMP]) is used for connectivity checks, and traceroute is used for hop-by-hop fault localization as well as path tracing. This document specifies a \"ping\" mode and a \"traceroute\" mode for testing MPLS LSPs.",
      "ja": "この文書では、我々はこれらの目標を達成メカニズムを説明します。この機構は、ピング/トレースルートパラダイムの後にモデル化されます。ping（ICMPエコー要求[ICMP]）は接続性チェックのために使用され、およびtracerouteは、ホップバイホップ障害局在ならびに経路追跡のために使用されます。この文書では、MPLS LSPをテストするための「ピング」モードと「トレースルート」モードを指定します。"
    },
    {
      "indent": 3,
      "text": "The basic idea is to verify that packets that belong to a particular Forwarding Equivalence Class (FEC) actually end their MPLS path on a Label Switching Router (LSR) that is an egress for that FEC. This document proposes that this test be carried out by sending a packet (called an \"MPLS echo request\") along the same data path as other packets belonging to this FEC. An MPLS echo request also carries information about the FEC whose MPLS path is being verified. This echo request is forwarded just like any other packet belonging to that FEC. In \"ping\" mode (basic connectivity check), the packet should reach the end of the path, at which point it is sent to the control plane of the egress LSR, which then verifies whether it is indeed an egress for the FEC. In \"traceroute\" mode (fault isolation), the packet is sent to the control plane of each transit LSR, which performs various checks that it is indeed a transit LSR for this path; this LSR also returns further information that helps check the control plane against the data plane, i.e., that forwarding matches what the routing protocols determined as the path.",
      "ja": "基本的な考え方は、特定の転送等価クラス（FEC）に属するパケットが実際にそのFECのための出口であるルータ（LSR）のラベルスイッチング上で自分のMPLSパスを終了することを確認することです。この文書は、この試験は、このFECに属する他のパケットと同じデータ・パスに沿って（「MPLSエコー要求」と呼ばれる）パケットを送信することによって行うことが提案されています。 MPLSエコー要求は、MPLSパス検証されているFECについての情報を運びます。このエコー要求は、ちょうどそのFECに属する他のパケットと同様に転送されます。 「ピング」モード（基本的な接続性チェック）において、パケットは、それが、それが実際にFEC用の出口であるかどうかを検証出口LSRの制御プレーンに送られ、その時点で、パスの末尾に到達しなければなりません。 「トレースルート」モード（障害分離）では、パケットは、それが実際にこのパスの中継LSRであることを、様々なチェックを行い、各中継LSRの制御プレーンに送られます。このLSRはまた、データプレーンに対する制御プレーンを確認に役立つさらなる情報を返す、すなわち、その転送は、ルーティングプロトコルがパスとして決定ものと一致します。"
    },
    {
      "indent": 3,
      "text": "One way these tools can be used is to periodically ping an FEC to ensure connectivity. If the ping fails, one can then initiate a traceroute to determine where the fault lies. One can also periodically traceroute FECs to verify that forwarding matches the control plane; however, this places a greater burden on transit LSRs and thus should be used with caution.",
      "ja": "これらのツールを使用することができる一つの方法は、定期的に接続性を確保するためにFECをpingすることです。 pingが失敗した場合、1は、障害がどこにあるかを決定するためにtracerouteを開始することができます。一つは、その転送が制御プレーンと一致確認することも、定期的にトレースルートのFECことができ、しかし、これはトランジットLSRの上の大きな負担を課すので、注意して使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.1. Use of Address Range 127/8",
      "section_title": true,
      "ja": "2.1。アドレス範囲の使用8分の127"
    },
    {
      "indent": 3,
      "text": "As described above, LSP ping is intended as a diagnostic tool. It is intended to enable providers of an MPLS-based service to isolate network faults. In particular, LSP ping needs to diagnose situations where the control and data planes are out of sync. It performs this by routing an MPLS echo request packet based solely on its label stack. That is, the IP destination address is never used in a forwarding decision. In fact, the sender of an MPLS echo request packet may not know, a priori, the address of the router at the end of the LSP.",
      "ja": "上述したように、LSPピングは、診断ツールとして意図されています。ネットワーク障害を隔離するMPLSベースのサービスの提供を可能にするためのものです。具体的には、LSPピングは、制御プレーンとデータプレーンが同期していない状況を診断する必要があります。それは、そのラベルスタックのみに基づいてMPLSエコー要求パケットをルーティングすることによって、これを実行します。これは、転送決定に使用されることはありませんIP宛先アドレスです。実際には、MPLSエコー要求パケットの送信者は、先験的に、LSPの最後にルータのアドレスを知らないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Providers of MPLS-based services also need the ability to trace all of the possible paths that an LSP may take. Since most MPLS services are based on IP unicast forwarding, these paths are subject to equal-cost multi-path (ECMP) load sharing.",
      "ja": "MPLSベースのサービスの提供者はまた、LSPが取る可能性のあるすべてのパスをトレースする能力が必要です。ほとんどのMPLSサービスは、IPユニキャスト転送に基づいているので、これらのパスは、等コストマルチパス（ECMP）負荷分散の対象となっています。"
    },
    {
      "indent": 3,
      "text": "This leads to the following requirements:",
      "ja": "これは、次の要件につながります："
    },
    {
      "indent": 3,
      "text": "1. Although the LSP in question may be broken in unknown ways, the likelihood of a diagnostic packet being delivered to a user of an MPLS service MUST be held to an absolute minimum.",
      "ja": "1.当該LSPが未知の方法で破壊することができるが、MPLSサービスのユーザに配信される診断用パケットの可能性が最小限に保持されなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If an LSP is broken in such a way that it prematurely terminates, the diagnostic packet MUST NOT be IP forwarded.",
      "ja": "LSPは、それが途中で終了するように、壊れている場合2.は、診断パケットは、IPは、転送されてはなりません。"
    },
    {
      "indent": 3,
      "text": "3. A means of varying the diagnostic packets such that they exercise all ECMP paths is thus REQUIRED.",
      "ja": "3.それらは全てECMPパスを行使するように診断パケットを変化させる手段は、このように必要とされます。"
    },
    {
      "indent": 3,
      "text": "Clearly, using general unicast addresses satisfies neither of the first two requirements. A number of other options for addresses were considered, including a portion of the private address space (as determined by the network operator) and the newly designated IPv4 link local addresses. Use of the private address space was deemed ineffective since the leading MPLS-based service is an IPv4 Virtual Private Network (VPN). VPNs often use private addresses.",
      "ja": "明らかに、どちらも最初の二つの要件の一般的なユニキャストアドレスを満たすを使用していません。アドレスの他のオプションの数は、プライベートアドレス空間の部分（ネットワークオペレータによって決定される）と新たに指定されたIPv4リンクローカルアドレスを含む、と考えられました。主要なMPLSベースのサービスは、IPv4仮想プライベートネットワーク（VPN）であるため、プライベートアドレス空間の使用は効果がないと考えられました。 VPNは、多くの場合、プライベートアドレスを使用します。"
    },
    {
      "indent": 3,
      "text": "The IPv4 link local addresses are more attractive in that the scope over which they can be forwarded is limited. However, if one were to use an address from this range, it would still be possible for the first recipient of a diagnostic packet that \"escaped\" from a broken LSP to have that address assigned to the interface on which it arrived and thus could mistakenly receive such a packet. Furthermore, the IPv4 link local address range has only recently been allocated. Many deployed routers would forward a packet with an address from that range toward the default route.",
      "ja": "IPv4のローカルアドレスには、彼らが転送することができ、その上範囲が限られているという点で、より魅力的でリンクします。一つは、この範囲のアドレスを使用した場合しかし、それはまだ誤っ従ってができ、それが到着したインターフェイスに割り当てられ、そのアドレスを有することが壊れたLSPから「エスケープ」という診断用パケットの最初の受信者のために可能となりますこのようなパケットを受信します。さらに、IPv4のリンクローカルアドレスの範囲はごく最近割り当てられています。多くの展開ルータは、デフォルトルートに向けて、その範囲からアドレスを持つパケットを転送します。"
    },
    {
      "indent": 3,
      "text": "The 127/8 range for IPv4 and that same range embedded in as IPv4- mapped IPv6 addresses for IPv6 was chosen for a number of reasons.",
      "ja": "IPv4の8分の127範囲とIPv4-がIPv6のためのIPv6アドレスをマッピングされたように埋め込まれたその同じ範囲が多くの理由のために選択しました。"
    },
    {
      "indent": 3,
      "text": "RFC 1122 allocates the 127/8 as \"Internal host loopback address\" and states: \"Addresses of this form MUST NOT appear outside a host.\" Thus, the default behavior of hosts is to discard such packets. This helps to ensure that if a diagnostic packet is misdirected to a host, it will be silently discarded.",
      "ja": "RFC 1122は、「内部ホストのループバックアドレス」として8分の127を割り当て、状態：「この形式のアドレスは、ホストの外に現れてはなりません」このように、ホストのデフォルトの動作は、このようなパケットを破棄することです。これは、診断パケットがホストに誤って誘導されている場合、それは黙って廃棄されることを確実にするのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "RFC 1812 [RFC1812] states:",
      "ja": "RFC 1812 [RFC1812]は述べています："
    },
    {
      "indent": 6,
      "text": "A router SHOULD NOT forward, except over a loopback interface, any packet that has a destination address on network 127. A router MAY have a switch that allows the network manager to disable these checks. If such a switch is provided, it MUST default to performing the checks.",
      "ja": "ルータは、ループバックインタフェースを介し除き、ネットワーク管理者がこれらのチェックを無効にすることを可能にするスイッチを持っているかもしれませんネットワーク127ルータの宛先アドレスを持つすべてのパケットを転送すべきではありません。そのようなスイッチが用意されている場合は、チェックを実行するデフォルトしなければなりません。"
    },
    {
      "indent": 3,
      "text": "This helps to ensure that diagnostic packets are never IP forwarded.",
      "ja": "これは、診断パケットがIP転送されないことを確実にするために役立ちます。"
    },
    {
      "indent": 3,
      "text": "The 127/8 address range provides 16M addresses allowing wide flexibility in varying addresses to exercise ECMP paths. Finally, as an implementation optimization, the 127/8 provides an easy means of identifying possible LSP packets.",
      "ja": "8分の127のアドレス範囲は、ECMPパスを行使するアドレスを変更することで、広い柔軟性を可能16Mアドレスを提供します。最後に、実装の最適化として、8分の127は、可能なLSPパケットを特定する簡単な手段を提供します。"
    },
    {
      "indent": 0,
      "text": "3. Packet Format",
      "section_title": true,
      "ja": "3.パケットフォーマット"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request is a (possibly labeled) IPv4 or IPv6 UDP packet; the contents of the UDP packet have the following format:",
      "ja": "MPLSエコー要求は、（おそらく標識された）IPv4またはIPv6 UDPパケットです。 UDPパケットの内容は、次の形式を持っています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Version Number        |         Global Flags          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Message Type |   Reply mode  |  Return Code  | Return Subcode|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sender's Handle                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    TimeStamp Sent (seconds)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  TimeStamp Sent (microseconds)                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  TimeStamp Received (seconds)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                TimeStamp Received (microseconds)              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            TLVs ...                           |\n.                                                               .\n.                                                               .\n.                                                               .\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Version Number is currently 1. (Note: the version number is to be incremented whenever a change is made that affects the ability of an implementation to correctly parse or process an MPLS echo request/reply. These changes include any syntactic or semantic changes made to any of the fixed fields, or to any Type-Length-Value (TLV) or sub-TLV assignment or format that is defined at a certain version number. The version number may not need to be changed if an optional TLV or sub-TLV is added.)",
      "ja": "バージョン番号は、現在、1（注です：バージョン番号は変更が正しく解析やMPLSエコー要求/応答を処理する実装の能力に影響を与える行われるたびにインクリメントされるこれらの変更が行われた構文や意味の変更が含まれます。固定フィールドのいずれかに、または特定のバージョン番号で定義される任意のタイプレングス値（TLV）またはサブTLV割り当てまたはフォーマットに。バージョン番号は、オプションTLVまたはサブ場合に変更する必要がないかもしれませんTLVが追加されます。）"
    },
    {
      "indent": 3,
      "text": "The Global Flags field is a bit vector with the following format:",
      "ja": "グローバルFlagsフィールドは、次の形式のビットベクトルであります："
    },
    {
      "indent": 6,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             MBZ             |V|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "One flag is defined for now, the V bit; the rest MUST be set to zero when sending and ignored on receipt.",
      "ja": "1つのフラグは現在のために定義され、Vビット。残りは、送信時にゼロに設定して、領収書の上で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The V (Validate FEC Stack) flag is set to 1 if the sender wants the receiver to perform FEC Stack validation; if V is 0, the choice is left to the receiver.",
      "ja": "送信者は、受信機がFECスタックの検証を行いたい場合にV（検証FECスタック）フラグが1に設定されています。 Vが0の場合、選択は、受信機に任されています。"
    },
    {
      "indent": 3,
      "text": "The Message Type is one of the following:",
      "ja": "メッセージタイプは、次のいずれかです。"
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    MPLS echo request\n    2    MPLS echo reply",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Reply Mode can take one of the following values:",
      "ja": "返信モードは、次のいずれかの値をとることができます。"
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    Do not reply\n    2    Reply via an IPv4/IPv6 UDP packet\n    3    Reply via an IPv4/IPv6 UDP packet with Router Alert\n    4    Reply via application level control channel",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An MPLS echo request with 1 (Do not reply) in the Reply Mode field may be used for one-way connectivity tests; the receiving router may log gaps in the Sequence Numbers and/or maintain delay/jitter statistics. An MPLS echo request would normally have 2 (Reply via an IPv4/IPv6 UDP packet) in the Reply Mode field. If the normal IP return path is deemed unreliable, one may use 3 (Reply via an IPv4/IPv6 UDP packet with Router Alert). Note that this requires that all intermediate routers understand and know how to forward MPLS echo replies. The echo reply uses the same IP version number as the received echo request, i.e., an IPv4 encapsulated echo reply is sent in response to an IPv4 encapsulated echo request.",
      "ja": "応答モードフィールドに1 MPLSエコー要求（応答しない）一方向の接続テストに使用することができます。受信したルータは、シーケンス番号のギャップをログに記録および/または遅延/ジッタ統計を維持することができます。 MPLSエコー要求は、通常応答モードフィールドで（のIPv4 / IPv6のUDPパケットを介して返信）2を有するであろう。通常のIP戻り経路が信頼できないとみなされる場合、一つは3（ルータ警告付きのIPv4 / IPv6のUDPパケットを介して返信）を使用することができます。これは、すべての中間ルータを理解し、MPLSエコー応答を転送する方法を知っている必要があることに注意してください。エコー応答が受信されたエコー要求、すなわち、同じIPバージョン番号を使用して、IPv4のカプセル化されたエコー応答がエコー要求をカプセル化されたIPv4に応答して送信されます。"
    },
    {
      "indent": 3,
      "text": "Some applications support an IP control channel. One such example is the associated control channel defined in Virtual Circuit Connectivity Verification (VCCV) [VCCV]. Any application that supports an IP control channel between its control entities may set the Reply Mode to 4 (Reply via application level control channel) to ensure that replies use that same channel. Further definition of this codepoint is application specific and thus beyond the scope of this document.",
      "ja": "一部のアプリケーションでは、IP制御チャネルをサポートしています。その一例は、[VCCV]仮想回線接続性検証（VCCV）で定義された関連する制御チャネルです。その制御エンティティとの間のIP制御チャネルをサポートする任意のアプリケーションは応答が同じチャネルを使用することを保証するために、（アプリケーション・レベルの制御チャネルを介して返信）4への応答モードを設定してもよいです。このコードポイントのさらなる定義は、アプリケーション固有のため、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "Return Codes and Subcodes are described in the next section.",
      "ja": "リターンコードとサブコードについては、次のセクションで説明されています。"
    },
    {
      "indent": 3,
      "text": "The Sender's Handle is filled in by the sender, and returned unchanged by the receiver in the echo reply (if any). There are no semantics associated with this handle, although a sender may find this useful for matching up requests with replies.",
      "ja": "送信者のハンドルは、送信者によって記入し、エコー応答（もしあれば）に受信機でそのまま返されます。送信者が回答して要求を一致させるため、これは便利かもしれないが、このハンドルに関連付けられた意味は、ありません。"
    },
    {
      "indent": 3,
      "text": "The Sequence Number is assigned by the sender of the MPLS echo request and can be (for example) used to detect missed replies.",
      "ja": "シーケンス番号は、MPLSエコー要求の送信者によって割り当てられ、（例えば）逃した応答を検出するために用いることができます。"
    },
    {
      "indent": 3,
      "text": "The TimeStamp Sent is the time-of-day (in seconds and microseconds, according to the sender's clock) in NTP format [NTP] when the MPLS echo request is sent. The TimeStamp Received in an echo reply is the time-of-day (according to the receiver's clock) in NTP format that the corresponding echo request was received.",
      "ja": "MPLSエコー要求が送信されたときに送信されタイムスタンプは、[NTP] NTP形式で（送信者のクロックに従って、秒、マイクロ秒）の時刻です。タイムスタンプはエコー応答で受信した時刻（受信機のクロックに応じて）NTP形式で対応するエコー要求が受信されたことです。"
    },
    {
      "indent": 3,
      "text": "TLVs (Type-Length-Value tuples) have the following format:",
      "ja": "TLV（タイプ - 長さ - 値タプル）次の形式を持っています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Value                             |\n.                                                               .\n.                                                               .\n.                                                               .\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Types are defined below; Length is the length of the Value field in octets. The Value field depends on the Type; it is zero padded to align to a 4-octet boundary. TLVs may be nested within other TLVs, in which case the nested TLVs are called sub-TLVs. Sub-TLVs have independent types and MUST also be 4-octet aligned.",
      "ja": "種類は、以下に定義されています。長さはオクテット単位で値フィールドの長さです。 Valueフィールドはタイプによって異なります。それはゼロが4オクテット境界に整列させるためにパディングされます。 TLVのTLVは、ネストされたサブTLVを呼ばれた場合に他のTLV内にネストされてもよいです。サブTLVが独立したタイプがあり、また、4オクテットを整列させる必要があります。"
    },
    {
      "indent": 3,
      "text": "Two examples follow. The Label Distribution Protocol (LDP) IPv4 FEC sub-TLV has the following format:",
      "ja": "二つの例は以下の通り。ラベル配布プロトコル（LDP）のIPv4 FECサブTLVは、次の形式を有します。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 1 (LDP IPv4 FEC)    |          Length = 5           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Length for this TLV is 5. A Target FEC Stack TLV that contains an LDP IPv4 FEC sub-TLV and a VPN IPv4 prefix sub-TLV has the following format:",
      "ja": "このTLVの長さがLDPのIPv4 FECサブTLVとサブTLVは以下のフォーマットを有するVPN IPv4プレフィクスが含まれている5 AターゲットFECスタックTLVです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Type = 1 (FEC TLV)       |          Length = 12          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  sub-Type = 1 (LDP IPv4 FEC)  |          Length = 5           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| sub-Type = 6 (VPN IPv4 prefix)|          Length = 13          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv4 prefix                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A description of the Types and Values of the top-level TLVs for LSP ping are given below:",
      "ja": "LSPピングのための最上位のTLVのタイプと値の説明を以下に示します。"
    },
    {
      "indent": 10,
      "text": "Type #                  Value Field\n------                  -----------\n     1                  Target FEC Stack\n     2                  Downstream Mapping\n     3                  Pad\n     4                  Not Assigned\n     5                  Vendor Enterprise Number\n     6                  Not Assigned\n     7                  Interface and Label Stack\n     8                  Not Assigned\n     9                  Errored TLVs\n    10                  Reply TOS Byte",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Types less than 32768 (i.e., with the high-order bit equal to 0) are mandatory TLVs that MUST either be supported by an implementation or result in the return code of 2 (\"One or more of the TLVs was not understood\") being sent in the echo response.",
      "ja": "32768未満の種類（すなわち、0に等しい上位ビットで）のいずれかの実装によってサポートされる、または戻りコードをもたらすされなければならない必須のTLVは、2（「1つのTLVの複数が理解されていなかった」）でありますエコー応答で送信されました。"
    },
    {
      "indent": 3,
      "text": "Types greater than or equal to 32768 (i.e., with the high-order bit equal to 1) are optional TLVs that SHOULD be ignored if the implementation does not understand or support them.",
      "ja": "（すなわち、1に等しい最上位ビットを有する）よりも大きいか、または32768に等しいタイプは実装がそれらを理解し、またはサポートしていない場合は無視されるべき任意のTLVです。"
    },
    {
      "indent": 0,
      "text": "3.1. Return Codes",
      "section_title": true,
      "ja": "3.1。リターンコード"
    },
    {
      "indent": 3,
      "text": "The Return Code is set to zero by the sender. The receiver can set it to one of the values listed below. The notation <RSC> refers to the Return Subcode. This field is filled in with the stack-depth for those codes that specify that. For all other codes, the Return Subcode MUST be set to zero.",
      "ja": "リターンコードは、送信者によってゼロに設定されています。受信機は、下記のいずれかの値に設定することができます。表記<RSCは>リターンサブコードを指します。このフィールドは、その指定これらのコードのためのスタック深さで充填されています。他のすべてのコードの場合、リターン・サブコードをゼロに設定しなければなりません。"
    },
    {
      "indent": 10,
      "text": "Value    Meaning\n-----    -------",
      "raw": true
    },
    {
      "indent": 14,
      "text": "0 No return code",
      "ja": "0ノーリターンコードに"
    },
    {
      "indent": 14,
      "text": "1 Malformed echo request received",
      "ja": "1つの不正なエコー要求を受信しました"
    },
    {
      "indent": 14,
      "text": "2 One or more of the TLVs was not understood",
      "ja": "2つまたはそれ以上のTLVのは理解されていませんでした"
    },
    {
      "indent": 14,
      "text": "3 Replying router is an egress for the FEC at stack-depth <RSC>",
      "ja": "3返信ルータはスタック深さでのFECのための出口である<RSC>"
    },
    {
      "indent": 14,
      "text": "4 Replying router has no mapping for the FEC at stack-depth <RSC>",
      "ja": "4返信ルータはスタック深さでFECのためのマッピングを持っていない<RSC>"
    },
    {
      "indent": 14,
      "text": "5 Downstream Mapping Mismatch (See Note 1)",
      "ja": "5ダウンストリームマッピングミスマッチ（注1を参照）。"
    },
    {
      "indent": 14,
      "text": "6 Upstream Interface Index Unknown (See Note 1)",
      "ja": "6アップストリームインターフェイスインデックス不明（注1を参照してください）"
    },
    {
      "indent": 14,
      "text": "7 Reserved",
      "ja": "7予約"
    },
    {
      "indent": 14,
      "text": "8 Label switched at stack-depth <RSC>",
      "ja": "8ラベルは<RSC>スタック深さで切り換え"
    },
    {
      "indent": 14,
      "text": "9 Label switched but no MPLS forwarding at stack-depth <RSC>",
      "ja": "9ラベルは、スイッチが、スタックの深さで無MPLSフォワーディング<RSC>"
    },
    {
      "indent": 13,
      "text": "10 Mapping for this FEC is not the given label at stack-depth <RSC>",
      "ja": "このFECのための10のマッピングはスタック深さで所定のラベルではない<RSC>"
    },
    {
      "indent": 13,
      "text": "11 No label entry at stack-depth <RSC>",
      "ja": "スタックの深さで11ノーラベルエントリ<RSC>"
    },
    {
      "indent": 13,
      "text": "12 Protocol not associated with interface at FEC stack-depth <RSC>",
      "ja": "FECスタック深さのインタフェースに関連付けられていない12プロトコル<RSC>"
    },
    {
      "indent": 13,
      "text": "13 Premature termination of ping due to label stack shrinking to a single label",
      "ja": "単一のラベルに縮小によるラベルスタックへのpingの13早すぎる終了"
    },
    {
      "indent": 3,
      "text": "Note 1",
      "ja": "注1"
    },
    {
      "indent": 6,
      "text": "The Return Subcode contains the point in the label stack where processing was terminated. If the RSC is 0, no labels were processed. Otherwise the packet would have been label switched at depth RSC.",
      "ja": "戻るサブコードは、処理が終了したラベルスタック内のポイントが含まれています。 RSCが0の場合、ラベルは処理されませんでした。そうでない場合、パケットは、ラベルは深さRSCで切り替えされていたであろう。"
    },
    {
      "indent": 0,
      "text": "3.2. Target FEC Stack",
      "section_title": true,
      "ja": "3.2。ターゲットFECスタック"
    },
    {
      "indent": 3,
      "text": "A Target FEC Stack is a list of sub-TLVs. The number of elements is determined by looking at the sub-TLV length fields.",
      "ja": "ターゲットFECスタックは、サブのTLVのリストです。要素の数は、サブTLVの長さフィールドを見ることによって決定されます。"
    },
    {
      "indent": 6,
      "text": "Sub-Type       Length            Value Field\n--------       ------            -----------\n       1            5            LDP IPv4 prefix\n       2           17            LDP IPv6 prefix\n       3           20            RSVP IPv4 LSP\n       4           56            RSVP IPv6 LSP\n       5                         Not Assigned\n       6           13            VPN IPv4 prefix\n       7           25            VPN IPv6 prefix\n       8           14            L2 VPN endpoint\n       9           10            \"FEC 128\" Pseudowire (deprecated)\n      10           14            \"FEC 128\" Pseudowire\n      11          16+            \"FEC 129\" Pseudowire\n      12            5            BGP labeled IPv4 prefix",
      "raw": true
    },
    {
      "indent": 12,
      "text": "13           17            BGP labeled IPv6 prefix\n14            5            Generic IPv4 prefix\n15           17            Generic IPv6 prefix\n16            4            Nil FEC",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Other FEC Types will be defined as needed.",
      "ja": "必要に応じて他のFECタイプが定義されます。"
    },
    {
      "indent": 3,
      "text": "Note that this TLV defines a stack of FECs, the first FEC element corresponding to the top of the label stack, etc.",
      "ja": "このTLV等のFEC、ラベルスタックの最上位に対応する最初のFEC要素のスタックを定義することに注意してください"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request MUST have a Target FEC Stack that describes the FEC Stack being tested. For example, if an LSR X has an LDP mapping [LDP] for 192.168.1.1 (say, label 1001), then to verify that label 1001 does indeed reach an egress LSR that announced this prefix via LDP, X can send an MPLS echo request with an FEC Stack TLV with one FEC in it, namely, of type LDP IPv4 prefix, with prefix 192.168.1.1/32, and send the echo request with a label of 1001.",
      "ja": "MPLSエコー要求は、FECスタックがテストされている記述のターゲットFECスタックを持たなければなりません。 LSR Xが192.168.1.1（たとえば、ラベル1001）のために[LDP] LDPマッピングを持っている場合たとえば、そのラベル1001は確かに自民党を経由して、この接頭辞を発表しました出口LSRに到達ん検証するために、Xは、MPLSエコーを送信することができますプレフィックス192.168.1.1/32で、タイプLDPのIPv4プレフィックス、すなわち、その中で1つのFECとFECスタックTLVを要求し、1001のラベルを持つエコー要求を送信します。"
    },
    {
      "indent": 3,
      "text": "Say LSR X wanted to verify that a label stack of <1001, 23456> is the right label stack to use to reach a VPN IPv4 prefix [see section 3.2.5] of 10/8 in VPN foo. Say further that LSR Y with loopback address 192.168.1.1 announced prefix 10/8 with Route Distinguisher RD-foo-Y (which may in general be different from the Route Distinguisher that LSR X uses in its own advertisements for VPN foo), label 23456 and BGP next hop 192.168.1.1 [BGP]. Finally, suppose that LSR X receives a label binding of 1001 for 192.168.1.1 via LDP. X has two choices in sending an MPLS echo request: X can send an MPLS echo request with an FEC Stack TLV with a single FEC of type VPN IPv4 prefix with a prefix of 10/8 and a Route Distinguisher of RD-foo-Y. Alternatively, X can send an FEC Stack TLV with two FECs, the first of type LDP IPv4 with a prefix of 192.168.1.1/32 and the second of type of IP VPN with a prefix 10/8 with Route Distinguisher of RD-foo-Y. In either case, the MPLS echo request would have a label stack of <1001, 23456>. (Note: in this example, 1001 is the \"outer\" label and 23456 is the \"inner\" label.)",
      "ja": "LSR Xは<1001、23456>のラベルスタックは、VPNのIPv4プレフィックスに到達するために使用する権利ラベルスタックであることを確認したかったと言うVPN fooの中で10/8の[セクション3.2.5を参照してください]。ループバックアドレス192.168.1.1を持つLSR Yは、（一般に、LSR XはVPN fooの独自の広告で使用するルート識別子と異なっていてもよい）ルート区分RD-FOO-Yとラベル23456をプレフィックス10/8を発表することをさらに言いますそしてBGPネクストホップ192.168.1.1 [BGP]。最後に、LSR XはLDP経由で192.168.1.1のための1001の結合ラベルを受けることとします。 Xは、MPLSエコー要求を送信するには2つの選択肢があります：Xは10/8のプレフィックスとRD-FOO-Yのルート識別子と種類VPNのIPv4プレフィックスの単一FECとFECスタックTLVとMPLSエコー要求を送信することができます。あるいは、Xは192.168.1.1/32のプレフィックスとRD-foo-のルート識別子を持つプレフィックス10/8を持つIP VPNの種類の第有する2つのFEC、タイプLDPのIPv4の最初とFECスタックTLVを送信することができY.いずれの場合も、MPLSエコー要求は<1001、23456>のラベルスタックを持っているでしょう。 （注：この例では、1001は、「外側」ラベルであり、23456は、「内側」ラベルです。）"
    },
    {
      "indent": 0,
      "text": "3.2.1. LDP IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.1。 LDP IPv4のプレフィックス"
    },
    {
      "indent": 3,
      "text": "The IPv4 Prefix FEC is defined in [LDP]. When an LDP IPv4 prefix is encoded in a label stack, the following format is used. The value consists of 4 octets of an IPv4 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv4 prefix is in network byte order; if the prefix is shorter than 32 bits, trailing bits SHOULD be set to zero. See [LDP] for an example of a Mapping for an IPv4 FEC.",
      "ja": "IPv4のプレフィックスFECは[LDP]で定義されています。 LDP IPv4のプレフィックスがラベルスタックで符号化された場合、以下の形式が使用されます。値は、ビットでプレフィックス長の1つのオクテット続いIPv4プレフィクスの4つのオクテットから成ります。フォーマットは以下のとおりです。 IPv4のプレフィックスは、ネットワークバイトオーダです。プレフィックスが32ビットよりも短い場合、末尾のビットはゼロに設定されるべきです。 IPv4のFECのためのマッピングの例について[LDP]参照。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.2. LDP IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.2。自民党のIPv6プレフィックス"
    },
    {
      "indent": 3,
      "text": "The IPv6 Prefix FEC is defined in [LDP]. When an LDP IPv6 prefix is encoded in a label stack, the following format is used. The value consists of 16 octets of an IPv6 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv6 prefix is in network byte order; if the prefix is shorter than 128 bits, the trailing bits SHOULD be set to zero. See [LDP] for an example of a Mapping for an IPv6 FEC.",
      "ja": "IPv6のプレフィックスFECは[LDP]で定義されています。 LDP IPv6プレフィックスをラベルスタックに符号化される場合、以下の形式が使用されます。値は、ビットでプレフィックス長の1つのオクテット続くIPv6プレフィックスの16個のオクテットから成ります。フォーマットは以下のとおりです。 IPv6プレフィックスは、ネットワークバイトオーダです。プレフィックスが128ビットより短い場合、後続のビットがゼロに設定されるべきです。 IPv6のFECのためのマッピングの例について[LDP]参照。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv6 prefix                          |\n|                          (16 octets)                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.3. RSVP IPv4 LSP",
      "section_title": true,
      "ja": "3.2.3。 RSVP IPv4のLSP"
    },
    {
      "indent": 3,
      "text": "The value has the format below. The value fields are taken from RFC 3209, sections 4.6.1.1 and 4.6.2.1. See [RSVP-TE].",
      "ja": "値は以下の形式があります。値フィールドは、RFC 3209、セクション4.6.1.1と4.6.2.1から取得されます。 [RSVP-TE]を参照してください。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 IPv4 tunnel end point address                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |     Tunnel ID                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Extended Tunnel ID                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   IPv4 tunnel sender address                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |            LSP ID             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.4. RSVP IPv6 LSP",
      "section_title": true,
      "ja": "3.2.4。 RSVP IPv6のLSP"
    },
    {
      "indent": 3,
      "text": "The value has the format below. The value fields are taken from RFC 3209, sections 4.6.1.2 and 4.6.2.2. See [RSVP-TE].",
      "ja": "値は以下の形式があります。値フィールドは、RFC 3209、セクション4.6.1.2と4.6.2.2から取得されます。 [RSVP-TE]を参照してください。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 IPv6 tunnel end point address                 |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |          Tunnel ID            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Extended Tunnel ID                      |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   IPv6 tunnel sender address                  |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |            LSP ID             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.5. VPN IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.5。 VPN IPv4のプレフィックス"
    },
    {
      "indent": 3,
      "text": "VPN-IPv4 Network Layer Routing Information (NLRI) is defined in [RFC4365]. This document uses the term VPN IPv4 prefix for a VPN-IPv4 NLRI that has been advertised with an MPLS label in BGP. See [BGP-LABEL].",
      "ja": "VPN-IPv4のネットワークレイヤルーティング情報（NLRI）は[RFC4365]で定義されています。この文書は、BGPでのMPLSラベルでアドバタイズされたVPN-IPv4のNLRIのための用語VPNのIPv4プレフィックスを使用しています。 [BGP-LABEL]を参照してください。"
    },
    {
      "indent": 3,
      "text": "When a VPN IPv4 prefix is encoded in a label stack, the following format is used. The value field consists of the Route Distinguisher advertised with the VPN IPv4 prefix, the IPv4 prefix (with trailing 0 bits to make 32 bits in all), and a prefix length, as follows:",
      "ja": "VPN IPv4プレフィクスをラベルスタックに符号化される場合、以下の形式が使用されます。次のように値フィールドは、VPN IPv4のプレフィックス、（全部で32ビットを作るために0ビットを末尾で）IPv4プレフィクス、およびプレフィックス長でアドバタイズルート識別子で構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv4 prefix                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Route Distinguisher (RD) is an 8-octet identifier; it does not contain any inherent information. The purpose of the RD is solely to allow one to create distinct routes to a common IPv4 address prefix. The encoding of the RD is not important here. When matching this field to the local FEC information, it is treated as an opaque value.",
      "ja": "ルート区分（RD）は、8オクテットの識別子です。それは、どんな固有の情報が含まれていません。 RDの目的は1つが、共通のIPv4アドレスのプレフィックスに明確なルートを作成できるようにするためだけです。 RDのエンコーディングは、ここでは重要ではありません。ローカルFEC情報にこのフィールドに一致する場合には、不透明な値として扱われます。"
    },
    {
      "indent": 0,
      "text": "3.2.6. VPN IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.6。 VPNのIPv6プレフィックス"
    },
    {
      "indent": 3,
      "text": "VPN-IPv6 Network Layer Routing Information (NLRI) is defined in [RFC4365]. This document uses the term VPN IPv6 prefix for a VPN-IPv6 NLRI that has been advertised with an MPLS label in BGP. See [BGP-LABEL].",
      "ja": "VPN-IPv6ネットワークレイヤルーティング情報（NLRI）は[RFC4365]で定義されています。この文書は、BGPでのMPLSラベルでアドバタイズされたVPN-IPv6のNLRIのための用語VPN IPv6プレフィックスを使用しています。 [BGP-LABEL]を参照してください。"
    },
    {
      "indent": 3,
      "text": "When a VPN IPv6 prefix is encoded in a label stack, the following format is used. The value field consists of the Route Distinguisher advertised with the VPN IPv6 prefix, the IPv6 prefix (with trailing 0 bits to make 128 bits in all), and a prefix length, as follows:",
      "ja": "VPNのIPv6プレフィックスがラベルスタックでコード化された場合、以下のフォーマットが使用されています。次のように値フィールドは、VPN IPv6プレフィックス、（全部で128ビットを作るために0ビットを末尾で）IPv6プレフィックス、及びプレフィックス長でアドバタイズルート識別子で構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv6 prefix                           |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Route Distinguisher is identical to the VPN IPv4 Prefix RD, except that it functions here to allow the creation of distinct routes to IPv6 prefixes. See section 3.2.5. When matching this field to local FEC information, it is treated as an opaque value.",
      "ja": "ルート識別子は、IPv6プレフィックスに異なるルートの作成を可能にするためにここで機能することを除いて、VPN IPv4のプレフィックスRDと同じです。セクション3.2.5を参照してください。ローカルFEC情報にこのフィールドに一致する場合には、不透明な値として扱われます。"
    },
    {
      "indent": 0,
      "text": "3.2.7. L2 VPN Endpoint",
      "section_title": true,
      "ja": "3.2.7。 L2 VPNエンドポイント"
    },
    {
      "indent": 3,
      "text": "VPLS stands for Virtual Private LAN Service. The terms VPLS BGP NLRI and VE ID (VPLS Edge Identifier) are defined in [VPLS-BGP]. This document uses the simpler term L2 VPN endpoint when referring to a VPLS BGP NLRI. The Route Distinguisher is an 8-octet identifier used to distinguish information about various L2 VPNs advertised by a node. The VE ID is a 2-octet identifier used to identify a particular node that serves as the service attachment point within a VPLS. The structure of these two identifiers is unimportant here; when matching these fields to local FEC information, they are treated as opaque values. The encapsulation type is identical to the PW Type in section 3.2.8 below.",
      "ja": "VPLSは、仮想プライベートLANサービスの略です。用語VPLS BGP NLRIとID（VPLSエッジ識別子）VEは、[VPLS-BGP]で定義されています。 VPLS BGP NLRIを参照するときにこの文書では、単純な用語L2 VPNエンドポイントを使用しています。ルート識別子は、ノードによってアドバタイズ各種L2 VPNの情報を区別するために使用される8オクテット識別子です。ザは、IDがVPLS内のサービス接続ポイントとして機能する特定のノードを識別するために使用される2オクテットの識別子であるVE。これら二つの識別子の構造は、ここでは重要ではありません。地元のFEC情報にこれらのフィールドを照合するとき、彼らは不透明な値として扱われます。カプセル化タイプは、以下のセクション3.2.8にPWタイプと同一です。"
    },
    {
      "indent": 3,
      "text": "When an L2 VPN endpoint is encoded in a label stack, the following format is used. The value field consists of a Route Distinguisher (8 octets), the sender (of the ping)'s VE ID (2 octets), the receiver's VE ID (2 octets), and an encapsulation type (2 octets), formatted as follows:",
      "ja": "L2 VPNエンドポイントは、ラベルスタックに符号化される場合、以下の形式が使用されます。値フィールドはルート区分（8つのオクテット）、（PINGの）送信者のID（2つのオクテット）VEから成る、受信機のは、次のようにフォーマットされ、ID（2つのオクテット）、およびカプセル化タイプ（2つのオクテット）VE ："
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Sender's VE ID        |       Receiver's VE ID        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Encapsulation Type       |         Must Be Zero          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.8. FEC 128 Pseudowire (Deprecated)",
      "section_title": true,
      "ja": "3.2.8。 FEC 128疑似回線（非推奨）"
    },
    {
      "indent": 3,
      "text": "FEC 128 (0x80) is defined in [PW-CONTROL], as are the terms PW ID (Pseudowire ID) and PW Type (Pseudowire Type). A PW ID is a non-zero 32-bit connection ID. The PW Type is a 15-bit number indicating the encapsulation type. It is carried right justified in the field below termed encapsulation type with the high-order bit set to zero. Both of these fields are treated in this protocol as opaque values.",
      "ja": "用語PW ID（疑似回線ID）とPWタイプ（疑似タイプ）であるとしてFEC 128（0x80の）は、[PW-CONTROL]で定義されています。 PW IDは、非ゼロの32ビット接続IDです。 PWタイプのカプセル化タイプを示す15ビットの数です。ゼロ以下に設定し、上位ビットでカプセル化タイプと呼ばれる分野での右寄せ行われます。これらのフィールドの両方が不透明な値として、このプロトコルで処理されます。"
    },
    {
      "indent": 3,
      "text": "When an FEC 128 is encoded in a label stack, the following format is used. The value field consists of the remote PE address (the destination address of the targeted LDP session), the PW ID, and the encapsulation type as follows:",
      "ja": "FEC 128はラベルスタックに符号化される場合、以下の形式が使用されます。次のように値フィールドは、リモートPEアドレス（ターゲットLDPセッションの宛先アドレス）、PWのID、およびカプセル化タイプで構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Remote PE Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             PW ID                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            PW Type            |          Must Be Zero         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This FEC is deprecated and is retained only for backward compatibility. Implementations of LSP ping SHOULD accept and process this TLV, but SHOULD send LSP ping echo requests with the new TLV (see next section), unless explicitly configured to use the old TLV.",
      "ja": "このFECは非推奨となっており、下位互換性のためにのみ保持されます。 LSPピングの実装が受け入れ、このTLVを処理しますが、明示的に古いTLVを使用するように構成されていない限り、（次のセクションを参照）新しいTLVとLSPピングエコー要求を送信するべきです。"
    },
    {
      "indent": 3,
      "text": "An LSR receiving this TLV SHOULD use the source IP address of the LSP echo request to infer the sender's PE address.",
      "ja": "このTLVを受けたLSRは、送信者のPEアドレスを推測するための要求をエコーLSPの送信元IPアドレスを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.9. FEC 128 Pseudowire (Current)",
      "section_title": true,
      "ja": "3.2.9。 FEC 128スードワイヤ（現在）"
    },
    {
      "indent": 3,
      "text": "FEC 128 (0x80) is defined in [PW-CONTROL], as are the terms PW ID (Pseudowire ID) and PW Type (Pseudowire Type). A PW ID is a non-zero 32-bit connection ID. The PW Type is a 15-bit number indicating the encapsulation type. It is carried right justified in the field below termed encapsulation type with the high-order bit set to zero.",
      "ja": "用語PW ID（疑似回線ID）とPWタイプ（疑似タイプ）であるとしてFEC 128（0x80の）は、[PW-CONTROL]で定義されています。 PW IDは、非ゼロの32ビット接続IDです。 PWタイプのカプセル化タイプを示す15ビットの数です。ゼロ以下に設定し、上位ビットでカプセル化タイプと呼ばれる分野での右寄せ行われます。"
    },
    {
      "indent": 3,
      "text": "Both of these fields are treated in this protocol as opaque values. When matching these field to the local FEC information, the match MUST be exact.",
      "ja": "これらのフィールドの両方が不透明な値として、このプロトコルで処理されます。ローカルFEC情報にこれらのフィールドを照合すると、マッチは正確でなければなりません。"
    },
    {
      "indent": 3,
      "text": "When an FEC 128 is encoded in a label stack, the following format is used. The value field consists of the sender's PE address (the source address of the targeted LDP session), the remote PE address (the destination address of the targeted LDP session), the PW ID, and the encapsulation type as follows:",
      "ja": "FEC 128はラベルスタックに符号化される場合、以下の形式が使用されます。次のように値フィールドは、送信者のPEアドレス（ターゲットLDPセッションの送信元アドレス）、リモートPEアドレス（ターゲットLDPセッションの宛先アドレス）、PW ID、およびカプセル化タイプで構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Sender's PE Address                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Remote PE Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             PW ID                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            PW Type            |          Must Be Zero         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.10. FEC 129 Pseudowire",
      "section_title": true,
      "ja": "3.2.10。 FEC 129スードワイヤ"
    },
    {
      "indent": 3,
      "text": "FEC 129 (0x81) and the terms PW Type, Attachment Group Identifier (AGI), Attachment Group Identifier Type (AGI Type), Attachment Individual Identifier Type (AII Type), Source Attachment Individual Identifier (SAII), and Target Attachment Individual Identifier (TAII) are defined in [PW-CONTROL]. The PW Type is a 15-bit number indicating the encapsulation type. It is carried right justified in the field below PW Type with the high-order bit set to zero. All the other fields are treated as opaque values and copied directly from the FEC 129 format. All of these values together uniquely define the FEC within the scope of the LDP session identified by the source and remote PE addresses.",
      "ja": "FEC 129（0x81と）や用語PWタイプ、アタッチメントグループ識別子（AGI）、アタッチメントグループの識別子タイプ（AGIタイプ）、アタッチメント個別識別子タイプ（AII型）、ソースアタッチメント個別識別子（SAII）、およびターゲット添付ファイルの個別識別子（ TAII）を[PW-CONTROL]で定義されています。 PWタイプのカプセル化タイプを示す15ビットの数です。それはゼロに設定上位ビットとPWタイプの下のフィールドに右詰め運ばれます。他のすべてのフィールドは、不透明な値として扱われ、FEC 129フォーマットから直接コピーされます。一緒に、これらの値の全ては、一意のソース及びリモートPEアドレスによって識別されたLDPセッションの範囲内でFECを定義します。"
    },
    {
      "indent": 3,
      "text": "When an FEC 129 is encoded in a label stack, the following format is used. The Length of this TLV is 16 + AGI length + SAII length + TAII length. Padding is used to make the total length a multiple of 4; the length of the padding is not included in the Length field.",
      "ja": "FEC 129はラベルスタックに符号化される場合、以下の形式が使用されます。このTLVの長さは、16 + AGI長+ SAII長+ TAII長さです。パディングは、全長4の倍数を作製するために使用されます。詰め物の長さは、長さフィールドに含まれていません。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Sender's PE Address                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Remote PE Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            PW Type            |   AGI Type    |  AGI Length   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                           AGI Value                           ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   AII Type    |  SAII Length  |      SAII Value               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                    SAII Value (continued)                     ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   AII Type    |  TAII Length  |      TAII Value               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                    TAII Value (continued)                     ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  TAII (cont.) |  0-3 octets of zero padding                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.11. BGP Labeled IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.11。 BGPはIPv4プレフィックス標識"
    },
    {
      "indent": 3,
      "text": "BGP labeled IPv4 prefixes are defined in [BGP-LABEL]. When a BGP labeled IPv4 prefix is encoded in a label stack, the following format is used. The value field consists the IPv4 prefix (with trailing 0 bits to make 32 bits in all), and the prefix length, as follows:",
      "ja": "BGPは、IPv4プレフィクスが[BGP-LABEL]で定義される標識されました。 BGP標識されたIPv4のプレフィックスがラベルスタックで符号化された場合、以下の形式が使用されます。次のように値フィールドは、（全部で32ビットを作るために0ビットを末尾で）IPv4のプレフィックスを構成され、プレフィックス長："
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 Prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.12. BGP Labeled IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.12。 BGPのIPv6プレフィックス標識"
    },
    {
      "indent": 3,
      "text": "BGP labeled IPv6 prefixes are defined in [BGP-LABEL]. When a BGP labeled IPv6 prefix is encoded in a label stack, the following format is used. The value consists of 16 octets of an IPv6 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv6 prefix is in network byte order; if the prefix is shorter than 128 bits, the trailing bits SHOULD be set to zero.",
      "ja": "BGPは、IPv6プレフィックスを[BGP-LABEL]で定義される標識されました。 BGPラベルされたIPv6プレフィックスがラベルスタックでコード化された場合、以下のフォーマットが使用されています。値は、ビットでプレフィックス長の1つのオクテット続くIPv6プレフィックスの16個のオクテットから成ります。フォーマットは以下のとおりです。 IPv6プレフィックスは、ネットワークバイトオーダです。プレフィックスが128ビットより短い場合、後続のビットがゼロに設定されるべきです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv6 prefix                          |\n|                          (16 octets)                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.13. Generic IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.13。一般的なIPv4のプレフィックス"
    },
    {
      "indent": 3,
      "text": "The value consists of 4 octets of an IPv4 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv4 prefix is in network byte order; if the prefix is shorter than 32 bits, trailing bits SHOULD be set to zero. This FEC is used if the protocol advertising the label is unknown or may change during the course of the LSP. An example is an inter-AS LSP that may be signaled by LDP in one Autonomous System (AS), by RSVP-TE [RSVP-TE] in another AS, and by BGP between the ASes, such as is common for inter-AS VPNs.",
      "ja": "値は、ビットでプレフィックス長の1つのオクテット続いIPv4プレフィクスの4つのオクテットから成ります。フォーマットは以下のとおりです。 IPv4のプレフィックスは、ネットワークバイトオーダです。プレフィックスが32ビットよりも短い場合、末尾のビットはゼロに設定されるべきです。ラベルを広告するプロトコルが不明であるか、LSPの進行中に変更されることがあれば、このFECが使用されます。例は、インターAS一般的であるような、AS間相互AS別のASにRSVP-TE [RSVP-TE]ずつ自律システム（AS）にLDPによってシグナリングすることができるLSP、およびBGPによるものですVPNを。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.14. Generic IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.14。ジェネリックのIPv6プレフィックス"
    },
    {
      "indent": 3,
      "text": "The value consists of 16 octets of an IPv6 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv6 prefix is in network byte order; if the prefix is shorter than 128 bits, the trailing bits SHOULD be set to zero.",
      "ja": "値は、ビットでプレフィックス長の1つのオクテット続くIPv6プレフィックスの16個のオクテットから成ります。フォーマットは以下のとおりです。 IPv6プレフィックスは、ネットワークバイトオーダです。プレフィックスが128ビットより短い場合、後続のビットがゼロに設定されるべきです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv6 prefix                          |\n|                          (16 octets)                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.15. Nil FEC",
      "section_title": true,
      "ja": "3.2.15。何FEC"
    },
    {
      "indent": 3,
      "text": "At times, labels from the reserved range, e.g., Router Alert and Explicit-null, may be added to the label stack for various diagnostic purposes such as influencing load-balancing. These labels may have no explicit FEC associated with them. The Nil FEC Stack is defined to allow a Target FEC Stack sub-TLV to be added to the Target FEC Stack to account for such labels so that proper validation can still be performed.",
      "ja": "時間に、予約された範囲からのラベルは、例えば、ルータ警告および明示的ヌルは、このような負荷バランシングに影響を与えるような様々な診断目的のためにラベルスタックに追加することができます。これらのラベルは、それらに関連付けられている明示的なFECを有していなくてもよいです。無記号FECスタックはターゲットFECスタックサブTLVは、適切な検証が依然として行うことができるように、そのような標識を考慮するために、ターゲットFECスタックに追加できるように定義されます。"
    },
    {
      "indent": 3,
      "text": "The Length is 4. Labels are 20-bit values treated as numbers.",
      "ja": "長さ4のラベルが数値として扱われる20ビット値です。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Label                 |          MBZ          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Label is the actual label value inserted in the label stack; the MBZ fields MUST be zero when sent and ignored on receipt.",
      "ja": "ラベルは、ラベルスタックに挿入された実際のラベル値です。送られて、領収書の上で無視するときMBZフィールドはゼロでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3. Downstream Mapping",
      "section_title": true,
      "ja": "3.3。下流のマッピング"
    },
    {
      "indent": 3,
      "text": "The Downstream Mapping object is a TLV that MAY be included in an echo request message. Only one Downstream Mapping object may appear in an echo request. The presence of a Downstream Mapping object is a request that Downstream Mapping objects be included in the echo reply. If the replying router is the destination of the FEC, then a Downstream Mapping TLV SHOULD NOT be included in the echo reply. Otherwise the replying router SHOULD include a Downstream Mapping object for each interface over which this FEC could be forwarded. For a more precise definition of the notion of \"downstream\", see section 3.3.2, \"Downstream Router and Interface\".",
      "ja": "ダウンストリームマッピングオブジェクトは、エコー要求メッセージに含まれるかもしれTLVです。唯一のダウンストリームマッピングオブジェクトは、エコー要求に表示される場合があります。ダウンストリームマッピングオブジェクトの存在は下流マッピングオブジェクトがエコー応答に含まれる要求です。返答ルータがFECの宛先である場合には、川下のマッピングTLVは、エコー応答に含まれるべきではありません。そうでなければ返答ルータは、このFECを転送することができ、その上、各インターフェイスのダウンストリームマッピングオブジェクトを含むべきです。 「下流」の概念のより正確な定義については、セクション3.3.2、「ダウンストリームルータとインタフェース」を参照してください。"
    },
    {
      "indent": 3,
      "text": "The Length is K + M + 4*N octets, where M is the Multipath Length, and N is the number of Downstream Labels. Values for K are found in the description of Address Type below. The Value field of a Downstream Mapping has the following format:",
      "ja": "長さMはマルチパスの長さK + M + 4 * Nオクテットであり、そしてNは、下流ラベルの数です。 Kの値は、以下のアドレスタイプの記述に記載されています。ダウンストリームマッピングの値フィールドの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               MTU             | Address Type  |    DS Flags   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Downstream IP Address (4 or 16 octets)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Downstream Interface Address (4 or 16 octets)         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Multipath Type| Depth Limit   |        Multipath Length       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                     (Multipath Information)                   .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Downstream Label                |    Protocol   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                                                               .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Downstream Label                |    Protocol   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Maximum Transmission Unit (MTU)",
      "ja": "最大転送単位（MTU）"
    },
    {
      "indent": 6,
      "text": "The MTU is the size in octets of the largest MPLS frame (including label stack) that fits on the interface to the Downstream LSR.",
      "ja": "MTUは、ダウンストリームLSRへのインタフェースに収まる（ラベルスタックを含む）最大のMPLSフレームのオクテットサイズです。"
    },
    {
      "indent": 3,
      "text": "Address Type",
      "ja": "アドレスタイプ"
    },
    {
      "indent": 6,
      "text": "The Address Type indicates if the interface is numbered or unnumbered. It also determines the length of the Downstream IP Address and Downstream Interface fields. The resulting total for the initial part of the TLV is listed in the table below as \"K Octets\". The Address Type is set to one of the following values:",
      "ja": "インターフェースは、番号または番号なしの場合はアドレスタイプを示します。また、ダウンストリームIPアドレスとダウンストリームインターフェイスフィールドの長さを決定します。 TLVの最初の部分のために得られた合計「Kオクテット」として以下の表に記載されています。アドレスタイプは、次のいずれかの値に設定されています："
    },
    {
      "indent": 9,
      "text": "Type #        Address Type           K Octets\n------        ------------           --------\n     1        IPv4 Numbered                16\n     2        IPv4 Unnumbered              16\n     3        IPv6 Numbered                40\n     4        IPv6 Unnumbered              28",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DS Flags",
      "ja": "DSフラグ"
    },
    {
      "indent": 6,
      "text": "The DS Flags field is a bit vector with the following format:",
      "ja": "DSのFlagsフィールドは、次の形式のビットベクトルであります："
    },
    {
      "indent": 9,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n| Rsvd(MBZ) |I|N|\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Two flags are defined currently, I and N. The remaining flags MUST be set to zero when sending and ignored on receipt.",
      "ja": "二つのフラグが現在定義され、IおよびN.残りのフラグは、送信時にゼロに設定して、領収書の上で無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Flag  Name and Meaning\n----  ----------------",
      "raw": true
    },
    {
      "indent": 9,
      "text": "I Interface and Label Stack Object Request",
      "ja": "Iインタフェースとラベルスタックオブジェクト・リクエスト"
    },
    {
      "indent": 12,
      "text": "When this flag is set, it indicates that the replying router SHOULD include an Interface and Label Stack Object in the echo reply message.",
      "ja": "このフラグが設定されている場合は、返答ルータは、エコー応答メッセージのインタフェースとラベルスタックオブジェクトを含めるべきであることを示しています。"
    },
    {
      "indent": 9,
      "text": "N Treat as a Non-IP Packet",
      "ja": "N非IPパケットとして扱います"
    },
    {
      "indent": 12,
      "text": "Echo request messages will be used to diagnose non-IP flows. However, these messages are carried in IP packets. For a router that alters its ECMP algorithm based on the FEC or deep packet examination, this flag requests that the router treat this as it would if the determination of an IP payload had failed.",
      "ja": "エコー要求メッセージは、非IPフローを診断するために使用されます。しかし、これらのメッセージは、IPパケットで運ばれます。 、FECまたはディープパケット検査に基づいてIPペイロードの決意が失敗した場合、ルータはそれと同じように、これを扱うこのフラグ要求をそのECMPアルゴリズムを変更ルータの。"
    },
    {
      "indent": 3,
      "text": "Downstream IP Address and Downstream Interface Address",
      "ja": "下流のIPアドレスと下流のインターフェイスアドレス"
    },
    {
      "indent": 6,
      "text": "IPv4 addresses and interface indices are encoded in 4 octets; IPv6 addresses are encoded in 16 octets.",
      "ja": "IPv4アドレスとインターフェイスインデックスが4つのオクテットで符号化されます。 IPv6アドレスは16個のオクテットでエンコードされています。"
    },
    {
      "indent": 6,
      "text": "If the interface to the downstream LSR is numbered, then the Address Type MUST be set to IPv4 or IPv6, the Downstream IP Address MUST be set to either the downstream LSR's Router ID or the interface address of the downstream LSR, and the Downstream Interface Address MUST be set to the downstream LSR's interface address.",
      "ja": "下流のLSRへのインタフェースが番号付けされている場合は、アドレスタイプはIPv4またはIPv6に設定しなければならなくて、ダウンストリームIPアドレスは、ダウンストリームLSRのルータIDまたは下流のLSRのインターフェースアドレス、およびダウンストリームインターフェイスアドレスのどちらかに設定しなければなりません。下流のLSRのインターフェースアドレスに設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "If the interface to the downstream LSR is unnumbered, the Address Type MUST be IPv4 Unnumbered or IPv6 Unnumbered, the Downstream IP Address MUST be the downstream LSR's Router ID, and the Downstream Interface Address MUST be set to the index assigned by the upstream LSR to the interface.",
      "ja": "ダウンストリームLSRへのインターフェースに番号が付いていない場合、アドレスタイプは、IPv4アンナンバードまたはIPv6番号なしで、ダウンストリームIPアドレスは、下流LSRのルータIDでなければなりません、そしてダウンストリームインターフェイスアドレスは上流のLSRによって割り当てられたインデックスに設定しなければなりませんインタフェース。"
    },
    {
      "indent": 6,
      "text": "If an LSR does not know the IP address of its neighbor, then it MUST set the Address Type to either IPv4 Unnumbered or IPv6 Unnumbered. For IPv4, it must set the Downstream IP Address to 127.0.0.1; for IPv6 the address is set to 0::1. In both cases, the interface index MUST be set to 0. If an LSR receives an Echo Request packet with either of these addresses in the Downstream IP Address field, this indicates that it MUST bypass interface verification but continue with label validation.",
      "ja": "LSRがネイバーのIPアドレスを知らない場合、それは、IPv4またはIPv6アンナンバードアンナンバードのいずれかにアドレスタイプを設定しなければなりません。 IPv4の場合、それは127.0.0.1へのダウンストリームIPアドレスを設定する必要があります。 IPv6のアドレスは0 :: 1に設定されています。 LSRは川下IP Addressフィールドに、これらのアドレスのいずれかでエコー要求パケットを受信した場合、両方のケースでは、インターフェイス・インデックスは、0に設定しなければならない、これはインタフェースの検証をバイパスするが、ラベルの検証を継続しなければならないことを示しています。"
    },
    {
      "indent": 6,
      "text": "If the originator of an Echo Request packet wishes to obtain Downstream Mapping information but does not know the expected label stack, then it SHOULD set the Address Type to either IPv4 Unnumbered or IPv6 Unnumbered. For IPv4, it MUST set the Downstream IP Address to 224.0.0.2; for IPv6 the address MUST be set to FF02::2. In both cases, the interface index MUST be set to 0. If an LSR receives an Echo Request packet with the all-routers multicast address, then this indicates that it MUST bypass both interface and label stack validation, but return Downstream Mapping TLVs using the information provided.",
      "ja": "エコー要求パケットの発信元は、ダウンストリームのマッピング情報を取得したいが、予想されるラベルスタックを知らない場合、それは、IPv4またはIPv6アンナンバードアンナンバードのいずれかにアドレスタイプを設定する必要があります。 IPv4の場合、それは224.0.0.2へのダウンストリームIPアドレスを設定しなければなりません。 IPv6のアドレスはFF02 :: 2に設定しなければなりません。 LSRは、全ルータのマルチキャストアドレスにエコー要求パケットを受信した場合の両方の場合において、インターフェースインデックスを0に設定しなければならない、これは、それがインタフェースとラベルスタックの検証の両方を回避するが、使用するダウンストリームマッピングTLVを返さなければならないことを示しています情報提供。"
    },
    {
      "indent": 3,
      "text": "Multipath Type",
      "ja": "マルチタイプ"
    },
    {
      "indent": 6,
      "text": "The following Multipath Types are defined:",
      "ja": "以下のマルチパスの種類が定義されています。"
    },
    {
      "indent": 6,
      "text": "Key   Type                  Multipath Information\n---   ----------------      ---------------------\n 0    no multipath          Empty (Multipath Length = 0)\n 2    IP address            IP addresses\n 4    IP address range      low/high address pairs\n 8    Bit-masked IP         IP address prefix and bit mask\n        address set\n 9    Bit-masked label set  Label prefix and bit mask",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 0 indicates that all packets will be forwarded out this one interface.",
      "ja": "タイプ0は、すべてのパケットはこの1つのインターフェイスから転送されることを示します。"
    },
    {
      "indent": 6,
      "text": "Types 2, 4, 8, and 9 specify that the supplied Multipath Information will serve to exercise this path.",
      "ja": "タイプ2、4、8、および9は、供給マルチパスの情報は、このパスを行使するのに役立つであろうことを指定します。"
    },
    {
      "indent": 3,
      "text": "Depth Limit",
      "ja": "深さの制限"
    },
    {
      "indent": 6,
      "text": "The Depth Limit is applicable only to a label stack and is the maximum number of labels considered in the hash; this SHOULD be set to zero if unspecified or unlimited.",
      "ja": "深さ制限はラベルスタックに適用可能であり、ハッシュで考慮ラベルの最大数です。未指定または無制限の場合、これはゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Multipath Length",
      "ja": "マルチパスの長さ"
    },
    {
      "indent": 6,
      "text": "The length in octets of the Multipath Information.",
      "ja": "マルチパス情報のオクテットの長さ。"
    },
    {
      "indent": 3,
      "text": "Multipath Information",
      "ja": "マルチインフォメーション"
    },
    {
      "indent": 6,
      "text": "Address or label values encoded according to the Multipath Type. See the next section below for encoding details.",
      "ja": "マルチパスの種類に応じてエンコードされたアドレスまたはラベルの値。エンコードの詳細については、次のセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Downstream Label(s)",
      "ja": "下流ラベル（S）"
    },
    {
      "indent": 6,
      "text": "The set of labels in the label stack as it would have appeared if this router were forwarding the packet through this interface. Any Implicit Null labels are explicitly included. Labels are treated as numbers, i.e., they are right justified in the field.",
      "ja": "このルータは、このインターフェイスを介してパケットを転送した場合、それは登場していたとして、ラベルスタックのラベルのセット。暗黙的ヌルラベルは、明示的に含まれています。ラベルはつまり、彼らはフィールドで右詰めされ、数値として扱われます。"
    },
    {
      "indent": 6,
      "text": "A Downstream Label is 24 bits, in the same format as an MPLS label minus the TTL field, i.e., the MSBit of the label is bit 0, the LSBit is bit 19, the EXP bits are bits 20-22, and bit 23 is the S bit. The replying router SHOULD fill in the EXP and S bits; the LSR receiving the echo reply MAY choose to ignore these bits.",
      "ja": "ダウンストリームラベルは、MPLSラベルマイナスTTLフィールドと同じ形式で、すなわち、ラベルのMSBitからビット0であり、最下位ビットはビット19であり、24ビットであり、EXPビットは、ビット20〜22であり、23ビットでありますSビット。返答ルータはEXPとSビットを記入すべきです。エコー応答を受信LSRはこれらのビットを無視することを選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "Protocol",
      "ja": "プロトコル"
    },
    {
      "indent": 6,
      "text": "The Protocol is taken from the following table:",
      "ja": "プロトコルは、以下の表から取得されます："
    },
    {
      "indent": 6,
      "text": "Protocol #        Signaling Protocol\n----------        ------------------\n         0        Unknown\n         1        Static\n         2        BGP\n         3        LDP\n         4        RSVP-TE",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3.1. Multipath Information Encoding",
      "section_title": true,
      "ja": "3.3.1。マルチパス情報のエンコーディング"
    },
    {
      "indent": 3,
      "text": "The Multipath Information encodes labels or addresses that will exercise this path. The Multipath Information depends on the Multipath Type. The contents of the field are shown in the table above. IPv4 addresses are drawn from the range 127/8; IPv6 addresses are drawn from the range 0:0:0:0:0:FFFF:127/104. Labels are treated as numbers, i.e., they are right justified in the field. For Type 4, ranges indicated by Address pairs MUST NOT overlap and MUST be in ascending sequence.",
      "ja": "マルチパス情報は、このパスを行使するラベルやアドレスを符号化します。マルチパス情報は、マルチパスの種類に依存します。フィールドの内容は、上記の表に示されています。 IPv4アドレスは、範囲8分の127から引き出されます。 0：0：0：0：FFFF：104分の127 IPv6アドレスは範囲0から描かれています。ラベルはつまり、彼らはフィールドで右詰めされ、数値として扱われます。タイプ4のために、アドレスのペアで示される範囲が重複してはならないと昇順でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Type 8 allows a more dense encoding of IP addresses. The IP prefix is formatted as a base IP address with the non-prefix low-order bits set to zero. The maximum prefix length is 27. Following the prefix is a mask of length 2^(32-prefix length) bits for IPv4 and 2^(128- prefix length) bits for IPv6. Each bit set to 1 represents a valid address. The address is the base IPv4 address plus the position of the bit in the mask where the bits are numbered left to right beginning with zero. For example, the IPv4 addresses 127.2.1.0, 127.2.1.5-127.2.1.15, and 127.2.1.20-127.2.1.29 would be encoded as follows:",
      "ja": "タイプ8は、IPアドレスのより密なエンコーディングを可能にします。 IPプレフィックスはゼロに設定非接頭下位ビットとベースIPアドレスとしてフォーマットされます。最大プレフィックス長は、プレフィックスの後に27の長さ2 ^（32プレフィックス長）のマスクIPv4用ビットとIPv6の2 ^（128プレフィックス長）ビットです。 1に設定された各ビットは、有効なアドレスを表します。アドレスは、ベースのIPv4アドレスとビットはゼロから始まり右に左番号付けされたマスク内のビットの位置です。例えば、IPv4が127.2.1.0、127.2.1.5-127.2.1.15に対処し、そして次のように127.2.1.20-127.2.1.29は、符号化されるであろう。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 1 1 1 1 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Those same addresses embedded in IPv6 would be encoded as follows:",
      "ja": "次のようにIPv6の中に埋め込まれたものと同じアドレスをエンコードすることになります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 1 1 1 1 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Type 9 allows a more dense encoding of labels. The label prefix is formatted as a base label value with the non-prefix low-order bits set to zero. The maximum prefix (including leading zeros due to encoding) length is 27. Following the prefix is a mask of length 2^(32-prefix length) bits. Each bit set to one represents a valid label. The label is the base label plus the position of the bit in the mask where the bits are numbered left to right beginning with zero. Label values of all the odd numbers between 1152 and 1279 would be encoded as follows:",
      "ja": "タイプ9は、ラベルのより密なエンコーディングを可能にします。ラベルプレフィックスはゼロに設定非接頭下位ビットとベースラベル値としてフォーマットされます。長さは、プレフィックスの後に27である（符号化による先行ゼロを含む）の最大プレフィックス長2 ^（32プレフィックス長）ビットのマスクです。 1に設定された各ビットは、有効なラベルを表します。ラベルは、ベースラベルプラスビットはゼロから始まる左から右に番号付けされたマスク内のビットの位置です。次のように1152と1279の間の全ての奇数番号のラベル値は、符号化されるであろう。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0| +-+-+-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 1 0 1\n0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1| +-+-+-+-+-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 1 0 1 0 1\n0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1| +-+-+-+-+-+-+-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 1 0 1 0 1 0 1\n0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1| +-+-+-+-+-+-+-+-+-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 1 0 1 0 1 0 1 0 1\n0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1| +-+-+-+-+-+-+-+-+-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the received Multipath Information is non-null, the labels and IP addresses MUST be picked from the set provided. If none of these labels or addresses map to a particular downstream interface, then for that interface, the type MUST be set to 0. If the received Multipath Information is null (i.e., Multipath Length = 0, or for Types 8 and 9, a mask of all zeros), the type MUST be set to 0.",
      "ja": "受信マルチパス情報が非nullの場合、ラベルとIPアドレスが提供集合から選ばれなければなりません。これらのラベルまたはアドレスのいずれも、特定のダウンストリームインタフェースにマップしない場合は受信したマルチパス情報（すなわち、マルチパス長= 0、またはタイプ8と9のためにnullである場合、そのインターフェイスのために、タイプ0に設定しなければなりません、Aすべてゼロのマスク）、タイプが0に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, suppose LSR X at hop 10 has two downstream LSRs, Y and Z, for the FEC in question. The received X could return Multipath Type 4, with low/high IP addresses of 127.1.1.1->127.1.1.255 for downstream LSR Y and 127.2.1.1->127.2.1.255 for downstream LSR Z. The head end reflects this information to LSR Y. Y, which has three downstream LSRs, U, V, and W, computes that 127.1.1.1->127.1.1.127 would go to U and 127.1.1.128-> 127.1.1.255 would go to V. Y would then respond with 3 Downstream Mappings: to U, with Multipath Type 4 (127.1.1.1->127.1.1.127); to V, with Multipath Type 4 (127.1.1.127->127.1.1.255); and to W, with Multipath Type 0.",
      "ja": "例えば、ホップ10におけるLSR Xが問題のFECのための2つの下流のLSR、Y及びZを、有していると仮定する。受信されたXは、ヘッドエンドは、LSRにこの情報を反映下流LSR Y用127.1.1.1-> 127.1.1.255と下流LSRのZ.ため127.2.1.1-> 127.2.1.255の低/高IPアドレスと、マルチパスタイプ4を返すことができ3つの下流のLSR、U、V、およびWを持っているY. Yは、127.1.1.1-> 127.1.1.127がUに行くだろうと> 127.1.1.255 127.1.1.128-がV. Yに行くだろうと計算して、その後に応答することになります3つのダウンストリームマッピング：Uに、マルチタイプ4（> 127.1.1.127 127.1.1.1-）を有します。 Vに、マルチパスタイプ4（127.1.1.127-> 127.1.1.255）を有します。そしてマルチパスタイプ0とWへ。"
    },
    {
      "indent": 3,
      "text": "Note that computing Multipath Information may impose a significant processing burden on the receiver. A receiver MAY thus choose to process a subset of the received prefixes. The sender, on receiving a reply to a Downstream Mapping with partial information, SHOULD assume that the prefixes missing in the reply were skipped by the receiver, and MAY re-request information about them in a new echo request.",
      "ja": "マルチパス情報を計算すると、受信機にかなりの処理負担を課すことに注意してください。受信機は、受信したプレフィックスのサブセットを処理するために選ぶかもしれ。送信者は、部分的な情報と川下のマッピングへの応答を受信すると、返信に欠けているプレフィックスが受信機によってスキップされたと仮定しなければならず、新しいエコー要求でそれらの情報要求を再MAY。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Downstream Router and Interface",
      "section_title": true,
      "ja": "3.3.2。ダウンストリームルータとのインターフェイス"
    },
    {
      "indent": 3,
      "text": "The notion of \"downstream router\" and \"downstream interface\" should be explained. Consider an LSR X. If a packet that was originated with TTL n>1 arrived with outermost label L and TTL=1 at LSR X, X must be able to compute which LSRs could receive the packet if it was originated with TTL=n+1, over which interface the request would arrive and what label stack those LSRs would see. (It is outside the scope of this document to specify how this computation is done.) The set of these LSRs/interfaces consists of the downstream routers/interfaces (and their corresponding labels) for X with respect to L. Each pair of downstream router and interface requires a separate Downstream Mapping to be added to the reply.",
      "ja": "「下流ルータ」と「下流インターフェース」の概念を説明する必要があります。 TTLで発信されたパケットN> 1 LSR Xに最も外側のラベルLとTTL = 1で到着した場合、XはそれがTTL = N +で発信された場合、パケットを受信できたのLSRを計算することができなければならないLSR Xを考えます1は、そのインタフェースを介して要求が到着し、どのようなラベルは、それらのLSRが見るであろうスタックでしょう。 （なお、この計算がどのように行われるかを指定するには、この文書の範囲外である。）これらのLSR /インターフェースのセットが下流ルータ/インターフェース（およびそれらの対応するラベル）で構成L.に対するXのための下流のルータの各対インターフェースは、応答に追加する別のダウンストリームマッピングを必要とします。"
    },
    {
      "indent": 3,
      "text": "The case where X is the LSR originating the echo request is a special case. X needs to figure out what LSRs would receive the MPLS echo request for a given FEC Stack that X originates with TTL=1.",
      "ja": "Xは、エコー要求を発信するLSRである場合は特殊なケースです。 Xは、のLSRは、Xは、TTL = 1で発信することを考えるとFECスタックのためのMPLSエコー要求を受け取ることになるかを把握する必要があります。"
    },
    {
      "indent": 3,
      "text": "The set of downstream routers at X may be alternative paths (see the discussion below on ECMP) or simultaneous paths (e.g., for MPLS multicast). In the former case, the Multipath Information is used as a hint to the sender as to how it may influence the choice of these alternatives.",
      "ja": "Xにおける下流ルータのセットは、代替パス（ECMP上の以下の説明を参照）または同時パス（例えば、MPLSのマルチキャストのための）であってもよいです。前者の場合には、マルチパスの情報は、として、それはこれらの選択肢の選択に影響を与えることがどのように送信者へのヒントとして使用されています。"
    },
    {
      "indent": 0,
      "text": "3.4. Pad TLV",
      "section_title": true,
      "ja": "3.4。パッドTLV"
    },
    {
      "indent": 3,
      "text": "The value part of the Pad TLV contains a variable number (>= 1) of octets. The first octet takes values from the following table; all the other octets (if any) are ignored. The receiver SHOULD verify that the TLV is received in its entirety, but otherwise ignores the contents of this TLV, apart from the first octet.",
      "ja": "パッドTLVの値の一部は、オクテットの可変数（> = 1）を含みます。最初のオクテットは、次の表の値をとります。他のすべてのオクテット（もしあれば）は無視されます。受信機は、TLVは、その全体が受信されていることを確認し、それ以外離れ最初のオクテットから、このTLVの内容を無視すべきです。"
    },
    {
      "indent": 6,
      "text": "Value        Meaning\n-----        -------\n    1        Drop Pad TLV from reply\n    2        Copy Pad TLV to reply\n3-255        Reserved for future use",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.5. Vendor Enterprise Number",
      "section_title": true,
      "ja": "3.5。ベンダー企業数"
    },
    {
      "indent": 3,
      "text": "SMI Private Enterprise Numbers are maintained by IANA. The Length is always 4; the value is the SMI Private Enterprise code, in network octet order, of the vendor with a Vendor Private extension to any of the fields in the fixed part of the message, in which case this TLV MUST be present. If none of the fields in the fixed part of the message have Vendor Private extensions, inclusion of this TLV is OPTIONAL. Vendor Private ranges for Message Types, Reply Modes, and Return Codes have been defined. When any of these are used, the Vendor Enterprise Number TLV MUST be included in the message.",
      "ja": "SMIプライベートエンタープライズ番号はIANAによって維持されています。長さは常に4です。値は、このTLVが存在しなければならない場合には、メッセージの固定部分のフィールドのいずれかにベンダープライベート拡張を持つベンダーのネットワークオクテット順に、SMIプライベート企業コードです。メッセージの固定部分のフィールドのいずれもベンダー専用の拡張機能を持っていない場合は、このTLVを含めることは任意です。メッセージタイプのベンダーのプライベート範囲、モードを返信し、リターンコードが定義されています。これらのいずれかが使用される場合、ベンダー企業の数TLVは、メッセージに含まれなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.6. Interface and Label Stack",
      "section_title": true,
      "ja": "3.6。インタフェースとラベルスタック"
    },
    {
      "indent": 3,
      "text": "The Interface and Label Stack TLV MAY be included in a reply message to report the interface on which the request message was received and the label stack that was on the packet when it was received. Only one such object may appear. The purpose of the object is to allow the upstream router to obtain the exact interface and label stack information as it appears at the replying LSR.",
      "ja": "インターフェイスおよびラベルスタックTLVは、要求メッセージを受信したインターフェイスと、それを受信した際のパケットにあったラベルスタックを報告する応答メッセージに含まれるかもしれません。唯一のそのようなオブジェクトが表示されることがあります。オブジェクトの目的は、それが返信するのLSRで表示される上流のルータが正確なインターフェースとラベルスタック情報を取得できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "The Length is K + 4*N octets; N is the number of labels in the label stack. Values for K are found in the description of Address Type below. The Value field of a Downstream Mapping has the following format:",
      "ja": "長さK + 4 * Nオクテットです。 Nは、ラベルスタックのラベルの数です。 Kの値は、以下のアドレスタイプの記述に記載されています。ダウンストリームマッピングの値フィールドの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Address Type  |             Must Be Zero                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   IP Address (4 or 16 octets)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   Interface (4 or 16 octets)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                                                               .\n.                          Label Stack                          .\n.                                                               .\n.                                                               .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Address Type",
      "ja": "アドレスタイプ"
    },
    {
      "indent": 6,
      "text": "The Address Type indicates if the interface is numbered or unnumbered. It also determines the length of the IP Address and Interface fields. The resulting total for the initial part of the TLV is listed in the table below as \"K Octets\". The Address Type is set to one of the following values:",
      "ja": "インターフェースは、番号または番号なしの場合はアドレスタイプを示します。また、IPアドレスとインターフェイスフィールドの長さを決定します。 TLVの最初の部分のために得られた合計「Kオクテット」として以下の表に記載されています。アドレスタイプは、次のいずれかの値に設定されています："
    },
    {
      "indent": 9,
      "text": "Type #        Address Type           K Octets\n------        ------------           --------\n     1        IPv4 Numbered                12\n     2        IPv4 Unnumbered              12\n     3        IPv6 Numbered                36\n     4        IPv6 Unnumbered              24",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IP Address and Interface",
      "ja": "IPアドレスとインターフェイス"
    },
    {
      "indent": 6,
      "text": "IPv4 addresses and interface indices are encoded in 4 octets; IPv6 addresses are encoded in 16 octets.",
      "ja": "IPv4アドレスとインターフェイスインデックスが4つのオクテットで符号化されます。 IPv6アドレスは16個のオクテットでエンコードされています。"
    },
    {
      "indent": 6,
      "text": "If the interface upon which the echo request message was received is numbered, then the Address Type MUST be set to IPv4 or IPv6, the IP Address MUST be set to either the LSR's Router ID or the interface address, and the Interface MUST be set to the interface address.",
      "ja": "エコー要求メッセージを受信した時にインターフェースが番号付けされた場合、アドレスタイプがIPv4またはIPv6に設定しなければなりません、IPアドレスは、LSRのルータIDまたはインターフェイスアドレスのいずれかに設定しなければなりません、そしてインタフェースに設定しなければなりませんインターフェイスアドレス。"
    },
    {
      "indent": 6,
      "text": "If the interface is unnumbered, the Address Type MUST be either IPv4 Unnumbered or IPv6 Unnumbered, the IP Address MUST be the LSR's Router ID, and the Interface MUST be set to the index assigned to the interface.",
      "ja": "インターフェースに番号が付いていない場合、アドレスタイプは、IPv4またはIPv6アンナンバード番号なしのいずれかでなければならない、IPアドレスはLSRのルータIDでなければならない、とのインターフェイスは、インターフェイスに割り当てられたインデックスに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Label Stack",
      "ja": "ラベルスタック"
    },
    {
      "indent": 6,
      "text": "The label stack of the received echo request message. If any TTL values have been changed by this router, they SHOULD be restored.",
      "ja": "受信されたエコー要求メッセージのラベルスタック。任意のTTL値はこのルータによって変更された場合は、それらを復元する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.7. Errored TLVs",
      "section_title": true,
      "ja": "3.7。エラー状態のTLV"
    },
    {
      "indent": 3,
      "text": "The following TLV is a TLV that MAY be included in an echo reply to inform the sender of an echo request of mandatory TLVs either not supported by an implementation or parsed and found to be in error.",
      "ja": "次のTLVは必須のTLV実装によってサポートまたは解析され、エラーであることが見出されていないいずれかのエコー要求の送信者に通知するために、エコー応答に含まれてもよいことTLVです。"
    },
    {
      "indent": 3,
      "text": "The Value field contains the TLVs that were not understood, encoded as sub-TLVs.",
      "ja": "Valueフィールドは、理解サブのTLVとして符号化されなかったTLVを含んでいます。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type = 9          |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Value                             |\n.                                                               .\n.                                                               .\n.                                                               .\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.8. Reply TOS Byte TLV",
      "section_title": true,
      "ja": "3.8。 TOSバイトTLV返信"
    },
    {
      "indent": 3,
      "text": "This TLV MAY be used by the originator of the echo request to request that an echo reply be sent with the IP header TOS byte set to the value specified in the TLV. This TLV has a length of 4 with the following value field.",
      "ja": "このTLVは、エコー応答がTLVで指定された値に設定されたIPヘッダのTOSバイトで送信されることを要求するために、エコー要求の発信者によって使用されてもよいです。このTLVは、次の値フィールドを持つ4の長さを有しています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Reply-TOS Byte|                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4. Theory of Operation",
      "section_title": true,
      "ja": "操作の4論"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request is used to test a particular LSP. The LSP to be tested is identified by the \"FEC Stack\"; for example, if the LSP was set up via LDP, and is to an egress IP address of 10.1.1.1, the FEC Stack contains a single element, namely, an LDP IPv4 prefix sub-TLV with value 10.1.1.1/32. If the LSP being tested is an RSVP LSP, the FEC Stack consists of a single element that captures the RSVP Session and Sender Template that uniquely identifies the LSP.",
      "ja": "MPLSエコー要求は、特定のLSPをテストするために使用されます。 LSPは、「FECスタック」によって識別されるテストされます。 LSPは、LDPを介して設定、及び10.1.1.1の出口IPアドレスにあるれた場合、例えば、FECスタックは、単一の要素、値10.1.1.1/32有する即ち、LDP IPv4プレフィクスのサブTLVが含まれています。試験されるLSPは、RSVPのLSPである場合、FECスタック一意LSPを識別RSVPセッションおよび送信者テンプレートをキャプチャ単一の要素から構成されています。"
    },
    {
      "indent": 3,
      "text": "FEC Stacks can be more complex. For example, one may wish to test a VPN IPv4 prefix of 10.1/8 that is tunneled over an LDP LSP with egress 10.10.1.1. The FEC Stack would then contain two sub-TLVs, the bottom being a VPN IPv4 prefix, and the top being an LDP IPv4 prefix. If the underlying (LDP) tunnel were not known, or was considered irrelevant, the FEC Stack could be a single element with just the VPN IPv4 sub-TLV.",
      "ja": "FECスタックは、より複雑になることがあります。例えば、一方が出口10.10.1.1とLDP LSP上にトンネリングさ10.1 / 8のVPN IPv4プレフィクスをテストすることを望むかもしれません。 FECスタックは、2つのサブTLVを、VPN IPv4プレフィクスである底部、およびLDP IPv4のプレフィックスである上面を含むであろう。基礎となる（LDP）トンネルが知られていなかった、または無関係と考えられた場合、FECスタックだけVPNのIPv4サブTLVを持つ単一の要素であってもよいです。"
    },
    {
      "indent": 3,
      "text": "When an MPLS echo request is received, the receiver is expected to verify that the control plane and data plane are both healthy (for the FEC Stack being pinged) and that the two planes are in sync. The procedures for this are in section 4.4 below.",
      "ja": "MPLSエコー要求を受信した場合、受信機は、制御プレーンとデータプレーンは、健康（FECスタックはpingされているため）および2つの面が同期していることの両方であることを確認することが期待されます。このための手順は、以下のセクション4.4です。"
    },
    {
      "indent": 0,
      "text": "4.1. Dealing with Equal-Cost Multi-Path (ECMP)",
      "section_title": true,
      "ja": "4.1。等価コストマルチパス（ECMP）への対応"
    },
    {
      "indent": 3,
      "text": "LSPs need not be simple point-to-point tunnels. Frequently, a single LSP may originate at several ingresses, and terminate at several egresses; this is very common with LDP LSPs. LSPs for a given FEC may also have multiple \"next hops\" at transit LSRs. At an ingress, there may also be several different LSPs to choose from to get to the desired endpoint. Finally, LSPs may have backup paths, detour paths, and other alternative paths to take should the primary LSP go down.",
      "ja": "LSPは、単純なポイントツーポイントトンネルである必要はありません。しばしば、単一のLSPは、いくつかのingressesに属し、そしていくつかのegressesで終端してもよいです。これは自民党のLSPと非常に一般的です。与えられたFECのためのLSPはまた、トランジットのLSRに複数の「次のホップ」を有していてもよいです。入口で、また、所望の終点に到達するために中から選択するために、いくつかの異なったLSPがあるかもしれません。最後に、LSPは主LSPがダウンした取るために、バックアップパス、迂回パス、およびその他の代替経路を有することができます。"
    },
    {
      "indent": 3,
      "text": "To deal with the last two first: it is assumed that the LSR sourcing MPLS echo requests can force the echo request into any desired LSP, so choosing among multiple LSPs at the ingress is not an issue. The problem of probing the various flavors of backup paths that will typically not be used for forwarding data unless the primary LSP is down will not be addressed here.",
      "ja": "最後の二つの最初に対処するために：そう進入で複数のLSPの中から選択、LSRソーシングMPLSエコー要求は、任意の所望のLSPにエコー要求を強制することができることが想定されることは問題ではありません。主LSPがダウンしている場合を除き、通常の転送データのために使用されることはありませんバックアップパスのさまざまな味をプロービングの問題はここで扱われることはありません。"
    },
    {
      "indent": 3,
      "text": "Since the actual LSP and path that a given packet may take may not be known a priori, it is useful if MPLS echo requests can exercise all possible paths. This, although desirable, may not be practical, because the algorithms that a given LSR uses to distribute packets over alternative paths may be proprietary.",
      "ja": "与えられたパケットがかかる場合があり、実際のLSPとパスが事前に知られないかもしれないので、MPLSエコー要求は、すべての可能なパスを行使することができれば、それは便利です。与えられたLSRは、代替パス上でパケットを配信するために使用するアルゴリズムはプロプライエタリであってもよいので、これは、望ましいが、実用的ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "To achieve some degree of coverage of alternate paths, there is a certain latitude in choosing the destination IP address and source",
      "ja": "代替パスのカバレッジをある程度達成するために、特定の緯度は、宛先IPアドレスと送信元の選択にあります"
    },
    {
      "indent": 3,
      "text": "UDP port for an MPLS echo request. This is clearly not sufficient; in the case of traceroute, more latitude is offered by means of the Multipath Information of the Downstream Mapping TLV. This is used as follows. An ingress LSR periodically sends an MPLS traceroute message to determine whether there are multipaths for a given LSP. If so, each hop will provide some information how each of its downstream paths can be exercised. The ingress can then send MPLS echo requests that exercise these paths. If several transit LSRs have ECMP, the ingress may attempt to compose these to exercise all possible paths. However, full coverage may not be possible.",
      "ja": "MPLSエコー要求のためのUDPポート。これは明らかに十分ではありません。トレースルートの場合には、より多くの緯度下流マッピングTLVのマルチパス情報を用いて提供されます。これは次のように使用されています。入口LSRは、定期的に与えられたLSPのためにマルチパスが存在するかどうかを決定するためにMPLSのトレースルート・メッセージを送信します。その場合、各ホップは、その下流経路の各々を行使することができる方法をいくつかの情報を提供するであろう。イングレスは、これらのパスを行使MPLSエコー要求を送信することができます。いくつかのトランジットのLSRは、ECMPを持っている場合は、侵入が可能なすべてのパスを行使するためにこれらを構成しようとすることができます。しかし、完全にカバーできない場合があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Testing LSPs That Are Used to Carry MPLS Payloads",
      "section_title": true,
      "ja": "4.2。 MPLSペイロードを運ぶために使用されているLSPをテスト"
    },
    {
      "indent": 3,
      "text": "To detect certain LSP breakages, it may be necessary to encapsulate an MPLS echo request packet with at least one additional label when testing LSPs that are used to carry MPLS payloads (such as LSPs used to carry L2VPN and L3VPN traffic. For example, when testing LDP or RSVP-TE LSPs, just sending an MPLS echo request packet may not detect instances where the router immediately upstream of the destination of the LSP ping may forward the MPLS echo request successfully over an interface not configured to carry MPLS payloads because of the use of penultimate hop popping. Since the receiving router has no means to differentiate whether the IP packet was sent unlabeled or implicitly labeled, the addition of labels shimmed above the MPLS echo request (using the Nil FEC) will prevent a router from forwarding such a packet out unlabeled interfaces.",
      "ja": "特定のLSPの破損を検出するために、そのようなL2VPNとL3VPNトラフィックを運ぶために使用されるのLSPとしてMPLSペイロードを（運ぶために使用されるLSPをテストするときに少なくとも一つの追加のラベルとMPLSエコー要求パケットをカプセル化する必要があるかもしれない。例えば、試験LDPまたはRSVP-TE LSPを、直ちにLSPピングの先のアップストリームルータが原因使用のMPLSペイロードを運ぶように構成されていないインタフェースを介して正常にMPLSにエコー要求を転送することができる場合だけでMPLSエコー要求パケットを送信するインスタンスを検出しないかもしれませんポッピング最後から二番目のホップの受信ルータは、IPパケットが標識されていない送信または暗黙的に標識されたかどうかを区別するための手段を持たないので、（NIL FECを使用して）MPLSエコー要求上方シム標識の添加は、このようなパケットを転送からルータを防止します非標識インターフェイスアウト。"
    },
    {
      "indent": 0,
      "text": "4.3. Sending an MPLS Echo Request",
      "section_title": true,
      "ja": "4.3。 MPLSエコー要求を送信します"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request is a UDP packet. The IP header is set as follows: the source IP address is a routable address of the sender; the destination IP address is a (randomly chosen) IPv4 address from the range 127/8 or IPv6 address from the range 0:0:0:0:0:FFFF:127/104. The IP TTL is set to 1. The source UDP port is chosen by the sender; the destination UDP port is set to 3503 (assigned by IANA for MPLS echo requests). The Router Alert option MUST be set in the IP header.",
      "ja": "MPLSエコー要求は、UDPパケットです。次のようにIPヘッダが設定されている：送信元IPアドレスは、送信者のルーティング可能なアドレスです。 0：0：0：0：FFFF：104分の127の宛先IPアドレスは、範囲0〜8分の127またはIPv6アドレスからの（ランダムに選択される）のIPv4アドレスです。 IP TTLは、ソースUDPポートが送信者によって選択された1に設定されています。先UDPポートは（MPLSエコー要求のためにIANAによって割り当てられた）3503に設定されています。ルータアラートオプションは、IPヘッダに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request is sent with a label stack corresponding to the FEC Stack being tested. Note that further labels could be applied if, for example, the normal route to the topmost FEC in the stack is via a Traffic Engineered Tunnel [RSVP-TE]. If all of the FECs in the stack correspond to Implicit Null labels, the MPLS echo request is considered unlabeled even if further labels will be applied in sending the packet.",
      "ja": "MPLSエコー要求は、FECスタックに対応するラベルスタックがテストされて送信されます。例えば、スタックの一番上のFECに対して垂直経路がトラヒックエンジニアリングトンネル[RSVP-TE]を介して行われる、場合さらに、ラベルが適用され得ることに留意されたいです。スタック内のFECのすべてが暗黙的ヌルラベルに対応する場合、MPLSエコー要求は、さらに、ラベルはパケットの送信に適用される場合であっても非標識であると考えられます。"
    },
    {
      "indent": 3,
      "text": "If the echo request is labeled, one MAY (depending on what is being pinged) set the TTL of the innermost label to 1, to prevent the ping request going farther than it should. Examples of where this SHOULD be done include pinging a VPN IPv4 or IPv6 prefix, an L2 VPN endpoint or a pseudowire. Preventing the ping request from going too far can also be accomplished by inserting a Router Alert label above this label; however, this may lead to the undesired side effect that MPLS echo requests take a different data path than actual data. For more information on how these mechanisms can be used for pseudowire connectivity verification, see [VCCV].",
      "ja": "エコー要求が標識されている場合は、（pingを実行されているものに応じて）1 MAYは遠く、それが必要以上に行くping要求を防ぐために、1に最も内側のラベルのTTLを設定します。これが行われるべき場所の例は、VPN IPv4またはIPv6プレフィックス、L2 VPNエンドポイントまたは疑似回線をping含みます。あまりにも遠くも、このラベル上のルータ警告ラベルを挿入することによって達成することができるだろうからping要求を防止すること;しかしながら、これは、エコー要求が実際のデータとは異なるデータパスを取るMPLS望ましくない副作用をもたらし得ます。これらのメカニズムは、疑似回線接続性検証のために使用することができる方法の詳細については、[VCCV]参照。"
    },
    {
      "indent": 3,
      "text": "In \"ping\" mode (end-to-end connectivity check), the TTL in the outermost label is set to 255. In \"traceroute\" mode (fault isolation mode), the TTL is set successively to 1, 2, and so on.",
      "ja": "「ピング」モード（エンドツーエンド接続性チェック）において、最も外側のラベルにTTLを「トレースルート」モード（障害分離モード）、TTLのように2,1に順次設定され、255に設定されています。"
    },
    {
      "indent": 3,
      "text": "The sender chooses a Sender's Handle and a Sequence Number. When sending subsequent MPLS echo requests, the sender SHOULD increment the Sequence Number by 1. However, a sender MAY choose to send a group of echo requests with the same Sequence Number to improve the chance of arrival of at least one packet with that Sequence Number.",
      "ja": "送信者は送信者のハンドルとシーケンス番号を選択します。エコー要求を、後続のMPLSを送信すると、送信者は、しかし、送信者がそのシーケンス番号を持つ少なくとも1つのパケットの到着のチャンスを改善するために、同じシーケンス番号をエコー要求のグループを送るのを選ぶかもしれ1.でシーケンス番号をインクリメントすべきです。"
    },
    {
      "indent": 3,
      "text": "The TimeStamp Sent is set to the time-of-day (in seconds and microseconds) that the echo request is sent. The TimeStamp Received is set to zero.",
      "ja": "送信されたタイムスタンプは時刻（秒およびマイクロ秒）エコー要求が送信されることに設定されています。受信したタイムスタンプはゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request MUST have an FEC Stack TLV. Also, the Reply Mode must be set to the desired reply mode; the Return Code and Subcode are set to zero. In the \"traceroute\" mode, the echo request SHOULD include a Downstream Mapping TLV.",
      "ja": "MPLSエコー要求は、FECスタックTLVを持たなければなりません。また、応答モードは、所望の応答モードに設定されなければなりません。戻りコードとサブコードはゼロに設定されています。 「トレースルート」モードでは、エコー要求は、ダウンストリームマッピングTLVを含むべきです。"
    },
    {
      "indent": 0,
      "text": "4.4. Receiving an MPLS Echo Request",
      "section_title": true,
      "ja": "4.4。 MPLSエコー要求を受信します"
    },
    {
      "indent": 3,
      "text": "Sending an MPLS echo request to the control plane is triggered by one of the following packet processing exceptions: Router Alert option, IP TTL expiration, MPLS TTL expiration, MPLS Router Alert label, or the destination address in the 127/8 address range. The control plane further identifies it by UDP destination port 3503.",
      "ja": "ルータ警告オプション、IP TTLの期限切れ、MPLS TTLの期限切れ、MPLSルータ警告ラベル、または8分の127のアドレス範囲の宛先アドレス：コントロールプレーンにMPLSエコー要求を送信することは、次のパケット処理例外のいずれかによってトリガされます。制御プレーンはさらに、UDP宛先ポート3503によってそれを識別する。"
    },
    {
      "indent": 3,
      "text": "For reporting purposes the bottom of stack is considered to be stack-depth of 1. This is to establish an absolute reference for the case where the actual stack may have more labels than there are FECs in the Target FEC Stack.",
      "ja": "報告目的のためにスタックの底部が1のスタック深さであると考えられているこれは、実際のスタックは、ターゲットFECスタック内のFECがあるより多くのラベルを有していてもよい場合の絶対的な基準を確立することです。"
    },
    {
      "indent": 3,
      "text": "Furthermore, in all the error codes listed in this document, a stack-depth of 0 means \"no value specified\". This allows compatibility with existing implementations that do not use the Return Subcode field.",
      "ja": "また、この文書に記載されているすべてのエラーコードでは、0のスタック深さ「が指定されていない値」を意味しません。これは、リターンサブコードフィールドを使用していない既存の実装との互換性を可能にします。"
    },
    {
      "indent": 3,
      "text": "An LSR X that receives an MPLS echo request then processes it as follows.",
      "ja": "その後、MPLSエコー要求を受信し、次のようにそれを処理LSRのX。"
    },
    {
      "indent": 3,
      "text": "1. General packet sanity is verified. If the packet is not well-formed, LSR X SHOULD send an MPLS Echo Reply with the Return Code set to \"Malformed echo request received\" and the Subcode to zero. If there are any TLVs not marked as \"Ignore\" that LSR X does not understand, LSR X SHOULD send an MPLS \"TLV not understood\" (as appropriate), and the Subcode set to zero. In the latter case, the misunderstood TLVs (only) are included as sub-TLVs in an Errored TLVs TLV in the reply. The header fields Sender's Handle, Sequence Number, and Timestamp Sent are not examined, but are included in the MPLS echo reply message.",
      "ja": "1.一般的なパケット正気が検証されます。パケットがうまく形成されていない場合は、LSR Xは、戻りコードを持つMPLSエコー応答を送るべきである「不正な形式のエコー要求を受信」に設定し、ゼロにサブコード。どんなのTLVがないLSR Xは理解していないことを「無視」としてマークがある場合は、LSR Xは、MPLS（適宜）「TLV理解されていない」と、ゼロに設定サブコードを送るべきです。後者の場合には、誤解のTLV（のみ）が応答でエラー状態TLVのTLVサブのTLVとして含まれます。送信されたヘッダフィールドの送信者のハンドル、シーケンス番号、タイムスタンプが検査されていないが、MPLSエコー応答メッセージに含まれています。"
    },
    {
      "indent": 3,
      "text": "The algorithm uses the following variables and identifiers:",
      "ja": "このアルゴリズムは、以下の変数および識別子を使用しています。"
    },
    {
      "indent": 3,
      "text": "Interface-I: the interface on which the MPLS echo request was received.",
      "ja": "インタフェース-I：MPLSエコー要求を受信したインタフェース。"
    },
    {
      "indent": 3,
      "text": "Stack-R: the label stack on the packet as it was received.",
      "ja": "スタック-R：それは受信されたように、パケットにラベルスタック。"
    },
    {
      "indent": 3,
      "text": "Stack-D: the label stack carried in the Downstream Mapping TLV (not always present)",
      "ja": "スタック-D：ダウンストリームマッピングTLVで運ばれたラベルスタック（常に存在していません）"
    },
    {
      "indent": 3,
      "text": "Label-L: the label from the actual stack currently being examined. Requires no initialization.",
      "ja": "ラベルL：実際のスタックからラベルが現在検討されています。何の初期化を必要としません。"
    },
    {
      "indent": 3,
      "text": "Label-stack-depth: the depth of label being verified. Initialized to the number of labels in the received label stack S.",
      "ja": "ラベルスタックの深さ：ラベルの深さが確認されています。受信したラベルスタックS.のラベルの数に初期化"
    },
    {
      "indent": 3,
      "text": "FEC-stack-depth: depth of the FEC in the Target FEC Stack that should be used to verify the current actual label. Requires no initialization.",
      "ja": "FEC-スタックの深さ：現在の実際のラベルを確認するために使用されるべきターゲットFECスタックにおけるFECの深さ。何の初期化を必要としません。"
    },
    {
      "indent": 3,
      "text": "Best-return-code: contains the return code for the echo reply packet as currently best known. As algorithm progresses, this code may change depending on the results of further checks that it performs.",
      "ja": "ベスト・リターン・コードは：として現在最もよく知られたエコー応答パケットの戻りコードが含まれています。アルゴリズムが進行するにつれて、このコードは、実行さらにチェックの結果に応じて変化してもよいです。"
    },
    {
      "indent": 3,
      "text": "Best-rtn-subcode: similar to Best-return-code, but for the Echo Reply Subcode.",
      "ja": "ベスト-rtnをサブコード：ベスト・リターン・コードに似ていますが、エコー応答サブコードのために。"
    },
    {
      "indent": 3,
      "text": "FEC-status: result value returned by the FEC Checking algorithm described in section 4.4.1.",
      "ja": "FECステータス：セクション4.4.1で説明したFECチェックアルゴリズムによって返された結果の値。"
    },
    {
      "indent": 3,
      "text": "/* Save receive context information */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. If the echo request is good, LSR X stores the interface over which the echo was received in Interface-I, and the label stack with which it came in Stack-R.",
      "ja": "2.エコー要求が良好であれば、LSR Xは、それがスタック-Rに来たとエコーがインターフェイス-Iで受信された上でインターフェイス、およびラベルスタックを格納します。"
    },
    {
      "indent": 3,
      "text": "/* The rest of the algorithm iterates over the labels in Stack-R,\n   verifies validity of label values, reports associated label\n   switching operations (for traceroute), verifies correspondence\n   between the Stack-R and the Target FEC Stack description in the\n   body of the echo request, and reports any errors. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* The algorithm iterates as follows. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. Label Validation:",
      "section_title": true,
      "ja": "3.ラベルの検証："
    },
    {
      "indent": 6,
      "text": "If Label-stack-depth is 0 {",
      "ja": "ラベルスタックの深さが0の場合{"
    },
    {
      "indent": 6,
      "text": "/* The LSR needs to report its being a tail-end for the LSP */",
      "raw": true
    },
    {
      "indent": 6,
      "text": " Set FEC-stack-depth to 1, set Label-L to 3 (Implicit Null). Set Best-return-code to 3 (\"Replying router is an egress for the FEC at stack depth\"), set Best-rtn-subcode to the value of FEC-stack-depth (1) and go to step 5 (Egress Processing). }",
      "ja": "1にFECスタック深さを設定し、（暗黙NULL）3にラベルLを設定します。 3にベスト・リターン・コードを設定します（「ルータを返信すると、スタックの深さで、FECのための出口である」）、FEC-スタックの深さ（1）の値にベスト-rtnを-サブコードを設定し、手順5に進みます（出力処理）。 }"
    },
    {
      "indent": 6,
      "text": "/* This step assumes there is always an entry for well-known\n   label values */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Set Label-L to the value extracted from Stack-R at depth Label-stack-depth. Look up Label-L in the Incoming Label Map (ILM) to determine if the label has been allocated and an operation is associated with it.",
      "ja": "深さのラベルスタックの深さにスタックRから抽出​​された値に設定するラベルL。ラベルが割り当てられていると操作は、それに関連付けられているかどうかを判断するために着信ラベルマップ（ILM）にラベルLを検索します。"
    },
    {
      "indent": 6,
      "text": "If there is no entry for L {",
      "ja": "L {ためのエントリが存在しない場合"
    },
    {
      "indent": 6,
      "text": "/* Indicates a temporary or permanent label synchronization\n   problem the LSR needs to report an error */",
      "raw": true
    },
    {
      "indent": 6,
      "text": " Set Best-return-code to 11 (\"No label entry at stack-depth\") and Best-rtn-subcode to Label-stack-depth. Go to step 7 (Send Reply Packet). }",
      "ja": "11に最高のリターンコードを設定します（「スタックの深さではありませんラベルエントリ」）と、スタックの深さを標識するのに最高のrtnをサブコード。 （応答パケットを送信します）7に進みます。 }"
    },
    {
      "indent": 6,
      "text": "Else {",
      "ja": "エルス{"
    },
    {
      "indent": 9,
      "text": "Retrieve the associated label operation from the corresponding NLFE and proceed to step 4 (Label Operation check).",
      "ja": "対応NLFEから関連するラベル操作を取得し、4（ラベル操作チェック）に進みます。"
    },
    {
      "indent": 6,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "4. Label Operation Check",
      "section_title": true,
      "ja": "4.ラベルの動作確認"
    },
    {
      "indent": 6,
      "text": "If the label operation is \"Pop and Continue Processing\" {",
      "ja": "ラベル操作がある場合は、{「ポップと処理を継続」"
    },
    {
      "indent": 6,
      "text": "/* Includes Explicit Null and Router Alert label cases */",
      "raw": true
    },
    {
      "indent": 6,
      "text": " Iterate to the next label by decrementing Label-stack-depth and loop back to step 3 (Label Validation). }",
      "ja": "3（ラベル検証）をステップバックラベルスタック深さとループをデクリメントすることにより次のラベルを反復。 }"
    },
    {
      "indent": 6,
      "text": "If the label operation is \"Swap or Pop and Switch based on Popped Label\" {",
      "ja": "ラベル操作は{「ポップラベルに基づいて、スワップやポップとスイッチ」である場合"
    },
    {
      "indent": 9,
      "text": "Set Best-return-code to 8 (\"Label switched at stack-depth\") and Best-rtn-subcode to Label-stack-depth to report transit switching.",
      "ja": "8に最高のリターンコードを設定し、ラベルスタックの深さをするトランジット切り替えを報告するベスト-rtnをサブコード（「ラベルスタック深さで切り換え」）。"
    },
    {
      "indent": 9,
      "text": "If a Downstream Mapping TLV is present in the received echo request {",
      "ja": "ダウンストリームマッピングTLVは、受信したエコー要求{に存在する場合に"
    },
    {
      "indent": 12,
      "text": "If the IP address in the TLV is 127.0.0.1 or 0::1 { Set Best-return-code to 6 (\"Upstream Interface Index Unknown\"). An Interface and Label Stack TLV SHOULD be included in the reply and filled with Interface-I and Stack-R. }",
      "ja": "TLVでのIPアドレスが127.0.0.1または0 :: 1である場合には{6（「アップストリームインターフェイスインデックス不明」）に最高のリターンコードを設定します。インターフェイスおよびラベルスタックTLVは、回答に含まれており、インターフェイス-Iおよびスタック-Rで満たされるべきです。 }"
    },
    {
      "indent": 12,
      "text": "Else {",
      "ja": "エルス{"
    },
    {
      "indent": 9,
      "text": " Verify that the IP address, interface address, and label stack in the Downstream Mapping TLV match Interface-I and Stack-R. If there is a mismatch, set Best-return-code to 5, \"Downstream Mapping Mismatch\". An Interface and Label Stack TLV SHOULD be included in the reply and filled in based on Interface-I and Stack-R. Go to step 7 (Send Reply Packet). } }",
      "ja": "ダウンストリームマッピングTLVマッチインタフェース-Iおよびスタック-RでのIPアドレス、インターフェイスアドレス、およびラベルスタックいることを確認します。不一致がある場合は、5に最高のリターンコードを設定し、「川下のマッピングの不一致」。インターフェイスおよびラベルスタックTLVは、回答に含まれており、インターフェイス-Iおよびスタック-Rに基づいて記入されるべきである（SHOULD）。 （応答パケットを送信します）7に進みます。 }}"
    },
    {
      "indent": 9,
      "text": "For each available downstream ECMP path {",
      "ja": "各利用可能な下流ECMPパスの{"
    },
    {
      "indent": 12,
      "text": "Retrieve output interface from the NHLFE entry.",
      "ja": "NHLFEエントリーから出力インタフェースを取得します。"
    },
    {
      "indent": 12,
      "text": "/* Note: this return code is set even if Label-stack-depth\n   is one */",
      "raw": true
    },
    {
      "indent": 12,
      "text": "If the output interface is not MPLS enabled {",
      "ja": "出力インタフェースは、イネーブルMPLSされていない場合は{"
    },
    {
      "indent": 12,
      "text": " Set Best-return-code to Return Code 9, \"Label switched but no MPLS forwarding at stack-depth\" and set Best-rtn-subcode to Label-stack-depth and goto Send_Reply_Packet. }",
      "ja": "コード9を返すために最高のリターンコードを設定し、「ラベルが切り替わりませんが、スタックの深さで何のMPLSフォワーディング」とし、後藤Send_Reply_Packet-スタックの深さを標識するのに最高のrtnを-サブコードを設定します。 }"
    },
    {
      "indent": 12,
      "text": "If a Downstream Mapping TLV is present {",
      "ja": "ダウンストリームマッピング場合TLVが存在します{"
    },
    {
      "indent": 9,
      "text": " A Downstream Mapping TLV SHOULD be included in the echo reply (see section 3.3) filled in with information about the current ECMP path. } }",
      "ja": "TLVは、エコー応答（セクション3.3を参照）に含まれるべきであるダウンストリームマッピングは、現在のECMPパスに関する情報で埋め。 }}"
    },
    {
      "indent": 9,
      "text": "If no Downstream Mapping TLV is present, or the Downstream IP Address is set to the ALLROUTERS multicast address, go to step 7 (Send Reply Packet).",
      "ja": "何のダウンストリームマッピングTLVが存在しない、またはダウンストリームIPアドレスがALLROUTERSマルチキャストアドレスに設定されている場合、（応答パケットを送信します）手順7に進みます。"
    },
    {
      "indent": 9,
      "text": "If the \"Validate FEC Stack\" flag is not set and the LSR is not configured to perform FEC checking by default, go to step 7 (Send Reply Packet).",
      "ja": "「検証FECスタック」フラグが設定されていないとLSRはデフォルトでFECチェックを実行するように構成されていない場合は、（応答パケットを送信します）手順7に進みます。"
    },
    {
      "indent": 6,
      "text": "/* Validate the Target FEC Stack in the received echo request.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "First determine FEC-stack-depth from the Downstream Mapping TLV. This is done by walking through Stack-D (the Downstream labels) from the bottom, decrementing the number of labels for each non-Implicit Null label, while incrementing FEC-stack-depth for each label. If the Downstream Mapping TLV contains one or more Implicit Null labels, FEC-stack-depth may be greater than Label-stack-depth. To be consistent with the above stack-depths, the bottom is considered to entry 1. */",
      "ja": "最初のダウンストリームマッピングTLVからFEC-スタックの深さを決定します。これは、各ラベルにFECスタック深さをインクリメントしながら、下からスタック-D（下流ラベル）を歩いて、各非暗黙的ヌルラベルのラベルの数を減少することによって行われます。ダウンストリームマッピングTLVは、1つまたは複数の暗黙的ヌルラベルが含まれている場合は、FEC-スタックの深さは、ラベルスタックの深さよりも大きくすることができます。上記スタック深さと一致するように、底部がエントリ1に考えられています* /"
    },
    {
      "indent": 9,
      "text": "Set FEC-stack-depth to 0. Set i to Label-stack-depth.",
      "ja": "私はラベルスタックの深さを0に設定するFEC-スタックの深さを設定します。"
    },
    {
      "indent": 9,
      "text": "While (i > 0 ) do { ++FEC-stack-depth. if Stack-D[FEC-stack-depth] != 3 (Implicit Null) --i. }",
      "ja": "一方で（私は> 0）{++ FEC-スタックの深さを行います。もしスタックD [FECスタック深]！= 3（暗黙NULL）--I。 }"
    },
    {
      "indent": 9,
      "text": "If the number of labels in the FEC stack is greater than or equal to FEC-stack-depth {",
      "ja": "FECスタックのラベルの数は、FECスタック深さ以上である場合、{"
    },
    {
      "indent": 12,
      "text": "Perform the FEC Checking procedure (see subsection 4.4.1 below).",
      "ja": "FECチェック手順を実行します（サブセクション4.4.1以下を参照してください）。"
    },
    {
      "indent": 12,
      "text": "If FEC-status is 2, set Best-return-code to 10 (\"Mapping for this FEC is not the given label at stack-depth\").",
      "ja": "FEC-ステータスは10から2、セットベスト・リターン・コードである場合（「このFECのためのマッピングは、スタックの深さで与えられたラベルではありません」）。"
    },
    {
      "indent": 9,
      "text": " If the return code is 1, set Best-return-code to FEC-return-code and Best-rtn-subcode to FEC-stack-depth. }",
      "ja": "リターンコードが1である場合には、FEC-スタックの深さにFEC-リターン・コードおよびベスト・rtnをサブコードに最高のリターン・コードを設定します。 }"
    },
    {
      "indent": 6,
      "text": " Go to step 7 (Send Reply Packet). }",
      "ja": "（応答パケットを送信します）7に進みます。 }"
    },
    {
      "indent": 3,
      "text": "5. Egress Processing:",
      "section_title": true,
      "ja": "5.出口処理："
    },
    {
      "indent": 6,
      "text": "/* These steps are performed by the LSR that identified itself\n   as the tail-end LSR for an LSP. */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "If received echo request contains no Downstream Mapping TLV, or the Downstream IP Address is set to 127.0.0.1 or 0::1 go to step 6 (Egress FEC Validation).",
      "ja": "受信されたエコー要求にはダウンストリームマッピングTLVが含まれていない、またはダウンストリームIPアドレスは、6（出口FEC検証）をステップ127.0.0.1または0 :: 1行くように設定されている場合。"
    },
    {
      "indent": 6,
      "text": "Verify that the IP address, interface address, and label stack in the Downstream Mapping TLV match Interface-I and Stack-R. If not, set Best-return-code to 5, \"Downstream Mapping Mis-match\". A Received Interface and Label Stack TLV SHOULD be created for the echo response packet. Go to step 7 (Send Reply Packet).",
      "ja": "ダウンストリームマッピングTLVマッチインタフェース-Iおよびスタック-RでのIPアドレス、インターフェイスアドレス、およびラベルスタックいることを確認します。ない場合は、「ダウンストリームマッピングミスマッチ」、5に最高のリターンコードを設定します。受信したインターフェイスとラベルスタックTLVは、エコー応答パケットのために作成する必要があります。 （応答パケットを送信します）7に進みます。"
    },
    {
      "indent": 3,
      "text": "6. Egress FEC Validation:",
      "section_title": true,
      "ja": "6.出口FEC検証："
    },
    {
      "indent": 6,
      "text": "/* This is a loop for all entries in the Target FEC Stack\n   starting with FEC-stack-depth. */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Perform FEC checking by following the algorithm described in subsection 4.4.1 for Label-L and the FEC at FEC-stack-depth.",
      "ja": "FEC-スタックの深さでラベルLとFECのためのサブセクション4.4.1で説明したアルゴリズムに従って、FECチェックを実行します。"
    },
    {
      "indent": 6,
      "text": "Set Best-return-code to FEC-code and Best-rtn-subcode to the value in FEC-stack-depth.",
      "ja": "FEC-スタックの深さの値にFECコードとベスト・rtnをサブコードに最高のリターンコードを設定します。"
    },
    {
      "indent": 6,
      "text": "If FEC-status (the result of the check) is 1, go to step 7 (Send Reply Packet).",
      "ja": "FEC-状態（チェックの結果）が1である場合には、（応答パケットを送信します）手順7に進みます。"
    },
    {
      "indent": 6,
      "text": "/* Iterate to the next FEC entry */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "++FEC-stack-depth.",
      "ja": "++ FEC-スタックの深さ。"
    },
    {
      "indent": 6,
      "text": "If FEC-stack-depth > the number of FECs in the FEC-stack, go to step 7 (Send Reply Packet).",
      "ja": "FEC-スタックの深さ> FECスタック内のFECの数は、7ステップに進みます（応答パケットを送信します）。"
    },
    {
      "indent": 6,
      "text": "If FEC-status is 0 { ++Label-stack-depth. If Label-stack-depth > the number of labels in Stack-R, Go to step 7 (Send Reply Packet).",
      "ja": "FEC-ステータスは0 {++ラベルスタックの深さである場合。ラベルスタックの深さ>スタック-Rのラベルの数は、7に進み場合（応答パケットを送信します）。"
    },
    {
      "indent": 6,
      "text": " Label-L = extracted label from Stack-R at depth Label-stack-depth. Loop back to step 6 (Egress FEC Validation). }",
      "ja": "ラベルL =深度ラベルスタック深さでスタックRから抽出​​されたラベル。ループバック6（出力FEC検証）を進みます。 }"
    },
    {
      "indent": 3,
      "text": "7. Send Reply Packet:",
      "section_title": true,
      "ja": "7.応答パケットを送信します。"
    },
    {
      "indent": 6,
      "text": "Send an MPLS echo reply with a Return Code of Best-return-code, and a Return Subcode of Best-rtn-subcode. Include any TLVs created during the above process. The procedures for sending the echo reply are found in subsection 4.4.1.",
      "ja": "ベスト・リターン・コードの戻りコード、およびベスト・rtnをサブコードのリターンサブコードとMPLSエコー応答を送信します。上記のプロセス中に作成されたすべてのTLVを含めます。エコー応答を送信するための手順は、サブセクション4.4.1に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.4.1. FEC Validation",
      "section_title": true,
      "ja": "4.4.1。 FECの検証"
    },
    {
      "indent": 3,
      "text": "/* This subsection describes validation of an FEC entry within the\n   Target FEC Stack and accepts an FEC, Label-L, and Interface-I.\n   The algorithm performs the following steps. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "1. Two return values, FEC-status and FEC-return-code, are initialized to 0.",
      "ja": "1. 2つの戻り値、FEC-状態とFEC-リターンコードは、0に初期化されています。"
    },
    {
      "indent": 3,
      "text": "2. If the FEC is the Nil FEC { If Label-L is either Explicit_Null or Router_Alert, return.",
      "ja": "FECがnil FEC場合ラベルLがExplicit_Null又はRouter_Alertのいずれかである場合2. {返します。"
    },
    {
      "indent": 6,
      "text": " Else { Set FEC-return-code to 10 (\"Mapping for this FEC is not the given label at stack-depth\"). Set FEC-status to 1 Return. } }",
      "ja": "他{セットFECリターンコード10（「このFECのためのマッピングはスタック深さで所定のラベルではありません」）。 1つのリターンにFECステータスを設定します。 }}"
    },
    {
      "indent": 3,
      "text": "3. Check the FEC label mapping that describes how traffic received on the LSP is further switched or which application it is associated with. If no mapping exists, set FEC-return-code to Return 4, \"Replying router has no mapping for the FEC at stack-depth\". Set FEC-status to 1. Return.",
      "ja": "3.トラフィックがさらに切り替わっているか、どのアプリケーションが関連付けられているLSP上で受信方法について説明FECラベルマッピングを確認してください。マッピングが存在しない場合、4を返すために、FEC-リターンコードを設定し、「返信ルータは、スタックの深さでFECのためのマッピングを持っていません」。 1.リターンにFECステータスを設定します。"
    },
    {
      "indent": 3,
      "text": "4. If the label mapping for FEC is Implicit Null, set FEC-status to 2 and proceed to step 5. Otherwise, if the label mapping for FEC is",
      "ja": "4. FECのためのラベルマッピングは暗黙のNULLの場合、2にFEC-ステータスを設定し、FECのためのラベルマッピングがあれば、そうでない場合はステップ5に進みます"
    },
    {
      "indent": 6,
      "text": "Label-L, proceed to step 5. Otherwise, set FEC-return-code to 10 (\"Mapping for this FEC is not the given label at stack-depth\"), set FEC-status to 1, and return.",
      "ja": "ラベルL、そうでない場合はステップ5に進んで、（「このFECのためのマッピングはスタック深さで所定のラベルではない」）10にFECリターンコードを設定し、1にFECステータスを設定し、返します。"
    },
    {
      "indent": 3,
      "text": "5. This is a protocol check. Check what protocol would be used to advertise FEC. If it can be determined that no protocol associated with Interface-I would have advertised an FEC of that FEC-Type, set FEC-return-code to 12 (\"Protocol not associated with interface at FEC stack-depth\"). Set FEC-status to 1.",
      "ja": "5.これは、プロトコルチェックです。 FECを宣伝するために使用されるもののプロトコルを確認してください。プロトコルが関連付けられていないと判断できる場合インターフェイス-Iは、そのFECタイプのFECをアドバタイズ（「FECスタック深さのインタフェースに関連付けられていないプロトコル」）12にFECリターンコードを設定しているであろう。 1にFECステータスを設定します。"
    },
    {
      "indent": 3,
      "text": "6. Return.",
      "section_title": true,
      "ja": "6.戻ります。"
    },
    {
      "indent": 0,
      "text": "4.5. Sending an MPLS Echo Reply",
      "section_title": true,
      "ja": "4.5。 MPLSエコー応答を送信します"
    },
    {
      "indent": 3,
      "text": "An MPLS echo reply is a UDP packet. It MUST ONLY be sent in response to an MPLS echo request. The source IP address is a routable address of the replier; the source port is the well-known UDP port for LSP ping. The destination IP address and UDP port are copied from the source IP address and UDP port of the echo request. The IP TTL is set to 255. If the Reply Mode in the echo request is \"Reply via an IPv4 UDP packet with Router Alert\", then the IP header MUST contain the Router Alert IP option. If the reply is sent over an LSP, the topmost label MUST in this case be the Router Alert label (1) (see [LABEL-STACK]).",
      "ja": "MPLSエコー応答がUDPパケットです。それだけでMPLSエコー要求に応答して送らなければなりません。送信元IPアドレスはリプライヤのルーティング可能なアドレスです。送信元ポートは、LSPピングのためのよく知られたUDPポートです。宛先IPアドレスとUDPポートは、エコー要求の送信元IPアドレスとUDPポートからコピーされます。エコー要求に応答モードは、次にIPヘッダはルータアラートIPオプションを含まなければならない、「ルータアラートとのIPv4 UDPパケットを介して返信」である場合、IP TTLは255に設定されています。応答がLSPを介して送信された場合、この場合の最上位ラベルのMUSTは、ルータ警告ラベルである（1）（[LABEL-STACK]を参照）。"
    },
    {
      "indent": 3,
      "text": "The format of the echo reply is the same as the echo request. The Sender's Handle, the Sequence Number, and TimeStamp Sent are copied from the echo request; the TimeStamp Received is set to the time-of-day that the echo request is received (note that this information is most useful if the time-of-day clocks on the requester and the replier are synchronized). The FEC Stack TLV from the echo request MAY be copied to the reply.",
      "ja": "エコー応答の形式は、エコー要求と同じです。エコー要求からコピーされて送信された送信者のハンドル、シーケンス番号、およびタイムスタンプ。受信したタイムスタンプが時刻エコー要求が受信されるに設定されている（リクエスタとリプライヤ上の時刻クロックが同期している場合は、この情報が最も有用であることに注意してください）。エコー要求からFECスタックTLVは、返信にコピーされてもよいです。"
    },
    {
      "indent": 3,
      "text": "The replier MUST fill in the Return Code and Subcode, as determined in the previous subsection.",
      "ja": "前節で決定されたようリプライヤは、戻りコードおよびサブコードを入力する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the echo request contains a Pad TLV, the replier MUST interpret the first octet for instructions regarding how to reply.",
      "ja": "エコー要求はパッドTLVが含まれている場合は、リプライヤは返信する方法に関する指示のための最初のオクテットを解釈する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the replying router is the destination of the FEC, then Downstream Mapping TLVs SHOULD NOT be included in the echo reply.",
      "ja": "返答ルータがFECの宛先である場合には、川下のマッピングのTLVは、エコー応答に含まれるべきではありません。"
    },
    {
      "indent": 3,
      "text": "If the echo request contains a Downstream Mapping TLV, and the replying router is not the destination of the FEC, the replier SHOULD compute its downstream routers and corresponding labels for the incoming label, and add Downstream Mapping TLVs for each one to the echo reply it sends back.",
      "ja": "エコー要求は、ダウンストリームマッピングTLVが含まれており、返答ルータがFECの宛先ではない場合は、リプライヤは、着信ラベルにその下流のルータと対応するラベルを計算し、エコー応答にそれぞれに対してダウンストリームマッピングTLVを追加すべきであること送り返します。"
    },
    {
      "indent": 3,
      "text": "If the Downstream Mapping TLV contains Multipath Information requiring more processing than the receiving router is willing to perform, the responding router MAY choose to respond with only a subset of multipaths contained in the echo request Downstream Mapping. (Note: The originator of the echo request MAY send another echo request with the Multipath Information that was not included in the reply.)",
      "ja": "ダウンストリームマッピングTLVが受信ルータが実行していく所存ですより多くの処理を必要とするマルチパスの情報が含まれている場合は、応答ルータはエコー要求ダウンストリームマッピングに含まれているマルチパスのサブセットのみで応答することを選択するかもしれません。 （注意：エコー要求の発信元は、回答に含まれていなかったマルチパス情報を持つ別のエコー要求を送信することができます。）"
    },
    {
      "indent": 3,
      "text": "Except in the case of Reply Mode 4, \"Reply via application level control channel\", echo replies are always sent in the context of the IP/MPLS network.",
      "ja": "応答モード4の場合を除いて、「アプリケーションレベルの制御チャネルを介して返信」、エコー応答は常に、IP / MPLSネットワークのコンテキストで送信されます。"
    },
    {
      "indent": 0,
      "text": "4.6. Receiving an MPLS Echo Reply",
      "section_title": true,
      "ja": "4.6。 MPLSエコー応答を受け取ります"
    },
    {
      "indent": 3,
      "text": "An LSR X should only receive an MPLS echo reply in response to an MPLS echo request that it sent. Thus, on receipt of an MPLS echo reply, X should parse the packet to ensure that it is well-formed, then attempt to match up the echo reply with an echo request that it had previously sent, using the destination UDP port and the Sender's Handle. If no match is found, then X jettisons the echo reply; otherwise, it checks the Sequence Number to see if it matches.",
      "ja": "LSR Xは、それが送られたMPLSエコー要求に応じて、MPLSエコー応答を受け取る必要があります。このように、MPLSエコー応答の受信時に、Xは送信者の、それは以前に送られていたことをエコー要求とエコー応答を照合し、宛先UDPポートを使用して、その後、それはよく形成されることを保証するために、パケットを解析しなければなりません扱う。一致が見つからない場合には、Xは、エコー応答をjettisons。そうでない場合は、それが一致するかどうかを確認するためにシーケンス番号をチェックします。"
    },
    {
      "indent": 3,
      "text": "If the echo reply contains Downstream Mappings, and X wishes to traceroute further, it SHOULD copy the Downstream Mapping(s) into its next echo request(s) (with TTL incremented by one).",
      "ja": "エコー応答がダウンストリームマッピングを含み、Xは、さらに、トレースルートを望む場合、その次のエコー要求（単数または複数）（インクリメントTTL付き）にダウンストリームマッピング（複数可）をコピーする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.7. Issue with VPN IPv4 and IPv6 Prefixes",
      "section_title": true,
      "ja": "4.7。 VPN IPv4およびIPv6プレフィックスを持つ問題"
    },
    {
      "indent": 3,
      "text": "Typically, an LSP ping for a VPN IPv4 prefix or VPN IPv6 prefix is sent with a label stack of depth greater than 1, with the innermost label having a TTL of 1. This is to terminate the ping at the egress PE, before it gets sent to the customer device. However, under certain circumstances, the label stack can shrink to a single label before the ping hits the egress PE; this will result in the ping terminating prematurely. One such scenario is a multi-AS Carrier's Carrier VPN.",
      "ja": "典型的には、VPN IPv4プレフィクスまたはVPNのIPv6プレフィックスのLSPピングは、最も内側のラベルこれはそれを取得する前に、出口PEでのpingを終了する1のTTLを有する、1を超える深さのラベルスタックを用いて送信されますお客様のデバイスに送信されます。 pingが出口PEを打つ前しかし、特定の状況下で、ラベルスタックは、単一のラベルに縮小することができます。これは途中で終了ピングになります。そのようなシナリオの1つは、マルチASキャリアのキャリアVPNです。"
    },
    {
      "indent": 3,
      "text": "To get around this problem, one approach is for the LSR that receives such a ping to realize that the ping terminated prematurely, and send back error code 13. In that case, the initiating LSR can retry the ping after incrementing the TTL on the VPN label. In this fashion, the ingress LSR will sequentially try TTL values until it finds one that allows the VPN ping to reach the egress PE.",
      "ja": "この問題を回避するには、1つのアプローチは、pingが途中で終了したことを実感し、その場合、エラーコード13を返送するようにPINGを受け取るLSRのためである、開始LSRは、VPN上でTTLをインクリメントした後にpingを再試行することができますラベル。それはVPNのpingが出口PEに到達することを可能にするものを見つけるまでこのように、入口LSRが順次TTL値を試みます。"
    },
    {
      "indent": 0,
      "text": "4.8. Non-compliant Routers",
      "section_title": true,
      "ja": "4.8。非対応ルータ"
    },
    {
      "indent": 3,
      "text": "If the egress for the FEC Stack being pinged does not support MPLS ping, then no reply will be sent, resulting in possible \"false negatives\". If in \"traceroute\" mode, a transit LSR does not support LSP ping, then no reply will be forthcoming from that LSR for some TTL, say, n. The LSR originating the echo request SHOULD try sending the echo request with TTL=n+1, n+2, ..., n+k to probe LSRs further down the path. In such a case, the echo request for TTL > n SHOULD be sent with Downstream Mapping TLV \"Downstream IP Address\" field set to the ALLROUTERs multicast address until a reply is received with a Downstream Mapping TLV. The label stack MAY be omitted from the Downstream Mapping TLV. Furthermore, the \"Validate FEC Stack\" flag SHOULD NOT be set until an echo reply packet with a Downstream Mapping TLV is received.",
      "ja": "FECスタックのための出口がMPLSピングをサポートしていないpingを実行している場合は、何も返信が可能「偽陰性」で、その結果、送信されません。 「トレースルート」モードでは、中継LSRは、LSPピングをサポートしていない場合は、何の返事は、いくつかのTTL、たとえば、nに対してそのLSRから来ることはありません。エコー要求元LSRはTTL有するエコー要求を送信してください= N + 1、N + 2、...、N + kがパスさらに下のLSRをプローブするべきです。このような場合には、TTLのためのエコー要求> N返信下流マッピングTLVで受信されるまでALLROUTERsマルチキャストアドレスに設定ダウンストリームマッピングTLV「下流IPアドレス」フィールドで送信されるべきです。ラベルスタックは、ダウンストリームマッピングTLVから省略されるかもしれません。また、「検証FECスタック」フラグは、TLVが受信されたダウンストリームマッピングとエコー応答パケットまで設定しないでください。"
    },
    {
      "indent": 0,
      "text": "5. References",
      "section_title": true,
      "ja": "5.参考文献"
    },
    {
      "indent": 0,
      "text": "5.1. Normative References",
      "section_title": true,
      "ja": "5.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[BGP] Rekhter, Y., Li, T., and S. Hares, \"A Border Gateway Protocol 4 (BGP-4)\", RFC 4271, January 2006.",
      "ja": "[BGP] Rekhter、Y.、李、T.、およびS.野兎、 \"ボーダーゲートウェイプロトコル4（BGP-4）\"、RFC 4271、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[IANA] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[IANA] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[KEYWORDS] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[キーワード]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[LABEL-STACK] Rosen, E., Tappan, D., Fedorkow, G., Rekhter, Y., Farinacci, D., Li, T., and A. Conta, \"MPLS Label Stack Encoding\", RFC 3032, January 2001.",
      "ja": "[LABEL-STACK]ローゼン、E.、タッパン、D.、Fedorkow、G.、Rekhter、Y.、ファリナッチ、D.、李、T.、およびA.コンタ、 \"MPLSラベルスタックエンコーディング\"、RFC 3032、 2001年1月。"
    },
    {
      "indent": 3,
      "text": "[NTP] Mills, D., \"Simple Network Time Protocol (SNTP) Version 4 for IPv4, IPv6 and OSI\", RFC 2030, October 1996.",
      "ja": "[NTP]ミルズ、D.、 \"IPv4、IPv6、およびOSIのため簡易ネットワークタイムプロトコル（SNTP）バージョン4\"、RFC 2030、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122]ブレーデン、R.、 \"インターネットホストのための要件 - 通信層\"、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1812] Baker, F., \"Requirements for IP Version 4 Routers\", RFC 1812, June 1995.",
      "ja": "[RFC1812]ベイカー、F.、RFC 1812、1995年6月 \"IPバージョン4つのルータのための要件\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4026] Andersson, L. and T. Madsen, \"Provider Provisioned Virtual Private Network (VPN) Terminology\", RFC 4026, March 2005.",
      "ja": "[RFC4026]アンデションとL.とT.マドセン、 \"プロバイダーのプロビジョニングされた仮想プライベートネットワーク（VPN）用語\"、RFC 4026、2005月。"
    },
    {
      "indent": 0,
      "text": "5.2. Informative References",
      "section_title": true,
      "ja": "5.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[BGP-LABEL] Rekhter, Y. and E. Rosen, \"Carrying Label Information in BGP-4\", RFC 3107, May 2001.",
      "ja": "[BGP-LABEL] Rekhter、Y.、およびE.ローゼン、 \"BGP-4でのキャリングラベル情報\"、RFC 3107、2001年5月。"
    },
    {
      "indent": 3,
      "text": "[ICMP] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, September 1981.",
      "ja": "[ICMP]ポステル、J.、 \"インターネット制御メッセージプロトコル\"、STD 5、RFC 792、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[LDP] Andersson, L., Doolan, P., Feldman, N., Fredette, A., and B. Thomas, \"LDP Specification\", RFC 3036, January 2001.",
      "ja": "[LDP]アンデション、L.、Doolan、P.、フェルドマン、N.、Fredette、A.、およびB.トーマス、 \"LDP仕様\"、RFC 3036、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[PW-CONTROL] Martini, L., El-Aawar, N., Heron, G., Rosen, E., Tappan, D., and T. Smith, \"Pseudowire Setup and Maintenance using the Label Distribution Protocol\", Work in Progress.",
      "ja": "[PW-CONTROL]マティーニ、L.、エル・Aawar、N.、ヘロン、G.、ローゼン、E.、タッパン、D.、およびT.スミス、 \"ラベル配布プロトコルを使用して擬似回線の設定とメンテナンス\"、仕事進行中。"
    },
    {
      "indent": 3,
      "text": "[RFC4365] Rosen, E., \"Applicability Statement for BGP/MPLS IP Virtual Private Networks (VPNs)\", RFC 4365, February 2006.",
      "ja": "[RFC4365]ローゼン、E.、 \"BGP / MPLS IP仮想プライベートネットワーク（VPN）のための適用性に関する声明\"、RFC 4365、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[RSVP-TE] Awduche, D., Berger, L., Gan, D., Li, T., Srinivasan, V., and G. Swallow, \"RSVP-TE: Extensions to RSVP for LSP Tunnels\", RFC 3209, December 2001.",
      "ja": "[RSVP-TE] Awduche、D.、バーガー、L.、ガン、D.、李、T.、スリニヴァサン、V.、およびG.ツバメ、 \"RSVP-TE：ExtensionsがLSPトンネルのためのRSVPする\"、RFC 3209 、2001年12月。"
    },
    {
      "indent": 3,
      "text": "[VCCV] Nadeau, T. and R. Aggarwal, \"Pseudo Wire Virtual Circuit Connectivity Verification (VCCV), Work in Progress, August 2005.",
      "ja": "[VCCV]ナドー、T.、およびR.アガルワル、「疑似ワイヤー仮想回線接続性検証（VCCV）、進歩、2005年8月に作業。"
    },
    {
      "indent": 3,
      "text": "[VPLS-BGP] Kompella, K. and Y. Rekhter, \"Virtual Private LAN Service\", Work in Progress.",
      "ja": "[VPLS-BGP] Kompella、K.とY. Rekhter、 \"仮想プライベートLANサービス\" が進行中で働いています。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Overall, the security needs for LSP ping are similar to those of ICMP ping.",
      "ja": "全体的に、LSPピングのためのセキュリティニーズは、ICMP pingのと同様です。"
    },
    {
      "indent": 3,
      "text": "There are at least three approaches to attacking LSRs using the mechanisms defined here. One is a Denial-of-Service attack, by sending MPLS echo requests/replies to LSRs and thereby increasing their workload. The second is obfuscating the state of the MPLS data plane liveness by spoofing, hijacking, replaying, or otherwise tampering with MPLS echo requests and replies. The third is an unauthorized source using an LSP ping to obtain information about the network.",
      "ja": "ここで定義されたメカニズムを使用してのLSRを攻撃する、少なくとも3つのアプローチがあります。一つは、MPLSエコー要求を送信することにより、DoS攻撃、である/のLSRに応答し、それによって彼らのワークロードが増加します。第二は、なりすまし、ハイジャック、再生、または他の方法でMPLSエコー要求および応答を改ざんすることによってMPLSデータプレーンライブネスの状態を難読化されています。第三には、ネットワークに関する情報を取得するLSPピングを使用して、不正なソースです。"
    },
    {
      "indent": 3,
      "text": "To avoid potential Denial-of-Service attacks, it is RECOMMENDED that implementations regulate the LSP ping traffic going to the control plane. A rate limiter SHOULD be applied to the well-known UDP port defined below.",
      "ja": "潜在的なサービス拒否攻撃を回避するために、実装はコントロールプレーンに行くのLSP pingトラフィックを制御することが推奨されます。レートリミッタは、以下に定義され、よく知られているUDPポートに適用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Unsophisticated replay and spoofing attacks involving faking or replaying MPLS echo reply messages are unlikely to be effective. These replies would have to match the Sender's Handle and Sequence Number of an outstanding MPLS echo request message. A non-matching replay would be discarded as the sequence has moved on, thus a spoof has only a small window of opportunity. However, to provide a stronger defense, an implementation MAY also validate the TimeStamp Sent by requiring and exact match on this field.",
      "ja": "MPLSを偽造または再生エコー応答メッセージを含む素朴な再生とスプーフィング攻撃が有効であることがほとんどありません。これらの応答は、優れたMPLSエコー要求メッセージの送信者のハンドルとシーケンス番号と一致しなければなりません。配列は、このようになりすまし機会の少ない窓を有する、上に移動したような非整合リプレイは廃棄されるであろう。しかし、より強力な防御力を提供するために、実装は、この分野で必要と正確に一致することにより、送信されたタイムスタンプを検証することができます。"
    },
    {
      "indent": 3,
      "text": "To protect against unauthorized sources using MPLS echo request messages to obtain network information, it is RECOMMENDED that implementations provide a means of checking the source addresses of MPLS echo request messages against an access list before accepting the message.",
      "ja": "ネットワーク情報を得るために、MPLSにエコー要求メッセージを使用して、不正なソースから保護するためには、実装がメッセージを受け入れる前に、アクセスリストに対してMPLSエコー要求メッセージの送信元アドレスをチェックする手段を提供することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "It is not clear how to prevent hijacking (non-delivery) of echo requests or replies; however, if these messages are indeed hijacked, LSP ping will report that the data plane is not working as it should.",
      "ja": "エコー要求や応答のハイジャック（非配信）を防止する方法は明らかではありません。これらのメッセージは確かにハイジャックされている場合は、LSPピングは、データプレーンは、それが必要として動作していないことを報告します。"
    },
    {
      "indent": 3,
      "text": "It does not seem vital (at this point) to secure the data carried in MPLS echo requests and replies, although knowledge of the state of the MPLS data plane may be considered confidential by some. Implementations SHOULD, however, provide a means of filtering the addresses to which echo reply messages may be sent.",
      "ja": "MPLSデータプレーンの状態の知識がいくつかによって機密と見なすことができるが、MPLSエコー要求と応答で搬送されたデータを保護するために（この時点で）重要ないないようです。実装は、しかし、メッセージが送信されても​​よい返信エコーたアドレスをフィルタリングする手段を提供すべきです。"
    },
    {
      "indent": 3,
      "text": "Although this document makes special use of 127/8 address, these are used only in conjunction with the UDP port 3503. Furthermore, these packets are only processed by routers. All other hosts MUST treat all packets with a destination address in the range 127/8 in accordance to RFC 1122. Any packet received by a router with a destination address in the range 127/8 without a destination UDP port of 3503 MUST be treated in accordance to RFC 1812. In particular, the default behavior is to treat packets destined to a 127/8 address as \"martians\".",
      "ja": "このドキュメントは、8分の127番地の特別利用しているが、これらだけさらにUDPポート3503と組み合わせて使用​​され、これらのパケットはルータによって処理されます。他のすべてのホストは、RFC 1122に合わせて3503の宛先UDPポートなし範囲8分の127の宛先アドレスを持つルータが受信した任意のパケットが中で処理しなければならない範囲8分の127内の宛先アドレスを持つすべてのパケットを扱わなければなりません特に、RFC 1812に基づき、デフォルトの動作は、「火星人」として8分の127のアドレス宛てのパケットを処理することです。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The TCP and UDP port number 3503 has been allocated by IANA for LSP echo requests and replies.",
      "ja": "TCPとUDPのポート番号3503は、LSPエコー要求および応答のためにIANAによって割り当てられています。"
    },
    {
      "indent": 3,
      "text": "The following sections detail the new name spaces to be managed by IANA. For each of these name spaces, the space is divided into assignment ranges; the following terms are used in describing the procedures by which IANA allocates values: \"Standards Action\" (as defined in [IANA]), \"Specification Required\", and \"Vendor Private Use\".",
      "ja": "次のセクションの詳細は、新しい名前空間はIANAによって管理されます。これらの名前空間のそれぞれについて、スペースが割り当て範囲に分割されます。 「標準アクション」（[IANA]で定義されるように）、「仕様が必要」、および「ベンダープライベート使用」：以下の用語は、IANAに値を割り当てるれる手順を説明するのに使用されます。"
    },
    {
      "indent": 3,
      "text": "Values from \"Specification Required\" ranges MUST be registered with IANA. The request MUST be made via an Experimental RFC that describes the format and procedures for using the code point; the actual assignment is made during the IANA actions for the RFC.",
      "ja": "「仕様が必要」の範囲からの値はIANAに登録しなければなりません。要求は、コードポイントを使用するためのフォーマットおよび手順を説明し、実験RFCを介して行わなければなりません。実際の割り当てはRFCのIANAアクション中に行われます。"
    },
    {
      "indent": 3,
      "text": "Values from \"Vendor Private\" ranges MUST NOT be registered with IANA; however, the message MUST contain an enterprise code as registered with the IANA SMI Private Network Management Private Enterprise Numbers. For each name space that has a Vendor Private range, it must be specified where exactly the SMI Private Enterprise Number resides; see below for examples. In this way, several enterprises (vendors) can use the same code point without fear of collision.",
      "ja": "「ベンダープライベート」の範囲からの値はIANAに登録されてはなりません。 IANA SMIプライベートネットワーク管理プライベート・エンタープライズ番号に登録されしかし、メッセージは、エンタープライズコードを含まなければなりません。正確にSMI民間企業の数はどこにあるベンダーのプライベート範囲を持つ各名前空間の場合は、指定する必要があります。例については以下を参照してください。このように、いくつかの企業（ベンダー）は衝突の恐れなしに同じコードポイントを使用することができます。"
    },
    {
      "indent": 0,
      "text": "7.1. Message Types, Reply Modes, Return Codes",
      "section_title": true,
      "ja": "7.1。メッセージタイプは、モードの返信、リターンコード"
    },
    {
      "indent": 3,
      "text": "The IANA has created and will maintain registries for Message Types, Reply Modes, and Return Codes. Each of these can take values in the range 0-255. Assignments in the range 0-191 are via Standards Action; assignments in the range 192-251 are made via \"Specification Required\"; values in the range 252-255 are for Vendor Private Use, and MUST NOT be allocated.",
      "ja": "IANAは、作成していると、メッセージタイプのためのレジストリを維持するモードの返信、およびコードを返します。これらのそれぞれは、0〜255の範囲の値を取ることができます。範囲0から191での割り当ては標準アクションを経由しています。範囲192から251での割り当ては、「仕様が必要」を経由して作られています。範囲252から255の値は、ベンダー私的使用のためであり、割り当てられてはなりません。"
    },
    {
      "indent": 3,
      "text": "If any of these fields fall in the Vendor Private range, a top-level Vendor Enterprise Number TLV MUST be present in the message.",
      "ja": "これらのフィールドのいずれかがベンダーのプライベート範囲にいる場合、トップレベルのベンダー企業の数TLVは、メッセージ内に存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Message Types defined in this document are the following:",
      "ja": "この文書で定義されたメッセージタイプは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    MPLS echo request\n    2    MPLS echo reply",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Reply Modes defined in this document are the following:",
      "ja": "以下の通り、この文書で定義されたモードの返信："
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    Do not reply\n    2    Reply via an IPv4/IPv6 UDP packet\n    3    Reply via an IPv4/IPv6 UDP packet with Router Alert\n    4    Reply via application level control channel",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Return Codes defined in this document are listed in section 3.1.",
      "ja": "この文書で定義されたリターンコードは、セクション3.1に記載されています。"
    },
    {
      "indent": 0,
      "text": "7.2. TLVs",
      "section_title": true,
      "ja": "7.2。 TLV"
    },
    {
      "indent": 3,
      "text": "The IANA has created and will maintain a registry for the Type field of top-level TLVs as well as for any associated sub-TLVs. Note the meaning of a sub-TLV is scoped by the TLV. The number spaces for the sub-TLVs of various TLVs are independent.",
      "ja": "IANAは、作成したトップレベルのTLVのTypeフィールドのためだけでなく、任意の関連するサブTLVのためのレジストリを維持します。 TLVによってスコープされたサブTLVの意味を注意してください。種々のTLVのサブTLVのための番号空間は独立しています。"
    },
    {
      "indent": 3,
      "text": "The valid range for TLVs and sub-TLVs is 0-65535. Assignments in the range 0-16383 and 32768-49161 are made via Standards Action as defined in [IANA]; assignments in the range 16384-31743 and 49162-64511 are made via \"Specification Required\" as defined above; values in the range 31744-32767 and 64512-65535 are for Vendor Private Use, and MUST NOT be allocated.",
      "ja": "TLVのサブTLVのための有効な範囲は0〜65535です。 [IANA]で定義されるように範囲0から16383と32768から49161で割り当ては標準アクションを介して行われます。上記で定義した範囲16384から31743と49162から64511での割り当ては、「仕様が必要」を介して行われます。範囲31744から32767と64512から65535の値はベンダー私的使用のためであり、割り当てられてはなりません。"
    },
    {
      "indent": 3,
      "text": "If a TLV or sub-TLV has a Type that falls in the range for Vendor Private Use, the Length MUST be at least 4, and the first four octets MUST be that vendor's SMI Private Enterprise Number, in network octet order. The rest of the Value field is private to the vendor.",
      "ja": "TLVまたはサブTLVは、ベンダー私的使用のための範囲内に収まるタイプを持っている場合、長さは少なくとも4でなければならない、と最初の4つのオクテットは、ネットワークオクテット順に、そのベンダーのSMI民間企業数でなければなりません。 Valueフィールドの残りの部分は、ベンダーにプライベートです。"
    },
    {
      "indent": 3,
      "text": "TLVs and sub-TLVs defined in this document are the following:",
      "ja": "この文書で定義されたTLVとサブのTLVは次のとおりです。"
    },
    {
      "indent": 9,
      "text": "Type       Sub-Type        Value Field\n----       --------        -----------\n   1                       Target FEC Stack\n                1          LDP IPv4 prefix\n                2          LDP IPv6 prefix\n                3          RSVP IPv4 LSP\n                4          RSVP IPv6 LSP\n                5          Not Assigned\n                6          VPN IPv4 prefix\n                7          VPN IPv6 prefix\n                8          L2 VPN endpoint\n                9          \"FEC 128\" Pseudowire (Deprecated)\n               10          \"FEC 128\" Pseudowire\n               11          \"FEC 129\" Pseudowire\n               12          BGP labeled IPv4 prefix\n               13          BGP labeled IPv6 prefix\n               14          Generic IPv4 prefix\n               15          Generic IPv6 prefix\n               16          Nil FEC\n   2                       Downstream Mapping\n   3                       Pad\n   4                       Not Assigned\n   5                       Vendor Enterprise Number\n   6                       Not Assigned\n   7                       Interface and Label Stack\n   8                       Not Assigned\n   9                       Errored TLVs\n           Any value       The TLV not understood\n  10                       Reply TOS Byte",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8. Acknowledgements",
      "section_title": true,
      "ja": "8.謝辞"
    },
    {
      "indent": 3,
      "text": "This document is the outcome of many discussions among many people, including Manoj Leelanivas, Paul Traina, Yakov Rekhter, Der-Hwa Gan, Brook Bailey, Eric Rosen, Ina Minei, Shivani Aggarwal, and Vanson Lim.",
      "ja": "この文書では、ManojさんLeelanivas、ポールTrainaの、ヤコフ・レックター、デア・ファガン、ブルック・ベイリー、エリック・ローゼン、伊那Minei、シヴァーニアガルワル、およびバンソン・リムを含む多くの人々の間で多くの議論の結果です。"
    },
    {
      "indent": 3,
      "text": "The description of the Multipath Information sub-field of the Downstream Mapping TLV was adapted from text suggested by Curtis Villamizar.",
      "ja": "ダウンストリームマッピングTLVのマルチパス情報サブフィールドの説明は、カーティスVillamizarによって提案されたテキストから適応されました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Kireeti Kompella Juniper Networks 1194 N.Mathilda Ave Sunnyvale, CA 94089",
      "ja": "Kireeti Kompellaジュニパーネットワークス1194 N.Mathildaアベニューサニーベール、CA 94089"
    },
    {
      "indent": 3,
      "text": "EMail: kireeti@juniper.net",
      "ja": "メールアドレス：kireeti@juniper.net"
    },
    {
      "indent": 3,
      "text": "George Swallow Cisco Systems 1414 Massachusetts Ave, Boxborough, MA 01719",
      "ja": "ジョージツバメシスコシステムズ1414年マサチューセッツアベニュー、ボックスボロー、MA 01719"
    },
    {
      "indent": 3,
      "text": "Phone: +1 978 936 1398 EMail: swallow@cisco.com",
      "ja": "電話：+1 978 936 1398 Eメール：swallow@cisco.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディタ機能のための資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}