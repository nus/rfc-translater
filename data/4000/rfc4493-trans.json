{
  "title": {
    "text": "RFC 4493 - The AES-CMAC Algorithm",
    "ja": "RFC 4493 - AES-CMACアルゴリズム"
  },
  "number": 4493,
  "created_at": "2019-10-25 19:37:57.951825+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           JH. Song\nRequest for Comments: 4493                                 R. Poovendran\nCategory: Informational                         University of Washington\n                                                                  J. Lee\n                                                     Samsung Electronics\n                                                                T. Iwata\n                                                       Nagoya University\n                                                               June 2006",
      "raw": true
    },
    {
      "indent": 25,
      "text": "The AES-CMAC Algorithm",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The National Institute of Standards and Technology (NIST) has recently specified the Cipher-based Message Authentication Code (CMAC), which is equivalent to the One-Key CBC MAC1 (OMAC1) submitted by Iwata and Kurosawa. This memo specifies an authentication algorithm based on CMAC with the 128-bit Advanced Encryption Standard (AES). This new authentication algorithm is named AES-CMAC. The purpose of this document is to make the AES-CMAC algorithm conveniently available to the Internet Community.",
      "ja": "アメリカ国立標準技術研究所（NIST）は最近、岩田と黒沢が提出したワンキーCBC MAC1（OMAC1）と等価である暗号ベースのメッセージ認証コード（CMAC）を、指定しました。このメモは、128ビットのAdvanced Encryption Standard（AES）をCMACに基づく認証アルゴリズムを指定します。この新しい認証アルゴリズムはAES-CMACと命名されます。このドキュメントの目的は、インターネットコミュニティにAES-CMACアルゴリズムは便利な利用できるようにすることです。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. Specification of AES-CMAC .......................................3\n   2.1. Basic Definitions ..........................................3\n   2.2. Overview ...................................................4\n   2.3. Subkey Generation Algorithm ................................5\n   2.4. MAC Generation Algorithm ...................................7\n   2.5. MAC Verification Algorithm .................................9\n3. Security Considerations ........................................10\n4. Test Vectors ...................................................11\n5. Acknowledgement ................................................12\n6. References .....................................................12\n   6.1. Normative References ......................................12\n   6.2. Informative References ....................................12\nAppendix A. Test Code .............................................14",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The National Institute of Standards and Technology (NIST) has recently specified the Cipher-based Message Authentication Code (CMAC). CMAC [NIST-CMAC] is a keyed hash function that is based on a symmetric key block cipher, such as the Advanced Encryption Standard [NIST-AES]. CMAC is equivalent to the One-Key CBC MAC1 (OMAC1) submitted by Iwata and Kurosawa [OMAC1a, OMAC1b]. OMAC1 is an improvement of the eXtended Cipher Block Chaining mode (XCBC) submitted by Black and Rogaway [XCBCa, XCBCb], which itself is an improvement of the basic Cipher Block Chaining-Message Authentication Code (CBC-MAC). XCBC efficiently addresses the security deficiencies of CBC-MAC, and OMAC1 efficiently reduces the key size of XCBC.",
      "ja": "アメリカ国立標準技術研究所（NIST）は最近、暗号ベースのメッセージ認証コード（CMAC）を指定しています。 CMAC [NIST-CMACは、このような高度暗号化標準[NIST-AES]として対称鍵ブロック暗号に基づく鍵付きハッシュ関数です。 CMACは岩田と黒沢[OMAC1a、OMAC1b]によって提出された一つのキーCBC MAC1（OMAC1）と等価です。 OMAC1自体は基本的な暗号ブロック連鎖、メッセージ認証コード（CBC-MAC）の改良である黒とRogaway [XCBCa、XCBCb]によって提出拡張暗​​号ブロック連鎖モード（XCBC）の改良です。 XCBCは、効率的にCBC-MACのセキュリティ上の欠陥に対処し、そしてOMAC1を効率的XCBCのキーサイズを削減します。"
    },
    {
      "indent": 3,
      "text": "AES-CMAC provides stronger assurance of data integrity than a checksum or an error-detecting code. The verification of a checksum or an error-detecting code detects only accidental modifications of the data, while CMAC is designed to detect intentional, unauthorized modifications of the data, as well as accidental modifications.",
      "ja": "AES-CMACは、チェックサムまたは誤り検出符号よりも、データの整合性の強力な保証を提供します。 CMACがデータの意図的な不正変更、ならびに偶発的な変更を検出するように設計されているチェックサムまたは誤り検出符号の検証は、データの唯一の偶発的変更を検出します。"
    },
    {
      "indent": 3,
      "text": "AES-CMAC achieves a security goal similar to that of HMAC [RFC-HMAC]. Since AES-CMAC is based on a symmetric key block cipher, AES, and HMAC is based on a hash function, such as SHA-1, AES-CMAC is appropriate for information systems in which AES is more readily available than a hash function.",
      "ja": "AES-CMACは、HMAC [RFC-HMAC]と同様のセキュリティ目標を達成しています。 AES-CMACは、対称鍵ブロック暗号に基づいているので、AES、およびHMACは、例えばSHA-1などのハッシュ関数に基づいており、AES-CMACは、AESは、ハッシュ関数よりも容易に入手可能である情報システムに適しています。"
    },
    {
      "indent": 3,
      "text": "This memo specifies the authentication algorithm based on CMAC with AES-128. This new authentication algorithm is named AES-CMAC.",
      "ja": "このメモは、AES-128でCMACに基づく認証アルゴリズムを指定します。この新しい認証アルゴリズムはAES-CMACと命名されます。"
    },
    {
      "indent": 0,
      "text": "2. Specification of AES-CMAC",
      "section_title": true,
      "ja": "AES-CMACの2仕様"
    },
    {
      "indent": 0,
      "text": "2.1. Basic Definitions",
      "section_title": true,
      "ja": "2.1。基本的な定義"
    },
    {
      "indent": 3,
      "text": "The following table describes the basic definitions necessary to explain the specification of AES-CMAC.",
      "ja": "次の表は、AES-CMACの仕様を説明するのに必要な基本的な定義を説明しています。"
    },
    {
      "indent": 3,
      "text": "x || y Concatenation. x || y is the string x concatenated with the string y. 0000 || 1111 is 00001111.",
      "ja": "X || yの連結。 X || Yは、文字列Yと連結ストリングXあります。 0000 || 1111は00001111です。"
    },
    {
      "indent": 3,
      "text": "x XOR y Exclusive-OR operation. For two equal length strings, x and y, x XOR y is their bit-wise exclusive-OR.",
      "ja": "X XOR yを排他的論理和。二つの等しい長さの文字列、XおよびYは、XのXOR yは、それらのビット単位の排他的論理和です。"
    },
    {
      "indent": 3,
      "text": "ceil(x) Ceiling function. The smallest integer no smaller than x. ceil(3.5) is 4. ceil(5) is 5.",
      "ja": "CEIL（x）は天井関数。 xより小さくない最小の整数。 CEIL（3.5）は4 CEIL（5）5です。"
    },
    {
      "indent": 3,
      "text": "x << 1 Left-shift of the string x by 1 bit. The most significant bit disappears, and a zero comes into the least significant bit. 10010001 << 1 is 00100010.",
      "ja": "X << 1ビット列xの1左シフト。最上位ビットが消え、ゼロは最下位ビットになります。 10010001 << 1は00100010です。"
    },
    {
      "indent": 3,
      "text": "0^n The string that consists of n zero-bits. 0^3 means 000 in binary format. 10^4 means 10000 in binary format. 10^i means 1 followed by i-times repeated zeros.",
      "ja": "0 ^ N Nゼロビットからなる文字列。 0 ^ 3バイナリ形式で000を意味します。 ^ 4 10は、バイナリ形式で10000を意味します。 10 ^ iが続く1のi回繰り返しゼロを意味します。"
    },
    {
      "indent": 3,
      "text": "MSB(x) The most-significant bit of the string x. MSB(10010000) means 1.",
      "ja": "MSB（x）は、文字列xの最上位ビット。 MSB（10010000）が1を意味します。"
    },
    {
      "indent": 3,
      "text": "padding(x) 10^i padded output of input x. It is described in detail in section 2.4.",
      "ja": "パディング（x）は10 ^ iが入力xの出力を埋め。これは、2.4節に詳細に記載されています。"
    },
    {
      "indent": 3,
      "text": "Key 128-bit (16-octet) long key for AES-128. Denoted by K.",
      "ja": "AES-128のためのキーの128ビット（16オクテット）の長キー。 K.によって示されます"
    },
    {
      "indent": 3,
      "text": "First subkey 128-bit (16-octet) long first subkey, derived through the subkey generation algorithm from the key K. Denoted by K1.",
      "ja": "K1によって鍵K表さからサブキーの生成アルゴリズムを介して導出された第1のサブキー128ビット（16オクテット）長最初のサブキー。"
    },
    {
      "indent": 3,
      "text": "Second subkey 128-bit (16-octet) long second subkey, derived through the subkey generation algorithm from the key K. Denoted by K2.",
      "ja": "K2によって鍵K表さからサブキーの生成アルゴリズムを介して誘導される第二のサブキー128ビット（16オクテット）長秒サブキー。"
    },
    {
      "indent": 3,
      "text": "Message A message to be authenticated. Denoted by M. The message can be null, which means that the length of M is 0.",
      "ja": "メッセージのメッセージが認証されます。 M.で示されるメッセージは、Mの長さが0であることを意味し、nullにすることができます。"
    },
    {
      "indent": 3,
      "text": "Message length The length of the message M in octets. Denoted by len. The minimum value of the length can be 0. The maximum value of the length is not specified in this document.",
      "ja": "メッセージの長さオクテットのメッセージMの長さ。 lenで示されます。長さの最大値は、この文書で指定されていない0の長さの最小値とすることができます。"
    },
    {
      "indent": 3,
      "text": "AES-128(K,M) AES-128(K,M) is the 128-bit ciphertext of AES-128 for a 128-bit key, K, and a 128-bit message, M.",
      "ja": "AES-128（K、M）、AES-128（K、M）は、128ビット鍵、K、及び128ビットのメッセージのためのAES-128の128ビットの暗号文であり、M."
    },
    {
      "indent": 3,
      "text": "MAC A 128-bit string that is the output of AES-CMAC. Denoted by T. Validating the MAC provides assurance of the integrity and authenticity of the message from the source.",
      "ja": "MAC AES-CMACの出力である128ビットのストリング。 MACの検証T.で表さソースからのメッセージの完全性と真正性の保証を提供します。"
    },
    {
      "indent": 3,
      "text": "MAC length By default, the length of the output of AES-CMAC is 128 bits. It is possible to truncate the MAC. The result of the truncation should be taken in most significant bits first order. The MAC length must be specified before the communication starts, and it must not be changed during the lifetime of the key.",
      "ja": "デフォルトではMACの長さは、AES-CMACの出力の長さは128ビットです。 MACを切り捨てることが可能です。切り捨ての結果は、最上位ビット最初の順番に注意が必要です。通信を開始する前に、MACの長さを指定する必要があり、それは、キーの有効期間中に変更されてはなりません。"
    },
    {
      "indent": 0,
      "text": "2.2. Overview",
      "section_title": true,
      "ja": "2.2。概要"
    },
    {
      "indent": 3,
      "text": "AES-CMAC uses the Advanced Encryption Standard [NIST-AES] as a building block. To generate a MAC, AES-CMAC takes a secret key, a message of variable length, and the length of the message in octets as inputs and returns a fixed-bit string called a MAC.",
      "ja": "AES-CMACは、ビルディングブロックとしてのAdvanced Encryption Standard [NIST-AES]を使用しています。 MACを生成するために、AES-CMACは、入力として、秘密鍵、可変長のメッセージ、及びオクテットでメッセージの長さを取得し、MACと呼ばれる固定ビット列を返します。"
    },
    {
      "indent": 3,
      "text": "The core of AES-CMAC is the basic CBC-MAC. For a message, M, to be authenticated, the CBC-MAC is applied to M. There are two cases of operation in CMAC. Figure 2.1 illustrates the operation of CBC-MAC in both cases. If the size of the input message block is equal to a positive multiple of the block size (namely, 128 bits), the last block shall be exclusive-OR'ed with K1 before processing. Otherwise, the last block shall be padded with 10^i (notation is described in section 2.1) and exclusive-OR'ed with K2. The result of the previous",
      "ja": "AES-CMACのコアは、基本的なCBC-MACです。メッセージMは、認証されるために、CBC-MACは、CMACの動作の2例があるMに印加されます。図2.1は、両方の場合においてCBC-MACの動作を示します。入力メッセージブロックのサイズは、ブロックサイズ（すなわち、128ビット）の正の倍数に等しい場合、最後のブロックは、排他的論理和演算処理の前K1としなければなりません。そうでない場合、最後のブロックは、10 ^ I（表記は、セクション2.1に記載されている）とK2との排他的論理和演算で埋めなければなりません。前回の結果"
    },
    {
      "indent": 3,
      "text": "process will be the input of the last encryption. The output of AES-CMAC provides data integrity of the whole input message.",
      "ja": "このプロセスは、最後の暗号化の入力となります。 AES-CMACの出力は、全入力メッセージのデータ保全性を提供します。"
    },
    {
      "indent": 1,
      "text": "+-----+     +-----+     +-----+     +-----+     +-----+     +---+----+\n| M_1 |     | M_2 |     | M_n |     | M_1 |     | M_2 |     |M_n|10^i|\n+-----+     +-----+     +-----+     +-----+     +-----+     +---+----+\n   |           |           |   +--+    |           |           |   +--+\n   |     +--->(+)    +--->(+)<-|K1|    |     +--->(+)    +--->(+)<-|K2|\n   |     |     |     |     |   +--+    |     |     |     |     |   +--+\n+-----+  |  +-----+  |  +-----+     +-----+  |  +-----+  |  +-----+\n|AES_K|  |  |AES_K|  |  |AES_K|     |AES_K|  |  |AES_K|  |  |AES_K|\n+-----+  |  +-----+  |  +-----+     +-----+  |  +-----+  |  +-----+\n   |     |     |     |     |           |     |     |     |     |\n   +-----+     +-----+     |           +-----+     +-----+     |\n                           |                                   |\n                        +-----+                              +-----+\n                        |  T  |                              |  T  |\n                        +-----+                              +-----+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "(a) positive multiple block length (b) otherwise",
      "ja": "（a）は正の複数のブロックの長さ（B）そうでなければ"
    },
    {
      "indent": 10,
      "text": "Figure 2.1. Illustration of the two cases of AES-CMAC",
      "ja": "図2.1。 AES-CMACの2例イラスト"
    },
    {
      "indent": 3,
      "text": "AES_K is AES-128 with key K. The message M is divided into blocks M_1,...,M_n, where M_i is the i-th message block. The length of M_i is 128 bits for i = 1,...,n-1, and the length of the last block, M_n, is less than or equal to 128 bits. K1 is the subkey for the case (a), and K2 is the subkey for the case (b). K1 and K2 are generated by the subkey generation algorithm described in section 2.3.",
      "ja": "AES_Kは、AES-128鍵KとMがM_Iは、i番目のメッセージブロックであるブロックM_1、...、M_n、に分割されるメッセージです。 M_Iの長さは128ビットであり、I = 1、...、N-1、及び最後のブロック、M_nの長さより小さいか128ビットに等しいです。 K1は（a）の場合のサブキーであり、K2は、ケース（B）のサブキーです。 K1及びK2は、セクション2.3に記載のサブキー生成アルゴリズムによって生成されます。"
    },
    {
      "indent": 0,
      "text": "2.3. Subkey Generation Algorithm",
      "section_title": true,
      "ja": "2.3。サブキーの生成アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The subkey generation algorithm, Generate_Subkey(), takes a secret key, K, which is just the key for AES-128.",
      "ja": "サブキーの生成アルゴリズムは、Generate_Subkey（）は、AES-128のためだけの鍵である秘密鍵Kをとります。"
    },
    {
      "indent": 3,
      "text": "The outputs of the subkey generation algorithm are two subkeys, K1 and K2. We write (K1,K2) := Generate_Subkey(K).",
      "ja": "サブキー生成アルゴリズムの出力は2つのサブキー、K1およびK2あります。 = Generate_Subkey（K）：私たちは（K1、K2）を書き込みます。"
    },
    {
      "indent": 3,
      "text": "Subkeys K1 and K2 are used in both MAC generation and MAC verification algorithms. K1 is used for the case where the length of the last block is equal to the block length. K2 is used for the case where the length of the last block is less than the block length.",
      "ja": "サブキーK1およびK2は、MAC生成とMAC検証アルゴリズムの両方で使用されています。 K1は、最後のブロックの長さがブロック長と等しい場合に使用されます。 K2は、最後のブロックの長さがブロック長未満である場合に使用されます。"
    },
    {
      "indent": 3,
      "text": "Figure 2.2 specifies the subkey generation algorithm.",
      "ja": "図2.2は、サブキー生成アルゴリズムを指定します。"
    },
    {
      "indent": 3,
      "text": "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+                    Algorithm Generate_Subkey                      +\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+                                                                   +\n+   Input    : K (128-bit key)                                      +\n+   Output   : K1 (128-bit first subkey)                            +\n+              K2 (128-bit second subkey)                           +\n+-------------------------------------------------------------------+\n+                                                                   +\n+   Constants: const_Zero is 0x00000000000000000000000000000000     +\n+              const_Rb   is 0x00000000000000000000000000000087     +\n+   Variables: L          for output of AES-128 applied to 0^128    +\n+                                                                   +\n+   Step 1.  L := AES-128(K, const_Zero);                           +\n+   Step 2.  if MSB(L) is equal to 0                                +\n+            then    K1 := L << 1;                                  +\n+            else    K1 := (L << 1) XOR const_Rb;                   +\n+   Step 3.  if MSB(K1) is equal to 0                               +\n+            then    K2 := K1 << 1;                                 +\n+            else    K2 := (K1 << 1) XOR const_Rb;                  +\n+   Step 4.  return K1, K2;                                         +\n+                                                                   +\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 2.2. Algorithm Generate_Subkey",
      "ja": "図2.2。アルゴリズムGenerate_Subkey"
    },
    {
      "indent": 3,
      "text": "In step 1, AES-128 with key K is applied to an all-zero input block.",
      "ja": "ステップ1では、AES-128鍵Kとは、すべてのゼロ入力ブロックに適用されます。"
    },
    {
      "indent": 3,
      "text": "In step 2, K1 is derived through the following operation:",
      "ja": "ステップ2において、K1は、以下の操作を介して導かれます。"
    },
    {
      "indent": 3,
      "text": "If the most significant bit of L is equal to 0, K1 is the left-shift of L by 1 bit.",
      "ja": "Lの最上位ビットが0に等しい場合、K1は1ビットLの左シフトです。"
    },
    {
      "indent": 3,
      "text": "Otherwise, K1 is the exclusive-OR of const_Rb and the left-shift of L by 1 bit.",
      "ja": "そうでない場合には、K1はconst_Rbの排他的論理和と1ビットLの左シフトです。"
    },
    {
      "indent": 3,
      "text": "In step 3, K2 is derived through the following operation:",
      "ja": "ステップ3において、K2は、以下の操作を介して導かれます。"
    },
    {
      "indent": 3,
      "text": "If the most significant bit of K1 is equal to 0, K2 is the left-shift of K1 by 1 bit.",
      "ja": "K1の最上位ビットが0に等しい場合、K2は1ビットK1の左シフトです。"
    },
    {
      "indent": 3,
      "text": "Otherwise, K2 is the exclusive-OR of const_Rb and the left-shift of K1 by 1 bit.",
      "ja": "そうでなければ、K2はconst_Rbの排他的論理和と1ビットK1の左シフトです。"
    },
    {
      "indent": 3,
      "text": "In step 4, (K1,K2) := Generate_Subkey(K) is returned.",
      "ja": "ステップ4において、（K1、K2）= Generate_Subkey（K）が返されます。"
    },
    {
      "indent": 3,
      "text": "The mathematical meaning of the procedures in steps 2 and 3, including const_Rb, can be found in [OMAC1a].",
      "ja": "const_Rb含むステップ2および3の手順の数学的な意味は、[OMAC1a]に見出すことができます。"
    },
    {
      "indent": 0,
      "text": "2.4. MAC Generation Algorithm",
      "section_title": true,
      "ja": "2.4。 MAC生成アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The MAC generation algorithm, AES-CMAC(), takes three inputs, a secret key, a message, and the length of the message in octets. The secret key, denoted by K, is just the key for AES-128. The message and its length in octets are denoted by M and len, respectively. The message M is denoted by the sequence of M_i, where M_i is the i-th message block. That is, if M consists of n blocks, then M is written as",
      "ja": "MAC生成アルゴリズム、AES-CMAC（）は、三つの入力、秘密鍵、メッセージ、およびオクテット内のメッセージの長さをとります。 Kで示される秘密鍵は、AES-128のためだけの鍵です。オクテット内のメッセージと、その長さは、それぞれ、Mとlenで示されています。メッセージMは、M_Iがi番目のメッセージブロックであるM_Iの配列によって示されます。つまり、Mは、N個のブロックで構成されている場合、その後、Mは次のように書かれている、です"
    },
    {
      "indent": 4,
      "text": "- M = M_1 || M_2 || ... || M_{n-1} || M_n",
      "ja": " -  M = M_1 || M_2 || ... || M_ {N-1} || M_n"
    },
    {
      "indent": 3,
      "text": "The length of M_i is 128 bits for i = 1,...,n-1, and the length of the last block M_n is less than or equal to 128 bits.",
      "ja": "M_Iの長さは128ビットであり、I = 1、...、N-1、及びM_nがより小さいか128ビットに等しく、最後のブロックの長さ。"
    },
    {
      "indent": 3,
      "text": "The output of the MAC generation algorithm is a 128-bit string, called a MAC, which is used to validate the input message. The MAC is denoted by T, and we write T := AES-CMAC(K,M,len). Validating the MAC provides assurance of the integrity and authenticity of the message from the source.",
      "ja": "MAC生成アルゴリズムの出力は、入力されたメッセージを検証するために使用されるMACと呼ばれる128ビットの列、です。 MACをT、我々はTを記述されている：= AES-CMAC（K、M、LEN）。 MACの検証は、ソースからのメッセージの完全性と真正性の保証を提供します。"
    },
    {
      "indent": 3,
      "text": "It is possible to truncate the MAC. According to [NIST-CMAC], at least a 64-bit MAC should be used as protection against guessing attacks. The result of truncation should be taken in most significant bits first order.",
      "ja": "MACを切り捨てることが可能です。 [NIST-CMAC]によれば、少なくとも64ビットMACは、推測攻撃に対する保護として使用されるべきです。切り捨ての結果は、最上位ビット最初の順番に注意が必要です。"
    },
    {
      "indent": 3,
      "text": "The block length of AES-128 is 128 bits (16 octets). There is a special treatment if the length of the message is not a positive multiple of the block length. The special treatment is to pad M with the bit-string 10^i to adjust the length of the last block up to the block length.",
      "ja": "AES-128のブロック長は128ビット（16オクテット）です。メッセージの長さがブロック長の正の倍数でない場合は、特別な治療法があります。特別な治療がiはブロック長までの最後のブロックの長さを調整するために、ビットストリング10 ^とパッドMです。"
    },
    {
      "indent": 3,
      "text": "For an input string x of r-octets, where 0 <= r < 16, the padding function, padding(x), is defined as follows:",
      "ja": "次のように0 <= R <16、パディング機能、パディング（x）は、定義されたR-オクテット、のX入力文字列のための"
    },
    {
      "indent": 3,
      "text": "- padding(x) = x || 10^i where i is 128-8*r-1",
      "ja": " - パディング（X）= Xの||私は128から8 * R-1である10 ^ I"
    },
    {
      "indent": 3,
      "text": "That is, padding(x) is the concatenation of x and a single '1', followed by the minimum number of '0's, so that the total length is equal to 128 bits.",
      "ja": "すなわち、全長が128ビットになるようにパディング（x）は、0年代の最小数続くXの連結と単一「1」です。"
    },
    {
      "indent": 3,
      "text": "Figure 2.3 describes the MAC generation algorithm.",
      "ja": "図2.3は、MAC生成アルゴリズムを説明しています。"
    },
    {
      "indent": 3,
      "text": "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ + Algorithm AES-CMAC + +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ + + + Input : K ( 128-bit key ) + + : M ( message to be authenticated ) + + : len ( length of the message in octets ) + + Output : T ( message authentication code ) + + + +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ + Constants: const_Zero is 0x00000000000000000000000000000000 + + const_Bsize is 16 + + + + Variables: K1, K2 for 128-bit subkeys + + M_i is the i-th block (i=1..ceil(len/const_Bsize)) + + M_last is the last block xor-ed with K1 or K2 + + n for number of blocks to be processed + + r for number of octets of last block + + flag for denoting if last block is complete or not + + + + Step 1. (K1,K2) := Generate_Subkey(K); + + Step 2. n := ceil(len/const_Bsize); + + Step 3. if n = 0 + + then + + n := 1; + + flag := false; + + else + + if len mod const_Bsize is 0 + + then flag := true; + + else flag := false; + + + + Step 4. if flag is true + + then M_last := M_n XOR K1; + + else M_last := padding(M_n) XOR K2; + + Step 5. X := const_Zero; + + Step 6. for i := 1 to n-1 do + + begin + + Y := X XOR M_i; + + X := AES-128(K,Y); + + end + + Y := M_last XOR X; + + T := AES-128(K,Y); + + Step 7. return T; + +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++",
      "ja": "++++++++++++++++++++++++++++++++++++++++++++++++++ +++++++++++++++++++ +アルゴリズムAES-CMAC + +++++++++++++++++++++++++ ++++++++++++++++++++++++++++++++++++++++++++ + + +入力：K （128ビットのキー）+ +：M（メッセージが認証される）+ +：LEN（オクテットでのメッセージの長さ）+ +出力：T（メッセージ認証コード）+ + + +++++++++ ++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++ +定数：const_Zeroは0x00000000000000000000000000000000 + + const_Bsize 16個の+ + + +変数である：K1、K2 128ビットサブキーの+ + M_Iは、i番目のブロック（I = 1であります.. CEILは、（lenが/ const_Bsize））+ + M_lastは、最後のブロックを表すために、最後のブロック+ +フラグのオクテット数のK1またはK2 + + n個のブロックの数のために処理されるべき+ + rの最後のブロックのXOR演算である場合完全かどうか+ + + +ステップ1（K1、K2）= Generate_Subkey（K）。 + +ステップ2：N = CEIL（LEN / const_Bsize）。 + +ステップ3であれば、N = 0 + +、その後+ + N = 1。 + +フラグ：= FALSE; + +他+ + lenのMOD const_Bsize 0 + +その後のフラグである場合：= TRUE; + +他のフラグ：= falseは、 + + + +ステップ4フラグが真であれば+ +次にM_last：= M_n XOR K1。 + +他M_last：=パディング（M_n）XORのK2。 + +ステップ5 X：= const_Zero。私のために+ +ステップ6：= 1〜N-1に+ +始めるん+ + Y：= X XOR M_I。 + + X：= AES-128（K、Y）。 + +エンド+ + Y：= M_last XOR X。 + + T：= AES-128（K、Y）。 + +工程7.リターンT。 + +++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++++++++++++++"
    },
    {
      "indent": 22,
      "text": "Figure 2.3. Algorithm AES-CMAC",
      "ja": "図2.3。アルゴリズムAES-CMAC"
    },
    {
      "indent": 3,
      "text": "In step 1, subkeys K1 and K2 are derived from K through the subkey generation algorithm.",
      "ja": "ステップ1において、サブキーK1およびK2は、サブキーの生成アルゴリズムを介してKから誘導されます。"
    },
    {
      "indent": 3,
      "text": "In step 2, the number of blocks, n, is calculated. The number of blocks is the smallest integer value greater than or equal to the quotient determined by dividing the length parameter by the block length, 16 octets.",
      "ja": "ステップ2では、ブロックの数は、nは、計算されます。ブロックの数は、ブロック長、16オクテットの長さパラメータを割ることによって決定商の最小の整数値以上です。"
    },
    {
      "indent": 3,
      "text": "In step 3, the length of the input message is checked. If the input length is 0 (null), the number of blocks to be processed shall be 1, and the flag shall be marked as not-complete-block (false). Otherwise, if the last block length is 128 bits, the flag is marked as complete-block (true); else mark the flag as not-complete-block (false).",
      "ja": "ステップ3において、入力メッセージの長さがチェックされます。入力の長さが0（ヌル）である場合、処理対象のブロックの数は1でなければならない、及びフラグが（偽）、完了していないブロックとしてマークされなければなりません。最後のブロック長が128ビットである場合にそうでない場合、フラグは完全ブロック（真）としてマークされます。他にはない完全ブロック（偽）としてフラグをマーク。"
    },
    {
      "indent": 3,
      "text": "In step 4, M_last is calculated by exclusive-OR'ing M_n and one of the previously calculated subkeys. If the last block is a complete block (true), then M_last is the exclusive-OR of M_n and K1. Otherwise, M_last is the exclusive-OR of padding(M_n) and K2.",
      "ja": "ステップ4において、M_lastは、排他的OR接続M_nと以前に計算サブキーのいずれかによって計算されます。最後のブロックは完全なブロック（真）の場合、M_lastはM_nとK1の排他的論理和です。それ以外の場合は、M_lastはパディングの排他的論理和（M_n）およびK2です。"
    },
    {
      "indent": 3,
      "text": "In step 5, the variable X is initialized.",
      "ja": "ステップ5では、変数Xが初期化されます。"
    },
    {
      "indent": 3,
      "text": "In step 6, the basic CBC-MAC is applied to M_1,...,M_{n-1},M_last.",
      "ja": "ステップ6において、基本的なCBC-MACをM_1に適用され、...、M_ {N-1}、M_last。"
    },
    {
      "indent": 3,
      "text": "In step 7, the 128-bit MAC, T := AES-CMAC(K,M,len), is returned.",
      "ja": "ステップ7において、128ビットのMAC、T：= AES-CMAC（K、M、LEN）、返されます。"
    },
    {
      "indent": 3,
      "text": "If necessary, the MAC is truncated before it is returned.",
      "ja": "必要であればそれが返される前に、MACは切り捨てられます。"
    },
    {
      "indent": 0,
      "text": "2.5. MAC Verification Algorithm",
      "section_title": true,
      "ja": "2.5。 MAC検証アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The verification of the MAC is simply done by a MAC recomputation. We use the MAC generation algorithm, which is described in section 2.4.",
      "ja": "MACの検証は、単純にMACの再計算によって行われます。私たちは、セクション2.4で説明されたMAC生成アルゴリズムを使用します。"
    },
    {
      "indent": 3,
      "text": "The MAC verification algorithm, Verify_MAC(), takes four inputs, a secret key, a message, the length of the message in octets, and the received MAC. These are denoted by K, M, len, and T', respectively.",
      "ja": "MAC検証アルゴリズムは、Verify_MAC（）、4つの入力、秘密鍵、メッセージ、オクテット内のメッセージの長さ、および受信されたMACをとります。これらは、それぞれ、「K、M、LEN、およびTで示されています。"
    },
    {
      "indent": 3,
      "text": "The output of the MAC verification algorithm is either INVALID or VALID.",
      "ja": "MAC検証アルゴリズムの出力は、INVALIDまたはVALIDのいずれかです。"
    },
    {
      "indent": 3,
      "text": "Figure 2.4 describes the MAC verification algorithm.",
      "ja": "図2.4は、MAC検証アルゴリズムを説明します。"
    },
    {
      "indent": 3,
      "text": "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+                      Algorithm Verify_MAC                         +\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+                                                                   +\n+   Input    : K    ( 128-bit Key )                                 +\n+            : M    ( message to be verified )                      +\n+            : len  ( length of the message in octets )             +\n+            : T'   ( the received MAC to be verified )             +\n+   Output   : INVALID or VALID                                     +\n+                                                                   +\n+-------------------------------------------------------------------+\n+                                                                   +\n+   Step 1.  T* := AES-CMAC(K,M,len);                               +\n+   Step 2.  if T* is equal to T'                                   +\n+            then                                                   +\n+                 return VALID;                                     +\n+            else                                                   +\n+                 return INVALID;                                   +\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 2.4. Algorithm Verify_MAC",
      "ja": "図2.4。アルゴリズムVerify_MAC"
    },
    {
      "indent": 3,
      "text": "In step 1, T* is derived from K, M, and len through the MAC generation algorithm.",
      "ja": "ステップ1において、T *はK、Mから誘導され、MAC生成アルゴリズムを介したlen。"
    },
    {
      "indent": 3,
      "text": "In step 2, T* and T' are compared. If T* is equal to T', then return VALID; otherwise return INVALID.",
      "ja": "ステップ2において、T *及びT」が比較されます。 T *は「Tに等しい場合、有効な戻り。そうでない場合は無効な戻り。"
    },
    {
      "indent": 3,
      "text": "If the output is INVALID, then the message is definitely not authentic, i.e., it did not originate from a source that executed the generation process on the message to produce the purported MAC.",
      "ja": "出力が無効な場合、メッセージは間違いなく本物ではない、すなわち、それが主張MACを生成するためにメッセージに生成処理を実行ソースに由来しませんでした。"
    },
    {
      "indent": 3,
      "text": "If the output is VALID, then the design of the AES-CMAC provides assurance that the message is authentic and, hence, was not corrupted in transit; however, this assurance, as for any MAC algorithm, is not absolute.",
      "ja": "出力が有効である場合、AES-CMACの設計は、メッセージが本物と、したがって、輸送中に破損していないであることを保証します。しかし、この保証は、任意のMACアルゴリズムのように、絶対的ではありません。"
    },
    {
      "indent": 0,
      "text": "3. Security Considerations",
      "section_title": true,
      "ja": "3.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The security provided by AES-CMAC is built on the strong cryptographic algorithm AES. However, as is true with any cryptographic algorithm, part of its strength lies in the secret key, K, and the correctness of the implementation in all of the participating systems. If the secret key is compromised or inappropriately shared, it guarantees neither authentication nor integrity of message at all. The secret key shall be generated in a way that meets the pseudo randomness requirement of RFC 4086 [RFC4086] and should be kept safe. If and only if AES-CMAC is used",
      "ja": "AES-CMACによって提供されるセキュリティは、強力な暗号化アルゴリズムAESの上に構築されています。任意の暗号化アルゴリズムと真であるしかし、その強さの一部は、秘密鍵、K、および参加システムのすべてにおける実装の正確さにあります。秘密鍵が危殆化または不適切に共有されている場合、それは全くのメッセージのどちらも認証や完全性を保証します。秘密鍵は、RFC 4086の擬似ランダム性の要件を満たしている方法[RFC4086]で生成されるものとし、安全に保管する必要があります。 AES-CMACが使用されている場合にのみ、"
    },
    {
      "indent": 3,
      "text": "properly it provides the authentication and integrity that meet the best current practice of message authentication.",
      "ja": "適切には、メッセージ認証の現在のベストプラクティスを満たした認証と完全性を提供します。"
    },
    {
      "indent": 0,
      "text": "4. Test Vectors",
      "section_title": true,
      "ja": "4.テストベクトル"
    },
    {
      "indent": 3,
      "text": "The following test vectors are the same as those of [NIST-CMAC]. The following vectors are also the output of the test program in Appendix A.",
      "ja": "次のテストベクトルは[NIST-CMAC]のものと同じです。以下のベクターはまた、付録Aのテストプログラムの出力です"
    },
    {
      "indent": 3,
      "text": "--------------------------------------------------\nSubkey Generation\nK              2b7e1516 28aed2a6 abf71588 09cf4f3c\nAES-128(key,0) 7df76b0c 1ab899b3 3e42f047 b91b546f\nK1             fbeed618 35713366 7c85e08f 7236a8de\nK2             f7ddac30 6ae266cc f90bc11e e46d513b\n--------------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "--------------------------------------------------\nExample 1: len = 0\nM              <empty string>\nAES-CMAC       bb1d6929 e9593728 7fa37d12 9b756746\n--------------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Example 2: len = 16\nM              6bc1bee2 2e409f96 e93d7e11 7393172a\nAES-CMAC       070a16b4 6b4d4144 f79bdd9d d04a287c\n--------------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Example 3: len = 40\nM              6bc1bee2 2e409f96 e93d7e11 7393172a\n               ae2d8a57 1e03ac9c 9eb76fac 45af8e51\n               30c81c46 a35ce411\nAES-CMAC       dfa66747 de9ae630 30ca3261 1497c827\n--------------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Example 4: len = 64\nM              6bc1bee2 2e409f96 e93d7e11 7393172a\n               ae2d8a57 1e03ac9c 9eb76fac 45af8e51\n               30c81c46 a35ce411 e5fbc119 1a0a52ef\n               f69f2445 df4f9b17 ad2b417b e66c3710\nAES-CMAC       51f0bebf 7e3b9d92 fc497417 79363cfe\n--------------------------------------------------",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. Acknowledgement",
      "section_title": true,
      "ja": "5.謝辞"
    },
    {
      "indent": 3,
      "text": "Portions of the text herein are borrowed from [NIST-CMAC]. We appreciate the OMAC1 authors, the SP 800-38B author, and Russ Housley for his useful comments and guidance, which have been incorporated herein. We also thank Alfred Hoenes for many useful comments. This memo was prepared while Tetsu Iwata was at Ibaraki University, Japan.",
      "ja": "テキストの部分は、本明細書[NIST-CMAC]から借用されています。当社は、本明細書に組み込まれている彼の有益なコメントと指導のためのOMAC1の作者、SP 800-38Bの著者、とラスHousleyを、感謝しています。我々はまた、多くの有用なコメントをアルフレッドHoenesに感謝します。テツ岩田は茨城大学、日本にいた間、このメモを用意しました。"
    },
    {
      "indent": 3,
      "text": "We acknowledge the support from the following grants: Collaborative Technology Alliance (CTA) from US Army Research Laboratory, DAAD19- 01-2-0011; Presidential Award from Army Research Office, W911NF-05- 1-0491; NSF CAREER ANI-0093187. Results do not reflect any position of the funding agencies.",
      "ja": "私たちは、以下の助成金からの支援認める：US陸軍研究所、DAAD19- 01-2-0011から共同テクノロジーアライアンス（CTA）を、陸軍研究事務所から大統領賞、W911NF-05- 1から0491; NSF CAREER ANI-0093187。結果は、資金提供機関の任意の位置を反映するものではありません。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[NIST-CMAC] NIST, Special Publication 800-38B, \"Recommendation for Block Cipher Modes of Operation: The CMAC Mode for Authentication\", May 2005.",
      "ja": "[NIST-CMAC] NIST、特別な公表800-38B、「操作のブロック暗号モードのための推薦：認証のためのCMACモード」、2005年5月。"
    },
    {
      "indent": 3,
      "text": "[NIST-AES] NIST, FIPS 197, \"Advanced Encryption Standard (AES)\", November 2001. http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf",
      "ja": "[NIST-AES] NIST、FIPS 197、 \"高度暗号化標準（AES）\"、2001年11月http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、3、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC-HMAC] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC-HMAC] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[OMAC1a] Tetsu Iwata and Kaoru Kurosawa, \"OMAC: One-Key CBC MAC\", Fast Software Encryption, FSE 2003, LNCS 2887, pp. 129- 153, Springer-Verlag, 2003.",
      "ja": "[OMAC1a]哲岩田薫黒沢、 \"OMAC：ワンキーCBC MAC\"。、高速ソフトウェア暗号化、FSE 2003、LNCS 2887、頁129- 153、シュプリンガー・フェアラーク、2003。"
    },
    {
      "indent": 3,
      "text": "[OMAC1b] Tetsu Iwata and Kaoru Kurosawa, \"OMAC: One-Key CBC MAC\", Submission to NIST, December 2002. Available from the NIST modes of operation web site at http://csrc.nist.gov/CryptoToolkit/modes/proposedmodes/ omac/omac-spec.pdf",
      "ja": "[OMAC1b]哲岩田薫黒沢、「OMAC：ワンキーCBC MAC」、http://csrc.nist.gov/CryptoToolkit/modes/での操作ウェブサイトのNISTモードから利用できるNIST、2002年12月に提出proposedmodes / OMAC / OMAC-spec.pdf"
    },
    {
      "indent": 3,
      "text": "[XCBCa] John Black and Phillip Rogaway, \"A Suggestion for Handling Arbitrary-Length Messages with the CBC MAC\", NIST Second Modes of Operation Workshop, August 2001. Available from the NIST modes of operation web site at http://csrc.nist.gov/CryptoToolkit/modes/proposedmodes/ xcbc-mac/xcbc-mac-spec.pdf",
      "ja": "[XCBCa]ジョン・ブラックとフィリップ・ロガウェイ、「CBC MACで任意の長さのメッセージを処理するための提案」は、httpでの操作ウェブサイトのNISTモードからオペレーションワークショップ、2001年8月のNIST第二のモードが利用可能：// CSRC。 nist.gov/CryptoToolkit/modes/proposedmodes/ XCBC-MAC / XCBC-MAC-spec.pdf"
    },
    {
      "indent": 3,
      "text": "[XCBCb] John Black and Phillip Rogaway, \"CBC MACs for Arbitrary-Length Messages: The Three-Key Constructions\", Journal of Cryptology, Vol. 18, No. 2, pp. 111-132, Springer-Verlag, Spring 2005.",
      "ja": "[XCBCb]ジョン・ブラックとフィリップ・ロガウェイ、「CBC MACは、任意の長さのメッセージについて：スリーキー構文」、暗号学誌、Vol。 18、第2号、頁111から132、シュプリンガー・フェアラーク、2005年春。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Test Code",
      "ja": "付録A.テストコード"
    },
    {
      "indent": 2,
      "text": "This C source is designed to generate the test vectors that appear in this memo to verify correctness of the algorithm. The source code is not intended for use in commercial products.",
      "ja": "このCソースは、アルゴリズムの正しさを検証するために、このメモに表示されるテストベクトルを生成するように設計されています。ソースコードは、市販の製品で使用するためのものではありません。"
    },
    {
      "indent": 2,
      "text": "/****************************************************************/\n/* AES-CMAC with AES-128 bit                                    */\n/* CMAC     Algorithm described in SP800-38B                    */\n/* Author: Junhyuk Song (junhyuk.song@samsung.com)              */\n/*         Jicheol Lee  (jicheol.lee@samsung.com)               */\n/****************************************************************/",
      "raw": true
    },
    {
      "indent": 2,
      "text": "#include <stdio.h>",
      "ja": "書式#include <stdio.hに>"
    },
    {
      "indent": 2,
      "text": "/* For CMAC Calculation */\nunsigned char const_Rb[16] = {\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87\n};\nunsigned char const_Zero[16] = {\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};",
      "raw": true
    },
    {
      "indent": 2,
      "text": "/* Basic Functions */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void xor_128(unsigned char *a, unsigned char *b, unsigned char *out)\n{\n    int i;\n    for (i=0;i<16; i++)\n    {\n        out[i] = a[i] ^ b[i];\n    }\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void print_hex(char *str, unsigned char *buf, int len) { int i;",
      "ja": "ボイドprint_hexは（するchar * STR、unsigned char型の*のBUF、INT LEN）{iはint型。"
    },
    {
      "indent": 2,
      "text": "    for ( i=0; i<len; i++ ) {\n        if ( (i % 16) == 0 && i != 0 ) printf(str);\n        printf(\"%02x\", buf[i]);\n        if ( (i % 4) == 3 ) printf(\" \");\n        if ( (i % 16) == 15 ) printf(\"\\n\");\n    }\n    if ( (i % 16) != 0 ) printf(\"\\n\");\n} void print128(unsigned char *bytes)\n{\n    int         j;\n    for (j=0; j<16;j++) {\n        printf(\"%02x\",bytes[j]);\n        if ( (j%4) == 3 ) printf(\" \");\n    }\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void print96(unsigned char *bytes)\n{\n    int         j;\n    for (j=0; j<12;j++) {\n        printf(\"%02x\",bytes[j]);\n        if ( (j%4) == 3 ) printf(\" \");\n    }\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "/* AES-CMAC Generation Function */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void leftshift_onebit(unsigned char *input,unsigned char *output)\n{\n    int         i;\n    unsigned char overflow = 0;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "    for ( i=15; i>=0; i-- ) {\n        output[i] = input[i] << 1;\n        output[i] |= overflow;\n        overflow = (input[i] & 0x80)?1:0;\n    }\n    return;\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void generate_subkey(unsigned char *key, unsigned char *K1, unsigned\n                     char *K2)\n{\n    unsigned char L[16];\n    unsigned char Z[16];\n    unsigned char tmp[16];\n    int i;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "for ( i=0; i<16; i++ ) Z[i] = 0;",
      "ja": "用（i = 0; iは16 <; iは++）Z [I] = 0;"
    },
    {
      "indent": 6,
      "text": "AES_128(key,Z,L);",
      "ja": "AES_128（キー、Z、L）。"
    },
    {
      "indent": 6,
      "text": "if ( (L[0] & 0x80) == 0 ) { /* If MSB(L) = 0, then K1 = L << 1 */\n    leftshift_onebit(L,K1);\n} else {    /* Else K1 = ( L << 1 ) (+) Rb */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "    leftshift_onebit(L,tmp);\n    xor_128(tmp,const_Rb,K1);\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "    if ( (K1[0] & 0x80) == 0 ) {\n        leftshift_onebit(K1,K2);\n    } else {\n        leftshift_onebit(K1,tmp);\n        xor_128(tmp,const_Rb,K2);\n    }\n    return;\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void padding ( unsigned char *lastb, unsigned char *pad, int length ) { int j;",
      "ja": "ボイドパディング（unsigned char型の*のlastb、unsigned char型の*パッド、int型の長さ）{int型J。"
    },
    {
      "indent": 2,
      "text": "    /* original last block */\n    for ( j=0; j<16; j++ ) {\n        if ( j < length ) {\n            pad[j] = lastb[j];\n        } else if ( j == length ) {\n            pad[j] = 0x80;\n        } else {\n            pad[j] = 0x00;\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "void AES_CMAC ( unsigned char *key, unsigned char *input, int length,\n                unsigned char *mac )\n{\n    unsigned char       X[16],Y[16], M_last[16], padded[16];\n    unsigned char       K1[16], K2[16];\n    int         n, i, flag;\n    generate_subkey(key,K1,K2);",
      "raw": true
    },
    {
      "indent": 6,
      "text": "n = (length+15) / 16;       /* n is number of rounds */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "if ( n == 0 ) {\n    n = 1;\n    flag = 0;\n} else {\n    if ( (length%16) == 0 ) { /* last block is a complete block */\n        flag = 1;\n    } else { /* last block is not complete block */\n        flag = 0;\n    }",
      "raw": true
    },
    {
      "indent": 6,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 6,
      "text": "if ( flag ) { /* last block is complete block */\n    xor_128(&input[16*(n-1)],K1,M_last);\n} else {\n    padding(&input[16*(n-1)],padded,length%16);\n    xor_128(padded,K2,M_last);\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "for ( i=0; i<16; i++ ) X[i] = 0;\nfor ( i=0; i<n-1; i++ ) {\n    xor_128(X,&input[16*i],Y); /* Y := Mi (+) X  */\n    AES_128(key,Y,X);      /* X := AES-128(KEY, Y); */\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "xor_128(X,M_last,Y);\nAES_128(key,Y,X);",
      "raw": true
    },
    {
      "indent": 2,
      "text": " for ( i=0; i<16; i++ ) { mac[i] = X[i]; } }",
      "ja": "用（i = 0; iは16 <; iは++）{MAC [I] =のX [i]は、 }}"
    },
    {
      "indent": 2,
      "text": "int main()\n{\n    unsigned char L[16], K1[16], K2[16], T[16], TT[12];\n    unsigned char M[64] = {\n        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,\n        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,\n        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,\n        0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,\n        0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10\n    };\n    unsigned char key[16] = {\n        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,\n        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c\n    };",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"--------------------------------------------------\\n\");\nprintf(\"K              \"); print128(key); printf(\"\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"\\nSubkey Generation\\n\");\nAES_128(key,const_Zero,L);\nprintf(\"AES_128(key,0) \"); print128(L); printf(\"\\n\");\ngenerate_subkey(key,K1,K2);",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"K1             \"); print128(K1); printf(\"\\n\");\nprintf(\"K2             \"); print128(K2); printf(\"\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"\\nExample 1: len = 0\\n\");\nprintf(\"M              \"); printf(\"<empty string>\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "AES_CMAC(key,M,0,T);\nprintf(\"AES_CMAC       \"); print128(T); printf(\"\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"\\nExample 2: len = 16\\n\");\nprintf(\"M              \"); print_hex(\"                \",M,16);\nAES_CMAC(key,M,16,T);\nprintf(\"AES_CMAC       \"); print128(T); printf(\"\\n\");\nprintf(\"\\nExample 3: len = 40\\n\");\nprintf(\"M              \"); print_hex(\"               \",M,40);\nAES_CMAC(key,M,40,T);\nprintf(\"AES_CMAC       \"); print128(T); printf(\"\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"\\nExample 4: len = 64\\n\");\nprintf(\"M              \"); print_hex(\"               \",M,64);\nAES_CMAC(key,M,64,T);\nprintf(\"AES_CMAC       \"); print128(T); printf(\"\\n\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "printf(\"--------------------------------------------------\\n\");",
      "raw": true
    },
    {
      "indent": 2,
      "text": " return 0; }",
      "ja": "0を返します。 }"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 2,
      "text": "Junhyuk Song University of Washington Samsung Electronics",
      "ja": "ワシントンサムスン電子のJunhyuk歌大学"
    },
    {
      "indent": 2,
      "text": "Phone: (206) 853-5843 EMail: songlee@ee.washington.edu, junhyuk.song@samsung.com",
      "ja": "電話：（206）853-5843 Eメール：songlee@ee.washington.edu、junhyuk.song@samsung.com"
    },
    {
      "indent": 2,
      "text": "Jicheol Lee Samsung Electronics",
      "ja": "Jicheolリーサムスン電子"
    },
    {
      "indent": 2,
      "text": "Phone: +82-31-279-3605 EMail: jicheol.lee@samsung.com",
      "ja": "電話：+ 82-31-279-3605 Eメール：jicheol.lee@samsung.com"
    },
    {
      "indent": 2,
      "text": "Radha Poovendran Network Security Lab University of Washington",
      "ja": "ワシントンのラダPoovendranネットワークセキュリティラボ大学"
    },
    {
      "indent": 2,
      "text": "Phone: (206) 221-6512 EMail: radha@ee.washington.edu",
      "ja": "電話：（206）221-6512 Eメール：radha@ee.washington.edu"
    },
    {
      "indent": 2,
      "text": "Tetsu Iwata Nagoya University",
      "ja": "てつ いわた なごや うにゔぇｒしｔｙ"
    },
    {
      "indent": 2,
      "text": "EMail: iwata@cse.nagoya-u.ac.jp",
      "ja": "メールアドレス：iwata@cse.nagoya-u.ac.jp"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディタ機能のための資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}