{
  "title": {
    "text": "RFC 4941 - Privacy Extensions for Stateless Address Autoconfiguration in IPv6",
    "ja": "RFC 4941 - IPv6におけるステートレスアドレス自動設定のための個人情報保護の拡張"
  },
  "number": 4941,
  "created_at": "2019-10-29 01:03:42.329571+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          T. Narten\nRequest for Comments: 4941                               IBM Corporation\nObsoletes: 3041                                                R. Draves\nCategory: Standards Track                             Microsoft Research\n                                                             S. Krishnan\n                                                       Ericsson Research\n                                                          September 2007",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Privacy Extensions for Stateless Address Autoconfiguration in IPv6",
      "ja": "IPv6におけるステートレスアドレス自動設定のための個人情報保護の拡張"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Nodes use IPv6 stateless address autoconfiguration to generate addresses using a combination of locally available information and information advertised by routers. Addresses are formed by combining network prefixes with an interface identifier. On an interface that contains an embedded IEEE Identifier, the interface identifier is typically derived from it. On other interface types, the interface identifier is generated through other means, for example, via random number generation. This document describes an extension to IPv6 stateless address autoconfiguration for interfaces whose interface identifier is derived from an IEEE identifier. Use of the extension causes nodes to generate global scope addresses from interface identifiers that change over time, even in cases where the interface contains an embedded IEEE identifier. Changing the interface identifier (and the global scope addresses generated from it) over time makes it more difficult for eavesdroppers and other information collectors to identify when different addresses used in different transactions actually correspond to the same node.",
      "ja": "ノードはローカルで利用可能な情報とルータによってアドバタイズ情報の組み合わせを使用してアドレスを生成するためのIPv6ステートレスアドレス自動設定を使用します。アドレスは、インターフェース識別子とネットワーク・プレフィックスとを組み合わせることによって形成されます。埋め込みIEEE識別子を含むインターフェース上で、インタフェース識別子は、典型的にはそれから誘導されます。他のインタフェースタイプに、インタフェース識別子は、乱数生成を介して、例えば、他の手段によって生成されます。この文書では、インタフェース識別子IEEE識別子から導出されるインターフェイスのIPv6ステートレスアドレス自動設定の拡張を記述しています。拡張の使用は、ノードがあっても、インターフェイスが埋め込まIEEE識別子が含まれている場合には、経時的に変化インタフェース識別子からグローバルスコープのアドレスを生成させます。経時的（そこから生成され、グローバルスコープのアドレス）インタフェース識別子を変更すると、異なるトランザクションに使用される異なるアドレスが実際には同じノードに対応する場合に同定する盗聴者や他の情報収集のためにそれをより困難にします。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n  1.1.  Conventions Used in This Document  . . . . . . . . . . . .  4\n  1.2.  Problem Statement  . . . . . . . . . . . . . . . . . . . .  4\n2.  Background . . . . . . . . . . . . . . . . . . . . . . . . . .  5\n  2.1.  Extended Use of the Same Identifier  . . . . . . . . . . .  5\n  2.2.  Address Usage in IPv4 Today  . . . . . . . . . . . . . . .  6\n  2.3.  The Concern with IPv6 Addresses  . . . . . . . . . . . . .  7\n  2.4.  Possible Approaches  . . . . . . . . . . . . . . . . . . .  8\n3.  Protocol Description . . . . . . . . . . . . . . . . . . . . .  9\n  3.1.  Assumptions  . . . . . . . . . . . . . . . . . . . . . . . 10\n  3.2.  Generation of Randomized Interface Identifiers . . . . . . 10\n    3.2.1.  When Stable Storage Is Present . . . . . . . . . . . . 11\n    3.2.2.  In The Absence of Stable Storage . . . . . . . . . . . 12\n    3.2.3.  Alternate Approaches . . . . . . . . . . . . . . . . . 12\n  3.3.  Generating Temporary Addresses . . . . . . . . . . . . . . 13\n  3.4.  Expiration of Temporary Addresses  . . . . . . . . . . . . 14\n  3.5.  Regeneration of Randomized Interface Identifiers . . . . . 15\n  3.6.  Deployment Considerations  . . . . . . . . . . . . . . . . 16\n4.  Implications of Changing Interface Identifiers . . . . . . . . 17\n5.  Defined Constants  . . . . . . . . . . . . . . . . . . . . . . 18\n6.  Future Work  . . . . . . . . . . . . . . . . . . . . . . . . . 18\n7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 19\n8.  Significant Changes from RFC 3041  . . . . . . . . . . . . . . 19\n9.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 20\n10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n  10.1. Normative References . . . . . . . . . . . . . . . . . . . 20\n  10.2. Informative References . . . . . . . . . . . . . . . . . . 20",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Stateless address autoconfiguration [ADDRCONF] defines how an IPv6 node generates addresses without the need for a Dynamic Host Configuration Protocol for IPv6 (DHCPv6) server. Some types of network interfaces come with an embedded IEEE Identifier (i.e., a link-layer MAC address), and in those cases, stateless address autoconfiguration uses the IEEE identifier to generate a 64-bit interface identifier [ADDRARCH]. By design, the interface identifier is likely to be globally unique when generated in this fashion. The interface identifier is in turn appended to a prefix to form a 128-bit IPv6 address. Note that an IPv6 identifier does not necessarily have to be 64 bits in length, but the algorithm specified in this document is targeted towards 64-bit interface identifiers.",
      "ja": "ステートレスアドレス自動設定は[ADDRCONF] IPv6ノードがIPv6（DHCPv6の）サーバーの動的ホスト構成プロトコルを必要とせずにアドレスを生成する方法を定義します。ネットワークインターフェースのいくつかのタイプは、埋め込みIEEE識別子（すなわち、リンク層のMACアドレス）が付属して、それらの場合には、ステートレスアドレス自動設定は、64ビットのインタフェース識別子[ADDRARCH]を生成するために、IEEE識別子を使用します。この方法で生成されたときに設計することで、インタフェース識別子は、グローバルに一意である可能性が高いです。インタフェース識別子は、次に、128ビットのIPv6アドレスを形成するために、プレフィックスに付加されます。 IPv6の識別子は、必ずしも長さが64ビットである必要はないことに留意されたいが、この文書で指定されたアルゴリズムは、64ビットのインタフェース識別子をターゲットにしています。"
    },
    {
      "indent": 3,
      "text": "All nodes combine interface identifiers (whether derived from an IEEE identifier or generated through some other technique) with the reserved link-local prefix to generate link-local addresses for their attached interfaces. Additional addresses can then be created by combining prefixes advertised in Router Advertisements via Neighbor Discovery [DISCOVERY] with the interface identifier.",
      "ja": "すべてのノードが、それらの添付のインターフェイスのリンクローカルアドレスを生成するために予約リンクローカル接頭辞（IEEE識別子に由来するか、またはいくつかの他の技術を介して生成されたか否か）インタフェース識別子を組み合わせます。追加のアドレスは、インターフェイス識別子と近隣探索[DISCOVERY]を介して、ルータ広告で広告プレフィックスを組み合わせることによって作成することができます。"
    },
    {
      "indent": 3,
      "text": "Not all nodes and interfaces contain IEEE identifiers. In such cases, an interface identifier is generated through some other means (e.g., at random), and the resultant interface identifier may not be globally unique and may also change over time. The focus of this document is on addresses derived from IEEE identifiers because tracking of individual devices, the concern being addressed here, is possible only in those cases where the interface identifier is globally unique and non-changing. The rest of this document assumes that IEEE identifiers are being used, but the techniques described may also apply to interfaces with other types of globally unique and/or persistent identifiers.",
      "ja": "いないすべてのノードとのインターフェイスはIEEE識別子が含まれています。このような場合、インタフェース識別子は、他の手段（例えば、ランダムに）を介して生成され、得られたインターフェース識別子はグローバルに一意でなくてもよく、また、時間の経過と共に変化してもよいです。個々のデバイスの追跡、ここで扱われている懸念は、唯一のインタフェース識別子は、グローバルに一意と非変更である場合には可能性があるため。この文書の焦点は、IEEE識別子から得られたアドレスにありますこの文書の残りの部分は、IEEE識別子が使用されていることを前提としたが、記載された技術はまた、グローバルに一意及び/又は永続識別子の他のタイプのインターフェイスに適用することができます。"
    },
    {
      "indent": 3,
      "text": "This document discusses concerns associated with the embedding of non-changing interface identifiers within IPv6 addresses and describes extensions to stateless address autoconfiguration that can help mitigate those concerns for individual users and in environments where such concerns are significant. Section 2 provides background information on the issue. Section 3 describes a procedure for generating alternate interface identifiers and global scope addresses. Section 4 discusses implications of changing interface identifiers. The term \"global scope addresses\" is used in this document to collectively refer to \"Global unicast addresses\" as defined in [ADDRARCH] and \"Unique local addresses\" as defined in [ULA].",
      "ja": "この文書は、IPv6アドレス内の非変更インターフェイス識別子の埋め込みに関連した懸念を説明し、個々のユーザーのために、そのような懸念が重要である環境では、これらの懸念を軽減することができステートレスアドレス自動設定の拡張機能について説明します。第2節では、問題の背景情報を提供します。セクション3は、代替インタフェース識別子とグローバルスコープのアドレスを生成するための手順を記載しています。セクション4は、インタフェース識別子を変更することの影響を論じています。用語「グローバルスコープのアドレスは」まとめ[ULA]で定義されるように、「ユニークローカルアドレス」[ADDRARCH]および定義されるように「グローバルユニキャストアドレス」を参照するために本書で使用されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1。このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Problem Statement",
      "section_title": true,
      "ja": "1.2。問題文"
    },
    {
      "indent": 3,
      "text": "Addresses generated using stateless address autoconfiguration [ADDRCONF] contain an embedded interface identifier, which remains constant over time. Anytime a fixed identifier is used in multiple contexts, it becomes possible to correlate seemingly unrelated activity using this identifier.",
      "ja": "ステートレスアドレス自動設定を使用して生成されたアドレスは[ADDRCONF]経時的に一定のままで埋め込まれたインタフェース識別子を含みます。いつでも固定識別子が複数のコンテキストで使用され、それはこの識別子を使用して、一見無関係な活性を相関させることが可能となります。"
    },
    {
      "indent": 3,
      "text": "The correlation can be performed by",
      "ja": "相関は、により行うことができます"
    },
    {
      "indent": 3,
      "text": "o An attacker who is in the path between the node in question and the peer(s) to which it is communicating, and who can view the IPv6 addresses present in the datagrams.",
      "ja": "当該ノードとピア（複数可）が通信しているため、誰がデータグラムに存在するIPv6アドレスを表示することができるとの間のパスにある攻撃O。"
    },
    {
      "indent": 3,
      "text": "o An attacker who can access the communication logs of the peers with which the node has communicated.",
      "ja": "ノードが通信したピアの通信ログにアクセスできる攻撃者は、O。"
    },
    {
      "indent": 3,
      "text": "Since the identifier is embedded within the IPv6 address, which is a fundamental requirement of communication, it cannot be easily hidden. This document proposes a solution to this issue by generating interface identifiers that vary over time.",
      "ja": "識別子は、通信の基本的な要件であるIPv6アドレス内に埋め込まれているので、容易に隠すことができません。この文書では、時間の経過とともに変化インタフェース識別子を生成することによって、この問題の解決策を提案しています。"
    },
    {
      "indent": 3,
      "text": "Note that an attacker, who is on path, may be able to perform significant correlation based on",
      "ja": "パス上にある攻撃者は、に基づいて、有意な相関を実行することができるかもしれないことに注意してください"
    },
    {
      "indent": 3,
      "text": "o The payload contents of the packets on the wire",
      "ja": "ワイヤ上のパケットのペイロードの内容O"
    },
    {
      "indent": 3,
      "text": "o The characteristics of the packets such as packet size and timing",
      "ja": "そのようなパケットサイズとタイミングとして、パケットの特徴O"
    },
    {
      "indent": 3,
      "text": "Use of temporary addresses will not prevent such payload-based correlation.",
      "ja": "一時アドレスの使用は、このようなペイロードベースの相関を防ぐことはできません。"
    },
    {
      "indent": 0,
      "text": "2. Background",
      "section_title": true,
      "ja": "2.背景"
    },
    {
      "indent": 3,
      "text": "This section discusses the problem in more detail, provides context for evaluating the significance of the concerns in specific environments and makes comparisons with existing practices.",
      "ja": "このセクションでは、より詳細に問題を説明し、特定の環境での問題の重要性を評価するためのコンテキストを提供し、既存の慣行との比較になります。"
    },
    {
      "indent": 0,
      "text": "2.1. Extended Use of the Same Identifier",
      "section_title": true,
      "ja": "2.1。同じ識別子の長時間使用"
    },
    {
      "indent": 3,
      "text": "The use of a non-changing interface identifier to form addresses is a specific instance of the more general case where a constant identifier is reused over an extended period of time and in multiple independent activities. Any time the same identifier is used in multiple contexts, it becomes possible for that identifier to be used to correlate seemingly unrelated activity. For example, a network sniffer placed strategically on a link across which all traffic to/ from a particular host crosses could keep track of which destinations a node communicated with and at what times. Such information can in some cases be used to infer things, such as what hours an employee was active, when someone is at home, etc. Although it might appear that changing an address regularly in such environments would be desirable to lessen privacy concerns, it should be noted that the network prefix portion of an address also serves as a constant identifier. All nodes at, say, a home, would have the same network prefix, which identifies the topological location of those nodes. This has implications for privacy, though not at the same granularity as the concern that this document addresses. Specifically, all nodes within a home could be grouped together for the purposes of collecting information. If the network contains a very small number of nodes, say, just one, changing just the interface identifier will not enhance privacy at all, since the prefix serves as a constant identifier.",
      "ja": "アドレスを形成するための非変化インタフェース識別子の使用は、一定の識別子が長期間にわたって、複数の独立した活動で再利用されているより一般的な場合の特定のインスタンスです。その識別子は、一見無関係な活性を相関させるために使用されるのと同じ識別子が複数のコンテキストで使用される任意の時間は、それが可能となります。例えば、ネットワークスニファは、特定の宿主交雑から/へのすべてのトラフィックは、ノードと、何時間に通信された宛先を追跡する可能性が横切ってリンクを戦略的に配置されました。誰かが家にいるとき、それは、そのような環境では、定期的にアドレスを変更すると、プライバシーの問題、それを軽減することが望ましいように見えるかもしれませんが、そのような情報には、いくつかのケースではなど、そのような時間の従業員が有効だったかのように、物事を推測するために使用することができますアドレスのネットワークプレフィックス部分も一定識別子として働くことに留意すべきです。家庭、たとえば、のすべてのノードは、それらのノードの位相的な位置を特定し、同じネットワークプレフィックスを、持っているでしょう。このドキュメントのアドレスその懸念と同じ粒度ではないが、これは、プライバシーのための意味を持っています。具体的には、家庭内のすべてのノードが情報を収集する目的のためにグループ化することができます。ネットワークはノードの非常に小さな数が含まれている場合は、たとえば、一つだけ、ちょうどインタフェース識別子を変更すると、接頭辞が一定の識別子として機能するので、全くのプライバシーを強化しません。"
    },
    {
      "indent": 3,
      "text": "One of the requirements for correlating seemingly unrelated activities is the use (and reuse) of an identifier that is recognizable over time within different contexts. IP addresses provide one obvious example, but there are more. Many nodes also have DNS names associated with their addresses, in which case the DNS name serves as a similar identifier. Although the DNS name associated with an address is more work to obtain (it may require a DNS query), the information is often readily available. In such cases, changing the address on a machine over time would do little to address the concerns raised in this document, unless the DNS name is changed as well (see Section 4).",
      "ja": "一見無関係な活動を相関させるための要件の1つは、異なるコンテキスト内の時間にわたって認識された識別子の使用（再利用）です。 IPアドレスが1つの明白な例を提供しますが、より多くのがあります。多くのノードはDNS名が同様の識別子として機能する場合にはそのアドレスに関連付けられているDNS名を持っています。アドレスに関連付けられているDNS名が（それがDNSクエリが必要な場合があります）を取得するために多くの作業ではあるが、情報は多くの場合、容易に利用可能です。このような場合には、時間をかけてマシン上のアドレスを変更すると、DNS名も同様に変更されない限り（セクション4を参照）、この文書の懸念に対処するために少しをするでしょう。"
    },
    {
      "indent": 3,
      "text": "Web browsers and servers typically exchange \"cookies\" with each other [COOKIES]. Cookies allow Web servers to correlate a current activity with a previous activity. One common usage is to send back targeted advertising to a user by using the cookie supplied by the browser to identify what earlier queries had been made (e.g., for what type of information). Based on the earlier queries, advertisements can be targeted to match the (assumed) interests of the end user.",
      "ja": "Webブラウザとサーバは、一般的にお互いの[Cookie]で「クッキー」を交換します。クッキーは、Webサーバーは、以前の活動と現在の活動を関連付けることができます。一つの一般的な使用法は、以前のクエリが（例えば、情報の種類のために）行われていたものを識別するために、ブラウザによって提供されたクッキーを使用してユーザーに戻ってターゲットを絞った広告を送信することです。以前のクエリに基づいて、広告は、エンドユーザーの（仮定）の利益を一致させるために標的とすることができます。"
    },
    {
      "indent": 3,
      "text": "The use of a constant identifier within an address is of special concern because addresses are a fundamental requirement of communication and cannot easily be hidden from eavesdroppers and other parties. Even when higher layers encrypt their payloads, addresses in packet headers appear in the clear. Consequently, if a mobile host (e.g., laptop) accessed the network from several different locations, an eavesdropper might be able to track the movement of that mobile host from place to place, even if the upper layer payloads were encrypted.",
      "ja": "アドレスは、通信の基本的な要件であり、簡単に盗聴者や他の関係者から隠すことができないので、アドレス内で一定の識別子を使用することは、特別な問題を有します。上位層がそのペイロードを暗号化する場合でも、パケットヘッダのアドレスが明確に表示されます。モバイルホスト（例えば、ラップトップ）は、いくつかの異なる場所からネットワークにアクセスした場合、結果として、盗聴者は、上位層ペイロードが暗号化された場合でも、場所から場所へとその移動ホストの移動を追跡することができるかもしれません。"
    },
    {
      "indent": 0,
      "text": "2.2. Address Usage in IPv4 Today",
      "section_title": true,
      "ja": "2.2。 IPv4のアドレスの使用今日"
    },
    {
      "indent": 3,
      "text": "Addresses used in today's Internet are often non-changing in practice for extended periods of time. In an increasing number of sites, addresses are assigned statically and typically change infrequently. Over the last few years, sites have begun moving away from static allocation to dynamic allocation via DHCP [DHCP]. In theory, the address a client gets via DHCP can change over time, but in practice servers often return the same address to the same client (unless addresses are in such short supply that they are reused immediately by a different node when they become free). Thus, even within sites using DHCP, clients frequently end up using the same address for weeks to months at a time.",
      "ja": "今日のインターネットで使用されるアドレスは、多くの場合、長期間にわたって実際に非変化しています。サイト数の増加には、アドレスが静的に割り当てられ、通常はまれにしか変更されています。過去数年間で、サイトでは、DHCP [DHCP]を経由して離れ動的割り当てへの静的割り当てから移動し始めています。理論的には、クライアントがDHCP経由で取得するアドレスは、時間の経過とともに変化することができますが、（アドレスは、彼らが自由になったときに、彼らは別のノードですぐに再利用されるように不足している場合を除き）、実際にサーバーには、多くの場合、同じクライアントに同じアドレスを返します。したがって、でもDHCPを使用してサイト内では、クライアントが頻繁に一度に数週間から数ヶ月のために同じアドレスを使用して終了します。"
    },
    {
      "indent": 3,
      "text": "For home users accessing the Internet over dial-up lines, the situation is generally different. Such users do not have permanent connections and are often assigned temporary addresses each time they connect to their ISP. Consequently, the addresses they use change frequently over time and are shared among a number of different users. Thus, an address does not reliably identify a particular device over time spans of more than a few minutes.",
      "ja": "ホームユーザーがダイヤルアップ回線を介してインターネットにアクセスするために、状況は一般的に異なっています。このようなユーザーは、恒久的な接続を持っていないと、多くの場合、一時アドレスに彼らが彼らのISPに接続するたびに割り当てられています。その結果、アドレスが、彼らは時間をかけて、頻繁に変更を使用して、異なるユーザー数の間で共有されています。このように、アドレスは確実に数分以上の時間スパンにわたり、特定のデバイスを識別しません。"
    },
    {
      "indent": 3,
      "text": "A more interesting case concerns always-on connections (e.g., cable modems, ISDN, DSL, etc.) that result in a home site using the same address for extended periods of time. This is a scenario that is just starting to become common in IPv4 and promises to become more of a concern as always-on Internet connectivity becomes widely available.",
      "ja": "より興味深いケースの懸念常時オン長時間同じアドレスを使用してホームサイトにつながる接続（例えば、ケーブルモデム、ISDN、DSL、など）。これはちょうどIPv4の一般的になり始めているシナリオで、インターネット接続常時オン広く利用可能になるとの懸念のよりになることをお約束します。"
    },
    {
      "indent": 3,
      "text": "Finally, it should be noted that nodes that need a (non-changing) DNS name generally have static addresses assigned to them to simplify the configuration of DNS servers. Although Dynamic DNS [DDNS] can be used to update the DNS dynamically, it may not always be available depending on the administrative policy. In addition, changing an address but keeping the same DNS name does not really address the underlying concern, since the DNS name becomes a non-changing identifier. Servers generally require a DNS name (so clients can connect to them), and clients often do as well (e.g., some servers refuse to speak to a client whose address cannot be mapped into a DNS name that also maps back into the same address). Section 4 describes one approach to this issue.",
      "ja": "最後に、（非変化）DNS名を必要とするノードは、一般的にDNSサーバの構成を簡素化するためにそれらに割り当てられた静的アドレスを持っていることに留意すべきです。ダイナミックDNSは、[DDNS]動的DNSを更新するために使用することができますが、それは常に管理ポリシーによっては利用できない場合があります。 DNS名が非変更識別子なるのでまた、アドレスの変更が、同じDNS名を維持することは、本当に、根本的な問題に対処しません。 （例えば、いくつかのサーバは、そのアドレスも同じアドレスに戻すマップするDNS名にマップすることができないクライアントに話すことを拒否）（クライアントがそれらに接続できるように）サーバは、一般的にDNS名を必要とし、クライアントは、多くの場合、同様に行います。第4節では、この問題への一つのアプローチを説明します。"
    },
    {
      "indent": 0,
      "text": "2.3. The Concern with IPv6 Addresses",
      "section_title": true,
      "ja": "2.3。 IPv6アドレスと懸念"
    },
    {
      "indent": 3,
      "text": "The division of IPv6 addresses into distinct topology and interface identifier portions raises an issue new to IPv6 in that a fixed portion of an IPv6 address (i.e., the interface identifier) can contain an identifier that remains constant even when the topology portion of an address changes (e.g., as the result of connecting to a different part of the Internet). In IPv4, when an address changes, the entire address (including the local part of the address) usually changes. It is this new issue that this document addresses.",
      "ja": "IPv6の分割は、別個のトポロジとインタフェース識別子部分にIPv6アドレスのアドレス（すなわち、インタフェース識別子）の固定部分があってもアドレスの変更のトポロジー部一定のままである識別子を含むことができるという点で、IPv6への新たな問題を提起（例えば、インターネットの別の部分に接続するの結果として）。アドレスが変化したときのIPv4では、（アドレスのローカル部分を含む）全体のアドレスは通常変化します。これは、このドキュメントのアドレスを、この新しい問題です。"
    },
    {
      "indent": 3,
      "text": "If addresses are generated from an interface identifier, a home user's address could contain an interface identifier that remains the same from one dial-up session to the next, even if the rest of the address changes. The way PPP is used today, however, PPP servers typically unilaterally inform the client what address they are to use (i.e., the client doesn't generate one on its own). This practice, if continued in IPv6, would avoid the concerns that are the focus of this document.",
      "ja": "アドレスは、インタフェース識別子から生成されている場合は、ホームユーザーのアドレスは、偶数アドレスの変更の残りの場合は、次の1つのダイヤルアップセッションから同じままインタフェース識別子を含めることができます。 PPPは、今日使用されている方法は、しかし、PPPサーバは、一般的に一方的に（つまり、クライアントが独自に1つずつ生成されません）彼らが使用しているどのようなアドレスをクライアントに通知します。このような行為は、IPv6では続ければ、このドキュメントの焦点である懸念を避けるだろう。"
    },
    {
      "indent": 3,
      "text": "A more troubling case concerns mobile devices (e.g., laptops, PDAs, etc.) that move topologically within the Internet. Whenever they move, they form new addresses for their current topological point of attachment. This is typified today by the \"road warrior\" who has Internet connectivity both at home and at the office. While the node's address changes as it moves, the interface identifier contained within the address remains the same (when derived from an IEEE Identifier). In such cases, the interface identifier can be used to track the movement and usage of a particular machine. For example, a server that logs usage information together with source addresses, is also recording the interface identifier since it is embedded within an address. Consequently, any data-mining technique that correlates activity based on addresses could easily be extended to do the same using the interface identifier. This is of particular concern with the expected proliferation of next-generation network-connected devices (e.g., PDAs, cell phones, etc.) in which large numbers of devices are, in practice, associated with individual users (i.e., not shared). Thus, the interface identifier embedded within an address could be used to track activities of an individual, even as they move topologically within the Internet.",
      "ja": "より厄介な場合は、インターネット内でトポロジー的に移動モバイル機器（例えば、ラップトップ、PDA、等）に関する。彼らが移動するたびに、彼らは添付ファイルの彼らの現在のトポロジカルポイントの新しいアドレスを形成します。これは、自宅やオフィスの両方でインターネット接続を持っている「道の戦士」が本日代表されます。それが移動するノードのアドレスが変更しながら（IEEE識別子に由来する場合）、アドレス内に含まれるインターフェイス識別子は同じままです。このような場合、インタフェース識別子は、特定のマシンの動きと使用を追跡するために使用することができます。それはアドレス内に埋め込まれているので、例えば、送信元アドレスと一緒に使用情報をログに記録サーバーは、また、インタフェース識別子を記録しています。これにより、アドレスに基づいて、アクティビティを相関任意のデータマイニング技術を容易にインタフェース識別子を使用して同じことを行うように拡張することができます。これは、多数のデバイスが、実際には、個々のユーザ（すなわち、共有されていない）に関連付けられている次世代ネットワーク接続されたデバイス（例えば、PDA、携帯電話、等）の予想される増殖を伴う特定の問題です。このように、アドレスの中に埋め込まれたインタフェース識別子は、彼らがインターネット内位相幾何学的に移動したとしても、個々の活動を追跡するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "In summary, IPv6 addresses on a given interface generated via Stateless Autoconfiguration contain the same interface identifier, regardless of where within the Internet the device connects. This facilitates the tracking of individual devices (and thus, potentially, users). The purpose of this document is to define mechanisms that eliminate this issue in those situations where it is a concern.",
      "ja": "要約すると、ステートレス自動設定を介して生成された所定のインターフェイスのIPv6アドレスは、デバイスが接続され、インターネット内にかかわらず、ここでの、同じインタフェース識別子を含みます。これは、個々のデバイス（したがって、潜在的に、ユーザー）の追跡を容易にします。このドキュメントの目的は、それが懸念されるような状況でこの問題を解消するメカニズムを定義することです。"
    },
    {
      "indent": 0,
      "text": "2.4. Possible Approaches",
      "section_title": true,
      "ja": "2.4。可能なアプローチ"
    },
    {
      "indent": 3,
      "text": "One way to avoid having a static non-changing address is to use DHCPv6 [DHCPV6] for obtaining addresses. Section 12 of [DHCPV6] discusses the use of DHCPv6 for the assignment and management of \"temporary addresses\", which are never renewed and provide the same property of temporary addresses described in this document with regards to the privacy concern.",
      "ja": "静的非変更アドレスを有する回避する1つの方法は、アドレスを取得するためのDHCPv6 [DHCPV6]を使用することです。 [DHCPV6]のセクション12を更新しないと、プライバシーの問題に関して、この文書で説明する一時アドレスの同じプロパティを提供している決して「一時アドレス」、の割り当てと管理のためのDHCPv6の使用について説明します。"
    },
    {
      "indent": 3,
      "text": "Another approach, compatible with the stateless address autoconfiguration architecture, would be to change the interface identifier portion of an address over time and generate new addresses from the interface identifier for some address scopes. Changing the interface identifier can make it more difficult to look at the IP addresses in independent transactions and identify which ones actually correspond to the same node, both in the case where the routing prefix portion of an address changes and when it does not.",
      "ja": "ステートレスアドレス自動設定アーキテクチャと互換性の別のアプローチは、時間をかけてアドレスのインタフェース識別子部分を変更し、いくつかのアドレススコープのインタフェース識別子から新しいアドレスを生成することであろう。インタフェース識別子を変更することはより困難に独立したトランザクション内のIPアドレスを見て、実際にアドレス変更のルーティングプレフィックス部分場合に、いつそうでない両方、同じノードに対応するものを同定するために行うことができます。"
    },
    {
      "indent": 3,
      "text": "Many machines function as both clients and servers. In such cases, the machine would need a DNS name for its use as a server. Whether the address stays fixed or changes has little privacy implication since the DNS name remains constant and serves as a constant identifier. When acting as a client (e.g., initiating communication), however, such a machine may want to vary the addresses it uses. In such environments, one may need multiple addresses: a \"public\" (i.e., non-secret) server address, registered in the DNS, that is used to accept incoming connection requests from other machines, and a \"temporary\" address used to shield the identity of the client when it initiates communication. These two cases are roughly analogous to telephone numbers and caller ID, where a user may list their telephone number in the public phone book, but disable the display of its number via caller ID when initiating calls.",
      "ja": "多くのマシンは、クライアントとサーバーの両方として機能します。このような場合には、マシンがサーバーとしての使用のためのDNS名が必要になります。 DNS名は一定のまま、一定の識別子として機能しますので、アドレスが固定または変更したままかどうかは、少しプライバシー意味合いを持っています。 （例えば、通信を開始する）クライアントとして動作する場合、しかし、そのようなマシンは、それが使用するアドレスを変更することもできます。このような環境では、1は、複数のアドレスが必要な場合があります。DNSに登録されている「公共の」（すなわち、非秘密）サーバーのアドレスを、それは他のマシンからの着信接続要求を受け入れるために使用され、かつ遮蔽するために使用される「一時的な」アドレスそれが通信を開始するクライアントのID。これらの2つのケースは、ユーザーが公衆電話帳に自分の電話番号の一覧を表示する電話番号と発信者ID、とほぼ類似しているが、通話を開始する際に、発信者IDを経由してその番号の表示を無効にします。"
    },
    {
      "indent": 3,
      "text": "To make it difficult to make educated guesses as to whether two different interface identifiers belong to the same node, the algorithm for generating alternate identifiers must include input that has an unpredictable component from the perspective of the outside entities that are collecting information. Picking identifiers from a pseudo-random sequence suffices, so long as the specific sequence cannot be determined by an outsider examining information that is readily available or easily determinable (e.g., by examining packet contents). This document proposes the generation of a pseudo-random sequence of interface identifiers via an MD5 hash. Periodically, the next interface identifier in the sequence is generated, a new set of temporary addresses is created, and the previous temporary addresses are deprecated to discourage their further use. The precise pseudo-random sequence depends on both a random component and the globally unique interface identifier (when available), to increase the likelihood that different nodes generate different sequences.",
      "ja": "それは難しい二つの異なるインタフェース識別子が同じノードに属しているか否かの教育を受けた推測をするために作るために、代替の識別子を生成するためのアルゴリズムは、情報を収集している外部エンティティの観点から、予測不可能な成分を有する入力を含んでいなければなりません。擬似ランダムシーケンスから識別子をピッキングすることは、特定の配列が、（パケットの内容を調べることによって、例えば、）容易に利用可能であるか、または容易に決定可能である部外検査情報によって決定することができない限り、十分です。この文書は、MD5ハッシュを介して、インターフェース識別子の擬似ランダムシーケンスの生成を提案しています。定期的に、シーケンス内の次のインタフェース識別子は、一時アドレスの新しいセットが作成され、生成され、前回の仮のアドレスはそれらのさらなる使用を阻止することが推奨されていません。正確な疑似ランダムシーケンスは、異なるノードは異なる配列を生成する可能性を高めるために、ランダム成分とグローバルに一意のインタフェース識別子（使用可能）の両方に依存します。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Description",
      "section_title": true,
      "ja": "3.プロトコル説明"
    },
    {
      "indent": 3,
      "text": "The goal of this section is to define procedures that:",
      "ja": "このセクションの目標は、という手順を定義することです。"
    },
    {
      "indent": 3,
      "text": "1. Do not result in any changes to the basic behavior of addresses generated via stateless address autoconfiguration [ADDRCONF].",
      "ja": "1.ステートレスアドレス自動設定[ADDRCONF]を経由して生成されたアドレスの基本的な行動に何らかの変化をもたらすしないでください。"
    },
    {
      "indent": 3,
      "text": "2. Create additional addresses based on a random interface identifier for the purpose of initiating outgoing sessions. These \"random\" or temporary addresses would be used for a short period of time (hours to days) and would then be deprecated. Deprecated address can continue to be used for already established connections, but are not used to initiate new connections. New temporary addresses are generated periodically to replace temporary addresses that expire, with the exact time between address generation a matter of local policy.",
      "ja": "2.送信セッションを開始するために、ランダムなインターフェイス識別子に基づいて、追加のアドレスを作成します。これらは、「ランダム」または一時アドレスは、時間（数時間から数日）の短期間のために使用されるだろうし、その後廃止されるでしょう。非推奨アドレスは、すでに確立された接続を使用し続けることができるが、新しい接続を開始するために使用されていません。新しい仮のアドレスは、アドレス生成間の正確な時間ローカルポリシーの問題で、有効期限は一時アドレスを交換するために定期的に生成されます。"
    },
    {
      "indent": 3,
      "text": "3. Produce a sequence of temporary global scope addresses from a sequence of interface identifiers that appear to be random in the sense that it is difficult for an outside observer to predict a future address (or identifier) based on a current one, and it is difficult to determine previous addresses (or identifiers) knowing only the present one.",
      "ja": "3.外部観察者が現在のものに基づいて将来のアドレス（又は識別子）を予測することは困難であるという意味で、ランダムであるように見えるインタフェース識別子のシーケンスからの一時的なグローバルスコープのアドレスのシーケンスを生成し、それはのみ存在いずれかを知る前のアドレス（又は識別子）を決定することは困難。"
    },
    {
      "indent": 3,
      "text": "4. By default, generate a set of addresses from the same (randomized) interface identifier, one address for each prefix for which a global address has been generated via stateless address autoconfiguration. Using the same interface identifier to generate a set of temporary addresses reduces the number of IP multicast groups a host must join. Nodes join the solicited-node multicast address for each unicast address they support, and solicited-node addresses are dependent only on the low-order bits of the corresponding address. This default behavior was made to address the concern that a node that joins a large number of multicast groups may be required to put its interface into promiscuous mode, resulting in possible reduced performance.",
      "ja": "4.デフォルトで、同じ（ランダム化）インタフェース識別子、グローバルアドレスはステートレスアドレス自動設定を介して生成された各プレフィックスに対して1つのアドレスからのアドレスのセットを生成します。一時アドレスのセットを生成するために、同じインタフェース識別子を使用すると、ホストが加入しなければならないIPマルチキャストグループの数を減らします。ノードは、それらがサポートする各ユニキャストアドレスの要請ノードマルチキャストアドレスへの参加、および要請ノードアドレスは、対応するアドレスの下位ビットに依存しています。このデフォルトの動作は、マルチキャストグループの多数に参加するノードは、可能な性能低下が生じ、プロミスキャスモードにそのインターフェースを置くことを必要とすることができるの懸念に対処するためになされました。"
    },
    {
      "indent": 7,
      "text": "A node highly concerned about privacy MAY use different interface\nidentifiers on different prefixes, resulting in a set of global\naddresses that cannot be easily tied to each other.  For example\na node MAY create different interface identifiers I1, I2, and I3\nfor use with different prefixes P1, P2, and P3 on the same\ninterface.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1. Assumptions",
      "section_title": true,
      "ja": "3.1。仮定"
    },
    {
      "indent": 3,
      "text": "The following algorithm assumes that each interface maintains an associated randomized interface identifier. When temporary addresses are generated, the current value of the associated randomized interface identifier is used. While the same identifier can be used to create more than one temporary address, the value SHOULD change over time as described in Section 3.5.",
      "ja": "以下のアルゴリズムは、各インタフェースは、関連ランダムインタフェース識別子を維持することを前提としています。一時的なアドレスが生成されると、関連付けられたランダムインタフェース識別子の現在の値が使用されます。同じ識別子が複数の一時アドレスを作成するために使用することができますが、セクション3.5で説明したように、値が時間の経過とともに変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "The algorithm also assumes that, for a given temporary address, an implementation can determine the prefix from which it was generated. When a temporary address is deprecated, a new temporary address is generated. The specific valid and preferred lifetimes for the new address are dependent on the corresponding lifetime values set for the prefix from which it was generated.",
      "ja": "アルゴリズムは、与えられた一時的なアドレスのために、実装はそれが生成された接頭辞を決定することができることを前提としています。一時アドレスを非推奨されている場合、新しい一時的なアドレスが生成されます。新しいアドレスのための特定の有効期間と推奨期間は、それが生成された接頭辞に設定され、対応する寿命値に依存しています。"
    },
    {
      "indent": 3,
      "text": "Finally, this document assumes that when a node initiates outgoing communication, temporary addresses can be given preference over public addresses when the device is configured to do so. [ADDR_SELECT] mandates implementations to provide a mechanism, which allows an application to configure its preference for temporary addresses over public addresses. It also allows for an implementation to prefer temporary addresses by default, so that the connections initiated by the node can use temporary addresses without requiring application-specific enablement. This document also assumes that an API will exist that allows individual applications to indicate whether they prefer to use temporary or public addresses and override the system defaults.",
      "ja": "最後に、この文書は、ノードが、発信通信を開始するとき、デバイスがそうするように構成されている場合、一時的なアドレスがパブリックアドレスを超える優先度を与えることができると仮定しています。 【ADDR_SELECT]義務の実装は、アプリケーションがパブリックアドレス上に一時アドレスのためにその嗜好を設定することを可能にするメカニズムを提供します。ノードが開始した接続は、アプリケーション固有の有効化を必要とせずに、一時的なアドレスを使用できるように、それはまた、デフォルトでは一時アドレスを好むために実装することができます。また、このドキュメントでは、APIは、それが個々のアプリケーションは、彼らが一時的またはパブリックアドレスを使用して、システムのデフォルト値を上書きすることを好むかどうかを指定することができます存在することを前提としています。"
    },
    {
      "indent": 0,
      "text": "3.2. Generation of Randomized Interface Identifiers",
      "section_title": true,
      "ja": "3.2。ランダムインタフェース識別子の生成"
    },
    {
      "indent": 3,
      "text": "We describe two approaches for the generation and maintenance of the randomized interface identifier. The first assumes the presence of stable storage that can be used to record state history for use as input into the next iteration of the algorithm across system restarts. A second approach addresses the case where stable storage is unavailable and there is a need to generate randomized interface identifiers without previous state.",
      "ja": "私たちは、ランダム化されたインタフェース識別子の生成と維持のための2つのアプローチを説明します。第一は、システムの再起動を横断アルゴリズムの次の反復への入力として使用するための状態の履歴を記録するために使用することができる安定な保存が存在することを前提としています。第2のアプローチは、貯蔵安定性が使用不能であると以前の状態なしでランダムインタフェース識別子を生成する必要がある場合に対処します。"
    },
    {
      "indent": 3,
      "text": "The random interface identifier generation algorithm, as described in this document, uses MD5 as the hash algorithm. The node MAY use another algorithm instead of MD5 to produce the random interface identifier.",
      "ja": "ランダムインタフェース識別子生成アルゴリズムは、この文書に記載されているように、ハッシュアルゴリズムとしてMD5を使用します。ノードは、ランダムインタフェース識別子を生成するためにMD5の代わりに別のアルゴリズムを使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.2.1. When Stable Storage Is Present",
      "section_title": true,
      "ja": "3.2.1。安定したストレージが存在する場合には"
    },
    {
      "indent": 3,
      "text": "The following algorithm assumes the presence of a 64-bit \"history value\" that is used as input in generating a randomized interface identifier. The very first time the system boots (i.e., out-of-the-box), a random value SHOULD be generated using techniques that help ensure the initial value is hard to guess [RANDOM]. Whenever a new interface identifier is generated, a value generated by the computation is saved in the history value for the next iteration of the algorithm.",
      "ja": "以下のアルゴリズムは、ランダム化されたインタフェース識別子を生成する際に入力として使用される64ビットの「履歴値」の存在を前提としています。初めてシステムが起動（すなわち、アウトオブボックス）、ランダム値を初期値は[ランダム]を推測することは困難である確実な技術を用いて生成されるべきです。新しいインタフェース識別子が生成されるたびに、計算によって生成された値は、アルゴリズムの次の反復のための履歴値に保存されます。"
    },
    {
      "indent": 3,
      "text": "A randomized interface identifier is created as follows:",
      "ja": "次のようにランダム化されたインタフェース識別子が作成されます。"
    },
    {
      "indent": 3,
      "text": "1. Take the history value from the previous iteration of this algorithm (or a random value if there is no previous value) and append to it the interface identifier generated as described in [ADDRARCH].",
      "ja": "1 ADDRARCH]で説明されるように生成されたインタフェース識別子を（以前の値がない場合、またはランダム値）このアルゴリズムの前の反復からの履歴値を取り、それに追加します。"
    },
    {
      "indent": 3,
      "text": "2. Compute the MD5 message digest [MD5] over the quantity created in the previous step.",
      "ja": "2.計算前のステップで作成した量よりMD5メッセージダイジェスト[MD5]。"
    },
    {
      "indent": 3,
      "text": "3. Take the leftmost 64-bits of the MD5 digest and set bit 6 (the leftmost bit is numbered 0) to zero. This creates an interface identifier with the universal/local bit indicating local significance only.",
      "ja": "3.ゼロに左端のMD5ダイジェストの64ビットとビット6（左端ビットは0の番号が付されている）を設定してください。これはローカルな意味を表すユニバーサル/ローカルビットとのインタフェース識別子を生成します。"
    },
    {
      "indent": 3,
      "text": "4. Compare the generated identifier against a list of reserved interface identifiers and to those already assigned to an address on the local device. In the event that an unacceptable identifier has been generated, the node MUST restart the process at step 1 above, using the rightmost 64 bits of the MD5 digest obtained in step 2 in place of the history value in step 1.",
      "ja": "4.予約インタフェース識別子のリストに対して、すでにローカルデバイス上のアドレスに割り当てられているものに生成された識別子を比較します。許容できない識別子が生成された場合に、ノードは、ステップ1で履歴値の代わりに工程2で得られたMD5ダイジェストの右端の64ビットを使用して、上記のステップ1の処理を再開する必要があります。"
    },
    {
      "indent": 3,
      "text": "5. Save the generated identifier as the associated randomized interface identifier.",
      "ja": "5.関連するランダムインタフェース識別子として生成された識別子を保存します。"
    },
    {
      "indent": 3,
      "text": "6. Take the rightmost 64-bits of the MD5 digest computed in step 2) and save them in stable storage as the history value to be used in the next iteration of the algorithm.",
      "ja": "6.ステップ2で計算されたMD5ダイジェストの右端の64ビット）を取り、履歴値は、アルゴリズムの次の反復で使用されるように安定したストレージに保存。"
    },
    {
      "indent": 3,
      "text": "MD5 was chosen for convenience, and because its particular properties were adequate to produce the desired level of randomization. The node MAY use another algorithm instead of MD5 to produce the random interface identifier",
      "ja": "MD5は、便宜のために選択した、その特定の特性が適切であったため、ランダム化の所望のレベルを生成します。ノードは、ランダムインタフェース識別子を生成する代わりに、MD5の別のアルゴリズムを使用するかもしれ"
    },
    {
      "indent": 3,
      "text": "In theory, generating successive randomized interface identifiers using a history scheme as above has no advantages over generating them at random. In practice, however, generating truly random numbers can be tricky. Use of a history value is intended to avoid the particular scenario where two nodes generate the same randomized interface identifier, both detect the situation via DAD, but then proceed to generate identical randomized interface identifiers via the same (flawed) random number generation algorithm. The above algorithm avoids this problem by having the interface identifier (which will often be globally unique) used in the calculation that generates subsequent randomized interface identifiers. Thus, if two nodes happen to generate the same randomized interface identifier, they should generate different ones on the follow-up attempt.",
      "ja": "理論的には、上記のように履歴方式を用いて連続したランダムインタフェース識別子を生成することは、ランダムにそれらを生成に対して何ら効果を有していません。しかし実際には、真の乱数を生成することは難しいことができます。履歴値の使用は、2つのノードが同じランダムインタフェース識別子を生成する特定のシナリオを回避するため、両方のDADを介して状況を検出し、その後、同じ（欠陥）乱数生成アルゴリズムを介して同じランダムインタフェース識別子を生成するように進行することを意図しています。上記のアルゴリズムは、後続のランダムインタフェース識別子を生成する計算に使用される（多くの場合、グローバルに一意であろう）インタフェース識別子を有することによって、この問題を回避します。 2つのノードが同じランダム化されたインタフェース識別子を生成するために起こる場合はこのように、彼らは、フォローアップの試みで異なるものを生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.2. In The Absence of Stable Storage",
      "section_title": true,
      "ja": "3.2.2。安定記憶のない状態で"
    },
    {
      "indent": 3,
      "text": "In the absence of stable storage, no history value will be available across system restarts to generate a pseudo-random sequence of interface identifiers. Consequently, the initial history value used above SHOULD be generated at random. A number of techniques might be appropriate. Consult [RANDOM] for suggestions on good sources for obtaining random numbers. Note that even though machines may not have stable storage for storing a history value, they will in many cases have configuration information that differs from one machine to another (e.g., user identity, security keys, serial numbers, etc.). One approach to generating a random initial history value in such cases is to use the configuration information to generate some data bits (which may remain constant for the life of the machine, but will vary from one machine to another), append some random data, and compute the MD5 digest as before.",
      "ja": "貯蔵安定性の非存在下で、何履歴値は、インターフェース識別子の擬似ランダムシーケンスを生成するためにシステムの再起動を横切って利用できません。したがって、上記の使用初期履歴値はランダムに生成されるべきです。多くの技術が適切かもしれません。乱数を得るための良い情報源の提案のための[RANDOM]を参照してください。マシンは履歴値を格納するための安定した記憶装置を持っていなくても、彼らは多くの場合、別の（例えば、ユーザーのアイデンティティ、セキュリティキー、シリアル番号など）を1台のマシンとは異なり、構成情報を持っていることに注意してください。そのような場合にはランダムな初期履歴値を生成するための一つのアプローチは、いくつかのランダムなデータを追加し、（機械の寿命のために一定のままであってもよいが、あるマシンから別のマシンに変化するであろう）は、いくつかのデータビットを生成するために、構成情報を使用することで、そして以前のようにMD5ダイジェストを計算します。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Alternate Approaches",
      "section_title": true,
      "ja": "3.2.3。代替アプローチ"
    },
    {
      "indent": 3,
      "text": "Note that there are other approaches to generate random interface identifiers, albeit with different goals and applicability. One such approach is Cryptographically Generated Addresses (CGAs) [CGA], which generate a random interface identifier based on the public key of the node. The goal of CGAs is to prove ownership of an address and to prevent spoofing and stealing of existing IPv6 addresses. They are used for securing neighbor discovery using [SEND]. The CGA random interface identifier generation algorithm may not be suitable for privacy addresses because of the following properties: o It requires the node to have a public key. This means that the node can still be identified by its public key.",
      "ja": "別の目標や適用性はあるものの、ランダムインタフェース識別子を生成するための他のアプローチがあることに注意してください。このようなアプローチの1つは、ノードの公開鍵に基づいて、ランダムインタフェース識別子を生成する暗号化生成アドレス（CGAs）[CGA]です。 CGAsの目標は、アドレスの所有権を証明するために、既存のIPv6アドレスのスプーフィングや盗難を防ぐためです。彼らは、[SEND]を使用して近隣探索を確保するために使用されています。 CGAランダムインタフェース識別子生成アルゴリズムがあるため、次の特性のプライバシーアドレスには適していないことがあります。それは、公開鍵を持っているノードを必要とoを。これは、ノードがまだその公開鍵によって識別することができることを意味します。"
    },
    {
      "indent": 3,
      "text": "o The random interface identifier process is computationally intensive and hence discourages frequent regeneration.",
      "ja": "Oランダムインタフェース識別子プロセスは、計算集約的であり、したがって、頻繁な再生を阻止します。"
    },
    {
      "indent": 0,
      "text": "3.3. Generating Temporary Addresses",
      "section_title": true,
      "ja": "3.3。一時アドレスの生成"
    },
    {
      "indent": 3,
      "text": "[ADDRCONF] describes the steps for generating a link-local address when an interface becomes enabled as well as the steps for generating addresses for other scopes. This document extends [ADDRCONF] as follows. When processing a Router Advertisement with a Prefix Information option carrying a global scope prefix for the purposes of address autoconfiguration (i.e., the A bit is set), the node MUST perform the following steps:",
      "ja": "[ADDRCONF]インタフェースが有効ならびに他のスコープのアドレスを生成するステップになる場合、リンクローカルアドレスを生成する手順を記載しています。この文書では、[ADDRCONF]次のように延びています。アドレス自動設定の目的のためのグローバルスコーププレフィックスを運ぶプレフィックス情報オプション（すなわち、ビットがセットされている）を有するルータ通知を処理する場合、ノードは以下のステップを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Process the Prefix Information Option as defined in [ADDRCONF], either creating a new public address or adjusting the lifetimes of existing addresses, both public and temporary. If a received option will extend the lifetime of a public address, the lifetimes of temporary addresses should be extended, subject to the overall constraint that no temporary addresses should ever remain \"valid\" or \"preferred\" for a time longer than (TEMP_VALID_LIFETIME) or (TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR), respectively. The configuration variables TEMP_VALID_LIFETIME and TEMP_PREFERRED_LIFETIME correspond to approximate target lifetimes for temporary addresses.",
      "ja": "1.プロセス[ADDRCONF]で定義されているプレフィックス情報オプション、新しいパブリックアドレスを作成またはパブリックと一時両方既存のアドレスの寿命を調整するのどちらか。受信オプションは、パブリックアドレスの寿命を延長する場合は、一時的なアドレスの寿命は何の一時アドレスは、これまで長い（TEMP_VALID_LIFETIME）よりも時間を「有効」または「好ましい」残っていない必要があることを、全体的な制約を受ける延長すべきか（TEMP_PREFERRED_LIFETIME  -  DESYNC_FACTOR）、それぞれ。設定変数TEMP_VALID_LIFETIMEとTEMP_PREFERRED_LIFETIMEは、一時的なアドレスのターゲット寿命を近似するために対応しています。"
    },
    {
      "indent": 3,
      "text": "2. One way an implementation can satisfy the above constraints is to associate with each temporary address a creation time (called CREATION_TIME) that indicates the time at which the address was created. When updating the preferred lifetime of an existing temporary address, it would be set to expire at whichever time is earlier: the time indicated by the received lifetime or (CREATION_TIME + TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR). A similar approach can be used with the valid lifetime.",
      "ja": "実装は、上記の制約を満たすことができる2つの方法は、アドレスが作成された時刻を示し、各一時アドレス（CREATION_TIMEと呼ばれる）作成時間に関連付けることです。既存の一時アドレスの優先寿命を更新する場合には、いずれか早い時点で有効期限が切れるように設定される。受信した寿命または（CREATION_TIME + TEMP_PREFERRED_LIFETIME  -  DESYNC_FACTOR）が示す時刻を。同様のアプローチが有効な寿命で使用することができます。"
    },
    {
      "indent": 3,
      "text": "3. When a new public address is created as described in [ADDRCONF], the node SHOULD also create a new temporary address.",
      "ja": "3. [ADDRCONF]で説明したように、新たなパブリックアドレスが作成されると、ノードは、新しい一時アドレスを作成する必要があります。"
    },
    {
      "indent": 3,
      "text": "4. When creating a temporary address, the lifetime values MUST be derived from the corresponding prefix as follows:",
      "ja": "一時アドレスを作成する場合、以下のように4.は、寿命値は、対応するプレフィックスから導出されなければなりません。"
    },
    {
      "indent": 7,
      "text": "*  Its Valid Lifetime is the lower of the Valid Lifetime of the\n   public address or TEMP_VALID_LIFETIME.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* Its Preferred Lifetime is the lower of the Preferred Lifetime of the public address or TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR.",
      "ja": "DESYNC_FACTOR  -  *その好ましい寿命は、パブリックアドレスまたはTEMP_PREFERRED_LIFETIMEの優先寿命の低下です。"
    },
    {
      "indent": 3,
      "text": "5. A temporary address is created only if this calculated Preferred Lifetime is greater than REGEN_ADVANCE time units. In particular, an implementation MUST NOT create a temporary address with a zero Preferred Lifetime.",
      "ja": "5.一時アドレスは、この算出された好ましい寿命がREGEN_ADVANCE時間単位よりも大きい場合にのみ作成されます。特に、実装はゼロ優先寿命で一時アドレスを作成してはいけません。"
    },
    {
      "indent": 3,
      "text": "6. New temporary addresses MUST be created by appending the interface's current randomized interface identifier to the prefix that was received.",
      "ja": "6.新しい一時的なアドレスが受信されたプレフィックスにインターフェイスの現在の無作為化インタフェース識別子を追加することで作成する必要があります。"
    },
    {
      "indent": 3,
      "text": "7. The node MUST perform duplicate address detection (DAD) on the generated temporary address. If DAD indicates the address is already in use, the node MUST generate a new randomized interface identifier as described in Section 3.2 above, and repeat the previous steps as appropriate up to TEMP_IDGEN_RETRIES times. If after TEMP_IDGEN_RETRIES consecutive attempts no non-unique address was generated, the node MUST log a system error and MUST NOT attempt to generate temporary addresses for that interface. Note that DAD MUST be performed on every unicast address generated from this randomized interface identifier.",
      "ja": "7.ノードが生成された臨時アドレスに重複アドレス検出（DAD）を実行しなければなりません。 DADは、アドレスが既に使用中であることを示す場合、ノードは、上記のセクション3.2に記載したように、新しいランダムインタフェース識別子を生成し、TEMP_IDGEN_RETRIES回まで必要に応じて上記の手順を繰り返す必要があります。 TEMP_IDGEN_RETRIES連続試行した後、何の非固有のアドレスが生成されなかった場合、ノードはシステムエラーをログに記録しなければならないし、そのインターフェイスの一時アドレスを生成することを試みてはいけません。 DADこのランダムインタフェース識別子から生成されたすべてのユニキャストアドレスに対して行わなければならないことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "3.4. Expiration of Temporary Addresses",
      "section_title": true,
      "ja": "3.4。一時アドレスの有効期限"
    },
    {
      "indent": 3,
      "text": "When a temporary address becomes deprecated, a new one MUST be generated. This is done by repeating the actions described in Section 3.3, starting at step 3). Note that, except for the transient period when a temporary address is being regenerated, in normal operation at most one temporary address per prefix should be in a non-deprecated state at any given time on a given interface. Note that if a temporary address becomes deprecated as result of processing a Prefix Information Option with a zero Preferred Lifetime, then a new temporary address MUST NOT be generated. To ensure that a preferred temporary address is always available, a new temporary address SHOULD be regenerated slightly before its predecessor is deprecated. This is to allow sufficient time to avoid race conditions in the case where generating a new temporary address is not instantaneous, such as when duplicate address detection must be run. The node SHOULD start the address regeneration process REGEN_ADVANCE time units before a temporary address would actually be deprecated.",
      "ja": "一時アドレスが非推奨になると、新しいものが生成されなければなりません。これは、セクション3.3に記載の操作を繰り返すことによって行われる、）ステップ3から始まります。一時アドレスが再生されている過渡期間を除いて、通常の操作では、プレフィックスごとに最大1つの一時的なアドレスが指定されたインターフェイス上の任意の時点で非非推奨状態になっている必要があり、あることに注意してください。一時アドレスがゼロ優先寿命のプレフィックス情報オプションを処理した結果として、非推奨になった場合、その後、新しい一時アドレスを生成してはならないことに注意してください。その前身は廃止される前に、好ましくは、一時的なアドレスが常に利用可能であることを確実にするために、新しい仮のアドレスがやや再生成する必要があります。これは、新しい一時アドレスを生成することは、このような重複アドレス検出が実行されなければならないときなど、瞬間的でない場合には競合状態を回避するのに十分な時間を確保することです。一時アドレスは、実際に廃止されるだろう前に、ノードは、アドレス再生プロセスREGEN_ADVANCE時間単位を開始する必要があります。"
    },
    {
      "indent": 3,
      "text": "As an optional optimization, an implementation MAY remove a deprecated temporary address that is not in use by applications or upper layers as detailed in Section 6.",
      "ja": "オプションの最適化として、実装は、第6節で説明するようなアプリケーションや上位層で使用されていない非推奨の一時的なアドレスを削除することができます。"
    },
    {
      "indent": 0,
      "text": "3.5. Regeneration of Randomized Interface Identifiers",
      "section_title": true,
      "ja": "3.5。ランダムインタフェース識別子の再生"
    },
    {
      "indent": 3,
      "text": "The frequency at which temporary addresses changes depends on how a device is being used (e.g., how frequently it initiates new communication) and the concerns of the end user. The most egregious privacy concerns appear to involve addresses used for long periods of time (weeks to months to years). The more frequently an address changes, the less feasible collecting or coordinating information keyed on interface identifiers becomes. Moreover, the cost of collecting information and attempting to correlate it based on interface identifiers will only be justified if enough addresses contain non-changing identifiers to make it worthwhile. Thus, having large numbers of clients change their address on a daily or weekly basis is likely to be sufficient to alleviate most privacy concerns.",
      "ja": "一時アドレスの変更の周波数は、デバイスが（それが新たな通信を開始例えば、頻度）を使用し、エンドユーザの懸念されている方法に依存します。最も悪質なプライバシーの問題は、（年に数週間〜数ヶ月）長時間使用されるアドレスが関与するように見えます。より頻繁にアドレス変更、インタフェース識別子をキー少ない可能収集または調整情報となります。十分な数のアドレスが、それは価値がある作るために非変更識別子が含まれている場合はさらに、インターフェイス識別子に基づいて情報を収集し、それを相関しようとするのコストは正当化されます。このように、多数のクライアントが毎日または週単位で自分のアドレスを変更したことは、ほとんどのプライバシーの問題を緩和するのに十分である可能性が高いです。"
    },
    {
      "indent": 3,
      "text": "There are also client costs associated with having a large number of addresses associated with a node (e.g., in doing address lookups, the need to join many multicast groups, etc.). Thus, changing addresses frequently (e.g., every few minutes) may have performance implications.",
      "ja": "（アドレスの検索を行うことで、例えば、多くのマルチキャストグループに参加する必要性など）ノードに関連付けられたアドレスの数が多いと関連付けられたクライアントのコストもあります。したがって、頻繁にアドレスを変更する（例えば、数分ごと）がパフォーマンスに影響を有することができます。"
    },
    {
      "indent": 3,
      "text": "Nodes following this specification SHOULD generate new temporary addresses on a periodic basis. This can be achieved automatically by generating a new randomized interface identifier at least once every (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE - DESYNC_FACTOR) time units. As described above, generating a new temporary address REGEN_ADVANCE time units before a temporary address becomes deprecated produces addresses with a preferred lifetime no larger than TEMP_PREFERRED_LIFETIME. The value DESYNC_FACTOR is a random value (different for each client) that ensures that clients don't synchronize with each other and generate new addresses at exactly the same time. When the preferred lifetime expires, a new temporary address MUST be generated using the new randomized interface identifier.",
      "ja": "この仕様を次のノードは、定期的に新しい一時アドレスを生成する必要があります。時間単位これは、少なくとも一度（ -   -  REGEN_ADVANCE DESYNC_FACTOR TEMP_PREFERRED_LIFETIME）新しいランダムインタフェース識別子を生成することによって自動的に達成することができます。上述したように、一時的アドレスは廃止になる前に、新しい一時的なアドレスREGEN_ADVANCE時間単位を生成するTEMP_PREFERRED_LIFETIMEより大きくない好ましい寿命とアドレスを生成します。値DESYNC_FACTORは、クライアントが互いに同期とまったく同じ時刻に新しいアドレスを生成しないことを保証します（クライアントごとに異なる）ランダムな値です。好適寿命の期限が切れると、新しい一時アドレスは新しいランダム化されたインタフェース識別子を使用して生成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Because the precise frequency at which it is appropriate to generate new addresses varies from one environment to another, implementations SHOULD provide end users with the ability to change the frequency at which addresses are regenerated. The default value is given in TEMP_PREFERRED_LIFETIME and is one day. In addition, the exact time at which to invalidate a temporary address depends on how applications are used by end users. Thus, the suggested default value of one week (TEMP_VALID_LIFETIME) may not be appropriate in all environments. Implementations SHOULD provide end users with the ability to override both of these default values.",
      "ja": "新しいアドレスを生成するために適切れる正確な周波数は、ある環境から別のものに変化するので、実装は、アドレスを再生成する頻度を変更する能力をエンドユーザに提供すべきです。デフォルト値はTEMP_PREFERRED_LIFETIMEに与えられ、1日です。また、一時アドレスを無効にする正確な時間は、アプリケーションがエンドユーザーによって使用されている方法によって異なります。このように、1週間（TEMP_VALID_LIFETIME）の提案デフォルト値は、すべての環境で適切ではないかもしれません。実装はこれらのデフォルト値の両方を無効にする能力をエンドユーザに提供すべきです。"
    },
    {
      "indent": 3,
      "text": "Finally, when an interface connects to a new link, a new randomized interface identifier SHOULD be generated immediately together with a new set of temporary addresses. If a device moves from one ethernet to another, generating a new set of temporary addresses from a different randomized interface identifier ensures that the device uses different randomized interface identifiers for the temporary addresses associated with the two links, making it more difficult to correlate addresses from the two different links as being from the same node. The node MAY follow any process available to it, to determine that the link change has occurred. One such process is described by Detecting Network Attachment [DNA].",
      "ja": "インタフェースは新しいリンクに接続したときに最後に、新しいランダム化されたインタフェース識別子は、一時アドレスの新しいセットと一緒に、すぐに生成する必要があります。デバイスが別のイーサネット（登録商標）から移動した場合、異なるランダムインタフェース識別子から一時アドレスの新しいセットを生成することは、より困難からアドレスを相関すること、デバイスは、2つのリンクに関連付けられた一時的なアドレスの異なるランダムインタフェース識別子を使用することを保証します同じノードからのもののような2つの異なるリンク。ノードは、リンク変更が発生したことを判断するために、それが利用可能な任意のプロセスに従うことができます。そのようなプロセスは、ネットワーク接続[DNA]を検出することによって説明されます。"
    },
    {
      "indent": 0,
      "text": "3.6. Deployment Considerations",
      "section_title": true,
      "ja": "3.6。展開に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Devices implementing this specification MUST provide a way for the end user to explicitly enable or disable the use of temporary addresses. In addition, a site might wish to disable the use of temporary addresses in order to simplify network debugging and operations. Consequently, implementations SHOULD provide a way for trusted system administrators to enable or disable the use of temporary addresses.",
      "ja": "この仕様を実装するデバイスは、エンドユーザーが明示的に一時アドレスの使用を有効または無効にするための方法を提供しなければなりません。また、サイトでは、ネットワークのデバッグと運用を簡素化するために、一時的なアドレスの使用を無効にしたい場合があります。その結果、実装は一時アドレスの使用を有効または無効にする、信頼できるシステム管理者のための方法を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Additionally, sites might wish to selectively enable or disable the use of temporary addresses for some prefixes. For example, a site might wish to disable temporary address generation for \"Unique local\" [ULA] prefixes while still generating temporary addresses for all other global prefixes. Another site might wish to enable temporary address generation only for the prefixes 2001::/16 and 2002::/16, while disabling it for all other prefixes. To support this behavior, implementations SHOULD provide a way to enable and disable generation of temporary addresses for specific prefix subranges. This per-prefix setting SHOULD override the global settings on the node with respect to the specified prefix subranges. Note that the pre-prefix setting can be applied at any granularity, and not necessarily on a per-subnet basis.",
      "ja": "また、サイトでは、選択的に、いくつかのプレフィックスのための一時的なアドレスの使用を有効または無効にしたい場合があります。たとえば、サイトには、まだ他のすべてのグローバルプレフィックスのための一時的なアドレスを生成しながら、「地元のユニークな」[ULA]プレフィックスのための一時アドレスの生成を無効にしたい場合があります。別のサイトには、他のすべての接頭辞のためにそれを無効にしながら、唯一のプレフィクス2001 :: / 16と2002 :: / 16のための一時アドレスの生成を有効にしたいかもしれません。この動作をサポートするために、実装は、特定のプレフィックス部分的な範囲のために、一時アドレスの生成を有効または無効にする方法を提供する必要があります。このプレフィクス単位の設定は、指定したプレフィックスサブレンジに対するノード上のグローバル設定をオーバーライドする必要があります。前の接頭辞の設定は任意の粒度で適用することができる、と必ずしもあたりサブネットベースで。"
    },
    {
      "indent": 3,
      "text": "The use of temporary addresses may cause unexpected difficulties with some applications. As described below, some servers refuse to accept communications from clients for which they cannot map the IP address into a DNS name. In addition, some applications may not behave robustly if temporary addresses are used and an address expires before the application has terminated, or if it opens multiple sessions, but expects them to all use the same addresses. Consequently, the use of temporary addresses SHOULD be disabled by default in order to minimize potential disruptions. Individual applications, which have specific knowledge about the normal duration of connections, MAY override this as appropriate.",
      "ja": "一時アドレスの使用は、いくつかのアプリケーションで予期しない困難を引き起こす可能性があります。後述するように、いくつかのサーバーは、DNS名にIPアドレスをマッピングすることができないため、クライアントからの通信を受け入れることを拒否します。また、一時的なアドレスが使用されている場合、一部のアプリケーションが確実に動作しないことと同じアドレスを使用するアプリケーションが終了する前、またはそれは複数のセッションを開いた場合、しかし、すべてにそれらを期待していたアドレスの有効期限が切れます。その結果、一時的なアドレスの使用は、潜在的な混乱を最小限に抑えるためには、デフォルトでは無効にする必要があります。接続の通常の期間についての具体的な知識を持っている個々のアプリケーションは、必要に応じてこれを無効にすることができます。"
    },
    {
      "indent": 3,
      "text": "If a very small number of nodes (say, only one) use a given prefix for extended periods of time, just changing the interface identifier part of the address may not be sufficient to ensure privacy, since the prefix acts as a constant identifier. The procedures described in this document are most effective when the prefix is reasonably non static or is used by a fairly large number of nodes.",
      "ja": "ノードの非常に少数（たとえば、一方のみ）長時間、所定のプレフィクスを使用する場合、接頭辞は、一定の識別子として作用するため、単にアドレスのインタフェース識別子部分を変更すると、プライバシーを確​​保するのに十分ではないかもしれません。プレフィックスが合理的、非静的であるか、またはノードのかなり多数で使用される場合、この文書に記載された手順は、最も効果的です。"
    },
    {
      "indent": 0,
      "text": "4. Implications of Changing Interface Identifiers",
      "section_title": true,
      "ja": "インタフェース識別子を変更する4.影響"
    },
    {
      "indent": 3,
      "text": "The IPv6 addressing architecture goes to some lengths to ensure that interface identifiers are likely to be globally unique where easy to do so. The widespread use of temporary addresses may result in a significant fraction of Internet traffic not using addresses in which the interface identifier portion is globally unique. Consequently, usage of the algorithms in this document may complicate providing such a future flexibility, if global uniqueness is necessary.",
      "ja": "IPv6のアドレス体系は、そのインターフェイス識別子がどこそうするのは簡単、グローバルに一意である可能性が高いことを確認するために、いくつかの長さになります。一時アドレスの普及は、インタフェース識別子部分がグローバルに一意であるアドレスを使用していないインターネットトラフィックのかなりの部分をもたらすことができます。したがって、この文書に記載されているアルゴリズムの使用は、グローバルな一意性が必要な場合、そのような将来の柔軟性を提供複雑にすることができます。"
    },
    {
      "indent": 3,
      "text": "The desires of protecting individual privacy versus the desire to effectively maintain and debug a network can conflict with each other. Having clients use addresses that change over time will make it more difficult to track down and isolate operational problems. For example, when looking at packet traces, it could become more difficult to determine whether one is seeing behavior caused by a single errant machine, or by a number of them.",
      "ja": "欲望対個人のプライバシーを保護するための欲望が効果的に維持し、ネットワークをデバッグすることは互いに競合することができます。クライアントが時間とともに変化するアドレスを使用して持つことは追跡と操作上の問題を分離することがより困難になります。パケットトレースを見ると、例えば、それは1つが、単一の誤ったマシンによって引き起こされる行動を見ているか、またはそれらの数によって決定することがより困難になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some servers refuse to grant access to clients for which no DNS name exists. That is, they perform a DNS PTR query to determine the DNS name, and may then also perform an AAAA query on the returned name to verify that the returned DNS name maps back into the address being used. Consequently, clients not properly registered in the DNS may be unable to access some services. As noted earlier, however, a node's DNS name (if non-changing) serves as a constant identifier. The wide deployment of the extension described in this document could challenge the practice of inverse-DNS-based \"authentication,\" which has little validity, though it is widely implemented. In order to meet server challenges, nodes could register temporary addresses in the DNS using random names (for example, a string version of the random address itself).",
      "ja": "一部のサーバーにはDNS名が存在しないため、クライアントへのアクセスを許可することを拒否します。それは、彼らがDNS名を決定するためにDNS PTRクエリを実行し、その後も返さDNS名が戻って使用されているアドレスにマッピングしていることを確認するために返された名前にAAAAクエリを実行する場合があります。その結果、適切にDNSに登録されていないクライアントは、いくつかのサービスにアクセスできないことがあります。前述のように、しかし、ノードのDNS名（非変更の場合）一定の識別子として機能します。このドキュメントで説明する拡張機能の広い展開は、それが広く実装されているが、少し妥当性を持って逆DNSベースの「認証」の実践に挑戦できます。サーバー上の課題に対応するために、ノードはランダムな名前を使用してDNSで一時アドレスを登録することができ（例えば、ランダムなアドレス自体の文字列バージョン）。"
    },
    {
      "indent": 3,
      "text": "Use of the extensions defined in this document may complicate debugging and other operational troubleshooting activities. Consequently, it may be site policy that temporary addresses should not be used. Consequently, implementations MUST provide a method for the end user or trusted administrator to override the use of temporary addresses.",
      "ja": "この文書で定義された拡張の使用は、デバッグおよびその他の業務のトラブルシューティング活動を複雑にする可能性があります。したがって、それは一時的なアドレスが使用されるべきではないとサイトのポリシーかもしれません。その結果、実装は一時アドレスの使用を無効にするには、エンドユーザーまたは信頼できる管理者のための方法を提供しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. Defined Constants",
      "section_title": true,
      "ja": "5.定義された定数"
    },
    {
      "indent": 3,
      "text": "Constants defined in this document include:",
      "ja": "この文書で定義された定数は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "TEMP_VALID_LIFETIME -- Default value: 1 week. Users should be able to override the default value.",
      "ja": "TEMP_VALID_LIFETIME  - デフォルト値：1週間。ユーザーは、デフォルト値を上書きすることができるはずです。"
    },
    {
      "indent": 3,
      "text": "TEMP_PREFERRED_LIFETIME -- Default value: 1 day. Users should be able to override the default value.",
      "ja": "TEMP_PREFERRED_LIFETIME  - デフォルト値：1日。ユーザーは、デフォルト値を上書きすることができるはずです。"
    },
    {
      "indent": 3,
      "text": "REGEN_ADVANCE -- 5 seconds",
      "ja": "REGEN_ADVANCE  -  5秒"
    },
    {
      "indent": 3,
      "text": "MAX_DESYNC_FACTOR -- 10 minutes. Upper bound on DESYNC_FACTOR.",
      "ja": "MAX_DESYNC_FACTOR  -  10分。アッパーはDESYNC_FACTORに結合しました。"
    },
    {
      "indent": 3,
      "text": "DESYNC_FACTOR -- A random value within the range 0 - MAX_DESYNC_FACTOR. It is computed once at system start (rather than each time it is used) and must never be greater than (TEMP_VALID_LIFETIME - REGEN_ADVANCE).",
      "ja": "DESYNC_FACTOR  -  MAX_DESYNC_FACTOR  - 範囲0内のランダムな値。それは、（むしろそれが使用されるたびに比べて）システム起動時に一度計算されると（TEMP_VALID_LIFETIME  -  REGEN_ADVANCE）以上にすることはできません。"
    },
    {
      "indent": 3,
      "text": "TEMP_IDGEN_RETRIES -- Default value: 3",
      "ja": "TEMP_IDGEN_RETRIES  - デフォルト値：3"
    },
    {
      "indent": 0,
      "text": "6. Future Work",
      "section_title": true,
      "ja": "6.今後の課題"
    },
    {
      "indent": 3,
      "text": "An implementation might want to keep track of which addresses are being used by upper layers so as to be able to remove a deprecated temporary address from internal data structures once no upper layer protocols are using it (but not before). This is in contrast to current approaches where addresses are removed from an interface when they become invalid [ADDRCONF], independent of whether or not upper layer protocols are still using them. For TCP connections, such information is available in control blocks. For UDP-based applications, it may be the case that only the applications have knowledge about what addresses are actually in use. Consequently, an implementation generally will need to use heuristics in deciding when an address is no longer in use.",
      "ja": "実装には、上位層プロトコルがそれを使用していない（ただし前）されると、内部データ構造から非推奨の一時的なアドレスを削除することができるようにアドレスが上位層によって使用されているかを追跡することができます。これは、上位層プロトコルがまだそれらを使用しているか否かとは無関係に、それらが無効[ADDRCONF]になったときのアドレスがインタフェースから削除される現在のアプローチとは対照的です。 TCP接続の場合、このような情報は、制御ブロックで利用可能です。 UDPベースのアプリケーションでは、アプリケーションのみがアドレスが実際に使用中であるかについての知識を持っている場合があります。その結果、実装は一般的にアドレスが使用されなくなったときに決めないでヒューリスティックを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The determination as to whether to use public versus temporary addresses can in some cases only be made by an application. For example, some applications may always want to use temporary addresses, while others may want to use them only in some circumstances or not at all. Suitable API extensions will likely need to be developed to enable individual applications to indicate with sufficient granularity their needs with regards to the use of temporary addresses. Recommendations on DNS practices to avoid the problem described in Section 4 when reverse DNS lookups fail may be needed. [DNSOP] contains a more detailed discussion of the DNS-related issues.",
      "ja": "一時アドレス対公衆使用するかどうかの決意は、いくつかのケースではアプリケーションによってのみ行うことができます。例えば、いくつかのアプリケーションは、常に他の人が唯一のいくつかの状況または全くないでそれらを使用するかもしれないが、一時的なアドレスを使用することをお勧めします。適したAPIの拡張機能は、おそらく一時的なアドレスの使用に関して十分な精度で彼らのニーズを示すために、個々のアプリケーションを可能にするために開発する必要があります。 DNSの逆引きが必要になることが失敗したときに第4節で説明した問題を回避するために、DNSの実践に関する提言。 [DNSOP] DNS関連の問題のより詳細な議論が含まれています。"
    },
    {
      "indent": 3,
      "text": "While this document discusses ways of obscuring a user's permanent IP address, the method described is believed to be ineffective against sophisticated forms of traffic analysis. To increase effectiveness, one may need to consider use of more advanced techniques, such as Onion Routing [ONION].",
      "ja": "この文書は、ユーザーの恒久的なIPアドレスを不明瞭にする方法について説明しますが、記載されている方法は、トラフィック分析の洗練されたフォームに対して効果がないことが考えられています。実効性を高めるために、1は、このようなオニオンルーティング[ONION]など、より高度な技術の使用を検討する必要があるかもしれません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Ingress filtering has been and is being deployed as a means of preventing the use of spoofed source addresses in Distributed Denial of Service (DDoS) attacks. In a network with a large number of nodes, new temporary addresses are created at a fairly high rate. This might make it difficult for ingress filtering mechanisms to distinguish between legitimately changing temporary addresses and spoofed source addresses, which are \"in-prefix\" (using a topologically correct prefix and non-existent interface ID). This can be addressed by using access control mechanisms on a per-address basis on the network egress point.",
      "ja": "イングレスフィルタリングはされており、分散サービス妨害（DDoS）攻撃の攻撃でスプーフィングされた送信元アドレスの使用を防止する手段として展開されています。多数のノードを持つネットワークでは、新しい一時アドレスは、かなり高い割合で作成されます。イングレスフィルタリングメカニズムは、「イン接頭辞」されている合法的に変更、一時アドレスと偽装された送信元アドレス、区別するためにこれが（位相幾何学的に正しいプレフィックスと、存在しないインターフェイスIDを使用して）ことが困難になるかもしれません。これは、ネットワーク出口ポイントに当たりアドレスに基づいてアクセス制御メカニズムを使用することによって対処することができます。"
    },
    {
      "indent": 1,
      "text": "8. Significant Changes from",
      "section_title": true,
      "ja": "8.著しい変動があったから"
    },
    {
      "indent": 3,
      "text": "This section summarizes the changes in this document relative to RFC 3041 that an implementer of RFC 3041 should be aware of.",
      "ja": "このセクションでは、RFC 3041の実装が知っておくべきことをRFC 3041には、このドキュメント相対の変化をまとめたもの。"
    },
    {
      "indent": 3,
      "text": "1. Excluded certain interface identifiers from the range of acceptable interface identifiers. Interface IDs such as those for reserved anycast addresses [RFC2526], etc.",
      "ja": "1.許容されるインタフェース識別子の範囲から特定のインタフェース識別子を除外しました。そのような予約されたエニキャストアドレス[RFC2526]などのものとインターフェイスID"
    },
    {
      "indent": 3,
      "text": "2. Added a configuration knob that provides the end user with a way to enable or disable the use of temporary addresses on a per-prefix basis.",
      "ja": "2.プレフィクス単位ベースで一時アドレスの使用を有効または無効にする方法をエンドユーザに提供し、設定ノブを追加しました。"
    },
    {
      "indent": 3,
      "text": "3. Added a check for denial of service attacks using low valid lifetimes in router advertisements.",
      "ja": "3.ルータ広告で低有効寿命を使用してサービス拒否攻撃のためのチェックを追加しました。"
    },
    {
      "indent": 3,
      "text": "4. DAD is now run on all temporary addresses, not just the first one generated from an interface identifier.",
      "ja": "4. DADは今、すべての一時アドレスのインターフェイス識別子から生成されただけでなく、最初の1を実行しています。"
    },
    {
      "indent": 3,
      "text": "5. Changed the default setting for usage of temporary addresses to be disabled.",
      "ja": "5.無効にするための一時アドレスの使用のためのデフォルト設定を変更しました。"
    },
    {
      "indent": 3,
      "text": "6. The node is now allowed to generate different interface identifiers for different prefixes, if it so desires.",
      "ja": "そう望む場合6.ノードは現在、異なるプレフィックスのための異なるインタフェース識別子を生成することができます。"
    },
    {
      "indent": 3,
      "text": "7. The algorithm used for generating random interface identifiers is no longer restricted to just MD5.",
      "ja": "7.ランダムインタフェース識別子を生成するのに使用されるアルゴリズムは、もはや単なるMD5に限定されません。"
    },
    {
      "indent": 3,
      "text": "8. Reduced default number of retries to 3 and added a configuration variable.",
      "ja": "8. 3にデフォルトのリトライ回数を減少させ、構成変数を追加しました。"
    },
    {
      "indent": 3,
      "text": "9. Router advertisement (RA) processing algorithm is no longer included in the document, and is replaced by a reference to [ADDRCONF].",
      "ja": "9.ルータ広告（RA）処理アルゴリズムは、もはや文書に含まれていない、そして[ADDRCONF]を参照することによって置き換えられます。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgments",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "Rich Draves and Thomas Narten were the authors of RFC 3041. They would like to acknowledge the contributions of the ipv6 working group and, in particular, Ran Atkinson, Matt Crawford, Steve Deering, Allison Mankin, and Peter Bieringer.",
      "ja": "リッチDravesとトーマスNarten氏は具体的には、アトキンソン、マット・クロフォード、スティーブデアリング、アリソンマンキン、そしてピーターBieringer蘭、彼らは、IPv6ワーキンググループの貢献を認めたいRFC 3041の作者だったと。"
    },
    {
      "indent": 3,
      "text": "Suresh Krishnan was the sole author of this version of the document. He would like to acknowledge the contributions of the ipv6 working group and, in particular, Jari Arkko, Pekka Nikander, Pekka Savola, Francis Dupont, Brian Haberman, Tatuya Jinmei, and Margaret Wasserman for their detailed comments.",
      "ja": "スレシュクリシュナンは、ドキュメントのこのバージョンの唯一の著者でした。彼は、彼らの詳細なコメントのIPv6ワーキンググループの貢献と、特に、ヤリArkko、ペッカNikander、ペッカSavola、フランシスデュポン、ブライアンハーバーマン、達也神明、およびマーガレットワッサーマンを承認したいと思います。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[ADDRARCH] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 4291, February 2006.",
      "ja": "[ADDRARCH] HindenとR.とS.デアリング、 \"IPバージョン6アドレッシング体系\"、RFC 4291、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[ADDRCONF] Thomson, S., Narten, T., and T. Jinmei, \"IPv6 Stateless Address Autoconfiguration\", RFC 4862, September 2007.",
      "ja": "[ADDRCONF]トムソン、S.、Narten氏、T.、およびT.神明、 \"IPv6のステートレスアドレス自動設定\"、RFC 4862、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[DISCOVERY] Narten, T., Nordmark, E., Simpson, W., and H. Soliman, \"Neighbor Discovery for IP version 6 (IPv6)\", RFC 4861, September 2007.",
      "ja": "[DISCOVERY] Narten氏、T.、Nordmarkと、E.、シンプソン、W.、およびH.ソリマン、 \"IPバージョン6（IPv6）のための近隣探索\"、RFC 4861、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[MD5] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[MD5] Rivest氏、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[ADDR_SELECT] Draves, R., \"Default Address Selection for Internet Protocol version 6 (IPv6)\", RFC 3484, February 2003.",
      "ja": "[ADDR_SELECT] Draves、R.、RFC 3484 \"インターネットプロトコルバージョン6（IPv6）のデフォルトのアドレス選択\"、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[CGA] Aura, T., \"Cryptographically Generated Addresses (CGA)\", RFC 3972, March 2005.",
      "ja": "[CGA]オーラ、T.、 \"暗号的に生成されたアドレス（CGA）\"、RFC 3972、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[COOKIES] Kristol, D. and L. Montulli, \"HTTP State Management Mechanism\", RFC 2965, October 2000.",
      "ja": "[COOKIES]クリストル、D.およびL. Montulli、 \"HTTP状態管理機構\"、RFC 2965、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[DDNS] Vixie, P., Thomson, S., Rekhter, Y., and J. Bound, \"Dynamic Updates in the Domain Name System (DNS UPDATE)\", RFC 2136, April 1997.",
      "ja": "[DDNS]いるVixie、P.、トムソン、S.、Rekhter、Y.、およびJ.バウンド、 \"ドメインネームシステムにおける動的更新（DNS更新）\"、RFC 2136、1997年4月。"
    },
    {
      "indent": 3,
      "text": "[DHCP] Droms, R., \"Dynamic Host Configuration Protocol\", RFC 2131, March 1997.",
      "ja": "[DHCP] Droms、R.、 \"動的ホスト構成プロトコル\"、RFC 2131、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[DHCPV6] Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, \"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)\", RFC 3315, July 2003.",
      "ja": "[DHCPV6] Droms、R.、バウンド、J.、フォルツ、B.、レモン、T.、パーキンス、C.、およびM.カーニー、 \"IPv6のための動的ホスト構成プロトコル（DHCPv6）\"、RFC 3315、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[DNA] Choi, JH. and G. Daley, \"Goals of Detecting Network Attachment in IPv6\", RFC 4135, August 2005.",
      "ja": "[DNA]チェ、JH。そして、G.デイリー、「IPv6におけるネットワーク接続検出の目標」、RFC 4135、2005年8月。"
    },
    {
      "indent": 3,
      "text": "[DNSOP] Durand, A., Ihren, J., and P. Savola, \"Operational Considerations and Issues with IPv6 DNS\", RFC 4472, April 2006.",
      "ja": "[DNSOP]デュラン、A.、Ihren、J.、およびP. Savola、RFC 4472 \"IPv6のDNSで運用考慮事項と課題\"、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[ONION] Reed, MGR., Syverson, PFS., and DMG. Goldschlag, \"Proxies for Anonymous Routing\", Proceedings of the 12th Annual Computer Security Applications Conference, San Diego, CA, December 1996.",
      "ja": "[ONION]リード、MGR。、Syverson、PFS、およびDMG。 Goldschlag、「匿名ルーティングのためのプロキシ」、第12回コンピュータセキュリティアプリケーションの会議の議事録、サンディエゴ、CA、1996年12月。"
    },
    {
      "indent": 3,
      "text": "[RANDOM] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[ランダム]イーストレーク、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2526] Johnson, D. and S. Deering, \"Reserved IPv6 Subnet Anycast Addresses\", RFC 2526, March 1999.",
      "ja": "[RFC2526]ジョンソン、D.とS.デアリング、 \"予約済みのIPv6サブネットエニーキャストアドレス\"、RFC 2526、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[SEND] Arkko, J., Kempf, J., Zill, B., and P. Nikander, \"SEcure Neighbor Discovery (SEND)\", RFC 3971, March 2005.",
      "ja": "[SEND] Arkko、J.、ケンプ、J.、Zill、B.、およびP. Nikander、 \"セキュア近隣探索（SEND）\"、RFC 3971、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[ULA] Hinden, R. and B. Haberman, \"Unique Local IPv6 Unicast Addresses\", RFC 4193, October 2005.",
      "ja": "[ULA] HindenとR.とB.ハーバーマン、 \"ユニークローカルIPv6ユニキャストアドレス\"、RFC 4193、2005年10月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Thomas Narten IBM Corporation P.O. Box 12195 Research Triangle Park, NC USA",
      "ja": "トーマスNarten氏IBM社の私書箱ボックス12195リサーチトライアングルパーク、NC USA"
    },
    {
      "indent": 3,
      "text": "EMail: narten@us.ibm.com",
      "ja": "メールアドレス：narten@us.ibm.com"
    },
    {
      "indent": 3,
      "text": "Richard Draves Microsoft Research One Microsoft Way Redmond, WA USA",
      "ja": "リチャードDravesマイクロソフトリサーチ1つのマイクロソフト道、レッドモンド、ワシントン州"
    },
    {
      "indent": 3,
      "text": "EMail: richdr@microsoft.com",
      "ja": "メールアドレス：richdr@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Suresh Krishnan Ericsson Research 8400 Decarie Blvd. Town of Mount Royal, QC Canada",
      "ja": "スレシュクリシュナンエリクソン研究8400 Decarie大通りマウントロイヤル、QCカナダの町"
    },
    {
      "indent": 3,
      "text": "EMail: suresh.krishnan@ericsson.com",
      "ja": "メールアドレス：suresh.krishnan@ericsson.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "著作権（C）IETFトラスト（2007）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットSOCIETY、（もしあれば）を後援し、IETF TRUST ANDインターネットエンジニアリングタスクフォース放棄ALLに設けられています。保証は、明示または黙示、この情報の利用および特定目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証がこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    }
  ]
}