{
  "title": {
    "text": "RFC 4366 - Transport Layer Security (TLS) Extensions",
    "ja": "RFC 4366 - トランスポート層セキュリティ（TLS）拡張機能"
  },
  "number": 4366,
  "created_at": "2019-10-24 05:06:31.566358+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                    S. Blake-Wilson\nRequest for Comments: 4366                                           BCI\nObsoletes: 3546                                               M. Nystrom\nUpdates: 4346                                               RSA Security\nCategory: Standards Track                                     D. Hopwood\n                                                  Independent Consultant\n                                                            J. Mikkelsen\n                                                         Transactionware\n                                                               T. Wright\n                                                                Vodafone\n                                                              April 2006",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Transport Layer Security (TLS) Extensions",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes extensions that may be used to add functionality to Transport Layer Security (TLS). It provides both generic extension mechanisms for the TLS handshake client and server hellos, and specific extensions using these generic mechanisms.",
      "ja": "この文書では、トランスポート層セキュリティ（TLS）に機能を追加するために使用することができる拡張機能について説明します。これは、TLSハンドシェイククライアントとサーバのhello、およびこれらの一般的なメカニズムを使用して、特定の拡張子の両方の一般的な拡張メカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "The extensions may be used by TLS clients and servers. The extensions are backwards compatible: communication is possible between TLS clients that support the extensions and TLS servers that do not support the extensions, and vice versa.",
      "ja": "エクステンションは、TLSクライアントとサーバが使用することができます。拡張子は、下位互換性があります。通信拡張機能をサポートしていない拡張機能やTLSサーバをサポートするTLSクライアント、およびその逆の間で可能です。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Conventions Used in This Document ..........................5\n2. General Extension Mechanisms ....................................5\n   2.1. Extended Client Hello ......................................5\n   2.2. Extended Server Hello ......................................6\n   2.3. Hello Extensions ...........................................6\n   2.4. Extensions to the Handshake Protocol .......................8\n3. Specific Extensions .............................................8\n   3.1.  Server Name Indication ....................................9\n   3.2.  Maximum Fragment Length Negotiation ......................11\n   3.3.  Client Certificate URLs ..................................12\n   3.4.  Trusted CA Indication ....................................15\n   3.5. Truncated HMAC ............................................16\n   3.6. Certificate Status Request ................................17\n4. Error Alerts ...................................................19\n5. Procedure for Defining New Extensions ..........................20\n6. Security Considerations ........................................21\n   6.1. Security of server_name ...................................22\n   6.2. Security of max_fragment_length ...........................22\n   6.3. Security of client_certificate_url ........................22\n   6.4. Security of trusted_ca_keys ...............................24\n   6.5. Security of truncated_hmac ................................24\n   6.6. Security of status_request ................................25\n7. Internationalization Considerations ............................25\n8. IANA Considerations ............................................25\n9. Acknowledgements ...............................................27\n10. Normative References ..........................................27\n11. Informative References ........................................28",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes extensions that may be used to add functionality to Transport Layer Security (TLS). It provides both generic extension mechanisms for the TLS handshake client and server hellos, and specific extensions using these generic mechanisms.",
      "ja": "この文書では、トランスポート層セキュリティ（TLS）に機能を追加するために使用することができる拡張機能について説明します。これは、TLSハンドシェイククライアントとサーバのhello、およびこれらの一般的なメカニズムを使用して、特定の拡張子の両方の一般的な拡張メカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "TLS is now used in an increasing variety of operational environments, many of which were not envisioned when the original design criteria for TLS were determined. The extensions introduced in this document are designed to enable TLS to operate as effectively as possible in new environments such as wireless networks.",
      "ja": "TLSは現在、TLSの元の設計基準を決定した際に想定されていなかったその多くは運用環境の増加多様に使用されています。このドキュメントで紹介拡張は、ワイヤレスネットワークなどの新しい環境にできるだけ効果的に動作するためにTLSを有効にするために設計されています。"
    },
    {
      "indent": 3,
      "text": "Wireless environments often suffer from a number of constraints not commonly present in wired environments. These constraints may include bandwidth limitations, computational power limitations, memory limitations, and battery life limitations.",
      "ja": "ワイヤレス環境では、多くの場合、有線環境では一般的に存在しない制約の数に苦しんでいます。これらの制約は、帯域幅の制限、計算能力の制限、メモリ制限、および電池寿命の制限を含むことができます。"
    },
    {
      "indent": 3,
      "text": "The extensions described here focus on extending the functionality provided by the TLS protocol message formats. Other issues, such as the addition of new cipher suites, are deferred.",
      "ja": "ここで説明する拡張は、TLSプロトコルメッセージフォーマットで提供される機能を拡張するに焦点を当てます。新たな暗号スイートの追加などの他の問題は、延期されています。"
    },
    {
      "indent": 3,
      "text": "Specifically, the extensions described in this document:",
      "ja": "具体的には、拡張子は、この文書で説明します："
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients to provide to the TLS server the name of the server they are contacting. This functionality is desirable in order to facilitate secure connections to servers that host multiple 'virtual' servers at a single underlying network address.",
      "ja": " -  TLSクライアントはTLSサーバに、彼らが接触しているサーバーの名前を提供することを許可します。この機能は、単一の基盤となるネットワークアドレスに複数の「仮想」サーバをホストするサーバーへのセキュアな接続を容易にするために望ましいです。"
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients and servers to negotiate the maximum fragment length to be sent. This functionality is desirable as a result of memory constraints among some clients, and bandwidth constraints among some access networks.",
      "ja": " -  TLSクライアントとサーバが送信する最大フラグメント長を交渉することを許可します。この機能は、いくつかのアクセスネットワークの中で、いくつかのクライアントの間でメモリ制約、および帯域幅の制約の結果として望ましいです。"
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients and servers to negotiate the use of client certificate URLs. This functionality is desirable in order to conserve memory on constrained clients.",
      "ja": " -  TLSクライアントとサーバは、クライアント証明書のURLの使用を交渉することを許可します。この機能は、制約のクライアントでメモリを節約するために望ましいです。"
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients to indicate to TLS servers which CA root keys they possess. This functionality is desirable in order to prevent multiple handshake failures involving TLS clients that are only able to store a small number of CA root keys due to memory limitations.",
      "ja": " -  TLSクライアントはCAルート鍵は、彼らが持っているTLSサーバに指示することを許可します。この機能は、メモリの制限のためにCAルート鍵の小さな番号を保存することができますTLSクライアントを含む複数のハンドシェイクの失敗を防ぐために望ましいです。"
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients and servers to negotiate the use of truncated MACs. This functionality is desirable in order to conserve bandwidth in constrained access networks.",
      "ja": " -  TLSクライアントとサーバは切り捨てMACの使用を交渉することを許可します。この機能は、制約されたアクセスネットワークにおける帯域幅を節約するために望ましいです。"
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients and servers to negotiate that the server sends the client certificate status information (e.g., an Online Certificate Status Protocol (OCSP) [OCSP] response) during a TLS handshake. This functionality is desirable in order to avoid sending a Certificate Revocation List (CRL) over a constrained access network and therefore save bandwidth.",
      "ja": " -  TLSクライアントとサーバは、サーバがTLSハンドシェイク中にクライアント証明書ステータス情報（例えば、オンライン証明書状態プロトコル（OCSP）[OCSP]応答）を送信することを交渉することを許可します。この機能は、制約されたアクセスネットワーク上で証明書失効リスト（CRL）を送信しないよう、したがって、帯域幅を節約するために望ましいです。"
    },
    {
      "indent": 3,
      "text": "In order to support the extensions above, general extension mechanisms for the client hello message and the server hello message are introduced.",
      "ja": "上記の拡張をサポートするために、クライアントのhelloメッセージとサーバハローメッセージのための一般的な拡張メカニズムが導入されています。"
    },
    {
      "indent": 3,
      "text": "The extensions described in this document may be used by TLS clients and servers. The extensions are designed to be backwards compatible, meaning that TLS clients that support the extensions can talk to TLS servers that do not support the extensions, and vice versa. The document therefore updates TLS 1.0 [TLS] and TLS 1.1 [TLSbis].",
      "ja": "この文書で説明する機能拡張は、TLSクライアントとサーバが使用することができます。拡張は拡張をサポートするTLSクライアントが拡張をサポートしていないTLSサーバ、およびその逆に話すことができることを意味し、後方互換性を持つように設計されています。文書は、したがって、TLS 1.0 [TLS]およびTLS 1.1 [TLSbis]を更新します。"
    },
    {
      "indent": 3,
      "text": "Backwards compatibility is primarily achieved via two considerations:",
      "ja": "後方互換性は、主に次の2つの考慮事項によって達成されます。"
    },
    {
      "indent": 3,
      "text": "- Clients typically request the use of extensions via the extended client hello message described in Section 2.1. TLS requires servers to accept extended client hello messages, even if the server does not \"understand\" the extension.",
      "ja": " - クライアントは、通常、2.1節で説明した拡張クライアントのhelloメッセージを経由してエクステンションの使用を要求します。 TLSは、サーバーが拡張子を「理解」していない場合でも、拡張されたクライアントhelloメッセージを受け入れるためにサーバを必要とします。"
    },
    {
      "indent": 3,
      "text": "- For the specific extensions described here, no mandatory server response is required when clients request extended functionality.",
      "ja": " - クライアントが拡張機能を要求したときに、ここに記載された特定の拡張のために、何の義務的なサーバーの応答は必要ありません。"
    },
    {
      "indent": 3,
      "text": "Essentially, backwards compatibility is achieved based on the TLS requirement that servers that are not \"extensions-aware\" ignore data added to client hellos that they do not recognize; for example, see Section 7.4.1.2 of [TLS].",
      "ja": "基本的に、後方互換性は、「拡張子を認識」されないサーバは、彼らが認識しないクライアントのhelloに追加されたデータを無視するTLS要件に基づいて達成されます。たとえば、[TLS]のセクション7.4.1.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note, however, that although backwards compatibility is supported, some constrained clients may be forced to reject communications with servers that do not support the extensions as a result of the limited capabilities of such clients.",
      "ja": "後方互換性がサポートされていますが、いくつかの制約のクライアントは、このようなクライアントの限られた能力の結果としての拡張機能をサポートしていないサーバーとの通信を拒否するように強制することができること、しかし、注意してください。"
    },
    {
      "indent": 3,
      "text": "This document is a revision of the RFC3546 [RFC3546]. The only major change concerns the definition of new extensions. New extensions can now be defined via the IETF Consensus Process (rather than requiring a standards track RFC). In addition, a few minor clarifications and editorial improvements were made.",
      "ja": "このドキュメントは、RFC3546 [RFC3546]の改訂版です。唯一の主要な変更は、新しい拡張機能の定義に関するものです。新しい拡張機能は、現在IETFコンセンサス・プロセス（というよりも標準トラックRFCを必要とする）を介して定義することができます。また、いくつかのマイナーな明確化と編集の改善が行われました。"
    },
    {
      "indent": 3,
      "text": "The remainder of this document is organized as follows. Section 2 describes general extension mechanisms for the client hello and server hello handshake messages. Section 3 describes specific extensions to TLS. Section 4 describes new error alerts for use with",
      "ja": "このドキュメントの残りは以下の通り構成されています。第2節では、クライアントハローとサーバハローハンドシェイクメッセージのための一般的な拡張メカニズムを説明しています。第3節では、TLSに固有の拡張機能について説明します。第4節では、で使用するための新しいエラー警告を記述する"
    },
    {
      "indent": 3,
      "text": "the TLS extensions. The final sections of the document address IPR, security considerations, registration of the application/pkix-pkipath MIME type, acknowledgements, and references.",
      "ja": "TLS拡張。アプリケーション/ PKIX-pkipathのMIMEタイプ、謝辞、および参照の文書アドレスIPR、セキュリティ上の考慮事項、登録の最終節。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1。このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, RFC 2119 [KEYWORDS].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますBCP 14、RFC 2119 [KEYWORDS]で説明されるように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. General Extension Mechanisms",
      "section_title": true,
      "ja": "2.一般的な拡張メカニズム"
    },
    {
      "indent": 3,
      "text": "This section presents general extension mechanisms for the TLS handshake client hello and server hello messages.",
      "ja": "このセクションでは、TLSハンドシェイククライアントハローとサーバhelloメッセージのための一般的な拡張メカニズムを提示します。"
    },
    {
      "indent": 3,
      "text": "These general extension mechanisms are necessary in order to enable clients and servers to negotiate whether to use specific extensions, and how to use specific extensions. The extension formats described are based on [MAILINGLIST].",
      "ja": "これらの一般的な拡張メカニズムは、特定の拡張子を使用するかどうかを交渉するためにクライアントとサーバーを有効にすると、特定の拡張子を使用する方法ために必要です。説明拡張フォーマットは、[メーリングリスト]に基づいています。"
    },
    {
      "indent": 3,
      "text": "Section 2.1 specifies the extended client hello message format, Section 2.2 specifies the extended server hello message format, and Section 2.3 describes the actual extension format used with the extended client and server hellos.",
      "ja": "セクション2.1は、セクション2.2、拡張サーバハローメッセージのフォーマットを指定し、セクション2.3は、拡張クライアントとサーバのhelloで使用される実際の拡張フォーマットを説明し、拡張されたクライアントハローメッセージのフォーマットを指定します。"
    },
    {
      "indent": 0,
      "text": "2.1. Extended Client Hello",
      "section_title": true,
      "ja": "2.1。拡張クライアントこんにちは"
    },
    {
      "indent": 3,
      "text": "Clients MAY request extended functionality from servers by sending the extended client hello message format in place of the client hello message format. The extended client hello message format is:",
      "ja": "クライアントは、クライアントハローメッセージ形式の代わりに、拡張されたクライアントハローメッセージのフォーマットを送信することで、サーバからの拡張機能を要求することができます。拡張クライアントhelloメッセージの形式は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "struct {\n    ProtocolVersion client_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suites<2..2^16-1>;\n    CompressionMethod compression_methods<1..2^8-1>;\n    Extension client_hello_extension_list<0..2^16-1>;\n} ClientHello;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here the new \"client_hello_extension_list\" field contains a list of extensions. The actual \"Extension\" format is defined in Section 2.3.",
      "ja": "ここでは、新たな「client_hello_extension_list」フィールドには、拡張子のリストが含まれています。実際の「拡張」フォーマットは2.3節で定義されています。"
    },
    {
      "indent": 3,
      "text": "In the event that a client requests additional functionality using the extended client hello, and this functionality is not supplied by the server, the client MAY abort the handshake.",
      "ja": "クライアントはこんにちは、拡張クライアントを使用して追加機能を要求し、この機能がサーバによって供給されていない場合には、クライアントは握手を中止することができます。"
    },
    {
      "indent": 3,
      "text": "Note that [TLS], Section 7.4.1.2, allows additional information to be added to the client hello message. Thus, the use of the extended client hello defined above should not \"break\" existing TLS servers.",
      "ja": "[TLS]、セクション7.4.1.2は、追加情報は、クライアントハローメッセージに追加されることを可能にすることに留意されたいです。したがって、上記で定義された拡張されたクライアントの使用こんにちは、既存のTLSサーバを「壊す」べきではありません。"
    },
    {
      "indent": 3,
      "text": "A server that supports the extensions mechanism MUST accept only client hello messages in either the original or extended ClientHello format and (as for all other messages) MUST check that the amount of data in the message precisely matches one of these formats. If it does not, then it MUST send a fatal \"decode_error\" alert. This overrides the \"Forward compatibility note\" in [TLS].",
      "ja": "（他のすべてのメッセージのためのような）元または拡張のClientHello形式のいずれかでのみ、クライアントhelloメッセージを受け入れなければならない拡張メカニズムをサポートするサーバーは、メッセージ内のデータの量を正確にこれらのフォーマットの1つと一致していることをチェックしなければなりません。そうでないなら、それは致命的な「decode_error」アラートを送らなければなりません。これは、[TLS]で「上位互換性ノート」を上書きします。"
    },
    {
      "indent": 0,
      "text": "2.2. Extended Server Hello",
      "section_title": true,
      "ja": "2.2。拡張サーバーこんにちは"
    },
    {
      "indent": 3,
      "text": "The extended server hello message format MAY be sent in place of the server hello message when the client has requested extended functionality via the extended client hello message specified in Section 2.1. The extended server hello message format is:",
      "ja": "クライアントは、セクション2.1で指定された拡張クライアントのhelloメッセージを介して拡張機能を要求したとき、拡張サーバーハローメッセージのフォーマットは、サーバハローメッセージの代わりに送信されるかもしれません。拡張されたサーバーハローメッセージのフォーマットは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "struct {\n    ProtocolVersion server_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suite;\n    CompressionMethod compression_method;\n    Extension server_hello_extension_list<0..2^16-1>;\n} ServerHello;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here the new \"server_hello_extension_list\" field contains a list of extensions. The actual \"Extension\" format is defined in Section 2.3.",
      "ja": "ここでは、新たな「server_hello_extension_list」フィールドには、拡張子のリストが含まれています。実際の「拡張」フォーマットは2.3節で定義されています。"
    },
    {
      "indent": 3,
      "text": "Note that the extended server hello message is only sent in response to an extended client hello message. This prevents the possibility that the extended server hello message could \"break\" existing TLS clients.",
      "ja": "拡張されたサーバーのhelloメッセージのみ、拡張クライアントのhelloメッセージに応答して送信されることに注意してください。これは、拡張されたサーバーのhelloメッセージは、既存のTLSクライアントを「壊す」ことができる可能性を防ぐことができます。"
    },
    {
      "indent": 0,
      "text": "2.3. Hello Extensions",
      "section_title": true,
      "ja": "2.3。こんにちは拡張機能"
    },
    {
      "indent": 3,
      "text": "The extension format for extended client hellos and extended server hellos is:",
      "ja": "拡張クライアントのhelloと拡張サーバーのhello用の拡張形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "struct {\n    ExtensionType extension_type;\n    opaque extension_data<0..2^16-1>;\n} Extension;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here:",
      "ja": "ここに："
    },
    {
      "indent": 3,
      "text": "- \"extension_type\" identifies the particular extension type.",
      "ja": " - 「EXTENSION_TYPE」は、特定の拡張子の型を識別する。"
    },
    {
      "indent": 3,
      "text": "- \"extension_data\" contains information specific to the particular extension type.",
      "ja": " - 「拡大」は、特定の拡張子の種類に固有の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The extension types defined in this document are:",
      "ja": "この文書で定義された拡張タイプは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "enum {\n    server_name(0), max_fragment_length(1),\n    client_certificate_url(2), trusted_ca_keys(3),\n    truncated_hmac(4), status_request(5), (65535)\n} ExtensionType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The list of defined extension types is maintained by the IANA. The current list can be found at: http://www.iana.org/assignments/tls-extensiontype-values. See Sections 5 and 8 for more information on how new values are added.",
      "ja": "定義された拡張タイプのリストがIANAによって維持されています。 http://www.iana.org/assignments/tls-extensiontype-values：現在のリストはで見つけることができます。新しい値を追加する方法の詳細については、セクション5と8を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that for all extension types (including those defined in the future), the extension type MUST NOT appear in the extended server hello unless the same extension type appeared in the corresponding client hello. Thus clients MUST abort the handshake if they receive an extension type in the extended server hello that they did not request in the associated (extended) client hello.",
      "ja": "同じ拡張型はハロー対応するクライアントに登場しない限り、（将来的に定義されたものを含む）すべての拡張タイプに対してなお、拡張タイプは、ハロー拡張サーバーに現れてはいけません。彼らは、拡張サーバハローに拡張タイプを受信した場合このように、クライアントは、彼らがハロー関連する（拡張）クライアントに要求しなかったことを握手を中止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Nonetheless, \"server-oriented\" extensions may be provided in the future within this framework. Such an extension (say, of type x) would require the client to first send an extension of type x in the (extended) client hello with empty extension_data to indicate that it supports the extension type. In this case, the client is offering the capability to understand the extension type, and the server is taking the client up on its offer.",
      "ja": "それにもかかわらず、「サーバー志向」の拡張機能は、この枠組みの中で、将来的に提供することができます。 （タイプxの言う、）このような拡張は最初、それは拡張タイプをサポートすることを示すために、空の拡大を（拡張）クライアントハロータイプxの延長を送信するためにクライアントが必要となります。この場合、クライアントは、拡張タイプを理解するための機能を提供して、サーバはその申し出にクライアントを取っています。"
    },
    {
      "indent": 3,
      "text": "Also note that when multiple extensions of different types are present in the extended client hello or the extended server hello, the extensions may appear in any order. There MUST NOT be more than one extension of the same type.",
      "ja": "また、異なるタイプの複数の拡張機能が拡張されたクライアントハローまたは拡張サーバーに存在する場合こんにちは、拡張子は任意の順序で表示される可能性があることに注意。同じタイプの複数の拡張機能があってはなりません。"
    },
    {
      "indent": 3,
      "text": "Finally, note that an extended client hello may be sent both when starting a new session and when requesting session resumption. Indeed, a client that requests resumption of a session does not in general know whether the server will accept this request, and therefore it SHOULD send an extended client hello if it would normally do so for a new session. In general the specification of each extension type must include a discussion of the effect of the extension both during new sessions and during resumed sessions.",
      "ja": "最後に、新しいセッションを開始するときに、セッション再開を要求するときに、拡張クライアントのhelloを両方送ることができることに注意してください。実際、セッションの再開を要求するクライアントは、一般的には、サーバがこの要求を受け入れます、そしてそれは通常、新しいセッションのためにそうならば、したがって、それはハロー拡張クライアントを送信するかどうか分かりません。一般に、各拡張型の仕様は、新しいセッションの間及び再開セッション中の両方拡張の効果の議論を含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.4. Extensions to the Handshake Protocol",
      "section_title": true,
      "ja": "2.4。ハンドシェイクプロトコルの拡張"
    },
    {
      "indent": 3,
      "text": "This document suggests the use of two new handshake messages, \"CertificateURL\" and \"CertificateStatus\". These messages are described in Section 3.3 and Section 3.6, respectively. The new handshake message structure therefore becomes:",
      "ja": "この文書では、2つの新しいハンドシェイクメッセージ、「CertificateURL」と「CertificateStatus」の使用を示唆しています。これらのメッセージは、それぞれ、3.3節及び3.6節に記載されています。新しいハンドシェイクメッセージの構造は、したがって、次のようになります。"
    },
    {
      "indent": 6,
      "text": "enum {\n    hello_request(0), client_hello(1), server_hello(2),\n    certificate(11), server_key_exchange (12),\n    certificate_request(13), server_hello_done(14),\n    certificate_verify(15), client_key_exchange(16),\n    finished(20), certificate_url(21), certificate_status(22),\n    (255)\n} HandshakeType;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n    HandshakeType msg_type;    /* handshake type */\n    uint24 length;             /* bytes in message */\n    select (HandshakeType) {\n        case hello_request:       HelloRequest;\n        case client_hello:        ClientHello;\n        case server_hello:        ServerHello;\n        case certificate:         Certificate;\n        case server_key_exchange: ServerKeyExchange;\n        case certificate_request: CertificateRequest;\n        case server_hello_done:   ServerHelloDone;\n        case certificate_verify:  CertificateVerify;\n        case client_key_exchange: ClientKeyExchange;\n        case finished:            Finished;\n        case certificate_url:     CertificateURL;\n        case certificate_status:  CertificateStatus;\n    } body;\n} Handshake;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3. Specific Extensions",
      "section_title": true,
      "ja": "3.特定の拡張機能"
    },
    {
      "indent": 3,
      "text": "This section describes the specific TLS extensions specified in this document.",
      "ja": "このセクションでは、この文書で指定された特定のTLS拡張を説明しています。"
    },
    {
      "indent": 3,
      "text": "Note that any messages associated with these extensions that are sent during the TLS handshake MUST be included in the hash calculations involved in \"Finished\" messages.",
      "ja": "TLSハンドシェイク中に送信されたこれらの拡張子に関連付けられたすべてのメッセージは、「完了」のメッセージに関与ハッシュ計算に含めなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note also that all the extensions defined in this section are relevant only when a session is initiated. When a client includes one or more of the defined extension types in an extended client hello while requesting session resumption:",
      "ja": "セッションが開始された場合にのみ、このセクションで定義されたすべての拡張機能が関連していることにも注意してください。セッションの再開を要求しながら、クライアントが拡張されたクライアントハローで定義された拡張タイプの一つ以上を含む場合。"
    },
    {
      "indent": 3,
      "text": "- If the resumption request is denied, the use of the extensions is negotiated as normal.",
      "ja": " - 再開要求が拒否された場合、拡張の使用は、通常のように交渉されます。"
    },
    {
      "indent": 3,
      "text": "- If, on the other hand, the older session is resumed, then the server MUST ignore the extensions and send a server hello containing none of the extension types. In this case, the functionality of these extensions negotiated during the original session initiation is applied to the resumed session.",
      "ja": " - 一方で、古いセッションが再開されている場合は、サーバー拡張機能を無視して、拡張型のいずれも含有しない、サーバーハローを送らなければなりません。この場合、元のセッション開始時にネゴシエートされたこれらの拡張機能は、再開セッションに適用されます。"
    },
    {
      "indent": 3,
      "text": "Section 3.1 describes the extension of TLS to allow a client to indicate which server it is contacting. Section 3.2 describes the extension that provides maximum fragment length negotiation. Section 3.3 describes the extension that allows client certificate URLs. Section 3.4 describes the extension that allows a client to indicate which CA root keys it possesses. Section 3.5 describes the extension that allows the use of truncated HMAC. Section 3.6 describes the extension that supports integration of certificate status information messages into TLS handshakes.",
      "ja": "3.1節では、クライアントは、それが接触しているどのサーバを示すことができるようにTLSの拡張機能について説明します。セクション3.2は、最大フラグメント長交渉を提供する拡張を記述する。 3.3節では、クライアント証明書のURLを可能にする拡張機能について説明します。 3.4節では、クライアントは、それが持っているどのCAルート鍵を示すことを可能にする拡張機能について説明します。 3.5節は切り捨てHMACの使用を可能にする拡張機能について説明します。セクション3.6は、TLSハンドシェイクに証明書のステータス情報メッセージの統合をサポートしている拡張機能について説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Server Name Indication",
      "section_title": true,
      "ja": "3.1。サーバ名の表示"
    },
    {
      "indent": 3,
      "text": "TLS does not provide a mechanism for a client to tell a server the name of the server it is contacting. It may be desirable for clients to provide this information to facilitate secure connections to servers that host multiple 'virtual' servers at a single underlying network address.",
      "ja": "TLSは、サーバーにそれが接触しているサーバーの名前を伝えるために、クライアントのためのメカニズムを提供しません。クライアントは、単一の基盤となるネットワークアドレスに複数の「仮想」サーバをホストするサーバーへのセキュアな接続を容易にするために、この情報を提供することが望ましい場合があります。"
    },
    {
      "indent": 3,
      "text": "In order to provide the server name, clients MAY include an extension of type \"server_name\" in the (extended) client hello. The \"extension_data\" field of this extension SHALL contain \"ServerNameList\" where:",
      "ja": "サーバー名を提供するために、クライアントは（拡張）クライアントのhelloを入力し、「サーバー名」の拡張子を含むかもしれません。この拡張機能の「拡大」フィールドが「ServerNameList」を含まなければなりません："
    },
    {
      "indent": 6,
      "text": "struct {\n    NameType name_type;\n    select (name_type) {\n        case host_name: HostName;\n    } name;\n} ServerName;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "enum {\n    host_name(0), (255)\n} NameType;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "opaque HostName<1..2^16-1>;",
      "ja": "不透明なホスト名<1..2 ^ 16-1>;"
    },
    {
      "indent": 6,
      "text": "struct {\n    ServerName server_name_list<1..2^16-1>\n} ServerNameList;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Currently, the only server names supported are DNS hostnames; however, this does not imply any dependency of TLS on DNS, and other name types may be added in the future (by an RFC that updates this document). TLS MAY treat provided server names as opaque data and pass the names and types to the application.",
      "ja": "現在、サポートされている唯一のサーバー名がDNSホスト名です。しかしながら、これは、DNS上のTLSの任意の依存性を意味するものではない、と他の名前の種類（この文書を更新するRFCにより）将来的に添加してもよいです。 TLSは、不透明なデータとして提供するサーバー名を扱い、アプリケーションに名前と型を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "\"HostName\" contains the fully qualified DNS hostname of the server, as understood by the client. The hostname is represented as a byte string using UTF-8 encoding [UTF8], without a trailing dot.",
      "ja": "「ホスト名は」クライアントによって理解されるよう、サーバーの完全修飾DNSホスト名が含まれています。ホスト名は末尾のドットなしで、UTF8エンコーディング[UTF8]を使用して、バイト列として表現されます。"
    },
    {
      "indent": 3,
      "text": "If the hostname labels contain only US-ASCII characters, then the client MUST ensure that labels are separated only by the byte 0x2E, representing the dot character U+002E (requirement 1 in Section 3.1 of [IDNA] notwithstanding). If the server needs to match the HostName against names that contain non-US-ASCII characters, it MUST perform the conversion operation described in Section 4 of [IDNA], treating the HostName as a \"query string\" (i.e., the AllowUnassigned flag MUST be set). Note that IDNA allows labels to be separated by any of the Unicode characters U+002E, U+3002, U+FF0E, and U+FF61; therefore, servers MUST accept any of these characters as a label separator. If the server only needs to match the HostName against names containing exclusively ASCII characters, it MUST compare ASCII names case-insensitively.",
      "ja": "ホスト名のラベルはUS-ASCII文字のみが含まれている場合、クライアントは、ラベルが唯一のドット文字U + 002E（[IDNA]にもかかわらずの3.1節で要件1）を表すバイト0x2E、によって分離されていることを保証しなければなりません。サーバーが非US-ASCII文字を含む名前に対するホスト名と一致する必要がある場合は、[IDNA]のセクション4で説明した変換操作を実行しなければなりません、「クエリ文字列」としてホスト名を処理する（すなわち、AllowUnassignedフラグMUST ）を設定します。 IDNAラベルがユニコード文字U + 002E、U + 3002、U + FF0E、およびU + FF61のいずれかによって分離されることを可能にすることに留意されたいです。そのため、サーバーは、ラベルの区切り文字としてこれらの文字を受け入れなければなりません。サーバが唯一の排他的にASCII文字を含む名前に対するホスト名と一致する必要がある場合、それは大文字と小文字を区別せずにASCII名を比較しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Literal IPv4 and IPv6 addresses are not permitted in \"HostName\".",
      "ja": "リテラルIPv4アドレスとIPv6アドレスは、「ホスト名」には許可されていません。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that clients include an extension of type \"server_name\" in the client hello whenever they locate a server by a supported name type.",
      "ja": "彼らがサポート名前の種類によってサーバーを見つけるたび、クライアントがクライアントのhelloを入力し、「サーバー名」の拡張子を含めることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "A server that receives a client hello containing the \"server_name\" extension MAY use the information contained in the extension to guide its selection of an appropriate certificate to return to the client, and/or other aspects of security policy. In this event, the server SHALL include an extension of type \"server_name\" in the (extended) server hello. The \"extension_data\" field of this extension SHALL be empty.",
      "ja": "セキュリティポリシーのおよび/または他の側面、クライアントに返すために適切な証明書のその選択をガイドするための拡張に含まれている情報を使用するかもしれ「サーバー名」の拡張子を含むクライアントのhelloを受信するサーバー。この場合、サーバは、（拡張）サーバハロータイプの拡張子「サーバ名」を含むものとします。この拡張機能の「拡大」フィールドが空にされなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the server understood the client hello extension but does not recognize the server name, it SHOULD send an \"unrecognized_name\" alert (which MAY be fatal).",
      "ja": "サーバーは、クライアントハロー拡張子を理解している場合が、サーバー名を認識しない、それが（致命的かもしれない）「unrecognized_name」アラートを送信すべきです。"
    },
    {
      "indent": 3,
      "text": "If an application negotiates a server name using an application protocol and then upgrades to TLS, and if a server_name extension is sent, then the extension SHOULD contain the same name that was negotiated in the application protocol. If the server_name is established in the TLS session handshake, the client SHOULD NOT attempt to request a different server name at the application layer.",
      "ja": "アプリケーションは、アプリケーションプロトコルを使用してサーバー名を交渉した場合はTLSへのアップグレード、およびサーバー名の拡張子が送信された場合、その後の拡張は、アプリケーションプロトコルで交渉されたのと同じ名前を含むべきです。 SERVER_NAMEはTLSセッションハンドシェイクで確立された場合、クライアントは、アプリケーション層で別のサーバー名を要求するように試みるべきではありません。"
    },
    {
      "indent": 0,
      "text": "3.2. Maximum Fragment Length Negotiation",
      "section_title": true,
      "ja": "3.2。最大フラグメント長交渉"
    },
    {
      "indent": 3,
      "text": "Without this extension, TLS specifies a fixed maximum plaintext fragment length of 2^14 bytes. It may be desirable for constrained clients to negotiate a smaller maximum fragment length due to memory limitations or bandwidth limitations.",
      "ja": "この拡張せず、TLSは、2 ^ 14バイトの固定最大平文断片の長さを指定します。制約クライアントがメモリ制限または帯域幅制限による小さい最大フラグメント長を交渉することが望ましいかもしれません。"
    },
    {
      "indent": 3,
      "text": "In order to negotiate smaller maximum fragment lengths, clients MAY include an extension of type \"max_fragment_length\" in the (extended) client hello. The \"extension_data\" field of this extension SHALL contain:",
      "ja": "より小さい最大フラグメント長を交渉するために、クライアントは、（拡張）クライアントハロータイプの拡張子「max_fragment_lengthを」を含むことができます。この拡張機能の「拡大」フィールドが含まれていなければなりません。"
    },
    {
      "indent": 3,
      "text": "enum{ 2^9(1), 2^10(2), 2^11(3), 2^12(4), (255) } MaxFragmentLength;",
      "ja": "列挙{2 ^ 9（1）、2 ^ 10（2）、2 ^ 11（3）、2 ^ 12（4）、（255）} MaxFragmentLength。"
    },
    {
      "indent": 3,
      "text": "whose value is the desired maximum fragment length. The allowed values for this field are: 2^9, 2^10, 2^11, and 2^12.",
      "ja": "その値は所望の最大フラグメント長です。このフィールドの許容値は：^ 9 2、^ 10 2、^ 11 2、および2 ^ 12。"
    },
    {
      "indent": 3,
      "text": "Servers that receive an extended client hello containing a \"max_fragment_length\" extension MAY accept the requested maximum fragment length by including an extension of type \"max_fragment_length\" in the (extended) server hello. The \"extension_data\" field of this extension SHALL contain a \"MaxFragmentLength\" whose value is the same as the requested maximum fragment length.",
      "ja": "「max_fragment_length」拡張を含む拡張されたクライアントハローを受信サーバー（拡張）サーバタイプの拡張子を含むことにより、要求された最大の断片長を受け付けるようにしてもよい「max_fragment_length」こんにちは。この拡張の「拡大」フィールドは、値が要求された最大フラグメント長さと同じである「MaxFragmentLength」を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a server receives a maximum fragment length negotiation request for a value other than the allowed values, it MUST abort the handshake with an \"illegal_parameter\" alert. Similarly, if a client receives a maximum fragment length negotiation response that differs from the length it requested, it MUST also abort the handshake with an \"illegal_parameter\" alert.",
      "ja": "サーバーが許可された値以外の値の最大フラグメント長交渉要求を受信した場合、それは「illegal_parameter」アラートに握手を中止しなければなりません。クライアントが要求された長さとは異なり、最大フラグメント長交渉応答を受信した場合同様に、それはまた、「illegal_parameter」アラートに握手を中止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once a maximum fragment length other than 2^14 has been successfully negotiated, the client and server MUST immediately begin fragmenting messages (including handshake messages), to ensure that no fragment larger than the negotiated length is sent. Note that TLS already requires clients and servers to support fragmentation of handshake messages.",
      "ja": "2 ^ 14以外の最大フラグメント長さが正常にネゴシエートされた後、クライアントとサーバーは直ちにネゴシエート長さよりも大きくないフラグメントが送信されないことを保証するために、（ハンドシェイク・メッセージを含む）メッセージを断片化開始しなければなりません。 TLSは、すでにハンドシェイクメッセージの断片化をサポートするために、クライアントとサーバが必要であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The negotiated length applies for the duration of the session including session resumptions.",
      "ja": "交渉さ長さは、セッションコンテニューを含むセッションの間に適用されます。"
    },
    {
      "indent": 3,
      "text": "The negotiated length limits the input that the record layer may process without fragmentation (that is, the maximum value of TLSPlaintext.length; see [TLS], Section 6.2.1). Note that the output of the record layer may be larger. For example, if the negotiated length is 2^9=512, then for currently defined cipher suites (those defined in [TLS], [KERB], and [AESSUITES]), and when null compression is used, the record layer output can be at most 793 bytes: 5 bytes of headers, 512 bytes of application data, 256 bytes of padding, and 20 bytes of MAC. This means that in this event a TLS record layer peer receiving a TLS record layer message larger than 793 bytes may discard the message and send a \"record_overflow\" alert, without decrypting the message.",
      "ja": "ネゴシエートされた長さは、記録層が断片化することなく処理することができる入力を制限する（すなわち、TLSPlaintext.lengthの最大値であり、[TLS]、セクション6.2.1を参照します）。記録層の出力が大きくてもよいことに留意されたいです。例えば、ネゴシエート長さは、現在定義されている暗号スイート（[TLS]で定義されたもの、[CURB]、および[AESSUITES]）、およびヌル圧縮が使用される場合、記録層の出力ができ、次いで、2 ^ 9 = 512である場合ヘッダの5バイト、アプリケーションデータの512バイト、パディングの256バイト、およびMACの20バイト：最大で793バイトです。これは、より大きい793のバイトはメッセージを破棄してメッセージを復号化することなく、「record_overflow」警告を送信することができるTLSレコード層メッセージを受信し、このイベントにTLSレコード層ピアことを意味します。"
    },
    {
      "indent": 0,
      "text": "3.3. Client Certificate URLs",
      "section_title": true,
      "ja": "3.3。クライアント証明書のURL"
    },
    {
      "indent": 3,
      "text": "Without this extension, TLS specifies that when client authentication is performed, client certificates are sent by clients to servers during the TLS handshake. It may be desirable for constrained clients to send certificate URLs in place of certificates, so that they do not need to store their certificates and can therefore save memory.",
      "ja": "この拡張機能がないと、TLSは、クライアント認証が行われた場合、クライアント証明書は、TLSハンドシェイク中にサーバにクライアントから送信されることを指定します。彼らは自分の証明書を格納する必要がないため、メモリを節約することができるように拘束されたクライアントは、証明書の代わりに証明書のURLを送信することが望ましい場合があります。"
    },
    {
      "indent": 3,
      "text": "In order to negotiate sending certificate URLs to a server, clients MAY include an extension of type \"client_certificate_url\" in the (extended) client hello. The \"extension_data\" field of this extension SHALL be empty.",
      "ja": "サーバーに証明書のURLを送る交渉するためには、クライアントは（拡張）クライアントのhelloを入力し、「client_certificate_url」の拡張子を含むかもしれません。この拡張機能の「拡大」フィールドが空にされなければなりません。"
    },
    {
      "indent": 3,
      "text": "(Note that it is necessary to negotiate use of client certificate URLs in order to avoid \"breaking\" existing TLS servers.)",
      "ja": "（既存のTLSサーバを「破壊」を避けるために、クライアント証明書のURLの使用を交渉する必要があることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Servers that receive an extended client hello containing a \"client_certificate_url\" extension MAY indicate that they are willing to accept certificate URLs by including an extension of type \"client_certificate_url\" in the (extended) server hello. The \"extension_data\" field of this extension SHALL be empty.",
      "ja": "「client_certificate_url」拡張を含む拡張クライアントのhelloを受け取るサーバは、彼らが（拡張）サーバーこんにちはにおけるタイプ「client_certificate_url」の拡張子を含めることにより、証明書のURLを受け入れて喜んでであることを示してもよいです。この拡張機能の「拡大」フィールドが空にされなければなりません。"
    },
    {
      "indent": 3,
      "text": "After negotiation of the use of client certificate URLs has been successfully completed (by exchanging hellos including \"client_certificate_url\" extensions), clients MAY send a \"CertificateURL\" message in place of a \"Certificate\" message:",
      "ja": "クライアント証明書URLの使用のネゴシエーションが成功した（「client_certificate_url」拡張を含むhelloを交換することで）完了した後に、クライアントが「証明書」のメッセージの代わりに「CertificateURL」メッセージを送信することができます。"
    },
    {
      "indent": 6,
      "text": "enum {\n    individual_certs(0), pkipath(1), (255)\n} CertChainType;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "enum {\n    false(0), true(1)\n} Boolean;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n    CertChainType type;\n    URLAndOptionalHash url_and_hash_list<1..2^16-1>;\n} CertificateURL;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n    opaque url<1..2^16-1>;\n    Boolean hash_present;\n    select (hash_present) {\n        case false: struct {};\n        case true: SHA1Hash;\n    } hash;\n} URLAndOptionalHash;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "opaque SHA1Hash[20];",
      "ja": "不透明SHA1Hash [20]。"
    },
    {
      "indent": 3,
      "text": "Here \"url_and_hash_list\" contains a sequence of URLs and optional hashes.",
      "ja": "ここで「url_and_hash_listは」のURLとオプションのハッシュの配列を含みます。"
    },
    {
      "indent": 3,
      "text": "When X.509 certificates are used, there are two possibilities:",
      "ja": "X.509証明書を使用する場合には、2つの可能性があります。"
    },
    {
      "indent": 3,
      "text": "- If CertificateURL.type is \"individual_certs\", each URL refers to a single DER-encoded X.509v3 certificate, with the URL for the client's certificate first.",
      "ja": " -  CertificateURL.typeは「individual_certs」である場合は、各URLは、最初にクライアントの証明書のためのURLと、シングルDERで符号化されたX.509v3証明書を指します。"
    },
    {
      "indent": 3,
      "text": "- If CertificateURL.type is \"pkipath\", the list contains a single URL referring to a DER-encoded certificate chain, using the type PkiPath described in Section 8.",
      "ja": " -  CertificateURL.typeが「pkipath」である場合、リストは、セクション8に記載されているタイプのPkiPathを使用して、DER符号化された証明書チェーンを参照すると、単一のURLが含まれています。"
    },
    {
      "indent": 3,
      "text": "When any other certificate format is used, the specification that describes use of that format in TLS should define the encoding format of certificates or certificate chains, and any constraint on their ordering.",
      "ja": "他の証明書のフォーマットを使用する場合は、TLSでその形式の使用が記載されている仕様は、証明書または証明書チェーンのエンコード形式、およびその順序上の任意の制約を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "The hash corresponding to each URL at the client's discretion either is not present or is the SHA-1 hash of the certificate or certificate chain (in the case of X.509 certificates, the DER-encoded certificate or the DER-encoded PkiPath).",
      "ja": "クライアントの裁量で各URLに対応するハッシュが存在しないか、または（X.509証明書の場合には、DER符号化された証明書またはDERエンコードPkiPath）証明書または証明書チェーンのSHA-1ハッシュのいずれか。"
    },
    {
      "indent": 3,
      "text": "Note that when a list of URLs for X.509 certificates is used, the ordering of URLs is the same as that used in the TLS Certificate message (see [TLS], Section 7.4.2), but opposite to the order in which certificates are encoded in PkiPath. In either case, the self-signed root certificate MAY be omitted from the chain, under the assumption that the server must already possess it in order to validate it.",
      "ja": "X.509証明書のURLのリストを使用する場合、URLの順序は、TLS証明書メッセージに使用されるものと同じであることに留意されたいために、しかし反対に、証明書（[TLS]、セクション7.4.2を参照のこと） PkiPathでエンコードされています。いずれの場合も、自己署名ルート証明書は、サーバーがそれを検証するために、それをすでに所有していなければならないという仮定の下で、チェーンから省略されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Servers receiving \"CertificateURL\" SHALL attempt to retrieve the client's certificate chain from the URLs and then process the certificate chain as usual. A cached copy of the content of any URL in the chain MAY be used, provided that a SHA-1 hash is present for that URL and it matches the hash of the cached copy.",
      "ja": "「CertificateURL」を受信サーバーは、URLからクライアントの証明書チェーンを取得し、いつものように証明書チェーンを処理しようとしないものとします。チェーン内の任意のURLのコンテンツのキャッシュされたコピーは、SHA-1ハッシュは、そのURLのために存在し、それがキャッシュされたコピーのハッシュと一致するという条件で、使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Servers that support this extension MUST support the http: URL scheme for certificate URLs, and MAY support other schemes. Use of other schemes than \"http\", \"https\", or \"ftp\" may create unexpected problems.",
      "ja": "証明書のURLのURLスキームを、および他のスキームをサポートする可能性があります。この拡張機能をサポートするサーバーは、HTTPをサポートしなければなりません。 「HTTP」、「HTTPS」、または「FTP」以外のスキームを使用すると、予期しない問題を作成することがあります。"
    },
    {
      "indent": 3,
      "text": "If the protocol used is HTTP, then the HTTP server can be configured to use the Cache-Control and Expires directives described in [HTTP] to specify whether and for how long certificates or certificate chains should be cached.",
      "ja": "使用されるプロトコルがHTTPの場合、HTTPサーバは、キャッシュ・コントロールを使用するように設定しているかどうかと、キャッシュする必要があるどのくらいの証明書または証明書チェーンに指定し、[HTTP]で説明ディレクティブを期限切れにすることができます。"
    },
    {
      "indent": 3,
      "text": "The TLS server is not required to follow HTTP redirects when retrieving the certificates or certificate chain. The URLs used in this extension SHOULD therefore be chosen not to depend on such redirects.",
      "ja": "TLSサーバは、証明書または証明書チェーンを取得する際にHTTPリダイレクトを追跡するために必要とされていません。この拡張に使用されるURLは、したがって、そのようなリダイレクトに依存しないように選択すべきです。"
    },
    {
      "indent": 3,
      "text": "If the protocol used to retrieve certificates or certificate chains returns a MIME-formatted response (as HTTP does), then the following MIME Content-Types SHALL be used: when a single X.509v3 certificate is returned, the Content-Type is \"application/pkix-cert\" [PKIOP], and when a chain of X.509v3 certificates is returned, the Content-Type is \"application/pkix-pkipath\" (see Section 8).",
      "ja": "証明書または証明書チェーンを取得するために使用されるプロトコルは、（HTTPがするように）MIME形式の応答を返した場合は、次のMIMEコンテンツタイプを使用しなければならない：単一X.509v3証明書が返されたときに、Content-Typeのは、「アプリケーションです/ PKIX-CERT」[PKIOP]とのX.509v3証明書のチェーンが返された場合、コンテンツタイプが \"アプリケーション/ PKIX-pkipath\"（セクション8を参照）。"
    },
    {
      "indent": 3,
      "text": "If a SHA-1 hash is present for an URL, then the server MUST check that the SHA-1 hash of the contents of the object retrieved from that URL (after decoding any MIME Content-Transfer-Encoding) matches the given hash. If any retrieved object does not have the correct SHA-1 hash, the server MUST abort the handshake with a \"bad_certificate_hash_value\" alert.",
      "ja": "SHA-1ハッシュがURLのために存在している場合、サーバはそのURLから取得対象のコンテンツのSHA-1ハッシュ（任意のMIMEコンテンツ転送エンコードをデコードした後に）指定されたハッシュと一致することをチェックしなければなりません。任意の取得したオブジェクトが正しいSHA-1ハッシュを持っていない場合、サーバは「bad_certificate_hash_value」アラートに握手を中止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that clients may choose to send either \"Certificate\" or \"CertificateURL\" after successfully negotiating the option to send certificate URLs. The option to send a certificate is included to provide flexibility to clients possessing multiple certificates.",
      "ja": "クライアント証明書が正常にURLを送信するオプションを交渉した後、「証明書」または「CertificateURL」のいずれかを送信することを選択することがあります。証明書を送信するためのオプションは、複数の証明書を持つクライアントに柔軟性を提供するために含まれています。"
    },
    {
      "indent": 3,
      "text": "If a server encounters an unreasonable delay in obtaining certificates in a given CertificateURL, it SHOULD time out and signal a \"certificate_unobtainable\" error alert.",
      "ja": "サーバは与えられたCertificateURL内の証明書を得るための不当な遅延が発生した場合、それはタイムアウトして「certificate_unobtainable」エラー警告を通知すべきです。"
    },
    {
      "indent": 0,
      "text": "3.4. Trusted CA Indication",
      "section_title": true,
      "ja": "3.4。信頼できるCAの表示"
    },
    {
      "indent": 3,
      "text": "Constrained clients that, due to memory limitations, possess only a small number of CA root keys may wish to indicate to servers which root keys they possess, in order to avoid repeated handshake failures.",
      "ja": "メモリの制限のために、CAルート鍵のほんの数を所有し、制約付きのクライアントが繰り返さハンドシェイクの失敗を避けるために、彼らが持っているルートキーサーバに指示することを望むかもしれません。"
    },
    {
      "indent": 3,
      "text": "In order to indicate which CA root keys they possess, clients MAY include an extension of type \"trusted_ca_keys\" in the (extended) client hello. The \"extension_data\" field of this extension SHALL contain \"TrustedAuthorities\" where:",
      "ja": "彼らが持っているCAルート鍵を示すために、クライアントは（拡張）クライアントのhelloを入力し、「trusted_ca_keys」の拡張子を含むかもしれません。この拡張機能の「拡大」フィールドが「TrustedAuthorities」を含まなければなりません："
    },
    {
      "indent": 6,
      "text": "struct {\n    TrustedAuthority trusted_authorities_list<0..2^16-1>;\n} TrustedAuthorities;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n    IdentifierType identifier_type;\n    select (identifier_type) {\n        case pre_agreed: struct {};\n        case key_sha1_hash: SHA1Hash;\n        case x509_name: DistinguishedName;\n        case cert_sha1_hash: SHA1Hash;\n    } identifier;\n} TrustedAuthority;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "enum {\n    pre_agreed(0), key_sha1_hash(1), x509_name(2),\n    cert_sha1_hash(3), (255)\n} IdentifierType;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "opaque DistinguishedName<1..2^16-1>;",
      "ja": "不透明な識別名<1..2 ^ 16-1>;"
    },
    {
      "indent": 3,
      "text": "Here \"TrustedAuthorities\" provides a list of CA root key identifiers that the client possesses. Each CA root key is identified via either:",
      "ja": "ここで「TrustedAuthoritiesは、」クライアントが保有するCAルート鍵識別子のリストを提供します。各CAのルートキーのいずれかを経由して識別されます。"
    },
    {
      "indent": 3,
      "text": "- \"pre_agreed\": no CA root key identity supplied.",
      "ja": " - 「pre_agreed」：なしCAルートキーIDが供給されていません。"
    },
    {
      "indent": 3,
      "text": "- \"key_sha1_hash\": contains the SHA-1 hash of the CA root key. For Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA) keys, this is the hash of the \"subjectPublicKey\" value. For RSA keys, the hash is of the big-endian byte string representation of the modulus without any initial 0-valued bytes. (This copies the key hash formats deployed in other environments.)",
      "ja": " -  \"key_sha1_hash\"：CAのルート鍵のSHA-1ハッシュが含まれています。デジタル署名アルゴリズム（DSA）と楕円曲線デジタル署名アルゴリズム（ECDSA）キーの場合、これは「のsubjectPublicKey」値のハッシュです。 RSA鍵の場合、ハッシュは、任意の初期値の0バイトなしモジュラスのビッグエンディアンバイトの文字列表現です。 （このコピーキーハッシュ形式は、他の環境で展開します。）"
    },
    {
      "indent": 3,
      "text": "- \"x509_name\": contains the DER-encoded X.509 DistinguishedName of the CA.",
      "ja": " - 「x509_nameは」：CAのDERでエンコードされたX.509識別名が含まれています"
    },
    {
      "indent": 3,
      "text": "- \"cert_sha1_hash\": contains the SHA-1 hash of a DER-encoded Certificate containing the CA root key.",
      "ja": " - 「cert_sha1_hash」：CAのルートキーを含むDERでエンコードされた証明書のSHA-1ハッシュが含まれています。"
    },
    {
      "indent": 3,
      "text": "Note that clients may include none, some, or all of the CA root keys they possess in this extension.",
      "ja": "クライアントはどれも、いくつか、または彼らは、この拡張に持っCAルート鍵の全てを含まなくてもよいことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note also that it is possible that a key hash or a Distinguished Name alone may not uniquely identify a certificate issuer (for example, if a particular CA has multiple key pairs). However, here we assume this is the case following the use of Distinguished Names to identify certificate issuers in TLS.",
      "ja": "（特定のCAが複数の鍵ペアを持っている場合など）単独キーハッシュまたは識別名が一意の証明書発行者を識別しない可能性があることにも留意されたいです。しかし、ここでは、これがTLSでの証明書発行者を識別するための識別名を使用する次のような場合であると仮定します。"
    },
    {
      "indent": 3,
      "text": "The option to include no CA root keys is included to allow the client to indicate possession of some pre-defined set of CA root keys.",
      "ja": "何のCAルート鍵を含まないためのオプションは、クライアントがCAルート鍵のいくつかの事前定義されたセットの所有権を示すことができるように含まれています。"
    },
    {
      "indent": 3,
      "text": "Servers that receive a client hello containing the \"trusted_ca_keys\" extension MAY use the information contained in the extension to guide their selection of an appropriate certificate chain to return to the client. In this event, the server SHALL include an extension of type \"trusted_ca_keys\" in the (extended) server hello. The \"extension_data\" field of this extension SHALL be empty.",
      "ja": "「trusted_ca_keys」拡張子を含むクライアントのhelloを受け取るサーバは、クライアントに返すために、適切な証明書チェーンの彼らの選択を導くために拡張に含まれる情報を使用することができます。この場合、サーバは、（拡張）サーバハローにおけるタイプ「trusted_ca_keys」の拡張子を含まなければなりません。この拡張機能の「拡大」フィールドが空にされなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.5. Truncated HMAC",
      "section_title": true,
      "ja": "3.5。切り捨てられたHMAC"
    },
    {
      "indent": 3,
      "text": "Currently defined TLS cipher suites use the MAC construction HMAC with either MD5 or SHA-1 [HMAC] to authenticate record layer communications. In TLS, the entire output of the hash function is used as the MAC tag. However, it may be desirable in constrained environments to save bandwidth by truncating the output of the hash function to 80 bits when forming MAC tags.",
      "ja": "現在定義されているTLS暗号スイートは、[HMAC]記録層の通信を認証するために、MD5またはSHA-1のいずれかでMAC構成HMACを使用します。 TLSでは、ハッシュ関数の出力全体は、MACタグとして使用されます。しかし、MACタグを形成する際に80ビットのハッシュ関数の出力を切り捨てることによって帯域幅を節約するために制約のある環境に望ましいかもしれません。"
    },
    {
      "indent": 3,
      "text": "In order to negotiate the use of 80-bit truncated HMAC, clients MAY include an extension of type \"truncated_hmac\" in the extended client hello. The \"extension_data\" field of this extension SHALL be empty.",
      "ja": "80ビット切り捨てHMACの使用を交渉するためには、クライアントは、ハロー拡張クライアントタイプ「truncated_hmac」の拡張子を含むかもしれません。この拡張機能の「拡大」フィールドが空にされなければなりません。"
    },
    {
      "indent": 3,
      "text": "Servers that receive an extended hello containing a \"truncated_hmac\" extension MAY agree to use a truncated HMAC by including an extension of type \"truncated_hmac\", with empty \"extension_data\", in the extended server hello.",
      "ja": "「truncated_hmac」拡張を含む拡張こんにちはを受け取るサーバーはハロー拡張サーバーで、空の「拡大」で、「truncated_hmac」タイプの拡張子を含むことによって切り捨てHMACを使用することに同意することができます。"
    },
    {
      "indent": 3,
      "text": "Note that if new cipher suites are added that do not use HMAC, and the session negotiates one of these cipher suites, this extension will have no effect. It is strongly recommended that any new cipher suites using other MACs consider the MAC size an integral part of the cipher suite definition, taking into account both security and bandwidth considerations.",
      "ja": "新しい暗号スイートがHMACを使用していないが追加され、セッションはこれらの暗号スイートの1交渉する場合は、この拡張は効果がありませんので注意してください。他のMacを使用して、任意の新しい暗号スイートは、アカウントに両方のセキュリティと帯域幅の考慮を取って、MACサイズ暗号スイート定義の不可欠な部分を検討することを強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "If HMAC truncation has been successfully negotiated during a TLS handshake, and the negotiated cipher suite uses HMAC, both the client and the server pass this fact to the TLS record layer along with the other negotiated security parameters. Subsequently during the session, clients and servers MUST use truncated HMACs, calculated as specified in [HMAC]. That is, CipherSpec.hash_size is 10 bytes, and only the first 10 bytes of the HMAC output are transmitted and checked. Note that this extension does not affect the calculation of the pseudo-random function (PRF) as part of handshaking or key derivation.",
      "ja": "HMACの切り詰めが正常にTLSハンドシェイク中に交渉されてきた、と交渉した暗号スイートがHMACを使用する場合は、クライアントとサーバの両方が、他の交渉されたセキュリティパラメータと共にTLSレコード層にこの事実を渡します。その後、セッション中に、クライアントとサーバは、[HMAC]で指定したように計算切り捨てHMACsを、使用しなければなりません。すなわちCipherSpec.hash_sizeが10バイトであり、HMAC出力の最初の10のバイトが送信され、チェックされます。この拡張は、ハンドシェイク又は鍵導出の一部として、擬似ランダム関数（PRF）の計算に影響を及ぼさないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The negotiated HMAC truncation size applies for the duration of the session including session resumptions.",
      "ja": "交渉さHMACの切り捨てサイズは、セッションコンテニューを含むセッションの間に適用されます。"
    },
    {
      "indent": 0,
      "text": "3.6. Certificate Status Request",
      "section_title": true,
      "ja": "3.6。証明書のステータス要求"
    },
    {
      "indent": 3,
      "text": "Constrained clients may wish to use a certificate-status protocol such as OCSP [OCSP] to check the validity of server certificates, in order to avoid transmission of CRLs and therefore save bandwidth on constrained networks. This extension allows for such information to be sent in the TLS handshake, saving roundtrips and resources.",
      "ja": "制約付きのクライアントは、CRLの伝送を避けるため、制約ネットワーク上の帯域幅を節約するために、サーバ証明書の有効性を確認するために、このようなOCSP [OCSP]として証明書状態プロトコルを使用することもできます。この拡張は、往復とリソースを節約、TLSハンドシェイク中に送信されるような情報が可能になります。"
    },
    {
      "indent": 3,
      "text": "In order to indicate their desire to receive certificate status information, clients MAY include an extension of type \"status_request\" in the (extended) client hello. The \"extension_data\" field of this extension SHALL contain \"CertificateStatusRequest\" where:",
      "ja": "証明書のステータス情報を受信する意欲を示すために、クライアントはハロー（拡張）クライアントタイプ「status_request」の拡張子を含むかもしれません。この拡張機能の「拡大」フィールドが「CertificateStatusRequest」を含まなければなりません："
    },
    {
      "indent": 6,
      "text": "struct {\n    CertificateStatusType status_type;\n    select (status_type) {\n        case ocsp: OCSPStatusRequest;\n    } request;\n} CertificateStatusRequest;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "enum { ocsp(1), (255) } CertificateStatusType;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n    ResponderID responder_id_list<0..2^16-1>;\n    Extensions  request_extensions;\n} OCSPStatusRequest;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "opaque ResponderID<1..2^16-1>;\nopaque Extensions<0..2^16-1>;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the OCSPStatusRequest, the \"ResponderIDs\" provides a list of OCSP responders that the client trusts. A zero-length \"responder_id_list\" sequence has the special meaning that the responders are implicitly known to the server, e.g., by prior arrangement. \"Extensions\" is a DER encoding of OCSP request extensions.",
      "ja": "OCSPStatusRequestでは、「ResponderIDsは、」OCSPレスポンダクライアントが信頼のリストを提供します。ゼロ長「responder_id_list」配列は、応答が暗黙的に事前配置することによって、例えば、サーバに知られていることを特別な意味を有しています。 「拡張機能」OCSPリクエストエクステンションのDERエンコーディングです。"
    },
    {
      "indent": 3,
      "text": "Both \"ResponderID\" and \"Extensions\" are DER-encoded ASN.1 types as defined in [OCSP]. \"Extensions\" is imported from [PKIX]. A zero-length \"request_extensions\" value means that there are no extensions (as opposed to a zero-length ASN.1 SEQUENCE, which is not valid for the \"Extensions\" type).",
      "ja": "「ResponderID」および「拡張」[OCSP]で定義されるようにDER符号化されたASN.1タイプ共に。 「機能拡張」は[PKIX]からインポートされます。ゼロ長「request_extensions」値（「拡張」型に対して有効でない長さゼロのASN.1配列とは対照的に）は拡張が存在しないことを意味します。"
    },
    {
      "indent": 3,
      "text": "In the case of the \"id-pkix-ocsp-nonce\" OCSP extension, [OCSP] is unclear about its encoding; for clarification, the nonce MUST be a DER-encoded OCTET STRING, which is encapsulated as another OCTET STRING (note that implementations based on an existing OCSP client will need to be checked for conformance to this requirement).",
      "ja": "「ID-PKIX-OCSP-ノンス」OCSP拡張の場合には、[OCSP]は、その符号化については不明です。明確化のために、nonceが別のOCTET STRINGとしてカプセル化されているDER符号化されたOCTET STRINGでなければならない（既存のOCSPクライアントに基づく実装はこの要件に適合するためにチェックする必要があることに注意）。"
    },
    {
      "indent": 3,
      "text": "Servers that receive a client hello containing the \"status_request\" extension MAY return a suitable certificate status response to the client along with their certificate. If OCSP is requested, they SHOULD use the information contained in the extension when selecting an OCSP responder and SHOULD include request_extensions in the OCSP request.",
      "ja": "「status_request」拡張子を含むクライアントのhelloを受け取るサーバはその証明書を使用してクライアントに適した証明書状態応答を一緒に返してもよいです。 OCSPが要求された場合は、OCSPレスポンダを選択する際の拡張に含まれている情報を使用すべきであるし、OCSP要求にrequest_extensionsを含むべきです。"
    },
    {
      "indent": 3,
      "text": "Servers return a certificate response along with their certificate by sending a \"CertificateStatus\" message immediately after the \"Certificate\" message (and before any \"ServerKeyExchange\" or \"CertificateRequest\" messages). If a server returns a",
      "ja": "サーバーは、「証明書」のメッセージの直後に「CertificateStatus」メッセージを送信することにより、その証明書（および任意の「ServerKeyExchange」または「CertificateRequest」メッセージの前に）と一緒に証明書応答を返します。サーバが返した場合"
    },
    {
      "indent": 3,
      "text": "\"CertificateStatus\" message, then the server MUST have included an extension of type \"status_request\" with empty \"extension_data\" in the extended server hello.",
      "ja": "「CertificateStatus」メッセージは、サーバは、拡張サーバハローに空「拡大」とタイプ「status_request」の拡張を含んでいなければなりません。"
    },
    {
      "indent": 6,
      "text": "struct {\n    CertificateStatusType status_type;\n    select (status_type) {\n        case ocsp: OCSPResponse;\n    } response;\n} CertificateStatus;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "opaque OCSPResponse<1..2^24-1>;",
      "ja": "不透明OCSPResponse <1..2 ^ 24-1>;"
    },
    {
      "indent": 3,
      "text": "An \"ocsp_response\" contains a complete, DER-encoded OCSP response (using the ASN.1 type OCSPResponse defined in [OCSP]). Note that only one OCSP response may be sent.",
      "ja": "「ocsp_responseは」（[OCSP]で定義されたASN.1型OCSPResponseを使用して）完全な、DER符号化されたOCSP応答を含んでいます。唯一のOCSP応答を送信することができることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The \"CertificateStatus\" message is conveyed using the handshake message type \"certificate_status\".",
      "ja": "「CertificateStatus」メッセージは、ハンドシェイクメッセージタイプ「certificate_status」を使用して搬送されます。"
    },
    {
      "indent": 3,
      "text": "Note that a server MAY also choose not to send a \"CertificateStatus\" message, even if it receives a \"status_request\" extension in the client hello message.",
      "ja": "それは、クライアントのhelloメッセージで「status_request」の拡張子を受けても、サーバはまた、「CertificateStatus」メッセージを送信しないことを選択することができることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note in addition that servers MUST NOT send the \"CertificateStatus\" message unless it received a \"status_request\" extension in the client hello message.",
      "ja": "それは、クライアントのhelloメッセージで「status_request」の拡張子を受けない限り、サーバは「CertificateStatus」メッセージを送ってはいけないことに加えて、注意してください。"
    },
    {
      "indent": 3,
      "text": "Clients requesting an OCSP response and receiving an OCSP response in a \"CertificateStatus\" message MUST check the OCSP response and abort the handshake if the response is not satisfactory.",
      "ja": "クライアントOCSP応答を要求し、OCSP応答をチェックし、応答が十分でない場合は握手を中止しなければなりません「CertificateStatus」メッセージ中のOCSP応答を受け取ります。"
    },
    {
      "indent": 0,
      "text": "4. Error Alerts",
      "section_title": true,
      "ja": "4.エラーアラート"
    },
    {
      "indent": 3,
      "text": "This section defines new error alerts for use with the TLS extensions defined in this document.",
      "ja": "このセクションでは、この文書で定義されたTLS拡張で使用するための新しいエラー警告を定義します。"
    },
    {
      "indent": 3,
      "text": "The following new error alerts are defined. To avoid \"breaking\" existing clients and servers, these alerts MUST NOT be sent unless the sending party has received an extended hello message from the party they are communicating with.",
      "ja": "次の新しいエラーアラートが定義されています。送信側は、彼らが通信している相手からの拡張helloメッセージを受信した場合を除き、既存のクライアントとサーバを「破壊」を回避するには、これらのアラートを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "- \"unsupported_extension\": this alert is sent by clients that receive an extended server hello containing an extension that they did not put in the corresponding client hello (see Section 2.3). This message is always fatal.",
      "ja": " - 「unsupported_extension」：この警告は、ハロー彼らはハロー（2.3節を参照）、対応するクライアントには入れていないという拡張子を含む拡張サーバーを受け取るクライアントによって送信されます。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "- \"unrecognized_name\": this alert is sent by servers that receive a server_name extension request, but do not recognize the server name. This message MAY be fatal.",
      "ja": " - 「unrecognized_name」：この警告は、サーバー名拡張要求を受け取るサーバーが送信されますが、サーバー名を認識しません。このメッセージは致命的かもしれ。"
    },
    {
      "indent": 3,
      "text": "- \"certificate_unobtainable\": this alert is sent by servers who are unable to retrieve a certificate chain from the URL supplied by the client (see Section 3.3). This message MAY be fatal; for example, if client authentication is required by the server for the handshake to continue and the server is unable to retrieve the certificate chain, it may send a fatal alert.",
      "ja": " - 「certificate_unobtainable」：このアラートは、クライアントによって提供されるURLから証明書チェーンを取得することができないサーバーが送信される（3.3節を参照してください）。このメッセージは致命的かもしれ。クライアント認証を継続するために、ハンドシェイクのためのサーバが必要とサーバーが証明書チェーンを取得することができませんされている場合例えば、それは致命的なアラートを送信してもよいです。"
    },
    {
      "indent": 3,
      "text": "- \"bad_certificate_status_response\": this alert is sent by clients that receive an invalid certificate status response (see Section 3.6). This message is always fatal.",
      "ja": " - 「bad_certificate_status_response」：この警告は、無効な証明書のステータス応答を受け取るクライアントによって送信される（セクション3.6を参照してください）。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "- \"bad_certificate_hash_value\": this alert is sent by servers when a certificate hash does not match a client-provided certificate_hash. This message is always fatal.",
      "ja": " - 「bad_certificate_hash_value」：証明書ハッシュは、クライアントが提供するcertificate_hashと一致しない場合、このアラートは、サーバによって送信されます。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "These error alerts are conveyed using the following syntax:",
      "ja": "これらのエラーアラートは、次の構文を使用して搬送されます。"
    },
    {
      "indent": 6,
      "text": "enum {\n    close_notify(0),\n    unexpected_message(10),\n    bad_record_mac(20),\n    decryption_failed(21),\n    record_overflow(22),\n    decompression_failure(30),\n    handshake_failure(40),\n    /* 41 is not defined, for historical reasons */\n    bad_certificate(42),\n    unsupported_certificate(43),\n    certificate_revoked(44),\n    certificate_expired(45),\n    certificate_unknown(46),\n    illegal_parameter(47),\n    unknown_ca(48),\n    access_denied(49),\n    decode_error(50),\n    decrypt_error(51),\n    export_restriction(60),\n    protocol_version(70),\n    insufficient_security(71),\n    internal_error(80),\n    user_canceled(90),\n    no_renegotiation(100),\n    unsupported_extension(110),           /* new */\n    certificate_unobtainable(111),        /* new */\n    unrecognized_name(112),               /* new */\n    bad_certificate_status_response(113), /* new */\n    bad_certificate_hash_value(114),      /* new */\n    (255)\n} AlertDescription;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. Procedure for Defining New Extensions",
      "section_title": true,
      "ja": "定義新しい拡張機能5.手順"
    },
    {
      "indent": 3,
      "text": "The list of extension types, as defined in Section 2.3, is maintained by the Internet Assigned Numbers Authority (IANA). Thus, an application needs to be made to the IANA in order to obtain a new extension type value. Since there are subtle (and not-so-subtle) interactions that may occur in this protocol between new features and existing features that may result in a significant reduction in overall security, new values SHALL be defined only through the IETF Consensus process specified in [IANA].",
      "ja": "拡張タイプのリストは、セクション2.3で定義されるように、Internet Assigned Numbers Authority（IANA）によって維持されます。したがって、アプリケーションは、新しい拡張タイプ値を得るために、IANAに行われる必要があります。新機能および全体的なセキュリティの有意な減少をもたらすことができる既存の機能との間のこのプロトコルで発生する可能性が微妙（およびそれほど微妙ではない）の相互作用があるため、新しい値のみで指定されたIETFコンセンサスプロセスを経て定義されなければなりません[ IANA]。"
    },
    {
      "indent": 3,
      "text": "(This means that new assignments can be made only via RFCs approved by the IESG.)",
      "ja": "（これは、新しい割り当てはIESGによって承認されたRFC経由でのみ行うことができることを意味します。）"
    },
    {
      "indent": 3,
      "text": "The following considerations should be taken into account when designing new extensions:",
      "ja": "新しい拡張機能を設計する際に、以下の考慮事項を考慮に入れるべきです。"
    },
    {
      "indent": 3,
      "text": "- All of the extensions defined in this document follow the convention that for each extension that a client requests and that the server understands, the server replies with an extension of the same type.",
      "ja": " - この文書で定義された拡張機能はすべて、それぞれの拡張のために、クライアントが要求するとサーバーが同じタイプの拡張子で応答し、サーバーが理解できるという慣例に従ってください。"
    },
    {
      "indent": 3,
      "text": "- Some cases where a server does not agree to an extension are error conditions, and some simply a refusal to support a particular feature. In general, error alerts should be used for the former, and a field in the server extension response for the latter.",
      "ja": " - サーバが延長に同意しないいくつかの例は、エラー条件であり、単にいくつかの特定の機能をサポートするために拒否。一般的に、エラー警告は、後者のためにサーバ拡張応答の元、およびフィールドのために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "- Extensions should as far as possible be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages. This principle should be followed regardless of whether the feature is believed to cause a security problem.",
      "ja": " - 拡張機能は、可能な限り握手メッセージの操作によって特定の機能の使用（または非使用）を強制的に任意の攻撃を防ぐように設計されなければなりません。この原則は関係なく、機能はセキュリティ上の問題を引き起こすと考えられているかどうかの従うべきです。"
    },
    {
      "indent": 6,
      "text": "Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase. Designers and implementors should be aware of the fact that until the handshake has been authenticated, active attackers can modify messages and insert, remove, or replace extensions.",
      "ja": "多くの場合、拡張フィールドがFinishedメッセージハッシュへの入力に含まれているという事実は十分であろうが、拡張子がハンドシェイクフェーズで送信されたメッセージの意味を変更したときに細心の注意が必要です。設計者と実装者は、ハンドシェイクが認証されるまで、アクティブな攻撃者がメッセージを変更し、挿入、削除、または拡張を置き換えることができるという事実に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "- It would be technically possible to use extensions to change major aspects of the design of TLS; for example, the design of cipher suite negotiation. This is not recommended; it would be more appropriate to define a new version of TLS, particularly since the TLS handshake algorithms have specific protection against version rollback attacks based on the version number. The possibility of version rollback should be a significant consideration in any major design change.",
      "ja": " -  TLSの設計の主要な側面を変更する拡張機能を使用することは技術的には可能だろう。例えば、暗号スイートのネゴシエーションのデザイン。これはお勧めしません。 TLSハンドシェイクアルゴリズムは、バージョン番号に基づくバージョンロールバック攻撃に対する特定の保護を持っている、特に以来、TLSの新しいバージョンを定義するのがより適切であろう。バージョンロールバックの可能性は、すべての主要な設計変更で重要な考慮事項でなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Security considerations for the extension mechanism in general and for the design of new extensions are described in the previous section. A security analysis of each of the extensions defined in this document is given below.",
      "ja": "一般的には、新たな拡張の設計のための拡張メカニズムのためのセキュリティの考慮事項は、前のセクションで説明されています。この文書で定義された拡張の各のセキュリティ分析は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "In general, implementers should continue to monitor the state of the art and address any weaknesses identified.",
      "ja": "一般的には、実装者は、芸術の状態を監視し、特定された弱点に対処し続けなければなりません。"
    },
    {
      "indent": 3,
      "text": "Additional security considerations are described in the TLS 1.0 RFC [TLS] and the TLS 1.1 RFC [TLSbis].",
      "ja": "追加のセキュリティ上の考慮事項は、TLS 1.0 RFC [TLS]およびTLS 1.1 RFC [TLSbis]で説明されています。"
    },
    {
      "indent": 0,
      "text": "6.1. Security of server_name",
      "section_title": true,
      "ja": "6.1。 SERVER_NAMEのセキュリティ"
    },
    {
      "indent": 3,
      "text": "If a single server hosts several domains, then clearly it is necessary for the owners of each domain to ensure that this satisfies their security needs. Apart from this, server_name does not appear to introduce significant security issues.",
      "ja": "単一のサーバが複数のドメインをホストする場合は、各ドメインの所有者が、これはそれぞれのセキュリティニーズを満たすことを確実にするためにのために、そして明確にそれが必要です。これとは別に、server_nameは重大なセキュリティ上の問題を紹介して表示されません。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST ensure that a buffer overflow does not occur, whatever the values of the length fields in server_name.",
      "ja": "実装は、サーバー名の長さフィールドのどの値が、バッファ・オーバーフローが発生しないことを保証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Although this document specifies an encoding for internationalized hostnames in the server_name extension, it does not address any security issues associated with the use of internationalized hostnames in TLS (in particular, the consequences of \"spoofed\" names that are indistinguishable from another name when displayed or printed). It is recommended that server certificates not be issued for internationalized hostnames unless procedures are in place to mitigate the risk of spoofed hostnames.",
      "ja": "このドキュメントは、サーバー名の拡張子で国際化ホスト名のエンコーディングを指定しますが、それは（特に、別の名前と区別がつかない「偽装された」名前の結果を表示したときにTLSにおける国際化ホスト名の使用に関連したすべてのセキュリティ問題に対処していませんか、印刷されました）。手順が偽装されたホスト名のリスクを軽減するための場所である場合を除き、サーバー証明書が国際化ホスト名のために発行されていないことをお勧めします。"
    },
    {
      "indent": 0,
      "text": "6.2. Security of max_fragment_length",
      "section_title": true,
      "ja": "6.2。 max_fragment_lengthのセキュリティ"
    },
    {
      "indent": 3,
      "text": "The maximum fragment length takes effect immediately, including for handshake messages. However, that does not introduce any security complications that are not already present in TLS, since TLS requires implementations to be able to handle fragmented handshake messages.",
      "ja": "最大フラグメント長は、ハンドシェイク・メッセージを含む、すぐに有効になります。 TLSは、断片化されたハンドシェイクメッセージを処理できるように実装を必要とするためしかし、それは、TLSには既に存在していない任意のセキュリティ合併症を導入していません。"
    },
    {
      "indent": 3,
      "text": "Note that as described in Section 3.2, once a non-null cipher suite has been activated, the effective maximum fragment length depends on the cipher suite and compression method, as well as on the negotiated max_fragment_length. This must be taken into account when sizing buffers, and checking for buffer overflow.",
      "ja": "非ヌル暗号スイートが起動された後、セクション3.2で説明したように、有効な最大の断片長は暗号スイートと圧縮方法に、ならびにネゴシエートmax_fragment_lengthに依存することに留意されたいです。これは、バッファのサイズを決定する際に考慮され、バッファオーバーフローをチェックする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Security of client_certificate_url",
      "section_title": true,
      "ja": "6.3。 client_certificate_urlのセキュリティ"
    },
    {
      "indent": 3,
      "text": "There are two major issues with this extension.",
      "ja": "この拡張子を持つ2つの大きな問題があります。"
    },
    {
      "indent": 3,
      "text": "The first major issue is whether or not clients should include certificate hashes when they send certificate URLs.",
      "ja": "最初の主要な問題は、彼らが証明書のURLを送信するとき、クライアントが証明書ハッシュを含めるべきかどうかではありません。"
    },
    {
      "indent": 3,
      "text": "When client authentication is used *without* the client_certificate_url extension, the client certificate chain is covered by the Finished message hashes. The purpose of including hashes and checking them against the retrieved certificate chain is to ensure that the same property holds when this extension is used, i.e., that all of the information in the certificate chain retrieved by the server is as the client intended.",
      "ja": "クライアント認証がclient_certificate_url拡張子*なし*使用されている場合は、クライアント証明書チェーンはFinishedメッセージハッシュで覆われています。ハッシュを含む、取得証明書チェーンに対してそれらを確認する目的は、この拡張を使用する場合と同じプロパティは、クライアントが意図したように、サーバによって取得証明書チェーン内のすべての情報であること、即ち、保持していることを保証することです。"
    },
    {
      "indent": 3,
      "text": "On the other hand, omitting certificate hashes enables functionality that is desirable in some circumstances; for example, clients can be issued daily certificates that are stored at a fixed URL and need not be provided to the client. Clients that choose to omit certificate hashes should be aware of the possibility of an attack in which the attacker obtains a valid certificate on the client's key that is different from the certificate the client intended to provide. Although TLS uses both MD5 and SHA-1 hashes in several other places, this was not believed to be necessary here. The property required of SHA-1 is second pre-image resistance.",
      "ja": "一方、証明書のハッシュを省略すると、いくつかの状況において望ましい機能を可能にします。例えば、クライアントが固定されたURLに保存され、クライアントに提供する必要がない、毎日の証明書を発行することができます。証明書ハッシュを省略することを選択したクライアントは、攻撃者がクライアントを提供することを目的とした証明書とは異なり、クライアントのキーの有効な証明書を取得するには、攻撃の可能性に注意する必要があります。 TLSは、いくつかの他の場所でMD5とSHA-1ハッシュの両方を使用していますが、これはここでは必要であると考えられていませんでした。 SHA-1の必要性は、第二のプリイメージ耐性です。"
    },
    {
      "indent": 3,
      "text": "The second major issue is that support for client_certificate_url involves the server's acting as a client in another URL protocol. The server therefore becomes subject to many of the same security concerns that clients of the URL scheme are subject to, with the added concern that the client can attempt to prompt the server to connect to some (possibly weird-looking) URL.",
      "ja": "第二の主要な問題は、client_certificate_urlのサポートは別のURLプロトコルでクライアントとしてサーバーの演技を含むことです。サーバーは、したがって、URLスキームのクライアントは、クライアントは、いくつかの（おそらく奇妙に見える）URLに接続するようにサーバーを促すために試みることができると付け加えた懸念で、対象としているのと同じセキュリティ上の懸念の多くの対象になります。"
    },
    {
      "indent": 3,
      "text": "In general, this issue means that an attacker might use the server to indirectly attack another host that is vulnerable to some security flaw. It also introduces the possibility of denial of service attacks in which an attacker makes many connections to the server, each of which results in the server's attempting a connection to the target of the attack.",
      "ja": "一般に、この問題は、攻撃者が間接的にいくつかのセキュリティ上の欠陥に対して脆弱である別のホストを攻撃するためにサーバーを使用する可能性があることを意味します。また、攻撃者は、攻撃のターゲットへのサーバの接続しようとし、その結果それぞれのサーバに多くの接続を行っているサービス妨害攻撃の可能性を紹介します。"
    },
    {
      "indent": 3,
      "text": "Note that the server may be behind a firewall or otherwise able to access hosts that would not be directly accessible from the public Internet. This could exacerbate the potential security and denial of service problems described above, as well as allow the existence of internal hosts to be confirmed when they would otherwise be hidden.",
      "ja": "サーバーがパブリックインターネットから直接アクセスではないでしょうホストにアクセスできるようにファイアウォールまたはその他の背後にあってもよいことに注意してください。これは、上記のサービスの問題の潜在的なセキュリティと拒否を悪化させるだけでなく、彼らはそれ以外の場合は非表示にするだろうというとき、内部ホストの存在が確認される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The detailed security concerns involved will depend on the URL schemes supported by the server. In the case of HTTP, the concerns are similar to those that apply to a publicly accessible HTTP proxy server. In the case of HTTPS, loops and deadlocks may be created, and this should be addressed. In the case of FTP, attacks arise that are similar to FTP bounce attacks.",
      "ja": "関連する詳細なセキュリティ上の問題は、サーバーでサポートされているURLスキームに依存します。 HTTPの場合、懸念が公的にアクセス可能なHTTPプロキシサーバに適用されるものと同様です。 HTTPSの場合、ループおよびデッドロックが作成されることがあり、これに対処しなければなりません。 FTPの場合、攻撃はFTPバウンス攻撃に類似していることが生じます。"
    },
    {
      "indent": 3,
      "text": "As a result of this issue, it is RECOMMENDED that the client_certificate_url extension should have to be specifically enabled by a server administrator, rather than be enabled by default. It is also RECOMMENDED that URI protocols be enabled by the administrator individually, and only a minimal set of protocols be enabled. Unusual protocols that offer limited security or whose security is not well-understood SHOULD be avoided.",
      "ja": "この問題の結果として、client_certificate_url拡張子は特にサーバー管理者によって有効にする必要があります、というよりも、デフォルトで有効にすることを推奨します。また、URIプロトコルが個別に管理者が有効にされ、プロトコルの唯一の最小セットを有効にすることを推奨します。限られたセキュリティやセキュリティ、よく理解されていない避けるべきである（SHOULD）を提供して異常なプロトコル。"
    },
    {
      "indent": 3,
      "text": "As discussed in [URI], URLs that specify ports other than the default may cause problems, as may very long URLs (which are more likely to be useful in exploiting buffer overflow bugs).",
      "ja": "[URI]で議論したように（バッファオーバーフローのバグを利用するのに有用である可能性が高い）非常に長いURLを得るように、デフォルト以外のポートを指定するURLは、問題を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "Also note that HTTP caching proxies are common on the Internet, and some proxies do not check for the latest version of an object correctly. If a request using HTTP (or another caching protocol) goes through a misconfigured or otherwise broken proxy, the proxy may return an out-of-date response.",
      "ja": "また、HTTPキャッシングプロキシは、インターネット上で共通していることに注意してください、といくつかのプロキシは正しくオブジェクトの最新バージョンをチェックしません。 HTTP（または他のキャッシュプロトコル）を使用して要求が誤って設定または他の方法で破損プロキシを通過する場合、プロキシは、期限切れの応答を返すことができます。"
    },
    {
      "indent": 0,
      "text": "6.4. Security of trusted_ca_keys",
      "section_title": true,
      "ja": "6.4。 trusted_ca_keysのセキュリティ"
    },
    {
      "indent": 3,
      "text": "It is possible that which CA root keys a client possesses could be regarded as confidential information. As a result, the CA root key indication extension should be used with care.",
      "ja": "クライアントが所有しているCAルート鍵は、機密情報とみなすことができたということも可能です。その結果、CAルートキー表示の拡張子は注意して使用してください。"
    },
    {
      "indent": 3,
      "text": "The use of the SHA-1 certificate hash alternative ensures that each certificate is specified unambiguously. As for the previous extension, it was not believed necessary to use both MD5 and SHA-1 hashes.",
      "ja": "SHA-1証明書ハッシュ代替の使用は、各証明書が明確に指定されることを保証します。前拡張用としては、MD5とSHA-1ハッシュの両方を使用する必要はないと考えました。"
    },
    {
      "indent": 0,
      "text": "6.5. Security of truncated_hmac",
      "section_title": true,
      "ja": "6.5。 truncated_hmacのセキュリティ"
    },
    {
      "indent": 3,
      "text": "It is possible that truncated MACs are weaker than \"un-truncated\" MACs. However, no significant weaknesses are currently known or expected to exist for HMAC with MD5 or SHA-1, truncated to 80 bits.",
      "ja": "切り捨てMACは「非切り捨て」のMACよりも弱いことも可能です。しかし、有意な弱点は、現在知られていないか、MD5またはSHA-1、80ビットに切り捨てとHMACのために存在すると予想されます。"
    },
    {
      "indent": 3,
      "text": "Note that the output length of a MAC need not be as long as the length of a symmetric cipher key, since forging of MAC values cannot be done off-line: in TLS, a single failed MAC guess will cause the immediate termination of the TLS session.",
      "ja": "単一障害が発生したMACは、TLSの即時停止を引き起こします、TLSに推測：MAC値の鍛造がオフラインで行うことができないので、MACの出力長は、対称暗号鍵の長さが限りである必要はないことに注意してくださいセッション。"
    },
    {
      "indent": 3,
      "text": "Since the MAC algorithm only takes effect after all handshake messages that affect extension parameters have been authenticated by the hashes in the Finished messages, it is not possible for an active attacker to force negotiation of the truncated HMAC extension where it would not otherwise be used (to the extent that the handshake authentication is secure). Therefore, in the event that any security problem were found with truncated HMAC in the future, if either the client or the server for a given session were updated to take the problem into account, it would be able to veto use of this extension.",
      "ja": "MACアルゴリズムは唯一の拡張パラメータがFinishedメッセージでハッシュによって認証されている影響を与えるすべてのハンドシェイクメッセージの後に有効になりますので、アクティブな攻撃者は、それがそうでなければ使用できません切り捨てHMAC延長の交渉を強制するために、それは（可能ではありません程度のハンドシェイク認証）が安全であること。クライアントまたは特定のセッションのためのサーバーのいずれかのアカウントに問題を取るために更新された場合そのため、どのようなセキュリティ上の問題は、将来的に切り詰められたHMACで発見された場合には、この拡張機能の使用を拒否することができるだろう。"
    },
    {
      "indent": 0,
      "text": "6.6. Security of status_request",
      "section_title": true,
      "ja": "6.6。 status_requestのセキュリティ"
    },
    {
      "indent": 3,
      "text": "If a client requests an OCSP response, it must take into account that an attacker's server using a compromised key could (and probably would) pretend not to support the extension. In this case, a client that requires OCSP validation of certificates SHOULD either contact the OCSP server directly or abort the handshake.",
      "ja": "クライアントは、OCSP応答を要求した場合、それは攻撃者のサーバが（そしておそらくでしょう）拡張をサポートしないふり妥協キーを使用していることを考慮に入れる必要があります。この場合、証明書のOCSP検証を必要とするクライアントは、直接OCSPサーバーに連絡するか、握手を中止すべきであるのいずれか。"
    },
    {
      "indent": 3,
      "text": "Use of the OCSP nonce request extension (id-pkix-ocsp-nonce) may improve security against attacks that attempt to replay OCSP responses; see Section 4.4.1 of [OCSP] for further details.",
      "ja": "OCSPナンス要求拡張（ID-PKIX-OCSP-ナンス）の使用は、OCSP応答を再生しようとする攻撃に対するセキュリティを向上させること。詳細については、[OCSP]のセクション4.4.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "7. Internationalization Considerations",
      "section_title": true,
      "ja": "7.国際化に関する注意事項"
    },
    {
      "indent": 3,
      "text": "None of the extensions defined here directly use strings subject to localization. Domain Name System (DNS) hostnames are encoded using UTF-8. If future extensions use text strings, then internationalization should be considered in their design.",
      "ja": "ここで定義された拡張子のいずれも直接ローカライズ対象の文字列を使用していません。ドメインネームシステム（DNS）ホスト名はUTF-8を使用してエンコードされています。将来の拡張は、テキスト文字列を使用する場合は、国際化は、それらの設計で考慮されるべきです。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Sections 2.3 and 5 describe a registry of ExtensionType values to be maintained by the IANA. ExtensionType values are to be assigned via IETF Consensus as defined in RFC 2434 [IANA]. The initial registry corresponds to the definition of \"ExtensionType\" in Section 2.3.",
      "ja": "セクション2.3と5は、IANAによって維持されるExtensionType値のレジストリを記述する。 ExtensionType値は、RFC 2434 [IANA]で定義されるようにIETFコンセンサスを介して割り当てられます。最初のレジストリは、2.3節で「ExtensionType」の定義に対応します。"
    },
    {
      "indent": 3,
      "text": "The MIME type \"application/pkix-pkipath\" has been registered by the IANA with the following template:",
      "ja": "MIMEタイプ「アプリケーション/ PKIX-pkipath」は、以下のテンプレートにIANAによって登録されています。"
    },
    {
      "indent": 3,
      "text": "To: ietf-types@iana.org Subject: Registration of MIME media type application/pkix-pkipath",
      "ja": "To：ietf-types@iana.org件名：MIMEメディアタイプapplication / PKIX-pkipathの登録"
    },
    {
      "indent": 3,
      "text": "MIME media type name: application MIME subtype name: pkix-pkipath Required parameters: none",
      "ja": "MIMEメディアタイプ名：application MIMEサブタイプ名：PKIX-pkipath必須パラメーター：なし"
    },
    {
      "indent": 3,
      "text": "Optional parameters: version (default value is \"1\")",
      "ja": "オプションのパラメータ：バージョン（デフォルト値は「1」です）"
    },
    {
      "indent": 3,
      "text": "Encoding considerations:\n   This MIME type is a DER encoding of the ASN.1 type PkiPath,\n   defined as follows:\n     PkiPath ::= SEQUENCE OF Certificate\n     PkiPath is used to represent a certification path.  Within the\n     sequence, the order of certificates is such that the subject of\n     the first certificate is the issuer of the second certificate,\n     etc.",
      "raw": true
    },
    {
      "indent": 6,
      "text": "This is identical to the definition published in [X509-4th-TC1]; note that it is different from that in [X509-4th].",
      "ja": "これは、[X509-4th-TC1]に掲載された定義と同じです。それは[X509-4th]と異なることに注意してください。"
    },
    {
      "indent": 6,
      "text": "All Certificates MUST conform to [PKIX]. (This should be interpreted as a requirement to encode only PKIX-conformant certificates using this type. It does not necessarily require that all certificates that are not strictly PKIX-conformant must be rejected by relying parties, although the security consequences of accepting any such certificates should be considered carefully.)",
      "ja": "すべての証明書は、[PKIX]に従わなければなりません。 （これは、このタイプを使用してのみPKIX準拠の証明書をエンコードするための要件として解釈されるべきである。それは、必ずしも厳密PKIX-準拠していないすべての証明書はどのような証明書を受け入れるのセキュリティへの影響が、依拠当事者によって拒否されなければならないことを必要としません慎重に検討する必要があります。）"
    },
    {
      "indent": 6,
      "text": "DER (as opposed to BER) encoding MUST be used. If this type is sent over a 7-bit transport, base64 encoding SHOULD be used.",
      "ja": "DER（BERとは対照的に）符号化を使用しなければなりません。このタイプは、7ビットのトランスポートを介して送信される場合、base64エンコーディングを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Security considerations: The security considerations of [X509-4th] and [PKIX] (or any updates to them) apply, as well as those of any protocol that uses this type (e.g., TLS).",
      "ja": "セキュリティの考慮事項：[X509-4th]および[PKIX]（又はそれらに対する更新）セキュリティ上の考慮事項が適用され、同様に、このタイプ（例えば、TLS）を使用する任意のプロトコルのもの。"
    },
    {
      "indent": 6,
      "text": "Note that this type only specifies a certificate chain that can be assessed for validity according to the relying party's existing configuration of trusted CAs; it is not intended to be used to specify any change to that configuration.",
      "ja": "このタイプは、唯一の信頼できるCAの証明書利用者の既存の構成に応じて有効性について評価することができる証明書チェーンを指定することに注意してください。その構成に変更を指定するために使用されるものではありません。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: No specific interoperability problems are known with this type, but for recommendations relating to X.509 certificates in general, see [PKIX].",
      "ja": "相互運用性に関する注意事項：いいえ、特定の相互運用性の問題は、このタイプで知られているが、一般的にX.509証明書に関する推奨事項については、[PKIX]を参照されています。"
    },
    {
      "indent": 3,
      "text": "Published specification: RFC 4366 (this memo), and [PKIX].",
      "ja": "公開された仕様：RFC 4366（このメモ）、および[PKIX]。"
    },
    {
      "indent": 3,
      "text": "Applications which use this media type: TLS. It may also be used by other protocols, or for general interchange of PKIX certificate chains.",
      "ja": "TLS：このメディアタイプを使用するアプリケーション。それはまた、他のプロトコルによって使用される、またはPKIX証明書チェーンの一般的な交換のためにすることができます。"
    },
    {
      "indent": 3,
      "text": "Additional information: Magic number(s): DER-encoded ASN.1 can be easily recognized. Further parsing is required to distinguish it from other ASN.1 types. File extension(s): .pkipath Macintosh File Type Code(s): not specified",
      "ja": "追加情報：マジックナンバー（S）：DER符号化されたASN.1を容易に認識することができます。さらに、解析は他のASN.1タイプと区別するために必要とされます。ファイルの拡張子（S）：.pkipath Macintoshファイルタイプコード（S）：指定されていません"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: Magnus Nystrom <magnus@rsasecurity.com>",
      "ja": "人とEメールアドレスは、詳細のために連絡する：マグナスNystrom <magnus@rsasecurity.com>"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図している用法：COMMON"
    },
    {
      "indent": 3,
      "text": "Change controller: IESG <iesg@ietf.org>",
      "ja": "変更コントローラ：IESG <iesg@ietf.org>"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgements",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank the TLS Working Group and the WAP Security Group. This document is based on discussion within these groups.",
      "ja": "著者は、TLSワーキンググループとWAPセキュリティグループに感謝したいです。この文書は、これらのグループ内での議論に基づいています。"
    },
    {
      "indent": 0,
      "text": "10. Normative References",
      "section_title": true,
      "ja": "10.引用規格"
    },
    {
      "indent": 3,
      "text": "[HMAC] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[HMAC] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[HTTP] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[HTTP]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[IANA] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[IANA] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[IDNA] Faltstrom, P., Hoffman, P., and A. Costello, \"Internationalizing Domain Names in Applications (IDNA)\", RFC 3490, March 2003.",
      "ja": "[IDNA] Faltstrom、P.、ホフマン、P.、およびA.コステロ、 \"アプリケーションにおける国際化ドメイン名（IDNA）\"、RFC 3490、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[KEYWORDS] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[キーワード]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[OCSP] Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, \"X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP\", RFC 2560, June 1999.",
      "ja": "[OCSP]マイヤーズ、M.、Ankney、R.、Malpani、A.、Galperin、S.、およびC.アダムス、 \"X.509のインターネット公開鍵暗号基盤のオンライン証明書状態プロトコル -  OCSP\"、RFC 2560、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[PKIOP] Housley, R. and P. Hoffman, \"Internet X.509 Public Key Infrastructure Operational Protocols: FTP and HTTP\", RFC 2585, May 1999.",
      "ja": "[PKIOP] Housley氏、R.とP.ホフマン、 \"インターネットX.509公開鍵基盤運用プロトコル：FTPやHTTP\"、RFC 2585、1999年5月。"
    },
    {
      "indent": 3,
      "text": "[PKIX] Housley, R., Polk, W., Ford, W., and D. Solo, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 3280, April 2002.",
      "ja": "[PKIX] Housley氏、R.、ポーク、W.、フォード、W.、およびD.ソロ、 \"インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）プロフィール\"、RFC 3280、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[TLS] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[TLS]ダークス、T.とC.アレン、 \"TLSプロトコルバージョン1.0\"、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[TLSbis] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.1\", RFC 4346, April 2006.",
      "ja": "[TLSbis]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.1\"、RFC 4346、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[URI] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[URI]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[UTF8] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[UTF8] Yergeau、F.、 \"UTF8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[X509-4th] ITU-T Recommendation X.509 (2000) | ISO/IEC 9594-8:2001, \"Information Systems - Open Systems Interconnection - The Directory: Public key and attribute certificate frameworks.\"",
      "ja": "[X509-4th] ITU-T勧告X.509（2000）| ISO / IEC 9594から8：2001、「情報システム - オープンシステムインターコネクション - ディレクトリ：公開鍵と属性証明書の枠組み。」"
    },
    {
      "indent": 3,
      "text": "[X509-4th-TC1] ITU-T Recommendation X.509(2000) Corrigendum 1(2001) | ISO/IEC 9594-8:2001/Cor.1:2002, Technical Corrigendum 1 to ISO/IEC 9594:8:2001.",
      "ja": "[X509-4th-TC1] ITU-T勧告X.509（2000）追補1（2001）| ISO / IEC 9594から8：2001 / Cor.1、2002年、技術的な改正1 ISO / IEC 9594：8、2001。"
    },
    {
      "indent": 0,
      "text": "11. Informative References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 3,
      "text": "[AESSUITES] Chown, P., \"Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)\", RFC 3268, June 2002.",
      "ja": "、RFC 3268、2002年6月[AESSUITES]のchown、P.、 \"トランスポート層セキュリティ（TLS）用のAdvanced Encryption Standard（AES）暗号の組み合わせ\"。"
    },
    {
      "indent": 3,
      "text": "[KERB] Medvinsky, A. and M. Hur, \"Addition of Kerberos Cipher Suites to Transport Layer Security (TLS)\", RFC 2712, October 1999.",
      "ja": "[CURB] Medvinsky、A.とM.ハー、RFC 2712、1999年10月 \"Layer Security（TLS）を輸送するためのケルベロス暗号スイートの追加\"。"
    },
    {
      "indent": 3,
      "text": "[MAILINGLIST] J. Mikkelsen, R. Eberhard, and J. Kistler, \"General ClientHello extension mechanism and virtual hosting,\" ietf-tls mailing list posting, August 14, 2000.",
      "ja": "[メーリングリスト] J.ミケルセン、R.エーベルハルト、およびJ.キスラー、 \"一般のClientHello拡張メカニズムと仮想ホスティング、\" IETF-TLSメーリングリストへの投稿、2000年8月14日。"
    },
    {
      "indent": 3,
      "text": "[RFC3546] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, \"Transport Layer Security (TLS) Extensions\", RFC 3546, June 2003.",
      "ja": "[RFC3546]ブレイク・ウィルソン、S.、Nystrom、M.、ホップウッド、D.、ミケルセン、J.、およびT.ライト、 \"トランスポート層セキュリティ（TLS）の拡張\"、RFC 3546、2003年6月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Simon Blake-Wilson BCI",
      "ja": "サイモン・ブレイク・ウィルソンBCI"
    },
    {
      "indent": 3,
      "text": "EMail: sblakewilson@bcisse.com",
      "ja": "メールアドレス：sblakewilson@bcisse.com"
    },
    {
      "indent": 3,
      "text": "Magnus Nystrom RSA Security",
      "ja": "マグナスNystrom RSAセキュリティ"
    },
    {
      "indent": 3,
      "text": "EMail: magnus@rsasecurity.com",
      "ja": "メールアドレス：magnus@rsasecurity.com"
    },
    {
      "indent": 3,
      "text": "David Hopwood Independent Consultant",
      "ja": "デビッド・ホップウッド独立コンサルタント"
    },
    {
      "indent": 3,
      "text": "EMail: david.hopwood@blueyonder.co.uk",
      "ja": "メールアドレス：david.hopwood@blueyonder.co.uk"
    },
    {
      "indent": 3,
      "text": "Jan Mikkelsen Transactionware",
      "ja": "1月ミケルセンTransactionware"
    },
    {
      "indent": 3,
      "text": "EMail: janm@transactionware.com",
      "ja": "メールアドレス：janm@transactionware.com"
    },
    {
      "indent": 3,
      "text": "Tim Wright Vodafone",
      "ja": "ティム・ライトボーダフォン"
    },
    {
      "indent": 3,
      "text": "EMail: timothy.wright@vodafone.com",
      "ja": "メールアドレス：timothy.wright@vodafone.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディタ機能のための資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}