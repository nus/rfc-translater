{
  "title": {
    "text": "RFC 4011 - Policy Based Management MIB",
    "ja": "RFC 4011 - ポリシーベースの管理MIB"
  },
  "number": 4011,
  "created_at": "2019-10-18 22:13:32.728948+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                      S. Waldbusser\nRequest for Comments: 4011                                    Nextbeacon\nCategory: Standards Track                                     J. Saperia\n                                                    JDS Consulting, Inc.\n                                                               T. Hongal\n                                               Riverstone Networks, Inc.\n                                                              March 2005",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Policy Based Management MIB",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントでは、インターネットコミュニティ向けのインターネット標準追跡プロトコルを指定し、改善のための議論と提案を求めています。 このプロトコルの標準化状態とステータスについては、「Internet Official Protocol Standards」（STD 1）の最新版を参照してください。 このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo defines a portion of the Management Information Base (MIB) for use with network management protocols in TCP/IP-based internets. In particular, this MIB defines objects that enable policy-based monitoring and management of Simple Network Management Protocol (SNMP) infrastructures, a scripting language, and a script execution environment.",
      "ja": "このメモは、TCP / IPベースのインターネットのネットワーク管理プロトコルで使用する管理情報ベース（MIB）の一部を定義します。 特に、このMIBは、SNMP（Simple Network Management Protocol）インフラストラクチャ、スクリプト言語、およびスクリプト実行環境のポリシーベースの監視と管理を可能にするオブジェクトを定義します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  The Internet-Standard Management Framework ..................   3\n2.  Overview ....................................................   4\n3.  Policy-Based Management Architecture ........................   4\n4.  Policy-Based Management Execution Environment ...............  10\n    4.1.  Terminology ...........................................  10\n    4.2.  Execution Environment - Elements of Procedure .........  10\n    4.3.  Element Discovery .....................................  11\n          4.3.1.  Implementation Notes ..........................  12\n    4.4.  Element Filtering .....................................  13\n          4.4.1.  Implementation Notes ..........................  13\n    4.5.  Policy Enforcement ....................................  13\n          4.5.1.  Implementation Notes ..........................  14\n5.  The PolicyScript Language ...................................  14\n    5.1.  Formal Definition .....................................  15",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    5.2.  Variables .............................................  18\n          5.2.1.  The Var Class .................................  19\n    5.3.  PolicyScript QuickStart Guide .........................  23\n          5.3.1.  Quickstart for C Programmers ..................  25\n          5.3.2.  Quickstart for Perl Programmers ...............  25\n          5.3.3.  Quickstart for TCL Programmers ................  25\n          5.3.4.  Quickstart for Python Programmers .............  26\n          5.3.5.  Quickstart for JavaScript/ECMAScript/JScript\n                  Programmers ...................................  26\n    5.4.  PolicyScript Script Return Values .....................  26\n6.  Index Information for `this element' ........................  27\n7.  Library Functions ...........................................  28\n8.  Base Function Library .......................................  29\n    8.1.  SNMP Library Functions ................................  29\n          8.1.1.  SNMP Operations on Non-Local Systems ..........  30\n          8.1.2.  Form of SNMP Values ...........................  32\n          8.1.3.  Convenience SNMP Functions ....................  34\n                  8.1.3.1.  getVar() ............................  34\n                  8.1.3.2.  exists() ............................  34\n                  8.1.3.3.  setVar() ............................  35\n                  8.1.3.4.  searchColumn() ......................  36\n                  8.1.3.5.  setRowStatus() ......................  38\n                  8.1.3.6.  createRow() .........................  39\n                  8.1.3.7.  counterRate() .......................  42\n          8.1.4.  General SNMP Functions ........................  44\n                  8.1.4.1.  newPDU() ............................  45\n                  8.1.4.2.  writeVar() ..........................  45\n                  8.1.4.3.  readVar() ...........................  46\n                  8.1.4.4.  snmpSend() ..........................  47\n                  8.1.4.5.  readError() .........................  48\n                  8.1.4.6.  writeBulkParameters() ...............  48\n          8.1.5.  Constants for SNMP Library Functions ..........  49\n    8.2.  Policy Library Functions ..............................  51\n          8.2.1.  elementName() .................................  51\n          8.2.2.  elementAddress() ..............................  51\n          8.2.3.  elementContext() ..............................  52\n          8.2.4.  ec() ..........................................  52\n          8.2.5.  ev() ..........................................  52\n          8.2.6.  roleMatch() ...................................  52\n          8.2.7.  Scratchpad Functions ..........................  53\n          8.2.8.  setScratchpad() ...............................  55\n          8.2.9.  getScratchpad() ...............................  56\n          8.2.10. signalError() .................................  57\n          8.2.11. defer() .......................................  57\n          8.2.12. fail() ........................................  58\n          8.2.13. getParameters() ...............................  58\n    8.3.  Utility Library Functions .............................  59\n          8.3.1.  regexp() ......................................  59",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "          8.3.2.  regexpReplace() ...............................  60\n          8.3.3.  oidlen() ......................................  60\n          8.3.4.  oidncmp() .....................................  60\n          8.3.5.  inSubtree() ...................................  60\n          8.3.6.  subid() .......................................  61\n          8.3.7.  subidWrite() ..................................  61\n          8.3.8.  oidSplice() ...................................  61\n          8.3.9.  parseIndex() ..................................  62\n          8.3.10. stringToDotted() ..............................  63\n          8.3.11. integer() .....................................  64\n          8.3.12. string() ......................................  64\n          8.3.13. type() ........................................  64\n          8.3.14. chr() .........................................  64\n          8.3.15. ord() .........................................  64\n          8.3.16. substr() ......................................  65\n    8.4.  General Functions .....................................  65\n9.  International String Library ................................  65\n    9.1.  stringprep() ..........................................  66\n          9.1.1.  Stringprep Profile ............................  66\n    9.2.  utf8Strlen() ..........................................  67\n    9.3.  utf8Chr() .............................................  68\n    9.4.  utf8Ord() .............................................  68\n    9.5.  utf8Substr() ..........................................  68\n10. Schedule Table ..............................................  69\n11. Definitions .................................................  70\n12. Relationship to Other MIB Modules ........................... 113\n13. Security Considerations ..................................... 114\n14. IANA Considerations ......................................... 117\n15. Acknowledgements ............................................ 118\n16. References .................................................. 118\n    16.1. Normative References .................................. 118\n    16.2. Informative References ................................ 119\nAuthors' Addresses .............................................. 120\nFull Copyright Statement ........................................ 121",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. The Internet-Standard Management Framework",
      "section_title": true,
      "ja": "1.インターネット標準管理フレームワーク"
    },
    {
      "indent": 3,
      "text": "For a detailed overview of the documents that describe the current Internet-Standard Management Framework, please refer to section 7 of RFC 3410 [16].",
      "ja": "現在のインターネット標準管理フレームワークについて説明しているドキュメントの詳細な概要については、RFC 3410 [16]のセクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Managed objects are accessed via a virtual information store, termed the Management Information Base or MIB. MIB objects are generally accessed through the Simple Network Management Protocol (SNMP). Objects in the MIB are defined using the mechanisms defined in the Structure of Management Information (SMI). This memo specifies a MIB module that is compliant to the SMIv2, which is described in STD 58, RFC 2578 [2], STD 58, RFC 2579 [3], and STD 58, RFC 2580 [4].",
      "ja": "管理対象オブジェクトには、管理情報ベースまたはMIBと呼ばれる仮想情報ストアを介してアクセスします。 MIBオブジェクトには、通常、簡易ネットワーク管理プロトコル（SNMP）を介してアクセスします。 MIBのオブジェクトは、管理情報の構造（SMI）で定義されたメカニズムを使用して定義されます。 このメモは、STD 58、RFC 2578 [2]、STD 58、RFC 2579 [3]、およびSTD 58、RFC 2580 [4]で説明されているSMIv2に準拠するMIBモジュールを指定します。"
    },
    {
      "indent": 0,
      "text": "2. Overview",
      "section_title": true,
      "ja": "2.概要"
    },
    {
      "indent": 3,
      "text": "Large IT organizations have developed management strategies to cope with the extraordinarily large scale and complexity of today's networks. In particular, they have tried to configure the network as a whole by describing and implementing high-level business policies, rather than manage device by device, where orders of magnitude more decisions (and mistakes) may be made.",
      "ja": "大規模なIT組織は、今日のネットワークの非常に大規模で複雑な状況に対処するための管理戦略を開発しています。 特に、より多くの決定（およびミス）が行われる可能性のあるデバイスごとにデバイスを管理するのではなく、高レベルのビジネスポリシーを記述して実装することにより、ネットワーク全体を構成しようとしました。"
    },
    {
      "indent": 3,
      "text": "The following are examples of \"business policies\":",
      "ja": "「ビジネスポリシー」の例は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "- All routers will run code version 6.2. - On-site contractors will only be connected to ports that are configured with special security restrictions. - All voice over cable ports in California must provide free local calling. - Apply special forwarding to all ports whose customers have paid for premium service.",
      "ja": "-すべてのルーターでコードバージョン6.2が実行されます。 -現場の請負業者は、特別なセキュリティ制限が設定されたポートにのみ接続されます。 -カリフォルニアのすべてのボイスオーバーケーブルポートは、無料の市内通話を提供する必要があります。 -顧客がプレミアムサービスの料金を支払ったすべてのポートに特別な転送を適用します。"
    },
    {
      "indent": 3,
      "text": "Each of these policies could represent an action applied to hundreds of thousands of variables.",
      "ja": "これらの各ポリシーは、数十万の変数に適用されるアクションを表すことができます。"
    },
    {
      "indent": 3,
      "text": "To automate this practice, customers need software tools that will implement business policies across their networks, as well as standard protocols that will ensure that policies can be applied to all of their devices, regardless of the vendor.",
      "ja": "このプラクティスを自動化するには、ネットワーク全体にビジネスポリシーを実装するソフトウェアツールと、ベンダーに関係なくポリシーをすべてのデバイスに適用できるようにする標準プロトコルが必要です。"
    },
    {
      "indent": 3,
      "text": "This practice is called Policy-Based Management. This document defines managed objects for the Simple Network Management Protocol that are used to distribute policies in a common form throughout the network.",
      "ja": "このプラクティスは、ポリシーベースの管理と呼ばれます。 このドキュメントでは、ネットワーク全体に共通の形式でポリシーを配布するために使用されるSimple Network Management Protocolの管理対象オブジェクトを定義します。"
    },
    {
      "indent": 0,
      "text": "3. Policy-Based Management Architecture",
      "section_title": true,
      "ja": "3.ポリシーベースの管理アーキテクチャ"
    },
    {
      "indent": 3,
      "text": "Policy-based management is the practice of applying management operations globally on all managed elements that share certain attributes.",
      "ja": "ポリシーベースの管理は、特定の属性を共有するすべての管理対象要素に管理操作をグローバルに適用する実践です。"
    },
    {
      "indent": 3,
      "text": "Policies are intended to express a notion of:",
      "ja": "ポリシーは、次の概念を表すことを目的としています。"
    },
    {
      "indent": 6,
      "text": "if (an element has certain characteristics) then (apply an operation to that element)",
      "ja": "if（要素に特定の特性がある）then（操作をその要素に適用する）"
    },
    {
      "indent": 3,
      "text": "Policies take the following normal form:",
      "ja": "ポリシーは次の標準形式を取ります。"
    },
    {
      "indent": 6,
      "text": "if (policyCondition) then (policyAction)",
      "ja": "if（policyCondition）then（policyAction）"
    },
    {
      "indent": 3,
      "text": "A policyCondition is a script that results in a boolean to determine whether an element is a member of a set of elements upon which an action is to be performed.",
      "ja": "policyConditionは、要素がアクションが実行される一連の要素のメンバーであるかどうかを決定するブール値を生成するスクリプトです。"
    },
    {
      "indent": 3,
      "text": "A policyAction is an operation performed on an element or a set of elements.",
      "ja": "policyActionは、要素または要素のセットで実行される操作です。"
    },
    {
      "indent": 3,
      "text": "These policies are most often executed on or near managed devices where the elements live (and thus their characteristics may be easily inspected) and where operations on those elements will be performed.",
      "ja": "これらのポリシーは、ほとんどの場合、要素が存在する管理対象デバイス上またはその近くで実行され（したがって、その特性を簡単に検査できます）、それらの要素に対する操作が実行されます。"
    },
    {
      "indent": 3,
      "text": "A management station is responsible for distributing an organization's policies to all the managed devices in the infrastructure. The pmPolicyTable provides managed objects for representing a policy on a managed device.",
      "ja": "管理ステーションは、組織のポリシーをインフラストラクチャ内のすべての管理対象デバイスに配布する役割を果たします。 pmPolicyTableは、管理対象デバイス上のポリシーを表すための管理対象オブジェクトを提供します。"
    },
    {
      "indent": 3,
      "text": "An element is an instance of a physical or logical entity and is embodied by a group of related MIB variables, such as all the variables for interface 7. This enables policies to be expressed more efficiently and concisely. Elements can also model circuits, CPUs, queues, processes, systems, etc.",
      "ja": "要素は、物理エンティティまたは論理エンティティのインスタンスであり、インターフェイス7のすべての変数など、関連するMIB変数のグループによって具体化されます。これにより、ポリシーをより効率的かつ簡潔に表現できます。 要素は、回路、CPU、キュー、プロセス、システムなどもモデル化できます。"
    },
    {
      "indent": 3,
      "text": "Conceptually, policies are executed in the following manner:",
      "ja": "概念的には、ポリシーは次の方法で実行されます。"
    },
    {
      "indent": 3,
      "text": "for each element for which policyCondition returns true, execute policyAction on that element",
      "ja": "policyConditionがtrueを返す各要素について、その要素でpolicyActionを実行します"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 3,
      "text": "If (interface is fast ethernet) then (apply full-duplex mode) If (interface is access) then (apply security filters) If (circuit w/gold service paid for) then (apply special queuing)",
      "ja": "If（インターフェイスが高速イーサネット）then（全二重モードを適用）If（インターフェイスがアクセス）then（セキュリティフィルタを適用）If（回線w /ゴールドサービスの支払い）then（特別なキューイングを適用）"
    },
    {
      "indent": 3,
      "text": "Each unique combination of policy and element is called an execution context. Within a particular execution context, the phrase 'this element' is often used to refer to the associated element, as most policy operations will be applied to 'this element'. The address of 'this element' contains the object identifier of any attribute of the element, the SNMP context the element was discovered in, and the address of the system on which the element was discovered.",
      "ja": "ポリシーと要素の一意の組み合わせはそれぞれ、実行コンテキストと呼ばれます。 特定の実行コンテキスト内では、ほとんどのポリシー操作が「this element」に適用されるため、「this element」というフレーズが関連する要素を指すためによく使用されます。 「この要素」のアドレスには、要素の属性のオブジェクト識別子、要素が検出されたSNMPコンテキスト、および要素が検出されたシステムのアドレスが含まれます。"
    },
    {
      "indent": 3,
      "text": "Policies can manage elements on the same system:",
      "ja": "ポリシーは、同じシステム上の要素を管理できます。"
    },
    {
      "indent": 9,
      "text": "-----------------------------------------------------\n|                                                   |\n|              Managed System                       |\n|                                                   |\n|                                                   |\n|   ------------------             Managed Elements |\n|   |                |               interfaces     |\n|   | Policy Manager | manages...    circuits       |\n|   |                |               queues         |\n|   ------------------               processes      |\n|                                    ...            |\n|                                                   |\n-----------------------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "or they can manage elements on other systems:",
      "ja": "または、他のシステム上の要素を管理できます。"
    },
    {
      "indent": 5,
      "text": "                                       --------------------------\n                                       |  Managed System        |\n--------------------------             |    Managed Elements    |\n|                        |             |      interfaces        |\n|  Management Station or |             |      circuits          |\n|    Mid-Level Manager   |             |      ...               |\n|                        |             --------------------------\n|   ------------------   | manages...\n|   | Policy Manager |   |             --------------------------\n|   ------------------   |             |  Managed System        |\n|                        |             |    Managed Elements    |\n--------------------------             |      interfaces        |\n                                       |      circuits          |\n                                       |      ...               |\n                                       --------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 44,
      "text": "...",
      "ja": "..."
    },
    {
      "indent": 3,
      "text": "PolicyConditions have the capability of performing comparison operations on SNMP variables, logical expressions, and other functions. Many device characteristics are already defined in MIB Modules and are easy to include in policyCondition expressions (ifType == ethernet, frCircuitCommittedBurst < 128K, etc). However, there are important characteristics that aren't currently in MIB objects, and, worse, it is not current practice to store this information on managed devices. Therefore, this document defines MIB objects for this information. To meet today's needs there are three missing areas: roles, capabilities, and time.",
      "ja": "PolicyConditionsには、SNMP変数、論理式、およびその他の関数で比較操作を実行する機能があります。 多くのデバイス特性はMIBモジュールですでに定義されており、policyCondition式に簡単に含めることができます（ifType == ethernet、frCircuitCommittedBurst <128Kなど）。 ただし、現在MIBオブジェクトにはない重要な特性があり、さらに悪いことに、この情報を管理対象デバイスに保存することは現在の習慣ではありません。 したがって、このドキュメントでは、この情報のMIBオブジェクトを定義します。 今日のニーズを満たすために、役割、能力、および時間という3つの欠落領域があります。"
    },
    {
      "indent": 3,
      "text": "Roles",
      "ja": "役割"
    },
    {
      "indent": 3,
      "text": "A role is an administratively specified characteristic of a managed element. As a selector for policies, it determines the applicability of the policy to a particular managed element.",
      "ja": "ロールは、管理対象要素の管理上指定された特性です。 ポリシーのセレクターとして、特定の管理対象要素に対するポリシーの適用可能性を決定します。"
    },
    {
      "indent": 3,
      "text": "Some examples of roles are political, financial, legal, geographical, or architectural characteristics, typically not directly derivable from information stored on the managed system. For example, \"paid for premium service\" or \"is plugged into a UPS\" are examples of roles, whereas the \"percent utilization of a link\" would not be.",
      "ja": "役割の例としては、政治的、財務的、法的、地理的、または建築的な特性があり、通常は管理対象システムに保存されている情報から直接派生することはできません。 たとえば、「プレミアムサービスの支払い」または「UPSに接続されている」は役割の例ですが、「リンクの利用率」はそうではありません。"
    },
    {
      "indent": 3,
      "text": "Some types of information one would put into a role include the following:",
      "ja": "ロールに入れる情報の種類には次のものがあります。"
    },
    {
      "indent": 3,
      "text": "political - describes the role of a person or group of people, or of a service that a group of people uses. Examples: executive, sales, outside-contractor, customer. If (attached user is executive) then (apply higher bandwidth) If (attached user is outside-contractor) then (restrict access)",
      "ja": "政治的-人または人のグループ、または人のグループが使用するサービスの役割を表します。 例：幹部、営業、外部請負業者、顧客。 If（アタッチされたユーザーがエグゼクティブである場合）then（より高い帯域幅を適用する）if（アタッチされたユーザーが外部契約者である場合）then（アクセスを制限する）"
    },
    {
      "indent": 3,
      "text": "financial/legal - describes what financial consideration was received. Could also include contractual or legal considerations. Examples: paid, gold, free, trial, demo, lifeline. If (gold service paid for) then (apply special queuing)",
      "ja": "財務/法的-受け取った財務的考慮事項について説明します。 契約上または法律上の考慮事項も含めることができます。 例：有料、ゴールド、無料、トライアル、デモ、ライフライン。 （ゴールドサービスの支払い）の場合（特別なキューイングを適用）"
    },
    {
      "indent": 3,
      "text": "geographical - describes the location of an element. Examples: California, Headquarters, insecure conduit. If (interface leaves the building) then (apply special security)",
      "ja": "地理的-要素の場所を説明します。 例：カリフォルニア、本社、不安定な導管。 （インターフェースが建物を離れる）場合、（特別なセキュリティを適用する）"
    },
    {
      "indent": 3,
      "text": "architectural - describes the network architects \"intent\" for an element. Examples: backup, trunk. If (interface is backup) then (set ifAdminStatus = down)",
      "ja": "アーキテクチャ-ネットワークアーキテクトの要素の「意図」を説明します。 例：バックアップ、トランク。 if（インターフェースがバックアップ）if（set ifAdminStatus = down）"
    },
    {
      "indent": 6,
      "text": "Roles in this model are human-defined strings that can be referenced by policy code. The role table in this MIB may be used to assign role strings to elements and to view all role string assignments. Implementation-specific mechanisms may also be used to assign role strings; however, these assignments must be visible in the role table. Multiple roles may be assigned to each element. Because policy code has access to data in MIB objects that represent the current state of the system and (in contrast) role strings are more static, it is recommended that role strings not duplicate information available in MIB objects. Role strings generally should be used to describe information not accessible in MIB objects.",
      "ja": "このモデルのロールは、ポリシーコードで参照できる人間が定義した文字列です。 このMIBの役割テーブルを使用して、要素に役割文字列を割り当て、すべての役割文字列の割り当てを表示できます。 実装固有のメカニズムを使用して、役割文字列を割り当てることもできます。 ただし、これらの割り当ては役割テーブルに表示される必要があります。 各要素に複数のロールを割り当てることができます。 ポリシーコードはシステムの現在の状態を表すMIBオブジェクトのデータにアクセスでき、（対照的に）役割文字列はより静的なので、役割文字列はMIBオブジェクトで利用可能な情報を複製しないことをお勧めします。 通常、ロール文字列は、MIBオブジェクトでアクセスできない情報を記述するために使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "Policy scripts may inspect role assignments to make decisions based on whether an element has a particular role assigned to it.",
      "ja": "ポリシースクリプトは、要素に特定の役割が割り当てられているかどうかに基づいて決定を下すために、役割の割り当てを検査できます。"
    },
    {
      "indent": 6,
      "text": "The pmRoleTable allows a management station to learn what roles exist on a managed system. The management station may choose not to install policies that depend on a role that does not exist on any elements in the system. The management station can then register for notifications of new roles. Upon receipt of a pmNewRoleNotification, it may choose to install new policies that make use of that new role.",
      "ja": "pmRoleTableを使用すると、管理ステーションは管理対象システムに存在する役割を知ることができます。 管理ステーションは、システム内のどの要素にも存在しない役割に依存するポリシーをインストールしないことを選択できます。 管理ステーションは、新しい役割の通知に登録できます。 pmNewRoleNotificationを受信すると、その新しい役割を使用する新しいポリシーをインストールすることを選択できます。"
    },
    {
      "indent": 3,
      "text": "Capabilities",
      "ja": "能力"
    },
    {
      "indent": 6,
      "text": "The capabilities table allows a management station to learn what capabilities exist on a managed system. The management station may choose not to install policies that depend on a capability that does not exist on any elements in the system. The management station can then register for notifications of new capabilities. Upon receipt of a pmNewCapabilityNotification, it may choose to install new policies that make use of that new capability.",
      "ja": "機能テーブルにより、管理ステーションは管理対象システムに存在する機能を知ることができます。 管理ステーションは、システム内のどの要素にも存在しない機能に依存するポリシーをインストールしないことを選択できます。 管理ステーションは、新しい機能の通知に登録できます。 pmNewCapabilityNotificationを受信すると、その新しい機能を使用する新しいポリシーをインストールすることを選択できます。"
    },
    {
      "indent": 3,
      "text": "Time",
      "ja": "時間"
    },
    {
      "indent": 6,
      "text": "Managers may wish to define policies that are intended to apply for certain periods of time. This might mean that a policy is installed and is dormant for a period of time, becomes ready, and then later goes dormant again. Sometimes these time periods will be regular (Monday-Friday 9-5), and sometimes ad hoc. This MIB provides a schedule table that can schedule when a policy is ready and when it is dormant.",
      "ja": "マネージャーは、特定の期間に適用されることを意図したポリシーを定義することを望む場合があります。 これは、ポリシーがインストールされ、一定期間休止状態になり、準備が整い、その後再び休止状態になることを意味する場合があります。 これらの期間は定期的（月曜日から金曜日は9〜5）である場合もあれば、臨時である場合もあります。 このMIBは、ポリシーの準備ができたときと休止状態のときをスケジュールできるスケジュールテーブルを提供します。"
    },
    {
      "indent": 3,
      "text": "A policy manager contains the following:",
      "ja": "ポリシーマネージャーには次のものが含まれます。"
    },
    {
      "indent": 9,
      "text": "-------------------------------------------------------\n| Policy Manager                                      |\n|                                                     |\n|   ----------------------------------------          |\n|   | Agent                                |          |\n|   |                                      |          |\n|   |  ---------------------------------   |          |\n|   |  | Policy Download and Control   |   |          |\n|   |  |   pmPolicyTable               |   |          |\n|   |  |   pmElementTypeRegTable       |   |          |\n|   |  |   pmSchedTable                |   |          |\n|   |  ---------------------------------   |          |\n|   |                                      |          |\n|   |  ---------------------------------   |          |\n|   |  | Policy Environment Control    |   |          |\n|   |  |   pmRoleTable                 |   |          |\n|   |  |   pmCapabilitiesTables        |   |          |\n|   |  ---------------------------------   |          |\n|   |                                      |          |\n|   |  ---------------------------------   |          |\n|   |  | Policy Monitoring             |   |          |\n|   |  |   pmTrackingTables            |   |          |\n|   |  |   pmDebuggingTable            |   |          |\n|   |  ---------------------------------   |          |\n|   ----------------------------------------          |\n|                                                     |\n|   --------------------------------                  |\n|   | Execution Environment        |                  |\n|   |                              |                  |\n|   |  -----------------------     |                  |\n|   |  | Policy Scheduler    |     |                  |\n|   |  -----------------------     |                  |\n|   |  -----------------------     |                  |\n|   |  | Language            |     |                  |\n|   |  -----------------------     |                  |\n|   |  -----------------------     |                  |\n|   |  | Function Library    |     |                  |\n|   |  -----------------------     |                  |\n|   --------------------------------                  |\n-------------------------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Policy-Based Management Execution Environment",
      "section_title": true,
      "ja": "4.ポリシーベースの管理実行環境"
    },
    {
      "indent": 0,
      "text": "4.1. Terminology",
      "section_title": true,
      "ja": "4.1。 用語"
    },
    {
      "indent": 3,
      "text": "Active Schedule - A schedule specifies certain times that it will be considered active. A schedule is active during those times.",
      "ja": "アクティブスケジュール-スケジュールは、アクティブと見なされる特定の時間を指定します。 これらの時間帯はスケジュールがアクティブです。"
    },
    {
      "indent": 3,
      "text": "Valid Policy - A valid policy is a policy that is fully configured and enabled to run. A valid policy may run unless it is linked to a schedule entry that says the policy is not currently active.",
      "ja": "有効なポリシー-有効なポリシーとは、完全に構成され、実行可能になっているポリシーです。 有効なポリシーは、そのポリシーが現在アクティブではないというスケジュールエントリにリンクされていない限り実行できます。"
    },
    {
      "indent": 3,
      "text": "Ready Policy - A ready policy is a valid policy that either has no schedule or is linked to a schedule that is currently active.",
      "ja": "準備完了ポリシー-準備完了ポリシーは、スケジュールがないか、現在アクティブなスケジュールにリンクされている有効なポリシーです。"
    },
    {
      "indent": 3,
      "text": "Precedence Group - Multiple policies can be assigned to a precedence group with the resulting behavior that for each element, of the ready policies that match the condition, only the one with the highest precedence value will be active. For example, if there is a default bronze policy that applies to any interface and a special policy for gold interfaces, the higher precedence of the gold policy will ensure that it is run on gold ports and that the bronze policy isn't.",
      "ja": "優先グループ-複数のポリシーを優先グループに割り当てることができます。その結果、各要素について、条件に一致する準備ができたポリシーのうち、最も高い優先値を持つポリシーのみがアクティブになります。 たとえば、任意のインターフェイスに適用されるデフォルトのブロンズポリシーとゴールドインターフェイスの特別なポリシーがある場合、ゴールドポリシーの優先順位が高いため、ゴールドポートで実行され、ブロンズポリシーは実行されません。"
    },
    {
      "indent": 3,
      "text": "Active Execution Context - An active execution context is a pairing of a ready policy with an element that matches the element type filter and the policy condition. If there are multiple policies in the precedence group, it is also necessary that no higher precedence policy in the group match the policy condition.",
      "ja": "アクティブな実行コンテキスト-アクティブな実行コンテキストは、準備完了ポリシーと、要素タイプフィルターおよびポリシー条件に一致する要素とのペアです。 優先グループに複数のポリシーがある場合、グループ内のより高い優先ポリシーがポリシー条件に一致しないことも必要です。"
    },
    {
      "indent": 3,
      "text": "Run-Time Exception (RTE) - A run-time exception is a fatal error caused in language or function processing. If, during the invocation of a script, a run-time exception occurs, execution of that script is immediately terminated. If a policyCondition experiences a run-time exception while processing an element, the element is not matched by the condition and the associated action will not be run on that element. A run-time exception can cause an entry to be added to the pmDebuggingTable and will be reflected in the pmTrackingPEInfo object.",
      "ja": "実行時例外（RTE）-実行時例外は、言語または関数の処理で発生する致命的なエラーです。 スクリプトの呼び出し中にランタイム例外が発生した場合、そのスクリプトの実行はすぐに終了します。 policyConditionでエレメントの処理中にランタイム例外が発生した場合、エレメントは条件と一致せず、関連付けられたアクションはそのエレメントで実行されません。 ランタイム例外により、エントリがpmDebuggingTableに追加され、pmTrackingPEInfoオブジェクトに反映されます。"
    },
    {
      "indent": 0,
      "text": "4.2. Execution Environment - Elements of Procedure",
      "section_title": true,
      "ja": "4.2。 実行環境-手順の要素"
    },
    {
      "indent": 3,
      "text": "There are several steps performed in order to execute policies in this environment:",
      "ja": "この環境でポリシーを実行するには、いくつかの手順を実行します。"
    },
    {
      "indent": 6,
      "text": "- Element Discovery - Element Filtering - Policy Enforcement",
      "ja": "-要素の発見-要素のフィルタリング-ポリシーの施行"
    },
    {
      "indent": 0,
      "text": "4.3. Element Discovery",
      "section_title": true,
      "ja": "4.3。 エレメントディスカバリー"
    },
    {
      "indent": 3,
      "text": "An element is an instance of a physical or logical entity. Examples of elements include interfaces, circuits, queues, CPUs, and processes. Sometimes various attributes of an entity will be described through tables in several standard and proprietary MIB Modules. As long as the indexing is consistent between these tables, the entity can be modeled as one element. For example, the ifTable and the dot3Stats table both contain attributes of interfaces and share the same index (ifIndex), therefore they can be modeled as one element type.",
      "ja": "要素は、物理エンティティまたは論理エンティティのインスタンスです。 要素の例には、インターフェイス、回路、キュー、CPU、およびプロセスが含まれます。 エンティティのさまざまな属性は、いくつかの標準および独自のMIBモジュールのテーブルを通じて記述される場合があります。 これらのテーブル間でインデックス付けが一貫している限り、エンティティは1つの要素としてモデル化できます。 たとえば、ifTableとdot3Statsテーブルは両方ともインターフェイスの属性を含み、同じインデックス（ifIndex）を共有するため、1つの要素タイプとしてモデル化できます。"
    },
    {
      "indent": 3,
      "text": "The Element Type Registration table allows the manager to learn what element types are being managed by the system and to register new types, if necessary. An element type is registered by providing the OID of an SNMP object (i.e., without the instance). Each SNMP instance that exists under that object is a distinct element. The index part of the discovered OID will be supplied to policy conditions and actions so that this code can inspect and configure the element. The agent can determine the index portion of discovered OIDs based on the length of the pmElementTypeRegOIDPrefix for the portion of the MIB that is being retrieved. For example, if the OIDPrefix is 'ifEntry', which has 9 subids, the index starts on the 11th subid (skipping the subidentifier for the column; e.g., ifSpeed).",
      "ja": "エレメントタイプ登録テーブルを使用すると、マネージャはシステムで管理されているエレメントタイプを学習し、必要に応じて新しいタイプを登録できます。 要素タイプは、SNMPオブジェクトのOIDを提供することにより登録されます（つまり、インスタンスなし）。 そのオブジェクトの下に存在する各SNMPインスタンスは、個別の要素です。 検出されたOIDのインデックス部分は、このコードが要素を検査および構成できるように、ポリシー条件およびアクションに提供されます。 エージェントは、取得されるMIBの部分のpmElementTypeRegOIDPrefixの長さに基づいて、検出されたOIDのインデックス部分を決定できます。 たとえば、OIDPrefixが9つのサブIDを持つ「ifEntry」である場合、インデックスは11番目のサブIDで始まります（列のサブ識別子をスキップします; ifSpeedなど）。"
    },
    {
      "indent": 3,
      "text": "For each element that is discovered, the policy condition is called with the element's name as an argument to see whether the element is a member of the set the policy acts upon.",
      "ja": "検出された各要素について、その要素の名前が引数としてポリシー条件が呼び出され、その要素がポリシーの対象となるセットのメンバーであるかどうかが確認されます。"
    },
    {
      "indent": 3,
      "text": "Note that agents may automatically configure entries in this table for frequently used element types (interfaces, circuits, etc.). In particular, it may configure elements for which discovery is optimized in one or both of the following ways:",
      "ja": "エージェントは、頻繁に使用される要素タイプ（インターフェイス、回線など）に対してこのテーブルのエントリを自動的に構成する場合があることに注意してください。 特に、次のいずれかまたは両方の方法で検出が最適化される要素を構成できます。"
    },
    {
      "indent": 3,
      "text": "1. The agent may discover elements by scanning internal data structures as opposed to issuing local SNMP requests. It is possible to recreate the exact semantics described in this table even if local SNMP requests are not issued.",
      "ja": "1.エージェントは、ローカルSNMP要求を発行するのではなく、内部データ構造をスキャンして要素を検出する場合があります。 ローカルSNMP要求が発行されない場合でも、この表で説明されている正確なセマンティクスを再作成することは可能です。"
    },
    {
      "indent": 3,
      "text": "2. The agent may receive asynchronous notification of new elements (for example, \"card inserted\") and use that information to create elements instantly rather than through polling. A similar feature might be available for the deletion of elements.",
      "ja": "2.エージェントは、新しい要素（「カード挿入」など）の非同期通知を受信し、その情報を使用して、ポーリングではなく即座に要素を作成できます。 同様の機能が要素の削除に使用できる場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that upon restart, the disposition of agent-installed entries is described by the pmPolicyStorageType object.",
      "ja": "再起動時に、エージェントがインストールしたエントリの処理はpmPolicyStorageTypeオブジェクトによって記述されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A special element type \"0.0\" represents the \"system element\". \"0.0\" represents the single instance of the system itself and provides an execution context for policies to operate on \"the system\" and on MIB objects modeled as scalars. For example, \"0.0\" gives an execution context for policy-based selection of the operating system code version (likely modeled as a scalar MIB object). The element type \"0.0\" always exists. As a consequence, no actual discovery will take place and the pmElementTypeRegMaxLatency object will have no effect for the \"0.0\" element type. However, if the \"0.0\" element type is not registered in the table, policies will not be executed on the \"0.0\" element.",
      "ja": "特別な要素タイプ「0.0」は「システム要素」を表します。 「0.0」はシステム自体の単一インスタンスを表し、「システム」およびスカラーとしてモデル化されたMIBオブジェクトで動作するポリシーの実行コンテキストを提供します。 たとえば、「0.0」は、オペレーティングシステムのコードバージョン（スカラーMIBオブジェクトとしてモデル化されている可能性が高い）のポリシーベースの選択の実行コンテキストを提供します。 要素タイプ「0.0」は常に存在します。 結果として、実際の検出は行われず、pmElementTypeRegMaxLatencyオブジェクトは「0.0」要素タイプには影響しません。 ただし、「0.0」要素タイプがテーブルに登録されていない場合、「0.0」要素に対してポリシーは実行されません。"
    },
    {
      "indent": 3,
      "text": "If the agent is discovering elements by polling, it should check for new elements no less frequently than pmElementTypeRegMaxLatency would dictate. When an element is first discovered, all policyConditions are run immediately, and policyConditions that match will have the associated policyAction run immediately. Subsequently, the policyCondition will be run regularly for the element, with no more than pmPolicyConditionMaxLatency milliseconds elapsing between each invocation. Note that if an implementation has the ability to be alerted immediately when a particular type of element is created, it is urged to discover that type of element in this fashion rather than through polling, resulting in immediate configuration of the discovered element.",
      "ja": "エージェントがポーリングによって要素を検出している場合、pmElementTypeRegMaxLatencyが指示するより頻繁に新しい要素をチェックする必要があります。 要素が最初に検出されると、すべてのpolicyConditionsがすぐに実行され、一致するpolicyConditionsに関連付けられたpolicyActionがすぐに実行されます。 その後、policyConditionは要素に対して定期的に実行され、各呼び出しの間にpmPolicyConditionMaxLatencyミリ秒を超えないようにします。 特定のタイプの要素が作成されるとすぐに実装にアラートを出す機能がある場合、ポーリングではなくこの方法でそのタイプの要素を検出するように促され、検出された要素の即時設定が行われることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Implementation Notes",
      "section_title": true,
      "ja": "4.3.1。 実装ノート"
    },
    {
      "indent": 3,
      "text": "Note that although the external behavior of this registration process is defined in terms of the walking of MIB tables, implementation strategies may differ. For example, commonly used element types (such as interface) may have purpose-built element discovery capability built-in and advertised to managers through an entry in the pmElementTypeRegTable.",
      "ja": "この登録プロセスの外部動作はMIBテーブルのウォークに関して定義されていますが、実装戦略は異なる場合があることに注意してください。 たとえば、よく使用される要素タイプ（インターフェイスなど）には、専用の要素検出機能が組み込まれ、pmElementTypeRegTableのエントリを通じてマネージャーにアドバタイズされる場合があります。"
    },
    {
      "indent": 3,
      "text": "Before registering an element type, a manager is responsible for inspecting the table to see whether it is already registered (either by the agent or by another manager). Note that entries that differ only in the last subid (which specifies which object is an entry) are effectively duplicates and should be treated as such by the manager.",
      "ja": "要素タイプを登録する前に、マネージャーはテーブルを検査して、すでに登録されているかどうかを確認します（エージェントまたは別のマネージャーによって）。 最後のサブID（エントリであるオブジェクトを指定する）のみが異なるエントリは、事実上重複しているため、マネージャによってそのように扱われる必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The system that implements the Policy-Based Management MIB may not have knowledge of the format of object identifiers in other MIB Modules. Therefore it is inappropriate for it to check these OIDs for errors. It is the responsibility of the management station to register well-formed object identifiers. For example, if an extra sub-identifier is supplied when the ifTable is registered, no elements will be discovered. Similarly, if a sub-identifier is missing, every element will be discovered numerous times (once per column) and none of the element addresses will be well formed.",
      "ja": "ポリシーベースの管理MIBを実装するシステムは、他のMIBモジュールのオブジェクト識別子の形式に関する知識を持っていない場合があります。 したがって、これらのOIDのエラーをチェックすることは不適切です。 整形式のオブジェクト識別子を登録するのは管理ステーションの責任です。 たとえば、ifTableの登録時に追加のサブ識別子が提供された場合、要素は検出されません。 同様に、サブ識別子が欠落している場合、すべての要素が何度も（列ごとに1回）検出され、要素のアドレスはいずれも適切に形成されません。"
    },
    {
      "indent": 0,
      "text": "4.4. Element Filtering",
      "section_title": true,
      "ja": "4.4。 要素のフィルタリング"
    },
    {
      "indent": 3,
      "text": "The first step in executing a policy is to see whether the policy is ready to run based on its schedule. If the pmPolicySchedule object is equal to zero, there is no schedule defined, and the policy is always ready. If the pmPolicySchedule object is non-zero, then the policy is ready only if the referenced schedule group contains at least one valid schedule entry that is active at the current time.",
      "ja": "ポリシーを実行する最初のステップは、スケジュールに基づいてポリシーを実行する準備ができているかどうかを確認することです。 pmPolicyScheduleオブジェクトがゼロに等しい場合、スケジュールは定義されておらず、ポリシーは常に準備ができています。 pmPolicyScheduleオブジェクトがゼロ以外の場合、参照されるスケジュールグループに、現在アクティブな少なくとも1つの有効なスケジュールエントリが含まれている場合にのみ、ポリシーは準備完了です。"
    },
    {
      "indent": 3,
      "text": "If the policy is ready, the next step in executing a policy is to see which elements match the policy condition. The policy condition is called once for each element and runs to completion. The element's name is the only argument that is passed to the condition code for each invocation. No state is remembered within the policy script from the previous invocation of 'this element' or from the previous invocation of the policy condition, except for state accessible through library functions. Two notable examples of these are the scratchpad functions, which explicitly provide for storing state, and the SNMP functions, which can store state in local or remote MIB objects. If any run-time exception occurs, the condition will terminate immediately for 'this element'. If the condition returns non-zero, the corresponding policy action will be executed for 'this element'.",
      "ja": "ポリシーの準備ができている場合、ポリシー実行の次のステップは、どの要素がポリシー条件に一致するかを確認することです。 ポリシー条件は、要素ごとに1回呼び出され、完了するまで実行されます。 要素の名前は、各呼び出しの条件コードに渡される唯一の引数です。 ライブラリ関数を介してアクセス可能な状態を除き、ポリシースクリプト内では、「この要素」の前回の呼び出しまたはポリシー条件の前回の呼び出しからの状態は記憶されません。 これらの2つの注目すべき例は、状態の保存を明示的に提供するスクラッチパッド機能と、ローカルまたはリモートMIBオブジェクトに状態を保存できるSNMP機能です。 実行時例外が発生すると、「この要素」の条件はすぐに終了します。 条件がゼロ以外を返す場合、対応するポリシーアクションが「この要素」に対して実行されます。"
    },
    {
      "indent": 3,
      "text": "If an element matches a condition and it had not matched that condition the last time it was checked (or if it is a newly discovered element), the associated policyAction will be executed immediately. If the element had matched the condition at the last check, it will remain in the set of elements whose policyAction will be run within the policyActionMaxLatency.",
      "ja": "要素が条件に一致し、最後にチェックされたときにその条件に一致しなかった場合（または新しく検出された要素である場合）、関連するpolicyActionがすぐに実行されます。 要素が最後のチェックで条件に一致した場合、policyActionMaxLatency内でpolicyActionが実行される要素のセットに残ります。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Implementation Notes",
      "section_title": true,
      "ja": "4.4.1。 実装ノート"
    },
    {
      "indent": 3,
      "text": "Whether policy conditions are multi-tasked is an implementation-dependent matter. Each condition/element combination is conceptually its own process and can be scheduled sequentially, or two or more could be run simultaneously.",
      "ja": "ポリシー条件がマルチタスクかどうかは、実装に依存する問題です。 各条件/要素の組み合わせは、概念的には独自のプロセスであり、順次スケジュールすることも、2つ以上を同時に実行することもできます。"
    },
    {
      "indent": 0,
      "text": "4.5. Policy Enforcement",
      "section_title": true,
      "ja": "4.5。 ポリシーの施行"
    },
    {
      "indent": 3,
      "text": "For each element that has returned non-zero from the policy condition, the corresponding policy action is called. The element's name is the only argument that is passed to the policy action for each invocation. Except for state accessible from library functions, no state is remembered from the policy condition evaluation, or from the previous condition/action invocation of 'this element' or from the previous invocation of the policy condition or action on any other element. If any run-time exception occurs, the action will terminate immediately for 'this element'.",
      "ja": "ポリシー条件からゼロ以外を返した各要素に対して、対応するポリシーアクションが呼び出されます。 要素の名前は、呼び出しごとにポリシーアクションに渡される唯一の引数です。 ライブラリ関数からアクセス可能な状態を除き、ポリシー条件の評価、または「この要素」の以前の条件/アクション呼び出し、または他の要素のポリシー条件またはアクションの以前の呼び出しから状態は記憶されません。 実行時例外が発生すると、「この要素」のアクションはすぐに終了します。"
    },
    {
      "indent": 0,
      "text": "4.5.1. Implementation Notes",
      "section_title": true,
      "ja": "4.5.1。 実装ノート"
    },
    {
      "indent": 3,
      "text": "How policy actions are multi-tasked is an implementation-dependent matter. Each condition/element combination is conceptually its own process and can be scheduled sequentially, or two or more could be run simultaneously.",
      "ja": "ポリシーアクションがマルチタスク化される方法は、実装に依存する問題です。 各条件/要素の組み合わせは、概念的には独自のプロセスであり、順次スケジュールすることも、2つ以上を同時に実行することもできます。"
    },
    {
      "indent": 0,
      "text": "5. The PolicyScript Language",
      "section_title": true,
      "ja": "5. PolicyScript言語"
    },
    {
      "indent": 3,
      "text": "Policy conditions and policy actions are expressed with the PolicyScript language. The PolicyScript language is designed to be a small interpreted language that is simple to understand and implement; it is designed to be appropriate for writing small scripts that make up policy conditions and actions.",
      "ja": "ポリシー条件とポリシーアクションは、PolicyScript言語で表現されます。 PolicyScript言語は、理解および実装が簡単な小さなインタープリター言語になるように設計されています。 ポリシーの条件とアクションを構成する小さなスクリプトを作成するのに適しているように設計されています。"
    },
    {
      "indent": 3,
      "text": "PolicyScript is intended to be familiar to programmers that know one of several common languages, including Perl and C. Nominally, policyScript is a subset of the C language; however, it was desirable to have access to C++'s operator overloading (solely to aid in documenting the language). Therefore, PolicyScript is defined formally as a subset of the C++ language in which many of the operators are overloaded as part of the \"var\" class. Note, however, that a PolicyScript program cannot further overload operators, as the syntax to specify overloading is not part of the PolicyScript syntax. A subset was used to provide for easy development of low-cost interpreters of PolicyScript and to take away language constructs that are peculiar to the C/C++ languages. For example, it is expected that both C and Perl programmers will understand the constructs allowed in PolicyScript.",
      "ja": "PolicyScriptは、PerlやCなど、いくつかの一般的な言語の1つを知っているプログラマーになじみやすいように設計されています。 ただし、C ++の演算子のオーバーロードにアクセスできることが望ましい（言語の文書化を支援するためだけに）。 したがって、PolicyScriptは、多くの演算子が「var」クラスの一部としてオーバーロードされるC ++言語のサブセットとして正式に定義されています。 ただし、過負荷を指定する構文はPolicyScript構文の一部ではないため、PolicyScriptプログラムは演算子をさらに過負荷にできないことに注意してください。 サブセットを使用して、PolicyScriptの低コストインタープリターを簡単に開発し、C / C ++言語に固有の言語構造を取り除くことができました。 たとえば、CとPerlの両方のプログラマーがPolicyScriptで許可されている構造を理解することが期待されます。"
    },
    {
      "indent": 3,
      "text": "Some examples of the C/C++ features that are not available are function definitions, pointer variables, structures, enums, typedefs, floating point and pre-processor functions (except for comments).",
      "ja": "利用できないC / C ++機能の例には、関数定義、ポインター変数、構造体、列挙、typedef、浮動小数点、およびプリプロセッサー関数（コメントを除く）があります。"
    },
    {
      "indent": 3,
      "text": "This language is formally defined as a subset of ISO C++ [10] but only allows constructs that may be expressed in the Extended Backus-Naur Form (EBNF) documented here. This is because although EBNF doesn't fully specify syntactical rules (it allows constructs that are invalid) and doesn't specify semantic rules, it can successfully be used to define the subset of the language that is required for conformance to this specification. Unless explicitly described herein, the meaning of any construct expressed in the EBNF can be found by reference to the ISO C++ standard.",
      "ja": "この言語はISO C ++ [10]のサブセットとして正式に定義されていますが、ここで説明されている拡張バッカスナウア形式（EBNF）で表現できる構造のみを許可します。 これは、EBNFは構文規則を完全に指定せず（無効な構造を許可する）、セマンティック規則を指定しないが、この仕様への準拠に必要な言語のサブセットを定義するために正常に使用できるためです。 本書で明示的に説明されていない限り、EBNFで表現されたコンストラクトの意味は、ISO C ++標準を参照することで見つけることができます。"
    },
    {
      "indent": 3,
      "text": "The use of comments and newlines are allowed and encouraged in order\nto promote readability of PolicyScript code.  Comments begin with\n'/*' and end with '*/' or begin with '//' and go until the end of the\nline.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "One subset is not expressible in the EBNF syntax: all variables within an instance of a PolicyScript script are within the same scope. In other words, variables defined in a block delimited with '{' and '}' are not in a separate scope from variables in the enclosing block.",
      "ja": "1つのサブセットはEBNF構文では表現できません。PolicyScriptスクリプトのインスタンス内のすべての変数は同じスコープ内にあります。 言い換えると、「{」と「}」で区切られたブロックで定義された変数は、囲んでいるブロックの変数とは別のスコープにありません。"
    },
    {
      "indent": 3,
      "text": "PolicyScript code must be expressed in the ASCII character set.",
      "ja": "PolicyScriptコードは、ASCII文字セットで表現する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the EBNF used here, terminals are character set members (singly or in a sequence) that are enclosed between two single-quote characters or described as a phrase between '<' and '>' characters. Nonterminals are a sequence of letters and underscore characters. A colon (:) following a nonterminal introduces its definition, a production. In a production, a '|' character separates alternatives. The '(' and ')' symbols group the enclosed items. The '[' and ']' symbols indicate that the enclosed items are optional. A '?' symbol following an item indicates that the item is optional. A '*' symbol following an item indicates that the item is repeated zero, one, or more times. A '+' symbol following an item indicates that the item is repeated one or more times. The symbol '--' begins a comment that ends at the end of the line.",
      "ja": "ここで使用されるEBNFでは、端末は2つの一重引用符で囲まれた文字セットメンバー（単独またはシーケンス）であるか、「<」と「>」文字の間のフレーズとして記述されます。 非終端記号は、文字とアンダースコア文字のシーケンスです。 非終端記号に続くコロン（:)は、その定義であるプロダクションを導入します。 プロダクションでは、「|」 文字は選択肢を区切ります。 「（」および「）」記号は、囲まれたアイテムをグループ化します。 「[」および「]」記号は、囲まれた項目がオプションであることを示します。 「？」 アイテムに続く記号は、そのアイテムがオプションであることを示します。 アイテムに続く「*」記号は、アイテムが0回、1回、またはそれ以上繰り返されることを示します。 アイテムに続く「+」記号は、アイテムが1回以上繰り返されることを示します。 記号「-」は、行末で終わるコメントを開始します。"
    },
    {
      "indent": 0,
      "text": "5.1. Formal Definition",
      "section_title": true,
      "ja": "5.1。 正式な定義"
    },
    {
      "indent": 3,
      "text": "The PolicyScript language follows the syntax and semantics of ISO C++ [10], but is limited to that which can be expressed in the EBNF below.",
      "ja": "PolicyScript言語は、ISO C ++ [10]の構文とセマンティクスに従いますが、以下のEBNFで表現できるものに制限されています。"
    },
    {
      "indent": 3,
      "text": "The following keywords are reserved words and cannot be used in any policy script. This prevents someone from using a common keyword in another language as an identifier in a script, thereby confusing the meaning of the script. The reserved words are:",
      "ja": "次のキーワードは予約語であり、ポリシースクリプトでは使用できません。 これにより、誰かが別の言語の共通キーワードをスクリプトの識別子として使用することを防ぎ、それによってスクリプトの意味を混乱させます。 予約語は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "auto, case, char, const, default, do, double, enum, extern, float, goto, inline, int, long, register, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, and volatile.",
      "ja": "auto、case、char、const、default、do、double、enum、extern、float、goto、inline、int、long、register、short、signed、sizeof、static、struct、switch、typedef、union、unsigned、void、 揮発性。"
    },
    {
      "indent": 3,
      "text": "Any syntax error, use of a reserved keyword, reference to an unknown identifier, improper number of function arguments, error in coercing an argument to the proper type, exceeding local limitations on string length, or exceeding local limitations on the total amount of storage used by local variables will cause an RTE.",
      "ja": "構文エラー、予約済みキーワードの使用、未知の識別子への参照、不適切な数の関数引数、適切な型への引数の強制エラー、文字列の長さのローカル制限の超過、または使用されるストレージの合計量のローカル制限の超過 ローカル変数によってRTEが発生します。"
    },
    {
      "indent": 3,
      "text": "PolicyScript permits comments using the comment delimiters, '/*' to\n'*/', or the start of comment symbol '//'.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Lexical Grammar",
      "ja": "-字句文法"
    },
    {
      "indent": 3,
      "text": "letter: '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'",
      "ja": "レター： '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | 「A」| 「B」| 'C' | 'D' | 「E」| 'F' | 「G」| 'H' | 「私」| 「J」| 'K' | 'L' | 「M」| 'N' | 「O」| 「P」| 「Q」| 'R' | 「S」| 'T' | 「U」| 「V」| 「W」| 'X' | 「Y」| 「Z」"
    },
    {
      "indent": 3,
      "text": "digit: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'",
      "ja": "桁： '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | 「9」"
    },
    {
      "indent": 3,
      "text": "non_zero: '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'",
      "ja": "non_zero： '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | 「9」"
    },
    {
      "indent": 3,
      "text": "oct_digit: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'",
      "ja": "oct_digit： '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'"
    },
    {
      "indent": 3,
      "text": "hex_digit: digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'",
      "ja": "hex_digit：数字| 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 「A」| 「B」| 'C' | 'D' | 「E」| 「F」"
    },
    {
      "indent": 3,
      "text": "escape_seq: '\\'' | '\\\"' | '\\?' | '\\\\' | '\\a' | '\\b' | '\\f' | '\\n' | '\\r' | '\\t' | '\\v' | '\\' oct_digit+ | '\\x' hex_digit+",
      "ja": "escape_seq： '\\' '| '\\ \"' | '\\？' | '\\\\' | '\\ a' | '\\ b' | '\\ f' | '\\ n' | '\\ r' | '\\ t' | '\\ v' | '\\' oct_digit + | '\\ x' hex_digit +"
    },
    {
      "indent": 3,
      "text": "non_quote: Any character in the ASCII character set except single quote ('), double quote (\"), backslash ('\\'), or newline.",
      "ja": "non_quote：単一引用符（ '）、二重引用符（ \"）、バックスラッシュ（' \\ '）、または改行を除くASCII文字セットの任意の文字。"
    },
    {
      "indent": 3,
      "text": "c_char: non_quote | '\"' | escape_seq",
      "ja": "c_char：non_quote | '\"' | escape_seq"
    },
    {
      "indent": 3,
      "text": "string_literal: '\"' s_char* '\"'",
      "ja": "string_literal： '\"' s_char * '\"'"
    },
    {
      "indent": 3,
      "text": "s_char: non_quote | ''' | escape_seq",
      "ja": "s_char：non_quote | '' '| escape_seq"
    },
    {
      "indent": 3,
      "text": "char_constant: ''' c_char '''",
      "ja": "char_constant： '' 'c_char' ''"
    },
    {
      "indent": 3,
      "text": "decimal_constant: non_zero digit* octal_constant: '0' oct_digit*",
      "ja": "decimal_constant：ゼロ以外の数字* octal_constant： '0' oct_digit *"
    },
    {
      "indent": 3,
      "text": "hex_constant: ( '0x' | '0X' ) hex_digit+",
      "ja": "hex_constant：（ '0x' | '0X'）hex_digit +"
    },
    {
      "indent": 3,
      "text": "integer_constant: decimal_constant | octal_constant | hex_constant",
      "ja": "integer_constant：decimal_constant | octal_constant | hex_constant"
    },
    {
      "indent": 3,
      "text": "identifier: letter ( letter | digit )*",
      "ja": "識別子：文字（文字|数字）*"
    },
    {
      "indent": 0,
      "text": "-- Phrase Structure Grammar",
      "ja": "-フレーズ構造文法"
    },
    {
      "indent": 3,
      "text": "-- Expressions",
      "ja": "-式"
    },
    {
      "indent": 3,
      "text": "primary_expr: identifier | integer_constant | char_constant | string_literal | '(' expression ')'",
      "ja": "primary_expr：識別子| integer_constant | char_constant | string_literal | '（'式 '）'"
    },
    {
      "indent": 3,
      "text": "postfix_expr: primary_expr | identifier '(' argument_expression_list? ')' | postfix_expr '++' | postfix_expr '--' | postfix_expr '[' expression ']'",
      "ja": "postfix_expr：primary_expr | 識別子 '（' argument_expression_list？ '）' | postfix_expr '++' | postfix_expr '-' | postfix_expr '['式 ']'"
    },
    {
      "indent": 3,
      "text": "argument_expression_list: assignment_expr | argument_expression_list ',' assignment_expr",
      "ja": "argument_expression_list：assignment_expr | argument_expression_list '、' assignment_expr"
    },
    {
      "indent": 3,
      "text": "unary_expr: postfix_expr | unary_op unary_expr",
      "ja": "unary_expr：postfix_expr | unary_op unary_expr"
    },
    {
      "indent": 3,
      "text": "unary_op: '+' | '-' | '~' | '!' | '++' | '--'",
      "ja": "unary_op： '+' | '-' | '〜' | 「！」 | '++' | 「-」"
    },
    {
      "indent": 3,
      "text": "binary_expr: unary_expr | binary_expr binary_op unary_expr",
      "ja": "binary_expr：unary_expr | binary_expr binary_op unary_expr"
    },
    {
      "indent": 3,
      "text": "binary_op: '||' | '&&' | '|' | '^' | '&' | '!=' | '==' | '>=' | '<=' | '>' | '<' | '>>' | '<<' | '-' | '+' | '%' | '/' | '*'",
      "ja": "binary_op： '||' | '&&' | 「|」 | '^' | '＆' | '！=' | '==' | '> =' | '<=' | '>' | '<' | '>>' | '<<' | '-' | '+' | '％' | '/' | 「*」"
    },
    {
      "indent": 3,
      "text": "assignment_expr: binary_expr | unary_expr assignment_op assignment_expr",
      "ja": "assignment_expr：binary_expr | unary_expr assignment_op assignment_expr"
    },
    {
      "indent": 3,
      "text": "assignment_op: '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|='",
      "ja": "assignment_op： '=' | '* =' | '/ =' | '％=' | '+ =' | '-=' | '<< =' | '>> =' | '＆=' | '^ =' | '| ='"
    },
    {
      "indent": 3,
      "text": "expression: assignment_expr | expression ',' assignment_expr",
      "ja": "式：assignment_expr | 式 '、' assignment_expr"
    },
    {
      "indent": 3,
      "text": "-- Declarations",
      "ja": "-宣言"
    },
    {
      "indent": 3,
      "text": "declaration: 'var' declarator_list ';' declarator_list: init_declarator | declarator_list ',' init_declarator",
      "ja": "宣言： 'var' declarator_list ';' declarator_list：init_declarator | declarator_list '、' init_declarator"
    },
    {
      "indent": 3,
      "text": "init_declarator: identifier [ '=' assignment_expr ]",
      "ja": "init_declarator：識別子['=' assignment_expr]"
    },
    {
      "indent": 3,
      "text": "-- Statements",
      "ja": "-ステートメント"
    },
    {
      "indent": 3,
      "text": "statement: declaration | compound_statement | expression_statement | selection_statement | iteration_statement | jump_statement",
      "ja": "ステートメント：宣言| compound_statement | expression_statement | selection_statement | iteration_statement | jump_statement"
    },
    {
      "indent": 3,
      "text": "compound_statement: '{' statement* '}'",
      "ja": "compound_statement： '{'ステートメント* '}'"
    },
    {
      "indent": 3,
      "text": "expression_statement: expression? ';'",
      "ja": "expression_statement：expression？ 「;」"
    },
    {
      "indent": 3,
      "text": "selection_statement: 'if' '(' expression ')' statement | 'if' '(' expression ')' statement 'else' statement",
      "ja": "selection_statement： 'if' '（' expression '）'ステートメント| 'if' '（' expression '）'ステートメント 'else'ステートメント"
    },
    {
      "indent": 3,
      "text": "iteration_statement: 'while' '(' expression ')' statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement",
      "ja": "iteration_statement： 'while' '（' expression '）'ステートメント| 'for' '（' expression？ ';' expression？ ';' expression？ '）'ステートメント"
    },
    {
      "indent": 3,
      "text": "jump_statement: 'continue' ';' | 'break' ';' | 'return' expression? ';'",
      "ja": "jump_statement： 'continue' ';' | 'break' ';' | 「戻り」式？ 「;」"
    },
    {
      "indent": 3,
      "text": "-- Root production",
      "ja": "-ルート生産"
    },
    {
      "indent": 3,
      "text": "PolicyScript: statement*",
      "ja": "PolicyScript：ステートメント*"
    },
    {
      "indent": 0,
      "text": "5.2. Variables",
      "section_title": true,
      "ja": "5.2。 変数"
    },
    {
      "indent": 3,
      "text": "To promote shorter scripts and ease in writing them, PolicyScript provides a loosely typed data class, \"var\", that can store both integer and string values. The native C++ types (char, int, etc.) are thus unnecessary and have not been carried into the subset that comprises this language. The semantics of the \"var\" type are modeled after those of ECMAScript[17].",
      "ja": "短いスクリプトを促進し、それらの記述を容易にするために、PolicyScriptは、整数値と文字列値の両方を格納できる、緩やかに型指定されたデータクラス「var」を提供します。 したがって、ネイティブC ++型（char、intなど）は不要であり、この言語を構成するサブセットに組み込まれていません。 「var」タイプのセマンティクスは、ECMAScript [17]のセマンティクスをモデルにしています。"
    },
    {
      "indent": 6,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 9,
      "text": "var number = 0, name = \"IETF\";",
      "ja": "変数番号= 0、名前= \"IETF\";"
    },
    {
      "indent": 3,
      "text": "This language will be executed in an environment where the following typedef is declared. (Note that this typedef will not be visible in the policyCondition or policyAction code.)",
      "ja": "この言語は、次のtypedefが宣言されている環境で実行されます。 （このtypedefは、policyConditionまたはpolicyActionコードでは表示されないことに注意してください。）"
    },
    {
      "indent": 6,
      "text": "typedef ... var;",
      "ja": "typedef ... var;"
    },
    {
      "indent": 3,
      "text": "Although this declaration is expressed here as a typedef, the 'typedef' keyword itself is not available to be used in PolicyScript code.",
      "ja": "この宣言はここではtypedefとして表されていますが、「typedef」キーワード自体をPolicyScriptコードで使用することはできません。"
    },
    {
      "indent": 0,
      "text": "5.2.1. The Var Class",
      "section_title": true,
      "ja": "5.2.1。 Varクラス"
    },
    {
      "indent": 3,
      "text": "A value is an entity that takes on one of two types: string or integer.",
      "ja": "値は、文字列または整数の2つのタイプのいずれかを取るエンティティです。"
    },
    {
      "indent": 3,
      "text": "The String type is the set of all finite ordered sequences of zero or more 8-bit unsigned integer values (\"elements\"). The string type can store textual data as well as binary data sequences. Each element is considered to occupy a position within the sequence. These positions are indexed with nonnegative integers. The first element (if any) is at position 0, the next element (if any) at position 1, and so on. The length of a string is the number of elements (i.e., 8-bit values) within it. The empty string has length zero and therefore contains no elements.",
      "ja": "String型は、0個以上の8ビット符号なし整数値（「要素」）のすべての有限順序シーケンスのセットです。 文字列型には、バイナリデータシーケンスだけでなくテキストデータも格納できます。 各要素は、シーケンス内の位置を占めると見なされます。 これらの位置には、非負の整数でインデックスが付けられます。 最初の要素（ある場合）は位置0に、次の要素（ある場合）は位置1に、というように続きます。 文字列の長さは、その中の要素（つまり、8ビット値）の数です。 空の文字列は長さがゼロであるため、要素が含まれていません。"
    },
    {
      "indent": 3,
      "text": "The integer type is the set of all integer values in the range -9223372036854775808 (-2^63) to 18446744073709551615 (2^64-1). If an integer operation would cause a (positive) overflow, then the result is returned modulo 2^64. If an integer operation would cause a (negative) underflow, then the result is undefined. Integer division rounds toward zero.",
      "ja": "整数型は、-9223372036854775808（-2 ^ 63）から18446744073709551615（2 ^ 64-1）の範囲のすべての整数値のセットです。 整数演算が（正の）オーバーフローを引き起こす場合、結果は2 ^ 64を法として返されます。 整数演算が（負の）アンダーフローを引き起こす場合、結果は未定義です。 整数除算はゼロに向かって丸めます。"
    },
    {
      "indent": 3,
      "text": "Prior to initialization, a var object has type String and a length of zero.",
      "ja": "初期化の前に、varオブジェクトの型はStringで、長さはゼロです。"
    },
    {
      "indent": 3,
      "text": "The policy script runtime system performs automatic type conversion as needed. To clarify the semantics of certain constructs it is useful to define a set of conversion operators: ToInteger(), ToString(), ToBoolean(), and Type(). These operators are not a part of the language; they are defined here to aid the specification of the semantics of the language. The conversion operators are polymorphic; that is, they can accept a value of any standard type.",
      "ja": "ポリシースクリプトランタイムシステムは、必要に応じて自動タイプ変換を実行します。 特定のコンストラクトのセマンティクスを明確にするには、一連の変換演算子、ToInteger（）、ToString（）、ToBoolean（）、およびType（）を定義すると便利です。 これらの演算子は言語の一部ではありません。 ここで定義されているのは、言語のセマンティクスの仕様を支援するためです。 変換演算子は多態的です。 つまり、任意の標準タイプの値を受け入れることができます。"
    },
    {
      "indent": 3,
      "text": "ToInteger",
      "ja": "ToInteger"
    },
    {
      "indent": 3,
      "text": "The operator ToInteger converts its argument to a value of type Integer according to the following table:",
      "ja": "演算子ToIntegerは、次の表に従って、引数を整数型の値に変換します。"
    },
    {
      "indent": 9,
      "text": "Integer            The result equals the input argument\n                   (no conversion).\nString             See grammar and note below.\ninteger_constant   The result equals the input argument\n                   (no conversion).\nstring_literal     See grammar and note below.\nchar_constant      See grammar and note below.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ToInteger Applied to Strings",
      "ja": "文字列に適用されるToInteger"
    },
    {
      "indent": 3,
      "text": "ToInteger applied to the String Type string_literal and to char_constants applies the following grammar to the input. If the grammar cannot interpret the string as an expansion of numeric_string, then an RTE is generated. Note that a numeric_string that is empty or contains only white space is converted to 0.",
      "ja": "文字列型string_literalとchar_constantsに適用されるToIntegerは、次の文法を入力に適用します。 文法が文字列をnumeric_stringの展開として解釈できない場合、RTEが生成されます。 空のまたは空白のみを含むnumeric_stringは0に変換されることに注意してください。"
    },
    {
      "indent": 1,
      "text": "-- EBNF for numeric_string",
      "ja": "-numeric_stringのEBNF"
    },
    {
      "indent": 3,
      "text": "numeric_string : white_space* numeric? white_space*",
      "ja": "numeric_string：white_space * numeric？ white_space *"
    },
    {
      "indent": 3,
      "text": "white_space : <TAB> | <SP> | <NBSP> | <FF> | <VT> | <CR> | <LF> | <LS> | <PS> | <USP>",
      "ja": "white_space：<TAB> | <SP> | <NBSP> | <FF> | <VT> | <CR> | <LF> | <LS> | <PS> | <USP>"
    },
    {
      "indent": 3,
      "text": "numeric : signed_decimal | hex_constant | octal_constant | enum_decimal",
      "ja": "数値：signed_decimal | hex_constant | octal_constant | enum_decimal"
    },
    {
      "indent": 3,
      "text": "signed_decimal: [ '-' | '+' ] decimal_constant",
      "ja": "signed_decimal：['-' | '+'] decimal_constant"
    },
    {
      "indent": 3,
      "text": "enum_decimal: [ letter | digit | '-' ]* '(' decimal_constant ')'",
      "ja": "enum_decimal：[レター| 桁| '-'] * '（' decimal_constant '）'"
    },
    {
      "indent": 3,
      "text": "-- decimal_constant, hex_constant, and octal_constant are defined -- in the PolicyScript EBNF described earlier.",
      "ja": "-decimal_constant、hex_constant、およびoctal_constantが定義されています-前述のPolicyScript EBNFで。"
    },
    {
      "indent": 3,
      "text": "Note that when the enum_decimal form is converted, the sequence of characters before the parenthesis and the pair of parenthesis themselves are completely ignored, and the decimal_constant inside the parenthesis is converted. Thus, \"frame-relay(32)\" translates to the integer 32.",
      "ja": "enum_decimal形式が変換されるとき、括弧の前の文字シーケンスと括弧のペア自体は完全に無視され、括弧内のdecimal_constantは変換されることに注意してください。 したがって、「frame-relay（32）」は整数32に変換されます。"
    },
    {
      "indent": 3,
      "text": "Although this will make the script more readable than using the constant \"32\", the burden is on the code writer to be accurate, as \"ethernet-csmacd(32)\" and \"frame-relay(999)\" will also be accepted.",
      "ja": "これにより、定数「32」を使用するよりもスクリプトが読みやすくなりますが、「ethernet-csmacd（32）」と「frame-relay（999）」も受け入れられるため、コード作成者の負担は正確です。"
    },
    {
      "indent": 3,
      "text": "ToString",
      "ja": "ToString"
    },
    {
      "indent": 3,
      "text": "The operator ToString converts its argument to a value of type String according to the following table:",
      "ja": "演算子ToStringは、次の表に従って、引数をString型の値に変換します。"
    },
    {
      "indent": 6,
      "text": "Integer Return the string containing the decimal representation of the input argument in the form of signed_decimal, except that no leading '+' will be used. String Return the input argument (no conversion) integer_constant Return the string containing the decimal representation of the input argument in the form of signed_decimal except that no leading '+' will be used. string_literal Return the input argument (no conversion) char_constant Return the string of length one containing the value of the input argument.",
      "ja": "整数入力引数の10進表現を含む文字列をsigned_decimalの形式で返しますが、先頭の「+」は使用されません。 文字列入力引数（変換なし）を返しますinteger_constant先頭の「+」が使用されないことを除いて、signed_decimalの形式で入力引数の10進表現を含む文字列を返します。 string_literal入力引数を返します（変換なし）char_constant入力引数の値を含む長さ1の文字列を返します。"
    },
    {
      "indent": 3,
      "text": "ToBoolean",
      "ja": "ToBoolean"
    },
    {
      "indent": 3,
      "text": "The operator ToBoolean converts its argument to a value of type Integer according to the following table:",
      "ja": "演算子ToBooleanは、次の表に従って、引数を整数型の値に変換します。"
    },
    {
      "indent": 6,
      "text": "Integer The result is 0 if the argument is 0. Otherwise the result is 1. String The results is 0 if the argument is the empty string. Otherwise the result is 1. integer_constant The result is 0 if the argument is 0. Otherwise the result is 1. string_literal The result is 0 if the argument is the empty string. Otherwise the result is 1. char_constant The result is 1.",
      "ja": "整数引数が0の場合、結果は0です。それ以外の場合、結果は1です。文字列引数が空の文字列の場合、結果は0です。 それ以外の場合、結果は1です。integer_constant引数が0の場合、結果は0です。それ以外の場合、結果は1です。string_literal引数が空の文字列の場合、結果は0です。 それ以外の場合、結果は1です。char_constant結果は1です。"
    },
    {
      "indent": 3,
      "text": "Operators",
      "ja": "オペレーター"
    },
    {
      "indent": 3,
      "text": "The rules below specify the type conversion rules for the various operators.",
      "ja": "以下の規則は、さまざまな演算子の型変換規則を指定します。"
    },
    {
      "indent": 6,
      "text": "A++:   A = ToInteger(A); A++;\nA--:   A = ToInteger(A); A--;\n++A:   A = ToInteger(A); ++A;\n--A:   A = ToInteger(A); --A;\n+A:    ToInteger(A);\n-A:     -1 * ToInteger(A);\n~A:    ToInteger(A);\n!A:    !ToBoolean(A);\nA * B, A - B, A & B, A ^ B , A | B, A << B, A >> B:\n       ToInteger(A) <operator> ToInteger(B)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "A / B, A % B: if (ToInteger(B) == 0) RTE, terminate; else ToInteger(A) <operator> ToInteger(B) A + B: if (Type(A) == String || Type(B) == String) ToString(A) concatenated with ToString(B) else A + B Compound Assignment (<operator>=): Simply follow rules above. Note that type of LHS (Left Hand Side) may be changed as a result.",
      "ja": "A / B、A％B：if（ToInteger（B）== 0）RTE、終了; else ToInteger（A）<operator> ToInteger（B）A + B：if（Type（A）== String || Type（B）== String）ToString（A）とToString（B）を連結した場合else A + B Compound 割り当て（<演算子> =）：上記のルールに従ってください。 その結果、LHS（左側）のタイプが変更される可能性があることに注意してください。"
    },
    {
      "indent": 6,
      "text": "A < B, A > B, A <= B, A >= B, A == B, A != B:\n       if (Type(A) == String && Type(B) == String)\n           lexically compare strings with strcmp() logic\n       else\n           ToInteger(A) <operator> ToInteger(B)\n A && B:\n        if (ToBoolean(A))\n            ToBoolean(B);\n        else\n            false;\n A || B:\n        if (ToBoolean(A))\n            true;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "else\n    ToBoolean(B);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if(A): if (ToBoolean(A)) while(A): while(ToBoolean(A)) for(...; A; ...): for(...; ToBoolean(A); ...)",
      "ja": "if（A）：if（ToBoolean（A））while（A）：while（ToBoolean（A））for（...; A; ...）：for（...; ToBoolean（A）; .. ）"
    },
    {
      "indent": 7,
      "text": "A[B] as a RHS (Right Hand Side) value: if (Type(A) != String || ToInteger(B) >= strlen(A)) RTE, terminate; A[ ToInteger(B) ] The contents are returned as a string of length one",
      "ja": "RHS（右側）値としてのA [B]：if（Type（A）！= String || ToInteger（B）> = strlen（A））RTE、terminate; A [ToInteger（B）]内容は長さ1の文字列として返されます"
    },
    {
      "indent": 8,
      "text": "A[B] = C as a LHS value: if (Type(A) != String || ToInteger(B) >= strlen(A))",
      "ja": "A [B] = LHS値としてのC：if（Type（A）！= String || ToInteger（B）> = strlen（A））"
    },
    {
      "indent": 13,
      "text": "   RTE, terminate;\nif (strlen(ToString(C)) == 0)\n   RTE, terminate\nA[ ToInteger(B) ] = First octet of ToString(C)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Note that this is only applicable in a simple assignment.",
      "ja": "これは単純な割り当てにのみ適用されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "For example, in the expression",
      "ja": "たとえば、式"
    },
    {
      "indent": 6,
      "text": "\"getVar(\"ifSpeed.1\") < 128000\"",
      "ja": "\"getVar（\" ifSpeed.1 \"）<128000\""
    },
    {
      "indent": 3,
      "text": "getVar always returns a string and '128000' is implicitly an integer. The rules for '<' dictate that if either argument is an integer then a 'numeric less than' is performed on ToInteger(A) and ToInteger(B).",
      "ja": "getVarは常に文字列を返し、「128000」は暗黙的に整数です。 '<'の規則では、いずれかの引数が整数の場合、ToInteger（A）およびToInteger（B）で 'より小さい数値'が実行されます。"
    },
    {
      "indent": 3,
      "text": "If \"getVar(\"ifSpeed.1\")\" returns \"64000\", the expression can be translated to:",
      "ja": "「getVar（ \"ifSpeed.1\"）」が「64000」を返す場合、式は次のように変換できます。"
    },
    {
      "indent": 8,
      "text": "ToInteger(\"64000\") < ToInteger(128000); or,\n64000 < 128000; or,\nTrue",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3. PolicyScript QuickStart Guide",
      "section_title": true,
      "ja": "5.3。 PolicyScriptクイックスタートガイド"
    },
    {
      "indent": 3,
      "text": "PolicyScript is designed so that programmers fluent in other languages can quickly begin to write scripts.",
      "ja": "PolicyScriptは、他の言語に堪能なプログラマーがすぐにスクリプトを書き始めることができるように設計されています。"
    },
    {
      "indent": 3,
      "text": "One way to become familiar with a language is to see it in action. The following nonsensical script exercises most of the PolicyScript constructs (though it skips some usage options and many arithmetic operators).",
      "ja": "言語に慣れる1つの方法は、その言語を実際に使用することです。 次の無意味なスクリプトは、ほとんどのPolicyScriptコンストラクトを実行します（ただし、一部の使用オプションと多くの算術演算子はスキップされます）。"
    },
    {
      "indent": 6,
      "text": "var x, index = 7, str = \"Hello World\", oid = \"ifSpeed.\";",
      "ja": "var x、index = 7、str = \"Hello World\"、oid = \"ifSpeed。\";"
    },
    {
      "indent": 6,
      "text": "x = 0;\nwhile(x < 10){\n    if (str < \"Goodbye\") /* string comparison */\n        continue;\n    else\n        break;\n    x++;\n}\nif (oidlen(oid) == 10)\n    oid += \".\" + index; // append index to oid\nfor(x = 0; x < 7; x++){\n      str += \"a\"; var y = 12;\n      index = ((x * 7) + y) % 3;\n      if (str[6] == 'W')\n          return index;\n}\nreturn;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following examples are more practical:",
      "ja": "次の例はより実用的です。"
    },
    {
      "indent": 3,
      "text": "For a condition: // Return 1 if this is an interface and it is tagged // with the role \"gold\" return (inSubtree(elementName(), \"ifEntry\") && roleMatch(\"gold\"))",
      "ja": "条件の場合：//これがインターフェイスであり、ロール \"gold\"でタグ付けされている場合は、1を返す// return（inSubtree（elementName（）、 \"ifEntry\"）&& roleMatch（ \"gold\"））"
    },
    {
      "indent": 3,
      "text": "A condition/action pair: First, register the Host Resources MIB hrSWRunEntry as a new element in the pmElementTypeRegTable. This will cause the policy to run for every process on the system. The token '$*' will be replaced by the script interpreter with a process index (see Section 7 for a definition of the '$*' token).",
      "ja": "条件/アクションのペア：最初に、pmResourceTypeRegTableの新しい要素としてホストリソースMIB hrSWRunEntryを登録します。 これにより、システム上のすべてのプロセスに対してポリシーが実行されます。 トークン「$ *」は、スクリプトインタープリターによってプロセスインデックスに置き換えられます（「$ *」トークンの定義については、セクション7を参照してください）。"
    },
    {
      "indent": 3,
      "text": "The condition: // if it's a process and it's an application and it's // consumed more than 5 minutes of CPU time return (inSubtree(elementName(), \"hrSWRunEntry\") && getVar(\"hrSWRunType.$*\") == 4 // app, not OS or driver && getVar(\"hrSWRunPerfCPU.$*\") > 30000) // 300 seconds",
      "ja": "条件：//プロセスであり、アプリケーションであり、CPU時間の5分以上を消費する場合return（inSubtree（elementName（）、 \"hrSWRunEntry\"）&& getVar（ \"hrSWRunType。$ *\"）== 4 // OSまたはドライバーではなくアプリ&& getVar（ \"hrSWRunPerfCPU。$ *\"）> 30000）// 300秒"
    },
    {
      "indent": 3,
      "text": "The action: // Kill it setVar(\"hrSWRunStatus.$*\", 4, Integer); // invalid(4) kills it",
      "ja": "アクション：// Kill it setVar（ \"hrSWRunStatus。$ *\"、4、Integer）; // invalid（4）はそれを殺します"
    },
    {
      "indent": 3,
      "text": "A more substantial action to start an RMON2 host table on interfaces that match the condition:",
      "ja": "条件に一致するインターフェイスでRMON2ホストテーブルを開始するより実質的なアクション："
    },
    {
      "indent": 6,
      "text": "var pdu, index;",
      "ja": "var pdu、インデックス。"
    },
    {
      "indent": 6,
      "text": "pdu = newPDU();\nwriteVar(pdu, 0, \"hlHostControlDataSource.*\",\n         \"ifIndex.\" + ev(0), Oid);\nwriteVar(pdu, 1, \"hlHostControlNlMaxDesiredEntries.*\", 1000,\n         Integer);\nwriteVar(pdu, 2, \"hlHostControlAlMaxDesiredEntries.*\", 1000,\n         Integer);\nwriteVar(pdu, 3, \"hlHostControlOwner.*\", \"policy\", String); writeVar(pdu, 4, \"hlHostControlStatus.*\", \"active(1)\", Integer);\nif (createRow(pdu, 5, 4, 20, 65535, index) == 0\n    || index == -1)\n    return;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Because PolicyScript is a least common denominator, it contains nothing that would astonish programmers familiar with C, C++, Perl, Tcl, JavaScript, or Python. Although a new programmer may attempt to use language constructs that aren't available in PolicyScript, s/he should be able to understand any existing PolicyScript and will likely know how to use anything that is valid in PolicyScript. The lists below quickly enumerate the changes of note for programmers coming from some particular languages. These lists won't describe the unavailable constructs, but it is easy to see from the definition above what is available.",
      "ja": "PolicyScriptは最も一般的な分母ではないため、C、C ++、Perl、Tcl、JavaScript、またはPythonに精通したプログラマーを驚かせるようなものは何も含まれていません。 新しいプログラマーは、PolicyScriptで使用できない言語構成を使用しようとする場合がありますが、既存のPolicyScriptを理解でき、PolicyScriptで有効なものを使用する方法を知っているはずです。 以下のリストは、特定の言語を使用するプログラマーの注意事項の変更をすばやく列挙しています。 これらのリストは、使用できない構成を説明しませんが、上記の定義から使用可能な構成を簡単に確認できます。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Quickstart for C Programmers",
      "section_title": true,
      "ja": "5.3.1。 Cプログラマー向けクイックスタート"
    },
    {
      "indent": 3,
      "text": "- Character constants (i.e., 'c') are treated as one-character strings, not as integers. So operations such as ('M' - 'A') or (x + 'A') will not perform as expected. - Functions can change the value of arguments even though they are not pointers (or called like '&arg'). - All variables are in the same scope.",
      "ja": "-文字定数（つまり、「c」）は、整数としてではなく、1文字の文字列として扱われます。 そのため、（ 'M'-'A'）や（x + 'A'）などの操作は期待どおりに実行されません。 -関数は、ポインターではない（または '＆arg'のように呼び出される）場合でも、引数の値を変更できます。 -すべての変数は同じスコープ内にあります。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Quickstart for Perl Programmers",
      "section_title": true,
      "ja": "5.3.2。 Perlプログラマー向けクイックスタート"
    },
    {
      "indent": 3,
      "text": "- Comments are '/* comment */' and '// till end of line', not '#'.\n- No need to put a '$' in front of variables.\n- Strings are compared with ==, <=, <, etc. (details in Sec. 6.2.1).\n- Strings are concatenated with '+' (details in Sec. 6.2.1).\n- No variable substitution in \"\" strings.  '' strings are 1 char\n  only.\n- Variables must be declared before use (but no type is necessary).\n- All variables are in the same scope.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.3. Quickstart for TCL Programmers",
      "section_title": true,
      "ja": "5.3.3。 TCLプログラマー向けクイックスタート"
    },
    {
      "indent": 3,
      "text": "- Comments are '/* comment */' and '// till end of line', not '#'.\n- No need to put a '$' in front of variables.\n- Function calls are func-name(arg1, arg2, ...).\n- Square braces [] don't interpret their contents.\n- Double quotes \"\" surround a string, but no substitutions are\n  performed (\"\" is like { } in TCL ).\n- Statements are terminated by a semicolon (;).\n- Instead of \"Set a b\", use \"b = a;\".\n- Strings are concatenated with '+' (details in Sec. 6.2.1).\n- All variables are in the same scope.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.4. Quickstart for Python Programmers",
      "section_title": true,
      "ja": "5.3.4。 Pythonプログラマ向けクイックスタート"
    },
    {
      "indent": 3,
      "text": "- Comments are '/* comment */' and '// till end of line', not '#'.\n- Single quotes can be used only for single-character strings ('a').\n- Indentation doesn't matter.  Braces { } define blocks.\n- Variables must be declared before use (but no type is necessary).\n- The expressions for if and while are always surrounded by\n  parenthesis, as in \"if (x < 5)\".\n- 'for' syntax is \"for(expression; expression; expression)\" (see\n  EBNF).\n- All variables are in the same scope.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.5. Quickstart for JavaScript/ECMAScript/JScript Programmers",
      "section_title": true,
      "ja": "5.3.5。 JavaScript / ECMAScript / JScriptプログラマー向けクイックスタート"
    },
    {
      "indent": 3,
      "text": "- Variables must be declared before use. - Functions can change the value of arguments. - All variables are in the same scope.",
      "ja": "-変数は使用前に宣言する必要があります。 -関数は引数の値を変更できます。 -すべての変数は同じスコープ内にあります。"
    },
    {
      "indent": 0,
      "text": "5.4. PolicyScript Script Return Values",
      "section_title": true,
      "ja": "5.4。 PolicyScriptスクリプトの戻り値"
    },
    {
      "indent": 3,
      "text": "A PolicyScript script execution is normally ended by the execution of a return statement, or by having the flow of execution reach the end of the final statement in the script. A normal script execution always returns a Boolean value. If no explicit value is specified in the return statement, or if the flow of control proceeds through the end of the script, the return value is implicitly zero. If an expression is provided with the return statement, the expression is evaluated, and the result of the expression is implicitly converted with the ToBoolean operator before being returned to the script execution environment.",
      "ja": "PolicyScriptスクリプトの実行は、通常、returnステートメントの実行によって、または実行フローがスクリプト内の最終ステートメントの終わりに到達することによって終了します。 通常のスクリプト実行では、常にブール値が返されます。 returnステートメントで明示的な値が指定されていない場合、または制御の流れがスクリプトの最後まで進む場合、戻り値は暗黙的にゼロになります。 式がreturnステートメントで提供される場合、式は評価され、式の結果はスクリプト実行環境に返される前に、ToBoolean演算子で暗黙的に変換されます。"
    },
    {
      "indent": 3,
      "text": "The return value of a policyCondition script is used to determine whether the associated policyAction script is executed. If the returned value is zero, the associated policyAction script is not executed. If the returned value is one, the associated policyAction script will be executed.",
      "ja": "policyConditionスクリプトの戻り値は、関連するpolicyActionスクリプトが実行されるかどうかを判断するために使用されます。 返された値がゼロの場合、関連するpolicyActionスクリプトは実行されません。 返される値が1の場合、関連付けられたpolicyActionスクリプトが実行されます。"
    },
    {
      "indent": 3,
      "text": "The return value of a policyAction script is ignored.",
      "ja": "policyActionスクリプトの戻り値は無視されます。"
    },
    {
      "indent": 3,
      "text": "An RTE or invocation of the fail() function will cause the return value of the script to be set to zero. Note however, that execution of the defer() or fail() functions may set the defer attribute so that the lower precedence script may be executed. This is independent of the return value of the policy script execution.",
      "ja": "RTEまたはfail（）関数の呼び出しにより、スクリプトの戻り値がゼロに設定されます。 ただし、defer（）またはfail（）関数を実行すると、defer属性が設定され、優先順位の低いスクリプトが実行される場合があります。 これは、ポリシースクリプト実行の戻り値とは無関係です。"
    },
    {
      "indent": 0,
      "text": "6. Index Information for 'this element'",
      "section_title": true,
      "ja": "6.「この要素」のインデックス情報"
    },
    {
      "indent": 3,
      "text": "PolicyScript code needs a convenient way to get the components of the index for 'this element' so that they can perform SNMP operations on it or on related elements.",
      "ja": "PolicyScriptコードは、 'this element'のインデックスのコンポーネントを取得する便利な方法を必要とするため、そのコンポーネントまたは関連する要素でSNMP操作を実行できます。"
    },
    {
      "indent": 3,
      "text": "Two mechanisms are provided.",
      "ja": "2つのメカニズムが提供されます。"
    },
    {
      "indent": 3,
      "text": "1. For all OID input parameters to all SNMP Library Functions (but not OID utility functions), the token \"$n\" ('$' followed by an integer between 0 and 128) can be used in place of any decimal sub-identifier. This token is expanded by the agent at execution time to contain the nth subid of the index for the current element. For example, if the element is interface 7, and the objectIdentifier is \"1.3.6.1.2.1.2.2.1.3.$0\", it will be expanded to \"1.3.6.1.2.1.2.2.1.3.7\". The special token \"$*\" is expanded to contain all of the subidentifiers of the index of the current element, separated by '.' characters.",
      "ja": "1.すべてのSNMPライブラリ関数（ただし、OIDユーティリティ関数ではない）へのすべてのOID入力パラメーターでは、トークン「$ n」（「$」の後に0〜128の整数）を10進数のサブ識別子の代わりに使用できます。 。 このトークンは、実行時にエージェントによって拡張され、現在の要素のインデックスのn番目のサブIDが含まれます。 たとえば、要素がインターフェイス7で、objectIdentifierが「1.3.6.1.2.1.2.2.1.3。$ 0」の場合、「1.3.6.1.2.1.2.2.1.3.7」に展開されます。 特別なトークン「$ *」は、「。」で区切られた現在の要素のインデックスのすべてのサブ識別子を含むように展開されます。 文字。"
    },
    {
      "indent": 6,
      "text": "It is an RTE if a token is specified that is beyond the length of the index for the current element.",
      "ja": "現在の要素のインデックスの長さを超えるトークンが指定されている場合、RTEです。"
    },
    {
      "indent": 6,
      "text": "Note that the \"$n\" convention is only active within strings.",
      "ja": "「$ n」規則は文字列内でのみアクティブであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "2. The ec() and ev() functions allow access to the components of the index for 'this element'. ec() takes no argument and returns the number of index components that exist. ev() takes an integer argument specifying which component of the index (numbered starting at 0) and returns an integer containing the value of the n'th subidentifier. Refer to the Library functions section for the complete definition of ec() and ev().",
      "ja": "2. ec（）およびev（）関数を使用すると、「この要素」のインデックスのコンポーネントにアクセスできます。 ec（）は引数を取らず、存在するインデックスコンポーネントの数を返します。 ev（）は、インデックスのどのコンポーネント（0から始まる番号）を指定する整数引数を取り、n番目のサブ識別子の値を含む整数を返します。 ec（）およびev（）の完全な定義については、ライブラリ関数セクションを参照してください。"
    },
    {
      "indent": 9,
      "text": "For example, if 'this element' is frCircuitDLCI.5.57\n                                  (ifIndex = 5, DLCI = 57)\n      then ec()  returns 2\n           ev(0) returns 5\n           ev(1) returns 57",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "This is helpful when one wishes to address a related element. Extending the previous example, to find the port speed of the port, the circuit (above) runs over:",
      "ja": "これは、関連する要素に対処する場合に役立ちます。 前の例を拡張して、ポートのポート速度を見つけるために、回路（上記）が実行されます。"
    },
    {
      "indent": 9,
      "text": "portSpeed = getVar(\"ifSpeed.\" + ev(0));",
      "ja": "portSpeed = getVar（ \"ifSpeed。\" + ev（0））;"
    },
    {
      "indent": 6,
      "text": "A script may check the type of 'this element' by calling the elementName() function. Although it is possible to write a script that will work with different types of elements, many scripts will assume a particular element type and will work incorrectly if used on different element types.",
      "ja": "スクリプトは、elementName（）関数を呼び出すことにより、「この要素」のタイプを確認できます。 さまざまなタイプの要素で機能するスクリプトを作成することは可能ですが、多くのスクリプトは特定の要素タイプを想定しており、さまざまな要素タイプで使用すると正しく機能しません。"
    },
    {
      "indent": 0,
      "text": "7. Library Functions",
      "section_title": true,
      "ja": "7.ライブラリ関数"
    },
    {
      "indent": 3,
      "text": "Library functions are built-in functions available primarily to provide access to information on the local system or to manipulate this information more efficiently. A group of functions is organized into a library, the unit of conformance for function implementation. In order to claim conformance to a library, an implementation must implement all functions in a library to the specifications of the library.",
      "ja": "ライブラリ関数は、主にローカルシステム上の情報へのアクセスを提供したり、この情報をより効率的に操作するために使用できる組み込み関数です。 関数のグループは、関数実装の適合の単位であるライブラリに編成されます。 ライブラリへの適合を主張するために、実装はライブラリのすべての機能をライブラリの仕様に実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "In order for a management station or a condition or action to understand whether a certain library of functions is implemented, each library will have a name that it registers in the role table as a characteristic of the system element (\"0.0\") in the default SNMP context. Thus, conformance to a library can be tested with the roleMatch library function (in the base library) with the call roleMatch (\"libraryName\", \"0.0\").",
      "ja": "機能の特定のライブラリが実装されているかどうかを管理ステーションまたは条件またはアクションが理解するために、各ライブラリには、デフォルトでシステム要素の特性（「0.0」）としてロールテーブルに登録する名前があります。 SNMPコンテキスト。 したがって、roleMatch（ \"libraryName\"、 \"0.0\"）を呼び出して、roleMatchライブラリ関数（ベースライブラリ内）でライブラリへの適合をテストできます。"
    },
    {
      "indent": 3,
      "text": "Note that in the descriptions of these functions below, the function prototype describes the type of argument expected. Even though variables are not declared with a particular type, their contents must be appropriate for each function argument. If the type is variable, the keyword 'var' will be used. If only a string is appropriate, the keyword 'string' will be used. If only an integer is appropriate, the keyword 'integer' will be used. If the argument is declared as 'string' or 'integer' and a value of a different type is passed, the argument will be coerced with ToInteger() or ToString(). Any failure of this coercion will cause an RTE (in particular for ToInteger(), which will fail if its string-valued argument is not a well-formed integer).",
      "ja": "以下のこれらの関数の説明では、関数のプロトタイプが予想される引数のタイプを説明していることに注意してください。 変数は特定の型で宣言されていませんが、その内容は関数の引数ごとに適切でなければなりません。 タイプが可変の場合、キーワード「var」が使用されます。 文字列のみが適切な場合、キーワード「string」が使用されます。 整数のみが適切な場合は、キーワード「整数」が使用されます。 引数が 'string'または 'integer'として宣言され、異なる型の値が渡される場合、引数はToInteger（）またはToString（）で強制されます。 この強制が失敗すると、RTEが発生します（特にToInteger（）の場合、文字列値の引数が整形式整数でない場合は失敗します）。"
    },
    {
      "indent": 3,
      "text": "In the function prototype, if the '&' character precedes the identifier for an argument, that argument may be modified by the function (e.g., \"integer &result, ...)\"). Arguments without the '&' character cannot be modified by the function. In a script, modifiable arguments don't have to be preceded by a '&'. It is an RTE if a constant is passed to a modifiable function argument (regardless of whether the function actually writes to the argument).",
      "ja": "関数プロトタイプでは、「＆」文字が引数の識別子の前にある場合、その引数は関数によって変更される場合があります（例： \"integer＆result、...）\"）。 「＆」文字のない引数は、関数で変更できません。 スクリプトでは、変更可能な引数の前に「＆」を付ける必要はありません。 （関数が実際に引数に書き込むかどうかに関係なく）修正可能な関数の引数に定数が渡される場合、RTEです。"
    },
    {
      "indent": 3,
      "text": "In the function prototype, the '[' and ']' characters surround arguments that are optional. In PolicyScript code, the optional argument may only be included if all optional arguments to the left of it are included. The function may place restrictions on when an optional argument must, or must not, be included.",
      "ja": "関数プロトタイプでは、「[」および「]」文字はオプションの引数を囲みます。 PolicyScriptコードでは、左側にあるすべてのオプション引数が含まれている場合にのみ、オプション引数を含めることができます。 この関数は、オプションの引数を含める必要があるかどうかを制限する場合があります。"
    },
    {
      "indent": 3,
      "text": "In the function prototype, if a type is listed before the name of the function, the function returns a value of that type. If no type is listed, the function returns no value.",
      "ja": "関数プロトタイプでは、関数の名前の前に型がリストされている場合、関数はその型の値を返します。 タイプがリストされていない場合、関数は値を返しません。"
    },
    {
      "indent": 0,
      "text": "8. Base Function Library",
      "section_title": true,
      "ja": "8.基本機能ライブラリ"
    },
    {
      "indent": 3,
      "text": "A standard base library of functions is available to all systems that implement this specification. This library is registered with the name \"pmBaseFunctionLibrary\". Although the specification of this library is modularized into 4 separate sections, conformance to the library requires implementation of all functions in all sections.",
      "ja": "関数の標準ベースライブラリは、この仕様を実装するすべてのシステムで利用できます。 このライブラリは、「pmBaseFunctionLibrary」という名前で登録されています。 このライブラリの仕様は4つのセクションにモジュール化されていますが、ライブラリに準拠するには、すべてのセクションのすべての機能を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "The sections are:",
      "ja": "セクションは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "- SNMP library functions - Policy library functions - Utility functions - Library Functions",
      "ja": "-SNMPライブラリ関数-ポリシーライブラリ関数-ユーティリティ関数-ライブラリ関数"
    },
    {
      "indent": 0,
      "text": "8.1. SNMP Library Functions",
      "section_title": true,
      "ja": "8.1。 SNMPライブラリ関数"
    },
    {
      "indent": 3,
      "text": "Two sets of SNMP Library functions are available with different situations in mind:",
      "ja": "2つのSNMPライブラリ関数のセットは、異なる状況を考慮して使用できます。"
    },
    {
      "indent": 3,
      "text": "- Convenience SNMP Functions",
      "ja": "-便利なSNMP機能"
    },
    {
      "indent": 5,
      "text": "In an effort to keep simple things simple, these functions are easy to use and code that is easy to understand. These functions will suffice for the majority of situations, where a single variable is referenced and the desired error recovery is simply (and immediately) to give up (and move to the next policy-element combination). In more complex cases, the General SNMP Functions can be used at the cost of several times the code complexity.",
      "ja": "シンプルなものをシンプルにするために、これらの関数は使いやすく、理解しやすいコードです。 これらの関数は、単一の変数が参照され、必要なエラー回復が単純に（そしてすぐに）giveめられる（そして次のポリシー要素の組み合わせに移動する）大多数の状況で十分です。 より複雑なケースでは、コードの複雑さの数倍のコストで一般的なSNMP機能を使用できます。"
    },
    {
      "indent": 5,
      "text": "The convenience SNMP functions are getVar, exists, setVar, setRowStatus, createRow, counterRate, and searchColumn.",
      "ja": "便利なSNMP関数は、getVar、exists、setVar、setRowStatus、createRow、counterRate、およびsearchColumnです。"
    },
    {
      "indent": 3,
      "text": "- General SNMP Functions",
      "ja": "-一般的なSNMP機能"
    },
    {
      "indent": 5,
      "text": "The General SNMP functions allow nearly any legal SNMP Message to be generated, including those with multiple varbinds, getNext operations, notifications, and messages with explicit addressing or security specifications.",
      "ja": "一般的なSNMP機能を使用すると、複数のvarbind、getNext操作、通知、明示的なアドレス指定またはセキュリティ仕様のメッセージを含む、ほぼすべての正当なSNMPメッセージを生成できます。"
    },
    {
      "indent": 5,
      "text": "The general SNMP functions are writeVar, readVar, snmpSend, readError, and writeBulkParameters.",
      "ja": "一般的なSNMP関数は、writeVar、readVar、snmpSend、readError、およびwriteBulkParametersです。"
    },
    {
      "indent": 0,
      "text": "8.1.1. SNMP Operations on Non-Local Systems",
      "section_title": true,
      "ja": "8.1.1。 非ローカルシステムでのSNMP操作"
    },
    {
      "indent": 3,
      "text": "From time to time, a script may have to perform an operation on a different SNMP system than that on which 'this element' resides. Scripts may also have to specify the use of alternate security parameters. In order to do this, the following optional arguments are provided for the SNMP library functions:",
      "ja": "スクリプトは、「この要素」が存在するシステムとは異なるSNMPシステムで操作を実行する必要がある場合があります。 スクリプトは、代替セキュリティパラメータの使用を指定する必要がある場合もあります。 これを行うために、次のオプションの引数がSNMPライブラリ関数に提供されます。"
    },
    {
      "indent": 3,
      "text": "snmp-function(...[, integer mPModel, string tDomain, string tAddress, integer secModel, string secName, integer secLevel, string contextEngineID ])",
      "ja": "snmp-function（... [、integer mPModel、string tDomain、string tAddress、integer secModel、string secName、integer secLevel、string contextEngineID]）"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 7,
      "text": "getVar(\"sysDescr.0\", \"\", SNMPv3, \"transportDomainUdpIpv4\",\n       \"192.168.1.1:161\", USM, \"joe\", NoAuthNoPriv);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The use of these arguments is denoted in function definitions by the keyword 'NonLocalArgs'. The definitions of these arguments are as follows:",
      "ja": "これらの引数の使用は、キーワード「NonLocalArgs」によって関数定義で示されます。 これらの引数の定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "'mPModel' is the integer value of the SnmpMessageProcessingModel to use for this operation.",
      "ja": "「mPModel」は、この操作に使用するSnmpMessageProcessingModelの整数値です。"
    },
    {
      "indent": 6,
      "text": "'tDomain' is a string containing an ASCII dotted-decimal object identifier representing the transport domain to use for this operation.",
      "ja": "「tDomain」は、この操作に使用するトランスポートドメインを表すASCIIドット付き10進数のオブジェクト識別子を含む文字列です。"
    },
    {
      "indent": 6,
      "text": "'tAddress' is a string containing the transport address formatted according to the 'tDomain' argument. The ASCII formats for various values of 'tDomain' are defined by the DISPLAY-HINT for a TEXTUAL-CONVENTION that represents an address of that type. The DISPLAY-HINTs used are:",
      "ja": "「tAddress」は、「tDomain」引数に従ってフォーマットされたトランスポートアドレスを含む文字列です。 「tDomain」のさまざまな値のASCII形式は、そのタイプのアドレスを表すTEXTUAL-CONVENTIONのDISPLAY-HINTによって定義されます。 使用されるDISPLAY-HINTは次のとおりです。"
    },
    {
      "indent": 9,
      "text": "tDomain                    Source of DISPLAY-HINT [5] [11]\n-------                    ----------------------\ntransportDomainUdpIpv4     TransportAddressIPv4\ntransportDomainUdpIpv6     TransportAddressIPv6\ntransportDomainUdpDns      TransportAddressDns\nsnmpCLNSDomain             snmpOSIAddress\nsnmpCONSDomain             snmpOSIAddress\nsnmpDDPDomain              snmpNBPAddress\nsnmpIPXDomain              snmpIPXAddress\nrfc1157Domain              snmpUDPAddress\nOther                      Use DISPLAY-HINT \"1x:\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "'secModel' is the integer value of the SnmpSecurityModel to use for this operation.",
      "ja": "「secModel」は、この操作に使用するSnmpSecurityModelの整数値です。"
    },
    {
      "indent": 6,
      "text": "'secName' is a string value representing the SnmpSecurityName to use for this operation.",
      "ja": "「secName」は、この操作に使用するSnmpSecurityNameを表す文字列値です。"
    },
    {
      "indent": 6,
      "text": "'secLevel' is the integer value of the SnmpSecurityLevel to use for this operation.",
      "ja": "「secLevel」は、この操作に使用するSnmpSecurityLevelの整数値です。"
    },
    {
      "indent": 6,
      "text": "An SNMP operation will be sent to the target system by using security parameters retrieved from a local configuration datastore based on 'secModel', 'secName', and 'secLevel'. It is the responsibility of the agent to ensure that sensitive information in the local configuration datastore is used on behalf of the correct principals, as identified by the security credentials of the last entity to modify the pmPolicyAdminStatus for a policy.",
      "ja": "SNMP操作は、「secModel」、「secName」、および「secLevel」に基づいてローカル構成データストアから取得したセキュリティパラメーターを使用して、ターゲットシステムに送信されます。 ポリシーのpmPolicyAdminStatusを変更する最後のエンティティのセキュリティ資格情報によって識別されるように、ローカル構成データストア内の機密情報が正しいプリンシパルに代わって使用されるようにすることは、エージェントの責任です。"
    },
    {
      "indent": 6,
      "text": "To illustrate how this must be configured, consider an example in which 'joe' installs a policy on 'PMAgent' that will periodically configure objects on 'TargetAgent' with the credentials of 'Operator'. The following conditions must be true for this policy to execute with the proper privileges:",
      "ja": "これをどのように構成する必要があるかを説明するために、「joe」が「PMAgent」にポリシーをインストールし、「TargetAgent」のオブジェクトを「Operator」の資格情報で定期的に構成する例を考えます。 このポリシーを適切な権限で実行するには、次の条件が満たされている必要があります。"
    },
    {
      "indent": 6,
      "text": "- 'Operator's security credentials for TargetAgent must be installed in PMAgent's local configuration datastore (e.g., usmUserTable [6]) indexed by TargetAgent's engineID and 'Operator'. - VACM [9] must be configured on PMAgent so that 'joe' has access to the above entry in the appropriate MIB for the local configuration datastore (e.g., usmUserTable). - 'joe' must be the last user to modify the pmPolicyAdminStatus object for the policy.",
      "ja": "-TargetAgentのengineIDおよび 'Operator'によってインデックスが付けられた 'TargetAgentのオペレーターのセキュリティ資格情報は、PMAgentのローカル構成データストア（たとえば、usmUserTable [6]）にインストールする必要があります。 -「joe」がローカル構成データストアの適切なMIB（usmUserTableなど）の上記のエントリにアクセスできるように、VACAgent [9]をPMAgentで構成する必要があります。 -「joe」は、ポリシーのpmPolicyAdminStatusオブジェクトを変更する最後のユーザーでなければなりません。"
    },
    {
      "indent": 6,
      "text": "See the Security Considerations section for more information.",
      "ja": "詳細については、セキュリティに関する考慮事項のセクションを参照してください。"
    },
    {
      "indent": 6,
      "text": "For convenience, constants for 'mPModel', 'secModel', and 'secLevel' are defined in the \"Constants\" section below.",
      "ja": "便宜上、「mPModel」、「secModel」、および「secLevel」の定数は、以下の「定数」セクションで定義されています。"
    },
    {
      "indent": 6,
      "text": "'contextEngineID' is a string representing the contextEngineID of the SNMP entity targeted by this operation. It is encoded as a pair of hex digits (upper- and lowercase are valid) for each octet of the contextEngineID. If 'tDomain' and 'tAddress' are provided but 'contextEngineID' is not, then the operation will be directed to the SNMP entity reachable at 'tDomain' and 'tAddress'.",
      "ja": "「contextEngineID」は、この操作の対象となるSNMPエンティティのcontextEngineIDを表す文字列です。 contextEngineIDの各オクテットに対して、16進数のペア（大文字と小文字が有効）としてエンコードされます。 「tDomain」および「tAddress」が提供されるが「contextEngineID」が提供されない場合、操作は「tDomain」および「tAddress」で到達可能なSNMPエンティティに向けられます。"
    },
    {
      "indent": 6,
      "text": "In order for PolicyScript code to use any of these arguments, all optional arguments to the left must be included. 'mPModel', 'tDomain', 'tAddress', 'secModel', 'secName', and 'secLevel' must be used as a group; if one is specified, they must all be. 'contextEngineID' may only be specified if all others are specified.",
      "ja": "PolicyScriptコードでこれらの引数のいずれかを使用するには、左側のすべてのオプションの引数を含める必要があります。 「mPModel」、「tDomain」、「tAddress」、「secModel」、「secName」、および「secLevel」をグループとして使用する必要があります。 指定する場合は、すべて指定する必要があります。 「contextEngineID」は、他のすべてが指定されている場合にのみ指定できます。"
    },
    {
      "indent": 6,
      "text": "Note that a function that uses NonLocalArgs must provide a parameter for the contextName that will be required when the NonLocalArgs are present. Many functions will have the following logic:",
      "ja": "NonLocalArgsを使用する関数は、NonLocalArgsが存在する場合に必要となるcontextNameのパラメーターを提供する必要があることに注意してください。 多くの関数には次のロジックがあります。"
    },
    {
      "indent": 6,
      "text": "ContextName NonLocalArgs Supplied Supplied",
      "ja": "ContextName NonLocalArgs Supplied Supplied"
    },
    {
      "indent": 6,
      "text": "No No Addressed to default context on local system. Yes No Addressed to named context on local system. Yes Yes Addressed to named context on potentially remote system. No Yes Not allowed.",
      "ja": "ローカルシステムのデフォルトコンテキストに対応します。 はいいいえローカルシステムの名前付きコンテキストに対応します。 はいはい潜在的にリモートシステム上の名前付きコンテキストに対処しました。 いいえはい許可されていません。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Form of SNMP Values",
      "section_title": true,
      "ja": "8.1.2。 SNMP値の形式"
    },
    {
      "indent": 3,
      "text": "Many of the library functions have input or output parameters that may be one of the many SMI data types. The actual type is not encoded in the value but is specified elsewhere, possibly by nature of the situation in which it is used. The exact usage for input and output is as follows:",
      "ja": "ライブラリ関数の多くには、多くのSMIデータ型の1つである可能性がある入力または出力パラメーターがあります。 実際のタイプは値にエンコードされませんが、おそらく使用される状況の性質により、他の場所で指定されます。 入力と出力の正確な使用法は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Any Integer value (INTEGER, Integer32, Counter32, Counter64, Gauge32, Unsigned32, TimeTicks, Counter64):",
      "ja": "任意の整数値（INTEGER、Integer32、Counter32、Counter64、Gauge32、Unsigned32、TimeTicks、Counter64）："
    },
    {
      "indent": 6,
      "text": "On input: An Integer or a String that can be successfully coerced to an Integer with the ToInteger() operator. It is an RTE if a string is passed that cannot be converted by ToInteger() into an integer.",
      "ja": "入力時：ToInteger（）演算子を使用して整数に正常に強制変換できる整数または文字列。 ToInteger（）で整数に変換できない文字列が渡された場合、RTEです。"
    },
    {
      "indent": 9,
      "text": "A string of the form",
      "ja": "フォームの文字列"
    },
    {
      "indent": 9,
      "text": " enum_decimal: [ letter | digit | '-' ]* '(' decimal_constant ')'",
      "ja": "enum_decimal：[レター| 桁| '-'] * '（' decimal_constant '）'"
    },
    {
      "indent": 9,
      "text": "will also be accepted. In this case the sequence of characters before the parentheses and the parentheses themselves are completely ignored, and the decimal_constant inside the parentheses is converted. Thus, \"frame-relay(32)\" translates to the integer 32.",
      "ja": "受け入れられます。 この場合、括弧の前の文字シーケンスと括弧自体は完全に無視され、括弧内のdecimal_constantは変換されます。 したがって、「frame-relay（32）」は整数32に変換されます。"
    },
    {
      "indent": 6,
      "text": "On output: An Integer containing the returned value.",
      "ja": "出力時：戻り値を含む整数。"
    },
    {
      "indent": 3,
      "text": "Octet String On input: Either a String or an Integer. If an Integer, it will be coerced to a String with the ToString() function. This string will be used as an unencoded representation of the octet string value.",
      "ja": "入力時のオクテット文字列：文字列または整数のいずれか。 整数の場合、ToString（）関数を使用して強制的に文字列に変換されます。 この文字列は、オクテット文字列値のエンコードされていない表現として使用されます。"
    },
    {
      "indent": 6,
      "text": "On output: A String containing the unencoded value of the octet string.",
      "ja": "出力時：オクテット文字列のエンコードされていない値を含む文字列。"
    },
    {
      "indent": 3,
      "text": "Object Identifier On input and on output: A String containing a decimal ASCII encoded object identifier of the following form:",
      "ja": "オブジェクト識別子入力時および出力時：次の形式の10進ASCIIエンコードオブジェクト識別子を含む文字列："
    },
    {
      "indent": 12,
      "text": "oid:       subid [ '.' subid ]* [ '.' ]\nsubid:     '0' | decimal_constant",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "It is an RTE if an Object Identifier argument is not in the form above. Note that a trailing '.' is acceptable and will simply be ignored. (Note, however, that a trailing dot could cause a strncmp() comparison of two otherwise-identical OIDs to fail; instead, use oidncmp().)",
      "ja": "オブジェクト識別子の引数が上記の形式でない場合、RTEです。 末尾の「。」 許容され、単に無視されます。 （ただし、末尾のドットが原因で、同一の2つのOIDのstrncmp（）比較が失敗する可能性があることに注意してください。代わりに、oidncmp（）を使用してください。）"
    },
    {
      "indent": 6,
      "text": "Note that ASCII descriptors (e.g., \"ifIndex\") are never used in these encodings \"over the wire\". They are never returned from library functions; nor are they ever accepted by them. NMS user interfaces are encouraged to allow humans to view object identifiers with ASCII descriptors, but they must translate those descriptors to dotted-decimal format before sending them in MIB objects to policy agents.",
      "ja": "ASCII記述子（例：「ifIndex」）は、これらのエンコードでは「over the wire」では使用されないことに注意してください。 ライブラリ関数から返されることはありません。 また、彼らに受け入れられることもありません。 NMSユーザーインターフェイスは、ASCII記述子を使用してオブジェクト識別子を表示できるようにすることをお勧めしますが、MIBオブジェクトでポリシーエージェントに送信する前に、それらの記述子をドット付き10進形式に変換する必要があります。"
    },
    {
      "indent": 3,
      "text": "Null On input: The input is ignored.",
      "ja": "Null On input：入力は無視されます。"
    },
    {
      "indent": 6,
      "text": "On output: A zero length string.",
      "ja": "出力時：長さゼロの文字列。"
    },
    {
      "indent": 0,
      "text": "8.1.3. Convenience SNMP Functions",
      "section_title": true,
      "ja": "8.1.3。 便利なSNMP機能"
    },
    {
      "indent": 0,
      "text": "8.1.3.1. getVar()",
      "section_title": true,
      "ja": "8.1.3.1。 getVar（）"
    },
    {
      "indent": 3,
      "text": "The getVar() function is used to retrieve the value of an SNMP MIB object instance.",
      "ja": "getVar（）関数は、SNMP MIBオブジェクトインスタンスの値を取得するために使用されます。"
    },
    {
      "indent": 6,
      "text": "string getVar(string oid [, string contextName, NonLocalArgs])",
      "ja": "string getVar（string oid [、string contextName、NonLocalArgs]）"
    },
    {
      "indent": 9,
      "text": "'oid' is a string containing an ASCII dotted-decimal representation of an object identifier (e.g., \"1.3.6.1.2.1.1.1.0\").",
      "ja": "「oid」は、オブジェクト識別子のASCIIドット付き10進表現を含む文字列です（例：「1.3.6.1.2.1.1.1.0」）。"
    },
    {
      "indent": 9,
      "text": "The optional 'contextName' argument contains the SNMP context on which to operate. If 'contextName' is not present, the contextName of 'this element' will be used. If 'contextName' is the zero-length string, the default context is used.",
      "ja": "オプションの「contextName」引数には、操作対象のSNMPコンテキストが含まれます。 「contextName」が存在しない場合、「this element」のcontextNameが使用されます。 'contextName'が長さゼロの文字列の場合、デフォルトのコンテキストが使用されます。"
    },
    {
      "indent": 9,
      "text": "The optional 'NonLocalArgs' provide addressing and security information to perform an SNMP operation on a system different from that of 'this element'.",
      "ja": "オプションの「NonLocalArgs」は、「この要素」とは異なるシステムでSNMP操作を実行するためのアドレス指定とセキュリティ情報を提供します。"
    },
    {
      "indent": 9,
      "text": "It is an RTE if the queried object identifier value does not exist.",
      "ja": "照会されたオブジェクト識別子の値が存在しない場合、RTEです。"
    },
    {
      "indent": 9,
      "text": "This function returns a string containing the returned value, encoded according to the returned type. Note that no actual SNMP PDU has to be generated and parsed when the policy MIB agent resides on the same system as the managed elements.",
      "ja": "この関数は、返されたタイプに従ってエンコードされた、返された値を含む文字列を返します。 ポリシーMIBエージェントが管理対象要素と同じシステムにある場合、実際のSNMP PDUを生成および解析する必要はありません。"
    },
    {
      "indent": 9,
      "text": "It is recommended that NMS user interfaces display and allow input of MIB object names by their descriptor values, followed by the index in dotted-decimal form (e.g., \"ifType.7\").",
      "ja": "NMSユーザーインターフェイスは、記述子値とそれに続くドット付き10進形式のインデックス（たとえば、「ifType.7」）によってMIBオブジェクト名を表示および入力できるようにすることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "8.1.3.2. exists()",
      "section_title": true,
      "ja": "8.1.3.2。 exists（）"
    },
    {
      "indent": 3,
      "text": "The exists() function is used to verify the existence of an SNMP MIB object instance.",
      "ja": "exists（）関数は、SNMP MIBオブジェクトインスタンスの存在を確認するために使用されます。"
    },
    {
      "indent": 6,
      "text": "integer exists(string oid [, string contextName, NonLocalArgs])",
      "ja": "整数が存在します（string oid [、string contextName、NonLocalArgs]）"
    },
    {
      "indent": 9,
      "text": "'oid' is a string containing an ASCII dotted-decimal representation of an object identifier (e.g., \"1.3.6.1.2.1.1.1.0\").",
      "ja": "「oid」は、オブジェクト識別子のASCIIドット付き10進表現を含む文字列です（例：「1.3.6.1.2.1.1.1.0」）。"
    },
    {
      "indent": 9,
      "text": "The optional 'contextName' argument contains the SNMP context on which to operate. If 'contextName' is not present, the contextName of 'this element' will be used. If 'contextName' is the zero-length string, the default context is used.",
      "ja": "オプションの「contextName」引数には、操作対象のSNMPコンテキストが含まれます。 「contextName」が存在しない場合、「this element」のcontextNameが使用されます。 'contextName'が長さゼロの文字列の場合、デフォルトのコンテキストが使用されます。"
    },
    {
      "indent": 9,
      "text": "The optional 'NonLocalArgs' provide addressing and security information to perform an SNMP operation on a system different from that of 'this element'.",
      "ja": "オプションの「NonLocalArgs」は、「この要素」とは異なるシステムでSNMP操作を実行するためのアドレス指定とセキュリティ情報を提供します。"
    },
    {
      "indent": 9,
      "text": "This function returns the value 1 if the SNMP instance exists and 0 if it doesn't exist. Note that no actual SNMP PDU has to be generated and parsed when the policy MIB agent resides on the same system as the managed elements.",
      "ja": "この関数は、SNMPインスタンスが存在する場合は値1を返し、存在しない場合は0を返します。 ポリシーMIBエージェントが管理対象要素と同じシステムにある場合、実際のSNMP PDUを生成および解析する必要はありません。"
    },
    {
      "indent": 9,
      "text": "It is recommended that NMS user interfaces display and allow input of MIB object names by their descriptor values, followed by the index in dotted-decimal form (e.g., \"ifType.7\").",
      "ja": "NMSユーザーインターフェイスは、記述子値とそれに続くドット付き10進形式のインデックス（たとえば、「ifType.7」）によってMIBオブジェクト名を表示および入力できるようにすることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "8.1.3.3. setVar()",
      "section_title": true,
      "ja": "8.1.3.3。 setVar（）"
    },
    {
      "indent": 3,
      "text": "The setVar() function is used to set a MIB object instance to a certain value. The setVar() function is only valid in policyActions.",
      "ja": "setVar（）関数は、MIBオブジェクトインスタンスを特定の値に設定するために使用されます。 setVar（）関数はpolicyActionsでのみ有効です。"
    },
    {
      "indent": 6,
      "text": "setVar(string oid, var value, integer type [, string contextName, NonLocalArgs] )",
      "ja": "setVar（string oid、var value、integer type [、string contextName、NonLocalArgs]）"
    },
    {
      "indent": 9,
      "text": "'oid' is a string containing an ASCII dotted-decimal representation of an object identifier (e.g., \"1.3.6.1.2.1.1.1.0\").",
      "ja": "「oid」は、オブジェクト識別子のASCIIドット付き10進表現を含む文字列です（例：「1.3.6.1.2.1.1.1.0」）。"
    },
    {
      "indent": 9,
      "text": "'value' is a string encoded in the format appropriate to the 'type' parameter. The agent will set the variable specified by 'oid' to the value specified by 'value'.",
      "ja": "「値」は、「タイプ」パラメーターに適した形式でエンコードされたストリングです。 エージェントは、「oid」で指定された変数を「value」で指定された値に設定します。"
    },
    {
      "indent": 9,
      "text": "'type' will be the type of the 'value' parameter and will be set to one of the values for DataType Constants.",
      "ja": "「タイプ」は「値」パラメーターのタイプであり、DataType定数の値の1つに設定されます。"
    },
    {
      "indent": 9,
      "text": "The optional 'contextName' argument contains the SNMP context on which to operate. If 'contextName' is not present, the contextName of 'this element' will be used. If 'contextName' is the zero length string, the default context is used.",
      "ja": "オプションの「contextName」引数には、操作対象のSNMPコンテキストが含まれます。 「contextName」が存在しない場合、「this element」のcontextNameが使用されます。 'contextName'が長さゼロの文字列の場合、デフォルトのコンテキストが使用されます。"
    },
    {
      "indent": 9,
      "text": "The optional 'NonLocalArgs' provide addressing and security information to perform an SNMP operation on a system different from that of 'this element'. Note that no actual SNMP PDU has to be generated and parsed when the policy MIB agent resides on the same system as the managed elements.",
      "ja": "オプションの「NonLocalArgs」は、「この要素」とは異なるシステムでSNMP操作を実行するためのアドレス指定とセキュリティ情報を提供します。 ポリシーMIBエージェントが管理対象要素と同じシステムにある場合、実際のSNMP PDUを生成および解析する必要はありません。"
    },
    {
      "indent": 9,
      "text": "It is an RTE if the set encounters any error.",
      "ja": "セットでエラーが発生した場合は、RTEです。"
    },
    {
      "indent": 9,
      "text": "It is recommended that NMS user interfaces display and allow input of MIB object names by their descriptor values, followed by the index in dotted-decimal form (e.g., \"ifType.7\").",
      "ja": "NMSユーザーインターフェイスは、記述子値とそれに続くドット付き10進形式のインデックス（たとえば、「ifType.7」）によってMIBオブジェクト名を表示および入力できるようにすることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "8.1.3.4. searchColumn()",
      "section_title": true,
      "ja": "8.1.3.4。 searchColumn（）"
    },
    {
      "indent": 6,
      "text": "integer searchColumn(string columnoid, string &oid,\n                     string pattern, integer mode\n                     [, string contextName, NonLocalArgs])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "searchColumn performs an SNMP walk on a portion of the MIB searching for objects with values equal to the 'pattern' parameter.",
      "ja": "searchColumnは、MIBの一部でSNMPウォークを実行し、「パターン」パラメーターに等しい値を持つオブジェクトを検索します。"
    },
    {
      "indent": 9,
      "text": "'columnoid' constrains the search to those variables that share the same OID prefix (i.e., those that are beneath it in the OID tree).",
      "ja": "'columnoid'は、同じOIDプレフィックスを共有する変数（つまり、OIDツリーでその下にある変数）に検索を制限します。"
    },
    {
      "indent": 9,
      "text": "A getnext request will be sent requesting the object identifier 'oid'. If 'oid' is an empty string, the value of 'columnoid' will be sent.",
      "ja": "オブジェクト識別子「oid」を要求するgetnext要求が送信されます。 「oid」が空の文字列の場合、「columnoid」の値が送信されます。"
    },
    {
      "indent": 9,
      "text": "The value returned in each response packet will be transformed to a string representation of the value of the returned variable. The string representation of the value will be formed by putting the value in the form dictated by the \"Form of SNMP Values\" rules, and then by performing the ToString() function on this value, forming 'SearchString'.",
      "ja": "各応答パケットで返される値は、返される変数の値の文字列表現に変換されます。 値の文字列表現は、「SNMP値の形式」ルールで指定された形式で値を入力し、この値に対してToString（）関数を実行して「SearchString」を形成することにより形成されます。"
    },
    {
      "indent": 9,
      "text": "The 'mode' value controls what type of match to perform on this 'SearchString' value. There are 6 possibilities for mode:",
      "ja": "「mode」値は、この「SearchString」値に対して実行する一致のタイプを制御します。 モードには6つの可能性があります。"
    },
    {
      "indent": 11,
      "text": "Mode Search Action ExactMatch Case sensitive exact match of 'pattern' and 'SearchString'. ExactCaseMatch Case insensitive exact match of 'pattern' and 'SearchString'. SubstringMatch Case sensitive substring match, finding 'pattern' in 'SearchString'. SubstringCaseMatch Case insensitive substring match, finding 'pattern' in 'SearchString'. RegexpMatch Case sensitive regular expression match, searching 'SearchString' for the regular expression given in 'pattern'.",
      "ja": "モード検索アクションExactMatch「pattern」と「SearchString」の大文字と小文字を区別する完全一致。 ExactCaseMatch「pattern」と「SearchString」の大文字と小文字を区別しない完全一致。 SubstringMatch大文字と小文字を区別する部分文字列の一致。「SearchString」で「パターン」を見つけます。 SubstringCaseMatch大文字と小文字を区別しない部分文字列一致。「SearchString」で「パターン」を検索します。 RegexpMatch大文字と小文字を区別する正規表現の一致。「パターン」で指定された正規表現を「SearchString」で検索します。"
    },
    {
      "indent": 11,
      "text": "RegexpCaseMatch Case insensitive regular expression match, searching 'SearchString' for the regular expression given in 'pattern'.",
      "ja": "RegexpCaseMatch大文字と小文字を区別しない正規表現の一致。「pattern」で指定された正規表現を「SearchString」で検索します。"
    },
    {
      "indent": 9,
      "text": "Constants for the values of 'mode' are defined in the 'Constants' section below.",
      "ja": "「モード」の値の定数は、以下の「定数」セクションで定義されています。"
    },
    {
      "indent": 9,
      "text": "searchColumn uses the POSIX extended regular expressions defined in POSIX 1003.2.",
      "ja": "searchColumnは、POSIX 1003.2で定義されているPOSIX拡張正規表現を使用します。"
    },
    {
      "indent": 9,
      "text": "The optional 'contextName' argument contains the SNMP context on which to operate. If 'contextName' is not present, the contextName of 'this element' will be used. If 'contextName' is the zero-length string, the default context is used.",
      "ja": "オプションの「contextName」引数には、操作対象のSNMPコンテキストが含まれます。 「contextName」が存在しない場合、「this element」のcontextNameが使用されます。 'contextName'が長さゼロの文字列の場合、デフォルトのコンテキストが使用されます。"
    },
    {
      "indent": 9,
      "text": "The optional 'NonLocalArgs' provide addressing and security information to perform SNMP operations on a system different from that of 'this element'.",
      "ja": "オプションの「NonLocalArgs」は、「この要素」とは異なるシステムでSNMP操作を実行するためのアドレス指定とセキュリティ情報を提供します。"
    },
    {
      "indent": 9,
      "text": "If a match is found, 'oid' is set to the OID of the matched value, and 1 is returned. If the search traverses beyond columnoid or returns an error without finding a match, zero is returned, and 'oid' isn't modified.",
      "ja": "一致が見つかった場合、「oid」は一致した値のOIDに設定され、1が返されます。 検索がcolumnoidを超えて横断するか、一致するものを見つけずにエラーを返す場合、ゼロが返され、「oid」は変更されません。"
    },
    {
      "indent": 9,
      "text": "To find the first match, the caller should set 'oid' to the empty string. To find additional matches, subsequent calls to searchColumn should have 'oid' set to the OID of the last match, an operation that searchColumn performs automatically.",
      "ja": "最初の一致を見つけるには、呼び出し元は 'oid'を空の文字列に設定する必要があります。 追加の一致を見つけるには、後続のsearchColumnの呼び出しで、最後の一致のOIDに 'oid'を設定する必要があります。これは、searchColumnが自動的に実行する操作です。"
    },
    {
      "indent": 9,
      "text": "For example:\n    To find an ethernet interface\n    oid = \"\";\n    searchColumn(\"ifType\", oid, \"6\", 0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "This sends a getnext request for ifType and continues to walk the tree until a value matching 6 is found or a variable returns that is not in the 'ifType' subtree.",
      "ja": "これは、ifTypeのgetnextリクエストを送信し、6に一致する値が見つかるか、「ifType」サブツリーにない変数が返されるまでツリーをウォークし続けます。"
    },
    {
      "indent": 9,
      "text": "To find the next ethernet interface, assuming that interface 3 was discovered to be the first:",
      "ja": "インターフェイス3が最初に発見されたと仮定して、次のイーサネットインターフェイスを見つけるには："
    },
    {
      "indent": 13,
      "text": "oid = \"ifType.3\";\nsearchColumn(\"ifType\", oid, \"6\", 0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "In a loop to determine all the ethernet interfaces, this looks as follows:",
      "ja": "すべてのイーサネットインターフェイスを決定するループでは、これは次のようになります。"
    },
    {
      "indent": 13,
      "text": "oid = \"\";\nwhile(searchColumn(\"ifType\", oid, \"6\", 0)){\n  /* Do something with oid */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Note that in the preceding examples, \"ifType\" is used as a notational convenience, and the actual code downloaded to the policy MIB agent must use the string \"1.3.6.1.2.1.2.2.1.3\" as there may be no MIB compiler (or MIB file) available on the policy MIB agent.",
      "ja": "上記の例では、表記上の便宜上「ifType」が使用されており、MIBコンパイラがないため、ポリシーMIBエージェントにダウンロードされる実際のコードは文字列「1.3.6.1.2.1.2.2.1.3」を使用する必要があることに注意してください（ またはポリシーMIBエージェントで利用可能なMIBファイル）。"
    },
    {
      "indent": 9,
      "text": "Note that if the value of 'columnoid' is too short and thus references too much of the object identifier tree (e.g., \"1.3.6\"), 'columnoid' could end up searching a huge number of variables (if the value was \"1.3.6\", it would search ALL variables on the agent). It is the responsibility of the caller to make sure that 'columnoid' is set appropriately.",
      "ja": "「columnoid」の値が短すぎてオブジェクト識別子ツリーの参照が多すぎる場合（「1.3.6」など）、「columnoid」は膨大な数の変数を検索することになります（値が「 1.3.6 \"、エージェント上のすべての変数を検索します）。 「columnoid」が適切に設定されていることを確認するのは、呼び出し側の責任です。"
    },
    {
      "indent": 0,
      "text": "8.1.3.5. setRowStatus()",
      "section_title": true,
      "ja": "8.1.3.5。 setRowStatus（）"
    },
    {
      "indent": 6,
      "text": "integer setRowStatus(string oid, integer maxTries\n                     [, integer freeOnException , integer seed\n                      , string contextName, NonLocalArgs])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "setRowStatus is used to automate the process of finding an unused row in a read-create table that uses RowStatus whose index contains an arbitrary integer component for uniqueness.",
      "ja": "setRowStatusは、一意性のために任意の整数コンポーネントをインデックスに含むRowStatusを使用する、読み取り作成テーブルで未使用の行を見つけるプロセスを自動化するために使用されます。"
    },
    {
      "indent": 9,
      "text": "'oid' is a string containing an ASCII dotted-decimal representation of an object identifier, with one of the subids replaced with a '*' character (e.g., \"1.3.6.1.3.1.99.1.2.1.9.*\"). 'oid' must reference an 'instance' of the RowStatus object, and the '*' must replace any integer index item that may be set to some random value.",
      "ja": "「oid」は、サブ識別子の1つが「*」文字に置き換えられたオブジェクト識別子のASCIIドット付き10進表現を含む文字列です（例：「1.3.6.1.3.1.99.1.2.1.9。*」）。 「oid」はRowStatusオブジェクトの「インスタンス」を参照する必要があり、「*」は何らかのランダムな値に設定される可能性のある整数インデックス項目を置き換える必要があります。"
    },
    {
      "indent": 9,
      "text": "setRowStatus will come up with a number for the selected index item and will attempt to create the instance with the createAndWait state. If the attempt fails, it will retry with a different random index value. It will attempt this no more than 'maxTries' times.",
      "ja": "setRowStatusは、選択されたインデックスアイテムの番号を見つけ出し、createAndWait状態でインスタンスを作成しようとします。 試行が失敗した場合、異なるランダムインデックス値で再試行します。 これは、 'maxTries'回までしか試行しません。"
    },
    {
      "indent": 9,
      "text": "If the optional 'freeOnException' argument is present and equal to 1, the agent will free this row by setting RowStatus to 'destroy' if, later in the same script invocation, this script dies with a run-time exception or by a call to fail(). Note that this does not apply to exceptions experienced in subsequent invocations of the script.",
      "ja": "オプションの 'freeOnException'引数が存在し、1に等しい場合、エージェントは、後で同じスクリプト呼び出しで、このスクリプトがランタイム例外で終了するか、またはの呼び出しによってRowStatusを 'destroy'に設定することにより、この行を解放します 不合格（）。 これは、スクリプトの後続の呼び出しで発生する例外には適用されないことに注意してください。"
    },
    {
      "indent": 9,
      "text": "If the optional 'seed' argument is present, the initial index will be set to 'seed'. Otherwise it will be random. 'seed' may not be present if the 'freeOnException' argument is not present.",
      "ja": "オプションの「seed」引数が存在する場合、初期インデックスは「seed」に設定されます。 それ以外の場合はランダムになります。 'freeOnException'引数が存在しない場合、 'seed'は存在しない場合があります。"
    },
    {
      "indent": 9,
      "text": "The optional 'contextName' argument contains the SNMP context on which to operate. If 'contextName' is not present, the contextName of 'this element' will be used. If 'contextName' is the zero-length string, the default context is used.",
      "ja": "オプションの「contextName」引数には、操作対象のSNMPコンテキストが含まれます。 「contextName」が存在しない場合、「this element」のcontextNameが使用されます。 'contextName'が長さゼロの文字列の場合、デフォルトのコンテキストが使用されます。"
    },
    {
      "indent": 9,
      "text": "The optional 'NonLocalArgs' provide addressing and security information to perform an SNMP operation on a system different from that of 'this element'.",
      "ja": "オプションの「NonLocalArgs」は、「この要素」とは異なるシステムでSNMP操作を実行するためのアドレス指定とセキュリティ情報を提供します。"
    },
    {
      "indent": 9,
      "text": "setRowStatus returns the successful integer value for the index. If it is unsuccessful after 'maxTries', or if zero or more than one '*' is in OID, -1 will be returned.",
      "ja": "setRowStatusは、インデックスの成功した整数値を返します。 「maxTries」の後に失敗した場合、またはOIDにゼロまたは複数の「*」がある場合、-1が返されます。"
    },
    {
      "indent": 9,
      "text": "The createRow function (below) can also be used when adding rows to tables. Although createRow has more functionality, setRowStatus may be preferable in certain situations (for example, to have the opportunity to inspect default values created by the agent).",
      "ja": "テーブルに行を追加するときに、createRow関数（下記）も使用できます。 createRowにはより多くの機能がありますが、特定の状況ではsetRowStatusが望ましい場合があります（たとえば、エージェントによって作成されたデフォルト値を検査する機会がある場合）。"
    },
    {
      "indent": 0,
      "text": "8.1.3.6. createRow()",
      "section_title": true,
      "ja": "8.1.3.6。 createRow（）"
    },
    {
      "indent": 6,
      "text": "integer createRow(integer reqPDU, integer reqNumVarbinds,\n                  integer statusColumn, integer maxTries,\n                  integer indexRange,\n                  integer &respPDU, integer &respNumVarbinds,\n                  integer &index\n                  [, integer freeOnException, string contextName,\n                  NonLocalArgs])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "createRow is used to automate the process of creating a row in a read-create table whose index contains an arbitrary integer component for uniqueness. In particular, it encapsulates the algorithm behind either the createAndWait or createAndGo mechanism and the algorithm for finding an unused row in the table. createRow is not useful for creating rows in tables whose indexes don't contain an arbitrary integer component.",
      "ja": "createRowは、一意性のためにインデックスに任意の整数コンポーネントが含まれる読み取り作成テーブルに行を作成するプロセスを自動化するために使用されます。 特に、createAndWaitまたはcreateAndGoメカニズムの背後にあるアルゴリズムと、テーブル内の未使用の行を見つけるためのアルゴリズムをカプセル化します。 createRowは、インデックスに任意の整数コンポーネントが含まれていないテーブルに行を作成するのに役立ちません。"
    },
    {
      "indent": 9,
      "text": "createRow will perform the operation by sending 'reqPDU' and returning the results in 'respPDU'. Both 'reqPDU' and",
      "ja": "createRowは、「reqPDU」を送信し、結果を「respPDU」で返すことで操作を実行します。 「reqPDU」と"
    },
    {
      "indent": 9,
      "text": "'respPDU' must previously have been allocated with newPDU. 'reqPDU' and 'respPDU' may both contain the same PDU handle, in which case the 'reqPDU' is sent and then replaced with the contents of the received PDU.",
      "ja": "「respPDU」は、以前にnewPDUで割り当てられていなければなりません。 「reqPDU」と「respPDU」の両方に同じPDUハンドルが含まれる場合があります。その場合、「reqPDU」が送信され、受信したPDUの内容に置き換えられます。"
    },
    {
      "indent": 9,
      "text": "'reqNumVarbinds' is an integer greater than zero that specifies which varbinds in the PDU will be used in this operation. The first 'reqNumVarbinds' in the PDU are used. Each such varbind must be of a special form in which the object name must have one of its subids replaced with a '*' character (e.g., \"1.3.6.1.3.1.99.1.2.1.9.*\"). The subid selected to be replaced will be an integer index item that may be set to some random value. The same subid should be selected in each varbind in the PDU.",
      "ja": "「reqNumVarbinds」は、PDU内のどの変数がこの操作で使用されるかを指定するゼロより大きい整数です。 PDUの最初の「reqNumVarbinds」が使用されます。 このような各varbindは、オブジェクト名のサブIDの1つを「*」文字に置き換えた特別な形式である必要があります（例：「1.3.6.1.3.1.99.1.2.1.9。*」）。 置換するために選択されたサブIDは、ランダムな値に設定される可能性のある整数のインデックスアイテムになります。 PDUの各変数で同じサブIDを選択する必要があります。"
    },
    {
      "indent": 9,
      "text": "'respNumVarbinds' will be modified to contain the number of varbinds received in the last response PDU.",
      "ja": "「respNumVarbinds」は、最後の応答PDUで受信したvarbindの数を含むように変更されます。"
    },
    {
      "indent": 9,
      "text": "'statusColumn' identifies which varbind in 'pdu' should be treated as the RowStatus column, where 0 identifies the 1st varbind.",
      "ja": "'statusColumn'は、 'pdu'のどのvarbindをRowStatus列として扱うかを識別します。0は最初のvarbindを識別します。"
    },
    {
      "indent": 9,
      "text": "createRow will come up with a random integer index value and will substitute that value in place of the '*' subid in each varbind. It will then set the value of the RowStatus column to select the 'createAndGo' mechanism and execute the set. If the attempt fails due to the unavailability of the 'createAndGo' mechanism, it will retry with the 'createAndWait' mechanism selected. If the attempt fails because the chosen index value is already in use, the operation will be retried with a different random index value. It will continue to retry different index values until it succeeds, until it has made 'maxTries' attempts, or until it encounters an error. The value of 'maxTries' should be chosen to be high enough to minimize the chance that as the table fills up an attempt to create a new entry will 'collide' too often and fail.",
      "ja": "createRowはランダムな整数インデックス値を見つけ出し、各varbindの「*」subidの代わりにその値を置き換えます。 次に、RowStatus列の値を設定して「createAndGo」メカニズムを選択し、セットを実行します。 「createAndGo」メカニズムが利用できないために試行が失敗した場合、「createAndWait」メカニズムが選択された状態で再試行されます。 選択したインデックス値がすでに使用されているために試行が失敗した場合、操作は別のランダムインデックス値で再試行されます。 成功するまで、「maxTries」試行を行うまで、またはエラーが発生するまで、異なるインデックス値を再試行し続けます。 「maxTries」の値は、テーブルがいっぱいになって新しいエントリを作成しようとする試みが頻繁に「衝突」して失敗する可能性を最小限に抑えるのに十分高い値を選択する必要があります。"
    },
    {
      "indent": 9,
      "text": "All random index values must be between 1 and 'indexRange', inclusive. This is so that values are not attempted for an index that fall outside of that index's restricted range (e.g., 1..65535).",
      "ja": "すべてのランダムインデックス値は、1〜 'indexRange'である必要があります。 これは、そのインデックスの制限範囲（1..65535など）の範囲外にあるインデックスに対して値が試行されないようにするためです。"
    },
    {
      "indent": 9,
      "text": "If the optional 'freeOnException' argument is present and equal to 1, the agent will free this row by setting RowStatus to 'destroy' if, later in the same script invocation, this script dies with a run-time exception or by a call to fail(). Note that this does not apply to exceptions experienced in subsequent invocations of the script.",
      "ja": "オプションの 'freeOnException'引数が存在し、1に等しい場合、エージェントは、後で同じスクリプト呼び出しで、このスクリプトがランタイム例外で終了するか、またはの呼び出しによってRowStatusを 'destroy'に設定することにより、この行を解放します 不合格（）。 これは、スクリプトの後続の呼び出しで発生する例外には適用されないことに注意してください。"
    },
    {
      "indent": 9,
      "text": "The optional 'contextName' argument contains the SNMP context on which to operate. If 'contextName' is not present, the contextName of 'this element' will be used. If 'contextName' is the zero-length string, the default context is used.",
      "ja": "オプションの「contextName」引数には、操作対象のSNMPコンテキストが含まれます。 「contextName」が存在しない場合、「this element」のcontextNameが使用されます。 'contextName'が長さゼロの文字列の場合、デフォルトのコンテキストが使用されます。"
    },
    {
      "indent": 9,
      "text": "The optional 'NonLocalArgs' provide addressing and security information to perform an SNMP operation on a system different from that of 'this element'.",
      "ja": "オプションの「NonLocalArgs」は、「この要素」とは異なるシステムでSNMP操作を実行するためのアドレス指定とセキュリティ情報を提供します。"
    },
    {
      "indent": 9,
      "text": "Note that no actual SNMP PDU has to be generated and parsed when the policy MIB agent resides on the same system as the managed elements. If no PDU is generated, the agent must correctly simulate the behavior of the SNMP Response PDU, particularly in case of an error.",
      "ja": "ポリシーMIBエージェントが管理対象要素と同じシステムにある場合、実際のSNMP PDUを生成および解析する必要はありません。 PDUが生成されない場合、エージェントは、特にエラーの場合に、SNMP応答PDUの動作を正しくシミュレートする必要があります。"
    },
    {
      "indent": 9,
      "text": "This function returns zero unless an error occurs, in which case it returns the proper SNMP Error Constant. If an error occurred, respPDU will contain the last response PDU as received from the agent unless no response PDU was received, in which case respNumVarbinds will be 0. In any event, readError may be called on the PDU to determine error information for the transaction.",
      "ja": "この関数は、エラーが発生しない限りゼロを返します。エラーが発生した場合、適切なSNMPエラー定数を返します。 エラーが発生した場合、respPDUには、応答PDUが受信されない限り、エージェントから受信された最後の応答PDUが含まれます。その場合、respNumVarbindsは0になります。 。"
    },
    {
      "indent": 9,
      "text": "The 'index' parameter returns the chosen index. If successful, 'index' will be set to the successful integer index. If no SNMP error occurs but the operation does not succeed due to the following reasons, 'index' will be set to -1:",
      "ja": "'index'パラメーターは、選択したインデックスを返します。 成功した場合、「index」は成功した整数インデックスに設定されます。 SNMPエラーは発生しないが、次の理由により操作が成功しない場合、「インデックス」は-1に設定されます。"
    },
    {
      "indent": 12,
      "text": "1) Unsuccessful after 'maxTries'. 2) An object name had no '*' in it. 3) An object name had more than one '*' in it.",
      "ja": "1）「maxTries」の後に失敗しました。 2）オブジェクト名に「*」が含まれていません。 3）オブジェクト名に複数の「*」が含まれていました。"
    },
    {
      "indent": 9,
      "text": "For example, createRow() might be used as follows:",
      "ja": "たとえば、createRow（）は次のように使用できます。"
    },
    {
      "indent": 9,
      "text": "var index, pdu = newPDU(), nVars = 0;",
      "ja": "var index、pdu = newPDU（）、nVars = 0;"
    },
    {
      "indent": 9,
      "text": "writeVar(pdu, nVars++, \"hlHostControlDataSource.*\",\n         \"ifIndex.\" + ev(0), Oid);\nwriteVar(pdu, nVars++, \"hlHostControlNlMaxDesiredEntries.*\",\n         1000, Integer);\nwriteVar(pdu, nVars++, \"hlHostControlAlMaxDesiredEntries.*\",\n         1000, Integer);\nwriteVar(pdu, nVars++, \"hlHostControlOwner.*\", \"policy\",\n         String);\nwriteVar(pdu, nVars++, \"hlHostControlStatus.*\", \"active(1)\",\n         Integer);\nif (createRow(pdu, nVars, 4, 20, 65535,\n              pdu, nVars, index) != 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": " || index == -1) return; // index now contains index of new row",
      "ja": "|| index == -1）return; //インデックスに新しい行のインデックスが含まれるようになりました"
    },
    {
      "indent": 0,
      "text": "8.1.3.7. counterRate()",
      "section_title": true,
      "ja": "8.1.3.7。 counterRate（）"
    },
    {
      "indent": 3,
      "text": "When a policy wishes to make a decision based on the rate of a counter, it faces a couple of problems:",
      "ja": "ポリシーがカウンターのレートに基づいて決定を行いたい場合、いくつかの問題に直面します。"
    },
    {
      "indent": 3,
      "text": "1. It may have to run every X minutes but have to make decisions on rates calculated over at least Y minutes, where Y > X. This would require the complexity of managing a queue of old counter values.",
      "ja": "1. X分ごとに実行する必要がありますが、少なくともY分（Y> X）で計算されるレートを決定する必要があります。これには、古いカウンター値のキューを管理する複雑さが必要になります。"
    },
    {
      "indent": 3,
      "text": "2. The policy script has no control over exactly when it will run.",
      "ja": "2.ポリシースクリプトは、いつ実行されるかを正確に制御することはできません。"
    },
    {
      "indent": 3,
      "text": "The counterRate() function is designed to surmount these problems easily.",
      "ja": "counterRate（）関数は、これらの問題を簡単に克服できるように設計されています。"
    },
    {
      "indent": 6,
      "text": "integer counterRate(string oid, integer minInterval [, integer 64bit, string discOid, integer discMethod, string contextName, NonLocalArgs])",
      "ja": "整数counterRate（文字列oid、整数minInterval [、整数64ビット、文字列discOid、整数discMethod、文字列contextName、NonLocalArgs]）"
    },
    {
      "indent": 9,
      "text": "'counterRate' retrieves the variable specified by oid once per invocation. It keeps track of timestamped values retrieved on previous invocations by this execution context so that it can calculate a rate over a period longer than that since the last invocation.",
      "ja": "'counterRate'は、呼び出しごとにoidで指定された変数を取得します。 この実行コンテキストによって以前の呼び出しで取得されたタイムスタンプ付きの値を追跡するため、最後の呼び出し以降の期間よりも長い期間にわたってレートを計算できます。"
    },
    {
      "indent": 9,
      "text": "'oid' is the object identifier of the counter value that will be retrieved. The most recent previously saved value of the same object identifier that is at least 'minInterval' seconds old will be subtracted from the newly retrieved value, yielding a delta. If 'minInterval' is zero, this delta will be returned. Otherwise, this delta will be divided by the number of seconds elapsed between the two retrievals, and the integer-valued result will be returned (rounding down when necessary).",
      "ja": "「oid」は、取得されるカウンタ値のオブジェクト識別子です。 少なくとも「minInterval」秒古い同じオブジェクト識別子の以前に保存された最新の値が、新しく取得された値から差し引かれ、デルタが生成されます。 「minInterval」がゼロの場合、このデルタが返されます。 それ以外の場合、このデルタは2つの取得間の経過秒数で除算され、整数値の結果が返されます（必要に応じて切り捨てられます）。"
    },
    {
      "indent": 9,
      "text": "If there was no previously saved retrieval older than 'minInterval' seconds, then -1 will be returned. It is an RTE if the query returns noSuchName, noSuchInstance, or noSuchObject or an object that is not of type Counter32 or Counter64.",
      "ja": "「minInterval」秒よりも古い保存済みの検索がなかった場合、-1が返されます。 クエリがnoSuchName、noSuchInstance、noSuchObject、またはCounter32またはCounter64タイプではないオブジェクトを返す場合、RTEです。"
    },
    {
      "indent": 9,
      "text": "The delta calculation will allow for 32-bit counter semantics if it encounters rollover between the two retrievals, unless the optional argument '64bit' is present and equal to 1, in which case it will allow for 64-bit counter semantics.",
      "ja": "オプションの引数 '64bit'が存在し、1に等しい場合を除き、2つの取得間でロールオーバーが発生した場合、デルタ計算は32ビットカウンターセマンティクスを許可します。その場合、64ビットカウンターセマンティクスを許可します。"
    },
    {
      "indent": 9,
      "text": "'discOid' and 'discMethod' may only be present together. 'discOid' contains an object identifier of a discontinuity indicator value that will be retrieved simultaneously with each counter value:",
      "ja": "「discOid」と「discMethod」は一緒にしか存在できません。 「discOid」には、各カウンタ値と同時に取得される不連続インジケータ値のオブジェクト識別子が含まれます。"
    },
    {
      "indent": 12,
      "text": "1. If 'discMethod' is equal to 1 and the discontinuity indicator is less than the last one retrieved, then a discontinuity is indicated. 2. If 'discMethod' is equal to 2 and the discontinuity indicated is different from the last one retrieved, then a discontinuity is indicated.",
      "ja": "1. 'discMethod'が1に等しく、不連続インジケータが最後に取得したものより小さい場合、不連続が示されます。 2. 'discMethod'が2に等しく、示された不連続が最後に取得された不連続と異なる場合、不連続が示されます。"
    },
    {
      "indent": 9,
      "text": "If this value indicates a discontinuity, this counter value (and its timestamp) will be stored, but all previously stored counter values will be invalidated and -1 will be returned.",
      "ja": "この値が不連続を示す場合、このカウンター値（およびそのタイムスタンプ）は保存されますが、以前に保存されたすべてのカウンター値は無効になり、-1が返されます。"
    },
    {
      "indent": 9,
      "text": "The implementation will have to store a number of timestamped counter values. The implementation must keep all values that are newer than minInterval seconds, plus the newest value that is older than minInterval seconds. Other than this one value that is older than minInterval seconds, the implementation should discard any older values.",
      "ja": "実装では、多くのタイムスタンプ付きカウンター値を保存する必要があります。 実装では、minInterval秒より新しいすべての値と、minInterval秒より古い最新の値を保持する必要があります。 minInterval秒よりも古いこの1つの値以外は、実装は古い値を破棄する必要があります。"
    },
    {
      "indent": 9,
      "text": "For example: Policy that executes every 60 seconds: rate = counterRate(\"ifInOctets.$*\", 300); if (rate > 1000000) ...",
      "ja": "例：60秒ごとに実行するポリシー：rate = counterRate（ \"ifInOctets。$ *\"、300）; if（rate> 1000000）..."
    },
    {
      "indent": 9,
      "text": "Another example, with a discontinuity indicator:",
      "ja": "不連続インジケータを使用した別の例："
    },
    {
      "indent": 11,
      "text": "Policy that executes every 60 seconds: rate = counterRate(\"ifInOctets.$*\", 300, 0, \"sysUpTime.0\", 1); if (rate > 1000000) ...",
      "ja": "60秒ごとに実行するポリシー：rate = counterRate（ \"ifInOctets。$ *\"、300、0、 \"sysUpTime.0\"、1）; if（rate> 1000000）..."
    },
    {
      "indent": 9,
      "text": "Another example, with zero minInterval: Policy that executes every 60 seconds: delta = counterRate(\"ifInErrors.$*\", 0); if (delta > 100) ...",
      "ja": "minIntervalがゼロの別の例：60秒ごとに実行されるポリシー：delta = counterRate（ \"ifInErrors。$ *\"、0）; if（delta> 100）..."
    },
    {
      "indent": 9,
      "text": "The optional 'contextName' argument contains the SNMP context on which to operate. If 'contextName' is not present, the contextName of 'this element' will be used. If 'contextName' is the zero-length string, the default context is used.",
      "ja": "オプションの「contextName」引数には、操作対象のSNMPコンテキストが含まれます。 「contextName」が存在しない場合、「this element」のcontextNameが使用されます。 'contextName'が長さゼロの文字列の場合、デフォルトのコンテキストが使用されます。"
    },
    {
      "indent": 0,
      "text": "8.1.4. General SNMP Functions",
      "section_title": true,
      "ja": "8.1.4。 一般的なSNMP機能"
    },
    {
      "indent": 3,
      "text": "It is desirable that a general SNMP interface have the ability to perform SNMP operations on multiple variables at once and that it allow multiple varbind lists to exist at once. The newPdu, readVar, and writeVar functions exist to provide these facilities in a language without pointers, arrays, and memory allocators.",
      "ja": "一般的なSNMPインターフェースは、複数の変数に対して一度にSNMP操作を実行する機能を持ち、複数のvarbindリストが一度に存在できることが望ましいです。 newPdu、readVar、およびwriteVar関数は、ポインター、配列、およびメモリアロケーターなしでこれらの機能を言語で提供するために存在します。"
    },
    {
      "indent": 3,
      "text": "newPDU is called to allocate a PDU and return an integer handle to it. As PDUs are automatically freed when the script exits and can be reused during execution, there is no freePDU().",
      "ja": "newPDUを呼び出して、PDUを割り当て、整数ハンドルを返します。 スクリプトが終了するとPDUは自動的に解放され、実行中に再利用できるため、freePDU（）はありません。"
    },
    {
      "indent": 3,
      "text": "readVar and writeVar access a variable length varbind list for a PDU. The PDU handle and the index of the variable within that PDU are specified in every readVar and writeVar operation. Once a PDU has been fully specified by one or more calls to writeVar, it is passed to snmpSend (by referencing the PDU handle) and the number of varbinds to be included in the operation. When a response is returned, the contents of the response are returned in another PDU and may be read by one or more calls to readVar. Error information may be read from the PDU with the readError function. Because GetBulk PDUs send additional information in the SNMP header, the writeBulkParameters function is provided to configure these parameters.",
      "ja": "readVarおよびwriteVarは、PDUの可変長varbindリストにアクセスします。 PDUハンドルと、そのPDU内の変数のインデックスは、すべてのreadVarおよびwriteVar操作で指定されます。 writeVarの1つ以上の呼び出しによってPDUが完全に指定されると、（PDUハンドルを参照することにより）snmpSendに渡され、操作に含まれるvarbindの数が渡されます。 応答が返されると、応答の内容が別のPDUで返され、readVarの1つ以上の呼び出しで読み取られる場合があります。 エラー情報は、readError関数を使用してPDUから読み取ることができます。 GetBulk PDUはSNMPヘッダーで追加情報を送信するため、これらのパラメーターを構成するためにwriteBulkParameters関数が提供されています。"
    },
    {
      "indent": 3,
      "text": "Varbinds in this data store are created automatically whenever they are written by any writeVar or snmpSend operation.",
      "ja": "このデータストア内の変数バインドは、writeVarまたはsnmpSend操作によって書き込まれるたびに自動的に作成されます。"
    },
    {
      "indent": 3,
      "text": "For example:\n  var pdu = newPDU();\n  var nVars = 0, oid, type, value;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "writeVar(pdu, nVars++, \"sysDescr.0\", \"\", Null);\nwriteVar(pdu, nVars++, \"sysOID.0\", \"\", Null);\nwriteVar(pdu, nVars++, \"ifNumber.0\", \"\", Null);\nif (snmpSend(pdu, nVars, Get, pdu, nVars))\n    return;\nreadVar(pdu, 0, oid, value, type);\nreadVar(pdu, 1, oid, value, type);\nreadVar(pdu, 2, oid, value, type);\n...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "or,\n  var pdu = newPDU();\n  var nVars = 0, oid1, oid2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "writeVar(pdu, nVars++, \"ifIndex\", \"\", Null);\nwriteVar(pdu, nVars++, \"ifType\", \"\", Null);\nwhile(!done){\n  if (snmpSend(pdu, nVars, Getnext, pdu, nVars))\n      continue;\n  readVar(pdu, 0, oid1, value, type);\n  readVar(pdu, 1, oid2, value, type);\n  /* leave OIDs alone, now PDU #0 is set up for next step\n     in table walk. */\n  if (oidncmp(oid1, \"ifIndex\", oidlen(\"ifIndex\")))\n    done = 0;\n  ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that in the preceding examples, descriptors such as ifType and sysDescr are used in object identifiers solely as a notational convenience. The actual code downloaded to the policy MIB agent must use a dotted decimal notation only, as there may be no MIB compiler (or MIB file) available on the policy MIB agent.",
      "ja": "前述の例では、ifTypeやsysDescrなどの記述子は、表記上の便宜上、オブジェクト識別子でのみ使用されていることに注意してください。 ポリシーMIBエージェントで使用可能なMIBコンパイラー（またはMIBファイル）がない場合があるため、ポリシーMIBエージェントにダウンロードされる実際のコードはドット付き10進表記のみを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "To conform to this specification, implementations must allow each policy script invocation to allocate at least 5 PDUs with at least 64 varbinds per list. It is suggested that implementations limit the total number of PDUs per invocation to protect other script invocations from a malfunctioning script (e.g., a script that calls newPDU() in a loop).",
      "ja": "この仕様に準拠するには、各ポリシースクリプトの呼び出しが、リストごとに少なくとも64個のvarbindを持つ少なくとも5つのPDUを割り当てることを実装が許可する必要があります。 実装は呼び出しごとのPDUの総数を制限して、誤動作しているスクリプト（ループ内でnewPDU（）を呼び出すスクリプト）から他のスクリプト呼び出しを保護することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "8.1.4.1. newPDU()",
      "section_title": true,
      "ja": "8.1.4.1。 newPDU（）"
    },
    {
      "indent": 6,
      "text": "integer newPDU()",
      "ja": "整数newPDU（）"
    },
    {
      "indent": 9,
      "text": "newPDU will allocate a new PDU and return a handle to the PDU. If no PDU could be allocated, -1 will be returned. The PDU's initial values of nonRepeaters and maxRepetitions will be zero.",
      "ja": "newPDUは新しいPDUを割り当て、PDUにハンドルを返します。 PDUを割り当てることができなかった場合、-1が返されます。 nonRepeatersおよびmaxRepetitionsのPDUの初期値はゼロになります。"
    },
    {
      "indent": 0,
      "text": "8.1.4.2. writeVar()",
      "section_title": true,
      "ja": "8.1.4.2。 writeVar（）"
    },
    {
      "indent": 6,
      "text": "writeVar(integer pdu, integer varBindIndex,\n         string oid, var value, integer type)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "writeVar will store 'oid', 'value', and 'type' in the specified varbind.",
      "ja": "writeVarは、指定されたvarbindに「oid」、「value」、および「type」を格納します。"
    },
    {
      "indent": 9,
      "text": "'pdu' is the handle to a PDU allocated by newPDU().",
      "ja": "「pdu」は、newPDU（）によって割り当てられたPDUのハンドルです。"
    },
    {
      "indent": 9,
      "text": "'varBindIndex' is a non-negative integer that identifies the varbind within the specified PDU modified by this call. The first varbind is number 0.",
      "ja": "「varBindIndex」は、この呼び出しによって変更された指定されたPDU内のvarbindを識別する負でない整数です。 最初のvarbindは番号0です。"
    },
    {
      "indent": 9,
      "text": "'oid' is a string containing an ASCII dotted-decimal representation of an object identifier (e.g., \"1.3.6.1.2.1.1.1.0\").",
      "ja": "「oid」は、オブジェクト識別子のASCIIドット付き10進表現を含む文字列です（例：「1.3.6.1.2.1.1.1.0」）。"
    },
    {
      "indent": 9,
      "text": "'value' is the value to be stored, of a type appropriate to the 'type' parameter.",
      "ja": "「値」は、「タイプ」パラメーターに適したタイプの、保管される値です。"
    },
    {
      "indent": 9,
      "text": "'type' will be the type of the value parameter and will be set to one of the values for DataType Constants.",
      "ja": "'type'は値パラメーターのタイプであり、DataType定数の値の1つに設定されます。"
    },
    {
      "indent": 9,
      "text": "It is an RTE if any of the parameters don't conform to the rules above.",
      "ja": "パラメータのいずれかが上記のルールに適合しない場合、RTEです。"
    },
    {
      "indent": 0,
      "text": "8.1.4.3. readVar()",
      "section_title": true,
      "ja": "8.1.4.3。 readVar（）"
    },
    {
      "indent": 6,
      "text": "readVar(integer pdu, integer varBindIndex, string &oid,\n        var &value, integer &type)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "readVar will retrieve the oid, the value, and its type from the specified varbind.",
      "ja": "readVarは、指定されたvarbindからOID、値、およびその型を取得します。"
    },
    {
      "indent": 9,
      "text": "'pdu' is the handle to a PDU allocated by newPDU().",
      "ja": "「pdu」は、newPDU（）によって割り当てられたPDUのハンドルです。"
    },
    {
      "indent": 9,
      "text": "'varBindIndex' is a non-negative integer that identifies the varbind within the specified PDU read by this call. The first varbind is number 0.",
      "ja": "「varBindIndex」は、このコールによって読み取られた指定されたPDU内のvarbindを識別する負でない整数です。 最初のvarbindは番号0です。"
    },
    {
      "indent": 9,
      "text": "The object identifier value of the referenced varbind will be copied into the 'oid' parameter, formatted in an ASCII dotted-decimal representation (e.g., \"1.3.6.1.2.1.1.1.0\").",
      "ja": "参照されたvarbindのオブジェクト識別子の値は、ASCIIのドット付き10進表現（「1.3.6.1.2.1.1.1.0」など）でフォーマットされた「oid」パラメーターにコピーされます。"
    },
    {
      "indent": 9,
      "text": "'value' is the value retrieved, of a type appropriate to the 'type' parameter.",
      "ja": "「値」は、「タイプ」パラメーターに適したタイプの取得値です。"
    },
    {
      "indent": 9,
      "text": "'type' is the type of the value parameter and will be set to one of the values for DataType Constants.",
      "ja": "'type'は値パラメーターのタイプであり、DataType定数の値の1つに設定されます。"
    },
    {
      "indent": 9,
      "text": "It is an RTE if 'pdu' doesn't reference a valid PDU or 'varBindIndex' doesn't reference a valid varbind.",
      "ja": "「pdu」が有効なPDUを参照しない場合、または「varBindIndex」が有効なvarbindを参照しない場合、RTEです。"
    },
    {
      "indent": 0,
      "text": "8.1.4.4. snmpSend()",
      "section_title": true,
      "ja": "8.1.4.4。 snmpSend（）"
    },
    {
      "indent": 6,
      "text": "integer snmpSend(integer reqPDU, integer reqNumVarbinds,\n                 integer opcode,\n                 integer &respPDU, integer &respNumVarbinds,\n                 [, string contextName , NonLocalArgs] )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "snmpSend will perform an SNMP operation by sending 'reqPDU' and returning the results in 'respPDU'. Both 'reqPDU' and 'respPDU' must previously have been allocated with newPDU. 'reqPDU' and 'respPDU' may both contain the same PDU handle, in which case the 'reqPDU' is sent and then replaced with the contents of the received PDU. If the opcode specifies a Trap or V2trap, 'respPDU' will not be modified.",
      "ja": "snmpSendは、「reqPDU」を送信し、結果を「respPDU」で返すことにより、SNMP操作を実行します。 「reqPDU」と「respPDU」の両方は、以前にnewPDUで割り当てられていなければなりません。 「reqPDU」と「respPDU」の両方に同じPDUハンドルが含まれる場合があります。その場合、「reqPDU」が送信され、受信したPDUの内容に置き換えられます。 オペコードがトラップまたはV2trapを指定している場合、「respPDU」は変更されません。"
    },
    {
      "indent": 9,
      "text": "'reqNumVarbinds' is an integer greater than zero that specifies which varbinds in the PDU will be used in this operation. The first 'reqNumVarbinds' in the PDU are used. 'respNumVarbinds' will be modified to contain the number of varbinds received in the response PDU, which, in the case of GetBulk or an error, may be substantially different from reqNumVarbinds.",
      "ja": "「reqNumVarbinds」は、PDU内のどの変数がこの操作で使用されるかを指定するゼロより大きい整数です。 PDUの最初の「reqNumVarbinds」が使用されます。 「respNumVarbinds」は、応答PDUで受信されたvarbindの数を含むように変更されます。これは、GetBulkまたはエラーの場合、reqNumVarbindsとは大幅に異なる場合があります。"
    },
    {
      "indent": 9,
      "text": "'opcode' is the type of SNMP operation to perform and must be one of the values for SNMP Operation Constants listed in the 'Constants' section below.",
      "ja": "「opcode」は、実行するSNMP操作のタイプであり、以下の「定数」セクションにリストされているSNMP操作定数の値のいずれかでなければなりません。"
    },
    {
      "indent": 9,
      "text": "The optional 'contextName' argument contains the SNMP context on which to operate. If 'contextName' is not present, the contextName of 'this element' will be used. If 'contextName' is the zero-length string, the default context is used.",
      "ja": "オプションの「contextName」引数には、操作対象のSNMPコンテキストが含まれます。 「contextName」が存在しない場合、「this element」のcontextNameが使用されます。 'contextName'が長さゼロの文字列の場合、デフォルトのコンテキストが使用されます。"
    },
    {
      "indent": 9,
      "text": "Note that no actual SNMP PDU has to be generated and parsed when the policy MIB agent resides on the same system as the managed elements. If no PDU is generated, the agent must correctly simulate the behavior of the SNMP Response PDU, particularly in case of an error.",
      "ja": "ポリシーMIBエージェントが管理対象要素と同じシステムにある場合、実際のSNMP PDUを生成および解析する必要はありません。 PDUが生成されない場合、エージェントは、特にエラーの場合に、SNMP応答PDUの動作を正しくシミュレートする必要があります。"
    },
    {
      "indent": 9,
      "text": "This function returns zero unless an error occurs, in which case it returns the proper SNMP Error Constant. If an error occurred, respPDU will contain the response PDU as received from the agent, unless no response PDU was received, in which case respNumVarbinds will be 0. In any event, readError may be called on the PDU to determine error information for the transaction.",
      "ja": "この関数は、エラーが発生しない限りゼロを返します。エラーが発生した場合、適切なSNMPエラー定数を返します。 エラーが発生した場合、応答PDUが受信されない限り、respPDUにはエージェントから受信した応答PDUが含まれます。この場合、respNumVarbindsは0になります。 。"
    },
    {
      "indent": 9,
      "text": "If an SNMP Version 1 trap is requested (the opcode is Trap(4)), then SNMP Version 2 trap parameters are supplied and converted according to the rules of RFC 3584 [8], section 3.2. The first",
      "ja": "SNMPバージョン1トラップが要求された場合（オペコードはTrap（4））、SNMPバージョン2トラップパラメータが提供され、RFC 3584 [8]、セクション3.2の規則に従って変換されます。 最初"
    },
    {
      "indent": 9,
      "text": "variable binding must be sysUpTime.0, and the second must be snmpTrapOID.0, as per RFC 3416 [7], section 4.2.6. Subsequent variable bindings are copied to the SNMP Version 1 trap PDU in the usual fashion.",
      "ja": "RFC 3416 [7]のセクション4.2.6に従って、変数バインディングはsysUpTime.0でなければならず、2番目はsnmpTrapOID.0でなければなりません。 後続の変数バインディングは、通常の方法でSNMPバージョン1トラップPDUにコピーされます。"
    },
    {
      "indent": 0,
      "text": "8.1.4.5. readError()",
      "section_title": true,
      "ja": "8.1.4.5。 readError（）"
    },
    {
      "indent": 6,
      "text": "readError(integer pdu, integer numVarbinds, integer &errorStatus,\n          integer &errorIndex, integer &hasException)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Returns the error information in a PDU.",
      "ja": "エラー情報をPDUで返します。"
    },
    {
      "indent": 9,
      "text": "'errorStatus' contains the error-status field from the response PDU or a local error constant if the error was generated locally. If no error was experienced or no PDU was ever copied into this PDU, this value will be 0.",
      "ja": "「errorStatus」には、応答PDUからのエラー状態フィールド、またはエラーがローカルで生成された場合はローカルエラー定数が含まれます。 エラーが発生していないか、このPDUにPDUがコピーされていない場合、この値は0になります。"
    },
    {
      "indent": 9,
      "text": "'errorIndex' contains the error-index field from the response PDU. If no PDU was ever copied into this PDU, this value will be 0.",
      "ja": "「errorIndex」は応答PDUからのエラーインデックスフィールドが含まれています。 PDUがこのPDUにコピーされたことがない場合、この値は0になります。"
    },
    {
      "indent": 9,
      "text": "'hasException' will be 1 if any of the first 'numVarbinds' varbinds in the PDU contain an exception (Nosuchobject, Nosuchinstance, Endofmibview); otherwise it will be 0.",
      "ja": "PDUの最初の「numVarbinds」変数のいずれかに例外（Nosuchobject、Nosuchinstance、Endofmibview）が含まれている場合、「hasException」は1になります。 それ以外の場合は0になります。"
    },
    {
      "indent": 9,
      "text": "It is an RTE if 'pdu' does not reference a valid PDU or if 'numVarbinds' references varbinds that aren't valid.",
      "ja": "「pdu」が有効なPDUを参照しない場合、または「numVarbinds」が無効なvarbindを参照する場合、RTEです。"
    },
    {
      "indent": 0,
      "text": "8.1.4.6. writeBulkParameters()",
      "section_title": true,
      "ja": "8.1.4.6。 writeBulkParameters（）"
    },
    {
      "indent": 6,
      "text": "writeBulkParameters(integer pdu, integer nonRepeaters,\n                    integer maxRepetitions)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Modifies the parameters in a PDU in any subsequent GetBulk operation sent by the PDU. 'nonRepeaters' will be copied into the PDU's non-repeaters field, and 'maxRepetitions' into the max-repetitions field.",
      "ja": "PDUによって送信される後続のGetBulk操作で、PDUのパラメーターを変更します。 「nonRepeaters」はPDUのnon-repeatersフィールドにコピーされ、「maxRepetitions」はmax-repetitionsフィールドにコピーされます。"
    },
    {
      "indent": 9,
      "text": "This function may be called before or after writeVar is called to add varbinds to the PDU, but it must be called before the PDU is sent; otherwise, it will have no effect. A new PDU is initialized with nonRepeaters set to zero and maxRepetitions set to zero. If a Bulk PDU is sent before writeBulkParameters is called, these default values will be used. If writeBulkParameters is called to modify a PDU, it is acceptable if this PDU is later sent as a type other than bulk. The writeBulkParameters call will only affect subsequent sends of Bulk PDUs. If a PDU is used to receive the contents of a response, the values of nonRepeaters and maxRepetitions are never modified.",
      "ja": "この関数は、varVindをPDUに追加するためにwriteVarが呼び出される前または後に呼び出されますが、PDUが送信される前に呼び出される必要があります。 そうでない場合、効果はありません。 新しいPDUは、nonRepeatersをゼロに設定し、maxRepetitionsをゼロに設定して初期化されます。 writeBulkParametersが呼び出される前にBulk PDUが送信された場合、これらのデフォルト値が使用されます。 PDUを変更するためにwriteBulkParametersが呼び出された場合、このPDUが後でバルク以外のタイプとして送信されても問題ありません。 writeBulkParameters呼び出しは、バルクPDUの後続の送信にのみ影響します。 PDUを使用して応答のコンテンツを受信する場合、nonRepeatersおよびmaxRepetitionsの値は変更されません。"
    },
    {
      "indent": 0,
      "text": "8.1.5. Constants for SNMP Library Functions",
      "section_title": true,
      "ja": "8.1.5。 SNMPライブラリ関数の定数"
    },
    {
      "indent": 3,
      "text": "The following constants are defined for use with all SNMP Library Functions. Policy code will be executed in an environment where the following constants are declared. (Note that the constant declarations below will not be visible in the policyCondition or policyAction code.) These constants are reserved words and cannot be used for any variable or function name.",
      "ja": "次の定数は、すべてのSNMPライブラリ関数で使用するために定義されています。 ポリシーコードは、次の定数が宣言されている環境で実行されます。 （以下の定数宣言は、policyConditionまたはpolicyActionコードでは表示されないことに注意してください。）これらの定数は予約語であり、変数または関数名には使用できません。"
    },
    {
      "indent": 3,
      "text": "Although these declarations are expressed here as C 'const's, the 'const' construct itself is not available to be used in policy code.",
      "ja": "これらの宣言はここではC 'const'sとして表されていますが、' const 'コンストラクト自体はポリシーコードで使用できません。"
    },
    {
      "indent": 3,
      "text": "// Datatype Constants",
      "ja": "//データ型定数"
    },
    {
      "indent": 3,
      "text": "// From RFC 2578 [2]\nconst integer Integer       = 2;\nconst integer Integer32     = 2;\nconst integer String        = 4;\nconst integer Bits          = 4;\nconst integer Null          = 5;\nconst integer Oid           = 6;\nconst integer IpAddress     = 64;\nconst integer Counter32     = 65;\nconst integer Gauge32       = 66;\nconst integer Unsigned32    = 66;\nconst integer TimeTicks     = 67;\nconst integer Opaque        = 68;\nconst integer Counter64     = 70;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// SNMP Exceptions from RFC 3416 [7]\nconst integer NoSuchObject         = 128;\nconst integer NoSuchInstance       = 129;\nconst integer EndOfMibView         = 130;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// SNMP Error Constants from RFC 3416 [7]\nconst integer NoError              = 0;\nconst integer TooBig               = 1;\nconst integer NoSuchName           = 2;\nconst integer BadValue             = 3;\nconst integer ReadOnly             = 4;\nconst integer GenErr               = 5;\nconst integer NoAccess             = 6;\nconst integer WrongType            = 7;\nconst integer WrongLength          = 8;\nconst integer WrongEncoding        = 9; const integer WrongValue           = 10;\nconst integer NoCreation           = 11;\nconst integer InconsistentValue    = 12;\nconst integer ResourceUnavailable  = 13;\nconst integer CommitFailed         = 14;\nconst integer UndoFailed           = 15;\nconst integer AuthorizationError   = 16;\nconst integer NotWritable          = 17;\nconst integer InconsistentName     = 18;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// \"Local\" Errors // These are also possible choices for errorStatus returns // For example: unknown PDU, maxVarbinds is bigger than number // written with writeVar, unknown opcode, etc. const integer BadParameter = 1000;",
      "ja": "//「ローカル」エラー//これらは、errorStatusが返す可能性のある選択肢です//例：不明なPDU、maxVarbindsは数値より大きい// writeVar、不明なオペコードなどで書き込まれますconst integer BadParameter = 1000;"
    },
    {
      "indent": 3,
      "text": "// Request would have created a PDU larger than local limitations const integer TooLong = 1001;",
      "ja": "//リクエストはローカルの制限よりも大きいPDUを作成したconst const TooLong = 1001;"
    },
    {
      "indent": 3,
      "text": "// A response to the request was received but errors were encountered // when parsing it. const integer ParseError = 1002;",
      "ja": "//リクエストへの応答は受信されましたが、解析中に//エラーが発生しました。 const integer ParseError = 1002;"
    },
    {
      "indent": 3,
      "text": "// Local system has complained of an authentication failure const integer AuthFailure = 1003;",
      "ja": "//ローカルシステムは認証失敗を訴えていますconst integer AuthFailure = 1003;"
    },
    {
      "indent": 3,
      "text": "// No valid response was received in a timely fashion const integer TimedOut = 1004;",
      "ja": "//タイムリーに有効な応答が受信されなかったconst integer TimedOut = 1004;"
    },
    {
      "indent": 3,
      "text": "// General local failure including lack of resources const integer GeneralFailure = 1005;",
      "ja": "//リソース不足を含む一般的なローカル障害const integer GeneralFailure = 1005;"
    },
    {
      "indent": 3,
      "text": "// SNMP Operation Constants from RFC 3416 [7]\nconst integer Get                  = 0;\nconst integer Getnext              = 1;\nconst integer Set                  = 3;\nconst integer Trap                 = 4;\nconst integer Getbulk              = 5;\nconst integer Inform               = 6;\nconst integer V2trap               = 7;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Constants from RFC 3411 [1] for SnmpMessageProcessingModel\nconst integer SNMPv1              = 0;\nconst integer SNMPv2c             = 1;\nconst integer SNMPv3              = 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Constants from RFC 3411 [1] for SnmpSecurityModel\nconst integer SNMPv1              = 1;\nconst integer SNMPv2c             = 2;\nconst integer USM                 = 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// SnmpSecurityLevel Constants from RFC 3411 [1]\nconst integer NoAuthNoPriv        = 1;\nconst integer AuthNoPriv          = 2;\nconst integer AuthPriv            = 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Constants for use with searchColumn\nconst integer ExactMatch          = 0;\nconst integer ExactCaseMatch      = 1;\nconst integer SubstringMatch      = 2;\nconst integer SubstringCaseMatch  = 3;\nconst integer RegexpMatch         = 4;\nconst integer RegexpCaseMatch     = 5;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2. Policy Library Functions",
      "section_title": true,
      "ja": "8.2。 ポリシーライブラリ関数"
    },
    {
      "indent": 3,
      "text": "Policy Library Functions provide access to information specifically related to the execution of policies.",
      "ja": "ポリシーライブラリ関数は、特にポリシーの実行に関連する情報へのアクセスを提供します。"
    },
    {
      "indent": 0,
      "text": "8.2.1. elementName()",
      "section_title": true,
      "ja": "8.2.1。 elementName（）"
    },
    {
      "indent": 3,
      "text": "The elementName() function is used to determine what the current element is and can be used to provide information about the type of element and how it is indexed.",
      "ja": "elementName（）関数は、現在の要素が何であるかを判別するために使用され、要素のタイプとそのインデックス付け方法に関する情報を提供するために使用できます。"
    },
    {
      "indent": 6,
      "text": "string elementName()",
      "ja": "文字列elementName（）"
    },
    {
      "indent": 9,
      "text": "elementName returns a string containing an ASCII dotted-decimal representation of an object identifier (e.g., 1.3.6.1.2.1.1.1.0). This object identifier identifies an instance of a MIB object that is an attribute of 'this element'.",
      "ja": "elementNameは、オブジェクト識別子のASCIIドット付き10進表現を含む文字列を返します（例：1.3.6.1.2.1.1.1.0）。 このオブジェクト識別子は、「この要素」の属性であるMIBオブジェクトのインスタンスを識別します。"
    },
    {
      "indent": 0,
      "text": "8.2.2. elementAddress()",
      "section_title": true,
      "ja": "8.2.2。 elementAddress（）"
    },
    {
      "indent": 6,
      "text": "elementAddress(&tDomain, &tAddress)",
      "ja": "elementAddress（＆tDomain、＆tAddress）"
    },
    {
      "indent": 9,
      "text": "elementAddress finds a domain/address pair that can be used to access 'this element' and returns the values in 'tDomain' and 'tAddress'.",
      "ja": "elementAddressは、「この要素」にアクセスするために使用できるドメイン/アドレスのペアを見つけ、「tDomain」および「tAddress」の値を返します。"
    },
    {
      "indent": 0,
      "text": "8.2.3. elementContext()",
      "section_title": true,
      "ja": "8.2.3。 elementContext（）"
    },
    {
      "indent": 6,
      "text": "string elementContext()",
      "ja": "文字列elementContext（）"
    },
    {
      "indent": 9,
      "text": "elementContext() returns a string containing the SNMP contextName of 'this element'.",
      "ja": "elementContext（）は、「this element」のSNMP contextNameを含む文字列を返します。"
    },
    {
      "indent": 0,
      "text": "8.2.4. ec()",
      "section_title": true,
      "ja": "8.2.4。 ec（）"
    },
    {
      "indent": 3,
      "text": "The ec() (element count) and ev() (element value) functions provide convenient access to the components of the index for 'this element'. Typical uses will be in creating the index to other, related elements.",
      "ja": "ec（）（要素数）およびev（）（要素値）関数は、「この要素」のインデックスのコンポーネントへの便利なアクセスを提供します。 典型的な用途は、他の関連する要素のインデックスを作成することです。"
    },
    {
      "indent": 6,
      "text": "integer ec()",
      "ja": "整数ec（）"
    },
    {
      "indent": 9,
      "text": "ec() returns an integer count of the number of index subidentifiers that exist in the index for 'this element'.",
      "ja": "ec（）は、「この要素」のインデックスに存在するインデックスサブ識別子の数の整数カウントを返します。"
    },
    {
      "indent": 0,
      "text": "8.2.5. ev()",
      "section_title": true,
      "ja": "8.2.5。 ev（）"
    },
    {
      "indent": 6,
      "text": "integer ev(integer n)",
      "ja": "整数ev（整数n）"
    },
    {
      "indent": 9,
      "text": "ev() returns the value of the nth subidentifier in the index for 'this element'. The first subidentifier is indexed at 0. It is an RTE if n specifies a subidentifier beyond the last subidentifier.",
      "ja": "ev（）は、「this element」のインデックス内のn番目のサブ識別子の値を返します。 最初のサブ識別子は0でインデックス付けされます。nが最後のサブ識別子を超えるサブ識別子を指定する場合、RTEです。"
    },
    {
      "indent": 0,
      "text": "8.2.6. roleMatch()",
      "section_title": true,
      "ja": "8.2.6。 roleMatch（）"
    },
    {
      "indent": 3,
      "text": "The roleMatch() function is used to check whether an element has been assigned a particular role.",
      "ja": "roleMatch（）関数は、要素に特定の役割が割り当てられているかどうかを確認するために使用されます。"
    },
    {
      "indent": 6,
      "text": "integer roleMatch(string roleString [, string element, string contextName, string contextEngineID])",
      "ja": "整数roleMatch（string roleString [、文字列要素、文字列contextName、文字列contextEngineID]）"
    },
    {
      "indent": 9,
      "text": "'roleString' is a string. The optional argument 'element' contains the OID name of an element, defaulting to the current element if 'element' is not supplied. If roleString exactly matches (content and length) any role assigned to the specified element, the function returns 1. If no roles match, the function returns 0.",
      "ja": "「roleString」は文字列です。 オプションの引数「element」には要素のOID名が含まれ、「element」が指定されていない場合はデフォルトで現在の要素になります。 roleStringが、指定された要素に割り当てられたロールと完全に一致する場合（コンテンツと長さ）、関数は1を返します。一致するロールがない場合、関数は0を返します。"
    },
    {
      "indent": 9,
      "text": "The optional 'contextName' argument contains the SNMP context on which to operate. If 'contextName' is not present, the contextName of 'this element' will be used. If 'contextName' is the zero-length string, the default context is used.",
      "ja": "オプションの「contextName」引数には、操作対象のSNMPコンテキストが含まれます。 「contextName」が存在しない場合、「this element」のcontextNameが使用されます。 'contextName'が長さゼロの文字列の場合、デフォルトのコンテキストが使用されます。"
    },
    {
      "indent": 9,
      "text": "'contextEngineID' contains the contextEngineID of the remote system on which 'element' resides. It is encoded as a pair of hex digits (upper- and lowercase are valid) for each octet of the contextEngineID. If 'contextEngineID' is not present, the contextEngineID of 'this element' will be used. 'contextEngineID' may only be present if the 'element' and 'context' arguments are present.",
      "ja": "「contextEngineID」には、「element」が存在するリモートシステムのcontextEngineIDが含まれます。 contextEngineIDの各オクテットに対して、16進数のペア（大文字と小文字が有効）としてエンコードされます。 「contextEngineID」が存在しない場合、「this element」のcontextEngineIDが使用されます。 「contextEngineID」は、「element」および「context」引数が存在する場合にのみ存在します。"
    },
    {
      "indent": 0,
      "text": "8.2.7. Scratchpad Functions",
      "section_title": true,
      "ja": "8.2.7。 スクラッチパッド機能"
    },
    {
      "indent": 3,
      "text": "Every maxLatency time period, every policy runs once for each element. When the setScratchpad function executes, it stores a value named by a string that can be retrieved with getScratchpad() even after this policy execution code exits. This allows sharing of data between a condition and an action, two conditions executing on different elements, or even different policies altogether.",
      "ja": "maxLatencyの期間ごとに、すべてのポリシーが要素ごとに1回実行されます。 setScratchpad関数を実行すると、このポリシー実行コードが終了した後でもgetScratchpad（）で取得できる文字列で指定された値が保存されます。 これにより、条件とアクション、異なる要素で実行される2つの条件、または異なるポリシー全体でデータを共有できます。"
    },
    {
      "indent": 3,
      "text": "The value of 'scope' controls which policy/element combinations can retrieve this 'varName'/'value' pair. The following are options for 'scope':",
      "ja": "「scope」の値は、この「varName」/「value」のペアを取得できるポリシー/要素の組み合わせを制御します。 「スコープ」のオプションは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Global The 'varName'/'value' combination will be available in the condition or action of any policy while it is executing on any element. Note that any information placed here will be visible to all other scripts on this system regardless of their authority. Sensitive information should not be placed in global scratchpad variables.",
      "ja": "グローバル「varName」/「value」の組み合わせは、任意の要素で実行されているポリシーの条件またはアクションで使用できます。 ここに配置された情報は、権限に関係なく、このシステム上の他のすべてのスクリプトに表示されることに注意してください。 機密情報は、グローバルスクラッチパッド変数に配置しないでください。"
    },
    {
      "indent": 6,
      "text": "Policy The 'varName'/'value' combination will be available in any future execution of the condition or action of the current policy (regardless of what element the policy is executing on). If a policy is ever deleted, or if its condition or action code is modified, all values in its 'Policy' scope will be deleted.",
      "ja": "ポリシー 'varName' / 'value'の組み合わせは、現在のポリシーの条件またはアクションの将来の実行で利用可能になります（ポリシーが実行されている要素に関係なく）。 ポリシーが削除された場合、またはその条件またはアクションコードが変更された場合、「ポリシー」スコープ内のすべての値が削除されます。"
    },
    {
      "indent": 6,
      "text": "PolicyElement The 'varName'/'value' combination will be available in future executions of the condition or action of the current policy, but only when the policy is executing on the current element. If a policy is ever deleted, or if its condition or action code is modified, all values in its 'PolicyElement' scope will be deleted. The agent may also periodically delete values in a 'PolicyElement' scope if the corresponding element does not exist (in other words, if an element disappears for a period and reappears, values in its 'PolicyElement' scope may or may not be deleted).",
      "ja": "PolicyElement 'varName' / 'value'の組み合わせは、現在のポリシーの条件またはアクションの今後の実行で使用できますが、ポリシーが現在の要素で実行されている場合のみです。 ポリシーが削除された場合、または条件またはアクションコードが変更された場合、「PolicyElement」スコープ内のすべての値が削除されます。 対応する要素が存在しない場合、エージェントは「PolicyElement」スコープの値を定期的に削除することもできます（つまり、ある期間要素が消えて再表示される場合、「PolicyElement」スコープの値は削除される場合とされない場合があります）。"
    },
    {
      "indent": 3,
      "text": "setScratchpad's 'storageType' argument allows the script to control the lifetime of a variable stored in the scratchpad. If the storageType is equal to the constant 'volatile', then this variable must be deleted on a reboot. If it is equal to 'nonVolatile', then this variable should be stored in non-volatile storage, where it will be available after a reboot. If the 'storageType' argument is not present, the variable will be volatile and will be erased on reboot.",
      "ja": "setScratchpadの 'storageType'引数により、スクリプトはスクラッチパッドに保存されている変数の有効期間を制御できます。 storageTypeが定数「volatile」に等しい場合、この変数は再起動時に削除する必要があります。 「nonVolatile」に等しい場合、この変数は不揮発性ストレージに保存する必要があり、再起動後に利用可能になります。 'storageType'引数が存在しない場合、変数は揮発性であり、再起動時に消去されます。"
    },
    {
      "indent": 3,
      "text": "If the optional 'freeOnException' argument is present and equal to 1, the agent will free this variable if, later in the same script invocation, this script dies with a run-time exception or by a call to fail(). (Note that this does not apply to exceptions experienced in subsequent invocations of the script.)",
      "ja": "オプションの「freeOnException」引数が存在し、1に等しい場合、後で同じスクリプト呼び出しでこのスクリプトが実行時例外またはfail（）の呼び出しで停止した場合、エージェントはこの変数を解放します。 （これは、スクリプトの後続の呼び出しで発生する例外には適用されないことに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Note that there may be implementation-specific limits on the number of scratchpad variables that can be allocated. The limit of unique scratchpad variables may be different for each scope or storageType. It is suggested that implementations limit the total number of scratchpad variables per script to protect other scripts from a malfunctioning script. In addition, compliant implementations must support at least 50 Global variables, 5 Policy variables per policy, and 5 PolicyElement variables per policy-element pair.",
      "ja": "割り当てることができるスクラッチパッド変数の数には、実装固有の制限がある場合があることに注意してください。 一意のスクラッチパッド変数の制限は、スコープまたはstorageTypeごとに異なる場合があります。 実装では、スクリプトごとにスクラッチパッド変数の総数を制限して、誤動作するスクリプトから他のスクリプトを保護することをお勧めします。 さらに、準拠する実装は、少なくとも50のグローバル変数、ポリシーごとに5つのポリシー変数、およびポリシーと要素のペアごとに5つのPolicyElement変数をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Scratchpad Usage Examples",
      "ja": "スクラッチパッドの使用例"
    },
    {
      "indent": 3,
      "text": "Policy Element Action A ifIndex.1 setScratchpad(Global, \"foo\", \"55\") A ifIndex.1 getScratchpad(Global, \"foo\", val) --> 55 A ifIndex.2 getScratchpad(Global, \"foo\", val) --> 55 B ifIndex.2 getScratchpad(Global, \"foo\", val) --> 55 B ifIndex.2 setScratchpad(Global, \"foo\", \"16\") A ifIndex.1 getScratchpad(Global, \"foo\", val) --> 16",
      "ja": "ポリシー要素アクションifIndex.1 setScratchpad（Global、 \"foo\"、 \"55\"）ifIndex.1 getScratchpad（Global、 \"foo\"、val）-> 55 ifIndex.2 getScratchpad（Global、 \"foo\"、val ）-> 55 B ifIndex.2 getScratchpad（Global、 \"foo\"、val）-> 55 B ifIndex.2 setScratchpad（Global、 \"foo\"、 \"16\"）A ifIndex.1 getScratchpad（Global、 \"foo\" 、val）-> 16"
    },
    {
      "indent": 3,
      "text": "Policy Element Action A ifIndex.1 setScratchpad(Policy, \"bar\", \"75\") A ifIndex.1 getScratchpad(Policy, \"bar\", val) --> 75 A ifIndex.2 getScratchpad(Policy, \"bar\", val) --> 75 B ifIndex.1 getScratchpad(Policy, \"bar\", val) not found B ifIndex.1 setScratchpad(Policy, \"bar\", \"20\") A ifIndex.2 getScratchpad(Policy, \"bar\", val) --> 75 B ifIndex.2 getScratchpad(Policy, \"bar\", val) --> 20",
      "ja": "ポリシー要素アクションifIndex.1 setScratchpad（Policy、 \"bar\"、 \"75\"）ifIndex.1 getScratchpad（Policy、 \"bar\"、val）-> 75 A ifIndex.2 getScratchpad（Policy、 \"bar\"、val ）-> 75 B ifIndex.1 getScratchpad（Policy、 \"bar\"、val）not found B ifIndex.1 setScratchpad（Policy、 \"bar\"、 \"20\"）A ifIndex.2 getScratchpad（Policy、 \"bar\"、val ）-> 75 B ifIndex.2 getScratchpad（Policy、 \"bar\"、val）-> 20"
    },
    {
      "indent": 3,
      "text": "Policy Element Action A ifIndex.1 setScratchpad(PolicyElement, \"baz\", \"43\") A ifIndex.1 getScratchpad(PolicyElement, \"baz\", val) --> 43 A ifIndex.2 getScratchpad(PolicyElement, \"baz\", val) not found B ifIndex.1 getScratchpad(PolicyElement, \"baz\", val) not found A ifIndex.2 setScratchpad(PolicyElement, \"baz\", \"54\")",
      "ja": "ポリシー要素アクションifIndex.1 setScratchpad（PolicyElement、 \"baz\"、 \"43\"）ifIndex.1 getScratchpad（PolicyElement、 \"baz\"、val）-> 43 ifIndex.2 getScratchpad（PolicyElement、 \"baz\"、val ）見つからないB ifIndex.1 getScratchpad（PolicyElement、 \"baz\"、val）見つからないA ifIndex.2 setScratchpad（PolicyElement、 \"baz\"、 \"54\"）"
    },
    {
      "indent": 3,
      "text": "B ifIndex.1 setScratchpad(PolicyElement, \"baz\", \"65\") A ifIndex.1 getScratchpad(PolicyElement, \"baz\", val) --> 43 A ifIndex.2 getScratchpad(PolicyElement, \"baz\", val) --> 54 B ifIndex.1 getScratchpad(PolicyElement, \"baz\", val) --> 65",
      "ja": "B ifIndex.1 setScratchpad（PolicyElement、 \"baz\"、 \"65\"）A ifIndex.1 getScratchpad（PolicyElement、 \"baz\"、val）-> 43 A ifIndex.2 getScratchpad（PolicyElement、 \"baz\"、val）- > 54 B ifIndex.1 getScratchpad（PolicyElement、 \"baz\"、val）-> 65"
    },
    {
      "indent": 3,
      "text": "Policy Element Action A ifIndex.1 setScratchpad(PolicyElement, \"foo\", \"11\") A ifIndex.1 setScratchpad(Global, \"foo\", \"22\") A ifIndex.1 getScratchpad(PolicyElement, \"foo\", val) --> 11 A ifIndex.1 getScratchpad(Global, \"foo\", val) --> 22",
      "ja": "ポリシー要素アクションifIndex.1 setScratchpad（PolicyElement、 \"foo\"、 \"11\"）ifIndex.1 setScratchpad（Global、 \"foo\"、 \"22\"）ifIndex.1 getScratchpad（PolicyElement、 \"foo\"、val）- -> 11 A ifIndex.1 getScratchpad（Global、 \"foo\"、val）-> 22"
    },
    {
      "indent": 3,
      "text": "Constants",
      "ja": "定数"
    },
    {
      "indent": 3,
      "text": "The following constants are defined for use with the scratchpad functions. Policy code will be executed in an environment where the following constants are declared. (Note that these constant declarations will not be visible in the policyCondition or policyAction MIB objects.)",
      "ja": "以下の定数は、スクラッチパッド機能で使用するために定義されています。 ポリシーコードは、次の定数が宣言されている環境で実行されます。 （これらの定数宣言は、policyConditionまたはpolicyAction MIBオブジェクトでは表示されないことに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Although these declarations are expressed here as C 'const's, the 'const' construct itself is not available to be used inside of policy code.",
      "ja": "これらの宣言はここではC 'const'sとして表されていますが、' const 'コンストラクト自体はポリシーコード内で使用できません。"
    },
    {
      "indent": 3,
      "text": "// Scratchpad Constants",
      "ja": "//スクラッチパッド定数"
    },
    {
      "indent": 3,
      "text": "// Values of scope\nconst integer Global           = 0;\nconst integer Policy           = 1;\nconst integer PolicyElement    = 2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Values of storageType\nconst integer Volatile         = 0;\nconst integer NonVolatile      = 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2.8. setScratchpad()",
      "section_title": true,
      "ja": "8.2.8。 setScratchpad（）"
    },
    {
      "indent": 6,
      "text": "setScratchpad(integer scope, string varName [, string value,\n              integer storageType, integer freeOnException ])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "The setScratchpad function stores a value that can be retrieved even after this policy execution code exits.",
      "ja": "setScratchpad関数は、このポリシー実行コードが終了した後でも取得できる値を保存します。"
    },
    {
      "indent": 9,
      "text": "The value of 'scope' controls which policy/element combinations can retrieve this 'varName'/'value' pair. The options for 'scope' are Global, Policy, and PolicyElement.",
      "ja": "「scope」の値は、この「varName」/「value」のペアを取得できるポリシー/要素の組み合わせを制御します。 「scope」のオプションは、Global、Policy、およびPolicyElementです。"
    },
    {
      "indent": 9,
      "text": "'varName' is a string used to identify the value. Subsequent retrievals of the same 'varName' in the proper scope will return the value stored. Note that the namespace for 'varName' is distinct for each scope. 'varName' is case sensitive.",
      "ja": "'varName'は、値を識別するために使用される文字列です。 適切なスコープで同じ「varName」をその後取得すると、保存されている値が返されます。 'varName'の名前空間はスコープごとに異なることに注意してください。 'varName'は大文字と小文字が区別されます。"
    },
    {
      "indent": 9,
      "text": "'value' is a string containing the value to be stored. ToString(value) is called on 'value' to convert it to a string before storage.",
      "ja": "「値」は、保存する値を含む文字列です。 ToString（value）は、「value」で呼び出され、保存する前に文字列に変換します。"
    },
    {
      "indent": 9,
      "text": "If the 'value' argument is missing, the 'varName' in scope 'scope' will be deleted if it exists.",
      "ja": "「値」引数が欠落している場合、スコープ「スコープ」内の「varName」が存在する場合は削除されます。"
    },
    {
      "indent": 9,
      "text": "If the optional 'storageType' argument is present and is equal to the constant 'Volatile', then this variable must be deleted on a reboot. If it is equal to 'NonVolatile', then this variable should be stored in non-volatile storage, where it will be available after a reboot. If the 'storageType' argument is not present, the variable will be volatile and will be erased on reboot. 'storageType' may not be present if the 'value' argument is not present. If the variable already existed, its previous storageType is updated according to the current 'storageType' argument.",
      "ja": "オプションの 'storageType'引数が存在し、定数 'Volatile'と等しい場合、この変数は再起動時に削除する必要があります。 「NonVolatile」に等しい場合、この変数は不揮発性ストレージに保存する必要があり、再起動後に利用可能になります。 'storageType'引数が存在しない場合、変数は揮発性であり、再起動時に消去されます。 「value」引数が存在しない場合、「storageType」は存在しない場合があります。 変数が既に存在する場合、その以前のstorageTypeは現在の 'storageType'引数に従って更新されます。"
    },
    {
      "indent": 9,
      "text": "If the optional 'freeOnException' argument is present and equal to 1, the agent will free this variable if, later in the same script invocation, this script dies with a run-time exception or by a call to fail(). (Note that this does not apply to exceptions experienced in subsequent invocations of the script.)",
      "ja": "オプションの「freeOnException」引数が存在し、1に等しい場合、後で同じスクリプト呼び出しでこのスクリプトが実行時例外またはfail（）の呼び出しで停止した場合、エージェントはこの変数を解放します。 （これは、スクリプトの後続の呼び出しで発生する例外には適用されないことに注意してください。）"
    },
    {
      "indent": 0,
      "text": "8.2.9. getScratchpad()",
      "section_title": true,
      "ja": "8.2.9。 getScratchpad（）"
    },
    {
      "indent": 6,
      "text": "integer getScratchpad(integer scope, string varName,\n                      string &value)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "The getScratchpad function allows the retrieval of values that were stored previously in this execution context or in other execution contexts. The value of 'scope' controls which execution contexts can pass a value to this execution context. The options for 'scope' are Global, Policy, and PolicyElement.",
      "ja": "getScratchpad関数を使用すると、この実行コンテキストまたは他の実行コンテキストに以前に保存された値を取得できます。 'scope'の値は、どの実行コンテキストがこの実行コンテキストに値を渡すことができるかを制御します。 「scope」のオプションは、Global、Policy、およびPolicyElementです。"
    },
    {
      "indent": 9,
      "text": "'varName' is a string used to identify the value. Subsequent retrievals of the same 'varName' in the proper scope will return the value stored. Note that the namespace for varName is distinct for each scope. As a result, getScratchpad cannot force access to a variable in an inaccessible scope; it can only retrieve variables by referencing the proper scope in which they were set. 'varName' is case sensitive.",
      "ja": "'varName'は、値を識別するために使用される文字列です。 適切なスコープで同じ「varName」をその後取得すると、保存されている値が返されます。 varNameの名前空間は、スコープごとに異なることに注意してください。 その結果、getScratchpadはアクセスできないスコープ内の変数へのアクセスを強制できません。 変数が設定された適切なスコープを参照することによってのみ変数を取得できます。 'varName'は大文字と小文字が区別されます。"
    },
    {
      "indent": 9,
      "text": "On successful return, 'value' will be set to the value that was previously stored; otherwise, 'value' will not be modified.",
      "ja": "正常に戻ると、「値」は以前に保存された値に設定されます。 それ以外の場合、「値」は変更されません。"
    },
    {
      "indent": 9,
      "text": "This function returns 1 if a value was previously stored and 0 otherwise.",
      "ja": "この関数は、値が以前に保存されていた場合は1を返し、それ以外の場合は0を返します。"
    },
    {
      "indent": 0,
      "text": "8.2.10. signalError()",
      "section_title": true,
      "ja": "8.2.10。 signalError（）"
    },
    {
      "indent": 3,
      "text": "The signalError() function is used by the script to indicate to a management station that it is experiencing abnormal behavior. signalError() turns on the conditionUserSignal(3) or actionUserSignal(5) bit in the associated pmTrackingPEInfo object (subsequent calls to signalError() have no additional effect). This bit is initially cleared at the beginning of each execution. If, upon a subsequent execution, the script finishes without calling signalError, the bit will be cleared.",
      "ja": "signalError（）関数は、異常な動作が発生していることを管理ステーションに示すためにスクリプトによって使用されます。 signalError（）は、関連するpmTrackingPEInfoオブジェクトのconditionUserSignal（3）またはactionUserSignal（5）ビットをオンにします（signalError（）への後続の呼び出しは追加の効果はありません）。 このビットは、各実行の開始時に最初にクリアされます。 後続の実行時に、signalErrorを呼び出さずにスクリプトが終了すると、ビットはクリアされます。"
    },
    {
      "indent": 6,
      "text": "signalError()",
      "ja": "signalError（）"
    },
    {
      "indent": 9,
      "text": "The signalException function takes no arguments and returns no value.",
      "ja": "signalException関数は引数を取らず、値を返しません。"
    },
    {
      "indent": 0,
      "text": "8.2.11. defer()",
      "section_title": true,
      "ja": "8.2.11。 defer（）"
    },
    {
      "indent": 3,
      "text": "Precedence groups enforce the rule that for each element, of the ready policies that match the condition, only the one with the highest precedence value will be active. Unfortunately, once the winning policy has been selected and the action begins running, situations can occur in which the policy script determines that it cannot complete its task. In many such cases, it is desirable that the next runner-up ready policy be executed. In the previous example, it would be desirable that at least bronze behavior be configured if gold is appropriate but gold isn't possible.",
      "ja": "優先順位グループは、条件に一致する準備ができたポリシーの各要素について、優先順位の値が最も高いポリシーのみがアクティブになるというルールを実施します。 残念ながら、勝ち取ったポリシーが選択されてアクションの実行が開始されると、ポリシースクリプトがタスクを完了できないと判断する状況が発生する可能性があります。 多くの場合、次点の準備完了ポリシーを実行することが望ましいです。 前の例では、金は適切だが金が不可能な場合は、少なくとも青銅の動作を構成することが望ましいでしょう。"
    },
    {
      "indent": 3,
      "text": "When a policy defers, it exits, and the ready, condition-matching policy with the next-highest precedence is immediately run. Because this might also defer, the execution environment must remember where it is in the precedence chain so that it can continue going down the chain until an action completes without deferring, or until no policies are left in the precedence group. Once a policy finishes successfully, the next iteration will begin at the top of the precedence chain.",
      "ja": "ポリシーが延期されると、ポリシーは終了し、次に優先順位の高い準備ができた条件一致ポリシーがすぐに実行されます。 これも延期される可能性があるため、実行環境は、優先チェーン内の場所を覚えて、アクションが遅延することなく完了するか、優先グループにポリシーがなくなるまでチェーンを下っていく必要があります。 ポリシーが正常に終了すると、次の反復は優先チェーンの先頭から開始されます。"
    },
    {
      "indent": 3,
      "text": "There are two ways to defer. A script can exit by calling fail() and specify that it should defer immediately. Alternately, a script can instruct the execution environment to defer automatically in the event of a run-time exception.",
      "ja": "延期するには2つの方法があります。 スクリプトは、fail（）を呼び出して終了し、すぐに延期するように指定できます。 または、スクリプトは、実行時例外が発生した場合に自動的に延期するように実行環境に指示できます。"
    },
    {
      "indent": 6,
      "text": "defer(integer deferOnRTE)",
      "ja": "defer（整数deferOnRTE）"
    },
    {
      "indent": 9,
      "text": "The defer function changes the run-time exception behavior of a script. By default, a script will not defer when it encounters an RTE. If defer(1) is called, the exit behavior is changed so that the script will defer when it is terminated due to an RTE. If defer(0) is called, the script is reset to its default behavior and will not defer.",
      "ja": "defer関数は、スクリプトの実行時例外動作を変更します。 デフォルトでは、スクリプトはRTEに遭遇しても延期しません。 defer（1）が呼び出されると、終了動作が変更され、RTEによりスクリプトが終了したときにスクリプトが延期されるようになります。 defer（0）が呼び出されると、スクリプトはデフォルトの動作にリセットされ、延期されません。"
    },
    {
      "indent": 9,
      "text": "Note that calling defer doesn't cause the script to exit. Defer only changes the default behavior if an RTE occurs later in this invocation.",
      "ja": "deferを呼び出しても、スクリプトは終了しません。 この呼び出しの後半でRTEが発生した場合、遅延はデフォルトの動作のみを変更します。"
    },
    {
      "indent": 0,
      "text": "8.2.12. fail()",
      "section_title": true,
      "ja": "8.2.12。 不合格（）"
    },
    {
      "indent": 6,
      "text": "fail(integer defer, integer free [, string message] )",
      "ja": "fail（整数遅延、整数フリー[、文字列メッセージ]）"
    },
    {
      "indent": 9,
      "text": "The fail function causes the script to optionally perform certain functions and then exit.",
      "ja": "fail関数により、スクリプトはオプションで特定の機能を実行してから終了します。"
    },
    {
      "indent": 9,
      "text": "If 'defer' is 1, this script will defer to the next lower precedence ready policy in the same precedence group whose condition matches. If 'defer' isn't 1, it will not defer. Note that if a condition defers, it is functionally equivalent to the condition returning false.",
      "ja": "'defer'が1の場合、このスクリプトは、条件が一致する同じ優先順位グループ内の次に低い優先順位の準備ポリシーに延期します。 「遅延」が1でない場合、遅延しません。 条件が遅延する場合、falseを返す条件と機能的に同等であることに注意してください。"
    },
    {
      "indent": 9,
      "text": "If 'free' is 1, certain registered resources will be freed. If, earlier in this script invocation, any rows were created by createRow with the 'freeOnException' option, the execution environment will set the RowStatus of each row to 'destroy' to delete the row. Further, if earlier in this script invocation any scratchpad variables were created or modified with the 'freeOnException' option, they will be deleted.",
      "ja": "'free'が1の場合、特定の登録済みリソースが解放されます。 このスクリプト呼び出しの初期段階で、 'freeOnException'オプションを指定したcreateRowによって行が作成された場合、実行環境は各行のRowStatusを 'destroy'に設定して行を削除します。 さらに、このスクリプト呼び出しの初期段階で、「freeOnException」オプションを使用してスクラッチパッド変数が作成または変更された場合、それらは削除されます。"
    },
    {
      "indent": 9,
      "text": "If the optional 'message' argument is present, it will be logged to the debugging table if pmPolicyDebugging is turned on for this policy.",
      "ja": "オプションの 'message'引数が存在する場合、このポリシーでpmPolicyDebuggingがオンになっていると、デバッグテーブルにログが記録されます。"
    },
    {
      "indent": 9,
      "text": "This function does not return. Instead, the script will terminate.",
      "ja": "この関数は戻りません。 代わりに、スクリプトは終了します。"
    },
    {
      "indent": 0,
      "text": "8.2.13. getParameters()",
      "section_title": true,
      "ja": "8.2.13。 getParameters（）"
    },
    {
      "indent": 3,
      "text": "From time to time, policy scripts may be parameterized so that they are supplied with one or more parameters (e.g., site-specific constants). These parameters may be installed in the pmPolicyParameters object and are accessible to the script via the getParameters() function. If it is necessary for multiple parameters to be passed to the script, the script can choose whatever encoding/delimiting mechanism is most appropriate so that the multiple parameters can be stored in the associated instance of pmPolicyParameters.",
      "ja": "ポリシースクリプトは、1つ以上のパラメーター（サイト固有の定数など）で提供されるようにパラメーター化される場合があります。 これらのパラメーターはpmPolicyParametersオブジェクトにインストールでき、getParameters（）関数を介してスクリプトにアクセスできます。 複数のパラメーターをスクリプトに渡す必要がある場合、スクリプトは、pmPolicyParametersの関連インスタンスに複数のパラメーターを格納できるように、最も適切なエンコード/区切りメカニズムを選択できます。"
    },
    {
      "indent": 6,
      "text": "string getParameters()",
      "ja": "文字列getParameters（）"
    },
    {
      "indent": 9,
      "text": "The getParameters function takes no arguments. It returns a string containing the value of the pmPolicyParameters object for the running policy.",
      "ja": "getParameters関数は引数を取りません。 実行中のポリシーのpmPolicyParametersオブジェクトの値を含む文字列を返します。"
    },
    {
      "indent": 3,
      "text": "For example, if a policy is to apply to \"slow speed interfaces\" and the cutoff point for slow speed should be parameterized, the policy filter should be:",
      "ja": "たとえば、ポリシーが「低速インターフェイス」に適用され、低速のカットオフポイントがパラメーター化される場合、ポリシーフィルターは次のようになります。"
    },
    {
      "indent": 6,
      "text": "getVar(\"ifSpeed.$*\") == getParameters()",
      "ja": "getVar（ \"ifSpeed。$ *\"）== getParameters（）"
    },
    {
      "indent": 3,
      "text": "In this example, one can store the string \"128000\" in the policy's pmPolicyParameters object to cause this policy to act on all 128 Kbps interfaces.",
      "ja": "この例では、ポリシーのpmPolicyParametersオブジェクトに文字列「128000」を保存して、このポリシーを128 Kbpsのすべてのインターフェイスで動作させることができます。"
    },
    {
      "indent": 0,
      "text": "8.3. Utility Library Functions",
      "section_title": true,
      "ja": "8.3。 ユーティリティライブラリ関数"
    },
    {
      "indent": 3,
      "text": "Utility Library Functions are provided to enable more efficient policy scripts.",
      "ja": "より効率的なポリシースクリプトを有効にするユーティリティライブラリ関数が提供されています。"
    },
    {
      "indent": 0,
      "text": "8.3.1. regexp()",
      "section_title": true,
      "ja": "8.3.1。 regexp（）"
    },
    {
      "indent": 6,
      "text": "integer regexp(string pattern, string str,\n               integer case [, string &match])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "regexp searches 'str' for matches to the regular expression given in `pattern`. regexp uses the POSIX extended regular expressions defined in POSIX 1003.2.",
      "ja": "regexpは、「パターン」で指定された正規表現に一致する「str」を検索します。 regexpは、POSIX 1003.2で定義されているPOSIX拡張正規表現を使用します。"
    },
    {
      "indent": 9,
      "text": "If `case` is 0, the search will be case insensitive; otherwise, it will be case sensitive.",
      "ja": "「case」が0の場合、検索では大文字と小文字が区別されません。 それ以外の場合は、大文字と小文字が区別されます。"
    },
    {
      "indent": 9,
      "text": "If a match is found, 1 is returned, otherwise 0 is returned.",
      "ja": "一致が見つかった場合は1が返され、それ以外の場合は0が返されます。"
    },
    {
      "indent": 9,
      "text": "If the optional argument 'match' is provided and a match is found, 'match' will be replaced with the text of the first substring of 'str' that matches 'pattern'. If no match is found, it will be unchanged.",
      "ja": "オプションの引数 'match'が提供され、一致が見つかった場合、 'match'は、 'pattern'に一致する 'str'の最初の部分文字列のテキストに置き換えられます。 一致するものが見つからない場合、変更されません。"
    },
    {
      "indent": 0,
      "text": "8.3.2. regexpReplace()",
      "section_title": true,
      "ja": "8.3.2。 regexpReplace（）"
    },
    {
      "indent": 6,
      "text": "string regexpReplace(string pattern, string replacement,\n                      string str, integer case)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "regexpReplace searches 'str' for matches to the regular expression given in 'pattern', replacing each occurrence of matched text with 'replacement'. regexpReplace uses the POSIX extended regular expressions defined in POSIX 1003.2.",
      "ja": "regexpReplaceは、「パターン」で指定された正規表現への一致を「str」で検索し、一致したテキストの各出現を「置換」で置き換えます。 regexpReplaceは、POSIX 1003.2で定義されているPOSIX拡張正規表現を使用します。"
    },
    {
      "indent": 9,
      "text": "If `case` is 0, the search will be case insensitive; otherwise, it will be case sensitive.",
      "ja": "「case」が0の場合、検索では大文字と小文字が区別されません。 それ以外の場合は、大文字と小文字が区別されます。"
    },
    {
      "indent": 9,
      "text": "The modified string is returned (it would be the same as the original string if no matches were found).",
      "ja": "変更された文字列が返されます（一致するものが見つからなかった場合、元の文字列と同じになります）。"
    },
    {
      "indent": 0,
      "text": "8.3.3. oidlen()",
      "section_title": true,
      "ja": "8.3.3。 oidlen（）"
    },
    {
      "indent": 6,
      "text": "integer oidlen(string oid)",
      "ja": "整数oidlen（string oid）"
    },
    {
      "indent": 9,
      "text": "oidlen returns the number of subidentifiers in 'oid'. 'oid' is a string containing an ASCII dotted-decimal representation of an object identifier (e.g., \"1.3.6.1.2.1.1.1.0\").",
      "ja": "oidlenは、 'oid'のサブ識別子の数を返します。 「oid」は、オブジェクト識別子のASCIIドット付き10進表現を含む文字列です（例：「1.3.6.1.2.1.1.1.0」）。"
    },
    {
      "indent": 0,
      "text": "8.3.4. oidncmp()",
      "section_title": true,
      "ja": "8.3.4。 oidncmp（）"
    },
    {
      "indent": 6,
      "text": "integer oidncmp(string oid1, string oid2, integer n)",
      "ja": "整数oidncmp（文字列oid1、文字列oid2、整数n）"
    },
    {
      "indent": 9,
      "text": "Arguments 'oid1' and 'oid2' are strings containing ASCII dotted-decimal representations of object identifiers (e.g., \"1.3.6.1.2.1.1.1.0\").",
      "ja": "引数 'oid1'および 'oid2'は、オブジェクト識別子のASCIIドット付き10進表現を含む文字列です（例：「1.3.6.1.2.1.1.1.0」）。"
    },
    {
      "indent": 9,
      "text": "oidcmp compares not more than n subidentifiers of 'oid1' and 'oid2' and returns -1 if 'oid1' is less than 'oid2', 0 if they are equal, and 1 if 'oid1' is greater than 'oid2'.",
      "ja": "oidcmpは、 'oid1'と 'oid2'のn個以下のサブ識別子を比較し、 'oid1'が 'oid2'より小さい場合は-1、等しい場合は0、 'oid1'が 'oid2'より大きい場合は1を返します。"
    },
    {
      "indent": 0,
      "text": "8.3.5. inSubtree()",
      "section_title": true,
      "ja": "8.3.5。 inSubtree（）"
    },
    {
      "indent": 6,
      "text": "integer inSubtree(string oid, string prefix)",
      "ja": "整数inSubtree（string oid、string prefix）"
    },
    {
      "indent": 9,
      "text": "Arguments 'oid' and 'prefix' are strings containing ASCII dotted-decimal representations of object identifiers (e.g., \"1.3.6.1.2.1.1.1.0\").",
      "ja": "引数 'oid'および 'prefix'は、オブジェクト識別子のASCIIドット付き10進表現を含む文字列です（例：「1.3.6.1.2.1.1.1.0」）。"
    },
    {
      "indent": 9,
      "text": "inSubtree returns 1 if every subidentifier in 'prefix' equals the corresponding subidentifier in 'oid', otherwise it returns 0. The is equivalent to oidncmp(oid1, prefix, oidlen(prefix)) is provided because this is an idiom and because it avoids evaluating 'prefix' twice if it is an expression.",
      "ja": "inSubtreeは、 'prefix'のすべてのサブ識別子が 'oid'の対応するサブ識別子と等しい場合は1を返し、そうでない場合は0を返します。これはイディオムであり、 式である場合、 'prefix'を2回評価します。"
    },
    {
      "indent": 0,
      "text": "8.3.6. subid()",
      "section_title": true,
      "ja": "8.3.6。 subid（）"
    },
    {
      "indent": 6,
      "text": "integer subid(string oid, integer n)",
      "ja": "整数subid（文字列oid、整数n）"
    },
    {
      "indent": 9,
      "text": "subid returns the value of the nth (starting at zero) subidentifier of 'oid'. 'oid' is a string containing an ASCII dotted-decimal representation of an object identifier (e.g., \"1.3.6.1.2.1.1.1.0\").",
      "ja": "subidは、「oid」のn番目（ゼロから始まる）のサブ識別子の値を返します。 「oid」は、オブジェクト識別子のASCIIドット付き10進表現を含む文字列です（例：「1.3.6.1.2.1.1.1.0」）。"
    },
    {
      "indent": 9,
      "text": "If n specifies a subidentifier beyond the length of 'oid', a value of -1 is returned.",
      "ja": "nが 'oid'の長さを超えるサブ識別子を指定する場合、-1の値が返されます。"
    },
    {
      "indent": 0,
      "text": "8.3.7. subidWrite()",
      "section_title": true,
      "ja": "8.3.7。 subidWrite（）"
    },
    {
      "indent": 6,
      "text": "integer subidWrite(string oid, integer n, integer subid)",
      "ja": "整数subidWrite（文字列oid、整数n、整数subid）"
    },
    {
      "indent": 9,
      "text": "subidWrite sets the value of the nth (starting at zero) subidentifier of 'oid' to 'subid'. 'oid' is a string containing an ASCII dotted-decimal representation of an object identifier (e.g., \"1.3.6.1.2.1.1.1.0\").",
      "ja": "subidWriteは、「oid」のn番目（ゼロから始まる）のサブ識別子の値を「subid」に設定します。 「oid」は、オブジェクト識別子のASCIIドット付き10進表現を含む文字列です（例：「1.3.6.1.2.1.1.1.0」）。"
    },
    {
      "indent": 9,
      "text": "If n specifies a subidentifier beyond the length of 'oid', a value of -1 is returned. Note that appending subidentifiers can be accomplished with the string concatenation '+' operator. If no error occurs, zero is returned.",
      "ja": "nが 'oid'の長さを超えるサブ識別子を指定する場合、-1の値が返されます。 サブ識別子の追加は、文字列連結「+」演算子を使用して実行できることに注意してください。 エラーが発生しない場合、ゼロが返されます。"
    },
    {
      "indent": 0,
      "text": "8.3.8. oidSplice()",
      "section_title": true,
      "ja": "8.3.8。 oidSplice（）"
    },
    {
      "indent": 6,
      "text": "string oidSplice(string oid1, integer offset, integer len, string\n   oid2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "oidSplice returns an OID formed by replacing 'len' subidentifiers in 'oid1' with all of the subidentifiers from 'oid2', starting at 'offset' in 'oid1' (the first subidentifier is at offset 0). The OID length will be extended, if necessary, if 'offset' + 'len' extends beyond the end of 'oid1'. If 'offset' is larger than the length of oid1, then an RTE will occur.",
      "ja": "oidSpliceは、「oid1」の「len」サブ識別子を「oid1」の「offset」で始まる「oid2」のすべてのサブ識別子に置き換えたOIDを返します（最初のサブ識別子はオフセット0です）。 'offset' + 'len'が 'oid1'の末尾を超えている場合、必要に応じてOIDの長さが延長されます。 'offset'がoid1の長さより大きい場合、RTEが発生します。"
    },
    {
      "indent": 9,
      "text": "The resulting OID is returned.",
      "ja": "結果のOIDが返されます。"
    },
    {
      "indent": 9,
      "text": "For example: oidSplice(\"1.3.6.1.2.1\", 5, 1, \"7\") => \"1.3.6.1.2.7\" oidSplice(\"1.3.6.1.2.1\", 4, 2, \"7.7\") => \"1.3.6.1.7.7\" oidSplice(\"1.3.6.1.2.1\", 4, 3, \"7.7.7\") => \"1.3.6.1.7.7.7\"",
      "ja": "例：oidSplice（ \"1.3.6.1.2.1\"、5、1、 \"7\"）=> \"1.3.6.1.2.7\" oidSplice（ \"1.3.6.1.2.1\"、4、2、 \"7.7\"）=> \"1.3.6.1.7.7\" oidSplice（ \"1.3.6.1.2.1\"、4、3、 \"7.7.7\"）=> \"1.3.6.1.7.7.7\""
    },
    {
      "indent": 0,
      "text": "8.3.9. parseIndex()",
      "section_title": true,
      "ja": "8.3.9。 parseIndex（）"
    },
    {
      "indent": 3,
      "text": "ParseIndex is provided to make it easy to pull index values from OIDs into variables.",
      "ja": "ParseIndexは、OIDから変数にインデックス値を簡単にプルできるように提供されています。"
    },
    {
      "indent": 6,
      "text": "var parseIndex(string oid, integer &index, integer type, integer len)",
      "ja": "var parseIndex（string oid、integer＆index、integer type、integer len）"
    },
    {
      "indent": 9,
      "text": "parseIndex pulls values from the instance identification portion of 'oid', encoded as per Section 7.7, \"Mapping of the INDEX Clause\", of the SMIv2 [2].",
      "ja": "parseIndexは、SMIv2 [2]のセクション7.7「INDEX句のマッピング」に従ってエンコードされた「oid」のインスタンス識別部分から値を取得します。"
    },
    {
      "indent": 9,
      "text": "'oid' is the OID to be parsed.",
      "ja": "'oid'は解析されるOIDです。"
    },
    {
      "indent": 9,
      "text": "'index' describes which subid to begin parsing at. 'index' will be modified to indicate the subid after the last one parsed (even if this points past the last subid). The first subid is index 0. If any error occurs, 'index' will be set to -1 on return. If the input index is less than 0 or refers past the end of the OID, 'index' will be set to -1 on return and the function will return 0.",
      "ja": "「インデックス」は、解析を開始するサブIDを示します。 'index'は、最後の解析後のサブIDを示すように変更されます（これが最後のサブIDを超えている場合でも）。 最初のサブIDはインデックス0です。エラーが発生すると、戻り時に「インデックス」が-1に設定されます。 入力インデックスが0より小さいか、OIDの終わりを超えて参照している場合、戻り時に 'index'が-1に設定され、関数は0を返します。"
    },
    {
      "indent": 9,
      "text": "If 'type' is Integer, 'len' will not be consulted. The return value is the integer value of the next subid.",
      "ja": "「タイプ」が整数の場合、「len」は参照されません。 戻り値は、次のサブIDの整数値です。"
    },
    {
      "indent": 9,
      "text": "If 'type' is String and 'len' is greater than zero, 'len' subids will be parsed. For each subid parsed, the chr() value of the subid will be appended to the returned string. If any subid is greater than 255, 'index' will be set to -1 on return, and an empty string will be returned. If there are fewer than 'len' subids left in 'oid', 'index' will be set to -1 on return, but a string will be returned containing a character for each subid that was left.",
      "ja": "「type」がStringで、「len」がゼロより大きい場合、「len」サブIDが解析されます。 解析された各subidについて、subidのchr（）値が返された文字列に追加されます。 subidが255より大きい場合、戻り時に 'index'は-1に設定され、空の文字列が返されます。 「oid」に「len」未満のサブIDが残っている場合、戻り時に「index」が-1に設定されますが、残った各サブIDの文字を含む文字列が返されます。"
    },
    {
      "indent": 9,
      "text": "If 'type' is String and 'len' is zero, the next subid will be parsed to find N, the length of the string. Then, that many subids will be parsed. For each subid parsed, the chr() value of the subid will be appended to the returned string. If any subid is greater than 255, 'index' will be set to -1 on return, and an empty string will be returned. If there are fewer than N subids left in 'oid', 'index' will be set to -1 on return, but a string will be returned containing a character for each subid that was left.",
      "ja": "'type'がStringで 'len'がゼロの場合、次のサブIDが解析されて、文字列の長さNが検出されます。 次に、その多くのサブIDが解析されます。 解析された各subidについて、subidのchr（）値が返された文字列に追加されます。 subidが255より大きい場合、戻り時に 'index'は-1に設定され、空の文字列が返されます。 'oid'にN個未満のサブIDが残っている場合、戻り時に 'index'は-1に設定されますが、残った各サブIDの文字を含む文字列が返されます。"
    },
    {
      "indent": 9,
      "text": "If 'type' is String and 'len' is -1, subids will be parsed until the end of 'oid'. For each subid parsed, the chr() value of the subid will be appended to the returned string. If any subid is greater than 255, 'index' will be set to -1 on return, and an empty string will be returned.",
      "ja": "'type'がStringで 'len'が-1の場合、subidは 'oid'の終わりまで解析されます。 解析された各subidについて、subidのchr（）値が返された文字列に追加されます。 subidが255より大きい場合、戻り時に 'index'は-1に設定され、空の文字列が返されます。"
    },
    {
      "indent": 9,
      "text": "If 'type' is Oid and 'len' is greater than zero, 'len' subids will be parsed. For each subid parsed, the decimal-encoded value of the subid will be appended to the returned string, with a '.' character appended between each output subid, but not after the last subid. If there are fewer than 'len' subids left in 'oid', 'index' will be set to -1 on return, but a string will be returned containing an encoding for each subid that was left.",
      "ja": "「type」がOidで、「len」がゼロより大きい場合、「len」サブIDが解析されます。 解析された各サブIDに対して、サブIDの10進数でエンコードされた値が、「。」で返された文字列に追加されます。 各出力サブIDの間に追加された文字。ただし、最後のサブIDの後には追加されません。 'oid'に 'len'未満のサブIDが残っている場合、戻り時に 'index'は-1に設定されますが、残った各サブIDのエンコードを含む文字列が返されます。"
    },
    {
      "indent": 9,
      "text": "If 'type' is Oid and 'len' is zero, the next subid will be parsed to find N, the number of subids to parse. For each subid parsed, the decimal-encoded value of the subid will be appended to the returned string, with a '.' character appended between each output subid but not after the last subid. If there are fewer than N subids left in 'oid', 'index' will be set to -1 on return, but a string will be returned containing an encoding for each subid that was left.",
      "ja": "'type'がOidで 'len'がゼロの場合、次のサブIDが解析されて、解析するサブIDの数であるNが検出されます。 解析された各サブIDに対して、サブIDの10進数でエンコードされた値が、「。」で返された文字列に追加されます。 各出力サブIDの間に追加された文字で、最後のサブIDの後には追加されません。 'oid'にN個未満のサブIDが残っている場合、戻り時に 'index'は-1に設定されますが、残った各サブIDのエンコードを含む文字列が返されます。"
    },
    {
      "indent": 9,
      "text": "If 'type' is Oid and 'len' is -1, subids will be parsed until the end of 'oid'. For each subid parsed, the decimal-encoded value of the subid will be appended to the returned string, with a '.' character appended between each output subid, but not after the last subid.",
      "ja": "'type'がOidで 'len'が-1の場合、subidsは 'oid'の終わりまで解析されます。 解析された各サブIDに対して、サブIDの10進数でエンコードされた値が、「。」で返された文字列に追加されます。 各出力サブIDの間に追加された文字。ただし、最後のサブIDの後には追加されません。"
    },
    {
      "indent": 3,
      "text": "For example, to decode the index component of an instance of the ipForward table:",
      "ja": "たとえば、ipForwardテーブルのインスタンスのインデックスコンポーネントをデコードするには："
    },
    {
      "indent": 6,
      "text": "oid = \"ipForwardIfIndex.0.0.0.0.13.0.192.168.1.1\";\nindex = 11;\ndest   =  parseIndex(oid, index, String, 4);\nproto  =  parseIndex(oid, index, Integer, 0);\npolicy =  parseIndex(oid, index, Integer, 0);\nnextHop = parseIndex(oid, index, String, 4);\n// proto and policy now contain integer values\n// dest and nextHop now contain 4 byte IP addresses.  Use\n// stringToDotted to get them to dotted decimal notation:\n// e.g.: stringToDotted(nextHop) => \"192.168.1.1\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.3.10. stringToDotted()",
      "section_title": true,
      "ja": "8.3.10。 stringToDotted（）"
    },
    {
      "indent": 3,
      "text": "stringToDotted() is provided to encode strings suitable for the index portion of an OID or to convert the binary encoding of an IP address to a dotted-decimal encoding.",
      "ja": "stringToDotted（）は、OIDのインデックス部分に適した文字列をエンコードするため、またはIPアドレスのバイナリエンコードをドット付き10進エンコードに変換するために提供されています。"
    },
    {
      "indent": 6,
      "text": "string stringToDotted(string value)",
      "ja": "string stringToDotted（文字列値）"
    },
    {
      "indent": 9,
      "text": "If 'value' is the zero-length string, the zero-length string is returned.",
      "ja": "「値」が長さゼロの文字列の場合、長さゼロの文字列が返されます。"
    },
    {
      "indent": 9,
      "text": "The decimal encoding of the first byte of 'value' is appended to the output string. Then, for each additional byte in 'value', a '.' is appended to the output string, followed by the decimal encoding of the additional byte.",
      "ja": "「値」の最初のバイトの10進エンコードが出力文字列に追加されます。 次に、「値」の追加バイトごとに、「。」 出力文字列に追加され、その後に追加バイトの10進エンコードが続きます。"
    },
    {
      "indent": 0,
      "text": "8.3.11. integer()",
      "section_title": true,
      "ja": "8.3.11。 整数（）"
    },
    {
      "indent": 6,
      "text": "integer integer(var input)",
      "ja": "整数integer（var入力）"
    },
    {
      "indent": 9,
      "text": "integer converts 'input' into an integer by using the rules specified for ToInteger(), returning the integer-typed results.",
      "ja": "integerは、ToInteger（）に指定されたルールを使用して「入力」を整数に変換し、整数型の結果を返します。"
    },
    {
      "indent": 0,
      "text": "8.3.12. string()",
      "section_title": true,
      "ja": "8.3.12。 string（）"
    },
    {
      "indent": 6,
      "text": "string string(var input)",
      "ja": "string string（var input）"
    },
    {
      "indent": 9,
      "text": "string converts 'input' into a string by using the rules specified for ToString(), returning the string-typed results.",
      "ja": "stringは、ToString（）に指定されたルールを使用して「入力」を文字列に変換し、文字列型の結果を返します。"
    },
    {
      "indent": 0,
      "text": "8.3.13. type()",
      "section_title": true,
      "ja": "8.3.13。 タイプ（）"
    },
    {
      "indent": 6,
      "text": "string type(var variable)",
      "ja": "文字列型（var変数）"
    },
    {
      "indent": 9,
      "text": "type returns the type of its argument as either the string 'String' or the string 'Integer'.",
      "ja": "typeは、引数の型を文字列「String」または文字列「Integer」として返します。"
    },
    {
      "indent": 0,
      "text": "8.3.14. chr()",
      "section_title": true,
      "ja": "8.3.14。 chr（）"
    },
    {
      "indent": 6,
      "text": "string chr(integer char)",
      "ja": "文字列chr（整数文字）"
    },
    {
      "indent": 9,
      "text": "Returns a one-character string containing the character specified by the ASCII code contained in 'char'.",
      "ja": "「char」に含まれるASCIIコードで指定された文字を含む1文字の文字列を返します。"
    },
    {
      "indent": 0,
      "text": "8.3.15. ord()",
      "section_title": true,
      "ja": "8.3.15。 ord（）"
    },
    {
      "indent": 6,
      "text": "integer ord(string str)",
      "ja": "整数ord（string str）"
    },
    {
      "indent": 9,
      "text": "Returns the ASCII value of the first character of 'str'. This function complements chr().",
      "ja": "「str」の最初の文字のASCII値を返します。 この関数はchr（）を補完します。"
    },
    {
      "indent": 0,
      "text": "8.3.16. substr()",
      "section_title": true,
      "ja": "8.3.16。 substr（）"
    },
    {
      "indent": 6,
      "text": "string substr(string &str, integer offset\n              [, integer len, string replacement])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Extracts a substring out of 'str' and returns it. The first octet is at offset 0. If the offset is negative, the returned string starts that far from the end of 'str'. If 'len' is positive, the returned string contains up to 'len' octets, up to the end of the string. If 'len' is omitted, the returned string includes everything to the end of 'str'. If 'len' is negative, abs(len) octets are left off the end of the string.",
      "ja": "「str」から部分文字列を抽出して返します。 最初のオクテットはオフセット0にあります。オフセットが負の場合、返される文字列は「str」の末尾から遠く離れたところから始まります。 「len」が正の場合、返される文字列には、文字列の末尾までの「len」オクテットが含まれます。 「len」を省略すると、返される文字列には「str」の末尾までのすべてが含まれます。 'len'が負の場合、abs（len）オクテットは文字列の末尾から除外されます。"
    },
    {
      "indent": 9,
      "text": "If a substring is specified that is partly outside the string, the part within the string is returned. If the substring is totally outside the string, a zero-length string is produced.",
      "ja": "部分的に文字列の外側にある部分文字列が指定されている場合、文字列内の部分が返されます。 部分文字列が完全に文字列の外側にある場合、長さゼロの文字列が生成されます。"
    },
    {
      "indent": 9,
      "text": "If the optional 'replacement' argument is included, 'str' is modified. 'offset' and 'len' act as above to select a range of octets in 'str'. These octets are replaced with octets from 'replacement'. If the replacement string is shorter or longer than the number of octets selected, 'str' will shrink or grow, respectively. If 'replacement' is included, the 'len' argument must also be included.",
      "ja": "オプションの「replacement」引数が含まれている場合、「str」が変更されます。 'offset'と 'len'は、上記のように機能して、 'str'のオクテットの範囲を選択します。 これらのオクテットは、「置換」からのオクテットに置き換えられます。 置換文字列が選択されたオクテットの数より短いか長い場合、「str」はそれぞれ縮小または拡大します。 'replacement'が含まれる場合、 'len'引数も含まれる必要があります。"
    },
    {
      "indent": 9,
      "text": "Note that to replace everything from offset to the end of the string, substr() should be called as follows:",
      "ja": "オフセットから文字列の末尾までをすべて置換するには、substr（）を次のように呼び出す必要があります。"
    },
    {
      "indent": 12,
      "text": "substr(str, offset, strlen(str) - offset, replacement)",
      "ja": "substr（str、offset、strlen（str）-オフセット、置換）"
    },
    {
      "indent": 0,
      "text": "8.4. General Functions",
      "section_title": true,
      "ja": "8.4。 一般的な機能"
    },
    {
      "indent": 3,
      "text": "The following POSIX standard library functions are provided:",
      "ja": "次のPOSIX標準ライブラリ関数が提供されています。"
    },
    {
      "indent": 7,
      "text": "strncmp()\nstrncasecmp()\nstrlen()\nrandom()\nsprintf()\nsscanf()",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9. International String Library",
      "section_title": true,
      "ja": "9.国際文字列ライブラリ"
    },
    {
      "indent": 3,
      "text": "This library is optional for systems that wish to have support for collating (sorting) and verifying equality of international strings in a manner that will be least surprising to humans. International strings are encoded in the UTF-8 transformation format described in [14]. This library is registered with the name \"pmInternationalStringLibrary\".",
      "ja": "このライブラリは、人間にとって最も驚くような方法で国際文字列の照合（ソート）および検証をサポートしたいシステムではオプションです。 国際文字列は、[14]で説明されているUTF-8変換形式でエンコードされます。 このライブラリは、「pmInternationalStringLibrary」という名前で登録されています。"
    },
    {
      "indent": 3,
      "text": "When verifying equality of international strings in the Unicode character set, it is recommended to normalize the strings with the stringprep() function before checking for equality.",
      "ja": "Unicode文字セットの国際文字列の等価性を検証する場合、等価性をチェックする前にstringprep（）関数で文字列を正規化することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "When attempting to sort international strings in the Unicode character set, normalization should also be performed, but note that the result is highly context dependent and hard to implement correctly. Just ordering by Unicode Codepoint Value is in many cases not what the end user expects. See Unicode technical note 9 for more information about sorting.",
      "ja": "Unicode文字セットの国際文字列を並べ替える際には、正規化も実行する必要がありますが、結果はコンテキストに大きく依存しており、正しく実装するのが難しいことに注意してください。 Unicode Codepoint Valueによる注文は、多くの場合、エンドユーザーが期待するものではありません。 ソートの詳細については、Unicodeテクニカルノート9を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.1. stringprep()",
      "section_title": true,
      "ja": "9.1。 stringprep（）"
    },
    {
      "indent": 6,
      "text": "integer stringprep(string utf8Input, string &utf8Output)",
      "ja": "整数stringprep（string utf8Input、string＆utf8Output）"
    },
    {
      "indent": 9,
      "text": "Performs the Stringprep [13] transformation for appropriate comparison of internationalized strings. The transformation is performed on 'utf8Input'; if the transformation finishes without error, the resulting string is written to utf8Output. The stringprep profile used is specified below in Section 9. If it is successful, the function returns 1.",
      "ja": "国際化された文字列を適切に比較するために、Stringprep [13]変換を実行します。 変換は「utf8Input」で実行されます。 変換がエラーなしで終了した場合、結果の文字列はutf8Outputに書き込まれます。 使用されるstringprepプロファイルは、セクション9で指定されます。成功した場合、関数は1を返します。"
    },
    {
      "indent": 9,
      "text": "If the stringprep transformation encounters an error, 0 is returned, and the utf8Output parameter remains unchanged.",
      "ja": "stringprep変換でエラーが発生した場合、0が返され、utf8Outputパラメーターは変更されません。"
    },
    {
      "indent": 9,
      "text": "For example, to compare UTF8 strings 'one' and 'two':",
      "ja": "たとえば、UTF8文字列「one」と「two」を比較するには："
    },
    {
      "indent": 9,
      "text": "if (stringprep(one, a) && stringprep(two, b)){ if (a == b){ // strings are identical } else { // strings are different } } else { // strings couldn't be transformed for comparison }",
      "ja": "if（stringprep（one、a）&& stringprep（two、b））{if（a == b）{//文字列は同じ} else {//文字列は異なる}} else {//文字列は変換できなかった 比較のために}"
    },
    {
      "indent": 9,
      "text": "See Stringprep [13] for more information.",
      "ja": "詳細については、Stringprep [13]を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.1.1. Stringprep Profile",
      "section_title": true,
      "ja": "9.1.1。 Stringprepプロファイル"
    },
    {
      "indent": 3,
      "text": "The Stringprep specification [13] describes a framework for preparing Unicode text strings in order to increase the likelihood that string input and string comparison work in ways that make sense for typical users throughout the world. Specifications that specify stringprep (as this one does) are required to fully specify stringprep's processing options by documenting a stringprep profile.",
      "ja": "Stringprep仕様[13]は、世界中の一般的なユーザーにとって意味のある方法で文字列入力と文字列比較が機能する可能性を高めるために、Unicodeテキスト文字列を準備するためのフレームワークを説明しています。 stringprepプロファイルを文書化してstringprepの処理オプションを完全に指定するには、stringprepを指定する仕様（これが指定する仕様）が必要です。"
    },
    {
      "indent": 3,
      "text": "This profile defines the following, as required by Stringprep:",
      "ja": "このプロファイルは、Stringprepの必要に応じて以下を定義します。"
    },
    {
      "indent": 3,
      "text": "- The intended applicability of the profile: internationalized network management information.",
      "ja": "-プロファイルの意図された適用可能性：国際化されたネットワーク管理情報。"
    },
    {
      "indent": 3,
      "text": "- The character repertoire that is the input and output to stringprep: Unicode 3.2, as defined in Stringprep [13], Appendix A.1.",
      "ja": "-stringprepへの入力および出力である文字レパートリー：Unicode 3.2、Stringprep [13]、付録A.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "- The mapping tables used: Table B.1 from Stringprep [13].",
      "ja": "-使用されたマッピングテーブル：Stringprep [13]のテーブルB.1。"
    },
    {
      "indent": 3,
      "text": "- Any additional mapping tables specific to the profile: None.",
      "ja": "-プロファイルに固有の追加のマッピングテーブル：なし。"
    },
    {
      "indent": 3,
      "text": "- The Unicode normalization used: Form KC, as described in Stringprep [13].",
      "ja": "-使用されたUnicode正規化：Stringprep [13]で説明されているフォームKC。"
    },
    {
      "indent": 3,
      "text": "- The characters that are prohibited as output: As specified in the following tables from Stringprep [13]:",
      "ja": "-出力として禁止されている文字：Stringprep [13]の以下の表に指定されているとおり："
    },
    {
      "indent": 7,
      "text": "Table C.2\nTable C.3\nTable C.4\nTable C.5\nTable C.6\nTable C.7\nTable C.8\nTable C.9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "- Bidirectional character handling: not performed.",
      "ja": "-双方向文字処理：実行されません。"
    },
    {
      "indent": 3,
      "text": "- Any additional characters that are prohibited as output: None.",
      "ja": "-出力として禁止されている追加文字：なし。"
    },
    {
      "indent": 0,
      "text": "9.2. utf8Strlen()",
      "section_title": true,
      "ja": "9.2。 utf8Strlen（）"
    },
    {
      "indent": 6,
      "text": "integer utf8Strlen(string str)",
      "ja": "整数utf8Strlen（string str）"
    },
    {
      "indent": 9,
      "text": "Returns the number of UTF-8 characters in 'str', which may be less than the number of octets in 'str' if one or more characters are multi-byte characters.",
      "ja": "'str'のUTF-8文字の数を返します。1つ以上の文字がマルチバイト文字の場合、 'str'のオクテット数より少ない場合があります。"
    },
    {
      "indent": 0,
      "text": "9.3. utf8Chr()",
      "section_title": true,
      "ja": "9.3。 utf8Chr（）"
    },
    {
      "indent": 6,
      "text": "string utf8Chr(integer utf8)",
      "ja": "文字列utf8Chr（整数utf8）"
    },
    {
      "indent": 9,
      "text": "Returns a one-character string containing the character specified by the UTF-8 code contained in 'utf8'. Although it contains only 1 UTF-8 character, the resulting string may be more than 1 octet in length.",
      "ja": "'utf8'に含まれるUTF-8コードで指定された文字を含む1文字の文字列を返します。 UTF-8文字は1つしか含まれていませんが、結果の文字列の長さは1オクテット以上になる場合があります。"
    },
    {
      "indent": 0,
      "text": "9.4. utf8Ord()",
      "section_title": true,
      "ja": "9.4。 utf8Ord（）"
    },
    {
      "indent": 6,
      "text": "integer utf8Ord(string str)",
      "ja": "整数utf8Ord（string str）"
    },
    {
      "indent": 9,
      "text": "Returns the UTF-8 code-point value of the first character of 'str'. Note that the first UTF-8 character in 'str' may be more than 1 octet in length. This function complements chr().",
      "ja": "'str'の最初の文字のUTF-8コードポイント値を返します。 'str'の最初のUTF-8文字の長さは1オクテット以上であることに注意してください。 この関数はchr（）を補完します。"
    },
    {
      "indent": 0,
      "text": "9.5. utf8Substr()",
      "section_title": true,
      "ja": "9.5。 utf8Substr（）"
    },
    {
      "indent": 6,
      "text": "string utf8Substr(string &str, integer offset\n              [, integer len, string replacement])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Extracts a substring out of 'str' and returns it, keeping track of UTF-8 character boundaries and using them, instead of octets, as the basis for offset and length calculations. The first character is at offset 0. If offset is negative, the returned string starts that far from the end of 'str'. If 'len' is positive, the returned string contains up to 'len' characters, up to the end of the string. If 'len' is omitted, the returned string includes everything to the end of 'str'. If 'len' is negative, abs(len) characters are left off the end of the string.",
      "ja": "'str'から部分文字列を抽出して返し、UTF-8文字の境界を追跡し、オクテットの代わりにそれらをオフセットおよび長さの計算の基礎として使用します。 最初の文字はオフセット0にあります。offsetが負の場合、返される文字列は 'str'の末尾から遠く離れたところから始まります。 「len」が正の場合、返される文字列には、文字列の末尾までの「len」文字までが含まれます。 「len」を省略すると、返される文字列には「str」の末尾までのすべてが含まれます。 'len'が負の場合、abs（len）文字は文字列の末尾から除外されます。"
    },
    {
      "indent": 9,
      "text": "If you specify a substring that is partly outside the string, the part within the string is returned. If the substring is totally outside the string, a zero-length string is produced.",
      "ja": "部分的に文字列の外側にある部分文字列を指定すると、文字列内の部分が返されます。 部分文字列が完全に文字列の外側にある場合、長さゼロの文字列が生成されます。"
    },
    {
      "indent": 9,
      "text": "If the optional 'replacement' argument is included, 'str' is modified. 'offset' and 'len' act as above to select a range of characters in 'str'. These characters are replaced with characters from 'replacement'. If the replacement string is shorter or longer than the number of characters selected, 'str' will shrink or grow, respectively. If 'replacement' is included, the 'len' argument must also be included.",
      "ja": "オプションの「replacement」引数が含まれている場合、「str」が変更されます。 'offset'と 'len'は上記のように機能し、 'str'の文字の範囲を選択します。 これらの文字は、「置換」の文字に置き換えられます。 置換文字列が選択された文字数より短いか長い場合、「str」はそれぞれ縮小または拡大します。 'replacement'が含まれる場合、 'len'引数も含まれる必要があります。"
    },
    {
      "indent": 9,
      "text": "Note that to replace everything from offset to the end of the string, substr() should be called as follows:",
      "ja": "オフセットから文字列の末尾までをすべて置換するには、substr（）を次のように呼び出す必要があります。"
    },
    {
      "indent": 12,
      "text": "substr(str, offset, strlen(str) - offset, replacement)",
      "ja": "substr（str、offset、strlen（str）-オフセット、置換）"
    },
    {
      "indent": 0,
      "text": "10. Schedule Table",
      "section_title": true,
      "ja": "10.スケジュール表"
    },
    {
      "indent": 3,
      "text": "This table is an adapted form of the policyTimePeriodCondition class defined in the Policy Core Information Model, RFC 3060 [18]. Some of the objects describing a schedule are expressed in formats defined in the iCalendar specification [15].",
      "ja": "このテーブルは、Policy Core Information Model、RFC 3060 [18]で定義されたpolicyTimePeriodConditionクラスの適合した形式です。 スケジュールを記述するオブジェクトの一部は、iCalendar仕様[15]で定義されている形式で表されます。"
    },
    {
      "indent": 3,
      "text": "The policy schedule table allows control over when a valid policy will be ready, based on the date and time.",
      "ja": "ポリシースケジュールテーブルを使用すると、日付と時刻に基づいて、有効なポリシーをいつ準備できるかを制御できます。"
    },
    {
      "indent": 3,
      "text": "A policy's pmPolicySchedule variable refers to a group of one or more schedules in the schedule table. At any given time, if any of these schedules are active, the policy will be ready (assuming that it is enabled and thus valid), and its conditions and actions will be executed, as appropriate. At times when none of these schedules are active, the policy will not be ready and will have no effect. A policy will always be ready if its pmPolicySchedule variable is 0. If a policy has a non-zero pmPolicySchedule that doesn't refer to a group that includes an active schedule, then the policy will not be ready, even if this is due to a misconfiguration of the pmPolicySchedule object or the pmSchedTable.",
      "ja": "ポリシーのpmPolicySchedule変数は、スケジュールテーブル内の1つ以上のスケジュールのグループを参照します。 いつでも、これらのスケジュールのいずれかがアクティブである場合、ポリシーが準備され（有効であり、有効であると仮定）、必要に応じてその条件とアクションが実行されます。 これらのスケジュールのいずれもアクティブでない場合、ポリシーは準備ができておらず、効果がありません。 ポリシーのpmPolicySchedule変数が0の場合、ポリシーは常に準備完了です。ポリシーにアクティブなスケジュールを含むグループを参照しない0以外のpmPolicyScheduleがある場合、ポリシーは準備ができていません。これは、 pmPolicyScheduleオブジェクトまたはpmSchedTableの設定ミス。"
    },
    {
      "indent": 3,
      "text": "A policy that is controlled by a schedule group immediately executes its policy condition (and conditionally the policyAction) when the schedule group becomes active, periodically re-executing these scripts as appropriate until the schedule group becomes inactive (i.e., all schedules are inactive).",
      "ja": "スケジュールグループによって制御されるポリシーは、スケジュールグループがアクティブになるとすぐにポリシー条件（および条件付きでpolicyAction）を実行し、スケジュールグループが非アクティブになるまですべてのスクリプトを定期的に再実行します（つまり、すべてのスケジュールが非アクティブになります）。"
    },
    {
      "indent": 3,
      "text": "An individual schedule item is active at those times that match all the variables that define the schedule: pmSchedTimePeriod, pmSchedMonth, pmSchedDay, pmSchedWeekDay, and pmSchedTimeOfDay. It is possible to specify multiple values for each schedule item. This provides a mechanism for defining complex schedules. For example, a schedule that is active the entire workday each weekday could be defined.",
      "ja": "個々のスケジュールアイテムは、スケジュールを定義するすべての変数に一致する時間にアクティブになります：pmSchedTimePeriod、pmSchedMonth、pmSchedDay、pmSchedWeekDay、およびpmSchedTimeOfDay。 各スケジュール項目に複数の値を指定することができます。 これにより、複雑なスケジュールを定義するメカニズムが提供されます。 たとえば、各平日の稼働日全体でアクティブなスケジュールを定義できます。"
    },
    {
      "indent": 3,
      "text": "Months, days, and weekdays are specified by using the objects pmSchedMonth, pmSchedDay, and pmSchedWeekDay of type BITS. Setting multiple bits in these objects causes an OR operation. For example, setting the bits monday(1) and friday(5) in pmSchedWeekDay restricts the schedule to Mondays and Fridays.",
      "ja": "タイプBITSのオブジェクトpmSchedMonth、pmSchedDay、およびpmSchedWeekDayを使用して、月、日、および曜日を指定します。 これらのオブジェクトに複数のビットを設定すると、OR演算が発生します。 たとえば、pmSchedWeekDayでビットmonday（1）およびfriday（5）を設定すると、スケジュールは月曜日と金曜日に制限されます。"
    },
    {
      "indent": 3,
      "text": "The matched times for pmSchedTimePeriod, pmSchedMonth, pmSchedDay pmSchedWeekDay, and pmSchedTimeOfDay are ANDed together to determine the time periods when the schedule will be active; in other words, the schedule is only active for those times when ALL of these schedule attributes match. For example, a schedule with an overall validity range of January 1, 2000, through December 31, 2000; a month mask that selects March and April; a day-of-the-week mask that selects Fridays; and a time-of-day range of 0800 through 1600 would represent the following time periods:",
      "ja": "pmSchedTimePeriod、pmSchedMonth、pmSchedDay、pmSchedWeekDay、およびpmSchedTimeOfDayの一致した時間は、スケジュールがアクティブになる期間を決定するためにANDされます。 つまり、これらのスケジュール属性のすべてが一致する場合にのみ、スケジュールがアクティブになります。 たとえば、2000年1月1日から2000年12月31日までの全体的な有効範囲を持つスケジュール。 3月と4月を選択する月マスク。 金曜日を選択する曜日マスク; また、0800〜1600の時刻範囲は、次の期間を表します。"
    },
    {
      "indent": 6,
      "text": "Friday, March 5, 2000, from 0800 through 1600 Friday, March 12, 2000, from 0800 through 1600 Friday, March 19, 2000, from 0800 through 1600 Friday, March 26, 2000, from 0800 through 1600 Friday, April 2, 2000, from 0800 through 1600 Friday, April 9, 2000, from 0800 through 1600 Friday, April 16, 2000, from 0800 through 1600 Friday, April 23, 2000, from 0800 through 1600 Friday, April 30, 2000, from 0800 through 1600",
      "ja": "2000年3月5日金曜日、0800から1600 2000年3月12日金曜日、0800から1600 2000年3月19日金曜日、0800から1600 2000年3月26日金曜日、0800から1600 2000年4月2日金曜日 、2000年4月9日金曜日0800〜1600、2000年4月16日金曜日0800〜1600、2000年4月23日金曜日0800〜1600、2000年4月30日金曜日0800〜1600、0800〜1600"
    },
    {
      "indent": 3,
      "text": "Wildcarding of schedule attributes of type BITS is achieved by setting all bits to one.",
      "ja": "タイプBITSのスケジュール属性のワイルドカードは、すべてのビットを1に設定することにより実現されます。"
    },
    {
      "indent": 3,
      "text": "It is possible to define schedules that will never cause a policy to be activated. For example, one can define a schedule that should be active on February 31st.",
      "ja": "ポリシーをアクティブにしないスケジュールを定義することができます。 たとえば、2月31日にアクティブになるスケジュールを定義できます。"
    },
    {
      "indent": 0,
      "text": "11. Definitions",
      "section_title": true,
      "ja": "11.定義"
    },
    {
      "indent": 0,
      "text": "POLICY-BASED-MANAGEMENT-MIB DEFINITIONS ::= BEGIN\nIMPORTS\n    MODULE-IDENTITY, OBJECT-TYPE, NOTIFICATION-TYPE,\n    Counter32, Gauge32, Unsigned32,\n    mib-2                                       FROM SNMPv2-SMI\n    RowStatus, RowPointer, TEXTUAL-CONVENTION,\n    DateAndTime, StorageType                    FROM SNMPv2-TC\n    MODULE-COMPLIANCE, OBJECT-GROUP,\n    NOTIFICATION-GROUP                          FROM SNMPv2-CONF\n    SnmpAdminString                             FROM SNMP-FRAMEWORK-MIB;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Policy-Based Management MIB",
      "ja": "-ポリシーベースの管理MIB"
    },
    {
      "indent": 0,
      "text": "pmMib MODULE-IDENTITY LAST-UPDATED \"200502070000Z\" -- February 7, 2005 ORGANIZATION \"IETF SNMP Configuration Working Group\" CONTACT-INFO \"",
      "ja": "pmMib MODULE-IDENTITY LAST-UPDATED \"200502070000Z\"-2005年2月7日ORGANIZATION \"IETF SNMP Configuration Working Group\" CONTACT-INFO \""
    },
    {
      "indent": 8,
      "text": "Steve Waldbusser\nPhone: +1-650-948-6500\nFax:   +1-650-745-0671\nEmail: waldbusser@nextbeacon.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Jon Saperia (WG Co-chair) JDS Consulting, Inc. 84 Kettell Plain Road. Stow MA 01775 USA Phone: +1-978-461-0249 Fax: +1-617-249-0874 Email: saperia@jdscons.com",
      "ja": "Jon Saperia（WG共同議長）JDS Consulting、Inc. 84 Kettell Plain Road。 Stow MA 01775 USA電話：+ 1-978-461-0249ファックス：+ 1-617-249-0874メール：saperia@jdscons.com"
    },
    {
      "indent": 8,
      "text": "Thippanna Hongal Riverstone Networks, Inc. 5200 Great America Parkway Santa Clara, CA, 95054 USA",
      "ja": "Thippanna Hongal Riverstone Networks、Inc. 5200 Great America Parkway Santa Clara、CA、95054 USA"
    },
    {
      "indent": 8,
      "text": "Phone: +1-408-878-6562 Fax: +1-408-878-6501 Email: hongal@riverstonenet.com",
      "ja": "電話：+ 1-408-878-6562ファックス：+ 1-408-878-6501メール：hongal@riverstonenet.com"
    },
    {
      "indent": 8,
      "text": "David Partain (WG Co-chair) Postal: Ericsson AB P.O. Box 1248 SE-581 12 Linkoping Sweden Tel: +46 13 28 41 44 E-mail: David.Partain@ericsson.com",
      "ja": "David Partain（WG共同議長）郵便番号：Ericsson AB P.O. Box 1248 SE-581 12 Linkoping Sweden Tel：+46 13 28 41 44 E-mail：David.Partain@ericsson.com"
    },
    {
      "indent": 4,
      "text": " Any questions or comments about this document can also be directed to the working group at snmpconf@snmp.com.\" DESCRIPTION \"The MIB module for policy-based configuration of SNMP infrastructures.",
      "ja": "このドキュメントに関する質問やコメントは、snmpconf @ snmp.comのワーキンググループに送ることもできます。 \"DESCRIPTION\" SNMPインフラストラクチャのポリシーベースの構成のためのMIBモジュール。"
    },
    {
      "indent": 8,
      "text": "Copyright (C) The Internet Society (2005).  This version of\nthis MIB module is part of RFC 4011; see the RFC itself for\nfull legal notices.\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "REVISION \"200502070000Z\"    -- February 7, 2005\nDESCRIPTION\n    \"The original version of this MIB, published as RFC4011.\"\n::= { mib-2 124 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PmUTF8String ::= TEXTUAL-CONVENTION\n    STATUS       current\n    DESCRIPTION\n        \"An octet string containing information typically in\n        human-readable form.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "To facilitate internationalization, this\ninformation is represented by using the ISO/IEC\nIS 10646-1 character set, encoded as an octet\nstring using the UTF-8 transformation format\ndescribed in RFC 3629.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "As additional code points are added by amendments to the 10646 standard from time to time, implementations must be prepared to encounter any code point from 0x00000000 to 0x10FFFF. Byte sequences that do not correspond to the valid UTF-8 encoding of a code point or that are outside this range are prohibited.",
      "ja": "追加のコードポイントが10646標準の修正によって随時追加されるため、0x00000000から0x10FFFFまでのコードポイントに遭遇する実装を準備する必要があります。 コードポイントの有効なUTF-8エンコーディングに対応しない、またはこの範囲外のバイトシーケンスは禁止されています。"
    },
    {
      "indent": 8,
      "text": "The use of control codes should be avoided.",
      "ja": "制御コードの使用は避けてください。"
    },
    {
      "indent": 8,
      "text": "When it is necessary to represent a newline, the control code sequence CR LF should be used.",
      "ja": "改行を表す必要がある場合は、制御コードシーケンスCR LFを使用する必要があります。"
    },
    {
      "indent": 8,
      "text": "For code points not directly supported by user interface hardware or software, an alternative means of entry and display, such as hexadecimal, may be provided.",
      "ja": "ユーザーインターフェイスのハードウェアまたはソフトウェアで直接サポートされていないコードポイントの場合、16進数などの入力および表示の代替手段が提供される場合があります。"
    },
    {
      "indent": 8,
      "text": "For information encoded in 7-bit US-ASCII, the UTF-8 encoding is identical to the US-ASCII encoding.",
      "ja": "7ビットUS-ASCIIでエンコードされた情報の場合、UTF-8エンコードはUS-ASCIIエンコードと同じです。"
    },
    {
      "indent": 8,
      "text": "UTF-8 may require multiple bytes to represent a single character/code point; thus, the length of this object in octets may be different from the number of characters encoded. Similarly, size constraints refer to the number of encoded octets, not the number of characters represented by an encoding.",
      "ja": "UTF-8では、単一の文字/コードポイントを表すために複数のバイトが必要になる場合があります。 したがって、オクテット単位のこのオブジェクトの長さは、エンコードされた文字数と異なる場合があります。 同様に、サイズの制約は、エンコードによって表される文字の数ではなく、エンコードされたオクテットの数を指します。"
    },
    {
      "indent": 8,
      "text": "Note that when this TC is used for an object used or envisioned to be used as an index, then a SIZE restriction MUST be specified so that the number of sub-identifiers for any object instance does not exceed the limit of 128, as defined by",
      "ja": "このTCがインデックスとして使用または想定されるオブジェクトに使用される場合、オブジェクトインスタンスのサブ識別子の数が128の制限を超えないように、サイズ制限を指定する必要があることに注意してください。"
    },
    {
      "indent": 8,
      "text": "RFC 3416.",
      "ja": "RFC 3416。"
    },
    {
      "indent": 7,
      "text": " Note that the size of PmUTF8String object is measured in octets, not characters.\" SYNTAX OCTET STRING (SIZE (0..65535))",
      "ja": "PmUTF8Stringオブジェクトのサイズは、文字ではなくオクテットで測定されることに注意してください。 \"SYNTAX OCTET STRING（SIZE（0..65535））"
    },
    {
      "indent": 0,
      "text": "-- The policy table",
      "ja": "-ポリシーテーブル"
    },
    {
      "indent": 0,
      "text": "pmPolicyTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmPolicyEntry\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"The policy table.  A policy is a pairing of a\n        policyCondition and a policyAction that is used to apply the\n        action to a selected set of elements.\"\n    ::= { pmMib 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyEntry OBJECT-TYPE\n    SYNTAX      PmPolicyEntry\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"An entry in the policy table representing one policy.\"\n    INDEX { pmPolicyAdminGroup, pmPolicyIndex }\n    ::= { pmPolicyTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PmPolicyEntry ::= SEQUENCE {\n    pmPolicyAdminGroup            PmUTF8String,\n    pmPolicyIndex                 Unsigned32,\n    pmPolicyPrecedenceGroup       PmUTF8String,\n    pmPolicyPrecedence            Unsigned32,\n    pmPolicySchedule              Unsigned32,\n    pmPolicyElementTypeFilter     PmUTF8String,\n    pmPolicyConditionScriptIndex  Unsigned32,\n    pmPolicyActionScriptIndex     Unsigned32,\n    pmPolicyParameters            OCTET STRING,\n    pmPolicyConditionMaxLatency   Unsigned32,\n    pmPolicyActionMaxLatency      Unsigned32,\n    pmPolicyMaxIterations         Unsigned32,\n    pmPolicyDescription           PmUTF8String,\n    pmPolicyMatches               Gauge32,\n    pmPolicyAbnormalTerminations  Gauge32,\n    pmPolicyExecutionErrors       Counter32,\n    pmPolicyDebugging             INTEGER,\n    pmPolicyAdminStatus           INTEGER,\n    pmPolicyStorageType           StorageType,\n    pmPolicyRowStatus             RowStatus",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 0,
      "text": "pmPolicyAdminGroup OBJECT-TYPE SYNTAX PmUTF8String (SIZE(0..32)) MAX-ACCESS not-accessible STATUS current DESCRIPTION \"An administratively assigned string that can be used to group policies for convenience, for readability, or to simplify configuration of access control.",
      "ja": "pmPolicyAdminGroup OBJECT-TYPE SYNTAX PmUTF8String（SIZE（0..32））MAX-ACCESSアクセス不可STATUS現在の説明「利便性、読みやすさ、またはアクセス制御の構成を簡素化するためにポリシーをグループ化するために使用できる管理上割り当てられた文字列。"
    },
    {
      "indent": 4,
      "text": "    The value of this string does not affect policy processing in\n    any way.  If grouping is not desired or necessary, this object\n    may be set to a zero-length string.\"\n::= { pmPolicyEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"A unique index for this policy entry, unique among all\n         policies regardless of administrative group.\"\n    ::= { pmPolicyEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyPrecedenceGroup OBJECT-TYPE SYNTAX PmUTF8String (SIZE (0..32)) MAX-ACCESS read-create STATUS current DESCRIPTION \"An administratively assigned string that is used to group policies. For each element, only one policy in the same precedence group may be active on that element. If multiple policies would be active on an element (because their conditions return non-zero), the execution environment will only allow the policy with the highest value of pmPolicyPrecedence to be active.",
      "ja": "pmPolicyPrecedenceGroup OBJECT-TYPE SYNTAX PmUTF8String（SIZE（0..32））MAX-ACCESS read-create STATUS現在の説明「ポリシーをグループ化するために使用される管理上割り当てられた文字列。各要素について、同じ優先グループ内の1つのポリシーのみ 要素で複数のポリシーがアクティブになる場合（条件がゼロ以外を返すため）、実行環境では、pmPolicyPrecedenceの最大値を持つポリシーのみがアクティブになります。"
    },
    {
      "indent": 4,
      "text": "    All values of this object must have been successfully\n    transformed by Stringprep RFC 3454.  Management stations\n    must perform this translation and must only set this object to\n    string values that have been transformed.\"\n::= { pmPolicyEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyPrecedence OBJECT-TYPE SYNTAX Unsigned32 (0..65535) MAX-ACCESS read-create STATUS current",
      "ja": "pmPolicyPrecedence OBJECT-TYPE構文Unsigned32（0..65535）MAX-ACCESS読み取り-作成STATUS現在"
    },
    {
      "indent": 4,
      "text": "DESCRIPTION\n    \"If, while checking to see which policy conditions match an\n    element, 2 or more ready policies in the same precedence group\n    match the same element, the pmPolicyPrecedence object provides\n    the rule to arbitrate which single policy will be active on\n    'this element'.  Of policies in the same precedence group, only\n    the ready and matching policy with the highest precedence\n    value (e.g., 2 is higher than 1) will have its policy action\n    periodically executed on 'this element'.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "When a policy is active on an element but the condition ceases\nto match the element, its action (if currently running) will\nbe allowed to finish and then the condition-matching ready\npolicy with the next-highest precedence will immediately\nbecome active (and have its action run immediately).  If the\ncondition of a higher-precedence ready policy suddenly begins\nmatching an element, the previously-active policy's action (if\ncurrently running) will be allowed to finish and then the\nhigher precedence policy will immediately become active.  Its\naction will run immediately, and any lower-precedence matching\npolicy will not be active anymore.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "In the case where multiple ready policies share the highest value, it is an implementation-dependent matter as to which single policy action will be chosen.",
      "ja": "複数の既製のポリシーが最高の価値を共有する場合、どの単一のポリシーアクションが選択されるかは実装依存の問題です。"
    },
    {
      "indent": 4,
      "text": "    Note that if it is necessary to take certain actions after a\n    policy is no longer active on an element, these actions should\n    be included in a lower-precedence policy that is in the same\n    precedence group.\"\n::= { pmPolicyEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicySchedule OBJECT-TYPE SYNTAX Unsigned32 (1..4294967295) MAX-ACCESS read-create STATUS current DESCRIPTION \"This policy will be ready if any of the associated schedule entries are active.",
      "ja": "pmPolicySchedule OBJECT-TYPE SYNTAX Unsigned32（1..4294967295）MAX-ACCESS読み取り作成ステータス現在の説明「関連付けられたスケジュールエントリのいずれかがアクティブである場合、このポリシーは準備完了です。"
    },
    {
      "indent": 9,
      "text": "If the value of this object is 0, this policy is always\nready.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "     If the value of this object is non-zero but doesn't\n     refer to a schedule group that includes an active schedule,\n     then the policy will not be ready, even if this is due to a\n     misconfiguration of this object or the pmSchedTable.\"\n::= { pmPolicyEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyElementTypeFilter OBJECT-TYPE SYNTAX PmUTF8String (SIZE (0..128)) MAX-ACCESS read-create STATUS current DESCRIPTION \"This object specifies the element types for which this policy can be executed.",
      "ja": "pmPolicyElementTypeFilter OBJECT-TYPE SYNTAX PmUTF8String（SIZE（0..128））MAX-ACCESS読み取り作成ステータス現在の説明「このオブジェクトはこのポリシーが実行することができる要素タイプを指定します。"
    },
    {
      "indent": 8,
      "text": "The format of this object will be a sequence of\npmElementTypeRegOIDPrefix values, encoded in the following\nBNF form:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "elementTypeFilter: oid [ ';' oid ]* oid: subid [ '.' subid ]* subid: '0' | decimal_constant",
      "ja": "elementTypeFilter：oid [';' oid] * oid：subid ['。' subid] * subid： '0' | decimal_constant"
    },
    {
      "indent": 8,
      "text": "For example, to register for the policy to be run on all interface elements, the 'ifEntry' element type will be registered as '1.3.6.1.2.1.2.2.1'.",
      "ja": "たとえば、すべてのインターフェイス要素で実行されるポリシーに登録する場合、「ifEntry」要素タイプは「1.3.6.1.2.1.2.2.1」として登録されます。"
    },
    {
      "indent": 4,
      "text": "    If a value is included that does not represent a registered\n    pmElementTypeRegOIDPrefix, then that value will be ignored.\"\n::= { pmPolicyEntry 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyConditionScriptIndex OBJECT-TYPE SYNTAX Unsigned32 (1..4294967295) MAX-ACCESS read-only STATUS current DESCRIPTION \"A pointer to the row or rows in the pmPolicyCodeTable that contain the condition code for this policy. When a policy entry is created, a pmPolicyCodeIndex value unused by this policy's adminGroup will be assigned to this object.",
      "ja": "pmPolicyConditionScriptIndex OBJECT-TYPE SYNTAX Unsigned32（1..4294967295）MAX-ACCESS読み取り専用STATUS現在の説明「このポリシーの条件コードを含むpmPolicyCodeTableの行へのポインター。ポリシーエントリが作成されると、pmPolicyCodeIndex このポリシーのadminGroupによって使用されていない値は、このオブジェクトに割り当てられます。"
    },
    {
      "indent": 9,
      "text": "A policy condition is one or more PolicyScript statements\nthat result(s) in a boolean value that represents whether\nan element is a member of a set of elements upon which an\naction is to be performed.  If a policy is ready and the\ncondition returns true for an element of a proper element\ntype, and if no higher-precedence policy should be active,\nthen the policy is active on that element.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Condition evaluation stops immediately when any run-time exception is detected, and the policyAction is not executed.",
      "ja": "実行時例外が検出されると、条件評価はすぐに停止し、policyActionは実行されません。"
    },
    {
      "indent": 9,
      "text": "The policyCondition is evaluated for various elements. Any element for which the policyCondition returns any nonzero value will match the condition and will have the associated policyAction executed on that element unless a higher-precedence policy in the same precedence group also matches 'this element'.",
      "ja": "policyConditionは、さまざまな要素について評価されます。 policyConditionがゼロ以外の値を返す要素は条件と一致し、同じ優先順位グループ内のより高い優先順位のポリシーも「この要素」と一致しない限り、その要素で関連するpolicyActionが実行されます。"
    },
    {
      "indent": 9,
      "text": "If the condition object is empty (contains no code) or otherwise does not return a value, the element will not be matched.",
      "ja": "条件オブジェクトが空（コードを含まない）である場合、または値を返さない場合、要素は一致しません。"
    },
    {
      "indent": 4,
      "text": "     When this condition is executed, if SNMP requests are made to\n     the local system and secModel/secName/secLevel aren't\n     specified, access to objects is under the security\n     credentials of the requester who most recently modified the\n     associated pmPolicyAdminStatus object.  If SNMP requests are\n     made in which secModel/secName/secLevel are specified, then\n     the specified credentials are retrieved from the local\n     configuration datastore only if VACM is configured to\n     allow access to the requester who most recently modified the\n     associated pmPolicyAdminStatus object.  See the Security\n     Considerations section for more information.\"\n::= { pmPolicyEntry 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyActionScriptIndex OBJECT-TYPE SYNTAX Unsigned32 (1..4294967295) MAX-ACCESS read-only STATUS current DESCRIPTION \"A pointer to the row or rows in the pmPolicyCodeTable that contain the action code for this policy. When a policy entry is created, a pmPolicyCodeIndex value unused by this policy's adminGroup will be assigned to this object.",
      "ja": "pmPolicyActionScriptIndex OBJECT-TYPE SYNTAX Unsigned32（1..4294967295）MAX-ACCESS読み取り専用STATUS現在の説明「このポリシーのアクションコードを含むpmPolicyCodeTableの行へのポインター。ポリシーエントリが作成されると、pmPolicyCodeIndex このポリシーのadminGroupによって使用されていない値は、このオブジェクトに割り当てられます。"
    },
    {
      "indent": 9,
      "text": "A PolicyAction is an operation performed on a\nset of elements for which the policy is active.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Action evaluation stops immediately when any run-time exception is detected.",
      "ja": "実行時例外が検出されると、アクション評価はすぐに停止します。"
    },
    {
      "indent": 9,
      "text": "When this condition is executed, if SNMP requests are made to the local system and secModel/secName/secLevel aren't specified, access to objects is under the security credentials of the requester who most recently modified the associated pmPolicyAdminStatus object. If SNMP requests are made in which secModel/secName/secLevel are specified, then the specified credentials are retrieved from the local configuration datastore only if VACM is configured to allow access to the requester who most recently modified the associated pmPolicyAdminStatus object. See the Security Considerations section for more information.\"",
      "ja": "この条件が実行されるときに、ローカルシステムに対してSNMP要求が行われ、secModel / secName / secLevelが指定されていない場合、オブジェクトへのアクセスは、関連するpmPolicyAdminStatusオブジェクトを最後に変更したリクエスターのセキュリティ資格情報の下にあります。 secModel / secName / secLevelが指定されたSNMP要求が行われた場合、関連するpmPolicyAdminStatusオブジェクトを最後に変更したリクエスターへのアクセスを許可するようにVACMが構成されている場合にのみ、指定された資格情報がローカル構成データストアから取得されます。 詳細については、セキュリティに関する考慮事項のセクションをご覧ください。"
    },
    {
      "indent": 4,
      "text": "::= { pmPolicyEntry 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyParameters OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE (0..65535))\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"From time to time, policy scripts may seek one or more\n        parameters (e.g., site-specific constants).  These parameters\n        may be installed with the script in this object and are\n        accessible to the script via the getParameters() function.  If\n        it is necessary for multiple parameters to be passed to the\n        script, the script can choose whatever encoding/delimiting\n        mechanism is most appropriate.\"\n    ::= { pmPolicyEntry 9 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyConditionMaxLatency OBJECT-TYPE SYNTAX Unsigned32 (0..2147483647) UNITS \"milliseconds\" MAX-ACCESS read-create STATUS current DESCRIPTION \"Every element under the control of this agent is re-checked periodically to see whether it is under control of this policy by re-running the condition for this policy. This object lets the manager control the maximum amount of time that may pass before an element is re-checked.",
      "ja": "pmPolicyConditionMaxLatency OBJECT-TYPE SYNTAX Unsigned32（0..2147483647）UNITS \"milliseconds\" MAX-ACCESS read-create STATUS現在の説明 このポリシーの条件を再実行する：このオブジェクトを使用すると、マネージャーは、要素が再チェックされるまでの最大時間を制御できます。"
    },
    {
      "indent": 4,
      "text": "    In other words, in any given interval of this duration, all\n    elements must be re-checked.  Note that how the policy agent\n    schedules the checking of various elements within this\n    interval is an implementation-dependent matter.\n    Implementations may wish to re-run a condition more\n    quickly if they note a change to the role strings for an\n    element.\"\n::= { pmPolicyEntry 10 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyActionMaxLatency OBJECT-TYPE SYNTAX Unsigned32 (0..2147483647) UNITS \"milliseconds\" MAX-ACCESS read-create STATUS current DESCRIPTION \"Every element that matches this policy's condition and is therefore under control of this policy will have this policy's action executed periodically to ensure that the element remains in the state dictated by the policy. This object lets the manager control the maximum amount of time that may pass before an element has the action run on it.",
      "ja": "pmPolicyActionMaxLatency OBJECT-TYPE SYNTAX Unsigned32（0..2147483647）UNITS \"milliseconds\" MAX-ACCESS read-create STATUS現在の説明 このオブジェクトは、ポリシーによって指定された状態のままになりますこのオブジェクトを使用すると、マネージャーは、エレメントでアクションが実行されるまでの最大時間を制御できます。"
    },
    {
      "indent": 4,
      "text": "    In other words, in any given interval of this duration, all\n    elements under control of this policy must have the action run\n    on them.  Note that how the policy agent schedules the policy\n    action on various elements within this interval is an\n    implementation-dependent matter.\"\n::= { pmPolicyEntry 11 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyMaxIterations OBJECT-TYPE SYNTAX Unsigned32 MAX-ACCESS read-create STATUS current DESCRIPTION \"If a condition or action script iterates in loops too many times in one invocation, the execution environment may consider it in an infinite loop or otherwise not acting as intended and may be terminated by the execution environment. The execution environment will count the cumulative number of times all 'for' or 'while' loops iterated and will apply a threshold to determine when to terminate the script. What threshold the execution environment uses is an implementation-dependent manner, but the value of this object SHOULD be the basis for choosing the threshold for each script. The value of this object represents a policy-specific threshold and can be tuned for policies of varying workloads. If this value is zero, no threshold will be enforced except for any implementation-dependent maximum. Regardless of this value, the agent is allowed to terminate any script invocation that exceeds a local CPU or memory limitation.",
      "ja": "pmPolicyMaxIterations OBJECT-TYPE SYNTAX Unsigned32 MAX-ACCESS読み取り-作成STATUS現在の説明実行環境は、すべての「for」ループまたは「while」ループが繰り返された累積回数をカウントし、スクリプトを終了するタイミングを決定するためにしきい値を適用します。ただし、このオブジェクトの値は、各スクリプトのしきい値を選択するための基礎である必要があります。このオブジェクトの値は、ポリシー固有のしきい値を表し、さまざまなワークロードのポリシーに合わせて調整できます。実装に依存する最大値を除き、この値に関係なく、エージェントは超過するスクリプト呼び出しを終了することができます。 sローカルCPUまたはメモリの制限。"
    },
    {
      "indent": 4,
      "text": "    Note that the condition and action invocations are tracked\n    separately.\"\n::= { pmPolicyEntry 12 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyDescription OBJECT-TYPE\n    SYNTAX      PmUTF8String\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n         \"A description of this rule and its significance, typically\n         provided by a human.\"\n    ::= { pmPolicyEntry 13 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyMatches OBJECT-TYPE SYNTAX Gauge32",
      "ja": "pmPolicyMatches OBJECT-TYPE構文Gauge32"
    },
    {
      "indent": 4,
      "text": "UNITS       \"elements\"\nMAX-ACCESS  read-only\nSTATUS      current\nDESCRIPTION\n     \"The number of elements that, in their most recent execution\n     of the associated condition, were matched by the condition.\"\n::= { pmPolicyEntry 14 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyAbnormalTerminations OBJECT-TYPE\n    SYNTAX      Gauge32\n    UNITS       \"elements\"\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n         \"The number of elements that, in their most recent execution\n         of the associated condition or action, have experienced a\n         run-time exception and terminated abnormally.  Note that if a\n         policy was experiencing a run-time exception while processing\n         a particular element but runs normally on a subsequent\n         invocation, this number can decline.\"\n    ::= { pmPolicyEntry 15 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyExecutionErrors OBJECT-TYPE\n    SYNTAX      Counter32\n    UNITS       \"errors\"\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n         \"The total number of times that execution of this policy's\n         condition or action has been terminated due to run-time\n         exceptions.\"\n    ::= { pmPolicyEntry 16 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyDebugging OBJECT-TYPE\n    SYNTAX      INTEGER {\n                    off(1),\n                    on(2)\n                }\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n         \"The status of debugging for this policy.  If this is turned\n         on(2), log entries will be created in the pmDebuggingTable\n         for each run-time exception that is experienced by this\n         policy.\"\n    DEFVAL { off }\n    ::= { pmPolicyEntry 17 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyAdminStatus OBJECT-TYPE SYNTAX INTEGER { disabled(1), enabled(2), enabledAutoRemove(3) } MAX-ACCESS read-create STATUS current DESCRIPTION \"The administrative status of this policy.",
      "ja": "pmPolicyAdminStatus OBJECT-TYPE SYNTAX INTEGER {disabled（1）、enabled（2）、enabledAutoRemove（3）} MAX-ACCESS読み取り作成ステータス現在の説明「このポリシーの管理ステータス。"
    },
    {
      "indent": 9,
      "text": "The policy will be valid only if the associated\npmPolicyRowStatus is set to active(1) and this object is set\nto enabled(2) or enabledAutoRemove(3).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "If this object is set to enabledAutoRemove(3), the next time the associated schedule moves from the active state to the inactive state, this policy will immediately be deleted, including any associated entries in the pmPolicyCodeTable.",
      "ja": "このオブジェクトがenabledAutoRemove（3）に設定されている場合、関連付けられたスケジュールがアクティブ状態から非アクティブ状態に次に移動すると、pmPolicyCodeTable内の関連付けられたエントリを含め、このポリシーはすぐに削除されます。"
    },
    {
      "indent": 9,
      "text": "The following related objects may not be changed unless this object is set to disabled(1): pmPolicyPrecedenceGroup, pmPolicyPrecedence, pmPolicySchedule, pmPolicyElementTypeFilter, pmPolicyConditionScriptIndex, pmPolicyActionScriptIndex, pmPolicyParameters, and any pmPolicyCodeTable row referenced by this policy. In order to change any of these parameters, the policy must be moved to the disabled(1) state, changed, and then re-enabled.",
      "ja": "このオブジェクトがdisabled（1）に設定されていない限り、次の関連オブジェクトは変更できません：pmPolicyPrecedenceGroup、pmPolicyPrecedence、pmPolicySchedule、pmPolicyElementTypeFilter、pmPolicyConditionScriptIndex、pmPolicyActionScriptIndex、pmPolicyParameters、およびこのポリシーによって参照されるpmPolicyCodeTable行。 これらのパラメータのいずれかを変更するには、ポリシーをdisabled（1）状態に移動し、変更してから再度有効にする必要があります。"
    },
    {
      "indent": 4,
      "text": "     When this policy moves to either enabled state from the\n     disabled state, any cached values of policy condition must be\n     erased, and any Policy or PolicyElement scratchpad values for\n     this policy should be removed.  Policy execution will begin by\n     testing the policy condition on all appropriate elements.\"\n::= { pmPolicyEntry 18 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyStorageType OBJECT-TYPE SYNTAX StorageType MAX-ACCESS read-create STATUS current DESCRIPTION \"This object defines whether this policy and any associated entries in the pmPolicyCodeTable are kept in volatile storage and lost upon reboot or if this row is backed up by non-volatile or permanent storage.",
      "ja": "pmPolicyStorageType OBJECT-TYPE SYNTAX StorageType MAX-ACCESS read-create STATUS現在の説明「このオブジェクトは、このポリシーとpmPolicyCodeTableの関連エントリが揮発性ストレージに保持され、再起動時に失われるか、この行が不揮発性または 永続的なストレージ。"
    },
    {
      "indent": 4,
      "text": "     If the value of this object is 'permanent', the values for\n     the associated pmPolicyAdminStatus object must remain\n     writable.\"\n::= { pmPolicyEntry 19 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyRowStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current DESCRIPTION \"The row status of this pmPolicyEntry.",
      "ja": "pmPolicyRowStatus OBJECT-TYPE構文RowStatus MAX-ACCESS読み取り-作成STATUS現在の説明「このpmPolicyEntryの行ステータス。"
    },
    {
      "indent": 9,
      "text": "The status may not be set to active if any of the related\nentries in the pmPolicyCode table do not have a status of\nactive or if any of the objects in this row are not set to\nvalid values.  Only the following objects may be modified\nwhile in the active state:\n    pmPolicyParameters\n    pmPolicyConditionMaxLatency\n    pmPolicyActionMaxLatency\n    pmPolicyDebugging\n    pmPolicyAdminStatus",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "     If this row is deleted, any associated entries in the\n     pmPolicyCodeTable will be deleted as well.\"\n::= { pmPolicyEntry 20 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Policy Code Table",
      "ja": "-ポリシーコード表"
    },
    {
      "indent": 0,
      "text": "pmPolicyCodeTable OBJECT-TYPE SYNTAX SEQUENCE OF PmPolicyCodeEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"The pmPolicyCodeTable stores the code for policy conditions and actions.",
      "ja": "PmPolicyCodeEntryのMAX-ACCESSのアクセス不可能なpmPolicyCodeTable OBJECT-TYPE構文配列ステータス現在の説明「pmPolicyCodeTableはポリシー条件およびアクションのためのコードを保存します。"
    },
    {
      "indent": 8,
      "text": "An example of the relationships between the code table and the\npolicy table follows:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "pmPolicyTable AdminGroup Index ConditionScriptIndex ActionScriptIndex A '' 1 1 2 B 'oper' 1 1 2 C 'oper' 2 3 4",
      "ja": "pmPolicyTable AdminGroup Index ConditionScriptIndex ActionScriptIndex A '' 1 1 2 B 'oper' 1 1 2 C 'oper' 2 3 4"
    },
    {
      "indent": 8,
      "text": "pmPolicyCodeTable AdminGroup ScriptIndex Segment Note",
      "ja": "pmPolicyCodeTable AdminGroup ScriptIndex Segment注"
    },
    {
      "indent": 8,
      "text": "'' 1 1 Filter for policy A '' 2 1 Action for policy A 'oper' 1 1 Filter for policy B 'oper' 2 1 Action 1/2 for policy B 'oper' 2 2 Action 2/2 for policy B 'oper' 3 1 Filter for policy C 'oper' 4 1 Action for policy C",
      "ja": "'' 1 1ポリシーAのフィルター '' 2 1ポリシーAのアクション 'oper' 1 1ポリシーBのフィルター 'oper' 2 1ポリシーBのアクション1/2 'oper' 2 2ポリシーBのアクション2/2 ' oper '3 1ポリシーCのフィルター' oper '4 1ポリシーCのアクション"
    },
    {
      "indent": 4,
      "text": "    In this example, there are 3 policies: 1 in the '' adminGroup,\n    and 2 in the 'oper' adminGroup.  Policy A has been assigned\n    script indexes 1 and 2 (these script indexes are assigned out of\n    a separate pool per adminGroup), with 1 code segment each for\n    the filter and the action.  Policy B has been assigned script\n    indexes 1 and 2 (out of the pool for the 'oper' adminGroup).\n    While the filter has 1 segment, the action is longer and is\n    loaded into 2 segments.  Finally, Policy C has been assigned\n    script indexes 3 and 4, with 1 code segment each for the filter\n    and the action.\"\n::= { pmMib 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyCodeEntry OBJECT-TYPE SYNTAX PmPolicyCodeEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"An entry in the policy code table representing one code segment. Entries that share a common AdminGroup/ScriptIndex pair make up a single script. Valid values of ScriptIndex are retrieved from pmPolicyConditionScriptIndex and pmPolicyActionScriptIndex after a pmPolicyEntry is created. Segments of code can then be written to this table with the learned ScriptIndex values.",
      "ja": "pmPolicyCodeEntry OBJECT-TYPE構文PmPolicyCodeEntry MAX-ACCESSアクセス不可STATUS現在の説明「1つのコードセグメントを表すポリシーコードテーブルのエントリ。共通のAdminGroup / ScriptIndexペアを共有するエントリは、単一のスクリプトを構成します。ScriptIndexの有効な値は pmPolicyEntryの作成後のpmPolicyConditionScriptIndexおよびpmPolicyActionScriptIndexその後、学習したScriptIndex値を使用して、コードのセグメントをこのテーブルに書き込むことができます。"
    },
    {
      "indent": 8,
      "text": "The StorageType of this entry is determined by the value of\nthe associated pmPolicyStorageType.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "    The pmPolicyAdminGroup element of the index represents the\n    administrative group of the policy of which this code entry is\n    a part.\"\nINDEX { pmPolicyAdminGroup, pmPolicyCodeScriptIndex,\n        pmPolicyCodeSegment }\n::= { pmPolicyCodeTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PmPolicyCodeEntry ::= SEQUENCE {\n    pmPolicyCodeScriptIndex    Unsigned32,\n    pmPolicyCodeSegment        Unsigned32,\n    pmPolicyCodeText           PmUTF8String,\n    pmPolicyCodeStatus         RowStatus",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 0,
      "text": "pmPolicyCodeScriptIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"A unique index for each policy condition or action.  The code\n         for each such condition or action may be composed of multiple\n         entries in this table if the code cannot fit in one entry.\n         Values of pmPolicyCodeScriptIndex may not be used unless\n         they have previously been assigned in the\n         pmPolicyConditionScriptIndex or pmPolicyActionScriptIndex\n         objects.\"\n    ::= { pmPolicyCodeEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyCodeSegment OBJECT-TYPE SYNTAX Unsigned32 (1..4294967295) MAX-ACCESS not-accessible STATUS current DESCRIPTION \"A unique index for each segment of a policy condition or action.",
      "ja": "pmPolicyCodeSegment OBJECT-TYPE SYNTAX Unsigned32（1..4294967295）アクセス不可能なMAX-ACCESS STATUSの現在の説明「ポリシー条件またはアクションの各セグメントのためのユニークなインデックス。"
    },
    {
      "indent": 4,
      "text": "     When a policy condition or action spans multiple entries in\n     this table, the code of that policy starts from the\n     lowest-numbered segment and continues with increasing segment\n     values until it ends with the highest-numbered segment.\"\n::= { pmPolicyCodeEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyCodeText OBJECT-TYPE SYNTAX PmUTF8String (SIZE (1..1024)) MAX-ACCESS read-create STATUS current DESCRIPTION \"A segment of policy code (condition or action). Lengthy Policy conditions or actions may be stored in multiple segments in this table that share the same value of pmPolicyCodeScriptIndex. When multiple segments are used, it is recommended that each segment be as large as is practical.",
      "ja": "pmPolicyCodeText OBJECT-TYPE SYNTAX PmUTF8String（SIZE（1..1024））MAX-ACCESS read-create STATUS現在の説明「ポリシーコード（条件またはアクション）のセグメント。長いポリシー条件またはアクションは、このテーブルの複数のセグメントに格納できます。 pmPolicyCodeScriptIndexの同じ値を共有する複数のセグメントが使用される場合、各セグメントは実用的な大きさであることが推奨されます。"
    },
    {
      "indent": 4,
      "text": "     Entries in this table are associated with policies by values\n     of the pmPolicyConditionScriptIndex and\n     pmPolicyActionScriptIndex objects.  If the status of the\n     related policy is active, then this object may not be\n     modified.\"\n::= { pmPolicyCodeEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyCodeStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current DESCRIPTION \"The status of this code entry.",
      "ja": "pmPolicyCodeStatus OBJECT-TYPE構文RowStatus MAX-ACCESS読み取り作成ステータス現在の説明「このコードエントリのステータス。"
    },
    {
      "indent": 9,
      "text": "Entries in this table are associated with policies by values\nof the pmPolicyConditionScriptIndex and\npmPolicyActionScriptIndex objects.  If the status of the\nrelated policy is active, then this object can not be\nmodified (i.e., deleted or set to notInService), nor may new\nentries be created.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "     If the status of this object is active, no objects in this\n     row may be modified.\"\n::= { pmPolicyCodeEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Element Type Registration Table",
      "ja": "-エレメントタイプ登録テーブル"
    },
    {
      "indent": 0,
      "text": "pmElementTypeRegTable OBJECT-TYPE SYNTAX SEQUENCE OF PmElementTypeRegEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"A registration table for element types managed by this system.",
      "ja": "pmElementTypeRegTable OBJECT-TYPE構文配列PmElementTypeRegEntry MAX-ACCESSアクセス不可能ステータス現在の説明「このシステムによって管理される要素タイプのための登録表。"
    },
    {
      "indent": 8,
      "text": "The Element Type Registration table allows the manager to\nlearn what element types are being managed by the system and\nto register new types, if necessary.  An element type is\nregistered by providing the OID of an SNMP object (i.e.,\nwithout the instance).  Each SNMP instance that exists under\nthat object is a distinct element.  The index of the element is\nthe index part of the discovered OID.  This index will be\nsupplied to policy conditions and actions so that this code\ncan inspect and configure the element.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "For example, this table might contain the following entries. The first three are agent-installed, and the 4th was downloaded by a management station:",
      "ja": "たとえば、このテーブルには次のエントリが含まれる場合があります。 最初の3つはエージェントがインストールされ、4つ目は管理ステーションによってダウンロードされました。"
    },
    {
      "indent": 2,
      "text": "OIDPrefix MaxLatency Description StorageType ifEntry 100 mS interfaces - builtin readOnly 0.0 100 mS system element - builtin readOnly frCircuitEntry 100 mS FR Circuits - builtin readOnly hrSWRunEntry 60 sec Running Processes volatile",
      "ja": "OIDPrefix MaxLatency説明StorageType ifEntry 100 mSインターフェイス-組み込みreadOnly 0.0 100 mSシステム要素-組み込みreadOnly frCircuitEntry 100 mS FR回線-組み込みreadOnly hrSWRunEntry 60秒実行中のプロセス揮発性"
    },
    {
      "indent": 8,
      "text": "Note that agents may automatically configure elements in this\ntable for frequently used element types (interfaces, circuits,\netc.).  In particular, it may configure elements for whom\ndiscovery is optimized in one or both of the following ways:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "1. The agent may discover elements by scanning internal data structures as opposed to issuing local SNMP requests. It is possible to recreate the exact semantics described in this table even if local SNMP requests are not issued.",
      "ja": "1.エージェントは、ローカルSNMP要求を発行するのではなく、内部データ構造をスキャンして要素を検出する場合があります。 ローカルSNMP要求が発行されない場合でも、この表で説明されている正確なセマンティクスを再作成することは可能です。"
    },
    {
      "indent": 8,
      "text": "2. The agent may receive asynchronous notification of new elements (for example, 'card inserted') and use that information to instantly create elements rather than through polling. A similar feature might be available for the deletion of elements.",
      "ja": "2.エージェントは、新しい要素（たとえば、「カード挿入」）の非同期通知を受信し、その情報を使用して、ポーリングではなく要素を即座に作成できます。 同様の機能が要素の削除に使用できる場合があります。"
    },
    {
      "indent": 4,
      "text": "    Note that the disposition of agent-installed entries is\n    described by the pmPolicyStorageType object.\"\n::= { pmMib 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmElementTypeRegEntry OBJECT-TYPE SYNTAX PmElementTypeRegEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"A registration of an element type.",
      "ja": "pmElementTypeRegEntry OBJECT-TYPE構文PmElementTypeRegEntry MAX-ACCESSアクセス不能ステータス現在の説明「要素タイプの登録。"
    },
    {
      "indent": 4,
      "text": "    Note that some values of this table's index may result in an\n    instance name that exceeds a length of 128 sub-identifiers,\n    which exceeds the maximum for the SNMP protocol.\n    Implementations should take care to avoid such values.\"\nINDEX       { pmElementTypeRegOIDPrefix }\n::= { pmElementTypeRegTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PmElementTypeRegEntry ::= SEQUENCE {\n    pmElementTypeRegOIDPrefix     OBJECT IDENTIFIER,\n    pmElementTypeRegMaxLatency    Unsigned32,\n    pmElementTypeRegDescription   PmUTF8String,\n    pmElementTypeRegStorageType   StorageType,\n    pmElementTypeRegRowStatus     RowStatus\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmElementTypeRegOIDPrefix OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESS not-accessible STATUS current DESCRIPTION \"This OBJECT IDENTIFIER value identifies a table in which all elements of this type will be found. Every row in the referenced table will be treated as an element for the period of time that it remains in the table. The agent will then execute policy conditions and actions as appropriate on each of these elements.",
      "ja": "pmElementTypeRegOIDPrefix OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESSアクセス不可STATUS現在の説明「このOBJECT IDENTIFIER値は、このタイプのすべての要素が見つかるテーブルを識別します。参照されたテーブルのすべての行は、期間の要素として扱われます その後、エージェントは、これらの各要素に対して適切なポリシー条件とアクションを実行します。"
    },
    {
      "indent": 8,
      "text": "This object identifier value is specified down to the 'entry'\ncomponent (e.g., ifEntry) of the identifier.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "The index of each discovered row will be passed to each invocation of the policy condition and policy action.",
      "ja": "検出された各行のインデックスは、ポリシー条件とポリシーアクションの各呼び出しに渡されます。"
    },
    {
      "indent": 8,
      "text": "The actual mechanism by which instances are discovered is implementation dependent. Periodic walks of the table to discover the rows in the table is one such mechanism. This mechanism has the advantage that it can be performed by an agent with no knowledge of the names, syntax, or semantics of the MIB objects in the table. This mechanism also serves as the reference design. Other implementation-dependent mechanisms may be implemented that are more efficient (perhaps because they are hard coded) or that don't require polling. These mechanisms must discover the same elements as would the table-walking reference design.",
      "ja": "インスタンスが検出される実際のメカニズムは実装に依存します。 テーブル内の行を発見するためのテーブルの定期的なウォークは、そのようなメカニズムの1つです。 このメカニズムには、テーブル内のMIBオブジェクトの名前、構文、またはセマンティクスを知らなくてもエージェントが実行できるという利点があります。 このメカニズムは、リファレンスデザインとしても機能します。 より効率的な（おそらくハードコーディングされているため）またはポーリングを必要としない他の実装依存のメカニズムを実装できます。 これらのメカニズムは、テーブルウォークリファレンスデザインと同じ要素を発見する必要があります。"
    },
    {
      "indent": 8,
      "text": "This object can contain a OBJECT IDENTIFIER, '0.0'. '0.0' represents the single instance of the system itself and provides an execution context for policies to operate on the 'system element' and on MIB objects modeled as scalars. For example, '0.0' gives an execution context for policy-based selection of the operating system code version (likely modeled as a scalar MIB object). The element type '0.0' always exists; as a consequence, no actual discovery will take place, and the pmElementTypeRegMaxLatency object will have no effect for the '0.0' element type. However, if the '0.0' element type is not registered in the table, policies will not be executed on the '0.0' element.",
      "ja": "このオブジェクトには、OBJECT IDENTIFIER、「0.0」を含めることができます。 「0.0」はシステム自体の単一インスタンスを表し、「システム要素」およびスカラーとしてモデル化されたMIBオブジェクトで動作するポリシーの実行コンテキストを提供します。 たとえば、「0.0」は、オペレーティングシステムのコードバージョン（スカラーMIBオブジェクトとしてモデル化されている可能性が高い）のポリシーベースの選択の実行コンテキストを提供します。 要素タイプ '0.0'は常に存在します。 結果として、実際の検出は行われず、pmElementTypeRegMaxLatencyオブジェクトは「0.0」要素タイプには影響しません。 ただし、「0.0」要素タイプがテーブルに登録されていない場合、「0.0」要素でポリシーは実行されません。"
    },
    {
      "indent": 8,
      "text": "When a policy is invoked on behalf of a '0.0' entry in this table, the element name will be '0.0', and there is no index of 'this element' (in other words, it has zero length).",
      "ja": "このテーブルの「0.0」エントリに代わってポリシーが呼び出されると、要素名は「0.0」になり、「この要素」のインデックスはありません（つまり、長さがゼロになります）。"
    },
    {
      "indent": 4,
      "text": "    As this object is used in the index for the\n    pmElementTypeRegTable, users of this table should be careful\n    not to create entries that would result in instance names with\n    more than 128 sub-identifiers.\"\n::= { pmElementTypeRegEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmElementTypeRegMaxLatency OBJECT-TYPE SYNTAX Unsigned32 UNITS \"milliseconds\" MAX-ACCESS read-create STATUS current DESCRIPTION \"The PM agent is responsible for discovering new elements of types that are registered. This object lets the manager control the maximum amount of time that may pass between the time an element is created and when it is discovered.",
      "ja": "pmElementTypeRegMaxLatency OBJECT-TYPE SYNTAX Unsigned32 UNITS \"milliseconds\" MAX-ACCESS read-create STATUS現在の説明「PMエージェントは、登録されているタイプの新しい要素を検出する責任があります。このオブジェクトは、マネージャが、 要素が作成された時刻と検出された時刻。"
    },
    {
      "indent": 4,
      "text": "    In other words, in any given interval of this duration, all\n    new elements must be discovered.  Note that how the policy\n    agent schedules the checking of various elements within this\n    interval is an implementation-dependent matter.\"\n::= { pmElementTypeRegEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmElementTypeRegDescription OBJECT-TYPE\n    SYNTAX      PmUTF8String (SIZE (0..64))\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"A descriptive label for this registered type.\"\n    ::= { pmElementTypeRegEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmElementTypeRegStorageType OBJECT-TYPE SYNTAX StorageType MAX-ACCESS read-create STATUS current DESCRIPTION \"This object defines whether this row is kept in volatile storage and lost upon reboot or backed up by non-volatile or permanent storage.",
      "ja": "pmElementTypeRegStorageType OBJECT-TYPE SYNTAX StorageType MAX-ACCESS読み取り-作成ステータス現在の説明「このオブジェクトはこの列が揮発性ストレージで保持され、リブートで失われるか、不揮発性または永久ストレージによってバックアップされるかどうかを定義します。"
    },
    {
      "indent": 4,
      "text": "     If the value of this object is 'permanent', no values in the\n     associated row have to be writable.\"\n::= { pmElementTypeRegEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmElementTypeRegRowStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current DESCRIPTION \"The status of this registration entry.",
      "ja": "pmElementTypeRegRowStatus OBJECT-TYPE構文RowStatus MAX-ACCESS読み取り作成ステータス現在の説明「この登録エントリのステータス。"
    },
    {
      "indent": 4,
      "text": "    If the value of this object is active, no objects in this row\n    may be modified.\"\n::= { pmElementTypeRegEntry 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Role Table",
      "ja": "-役割表"
    },
    {
      "indent": 0,
      "text": "pmRoleTable OBJECT-TYPE SYNTAX SEQUENCE OF PmRoleEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"The pmRoleTable is a read-create table that organizes role strings sorted by element. This table is used to create and modify role strings and their associations, as well as to allow a management station to learn about the existence of roles and their associations.",
      "ja": "pmRoleTable OBJECT-TYPE SYNTAX SEQUENCE OF PmRoleEntry MAX-ACCESS not-accessible STATUS現在の説明「pmRoleTableは、要素別にソートされたロール文字列を整理する読み取り作成テーブルです。このテーブルは、ロール文字列とその関連付けを作成および変更するためにも使用されます 管理ステーションが役割の存在とその関連について学習できるようにするため。"
    },
    {
      "indent": 8,
      "text": "It is the responsibility of the agent to keep track of any\nre-indexing of the underlying SNMP elements and to continue to\nassociate role strings with the element with which they were\ninitially configured.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Policy MIB agents that have elements in multiple local SNMP contexts have to allow some roles to be assigned to elements in particular contexts. This is particularly true when some elements have the same names in different contexts and the context is required to disambiguate them. In those situations, a value for the pmRoleContextName may be provided. When a pmRoleContextName value is not provided, the assignment is to the element in the default context.",
      "ja": "複数のローカルSNMPコンテキストに要素を持つポリシーMIBエージェントは、特定のコンテキストの要素にいくつかの役割を割り当てることを許可する必要があります。 これは、いくつかの要素が異なるコンテキストで同じ名前を持ち、それらを明確にするためにコンテキストが必要な場合に特に当てはまります。 これらの状況では、pmRoleContextNameの値が提供される場合があります。 pmRoleContextName値が提供されない場合、割り当てはデフォルトコンテキストの要素になります。"
    },
    {
      "indent": 8,
      "text": "Policy MIB agents that discover elements on other systems and execute policies on their behalf need to have access to role information for these remote elements. In such situations, role assignments for other systems can be stored in this table by providing values for the pmRoleContextEngineID parameters.",
      "ja": "他のシステム上の要素を検出し、それらに代わってポリシーを実行するポリシーMIBエージェントは、これらのリモート要素のロール情報にアクセスする必要があります。 このような状況では、pmRoleContextEngineIDパラメーターの値を提供することにより、他のシステムの役割の割り当てをこのテーブルに保存できます。"
    },
    {
      "indent": 4,
      "text": "For example: Example: element role context ctxEngineID #comment ifindex.1 gold local, default context ifindex.2 gold local, default context repeaterid.1 foo rptr1 local, rptr1 context repeaterid.1 bar rptr2 local, rptr2 context ifindex.1 gold '' A different system ifindex.1 gold '' B different system",
      "ja": "例：例：エレメントロールコンテキストctxEngineID #comment ifindex.1 gold local、default context ifindex.2 gold local、default context repeaterid.1 foo rptr1 local、rptr1 context repeaterid.1 bar rptr2 local、rptr2 context ifindex.1 gold ' '別のシステムifindex.1 gold' 'B別のシステム"
    },
    {
      "indent": 4,
      "text": "     The agent must store role string associations in non-volatile\n     storage.\"\n::= { pmMib 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmRoleEntry OBJECT-TYPE SYNTAX PmRoleEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"A role string entry associates a role string with an individual element.",
      "ja": "pmRoleEntry OBJECT-TYPE構文PmRoleEntry MAX-ACCESSアクセス不可能ステータス現在の説明「役割ストリングエントリは役割ストリングを個々の要素と関連付けます。"
    },
    {
      "indent": 4,
      "text": "     Note that some combinations of index values may result in an\n     instance name that exceeds a length of 128 sub-identifiers,\n     which exceeds the maximum for the SNMP\n     protocol.  Implementations should take care to avoid such\n     combinations.\"\nINDEX       { pmRoleElement, pmRoleContextName,\n              pmRoleContextEngineID, pmRoleString }\n::= { pmRoleTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PmRoleEntry ::= SEQUENCE {\n    pmRoleElement          RowPointer,\n    pmRoleContextName      SnmpAdminString,\n    pmRoleContextEngineID  OCTET STRING,\n    pmRoleString           PmUTF8String,\n    pmRoleStatus           RowStatus\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmRoleElement OBJECT-TYPE SYNTAX RowPointer MAX-ACCESS not-accessible STATUS current DESCRIPTION \"The element with which this role string is associated.",
      "ja": "pmRoleElement OBJECT-TYPE構文RowPointer MAX-ACCESSアクセス不能STATUS現在の説明「この役割ストリングが関連付けられる要素。"
    },
    {
      "indent": 9,
      "text": "For example, if the element is interface 3, then this object\nwill contain the OID for 'ifIndex.3'.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "If the agent assigns new indexes in the MIB table to represent the same underlying element (re-indexing), the agent will modify this value to contain the new index for the underlying element.",
      "ja": "エージェントが同じ基礎要素を表すためにMIBテーブルの新しいインデックスを割り当てた場合（再インデックス付け）、エージェントはこの値を変更して基礎要素の新しいインデックスを含めます。"
    },
    {
      "indent": 4,
      "text": "     As this object is used in the index for the pmRoleTable,\n     users of this table should be careful not to create entries\n     that would result in instance names with more than 128\n     sub-identifiers.\"\n::= { pmRoleEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmRoleContextName OBJECT-TYPE\n    SYNTAX      SnmpAdminString (SIZE (0..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"If the associated element is not in the default SNMP context\n        for the target system, this object is used to identify the\n        context.  If the element is in the default context, this object\n        is equal to the empty string.\"\n    ::= { pmRoleEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmRoleContextEngineID OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE (0 | 5..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"If the associated element is on a remote system, this object\n        is used to identify the remote system.  This object contains\n        the contextEngineID of the system for which this role string\n        assignment is valid.  If the element is on the local system\n        this object will be the empty string.\"\n    ::= { pmRoleEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmRoleString OBJECT-TYPE SYNTAX PmUTF8String (SIZE (0..64)) MAX-ACCESS not-accessible STATUS current DESCRIPTION \"The role string that is associated with an element through this table. All role strings must have been successfully transformed by Stringprep RFC 3454. Management stations must perform this translation and must only set this object to string values that have been transformed.",
      "ja": "pmRoleString OBJECT-TYPE SYNTAX PmUTF8String（SIZE（0..64））MAX-ACCESSアクセス不可STATUS現在の説明「このテーブルを通じて要素に関連付けられているロール文字列。すべてのロール文字列は、Stringprep RFC 3454によって正常に変換されている必要があります。 管理ステーションはこの変換を実行する必要があり、変換された文字列値にこのオブジェクトを設定する必要があります。"
    },
    {
      "indent": 4,
      "text": "     A role string is an administratively specified characteristic\n     of a managed element (for example, an interface).  It is a\n     selector for policy rules, that determines the applicability of\n     the rule to a particular managed element.\"\n::= { pmRoleEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmRoleStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current DESCRIPTION \"The status of this role string.",
      "ja": "pmRoleStatus OBJECT-TYPE構文RowStatus MAX-ACCESS読み取り作成ステータス現在の説明「この役割ストリングのステータス。"
    },
    {
      "indent": 4,
      "text": "     If the value of this object is active, no object in this row\n     may be modified.\"\n::= { pmRoleEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Capabilities table",
      "ja": "-機能表"
    },
    {
      "indent": 0,
      "text": "pmCapabilitiesTable OBJECT-TYPE SYNTAX SEQUENCE OF PmCapabilitiesEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"The pmCapabilitiesTable contains a description of the inherent capabilities of the system so that management stations can learn of an agent's capabilities and differentially install policies based on the capabilities.",
      "ja": "pmCapabilitiesTable OBJECT-TYPE SYNTAX SEQUENCE OF PmCapabilitiesEntry MAX-ACCESSアクセス不能STATUS現在の説明「pmCapabilitiesTableには、管理ステーションがエージェントの機能を学習し、機能に基づいてポリシーを差分インストールできるように、システムの固有の機能の説明が含まれます。"
    },
    {
      "indent": 4,
      "text": "     Capabilities are expressed at the system level.  There can be\n     variation in how capabilities are realized from one vendor or\n     model to the next.  Management systems should consider these\n     differences before selecting which policy to install in a\n     system.\"\n::= { pmMib 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmCapabilitiesEntry OBJECT-TYPE SYNTAX PmCapabilitiesEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"A capabilities entry holds an OID indicating support for a particular capability. Capabilities may include hardware and software functions and the implementation of MIB Modules. The semantics of the OID are defined in the description of pmCapabilitiesType.",
      "ja": "pmCapabilitiesEntry OBJECT-TYPE構文PmCapabilitiesEntry MAX-ACCESSアクセス不能STATUS現在の説明「機能エントリは特定の機能のサポートを示すOIDを保持します。機能にはハードウェアおよびソフトウェア機能とMIBモジュールの実装が含まれます。OIDのセマンティクスは定義されます pmCapabilitiesTypeの説明。"
    },
    {
      "indent": 9,
      "text": "Entries appear in this table if any element in the system has\na specific capability.  A capability should appear in this\ntable only once, regardless of the number of elements in the\nsystem with that capability.  An entry is removed from this\ntable when the last element in the system that has the\ncapability is removed.  In some cases, capabilities are\ndynamic and exist only in software.  This table should have an\nentry for the capability even if there are no current\ninstances.  Examples include systems with database or WEB\nservices.  While the system has the ability to create new\ndatabases or WEB services, the entry should exist.  In these\ncases, the ability to create these services could come from\nother processes that are running in the system, even though\nthere are no currently open databases or WEB servers running.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Capabilities may include the implementation of MIB Modules but need not be limited to those that represent MIB Modules with one or more configurable objects. It may also be valuable to include entries for capabilities that do not include configuration objects, as that information, in combination with other entries in this table, might be used by the management software to determine whether to install a policy.",
      "ja": "機能には、MIBモジュールの実装が含まれる場合がありますが、1つ以上の設定可能なオブジェクトを持つMIBモジュールを表すものに限定する必要はありません。 また、構成オブジェクトを含まない機能のエントリを含めることも有益です。この情報は、このテーブルの他のエントリと組み合わせて、管理ソフトウェアがポリシーをインストールするかどうかを判断するために使用される可能性があるためです。"
    },
    {
      "indent": 9,
      "text": "Vendor software may also add entries in this table to express capabilities from their private branch.",
      "ja": "ベンダーソフトウェアは、このテーブルにエントリを追加して、プライベートブランチの機能を表現することもできます。"
    },
    {
      "indent": 4,
      "text": "     Note that some values of this table's index may result in an\n     instance name that exceeds a length of 128 sub-identifiers,\n     which exceeds the maximum for the SNMP\n     protocol.  Implementations should take care to avoid such\n     values.\"\nINDEX       { pmCapabilitiesType }\n::= { pmCapabilitiesTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PmCapabilitiesEntry ::= SEQUENCE {\n    pmCapabilitiesType               OBJECT IDENTIFIER\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmCapabilitiesType OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESS read-only STATUS current DESCRIPTION \"There are three types of OIDs that may be present in the pmCapabilitiesType object:",
      "ja": "pmCapabilitiesType OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESS読み取り専用STATUSの現在の記述「pmCapabilitiesTypeオブジェクトに存在するかもしれないOIDには3つのタイプがあります："
    },
    {
      "indent": 9,
      "text": "1) The OID of a MODULE-COMPLIANCE macro that represents the\nhighest level of compliance realized by the agent for that\nMIB Module.  For example, an agent that implements the OSPF\nMIB Module at the highest level of compliance would have the\nvalue of '1.3.6.1.2.1.14.15.2' in the pmCapabilitiesType\nobject.  For software that realizes standard MIB\nModules that do not have compliance statements, the base OID\nof the MIB Module should be used instead.  If the OSPF MIB\nModule had not been created with a compliance statement, then\nthe correct value of the pmCapabilitiesType would be\n'1.3.6.1.2.1.14'.  In the cases where multiple compliance\nstatements in a MIB Module are supported by the agent, and\nwhere one compliance statement does not by definition include\nthe other, each of the compliance OIDs would have entries in\nthis table.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "MIB Documents can contain more than one MIB Module. In the case of OSPF, there is a second MIB Module that describes notifications for the OSPF Version 2 Protocol. If the agent also realizes these functions, an entry will also exist for those capabilities in this table.",
      "ja": "MIBドキュメントには、複数のMIBモジュールを含めることができます。 OSPFの場合、OSPFバージョン2プロトコルの通知を記述する2番目のMIBモジュールがあります。 エージェントがこれらの機能も実現している場合、この表のこれらの機能のエントリも存在します。"
    },
    {
      "indent": 9,
      "text": "2) Vendors should install OIDs in this table that represent vendor-specific capabilities. These capabilities can be expressed just as those described above for MIB Modules on the standards track. In addition, vendors may install any OID they desire from their registered branch. The OIDs may be at any level of granularity, from the root of their entire branch to an instance of a single OID. There is no restriction on the number of registrations they may make, though care should be taken to avoid unnecessary entries.",
      "ja": "2）ベンダーは、ベンダー固有の機能を表すOIDをこの表にインストールする必要があります。 これらの機能は、標準トラックのMIBモジュールについて上記で説明した機能とまったく同じように表現できます。 さらに、ベンダーは、登録ブランチから必要なOIDをインストールできます。 OIDは、ブランチ全体のルートから単一のOIDのインスタンスまで、どのレベルの粒度でもかまいません。 彼らが行う登録の数に制限はありませんが、不必要なエントリを避けるように注意する必要があります。"
    },
    {
      "indent": 9,
      "text": "3) OIDs that represent one capability or a collection of capabilities that could be any collection of MIB Objects or hardware or software functions may be created in working groups and registered in a MIB Module. Other entities (e.g., vendors) may also make registrations. Software will register these standard capability OIDs, as well as vendor specific OIDs.",
      "ja": "3）MIBオブジェクトまたはハードウェアまたはソフトウェア機能のコレクションである1つの機能または機能のコレクションを表すOIDは、ワーキンググループで作成され、MIBモジュールに登録されます。 他のエンティティ（ベンダーなど）も登録できます。 ソフトウェアは、これらの標準機能OIDとベンダー固有のOIDを登録します。"
    },
    {
      "indent": 9,
      "text": "If the OID for a known capability is not present in the table, then it should be assumed that the capability is not implemented.",
      "ja": "既知の機能のOIDがテーブルに存在しない場合、その機能は実装されていないと想定する必要があります。"
    },
    {
      "indent": 4,
      "text": "     As this object is used in the index for the\n     pmCapabilitiesTable, users of this table should be careful\n     not to create entries that would result in instance names\n     with more than 128 sub-identifiers.\"\n::= { pmCapabilitiesEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Capabilities override table",
      "ja": "-機能オーバーライドテーブル"
    },
    {
      "indent": 0,
      "text": "pmCapabilitiesOverrideTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmCapabilitiesOverrideEntry\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"The pmCapabilitiesOverrideTable allows management stations\n         to override pmCapabilitiesTable entries that have been\n         registered by the agent.  This facility can be used to avoid\n         situations in which managers in the network send policies to\n         a system that has advertised a capability in the\n         pmCapabilitiesTable but that should not be installed on this\n         particular system.  One example could be newly deployed equipment that is still in a trial state in a trial state or\n         resources reserved for some other administrative reason.\n         This table can also be used to override entries in the\n         pmCapabilitiesTable through the use of the\n         pmCapabilitiesOverrideState object.  Capabilities can also be\n         declared available in this table that were not registered in\n         the pmCapabilitiesTable.  A management application can make\n         an entry in this table for any valid OID and declare the\n         capability available by setting the\n         pmCapabilitiesOverrideState for that row to valid(1).\"\n    ::= { pmMib 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmCapabilitiesOverrideEntry OBJECT-TYPE SYNTAX PmCapabilitiesOverrideEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"An entry in this table indicates whether a particular capability is valid or invalid.",
      "ja": "pmCapabilitiesOverrideEntry OBJECT-TYPE構文PmCapabilitiesOverrideEntry MAX-ACCESSアクセス不能STATUS現在の説明「この表のエントリは特定の機能が有効か無効かを示します。"
    },
    {
      "indent": 4,
      "text": "     Note that some values of this table's index may result in an\n     instance name that exceeds a length of 128 sub-identifiers,\n     which exceeds the maximum for the SNMP\n     protocol.  Implementations should take care to avoid such\n     values.\"\nINDEX       { pmCapabilitiesOverrideType }\n::= { pmCapabilitiesOverrideTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PmCapabilitiesOverrideEntry ::= SEQUENCE {\n    pmCapabilitiesOverrideType               OBJECT IDENTIFIER,\n    pmCapabilitiesOverrideState              INTEGER,\n    pmCapabilitiesOverrideRowStatus          RowStatus\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmCapabilitiesOverrideType OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESS not-accessible STATUS current DESCRIPTION \"This is the OID of the capability that is declared valid or invalid by the pmCapabilitiesOverrideState value for this row. Any valid OID, as described in the pmCapabilitiesTable, is permitted in the pmCapabilitiesOverrideType object. This means that capabilities can be expressed at any level, from a specific instance of an object to a table or entire module. There are no restrictions on whether these objects are from standards track MIB documents or in the private branch of the MIB.",
      "ja": "pmCapabilitiesOverrideType OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESSアクセス不可STATUS現在の説明「これは、この行のpmCapabilitiesOverrideState値によって有効または無効と宣言された機能のOIDです。pmCapabilitiesTableで説明されている有効なOIDは許可されます。 これは、オブジェクトの特定のインスタンスからテーブルまたはモジュール全体に至るまで、あらゆるレベルで機能を表現できることを意味します。これらのオブジェクトが標準トラックMIBドキュメントからのものであるか、プライベートブランチからのものであるかには制限がありません MIB。"
    },
    {
      "indent": 9,
      "text": "If an entry exists in this table for which there is a\ncorresponding entry in the pmCapabilitiesTable, then this entry\nshall have precedence over the entry in the\npmCapabilitiesTable.  All entries in this table must be\npreserved across reboots.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "     As this object is used in the index for the\n     pmCapabilitiesOverrideTable, users of this table should be\n     careful not to create entries that would result in instance\n     names with more than 128 sub-identifiers.\"\n::= { pmCapabilitiesOverrideEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmCapabilitiesOverrideState OBJECT-TYPE SYNTAX INTEGER { invalid(1), valid(2) } MAX-ACCESS read-create STATUS current DESCRIPTION \"A pmCapabilitiesOverrideState of invalid indicates that management software should not send policies to this system for the capability identified in the pmCapabilitiesOverrideType for this row of the table. This behavior is the same whether the capability represented by the pmCapabilitiesOverrideType exists only in this table (that is, it was installed by an external management application) or exists in this table as well as the pmCapabilitiesTable. This would be the case when a manager wanted to disable a capability that the native management system found and registered in the pmCapabilitiesTable.",
      "ja": "pmCapabilitiesOverrideState OBJECT-TYPE SYNTAX INTEGER {invalid（1）、valid（2）} MAX-ACCESS read-create STATUS現在の説明 テーブルのこの行。pmCapabilitiesOverrideTypeで表される機能がこのテーブルにのみ存在する（つまり、外部管理アプリケーションによってインストールされた）か、このテーブルとpmCapabilitiesTableに存在するかにかかわらず、この動作は同じです。 マネージャーが、ネイティブ管理システムがpmCapabilitiesTableで検出および登録した機能を無効にしたい場合。"
    },
    {
      "indent": 4,
      "text": "     An entry in this table that has a pmCapabilitiesOverrideState\n     of valid should be treated as though it appeared in the\n     pmCapabilitiesTable.  If the entry also exists in the\n     pmCapabilitiesTable in the pmCapabilitiesType object, and if\n     the value of this object is valid, then the system shall\n     operate as though this entry did not exist and policy\n     installations and executions will continue in a normal\n     fashion.\"\n::= { pmCapabilitiesOverrideEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmCapabilitiesOverrideRowStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current DESCRIPTION \"The row status of this pmCapabilitiesOverrideEntry.",
      "ja": "pmCapabilitiesOverrideRowStatus OBJECT-TYPE構文RowStatus MAX-ACCESS読み取り-作成STATUS現在の説明「このpmCapabilitiesOverrideEntryの行ステータス。"
    },
    {
      "indent": 4,
      "text": "     If the value of this object is active, no object in this row\n     may be modified.\"\n::= { pmCapabilitiesOverrideEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- The Schedule Group",
      "ja": "-スケジュールグループ"
    },
    {
      "indent": 0,
      "text": "pmSchedLocalTime OBJECT-TYPE\n    SYNTAX      DateAndTime (SIZE (11))\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n        \"The local time used by the scheduler.  Schedules that\n         refer to calendar time will use the local time indicated\n         by this object.  An implementation MUST return all 11 bytes\n         of the DateAndTime textual-convention so that a manager\n         may retrieve the offset from GMT time.\"\n    ::= { pmMib 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- -- The schedule table that controls the scheduler. --",
      "ja": "--スケジューラを制御するスケジュールテーブル。 -"
    },
    {
      "indent": 0,
      "text": "pmSchedTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmSchedEntry\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"This table defines schedules for policies.\"\n    ::= { pmMib 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedEntry OBJECT-TYPE SYNTAX PmSchedEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"An entry describing a particular schedule.",
      "ja": "pmSchedEntry OBJECT-TYPE構文PmSchedEntry MAX-ACCESSアクセス不可能ステータス現在の説明「特定のスケジュールを記述するエントリ。"
    },
    {
      "indent": 4,
      "text": "    Unless noted otherwise, writable objects of this row can be\n    modified independently of the current value of pmSchedRowStatus,\n    pmSchedAdminStatus and pmSchedOperStatus.  In particular, it\n    is legal to modify pmSchedWeekDay, pmSchedMonth, and\n    pmSchedDay when pmSchedRowStatus is active.\"\nINDEX { pmSchedIndex }\n::= { pmSchedTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PmSchedEntry ::= SEQUENCE {\n    pmSchedIndex          Unsigned32,\n    pmSchedGroupIndex     Unsigned32,\n    pmSchedDescr          PmUTF8String,\n    pmSchedTimePeriod     PmUTF8String,\n    pmSchedMonth          BITS,\n    pmSchedDay            BITS,\n    pmSchedWeekDay        BITS,\n    pmSchedTimeOfDay      PmUTF8String,\n    pmSchedLocalOrUtc     INTEGER,\n    pmSchedStorageType    StorageType,\n    pmSchedRowStatus      RowStatus\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"The locally unique, administratively assigned index for this\n        scheduling entry.\"\n    ::= { pmSchedEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedGroupIndex OBJECT-TYPE SYNTAX Unsigned32 (1..4294967295) MAX-ACCESS read-create STATUS current DESCRIPTION \"The locally unique, administratively assigned index for the schedule group this scheduling entry belongs to.",
      "ja": "pmSchedGroupIndex OBJECT-TYPE SYNTAX Unsigned32（1..4294967295）MAX-ACCESS読み取り作成ステータス現在の説明「このスケジュールエントリが属するスケジュールグループのためのローカルでユニークな、管理上割り当てられたインデックス。"
    },
    {
      "indent": 8,
      "text": "To assign multiple schedule entries to the same group, the\npmSchedGroupIndex of each entry in the group will be set to\nthe same value.  This pmSchedGroupIndex value must be equal to\nthe pmSchedIndex of one of the entries in the group.  If the\nentry whose pmSchedIndex equals the pmSchedGroupIndex\nfor the group is deleted, the agent will assign a new\npmSchedGroupIndex to all remaining members of the group.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "If an entry is not a member of a group, its pmSchedGroupIndex must be assigned to the value of its pmSchedIndex.",
      "ja": "エントリがグループのメンバーではない場合、pmSchedGroupIndexをそのpmSchedIndexの値に割り当てる必要があります。"
    },
    {
      "indent": 4,
      "text": "    Policies that are controlled by a group of schedule entries\n    are active when any schedule in the group is active.\"\n::= { pmSchedEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedDescr OBJECT-TYPE\n    SYNTAX      PmUTF8String\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"The human-readable description of the purpose of this\n        scheduling entry.\"\n    DEFVAL { ''H }\n    ::= { pmSchedEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedTimePeriod OBJECT-TYPE SYNTAX PmUTF8String (SIZE (0..31)) MAX-ACCESS read-create STATUS current DESCRIPTION \"The overall range of calendar dates and times over which this schedule is active. It is stored in a slightly extended version of the format for a 'period-explicit' defined in RFC 2445. This format is expressed as a string representing the starting date and time, in which the character 'T' indicates the beginning of the time portion, followed by the solidus character, '/', followed by a similar string representing an end date and time. The start of the period MUST be before the end of the period. Date-Time values are expressed as substrings of the form 'yyyymmddThhmmss'. For example:",
      "ja": "pmSchedTimePeriod OBJECT-TYPE SYNTAX PmUTF8String（SIZE（0..31））MAX-ACCESS読み取り-作成ステータス現在の説明「このスケジュールがアクティブであるカレンダーの日付と時間の全体的な範囲。 RFC 2445で定義されている「期間明示」の形式。この形式は、開始日時を表す文字列として表されます。文字「T」は時間部分の始まりを示し、その後に固相線文字「/」が続きます。 'に、終了日時を表す同様の文字列が続きます。期間の開始は期間の終了前でなければなりません。日時値は、' yyyymmddThhmmss '形式のサブストリングとして表されます。例："
    },
    {
      "indent": 12,
      "text": "20000101T080000/20000131T130000",
      "ja": "20000101T080000 / 20000131T130000"
    },
    {
      "indent": 14,
      "text": "January 1, 2000, 0800 through January 31, 2000, 1PM",
      "ja": "2000年1月1日、0800〜2000年1月31日、午後1時"
    },
    {
      "indent": 8,
      "text": "The 'Date with UTC time' format defined in RFC 2445 in which the Date-Time string ends with the character 'Z' is not allowed.",
      "ja": "RFC 2445で定義されている「UTC時間の日付」形式では、日付時刻文字列が文字「Z」で終わる形式は許可されません。"
    },
    {
      "indent": 8,
      "text": "This 'period-explicit' format is also extended to allow two special cases in which one of the Date-Time strings is replaced with a special string defined in RFC 2445:",
      "ja": "この 'period-explicit'形式は、Date-Time文字列の1つがRFC 2445で定義された特別な文字列で置き換えられる2つの特別なケースを許可するように拡張されています。"
    },
    {
      "indent": 8,
      "text": "1. If the first Date-Time value is replaced with the string 'THISANDPRIOR', then the value indicates that the schedule is active at any time prior to the Date-Time that appears after the '/'.",
      "ja": "1.最初の日時の値が文字列「THISANDPRIOR」に置き換えられた場合、値は、「/」の後に表示される日時より前の任意の時点でスケジュールがアクティブであることを示します。"
    },
    {
      "indent": 8,
      "text": "2. If the second Date-Time is replaced with the string 'THISANDFUTURE', then the value indicates that the schedule is active at any time after the Date-Time that appears before the '/'.",
      "ja": "2. 2番目の日時が文字列「THISANDFUTURE」で置き換えられる場合、値は、「/」の前に表示される日時の後の任意の時点でスケジュールがアクティブであることを示します。"
    },
    {
      "indent": 4,
      "text": "    Note that although RFC 2445 defines these two strings, they are\n    not specified for use in the 'period-explicit' format.  The use\n    of these strings represents an extension to the\n    'period-explicit' format.\"\n::= { pmSchedEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedMonth OBJECT-TYPE SYNTAX BITS { january(0), february(1), march(2), april(3), may(4), june(5), july(6), august(7), september(8), october(9), november(10), december(11) }",
      "ja": "pmSchedMonth OBJECT-TYPE構文ビット{1月（0）、2月（1）、3月（2）、4月（3）、5月（4）、6月（5）、7月（6）、8月（7）、9月（8） ）、10月（9）、11月（10）、12月（11）}"
    },
    {
      "indent": 4,
      "text": "MAX-ACCESS  read-create\nSTATUS      current\nDESCRIPTION\n    \"Within the overall time period specified in the\n    pmSchedTimePeriod object, the value of this object specifies\n    the specific months within that time period when the schedule\n    is active.  Setting all bits will cause the schedule to act\n    independently of the month.\"\nDEFVAL { { january, february, march, april, may, june, july,\n           august, september, october, november, december } }\n::= { pmSchedEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedDay OBJECT-TYPE SYNTAX BITS { d1(0), d2(1), d3(2), d4(3), d5(4), d6(5), d7(6), d8(7), d9(8), d10(9), d11(10), d12(11), d13(12), d14(13), d15(14), d16(15), d17(16), d18(17), d19(18), d20(19), d21(20), d22(21), d23(22), d24(23), d25(24), d26(25), d27(26), d28(27), d29(28), d30(29), d31(30), r1(31), r2(32), r3(33), r4(34), r5(35), r6(36), r7(37), r8(38), r9(39), r10(40), r11(41), r12(42), r13(43), r14(44), r15(45), r16(46), r17(47), r18(48), r19(49), r20(50), r21(51), r22(52), r23(53), r24(54), r25(55), r26(56), r27(57), r28(58), r29(59), r30(60), r31(61) } MAX-ACCESS read-create STATUS current DESCRIPTION \"Within the overall time period specified in the pmSchedTimePeriod object, the value of this object specifies the specific days of the month within that time period when the schedule is active.",
      "ja": "pmSchedDay OBJECT-TYPE SYNTAX BITS {d1（0）、d2（1）、d3（2）、d4（3）、d5（4）、d6（5）、d7（6）、d8（7）、d9（8 ）、d10（9）、d11（10）、d12（11）、d13（12）、d14（13）、d15（14）、d16（15）、d17（16）、d18（17）、d19（18 ）、d20（19）、d21（20）、d22（21）、d23（22）、d24（23）、d25（24）、d26（25）、d27（26）、d28（27）、d29（28 ）、d30（29）、d31（30）、r1（31）、r2（32）、r3（33）、r4（34）、r5（35）、r6（36）、r7（37）、r8（38 ）、r9（39）、r10（40）、r11（41）、r12（42）、r13（43）、r14（44）、r15（45）、r16（46）、r17（47）、r18（48 ）、r19（49）、r20（50）、r21（51）、r22（52）、r23（53）、r24（54）、r25（55）、r26（56）、r27（57）、r28（58 ）、r29（59）、r30（60）、r31（61）} MAX-ACCESS読み取り作成STATUS現在の説明「pmSchedTimePeriodオブジェクトで指定された全体の期間内で、このオブジェクトの値は特定の日を指定します スケジュールがアクティブな期間内。"
    },
    {
      "indent": 8,
      "text": "There are two sets of bits one can use to define the day\nwithin a month:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Enumerations starting with the letter 'd' indicate a day in a month relative to the first day of a month. The first day of the month can therefore be specified by setting the bit d1(0), and d31(30) means the last day of a month with 31 days.",
      "ja": "文字「d」で始まる列挙は、月の最初の日を基準にした月の日を示します。 したがって、ビットd1（0）を設定することにより、月の最初の日を指定できます。d31（30）は、31日を含む月の最終日を意味します。"
    },
    {
      "indent": 8,
      "text": "Enumerations starting with the letter 'r' indicate a day in a month in reverse order, relative to the last day of a month. The last day in the month can therefore be specified by setting the bit r1(31), and r31(61) means the first day of a month with 31 days.",
      "ja": "文字 'r'で始まる列挙は、月の最後の日に対して逆順で月の日を示します。 したがって、ビットr1（31）を設定することにより、月の最後の日を指定できます。r31（61）は、31日を含む月の最初の日を意味します。"
    },
    {
      "indent": 4,
      "text": "    Setting multiple bits will include several days in the set\n    of possible days for this schedule.  Setting all bits starting\n    with the letter 'd' or all bits starting with the letter 'r'\n    will cause the schedule to act independently of the day of the\n    month.\"\nDEFVAL { {  d1, d2, d3, d4, d5, d6, d7, d8, d9, d10,\n            d11, d12, d13, d14, d15, d16, d17, d18, d19, d20,\n            d21, d22, d23, d24, d25, d26, d27, d28, d29, d30,\n            d31, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10,\n            r11, r12, r13, r14, r15, r16, r17, r18, r19, r20,\n            r21, r22, r23, r24, r25, r26, r27, r28, r29, r30,\n            r31 } }\n::= { pmSchedEntry 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedWeekDay OBJECT-TYPE\n    SYNTAX      BITS {\n                    sunday(0),\n                    monday(1),\n                    tuesday(2),\n                    wednesday(3),\n                    thursday(4),\n                    friday(5), saturday(6)\n                }\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"Within the overall time period specified in the\n        pmSchedTimePeriod object, the value of this object specifies\n        the specific days of the week within that time period when\n        the schedule is active.  Setting all bits will cause the\n        schedule to act independently of the day of the week.\"\n    DEFVAL { { sunday, monday, tuesday, wednesday, thursday,\n               friday, saturday } }\n    ::= { pmSchedEntry 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedTimeOfDay OBJECT-TYPE SYNTAX PmUTF8String (SIZE (0..15)) MAX-ACCESS read-create STATUS current DESCRIPTION",
      "ja": "pmSchedTimeOfDay OBJECT-TYPE構文PmUTF8String（SIZE（0..15））MAX-ACCESS読み取り作成ステータス現在の説明"
    },
    {
      "indent": 8,
      "text": "\"Within the overall time period specified in the\npmSchedTimePeriod object, the value of this object specifies\nthe range of times in a day when the schedule is active.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "This value is stored in a format based on the RFC 2445 format for 'time': The character 'T' followed by a 'time' string, followed by the solidus character, '/', followed by the character 'T', followed by a second time string. The first time indicates the beginning of the range, and the second time indicates the end. Thus, this value takes the following form:",
      "ja": "この値は、 'time'のRFC 2445形式に基づいた形式で保存されます。文字 'T'の後に 'time'文字列が続き、その後に固相線文字 '/'、文字 'T'、 2回目の文字列ごと。 1回目は範囲の開始を示し、2回目は終了を示します。 したがって、この値は次の形式を取ります。"
    },
    {
      "indent": 12,
      "text": "'Thhmmss/Thhmmss'.",
      "ja": "「Thhmmss / Thhmmss」。"
    },
    {
      "indent": 8,
      "text": "The second substring always identifies a later time than the first substring. To allow for ranges that span midnight, however, the value of the second string may be smaller than the value of the first substring. Thus, 'T080000/T210000' identifies the range from 0800 until 2100, whereas 'T210000/T080000' identifies the range from 2100 until 0800 of the following day.",
      "ja": "2番目の部分文字列は、常に最初の部分文字列よりも遅い時刻を識別します。 ただし、午前0時の範囲を許可するには、2番目の文字列の値が最初の部分文字列の値よりも小さい場合があります。 したがって、「T080000 / T210000」は0800から2100までの範囲を識別し、「T210000 / T080000」は2100から翌日の0800までの範囲を識別します。"
    },
    {
      "indent": 8,
      "text": "When a range spans midnight, by definition it includes parts of two successive days. When one of these days is also selected by either the MonthOfYearMask, DayOfMonthMask, and/or DayOfWeekMask, but the other day is not, then the policy is active only during the portion of the range that falls on the selected day. For example, if the range extends from 2100 until 0800, and the day of week mask selects Monday and Tuesday, then the policy is active during the following three intervals:",
      "ja": "範囲が真夜中にまたがる場合、定義により、連続する2つの日の部分が含まれます。 これらの日のうちの1つがMonthOfYearMask、DayOfMonthMask、および/またはDayOfWeekMaskによっても選択され、他の日が選択されていない場合、ポリシーは選択された日に該当する範囲の部分でのみアクティブになります。 たとえば、範囲が2100から0800までで、曜日マスクが月曜日と火曜日を選択している場合、ポリシーは次の3つの間隔でアクティブになります。"
    },
    {
      "indent": 12,
      "text": "From midnight Sunday until 0800 Monday\nFrom 2100 Monday until 0800 Tuesday\nFrom 2100 Tuesday until 23:59:59 Tuesday",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "     Setting this value to 'T000000/T235959' will cause the\n     schedule to act independently of the time of day.\"\nDEFVAL { '543030303030302F54323335393539'H } -- T000000/T235959\n::= { pmSchedEntry 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedLocalOrUtc OBJECT-TYPE\n    SYNTAX      INTEGER {\n                    localTime(1),\n                    utcTime(2)\n                }\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"This object indicates whether the times represented in the\n        TimePeriod object and in the various Mask objects represent\n        local times or UTC times.\"\n    DEFVAL { utcTime }\n    ::= { pmSchedEntry 9 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedStorageType OBJECT-TYPE SYNTAX StorageType MAX-ACCESS read-create STATUS current DESCRIPTION \"This object defines whether this schedule entry is kept in volatile storage and lost upon reboot or backed up by non-volatile or permanent storage.",
      "ja": "pmSchedStorageType OBJECT-TYPE SYNTAX StorageType MAX-ACCESS読み取り-作成STATUSの現在の説明「このオブジェクトは、このスケジュールエントリが揮発性ストレージに保持され、再起動時に失われるか、不揮発性または永久ストレージによってバックアップされるかを定義します。"
    },
    {
      "indent": 9,
      "text": "Conceptual rows having the value 'permanent' must allow write\naccess to the columnar objects pmSchedDescr, pmSchedWeekDay,\npmSchedMonth, and pmSchedDay.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "     If the value of this object is 'permanent', no values in the\n     associated row have to be writable.\"\nDEFVAL { volatile }\n::= { pmSchedEntry 10 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedRowStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current DESCRIPTION \"The status of this schedule entry.",
      "ja": "pmSchedRowStatus OBJECT-TYPE構文RowStatus MAX-ACCESS読み取り作成ステータス現在の説明「このスケジュールエントリのステータス。"
    },
    {
      "indent": 4,
      "text": "     If the value of this object is active, no object in this row\n     may be modified.\"\n::= { pmSchedEntry 11 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Policy Tracking",
      "ja": "-ポリシーの追跡"
    },
    {
      "indent": 0,
      "text": "-- The \"policy to element\" (PE) table and the \"element to policy\" (EP) -- table track the status of execution contexts grouped by policy and -- element respectively.",
      "ja": "-「ポリシーから要素へ」（PE）テーブルと「要素からポリシーへ」（EP）-テーブルは、ポリシーごとにグループ化された実行コンテキストのステータスを追跡し、-要素。"
    },
    {
      "indent": 0,
      "text": "pmTrackingPETable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF PmTrackingPEEntry\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"The pmTrackingPETable describes what elements\n         are active (under control of) a policy.  This table is indexed\n         in order to optimize retrieval of the entire status for a\n         given policy.\"\n    ::= { pmMib 9 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmTrackingPEEntry OBJECT-TYPE SYNTAX PmTrackingPEEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"An entry in the pmTrackingPETable. The pmPolicyIndex in the index specifies the policy tracked by this entry.",
      "ja": "pmTrackingPEEntry OBJECT-TYPE構文PmTrackingPEEntry MAX-ACCESSアクセス不能ステータス現在の説明「pmTrackingPETableのエントリ。インデックスのpmPolicyIndexはこのエントリによってトラッキングされるポリシーを指定します。"
    },
    {
      "indent": 4,
      "text": "     Note that some combinations of index values may result in an\n     instance name that exceeds a length of 128 sub-identifiers,\n     which exceeds the maximum for the SNMP\n     protocol.  Implementations should take care to avoid such\n     combinations.\"\nINDEX       { pmPolicyIndex, pmTrackingPEElement,\n              pmTrackingPEContextName, pmTrackingPEContextEngineID }\n::= { pmTrackingPETable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PmTrackingPEEntry ::= SEQUENCE {\n    pmTrackingPEElement          RowPointer,\n    pmTrackingPEContextName      SnmpAdminString,\n    pmTrackingPEContextEngineID  OCTET STRING,\n    pmTrackingPEInfo             BITS\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmTrackingPEElement OBJECT-TYPE SYNTAX RowPointer MAX-ACCESS not-accessible STATUS current DESCRIPTION \"The element that is acted upon by the associated policy.",
      "ja": "pmTrackingPEElement OBJECT-TYPE構文RowPointer MAX-ACCESSアクセス不能ステータス現在の説明「関連するポリシーによって機能する要素。"
    },
    {
      "indent": 4,
      "text": "     As this object is used in the index for the\n     pmTrackingPETable, users of this table should be careful not\n     to create entries that would result in instance names with\n     more than 128 sub-identifiers.\"\n::= { pmTrackingPEEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmTrackingPEContextName OBJECT-TYPE\n    SYNTAX      SnmpAdminString (SIZE (0..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"If the associated element is not in the default SNMP context\n        for the target system, this object is used to identify the\n        context.  If the element is in the default context, this object\n        is equal to the empty string.\"\n    ::= { pmTrackingPEEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmTrackingPEContextEngineID OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE (0 | 5..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"If the associated element is on a remote system, this object\n        is used to identify the remote system.  This object contains\n        the contextEngineID of the system on which the associated\n        element resides.  If the element is on the local system,\n        this object will be the empty string.\"\n    ::= { pmTrackingPEEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmTrackingPEInfo OBJECT-TYPE SYNTAX BITS { actionSkippedDueToPrecedence(0), conditionRunTimeException(1), conditionUserSignal(2), actionRunTimeException(3), actionUserSignal(4) } MAX-ACCESS read-only STATUS current DESCRIPTION \"This object returns information about the previous policy script executions.",
      "ja": "pmTrackingPEInfo OBJECT-TYPE SYNTAX BITS {actionSkippedDueToPrecedence（0）、conditionRunTimeException（1）、conditionUserSignal（2）、actionRunTimeException（3）、actionUserSignal（4）} MAX-ACCESS読み取り専用STATUS現在の説明「前のポリシーに関する情報を返します スクリプトの実行。"
    },
    {
      "indent": 9,
      "text": "If the actionSkippedDueToPrecedence(1) bit is set, the last\nexecution of the associated policy condition returned non-zero,\nbut the action is not active, because it was trumped by a\nmatching policy condition in the same precedence group with a\nhigher precedence value.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "If the conditionRunTimeException(2) bit is set, the last execution of the associated policy condition encountered a run-time exception and aborted.",
      "ja": "conditionRunTimeException（2）ビットが設定されている場合、関連するポリシー条件の最後の実行でランタイム例外が発生し、中止されました。"
    },
    {
      "indent": 9,
      "text": "If the conditionUserSignal(3) bit is set, the last execution of the associated policy condition called the signalError() function.",
      "ja": "conditionUserSignal（3）ビットが設定されている場合、関連するポリシー条件の最後の実行はsignalError（）関数を呼び出しました。"
    },
    {
      "indent": 9,
      "text": "If the actionRunTimeException(4) bit is set, the last execution of the associated policy action encountered a run-time exception and aborted.",
      "ja": "actionRunTimeException（4）ビットが設定されている場合、関連するポリシーアクションの最後の実行でランタイム例外が発生し、中止されました。"
    },
    {
      "indent": 9,
      "text": "If the actionUserSignal(5) bit is set, the last execution of the associated policy action called the signalError() function.",
      "ja": "actionUserSignal（5）ビットが設定されている場合、関連するポリシーアクションの最後の実行はsignalError（）関数を呼び出しました。"
    },
    {
      "indent": 4,
      "text": "     Entries will only exist in this table of one or more bits are\n     set.  In particular, if an entry does not exist for a\n     particular policy/element combination, it can be assumed that\n     the policy's condition did not match 'this element'.\"\n::= { pmTrackingPEEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Element to Policy Table",
      "ja": "-要素からポリシーテーブル"
    },
    {
      "indent": 0,
      "text": "pmTrackingEPTable OBJECT-TYPE SYNTAX SEQUENCE OF PmTrackingEPEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"The pmTrackingEPTable describes what policies are controlling an element. This table is indexed in order to optimize retrieval of the status of all policies active for a given element.\"",
      "ja": "pmTrackingEPTable OBJECT-TYPE SYNTAX SEQUENCE OF PmTrackingEPEntry MAX-ACCESSアクセス不可ステータス現在の説明「pmTrackingEPTableは、要素を制御しているポリシーを記述します。このテーブルは、特定の要素に対してアクティブなすべてのポリシーのステータスの取得を最適化するためにインデックス付けされます」"
    },
    {
      "indent": 4,
      "text": "::= { pmMib 10 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmTrackingEPEntry OBJECT-TYPE SYNTAX PmTrackingEPEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"An entry in the pmTrackingEPTable. Entries exist for all element/policy combinations for which the policy's condition matches and only if the schedule for the policy is active.",
      "ja": "pmTrackingEPEntry OBJECT-TYPE構文PmTrackingEPEntry MAX-ACCESSアクセス不可STATUS現在の説明「pmTrackingEPTableのエントリ。ポリシーの条件が一致し、ポリシーのスケジュールがアクティブである場合のみ、エントリはすべての要素/ポリシーの組み合わせに存在します。"
    },
    {
      "indent": 9,
      "text": "The pmPolicyIndex in the index specifies the policy\ntracked by this entry.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "     Note that some combinations of index values may result in an\n     instance name that exceeds a length of 128 sub-identifiers,\n     which exceeds the maximum for the SNMP protocol.\n     Implementations should take care to avoid such combinations.\"\nINDEX       { pmTrackingEPElement, pmTrackingEPContextName,\n              pmTrackingEPContextEngineID, pmPolicyIndex }\n::= { pmTrackingEPTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PmTrackingEPEntry ::= SEQUENCE {\n    pmTrackingEPElement          RowPointer,\n    pmTrackingEPContextName      SnmpAdminString,\n    pmTrackingEPContextEngineID  OCTET STRING,\n    pmTrackingEPStatus           INTEGER\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmTrackingEPElement OBJECT-TYPE SYNTAX RowPointer MAX-ACCESS not-accessible STATUS current DESCRIPTION \"The element acted upon by the associated policy.",
      "ja": "pmTrackingEPElement OBJECT-TYPE構文RowPointer MAX-ACCESSアクセス不可能ステータス現在の説明「要素は関連するポリシーによって機能しました。"
    },
    {
      "indent": 4,
      "text": "     As this object is used in the index for the\n     pmTrackingEPTable, users of this table should be careful\n     not to create entries that would result in instance names\n     with more than 128 sub-identifiers.\"\n::= { pmTrackingEPEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmTrackingEPContextName OBJECT-TYPE\n    SYNTAX      SnmpAdminString (SIZE (0..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"If the associated element is not in the default SNMP context for the target system, this object is used to identify the\n        context.  If the element is in the default context, this object\n        is equal to the empty string.\"\n    ::= { pmTrackingEPEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmTrackingEPContextEngineID OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE (0 | 5..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"If the associated element is on a remote system, this object\n        is used to identify the remote system.  This object contains\n        the contextEngineID of the system on which the associated\n        element resides.  If the element is on the local system,\n        this object will be the empty string.\"\n    ::= { pmTrackingEPEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmTrackingEPStatus OBJECT-TYPE SYNTAX INTEGER { on(1), forceOff(2) } MAX-ACCESS read-write STATUS current DESCRIPTION \"This entry will only exist if the calendar for the policy is active and if the associated policyCondition returned 1 for 'this element'.",
      "ja": "pmTrackingEPStatus OBJECT-TYPE SYNTAX INTEGER {on（1）、forceOff（2）} MAX-ACCESS読み取りと書き込みSTATUS現在の説明 素子'。"
    },
    {
      "indent": 9,
      "text": "A policy can be forcibly disabled on a particular element\nby setting this value to forceOff(2).  The agent should then\nact as though the policyCondition failed for 'this element'.\nThe forceOff(2) state will persist (even across reboots) until\nthis value is set to on(1) by a management request.  The\nforceOff(2) state may be set even if the entry does not\npreviously exist so that future policy invocations can be\navoided.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "     Unless forcibly disabled, if this entry exists, its value\n     will be on(1).\"\n::= { pmTrackingEPEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Policy Debugging Table",
      "ja": "-ポリシーデバッグテーブル"
    },
    {
      "indent": 0,
      "text": "pmDebuggingTable OBJECT-TYPE SYNTAX SEQUENCE OF PmDebuggingEntry MAX-ACCESS not-accessible STATUS current",
      "ja": "pmDebuggingTable OBJECT-TYPE構文シーケンスのPmDebuggingEntry MAX-ACCESSアクセス不能STATUS current"
    },
    {
      "indent": 4,
      "text": "DESCRIPTION\n     \"Policies that have debugging turned on will generate a log\n     entry in the policy debugging table for every runtime\n     exception that occurs in either the condition or action\n     code.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "The pmDebuggingTable logs debugging messages when\npolicies experience run-time exceptions in either the condition\nor action code and the associated pmPolicyDebugging object\nhas been turned on.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "The maximum number of debugging entries that will be stored and the maximum length of time an entry will be kept are an implementation-dependent manner. If entries must be discarded to make room for new entries, the oldest entries must be discarded first.",
      "ja": "格納されるデバッグエントリの最大数とエントリが保持される最大時間は、実装に依存する方法です。 エントリを破棄して新しいエントリ用のスペースを確保する必要がある場合は、最も古いエントリを最初に破棄する必要があります。"
    },
    {
      "indent": 4,
      "text": "     If the system restarts, all debugging entries may be deleted.\"\n::= { pmMib 11 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmDebuggingEntry OBJECT-TYPE SYNTAX PmDebuggingEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"An entry in the pmDebuggingTable. The pmPolicyIndex in the index specifies the policy that encountered the exception that led to this log entry.",
      "ja": "pmDebuggingEntry OBJECT-TYPE構文PmDebuggingEntry MAX-ACCESSアクセス不能STATUS現在の説明「pmDebuggingTableのエントリ。インデックスのpmPolicyIndexは、このログエントリにつながった例外が発生したポリシーを指定します。"
    },
    {
      "indent": 4,
      "text": "     Note that some combinations of index values may result in an\n     instance name that exceeds a length of 128 sub-identifiers,\n     which exceeds the maximum for the SNMP protocol.\n     Implementations should take care to avoid such combinations.\"\nINDEX       { pmPolicyIndex, pmDebuggingElement,\n              pmDebuggingContextName, pmDebuggingContextEngineID,\n              pmDebuggingLogIndex }\n::= { pmDebuggingTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PmDebuggingEntry ::= SEQUENCE {\n    pmDebuggingElement          RowPointer,\n    pmDebuggingContextName      SnmpAdminString,\n    pmDebuggingContextEngineID  OCTET STRING,\n    pmDebuggingLogIndex         Unsigned32,\n    pmDebuggingMessage          PmUTF8String\n} pmDebuggingElement OBJECT-TYPE\n    SYNTAX      RowPointer\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"The element the policy was executing on when it encountered\n         the error that led to this log entry.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "For example, if the element is interface 3, then this object\nwill contain the OID for 'ifIndex.3'.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "     As this object is used in the index for the\n     pmDebuggingTable, users of this table should be careful\n     not to create entries that would result in instance names\n     with more than 128 sub-identifiers.\"\n::= { pmDebuggingEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmDebuggingContextName OBJECT-TYPE\n    SYNTAX      SnmpAdminString (SIZE (0..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"If the associated element is not in the default SNMP context\n        for the target system, this object is used to identify the\n        context.  If the element is in the default context, this object\n        is equal to the empty string.\"\n    ::= { pmDebuggingEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmDebuggingContextEngineID OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE (0 | 5..32))\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"If the associated element is on a remote system, this object\n        is used to identify the remote system.  This object contains\n        the contextEngineID of the system on which the associated\n        element resides.  If the element is on the local system,\n        this object will be the empty string.\"\n    ::= { pmDebuggingEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmDebuggingLogIndex OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n         \"A unique index for this log entry among other log entries\n         for this policy/element combination.\"\n    ::= { pmDebuggingEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmDebuggingMessage OBJECT-TYPE\n    SYNTAX      PmUTF8String (SIZE (0..128))\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n         \"An error message generated by the policy execution\n         environment.  It is recommended that this message include the\n         time of day when the message was generated, if known.\"\n    ::= { pmDebuggingEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Notifications",
      "ja": "-通知"
    },
    {
      "indent": 0,
      "text": "pmNotifications OBJECT IDENTIFIER ::= { pmMib 0 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmNewRoleNotification NOTIFICATION-TYPE OBJECTS { pmRoleStatus } STATUS current DESCRIPTION \"The pmNewRoleNotification is sent when an agent is configured with its first instance of a previously unused role string (not every time a new element is given a particular role).",
      "ja": "pmNewRoleNotification NOTIFICATION-TYPE OBJECTS {pmRoleStatus}ステータスの現在の説明は「エージェントが以前に未使用のロール文字列の最初のインスタンスで設定されるとき送信されます（新しい要素に特定のロールが与えられるたびではない）。"
    },
    {
      "indent": 4,
      "text": "    An instance of the pmRoleStatus object is sent containing\n    the new roleString in its index.  In the event that two or\n    more elements are given the same role simultaneously, it is an\n    implementation-dependent matter as to which pmRoleTable\n    instance will be included in the notification.\"\n::= { pmNotifications 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmNewCapabilityNotification NOTIFICATION-TYPE OBJECTS { pmCapabilitiesType } STATUS current DESCRIPTION \"The pmNewCapabilityNotification is sent when an agent gains a new capability that did not previously exist in any element on the system (not every time an element gains a particular capability).",
      "ja": "pmNewCapabilityNotification NOTIFICATION-TYPE OBJECTS {pmCapabilitiesType}ステータスの現在の説明は「エージェントがシステムのどの要素にも以前に存在しなかった新しい機能を取得すると送信されます（要素が特定の機能を取得するたびにではありません）。"
    },
    {
      "indent": 4,
      "text": "    An instance of the pmCapabilitiesType object is sent containing\n    the identity of the new capability.  In the event that two or\n    more elements gain the same capability simultaneously, it is an\n    implementation-dependent matter as to which pmCapabilitiesType\n    instance will be included in the notification.\"\n::= { pmNotifications 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmAbnormalTermNotification NOTIFICATION-TYPE OBJECTS { pmTrackingPEInfo } STATUS current",
      "ja": "pmAbnormalTermNotification NOTIFICATION-TYPEオブジェクト{pmTrackingPEInfo}ステータス現在"
    },
    {
      "indent": 4,
      "text": "DESCRIPTION\n    \"The pmAbnormalTermNotification is sent when a policy's\n    pmPolicyAbnormalTerminations gauge value changes from zero to\n    any value greater than zero and no such notification has been\n    sent for that policy in the last 5 minutes.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "    The notification contains an instance of the pmTrackingPEInfo\n    object where the pmPolicyIndex component of the index\n    identifies the associated policy and the rest of the index\n    identifies an element on which the policy failed.\"\n::= { pmNotifications 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Compliance Statements",
      "ja": "-コンプライアンスステートメント"
    },
    {
      "indent": 4,
      "text": "pmConformance   OBJECT IDENTIFIER ::= { pmMib 12 }\npmCompliances   OBJECT IDENTIFIER ::= { pmConformance 1 }\npmGroups        OBJECT IDENTIFIER ::= { pmConformance 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmCompliance MODULE-COMPLIANCE\n    STATUS  current\n    DESCRIPTION\n        \"Describes the requirements for conformance to\n        the Policy-Based Management MIB\"\n    MODULE  -- this module\n        MANDATORY-GROUPS { pmPolicyManagementGroup, pmSchedGroup,\n                           pmNotificationGroup }\n    ::= { pmCompliances 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmPolicyManagementGroup OBJECT-GROUP OBJECTS { pmPolicyPrecedenceGroup, pmPolicyPrecedence, pmPolicySchedule, pmPolicyElementTypeFilter, pmPolicyConditionScriptIndex, pmPolicyActionScriptIndex, pmPolicyParameters, pmPolicyConditionMaxLatency, pmPolicyActionMaxLatency, pmPolicyMaxIterations, pmPolicyDescription, pmPolicyMatches, pmPolicyAbnormalTerminations, pmPolicyExecutionErrors, pmPolicyDebugging, pmPolicyStorageType, pmPolicyAdminStatus, pmPolicyRowStatus, pmPolicyCodeText, pmPolicyCodeStatus, pmElementTypeRegMaxLatency, pmElementTypeRegDescription, pmElementTypeRegStorageType, pmElementTypeRegRowStatus, pmRoleStatus, pmCapabilitiesType, pmCapabilitiesOverrideState, pmCapabilitiesOverrideRowStatus, pmTrackingPEInfo, pmTrackingEPStatus, pmDebuggingMessage }",
      "ja": "pmPolicyManagementGroupオブジェクト・グループオブジェクト{pmPolicyPrecedenceGroup、pmPolicyPrecedence、pmPolicySchedule、pmPolicyElementTypeFilter、pmPolicyConditionScriptIndex、pmPolicyActionScriptIndex、pmPolicyParameters、pmPolicyConditionMaxLatency、pmPolicyActionMaxLatency、pmPolicyMaxIterations、pmPolicyDescription、pmPolicyMatches、pmPolicyAbnormalTerminations、pmPolicyExecutionErrors、pmPolicyDebugging、pmPolicyStorageType、pmPolicyAdminStatus、pmPolicyRowStatus、pmPolicyCodeText、pmPolicyCodeStatus、pmElementTypeRegMaxLatency、pmElementTypeRegDescription、 pmElementTypeRegStorageType、pmElementTypeRegRowStatus、pmRoleStatus、pmCapabilitiesType、pmCapabilitiesOverrideState、pmCapabilitiesOverrideRowStatus、pmTrackingPEInfo、pmTrackingEPStatus、pmDebuggingMessage}"
    },
    {
      "indent": 4,
      "text": "STATUS  current\nDESCRIPTION\n    \"Objects that allow for the creation and management of\n    configuration policies.\"\n::=  { pmGroups 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmSchedGroup OBJECT-GROUP\n    OBJECTS { pmSchedLocalTime, pmSchedGroupIndex,\n              pmSchedDescr, pmSchedTimePeriod,\n              pmSchedMonth, pmSchedDay, pmSchedWeekDay,\n              pmSchedTimeOfDay, pmSchedLocalOrUtc, pmSchedStorageType,\n              pmSchedRowStatus\n            }\n    STATUS current\n    DESCRIPTION\n        \"Objects that allow for the scheduling of policies.\"\n    ::= { pmGroups 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmNotificationGroup NOTIFICATION-GROUP\n    NOTIFICATIONS { pmNewRoleNotification,\n                    pmNewCapabilityNotification,\n                    pmAbnormalTermNotification }\n    STATUS        current\n    DESCRIPTION\n        \"Notifications sent by an Policy MIB agent.\"\n    ::= { pmGroups 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "pmBaseFunctionLibrary OBJECT IDENTIFIER ::= { pmGroups 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 0,
      "text": "12. Relationship to Other MIB Modules",
      "section_title": true,
      "ja": "12.他のMIBモジュールとの関係"
    },
    {
      "indent": 3,
      "text": "When policy-based management is used specifically for (policy-based) configuration, the \"Configuring Networks and Devices With SNMP\" RFC 3512 [19] document describes configuration management practices, terminology, and an example of a MIB Module that may be helpful to those developing and using this technology.",
      "ja": "ポリシーベースの管理が（ポリシーベースの）構成に特に使用される場合、「SNMPを使用したネットワークとデバイスの構成」RFC 3512 [19]ドキュメントでは、構成管理の実践、用語、MIBモジュールの例を説明しています。 この技術を開発して使用している人。"
    },
    {
      "indent": 3,
      "text": "The Policy MIB accesses system instrumentation for the purposes of policy evaluation, control, notification, monitoring, and error reporting. This information is available to managers in the form of MIB objects. Information about system configuration is modified by the Policy MIB through MIB objects defined in other MIB Modules.",
      "ja": "ポリシーMIBは、ポリシーの評価、制御、通知、監視、およびエラー報告のためにシステム計装にアクセスします。 この情報は、MIBオブジェクトの形式で管理者が利用できます。 システム構成に関する情報は、他のMIBモジュールで定義されたMIBオブジェクトを介してポリシーMIBによって変更されます。"
    },
    {
      "indent": 3,
      "text": "Details about the operational or configuration details of a system are retrieved by the manager via access to the specific MIB objects available in a network element. As such, the Policy MIB can use any standard or vendor-defined object that exists on a managed system. In particular, the Policy MIB may access standard or vendor specific objects that are instance-specific such as BGP timeout parameters and specific interface counters.",
      "ja": "システムの運用または構成の詳細に関する詳細は、ネットワーク要素で利用可能な特定のMIBオブジェクトへのアクセスを介して、マネージャによって取得されます。 そのため、ポリシーMIBは、管理対象システムに存在する標準またはベンダー定義のオブジェクトを使用できます。 特に、ポリシーMIBは、BGPタイムアウトパラメーターや特定のインターフェイスカウンターなど、インスタンス固有の標準またはベンダー固有のオブジェクトにアクセスできます。"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13.セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This MIB contains no objects for which read access would disclose sensitive information.",
      "ja": "このMIBには、読み取りアクセスによって機密情報が開示されるオブジェクトは含まれていません。"
    },
    {
      "indent": 3,
      "text": "There are a number of management objects defined in this MIB that have a MAX-ACCESS clause of read-write and/or read-create. Such objects may be considered sensitive or vulnerable in some network environments. The support for SET operations in a non-secure environment without proper protection can have a negative effect on network operations.",
      "ja": "このMIBには、読み取り/書き込みおよび/または読み取り/作成のMAX-ACCESS句を持つ多数の管理オブジェクトがあります。 このようなオブジェクトは、一部のネットワーク環境では機密または脆弱であると見なされる場合があります。 適切な保護のない非セキュア環境でのSET操作のサポートは、ネットワーク操作に悪影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "With the exception of pmPolicyDescription, pmPolicyDebugging, pmElementTypeRegDescription, and pmSchedDescr, EVERY read-create and read-write object in this MIB should be considered sensitive because if an unauthorized user could manipulate these objects, s/he could cause the Policy MIB system to use the stored credentials of an authorized user to perform unauthorized and potentially harmful operations.",
      "ja": "pmPolicyDescription、pmPolicyDebugging、pmElementTypeRegDescription、およびpmSchedDescrを除き、権限のないユーザーがこれらのオブジェクトを操作できる場合、ポリシーMIBシステムが使用される可能性があるため、このMIBのすべての読み取り/作成および読み取り/書き込みオブジェクトは機密と見なされる必要があります 許可されていない、潜在的に有害な操作を実行するための、許可されたユーザーの保存された資格情報。"
    },
    {
      "indent": 3,
      "text": "There are no read-only objects in this MIB that contain sensitive information.",
      "ja": "このMIBには、機密情報を含む読み取り専用オブジェクトはありません。"
    },
    {
      "indent": 3,
      "text": "SNMP versions prior to SNMPv3 did not include adequate security. Even if the network itself is secure (for example by using IPSec), even then, there is no control as to who on the secure network is allowed to access and GET/SET (read/change/create/delete) the objects in this MIB module.",
      "ja": "SNMPv3より前のSNMPバージョンには、適切なセキュリティが含まれていませんでした。 ネットワーク自体がセキュリティで保護されている場合（IPSecを使用する場合など）でも、セキュリティで保護されたネットワーク上の誰がこのオブジェクトにアクセスしてGET / SET（読み取り/変更/作成/削除）できるかについては制御できません。 MIBモジュール。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that implementers consider the security features as provided by the SNMPv3 framework (see [16], section 8), including full support for the SNMPv3 cryptographic mechanisms (for authentication and privacy).",
      "ja": "実装者は、SNMPv3暗号化メカニズムの完全なサポート（認証とプライバシー）を含む、SNMPv3フレームワーク（[16]、セクション8を参照）によって提供されるセキュリティ機能を考慮することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Further, deployment of SNMP versions prior to SNMPv3 is NOT RECOMMENDED. Instead, it is RECOMMENDED to deploy SNMPv3 and to enable cryptographic security. It is then a customer/operator responsibility to ensure that the SNMP entity giving access to an instance of this MIB module is properly configured to give access to the objects only to those principals (users) that have legitimate rights to indeed GET or SET (change/create/delete) them.",
      "ja": "さらに、SNMPv3より前のSNMPバージョンの展開は推奨されません。 代わりに、SNMPv3を展開し、暗号化セキュリティを有効にすることをお勧めします。 次に、このMIBモジュールのインスタンスへのアクセスを提供するSNMPエンティティが、実際にGETまたはSET（変更）に対する正当な権利を持つプリンシパル（ユーザー）のみにオブジェクトへのアクセスを許可するように正しく構成されていることを確認するのは、顧客/オペレーターの責任です / create / delete）それら。"
    },
    {
      "indent": 3,
      "text": "An implementation must ensure that access control rules are applied when SNMP operations are performed in policy scripts. To ensure this, an implementation must record and maintain the security credentials of the last entity to modify each policy's pmPolicyAdminStatus object. The credentials to store are the securityModel, securityName, and securityLevel and will be used as input parameters for isAccessAllowed from the Architecture for Describing SNMP Management Frameworks [1]. This mechanism was first introduced in the DISMAN-SCHEDULE-MIB [12].",
      "ja": "実装では、SNMPスクリプト操作がポリシースクリプトで実行されるときにアクセス制御ルールが適用されるようにする必要があります。 これを保証するために、実装は最後のエンティティのセキュリティ資格情報を記録および維持して、各ポリシーのpmPolicyAdminStatusオブジェクトを変更する必要があります。 保存する資格情報はsecurityModel、securityName、およびsecurityLevelであり、SNMP管理フレームワーク[1]を記述するためのアーキテクチャのisAccessAllowedの入力パラメータとして使用されます。 このメカニズムは、DISMAN-SCHEDULE-MIB [12]で初めて導入されました。"
    },
    {
      "indent": 3,
      "text": "SNMP requests made when secModel, secName, and secLevel are specified use credentials stored in the local configuration datastore. Access to these credentials depends on the security credentials of the last entity to modify the policy's pmPolicyAdminStatus object. To determine whether the credentials can be accessed, the isAccessAllowed abstract service interface defined in RFC 3411 [1] is called:",
      "ja": "secModel、secName、およびsecLevelが指定されたときに行われるSNMP要求は、ローカル構成データストアに格納されている資格情報を使用します。 これらの資格情報へのアクセスは、ポリシーのpmPolicyAdminStatusオブジェクトを変更する最後のエンティティのセキュリティ資格情報に依存します。 資格情報にアクセスできるかどうかを判断するには、RFC 3411 [1]で定義されているisAccessAllowed抽象サービスインターフェイスを呼び出します。"
    },
    {
      "indent": 6,
      "text": "statusInformation = -- success or errorIndication isAccessAllowed(",
      "ja": "statusInformation =-successまたはerrorIndication isAccessAllowed（"
    },
    {
      "indent": 8,
      "text": "IN securityModel -- Security Model used IN securityName -- principal who wants to access IN securityLevel -- Level of Security used IN viewType -- write IN contextName -- context containing variableName IN variableName -- OID for an object in the proper -- LCD entry )",
      "ja": "IN securityModel-使用されるセキュリティモデルIN securityName-アクセスしたいプリンシパルIN securityLevel-使用されるセキュリティのレベルIN viewType-書き込みIN contextName-variableNameを含むコンテキストIN variableName-適切なオブジェクトのOID-LCD エントリー）"
    },
    {
      "indent": 6,
      "text": "The securityModel, securityName, and securityLevel parameters are set to the values that were recorded when the policy was modified. The viewType is set to write, and the contextName and variableName are set to select any read-create object in the appropriate LCD entry.",
      "ja": "securityModel、securityName、およびsecurityLevelパラメーターは、ポリシーが変更されたときに記録された値に設定されます。 viewTypeは書き込みに設定され、contextNameとvariableNameは適切なLCDエントリの読み取り作成オブジェクトを選択するように設定されます。"
    },
    {
      "indent": 3,
      "text": "Proper configuration of VACM requires that write access to an LCD entry not be given to entities that aren't authorized to use the credentials therein.",
      "ja": "VACMを適切に構成するには、LCDエントリへの書き込みアクセスが、そのエントリ内の資格情報の使用を許可されていないエンティティに与えられないことが必要です。"
    },
    {
      "indent": 3,
      "text": "Access control for SNMP requests made to the local system where secModel, secName, and secLevel aren't specified depends on the security credentials of the last entity to modify the policy's pmPolicyAdminStatus object. To determine whether the operation should succeed, the isAccessAllowed abstract service interface defined in RFC 3411 [1] is called:",
      "ja": "secModel、secName、およびsecLevelが指定されていないローカルシステムに対して行われたSNMP要求のアクセス制御は、ポリシーのpmPolicyAdminStatusオブジェクトを変更する最後のエンティティのセキュリティ資格情報に依存します。 操作が成功するかどうかを判断するために、RFC 3411 [1]で定義されているisAccessAllowed抽象サービスインターフェイスが呼び出されます。"
    },
    {
      "indent": 6,
      "text": "statusInformation = -- success or errorIndication isAccessAllowed( IN securityModel -- Security Model in use IN securityName -- principal who wants to access IN securityLevel -- Level of Security IN viewType -- read, write, or notify view IN contextName -- context as specified IN variableName -- OID for the managed object )",
      "ja": "statusInformation =-successまたはerrorIndication isAccessAllowed（IN securityModel-使用中のセキュリティモデルIN securityName-INにアクセスするプリンシパルのレベルsecuritylevel-セキュリティのレベルIN viewType-読み取り、書き込み、またはビューIN contextName-コンテキストas 指定されたIN variableName-管理対象オブジェクトのOID）"
    },
    {
      "indent": 6,
      "text": "The securityModel, securityName, and securityLevel parameters are set to the values that were recorded when the policy was modified. The viewType, contextName, and variableName parameters are set as appropriate for the requested SNMP operation.",
      "ja": "securityModel、securityName、およびsecurityLevelパラメーターは、ポリシーが変更されたときに記録された値に設定されます。 viewType、contextName、およびvariableNameパラメーターは、要求されたSNMP操作に応じて設定されます。"
    },
    {
      "indent": 3,
      "text": "Unless all users who have write access to the pmPolicyTable and pmPolicyCodeTable have equivalent access to the managed system, policy scripts could be used by a user to gain the privileges of another user. Therefore, when policy users have different access, access control should be applied so that a user's policies cannot be modified by another user. To make this more convenient, a user can place all of his or her policies in the same pmPolicyAdminGroup so that a single access control view can apply to all of them.",
      "ja": "pmPolicyTableおよびpmPolicyCodeTableへの書き込みアクセス権を持つすべてのユーザーが管理対象システムへの同等のアクセス権を持たない限り、ユーザーはポリシースクリプトを使用して別のユーザーの権限を取得できます。 したがって、ポリシーユーザーのアクセスが異なる場合は、アクセス制御を適用して、ユーザーのポリシーを別のユーザーが変更できないようにする必要があります。 これをより便利にするために、ユーザーはすべてのポリシーを同じpmPolicyAdminGroupに配置して、単一のアクセス制御ビューをすべてのポリシーに適用できます。"
    },
    {
      "indent": 3,
      "text": "Some policies may be designed to ensure the security of a network. If these policies have not been installed pending the appearance of a role or capability, some delay will occur in their activation policies when the role or capability appears because a responsible manager must notice the change and install the policy. This delay may expose the device or the network to unacceptable security vulnerabilities during this delay. If the role or capability appears during a time of network stress or when the management station is unavailable, this delay could be extensive, further increasing the exposure. It is recommended that management stations install any security-related policies that might ever be needed on a particular managed device, even if a nonexistent role or capability suggests that it is not needed at a given time.",
      "ja": "一部のポリシーは、ネットワークのセキュリティを確保するように設計されている場合があります。 これらのポリシーが役割または機能の出現を待ってインストールされていない場合、責任マネージャが変更に気づき、ポリシーをインストールする必要があるため、役割または機能が表示されるときにアクティベーションポリシーに遅延が発生します。 この遅延により、この遅延中にデバイスまたはネットワークが許容できないセキュリティ脆弱性にさらされる可能性があります。 ネットワークに負荷がかかっている間、または管理ステーションが利用できないときに役割または機能が表示される場合、この遅延は広範囲に及ぶ可能性があり、露出がさらに増加します。 存在しない役割または機能が特定の時間に必要でないことを示唆している場合でも、管理ステーションは特定の管理対象デバイスで必要になる可能性のあるセキュリティ関連ポリシーをインストールすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "This MIB allows the delegation of access rights so that a user (\"Joe\") can instruct a Policy MIB agent to execute remote operations on his behalf that are authorized by keys stored by \"Joe\" into the usmUserTable. Care needs to be taken to ensure that unauthorized users are unable to configure their policies to use Joe's keys. Although there are theoretically many ways to configure SNMP security, users are advised to follow the most straightforward way outlined below to minimize complexity and the resulting opportunity for errors.",
      "ja": "このMIBにより、アクセス権の委任が可能になり、ユーザー（ \"Joe\"）がポリシーMIBエージェントに指示して、 \"Joe\"によってusmUserTableに格納されたキーによって許可されるリモート操作を実行できるようになります。 許可されていないユーザーがJoeのキーを使用するようにポリシーを構成できないように注意する必要があります。 SNMPセキュリティを設定する方法は理論的に多くありますが、複雑さとエラーの発生する可能性を最小限に抑えるために、以下に概説する最も簡単な方法に従うことをお勧めします。"
    },
    {
      "indent": 6,
      "text": "Assume that Joe has credentials that give him authority to manage agents A, B, and C, as well as the Policy MIB agent \"P\". Joe will store credentials for Joe@A, Joe@B, and Joe@C in the usmUserTable of the Policy MIB agent. Then the following VACM configuration will be used:",
      "ja": "Joeには、エージェントA、B、C、およびポリシーMIBエージェント「P」を管理する権限を与える資格情報があると仮定します。 Joeは、Joe @ A、Joe @ B、およびJoe @ Cの資格情報をPolicy MIBエージェントのusmUserTableに保存します。 次に、次のVACM構成が使用されます。"
    },
    {
      "indent": 9,
      "text": "VACM securityToGroupTable A single entry mapping user Joe@P to group JoesGroup",
      "ja": "VACM securityToGroupTableユーザーJoe @ PをグループJoesGroupにマッピングする単一のエントリ"
    },
    {
      "indent": 9,
      "text": "VACM accessTable A single entry mapping group JoesGroup to write view JoesView",
      "ja": "VACM accessTableビューJoesViewを書き込む単一エントリマッピンググループJoesGroup"
    },
    {
      "indent": 9,
      "text": "VACM viewTreeFamilyTable ViewName Subtree Type JoesView points to Joe@A in usmUserTable included JoesView points to Joe@B in usmUserTable included JoesView points to Joe@C in usmUserTable included",
      "ja": "VACM viewTreeFamilyTable ViewNameサブツリータイプ"
    },
    {
      "indent": 6,
      "text": "In the preceding examples, the notation Joe@A represents the entry indexed by usmUserEngineID and usmUserName, where the SnmpEngineID is that of system A and the usmUserName is \"Joe\".",
      "ja": "上記の例では、Joe @ Aという表記はusmUserEngineIDとusmUserNameによってインデックスが付けられたエントリを表します。SnmpEngineIDはシステムAのもので、usmUserNameは「Joe」です。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This is a profile of stringprep. It has been registered by the IANA in the stringprep profile registry located at:",
      "ja": "これはstringprepのプロファイルです。 IANAは、次の場所にあるstringprepプロファイルレジストリに登録しました。"
    },
    {
      "indent": 6,
      "text": "http://www.iana.org/assignments/stringprep-profiles",
      "ja": "http://www.iana.org/assignments/stringprep-profiles"
    },
    {
      "indent": 6,
      "text": "Name of this profile: Policy MIB Stringprep.",
      "ja": "このプロファイルの名前：ポリシーMIB Stringprep。"
    },
    {
      "indent": 6,
      "text": "RFC in which the profile is defined: This document.",
      "ja": "プロファイルが定義されているRFC：このドキュメント。"
    },
    {
      "indent": 9,
      "text": "Indicator whether this is the newest version of the profile:",
      "ja": "これがプロファイルの最新バージョンであるかどうかのインジケーター："
    },
    {
      "indent": 12,
      "text": "This is the first version of Policy MIB Stringprep.",
      "ja": "これは、ポリシーMIB Stringprepの最初のバージョンです。"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgements",
      "section_title": true,
      "ja": "15.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors gratefully acknowledge the significant contributions to this work made by Jeff Case, Patrik Falstrom, Joel Halpern, Pablo Halpern, Bob Moore, Steve Moulton, David Partain, and Walter Weiss.",
      "ja": "著者は、Jeff Case、Patrik Falstrom、Joel Halpern、Pablo Halpern、Bob Moore、Steve Moulton、David Partain、およびWalter Weissによるこの作品への多大な貢献に感謝します。"
    },
    {
      "indent": 3,
      "text": "This MIB uses a security delegation mechanism that was first introduced in the DISMAN-SCHEDULE-MIB [12]. The Schedule table of this MIB borrows heavily from the PolicyTimePeriodCondition of the Policy Core Information Model (PCIM) [18] and from the DISMAN-SCHEDULE-MIB [12].",
      "ja": "このMIBは、DISMAN-SCHEDULE-MIB [12]で最初に導入されたセキュリティ委任メカニズムを使用します。 このMIBのスケジュールテーブルは、ポリシーコア情報モデル（PCIM）のPolicyTimePeriodCondition [18]およびDISMAN-SCHEDULE-MIB [12]から大きく借用しています。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16.参照"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "ja": "16.1。 規範的参考文献"
    },
    {
      "indent": 3,
      "text": "[1] Harrington, D., Presuhn, R., and B. Wijnen, \"An Architecture for Describing Simple Network Management Protocol (SNMP) Management Frameworks\", STD 62, RFC 3411, December 2002.",
      "ja": "[1] Harrington、D.、Presuhn、R。、およびB. Wijnen、「簡易ネットワーク管理プロトコル（SNMP）管理フレームワークを記述するためのアーキテクチャ」、STD 62、RFC 3411、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[2] McCloghrie, K., Perkins, D., and J. Schoenwaelder, \"Structure of Management Information Version 2 (SMIv2)\", STD 58, RFC 2578, April 1999.",
      "ja": "[2] McCloghrie、K.、Perkins、D。、およびJ. Schoenwaelder、「管理情報バージョン2（SMIv2）の構造」、STD 58、RFC 2578、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[3] McCloghrie, K., Perkins, D., and J. Schoenwaelder, \"Textual Conventions for SMIv2\", STD 58, RFC 2579, April 1999.",
      "ja": "[3] McCloghrie、K.、Perkins、D。、およびJ. Schoenwaelder、「SMIv2のテキスト表記規則」、STD 58、RFC 2579、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[4] McCloghrie, K., Perkins, D., and J. Schoenwaelder, \"Conformance Statements for SMIv2\", STD 58, RFC 2580, April 1999.",
      "ja": "[4] McCloghrie、K.、Perkins、D。、およびJ. Schoenwaelder、「SMIv2の適合宣言」、STD 58、RFC 2580、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[5] Presuhn, R., \"Transport Mappings for the Simple Network Management Protocol (SNMP)\", STD 62, RFC 3417, December 2002.",
      "ja": "[5] Presuhn、R。、「簡易ネットワーク管理プロトコル（SNMP）のトランスポートマッピング」、STD 62、RFC 3417、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[6] Blumenthal, U. and B. Wijnen, \"User-based Security Model (USM) for version 3 of the Simple Network Management Protocol (SNMPv3)\", STD 62, RFC 3414, December 2002.",
      "ja": "[6] Blumenthal、U。およびB. Wijnen、「Simple Network Management Protocol（SNMPv3）バージョン3のユーザーベースセキュリティモデル（USM）」、STD 62、RFC 3414、2002年12月"
    },
    {
      "indent": 3,
      "text": "[7] Presuhn, R., \"Version 2 of the Protocol Operations for the Simple Network Management Protocol (SNMP)\", STD 62, RFC 3416, December 2002.",
      "ja": "[7] Presuhn、R。、「簡易ネットワーク管理プロトコル（SNMP）のプロトコル操作のバージョン2」、STD 62、RFC 3416、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[8] Frye, R., Levi, D., Routhier, S., and B. Wijnen, \"Coexistence between Version 1, Version 2, and Version 3 of the Internet-standard Network Management Framework\", BCP 74, RFC 3584, August 2003.",
      "ja": "[8] Frye、R.、Levi、D.、Routhier、S。、およびB. Wijnen、「インターネット標準ネットワーク管理フレームワークのバージョン1、バージョン2、およびバージョン3の共存」、BCP 74、RFC 3584 、2003年8月。"
    },
    {
      "indent": 3,
      "text": "[9] Wijnen, B., Presuhn, R., and K. McCloghrie, \"View-based Access Control Model (VACM) for the Simple Network Management Protocol (SNMP)\", STD 62, RFC 3415, December 2002.",
      "ja": "[9] Wijnen、B.、Presuhn、R。、およびK. McCloghrie、「簡易ネットワーク管理プロトコル（SNMP）のビューベースのアクセス制御モデル（VACM）」、STD 62、RFC 3415、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[10] International Standards Organization, \"Information Technology - Programming Languages - C++\", ISO/IEC 14882-1998",
      "ja": "[10]国際標準化機構、「情報技術-プログラミング言語-C ++」、ISO / IEC 14882-1998"
    },
    {
      "indent": 3,
      "text": "[11] Daniele, M. and J. Schoenwaelder, \"Textual Conventions for Transport Addresses\", RFC 3419, December 2002.",
      "ja": "[11] Daniele、M。、およびJ. Schoenwaelder、「トランスポートアドレスのテキスト表記」、RFC 3419、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[12] Levi, D. and J. Schoenwaelder, \"Definitions of Managed Objects for Scheduling Management Operations\", RFC 3231, January 2002.",
      "ja": "[12] Levi、D。、およびJ. Schoenwaelder、「管理操作のスケジューリングのための管理対象オブジェクトの定義」、RFC 3231、2002年1月。"
    },
    {
      "indent": 3,
      "text": "[13] Hoffman, P. and M. Blanchet, \"Preparation of Internationalized Strings (\"stringprep\")\", RFC 3454, December 2002.",
      "ja": "[13] Hoffman、P。およびM. Blanchet、「国際化文字列の準備（ \"stringprep\"）」、RFC 3454、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[14] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[14] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[15] Dawson, F. and D. Stenerson, \"Internet Calendaring and Scheduling Core Object Specification (iCalendar)\", RFC 2445, November 1998.",
      "ja": "[15] Dawson、F。、およびD. Stenerson、「Internet Calendaring and Scheduling Core Object Specification（iCalendar）」、RFC 2445、1998年11月。"
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "ja": "16.2。 参考資料"
    },
    {
      "indent": 3,
      "text": "[16] Case, J., Mundy, R., Partain, D., and B. Stewart, \"Introduction and Applicability Statements for Internet-Standard Management Framework\", RFC 3410, December 2002.",
      "ja": "[16]ケース、J。、マンディ、R。、パーテイン、D。、およびB.スチュワート、「インターネット標準管理フレームワークの導入と適用ステートメント」、RFC 3410、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[17] ECMA, \"ECMAScript Language Specification\", ECMA-262, December 1999",
      "ja": "[17] ECMA、「ECMAScript言語仕様」、ECMA-262、1999年12月"
    },
    {
      "indent": 3,
      "text": "[18] Moore, B., Ellesson, E., Strassner, J., and A. Westerinen, \"Policy Core Information Model -- Version 1 Specification\", RFC 3060, February 2001.",
      "ja": "[18] Moore、B.、Ellesson、E.、Strassner、J。、およびA. Westerinen、「ポリシーコア情報モデル-バージョン1仕様」、RFC 3060、2001年2月。"
    },
    {
      "indent": 3,
      "text": "[19] MacFaden, M., Partain, D., Saperia, J., and W. Tackabury, \"Configuring Networks and Devices with Simple Network Management Protocol (SNMP)\", RFC 3512, April 2003.",
      "ja": "[19] MacFaden、M.、Partain、D.、Saperia、J。、およびW. Tackabury、「簡易ネットワーク管理プロトコル（SNMP）によるネットワークおよびデバイスの構成」、RFC 3512、2003年4月。"
    },
    {
      "indent": 0,
      "text": "Author's Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Steve Waldbusser",
      "ja": "スティーブ・ウォルドバッサー"
    },
    {
      "indent": 3,
      "text": "Phone: +1-650-948-6500 Fax: +1-650-745-0671 EMail: waldbusser@nextbeacon.com",
      "ja": "電話：+ 1-650-948-6500ファックス：+ 1-650-745-0671電子メール：waldbusser@nextbeacon.com"
    },
    {
      "indent": 3,
      "text": "Jon Saperia (WG Co-chair) JDS Consulting, Inc. 84 Kettell Plain Road. Stow MA 01775 USA",
      "ja": "Jon Saperia（WG共同議長）JDS Consulting、Inc. 84 Kettell Plain Road。 ストウMA 01775アメリカ"
    },
    {
      "indent": 3,
      "text": "Phone: +1-978-461--0249 Fax: +1-617-249-0874 EMail: saperia@jdscons.com",
      "ja": "電話：+ 1-978-461--0249ファックス：+ 1-617-249-0874電子メール：saperia@jdscons.com"
    },
    {
      "indent": 3,
      "text": "Thippanna Hongal Riverstone Networks, Inc. 5200 Great America Parkway Santa Clara, CA, 95054 USA",
      "ja": "Thippanna Hongal Riverstone Networks、Inc. 5200 Great America Parkway Santa Clara、CA、95054 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-408-878-6562 Fax: +1-408-878-6501 EMail: hongal@riverstonenet.com",
      "ja": "電話：+ 1-408-878-6562ファックス：+ 1-408-878-6501電子メール：hongal@riverstonenet.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、制限の対象となります。また、そこに記載されている場合を除き、著者はすべての権利を保持します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "本書および本書に含まれる情報は「現状のまま」提供され、寄稿者、代表者または代表者（もしあれば）、インターネット協会、インターネットエンジニアリングタスクフォースはすべての保証を放棄します 黙示的であるが、ここに記載されている情報の使用が商品性または特定の目的への適合性の黙示的保証を侵害しないという保証に限定されない。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書に記載されている技術の実装または使用に関連すると主張される可能性のある知的財産権またはその他の権利の有効性または範囲、またはそのような権利の下でのライセンスの有無に関して、立場をとりません。 利用可能 また、そのような権利を特定するための独立した努力を行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーおよび利用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによる一般的なライセンスまたはそのような所有権の使用許可の取得を試みた結果を取得できます。 IETFオンラインIPRリポジトリ（http://www.ietf.org/ipr）から。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、この標準を実装するために必要な技術を対象とする著作権、特許、特許出願、またはその他の所有権に関心を寄せるよう、あらゆる利害関係者を招待します。 IETFのietf-ipr@ietf.orgに情報を送信してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能の資金は、現在インターネット協会によって提供されています。"
    }
  ]
}