{
  "title": {
    "text": "RFC 4757 - The RC4-HMAC Kerberos Encryption Types Used by Microsoft Windows",
    "ja": "RFC 4757 - マイクロソフトWindowsで使用RC4-HMAC Kerberos暗号化タイプ"
  },
  "number": 4757,
  "created_at": "2019-10-26 01:27:36.771823+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                      K. Jaganathan\nRequest for Comments: 4757                                        L. Zhu\nCategory: Informational                                        J. Brezak\n                                                   Microsoft Corporation\n                                                           December 2006",
      "raw": true
    },
    {
      "indent": 4,
      "text": "The RC4-HMAC Kerberos Encryption Types Used by Microsoft Windows",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2006).",
      "ja": "著作権（C）IETFトラスト（2006）。"
    },
    {
      "indent": 0,
      "text": "IESG Note",
      "ja": "IESG注意"
    },
    {
      "indent": 3,
      "text": "This document documents the RC4 Kerberos encryption types first introduced in Microsoft Windows 2000. Since then, these encryption types have been implemented in a number of Kerberos implementations. The IETF Kerberos community supports publishing this specification as an informational document in order to describe this widely implemented technology. However, while these encryption types provide the operations necessary to implement the base Kerberos specification [RFC4120], they do not provide all the required operations in the Kerberos cryptography framework [RFC3961]. As a result, it is not generally possible to implement potential extensions to Kerberos using these encryption types. The Kerberos encryption type negotiation mechanism [RFC4537] provides one approach for using such extensions even when a Kerberos infrastructure uses long-term RC4 keys. Because this specification does not implement operations required by RFC 3961 and because of security concerns with the use of RC4 and MD4 discussed in Section 8, this specification is not appropriate for publication on the standards track.",
      "ja": "この文書では、最初にそれ以来のMicrosoft Windows 2000で導入されたRC4のKerberos暗号化タイプを文書化し、これらの暗号化タイプは、Kerberos実装で実装されています。 IETFケルベロスコミュニティは、この広く実装技術を説明するために情報の文書としてこの仕様を公開しサポートしています。これらの暗号化タイプがベースのKerberos仕様[RFC4120]を実装するために必要な操作を提供しながら、しかし、彼らは、Kerberos暗号化フレームワーク[RFC3961]内のすべての必要な操作を提供していません。その結果、これらの暗号化タイプを使用してケルベロスへの潜在的な拡張を実装することは一般に不可能です。ケルベロス暗号化タイプのネゴシエーションメカニズム[RFC4537]はケルベロスインフラ長期RC4キーを使用した場合であっても、このような拡張機能を使用するための1つのアプローチを提供します。この仕様はRFC 3961でと理由はセクション8で議論RC4とMD4を用いたセキュリティ上の懸念の必要な操作を実装していないので、この仕様は標準化トラックの出版には適していません。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Microsoft Windows 2000 implementation of Kerberos introduces a new encryption type based on the RC4 encryption algorithm and using an MD5 HMAC for checksum. This is offered as an alternative to using the existing DES-based encryption types.",
      "ja": "ケルベロスのマイクロソフトWindows 2000の実装では、RC4暗号化アルゴリズムに基づいて、新たな暗号化の種類を紹介し、チェックサムのためのMD5 HMACを使用しました。これは、既存のDESベースの暗号化の種類を使用する代わりとして提供されます。"
    },
    {
      "indent": 3,
      "text": "The RC4-HMAC encryption types are used to ease upgrade of existing Windows NT environments, provide strong cryptography (128-bit key lengths), and provide exportable (meet United States government export restriction requirements) encryption. This document describes the implementation of those encryption types.",
      "ja": "RC4-HMAC暗号化タイプは、暗号化（米国政府の輸出規制の要件を満たす）、既存のWindows NT環境のアップグレードを容易に強力な暗号化（128ビットの鍵長）を提供し、エクスポートを提供するために使用されています。この文書では、これらの暗号化タイプの実装について説明します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Conventions Used in This Document ..........................3\n2. Key Generation ..................................................3\n3. Basic Operations ................................................4\n4. Checksum Types ..................................................5\n5. Encryption Types ................................................6\n6. Key Strength Negotiation ........................................8\n7. GSS-API Kerberos V5 Mechanism Type ..............................8\n   7.1. Mechanism Specific Changes .................................8\n   7.2. GSS-API MIC Semantics ......................................9\n   7.3. GSS-API WRAP Semantics ....................................11\n8. Security Considerations ........................................15\n9. IANA Considerations ............................................15\n10. Acknowledgements ..............................................15\n11. References ....................................................16\n   11.1. Normative References .....................................16\n   11.2. Informative References ...................................16",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Microsoft Windows 2000 implementation of Kerberos contains new encryption and checksum types for two reasons. First, for export reasons early in the development process, 56-bit DES encryption could not be exported, and, second, upon upgrade from Windows NT 4.0 to Windows 2000, accounts will not have the appropriate DES keying material to do the standard DES encryption. Furthermore, 3DES was not available for export when Windows 2000 was released, and there was a desire to use a single flavor of encryption in the product for both US and international products.",
      "ja": "ケルベロスのマイクロソフトWindows 2000の実装では、2つの理由のための新しい暗号化とチェックサムタイプが含まれています。まず、開発プロセスの初期段階における輸出の理由から、56ビットDES暗号化はエクスポートできませんでした、そして、第二、Windows NT 4.0からWindows 2000へのアップグレード時に、アカウントが標準のDES暗号化を行うために、適切なDESの鍵素材を持っていません。 。さらに、Windows 2000のがリリースされたとき、3DESはエクスポートできませんでした、米国と国際製品の両方の製品で暗号化の単一のフレーバーを使用することが望まれていました。"
    },
    {
      "indent": 3,
      "text": "As a result, there are two new encryption types and one new checksum type introduced in Microsoft Windows 2000.",
      "ja": "その結果、二つの新しい暗号化タイプとMicrosoft Windows 2000で導入された1つの新しいチェックサムタイプがあります。"
    },
    {
      "indent": 3,
      "text": "Note that these cryptosystems aren't intended to be complete, general-purpose Kerberos encryption or checksum systems as defined in [RFC3961]: there is no one-one mapping between the operations in this documents and the primitives described in [RFC3961].",
      "ja": "[RFC3961]で定義されるように、これらの暗号システムは、完全な汎用ケルベロス暗号化又はチェックサム・システムであることを意図するものではないことに注意：この文書の動作と[RFC3961]に記載のプリミティブとの間には一対一のマッピングが存在しません。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1。このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"OPTIONAL\" は解釈されるべきです[RFC2119]に記載されているように。"
    },
    {
      "indent": 0,
      "text": "2. Key Generation",
      "section_title": true,
      "ja": "2.キー生成"
    },
    {
      "indent": 3,
      "text": "On upgrade from existing Windows NT domains, the user accounts would not have a DES-based key available to enable the use of DES base encryption types specified in [RFC4120] and [RFC3961]. The key used for RC4-HMAC is the same as the existing Windows NT key (NT Password Hash) for compatibility reasons. Once the account password is changed, the DES-based keys are created and maintained. Once the DES keys are available, DES-based encryption types can be used with Kerberos.",
      "ja": "既存のWindows NTドメインからのアップグレードでは、ユーザーアカウントは、[RFC4120]と[RFC3961]で指定されたDESベースの暗号化タイプの使用を可能にするために利用できるDESベースのキーを持っていないでしょう。 RC4-HMACのために使用されるキーは、互換性の理由のため、既存のWindows NTキー（NTパスワードハッシュ）と同じです。アカウントのパスワードが変更されると、DESベースのキーが作成され、維持されています。 DESキーが用意されていたら、DESベースの暗号化タイプがケルベロスで使用することができます。"
    },
    {
      "indent": 3,
      "text": "The RC4-HMAC string to key function is defined as follows:",
      "ja": "次のようにキーの機能へのRC4-HMACの文字列が定義されています。"
    },
    {
      "indent": 6,
      "text": "String2Key(password)",
      "ja": "String2Key（パスワード）"
    },
    {
      "indent": 11,
      "text": "K = MD4(UNICODE(password))",
      "ja": "K = MD4（UNICODE（パスワード））"
    },
    {
      "indent": 3,
      "text": "The RC4-HMAC keys are generated by using the Windows UNICODE version of the password. Each Windows UNICODE character is encoded in little-endian format of 2 octets each. Then an MD4 [RFC1320] hash operation is performed on just the UNICODE characters of the password (not including the terminating zero octets).",
      "ja": "RC4-HMACキーは、パスワードのWindowsのUnicodeバージョンを使用して生成されます。各WindowsのUnicode文字は2つのオクテット、それぞれのリトルエンディアン形式でエンコードされます。次いで、MD4 [RFC1320]ハッシュ演算は（終端ゼロオクテットを含まない）パスワードのちょうどUnicode文字に対して実行されます。"
    },
    {
      "indent": 3,
      "text": "For an account with a password of \"foo\", this String2Key(\"foo\") will return:",
      "ja": "「foo」というのパスワードとアカウントの場合、このString2Key（「fooが」）を返します："
    },
    {
      "indent": 11,
      "text": "0xac, 0x8e, 0x65, 0x7f, 0x83, 0xdf, 0x82, 0xbe,\n0xea, 0x5d, 0x43, 0xbd, 0xaf, 0x78, 0x00, 0xcc",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3. Basic Operations",
      "section_title": true,
      "ja": "3.基本操作"
    },
    {
      "indent": 3,
      "text": "The MD5 HMAC function is defined in [RFC2104]. It is used in this encryption type for checksum operations. Refer to [RFC2104] for details on its operation. In this document, this function is referred to as HMAC(Key, Data) returning the checksum using the specified key on the data.",
      "ja": "MD5 HMAC関数は、[RFC2104]で定義されています。これは、チェックサム操作のために、この暗号化タイプで使用されています。その動作の詳細については、[RFC2104]を参照してください。この文書では、この機能は、データ上の指定されたキーを使用してチェックサムを返すHMAC（キー、データ）と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "The basic MD5 hash operation is used in this encryption type and defined in [RFC1321]. In this document, this function is referred to as MD5(Data) returning the checksum of the data.",
      "ja": "基本的なMD5ハッシュ操作は、この暗号化タイプで使用され、[RFC1321]で定義されています。この文書では、この関数がMD5（データ）は、データのチェックサムを返すと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "RC4 is a stream cipher licensed by RSA Data Security. In this document, the function is referred to as RC4(Key, Data) returning the encrypted data using the specified key on the data.",
      "ja": "RC4は、RSA Data Securityによってライセンスストリーム暗号です。この文書では、関数は、データ上の指定されたキーを用いて暗号化したデータを返すRC4（キー、データ）と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "These encryption types use key derivation. With each message, the message type (T) is used as a component of the keying material. The following table summarizes the different key derivation values used in the various operations. Note that these differ from the key derivations used in other Kerberos encryption types. T = the message type, encoded as a little-endian four-byte integer.",
      "ja": "これらの暗号化タイプは、キー派生を使用しています。各メッセージで、メッセージタイプ（T）は、キーイング材料の成分として使用されます。次の表は、様々な操作に使用される異なる鍵導出値をまとめたものです。これらは、他のKerberos暗号化タイプで使用されるキー派生異なることに注意してください。 Tは、リトルエンディアンの4バイトの整数として符号化されたメッセージタイプを=。"
    },
    {
      "indent": 6,
      "text": "1. AS-REQ PA-ENC-TIMESTAMP padata timestamp, encrypted with the client key (T=1) 2. AS-REP Ticket and TGS-REP Ticket (includes TGS session key or application session key), encrypted with the service key (T=2) 3. AS-REP encrypted part (includes TGS session key or application session key), encrypted with the client key (T=8) 4. TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with the TGS session key (T=4) 5. TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with the TGS authenticator subkey (T=5) 6. TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator cksum, keyed with the TGS session key (T=6) 7. TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator (includes TGS authenticator subkey), encrypted with the TGS session key T=7) 8. TGS-REP encrypted part (includes application session key), encrypted with the TGS session key (T=8) 9. TGS-REP encrypted part (includes application session key), encrypted with the TGS authenticator subkey (T=8)",
      "ja": "1. AS-REQ PA-ENC-TIMESTAMPのPADATAタイムスタンプ、クライアントキー（T = 1）で暗号化された2 AS-REPチケットとサービスキーで暗号化TGS-REPチケット（TGSセッションキーまたはアプリケーションセッションキーを含みます）、 （T = 2）3. AS-REPは、一部をTGSセッションで暗号化されたクライアントキー（T = 8）4 TGS-REQ KDC-REQ-BODY AuthorizationDataで暗号化、（TGSセッションキーまたはアプリケーションセッション鍵を含む）暗号化キー（T = 4）5 TGS​​-REQ KDC-REQ-BODY AuthorizationData、TGSとキーイングTGS認証サブキー（T = 5）6 TGS-REQ PA-TGS-REQのPADATA AP-REQ認証プログラムcksumので暗号化セッション鍵（T = 6）T = 7）8. TGS-REPは一部を暗号化されたTGSセッションキーで暗号化7 TGS-REQ PA-TGS-REQのPADATA AP-REQの認証は、（TGS認証サブキーを含む）、（アプリケーションセッションを含みますTGSセッションキー（T = 8）9. TGS-REPはTGS認証サブキー（T = 8）で暗号化、（アプリケーションセッションキーを含む）の部分を暗号化して暗号化された）キー"
    },
    {
      "indent": 6,
      "text": "10. AP-REQ Authenticator cksum, keyed with the application session key (T=10) 11. AP-REQ Authenticator (includes application authenticator subkey), encrypted with the application session key (T=11) 12. AP-REP encrypted part (includes application session subkey), encrypted with the application session key (T=12) 13. KRB-PRIV encrypted part, encrypted with a key chosen by the application. Also for data encrypted with GSS Wrap (T=13) 14. KRB-CRED encrypted part, encrypted with a key chosen by the application (T=14) 15. KRB-SAFE cksum, keyed with a key chosen by the application. Also for data signed in GSS MIC (T=15)",
      "ja": "アプリケーション・セッション・キー（T = 10）アプリケーション・セッション・キー（T = 11）12 AP-REPの一部を暗号化して暗号化された11 AP-REQのオーセンティケータ（アプリ認証サブキーを含む）、とキー止め10 AP-REQ認証プログラムcksumの、 （アプリケーションセッションサブキーを含む）、アプリケーション・セッション・キーで暗号化された（T = 12）13 KRB-PRIVは、アプリケーションによって選択されたキーで暗号化され、一部が暗号化されました。また、GSSラップ（T = 13）14 KRB-CREDで暗号化されたデータのためにアプリケーションによって選択されたキーとキー入力アプリケーション（T = 14）15 KRB-SAFE cksumの、によって選択されたキーで暗号化され、一部が暗号化されました。また、GSS MIC（T = 15）で署名されたデータのための"
    },
    {
      "indent": 6,
      "text": "Relative to RFC-1964 key uses:",
      "ja": "RFC-1964キーの用途への相対："
    },
    {
      "indent": 6,
      "text": "T = 0 in the generation of sequence number for the MIC token T = 0 in the generation of sequence number for the WRAP token T = 0 in the generation of encrypted data for the WRAPPED token",
      "ja": "T = 0 WRAPPEDトークンの暗号化データの生成にWRAPトークンT = 0のシーケンス番号の生成におけるMICトークンT = 0のシーケンス番号の生成に"
    },
    {
      "indent": 3,
      "text": "All strings in this document are ASCII unless otherwise specified. The lengths of ASCII-encoded character strings include the trailing terminator character (0). The concat(a,b,c,...) function will return the logical concatenation (left to right) of the values of the arguments. The nonce(n) function returns a pseudo-random number of \"n\" octets.",
      "ja": "特に指定しない限り、このドキュメント内のすべての文字列はASCIIです。 ASCII符号化された文字列の長さは、後続の終端文字（0）が含まれます。 CONCAT（A、B、C、...）関数は、引数の値の（左から右へ）論理的に連結したものを返します。ノンス（n）の関数は、「n」はオクテットの擬似乱数を返します。"
    },
    {
      "indent": 0,
      "text": "4. Checksum Types",
      "section_title": true,
      "ja": "4.チェックサムタイプ"
    },
    {
      "indent": 3,
      "text": "There is one checksum type used in this encryption type. The Kerberos constant for this type is:",
      "ja": "この暗号化タイプで使用されるもののチェックサムのタイプがあります。このタイプのKerberos定数は次のようになります。"
    },
    {
      "indent": 11,
      "text": "#define KERB_CHECKSUM_HMAC_MD5 (-138)",
      "ja": "#define KERB_CHECKSUM_HMAC_MD5（-138）"
    },
    {
      "indent": 6,
      "text": "The function is defined as follows:",
      "ja": "この関数は次のように定義されています。"
    },
    {
      "indent": 6,
      "text": "K = the Key T = the message type, encoded as a little-endian four-byte integer",
      "ja": "Kは、=キーTは、リトルエンディアンの4バイトの整数として符号化されたメッセージタイプ="
    },
    {
      "indent": 6,
      "text": "CHKSUM(K, T, data)",
      "ja": "チェックサム（KT、データ）"
    },
    {
      "indent": 11,
      "text": "Ksign = HMAC(K, \"signaturekey\")  //includes zero octet at end\ntmp = MD5(concat(T, data))\nCHKSUM = HMAC(Ksign, tmp)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. Encryption Types",
      "section_title": true,
      "ja": "5.暗号化タイプ"
    },
    {
      "indent": 3,
      "text": "There are two encryption types used in these encryption types. The Kerberos constants for these types are:",
      "ja": "これらの暗号化タイプで使用される2つの暗号化タイプがあります。これらのタイプのためのKerberosの定数は、次のとおりです。"
    },
    {
      "indent": 11,
      "text": "#define KERB_ETYPE_RC4_HMAC             23\n#define KERB_ETYPE_RC4_HMAC_EXP         24",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The basic encryption function is defined as follows:",
      "ja": "次のように基本的な暗号化機能が定義されています。"
    },
    {
      "indent": 5,
      "text": "T = the message type, encoded as a little-endian four-byte integer.",
      "ja": "Tは、リトルエンディアンの4バイトの整数として符号化されたメッセージタイプを=。"
    },
    {
      "indent": 11,
      "text": "OCTET L40[14] = \"fortybits\";",
      "ja": "OCTET L40 [14] = \"fortybits\"。"
    },
    {
      "indent": 6,
      "text": "The header field on the encrypted data in KDC messages is:",
      "ja": "KDCメッセージに暗号化されたデータのヘッダフィールドは次のとおりです。"
    },
    {
      "indent": 11,
      "text": "typedef struct _RC4_MDx_HEADER {\n    OCTET Checksum[16];\n    OCTET Confounder[8];\n} RC4_MDx_HEADER, *PRC4_MDx_HEADER;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "ENCRYPT (K, export, T, data)\n{\n    struct EDATA {\n        struct HEADER {\n                OCTET Checksum[16];\n                OCTET Confounder[8];\n        } Header;\n        OCTET Data[0];\n    } edata;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "if (export){\n    *((DWORD *)(L40+10)) = T;\n    K1 = HMAC(K, L40); // where the length of L40 in\n                       // octets is 14\n}\nelse\n{\n    K1 = HMAC(K, &T); // where the length of T in octets\n                      // is 4\n}\nmemcpy (K2, K1, 16);\nif (export) memset (K1+7, 0xAB, 9);",
      "raw": true
    },
    {
      "indent": 15,
      "text": "nonce (edata.Confounder, 8);\nmemcpy (edata.Data, data);",
      "raw": true
    },
    {
      "indent": 15,
      "text": "edata.Checksum = HMAC (K2, edata);\nK3 = HMAC (K1, edata.Checksum);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    RC4 (K3, edata.Confounder);\n    RC4 (K3, data.Data);\n}",
      "raw": true
    },
    {
      "indent": 11,
      "text": "DECRYPT (K, export, T, edata)\n{\n    // edata looks like\n    struct EDATA {\n        struct HEADER {\n                OCTET Checksum[16];\n                OCTET Confounder[8];\n        } Header;\n        OCTET Data[0];\n    } edata;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "if (export){\n    *((DWORD *)(L40+10)) = T;\n    HMAC (K, L40, 14, K1);\n}\nelse\n{\n    HMAC (K, &T, 4, K1);\n}\nmemcpy (K2, K1, 16);\nif (export) memset (K1+7, 0xAB, 9);",
      "raw": true
    },
    {
      "indent": 15,
      "text": "K3 = HMAC (K1, edata.Checksum);\nRC4 (K3, edata.Confounder);\nRC4 (K3, edata.Data);",
      "raw": true
    },
    {
      "indent": 11,
      "text": "    // verify generated and received checksums\n  checksum = HMAC (K2, concat(edata.Confounder, edata.Data));\n    if (checksum != edata.Checksum)\n        printf(\"CHECKSUM ERROR  !!!!!!\\n\");\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The KDC message is encrypted using the ENCRYPT function not including the Checksum in the RC4_MDx_HEADER.",
      "ja": "KDCメッセージはRC4_MDx_HEADERでチェックサムを含まないENCRYPT関数を使用して暗号化されます。"
    },
    {
      "indent": 3,
      "text": "The character constant \"fortybits\" evolved from the time when a 40-bit key length was all that was exportable from the United States. It is now used to recognize that the key length is of \"exportable\" length. In this description, the key size is actually 56 bits.",
      "ja": "文字定数「fortybitsは、」40ビットの鍵長が米国からエクスポートしたものすべてだった時から進化しました。現在では、キーの長さは、「エクスポート」の長さであることを認識するために使用されます。この説明では、キーのサイズは実際に56ビットです。"
    },
    {
      "indent": 3,
      "text": "The pseudo-random operation [RFC3961] for both enctypes above is defined as follows:",
      "ja": "以下のように定義される両方enctypes用擬似乱数操作[RFC3961]："
    },
    {
      "indent": 11,
      "text": "pseudo-random(K, S) = HMAC-SHA1(K, S)",
      "ja": "擬似ランダム（K、S）= HMAC-SHA1（K、S）"
    },
    {
      "indent": 3,
      "text": "where K is the protocol key and S is the input octet string. HMAC-SHA1 is defined in [RFC2104] and the output of HMAC-SHA1 is the 20-octet digest.",
      "ja": "Kは、プロトコルキーであり、Sは、入力されたオクテットストリングです。 HMAC-SHA1は、[RFC2104]で定義され、HMAC-SHA1の出力は、20オクテットのダイジェストです。"
    },
    {
      "indent": 0,
      "text": "6. Key Strength Negotiation",
      "section_title": true,
      "ja": "6.強み交渉"
    },
    {
      "indent": 3,
      "text": "A Kerberos client and server can negotiate over key length if they are using mutual authentication. If the client is unable to perform full-strength encryption, it may propose a key in the \"subkey\" field of the authenticator, using a weaker encryption type. The server must then either return the same key or suggest its own key in the subkey field of the AP reply message. The key used to encrypt data is derived from the key returned by the server. If the client is able to perform strong encryption but the server is not, it may propose a subkey in the AP reply without first being sent a subkey in the authenticator.",
      "ja": "彼らは、相互認証を使用している場合は、Kerberosクライアントとサーバは、鍵の長さにわたって交渉することができます。クライアントは、完全な強度の暗号化を実行できない場合は、弱い暗号化タイプを使用して、オーセンティケータの「サブキー」フィールドにキーを提案することができます。その後、サーバーは同じキーを返すか、APのサブキーフィールドに、独自のキーを提案しなければならないのいずれかのメッセージを返信します。データを暗号化するために使用されるキーは、サーバから返されたキーから導出されます。クライアントは、強力な暗号化を実行することが可能であるが、サーバーがない場合は、最初のオーセンティケータでのサブキーを送られることなく、APの返信にサブキーを提案することができます。"
    },
    {
      "indent": 0,
      "text": "7. GSS-API Kerberos V5 Mechanism Type",
      "section_title": true,
      "ja": "7. GSS-APIにKerberos V5メカニズムタイプ"
    },
    {
      "indent": 0,
      "text": "7.1. Mechanism Specific Changes",
      "section_title": true,
      "ja": "7.1。機構固有の変更点"
    },
    {
      "indent": 3,
      "text": "The Generic Security Service Application Program Interface (GSS-API) per-message tokens also require new checksum and encryption types. The GSS-API per-message tokens are adapted to support these new encryption types. See [RFC1964] Section 1.2.2.",
      "ja": "メッセージごとの一般的なセキュリティサービスアプリケーションプログラムインタフェース（GSS-API）も、新しいチェックサムと暗号化の種類を必要とするトークン。 GSS-APIメッセージごとのトークンは、これらの新しい暗号化タイプをサポートするようになっています。 [RFC1964]セクション1.2.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The only support quality of protection is:",
      "ja": "保護の唯一のサポートの品質は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "#define GSS_KRB5_INTEG_C_QOP_DEFAULT 0x0",
      "ja": "#define GSS_KRB5_INTEG_C_QOP_DEFAULT 0x0の"
    },
    {
      "indent": 3,
      "text": "When using this RC4-based encryption type, the sequence number is always sent in big-endian rather than little-endian order.",
      "ja": "このRC4ベースの暗号化タイプを使用する場合は、シーケンス番号は常にリトルエンディアン順ではなく、ビッグエンディアンに送られます。"
    },
    {
      "indent": 3,
      "text": "The Windows 2000 implementation also defines new GSS-API flags in the initial token passed when initializing a security context. These flags are passed in the checksum field of the authenticator. See [RFC1964] Section 1.1.1.",
      "ja": "Windows 2000の実装では、セキュリティコンテキストを初期化するときに渡された最初のトークンに新しいGSS-APIのフラグを定義します。これらのフラグは、オーセンティケータのチェックサムフィールドに渡されます。 [RFC1964]セクション1.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "GSS_C_DCE_STYLE - This flag was added for use with Microsoft's implementation of Distributed Computing Environment Remote Procedure Call (DCE RPC), which initially expected three legs of authentication. Setting this flag causes an extra AP reply to be sent from the client back to the server after receiving the server's",
      "ja": "GSS_C_DCE_STYLE  - このフラグは、最初の認証の3本の脚を期待分散コンピューティング環境リモートプロシージャコール（RPC DCE）、のMicrosoftの実装で使用するために追加されました。このフラグを設定すると、サーバーのを受け取った後、クライアントからサーバーへの送信される追加のAP応答を引き起こし"
    },
    {
      "indent": 3,
      "text": "AP reply. In addition, the context negotiation tokens do not have GSS-API per-message tokens -- they are raw AP messages that do not include object identifiers.",
      "ja": "AP返信。また、コンテキスト交渉トークンは、GSS-APIメッセージごとのトークンを持っていない - 彼らはオブジェクト識別子が含まれていない生のAPメッセージです。"
    },
    {
      "indent": 11,
      "text": "#define GSS_C_DCE_STYLE 0x1000",
      "ja": "#define GSS_C_DCE_STYLEは0x1000"
    },
    {
      "indent": 3,
      "text": "GSS_C_IDENTIFY_FLAG - This flag allows the client to indicate to the server that it should only allow the server application to identify the client by name and ID, but not to impersonate the client.",
      "ja": "GSS_C_IDENTIFY_FLAG  - このフラグは、クライアントは、それが唯一のサーバー・アプリケーションは、名前とIDでクライアントを識別できるようにする必要がありますが、クライアントを偽装していないサーバーに指示することができます。"
    },
    {
      "indent": 11,
      "text": "#define GSS_C_IDENTIFY_FLAG 0x2000",
      "ja": "#define GSS_C_IDENTIFY_FLAG 0x2000で"
    },
    {
      "indent": 3,
      "text": "GSS_C_EXTENDED_ERROR_FLAG - Setting this flag indicates that the client wants to be informed of extended error information. In particular, Windows 2000 status codes may be returned in the data field of a Kerberos error message. This allows the client to understand a server failure more precisely. In addition, the server may return errors to the client that are normally handled at the application layer in the server, in order to let the client try to recover. After receiving an error message, the client may attempt to resubmit an AP request.",
      "ja": "GSS_C_EXTENDED_ERROR_FLAG  - このフラグを設定するには、クライアントが拡張エラー情報が通知されるように望んでいることを示しています。具体的には、Windows 2000のステータスコードは、Kerberosエラーメッセージのデータフィールドに返されることがあります。これは、クライアントがより正確に、サーバーの障害を理解することができます。また、サーバは、クライアントが回復してみましょうするためには、通常、サーバ内のアプリケーション層で処理され、クライアントにエラーを返すことがあります。エラーメッセージを受信した後、クライアントはAP要求を再送信しようとすることができます。"
    },
    {
      "indent": 11,
      "text": "#define GSS_C_EXTENDED_ERROR_FLAG 0x4000",
      "ja": "#define GSS_C_EXTENDED_ERROR_FLAG 0x4000の"
    },
    {
      "indent": 3,
      "text": "These flags are only used if a client is aware of these conventions when using the Security Support Provider Interface (SSPI) on the Windows platform; they are not generally used by default.",
      "ja": "Windowsプラットフォーム上でセキュリティサポートプロバイダインターフェイス（SSPI）を使用した場合、クライアントはこれらの規則を認識している場合、これらのフラグにのみ使用されます。彼らは一般的にデフォルトで使用されていません。"
    },
    {
      "indent": 3,
      "text": "When NetBIOS addresses are used in the GSS-API, they are identified by the GSS_C_AF_NETBIOS value. This value is defined as:",
      "ja": "NetBIOSのアドレスはGSS-APIで使用される場合、それらはGSS_C_AF_NETBIOS値によって識別されます。この値は、次のように定義されます"
    },
    {
      "indent": 11,
      "text": "#define GSS_C_AF_NETBIOS 0x14",
      "ja": "#define GSS_C_AF_NETBIOS 0x14の"
    },
    {
      "indent": 3,
      "text": "NetBios addresses are 16-octet addresses typically composed of 1 to 15 characters, trailing blank (ASCII char 20) filled, with a 16th octet of 0x0.",
      "ja": "NetBiosのアドレスが空白（ASCII文字20）末尾、典型的には1〜15文字で構成さ16オクテットのアドレスでは、0x0の第16オクテットで、充填されました。"
    },
    {
      "indent": 0,
      "text": "7.2. GSS-API MIC Semantics",
      "section_title": true,
      "ja": "7.2。 GSS-API MICセマンティクス"
    },
    {
      "indent": 3,
      "text": "The GSS-API checksum type and algorithm are defined in Section 5. Only the first 8 octets of the checksum are used. The resulting checksum is stored in the SGN_CKSUM field. See [RFC1964] Section 1.2 for GSS_GetMIC() and GSS_Wrap(conf_flag=FALSE).",
      "ja": "GSS-APIのチェックサムのタイプとアルゴリズムは、チェックサムの唯一の最初の8つのオクテットが使用されている第5節で定義されています。得られたチェックサムはSGN_CKSUMフィールドに格納されています。 [RFC1964] GSS_GetMICはセクション1.2（）を参照にGSS_Wrap（conf_flag = FALSE）。"
    },
    {
      "indent": 3,
      "text": "The GSS_GetMIC token has the following format:",
      "ja": "GSS_GetMICトークンの形式は、次のとおりです。"
    },
    {
      "indent": 8,
      "text": "Byte no         Name        Description\n0..1           TOK_ID     Identification field.\n                          Tokens emitted by GSS_GetMIC() contain\n                          the hex value 01 01 in this field.\n2..3           SGN_ALG    Integrity algorithm indicator.\n                          11 00 - HMAC\n4..7           Filler     Contains ff ff ff ff\n8..15          SND_SEQ    Sequence number field.\n16..23         SGN_CKSUM  Checksum of \"to-be-signed data\",\n                          calculated according to algorithm\n                          specified in SGN_ALG field.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The MIC mechanism used for GSS-MIC-based messages is as follows:",
      "ja": "次のようにGSS-MICベースのメッセージに使用されるMICメカニズムは次のとおりです。"
    },
    {
      "indent": 11,
      "text": "GetMIC(Kss, direction, export, seq_num, data)\n{\n        struct Token {\n               struct Header {\n                      OCTET TOK_ID[2];\n                      OCTET SGN_ALG[2];\n                      OCTET Filler[4];\n                 };\n               OCTET SND_SEQ[8];\n               OCTET SGN_CKSUM[8];\n        } Token;",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Token.TOK_ID = 01 01;\nToken.SGN_SLG = 11 00;\nToken.Filler = ff ff ff ff;",
      "raw": true
    },
    {
      "indent": 19,
      "text": "// Create the sequence number",
      "ja": "//シーケンス番号を作成します。"
    },
    {
      "indent": 19,
      "text": "if (direction == sender_is_initiator)\n{\n        memset(Token.SEND_SEQ+4, 0xff, 4)\n}\nelse if (direction == sender_is_acceptor)\n{\n        memset(Token.SEND_SEQ+4, 0, 4)\n}\nToken.SEND_SEQ[0] = (seq_num & 0xff000000) >> 24;\nToken.SEND_SEQ[1] = (seq_num & 0x00ff0000) >> 16;\nToken.SEND_SEQ[2] = (seq_num & 0x0000ff00) >> 8;\nToken.SEND_SEQ[3] = (seq_num & 0x000000ff);",
      "raw": true
    },
    {
      "indent": 19,
      "text": "// Derive signing key from session key",
      "ja": "//セッション鍵から鍵を署名導出します"
    },
    {
      "indent": 19,
      "text": "Ksign = HMAC(Kss, \"signaturekey\"); // length includes terminating null",
      "ja": "Ksign = HMAC（KSS、 \"signaturekey\"）。 //長さは、終端のnullを含み"
    },
    {
      "indent": 19,
      "text": "// Generate checksum of message - SGN_CKSUM // Key derivation salt = 15",
      "ja": "//メッセージのチェックサムを生成 -  SGN_CKSUM //キー派生塩= 15"
    },
    {
      "indent": 19,
      "text": "Sgn_Cksum = MD5((int32)15, Token.Header, data);",
      "ja": "SGN_CKSUM = MD5（（INT32）15、Token.Header、データ）。"
    },
    {
      "indent": 19,
      "text": "// Save first 8 octets of HMAC Sgn_Cksum",
      "ja": "// HMAC SGN_CKSUMの最初の8つのオクテットを保存"
    },
    {
      "indent": 19,
      "text": "Sgn_Cksum = HMAC(Ksign, Sgn_Cksum);\nmemcpy(Token.SGN_CKSUM, Sgn_Cksum, 8);",
      "raw": true
    },
    {
      "indent": 19,
      "text": "// Encrypt the sequence number",
      "ja": "//シーケンス番号を暗号化"
    },
    {
      "indent": 19,
      "text": "// Derive encryption key for the sequence number // Key derivation salt = 0",
      "ja": "シーケンス番号//鍵導出塩= 0 //派生暗号化キー"
    },
    {
      "indent": 19,
      "text": "if (exportable)\n{\n        Kseq = HMAC(Kss, \"fortybits\", (int32)0);\n                     // len includes terminating null\n        memset(Kseq+7, 0xab, 7)\n}\nelse\n{\n         Kseq = HMAC(Kss, (int32)0);\n}\nKseq = HMAC(Kseq, Token.SGN_CKSUM);",
      "raw": true
    },
    {
      "indent": 19,
      "text": "// Encrypt the sequence number",
      "ja": "//シーケンス番号を暗号化"
    },
    {
      "indent": 11,
      "text": " RC4(Kseq, Token.SND_SEQ); }",
      "ja": "RC4（Kseq、Token.SND_SEQ）。 }"
    },
    {
      "indent": 0,
      "text": "7.3. GSS-API WRAP Semantics",
      "section_title": true,
      "ja": "7.3。 GSS-API WRAPセマンティクス"
    },
    {
      "indent": 3,
      "text": "There are two encryption keys for GSS-API message tokens, one that is 128 bits in strength and one that is 56 bits in strength as defined in Section 6.",
      "ja": "GSS-APIメッセージトークンの2つの暗号化キー、強度​​及びセクション6で定義されるような強度で56ビットであるものに128ビットであるものがあります。"
    },
    {
      "indent": 3,
      "text": "All padding is rounded up to 1 byte. One byte is needed to say that there is 1 byte of padding. The DES-based mechanism type uses 8-byte padding. See [RFC1964] Section 1.2.2.3.",
      "ja": "すべてのパディングは1バイトに切り上げられます。 1つのバイトはパディングの1つのバイトがあることを言うために必要とされます。 DESベースのメカニズムのタイプは8バイトのパディングを使用しています。 [RFC1964]のセクション1.2.2.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "The RC4-HMAC GSS_Wrap() token has the following format:",
      "ja": "RC4-HMACにGSS_Wrap（）トークンは、次の形式を有します。"
    },
    {
      "indent": 6,
      "text": "Byte no Name Description 0..1 TOK_ID Identification field. Tokens emitted by GSS_Wrap() contain the hex value 02 01 in this field. 2..3 SGN_ALG Checksum algorithm indicator. 11 00 - HMAC 4..5 SEAL_ALG ff ff - none 00 00 - DES-CBC 10 00 - RC4 6..7 Filler Contains ff ff 8..15 SND_SEQ Encrypted sequence number field. 16..23 SGN_CKSUM Checksum of plaintext padded data, calculated according to algorithm specified in SGN_ALG field. 24..31 Confounder Random confounder. 32..last Data Encrypted or plaintext padded data.",
      "ja": "なし名前説明0..1 TOK_ID識別フィールドバイト。 GSS_Wrap（によって放出されたトークン）は、この分野における02 01進値を含みます。 2..3 SGN_ALGチェックサムアルゴリズムインジケータ。 11 00  -  HMAC 4..5 SEAL_ALG用のFF FF  - なし00 00  -  DES-CBC 10 00  -  RC4 6..7フィラー8..15 SND_SEQ暗号化シーケンス番号フィールドFF FF含ま。 SGN_ALGフィールドに指定されたアルゴリズムに従って計算平文パディングデータの16..23 SGN_CKSUMチェックサム、。 24..31交絡因子ランダム交絡因子。データ暗号化または平文パディングデータ32..last。"
    },
    {
      "indent": 3,
      "text": "The encryption mechanism used for GSS-wrap-based messages is as follows:",
      "ja": "次のようにGSS-ラップベースのメッセージに使用される暗号化メカニズムは次のようになります。"
    },
    {
      "indent": 11,
      "text": "WRAP(Kss, encrypt, direction, export, seq_num, data)\n{\n        struct Token {          // 32 octets\n               struct Header {\n                      OCTET TOK_ID[2];\n                      OCTET SGN_ALG[2];\n                      OCTET SEAL_ALG[2];\n                      OCTET Filler[2];\n               };\n               OCTET SND_SEQ[8];\n               OCTET SGN_CKSUM[8];\n                 OCTET Confounder[8];\n        } Token;",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Token.TOK_ID = 02 01;\nToken.SGN_SLG = 11 00;\nToken.SEAL_ALG = (no_encrypt)? ff ff : 10 00;\nToken.Filler = ff ff;",
      "raw": true
    },
    {
      "indent": 19,
      "text": "// Create the sequence number",
      "ja": "//シーケンス番号を作成します。"
    },
    {
      "indent": 19,
      "text": "if (direction == sender_is_initiator) {",
      "ja": "IF（方向== sender_is_initiator）{"
    },
    {
      "indent": 19,
      "text": "        memset(&Token.SEND_SEQ[4], 0xff, 4)\n}\nelse if (direction == sender_is_acceptor)\n{\n        memset(&Token.SEND_SEQ[4], 0, 4)\n}\nToken.SEND_SEQ[0] = (seq_num & 0xff000000) >> 24;\nToken.SEND_SEQ[1] = (seq_num & 0x00ff0000) >> 16;\nToken.SEND_SEQ[2] = (seq_num & 0x0000ff00) >> 8;\nToken.SEND_SEQ[3] = (seq_num & 0x000000ff);",
      "raw": true
    },
    {
      "indent": 19,
      "text": "// Generate random confounder",
      "ja": "//ランダムな交絡因子を生成します"
    },
    {
      "indent": 19,
      "text": "nonce(&Token.Confounder, 8);",
      "ja": "ノンス（＆Token.Confounder、8）。"
    },
    {
      "indent": 19,
      "text": "// Derive signing key from session key",
      "ja": "//セッション鍵から鍵を署名導出します"
    },
    {
      "indent": 19,
      "text": "Ksign = HMAC(Kss, \"signaturekey\");",
      "ja": "Ksign = HMAC（KSS、 \"signaturekey\"）。"
    },
    {
      "indent": 19,
      "text": "// Generate checksum of message - // SGN_CKSUM + Token.Confounder // Key derivation salt = 15",
      "ja": "//メッセージのチェックサムを生成 -  // SGN_CKSUM + Token.Confounder //キー派生塩= 15"
    },
    {
      "indent": 19,
      "text": "Sgn_Cksum = MD5((int32)15, Token.Header, Token.Confounder);",
      "ja": "SGN_CKSUM = MD5（（INT32）15、Token.Header、Token.Confounder）。"
    },
    {
      "indent": 19,
      "text": "// Derive encryption key for data // Key derivation salt = 0",
      "ja": "データ用//派生暗号化キー//キー導出塩= 0"
    },
    {
      "indent": 19,
      "text": "for (i = 0; i < 16; i++) Klocal[i] = Kss[i] ^ 0xF0;\n                                         // XOR\nif (exportable)\n{\n        Kcrypt = HMAC(Klocal, \"fortybits\", (int32)0);\n                    // len includes terminating null\n        memset(Kcrypt+7, 0xab, 7);\n}\nelse\n{\n        Kcrypt = HMAC(Klocal, (int32)0);\n  }",
      "raw": true
    },
    {
      "indent": 19,
      "text": "// new encryption key salted with seq",
      "ja": "//新しい暗号化キー配列と塩漬け"
    },
    {
      "indent": 19,
      "text": "Kcrypt = HMAC(Kcrypt, (int32)seq);",
      "ja": "Kcrypt = HMAC（Kcrypt、（INT32）配列）。"
    },
    {
      "indent": 19,
      "text": "// Encrypt confounder (if encrypting)",
      "ja": "//暗号化交絡因子（暗号化の場合）"
    },
    {
      "indent": 19,
      "text": "if (encrypt) RC4(Kcrypt, Token.Confounder);",
      "ja": "IF（暗号化）、RC4（Kcrypt、Token.Confounder）。"
    },
    {
      "indent": 19,
      "text": "// Sum the data buffer",
      "ja": "//データバッファを合計"
    },
    {
      "indent": 19,
      "text": "Sgn_Cksum += MD5(data); // Append to checksum",
      "ja": "SGN_CKSUM + = MD5（データ）。 //チェックサムに追加"
    },
    {
      "indent": 19,
      "text": "// Encrypt the data (if encrypting)",
      "ja": "（暗号場合）//データを暗号化"
    },
    {
      "indent": 19,
      "text": "if (encrypt) RC4(Kcrypt, data);",
      "ja": "（暗号化）、RC4（Kcrypt、データ）であれば、"
    },
    {
      "indent": 19,
      "text": "// Save first 8 octets of HMAC Sgn_Cksum",
      "ja": "// HMAC SGN_CKSUMの最初の8つのオクテットを保存"
    },
    {
      "indent": 19,
      "text": "Sgn_Cksum = HMAC(Ksign, Sgn_Cksum);\nmemcpy(Token.SGN_CKSUM, Sgn_Cksum, 8);",
      "raw": true
    },
    {
      "indent": 19,
      "text": "// Derive encryption key for the sequence number // Key derivation salt = 0",
      "ja": "シーケンス番号//鍵導出塩= 0 //派生暗号化キー"
    },
    {
      "indent": 19,
      "text": "if (exportable)\n{\n        Kseq = HMAC(Kss, \"fortybits\", (int32)0);\n                    // len includes terminating null\n        memset(Kseq+7, 0xab, 7)\n}\nelse\n{\n        Kseq = HMAC(Kss, (int32)0);\n}\nKseq = HMAC(Kseq, Token.SGN_CKSUM);",
      "raw": true
    },
    {
      "indent": 19,
      "text": "// Encrypt the sequence number",
      "ja": "//シーケンス番号を暗号化"
    },
    {
      "indent": 19,
      "text": "RC4(Kseq, Token.SND_SEQ);",
      "ja": "RC4（Kseq、Token.SND_SEQ）。"
    },
    {
      "indent": 11,
      "text": " // Encrypted message = Token + Data }",
      "ja": "//暗号化されたメッセージ=トークン+データ}"
    },
    {
      "indent": 3,
      "text": "The character constant \"fortybits\" evolved from the time when a 40-bit key length was all that was exportable from the United States. It is now used to recognize that the key length is of \"exportable\" length. In this description, the key size is actually 56 bits.",
      "ja": "文字定数「fortybitsは、」40ビットの鍵長が米国からエクスポートしたものすべてだった時から進化しました。現在では、キーの長さは、「エクスポート」の長さであることを認識するために使用されます。この説明では、キーのサイズは実際に56ビットです。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Care must be taken in implementing these encryption types because they use a stream cipher. If a different IV is not used in each direction when using a session key, the encryption is weak. By using the sequence number as an IV, this is avoided.",
      "ja": "彼らはストリーム暗号を使用しているため注意がこれらの暗号化タイプを実装するには注意する必要があります。セッションキーを使用するときに異なるIVを各方向に使用されていない場合、暗号化は弱いです。 IVとしてシーケンス番号を使用することにより、これを回避することができます。"
    },
    {
      "indent": 3,
      "text": "There are two classes of attack on RC4 described in [MIRONOV]. Strong distinguishers distinguish an RC4 keystream from randomness at the start of the stream. Weak distinguishers can operate on any part of the keystream, and the best ones, described in [FMcG] and [MANTIN05], can exploit data from multiple, different keystreams. A consequence of these is that encrypting the same data (for instance, a password) sufficiently many times in separate RC4 keystreams can be sufficient to leak information to an adversary. The encryption types defined in this document defend against these by constructing a new keystream for every message. However, it is RECOMMENDED not to use the RC4 encryption types defined in this document for high-volume connections.",
      "ja": "[ミロノフ]で説明RC4の攻撃の2つのクラスがあります。強力な区別子は、ストリームの開始時にランダム性からRC4のキーストリームを区別する。弱識別器は、キーストリームの任意の部分で動作する、とすることができる[FMCG]に記載の最高のもの、および[MANTIN05]、複数の異なるキーストリームからのデータを利用することができます。これらの結果は、同じデータを暗号化する（例えば、パスワード）別RC4のキーストリームに十分に多くの時間が敵に情報を漏洩するのに十分であることができるということです。この文書で定義された暗号化タイプは、メッセージごとに新しい鍵ストリームを構築することにより、これらを防御します。しかし、大量の接続のために、この文書で定義されたRC4暗号化タイプを使用しないことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Weaknesses in MD4 [BOER91] were demonstrated by den Boer and Bosselaers in 1991. In August 2004, Xiaoyun Wang, et al., reported MD4 collisions generated using hand calculation [WANG04]. Implementations based on Wang's algorithm can find collisions in real time. However, the intended usage of MD4 described in this document does not rely on the collision-resistant property of MD4. Furthermore, MD4 is always used in the context of a keyed hash in this document. Although no evidence has suggested keyed MD4 hashes are vulnerable to collision-based attacks, no study has directly proved that the HMAC-MD4 is secure: the existing study simply assumed that the hash function used in HMAC is collision proof. It is thus RECOMMENDED not to use the RC4 encryption types defined in this document if alternative stronger encryption types, such as aes256-cts-hmac-sha1-96 [RFC3962], are available.",
      "ja": "MD4 [BOER91]の弱点は、Xiaoyunワングら、2004年8月1991年DENボーアとBosselaersによって実証された。、MD4衝突が[WANG04】手計算を使用して生成され報告されています。王のアルゴリズムに基づいた実装は、リアルタイムでの衝突を見つけることができます。しかし、この文書で説明MD4の使用目的は、MD4の衝突耐性の性質に依存しません。さらに、MD4は、常にこの文書に記載されている鍵付きハッシュの文脈で使用されます。証拠は鍵付きMD4ハッシュが衝突ベースの攻撃に対して脆弱で示唆しなかったが、何の研究では、直接、HMAC-MD4が安全であることを証明していない：既存の研究では、単にHMACで使用されるハッシュ関数は、衝突の証拠であると仮定しました。このように、このようなAES256-CTS-HMAC-SHA1-96 [RFC3962]などの別の強力な暗号化の種類は、利用可能である場合は、この文書で定義されたRC4暗号化タイプを使用しないことをお勧めします。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Section 5 of this document defines two Kerberos encryption types rc4-hmac (23) and rc4-hmac-exp (24). The Kerberos parameters registration page at <http://www.iana.org/assignments/kerberos-parameters> has been updated to reference this document for these two encryption types.",
      "ja": "このドキュメントのセクション5は、2つのKerberos暗号化タイプのRC4-HMAC（23）とRC4-HMAC-EXP（24）を定義します。 Kerberosがで登録ページパラメータ<http://www.iana.org/assignments/kerberos-parameters>これら2つの暗号化の種類については、この文書を参照するように更新されました。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgements",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Sam Hartman, Ken Raeburn, and Qunli Li for their insightful comments.",
      "ja": "作者は彼らの洞察に満ちたコメントをサム・ハートマン、ケン・レイバーン、およびQunliリーに感謝したいです。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1320] Rivest, R., \"The MD4 Message-Digest Algorithm\", RFC 1320, April 1992.",
      "ja": "[RFC1320]のRivest、R.、 \"MD4メッセージダイジェストアルゴリズム\"、RFC 1320、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1321] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[RFC1321]のRivest、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1964] Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\", RFC 1964, June 1996.",
      "ja": "[RFC1964]リン、J.、 \"Kerberosバージョン5 GSS-APIメカニズム\"、RFC 1964、1996年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3961] Raeburn, K., \"Encryption and Checksum Specifications for Kerberos 5\", RFC 3961, February 2005.",
      "ja": "[RFC3961]レイバーン、K.、 \"暗号化とケルベロス5チェックサムの仕様\"、RFC 3961、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3962] Raeburn, K., \"Advanced Encryption Standard (AES) Encryption for Kerberos 5\", RFC 3962, February 2005.",
      "ja": "[RFC3962]レイバーン、K.、 \"Kerberos 5のためのAdvanced Encryption Standard（AES）暗号化\"、RFC 3962、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The Kerberos Network Authentication Service (V5)\", RFC 4120, July 2005.",
      "ja": "[RFC4120]ノイマン、C.、ゆう、T.、ハルトマン、S.、およびK.レイバーン、 \"ケルベロスネットワーク認証サービス（V5）\"、RFC 4120、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4537] Zhu, L., Leach, P., and K. Jaganathan, \"Kerberos Cryptosystem Negotiation Extension\", RFC 4537, June 2006.",
      "ja": "[RFC4537]朱、L.、リーチ、P.、およびK. Jaganathan、 \"ケルベロス暗号交渉拡張\"、RFC 4537、2006年6月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[BOER91] den Boer, B. and A. Bosselaers, \"An Attack on the Last Two Rounds of MD4\", Proceedings of the 11th Annual International Cryptology Conference on Advances in Cryptology, pages: 194 - 203, 1991.",
      "ja": "[BOER91]デンボーア、B.とA. Bosselaers、「MD4の最後の2ラウンドの攻撃」、暗号学の進歩の第11回国際暗号学会議議事録、ページ：194から203、1991。"
    },
    {
      "indent": 3,
      "text": "[FMcG] Fluhrer, S. and D. McGrew, \"Statistical Analysis of the Alleged RC4 Keystream Generator\", Fast Software Encryption: 7th International Workshop, FSE 2000, April 2000, <http://www.mindspring.com/~dmcgrew/rc4-03.pdf>.",
      "ja": "[FMCG] Fluhrer、S.およびD.マグリュー、 \"疑惑RC4キーストリームジェネレータの統計的分析\"、高速ソフトウェア暗号化：第7回国際ワークショップ、FSE 2000年、2000年4月、<http://www.mindspring.com/~dmcgrew /rc4-03.pdf>。"
    },
    {
      "indent": 3,
      "text": "[MANTIN05] Mantin, I., \"Predicting and Distinguishing Attacks on RC4 Keystream Generator\", Advances in Cryptology -- EUROCRYPT 2005: 24th Annual International Conference on the Theory and Applications of Cryptographic Techniques, May 2005.",
      "ja": "暗号技術、2005年5月の理論と応用に第24回国際会議：EUROCRYPT 2005  -  [MANTIN05] Mantin、I.、「予測およびRC4キーストリームジェネレータの区別攻撃は」、暗号学の進歩します。"
    },
    {
      "indent": 3,
      "text": "[MIRONOV] Mironov, I., \"(Not So) Random Shuffles of RC4\", Advances in Cryptology -- CRYPTO 2002: 22nd Annual International Cryptology Conference, August 2002, <http://eprint.iacr.org/2002/067.pdf>.",
      "ja": "[ミロノフ]ミロノフ、I.、 \"（ない）RC4のランダムシャッフル\" は、暗号学の進歩 -  CRYPTO 2002：第22回国際暗号学会議、2002年8月、<http://eprint.iacr.org/2002/067 .PDF>。"
    },
    {
      "indent": 3,
      "text": "[WANG04] Wang, X., Lai, X., Feng, D., Chen, H., and X. Yu, \"Cryptanalysis of Hash functions MD4 and RIPEMD\", August 2004, <http://www.infosec.sdu.edu.cn/paper/md4-ripemd-attck.pdf>.",
      "ja": "[WANG04]王、X.、ライ、X.、風水、D.、陳、H.、およびX.ゆう、 \"ハッシュ関数MD4とRIPEMDの解読\"、2004年8月、<のhttp：//www.infosec。 sdu.edu.cn/paper/md4-ripemd-attck.pdf>。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Karthik Jaganathan Microsoft Corporation One Microsoft Way Redmond, WA 98052 US",
      "ja": "カルティクJaganathanマイクロソフト社1マイクロソフト道、レッドモンド、ワシントン98052米国"
    },
    {
      "indent": 3,
      "text": "EMail: karthikj@microsoft.com",
      "ja": "メールアドレス：karthikj@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Larry Zhu Microsoft Corporation One Microsoft Way Redmond, WA 98052 US",
      "ja": "ラリー朱マイクロソフト社1マイクロソフト道、レッドモンド、ワシントン98052米国"
    },
    {
      "indent": 3,
      "text": "EMail: lzhu@microsoft.com",
      "ja": "メールアドレス：lzhu@microsoft.com"
    },
    {
      "indent": 3,
      "text": "John Brezak Microsoft Corporation One Microsoft Way Redmond, WA 98052 US",
      "ja": "ジョンBrezakマイクロソフト社1マイクロソフト道、レッドモンド、ワシントン98052米国"
    },
    {
      "indent": 3,
      "text": "EMail: jbrezak@microsoft.com",
      "ja": "メールアドレス：jbrezak@microsoft.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2006).",
      "ja": "著作権（C）IETFトラスト（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST, AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書およびここに含まれる情報は、上に提供される基礎とCONTRIBUTOR、ORGANIZATION彼/彼女が表すOR（もしあれば）後援が「そのまま」、インターネット学会、IETFトラスト、インターネットエンジニアリングタスクフォース放棄情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されないすべての保証、明示または黙示、。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}