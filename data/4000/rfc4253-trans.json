{
  "title": {
    "text": "RFC 4253 - The Secure Shell (SSH) Transport Layer Protocol",
    "ja": "RFC 4253 - セキュアシェル（SSH）トランスポート層プロトコル"
  },
  "number": 4253,
  "created_at": "2019-10-22 14:04:20.090041+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          T. Ylonen\nRequest for Comments: 4253              SSH Communications Security Corp\nCategory: Standards Track                                C. Lonvick, Ed.\n                                                     Cisco Systems, Inc.\n                                                            January 2006",
      "raw": true
    },
    {
      "indent": 12,
      "text": "The Secure Shell (SSH) Transport Layer Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Secure Shell (SSH) is a protocol for secure remote login and other secure network services over an insecure network.",
      "ja": "セキュアシェル（SSH）は、安全でないネットワーク上の安全なリモートログイン及び他の安全なネットワークサービスのためのプロトコルです。"
    },
    {
      "indent": 3,
      "text": "This document describes the SSH transport layer protocol, which typically runs on top of TCP/IP. The protocol can be used as a basis for a number of secure network services. It provides strong encryption, server authentication, and integrity protection. It may also provide compression.",
      "ja": "この文書では、通常、TCP / IP上で動作するSSHトランスポート層プロトコルを、説明しています。プロトコルは、セキュアなネットワークサービスの数のための基礎として使用することができます。それは強力な暗号化、サーバー認証、および完全性保護を提供します。また、圧縮を提供することができます。"
    },
    {
      "indent": 3,
      "text": "Key exchange method, public key algorithm, symmetric encryption algorithm, message authentication algorithm, and hash algorithm are all negotiated.",
      "ja": "鍵交換方式、公開鍵アルゴリズム、対称暗号化アルゴリズム、メッセージ認証アルゴリズム、およびハッシュアルゴリズムは、すべてのネゴシエートされます。"
    },
    {
      "indent": 3,
      "text": "This document also describes the Diffie-Hellman key exchange method and the minimal set of algorithms that are needed to implement the SSH transport layer protocol.",
      "ja": "この文書はまた、ディフィー・ヘルマン鍵共有法とSSHトランスポート層プロトコルを実装するために必要とされるアルゴリズムの最小セットを記述する。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Contributors ....................................................3\n3. Conventions Used in This Document ...............................3\n4. Connection Setup ................................................4\n   4.1. Use over TCP/IP ............................................4\n   4.2. Protocol Version Exchange ..................................4\n5. Compatibility With Old SSH Versions .............................5\n   5.1. Old Client, New Server .....................................6\n   5.2. New Client, Old Server .....................................6\n   5.3. Packet Size and Overhead ...................................6\n6. Binary Packet Protocol ..........................................7\n   6.1. Maximum Packet Length ......................................8\n   6.2. Compression ................................................8\n   6.3. Encryption .................................................9\n   6.4. Data Integrity ............................................12\n   6.5. Key Exchange Methods ......................................13\n   6.6. Public Key Algorithms .....................................13\n7. Key Exchange ...................................................15\n   7.1. Algorithm Negotiation .....................................17\n   7.2. Output from Key Exchange ..................................20\n   7.3. Taking Keys Into Use ......................................21\n8. Diffie-Hellman Key Exchange ....................................21\n   8.1. diffie-hellman-group1-sha1 ................................23\n   8.2. diffie-hellman-group14-sha1 ...............................23\n9. Key Re-Exchange ................................................23\n10. Service Request ...............................................24\n11. Additional Messages ...........................................25\n   11.1. Disconnection Message ....................................25\n   11.2. Ignored Data Message .....................................26\n   11.3. Debug Message ............................................26\n   11.4. Reserved Messages ........................................27\n12. Summary of Message Numbers ....................................27\n13. IANA Considerations ...........................................27\n14. Security Considerations .......................................28\n15. References ....................................................29\n   15.1. Normative References .....................................29\n   15.2. Informative References ...................................30\nAuthors' Addresses ................................................31\nTrademark Notice ..................................................31",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The SSH transport layer is a secure, low level transport protocol. It provides strong encryption, cryptographic host authentication, and integrity protection.",
      "ja": "SSH輸送層は、安全な、低レベルのトランスポートプロトコルです。それは強力な暗号化、暗号化ホスト認証、および完全性保護を提供します。"
    },
    {
      "indent": 3,
      "text": "Authentication in this protocol level is host-based; this protocol does not perform user authentication. A higher level protocol for user authentication can be designed on top of this protocol.",
      "ja": "このプロトコルレベルでの認証は、ホストベースです。このプロトコルは、ユーザー認証を行いません。ユーザ認証のために、より高いレベルのプロトコルは、このプロトコルの上で設計することができます。"
    },
    {
      "indent": 3,
      "text": "The protocol has been designed to be simple and flexible to allow parameter negotiation, and to minimize the number of round-trips. The key exchange method, public key algorithm, symmetric encryption algorithm, message authentication algorithm, and hash algorithm are all negotiated. It is expected that in most environments, only 2 round-trips will be needed for full key exchange, server authentication, service request, and acceptance notification of service request. The worst case is 3 round-trips.",
      "ja": "プロトコルは、パラメータネゴシエーションを可能にするため、およびラウンドトリップの数を最小限にするために、シンプルで柔軟に設計されています。鍵交換方式、公開鍵アルゴリズム、対称暗号化アルゴリズム、メッセージ認証アルゴリズム、およびハッシュアルゴリズムは、すべてのネゴシエートされます。ほとんどの環境では、わずか2ラウンドトリップがいっぱい鍵交換、サーバー認証、サービス要求、およびサービス要求の受理通知のために必要とされるであろうことが期待されます。最悪の場合は3往復です。"
    },
    {
      "indent": 0,
      "text": "2. Contributors",
      "section_title": true,
      "ja": "2.協力者"
    },
    {
      "indent": 3,
      "text": "The major original contributors of this set of documents have been: Tatu Ylonen, Tero Kivinen, Timo J. Rinne, Sami Lehtinen (all of SSH Communications Security Corp), and Markku-Juhani O. Saarinen (University of Jyvaskyla). Darren Moffat was the original editor of this set of documents and also made very substantial contributions.",
      "ja": "文書のこのセットの主要な元貢献はされている：タトゥYlonenと、TERO Kivinen、ティモJ.リンネ、サミLehtinenの（SSHコミュニケーションズ・セキュリティ社の全て）、およびマルック・Juhani O.サーリネン（ユヴァスキュラ大学）。ダレン・モファットは、文書のこのセットの元編集者だったとも非常に実質的な貢献をしました。"
    },
    {
      "indent": 3,
      "text": "Many people contributed to the development of this document over the years. People who should be acknowledged include Mats Andersson, Ben Harris, Bill Sommerfeld, Brent McClure, Niels Moller, Damien Miller, Derek Fawcus, Frank Cusack, Heikki Nousiainen, Jakob Schlyter, Jeff Van Dyke, Jeffrey Altman, Jeffrey Hutzelman, Jon Bright, Joseph Galbraith, Ken Hornstein, Markus Friedl, Martin Forssen, Nicolas Williams, Niels Provos, Perry Metzger, Peter Gutmann, Simon Josefsson, Simon Tatham, Wei Dai, Denis Bider, der Mouse, and Tadayoshi Kohno. Listing their names here does not mean that they endorse this document, but that they have contributed to it.",
      "ja": "多くの人々が長年にわたってこのドキュメントの発展に貢献しました。承認される必要がある人々は、マット・アンダーソン、ベン・ハリス、ビルゾンマーフェルト、ブレントマクルーア、ニールス・モーラー、ダミアン・ミラー、デレクFawcus、フランク・キューザック、ハイッキ・ヌジアイナン、ヤコブSchlyter、ジェフ・ヴァン・ダイク、ジェフリー・アルトマン、ジェフリーHutzelman、ジョン明るい、ジョセフが含まれますガルブレイス、ケンHornstein、マルクスFriedlの、マーティンForssen、ニコラス・ウィリアムズ、ニールス・プロボス、ペリーメッツガー、ピーター・ガットマン、サイモンJosefsson氏、サイモンTatham氏、魏大、デニスBider、DERマウス、および忠義河野。ここに自分の名前をリスト彼らはこの文書を承認することを意味するものではありませんが、彼らはそれに貢献してきたこと。"
    },
    {
      "indent": 0,
      "text": "3. Conventions Used in This Document",
      "section_title": true,
      "ja": "この文書で使用される3表記"
    },
    {
      "indent": 3,
      "text": "All documents related to the SSH protocols shall use the keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" to describe requirements. These keywords are to be interpreted as described in [RFC2119].",
      "ja": "SSHプロトコルに関連するすべての文書は、 \"MAY\"、 \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\" \"ないもの\"、 \"推奨\" \"NOTべきである\" キーワードを使用しなければなりません、要件を記述すると「オプション」。これらのキーワードは、[RFC2119]に記載されているように解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "The keywords \"PRIVATE USE\", \"HIERARCHICAL ALLOCATION\", \"FIRST COME FIRST SERVED\", \"EXPERT REVIEW\", \"SPECIFICATION REQUIRED\", \"IESG APPROVAL\", \"IETF CONSENSUS\", and \"STANDARDS ACTION\" that appear in this document when used to describe namespace allocation are to be interpreted as described in [RFC2434].",
      "ja": "キーワード「私的使用」、「階層割り当ては」、「先着順」この文書に表示される「EXPERT REVIEW」、「仕様REQUIRED」、「IESGの承認」、「IETFコンセンサス」、および「STANDARDS ACTION」、名前空間の割り当てを記述するために使用される[RFC2434]に記載されているように解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "Protocol fields and possible values to fill them are defined in this set of documents. Protocol fields will be defined in the message definitions. As an example, SSH_MSG_CHANNEL_DATA is defined as follows.",
      "ja": "プロトコルフィールドとそれを埋めるために可能な値は、文書のこのセットで定義されています。プロトコルフィールドは、メッセージ定義で定義されます。次のように、一例として、SSH_MSG_CHANNEL_DATAが定義されています。"
    },
    {
      "indent": 6,
      "text": "byte SSH_MSG_CHANNEL_DATA uint32 recipient channel string data",
      "ja": "バイトSSH_MSG_CHANNEL_DATA UINT32受信者チャネル列データ"
    },
    {
      "indent": 3,
      "text": "Throughout these documents, when the fields are referenced, they will appear within single quotes. When values to fill those fields are referenced, they will appear within double quotes. Using the above example, possible values for 'data' are \"foo\" and \"bar\".",
      "ja": "フィールドが参照されたとき、これらの文書を通じて、彼らは、単一引用符で囲んで表示されます。これらのフィールドを埋めるために値が参照されているとき、彼らは二重引用符で表示されます。上記の例を使用して、「データ」のための可能な値は、「foo」と「bar」です。"
    },
    {
      "indent": 0,
      "text": "4. Connection Setup",
      "section_title": true,
      "ja": "4.接続のセットアップ"
    },
    {
      "indent": 3,
      "text": "SSH works over any 8-bit clean, binary-transparent transport. The underlying transport SHOULD protect against transmission errors, as such errors cause the SSH connection to terminate.",
      "ja": "SSHは、任意の8ビットクリーン、バイナリ透明のトランスポート上で動作します。このようなエラーが終了するSSH接続を原因として、基礎となるトランスポートは、送信エラーから保護すべきです。"
    },
    {
      "indent": 3,
      "text": "The client initiates the connection.",
      "ja": "クライアントが接続を開始します。"
    },
    {
      "indent": 0,
      "text": "4.1. Use over TCP/IP",
      "section_title": true,
      "ja": "4.1.  TCP / IP経由で使用してください"
    },
    {
      "indent": 3,
      "text": "When used over TCP/IP, the server normally listens for connections on port 22. This port number has been registered with the IANA, and has been officially assigned for SSH.",
      "ja": "TCP / IP上で使用する場合、サーバは通常、このポート番号は、IANAに登録されている、と正式にSSHのために割り当てられているポート22で接続を待機します。"
    },
    {
      "indent": 0,
      "text": "4.2. Protocol Version Exchange",
      "section_title": true,
      "ja": "4.2. プロトコルバージョン所"
    },
    {
      "indent": 3,
      "text": "When the connection has been established, both sides MUST send an identification string. This identification string MUST be",
      "ja": "接続が確立されているときに、両側は、識別文字列を送信しなければなりません。この識別文字列でなければなりません"
    },
    {
      "indent": 6,
      "text": "SSH-protoversion-softwareversion SP comments CR LF",
      "ja": "SSH-PROTOVERSION-softwareversion SPはCR LFコメント"
    },
    {
      "indent": 3,
      "text": "Since the protocol being defined in this set of documents is version 2.0, the 'protoversion' MUST be \"2.0\". The 'comments' string is OPTIONAL. If the 'comments' string is included, a 'space' character (denoted above as SP, ASCII 32) MUST separate the 'softwareversion' and 'comments' strings. The identification MUST be terminated by a single Carriage Return (CR) and a single Line Feed (LF) character (ASCII 13 and 10, respectively). Implementers who wish to maintain compatibility with older, undocumented versions of this protocol may want to process the identification string without expecting the presence of the carriage return character for reasons described in Section 5 of this document. The null character MUST NOT be sent. The maximum length of the string is 255 characters, including the Carriage Return and Line Feed.",
      "ja": "文書のこのセットに定義されたプロトコルがバージョン2.0であるため、「PROTOVERSION」が「2.0」でなければなりません。コメント 'という文字列はオプションです。コメント 'という文字列が含まれている場合は、（SP、ASCII 32として上記表記）「スペース」文字は、「softwareversion」と「コメント」の文字列を区切る必要があります。識別は、単一のキャリッジリターン（CR）と単一ラインフィード（LF）文字（ASCII、それぞれ13及び10）によって終了されなければなりません。このプロトコルの古い、文書化されていないバージョンとの互換性を維持したい実装者は、本書の第5章で説明した理由のために復帰文字の存在を期待せずに識別文字列を処理することもできます。ヌル文字を送ってはいけません。文字列の最大長は、キャリッジリターンとラインフィードを含めて255文字です。"
    },
    {
      "indent": 3,
      "text": "The part of the identification string preceding the Carriage Return and Line Feed is used in the Diffie-Hellman key exchange (see Section 8).",
      "ja": "キャリッジリターンの前に識別文字列と改行の一部は（セクション8を参照）のDiffie-Hellman鍵交換に使用されます。"
    },
    {
      "indent": 3,
      "text": "The server MAY send other lines of data before sending the version string. Each line SHOULD be terminated by a Carriage Return and Line Feed. Such lines MUST NOT begin with \"SSH-\", and SHOULD be encoded in ISO-10646 UTF-8 [RFC3629] (language is not specified). Clients MUST be able to process such lines. Such lines MAY be silently ignored, or MAY be displayed to the client user. If they are displayed, control character filtering, as discussed in [SSH-ARCH], SHOULD be used. The primary use of this feature is to allow TCP-wrappers to display an error message before disconnecting.",
      "ja": "サーバーは、バージョン文字列を送信する前に、データの他の線を送信することができます。各行はキャリッジリターンとラインフィードで終了する必要があります。そのような線は「SSH-」で始めてはいけません、そしてISO-10646 UTF-8 [RFC3629]（言語が指定されていない）で符号化されるべきです。クライアントは、このような行を処理できなければなりません。このような行は黙って無視されてもよいし、クライアントのユーザに表示することができます。それらが表示されている場合、制御文字フィルタリングは、[SSH-ARCH]で説明したように、使用されるべきです。この機能の主な用途は、TCP-ラッパーを切断する前にエラーメッセージを表示できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "Both the 'protoversion' and 'softwareversion' strings MUST consist of printable US-ASCII characters, with the exception of whitespace characters and the minus sign (-). The 'softwareversion' string is primarily used to trigger compatibility extensions and to indicate the capabilities of an implementation. The 'comments' string SHOULD contain additional information that might be useful in solving user problems. As such, an example of a valid identification string is",
      "ja": "（ - ）「PROTOVERSION」と「softwareversion」の文字列の両方が空白文字の例外とマイナス記号で、印刷可能なUS-ASCII文字で構成する必要があります。 「softwareversion」文字列は、主に互換性の拡張をトリガすると、実装の機能を示すために使用されます。コメント \"文字列は、ユーザーの問題を解決するのに有用である可能性がある追加の情報が含まれているはずです。このように、有効な身分証明書文字列の例であります"
    },
    {
      "indent": 6,
      "text": "SSH-2.0-billsSSH_3.6.3q3<CR><LF>",
      "ja": "SSH-2.0-billsSSH_3.6.3q3 <CR> <LF>"
    },
    {
      "indent": 3,
      "text": "This identification string does not contain the optional 'comments' string and is thus terminated by a CR and LF immediately after the 'softwareversion' string.",
      "ja": "この識別文字列は、オプションの「コメント」の文字列が含まれていませんので、すぐに「softwareversion」という文字列の後にCRとLFで終了します。"
    },
    {
      "indent": 3,
      "text": "Key exchange will begin immediately after sending this identifier. All packets following the identification string SHALL use the binary packet protocol, which is described in Section 6.",
      "ja": "鍵の交換は、この識別子を送信した直後に開始されます。識別文字列以下のすべてのパケットは、セクション6に記載されているバイナリ・パケット・プロトコルを使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. Compatibility With Old SSH Versions",
      "section_title": true,
      "ja": "古いSSHバージョンとの互換性5."
    },
    {
      "indent": 3,
      "text": "As stated earlier, the 'protoversion' specified for this protocol is \"2.0\". Earlier versions of this protocol have not been formally documented, but it is widely known that they use 'protoversion' of \"1.x\" (e.g., \"1.5\" or \"1.3\"). At the time of this writing, many implementations of SSH are utilizing protocol version 2.0, but it is known that there are still devices using the previous versions. During the transition period, it is important to be able to work in a way that is compatible with the installed SSH clients and servers that use the older version of the protocol. Information in this section is only relevant for implementations supporting compatibility with SSH versions 1.x. For those interested, the only known documentation of the 1.x protocol is contained in README files that are shipped along with the source code [ssh-1.2.30].",
      "ja": "先に述べたように、このプロトコルのために指定された「PROTOVERSION」が「2.0」です。このプロトコルの以前のバージョンでは、正式に文書化されていないが、広く、彼らが「1.1」（例えば、「1.5」や「1.3」）の「PROTOVERSION」を使用することが知られています。この記事の執筆時点では、SSHの多くの実装は、プロトコルのバージョン2.0を利用しているが、以前のバージョンを使用しているデバイスがまだ存在することが知られています。移行期間中には、プロトコルの古いバージョンを使用してインストールSSHクライアントとサーバとの互換性のある方法で働くことができることが重要です。このセクションの情報は、SSHバージョン1.xの互換性をサポートする実装にのみ関連しこれらの興味のために、1.xのプロトコルの唯一知られている文書は、ソースコード[SSH-1.2.30]と一緒に出荷されるREADMEファイルに含まれています。"
    },
    {
      "indent": 0,
      "text": "5.1. Old Client, New Server",
      "section_title": true,
      "ja": "5.1. 旧クライアント、新規サーバー"
    },
    {
      "indent": 3,
      "text": "Server implementations MAY support a configurable compatibility flag that enables compatibility with old versions. When this flag is on, the server SHOULD identify its 'protoversion' as \"1.99\". Clients using protocol 2.0 MUST be able to identify this as identical to \"2.0\". In this mode, the server SHOULD NOT send the Carriage Return character (ASCII 13) after the identification string.",
      "ja": "サーバ実装は、旧バージョンとの互換性を可能にし、設定の互換性フラグをサポートするかもしれません。このフラグがオンの場合、サーバーは「1.99」とその「PROTOVERSION」を識別する必要があります。プロトコル2.0を使用するクライアントは、「2.0」と同じように、これを識別できなければなりません。このモードでは、サーバーは、識別文字列の後にキャリッジリターン文字（ASCII 13）を送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "In the compatibility mode, the server SHOULD NOT send any further data after sending its identification string until it has received an identification string from the client. The server can then determine whether the client is using an old protocol, and can revert to the old protocol if required. In the compatibility mode, the server MUST NOT send additional data before the identification string.",
      "ja": "互換モードでは、サーバはクライアントからの識別文字列を受信するまで、その識別文字列を送信した後、任意のさらなるデータを送るべきではありません。その後、サーバーは、クライアントが古いプロトコルを使用しているかどうかを決定することができ、必要に応じて古いプロトコルに戻すことができます。互換モードでは、サーバーは、識別文字列の前に追加のデータを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "When compatibility with old clients is not needed, the server MAY send its initial key exchange data immediately after the identification string.",
      "ja": "古いクライアントとの互換性が必要とされていない場合は、サーバーは、識別文字列の直後にその最初の鍵交換データを送信することができます。"
    },
    {
      "indent": 0,
      "text": "5.2. New Client, Old Server",
      "section_title": true,
      "ja": "5.2. 新しいクライアント、古いサーバ"
    },
    {
      "indent": 3,
      "text": "Since the new client MAY immediately send additional data after its identification string (before receiving the server's identification string), the old protocol may already be corrupt when the client learns that the server is old. When this happens, the client SHOULD close the connection to the server, and reconnect using the old protocol.",
      "ja": "新しいクライアントがすぐに（サーバーの識別文字列を受信する前に）その識別文字列の後に追加データを送信する可能性があるため、クライアントは、サーバが古いことを知ったとき、古いプロトコルはすでに壊れている可能性があります。このような場合、クライアントは、サーバーへの接続をクローズし、古いプロトコルを使用して再接続する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Packet Size and Overhead",
      "section_title": true,
      "ja": "5.3. パケットサイズとオーバーヘッド"
    },
    {
      "indent": 3,
      "text": "Some readers will worry about the increase in packet size due to new headers, padding, and the Message Authentication Code (MAC). The minimum packet size is in the order of 28 bytes (depending on negotiated algorithms). The increase is negligible for large packets, but very significant for one-byte packets (telnet-type sessions). There are, however, several factors that make this a non-issue in almost all cases:",
      "ja": "一部の読者は、新たなヘッダ、パディングによるパケットサイズの増加、およびメッセージ認証コード（MAC）を心配します。最小パケットサイズは28バイト（交渉されたアルゴリズムに依存する）のオーダーです。増加は大きなパケットのために無視できないが、1バイトのパケット（telnetの型セッション）のために非常に重要です。ほとんどの場合、この非問題にするいくつかの要因は、しかし、があります。"
    },
    {
      "indent": 3,
      "text": "o The minimum size of a TCP/IP header is 32 bytes. Thus, the increase is actually from 33 to 51 bytes (roughly).",
      "ja": "O TCP / IPヘッダの最小サイズは32バイトです。したがって、増加は33〜51バイト（約）から実際にあります。"
    },
    {
      "indent": 3,
      "text": "o The minimum size of the data field of an Ethernet packet is 46 bytes [RFC0894]. Thus, the increase is no more than 5 bytes. When Ethernet headers are considered, the increase is less than 10 percent.",
      "ja": "oをイーサネットパケットのデータフィールドの最小サイズは46バイト[RFC0894]です。したがって、増加は5バイト以下です。イーサネットヘッダを考慮すると、増加が10％未満です。"
    },
    {
      "indent": 3,
      "text": "o The total fraction of telnet-type data in the Internet is negligible, even with increased packet sizes.",
      "ja": "インターネットでのtelnet型データの合計の割合が増加さえパケットサイズと、無視できるO。"
    },
    {
      "indent": 3,
      "text": "The only environment where the packet size increase is likely to have a significant effect is PPP [RFC1661] over slow modem lines (PPP compresses the TCP/IP headers, emphasizing the increase in packet size). However, with modern modems, the time needed to transfer is in the order of 2 milliseconds, which is a lot faster than people can type.",
      "ja": "パケットサイズの増加が大きな影響を与える可能性がある唯一の環境は（PPPはパケットサイズの増加を強調し、TCP / IPヘッダを圧縮し）、低速モデム回線を介してPPP [RFC1661]です。しかし、現代のモデムで、転送するのに必要な時間は、人々が入力することができるよりもはるかに高速で2ミリ秒のオーダーです。"
    },
    {
      "indent": 3,
      "text": "There are also issues related to the maximum packet size. To minimize delays in screen updates, one does not want excessively large packets for interactive sessions. The maximum packet size is negotiated separately for each channel.",
      "ja": "最大パケットサイズに関連する問題もあります。画面更新の遅延を最小限に抑えるためには、対話型セッションのために過大​​なパケットを望んでいません。最大パケットサイズは、各チャネルに対して別々にネゴシエートされます。"
    },
    {
      "indent": 0,
      "text": "6. Binary Packet Protocol",
      "section_title": true,
      "ja": "6.バイナリパケットプロトコル"
    },
    {
      "indent": 3,
      "text": "Each packet is in the following format:",
      "ja": "各パケットの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "uint32 packet_length byte padding_length byte[n1] payload; n1 = packet_length - padding_length - 1 byte[n2] random padding; n2 = padding_length byte[m] mac (Message Authentication Code - MAC); m = mac_length",
      "ja": "UINT32 packet_lengthバイトするpadding_lengthバイト[N1]ペイロード。 N1 = packet_length  - するpadding_length  -  1バイト[N2]ランダムパディング。 N2 =するpadding_lengthバイト[m]は、MAC（メッセージ認証コード -  MAC）。 M = mac_length"
    },
    {
      "indent": 6,
      "text": "packet_length The length of the packet in bytes, not including 'mac' or the 'packet_length' field itself.",
      "ja": "「MAC」または「packet_length」フィールド自体を含まない、バイト数でパケットの長さをpacket_length。"
    },
    {
      "indent": 6,
      "text": "padding_length Length of 'random padding' (bytes).",
      "ja": "「ランダムパディング」（バイト）のするpadding_lengthの長さ。"
    },
    {
      "indent": 6,
      "text": "payload The useful contents of the packet. If compression has been negotiated, this field is compressed. Initially, compression MUST be \"none\".",
      "ja": "パケットの有益な内容をペイロード。圧縮が交渉されている場合、このフィールドは圧縮されています。最初は、圧縮は「なし」である必要があります。"
    },
    {
      "indent": 6,
      "text": "random padding Arbitrary-length padding, such that the total length of (packet_length || padding_length || payload || random padding) is a multiple of the cipher block size or 8, whichever is larger. There MUST be at least four bytes of padding. The padding SHOULD consist of random bytes. The maximum amount of padding is 255 bytes.",
      "ja": "（packet_length || ||するpadding_lengthペイロード||ランダムパディング）の全長が大きい方の暗号ブロックサイズまたは8の倍数になるようにランダムパディング任意の長さのパディング。パディングの少なくとも4つのバイトがあるに違いありません。パディングは、ランダムなバイトで構成する必要があります。パディングの最大量は255バイトです。"
    },
    {
      "indent": 6,
      "text": "mac Message Authentication Code. If message authentication has been negotiated, this field contains the MAC bytes. Initially, the MAC algorithm MUST be \"none\".",
      "ja": "MACメッセージ認証コード。メッセージ認証がネゴシエートされている場合、このフィールドは、MACバイトが含まれています。最初は、MACアルゴリズムは、「なし」である必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the length of the concatenation of 'packet_length', 'padding_length', 'payload', and 'random padding' MUST be a multiple of the cipher block size or 8, whichever is larger. This constraint MUST be enforced, even when using stream ciphers. Note that the 'packet_length' field is also encrypted, and processing it requires special care when sending or receiving packets. Also note that the insertion of variable amounts of 'random padding' may help thwart traffic analysis.",
      "ja": "「packet_length」、「するpadding_length」、「ペイロード」、及び「ランダムパディング」の連結の長さが大きい方の暗号ブロックサイズ又は8の倍数でなければならないことに留意されたいです。この制約は、ストリーム暗号を用いた場合でも、実施されなければなりません。 「packet_length」フィールドも暗号化されていることに注意してください、そして、パケットを送信または受信したときに、それを処理することは、特別な注意が必要です。また、「ランダムパディング」の可変量の挿入は、トラフィック分析を妨害助けるかもしれないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The minimum size of a packet is 16 (or the cipher block size, whichever is larger) bytes (plus 'mac'). Implementations SHOULD decrypt the length after receiving the first 8 (or cipher block size, whichever is larger) bytes of a packet.",
      "ja": "パケットの最小サイズは16である（又は大きい方の暗号ブロックサイズは、）バイト（プラス「MAC」）。実装は、パケットのバイトの最初の8（いずれか大きい方又は暗号ブロックサイズを、）受信した後、長さを復号化するべきです。"
    },
    {
      "indent": 0,
      "text": "6.1. Maximum Packet Length",
      "section_title": true,
      "ja": "6.1. 最大パケット長"
    },
    {
      "indent": 3,
      "text": "All implementations MUST be able to process packets with an uncompressed payload length of 32768 bytes or less and a total packet size of 35000 bytes or less (including 'packet_length', 'padding_length', 'payload', 'random padding', and 'mac'). The maximum of 35000 bytes is an arbitrarily chosen value that is larger than the uncompressed length noted above. Implementations SHOULD support longer packets, where they might be needed. For example, if an implementation wants to send a very large number of certificates, the larger packets MAY be sent if the identification string indicates that the other party is able to process them. However, implementations SHOULD check that the packet length is reasonable in order for the implementation to avoid denial of service and/or buffer overflow attacks.",
      "ja": "すべての実装は、32768バイト以下の非圧縮のペイロード長と（「packet_length」、「するpadding_length」、「ペイロード」、「ランダムパディング」、及び「MACなど35000バイト以下の総パケットサイズのパケットを処理できなければなりません「）。 35000バイトの最大値は、上記圧縮されていない長さよりも大きい任意に選択された値です。実装は、彼らが必要になる可能性がある長いパケットを、サポートすべきです。実装は、証明書の非常に大きな数を送信したい場合には識別文字列は、他の当事者がそれを処理することが可能であることを示した場合、より大きなパケットが送信されるかもしれません。しかし、実装はパケット長は、実装は、サービスの拒否を回避及び/又はオーバーフロー攻撃をバッファリングするために妥当であることを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Compression",
      "section_title": true,
      "ja": "6.2. 圧縮"
    },
    {
      "indent": 3,
      "text": "If compression has been negotiated, the 'payload' field (and only it) will be compressed using the negotiated algorithm. The 'packet_length' field and 'mac' will be computed from the compressed payload. Encryption will be done after compression.",
      "ja": "圧縮が交渉されている場合は、「ペイロード」フィールド（とのみ、それは）交渉されたアルゴリズムを使用して圧縮されます。 「packet_length」フィールド及び「MAC」が圧縮されたペイロードから計算されます。暗号化は、圧縮後に行われます。"
    },
    {
      "indent": 3,
      "text": "Compression MAY be stateful, depending on the method. Compression MUST be independent for each direction, and implementations MUST allow independent choosing of the algorithm for each direction. In practice however, it is RECOMMENDED that the compression method be the same in both directions.",
      "ja": "圧縮は、方法によっては、ステートフルかもしれ。圧縮は、各方向に対して独立していなければならない、および実装は、各方向のためのアルゴリズムとは独立して選んを可能にしなければなりません。しかし実際には、圧縮方法が両方向で同じであることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "The following compression methods are currently defined:",
      "ja": "次の圧縮方法は、現在定義されています。"
    },
    {
      "indent": 6,
      "text": "none REQUIRED no compression zlib OPTIONAL ZLIB (LZ77) compression",
      "ja": "noneは、圧縮はzlibオプションZLIB（LZ77）圧縮を必要としません"
    },
    {
      "indent": 3,
      "text": "The \"zlib\" compression is described in [RFC1950] and in [RFC1951]. The compression context is initialized after each key exchange, and is passed from one packet to the next, with only a partial flush being performed at the end of each packet. A partial flush means that the current compressed block is ended and all data will be output. If the current block is not a stored block, one or more empty blocks are added after the current block to ensure that there are at least 8 bits, counting from the start of the end-of-block code of the current block to the end of the packet payload.",
      "ja": "\"ZLIB\" 圧縮が[RFC1950]及び[RFC1951]に記載されています。圧縮コンテキストは、各キーの交換後に初期化され、そして部分的にしかフラッシュが各パケットの終わりに実行されると、次に一つのパケットから渡されます。部分的なフラッシュは、現在の圧縮ブロックが終了すると、すべてのデータが出力されることを意味します。現在のブロックが格納されたブロックでない場合、一個の以上の空のブロックが現在のブロックの終わりのブロックコードの開始から終了まで数え、少なくとも8ビットが存在することを保証するために、現在のブロックの後に追加されていますパケットペイロードの。"
    },
    {
      "indent": 3,
      "text": "Additional methods may be defined as specified in [SSH-ARCH] and [SSH-NUMBERS].",
      "ja": "[SSH-ARCH]および[SSH-NUMBERS]で指定されるように、追加の方法が定義されてもよいです。"
    },
    {
      "indent": 0,
      "text": "6.3. Encryption",
      "section_title": true,
      "ja": "6.3. 暗号化"
    },
    {
      "indent": 3,
      "text": "An encryption algorithm and a key will be negotiated during the key exchange. When encryption is in effect, the packet length, padding length, payload, and padding fields of each packet MUST be encrypted with the given algorithm.",
      "ja": "暗号化アルゴリズムとキーは、キー交換中にネゴシエートされます。暗号化が有効である場合、パケット長、パディング長、ペイロード、及び各パケットのパディングフィールドは、与えられたアルゴリズムで暗号化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The encrypted data in all packets sent in one direction SHOULD be considered a single data stream. For example, initialization vectors SHOULD be passed from the end of one packet to the beginning of the next packet. All ciphers SHOULD use keys with an effective key length of 128 bits or more.",
      "ja": "一方向に送信されるすべてのパケットで暗号化されたデータは、単一のデータストリームを考慮すべきです。例えば、初期化ベクトルは、次のパケットの先頭に1つのパケットの端から渡す必要があります。すべての暗号は128ビット以上の有効な鍵長を持つ鍵を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "The ciphers in each direction MUST run independently of each other. Implementations MUST allow the algorithm for each direction to be independently selected, if multiple algorithms are allowed by local policy. In practice however, it is RECOMMENDED that the same algorithm be used in both directions.",
      "ja": "各方向での暗号は、互いに独立して実行する必要があります。実装は、複数のアルゴリズムがローカルポリシーによって許可されている場合、各方向のためのアルゴリズムは、独立して、選択されることを可能にしなければなりません。しかし実際には、同じアルゴリズムが両方向に使用することを推奨されています。"
    },
    {
      "indent": 3,
      "text": "The following ciphers are currently defined:",
      "ja": "以下の暗号は、現在定義されています。"
    },
    {
      "indent": 6,
      "text": "3des-cbc REQUIRED three-key 3DES in CBC mode blowfish-cbc OPTIONAL Blowfish in CBC mode twofish256-cbc OPTIONAL Twofish in CBC mode, with a 256-bit key twofish-cbc OPTIONAL alias for \"twofish256-cbc\" (this is being retained for historical reasons) twofish192-cbc OPTIONAL Twofish with a 192-bit key twofish128-cbc OPTIONAL Twofish with a 128-bit key aes256-cbc OPTIONAL AES in CBC mode, with a 256-bit key aes192-cbc OPTIONAL AES with a 192-bit key aes128-cbc RECOMMENDED AES with a 128-bit key serpent256-cbc OPTIONAL Serpent in CBC mode, with a 256-bit key serpent192-cbc OPTIONAL Serpent with a 192-bit key serpent128-cbc OPTIONAL Serpent with a 128-bit key arcfour OPTIONAL the ARCFOUR stream cipher with a 128-bit key idea-cbc OPTIONAL IDEA in CBC mode cast128-cbc OPTIONAL CAST-128 in CBC mode none OPTIONAL no encryption; NOT RECOMMENDED",
      "ja": "3DES-CBC CBCモードでCBCモードtwofish256-CBC OPTIONAL TwofishはでCBCモードふぐ-CBC OPTIONALフグに必要な3つのキー3DES、 \"twofish256-CBC\" の256ビット鍵twofishです-CBC OPTIONALエイリアスと（これは保持されています192と256ビットのキーAES192-CBC OPTIONAL AES 128ビット鍵AES256-CBC OPTIONAL AES CBCモード192ビット鍵twofish128-CBC OPTIONAL Twofishはとの歴史的な理由により）twofish192-CBC OPTIONAL Twofishは、用ビットキーAES128-CBC推奨AES CBCモードでは、128ビットの鍵serpent256-CBC OPTIONAL蛇と、128ビットの鍵を使用して192ビットの鍵serpent128-CBC OPTIONAL蛇256ビット鍵serpent192-CBC OPTIONAL蛇とOPTIONAL ARCFOUR CBCモードCAST128-CBC OPTIONAL CAST-128で128ビットのキー考え-CBC OPTIONALアイデアをARCFOURストリーム暗号CBCモードなしオプション暗号化なしで。推奨しません"
    },
    {
      "indent": 3,
      "text": "The \"3des-cbc\" cipher is three-key triple-DES (encrypt-decrypt-encrypt), where the first 8 bytes of the key are used for the first encryption, the next 8 bytes for the decryption, and the following 8 bytes for the final encryption. This requires 24 bytes of key data (of which 168 bits are actually used). To implement CBC mode, outer chaining MUST be used (i.e., there is only one initialization vector). This is a block cipher with 8-byte blocks. This algorithm is defined in [FIPS-46-3]. Note that since this algorithm only has an effective key length of 112 bits ([SCHNEIER]), it does not meet the specifications that SSH encryption algorithms should use keys of 128 bits or more. However, this algorithm is still REQUIRED for historical reasons; essentially, all known implementations at the time of this writing support this algorithm, and it is commonly used because it is the fundamental interoperable algorithm. At some future time, it is expected that another algorithm, one with better strength, will become so prevalent and ubiquitous that the use of \"3des-cbc\" will be deprecated by another STANDARDS ACTION.",
      "ja": "「3DES-CBC」暗号キーの最初の8つのバイトは、最初の暗号化に使用される3つのキーのトリプルDES（暗号化、復号化、暗号化）、復号化のための次の8バイト、次の8バイトであります最後の暗号化のために。これは、（168ビットが実際に使用された）鍵データの24バイトを必要とします。 CBCモードを実現するために、外側の連鎖（すなわち、唯一の初期化ベクトルがある）を使用しなければなりません。これは8バイトのブロックとブロック暗号です。このアルゴリズムは[FIPS-46-3]で定義されています。このアルゴリズムは唯一112ビット（[SCHNEIER]）の有効なキーの長さを有しているので、それはSSH暗号化アルゴリズムは、128ビット以上のキーを使用する必要が仕様を満たしていないことに留意されたいです。しかし、このアルゴリズムは、まだ歴史的な理由のために必要です。基本的に、すべてこの書き込みサポートこのアルゴリズムの時点で実装が知られており、それが基本的な相互運用可能なアルゴリズムであるため、それは一般的に使用されます。一部の将来の時点で、別のアルゴリズム、優れた強度を持つ1は、「3DES-CBC」の使用は、他の規格のACTIONによって廃止されますように普及し、広く普及することが予想されます。"
    },
    {
      "indent": 3,
      "text": "The \"blowfish-cbc\" cipher is Blowfish in CBC mode, with 128-bit keys [SCHNEIER]. This is a block cipher with 8-byte blocks.",
      "ja": "「ふぐ-CBC」暗号は128ビット鍵[SCHNEIER]と、CBCモードのフグです。これは8バイトのブロックとブロック暗号です。"
    },
    {
      "indent": 3,
      "text": "The \"twofish-cbc\" or \"twofish256-cbc\" cipher is Twofish in CBC mode, with 256-bit keys as described [TWOFISH]. This is a block cipher with 16-byte blocks.",
      "ja": "[Twofishは】記載されているように、 \"twofishです-CBC\" または \"twofish256-CBC\" 暗号は256ビット鍵と、CBCモードでTwofishはあります。これは、16バイトのブロックとブロック暗号です。"
    },
    {
      "indent": 3,
      "text": "The \"twofish192-cbc\" cipher is the same as above, but with a 192-bit key.",
      "ja": "「twofish192-CBC」暗号は上記と同様であるが、192ビットの鍵です。"
    },
    {
      "indent": 3,
      "text": "The \"twofish128-cbc\" cipher is the same as above, but with a 128-bit key.",
      "ja": "「twofish128-CBC」暗号は上記と同様であるが、128ビットの鍵です。"
    },
    {
      "indent": 3,
      "text": "The \"aes256-cbc\" cipher is AES (Advanced Encryption Standard) [FIPS-197], in CBC mode. This version uses a 256-bit key.",
      "ja": "\"AES256-CBC\" 暗号は、AES（Advanced Encryption Standard）[FIPS-197]、CBCモードです。このバージョンでは、256ビットの鍵を使用しています。"
    },
    {
      "indent": 3,
      "text": "The \"aes192-cbc\" cipher is the same as above, but with a 192-bit key.",
      "ja": "「AES192-CBC」暗号は上記と同様であるが、192ビットの鍵です。"
    },
    {
      "indent": 3,
      "text": "The \"aes128-cbc\" cipher is the same as above, but with a 128-bit key.",
      "ja": "「AES128-CBC」暗号は上記と同様であるが、128ビットの鍵です。"
    },
    {
      "indent": 3,
      "text": "The \"serpent256-cbc\" cipher in CBC mode, with a 256-bit key as described in the Serpent AES submission.",
      "ja": "蛇AESの提出で説明したように、256ビットのキーでCBCモードで「serpent256-CBC」暗号、。"
    },
    {
      "indent": 3,
      "text": "The \"serpent192-cbc\" cipher is the same as above, but with a 192-bit key.",
      "ja": "「serpent192-CBC」暗号は上記と同様であるが、192ビットの鍵です。"
    },
    {
      "indent": 3,
      "text": "The \"serpent128-cbc\" cipher is the same as above, but with a 128-bit key.",
      "ja": "「serpent128-CBC」暗号は上記と同様であるが、128ビットの鍵です。"
    },
    {
      "indent": 3,
      "text": "The \"arcfour\" cipher is the Arcfour stream cipher with 128-bit keys. The Arcfour cipher is believed to be compatible with the RC4 cipher [SCHNEIER]. Arcfour (and RC4) has problems with weak keys, and should be used with caution.",
      "ja": "「ARCFOUR」暗号は128ビットキーを使用してたArcfourのストリーム暗号です。たArcfour暗号は、RC4暗号[SCHNEIER]と互換性があると考えられています。 ARCFOUR（およびRC4）は弱いキーに問題があり、注意して使用すべきです。"
    },
    {
      "indent": 3,
      "text": "The \"idea-cbc\" cipher is the IDEA cipher in CBC mode [SCHNEIER].",
      "ja": "\"アイデア-CBC\" 暗号はCBCモード[SCHNEIER]でIDEA暗号です。"
    },
    {
      "indent": 3,
      "text": "The \"cast128-cbc\" cipher is the CAST-128 cipher in CBC mode with a 128-bit key [RFC2144].",
      "ja": "\"CAST128-CBC\" 暗号は128ビットの鍵[RFC2144]を用いてCBCモードでCAST-128暗号です。"
    },
    {
      "indent": 3,
      "text": "The \"none\" algorithm specifies that no encryption is to be done. Note that this method provides no confidentiality protection, and it is NOT RECOMMENDED. Some functionality (e.g., password authentication) may be disabled for security reasons if this cipher is chosen.",
      "ja": "「なし」アルゴリズムには暗号化が行われるべきでないことを指定します。このメソッドは機密性保護を提供しないことに注意してください、そして、それは推奨されません。この暗号が選択されている場合、一部の機能（例えば、パスワード認証）は、セキュリティ上の理由で無効にすることができます。"
    },
    {
      "indent": 3,
      "text": "Additional methods may be defined as specified in [SSH-ARCH] and in [SSH-NUMBERS].",
      "ja": "[SSH-ARCH]および[SSH-NUMBERS]で指定されるように、追加の方法が定義されてもよいです。"
    },
    {
      "indent": 0,
      "text": "6.4. Data Integrity",
      "section_title": true,
      "ja": "6.4. データの整合性"
    },
    {
      "indent": 3,
      "text": "Data integrity is protected by including with each packet a MAC that is computed from a shared secret, packet sequence number, and the contents of the packet.",
      "ja": "データの整合性を共有シークレットから計算される各パケットMAC、パケットシーケンス番号、およびパケットの内容を含むによって保護されています。"
    },
    {
      "indent": 3,
      "text": "The message authentication algorithm and key are negotiated during key exchange. Initially, no MAC will be in effect, and its length MUST be zero. After key exchange, the 'mac' for the selected MAC algorithm will be computed before encryption from the concatenation of packet data:",
      "ja": "メッセージ認証アルゴリズムと鍵は、鍵交換の間で交渉されています。最初は、MACは有効になりません、その長さはゼロでなければなりません。鍵交換の後、選択されたMACアルゴリズムのための「MAC」は、パケットデータの連結から、暗号化の前に計算されます。"
    },
    {
      "indent": 6,
      "text": "mac = MAC(key, sequence_number || unencrypted_packet)",
      "ja": "MAC = MAC（キー、SEQUENCE_NUMBER || unencrypted_pa​​cket）"
    },
    {
      "indent": 3,
      "text": "where unencrypted_packet is the entire packet without 'mac' (the length fields, 'payload' and 'random padding'), and sequence_number is an implicit packet sequence number represented as uint32. The sequence_number is initialized to zero for the first packet, and is incremented after every packet (regardless of whether encryption or MAC is in use). It is never reset, even if keys/algorithms are renegotiated later. It wraps around to zero after every 2^32 packets. The packet sequence_number itself is not included in the packet sent over the wire.",
      "ja": "unencrypted_pa​​cketは「MAC」（長さフィールド、「ペイロード」と「ランダムパディング」）なしのパケット全体であり、SEQUENCE_NUMBERはUINT32として表さ暗黙のパケットシーケンス番号です。 SEQUENCE_NUMBERは、最初のパケットのためにゼロに初期化され、（関係なく、暗号化やMACが使用されているかどうかの）パケットごとにインクリメントされます。キー/アルゴリズムが、後に再交渉されている場合でも、リセットされることはありません。これは、すべての2 ^ 32パケット後にゼロにラップアラウンド。パケットSEQUENCE_NUMBER自体は、ワイヤを介して送信されるパケットに含まれていません。"
    },
    {
      "indent": 3,
      "text": "The MAC algorithms for each direction MUST run independently, and implementations MUST allow choosing the algorithm independently for both directions. In practice however, it is RECOMMENDED that the same algorithm be used in both directions.",
      "ja": "各方向のためのMACアルゴリズムは、独立して実行する必要があり、かつ実装が両方の方向について独立にアルゴリズムを選択できるようにしなければなりません。しかし実際には、同じアルゴリズムが両方向に使用することを推奨されています。"
    },
    {
      "indent": 3,
      "text": "The value of 'mac' resulting from the MAC algorithm MUST be transmitted without encryption as the last part of the packet. The number of 'mac' bytes depends on the algorithm chosen.",
      "ja": "MACアルゴリズムに起因「MAC」の値は、パケットの最後の部分として暗号化なしで送信されなければなりません。 「マック」のバイト数は、選択されたアルゴリズムに依存します。"
    },
    {
      "indent": 3,
      "text": "The following MAC algorithms are currently defined:",
      "ja": "次MACアルゴリズムは、現在定義されています。"
    },
    {
      "indent": 6,
      "text": "hmac-sha1 REQUIRED HMAC-SHA1 (digest length = key length = 20) hmac-sha1-96 RECOMMENDED first 96 bits of HMAC-SHA1 (digest length = 12, key length = 20) hmac-md5 OPTIONAL HMAC-MD5 (digest length = key length = 16) hmac-md5-96 OPTIONAL first 96 bits of HMAC-MD5 (digest length = 12, key length = 16) none OPTIONAL no MAC; NOT RECOMMENDED",
      "ja": "HMAC-SHA1のREQUIRED HMAC-SHA1は、HMAC-SHA1（長さを消化=キー長= 20）HMAC-SHA1-96推奨最初の96ビット（ダイジェスト長= 12、鍵長= 20）HMAC-MD5 OPTIONAL HMAC-MD5（長ダイジェスト= HMAC-MD5のキー長= 16）HMAC-MD5-96 OPTIONAL最初の96ビットは（ダイジェスト長さ= 12、キー長= 16）なしなしMAC OPTIONAL。推奨しません"
    },
    {
      "indent": 3,
      "text": "The \"hmac-*\" algorithms are described in [RFC2104]. The \"*-n\" MACs use only the first n bits of the resulting value.",
      "ja": "「HMAC-*」アルゴリズムは[RFC2104]に記載されています。 「* -n」MACは、得られた値の最初のnビットを使用します。"
    },
    {
      "indent": 3,
      "text": "SHA-1 is described in [FIPS-180-2] and MD5 is described in [RFC1321].",
      "ja": "SHA-1は、[FIPS-180-2]に記載されており、MD5は、[RFC1321]に記載されています。"
    },
    {
      "indent": 3,
      "text": "Additional methods may be defined, as specified in [SSH-ARCH] and in [SSH-NUMBERS].",
      "ja": "[SSH-ARCH]および[SSH-NUMBERS]で指定されるように、追加の方法が、定義されてもよいです。"
    },
    {
      "indent": 0,
      "text": "6.5. Key Exchange Methods",
      "section_title": true,
      "ja": "6.5. キー交換方法"
    },
    {
      "indent": 3,
      "text": "The key exchange method specifies how one-time session keys are generated for encryption and for authentication, and how the server authentication is done.",
      "ja": "鍵交換方式は、1回のセッションキーを暗号化するために、認証のために生成される方法、およびサーバー認証がどのように行われるかを指定します。"
    },
    {
      "indent": 3,
      "text": "Two REQUIRED key exchange methods have been defined:",
      "ja": "2つの必要な鍵交換方法が定義されています。"
    },
    {
      "indent": 6,
      "text": "diffie-hellman-group1-sha1 REQUIRED diffie-hellman-group14-sha1 REQUIRED",
      "ja": "ディフィー・ヘルマン-GROUP1-SHA1 REQUIREDディフィー・ヘルマン-group14-SHA1は必須"
    },
    {
      "indent": 3,
      "text": "These methods are described in Section 8.",
      "ja": "これらのメソッドは、セクション8に記載されています。"
    },
    {
      "indent": 3,
      "text": "Additional methods may be defined as specified in [SSH-NUMBERS]. The name \"diffie-hellman-group1-sha1\" is used for a key exchange method using an Oakley group, as defined in [RFC2409]. SSH maintains its own group identifier space that is logically distinct from Oakley [RFC2412] and IKE; however, for one additional group, the Working Group adopted the number assigned by [RFC3526], using diffie-hellman-group14-sha1 for the name of the second defined group. Implementations should treat these names as opaque identifiers and should not assume any relationship between the groups used by SSH and the groups defined for IKE.",
      "ja": "[SSH-NUMBERS]で指定されるように、追加の方法が定義されてもよいです。名称「ディフィー・ヘルマン-GROUP1-SHA1」[RFC2409]で定義されるように、オークリー基を使用して鍵交換法のために使用されます。 SSHはオークリー[RFC2412]とIKEから論理的に区別される独自のグループ識別子空間を維持します。しかし、一つの追加のグループに対して、ワーキンググループは、第定義されたグループ名のディフィー - ヘルマン-group14-SHA1を使用して、[RFC3526]によって割り当てられた番号を採用しました。実装は、不透明な識別子としてこれらの名前を扱う必要がありますし、SSHで使用するグループとIKEのために定義されたグループ間のすべての関係を仮定するべきではありません。"
    },
    {
      "indent": 0,
      "text": "6.6. Public Key Algorithms",
      "section_title": true,
      "ja": "6.6. 公開鍵アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This protocol has been designed to operate with almost any public key format, encoding, and algorithm (signature and/or encryption).",
      "ja": "このプロトコルは、ほとんどすべての公開鍵フォーマット、符号化、およびアルゴリズム（署名及び/又は暗号化）で動作するように設計されています。"
    },
    {
      "indent": 3,
      "text": "There are several aspects that define a public key type:",
      "ja": "公開鍵のタイプを定義するいくつかの側面があります。"
    },
    {
      "indent": 3,
      "text": "o Key format: how is the key encoded and how are certificates represented. The key blobs in this protocol MAY contain certificates in addition to keys.",
      "ja": "Oキーフォーマット：どのように鍵が符号化され、そしてどのように証明書が表現されています。このプロトコルの重要な塊は、キーに加えて、証明書を含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "o Signature and/or encryption algorithms. Some key types may not support both signing and encryption. Key usage may also be restricted by policy statements (e.g., in certificates). In this case, different key types SHOULD be defined for the different policy alternatives.",
      "ja": "署名Oおよび/または暗号化アルゴリズム。いくつかのキータイプには、署名と暗号化の両方をサポートしていないかもしれません。主な使用法は、（証明書では、例えば）ポリシーステートメントによって制限されることがあります。この場合、異なる鍵の種類が異なる政策選択肢を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Encoding of signatures and/or encrypted data. This includes but is not limited to padding, byte order, and data formats.",
      "ja": "署名および/または暗号化されたデータのOエンコード。これは、しかし、パディング、バイトオーダー、およびデータ形式に限定されるものではありません。"
    },
    {
      "indent": 3,
      "text": "The following public key and/or certificate formats are currently defined:",
      "ja": "次の公開鍵および/または証明書の形式は、現在定義されています。"
    },
    {
      "indent": 3,
      "text": "ssh-dss REQUIRED sign Raw DSS Key ssh-rsa RECOMMENDED sign Raw RSA Key pgp-sign-rsa OPTIONAL sign OpenPGP certificates (RSA key) pgp-sign-dss OPTIONAL sign OpenPGP certificates (DSS key)",
      "ja": "SSH-DSSログインが必要です生DSSキーのssh-rsaの推奨記号生のRSAキーPGP-SIGN-RSAオプション記号のOpenPGP証明書（RSAキー）オプションの符号のOpenPGPの証明書PGP-SIGN-DSS（DSSキー）"
    },
    {
      "indent": 3,
      "text": "Additional key types may be defined, as specified in [SSH-ARCH] and in [SSH-NUMBERS].",
      "ja": "[SSH-ARCH]および[SSH-NUMBERS]で指定されるように追加のキータイプは、定義されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The key type MUST always be explicitly known (from algorithm negotiation or some other source). It is not normally included in the key blob.",
      "ja": "キータイプには、常に明示的に（アルゴリズムの折衝や他のソースから）知らなければなりません。これは、通常の鍵Blobに含まれていません。"
    },
    {
      "indent": 3,
      "text": "Certificates and public keys are encoded as follows:",
      "ja": "証明書と公開鍵、次のようにエンコードされます。"
    },
    {
      "indent": 6,
      "text": "string certificate or public key format identifier byte[n] key/certificate data",
      "ja": "文字列証明書または公開鍵フォーマット識別子バイト[N]キー/証明書データ"
    },
    {
      "indent": 3,
      "text": "The certificate part may be a zero length string, but a public key is required. This is the public key that will be used for authentication. The certificate sequence contained in the certificate blob can be used to provide authorization.",
      "ja": "証明書の部分は長さゼロの文字列であってもよいが、公開鍵が必要です。これは、認証のために使用される公開鍵です。証明書のブロブに含まれる証明書の順序は、承認を提供するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Public key/certificate formats that do not explicitly specify a signature format identifier MUST use the public key/certificate format identifier as the signature identifier.",
      "ja": "明示的に署名フォーマット識別子を指定しない公開鍵/証明書の形式は、署名識別子として公開鍵/証明書のフォーマット識別子を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Signatures are encoded as follows:",
      "ja": "次のように署名がエンコードされます。"
    },
    {
      "indent": 6,
      "text": "string signature format identifier (as specified by the public key/certificate format) byte[n] signature blob in format specific encoding.",
      "ja": "フォーマット特定のエンコーディングの文字列署名フォーマット識別子（公開鍵/証明書の形式で指定された）バイト[n]の署名ブロブ。"
    },
    {
      "indent": 3,
      "text": "The \"ssh-dss\" key format has the following specific encoding:",
      "ja": "「SSH-DSS」キーの形式は、次の特定のエンコーディングがあります。"
    },
    {
      "indent": 6,
      "text": "string \"ssh-dss\" mpint p mpint q mpint g mpint y",
      "ja": "文字列 \"SSH-DSS\" mpint P mpint Q mpint G mpint Y"
    },
    {
      "indent": 3,
      "text": "Here, the 'p', 'q', 'g', and 'y' parameters form the signature key blob.",
      "ja": "ここで、「P」、「Q」、「G」、および「Y」のパラメータは、署名鍵ブロブを形成します。"
    },
    {
      "indent": 3,
      "text": "Signing and verifying using this key format is done according to the Digital Signature Standard [FIPS-186-2] using the SHA-1 hash [FIPS-180-2].",
      "ja": "署名およびデジタル署名標準に従って行われ、このキーの形式を使用して検証[FIPS-186-2] SHA-1ハッシュを使用して、[FIPS-180-2]。"
    },
    {
      "indent": 3,
      "text": "The resulting signature is encoded as follows:",
      "ja": "次のように得られた署名は、コードされます。"
    },
    {
      "indent": 6,
      "text": "string \"ssh-dss\" string dss_signature_blob",
      "ja": "文字列dss_signature_blob \"のssh-DSS\""
    },
    {
      "indent": 3,
      "text": "The value for 'dss_signature_blob' is encoded as a string containing r, followed by s (which are 160-bit integers, without lengths or padding, unsigned, and in network byte order).",
      "ja": "「dss_signature_blob」の値は、（符号なしの長さまたはパディングなしで、160ビットの整数であり、ネットワークバイト順で）S続いて、文字列を含むRとして符号化されます。"
    },
    {
      "indent": 3,
      "text": "The \"ssh-rsa\" key format has the following specific encoding:",
      "ja": "「SSH-RSA」キーの形式は、次の特定のエンコーディングがあります。"
    },
    {
      "indent": 6,
      "text": "string \"ssh-rsa\" mpint e mpint n",
      "ja": "文字列 \"SSH-RSA\" mpint電子のmpint nを"
    },
    {
      "indent": 3,
      "text": "Here the 'e' and 'n' parameters form the signature key blob.",
      "ja": "ここでは「E」と「n」のパラメータは、署名鍵ブロブを形成します。"
    },
    {
      "indent": 3,
      "text": "Signing and verifying using this key format is performed according to the RSASSA-PKCS1-v1_5 scheme in [RFC3447] using the SHA-1 hash.",
      "ja": "署名とSHA-1ハッシュを使用して、[RFC3447]でRSASSA-PKCS1-v1_5の方式に従って行われ、このキーの形式を用いて検証します。"
    },
    {
      "indent": 3,
      "text": "The resulting signature is encoded as follows:",
      "ja": "次のように得られた署名は、コードされます。"
    },
    {
      "indent": 6,
      "text": "string \"ssh-rsa\" string rsa_signature_blob",
      "ja": "文字列 \"SSH-RSA\" の文字列rsa_signature_blob"
    },
    {
      "indent": 3,
      "text": "The value for 'rsa_signature_blob' is encoded as a string containing s (which is an integer, without lengths or padding, unsigned, and in network byte order).",
      "ja": "「rsa_signature_blob」の値は、（長さまたはパディングなしの整数であり、符号なし、ネットワークバイト順で）Sを含む文字列として符号化されます。"
    },
    {
      "indent": 3,
      "text": "The \"pgp-sign-rsa\" method indicates the certificates, the public key, and the signature are in OpenPGP compatible binary format ([RFC2440]). This method indicates that the key is an RSA-key.",
      "ja": "「PGP-SIGN-RSA」法は、証明書、公開鍵、および署名は、OpenPGPの互換性のあるバイナリ形式であることを示し（[RFC2440]）。この方法では、キーはRSAキーであることを示しています。"
    },
    {
      "indent": 3,
      "text": "The \"pgp-sign-dss\" is as above, but indicates that the key is a DSS-key.",
      "ja": "「PGP-SIGN-DSS」は上記のようであるが、キーはDSSキーであることを示しています。"
    },
    {
      "indent": 0,
      "text": "7. Key Exchange",
      "section_title": true,
      "ja": "7.鍵交換"
    },
    {
      "indent": 3,
      "text": "Key exchange (kex) begins by each side sending name-lists of supported algorithms. Each side has a preferred algorithm in each category, and it is assumed that most implementations, at any given time, will use the same preferred algorithm. Each side MAY guess which algorithm the other side is using, and MAY send an initial key exchange packet according to the algorithm, if appropriate for the preferred method.",
      "ja": "鍵交換（KEX）がサポートされているアルゴリズムの名前のリストを送信するそれぞれの側で開始されます。各側は、各カテゴリ内の好ましいアルゴリズムを有し、ほとんどの実装は、任意の時点で、同じ好適なアルゴリズムを使用することが想定されます。各側は他の側が使用されるアルゴリズムた推測することができ、好ましい方法に適している場合、アルゴリズムに従って初期鍵交換パケットを送信することができます。"
    },
    {
      "indent": 3,
      "text": "The guess is considered wrong if:",
      "ja": "推測では、もし間違っていると考えられています。"
    },
    {
      "indent": 3,
      "text": "o the kex algorithm and/or the host key algorithm is guessed wrong (server and client have different preferred algorithm), or",
      "ja": "KEXアルゴリズムおよび/またはホスト鍵のアルゴリズムは（サーバとクライアントが別の好ましいアルゴリズムを持っている）間違った推測されるO、または"
    },
    {
      "indent": 3,
      "text": "o if any of the other algorithms cannot be agreed upon (the procedure is defined below in Section 7.1).",
      "ja": "他のアルゴリズムのいずれかを合意することができない場合はO（手順はセクション7.1で以下に定義されます）。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the guess is considered to be right, and the optimistically sent packet MUST be handled as the first key exchange packet.",
      "ja": "そうでなければ、推測が正しいと考えられている、と楽観的に送られたパケットは、最初の鍵交換パケットとして扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "However, if the guess was wrong, and a packet was optimistically sent by one or both parties, such packets MUST be ignored (even if the error in the guess would not affect the contents of the initial packet(s)), and the appropriate side MUST send the correct initial packet.",
      "ja": "推測が間違っていた、そしてパケットは楽観一方または両方の当事者によって送信された場合には、そのようなパケットは、（推測の誤差が最初のパケット（複数可）の内容に影響を与えない場合でも）無視され、適切なものでなければなりません側は、正しい初期パケットを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "A key exchange method uses explicit server authentication if the key exchange messages include a signature or other proof of the server's authenticity. A key exchange method uses implicit server authentication if, in order to prove its authenticity, the server also has to prove that it knows the shared secret, K, by sending a message and a corresponding MAC that the client can verify.",
      "ja": "鍵交換メッセージが署名またはサーバの真正性の証明が他が含まれている場合、鍵交換方法は、明示的なサーバー認証を使用しています。その信憑性を証明するために、サーバは、クライアントが検証できることを示すメッセージと、対応するMACを送信することで、それは共有の秘密を知っていることをKを証明しなければならない、あれば鍵交換方式は、暗黙のサーバー認証を使用しています。"
    },
    {
      "indent": 3,
      "text": "The key exchange method defined by this document uses explicit server authentication. However, key exchange methods with implicit server authentication MAY be used with this protocol. After a key exchange with implicit server authentication, the client MUST wait for a response to its service request message before sending any further data.",
      "ja": "この文書で定義された鍵交換方式は、明示的なサーバー認証を使用しています。しかし、暗黙のサーバー認証と鍵交換方法は、このプロトコルで使用されるかもしれません。暗黙のサーバー認証と鍵交換した後、クライアントはそれ以上のデータを送信する前にそのサービス要求メッセージに対する応答を待たなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.1. Algorithm Negotiation",
      "section_title": true,
      "ja": "7.1. アルゴリズムの折衝"
    },
    {
      "indent": 3,
      "text": "Key exchange begins by each side sending the following packet:",
      "ja": "鍵交換は、次のパケットを送信するそれぞれの側で始まります。"
    },
    {
      "indent": 6,
      "text": "byte SSH_MSG_KEXINIT byte[16] cookie (random bytes) name-list kex_algorithms name-list server_host_key_algorithms name-list encryption_algorithms_client_to_server name-list encryption_algorithms_server_to_client name-list mac_algorithms_client_to_server name-list mac_algorithms_server_to_client name-list compression_algorithms_client_to_server name-list compression_algorithms_server_to_client name-list languages_client_to_server name-list languages_server_to_client boolean first_kex_packet_follows uint32 0 (reserved for future extension)",
      "ja": "バイトSSH_MSG_KEXINITバイト[16]クッキー（ランダムバイト）名前リストkex_algorithms名リストserver_host_key_algorithms名リストencryption_algorithms_client_to_server名リストencryption_algorithms_server_to_client名リストmac_algorithms_client_to_server名リストmac_algorithms_server_to_client名リストcompression_algorithms_client_to_server名リストcompression_algorithms_server_to_client名リストlanguages_client_to_server名リストlanguages_server_to_clientブールfirst_kex_packet_follows UINT32 0（将来の拡張のために予約）"
    },
    {
      "indent": 3,
      "text": "Each of the algorithm name-lists MUST be a comma-separated list of algorithm names (see Algorithm Naming in [SSH-ARCH] and additional information in [SSH-NUMBERS]). Each supported (allowed) algorithm MUST be listed in order of preference, from most to least.",
      "ja": "アルゴリズム名リストの各々は、（アルゴリズム[SSH-NUMBERS]の[SSH-ARCH]と付加情報に命名参照）アルゴリズム名のカンマ区切りのリストでなければなりません。各サポート（許可）アルゴリズムが最もから最低まで、優先順にリストされなければなりません。"
    },
    {
      "indent": 3,
      "text": "The first algorithm in each name-list MUST be the preferred (guessed) algorithm. Each name-list MUST contain at least one algorithm name.",
      "ja": "各名前リスト内の最初のアルゴリズムが好ましい（推測）アルゴリズムでなければなりません。それぞれの名前-リストには、少なくとも1人のアルゴリズム名を含まなければなりません。"
    },
    {
      "indent": 6,
      "text": "cookie The 'cookie' MUST be a random value generated by the sender. Its purpose is to make it impossible for either side to fully determine the keys and the session identifier.",
      "ja": "「クッキー」は、送信者によって生成されたランダムな値でなければならないクッキー。その目的は、それが不可能どちらかの側が完全に鍵とセッション識別子を決定できるようにすることです。"
    },
    {
      "indent": 6,
      "text": "kex_algorithms Key exchange algorithms were defined above. The first algorithm MUST be the preferred (and guessed) algorithm. If both sides make the same guess, that algorithm MUST be used. Otherwise, the following algorithm MUST be used to choose a key exchange method: Iterate over client's kex algorithms, one at a time. Choose the first algorithm that satisfies the following conditions:",
      "ja": "kex_algorithms鍵交換アルゴリズムは、上記で定義されました。最初のアルゴリズムが好ましい（と推測）アルゴリズムでなければなりません。両側が同じ推測を行う場合は、そのアルゴリズムを使用しなければなりません。クライアントのKEXアルゴリズム、一度に一つの上に反復処理：そうでない場合は、次のアルゴリズムは、鍵交換方式を選択するために使用しなければなりません。以下の条件を満たした最初のアルゴリズムを選択します。"
    },
    {
      "indent": 9,
      "text": "+ the server also supports the algorithm,",
      "ja": "+また、サーバは、アルゴリズムをサポートしています"
    },
    {
      "indent": 9,
      "text": "+ if the algorithm requires an encryption-capable host key, there is an encryption-capable algorithm on the server's server_host_key_algorithms that is also supported by the client, and",
      "ja": "+アルゴリズムは、暗号化対応のホストキーを必要とする場合、また、クライアントによってサポートされているサーバのserver_host_key_algorithms上の暗号化対応のアルゴリズムが存在し、かつ"
    },
    {
      "indent": 9,
      "text": "+ if the algorithm requires a signature-capable host key, there is a signature-capable algorithm on the server's server_host_key_algorithms that is also supported by the client.",
      "ja": "アルゴリズムは、署名可能なホストキーを必要とする場合+、また、クライアントによってサポートされているサーバのserver_host_key_algorithmsの署名可能なアルゴリズムがあります。"
    },
    {
      "indent": 6,
      "text": "If no algorithm satisfying all these conditions can be found, the connection fails, and both sides MUST disconnect.",
      "ja": "これらすべての条件を満たすアルゴリズムが見つからない場合、接続は失敗し、両側が切断する必要があります。"
    },
    {
      "indent": 6,
      "text": "server_host_key_algorithms A name-list of the algorithms supported for the server host key. The server lists the algorithms for which it has host keys; the client lists the algorithms that it is willing to accept. There MAY be multiple host keys for a host, possibly with different algorithms.",
      "ja": "サーバーのホストキーのためにサポートされているアルゴリズムの名前リストをserver_host_key_algorithms。サーバは、ホスト鍵を持っているアルゴリズムを示します。クライアントは、受け入れて喜んでいるアルゴリズムを示します。おそらく異なるアルゴリズムで、ホストに対して複数のホスト鍵があるかもしれません。"
    },
    {
      "indent": 9,
      "text": "Some host keys may not support both signatures and encryption (this can be determined from the algorithm), and thus not all host keys are valid for all key exchange methods.",
      "ja": "一部のホストキーが（これはアルゴリズムから決定することができる）の両方の署名と暗号化をサポートしていない場合があり、したがって、すべてのホスト鍵は、すべての鍵交換方式のために有効でありません。"
    },
    {
      "indent": 9,
      "text": "Algorithm selection depends on whether the chosen key exchange algorithm requires a signature or an encryption-capable host key. It MUST be possible to determine this from the public key algorithm name. The first algorithm on the client's name-list that satisfies the requirements and is also supported by the server MUST be chosen. If there is no such algorithm, both sides MUST disconnect.",
      "ja": "アルゴリズムの選択は、選択された鍵交換アルゴリズムは、署名または暗号化可能なホストキーを必要とするかどうかに依存します。公開鍵アルゴリズム名からこれを決定することが可能でなければなりません。要件を満たし、また、サーバーでサポートされているクライアントの名前、リストの最初のアルゴリズムを選ばなければなりません。そのようなアルゴリズムが存在しない場合は、両側が切断する必要があります。"
    },
    {
      "indent": 6,
      "text": "encryption_algorithms A name-list of acceptable symmetric encryption algorithms (also known as ciphers) in order of preference. The chosen encryption algorithm to each direction MUST be the first algorithm on the client's name-list that is also on the server's name-list. If there is no such algorithm, both sides MUST disconnect.",
      "ja": "優先順に（また、暗号化方式として知られている）に許容される対称暗号化アルゴリズムの名前リストをencryption_algorithms。各方向に選ばれた暗号化アルゴリズムには、サーバーの名前をリストにもあり、クライアントの名前、リスト上の最初のアルゴリズムでなければなりません。そのようなアルゴリズムが存在しない場合は、両側が切断する必要があります。"
    },
    {
      "indent": 9,
      "text": "Note that \"none\" must be explicitly listed if it is to be acceptable. The defined algorithm names are listed in Section 6.3.",
      "ja": "それが受け入れられるのであれば、「なし」は、明示的にリストされていないされなければならないことに注意してください。定義されたアルゴリズム名は、セクション6.3に記載されています。"
    },
    {
      "indent": 6,
      "text": "mac_algorithms A name-list of acceptable MAC algorithms in order of preference. The chosen MAC algorithm MUST be the first algorithm on the client's name-list that is also on the server's name-list. If there is no such algorithm, both sides MUST disconnect.",
      "ja": "優先順に許容されるMACアルゴリズムの名前リストをmac_algorithms。選ばれたMACアルゴリズムは、サーバーの名前をリストにもあり、クライアントの名前、リスト上の最初のアルゴリズムでなければなりません。そのようなアルゴリズムが存在しない場合は、両側が切断する必要があります。"
    },
    {
      "indent": 9,
      "text": "Note that \"none\" must be explicitly listed if it is to be acceptable. The MAC algorithm names are listed in Section 6.4.",
      "ja": "それが受け入れられるのであれば、「なし」は、明示的にリストされていないされなければならないことに注意してください。 MACアルゴリズム名は、6.4節に記載されています。"
    },
    {
      "indent": 6,
      "text": "compression_algorithms A name-list of acceptable compression algorithms in order of preference. The chosen compression algorithm MUST be the first algorithm on the client's name-list that is also on the server's name-list. If there is no such algorithm, both sides MUST disconnect.",
      "ja": "優先順に許容される圧縮アルゴリズムの名前リストをcompression_algorithms。選択した圧縮アルゴリズムは、サーバの名前をリストにもあり、クライアントの名前、リスト上の最初のアルゴリズムでなければなりません。そのようなアルゴリズムが存在しない場合は、両側が切断する必要があります。"
    },
    {
      "indent": 9,
      "text": "Note that \"none\" must be explicitly listed if it is to be acceptable. The compression algorithm names are listed in Section 6.2.",
      "ja": "それが受け入れられるのであれば、「なし」は、明示的にリストされていないされなければならないことに注意してください。圧縮アルゴリズム名は、セクション6.2に記載されています。"
    },
    {
      "indent": 6,
      "text": "languages This is a name-list of language tags in order of preference [RFC3066]. Both parties MAY ignore this name-list. If there are no language preferences, this name-list SHOULD be empty as defined in Section 5 of [SSH-ARCH]. Language tags SHOULD NOT be present unless they are known to be needed by the sending party.",
      "ja": "言語これは、[RFC3066]の優先順位で言語タグの名前リストです。両当事者は、この名前リストを無視してもよいです。何の言語設定がない場合は、[SSH-ARCH]のセクション5で定義されるように、この名前リストは空である必要があります。それらは送信側で必要とされることが知られていない限り言語タグが存在してはなりません。"
    },
    {
      "indent": 6,
      "text": "first_kex_packet_follows Indicates whether a guessed key exchange packet follows. If a guessed packet will be sent, this MUST be TRUE. If no guessed packet will be sent, this MUST be FALSE.",
      "ja": "first_kex_packet_followsは推測鍵交換パケットは、以下のかどうかを示します。推測パケットが送信される場合は、これが真でなければなりません。何の推測パケットが送信されません場合は、これはfalseでなければなりません。"
    },
    {
      "indent": 9,
      "text": "After receiving the SSH_MSG_KEXINIT packet from the other side, each party will know whether their guess was right. If the other party's guess was wrong, and this field was TRUE, the next packet MUST be silently ignored, and both sides MUST then act as determined by the negotiated key exchange method. If the guess was right, key exchange MUST continue using the guessed packet.",
      "ja": "他の側からSSH_MSG_KEXINITパケットを受信した後、各当事者は自分の推測が正しかったかどうかを知ることができます。相手の推測が間違っていた、とこのフィールドがTRUEだった場合は、次のパケットは黙って無視されなければならない、と交渉し鍵交換方式によって決定され、両側には、その後、行動しなければなりません。推測が正しかった場合は、鍵交換は推測パケットを継続して使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "After the SSH_MSG_KEXINIT message exchange, the key exchange algorithm is run. It may involve several packet exchanges, as specified by the key exchange method.",
      "ja": "SSH_MSG_KEXINITメッセージ交換後、鍵交換アルゴリズムが実行されます。鍵交換方式で指定されたように、それは、いくつかのパケット交換を含むことができます。"
    },
    {
      "indent": 3,
      "text": "Once a party has sent a SSH_MSG_KEXINIT message for key exchange or re-exchange, until it has sent a SSH_MSG_NEWKEYS message (Section 7.3), it MUST NOT send any messages other than:",
      "ja": "それはSSH_MSG_NEWKEYSメッセージ（7.3節）を送信したまで当事者が、鍵交換または再交換のためSSH_MSG_KEXINITメッセージを送信した後は、以外のすべてのメッセージを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "o Transport layer generic messages (1 to 19) (but SSH_MSG_SERVICE_REQUEST and SSH_MSG_SERVICE_ACCEPT MUST NOT be sent);",
      "ja": "Oトランスポート層の一般的なメッセージ（1〜19）（ただし、SSH_MSG_SERVICE_REQUESTとSSH_MSG_SERVICE_ACCEPTを送ってはいけません）。"
    },
    {
      "indent": 3,
      "text": "o Algorithm negotiation messages (20 to 29) (but further SSH_MSG_KEXINIT messages MUST NOT be sent);",
      "ja": "Oアルゴリズムのネゴシエーションメッセージ（20〜29）（しかし、さらにSSH_MSG_KEXINITメッセージを送ってはいけません）。"
    },
    {
      "indent": 3,
      "text": "o Specific key exchange method messages (30 to 49).",
      "ja": "O固有の鍵交換方式のメッセージ（30〜49）。"
    },
    {
      "indent": 3,
      "text": "The provisions of Section 11 apply to unrecognized messages.",
      "ja": "セクション11の規定は認識されていないメッセージに適用されます。"
    },
    {
      "indent": 3,
      "text": "Note, however, that during a key re-exchange, after sending a SSH_MSG_KEXINIT message, each party MUST be prepared to process an arbitrary number of messages that may be in-flight before receiving a SSH_MSG_KEXINIT message from the other party.",
      "ja": "鍵の再交換中、SSH_MSG_KEXINITメッセージを送信した後、各当事者が他の当事者からSSH_MSG_KEXINITメッセージを受信する前に飛行することができるメッセージの任意の数を処理するために用意しなければならないこと、しかし、注意してください。"
    },
    {
      "indent": 0,
      "text": "7.2. Output from Key Exchange",
      "section_title": true,
      "ja": "7.2. 鍵交換からの出力"
    },
    {
      "indent": 3,
      "text": "The key exchange produces two values: a shared secret K, and an exchange hash H. Encryption and authentication keys are derived from these. The exchange hash H from the first key exchange is additionally used as the session identifier, which is a unique identifier for this connection. It is used by authentication methods as a part of the data that is signed as a proof of possession of a private key. Once computed, the session identifier is not changed, even if keys are later re-exchanged.",
      "ja": "鍵交換は、2つの値生成：共有秘密Kを、および交換ハッシュH.暗号化と認証キーは、これらから派生しています。最初の鍵交換から交換ハッシュHは、さらに、この接続の一意の識別子であるセッション識別子として使用されます。それは、秘密鍵の所有の証明として署名されたデータの一部として認証方法で使用されています。計算すると、セッション識別子は、キーは、後に再交換された場合でも、変更されません。"
    },
    {
      "indent": 3,
      "text": "Each key exchange method specifies a hash function that is used in the key exchange. The same hash algorithm MUST be used in key derivation. Here, we'll call it HASH.",
      "ja": "各キーの交換方法は、鍵交換に使用されているハッシュ関数を指定します。同じハッシュアルゴリズムは、鍵導出に使用しなければなりません。ここでは、HASHそれを呼ぶことにします。"
    },
    {
      "indent": 3,
      "text": "Encryption keys MUST be computed as HASH, of a known value and K, as follows:",
      "ja": "次のように暗号化キーは、既知の値およびkのハッシュとして計算されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Initial IV client to server: HASH(K || H || \"A\" || session_id) (Here K is encoded as mpint and \"A\" as byte and session_id as raw data. \"A\" means the single character A, ASCII 65).",
      "ja": "Oサーバーへの初期IVクライアント：HASH（K || H || \"A\" ||のsession_id）（ここでKは、バイトとしてmpintと \"A\" としてエンコードし、生データとしてセッション_さ \"\" 単一の文字Aが意味し、 ASCII 65）。"
    },
    {
      "indent": 3,
      "text": "o Initial IV server to client: HASH(K || H || \"B\" || session_id)",
      "ja": "HASH（K || H || \"B\" || SESSION_ID）：クライアントへの初期IVサーバO"
    },
    {
      "indent": 3,
      "text": "o Encryption key client to server: HASH(K || H || \"C\" || session_id)",
      "ja": "サーバーへのO暗号化キークライアント：HASH（K || H || \"C\" || SESSION_ID）"
    },
    {
      "indent": 3,
      "text": "o Encryption key server to client: HASH(K || H || \"D\" || session_id)",
      "ja": "クライアントへのO暗号化キーサーバー：HASH（K || H || \"D\" || SESSION_ID）"
    },
    {
      "indent": 3,
      "text": "o Integrity key client to server: HASH(K || H || \"E\" || session_id)",
      "ja": "サーバーへのO整合性の鍵クライアント：HASH（K || H || \"E\" || SESSION_ID）"
    },
    {
      "indent": 3,
      "text": "o Integrity key server to client: HASH(K || H || \"F\" || session_id)",
      "ja": "クライアントへのO整合性の鍵サーバー：HASH（K || H || \"F\" || SESSION_ID）"
    },
    {
      "indent": 3,
      "text": "Key data MUST be taken from the beginning of the hash output. As many bytes as needed are taken from the beginning of the hash value. If the key length needed is longer than the output of the HASH, the key is extended by computing HASH of the concatenation of K and H and the entire key so far, and appending the resulting bytes (as many as HASH generates) to the key. This process is repeated until enough key material is available; the key is taken from the beginning of this value. In other words:",
      "ja": "主なデータはハッシュ出力の最初から取らなければなりません。必要なだけのバイトは、ハッシュ値の先頭から取られています。必要なキーの長さが長いHASHの出力よりも大きい場合、キーは、これまでKおよびHの連結全体キーのハッシュを計算し、キーに得られたバイト（HASHが生成する限り多くの）を追加することによって拡張されます。十分なキーマテリアルが利用可能になるまで、このプロセスが繰り返されます。キーは、この値の先頭から取られています。言い換えると："
    },
    {
      "indent": 6,
      "text": "K1 = HASH(K || H || X || session_id) (X is e.g., \"A\") K2 = HASH(K || H || K1) K3 = HASH(K || H || K1 || K2) ... key = K1 || K2 || K3 || ...",
      "ja": "K1 = HASH（K || H || X || SESSION_ID）（Xは例えば \"A\"）K2 = HASH（K || H || K1）K3 = HASH（K || H || || K1 K2 ）...キー= K1 || K2 || K3 || ..."
    },
    {
      "indent": 3,
      "text": "This process will lose entropy if the amount of entropy in K is larger than the internal state size of HASH.",
      "ja": "Kにおけるエントロピーの量がHASHの内部状態のサイズよりも大きい場合には、このプロセスは、エントロピーを失うことになります。"
    },
    {
      "indent": 0,
      "text": "7.3. Taking Keys Into Use",
      "section_title": true,
      "ja": "7.3. 利用されるようにキーを撮ります"
    },
    {
      "indent": 3,
      "text": "Key exchange ends by each side sending an SSH_MSG_NEWKEYS message. This message is sent with the old keys and algorithms. All messages sent after this message MUST use the new keys and algorithms.",
      "ja": "鍵交換はSSH_MSG_NEWKEYSメッセージを送信するそれぞれの側で終わります。このメッセージは、古い鍵とアルゴリズムに送信されます。このメッセージの後に送信されるすべてのメッセージは、新しいキーとアルゴリズムを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When this message is received, the new keys and algorithms MUST be used for receiving.",
      "ja": "このメッセージが受信されると、新たな鍵およびアルゴリズムは、受信するために使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The purpose of this message is to ensure that a party is able to respond with an SSH_MSG_DISCONNECT message that the other party can understand if something goes wrong with the key exchange.",
      "ja": "このメッセージの目的は、当事者が何かが鍵交換で問題が発生した場合、相手が理解できるSSH_MSG_DISCONNECTメッセージで応答することが可能であることを確認することです。"
    },
    {
      "indent": 6,
      "text": "byte SSH_MSG_NEWKEYS",
      "ja": "バイトSSH_MSG_NEWKEYS"
    },
    {
      "indent": 0,
      "text": "8. Diffie-Hellman Key Exchange",
      "section_title": true,
      "ja": "8.のDiffie-Hellman鍵交換"
    },
    {
      "indent": 3,
      "text": "The Diffie-Hellman (DH) key exchange provides a shared secret that cannot be determined by either party alone. The key exchange is combined with a signature with the host key to provide host authentication. This key exchange method provides explicit server authentication as defined in Section 7.",
      "ja": "ディフィー・ヘルマン（DH）鍵交換だけではいずれの当事者によって決定することができない共有シークレットを提供します。鍵交換はホスト認証を提供するために、ホストキーで署名と組み合わされます。第7節で定義されたように、この鍵交換方式は、明示的なサーバ認証を提供します。"
    },
    {
      "indent": 3,
      "text": "The following steps are used to exchange a key. In this, C is the client; S is the server; p is a large safe prime; g is a generator for a subgroup of GF(p); q is the order of the subgroup; V_S is S's identification string; V_C is C's identification string; K_S is S's public host key; I_C is C's SSH_MSG_KEXINIT message and I_S is S's SSH_MSG_KEXINIT message that have been exchanged before this part begins.",
      "ja": "次の手順は、鍵を交換するために使用されています。この中で、Cは、クライアントです。 Sはサーバです。 pは、大きな安全素数です。 GはGF（P）のサブグループのジェネレータです。 qはサブグループの順序です。 V_SはSの識別文字列です。 V_CはCの識別文字列です。 K_SはSの公開ホスト鍵です。 I_CはCのSSH_MSG_KEXINITメッセージであるとI_Sは、この部分が始まる前に交換されているSさんSSH_MSG_KEXINITメッセージです。"
    },
    {
      "indent": 3,
      "text": "1. C generates a random number x (1 < x < q) and computes e = g^x mod p. C sends e to S.",
      "ja": "1. Cは、ランダム番号x（1 <x <q）を生成し、E = G ^ Xのmod Pを計算します。 CはS.に電子を送ります"
    },
    {
      "indent": 3,
      "text": "2. S generates a random number y (0 < y < q) and computes f = g^y mod p. S receives e. It computes K = e^y mod p, H = hash(V_C || V_S || I_C || I_S || K_S || e || f || K) (these elements are encoded according to their types; see below), and signature s on H with its private host key. S sends (K_S || f || s) to C. The signing operation may involve a second hashing operation.",
      "ja": "2. Sは、乱数yを（0 <Y <Q）を生成すると、F = G ^ Yのmod Pを計算します。 Sは、電子を受け取ります。それは計算K = E ^ Y MOD P、H =ハッシュ（V_C || || V_S I_C || || I_S K_S || E || F || K）（これらの要素は、それらの種類に従って符号化されている;以下を参照のこと） 、および署名S H上のプライベートホストキーを持ちます。 Sは、署名操作が、第二ハッシュ演算を含んでいてもよいCに（K_S || F || S）を送信します。"
    },
    {
      "indent": 3,
      "text": "3. C verifies that K_S really is the host key for S (e.g., using certificates or a local database). C is also allowed to accept the key without verification; however, doing so will render the protocol insecure against active attacks (but may be desirable for practical reasons in the short term in many environments). C then computes K = f^x mod p, H = hash(V_C || V_S || I_C || I_S || K_S || e || f || K), and verifies the signature s on H.",
      "ja": "3. CはK_Sが本当に（例えば、証明書またはローカルデータベースを使用して）S用のホストキーであることを検証します。 Cも検証せずにキーを受け入れることを許可されています。しかし、そうすることは、アクティブな攻撃に対して安全でないプロトコルをレンダリングします（ただし、多くの環境で短期的に実際的な理由が望ましいかもしれません）。 Cは、その後、K = F ^ X MOD P、H =ハッシュ（V_C || || V_S I_C || || I_S K_S || E || F || K）を計算し、及びH.上の署名Sを検証します"
    },
    {
      "indent": 3,
      "text": "Values of 'e' or 'f' that are not in the range [1, p-1] MUST NOT be sent or accepted by either side. If this condition is violated, the key exchange fails.",
      "ja": "範囲内にない「E」または「F」の値は[1、P-1]のどちらかの側によって送信された又は受け入れてはいけません。この条件に違反した場合、鍵交換が失敗します。"
    },
    {
      "indent": 3,
      "text": "This is implemented with the following messages. The hash algorithm for computing the exchange hash is defined by the method name, and is called HASH. The public key algorithm for signing is negotiated with the SSH_MSG_KEXINIT messages.",
      "ja": "これは、次のようなメッセージで実装されています。交換ハッシュを計算するハッシュアルゴリズムは、メソッド名によって定義され、HASHと呼ばれています。署名の公開鍵アルゴリズムはSSH_MSG_KEXINITメッセージと交渉しています。"
    },
    {
      "indent": 3,
      "text": "First, the client sends the following:",
      "ja": "まず、クライアントは、次のように送信します。"
    },
    {
      "indent": 6,
      "text": "byte SSH_MSG_KEXDH_INIT mpint e",
      "ja": "EマウントSSH_MSG_KEXINITバイト"
    },
    {
      "indent": 3,
      "text": "The server then responds with the following:",
      "ja": "次に、サーバは次のように応答します。"
    },
    {
      "indent": 6,
      "text": "byte SSH_MSG_KEXDH_REPLY string server public host key and certificates (K_S) mpint f string signature of H",
      "ja": "バイトSSH_MSG_KEXDH_REPLY文字列サーバ公開ホスト鍵と証明書（K_S）Hのmpint F列の署名"
    },
    {
      "indent": 3,
      "text": "The hash H is computed as the HASH hash of the concatenation of the following:",
      "ja": "ハッシュHは、以下の連結のハッシュハッシュとして計算されます。"
    },
    {
      "indent": 6,
      "text": "string V_C, the client's identification string (CR and LF excluded) string V_S, the server's identification string (CR and LF excluded) string I_C, the payload of the client's SSH_MSG_KEXINIT string I_S, the payload of the server's SSH_MSG_KEXINIT string K_S, the host key mpint e, exchange value sent by the client mpint f, exchange value sent by the server mpint K, the shared secret",
      "ja": "文字列V_C、クライアントの識別文字列（CRとLFを除く）は、文字列V_S、サーバーの識別文字列（CRとLFを除く）は、文字列I_C、クライアントのSSH_MSG_KEXINIT列I_Sのペイロードは、サーバのSSH_MSG_KEXINIT列K_Sのペイロード、ホスト鍵mpint電子、クライアントmpint fで送信された交換価値、サーバmpint Kにより送信された交換価値、共有秘密"
    },
    {
      "indent": 3,
      "text": "This value is called the exchange hash, and it is used to authenticate the key exchange. The exchange hash SHOULD be kept secret.",
      "ja": "この値は、交換ハッシュと呼ばれ、鍵交換を認証するために使用されます。交換ハッシュは秘密にされるべきです。"
    },
    {
      "indent": 3,
      "text": "The signature algorithm MUST be applied over H, not the original data. Most signature algorithms include hashing and additional padding (e.g., \"ssh-dss\" specifies SHA-1 hashing). In that case, the data is first hashed with HASH to compute H, and H is then hashed with SHA-1 as part of the signing operation.",
      "ja": "署名アルゴリズムはHではなく、元のデータの上に適用されなければなりません。ほとんどの署名アルゴリズムは、ハッシュと追加のパディングを含む（例えば、「SSH-DSSは、」SHA-1ハッシュを指定します）。その場合、データは最初にHを計算するハッシュとハッシュされ、そしてHは、その後、署名操作の一部としてSHA-1ハッシュされます。"
    },
    {
      "indent": 0,
      "text": "8.1. diffie-hellman-group1-sha1",
      "section_title": true,
      "ja": "8.1. ディフィー・ヘルマン-GROUP1-SHA1"
    },
    {
      "indent": 3,
      "text": "The \"diffie-hellman-group1-sha1\" method specifies the Diffie-Hellman key exchange with SHA-1 as HASH, and Oakley Group 2 [RFC2409] (1024- bit MODP Group). This method MUST be supported for interoperability as all of the known implementations currently support it. Note that this method is named using the phrase \"group1\", even though it specifies the use of Oakley Group 2.",
      "ja": "\"ディフィー・ヘルマン-GROUP1-SHA1\" 方法は、SHA-1ハッシュとして、及びオークリーグループ2 [RFC2409]（1024ビットMODPグループ）とのDiffie-Hellman鍵交換を指定します。この方法は、現在、それをサポートして知られている実装のすべてと相互運用性のためにサポートしなければなりません。それはオークリーグループ2の使用を指定していても、この方法は、句「GROUP1」を使用して命名されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "8.2. diffie-hellman-group14-sha1",
      "section_title": true,
      "ja": "8.2. ディフィー・ヘルマン-group14-SHA1"
    },
    {
      "indent": 3,
      "text": "The \"diffie-hellman-group14-sha1\" method specifies a Diffie-Hellman key exchange with SHA-1 as HASH and Oakley Group 14 [RFC3526] (2048- bit MODP Group), and it MUST also be supported.",
      "ja": "\"ディフィー・ヘルマン-group14-SHA1\" 方法はHASHとオークリーグループ14 [RFC3526]（2048ビットMODPグループ）としてSHA-1とのDiffie-Hellman鍵交換を指定し、それはまた、サポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "9. Key Re-Exchange",
      "section_title": true,
      "ja": "9.キー再交換"
    },
    {
      "indent": 3,
      "text": "Key re-exchange is started by sending an SSH_MSG_KEXINIT packet when not already doing a key exchange (as described in Section 7.1). When this message is received, a party MUST respond with its own SSH_MSG_KEXINIT message, except when the received SSH_MSG_KEXINIT already was a reply. Either party MAY initiate the re-exchange, but roles MUST NOT be changed (i.e., the server remains the server, and the client remains the client).",
      "ja": "キー再交換は（セクション7.1で説明したように）すでに鍵交換をしていないSSH_MSG_KEXINITパケットを送信することにより開始されます。このメッセージを受信した場合、当事者は受信SSH_MSG_KEXINITが既に回答した場合を除き、独自のSSH_MSG_KEXINITメッセージで応じなければなりません。 （すなわち、サーバは、サーバままで、クライアントは、クライアントのまま）いずれの当事者も、再交換を開始することができるが、役割は変更しないでください。"
    },
    {
      "indent": 3,
      "text": "Key re-exchange is performed using whatever encryption was in effect when the exchange was started. Encryption, compression, and MAC methods are not changed before a new SSH_MSG_NEWKEYS is sent after the key exchange (as in the initial key exchange). Re-exchange is processed identically to the initial key exchange, except for the session identifier that will remain unchanged. It is permissible to change some or all of the algorithms during the re-exchange. Host keys can also change. All keys and initialization vectors are recomputed after the exchange. Compression and encryption contexts are reset.",
      "ja": "キー再交換は、為替の起動時に有効だったものは何でも暗号化使用して行われます。新しいSSH_MSG_NEWKEYSが（初期鍵交換のように）鍵交換の後に送信される前に暗号化、圧縮、およびMAC方法は変更されません。再交換は変わらないセッション識別子を除いて、最初の鍵交換と同一に処理されます。再交換中にアルゴリズムの一部またはすべてを変更することが許されます。ホストキーも変更することができます。すべてのキーと初期化ベクトルは、交換後に再計算されます。圧縮と暗号化コンテキストがリセットされます。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the keys be changed after each gigabyte of transmitted data or after each hour of connection time, whichever comes sooner. However, since the re-exchange is a public key operation, it requires a fair amount of processing power and should not be performed too often.",
      "ja": "キーが送信されたデータの各ギガバイト後、または早くいずれか早い方の接続時間の各時間、後に変更することが推奨されます。再交換は公開キー操作であるため、しかし、それは処理能力のかなりの量を必要とし、あまりにも頻繁に実行されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "More application data may be sent after the SSH_MSG_NEWKEYS packet has been sent; key exchange does not affect the protocols that lie above the SSH transport layer.",
      "ja": "SSH_MSG_NEWKEYSパケットが送信された後より多くのアプリケーションデータを送信することができます。鍵交換は、SSHトランスポート層の上にあるプロトコルには影響を与えません。"
    },
    {
      "indent": 0,
      "text": "10. Service Request",
      "section_title": true,
      "ja": "10.サービスリクエスト"
    },
    {
      "indent": 3,
      "text": "After the key exchange, the client requests a service. The service is identified by a name. The format of names and procedures for defining new names are defined in [SSH-ARCH] and [SSH-NUMBERS].",
      "ja": "鍵交換の後、クライアントがサービスを要求します。サービスは名前で識別されます。名前と新しい名前を定義するための手順の形式は、[SSH-ARCH]および[SSH-NUMBERS]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Currently, the following names have been reserved:",
      "ja": "現在、次の名前は予約されています："
    },
    {
      "indent": 6,
      "text": "ssh-userauth ssh-connection",
      "ja": "SSH-USERAUTHのssh接続"
    },
    {
      "indent": 3,
      "text": "Similar local naming policy is applied to the service names, as is applied to the algorithm names. A local service should use the PRIVATE USE syntax of \"servicename@domain\".",
      "ja": "アルゴリズム名に適用されるものと同様のローカル・ネーミング・ポリシーは、サービス名に適用されます。ローカルサービスは、「サービス名@ドメイン」の私的使用の構文を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "byte SSH_MSG_SERVICE_REQUEST string service name",
      "ja": "バイトSSH_MSG_SERVICE_REQUEST文字列のサービス名"
    },
    {
      "indent": 3,
      "text": "If the server rejects the service request, it SHOULD send an appropriate SSH_MSG_DISCONNECT message and MUST disconnect.",
      "ja": "サーバーがサービス要求を拒否した場合、それは適切なSSH_MSG_DISCONNECTメッセージを送るべきであると切り離す必要があります。"
    },
    {
      "indent": 3,
      "text": "When the service starts, it may have access to the session identifier generated during the key exchange.",
      "ja": "サービスが起動すると、鍵交換の際に生成されたセッション識別子にアクセスすることができます。"
    },
    {
      "indent": 3,
      "text": "If the server supports the service (and permits the client to use it), it MUST respond with the following:",
      "ja": "サーバがサービスをサポートしています（と、それを使用するようにクライアントを許可する）場合は、次のように応答しなければなりません："
    },
    {
      "indent": 6,
      "text": "byte SSH_MSG_SERVICE_ACCEPT string service name",
      "ja": "バイトSSH_MSG_SERVICE_ACCEPT文字列のサービス名"
    },
    {
      "indent": 3,
      "text": "Message numbers used by services should be in the area reserved for them (see [SSH-ARCH] and [SSH-NUMBERS]). The transport level will continue to process its own messages.",
      "ja": "サービスによって使用されるメッセージの数は、（[SSH-ARCH]および[SSH-NUMBERS]を参照）、それらのために確保された領域内にあるべきです。トランスポート・レベルは、独自のメッセージを処理していきます。"
    },
    {
      "indent": 3,
      "text": "Note that after a key exchange with implicit server authentication, the client MUST wait for a response to its service request message before sending any further data.",
      "ja": "暗黙のサーバー認証と鍵交換した後、クライアントはそれ以上のデータを送信する前にそのサービス要求メッセージに対する応答を待たなければならないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "11. Additional Messages",
      "section_title": true,
      "ja": "11.追加メッセージ"
    },
    {
      "indent": 3,
      "text": "Either party may send any of the following messages at any time.",
      "ja": "いずれの当事者は、いつでも、次のいずれかのメッセージを送信することができます。"
    },
    {
      "indent": 0,
      "text": "11.1. Disconnection Message",
      "section_title": true,
      "ja": "11.1. 切断メッセージ"
    },
    {
      "indent": 6,
      "text": "byte      SSH_MSG_DISCONNECT\nuint32    reason code\nstring    description in ISO-10646 UTF-8 encoding [RFC3629]\nstring    language tag [RFC3066]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This message causes immediate termination of the connection. All implementations MUST be able to process this message; they SHOULD be able to send this message.",
      "ja": "このメッセージは、接続の即時終了を引き起こします。すべての実装は、このメッセージを処理できなければなりません。彼らはこのメッセージを送信することができるべきです。"
    },
    {
      "indent": 3,
      "text": "The sender MUST NOT send or receive any data after this message, and the recipient MUST NOT accept any data after receiving this message. The Disconnection Message 'description' string gives a more specific explanation in a human-readable form. The Disconnection Message 'reason code' gives the reason in a more machine-readable format (suitable for localization), and can have the values as displayed in the table below. Note that the decimal representation is displayed in this table for readability, but the values are actually uint32 values.",
      "ja": "送信者は送信またはこのメッセージの後に任意のデータを受信し、受信者がこのメッセージを受信した後、任意のデータを受け入れてはいけませんてはなりません。切断メッセージ「説明」文字列は、人間が読める形式で、より具体的に説明します。切断メッセージ「理由コード」は（ローカライズするのに適した）複数の機械可読形式で理由を与え、かつ以下の表に表示されているような値を有することができます。 10進数表現を読みやすくするために、このテーブルに表示されていることに注意してくださいが、値は実際にはUINT32値です。"
    },
    {
      "indent": 6,
      "text": "     Symbolic name                                reason code\n     -------------                                -----------\nSSH_DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT             1\nSSH_DISCONNECT_PROTOCOL_ERROR                          2\nSSH_DISCONNECT_KEY_EXCHANGE_FAILED                     3\nSSH_DISCONNECT_RESERVED                                4\nSSH_DISCONNECT_MAC_ERROR                               5\nSSH_DISCONNECT_COMPRESSION_ERROR                       6\nSSH_DISCONNECT_SERVICE_NOT_AVAILABLE                   7\nSSH_DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED          8\nSSH_DISCONNECT_HOST_KEY_NOT_VERIFIABLE                 9\nSSH_DISCONNECT_CONNECTION_LOST                        10\nSSH_DISCONNECT_BY_APPLICATION                         11\nSSH_DISCONNECT_TOO_MANY_CONNECTIONS                   12\nSSH_DISCONNECT_AUTH_CANCELLED_BY_USER                 13\nSSH_DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE         14\nSSH_DISCONNECT_ILLEGAL_USER_NAME                      15",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the 'description' string is displayed, the control character filtering discussed in [SSH-ARCH] should be used to avoid attacks by sending terminal control characters.",
      "ja": "「説明」の文字列が表示されたら、[SSH-ARCH]で議論フィルタリング制御文字は端末制御文字を送信することにより、攻撃を回避するために使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Requests for assignments of new Disconnection Message 'reason code' values (and associated 'description' text) in the range of 0x00000010 to 0xFDFFFFFF MUST be done through the IETF CONSENSUS method, as described in [RFC2434]. The Disconnection Message 'reason code' values in the range of 0xFE000000 through 0xFFFFFFFF are reserved for PRIVATE USE. As noted, the actual instructions to the IANA are in [SSH-NUMBERS].",
      "ja": "[RFC2434]に記載されているように0xFDFFFFFFに0x00000010の範囲内の新たな切断メッセージ「理由コード」値（および関連する「説明」テキスト）の割当の要求は、IETFコンセンサス方法を介して行われなければなりません。 0xFFFFFFFFを介して0xFE000000の範囲で切断メッセージ「理由コード」の値は、私的使用のために予約されています。述べたように、IANAに実際の命令は、[SSH-NUMBERS]です。"
    },
    {
      "indent": 0,
      "text": "11.2. Ignored Data Message",
      "section_title": true,
      "ja": "11.2. 無視されたデータメッセージ"
    },
    {
      "indent": 6,
      "text": "byte      SSH_MSG_IGNORE\nstring    data",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All implementations MUST understand (and ignore) this message at any time (after receiving the identification string). No implementation is required to send them. This message can be used as an additional protection measure against advanced traffic analysis techniques.",
      "ja": "すべての実装は、（識別文字列を受信した後に）いつでも、このメッセージを理解する（そして無視する）しなければなりません。いいえ実装は、それらを送信するために必要とされません。このメッセージは、高度なトラフィック分析技術に対する追加の保護対策として使用することができます。"
    },
    {
      "indent": 0,
      "text": "11.3. Debug Message",
      "section_title": true,
      "ja": "11.3. デバッグメッセージ"
    },
    {
      "indent": 6,
      "text": "byte      SSH_MSG_DEBUG\nboolean   always_display\nstring    message in ISO-10646 UTF-8 encoding [RFC3629]\nstring    language tag [RFC3066]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All implementations MUST understand this message, but they are allowed to ignore it. This message is used to transmit information that may help debugging. If 'always_display' is TRUE, the message SHOULD be displayed. Otherwise, it SHOULD NOT be displayed unless debugging information has been explicitly requested by the user.",
      "ja": "すべての実装は、このメッセージを理解する必要がありますが、彼らはそれを無視することが許可されています。このメッセージは、デバッグに役立つ情報を送信するために使用されます。 「always_displayが」TRUEの場合は、メッセージが表示されるはずです。デバッグ情報は、ユーザーによって明示的に要求されていない限り、それ以外の場合は表示されません。"
    },
    {
      "indent": 3,
      "text": "The 'message' doesn't need to contain a newline. It is, however, allowed to consist of multiple lines separated by CRLF (Carriage Return - Line Feed) pairs.",
      "ja": "「メッセージ」は改行を含める必要はありません。対 - しかしながら、CRLF（改行キャリッジリターン）で区切られた複数の行から構成することができます。"
    },
    {
      "indent": 3,
      "text": "If the 'message' string is displayed, the terminal control character filtering discussed in [SSH-ARCH] should be used to avoid attacks by sending terminal control characters.",
      "ja": "「メッセージ」の文字列が表示されたら、[SSH-ARCH]で議論フィルタリング端末制御文字は端末制御文字を送信することにより、攻撃を回避するために使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.4. Reserved Messages",
      "section_title": true,
      "ja": "11.4. 予約済みのメッセージ"
    },
    {
      "indent": 3,
      "text": "An implementation MUST respond to all unrecognized messages with an SSH_MSG_UNIMPLEMENTED message in the order in which the messages were received. Such messages MUST be otherwise ignored. Later protocol versions may define other meanings for these message types.",
      "ja": "実装は、メッセージが受信された順序でSSH_MSG_UNIMPLEMENTEDメッセージをすべて認識されていないメッセージに応答しなければなりません。このようなメッセージは、それ以外の場合は無視しなければなりません。以降のプロトコルバージョンは、これらのメッセージタイプのために他の意味を定義することができます。"
    },
    {
      "indent": 6,
      "text": "byte SSH_MSG_UNIMPLEMENTED uint32 packet sequence number of rejected message",
      "ja": "拒否されたメッセージのバイトSSH_MSG_UNIMPLEMENTED UINT32のパケットシーケンス番号"
    },
    {
      "indent": 0,
      "text": "12. Summary of Message Numbers",
      "section_title": true,
      "ja": "メッセージ番号の12の概要"
    },
    {
      "indent": 3,
      "text": "The following is a summary of messages and their associated message number.",
      "ja": "以下は、メッセージとそれに関連するメッセージ番号の要約です。"
    },
    {
      "indent": 9,
      "text": "SSH_MSG_DISCONNECT             1\nSSH_MSG_IGNORE                 2\nSSH_MSG_UNIMPLEMENTED          3\nSSH_MSG_DEBUG                  4\nSSH_MSG_SERVICE_REQUEST        5\nSSH_MSG_SERVICE_ACCEPT         6\nSSH_MSG_KEXINIT                20\nSSH_MSG_NEWKEYS                21",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that numbers 30-49 are used for kex packets. Different kex methods may reuse message numbers in this range.",
      "ja": "数字30-49はKEXパケットに使用されていることに注意してください。異なるKEX方法は、この範囲のメッセージ番号を再利用することができます。"
    },
    {
      "indent": 0,
      "text": "13. IANA Considerations",
      "section_title": true,
      "ja": "13. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document is part of a set. The IANA considerations for the SSH protocol as defined in [SSH-ARCH], [SSH-USERAUTH], [SSH-CONNECT], and this document, are detailed in [SSH-NUMBERS].",
      "ja": "この文書では、セットの一部です。 [SSH-ARCH]で定義されるようにSSHプロトコルのIANAの考慮、[SSH-USERAUTH]、[SSH-CONNECT]、この文書は、[SSH-NUMBERS]に詳述されています。"
    },
    {
      "indent": 0,
      "text": "14. Security Considerations",
      "section_title": true,
      "ja": "14.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This protocol provides a secure encrypted channel over an insecure network. It performs server host authentication, key exchange, encryption, and integrity protection. It also derives a unique session ID that may be used by higher-level protocols.",
      "ja": "このプロトコルは、安全でないネットワーク上でセキュアな暗号化されたチャネルを提供します。これは、サーバーのホスト認証、鍵交換、暗号化、および整合性保護を行います。それはまた、より高いレベルのプロトコルによって使用することができる一意のセッションIDを導出します。"
    },
    {
      "indent": 3,
      "text": "Full security considerations for this protocol are provided in [SSH-ARCH].",
      "ja": "このプロトコルのための完全なセキュリティ上の考慮事項は、[SSH-ARCH]で提供されています。"
    },
    {
      "indent": 0,
      "text": "15. References",
      "section_title": true,
      "ja": "15.参考文献"
    },
    {
      "indent": 0,
      "text": "15.1. Normative References",
      "section_title": true,
      "ja": "15.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[SSH-ARCH] Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH) Protocol Architecture\", RFC 4251, January 2006.",
      "ja": "[SSH-ARCH] Ylonenと、T.とC. Lonvick、エド。、 \"セキュアシェル（SSH）プロトコルアーキテクチャ\"、RFC 4251、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[SSH-USERAUTH] Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH) Authentication Protocol\", RFC 4252, January 2006.",
      "ja": "[SSH-USERAUTH] Ylonenと、T.とC. Lonvick、エド。、 \"セキュアシェル（SSH）認証プロトコル\"、RFC 4252、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[SSH-CONNECT] Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH) Connection Protocol\", RFC 4254, January 2006.",
      "ja": "[SSH-CONNECT] Ylonenと、T.とC. Lonvick、エド。、 \"セキュアシェル（SSH）接続プロトコル\"、RFC 4254、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[SSH-NUMBERS] Lehtinen, S. and C. Lonvick, Ed., \"The Secure Shell (SSH) Protocol Assigned Numbers\", RFC 4250, January 2006.",
      "ja": "[SSH-NUMBERS]レーティネン、S.とC. Lonvick、エド。、 \"セキュアシェル（SSH）プロトコル割り当て番号\"、RFC 4250、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC1321] Rivest, R., \"The MD5 Message-Digest Algorithm \", RFC 1321, April 1992.",
      "ja": "[RFC1321]のRivest、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1950] Deutsch, P. and J-L. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, May 1996.",
      "ja": "[RFC1950]ドイツ、P.及びJ-L。 Gailly氏、 \"ZLIB圧縮データフォーマット仕様バージョン3.3\"、RFC 1950、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1951] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3\", RFC 1951, May 1996.",
      "ja": "[RFC1951]ドイツ、P.、 \"DEFLATE圧縮データフォーマット仕様バージョン1.3\"、RFC 1951、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2144] Adams, C., \"The CAST-128 Encryption Algorithm\", RFC 2144, May 1997.",
      "ja": "[RFC2144]アダムス、C.、 \"CAST-128暗号化アルゴリズム\"、RFC 2144、1997年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2409] Harkins, D. and D. Carrel, \"The Internet Key Exchange (IKE)\", RFC 2409, November 1998.",
      "ja": "[RFC2409]ハーキンとD.とD.カレル、 \"インターネットキー交換（IKE）\"、RFC 2409、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2440] Callas, J., Donnerhacke, L., Finney, H., and R. Thayer, \"OpenPGP Message Format\", RFC 2440, November 1998.",
      "ja": "[RFC2440]カラス、J.、Donnerhacke、L.、フィニー、H.、およびR.セイヤー、 \"OpenPGPのメッセージフォーマット\"、RFC 2440、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3066] Alvestrand, H., \"Tags for the Identification of Languages\", BCP 47, RFC 3066, January 2001.",
      "ja": "[RFC3066] Alvestrand、H.、 \"言語識別のためのタグ\"、BCP 47、RFC 3066、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "ja": "[RFC3447]ジョンソン、J.とB. Kaliski、 \"公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン2.1\"、RFC 3447、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3526] Kivinen, T. and M. Kojo, \"More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)\", RFC 3526, May 2003.",
      "ja": "[RFC3526] Kivinen、T.およびM.古城、 \"インターネット鍵交換のためのより多くのモジュラー指数（MODP）のDiffie-Hellmanグループ（IKE）\"、RFC 3526、2003年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[FIPS-180-2] US National Institute of Standards and Technology, \"Secure Hash Standard (SHS)\", Federal Information Processing Standards Publication 180-2, August 2002.",
      "ja": "[FIPS-180-2]米国国立標準技術研究所、連邦情報処理規格180-2出版、2002年8月「ハッシュ規格（SHS）を固定します」。"
    },
    {
      "indent": 3,
      "text": "[FIPS-186-2] US National Institute of Standards and Technology, \"Digital Signature Standard (DSS)\", Federal Information Processing Standards Publication 186-2, January 2000.",
      "ja": "[FIPS-186-2]米国国立標準技術研究所、「デジタル署名標準（DSS）」、連邦情報処理規格186-2出版、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[FIPS-197] US National Institute of Standards and Technology, \"Advanced Encryption Standard (AES)\", Federal Information Processing Standards Publication 197, November 2001.",
      "ja": "[FIPS-197]米国国立標準技術研究所、「高度暗号化標準（AES）」、連邦情報処理規格出版197、2001年11月。"
    },
    {
      "indent": 3,
      "text": "[FIPS-46-3] US National Institute of Standards and Technology, \"Data Encryption Standard (DES)\", Federal Information Processing Standards Publication 46-3, October 1999.",
      "ja": "[FIPS-46-3]米国国立標準技術研究所、「データ暗号化規格（DES）」、連邦情報処理規格出版物46-3、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[SCHNEIER] Schneier, B., \"Applied Cryptography Second Edition: protocols algorithms and source in code in C\", John Wiley and Sons, New York, NY, 1996.",
      "ja": "[シュナイアー]シュナイアー、B.、 \"応用暗号第二版：Cのコードでプロトコルアルゴリズムとソース\"、John Wiley and Sons、ニューヨーク、NY、1996。"
    },
    {
      "indent": 3,
      "text": "[TWOFISH] Schneier, B., \"The Twofish Encryptions Algorithm: A 128-Bit Block Cipher, 1st Edition\", March 1999.",
      "ja": "[Twofishは]シュナイアー、B.、 \"Twofishの暗号化アルゴリズム：128ビットブロック暗号、第1版\"、1999年3月。"
    },
    {
      "indent": 0,
      "text": "15.2. Informative References",
      "section_title": true,
      "ja": "15.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC0894] Hornig, C., \"Standard for the transmission of IP datagrams over Ethernet networks\", STD 41, RFC 894, April 1984.",
      "ja": "[RFC0894] Hornig、C.、 \"イーサネットネットワーク上でIPデータグラムの送信のための基準\"、STD 41、RFC 894、1984年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1661] Simpson, W., \"The Point-to-Point Protocol (PPP)\", STD 51, RFC 1661, July 1994.",
      "ja": "[RFC1661]シンプソン、W.、 \"ポイントツーポイントプロトコル（PPP）\"、STD 51、RFC 1661、1994年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC2412] Orman, H., \"The OAKLEY Key Determination Protocol\", RFC 2412, November 1998.",
      "ja": "[RFC2412]オーマン、H.、 \"OAKLEYキー決意プロトコル\"、RFC 2412、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[ssh-1.2.30] Ylonen, T., \"ssh-1.2.30/RFC\", File within compressed tarball ftp://ftp.funet.fi/pub/unix/security/ login/ssh/ssh-1.2.30.tar.gz, November 1995.",
      "ja": "[SSH-1.2.30] Ylonenと、T.、 \"SSH-1.2.30 / RFC\"、圧縮されたtarballのftp://ftp.funet.fi/pub/unix/security/のログイン/ SSH / SSH-1.2内のファイル。 30.tar.gz、1995年11月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tatu Ylonen SSH Communications Security Corp Valimotie 17 00380 Helsinki Finland",
      "ja": "タトゥYlonenとSSHコミュニケーションズ・セキュリティ社Valimotie 17 00380ヘルシンキフィンランド"
    },
    {
      "indent": 3,
      "text": "EMail: ylo@ssh.com",
      "ja": "メールアドレス：ylo@ssh.com"
    },
    {
      "indent": 3,
      "text": "Chris Lonvick (editor) Cisco Systems, Inc. 12515 Research Blvd. Austin 78759 USA",
      "ja": "クリスLonvick（エディタ）は、シスコシステムズ、株式会社12515リサーチ・ブルバードオースティン78759 USA"
    },
    {
      "indent": 3,
      "text": "EMail: clonvick@cisco.com",
      "ja": "メールアドレス：clonvick@cisco.com"
    },
    {
      "indent": 0,
      "text": "Trademark Notice",
      "ja": "商標について"
    },
    {
      "indent": 3,
      "text": "\"ssh\" is a registered trademark in the United States and/or other countries.",
      "ja": "「SSHは」米国および/またはその他の国における登録商標または商標です。"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディタ機能のための資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}