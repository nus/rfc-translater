{
  "title": {
    "text": "RFC 4492 - Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)",
    "ja": "RFC 4492 - 楕円曲線暗号（ECC）トランスポート層セキュリティのための暗号スイート（TLS）"
  },
  "number": 4492,
  "created_at": "2019-10-25 19:10:25.876419+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                    S. Blake-Wilson\nRequest for Comments: 4492                                       SafeNet\nCategory: Informational                                       N. Bolyard\n                                                        Sun Microsystems\n                                                                V. Gupta\n                                                                Sun Labs\n                                                                 C. Hawk\n                                                               Corriente\n                                                              B. Moeller\n                                                         Ruhr-Uni Bochum\n                                                                May 2006",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Elliptic Curve Cryptography (ECC) Cipher Suites\n       for Transport Layer Security (TLS)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes new key exchange algorithms based on Elliptic Curve Cryptography (ECC) for the Transport Layer Security (TLS) protocol. In particular, it specifies the use of Elliptic Curve Diffie-Hellman (ECDH) key agreement in a TLS handshake and the use of Elliptic Curve Digital Signature Algorithm (ECDSA) as a new authentication mechanism.",
      "ja": "この文書では、トランスポート層セキュリティ（TLS）プロトコルの楕円曲線暗号（ECC）に基づいて新しい鍵交換アルゴリズムを説明します。特に、新たな認証機構として楕円曲線ディフィ - ヘルマン（ECDH）TLSハンドシェイクと楕円曲線デジタル署名アルゴリズム（ECDSA）の使用でキー合意の使用を指定します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Key Exchange Algorithms .........................................4\n   2.1. ECDH_ECDSA .................................................6\n   2.2. ECDHE_ECDSA ................................................6\n   2.3. ECDH_RSA ...................................................7\n   2.4. ECDHE_RSA ..................................................7\n   2.5. ECDH_anon ..................................................7\n3. Client Authentication ...........................................8\n   3.1. ECDSA_sign .................................................8\n   3.2. ECDSA_fixed_ECDH ...........................................9\n   3.3. RSA_fixed_ECDH .............................................9\n4. TLS Extensions for ECC ..........................................9\n5. Data Structures and Computations ...............................10\n   5.1. Client Hello Extensions ...................................10\n        5.1.1. Supported Elliptic Curves Extension ................12\n        5.1.2. Supported Point Formats Extension ..................13\n   5.2. Server Hello Extension ....................................14\n   5.3. Server Certificate ........................................15\n   5.4. Server Key Exchange .......................................17\n   5.5. Certificate Request .......................................21\n   5.6. Client Certificate ........................................22\n   5.7. Client Key Exchange .......................................23\n   5.8. Certificate Verify ........................................25\n   5.9. Elliptic Curve Certificates ...............................26\n   5.10. ECDH, ECDSA, and RSA Computations ........................26\n6. Cipher Suites ..................................................27\n7. Security Considerations ........................................28\n8. IANA Considerations ............................................29\n9. Acknowledgements ...............................................29\n10. References ....................................................30\n   10.1. Normative References .....................................30\n   10.2. Informative References ...................................31\nAppendix A.  Equivalent Curves (Informative) ......................32",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Elliptic Curve Cryptography (ECC) is emerging as an attractive public-key cryptosystem, in particular for mobile (i.e., wireless) environments. Compared to currently prevalent cryptosystems such as RSA, ECC offers equivalent security with smaller key sizes. This is illustrated in the following table, based on [18], which gives approximate comparable key sizes for symmetric- and asymmetric-key cryptosystems based on the best-known algorithms for attacking them.",
      "ja": "楕円曲線暗号（ECC）は、移動（即ち、ワイヤレス）環境のために、特に魅力的な公開鍵暗号として浮上しています。 RSAなど、現在普及している暗号に比べ、ECCは、より小さなキーサイズで同等のセキュリティを提供しています。これは、それらを攻撃するための最もよく知られたアルゴリズムに基づいてsymmetric-と非対称鍵暗号のためのおおよそ匹敵する鍵サイズを与える[18]に基づいて、以下の表に示されています。"
    },
    {
      "indent": 19,
      "text": " Symmetric  |   ECC   |  DH/DSA/RSA\n------------+---------+-------------\n     80     |   163   |     1024\n    112     |   233   |     2048\n    128     |   283   |     3072\n    192     |   409   |     7680\n    256     |   571   |    15360",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Table 1: Comparable Key Sizes (in bits)",
      "ja": "表1：（ビットで）同等の鍵のサイズ"
    },
    {
      "indent": 3,
      "text": "Smaller key sizes result in savings for power, memory, bandwidth, and computational cost that make ECC especially attractive for constrained environments.",
      "ja": "小さいキーサイズが限られた環境のためのECCが特に魅力的パワー、メモリ、帯域幅、および計算コストのための節約になります。"
    },
    {
      "indent": 3,
      "text": "This document describes additions to TLS to support ECC, applicable both to TLS Version 1.0 [2] and to TLS Version 1.1 [3]. In particular, it defines",
      "ja": "この文書では、[2]とTLSバージョン1.1にTLSバージョン1.0の両方に適用可能なECCをサポートするために、TLSへの追加を説明する[3]。特に、それは定義します"
    },
    {
      "indent": 3,
      "text": "o the use of the Elliptic Curve Diffie-Hellman (ECDH) key agreement scheme with long-term or ephemeral keys to establish the TLS premaster secret, and",
      "ja": "TLSのプレマスターシークレットを確立するために、長期的または一時的なキーを持つ楕円曲線のDiffie-Hellmanの（ECDH）キー合意方式を使用O、および"
    },
    {
      "indent": 3,
      "text": "o the use of fixed-ECDH certificates and ECDSA for authentication of TLS peers.",
      "ja": "TLSピアの認証のための固定ECDH証明書とECDSAの使用O。"
    },
    {
      "indent": 3,
      "text": "The remainder of this document is organized as follows. Section 2 provides an overview of ECC-based key exchange algorithms for TLS. Section 3 describes the use of ECC certificates for client authentication. TLS extensions that allow a client to negotiate the use of specific curves and point formats are presented in Section 4. Section 5 specifies various data structures needed for an ECC-based handshake, their encoding in TLS messages, and the processing of those messages. Section 6 defines new ECC-based cipher suites and identifies a small subset of these as recommended for all implementations of this specification. Section 7 discusses security considerations. Section 8 describes IANA considerations for the name spaces created by this document. Section 9 gives acknowledgements.",
      "ja": "このドキュメントの残りは以下の通り構成されています。第2節では、TLSのためのECCベースの鍵交換アルゴリズムの概要を説明します。第3節では、クライアント認証のためのECC証明書の使用を記載しています。クライアントが特定の曲線と点フォーマットの使用を交渉することができTLS拡張機能は、第4節第5節で提示されている各種データECCベースのハンドシェイクのために必要な構造、TLSメッセージでのエンコーディング、およびそれらのメッセージの処理を指定します。セクション6は、新しいECCベースの暗号スイートを定義し、本明細書のすべての実装のために推奨されているように、これらの小さなサブセットを識別する。第7節は、セキュリティ上の考慮事項について説明します。第8節は、この文書で作成された名前空間のためのIANAの考慮事項について説明します。第9節は、確認応答を提供します。"
    },
    {
      "indent": 3,
      "text": "This is followed by the lists of normative and informative references cited in this document, the authors' contact information, and statements on intellectual property rights and copyrights.",
      "ja": "これは規範的で有益な本文書に引用された参考文献、著者の連絡先情報、および知的財産権と著作権上の文のリストが続いています。"
    },
    {
      "indent": 3,
      "text": "Implementation of this specification requires familiarity with TLS [2][3], TLS extensions [4], and ECC [5][6][7][11][17].",
      "ja": "この仕様の実装は、TLSに精通している必要があり[2] [3]、TLS拡張子[4]、及びECC [5] [6] [7] [11] [17]。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [1].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119に記載されるように解釈される[1]。"
    },
    {
      "indent": 0,
      "text": "2. Key Exchange Algorithms",
      "section_title": true,
      "ja": "2.鍵交換アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This document introduces five new ECC-based key exchange algorithms for TLS. All of them use ECDH to compute the TLS premaster secret, and they differ only in the lifetime of ECDH keys (long-term or ephemeral) and the mechanism (if any) used to authenticate them. The derivation of the TLS master secret from the premaster secret and the subsequent generation of bulk encryption/MAC keys and initialization vectors is independent of the key exchange algorithm and not impacted by the introduction of ECC.",
      "ja": "このドキュメントは、TLSのための5つの新しいECCベースの鍵交換アルゴリズムを導入しています。それらのすべては、TLSプレマスターの秘密を計算するためにECDHを使用して、彼らは唯一のECDHキー（長期的または一時的）と、それらを認証するために使用されるメカニズム（もしあれば）の寿命が異なります。前マスターシークレットからTLSマスターシークレットの導出およびバルク暗号化/ MACキーと初期化ベクトルの次の世代は、鍵交換アルゴリズムとは無関係であり、ECCの導入によって影響を受けません。"
    },
    {
      "indent": 3,
      "text": "The table below summarizes the new key exchange algorithms, which mimic DH_DSS, DHE_DSS, DH_RSA, DHE_RSA, and DH_anon (see [2] and [3]), respectively.",
      "ja": "以下の表はDH_DSS、DHE_DSS、DH_RSA、DHE_RSAを模倣する新しい鍵交換アルゴリズムを、要約、及びDH_anonは、それぞれ、（[2]、[3]参照します）。"
    },
    {
      "indent": 10,
      "text": "Key\nExchange\nAlgorithm           Description\n---------           -----------",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ECDH_ECDSA Fixed ECDH with ECDSA-signed certificates.",
      "ja": "ECDSA署名証明書を持つECDH_ECDSA固定ECDH。"
    },
    {
      "indent": 10,
      "text": "ECDHE_ECDSA Ephemeral ECDH with ECDSA signatures.",
      "ja": "ECDSA署名付きECDHE_ECDSAエフェメラルECDH。"
    },
    {
      "indent": 10,
      "text": "ECDH_RSA Fixed ECDH with RSA-signed certificates.",
      "ja": "RSA署名付き証明書とECDH_RSA固定ECDH。"
    },
    {
      "indent": 10,
      "text": "ECDHE_RSA Ephemeral ECDH with RSA signatures.",
      "ja": "RSA署名付きECDHE_RSAエフェメラルECDH。"
    },
    {
      "indent": 10,
      "text": "ECDH_anon Anonymous ECDH, no signatures.",
      "ja": "ECDH_anon匿名ECDH、無署名。"
    },
    {
      "indent": 21,
      "text": "Table 2: ECC Key Exchange Algorithms",
      "ja": "表2：ECC鍵交換アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The ECDHE_ECDSA and ECDHE_RSA key exchange mechanisms provide forward secrecy. With ECDHE_RSA, a server can reuse its existing RSA certificate and easily comply with a constrained client's elliptic curve preferences (see Section 4). However, the computational cost",
      "ja": "ECDHE_ECDSAとECDHE_RSA鍵交換メカニズムは前進の秘密保持を提供しています。 ECDHE_RSAでは、サーバーは、既存のRSA証明書を再利用することができ、容易に制約クライアントの楕円曲線の嗜好（セクション4を参照）に準拠しています。しかし、計算コスト"
    },
    {
      "indent": 3,
      "text": "incurred by a server is higher for ECDHE_RSA than for the traditional RSA key exchange, which does not provide forward secrecy.",
      "ja": "サーバーによって被っは前進の秘密保持を提供していない従来のRSA鍵交換のためのよりECDHE_RSAの方が高いです。"
    },
    {
      "indent": 3,
      "text": "The ECDH_RSA mechanism requires a server to acquire an ECC certificate, but the certificate issuer can still use an existing RSA key for signing. This eliminates the need to update the keys of trusted certification authorities accepted by TLS clients. The ECDH_ECDSA mechanism requires ECC keys for the server as well as the certification authority and is best suited for constrained devices unable to support RSA.",
      "ja": "ECDH_RSAメカニズムは、ECC証明書を取得するためのサーバーを必要としますが、証明書発行者は、まだ署名のための既存のRSAキーを使用することができます。これは、TLSクライアントによって受け入れられ、信頼できる認証局の鍵を更新する必要がなくなります。 ECDH_ECDSAメカニズムは、サーバ用のECCキーだけでなく、認証局を必要とし、RSAをサポートすることができない制約のあるデバイスに最適です。"
    },
    {
      "indent": 3,
      "text": "The anonymous key exchange algorithm does not provide authentication of the server or the client. Like other anonymous TLS key exchanges, it is subject to man-in-the-middle attacks. Implementations of this algorithm SHOULD provide authentication by other means.",
      "ja": "匿名の鍵交換アルゴリズムは、サーバーまたはクライアントの認証を提供していません。他の匿名TLSキーの交換と同様に、man-in-the-middle攻撃の対象となります。このアルゴリズムの実装は、他の手段で認証を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that there is no structural difference between ECDH and ECDSA keys. A certificate issuer may use X.509 v3 keyUsage and extendedKeyUsage extensions to restrict the use of an ECC public key to certain computations [15]. This document refers to an ECC key as ECDH-capable if its use in ECDH is permitted. ECDSA-capable is defined similarly.",
      "ja": "ECDHとECDSAキーの間には構造的な差がないことに注意してください。証明書発行者は、特定の計算[15]にECC公開鍵の使用を制限するX.509 v3のののkeyUsageとextendedKeyUsageの拡張機能を使用することができます。 ECDHにおけるその使用が許可された場合、この文書はECDH対応としてECCキーを指します。対応ECDSAは、同様に定義されます。"
    },
    {
      "indent": 14,
      "text": "Client                                        Server\n------                                        ------",
      "raw": true
    },
    {
      "indent": 14,
      "text": "ClientHello          -------->\n                                         ServerHello\n                                        Certificate*\n                                  ServerKeyExchange*\n                                CertificateRequest*+\n                     <--------       ServerHelloDone\nCertificate*+\nClientKeyExchange\nCertificateVerify*+\n[ChangeCipherSpec]\nFinished             -------->\n                                  [ChangeCipherSpec]\n                     <--------              Finished",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Application Data     <------->      Application Data",
      "raw": true
    },
    {
      "indent": 19,
      "text": "* message is not sent under some conditions\n+ message is not sent unless client authentication\n  is desired",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 1: Message flow in a full TLS handshake",
      "ja": "図1：フルTLSハンドシェイクでのメッセージの流れ"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows all messages involved in the TLS key establishment protocol (aka full handshake). The addition of ECC has direct impact only on the ClientHello, the ServerHello, the server's Certificate message, the ServerKeyExchange, the ClientKeyExchange, the CertificateRequest, the client's Certificate message, and the CertificateVerify. Next, we describe each ECC key exchange algorithm in greater detail in terms of the content and processing of these messages. For ease of exposition, we defer discussion of client authentication and associated messages (identified with a + in Figure 1) until Section 3 and of the optional ECC-specific extensions (which impact the Hello messages) until Section 4.",
      "ja": "図1は、TLS鍵確立プロトコル（別名フルハンドシェーク）に関与するすべてのメッセージを示しています。 ECCの添加は唯一のClientHelloに直接影響を持っている、のServerHello、サーバのCertificateメッセージ、ServerKeyExchange、ClientKeyExchange、CertificateRequest、クライアントの証明書のメッセージ、およびCertificateVerify。次に、我々はこれらのメッセージの内容及び処理の面でより詳細に各ECC鍵交換アルゴリズムを記述します。説明の容易さのために、我々は、第3節まで、クライアントの認証と（図1の+と同定された）関連するメッセージの議論を延期し、任意ECC固有の拡張（耐衝撃Helloメッセージ）の第4章まで。"
    },
    {
      "indent": 0,
      "text": "2.1. ECDH_ECDSA",
      "section_title": true,
      "ja": "2.1.  ECDH_ECDSA"
    },
    {
      "indent": 3,
      "text": "In ECDH_ECDSA, the server's certificate MUST contain an ECDH-capable public key and be signed with ECDSA.",
      "ja": "ECDH_ECDSAでは、サーバーの証明書がECDH可能な公開鍵を含まなければならないし、ECDSAで署名します。"
    },
    {
      "indent": 3,
      "text": "A ServerKeyExchange MUST NOT be sent (the server's certificate contains all the necessary keying information required by the client to arrive at the premaster secret).",
      "ja": "ServerKeyExchangeは（サーバの証明書は、このpremaster_secretに到着するためにクライアントが必要とするすべての必要な鍵情報が含まれています）を送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "The client generates an ECDH key pair on the same curve as the server's long-term public key and sends its public key in the ClientKeyExchange message (except when using client authentication algorithm ECDSA_fixed_ECDH or RSA_fixed_ECDH, in which case the modifications from Section 3.2 or Section 3.3 apply).",
      "ja": "クライアントは、サーバの長期の公開鍵と同じ曲線にECDH鍵ペアを生成し、クライアント認証アルゴリズムECDSA_fixed_ECDH又はRSA_fixed_ECDHを使用する場合を除き、（ClientKeyExchangeメッセージにその公開鍵を送信する場合、セクション3.2または3.3節から修飾に）適用されます。"
    },
    {
      "indent": 3,
      "text": "Both client and server perform an ECDH operation and use the resultant shared secret as the premaster secret. All ECDH calculations are performed as specified in Section 5.10.",
      "ja": "クライアントとサーバーの両方がECDH操作を実行し、このpremaster_secretとして結果の共有秘密鍵を使用しています。 5.10節に指定されているすべてのECDH計算が実行されます。"
    },
    {
      "indent": 0,
      "text": "2.2. ECDHE_ECDSA",
      "section_title": true,
      "ja": "2.2.  ECDHE_ECDSA"
    },
    {
      "indent": 3,
      "text": "In ECDHE_ECDSA, the server's certificate MUST contain an ECDSA-capable public key and be signed with ECDSA.",
      "ja": "ECDHE_ECDSAでは、サーバーの証明書がECDSA可能な公開鍵を含まなければならないし、ECDSAで署名します。"
    },
    {
      "indent": 3,
      "text": "The server sends its ephemeral ECDH public key and a specification of the corresponding curve in the ServerKeyExchange message. These parameters MUST be signed with ECDSA using the private key corresponding to the public key in the server's Certificate.",
      "ja": "サーバーは、そのはかないECDH公開鍵とServerKeyExchangeメッセージに対応する曲線の仕様を送信します。これらのパラメータは、サーバの証明書の公開鍵に対応する秘密鍵を使用して、ECDSAで署名する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client generates an ECDH key pair on the same curve as the server's ephemeral ECDH key and sends its public key in the ClientKeyExchange message.",
      "ja": "クライアントは、サーバのはかないECDHキーと同じ曲線上ECDH鍵のペアを生成し、ClientKeyExchangeメッセージに公開鍵を送信します。"
    },
    {
      "indent": 3,
      "text": "Both client and server perform an ECDH operation (Section 5.10) and use the resultant shared secret as the premaster secret.",
      "ja": "クライアントとサーバーの両方がECDH操作（5.10）を実行し、このpremaster_secretとして結果の共有秘密鍵を使用しています。"
    },
    {
      "indent": 0,
      "text": "2.3. ECDH_RSA",
      "section_title": true,
      "ja": "2.3.  ECDH_RSA"
    },
    {
      "indent": 3,
      "text": "This key exchange algorithm is the same as ECDH_ECDSA except that the server's certificate MUST be signed with RSA rather than ECDSA.",
      "ja": "この鍵交換アルゴリズムは、サーバーの証明書は、RSAではなくECDSAで署名しなければならないことを除いてECDH_ECDSAと同じです。"
    },
    {
      "indent": 0,
      "text": "2.4. ECDHE_RSA",
      "section_title": true,
      "ja": "2.4.  ECDHE_RSA"
    },
    {
      "indent": 3,
      "text": "This key exchange algorithm is the same as ECDHE_ECDSA except that the server's certificate MUST contain an RSA public key authorized for signing, and that the signature in the ServerKeyExchange message must be computed with the corresponding RSA private key. The server certificate MUST be signed with RSA.",
      "ja": "この鍵交換アルゴリズムは、サーバーの証明書は、署名のための認可RSA公開鍵が含まれており、ServerKeyExchangeメッセージに署名が対応するRSA秘密鍵で計算しなければならない必要があることを除いてECDHE_ECDSAと同じです。サーバ証明書は、RSAで署名されなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.5. ECDH_anon",
      "section_title": true,
      "ja": "2.5.  ECDH_anon"
    },
    {
      "indent": 3,
      "text": "In ECDH_anon, the server's Certificate, the CertificateRequest, the client's Certificate, and the CertificateVerify messages MUST NOT be sent.",
      "ja": "ECDH_anon、サーバーの証明書では、CertificateRequest、クライアントの証明書、およびCertificateVerifyメッセージを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "The server MUST send an ephemeral ECDH public key and a specification of the corresponding curve in the ServerKeyExchange message. These parameters MUST NOT be signed.",
      "ja": "サーバは、はかないECDH公開鍵とServerKeyExchangeメッセージに対応する曲線の仕様を送らなければなりません。これらのパラメータは、署名してはなりません。"
    },
    {
      "indent": 3,
      "text": "The client generates an ECDH key pair on the same curve as the server's ephemeral ECDH key and sends its public key in the ClientKeyExchange message.",
      "ja": "クライアントは、サーバのはかないECDHキーと同じ曲線上ECDH鍵のペアを生成し、ClientKeyExchangeメッセージに公開鍵を送信します。"
    },
    {
      "indent": 3,
      "text": "Both client and server perform an ECDH operation and use the resultant shared secret as the premaster secret. All ECDH calculations are performed as specified in Section 5.10.",
      "ja": "クライアントとサーバーの両方がECDH操作を実行し、このpremaster_secretとして結果の共有秘密鍵を使用しています。 5.10節に指定されているすべてのECDH計算が実行されます。"
    },
    {
      "indent": 3,
      "text": "Note that while the ECDH_ECDSA, ECDHE_ECDSA, ECDH_RSA, and ECDHE_RSA key exchange algorithms require the server's certificate to be signed with a particular signature scheme, this specification (following the similar cases of DH_DSS, DHE_DSS, DH_RSA, and DHE_RSA in [2] and [3]) does not impose restrictions on signature schemes used elsewhere in the certificate chain. (Often such restrictions will be useful, and it is expected that this will be taken into account in certification authorities' signing practices. However, such restrictions are not strictly required in general: Even if it is beyond the capabilities of a client to completely validate a given chain, the client may be able to validate the server's certificate by relying on a trusted certification authority whose certificate appears as one of the intermediate certificates in the chain.)",
      "ja": "[2]でDH_DSS、DHE_DSS、DH_RSA、及びDHE_RSAの類似事例以下（本明細書、ECDH_ECDSA、ECDHE_ECDSA、ECDH_RSA、及びECDHE_RSA鍵交換アルゴリズムは、特定の署名方式で署名するサーバの証明書を必要とすることに注意してください[ 3]）証明書チェーン内の他の場所で使用される署名方式に制限を課しません。 （多くの場合、そのような制限は有用であろう、そして証明当局の署名実践する際に考慮されることが予想されるが、そのような制限が厳しく、一般的には必要とされていません：それは、クライアントの能力を超えている場合であっても、完全に検証します与えられたチェーンは、クライアントは、その証明書チェーン内の中間証明書の1つとして表示されます、信頼できる認証局に依存することによって、サーバーの証明書を検証することができるかもしれません。）"
    },
    {
      "indent": 0,
      "text": "3. Client Authentication",
      "section_title": true,
      "ja": "3.クライアント認証"
    },
    {
      "indent": 3,
      "text": "This document defines three new client authentication mechanisms, each named after the type of client certificate involved: ECDSA_sign, ECDSA_fixed_ECDH, and RSA_fixed_ECDH. The ECDSA_sign mechanism is usable with any of the non-anonymous ECC key exchange algorithms described in Section 2 as well as other non-anonymous (non-ECC) key exchange algorithms defined in TLS [2][3]. The ECDSA_fixed_ECDH and RSA_fixed_ECDH mechanisms are usable with ECDH_ECDSA and ECDH_RSA. Their use with ECDHE_ECDSA and ECDHE_RSA is prohibited because the use of a long-term ECDH client key would jeopardize the forward secrecy property of these algorithms.",
      "ja": "ECDSA_sign、ECDSA_fixed_ECDH、およびRSA_fixed_ECDH：この文書は、関係するクライアント証明書の種類にちなんで名付けられた3つの新しいクライアント認証メカニズム、それぞれを定義します。 ECDSA_sign機構は、非匿名項2に記載のECC鍵交換アルゴリズムならびにTLSで定義された他の非匿名（非ECC）鍵交換アルゴリズムのいずれかで使用可能である[2] [3]。 ECDSA_fixed_ECDHとRSA_fixed_ECDHメカニズムはECDH_ECDSAとECDH_RSAで使用可能です。長期ECDHクライアントキーの使用は、これらのアルゴリズムの前進の秘密保持性が危うくなるのでECDHE_ECDSAとECDHE_RSAとその使用は禁止されています。"
    },
    {
      "indent": 3,
      "text": "The server can request ECC-based client authentication by including one or more of these certificate types in its CertificateRequest message. The server must not include any certificate types that are prohibited for the negotiated key exchange algorithm. The client must check if it possesses a certificate appropriate for any of the methods suggested by the server and is willing to use it for authentication.",
      "ja": "サーバーは、そのCertificateRequestメッセージにこれらの証明書の種類の一つ以上を含むことにより、ECCベースのクライアント認証を要求することができます。サーバは、ネゴシエート鍵交換アルゴリズムのために禁止されているすべての証明書の種類を含めることはできません。それは、サーバによって提案された方法のいずれかの証明書の適切なを所有し、認証のためにそれを使用して喜んでいる場合、クライアントは確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "If these conditions are not met, the client should send a client Certificate message containing no certificates. In this case, the ClientKeyExchange should be sent as described in Section 2, and the CertificateVerify should not be sent. If the server requires client authentication, it may respond with a fatal handshake failure alert.",
      "ja": "これらの条件が満たされない場合、クライアントには、証明書を含まないクライアント証明書のメッセージを送信する必要があります。この場合には、セクション2で説明したようにClientKeyExchangeが送信されるべきであり、CertificateVerifyが送信されるべきではありません。サーバーがクライアント認証を必要とする場合、それは致命的な握手故障警報で応答することができます。"
    },
    {
      "indent": 3,
      "text": "If the client has an appropriate certificate and is willing to use it for authentication, it must send that certificate in the client's Certificate message (as per Section 5.6) and prove possession of the private key corresponding to the certified key. The process of determining an appropriate certificate and proving possession is different for each authentication mechanism and described below.",
      "ja": "クライアントは、適切な証明書を持っており、認証のためにそれを使用する意思があるなら、それは（5.6節に従って）、クライアントの証明書のメッセージでその証明書を送信し、認証されたキーに対応する秘密鍵の所有を証明しなければなりません。適切な証明書を決定し、所有を証明するプロセスは、各認証機構のために異なって以下に説明します。"
    },
    {
      "indent": 3,
      "text": "NOTE: It is permissible for a server to request (and the client to send) a client certificate of a different type than the server certificate.",
      "ja": "注：サーバ証明書とは異なるタイプのクライアント証明書をサーバーに要求する（そして、クライアントが送信する）ことが許されます。"
    },
    {
      "indent": 0,
      "text": "3.1. ECDSA_sign",
      "section_title": true,
      "ja": "3.1.  ECDSA_sign"
    },
    {
      "indent": 3,
      "text": "To use this authentication mechanism, the client MUST possess a certificate containing an ECDSA-capable public key and signed with ECDSA.",
      "ja": "この認証メカニズムを使用するには、クライアントは、ECDSA可能な公開鍵とECDSAで署名を含む証明書を持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "The client proves possession of the private key corresponding to the certified key by including a signature in the CertificateVerify message as described in Section 5.8.",
      "ja": "クライアントは、5.8節で説明したようにCertificateVerifyメッセージに署名を含めることによって認定されたキーに対応する秘密鍵の所有を証明しています。"
    },
    {
      "indent": 0,
      "text": "3.2. ECDSA_fixed_ECDH",
      "section_title": true,
      "ja": "3.2.  ECDSA_fixed_ECDH"
    },
    {
      "indent": 3,
      "text": "To use this authentication mechanism, the client MUST possess a certificate containing an ECDH-capable public key, and that certificate MUST be signed with ECDSA. Furthermore, the client's ECDH key MUST be on the same elliptic curve as the server's long-term (certified) ECDH key. This might limit use of this mechanism to closed environments. In situations where the client has an ECC key on a different curve, it would have to authenticate using either ECDSA_sign or a non-ECC mechanism (e.g., RSA). Using fixed ECDH for both servers and clients is computationally more efficient than mechanisms providing forward secrecy.",
      "ja": "この認証メカニズムを使用するには、クライアントはECDH可能な公開鍵を含む証明書を持っている必要があり、その証明書はECDSAで署名されなければなりません。さらに、クライアントのECDHキーは、サーバーの長期（認定）ECDHキーと同じ楕円曲線上にある必要があります。これは、閉じた環境に、このメカニズムの使用が制限される場合があります。クライアントは異なる曲線上のECCキーを有している状況では、ECDSA_signまたは非ECC機構（例えば、RSA）のいずれかを使用して認証しなければなりません。サーバーとクライアントの両方に固定ECDHを使用すると、計算上、より効率的な前進の秘密保持を提供するメカニズムを超えています。"
    },
    {
      "indent": 3,
      "text": "When using this authentication mechanism, the client MUST send an empty ClientKeyExchange as described in Section 5.7 and MUST NOT send the CertificateVerify message. The ClientKeyExchange is empty since the client's ECDH public key required by the server to compute the premaster secret is available inside the client's certificate. The client's ability to arrive at the same premaster secret as the server (demonstrated by a successful exchange of Finished messages) proves possession of the private key corresponding to the certified public key, and the CertificateVerify message is unnecessary.",
      "ja": "この認証メカニズムを使用する場合は、セクション5.7で説明したCertificateVerifyメッセージを送ってはいけませんと、クライアントは空ClientKeyExchangeを送らなければなりません。プレマスターシークレットを計算するためにサーバに必要なクライアントのECDH公開鍵がクライアントの証明書内で使用可能であるため、ClientKeyExchangeは空です。 （Finishedメッセージの成功交換によって立証）サーバーと同じプリマスターの秘密に到達するクライアントの能力は、認定された公開鍵に対応する秘密鍵の所有を証明し、CertificateVerifyメッセージは不要です。"
    },
    {
      "indent": 0,
      "text": "3.3. RSA_fixed_ECDH",
      "section_title": true,
      "ja": "3.3.  RSA_fixed_ECDH"
    },
    {
      "indent": 3,
      "text": "This authentication mechanism is identical to ECDSA_fixed_ECDH except that the client's certificate MUST be signed with RSA.",
      "ja": "この認証メカニズムは、クライアントの証明書は、RSAで署名しなければならないことを除いてECDSA_fixed_ECDHと同じです。"
    },
    {
      "indent": 3,
      "text": "Note that while the ECDSA_sign, ECDSA_fixed_ECDH, and RSA_fixed_ECDH client authentication mechanisms require the client's certificate to be signed with a particular signature scheme, this specification does not impose restrictions on signature schemes used elsewhere in the certificate chain. (Often such restrictions will be useful, and it is expected that this will be taken into account in certification authorities' signing practices. However, such restrictions are not strictly required in general: Even if it is beyond the capabilities of a server to completely validate a given chain, the server may be able to validate the clients certificate by relying on a trust anchor that appears as one of the intermediate certificates in the chain.)",
      "ja": "ECDSA_sign、ECDSA_fixed_ECDH、及びRSA_fixed_ECDHクライアント認証メカニズムは、特定の署名方式で署名するクライアントの証明書を必要とする、本明細書は、証明書チェーン内の他の場所で使用される署名方式に制限を課さないことに留意されたいです。 （多くの場合、そのような制限は有用であろう、そして証明当局の署名実践する際に考慮されることが予想されるが、そのような制限が厳しく、一般的には必要とされていません：それは、サーバの能力を超えている場合であっても、完全に検証します与えられたチェーンは、サーバーは、チェーンの中間証明書の1つとして表示されますトラストアンカーに依存することによって、クライアント証明書を検証することができるかもしれません。）"
    },
    {
      "indent": 0,
      "text": "4. TLS Extensions for ECC",
      "section_title": true,
      "ja": "ECC 4. TLS拡張"
    },
    {
      "indent": 3,
      "text": "Two new TLS extensions are defined in this specification: (i) the Supported Elliptic Curves Extension, and (ii) the Supported Point Formats Extension. These allow negotiating the use of specific curves and point formats (e.g., compressed vs. uncompressed, respectively) during a handshake starting a new session. These extensions are especially relevant for constrained clients that may only support a limited number of curves or point formats. They follow the general approach outlined in [4]; message details are specified in Section 5. The client enumerates the curves it supports and the point formats it can parse by including the appropriate extensions in its ClientHello message. The server similarly enumerates the point formats it can parse by including an extension in its ServerHello message.",
      "ja": "（ⅰ）サポートされている楕円曲線拡張、および（ii）サポートされている小数点形式拡張子：二つの新しいTLS拡張はこの仕様で定義されています。これらは、特定の曲線と点フォーマットの使用を交渉することを可能に新しいセッションを開始ハンドシェーク中（例えば、それぞれ、非圧縮対圧縮）。これらの拡張機能はカーブやポイント形式の限られた数をサポートすることが可能に制約のクライアントのために特に関連しています。これらは、[4]に記載の一般的なアプローチに従います。メッセージの詳細はセクション5で指定されたクライアントは、それがサポートするカーブと、それはそのClientHelloメッセージに適切な拡張子を含めることによって解析できるポイント形式を列挙します。サーバは、同様に、そのServerHelloメッセージに拡張を含めることによって解析できる点フォーマットを列挙する。"
    },
    {
      "indent": 3,
      "text": "A TLS client that proposes ECC cipher suites in its ClientHello message SHOULD include these extensions. Servers implementing ECC cipher suites MUST support these extensions, and when a client uses these extensions, servers MUST NOT negotiate the use of an ECC cipher suite unless they can complete the handshake while respecting the choice of curves and compression techniques specified by the client. This eliminates the possibility that a negotiated ECC handshake will be subsequently aborted due to a client's inability to deal with the server's EC key.",
      "ja": "そのClientHelloメッセージでECC暗号スイートを提案しているTLSクライアントは、これらの拡張を含むべきです。 ECC暗号スイートを実装したサーバは、これらの拡張をサポートしなければならない、そしてクライアントがこれらの拡張機能を使用する場合、クライアントによって指定された曲線と圧縮技術の選択を尊重しながら、彼らは握手を完了することができない限り、サーバーは、ECC暗号スイートの使用を交渉してはなりません。これは、交渉されたECC握手がその後により、サーバのECキーに対処するために、クライアントのできないために中止される可能性を排除します。"
    },
    {
      "indent": 3,
      "text": "The client MUST NOT include these extensions in the ClientHello message if it does not propose any ECC cipher suites. A client that proposes ECC cipher suites may choose not to include these extensions. In this case, the server is free to choose any one of the elliptic curves or point formats listed in Section 5. That section also describes the structure and processing of these extensions in greater detail.",
      "ja": "それは任意のECC暗号スイートを提案していない場合、クライアントはClientHelloメッセージにこれらの拡張機能を含んではいけません。 ECC暗号スイートを提案しているクライアントは、これらの拡張を含めないことを選択することができます。この場合、サーバは、セクションはまた、より詳細にこれらの拡張の構造と処理を記述した楕円曲線またはセクション5に記載されている点フォーマットのいずれかを選択する自由です。"
    },
    {
      "indent": 3,
      "text": "In the case of session resumption, the server simply ignores the Supported Elliptic Curves Extension and the Supported Point Formats Extension appearing in the current ClientHello message. These extensions only play a role during handshakes negotiating a new session.",
      "ja": "セッション再開の場合、サーバは単にサポートされている楕円曲線拡張し、現在のClientHelloメッセージに表示されてサポートされている小数点形式拡張子を無視します。これらの拡張機能は、新しいセッションを交渉ハンドシェイク中に役割を果たしています。"
    },
    {
      "indent": 0,
      "text": "5. Data Structures and Computations",
      "section_title": true,
      "ja": "5.データ構造と計算"
    },
    {
      "indent": 3,
      "text": "This section specifies the data structures and computations used by ECC-based key mechanisms specified in Sections 2, 3, and 4. The presentation language used here is the same as that used in TLS [2][3]. Since this specification extends TLS, these descriptions should be merged with those in the TLS specification and any others that extend TLS. This means that enum types may not specify all possible values, and structures with multiple formats chosen with a select() clause may not indicate all possible cases.",
      "ja": "このセクションでは、セクション2、3で指定されたECCベースのキーメカニズムによって使用されるデータ構造及び計算を指定し、ここで使用される4プレゼンテーション言語は、TLSで用いたものと同じである[2] [3]。この仕様は、TLSを拡張するため、これらの説明は、TLS仕様とTLSを拡張する任意の他のものとマージされるべきです。これは、列挙タイプは、すべての可能なケースを示していてもよいセレクト（）句を使用して選択された複数のフォーマットを有する全ての可能な値、および構造を指定しなくてもよいことを意味します。"
    },
    {
      "indent": 0,
      "text": "5.1. Client Hello Extensions",
      "section_title": true,
      "ja": "5.1. クライアントこんにちは拡張"
    },
    {
      "indent": 3,
      "text": "This section specifies two TLS extensions that can be included with the ClientHello message as described in [4], the Supported Elliptic Curves Extension and the Supported Point Formats Extension.",
      "ja": "このセクションでは、に記載されているようにClientHelloメッセージに含めることができる2つのTLS拡張子を指定し[4]、サポートされている楕円曲線拡張及びサポート点フォーマットの拡張。"
    },
    {
      "indent": 3,
      "text": "When these extensions are sent:",
      "ja": "これらの拡張機能は、送信された場合："
    },
    {
      "indent": 3,
      "text": "The extensions SHOULD be sent along with any ClientHello message that proposes ECC cipher suites.",
      "ja": "拡張機能は、ECC暗号スイートを提案している任意のClientHelloメッセージと一緒に送ってください。"
    },
    {
      "indent": 3,
      "text": "Meaning of these extensions:",
      "ja": "これらの拡張機能の意味："
    },
    {
      "indent": 3,
      "text": "These extensions allow a client to enumerate the elliptic curves it supports and/or the point formats it can parse.",
      "ja": "これらの拡張機能は、クライアントがそれをサポートしている楕円曲線および/またはそれを解析できるポイント形式を列挙することができます。"
    },
    {
      "indent": 3,
      "text": "Structure of these extensions:",
      "ja": "これらの拡張機能の構造："
    },
    {
      "indent": 3,
      "text": "The general structure of TLS extensions is described in [4], and this specification adds two new types to ExtensionType.",
      "ja": "TLS拡張の一般的な構造は、[4]に記載され、そして本明細書はExtensionTypeに二つの新しいタイプを追加しています。"
    },
    {
      "indent": 7,
      "text": "enum { elliptic_curves(10), ec_point_formats(11) } ExtensionType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "elliptic_curves (Supported Elliptic Curves Extension): Indicates the set of elliptic curves supported by the client. For this extension, the opaque extension_data field contains EllipticCurveList. See Section 5.1.1 for details.",
      "ja": "elliptic_curves（サポートされている楕円曲線の延長）：クライアントでサポートされている楕円曲線のセットを示します。この拡張のために、不透明な拡フィールドがEllipticCurveListが含まれています。詳細については、セクション5.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "ec_point_formats (Supported Point Formats Extension): Indicates the set of point formats that the client can parse. For this extension, the opaque extension_data field contains ECPointFormatList. See Section 5.1.2 for details.",
      "ja": "ec_point_formats（小数点形式の拡張をサポートするには）：クライアントが解析できるポイント形式のセットを示します。この拡張のために、不透明な拡フィールドがECPointFormatListが含まれています。詳細については、5.1.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "A client that proposes ECC cipher suites in its ClientHello message appends these extensions (along with any others), enumerating the curves it supports and the point formats it can parse. Clients SHOULD send both the Supported Elliptic Curves Extension and the Supported Point Formats Extension. If the Supported Point Formats Extension is indeed sent, it MUST contain the value 0 (uncompressed) as one of the items in the list of point formats.",
      "ja": "そのClientHelloメッセージでECC暗号スイートを提案しているクライアントは、それがサポートするカーブと、それが解析できるポイント形式を列挙し、（他のものと一緒に）これらの拡張機能を付加します。クライアントがサポートされている楕円曲線拡張およびサポートされている小数点形式拡張の両方を送るべきです。サポートされている小数点形式拡張子が実際に送信された場合、それはポイント形式のリスト内の項目の一つとして値0（非圧縮）を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "A server that receives a ClientHello containing one or both of these extensions MUST use the client's enumerated capabilities to guide its selection of an appropriate cipher suite. One of the proposed ECC cipher suites must be negotiated only if the server can successfully complete the handshake while using the curves and point formats supported by the client (cf. Sections 5.3 and 5.4).",
      "ja": "これらの拡張機能のいずれかまたは両方を含むのClientHelloを受信するサーバーは、適切な暗号スイートのその選択を導くために、クライアントの列挙機能を使用しなければなりません。提案されたECC暗号スイートの一つは、クライアントによってサポートされた曲線とポイント形式（参照：セクション5.3および5.4）を使用している間、サーバーが正常に握手を完了することができた場合にのみ交渉しなければなりません。"
    },
    {
      "indent": 3,
      "text": "NOTE: A server participating in an ECDHE-ECDSA key exchange may use different curves for (i) the ECDSA key in its certificate, and (ii) the ephemeral ECDH key in the ServerKeyExchange message. The server must consider the extensions in both cases.",
      "ja": "注：ECDHE-ECDSA鍵交換に参加しているサーバはServerKeyExchangeメッセージ内の証明書（I）ECDSAキー、および（ii）はかないECDHキーの異なる曲線を使用してもよいです。サーバーは、両方のケースで拡張を考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a server does not understand the Supported Elliptic Curves Extension, does not understand the Supported Point Formats Extension, or is unable to complete the ECC handshake while restricting itself to the enumerated curves and point formats, it MUST NOT negotiate the use of an ECC cipher suite. Depending on what other cipher suites are proposed by the client and supported by the server, this may result in a fatal handshake failure alert due to the lack of common cipher suites.",
      "ja": "サーバがサポートされている楕円曲線拡張を理解していない場合は、それがECC暗号の使用を交渉してはならない、サポートされている小数点形式拡張子を理解し、または列挙カーブとポイント形式に自分自身を制限しながら、ECCハンドシェイクを完了することができませんしません。組。クライアントによって提案され、サーバーによってサポートされている暗号他のどのようなスイートによっては、これは、一般的な暗号スイートの不足のために致命的な握手故障警報をもたらすことができます。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Supported Elliptic Curves Extension",
      "section_title": true,
      "ja": "5.1.1. サポートされている楕円曲線の拡張"
    },
    {
      "indent": 8,
      "text": "enum {\n    sect163k1 (1), sect163r1 (2), sect163r2 (3),\n    sect193r1 (4), sect193r2 (5), sect233k1 (6),\n    sect233r1 (7), sect239k1 (8), sect283k1 (9),\n    sect283r1 (10), sect409k1 (11), sect409r1 (12),\n    sect571k1 (13), sect571r1 (14), secp160k1 (15),\n    secp160r1 (16), secp160r2 (17), secp192k1 (18),\n    secp192r1 (19), secp224k1 (20), secp224r1 (21),\n    secp256k1 (22), secp256r1 (23), secp384r1 (24),\n    secp521r1 (25),\n    reserved (0xFE00..0xFEFF),\n    arbitrary_explicit_prime_curves(0xFF01),\n    arbitrary_explicit_char2_curves(0xFF02),\n    (0xFFFF)\n} NamedCurve;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sect163k1, etc: Indicates support of the corresponding named curve or class of explicitly defined curves. The named curves defined here are those specified in SEC 2 [13]. Note that many of these curves are also recommended in ANSI X9.62 [7] and FIPS 186-2 [11]. Values 0xFE00 through 0xFEFF are reserved for private use. Values 0xFF01 and 0xFF02 indicate that the client supports arbitrary prime and characteristic-2 curves, respectively (the curve parameters must be encoded explicitly in ECParameters).",
      "ja": "sect163k1などは：明示的に定義された曲線の対応という名前の曲線やクラスのサポートを示します。ここで定義された名前付きの曲線は、SEC 2 [13]で指定されたものです。これらの曲線の多くはまた、ANSI X9.62 [7]で推奨されていることに注意し、FIPS 186-2 [11]。 0xFEFFまでの値0xFE00は、私的使用のために予約されています。値0xFF01と0xFF02は、クライアントが（曲線パラメータがECParametersで明示的にコード化されなければならない）、それぞれ、任意の素数と特徴-2曲線をサポートしていることを示しています。"
    },
    {
      "indent": 3,
      "text": "The NamedCurve name space is maintained by IANA. See Section 8 for information on how new value assignments are added.",
      "ja": "NamedCurve名前空間はIANAによって維持されています。新しい値の割り当てが追加されている方法の詳細については、セクション8を参照してください。"
    },
    {
      "indent": 8,
      "text": "struct {\n    NamedCurve elliptic_curve_list<1..2^16-1>\n} EllipticCurveList;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Items in elliptic_curve_list are ordered according to the client's preferences (favorite choice first).",
      "ja": "elliptic_curve_listのアイテムは、クライアントの好み（最初のお気に入りの選択）に従って順序付けされています。"
    },
    {
      "indent": 3,
      "text": "As an example, a client that only supports secp192r1 (aka NIST P-192; value 19 = 0x0013) and secp224r1 (aka NIST P-224; value 21 = 0x0015) and prefers to use secp192r1 would include a TLS extension consisting of the following octets. Note that the first two octets indicate the extension type (Supported Elliptic Curves Extension):",
      "ja": "例としてのみsecp192r1をサポートし、クライアント（別名NIST P-192;値19 = 0x0013）とsecp224r1（別名NIST P-224;値21 = 0x0015）とsecp192r1を使用することを好むは、次からなるTLS拡張子を含むであろうオクテット。最初の2つのオクテットは、拡張タイプ（サポートされている楕円曲線の延長）を示していることに注意してください："
    },
    {
      "indent": 8,
      "text": "00 0A 00 06 00 04 00 13 00 15",
      "ja": "00 0A 00 06 00 04 00 13 00 15"
    },
    {
      "indent": 3,
      "text": "A client that supports arbitrary explicit characteristic-2 curves (value 0xFF02) would include an extension consisting of the following octets:",
      "ja": "任意の明示的な特性-2曲線（値0xFF02）をサポートするクライアントは、次のオクテットからなる拡張を含むであろう。"
    },
    {
      "indent": 8,
      "text": "00 0A 00 04 00 02 FF 02",
      "ja": "00 0A 00 04 FF 00 02 02"
    },
    {
      "indent": 0,
      "text": "5.1.2. Supported Point Formats Extension",
      "section_title": true,
      "ja": "5.1.2. サポートされている小数点形式拡張子"
    },
    {
      "indent": 8,
      "text": "enum { uncompressed (0), ansiX962_compressed_prime (1),\n       ansiX962_compressed_char2 (2), reserved (248..255)\n} ECPointFormat;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n    ECPointFormat ec_point_format_list<1..2^8-1>\n} ECPointFormatList;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Three point formats are included in the definition of ECPointFormat above. The uncompressed point format is the default format in that implementations of this document MUST support it for all of their supported curves. Compressed point formats reduce bandwidth by including only the x-coordinate and a single bit of the y-coordinate of the point. Implementations of this document MAY support the ansiX962_compressed_prime and ansiX962_compressed_char2 formats, where the former applies only to prime curves and the latter applies only to characteristic-2 curves. (These formats are specified in [7].) Values 248 through 255 are reserved for private use.",
      "ja": "スリーポイント・フォーマットは、上記のECPointFormatの定義に含まれます。圧縮されていない小数点形式は、彼らのサポートの曲線のすべてのためにそれをサポートしなければならない。この文書の実装では、デフォルトのフォーマットです。圧縮点フォーマットは、x座標とy座標点からの単一ビットを含むことにより、帯域幅を減少させます。この文書の実装では、前者のみプライム曲線に適用され、後者の特性-2曲線にのみ適用さansiX962_compressed_primeとansiX962_compressed_char2フォーマットをサポートすることができます。 （これらのフォーマットは、[7]で指定されている。）248〜255は、私的使用のために予約された値。"
    },
    {
      "indent": 3,
      "text": "The ECPointFormat name space is maintained by IANA. See Section 8 for information on how new value assignments are added.",
      "ja": "ECPointFormat名前空間はIANAによって維持されています。新しい値の割り当てが追加されている方法の詳細については、セクション8を参照してください。"
    },
    {
      "indent": 3,
      "text": "Items in ec_point_format_list are ordered according to the client's preferences (favorite choice first).",
      "ja": "ec_point_format_listのアイテムは、クライアントの好み（最初のお気に入りの選択）に従って順序付けされています。"
    },
    {
      "indent": 3,
      "text": "A client that can parse only the uncompressed point format (value 0) includes an extension consisting of the following octets; note that the first two octets indicate the extension type (Supported Point Formats Extension):",
      "ja": "唯一の非圧縮小数点フォーマットを解析することができるクライアント（値0）は、次のオクテットからなる延長部を含みます。最初の2つのオクテットが（小数点形式拡張をサポート）拡張タイプを示していることに注意してください："
    },
    {
      "indent": 8,
      "text": "00 0B 00 02 01 00",
      "ja": "00 0B 00 02 01 00"
    },
    {
      "indent": 3,
      "text": "A client that in the case of prime fields prefers the compressed format (ansiX962_compressed_prime, value 1) over the uncompressed format (value 0), but in the case of characteristic-2 fields prefers the uncompressed format (value 0) over the compressed format (ansiX962_compressed_char2, value 2), may indicate these preferences by including an extension consisting of the following octets:",
      "ja": "プライムフィールドの場合には非圧縮形式（値0）を超える圧縮形式（ansiX962_compressed_prime、値1）クライアントを好むことが、特徴-2フィールドの場合には圧縮形式（上非圧縮形式（値0）を好みますansiX962_compressed_char2、値2）は、次のオクテットからなる拡張を含むことによって、これらの選好を示すことができます。"
    },
    {
      "indent": 8,
      "text": "00 0B 00 04 03 01 00 02",
      "ja": "00 0B 00 04 03 01 00 02"
    },
    {
      "indent": 0,
      "text": "5.2. Server Hello Extension",
      "section_title": true,
      "ja": "5.2. サーバーこんにちは拡張"
    },
    {
      "indent": 3,
      "text": "This section specifies a TLS extension that can be included with the ServerHello message as described in [4], the Supported Point Formats Extension.",
      "ja": "このセクションでは、[4]に記載されているようにServerHelloメッセージに含めることができるTLS拡張、サポートポイントフォーマット拡張子を指定します。"
    },
    {
      "indent": 3,
      "text": "When this extension is sent:",
      "ja": "この拡張機能は、送信された場合："
    },
    {
      "indent": 3,
      "text": "The Supported Point Formats Extension is included in a ServerHello message in response to a ClientHello message containing the Supported Point Formats Extension when negotiating an ECC cipher suite.",
      "ja": "ECC暗号スイートをネゴシエートするときにサポートされているポイントフォーマット拡張がサポートされているポイントフォーマットの拡張を含むClientHelloメッセージに応答して、ServerHelloメッセージに含まれています。"
    },
    {
      "indent": 3,
      "text": "Meaning of this extension:",
      "ja": "この拡張機能の意味："
    },
    {
      "indent": 3,
      "text": "This extension allows a server to enumerate the point formats it can parse (for the curve that will appear in its ServerKeyExchange message when using the ECDHE_ECDSA, ECDHE_RSA, or ECDH_anon key exchange algorithm, or for the curve that is used in the server's public key that will appear in its Certificate message when using the ECDH_ECDSA or ECDH_RSA key exchange algorithm).",
      "ja": "この拡張は（ECDHE_ECDSA、ECDHE_RSA、またはECDH_anon鍵交換アルゴリズムを使用しているときにそのServerKeyExchangeメッセージに表示される曲線のために、またはそのサーバーの公開鍵で使用された曲線のために、サーバはそれが解析できるポイント形式を列挙することができますECDH_ECDSAまたはECDH_RSA鍵交換アルゴリズムを使用した場合）そのCertificateメッセージに表示されます。"
    },
    {
      "indent": 3,
      "text": "Structure of this extension:",
      "ja": "この拡張機能の構造："
    },
    {
      "indent": 3,
      "text": "The server's Supported Point Formats Extension has the same structure as the client's Supported Point Formats Extension (see Section 5.1.2). Items in elliptic_curve_list here are ordered according to the server's preference (favorite choice first). Note that the server may include items that were not found in the client's list (e.g., the server may prefer to receive points in compressed format even when a client cannot parse this format: the same client may nevertheless be capable of outputting points in compressed format).",
      "ja": "サーバーのサポートされている小数点形式拡張子は、クライアントのサポートされている小数点形式拡張（5.1.2項を参照）と同様の構造を有しています。ここelliptic_curve_listの項目は、サーバーの好み（最初のお気に入りの選択）に従って順序付けされています。サーバーがクライアントのリストには検出されなかった項目を含んでいてもよいことに注意してください（例えば、サーバーは、クライアントがこのフォーマットを解析できない場合でも、圧縮形式でポイントを受け取ることを好むことがあります。同じクライアントがそれにもかかわらず、圧縮形式でポイントを出力することが可能です）。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "A server that selects an ECC cipher suite in response to a ClientHello message including a Supported Point Formats Extension appends this extension (along with others) to its ServerHello message, enumerating the point formats it can parse. The Supported Point Formats Extension, when used, MUST contain the value 0 (uncompressed) as one of the items in the list of point formats.",
      "ja": "サポートされているポイントフォーマット拡張子を含むClientHelloメッセージに応答して、ECC暗号スイートを選択し、サーバが解析できる点フォーマットを列挙し、そのServerHelloメッセージに（他の人と一緒に）この拡張機能を追加します。サポートされているポイントフォーマットの拡張は、使用される場合、小数点形式のリスト内の項目の一つとして値0（非圧縮）を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "A client that receives a ServerHello message containing a Supported Point Formats Extension MUST respect the server's choice of point formats during the handshake (cf. Sections 5.6 and 5.7). If no Supported Point Formats Extension is received with the ServerHello, this is equivalent to an extension allowing only the uncompressed point format.",
      "ja": "サポートされている小数点形式拡張子を含むServerHelloメッセージを受信したクライアントは、ハンドシェイク（参照：セクション5.6および5.7）の間に小数点フォーマットのサーバの選択を尊重しなければなりません。何もサポートされている小数点形式拡張子がのServerHelloで受信されない場合、これが唯一の非圧縮小数点形式を許可する拡張機能と同等です。"
    },
    {
      "indent": 0,
      "text": "5.3. Server Certificate",
      "section_title": true,
      "ja": "5.3. サーバー証明書"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent in all non-anonymous ECC-based key exchange algorithms.",
      "ja": "このメッセージは、すべての非匿名ECCベースの鍵交換アルゴリズムに送信されます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 3,
      "text": "This message is used to authentically convey the server's static public key to the client. The following table shows the server certificate type appropriate for each key exchange algorithm. ECC public keys MUST be encoded in certificates as described in Section 5.9.",
      "ja": "このメッセージは、本物のクライアントに対するサーバの静的な公開鍵を伝えるために使用されます。次の表は、各鍵交換アルゴリズムに適したサーバ証明書の種類を示します。 5.9節で説明したようにECC公開鍵は、証明書にエンコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "NOTE: The server's Certificate message is capable of carrying a chain of certificates. The restrictions mentioned in Table 3 apply only to the server's certificate (first in the chain).",
      "ja": "注：サーバーの証明書のメッセージが証明書のチェーンを搬送することができます。表3に記載された制限は、（最初​​の鎖に）のみ、サーバーの証明書に適用されます。"
    },
    {
      "indent": 10,
      "text": "Key Exchange Algorithm  Server Certificate Type\n----------------------  -----------------------",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ECDH_ECDSA Certificate MUST contain an ECDH-capable public key. It MUST be signed with ECDSA.",
      "ja": "ECDH_ECDSA証明書はECDH可能な公開鍵を含まなければなりません。これは、ECDSAで署名する必要があります。"
    },
    {
      "indent": 10,
      "text": "ECDHE_ECDSA Certificate MUST contain an ECDSA-capable public key. It MUST be signed with ECDSA.",
      "ja": "ECDHE_ECDSA証明書は、ECDSA可能な公開鍵を含まなければなりません。これは、ECDSAで署名する必要があります。"
    },
    {
      "indent": 10,
      "text": "ECDH_RSA Certificate MUST contain an ECDH-capable public key. It MUST be signed with RSA.",
      "ja": "ECDH_RSA証明書はECDH可能な公開鍵を含まなければなりません。これは、RSAで署名されなければなりません。"
    },
    {
      "indent": 10,
      "text": "ECDHE_RSA Certificate MUST contain an RSA public key authorized for use in digital signatures. It MUST be signed with RSA.",
      "ja": "ECDHE_RSA証明書は、デジタル署名で使用が許可RSA公開鍵を含まなければなりません。これは、RSAで署名されなければなりません。"
    },
    {
      "indent": 20,
      "text": "Table 3: Server Certificate Types",
      "ja": "表3：サーバー証明書の種類"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 3,
      "text": "Identical to the TLS Certificate format.",
      "ja": "TLS証明書の形式と同じ。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The server constructs an appropriate certificate chain and conveys it to the client in the Certificate message. If the client has used a Supported Elliptic Curves Extension, the public key in the server's certificate MUST respect the client's choice of elliptic curves; in particular, the public key MUST employ a named curve (not the same curve as an explicit curve) unless the client has indicated support for explicit curves of the appropriate type. If the client has used a Supported Point Formats Extension, both the server's public key point and (in the case of an explicit curve) the curve's base point MUST respect the client's choice of point formats. (A server that cannot satisfy these requirements MUST NOT choose an ECC cipher suite in its ServerHello message.)",
      "ja": "サーバーは、適切な証明書チェーンを構築し、Certificateメッセージでクライアントにそれを伝えます。クライアントがサポートされている楕円曲線拡張子を使用している場合は、サーバーの証明書の公開鍵は、楕円曲線のクライアントの選択を尊重しなければなりません。特に、公開鍵は、名前付き曲線（明示しない曲線と同じ曲線）の適切なタイプの明示的なカーブのクライアントが示されていない限り、サポートを使用しなければなりません。クライアントがサポートされている小数点形式拡張子を使用している場合は、サーバの公開キーポイントと（明示的な曲線の場合）曲線のベースポイントの両方が小数点フォーマットのクライアントの選択を尊重しなければなりません。 （これらの要件を満たすことができないサーバがServerHelloメッセージでECC暗号スイートを選択してはなりません。）"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The client validates the certificate chain, extracts the server's public key, and checks that the key type is appropriate for the negotiated key exchange algorithm. (A possible reason for a fatal handshake failure is that the client's capabilities for handling elliptic curves and point formats are exceeded; cf. Section 5.1.)",
      "ja": "クライアントは、証明書チェーンを検証し、サーバーの公開鍵を抽出し、キータイプが交渉の鍵交換アルゴリズムに適切であることを確認します。 （致命的なハンドシェイク失敗の可能な理由は、楕円曲線とポイント形式を処理するためのクライアントの能力を超えているということであり、節参照5.1。）"
    },
    {
      "indent": 0,
      "text": "5.4. Server Key Exchange",
      "section_title": true,
      "ja": "5.4. サーバーの鍵交換"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent when using the ECDHE_ECDSA, ECDHE_RSA, and ECDH_anon key exchange algorithms.",
      "ja": "ECDHE_ECDSA、ECDHE_RSA、及びECDH_anon鍵交換アルゴリズムを使用する場合、このメッセージが送信されます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 3,
      "text": "This message is used to convey the server's ephemeral ECDH public key (and the corresponding elliptic curve domain parameters) to the client.",
      "ja": "このメッセージは、クライアントに対するサーバのはかないECDH公開鍵（および対応する楕円曲線ドメインパラメータを）伝えるために使用されます。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 8,
      "text": "enum { explicit_prime (1), explicit_char2 (2),\n       named_curve (3), reserved(248..255) } ECCurveType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "explicit_prime: Indicates the elliptic curve domain parameters are conveyed verbosely, and the underlying finite field is a prime field.",
      "ja": "explicit_primeは：楕円曲線ドメインパラメータが冗長に搬送されることを示し、基礎となる有限体は素体です。"
    },
    {
      "indent": 3,
      "text": "explicit_char2: Indicates the elliptic curve domain parameters are conveyed verbosely, and the underlying finite field is a characteristic-2 field.",
      "ja": "explicit_char2は：楕円曲線ドメインパラメータが冗長に搬送されることを示し、そして基礎となる有限体は、特性-2のフィールドです。"
    },
    {
      "indent": 3,
      "text": "named_curve: Indicates that a named curve is used. This option SHOULD be used when applicable.",
      "ja": "named_curve：名前の曲線が使用されていることを示します。このオプションは、適用可能な場合に使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Values 248 through 255 are reserved for private use.",
      "ja": "255までの値248は、私的使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "The ECCurveType name space is maintained by IANA. See Section 8 for information on how new value assignments are added.",
      "ja": "ECCurveType名前空間はIANAによって維持されています。新しい値の割り当てが追加されている方法の詳細については、セクション8を参照してください。"
    },
    {
      "indent": 8,
      "text": "struct {\n    opaque a <1..2^8-1>;\n    opaque b <1..2^8-1>;\n} ECCurve;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "a, b: These parameters specify the coefficients of the elliptic curve. Each value contains the byte string representation of a field element following the conversion routine in Section 4.3.3 of ANSI X9.62 [7].",
      "ja": "、B：これらのパラメータは、楕円曲線の係数を指定します。各値は、ANSI X9.62 [7]のセクション4.3.3に変換ルーチン次のフィールド要素のバイトの文字列表現を含みます。"
    },
    {
      "indent": 8,
      "text": "struct {\n    opaque point <1..2^8-1>;\n} ECPoint;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "point: This is the byte string representation of an elliptic curve point following the conversion routine in Section 4.3.6 of ANSI X9.62 [7]. This byte string may represent an elliptic curve point in uncompressed or compressed format; it MUST conform to what the client has requested through a Supported Point Formats Extension if this extension was used.",
      "ja": "点：これは、ANSI X9.62のセクション4.3.6に変換ルーチン次の楕円曲線点のバイトの文字列表現である[7]。このバイト列は、非圧縮又は圧縮形式の楕円曲線点を表すことができます。それは、この拡張が使用された場合、クライアントはサポートされている小数点形式拡張を介して要求したものに従わなければなりません。"
    },
    {
      "indent": 8,
      "text": "enum { ec_basis_trinomial, ec_basis_pentanomial } ECBasisType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ec_basis_trinomial: Indicates representation of a characteristic-2 field using a trinomial basis.",
      "ja": "ec_basis_trinomial：三項の基礎を使用して特性-2フィールドの表現を示します。"
    },
    {
      "indent": 3,
      "text": "ec_basis_pentanomial: Indicates representation of a characteristic-2 field using a pentanomial basis.",
      "ja": "ec_basis_pentanomial：pentanomial基礎を使用して特性-2フィールドの表現を示します。"
    },
    {
      "indent": 8,
      "text": "struct {\n    ECCurveType    curve_type;\n    select (curve_type) {\n        case explicit_prime:\n            opaque      prime_p <1..2^8-1>;\n            ECCurve     curve;\n            ECPoint     base;\n            opaque      order <1..2^8-1>;\n            opaque      cofactor <1..2^8-1>;\n        case explicit_char2:\n            uint16      m;\n            ECBasisType basis;\n            select (basis) {\n                case ec_trinomial:\n                    opaque  k <1..2^8-1>;\n                case ec_pentanomial:\n                    opaque  k1 <1..2^8-1>;\n                    opaque  k2 <1..2^8-1>;\n                    opaque  k3 <1..2^8-1>;\n            };\n            ECCurve     curve;\n            ECPoint     base;\n            opaque      order <1..2^8-1>;\n            opaque      cofactor <1..2^8-1>;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "        case named_curve:\n            NamedCurve namedcurve;\n    };\n} ECParameters;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "curve_type: This identifies the type of the elliptic curve domain parameters.",
      "ja": "curve_type：これは、楕円曲線ドメインパラメータのタイプを識別する。"
    },
    {
      "indent": 3,
      "text": "prime_p: This is the odd prime defining the field Fp.",
      "ja": "prime_p：これは体Fpを定義する奇素数です。"
    },
    {
      "indent": 3,
      "text": "curve: Specifies the coefficients a and b of the elliptic curve E.",
      "ja": "曲線：楕円曲線Eの係数a、bを指定し"
    },
    {
      "indent": 3,
      "text": "base: Specifies the base point G on the elliptic curve.",
      "ja": "ベース：楕円曲線上のベースポイントGを指定します。"
    },
    {
      "indent": 3,
      "text": "order: Specifies the order n of the base point.",
      "ja": "オーダー：ベースポイントの次数nを指定します。"
    },
    {
      "indent": 3,
      "text": "cofactor: Specifies the cofactor h = #E(Fq)/n, where #E(Fq) represents the number of points on the elliptic curve E defined over the field Fq (either Fp or F2^m).",
      "ja": "補因子は：#E（体F q）の体Fq（FPいずれかまたはF2 ^ m）の上で定義された楕円曲線E上の点の数を表す補因子H = #E（体F q）/ Nを指定します。"
    },
    {
      "indent": 3,
      "text": "m: This is the degree of the characteristic-2 field F2^m.",
      "ja": "M：これは特性-2フィールドF2 ^ Mの度合いです。"
    },
    {
      "indent": 3,
      "text": "k: The exponent k for the trinomial basis representation x^m + x^k +1.",
      "ja": "K：X ^ M + X ^ K +1三項基底表現のための指数K。"
    },
    {
      "indent": 3,
      "text": "k1, k2, k3: The exponents for the pentanomial representation x^m + x^k3 + x^k2 + x^k1 + 1 (such that k3 > k2 > k1).",
      "ja": "K1、K2、K3：pentanomial表現X ^ M + X ^ K3 + X ^ K2 + X ^ K1 + 1（例えば、そのK3> K2> K1）のための指数。"
    },
    {
      "indent": 3,
      "text": "namedcurve: Specifies a recommended set of elliptic curve domain parameters. All those values of NamedCurve are allowed that refer to a specific curve. Values of NamedCurve that indicate support for a class of explicitly defined curves are not allowed here (they are only permissible in the ClientHello extension); this applies to arbitrary_explicit_prime_curves(0xFF01) and arbitrary_explicit_char2_curves(0xFF02).",
      "ja": "namedcurve：楕円曲線ドメインパラメータの推奨セットを指定します。 NamedCurveのすべてのそれらの値は、特定の曲線を参照することを許可されています。明示的に定義された曲線のクラスのサポートを示すNamedCurveの値はここでは許可されていません（彼らはのClientHelloエクステンションにのみ許容されます）。これはarbitrary_explicit_prime_curves（0xFF01）とarbitrary_explicit_char2_curves（0xFF02）に適用されます。"
    },
    {
      "indent": 8,
      "text": "struct {\n    ECParameters    curve_params;\n    ECPoint         public;\n} ServerECDHParams;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "curve_params: Specifies the elliptic curve domain parameters associated with the ECDH public key.",
      "ja": "curve_params：ECDH公開鍵に関連付けられた楕円曲線ドメインパラメータを指定します。"
    },
    {
      "indent": 3,
      "text": "public: The ephemeral ECDH public key.",
      "ja": "公共：はかないECDH公開鍵。"
    },
    {
      "indent": 3,
      "text": "The ServerKeyExchange message is extended as follows.",
      "ja": "次のようにServerKeyExchangeメッセージが拡張されます。"
    },
    {
      "indent": 8,
      "text": "enum { ec_diffie_hellman } KeyExchangeAlgorithm;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ec_diffie_hellman: Indicates the ServerKeyExchange message contains an ECDH public key.",
      "ja": "ec_diffie_hellman：ServerKeyExchangeメッセージがECDH公開鍵が含まれていることを示します。"
    },
    {
      "indent": 8,
      "text": "select (KeyExchangeAlgorithm) {\n    case ec_diffie_hellman:\n        ServerECDHParams    params;\n        Signature           signed_params;\n} ServerKeyExchange;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "params: Specifies the ECDH public key and associated domain parameters.",
      "ja": "params：ECDH公開鍵と関連したドメインパラメータを指定します。"
    },
    {
      "indent": 3,
      "text": "signed_params: A hash of the params, with the signature appropriate to that hash applied. The private key corresponding to the certified public key in the server's Certificate message is used for signing.",
      "ja": "signed_pa​​rams：そのハッシュに適切な署名付きのparamsのハッシュは、適用しました。サーバーの証明書メッセージに認定された公開鍵に対応する秘密鍵は、署名に使用されます。"
    },
    {
      "indent": 10,
      "text": "enum { ecdsa } SignatureAlgorithm;",
      "raw": true
    },
    {
      "indent": 10,
      "text": "select (SignatureAlgorithm) {\n    case ecdsa:\n        digitally-signed struct {\n            opaque sha_hash[sha_size];\n        };\n} Signature;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "ServerKeyExchange.signed_params.sha_hash SHA(ClientHello.random + ServerHello.random + ServerKeyExchange.params);",
      "ja": "ServerKeyExchange.signed_pa​​rams.sha_hash SHA（ClientHello.randomと+ ServerHello.random + ServerKeyExchange.params）。"
    },
    {
      "indent": 3,
      "text": "NOTE: SignatureAlgorithm is \"rsa\" for the ECDHE_RSA key exchange algorithm and \"anonymous\" for ECDH_anon. These cases are defined in TLS [2][3]. SignatureAlgorithm is \"ecdsa\" for ECDHE_ECDSA. ECDSA signatures are generated and verified as described in Section 5.10, and SHA in the above template for sha_hash accordingly may denote a hash algorithm other than SHA-1. As per ANSI X9.62, an ECDSA signature consists of a pair of integers, r and s. The digitally-signed element is encoded as an opaque vector <0..2^16-1>, the contents of which are the DER encoding [9] corresponding to the following ASN.1 notation [8].",
      "ja": "注：のsignatureAlgorithmはECDHE_RSA鍵交換アルゴリズムのための「RSA」とECDH_anonのための「匿名」です。これらの場合は、TLSで定義されている[2] [3]。 signatureAlgorithmはECDHE_ECDSAのための \"ECDSA\" です。 SHA-1以外のハッシュアルゴリズムを表してもよい従ってsha_hashための上記テンプレートのセクション5.10に記載され、そしてSHAとしてECDSA署名が生成され、検証されます。 ANSI X9.62に従って、ECDSA署名は整数、rおよびsの対から成ります。デジタル署名された要素は、DER符号化された内容は、[8] [9]以下のASN.1表記に対応し、不透明なベクトル<^ 16-1 0..2>としてコード化されます。"
    },
    {
      "indent": 11,
      "text": "Ecdsa-Sig-Value ::= SEQUENCE {\n    r       INTEGER,\n    s       INTEGER\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The server selects elliptic curve domain parameters and an ephemeral ECDH public key corresponding to these parameters according to the ECKAS-DH1 scheme from IEEE 1363 [6]. It conveys this information to the client in the ServerKeyExchange message using the format defined above.",
      "ja": "サーバーは楕円曲線ドメインパラメータを選択し、IEEE 1363からECKAS-DH1方式に従って、これらのパラメータに対応するはかないECDH公開鍵[6]。これは、上記で定義されたフォーマットを使用して、ServerKeyExchangeメッセージでクライアントにこの情報を伝えます。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The client verifies the signature (when present) and retrieves the server's elliptic curve domain parameters and ephemeral ECDH public key from the ServerKeyExchange message. (A possible reason for a fatal handshake failure is that the client's capabilities for handling elliptic curves and point formats are exceeded; cf. Section 5.1.)",
      "ja": "クライアントは、署名を検証する（存在する場合）、サーバーの楕円曲線ドメインパラメータとServerKeyExchangeメッセージからはかないECDH公開鍵を取り出します。 （致命的なハンドシェイク失敗の可能な理由は、楕円曲線とポイント形式を処理するためのクライアントの能力を超えているということであり、節参照5.1。）"
    },
    {
      "indent": 0,
      "text": "5.5. Certificate Request",
      "section_title": true,
      "ja": "5.5. 証明書要求"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent when requesting client authentication.",
      "ja": "クライアント認証を要求するときにこのメッセージが送信されます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 3,
      "text": "The server uses this message to suggest acceptable client authentication methods.",
      "ja": "サーバは、許容可能なクライアント認証方法を提案するために、このメッセージを使用しています。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 3,
      "text": "The TLS CertificateRequest message is extended as follows.",
      "ja": "次のようにTLS CertificateRequestメッセージが拡張されます。"
    },
    {
      "indent": 8,
      "text": "enum {\n    ecdsa_sign(64), rsa_fixed_ecdh(65),\n    ecdsa_fixed_ecdh(66), (255)\n} ClientCertificateType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ecdsa_sign, etc. Indicates that the server would like to use the corresponding client authentication method specified in Section 3.",
      "ja": "などecdsa_signは、サーバは第3節で指定された対応するクライアント認証方法を使用したいことを示します。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The server decides which client authentication methods it would like to use, and conveys this information to the client using the format defined above.",
      "ja": "サーバーは、それが使用したいどのクライアントの認証方法を決定し、上記で定義されたフォーマットを使用してクライアントにこの情報を伝えます。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The client determines whether it has a suitable certificate for use with any of the requested methods and whether to proceed with client authentication.",
      "ja": "クライアントは、要求のいずれかの方法で、クライアント認証を続行するかどうかの使用に適した証明書を持っているかどうかを決定します。"
    },
    {
      "indent": 0,
      "text": "5.6. Client Certificate",
      "section_title": true,
      "ja": "5.6. クライアント証明書"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent in response to a CertificateRequest when a client has a suitable certificate and has decided to proceed with client authentication. (Note that if the server has used a Supported Point Formats Extension, a certificate can only be considered suitable for use with the ECDSA_sign, RSA_fixed_ECDH, and ECDSA_fixed_ECDH authentication methods if the public key point specified in it respects the server's choice of point formats. If no Supported Point Formats Extension has been used, a certificate can only be considered suitable for use with these authentication methods if the point is represented in uncompressed point format.)",
      "ja": "このメッセージは、クライアントが、適切な証明書を持っており、クライアント認証を続行することを決定しましたCertificateRequestに応じて送信されます。 （サーバがサポートされている小数点形式拡張子を使用している場合、証明書はそれだけで指定された公開キーポイントは、ポイント形式のサーバーの選択を尊重した場合ECDSA_sign、RSA_fixed_ECDH、およびECDSA_fixed_ECDH認証方法での使用に適し考えることができることに注意してください。場合全くサポートポイントフォーマット拡張が使用されていない点が非圧縮小数点形式で表現されている場合、証明書は、これらの認証方法と共に使用するのに適したと考えることができます。）"
    },
    {
      "indent": 3,
      "text": "Meaning of this message:",
      "ja": "このメッセージの意味："
    },
    {
      "indent": 3,
      "text": "This message is used to authentically convey the client's static public key to the server. The following table summarizes what client certificate types are appropriate for the ECC-based client authentication mechanisms described in Section 3. ECC public keys must be encoded in certificates as described in Section 5.9.",
      "ja": "このメッセージは、本物のサーバーへのクライアントの静的な公開鍵を伝えるために使用されます。次の表は、クライアント証明書の種類は、セクション5.9で説明したように3 ECC公開鍵証明書にエンコードする必要がありますセクションで説明したECCベースのクライアント認証メカニズムに適したものをまとめたものです。"
    },
    {
      "indent": 3,
      "text": "NOTE: The client's Certificate message is capable of carrying a chain of certificates. The restrictions mentioned in Table 4 apply only to the client's certificate (first in the chain).",
      "ja": "注：クライアントの証明書のメッセージが証明書のチェーンを搬送することができます。表4に記載された制限はのみ（最初の鎖で）クライアントの証明書に適用されます。"
    },
    {
      "indent": 10,
      "text": "Client\nAuthentication Method   Client Certificate Type\n---------------------   -----------------------",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ECDSA_sign Certificate MUST contain an ECDSA-capable public key and be signed with ECDSA.",
      "ja": "ECDSA_sign証明書は、ECDSA可能な公開鍵を含まなければならないし、ECDSAで署名します。"
    },
    {
      "indent": 10,
      "text": "ECDSA_fixed_ECDH Certificate MUST contain an ECDH-capable public key on the same elliptic curve as the server's long-term ECDH key. This certificate MUST be signed with ECDSA.",
      "ja": "ECDSA_fixed_ECDH証明書は、サーバーの長期ECDHキーと同じ楕円曲線上のECDH可能な公開鍵を含まなければなりません。この証明書は、ECDSAで署名されなければなりません。"
    },
    {
      "indent": 10,
      "text": "RSA_fixed_ECDH Certificate MUST contain an ECDH-capable public key on the same elliptic curve as the server's long-term ECDH key. This certificate MUST be signed with RSA.",
      "ja": "RSA_fixed_ECDH証明書は、サーバーの長期ECDHキーと同じ楕円曲線上のECDH可能な公開鍵を含まなければなりません。この証明書は、RSAで署名されなければなりません。"
    },
    {
      "indent": 21,
      "text": "Table 4: Client Certificate Types",
      "ja": "表4：クライアント証明書の種類"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 3,
      "text": "Identical to the TLS client Certificate format.",
      "ja": "TLSクライアント証明書の形式と同じ。"
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The client constructs an appropriate certificate chain, and conveys it to the server in the Certificate message.",
      "ja": "クライアントは、適切な証明書チェーンを構築し、Certificateメッセージ内のサーバーにそれを伝えます。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The TLS server validates the certificate chain, extracts the client's public key, and checks that the key type is appropriate for the client authentication method.",
      "ja": "TLSサーバは、証明書チェーンを検証し、クライアントの公開鍵を抽出し、キータイプは、クライアント認証方法に適していることを確認します。"
    },
    {
      "indent": 0,
      "text": "5.7. Client Key Exchange",
      "section_title": true,
      "ja": "5.7. クライアント鍵交換"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent in all key exchange algorithms. If client authentication with ECDSA_fixed_ECDH or RSA_fixed_ECDH is used, this message is empty. Otherwise, it contains the client's ephemeral ECDH public key.",
      "ja": "このメッセージは、すべての鍵交換アルゴリズムに送信されます。 ECDSA_fixed_ECDHまたはRSA_fixed_ECDHとクライアント認証を使用する場合は、このメッセージは空です。それ以外の場合は、クライアントのはかないECDH公開鍵が含まれています。"
    },
    {
      "indent": 3,
      "text": "Meaning of the message:",
      "ja": "メッセージの意味："
    },
    {
      "indent": 3,
      "text": "This message is used to convey ephemeral data relating to the key exchange belonging to the client (such as its ephemeral ECDH public key).",
      "ja": "このメッセージは、（そのはかないECDH公開鍵として）クライアントに属する鍵交換に関連する一時的なデータを伝えるために使用されます。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 3,
      "text": "The TLS ClientKeyExchange message is extended as follows.",
      "ja": "次のようにTLS ClientKeyExchangeメッセージが拡張されます。"
    },
    {
      "indent": 8,
      "text": "enum { implicit, explicit } PublicValueEncoding;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "implicit, explicit: For ECC cipher suites, this indicates whether the client's ECDH public key is in the client's certificate (\"implicit\") or is provided, as an ephemeral ECDH public key, in the ClientKeyExchange message (\"explicit\"). (This is \"explicit\" in ECC cipher suites except when the client uses the ECDSA_fixed_ECDH or RSA_fixed_ECDH client authentication mechanism.)",
      "ja": "暗黙的には、明示的に：ECC暗号スイートでは、これはクライアントのECDH公開鍵が（「暗黙の」）、クライアントの証明書であるか（「明示的な」）ClientKeyExchangeメッセージで、はかないECDH公開鍵として、提供されているかどうかを示します。 （これは、クライアントがECDSA_fixed_ECDHまたはRSA_fixed_ECDHクライアント認証メカニズムを使用している場合を除き、ECC暗号スイートに「明示的」です。）"
    },
    {
      "indent": 8,
      "text": "struct {\n    select (PublicValueEncoding) {\n        case implicit: struct { };\n        case explicit: ECPoint ecdh_Yc;\n    } ecdh_public;\n} ClientECDiffieHellmanPublic;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ecdh_Yc: Contains the client's ephemeral ECDH public key as a byte string ECPoint.point, which may represent an elliptic curve point in uncompressed or compressed format. Here, the format MUST conform to what the server has requested through a Supported Point Formats Extension if this extension was used, and MUST be uncompressed if this extension was not used.",
      "ja": "ecdh_Ycは：非圧縮または圧縮形式で、楕円曲線上の点を表すことができるバイトの文字列ECPoint.point、などクライアントのはかないECDH公開鍵が含まれています。ここで、フォーマットは、この拡張機能を使用した場合、サーバーがサポートされている小数点形式拡張を介して要求したものに従わなければなりませんし、この拡張は使用されなかった場合、非圧縮でなければなりません。"
    },
    {
      "indent": 8,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case ec_diffie_hellman: ClientECDiffieHellmanPublic;\n    } exchange_keys;\n} ClientKeyExchange;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The client selects an ephemeral ECDH public key corresponding to the parameters it received from the server according to the ECKAS-DH1 scheme from IEEE 1363 [6]. It conveys this information to the client in the ClientKeyExchange message using the format defined above.",
      "ja": "クライアントは、IEEE 1363からECKAS-DH1方式に従ってサーバから受信したパラメータに対応するはかないECDH公開鍵を選択する[6]。これは、上記で定義されたフォーマットを使用して、ClientKeyExchangeメッセージでクライアントにこの情報を伝えます。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The server retrieves the client's ephemeral ECDH public key from the ClientKeyExchange message and checks that it is on the same elliptic curve as the server's ECDH key.",
      "ja": "サーバは、サーバのECDHキーと同じ楕円曲線上にあるClientKeyExchangeメッセージとチェックから、クライアントのはかないECDH公開鍵を取得します。"
    },
    {
      "indent": 0,
      "text": "5.8. Certificate Verify",
      "section_title": true,
      "ja": "5.8. 証明書は、確認してください"
    },
    {
      "indent": 3,
      "text": "When this message is sent:",
      "ja": "このメッセージが送信された場合："
    },
    {
      "indent": 3,
      "text": "This message is sent when the client sends a client certificate containing a public key usable for digital signatures, e.g., when the client is authenticated using the ECDSA_sign mechanism.",
      "ja": "クライアントがECDSA_sign機構を使用して認証された場合、クライアントは、例えば、デジタル署名のために使用可能な公開鍵を含むクライアント証明書を送信するとき、このメッセージが送信されます。"
    },
    {
      "indent": 3,
      "text": "Meaning of the message:",
      "ja": "メッセージの意味："
    },
    {
      "indent": 3,
      "text": "This message contains a signature that proves possession of the private key corresponding to the public key in the client's Certificate message.",
      "ja": "このメッセージは、クライアントのCertificateメッセージ内の公開鍵に対応する秘密鍵の所有を証明する署名が含まれています。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:",
      "ja": "このメッセージの構造："
    },
    {
      "indent": 3,
      "text": "The TLS CertificateVerify message and the underlying Signature type are defined in [2] and [3], and the latter is extended here in Section 5.4. For the ecdsa case, the signature field in the CertificateVerify message contains an ECDSA signature computed over handshake messages exchanged so far, exactly similar to CertificateVerify with other signing algorithms in [2] and [3]:",
      "ja": "TLS CertificateVerifyメッセージとその下の署名タイプが定義されている[2]、[3]、後者は5.4でここに拡張されます。 ECDSAの場合について、CertificateVerifyメッセージに署名フィールドは、ハンドシェイクメッセージに関して計算ECDSA署名の中の他の署名アルゴリズムとCertificateVerifyに、これまで正確に同様の交換を含んでいる[2]、[3]。"
    },
    {
      "indent": 8,
      "text": "CertificateVerify.signature.sha_hash\n    SHA(handshake_messages);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ECDSA signatures are computed as described in Section 5.10, and SHA in the above template for sha_hash accordingly may denote a hash algorithm other than SHA-1. As per ANSI X9.62, an ECDSA signature consists of a pair of integers, r and s. The digitally-signed element is encoded as an opaque vector <0..2^16-1>, the contents of which are the DER encoding [9] corresponding to the following ASN.1 notation [8].",
      "ja": "SHA-1以外のハッシュアルゴリズムを表してもよい従ってsha_hashための上記テンプレートのセクション5.10に記載され、そしてSHAとしてECDSA署名が計算されます。 ANSI X9.62に従って、ECDSA署名は整数、rおよびsの対から成ります。デジタル署名された要素は、DER符号化された内容は、[8] [9]以下のASN.1表記に対応し、不透明なベクトル<^ 16-1 0..2>としてコード化されます。"
    },
    {
      "indent": 8,
      "text": "Ecdsa-Sig-Value ::= SEQUENCE {\n    r       INTEGER,\n    s       INTEGER\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Actions of the sender:",
      "ja": "送信者のアクション："
    },
    {
      "indent": 3,
      "text": "The client computes its signature over all handshake messages sent or received starting at client hello and up to but not including this message. It uses the private key corresponding to its certified public key to compute the signature, which is conveyed in the format defined above.",
      "ja": "クライアントは、クライアントハローとまでが、このメッセージを含まないから始まる送信または受信したすべてのハンドシェイクメッセージの上にその署名を計算します。これは、上記で定義された形式で搬送される署名を計算するための証明される公開鍵に対応する秘密鍵を使用します。"
    },
    {
      "indent": 3,
      "text": "Actions of the receiver:",
      "ja": "受信機のアクション："
    },
    {
      "indent": 3,
      "text": "The server extracts the client's signature from the CertificateVerify message, and verifies the signature using the public key it received in the client's Certificate message.",
      "ja": "サーバはCertificateVerifyメッセージからクライアントの署名を抽出し、それは、クライアントの証明書メッセージで受信した公開鍵を使って署名を検証します。"
    },
    {
      "indent": 0,
      "text": "5.9. Elliptic Curve Certificates",
      "section_title": true,
      "ja": "5.9. 楕円曲線証明書"
    },
    {
      "indent": 3,
      "text": "X.509 certificates containing ECC public keys or signed using ECDSA MUST comply with [14] or another RFC that replaces or extends it. Clients SHOULD use the elliptic curve domain parameters recommended in ANSI X9.62 [7], FIPS 186-2 [11], and SEC 2 [13].",
      "ja": "ECC公開鍵を含むか、[14]または置き換え、またはそれを拡張する他のRFCに準拠している必要がありECDSAを用いて署名されたX.509証明書。クライアントは、ANSI X9.62に推奨される楕円曲線ドメインパラメータを使用すべきである[7]、186-2 [11] FIPS、およびSEC 2 [13]。"
    },
    {
      "indent": 0,
      "text": "5.10. ECDH, ECDSA, and RSA Computations",
      "section_title": true,
      "ja": "5.10.  ECDH、ECDSA、およびRSA計算"
    },
    {
      "indent": 3,
      "text": "All ECDH calculations (including parameter and key generation as well as the shared secret calculation) are performed according to [6] using the ECKAS-DH1 scheme with the identity map as key derivation function (KDF), so that the premaster secret is the x-coordinate of the ECDH shared secret elliptic curve point represented as an octet string. Note that this octet string (Z in IEEE 1363 terminology) as output by FE2OSP, the Field Element to Octet String Conversion Primitive, has constant length for any given field; leading zeros found in this octet string MUST NOT be truncated.",
      "ja": "前マスター秘密がXとなるように（パラメータと鍵生成、ならびに共有秘密計算を含む）すべてのECDH計算は、[6]キー導出関数（KDF）として識別地図ECKAS-DH1方式を使用に従って行われますECDHの - 座標は、オクテットストリングとして表さ秘密楕円曲線点を共有しました。このオクテットストリングFE2OSP、プリミティブオクテットストリングへの変換フィールド要素によって出力として（IEEE 1363用語でZ）は、任意の所与のフィールドのための一定の長さを有していることに留意されたいです。このオクテット文字列で見つかった先行ゼロは切り捨ててはなりません。"
    },
    {
      "indent": 3,
      "text": "(Note that this use of the identity KDF is a technicality. The complete picture is that ECDH is employed with a non-trivial KDF because TLS does not directly use the premaster secret for anything other than for computing the master secret. As of TLS 1.0 [2] and 1.1 [3], this means that the MD5- and SHA-1-based TLS PRF serves as a KDF; it is conceivable that future TLS versions or new TLS extensions introduced in the future may vary this computation.)",
      "ja": "（アイデンティティKDFのこの使用は、専門的であることに注意してください。完全な絵がTLSは直接マスターシークレットを計算するため以外の目的でプリマスターシークレットを使用していないので、ECDHは非自明なKDFで採用されていることである。TLS 1.0のとおり[2]、1.1 [3]、これはMD5-とSHA-1ベースのTLS PRFがKDFとして機能することを意味し、将来のTLSバージョンまたは将来的に導入された新しいTLS拡張がこの計算を変えることができると考えられます）。"
    },
    {
      "indent": 3,
      "text": "All ECDSA computations MUST be performed according to ANSI X9.62 [7] or its successors. Data to be signed/verified is hashed, and the result run directly through the ECDSA algorithm with no additional hashing. The default hash function is SHA-1 [10], and sha_size (see Sections 5.4 and 5.8) is 20. However, an alternative hash function, such as one of the new SHA hash functions specified in FIPS 180-2 [10], may be used instead if the certificate containing the EC public",
      "ja": "全てECDSA計算は、ANSI X9.62 [7]またはその後継に従って実行されなければなりません。データが署名される/検証ハッシュ化され、その結果はありません、追加のハッシュとECDSAアルゴリズムを介して直接実行されます。デフォルトのハッシュ関数は、FIPS 180-2に指定された新しいSHAハッシュ関数の一つとして、SHA-1 [10]、及びsha_size（セクション5.4および5.8を参照）、しかしながら、代替のハッシュ関数20である、[10]であり、証明書はEC公共を含む場合は代わりに使用することができます"
    },
    {
      "indent": 3,
      "text": "key explicitly requires use of another hash function. (The mechanism for specifying the required hash function has not been standardized, but this provision anticipates such standardization and obviates the need to update this document in response. Future PKIX RFCs may choose, for example, to specify the hash function to be used with a public key in the parameters field of subjectPublicKeyInfo.)",
      "ja": "キーは、明示的に別のハッシュ関数を使用する必要があります。 （必要なハッシュ関数を指定するための機構が標準化されていないが、この規定は、このような標準化を予測し、それに応答して、この文書を更新する必要がなくなる。今後PKIX RFCはで使用するハッシュ関数を指定するために、例えば、選択することができますSubjectPublicKeyInfoでのパラメータフィールド内の公開鍵。）"
    },
    {
      "indent": 3,
      "text": "All RSA signatures must be generated and verified according to PKCS#1 [12] block type 1.",
      "ja": "すべてのRSA署名はPKCS＃1 [12]ブロックタイプ1に従って生成され、検証されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. Cipher Suites",
      "section_title": true,
      "ja": "6.暗号スイート"
    },
    {
      "indent": 3,
      "text": "The table below defines new ECC cipher suites that use the key exchange algorithms specified in Section 2.",
      "ja": "以下の表は、第2節で指定された鍵交換アルゴリズムを使用して新しいECC暗号スイートを定義します。"
    },
    {
      "indent": 5,
      "text": "CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = { 0xC0, 0x01 } CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = { 0xC0, 0x02 } CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = { 0xC0, 0x03 } CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = { 0xC0, 0x04 } CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = { 0xC0, 0x05 }",
      "ja": "CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = {0xC0の、0×01}のCipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = {0xC0の、0×02}のCipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = {0xC0の、0×03}のCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = {0xC0の、0×04}のCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = {0xC0の、0x05を}"
    },
    {
      "indent": 5,
      "text": "CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = { 0xC0, 0x06 } CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = { 0xC0, 0x07 } CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = { 0xC0, 0x08 } CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = { 0xC0, 0x09 } CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = { 0xC0, 0x0A }",
      "ja": "CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = {0xC0の、0x06でのCipherSuite} TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = {0xC0の、0x07の}のCipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = {0xC0の、0x08に}のCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = {0xC0の、0x09の}のCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = {0xC0の、0x0Aを}"
    },
    {
      "indent": 5,
      "text": "CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = { 0xC0, 0x0B } CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = { 0xC0, 0x0C } CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = { 0xC0, 0x0D } CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = { 0xC0, 0x0E } CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = { 0xC0, 0x0F }",
      "ja": "CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = {0xC0の、0x0Bの}のCipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = {0xC0の、0x0Cの}のCipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = {0xC0の、0x0Dを}のCipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = {0xC0の、0x0Eの}のCipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = {0xC0の、0x0Fの}"
    },
    {
      "indent": 5,
      "text": "CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = { 0xC0, 0x10 } CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = { 0xC0, 0x11 } CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = { 0xC0, 0x12 } CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = { 0xC0, 0x13 } CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = { 0xC0, 0x14 }",
      "ja": "CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = {0xC0の、0x10を}のCipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = {0xC0の、0x11を}のCipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = {0xC0の、0x12を}のCipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = {0xC0の、0x13を}のCipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = {0xC0の、0x14の}"
    },
    {
      "indent": 5,
      "text": "CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = { 0xC0, 0x15 } CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = { 0xC0, 0x16 } CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = { 0xC0, 0x17 } CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = { 0xC0, 0x18 } CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = { 0xC0, 0x19 }",
      "ja": "CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = {0xC0の、0x15の}のCipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = {0xC0の、0x16}のCipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = {0xC0の、0x17の}のCipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = {0xC0の、0x18の}のCipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = {0xC0の、0x19}"
    },
    {
      "indent": 24,
      "text": "Table 5: TLS ECC cipher suites",
      "ja": "表5：TLS ECC暗号スイート"
    },
    {
      "indent": 3,
      "text": "The key exchange method, cipher, and hash algorithm for each of these cipher suites are easily determined by examining the name. Ciphers (other than AES ciphers) and hash algorithms are defined in [2] and [3]. AES ciphers are defined in [19].",
      "ja": "これらの暗号スイートのそれぞれの鍵交換方式、暗号、ハッシュアルゴリズムが簡単に名前を調べることによって決定されます。 （AES暗号以外）暗号やハッシュアルゴリズムが定義されている[2]、[3]。 AES暗号は[19]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Server implementations SHOULD support all of the following cipher suites, and client implementations SHOULD support at least one of them: TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, and TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA.",
      "ja": "サーバーの実装は、以下の暗号スイートのすべてをサポートする必要があり、クライアントの実装は、それらの少なくとも1つをサポートする必要がありますTLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA、TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA、およびTLS_ECDHE_RSA_WITH_AES_128_CBC_SHAを。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Security issues are discussed throughout this memo.",
      "ja": "セキュリティの問題は、このメモ中で議論されています。"
    },
    {
      "indent": 3,
      "text": "For TLS handshakes using ECC cipher suites, the security considerations in appendices D.2 and D.3 of [2] and [3] apply accordingly.",
      "ja": "ECC暗号スイートの付録D.2とD.3のセキュリティ上の考慮事項を使用してTLSハンドシェイクのための[2]、[3]に応じて適用します。"
    },
    {
      "indent": 3,
      "text": "Security discussions specific to ECC can be found in [6] and [7]. One important issue that implementers and users must consider is elliptic curve selection. Guidance on selecting an appropriate elliptic curve size is given in Table 1.",
      "ja": "ECCに固有のセキュリティ議論はで見つけることができる[6]、[7]。実装者とユーザーが考慮しなければならない一つの重要な問題は、楕円曲線の選択です。適切な楕円曲線のサイズの選択に関するガイダンスは、表1に示します。"
    },
    {
      "indent": 3,
      "text": "Beyond elliptic curve size, the main issue is elliptic curve structure. As a general principle, it is more conservative to use elliptic curves with as little algebraic structure as possible. Thus, random curves are more conservative than special curves such as Koblitz curves, and curves over F_p with p random are more conservative than curves over F_p with p of a special form (and curves over F_p with p random might be considered more conservative than curves over F_2^m as there is no choice between multiple fields of similar size for characteristic 2). Note, however, that algebraic structure can also lead to implementation efficiencies, and implementers and users may, therefore, need to balance conservatism against a need for efficiency. Concrete attacks are known against only very few special classes of curves, such as supersingular curves, and these classes are excluded from the ECC standards that this document references [6], [7].",
      "ja": "楕円曲線の大きさを超えて、主な問題は、楕円曲線構造です。一般原則として、できるだけ少ない代数構造を有する楕円曲線を使用するより保守的です。このように、ランダムな曲線は、Koblitz曲線のような特殊な曲線より保守的であり、ランダムpでF_P上の曲線は、曲線より保守的とみなされるかもしれないランダムpでF_P上特殊な形態のPとF_P上の曲線（曲線より保守的ですF_2 ^ M上特性2に対する同様の大きさの複数のフィールド）の間の選択の余地がないように。代数的構造は、実装効率につながることができ、および実装と、ユーザーは、このため、効率の必要性に対して保守主義のバランスを取る必要があること、しかし、注意してください。コンクリートの攻撃は、超特異曲線などの曲線のごく少数の特別なクラス、反対知られており、これらのクラスは、ECC規格から除外され、このドキュメントの参照[6]、[7]。"
    },
    {
      "indent": 3,
      "text": "Another issue is the potential for catastrophic failures when a single elliptic curve is widely used. In this case, an attack on the elliptic curve might result in the compromise of a large number of keys. Again, this concern may need to be balanced against efficiency and interoperability improvements associated with widely-used curves. Substantial additional information on elliptic curve choice can be found in [5], [6], [7], and [11].",
      "ja": "もう一つの問題は、単一の楕円曲線が広く使用されている致命的な障害の可能性です。この場合には、楕円曲線上の攻撃は、キーの多数の妥協をもたらすかもしれません。再び、この懸念は、広く使用されている曲線に関連付けられた効率性と相互運用性の向上に対してバランスされる必要があるかもしれません。楕円曲線上の選択に実質的な付加的な情報を見つけることができる[5]、[6]、[7]、および[11]。"
    },
    {
      "indent": 3,
      "text": "Implementers and users must also consider whether they need forward secrecy. Forward secrecy refers to the property that session keys are not compromised if the static, certified keys belonging to the server and client are compromised. The ECDHE_ECDSA and ECDHE_RSA key exchange algorithms provide forward secrecy protection in the event of server key compromise, while ECDH_ECDSA and ECDH_RSA do not. Similarly, if the client is providing a static, certified key, ECDSA_sign client authentication provides forward secrecy protection in the event of client key compromise, while ECDSA_fixed_ECDH and RSA_fixed_ECDH do not. Thus, to obtain complete forward secrecy protection, ECDHE_ECDSA or ECDHE_RSA must be used for key exchange, with ECDSA_sign used for client authentication if necessary. Here again the security benefits of forward secrecy may need to be balanced against the improved efficiency offered by other options.",
      "ja": "実装者とユーザーはまた、彼らは前進の秘密保持を必要とするかどうかを検討しなければなりません。転送秘密は、サーバーとクライアントに属する静的、認定されたキーが侵害された場合にセッション鍵が危険にさらされていないプロパティを参照します。 ECDH_ECDSAとECDH_RSAがいない間ECDHE_ECDSAとECDHE_RSA鍵交換アルゴリズムは、サーバーキーの侵害が発生した場合には前進の秘密保持の保護を提供します。クライアントは、静的、認定キーを提供している場合ECDSA_fixed_ECDHとRSA_fixed_ECDHがいない間同様に、ECDSA_signクライアント認証は、クライアントキー妥協のイベントでの前進の秘密保持の保護を提供します。必要に応じてECDSA_signは、クライアントの認証に使用してこのように、完全な前進の秘密保持の保護を得るために、ECDHE_ECDSAまたはECDHE_RSAは、鍵交換に使用する必要があります。ここで再び前進の秘密保持のセキュリティ上の利点は、他のオプションが提供する効率の向上に対してバランスする必要があるかもしれません。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document describes three new name spaces for use with the TLS protocol:",
      "ja": "このドキュメントは、TLSプロトコルで使用するための3つの新しい名前空間について説明します。"
    },
    {
      "indent": 3,
      "text": "o NamedCurve (Section 5.1)",
      "ja": "NamedCurve O（5.1節）"
    },
    {
      "indent": 3,
      "text": "o ECPointFormat (Section 5.1)",
      "ja": "O ECPointFormat（5.1節）"
    },
    {
      "indent": 3,
      "text": "o ECCurveType (Section 5.4)",
      "ja": "ECCurveType O（5.4節）"
    },
    {
      "indent": 3,
      "text": "For each name space, this document defines the initial value assignments and defines a range of 256 values (NamedCurve) or eight values (ECPointFormat and ECCurveType) reserved for Private Use. Any additional assignments require IETF Consensus action [16].",
      "ja": "各名前空間のために、この文書は、初期値の割り当てを定義し、プライベート使用のために予約さ256個の値（NamedCurve）または8つの値（ECPointFormatとECCurveType）の範囲を規定します。任意の追加割り当ては、[16] IETF Consensus動作を必要とします。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgements",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Bill Anderson and Tim Dierks.",
      "ja": "著者は、ビル・アンダーソンとティム・ダークスに感謝したいです。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Bradner, S., \"Key Words for Use in RFCs to Indicate Requirement Levels\", RFC 2119, March 1997.",
      "ja": "[1]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、RFC 2119、1997年3月を。"
    },
    {
      "indent": 3,
      "text": "[2] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[2]ダークス、T.とC.アレン、 \"TLSプロトコルバージョン1.0\"、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[3] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.1\", RFC 4346, April 2006.",
      "ja": "[3]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.1\"、RFC 4346、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[4] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, \"Transport Layer Security (TLS) Extensions\", RFC 4366, April 2006.",
      "ja": "[4]ブレイク・ウィルソン、S.、Nystrom、M.、ホップウッド、D.、ミケルセン、J.、およびT.ライト、 \"トランスポート層セキュリティ（TLS）拡張機能\"、RFC 4366、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[5] SECG, \"Elliptic Curve Cryptography\", SEC 1, 2000, <http://www.secg.org/>.",
      "ja": "[5] SECG、 \"楕円曲線暗号\"、SEC 1、2000、<http://www.secg.org/>。"
    },
    {
      "indent": 3,
      "text": "[6] IEEE, \"Standard Specifications for Public Key Cryptography\", IEEE 1363, 2000.",
      "ja": "[6] IEEE、 \"公開鍵暗号のための標準仕様\"、IEEE 1363、2000。"
    },
    {
      "indent": 3,
      "text": "[7] ANSI, \"Public Key Cryptography For The Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)\", ANSI X9.62, 1998.",
      "ja": "[7] ANSI、 \"金融サービス業界のための公開鍵暗号：楕円曲線デジタル署名アルゴリズム（ECDSA）\"、ANSI X9.62、1998。"
    },
    {
      "indent": 3,
      "text": "[8] International Telecommunication Union, \"Information technology - Abstract Syntax Notation One (ASN.1): Specification of basic notation\", ITU-T Recommendation X.680, 2002.",
      "ja": "[8]国際電気通信連合、 \"情報技術 - 抽象構文記法1（ASN.1）：基本的な表記法の仕様\"、ITU-T勧告X.680、2002。"
    },
    {
      "indent": 3,
      "text": "[9] International Telecommunication Union, \"Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ITU-T Recommendation X.690, 2002.",
      "ja": "[9]国際電気通信連合、 \"情報技術 -  ASN.1エンコーディング規則：基本符号化規則（BER）、Canonicalの符号化規則（CER）、および顕著な符号化規則（DER）の仕様\"、ITU-T勧告X.690、2002 。"
    },
    {
      "indent": 3,
      "text": "[10] NIST, \"Secure Hash Standard\", FIPS 180-2, 2002.",
      "ja": "[10] NIST、FIPS 180-2、2002年 \"ハッシュ標準セキュア\"。"
    },
    {
      "indent": 3,
      "text": "[11] NIST, \"Digital Signature Standard\", FIPS 186-2, 2000.",
      "ja": "[11] NIST、 \"デジタル署名標準\"、186-2、2000 FIPS。"
    },
    {
      "indent": 3,
      "text": "[12] RSA Laboratories, \"PKCS#1: RSA Encryption Standard version 1.5\", PKCS 1, November 1993.",
      "ja": "[12] RSA Laboratories社、 \"PKCS＃1：RSA暗号化規格バージョン1.5\"、PKCS 1、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[13] SECG, \"Recommended Elliptic Curve Domain Parameters\", SEC 2, 2000, <http://www.secg.org/>.",
      "ja": "[13] SECG、 \"推奨楕円曲線ドメインパラメータ\"、SEC 2、2000、<http://www.secg.org/>。"
    },
    {
      "indent": 3,
      "text": "[14] Polk, T., Housley, R., and L. Bassham, \"Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 3279, April 2002.",
      "ja": "[14]ポーク、T.、Housley氏、R.、およびL. Bassham、 \"アルゴリズムとインターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）プロフィールの識別子\"、RFC 3279、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[15] Housley, R., Polk, T., Ford, W., and D. Solo, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 3280, April 2002.",
      "ja": "[15] Housley氏、R.、ポーク、T.、フォード、W.、およびD.ソロ、 \"インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）プロフィール\"、RFC 3280、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[16] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", RFC 2434, October 1998.",
      "ja": "[16] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、RFC 2434、1998年10月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[17] Harper, G., Menezes, A., and S. Vanstone, \"Public-Key Cryptosystems with Very Small Key Lengths\", Advances in Cryptology -- EUROCRYPT '92, LNCS 658, 1993.",
      "ja": "[17]ハーパー、G.、メネゼス、A.、およびS. Vanstone著、 \"超小型キーの長さを有する公開鍵暗号\" は、暗号理論における進歩 -  EUROCRYPT '92、LNCS 658、1993。"
    },
    {
      "indent": 3,
      "text": "[18] Lenstra, A. and E. Verheul, \"Selecting Cryptographic Key Sizes\", Journal of Cryptology 14 (2001) 255-293, <http://www.cryptosavvy.com/>.",
      "ja": "[18] Lenstra、A.及びE. Verheul、 \"暗号鍵長を選択\"、暗号理論の14誌（2001）255から293、<http://www.cryptosavvy.com/>。"
    },
    {
      "indent": 3,
      "text": "[19] Chown, P., \"Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)\", RFC 3268, June 2002.",
      "ja": "、RFC 3268、2002年6月[19]のchown、P.、 \"トランスポート層セキュリティ（TLS）用のAdvanced Encryption Standard（AES）暗号の組み合わせ\"。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Equivalent Curves (Informative)",
      "ja": "付録A.等価曲線（参考情報）"
    },
    {
      "indent": 3,
      "text": "All of the NIST curves [11] and several of the ANSI curves [7] are equivalent to curves listed in Section 5.1.1. In the following table, multiple names in one row represent aliases for the same curve.",
      "ja": "NIST曲線[11]とANSI曲線[7]のいくつかの全ては、セクション5.1.1に記載されている曲線に相当します。以下の表では、1行の複数の名前は、同じ曲線のエイリアスを表します。"
    },
    {
      "indent": 13,
      "text": "------------------------------------------\n          Curve names chosen by\n     different standards organizations\n------------+---------------+-------------\nSECG        |  ANSI X9.62   |  NIST\n------------+---------------+-------------\nsect163k1   |               |   NIST K-163\nsect163r1   |               |\nsect163r2   |               |   NIST B-163\nsect193r1   |               |\nsect193r2   |               |\nsect233k1   |               |   NIST K-233\nsect233r1   |               |   NIST B-233\nsect239k1   |               |\nsect283k1   |               |   NIST K-283\nsect283r1   |               |   NIST B-283\nsect409k1   |               |   NIST K-409\nsect409r1   |               |   NIST B-409\nsect571k1   |               |   NIST K-571\nsect571r1   |               |   NIST B-571\nsecp160k1   |               |\nsecp160r1   |               |\nsecp160r2   |               |\nsecp192k1   |               |\nsecp192r1   |  prime192v1   |   NIST P-192\nsecp224k1   |               |\nsecp224r1   |               |   NIST P-224\nsecp256k1   |               |\nsecp256r1   |  prime256v1   |   NIST P-256\nsecp384r1   |               |   NIST P-384\nsecp521r1   |               |   NIST P-521\n------------+---------------+-------------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Table 6: Equivalent curves defined by SECG, ANSI, and NIST",
      "ja": "表6：SECG、ANSI、およびNISTによって定義された同等の曲線"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Simon Blake-Wilson SafeNet Technologies BV Amstelveenseweg 88-90 1075 XJ, Amsterdam NL",
      "ja": "サイモン・ブレイク・ウィルソンSafeNetのテクノロジーBV Amstelveenseweg 88-90 1075 XJ、アムステルダムNL"
    },
    {
      "indent": 3,
      "text": "Phone: +31 653 899 836 EMail: sblakewilson@safenet-inc.com",
      "ja": "電話：+31 653 899 836 Eメール：sblakewilson@safenet-inc.com"
    },
    {
      "indent": 3,
      "text": "Nelson Bolyard Sun Microsystems Inc. 4170 Network Circle MS SCA17-201 Santa Clara, CA 95054 US",
      "ja": "ネルソンBolyardサン・マイクロ株式会社4170ネットワークサークルMS SCA17-201サンタクララ、カリフォルニア州95054米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 930 1443 EMail: nelson@bolyard.com",
      "ja": "電話：+1 408 930 1443 Eメール：nelson@bolyard.com"
    },
    {
      "indent": 3,
      "text": "Vipul Gupta Sun Microsystems Laboratories 16 Network Circle MS UMPK16-160 Menlo Park, CA 94025 US",
      "ja": "ビパル・グプタSun Microsystemsの研究所16ネットワークサークルMS UMPK16-160メンロパーク、CA 94025米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 786 7551 EMail: vipul.gupta@sun.com",
      "ja": "電話：+1 650 786 7551 Eメール：vipul.gupta@sun.com"
    },
    {
      "indent": 3,
      "text": "Chris Hawk Corriente Networks LLC 1563 Solano Ave., #484 Berkeley, CA 94707 US",
      "ja": "クリス・ホークストリームネットワークスLLC 1563ソラノアベニュー、第484位バークレー、CA 94707米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 510 527 0601 EMail: chris@corriente.net",
      "ja": "電話：+1 510 527 0601 Eメール：chris@corriente.net"
    },
    {
      "indent": 3,
      "text": "Bodo Moeller Ruhr-Uni Bochum Horst-Goertz-Institut, Lehrstuhl fuer Kommunikationssicherheit IC 4/139 44780 Bochum DE",
      "ja": "ボードーメラールール地方大学ボーフムホルストGoertz研究所、通信セキュリティIC 139分の4 44780ボーフムDEのための椅子"
    },
    {
      "indent": 3,
      "text": "Phone: +49 234 32 26795 EMail: bodo@openssl.org",
      "ja": "電話：+49 234 32 26795 Eメール：bodo@openssl.org"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディタ機能のための資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}