{
  "title": {
    "text": "RFC 4460 - Stream Control Transmission Protocol (SCTP) Specification Errata and Issues",
    "ja": "RFC 4460 - ストリーム制御伝送プロトコル（SCTP）仕様正誤表と課題"
  },
  "number": 4460,
  "created_at": "2019-10-25 07:32:54.563673+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         R. Stewart\nRequest for Comments: 4460                           Cisco Systems, Inc.\nCategory: Informational                               I. Arias-Rodriguez\n                                                   Nokia Research Center\n                                                                 K. Poon\n                                                  Sun Microsystems, Inc.\n                                                                 A. Caro\n                                                        BBN Technologies\n                                                               M. Tuexen\n                                      Muenster Univ. of Applied Sciences\n                                                              April 2006",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Stream Control Transmission Protocol (SCTP) Specification\n                    Errata and Issues",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document is a compilation of issues found during six interoperability events and 5 years of experience with implementing, testing, and using Stream Control Transmission Protocol (SCTP) along with the suggested fixes. This document provides deltas to RFC 2960 and is organized in a time-based way. The issues are listed in the order they were brought up. Because some text is changed several times, the last delta in the text is the one that should be applied. In addition to the delta, a description of the problem and the details of the solution are also provided.",
      "ja": "この文書では、6つの相互運用性のイベントや、実装、テスト、および提案の修正と一緒にストリーム制御伝送プロトコル（SCTP）を使用しての経験5年の間に見つかった問題をまとめたものです。この文書は、RFC 2960にデルタを提供し、時間ベースの方法で編成されます。問題は、彼らが育った順に表示されます。いくつかのテキストが複数回変更されているので、テキストの最後のデルタが適用されるべきものです。デルタに加えて、問題の説明および溶液の詳細も提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................6\n   1.1. Conventions ................................................7\n2. Corrections to RFC 2960 .........................................7\n   2.1. Incorrect Error Type During Chunk Processing. ..............7\n        2.1.1. Description of the Problem ..........................7\n        2.1.2. Text changes to the document ........................7\n        2.1.3. Solution Description ................................7",
      "raw": true
    },
    {
      "indent": 6,
      "text": "2.2. Parameter Processing Issue .................................7\n     2.2.1. Description of the Problem ..........................7\n     2.2.2. Text Changes to the Document ........................8\n     2.2.3. Solution Description ................................8\n2.3. Padding Issues .............................................8\n     2.3.1. Description of the Problem ..........................8\n     2.3.2. Text Changes to the Document ........................9\n     2.3.3. Solution Description ...............................10\n2.4. Parameter Types across All Chunk Types ....................10\n     2.4.1. Description of the Problem .........................10\n     2.4.2. Text Changes to the Document .......................10\n     2.4.3. Solution Description ...............................12\n2.5. Stream Parameter Clarification ............................12\n     2.5.1. Description of the problem .........................12\n     2.5.2. Text Changes to the Document .......................12\n     2.5.3. Solution Description ...............................13\n2.6. Restarting Association Security Issue .....................13\n     2.6.1. Description of the Problem .........................13\n     2.6.2. Text Changes to the Document .......................14\n     2.6.3. Solution Description ...............................18\n2.7. Implicit Ability to Exceed cwnd by PMTU-1 Bytes ...........19\n     2.7.1. Description of the Problem .........................19\n     2.7.2. Text Changes to the Document .......................19\n     2.7.3. Solution Description ...............................19\n2.8. Issues with Fast Retransmit ...............................19\n     2.8.1. Description of the Problem .........................19\n     2.8.2. Text Changes to the Document .......................20\n     2.8.3. Solution Description ...............................23\n2.9. Missing Statement about partial_bytes_acked Update ........24\n     2.9.1. Description of the Problem .........................24\n     2.9.2. Text Changes to the Document .......................24\n     2.9.3. Solution Description ...............................25\n2.10. Issues with Heartbeating and Failure Detection ...........25\n     2.10.1. Description of the Problem ........................25\n     2.10.2. Text Changes to the Document ......................26\n     2.10.3. Solution Description ..............................28\n2.11. Security interactions with firewalls .....................29\n     2.11.1. Description of the Problem ........................29\n     2.11.2. Text Changes to the Document ......................29\n     2.11.3. Solution Description ..............................31\n2.12. Shutdown Ambiguity .......................................31\n     2.12.1. Description of the Problem ........................31\n     2.12.2. Text Changes to the Document ......................31\n     2.12.3. Solution Description ..............................32\n2.13. Inconsistency in ABORT Processing ........................32\n     2.13.1. Description of the Problem ........................32\n     2.13.2. Text changes to the document ......................33\n     2.13.3. Solution Description ..............................33",
      "raw": true
    },
    {
      "indent": 6,
      "text": "2.14. Cwnd Gated by Its Full Use ...............................34\n     2.14.1. Description of the Problem ........................34\n     2.14.2. Text Changes to the Document ......................34\n     2.14.3. Solution Description ..............................36\n2.15. Window Probes in SCTP ....................................36\n     2.15.1. Description of the Problem ........................36\n     2.15.2. Text Changes to the Document ......................36\n     2.15.3. Solution Description ..............................38\n2.16. Fragmentation and Path MTU Issues ........................39\n     2.16.1. Description of the Problem ........................39\n     2.16.2. Text Changes to the Document ......................39\n     2.16.3. Solution Description ..............................40\n2.17. Initial Value of the Cumulative TSN Ack ..................40\n     2.17.1. Description of the Problem ........................40\n     2.17.2. Text Changes to the Document ......................40\n     2.17.3. Solution Description ..............................41\n2.18. Handling of Address Parameters within the INIT or\n      INIT-ACK .................................................41\n     2.18.1. Description of the Problem ........................41\n     2.18.2. Text Changes to the Document ......................41\n     2.18.3. Solution description ..............................42\n2.19. Handling of Stream Shortages .............................42\n     2.19.1. Description of the Problem ........................42\n     2.19.2. Text Changes to the Document ......................42\n     2.19.3. Solution Description ..............................43\n2.20. Indefinite Postponement ..................................43\n     2.20.1. Description of the Problem ........................43\n     2.20.2. Text Changes to the Document ......................43\n     2.20.3. Solution Description ..............................44\n2.21. User-Initiated Abort of an Association ...................44\n     2.21.1. Description of the Problem ........................44\n     2.21.2. Text changes to the document ......................44\n     2.21.3. Solution Description ..............................50\n2.22. Handling of Invalid Initiate Tag of INIT-ACK .............50\n     2.22.1. Description of the Problem ........................50\n     2.22.2. Text Changes to the Document ......................50\n     2.22.3. Solution Description ..............................51\n2.23. Sending an ABORT in Response to an INIT ..................51\n     2.23.1. Description of the Problem ........................51\n     2.23.2. Text Changes to the Document ......................51\n     2.23.3. Solution Description ..............................52\n2.24. Stream Sequence Number (SSN) Initialization ..............52\n     2.24.1. Description of the Problem ........................52\n     2.24.2. Text Changes to the Document ......................52\n     2.24.3. Solution Description ..............................53\n2.25. SACK Packet Format .......................................53\n     2.25.1. Description of the Problem ........................53\n     2.25.2. Text Changes to the Document ......................53",
      "raw": true
    },
    {
      "indent": 6,
      "text": "     2.25.3. Solution Description ..............................53\n2.26. Protocol Violation Error Cause ...........................53\n     2.26.1. Description of the Problem ........................53\n     2.26.2. Text Changes to the Document ......................54\n     2.26.3. Solution Description ..............................56\n2.27. Reporting of Unrecognized Parameters .....................56\n     2.27.1. Description of the Problem ........................56\n     2.27.2. Text Changes to the Document ......................56\n     2.27.3. Solution Description ..............................57\n2.28. Handling of IP Address Parameters ........................58\n     2.28.1. Description of the Problem ........................58\n     2.28.2. Text Changes to the Document ......................58\n     2.28.3. Solution Description ..............................58\n2.29. Handling of COOKIE ECHO Chunks When a TCB Exists .........59\n     2.29.1. Description of the Problem ........................59\n     2.29.2. Text Changes to the Document ......................59\n     2.29.3. Solution Description ..............................59\n2.30. The Initial Congestion Window Size .......................59\n     2.30.1. Description of the Problem ........................59\n     2.30.2. Text Changes to the Document ......................60\n     2.30.3. Solution Description ..............................61\n2.31. Stream Sequence Numbers in Figures .......................62\n     2.31.1. Description of the Problem ........................62\n     2.31.2. Text Changes to the Document ......................63\n     2.31.3. Solution description ..............................67\n2.32. Unrecognized Parameters ..................................67\n     2.32.1. Description of the Problem ........................67\n     2.32.2. Text Changes to the Document ......................67\n     2.32.3. Solution Description ..............................68\n2.33. Handling of Unrecognized Parameters ......................68\n     2.33.1. Description of the Problem ........................68\n     2.33.2. Text Changes to the Document ......................68\n     2.33.3. Solution Description ..............................70\n2.34. Tie Tags .................................................70\n     2.34.1. Description of the Problem ........................70\n     2.34.2. Text Changes to the Document ......................70\n     2.34.3. Solution Description ..............................72\n2.35. Port Number Verification in the COOKIE-ECHO ..............72\n     2.35.1. Description of the Problem ........................72\n     2.35.2. Text Changes to the Document ......................72\n     2.35.3. Solution Description ..............................73\n2.36. Path Initialization ......................................74\n     2.36.1. Description of the Problem ........................74\n     2.36.2. Text Changes to the Document ......................74\n     2.36.3. Solution Description ..............................76\n2.37. ICMP Handling Procedures .................................76\n     2.37.1. Description of the Problem ........................76\n     2.37.2. Text Changes to the Document ......................77",
      "raw": true
    },
    {
      "indent": 6,
      "text": "     2.37.3. Solution Description ..............................79\n2.38. Checksum .................................................79\n     2.38.1. Description of the problem ........................79\n     2.38.2. Text Changes to the Document ......................79\n     2.38.3. Solution Description ..............................86\n2.39. Retransmission Policy ....................................86\n     2.39.1. Description of the Problem ........................86\n     2.39.2. Text Changes to the Document ......................87\n     2.39.3. Solution Description ..............................87\n2.40. Port Number 0 ............................................88\n     2.40.1. Description of the Problem ........................88\n     2.40.2. Text Changes to the Document ......................88\n     2.40.3. Solution Description ..............................89\n2.41. T Bit ....................................................89\n     2.41.1. Description of the Problem ........................89\n     2.41.2. Text Changes to the Document ......................89\n     2.41.3. Solution Description ..............................93\n2.42. Unknown Parameter Handling ...............................93\n     2.42.1. Description of the Problem ........................93\n     2.42.2. Text Changes to the Document ......................93\n     2.42.3. Solution Description ..............................95\n2.43. Cookie Echo Chunk ........................................95\n     2.43.1. Description of the Problem ........................95\n     2.43.2. Text Changes to the Document ......................95\n     2.43.3. Solution Description ..............................96\n2.44. Partial Chunks ...........................................96\n     2.44.1. Description of the Problem ........................96\n     2.44.2. Text Changes to the Document ......................96\n     2.44.3. Solution Description ..............................97\n2.45. Non-unicast Addresses ....................................97\n     2.45.1. Description of the Problem ........................97\n     2.45.2. Text Changes to the Document ......................97\n     2.45.3. Solution Description ..............................98\n2.46. Processing of ABORT Chunks ...............................98\n     2.46.1. Description of the Problem ........................98\n     2.46.2. Text Changes to the Document ......................98\n     2.46.3. Solution Description ..............................98\n2.47. Sending of ABORT Chunks ..................................99\n     2.47.1. Description of the Problem ........................99\n     2.47.2. Text Changes to the Document ......................99\n     2.47.3. Solution Description ..............................99\n2.48. Handling of Supported Address Types Parameter ............99\n     2.48.1. Description of the Problem ........................99\n     2.48.2. Text Changes to the Document .....................100\n     2.48.3. Solution Description .............................100\n2.49. Handling of Unexpected Parameters .......................101\n     2.49.1. Description of the Problem .......................101\n     2.49.2. Text Changes to the Document .....................101",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        2.49.3. Solution Description .............................102\n   2.50. Payload Protocol Identifier .............................102\n        2.50.1. Description of the Problem .......................102\n        2.50.2. Text Changes to the Document .....................103\n        2.50.3. Solution Description .............................103\n   2.51. Karn's Algorithm ........................................104\n        2.51.1. Description of the Problem .......................104\n        2.51.2. Text Changes to the Document .....................104\n        2.51.3. Solution Description .............................104\n   2.52. Fast Retransmit Algorithm ...............................104\n        2.52.1. Description of the Problem .......................104\n        2.52.2. Text Changes to the Document .....................105\n        2.52.3. Solution Description .............................105\n3. Security Considerations .......................................105\n4. Acknowledgements ..............................................106\n5. IANA Considerations ...........................................106\n6. Normative References ..........................................106",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document contains a compilation of all defects found up until the publishing of this document for the Stream Control Transmission Protocol (SCTP), RFC 2960 [5]. These defects may be of an editorial or technical nature. This document may be thought of as a companion document to be used in the implementation of SCTP to clarify errors in the original SCTP document.",
      "ja": "この文書では、[5] RFC 2960、ストリーム制御伝送プロトコル（SCTP）については、この文書の発行まで検出されたすべての欠陥のコンパイルが含まれています。これらの欠陥は、編集上または技術的な性質のものであってもよいです。この文書では、元のSCTP文書の誤りを明確にするためにSCTPの実装に使用されるコンパニオン文書として考えることができます。"
    },
    {
      "indent": 3,
      "text": "This document provides a history of the changes that will be compiled into RFC 2960's [5] BIS document. Each error will be detailed within this document in the form of",
      "ja": "この文書は、RFC 2960の[5] BISの文書にコンパイルされる変更の履歴を提供します。各エラーは次の形式で、この文書の中に詳述されます"
    },
    {
      "indent": 3,
      "text": "o the problem description,",
      "ja": "O問題の説明、"
    },
    {
      "indent": 3,
      "text": "o the text quoted from RFC 2960 [5],",
      "ja": "RFC 2960から引用されたテキストO [5]、"
    },
    {
      "indent": 3,
      "text": "o the replacement text that should be placed into the BIS document, and",
      "ja": "BISドキュメントに配置する必要があります置換テキストO、および"
    },
    {
      "indent": 3,
      "text": "o a description of the solution.",
      "ja": "溶液の説明O。"
    },
    {
      "indent": 3,
      "text": "This document is a historical record of sequential changes what have been found necessary at various interop events and through discussion on this list.",
      "ja": "この文書では、さまざまな相互運用イベントで、このリスト上の議論を通じて必要であることが見出されてきたものを、順次、変更の履歴レコードです。"
    },
    {
      "indent": 3,
      "text": "Note that because some text is changed several times, the last delta for a text in the document is the erratum for that text in RFC 2960.",
      "ja": "いくつかのテキストが複数回変更されるため、文書内のテキストの最後のデルタはRFC 2960で、そのテキストのエラッタであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions",
      "section_title": true,
      "ja": "1.1。表記"
    },
    {
      "indent": 3,
      "text": "The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL, when they appear in this document, are to be interpreted as described in RFC 2119 [2].",
      "ja": "キーワードは、REQUIREDは、、、、、推奨しません、MAYを推奨、オプション、彼らは、この文書に表示されたときに、RFC 2119で説明されているように解釈されるすべきでないないものとものとしてはなりませんしなければならない[2]。"
    },
    {
      "indent": 1,
      "text": "2. Corrections to",
      "section_title": true,
      "ja": "2.訂正へ"
    },
    {
      "indent": 0,
      "text": "2.1. Incorrect Error Type During Chunk Processing.",
      "section_title": true,
      "ja": "2.1。チャンク処理中に誤ったエラーの種類。"
    },
    {
      "indent": 0,
      "text": "2.1.1. Description of the Problem",
      "section_title": true,
      "ja": "2.1.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "A typo was discovered in RFC 2960 [5] that incorrectly specifies an action to be taken when processing chunks of unknown identity.",
      "ja": "タイプミスはRFC 2960 [5]誤っ未知のアイデンティティのチャンクを処理するときに実行されるアクションを指定で発見されました。"
    },
    {
      "indent": 0,
      "text": "2.1.2. Text changes to the document",
      "section_title": true,
      "ja": "2.1.2。文書へのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "01  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理し、（ERRORのいずれかまたはINIT ACKで）「認識できないパラメータ型」で認識されていないパラメータを報告しません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized chunk in an 'Unrecognized Chunk Type'.",
      "ja": "01  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理し、「認識できないチャンクタイプ」で認識されていないチャンクを報告しません。"
    },
    {
      "indent": 0,
      "text": "2.1.3. Solution Description",
      "section_title": true,
      "ja": "2.1.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The receiver of an unrecognized chunk should not send a 'parameter' error but instead should send the appropriate chunk error as described above.",
      "ja": "認識されないチャンクの受信機は、「パラメータ」エラーを送信するべきではないが、代わりに上記のように適切なチャンクエラーを送信します。"
    },
    {
      "indent": 0,
      "text": "2.2. Parameter Processing Issue",
      "section_title": true,
      "ja": "2.2。パラメータ処理の問題"
    },
    {
      "indent": 0,
      "text": "2.2.1. Description of the Problem",
      "section_title": true,
      "ja": "2.2.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "A typographical error was introduced through an improper cut and paste in the use of the upper two bits to describe proper handling of unknown parameters.",
      "ja": "誤字は未知のパラメータの適切な取り扱いを記述するために上位2ビットを使用することで不適切なカット・アンド・ペーストを介して導入しました。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.2.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this SCTP packet and discard it; do not process any further chunks within it.",
      "ja": "00  - このSCTPパケットの処理を停止し、それを捨てます。その内の任意の更なるチャンクを処理しません。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "01  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理し、（ERRORのいずれかまたはINIT ACKで）「認識できないパラメータ型」で認識されていないパラメータを報告しません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this SCTP chunk and discard it, do not process any further parameters within this chunk.",
      "ja": "00  - このSCTPチャンクの処理を停止し、それを廃棄し、このチャンク内の任意の他のパラメータを処理しません。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP chunk and discard it, do not process any further parameters within this chunk, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "01  - このSCTPチャンクの処理を停止し、それを廃棄し、このチャンク内の任意の他のパラメータを処理し、（ERRORのいずれかまたはINIT ACKで）「認識できないパラメータ型」で認識されていないパラメータを報告しません。"
    },
    {
      "indent": 0,
      "text": "2.2.3. Solution Description",
      "section_title": true,
      "ja": "2.2.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "It was always the intent to stop processing at the level one was at in an unknown chunk or parameter with the upper bit set to 0. Thus, if you are processing a chunk, you should drop the packet. If you are processing a parameter, you should drop the chunk.",
      "ja": "常に1つは、あなたがチャンクを処理している場合は、あなたがパケットをドロップする必要があり、このように0に設定され、上位ビットと未知のチャンクまたはパラメータ内にあったレベルでの処理を停止する意図でした。あなたは、パラメータを処理している場合は、チャンクをドロップする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3. Padding Issues",
      "section_title": true,
      "ja": "2.3。パディングの問題"
    },
    {
      "indent": 0,
      "text": "2.3.1. Description of the Problem",
      "section_title": true,
      "ja": "2.3.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "A problem was found when a Chunk terminated in a TLV parameter. If this last TLV was not on a 32-bit boundary (as required), there was confusion as to whether the last padding was included in the chunk length.",
      "ja": "チャンクは、TLVパラメータで終了したときに問題が発見されました。 （必要に応じて）、この最後のTLVは、32ビット境界でなかった場合、最後にパディングがチャンク長さに含まれていたかどうかに関して混乱がありました。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.3.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Length: 16 bits (unsigned integer)",
      "ja": "チャンクの長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the size of the chunk in bytes including the Chunk Type, Chunk Flags, Chunk Length, and Chunk Value fields. Therefore, if the Chunk Value field is zero-length, the Length field will be set to 4. The Chunk Length field does not count any padding.",
      "ja": "この値は、チャンクタイプ、チャンクフラグ、チャンク長、およびチャンク値フィールドを含むバイト単位のチャンクのサイズを表します。チャンク値フィールドが長さゼロの場合はそのため、長さフィールドは、任意のパディングをカウントされません4.チャンク長フィールドに設定されます。"
    },
    {
      "indent": 3,
      "text": "Chunk Value: variable length",
      "ja": "チャンク値：可変長"
    },
    {
      "indent": 6,
      "text": "The Chunk Value field contains the actual information to be transferred in the chunk. The usage and format of this field is dependent on the Chunk Type.",
      "ja": "チャンク値フィールドは、チャンクに転送される実際の情報が含まれています。このフィールドの使用方法と形式は、チャンクタイプに依存しています。"
    },
    {
      "indent": 3,
      "text": "The total length of a chunk (including Type, Length and Value fields) MUST be a multiple of 4 bytes. If the length of the chunk is not a multiple of 4 bytes, the sender MUST pad the chunk with all zero bytes and this padding is not included in the chunk length field. The sender should never pad with more than 3 bytes. The receiver MUST ignore the padding bytes.",
      "ja": "（タイプ、長さおよび値フィールドを含む）のチャンクの合計長さが4バイトの倍数でなければなりません。チャンクの長さが4バイトの倍数でない場合、送信者MUSTパッドは全てゼロバイトのチャンクと、このパディングは、チャンク長フィールドに含まれていません。送信者は、以上の3バイトのパッドありません。受信機は、パディングバイトを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Length: 16 bits (unsigned integer)",
      "ja": "チャンクの長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the size of the chunk in bytes, including the Chunk Type, Chunk Flags, Chunk Length, and Chunk Value fields. Therefore, if the Chunk Value field is zero-length, the Length field will be set to 4. The Chunk Length field does not count any chunk padding.",
      "ja": "この値は、チャンクタイプ、チャンクフラグ、チャンク長、およびチャンク値フィールドを含むバイト単位のチャンクのサイズを表します。チャンク値フィールドが長さゼロの場合はそのため、長さフィールドは、任意のチャンクのパディングをカウントしない4.チャンク長フィールドに設定されます。"
    },
    {
      "indent": 6,
      "text": "Chunks (including Type, Length, and Value fields) are padded out by the sender with all zero bytes to be a multiple of 4 bytes long. This padding MUST NOT be more than 3 bytes in total. The Chunk Length value does not include terminating padding of the chunk. However, it does include padding of any variable-length parameter except the last parameter in the chunk. The receiver MUST ignore the padding.",
      "ja": "（タイプ、長さ、および値フィールドを含む）チャンクが長い4バイトの倍数になるように、すべてのゼロバイトの送信側によってパディングされます。このパディングは合計で3つの以上のバイト以下でなければなりません。チャンク長値は、チャンクのパディングを終了含まれていません。しかし、それはチャンクで最後のパラメータを除くすべての可変長パラメータのパディングを含みません。受信機は、パディングを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: A robust implementation should accept the Chunk whether or not the final padding has been included in the Chunk Length.",
      "ja": "注：堅牢な実装では、最終的なパディングがチャンク長に含まれているか否かのチャンクを受け入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "Chunk Value: variable length",
      "ja": "チャンク値：可変長"
    },
    {
      "indent": 6,
      "text": "The Chunk Value field contains the actual information to be transferred in the chunk. The usage and format of this field is dependent on the Chunk Type.",
      "ja": "チャンク値フィールドは、チャンクに転送される実際の情報が含まれています。このフィールドの使用方法と形式は、チャンクタイプに依存しています。"
    },
    {
      "indent": 3,
      "text": "The total length of a chunk (including Type, Length, and Value fields) MUST be a multiple of 4 bytes. If the length of the chunk is not a multiple of 4 bytes, the sender MUST pad the chunk with all zero bytes, and this padding is not included in the chunk length field. The sender should never pad with more than 3 bytes. The receiver MUST ignore the padding bytes.",
      "ja": "（タイプ、長さ、および値フィールドを含む）のチャンクの合計長さが4バイトの倍数でなければなりません。チャンクの長さが4バイトの倍数でない場合、送信者MUSTパッドは全てゼロバイトのチャンク、このパディングは、チャンク長フィールドに含まれていません。送信者は、以上の3バイトのパッドありません。受信機は、パディングバイトを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Solution Description",
      "section_title": true,
      "ja": "2.3.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above text makes clear that the padding of the last parameter is not included in the Chunk Length field. It also clarifies that the padding of parameters that are not the last one must be counted in the Chunk Length field.",
      "ja": "上記のテキストは、最後のパラメータのパディングがチャンク長フィールドに含まれていないことが明らかになります。また、最後のないパラメータのパディングがチャンク長フィールドでカウントされなければならないことを明確にしています。"
    },
    {
      "indent": 0,
      "text": "2.4. Parameter Types across All Chunk Types",
      "section_title": true,
      "ja": "2.4。すべてのチャンクタイプでパラメータの種類"
    },
    {
      "indent": 0,
      "text": "2.4.1. Description of the Problem",
      "section_title": true,
      "ja": "2.4.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "A problem was noted when multiple errors are needed to be sent regarding unknown or unrecognized parameters. Since often the error type does not hold the chunk type field, it may become difficult to tell which error was associated with which chunk.",
      "ja": "複数のエラーが不明または認識できないパラメータに関する送信することが必要とされているときに問題が認められました。多くの場合、エラーの種類がチャンクタイプフィールドを保持していないので、それがどのチャンクに関連付けられたエラー伝えることは困難になることがあります。"
    },
    {
      "indent": 0,
      "text": "2.4.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.4.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The actual SCTP parameters are defined in the specific SCTP chunk sections. The rules for IETF-defined parameter extensions are defined in Section 13.2.",
      "ja": "実際のSCTPパラメータは、特定のSCTPチャンクセクションで定義されています。 IETF定義のパラメータの拡張のための規則は、13.2節で定義されています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The actual SCTP parameters are defined in the specific SCTP chunk sections. The rules for IETF-defined parameter extensions are defined in Section 13.2. Note that a parameter type MUST be unique across all chunks. For example, the parameter type '5' is used to represent an IPv4 address (see Section 3.3.2). The value '5' then is reserved across all chunks to represent an IPv4 address and MUST NOT be reused with a different meaning in any other chunk.",
      "ja": "実際のSCTPパラメータは、特定のSCTPチャンクセクションで定義されています。 IETF定義のパラメータの拡張のための規則は、13.2節で定義されています。パラメータの型は、すべてのチャンクで一意である必要があります。例えば、パラメータタイプが「5」（セクション3.3.2を参照）、IPv4アドレスを表すために使用されます。値が「5」そして、IPv4アドレスを表すために、すべてのチャンク間で予約されており、他のチャンクで異なる意味を再利用してはいけません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 13.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "13.2 IETF-defined Chunk Parameter Extension",
      "section_title": true,
      "ja": "13.2 IETF定義のチャンクパラメータの拡張"
    },
    {
      "indent": 3,
      "text": "The assignment of new chunk parameter type codes is done through an IETF Consensus action as defined in [RFC2434]. Documentation of the chunk parameter MUST contain the following information:",
      "ja": "[RFC2434]で定義されるように、新しいチャンクのパラメータ型コードの割り当ては、IETF Consensus動作を介して行われます。チャンクパラメータのドキュメントには、以下の情報を含まなければなりません："
    },
    {
      "indent": 3,
      "text": "a) Name of the parameter type.",
      "ja": "パラメータの型のa）の名前。"
    },
    {
      "indent": 3,
      "text": "b) Detailed description of the structure of the parameter field. This structure MUST conform to the general type-length-value format described in Section 3.2.1.",
      "ja": "パラメータフィールドの構造のb）の詳細な説明。この構造は、セクション3.2.1に記載した一般的なタイプレングス値の形式に準拠しなければなりません。"
    },
    {
      "indent": 3,
      "text": "c) Detailed definition of each component of the parameter type.",
      "ja": "C）パラメータタイプの各構成要素の詳細な定義。"
    },
    {
      "indent": 3,
      "text": "d) Detailed description of the intended use of this parameter type, and an indication of whether and under what circumstances multiple instances of this parameter type may be found within the same chunk.",
      "ja": "D）の詳細は、このパラメータ・タイプの使用目的の記述、及びこのパラメータの型の複数のインスタンスが同じチャンク内に見出すことができるかどうか、およびどのような状況下での指示。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 13.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "13.2. IETF-defined Chunk Parameter Extension",
      "section_title": true,
      "ja": "13.2。 IETF定義のチャンクパラメータの拡張"
    },
    {
      "indent": 3,
      "text": "The assignment of new chunk parameter type codes is done through an IETF Consensus action, as defined in [RFC2434]. Documentation of the chunk parameter MUST contain the following information:",
      "ja": "新しいチャンクパラメータタイプコードの割り当ては、[RFC2434]で定義されるように、IETF Consensus動作を介して行われます。チャンクパラメータのドキュメントには、以下の情報を含まなければなりません："
    },
    {
      "indent": 3,
      "text": "a) Name of the parameter type.",
      "ja": "パラメータの型のa）の名前。"
    },
    {
      "indent": 3,
      "text": "b) Detailed description of the structure of the parameter field. This structure MUST conform to the general type-length-value format described in Section 3.2.1.",
      "ja": "パラメータフィールドの構造のb）の詳細な説明。この構造は、セクション3.2.1に記載した一般的なタイプレングス値の形式に準拠しなければなりません。"
    },
    {
      "indent": 3,
      "text": "c) Detailed definition of each component of the parameter type.",
      "ja": "C）パラメータタイプの各構成要素の詳細な定義。"
    },
    {
      "indent": 3,
      "text": "d) Detailed description of the intended use of this parameter type, and an indication of whether and under what circumstances multiple instances of this parameter type may be found within the same chunk.",
      "ja": "D）の詳細は、このパラメータ・タイプの使用目的の記述、及びこのパラメータの型の複数のインスタンスが同じチャンク内に見出すことができるかどうか、およびどのような状況下での指示。"
    },
    {
      "indent": 3,
      "text": "e) Each parameter type MUST be unique across all chunks.",
      "ja": "e）の各パラメータの型はすべてのチャンクで一意である必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4.3. Solution Description",
      "section_title": true,
      "ja": "2.4.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "By having all parameters unique across all chunk assignments (the current assignment policy), no ambiguity exists as to what a parameter means in different contexts. The trade-off for this is a smaller parameter space, i.e., 65,536 parameters versus 65,536 * Number-of- chunks.",
      "ja": "すべてのチャンクの割り当て間で一意すべてのパラメータ（現在の割り当てポリシー）を有することによって、曖昧パラメータが異なるコンテキストで意味するように存在しません。これに対するトレードオフは、小さなパラメータ空間、すなわち、65,536 *番号オブチャンク対65,536パラメータ。"
    },
    {
      "indent": 0,
      "text": "2.5. Stream Parameter Clarification",
      "section_title": true,
      "ja": "2.5。ストリームパラメータの明確化"
    },
    {
      "indent": 0,
      "text": "2.5.1. Description of the problem",
      "section_title": true,
      "ja": "2.5.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "A problem was found where the specification is unclear on the legality of an endpoint asking for more stream resources than were allowed in the MIS value of the INIT. In particular, the value in the INIT ACK requested in its OS value was larger than the MIS value received in the INIT chunk. This behavior is illegal, yet it was unspecified in RFC 2960 [5]",
      "ja": "仕様はINITのMIS値で許可されたよりも多くのストリームリソースを求めるエンドポイントの合法性については不明であるという問題が発見されました。具体的には、そのOS値で要求INIT ACKの値がINITチャンクで受信MIS値よりも大きかったです。この動作は違法です、まだそれは、RFC 2960で指定されていないだった[5]"
    },
    {
      "indent": 0,
      "text": "2.5.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.5.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Number of Outbound Streams (OS): 16 bits (unsigned integer)",
      "ja": "アウトバウンドストリーム数（OS）：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the number of outbound streams the sender of this INIT ACK chunk wishes to create in this association. The value of 0 MUST NOT be used.",
      "ja": "このINIT ACKチャンクの送信者がこの協会で作成したいのアウトバウンドストリームの数を定義します。 0の値を使用してはいけません。"
    },
    {
      "indent": 6,
      "text": "Note: A receiver of an INIT ACK with the OS value set to 0 SHOULD destroy the association discarding its TCB.",
      "ja": "注：0に設定OS値とINIT ACKの受信機は、そのTCBを破棄会合を破壊するべきです。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Number of Outbound Streams (OS): 16 bits (unsigned integer)",
      "ja": "アウトバウンドストリーム数（OS）：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the number of outbound streams the sender of this INIT ACK chunk wishes to create in this association. The value of 0 MUST NOT be used, and the value MUST NOT be greater than the MIS value sent in the INIT chunk.",
      "ja": "このINIT ACKチャンクの送信者がこの協会で作成したいのアウトバウンドストリームの数を定義します。 0の値は、使用してはいけません、そして値がINITチャンクで送信されたMISの値を超えてはなりません。"
    },
    {
      "indent": 6,
      "text": "Note: A receiver of an INIT ACK with the OS value set to 0 SHOULD destroy the association, discarding its TCB.",
      "ja": "注：0に設定OS値とINIT ACKの受信機は、そのTCBを破棄、会合を破壊するべきです。"
    },
    {
      "indent": 0,
      "text": "2.5.3. Solution Description",
      "section_title": true,
      "ja": "2.5.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The change in wording, above, changes it so that a responder to an INIT chunk does not specify more streams in its OS value than were represented to it in the MIS value, i.e., its maximum.",
      "ja": "INITチャンクへの応答は、MIS値、即ち、最大でそれに示されたよりも、そのOS値の複数のストリームを指定しないように、文言の変更は、上記の、それを変更します。"
    },
    {
      "indent": 0,
      "text": "2.6. Restarting Association Security Issue",
      "section_title": true,
      "ja": "2.6。再起動協会セキュリティの問題"
    },
    {
      "indent": 0,
      "text": "2.6.1. Description of the Problem",
      "section_title": true,
      "ja": "2.6.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "A security problem was found when a restart occurs. It is possible for an intruder to send an INIT to an endpoint of an existing association. In the INIT the intruder would list one or more of the current addresses of an association and its own. The normal restart procedures would then occur, and the intruder would have hijacked an association.",
      "ja": "再起動が発生したときに、セキュリティの問題が発見されました。侵入者は、既存の関連付けのエンドポイントにINITを送信することが可能です。 INITで侵入者は、協会と、独自の現在のアドレスの一つ以上をリストします。通常の再起動の手順は、次に起こるであろう、と侵入者は関連をハイジャックしているだろう。"
    },
    {
      "indent": 0,
      "text": "2.6.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.6.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.10)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Cause Code\nValue           Cause Code\n---------      ----------------\n 1              Invalid Stream Identifier\n 2              Missing Mandatory Parameter\n 3              Stale Cookie Error\n 4              Out of Resource\n 5              Unresolvable Address\n 6              Unrecognized Chunk Type\n 7              Invalid Mandatory Parameter\n 8              Unrecognized Parameters\n 9              No User Data\n10              Cookie Received While Shutting Down",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cause Length: 16 bits (unsigned integer)",
      "ja": "原因長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause-Specific Information fields",
      "ja": "原因コード、原因の長さ、および原因固有の情報フィールドを含むバイト単位でのパラメータの大きさに設定してください"
    },
    {
      "indent": 3,
      "text": "Cause-specific Information: variable length",
      "ja": "原因固有情報：可変長"
    },
    {
      "indent": 6,
      "text": "This field carries the details of the error condition.",
      "ja": "このフィールドには、エラー状態の詳細を運びます。"
    },
    {
      "indent": 3,
      "text": "Sections 3.3.10.1 - 3.3.10.10 define error causes for SCTP.",
      "ja": "セクション3.3.10.1  -  3.3.10.10エラーがSCTPの原因を定義します。"
    },
    {
      "indent": 3,
      "text": "Guidelines for the IETF to define new error cause values are discussed in Section 13.3.",
      "ja": "新しいエラー原因値を定義するために、IETFのためのガイドラインは、13.3節で議論されています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.10)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Cause Code\nValue           Cause Code\n---------      ----------------\n 1              Invalid Stream Identifier\n 2              Missing Mandatory Parameter\n 3              Stale Cookie Error\n 4              Out of Resource\n 5              Unresolvable Address\n 6              Unrecognized Chunk Type\n 7              Invalid Mandatory Parameter\n 8              Unrecognized Parameters\n 9              No User Data\n10              Cookie Received While Shutting Down\n11              Restart of an Association with New Addresses",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cause Length: 16 bits (unsigned integer)",
      "ja": "原因長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause-Specific Information fields.",
      "ja": "原因コード、原因の長さ、および原因固有の情報フィールドを含むバイト単位でのパラメータの大きさに設定してください。"
    },
    {
      "indent": 3,
      "text": "Cause-specific Information: variable length",
      "ja": "原因固有情報：可変長"
    },
    {
      "indent": 6,
      "text": "This field carries the details of the error condition.",
      "ja": "このフィールドには、エラー状態の詳細を運びます。"
    },
    {
      "indent": 3,
      "text": "Sections 3.3.10.1 - 3.3.10.11 define error causes for SCTP. Guidelines for the IETF to define new error cause values are discussed in Section 13.3.",
      "ja": "セクション3.3.10.1  -  3.3.10.11エラーがSCTPの原因を定義します。新しいエラー原因値を定義するために、IETFのためのガイドラインは、13.3節で議論されています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Note no old text, new error cause added in section 3.3.10)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3.3.10.11. Restart of an Association with New Addresses (11)",
      "section_title": true,
      "ja": "3.3.10.11。新しいアドレスを持つ協会の再起動（11）"
    },
    {
      "indent": 4,
      "text": "Cause of error\n--------------\nRestart of an association with new addresses: An INIT was received\non an existing association.  But the INIT added addresses to the\nassociation that were previously NOT part of the association.  The\nnew addresses are listed in the error code.  This ERROR is normally\nsent as part of an ABORT refusing the INIT (see Section 5.2).",
      "raw": true
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Cause Code=11         |      Cause Length=Variable    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                       New Address TLVs                        /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Note: Each New Address TLV is an exact copy of the TLV that was found in the INIT chunk that was new, including the Parameter Type and the Parameter length.",
      "ja": "注意：それぞれの新しいアドレスTLVは、パラメータタイプとパラメータの長さを含む、新しいだったINITチャンクで発見されたTLVの正確なコピーです。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an endpoint MUST respond with an INIT ACK using the same parameters it sent in its original INIT chunk (including its Initiation Tag, unchanged). These original parameters are combined with those from the newly received INIT chunk. The endpoint shall also generate a State Cookie with the INIT ACK. The endpoint uses the parameters sent in its INIT to calculate the State Cookie.",
      "ja": "COOKIE-WAITまたはCOOKIE-エコー状態でINITを受信すると、エンドポイントは、それが（その開始タグを含む、変化しない）元のINITチャンクで送信され、同じパラメータを使用してINITのACKで応答しなければなりません。これら元のパラメータは、新たに受信したINITチャンクからのものと組み合わされます。エンドポイントはまた、INIT ACKと状態クッキーを生成しなければなりません。エンドポイントは状態クッキーを計算するために、そのINITに送信されたパラメータを使用しています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Upon receipt of an INIT in the COOKIE-WAIT state, an endpoint MUST respond with an INIT ACK using the same parameters it sent in its original INIT chunk (including its Initiation Tag, unchanged). When responding, the endpoint MUST send the INIT ACK back to the same address that the original INIT (sent by this endpoint) was sent to.",
      "ja": "COOKIE-WAIT状態でINITを受信すると、エンドポイントは、それが（その開始タグを含む、変化しない）元のINITチャンクで送信され、同じパラメータを使用してINITのACKで応答しなければなりません。応答する場合、エンドポイントはバック（このエンドポイントによって送信された）オリジナルのINITが送られた同じアドレスにINIT ACKを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an INIT in the COOKIE-ECHOED state, an endpoint MUST respond with an INIT ACK using the same parameters it sent in its original INIT chunk (including its Initiation Tag, unchanged), provided that no NEW address has been added to the forming association. If the INIT message indicates that a new address has been added to the association, then the entire INIT MUST be discarded, and NO changes should be made to the existing association. An ABORT SHOULD be sent in response that MAY include the error 'Restart of an association with new addresses'. The error SHOULD list the addresses that were added to the restarting association.",
      "ja": "COOKIE-ECHOED状態におけるINITを受信すると、エンドポイントは、新しいアドレスが追加されていないことを条件とする、（不変の、その開始タグを含む）を、その元のINITチャンクで送信され、同じパラメータを使用してINITのACKで応答しなければなりません関連付けを形成します。 INITメッセージは、新しいアドレスが関連付けに追加されたことを示す場合、全体INITは捨てなければなりません、及び変更は、既存の関連付けに対してなされるべきではありません。 ABORTはエラー「新しいアドレスとの関連付けの再起動」を含めてもよい対応して送ってください。エラーが再開協会に追加されたアドレスをリストする必要があります。"
    },
    {
      "indent": 3,
      "text": "When responding in either state (COOKIE-WAIT or COOKIE-ECHOED) with an INIT ACK, the original parameters are combined with those from the newly received INIT chunk. The endpoint shall also generate a State Cookie with the INIT ACK. The endpoint uses the parameters sent in its INIT to calculate the State Cookie.",
      "ja": "INIT ACKのいずれかの状態（COOKIE-WAITまたはCOOKIE-エコー）で応答する場合、元のパラメータは、新たに受信したINITチャンクからのものと組み合わされます。エンドポイントはまた、INIT ACKと状態クッキーを生成しなければなりません。エンドポイントは状態クッキーを計算するために、そのINITに送信されたパラメータを使用しています。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.2.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED, COOKIE-WAIT and SHUTDOWN-ACK-SENT",
      "ja": "5.2.2 CLOSED、COOKIE-ECHOED、COOKIE-WAITと-SENT SHUTDOWN-ACKよりも米国その他の予期しないINIT"
    },
    {
      "indent": 3,
      "text": "Unless otherwise stated, upon reception of an unexpected INIT for this association, the endpoint shall generate an INIT ACK with a State Cookie. In the outbound INIT ACK the endpoint MUST copy its current Verification Tag and peer's Verification Tag into a reserved place within the state cookie. We shall refer to these locations as the Peer's-Tie-Tag and the Local-Tie-Tag. The outbound SCTP packet containing this INIT ACK MUST carry a Verification Tag value equal to the Initiation Tag found in the unexpected INIT. And the INIT ACK MUST contain a new Initiation Tag (randomly generated see Section 5.3.1). Other parameters for the endpoint SHOULD be copied from the existing parameters of the association (e.g., number of outbound streams) into the INIT ACK and cookie.",
      "ja": "特に明記しない限り、この関連付けのための予想外のINITの受信時に、エンドポイントは、国家クッキーとINIT ACKを生成するものとします。アウトバウンドINIT ACKではエンドポイントは状態クッキー内の予約済みの場所に、現在の検証タグとピアの検証タグをコピーしなければなりません。我々はPeer's-タイタグとローカル・タイタグとしてこれらの場所を指すものとします。このINIT ACKを含むアウトバウンドSCTPパケットは、予期せぬINITで見つかった開始タグに等しい検証タグ値を運ばなければなりません。そして、INIT ACKは（ランダム5.3.1項を参照してください生成された）新しい開始タグを含まなければなりません。エンドポイントの他のパラメータはINIT ACKとクッキーに関連（例えば、アウトバウンドストリーム数）の既存のパラメータからコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "After sending out the INIT ACK, the endpoint shall take no further actions, i.e., the existing association, including its current state, and the corresponding TCB MUST NOT be changed.",
      "ja": "INIT ACKを送信した後、エンドポイント、すなわち、現在の状態、および対応するTCBを含む既存の関連付けは、変更してはならない、それ以上の行動を取るなりません。"
    },
    {
      "indent": 3,
      "text": "Note: Only when a TCB exists and the association is not in a COOKIE-WAIT state are the Tie-Tags populated. For a normal association INIT (i.e., the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be set to 0 (indicating that no previous TCB existed). The INIT ACK and State Cookie are populated as specified in section 5.2.1.",
      "ja": "注：TCBが存在し、アソシエーションがCOOKIE-WAIT状態でない場合にのみタイタグ移入されます。通常関連INIT（すなわち、エンドポイントは、COOKIE-WAIT状態にある）のために、タイタグ（以前のTCBが存在しないことを示す）を0に設定しなければなりません。セクション5.2.1で指定されたINIT ACKと状態クッキーが移入されます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.2.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5.2.2. Unexpected INIT in States Other Than CLOSED, COOKIE-ECHOED, COOKIE-WAIT, and SHUTDOWN-ACK-SENT",
      "ja": "5.2.2。米国以外CLOSEDに予期しないINIT、COOKIE-ECHOED、COOKIE-WAIT、及びSHUTDOWN-ACK-SENT"
    },
    {
      "indent": 3,
      "text": "Unless otherwise stated, upon receipt of an unexpected INIT for this association, the endpoint shall generate an INIT ACK with a State Cookie. Before responding, the endpoint MUST check to see if the unexpected INIT adds new addresses to the association. If new addresses are added to the association, the endpoint MUST respond with an ABORT, copying the 'Initiation Tag' of the unexpected INIT into the 'Verification Tag' of the outbound packet carrying the ABORT. In the ABORT response, the cause of error MAY be set to 'restart of an association with new addresses'. The error SHOULD list the addresses that were added to the restarting association.",
      "ja": "特に明記しない限り、この関連付けのための予想外のINITの受信時に、エンドポイントは、国家クッキーとINIT ACKを生成するものとします。応答する前に、エンドポイントは、予想外のINITが協会に新しいアドレスを追加するかどうかを確認するためにチェックしなければなりません。新しいアドレスが関連付けに追加された場合、エンドポイントはABORTを運ぶアウトバウンドパケットの「検証タグ」内に予想外のINITの「開始タグ」をコピーし、ABORTで応じなければなりません。 ABORT応答では、エラーの原因は、「新しいアドレスとの関連付けの再起動」に設定されるかもしれません。エラーが再開協会に追加されたアドレスをリストする必要があります。"
    },
    {
      "indent": 3,
      "text": "If no new addresses are added, when responding to the INIT in the outbound INIT ACK, the endpoint MUST copy its current Verification Tag and peer's Verification Tag into a reserved place within the state cookie. We shall refer to these locations as the Peer's-Tie-Tag and the Local-Tie-Tag. The outbound SCTP packet containing this INIT ACK MUST carry a Verification Tag value equal to the Initiation Tag found in the unexpected INIT. And the INIT ACK MUST contain a new Initiation Tag (randomly generated; see Section 5.3.1). Other parameters for the endpoint SHOULD be copied from the existing parameters of the association (e.g., number of outbound streams) into the INIT ACK and cookie.",
      "ja": "新しいアドレスが追加されていない場合、アウトバウンドのINIT ACKでINITに応答するときに、エンドポイントは状態クッキー内の予約済みの場所に、現在の検証タグとピアの検証タグをコピーしなければなりません。我々はPeer's-タイタグとローカル・タイタグとしてこれらの場所を指すものとします。このINIT ACKを含むアウトバウンドSCTPパケットは、予期せぬINITで見つかった開始タグに等しい検証タグ値を運ばなければなりません。そして、INIT ACKは、新しい開始タグが含まれなければならない（ランダムに生成し、5.3.1項を参照してください）。エンドポイントの他のパラメータはINIT ACKとクッキーに関連（例えば、アウトバウンドストリーム数）の既存のパラメータからコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "After sending out the INIT ACK or ABORT, the endpoint shall take no further actions; i.e., the existing association, including its current state, and the corresponding TCB MUST NOT be changed.",
      "ja": "INIT ACKまたはABORTを送信した後、エンドポイントはこれ以上行動を取らないものとします。即ち、その現在の状態を含む既存の関連付け、および対応するTCBを変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "Note: Only when a TCB exists and the association is not in a COOKIE-WAIT or SHUTDOWN-ACK-SENT state are the Tie-Tags populated with a value other than 0. For a normal association INIT (i.e., the endpoint is in the CLOSED state), the Tie-Tags MUST be set to 0 (indicating that no previous TCB existed).",
      "ja": "注：TCBが存在し、アソシエーションがCOOKIE-WAITまたはSHUTDOWN-ACK-SENT状態にない場合にのみ通常関連INITについて0以外の値で埋めタイタグである（すなわち、エンドポイントでありますCLOSED状態）、タイタグ）以前のTCBが存在しないことを示している（0に設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.6.3. Solution Description",
      "section_title": true,
      "ja": "2.6.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "A new error code is being added, along with specific instructions to send back an ABORT to a new association in a restart case or collision case, where new addresses have been added. The error code can be used by a legitimate restart to inform the endpoint that it has made a software error in adding a new address. The endpoint then can choose to wait until the OOTB ABORT tears down the old association, or to restart without the new address.",
      "ja": "新しいエラーコードは、新しいアドレスが追加された再起動ケースや衝突の場合には、新しいアソシエーションにABORTを送り返すために具体的な指示とともに、追加されています。エラーコードは、それが新しいアドレスを追加することで、ソフトウェア誤りをしているエンドポイントに通知するために、合法的な再起動で使用することができます。エンドポイントは、OOTB ABORTが古い協会を切断するまで待つか、新しいアドレスせずに再起動するように選択することができます。"
    },
    {
      "indent": 3,
      "text": "Also, the note at the end of Section 5.2.2 explaining the use of the Tie-Tags was modified to properly explain the states in which the Tie-Tags should be set to a value different than 0.",
      "ja": "また、タイのタグの使用を説明する5.2.2項の末尾のノートは適切にタイのタグが0とは異なる値に設定すべき状態を説明するために変更されました。"
    },
    {
      "indent": 0,
      "text": "2.7. Implicit Ability to Exceed cwnd by PMTU-1 Bytes",
      "section_title": true,
      "ja": "2.7。 PMTU-1バイトのcwndを超えることが暗黙の能力"
    },
    {
      "indent": 0,
      "text": "2.7.1. Description of the Problem",
      "section_title": true,
      "ja": "2.7.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Some implementations were having difficulty growing their cwnd. This was due to an improper enforcement of the congestion control rules. The rules, as written, provided for a slop over of the cwnd value. Without this slop over, the sender would appear NOT to be using its full cwnd value and thus would never increase it.",
      "ja": "いくつかの実装が困難彼らのcwndの成長を持ちました。これは、輻輳制御ルールの不適切な執行によるものでした。書かれたルールは、CWNDの値の上に傾きのために提供します。このスロップ以上がなければ、送信者は、その完全なcwndの値を使用してではないと思われるので、それを向上させることはありません。"
    },
    {
      "indent": 0,
      "text": "2.7.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.7.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "B) At any given time, the sender MUST NOT transmit new data to a given transport address if it has cwnd or more bytes of data outstanding to that transport address.",
      "ja": "それはcwndをまたはそのトランスポートアドレスへの未処理データのより多くのバイトをしている場合B）任意の時点で、送信者は、与えられた輸送アドレスに新しいデータを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "B) At any given time, the sender MUST NOT transmit new data to a given transport address if it has cwnd or more bytes of data outstanding to that transport address. The sender may exceed cwnd by up to (PMTU-1) bytes on a new transmission if the cwnd is not currently exceeded.",
      "ja": "それはcwndをまたはそのトランスポートアドレスへの未処理データのより多くのバイトをしている場合B）任意の時点で、送信者は、与えられた輸送アドレスに新しいデータを送信してはなりません。送信者は、CWNDが現在超過していない場合（PMTU-1）は新しい伝送にバイトまでによりCWNDを超えてもよいです。"
    },
    {
      "indent": 0,
      "text": "2.7.3. Solution Description",
      "section_title": true,
      "ja": "2.7.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The text changes make clear the ability to go over the cwnd value by no more than (PMTU-1) bytes.",
      "ja": "テキストの変更は、（PMTU-1）バイトを超えないことでのcwndの値より移動する機能をオフにします。"
    },
    {
      "indent": 0,
      "text": "2.8. Issues with Fast Retransmit",
      "section_title": true,
      "ja": "2.8。高速再送信に関する問題"
    },
    {
      "indent": 0,
      "text": "2.8.1. Description of the Problem",
      "section_title": true,
      "ja": "2.8.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Several problems were found in the current specification of fast retransmit. The current wording did not require GAP ACK blocks to be sent, even though they are essential to the workings of SCTP's congestion control. The specification left unclear how to handle the fast retransmit cycle, having the implementation wait on the cwnd to retransmit a TSN that was marked for fast retransmit. No limit was placed on how many times a TSN could be fast retransmitted. Fast Recovery was not specified, causing the congestion window to be reduced drastically when there are multiple losses in a single RTT.",
      "ja": "いくつかの問題は、高速再送の現在の仕様で発見されました。現在の文言は、彼らがSCTPの輻輳制御の働きに不可欠であるにもかかわらず、GAP ACKブロックを送信する必要はありませんでした。仕様は、高速再送信のためにマークされたTSNを再送信するのcwndの実装待ちを持つ、高速再送サイクルをどのように扱うかは不明残しました。制限なしにはTSNが速く再送される可能性がどのように何回に置かれませんでした。高速リカバリは、単一のRTT内に複数の損失がある場合に大幅に削減することが輻輳ウィンドウを引き起こして、指定されていませんでした。"
    },
    {
      "indent": 0,
      "text": "2.8.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.8.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Acknowledgements MUST be sent in SACK chunks unless shutdown was requested by the ULP in which case an endpoint MAY send an acknowledgement in the SHUTDOWN chunk. A SACK chunk can acknowledge the reception of multiple DATA chunks. See Section 3.3.4 for SACK chunk format. In particular, the SCTP endpoint MUST fill in the Cumulative TSN Ack field to indicate the latest sequential TSN (of a valid DATA chunk) it has received. Any received DATA chunks with TSN greater than the value in the Cumulative TSN Ack field SHOULD also be reported in the Gap Ack Block fields.",
      "ja": "シャットダウンが終点がSHUTDOWNチャンクに確認応答を送信することができ、その場合にはULPによって要求された場合を除き謝辞はSACKチャンクに送らなければなりません。 SACKチャンクは複数のDATAチャンクの受信を確認することができます。 SACKチャンク形式については、セクション3.3.4を参照してください。特に、SCTP終点は、それが受信した（有効なデータチャンクの）最新のシーケンシャルTSNを示すために、累積TSN ACKフィールドに記入しなければなりません。累積TSN ACKフィールドの値より大きいTSNを有する任意の受信したデータチャンクはまた、ギャップAckブロックフィールドで報告されるべきです。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Acknowledegments MUST be sent in SACK chunks unless shutdown was requested by the ULP, in which case an endpoint MAY send an acknowledgement in the SHUTDOWN chunk. A SACK chunk can acknowledge the reception of multiple DATA chunks. See Section 3.3.4 for SACK chunk format. In particular, the SCTP endpoint MUST fill in the Cumulative TSN Ack field to indicate the latest sequential TSN (of a valid DATA chunk) it has received. Any received DATA chunks with TSN greater than the value in the Cumulative TSN Ack field are reported in the Gap Ack Block fields. The SCTP endpoint MUST report as many Gap Ack Blocks as can fit in a single SACK chunk limited by the current path MTU.",
      "ja": "シャットダウンが終点がSHUTDOWNチャンクに確認応答を送信することができ、その場合にはULPによって要求された場合を除きAcknowledegmentsはSACKチャンクに送らなければなりません。 SACKチャンクは複数のDATAチャンクの受信を確認することができます。 SACKチャンク形式については、セクション3.3.4を参照してください。特に、SCTP終点は、それが受信した（有効なデータチャンクの）最新のシーケンシャルTSNを示すために、累積TSN ACKフィールドに記入しなければなりません。大きい累積TSN ACKフィールドの値よりもTSNを有する任意の受信したデータチャンクはギャップAckブロックフィールドに報告されています。現在のパスMTUによって制限され、単一のSACKチャンクに収まるようSCTP終点は、多くのギャップAckブロックとして報告しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "D) Any time a SACK arrives, the endpoint performs the following:",
      "ja": "D）SACKが到着するたびに、エンドポイントは以下を実行します。"
    },
    {
      "indent": 12,
      "text": "i) If Cumulative TSN Ack is less than the Cumulative TSN Ack\nPoint, then drop the SACK.  Since Cumulative TSN Ack is\nmonotonically increasing, a SACK whose Cumulative TSN Ack is\nless than the Cumulative TSN Ack Point indicates an out-of-\norder SACK.",
      "raw": true
    },
    {
      "indent": 12,
      "text": "ii) Set rwnd equal to the newly received a_rwnd minus the number of bytes still outstanding after processing the Cumulative TSN Ack and the Gap Ack Blocks.",
      "ja": "ii）のセットは、新たに受信したa_rwndマイナス累積TSN ACKおよびギャップAckブロックを処理した後、まだ未処理のバイト数に等しいRWND。"
    },
    {
      "indent": 12,
      "text": "iii) If the SACK is missing a TSN that was previously acknowledged via a Gap Ack Block (e.g., the data receiver reneged on the data), then mark the corresponding DATA chunk as available for retransmit: Mark it as missing for fast retransmit as described in Section 7.2.4 and if no retransmit timer is running for the destination address to which the DATA chunk was originally transmitted, then T3-rtx is started for that destination address.",
      "ja": "ⅲ）SACKが以前ギャップAckブロック（例えば、データ受信機がデータに破っ）を経由して認められたTSNが欠落している場合は、再送信用として利用できる対応するデータチャンクマーク：説明したように、高速再送信のために不足しているとしてマーク、それを何の再送信タイマーは、どのデータチャンクが最初に送信されたために宛先アドレスのために実行されていないセクション7.2.4にしている場合は、T3-RTXは、その宛先アドレスに対して開始されます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "D) Any time a SACK arrives, the endpoint performs the following:",
      "ja": "D）SACKが到着するたびに、エンドポイントは以下を実行します。"
    },
    {
      "indent": 12,
      "text": "i) If Cumulative TSN Ack is less than the Cumulative TSN Ack\nPoint, then drop the SACK.  Since Cumulative TSN Ack is\nmonotonically increasing, a SACK whose Cumulative TSN Ack is\nless than the Cumulative TSN Ack Point indicates an out-of-\norder SACK.",
      "raw": true
    },
    {
      "indent": 12,
      "text": "ii) Set rwnd equal to the newly received a_rwnd minus the number of bytes still outstanding after processing the Cumulative TSN Ack and the Gap Ack Blocks.",
      "ja": "ii）のセットは、新たに受信したa_rwndマイナス累積TSN ACKおよびギャップAckブロックを処理した後、まだ未処理のバイト数に等しいRWND。"
    },
    {
      "indent": 12,
      "text": "iii) If the SACK is missing a TSN that was previously acknowledged via a Gap Ack Block (e.g., the data receiver reneged on the data), then consider the corresponding DATA that might be possibly missing: Count one miss indication towards fast retransmit as described in Section 7.2.4, and if no retransmit timer is running for the destination address to which the DATA chunk was originally transmitted, then T3-rtx is started for that destination address.",
      "ja": "ⅲ）SACKが以前ギャップAckブロック（例えば、データ受信機がデータに破っ）を経由して認められたTSNが欠落している場合は、おそらく欠落している可能性があり、対応するデータを考慮してください。説明したように高速再送に対する1つのミス表示をカウント何の再送信タイマーがDATAチャンクが最初に送信されたと宛先アドレスのために実行されていない場合は、セクション7.2.4に、そして、その後、T3-RTXは、その宛先アドレスに対して開始されます。"
    },
    {
      "indent": 12,
      "text": "iv) If the Cumulative TSN Ack matches or exceeds the Fast Recovery exitpoint (Section 7.2.4), Fast Recovery is exited.",
      "ja": "累積TSN Ackは一致するか、高速リカバリexitpoint（第7.2.4項）を超えた場合IV）、高速回復を終了します。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Whenever an endpoint receives a SACK that indicates some TSN(s) missing, it SHOULD wait for 3 further miss indications (via subsequent SACK's) on the same TSN(s) before taking action with regard to Fast Retransmit.",
      "ja": "エンドポイントが不足しているいくつかのTSNを示しSACK（複数可）を受信するたびに、高速再送信に関して行動を起こす前に、同じTSN（S）上の（その後のSACKの経由）3点の、さらにミスの指摘を待つべき。"
    },
    {
      "indent": 3,
      "text": "When the TSN(s) is reported as missing in the fourth consecutive SACK, the data sender shall:",
      "ja": "TSN（複数可）4期連続SACKに欠けていると報告されている場合、データの送信者がしなければなりません。"
    },
    {
      "indent": 3,
      "text": "1) Mark the missing DATA chunk(s) for retransmission,",
      "ja": "1）マークを再送信のために失われたデータのチャンク（複数可）、"
    },
    {
      "indent": 3,
      "text": "2) Adjust the ssthresh and cwnd of the destination address(es) to which the missing DATA chunks were last sent, according to the formula described in Section 7.2.3.",
      "ja": "2）7.2.3項に記載の式に従って、欠落データチャンクが最後に送信された先のアドレス（ES）のSSTHRESHおよびCWNDを調整します。"
    },
    {
      "indent": 3,
      "text": "3) Determine how many of the earliest (i.e., lowest TSN) DATA chunks marked for retransmission will fit into a single packet, subject to constraint of the path MTU of the destination transport address to which the packet is being sent. Call this value K. Retransmit those K DATA chunks in a single packet.",
      "ja": "3）最も初期の何を決定する（すなわち、再送信のためにマークされた最も低いTSN）DATA塊は、パケットが送信された送付先輸送アドレスの経路MTUの制約を受ける単一のパケットに収まります。 K.は、単一のパケットでそれらのK DATAチャンクを再送この値を呼び出します。"
    },
    {
      "indent": 3,
      "text": "4) Restart T3-rtx timer only if the last SACK acknowledged the lowest outstanding TSN number sent to that address, or the endpoint is retransmitting the first outstanding DATA chunk sent to that address.",
      "ja": "4）再起動T3-RTXタイマー最後のSACKが最低優れたTSN番号は、そのアドレスに送信された、またはエンドポイントがそのアドレスに送信された最初の未処理データのチャンクを再送された場合にのみ認めました。"
    },
    {
      "indent": 3,
      "text": "Note: Before the above adjustments, if the received SACK also acknowledges new DATA chunks and advances the Cumulative TSN Ack Point, the cwnd adjustment rules defined in Sections 7.2.1 and 7.2.2 must be applied first.",
      "ja": "注：受信したSACKはまた、新しいデータチャンクを承認し、累積TSNのAckポイントを進める場合、上記の調整前に、セクション7.2.1及び7.2.2で定義されたCWND調整ルールが最初に適用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "A straightforward implementation of the above keeps a counter for each TSN hole reported by a SACK. The counter increments for each consecutive SACK reporting the TSN hole. After reaching 4 and starting the fast retransmit procedure, the counter resets to 0. Because cwnd in SCTP indirectly bounds the number of outstanding TSN's, the effect of TCP fast-recovery is achieved automatically with no adjustment to the congestion control window size.",
      "ja": "上記の簡単な実装はSACKによって報告された各TSN穴用のカウンタを保持します。 TSN穴を報告各連続SACKのカウンタをインクリメント。 SCTPにおけるCWNDが間接的発行済TSNの数の境界ので4に達すると0に高速再送手順、カウンタリセットを開始した後、TCP高速回復の効果は、輻輳制御ウィンドウサイズを調整なしで自動的に達成されます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Whenever an endpoint receives a SACK that indicates that some TSNs are missing, it SHOULD wait for 3 further miss indications (via subsequent SACKs) on the same TSN(s) before taking action with regard to Fast Retransmit.",
      "ja": "エンドポイントはいくつかのTSNが欠落していることを示しているSACKを受信するたびに、それが高速再送信に関して行動を起こす前に、同じTSN（S）上の（その後の袋を経由して）3点の、さらにミスの指摘を待つべき。"
    },
    {
      "indent": 3,
      "text": "Miss indications SHOULD follow the HTNA (Highest TSN Newly Acknowledged) algorithm. For each incoming SACK, miss indications are incremented only for missing TSNs prior to the highest TSN newly acknowledged in the SACK. A newly acknowledged DATA chunk is one not previously acknowledged in a SACK. If an endpoint is in Fast Recovery and a SACK arrives that advances the Cumulative TSN Ack Point, the miss indications are incremented for all TSNs reported missing in the SACK.",
      "ja": "ミス表示はHTNA（最高TSN新ADIは）アルゴリズムに従ってください。各着信SACKについて、ミス表示が前に新たSACKに認め最高TSNにだけ行方不明のTSNごとに増加しています。新たに認めたのDATAチャンクが以前にSACKで認められていないものです。エンドポイントは高速回復であるとSACKが累積TSN Ackをポイントを進め、その到着した場合、ミス表示がSACKに不足しているすべてのTSNについて報告インクリメントされています。"
    },
    {
      "indent": 3,
      "text": "When the fourth consecutive miss indication is received for a TSN(s), the data sender shall do the following:",
      "ja": "4年連続ミス表示がTSN（S）のために受信されると、データの送信者は、次の手順を実行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "1) Mark the DATA chunk(s) with four miss indications for retransmission.",
      "ja": "1）再送信のための4つのミスの適応症を持つデータチャンク（複数可）をマークします。"
    },
    {
      "indent": 3,
      "text": "2) If not in Fast Recovery, adjust the ssthresh and cwnd of the destination address(es) to which the missing DATA chunks were last sent, according to the formula described in Section 7.2.3.",
      "ja": "ない高速リカバリで場合2）、7.2.3項で説明した式に従って、欠落データチャンクが最後に送信された先のアドレス（ES）のSSTHRESHおよびCWNDを調整します。"
    },
    {
      "indent": 3,
      "text": "3) Determine how many of the earliest (i.e., lowest TSN) DATA chunks marked for retransmission will fit into a single packet, subject to constraint of the path MTU of the destination transport address to which the packet is being sent. Call this value K. Retransmit those K DATA chunks in a single packet. When a Fast Retransmit is being performed, the sender SHOULD ignore the value of cwnd and SHOULD NOT delay retransmission for this single packet.",
      "ja": "3）最も初期の何を決定する（すなわち、再送信のためにマークされた最も低いTSN）DATA塊は、パケットが送信された送付先輸送アドレスの経路MTUの制約を受ける単一のパケットに収まります。 K.は、単一のパケットでそれらのK DATAチャンクを再送この値を呼び出します。高速再送信が実行されている場合は、送信者はCWNDの値を無視すべきであり、この単一のパケットの再送信を遅らせるべきではありません。"
    },
    {
      "indent": 3,
      "text": "4) Restart T3-rtx timer only if the last SACK acknowledged the lowest outstanding TSN number sent to that address, or the endpoint is retransmitting the first outstanding DATA chunk sent to that address.",
      "ja": "4）再起動T3-RTXタイマー最後のSACKが最低優れたTSN番号は、そのアドレスに送信された、またはエンドポイントがそのアドレスに送信された最初の未処理データのチャンクを再送された場合にのみ認めました。"
    },
    {
      "indent": 3,
      "text": "5) Mark the DATA chunk(s) as being fast retransmitted and thus ineligible for a subsequent fast retransmit. Those TSNs marked for retransmission due to the Fast Retransmit algorithm that did not fit in the sent datagram carrying K other TSNs are also marked as ineligible for a subsequent fast retransmit. However, as they are marked for retransmission they will be retransmitted later on as soon as cwnd allows.",
      "ja": "5）高速再送およびその後の高速再送信のためにこのように不適格であるように、データチャンク（複数可）をマーク。 K他のTSNを運ぶ送信されたデータグラムに収まらなかった高速再送アルゴリズムに再送信のために印がついているもののTSNはまた、その後の高速再送用として不適格とマークされています。彼らは再送信のためにマークされているようしかし、彼らはすぐにcwndが許す限り、後に再送されます。"
    },
    {
      "indent": 3,
      "text": "6) If not in Fast Recovery, enter Fast Recovery and mark the highest outstanding TSN as the Fast Recovery exit point. When a SACK acknowledges all TSNs up to and including this exit point, Fast Recovery is exited. While in Fast Recovery, the ssthresh and cwnd SHOULD NOT change for any destinations due to a subsequent Fast Recovery event (i.e., one SHOULD NOT reduce the cwnd further due to a subsequent fast retransmit).",
      "ja": "6）高速回復で、高速リカバリを入力して、高速リカバリ出口点として最高の優れたTSNをマークしていない場合。 SACKは、この出口点までを含むすべてのTSNを承認すると、高速リカバリが終了します。高速リカバリでいる間、SSTHRESHおよびCWNDは（すなわち、1は、後続の高速再送へのさらなる原因にcwndを減らすべきではありません）、その後の高速リカバリイベントのために任意の宛先に変更すべきではありません。"
    },
    {
      "indent": 3,
      "text": "Note: Before the above adjustments, if the received SACK also acknowledges new DATA chunks and advances the Cumulative TSN Ack Point, the cwnd adjustment rules defined in Sections 7.2.1 and 7.2.2 must be applied first.",
      "ja": "注：受信したSACKはまた、新しいデータチャンクを承認し、累積TSNのAckポイントを進める場合、上記の調整前に、セクション7.2.1及び7.2.2で定義されたCWND調整ルールが最初に適用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.8.3. Solution Description",
      "section_title": true,
      "ja": "2.8.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The effect of the above wording changes are as follows: o It requires with a MUST the sending of GAP Ack blocks instead of the current RFC 2960 [5] SHOULD.",
      "ja": "これは、必要な現行のRFC 2960 [5] SHOULDの代わりにギャップAckブロックの送信と必要○：上記の言い回しの変更の効果は以下の通りです。"
    },
    {
      "indent": 3,
      "text": "o It allows a TSN being Fast Retransmitted (FR) to be sent only once via FR.",
      "ja": "OそれはTSNが速い（FR）再送されているFRを経由して一度だけ送信することができます。"
    },
    {
      "indent": 3,
      "text": "o It ends the delay in waiting for the flight size to drop when a TSN is identified as being ready to FR.",
      "ja": "Oこれは、TSNはFRに準備ができていると識別されたときにドロップする飛行サイズを待っているの遅延を終了します。"
    },
    {
      "indent": 3,
      "text": "o It changes the way chunks are marked during fast retransmit, so that only new reports are counted.",
      "ja": "唯一の新しいレポートがカウントされるように、Oそれは、チャンクが高速再送時にマークされている方法を変更します。"
    },
    {
      "indent": 3,
      "text": "o It introduces a Fast Recovery period to avoid multiple congestion window reductions when there are multiple losses in a single RTT (as shown by Caro et al. [3]).",
      "ja": "Oそれは単一RTT内に複数の損失がある場合、複数の輻輳ウィンドウの減少を回避するために、高速リカバリ期間を導入（カロらにより示されるように。[3]）。"
    },
    {
      "indent": 3,
      "text": "These changes will effectively allow SCTP to follow a similar model as TCP+SACK in the handling of Fast Retransmit.",
      "ja": "これらの変更は、効果的にSCTPが高速再送信の処理にTCP + SACKと同様のモデルに従うことができるようになります。"
    },
    {
      "indent": 0,
      "text": "2.9. Missing Statement about partial_bytes_acked Update",
      "section_title": true,
      "ja": "2.9。 partial_bytes_ackedアップデートに関する声明がありません"
    },
    {
      "indent": 0,
      "text": "2.9.1. Description of the Problem",
      "section_title": true,
      "ja": "2.9.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "SCTP uses four control variables to regulate its transmission rate: rwnd, cwnd, ssthresh, and partial_bytes_acked. Upon detection of packet losses from SACK, or when the T3-rtx timer expires on an address, cwnd and ssthresh should be updated as stated in Section 7.2.3. However, that section should also clarify that partial_bytes_acked must be updated as well; it has to be reset to 0.",
      "ja": "SCTPは、その伝送速度を調整するために4つの制御変数を使用します。RWND、cwndの、SSTHRESHを、そしてpartial_bytes_acked。 7.2.3項で述べたようにSACKからパケットロスを検出すると、またはT3-RTXタイマーは、アドレス、CWNDとSSTHRESHに期限切れになったときに更新する必要があります。しかし、そのセクションもpartial_bytes_ackedが同様に更新されなければならないことを明確にすべきです。それが0にリセットする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.9.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.9.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7.2.3 Congestion Control",
      "section_title": true,
      "ja": "7.2.3輻輳制御"
    },
    {
      "indent": 3,
      "text": "Upon detection of packet losses from SACK (see Section 7.2.4), An endpoint should do the following:",
      "ja": "SACKからパケットロスを検出すると（第7.2.4項を参照）、エンドポイントは、以下の操作を行う必要があります。"
    },
    {
      "indent": 6,
      "text": "ssthresh = max(cwnd/2, 2*MTU) cwnd = ssthresh",
      "ja": "SSTHRESH = MAX（CWND / 2、2 * MTU）CWND = SSTHRESH"
    },
    {
      "indent": 3,
      "text": "Basically, a packet loss causes cwnd to be cut in half.",
      "ja": "基本的には、パケット損失がcwndを半分にカットされます。"
    },
    {
      "indent": 3,
      "text": "When the T3-rtx timer expires on an address, SCTP should perform slow start by:",
      "ja": "T3-RTXタイマーがアドレスに期限が切れると、SCTPはでスロースタートを実行する必要があります。"
    },
    {
      "indent": 6,
      "text": "ssthresh = max(cwnd/2, 2*MTU) cwnd = 1*MTU",
      "ja": "SSTHRESH = MAX（CWND / 2、2 * MTU）CWND = 1 * MTU"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7.2.3. Congestion Control",
      "section_title": true,
      "ja": "7.2.3。輻輳制御"
    },
    {
      "indent": 3,
      "text": "Upon detection of packet losses from SACK (see Section 7.2.4), an endpoint should do the following if not in Fast Recovery:",
      "ja": "SACKからパケットロスを検出すると（第7.2.4項を参照）、エンドポイントは高速回復でない場合は、次の操作を行う必要があります。"
    },
    {
      "indent": 6,
      "text": "ssthresh = max(cwnd/2, 2*MTU) cwnd = ssthresh partial_bytes_acked = 0",
      "ja": "SSTHRESH = MAX（CWND / 2、2 * MTU）CWND = SSTHRESH partial_bytes_acked = 0"
    },
    {
      "indent": 3,
      "text": "Basically, a packet loss causes cwnd to be cut in half.",
      "ja": "基本的には、パケット損失がcwndを半分にカットされます。"
    },
    {
      "indent": 3,
      "text": "When the T3-rtx timer expires on an address, SCTP should perform slow start by",
      "ja": "T3-RTXタイマーがアドレスに期限が切れると、SCTPはでスロースタートを実行する必要があります"
    },
    {
      "indent": 6,
      "text": "ssthresh = max(cwnd/2, 2*MTU) cwnd = 1*MTU partial_bytes_acked = 0",
      "ja": "SSTHRESH = MAX（CWND / 2、2 * MTU）CWND = 1 * MTU partial_bytes_acked = 0"
    },
    {
      "indent": 0,
      "text": "2.9.3. Solution Description",
      "section_title": true,
      "ja": "2.9.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The missing text added solves the doubts about what to do with partial_bytes_acked in the situations stated in Section 7.2.3, making clear that, along with ssthresh and cwnd, partial_bytes_acked should also be updated by being reset to 0.",
      "ja": "追加不足しているテキストは、7.2.3項で述べたような状況でpartial_bytes_acked SSTHRESHおよびCWNDと一緒に、また0にリセットされることによって更新されるべきpartial_bytes_acked、ことが明らかになってどうするかについての疑問を解決します。"
    },
    {
      "indent": 0,
      "text": "2.10. Issues with Heartbeating and Failure Detection",
      "section_title": true,
      "ja": "2.10。ハートビートと障害検出に関する問題"
    },
    {
      "indent": 0,
      "text": "2.10.1. Description of the Problem",
      "section_title": true,
      "ja": "2.10.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Five basic problems have been discovered with the current heartbeat procedures:",
      "ja": "5つの基本的な問題は、現在の心拍の手順で発見されています："
    },
    {
      "indent": 3,
      "text": "o The current specification does not specify that you should count a failed heartbeat as an error against the overall association.",
      "ja": "O現在の仕様では、全体的な関連性に対するエラーとして失敗したハートビートを数えるべきであると指定されていません。"
    },
    {
      "indent": 3,
      "text": "o The current specification is not specific as to when you start sending heartbeats and when you should stop.",
      "ja": "O現在の仕様では、ハートビートの送信を開始するとき、あなたが停止すべきときになどの特定ではありません。"
    },
    {
      "indent": 3,
      "text": "o The current specification is not specific as to when you should respond to heartbeats.",
      "ja": "O現在の仕様では、ハートビートに応答すべきときになどの特定ではありません。"
    },
    {
      "indent": 3,
      "text": "o When responding to a Heartbeat, it is unclear what to do if more than a single TLV is present.",
      "ja": "ハートビートに応答するとき以上の単一TLVが存在する場合、O、何をするかは不明です。"
    },
    {
      "indent": 3,
      "text": "o The jitter applied to a heartbeat was meant to be a small variance of the RTO and is currently a wide variance, due to the default delay time and incorrect wording within the RFC.",
      "ja": "ハートビートに適用されるジッタoをRTOの小さな変動であることを意味し、現在はRFC内のデフォルトの遅延時間や不正確な表現のために広い分散、ですました。"
    },
    {
      "indent": 0,
      "text": "2.10.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.10.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8.1 Endpoint Failure Detection",
      "section_title": true,
      "ja": "8.1エンドポイントの障害検出"
    },
    {
      "indent": 3,
      "text": "An endpoint shall keep a counter on the total number of consecutive retransmissions to its peer (including retransmissions to all the destination transport addresses of the peer if it is multi-homed). If the value of this counter exceeds the limit indicated in the protocol parameter 'Association.Max.Retrans', the endpoint shall consider the peer endpoint unreachable and shall stop transmitting any more data to it (and thus the association enters the CLOSED state). In addition, the endpoint shall report the failure to the upper layer, and optionally report back all outstanding user data remaining in its outbound queue. The association is automatically closed when the peer endpoint becomes unreachable.",
      "ja": "エンドポイントは、（それがマルチホームされている場合、ピアのすべての宛先トランスポートアドレスへの再送信を含む）ピアへの連続再送信の総数にカウンタを維持しなければなりません。このカウンタの値は、プロトコルパラメータ「Association.Max.Retrans」で示さ限界を超えた場合、エンドポイントは、ピアエンドポイントが到達不能に考慮しなければならないし、それが（したがって、関連が閉状態になる）に、任意のより多くのデータの送信を停止しなければなりません。加えて、エンドポイントは、上位層に失敗を報告し、必要に応じてその送信キューに残っているすべての未処理のユーザデータをバック報告しなければなりません。ピアエンドポイントが到達不能になったときに関連付けは自動的に閉じられます。"
    },
    {
      "indent": 3,
      "text": "The counter shall be reset each time a DATA chunk sent to that peer endpoint is acknowledged (by the reception of a SACK), or a HEARTBEAT-ACK is received from the peer endpoint.",
      "ja": "カウンタが（SACKの受信によって）そのピアエンドポイントに送信されたデータチャンクが確認されるたびにリセットされなければならない、またはHEARTBEAT-ACKは、ピアエンドポイントから受信されます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8.1. Endpoint Failure Detection",
      "section_title": true,
      "ja": "8.1。エンドポイントの障害検出"
    },
    {
      "indent": 3,
      "text": "An endpoint shall keep a counter on the total number of consecutive retransmissions to its peer (this includes retransmissions to all the destination transport addresses of the peer if it is multi-homed), including unacknowledged HEARTBEAT Chunks. If the value of this counter exceeds the limit indicated in the protocol parameter 'Association.Max.Retrans', the endpoint shall consider the peer endpoint unreachable and shall stop transmitting any more data to it (and thus the association enters the CLOSED state). In addition, the endpoint MAY report the failure to the upper layer and optionally report back all outstanding user data remaining in its outbound queue. The association is automatically closed when the peer endpoint becomes unreachable.",
      "ja": "エンドポイントは、未確認HEARTBEATチャンクを含む、（マルチホームである場合、これは、ピアのすべての宛先トランスポートアドレスへの再送信を含む）ピアへの連続再送信の総数カウンタを維持しなければなりません。このカウンタの値は、プロトコルパラメータ「Association.Max.Retrans」で示さ限界を超えた場合、エンドポイントは、ピアエンドポイントが到達不能に考慮しなければならないし、それが（したがって、関連が閉状態になる）に、任意のより多くのデータの送信を停止しなければなりません。また、エンドポイントは、上位層に障害を報告し、必要に応じてその送信キューに残っているすべての未処理のユーザデータをバック報告することがあります。ピアエンドポイントが到達不能になったときに関連付けは自動的に閉じられます。"
    },
    {
      "indent": 3,
      "text": "The counter shall be reset each time a DATA chunk sent to that peer endpoint is acknowledged (by the reception of a SACK), or a HEARTBEAT-ACK is received from the peer endpoint.",
      "ja": "カウンタが（SACKの受信によって）そのピアエンドポイントに送信されたデータチャンクが確認されるたびにリセットされなければならない、またはHEARTBEAT-ACKは、ピアエンドポイントから受信されます。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8.3 Path Heartbeat",
      "section_title": true,
      "ja": "8.3パスのハートビート"
    },
    {
      "indent": 3,
      "text": "By default, an SCTP endpoint shall monitor the reachability of the idle destination transport address(es) of its peer by sending a HEARTBEAT chunk periodically to the destination transport address(es).",
      "ja": "デフォルトでは、SCTP終点は、宛先トランスポートアドレス（ES）に定期的にHEARTBEATチャンクを送信することによって、そのピアのアイドル先トランスポートアドレス（ES）の到達性を監視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8.3 Path Heartbeat",
      "section_title": true,
      "ja": "8.3パスのハートビート"
    },
    {
      "indent": 3,
      "text": "By default, an SCTP endpoint SHOULD monitor the reachability of the idle destination transport address(es) of its peer by sending a HEARTBEAT chunk periodically to the destination transport address(es). HEARTBEAT sending MAY begin upon reaching the ESTABLISHED state and is discontinued after sending either SHUTDOWN or SHUTDOWN-ACK. A receiver of a HEARTBEAT MUST respond to a HEARTBEAT with a HEARTBEAT-ACK after entering the COOKIE-ECHOED state (INIT sender) or the ESTABLISHED state (INIT receiver), up until reaching the SHUTDOWN-SENT state (SHUTDOWN sender) or the SHUTDOWN-ACK-SENT state (SHUTDOWN receiver).",
      "ja": "デフォルトでは、SCTP終点は、宛先トランスポートアドレス（ES）に定期的にHEARTBEATチャンクを送信することによって、そのピアのアイドル先トランスポートアドレス（ES）の到達性を監視する必要があります。送信HEARTBEATがESTABLISHED状態に達したときに開始することとSHUTDOWNやSHUTDOWN-ACKのいずれかを送った後に中止されます。 HEARTBEATの受信機がSHUTDOWN-SENT状態（SHUTDOWN送信者）またはSHUTDOWNに達するまで、（INITの送信者）または確立された状態（INIT受信機）COOKIE-ECHOED状態に入った後HEARTBEAT-ACKとHEARTBEATに応答しなければなりません-ACK-SENT状態（SHUTDOWN受信機）。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The receiver of the HEARTBEAT should immediately respond with a HEARTBEAT ACK that contains the Heartbeat Information field copied from the received HEARTBEAT chunk.",
      "ja": "HEARTBEATの受信機はすぐに受け取ったHEARTBEATチャンクからコピーされたハートビート情報フィールドが含まれているハートビートACKで応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The receiver of the HEARTBEAT should immediately respond with a HEARTBEAT ACK that contains the Heartbeat Information TLV, together with any other received TLVs, copied unchanged from the received HEARTBEAT chunk.",
      "ja": "HEARTBEATの受信機はすぐに一緒に受け取ったHEARTBEATチャンクからそのままコピーされ、他の受信のTLVと、ハートビートインフォメーションTLVが含まれているハートビートACKで応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "On an idle destination address that is allowed to heartbeat, a HEARTBEAT chunk is RECOMMENDED to be sent once per RTO of that destination address plus the protocol parameter 'HB.interval' , with jittering of +/- 50%, and exponential back-off of the RTO if the previous HEARTBEAT is unanswered.",
      "ja": "ハートビートさせ、アイドル宛先アドレスに、ハートビート・チャンクは+/- 50％のジッタ、および指数バックオフで、その宛先アドレスとプロトコルパラメータ「HB.interval」のRTOごとに一度送信することが推奨されています以前HEARTBEATが応答がない場合はRTOの。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "On an idle destination address that is allowed to heartbeat, it is recommended that a HEARTBEAT chunk is sent once per RTO of that destination address plus the protocol parameter 'HB.interval', with jittering of +/- 50% of the RTO value, and exponential back-off of the RTO if the previous HEARTBEAT is unanswered.",
      "ja": "ハートビートさせ、アイドル宛先アドレスに、ハートビート・チャンクがRTO値の+/- 50％のジッタと、一度その宛先アドレスとプロトコルパラメータ「HB.interval」のRTOごとに送信することが推奨されますそして、RTOの指数バックオフ前のHEARTBEATが未解決である場合。"
    },
    {
      "indent": 0,
      "text": "2.10.3. Solution Description",
      "section_title": true,
      "ja": "2.10.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above text provides guidance as to how to respond to the five issues mentioned in Section 2.10.1. In particular, the wording changes provide guidance as to when to start and stop heartbeating, how to respond to a heartbeat with extra parameters, and it clarifies the error counting procedures for the association.",
      "ja": "上記のテキストは、2.10.1項で述べた5つの課題への対応方法に関して、ガイダンスを提供します。具体的には、文言の変更は、余分なパラメータでハートビートに応答する方法、開始およびハートビートを停止する必要がある場合のガイダンスを提供し、それは関連付けのエラーカウント手順を明確にしています。"
    },
    {
      "indent": 0,
      "text": "2.11. Security interactions with firewalls",
      "section_title": true,
      "ja": "2.11。ファイアウォールとセキュリティの相互作用"
    },
    {
      "indent": 0,
      "text": "2.11.1. Description of the Problem",
      "section_title": true,
      "ja": "2.11.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "When dealing with firewalls, it is advantageous for the firewall to be able to properly determine the initial startup sequence of a reliable transport protocol. With this in mind, the following text is to be added to SCTP's security section.",
      "ja": "ファイアウォールを扱う場合、ファイアウォールが適切に信頼性の高いトランスポートプロトコルの最初の起動シーケンスを決定できるようにするために、それが有利です。これを念頭に置いて、次のテキストがSCTPのセキュリティセクションに追加されます。"
    },
    {
      "indent": 0,
      "text": "2.11.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.11.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (no old text, new section added)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "11.4 SCTP Interactions with Firewalls",
      "section_title": true,
      "ja": "ファイアウォールと11.4 SCTPの相互作用"
    },
    {
      "indent": 3,
      "text": "It is helpful for some firewalls if they can inspect just the first fragment of a fragmented SCTP packet and unambiguously determine whether it corresponds to an INIT chunk (for further information, please refer to RFC1858). Accordingly, we stress the requirements, stated in 3.1, that (1) an INIT chunk MUST NOT be bundled with any other chunk in a packet, and (2) a packet containing an INIT chunk MUST have a zero Verification Tag. Furthermore, we require that the receiver of an INIT chunk MUST enforce these rules by silently discarding an arriving packet with an INIT chunk that is bundled with other chunks.",
      "ja": "それらは断片化されたSCTPパケットのちょうど最初のフラグメントを検査し、明確にそれが（詳細については、RFC1858を参照）INITチャンクに対応するか否かを判断することができるかどうかは、いくつかのファイアウォールのために有用です。したがって、我々は要件を強調し、（1）INITチャンクはパケット内の他のチャンクとバンドルしてはならない、と（2）INITチャンクを含むパケットがゼロの検証タグを持たなければならないことを、3.1で述べました。さらに、我々はINITチャンクの受信機は静かに他のチャンクにバンドルされているINITチャンクで到着したパケットを破棄することにより、これらのルールを適用しなければならないことが必要です。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 18)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "18. Bibliography",
      "section_title": true,
      "ja": "18.参考文献"
    },
    {
      "indent": 3,
      "text": "[ALLMAN99] Allman, M. and Paxson, V., \"On Estimating End-to-End Network Path Properties\", Proc. SIGCOMM'99, 1999.",
      "ja": "「エンドツーエンドのネットワークパスのプロパティの推定について」[ALLMAN99]オールマン、M.とパクソン、V.、PROC。 SIGCOMM'99、1999。"
    },
    {
      "indent": 3,
      "text": "[FALL96] Fall, K. and Floyd, S., Simulation-based Comparisons of Tahoe, Reno, and SACK TCP, Computer Communications Review, V. 26 N. 3, July 1996, pp. 5-21.",
      "ja": "[FALL96]秋、K.とフロイド、S.、タホ、リノ、およびSACK TCP、コンピュータコミュニケーションレビュー、V. 26 N. 3、1996年7月、頁5-21のシミュレーションベースの比較。"
    },
    {
      "indent": 3,
      "text": "[RFC1750] Eastlake, D. (ed.), \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[RFC1750]イーストレーク、D.（編）、 \"セキュリティのためのランダム性に関する推奨事項\"、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1950] Deutsch P. and J. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, May 1996.",
      "ja": "[RFC1950]ドイツP.とJ. Gailly氏、 \"ZLIB圧縮データフォーマット仕様バージョン3.3\"、RFC 1950、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, March 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M。およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2196] Fraser, B., \"Site Security Handbook\", FYI 8, RFC 2196, September 1997.",
      "ja": "[RFC2196]フレイザー、B.、 \"サイトセキュリティハンドブック\"、FYI 8、RFC 2196、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2522] Karn, P. and W. Simpson, \"Photuris: Session-Key Management Protocol\", RFC 2522, March 1999.",
      "ja": "[RFC2522]カーン、P.とW.シンプソン、 \"Photuris：セッション鍵管理プロトコル\"、RFC 2522、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and Anderson, T., \"TCP Congestion Control with a Misbehaving Receiver\", ACM Computer Communication Review, 29(5), October 1999.",
      "ja": "[SAVAGE99]サベージ、S.、カードウェル、N.、Wetherall、D.、およびアンダーソン、T.、 \"ふらちなレシーバーとのTCP輻輳制御\"、ACMコンピュータコミュニケーションレビュー、29（5）、1999年10月。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 18)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "18. Bibliography",
      "section_title": true,
      "ja": "18.参考文献"
    },
    {
      "indent": 3,
      "text": "[ALLMAN99] Allman, M. and Paxson, V., \"On Estimating End-to-End Network Path Properties\", Proc. SIGCOMM'99, 1999.",
      "ja": "「エンドツーエンドのネットワークパスのプロパティの推定について」[ALLMAN99]オールマン、M.とパクソン、V.、PROC。 SIGCOMM'99、1999。"
    },
    {
      "indent": 3,
      "text": "[FALL96] Fall, K. and Floyd, S., Simulation-based Comparisons of Tahoe, Reno, and SACK TCP, Computer Communications Review, V. 26 N. 3, July 1996, pp. 5-21.",
      "ja": "[FALL96]秋、K.とフロイド、S.、タホ、リノ、およびSACK TCP、コンピュータコミュニケーションレビュー、V. 26 N. 3、1996年7月、頁5-21のシミュレーションベースの比較。"
    },
    {
      "indent": 3,
      "text": "[RFC1750] Eastlake, D. (ed.), \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[RFC1750]イーストレーク、D.（編）、 \"セキュリティのためのランダム性に関する推奨事項\"、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1858] Ziemba, G., Reed, D. and Traina P., \"Security Considerations for IP Fragment Filtering\", RFC 1858, October 1995.",
      "ja": "[RFC1858] Ziemba、G.、リード、D.とTrainaのP.、 \"IPフラグメントフィルタリングのためのセキュリティの考慮事項\"、RFC 1858、1995年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1950] Deutsch P. and J. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, May 1996.",
      "ja": "[RFC1950]ドイツP.とJ. Gailly氏、 \"ZLIB圧縮データフォーマット仕様バージョン3.3\"、RFC 1950、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, March 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M。およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2196] Fraser, B., \"Site Security Handbook\", FYI 8, RFC 2196, September 1997.",
      "ja": "[RFC2196]フレイザー、B.、 \"サイトセキュリティハンドブック\"、FYI 8、RFC 2196、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2522] Karn, P. and W. Simpson, \"Photuris: Session-Key Management Protocol\", RFC 2522, March 1999.",
      "ja": "[RFC2522]カーン、P.とW.シンプソン、 \"Photuris：セッション鍵管理プロトコル\"、RFC 2522、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and Anderson, T., \"TCP Congestion Control with a Misbehaving Receiver\", ACM Computer Communication Review, 29(5), October 1999.",
      "ja": "[SAVAGE99]サベージ、S.、カードウェル、N.、Wetherall、D.、およびアンダーソン、T.、 \"ふらちなレシーバーとのTCP輻輳制御\"、ACMコンピュータコミュニケーションレビュー、29（5）、1999年10月。"
    },
    {
      "indent": 0,
      "text": "2.11.3. Solution Description",
      "section_title": true,
      "ja": "2.11.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above text, which adds a new subsection to the Security Considerations section of RFC 2960 [5] makes clear that, to make easier the interaction with firewalls, an INIT chunk must not be bundled in any case with any other chunk that will silently discard the packets that do not follow this rule (this rule is enforced by the packet receiver).",
      "ja": "RFC 2960のセキュリティの考慮セクションに新しいサブセクションを追加して上記のテキストは、[5]明確なファイアウォールとの容易な相互作用をするために、ということになり、INITチャンクは静かに破棄されます、他のチャンクとどのような場合には同梱されてはなりませんこのルールに従わないパケット（この規則は、パケット受信部によって強制されます）。"
    },
    {
      "indent": 0,
      "text": "2.12. Shutdown Ambiguity",
      "section_title": true,
      "ja": "2.12。シャットダウンあいまい"
    },
    {
      "indent": 0,
      "text": "2.12.1. Description of the Problem",
      "section_title": true,
      "ja": "2.12.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Currently, there is an ambiguity between the statements in Sections 6.2 and 9.2. Section 6.2 allows the sending of a SHUTDOWN chunk in place of a SACK when the sender is in the process of shutting down, while section 9.2 requires that both a SHUTDOWN chunk and a SACK chunk be sent.",
      "ja": "現在、セクション6.2および9.2での文の間に曖昧さがあります。セクション9.2は、SHUTDOWNチャンクとSACKチャンクの両方が送信されることを要求しながら、6.2節では、送信者がシャットダウンのプロセスであるSACKの代わりにSHUTDOWNチャンクの送信を可能にします。"
    },
    {
      "indent": 3,
      "text": "Along with this ambiguity there is a problem wherein an errant SHUTDOWN receiver may fail to stop accepting user data.",
      "ja": "この曖昧とともに誤っSHUTDOWN受信機はユーザデータの受け入れを停止するのに失敗することがあり、前記問題があります。"
    },
    {
      "indent": 0,
      "text": "2.12.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.12.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 9.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If there are still outstanding DATA chunks left, the SHUTDOWN receiver shall continue to follow normal data transmission procedures defined in Section 6 until all outstanding DATA chunks are acknowledged; however, the SHUTDOWN receiver MUST NOT accept new data from its SCTP user.",
      "ja": "左の未処理データの塊が残っている場合は、SHUTDOWN受信機は、すべての未処理データのチャンクが確認されるまで、6節で定義された通常のデータ送信手順に従うことを継続します。しかし、SHUTDOWN受信機はそのSCTPユーザからの新しいデータを受け入れてはいけません。"
    },
    {
      "indent": 3,
      "text": "While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately respond to each received packet containing one or more DATA chunk(s) with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer. If it has no more outstanding DATA chunks, the SHUTDOWN receiver shall send a SHUTDOWN ACK and start a T2-shutdown timer of its own, entering the SHUTDOWN-ACK-SENT state. If the timer expires, the endpoint must re-send the SHUTDOWN ACK.",
      "ja": "SHUTDOWN-SENT状態にある間、SHUTDOWN送信者は、直ちにSACK、SHUTDOWNチャンクで一つ以上のデータチャンク（複数可）を含む各受信パケットに応答、およびT2-シャットダウンタイマーを再起動する必要があります。それは、より優れたDATAチャンクを持っていない場合は、SHUTDOWNの受信機は、SHUTDOWN ACKを送信しなければならないし、SHUTDOWN-ACK-SENT状態に入る、それ自身のT2-シャットダウンタイマーを起動します。タイマーが期限切れになった場合、エンドポイントは、SHUTDOWN ACKを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 9.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If there are still outstanding DATA chunks left, the SHUTDOWN receiver MUST continue to follow normal data transmission procedures defined in Section 6, until all outstanding DATA chunks are acknowledged; however, the SHUTDOWN receiver MUST NOT accept new data from its SCTP user.",
      "ja": "左の未処理データチャンクがまだある場合、SHUTDOWN受信機は、すべての未処理データチャンクが確認されるまで、セクション6で定義された通常のデータ送信手順に従うし続けなければなりません。しかし、SHUTDOWN受信機はそのSCTPユーザからの新しいデータを受け入れてはいけません。"
    },
    {
      "indent": 3,
      "text": "While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately respond to each received packet containing one or more DATA chunks with a SHUTDOWN chunk and restart the T2-shutdown timer. If a SHUTDOWN chunk by itself cannot acknowledge all of the received DATA chunks (i.e., there are TSNs that can be acknowledged that are larger than the cumulative TSN, and thus gaps exist in the TSN sequence), or if duplicate TSNs have been received, then a SACK chunk MUST also be sent.",
      "ja": "SHUTDOWN-SENT状態にある間、SHUTDOWN送信者はすぐにSHUTDOWNチャンク1つのまたは複数のデータチャンクを含む各受信パケットに対応し、T2-シャットダウンタイマーを再起動する必要があります。重複のTSNが受信された場合、それ自体でSHUTDOWNチャンクは、受信したデータチャンクの全て（すなわち、累積TSNよりも大きいことを認識し、したがってギャップがTSN配列内に存在することができるのTSNがある）、または確認できない場合、その後、SACKチャンクも送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sender of the SHUTDOWN MAY also start an overall guard timer 'T5-shutdown-guard' to bound the overall time for shutdown sequence. At the expiration of this timer, the sender SHOULD abort the association by sending an ABORT chunk. If the 'T5-shutdown-guard' timer is used, it SHOULD be set to the recommended value of 5 times 'RTO.Max'.",
      "ja": "SHUTDOWNの送信者は、全体的なガードタイマ「T5シャットダウン・ガード」はシャットダウンシーケンスのための全体的な時間を拘束するために起動することがあります。このタイマーの満了時に、送信側はABORTチャンクを送信することにより、関連付けを中止すべきです。 「T5シャットダウン・ガード」タイマーが使用されている場合、それが5回「RTO.Max」の推奨値に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the receiver of the SHUTDOWN has no more outstanding DATA chunks, the SHUTDOWN receiver MUST send a SHUTDOWN ACK and start a T2-shutdown timer of its own, entering the SHUTDOWN-ACK-SENT state. If the timer expires, the endpoint must re-send the SHUTDOWN ACK.",
      "ja": "SHUTDOWNの受信機はこれ以上の未処理データチャンクを持っていない場合は、SHUTDOWN受信機はSHUTDOWN-ACK-SENT状態に入る、SHUTDOWN ACKを送信し、自身のT2-シャットダウンタイマーを起動する必要があります。タイマーが期限切れになった場合、エンドポイントは、SHUTDOWN ACKを再送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.12.3. Solution Description",
      "section_title": true,
      "ja": "2.12.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above text clarifies the use of a SACK in conjunction with a SHUTDOWN chunk. It also adds a guard timer to the SCTP shutdown sequence to protect against errant receivers of SHUTDOWN chunks.",
      "ja": "上記のテキストは、SHUTDOWNチャンクと一緒にSACKの使用を明確にしています。また、SHUTDOWNチャンクの誤った受信機から保護するためにSCTPのシャットダウンシーケンスにガードタイマーを追加します。"
    },
    {
      "indent": 0,
      "text": "2.13. Inconsistency in ABORT Processing",
      "section_title": true,
      "ja": "2.13。 ABORT処理で矛盾"
    },
    {
      "indent": 0,
      "text": "2.13.1. Description of the Problem",
      "section_title": true,
      "ja": "2.13.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "It was noted that the wording in Section 8.5.1 did not give proper directions in the use of the 'T bit' with the Verification Tags.",
      "ja": "これは、セクション8.5.1での文言は検証タグ「Tビット」の使用に適切な指示を与えていないことが認められました。"
    },
    {
      "indent": 0,
      "text": "2.13.2. Text changes to the document",
      "section_title": true,
      "ja": "2.13.2。文書へのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.5.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "B) Rules for packet carrying ABORT:",
      "ja": "B）ABORTを運ぶパケットのためのルール："
    },
    {
      "indent": 6,
      "text": "- The endpoint shall always fill in the Verification Tag field of the outbound packet with the destination endpoint's tag value if it is known.",
      "ja": " - それがわかっている場合、エンドポイントは、常に宛先エンドポイントのタグ値とアウトバウンドパケットの検証タグフィールドに記入するものとします。"
    },
    {
      "indent": 6,
      "text": "- If the ABORT is sent in response to an OOTB packet, the endpoint MUST follow the procedure described in Section 8.4.",
      "ja": " -  ABORTはOOTBパケットに応答して送信された場合、エンドポイントは、8.4節で説明する手順に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "- The receiver MUST accept the packet if the Verification Tag matches either its own tag, OR the tag of its peer. Otherwise, the receiver MUST silently discard the packet and take no further action.",
      "ja": " - 検証タグは独自のタグ、またはそのピアのタグのいずれかと一致した場合、受信機はパケットを受け入れなければなりません。そうでない場合、受信機は静かにパケットを破棄し、それ以上の行動を取らないしなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.5.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "B) Rules for packet carrying ABORT:",
      "ja": "B）ABORTを運ぶパケットのためのルール："
    },
    {
      "indent": 6,
      "text": "- The endpoint MUST always fill in the Verification Tag field of the outbound packet with the destination endpoint's tag value, if it is known.",
      "ja": " - それがわかっている場合エンドポイントは常に、宛先エンドポイントのタグ値とアウトバウンドパケットの検証タグフィールドに入力する必要があります。"
    },
    {
      "indent": 6,
      "text": "- If the ABORT is sent in response to an OOTB packet, the endpoint MUST follow the procedure described in Section 8.4.",
      "ja": " -  ABORTはOOTBパケットに応答して送信された場合、エンドポイントは、8.4節で説明する手順に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "- The receiver of a ABORT MUST accept the packet if the Verification Tag field of the packet matches its own tag OR if it is set to its peer's tag and the T bit is set in the Chunk Flags. Otherwise, the receiver MUST silently discard the packet and take no further action.",
      "ja": " - それは、そのピアのタグに設定されているとTビットはチャンクフラグに設定されている場合は、パケットの検証タグフィールドは、独自のタグが一致する場合、またはABORTの受信機は、パケットを受け入れなければなりません。そうでない場合、受信機は静かにパケットを破棄し、それ以上の行動を取らないしなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.13.3. Solution Description",
      "section_title": true,
      "ja": "2.13.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above text change clarifies that the T bit must be set before an implementation looks for the peer's tag.",
      "ja": "上記のテキストの変更は、実装は、ピアのタグを検索する前に、Tビットを設定しなければならないことを明確にしています。"
    },
    {
      "indent": 0,
      "text": "2.14. Cwnd Gated by Its Full Use",
      "section_title": true,
      "ja": "2.14。その完全な使用によってゲートCWND"
    },
    {
      "indent": 0,
      "text": "2.14.1. Description of the Problem",
      "section_title": true,
      "ja": "2.14.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "A problem was found with the current specification of the growth and decay of cwnd. The cwnd should only be increased if it is being fully utilized, and after periods of underutilization, the cwnd should be decreased. In some sections, the current wording is weak and is not clearly defined. Also, the current specification unnecessarily introduces the need for special case code to ensure cwnd degradation. Plus, the cwnd should not be increased during Fast Recovery, since a full cwnd during Fast Recovery does not qualify the cwnd as being fully utilized. Additionally, multiple loss scenarios in a single window may cause the cwnd to grow more rapidly as the number of losses in a window increases [3].",
      "ja": "問題はのcwndの成長と衰退の現在の仕様で発見されました。それは十分に活用されている場合CWNDにのみ増加されるべきであり、不十分な利用の期間の後、CWNDを減少させるべきです。いくつかのセクションでは、現在の文言は弱く、明確に定義されていません。また、現在の仕様では、不必要にCWND劣化を確実にするために特殊なケースコードの必要性を導入します。高速リカバリ時にフルにcwndが十分に活用されているようにcwndを修飾していないので、プラス、CWNDは、高速回復中に増加すべきではありません。さらに、単一のウィンドウ内の複数の損失のシナリオは、[3] CWNDウィンドウ増加の損失の数がより急速に成長させてもよいです。"
    },
    {
      "indent": 0,
      "text": "2.14.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.14.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "D) Then, the sender can send out as many new DATA chunks as Rule A and Rule B above allow.",
      "ja": "D）次に、送信者はルールAとルールBのように多くの新しいDATAチャンクは、上記の許可送り出すことができます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "D) When the time comes for the sender to transmit new DATA chunks, the protocol parameter Max.Burst SHOULD be used to limit the number of packets sent. The limit MAY be applied by adjusting cwnd as follows:",
      "ja": "時刻が新しいデータチャンクを送信する送信者となるとD）、プロトコルパラメータMax.Burstは、送信されたパケットの数を制限するために使用されるべきです。制限は次のようにCWNDを調整することによって適用することができます。"
    },
    {
      "indent": 6,
      "text": "if((flightsize + Max.Burst*MTU) < cwnd) cwnd = flightsize + Max.Burst*MTU",
      "ja": "IF（（flightsize + Max.Burst * MTU）<CWND）CWND = flightsize + Max.Burst * MTU"
    },
    {
      "indent": 6,
      "text": "Or it MAY be applied by strictly limiting the number of packets emitted by the output routine.",
      "ja": "それとも、厳密に出力ルーチンによって放出されたパケットの数を制限することによって適用することもできます。"
    },
    {
      "indent": 3,
      "text": "E) Then, the sender can send out as many new DATA chunks as Rule A and Rule B allow.",
      "ja": "ルールAとルールBが許す限りE）次に、送信者は、多くの新しいDATAチャンクを送信することができます。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o When cwnd is less than or equal to ssthresh an SCTP endpoint MUST use the slow start algorithm to increase cwnd (assuming the current congestion window is being fully utilized). If an incoming SACK advances the Cumulative TSN Ack Point, cwnd MUST be increased by at most the lesser of 1) the total size of the previously outstanding DATA chunk(s) acknowledged, and 2) the destination's path MTU. This protects against the ACK-Splitting attack outlined in [SAVAGE99].",
      "ja": "CWNDは、SCTP終点をSSTHRESH以下である場合、O（現在の輻輳ウィンドウが完全に利用されていると仮定して）CWNDを増加させるためにスロースタートアルゴリズムを使用しなければなりません。着信SACKが累積TSNのAckポイントを進める場合、CWNDは、最も低い以前の未処理データのチャンク（S）の合計サイズが認め）1、及び2）宛先のパスMTUによって増加させなければなりません。これは、[SAVAGE99]で概説したACK分割攻撃から保護します。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o When cwnd is less than or equal to ssthresh, an SCTP endpoint MUST use the slow start algorithm to increase cwnd only if the current congestion window is being fully utilized, an incoming SACK advances the Cumulative TSN Ack Point, and the data sender is not in Fast Recovery. Only when these three conditions are met can the cwnd be increased; otherwise, the cwnd MUST not be increased. If these conditions are met, then cwnd MUST be increased by, at most, the lesser of 1) the total size of the previously outstanding DATA chunk(s) acknowledged, and 2) the destination's path MTU. This upper bound protects against the ACK-Splitting attack outlined in [SAVAGE99].",
      "ja": "CWNDがSSTHRESH以下である場合、O、SCTPエンドポイントは、現在の輻輳ウィンドウが完全に利用されている場合のみにcwndを増加させるためにスロースタートアルゴリズムを使用しなければなりません、着信SACKが累積TSNのAckポイントを進み、データ送信者ではありません高速リカバリインチこれら三つの条件が満たされた場合にのみにcwndを増加させることができます。そうでない場合は、CWNDが増加してはいけません。これらの条件が満たされている場合、CWNDは、以前の未処理データのチャンク（S）の合計サイズを認め、及び2）先のパスMTU）1より少ない、せいぜいによって増加されなければなりません。この上限は[SAVAGE99]で概説したACK分割攻撃から保護します。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 14)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "14. Suggested SCTP Protocol Parameter Values",
      "section_title": true,
      "ja": "14. SCTPプロトコルパラメータ値を推奨しました"
    },
    {
      "indent": 3,
      "text": "The following protocol parameters are RECOMMENDED:",
      "ja": "以下のプロトコルパラメータを推奨します。"
    },
    {
      "indent": 3,
      "text": "RTO.Initial - 3 seconds RTO.Min - 1 second RTO.Max - 60 seconds RTO.Alpha - 1/8 RTO.Beta - 1/4 Valid.Cookie.Life - 60 seconds Association.Max.Retrans - 10 attempts Path.Max.Retrans - 5 attempts (per destination address) Max.Init.Retransmits - 8 attempts HB.interval - 30 seconds",
      "ja": "RTO.Initial  -  3秒RTO.Min  -  1秒RTO.Max  -  60秒RTO.Alpha  -  1/8 RTO.Beta  -  1/4 Valid.Cookie.Life  -  60秒Association.Max.Retrans  -  10回のパス。 Max.Retrans  - （宛先アドレスごと）5つの試みMax.Init.Retransmits  -  8つの試みHB.interval  -  30秒"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 14)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "14. Suggested SCTP Protocol Parameter Values",
      "section_title": true,
      "ja": "14. SCTPプロトコルパラメータ値を推奨しました"
    },
    {
      "indent": 3,
      "text": "The following protocol parameters are RECOMMENDED:",
      "ja": "以下のプロトコルパラメータを推奨します。"
    },
    {
      "indent": 3,
      "text": "RTO.Initial - 3 seconds RTO.Min - 1 second RTO.Max - 60 seconds Max.Burst - 4 RTO.Alpha - 1/8 RTO.Beta - 1/4 Valid.Cookie.Life - 60 seconds Association.Max.Retrans - 10 attempts Path.Max.Retrans - 5 attempts (per destination address) Max.Init.Retransmits - 8 attempts HB.Interval - 30 seconds",
      "ja": "RTO.Initial  -  3秒RTO.Min  -  1秒RTO.Max  -  4 RTO.Alpha  -   -  Max.Burst 60秒1/8 RTO.Beta  -  1/4 Valid.Cookie.Life  -  60秒Association.Max.Retrans -  10試みるPath.Max.Retrans  - （宛先アドレスごと）5つの試みMax.Init.Retransmits  -  8つの試みHB.Interval  -  30秒"
    },
    {
      "indent": 0,
      "text": "2.14.3. Solution Description",
      "section_title": true,
      "ja": "2.14.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above changes strengthen the rules and make it much more apparent as to the need to block cwnd growth when the full cwnd is not being utilized. The changes also apply cwnd degradation without introducing the need for complex special case code.",
      "ja": "上記の変更は、ルールを強化し、フルにcwndが利用されていないときにcwndの成長を阻止する必要性として、それははるかに明白にします。変更は、複雑な特殊なケースコードの必要性を導入することなく、cwndの劣化を適用します。"
    },
    {
      "indent": 0,
      "text": "2.15. Window Probes in SCTP",
      "section_title": true,
      "ja": "2.15。 SCTPにおけるウィンドウプローブ"
    },
    {
      "indent": 0,
      "text": "2.15.1. Description of the Problem",
      "section_title": true,
      "ja": "2.15.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "When a receiver clamps its rwnd to 0 to flow control the peer, the specification implies that one must continue to accept data from the remote peer. This is incorrect and needs clarification.",
      "ja": "受信機は、ピア制御フロー0にそのRWNDをクランプするとき、仕様は、1つのリモートピアからのデータを受け入れ続けなければならないことを意味します。これは間違っていると明確化が必要です。"
    },
    {
      "indent": 0,
      "text": "2.15.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.15.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The SCTP endpoint MUST always acknowledge the receipt of each valid DATA chunk.",
      "ja": "SCTP終点は常に、各有効なデータ・チャンクの受信を確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The SCTP endpoint MUST always acknowledge the reception of each valid DATA chunk when the DATA chunk received is inside its receive window.",
      "ja": "受信したデータチャンクがその受信ウィンドウ内にあるとき、SCTP終点は常に、各有効なデータ・チャンクの受信を確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the receiver's advertised window is 0, the receiver MUST drop any new incoming DATA chunk with a TSN larger than the largest TSN received so far. If the new incoming DATA chunk holds a TSN value less than the largest TSN received so far, then the receiver SHOULD drop the largest TSN held for reordering and accept the new incoming DATA chunk. In either case, if such a DATA chunk is dropped, the receiver MUST immediately send back a SACK with the current receive window showing only DATA chunks received and accepted so far. The dropped DATA chunk(s) MUST NOT be included in the SACK, as they were not accepted. The receiver MUST also have an algorithm for advertising its receive window to avoid receiver silly window syndrome (SWS), as described in RFC 813. The algorithm can be similar to the one described in Section 4.2.3.3 of RFC 1122.",
      "ja": "受信機の広告ウィンドウが0の場合、受信機は、TSNがこれまでに受けた最大のより大きいTSNで任意の新しい着信データチャンクを削除する必要があります。新しい着信データチャンクはTSNがこれまでに受信した最大未満のTSN値を保持している場合、受信機は、並べ替えのために保持された最大のTSNをドロップし、新しい着信データチャンクを受け入れるべきです。いずれの場合においても、このようなデータチャンクが削除される場合、受信機はすぐに受信され、これまで受け入れられたデータのみチャンクを示す現在の受信ウィンドウとSACKを返送しなければなりません。彼らは受け入れられなかったとしてドロップされたデータのチャンク（複数可）、SACKに含まれてはいけません。受信機はまた、アルゴリズムは、RFC 1122のセクション4.2.3.3に記載したものと同様とすることができるRFC 813に記載されているように、（SWS）を受信愚かウィンドウ症候群を避けるために、その受信ウィンドウを広告するためのアルゴリズムがなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A) At any given time, the data sender MUST NOT transmit new data to any destination transport address if its peer's rwnd indicates that the peer has no buffer space (i.e., rwnd is 0, see Section 6.2.1). However, regardless of the value of rwnd (including if it is 0), the data sender can always have one DATA chunk in flight to the receiver if allowed by cwnd (see rule B below). This rule allows the sender to probe for a change in rwnd that the sender missed due to the SACK having been lost in transit from the data receiver to the data sender.",
      "ja": "そのピアのRWNDピア（すなわち、RWNDが0である、セクション6.2.1を参照）は、バッファスペースを有していないことを示す場合A）は、任意の所与の時点で、データ送信者は任意の宛先トランスポートアドレスに新しいデータを送信してはいけません。 CWNDによって許可されている場合しかし、関係なく（それが0である場合を含む）RWNDの値の、データの送信側は常に受信機に飛行中の一つのデータチャンクを有することができる（以下ルールBを参照）。このルールは、送信者は送信者が原因のデータ送信側にデータの受信機からのトランジットで失われたSACKに逃したRWNDの変化を調べることができます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A) At any given time, the data sender MUST NOT transmit new data to any destination transport address if its peer's rwnd indicates that the peer has no buffer space (i.e., rwnd is 0; see Section 6.2.1). However, regardless of the value of rwnd (including if it is 0), the data sender can always have one DATA chunk in flight to the receiver if allowed by cwnd (see rule B, below). This rule allows the sender to probe for a change in rwnd that the sender missed due to the SACK's having been lost in transit from the data receiver to the data sender.",
      "ja": "セクション6.2.1を参照）;そのピアのRWNDピア（すなわち、RWNDが0でないバッファスペースを有していないことを示す場合A）は、任意の所与の時点で、データ送信者は任意の宛先トランスポートアドレスに新しいデータを送信してはいけません。 CWNDによって許可されている場合しかし、関係なく（それが0である場合を含む）RWNDの値の、データの送信側は常に受信機に飛行中の一つのデータチャンクを有することができる（以下、ルールBを参照）。このルールは、送信者は送信者が原因SACKのデータ送信側にデータ受信機から輸送中に紛失されていたこと逃したRWNDの変化を調べることができます。"
    },
    {
      "indent": 6,
      "text": "When the receiver's advertised window is zero, this probe is called a zero window probe. Note that a zero window probe SHOULD only be sent when all outstanding DATA chunks have been cumulatively acknowledged and no DATA chunks are in flight. Zero window probing MUST be supported.",
      "ja": "受信機の広告ウィンドウがゼロの場合、このプローブは、ゼロウィンドウプローブと呼ばれています。すべての未処理データのチャンクが累積的に認められているとはデータのチャンクが飛行中でないときにゼロウィンドウプローブのみが送信されるべきであることに注意してください。プロービングゼロウィンドウをサポートしなければなりません。"
    },
    {
      "indent": 6,
      "text": "If the sender continues to receive new packets from the receiver while doing zero window probing, the unacknowledged window probes should not increment the error counter for the association or any destination transport address.This is because the receiver MAY keep its window closed for an indefinite time. Refer to Section 6.2 on the receiver behavior when it advertises a zero window. The sender SHOULD send the first zero window probe after 1 RTO when it detects that the receiver has closed its window and SHOULD increase the probe interval exponentially afterwards. Also note that the cwnd SHOULD be adjusted according to Section 7.2.1. Zero window probing does not affect the calculation of cwnd.",
      "ja": "送信者は、プロービングゼロウィンドウをしながら受信機からの新しいパケットの受信を継続する場合は、未確認のウィンドウプローブは会合または任意の宛先輸送address.Thisのエラーカウンタをインクリメントしてはならない受信機が保持してもよいので、そのウィンドウは無期限のため閉鎖されます。それがゼロウィンドウをアドバタイズするとき受信機の動作上のセクション6.2を参照してください。それは、受信機がそのウィンドウを閉じており、指数関数的にその後プローブ間隔を増やす必要があることを検出した場合、送信者は1 RTO後の最初のゼロウィンドウプローブを送るべきです。また、cwndは、セクション7.2.1に応じて調整する必要があることに注意してください。ゼロウィンドウのcwndの計算には影響しませんプロービング。"
    },
    {
      "indent": 6,
      "text": "The sender MUST also have an algorithm for sending new DATA chunks to avoid silly window syndrome (SWS) as described in RFC 813. The algorithm can be similar to the one described in Section 4.2.3.4 of RFC 1122.",
      "ja": "送信者はまた、アルゴリズムは、RFC 1122のセクション4.2.3.4に記載したものと同様とすることができるRFC 813に記載されているように愚かなウィンドウ症候群（SWS）を避けるために、新しいデータチャンクを送信するためのアルゴリズムがなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.15.3. Solution Description",
      "section_title": true,
      "ja": "2.15.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above allows a receiver to drop new data that arrives and yet still requires the receiver to send a SACK showing the conditions unchanged (with the possible exception of a new a_rwnd) and the dropped chunk as missing. This will allow the association to continue until the rwnd condition clears.",
      "ja": "上記受信機が到着すると、まだ行方不明として（新a_rwndの可能性を除いて）変わらない条件とドロップチャンクを示すSACKを送信するために受信機を必要とする新しいデータをドロップすることができます。これはRWND状態が解消されるまで会合が継続できるようになります。"
    },
    {
      "indent": 0,
      "text": "2.16. Fragmentation and Path MTU Issues",
      "section_title": true,
      "ja": "2.16。フラグメンテーションとパスMTUの問題"
    },
    {
      "indent": 0,
      "text": "2.16.1. Description of the Problem",
      "section_title": true,
      "ja": "2.16.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The current wording of the Fragmentation and Reassembly forces an implementation that supports fragmentation to always fragment. This prohibits an implementation from offering its users an option to disable sends that exceed the SCTP fragmentation point.",
      "ja": "フラグメンテーションおよび再構成の現在の文言は、常にフラグメントに断片化をサポートする実装を強制します。これは、そのユーザーを無効にするオプションを提供してから実装はそれがSCTPの断片化のポイントを超えて送信禁止しています。"
    },
    {
      "indent": 3,
      "text": "The restriction in RFC 2960 [5], Section 6.9, was never meant to restrict an implementations API from this behavior.",
      "ja": "RFC 2960 [5]、6.9節での制限は、この行動から実装のAPIを制限することを意図していませんでした。"
    },
    {
      "indent": 0,
      "text": "2.16.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.16.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6.9 Fragmentation and Reassembly",
      "section_title": true,
      "ja": "6.9断片化と再アセンブリ"
    },
    {
      "indent": 3,
      "text": "An endpoint MAY support fragmentation when sending DATA chunks, but MUST support reassembly when receiving DATA chunks. If an endpoint supports fragmentation, it MUST fragment a user message if the size of the user message to be sent causes the outbound SCTP packet size to exceed the current MTU. If an implementation does not support fragmentation of outbound user messages, the endpoint must return an error to its upper layer and not attempt to send the user message.",
      "ja": "エンドポイントは、DATAチャンクを送信するときに断片化をサポートするかもしれませんが、データのチャンクを受信したときに再構築をサポートしなければなりません。エンドポイントが断片化をサポートしている場合、ユーザ・メッセージのサイズが現在のMTUを超える発信SCTPパケットサイズを引き起こす送信する場合には、ユーザメッセージを断片化しなければなりません。実装は、発信ユーザメッセージの断片化をサポートしていない場合、エンドポイントは、その上位層にエラーを返すと、ユーザーのメッセージを送信しようとしてはなりません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In this error case, the Send primitive discussed in Section 10.1 would need to return an error to the upper layer.",
      "ja": "実装上の注意：このエラー場合は、10.1節で論じ送信プリミティブは、上位層にエラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6.9. Fragmentation and Reassembly",
      "section_title": true,
      "ja": "6.9。フラグメンテーションおよび再構成"
    },
    {
      "indent": 3,
      "text": "An endpoint MAY support fragmentation when sending DATA chunks, but it MUST support reassembly when receiving DATA chunks. If an endpoint supports fragmentation, it MUST fragment a user message if the size of the user message to be sent causes the outbound SCTP packet size to exceed the current MTU. If an implementation does not support fragmentation of outbound user messages, the endpoint MUST return an error to its upper layer and not attempt to send the user message.",
      "ja": "DATAチャンクを送信するときに、エンドポイントは、断片化をサポートするかもしれませんが、データのチャンクを受信したときには、再構築をサポートしなければなりません。エンドポイントが断片化をサポートしている場合、ユーザ・メッセージのサイズが現在のMTUを超える発信SCTPパケットサイズを引き起こす送信する場合には、ユーザメッセージを断片化しなければなりません。実装は、発信ユーザメッセージの断片化をサポートしていない場合、エンドポイントは、その上位層にエラーを返すと、ユーザーのメッセージを送信しようとしないしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: If an implementation that supports fragmentation makes available to its upper layer a mechanism to turn off fragmentation it may do so. However, in so doing, it MUST react just like an implementation that does NOT support fragmentation, i.e., it MUST reject sends that exceed the current P-MTU.",
      "ja": "注意：断片化をサポートする実装は、その上層それはそうかもしれ断片化をオフにする機構に提供する場合。しかし、そうすることで、それだけで断片化をサポートしていない実装、すなわち、それは現在のP-MTUを超えている送信拒絶しなければなりませんように反応しなければなりません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In this error case, the Send primitive discussed in Section 10.1 would need to return an error to the upper layer.",
      "ja": "実装上の注意：このエラー場合は、10.1節で論じ送信プリミティブは、上位層にエラーを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "2.16.3. Solution Description",
      "section_title": true,
      "ja": "2.16.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above wording will allow an implementation to offer the option of rejecting sends that exceed the P-MTU size even when the implementation supports fragmentation.",
      "ja": "上記の文言は、拒否のオプションを提供する実装は実装が断片化をサポートしても、P-MTUサイズを超えている送信できるようになります。"
    },
    {
      "indent": 0,
      "text": "2.17. Initial Value of the Cumulative TSN Ack",
      "section_title": true,
      "ja": "2.17。累積TSNのAckの初期値"
    },
    {
      "indent": 0,
      "text": "2.17.1. Description of the Problem",
      "section_title": true,
      "ja": "2.17.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The current description of the SACK chunk within the RFC does not clearly state the value that would be put within a SACK when no DATA chunk has been received.",
      "ja": "RFC内SACKチャンクの現在の記述は明らかにNO DATAチャンクを受信して​​いないときSACK以内に置かれる値を述べていません。"
    },
    {
      "indent": 0,
      "text": "2.17.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.17.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cumulative TSN Ack: 32 bits (unsigned integer)",
      "ja": "累積TSNのAck：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This parameter contains the TSN of the last DATA chunk received in sequence before a gap.",
      "ja": "このパラメータは、ギャップの前に順番に受け取った最後のDATAチャンクのTSNが含まれています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cumulative TSN Ack: 32 bits (unsigned integer)",
      "ja": "累積TSNのAck：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This parameter contains the TSN of the last DATA chunk received in sequence before a gap. In the case where no DATA chunk has been received, this value is set to the peer's Initial TSN minus one.",
      "ja": "このパラメータは、ギャップの前に順番に受け取った最後のDATAチャンクのTSNが含まれています。 NO DATAチャンクを受信して​​いない場合は、この値は、ピアの初期TSNマイナス1に設定されています。"
    },
    {
      "indent": 0,
      "text": "2.17.3. Solution Description",
      "section_title": true,
      "ja": "2.17.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "This change clearly states what the initial value will be for a SACK sender.",
      "ja": "この変更は明らかに初期値がSACKの送信者のためになるものを述べています。"
    },
    {
      "indent": 0,
      "text": "2.18. Handling of Address Parameters within the INIT or INIT-ACK",
      "section_title": true,
      "ja": "2.18。 INITまたはINIT-ACK内のアドレスパラメータの扱い"
    },
    {
      "indent": 0,
      "text": "2.18.1. Description of the Problem",
      "section_title": true,
      "ja": "2.18.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The current description on handling address parameters contained within the INIT and INIT-ACK does not fully describe a requirement for their handling.",
      "ja": "INITとINIT-ACK内に含まれるアドレスパラメータの取り扱いに関する現在の説明は完全に彼らの取扱いのための要件を説明していません。"
    },
    {
      "indent": 0,
      "text": "2.18.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.18.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.1.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C) If there are only IPv4/IPv6 addresses present in the received INIT or INIT ACK chunk, the receiver shall derive and record all the transport address(es) from the received chunk AND the source IP address that sent the INIT or INIT ACK. The transport address(es) are derived by the combination of SCTP source port (from the common header) and the IP address parameter(s) carried in the INIT or INIT ACK chunk and the source IP address of the IP datagram. The receiver should use only these transport addresses as destination transport addresses when sending subsequent packets to its peer.",
      "ja": "C）のみのIPv4 / IPv6が受信INITあるいはINIT ACKチャンクに存在するアドレスがある場合、受信機は、導出し、受信したチャンクとINITまたはINIT ACKを送信した送信元IPアドレスからのすべてのトランスポートアドレスを記録しなければなりません。トランスポートアドレス（複数可）は、（共通ヘッダから）SCTP送信元ポートの組み合わせとINITあるいはINIT ACKチャンクとIPデータグラムの送信元IPアドレスで運ばれるIPアドレスパラメータ（単数または複数）によって導出されます。ピアへの後続のパケットを送信するとき、受信機は、送信先トランスポートアドレスとしてのみ、これらのトランスポート・アドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.1.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C) If there are only IPv4/IPv6 addresses present in the received INIT or INIT ACK chunk, the receiver MUST derive and record all the transport addresses from the received chunk AND the source IP address that sent the INIT or INIT ACK. The transport addresses are derived by the combination of SCTP source port (from the common header) and the IP address parameter(s) carried in the INIT or INIT ACK chunk and the source IP address of the IP datagram. The receiver should use only these transport addresses as destination transport addresses when sending subsequent packets to its peer.",
      "ja": "C）のみのIPv4 / IPv6が受信INITあるいはINIT ACKチャンクに存在するアドレスがある場合、受信機は、導出し、受信したチャンクとINITまたはINIT ACKを送信した送信元IPアドレスからのすべてのトランスポートアドレスを記録しなければなりません。トランスポート・アドレスは、（共通ヘッダから）SCTP送信元ポートの組み合わせとINITあるいはINIT ACKチャンクとIPデータグラムの送信元IPアドレスで運ばれるIPアドレスパラメータ（単数または複数）によって導出されます。ピアへの後続のパケットを送信するとき、受信機は、送信先トランスポートアドレスとしてのみ、これらのトランスポート・アドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "D) An INIT or INIT ACK chunk MUST be treated as belonging to an already established association (or one in the process of being established) if the use of any of the valid address parameters contained within the chunk would identify an existing TCB.",
      "ja": "D）INITあるいはINIT ACKチャンクは、チャンク内に含まれる有効なアドレス・パラメータのいずれかの使用は、既存のTCBを識別するならば）確立の過程において既に確立されたアソシエーション（または1つに属するものとして扱わなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.18.3. Solution description",
      "section_title": true,
      "ja": "2.18.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "This new text clearly specifies to an implementor the need to look within the INIT or INIT ACK. Any implementation that does not do this may (for example) not be able to recognize an INIT chunk coming from an already established association that adds new addresses (see Section 2.6) or an incoming INIT ACK chunk sent from a source address different from the destination address used to send the INIT chunk.",
      "ja": "この新しいテキストがはっきり実装にINITまたはINIT ACKの中に見る必要を指定します。これを実行しない任意の実装では、（例えば）先と異なる送信元アドレスから送信された新しいアドレス（セクション2.6を参照）または着信INIT ACKチャンクを追加し、既に確立協会からのINITチャンクを認識することができないかもしれませんアドレスはINITチャンクを送信するために使用されます。"
    },
    {
      "indent": 0,
      "text": "2.19. Handling of Stream Shortages",
      "section_title": true,
      "ja": "2.19。ストリーム不足の取扱い"
    },
    {
      "indent": 0,
      "text": "2.19.1. Description of the Problem",
      "section_title": true,
      "ja": "2.19.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The current wording in the RFC places the choice of sending an ABORT upon the SCTP stack when a stream shortage occurs. This decision should really be made by the upper layer, not the SCTP stack.",
      "ja": "RFCの現在の文言は、ストリーム不足が発生したときにSCTPスタック時にABORTを送信する選択肢を配置します。この決定は、実際に上位層ではなく、SCTPスタックによってなされるべきです。"
    },
    {
      "indent": 0,
      "text": "2.19.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.19.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text:\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5.1.1 Handle Stream Parameters",
      "section_title": true,
      "ja": "5.1.1ハンドルストリーム・パラメータ"
    },
    {
      "indent": 3,
      "text": "In the INIT and INIT ACK chunks, the sender of the chunk shall indicate the number of outbound streams (OS) it wishes to have in the association, as well as the maximum inbound streams (MIS) it will accept from the other endpoint.",
      "ja": "INITとINIT ACKチャンクは、チャンクの送信者は、それが他のエンドポイントから受け入れる関連を持っていることを望むだけでなく、最大のインバウンドストリーム（MIS）アウトバウンドストリーム（OS）の数を示すものとします。"
    },
    {
      "indent": 3,
      "text": "After receiving the stream configuration information from the other side, each endpoint shall perform the following check: If the peer's MIS is less than the endpoint's OS, meaning that the peer is incapable of supporting all the outbound streams the endpoint wants to configure, the endpoint MUST either use MIS outbound streams, or abort the association and report to its upper layer the resources shortage at its peer.",
      "ja": "他の側からのストリーム構成情報を受信した後、各エンドポイントは、次のチェックを実行しなければならないピアのMISは、エンドポイントは、ピアがエンドポイントを設定したいすべての発信ストリームをサポートすることができないことを意味し、エンドポイントのOSよりも小さい場合ピアでリソース不足をMISアウトバウンドストリームを使用するか、または関連付けを中止し、その上位層に報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.1.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5.1.1. Handle Stream Parameters",
      "section_title": true,
      "ja": "5.1.1。ストリームのパラメータを扱います"
    },
    {
      "indent": 3,
      "text": "In the INIT and INIT ACK chunks, the sender of the chunk MUST indicate the number of outbound streams (OS) it wishes to have in the association, as well as the maximum inbound streams (MIS) it will accept from the other endpoint.",
      "ja": "INITとINIT ACKチャンクは、チャンクの送信者は、それが他のエンドポイントから受け入れる関連を持っていることを望むだけでなく、最大のインバウンドストリーム（MIS）アウトバウンドストリーム（OS）の数を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "After receiving the stream configuration information from the other side, each endpoint MUST perform the following check: If the peer's MIS is less than the endpoint's OS, meaning that the peer is incapable of supporting all the outbound streams the endpoint wants to configure, the endpoint MUST use MIS outbound streams and MAY report any shortage to the upper layer. The upper layer can then choose to abort the association if the resource shortage is unacceptable.",
      "ja": "他の側からのストリーム構成情報を受信した後、各エンドポイントは、次のチェックを実行しなければなりません：ピアのMISは、エンドポイントは、ピアがエンドポイントを設定したいすべての発信ストリームをサポートすることができないことを意味し、エンドポイントのOSよりも小さい場合MISアウトバウンド・ストリームを使用しなければならないし、上位層に任意の不足を報告することがあります。上層は、リソース不足が許容できない場合の関連付けを中止することを選択することができます。"
    },
    {
      "indent": 0,
      "text": "2.19.3. Solution Description",
      "section_title": true,
      "ja": "2.19.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above changes take the decision to ABORT out of the realm of the SCTP stack and place it into the user's hands.",
      "ja": "上記の変更は、SCTPスタックの領域の外に中止し、ユーザーの手にそれを置くために決定を取ります。"
    },
    {
      "indent": 0,
      "text": "2.20. Indefinite Postponement",
      "section_title": true,
      "ja": "2.20。無期限延期"
    },
    {
      "indent": 0,
      "text": "2.20.1. Description of the Problem",
      "section_title": true,
      "ja": "2.20.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The current RFC does not provide any guidance on the assignment of TSN sequence numbers to outbound messages nor reception of these messages. This could lead to a possible indefinite postponement.",
      "ja": "現在のRFCは、これらのメッセージの送信メッセージも受信にTSNシーケンス番号の割り当てのいずれかのガイダンスを提供していません。これは、可能な無期限延期につながる可能性があります。"
    },
    {
      "indent": 0,
      "text": "2.20.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.20.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: The data sender SHOULD NOT use a TSN that is more than 2**31 - 1 above the beginning TSN of the current send window.",
      "ja": "注意：データの送信者は2 ** 31以上であるTSN使うべきではありません -  1現在の送信ウィンドウの開始TSNの上を。"
    },
    {
      "indent": 3,
      "text": "6.2 Acknowledgement on Reception of DATA Chunks",
      "section_title": true,
      "ja": "データチャンクのレセプションに6.2謝辞"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: The data sender SHOULD NOT use a TSN that is more than 2**31 - 1 above the beginning TSN of the current send window.",
      "ja": "注意：データの送信者は2 ** 31以上であるTSN使うべきではありません -  1現在の送信ウィンドウの開始TSNの上を。"
    },
    {
      "indent": 3,
      "text": "The algorithm by which an implementation assigns sequential TSNs to messages on a particular association MUST ensure that no user message that has been accepted by SCTP is indefinitely postponed from being assigned a TSN. Acceptable algorithms for assigning TSNs include",
      "ja": "実装は、特定のアソシエーション上のメッセージにシーケンシャルのTSNを割り当てることにより、アルゴリズムは、SCTPによって受け付けられたどのユーザメッセージが無限にTSNを割り当てられるから延期されていないことを確認しなければなりません。 TSNを割り当てるために許容されるアルゴリズムは、"
    },
    {
      "indent": 3,
      "text": "(a) assigning TSNs in round-robin order over all streams with pending data; and",
      "ja": "（a）は、保留データを有するすべてのストリーム上のラウンドロビン順序でのTSNを割り当てます。そして"
    },
    {
      "indent": 3,
      "text": "(b) preserving the linear order in which the user messages were submitted to the SCTP association.",
      "ja": "（b）ユーザメッセージをSCTPアソシエーションに提出された直線状の順序を保存します。"
    },
    {
      "indent": 3,
      "text": "When an upper layer requests to read data on an SCTP association, the SCTP receiver SHOULD choose the message with the lowest TSN from among all deliverable messages. In SCTP implementations that allow a user to request data on a specific stream, this operation SHOULD NOT block if data is not available, since this can lead to a deadlock under certain conditions.",
      "ja": "SCTPアソシエーション上のデータを読み取るときに上層要求、SCTPの受信機は、すべての成果のメッセージの中から最も低いTSNを有するメッセージを選択してください。データが利用できない場合、これは、特定の条件下でデッドロックにつながる可能性があるため、ユーザが特定のストリーム上でデータを要求することを可能にするSCTPの実装では、この動作は、ブロックすべきではありません。"
    },
    {
      "indent": 3,
      "text": "6.2. Acknowledgement on Receipt of DATA Chunks",
      "section_title": true,
      "ja": "6.2。データチャンクの領収書に謝辞"
    },
    {
      "indent": 0,
      "text": "2.20.3. Solution Description",
      "section_title": true,
      "ja": "2.20.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above wording clarifies how TSNs SHOULD be assigned by the sender.",
      "ja": "上記の文言はのTSNが送信者によって割り当てられるべきかを明確にしています。"
    },
    {
      "indent": 0,
      "text": "2.21. User-Initiated Abort of an Association",
      "section_title": true,
      "ja": "2.21。協会のユーザ起動中止"
    },
    {
      "indent": 0,
      "text": "2.21.1. Description of the Problem",
      "section_title": true,
      "ja": "2.21.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "It is not possible for an upper layer to abort the association and provide the peer with an indication of why the association is aborted.",
      "ja": "上層がアソシエーションを中止し、関連付けが中止された理由の指示とピアを提供することは不可能です。"
    },
    {
      "indent": 0,
      "text": "2.21.2. Text changes to the document",
      "section_title": true,
      "ja": "2.21.2。文書へのテキストの変更"
    },
    {
      "indent": 3,
      "text": "Some of the changes given here already include changes suggested in Section 2.6 of this document.",
      "ja": "ここで与えられた変化のいくつかは、すでにこのドキュメントのセクション2.6で提案された変更が含まれます。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.10)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Cause Code\nValue           Cause Code\n---------      ----------------\n 1              Invalid Stream Identifier\n 2              Missing Mandatory Parameter\n 3              Stale Cookie Error\n 4              Out of Resource\n 5              Unresolvable Address\n 6              Unrecognized Chunk Type\n 7              Invalid Mandatory Parameter\n 8              Unrecognized Parameters\n 9              No User Data\n10              Cookie Received While Shutting Down",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cause Length: 16 bits (unsigned integer)",
      "ja": "原因長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause-Specific Information fields",
      "ja": "原因コード、原因の長さ、および原因固有の情報フィールドを含むバイト単位でのパラメータの大きさに設定してください"
    },
    {
      "indent": 3,
      "text": "Cause-specific Information: variable length",
      "ja": "原因固有情報：可変長"
    },
    {
      "indent": 6,
      "text": "This field carries the details of the error condition.",
      "ja": "このフィールドには、エラー状態の詳細を運びます。"
    },
    {
      "indent": 3,
      "text": "Sections 3.3.10.1 - 3.3.10.10 define error causes for SCTP. Guidelines for the IETF to define new error cause values are discussed in Section 13.3.",
      "ja": "セクション3.3.10.1  -  3.3.10.10エラーがSCTPの原因を定義します。新しいエラー原因値を定義するために、IETFのためのガイドラインは、13.3節で議論されています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.10)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Cause Code\nValue           Cause Code\n---------      ----------------\n 1              Invalid Stream Identifier\n 2              Missing Mandatory Parameter\n 3              Stale Cookie Error\n 4              Out of Resource\n 5              Unresolvable Address\n 6              Unrecognized Chunk Type\n 7              Invalid Mandatory Parameter\n 8              Unrecognized Parameters\n 9              No User Data\n10              Cookie Received While Shutting Down\n11              Restart of an Association with New Addresses\n12              User-Initiated Abort",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cause Length: 16 bits (unsigned integer)",
      "ja": "原因長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause-Specific Information fields",
      "ja": "原因コード、原因の長さ、および原因固有の情報フィールドを含むバイト単位でのパラメータの大きさに設定してください"
    },
    {
      "indent": 3,
      "text": "Cause-specific Information: variable length",
      "ja": "原因固有情報：可変長"
    },
    {
      "indent": 6,
      "text": "This field carries the details of the error condition.",
      "ja": "このフィールドには、エラー状態の詳細を運びます。"
    },
    {
      "indent": 3,
      "text": "Sections 3.3.10.1 - 3.3.10.12 define error causes for SCTP. Guidelines for the IETF to define new error cause values are discussed in Section 13.3.",
      "ja": "セクション3.3.10.1  -  3.3.10.12エラーがSCTPの原因を定義します。新しいエラー原因値を定義するために、IETFのためのガイドラインは、13.3節で議論されています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Note: no old text, new error added in Section 3.3.10)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3.3.10.12. User-Initiated Abort (12)",
      "section_title": true,
      "ja": "3.3.10.12。ユーザ起動の中止（12）"
    },
    {
      "indent": 4,
      "text": "Cause of error\n--------------",
      "raw": true
    },
    {
      "indent": 4,
      "text": "This error cause MAY be included in ABORT chunks that are sent because of an upper layer request. The upper layer can specify an Upper Layer Abort Reason that is transported by SCTP transparently and MAY be delivered to the upper layer protocol at the peer.",
      "ja": "このエラー原因があるため、上位層の要求を送信されたABORTチャンクに含まれるかもしれません。上層を透過SCTPによって搬送され、ピアに上位レイヤプロトコルに送達することができる上位層アボート理由を指定することができます。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Cause Code=12         |      Cause Length=Variable    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                    Upper Layer Abort Reason                   /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 9.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "9.1 Abort of an Association",
      "section_title": true,
      "ja": "協会の9.1中止"
    },
    {
      "indent": 6,
      "text": "When an endpoint decides to abort an existing association, it shall send an ABORT chunk to its peer endpoint. The sender MUST fill in the peer's Verification Tag in the outbound packet and MUST NOT bundle any DATA chunk with the ABORT.",
      "ja": "エンドポイントは、既存の関連付けを中止することを決定したときは、そのピアエンドポイントにABORTチャンクを送信しなければなりません。送信者は、発信パケットにピアの検証タグに記入しなければならないとABORTで任意のデータチャンクをバンドルしてはなりません。"
    },
    {
      "indent": 6,
      "text": "An endpoint MUST NOT respond to any received packet that contains an ABORT chunk (also see Section 8.4).",
      "ja": "エンドポイントは、（また、8.4節を参照）ABORTチャンクを含む任意の受信パケットに応じてはいけません。"
    },
    {
      "indent": 6,
      "text": "An endpoint receiving an ABORT shall apply the special Verification Tag check rules described in Section 8.5.1.",
      "ja": "ABORTを受けたエンドポイントは、セクション8.5.1で説明した特別な検証タグのチェックルールを適用しなければなりません。"
    },
    {
      "indent": 6,
      "text": "After checking the Verification Tag, the receiving endpoint shall remove the association from its record and shall report the termination to its upper layer.",
      "ja": "検証タグをチェックした後、受信側のエンドポイントは、そのレコードから関連付けを削除するものとし、その上層に終了を報告するものとします。"
    },
    {
      "indent": 6,
      "text": "---------\nNew text: (Section 9.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "9.1. Abort of an Association",
      "section_title": true,
      "ja": "9.1。協会の中止"
    },
    {
      "indent": 6,
      "text": "When an endpoint decides to abort an existing association, it MUST send an ABORT chunk to its peer endpoint. The sender MUST fill in the peer's Verification Tag in the outbound packet and MUST NOT bundle any DATA chunk with the ABORT. If the association is aborted on request of the upper layer, a User-Initiated Abort error cause (see 3.3.10.12) SHOULD be present in the ABORT chunk.",
      "ja": "エンドポイントは、既存の関連付けを中止することを決定したときは、そのピアエンドポイントにABORTチャンクを送らなければなりません。送信者は、発信パケットにピアの検証タグに記入しなければならないとABORTで任意のデータチャンクをバンドルしてはなりません。関連付けが上層、ユーザ起動アボートエラー原因の要求に中止された場合（3.3.10.12参照）ABORTチャンク中に存在すべきです。"
    },
    {
      "indent": 6,
      "text": "An endpoint MUST NOT respond to any received packet that contains an ABORT chunk (also see Section 8.4).",
      "ja": "エンドポイントは、（また、8.4節を参照）ABORTチャンクを含む任意の受信パケットに応じてはいけません。"
    },
    {
      "indent": 6,
      "text": "An endpoint receiving an ABORT MUST apply the special Verification Tag check rules described in Section 8.5.1.",
      "ja": "ABORTを受けたエンドポイントは、セクション8.5.1で説明した特別な検証タグのチェックルールを適用しなければなりません。"
    },
    {
      "indent": 6,
      "text": "After checking the Verification Tag, the receiving endpoint MUST remove the association from its record and SHOULD report the termination to its upper layer. If a User-Initiated Abort error cause is present in the ABORT chunk, the Upper Layer Abort Reason SHOULD be made available to the upper layer.",
      "ja": "検証タグをチェックした後、受信側のエンドポイントは、そのレコードから関連付けを削除しなければならないし、その上層に終了を報告する必要があります。ユーザ起動中止エラー原因がABORTチャンクに存在する場合、上位層中止理由は、上位層に利用できるようにすべきです。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 10.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "D) Abort",
      "ja": "D）アボート"
    },
    {
      "indent": 6,
      "text": "Format: ABORT(association id [, cause code]) -> result",
      "ja": "フォーマット：ABORT（アソシエーションID [、原因コード]） - >結果"
    },
    {
      "indent": 6,
      "text": "Ungracefully closes an association. Any locally queued user data will be discarded and an ABORT chunk is sent to the peer. A success code will be returned on successful abortion of the association. If attempting to abort the association results in a failure, an error code shall be returned.",
      "ja": "不正に関連付けを閉じます。任意のローカルキューに入れられたユーザデータが破棄され、ABORTチャンクはピアに送信されます。成功コードは、協会の成功中絶に返されます。失敗に関連した結果を中止しようとした場合、エラーコードが返されなければなりません。"
    },
    {
      "indent": 6,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 6,
      "text": "o association id - local handle to the SCTP association",
      "ja": "O協会イド -  SCTP協会へのローカルハンドル"
    },
    {
      "indent": 6,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 6,
      "text": "o cause code - reason of the abort to be passed to the peer.",
      "ja": "Oの原因コード - 中断の理由は、ピアに渡されます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 10.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "D) Abort",
      "ja": "D）アボート"
    },
    {
      "indent": 6,
      "text": "Format: ABORT(association id [, Upper Layer Abort Reason]) -> result",
      "ja": "フォーマット：ABORT（アソシエーションID [上層中止理由]） - >結果"
    },
    {
      "indent": 6,
      "text": "Ungracefully closes an association. Any locally queued user data will be discarded, and an ABORT chunk is sent to the peer. A success code will be returned on successful abortion of the association. If attempting to abort the association results in a failure, an error code shall be returned.",
      "ja": "不正に関連付けを閉じます。任意のローカルキューに入れられたユーザデータが破棄され、ABORTチャンクはピアに送信されます。成功コードは、協会の成功中絶に返されます。失敗に関連した結果を中止しようとした場合、エラーコードが返されなければなりません。"
    },
    {
      "indent": 6,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 6,
      "text": "o association id - Local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会へのローカルハンドル。"
    },
    {
      "indent": 6,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 6,
      "text": "o Upper Layer Abort Reason - Reason of the abort to be passed to the peer.",
      "ja": "O上位層アボート理由 - 中止の理由は、ピアに渡されます。"
    },
    {
      "indent": 6,
      "text": "None.",
      "ja": "無し。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 10.2)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "E) COMMUNICATION LOST notification",
      "ja": "E）COMMUNICATION LOST通知"
    },
    {
      "indent": 6,
      "text": "When SCTP loses communication to an endpoint completely (e.g., via Heartbeats) or detects that the endpoint has performed an abort operation, it shall invoke this notification on the ULP.",
      "ja": "SCTP（例えば、ハートビートを介して）完全にエンドポイントとの通信を失ったか、エンドポイントが中断操作が行われたことを検出すると、それはULPにこの通知を起動しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The following shall be passed with the notification:",
      "ja": "以下は、通知を渡さなければなりません。"
    },
    {
      "indent": 6,
      "text": "o association id - local handle to the SCTP association",
      "ja": "O協会イド -  SCTP協会へのローカルハンドル"
    },
    {
      "indent": 6,
      "text": "o status - This indicates what type of event has occurred; The status may indicate a failure OR a normal termination event occurred in response to a shutdown or abort request.",
      "ja": "Oステータス - これは、発生したイベントの種類を示します。ステータスが障害または正常終了イベントはシャットダウンに反応して発生した指示や要求を中止することがあります。"
    },
    {
      "indent": 6,
      "text": "The following may be passed with the notification:",
      "ja": "以下は通知で渡されます："
    },
    {
      "indent": 6,
      "text": "o data retrieval id - an identification used to retrieve unsent and unacknowledged data.",
      "ja": "Oデータ検索ID  - 未送信及び未確認データを取得するために使用される識別。"
    },
    {
      "indent": 6,
      "text": "o last-acked - the TSN last acked by that peer endpoint;",
      "ja": "O最後にACKさ -  TSN最後そのピアエンドポイントによってACKさ。"
    },
    {
      "indent": 6,
      "text": "o last-sent - the TSN last sent to that peer endpoint;",
      "ja": "O最後に送られた -  TSNは最後にその同輩終点に送られました。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 10.2)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "E) COMMUNICATION LOST notification",
      "ja": "E）COMMUNICATION LOST通知"
    },
    {
      "indent": 6,
      "text": "When SCTP loses communication to an endpoint completely (e.g., via Heartbeats) or detects that the endpoint has performed an abort operation, it shall invoke this notification on the ULP.",
      "ja": "SCTP（例えば、ハートビートを介して）完全にエンドポイントとの通信を失ったか、エンドポイントが中断操作が行われたことを検出すると、それはULPにこの通知を起動しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The following shall be passed with the notification:",
      "ja": "以下は、通知を渡さなければなりません。"
    },
    {
      "indent": 6,
      "text": "o association id - Local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会へのローカルハンドル。"
    },
    {
      "indent": 6,
      "text": "o status - This indicates what type of event has occurred; The status may indicate that a failure OR a normal termination event occurred in response to a shutdown or abort request.",
      "ja": "Oステータス - これは、発生したイベントの種類を示します。ステータスが障害または正常終了イベントはシャットダウンに反応して発生したことを示したり、要求を中止することがあります。"
    },
    {
      "indent": 6,
      "text": "The following may be passed with the notification:",
      "ja": "以下は通知で渡されます："
    },
    {
      "indent": 6,
      "text": "o data retrieval id - An identification used to retrieve unsent and unacknowledged data.",
      "ja": "Oデータ検索ID  - 未送信及び未確認データを取得するために使用される識別。"
    },
    {
      "indent": 6,
      "text": "o last-acked - The TSN last acked by that peer endpoint.",
      "ja": "O最後-ACKさ -  TSN最後のそのピアエンドポイントでACKさ。"
    },
    {
      "indent": 6,
      "text": "o last-sent - The TSN last sent to that peer endpoint.",
      "ja": "O最後に送られた -  TSNは最後にその同輩終点に送られます。"
    },
    {
      "indent": 6,
      "text": "o Upper Layer Abort Reason - The abort reason specified in case of a user-initiated abort.",
      "ja": "O上位層アボート理由 - ユーザーが開始アボートの場合には指定された中止理由。"
    },
    {
      "indent": 0,
      "text": "2.21.3. Solution Description",
      "section_title": true,
      "ja": "2.21.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above allows an upper layer to provide its peer with an indication of why the association was aborted. Therefore, an addition error cause was introduced.",
      "ja": "上記上層が、関連付けが中止された理由の指示とそのピアを提供することを可能にします。そのため、追加のエラー原因が導入されました。"
    },
    {
      "indent": 0,
      "text": "2.22. Handling of Invalid Initiate Tag of INIT-ACK",
      "section_title": true,
      "ja": "2.22。無効の取り扱いは、INIT-ACKのタグを開始します"
    },
    {
      "indent": 0,
      "text": "2.22.1. Description of the Problem",
      "section_title": true,
      "ja": "2.22.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "RFC 2960 requires that the receiver of an INIT-ACK with the Initiate Tag set to zero handles this as an error and sends back an ABORT. But the sender of the INIT-ACK normally has no TCB, and thus the ABORT is useless.",
      "ja": "RFC 2960は、ゼロに設定開始タグとINIT-ACKの受信機は、エラーとしてこれを処理し、ABORTを送り返すことを要求します。しかし、INIT-ACKの送信者は、通常は何のTCBを持っていないため、ABORTは無用です。"
    },
    {
      "indent": 0,
      "text": "2.22.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.22.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.3)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Initiate Tag: 32 bits (unsigned integer)",
      "ja": "タグを開始：32ビット（符号なし整数）"
    },
    {
      "indent": 9,
      "text": "The receiver of the INIT ACK records the value of the Initiate Tag parameter. This value MUST be placed into the Verification Tag field of every SCTP packet that the INIT ACK receiver transmits within this association.",
      "ja": "INIT ACKの受信機は、開始タグのパラメータの値を記録します。この値は、INIT ACKの受信機は、このアソシエーション内で送信するすべてのSCTPパケットの検証タグフィールドに入れなければなりません。"
    },
    {
      "indent": 9,
      "text": "The Initiate Tag MUST NOT take the value 0. See Section 5.3.1 for more on the selection of the Initiate Tag value.",
      "ja": "開始タグは、開始タグの値の選択の詳細については値0を参照してくださいセクション5.3.1を取るてはなりません。"
    },
    {
      "indent": 9,
      "text": "If the value of the Initiate Tag in a received INIT ACK chunk is found to be 0, the receiver MUST treat it as an error and close the association by transmitting an ABORT.",
      "ja": "受信したINIT ACKチャンク内の開始タグの値が0であることが見出された場合、受信機は、エラーとして扱い、ABORTを送信することにより関連付けを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.3)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Initiate Tag: 32 bits (unsigned integer)",
      "ja": "タグを開始：32ビット（符号なし整数）"
    },
    {
      "indent": 9,
      "text": "The receiver of the INIT ACK records the value of the Initiate Tag parameter. This value MUST be placed into the Verification Tag field of every SCTP packet that the INIT ACK receiver transmits within this association.",
      "ja": "INIT ACKの受信機は、開始タグのパラメータの値を記録します。この値は、INIT ACKの受信機は、このアソシエーション内で送信するすべてのSCTPパケットの検証タグフィールドに入れなければなりません。"
    },
    {
      "indent": 9,
      "text": "The Initiate Tag MUST NOT take the value 0. See Section 5.3.1 for more on the selection of the Initiate Tag value.",
      "ja": "開始タグは、開始タグの値の選択の詳細については値0を参照してくださいセクション5.3.1を取るてはなりません。"
    },
    {
      "indent": 9,
      "text": "If the value of the Initiate Tag in a received INIT ACK chunk is found to be 0, the receiver MUST destroy the association discarding its TCB. The receiver MAY send an ABORT for debugging purpose.",
      "ja": "受信したINIT ACKチャンク内の開始タグの値が0であることが見出された場合、受信機は、そのTCBを破棄会合を破壊しなければなりません。受信機は、目的をデバッグするためのABORTを送信することができます。"
    },
    {
      "indent": 0,
      "text": "2.22.3. Solution Description",
      "section_title": true,
      "ja": "2.22.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text does not require that the receiver of the invalid INIT-ACK send the ABORT. This behavior is in tune with the error case of invalid stream numbers in the INIT-ACK. However, sending an ABORT for debugging purposes is allowed.",
      "ja": "新しいテキストが無効INIT-ACKの受信機はABORTを送信する必要はありません。この動作は、INIT-ACKで無効なストリーム番号のエラーケースと調和しています。ただし、デバッグ目的でABORTを送信することは許可されています。"
    },
    {
      "indent": 0,
      "text": "2.23. Sending an ABORT in Response to an INIT",
      "section_title": true,
      "ja": "2.23。 INITへの応答でABORTを送信"
    },
    {
      "indent": 0,
      "text": "2.23.1. Description of the Problem",
      "section_title": true,
      "ja": "2.23.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Whenever the receiver of an INIT chunk has to send an ABORT chunk in response, for whatever reason, it is not stated clearly which Verification Tag and value of the T-bit should be used.",
      "ja": "INITチャンクの受信機は、どんな理由であれ、応答でABORTチャンクを送信するために持っているときはいつでも、検証タグとTビットの値を使用すべきか明確に記載しておりません。"
    },
    {
      "indent": 0,
      "text": "2.23.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.23.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.4)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "3) If the packet contains an INIT chunk with a Verification Tag set to '0', process it as described in Section 5.1. Otherwise,",
      "ja": "3）5.1節で説明したように、パケットがINIT「0」に設定検証タグとチャンク、プロセス、それが含まれている場合。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.4)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "3) If the packet contains an INIT chunk with a Verification Tag set to '0', process it as described in Section 5.1. If, for whatever reason, the INIT cannot be processed normally and an ABORT has to be sent in response, the Verification Tag of the packet containing the ABORT chunk MUST be the Initiate tag of the received INIT chunk, and the T-Bit of the ABORT chunk has to be set to 0, indicating that a TCB was destroyed. Otherwise,",
      "ja": "3）5.1節で説明したように、パケットがINIT「0」に設定検証タグとチャンク、プロセス、それが含まれている場合。何らかの理由で、INITが正常に処理できないとABORTが応答して送信する必要がある、場合、ABORTチャンクを含むパケットの検証タグは、受信INITチャンクの開始タグ、およびのTビットでなければなりませんチャンクを中止するTCBが破壊されたことを示す、0に設定されなければなりません。そうでなければ、"
    },
    {
      "indent": 0,
      "text": "2.23.3. Solution Description",
      "section_title": true,
      "ja": "2.23.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text stated clearly which value of the Verification Tag and T-bit have to be used.",
      "ja": "新しいテキストが使用されなければならない検証タグとTビットの値が明確に述べています。"
    },
    {
      "indent": 0,
      "text": "2.24. Stream Sequence Number (SSN) Initialization",
      "section_title": true,
      "ja": "2.24。ストリームシーケンス番号（SSN）の初期化"
    },
    {
      "indent": 0,
      "text": "2.24.1. Description of the Problem",
      "section_title": true,
      "ja": "2.24.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "RFC 2960 does not describe the fact that the SSN has to be initialized to 0, as required by RFC 2119.",
      "ja": "RFC 2960は、SSNは、RFC 2119で要求されるよう、0に初期化されなければならないという事実を説明していません。"
    },
    {
      "indent": 0,
      "text": "2.24.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.24.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.5)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The stream sequence number in all the streams shall start from 0 when the association is established. Also, when the stream sequence number reaches the value 65535 the next stream sequence number shall be set to 0.",
      "ja": "アソシエーションが確立されると、すべてのストリーム内のストリームシーケンス番号は0から開始しなければなりません。ストリーム・シーケンス番号が値に達したときにも、65535次のストリームのシーケンス番号が0に設定されます。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.5)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The stream sequence number in all the streams MUST start from 0 when the association is established. Also, when the stream sequence number reaches the value 65535 the next stream sequence number MUST be set to 0.",
      "ja": "アソシエーションが確立されると、すべてのストリーム内のストリームシーケンス番号は0から開始しなければなりません。ストリーム・シーケンス番号が値65535に到達したときにも、次のストリームのシーケンス番号が0に設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.24.3. Solution Description",
      "section_title": true,
      "ja": "2.24.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The 'shall' in the text is replaced by a 'MUST' to clearly state the required behavior.",
      "ja": "テキストに必要な行動を明確に述べることを「MUST」に置き換えられて「もの」。"
    },
    {
      "indent": 0,
      "text": "2.25. SACK Packet Format",
      "section_title": true,
      "ja": "2.25。 SACKパケットフォーマット"
    },
    {
      "indent": 0,
      "text": "2.25.1. Description of the Problem",
      "section_title": true,
      "ja": "2.25.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "It is not clear in RFC 2960 whether a SACK must contain the fields Number of Gap Ack Blocks and Number of Duplicate TSNs.",
      "ja": "SACKはギャップAckブロックと重複したTSNの数のフィールドの数を含んでいなければならないかどうかは、RFC 2960で明確ではありません。"
    },
    {
      "indent": 0,
      "text": "2.25.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.25.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.4)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The SACK MUST contain the Cumulative TSN Ack and Advertised Receiver Window Credit (a_rwnd) parameters.",
      "ja": "SACKは累積TSN ACKおよびアドバタイズ受信ウィンドウクレジット（a_rwnd）パラメータを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.4)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The SACK MUST contain the Cumulative TSN Ack, Advertised Receiver Window Credit (a_rwnd), Number of Gap Ack Blocks, and Number of Duplicate TSNs fields.",
      "ja": "SACKが累積TSN Ackを、アドバタイズレシーバーウィンドウクレジット（a_rwnd）、ギャップAckブロックの数、および重複のTSNフィールドの数を含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.25.3. Solution Description",
      "section_title": true,
      "ja": "2.25.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The text has been modified. It is now clear that a SACK always contains the fields Number of Gap Ack Blocks and Number of Duplicate TSNs.",
      "ja": "テキストが変更されました。 SACKは常にフィールドギャップAckブロックの数と重複したTSNの数が含まれていることが明らかです。"
    },
    {
      "indent": 0,
      "text": "2.26. Protocol Violation Error Cause",
      "section_title": true,
      "ja": "2.26。プロトコル違反エラー原因"
    },
    {
      "indent": 0,
      "text": "2.26.1. Description of the Problem",
      "section_title": true,
      "ja": "2.26.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "There are many situations where an SCTP endpoint may detect that its peer violates the protocol. The result of such detection often results in the association being destroyed by the sending of an ABORT. Currently, there are only some error causes that could be used to indicate the reason for the abort, but these do not cover all cases.",
      "ja": "SCTP終点はそのピアがプロトコルに違反することを検出することができる多くの状況があります。そのような検出の結果は、多くの場合、ABORTを送信することによって破壊される関連になります。現在、そこに中止の理由を示すために使用することができる唯一のいくつかのエラーの原因があるが、これらはすべてのケースをカバーしていません。"
    },
    {
      "indent": 0,
      "text": "2.26.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.26.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "Some of the changes given here already include changes suggested in Section 2.6 and 2.21 of this document.",
      "ja": "ここで与えられた変化のいくつかは、すでに2.6節と、この文書の2.21に提案された変更が含まれます。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.10)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Cause Code\nValue           Cause Code\n---------      ----------------\n 1              Invalid Stream Identifier\n 2              Missing Mandatory Parameter\n 3              Stale Cookie Error\n 4              Out of Resource\n 5              Unresolvable Address\n 6              Unrecognized Chunk Type\n 7              Invalid Mandatory Parameter\n 8              Unrecognized Parameters\n 9              No User Data\n10              Cookie Received While Shutting Down",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cause Length: 16 bits (unsigned integer)",
      "ja": "原因長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause-Specific Information fields",
      "ja": "原因コード、原因の長さ、および原因固有の情報フィールドを含むバイト単位でのパラメータの大きさに設定してください"
    },
    {
      "indent": 3,
      "text": "Cause-specific Information: variable length",
      "ja": "原因固有情報：可変長"
    },
    {
      "indent": 6,
      "text": "This field carries the details of the error condition.",
      "ja": "このフィールドには、エラー状態の詳細を運びます。"
    },
    {
      "indent": 3,
      "text": "Sections 3.3.10.1 - 3.3.10.10 define error causes for SCTP. Guidelines for the IETF to define new error cause values are discussed in Section 13.3.",
      "ja": "セクション3.3.10.1  -  3.3.10.10エラーがSCTPの原因を定義します。新しいエラー原因値を定義するために、IETFのためのガイドラインは、13.3節で議論されています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.10)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Cause Code\nValue           Cause Code\n---------      ----------------\n 1              Invalid Stream Identifier\n 2              Missing Mandatory Parameter\n 3              Stale Cookie Error\n 4              Out of Resource\n 5              Unresolvable Address\n 6              Unrecognized Chunk Type\n 7              Invalid Mandatory Parameter\n 8              Unrecognized Parameters\n 9              No User Data\n10              Cookie Received While Shutting Down\n11              Restart of an Association with New Addresses\n12              User Initiated Abort\n13              Protocol Violation",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cause Length: 16 bits (unsigned integer)",
      "ja": "原因長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause-Specific Information fields",
      "ja": "原因コード、原因の長さ、および原因固有の情報フィールドを含むバイト単位でのパラメータの大きさに設定してください"
    },
    {
      "indent": 3,
      "text": "Cause-specific Information: variable length",
      "ja": "原因固有情報：可変長"
    },
    {
      "indent": 6,
      "text": "This field carries the details of the error condition.",
      "ja": "このフィールドには、エラー状態の詳細を運びます。"
    },
    {
      "indent": 3,
      "text": "Sections 3.3.10.1 - 3.3.10.13 define error causes for SCTP. Guidelines for the IETF to define new error cause values are discussed in Section 13.3.",
      "ja": "セクション3.3.10.1  -  3.3.10.13エラーがSCTPの原因を定義します。新しいエラー原因値を定義するために、IETFのためのガイドラインは、13.3節で議論されています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Note: no old text; new error added in section 3.3.10)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3.3.10.13. Protocol Violation (13)",
      "section_title": true,
      "ja": "3.3.10.13。プロトコル違反（13）"
    },
    {
      "indent": 4,
      "text": "Cause of error\n--------------",
      "raw": true
    },
    {
      "indent": 4,
      "text": "This error cause MAY be included in ABORT chunks that are sent because an SCTP endpoint detects a protocol violation of the peer that is not covered by the error causes described in 3.3.10.1 to 3.3.10.12. An implementation MAY provide additional information specifying what kind of protocol violation has been detected.",
      "ja": "このエラーの原因は、SCTP終点は3.3.10.12に3.3.10.1に記載されたエラーの原因によって覆われていないピアのプロトコル違反を検出するために送信されるABORTチャンクに含まれるかもしれ。実装が検出されたプロトコル違反の種類を指定する追加情報を提供することができます。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Cause Code=13         |      Cause Length=Variable    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                    Additional Information                     /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.26.3. Solution Description",
      "section_title": true,
      "ja": "2.26.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "An additional error cause has been defined that can be used by an endpoint to indicate a protocol violation of the peer.",
      "ja": "追加のエラー原因は、ピアのプロトコル違反を示すために、エンドポイントで使用することができるように定義されています。"
    },
    {
      "indent": 0,
      "text": "2.27. Reporting of Unrecognized Parameters",
      "section_title": true,
      "ja": "2.27。認識できないパラメータの報告"
    },
    {
      "indent": 0,
      "text": "2.27.1. Description of the Problem",
      "section_title": true,
      "ja": "2.27.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "It is not stated clearly in RFC 2960 [5] how unrecognized parameters should be reported. Unrecognized parameters in an INIT chunk could be reported in the INIT-ACK chunk or in a separate ERROR chunk, which can get lost. Unrecognized parameters in an INIT-ACK chunk have to be reported in an ERROR-chunk. This can be bundled with the COOKIE-ERROR chunk or sent separately. If it is sent separately and received before the COOKIE-ECHO, it will be handled as an OOTB packet, resulting in sending out an ABORT chunk. Therefore, the association would not be established.",
      "ja": "報告すべきか認識できないパラメータ[5] RFC 2960に明記されていません。 INITチャンクで認識されないパラメータはINIT-ACKチャンクまたは迷子にすることができ、別ERRORチャンクで報告することができます。 INIT-ACKチャンクで認識されないパラメータはERRORチャンクで報告する必要があります。これはCOOKIE-ERRORチャンクにバンドルまたは別々に送信することができます。それは別々に送信され、COOKIE-ECHO前に受信された場合、それはABORTチャンクを送出その結果、OOTBパケットとして処理されます。そのため、関連は確立されません。"
    },
    {
      "indent": 0,
      "text": "2.27.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.27.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "Some of the changes given here already include changes suggested in Section 2.2 of this document.",
      "ja": "ここで与えられた変化のいくつかは、すでにこのドキュメントのセクション2.2で提案された変更が含まれます。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this SCTP packet and discard it, do not process any further chunks within it.",
      "ja": "00  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理しません。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "01  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理し、（ERRORのいずれかまたはINIT ACKで）「認識できないパラメータ型」で認識されていないパラメータを報告しません。"
    },
    {
      "indent": 3,
      "text": "10 - Skip this parameter and continue processing.",
      "ja": "10  - このパラメータをスキップして、処理を続行。"
    },
    {
      "indent": 3,
      "text": "11 - Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "11  - このパラメータをスキップして、処理を続行しますが（ERRORのいずれかまたはINIT ACKで）「認識できないパラメータ型」で認識されていないパラメータを報告しています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this SCTP chunk and discard it; do not process any further parameters within this chunk.",
      "ja": "00  - このSCTPチャンクの処理を停止し、それを捨てます。このチャンク内の任意の他のパラメータを処理しません。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP chunk and discard it, do not process any further parameters within this chunk, and report the unrecognized parameter in an 'Unrecognized Parameter Type', as described in 3.2.2.",
      "ja": "01  - このSCTPチャンクの処理を停止し、それを廃棄し、このチャンク内の任意の他のパラメータを処理し、3.2.2に記載されているように、「認識できないパラメータ型」で認識されていないパラメーターを報告していません。"
    },
    {
      "indent": 3,
      "text": "10 - Skip this parameter and continue processing.",
      "ja": "10  - このパラメータをスキップして、処理を続行。"
    },
    {
      "indent": 3,
      "text": "11 - Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter Type', as described in 3.2.2.",
      "ja": "11  -  3.2.2で説明したように、このパラメータをスキップして、処理を続行しますが「認識できないパラメータ型」で認識されていないパラメータを報告しています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Note: no old text; clarification added in Section 3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3.2.2. Reporting of Unrecognized Parameters",
      "section_title": true,
      "ja": "3.2.2。認識できないパラメータの報告"
    },
    {
      "indent": 6,
      "text": "If the receiver of an INIT chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it MUST put the 'Unrecognized Parameter' parameter(s) in the INIT-ACK chunk sent in response to the INIT-chunk. Note that if the receiver of the INIT chunk is NOT going to establish an association (e.g., due to lack of resources), then no report would be sent back.",
      "ja": "INITチャンクの受信機が認識できないパラメータを検出し、3.2.1項に従ってそれらを報告しなければならない場合、それはINITチャンクへの応答で送信されたINIT-ACKチャンクに「認識できないパラメータ」パラメータ（複数可）を置く必要があります。 INITチャンクの受信機は、（リソース不足のため、例えば）アソシエーションを確立しようとされていない場合、何も報告が返送されないであろうことに注意してください。"
    },
    {
      "indent": 6,
      "text": "If the receiver of an INIT-ACK chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it SHOULD bundle the ERROR chunk containing the 'Unrecognized Parameter' error cause with the COOKIE-ECHO chunk sent in response to the INIT-ACK chunk. If the receiver of the INIT-ACK cannot bundle the COOKIE-ECHO chunk with the ERROR chunk, the ERROR chunk MAY be sent separately but not before the COOKIE-ACK has been received.",
      "ja": "INIT-ACKチャンクの受信機が認識できないパラメータを検出し、3.2.1項に従ってそれらを報告しなければならない場合、それはINITに応答して送信されるCOOKIE-ECHOチャンクと「認識できないパラメータ」エラー原因を含むERRORチャンクをバンドルすべきです-ACKチャンク。 INIT-ACKの受信機はERRORチャンクでCOOKIE-ECHOチャンクをバンドルすることができない場合は、ERRORチャンクはCOOKIE-ACKが受信される前に個別にではなく、送信されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "Note: Any time a COOKIE-ECHO is sent in a packet, it MUST be the first chunk.",
      "ja": "注意：COOKIE-ECHOはパケットで送信されたすべての時間は、それは最初のチャンクでなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.27.3. Solution Description",
      "section_title": true,
      "ja": "2.27.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The procedure of reporting unrecognized parameters has been described clearly.",
      "ja": "認識できないパラメータの報告の手順が明確に記載されています。"
    },
    {
      "indent": 0,
      "text": "2.28. Handling of IP Address Parameters",
      "section_title": true,
      "ja": "2.28。 IPアドレスパラメータの扱い"
    },
    {
      "indent": 0,
      "text": "2.28.1. Description of the Problem",
      "section_title": true,
      "ja": "2.28.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "It is not stated clearly in RFC 2960 [5] how an SCTP endpoint that supports either IPv4 addresses or IPv6 addresses should respond if IPv4 and IPv6 addresses are presented by the peer in the INIT or INIT-ACK chunk.",
      "ja": "これは、IPv4アドレスとIPv6アドレスがINITまたはINIT-ACKチャンクにピアによって提示されている場合は、[5] IPv4アドレスまたはIPv6アドレスのどちらかをサポートしているSCTP終点が対応すべきかRFC 2960に明記されていません。"
    },
    {
      "indent": 0,
      "text": "2.28.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.28.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.1.2)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: In the case that the receiver of an INIT ACK fails to resolve the address parameter due to an unsupported type, it can abort the initiation process and then attempt a re-initiation by using a 'Supported Address Types' parameter in the new INIT to indicate what types of address it prefers.",
      "ja": "実装上の注意：INIT ACKの受信機が原因サポートされていないタイプのアドレスパラメータを解決するために失敗した場合は、開始プロセスを中止することができますし、新しい中に「サポートされているアドレス型」パラメータを使用して、再起動を試みますINITは、それが好むアドレスの種類を示します。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.1.2)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: In the case that the receiver of an INIT ACK fails to resolve the address parameter due to an unsupported type, it can abort the initiation process and then attempt a re-initiation by using a 'Supported Address Types' parameter in the new INIT to indicate what types of address it prefers.",
      "ja": "実装上の注意：INIT ACKの受信機が原因サポートされていないタイプのアドレスパラメータを解決するために失敗した場合は、開始プロセスを中止することができますし、新しい中に「サポートされているアドレス型」パラメータを使用して、再起動を試みますINITは、それが好むアドレスの種類を示します。"
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: If an SCTP endpoint that only supports either IPv4 or IPv6 receives IPv4 and IPv6 addresses in an INIT or INIT-ACK chunk from its peer, it MUST use all the addresses belonging to the supported address family. The other addresses MAY be ignored. The endpoint SHOULD NOT respond with any kind of error indication.",
      "ja": "実装上の注意：のみIPv4またはIPv6のいずれかをサポートしているSCTP終点はそのピアからのINITまたはINIT-ACKチャンクでIPv4アドレスとIPv6アドレスを受信した場合、それがサポートされるアドレスファミリに属する​​すべてのアドレスを使用しなければなりません。他のアドレスは無視してもよいです。エンドポイントは、エラー表示のいずれかの種類に応答すべきでありません。"
    },
    {
      "indent": 0,
      "text": "2.28.3. Solution Description",
      "section_title": true,
      "ja": "2.28.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The procedure of handling IP address parameters has been described clearly.",
      "ja": "IPアドレスパラメータを処理する手順が明確に記載されています。"
    },
    {
      "indent": 0,
      "text": "2.29. Handling of COOKIE ECHO Chunks When a TCB Exists",
      "section_title": true,
      "ja": "2.29。 TCBが存在する場合にCOOKIE ECHOチャンクの取り扱い"
    },
    {
      "indent": 0,
      "text": "2.29.1. Description of the Problem",
      "section_title": true,
      "ja": "2.29.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The description of the behavior in RFC 2960 [5] when a COOKIE ECHO chunk and a TCB exist could be misunderstood. When a COOKIE ECHO is received, a TCB exists and the local tag and peer's tag match, it is stated that the endpoint should enter the ESTABLISHED state if it has not already done so and send a COOKIE ACK. It was not clear that, in the case the endpoint has already left the ESTABLISHED state again, then it should not go back to established. In case D, the endpoint can only enter state ESTABLISHED from COOKIE-ECHOED because in state CLOSED it has no TCB and in state COOKIE-WAIT it has a TCB but knows nothing about the peer's tag, which is requested to match in this case.",
      "ja": "RFC 2960での動作の説明[5] COOKIE ECHOチャンクとTCBが存在誤解することができます。 COOKIE ECHOを受信した場合、TCBが存在していて、ローカルタグとピアのタグが一致し、まだ行っおよびCOOKIE A​​CKを送信していない場合、エンドポイントがESTABLISHED状態に入るべきであると述べています。エンドポイントがすでに再びESTABLISHED状態を残している場合には、それが戻っ確立に行くべきではない、ということは明らかではなかったです。 Dの場合には、エンドポイントがためだけの状態でCOOKIE-ECHOEDからESTABLISHED状態に入ることができ、それは何のTCBを持っていないし、状態にCOOKIE-WAIT、それはTCBを持っているが、この場合には一致するように要求されたピアのタグについて何も知らないCLOSED。"
    },
    {
      "indent": 0,
      "text": "2.29.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.29.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.2.4)\n---------\n   D) When both local and remote tags match the endpoint should\n      always enter the ESTABLISHED state, if it has not already\n      done so.  It should stop any init or cookie timers that may\n      be running and send a COOKIE ACK.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.2.4)\n---------\n   D) When both local and remote tags match, the endpoint should\n      enter the ESTABLISHED state, if it is in the COOKIE-ECHOED\n      state.  It should stop any cookie timer that may\n      be running and send a COOKIE ACK.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.29.3. Solution Description",
      "section_title": true,
      "ja": "2.29.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The procedure of handling of COOKIE-ECHO chunks when a TCB exists has been described clearly.",
      "ja": "TCBが存在するCOOKIE-ECHOチャンクの処理の手順が明確に記載されています。"
    },
    {
      "indent": 0,
      "text": "2.30. The Initial Congestion Window Size",
      "section_title": true,
      "ja": "2.30。初期の輻輳ウィンドウサイズ"
    },
    {
      "indent": 0,
      "text": "2.30.1. Description of the Problem",
      "section_title": true,
      "ja": "2.30.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "RFC 2960 was published with the intention of having the same congestion control properties as TCP. Since the publication of RFC 2960, TCP's initial congestion window size has been increased via RFC 3390. This same update will be needed for SCTP to keep SCTP's congestion control properties equivalent to that of TCP.",
      "ja": "RFC 2960は、TCPと同じ輻輳制御特性を有することを意図して出版されました。 RFC 2960の出版以来、TCPの輻輳ウィンドウの初期サイズは、これと同じアップデートはTCPと同等のSCTPの輻輳制御の特性を維持するためにSCTPのために必要とされるであろうRFC 3390を経由して増加しています。"
    },
    {
      "indent": 0,
      "text": "2.30.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.30.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.1)\n---------\n   o  The initial cwnd before DATA transmission or after a\n      sufficiently long idle period MUST be <= 2*MTU.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.1)\n---------\n   o  The initial cwnd before DATA transmission or after a\n      sufficiently long idle period MUST be set to\n      min(4*MTU, max (2*MTU, 4380 bytes)).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.1)\n---------\n   o  When the endpoint does not transmit data on a given transport\n      address, the cwnd of the transport address should be adjusted\n      to max(cwnd/2, 2*MTU) per RTO.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.1)\n---------\n   o  When the endpoint does not transmit data on a given transport\n      address, the cwnd of the transport address should be adjusted\n      to max(cwnd/2, 4*MTU) per RTO.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.2)\n---------\n   o  Same as in the slow start, when the sender does not transmit\n      DATA on a given transport address, the cwnd of the transport\n      address should be adjusted to max(cwnd / 2, 2*MTU) per RTO.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.2)\n---------\n   o  Same as in the slow start, when the sender does not transmit\n      DATA on a given transport address, the cwnd of the transport\n      address should be adjusted to max(cwnd / 2, 4*MTU) per RTO.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7.2.3. Congestion Control",
      "section_title": true,
      "ja": "7.2.3。輻輳制御"
    },
    {
      "indent": 6,
      "text": "Upon detection of packet losses from SACK (see Section 7.2.4), an endpoint should do the following:",
      "ja": "SACKからパケットロスを検出すると（第7.2.4項を参照）、エンドポイントは、以下の操作を行う必要があります。"
    },
    {
      "indent": 9,
      "text": "ssthresh = max(cwnd/2, 2*MTU) cwnd = ssthresh",
      "ja": "SSTHRESH = MAX（CWND / 2、2 * MTU）CWND = SSTHRESH"
    },
    {
      "indent": 6,
      "text": "Basically, a packet loss causes cwnd to be cut in half.",
      "ja": "基本的には、パケット損失がcwndを半分にカットされます。"
    },
    {
      "indent": 6,
      "text": "When the T3-rtx timer expires on an address, SCTP should perform slow start by",
      "ja": "T3-RTXタイマーがアドレスに期限が切れると、SCTPはでスロースタートを実行する必要があります"
    },
    {
      "indent": 9,
      "text": "ssthresh = max(cwnd/2, 2*MTU) cwnd = 1*MTU",
      "ja": "SSTHRESH = MAX（CWND / 2、2 * MTU）CWND = 1 * MTU"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.3)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7.2.3 Congestion Control",
      "section_title": true,
      "ja": "7.2.3輻輳制御"
    },
    {
      "indent": 6,
      "text": "Upon detection of packet losses from SACK (see Section 7.2.4), An endpoint should do the following:",
      "ja": "SACKからパケットロスを検出すると（第7.2.4項を参照）、エンドポイントは、以下の操作を行う必要があります。"
    },
    {
      "indent": 9,
      "text": "ssthresh = max(cwnd/2, 4*MTU) cwnd = ssthresh",
      "ja": "SSTHRESH = MAX（CWND / 2、4 * MTU）CWND = SSTHRESH"
    },
    {
      "indent": 6,
      "text": "Basically, a packet loss causes cwnd to be cut in half.",
      "ja": "基本的には、パケット損失がcwndを半分にカットされます。"
    },
    {
      "indent": 6,
      "text": "When the T3-rtx timer expires on an address, SCTP should perform slow start by:",
      "ja": "T3-RTXタイマーがアドレスに期限が切れると、SCTPはでスロースタートを実行する必要があります。"
    },
    {
      "indent": 9,
      "text": "ssthresh = max(cwnd/2, 4*MTU) cwnd = 1*MTU",
      "ja": "SSTHRESH = MAX（CWND / 2、4 * MTU）CWND = 1 * MTU"
    },
    {
      "indent": 0,
      "text": "2.30.3. Solution Description",
      "section_title": true,
      "ja": "2.30.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The change to SCTP's initial congestion window will allow it to continue to maintain the same congestion control properties as TCP.",
      "ja": "SCTPの初期の輻輳ウィンドウへの変更は、それはTCPと同じ輻輳制御特性を維持し続けることができるようになります。"
    },
    {
      "indent": 0,
      "text": "2.31. Stream Sequence Numbers in Figures",
      "section_title": true,
      "ja": "2.31。図中のストリームシーケンス番号"
    },
    {
      "indent": 0,
      "text": "2.31.1. Description of the Problem",
      "section_title": true,
      "ja": "2.31.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "In Section 2.24 of this document, it is clarified that the SSN are initialized with 0. Two figures in RFC 2960 [5] illustrate that they start with 1.",
      "ja": "このドキュメントのセクション2.24には、[5]、彼らは1で始まることを示すSSNは、RFC 2960で0二つの図で初期化されていることが明らかにされています。"
    },
    {
      "indent": 0,
      "text": "2.31.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.31.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": " Endpoint A                                          Endpoint Z\n {app sets association with Z}\n (build TCB)\n INIT [I-Tag=Tag_A\n       & other info]  ------\\\n (Start T1-init timer)       \\\n (Enter COOKIE-WAIT state)    \\---> (compose temp TCB and Cookie_Z)\n                                /-- INIT ACK [Veri Tag=Tag_A,\n                               /             I-Tag=Tag_Z,\n (Cancel T1-init timer) <-----/               Cookie_Z, & other info]\n                                        (destroy temp TCB)\n COOKIE ECHO [Cookie_Z] ------\\\n (Start T1-init timer)         \\\n (Enter COOKIE-ECHOED state)    \\---> (build TCB enter ESTABLISHED\n                                       state)\n                                /---- COOKIE-ACK\n                               /\n (Cancel T1-init timer, <-----/\n  Enter ESTABLISHED state)\n {app sends 1st user data; strm 0}\n  DATA [TSN=initial TSN_A\n      Strm=0,Seq=1 & user data]--\\\n  (Start T3-rtx timer)            \\\n                                   \\->\n                               /----- SACK [TSN Ack=init\n                              /              TSN_A,Block=0]\n(Cancel T3-rtx timer) <------/\n                                       ...\n                                       {app sends 2 messages;strm 0}\n                                 /---- DATA\n                                /        [TSN=init TSN_Z\n                            <--/          Strm=0,Seq=1 & user data 1]\nSACK [TSN Ack=init TSN_Z,     /    ---- DATA\n         Block=0]     --------\\  /        [TSN=init TSN_Z +1,\n                               \\/         Strm=0,Seq=2 & user data 2]\n                        <------/\\\n                                 \\\n                                  \\------>",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 4: INITiation Example",
      "ja": "図4：開始例"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 7.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Endpoint A                                          Endpoint Z\n{app sets association with Z}\n(build TCB)\nINIT [I-Tag=Tag_A\n      & other info]  ------\\\n(Start T1-init timer)       \\\n(Enter COOKIE-WAIT state)    \\---> (compose temp TCB and Cookie_Z)\n                                /-- INIT ACK [Veri Tag=Tag_A,\n                               /             I-Tag=Tag_Z,\n(Cancel T1-init timer) <------/              Cookie_Z, & other info]\n                                     (destroy temp TCB)\nCOOKIE ECHO [Cookie_Z] ------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-ECHOED state)    \\---> (build TCB enter ESTABLISHED\n                                      state)\n                               /---- COOKIE-ACK\n                              /\n(Cancel T1-init timer, <-----/\n Enter ESTABLISHED state)\n{app sends 1st user data; strm 0}\nDATA [TSN=initial TSN_A\n    Strm=0,Seq=0 & user data]--\\\n(Start T3-rtx timer)            \\\n                                 \\->\n                               /----- SACK [TSN Ack=init\n                              /           TSN_A,Block=0]\n(Cancel T3-rtx timer) <------/\n                                      ...\n                                     {app sends 2 messages;strm 0}\n                               /---- DATA\n                              /        [TSN=init TSN_Z\n                          <--/          Strm=0,Seq=0 & user data 1]\nSACK [TSN Ack=init TSN_Z,      /---- DATA\n      Block=0]     --------\\  /        [TSN=init TSN_Z +1,\n                            \\/          Strm=0,Seq=1 & user data 2]\n                     <------/\\\n                              \\\n                               \\------>",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 4: INITiation Example",
      "ja": "図4：開始例"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.2.4.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Endpoint A                                          Endpoint Z\n<------------ Association is established---------------------->\nTag=Tag_A                                             Tag=Tag_Z\n<------------------------------------------------------------->\n{A crashes and restarts}\n{app sets up a association with Z}\n(build TCB)\nINIT [I-Tag=Tag_A'\n      & other info]  --------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-WAIT state)      \\---> (find a existing TCB\n                                      compose temp TCB and Cookie_Z\n                                      with Tie-Tags to previous\n                                      association)\n                                /--- INIT ACK [Veri Tag=Tag_A',\n                               /               I-Tag=Tag_Z',\n(Cancel T1-init timer) <------/                Cookie_Z[TieTags=\n                                               Tag_A,Tag_Z\n                                                & other info]\n                                     (destroy temp TCB,leave original\n                                      in place)\nCOOKIE ECHO [Veri=Tag_Z',\n             Cookie_Z\n             Tie=Tag_A,\n             Tag_Z]----------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-ECHOED state)    \\---> (Find existing association,\n                                      Tie-Tags match old tags,\n                                      Tags do not match i.e.,\n                                      case X X M M above,\n                                      Announce Restart to ULP\n                                      and reset association).\n                               /---- COOKIE-ACK\n(Cancel T1-init timer, <------/\n Enter ESTABLISHED state)\n{app sends 1st user data; strm 0}\nDATA [TSN=initial TSN_A\n    Strm=0,Seq=1 & user data]--\\\n(Start T3-rtx timer)            \\\n                                 \\->\n                              /--- SACK [TSN Ack=init TSN_A,Block=0]\n(Cancel T3-rtx timer) <------/",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 5: A Restart Example",
      "ja": "図5：再起動例"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.2.4.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Endpoint A                                          Endpoint Z\n<-------------- Association is established---------------------->\nTag=Tag_A                                             Tag=Tag_Z\n<--------------------------------------------------------------->\n{A crashes and restarts}\n{app sets up a association with Z}\n(build TCB)\nINIT [I-Tag=Tag_A'\n      & other info]  --------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-WAIT state)      \\---> (find a existing TCB\n                                      compose temp TCB and Cookie_Z\n                                      with Tie-Tags to previous\n                                      association)\n                                /--- INIT ACK [Veri Tag=Tag_A',\n                               /               I-Tag=Tag_Z',\n(Cancel T1-init timer) <------/                Cookie_Z[TieTags=\n                                               Tag_A,Tag_Z\n                                                & other info]\n                                     (destroy temp TCB,leave original\n                                      in place)\nCOOKIE ECHO [Veri=Tag_Z',\n             Cookie_Z\n             Tie=Tag_A,\n             Tag_Z]----------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-ECHOED state)    \\---> (Find existing association,\n                                      Tie-Tags match old tags,\n                                      Tags do not match i.e.,\n                                      case X X M M above,\n                                      Announce Restart to ULP\n                                      and reset association).\n                               /---- COOKIE-ACK\n(Cancel T1-init timer, <------/\n Enter ESTABLISHED state)\n{app sends 1st user data; strm 0}\nDATA [TSN=initial TSN_A\n    Strm=0,Seq=0 & user data]--\\\n(Start T3-rtx timer)            \\\n                                 \\->\n                              /--- SACK [TSN Ack=init TSN_A,Block=0]\n(Cancel T3-rtx timer) <------/",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 5: A Restart Example",
      "ja": "図5：再起動例"
    },
    {
      "indent": 0,
      "text": "2.31.3. Solution description",
      "section_title": true,
      "ja": "2.31.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "Figure 4 and 5 were changed so that the SSN starts with 0 instead of 1.",
      "ja": "SSNは、0の代わりに1で開始するように、図4および図5は、変更されました。"
    },
    {
      "indent": 0,
      "text": "2.32. Unrecognized Parameters",
      "section_title": true,
      "ja": "2.32。認識できないパラメータ"
    },
    {
      "indent": 0,
      "text": "2.32.1. Description of the Problem",
      "section_title": true,
      "ja": "2.32.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The RFC does not state clearly in Section 3.3.3.1 whether one or multiple unrecognized parameters are included in the 'Unrecognized Parameter' parameter.",
      "ja": "RFCは、一つまたは複数の認識できないパラメータは「認識できないパラメータ」パラメータに含まれているかどうかのセクション3.3.3.1に明記されません。"
    },
    {
      "indent": 0,
      "text": "2.32.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.32.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.3)\n---------\n      Variable Parameters                  Status     Type Value\n      -------------------------------------------------------------\n      State Cookie                        Mandatory   7\n      IPv4 Address (Note 1)               Optional    5\n      IPv6 Address (Note 1)               Optional    6\n      Unrecognized Parameters             Optional    8\n      Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)\n      Host Name Address (Note 3)          Optional    11",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.3)\n---------\n      Variable Parameters                  Status     Type Value\n      -------------------------------------------------------------\n      State Cookie                        Mandatory   7\n      IPv4 Address (Note 1)               Optional    5\n      IPv6 Address (Note 1)               Optional    6\n      Unrecognized Parameter              Optional    8\n      Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)\n      Host Name Address (Note 3)          Optional    11",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.3.1)\n---------\n   Unrecognized Parameters:",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Parameter Type Value: 8",
      "ja": "パラメータタイプ値：8"
    },
    {
      "indent": 9,
      "text": "Parameter Length: Variable Size.",
      "ja": "パラメータの長さ：可変サイズ。"
    },
    {
      "indent": 9,
      "text": "Parameter Value: This parameter is returned to the originator of the INIT chunk when the INIT contains an unrecognized parameter which has a value that indicates that it should be reported to the sender. This parameter value field will contain unrecognized parameters copied from the INIT chunk complete with Parameter Type, Length and Value fields.",
      "ja": "パラメータ値：INITは、それが送信者に報告する必要があることを示す値を持っている認識されていないパラメータが含まれている場合は、このパラメータはINITチャンクの元に返されます。このパラメータの値フィールドは、パラメータタイプ、長さおよび値フィールドを持つ完全なINITチャンクからコピーされた認識できないパラメータが含まれています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.3.1)\n---------\n   Unrecognized Parameter:",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Parameter Type Value: 8",
      "ja": "パラメータタイプ値：8"
    },
    {
      "indent": 9,
      "text": "Parameter Length: Variable Size.",
      "ja": "パラメータの長さ：可変サイズ。"
    },
    {
      "indent": 9,
      "text": "Parameter Value:",
      "ja": "パラメータ値："
    },
    {
      "indent": 12,
      "text": "This parameter is returned to the originator of the INIT chunk when the INIT contains an unrecognized parameter that has a value that indicates that it should be reported to the sender. This parameter value field will contain the unrecognized parameter copied from the INIT chunk complete with Parameter Type, Length, and Value fields.",
      "ja": "INITは、それが送信者に報告する必要があることを示す値を持っている認識されていないパラメータが含まれている場合、このパラメータはINITチャンクの元に返されます。このパラメータの値フィールドは、パラメータタイプ、長さ、および値のフィールドを持つ完全なINITチャンクからコピーされ、認識されないパラメータが含まれています。"
    },
    {
      "indent": 0,
      "text": "2.32.3. Solution Description",
      "section_title": true,
      "ja": "2.32.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text states clearly that only one unrecognized parameter is reported per parameter.",
      "ja": "新しいテキストは一つだけ認識されないパラメータは、パラメータごとに報告されていることを明確に述べています。"
    },
    {
      "indent": 0,
      "text": "2.33. Handling of Unrecognized Parameters",
      "section_title": true,
      "ja": "2.33。認識できないパラメータの取り扱い"
    },
    {
      "indent": 0,
      "text": "2.33.1. Description of the Problem",
      "section_title": true,
      "ja": "2.33.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "It is not stated clearly in RFC 2960 [5] how unrecognized parameters should be handled. The problem comes up when an INIT contains an unrecognized parameter with highest bits 00. It was not clear whether an INIT-ACK should be sent.",
      "ja": "これは、[5]どのように処理すべきか認識できないパラメータRFC 2960に明記されていません。 INITは、最高ビット00で認識されていないパラメータが含まれているときに問題が立ち上がることはINIT-ACKを送信するかどうかは明らかではなかったです。"
    },
    {
      "indent": 0,
      "text": "2.33.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.33.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "Some of the changes given here already include changes suggested in Section 2.27 of this document.",
      "ja": "ここで与えられた変化のいくつかは、すでにこのドキュメントのセクション2.27に提案された変更が含まれます。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this SCTP packet and discard it, do not process any further chunks within it.",
      "ja": "00  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理しません。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "01  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理し、（ERRORのいずれかまたはINIT ACKで）「認識できないパラメータ型」で認識されていないパラメータを報告しません。"
    },
    {
      "indent": 3,
      "text": "10 - Skip this parameter and continue processing.",
      "ja": "10  - このパラメータをスキップして、処理を続行。"
    },
    {
      "indent": 3,
      "text": "11 - Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "11  - このパラメータをスキップして、処理を続行しますが（ERRORのいずれかまたはINIT ACKで）「認識できないパラメータ型」で認識されていないパラメータを報告しています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this parameter; do not process any further parameters within this chunk.",
      "ja": "00  - このパラメータの処理を停止。このチャンク内の任意の他のパラメータを処理しません。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this parameter, do not process any further parameters within this chunk, and report the unrecognized parameter in an 'Unrecognized Parameter Type', as described in 3.2.2.",
      "ja": "01  - このチャンク内の任意の他のパラメータを処理していない、このパラメータの処理を停止し、3.2.2に記載されているように、「認識できないパラメータ型」で認識されていないパラメータを報告します。"
    },
    {
      "indent": 3,
      "text": "10 - Skip this parameter and continue processing.",
      "ja": "10  - このパラメータをスキップして、処理を続行。"
    },
    {
      "indent": 3,
      "text": "11 - Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter Type', as described in 3.2.2.",
      "ja": "11  -  3.2.2で説明したように、このパラメータをスキップして、処理を続行しますが「認識できないパラメータ型」で認識されていないパラメータを報告しています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Note: no old text; clarification added in section 3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3.2.2. Reporting of Unrecognized Parameters",
      "section_title": true,
      "ja": "3.2.2。認識できないパラメータの報告"
    },
    {
      "indent": 3,
      "text": "If the receiver of an INIT chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it MUST put the 'Unrecognized Parameter' parameter(s) in the INIT-ACK chunk sent in response to the INIT-chunk. Note that if the receiver of the INIT chunk is NOT going to establish an association (e.g., due to lack of resources), an 'Unrecognized Parameter' would NOT be included with any ABORT being sent to the sender of the INIT.",
      "ja": "INITチャンクの受信機が認識できないパラメータを検出し、3.2.1項に従ってそれらを報告しなければならない場合、それはINITチャンクへの応答で送信されたINIT-ACKチャンクに「認識できないパラメータ」パラメータ（複数可）を置く必要があります。 INITチャンクの受信機は、（リソース不足のため、例えば）アソシエーションを確立しようとされていない場合は任意のABORTがINITの送信者に送信された状態で、「認識できないパラメータが」含まれないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the receiver of an INIT-ACK chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it SHOULD bundle the ERROR chunk containing the 'Unrecognized Parameter' error cause with the COOKIE-ECHO chunk sent in response to the INIT-ACK chunk. If the receiver of the INIT-ACK cannot bundle the COOKIE-ECHO chunk with the ERROR chunk, the ERROR chunk MAY be sent separately but not before the COOKIE-ACK has been received.",
      "ja": "INIT-ACKチャンクの受信機が認識できないパラメータを検出し、3.2.1項に従ってそれらを報告しなければならない場合、それはINITに応答して送信されるCOOKIE-ECHOチャンクと「認識できないパラメータ」エラー原因を含むERRORチャンクをバンドルすべきです-ACKチャンク。 INIT-ACKの受信機はERRORチャンクでCOOKIE-ECHOチャンクをバンドルすることができない場合は、ERRORチャンクはCOOKIE-ACKが受信される前に個別にではなく、送信されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Note: Any time a COOKIE-ECHO is sent in a packet, it MUST be the first chunk.",
      "ja": "注意：COOKIE-ECHOはパケットで送信されたすべての時間は、それは最初のチャンクでなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.33.3. Solution Description",
      "section_title": true,
      "ja": "2.33.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The procedure of handling unrecognized parameters has been described clearly.",
      "ja": "認識できないパラメータを処理する手順が明確に記載されています。"
    },
    {
      "indent": 0,
      "text": "2.34. Tie Tags",
      "section_title": true,
      "ja": "2.34。タイのタグ"
    },
    {
      "indent": 0,
      "text": "2.34.1. Description of the Problem",
      "section_title": true,
      "ja": "2.34.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "RFC 2960 requires that Tie-Tags be included in the COOKIE. The cookie may not be encrypted. An attacker could discover the value of the Verification Tags by analyzing cookies received after sending an INIT.",
      "ja": "RFC 2960には、タイのタグがCOOKIEに含まれている必要があります。クッキーは暗号化されないことがあります。攻撃者は、INITを送信した後に受け取ったクッキーを解析することにより、検証タグの値を発見することができます。"
    },
    {
      "indent": 0,
      "text": "2.34.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.34.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 1.4)\n---------\n   o  Tie-Tags: Verification Tags from a previous association.  These\n      Tags are used within a State Cookie so that the newly\n      restarting association can be linked to the original\n      association within the endpoint that did not restart.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 1.4)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "o Tie-Tags: Two 32-bit random numbers that together make a 64- bit nonce. These Tags are used within a State Cookie and TCB so that a newly restarting association can be linked to the original association within the endpoint that did not restart and yet not reveal the true Verification Tags of an existing association.",
      "ja": "Oタイタグ：一緒に64ビットのnonceを作る2つの32ビットの乱数。新しく再開会合が再起動しないと、まだ既存の関連付けの真の検証タグを明らかにしなかったエンドポイント内の元組合にリンクすることができるように、これらのタグは、州CookieとTCB内で使用されています。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "For an endpoint that is in the COOKIE-ECHOED state it MUST populate its Tie-Tags with the Tag information of itself and its peer (see Section 5.2.2 for a description of the Tie-Tags).",
      "ja": "それはそれ自体とそのピアのタグ情報とのタイタグを移入する必要がありCOOKIE-ECHOED状態にあるエンドポイント（TIE-タグの説明については、セクション5.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.2.1)\n---------\n   For an endpoint that is in the COOKIE-ECHOED state it MUST\n   populate its Tie-Tags within both the association TCB and\n   inside the State Cookie (see section 5.2.2 for a description\n   of the Tie-Tags).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.2.2)\n---------\n   Unless otherwise stated, upon reception of an unexpected INIT for\n   this association, the endpoint shall generate an INIT ACK with a\n   State Cookie.  In the outbound INIT ACK the endpoint MUST copy its\n   current Verification Tag and peer's Verification Tag into a\n   reserved place within the state cookie.  We shall refer to these\n   locations as the Peer's-Tie-Tag and the Local-Tie-Tag.  The\n   outbound SCTP packet containing this INIT ACK MUST carry a\n   Verification Tag value equal to the Initiation Tag found in the\n   unexpected INIT.  And the INIT ACK MUST contain a new Initiation\n   Tag (randomly generated see Section 5.3.1).  Other parameters\n   for the endpoint SHOULD be copied from the existing parameters\n   of the association (e.g., number of outbound streams) into the\n   INIT ACK and cookie.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.2.2)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Unless otherwise stated, upon receipt of an unexpected INIT for this association, the endpoint MUST generate an INIT ACK with a State Cookie. In the outbound INIT ACK, the endpoint MUST copy its current Tie-Tags to a reserved place within the State Cookie and the association's TCB. We shall refer to these locations inside the cookie as the Peer's-Tie-Tag and the Local-Tie-Tag. We will refer to the copy within an association's TCB as the Local Tag and Peer's Tag. The outbound SCTP packet containing this INIT ACK MUST carry a Verification Tag value equal to the Initiation Tag found in the unexpected INIT. And the INIT ACK MUST contain a new Initiation Tag (randomly generated; see Section 5.3.1). Other parameters for the endpoint SHOULD be copied from the existing parameters of the association (e.g., number of outbound streams) into the INIT ACK and cookie.",
      "ja": "特に明記しない限り、この関連付けのための予想外のINITの受信時に、エンドポイントは、国家クッキーとINIT ACKを発生させなければなりません。アウトバウンドのINIT ACKでは、エンドポイントは、州Cookieと協会のTCB内の予約済みの場所に現在のタイのタグをコピーしなければなりません。我々はPeer's-タイタグとローカル・タイタグとしてクッキー内のこれらの場所を指すものとします。私たちは、ローカルタグとピアのタグとして協会のTCB内のコピーを参照します。このINIT ACKを含むアウトバウンドSCTPパケットは、予期せぬINITで見つかった開始タグに等しい検証タグ値を運ばなければなりません。そして、INIT ACKは、新しい開始タグが含まれなければならない（ランダムに生成し、5.3.1項を参照してください）。エンドポイントの他のパラメータはINIT ACKとクッキーに関連（例えば、アウトバウンドストリーム数）の既存のパラメータからコピーする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.34.3. Solution Description",
      "section_title": true,
      "ja": "2.34.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The solution to this problem is not to use the real Verification Tags within the State Cookie as tie-tags. Instead, two 32-bit random numbers are created to form one 64-bit nonce and stored both in the State Cookie and the existing association TCB. This prevents exposing the Verification Tags inadvertently.",
      "ja": "この問題を解決するには、タイタグとして国家クッキーの中に実際の検証タグを使用することではありません。代わりに、2つの32ビットの乱数を1つの64ビットのノンスを形成するために作成され、州Cookieと既存のアソシエーションTCBの両方に格納されています。これは、不注意検証タグを露出させないようにします。"
    },
    {
      "indent": 0,
      "text": "2.35. Port Number Verification in the COOKIE-ECHO",
      "section_title": true,
      "ja": "2.35。 COOKIE-ECHOでのポート番号の検証"
    },
    {
      "indent": 0,
      "text": "2.35.1. Description of the Problem",
      "section_title": true,
      "ja": "2.35.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The State Cookie sent by a listening SCTP endpoint may not contain the original port numbers or the local Verification Tag. It is then possible that the endpoint, on receipt of the COOKIE-ECHO, will not be able to verify that these values match the original values found in the INIT and INIT-ACK that began the association setup.",
      "ja": "リスニングのSCTP終点によって送られた状態クッキーは、元のポート番号またはローカル検証タグを含めることはできません。エンドポイントは、COOKIE-ECHOの領収書に、これらの値は、関連のセットアップを開始しましたINITとINIT-ACKで見つかった元の値と一致していることを確認することができなくなることが可能です。"
    },
    {
      "indent": 0,
      "text": "2.35.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.35.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.1.5)\n---------\n   3) Compare the creation timestamp in the State Cookie to the\n      current local time.  If the elapsed time is longer than the\n      lifespan carried in the State Cookie, then the packet,\n      including the COOKIE ECHO and any attached DATA chunks,\n      SHOULD be discarded and the endpoint MUST transmit an ERROR\n      chunk with a \"Stale Cookie\" error cause to the peer endpoint,",
      "raw": true
    },
    {
      "indent": 6,
      "text": "4) If the State Cookie is valid, create an association to the sender of the COOKIE ECHO chunk with the information in the TCB data carried in the COOKIE ECHO, and enter the ESTABLISHED state,",
      "ja": "状態クッキーが有効であれば4）、COOKIE ECHOで運ばTCBデータに情報をCOOKIE ECHOチャンクの送信者に関連付けを作成し、および確立された状態を入力し、"
    },
    {
      "indent": 6,
      "text": "5) Send a COOKIE ACK chunk to the peer acknowledging reception of the COOKIE ECHO. The COOKIE ACK MAY be bundled with an outbound DATA chunk or SACK chunk; however, the COOKIE ACK MUST be the first chunk in the SCTP packet.",
      "ja": "5）COOKIE ECHOの受信を肯定応答するピアにCOOKIE A​​CKチャンクを送信します。 COOKIE A​​CKは、アウトバウンドのDATAチャンクまたはSACKチャンクにバンドルすることができ、しかし、COOKIE A​​CKは、SCTPパケット内の最初のチャンクでなければなりません。"
    },
    {
      "indent": 6,
      "text": "6) Immediately acknowledge any DATA chunk bundled with the COOKIE ECHO with a SACK (subsequent DATA chunk acknowledgement should follow the rules defined in Section 6.2). As mentioned in step",
      "ja": "6）直後（次のデータチャンク応答）はセクション6.2で定義された規則に従うべきであるSACKとCOOKIE ECHOにバンドルされ、任意のデータチャンクを認めます。ステップで述べたように"
    },
    {
      "indent": 9,
      "text": "5), if the SACK is bundled with the COOKIE ACK, the COOKIE ACK MUST appear first in the SCTP packet.",
      "ja": "SACKがCOOKIE A​​CKにバンドルされている場合5）、COOKIE A​​CKはSCTPパケット内の最初に表示されなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.1.5)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "3) Compare the port numbers and the Verification Tag contained within the COOKIE ECHO chunk to the actual port numbers and the Verification Tag within the SCTP common header of the received packet. If these values do not match, the packet MUST be silently discarded.",
      "ja": "3）受信したパケットのSCTP共通ヘッダ内の実際のポート番号と検証タグにCOOKIE ECHOチャンク内に含まれるポート番号と検証タグを比較します。これらの値が一致しない場合、パケットは静かに捨てなければなりません。"
    },
    {
      "indent": 6,
      "text": "4) Compare the creation timestamp in the State Cookie to the current local time. If the elapsed time is longer than the lifespan carried in the State Cookie, then the packet, including the COOKIE ECHO and any attached DATA chunks, SHOULD be discarded, and the endpoint MUST transmit an ERROR chunk with a \"Stale Cookie\" error cause to the peer endpoint.",
      "ja": "4）現在のローカル時刻に状態クッキー内の作成タイムスタンプを比較してください。経過時間が長い状態クッキーに運ば寿命を超える場合は、COOKIE ECHOと接続されているすべてのDATA塊を含むパケットは、廃棄すべき、およびエンドポイントは、「古いクッキー」エラー原因とERRORチャンクを伝えなければなりませんピアエンドポイント。"
    },
    {
      "indent": 6,
      "text": "5) If the State Cookie is valid, create an association to the sender of the COOKIE ECHO chunk with the information in the TCB data carried in the COOKIE ECHO and enter the ESTABLISHED state.",
      "ja": "国家クッキーが有効であれば5）、COOKIE ECHOで運ばTCBデータに情報をCOOKIE ECHOチャンクの送信者に関連付けを作成し、ESTABLISHED状態に入ります。"
    },
    {
      "indent": 6,
      "text": "6) Send a COOKIE ACK chunk to the peer acknowledging receipt of the COOKIE ECHO. The COOKIE ACK MAY be bundled with an outbound DATA chunk or SACK chunk; however, the COOKIE ACK MUST be the first chunk in the SCTP packet.",
      "ja": "6）COOKIE ECHOの受信を確認ピアにCOOKIE A​​CKチャンクを送信します。 COOKIE A​​CKは、アウトバウンドのDATAチャンクまたはSACKチャンクにバンドルすることができ、しかし、COOKIE A​​CKは、SCTPパケット内の最初のチャンクでなければなりません。"
    },
    {
      "indent": 6,
      "text": "7) Immediately acknowledge any DATA chunk bundled with the COOKIE ECHO with a SACK (subsequent DATA chunk acknowledgement should follow the rules defined in Section 6.2). As mentioned in step 5, if the SACK is bundled with the COOKIE ACK, the COOKIE ACK MUST appear first in the SCTP packet.",
      "ja": "7）直後（次のデータチャンク応答）はセクション6.2で定義された規則に従うべきであるSACKとCOOKIE ECHOにバンドルされ、任意のデータチャンクを認めます。ステップ5で述べたようにSACKをCOOKIE A​​CKにバンドルされている場合、COOKIE A​​CKはSCTPパケット内の最初に表示されなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.35.3. Solution Description",
      "section_title": true,
      "ja": "2.35.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "By including both port numbers and the local Verification Tag within the State Cookie and verifying these during COOKIE-ECHO processing, this issue is resolved.",
      "ja": "ポート番号と州クッキー内のローカル検証タグの両方を含むとCOOKIE-ECHO処理中にこれらを検証することにより、この問題は解決されています。"
    },
    {
      "indent": 0,
      "text": "2.36. Path Initialization",
      "section_title": true,
      "ja": "2.36。パスの初期化"
    },
    {
      "indent": 0,
      "text": "2.36.1. Description of the Problem",
      "section_title": true,
      "ja": "2.36.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "When an association enters the ESTABLISHED state, the endpoint has no verification that all of the addresses presented by the peer do in fact belong to the peer. This could cause various forms of denial of service attacks.",
      "ja": "協会がESTABLISHED状態に入ると、エンドポイントは、ピアによって提示されたアドレスのすべてが実際にピアに属しているかという検証を持っていません。これは、サービス拒否攻撃の様々な形態を引き起こす可能性があります。"
    },
    {
      "indent": 0,
      "text": "2.36.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.36.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: None\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.4)\n---------\n5.4.  Path Verification",
      "raw": true
    },
    {
      "indent": 3,
      "text": "During association establishment, the two peers exchange a list of addresses. In the predominant case, these lists accurately represent the addresses owned by each peer. However, it is possible that a misbehaving peer may supply addresses that it does not own. To prevent this, the following rules are applied to all addresses of the new association:",
      "ja": "アソシエーションの確立時には、2つのピアがアドレスのリストを交換します。支配的な場合には、これらのリストは正確に各ピアが所有するアドレスを表します。しかし、ふらちなピアは、それが所有していないアドレスを提供する可能性があります。これを防ぐには、以下のルールが新しいアソシエーションのすべてのアドレスに適用されます。"
    },
    {
      "indent": 3,
      "text": "1) Any address passed to the sender of the INIT by its upper layer is automatically considered to be CONFIRMED.",
      "ja": "1）その上位層によってINITの送信者に渡されたアドレスが自動的に確認されていると考えられます。"
    },
    {
      "indent": 3,
      "text": "2) For the receiver of the COOKIE-ECHO the only CONFIRMED address is the one that the INIT-ACK was sent to.",
      "ja": "2）COOKIE-ECHOの受信機のための唯一の確認された住所は、INIT-ACKが送られたものです。"
    },
    {
      "indent": 3,
      "text": "3) All other addresses not covered by rules 1 and 2 are considered UNCONFIRMED and are subject to probing for verification.",
      "ja": "3）ルール1及び2によって覆われていない他のすべてのアドレス未確認とみなされ、検証のためにプロービングの対象とされています。"
    },
    {
      "indent": 3,
      "text": "To probe an address for verification, an endpoint will send HEARTBEATs including a 64-bit random nonce and a path indicator (to identify the address that the HEARTBEAT is sent to) within the HEARTBEAT parameter.",
      "ja": "検証のためのアドレスを調べるために、エンドポイントはHEARTBEATパラメータ内（HEARTBEATが送られるアドレスを識別するために）64ビットのランダムなノンスとパスインジケータを含むハートビートを送信します。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the HEARTBEAT-ACK, a verification is made that the nonce included in the HEARTBEAT parameter is the one sent to the address indicated inside the HEARTBEAT parameter. When this match occurs, the address that the original HEARTBEAT was sent to is now considered CONFIRMED and available for normal data transfer.",
      "ja": "HEARTBEAT-ACKを受信すると、検証がnonceがHEARTBEATパラメータに含まれると判断されたハートビートパラメータの内部に示されたアドレスに送信されたものです。このマッチが発生すると、オリジナルのHEARTBEATが送られたことをアドレスは、現在確認され、通常のデータ転送のために利用できると考えられています。"
    },
    {
      "indent": 3,
      "text": "These probing procedures are started when an association moves to the ESTABLISHED state and are ended when all paths are confirmed.",
      "ja": "これらの探査手順は、協会がESTABLISHED状態に移行したときに開始され、すべてのパスが確認されたときに終了しています。"
    },
    {
      "indent": 3,
      "text": "Each RTO a probe may be sent on an active UNCONFIRMED path in an attempt to move it to the CONFIRMED state. If during this probing the path becomes inactive, this rate is lowered to the normal HEARTBEAT rate. At the expiration of the RTO timer, the error counter of any path that was probed but not CONFIRMED is incremented by one and subjected to path failure detection, as defined in section 8.2. When probing UNCONFIRMED addresses, however, the association overall error count is NOT incremented.",
      "ja": "各RTOは、プローブが確認状態に移動しようとして活性UNCONFIRMED経路上で送信することができます。この時のパスを探査することは非アクティブになると、このレートは、通常の心拍数に低下させます。セクション8.2で定義されるように、RTOタイマの満了時に、プローブが、確認されなかった任意のパスのエラーカウンタを1つインクリメントされ、パス障害検出を行いました。 UNCONFIRMEDアドレスをプロービングすると、しかし、協会全体のエラーカウントがインクリメントされていません。"
    },
    {
      "indent": 3,
      "text": "The number of HEARTBEATS sent at each RTO SHOULD be limited by the HB.Max.Burst parameter. It is an implementation decision as to how to distribute HEARTBEATS to the peer's addresses for path verification.",
      "ja": "各RTOで送信心拍数はHB.Max.Burstパラメータによって制限されるべきです。これは、パス検証のためのピアのアドレスにハートビートを配布する方法のような実装決定です。"
    },
    {
      "indent": 3,
      "text": "Whenever a path is confirmed, an indication MAY be given to the upper layer.",
      "ja": "パスが確認されるたびに、表示は上位層に与えてもよいです。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST NOT send any chunks to an UNCONFIRMED address, with the following exceptions:",
      "ja": "エンドポイントは、以下の例外を除いて、UNCONFIRMEDアドレスに任意の塊を送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "- A HEARTBEAT including a nonce MAY be sent to an UNCONFIRMED address.",
      "ja": " -  nonceを含むHEARTBEATをUNCONFIRMEDアドレスに送ってもよいです。"
    },
    {
      "indent": 3,
      "text": "- A HEARTBEAT-ACK MAY be sent to an UNCONFIRMED address.",
      "ja": " -  HEARTBEAT-ACKはUNCONFIRMEDアドレスに送ってもよいです。"
    },
    {
      "indent": 3,
      "text": "- A COOKIE-ACK MAY be sent to an UNCONFIRMED address, but it MUST be bundled with a HEARTBEAT including a nonce. An implementation that does NOT support bundling MUST NOT send a COOKIE-ACK to an UNCONFIRMED address.",
      "ja": " -  COOKIE-ACKはUNCONFIRMEDアドレスに送信されるかもしれないが、それはナンスを含むHEARTBEATとバンドルされなければなりません。バンドルサポートしていない実装はUNCONFIRMEDアドレスにCOOKIE-ACKを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "- A COOKE-ECHO MAY be sent to an UNCONFIRMED address, but it MUST be bundled with a HEARTBEAT including a nonce, and the packet MUST NOT exceed the path MTU. If the implementation does NOT support bundling or if the bundled COOKIE-ECHO plus HEARTBEAT (including nonce) would exceed the path MTU, then the implementation MUST NOT send a COOKIE-ECHO to an UNCONFIRMED address.",
      "ja": " -  COOKE-ECHO未確認アドレスに送信されても​​よく、それはナンスを含むHEARTBEATとバンドルされなければならない、そして、パケットはパスMTUを超えてはなりません。実装がバンドルまたはバンドルCOOKIE-ECHOプラス（ナンスを含む）HEARTBEATがパスMTUを超える場合はサポートしていない場合は、その実装はUNCONFIRMEDアドレスにCOOKIE-ECHOを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 14)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "14. Suggested SCTP Protocol Parameter Values",
      "section_title": true,
      "ja": "14. SCTPプロトコルパラメータ値を推奨しました"
    },
    {
      "indent": 3,
      "text": "The following protocol parameters are RECOMMENDED:",
      "ja": "以下のプロトコルパラメータを推奨します。"
    },
    {
      "indent": 3,
      "text": "RTO.Initial - 3 seconds RTO.Min - 1 second RTO.Max - 60 seconds RTO.Alpha - 1/8 RTO.Beta - 1/4 Valid.Cookie.Life - 60 seconds Association.Max.Retrans - 10 attempts Path.Max.Retrans - 5 attempts (per destination address) Max.Init.Retransmits - 8 attempts HB.interval - 30 seconds",
      "ja": "RTO.Initial  -  3秒RTO.Min  -  1秒RTO.Max  -  60秒RTO.Alpha  -  1/8 RTO.Beta  -  1/4 Valid.Cookie.Life  -  60秒Association.Max.Retrans  -  10回のパス。 Max.Retrans  - （宛先アドレスごと）5つの試みMax.Init.Retransmits  -  8つの試みHB.interval  -  30秒"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 14)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "14. Suggested SCTP Protocol Parameter Values",
      "section_title": true,
      "ja": "14. SCTPプロトコルパラメータ値を推奨しました"
    },
    {
      "indent": 3,
      "text": "The following protocol parameters are RECOMMENDED:",
      "ja": "以下のプロトコルパラメータを推奨します。"
    },
    {
      "indent": 3,
      "text": "RTO.Initial - 3 seconds RTO.Min - 1 second RTO.Max - 60 seconds Max.Burst - 4 RTO.Alpha - 1/8 RTO.Beta - 1/4 Valid.Cookie.Life - 60 seconds Association.Max.Retrans - 10 attempts Path.Max.Retrans - 5 attempts (per destination address) Max.Init.Retransmits - 8 attempts HB.Interval - 30 seconds HB.Max.Burst - 1",
      "ja": "RTO.Initial  -  3秒RTO.Min  -  1秒RTO.Max  -  4 RTO.Alpha  -   -  Max.Burst 60秒1/8 RTO.Beta  -  1/4 Valid.Cookie.Life  -  60秒Association.Max.Retrans -  10試みるPath.Max.Retrans  - （宛先アドレスごと）5つの試みMax.Init.Retransmits  -  8つの試みHB.Interval  -  30秒HB.Max.Burst  -  1"
    },
    {
      "indent": 0,
      "text": "2.36.3. Solution Description",
      "section_title": true,
      "ja": "2.36.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "By properly setting up initial path state and accelerated probing via HEARTBEAT's, a new association can verify that all addresses presented by a peer belong to that peer.",
      "ja": "適切に初期パス状態を設定し、HEARTBEATのを経由して探査を加速することで、新しいアソシエーションは、ピアによって提示されたすべてのアドレスがそのピアに属していることを確認することができます。"
    },
    {
      "indent": 0,
      "text": "2.37. ICMP Handling Procedures",
      "section_title": true,
      "ja": "2.37。 ICMPの取り扱い手順"
    },
    {
      "indent": 0,
      "text": "2.37.1. Description of the Problem",
      "section_title": true,
      "ja": "2.37.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "RFC 2960 does not describe how ICMP messages should be processed by an SCTP endpoint.",
      "ja": "RFC 2960は、ICMPメッセージはSCTP終点によって処理されるべき方法については説明しません。"
    },
    {
      "indent": 0,
      "text": "2.37.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.37.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "--------\nOld text: None\n--------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "11.5. Protection of Non-SCTP Capable Hosts.",
      "section_title": true,
      "ja": "11.5。非SCTP対応ホストの保護。"
    },
    {
      "indent": 3,
      "text": "To provide a non-SCTP capable host with the same level of protection against attacks as for SCTP-capable ones, all SCTP stacks MUST implement the ICMP handling described in Appendix C.",
      "ja": "SCTP対応のもののためなどの攻撃に対する保護の同じレベルを持つ非SCTP可能なホストを提供するために、すべてのSCTPスタックは、付録Cで説明ICMP処理を実装しなければなりません"
    },
    {
      "indent": 3,
      "text": "When an SCTP stack receives a packet containing multiple control or DATA chunks and the processing of the packet requires the sending of multiple chunks in response, the sender of the response chunk(s) MUST NOT send more than one packet. If bundling is supported, multiple response chunks that fit into a single packet MAY be bundled together into one single response packet. If bundling is not supported, then the sender MUST NOT send more than one response chunk and MUST discard all other responses. Note that this rule does NOT apply to a SACK chunk, since a SACK chunk is, in itself, a response to DATA and a SACK does not require a response of more DATA.",
      "ja": "SCTPスタックは、複数の制御またはDATAチャンクとパケットの処理を含むパケットを受信し、応答して複数のチャンクの送信を必要とするとき、応答チャンク（S）の送信者は、複数のパケットを送ってはいけません。バンドルがサポートされている場合、単一のパケットに収まる複数の応答チャンクは、1つの応答パケットに束ねられるかもしれません。バンドルがサポートされていない場合は、送信者は、複数の応答チャンクを送ってはいけませんし、他のすべての応答を捨てなければなりません。この規則は、SACKチャンクには適用されませんSACKチャンクであるため、それ自体が、データに応答し、SACKは、より多くのデータの応答を必要としないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "An SCTP implementation SHOULD abort the association if it receives a SACK acknowledging a TSN that has not been sent.",
      "ja": "それが送信されていないTSNを認めるSACKを受信した場合、SCTPの実装は、関連付けを中止すべきです。"
    },
    {
      "indent": 3,
      "text": "An SCTP implementation that receives an INIT that would require a large packet in response, due to the inclusion of multiple ERROR parameters, MAY (at its discretion) elect to omit some or all of the ERROR parameters to reduce the size of the INIT-ACK. Due to a combination of the size of the COOKIE parameter and the number of addresses a receiver of an INIT may be indicating to a peer, it is always possible that the INIT-ACK will be larger than the original INIT. An SCTP implementation SHOULD attempt to make the INIT-ACK as small as possible to reduce the possibility of byte amplification attacks.",
      "ja": "複数のエラーパラメータを含めることによる応答で大きいパケットを必要とするINITを受信SCTP実装、（その裁量で）MAYは、INIT-ACKのサイズを小さくするエラーパラメータの一部または全部を省略することを選択します。起因COOKIEパラメータの大きさとINITの受信ピアに知らせることができるアドレスの数の組み合わせには、INIT-ACKが元INITより大きくなることは常に可能です。 SCTPの実装は、バイト増幅攻撃の可能性を減らすために可能な限り小さくINIT-ACKを試みるべきです。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: None\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Appendix C)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Appendix C ICMP Handling",
      "ja": "付録C ICMPの取り扱い"
    },
    {
      "indent": 3,
      "text": "Whenever an ICMP message is received by an SCTP endpoint the following procedures MUST be followed to ensure proper utilization of the information being provided by layer 3.",
      "ja": "ICMPメッセージはSCTPエンドポイントによって受信されるたびに次の手順では、レイヤ3によって提供される情報の適切な使用を確実にするために従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "ICMP1) An implementation MAY ignore all ICMPv4 messages where the type field is not set to \"Destination Unreachable\".",
      "ja": "ICMP1）の実装は、タイプフィールドが「宛先到達不能」に設定されていないすべてのICMPv4メッセージを無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "ICMP2) An implementation MAY ignore all ICMPv6 messages where the type field is not \"Destination Unreachable, \"Parameter Problem\" or \"Packet Too Big\".",
      "ja": "ICMP2）の実装は、タイプフィールドではありません、すべてのICMPv6メッセージ「宛先到達不能、 『パラメータ問題』または 『パケット過大』を無視してもよいです。"
    },
    {
      "indent": 3,
      "text": "ICMP3) An implementation MAY ignore any ICMPv4 messages where the code does not indicate \"Protocol Unreachable\" or \"Fragmentation Needed\".",
      "ja": "ICMP3）実装では、コードは「プロトコル到達不能」または「断片化必要」を示すものではありません任意のICMPv4のメッセージを無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "ICMP4) An implementation MAY ignore all ICMPv6 messages of type \"Parameter Problem\" if the code is not \"Unrecognized next header type encountered\".",
      "ja": "コードは「遭遇認識できない次のヘッダタイプ」ではない場合ICMP4）実装がタイプ「パラメータ問題」のすべてのICMPv6メッセージを無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "ICMP5) An implementation MUST use the payload of the ICMP message (V4 or V6) to locate the association that sent the message that ICMP is responding to. If the association cannot be found, an implementation SHOULD ignore the ICMP message.",
      "ja": "ICMP5）実装はICMPをに応答しているというメッセージを送信した関連付けを検索するためにICMPメッセージ（V4またはV6）のペイロードを使用しなければなりません。関連付けが見つからない場合、実装はICMPメッセージを無視すべきです。"
    },
    {
      "indent": 3,
      "text": "ICMP6) An implementation MUST validate that the Verification Tag contained in the ICMP message matches the verification tag of the peer. If the Verification Tag is not 0 and does NOT match, discard the ICMP message. If it is 0 and the ICMP message contains enough bytes to verify that the chunk type is an INIT chunk and that the initiate tag matches the tag of the peer, continue with ICMP7. If the ICMP message is too short or the chunk type or the initiate tag does not match, silently discard the packet.",
      "ja": "ICMP6）実装はICMPメッセージに含まれる検証タグは、ピアの検証タグと一致することを検証しなければなりません。検証タグが0ではないと一致しない場合は、ICMPメッセージを破棄します。それが0であり、ICMPメッセージは、チャンクタイプがINITチャンクであり、ザ・タグは、ピアのタグと一致することを開始することを確認するのに十分なバイトが含まれている場合、ICMP7を続けます。 ICMPメッセージが短すぎるまたはチャンクタイプやインクルードが一致していないタグを開始する場合は、静かにパケットを破棄する。"
    },
    {
      "indent": 3,
      "text": "ICMP7) If the ICMP message is either a V6 \"Packet Too Big\" or a V4 \"Fragmentation Needed\", an implementation MAY process this information as defined for PATH MTU discovery.",
      "ja": "ICMPメッセージがV6「パケット過大」またはV4「必要な断片化」のいずれかである場合はPATH MTUの発見のために定義されているようICMP7）、実装はこの情報を処理することができます。"
    },
    {
      "indent": 3,
      "text": "ICMP8) If the ICMP code is a \"Unrecognized next header type encountered\" or a \"Protocol Unreachable\", an implementation MUST treat this message as an abort with the T bit set if it does not contain an INIT chunk. If it does contain an INIT chunk and the association is in COOKIE-WAIT state, handle the ICMP message like an ABORT.",
      "ja": "それがINITチャンクが含まれていない場合、TはビットセットとICMP8）ICMPコードが「遭遇認識されない次のヘッダタイプ」又は「プロトコル到達不能」である場合、実装は、アボート、このメッセージを処理しなければなりません。それがINITチャンクを含んでいますし、協会がCOOKIE-WAIT状態にある場合は、ABORTのようなICMPメッセージを処理します。"
    },
    {
      "indent": 3,
      "text": "ICMP9) If the ICMPv6 code is \"Destination Unreachable\", the implementation MAY mark the destination into the unreachable state or alternatively increment the path error counter.",
      "ja": "ICMP9 ICMPv6のコードが「到達不能宛先」である場合）、実装が到達不能状態に宛先をマーク又は代替パス・エラー・カウンタをインクリメントするかもしれません。"
    },
    {
      "indent": 3,
      "text": "Note that these procedures differ from RFC 1122 [1] and from its requirements for processing of port-unreachable messages and the requirements that an implementation MUST abort associations in response to a \"protocol unreachable\" message. Port unreachable messages are not processed, since an implementation will send an ABORT, not a port unreachable. The stricter handling of the \"protocol unreachable\" message is due to security concerns for hosts that do NOT support SCTP.",
      "ja": "これらの手順は、RFC 1122 [1]から、そのポート到達不能メッセージを処理するための要件と実装が「プロトコル到達不能」メッセージに応答して関連付けを中止しなければならない要件とは異なることに留意されたいです。実装はABORT、到達不可能ではないポートをお送りしますので、ポート到達不能メッセージは、処理されません。 「プロトコル到達不能」メッセージの厳格な取り扱いは、SCTPをサポートしていないホストのためのセキュリティ上の問題によるものです。"
    },
    {
      "indent": 0,
      "text": "2.37.3. Solution Description",
      "section_title": true,
      "ja": "2.37.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new appendix now describes proper handling of ICMP messages in conjunction with SCTP.",
      "ja": "新しい付録では、今SCTPと一緒にICMPメッセージの適切な取り扱いを説明しています。"
    },
    {
      "indent": 0,
      "text": "2.38. Checksum",
      "section_title": true,
      "ja": "2.38。チェックサム"
    },
    {
      "indent": 0,
      "text": "2.38.1. Description of the problem",
      "section_title": true,
      "ja": "2.38.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "RFC 3309 [6] changes the SCTP checksum due to weaknesses in the original Adler 32 checksum for small messages. This document, being used as a guide for a cut and paste replacement to update RFC 2960, thus also needs to incorporate the checksum changes. The idea is that one could apply all changes found in this guide to a copy of RFC 2960 and have a \"new\" document that has ALL changes (including RFC 3309).",
      "ja": "RFC 3309 [6]小さなメッセージの元アドラー32チェックサムの弱点に起因SCTPチェックサムを変更します。この文書では、このようにしても、チェックサムの変更を組み込む必要がある、RFC 2960を更新するために、カットアンドペースト交換のためのガイドとして使用されています。アイデアは、1つのRFC 2960のコピーに、このガイドで見つかったすべての変更を適用し、（RFC 3309を含む）すべての変更を持っている「新しい」文書を持っている可能性があることです。"
    },
    {
      "indent": 0,
      "text": "2.38.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.38.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text:\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6.8 Adler-32 Checksum Calculation",
      "section_title": true,
      "ja": "6.8アドラー-32チェックサムの計算"
    },
    {
      "indent": 6,
      "text": "When sending an SCTP packet, the endpoint MUST strengthen the data integrity of the transmission by including the Adler-32 checksum value calculated on the packet, as described below.",
      "ja": "SCTPパケットを送信するとき、以下に記載されるように、エンドポイントは、パケットで計算アドラー-32チェックサム値を含むことによって、送信のデータの整合性を強化しなければなりません。"
    },
    {
      "indent": 6,
      "text": "After the packet is constructed (containing the SCTP common header and one or more control or DATA chunks), the transmitter shall:",
      "ja": "パケットが（SCTP共通ヘッダと1つ以上の制御またはDATAチャンクを含む）を構築した後、送信機はなければなりません。"
    },
    {
      "indent": 6,
      "text": "1) Fill in the proper Verification Tag in the SCTP common header and initialize the checksum field to 0's.",
      "ja": "1）SCTP共通ヘッダに適切な検証タグを入力し、0のにチェックサムフィールドを初期化します。"
    },
    {
      "indent": 6,
      "text": "2) Calculate the Adler-32 checksum of the whole packet, including the SCTP common header and all the chunks. Refer to appendix B for details of the Adler-32 algorithm. And,",
      "ja": "2）SCTP共通ヘッダとすべてのチャンクを含むパケット全体のアドラー-32チェックサムを計算します。アドラー-32アルゴリズムの詳細については、付録Bを参照。そして、"
    },
    {
      "indent": 6,
      "text": "3) Put the resultant value into the checksum field in the common header, and leave the rest of the bits unchanged.",
      "ja": "3）共通ヘッダ内のチェックサムフィールドにその値を入れ、そして不変のビットの残りの部分を残します。"
    },
    {
      "indent": 6,
      "text": "When an SCTP packet is received, the receiver MUST first check the Adler-32 checksum:",
      "ja": "SCTPパケットが受信されると、受信機は最初アドラー-32チェックサムをチェックしなければなりません。"
    },
    {
      "indent": 6,
      "text": "1) Store the received Adler-32 checksum value aside,",
      "ja": "1）、別に受信アドラー-32チェックサム値を格納"
    },
    {
      "indent": 6,
      "text": "2) Replace the 32 bits of the checksum field in the received SCTP packet with all '0's and calculate an Adler-32 checksum value of the whole received packet. And,",
      "ja": "2）全て「0で受信SCTPパケット内のチェックサムフィールドの32ビットを交換し、全受信パケットのアドラー-32チェックサム値を計算します。そして、"
    },
    {
      "indent": 6,
      "text": "3) Verify that the calculated Adler-32 checksum is the same as the received Adler-32 checksum. If not, the receiver MUST treat the packet as an invalid SCTP packet.",
      "ja": "3）が算出アドラー-32チェックサムが受信アドラー-32チェックサムと同じであることを確認します。そうでない場合、受信機は、無効なSCTPパケットとしてパケットを扱わなければなりません。"
    },
    {
      "indent": 6,
      "text": "The default procedure for handling invalid SCTP packets is to silently discard them.",
      "ja": "無効なSCTPパケットを処理するためのデフォルトの手順は静かにそれらを捨てることです。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text:\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6.8 CRC-32c Checksum Calculation",
      "section_title": true,
      "ja": "6.8 CRC-32cのチェックサム計算"
    },
    {
      "indent": 6,
      "text": "When sending an SCTP packet, the endpoint MUST strengthen the data integrity of the transmission by including the CRC32c checksum value calculated on the packet, as described below.",
      "ja": "SCTPパケットを送信するとき、以下に記載されるように、エンドポイントは、パケットで計算CRC32Cチェックサム値を含むことによって、送信のデータの整合性を強化しなければなりません。"
    },
    {
      "indent": 6,
      "text": "After the packet is constructed (containing the SCTP common header and one or more control or DATA chunks), the transmitter MUST",
      "ja": "パケットが構築された後、送信機MUST（SCTP共通ヘッダと1つ以上の制御またはDATAチャンクを含みます）"
    },
    {
      "indent": 6,
      "text": "1) fill in the proper Verification Tag in the SCTP common header and initialize the checksum field to '0's,",
      "ja": "1）、SCTP共通ヘッダに適切な検証タグを記入し、「0年代にチェックサムフィールドを初期化します"
    },
    {
      "indent": 6,
      "text": "2) calculate the CRC32c checksum of the whole packet, including the SCTP common header and all the chunks (refer to appendix B for details of the CRC32c algorithm); and",
      "ja": "2）SCTP共通ヘッダとすべてのチャンク（CRC32Cアルゴリズムの詳細については、Bの付録を参照）を含むパケット全体のCRC32Cチェックサムを計算します。そして"
    },
    {
      "indent": 6,
      "text": "3) put the resultant value into the checksum field in the common header, and leave the rest of the bits unchanged.",
      "ja": "3）共通ヘッダ内のチェックサムフィールドにその値を入れ、そして不変のビットの残りの部分を残します。"
    },
    {
      "indent": 6,
      "text": "When an SCTP packet is received, the receiver MUST first check the CRC32c checksum as follows:",
      "ja": "SCTPパケットが受信されると、以下のように、受信機は、第CRC32Cチェックサムをチェックしなければなりません。"
    },
    {
      "indent": 6,
      "text": "1) Store the received CRC32c checksum value aside.",
      "ja": "1）脇受信CRC32Cチェックサムの値を格納します。"
    },
    {
      "indent": 6,
      "text": "2) Replace the 32 bits of the checksum field in the received SCTP packet with all '0's and calculate a CRC32c checksum value of the whole received packet.",
      "ja": "2）全て「0で受信SCTPパケット内のチェックサムフィールドの32ビットを置き換え、パケットを受信した全体のCRC32Cチェックサム値を計算します。"
    },
    {
      "indent": 6,
      "text": "3) Verify that the calculated CRC32c checksum is the same as the received CRC32c checksum. If it is not, the receiver MUST treat the packet as an invalid SCTP packet.",
      "ja": "3）計算CRC32Cチェックサムは、受信CRC32Cチェックサムと同じであることを確認します。そうでない場合、受信機は、無効なSCTPパケットとしてパケットを扱わなければなりません。"
    },
    {
      "indent": 6,
      "text": "The default procedure for handling invalid SCTP packets is to silently discard them.",
      "ja": "無効なSCTPパケットを処理するためのデフォルトの手順は静かにそれらを捨てることです。"
    },
    {
      "indent": 6,
      "text": "Any hardware implementation SHOULD be done in a way that is verifiable by the software.",
      "ja": "任意のハードウェア実装は、ソフトウェアによって検証可能な方法で行うべきです。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text:\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Appendix B Alder 32 bit checksum calculation",
      "ja": "付録Bアルダー32ビットのチェックサム計算"
    },
    {
      "indent": 6,
      "text": "The Adler-32 checksum calculation given in this appendix is copied from [RFC1950].",
      "ja": "この付録に示さアドラー-32チェックサムの計算は、[RFC1950]からコピーされます。"
    },
    {
      "indent": 6,
      "text": "Adler-32 is composed of two sums accumulated per byte: s1 is the sum of all bytes, s2 is the sum of all s1 values. Both sums are done modulo 65521. s1 is initialized to 1, s2 to zero. The Adler-32 checksum is stored as s2*65536 + s1 in network byte order.",
      "ja": "アドラー-32バイト当たり累積2点の合計で構成されている：S1はすべてのバイトの合計であり、S2は全てS1の値の合計です。両方の合計は、モジュロ65521. S1がゼロにS2では、1に初期化されて行われます。アドラー-32チェックサムは、ネットワークバイト順でのS2 * 65536 + S1として記憶されます。"
    },
    {
      "indent": 6,
      "text": "The following C code computes the Adler-32 checksum of a data buffer. It is written for clarity, not for speed. The sample code is in the ANSI C programming language. Non C users may find it easier to read with these hints:",
      "ja": "次のCコードは、データバッファのアドラー-32チェックサムを計算します。それはない速さのために、明確さのために書かれています。サンプルコードは、ANSI Cプログラミング言語です。非Cユーザーは、簡単にこれらのヒントを読むことを見つけることがあります。"
    },
    {
      "indent": 6,
      "text": "& Bitwise AND operator. >> Bitwise right shift operator. When applied to an unsigned quantity, as here, right shift inserts zero bit(s) at the left. << Bitwise left shift operator. Left shift inserts zero bit(s) at the right. ++ \"n++\" increments the variable n. % modulo operator: a % b is the remainder of a divided by b.",
      "ja": "ビット単位のAND演算子＆。 >>ビット単位の右シフト演算子。ここでのように、符号なしの数量に適用した場合、右シフトは左にゼロビット（単数または複数）を挿入します。 <<ビット単位のシフト演算子を残しました。左シフト、右にゼロ・ビット（単数または複数）を挿入します。 ++ \"N ++\" 変数nをインクリメントします。 ％モジュロ演算子：％BをBで割った余りのです。"
    },
    {
      "indent": 7,
      "text": "#define BASE 65521 /* largest prime smaller than 65536 */\n/*\n  Update a running Adler-32 checksum with the bytes buf[0..len-1]\n  and return the updated checksum.  The Adler-32 checksum should\n  be initialized to 1.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Usage example:",
      "ja": "使用例："
    },
    {
      "indent": 12,
      "text": "unsigned long adler = 1L;",
      "ja": "unsigned long型アドラー= 1L。"
    },
    {
      "indent": 9,
      "text": "   while (read_buffer(buffer, length) != EOF) {\n     adler = update_adler32(adler, buffer, length);\n    }\n   if (adler != original_adler) error();\n*/\nunsigned long update_adler32(unsigned long adler,\n   unsigned char *buf, int len)\n{\n  unsigned long s1 = adler & 0xffff;\n  unsigned long s2 = (adler >> 16) & 0xffff;\n  int n;",
      "raw": true
    },
    {
      "indent": 9,
      "text": "  for (n = 0; n < len; n++) {\n    s1 = (s1 + buf[n]) % BASE;\n    s2 = (s2 + s1)     % BASE;\n  }\n  return (s2 << 16) + s1;\n}",
      "raw": true
    },
    {
      "indent": 9,
      "text": "/* Return the adler32 of the bytes buf[0..len-1] */\nunsigned long adler32(unsigned char *buf, int len)\n{\n  return update_adler32(1L, buf, len);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text:\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Appendix B CRC32c Checksum Calculation",
      "ja": "付録B CRC32Cチェックサムの計算"
    },
    {
      "indent": 6,
      "text": "We define a 'reflected value' as one that is the opposite of the normal bit order of the machine. The 32-bit CRC is calculated as described for CRC-32c and uses the polynomial code 0x11EDC6F41 (Castagnoli93) or x^32+x^28+x^27+x^26+x^25 +x^23+x^22+x^20+x^19+x^18+x^14+x^13+x^11+x^10+x^9+x^8+x^6+x^0. The CRC is computed using a procedure similar to ETHERNET CRC [ITU32], modified to reflect transport level usage.",
      "ja": "我々は、機械の通常のビット順序の逆であるとして「反射値を」定義します。 32ビットCRCはCRC-32Cについて説明したように計算された多項式コード0x11EDC6F41（Castagnoli93）またはX ^ 32 + X ^ 28 + X ^ 27 + X ^ 26 + X ^ 25 + X ^ 23 + X ^ 22を使用しています+ X ^ 20 + X ^ 19 + X ^ 18 + X ^ 14 + X ^ 13 + X ^ 11 + X ^ 10 + X ^ 9 + X ^ 8 + X ^ 6 + X ^ 0。 CRCは、トランスポートレベルの使用を反映するように修正ETHERNET CRC [ITU32]と同様の手順を使用して計算されます。"
    },
    {
      "indent": 6,
      "text": "CRC computation uses polynomial division. A message bit-string M is transformed to a polynomial, M(X), and the CRC is calculated from M(X) using polynomial arithmetic [PETERSON 72].",
      "ja": "CRCの計算は、多項式除算を使用しています。多項式演算[PETERSON 72]を使用してメッセージビットストリングMは多項式M（X）に変換され、そしてCRCはM（X）から計算されます。"
    },
    {
      "indent": 6,
      "text": "When CRCs are used at the link layer, the polynomial is derived from on-the-wire bit ordering: the first bit 'on the wire' is the high-order coefficient. Since SCTP is a transport-level protocol, it cannot know the actual serial-media bit ordering. Moreover, different links in the path between SCTP endpoints may use different link-level bit orders.",
      "ja": "CRCはリンク層で使用される場合、多項式がオン・ザ・ワイヤビットの順序から導出される：「ワイヤ上の」最初のビットは、高次係数です。 SCTPは、トランスポートレベルのプロトコルであるので、実際のシリアルメディアビット順序を知ることができません。また、SCTPエンドポイント間の経路における異なるリンクは、異なるリンク・レベルのビット順序を使用してもよいです。"
    },
    {
      "indent": 6,
      "text": "A convention must therefore be established for mapping SCTP transport messages to polynomials for purposes of CRC computation. The bit-ordering for mapping SCTP messages to polynomials is that bytes are taken most-significant first; but within each byte, bits are taken least-significant first. The first byte of the message provides the eight highest coefficients. Within each byte, the least-significant SCTP bit gives the most significant polynomial coefficient within that byte, and the most-significant SCTP bit is the least significant polynomial coefficient in that byte. (This bit ordering is sometimes called 'mirrored' or 'reflected' [WILLIAMS93].) CRC polynomials are to be transformed back into SCTP transport-level byte values, using a consistent mapping.",
      "ja": "大会は、したがって、CRC計算の目的のために多項式にマッピングSCTP輸送メッセージのために確立されなければなりません。多項式へのマッピングSCTPメッセージのビット順序はバイトが最初に最上位取らされていることです。しかし、各バイト内のビットは最下位第取られます。メッセージの最初のバイトは8つの最高の係数を提供します。各バイト内、最下位SCTPビットがそのバイト内の最上位の多項式係数を与え、そして最上位SCTPビットがそのバイトの最下位多項式の係数です。 （このビットの順序は、時に[WILLIAMS93]「ミラー」または「反射」と呼ばれる。）CRC多項式一致マッピングを使用して、バックSCTPトランスポートレベルのバイト値に変換されます。"
    },
    {
      "indent": 6,
      "text": "The SCTP transport-level CRC value should be calculated as follows:",
      "ja": "次のようにSCTPトランスポートレベルのCRC値が計算されるべきです。"
    },
    {
      "indent": 9,
      "text": "- CRC input data are assigned to a byte stream, numbered from 0 to N-1.",
      "ja": " -  CRC入力データが0からN-1までの番号が付けられたバイトストリームに割り当てられます。"
    },
    {
      "indent": 9,
      "text": "- The transport-level byte-stream is mapped to a polynomial value. An N-byte PDU with j bytes numbered 0 to N-1 is considered as coefficients of a polynomial M(x) of order 8N-1, with bit 0 of byte j being coefficient x^(8(N-j)-8), and bit 7 of byte j being coefficient x^(8(N-j)-1).",
      "ja": " - トランスポートレベルのバイトストリームを、多項式の値にマッピングされます。 JのバイトのNバイトのPDUは、バイトJある係数X ^（8（NJ）-8）のビット0と、オーダー8N-1の多項式M（x）の係数として考えられるN-1に0の番号が付けバイトjのある係数X ^（8（NJ）-1）のビット7。"
    },
    {
      "indent": 9,
      "text": "- The CRC remainder register is initialized with all 1s and the CRC is computed with an algorithm that simultaneously multiplies by x^32 and divides by the CRC polynomial.",
      "ja": " -  CRC剰余レジスタはすべて1で初期化され、CRCが同時にX ^ 32によって乗算し、CRC多項式で除算アルゴリズムを用いて計算されます。"
    },
    {
      "indent": 9,
      "text": "- The polynomial is multiplied by x^32 and divided by G(x), the generator polynomial, producing a remainder R(x) of degree less than or equal to 31.",
      "ja": " - 多項式は、x ^ 32によって乗算され、31以下程度の剰余R（x）を生成し、G（x）は、生成多項式で割りました。"
    },
    {
      "indent": 9,
      "text": "- The coefficients of R(x) are considered a 32-bit sequence.",
      "ja": " -  Rの係数（x）は32ビットのシーケンスであると考えられます。"
    },
    {
      "indent": 9,
      "text": "- The bit sequence is complemented. The result is the CRC polynomial.",
      "ja": " - ビットシーケンスが補完されます。結果は、CRC多項式です。"
    },
    {
      "indent": 9,
      "text": "- The CRC polynomial is mapped back into SCTP transport-level bytes. The coefficient of x^31 gives the value of bit 7 of SCTP byte 0, and the coefficient of x^24 gives the value of bit 0 of byte 0. The coefficient of x^7 gives bit 7 of byte 3, and the coefficient of x^0 gives bit 0 of byte 3. The resulting four-byte transport-level sequence is the 32-bit SCTP checksum value.",
      "ja": " -  CRC多項式はバックSCTPトランスポートレベルのバイトにマッピングされます。 X ^ 31の係数は、SCTPのバイト0のビット7の値を与え、そしてx ^ 24の係数は、バイト0のビット0の値を与えるX ^ 7の係数がバイト3、及び係数のビット7を与えます0 X ^では、得られた4バイトのトランスポートレベルのシーケンスが32ビットSCTPチェックサム値であるバイト3のビット0を与えます。"
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: Standards documents, textbooks, and vendor literature on CRCs often follow an alternative formulation, in which the register used to hold the remainder of the long-division algorithm is initialized to zero rather than all-1s, and instead the first 32 bits of the message are complemented. The long-division algorithm used in our formulation is specified such that the initial multiplication by 2^32 and the long-division are combined into one simultaneous operation. For such algorithms, and for messages longer than 64 bits, the two specifications are precisely equivalent. That equivalence is the intent of this document.",
      "ja": "実装注：標準ドキュメント、教科書、及びCRCの上のベンダー文献は、多くの場合、レジスタがゼロではなく、すべての-1Sに初期化される長い分割アルゴリズムの残りの部分を保持するために使用される代替製剤、その代わりに最初の32ビットをたどりますメッセージの補完されています。我々の製剤に使用される長い分割アルゴリズムは、2 ^ 32による初期乗算と長い分割は、1つの同時操作に結合されるように指定されています。そのようなアルゴリズムのために、64ビットより長いメッセージのために、2つの仕様を正確に等価です。その等価性は、この文書の意図です。"
    },
    {
      "indent": 6,
      "text": "Implementors of SCTP are warned that both specifications are to be found in the literature, sometimes with no restriction on the long-division algorithm. The choice of formulation in this document is to permit non-SCTP usage, where the same CRC algorithm may be used to protect messages shorter than 64 bits.",
      "ja": "SCTPの実装は、両方の仕様は、時には長い分割アルゴリズム上の制限なく、文献に見出されることを警告されています。この文書に記載されている製剤の選択は、同じCRCアルゴリズムは、64ビットより短いメッセージを保護するために使用することができる非SCTPの使用を、可能にすることです。"
    },
    {
      "indent": 6,
      "text": "There may be a computational advantage in validating the Association against the Verification Tag, prior to performing a checksum, as invalid tags will result in the same action as a bad checksum in most cases. The exceptions for this technique would be INIT and some SHUTDOWN-COMPLETE exchanges, as well as a stale COOKIE-ECHO. These special case exchanges must represent small packets and will minimize the effect of the checksum calculation.",
      "ja": "無効なタグは、ほとんどの場合、不正なチェックサムと同じ動作になりますよう、事前のチェックサムを実行し、検証タグに対する協会の検証における計算利点があるかもしれません。この技術のための例外はINITと、いくつかのSHUTDOWN-COMPLETEの交流だけでなく、古いCOOKIE-ECHOだろう。これらの特別なケースの交換は小さなパケットを表しなければならず、チェックサム計算の影響を最小化します。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 18)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "18. Bibliography",
      "section_title": true,
      "ja": "18.参考文献"
    },
    {
      "indent": 3,
      "text": "[ALLMAN99] Allman, M. and Paxson, V., \"On Estimating End-to-End Network Path Properties\", Proc. SIGCOMM'99, 1999.",
      "ja": "「エンドツーエンドのネットワークパスのプロパティの推定について」[ALLMAN99]オールマン、M.とパクソン、V.、PROC。 SIGCOMM'99、1999。"
    },
    {
      "indent": 3,
      "text": "[FALL96] Fall, K. and Floyd, S., Simulation-based Comparisons of Tahoe, Reno, and SACK TCP, Computer Communications Review, V. 26 N. 3, July 1996, pp. 5-21.",
      "ja": "[FALL96]秋、K.とフロイド、S.、タホ、リノ、およびSACK TCP、コンピュータコミュニケーションレビュー、V. 26 N. 3、1996年7月、頁5-21のシミュレーションベースの比較。"
    },
    {
      "indent": 3,
      "text": "[RFC1750] Eastlake, D. (ed.), \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[RFC1750]イーストレーク、D.（編）、 \"セキュリティのためのランダム性に関する推奨事項\"、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1950] Deutsch P. and J. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, May 1996.",
      "ja": "[RFC1950]ドイツP.とJ. Gailly氏、 \"ZLIB圧縮データフォーマット仕様バージョン3.3\"、RFC 1950、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, March 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M。およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2196] Fraser, B., \"Site Security Handbook\", FYI 8, RFC 2196, September 1997.",
      "ja": "[RFC2196]フレイザー、B.、 \"サイトセキュリティハンドブック\"、FYI 8、RFC 2196、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2522] Karn, P. and W. Simpson, \"Photuris: Session-Key Management Protocol\", RFC 2522, March 1999.",
      "ja": "[RFC2522]カーン、P.とW.シンプソン、 \"Photuris：セッション鍵管理プロトコル\"、RFC 2522、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and Anderson, T., \"TCP Congestion Control with a Misbehaving Receiver\", ACM Computer Communication Review, 29(5), October 1999.",
      "ja": "[SAVAGE99]サベージ、S.、カードウェル、N.、Wetherall、D.、およびアンダーソン、T.、 \"ふらちなレシーバーとのTCP輻輳制御\"、ACMコンピュータコミュニケーションレビュー、29（5）、1999年10月。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 18, including changes from 2.11)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "18. Bibliography",
      "section_title": true,
      "ja": "18.参考文献"
    },
    {
      "indent": 3,
      "text": "[ALLMAN99] Allman, M. and Paxson, V., \"On Estimating End-to-End Network Path Properties\", Proc. SIGCOMM'99, 1999.",
      "ja": "「エンドツーエンドのネットワークパスのプロパティの推定について」[ALLMAN99]オールマン、M.とパクソン、V.、PROC。 SIGCOMM'99、1999。"
    },
    {
      "indent": 3,
      "text": "[FALL96] Fall, K. and Floyd, S., Simulation-based Comparisons of Tahoe, Reno, and SACK TCP, Computer Communications Review, V. 26 N. 3, July 1996, pp. 5-21.",
      "ja": "[FALL96]秋、K.とフロイド、S.、タホ、リノ、およびSACK TCP、コンピュータコミュニケーションレビュー、V. 26 N. 3、1996年7月、頁5-21のシミュレーションベースの比較。"
    },
    {
      "indent": 3,
      "text": "[ITU32] ITU-T Recommendation V.42, \"Error-correcting procedures for DCEs using asynchronous-to-synchronous conversion\", Section 8.1.1.6.2, October 1996.",
      "ja": "セクション8.1.1.6.2、1996年10月[ITU32] ITU-T勧告V.42、 \"非同期に同期変換を使用してのDCEのエラー訂正手順\"。"
    },
    {
      "indent": 3,
      "text": "[PETERSON 1972] W. W. Peterson and E.J Weldon, Error Correcting Codes, 2nd Edition, MIT Press, Cambridge, Massachusetts.",
      "ja": "[PETERSON 1972] W. W.ピーターソンとE.Jウェルドン、誤り訂正符号、第2版、MITプレス、ケンブリッジ、マサチューセッツ州。"
    },
    {
      "indent": 3,
      "text": "[RFC1750] Eastlake, D., Ed., \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[RFC1750]イーストレイク、D.編、 \"セキュリティのためのランダム性に関する推奨事項\"、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1858] Ziemba, G., Reed, D. and Traina P., \"Security Considerations for IP Fragment Filtering\", RFC 1858, October 1995.",
      "ja": "[RFC1858] Ziemba、G.、リード、D.とTrainaのP.、 \"IPフラグメントフィルタリングのためのセキュリティの考慮事項\"、RFC 1858、1995年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1950] Deutsch P. and J. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, May 1996.",
      "ja": "[RFC1950]ドイツP.とJ. Gailly氏、 \"ZLIB圧縮データフォーマット仕様バージョン3.3\"、RFC 1950、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, March 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M。およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2196] Fraser, B., \"Site Security Handbook\", FYI 8, RFC 2196, September 1997.",
      "ja": "[RFC2196]フレイザー、B.、 \"サイトセキュリティハンドブック\"、FYI 8、RFC 2196、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2522] Karn, P. and W. Simpson, \"Photuris: Session-Key Management Protocol\", RFC 2522, March 1999.",
      "ja": "[RFC2522]カーン、P.とW.シンプソン、 \"Photuris：セッション鍵管理プロトコル\"、RFC 2522、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and Anderson, T., \"TCP Congestion Control with a Misbehaving Receiver\", ACM Computer Communication Review, 29(5), October 1999.",
      "ja": "[SAVAGE99]サベージ、S.、カードウェル、N.、Wetherall、D.、およびアンダーソン、T.、 \"ふらちなレシーバーとのTCP輻輳制御\"、ACMコンピュータコミュニケーションレビュー、29（5）、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[WILLIAMS93] Williams, R., \"A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS\" - Internet publication, August 1993, http://www.geocities.com/SiliconValley/Pines/ 8659/crc.htm.",
      "ja": "[WILLIAMS93]ウィリアムズ、R.、 \"CRCエラー検出アルゴリズム無痛ガイド\"  - インターネット出版、1993年8月、http://www.geocities.com/SiliconValley/Pines/ 8659 / crc.htm。"
    },
    {
      "indent": 0,
      "text": "2.38.3. Solution Description",
      "section_title": true,
      "ja": "2.38.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "This change adds to the implementor's guide the complete set of changes that, when combined with RFC 2960 [5], encompasses the changes from RFC 3309 [6].",
      "ja": "この変更は、実装のガイドRFC 2960と組み合わされ、変更の完全なセットを追加し[5]、[6] RFC 3309からの変更を包含する。"
    },
    {
      "indent": 0,
      "text": "2.39. Retransmission Policy",
      "section_title": true,
      "ja": "2.39。再送方針"
    },
    {
      "indent": 0,
      "text": "2.39.1. Description of the Problem",
      "section_title": true,
      "ja": "2.39.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The current retransmission policy (send all retransmissions an alternate destination) in the specification has performance issues under certain loss conditions with multihomed endpoints. Instead, fast retransmissions should be sent to the same destination, and only timeout retransmissions should be sent to an alternate destination [4].",
      "ja": "現在の再送方針仕様で（すべての再送代替宛先を送信する）がマルチホームエンドポイントと特定の損失条件下でパフォーマンスの問題を有しています。代わりに、高速再送信は、同じ宛先に送信されるべきである、とのみタイムアウト再送信は、代替の宛先に送信されるべきである[4]。"
    },
    {
      "indent": 0,
      "text": "2.39.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.39.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Furthermore, when its peer is multi-homed, an endpoint SHOULD try to retransmit a chunk to an active destination transport address that is different from the last destination address to which the DATA chunk was sent.",
      "ja": "そのピアがマルチホームである場合さらに、エンドポイントは、データチャンクが送信されたために、最後の宛先アドレスと異なるアクティブ宛先トランスポートアドレスにチャンクを再送するようにしてください。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Furthermore, when its peer is multi-homed, an endpoint SHOULD try to retransmit a chunk that timed out to an active destination transport address that is different from the last destination address to which the DATA chunk was sent.",
      "ja": "そのピアがマルチホームである場合さらに、エンドポイントは、データチャンクが送信されたために、最後の宛先アドレスと異なるアクティブ宛先トランスポートアドレスにタイムアウトチャンクを再送するようにしてください。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.4.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When retransmitting data, if the endpoint is multi-homed, it should consider each source-destination address pair in its retransmission selection policy. When retransmitting the endpoint should attempt to pick the most divergent source-destination pair from the original source-destination pair to which the packet was transmitted.",
      "ja": "エンドポイントは、マルチホームの場合は、データを再送すると、その再選択ポリシー内の各ソース先のアドレスのペアを検討すべきです。エンドポイントを再送信する場合、パケットが送信された元の送信元と宛先のペアから最も発散ソースと宛先のペアを選択することを試みるべきです。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.4.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When retransmitting data that timed out, if the endpoint is multi-homed, it should consider each source-destination address pair in its retransmission selection policy. When retransmitting timed out data, the endpoint should attempt to pick the most divergent source-destination pair from the original source-destination pair to which the packet was transmitted.",
      "ja": "エンドポイントは、マルチホームの場合は、タイムアウトしたデータを再送すると、その再選択ポリシー内の各ソース先のアドレスのペアを検討すべきです。タイムアウトしたデータを再送する場合、エンドポイントは、パケットが送信された元の送信元と宛先のペアから最も発散ソースと宛先のペアを選択することを試みるべきです。"
    },
    {
      "indent": 0,
      "text": "2.39.3. Solution Description",
      "section_title": true,
      "ja": "2.39.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above wording changes clarify that only timeout retransmissions should be sent to an alternate active destination.",
      "ja": "上記文言は、タイムアウト再送が代替アクティブ宛先に送信されるべきであることを明確に変化します。"
    },
    {
      "indent": 0,
      "text": "2.40. Port Number 0",
      "section_title": true,
      "ja": "2.40。ポート番号0"
    },
    {
      "indent": 0,
      "text": "2.40.1. Description of the Problem",
      "section_title": true,
      "ja": "2.40.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The port number 0 has a special semantic in various APIs. For example, in the socket API, if the user specifies 0, the SCTP implementation chooses an appropriate port number for the user. Therefore, the port number 0 should not be used on the wire.",
      "ja": "ポート番号0は、様々なAPIで特別なセマンティックを持っています。例えば、ソケットAPIに、ユーザは、SCTPの実装では、ユーザに適切なポート番号を選択し、0を指定している場合。したがって、ポート番号0は、ワイヤ上で使用すべきではありません。"
    },
    {
      "indent": 0,
      "text": "2.40.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.40.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Source Port Number: 16 bits (unsigned integer)",
      "ja": "送信元ポート番号：16ビット（符号なし整数）"
    },
    {
      "indent": 9,
      "text": "This is the SCTP sender's port number. It can be used by the receiver in combination with the source IP address, the SCTP destination port, and possibly the destination IP address to identify the association to which this packet belongs.",
      "ja": "これは、SCTP送信者のポート番号です。このパケットが属する関連付けを識別するために、送信元IPアドレス、SCTP宛先ポート、および場合によって宛先IPアドレスと組み合わせて、受信機で使用することができます。"
    },
    {
      "indent": 6,
      "text": "Destination Port Number: 16 bits (unsigned integer)",
      "ja": "宛先ポート番号：16ビット（符号なし整数）"
    },
    {
      "indent": 9,
      "text": "This is the SCTP port number to which this packet is destined. The receiving host will use this port number to de-multiplex the SCTP packet to the correct receiving endpoint/application.",
      "ja": "これは、このパケットの宛先されているSCTPポート番号です。受信ホストは、正しい受信エンドポイント/アプリケーションにSCTPパケットを逆多重化するために、このポート番号を使用します。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Source Port Number: 16 bits (unsigned integer)",
      "ja": "送信元ポート番号：16ビット（符号なし整数）"
    },
    {
      "indent": 9,
      "text": "This is the SCTP sender's port number. It can be used by the receiver in combination with the source IP address, the SCTP destination port and possibly the destination IP address to identify the association to which this packet belongs. The port number 0 MUST NOT be used.",
      "ja": "これは、SCTP送信者のポート番号です。このパケットが属する関連付けを識別するために、送信元IPアドレス、SCTP宛先ポート及びおそらくは宛先IPアドレスと組み合わせて、受信機で使用することができます。ポート番号0を使用してはいけません。"
    },
    {
      "indent": 6,
      "text": "Destination Port Number: 16 bits (unsigned integer)",
      "ja": "宛先ポート番号：16ビット（符号なし整数）"
    },
    {
      "indent": 9,
      "text": "This is the SCTP port number to which this packet is destined. The receiving host will use this port number to de-multiplex the SCTP packet to the correct receiving endpoint/application. The port number 0 MUST NOT be used.",
      "ja": "これは、このパケットの宛先されているSCTPポート番号です。受信ホストは、正しい受信エンドポイント/アプリケーションにSCTPパケットを逆多重化するために、このポート番号を使用します。ポート番号0を使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "2.40.3. Solution Description",
      "section_title": true,
      "ja": "2.40.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "It is clearly stated that the port number 0 is an invalid value on the wire.",
      "ja": "明らかに、ポート番号0は、ワイヤ上の無効な値があることが述べられています。"
    },
    {
      "indent": 0,
      "text": "2.41. T Bit",
      "section_title": true,
      "ja": "2.41。 Tビット"
    },
    {
      "indent": 0,
      "text": "2.41.1. Description of the Problem",
      "section_title": true,
      "ja": "2.41.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The description of the T bit as the bit describing whether a TCB has been destroyed is misleading. In addition, the procedure described in Section 2.13 is not as precise as needed.",
      "ja": "TCBが破壊されたかどうかを記述するビットとしてTビットの説明は誤解を招きます。また、セクション2.13に記載された手順は、必要に応じとして正確ではありません。"
    },
    {
      "indent": 0,
      "text": "2.41.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.41.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.7)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "T bit: 1 bit The T bit is set to 0 if the sender had a TCB that it destroyed. If the sender did not have a TCB it should set this bit to 1.",
      "ja": "Tビット：1は、送信者は、それが破壊されていることTCBを持っていた場合はTビットが0に設定されているビット。送信者がTCBを持っていなかった場合には、このビットを1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.7)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "T bit: 1 bit The T bit is set to 0 if the sender filled in the Verification Tag expected by the peer. If the Verification Tag is reflected, the T bit MUST be set to 1. Reflecting means that the sent Verification Tag is the same as the received one.",
      "ja": "Tビット：1は、送信側がピアによって期待される検証タグ内に充填された場合にTビットが0に設定されているビット。検証タグが反映されている場合、Tビットは、送信された検証タグは、受信したものと同じであると反射手段を1に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.13)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "T bit: 1 bit The T bit is set to 0 if the sender had a TCB that it destroyed. If the sender did not have a TCB it should set this bit to 1.",
      "ja": "Tビット：1は、送信者は、それが破壊されていることTCBを持っていた場合はTビットが0に設定されているビット。送信者がTCBを持っていなかった場合には、このビットを1に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.13)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "T bit: 1 bit The T bit is set to 0 if the sender filled in the Verification Tag expected by the peer. If the Verification Tag is reflected, the T bit MUST be set to 1. Reflecting means that the sent Verification Tag is the same as the received one.",
      "ja": "Tビット：1は、送信側がピアによって期待される検証タグ内に充填された場合にTビットが0に設定されているビット。検証タグが反映されている場合、Tビットは、送信された検証タグは、受信したものと同じであると反射手段を1に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.4)\n---------",
      "raw": true
    },
    {
      "indent": 7,
      "text": "3) If the packet contains an INIT chunk with a Verification Tag\n   set to '0', process it as described in Section 5.1.\n   Otherwise,",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.4)\n---------\n    3) If the packet contains an INIT chunk with a Verification Tag\n      set to '0', process it as described in Section 5.1.  If, for\n      whatever reason, the INIT cannot be processed normally and\n      an ABORT has to be sent in response, the Verification Tag of\n      the packet containing the ABORT chunk MUST be the Initiate\n      tag of the received INIT chunk, and the T-Bit of the ABORT\n      chunk has to be set to 0, indicating that the Verification\n      Tag is NOT reflected.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.4)\n---------\n   5) If the packet contains a SHUTDOWN ACK chunk, the receiver\n      should respond to the sender of the OOTB packet with a\n      SHUTDOWN COMPLETE.  When sending the SHUTDOWN COMPLETE, the\n      receiver of the OOTB packet must fill in the Verification\n      Tag field of the outbound packet with the Verification Tag\n      received in the SHUTDOWN ACK and set the T-bit in the Chunk\n      Flags to indicate that no TCB was found.  Otherwise,",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.4)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "5) If the packet contains a SHUTDOWN ACK chunk, the receiver should respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE. When sending the SHUTDOWN COMPLETE, the receiver of the OOTB packet must fill in the Verification Tag field of the outbound packet with the Verification Tag received in the SHUTDOWN ACK and set the T-bit in the Chunk Flags to indicate that the Verification Tag is reflected. Otherwise,",
      "ja": "パケットがSHUTDOWN ACKチャンクが含まれている場合5）、受信機は、SHUTDOWNのCOMPLETEとOOTBパケットの送信者に応答する必要があります。 SHUTDOWNが完了し送信するとき、OOTBパケットの受信機は、シャットダウンACKに受信した検証タグとアウトバウンドパケットの検証タグフィールドに入力し、検証タグが反映されることを示すために、チャンクフラグにTビットを設定する必要があります。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.4)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "8) The receiver should respond to the sender of the OOTB packet with an ABORT. When sending the ABORT, the receiver of the OOTB packet MUST fill in the Verification Tag field of the outbound packet with the value found in the Verification Tag field of the OOTB packet and set the T-bit in the Chunk Flags to indicate that no TCB was found. After sending this ABORT, the receiver of the OOTB packet shall discard the OOTB packet and take no further action.",
      "ja": "8）受信機は、ABORTとOOTBパケットの送信者に応答すべきです。 ABORTを送信する場合、OOTBパケットの受信機はOOTBパケットの検証タグフィールドで見つかった値とアウトバウンドパケットの検証タグフィールドに入力し、その何のTCBがないことを示すためにチャンクフラグにTビットを設定しなければなりません発見された。このABORTを送信した後、OOTBパケットの受信機はOOTBパケットを破棄し、それ以上の措置を講じてはなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.4)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "8) The receiver should respond to the sender of the OOTB packet with an ABORT. When sending the ABORT, the receiver of the OOTB packet MUST fill in the Verification Tag field of the outbound packet with the value found in the Verification Tag field of the OOTB packet and set the T-bit in the Chunk Flags to indicate that the Verification Tag is reflected. After sending this ABORT, the receiver of the OOTB packet shall discard the OOTB packet and take no further action.",
      "ja": "8）受信機は、ABORTとOOTBパケットの送信者に応答すべきです。 ABORTを送信する場合、OOTBパケットの受信機はOOTBパケットの検証タグフィールドで見つかった値とアウトバウンドパケットの検証タグフィールドに入力し、その検証を示すためにチャンクフラグにTビットを設定しなければなりませんタグが反映されます。このABORTを送信した後、OOTBパケットの受信機はOOTBパケットを破棄し、それ以上の措置を講じてはなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.5.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "B) Rules for packet carrying ABORT:",
      "ja": "B）ABORTを運ぶパケットのためのルール："
    },
    {
      "indent": 9,
      "text": "- The endpoint shall always fill in the Verification Tag field of the outbound packet with the destination endpoint's tag value if it is known.",
      "ja": " - それがわかっている場合、エンドポイントは、常に宛先エンドポイントのタグ値とアウトバウンドパケットの検証タグフィールドに記入するものとします。"
    },
    {
      "indent": 9,
      "text": "- If the ABORT is sent in response to an OOTB packet, the endpoint MUST follow the procedure described in Section 8.4.",
      "ja": " -  ABORTはOOTBパケットに応答して送信された場合、エンドポイントは、8.4節で説明する手順に従わなければなりません。"
    },
    {
      "indent": 9,
      "text": "- The receiver MUST accept the packet if the Verification Tag matches either its own tag, OR the tag of its peer. Otherwise, the receiver MUST silently discard the packet and take no further action.",
      "ja": " - 検証タグは独自のタグ、またはそのピアのタグのいずれかと一致した場合、受信機はパケットを受け入れなければなりません。そうでない場合、受信機は静かにパケットを破棄し、それ以上の行動を取らないしなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.5.1)\n---------",
      "raw": true
    },
    {
      "indent": 5,
      "text": "B) Rules for packet carrying ABORT:",
      "ja": "B）ABORTを運ぶパケットのためのルール："
    },
    {
      "indent": 9,
      "text": "-  The endpoint MUST always fill in the Verification Tag\n   field of the outbound packet with the destination\n   endpoint's tag value, if it is known.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "- If the ABORT is sent in response to an OOTB packet, the endpoint MUST follow the procedure described in Section 8.4.",
      "ja": " -  ABORTはOOTBパケットに応答して送信された場合、エンドポイントは、8.4節で説明する手順に従わなければなりません。"
    },
    {
      "indent": 9,
      "text": "- The receiver of an ABORT MUST accept the packet if the Verification Tag field of the packet matches its own tag and the T bit is not set OR if it is set to its peer's tag and the T bit is set in the Chunk Flags. Otherwise, the receiver MUST silently discard the packet and take no further action.",
      "ja": " - パケットの検証タグフィールドは、独自のタグと一致し、Tビットがセットされていないか、それはそのピアのタグに設定された場合にTビットはチャンクフラグに設定されている場合、ABORTの受信機は、パケットを受け入れなければなりません。そうでない場合、受信機は静かにパケットを破棄し、それ以上の行動を取らないしなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.5.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "C) Rules for packet carrying SHUTDOWN COMPLETE:",
      "ja": "SHUTDOWNのCOMPLETEを運ぶパケットのためC）ルール："
    },
    {
      "indent": 9,
      "text": "- When sending a SHUTDOWN COMPLETE, if the receiver of the SHUTDOWN ACK has a TCB then the destination endpoint's tag MUST be used. Only where no TCB exists should the sender use the Verification Tag from the SHUTDOWN ACK.",
      "ja": " - シャットダウンCOMPLETEを送信するときSHUTDOWN ACKの受信機は、次に、TCBを有する場合、宛先エンドポイントのタグが使用されなければなりません。何TCBは、送信者はSHUTDOWNのACKから検証タグを使用する必要があります存在しない場合のみ。"
    },
    {
      "indent": 9,
      "text": "- The receiver of a SHUTDOWN COMPLETE shall accept the packet if the Verification Tag field of the packet matches its own tag OR it is set to its peer's tag and the T bit is set in the Chunk Flags. Otherwise, the receiver MUST silently discard the packet and take no further action. An endpoint MUST ignore the SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.",
      "ja": " - パケットの検証タグフィールドは、独自のタグが一致するか、そのピアのタグに設定されているとTビットはチャンクフラグに設定されている場合、COMPLETE SHUTDOWNの受信機がパケットを受け入れるもの。そうでない場合、受信機は静かにパケットを破棄し、それ以上の行動を取らないしなければなりません。それはSHUTDOWN-ACK-SENT状態にない場合、エンドポイントは、SHUTDOWNのCOMPLETEを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.5.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "C) Rules for packet carrying SHUTDOWN COMPLETE:",
      "ja": "SHUTDOWNのCOMPLETEを運ぶパケットのためC）ルール："
    },
    {
      "indent": 9,
      "text": "- When sending a SHUTDOWN COMPLETE, if the receiver of the SHUTDOWN ACK has a TCB, then the destination endpoint's tag MUST be used, and the T-bit MUST NOT be set. Only where no TCB exists should the sender use the Verification Tag from the SHUTDOWN ACK, and MUST set the T-bit.",
      "ja": " - シャットダウンCOMPLETEを送信するときSHUTDOWN ACKの受信機はTCBを有する場合、宛先エンドポイントのタグを使用しなければなりません、そしてTビットが設定されてはいけません。何TCBは、送信者はSHUTDOWNのACKから検証タグを使用する必要があり、そしてT-ビットを設定しなければなりません存在しない場合のみ。"
    },
    {
      "indent": 9,
      "text": "- The receiver of a SHUTDOWN COMPLETE shall accept the packet if the Verification Tag field of the packet matches its own tag and the T bit is not set OR if it is set to its peer's tag and the T bit is set in the Chunk Flags. Otherwise, the receiver MUST silently discard the packet and take no further action. An endpoint MUST ignore the SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.",
      "ja": " - パケットの検証タグフィールドは、独自のタグと一致し、Tビットがセットされていないか、それはそのピアのタグに設定された場合にTビットはチャンクフラグに設定されている場合、COMPLETE SHUTDOWNの受信機がパケットを受け入れるもの。そうでない場合、受信機は静かにパケットを破棄し、それ以上の行動を取らないしなければなりません。それはSHUTDOWN-ACK-SENT状態にない場合、エンドポイントは、SHUTDOWNのCOMPLETEを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.41.3. Solution Description",
      "section_title": true,
      "ja": "2.41.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The description of the T bit now clearly describes the semantic of the bit. The procedures for receiving the T bit have been clarified.",
      "ja": "Tビットの記述は、今はっきりビットの意味を説明しています。 Tビットを受信するための手順が明らかにされています。"
    },
    {
      "indent": 0,
      "text": "2.42. Unknown Parameter Handling",
      "section_title": true,
      "ja": "2.42。未知パラメータの処理"
    },
    {
      "indent": 0,
      "text": "2.42.1. Description of the Problem",
      "section_title": true,
      "ja": "2.42.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The description given in Section 2.33 does not state clearly whether an INIT-ACK or COOKIE-ECHO is sent.",
      "ja": "セクション2.33で与えられた説明は、INIT-ACKまたはCOOKIE-ECHO送信されるかどうかを明記しません。"
    },
    {
      "indent": 0,
      "text": "2.42.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.42.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "The changes given here already include changes suggested in Section 2.2, 2.27, and 2.33 of this document.",
      "ja": "ここで与えられた変更は、すでに2.2節で提案された変更、2.27、およびこのドキュメントの2.33が含まれます。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this SCTP packet and discard it do not process any further chunks within it.",
      "ja": "00  - このSCTPパケットの処理を停止し、それはそれ内の任意の更なるチャンクを処理しない捨てます。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "01  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理し、（ERRORのいずれかまたはINIT ACKで）「認識できないパラメータ型」で認識されていないパラメータを報告しません。"
    },
    {
      "indent": 3,
      "text": "10 - Skip this parameter and continue processing.",
      "ja": "10  - このパラメータをスキップして、処理を続行。"
    },
    {
      "indent": 3,
      "text": "11 - Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter Type' (in either an ERROR or in the INIT ACK).",
      "ja": "11  - このパラメータをスキップして、処理を続行しますが（ERRORのいずれかまたはINIT ACKで）「認識できないパラメータ型」で認識されていないパラメータを報告しています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.2.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "00 - Stop processing this parameter; do not process any further parameters within this chunk.",
      "ja": "00  - このパラメータの処理を停止。このチャンク内の任意の他のパラメータを処理しません。"
    },
    {
      "indent": 3,
      "text": "01 - Stop processing this parameter, do not process any further parameters within this chunk, and report the unrecognized parameter in an 'Unrecognized Parameter', as described in 3.2.2.",
      "ja": "01  - このチャンク内の任意の他のパラメータを処理していない、このパラメータの処理を停止し、3.2.2に記載されているように、「認識できないパラメータ」に認識されていないパラメータを報告します。"
    },
    {
      "indent": 3,
      "text": "10 - Skip this parameter and continue processing.",
      "ja": "10  - このパラメータをスキップして、処理を続行。"
    },
    {
      "indent": 3,
      "text": "11 - Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter', as described in 3.2.2.",
      "ja": "11  -  3.2.2に記載したように、このパラメータをスキップして処理を続行するが、「認識できないパラメータ」に認識されていないパラメータを報告します。"
    },
    {
      "indent": 3,
      "text": "Please note that in all four cases an INIT-ACK or COOKIE-ECHO chunk is sent. In the 00 or 01 case the processing of the parameters after the unknown parameter is canceled, but no processing already done is rolled back.",
      "ja": "4つのすべてのケースでINIT-ACKまたはCOOKIE-ECHOチャンクが送信されますのでご注意ください。 00または01の場合に未知パラメータの後にパラメータの処理がキャンセルされるが、既に行われない処理がロールバックされません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Note: no old text; clarification added in Section 3.2)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3.2.2. Reporting of Unrecognized Parameters",
      "section_title": true,
      "ja": "3.2.2。認識できないパラメータの報告"
    },
    {
      "indent": 6,
      "text": "If the receiver of an INIT chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it MUST put the 'Unrecognized Parameter' parameter(s) in the INIT-ACK chunk sent in response to the INIT-chunk. Note that if the receiver of the INIT chunk is NOT going to establish an association (e.g., due to lack of resources), an 'Unrecognized Parameter' would NOT be included with any ABORT being sent to the sender of the INIT.",
      "ja": "INITチャンクの受信機が認識できないパラメータを検出し、3.2.1項に従ってそれらを報告しなければならない場合、それはINITチャンクへの応答で送信されたINIT-ACKチャンクに「認識できないパラメータ」パラメータ（複数可）を置く必要があります。 INITチャンクの受信機は、（リソース不足のため、例えば）アソシエーションを確立しようとされていない場合は任意のABORTがINITの送信者に送信された状態で、「認識できないパラメータが」含まれないことに注意してください。"
    },
    {
      "indent": 6,
      "text": "If the receiver of an INIT-ACK chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it SHOULD bundle the ERROR chunk containing the 'Unrecognized Parameters' error cause with the COOKIE-ECHO chunk sent in response to the INIT-ACK chunk. If the receiver of the INIT-ACK cannot bundle the COOKIE-ECHO chunk with the ERROR chunk, the ERROR chunk MAY be sent separately but not before the COOKIE-ACK has been received.",
      "ja": "INIT-ACKチャンクの受信機が認識できないパラメータを検出し、3.2.1項に従ってそれらを報告しなければならない場合、それはINITに応答して送信されるCOOKIE-ECHOチャンクと「認識できないパラメーター」エラー原因を含むERRORチャンクをバンドルすべきです-ACKチャンク。 INIT-ACKの受信機はERRORチャンクでCOOKIE-ECHOチャンクをバンドルすることができない場合は、ERRORチャンクはCOOKIE-ACKが受信される前に個別にではなく、送信されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "Note: Any time a COOKIE-ECHO is sent in a packet, it MUST be the first chunk.",
      "ja": "注意：COOKIE-ECHOはパケットで送信されたすべての時間は、それは最初のチャンクでなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.42.3. Solution Description",
      "section_title": true,
      "ja": "2.42.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text clearly states that an INIT-ACK or COOKIE-ECHO has to be sent.",
      "ja": "新しいテキストは明らかにINIT-ACKまたはCOOKIE-ECHO送信されるようにしていると述べています。"
    },
    {
      "indent": 0,
      "text": "2.43. Cookie Echo Chunk",
      "section_title": true,
      "ja": "2.43。クッキーエコーチャンク"
    },
    {
      "indent": 0,
      "text": "2.43.1. Description of the Problem",
      "section_title": true,
      "ja": "2.43.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The description given in Section 3.3.11 of RFC 2960 [5] is unclear as to how the COOKIE-ECHO is composed.",
      "ja": "RFC 2960のセクション3.3.11での説明は、[5] COOKIE-ECHOが構成されている方法としては不明です。"
    },
    {
      "indent": 0,
      "text": "2.43.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.43.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.11)\n---------\n   Cookie: variable size",
      "raw": true
    },
    {
      "indent": 9,
      "text": "This field must contain the exact cookie received in the State\nCookie parameter from the previous INIT ACK.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "An implementation SHOULD make the cookie as small as possible to insure interoperability.",
      "ja": "実装は、相互運用性を保証するためにできる限りのクッキーは限り小さくすべきです。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.11)\n---------\n   Cookie: variable size",
      "raw": true
    },
    {
      "indent": 9,
      "text": "This field must contain the exact cookie received in the State\nCookie parameter from the previous INIT ACK.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "An implementation SHOULD make the cookie as small as possible to ensure interoperability.",
      "ja": "実装は、相互運用性を確保することができるようクッキーは限り小さくすべきです。"
    },
    {
      "indent": 9,
      "text": "Note: A Cookie Echo does NOT contain a State Cookie Parameter; instead, the data within the State Cookie's Parameter Value becomes the data within the Cookie Echo's Chunk Value. This allows an implementation to change only the first two bytes of the State Cookie parameter to become a Cookie Echo Chunk.",
      "ja": "注意：クッキーエコーは国家クッキーのパラメータが含まれていません。代わりに、国家クッキーのパラメータ値内のデータは、クッキーエコーのチャンク値内のデータとなります。これは、実装がクッキーエコーチャンクになるために州Cookieパラメタの最初の2バイトを変更することができます。"
    },
    {
      "indent": 0,
      "text": "2.43.3. Solution Description",
      "section_title": true,
      "ja": "2.43.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text adds a note that helps clarify that a Cookie Echo chunk is nothing more than the State Cookie parameter with only two bytes modified.",
      "ja": "新しいテキストは、クッキーエコー塊が変更のみ2バイトの州Cookieパラメタ以外の何物でもないことを明確にするのに役立ちますノートを追加します。"
    },
    {
      "indent": 0,
      "text": "2.44. Partial Chunks",
      "section_title": true,
      "ja": "2.44。部分的なチャンク"
    },
    {
      "indent": 0,
      "text": "2.44.1. Description of the Problem",
      "section_title": true,
      "ja": "2.44.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 6.10 of RFC 2960 [5] uses the notion of 'partial chunks' without defining it.",
      "ja": "RFC 2960のセクション6.10は、[5]、それを定義せずに「部分的チャンク」の概念を使用しています。"
    },
    {
      "indent": 0,
      "text": "2.44.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.44.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.10)\n---------\nPartial chunks MUST NOT be placed in an SCTP packet.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 6.10)\n---------\nPartial chunks MUST NOT be placed in an SCTP packet.  A partial\nchunk is a chunk that is not completely contained in the SCTP\npacket; i.e., the SCTP packet is too short to contain all the bytes\nof the chunk as indicated by the chunk length.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.44.3. Solution Description",
      "section_title": true,
      "ja": "2.44.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The new text adds a definition of 'partial chunks'.",
      "ja": "新しいテキストは、「部分的なチャンク」の定義を追加します。"
    },
    {
      "indent": 0,
      "text": "2.45. Non-unicast Addresses",
      "section_title": true,
      "ja": "2.45。非ユニキャストアドレス"
    },
    {
      "indent": 0,
      "text": "2.45.1. Description of the Problem",
      "section_title": true,
      "ja": "2.45.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 8.4 of RFC 2960 [5] forces the OOTB handling to discard all non-unicast addresses. This leaves future use of anycast addresses in question. With the addition of the add-ip feature, SCTP should be able to easily handle anycast INIT s that can be followed, after association setup, with a delete of the anycast address from the association.",
      "ja": "RFC 2960のセクション8.4には、[5]すべての非ユニキャストアドレスを廃棄するようにOOTB処理を強制します。これは、問題のエニーキャストアドレスの今後の使用を残します。アドオンIP機能の追加により、SCTPは簡単協会からのエニーキャストアドレスの削除と、関連のセットアップ後に続くことができるエニーキャストINIT Sを、扱うことができるはずです。"
    },
    {
      "indent": 0,
      "text": "2.45.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.45.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 8.4)\n---------\n8.4 Handle \"Out of the blue\" Packets",
      "raw": true
    },
    {
      "indent": 6,
      "text": "An SCTP packet is called an \"out of the blue\" (OOTB) packet if it is correctly formed, i.e., passed the receiver's Adler-32 check (see Section 6.8), but the receiver is not able to identify the association to which this packet belongs.",
      "ja": "それが正しく形成されている場合SCTPパケットは「青のうち」（OOTB）パケットと呼ばれている、すなわち、受信機のアドラー-32のチェック（6.8節を参照）を通過したが、受信機は、この先の関連性を識別することができませんパケットが属します。"
    },
    {
      "indent": 6,
      "text": "The receiver of an OOTB packet MUST do the following:",
      "ja": "OOTBパケットの受信機は、以下を行う必要があります。"
    },
    {
      "indent": 6,
      "text": "1) If the OOTB packet is to or from a non-unicast address, silently discard the packet. Otherwise,",
      "ja": "OOTBパケットが非ユニキャストアドレスへ又はからのものである場合は1）、静かにパケットを廃棄します。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 8.4)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8.4. Handle \"Out of the Blue\" Packets",
      "section_title": true,
      "ja": "8.4。パケット「ブルーのうち」ハンドル"
    },
    {
      "indent": 6,
      "text": "An SCTP packet is called an \"out of the blue\" (OOTB) packet if it is correctly formed (i.e., passed the receiver's CRC32c check; see Section 6.8), but the receiver is not able to identify the association to which this packet belongs.",
      "ja": "しかし、受信機は、このパケットが属する団体を識別することができません。それは正しく形成されている場合SCTPパケットは（6.8節を参照してくださいつまり、受信者のCRC32Cチェックに合格した）「青のうち」（OOTB）パケットと呼ばれています。"
    },
    {
      "indent": 6,
      "text": "The receiver of an OOTB packet MUST do the following:",
      "ja": "OOTBパケットの受信機は、以下を行う必要があります。"
    },
    {
      "indent": 6,
      "text": "1) If the OOTB packet is to or from a non-unicast address, a receiver SHOULD silently discard the packet. Otherwise,",
      "ja": "OOTBパケットが非ユニキャストアドレスへ又はからのものである場合は1）、受信機は静かにパケットを破棄すべきです。そうでなければ、"
    },
    {
      "indent": 0,
      "text": "2.45.3. Solution Description",
      "section_title": true,
      "ja": "2.45.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The loosening of the wording to a SHOULD will now allow future use of anycast addresses. Note that no changes are made to Section 11.2.4.1, since responding to broadcast addresses could lead to flooding attacks and implementors should pay careful attention to these words.",
      "ja": "SHOULDに文言の緩みは現在、エニーキャストアドレスの将来の使用が可能になります。変更がこれらの言葉に注意を払う必要がありフラッディング攻撃や実装につながる可能性があるブロードキャストアドレスに応答するので、セクション11.2.4.1に行われないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.46. Processing of ABORT Chunks",
      "section_title": true,
      "ja": "2.46。 ABORTチャンクの処理"
    },
    {
      "indent": 0,
      "text": "2.46.1. Description of the Problem",
      "section_title": true,
      "ja": "2.46.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 3.3.7 of RFC 2960 [5] requires an SCTP endpoint to silently discard ABORT chunks received for associations that do not exist. It is not clear what this means in the COOKIE-WAIT state, for example. Therefore, it was not clear whether an ABORT sent in response to an INIT should be processed or silently discarded.",
      "ja": "RFC 2960のセクション3.3.7には、[5]黙って存在していない団体のために受け取ったチャンクを中止破棄するSCTP端末が必要です。たとえば、COOKIE-WAIT状態で何を意味するのか明確ではありません。したがって、INITに応答して送信されたABORTを処理または静かに捨てなければならないかどうかは明らかではなかったです。"
    },
    {
      "indent": 0,
      "text": "2.46.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.46.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.7)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "If an endpoint receives an ABORT with a format error or for an association that doesn't exist, it MUST silently discard it.",
      "ja": "エンドポイントは、フォーマットエラーまたは存在しない関連ためABORTを受信した場合、それは静かにそれを捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.7)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "If an endpoint receives an ABORT with a format error or no TCB is found, it MUST silently discard it.",
      "ja": "エンドポイントは、フォーマットエラーでABORTを受信するか、または全くTCBが見つからない場合、それは静かにそれを捨てなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.46.3. Solution Description",
      "section_title": true,
      "ja": "2.46.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "It is now clearly stated that an ABORT chunk should be processed whenever a TCB is found.",
      "ja": "今はっきりとTCBが発見されるたびにABORTチャンクが処理されるべきであると述べています。"
    },
    {
      "indent": 0,
      "text": "2.47. Sending of ABORT Chunks",
      "section_title": true,
      "ja": "2.47。 ABORTチャンクの送信"
    },
    {
      "indent": 0,
      "text": "2.47.1. Description of the Problem",
      "section_title": true,
      "ja": "2.47.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "Section 5.1 of RFC 2960 [5] requires that an ABORT chunk be sent in response to an INIT chunk when there is no listening end point. To make port scanning harder, someone might not want these ABORTs to be received by the sender of the INIT chunks. Currently, the only way to enforce this is by using a firewall that discards the packets containing the INIT chunks or the packets containing the ABORT chunks. It is desirable that the same can be done without a middle box.",
      "ja": "RFC 2960のセクション5.1 [5]ないリスニングエンドポイントが存在しない場合ABORTチャンクはINITチャンクに応答して送信されることを必要とします。ポートスキャン困難にするために、誰かがこれらはINITチャンクの送信者が受信するアボートしたくない場合があります。現在、これを強制する唯一の方法は、INITチャンクまたはABORTチャンクを含むパケットを含むパケットを破棄し、ファイアウォールを使用することです。同じ中央のボックスなしで行うことができることが望ましいです。"
    },
    {
      "indent": 0,
      "text": "2.47.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.47.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO chunk but decides not to establish the new association due to missing mandatory parameters in the received INIT or INIT ACK, invalid parameter values, or lack of local resources, it MUST respond with an ABORT chunk.",
      "ja": "エンドポイントは、INIT、INIT ACK、またはCOOKIE ECHOチャンクを受信するが、受信INITまたはINIT ACKで必須パラメータ、無効なパラメータ値、またはローカルリソースの不足が欠けによる新しいアソシエーションを確立しないことを決定し、それがで応答しなければならない場合チャンクを中止します。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO chunk but decides not to establish the new association due to missing mandatory parameters in the received INIT or INIT ACK, invalid parameter values, or lack of local resources, it SHOULD respond with an ABORT chunk.",
      "ja": "エンドポイントは、INIT、INIT ACK、またはCOOKIE ECHOチャンクを受信するが、受信INITまたはINIT ACKで必須パラメータ、無効なパラメータ値、またはローカルリソースの不足が欠けによる新しいアソシエーションを確立しないことを決定し、それがで応答する必要がある場合チャンクを中止します。"
    },
    {
      "indent": 0,
      "text": "2.47.3. Solution Description",
      "section_title": true,
      "ja": "2.47.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The requirement of sending ABORT chunks is relaxed such that an implementation can decide not to send ABORT chunks.",
      "ja": "チャンクを中止送信の要件は、実装がABORTチャンクを送信しないことを決定することができるように緩和されます。"
    },
    {
      "indent": 0,
      "text": "2.48. Handling of Supported Address Types Parameter",
      "section_title": true,
      "ja": "2.48。サポートされているアドレス型パラメータの扱い"
    },
    {
      "indent": 0,
      "text": "2.48.1. Description of the Problem",
      "section_title": true,
      "ja": "2.48.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The sender of the INIT chunk can include a 'Supported Address Types' parameter to indicate which address families are supported. It is unclear how an INIT chunk should be processed where the source address of the packet containing the INIT chunk or listed addresses within the INIT chunk indicate that more address types are supported than those listed in the 'Supported Address Types' parameter.",
      "ja": "INITチャンクの送信者は、アドレスファミリがサポートされているかを示すために、「サポートされているアドレス型」パラメータを含めることができます。 INITチャンク内のINITチャンクまたは記載されているアドレスを含むパケットの送信元アドレスは、より多くのアドレスタイプは「サポートされているアドレス型」パラメータで指定されたものよりも、サポートされていることを示しているINITチャンクが処理されるべきかは不明です。"
    },
    {
      "indent": 0,
      "text": "2.48.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.48.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "The changes given here already include changes suggested in Section 2.28 of this document.",
      "ja": "ここで与えられた変更は、すでにこのドキュメントのセクション2.28に提案された変更が含まれます。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 5.1.2)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: In the case that the receiver of an INIT ACK fails to resolve the address parameter due to an unsupported type, it can abort the initiation process and then attempt a re-initiation by using a 'Supported Address Types' parameter in the new INIT to indicate what types of address it prefers.",
      "ja": "実装上の注意：INIT ACKの受信機が原因サポートされていないタイプのアドレスパラメータを解決するために失敗した場合は、開始プロセスを中止することができますし、新しい中に「サポートされているアドレス型」パラメータを使用して、再起動を試みますINITは、それが好むアドレスの種類を示します。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 5.1.2)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: In the case that the receiver of an INIT ACK fails to resolve the address parameter due to an unsupported type, it can abort the initiation process and then attempt a re-initiation by using a 'Supported Address Types' parameter in the new INIT to indicate what types of address it prefers.",
      "ja": "実装上の注意：INIT ACKの受信機が原因サポートされていないタイプのアドレスパラメータを解決するために失敗した場合は、開始プロセスを中止することができますし、新しい中に「サポートされているアドレス型」パラメータを使用して、再起動を試みますINITは、それが好むアドレスの種類を示します。"
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: If an SCTP endpoint that only supports either IPv4 or IPv6 receives IPv4 and IPv6 addresses in an INIT or INIT-ACK chunk from its peer, it MUST use all the addresses belonging to the supported address family. The other addresses MAY be ignored. The endpoint SHOULD NOT respond with any kind of error indication.",
      "ja": "実装上の注意：のみIPv4またはIPv6のいずれかをサポートしているSCTP終点はそのピアからのINITまたはINIT-ACKチャンクでIPv4アドレスとIPv6アドレスを受信した場合、それがサポートされるアドレスファミリに属する​​すべてのアドレスを使用しなければなりません。他のアドレスは無視してもよいです。エンドポイントは、エラー表示のいずれかの種類に応答すべきでありません。"
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: If an SCTP endpoint lists in the 'Supported Address Types' parameter either IPv4 or IPv6, but uses the other family for sending the packet containing the INIT chunk, or if it also lists addresses of the other family in the INIT chunk, then the address family that is not listed in the 'Supported Address Types' parameter SHOULD also be considered as supported by the receiver of the INIT chunk. The receiver of the INIT chunk SHOULD NOT respond with any kind of error indication.",
      "ja": "実装上の注意：「サポートされているアドレス型」パラメータIPv4またはIPv6のいずれかでSCTP終点リストがなく、INITチャンクを含むパケットを送信するために他の家族が使用している場合、またはそれはまた、INITチャンクに他の家族のアドレスをリストした場合、 INITチャンクの受信機でサポートされているとして、その後「サポートされているアドレス型」パラメータにリストされていないアドレスファミリも考慮すべきです。 INITチャンクの受信機は、エラー表示のいずれかの種類に応答すべきでありません。"
    },
    {
      "indent": 0,
      "text": "2.48.3. Solution Description",
      "section_title": true,
      "ja": "2.48.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "It is now clearly described how these Supported Address Types parameters with incorrect data should be handled.",
      "ja": "現在では、明確に誤ったデータとこれらのサポートされているアドレス型パラメータを処理する方法を説明しています。"
    },
    {
      "indent": 0,
      "text": "2.49. Handling of Unexpected Parameters",
      "section_title": true,
      "ja": "2.49。予期しないパラメータの取り扱い"
    },
    {
      "indent": 0,
      "text": "2.49.1. Description of the Problem",
      "section_title": true,
      "ja": "2.49.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "RFC 2960 [5] clearly describes how unknown parameters in the INIT and INIT-ACK chunk should be processed. But it is not described how unexpected parameters should be processed. A parameter is unexpected if it is known and is an optional parameter in either the INIT or INIT-ACK chunk but is received in the chunk for which it is not an optional parameter. For example, the 'Supported Address Types' parameter would be an unexpected parameter if contained in an INIT-ACK chunk.",
      "ja": "RFC 2960 [5]は明確にINITとINIT-ACKチャンク内の未知のパラメータを処理する方法について説明します。しかし、どのように処理すべきか、予想外のパラメータ説明されていません。それは知られており、INITまたはINIT-ACKチャンクのいずれかにおける任意のパラメータであるが、それはオプションのパラメータされていないチャンクに受信された場合、パラメータは予想外です。たとえば、「サポートされているアドレス型」パラメータはINIT-ACKチャンクに含まれている場合、予期しないパラメータになります。"
    },
    {
      "indent": 0,
      "text": "2.49.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.49.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.2)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Note 4: This parameter, when present, specifies all the address types the sending endpoint can support. The absence of this parameter indicates that the sending endpoint can support any address type.",
      "ja": "注4：このパラメータは、存在する場合、送信エンドポイントがサポートできるすべてのアドレスの種類を指定します。このパラメータが存在しない場合は、送信側エンドポイントが任意のアドレスタイプをサポートできることを示しています。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.2)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Note 4: This parameter, when present, specifies all the address types the sending endpoint can support. The absence of this parameter indicates that the sending endpoint can support any address type.",
      "ja": "注4：このパラメータは、存在する場合、送信エンドポイントがサポートできるすべてのアドレスの種類を指定します。このパラメータが存在しない場合は、送信側エンドポイントが任意のアドレスタイプをサポートできることを示しています。"
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: If an INIT chunk is received with known parameters that are not optional parameters of the INIT chunk then the receiver SHOULD process the INIT chunk and send back an INIT-ACK. The receiver of the INIT chunk MAY bundle an ERROR chunk with the COOKIE-ACK chunk later. However, restrictive implementations MAY send back an ABORT chunk in response to the INIT chunk.",
      "ja": "実装注：INITチャンクは、受信機は、INITチャンクを処理し、INIT-ACKを送り返すべきでINITチャンクのオプションのパラメータではない既知のパラメータを用いて受信された場合。 INITチャンクの受信機は、後にCOOKIE-ACKチャンクでERRORチャンクをバンドルするかもしれません。しかし、制限の実装はINITチャンクに対応してABORTチャンクを送り返します。"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.3)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: An implementation MUST be prepared to receive a INIT ACK that is quite large (more than 1500 bytes) due to the variable size of the state cookie AND the variable address list. For example if a responder to the INIT has 1000 IPv4 addresses it wishes to send, it would need at least 8,000 bytes to encode this in the INIT ACK.",
      "ja": "実装上の注意：実装が原因の状態クッキーの可変サイズと可変アドレス一覧にかなり大きいのINIT ACK（以上1500バイト）を受け取るように準備しなければなりません。 INITへの応答が1000のIPv4は、それが送信したいアドレスを持っている場合たとえば、それはINIT ACKでこれをエンコードするために、少なくとも8,000バイトが必要になります。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.3)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: An implementation MUST be prepared to receive a INIT ACK that is quite large (more than 1500 bytes) due to the variable size of the state cookie AND the variable address list. For example, if a responder to the INIT has 1000 IPv4 addresses it wishes to send, it would need at least 8,000 bytes to encode this in the INIT ACK.",
      "ja": "実装上の注意：実装が原因の状態クッキーの可変サイズと可変アドレス一覧にかなり大きいのINIT ACK（以上1500バイト）を受け取るように準備しなければなりません。 INITに応答1000のIPv4は、それが送信したいアドレスを有する場合、例えば、それがINIT ACKでこれを符号化するために、少なくとも8,000バイトを必要とします。"
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: If an INIT-ACK chunk is received with known parameters that are not optional parameters of the INIT-ACK chunk, then the receiver SHOULD process the INIT-ACK chunk and send back a COOKIE-ECHO. The receiver of the INIT-ACK chunk MAY bundle an ERROR chunk with the COOKIE-ECHO chunk. However, restrictive implementations MAY send back an ABORT chunk in response to the INIT-ACK chunk.",
      "ja": "実装注：INIT-ACKチャンクは、INIT-ACKチャンクのオプションのパラメータではない既知のパラメータを用いて受信された場合、受信機は、INIT-ACKチャンクを処理し、COOKIE-ECHOを送り返すべきです。 INIT-ACKチャンクの受信機は、COOKIE-ECHOチャンクとERRORチャンクをバンドルするかもしれません。しかし、制限の実装は、INIT-ACKチャンクに対応してABORTチャンクを送り返します。"
    },
    {
      "indent": 0,
      "text": "2.49.3. Solution Description",
      "section_title": true,
      "ja": "2.49.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "It is now stated how unexpected parameters should be processed.",
      "ja": "今どのように処理すべきか予想外のパラメータを記載されています。"
    },
    {
      "indent": 0,
      "text": "2.50. Payload Protocol Identifier",
      "section_title": true,
      "ja": "2.50。ペイロードプロトコル識別子"
    },
    {
      "indent": 0,
      "text": "2.50.1. Description of the Problem",
      "section_title": true,
      "ja": "2.50.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The current description of the payload protocol identifier does NOT highlight the fact that the field is NOT necessarily in network byte order.",
      "ja": "ペイロードプロトコル識別子の現在の記述は、フィールドはネットワークバイトオーダーに必然ではないという事実を強調しません。"
    },
    {
      "indent": 0,
      "text": "2.50.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.50.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 3.3.1)\n---------\n   Payload Protocol Identifier: 32 bits (unsigned integer)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "This value represents an application (or upper layer) specified\nprotocol identifier.  This value is passed to SCTP by its upper\nlayer and sent to its peer.  This identifier is not used by\nSCTP but can be used by certain network entities as well as\nthe peer application to identify the type of information being\ncarried in this DATA chunk.  This field must be sent even in\nfragmented DATA chunks (to make sure it is available for agents\nin the middle of the network).",
      "raw": true
    },
    {
      "indent": 9,
      "text": "The value 0 indicates no application identifier is specified by the upper layer for this payload data.",
      "ja": "値0は、アプリケーション識別子は、このペイロードデータの上位レイヤによって指定されていない示します。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text: (Section 3.3.1)\n---------\n   Payload Protocol Identifier: 32 bits (unsigned integer)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "This value represents an application (or upper layer) specified\nprotocol identifier.  This value is passed to SCTP by its upper\nlayer and sent to its peer.  This identifier is not used by\nSCTP but can be used by certain network entities, as well as by\nthe peer application, to identify the type of information being\ncarried in this DATA chunk.  This field must be sent even in\nfragmented DATA chunks (to make sure it is available for agents\nin the middle of the network).  Note that this field is NOT\ntouched by an SCTP implementation, therefore its byte order is\nNOT necessarily Big Endian.  The upper layer is responsible\nfor any byte order conversions to this field.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "The value 0 indicates that no application identifier is specified by the upper layer for this payload data.",
      "ja": "値0は、アプリケーション識別子は、このペイロードデータの上位レイヤによって指定されていないことを示しています。"
    },
    {
      "indent": 0,
      "text": "2.50.3. Solution Description",
      "section_title": true,
      "ja": "2.50.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "It is now explicitly stated that the upper layer is responsible for the byte order of this field.",
      "ja": "現在では、明示的に上位層がこのフィールドのバイト順に責任があると述べられています。"
    },
    {
      "indent": 0,
      "text": "2.51. Karn's Algorithm",
      "section_title": true,
      "ja": "2.51。カーンのアルゴリズム"
    },
    {
      "indent": 0,
      "text": "2.51.1. Description of the Problem",
      "section_title": true,
      "ja": "2.51.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The current wording of the use of Karn's algorithm is not descriptive enough to ensure that an implementation in a multi-homed association does not incorrectly mismeasure the RTT.",
      "ja": "カーンのアルゴリズムの使用の現在の文言は、マルチホームの関連での実装が間違ってRTTをmismeasureていないことを保証するのに十分説明的ではありません。"
    },
    {
      "indent": 0,
      "text": "2.51.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.51.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text: (Section 6.3.1)\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   C5) Karn's algorithm: RTT measurements MUST NOT be made using\n       packets that were retransmitted (and thus for which it is\n       ambiguous whether the reply was for the first instance of the\n       packet or a later instance)\n---------\nNew text: (Section 6.3.1)\n---------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "C5) Karn's algorithm: RTT measurements MUST NOT be made using chunks that were retransmitted (and thus for which it is ambiguous whether the reply was for the first instance of the chunk or for a later instance)",
      "ja": "C5）カーンのアルゴリズム：RTT測定値が再送信されたチャンクを使用して作製されてはいけません（したがって、そのため、応答がチャンクの最初のインスタンスまたは後、例えばあったかどうか曖昧です）"
    },
    {
      "indent": 10,
      "text": "IMPLEMENTATION NOTE: RTT measurements should only be\nmade using a chunk with TSN r if no chunk\nwith TSN less than or equal to r is retransmitted\nsince r is first sent.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.51.3. Solution Description",
      "section_title": true,
      "ja": "2.51.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above clarification adds an implementation note that will provide additional guidance in the application of Karn's algorithm.",
      "ja": "上記の明確化は、カーンのアルゴリズムのアプリケーションで追加のガイダンスを提供しますインプリメンテーション・ノートを追加します。"
    },
    {
      "indent": 0,
      "text": "2.52. Fast Retransmit Algorithm",
      "section_title": true,
      "ja": "2.52。高速再送アルゴリズム"
    },
    {
      "indent": 0,
      "text": "2.52.1. Description of the Problem",
      "section_title": true,
      "ja": "2.52.1。問題の説明"
    },
    {
      "indent": 3,
      "text": "The original SCTP specification is overly conservative in requiring 4 missing reports before fast retransmitting a segment. TCP uses 3 missing reports or 4 acknowledgements indicating that the same segment was received.",
      "ja": "元のSCTP仕様は高速セグメントを再送信する前に、4つの欠落レポートを必要に過度に保守的です。 TCPは、同じセグメントが受信されたことを示す3つの欠落レポートまたは4つの肯定応答を使用します。"
    },
    {
      "indent": 0,
      "text": "2.52.2. Text Changes to the Document",
      "section_title": true,
      "ja": "2.52.2。ドキュメントへのテキストの変更"
    },
    {
      "indent": 3,
      "text": "---------\nOld text:\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7.2.4 Fast Retransmit on Gap Reports",
      "section_title": true,
      "ja": "ギャップレポート上の7.2.4の高速再送信"
    },
    {
      "indent": 6,
      "text": "In the absence of data loss, an endpoint performs delayed acknowledgement. However, whenever an endpoint notices a hole in the arriving TSN sequence, it SHOULD start sending a SACK back every time a packet arrives carrying data until the hole is filled.",
      "ja": "データ損失の不在下で、エンドポイントは、遅延確認応答を行います。エンドポイントが到着TSNシーケンスの穴に気づいたときにしかし、それはバックパケットは穴が満たされるまで、データを運ぶ到着するたびにSACKの送信を開始すべきです。"
    },
    {
      "indent": 6,
      "text": "Whenever an endpoint receives a SACK that indicates some TSN(s) missing, it SHOULD wait for 3 further miss indications (via subsequent SACK's) on the same TSN(s) before taking action with regard to Fast Retransmit.",
      "ja": "エンドポイントが不足しているいくつかのTSNを示しSACK（複数可）を受信するたびに、高速再送信に関して行動を起こす前に、同じTSN（S）上の（その後のSACKの経由）3点の、さらにミスの指摘を待つべき。"
    },
    {
      "indent": 3,
      "text": "---------\nNew text:\n---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7.2.4. Fast Retransmit on Gap Reports",
      "section_title": true,
      "ja": "7.2.4。ギャップレポートの高速再送信"
    },
    {
      "indent": 6,
      "text": "In the absence of data loss, an endpoint performs delayed acknowledgement. However, whenever an endpoint notices a hole in the arriving TSN sequence, it SHOULD start sending a SACK back every time a packet arrives carrying data until the hole is filled.",
      "ja": "データ損失の不在下で、エンドポイントは、遅延確認応答を行います。エンドポイントが到着TSNシーケンスの穴に気づいたときにしかし、それはバックパケットは穴が満たされるまで、データを運ぶ到着するたびにSACKの送信を開始すべきです。"
    },
    {
      "indent": 6,
      "text": "Whenever an endpoint receives a SACK that indicates that some TSNs are missing, it SHOULD wait for 2 further miss indications (via subsequent SACKs for a total of 3 missing reports) on the same TSNs before taking action with regard to Fast Retransmit.",
      "ja": "エンドポイントはいくつかのTSNが欠落していることを示しているSACKを受信するたびに、それが高速再送信に関して行動を起こす前に、同じのTSN（3つの欠落しているレポートの合計のために、後続の袋を経由して）2点の、さらにミスの指摘を待つべき。"
    },
    {
      "indent": 0,
      "text": "2.52.3. Solution Description",
      "section_title": true,
      "ja": "2.52.3。ソリューションの説明"
    },
    {
      "indent": 3,
      "text": "The above changes will make SCTP and TCP behave similarly in terms of how fast they engage the Fast Retransmission algorithm upon receiving missing reports.",
      "ja": "上記の変更は、SCTPとTCPは、彼らが行方不明の報告を受けて、高速再送アルゴリズムに係合どのくらいの速の面で同様に振る舞うようになります。"
    },
    {
      "indent": 0,
      "text": "3. Security Considerations",
      "section_title": true,
      "ja": "3.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document should add no additional security risks to SCTP and in fact SHOULD correct some original security flaws within the original document once it is incorporated into a RFC 2960 [5] BIS document.",
      "ja": "この文書では、SCTPには追加のセキュリティリスクを追加してはならないし、それはRFC 2960 [5] BISの文書に組み込まれた後、実際には元の文書の中にいくつかのオリジナルセキュリティ上の欠陥を修正する必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Acknowledgements",
      "section_title": true,
      "ja": "4.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank the following people who have provided comments and input for this document:",
      "ja": "作者は、このドキュメントのコメントや入力を提供した以下の方々に感謝したいと思います："
    },
    {
      "indent": 3,
      "text": "Barry Zuckerman, La Monte Yarroll, Qiaobing Xie, Wang Xiaopeng, Jonathan Wood, Jeff Waskow, Mike Turner, John Townsend, Sabina Torrente, Cliff Thomas, Yuji Suzuki, Manoj Solanki, Sverre Slotte, Keyur Shah, Jan Rovins, Ben Robinson, Renee Revis, Ian Periam, RC Monee, Sanjay Rao, Sujith Radhakrishnan, Heinz Prantner, Biren Patel, Nathalie Mouellic, Mitch Miers, Bernward Meyknecht, Stan McClellan, Oliver Mayor, Tomas Orti Martin, Sandeep Mahajan, David Lehmann, Jonathan Lee, Philippe Langlois, Karl Knutson, Joe Keller, Gareth Keily, Andreas Jungmaier, Janardhan Iyengar, Mutsuya Irie, John Hebert, Kausar Hassan, Fred Hasle, Dan Harrison, Jon Grim, Laurent Glaude, Steven Furniss, Atsushi Fukumoto, Ken Fujita, Steve Dimig, Thomas Curran, Serkan Cil, Melissa Campbell, Peter Butler, Rob Brennan, Harsh Bhondwe, Brian Bidulock, Caitlin Bestler, Jon Berger, Robby Benedyk, Stephen Baucke, Sandeep Balani, and Ronnie Sellar.",
      "ja": "バリー・ズッカーマン、ラ・モンテYarroll、Qiaobing謝、王Xiaopeng、ジョナサン・ウッド、ジェフWaskow、マイク・ターナー、ジョン・タウンゼント、サビーナトレンテ、クリフ・トーマス、鈴木雄二、ManojさんSolanki、スヴェレSlotte、Keyurシャー、ヤンRovins、ベン・ロビンソン、レニーRevis、イアンPeriam、RCモニー、サンジャイ・ラオ、Sujithラダクリシュナン、ハインツPrantner、Birenパテル、ナタリーMouellic、ミッチMIERS、Bernward Meyknecht、スタン・マクレラン、オリバー市長、トマスORTIマーティン、サンディープマハジャン、デビッド・レーマン、ジョナサン・リー、フィリップ・ラングロワ、カール・Knutson、ジョー・ケラー、ガレスKeily、アンドレアスJungmaier、Janardhanアイアンガー、Mutsuya入江、ジョン・エベール、Kausarハッサン、フレッドハスレ、ダン・ハリスン、ジョン・グリム、ローランGlaude、スティーブン・Furniss、敦福本、ケン・藤田、スティーブDimig、トーマスカラン、セルカンCIL、メリッサ・キャンベル、ピーター・バトラー、ロブ・ブレナン、過酷なBhondwe、ブライアンBidulock、ケイトリンBestler、ジョン・バージャー、ロビーBenedyk、スティーブンBaucke、サンディープBalani、そしてロニートルコ鞍。"
    },
    {
      "indent": 3,
      "text": "A special thanks to Mark Allman, who should actually be a co-author for his work on the max-burst, but managed to wiggle out due to a technicality. Also, we would like to acknowledge Lyndon Ong and Phil Conrad for their valuable input and many contributions.",
      "ja": "実際には、最大バーストの彼の仕事のための共著者であってもよいが、原因専門的に出て小刻みに管理しなければならないマーク・オールマンに感謝、。また、我々は彼らの貴重な入力と多くの貢献のためにリンドン・オングとフィル・コンラッドを確認したいと思います。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document recommends changes for the RFC 2960 [5] BIS document. As such, even though it lists new error cause code, this document in itself does NOT define those new codes. Instead, the BIS document will make the needed changes to RFC 2960 [5] and thus its IANA section will require changes to be made.",
      "ja": "この文書は、RFC 2960 [5] BIS文書の変更を推奨しています。このように、それは新しいエラー原因コードの一覧を示していても、それ自体がこの文書では、これらの新しいコードを定義していません。代わりに、BIS文書はRFC 2960に必要な変更を行います[5]従ってそのIANAセクションが行われる変更が必要になります。"
    },
    {
      "indent": 0,
      "text": "6. Normative References",
      "section_title": true,
      "ja": "6.引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[1]ブレーデン、R.、 \"インターネットホストのための要件 - 通信層\"、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[2] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[2]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[3] Caro, A., Shah, K., Iyengar, J., Amer, P., and R. Stewart, \"SCTP and TCP Variants: Congestion Control Under Multiple Losses\", Technical Report TR2003-04, Computer and Information Sciences Department, University of Delaware, February 2003, <http://www.armandocaro.net/papers>.",
      "ja": "[3]カロ、A.、シャー、K.、アイアンガー、J.、アメール、P.、およびR.スチュワート、 \"SCTPとTCPバリアント：複数の損失の下で輻輳制御\"、技術報告書TR2003-04、コンピュータと情報科学科、デラウェア大学、2003年2月、<http://www.armandocaro.net/papers>。"
    },
    {
      "indent": 3,
      "text": "[4] Caro, A., Amer, P., and R. Stewart, \"Retransmission Schemes for End-to-end Failover with Transport Layer Multihoming\", GLOBECOM, November 2004., <http://www.armandocaro.net/papers>.",
      "ja": "[4]カロ、A.、アメール、P.、およびR.スチュワート、「トランスポート層マルチホーミングとエンドツーエンドのフェイルオーバーのための再送制御法」、GLOBECOM、2004年11月、<http://www.armandocaro.net /論文>。"
    },
    {
      "indent": 3,
      "text": "[5] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L., and V. Paxson, \"Stream Control Transmission Protocol\", RFC 2960, October 2000.",
      "ja": "[5]スチュワート、R.、謝、Q.、Morneault、K.、シャープ、C.、Schwarzbauer、H.、テイラー、T.、Rytina、I.、カラ、M.、チャン、L.、およびV 。パクソン、 \"ストリーム制御伝送プロトコル\"、RFC 2960、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[6] Stone, J., Stewart, R., and D. Otis, \"Stream Control Transmission Protocol (SCTP) Checksum Change\", RFC 3309, September 2002.",
      "ja": "[6]石、J.、スチュワート、R.、およびD.オーティス、 \"ストリーム制御伝送プロトコル（SCTP）チェックサムの変更\"、RFC 3309、2002年9月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Randall R. Stewart Cisco Systems, Inc. 4875 Forest Drive Suite 200 Columbia, SC 29206 USA",
      "ja": "ランドールR.スチュワートシスコシステムズ社4875森ドライブスイート200コロンビア、SC 29206 USA"
    },
    {
      "indent": 3,
      "text": "EMail: rrs@cisco.com",
      "ja": "メールアドレス：rrs@cisco.com"
    },
    {
      "indent": 3,
      "text": "Ivan Arias-Rodriguez Nokia Research Center PO Box 407 FIN-00045 Nokia Group Finland",
      "ja": "イヴァン・アリアス・ロドリゲスノキア・リサーチセンター私書箱407 FIN-00045 Nokiaのグループフィンランド"
    },
    {
      "indent": 3,
      "text": "EMail: ivan.arias-rodriguez@nokia.com",
      "ja": "メールアドレス：ivan.arias-rodriguez@nokia.com"
    },
    {
      "indent": 3,
      "text": "Kacheong Poon Sun Microsystems, Inc. 3571 N. First St. San Jose, CA 95134 USA",
      "ja": "Kacheongプーンサン・マイクロシステムズ株式会社3571 N.まず聖サンノゼ、CA 95134 USA"
    },
    {
      "indent": 3,
      "text": "EMail: kacheong.poon@sun.com",
      "ja": "メールアドレス：kacheong.poon@sun.com"
    },
    {
      "indent": 3,
      "text": "Armando L. Caro Jr. BBN Technologies 10 Moulton St. Cambridge, MA 02138",
      "ja": "アルマンド・L.カロジュニアBBNテクノロジーズ10モールトンセントケンブリッジ、MA 02138"
    },
    {
      "indent": 3,
      "text": "EMail: acaro@bbn.com URI: http://www.armandocaro.net",
      "ja": "電子メール：acaro@bbn.com URI：http://www.armandocaro.net"
    },
    {
      "indent": 3,
      "text": "Michael Tuexen Muenster Univ. of Applied Sciences Stegerwaldstr. 39 48565 Steinfurt Germany",
      "ja": "マイケルTuexenミュンスター大学。応用科学Stegerwaldstrの。 39 48565シュタインフルトドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: tuexen@fh-muenster.de",
      "ja": "メールアドレス：tuexen@fh-muenster.de"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディタ機能のための資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}