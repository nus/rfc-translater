{
  "title": {
    "text": "RFC 4340 - Datagram Congestion Control Protocol (DCCP)",
    "ja": "RFC 4340 - データグラム輻輳制御プロトコル（DCCP）"
  },
  "number": 4340,
  "created_at": "2019-10-23 18:12:49.832735+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          E. Kohler\nRequest for Comments: 4340                                          UCLA\nCategory: Standards Track                                     M. Handley\n                                                                     UCL\n                                                                S. Floyd\n                                                                    ICIR\n                                                              March 2006",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Datagram Congestion Control Protocol (DCCP)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Datagram Congestion Control Protocol (DCCP) is a transport protocol that provides bidirectional unicast connections of congestion-controlled unreliable datagrams. DCCP is suitable for applications that transfer fairly large amounts of data and that can benefit from control over the tradeoff between timeliness and reliability.",
      "ja": "データグラム輻輳制御プロトコル（DCCP）が輻輳制御信頼性のないデータグラムの双方向のユニキャスト接続を提供するトランスポート・プロトコルです。 DCCPはデータのかなり大きな金額を転送し、それがタイムリーかつ信頼性の間のトレードオフを制御の恩恵を受けることができるアプリケーションに適しています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n2. Design Rationale ................................................6\n3. Conventions and Terminology .....................................7\n   3.1. Numbers and Fields .........................................7\n   3.2. Parts of a Connection ......................................8\n   3.3. Features ...................................................9\n   3.4. Round-Trip Times ...........................................9\n   3.5. Security Limitation ........................................9\n   3.6. Robustness Principle ......................................10\n4. Overview .......................................................10\n   4.1. Packet Types ..............................................10\n   4.2. Packet Sequencing .........................................11\n   4.3. States ....................................................12\n   4.4. Congestion Control Mechanisms .............................14",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   4.5. Feature Negotiation Options ...............................15\n   4.6. Differences from TCP ......................................16\n   4.7. Example Connection ........................................17\n5. Packet Formats .................................................18\n   5.1. Generic Header ............................................19\n   5.2. DCCP-Request Packets ......................................22\n   5.3. DCCP-Response Packets .....................................23\n   5.4. DCCP-Data, DCCP-Ack, and DCCP-DataAck Packets .............23\n   5.5. DCCP-CloseReq and DCCP-Close Packets ......................25\n   5.6. DCCP-Reset Packets ........................................25\n   5.7. DCCP-Sync and DCCP-SyncAck Packets ........................28\n   5.8. Options ...................................................29\n        5.8.1. Padding Option .....................................31\n        5.8.2. Mandatory Option ...................................31\n6. Feature Negotiation ............................................32\n   6.1. Change Options ............................................32\n   6.2. Confirm Options ...........................................33\n   6.3. Reconciliation Rules ......................................33\n        6.3.1. Server-Priority ....................................34\n        6.3.2. Non-Negotiable .....................................34\n   6.4. Feature Numbers ...........................................35\n   6.5. Feature Negotiation Examples ..............................36\n   6.6. Option Exchange ...........................................37\n        6.6.1. Normal Exchange ....................................38\n        6.6.2. Processing Received Options ........................38\n        6.6.3. Loss and Retransmission ............................40\n        6.6.4. Reordering .........................................41\n        6.6.5. Preference Changes .................................42\n        6.6.6. Simultaneous Negotiation ...........................42\n        6.6.7. Unknown Features ...................................43\n        6.6.8. Invalid Options ....................................43\n        6.6.9. Mandatory Feature Negotiation ......................44\n7. Sequence Numbers ...............................................44\n   7.1. Variables .................................................45\n   7.2. Initial Sequence Numbers ..................................45\n   7.3. Quiet Time ................................................46\n   7.4. Acknowledgement Numbers ...................................47\n   7.5. Validity and Synchronization ..............................47\n        7.5.1. Sequence and Acknowledgement Number Windows ........48\n        7.5.2. Sequence Window Feature ............................49\n        7.5.3. Sequence-Validity Rules ............................49\n        7.5.4. Handling Sequence-Invalid Packets ..................51\n        7.5.5. Sequence Number Attacks ............................52\n        7.5.6. Sequence Number Handling Examples ..................54\n   7.6. Short Sequence Numbers ....................................55\n        7.6.1. Allow Short Sequence Numbers Feature ...............55\n        7.6.2. When to Avoid Short Sequence Numbers ...............56\n   7.7. NDP Count and Detecting Application Loss ..................56",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        7.7.1. NDP Count Usage Notes ..............................57\n        7.7.2. Send NDP Count Feature .............................57\n8. Event Processing ...............................................58\n   8.1. Connection Establishment ..................................58\n        8.1.1. Client Request .....................................58\n        8.1.2. Service Codes ......................................59\n        8.1.3. Server Response ....................................61\n        8.1.4. Init Cookie Option .................................62\n        8.1.5. Handshake Completion ...............................63\n   8.2. Data Transfer .............................................63\n   8.3. Termination ...............................................64\n        8.3.1. Abnormal Termination ...............................66\n   8.4. DCCP State Diagram ........................................66\n   8.5. Pseudocode ................................................67\n9. Checksums ......................................................72\n   9.1. Header Checksum Field .....................................73\n   9.2. Header Checksum Coverage Field ............................73\n        9.2.1. Minimum Checksum Coverage Feature ..................74\n   9.3. Data Checksum Option ......................................75\n        9.3.1. Check Data Checksum Feature ........................76\n        9.3.2. Checksum Usage Notes ...............................76\n10. Congestion Control ............................................76\n   10.1. TCP-like Congestion Control ..............................77\n   10.2. TFRC Congestion Control ..................................78\n   10.3. CCID-Specific Options, Features, and Reset Codes .........78\n   10.4. CCID Profile Requirements ................................80\n   10.5. Congestion State .........................................81\n11. Acknowledgements ..............................................81\n   11.1. Acks of Acks and Unidirectional Connections ..............82\n   11.2. Ack Piggybacking .........................................83\n   11.3. Ack Ratio Feature ........................................84\n   11.4. Ack Vector Options .......................................85\n        11.4.1. Ack Vector Consistency ............................88\n        11.4.2. Ack Vector Coverage ...............................89\n   11.5. Send Ack Vector Feature ..................................90\n   11.6. Slow Receiver Option .....................................90\n   11.7. Data Dropped Option ......................................91\n        11.7.1. Data Dropped and Normal Congestion Response .......94\n        11.7.2. Particular Drop Codes .............................95\n12. Explicit Congestion Notification ..............................96\n   12.1. ECN Incapable Feature ....................................96\n   12.2. ECN Nonces ...............................................97\n   12.3. Aggression Penalties .....................................98\n13. Timing Options ................................................99\n   13.1. Timestamp Option .........................................99\n   13.2. Elapsed Time Option ......................................99\n   13.3. Timestamp Echo Option ...................................100\n14. Maximum Packet Size ..........................................101",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   14.1. Measuring PMTU ..........................................102\n   14.2. Sender Behavior .........................................103\n15. Forward Compatibility ........................................104\n16. Middlebox Considerations .....................................105\n17. Relations to Other Specifications ............................106\n   17.1. RTP .....................................................106\n   17.2. Congestion Manager and Multiplexing .....................108\n18. Security Considerations ......................................108\n   18.1. Security Considerations for Partial Checksums ...........109\n19. IANA Considerations ..........................................110\n   19.1. Packet Types Registry ...................................110\n   19.2. Reset Codes Registry ....................................110\n   19.3. Option Types Registry ...................................110\n   19.4. Feature Numbers Registry ................................111\n   19.5. Congestion Control Identifiers Registry .................111\n   19.6. Ack Vector States Registry ..............................111\n   19.7. Drop Codes Registry .....................................112\n   19.8. Service Codes Registry ..................................112\n   19.9. Port Numbers Registry ...................................112\n20. Thanks .......................................................114\nA.  Appendix: Ack Vector Implementation Notes ....................116\n    A.1. Packet Arrival ..........................................118\n         A.1.1. New Packets ......................................118\n         A.1.2. Old Packets ......................................119\n    A.2. Sending Acknowledgements ................................120\n    A.3. Clearing State ..........................................120\n    A.4. Processing Acknowledgements .............................122\nB.  Appendix: Partial Checksumming Design Motivation .............123\nNormative References .............................................124\nInformative References ...........................................125",
      "raw": true
    },
    {
      "indent": 0,
      "text": "List of Tables",
      "ja": "テーブルのリスト"
    },
    {
      "indent": 3,
      "text": "Table 1: DCCP Packet Types .......................................21\nTable 2: DCCP Reset Codes ........................................28\nTable 3: DCCP Options ............................................30\nTable 4: DCCP Feature Numbers.....................................35\nTable 5: DCCP Congestion Control Identifiers .....................77\nTable 6: DCCP Ack Vector States ..................................86\nTable 7: DCCP Drop Codes .........................................92",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Datagram Congestion Control Protocol (DCCP) is a transport protocol that implements bidirectional, unicast connections of congestion-controlled, unreliable datagrams. Specifically, DCCP provides the following:",
      "ja": "データグラム輻輳制御プロトコル（DCCP）は、輻輳制御、信頼性のないデータグラムの双方向のユニキャスト接続を実装するトランスポート・プロトコルです。具体的には、DCCPは、以下の機能を提供します。"
    },
    {
      "indent": 3,
      "text": "o Unreliable flows of datagrams.",
      "ja": "データグラムの信頼性の低いフローO。"
    },
    {
      "indent": 3,
      "text": "o Reliable handshakes for connection setup and teardown.",
      "ja": "接続セットアップとティアダウンのための信頼性の高い握手O。"
    },
    {
      "indent": 3,
      "text": "o Reliable negotiation of options, including negotiation of a suitable congestion control mechanism.",
      "ja": "適した輻輳制御機構の交渉など、オプションのO信頼性交渉、。"
    },
    {
      "indent": 3,
      "text": "o Mechanisms allowing servers to avoid holding state for unacknowledged connection attempts and already-finished connections.",
      "ja": "メカニズムoをサーバが未確認の接続試行と、すでに完成の接続の状態を保持しないようすることができます。"
    },
    {
      "indent": 3,
      "text": "o Congestion control incorporating Explicit Congestion Notification (ECN) [RFC3168] and the ECN Nonce [RFC3540].",
      "ja": "明示的輻輳通知（ECN）[RFC3168]及びECNノンス[RFC3540]を組み込むO輻輳制御。"
    },
    {
      "indent": 3,
      "text": "o Acknowledgement mechanisms communicating packet loss and ECN information. Acks are transmitted as reliably as the relevant congestion control mechanism requires, possibly completely reliably.",
      "ja": "O肯定応答メカニズムは、パケットロス及びECN情報を通信します。 ACKは、関連する輻輳制御機構は、おそらく完全に確実に、必要な限り確実に伝達されます。"
    },
    {
      "indent": 3,
      "text": "o Optional mechanisms that tell the sending application, with high reliability, which data packets reached the receiver, and whether those packets were ECN marked, corrupted, or dropped in the receive buffer.",
      "ja": "データパケットが受信機に到達し、それらのパケットがECNマークされたかどうか、破損し、または受信バッファに滴下高い信頼性と、送信アプリケーションを伝える任意のメカニズムを、O。"
    },
    {
      "indent": 3,
      "text": "o Path Maximum Transmission Unit (PMTU) discovery [RFC1191].",
      "ja": "Oパス最大伝送単位（PMTU）の発見[RFC1191]。"
    },
    {
      "indent": 3,
      "text": "o A choice of modular congestion control mechanisms. Two mechanisms are currently specified: TCP-like Congestion Control [RFC4341] and TCP-Friendly Rate Control (TFRC) [RFC4342]. DCCP is easily extensible to further forms of unicast congestion control.",
      "ja": "Oモジュール式の輻輳制御機構の選択。 TCPのような輻輳制御を[RFC4341]とTCPフレンドリーレート制御（TFRC）[RFC4342]：二つのメカニズムは、現在指定されています。 DCCPは、ユニキャスト輻輳制御の更なる形態に容易に拡張可能です。"
    },
    {
      "indent": 3,
      "text": "DCCP is intended for applications such as streaming media that can benefit from control over the tradeoffs between delay and reliable in-order delivery. TCP is not well suited for these applications, since reliable in-order delivery and congestion control can cause arbitrarily long delays. UDP avoids long delays, but UDP applications that implement congestion control must do so on their own. DCCP provides built-in congestion control, including ECN support, for unreliable datagram flows, avoiding the arbitrary delays associated with TCP. It also implements reliable connection setup, teardown, and feature negotiation.",
      "ja": "DCCPは、遅延および信頼性における順序配信の間のトレードオフに対する制御から利益を得ることができるようなストリーミングメディアなどのアプリケーションのために意図されています。信頼性の高い順序どおりの配信と輻輳制御が任意に長い遅延が発生する可能性がありますので、TCPは、これらのアプリケーションには適していません。 UDPは、長い遅延を回避できますが、輻輳制御を実装するUDPアプリケーションは自分で行う必要があります。 DCCPはTCPに関連付けられている任意の遅延を回避信頼性のないデータグラムフローのECNのサポート、を含む、内蔵の輻輳制御を提供します。また、信頼性の高い接続のセットアップ、ティアダウン、および機能のネゴシエーションを実装しています。"
    },
    {
      "indent": 0,
      "text": "2. Design Rationale",
      "section_title": true,
      "ja": "2.デザイン理論的根拠"
    },
    {
      "indent": 3,
      "text": "One DCCP design goal was to give most streaming UDP applications little reason not to switch to DCCP, once it is deployed. To facilitate this, DCCP was designed to have as little overhead as possible, both in terms of the packet header size and in terms of the state and CPU overhead required at end hosts. Only the minimal necessary functionality was included in DCCP, leaving other functionality, such as forward error correction (FEC), semi-reliability, and multiple streams, to be layered on top of DCCP as desired.",
      "ja": "一つDCCPの設計目標は、それが展開されると、DCCPに切り替えていないほとんどのストリーミングUDPアプリケーション少し理由を与えることでした。これを容易にするために、DCCPは、パケットヘッダサイズの観点とエンドホストに必要な状態とCPUオーバーヘッドの点で両方の、可能な限り少ないオーバーヘッドを有するように設計しました。最小限の必要な機能は、所望のようにDCCPの上部に積層される、このような順方向誤り訂正（FEC）、半信頼性、および複数のストリームとして、他の機能を残し、DCCPに含まれていました。"
    },
    {
      "indent": 3,
      "text": "Different forms of conformant congestion control are appropriate for different applications. For example, on-line games might want to make quick use of any available bandwidth, while streaming media might trade off this responsiveness for a steadier, less bursty rate. (Sudden rate changes can cause unacceptable UI glitches such as audible pauses or clicks in the playout stream.) DCCP thus allows applications to choose from a set of congestion control mechanisms. One alternative, TCP-like Congestion Control, halves the congestion window in response to a packet drop or mark, as in TCP. Applications using this congestion control mechanism will respond quickly to changes in available bandwidth, but must tolerate the abrupt changes in congestion window typical of TCP. A second alternative, TCP-Friendly Rate Control (TFRC) [RFC3448], a form of equation-based congestion control, minimizes abrupt changes in the sending rate while maintaining longer-term fairness with TCP. Other alternatives can be added as future congestion control mechanisms are standardized.",
      "ja": "準拠輻輳制御の異なる形式は、さまざまなアプリケーションに適しています。例えば、オンラインゲームは、ストリーミングメディアがより安定し、より少ないバースト性率のために、この応答性のトレードオフかもしれないが、任意の利用可能な帯域幅を迅速に活用したい場合があります。 （突然の速度変化は、再生ストリーム内の可聴休止またはクリックなどの容認できないUIの不具合を引き起こす可能性がある。）DCCP従ってアプリケーションが輻輳制御機構のセットから選択することができます。一つの代替、TCPのような輻輳制御は、TCPのように、パケットのドロップまたはマークに対応して混雑ウィンドウを半分にします。この輻輳制御機構を使用するアプリケーションは、利用可能な帯域幅の変化に迅速に対応しますが、TCPの典型的な輻輳ウィンドウの急激な変化に耐えなければなりません。 TCPと長期的公平性を維持しながら、第二の代替、TCPフレンドリーレート制御（TFRC）[RFC3448]は、方程式ベースの輻輳制御の形態は、送信レートの急激な変化を最小限に抑えます。将来の輻輳制御機構が標準化されているように、他の選択肢を追加することができます。"
    },
    {
      "indent": 3,
      "text": "DCCP also lets unreliable traffic safely use ECN. A UDP kernel Application Programming Interface (API) might not allow applications to set UDP packets as ECN capable, since the API could not guarantee that the application would properly detect or respond to congestion. DCCP kernel APIs will have no such issues, since DCCP implements congestion control itself.",
      "ja": "DCCPはまた、信頼できないトラフィックが安全にECNを使用することができます。 UDPカーネルアプリケーションプログラミングインターフェイス（API）は、APIは、アプリケーションが適切に検出または混雑に応答することを保証することができませんでしたので、アプリケーションは、可能ECNとしてUDPパケットを設定することができない場合があります。 DCCPは輻輳制御自体を実装しているのでDCCPカーネルAPIは、そのような問題を持っていません。"
    },
    {
      "indent": 3,
      "text": "We chose not to require the use of the Congestion Manager [RFC3124], which allows multiple concurrent streams between the same sender and receiver to share congestion control. The current Congestion Manager can only be used by applications that have their own end-to-end feedback about packet losses, but this is not the case for many of the applications currently using UDP. In addition, the current Congestion Manager does not easily support multiple congestion control mechanisms or mechanisms where the state about past packet drops or marks is maintained at the receiver rather than the sender. DCCP should be able to make use of CM where desired by the application, but we do not see any benefit in making the deployment of DCCP contingent on the deployment of CM itself.",
      "ja": "私たちは、同じ送信者と受信者の間で複数の同時ストリームが輻輳制御を共有することができます輻輳マネージャ[RFC3124]の使用を必要としないことを選びました。現在の輻輳Managerは、パケットロスについて、独自のエンドツーエンドのフィードバックを持っているアプリケーションで使用することができますが、これは現在、UDPを使用したアプリケーションの多くの場合はそうではありません。加えて、現在の輻輳管理を容易に過去のパケットドロップまたはマークに関する状態が受信機ではなく送信側で維持される複数の輻輳制御機構または機構をサポートしていません。 DCCPは、アプリケーションが希望するCMを利用することができるはずですが、私たちはCM自体の展開にDCCPの偶発の展開を行う際にどんな利益が表示されません。"
    },
    {
      "indent": 3,
      "text": "We intend for DCCP's protocol mechanisms, which are described in this document, to suit any application desiring unicast congestion-controlled streams of unreliable datagrams. However, the congestion control mechanisms currently approved for use with DCCP, which are described in separate Congestion Control ID Profiles [RFC4341, RFC4342], may cause problems for some applications, including high-bandwidth interactive video. These applications should be able to use DCCP once suitable Congestion Control ID Profiles are standardized.",
      "ja": "私たちは、信頼性のないデータグラムのユニキャスト輻輳制御の流れを望む任意のアプリケーションに合うように、このドキュメントで説明されているDCCPのプロトコルメカニズム、のために意図しています。しかし、現在、別輻輳制御IDプロファイルに記載されているDCCP、[RFC4341、RFC4342]で使用するために承認された輻輳制御メカニズムは、高帯域幅のインタラクティブビデオを含むいくつかの用途のために問題を引き起こす可能性があります。これらのアプリケーションは、一度、適切な輻輳制御IDプロファイルが標準化されているDCCPを使用することができるはずです。"
    },
    {
      "indent": 0,
      "text": "3. Conventions and Terminology",
      "section_title": true,
      "ja": "3.表記と用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3.1. Numbers and Fields",
      "section_title": true,
      "ja": "3.1. 数字とフィールド"
    },
    {
      "indent": 3,
      "text": "All multi-byte numerical quantities in DCCP, such as port numbers, Sequence Numbers, and arguments to options, are transmitted in network byte order (most significant byte first).",
      "ja": "そのようなポート番号、シーケンス番号、およびオプションの引数としてDCCPのすべてのマルチバイト数量は、ネットワークバイト順（最上位バイト）で送信されます。"
    },
    {
      "indent": 3,
      "text": "We occasionally refer to the \"left\" and \"right\" sides of a bit field. \"Left\" means towards the most significant bit, and \"right\" means towards the least significant bit.",
      "ja": "私たちは、時折ビットフィールドの「左」と「右」の側面を参照してください。 「左」、最上位ビットの方を意味し、「右」は最下位ビットの方を意味します。"
    },
    {
      "indent": 3,
      "text": "Random numbers in DCCP are used for their security properties and SHOULD be chosen according to the guidelines in [RFC4086].",
      "ja": "DCCPにおける乱数は、それらのセキュリティ特性のために使用され、[RFC4086]のガイドラインに従って選択されるべきです。"
    },
    {
      "indent": 3,
      "text": "All operations on DCCP sequence numbers use circular arithmetic modulo 2^48, as do comparisons such as \"greater\" and \"greatest\". This form of arithmetic preserves the relationships between sequence numbers as they roll over from 2^48 - 1 to 0. Implementation strategies for DCCP sequence numbers will resemble those for other circular arithmetic spaces, including TCP's sequence numbers [RFC793] and DNS's serial numbers [RFC1982]. It may make sense to store DCCP sequence numbers in the most significant 48 bits of 64-bit integers and set the least significant 16 bits to zero, since this supports a common technique that implements circular comparison A < B by testing whether (A - B) < 0 using conventional two's-complement arithmetic.",
      "ja": "そのような「大きい」と「最大」などの比較がそうであるようにDCCPのシーケンス番号に対するすべての操作は、円形算術法2 ^ 48を使用しています。 TCPのシーケンス番号[RFC793]とDNSのシリアル番号[含む他の円形の演算空間のものに似ているであろうDCCP配列番号1 0に実装戦略 - これらは2 ^ 48からロールオーバー等の演算のこの形態は、シーケンス番号との間の関係を維持しますRFC1982]。 B  - これは（Aかどうかをテストすることにより円形の比較A <Bを実装する一般的な技術をサポートするので、それは、64ビット整数の最上位48ビットにDCCPシーケンス番号を格納し、ゼロに最下位16ビットを設定しても意味ができます）<0従来の2の補数演算を使用して。"
    },
    {
      "indent": 3,
      "text": "Reserved bitfields in DCCP packet headers MUST be set to zero by senders and MUST be ignored by receivers, unless otherwise specified. This allows for future protocol extensions. In particular, DCCP processors MUST NOT reset a DCCP connection simply because a Reserved field has non-zero value [RFC3360].",
      "ja": "DCCPパケットヘッダ内の予約ビットフィールドは送信者によってゼロに設定しなければならなくて、特に断らない限り、受信機によって無視されなければなりません。これは、将来のプロトコル拡張が可能になります。 Reservedフィールドが非ゼロ値[RFC3360]を有しているという理由だけで、特に、DCCPプロセッサはDCCP接続をリセットしてはいけません。"
    },
    {
      "indent": 0,
      "text": "3.2. Parts of a Connection",
      "section_title": true,
      "ja": "3.2. 接続のパーツ"
    },
    {
      "indent": 3,
      "text": "Each DCCP connection runs between two hosts, which we often name DCCP A and DCCP B. Each connection is actively initiated by one of the hosts, which we call the client; the other, initially passive host is called the server. The term \"DCCP endpoint\" is used to refer to either of the two hosts explicitly named by the connection (the client and the server). The term \"DCCP processor\" refers more generally to any host that might need to process a DCCP header; this includes the endpoints and any middleboxes on the path, such as firewalls and network address translators.",
      "ja": "各DCCP接続は、我々は多くの場合、積極的に私たちは、クライアントを呼び出すホスト、のいずれかによって開始され、それぞれの接続DCCP AとDCCP B.に名前を付ける2つのホスト間で実行されます。その他、最初にパッシブホストがサーバーと呼ばれています。用語「DCCP終点は、」明示的な接続（クライアントとサーバ）によってという名前の2つのホストのいずれかを参照するために使用されます。用語「DCCPプロセッサ」はDCCPヘッダを処理する必要がある可能性があるホストに、より一般的にいいます。これは、ファイアウォールやネットワークアドレス変換などのエンドポイントと経路上の任意の中間装置を含みます。"
    },
    {
      "indent": 3,
      "text": "DCCP connections are bidirectional: data may pass from either endpoint to the other. This means that data and acknowledgements may flow in both directions simultaneously. Logically, however, a DCCP connection consists of two separate unidirectional connections, called half-connections. Each half-connection consists of the application data sent by one endpoint and the corresponding acknowledgements sent by the other endpoint. We can illustrate this as follows:",
      "ja": "DCCP接続が双方向である：データは、他のエンドポイントのいずれかから渡してもよいです。これは、データおよび肯定応答は、同時に両方向に流れることができることを意味します。論理的には、しかし、DCCPコネクションはハーフ接続と呼ばれる2つの別々の単方向接続、構成されています。各半接続は、一方のエンドポイントによって送信されたアプリケーションデータ及び他のエンドポイントによって送信され、対応する肯定応答から成ります。次のように私たちは、これを説明することができます。"
    },
    {
      "indent": 6,
      "text": "+--------+  A-to-B half-connection:         +--------+\n|        |    -->  application data  -->    |        |\n|        |    <--  acknowledgements  <--    |        |\n| DCCP A |                                  | DCCP B |\n|        |  B-to-A half-connection:         |        |\n|        |    <--  application data  <--    |        |\n+--------+    -->  acknowledgements  -->    +--------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Although they are logically distinct, in practice the half-connections overlap; a DCCP-DataAck packet, for example, contains application data relevant to one half-connection and acknowledgement information relevant to the other.",
      "ja": "彼らは実際には、論理的に別個のものであるが、半接続が重なって。 DCCP-DataAckパケットは、例えば、1つの半接続および他の関連する送達確認情報に関連するアプリケーションデータを含みます。"
    },
    {
      "indent": 3,
      "text": "In the context of a single half-connection, the terms \"HC-Sender\" and \"HC-Receiver\" denote the endpoints sending application data and acknowledgements, respectively. For example, DCCP A is the HC-Sender and DCCP B is the HC-Receiver in the A-to-B half-connection.",
      "ja": "単一半接続の文脈において、用語「HC-送信者」及び「HC-受信機」は、それぞれ、アプリケーションデータおよび肯定応答を送信するエンドポイントを示します。例えば、DCCP Aは、HC-送信元であるとDCCP BはA対B半接続におけるHC-受信機です。"
    },
    {
      "indent": 0,
      "text": "3.3. Features",
      "section_title": true,
      "ja": "3.3. 特徴"
    },
    {
      "indent": 3,
      "text": "A DCCP feature is a connection attribute on whose value the two endpoints agree. Many properties of a DCCP connection are controlled by features, including the congestion control mechanisms in use on the two half-connections. The endpoints achieve agreement through the exchange of feature negotiation options in DCCP headers.",
      "ja": "DCCPの機能は、その値が2つのエンドポイントが同意の接続属性です。 DCCP接続の多くの特性は、二つの半接続に使用されている輻輳制御機構を含む、機能によって制御されます。エンドポイントはDCCPヘッダーに特徴交渉オプションの交換を通じて合意を達成します。"
    },
    {
      "indent": 3,
      "text": "DCCP features are identified by a feature number and an endpoint. The notation \"F/X\" represents the feature with feature number F located at DCCP endpoint X. Each valid feature number thus corresponds to two features, which are negotiated separately and need not have the same value. The two endpoints know, and agree on, the value of every valid feature. DCCP A is the \"feature location\" for all features F/A, and the \"feature remote\" for all features F/B.",
      "ja": "DCCPの特徴は、機能の数とエンドポイントによって識別されます。記号「F / X」DCCP終点Xの位置フィーチャー番号Fと機能を表す各有効な特徴数は、このように別々にネゴシエートと同じ値を有する必要はないされた2つの機能に対応します。 2つのエンドポイントは、すべての有効な機能の価値を知っている、と同意します。 DCCP Aは、すべてのための「特徴位置」とは、F / Aを備え、そしてすべての特徴F / Bは、「Remote機能」されています。"
    },
    {
      "indent": 0,
      "text": "3.4. Round-Trip Times",
      "section_title": true,
      "ja": "3.4. 往復時間"
    },
    {
      "indent": 3,
      "text": "DCCP round-trip time measurements are performed by congestion control mechanisms; different mechanisms may measure round-trip time in different ways, or not measure it at all. However, the main DCCP protocol does use round-trip times occasionally, such as in the initial values for certain timers. Each DCCP implementation thus defines a default round-trip time for use when no estimate is available. This parameter should default to not less than 0.2 seconds, a reasonably conservative round-trip time for Internet TCP connections. Protocol behavior specified in terms of \"round-trip time\" values actually refers to \"a current round-trip time estimate taken by some CCID, or, if no estimate is available, the default round-trip time parameter\".",
      "ja": "DCCP往復時間測定は、輻輳制御機構によって実行されます。異なるメカニズムは異なる方法で往復時間を測定する、またはまったくそれを測定することができません。しかし、主DCCPプロトコルは、特定のタイマーの初期値と同様に、時折往復時間を使用しません。何の推定値が利用できない場合、各DCCPの実装は、このように使用するためのデフォルトのラウンドトリップ時間を定義します。このパラメータは、以下0.2秒以上、インターネットのTCP接続のための合理的に保守的な往復時間をデフォルトとすべきです。 「何の推定値は、デフォルトのラウンドトリップ時間パラメータ利用できない場合、いくつかのCCIDで撮影した現在の往復時間の見積もり、または」「往復時間」の値の観点から指定されたプロトコルの動作は、実際にを指します。"
    },
    {
      "indent": 3,
      "text": "The maximum segment lifetime, or MSL, is the maximum length of time a packet can survive in the network. The DCCP MSL should equal that of TCP, which is normally two minutes.",
      "ja": "最大のセグメント生涯、またはMSL、パケットがネットワークの中で生き残ることができる時間の最大の長さです。 DCCP MSLは、通常は2分であるTCPのそれに等しくなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.5. Security Limitation",
      "section_title": true,
      "ja": "3.5. セキュリティの制限"
    },
    {
      "indent": 3,
      "text": "DCCP provides no protection against attackers who can snoop on a connection in progress, or who can guess valid sequence numbers in other ways. Applications desiring stronger security should use IPsec [RFC2401]; depending on the level of security required, application-level cryptography may also suffice. These issues are discussed further in Sections 7.5.5 and 18.",
      "ja": "DCCPは、進行中の接続をスヌーピングすることができ、あるいは他の方法で有効なシーケンス番号を推測できる人攻撃に対する保護を提供していません。強力なセキュリティを希望するアプリケーションは、IPsec [RFC2401]を使用する必要があります。必要とされるセキュリティのレベルに応じて、アプリケーション・レベルの暗号化も十分です。これらの問題は、セクション7.5.5および18でさらに議論されています。"
    },
    {
      "indent": 0,
      "text": "3.6. Robustness Principle",
      "section_title": true,
      "ja": "3.6. 堅牢性の原則"
    },
    {
      "indent": 3,
      "text": "DCCP implementations will follow TCP's \"general principle of\nrobustness\": \"be conservative in what you do, be liberal in what you\naccept from others\" [RFC793].",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4. Overview",
      "section_title": true,
      "ja": "4.概要"
    },
    {
      "indent": 3,
      "text": "DCCP's high-level connection dynamics echo those of TCP. Connections progress through three phases: initiation, including a three-way handshake; data transfer; and termination. Data can flow both ways over the connection. An acknowledgement framework lets senders discover how much data has been lost and thus avoid unfairly congesting the network. Of course, DCCP provides unreliable datagram semantics, not TCP's reliable bytestream semantics. The application must package its data into explicit frames and must retransmit its own data as necessary. It may be useful to think of DCCP as TCP minus bytestream semantics and reliability, or as UDP plus congestion control, handshakes, and acknowledgements.",
      "ja": "DCCPの高レベルの接続力学はTCPのそれらをエコー。接続は3つの段階を経て進行する：開始、3ウェイハンドシェイクを含みます。データ転送;そして終了。データが接続を介して、両方の方法を流れることができます。承認フレームワークでは、送信者が失われたため、不当にネットワークを輻輳回避してきたどのくらいのデータを発見することができます。もちろん、DCCPは信頼性のないデータグラム意味論ではなく、TCPの信頼性の高いバイトストリームのセマンティクスを提供します。アプリケーションが明示的なフレームにそのデータをパッケージ化する必要があり、必要に応じて、独自のデータを再送信しなければなりません。 TCPマイナスバイトストリームセマンティクスと信頼性、またはUDPプラス輻輳制御、握手、および確認応答としてDCCPを考えることが有用であり得ます。"
    },
    {
      "indent": 0,
      "text": "4.1. Packet Types",
      "section_title": true,
      "ja": "4.1. パケットタイプ"
    },
    {
      "indent": 3,
      "text": "Ten packet types implement DCCP's protocol functions. For example, every new connection attempt begins with a DCCP-Request packet sent by the client. In this way a DCCP-Request packet resembles a TCP SYN, but since DCCP-Request is a packet type there is no way to send an unexpected flag combination, such as TCP's SYN+FIN+ACK+RST.",
      "ja": "テンのパケットタイプは、DCCPのプロトコル機能を実装します。たとえば、すべての新しい接続試行は、クライアントから送信されたDCCP-Requestパケットで始まります。このように、DCCP-RequestパケットはTCP SYNに似ているが、DCCP-要求は、パケットの種類があるので、このようなTCPのSYN + FIN + ACK + RSTなどの予期しないフラグの組み合わせを、送信する方法はありません。"
    },
    {
      "indent": 3,
      "text": "Eight packet types occur during the progress of a typical connection, shown here. Note the three-way handshakes during initiation and termination.",
      "ja": "八のパケットタイプは、ここに示されている一般的な接続の進行中に発生します。開始と終了時の3ウェイハンドシェイクを注意してください。"
    },
    {
      "indent": 6,
      "text": "Client                                      Server\n------                                      ------\n                 (1) Initiation\nDCCP-Request -->\n                                 <-- DCCP-Response\nDCCP-Ack -->\n                 (2) Data transfer\nDCCP-Data, DCCP-Ack, DCCP-DataAck -->\n             <-- DCCP-Data, DCCP-Ack, DCCP-DataAck\n                 (3) Termination\n                                 <-- DCCP-CloseReq\nDCCP-Close -->\n                                    <-- DCCP-Reset",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The two remaining packet types are used to resynchronize after bursts of loss.",
      "ja": "残りの2つのパケットタイプは、損失のバースト後に再同期するために使用されています。"
    },
    {
      "indent": 3,
      "text": "Every DCCP packet starts with a fixed-size generic header. Particular packet types include additional fixed-size header data; for example, DCCP-Acks include an Acknowledgement Number. DCCP options and any application data follow the fixed-size header.",
      "ja": "すべてのDCCPパケットは、固定サイズの一般的なヘッダーで始まります。特定のパケットタイプは、追加の固定サイズ・ヘッダ・データを含みます。例えば、DCCP-ACKは確認応答番号が含まれます。 DCCPオプションと任意のアプリケーションデータは、固定サイズのヘッダに従います。"
    },
    {
      "indent": 3,
      "text": "The packet types are as follows:",
      "ja": "次のようにパケットの種類は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "DCCP-Request Sent by the client to initiate a connection (the first part of the three-way initiation handshake).",
      "ja": "DCCPリクエスト接続（三元開始ハンドシェークの最初の部分）を開始するためにクライアントによって送信されます。"
    },
    {
      "indent": 3,
      "text": "DCCP-Response Sent by the server in response to a DCCP-Request (the second part of the three-way initiation handshake).",
      "ja": "DCCP-要求に応答してサーバによって送信されたDCCP  - 応答（三元開始ハンドシェークの第二部分）。"
    },
    {
      "indent": 3,
      "text": "DCCP-Data Used to transmit application data.",
      "ja": "DCCP-データは、アプリケーション・データを送信するために使用します。"
    },
    {
      "indent": 3,
      "text": "DCCP-Ack Used to transmit pure acknowledgements.",
      "ja": "DCCP-Ackのは、純粋な確認応答を送信するために使用します。"
    },
    {
      "indent": 3,
      "text": "DCCP-DataAck Used to transmit application data with piggybacked acknowledgement information.",
      "ja": "DCCP-DataAckは便乗送達確認情報とアプリケーションデータを送信するために使用します。"
    },
    {
      "indent": 3,
      "text": "DCCP-CloseReq Sent by the server to request that the client close the connection.",
      "ja": "クライアントが接続を閉じることを要求するためにサーバーによって送信されDCCP-CloseReq。"
    },
    {
      "indent": 3,
      "text": "DCCP-Close Used by the client or the server to close the connection; elicits a DCCP-Reset in response.",
      "ja": "接続を閉じるには、クライアントまたはサーバが使用するDCCP-閉じます。応答におけるDCCP-リセットを誘発します。"
    },
    {
      "indent": 3,
      "text": "DCCP-Reset Used to terminate the connection, either normally or abnormally.",
      "ja": "DCCP-リセットはどちらか通常または異常、接続を終了するために使用します。"
    },
    {
      "indent": 3,
      "text": "DCCP-Sync, DCCP-SyncAck Used to resynchronize sequence numbers after large bursts of loss.",
      "ja": "DCCP-同期、DCCP-SyncAckは、損失の大バースト後のシーケンス番号を再同期するために使用します。"
    },
    {
      "indent": 0,
      "text": "4.2. Packet Sequencing",
      "section_title": true,
      "ja": "4.2. パケットシーケンス"
    },
    {
      "indent": 3,
      "text": "Each DCCP packet carries a sequence number so that losses can be detected and reported. Unlike TCP sequence numbers, which are byte-based, DCCP sequence numbers increment by one per packet. For example:",
      "ja": "損失が検出されたと報告できるように、それぞれのDCCPパケットは、シーケンス番号を運びます。バイトベースでTCPシーケンス番号とは異なり、DCCPのシーケンス番号は、パケットごとに1ずつ増加。例えば："
    },
    {
      "indent": 6,
      "text": "DCCP A                                      DCCP B\n------                                      ------\nDCCP-Data(seqno 1) -->\nDCCP-Data(seqno 2) -->\n                   <-- DCCP-Ack(seqno 10, ackno 2)\nDCCP-DataAck(seqno 3, ackno 10) -->\n                           <-- DCCP-Data(seqno 11)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Every DCCP packet increments the sequence number, whether or not it contains application data. DCCP-Ack pure acknowledgements increment the sequence number; for instance, DCCP B's second packet above uses sequence number 11, since sequence number 10 was used for an acknowledgement. This lets endpoints detect all packet loss, including acknowledgement loss. It also means that endpoints can get out of sync after long bursts of loss. The DCCP-Sync and DCCP-SyncAck packet types are used to recover (Section 7.5).",
      "ja": "すべてのDCCPパケットは、アプリケーションデータが含まれているかどうかにかかわらず、シーケンス番号をインクリメントします。 DCCP-Ackの純粋な肯定応答シーケンス番号をインクリメントします。配列番号10は、確認応答のために使用したので、例えば、DCCP Bの第2のパケットは、上記、配列番号11を使用します。これは、エンドポイントが確認応答損失を含む全てのパケットロスを検出することができます。また、エンドポイントが損失の長いバースト後の同期から抜け出すことができることを意味します。 DCCP-SyncとDCCP-SyncAckパケットタイプは（セクション7.5）を回収するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Since DCCP provides unreliable semantics, there are no retransmissions, and having a TCP-style cumulative acknowledgement field doesn't make sense. DCCP's Acknowledgement Number field equals the greatest sequence number received, rather than the smallest sequence number not received. Separate options indicate any intermediate sequence numbers that weren't received.",
      "ja": "DCCPは信頼できないセマンティクスを提供しているので、そこには再送信されない、とTCP-スタイル累積確認応答フィールドを持つことは意味がありません。 DCCPの承認番号フィールドは、受信最大シーケンス番号ではなく、ない受け取った最小のシーケンス番号に等しいです。個別のオプションが受信されなかった任意の中間シーケンス番号を示しています。"
    },
    {
      "indent": 0,
      "text": "4.3. States",
      "section_title": true,
      "ja": "4.3. アメリカ"
    },
    {
      "indent": 3,
      "text": "DCCP endpoints progress through different states during the course of a connection, corresponding roughly to the three phases of initiation, data transfer, and termination. The figure below shows the typical progress through these states for a client and server.",
      "ja": "DCCP終点は、開始、データ転送、および終了の三相にほぼ対応し、接続の過程の間の異なる状態を経て進行します。下の図は、クライアントとサーバのためにこれらの状態を経て、典型的な進行状況が表示されます。"
    },
    {
      "indent": 6,
      "text": "Client                                             Server\n------                                             ------\n                  (0) No connection\nCLOSED                                             LISTEN",
      "raw": true
    },
    {
      "indent": 6,
      "text": " (1) Initiation REQUEST DCCP-Request --> <-- DCCP-Response RESPOND PARTOPEN DCCP-Ack or DCCP-DataAck -->",
      "ja": "（1）開始要求DCCPリクエスト - > < -  DCCP-応答が応答PARTOPEN DCCP-ACKまたはDCCP-DataAck  - >"
    },
    {
      "indent": 6,
      "text": " (2) Data transfer OPEN <-- DCCP-Data, Ack, DataAck --> OPEN",
      "ja": "< -  DCCP-DATA、ACK、DataAck  - > OPEN（2）データは、OPENを転送します"
    },
    {
      "indent": 6,
      "text": " (3) Termination <-- DCCP-CloseReq CLOSEREQ CLOSING DCCP-Close --> <-- DCCP-Reset CLOSED TIMEWAIT CLOSED",
      "ja": "（3）終了< -  DCCP-CloseReqのCLOSEREQがDCCP-閉じるCLOSING  - > < -  DCCPリセットCLOSED TIMEWAITが閉じ"
    },
    {
      "indent": 3,
      "text": "The nine possible states are as follows. They are listed in increasing order, so that \"state >= CLOSEREQ\" means the same as \"state = CLOSEREQ or state = CLOSING or state = TIMEWAIT\". Section 8 describes the states in more detail.",
      "ja": "次のように9つの可能な状態です。 「> = CLOSEREQ状態」が「状態= CLOSEREQまたは状態= CLOSINGまたは状態= TIMEWAIT」と同じことを意味するように、それらは、昇順にリストされています。第8章は、より詳細に状態を説明しています。"
    },
    {
      "indent": 3,
      "text": "CLOSED Represents nonexistent connections.",
      "ja": "CLOSEDは存在しない接続を表します。"
    },
    {
      "indent": 3,
      "text": "LISTEN Represents server sockets in the passive listening state. LISTEN and CLOSED are not associated with any particular DCCP connection.",
      "ja": "LISTENはパッシブリスニングステートのサーバソケットを表します。 LISTENとCLOSEDは、任意の特定のDCCP接続に関連付けられていません。"
    },
    {
      "indent": 3,
      "text": "REQUEST A client socket enters this state, from CLOSED, after sending a DCCP-Request packet to try to initiate a connection.",
      "ja": "REQUESTは、クライアントソケットは、接続を開始しようとするDCCP-Requestパケットを送信した後、CLOSEDから、この状態に入ります。"
    },
    {
      "indent": 3,
      "text": "RESPOND A server socket enters this state, from LISTEN, after receiving a DCCP-Request from a client.",
      "ja": "サーバソケットは、クライアントからのDCCP-Requestを受け取った後、LISTENから、この状態に入り、応答します。"
    },
    {
      "indent": 3,
      "text": "PARTOPEN A client socket enters this state, from REQUEST, after receiving a DCCP-Response from the server. This state represents the third phase of the three-way handshake. The client may send application data in this state, but it MUST include an Acknowledgement Number on all of its packets.",
      "ja": "PARTOPEN Aクライアントソケットは、サーバからDCCP-応答を受け取った後、REQUESTから、この状態に入ります。この状態は、スリーウェイハンドシェイクの第三相を表しています。クライアントは、この状態でアプリケーションデータを送ることができますが、それはそのパケットのすべての承認番号を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "OPEN The central data transfer portion of a DCCP connection. Client and server sockets enter this state from PARTOPEN and RESPOND, respectively. Sometimes we speak of SERVER-OPEN and CLIENT-OPEN states, corresponding to the server's OPEN state and the client's OPEN state.",
      "ja": "DCCP接続の中央のデータ転送部を開きます。クライアントとサーバーのソケットはPARTOPENからこの状態に入り、それぞれ、対応しています。時々、私たちは、サーバのOPEN状態とクライアントのOPEN状態に対応し、SERVER-OPENおよびCLIENT-OPEN状態の話します。"
    },
    {
      "indent": 3,
      "text": "CLOSEREQ A server socket enters this state, from SERVER-OPEN, to order the client to close the connection and to hold TIMEWAIT state.",
      "ja": "CLOSEREQサーバソケットは、接続を閉じるには、クライアントを注文するとTIMEWAIT状態を保持するために、SERVER-OPENから、この状態に入ります。"
    },
    {
      "indent": 3,
      "text": "CLOSING Server and client sockets can both enter this state to close the connection.",
      "ja": "CLOSINGサーバーとクライアントのソケットは、接続を閉じるには、この状態に入ることができるの両方。"
    },
    {
      "indent": 3,
      "text": "TIMEWAIT A server or client socket remains in this state for 2MSL (4 minutes) after the connection has been torn down, to prevent mistakes due to the delivery of old packets. Only one of the endpoints has to enter TIMEWAIT state (the other can enter CLOSED state immediately), and a server can request its client to hold TIMEWAIT state using the DCCP-CloseReq packet type.",
      "ja": "TIMEWAITは、サーバーまたはクライアントソケットは、接続は切断された後2MSL（4分）については、この状態のまま、古いパケットの配信に起因するミスを防ぐために。唯一のエンドポイントの1つは、（他はすぐにCLOSED状態に入ることができる）TIMEWAIT状態に入る必要があり、サーバがDCCP-CloseReqパケットタイプを使用してTIMEWAIT状態を保持するために、そのクライアントを要求することができます。"
    },
    {
      "indent": 0,
      "text": "4.4. Congestion Control Mechanisms",
      "section_title": true,
      "ja": "4.4. 輻輳制御機構"
    },
    {
      "indent": 3,
      "text": "DCCP connections are congestion controlled, but unlike in TCP, DCCP applications have a choice of congestion control mechanism. In fact, the two half-connections can be governed by different mechanisms. Mechanisms are denoted by one-byte congestion control identifiers, or CCIDs. The endpoints negotiate their CCIDs during connection initiation. Each CCID describes how the HC-Sender limits data packet rates, how the HC-Receiver sends congestion feedback via acknowledgements, and so forth. CCIDs 2 and 3 are currently defined; CCIDs 0, 1, and 4-255 are reserved. Other CCIDs may be defined in the future.",
      "ja": "DCCPコネクションは、輻輳制御ですが、TCPとは異なり、DCCPアプリケーションは、輻輳制御機構の選択肢があります。実際には、二つの半接続は異なるメカニズムによって支配することができます。メカニズムは、1バイトの輻輳制御識別子、またはのCCIDsで示されています。エンドポイントは、接続開始時に自分のCCIDsを交渉します。各CCIDは、HC-Receiverのなどの承認を経て、輻輳フィードバックを送信し、どのように、どのようにHC-送信者の制限、データパケットのレートを記述する。 CCIDs 2及び3は、現在定義されています。 CCIDs 0,1、及び4から255は予約されています。その他のCCIDsは、将来的に定義されてもよいです。"
    },
    {
      "indent": 3,
      "text": "CCID 2 provides TCP-like Congestion Control, which is similar to that of TCP. The sender maintains a congestion window and sends packets until that window is full. Packets are acknowledged by the receiver. Dropped packets and ECN [RFC3168] indicate congestion; the response to congestion is to halve the congestion window. Acknowledgements in CCID 2 contain the sequence numbers of all received packets within some window, similar to a selective acknowledgement (SACK) [RFC2018].",
      "ja": "CCID 2は、TCPと同様であるTCPのような輻輳制御を提供します。送信者は輻輳ウィンドウを維持し、そのウィンドウがいっぱいになるまでパケットを送信します。パケットは、受信機によって確認されます。ドロップされたパケットとECNは、[RFC3168]の輻輳を示します。混雑への応答は、輻輳ウィンドウを半分にすることです。 CCID 2の肯定応答は、選択的確認応答（SACK）[RFC2018]と同様、いくつかのウィンドウ内のすべての受信パケットのシーケンス番号を含みます。"
    },
    {
      "indent": 3,
      "text": "CCID 3 provides TCP-Friendly Rate Control (TFRC), an equation-based form of congestion control intended to respond to congestion more smoothly than CCID 2. The sender maintains a transmit rate, which it updates using the receiver's estimate of the packet loss and mark rate. CCID 3 behaves somewhat differently than TCP in the short term, but is designed to operate fairly with TCP over the long term.",
      "ja": "CCID 3は、TCPフレンドリーレート制御（TFRC）、送信側は、パケットロスの受信機の推定値とを用いて更新する送信レートを維持CCID 2よりもより円滑輻輳に応答するように意図され、輻輳制御の方程式ベースのフォームを提供しますマーク率。 CCID 3は、短期的には多少異なるTCPよりも動作しますが、長期的にTCPと公平に動作するように設計されています。"
    },
    {
      "indent": 3,
      "text": "Section 10 describes DCCP's CCIDs in more detail. The behaviors of CCIDs 2 and 3 are fully defined in separate profile documents [RFC4341, RFC4342].",
      "ja": "セクション10は、より詳細にDCCPののCCIDsを説明しています。 CCIDs 2及び3の動作は完全に別々のプロファイルドキュメント[RFC4341、RFC4342]で定義されています。"
    },
    {
      "indent": 0,
      "text": "4.5. Feature Negotiation Options",
      "section_title": true,
      "ja": "4.5. 特徴交渉オプション"
    },
    {
      "indent": 3,
      "text": "DCCP endpoints use Change and Confirm options to negotiate and agree on feature values. Feature negotiation will almost always happen on the connection initiation handshake, but it can begin at any time.",
      "ja": "DCCP終点は、変更を使用し、交渉し、特徴値に同意するオプションを確認してください。機能の交渉は、ほとんどの場合、接続開始握手に発生しますが、それはいつでも始めることができます。"
    },
    {
      "indent": 3,
      "text": "There are four feature negotiation options in all: Change L, Confirm L, Change R, and Confirm R. The \"L\" options are sent by the feature location and the \"R\" options are sent by the feature remote. A Change R option says to the feature location, \"change this feature value as follows\". The feature location responds with Confirm L, meaning, \"I've changed it\". Some features allow Change R options to contain multiple values sorted in preference order. For example:",
      "ja": "変更L、L、変更Rを確認し、「L」オプションが機能リモートによって送信された特徴位置と「R」のオプションによって送信されたR.確認：4つの全部で特徴交渉オプションがあります。変更Rオプションは、「この機能は、次のように値を変更する」、特徴位置に言います。特徴位置は、「私はそれを変更した」、という意味、確認Lで応答します。一部の機能は変更Rオプションは、優先順にソートされた複数の値を含めることができます。例えば："
    },
    {
      "indent": 6,
      "text": "Client                                        Server\n------                                        ------\nChange R(CCID, 2) -->\n                              <-- Confirm L(CCID, 2)\n           * agreement that CCID/Server = 2 *",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Change R(CCID, 3 4) --> <-- Confirm L(CCID, 4, 4 2) * agreement that CCID/Server = 4 *",
      "ja": "変更R（CCID、3 4） - > < -  Lを確認し（CCID、4,4 2）*契約CCID /サーバ= 4 *"
    },
    {
      "indent": 3,
      "text": "Both exchanges negotiate the CCID/Server feature's value, which is the CCID in use on the server-to-client half-connection. In the second exchange, the client requests that the server use either CCID 3 or CCID 4, with 3 preferred; the server chooses 4 and supplies its preference list, \"4 2\".",
      "ja": "どちらの交換は、サーバからクライアントへの半分の接続に使用してCCIDあるCCID /サーバ機能の値を、交渉します。第二の交換、サーバー使用CCID 3又は好適3とCCID 4、いずれかのクライアント要求に、サーバーは、「4 2」、4を選択し、その優先リストを提供します。"
    },
    {
      "indent": 3,
      "text": "The Change L and Confirm R options are used for feature negotiations initiated by the feature location. In the following example, the server requests that CCID/Server be set to 3 or 2, with 3 preferred, and the client agrees.",
      "ja": "変更Lとは、Rオプションは特徴位置によって開始された特徴交渉のために使用されていることを確認します。次の例では、CCID /サーバが3または2に設定するサーバー要求は、3が好ましく、そしてクライアントが同意します。"
    },
    {
      "indent": 6,
      "text": "Client                                       Server\n------                                       ------\n                            <-- Change L(CCID, 3 2)\nConfirm R(CCID, 3, 3 2)  -->\n           * agreement that CCID/Server = 3 *",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Section 6 describes the feature negotiation options further, including the retransmission strategies that make negotiation reliable.",
      "ja": "第6節は、交渉が信頼できるように再送戦略を含めた更なる特徴交渉オプションについて説明します。"
    },
    {
      "indent": 0,
      "text": "4.6. Differences from TCP",
      "section_title": true,
      "ja": "4.6.  TCPとの違い"
    },
    {
      "indent": 3,
      "text": "DCCP's differences from TCP apart from those discussed so far include the following:",
      "ja": "TCPからのDCCPの違いは別に議論したから、これまでに次のものがあります。"
    },
    {
      "indent": 3,
      "text": "o Copious space for options (up to 1008 bytes or the PMTU).",
      "ja": "Oオプション（最大1008バイトまたはPMTU）のために多量のスペース。"
    },
    {
      "indent": 3,
      "text": "o Different acknowledgement formats. The CCID for a connection determines how much acknowledgement information needs to be transmitted. For example, in CCID 2 (TCP-like), this is about one ack per 2 packets, and each ack must declare exactly which packets were received. In CCID 3 (TFRC), it is about one ack per round-trip time, and acks must declare at minimum just the lengths of recent loss intervals.",
      "ja": "別の確認応答形式O。接続用のCCIDは、多くの送達確認情報を送信する必要がある方法を決定します。例えば、CCID 2（TCPのような）で、これは2つのパケット当たり約ACKあり、各ACKは、パケットが受信された正確に宣言しなければなりません。 CCID 3（TFRC）では、往復時間あたり約1 ACKで、ACKは最低でも最近の損失間隔のちょうど長さを宣言する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Denial of Service (DoS) protection. Several mechanisms help limit the amount of state that possibly-misbehaving clients can force DCCP servers to maintain. An Init Cookie option analogous to TCP's SYN Cookies [SYNCOOKIES] avoids SYN-flood-like attacks. Only one connection endpoint has to hold TIMEWAIT state; the DCCP-CloseReq packet, which may only be sent by the server, passes that state to the client. Various rate limits let servers avoid attacks that might force extensive computation or packet generation.",
      "ja": "Oサービス拒否（DoS）の保護。いくつかのメカニズムは、おそらく、ふらちなクライアントが維持するために、DCCPサーバを強制することができる状態の量を制限するのに役立ちます。 [syncookies機能] TCPのSYNクッキーに類似のInit Cookieのオプションは、SYNフラッドのような攻撃を回避します。一つだけ接続エンドポイントはTIMEWAIT状態を保持する必要があります。唯一のサーバーによって送信されることがDCCP-CloseReqパケットは、クライアントにその状態を渡します。様々なレート制限は、サーバが大規模な計算やパケットの生成を強制するかもしれない攻撃を避けるましょう。"
    },
    {
      "indent": 3,
      "text": "o Distinguishing different kinds of loss. A Data Dropped option (Section 11.7) lets an endpoint declare that a packet was dropped because of corruption, because of receive buffer overflow, and so on. This facilitates research into more appropriate rate-control responses for these non-network-congestion losses (although currently such losses will cause a congestion response).",
      "ja": "O損失の異なる種類を区別。データは、オプション（11.7節）エンドポイントがそうであるため、バッファオーバーフローを受けるのは、パケットが原因で破損のドロップされたことを宣言し、することができますを落としました。 （現在、このような損失が輻輳応答を引き起こしますが）これは、これらの非ネットワークの混雑の損失のためのより適切な速度制御応答の研究を促進します。"
    },
    {
      "indent": 3,
      "text": "o Acknowledgeability. In TCP, a packet may be acknowledged only once the data is reliably queued for application delivery. This does not make sense in DCCP, where an application might, for example, request a drop-from-front receive buffer. A DCCP packet may be acknowledged as soon as its header has been successfully processed. Concretely, a packet becomes acknowledgeable at Step 8 of Section 8.5's packet processing pseudocode. Acknowledgeability does not guarantee data delivery, however: the Data Dropped option may later report that the packet's application data was discarded.",
      "ja": "Acknowledgeability O。 TCPでは、パケットは、データを確実にアプリケーション配信のためにキューイングされて一度だけ認めていてもよいです。これは、アプリケーションが、例えば、ドロップからフロントを要求バッファを受け取ることがありますDCCPに意味がありません。 DCCPパケットは、すぐにそのヘッダが正常に処理されたと認定することができます。具体的には、パケットは、セクション8.5のパケット処理の擬似コードのステップ8で受け付け可能となります。 Acknowledgeabilityしかし、データの配信を保証するものではありません：データドロップオプションは、後に、パケットのアプリケーションデータが破棄されたことを報告することがあります。"
    },
    {
      "indent": 3,
      "text": "o No receive window. DCCP is a congestion control protocol, not a flow control protocol.",
      "ja": "Oノーウィンドウを受け取ります。 DCCP輻輳制御プロトコルではなく、フロー制御プロトコルです。"
    },
    {
      "indent": 3,
      "text": "o No simultaneous open. Every connection has one client and one server.",
      "ja": "ノー同時オープンO。すべての接続は、1つのクライアントと一つのサーバを持っています。"
    },
    {
      "indent": 3,
      "text": "o No half-closed states. DCCP has no states corresponding to TCP's FINWAIT and CLOSEWAIT, where one half-connection is explicitly closed while the other is still active. The Data Dropped option's Drop Code 1, Application Not Listening (Section 11.7), can achieve a similar effect, however.",
      "ja": "ノー半分閉じた状態O。 DCCPは他がまだアクティブである間、1つの半接続を明示的にクローズされるTCPのFINWAITとCLOSEWAIT、に対応する状態を持っていません。データは、オプションのドロップコード1、（セクション11.7を）聞いていないアプリケーションを落とし、しかし、同様の効果を得ることができます。"
    },
    {
      "indent": 0,
      "text": "4.7. Example Connection",
      "section_title": true,
      "ja": "4.7. 接続例"
    },
    {
      "indent": 3,
      "text": "The progress of a typical DCCP connection is as follows. (This description is informative, not normative.)",
      "ja": "次のように一般的なDCCP接続の進行があります。 （この記述は規範的、有益ではありません。）"
    },
    {
      "indent": 6,
      "text": "    Client                                  Server\n    ------                                  ------\n0.  [CLOSED]                              [LISTEN]\n1.  DCCP-Request -->\n2.                               <-- DCCP-Response\n3.  DCCP-Ack -->\n4.  DCCP-Data, DCCP-Ack, DCCP-DataAck -->\n             <-- DCCP-Data, DCCP-Ack, DCCP-DataAck\n5.                               <-- DCCP-CloseReq\n6.  DCCP-Close -->\n7.                                  <-- DCCP-Reset\n8.  [TIMEWAIT]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "1. The client sends the server a DCCP-Request packet specifying the client and server ports, the service being requested, and any features being negotiated, including the CCID that the client would like the server to use. The client may optionally piggyback an application request on the DCCP-Request packet. The server may ignore this application request.",
      "ja": "1.クライアントは、サーバがクライアントとサーバのポートを指定するDCCP-Requestパケット送信し、サービスが要求されている、とすべての機能は、クライアントがサーバーを使用したいCCIDを含め、交渉中。クライアントは、必要に応じてDCCP-Requestパケット上のアプリケーション要求を背負うことがあります。サーバーは、このアプリケーションの要求を無視することができます。"
    },
    {
      "indent": 3,
      "text": "2. The server sends the client a DCCP-Response packet indicating that it is willing to communicate with the client. This response indicates any features and options that the server agrees to, begins other feature negotiations as desired, and optionally includes Init Cookies that wrap up all this information and that must be returned by the client for the connection to complete.",
      "ja": "2.サーバーはクライアントに、クライアントと通信する意志があることを示すDCCP-Responseパケットを送信します。この応答は、サーバがすることに同意する任意の機能とオプションを示し、必要に応じて他の機能の交渉を開始し、必要に応じて、このすべての情報をラップし、それが完了するの接続のために、クライアントによって返されなければならない初期のクッキーが含まれています。"
    },
    {
      "indent": 3,
      "text": "3. The client sends the server a DCCP-Ack packet that acknowledges the DCCP-Response packet. This acknowledges the server's initial sequence number and returns any Init Cookies in the DCCP-Response. It may also continue feature negotiation. The client may piggyback an application-level request on this ack, producing a DCCP-DataAck packet.",
      "ja": "3.クライアントは、サーバにDCCP-Responseパケットを承認DCCP-Ackパケットを送信します。これは、サーバの初期シーケンス番号を認識し、DCCP-応答で任意の初期クッキーを返します。また、機能の交渉を継続してもよいです。クライアントは、DCCP-DataAckパケットを生成し、このACK上のアプリケーションレベルの要求を背負うことがあります。"
    },
    {
      "indent": 3,
      "text": "4. The server and client then exchange DCCP-Data packets, DCCP-Ack packets acknowledging that data, and, optionally, DCCP-DataAck packets containing data with piggybacked acknowledgements. If the client has no data to send, then the server will send DCCP-Data and DCCP-DataAck packets, while the client will send DCCP-Acks exclusively. (However, the client may not send DCCP-Data packets before receiving at least one non-DCCP-Response packet from the server.)",
      "ja": "4.サーバとクライアントは、次に、DCCP-ACKパケットは、必要に応じて、DCCP-DataAckパケットがピギーバック肯定応答とデータを含む、そのデータを認め、そして、DCCP  - データパケットを交換します。クライアントが送信するデータがない場合は、クライアントが独占的にDCCP-ACKを送信する一方、サーバは、DCCP-データとDCCP-DataAckパケットを送信します。 （ただし、クライアントは、サーバから少なくとも1つの非DCCP-Responseパケットを受信する前にDCCP  - データパケットを送信しない場合があります。）"
    },
    {
      "indent": 3,
      "text": "5. The server sends a DCCP-CloseReq packet requesting a close.",
      "section_title": true,
      "ja": "5.サーバーがクローズを要求DCCP-CloseReqパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "6. The client sends a DCCP-Close packet acknowledging the close.",
      "section_title": true,
      "ja": "6.クライアントが近くを認めDCCP-閉じるパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "7. The server sends a DCCP-Reset packet with Reset Code 1, \"Closed\", and clears its connection state. DCCP-Resets are part of normal connection termination; see Section 5.6.",
      "ja": "7.サーバは、「クローズ」、リセットコード1とDCCP-リセットパケットを送信し、その接続状態をクリアします。 DCCP-リセットは、通常の接続終端の一部です。セクション5.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "8. The client receives the DCCP-Reset packet and holds state for two maximum segment lifetimes, or 2MSL, to allow any remaining packets to clear the network.",
      "ja": "8.クライアントはDCCP  - リセットパケットを受信し、残りのパケットがネットワークをクリアできるようにするために、2つの最大セグメント寿命、または2MSLの状態を保持しています。"
    },
    {
      "indent": 3,
      "text": "An alternative connection closedown sequence is initiated by the client:",
      "ja": "代替接続閉止シーケンスは、クライアントによって開始されます。"
    },
    {
      "indent": 3,
      "text": "5b. The client sends a DCCP-Close packet closing the connection.",
      "ja": "図5b。クライアントが接続を閉じるDCCP-閉じるパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "6b. The server sends a DCCP-Reset packet with Reset Code 1, \"Closed\", and clears its connection state.",
      "ja": "図6b。サーバは、「クローズ」リセットコード1とDCCP-リセットパケットを送信し、その接続状態をクリアします。"
    },
    {
      "indent": 3,
      "text": "7b. The client receives the DCCP-Reset packet and holds state for 2MSL to allow any remaining packets to clear the network.",
      "ja": "図7b。クライアントは、DCCP-リセットパケットを受信して​​、残りのパケットがネットワークをクリアできるようにするために2MSLの状態を保持しています。"
    },
    {
      "indent": 0,
      "text": "5. Packet Formats",
      "section_title": true,
      "ja": "5.パケットフォーマット"
    },
    {
      "indent": 3,
      "text": "The DCCP header can be from 12 to 1020 bytes long. The initial part of the header has the same semantics for all currently defined packet types. Following this comes any additional fixed-length fields required by the packet type, and then a variable-length list of options. The application data area follows the header. In some packet types, this area contains data for the application; in other packet types, its contents are ignored.",
      "ja": "DCCPヘッダーは12 1020バイトより長くすることができます。ヘッダの最初の部分は、現在定義されているすべてのパケットタイプについて同じ意味を有します。続いて、これはその後、追加の固定長パケットの種類によって必要なフィールド、およびオプションの可変長リストを付属しています。アプリケーションデータ領域は、ヘッダの後に続きます。いくつかのパケットタイプでは、このエリアには、アプリケーションのためのデータが含まれています。他のパケットタイプで、その内容は無視されます。"
    },
    {
      "indent": 6,
      "text": "+---------------------------------------+  -.\n|            Generic Header             |   |\n+---------------------------------------+   |\n| Additional Fields (depending on type) |   +- DCCP Header\n+---------------------------------------+   |\n|          Options (optional)           |   |\n+=======================================+  -'\n|         Application Data Area         |\n+---------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.1. Generic Header",
      "section_title": true,
      "ja": "5.1. 一般ヘッダー"
    },
    {
      "indent": 3,
      "text": "The DCCP generic header takes different forms depending on the value of X, the Extended Sequence Numbers bit. If X is one, the Sequence Number field is 48 bits long, and the generic header takes 16 bytes, as follows.",
      "ja": "DCCPジェネリックヘッダはX、拡張シーケンス番号のビットの値に応じて異なる形式をとります。 Xが1である場合、シーケンス番号フィールドは48ビット長であり、以下のようにジェネリックヘッダは、16のバイトを要します。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |           Dest Port           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data Offset  | CCVal | CsCov |           Checksum            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     |       |X|               |                               .\n| Res | Type  |=|   Reserved    |  Sequence Number (high bits)  .\n|     |       |1|               |                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                  Sequence Number (low bits)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If X is zero, only the low 24 bits of the Sequence Number are transmitted, and the generic header is 12 bytes long.",
      "ja": "Xがゼロである場合、シーケンス番号だけ低い24ビットが送信され、ジェネリックヘッダは12バイト長です。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |           Dest Port           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data Offset  | CCVal | CsCov |           Checksum            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     |       |X|                                               |\n| Res | Type  |=|          Sequence Number (low bits)           |\n|     |       |0|                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The generic header fields are defined as follows.",
      "ja": "次のようにジェネリックヘッダフィールドが定義されています。"
    },
    {
      "indent": 3,
      "text": "Source and Destination Ports: 16 bits each These fields identify the connection, similar to the corresponding fields in TCP and UDP. The Source Port represents the relevant port on the endpoint that sent this packet, and the Destination Port represents the relevant port on the other endpoint. When initiating a connection, the client SHOULD choose its Source Port randomly to reduce the likelihood of attack.",
      "ja": "送信元ポートと宛先ポート：16ビットの各これらのフィールドは、TCPとUDPの対応するフィールドと同様の接続を、識別します。送信元ポートは、このパケットを送信したエンドポイントに関連するポートを表し、および宛先ポートは、他のエンドポイント上の関連するポートを表します。接続を開始すると、クライアントは、攻撃の可能性を低減するために、ランダムにその送信元ポートを選択する必要があります。"
    },
    {
      "indent": 6,
      "text": "DCCP APIs should treat port numbers similarly to TCP and UDP port numbers. For example, machines that distinguish between \"privileged\" and \"unprivileged\" ports for TCP and UDP should do the same for DCCP.",
      "ja": "DCCP APIは、TCPとUDPのポート番号と同様にポート番号を扱う必要があります。たとえば、TCPとUDPのための「特権」と「非特権」ポートを区別マシンはDCCPのために同じことを行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Data Offset: 8 bits The offset from the start of the packet's DCCP header to the start of its application data area, in 32-bit words. The receiver MUST ignore packets whose Data Offset is smaller than the minimum-sized header for the given Type or larger than the DCCP packet itself.",
      "ja": "データオフセット：8ビット、32ビット・ワードで、そのアプリケーションデータ領域の先頭にパケットのDCCPヘッダの先頭からのオフセット。受信機は、そのデータオフセットDCCPパケット自体よりも所与のタイプ以上の最小サイズのヘッダより小さいパケットを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "CCVal: 4 bits Used by the HC-Sender CCID. For example, the A-to-B CCID's sender, which is active at DCCP A, MAY send 4 bits of information per packet to its receiver by encoding that information in CCVal. The sender MUST set CCVal to zero unless its HC-Sender CCID specifies otherwise, and the receiver MUST ignore the CCVal field unless its HC-Receiver CCID specifies otherwise.",
      "ja": "CCVal：HC-送信者CCIDによって使用される4ビット。例えば、DCCP Aで活性であるA対B CCIDの送信者は、CCValにその情報を符号化することにより、その受信機にパケット当たり4ビットの情報を送信することができます。そのHC-SenderのCCIDは、別段の指定がない限り、送信者はゼロにCCValを設定しなければなりません、そのHCレシーバCCIDが別途指定しない限り、受信機はCCValフィールドを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Checksum Coverage (CsCov): 4 bits Checksum Coverage determines the parts of the packet that are covered by the Checksum field. This always includes the DCCP header and options, but some or all of the application data may be excluded. This can improve performance on noisy links for applications that can tolerate corruption. See Section 9.",
      "ja": "チェックサム・カバレッジ（CsCov）：4ビットのチェックサム・カバレッジは、チェックサムフィールドによって覆われているパケットの部分を決定します。これは、常にDCCPヘッダーとオプションを含むが、アプリケーションデータの一部またはすべてが除外されてもよいです。これは、破損を許容できるアプリケーションのための騒がしいリンク上のパフォーマンスを向上させることができます。第9章を参照してください。"
    },
    {
      "indent": 3,
      "text": "Checksum: 16 bits The Internet checksum of the packet's DCCP header (including options), a network-layer pseudoheader, and, depending on Checksum Coverage, all, some, or none of the application data. See Section 9.",
      "ja": "チェックサム：16ビット（オプションを含む）パケットのDCCPヘッダーのインターネットチェックサム、ネットワーク層擬似ヘッダ、及び、チェックサム・カバレッジ、すべて、一部、またはアプリケーション・データのどれに応じ。第9章を参照してください。"
    },
    {
      "indent": 3,
      "text": "Reserved (Res): 3 bits Senders MUST set this field to all zeroes on generated packets, and receivers MUST ignore its value.",
      "ja": "予約（RES）：3ビットの送信者は、生成されたパケットのすべてゼロにこのフィールドを設定しなければなりません、そして受信機は、その値を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Type: 4 bits The Type field specifies the type of the packet. The following values are defined:",
      "ja": "タイプ：4ビットのTypeフィールドは、パケットの種類を指定します。次の値が定義されています。"
    },
    {
      "indent": 25,
      "text": "Type   Meaning\n----   -------\n  0    DCCP-Request\n  1    DCCP-Response\n  2    DCCP-Data\n  3    DCCP-Ack\n  4    DCCP-DataAck\n  5    DCCP-CloseReq\n  6    DCCP-Close\n  7    DCCP-Reset\n  8    DCCP-Sync\n  9    DCCP-SyncAck\n10-15  Reserved",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Table 1: DCCP Packet Types",
      "ja": "表1：DCCPパケットタイプ"
    },
    {
      "indent": 6,
      "text": "Receivers MUST ignore any packets with reserved type. That is, packets with reserved type MUST NOT be processed, and they MUST NOT be acknowledged as received.",
      "ja": "レシーバは、予約タイプを持つパケットを無視しなければなりません。これは、予約型のパケットを処理してはならない、と受け取ったとして、彼らは認めてはならない、です。"
    },
    {
      "indent": 3,
      "text": "Extended Sequence Numbers (X): 1 bit Set to one to indicate the use of an extended generic header with 48-bit Sequence and Acknowledgement Numbers. DCCP-Data, DCCP-DataAck, and DCCP-Ack packets MAY set X to zero or one. All DCCP-Request, DCCP-Response, DCCP-CloseReq, DCCP-Close, DCCP-Reset, DCCP-Sync, and DCCP-SyncAck packets MUST set X to one; endpoints MUST ignore any such packets with X set to zero. High-rate connections SHOULD set X to one on all packets to gain increased protection against wrapped sequence numbers and attacks. See Section 7.6.",
      "ja": "拡張シーケンス番号（X）：1ビットは、48ビットのシーケンスおよび確認応答番号の拡張ジェネリックヘッダの使用を示すために1に設定します。 DCCP-データ、DCCP-DataAck、およびDCCP-ACKパケットは、0または1にXを設定してもよいです。すべてのDCCP-要求、DCCP-応答、DCCP-CloseReq、DCCP-クローズ、DCCP-リセット、DCCP-同期、およびDCCP-SyncAckパケットは1つにXを設定しなければなりません。エンドポイントはゼロにXが設定された任意のそのようなパケットを無視しなければなりません。高レート接続は、ラップシーケンス番号と攻撃に対する保護を強化を得るために、すべてのパケット上のものにXを設定する必要があります。 7.6節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Sequence Number: 48 or 24 bits Identifies the packet uniquely in the sequence of all packets the source sent on this connection. Sequence Number increases by one with every packet sent, including packets such as DCCP-Ack that carry no application data. See Section 7.",
      "ja": "配列番号：48個のまたは24ビットがすべてのパケットのシーケンスに一意この接続上で送信されたソースパケットを識別する。シーケンス番号には、アプリケーションデータを運ぶないようDCCP-ACKとパケットを含むすべてのパケット送信とのいずれかによって増加します。セクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "All currently defined packet types except DCCP-Request and DCCP-Data carry an Acknowledgement Number Subheader in the four or eight bytes immediately following the generic header. When X=1, its format is:",
      "ja": "DCCP-要求とDCCP-データを除くすべての現在定義されたパケットタイプは、一般的なヘッダの直後に4つのまたは8バイトに確認応答番号サブヘッダを運びます。場合X = 1、そのフォーマットは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Reserved            |    Acknowledgement Number     .\n|                               |          (high bits)          .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.               Acknowledgement Number (low bits)               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When X=0, only the low 24 bits of the Acknowledgement Number are transmitted, giving the Acknowledgement Number Subheader this format:",
      "ja": "X = 0、のみ確認応答番号の下位24ビットが送信されると、確認応答番号サブヘッダにこのフォーマットを与えます。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Reserved    |       Acknowledgement Number (low bits)       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Reserved: 16 or 8 bits Senders MUST set this field to all zeroes on generated packets, and receivers MUST ignore its value.",
      "ja": "予約：16または8ビットの送信者が生成されたパケットのすべてゼロにこのフィールドを設定しなければなりません、そして受信機がその値を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Acknowledgement Number: 48 or 24 bits Generally contains GSR, the Greatest Sequence Number Received on any acknowledgeable packet so far. A packet is acknowledgeable if and only if its header was successfully processed by the receiver; Section 7.4 describes this further. Options such as Ack Vector (Section 11.4) combine with the Acknowledgement Number to provide precise information about which packets have arrived.",
      "ja": "謝辞番号：48または24ビットが一般的GSR、これまでの任意の承認可能パケットで最もすばらしいSequence Number Receivedが含まれています。そのヘッダが正常に受信機によって処理された場合だけパケットが承認可能です。 7.4節ではこれをさらに説明します。このようAckをベクトル（11.4節）などのオプションは、パケットが到着したかについての正確な情報を提供するために、承認番号と組み合わせます。"
    },
    {
      "indent": 6,
      "text": "Acknowledgement Numbers on DCCP-Sync and DCCP-SyncAck packets need not equal GSR. See Section 5.7.",
      "ja": "DCCP-SyncとDCCP-SyncAckパケットの確認応答番号は、GSRを等しくする必要はありません。 5.7節を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2. DCCP-Request Packets",
      "section_title": true,
      "ja": "5.2.  DCCP-Requestパケット"
    },
    {
      "indent": 3,
      "text": "A client initiates a DCCP connection by sending a DCCP-Request packet. These packets MAY contain application data and MUST use 48-bit sequence numbers (X=1).",
      "ja": "クライアントは、DCCP-Requestパケットを送信することにより、DCCP接続を開始します。これらのパケットは、アプリケーションデータを含んでいてもよく、48ビットのシーケンス番号（X = 1）を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/            Generic DCCP Header with X=1 (16 bytes)            /\n/                   with Type=0 (DCCP-Request)                  /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Service Code                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                      Options and Padding                      /\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n/                       Application Data                        /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Service Code: 32 bits Describes the application-level service to which the client application wants to connect. Service Codes are intended to provide information about which application protocol a connection intends to use, thus aiding middleboxes and reducing reliance on globally well-known ports. See Section 8.1.2.",
      "ja": "サービスコード：32ビットのクライアント・アプリケーションは、接続したいとアプリケーションレベルのサービスを記述します。サービスコードは、このようにミドルボックスを支援し、世界的に有名なポートへの依存を減らし、接続が使用することを意図しているアプリケーションプロトコルに関する情報を提供することを意図しています。 8.1.2項を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3. DCCP-Response Packets",
      "section_title": true,
      "ja": "5.3.  DCCP-応答パケット"
    },
    {
      "indent": 3,
      "text": "The server responds to valid DCCP-Request packets with DCCP-Response packets. This is the second phase of the three-way handshake. DCCP-Response packets MAY contain application data and MUST use 48-bit sequence numbers (X=1).",
      "ja": "サーバはDCCP-応答パケットで有効なDCCP-Requestパケットに応答します。これは、3ウェイハンドシェイクの第二段階です。 DCCP  - 応答パケットは、アプリケーション・データを含んでいてもよく、48ビットのシーケンス番号（X = 1）を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/            Generic DCCP Header with X=1 (16 bytes)            /\n/                  with Type=1 (DCCP-Response)                  /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/          Acknowledgement Number Subheader (8 bytes)           /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Service Code                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                      Options and Padding                      /\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n/                       Application Data                        /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Acknowledgement Number: 48 bits Contains GSR. Since DCCP-Responses are only sent during connection initiation, this will always equal the Sequence Number on a received DCCP-Request.",
      "ja": "謝辞数：48ビットは、GSRが含まれています。 DCCP-応答のみ接続開始時に送信されますので、これは常に受信DCCP-要求のシーケンス番号に等しくなります。"
    },
    {
      "indent": 3,
      "text": "Service Code: 32 bits MUST equal the Service Code on the corresponding DCCP-Request.",
      "ja": "サービスコード：32ビットは、対応するDCCP-要求にサービスコードを等しくなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.4. DCCP-Data, DCCP-Ack, and DCCP-DataAck Packets",
      "section_title": true,
      "ja": "5.4.  DCCP-データ、DCCP-ACK、およびDCCP-DataAckパケット"
    },
    {
      "indent": 3,
      "text": "The central data transfer portion of every DCCP connection uses DCCP-Data, DCCP-Ack, and DCCP-DataAck packets. These packets MAY use 24-bit sequence numbers, depending on the value of the Allow Short Sequence Numbers feature (Section 7.6.1). DCCP-Data packets carry application data without acknowledgements.",
      "ja": "すべてのDCCP接続の中央のデータ転送部は、DCCP-データ、DCCP-ACK、およびDCCP-DataAckパケットを使用します。これらのパケットは許可ショートシーケンス番号機能（7.6.1項）の値に応じて、24ビットのシーケンス番号を使用するかもしれません。 DCCP  - データパケットは、確認応答なしにアプリケーションデータを運びます。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/              Generic DCCP Header (16 or 12 bytes)             /\n/                    with Type=2 (DCCP-Data)                    /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                      Options and Padding                      /\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n/                       Application Data                        /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DCCP-Ack packets dispense with the data but contain an Acknowledgement Number. They are used for pure acknowledgements.",
      "ja": "DCCP-ACKパケットはデータを省くが、確認応答番号が含まれています。彼らは純粋な受信確認のために使用されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/              Generic DCCP Header (16 or 12 bytes)             /\n/                    with Type=3 (DCCP-Ack)                     /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/        Acknowledgement Number Subheader (8 or 4 bytes)        /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                      Options and Padding                      /\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n/                Application Data Area (Ignored)                /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DCCP-DataAck packets carry both application data and an Acknowledgement Number. This piggybacks acknowledgement information on a data packet.",
      "ja": "DCCP-DataAckパケットは、アプリケーションデータと確認応答番号の両方を運びます。これは、データパケットの送達確認情報をピギーバックします。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/              Generic DCCP Header (16 or 12 bytes)             /\n/                  with Type=4 (DCCP-DataAck)                   /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/        Acknowledgement Number Subheader (8 or 4 bytes)        /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                      Options and Padding                      /\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n/                       Application Data                        /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A DCCP-Data or DCCP-DataAck packet may have a zero-length application data area, which indicates that the application sent a zero-length datagram. This differs from DCCP-Request and DCCP-Response packets, where an empty application data area indicates the absence of application data (not the presence of zero-length application data). The API SHOULD report any received zero-length datagrams to the receiving application.",
      "ja": "DCCP-データまたはDCCP-DataAckパケットは、アプリケーションが長さゼロのデータグラムを送信したことを示し、ゼロレングスアプリケーションデータ領域を有していてもよいです。これは、空のアプリケーションデータ領域は、アプリケーションデータがない（ゼロでない長さのアプリケーションデータの有無）を示すDCCP  - 要求とDCCP  - 応答パケットとは異なります。 APIは、受信側アプリケーションへの受信長さがゼロのデータグラムを報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "A DCCP-Ack packet MAY have a non-zero-length application data area, which essentially pads the DCCP-Ack to a desired length. Receivers MUST ignore the content of the application data area in DCCP-Ack packets.",
      "ja": "DCCP-Ackパケットは、本質的に所望の長さにDCCP-ACKをパッド非ゼロレングスアプリケーションデータ領域を有していてもよいです。受信機はDCCP-ACKパケットにおけるアプリケーションデータ領域の内容を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "DCCP-Ack and DCCP-DataAck packets often include additional acknowledgement options, such as Ack Vector, as required by the congestion control mechanism in use.",
      "ja": "DCCP-ACKおよびDCCP-DataAckパケットは、多くの場合、使用中の輻輳制御機構によって要求されるように、そのような肯定応答ベクトルなどの追加の肯定応答オプションを含みます。"
    },
    {
      "indent": 0,
      "text": "5.5. DCCP-CloseReq and DCCP-Close Packets",
      "section_title": true,
      "ja": "5.5.  DCCP-CloseReqとDCCP-閉じるパケット"
    },
    {
      "indent": 3,
      "text": "DCCP-CloseReq and DCCP-Close packets begin the handshake that normally terminates a connection. Either client or server may send a DCCP-Close packet, which will elicit a DCCP-Reset packet. Only the server can send a DCCP-CloseReq packet, which indicates that the server wants to close the connection but does not want to hold its TIMEWAIT state. Both packet types MUST use 48-bit sequence numbers (X=1).",
      "ja": "DCCP-CloseReqとDCCP-閉じるパケットが正常に接続を終了ハンドシェイクを開始します。クライアントまたはサーバのどちらかがDCCP-リセットパケットを誘発するDCCP-閉じるパケットを送信することができます。唯一のサーバは、サーバが接続を閉じるように望んでいることを示しているが、そのTIMEWAIT状態を保持したくないDCCP-CloseReqパケットを、送信することができます。両方のパケットタイプは、48ビットのシーケンス番号（X = 1）を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/            Generic DCCP Header with X=1 (16 bytes)            /\n/         with Type=5 (DCCP-CloseReq) or 6 (DCCP-Close)         /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/          Acknowledgement Number Subheader (8 bytes)           /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                      Options and Padding                      /\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n/                Application Data Area (Ignored)                /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "As with DCCP-Ack packets, DCCP-CloseReq and DCCP-Close packets MAY have non-zero-length application data areas, whose contents receivers MUST ignore.",
      "ja": "DCCP-ACKパケット、DCCP-CloseReqとDCCP-閉じるパケットと同様にその内容が受信機は無視しなければならない非ゼロ長アプリケーションデータ領域を有していてもよいです。"
    },
    {
      "indent": 0,
      "text": "5.6. DCCP-Reset Packets",
      "section_title": true,
      "ja": "5.6.  DCCP-リセットパケット"
    },
    {
      "indent": 3,
      "text": "DCCP-Reset packets unconditionally shut down a connection. Connections normally terminate with a DCCP-Reset, but resets may be sent for other reasons, including bad port numbers, bad option behavior, incorrect ECN Nonce Echoes, and so forth. DCCP-Resets MUST use 48-bit sequence numbers (X=1).",
      "ja": "DCCP-リセットパケットは無条件に接続をシャットダウンします。接続が正常にDCCP-リセットで終了しますが、リセットが悪いなどのポート番号、悪いオプションの振舞い、間違ったECNのNonceエコーズ、およびを含むその他の理由で送信されることがあります。 DCCP-リセットは、48ビットのシーケンス番号（X = 1）を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/            Generic DCCP Header with X=1 (16 bytes)            /\n/                   with Type=7 (DCCP-Reset)                    /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/          Acknowledgement Number Subheader (8 bytes)           /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Reset Code   |    Data 1     |    Data 2     |    Data 3     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                      Options and Padding                      /\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n/              Application Data Area (Error Text)               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Reset Code: 8 bits Represents the reason that the sender reset the DCCP connection.",
      "ja": "コードをリセット：8ビットは送信者がDCCP接続をリセットした理由を表します。"
    },
    {
      "indent": 3,
      "text": "Data 1, Data 2, and Data 3: 8 bits each The Data fields provide additional information about why the sender reset the DCCP connection. The meanings of these fields depend on the value of Reset Code.",
      "ja": "データ1、データ2、データ3：8ビットの各データフィールドは、送信者がDCCP接続をリセットする理由に関する追加情報を提供します。これらのフィールドの意味はリセットコードの値に依存します。"
    },
    {
      "indent": 3,
      "text": "Application Data Area: Error Text If present, Error Text is a human-readable text string encoded in Unicode UTF-8, and preferably in English, that describes the error in more detail. For example, a DCCP-Reset with Reset Code 11, \"Aggression Penalty\", might contain Error Text such as \"Aggression Penalty: Received 3 bad ECN Nonce Echoes, assuming misbehavior\".",
      "ja": "アプリケーションデータ領域：存在する場合はエラーテキストは、エラーテキストは、エラーをより詳細に説明し、好ましくは英語でのUnicode UTF-8でエンコードされた、人間が読み取り可能なテキスト文字列です。 「侵略ペナルティ：不正行為を想定し、3つの悪いECNのNonceエコーズを受信した」たとえば、リセットコード11、「侵略ペナルティ」とDCCP-リセットは、のようなエラーテキストが含まれる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The following Reset Codes are currently defined. Unless otherwise specified, the Data 1, 2, and 3 fields MUST be set to 0 by the sender of the DCCP-Reset and ignored by its receiver. Section references describe concrete situations that will cause each Reset Code to be generated; they are not meant to be exhaustive.",
      "ja": "次のリセットコードは、現在定義されています。特に断らない限り、データ1、2、及び3つのフィールドは、DCCP  - リセットの送信者によって0に設定され、その受信機で無視しなければなりません。セクション参照は、各リセットコードが生成されます、具体的な状況について説明します。それらは、網羅的であることを意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "0, \"Unspecified\" Indicates the absence of a meaningful Reset Code. Use of Reset Code 0 is NOT RECOMMENDED: the sender should choose a Reset Code that more clearly defines why the connection is being reset.",
      "ja": "0は、「指定なし」意味のリセットコードがないことを示します。リセットコード0の使用は推奨されません：送信者は、接続がリセットされている理由をより明確に定義するリセットコードを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "1, \"Closed\" Normal connection close. See Section 8.3.",
      "ja": "1、「クローズ」通常の接続があります。 8.3節を参照してください。"
    },
    {
      "indent": 3,
      "text": "2, \"Aborted\" The sending endpoint gave up on the connection because of lack of progress. See Sections 8.1.1 and 8.1.5.",
      "ja": "2は、「中止」の送信エンドポイントがあるため進捗の欠如の接続をあきらめました。セクション8.1.1と8.1.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "3, \"No Connection\" No connection exists. See Section 8.3.1.",
      "ja": "3、「接続なし」の接続は存在しません。 8.3.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "4, \"Packet Error\" A valid packet arrived with unexpected type. For example, a DCCP-Data packet with valid header checksum and sequence numbers arrived at a connection in the REQUEST state. See Section 8.3.1. The Data 1 field equals the offending packet type as an eight-bit number; thus, an offending packet with Type 2 will result in a Data 1 value of 2.",
      "ja": "4、「パケットエラー」の有効なパケットが予期しない形で到着しました。例えば、有効なヘッダチェックサムとシーケンス番号とのDCCP  - データパケットはREQUEST状態で接続に到着しました。 8.3.1項を参照してください。データ1フィールドは、8ビット数として問題のあるパケットタイプに等しいです。従って、タイプ2との違反パケットは、2のデータ1つの値をもたらすであろう。"
    },
    {
      "indent": 3,
      "text": "5, \"Option Error\" An option was erroneous, and the error was serious enough to warrant resetting the connection. See Sections 6.6.7, 6.6.8, and 11.4. The Data 1 field equals the offending option type; Data 2 and Data 3 equal the first two bytes of option data (or zero if the option had less than two bytes of data).",
      "ja": "5、「オプション誤り」オプションが誤っていた、とエラーが接続をリセット値するほど深刻でした。セクション6.6.7、6.6.8、および11.4を参照してください。データ1つのフィールドは、問題のオプションタイプに等しいです。データ2及びデータ3は、オプションデータの最初の2バイトに等しく（またはゼロオプションは、データの2未満のバイトを有する場合）。"
    },
    {
      "indent": 3,
      "text": "6, \"Mandatory Error\" The sending endpoint could not process an option O that was immediately preceded by Mandatory. The Data fields report the option type and data of option O, using the format of Reset Code 5, \"Option Error\". See Section 5.8.2.",
      "ja": "図6は、「必須のエラーは、」送信エンドポイントはすぐに必須で先行されたオプションのOを処理できませんでした。データフィールドは、リセットコード5、「オプション誤り」の形式を使用して、オプションタイプとオプションOのデータを報告しています。 5.8.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "7, \"Connection Refused\" The Destination Port didn't correspond to a port open for listening. Sent only in response to DCCP-Requests. See Section 8.1.3.",
      "ja": "7は、宛先ポートがリスニングのために開いているポートに対応していませんでした「接続が拒否されました」。 DCCP-要求に応じてのみ送信されます。 8.1.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "8, \"Bad Service Code\" The Service Code didn't equal the service code attached to the Destination Port. Sent only in response to DCCP-Requests. See Section 8.1.3.",
      "ja": "8、「悪いサービスコード」サービスコードは、宛先ポートに付加されたサービスコードを等しくありませんでした。 DCCP-要求に応じてのみ送信されます。 8.1.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "9, \"Too Busy\" The server is too busy to accept new connections. Sent only in response to DCCP-Requests. See Section 8.1.3.",
      "ja": "9、「ビジー状態」サーバーは、新しい接続を受け入れることができないくらい忙しいです。 DCCP-要求に応じてのみ送信されます。 8.1.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "10, \"Bad Init Cookie\" The Init Cookie echoed by the client was incorrect or missing. See Section 8.1.4.",
      "ja": "10は、クライアントによって反響「悪い初期クッキー」のInitクッキーが正しくないか、行方不明でした。セクション8.1.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "11, \"Aggression Penalty\" This endpoint has detected congestion control-related misbehavior on the part of the other endpoint. See Section 12.3.",
      "ja": "11、「攻撃ペナルティ」は、このエンドポイントは他のエンドポイントの一部に輻輳制御に関連する不正行為を検出しました。 12.3節を参照してください。"
    },
    {
      "indent": 3,
      "text": "12-127, Reserved Receivers should treat these codes as they do Reset Code 0, \"Unspecified\".",
      "ja": "彼らは、「指定なし」のコード0をリセットしそうであるように12から127、予約レシーバは、これらのコードを扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "128-255, CCID-specific codes Semantics depend on the connection's CCIDs. See Section 10.3. Receivers should treat unknown CCID-specific Reset Codes as they do Reset Code 0, \"Unspecified\".",
      "ja": "128-255、CCID固有のコードの意味は、接続ののCCIDsに依存します。 10.3節を参照してください。彼らは、「指定なし」のコード0をリセットしそうであるように受信機は、未知のCCID特有のリセットコードを扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "The following table summarizes this information.",
      "ja": "次の表は、この情報をまとめたもの。"
    },
    {
      "indent": 9,
      "text": " Reset\n Code   Name                    Data 1     Data 2 & 3\n -----  ----                    ------     ----------\n   0    Unspecified               0            0\n   1    Closed                    0            0\n   2    Aborted                   0            0\n   3    No Connection             0            0\n   4    Packet Error           pkt type        0\n   5    Option Error           option #   option data\n   6    Mandatory Error        option #   option data\n   7    Connection Refused        0            0\n   8    Bad Service Code          0            0\n   9    Too Busy                  0            0\n  10    Bad Init Cookie           0            0\n  11    Aggression Penalty        0            0\n 12-127 Reserved\n128-255 CCID-specific codes",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Table 2: DCCP Reset Codes",
      "ja": "表2：DCCPは、コードをリセット"
    },
    {
      "indent": 3,
      "text": "Options on DCCP-Reset packets are processed before the connection is shut down. This means that certain combinations of options, particularly involving Mandatory, may cause an endpoint to respond to a valid DCCP-Reset with another DCCP-Reset. This cannot lead to a reset storm; since the first endpoint has already reset the connection, the second DCCP-Reset will be ignored.",
      "ja": "接続がシャットダウンされる前に、DCCP-リセットパケットのオプションが処理されます。これは特に必須に関わるオプションの組み合わせによっては、エンドポイントが別のDCCP-リセットで有効なDCCP-リセットに応答させることを意味します。これは、リセット嵐につながることはできません。最初のエンドポイントが既に接続をリセットしているので、第二のDCCP-リセットは無視されます。"
    },
    {
      "indent": 0,
      "text": "5.7. DCCP-Sync and DCCP-SyncAck Packets",
      "section_title": true,
      "ja": "5.7.  DCCP-SyncとDCCP-SyncAckパケット"
    },
    {
      "indent": 3,
      "text": "DCCP-Sync packets help DCCP endpoints recover synchronization after bursts of loss and recover from half-open connections. Each valid received DCCP-Sync immediately elicits a DCCP-SyncAck. Both packet types MUST use 48-bit sequence numbers (X=1).",
      "ja": "DCCP-Syncのパケットは、DCCP終点は損失のバースト後に同期を回復し、ハーフオープン接続からの回復を助けます。それぞれの有効な受信DCCP-Syncは、すぐにDCCP-SyncAckを誘発します。両方のパケットタイプは、48ビットのシーケンス番号（X = 1）を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/            Generic DCCP Header with X=1 (16 bytes)            /\n/          with Type=8 (DCCP-Sync) or 9 (DCCP-SyncAck)          /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/          Acknowledgement Number Subheader (8 bytes)           /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                      Options and Padding                      /\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n/                Application Data Area (Ignored)                /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Acknowledgement Number field has special semantics for DCCP-Sync and DCCP-SyncAck packets. First, the packet corresponding to a DCCP-Sync's Acknowledgement Number need not have been acknowledgeable. Thus, receivers MUST NOT assume that a packet was processed simply because it appears in the Acknowledgement Number field of a DCCP-Sync packet. This differs from all other packet types, where the Acknowledgement Number by definition corresponds to an acknowledgeable packet. Second, the Acknowledgement Number on any DCCP-SyncAck packet MUST correspond to the Sequence Number on an acknowledgeable DCCP-Sync packet. In the presence of reordering, this might not equal GSR.",
      "ja": "確認応答番号フィールドは、DCCP-SyncとDCCP-SyncAckパケットのための特別な意味を持っています。まず、DCCP同期の確認応答番号に対応するパケットは承認可能となっている必要はありません。このように、受信機は、それがDCCP-同期パケットの確認応答番号フィールドに表示されますので、パケットは単純に処理されたと仮定してはいけません。これは、定義により、確認応答番号が承認可能パケットに対応して他のすべてのパケットタイプとは異なります。第二に、任意のDCCP-SyncAckパケットに確認応答番号が承認可能DCCP同期パケットにシーケンス番号に対応しなければなりません。並べ替えの存在下で、これはGSRと等しくない場合があります。"
    },
    {
      "indent": 3,
      "text": "As with DCCP-Ack packets, DCCP-Sync and DCCP-SyncAck packets MAY have non-zero-length application data areas, whose contents receivers MUST ignore. Padded DCCP-Sync packets may be useful when performing Path MTU discovery; see Section 14.",
      "ja": "DCCP-ACKパケットのように、DCCP-SyncとDCCP-SyncAckパケットは、そのコンテンツ受信機は無視しなければならない非ゼロレングスアプリケーションデータ領域を有していてもよいです。パスMTUディスカバリを実行するときにパッド入りDCCP-Syncのパケットが有用である可能性があります。第14章を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8. Options",
      "section_title": true,
      "ja": "5.8. オプション"
    },
    {
      "indent": 3,
      "text": "Any DCCP packet may contain options, which occupy space at the end of the DCCP header. Each option is a multiple of 8 bits in length. Individual options are not padded to multiples of 32 bits, and any option may begin on any byte boundary. However, the combination of all options MUST add up to a multiple of 32 bits; Padding options MUST be added as necessary to fill out option space to a word boundary. Any options present are included in the header checksum.",
      "ja": "任意のDCCPパケットはDCCPヘッダーの最後にスペースを占有するオプションを含んでいてもよいです。各オプションは、長さが8ビットの倍数です。個々のオプションは、32ビットの倍数に水増しされていない、と任意のオプションは、任意のバイト境界で開始してもよいです。しかし、すべてのオプションの組合せは、32ビットの倍数にならなければなりません。パディングオプションは、ワード境界にオプションスペースを記入し、必要に応じて加えなければなりません。存在する任意のオプションは、ヘッダチェックサムに含まれています。"
    },
    {
      "indent": 3,
      "text": "The first byte of an option is the option type. Options with types 0 through 31 are single-byte options. Other options are followed by a byte indicating the option's length. This length value includes the two bytes of option-type and option-length as well as any option-data bytes; it must therefore be greater than or equal to two.",
      "ja": "オプションの最初のバイトはオプションタイプです。タイプ0〜31でのオプションは、シングルバイトのオプションです。その他のオプションは、オプションの長さを示すバイトが続いています。この長さの値は、オプションタイプとオプション長ならびに任意のオプションデータバイトの2つのバイトを含みます。従って、2以上でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Options MUST be processed sequentially, starting with the first option in the packet header. Options with unknown types MUST be ignored. Also, options with nonsensical lengths (length byte less than two or more than the remaining space in the options portion of the header) MUST be ignored, and any option space following an option with nonsensical length MUST likewise be ignored. Unless otherwise specified, multiple occurrences of the same option MUST be processed independently; for some options, this will mean in practice that the last valid occurrence of an option takes precedence.",
      "ja": "オプションは、パケットヘッダ内の最初のオプションで開始し、順次処理されなければなりません。不明な種類のオプションを無視しなければなりません。また、無意味な長さ（長さバイト2未満またはヘッダのオプション部分の残りの空間より）を持つオプションは無視しなければなりません、そして無意味な長さのオプションを以下のいずれかのオプションのスペースは、同様に無視しなければなりません。特に指定しない限り、同じオプションの複数の出現は、独立して処理しなければなりません。オプションの最後の有効な発生が優先されることにいくつかのオプションのために、これは実際には意味します。"
    },
    {
      "indent": 3,
      "text": "The following options are currently defined:",
      "ja": "以下のオプションは、現在定義されています。"
    },
    {
      "indent": 6,
      "text": "         Option                           DCCP-  Section\n Type    Length     Meaning               Data?  Reference\n ----    ------     -------               -----  ---------\n   0        1       Padding                 Y      5.8.1\n   1        1       Mandatory               N      5.8.2\n   2        1       Slow Receiver           Y      11.6\n 3-31       1       Reserved\n  32     variable   Change L                N      6.1\n  33     variable   Confirm L               N      6.2\n  34     variable   Change R                N      6.1\n  35     variable   Confirm R               N      6.2\n  36     variable   Init Cookie             N      8.1.4\n  37       3-8      NDP Count               Y      7.7\n  38     variable   Ack Vector [Nonce 0]    N      11.4\n  39     variable   Ack Vector [Nonce 1]    N      11.4\n  40     variable   Data Dropped            N      11.7\n  41        6       Timestamp               Y      13.1\n  42      6/8/10    Timestamp Echo          Y      13.3\n  43       4/6      Elapsed Time            N      13.2\n  44        6       Data Checksum           Y      9.3\n 45-127  variable   Reserved\n128-255  variable   CCID-specific options   -      10.3",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Table 3: DCCP Options",
      "ja": "表3：DCCPオプション"
    },
    {
      "indent": 3,
      "text": "Not all options are suitable for all packet types. For example, since the Ack Vector option is interpreted relative to the Acknowledgement Number, it isn't suitable on DCCP-Request and DCCP-Data packets, which have no Acknowledgement Number. If an option occurs on an unexpected packet type, it MUST generally be ignored; any such restrictions are mentioned in each option's description. The table summarizes the most common restriction: when the DCCP-Data? column value is N, the corresponding option MUST be ignored when received on a DCCP-Data packet. (Section 7.5.5 describes why such options are ignored as opposed to, say, causing a reset.)",
      "ja": "いないすべてのオプションは、すべてのパケットタイプに適しています。 Ackベクトルオプションは確認応答番号に関連して解釈されるので、例えば、それは肯定応答番号を持たないDCCP  - 要求とDCCP  - データパケットには適していません。オプションは、予期しないパケットタイプで発生した場合、それは一般的に無視しなければなりません。そのような制限は、各オプションの説明に記載されています。 DCCP-データ：表は、最も一般的な制限を要約したもの？カラムの値がDCCP  - データパケットで受信したときにN、対応するオプションを無視しなければなりませんです。 （セクション7.5.5は、リセットを引き起こし、たとえば、とは対照的に、このようなオプションは無視されている理由を説明しています。）"
    },
    {
      "indent": 3,
      "text": "Options with invalid values MUST be ignored unless otherwise specified. For example, any Data Checksum option with option length",
      "ja": "特に指定がない限り、無効な値を持つオプションを無視しなければなりません。オプションの長さを持つ例えば、任意のデータのチェックサムオプション"
    },
    {
      "indent": 3,
      "text": "4 MUST be ignored, since all valid Data Checksum options have option length 6.",
      "ja": "すべての有効なデータのチェックサム・オプションは、オプションの長さ6を持っているので、4は、無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This section describes two generic options, Padding and Mandatory. Other options are described later.",
      "ja": "このセクションでは、2つの一般的なオプション、パディングと必須を説明しています。その他のオプションについては後述します。"
    },
    {
      "indent": 0,
      "text": "5.8.1. Padding Option",
      "section_title": true,
      "ja": "5.8.1. パディングオプション"
    },
    {
      "indent": 3,
      "text": "+--------+\n|00000000|\n+--------+\n  Type=0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Padding is a single-byte \"no-operation\" option used to pad between or after options. If the length of a packet's other options is not a multiple of 32 bits, then Padding options are REQUIRED to pad out the options area to the length implied by Data Offset. Padding may also be used between options; for example, to align the beginning of a subsequent option on a 32-bit boundary. There is no guarantee that senders will use this option, so receivers must be prepared to process options even if they do not begin on a word boundary.",
      "ja": "パディングはオプションの間または後のパッドに使用されるシングルバイトの「ノーオペレーション」のオプションです。パケットの他のオプションの長さが32ビットの倍数でない場合、パディングオプションは、オフセットデータによって暗黙の長さにオプションエリアアウトパッドが要求されます。パディングはまた、オプションの間で使用されてもよいです。例えば、32ビット境界上の次のオプションの開始を整列させます。受信機は、彼らがワード境界で始まらない場合でも、オプションを処理するために準備しなければならないので、送信者は、このオプションを使用するという保証はありません。"
    },
    {
      "indent": 0,
      "text": "5.8.2. Mandatory Option",
      "section_title": true,
      "ja": "5.8.2. 必須オプション"
    },
    {
      "indent": 3,
      "text": "+--------+\n|00000001|\n+--------+\n  Type=1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Mandatory is a single-byte option that marks the immediately following option as mandatory. Say that the immediately following option is O. Then the Mandatory option has no effect if the receiving DCCP endpoint understands and processes O. If the endpoint does not understand or process O, however, then it MUST reset the connection using Reset Code 6, \"Mandatory Failure\". For instance, the endpoint would reset the connection if it did not understand O's type; if it understood O's type, but not O's data; if O's data was invalid for O's type; if O was a feature negotiation option, and the endpoint did not understand the enclosed feature number; or if the endpoint understood O, but chose not to perform the action O implies. This list is not exhaustive and, in particular, individual option specifications may describe additional situations in which the endpoint should reset the connection and situations in which it should not.",
      "ja": "必須は必須として、すぐに次のオプションをマークシングルバイトオプションです。 「すぐに次のオプションは、受信DCCP終点が理解し、エンドポイントが理解していないか、プロセス・Oは、しかし、それはリセットコード6を使用して接続をリセットしなければならない場合はOを処理する場合O.が続い必須オプションは効果がありませんと言います必須の失敗」。それはOのタイプを理解していない場合たとえば、エンドポイントは、接続をリセットします。それはOのタイプではなく、Oのデータを理解している場合。 Oのデータは、Oのタイプには無効だった場合。 Oは特徴交渉オプションで、エンドポイントは、同封の機能番号を理解していなかった場合。場合、またはエンドポイントがOを理解したが、Oが示すアクションを実行しないことを選択しました。このリストは網羅的なものではないと、特に、個々のオプション仕様は、それがないべきエンドポイントは、接続や状況をリセットするべき追加的な状況を記述することができます。"
    },
    {
      "indent": 3,
      "text": "Mandatory options MUST NOT be sent on DCCP-Data packets, and any Mandatory options received on DCCP-Data packets MUST be ignored.",
      "ja": "必須オプションはDCCP  - データパケットに送ってはいけません、とDCCP  - データパケットで受信したすべての必須オプションは無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The connection is in error and should be reset with Reset Code 5, \"Option Error\", if option O is absent (Mandatory was the last byte of the option list), or if option O equals Mandatory. However, the combination \"Mandatory Padding\" is valid, and MUST behave like two bytes of Padding.",
      "ja": "オプションのOは（必須オプションリストの最後のバイトだった）存在しない場合、またはオプションOが必須等しい場合の接続は、エラーであるとリセットコード5、「オプション誤り」でリセットする必要があります。しかし、組み合わせ「必須パディングは、」有効であり、パディングの2バイトのように動作しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Section 6.6.9 describes the behavior of Mandatory feature negotiation options in more detail.",
      "ja": "6.6.9項では、より詳細に必須の特徴交渉オプションの動作について説明します。"
    },
    {
      "indent": 0,
      "text": "6. Feature Negotiation",
      "section_title": true,
      "ja": "6.機能のネゴシエーション"
    },
    {
      "indent": 3,
      "text": "Four DCCP options, Change L, Confirm L, Change R, and Confirm R, are used to negotiate feature values. Change options initiate a negotiation; Confirm options complete that negotiation. The \"L\" options are sent by the feature location, and the \"R\" options are sent by the feature remote. Change options are retransmitted to ensure reliability.",
      "ja": "四のDCCPオプション、変更Lは、L、Rの変更を確認し、Rを確認して、特徴値を交渉するために使用されています。変更オプションは、交渉を開始します。オプションは、その交渉を完了を確認してください。 「L」オプションは特徴位置によって送信され、そして「R」オプションは、特徴遠隔によって送信されます。変更オプションは、信頼性を確保するために再送信されます。"
    },
    {
      "indent": 3,
      "text": "All these options have the same format. The first byte of option data is the feature number, and the second and subsequent data bytes hold one or more feature values. The exact format of the feature value area depends on the feature type; see Section 6.3.",
      "ja": "これらのオプションはすべて同じフォーマットを持っています。オプションデータの最初のバイトは、特徴数であり、2番目以降のデータバイトは、一つ以上の特徴値を保持します。特徴量領域の正確なフォーマットは、特徴の種類に依存します。 6.3節を参照してください。"
    },
    {
      "indent": 3,
      "text": "+--------+--------+--------+--------+--------\n|  Type  | Length |Feature#| Value(s) ...\n+--------+--------+--------+--------+--------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Together, the feature number and the option type (\"L\" or \"R\") uniquely identify the feature to which an option applies. The exact format of the Value(s) area depends on the feature number.",
      "ja": "一緒に、機能番号及びオプションの種類（「L」または「R」）は、一意のオプションが適用される機能を特定します。値（S）領域の正確なフォーマットは、特徴数に依存します。"
    },
    {
      "indent": 3,
      "text": "Feature negotiation options MUST NOT be sent on DCCP-Data packets, and any feature negotiation options received on DCCP-Data packets MUST be ignored.",
      "ja": "特徴交渉オプションはDCCP  - データパケットに送ってはいけません、とDCCP  - データパケットで受信された任意の特徴交渉オプションは無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.1. Change Options",
      "section_title": true,
      "ja": "6.1. 変更オプション"
    },
    {
      "indent": 3,
      "text": "Change L and Change R options initiate feature negotiation. The option to use depends on the relevant feature's location: To start a negotiation for feature F/A, DCCP A will send a Change L option; to start a negotiation for F/B, it will send a Change R option. Change options are retransmitted until some response is received. They contain at least one Value, and thus have a length of at least 4.",
      "ja": "変更LとRの変更オプションが機能ネゴシエーションを開始します。使用するオプションは、関連する機能の位置によって異なります。機能F / Aのための交渉を開始するには、DCCP Aは変更Lオプションを送信します。 F / Bのための交渉を開始するために、それは変更Rオプションを送信します。いくつかの応答が受信されるまで、変更オプションが再送されています。彼らは、少なくとも1つの値を含み、従って少なくとも4の長さを有しています。"
    },
    {
      "indent": 3,
      "text": "           +--------+--------+--------+--------+--------\nChange L:  |00100000| Length |Feature#| Value(s) ...\n           +--------+--------+--------+--------+--------\n            Type=32",
      "raw": true
    },
    {
      "indent": 3,
      "text": "           +--------+--------+--------+--------+--------\nChange R:  |00100010| Length |Feature#| Value(s) ...\n           +--------+--------+--------+--------+--------\n            Type=34",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.2. Confirm Options",
      "section_title": true,
      "ja": "6.2. オプションを確認"
    },
    {
      "indent": 3,
      "text": "Confirm L and Confirm R options complete feature negotiation and are sent in response to Change R and Change L options, respectively. Confirm options MUST NOT be generated except in response to Change options. Confirm options need not be retransmitted, since Change options are retransmitted as necessary. The first byte of the Confirm option contains the feature number from the corresponding Change. Following this is the selected Value, and then possibly the sender's preference list.",
      "ja": "Lを確認し、Rオプションに完全な機能ネゴシエーションを確認し、それぞれ、RとLの変更オプションを変更するために応答して送信されます。オプションを確認してオプションを変更するには、応答以外で生成してはなりません。変更オプションは、必要に応じて再送信されるためのオプションは、再送信する必要はないことを確認します。 Confirmオプションの最初のバイトは、対応する変更から機能番号が含まれています。これは、選択した値、そしておそらく送信者の優先リストを以下に示します。"
    },
    {
      "indent": 3,
      "text": "           +--------+--------+--------+--------+--------\nConfirm L: |00100001| Length |Feature#| Value(s) ...\n           +--------+--------+--------+--------+--------\n            Type=33",
      "raw": true
    },
    {
      "indent": 3,
      "text": "           +--------+--------+--------+--------+--------\nConfirm R: |00100011| Length |Feature#| Value(s) ...\n           +--------+--------+--------+--------+--------\n            Type=35",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If an endpoint receives an invalid Change option -- with an unknown feature number, or an invalid value -- it will respond with an empty Confirm option containing the problematic feature number, but no value. Such options have length 3.",
      "ja": "未知の機能の数、または無効な値を持つ -   - エンドポイントが無効の変更オプションを受信した場合には、問題のある機能番号を含む空のConfirmオプション、ない値で応答します。このようなオプションは、長さ3を持っています。"
    },
    {
      "indent": 0,
      "text": "6.3. Reconciliation Rules",
      "section_title": true,
      "ja": "6.3. 調整ルール"
    },
    {
      "indent": 3,
      "text": "Reconciliation rules determine how the two sets of preferences for a given feature are resolved into a unique result. The reconciliation rule depends only on the feature number. Each reconciliation rule must have the property that the result is uniquely determined given the contents of Change options sent by the two endpoints.",
      "ja": "調整ルールは、所定の機能に対する好みの二組がユニークな結果に解決される方法を決定します。和解ルールは唯一の機能の数によって異なります。各調整ルールは結果が一意に2つのエンドポイントによって送信された変更オプションの内容を与えて決定された性質を持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "All current DCCP features use one of two reconciliation rules: server-priority (\"SP\") and non-negotiable (\"NN\").",
      "ja": "サーバの優先度（「SP」）と非交渉（「NN」）：現在のすべてのDCCPの特徴は、二つのリコンシリエーション・ルールのいずれかを使用します。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Server-Priority",
      "section_title": true,
      "ja": "6.3.1. サーバーの優先"
    },
    {
      "indent": 3,
      "text": "The feature value is a fixed-length byte string (length determined by the feature number). Each Change option contains a list of values ordered by preference, with the most preferred value coming first. Each Confirm option contains the confirmed value, followed by the confirmer's preference list. Thus, the feature's current value will generally appear twice in Confirm options' data, once as the current value and once in the confirmer's preference list.",
      "ja": "特徴量は、固定長バイト文字列（特徴数によって決定される長さ）です。各変更オプションは、最も好ましい値は、最初に来て、好みによって順序付けされた値のリストが含まれています。各Confirmオプションは、確認者の嗜好リストに続いて確認した値を、含まれています。このように、機能の現在の値は、一般的に確認者の優先リストに一度、現在の値として、一度、確認オプションのデータに2回表示されます。"
    },
    {
      "indent": 3,
      "text": "To reconcile the preference lists, select the first entry in the server's list that also occurs in the client's list. If there is no shared entry, the feature's value MUST NOT change, and the Confirm option will confirm the feature's previous value (unless the Change option was Mandatory; see Section 6.6.9).",
      "ja": "好みのリストを調整するために、また、クライアントのリストに発生し、サーバーのリストの最初のエントリを選択します。何の共有エントリが存在しない場合は、機能の値が変化してはならない、とConfirmオプションは、機能の以前の値を確認します（変更オプションが必須でない限り、6.6.9項を参照してください）。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Non-Negotiable",
      "section_title": true,
      "ja": "6.3.2. 不流通"
    },
    {
      "indent": 3,
      "text": "The feature value is a byte string. Each option contains exactly one feature value. The feature location signals a new value by sending a Change L option. The feature remote MUST accept any valid value, responding with a Confirm R option containing the new value, and it MUST send empty Confirm R options in response to invalid values (unless the Change L option was Mandatory; see Section 6.6.9). Change R and Confirm L options MUST NOT be sent for non-negotiable features; see Section 6.6.8. Non-negotiable features use the feature negotiation mechanism to achieve reliability.",
      "ja": "特徴値はバイト文字列です。各オプションは、1つの特徴値が含まれています。特徴位置は変更Lオプションを送ることによって、新たな価値を知らせます。機能リモコンは、新しい値を含む確認Rオプションで対応し、任意の有効な値を受け入れなければならない、と（変更Lオプションが必須でない限り、6.6.9項を参照）には、無効な値に応じて、空の確認Rオプションを送らなければなりません。 Rを変更し、非交渉機能のために送ってはいけませんLオプションを確認します。 6.6.8項を参照してください。非交渉機能は、信頼性を達成するための特徴交渉メカニズムを使用します。"
    },
    {
      "indent": 0,
      "text": "6.4. Feature Numbers",
      "section_title": true,
      "ja": "6.4. フィーチャー番号"
    },
    {
      "indent": 3,
      "text": "This document defines the following feature numbers.",
      "ja": "このドキュメントでは、次の機能番号を定義します。"
    },
    {
      "indent": 3,
      "text": "                                       Rec'n Initial        Section\nNumber   Meaning                       Rule   Value  Req'd Reference\n------   -------                       -----  -----  ----- ---------\n   0     Reserved\n   1     Congestion Control ID (CCID)   SP      2      Y     10\n   2     Allow Short Seqnos             SP      0      Y     7.6.1\n   3     Sequence Window                NN     100     Y     7.5.2\n   4     ECN Incapable                  SP      0      N     12.1\n   5     Ack Ratio                      NN      2      N     11.3\n   6     Send Ack Vector                SP      0      N     11.5\n   7     Send NDP Count                 SP      0      N     7.7.2\n   8     Minimum Checksum Coverage      SP      0      N     9.2.1\n   9     Check Data Checksum            SP      0      N     9.3.1\n 10-127  Reserved\n128-255  CCID-specific features                              10.3",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Table 4: DCCP Feature Numbers",
      "ja": "表4：DCCPフィーチャー番号"
    },
    {
      "indent": 3,
      "text": "Rec'n Rule The reconciliation rule used for the feature. SP means server-priority, NN means non-negotiable.",
      "ja": "機能のために使用さ和解のルールをルールRec'n。 SPは、サーバーの優先順位を意味し、NNは、譲渡禁止を意味します。"
    },
    {
      "indent": 3,
      "text": "Initial Value The initial value for the feature. Every feature has a known initial value.",
      "ja": "初期値機能の初期値。すべての機能は、既知の初期値を持っています。"
    },
    {
      "indent": 3,
      "text": "Req'd This column is \"Y\" if and only if every DCCP implementation MUST understand the feature. If it is \"N\", then the feature behaves like an extension (see Section 15), and it is safe to respond to Change options for the feature with empty Confirm options. Of course, a CCID might require the feature; a DCCP that implements CCID 2 MUST support Ack Ratio and Send Ack Vector, for example.",
      "ja": "このコラムReq'dすべてのDCCP実装が機能を理解しなければならない場合に限り、「Y」です。それは「N」であれば、機能が拡張（セクション15を参照）のように振る舞い、空の確認オプションを使用して、機能のオプションを変更するに応答しても安全です。もちろん、CCIDは、機能が必要になることがあります。 CCID 2を実装DCCPは、ACK比率をサポートし、例えば、のAckベクトルを送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.5. Feature Negotiation Examples",
      "section_title": true,
      "ja": "6.5. 特徴交渉の例"
    },
    {
      "indent": 3,
      "text": "Here are three example feature negotiations for features located at the server, the first two for the Congestion Control ID feature, the last for the Ack Ratio.",
      "ja": "ここでは3例機能サーバにある機能の交渉、輻輳制御ID機能のための最初の二つは、ACK比率の最後のです。"
    },
    {
      "indent": 6,
      "text": "           Client                     Server\n           ------                     ------\n1. Change R(CCID, 2 3 1)  -->\n   (\"2 3 1\" is client's preference list)\n2.                        <--  Confirm L(CCID, 3, 3 2 1)\n                         (3 is the negotiated value;\n                         \"3 2 1\" is server's pref list)\n            * agreement that CCID/Server = 3 *",
      "raw": true
    },
    {
      "indent": 6,
      "text": "1. XXX <-- Change L(CCID, 3 2 1) 2. Retransmission: <-- Change L(CCID, 3 2 1) 3. Confirm R(CCID, 3, 2 3 1) --> * agreement that CCID/Server = 3 *",
      "ja": "1. XXX < - 変更L（CCID、3 2 1）2再送< - 変更L（CCID、3 2 1）3.確認R（CCID、3、2 3 1） - > *合意CCID /サーバ= 3 *"
    },
    {
      "indent": 6,
      "text": "1. <-- Change L(Ack Ratio, 3) 2. Confirm R(Ack Ratio, 3) --> * agreement that Ack Ratio/Server = 3 *",
      "ja": "1. < - 変更L（肯定応答率、3）2.確認R（肯定応答率、3） - > *契約のAck比/サーバ= 3 *"
    },
    {
      "indent": 3,
      "text": "This example shows a simultaneous negotiation.",
      "ja": "この例では、同時交渉を示しています。"
    },
    {
      "indent": 6,
      "text": "            Client                     Server\n            ------                     ------\n1a. Change R(CCID, 2 3 1)  -->\n b.                        <--  Change L(CCID, 3 2 1)\n2a.                        <--  Confirm L(CCID, 3, 3 2 1)\n b. Confirm R(CCID, 3, 2 3 1)  -->\n             * agreement that CCID/Server = 3 *",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here are the byte encodings of several Change and Confirm options. Each option is sent by DCCP A.",
      "ja": "ここではいくつかの変更のバイトエンコーディングがあり、オプションを確認してください。各オプションは、DCCP Aによって送られます"
    },
    {
      "indent": 3,
      "text": "Change L(CCID, 2 3) = 32,5,1,2,3 DCCP B should change CCID/A's value (feature number 1, a server-priority feature); DCCP A's preferred values are 2 and 3, in that preference order.",
      "ja": "変化L（CCID、2 3）= 32,5,1,2,3 DCCP Bは、（フィーチャー番号1、サーバ優先機能）CCID / Aの値を変更すべきです。 DCCP Aの好ましい値は、優先順に、2及び3です。"
    },
    {
      "indent": 3,
      "text": "Change L(Sequence Window, 1024) = 32,9,3,0,0,0,0,4,0 DCCP B should change Sequence Window/A's value (feature number 3, a non-negotiable feature) to the 6-byte string 0,0,0,0,4,0 (the value 1024).",
      "ja": "変化L（シーケンスウィンドウ、1024）= 32,9,3,0,0,0,0,4,0 DCCP Bは、シーケンスウィンドウ/ Aの値を変更する必要があり（フィーチャー番号3、非交渉機能）6〜バイト文字列0,0,0,0,4,0（値1024）。"
    },
    {
      "indent": 3,
      "text": "Confirm L(CCID, 2, 2 3) = 33,6,1,2,2,3 DCCP A has changed CCID/A's value to 2; its preferred values are 2 and 3, in that preference order.",
      "ja": "（CCID、2、2 3）Lを確認= 33,6,1,2,2,3 DCCP A 2にCCID / Aの値を変更しました。その好ましい値は、優先順に、2及び3です。"
    },
    {
      "indent": 3,
      "text": "Empty Confirm L(126) = 33,3,126 DCCP A doesn't implement feature number 126, or DCCP B's proposed value for feature 126/A was invalid.",
      "ja": "空の確認L（126）= 33,3,126 DCCP Aは、特徴番号126を実装していない、または機能126 / AのためのDCCP Bの提案された値が無効でした。"
    },
    {
      "indent": 3,
      "text": "Change R(CCID, 3 2) = 34,5,1,3,2 DCCP B should change CCID/B's value; DCCP A's preferred values are 3 and 2, in that preference order.",
      "ja": "変更R（CCID、3 2）= 34,5,1,3,2 DCCP Bは、CCID / Bの値を変更すべきです。 DCCP Aの好ましい値は、優先順に、3及び2です。"
    },
    {
      "indent": 3,
      "text": "Confirm R(CCID, 2, 3 2) = 35,6,1,2,3,2 DCCP A has changed CCID/B's value to 2; its preferred values were 3 and 2, in that preference order.",
      "ja": "R（CCID、2、3 2）を確認= 35,6,1,2,3,2 DCCP Aは2にCCID / Bの値を変更しました。その好ましい値は、優先順に、3及び2でした。"
    },
    {
      "indent": 3,
      "text": "Confirm R(Sequence Window, 1024) = 35,9,3,0,0,0,0,4,0 DCCP A has changed Sequence Window/B's value to the 6-byte string 0,0,0,0,4,0 (the value 1024).",
      "ja": "R（シーケンスウィンドウ、1024）を確認= 35,9,3,0,0,0,0,4,0 DCCP Aは、6バイトの文字列0,0,0,0,4にシーケンスウィンドウ/ Bの値を変更しました、0（値1024）。"
    },
    {
      "indent": 3,
      "text": "Empty Confirm R(126) = 35,3,126 DCCP A doesn't implement feature number 126, or DCCP B's proposed value for feature 126/B was invalid.",
      "ja": "空の確認R（126）= 35,3,126 DCCP Aは、特徴番号126を実装していない、または機能126 / BのためのDCCP Bの提案された値が無効でした。"
    },
    {
      "indent": 0,
      "text": "6.6. Option Exchange",
      "section_title": true,
      "ja": "6.6. オプション取引"
    },
    {
      "indent": 3,
      "text": "A few basic rules govern feature negotiation option exchange.",
      "ja": "いくつかの基本的なルールは特徴交渉オプションの交換を支配します。"
    },
    {
      "indent": 3,
      "text": "1. Every non-reordered Change option gets a Confirm option in response.",
      "ja": "1.すべての非並べ替えを変更するオプションは、応答におけるConfirmオプションを取得します。"
    },
    {
      "indent": 3,
      "text": "2. Change options are retransmitted until a response for the latest Change is received.",
      "ja": "最新の変更のための応答が受信されるまで2.変更オプションが再送されています。"
    },
    {
      "indent": 3,
      "text": "3. Feature negotiation options are processed in strictly-increasing order by Sequence Number.",
      "ja": "3.特徴交渉オプションは、シーケンス番号によって厳密に増加順に処理されます。"
    },
    {
      "indent": 3,
      "text": "The rest of this section describes the consequences of these rules in more detail.",
      "ja": "このセクションの残りの部分は、より詳細にこれらのルールの結果を説明します。"
    },
    {
      "indent": 0,
      "text": "6.6.1. Normal Exchange",
      "section_title": true,
      "ja": "6.6.1. 通常取引"
    },
    {
      "indent": 3,
      "text": "Change options are generated when a DCCP endpoint wants to change the value of some feature. Generally, this will happen at the beginning of a connection, although it may happen at any time. We say the endpoint \"generates\" or \"sends\" a Change L or Change R option, but of course the option must be attached to a packet. The endpoint may attach the option to a packet it would have generated anyway (such as a DCCP-Request), or it may create a \"feature negotiation packet\", often a DCCP-Ack or DCCP-Sync, just to carry the option. Feature negotiation packets are controlled by the relevant congestion control mechanism. For example, DCCP A may send a DCCP-Ack or DCCP-Sync for feature negotiation only if the B-to-A CCID would allow sending a DCCP-Ack. In addition, an endpoint SHOULD generate at most one feature negotiation packet per round-trip time.",
      "ja": "変更オプションは、DCCP終点は、いくつかの機能の値を変更したいときに生成されます。それはいつでも起こるかもしれませんが、一般的に、これは、接続の開始時に発生します。私たちは、エンドポイントが、「生成」または変更Lまたは変更Rオプションを「送信」が、もちろんオプションは、パケットに付加されなければならないと言います。エンドポイントは、それが（例えばDCCP-要求として）とにかく生成しているだろうか、それだけでオプションを運ぶために、「特徴交渉パケット」、しばしばDCCP-ACKまたはDCCP-Syncを作成することができ、パケットにオプションをつけてもよいです。機能ネゴシエーションパケットは、関連する輻輳制御機構によって制御されています。例えば、DCCP AはB対A CCIDがDCCP-ACKを送信できるようになる場合にのみ機能ネゴシエーションのためにDCCP-ACKまたはDCCP-Syncを送信することができます。また、エンドポイントは、ラウンドトリップ時間あたり最大1つの特徴交渉パケットを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "On receiving a Change L or Change R option, a DCCP endpoint examines the included preference list, reconciles that with its own preference list, calculates the new value, and sends back a Confirm R or Confirm L option, respectively, informing its peer of the new value or that the feature was not understood. Every non-reordered Change option MUST result in a corresponding Confirm option, and any packet including a Confirm option MUST carry an Acknowledgement Number. (Section 6.6.4 describes how Change reordering is detected and handled.) Generated Confirm options may be attached to packets that would have been sent anyway (such as DCCP-Response or DCCP-SyncAck) or to new feature negotiation packets, as described above.",
      "ja": "変更Lまたは変更Rオプションを受信するのピアに知らせる、それぞれ、DCCP終点は、含まれる優先リストを調べ、自身の好みのリストと、新しい値を計算することを両立し、確認Rを返信またはLオプションを確認します新しい価値や機能を理解していなかったこと。すべての非並べ替えの変更オプションは、対応するConfirmオプションをもたらさなければなりません、とConfirmオプションを含むすべてのパケットが確認応答番号を運ばなければなりません。 （セクション6.6.4は、変更の並べ替えが検出され、処理される方法を説明します。）（例えばDCCP-応答またはDCCP-SyncAckとして）、または新しい機能ネゴシエーションパケットにとにかく送られていたであろうパケットに取り付けることができるオプションを確認して生成され、上記のように。"
    },
    {
      "indent": 3,
      "text": "The Change-sending endpoint MUST wait to receive a corresponding Confirm option before changing its stored feature value. The Confirm-sending endpoint changes its stored feature value as soon as it sends the Confirm.",
      "ja": "変更-送信エンドポイントは、その保存された特徴値を変更する前に、対応するConfirmオプションを受け取るのを待たなければなりません。確認-送信エンドポイントは、すぐにそれが確認を送るように、その記憶された特徴値を変更します。"
    },
    {
      "indent": 3,
      "text": "A packet MAY contain more than one feature negotiation option, possibly including two options that refer to the same feature; as usual, the options are processed sequentially.",
      "ja": "パケットは、おそらく同じ機能を参照する2つの選択肢を含む複数の特徴交渉オプションを含んでいてもよいです。いつものように、オプションが順番に処理されます。"
    },
    {
      "indent": 0,
      "text": "6.6.2. Processing Received Options",
      "section_title": true,
      "ja": "6.6.2. 処理の受信オプション"
    },
    {
      "indent": 3,
      "text": "DCCP endpoints exist in one of three states relative to each feature. STABLE is the normal state, where the endpoint knows the feature's value and thinks the other endpoint agrees. An endpoint enters the CHANGING state when it first sends a Change for the feature and returns to STABLE once it receives a corresponding Confirm. The final state, UNSTABLE, indicates that an endpoint in CHANGING state changed its preference list but has not yet transmitted a Change option with the new preference list.",
      "ja": "DCCP終点は、各機能に対する3つの状態が存在します。 STABLEは、エンドポイントが機能の価値を知っているし、他のエンドポイントが同意考えて通常の状態、です。それが第一の特徴のために変更を送信し、それが対応することを確認を受けた後、STABLEに戻ったときにエンドポイントは、CHANGING状態になります。 UNSTABLE最終状態は、状態を変更におけるエンドポイントがその優先リストを変更したが、まだ新しい優先リストでの変更のオプションを送信していないことを示しています。"
    },
    {
      "indent": 3,
      "text": "Feature state transitions at a feature location are implemented according to this diagram. The diagram ignores sequence number and option validity issues; these are handled explicitly in the pseudocode that follows.",
      "ja": "特徴位置における特徴の状態遷移は、この図に従って実装されます。図は、シーケンス番号とオプションの妥当性の問題を無視します。これらは、以下の擬似コードで明示的に処理されています。"
    },
    {
      "indent": 1,
      "text": "                                                         timeout/\nrcv Confirm R      app/protocol evt : snd Change L       rcv non-ack\n: ignore      +---------------------------------------+  : snd Change L\n     +----+   |                                       |  +----+\n     |    v   |                   rcv Change R        v  |    v\n  +------------+  rcv Confirm R   : calc new value, +------------+\n  |            |  : accept value    snd Confirm L   |            |\n  |   STABLE   |<-----------------------------------|  CHANGING  |\n  |            |        rcv empty Confirm R         |            |\n  +------------+        : revert to old value       +------------+\n      |    ^                                            |    ^\n      +----+                                  pref list |    | snd\nrcv Change R                                  changes   |    | Change L\n: calc new value, snd Confirm L                         v    |\n                                                    +------------+\n                                                +---|            |\n                           rcv Confirm/Change R |   |  UNSTABLE  |\n                           : ignore             +-->|            |\n                                                    +------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Feature locations SHOULD use the following pseudocode, which corresponds to the state diagram, to react to each feature negotiation option on each valid non-Data packet received. The pseudocode refers to \"P.seqno\" and \"P.ackno\", which are properties of the packet; \"O.type\" and \"O.len\", which are properties of the option; \"FGSR\" and \"FGSS\", which are properties of the connection and handle reordering as described in Section 6.6.4; \"F.state\", which is the feature's state (STABLE, CHANGING, or UNSTABLE); and \"F.value\", which is the feature's value.",
      "ja": "特徴位置は、受け取ったそれぞれの有効な非データパケットの各特徴交渉オプションに反応するように、状態図に対応し、以下の擬似コードを使用する必要があります。擬似コードは、パケットの特性である「P.seqno」および「P.ackno」を指します。オプションのプロパティである「O.type」と「O.len」、。接続のプロパティであり、セクション6.6.4に記載のように並べ替え処理「FGSR」および「FGSS」;機能の状態（安定、変化、または不安定）である「F.state」;機能の値であり、「F.value」、。"
    },
    {
      "indent": 3,
      "text": "First, check for unknown features (Section 6.6.7);\n   If F is unknown,\n      If the option was Mandatory,   /* Section 6.6.9 */\n         Reset connection and return\n      Otherwise, if O.type == Change R,\n         Send Empty Confirm L on a future packet",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Return",
      "ja": "リターン"
    },
    {
      "indent": 3,
      "text": "Second, check for reordering (Section 6.6.4); If F.state == UNSTABLE or P.seqno <= FGSR or (O.type == Confirm R and P.ackno < FGSS), Ignore option and return",
      "ja": "第二に、（セクション6.6.4）を並べ替えるかどうかを確認。 F.stateは==不安定になったりP.seqno <= FGSR又は（O.type ==確認R及びP.ackno <FGSS）、オプションとリターンを無視した場合"
    },
    {
      "indent": 3,
      "text": "Third, process Change R options;\n   If O.type == Change R,\n      If the option's value is valid,   /* Section 6.6.8 */\n         Calculate new value\n         Send Confirm L on a future packet\n         Set F.state := STABLE\n      Otherwise, if the option was Mandatory,\n         Reset connection and return\n      Otherwise,\n         Send Empty Confirm L on a future packet\n         /* Remain in existing state.  If that's CHANGING, this\n            endpoint will retransmit its Change L option later. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Fourth, process Confirm R options (but only in CHANGING state).\n   If F.state == CHANGING and O.type == Confirm R,\n      If O.len > 3,   /* nonempty */\n         If the option's value is valid,\n            Set F.value := new value\n         Otherwise,\n            Reset connection and return\n      Set F.state := STABLE",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Versions of this diagram and pseudocode are also used by feature remotes; simply switch the \"L\"s and \"R\"s, so that the relevant options are Change R and Confirm L.",
      "ja": "この図と擬似コードのバージョンも機能のリモコンで使用されています。単純に関連するオプションが変更Rになるように、「L」sおよび「R」Sを切り替えるとL.を確認"
    },
    {
      "indent": 0,
      "text": "6.6.3. Loss and Retransmission",
      "section_title": true,
      "ja": "6.6.3. 損失および再送信"
    },
    {
      "indent": 3,
      "text": "Packets containing Change and Confirm options might be lost or delayed by the network. Therefore, Change options are repeatedly transmitted to achieve reliability. We refer to this as \"retransmission\", although of course there are no packet-level retransmissions in DCCP: a Change option that is sent again will be sent on a new packet with a new sequence number.",
      "ja": "変更を含むパケットとオプションを確認するには、ネットワークによって失われたり、遅れる場合がございます。そのため、変更オプションを繰り返し、信頼性を達成するために送信されます。もちろんDCCPにはパケットレベルの再送信されないが、私たちは、「再送信」としてこれを参照してください：再送信される変更オプションは、新しいシーケンス番号の新しいパケットに送信されます。"
    },
    {
      "indent": 3,
      "text": "A CHANGING endpoint transmits another Change option once it realizes that it has not heard back from the other endpoint. The new Change option need not contain the same payload as the original; reordering protection will ensure that agreement is reached based on the most recently transmitted option.",
      "ja": "それが戻って、他のエンドポイントから聞いていないことを理解したら、CHANGING終点は、他の変更オプションを送信します。新しい変更オプションは、オリジナルと同じペイロードを含む必要はありません。その合意を確保する並べ替え保護は、最も最近に送信オプションをもとに達しています。"
    },
    {
      "indent": 3,
      "text": "A CHANGING endpoint MUST continue retransmitting Change options until it gets some response or the connection terminates.",
      "ja": "CHANGING終点は、それはいくつかの応答を取得または接続が終了するまで変更オプションを再送継続する必要があります。"
    },
    {
      "indent": 3,
      "text": "Endpoints SHOULD use an exponential-backoff timer to decide when to retransmit Change options. (Packets generated specifically for feature negotiation MUST use such a timer.) The timer interval is initially set to not less than one round-trip time, and should back off to not less than 64 seconds. The backoff protects against delayed agreement due to the reordering protection algorithms described in the next section. Again, endpoints may piggyback Change options on packets they would have sent anyway or create new packets to carry the options. Any new packets are controlled by the relevant congestion-control mechanism.",
      "ja": "エンドポイントは、変更オプションを再送するタイミングを決定するために、指数バックオフタイマーを使用すべきです。 （パケットは、そのようなタイマーを使用しなければならない機能の交渉のために特別に生成される。）タイマー間隔は最初はない1未満のラウンドトリップ時間に設定され、64秒以上にバックオフする必要があります。バックオフが原因次のセクションで説明並び替え保護アルゴリズムに遅延合意を防ぎます。ここでも、エンドポイントは、彼らがオプションを運ぶために、とにかく送信または新しいパケットを作成していたパケットの変更オプションを背負うことがあります。すべての新しいパケットは、関連する輻輳制御機構によって制御されています。"
    },
    {
      "indent": 3,
      "text": "Confirm options are never retransmitted, but the Confirm-sending endpoint MUST generate a Confirm option after every non-reordered Change.",
      "ja": "確認したオプションは、再送信されることはありませんが、確認-送信するエンドポイントは、すべての非並べ替えの変更後のConfirmオプションを発生させなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.6.4. Reordering",
      "section_title": true,
      "ja": "6.6.4. 並べ替え"
    },
    {
      "indent": 3,
      "text": "Reordering might cause packets containing Change and Confirm options to arrive in an unexpected order. Endpoints MUST ignore feature negotiation options that do not arrive in strictly-increasing order by Sequence Number. The rest of this section presents two algorithms that fulfill this requirement.",
      "ja": "並べ替えは、変更を含むパケットを引き起こし、予想外の順序で到着するオプションを確認することがあります。エンドポイントは、シーケンス番号によって厳密に昇順に到着しない特徴交渉オプションを無視しなければなりません。この節の残りの部分では、この要件を満たす2つのアルゴリズムを提示します。"
    },
    {
      "indent": 3,
      "text": "The first algorithm introduces two sequence number variables that each endpoint maintains for the connection.",
      "ja": "最初のアルゴリズムは、各エンドポイントが接続のために維持するに、2つのシーケンス番号変数を導入します。"
    },
    {
      "indent": 3,
      "text": "FGSR Feature Greatest Sequence Number Received: The greatest sequence number received, considering only valid packets that contained one or more feature negotiation options (Change and/or Confirm). This value is initialized to ISR - 1.",
      "ja": "受信FGSRフィーチャー最大のシーケンス番号は：最大のシーケンス番号は、一つ以上の特徴交渉オプション（変更および/または確認）が含まれていた唯一の有効なパケットを考慮すると、受け取りました。 1  - この値は、ISRに初期化されます。"
    },
    {
      "indent": 3,
      "text": "FGSS Feature Greatest Sequence Number Sent: The greatest sequence number sent, considering only packets that contained one or more new Change options. A Change option is new if and only if it was generated during a transition from the STABLE or UNSTABLE state to the CHANGING state; Change options generated within the CHANGING state are retransmissions and MUST have exactly the same contents as previously transmitted options, allowing tolerance for reordering. FGSS is initialized to ISS.",
      "ja": "1つ以上の新しい変更オプションが含まれているパケットのみを考慮すると、送信された最大の配列番号：FGSSは、送信最大のシーケンス番号を備えています。変更オプションがあれば、新規であり、それは、CHANGING状態に安定または不安定状態からの遷移中に生成された場合にのみ。 CHANGING状態内で発生する変更のオプションは再送信され、並べ替えのための許容範囲をできるように、以前に送信オプションとまったく同じ内容を持たなければなりません。 FGSSは、ISSに初期化されます。"
    },
    {
      "indent": 3,
      "text": "Each endpoint checks two conditions on sequence numbers to decide whether to process received feature negotiation options.",
      "ja": "各エンドポイントは受け取った特徴交渉オプションを処理するかどうかを決定するために、シーケンス番号に2つの条件をチェックします。"
    },
    {
      "indent": 3,
      "text": "1. If a packet's Sequence Number is less than or equal to FGSR, then its Change options MUST be ignored.",
      "ja": "パケットのシーケンス番号が以下FGSRに等しい場合は1、その変更オプションは無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If a packet's Sequence Number is less than or equal to FGSR, if it has no Acknowledgement Number, OR if its Acknowledgement Number is less than FGSS, then its Confirm options MUST be ignored.",
      "ja": "2.それは確認応答番号を持っていない、またはその承認番号がFGSS未満である場合には、その確認のオプションは無視されなければならない場合は、パケットのシーケンス番号は、以下FGSRに等しい場合。"
    },
    {
      "indent": 3,
      "text": "Alternatively, an endpoint MAY maintain separate FGSR and FGSS values for every feature. FGSR(F/X) would equal the greatest sequence number received, considering only packets that contained Change or Confirm options applying to feature F/X; FGSS(F/X) would be defined similarly. This algorithm requires more state, but is slightly more forgiving to multiple overlapped feature negotiations. Either algorithm MAY be used; the first algorithm, with connection-wide FGSR and FGSS variables, is RECOMMENDED.",
      "ja": "また、エンドポイントは、すべての機能のための独立したFGSRとFGSS値を維持することができます。 FGSR（F / X）が変更を含んでいたパケットのみを考慮し、最大シーケンス番号が受信等しいか又はF / Xを特色する適用オプションを確認することになります。 FGSS（F / X）が同様に定義されます。このアルゴリズムは、より多くの状態を必要としますが、複数の重複した特徴交渉にもう少し寛容です。どちらのアルゴリズムが使用されてもよいです。接続全体FGSRとFGSS変数との最初のアルゴリズムは、推奨されます。"
    },
    {
      "indent": 3,
      "text": "One consequence of these rules is that a CHANGING endpoint will ignore any Confirm option that does not acknowledge the latest Change option sent. This ensures that agreement, once achieved, used the most recent available information about the endpoints' preferences.",
      "ja": "これらのルールの1つの結果は、CHANGING終点が送られた最新の変更オプションを認めていない任意のConfirmオプションを無視するということです。これは、一度達成合意は、エンドポイントの好みについての最新の入手可能な情報を使用することを保証します。"
    },
    {
      "indent": 0,
      "text": "6.6.5. Preference Changes",
      "section_title": true,
      "ja": "6.6.5. プリファレンスの変更"
    },
    {
      "indent": 3,
      "text": "Endpoints are allowed to change their preference lists at any time. However, an endpoint that changes its preference list while in the CHANGING state MUST transition to the UNSTABLE state. It will transition back to CHANGING once it has transmitted a Change option with the new preference list. This ensures that agreement is based on active preference lists. Without the UNSTABLE state, simultaneous negotiation -- where the endpoints began independent negotiations for the same feature at the same time -- might lead to the negotiation's terminating with the endpoints thinking the feature had different values.",
      "ja": "エンドポイントは、いつでも自分の好みのリストを変更することが許可されています。しかし、変更状態にある間、その優先リストを変更するエンドポイントが不安定な状態に移行しなければなりません。それは新しい優先リストでの変更のオプションを送信した後に変更することに戻って移行します。これは、契約は、アクティブ優先リストに基づいていることを保証します。不安定な状態がなければ、同時交渉 - エンドポイントが同時に同じ機能のための独立した交渉を開始しました - 機能を考えて、エンドポイントが異なる値を持っていたとの交渉の終結につながる可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.6.6. Simultaneous Negotiation",
      "section_title": true,
      "ja": "6.6.6. 同時交渉"
    },
    {
      "indent": 3,
      "text": "The two endpoints might simultaneously open negotiation for the same feature, after which an endpoint in the CHANGING state will receive a Change option for the same feature. Such received Change options can act as responses to the original Change options. The CHANGING endpoint MUST examine the received Change's preference list, reconcile that with its own preference list (as expressed in its generated Change options), and generate the corresponding Confirm option. It can then transition to the STABLE state.",
      "ja": "2つのエンドポイントは、CHANGING状態の終点は同じ機能の変更オプションを受け取るた後、同じ機能、同時にオープン交渉をすることがあります。このような受信した変更オプションは、元の変更オプションへの応答としての役割を果たすことができます。変更エンドポイントは、受信した変更の好みのリストを調べる（その生成された変更オプションで表現されるように）それ自身の好みのリストとそれを照合し、対応する確認オプションを生成しなければなりません。それは安定した状態に遷移することができます。"
    },
    {
      "indent": 0,
      "text": "6.6.7. Unknown Features",
      "section_title": true,
      "ja": "6.6.7. 不明な特長"
    },
    {
      "indent": 3,
      "text": "Endpoints may receive Change options referring to feature numbers they do not understand -- for instance, when an extended DCCP converses with a non-extended DCCP. Endpoints MUST respond to unknown Change options with Empty Confirm options (that is, Confirm options containing no data), which inform the CHANGING endpoint that the feature was not understood. However, if the Change option was Mandatory, the connection MUST be reset; see Section 6.6.9.",
      "ja": "例えば、拡張DCCPが非拡張DCCPと対話するとき - エンドポイントは、彼らが理解していない数字を特徴とする参照の変更オプションを受け取ることができます。エンドポイントは、機能が理解されなかったCHANGING終点を知らせる空の確認オプション（つまり、何もデータを含まないオプションを確認してください）、未知の変更オプションに反応しなければなりません。変更オプションが必須だった場合は、接続をリセットする必要があります。 6.6.9項を参照してください。"
    },
    {
      "indent": 3,
      "text": "On receiving an empty Confirm option for some feature, the CHANGING endpoint MUST transition back to the STABLE state, leaving the feature's value unchanged. Section 15 suggests that the default value for any extension feature correspond to \"extension not available\".",
      "ja": "いくつかの機能のための空のConfirmオプションを受け取ると、CHANGING終点は、機能の値が変わらないままに、安定した状態に戻って遷移する必要があります。セクション15は、任意の拡張機能のデフォルト値は「利用できない拡張子」に対応することを示唆しています。"
    },
    {
      "indent": 3,
      "text": "Some features are required to be understood by all DCCPs (see Section 6.4). The CHANGING endpoint SHOULD reset the connection (with Reset Code 5, \"Option Error\") if it receives an empty Confirm option for such a feature.",
      "ja": "一部の機能は、すべてのDCCPsが理解される必要がある（6.4節を参照してください）。それは、このような機能のための空のConfirmオプションを受信した場合CHANGING終点は、（リセットコード5、「オプション誤り」との）接続をリセットする必要があります。"
    },
    {
      "indent": 3,
      "text": "Since Confirm options are generated only in response to Change options, an endpoint should never receive a Confirm option referring to a feature number it does not understand. Nevertheless, endpoints MUST ignore any such options they receive.",
      "ja": "確認オプションは、オプションを変更するためにのみ応答して生成されるので、エンドポイントは、それが理解していない機能番号を参照Confirmオプションを受け取ることはありません。それにもかかわらず、エンドポイントは、彼らが受け取るどのようなオプションを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.6.8. Invalid Options",
      "section_title": true,
      "ja": "6.6.8. 無効なオプション"
    },
    {
      "indent": 3,
      "text": "A DCCP endpoint might receive a Change or Confirm option for a known feature that lists one or more values that it does not understand. Some, but not all, such options are invalid, depending on the relevant reconciliation rule (Section 6.3). For instance:",
      "ja": "DCCP終点は変更を受けるか、それは理解していない1つ以上の値を示しています知られている機能のオプションを確認することがあります。いくつかは、すべてではないが、そのようなオプションは、関連する和解規則（6.3節）に応じて、無効です。例えば："
    },
    {
      "indent": 3,
      "text": "o All features have length limitations, and options with invalid lengths are invalid. For example, the Ack Ratio feature takes 16-bit values, so valid \"Confirm R(Ack Ratio)\" options have option length 5.",
      "ja": "Oすべての機能は、長さの制限があり、不正な長さのオプションは無効です。例えば、肯定応答比フィーチャは、16ビットの値を取るので、有効な「R（のAck比）を確認」オプションは、オプションの長さ5を有します。"
    },
    {
      "indent": 3,
      "text": "o Some non-negotiable features have value limitations. The Ack Ratio feature takes two-byte, non-zero integer values, so a \"Change L(Ack Ratio, 0)\" option is never valid. Note that server-priority features do not have value limitations, since unknown values are handled as a matter of course.",
      "ja": "Oいくつかの非交渉機能は、値の制限があります。 Ack比フィーチャは、2バイト、ゼロ以外の整数値をとるので、「変更L（Ackを比、0）」オプションが有効になることはありません。未知の値は、当然のこととして扱われるため、サーバーの優先度の機能は、値の制限を持たないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Any Confirm option that selects the wrong value, based on the two preference lists and the relevant reconciliation rule, is invalid.",
      "ja": "O 2つの好みのリストと関連する和解のルールに基づいて、間違った値を選択し、任意のConfirmオプションは、無効です。"
    },
    {
      "indent": 3,
      "text": "However, unexpected Confirm options -- that refer to unknown feature numbers, or that don't appear to be part of a current negotiation -- are not invalid, although they are ignored by the receiver.",
      "ja": "しかし、予想外の確認オプション - 未知の機能番号を参照、またはそれは、現在の交渉の一部であることが表示されません - 彼らは受信機で無視しているが、無効ではありません。"
    },
    {
      "indent": 3,
      "text": "An endpoint receiving an invalid Change option MUST respond with the corresponding empty Confirm option. An endpoint receiving an invalid Confirm option MUST reset the connection, with Reset Code 5, \"Option Error\".",
      "ja": "不正な変更オプションを受信エンドポイントは、対応する空のConfirmオプションで応じなければなりません。無効Confirmオプションを受け取るエンドポイントはリセットコード5、「オプション誤り」との接続を、リセットする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6.9. Mandatory Feature Negotiation",
      "section_title": true,
      "ja": "6.6.9. 必須機能のネゴシエーション"
    },
    {
      "indent": 3,
      "text": "Change options may be preceded by Mandatory options (Section 5.8.2). Mandatory Change options are processed like normal Change options except that the following failure cases will cause the receiver to reset the connection with Reset Code 6, \"Mandatory Failure\", rather than send a Confirm option. The connection MUST be reset if:",
      "ja": "変更オプションは必須オプション（セクション5.8.2）が先行することができます。必須の変更オプションには、次の障害の場合は、受信機がリセットコード6、「必須失敗」との接続をリセットするのではなく、Confirmオプションを送信するようになりますことを除いて、通常の変更オプションのように処理されます。場合は、接続をリセットする必要があります："
    },
    {
      "indent": 3,
      "text": "o the Change option's feature number was not understood;",
      "ja": "Oの変更オプションの機能番号が理解されていませんでした。"
    },
    {
      "indent": 3,
      "text": "o the Change option's value was invalid, and the receiver would normally have sent an empty Confirm option in response; or",
      "ja": "Oの変更オプションの値が無効であり、受信機は、通常、応答における空のConfirmオプションを送っているだろう。または"
    },
    {
      "indent": 3,
      "text": "o for server-priority features, there was no shared entry in the two endpoints' preference lists.",
      "ja": "サーバーの優先度の機能のoは、2つのエンドポイントの好みのリストには、共有エントリはありませんでした。"
    },
    {
      "indent": 3,
      "text": "Other failure cases do not cause connection reset; in particular, reordering protection may cause a Mandatory Change option to be ignored without resetting the connection.",
      "ja": "その他の障害の場合は、接続リセットは発生しません。具体的には、並べ替えの保護は、接続をリセットせずに無視することが必須の変更オプションを引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "Confirm options behave identically and have the same reset conditions whether or not they are Mandatory.",
      "ja": "オプションは同じように動作し、それらが必須かどうか、同じリセット条件を持っていることを確認します。"
    },
    {
      "indent": 0,
      "text": "7. Sequence Numbers",
      "section_title": true,
      "ja": "7.シーケンス番号"
    },
    {
      "indent": 3,
      "text": "DCCP uses sequence numbers to arrange packets into sequence, to detect losses and network duplicates, and to protect against attackers, half-open connections, and the delivery of very old packets. Every packet carries a Sequence Number; most packet types carry an Acknowledgement Number as well.",
      "ja": "DCCPは、シーケンスにパケットを配置する損失やネットワークの重複を検出すると、攻撃者は、ハーフオープン接続、および非常に古いパケットの配信から保護するためにシーケンス番号を使用しています。すべてのパケットは、シーケンス番号を運びます。ほとんどのパケットタイプは、同様に確認応答番号を運びます。"
    },
    {
      "indent": 3,
      "text": "DCCP sequence numbers are packet based. That is, Sequence Numbers generated by each endpoint increase by one, modulo 2^48, per packet. Even DCCP-Ack and DCCP-Sync packets, and other packets that don't carry user data, increment the Sequence Number. Since DCCP is an unreliable protocol, there are no true retransmissions, but effective retransmissions, such as retransmissions of DCCP-Request packets, also increment the Sequence Number. This lets DCCP implementations detect network duplication, retransmissions, and acknowledgement loss; it is a significant departure from TCP practice.",
      "ja": "DCCPのシーケンス番号は、パケットベースです。すなわち、パケットごとに一つ、各エンドポイントの増加、モジュロ2 ^ 48によって生成されたシーケンス番号です。でも、DCCP-AckのとDCCP-同期パケット、およびユーザデータを運ばない他のパケットは、シーケンス番号をインクリメントします。 DCCPは信頼できないプロトコルであるので、そこには真の再送はありませんが、このようなDCCP-Requestパケットの再送信などの効果的な再送信は、また、シーケンス番号をインクリメントします。これはDCCP実装がネットワーク複製、再送信、および承認損失を検出することができます。それはTCPの練習から大幅に逸脱しています。"
    },
    {
      "indent": 0,
      "text": "7.1. Variables",
      "section_title": true,
      "ja": "7.1. 変数"
    },
    {
      "indent": 3,
      "text": "DCCP endpoints maintain a set of sequence number variables for each connection.",
      "ja": "DCCP終点は、各接続のシーケンス番号変数のセットを維持します。"
    },
    {
      "indent": 3,
      "text": "ISS The Initial Sequence Number Sent by this endpoint. This equals the Sequence Number of the first DCCP-Request or DCCP-Response sent.",
      "ja": "ISSこのエンドポイントによって送信された初期シーケンス番号。これは最初のDCCP-要求または送信されたDCCP  - 応答のシーケンス番号に等しいです。"
    },
    {
      "indent": 3,
      "text": "ISR The Initial Sequence Number Received from the other endpoint. This equals the Sequence Number of the first DCCP-Request or DCCP-Response received.",
      "ja": "他のエンドポイントから受信した初期シーケンス番号ISR。これは、受信した最初DCCP-要求またはDCCP-応答のシーケンス番号に等しいです。"
    },
    {
      "indent": 3,
      "text": "GSS The Greatest Sequence Number Sent by this endpoint. Here, and elsewhere, \"greatest\" is measured in circular sequence space.",
      "ja": "GSSこのエンドポイントによって送信された最大のシーケンス番号。ここでは、他の場所、「最大」は、円形の系列スペースで測定されます。"
    },
    {
      "indent": 3,
      "text": "GSR The Greatest Sequence Number Received from the other endpoint on an acknowledgeable packet. (Section 7.4 defines this term.)",
      "ja": "GSR承認可能パケット上の他のエンドポイントから受信した最大のシーケンス番号。 （7.4節は、この用語を定義します。）"
    },
    {
      "indent": 3,
      "text": "GAR The Greatest Acknowledgement Number Received from the other endpoint on an acknowledgeable packet that was not a DCCP-Sync.",
      "ja": "GAR DCCP-Syncのではなかった承認可能パケット上の他のエンドポイントから受信した最大の確認番号。"
    },
    {
      "indent": 3,
      "text": "Some other variables are derived from these primitives.",
      "ja": "いくつかの他の変数は、これらのプリミティブに由来しています。"
    },
    {
      "indent": 3,
      "text": "SWL and SWH (Sequence Number Window Low and High) The extremes of the validity window for received packets' Sequence Numbers.",
      "ja": "SWLとSWH（シーケンス番号ウィンドウLowとHigh）受信パケットのシーケンス番号の有効ウィンドウの両極端。"
    },
    {
      "indent": 3,
      "text": "AWL and AWH (Acknowledgement Number Window Low and High) The extremes of the validity window for received packets' Acknowledgement Numbers.",
      "ja": "AWLとAWH（承認番号ウィンドウLowとHigh）受信パケットの確認応答番号の有効ウィンドウの両極端。"
    },
    {
      "indent": 0,
      "text": "7.2. Initial Sequence Numbers",
      "section_title": true,
      "ja": "7.2. 初期シーケンス番号"
    },
    {
      "indent": 3,
      "text": "The endpoints' initial sequence numbers are set by the first DCCP-Request and DCCP-Response packets sent. Initial sequence numbers MUST be chosen to avoid two problems:",
      "ja": "エンドポイントの初期シーケンス番号が送信された最初のDCCP-要求とDCCP-応答パケットによって設定されています。初期シーケンス番号は、二つの問題を回避するために選ばなければなりません。"
    },
    {
      "indent": 3,
      "text": "o delivery of old packets, where packets lingering in the network from an old connection are delivered to a new connection with the same addresses and port numbers; and",
      "ja": "古い接続からネットワークに長引くパケットが同じアドレスとポート番号との新しい接続に配信されている古いパケットのO配信。そして"
    },
    {
      "indent": 3,
      "text": "o sequence number attacks, where an attacker can guess the sequence numbers that a future connection would use [M85].",
      "ja": "攻撃者は、将来の接続は、[M85]を使用することをシーケンス番号を推測することができ、シーケンス番号攻撃、O。"
    },
    {
      "indent": 3,
      "text": "These problems are the same as those faced by TCP, and DCCP implementations SHOULD use TCP's strategies to avoid them [RFC793, RFC1948]. The rest of this section explains these strategies in more detail.",
      "ja": "[RFC793、RFC1948]これらの問題は、TCPが直面しているものと同じであり、DCCP実装は、それらを避けるために、TCPの戦略を使用すべきです。このセクションの残りの部分は、より詳細にこれらの戦略を説明します。"
    },
    {
      "indent": 3,
      "text": "To address the first problem, an implementation MUST ensure that the initial sequence number for a given <source address, source port, destination address, destination port> 4-tuple doesn't overlap with recent sequence numbers on previous connections with the same 4-tuple. (\"Recent\" means sent within 2 maximum segment lifetimes, or 4 minutes.) The implementation MUST additionally ensure that the lower 24 bits of the initial sequence number don't overlap with the lower 24 bits of recent sequence numbers (unless the implementation plans to avoid short sequence numbers; see Section 7.6). An implementation that has state for a recent connection with the same 4-tuple can pick a good initial sequence number explicitly. Otherwise, it could tie initial sequence number selection to some clock, such as the 4-microsecond clock used by TCP [RFC793]. Two separate clocks may be required, one for the upper 24 bits and one for the lower 24 bits.",
      "ja": "最初の問題に対処するために、実装は確保しなければならないことを指定された<ソースアドレス、ソースポート、宛先アドレス、宛先ポート> 4タプルは、同じ4-以前の接続における最近のシーケンス番号と重複しないための初期シーケンス番号タプル。 （2つの最大セグメント寿命、または4分以内に送信された「最近の」を意味する。）の実装は、さらに初期シーケンス番号の下位24ビットは、実施計画しない限り、（最近のシーケンス番号の下位24ビットと重複しないようにする必要があり短いシーケンス番号を避けるために、7.6節を参照してください）。同じ4組との最近の接続の状態を持っている実装は、明示的に良好な初期シーケンス番号を選ぶことができます。それ以外の場合は、TCP [RFC793]で使用される4マイクロ秒のクロックとして、いくつかのクロックに初期シーケンス番号の選択を結ぶことができました。二つの別個のクロックは、上位24ビット用と下位24ビットのための1つを必要とすることができます。"
    },
    {
      "indent": 3,
      "text": "To address the second problem, an implementation MUST provide each 4-tuple with an independent initial sequence number space. Then, opening a connection doesn't provide any information about initial sequence numbers on other connections to the same host. [RFC1948] achieves this by adding a cryptographic hash of the 4-tuple and a secret to each initial sequence number. For the secret, [RFC1948] recommends a combination of some truly random data [RFC4086], an administratively installed passphrase, the endpoint's IP address, and the endpoint's boot time, but truly random data is sufficient. Care should be taken when the secret is changed; such a change alters all initial sequence number spaces, which might make an initial sequence number for some 4-tuple equal a recently sent sequence number for the same 4-tuple. To avoid this problem, the endpoint might remember dead connection state for each 4-tuple or stay quiet for 2 maximum segment lifetimes around such a change.",
      "ja": "第二の問題に対処するために、実装は、独立した初期シーケンス番号スペースで各4タプルを提供しなければなりません。その後、接続を開くと、同じホストに他の接続の初期シーケンス番号に関する情報を提供していません。 [RFC1948]は、各初期シーケンス番号に4タプルと秘密の暗号ハッシュを追加することによって、これを達成します。秘密の場合は、[RFC1948]はいくつかの本当にランダムデータ[RFC4086]、行政インストールパスフレーズ、エンドポイントのIPアドレス、およびエンドポイントのブート時間の組み合わせを推奨していますが、真にランダムなデータが十分です。秘密が変更されたときには注意が必要です。そのような変化は、同一の4タプルのためのいくつかの4-タプル等しい最近送信されたシーケンス番号の初期シーケンス番号を作る可能性のあるすべての初期シーケンス番号空間を変化させます。この問題を回避するために、エンドポイントは各4タプルのために死んだの接続状態を覚えているか、そのような変化を約2つの最大セグメント寿命のために静かにとどまる可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.3. Quiet Time",
      "section_title": true,
      "ja": "7.3. 静かな時間"
    },
    {
      "indent": 3,
      "text": "DCCP endpoints, like TCP endpoints, must take care before initiating connections when they boot. In particular, they MUST NOT send packets whose sequence numbers are close to the sequence numbers of packets lingering in the network from before the boot. The simplest way to enforce this rule is for DCCP endpoints to avoid sending any packets until one maximum segment lifetime (2 minutes) after boot.",
      "ja": "TCPエンドポイントのようなDCCPエンドポイントは、それらが起動時に接続を開始する前に注意しなければなりません。特に、それらは、その配列番号ブート前からネットワークに長引くパケットのシーケンス番号に近いパケットを送ってはいけません。 DCCPエンドポイントが起動次々最大セグメント寿命（2分）までの任意のパケットを送信することを避けるために、このルールを適用する最も簡単な方法です。"
    },
    {
      "indent": 3,
      "text": "Other enforcement mechanisms include remembering recent sequence numbers across boots and reserving the upper 8 or so bits of initial sequence numbers for a persistent counter that decrements by two each boot. (The latter mechanism would require disallowing packets with short sequence numbers; see Section 7.6.1.)",
      "ja": "その他の実施メカニズムは、ブーツ全体で、最近のシーケンス番号を記憶し、2各ブートでデクリメント永続的なカウンタの初期シーケンス番号の上位8かそこらビットを確保含まれています。 （後者のメカニズムは、短いシーケンス番号を持つパケットを拒否必要とする;セクション7.6.1を参照します。）"
    },
    {
      "indent": 0,
      "text": "7.4. Acknowledgement Numbers",
      "section_title": true,
      "ja": "7.4. 謝辞番号"
    },
    {
      "indent": 3,
      "text": "Cumulative acknowledgements are meaningless in an unreliable protocol. Therefore, DCCP's Acknowledgement Number field has a different meaning from TCP's.",
      "ja": "累積確認応答は、信頼できないプロトコルでは無意味です。したがって、DCCPの承認番号フィールドには、TCPの異なる意味を持ちます。"
    },
    {
      "indent": 3,
      "text": "A received packet is classified as acknowledgeable if and only if its header was successfully processed by the receiving DCCP. In terms of the pseudocode in Section 8.5, a received packet becomes acknowledgeable when the receiving endpoint reaches Step 8. This means, for example, that all acknowledgeable packets have valid header checksums and sequence numbers. A sent packet's Acknowledgement Number MUST equal the sending endpoint's GSR, the Greatest Sequence Number Received on an acknowledgeable packet, for all packet types except DCCP-Sync and DCCP-SyncAck.",
      "ja": "受信されたパケットは、IF承認可能として分類され、そのヘッダが正常に受信DCCPによって処理された場合にのみ。セクション8.5の擬似コードの点で、受信したパケットは、受信エンドポイントが、すべての承認可能パケットが有効なヘッダチェックサムとシーケンス番号を持っていること、例えば、これは、ステップ8に到達したときに承認可能となります。送信されたパケットの確認応答番号は、送信エンドポイントのGSR、DCCP-SyncとDCCP-SyncAck以外のすべてのパケットタイプのため、承認可能パケットで最もすばらしいSequence Number Receivedと等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "\"Acknowledgeable\" does not refer to data processing. Even acknowledgeable packets may have their application data dropped, due to receive buffer overflow or corruption, for instance. Data Dropped options report these data losses when necessary, letting congestion control mechanisms distinguish between network losses and endpoint losses. This issue is discussed further in Sections 11.4 and 11.7.",
      "ja": "「承認可能」は、データ処理を参照していません。承認可能パケットは、それらのアプリケーションデータは、例えば、バッファオーバーフローや破損を受けることにより、低下していることができます。データが必要なときのオプションが輻輳制御メカニズムは、ネットワークの損失とエンドポイントの損失を区別せ、これらのデータの損失を報告して落としました。この問題は、セクション11.4と11.7でさらに議論されています。"
    },
    {
      "indent": 3,
      "text": "DCCP-Sync and DCCP-SyncAck packets' Acknowledgement Numbers differ as follows: The Acknowledgement Number on a DCCP-Sync packet corresponds to a received packet, but not necessarily to an acknowledgeable packet; in particular, it might correspond to an out-of-sync packet whose options were not processed. The Acknowledgement Number on a DCCP-SyncAck packet always corresponds to an acknowledgeable DCCP-Sync packet; it might be less than GSR in the presence of reordering.",
      "ja": "次のようにDCCP-SyncとDCCP-SyncAckパケットの確認応答番号が異なる：DCCP同期パケットに確認応答番号は必ずしも必要ではないが承認可能パケットに、受信したパケットに対応します。特に、それは、そのオプションが処理されなかった外の同期パケットに対応することがあります。 DCCP-SyncAckパケットの確認応答番号は、常に受け付け可能DCCP-Syncのパケットに対応します。それは、並べ替えの存在下でのGSR未満であるかもしれません。"
    },
    {
      "indent": 0,
      "text": "7.5. Validity and Synchronization",
      "section_title": true,
      "ja": "7.5. 有効性と同期"
    },
    {
      "indent": 3,
      "text": "Any DCCP endpoint might receive packets that are not actually part of the current connection. For instance, the network might deliver an old packet, an attacker might attempt to hijack a connection, or the other endpoint might crash, causing a half-open connection.",
      "ja": "任意のDCCP終点は、実際には現在の接続の一部ではないパケットを受け取ることがあります。例えば、ハーフオープン接続を引き起こして、古いパケットを配信する可能性があるネットワークでは、攻撃者が接続をハイジャックしようとしたり、他のエンドポイントがクラッシュする可能性があります。"
    },
    {
      "indent": 3,
      "text": "DCCP, like TCP, uses sequence number checks to detect these cases. Packets whose Sequence and/or Acknowledgement Numbers are out of range are called sequence-invalid and are not processed normally.",
      "ja": "DCCPは、TCPのように、これらのケースを検出するためのシーケンス番号のチェックを使用しています。その配列および/または承認番号が範囲外の系列無効と呼ばれ、正常に処理されていないパケット。"
    },
    {
      "indent": 3,
      "text": "Unlike TCP, DCCP requires a synchronization mechanism to recover from large bursts of loss. One endpoint might send so many packets during a burst of loss that when one of its packets finally got through, the other endpoint would label its Sequence Number as invalid. A handshake of DCCP-Sync and DCCP-SyncAck packets recovers from this case.",
      "ja": "TCPとは異なり、DCCPは、損失の大バーストから回復するために同期メカニズムが必要です。一方のエンドポイントは、そのパケットの1つが最終的に通じ得たとき、他のエンドポイントは無効とそのシーケンス番号にラベルを付けるだろうと損失のバースト中に非常に多くのパケットを送信することがあります。 DCCP-SyncとDCCP-SyncAckパケットのハンドシェークは、この場合から回復します。"
    },
    {
      "indent": 0,
      "text": "7.5.1. Sequence and Acknowledgement Number Windows",
      "section_title": true,
      "ja": "7.5.1. シーケンスおよび確認応答番号のWindows"
    },
    {
      "indent": 3,
      "text": "Each DCCP endpoint defines sequence validity windows that are subsets of the Sequence and Acknowledgement Number spaces. These windows correspond to packets the endpoint expects to receive in the next few round-trip times. The Sequence and Acknowledgement Number windows always contain GSR and GSS, respectively. The window widths are controlled by Sequence Window features for the two half-connections.",
      "ja": "各DCCP終点は、シーケンスおよび確認応答番号スペースのサブセットである一連の妥当性の窓を定義します。これらのウィンドウは、エンドポイントは、次のいくつかのラウンドトリップ時間に受信することを期待パケットに対応しています。シーケンスおよび確認応答番号のウィンドウは、常に、それぞれ、GSRとGSSが含まれています。ウィンドウの幅は、二つの半接続のためのシーケンスウィンドウ機能によって制御されています。"
    },
    {
      "indent": 3,
      "text": "The Sequence Number validity window for packets from DCCP B is [SWL, SWH]. This window always contains GSR, the Greatest Sequence Number Received on a sequence-valid packet from DCCP B. It is W packets wide, where W is the value of the Sequence Window/B feature. One-fourth of the sequence window, rounded down, is less than or equal to GSR, and three-fourths is greater than GSR. (This asymmetric placement assumes that bursts of loss are more common in the network than significant reorderings.)",
      "ja": "DCCP Bからのパケットのシーケンス番号の有効性ウィンドウは[SWL、SWH]です。このウィンドウには、常にGSR、Wはシーケンスウィンドウ/ Bの機能の値であり、Wパケット広いですDCCP B.それから配列の有効なパケットで最もすばらしいSequence Number Receivedが含まれています。切り捨てシーケンスウィンドウの4分の1は、以下GSRに等しく、四分の三は、GSRよりも大きいです。 （この非対称配置は、損失のバーストが重要reorderingsよりもネットワークでより一般的であることを前提としています。）"
    },
    {
      "indent": 3,
      "text": "  invalid  |       valid Sequence Numbers        |  invalid\n<---------*|*===========*=======================*|*--------->\n      GSR -|GSR + 1 -   GSR                 GSR +|GSR + 1 +\n floor(W/4)|floor(W/4)                 ceil(3W/4)|ceil(3W/4)\n            = SWL                           = SWH",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Acknowledgement Number validity window for packets from DCCP B is [AWL, AWH]. The high end of the window, AWH, equals GSS, the Greatest Sequence Number Sent by DCCP A; the window is W' packets wide, where W' is the value of the Sequence Window/A feature.",
      "ja": "DCCP Bからのパケットの確認応答番号の有効性ウィンドウは[AWL、AWH]です。ウィンドウのハイエンド、AWH、GSS、DCCP Aによって送信された最大のシーケンス番号が等しいです。ウィンドウシーケンスウィンドウ/特徴の値はW「Wは、ここで、パケット広い」です。"
    },
    {
      "indent": 3,
      "text": "  invalid  |    valid Acknowledgement Numbers    |  invalid\n<---------*|*===================================*|*--------->\n   GSS - W'|GSS + 1 - W'                      GSS|GSS + 1\n            = AWL                           = AWH",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SWL and AWL are initially adjusted so that they are not less than the initial Sequence Numbers received and sent, respectively:",
      "ja": "これらはそれぞれ、受信及び送信された初期シーケンス番号以上であるようにSWLとAWLは、最初に調整されます。"
    },
    {
      "indent": 9,
      "text": "SWL := max(GSR + 1 - floor(W/4), ISR),\nAWL := max(GSS + 1 - W', ISS).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "These adjustments MUST be applied only at the beginning of the connection. (Long-lived connections may wrap sequence numbers so that they appear to be less than ISR or ISS; the adjustments MUST NOT be applied in that case.)",
      "ja": "これらの調整は、接続の開始時にのみ適用されなければなりません。 （彼らはISRかISSより少ないように見えるように、長命の接続は、シーケンス番号をラップすることがあり、調整は、その場合に適用してはなりません。）"
    },
    {
      "indent": 0,
      "text": "7.5.2. Sequence Window Feature",
      "section_title": true,
      "ja": "7.5.2. シーケンスウィンドウ機能"
    },
    {
      "indent": 3,
      "text": "The Sequence Window/A feature determines the width of the Sequence Number validity window used by DCCP B and the width of the Acknowledgement Number validity window used by DCCP A. DCCP A sends a \"Change L(Sequence Window, W)\" option to notify DCCP B that the Sequence Window/A value is W.",
      "ja": "シーケンスウィンドウ/特徴はDCCP Bによって使用されるシーケンス番号の有効性ウィンドウの幅を決定し、DCCP A. DCCP Aによって使用される確認応答番号の有効性ウィンドウの幅を通知するための「変更L（シーケンスウィンドウ、W）」オプションを送りますDCCP Bシーケンスウィンドウ/ Aの値が、Wであること"
    },
    {
      "indent": 3,
      "text": "Sequence Window has feature number 3 and is non-negotiable. It takes 48-bit (6-byte) integer values, like DCCP sequence numbers. Change and Confirm options for Sequence Window are therefore 9 bytes long. New connections start with Sequence Window 100 for both endpoints. The minimum valid Sequence Window value is Wmin = 32. The maximum valid Sequence Window value is Wmax = 2^46 - 1 = 70368744177663. Change options suggesting Sequence Window values out of this range are invalid and MUST be handled accordingly.",
      "ja": "シーケンスウィンドウは、機能番号3を持っており、非交渉です。これはDCCPシーケンス番号と同様に、48ビット（6バイト）の整数値をとります。変更およびシーケンスウィンドウのオプションを確認するには、したがって、9バイトの長さです。新しい接続は、両方のエンドポイントのシーケンスウィンドウ100で始まります。最小の有効なシーケンスウィンドウ値は最大有効シーケンスウィンドウ値Wminと= 32である値Wmax = 2 ^ 46  - でこの範囲外のシーケンスウィンドウ値を示唆1 = 70368744177663.変更オプションは無効であり、それに応じて取り扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "A proper Sequence Window/A value must reflect the number of packets DCCP A expects to be in flight. Only DCCP A can anticipate this number. Values that are too small increase the risk of the endpoints getting out sync after bursts of loss, and values that are much too small can prevent productive communication whether or not there is loss. On the other hand, too-large values increase the risk of connection hijacking; Section 7.5.5 quantifies this risk. One good guideline is for each endpoint to set Sequence Window to about five times the maximum number of packets it expects to send in a round-trip time. Endpoints SHOULD send Change L(Sequence Window) options, as necessary, as the connection progresses. Also, an endpoint MUST NOT persistently send more than its Sequence Window number of packets per round-trip time; that is, DCCP A MUST NOT persistently send more than Sequence Window/A packets per RTT.",
      "ja": "適切なシーケンスウィンドウ/値がDCCP Aが飛行中であることを期待するパケットの数を反映しなければなりません。唯一のDCCP Aは、この数を予測することができます。あまりにも小さくて損失のバースト後に同期を抜け出すエンドポイントのリスクは小さすぎる増加された値、および値は損失があるかどうかを生産通信を防ぐことができます。一方、大きすぎる値は、接続ハイジャックのリスクを高めます。 7.5.5項では、このリスクを定量化します。一つの良いガイドラインは約5倍に、それは往復時間に送信することを期待するパケットの最大数をシーケンスウィンドウを設定するために、各エンドポイントのためです。接続が進むにつれてエンドポイントは、必要に応じて変更L（シーケンスウィンドウ）のオプションを、送信すべきです。また、エンドポイントは、持続的に往復時間当たりのパケットのシーケンスウィンドウの数よりも多くを送ってはいけません。つまり、DCCP Aは、永続的にRTTごとのシーケンスウィンドウ/ Aパケット以上のものを送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "7.5.3. Sequence-Validity Rules",
      "section_title": true,
      "ja": "7.5.3. シーケンス・妥当性ルール"
    },
    {
      "indent": 3,
      "text": "Sequence-validity depends on the received packet's type. This table shows the sequence and acknowledgement number checks applied to each packet; a packet is sequence-valid if it passes both tests, and sequence-invalid if it does not. Many of the checks refer to the sequence and acknowledgement number validity windows [SWL, SWH] and [AWL, AWH] defined in Section 7.5.1.",
      "ja": "シーケンス・妥当性は、受信したパケットの種類によって異なります。このテーブルは、シーケンスと、各パケットに適用される確認応答番号の確認を示す図です。そうでない場合には、テスト、および系列無効の両方に合格した場合、パケットは配列有効です。チェックの多くは、7.5.1項で定義された順序と確認応答番号の妥当性の窓[SWL、SWH]と[AWL、AWH]を参照してください。"
    },
    {
      "indent": 3,
      "text": "                                          Acknowledgement Number\nPacket Type      Sequence Number Check    Check\n-----------      ---------------------    ----------------------\nDCCP-Request     SWL <= seqno <= SWH (*)  N/A\nDCCP-Response    SWL <= seqno <= SWH (*)  AWL <= ackno <= AWH\nDCCP-Data        SWL <= seqno <= SWH      N/A\nDCCP-Ack         SWL <= seqno <= SWH      AWL <= ackno <= AWH\nDCCP-DataAck     SWL <= seqno <= SWH      AWL <= ackno <= AWH\nDCCP-CloseReq    GSR <  seqno <= SWH      GAR <= ackno <= AWH\nDCCP-Close       GSR <  seqno <= SWH      GAR <= ackno <= AWH\nDCCP-Reset       GSR <  seqno <= SWH      GAR <= ackno <= AWH\nDCCP-Sync        SWL <= seqno             AWL <= ackno <= AWH\nDCCP-SyncAck     SWL <= seqno             AWL <= ackno <= AWH",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(*) Check not applied if connection is in LISTEN or REQUEST state.",
      "ja": "（*）接続がLISTENやREQUEST状態にある場合には適用されません確認してください。"
    },
    {
      "indent": 3,
      "text": "In general, packets are sequence-valid if their Sequence and Acknowledgement Numbers lie within the corresponding valid windows, [SWL, SWH] and [AWL, AWH]. The exceptions to this rule are as follows:",
      "ja": "それらの配列確認応答番号が対応する有効ウィンドウ内に存在する場合、一般的に、パケットがシーケンス有効である、[SWL、SWH]と[AWL、AWH]。次のようにこのルールの例外は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Since DCCP-CloseReq, DCCP-Close, and DCCP-Reset packets end a connection, they cannot have Sequence Numbers less than or equal to GSR, or Acknowledgement Numbers less than GAR.",
      "ja": "O DCCPクローズDCCP-CloseReq、以来、およびDCCP  - リセットパケットが接続を終了し、それらは以下GAR未満GSR、または確認応答番号に等しいシーケンス番号を持つことができません。"
    },
    {
      "indent": 3,
      "text": "o DCCP-Sync and DCCP-SyncAck Sequence Numbers are not strongly checked. These packet types exist specifically to get the endpoints back into sync; checking their Sequence Numbers would eliminate their usefulness.",
      "ja": "O DCCP-SyncとDCCP-SyncAckシーケンス番号が強くチェックされません。これらのパケットタイプは、バック同期にエンドポイントを取得するために、具体的に存在します。そのシーケンス番号をチェックしてその有用性を排除するであろう。"
    },
    {
      "indent": 3,
      "text": "The lenient checks on DCCP-Sync and DCCP-SyncAck packets allow continued operation after unusual events, such as endpoint crashes and large bursts of loss, but there's no need for leniency in the absence of unusual events -- that is, during ongoing successful communication. Therefore, DCCP implementations SHOULD use the following, more stringent checks for active connections, where a connection is considered active if it has received valid packets from the other endpoint within the last three round-trip times.",
      "ja": "DCCP-SyncとDCCP-SyncAckパケットの寛大なチェックは、このようなエンドポイントのクラッシュや損失の大バーストなど、異常なイベント、後に運転を続けてできますが、異常なイベントが存在しない場合に寛大のための必要はありません - つまり、継続的な成功を収め通信中。したがって、DCCP実装は、それが最後の三つのラウンドトリップ時間内に他のエンドポイントから有効なパケットを受信した場合、接続がアクティブであると考えられるアクティブな接続は、次の、より厳しいチェックを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "                                          Acknowledgement Number\nPacket Type      Sequence Number Check    Check\n-----------      ---------------------    ----------------------\nDCCP-Sync        SWL <= seqno <= SWH      AWL <= ackno <= AWH\nDCCP-SyncAck     SWL <= seqno <= SWH      AWL <= ackno <= AWH",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Finally, an endpoint MAY apply the following more stringent checks to DCCP-CloseReq, DCCP-Close, and DCCP-Reset packets, further lowering the probability of successful blind attacks using those packet types.",
      "ja": "最後に、エンドポイントは、さらに、それらのパケットタイプを使用して成功したブラインド攻撃の確率を下げ、DCCP-CloseReq、DCCP-閉じる、およびDCCP  - リセットパケットを次のように、より厳格なチェックを適用することができます。"
    },
    {
      "indent": 3,
      "text": "Since these checks can cause extra synchronization overhead and delay connection closing when packets are lost, they should be considered experimental.",
      "ja": "これらのチェックは、余分な同期のオーバーヘッドが発生し、パケットが失われたときに、接続閉鎖を遅らせることができるので、彼らは実験的と考えるべきです。"
    },
    {
      "indent": 3,
      "text": "                                          Acknowledgement Number\nPacket Type      Sequence Number Check    Check\n-----------      ---------------------    ----------------------\nDCCP-CloseReq    seqno == GSR + 1         GAR <= ackno <= AWH\nDCCP-Close       seqno == GSR + 1         GAR <= ackno <= AWH\nDCCP-Reset       seqno == GSR + 1         GAR <= ackno <= AWH",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that sequence-validity is only one of the validity checks applied to received packets.",
      "ja": "その配列妥当性のみ受信パケットに適用される妥当性チェックのいずれかであることに注意。"
    },
    {
      "indent": 0,
      "text": "7.5.4. Handling Sequence-Invalid Packets",
      "section_title": true,
      "ja": "7.5.4. 系列無効パケットの処理"
    },
    {
      "indent": 3,
      "text": "Endpoints respond to received sequence-invalid packets as follows.",
      "ja": "次のようにエンドポイントは、受信系列無効のパケットに応答します。"
    },
    {
      "indent": 3,
      "text": "o Any sequence-invalid DCCP-Sync or DCCP-SyncAck packet MUST be ignored.",
      "ja": "O任意の系列無効DCCP同期またはDCCP-SyncAckパケットを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A sequence-invalid DCCP-Reset packet MUST elicit a DCCP-Sync packet in response (subject to a possible rate limit). This response packet MUST use a new Sequence Number, and thus will increase GSS; GSR will not change, however, since the received packet was sequence-invalid. The response packet's Acknowledgement Number MUST equal GSR.",
      "ja": "Oシーケンス無効DCCP  - リセットパケットは、（可能なレート制限を受ける）DCCP同期応答のパケットを誘発しなければなりません。この応答パケットは、新しいシーケンス番号を使用しなければならないので、GSSが増加します。受信したパケットが系列無効だったのでGSRは、しかし、変更されません。応答パケットの確認応答番号はGSRと等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Any other sequence-invalid packet MUST elicit a similar DCCP-Sync packet, except that the response packet's Acknowledgement Number MUST equal the sequence-invalid packet's Sequence Number.",
      "ja": "O任意の他の配列、無効なパケットは、応答パケットの確認応答番号は配列の無効なパケットのシーケンス番号に等しくなければならないことを除いて、同様のDCCP同期パケットを誘発しなければなりません。"
    },
    {
      "indent": 3,
      "text": "On receiving a sequence-valid DCCP-Sync packet, the peer endpoint (say, DCCP B) MUST update its GSR variable and reply with a DCCP-SyncAck packet. The DCCP-SyncAck packet's Acknowledgement Number will equal the DCCP-Sync's Sequence Number, which is not necessarily GSR. Upon receiving this DCCP-SyncAck, which will be sequence-valid since it acknowledges the DCCP-Sync, DCCP A will update its GSR variable, and the endpoints will be back in sync. As an exception, if the peer endpoint is in the REQUEST state, it MUST respond with a DCCP-Reset instead of a DCCP-SyncAck. This serves to clean up DCCP A's half-open connection.",
      "ja": "シーケンス有効DCCP同期パケットを受信すると、ピアエンドポイント（例えば、DCCP B）はそのGSR変数を更新しなければならなくて、DCCP-SyncAckパケットで返信。 DCCP-SyncAckパケットの確認応答番号は必ずしもGSRないDCCP同期のシーケンス番号を、等しくなります。それはDCCP同期を承認するのでシーケンス有効であろう本DCCP-SyncAckを受信すると、DCCP Aは、GSR変数を更新し、エンドポイントは、同期に戻ってきます。ピアエンドポイントが要求状態にある場合は例外として、それは代わりにDCCP-SyncAckのDCCP-リセットで応答しなければなりません。これはDCCP Aのハーフオープン接続をクリーンアップするのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "To protect against denial-of-service attacks, DCCP implementations SHOULD impose a rate limit on DCCP-Syncs sent in response to sequence-invalid packets, such as not more than eight DCCP-Syncs per second.",
      "ja": "サービス拒否攻撃から保護するために、DCCP実装は、このような毎秒8 DCCP-同期よりもないよう系列無効のパケットに応答して送られたDCCP-同期のレート制限を課すべきです。"
    },
    {
      "indent": 3,
      "text": "DCCP endpoints MUST NOT process sequence-invalid packets except, perhaps, by generating a DCCP-Sync. For instance, options MUST NOT be processed. An endpoint MAY temporarily preserve sequence-invalid packets in case they become valid later, however; this can reduce the impact of bursts of loss by delivering more packets to the application. In particular, an endpoint MAY preserve sequence-invalid packets for up to 2 round-trip times. If, within that time, the relevant sequence windows change so that the packets become sequence-valid, the endpoint MAY process them again.",
      "ja": "DCCP終点は、DCCP-Syncを発生させることにより、おそらく、を除い系列無効のパケットを処理してはいけません。例えば、オプションが処理されてはなりません。エンドポイントは、一時的に、彼らはしかし、後から有効となる場合のシーケンス、無効なパケットを保存することができます。これは、アプリケーションにより多くのパケットを提供することにより、損失のバーストの影響を低減することができます。具体的には、エンドポイントは、最大で2往復時間のための系列無効のパケットを保存することができます。場合は、その時間内に、パケットが配列有効になるように、関連する一連のウィンドウの変更は、エンドポイントが再びそれらを処理することができます。"
    },
    {
      "indent": 3,
      "text": "Note that sequence-invalid DCCP-Reset packets cause DCCP-Syncs to be generated. This is because endpoints in an unsynchronized state (CLOSED, REQUEST, and LISTEN) might not have enough information to generate a proper DCCP-Reset on the first try. For example, if a peer endpoint is in CLOSED state and receives a DCCP-Data packet, it cannot guess the right Sequence Number to use on the DCCP-Reset it generates (since the DCCP-Data packet has no Acknowledgement Number). The DCCP-Sync generated in response to this bad reset serves as a challenge, and contains enough information for the peer to generate a proper DCCP-Reset. However, the new DCCP-Reset may carry a different Reset Code than the original DCCP-Reset; probably the new Reset Code will be 3, \"No Connection\". The endpoint SHOULD use information from the original DCCP-Reset when possible.",
      "ja": "その系列無効DCCP-リセットパケットはDCCP-同期を発生させるに注意してください。同期化されていない状態でのエンドポイントは（CLOSED、REQUEST、およびLISTEN）最初の試みで適切なDCCP-リセットを生成するのに十分な情報を持っていない可能性があるためです。ピアエンドポイントが閉状態にあり、DCCP  - データパケットを受信した場合、例えば、それは（DCCP  - データパケットが確認応答番号を持っていないので）それが生成DCCPリセットに使用する権利シーケンス番号を推測することができません。この悪いリセットに応答して生成DCCP-Syncは、チャレンジとなり、適切なDCCP・リセットを生成するために、ピアのための十分な情報を含んでいます。しかし、新しいDCCP  - リセットは、元のDCCP、リセットとは異なるリセットコードを運ぶことができます。おそらく、新しいリセットコードは3、「接続なし」となります。エンドポイントは、オリジナルのDCCP-リセット可能性からの情報を使用すべきです。"
    },
    {
      "indent": 0,
      "text": "7.5.5. Sequence Number Attacks",
      "section_title": true,
      "ja": "7.5.5. シーケンス番号攻撃"
    },
    {
      "indent": 3,
      "text": "Sequence and Acknowledgement Numbers form DCCP's main line of defense against attackers. An attacker that cannot guess sequence numbers cannot easily manipulate or hijack a DCCP connection, and requirements like careful initial sequence number choice eliminate the most serious attacks.",
      "ja": "シーケンスおよび確認応答番号は、攻撃者に対する防御のDCCPのメインラインを形成します。シーケンス番号を推測することができない攻撃者が簡単に操作またはDCCPコネクションをハイジャックし、慎重な初期シーケンス番号の選択のような要件が最も深刻な攻撃を排除することはできません。"
    },
    {
      "indent": 3,
      "text": "An attacker might still send many packets with randomly chosen Sequence and Acknowledgement Numbers, however. If one of those probes ends up sequence-valid, it may shut down the connection or otherwise cause problems. The easiest such attacks to execute are as follows:",
      "ja": "攻撃者はまだしかし、ランダムに選択された配列と謝辞番号を持つ多くのパケットを送信することがあります。これらのプローブの1つが配列有効終わる場合、それは接続をシャットダウンまたはそれ以外の問題が発生することがあります。次のように実行するための最も簡単な、このような攻撃は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Send DCCP-Data packets with random Sequence Numbers. If one of these packets hits the valid sequence number window, the attack packet's application data may be inserted into the data stream.",
      "ja": "Oランダムシーケンス番号とDCCP  - データパケットを送信します。これらのパケットの1つは、有効なシーケンス番号のウィンドウをヒットした場合、攻撃パケットのアプリケーションデータは、データストリームに挿入することができます。"
    },
    {
      "indent": 3,
      "text": "o Send DCCP-Sync packets with random Sequence and Acknowledgement Numbers. If one of these packets hits the valid acknowledgement number window, the receiver will shift its sequence number window accordingly, getting out of sync with the correct endpoint -- perhaps permanently.",
      "ja": "Oランダムシーケンスおよび確認応答番号とDCCP-Syncのパケットを送信します。これらのパケットの1つが有効な確認応答番号のウィンドウをヒットした場合、受信機は、正しいエンドポイントと同期しなくなって、それに応じてシーケンス番号のウィンドウをシフトします - おそらく永久に。"
    },
    {
      "indent": 3,
      "text": "The attacker has to guess both Source and Destination Ports for any of these attacks to succeed. Additionally, the connection would have to be inactive for the DCCP-Sync attack to succeed, assuming the victim implemented the more stringent checks for active connections recommended in Section 7.5.3.",
      "ja": "攻撃者は、成功するために、これらの攻撃のいずれかの送信元ポートと宛先ポートの両方を推測しています。 DCCP-Syncの攻撃が成功するためにはさらに、接続は、被害者は、セクション7.5.3で推奨アクティブな接続のためのより厳格なチェックを実装想定し、非アクティブでなければならないであろう。"
    },
    {
      "indent": 3,
      "text": "To quantify the probability of success, let N be the number of attack packets the attacker is willing to send, W be the relevant sequence window width, and L be the length of sequence numbers (24 or 48). The attacker's best strategy is to space the attack packets evenly over sequence space. Then the probability of hitting one sequence number window is P = WN/2^L.",
      "ja": "成功の確率を定量化するために、N攻撃の数は、攻撃者が送信しても構わないと思っているパケットする、Wは、関連配列のウィンドウ幅であり、そしてLは、シーケンス番号（24または48）の長さとします。攻撃者の最善の戦略は、均等に配列スペース上の空間に攻撃パケットです。次いで、一つのシーケンス番号のウィンドウを打つ確率はP = WN / 2 ^ Lです。"
    },
    {
      "indent": 3,
      "text": "The success probability for a DCCP-Data attack using short sequence numbers thus equals P = WN/2^24. For W = 100, then, the attacker must send more than 83,000 packets to achieve a 50% chance of success. For reference, the easiest TCP attack -- sending a SYN with a random sequence number, which will cause a connection reset if it falls within the window -- with W = 8760 (a common default) and L = 32 requires more than 245,000 packets to achieve a 50% chance of success.",
      "ja": "短いシーケンス番号を使用して、DCCP  - データ攻撃の成功確率は、このようにP = WN / 2 ^ 24に等しいです。 W = 100の場合は、その後、攻撃者は、成功の50％の確率を達成するために以上83,000パケットを送信する必要があります。参考のために、最も簡単なTCP攻撃 - それは、ウィンドウ内にある場合、接続のリセットが発生しますランダムシーケンス番号、とSYNを送信する -  W = 8760と（一般的なデフォルト）とL = 32以上245,000パケットを必要とし成功の50％の確率で実現しています。"
    },
    {
      "indent": 3,
      "text": "A fast connection's W will generally be high, increasing the attack success probability for fixed N. If this probability gets uncomfortably high with L = 24, the endpoint SHOULD prevent the use of short sequence numbers by manipulating the Allow Short Sequence Numbers feature (see Section 7.6.1). The probability limit depends on the application, however. Some applications, such as those already designed to handle corruption, are quite resilient to data injection attacks.",
      "ja": "高速接続のWは、一般的に、この確率は、L = 24と不快に高くなった場合は、固定N.ため、攻撃の成功確率を高め、ハイになり、エンドポイントは許可ショートシーケンス番号の機能を操作することにより、短いシーケンス番号の使用を防止すべきである（セクションを参照してください7.6.1）。確率の上限は、しかし、アプリケーションに依存します。こうしたすでに腐敗を扱うように設計されたものなどの一部のアプリケーションでは、データインジェクション攻撃に対して非常に弾力性があります。"
    },
    {
      "indent": 3,
      "text": "The DCCP-Sync attack has L = 48, since DCCP-Sync packets use long sequence numbers exclusively; in addition, the success probability is halved, since only half the Sequence Number space is valid. Attacks have a correspondingly smaller probability of success. For a large W of 2000 packets, then, the attacker must send more than 10^11 packets to achieve a 50% chance of success.",
      "ja": "DCCP-Syncのパケットが排他的に長いシーケンス番号を使用するので、DCCP-Syncの攻撃は、L = 48を持っています。加えて、成功確率は半分しかシーケンス番号空間が有効であることから、半分になります。攻撃が成功するのに対応して小さい確率を持っています。 2000のパケットの大Wに関しては、その後、攻撃者は、成功の50％の確率を達成するために10個の以上の^ 11パケットを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Attacks involving DCCP-Ack, DCCP-DataAck, DCCP-CloseReq, DCCP-Close, and DCCP-Reset packets are more difficult, since Sequence and Acknowledgement Numbers must both be guessed. The probability of attack success for these packet types equals P = WXN/2^(2L), where W is the Sequence Number window, X is the Acknowledgement Number window, and N and L are as before.",
      "ja": "シーケンスおよび確認応答番号の両方が推測されなければならないので、DCCP-Ackを、DCCP-DataAck、DCCP-CloseReq、DCCP-閉じる、およびDCCP-リセットパケットを伴う攻撃は、より困難です。これらのパケットタイプの攻撃成功の確率がWは、シーケンス番号のウィンドウであるP = WXN / 2 ^（2L）を、等しく、Xは、肯定応答番号ウィンドウであり、そしてNおよびLは、前のようにです。"
    },
    {
      "indent": 3,
      "text": "Since DCCP-Data attacks with short sequence numbers are relatively easy for attackers to execute, DCCP has been engineered to prevent these attacks from escalating to connection resets or other serious consequences. In particular, any options whose processing might cause the connection to be reset are ignored when they appear on DCCP-Data packets.",
      "ja": "短いシーケンス番号とDCCP-データ攻撃は、攻撃者が実行するのは比較的容易であるので、DCCPは、接続のリセットやその他の重大な結果にエスカレートするから、これらの攻撃を防ぐように設計されています。彼らはDCCP  - データパケットに表示されたときに、特に、その処理の接続がリセットされることがあります任意のオプションは無視されます。"
    },
    {
      "indent": 0,
      "text": "7.5.6. Sequence Number Handling Examples",
      "section_title": true,
      "ja": "7.5.6. 例の処理シーケンス番号"
    },
    {
      "indent": 3,
      "text": "In the following example, DCCP A and DCCP B recover from a large burst of loss that runs DCCP A's sequence numbers out of DCCP B's appropriate sequence number window.",
      "ja": "次の例では、DCCP AとDCCP BはDCCP Bの適切なシーケンス番号のウィンドウの外DCCP Aのシーケンス番号を実行損失の大バーストから回復します。"
    },
    {
      "indent": 3,
      "text": "DCCP A DCCP B (GSS=1,GSR=10) (GSS=10,GSR=1) --> DCCP-Data(seq 2) XXX ... --> DCCP-Data(seq 100) XXX --> DCCP-Data(seq 101) --> ??? seqno out of range; send Sync OK <-- DCCP-Sync(seq 11, ack 101) <-- (GSS=11,GSR=1) --> DCCP-SyncAck(seq 102, ack 11) --> OK (GSS=102,GSR=11) (GSS=11,GSR=102)",
      "ja": "DCCP A DCCP B（GSS = 1、GSR = 10）（GSS = 10、GSR = 1） - > DCCP-データ（配列2）XXX ...  - > DCCP-データ（配列番号100）XXX  - > DCCP-データ（配列101） - > ???範囲外のSEQNO。送信同期OK < -  DCCP-SYNC（配列番号11、101 ACK）< - （GSS = 11、GSR = 1） - > DCCP-SyncAck（11 ACK配列番号102） - > OK（GSS = 102、 = 11 GSR）（GSS = 11、GSR = 102）"
    },
    {
      "indent": 3,
      "text": "In the next example, a DCCP connection recovers from a simple blind attack.",
      "ja": "次の例では、DCCP接続は、単純なブラインド攻撃から回復します。"
    },
    {
      "indent": 3,
      "text": "DCCP A DCCP B (GSS=1,GSR=10) (GSS=10,GSR=1) *ATTACKER* --> DCCP-Data(seq 10^6) --> ??? seqno out of range; send Sync ??? <-- DCCP-Sync(seq 11, ack 10^6) <-- ackno out of range; ignore (GSS=1,GSR=10) (GSS=11,GSR=1)",
      "ja": "DCCP A DCCP B（GSS = 1、GSR = 10）（GSS = 10、GSR = 1）* ATTACKER *  - > DCCP-データ（配列番号10 ^ 6） - > ???範囲外のSEQNO。 Syncを送ります？ < -  DCCP-SYNC（配列番号11、10 ^ 6 ACK）< -  ackno範囲外。無視（GSS = 1、GSR = 10）（GSS = 11、GSR = 1）"
    },
    {
      "indent": 3,
      "text": "The final example demonstrates recovery from a half-open connection.",
      "ja": "最後の例は、ハーフオープン接続からの回復を示しています。"
    },
    {
      "indent": 3,
      "text": "DCCP A DCCP B (GSS=1,GSR=10) (GSS=10,GSR=1) (Crash) CLOSED OPEN REQUEST --> DCCP-Request(seq 400) --> ??? !! <-- DCCP-Sync(seq 11, ack 400) <-- OPEN REQUEST --> DCCP-Reset(seq 401, ack 11) --> (Abort) REQUEST CLOSED REQUEST --> DCCP-Request(seq 402) --> ...",
      "ja": "DCCP A DCCP B（GSS = 1、GSR = 10）（クラッシュ）が閉じオープン要求（GSSが、GSR = 1 = 10） - > DCCP  - 要求（配列番号400） - > ??? !! < -  DCCP-SYNC（配列番号11、400をACK）< -  OPEN REQUEST  - > DCCP・リセット（配列番号401、ACK 11） - >  - > DCCP  - 要求（配列番号402）（中止）要求がREQUEST CLOSED - > ..."
    },
    {
      "indent": 0,
      "text": "7.6. Short Sequence Numbers",
      "section_title": true,
      "ja": "7.6. ショートシーケンス番号"
    },
    {
      "indent": 3,
      "text": "DCCP sequence numbers are 48 bits long. This large sequence space protects DCCP connections against some blind attacks, such as the injection of DCCP-Resets into the connection. However, DCCP-Data, DCCP-Ack, and DCCP-DataAck packets, which make up the body of any DCCP connection, may reduce header space by transmitting only the lower 24 bits of the relevant Sequence and Acknowledgement Numbers. The receiving endpoint will extend these numbers to 48 bits using the following pseudocode:",
      "ja": "DCCPのシーケンス番号は48ビット長です。この大きな配列スペースは、このような接続にDCCP-リセットの注射などのいくつかの盲目の攻撃に対するDCCP接続を保護します。しかし、任意のDCCP接続の本体を構成するDCCP-データ、DCCP-ACK、およびDCCP-DataAckパケットは、関連配列確認応答番号の下位24ビットのみを送信することによりヘッダスペースを低減することができます。受信エンドポイントは、以下の疑似コードを使用して48ビットにこれらの番号を拡張します。"
    },
    {
      "indent": 3,
      "text": "procedure Extend_Sequence_Number(S, REF)\n   /* S is a 24-bit sequence number from the packet header.\n      REF is the relevant 48-bit reference sequence number:\n      GSS if S is an Acknowledgement Number, and GSR if S is a\n      Sequence Number. */\n   Set REF_low := low 24 bits of REF\n   Set REF_hi := high 24 bits of REF\n   If REF_low (<) S           /* circular comparison mod 2^24 */\n         and S |<| REF_low,   /* conventional, non-circular\n                                 comparison */\n      Return (((REF_hi + 1) mod 2^24) << 24) | S\n   Otherwise, if S (<) REF_low and REF_low |<| S,\n      Return (((REF_hi - 1) mod 2^24) << 24) | S\n   Otherwise,\n      Return (REF_hi << 24) | S",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The two different kinds of comparison in the if statements detect when the low-order bits of the sequence space have wrapped. (The circular comparison \"REF_low (<) S\" returns true if and only if (S - REF_low), calculated using two's-complement arithmetic and then represented as an unsigned number, is less than or equal to 2^23 (mod 2^24).) When this happens, the high-order bits are incremented or decremented, as appropriate.",
      "ja": "比較の2種類のステートメントは、配列スペースの下位ビットをラップしている時に検出した場合。 、2の補数演算を用いて計算した後、符号なしの数として表される、^ 2（MOD未満または2 ^ 23に等しいREF_low） - のみ（Sもしあれば（円形の比較は「REF_low（<）S」がtrueを返しますこれが発生すると24）。）、上位ビットは、インクリメントまたはデクリメント、適宜れます。"
    },
    {
      "indent": 0,
      "text": "7.6.1. Allow Short Sequence Numbers Feature",
      "section_title": true,
      "ja": "7.6.1. ショートシーケンス番号の機能を許可します"
    },
    {
      "indent": 3,
      "text": "Endpoints can require that all packets use long sequence numbers by leaving the Allow Short Sequence Numbers feature value at its default of zero. This can reduce the risk that data will be inappropriately injected into the connection. DCCP A sends a \"Change L(Allow Short Seqnos, 1)\" option to indicate its desire to send packets with short sequence numbers.",
      "ja": "エンドポイントは、すべてのパケットが許可ショートシーケンス番号がゼロのデフォルトの値を特徴と残して長いシーケンス番号を使用することを必要とすることができます。これは、データが不適切な接続に注入されるリスクを減らすことができます。 DCCP Aは、「変更L（ショートSeqnosを許可する、1）」短いシーケンス番号のパケットを送信するためにその要望を示すためのオプションを送信します。"
    },
    {
      "indent": 3,
      "text": "Allow Short Sequence Numbers has feature number 2 and is server-priority. It takes one-byte Boolean values. When Allow Short Seqnos/B is zero, DCCP B MUST NOT send packets with short sequence numbers and DCCP A MUST ignore any packets with short sequence numbers that are received. Values of two or more are reserved. New connections start with Allow Short Sequence Numbers 0 for both endpoints.",
      "ja": "許可ショートシーケンス番号は、機能番号2を持っていると、サーバーの優先順位です。これは、1バイトのブール値をとります。許可ショートSeqnos / Bがゼロである場合、DCCP Bは、短いシーケンス番号を持つパケットを送ってはいけませんとDCCP Aが受信される短いシーケンス番号を持つパケットを無視しなければなりません。二つ以上の値が予約されています。両方のエンドポイントのショートシーケンス番号0を許可すると新しい接続が開始されます。"
    },
    {
      "indent": 0,
      "text": "7.6.2. When to Avoid Short Sequence Numbers",
      "section_title": true,
      "ja": "7.6.2. ショートシーケンス番号を避けるためにする場合"
    },
    {
      "indent": 3,
      "text": "Short sequence numbers reduce the rate DCCP connections can safely achieve and increase the risks of certain kinds of attacks, including blind data injection. Very-high-rate DCCP connections, and connections with large sequence windows (Section 7.5.2), SHOULD NOT use short sequence numbers on their data packets. The attack risk issues have been discussed in Section 7.5.5; we discuss the rate limitation issue here.",
      "ja": "短いシーケンス番号は、DCCP接続が安全に達成し、ブラインドデータの注入を含む攻撃の特定の種類のリスクを増やすことができます率を低下させます。超高レートDCCP接続、大きなシーケンス窓（7.5.2項）との接続は、そのデータパケットに短いシーケンス番号を使用しないでください。攻撃のリスク問題は、第7.5.5項で説明されています。ここでは、レート制限の問題を議論します。"
    },
    {
      "indent": 3,
      "text": "The sequence-validity mechanism assumes that the network does not deliver extremely old data. In particular, it assumes that the network must have dropped any packet by the time the connection wraps around and uses its sequence number again. This constraint limits the maximum connection rate that can be safely achieved. Let MSL equal the maximum segment lifetime, P equal the average DCCP packet size in bits, and L equal the length of sequence numbers (24 or 48 bits). Then the maximum safe rate, in bits per second, is R = P*(2^L)/2MSL.",
      "ja": "シーケンス・妥当性のメカニズムは、ネットワークが非常に古いデータを提供しないことを前提としています。特に、ネットワーク接続がラップアラウンドして、再びそのシーケンス番号を使用する時間によって、任意のパケットを落としていなければならないことを前提としています。この制約は、安全に実現することができる最大接続速度を制限します。 MSLは、最大セグメント寿命を等しくしてみましょう、Pは、ビットの平均DCCPパケットのサイズに等しく、そしてLは、シーケンス番号（24または48ビット）の長さに等しいです。次いで、最大安全速度は、秒当たりのビットで、R = P *（2 ^ L）/ 2MSLあります。"
    },
    {
      "indent": 3,
      "text": "For the default MSL of 2 minutes, 1500-byte DCCP packets, and short sequence numbers, the safe rate is therefore approximately 800 Mb/s. Although 2 minutes is a very large MSL for any networks that could sustain that rate with such small packets, long sequence numbers allow much higher rates under the same constraints: up to 14 petabits a second for 1500-byte packets and the default MSL.",
      "ja": "2分、1500バイトのDCCPパケット、および短いシーケンス番号のデフォルトMSLのために、安全率は、したがって、約800メガビット/秒です。 1500バイトのパケットとデフォルトMSLのための14 petabits秒まで：2分は、このような小さなパケットをそのレートを維持する可能性のあるネットワークのための非常に大きいMSLですが、長いシーケンス番号が同じ制約の下ではるかに高いレートを可能にします。"
    },
    {
      "indent": 0,
      "text": "7.7. NDP Count and Detecting Application Loss",
      "section_title": true,
      "ja": "7.7.  NDPカウントと検出アプリケーションの損失"
    },
    {
      "indent": 3,
      "text": "DCCP's sequence numbers increment by one on every packet, including non-data packets (packets that don't carry application data). This makes DCCP sequence numbers suitable for detecting any network loss, but not for detecting the loss of application data. The NDP Count option reports the length of each burst of non-data packets. This lets the receiving DCCP reliably determine when a burst of loss included application data.",
      "ja": "DCCPのシーケンス番号は、非データ・パケット（アプリケーションデータを運ばないパケット）を含め、すべてのパケットに1ずつ増加します。これは、アプリケーションデータの消失を検出するための任意のネットワークの損失を検出するのに適してではなく、DCCPシーケンス番号になります。 NDPカウントオプションは非データパケットの各バーストの長さを報告します。これは、損失のバーストは、アプリケーションデータが含まれた場合に受信DCCPを確実に判断することができます。"
    },
    {
      "indent": 3,
      "text": "+--------+--------+-------- ... --------+\n|00100101| Length |      NDP Count      |\n+--------+--------+-------- ... --------+\n Type=37  Len=3-8       (1-6 bytes)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If a DCCP endpoint's Send NDP Count feature is one (see below), then that endpoint MUST send an NDP Count option on every packet whose immediate predecessor was a non-data packet. Non-data packets consist of DCCP packet types DCCP-Ack, DCCP-Close, DCCP-CloseReq, DCCP-Reset, DCCP-Sync, and DCCP-SyncAck. The other packet types, namely DCCP-Request, DCCP-Response, DCCP-Data, and DCCP-DataAck, are considered data packets, although not all DCCP-Request and DCCP-Response packets will actually carry application data.",
      "ja": "DCCP終点のカウントNDPを送る機能が（下記参照）1である場合、そのエンドポイントは即時の前任者以外のデータパケットたすべてのパケット上のNDPカウントオプションを送らなければなりません。非データパケットはDCCPパケットタイプDCCP-ACK、DCCP-閉じる、DCCP-CloseReq、DCCP  - リセット、DCCP同期、およびDCCP-SyncAckから成ります。すべてのDCCP-要求とDCCP-応答パケットが実際にアプリケーションデータを運ぶされていないが、他のパケットタイプ、すなわち、DCCP-要求、DCCP-応答、DCCP-データ、およびDCCP-DataAckは、データパケットを考えられています。"
    },
    {
      "indent": 3,
      "text": "The value stored in NDP Count equals the number of consecutive non-data packets in the run immediately previous to the current packet. Packets with no NDP Count option are considered to have NDP Count zero.",
      "ja": "NDPカウントに格納されている値は、現在のパケットの直前、実行中の連続した非データパケットの数に等しいです。無NDPカウントオプション付きパケットはNDPがゼロカウント有すると考えられます。"
    },
    {
      "indent": 3,
      "text": "The NDP Count option can carry one to six bytes of data. The smallest option format that can hold the NDP Count SHOULD be used.",
      "ja": "NDPカウントオプションは、データの1〜6個のバイトを運ぶことができます。 NDPカウントを保持できる最小のオプションの形式を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "With NDP Count, the receiver can reliably tell only whether a burst of loss contained at least one data packet. For example, the receiver cannot always tell whether a burst of loss contained a non-data packet.",
      "ja": "NDPはカウントして、受信機は確実に損失のバーストは、少なくとも1つのデータ・パケットが含まれているかどうかだけで伝えることができます。例えば、受信機は常に損失のバーストが非データパケットが含まれているかどうかわかりません。"
    },
    {
      "indent": 0,
      "text": "7.7.1. NDP Count Usage Notes",
      "section_title": true,
      "ja": "7.7.1.  NDPカウント使用上の注意"
    },
    {
      "indent": 3,
      "text": "Say that K consecutive sequence numbers are missing in some burst of loss, and that the Send NDP Count feature is on. Then some application data was lost within those sequence numbers unless the packet following the hole contains an NDP Count option whose value is greater than or equal to K.",
      "ja": "K連続したシーケンス番号が損失のいくつかのバーストに欠けていること、およびカウントNDPを送る機能がオンになっていることを言います。穴次のパケットがその値K.以上であるNDPカウントオプションが含まれない限り、いくつかのアプリケーションデータは、これらのシーケンス番号の中に失われました"
    },
    {
      "indent": 3,
      "text": "For example, say that an endpoint sent the following sequence of non-data packets (Nx) and data packets (Dx).",
      "ja": "例えば、エンドポイントが非データ・パケット（Nxの）データパケット（Dxと）、次のシーケンスを送信することを言います。"
    },
    {
      "indent": 6,
      "text": "N0 N1 D2 N3 D4 D5 N6 D7 D8 D9 D10 N11 N12 D13",
      "ja": "N0 N1 D2 N3 D4 D5 N6 D7 D8 D9 D10 N11 N12 D13"
    },
    {
      "indent": 3,
      "text": "Those packets would have NDP Counts as follows.",
      "ja": "これらのパケットは、次のようにNDPカウントのだろう。"
    },
    {
      "indent": 6,
      "text": "N0 N1 D2 N3 D4 D5 N6 D7 D8 D9 D10 N11 N12 D13 - 1 2 - 1 - - 1 - - - - 1 2",
      "ja": "N0 N1 D2 N3 D4 D5 N6 D7 D8 D9 D10 N11 N12のD13  -  1 2  -  1  -   -  1  -   -   -   -  1 2"
    },
    {
      "indent": 3,
      "text": "NDP Count is not useful for applications that include their own sequence numbers with their packet headers.",
      "ja": "NDP Countは、そのパケットのヘッダに、独自のシーケンス番号を含むアプリケーションのために有用ではありません。"
    },
    {
      "indent": 0,
      "text": "7.7.2. Send NDP Count Feature",
      "section_title": true,
      "ja": "7.7.2.  NDPカウント機能を送ります"
    },
    {
      "indent": 3,
      "text": "The Send NDP Count feature lets DCCP endpoints negotiate whether they should send NDP Count options on their packets. DCCP A sends a \"Change R(Send NDP Count, 1)\" option to ask DCCP B to send NDP Count options.",
      "ja": "NDPカウント機能は、DCCP終点は、彼らが自分のパケットのNDPカウントオプションを送信するかどうかを交渉することができます送信します。 DCCP Aは \"変化R（、カウント1 NDPを送る）\" NDPカウントオプションを送信するためにDCCP Bを依頼するオプションを送信します。"
    },
    {
      "indent": 3,
      "text": "Send NDP Count has feature number 7 and is server-priority. It takes one-byte Boolean values. DCCP B MUST send NDP Count options as described above when Send NDP Count/B is one, although it MAY send NDP Count options even when Send NDP Count/B is zero. Values of two or more are reserved. New connections start with Send NDP Count 0 for both endpoints.",
      "ja": "NDP Countが機能番号7を持っていると、サーバーの優先順位で送信します。これは、1バイトのブール値をとります。 DCCP Bは、NDPカウント/ B送信すると上記のようなオプションをカウントNDPを送信しなければならないことがNDPを送る場合でも、Bがゼロ/カウントオプションカウントNDPを送ることができるが、一つです。二つ以上の値が予約されています。新しい接続は、両方のエンドポイントのNDPカウント0を送信し始めます。"
    },
    {
      "indent": 0,
      "text": "8. Event Processing",
      "section_title": true,
      "ja": "8.イベント処理"
    },
    {
      "indent": 3,
      "text": "This section describes how DCCP connections move between states and which packets are sent when. Note that feature negotiation takes place in parallel with the connection-wide state transitions described here.",
      "ja": "このセクションでは、DCCP接続はパケットが送信される状態との間を移動する方法について説明します。交渉がここで説明した接続全体の状態遷移と並行して行われ、その機能に注意してください。"
    },
    {
      "indent": 0,
      "text": "8.1. Connection Establishment",
      "section_title": true,
      "ja": "8.1. 接続の確立"
    },
    {
      "indent": 3,
      "text": "DCCP connections' initiation phase consists of a three-way handshake: an initial DCCP-Request packet sent by the client, a DCCP-Response sent by the server in reply, and finally an acknowledgement from the client, usually via a DCCP-Ack or DCCP-DataAck packet. The client moves from the REQUEST state to PARTOPEN, and finally to OPEN; the server moves from LISTEN to RESPOND, and finally to OPEN.",
      "ja": "DCCP接続の初期段階は3ウェイハンドシェイクで構成されています。通常、DCCP-Ackを経由して、クライアントから送信された初期のDCCP-Requestパケット、応答でサーバーから送信されたDCCP-応答、およびクライアントから最終的に承認またはDCCP-DataAckパケット。クライアントはPARTOPENにREQUEST状態から移動し、最終的にOPENに。サーバーが応答し、そして最終的にOPENにLISTENから移動します。"
    },
    {
      "indent": 3,
      "text": " Client State Server State CLOSED LISTEN 1. REQUEST --> Request --> 2. <-- Response <-- RESPOND 3. PARTOPEN --> Ack, DataAck --> 4. <-- Data, Ack, DataAck <-- OPEN 5. OPEN <-> Data, Ack, DataAck <-> OPEN",
      "ja": "クライアント状態サーバーの状態は、1 REQUESTをLISTEN CLOSED  - >リクエスト - > 2. < - レスポンス< -  RESPOND 3. PARTOPEN  - > ACK、DataAck  - > 4. < - データ、ACK、DataAck < -  -  OPEN 5. OPEN < - >データ、ACK、DataAck < - > OPEN"
    },
    {
      "indent": 0,
      "text": "8.1.1. Client Request",
      "section_title": true,
      "ja": "8.1.1. クライアント要求"
    },
    {
      "indent": 3,
      "text": "When a client decides to initiate a connection, it enters the REQUEST state, chooses an initial sequence number (Section 7.2), and sends a DCCP-Request packet using that sequence number to the intended server.",
      "ja": "クライアントが接続を開始することを決定するとき、それは、要求状態に入る初期シーケンス番号（セクション7.2）を選択し、目的のサーバーにそのシーケンス番号を使用して、DCCP-Requestパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "DCCP-Request packets will commonly carry feature negotiation options that open negotiations for various connection parameters, such as preferred congestion control IDs for each half-connection. They may also carry application data, but the client should be aware that the server may not accept such data.",
      "ja": "DCCP-Requestパケットは、一般的に、このような各半分接続の優先輻輳制御IDなど、さまざまな接続パラメータのためのオープン交渉、特徴交渉オプションを運ぶでしょう。彼らはまた、アプリケーションデータを運ぶかもしれませんが、クライアントは、サーバがそのようなデータを受け入れないことに注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "A client in the REQUEST state SHOULD use an exponential-backoff timer to send new DCCP-Request packets if no response is received. The first retransmission should occur after approximately one second, backing off to not less than one packet every 64 seconds; or the endpoint can use whatever retransmission strategy is followed for retransmitting TCP SYNs. Each new DCCP-Request MUST increment the Sequence Number by one and MUST contain the same Service Code and application data as the original DCCP-Request.",
      "ja": "REQUEST状態のクライアントは、応答が受信されない場合は、新しいDCCP-Requestパケットを送信するために、指数バックオフタイマーを使用すべきです。最初の再送信は、1つのパケットごとに64秒未満ではないにバックオフ、約1秒後に発生しなければなりません。またはエンドポイントは、TCPのSYNを再送するために続いているものは何でも、再送信戦略を使用することができます。それぞれの新しいDCCP-要求が一つのシーケンス番号をインクリメントしなければならなくて、オリジナルのDCCP-要求と同じサービスコードとアプリケーションデータを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "A client MAY give up on its DCCP-Requests after some time (3 minutes, for example). When it does, it SHOULD send a DCCP-Reset packet to the server with Reset Code 2, \"Aborted\", to clean up state in case one or more of the Requests actually arrived. A client in REQUEST state has never received an initial sequence number from its peer, so the DCCP-Reset's Acknowledgement Number MUST be set to zero.",
      "ja": "クライアントは、いくつかの時間後にそのDCCP-要求（例えば3分）にあきらめるかもしれません。それがないと、それは場合、実際に到着した要求の一つ以上の状態をクリーンアップするために、リセットコード2、「中止」を使用してサーバーにDCCP-リセットパケットを送るべきです。 REQUEST状態のクライアントがピアからの初期シーケンス番号を受けたことがないので、DCCP-リセットの確認応答番号をゼロに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client leaves the REQUEST state for PARTOPEN when it receives a DCCP-Response from the server.",
      "ja": "それは、サーバからDCCP-応答を受信したときにクライアントがPARTOPENの要求の状態を残します。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Service Codes",
      "section_title": true,
      "ja": "8.1.2. サービスコード"
    },
    {
      "indent": 3,
      "text": "Each DCCP-Request contains a 32-bit Service Code, which identifies the application-level service to which the client application is trying to connect. Service Codes should correspond to application services and protocols. For example, there might be a Service Code for SIP control connections and one for RTP audio connections. Middleboxes, such as firewalls, can use the Service Code to identify the application running on a nonstandard port (assuming the DCCP header has not been encrypted).",
      "ja": "各DCCP-要求は、クライアントアプリケーションが接続しようとされているアプリケーションレベルのサービスを識別する32ビットのサービスコードが含まれています。サービスコードは、アプリケーションサービスとプロトコルに対応している必要があります。例えば、SIP制御接続およびRTPオーディオ接続のいずれかのサービスコードがあるかもしれません。ファイアウォールなどの中間装置は、（DCCPヘッダが暗号化されていないと仮定して）非標準ポート上で動作するアプリケーションを識別するためのサービスコードを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Endpoints MUST associate a Service Code with every DCCP socket, both actively and passively opened. The application will generally supply this Service Code. Each active socket MUST have exactly one Service Code. Passive sockets MAY, at the implementation's discretion, be associated with more than one Service Code; this might let multiple applications, or multiple versions of the same application, listen on the same port, differentiated by Service Code. If the DCCP-Request's Service Code doesn't equal any of the server's Service Codes for the given port, the server MUST reject the request by sending a DCCP-Reset packet with Reset Code 8, \"Bad Service Code\". A middlebox MAY also send such a DCCP-Reset in response to packets whose Service Code is considered unsuitable.",
      "ja": "エンドポイントは、あらゆるDCCPソケットの両方積極的かつ受動的に開かれたサービスコードを関連付ける必要があります。アプリケーションは、一般的に、このサービスコードを供給します。各アクティブソケットは、1つのサービスコードを持たなければなりません。パッシブソケットは、実装者の裁量で、複数のサービスコードを関連付けることができます。これは、複数のアプリケーション、または同じアプリケーションの複数のバージョンは、サービスコードによって区別同じポート上で聞くせて頂く場合がございます。 DCCPリクエストのサービスコードは、特定のポートのサーバーのサービスコードのいずれかと等しくない場合、サーバーはリセットコード8、「悪い接客規範」とDCCP-リセットパケットを送信することにより、要求を拒絶しなければなりません。ミドルはまた、サービスコードは不向きと考えられているパケットに応じて、このようなDCCP-リセットを送るかもしれません。"
    },
    {
      "indent": 3,
      "text": "Service Codes are not intended to be DCCP-specific and are allocated by IANA. Following the policies outlined in [RFC2434], most Service Codes are allocated First Come First Served, subject to the following guidelines.",
      "ja": "サービスコードはDCCP特有であることを意図していないと、IANAによって割り当てられています。 [RFC2434]に概説された方針に続いて、ほとんどのサービスコードは、次のガイドラインに従う、まず第一に役立っ来割り当てられています。"
    },
    {
      "indent": 3,
      "text": "o Service Codes are allocated one at a time, or in small blocks. A short English description of the intended service is REQUIRED to obtain a Service Code assignment, but no specification, standards track or otherwise, is necessary. IANA maintains an association of Service Codes to the corresponding phrases.",
      "ja": "Oサービスコードは、一度に1つを割り当てられた、または小さなブロックでされています。意図したサービスの短い英語の説明がサービスコードの割り当てを取得する必要がありますが、指定なし、規格がそうでなければ追跡したり、必要です。 IANAは、対応する語句にサービスコードの関連付けを維持します。"
    },
    {
      "indent": 3,
      "text": "o Users request specific Service Code values. We suggest that users request Service Codes that can be represented using the \"SC:\" formatting convention described below. Thus, the \"Frobodyne Plotz Protocol\" might correspond to Service Code 17178548426 or, equivalently, \"SC:fdpz\". The canonical interpretation of a Service Code field is numeric.",
      "ja": "Oユーザーが特定のサービスコード値を要求します。下記の書式設定規則：私たちは、ユーザーが「SC」を用いて表すことができるサービスコードを要求することを示唆しています。 「：fdpz SC」したがって、「Frobodyne Plotz議定書は、」サービスコード17178548426または、同等に対応することがあります。サービスコードフィールドの標準的な解釈が数値です。"
    },
    {
      "indent": 3,
      "text": "o Service Codes whose bytes each have values in the set {32, 45-57, 65-90} use a Specification Required allocation policy. That is, these Service Codes are used for international standard or standards-track specifications, IETF or otherwise. (This set consists of the ASCII digits, uppercase letters, and characters space, '-', '.', and '/'.)",
      "ja": "そのバイトをそれぞれが集合{32、45-57、65-90}の値を持っている仕様が必要で割り当てポリシーを使用するサービスコードO。それは、これらのサービスコードは、国際規格や標準化過程仕様、IETFまたはそれ以外のために使用されています。 （ - 、および 『/』「」「」このセットには、ASCII数字、大文字、および文字のスペースで構成されています。）"
    },
    {
      "indent": 3,
      "text": "o Service Codes whose high-order byte equals 63 (ASCII '?') are reserved for Private Use.",
      "ja": "その上位バイト63等しい（ASCIIの「？」）Oサービスコードは、私的使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "o Service Code 0 represents the absence of a meaningful Service Code and MUST NOT be allocated.",
      "ja": "Oサービスコード0は、意味のあるサービスコードが存在しないことを表しており、割り当てられてはいけません。"
    },
    {
      "indent": 3,
      "text": "o The value 4294967295 is an invalid Service Code. Servers MUST reject any DCCP-Request with this Service Code value by sending a DCCP-Reset packet with Reset Code 8, \"Bad Service Code\".",
      "ja": "O値4294967295が無効なサービスコードがあります。サーバーはリセットコード8、「悪い接客規範」とDCCP-リセットパケットを送信することにより、このサービスコード値で任意のDCCP-Requestを拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This design for Service Code allocation is based on the allocation of 4-byte identifiers for Macintosh resources, PNG chunks, and TrueType and OpenType tables.",
      "ja": "サービスコードの割り当てのためのこの設計は、Macintoshのリソース、PNGチャンク、およびTrueTypeおよびOpenTypeのテーブルの4バイトの識別子の割り当てに基づいています。"
    },
    {
      "indent": 3,
      "text": "In text settings, we recommend that Service Codes be written in one of three forms, prefixed by the ASCII letters SC and either a colon \":\" or equals sign \"=\". These forms are interpreted as follows.",
      "ja": "「：」または記号「=」に等しいテキスト設定では、我々はサービスコードはASCII文字のSCとコロンのいずれかで始まる3つの形で書かれることをお勧めします。これらのフォームは、次のように解釈されています。"
    },
    {
      "indent": 3,
      "text": "SC: Indicates a Service Code representable using a subset of the ASCII characters. The colon is followed by one to four characters taken from the following set: letters, digits, and the characters in \"-_+.*/?@\" (not including quotes). Numerically, these characters have values in {42-43, 45-57, 63-90, 95, 97-122}. The Service Code is calculated by padding the string on the right with spaces (value 32) and intepreting the four-character result as a 32-bit big-endian number.",
      "ja": "SC：ASCII文字のサブセットを使用してサービスコードの表現を示します。コロンは、以下のセットから取られた1〜4つの文字が続いている：「？-_ + * / @」文字、数字、およびの文字（引用符は含みません）。数値的に、これらの文字は{42-43、45-57、63から90、95、97から122}の値を有します。サービスコードは、スペース（値32）と右側の文字列をパディングし、32ビットのビッグエンディアン番号として4文字の結果をintepretingして算出されます。"
    },
    {
      "indent": 3,
      "text": "SC= Indicates a decimal Service Code. The equals sign is followed by any number of decimal digits, which specify the Service Code. Values above 4294967294 are illegal.",
      "ja": "SC =小数サービスコードを示します。等号は、サービスコードを指定小数点以下の桁の任意の数、続いています。 4294967294上記の値は違法です。"
    },
    {
      "indent": 3,
      "text": "SC=x or SC=X Indicates a hexadecimal Service Code. The \"x\" or \"X\" is followed by any number of hexadecimal digits (upper or lower case), which specify the Service Code. Values above 4294967294 are illegal.",
      "ja": "SC = xまたはSC = Xは、16進のサービスコードを示します。 「X」または「X」は、サービスコードを指定する16進数字（大文字または小文字）、任意の数が続きます。 4294967294上記の値は違法です。"
    },
    {
      "indent": 3,
      "text": "Thus, the Service Code 1717858426 might be represented in text as either SC:fdpz, SC=1717858426, or SC=x6664707A.",
      "ja": "このように、サービスコード1717858426のいずれかSCとしてテキストで表現されることがありますfdpz、SC = 1717858426、またはSC = x6664707A。"
    },
    {
      "indent": 0,
      "text": "8.1.3. Server Response",
      "section_title": true,
      "ja": "8.1.3. サーバーの応答"
    },
    {
      "indent": 3,
      "text": "In the second phase of the three-way handshake, the server moves from the LISTEN state to RESPOND and sends a DCCP-Response message to the client. In this phase, a server will often specify the features it would like to use, either from among those the client requested or in addition to those. Among these options is the congestion control mechanism the server expects to use.",
      "ja": "3ウェイハンドシェイクの第二段階では、LISTEN状態からサーバーに移動するには、応答すると、クライアントにDCCP-Responseメッセージを送信します。このフェーズでは、サーバーは、多くの場合、クライアントが要求したものの中から、またはそれらに加えてのいずれかで、それが使用したい機能を指定します。これらのオプションの中にサーバが使用することを期待する輻輳制御機構です。"
    },
    {
      "indent": 3,
      "text": "The server MAY respond to a DCCP-Request packet with a DCCP-Reset packet to refuse the connection. Relevant Reset Codes for refusing a connection include 7, \"Connection Refused\", when the DCCP-Request's Destination Port did not correspond to a DCCP port open for listening; 8, \"Bad Service Code\", when the DCCP-Request's Service Code did not correspond to the service code registered with the Destination Port; and 9, \"Too Busy\", when the server is currently too busy to respond to requests. The server SHOULD limit the rate at which it generates these resets; for example, to not more than 1024 per second.",
      "ja": "サーバーは接続を拒否するためにDCCP-リセットパケットでDCCP-Requestパケットに応答することができます。接続を拒否ための関連リセットコードは、DCCP-要求の宛先ポートは、リスニングのためのオープンDCCPポートに対応していませんでした「接続拒否」を、7類; 8、「悪い接客規範」、DCCPリクエストのサービスコードは、宛先ポートに登録されたサービスコードに対応していませんでした。そして9、サーバーが現在の要求に応答するには余りにも忙しいときに、「ビジー状態」。サーバは、これらのリセットを生成する速度を制限する必要があります。例えば、毎秒1024以上にしないように。"
    },
    {
      "indent": 3,
      "text": "The server SHOULD NOT retransmit DCCP-Response packets; the client will retransmit the DCCP-Request if necessary. (Note that the \"retransmitted\" DCCP-Request will have, at least, a different sequence number from the \"original\" DCCP-Request. The server can thus distinguish true retransmissions from network duplicates.) The server will detect that the retransmitted DCCP-Request applies to an existing connection because of its Source and Destination Ports. Every valid DCCP-Request received while the server is in the RESPOND state MUST elicit a new DCCP-Response. Each new DCCP-Response MUST increment the server's Sequence Number by one and MUST include the same application data, if any, as the original DCCP-Response.",
      "ja": "サーバはDCCP-応答パケットを再送すべきではありません。必要であれば、クライアントはDCCP-Requestを再送します。サーバは、再送ことを検出する（「再送」DCCP-要求は、少なくとも、「オリジナル」DCCP  - 要求とは異なるシーケンス番号を有すること。サーバは、このようにネットワーク複製から真の再送を区別することができる。注）DCCP-要求は、その送信元ポートおよび宛先ポートの既存の接続に適用されます。すべての有効なDCCP-要求は、サーバーが応答状態にある間に新しいDCCP-応答を惹起しなければならない受け取りました。いずれかの場合にはそれぞれの新しいDCCP-応答は、オリジナルのDCCP-応答として、1により、サーバーのシーケンス番号をインクリメントしなければならなくて、同じアプリケーションデータを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server MUST NOT accept more than one piece of DCCP-Request application data per connection. In particular, the DCCP-Response sent in reply to a retransmitted DCCP-Request with application data SHOULD contain a Data Dropped option, in which the retransmitted DCCP-Request data is reported with Drop Code 0, Protocol Constraints. The original DCCP-Request SHOULD also be reported in the Data Dropped option, either in a Normal Block (if the server accepted the data or there was no data) or in a Drop Code 0 Drop Block (if the server refused the data the first time as well).",
      "ja": "サーバーは接続ごとにDCCP  - 要求アプリケーションデータの複数部分を受け入れてはいけません。具体的には、データを含むべきアプリケーションデータを再送さDCCP-要求に応答して送信されDCCP-応答は、再送さDCCP要求データがドロップコード0、プロトコルの制約で報告されているオプションは、ドロップされました。サーバーは、最初のデータを拒否した場合（またはドロップコード0ドロップブロック内（サーバーがデータを受け入れられるかはデータがなかった場合）、元DCCP-Requestは、データで報告されるべきでは通常、ブロックのいずれかで、オプションをドロップ時間も）。"
    },
    {
      "indent": 3,
      "text": "The Data Dropped and Init Cookie options are particularly useful for DCCP-Response packets (Sections 11.7 and 8.1.4).",
      "ja": "データはドロップとinitクッキーオプションはDCCP  - レスポンスパケット（セクション11.7および8.1.4）のために特に有用です。"
    },
    {
      "indent": 3,
      "text": "The server leaves the RESPOND state for OPEN when it receives a valid DCCP-Ack from the client, completing the three-way handshake. It MAY also leave the RESPOND state for CLOSED after a timeout of not less than 4MSL (8 minutes); when doing so, it SHOULD send a DCCP-Reset with Reset Code 2, \"Aborted\", to clean up state at the client.",
      "ja": "それは3ウェイハンドシェイクが完了し、クライアントから有効なDCCP-ACKを受信したときに、サーバーがOPENのためにRESPOND状態を離れます。また、4MSL（8分）以上のタイムアウト後にCLOSEDのためにRESPOND状態を残すことができます。そうするとき、それは、クライアントの状態をクリーンアップするために、リセットコード2、「中止」とDCCP-リセットを送るべきです。"
    },
    {
      "indent": 0,
      "text": "8.1.4. Init Cookie Option",
      "section_title": true,
      "ja": "8.1.4. 初期クッキーオプション"
    },
    {
      "indent": 3,
      "text": "+--------+--------+--------+--------+--------+--------\n|00100100| Length |         Init Cookie Value   ...\n+--------+--------+--------+--------+--------+--------\n Type=36",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Init Cookie option lets a DCCP server avoid having to hold any state until the three-way connection setup handshake has completed, in a similar fashion as for TCP SYN cookies [SYNCOOKIES]. The server wraps up the Service Code, server port, and any options it cares about from both the DCCP-Request and DCCP-Response in an opaque cookie. Typically the cookie will be encrypted using a secret known only to the server and will include a cryptographic checksum or magic value so that correct decryption can be verified. When the server receives the cookie back in the response, it can decrypt the cookie and instantiate all the state it avoided keeping. In the meantime, it need not move from the LISTEN state.",
      "ja": "初期クッキーオプションは、3ウェイ接続設定ハンドシェイクが完了するまで、TCP SYNクッキー[syncookies機能]の場合と同様の方法で、任意の状態を保持する必要がDCCPサーバーの回避をすることができます。サーバーは、サービスコード、サーバポート、およびそれがDCCP-要求と不透明なクッキーでDCCP-応答の両方から気に任意のオプションをラップします。通常、クッキーはサーバだけに知られている秘密を使用して暗号化され、正しい復号化を検証できるように、暗号化チェックサムや魔法値が含まれます。サーバが応答して戻ってクッキーを受信すると、クッキーを解読し、それが維持避け、すべての状態をインスタンス化することができます。一方で、それはLISTEN状態から移動する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The Init Cookie option MUST NOT be sent on DCCP-Request or DCCP-Data packets. Any Init Cookie options received on DCCP-Request or DCCP-Data packets, or after the connection has been established (when the connection's state is >= OPEN), MUST be ignored. The server MAY include Init Cookie options in its DCCP-Response. If so, then the client MUST echo the same Init Cookie options, in the same order, in each succeeding DCCP packet until one of those packets is acknowledged (showing that the three-way handshake has completed) or the connection is reset. As a result, the client MUST NOT use DCCP-Data packets until the three-way handshake completes or the connection is reset. The Init Cookie options on a client packet MUST equal those received on the DCCP-Request indicated by the client packet's Acknowledgement Number. The server SHOULD design its Init Cookie format so that Init Cookies can be checked for tampering; it SHOULD respond to a tampered Init Cookie option by resetting the connection with Reset Code 10, \"Bad Init Cookie\".",
      "ja": "初期クッキーオプションは、DCCP-要求またはDCCP  - データパケットに送ってはいけません。任意のInit CookieのオプションはDCCP-要求またはDCCP  - データパケットで受信し、または（接続の状態が> = OPENのとき）、接続が確立された後、無視しなければなりません。サーバーは、そのDCCP-応答でのInit Cookieのオプションを含むかもしれません。もしそうであれば、クライアントは、これらのパケットの1つまで、各後続DCCPパケットに、同じ順序で、同じ初期クッキーオプションをエコーし​​なければならない肯定応答（スリーウェイハンドシェイクが完了したことを示す）、または接続がリセットされます。 3ウェイハンドシェイクが完了したか、接続がリセットされるまでその結果、クライアントはDCCP  - データパケットを使用してはなりません。クライアントパケット上のInit Cookieのオプションは、クライアントパケットの確認応答番号で示さDCCP-要求で受信したものと等しくなければなりません。初期のクッキーが改ざんをチェックすることができるように、サーバーは、その初期Cookie形式を設計する必要があります。それはリセットコード10、「悪い初期クッキー」との接続をリセットすることにより、改ざんのInit Cookieのオプションに応じます。"
    },
    {
      "indent": 3,
      "text": "Init Cookie's precise implementation need not be specified here; since Init Cookies are opaque to the client, there are no interoperability concerns. An example cookie format might encrypt (using a secret key) the connection's initial sequence and acknowledgement numbers, ports, Service Code, any options included on the DCCP-Request packet and the corresponding DCCP-Response, a random salt, and a magic number. On receiving a reflected Init Cookie, the server would decrypt the cookie, validate it by checking its magic number, sequence numbers, and ports, and, if valid, create a corresponding socket using the options.",
      "ja": "初期クッキーの正確な実装では、ここで指定する必要はありません。初期クッキーがクライアントに不透明であることから、何の相互運用性の問題はありません。例えば、クッキーのフォーマットは、接続の初期シーケンスおよび確認応答番号、ポート、サービスコード、任意のオプションはDCCP-Requestパケットに含まれており、対応するDCCP-応答、ランダム塩、およびマジックナンバー（秘密鍵を使用して）暗号化するかもしれません。有効な場合は、オプションを使用して対応するソケットを作成し、反映のInitクッキーを受信すると、サーバは、クッキーを解読するでしょうそのマジックナンバー、シーケンス番号、およびポートをチェックして、それを検証し、そして。"
    },
    {
      "indent": 3,
      "text": "Each individual Init Cookie option can hold at most 253 bytes of data, but a server can send multiple Init Cookie options to gain more space.",
      "ja": "個々のInit Cookieのオプションは、データの最大で253のバイトを保持することができますが、サーバーはより多くのスペースを得るために、複数のInit Cookieのオプションを送信することができます。"
    },
    {
      "indent": 0,
      "text": "8.1.5. Handshake Completion",
      "section_title": true,
      "ja": "8.1.5. ハンドシェイク完了"
    },
    {
      "indent": 3,
      "text": "When the client receives a DCCP-Response from the server, it moves from the REQUEST state to PARTOPEN and completes the three-way handshake by sending a DCCP-Ack packet to the server. The client remains in PARTOPEN until it can be sure that the server has received some packet the client sent from PARTOPEN (either the initial DCCP-Ack or a later packet). Clients in the PARTOPEN state that want to send data MUST do so using DCCP-DataAck packets, not DCCP-Data packets. This is because DCCP-Data packets lack Acknowledgement Numbers, so the server can't tell from a DCCP-Data packet whether the client saw its DCCP-Response. Furthermore, if the DCCP-Response included an Init Cookie, that Init Cookie MUST be included on every packet sent in PARTOPEN.",
      "ja": "クライアントがサーバからDCCP-応答を受信した場合、それはPARTOPENにREQUEST状態から移動し、サーバにDCCP-Ackパケットを送信することにより、3ウェイハンドシェイクを完了します。サーバがいくつかのパケットPARTOPEN（どちらかの初期のDCCP-Ackの以降のパケット）から送信されたクライアントを受け取ったことを確認することができるようになるまで、クライアントはPARTOPENに残っています。データを送信したいPARTOPEN状態にあるクライアントは、DCCP  - データパケットはDCCP-DataAckパケットを使用して、ないそうしなければなりません。 DCCP  - データパケットは確認応答番号が不足しているので、クライアントはそのDCCP-応答を見たかどうかをサーバがDCCP  - データパケットから言うことができないためです。さらに、場合DCCP-応答は、initクッキーがPARTOPENに送信されるすべてのパケットに含まれなければならないことを、初期クッキーが含まれています。"
    },
    {
      "indent": 3,
      "text": "The single DCCP-Ack sent when entering the PARTOPEN state might, of course, be dropped by the network. The client SHOULD ensure that some packet gets through eventually. The preferred mechanism would be a roughly 200-millisecond timer, set every time a packet is transmitted in PARTOPEN. If this timer goes off and the client is still in PARTOPEN, the client generates another DCCP-Ack and backs off the timer. If the client remains in PARTOPEN for more than 4MSL (8 minutes), it SHOULD reset the connection with Reset Code 2, \"Aborted\".",
      "ja": "PARTOPEN状態に入るときに送信される単一のDCCP-Ackのは、当然のことながら、ネットワークによって廃棄される可能性があります。クライアントは、いくつかのパケットが最終的を通じて取得することを確認する必要があります。好ましい機構は、パケットがPARTOPENで送信されるたびに設定おおよそ200ミリ秒タイマであろう。このタイマーがオフになると、クライアントはPARTOPENに残っている場合、クライアントは別のDCCP-ACKを生成し、タイマーをオフにバックアップします。クライアントが4MSL以上（8分）のためにPARTOPENに残っている場合、それは、「中止」リセットコード2との接続をリセットする必要があります。"
    },
    {
      "indent": 3,
      "text": "The client leaves the PARTOPEN state for OPEN when it receives a valid packet other than DCCP-Response, DCCP-Reset, or DCCP-Sync from the server.",
      "ja": "それは、サーバからDCCP-応答、DCCP-リセット、またはDCCP同期以外の有効なパケットを受信した場合、クライアントは、OPENのためPARTOPEN状態を離れます。"
    },
    {
      "indent": 0,
      "text": "8.2. Data Transfer",
      "section_title": true,
      "ja": "8.2. データ転送"
    },
    {
      "indent": 3,
      "text": "In the central data transfer phase of the connection, both server and client are in the OPEN state.",
      "ja": "接続の中央のデータ転送フェーズでは、サーバーとクライアントの両方がOPEN状態になっています。"
    },
    {
      "indent": 3,
      "text": "DCCP A sends DCCP-Data and DCCP-DataAck packets to DCCP B due to application events on host A. These packets are congestion-controlled by the CCID for the A-to-B half-connection. In contrast, DCCP-Ack packets sent by DCCP A are controlled by the CCID for the B-to-A half-connection. Generally, DCCP A will piggyback acknowledgement information on DCCP-Data packets when acceptable, creating DCCP-DataAck packets. DCCP-Ack packets are used when there is no data to send from DCCP A to DCCP B, or when the congestion state of the A-to-B CCID will not allow data to be sent.",
      "ja": "DCCP Aは、これらのパケットが輻輳制御のA対B半接続のためにCCIDによるものによるホストA上のアプリケーションイベントにDCCP BにDCCP-データとDCCP-DataAckパケットを送信します。対照的に、DCCP Aによって送られたDCCP-ACKパケットは、B-に半接続のためにCCIDによって制御されます。 DCCP-DataAckパケットを作成する際に許容される、一般的に、DCCP AはDCCP  - データパケットに対して送達確認情報をピギーバックします。そこDCCP BへのDCCP Aから送信するデータがない、またはA対B CCIDの輻輳状態は、データが送信されることを許可しないとき場合DCCP-ACKパケットが使用されます。"
    },
    {
      "indent": 3,
      "text": "DCCP-Sync and DCCP-SyncAck packets may also occur in the data transfer phase. Some cases causing DCCP-Sync generation are discussed in Section 7.5. One important distinction between DCCP-Sync packets and other packet types is that DCCP-Sync elicits an immediate acknowledgement. On receiving a valid DCCP-Sync packet, a DCCP endpoint MUST immediately generate and send a DCCP-SyncAck response (subject to any implementation rate limits); the Acknowledgement Number on that DCCP-SyncAck MUST equal the Sequence Number of the DCCP-Sync.",
      "ja": "DCCP-SyncとDCCP-SyncAckパケットはまた、データ転送フェーズで行うことができます。 DCCP同期発生の原因となるいくつかの場合には、セクション7.5に記載されています。 DCCP-Syncのパケットと他のパケットタイプの間の1つの重要な違いはDCCP-Syncが即時確認応答を誘発することです。有効なDCCP同期パケットを受信すると、DCCP終点は直ちにDCCP-SyncAck応答（どんな実装レート制限を受ける）を生成して送信しなければなりません。そのDCCP-SyncAckに確認応答番号DCCP同期のシーケンス番号に等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "A particular DCCP implementation might decide to initiate feature negotiation only once the OPEN state was reached, in which case it might not allow data transfer until some time later. Data received during that time SHOULD be rejected and reported using a Data Dropped Drop Block with Drop Code 0, Protocol Constraints (see Section 11.7).",
      "ja": "特定のDCCP実装は、OPEN状態は、それはいくつかの時間後になるまでのデータ転送を許可しない場合があります。その場合には、達成された一度だけの機能の交渉を開始することを決めるかもしれません。その時に受信したデータは、拒否され、データがドロップコード0で落下ブロックをドロップ使用して報告されるべきである（SHOULD）プロトコルの制約（11.7節を参照してください）。"
    },
    {
      "indent": 0,
      "text": "8.3. Termination",
      "section_title": true,
      "ja": "8.3. 終了"
    },
    {
      "indent": 3,
      "text": "DCCP connection termination uses a handshake consisting of an optional DCCP-CloseReq packet, a DCCP-Close packet, and a DCCP-Reset packet. The server moves from the OPEN state, possibly through the CLOSEREQ state, to CLOSED; the client moves from OPEN through CLOSING to TIMEWAIT, and after 2MSL wait time (4 minutes) to CLOSED.",
      "ja": "DCCP接続終了は、オプションDCCP-CloseReqパケット、DCCPクローズパケット、およびDCCP  - リセットパケットからなるハンドシェイクを使用しています。サーバはCLOSEDに、おそらくはCLOSEREQ状態を介して、開状態から移動します。クライアントはTIMEWAITにCLOSINGを通じてOPENから移動し、2MSL後CLOSEDまでの時間（4分）を待ちます。"
    },
    {
      "indent": 3,
      "text": "The sequence DCCP-CloseReq, DCCP-Close, DCCP-Reset is used when the server decides to close the connection but doesn't want to hold TIMEWAIT state:",
      "ja": "シーケンスDCCP-CloseReq、DCCP-閉じるが、DCCP  - リセットは、サーバーが接続を終了することを決定したが、TIMEWAIT状態を保持したくないときに使用されます。"
    },
    {
      "indent": 3,
      "text": " Client State Server State OPEN OPEN 1. <-- CloseReq <-- CLOSEREQ 2. CLOSING --> Close --> 3. <-- Reset <-- CLOSED (LISTEN) 4. TIMEWAIT 5. CLOSED",
      "ja": "クライアント状態サーバーの状態OPEN OPEN 1. < -  CloseReq < -  CLOSEREQ 2. CLOSING  - >閉じる - > 3 < -  <リセット -  CLOSED（LISTEN）4. TIMEWAIT 5. CLOSED"
    },
    {
      "indent": 3,
      "text": "A shorter sequence occurs when the client decides to close the connection.",
      "ja": "クライアントが接続を閉じることを決定したときより短い配列が発生します。"
    },
    {
      "indent": 3,
      "text": " Client State Server State OPEN OPEN 1. CLOSING --> Close --> 2. <-- Reset <-- CLOSED (LISTEN) 3. TIMEWAIT 4. CLOSED",
      "ja": "クライアント状態サーバーの状態OPEN OPEN 1. CLOSING  - >閉じる - > 2. < -  <リセット -  CLOSED（LISTEN）3. TIME_WAIT 4. CLOSED"
    },
    {
      "indent": 3,
      "text": "Finally, the server can decide to hold TIMEWAIT state:",
      "ja": "最後に、サーバはTIMEWAIT状態を保持することを決定することができます。"
    },
    {
      "indent": 3,
      "text": " Client State Server State OPEN OPEN 1. <-- Close <-- CLOSING 2. CLOSED --> Reset --> 3. TIMEWAIT 4. CLOSED (LISTEN)",
      "ja": "クライアント状態サーバーの状態OPEN OPEN 1. < - クローズ< -  2が閉じ閉会 - >リセット - > 3. TIMEWAIT 4. CLOSED（LISTEN）"
    },
    {
      "indent": 3,
      "text": "In all cases, the receiver of the DCCP-Reset packet holds TIMEWAIT state for the connection. As in TCP, TIMEWAIT state, where an endpoint quietly preserves a socket for 2MSL (4 minutes) after its connection has closed, ensures that no connection duplicating the current connection's source and destination addresses and ports can start up while old packets might remain in the network.",
      "ja": "全ての場合において、DCCP  - リセットパケットの受信機は、接続用TIMEWAIT状態を保持します。 TCPのように、その接続が閉じられた後に、エンドポイントが静かに2MSL（4分）のためのソケットを保持するTIMEWAIT状態は、古いパケットが中に残っているかもしれないが、現在の接続の送信元と送信先アドレスとポートを複製するには接続が起動しないことが保証さ通信網。"
    },
    {
      "indent": 3,
      "text": "The termination handshake proceeds as follows. The receiver of a valid DCCP-CloseReq packet MUST respond with a DCCP-Close packet. The receiver of a valid DCCP-Close packet MUST respond with a DCCP-Reset packet with Reset Code 1, \"Closed\". The receiver of a valid DCCP-Reset packet -- which is also the sender of the DCCP-Close packet (and possibly the receiver of the DCCP-CloseReq packet) -- will hold TIMEWAIT state for the connection.",
      "ja": "次のように終了ハンドシェイクが進行します。有効なDCCP-CloseReqパケットの受信機はDCCP-閉じるパケットで応じなければなりません。有効なDCCP-閉じるパケットの受信機は、「クローズ」、リセットコード1とDCCP-リセットパケットで応じなければなりません。また、DCCPクローズパケット（およびおそらくDCCP-CloseReqパケットの受信機）の送信元である -   - 有効なDCCP  - リセットパケットの受信機は、接続用TIMEWAIT状態を保持します。"
    },
    {
      "indent": 3,
      "text": "A DCCP-Reset packet completes every DCCP connection, whether the termination is clean (due to application close; Reset Code 1, \"Closed\") or unclean. Unlike TCP, which has two distinct termination mechanisms (FIN and RST), DCCP ends all connections in a uniform manner. This is justified because some aspects of connection termination are the same independent of whether termination was clean. For instance, the endpoint that receives a valid DCCP-Reset SHOULD hold TIMEWAIT state for the connection. Processors that must distinguish between clean and unclean termination can examine the Reset Code. DCCP implementations generally transition to the CLOSED state after sending a DCCP-Reset packet.",
      "ja": "または汚れ; DCCP-リセットパケットが終了（リセットコード1、「クローズ」により近いアプリケーションに）きれいであるかどうか、すべてのDCCP接続を完了します。二つの別個の終結機構（FIN及びRST）を有するTCPとは異なり、DCCPは均一にすべての接続を終了します。接続終了のいくつかの側面を終了がきれいだったかどうか、同じ独立しているので、これは正当化されます。例えば、有効なDCCP-リセットを受信エンドポイントは、接続のためのTIMEWAIT状態を保持する必要があります。清潔で汚れ終了とを区別しなければならないプロセッサは、リセットコードを調べることができます。 DCCP実装は、一般的にDCCP  - リセットパケットを送信した後CLOSED状態に遷移します。"
    },
    {
      "indent": 3,
      "text": "Endpoints in the CLOSEREQ and CLOSING states MUST retransmit DCCP-CloseReq and DCCP-Close packets, respectively, until leaving those states. The retransmission timer should initially be set to go off in two round-trip times and should back off to not less than once every 64 seconds if no relevant response is received.",
      "ja": "CLOSEREQとCLOSING状態でのエンドポイントは、それらの状態を残してまで、それぞれ、DCCP-CloseReqとDCCP-閉じるパケットを再送しなければなりません。再送タイマは、最初に2往復時間でオフに行くように設定されるべきであると該当する応答が受信されない場合は一回64秒未満ではないにバックオフする必要があります。"
    },
    {
      "indent": 3,
      "text": "Only the server can send a DCCP-CloseReq packet or enter the CLOSEREQ state. A server receiving a sequence-valid DCCP-CloseReq packet MUST respond with a DCCP-Sync packet and otherwise ignore the DCCP-CloseReq.",
      "ja": "サーバだけがDCCP-CloseReqパケットを送信したり、CLOSEREQ状態に入ることができます。シーケンスの有効なDCCP-CloseReqパケットを受信したサーバはDCCP同期パケットで応答し、そうでない場合はDCCP-CloseReqを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "DCCP-Data, DCCP-DataAck, and DCCP-Ack packets received in CLOSEREQ or CLOSING states MAY be either processed or ignored.",
      "ja": "CLOSEREQまたはCLOSING状態で受信DCCP-データ、DCCP-DataAck、およびDCCP-Ackのパケットが処理されるか、または無視のいずれかであってもよいです。"
    },
    {
      "indent": 0,
      "text": "8.3.1. Abnormal Termination",
      "section_title": true,
      "ja": "8.3.1. 異常終了"
    },
    {
      "indent": 3,
      "text": "DCCP endpoints generate DCCP-Reset packets to terminate connections abnormally; a DCCP-Reset packet may be generated from any state. Resets sent in the CLOSED, LISTEN, and TIMEWAIT states use Reset Code 3, \"No Connection\", unless otherwise specified. Resets sent in the REQUEST or RESPOND states use Reset Code 4, \"Packet Error\", unless otherwise specified.",
      "ja": "DCCP終点は、異常な接続を終了するDCCP  - リセットパケットを生成します。 DCCP  - リセットパケットは、任意の状態から生成することができます。 CLOSEDに送られたリセットは、LISTEN、特に断らない限りTIMEWAIT状態は、リセットコード3、「接続なし」を使用します。リセットは、リクエストで送信されたか、特に指定のない限り状態は、リセットコード4、「パケットエラー」を使用して応答します。"
    },
    {
      "indent": 3,
      "text": "DCCP endpoints in CLOSED, LISTEN, or TIMEWAIT state may need to generate a DCCP-Reset packet in response to a packet received from a peer. Since these states have no associated sequence number variables, the Sequence and Acknowledgement Numbers on the DCCP-Reset packet R are taken from the received packet P, as follows.",
      "ja": "CLOSEDにおけるDCCPエンドポイントは、LISTEN、またはTIMEWAIT状態は、ピアから受信したパケットに応答して、DCCP  - リセットパケットを生成する必要があるかもしれません。これらの状態は、DCCP  - リセットパケットRには関連付けられたシーケンス番号変数、シーケンスおよび確認応答番号を持っていないので、次のように、受信したパケットPから取られます。"
    },
    {
      "indent": 3,
      "text": "1. If P.ackno exists, then set R.seqno := P.ackno + 1. Otherwise, set R.seqno := 0.",
      "ja": "1. P.acknoが存在する場合、R.seqno設定します、それ以外の場合= P.ackno + 1. R.seqnoを設定：= 0。"
    },
    {
      "indent": 3,
      "text": "2. Set R.ackno := P.seqno.",
      "section_title": true,
      "ja": "2.設定しR.ackno：= P.seqno。"
    },
    {
      "indent": 3,
      "text": "3. If the packet used short sequence numbers (P.X == 0), then set the upper 24 bits of R.seqno and R.ackno to 0.",
      "ja": "3.パケットが短い一連番号（P.X == 0）を使用した場合、0にR.seqnoとR.acknoの上位24ビットを設定します。"
    },
    {
      "indent": 0,
      "text": "8.4. DCCP State Diagram",
      "section_title": true,
      "ja": "8.4.  DCCP状態図"
    },
    {
      "indent": 3,
      "text": "The most common state transitions discussed above can be summarized in the following state diagram. The diagram is illustrative; the text in Section 8.5 and elsewhere should be considered definitive. For example, there are arcs (not shown) from every state except CLOSED to TIMEWAIT, contingent on the receipt of a valid DCCP-Reset.",
      "ja": "上述の最も一般的な状態遷移は、以下の状態図に要約することができます。図は例示です。セクション8.5および他の場所でのテキストが決定的と考えるべきです。例えば、TIMEWAIT、有効なDCCP  - リセットを受けて偶発的にCLOSED以外のすべての状態からアーク（図示せず）があります。"
    },
    {
      "indent": 3,
      "text": "+---------------------------+    +---------------------------+\n|                           v    v                           |\n|                        +----------+                        |\n|          +-------------+  CLOSED  +------------+           |\n|          | passive     +----------+  active    |           |\n|          |  open                      open     |           |\n|          |                         snd Request |           |\n|          v                                     v           |\n|     +----------+                          +----------+     |\n|     |  LISTEN  |                          | REQUEST  |     |\n|     +----+-----+                          +----+-----+     |\n|          | rcv Request            rcv Response |           |\n|          | snd Response             snd Ack    |           |\n|          v                                     v           |\n|     +----------+                          +----------+     |\n|     | RESPOND  |                          | PARTOPEN |     |\n|     +----+-----+                          +----+-----+     |\n|          | rcv Ack/DataAck         rcv packet  |           |\n|          |                                     |           |\n|          |             +----------+            |           |\n|          +------------>|   OPEN   |<-----------+           |\n|                        +--+-+--+--+                        |\n|       server active close | |  |   active close            |\n|           snd CloseReq    | |  | or rcv CloseReq           |\n|                           | |  |    snd Close              |\n|                           | |  |                           |\n|     +----------+          | |  |          +----------+     |\n|     | CLOSEREQ |<---------+ |  +--------->| CLOSING  |     |\n|     +----+-----+            |             +----+-----+     |\n|          | rcv Close        |        rcv Reset |           |\n|          | snd Reset        |                  |           |\n|<---------+                  |                  v           |\n|                             |             +----+-----+     |\n|                   rcv Close |             | TIMEWAIT |     |\n|                   snd Reset |             +----+-----+     |\n+-----------------------------+                  |           |\n                                                 +-----------+\n                                              2MSL timer expires",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.5. Pseudocode",
      "section_title": true,
      "ja": "8.5. 擬似コード"
    },
    {
      "indent": 3,
      "text": "This section presents an algorithm describing the processing steps a DCCP endpoint must go through when it receives a packet. A DCCP implementation need not implement the algorithm as it is described here, but any implementation MUST generate observable effects exactly as indicated by this pseudocode, except where allowed otherwise by another part of this document.",
      "ja": "このセクションでは、処理は、それがパケットを受信したときDCCP終点が通過しなければならない手順を記述したアルゴリズムを示します。それがここで説明されるようDCCP実装は、アルゴリズムを実装する必要はなく、任意の実装は、この文書の別の部分でそれ以外の場合は許可した場合を除いて、この擬似コードで示されているとおりに観察可能な効果を発生させなければなりません。"
    },
    {
      "indent": 3,
      "text": "The received packet is written as P, the socket as S. Socket variables are:",
      "ja": "受信したパケットをPとして書き込まれ、S.ソケット変数としてソケットは、次のとおり"
    },
    {
      "indent": 3,
      "text": "S.SWL - sequence number window low S.SWH - sequence number window high S.AWL - acknowledgement number window low S.AWH - acknowledgement number window high S.ISS - initial sequence number sent S.ISR - initial sequence number received S.OSR - first OPEN sequence number received S.GSS - greatest sequence number sent S.GSR - greatest valid sequence number received S.GAR - greatest valid acknowledgement number received on a non-Sync; initialized to S.ISS \"Send packet\" actions always use, and increment, S.GSS.",
      "ja": "S.SWL  - シーケンス番号のウィンドウ低いS.SWH  - シーケンス番号のウィンドウ高S.AWL  - 確認応答番号のウィンドウ低いS.AWH  - 確認応答番号のウィンドウ高S.ISS  - 初期シーケンス番号はS.ISRを送った - 初期シーケンス番号は、Sを受信OSR  - 最初のOPENシーケンス番号がS.GSSを受けた - 最大のシーケンス番号がS.GSRを送った - 最大の有効なシーケンス番号がS.GAR受信 - 非同期で受信した最大の有効な承認番号を、 、S.GSSをS.ISSアクション常に使用「パケットが送信」、および増分に初期化。"
    },
    {
      "indent": 3,
      "text": "Step 1: Check header basics\n   /* This step checks for malformed packets.  Packets that fail\n      these checks are ignored -- they do not receive Resets in\n      response */\n   If the packet is shorter than 12 bytes, drop packet and return\n   If P.type is not understood, drop packet and return\n   If P.Data Offset is smaller than the given packet type's\n         fixed header length or larger than the packet's length,\n         drop packet and return\n   If P.type is not Data, Ack, or DataAck and P.X == 0 (the packet\n         has short sequence numbers), drop packet and return\n   If the header checksum is incorrect, drop packet and return\n   If P.CsCov is too large for the packet size, drop packet and\n         return",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Step 2: Check ports and process TIMEWAIT state\n   /* Flow ID is <src addr, src port, dst addr, dst port> 4-tuple */\n   Look up flow ID in table and get corresponding socket\n   If no socket, or S.state == TIMEWAIT,\n      /* The following Reset's Sequence and Acknowledgement Numbers\n         are taken from the input packet; see Section 8.3.1. */\n      Generate Reset(No Connection) unless P.type == Reset\n      Drop packet and return",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Step 3: Process LISTEN state\n   If S.state == LISTEN,\n      If P.type == Request or P contains a valid Init Cookie option,\n         /* Must scan the packet's options to check for Init\n            Cookies.  Only Init Cookies are processed here,\n            however; other options are processed in Step 8.  This\n            scan need only be performed if the endpoint uses Init\n            Cookies */\n         /* Generate a new socket and switch to that socket */\n         Set S := new socket for this port pair\n         S.state = RESPOND\n         Choose S.ISS (initial seqno) or set from Init Cookies\n         Initialize S.GAR := S.ISS\n         Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookies\n         Continue with S.state == RESPOND\n         /* A Response packet will be generated in Step 11 */\n      Otherwise,\n         Generate Reset(No Connection) unless P.type == Reset\n         Drop packet and return",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Step 4: Prepare sequence numbers in REQUEST\n   If S.state == REQUEST,\n      If (P.type == Response or P.type == Reset)\n            and S.AWL <= P.ackno <= S.AWH,\n         /* Set sequence number variables corresponding to the\n            other endpoint, so P will pass the tests in Step 6 */\n         Set S.GSR, S.ISR, S.SWL, S.SWH\n         /* Response processing continues in Step 10; Reset\n            processing continues in Step 9 */\n      Otherwise,\n         /* Only Response and Reset are valid in REQUEST state */\n         Generate Reset(Packet Error)\n         Drop packet and return",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Step 5: Prepare sequence numbers for Sync\n   If P.type == Sync or P.type == SyncAck,\n      If S.AWL <= P.ackno <= S.AWH and P.seqno >= S.SWL,\n         /* P is valid, so update sequence number variables\n            accordingly.  After this update, P will pass the tests\n            in Step 6.  A SyncAck is generated if necessary in\n            Step 15 */\n         Update S.GSR, S.SWL, S.SWH\n      Otherwise,\n         Drop packet and return",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Step 6: Check sequence numbers\n   If P.X == 0 and the relevant Allow Short Seqnos feature is 0,\n      /* Packet has short seqnos, but short seqnos not allowed */\n      Drop packet and return\n   Otherwise, if P.X == 0,\n      Extend P.seqno and P.ackno to 48 bits using the procedure\n      in Section 7.6\n   Let LSWL = S.SWL and LAWL = S.AWL\n   If P.type == CloseReq or P.type == Close or P.type == Reset,\n      LSWL := S.GSR + 1, LAWL := S.GAR\n   If LSWL <= P.seqno <= S.SWH\n         and (P.ackno does not exist or LAWL <= P.ackno <= S.AWH),\n      Update S.GSR, S.SWL, S.SWH\n      If P.type != Sync,\n         Update S.GAR\n   Otherwise,\n      If P.type == Reset,\n         Send Sync packet acknowledging S.GSR\n      Otherwise,\n         Send Sync packet acknowledging P.seqno\n      Drop packet and return",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Step 7: Check for unexpected packet types If (S.is_server and P.type == CloseReq) or (S.is_server and P.type == Response) or (S.is_client and P.type == Request) or (S.state >= OPEN and P.type == Request and P.seqno >= S.OSR) or (S.state >= OPEN and P.type == Response and P.seqno >= S.OSR) or (S.state == RESPOND and P.type == Data), Send Sync packet acknowledging P.seqno Drop packet and return",
      "ja": "ステップ7：（リクエスト== S.is_clientとP.type）場合（S.is_serverとP.type CloseReq ==）予想外のパケットの種類を確認するか（S.is_serverとP.type ==応答）またはまたは（S .state> = OPENとP.type ==リクエストとP.seqno> = S.OSR）または（S.state> = OPENとP.type ==応答とP.seqno> = S.OSR）または（S .state ==対応し、P.type ==データ）、P.seqnoドロップパケットとリターンを認め同期パケットを送信します"
    },
    {
      "indent": 3,
      "text": "Step 8: Process options and mark acknowledgeable\n   /* Option processing is not specifically described here.\n      Certain options, such as Mandatory, may cause the connection\n      to be reset, in which case Steps 9 and on are not executed */\n   Mark packet as acknowledgeable (in Ack Vector terms, Received\n        or Received ECN Marked)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Step 9: Process Reset If P.type == Reset, Tear down connection S.state := TIMEWAIT Set TIMEWAIT timer Drop packet and return",
      "ja": "手順9：プロセスがP.typeが==リセットした場合、リセット接続S.stateを取り壊す：= TIMEWAIT設定TIMEWAITタイマードロップパケットとリターン"
    },
    {
      "indent": 3,
      "text": "Step 10: Process REQUEST state (second part)\n   If S.state == REQUEST,\n      /* If we get here, P is a valid Response from the server (see\n         Step 4), and we should move to PARTOPEN state.  PARTOPEN\n         means send an Ack, don't send Data packets, retransmit\n         Acks periodically, and always include any Init Cookie from\n         the Response */\n      S.state := PARTOPEN\n      Set PARTOPEN timer\n      Continue with S.state == PARTOPEN\n      /* Step 12 will send the Ack completing the three-way\n         handshake */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Step 11: Process RESPOND state\n   If S.state == RESPOND,\n      If P.type == Request,\n         Send Response, possibly containing Init Cookie\n         If Init Cookie was sent,\n            Destroy S and return\n            /* Step 3 will create another socket when the client\n               completes the three-way handshake */\n      Otherwise,\n         S.OSR := P.seqno\n         S.state := OPEN",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Step 12: Process PARTOPEN state If S.state == PARTOPEN, If P.type == Response, Send Ack Otherwise, if P.type != Sync, S.OSR := P.seqno S.state := OPEN",
      "ja": "ステップ12：、P.type ==応答した場合、P.typeあれば、そうでない場合はACKを送るプロセスPARTOPEN状態S.state == PARTOPEN場合=同期、S.OSR：！= P.seqno S.state：= OPEN"
    },
    {
      "indent": 3,
      "text": "Step 13: Process CloseReq If P.type == CloseReq and S.state < CLOSEREQ, Generate Close S.state := CLOSING Set CLOSING timer",
      "ja": "ステップ13：= CLOSINGセットCLOSINGタイマー：プロセスCloseReq P.type == CloseReqとS.state <CLOSEREQは、閉じるS.stateを生成する場合"
    },
    {
      "indent": 3,
      "text": "Step 14: Process Close If P.type == Close, Generate Reset(Closed) Tear down connection Drop packet and return",
      "ja": "ステップ14：プロセス閉じるP.type ==閉じる場合は、リセット（クローズ）を生成し、接続ドロップパケットとリターンを取り壊します"
    },
    {
      "indent": 3,
      "text": "Step 15: Process Sync If P.type == Sync, Generate SyncAck",
      "ja": "ステップ15：プロセス同期する場合P.type ==同期、SyncAckを生成します"
    },
    {
      "indent": 3,
      "text": "Step 16: Process data\n   /* At this point any application data on P can be passed to the\n      application, except that the application MUST NOT receive\n      data from more than one Request or Response */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9. Checksums",
      "section_title": true,
      "ja": "9.チェックサム"
    },
    {
      "indent": 3,
      "text": "DCCP uses a header checksum to protect its header against corruption. Generally, this checksum also covers any application data. DCCP applications can, however, request that the header checksum cover only part of the application data, or perhaps no application data at all. Link layers may then reduce their protection on unprotected parts of DCCP packets. For some noisy links, and for applications that can tolerate corruption, this can greatly improve delivery rates and perceived performance.",
      "ja": "DCCPは、腐敗、そのヘッダを保護するために、ヘッダチェックサムを使用しています。一般的には、このチェックサムはまた、任意のアプリケーションデータをカバーしています。 DCCPアプリケーションは、しかし、アプリケーションデータ、またはまったく多分ないアプリケーションデータのヘッダチェックサムカバーは一部のみように要求することができます。リンク層は、DCCPパケットの保護されていない部分について、その保護を減らすことができます。いくつかの騒々しいリンクについては、汚職を許容できるアプリケーションのために、これは非常に配達率と体感的なパフォーマンスを向上させることができます。"
    },
    {
      "indent": 3,
      "text": "Checksum coverage may eventually impact congestion control mechanisms as well. A packet with corrupt application data and complete checksum coverage is treated as lost. This incurs a heavy-duty loss response from the sender's congestion control mechanism, which can unfairly penalize connections on links with high background corruption. The combination of reduced checksum coverage and Data Checksum options may let endpoints report packets as corrupt rather than dropped, using Data Dropped options and Drop Code 3 (see Section 11.7). This may eventually benefit applications. However, further research is required to determine an appropriate response to corruption, which can sometimes correlate with congestion. Corrupt packets currently incur a loss response.",
      "ja": "チェックサム・カバレッジは、最終的にも輻輳制御メカニズムに影響を与えることができます。失われたとして、破損したアプリケーションデータと完全なチェックサム適用範囲を持つパケットが処理されます。これは不当に高いバックグラウンドの破損とのリンクで接続を罰することができ、送信者の輻輳制御機構、から大型損失応答が発生します。減少し、チェックサムのカバレッジとデータチェックサムオプションの組み合わせは、エンドポイントは、データはオプションとドロップコード3を（11.7節を参照してください）ドロップ使用して、破損しているとしてではなく、ドロップされたパケットを報告してみましょうことがあります。これは、最終的にアプリケーションを利益を得ることができます。しかしながら、さらなる研究が時々混雑と相関することができる破損への適切な応答を決定する必要があります。破損したパケットは、現在の損失応答を被ります。"
    },
    {
      "indent": 3,
      "text": "The Data Checksum option, which contains a strong CRC, lets endpoints detect application data corruption. An API can then be used to avoid delivering corrupt data to the application, even if links deliver corrupt data to the endpoint due to reduced checksum coverage. However, the use of reduced checksum coverage for applications that demand correct data is currently considered experimental. This is because the combined loss-plus-corruption rate for packets with reduced checksum coverage may be significantly higher than that for packets with full checksum coverage, although the loss rate will generally be lower. Actual behavior will depend on link design; further research and experience is required.",
      "ja": "強力なCRCが含まれているデータのチェックサムオプションは、エンドポイントは、アプリケーションデータの破損を検出することができます。 APIは、リンクが減少し、チェックサム・カバレッジのためにエンドポイントに破損したデータを提供する場合でも、アプリケーションに壊れたデータを配信避けるために使用することができます。しかし、正しいデータを必要とするアプリケーションのために減少したチェックサム適用範囲の使用は、現在、実験的なものと考えています。損失率は、一般的に低くなるが減少チェックサム適用範囲とパケットの複合損失プラス破損率は、完全なチェックサム・カバレッジを有するパケットの場合よりも有意に高くすることができるからです。実際の動作は、リンクの設計に依存します。さらなる研究と経験が必要です。"
    },
    {
      "indent": 3,
      "text": "Reduced checksum coverage introduces some security considerations; see Section 18.1. See Appendix B for further motivation and",
      "ja": "減少し、チェックサム適用範囲は、いくつかのセキュリティ上の考慮事項を紹介します。 18.1節を参照してください。さらに動機については、付録Bを参照してください"
    },
    {
      "indent": 3,
      "text": "discussion. DCCP's implementation of reduced checksum coverage was inspired by UDP-Lite [RFC3828].",
      "ja": "討論。減少し、チェックサム・カバレッジのDCCPの実装はUDP-Liteは[RFC3828]に触発されました。"
    },
    {
      "indent": 0,
      "text": "9.1. Header Checksum Field",
      "section_title": true,
      "ja": "9.1. ヘッダチェックサム・フィールド"
    },
    {
      "indent": 3,
      "text": "DCCP uses the TCP/IP checksum algorithm. The Checksum field in the DCCP generic header (see Section 5.1) equals the 16-bit one's complement of the one's complement sum of all 16-bit words in the DCCP header, DCCP options, a pseudoheader taken from the network-layer header, and, depending on the value of the Checksum Coverage field, some or all of the application data. When calculating the checksum, the Checksum field itself is treated as 0. If a packet contains an odd number of header and payload bytes to be checksummed, 8 zero bits are added on the right to form a 16-bit word for checksum purposes. The pad byte is not transmitted as part of the packet.",
      "ja": "DCCPは、TCP / IPのチェックサムアルゴリズムを使用しています。 DCCPジェネリックヘッダ内のチェックサムフィールド（セクション5.1を参照）DCCPヘッダ、DCCPオプション、ネットワーク層ヘッダから取られた擬似ヘッダ内の全ての16ビットワードの1の補数和の16ビットの1の補数に等しく、そしてアプリケーションデータのチェックサム・カバレッジ・フィールドの値に応じて、一部またはすべて。チェックサムを計算するときに、パケットが8ゼロビットがチェックサムの目的のために、16ビット・ワードを形成するために右側に追加され、チェックサムするヘッダとペイロードバイトの奇数が含まれている場合、チェックサムフィールド自体は0として扱われます。パッドバイトは、パケットの一部として送信されていません。"
    },
    {
      "indent": 3,
      "text": "The pseudoheader is calculated as for TCP. For IPv4, it is 96 bits long and consists of the IPv4 source and destination addresses, the IP protocol number for DCCP (padded on the left with 8 zero bits), and the DCCP length as a 16-bit quantity (the length of the DCCP header with options, plus the length of any data); see [RFC793], Section 3.1. For IPv6, it is 320 bits long, and consists of the IPv6 source and destination addresses, the DCCP length as a 32-bit quantity, and the IP protocol number for DCCP (padded on the left with 24 zero bits); see [RFC2460], Section 8.1.",
      "ja": "擬似ヘッダは、TCPのためのように計算されます。 IPv4の場合、それは96ビット長であり、IPv4ソースアドレスと宛先アドレスで構成され、（8ゼロビットで左に埋め）DCCPのためのIPプロトコル番号、および16ビット量としてDCCPの長さ（長さDCCPオプションとヘッダ、および任意のデータの長さ）。 [RFC793]、セクション3.1を参照してください。 IPv6の場合、それは長い320ビットであり、IPv6ソースアドレスと宛先アドレスで構成され、32ビットの量としてDCCPの長さ、および（24のゼロビットと左側のパディング）DCCPのためのIPプロトコル番号。 [RFC2460]、セクション8.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Packets with invalid header checksums MUST be ignored. In particular, their options MUST NOT be processed.",
      "ja": "無効なヘッダーチェックサムを持つパケットは無視しなければなりません。具体的には、そのオプションを処理してはなりません。"
    },
    {
      "indent": 0,
      "text": "9.2. Header Checksum Coverage Field",
      "section_title": true,
      "ja": "9.2. ヘッダチェックサム・カバレッジ・フィールド"
    },
    {
      "indent": 3,
      "text": "The Checksum Coverage field in the DCCP generic header (see Section 5.1) specifies what parts of the packet are covered by the Checksum field, as follows:",
      "ja": "次のようにDCCPジェネリックヘッダー内のチェックサムカバー範囲フィールドは、パケットの部分はチェックサムフィールドで覆われているものを指定します（セクション5.1を参照してください）："
    },
    {
      "indent": 3,
      "text": "CsCov = 0 The Checksum field covers the DCCP header, DCCP options, network-layer pseudoheader, and all application data in the packet, possibly padded on the right with zeros to an even number of bytes.",
      "ja": "CsCov = 0チェックサムフィールドを偶数バイトにゼロが右側にパディングおそらく、DCCPヘッダ、DCCPオプション、ネットワーク層擬似ヘッダ、およびパケット内のすべてのアプリケーションデータをカバーします。"
    },
    {
      "indent": 3,
      "text": "CsCov = 1-15 The Checksum field covers the DCCP header, DCCP options, network-layer pseudoheader, and the initial (CsCov-1)*4 bytes of the packet's application data.",
      "ja": "CsCov = 1-15チェックサムフィールドは、DCCPヘッダ、DCCPオプション、ネットワーク層擬似ヘッダ、及び初期（CsCov-1）*パケットのアプリケーションデータの4つのバイトをカバーします。"
    },
    {
      "indent": 3,
      "text": "Thus, if CsCov is 1, none of the application data is protected by the header checksum. The value (CsCov-1)*4 MUST be less than or equal to the length of the application data. Packets with invalid CsCov values MUST be ignored; in particular, their options MUST NOT be processed. The meanings of values other than 0 and 1 should be considered experimental.",
      "ja": "CsCovが1である場合したがって、アプリケーションデータのいずれも、ヘッダチェックサムによって保護されていません。値（CsCov-1）* 4は、以下のアプリケーション・データの長さに等しくなければなりません。無効なCsCov値を持つパケットは無視しなければなりません。具体的には、そのオプションを処理してはなりません。 0と1以外の値の意味は実験的と見なされるべきです。"
    },
    {
      "indent": 3,
      "text": "Values other than 0 specify that corruption is acceptable in some or all of the DCCP packet's application data. In fact, DCCP cannot even detect corruption in areas not covered by the header checksum, unless the Data Checksum option is used. Applications should not make any assumptions about the correctness of received data not covered by the checksum and should, if necessary, introduce their own validity checks.",
      "ja": "0以外の値が破損がDCCPパケットのアプリケーションデータの一部またはすべてでは許容可能であることを指定します。データチェックサムオプションを使用しない限り、実際には、DCCPも、ヘッダチェックサムによってカバーされていない領域の破損を検出することができません。アプリケーションは、チェックサムで覆われ、必要に応じて、自分自身の妥当性チェックを導入すべきではない、受信したデータの正確性についての仮定を行うべきではありません。"
    },
    {
      "indent": 3,
      "text": "A DCCP application interface should let sending applications suggest a value for CsCov for sent packets, defaulting to 0 (full coverage). The Minimum Checksum Coverage feature, described below, lets an endpoint refuse delivery of application data on packets with partial checksum coverage; by default, only fully covered application data is accepted. Lower layers that support partial error detection MAY use the Checksum Coverage field as a hint of where errors do not need to be detected. Lower layers MUST use a strong error detection mechanism to detect at least errors that occur in the sensitive part of the packet, and to discard damaged packets. The sensitive part consists of the bytes between the first byte of the IP header and the last byte identified by Checksum Coverage.",
      "ja": "DCCPアプリケーションインターフェースは、アプリケーションが0（フルカバー）をデフォルト、送信されるパケットのCsCovの値を示唆して送信するようにする必要があります。以下に説明する最小サムカバレッジ機能は、エンドポイントが部分的チェックサム適用範囲とパケットのアプリケーションデータの配信を拒否することができます。デフォルトでは、唯一の完全にカバーされたアプリケーションデータが受け入れられています。部分的なエラー検出をサポートする下位層は、エラーが検出されている必要はありませんどこのヒントとしてチェックサム・カバレッジ・フィールドを使用するかもしれません。下位層は、パケットの敏感な部分で発生する少なくともエラーを検出するための強力なエラー検出メカニズムを使用しなければなりません、そして損傷したパケットを廃棄します。敏感な部分は、IPヘッダとチェックサム・カバレッジによって識別される最後のバイトの最初のバイトの間のバイトから成ります。"
    },
    {
      "indent": 3,
      "text": "For more details on application and lower-layer interface issues relating to partial checksumming, see [RFC3828].",
      "ja": "部分的なチェックサムに関連するアプリケーションと下層の界面の問題の詳細については、[RFC3828]を参照。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Minimum Checksum Coverage Feature",
      "section_title": true,
      "ja": "9.2.1. 最低チェックサムカバレッジ機能"
    },
    {
      "indent": 3,
      "text": "The Minimum Checksum Coverage feature lets a DCCP endpoint determine whether its peer is willing to accept packets with reduced Checksum Coverage. For example, DCCP A sends a \"Change R(Minimum Checksum Coverage, 1)\" option to DCCP B to check whether B is willing to accept packets with Checksum Coverage set to 1.",
      "ja": "最小チェックサムカバレッジ機能は、DCCP終点は、そのピアが減少チェックサム・カバレッジを有するパケットを受け入れる意志があるかどうかを決定することができます。例えば、DCCP Aは、「変更R（最小チェックサム・カバレッジ、1）」Bチェックサムカバレッジを1に設定したパケットを受け入れるかどうかをチェックするDCCP Bにオプションを送ります。"
    },
    {
      "indent": 3,
      "text": "Minimum Checksum Coverage has feature number 8 and is server-priority. It takes one-byte integer values between 0 and 15; values of 16 or more are reserved. Minimum Checksum Coverage/B reflects values of Checksum Coverage that DCCP B finds unacceptable. Say that the value of Minimum Checksum Coverage/B is MinCsCov. Then:",
      "ja": "最低チェックサムカバー範囲は、機能番号8を持っていると、サーバーの優先順位です。これは、0と15との間に1バイトの整数値をとります。 16以上の値が予約されています。最小のチェックサム・カバレッジ/ BはDCCP Bが容認できない見つけたチェックサム・カバレッジの値を反映しています。最小のチェックサム・カバレッジ/ Bの値がMinCsCovであると言います。その後："
    },
    {
      "indent": 3,
      "text": "o If MinCsCov = 0, then DCCP B only finds packets with CsCov = 0 acceptable.",
      "ja": "O MinCsCov = 0の場合、DCCP Bのみ許容されるCsCov = 0のパケットを発見します。"
    },
    {
      "indent": 3,
      "text": "o If MinCsCov > 0, then DCCP B additionally finds packets with CsCov >= MinCsCov acceptable.",
      "ja": "O MinCsCov> 0の場合、DCCP BはさらにCsCov> = MinCsCovで許容されるパケットを見つけます。"
    },
    {
      "indent": 3,
      "text": "DCCP B MAY refuse to process application data from packets with unacceptable Checksum Coverage. Such packets SHOULD be reported using Data Dropped options (Section 11.7) with Drop Code 0, Protocol Constraints. New connections start with Minimum Checksum Coverage 0 for both endpoints.",
      "ja": "DCCP Bが容認できないチェックサムカバー範囲を持つパケットからアプリケーションデータを処理するために拒否することができます。このようなパケットは、データを使用して報告されるべきでドロップコード0、プロトコルの制約とオプション（11.7節）を落としました。新しい接続は両方の終点の最小チェックサムカバー範囲0から始まります。"
    },
    {
      "indent": 0,
      "text": "9.3. Data Checksum Option",
      "section_title": true,
      "ja": "9.3. データチェックサム・オプション"
    },
    {
      "indent": 3,
      "text": "The Data Checksum option holds a 32-bit CRC-32c cyclic redundancy-check code of a DCCP packet's application data.",
      "ja": "データチェックサムオプションはDCCPパケットのアプリケーションデータの32ビットのCRC-32C巡回冗長検査符号を保持しています。"
    },
    {
      "indent": 3,
      "text": "+--------+--------+--------+--------+--------+--------+\n|00101100|00000110|              CRC-32c              |\n+--------+--------+--------+--------+--------+--------+\n Type=44  Length=6",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sending DCCP computes the CRC of the bytes comprising the application data area and stores it in the option data. The CRC-32c algorithm used for Data Checksum is the same as that used for SCTP [RFC3309]; note that the CRC-32c of zero bytes of data equals zero. The DCCP header checksum will cover the Data Checksum option, so the data checksum must be computed before the header checksum.",
      "ja": "送信DCCPは、アプリケーションデータ領域及びオプションデータに格納それを含むバイトのCRCを計算します。データチェックサムに使用されるCRC-32CアルゴリズムはSCTP [RFC3309]のために用いたものと同じです。データのゼロバイトのCRC-32cはゼロに等しいことに注意してください。データチェックサムは、ヘッダチェックサムの前に計算されなければならないので、DCCPヘッダーチェックサムは、データチェックサムオプションをカバーします。"
    },
    {
      "indent": 3,
      "text": "A DCCP endpoint receiving a packet with a Data Checksum option either MUST or MAY check the Data Checksum; the choice depends on the value of the Check Data Checksum feature described below. If it checks the checksum, it computes the received application data's CRC-32c using the same algorithm as the sender and compares the result with the Data Checksum value. If the CRCs differ, the endpoint reacts in one of two ways:",
      "ja": "DCCP終点データチェックサムのいずれかのオプションMUSTでパケットを受信したり、データのチェックサムを確認すること。選択は下記のチェックデータのチェックサム機能の値に依存します。それはチェックサムをチェックした場合は、送信者と同じアルゴリズムを使用して、受信したアプリケーションデータのCRC-32Cを計​​算し、データチェックサム値と結果を比較します。 CRCが異なる場合、エンドポイントは2つの方法のいずれかで反応します："
    },
    {
      "indent": 3,
      "text": "o The receiving application may have requested delivery of known-corrupt data via some optional API. In this case, the packet's data MUST be delivered to the application, with a note that it is known to be corrupt. Furthermore, the receiving endpoint MUST report the packet as delivered corrupt using a Data Dropped option (Drop Code 7, Delivered Corrupt).",
      "ja": "O受信側アプリケーションは、いくつかのオプションのAPIを介して既知の破損データの配信を要求してもよいです。この場合、パケットのデータは、破損していることが知られていることに注意して、アプリケーションに配信されなければなりません。 （破損を配信ドロップコード7、）データドロップオプションを使用して破損している配信としてさらに、受信側のエンドポイントはパケットを報告しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the receiving endpoint MUST drop the application data and report that data as dropped due to corruption using a Data Dropped option (Drop Code 3, Corrupt).",
      "ja": "Oそれ以外の場合は、受信エンドポイントは、アプリケーションデータを削除したデータを使用してによる破損まで低下などのデータは、（破損ドロップコード3）オプションをドロップすることを報告しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In either case, the packet is considered acknowledgeable (since its header was processed) and will therefore be acknowledged using the equivalent of Ack Vector's Received or Received ECN Marked states.",
      "ja": "いずれの場合も、パケットは（そのヘッダが処理されたため）承認可能であると考えられ、したがって、肯定応答ベクトルの受信または受信ECNマークされた状態と同等のものを使用して認識されます。"
    },
    {
      "indent": 3,
      "text": "Although Data Checksum is intended for packets containing application data, it may be included on other packets, such as DCCP-Ack, DCCP-",
      "ja": "データチェックサムは、アプリケーション・データを含むパケットのために意図されているが、そのようなDCCP-ACK、DCCP-のような他のパケットに含まれていてもよいです"
    },
    {
      "indent": 3,
      "text": "Sync, and DCCP-SyncAck. The receiver SHOULD calculate the application data area's CRC-32c on such packets, just as it does for DCCP-Data and similar packets. If the CRCs differ, the packets similarly MUST be reported using Data Dropped options (Drop Code 3), although their application data areas would not be delivered to the application in any case.",
      "ja": "同期、およびDCCP-SyncAck。受信機は、それがDCCP-データと類似したパケットの場合と同じように、そのようなパケットにアプリケーションデータ領域のCRC-32Cを計​​算する必要があります。 CRCが異なる場合、パケットは、同様のデータを使用して報告しなければならないそれらのアプリケーションデータ領域は、いずれの場合にもアプリケーションに配信されないが、オプション（ドロップコード3）を滴下しました。"
    },
    {
      "indent": 0,
      "text": "9.3.1. Check Data Checksum Feature",
      "section_title": true,
      "ja": "9.3.1. データチェックサム機能をチェック"
    },
    {
      "indent": 3,
      "text": "The Check Data Checksum feature lets a DCCP endpoint determine whether its peer will definitely check Data Checksum options. DCCP A sends a Mandatory \"Change R(Check Data Checksum, 1)\" option to DCCP B to require it to check Data Checksum options (the connection will be reset if it cannot).",
      "ja": "チェックデータのチェックサム機能は、DCCP終点はそのピアは間違いなく、データチェックサムオプションをチェックするかどうかを判断することができます。 DCCP Aは必須「チェンジR（データチェックサム、1を確認してください）」データチェックサムオプションを確認することを要求するDCCP Bにオプションを（それができない場合は、接続がリセットされます）を送信します。"
    },
    {
      "indent": 3,
      "text": "Check Data Checksum has feature number 9 and is server-priority. It takes one-byte Boolean values. DCCP B MUST check any received Data Checksum options when Check Data Checksum/B is one, although it MAY check them even when Check Data Checksum/B is zero. Values of two or more are reserved. New connections start with Check Data Checksum 0 for both endpoints.",
      "ja": "チェックデータチェックサムは、機能番号9を持ち、サーバーの優先順位です。これは、1バイトのブール値をとります。 DCCP Bは、いずれかをチェックしなければならないデータのチェックサム/ Bをチェックしたときに、データチェックサムオプションを受け取ったことは、データチェックサム/ Bがゼロで確認しても、それらをチェックするかもしれないが、1です。二つ以上の値が予約されています。新しい接続は両方の終点のためのチェックデータのチェックサム0で始まります。"
    },
    {
      "indent": 0,
      "text": "9.3.2. Checksum Usage Notes",
      "section_title": true,
      "ja": "9.3.2. チェックサムの使用上の注意"
    },
    {
      "indent": 3,
      "text": "Internet links must normally apply strong integrity checks to the packets they transmit [RFC3828, RFC3819]. This is the default case when the DCCP header's Checksum Coverage value equals zero (full coverage). However, the DCCP Checksum Coverage value might not be zero. By setting partial Checksum Coverage, the application indicates that it can tolerate corruption in the unprotected part of the application data. Recognizing this, link layers may reduce error detection and/or correction strength when transmitting this unprotected part. This, in turn, can significantly increase the likelihood of the endpoint's receiving corrupt data; Data Checksum lets the receiver detect that corruption with very high probability.",
      "ja": "インターネットリンクは、通常、彼らは[RFC3828、RFC3819]送信パケットに強い整合性チェックを適用する必要があります。 DCCPヘッダーのチェックサム・カバレッジ値がゼロ（完全なカバレッジ）に等しいとき、これは、デフォルトのケースです。しかし、DCCPチェックサムカバー範囲の値がゼロではないかもしれません。部分的なチェックサム適用範囲を設定することにより、アプリケーションは、アプリケーションデータの保護されていない部分の破損に耐えることができることを示しています。この保護されていない部分を送信する場合、これを認識し、リンク層は、エラー検出及び/又は補正強度を低減することができます。これは、順番に、大幅にエンドポイントの受信データが破損する可能性を高めることができます。データチェックサムは、受信機が非常に高い確率でその破損を検出することができます。"
    },
    {
      "indent": 0,
      "text": "10. Congestion Control",
      "section_title": true,
      "ja": "10.輻輳制御"
    },
    {
      "indent": 3,
      "text": "Each congestion control mechanism supported by DCCP is assigned a congestion control identifier, or CCID: a number from 0 to 255. During connection setup, and optionally thereafter, the endpoints negotiate their congestion control mechanisms by negotiating the values for their Congestion Control ID features. Congestion Control ID has feature number 1. The CCID/A value equals the CCID in use for the A-to-B half-connection. DCCP B sends a \"Change R(CCID, K)\" option to ask DCCP A to use CCID K for its data packets.",
      "ja": "接続のセットアップ時に0〜255の数、及び必要に応じてその後、エンドポイントは、その輻輳制御ID機能の値を交渉することによって、それらの輻輳制御機構をネゴシエート：DCCPによってサポートされる各輻輳制御機構は、輻輳制御識別子、またはCCIDが割り当てられます。輻輳制御IDは、機能番号1 CCID / Aの値はA対B半接続のための使用においてCCIDに等しいを有しています。 DCCP Bは、そのデータパケットのためにCCID Kを使用するようにDCCP Aを依頼する \"の変更R（CCID、K）\" オプションを送ります。"
    },
    {
      "indent": 3,
      "text": "CCID is a server-priority feature, so CCID negotiation options can list multiple acceptable CCIDs, sorted in descending order of priority. For example, the option \"Change R(CCID, 2 3 4)\" asks the receiver to use CCID 2 for its packets, although CCIDs 3 and 4 are also acceptable. (This corresponds to the bytes \"35, 6, 1, 2, 3, 4\": Change R option (35), option length (6), feature ID (1), CCIDs (2, 3, 4).) Similarly, \"Confirm L(CCID, 2, 2 3 4)\" tells the receiver that the sender is using CCID 2 for its packets, but that CCIDs 3 and 4 might also be acceptable.",
      "ja": "CCID交渉オプションは、優先度の高い順にソート複数の許容のCCIDsを、一覧表示することができますので、CCIDは、サーバー優先順位の機能です。 CCIDs 3及び4も許容可能であるが、例えば、オプション「変更R（CCID、2 3 4）」は、そのパケットのためにCCID 2を使用する受信機に要求します。 （これは、バイトに対応する \"35、6、1、2、3、4\"：変更Rオプション（35）、オプションの長さ（6）、特徴ID（1）のCCIDs（2、3、4）。）同様、「L（CCID、2、2 3 4）を確認」送信者は、そのパケットのためCCID 2を使用していることを受信機に通知し、しかしのCCIDs 3及び4も許容されるかもしれないこと。"
    },
    {
      "indent": 3,
      "text": "Currently allocated CCIDs are as follows:",
      "ja": "次のように現在割り当てられているのCCIDsは以下のとおりです。"
    },
    {
      "indent": 11,
      "text": "CCID   Meaning                      Reference\n----   -------                      ---------\n 0-1   Reserved\n  2    TCP-like Congestion Control  [RFC4341]\n  3    TCP-Friendly Rate Control    [RFC4342]\n4-255  Reserved",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Table 5: DCCP Congestion Control Identifiers",
      "ja": "表5：DCCP輻輳制御識別子"
    },
    {
      "indent": 3,
      "text": "New connections start with CCID 2 for both endpoints. If this is unacceptable for a DCCP endpoint, that endpoint MUST send Mandatory Change(CCID) options on its first packets.",
      "ja": "新しい接続は両方の終点のためにCCID 2で始まります。これはDCCP終点のために許容できない場合、そのエンドポイントは、その最初のパケット上で必須の変更（CCID）オプションを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "All CCIDs standardized for use with DCCP will correspond to congestion control mechanisms previously standardized by the IETF. We expect that for quite some time, all such mechanisms will be TCP friendly, but TCP-friendliness is not an explicit DCCP requirement.",
      "ja": "DCCPで使用するために標準化され、すべてのCCIDsは、以前にIETFによって標準化された輻輳制御メカニズムに対応することになります。私たちは、かなりの時間のために、すべてのそのようなメカニズムは、TCPフレンドリーになることを期待していますが、TCPフレンドリーには、明示的なDCCP要件ではありません。"
    },
    {
      "indent": 3,
      "text": "A DCCP implementation intended for general use, such as an implementation in a general-purpose operating system kernel, SHOULD implement at least CCID 2. The intent is to make CCID 2 broadly available for interoperability, although particular applications might disallow its use.",
      "ja": "このような汎用オペレーティングシステムカーネルに実装として一般的な使用のために意図DCCP実装は、少なくともCCID 2を実装する必要が意図は、特定のアプリケーションがその使用を許可しないかもしれないが、相互運用性のためにCCID 2は、広く利用できるようにすることです。"
    },
    {
      "indent": 0,
      "text": "10.1. TCP-like Congestion Control",
      "section_title": true,
      "ja": "10.1.  TCPのような輻輳制御"
    },
    {
      "indent": 3,
      "text": "CCID 2, TCP-like Congestion Control, denotes Additive Increase, Multiplicative Decrease (AIMD) congestion control with behavior modelled directly on TCP, including congestion window, slow start, timeouts, and so forth [RFC2581]. CCID 2 achieves maximum bandwidth over the long term, consistent with the use of end-to-end congestion control, but halves its congestion window in response to each congestion event. This leads to the abrupt rate changes typical of TCP. Applications should use CCID 2 if they prefer maximum bandwidth utilization to steadiness of rate. This is often the case for applications that are not playing their data directly to the user.",
      "ja": "CCID 2、TCPのような輻輳制御は、輻輳ウィンドウ、スロースタート、タイムアウト、等[RFC2581]を含むTCPに直接モデル化挙動を有する添加増加、乗算減少（AIMD）輻輳制御を表します。 CCID 2は、エンドツーエンドの輻輳制御の使用と一致して、長期にわたって最大帯域幅を達成するが、各輻輳イベントに応答して輻輳ウィンドウを半分。これは、TCPの典型的な突然のレート変化をもたらします。彼らは率の堅実に最大帯域幅の利用を好む場合アプリケーションは、CCID 2を使用する必要があります。これは、多くの場合、ユーザーに直接自分のデータを再生していないアプリケーションの場合です。"
    },
    {
      "indent": 3,
      "text": "For example, a hypothetical application that transferred files over DCCP, using application-level retransmissions for lost packets, would prefer CCID 2 to CCID 3. On-line games may also prefer CCID 2.",
      "ja": "例えば、失われたパケットのためのアプリケーションレベルの再送信を使用して、DCCPの上にファイルを転送する仮想的なアプリケーションは、オンラインゲームはまた、CCID 2を好むことがCCID 3にCCID 2を好むだろう。"
    },
    {
      "indent": 3,
      "text": "CCID 2 is further described in [RFC4341].",
      "ja": "CCID 2は、さらに、[RFC4341]に記載されています。"
    },
    {
      "indent": 0,
      "text": "10.2. TFRC Congestion Control",
      "section_title": true,
      "ja": "10.2.  TFRC輻輳制御"
    },
    {
      "indent": 3,
      "text": "CCID 3 denotes TCP-Friendly Rate Control (TFRC), an equation-based rate-controlled congestion control mechanism. TFRC is designed to be reasonably fair when competing for bandwidth with TCP-like flows, where a flow is \"reasonably fair\" if its sending rate is generally within a factor of two of the sending rate of a TCP flow under the same conditions. However, TFRC has a much lower variation of throughput over time compared with TCP, which makes CCID 3 more suitable than CCID 2 for applications such as streaming media where a relatively smooth sending rate is important.",
      "ja": "CCID 3は、TCPフレンドリーレート制御（TFRC）、方程式ベースのレート制御輻輳制御機構です。 TFRCは、その送信レートが同じ条件の下でTCPフローの送信レートの2倍以内であれば、一般的にフローが「合理的公正」である場合には、TCPのようなフローに帯域幅を競合するとき、合理的に公平であるように設計されています。しかし、TFRCは、比較的滑らかな送信速度が重要であるストリーミングメディアなどのアプリケーションのためにCCID 2よりCCID 3がより適してTCPと比べ経時スループットのはるかに低い変動を有します。"
    },
    {
      "indent": 3,
      "text": "CCID 3 is further described in [RFC4342]. The TFRC congestion control algorithms were initially described in [RFC3448].",
      "ja": "CCID 3は、[RFC4342]に記載されています。 TFRC輻輳制御アルゴリズムは、最初に[RFC3448]で説明しました。"
    },
    {
      "indent": 0,
      "text": "10.3. CCID-Specific Options, Features, and Reset Codes",
      "section_title": true,
      "ja": "10.3.  CCID特有のオプション、機能、およびコードをリセット"
    },
    {
      "indent": 3,
      "text": "Half of the option types, feature numbers, and Reset Codes are reserved for CCID-specific use. CCIDs may often need new options, for communicating acknowledgement or rate information, for example; reserved option spaces let CCIDs create options at will without polluting the global option space. Option 128 might have different meanings on a half-connection using CCID 4 and a half-connection using CCID 8. CCID-specific options and features will never conflict with global options and features introduced by later versions of this specification.",
      "ja": "オプションの種類の半分、機能番号、およびコードをリセットは、CCID特有の使用のために予約されています。 CCIDsは、多くの場合、例えば、承認またはレート情報を通信するための、新しいオプションが必要な場合があります。予約オプションスペースはのCCIDsがグローバルオプション空間を汚染することなく、意志のオプションを作成してみましょう。オプション128は、CCID 4使って半接続、この仕様の後のバージョンで導入された世界的なオプションと機能と競合することはありませんCCID 8 CCID特有のオプションおよび機能を使用して、半接続で異なる意味を持っているかもしれません。"
    },
    {
      "indent": 3,
      "text": "Any packet may contain information meant for either half-connection, so CCID-specific option types, feature numbers, and Reset Codes explicitly signal the half-connection to which they apply.",
      "ja": "CCID特有のオプションの種類、機能番号、およびコードをリセットを明示的に彼らが適用される半接続を知らせるように、任意のパケットは、半接続のいずれかのために意味の情報が含まれていてもよいです。"
    },
    {
      "indent": 3,
      "text": "o Option numbers 128 through 191 are for options sent from the HC-Sender to the HC-Receiver; option numbers 192 through 255 are for options sent from the HC-Receiver to the HC-Sender.",
      "ja": "オプション番号128 O 191を介してHC-ReceiverにHC-送信者から送られたオプションのためのものです。オプション番号192〜255はHC-SenderへのHC-レシーバから送信されたオプションのためのものです。"
    },
    {
      "indent": 3,
      "text": "o Reset Codes 128 through 191 indicate that the HC-Sender reset the connection (most likely because of some problem with acknowledgements sent by the HC-Receiver). Reset Codes 192 through 255 indicate that the HC-Receiver reset the connection (most likely because of some problem with data packets sent by the HC-Sender).",
      "ja": "O 191を通じてコード128をリセットHC-Senderが（理由はHC-Receiverが送られた確認応答といくつかの問題の最も可能性の高い）接続をリセットすることを示しています。リセットコードは255 192は、HC-レシーバが（理由はHC-送信者によって送信されたデータパケットを持ついくつかの問題の最も可能性が高い）接続をリセットすることを示しています。"
    },
    {
      "indent": 3,
      "text": "o Finally, feature numbers 128 through 191 are used for features located at the HC-Sender; feature numbers 192 through 255 are for features located at the HC-Receiver. Since Change L and Confirm L options for a feature are sent by the feature location, we know that any Change L(128) option was sent by the HC-Sender, while any Change L(192) option was sent by the HC-Receiver. Similarly, Change R(128) options are sent by the HC-Receiver, while Change R(192) options are sent by the HC-Sender.",
      "ja": "O最後に、機能番号128 191を介しては、HC-センダに位置する機能のために使用されます。 255 192機能番号は、HC-レシーバに位置機能のためのものです。機能の変更LおよびConfirm Lオプションは特徴位置によって送信されますので任意の変更Lは、（192）オプションはHC-Receiverが送られたが、我々は、任意の変更Lは、（128）オプションはHC-送信者によって送信されたことを知っています。変更R（192）オプションはHC-送信者によって送信されつつ同様に、変更R（128）オプションは、HC-受信機によって送信されます。"
    },
    {
      "indent": 3,
      "text": "For example, consider a DCCP connection where the A-to-B half-connection uses CCID 4 and the B-to-A half-connection uses CCID 5. Here is how a sampling of CCID-specific options are assigned to half-connections.",
      "ja": "A対B半接続CCID 4を使用し、B-に半接続ここCCID 5を使用するCCID特有のオプションのサンプリングは、半接続に割り当てる方法であり、例えば、DCCP接続を検討。"
    },
    {
      "indent": 8,
      "text": "                           Relevant    Relevant\nPacket  Option             Half-conn.  CCID\n------  ------             ----------  ----\nA > B   128                  A-to-B     4\nA > B   192                  B-to-A     5\nA > B   Change L(128, ...)   A-to-B     4\nA > B   Change R(192, ...)   A-to-B     4\nA > B   Confirm L(128, ...)  A-to-B     4\nA > B   Confirm R(192, ...)  A-to-B     4\nA > B   Change R(128, ...)   B-to-A     5\nA > B   Change L(192, ...)   B-to-A     5\nA > B   Confirm R(128, ...)  B-to-A     5\nA > B   Confirm L(192, ...)  B-to-A     5\nB > A   128                  B-to-A     5\nB > A   192                  A-to-B     4\nB > A   Change L(128, ...)   B-to-A     5\nB > A   Change R(192, ...)   B-to-A     5\nB > A   Confirm L(128, ...)  B-to-A     5\nB > A   Confirm R(192, ...)  B-to-A     5\nB > A   Change R(128, ...)   A-to-B     4\nB > A   Change L(192, ...)   A-to-B     4\nB > A   Confirm R(128, ...)  A-to-B     4\nB > A   Confirm L(192, ...)  A-to-B     4",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Using CCID-specific options and feature options during a negotiation for the corresponding CCID feature is NOT RECOMMENDED, since it is difficult to predict which CCID will be in force when the option is processed. For example, if a DCCP-Request contains the option sequence \"Change L(CCID, 3), 128\", the CCID-specific option \"128\" may be processed either by CCID 3 (if the server supports CCID 3) or by the default CCID 2 (if it does not). However, it is safe to include CCID-specific options following certain Mandatory Change(CCID) options. For example, if a DCCP-Request contains the option sequence \"Mandatory, Change L(CCID, 3), 128\", then either the \"128\" option will be processed by CCID 3 or the connection will be reset.",
      "ja": "オプションが処理されるときCCIDが力になるかを予測することが困難であるため、対応するCCID機能のネゴシエーション中にCCID特有のオプションと機能オプションを使用すると、お勧めしません。 DCCP-要求はオプション配列が含まれている場合、例えば、「変更L（CCIDを、3）、128」、CCID固有のオプション「128」（サーバがCCID 3をサポートしている場合）またはCCID 3のいずれかによって処理されてもよいですデフォルトCCID 2（そうでない場合）。しかし、特定の必須の変更（CCID）オプションは以下のCCID特有のオプションが含まれるように安全です。例えば、DCCPリクエスト「は必須、変更L（CCID、3）、128は」オプション配列は、いずれかの「128」オプションはCCID 3によって処理されるか、または接続がリセットされますが含まれている場合。"
    },
    {
      "indent": 3,
      "text": "Servers that do not implement the default CCID 2 might nevertheless receive CCID 2-specific options on a DCCP-Request packet. (Such a server MUST send Mandatory Change(CCID) options on its DCCP-Response, so CCID-specific options on any other packet won't refer to CCID 2.) The server MUST treat such options as non-understood. Thus, it will reset the connection on encountering a Mandatory CCID-specific option or feature negotiation request, send an empty Confirm for a non-Mandatory Change option for a CCID-specific feature, and ignore other CCID-specific options.",
      "ja": "CCID 2デフォルトを実装していないサーバは、それにもかかわらず、DCCP-RequestパケットにCCID 2固有のオプションを受け取ることがあります。非分かるように、サーバーは、そのようなオプションを扱わなければなりません（他のパケットにCCID特有のオプションは、CCID 2を参照していますので、そのようなサーバは、そのDCCP-応答に必須の変更（CCID）オプションを送らなければなりません）。したがって、それは、必須CCID特有のオプションや機能交渉要求に遭遇した上で接続をリセットCCID特有の機能の非必須の変更オプションの空の確認を送信し、他のCCID特有のオプションを無視します。"
    },
    {
      "indent": 0,
      "text": "10.4. CCID Profile Requirements",
      "section_title": true,
      "ja": "10.4.  CCIDプロフィールの要件"
    },
    {
      "indent": 3,
      "text": "Each CCID Profile document MUST address at least the following requirements:",
      "ja": "各CCIDプロフィール文書には、少なくとも以下の要件に対処しなければなりません："
    },
    {
      "indent": 3,
      "text": "o The profile MUST include the name and number of the CCID being described.",
      "ja": "プロファイルoを記載されているCCIDの名前と番号を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The profile MUST describe the conditions in which it is likely to be useful. Often the best way to do this is by comparison to existing CCIDs.",
      "ja": "Oプロファイルは、有用である可能性が高いである状態を説明しなければなりません。多くの場合、これを行うための最善の方法は、既存のCCIDsとの比較です。"
    },
    {
      "indent": 3,
      "text": "o The profile MUST list and describe any CCID-specific options, features, and Reset Codes and SHOULD list those general options and features described in this document that are especially relevant to the CCID.",
      "ja": "プロファイルMUSTリストoおよび任意CCID特有のオプション、機能について説明し、コードをリセットし、CCIDに特に関連するこの文書に記載されているものの一般的なオプションと機能をリストする必要があります。"
    },
    {
      "indent": 3,
      "text": "o Any newly defined acknowledgement mechanism MUST include a way to transmit ECN Nonce Echoes back to the sender.",
      "ja": "O新しく定義された確認応答機構は、送信者の電子証券取引ネットワークNonceのエコーを送信する方法を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The profile MUST describe the format of data packets, including any options that should be included and the setting of the CCval header field.",
      "ja": "Oプロファイルが含まれるべきである任意のオプションとCCvalヘッダフィールドの設定を含む、データパケットのフォーマットを記述しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The profile MUST describe the format of acknowledgement packets, including any options that should be included.",
      "ja": "Oプロファイルが含まれるべきである任意のオプションを含む肯定応答パケットのフォーマットを記述しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The profile MUST define how data packets are congestion controlled. This includes responses to congestion events, to idle and application-limited periods, and to the DCCP Data Dropped and Slow Receiver options. CCIDs that implement per-packet congestion control SHOULD discuss how packet size is factored in to congestion control decisions.",
      "ja": "Oプロファイルは、データパケットが輻輳制御方法を定義しなければなりません。これは、渋滞のイベントへの応答、アイドル状態にすると、アプリケーションが制限された期間を含み、およびDCCPデータに低下し、スローレシーバーオプション。パケットごとの輻輳制御を実装するのCCIDsは、パケットサイズが輻輳制御の決定に加味される方法を議論する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The profile MUST specify when acknowledgement packets are generated and how they are congestion controlled.",
      "ja": "確認応答パケットが生成されるとき、プロファイルは指定しなければならないOおよびそれらがどのように輻輳制御されています。"
    },
    {
      "indent": 3,
      "text": "o The profile MUST define when a sender using the CCID is considered quiescent.",
      "ja": "CCIDを使用して、送信者が静止考慮すると、Oプロファイルが定義しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The profile MUST say whether its CCID's acknowledgements ever need to be acknowledged and, if so, how often.",
      "ja": "Oプロファイルは、そのCCIDの謝辞が今までそうであれば、どのくらいの頻度、承認される必要があるかどうか言わなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.5. Congestion State",
      "section_title": true,
      "ja": "10.5. 輻輳状態"
    },
    {
      "indent": 3,
      "text": "Most congestion control algorithms depend on past history to determine the current allowed sending rate. In CCID 2, this congestion state includes a congestion window and a measurement of the number of packets outstanding in the network; in CCID 3, it includes the lengths of recent loss intervals. Both CCIDs use an estimate of the round-trip time. Congestion state depends on the network path and is invalidated by path changes. Therefore, DCCP senders and receivers SHOULD reset their congestion state -- essentially restarting congestion control from \"slow start\" or equivalent -- on significant changes in the end-to-end path. For example, an endpoint that sends or receives a Mobile IPv6 Binding Update message [RFC3775] SHOULD reset its congestion state for any corresponding DCCP connections.",
      "ja": "ほとんどの輻輳制御アルゴリズムは、現在許可され、送信レートを決定するために過去の歴史に依存しています。 CCID 2において、この輻輳状態は、輻輳ウィンドウと、ネットワーク内の未処理パケットの数の測定を含みます。 CCID 3で、それは最近の損失間隔の長さを含んでいます。どちらのCCIDsは、ラウンドトリップ時間の推定値を使用します。輻輳状態は、ネットワーク経路に依存し、パスの変更によって無効化されます。したがって、DCCP送信側と受信側は、その輻輳状態をリセットする必要 - 本質的に「スロースタート」または同等の輻輳制御を再開 - エンドツーエンドパスの有意な変化に。例えば、モバイルIPv6バインディング更新メッセージ[RFC3775]を送信または受信したエンドポイントは、任意の対応するDCCP接続のために、その輻輳状態をリセットする必要があります。"
    },
    {
      "indent": 3,
      "text": "A DCCP implementation MAY also reset its congestion state when a CCID changes (that is, when a negotiation for the CCID feature completes successfully and the new feature value differs from the old value). Thus, a connection in a heavily congested environment might evade end-to-end congestion control by frequently renegotiating a CCID, just as it could evade end-to-end congestion control by opening new connections for the same session. This behavior is prohibited. To prevent it, DCCP implementations MAY limit the rate at which CCID can be changed -- for instance, by refusing to change a CCID feature value more than once per minute.",
      "ja": "DCCPの実装はまた、その輻輳状態をリセットされる場合がありCCIDの変更（CCID機能のネゴシエーションが正常に完了し、新しい機能の値が古い値と異なるときには、あります）。このように、非常に輻輳環境での接続は、同じセッションのために新しい接続を開くことによって、エンドツーエンドの輻輳制御を回避することができ同じように、頻繁にCCIDを再交渉することにより、エンドツーエンドの輻輳制御を回避することがあります。この動作は禁止されています。それを防ぐために、DCCP実装は、CCIDを変えることができる速度を制限するかもしれない - 例えば、1分に1回以上CCIDの特徴量を変更することを拒否することによって。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "ja": "11.謝辞"
    },
    {
      "indent": 3,
      "text": "Congestion control requires that receivers transmit information about packet losses and ECN marks to senders. DCCP receivers MUST report all congestion they see, as defined by the relevant CCID profile. Each CCID says when acknowledgements should be sent, what options they must use, and so on. DCCP acknowledgements are congestion controlled, although it is not required that the acknowledgement stream be more than very roughly TCP friendly; each CCID defines how acknowledgements are congestion controlled.",
      "ja": "輻輳制御は、受信機が送信者にパケットロスやECNマークに関する情報を送信することが必要です。関連CCIDプロファイルで定義されたDCCP受信機は、彼らが見るすべての混雑を報告しなければなりません。各CCIDは、確認応答を送信する必要がある場合、どのようなオプション彼らはように使用し、しなければならないと言います。承認の流れが非常に大まかTCPフレンドリー以上である必要はないが、DCCPの承認は、輻輳制御されています。各CCIDは、確認応答が輻輳を制御する方法を定義します。"
    },
    {
      "indent": 3,
      "text": "Most acknowledgements use DCCP options. For example, on a half-connection with CCID 2 (TCP-like), the receiver reports acknowledgement information using the Ack Vector option. This section describes common acknowledgement options and shows how acks using those options will commonly work. Full descriptions of the ack mechanisms used for each CCID are laid out in the CCID profile specifications.",
      "ja": "ほとんどの承認はDCCPオプションを使用しています。例えば、CCID 2（TCPのような）との半接続で、受信機は、ACKベクトルオプションを使用して送達確認情報をレポートします。このセクションでは、一般的な確認応答オプションについて説明し、それらのオプションを使用してACKが、一般的に動作する方法を示しています。各CCIDに使用されるACKメカニズムの完全な説明はCCIDプロフィール仕様に配置されています。"
    },
    {
      "indent": 3,
      "text": "Acknowledgement options, such as Ack Vector, depend on the DCCP Acknowledgement Number and are thus only allowed on packet types that carry that number. Acknowledgement options received on other packet types, namely DCCP-Request and DCCP-Data, MUST be ignored. Detailed acknowledgement options are not necessarily required on every packet that carries an Acknowledgement Number, however.",
      "ja": "そのような肯定応答ベクトルとして肯定応答オプションは、DCCP確認応答数に依存し、したがってのみその数を運ぶパケットタイプで許可されています。他のパケットタイプ、すなわち、DCCP-要求とDCCP-Dataを受信確認応答のオプションは、無視しなければなりません。詳細な確認応答オプションは、必ずしもしかし、確認応答番号を運ぶすべてのパケットには必要ありません。"
    },
    {
      "indent": 0,
      "text": "11.1. Acks of Acks and Unidirectional Connections",
      "section_title": true,
      "ja": "11.1.  ACKおよび単方向接続のACKを"
    },
    {
      "indent": 3,
      "text": "DCCP was designed to work well for both bidirectional and unidirectional flows of data, and for connections that transition between these states. However, acknowledgements required for a unidirectional connection are very different from those required for a bidirectional connection. In particular, unidirectional connections need to worry about acks of acks.",
      "ja": "DCCPはデータの双方向と単方向フローの両方のための、および、これらの状態間の遷移の接続のために働くように設計されました。しかし、一方向の接続に必要な確認応答が双方向の接続に必要なものとは非常に異なっています。具体的には、一方向の接続は、ACKのACKを心配する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ack-of-acks problem arises because some acknowledgement mechanisms are reliable. For example, an HC-Receiver using CCID 2, TCP-like Congestion Control, sends Ack Vectors containing completely reliable acknowledgement information. The HC-Sender should occasionally inform the HC-Receiver that it has received an ack. If it did not, the HC-Receiver might resend complete Ack Vector information, going back to the start of the connection, with every DCCP-Ack packet! However, note that acks-of-acks need not be reliable themselves: when an ack-of-acks is lost, the HC-Receiver will simply maintain, and periodically retransmit, old acknowledgement-related state for a little longer. Therefore, there is no need for acks-of-acks-of-acks.",
      "ja": "いくつかの承認メカニズムが信頼性があるため、ACK-の-ACKの問題が発生します。例えば、CCID 2、TCPのような輻輳制御を使用して、HC-Receiverは、完全に信頼できる送達確認情報を含む肯定応答ベクトルを送信します。 HC-送信者は時折、それはACKを受信したことをHC-Receiverを通知する必要があります。それがなかった場合は、HC-レシーバは、すべてのDCCP-Ackパケットで、接続の開始に戻って、完全なのAckベクトル情報を再送するかもしれません！ ACK-の-のACKが失われたとき、HC-レシーバは、単に少し長く維持し、定期的に再送信し、古い承認関連の状態になります。しかし、それはACKを-の-ACKが自分自身の信頼性である必要はない注意してください。したがって、ACKを-の-のACK-の-ACKのための必要はありません。"
    },
    {
      "indent": 3,
      "text": "When communication is bidirectional, any required acks-of-acks are automatically contained in normal acknowledgements for data packets. On a unidirectional connection, however, the receiver DCCP sends no data, so the sender would not normally send acknowledgements. Therefore, the CCID in force on that half-connection must explicitly say whether, when, and how the HC-Sender should generate acks-of-acks.",
      "ja": "通信が双方向である場合、必要なのACK-ACKのは、自動的にデータ・パケットの通常肯定応答に含まれています。一方向の接続では、しかし、受信機DCCPはデータを送信しないので、送信者は、通常、確認応答を送信しません。したがって、その半分接続で力のCCIDは、明示的にHC-SenderはACKの-の-ACKを生成するかどうか、いつ、どのように言わなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, consider a bidirectional connection where both half-connections use the same CCID (either 2 or 3), and where DCCP B goes \"quiescent\". This means that the connection becomes unidirectional:",
      "ja": "例えば、半接続の両方が同じCCID（2または3）を使用した双方向の接続を考慮し、ここで、DCCP Bは、「静止」になります。これは、接続が単方向になっていることを意味します。"
    },
    {
      "indent": 3,
      "text": "DCCP B stops sending data and sends only DCCP-Ack packets to DCCP A. In CCID 2, TCP-like Congestion Control, DCCP B uses Ack Vector to reliably communicate which packets it has received. As described above, DCCP A must occasionally acknowledge a pure acknowledgement from DCCP B so that B can free old Ack Vector state. For instance, A might send a DCCP-DataAck packet instead of DCCP-Data every now and then. In CCID 3, however, acknowledgement state is generally bounded, so A does not need to acknowledge B's acknowledgements.",
      "ja": "DCCP Bはデータ送信を停止し、CCID 2でDCCP AにのみDCCP-ACKパケットを送信し、TCPのような輻輳制御は、DCCP Bは確実それが受信したパケットた通信にACKベクトルを使用します。前述したようにBが古いのAckベクトル状態を解放することができるように、DCCP Aは時折DCCP Bから純粋な承認を確認する必要があります。例えば、Aは、すべての今して代わりにDCCP-データのDCCP-DataAckパケットを送信することがあります。 CCID 3では、しかし、確認応答状態は、一般的に囲まれているので、AはBの確認応答を確認する必要はありません。"
    },
    {
      "indent": 3,
      "text": "When communication is unidirectional, a single CCID -- in the example, the A-to-B CCID -- controls both DCCPs' acknowledgements, in terms of their content, their frequency, and so forth. For bidirectional connections, the A-to-B CCID governs DCCP B's acknowledgements (including its acks of DCCP A's acks) and the B-to-A CCID governs DCCP A's acknowledgements.",
      "ja": "通信が一方向である、単一CCID  - 例では、A対B CCID  - などのコントロールの両方DCCPs'肯定応答、それらの内容の点で、それらの周波数、および。双方向接続のために、A対B CCIDは（DCCP AのACKのそのACKを含む）DCCP Bの確認応答を支配し、BツーCCIDはDCCP Aの確認応答を支配します。"
    },
    {
      "indent": 3,
      "text": "DCCP A switches its ack pattern from bidirectional to unidirectional when it notices that DCCP B has gone quiescent. It switches from unidirectional to bidirectional when it must acknowledge even a single DCCP-Data or DCCP-DataAck packet from DCCP B.",
      "ja": "DCCP Aは、DCCP Bが休止になったことに気づくときに一方向で双方向からのACKパターンを切り替えます。それはDCCP Bから1つでもDCCP-データやDCCP-DataAckパケットを確認しなければならない場合には、単方向から双方向に切り替え"
    },
    {
      "indent": 3,
      "text": "Each CCID defines how to detect quiescence on that CCID, and how that CCID handles acks-of-acks on unidirectional connections. The B-to-A CCID defines when DCCP B has gone quiescent. Usually, this happens when a period has passed without B sending any data packets; in CCID 2, for example, this period is the maximum of 0.2 seconds and two round-trip times. The A-to-B CCID defines how DCCP A handles acks-of-acks once DCCP B has gone quiescent.",
      "ja": "各CCIDは、CCIDに休止を検出する方法を定義し、そのCCIDは一方向の接続でのACK-の-ACKをどのように処理しますか。 DCCP Bが休止になったときにBツーCCIDを定義します。期間はBは、任意のデータ・パケットを送信せずに経過したとき通常、これは起こります。 CCID 2において、例えば、この期間は0.2秒と2往復時間の最大値です。 A・ツー・B CCIDはDCCP Bが静止行った後DCCP AはACKを-の-ACKをどのように処理するかを定義します。"
    },
    {
      "indent": 0,
      "text": "11.2. Ack Piggybacking",
      "section_title": true,
      "ja": "11.2.  Ackをピギーバック"
    },
    {
      "indent": 3,
      "text": "Acknowledgements of A-to-B data MAY be piggybacked on data sent by DCCP B, as long as that does not delay the acknowledgement longer than the A-to-B CCID would find acceptable. However, data acknowledgements often require more than 4 bytes to express. A large set of acknowledgements prepended to a large data packet might exceed the allowed maximum packet size. In this case, DCCP B SHOULD send separate DCCP-Data and DCCP-Ack packets, or wait, but not too long, for a smaller datagram.",
      "ja": "A-に-Bデータの謝辞は限りそれは長いA-に-B CCIDが許容見つけることよりも、確認応答を遅らせることはありませんので、DCCP Bによって送信されたデータにピギーバックされるかもしれません。しかし、データの確認応答は、多くの場合、表現するために4バイト以上が必要です。大きなデータパケットの前に付加肯定応答の大規模なセットは、許容される最大パケットサイズを超える場合があります。この場合、DCCP Bは小さなデータグラムのために、長すぎる別のDCCP-データとDCCP-Ackのパケットを送信し、または待って、しかしべきではありません。"
    },
    {
      "indent": 3,
      "text": "Piggybacking is particularly common at DCCP A when the B-to-A half-connection is quiescent -- that is, when DCCP A is just acknowledging DCCP B's acknowledgements. There are three reasons to acknowledge DCCP B's acknowledgements: to allow DCCP B to free up information about previously acknowledged data packets from A; to shrink the size of future acknowledgements; and to manipulate the rate at which future acknowledgements are sent. Since these are secondary concerns, DCCP A can generally afford to wait indefinitely for a data packet to piggyback its acknowledgement onto; if DCCP B wants to elicit an acknowledgement, it can send a DCCP-Sync.",
      "ja": "つまり、DCCP AはちょうどDCCP Bの確認応答を認めているとき -  B-に半接続が静止しているとき、便乗はDCCP Aで特に一般的です。 DCCP Bの確認応答を確認するには、3つの理由があります：DCCP BはAからの応答済みのデータパケットに関する情報を解放できるようにするには、将来の確認応答のサイズを縮小します。そして将来の確認応答が送信されるレートを操作します。これらは、二次問題であるので、DCCP Aは、一般に、その確認応答をピギーバックするためのデータパケットを無期限に待機する余裕ができます。 DCCP Bは、確認応答を惹起したい場合、それはDCCP-Syncを送信することができます。"
    },
    {
      "indent": 3,
      "text": "Any restrictions on ack piggybacking are described in the relevant CCID's profile.",
      "ja": "ACKのピギーバック上の任意の制限は、関連CCIDのプロフィールに記載されています。"
    },
    {
      "indent": 0,
      "text": "11.3. Ack Ratio Feature",
      "section_title": true,
      "ja": "11.3.  Ack比フィーチャ"
    },
    {
      "indent": 3,
      "text": "The Ack Ratio feature lets HC-Senders influence the rate at which HC-Receivers generate DCCP-Ack packets, thus controlling reverse-path congestion. This differs from TCP, which presently has no congestion control for pure acknowledgement traffic. Ack Ratio reverse-path congestion control does not try to be TCP friendly. It just tries to avoid congestion collapse, and to be somewhat better than TCP in the presence of a high packet loss or mark rate on the reverse path.",
      "ja": "Ack比フィーチャは、HC-送信者は、このようにリバースパス輻輳を制御する、HC-受信機がDCCP-ACKパケットを生成する速度に影響を与えることができます。これは現在、純粋な承認トラフィックの輻輳制御を持っていないTCPとは異なります。 Ack比リバースパス輻輳制御はTCPフレンドリーになろうとしません。それはちょうど混雑崩壊を避けるために、高いパケット損失の存在下でのTCPよりも幾分良好であるか、または逆の経路上の率をマークしようとします。"
    },
    {
      "indent": 3,
      "text": "Ack Ratio applies to CCIDs whose HC-Receivers clock acknowledgements off the receipt of data packets. The value of Ack Ratio/A equals the rough ratio of data packets sent by DCCP A to DCCP-Ack packets sent by DCCP B. Higher Ack Ratios correspond to lower DCCP-Ack rates; the sender raises Ack Ratio when the reverse path is congested and lowers Ack Ratio when it is not. Each CCID profile defines how it controls congestion on the acknowledgement path, and, particularly, whether Ack Ratio is used. CCID 2, for example, uses Ack Ratio for acknowledgement congestion control, but CCID 3 does not. However, each Ack Ratio feature has a value whether or not that value is used by the relevant CCID.",
      "ja": "Ack比は、そのHC-レシーバのクロックデータパケットの受信をオフに謝辞のCCIDsに適用されます。肯定応答率/ Aの値がDCCP-Ackの速度を低下させるために対応するDCCP B.高いのAck比によって送信されたDCCP-ACKパケットにDCCP Aによって送られたデータパケットの大まかな比に等しいです。送信者は、リバースパスが混雑しているときのAck比率を上昇させ、それがないときのAck比を低下させます。各CCIDプロフィールは、ACK比率が使用されているかどうか、特に、それは肯定応答経路上の輻輳を制御する方法を定義し、そして。 CCID 2は、例えば、確認応答輻輳制御のためのACK比を使用するが、CCID 3がありません。しかし、それぞれのAck比フィーチャは、その値が関連CCIDによって使用されているか否かの値を有します。"
    },
    {
      "indent": 3,
      "text": "Ack Ratio has feature number 5 and is non-negotiable. It takes two-byte integer values. An Ack Ratio/A value of four means that DCCP B will send at least one acknowledgement packet for every four data packets sent by DCCP A. DCCP A sends a \"Change L(Ack Ratio)\" option to notify DCCP B of its ack ratio. An Ack Ratio value of zero indicates that the relevant half-connection does not use an Ack Ratio to control its acknowledgement rate. New connections start with Ack Ratio 2 for both endpoints; this Ack Ratio results in acknowledgement behavior analogous to TCP's delayed acks.",
      "ja": "Ack比率は、フィーチャー番号5を持ち、非交渉です。これは、2バイトの整数値をとります。肯定応答率/ DCCP BはDCCP A. DCCP Aによって送られたすべての4つのデータ・パケットのための少なくとも一つの肯定応答パケットを送信する4つの手段の値は、そのACK比DCCP Bに通知するために「変更L（のAck比）」オプションを送ります。ゼロの肯定応答比の値は、関連する半接続は、その確認応答速度を制御するためのAck比を使用していないことを示しています。新しい接続は、両方のエンドポイント用のAck比2で始まります。このTCPの遅延ACKに似確認行動でのAck比結果。"
    },
    {
      "indent": 3,
      "text": "Ack Ratio should be treated as a guideline rather than a strict requirement. We intend Ack Ratio-controlled acknowledgement behavior to resemble TCP's acknowledgement behavior when there is no reverse-path congestion, and to be somewhat more conservative when there is reverse-path congestion. Following this intent is more important than implementing Ack Ratio precisely. In particular: o Receivers MAY piggyback acknowledgement information on data packets, creating DCCP-DataAck packets. The Ack Ratio does not apply to piggybacked acknowledgements. However, if the data packets are too big to carry acknowledgement information, or if the data sending rate is lower than Ack Ratio would suggest, then DCCP B SHOULD send enough pure DCCP-Ack packets to maintain the rate of one acknowledgement per Ack Ratio received data packets.",
      "ja": "ACK比はガイドラインではなく、厳密な要件として扱われるべきです。私たちは何のリバースパス輻輳がない場合TCPの確認応答動作に似ているし、逆パスを輻輳があるときやや保守的にACK比制御の確認動作を意図しています。この意図を正確に続いてのAck比を実装するよりも重要です。特に：レシーバO DCCP-DataAckパケットを作成、データパケットに関する確認情報をピギーバックするかもしれません。 Ack比は、確認応答をピギーバックには適用されません。データパケットが送達確認情報を運ぶことが大きすぎる場合は、データ送信レートがACK比率が示唆しているよりも低い場合には、あるいは、その後、DCCP Bは、受信したACK比ごとに確認応答のレートを維持するために十分な純粋なDCCP-ACKパケットを送信すべきですデータパケット。"
    },
    {
      "indent": 3,
      "text": "o Receivers MAY rate-pace their acknowledgements rather than send acknowledgements immediately upon the receipt of data packets. Receivers that rate-pace acknowledgements SHOULD pick a rate that approximates the effect of Ack Ratio and SHOULD include Elapsed Time options (Section 13.2) to help the sender calculate round-trip times.",
      "ja": "Oレシーバは、その確認応答を評価ペースではなく、データパケットの受信時にすぐに確認応答を送信することができます。レートペースの確認応答がACK比の影響を近似し、送信者が往復時間を計算するのに役立つ経過時間オプション（13.2節）を含むべきである率を選ぶべきであることをレシーバ。"
    },
    {
      "indent": 3,
      "text": "o Receivers SHOULD implement delayed acknowledgement timers like TCP's, whereby any packet's acknowledgement is delayed by at most T seconds. This delay lets the receiver collect additional packets to acknowledge and thus reduce the per-packet overhead of acknowledgements; but if T seconds have passed by and the ack is still around, it is sent out right away. The default value of T should be 0.2 seconds, as is common in TCP implementations. This may lead to sending more acknowledgement packets than Ack Ratio would suggest.",
      "ja": "OレシーバはTCPの、任意のパケットの確認応答が最もT秒で遅れで表示させるような遅延確認応答タイマを実装する必要があります。この遅延は、受信機が認めるので、確認応答のパケットごとのオーバーヘッドを減らすために、追加のパケットを収集することができます。 T秒がで合格したとACKがまだ残っている場合は、それがすぐに送信されます。 TCP実装で一般的であるようにTのデフォルト値は、0.2秒であるべきです。これは、ACK比率が示唆しているよりも多くの確認応答パケットを送信することにつながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "o Receivers SHOULD send acknowledgements immediately on receiving packets marked ECN Congestion Experienced or packets whose out-of-order sequence numbers potentially indicate loss. However, there is no need to send such immediate acknowledgements for marked packets more than once per round-trip time.",
      "ja": "Oレシーバは、パケットを受信すると、すぐに確認応答を送信すべきであるECNの輻輳に遭遇したか、そのアウトオブオーダーシーケンス番号の潜在的損失を示すパケットをマーク。しかし、ラウンドトリップ時間ごとに複数回マークされたパケットのために、このような即時の確認応答を送信する必要はありません。"
    },
    {
      "indent": 3,
      "text": "o Receivers MAY ignore Ack Ratio if they perform their own congestion control on acknowledgements. For example, a receiver that knows the loss and mark rate for its DCCP-Ack packets might maintain a TCP-friendly acknowledgement rate on its own. Such a receiver MUST either ensure that it always obtains sufficient acknowledgement loss and mark information or fall back to Ack Ratio when sufficient information is not available, as might happen during periods when the receiver is quiescent.",
      "ja": "彼らは謝辞に、独自の輻輳制御を行う場合には、O受信機は、ACK比率を無視してもよいです。例えば、そのDCCP-ACKパケットのための損失とマーク率を知っている受信機は、独自のTCPフレンドリー承認率を維持することがあります。このような受信機は、それが必ずしも十分確認の損失やマーク情報を取得していることを確認したり、受信機が静止しているときの期間中に発生する可能性があるとして、十分な情報が、利用できない場合のAck比にフォールバックする必要があります。"
    },
    {
      "indent": 0,
      "text": "11.4. Ack Vector Options",
      "section_title": true,
      "ja": "11.4.  Ackベクトルオプション"
    },
    {
      "indent": 3,
      "text": "The Ack Vector gives a run-length encoded history of data packets received at the client. Each byte of the vector gives the state of that data packet in the loss history, and the number of preceding packets with the same state. The option's data looks like this:",
      "ja": "Ack Vectorがクライアントで受信したデータパケットのランレングスエンコードされた歴史を与えます。ベクトルの各バイトは、損失の歴史の中で、そのデータパケットの状態と同じ状態を持つパケットの前の数を与えます。オプションのデータは次のようになります。"
    },
    {
      "indent": 3,
      "text": "+--------+--------+--------+--------+--------+--------\n|0010011?| Length |SSLLLLLL|SSLLLLLL|SSLLLLLL|  ...\n+--------+--------+--------+--------+--------+--------\nType=38/39         \\___________ Vector ___________...",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The two Ack Vector options (option types 38 and 39) differ only in the values they imply for ECN Nonce Echo. Section 12.2 describes this further.",
      "ja": "2つのAckベクトルオプション（オプションタイプ38及び39）のみ、彼らがECNノンスエコーを意味するものでは値が異なります。 12.2節は、これをさらに説明します。"
    },
    {
      "indent": 3,
      "text": "The vector itself consists of a series of bytes, each of whose encoding is:",
      "ja": "ベクター自体が一連のバイトで構成され、その符号化の各々は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|Sta| Run Length|\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Sta[te] occupies the most significant two bits of each byte and can have one of four values, as follows:",
      "ja": "次のようにSTA [TE]は、各バイトの最上位の2ビットを占有し、4つの値のいずれかを有することができます。"
    },
    {
      "indent": 20,
      "text": "State  Meaning\n-----  -------\n  0    Received\n  1    Received ECN Marked\n  2    Reserved\n  3    Not Yet Received",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Table 6: DCCP Ack Vector States",
      "ja": "表6：DCCPのAckベクトル州"
    },
    {
      "indent": 3,
      "text": "The term \"ECN marked\" refers to packets with ECN code point 11, CE (Congestion Experienced); packets received with this ECN code point MUST be reported using State 1, Received ECN Marked. Packets received with ECN code points 00, 01, or 10 (Non-ECT, ECT(0), or ECT(1), respectively) MUST be reported using State 0, Received.",
      "ja": "用語「ECNがマークされた」とは、ECNコードポイント11、CE（輻輳経験豊富な）を持つパケットを指します。このECNコードポイントで受信されたパケットは状態1を用いて報告されなければならない、ECNがマーク受付。 ECNコードで受信されたパケットは、00、01、または10ポイント（非ECT、ECT（0）、またはECT（1）、それぞれ）状態0、受信を使用して報告されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Run Length, the least significant six bits of each byte, specifies how many consecutive packets have the given State. Run Length zero says the corresponding State applies to one packet only; Run Length 63 says it applies to 64 consecutive packets. Run lengths of 65 or more must be encoded in multiple bytes.",
      "ja": "各バイトの最下位6ビット、長さを実行して、多くの連続したパケットが与えられた状態を持っているかを指定します。ランレングスゼロは、対応する状態は、一つのパケットのみに適用されると言います。ランレングス63は、64の連続したパケットに適用されると言います。 65以上のランレングスは、複数のバイトに符号化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The first byte in the first Ack Vector option refers to the packet indicated in the Acknowledgement Number; subsequent bytes refer to older packets. Ack Vector MUST NOT be sent on DCCP-Data and DCCP-Request packets, which lack an Acknowledgement Number, and any Ack Vector options encountered on such packets MUST be ignored.",
      "ja": "最初のAckベクトルオプションの最初のバイトは、肯定応答番号に示されたパケットを意味します。後続のバイトは、古いパケットを参照してください。 Ack VectorがDCCP-データに送信され、受信確認番号が不足しているDCCP-Requestパケット、及びそのようなパケットに発生したのAckベクトルオプションは無視されなければならないしてはなりません。"
    },
    {
      "indent": 3,
      "text": "An Ack Vector containing the decimal values 0,192,3,64,5 and for which the Acknowledgement Number is decimal 100 indicates that:",
      "ja": "小数値0,192,3,64,5かつに対する肯定応答数が100小数であるを含むのAck Vectorがことを示しています。"
    },
    {
      "indent": 6,
      "text": "Packet 100 was received (Acknowledgement Number 100, State 0, Run Length 0);",
      "ja": "パケット100は、（確認応答番号100、状態0、ランレングス0）を受けました。"
    },
    {
      "indent": 6,
      "text": "Packet 99 was lost (State 3, Run Length 0);",
      "ja": "パケット99は、（状態3、ランレングス0）を失いました。"
    },
    {
      "indent": 6,
      "text": "Packets 98, 97, 96 and 95 were received (State 0, Run Length 3);",
      "ja": "パケット98、97、96及び95は、受信した（状態0、ランレングス3）。"
    },
    {
      "indent": 6,
      "text": "Packet 94 was ECN marked (State 1, Run Length 0); and",
      "ja": "パケット94は、ECNは、（状態1、ランレングス0）をマークしました。そして"
    },
    {
      "indent": 6,
      "text": "Packets 93, 92, 91, 90, 89, and 88 were received (State 0, Run Length 5).",
      "ja": "パケット93、92、91、90、89、および88は、（状態0、ランレングス5）を受けました。"
    },
    {
      "indent": 3,
      "text": "A single Ack Vector option can acknowledge up to 16192 data packets. Should more packets need to be acknowledged than can fit in 253 bytes of Ack Vector, then multiple Ack Vector options can be sent; the second Ack Vector begins where the first left off, and so forth.",
      "ja": "単一のAckベクトルオプションは、16192個のデータパケットまで認めることができます。より多くのパケットは、ACKベクトルの253バイトに収まることができるよりも、その後、複数のACKベクトルオプションを送信することができます承認される必要がある必要があります。最初等中断、及びここ第二のAckベクトルが始まります。"
    },
    {
      "indent": 3,
      "text": "Ack Vector states are subject to two general constraints. (These principles SHOULD also be followed for other acknowledgement mechanisms; referring to Ack Vector states simplifies their explanation.)",
      "ja": "Ackベクトル状態は、二つの一般的な制約を受けています。 （これらの原理は、他の肯定応答メカニズムについて追跡されるべきであるのAckベクトルを参照すると、その説明を簡略化状態。）"
    },
    {
      "indent": 3,
      "text": "1. Packets reported as State 0 or State 1 MUST be acknowledgeable: their options have been processed by the receiving DCCP stack. Any data on the packet need not have been delivered to the receiving application; in fact, the data may have been dropped.",
      "ja": "そのオプションは受信DCCPスタックによって処理されています：1.パケットは承認可能でなければならない状態0または状態1と報告しました。パケット上のすべてのデータが受信アプリケーションに配信されている必要はありません。実際には、データが削除された可能性があります。"
    },
    {
      "indent": 3,
      "text": "2. Packets reported as State 3 MUST NOT be acknowledgeable. Feature negotiations and options on such packets MUST NOT have been processed, and the Acknowledgement Number MUST NOT correspond to such a packet.",
      "ja": "状態3は、受け付け可能にすることはできません2.パケットは報告しました。そのようなパケットの機能の交渉やオプションが処理されていてはならない、と謝辞数は、パケットに対応してはなりません。"
    },
    {
      "indent": 3,
      "text": "Packets dropped in the application's receive buffer MUST be reported as Received or Received ECN Marked (States 0 and 1), depending on their ECN state; such packets' ECN Nonces MUST be included in the Nonce Echo. The Data Dropped option informs the sender that some packets reported as received actually had their application data dropped.",
      "ja": "パケットは、彼らのECNの状態に応じて、のは、受信バッファをアプリケーションにドロップされた受信または受信ECNがマークとして報告されなければならない（米国0および1）。そのようなパケットのECNのナンスはノンスエコーに含まれなければなりません。データドロップオプションは、受け取ったと報告いくつかのパケットが実際にアプリケーションデータがドロップされていたことを送信者に通知します。"
    },
    {
      "indent": 3,
      "text": "One or more Ack Vector options that, together, report the status of a packet with a sequence number less than ISN, the initial sequence number, SHOULD be considered invalid. The receiving DCCP SHOULD either ignore the options or reset the connection with Reset Code 5, \"Option Error\". No Ack Vector option can refer to a packet that has not yet been sent, as the Acknowledgement Number checks in Section",
      "ja": "、一緒に、ISN未満のシーケンス番号、初期シーケンス番号を持つパケットの状況を報告し、無効と見なされるべきである一の以上のAckベクトルオプション。受信DCCPは、いずれかのオプションを無視するか、リセットコード5、「オプション誤り」との接続をリセットする必要があります。何のAckベクトルオプションはまだ節で承認番号をチェックして、送信されていないパケットを参照することはできません"
    },
    {
      "indent": 3,
      "text": "7.5.3 ensure, but because of attack, implementation bug, or misbehavior, an Ack Vector option can claim that a packet was received before it is actually delivered. Section 12.2 describes how this is detected and how senders should react. Packets that haven't been included in any Ack Vector option SHOULD be treated as \"not yet received\" (State 3) by the sender.",
      "ja": "7.5.3は確実に、しかしなぜなら、攻撃、実装上のバグ、または誤動作のは、ACKベクトルオプションは、それが実際に配信される前に、パケットを受信したことを主張することができます。 12.2節では、これが検出された方法と送信者が反応する方法を説明します。どんなのAckベクトルオプションには含まれていないパケットは、送信者（状態3）「まだ受け取っていない」として扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "Appendix A provides a non-normative description of the details of DCCP acknowledgement handling in the context of an abstract Ack Vector implementation.",
      "ja": "付録Aは、抽象のAckベクトルの実装のコンテキストでDCCP確認処理の詳細の非規範的な説明を提供します。"
    },
    {
      "indent": 0,
      "text": "11.4.1. Ack Vector Consistency",
      "section_title": true,
      "ja": "11.4.1.  Ackベクトル一貫性"
    },
    {
      "indent": 3,
      "text": "A DCCP sender will commonly receive multiple acknowledgements for some of its data packets. For instance, an HC-Sender might receive two DCCP-Acks with Ack Vectors, both of which contained information about sequence number 24. (Information about a sequence number is generally repeated in every ack until the HC-Sender acknowledges an ack. In this case, perhaps the HC-Receiver is sending acks faster than the HC-Sender is acknowledging them.) In a perfect world, the two Ack Vectors would always be consistent. However, there are many reasons why they might not be. For example:",
      "ja": "DCCP送信者は、一般的にそのデータパケットのいくつかのために複数の承認を受け取ります。例えば、HC-SenderはHC-SenderはACKを確認するまで、シーケンス番号に関する情報は、一般的にすべてのACKで繰り返される（シーケンス番号24についての情報が含まれて両方とも肯定応答ベクトルを有する2つのDCCP-ACKを受け取る可能性がある。この中で場合は、おそらくHC-レシーバが速くHC-Senderはそれらを認めているよりも、ACKを送信しています。）完璧な世界では、2つのAckベクターは常に一致するであろう。しかし、彼らはないかもしれない多くの理由があります。例えば："
    },
    {
      "indent": 3,
      "text": "o The HC-Receiver received packet 24 between sending its acks, so the first ack said 24 was not received (State 3) and the second said it was received or ECN marked (State 0 or 1).",
      "ja": "O HC-ReceiverはそのACKを送信間のパケット24を受信し、第1のACKが24（状態3）に受信されなかった前記第二は、それが受信されたか、ECNがマークされた前記（状態0または1）。"
    },
    {
      "indent": 3,
      "text": "o The HC-Receiver received packet 24 between sending its acks, and the network reordered the acks. In this case, the packet will appear to transition from State 0 or 1 to State 3.",
      "ja": "O HC-受信機は、そのACKを送信間のパケット24を受信し、そしてネットワークがACKを並べ替え。この場合、パケットは、状態0または1から状態3に遷移するように見えるであろう。"
    },
    {
      "indent": 3,
      "text": "o The network duplicated packet 24, and one of the duplicates was ECN marked. This might show up as a transition between States 0 and 1.",
      "ja": "Oネットワークは、パケット24を複製し、かつ重複の一つは、ECNがマークしました。これは、米国0と1の間の遷移として表示される場合があります。"
    },
    {
      "indent": 3,
      "text": "To cope with these situations, HC-Sender DCCP implementations SHOULD combine multiple received Ack Vector states according to this table:",
      "ja": "これらの状況に対処するため、複数を組み合わせるべきであるHC-送信者DCCP実装は、ACKベクトルはこのテーブルに従って述べ受けました："
    },
    {
      "indent": 22,
      "text": "         Received State\n           0   1   3\n         +---+---+---+\n       0 | 0 |0/1| 0 |\n Old     +---+---+---+\n       1 | 1 | 1 | 1 |\nState    +---+---+---+\n       3 | 0 | 1 | 3 |\n         +---+---+---+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To read the table, choose the row corresponding to the packet's old state and the column corresponding to the packet's state in the newly received Ack Vector; then read the packet's new state off the table. For an old state of 0 (received non-marked) and received state of 1 (received ECN marked), the packet's new state may be set to either 0 or 1. The HC-Sender implementation will be indifferent to ack reordering if it chooses new state 1 for that cell.",
      "ja": "テーブルを読み取るには、パケットの古い状態に対応する行と、新たに受信したACKのベクトルで、パケットの状態に対応する列を選択してください。その後、テーブルから、パケットの新しい状態を読み出します。古い状態のために0（受信した非マーク）との状態を受け取っ1（受信ECNがマーク）、パケットの新しい状態が0または1のいずれかに設定することができるHC-送信者の実装は、それが選択した場合の並べ替えACKに無関心になりますそのセルの新しい状態1。"
    },
    {
      "indent": 3,
      "text": "The HC-Receiver should collect information about received packets according to the following table:",
      "ja": "HC-Receiverは次の表に従って受信されたパケットについての情報を収集する必要があります。"
    },
    {
      "indent": 21,
      "text": "         Received Packet\n            0   1   3\n          +---+---+---+\n        0 | 0 |0/1| 0 |\nStored    +---+---+---+\n        1 |0/1| 1 | 1 |\n State    +---+---+---+\n        3 | 0 | 1 | 3 |\n          +---+---+---+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This table equals the sender's table except that, when the stored state is 1 and the received state is 0, the receiver is allowed to switch its stored state to 0.",
      "ja": "保存された状態が1で受信された状態が0である場合、このテーブルは、受信機が0に、その格納された状態を切り替えることが許可されている、ことを除いて、送信者のテーブルに等しいです。"
    },
    {
      "indent": 3,
      "text": "An HC-Sender MAY choose to throw away old information gleaned from the HC-Receiver's Ack Vectors, in which case it MUST ignore newly received acknowledgements from the HC-Receiver for those old packets. It is often kinder to save recent Ack Vector information for a while so that the HC-Sender can undo its reaction to presumed congestion when a \"lost\" packet unexpectedly shows up (the transition from State 3 to State 0).",
      "ja": "HC-送信者は、これらの古いパケット用HC-Receiverから新たに受信した確認応答を無視しなければなりません。その場合にはHC-ReceiverのAckをベクトルから集められた古い情報を、捨てるのを選ぶかもしれ。 「失われた」パケットが予期せず（状態3から状態0への移行）現れたときにHC-Senderは推定混雑への反応を元に戻すことができるようにしばらくの間、最近のAckベクトル情報を保存することが多い親切です。"
    },
    {
      "indent": 0,
      "text": "11.4.2. Ack Vector Coverage",
      "section_title": true,
      "ja": "11.4.2.  Ackベクトルカバレッジ"
    },
    {
      "indent": 3,
      "text": "We can divide the packets that have been sent from an HC-Sender to an HC-Receiver into four roughly contiguous groups. From oldest to youngest, these are:",
      "ja": "我々は、4つの概ね連続したグループにHC-ReceiverにHC-送信機から送信されたパケットを分割することができます。最年少の古いものから、これらは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Packets already acknowledged by the HC-Receiver, where the HC-Receiver knows that the HC-Sender has definitely received the acknowledgements;",
      "ja": "すでにHC-レシーバはHC-Senderが確実に確認応答を受信したことを知っているHC-レシーバによって認め1.パケット。"
    },
    {
      "indent": 3,
      "text": "2. Packets already acknowledged by the HC-Receiver, where the HC-Receiver cannot be sure that the HC-Sender has received the acknowledgements;",
      "ja": "2.パケットは、既にHC-レシーバはHC-Senderが確認応答を受信したことを確認することはできませんHC-レシーバー、によって確認します。"
    },
    {
      "indent": 3,
      "text": "3. Packets not yet acknowledged by the HC-Receiver; and",
      "section_title": true,
      "ja": "まだHC-Receiverが認められていない3.パケット。そして"
    },
    {
      "indent": 3,
      "text": "4. Packets not yet received by the HC-Receiver.",
      "section_title": true,
      "ja": "4.パケットはまだHC-レシーバで受信されません。"
    },
    {
      "indent": 3,
      "text": "The union of groups 2 and 3 is called the Acknowledgement Window. Generally, every Ack Vector generated by the HC-Receiver will cover the whole Acknowledgement Window: Ack Vector acknowledgements are cumulative. (This simplifies Ack Vector maintenance at the HC-Receiver; see Appendix A, below.) As packets are received, this window both grows on the right and shrinks on the left. It grows because there are more packets, and shrinks because the HC-Sender's Acknowledgement Numbers will acknowledge previous acknowledgements, moving packets from group 2 into group 1.",
      "ja": "グループ2と3の労働組合は、確認応答ウィンドウと呼ばれています。一般に、HC-受信機によって生成されたすべてのAckベクトル全体肯定応答ウィンドウをカバーする：肯定応答ベクトル確認応答が累積的です。 （これは、HC-受信機でのAckベクトルメンテナンスを簡素化し、以下、付録Aを参照。）パケットが受信されると、このウィンドウの両方が右側に成長し、左側に収縮します。これは、より多くのパケットがあるので成長し、HC-送信者の承認番号がグループ1にグループ2からのパケットを移動し、以前の承認を承認しますので、縮小します。"
    },
    {
      "indent": 0,
      "text": "11.5. Send Ack Vector Feature",
      "section_title": true,
      "ja": "11.5.  Ackベクトル機能を送ります"
    },
    {
      "indent": 3,
      "text": "The Send Ack Vector feature lets DCCPs negotiate whether they should use Ack Vector options to report congestion. Ack Vector provides detailed loss information and lets senders report back to their applications whether particular packets were dropped. Send Ack Vector is mandatory for some CCIDs and optional for others.",
      "ja": "送信のAckベクトル機能がDCCPsは、彼らが混雑を報告したAckベクトルオプションを使用する必要があるかどうかを交渉することができます。 Ack Vectorが、詳細な損失情報を提供し、特定のパケットが破棄されたかどうかを送信者が自分のアプリケーションに報告することができます。 Ack Vectorは他の人のためのいくつかのCCIDsとオプションのために必須である送信します。"
    },
    {
      "indent": 3,
      "text": "Send Ack Vector has feature number 6 and is server-priority. It takes one-byte Boolean values. DCCP A MUST send Ack Vector options on its acknowledgements when Send Ack Vector/A has value one, although it MAY send Ack Vector options even when Send Ack Vector/A is zero. Values of two or more are reserved. New connections start with Send Ack Vector 0 for both endpoints. DCCP B sends a \"Change R(Send Ack Vector, 1)\" option to DCCP A to ask A to send Ack Vector options as part of its acknowledgement traffic.",
      "ja": "送信のAck Vectorがフィーチャー番号6を持っていると、サーバーの優先順位です。これは、1バイトのブール値をとります。送信のAckベクトル/ Aの値が1を持っていたときに送るのAckベクトル/ Aがゼロの場合であっても、それがAckでベクトルオプションを送るかもしれないがDCCP Aは、その確認応答上でACKベクトルオプションを送らなければなりません。二つ以上の値が予約されています。新しい接続は両方の終点のための送信のAckベクトル0で始まります。 DCCP Bは、「変更R（Ackをベクトル、1を送信）」の承認トラフィックの一部としてのAckベクトルオプションを送信するように依頼するDCCP Aへのオプションを送信します。"
    },
    {
      "indent": 0,
      "text": "11.6. Slow Receiver Option",
      "section_title": true,
      "ja": "11.6. スローレシーバーオプション"
    },
    {
      "indent": 3,
      "text": "An HC-Receiver sends the Slow Receiver option to its sender to indicate that it is having trouble keeping up with the sender's data. The HC-Sender SHOULD NOT increase its sending rate for approximately one round-trip time after seeing a packet with a Slow Receiver option. After one round-trip time, the effect of Slow Receiver disappears, allowing the HC-Sender to increase its rate. Therefore, the HC-Receiver SHOULD continue to send Slow Receiver options if it needs to prevent the HC-Sender from going faster in the long term. The Slow Receiver option does not indicate congestion, and the HC-Sender need not reduce its sending rate. (If necessary, the receiver can force the sender to slow down by dropping packets, with or without Data Dropped, or by reporting false ECN marks.) APIs should let receiver applications set Slow Receiver and sending applications determine whether their receivers are Slow.",
      "ja": "HC-レシーバは、それがトラブルの送信者のデータに追いついを持っていることを示すために、その送信者にスローレシーバーオプションを送信します。 HC-送信者は、スローレシーバオプションでパケットを見た後、約1往復時間のためにその送信レートを増加させるべきではありません。 1ラウンドトリップ時間の後、スローレシーバーの効果は、HC-Senderがその速度を増加させることができ、表示されなくなります。そのため、HC-レシーバは、それが長期的に速く行くからHC-送信者を防ぐために必要がある場合にスローレシーバーオプションを送信し続けるべきです。スローレシーバーオプションは、輻輳を示すものではありません、とHC-送信者は、その送信レートを下げる必要はありません。 （必要であれば、受信機は、またはデータ、または虚偽のECNマークを報告することによってドロップせずに、パケットをドロップすることによって減速し、送信者を強制することができます。）APIは、受信機アプリケーションが遅いレシーバ設定と送信アプリケーションは受信機が低速であるかどうかを確認させてください。"
    },
    {
      "indent": 3,
      "text": "Slow Receiver is a one-byte option.",
      "ja": "スローレシーバは、1バイトのオプションです。"
    },
    {
      "indent": 3,
      "text": "+--------+\n|00000010|\n+--------+\n Type=2",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Slow Receiver does not specify why the receiver is having trouble keeping up with the sender. Possible reasons include lack of buffer space, CPU overload, and application quotas. A sending application might react to Slow Receiver by reducing its application-level sending rate, for example.",
      "ja": "受信機はトラブルの送信者に追いついを持っている理由遅いレシーバが指定されていません。考えられる理由は、バッファスペースの不足、CPUの過負荷、およびアプリケーションのクォータがあります。送信側アプリケーションは、例えば、そのアプリケーションレベル送信速度を低下させることによって受信を遅くする反応するかもしれません。"
    },
    {
      "indent": 3,
      "text": "The sending application should not react to Slow Receiver by sending more data, however. Although the optimal response to a CPU-bound receiver might be to reduce compression and send more data (a highly-compressed data format might overwhelm a slow CPU more seriously than would the higher memory requirements of a less-compressed data format), this kind of format change should be requested at the application level, not via the Slow Receiver option.",
      "ja": "送信側アプリケーションは、しかし、より多くのデータを送信することにより、レシーバを遅らせるために反応すべきではありません。 CPUバウンド受信に最適な応答は、より多くのデータを圧縮を低減し、送信するかもしれないが、このような（高圧縮データフォーマットは、より深刻な場合とあまり圧縮データフォーマットの高いメモリ要件より遅いCPUを圧倒する可能性があります）フォーマット変更のないスローレシーバーのオプションを使用して、アプリケーションレベルで要求されるべき。"
    },
    {
      "indent": 3,
      "text": "Slow Receiver implements a portion of TCP's receive window functionality.",
      "ja": "スローレシーバーは、TCPの受信ウィンドウの機能の一部を実装しています。"
    },
    {
      "indent": 0,
      "text": "11.7. Data Dropped Option",
      "section_title": true,
      "ja": "11.7. データは、オプションをドロップ"
    },
    {
      "indent": 3,
      "text": "The Data Dropped option indicates that the application data on one or more received packets did not actually reach the application. Data Dropped additionally reports why the data was dropped: perhaps the data was corrupt, or perhaps the receiver cannot keep up with the sender's current rate and the data was dropped in some receive buffer. Using Data Dropped, DCCP endpoints can discriminate between different kinds of loss; this differs from TCP, in which all loss is reported the same way.",
      "ja": "データはオプションが1つまたは複数の受信したパケットのアプリケーションデータが実際にアプリケーションに到達しなかったことを示して低下しました。おそらく、データが破損した、またはおそらく受信側は送信者の現在のレートに追いつくことができず、データがいくつかに落とされた受信バッファ：さらにドロップされたデータは、データが削除された理由を報告します。データがドロップ用いて、DCCP終点は損失の異なる種類を区別することができます。これは、すべての損失が同じように報告されているTCPとは異なります。"
    },
    {
      "indent": 3,
      "text": "Unless it is explicitly specified otherwise, DCCP congestion control mechanisms MUST react as if each Data Dropped packet was marked as ECN Congestion Experienced by the network. We intend for Data Dropped to enable research into richer congestion responses to corrupt and other endpoint-dropped packets, but DCCP CCIDs MUST react conservatively to Data Dropped until this behavior is standardized. Section 11.7.2, below, describes congestion responses for all current Drop Codes.",
      "ja": "それが明示的に指定されていない限り、各データパケットを落とした場合にネットワークが経験するECNの輻輳としてマークされていたとして、DCCP輻輳制御メカニズムが反応しなければなりません。データが破損していると、他のエンドポイント・破棄されたパケットに、より豊かな混雑応答の研究を可能にするためにドロップされたが、この動作は標準化されるまで、DCCPのCCIDsがデータに保守的に反応しなければならないドロップのために私たちは意図しています。セクション11.7.2は、以下の、現在のすべてのドロップコードのための輻輳応答を記述する。"
    },
    {
      "indent": 3,
      "text": "If a received packet's application data is dropped for one of the reasons listed below, this SHOULD be reported using a Data Dropped option. Alternatively, the receiver MAY choose to report as",
      "ja": "受信したパケットのアプリケーションデータは、下記のいずれかの理由で削除された場合、これは、データがDroppedオプションを使用して報告する必要があります。また、受信機は、として報告することを選ぶかもしれ"
    },
    {
      "indent": 3,
      "text": "\"received\" only those packets whose data were not dropped, subject to the constraint that packets not reported as received MUST NOT have had their options processed.",
      "ja": "受け取ったとして報告されなかったパケットの制約を受け、データがドロップされなかったパケットのみが、そのオプションを処理していた持ってはいけません「受信」。"
    },
    {
      "indent": 3,
      "text": "The option's data looks like this:",
      "ja": "オプションのデータは次のようになります。"
    },
    {
      "indent": 3,
      "text": "+--------+--------+--------+--------+--------+--------\n|00101000| Length | Block  | Block  | Block  |  ...\n+--------+--------+--------+--------+--------+--------\n Type=40          \\___________ Vector ___________ ...",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Vector consists of a series of bytes, called Blocks, each of whose encoding corresponds to one of two choices:",
      "ja": "ベクターは、二つの選択肢の一つに対応するそれぞれその符号化ブロックと呼ばれる一連のバイトで構成さ："
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7                  0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+\n|0| Run Length  |       or       |1|DrpCd|Run Len|\n+-+-+-+-+-+-+-+-+                +-+-+-+-+-+-+-+-+\n  Normal Block                      Drop Block",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first byte in the first Data Dropped option refers to the packet indicated by the Acknowledgement Number; subsequent bytes refer to older packets. Data Dropped MUST NOT be sent on DCCP-Data or DCCP-Request packets, which lack an Acknowledgement Number, and any Data Dropped options received on such packets MUST be ignored.",
      "ja": "最初のデータ削除されたオプションの最初のバイトは、肯定応答番号が示すパケットを指します。後続のバイトは、古いパケットを参照してください。データは、確認応答番号が不足しているDCCP-データやDCCP-Requestパケット、に送ってはいけません滴下し、そのようなパケットで受信したすべてのデータアイテムドロップのオプションは無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Normal Blocks, which have high bit 0, indicate that any received packets in the Run Length had their data delivered to the application. Drop Blocks, which have high bit 1, indicate that received packets in the Run Len[gth] were not delivered as usual. The 3-bit Drop Code [DrpCd] field says what happened; generally, no data from that packet reached the application. Packets reported as \"not yet received\" MUST be included in Normal Blocks; packets not covered by any Data Dropped option are treated as if they were in a Normal Block. Defined Drop Codes for Drop Blocks are as follows.",
      "ja": "高ビット0を持っている通常のブロックは、ランレングスのいずれかの受信したパケットは、そのデータがアプリケーションに渡さなかったことを示しています。高いビット1を有するドロップブロックは、実行レン[GTH]における受信パケットを通常どおりに配信されなかったことを示しています。 3ビットのドロップコード[DrpCd]フィールドには、何が起こったかを言います。一般的に、そのパケットからのデータは、アプリケーションに達していません。 「まだ受け取っていない」と報告されたパケットは、通常のブロックに含まれなければなりません。彼らは通常のブロックにあったかのようにDroppedオプションを任意のデータでカバーされていないパケットが処理されます。ドロップブロックのために定義されたドロップコードは以下の通りです。"
    },
    {
      "indent": 18,
      "text": "Drop Code  Meaning\n---------  -------\n    0      Protocol Constraints\n    1      Application Not Listening\n    2      Receive Buffer\n    3      Corrupt\n   4-6     Reserved\n    7      Delivered Corrupt",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Table 7: DCCP Drop Codes",
      "ja": "表7：DCCPドロップコード"
    },
    {
      "indent": 3,
      "text": "In more detail:",
      "ja": "さらに詳細に："
    },
    {
      "indent": 6,
      "text": "0 The packet data was dropped due to protocol constraints. For example, the data was included on a DCCP-Request packet, but the receiving application does not allow such piggybacking; or the data was included on a packet with inappropriately low Checksum Coverage.",
      "ja": "0のパケットデータは、プロトコルの制約のために滴下しました。例えば、データはDCCP-Requestパケットに含まれていたが、受信側アプリケーションは、ピギーバックを可能にしません。またはデータが不適切に低いチェックサムカバー範囲を持つパケットに含まれていました。"
    },
    {
      "indent": 6,
      "text": "1 The packet data was dropped because the application is no longer listening. See Section 11.7.2.",
      "ja": "アプリケーションは、もはや聞いているので、1パケットデータは廃棄されませんでした。 11.7.2項を参照してください。"
    },
    {
      "indent": 6,
      "text": "2 The packet data was dropped in a receive buffer, probably because of receive buffer overflow. See Section 11.7.2.",
      "ja": "2パケットデータは、おそらく受信バッファオーバーフロー、受信バッファに滴下しました。 11.7.2項を参照してください。"
    },
    {
      "indent": 6,
      "text": "3 The packet data was dropped due to corruption. See Section 9.3.",
      "ja": "3パケットデータが破損が原因で滴下しました。セクション9.3を参照してください。"
    },
    {
      "indent": 6,
      "text": "7 The packet data was corrupted but was delivered to the application anyway. See Section 9.3.",
      "ja": "7パケットデータが破損しましたが、とにかくアプリケーションに配信されました。セクション9.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "For example, assume that a packet arrives with Acknowledgement Number 100, an Ack Vector reporting all packets as received, and a Data Dropped option containing the decimal values 0,160,3,162. Then:",
      "ja": "例えば、パケットが受信されるすべてのパケットを報告確認応答番号100は、ACKベクトルで到着することを前提とし、データは小数点以下の値0,160,3,162を含むオプションを落としました。その後："
    },
    {
      "indent": 6,
      "text": "Packet 100 was received (Acknowledgement Number 100, Normal Block, Run Length 0).",
      "ja": "パケット100は、受信しました（承認番号100、ノーマルブロックは、長さ0を実行します）。"
    },
    {
      "indent": 6,
      "text": "Packet 99 was dropped in a receive buffer (Drop Block, Drop Code 2, Run Length 0).",
      "ja": "パケット99は、受信バッファ（ドロップブロック、ドロップコード2、ランレングス0）に滴下しました。"
    },
    {
      "indent": 6,
      "text": "Packets 98, 97, 96, and 95 were received (Normal Block, Run Length 3).",
      "ja": "パケット98、97、96、及び95は、（通常ブロック、ランレングス3）受信されました。"
    },
    {
      "indent": 6,
      "text": "Packets 95, 94, and 93 were dropped in the receive buffer (Drop Block, Drop Code 2, Run Length 2).",
      "ja": "パケット95、94、および93は、受信バッファ（ドロップブロック、ドロップコード2、ランレングス2）で削除されました。"
    },
    {
      "indent": 3,
      "text": "Run lengths of more than 128 (for Normal Blocks) or 16 (for Drop Blocks) must be encoded in multiple Blocks. A single Data Dropped option can acknowledge up to 32384 Normal Block data packets, although the receiver SHOULD NOT send a Data Dropped option when all relevant packets fit into Normal Blocks. Should more packets need to be acknowledged than can fit in 253 bytes of Data Dropped, then multiple Data Dropped options can be sent. The second option will begin where the first left off, and so forth.",
      "ja": "（ドロップブロックのための）を実行（ノーマルブロック用）128以上の長さ、または16は、複数のブロックに符号化されなければなりません。関連するすべてのパケットは通常のブロックに収まるとき、受信機がデータを送信することはできませんが、32384個の通常のブロックデータパケットまで認めることができDroppedオプションを単一のデータは、オプションを落としました。データの253バイトに収まることができるより多くのパケットが承認される必要があるべきで落とし、その後、複数のデータがオプションを送信することができますドロップ。最初は、などやめて、どこ番目のオプションが開始されます。"
    },
    {
      "indent": 3,
      "text": "One or more Data Dropped options that, together, report the status of more packets than have been sent, or that change the status of a packet, or that disagree with Ack Vector or equivalent options (by reporting a \"not yet received\" packet as \"dropped in the receive buffer\", for example) SHOULD be considered invalid. The receiving DCCP SHOULD either ignore such options, or respond by resetting the connection with Reset Code 5, \"Option Error\".",
      "ja": "一つ以上のデータは、として、「未受信」パケットを報告することで、一緒に、送られてきたよりも多くのパケットの状況を報告し、またはそのパケットのステータスを変更、またはそれがAckでベクタまたは同等のオプションと一致しないオプションを（ドロップ無効と考慮されるべきである）、例えば、「受信バッファにドロップ」。受信DCCPは、いずれかのようなオプションを無視する、またはリセットコード5、「オプション誤り」との接続をリセットすることによって応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "A DCCP application interface should let receiving applications specify the Drop Codes corresponding to received packets. For example, this would let applications calculate their own checksums but still report \"dropped due to corruption\" packets via the Data Dropped option. The interface SHOULD NOT let applications reduce the \"seriousness\" of a packet's Drop Code; for example, the application should not be able to upgrade a packet from delivered corrupt (Drop Code 7) to delivered normally (no Drop Code).",
      "ja": "DCCPアプリケーションインターフェースは、受信アプリケーションは、受信したパケットに対応するドロップコードを指定できなければなりません。例えば、これは、アプリケーションが独自のチェックサムを計算してみましょうが、まだ報告するデータドロップされたオプションを使用してパケット「による腐敗に落ちました」。インタフェースは、アプリケーションが、パケットのドロップコードの「深刻さ」を軽減させてはいけません。例えば、アプリケーションが正常に配信する配信壊れた（ドロップコード7）からパケット（ノードロップコード）をアップグレードすることはできないはずです。"
    },
    {
      "indent": 3,
      "text": "Data Dropped information is transmitted reliably. That is, endpoints SHOULD continue to transmit Data Dropped options until receiving an acknowledgement indicating that the relevant options have been processed. In Ack Vector terms, each acknowledgement should contain Data Dropped options that cover the whole Acknowledgement Window (Section 11.4.2), although when every packet in that window would be placed in a Normal Block, no actual option is required.",
      "ja": "データは、情報が確実に伝達されて下落しました。これは、エンドポイントは、データが関連するオプションが処理されたことを示す確認応答を受信するまでのオプションをドロップ送信し続けるべきです。 Ackベクトル項では、各肯定応答データが含まれている必要があり、そのウィンドウ内のすべてのパケットが正常なブロックに置かれるだろうというとき、実際のオプションは必要ありませんが、全体の確認応答ウィンドウ（11.4.2）をカバーするオプションを落としました。"
    },
    {
      "indent": 0,
      "text": "11.7.1. Data Dropped and Normal Congestion Response",
      "section_title": true,
      "ja": "11.7.1. ドロップされたデータと通常の混雑応答"
    },
    {
      "indent": 3,
      "text": "When deciding on a response to a particular acknowledgement or set of acknowledgements containing Data Dropped options, a congestion control mechanism MUST consider dropped packets, ECN Congestion Experienced marks (including marked packets that are included in Data Dropped), and packets singled out in Data Dropped. For window-based mechanisms, the valid response space is defined as follows.",
      "ja": "オプションをドロップ、輻輳制御機構がドロップされたパケットを考慮する必要があり、特定の承認に対する応答に決定するか、データを含む肯定応答の設定した場合、ECNの輻輳が（データにドロップ含まれているマークされたパケットを含む）のマークを経験したし、データに白羽のパケットがドロップされました。次のようにウィンドウベースのメカニズムに関しては、有効な応答空間が定義されています。"
    },
    {
      "indent": 3,
      "text": "Assume an old window of W. Independently calculate a new window W_new1 that assumes no packets were Data Dropped (so W_new1 contains only the normal congestion response), and a new window W_new2 that assumes no packets were lost or marked (so W_new2 contains only the Data Dropped response). We are assuming that Data Dropped recommended a reduction in congestion window, so W_new2 < W.",
      "ja": "何のパケットを負いません新しいウィンドウW_new1を計算する独立しW.の古い窓を想定したデータが（そうW_new1のみ通常の混雑応答が含まれている）滴下し、何のパケットを負いません新しいウィンドウW_new2た（紛失したり、マークされていたので、W_new2のみ含まれていData）は、応答を落としました。私たちは、そうW_new2 <W.、データが輻輳ウィンドウの減少を推奨ドロップすることを想定しています"
    },
    {
      "indent": 3,
      "text": "Then the actual new window W_new MUST NOT be larger than the minimum of W_new1 and W_new2; and the sender MAY combine the two responses, by setting",
      "ja": "そして、実際の新しいウィンドウW_newはW_new1とW_new2の最小値より大きくにすることはできません。そして送信者が設定することで、2つの応答を組み合わせてもよいです"
    },
    {
      "indent": 9,
      "text": "W_new = W + min(W_new1 - W, 0) + min(W_new2 - W, 0).",
      "ja": "W_new = W +分（W_new1  -  W、0）+分（W_new2  -  W 0）。"
    },
    {
      "indent": 3,
      "text": "The details of how this is accomplished are specified in CCID profile documents. Non-window-based congestion control mechanisms MUST behave analogously; again, CCID profiles define how.",
      "ja": "これを達成する方法の詳細については、CCIDプロフィール文書に指定されています。非ウィンドウベースの輻輳制御メカニズムは同様に動作しなければなりません。再び、CCIDプロファイルがどのように定義します。"
    },
    {
      "indent": 0,
      "text": "11.7.2. Particular Drop Codes",
      "section_title": true,
      "ja": "11.7.2. 特定のドロップコード"
    },
    {
      "indent": 3,
      "text": "Drop Code 0, Protocol Constraints, does not indicate any kind of congestion, so the sender's CCID SHOULD react to packets with Drop Code 0 as if they were received (with or without ECN Congestion Experienced marks, as appropriate). However, the sending endpoint SHOULD NOT send data until it believes the protocol constraint no longer applies.",
      "ja": "彼らが受け取ったかのように、送信者のCCIDは、（またはECNの輻輳に遭遇したマークなしで必要に応じて、）ドロップコード0でパケットに反応する必要がありますので、渋滞のいずれかの種類を示すものではありません、コード0、プロトコルの制約をドロップします。それは、プロトコルの制約が適用されなくなり信じていなくなるまでしかし、送信エンドポイントは、データを送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "Drop Code 1, Application Not Listening, means the application running at the endpoint that sent the option is no longer listening for data. For example, a server might close its receiving half-connection to new data after receiving a complete request from the client. This would limit the amount of state available at the server for incoming data and thus reduce the potential damage from certain denial-of-service attacks. A Data Dropped option containing Drop Code 1 SHOULD be sent whenever received data is ignored due to a non-listening application. Once an endpoint reports Drop Code 1 for a packet, it SHOULD report Drop Code 1 for every succeeding data packet on that half-connection; once an endpoint receives a Drop State 1 report, it SHOULD expect that no more data will ever be delivered to the other endpoint's application, so it SHOULD NOT send more data.",
      "ja": "アプリケーションは聞いていない、コード1をドロップし、オプションはもはやデータを待機して送信されていないエンドポイントで実行中のアプリケーションを意味します。例えば、サーバは、クライアントからの完全な要求を受信した後、新しいデータへの受信半接続を閉じることがあります。これは、着信データ用のサーバで利用可能な状態の量を制限するため、特定のサービス拒否攻撃からの潜在的な損傷を低減するであろう。データは、受信したデータは無視されるたびに1による非リスニングアプリケーションに送信されるべきでドロップコードを含むオプションを落としました。エンドポイントは、パケットのドロップコード1を報告したら、それはその半分接続上のすべての後続のデータパケットのドロップコード1を報告しなければなりません。エンドポイントがドロップ状態1つのレポートを受信すると、それはそれ以上のデータはこれまで、他のエンドポイントのアプリケーションに配信されませんので、それはより多くのデータを送ってはならないことを期待してください。"
    },
    {
      "indent": 3,
      "text": "Drop Code 2, Receive Buffer, indicates congestion inside the receiving host. For instance, if a drop-from-tail kernel socket buffer is too full to accept a packet's application data, that packet should be reported as Drop Code 2. For a drop-from-head or more complex socket buffer, the dropped packet should be reported as Drop Code 2. DCCP implementations may also provide an API by which applications can mark received packets as Drop Code 2, indicating that the application ran out of space in its user-level receive buffer. (However, it is not generally useful to report packets as dropped due to Drop Code 2 after more than a couple of round-trip times have passed. The HC-Sender may have forgotten its acknowledgement state for the packet by that time, so the Data Dropped report will have no effect.) Every packet newly acknowledged as Drop Code 2 SHOULD reduce the sender's instantaneous rate by one packet per round-trip time, unless the sender is already sending one packet per RTT or less. Each CCID profile defines the CCID-specific mechanism by which this is accomplished.",
      "ja": "受信バッファ、コード2をドロップし、受信ホスト内の混雑を示します。例えば、ドロップからテールカーネルソケットバッファは、パケットのアプリケーションデータを受け入れるにはあまりにもいっぱいになった場合、そのパケットはからヘッドドロップまたはより複雑なソケットバッファのドロップコード2として報告しなければならない、ドロップされたパケットべき2. DCCP実装は、アプリケーションが受信バッファそのユーザレベルのスペースが不足していることを示す、アプリケーションは、ドロップコード2として受信したパケットにマークを付けることが可能なAPIを提供することができるドロップコードとして報告されます。 （ただし、ドロップとして往復時間以上のカップルが経過した後に起因する2ドロップコードに。HC-Senderは、その時点でのパケットのための承認状態を忘れてしまったかもしれパケットを報告するために一般的に有用ではないので、データは、報告書は効果がありませんドロップされた。）、送信者が既にRTT以下ごとに1つのパケットを送信している場合を除き、新たにドロップコード2として認めすべてのパケットは、ラウンドトリップ時間あたり1つのパケットで送信者の瞬間率を減らす必要があります。各CCIDプロフィールは、これが達成されることにより、CCID特有のメカニズムを定義します。"
    },
    {
      "indent": 3,
      "text": "Currently, the other Drop Codes (namely Drop Code 3, Corrupt; Drop Code 7, Delivered Corrupt; and reserved Drop Codes 4-6) MUST cause the relevant CCID to behave as if the relevant packets were ECN marked (ECN Congestion Experienced).",
      "ja": "現在、他のドロップコード関連のパケットはECNが（経験豊富なECNの輻輳）をマークしたかのように、関連CCIDの振る舞いを引き起こす必要があります（つまりドロップコード3、腐敗;＆ドロップコード4-6を予約し、ドロップコード7は、壊れ配信します）。"
    },
    {
      "indent": 0,
      "text": "12. Explicit Congestion Notification",
      "section_title": true,
      "ja": "12.明示的輻輳通知"
    },
    {
      "indent": 3,
      "text": "The DCCP protocol is fully ECN-aware [RFC3168]. Each CCID specifies how its endpoints respond to ECN marks. Furthermore, DCCP, unlike TCP, allows senders to control the rate at which acknowledgements are generated (with options like Ack Ratio); since acknowledgements are congestion controlled, they also qualify as ECN-Capable Transport.",
      "ja": "DCCPプロトコルは、[RFC3168]完全ECN-認識しています。そのエンドポイントはECNマークへの対応方法を各CCIDを指定します。また、DCCPは、TCPとは異なり、送信者が（肯定応答率のようなオプションで）確認応答が生成される速度を制御することを可能にします。確認応答は混雑が制御されているので、彼らはまた、ECN-できるTransportとしての資格。"
    },
    {
      "indent": 3,
      "text": "Each CCID profile describes how that CCID interacts with ECN, both for data traffic and pure-acknowledgement traffic. A sender SHOULD set ECN-Capable Transport on its packets' IP headers unless the receiver's ECN Incapable feature is on or the relevant CCID disallows it.",
      "ja": "各CCIDプロフィールは、CCIDは両方のデータトラフィックと純粋-承認トラフィックのため、ECNと対話する方法を説明します。受信者のECNできない機能がオンであるか、関連CCIDはそれを禁止しない限り、送信者は、そのパケットのIPヘッダにECN-できるTransportを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The rest of this section describes the ECN Incapable feature and the interaction of the ECN Nonce with acknowledgement options such as Ack Vector.",
      "ja": "このセクションの残りの部分は、ECNできない機能や、Ackをベクトルとして承認オプションとECNナンスの相互作用を記述する。"
    },
    {
      "indent": 0,
      "text": "12.1. ECN Incapable Feature",
      "section_title": true,
      "ja": "12.1.  ECNできない機能"
    },
    {
      "indent": 3,
      "text": "DCCP endpoints are ECN-aware by default, but the ECN Incapable feature lets an endpoint reject the use of Explicit Congestion Notification. The use of this feature is NOT RECOMMENDED. ECN incapability both avoids ECN's possible benefits and prevents senders from using the ECN Nonce to check for receiver misbehavior. A DCCP stack MAY therefore leave the ECN Incapable feature unimplemented, acting as if all connections were ECN capable. Note that the inappropriate firewall interactions that dogged TCP's implementation of ECN [RFC3360] involve TCP header bits, not the IP header's ECN bits; we know of no middlebox that would block ECN-capable DCCP packets but allow ECN-incapable DCCP packets.",
      "ja": "DCCPのエンドポイントは、デフォルトではECN-認識していますが、ECNできない機能は、エンドポイントが明示的輻輳通知の使用を拒否することができます。この機能の使用は推奨されません。 ECN不能は、両方のECNの可能性の利点を回避し、受信不正行為をチェックするためにECN nonceを使用してから送信者を防ぐことができます。 DCCPスタックは、したがって、すべての接続がECNが可能であるかのように作用して、実装されていないECNできない機能を残すことができます。 ECN [RFC3360]のTCPの実装を付きまとっ不適切ファイアウォール相互作用がTCPヘッダービットではなく、IPヘッダーのECNビットを含むことに留意されたいです。我々は、ECN対応のDCCPのパケットをブロックするが、ECN-不可能DCCPパケットを可能にする無ミドルを知っています。"
    },
    {
      "indent": 3,
      "text": "ECN Incapable has feature number 4 and is server-priority. It takes one-byte Boolean values. DCCP A MUST be able to read ECN bits from received frames' IP headers when ECN Incapable/A is zero. (This is independent of whether it can set ECN bits on sent frames.) DCCP A thus sends a \"Change L(ECN Inapable, 1)\" option to DCCP B to inform it that A cannot read ECN bits. If the ECN Incapable/A feature is one, then all of DCCP B's packets MUST be sent as ECN incapable. New connections start with ECN Incapable 0 (that is, ECN capable) for both endpoints. Values of two or more are reserved.",
      "ja": "ECN不可能では機能番号4を持ち、サーバーの優先順位です。これは、1バイトのブール値をとります。 DCCP Aは、ECN不能/ Aがゼロであるとき、受信したフレームのIPヘッダからECNビットを読み取ることができなければなりません。 （これは、それが送信されたフレームにECNビットを設定することができるかどうかとは無関係である。）DCCP Aは、このように「変化L（ECN Inapable、1）」AはECNビットを読み取ることができないことを知らせるためにDCCP Bにオプションを送ります。 ECNができない/機能が1であれば、DCCP Bのパケットのすべてが不可能ECNとして送らなければなりません。新しい接続は両方の終点のために（つまり、可能ECNである）ECN不可能な0で始まります。二つ以上の値が予約されています。"
    },
    {
      "indent": 3,
      "text": "If a DCCP is not ECN capable, it MUST send Mandatory \"Change L(ECN Incapable, 1)\" options to the other endpoint until acknowledged (by \"Confirm R(ECN Incapable, 1)\") or the connection closes. Furthermore, it MUST NOT accept any data until the other endpoint sends \"Confirm R(ECN Incapable, 1)\". It SHOULD send Data Dropped options on its acknowledgements, with Drop Code 0 (\"protocol constraints\"), if the other endpoint does send data inappropriately.",
      "ja": "DCCPが可能なECNされていない場合（「R（ECNできない、1）を確認してください」で）認めたり、接続が閉じるまで、それは他のエンドポイントに必須の「変更L（ECNできない、1）」オプションを送らなければなりません。さらに、それは他のエンドポイントに送信するまでの任意のデータを受け入れてはいけません「R（1、ECNができない）確認」。これは、他のエンドポイントが不適切にデータを送信した場合、データは、ドロップコード0（「プロトコルの制約」）と、その確認応答のオプションをドロップ送るべきです。"
    },
    {
      "indent": 0,
      "text": "12.2. ECN Nonces",
      "section_title": true,
      "ja": "12.2.  ECN Nuncios"
    },
    {
      "indent": 3,
      "text": "Congestion avoidance will not occur, and the receiver will sometimes get its data faster, if the sender isn't told about congestion events. Thus, the receiver has some incentive to falsify acknowledgement information, reporting that marked or dropped packets were actually received unmarked. This problem is more serious with DCCP than with TCP, since TCP provides reliable transport: it is more difficult with TCP to lie about lost packets without breaking the application.",
      "ja": "輻輳回避は発生しません、と送信者が輻輳イベントについて語られていない場合、受信機は時々、より高速にデータを取得します。このように、受信機は、パケットをマークまたは削除の報告が実際にマークされていない受信した、送達確認情報を改ざんするためにいくつかのインセンティブを持っています。 TCPは信頼性の高いトランスポートを提供するので、この問題は、TCPよりもDCCPとより深刻である：アプリケーションを壊すことなく、失われたパケット偽るためにTCPとより困難です。"
    },
    {
      "indent": 3,
      "text": "ECN Nonces are a general mechanism to prevent ECN cheating (or loss cheating). Two values for the two-bit ECN header field indicate ECN-Capable Transport, 01 and 10. The second code point, 10, is the ECN Nonce. In general, a protocol sender chooses between these code points randomly on its output packets, remembering the sequence it chose. On every acknowledgement, the protocol receiver reports the number of ECN Nonces it has received thus far. This is called the ECN Nonce Echo. Since ECN marking and packet dropping both destroy the ECN Nonce, a receiver that lies about an ECN mark or packet drop has a 50% chance of guessing right and avoiding discipline. The sender may react punitively to an ECN Nonce mismatch, possibly up to dropping the connection. The ECN Nonce Echo field need not be an integer; one bit is enough to catch 50% of infractions, and the probability of success drops exponentially as more packets are sent [RFC3540].",
      "ja": "ECNナンスは、ECN浮気（または損失の不正行為）を防ぐために、一般的なメカニズムです。 2つの2ビットECNヘッダフィールドの値ECN-可能なトランスポートを示し、01及び10の第2のコードポイント、10は、ECNノンスです。一般に、プロトコルの送信者は、それが選択したシーケンスを記憶、ランダムにその出力パケットにこれらのコード・ポイントとの間で選択します。すべての承認には、プロトコルの受信機は、それがこれまでに受けたECNナンスの数を報告します。これは、電子証券取引ネットワークのNonceエコーと呼ばれています。 ECNマーキングと、パケットがドロップ両方のECNナンス、右推測と規律を回避する50％のチャンスがあるECNマークやパケット損失についてのある受信機を破壊して以来。送信者は、おそらく、接続をドロップするまで、電子証券取引ネットワークのNonceの不一致にpunitively反応することができます。 ECNナンスエコーフィールドは整数である必要はありません。 1ビットは、違反の50％を捕捉するのに十分であり、そしてより多くのパケットが[RFC3540]を送信しているように、成功の確率が指数関数的に低下します。"
    },
    {
      "indent": 3,
      "text": "In DCCP, the ECN Nonce Echo field is encoded in acknowledgement options. For example, the Ack Vector option comes in two forms, Ack Vector [Nonce 0] (option 38) and Ack Vector [Nonce 1] (option 39), corresponding to the two values for a one-bit ECN Nonce Echo. The Nonce Echo for a given Ack Vector equals the one-bit sum (exclusive-or, or parity) of ECN nonces for packets reported by that Ack Vector as received and not ECN marked. Thus, only packets marked as State 0 matter for this calculation (that is, valid received packets that were not ECN marked). Every Ack Vector option is detailed enough for the sender to determine what the Nonce Echo should have been. It can check this calculation against the actual Nonce Echo and complain if there is a mismatch. (The Ack Vector could conceivably report every packet's ECN Nonce state, but this would severely limit its compressibility without providing much extra protection.)",
      "ja": "DCCPでは、ECNのNonceエコーフィールドには、確認応答のオプションでエンコードされています。例えば、肯定応答ベクトルオプションは、2つの形式が、肯定応答ベクトル[ノンス0]（オプション38）とACKベクトル[ノンス1]（オプション39）、1ビットECNノンスエコーのための2つの値に対応します。所与のAckベクトルのノンスエコーが受信されないECNがマークとしてその肯定応答ベクトルによって報告されたパケットのECNのナンスの1ビットの和（排他的論理和、またはパリティ）に等しいです。したがって、唯一の（つまり、マークされECNれなかった有効な受信パケット）この計算の状態0の問題としてマークされたパケット。すべてのAckベクトルオプションは、ノンスエコーがされているべきかを決定するために、送信者のために十分に詳述されています。これは、実際のNonceエコーに対してこの計算をチェックし、不一致がある場合は文句を言うことができます。 （のAck Vectorが考えられるすべてのパケットのECNナンス状態を報告することがありますが、これは深刻な多くの特別な保護を提供することなく、その圧縮性を制限します。）"
    },
    {
      "indent": 3,
      "text": "Each DCCP sender SHOULD set ECN Nonces on its packets and remember which packets had nonces. When a sender detects an ECN Nonce Echo mismatch, it behaves as described in the next section. Each DCCP receiver MUST calculate and use the correct value for ECN Nonce Echo when sending acknowledgement options.",
      "ja": "各DCCP送信者は、そのパケットにECNナンスを設定し、ナンスを持っていたパケットを覚えておいてください。送信者が電子証券取引ネットワークのNonceエコーの不一致を検出すると、次のセクションで説明するように、それが動作します。肯定応答オプションを送信するとき、各DCCP受信機は、ECNノンスエコーの正しい値を計算し、使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "ECN incapability, as indicated by the ECN Incapable feature, is handled as follows: an endpoint sending packets to an ECN-incapable receiver MUST send its packets as ECN incapable, and an ECN-incapable receiver MUST use the value zero for all ECN Nonce Echoes.",
      "ja": "ECNできない機能によって示されるように、以下のようにECN不能は、処理される：ECN非対応の受信機にパケットを送信するエンドポイントがECNできないように、そのパケットを送信しなければならない、およびECN非対応受信機は、すべてのECNノンスエコーの値ゼロを使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "12.3. Aggression Penalties",
      "section_title": true,
      "ja": "12.3. アグレッション罰則"
    },
    {
      "indent": 3,
      "text": "DCCP endpoints have several mechanisms for detecting congestion-related misbehavior. For example:",
      "ja": "DCCP終点は、輻輳関連の不正行為を検出するためのいくつかのメカニズムを持っています。例えば："
    },
    {
      "indent": 3,
      "text": "o A sender can detect an ECN Nonce Echo mismatch, indicating possible receiver misbehavior.",
      "ja": "O送信側は可能受信不正行為を示し、ECNノンスエコーミスマッチを検出することができます。"
    },
    {
      "indent": 3,
      "text": "o A receiver can detect whether the sender is responding to congestion feedback or Slow Receiver.",
      "ja": "O受信側は、送信側が輻輳フィードバックまたは遅い受信に応答しているかどうかを検出することができます。"
    },
    {
      "indent": 3,
      "text": "o An endpoint may be able to detect that its peer is reporting inappropriately small Elapsed Time values (Section 13.2).",
      "ja": "Oエンドポイントは、そのピアが不適切に小さい経過時間値（13.2）を報告していることを検出することができます。"
    },
    {
      "indent": 3,
      "text": "An endpoint that detects possible congestion-related misbehavior SHOULD try to verify that its peer is truly misbehaving. For example, a sending endpoint might send a packet whose ECN header field is set to Congestion Experienced, 11; a receiver that doesn't report a corresponding mark is most likely misbehaving.",
      "ja": "可能混雑関連の不正行為を検出したエンドポイントは、その相手が本当に不正な動作していることを確認してみてください。例えば、送信エンドポイントは、そのECNヘッダフィールドは輻輳経験、11に設定されているパケットを送るかもしれません。対応するマークを報告しない受信機は、ほとんどの誤動作です。"
    },
    {
      "indent": 3,
      "text": "Upon detecting possible misbehavior, a sender SHOULD respond as if the receiver had reported one or more recent packets as ECN-marked (instead of unmarked), while a receiver SHOULD report one or more recent non-marked packets as ECN-marked. Alternately, a sender might act as if the receiver had sent a Slow Receiver option, and a receiver might send Slow Receiver options. Other reactions that serve to slow the transfer rate are also acceptable. An entity that detects particularly egregious and ongoing misbehavior MAY also reset the connection with Reset Code 11, \"Aggression Penalty\".",
      "ja": "受信機は、（代わりにマークされていないの）ECN-マークとして、一つ以上の最近のパケットを報告したかのようにECN-マークとして受信機は、1つまたは複数の最近の非マークされたパケットを報告する必要がありながら、可能な不正行為を検出すると、送信者は、応答する必要があります。代わりに、受信機は遅いレシーバオプションを送っていたかのように送信者が行動するかもしれない、と受信機は、低速レシーバのオプションを送信することがあります。転送速度を遅くするのに役立つ他の反応も許容されます。特に悪質と継続的な不正行為を検出したエンティティは、リセットコード11、「侵略ペナルティ」との接続をリセットする場合があります。"
    },
    {
      "indent": 3,
      "text": "However, ECN Nonce mismatches and other warning signs can result from innocent causes, such as implementation bugs or attack. In particular, a successful DCCP-Data attack (Section 7.5.5) can cause the receiver to report an incorrect ECN Nonce Echo. Therefore, connection reset and other heavyweight mechanisms SHOULD be used only as last resorts, after multiple round-trip times of verified aggression.",
      "ja": "しかし、ECNナンスの不一致や他の警告標識は、そのような実装のバグや攻撃などの無実の原因に起因することができます。具体的には、成功したDCCP  - データ攻撃（セクション7.5.5）は、受信機が正しくないECNのNonceエコーを報告させることができます。そのため、接続がリセットされ、他のヘビー級のメカニズムを検証侵略の複数の往復時間の後、最後のリゾートとして使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "13. Timing Options",
      "section_title": true,
      "ja": "13.タイミングオプション"
    },
    {
      "indent": 3,
      "text": "The Timestamp, Timestamp Echo, and Elapsed Time options help DCCP endpoints explicitly measure round-trip times.",
      "ja": "タイムスタンプ、タイムスタンプエコー、経過時間のオプションは、DCCP終点は明示的に往復時間を測定するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "13.1. Timestamp Option",
      "section_title": true,
      "ja": "13.1. タイムスタンプオプション"
    },
    {
      "indent": 3,
      "text": "This option is permitted in any DCCP packet. The length of the option is 6 bytes.",
      "ja": "このオプションは、任意のDCCPパケットに許可されています。オプションの長さは6バイトです。"
    },
    {
      "indent": 3,
      "text": "+--------+--------+--------+--------+--------+--------+\n|00101001|00000110|          Timestamp Value          |\n+--------+--------+--------+--------+--------+--------+\n Type=41  Length=6",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The four bytes of option data carry the timestamp of this packet. The timestamp is a 32-bit integer that increases monotonically with time, at a rate of 1 unit per 10 microseconds. At this rate, Timestamp Value will wrap approximately every 11.9 hours. Endpoints need not measure time at this fine granularity; for example, an endpoint that preferred to measure time at millisecond granularity might send Timestamp Values that were all multiples of 100. The precise time corresponding to Timestamp Value zero is not specified: Timestamp Values are only meaningful relative to other Timestamp Values sent on the same connection. A DCCP receiving a Timestamp option SHOULD respond with a Timestamp Echo option on the next packet it sends.",
      "ja": "オプションの4バイトのデータは、このパケットのタイムスタンプを運びます。タイムスタンプは、10マイクロ秒当たり1単位の割合で、時間とともに単調に増加する32ビットの整数です。このレートでは、タイムスタンプ値は約すべての11.9時間をラップします。エンドポイントは、この細かい粒度で時間を計測する必要はありません。タイムスタンプ値は同じで送信され、他のタイムスタンプ値に対してのみ意味相対的：例えば、ミリ秒単位で時間を測定することが好ましい終点は、タイムスタンプ値ゼロに対応する正確な時刻が指定されていないすべての100の倍数であったタイムスタンプ値を送信するかもしれません接続。タイムスタンプオプションを受信DCCPは、送信する次のパケットのタイムスタンプエコーオプションを指定して応答する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.2. Elapsed Time Option",
      "section_title": true,
      "ja": "13.2. 経過時間オプション"
    },
    {
      "indent": 3,
      "text": "This option is permitted in any DCCP packet that contains an Acknowledgement Number; such options received on other packet types MUST be ignored. It indicates how much time has elapsed since the packet being acknowledged -- the packet with the given Acknowledgement Number -- was received. The option may take 4 or 6 bytes, depending on the size of the Elapsed Time value. Elapsed Time helps correct round-trip time estimates when the gap between receiving a packet and acknowledging that packet may be long -- in CCID 3, for example, where acknowledgements are sent infrequently.",
      "ja": "このオプションは、確認応答番号を含む任意のDCCPパケットに許可されています。他のパケットタイプで受信し、そのようなオプションは無視しなければなりません。これは、パケットが確認されてから経過した時間を示す - 与えられた確認応答番号を持つパケットを - 受信しました。オプションは、経過時間値の大きさに応じて、4つの又は6バイトをとることができます。肯定応答がまれに送信され、例えばCCID 3に - 経過時間がパケットを受信し、そのパケットを認めるとの間に隙間が長いとすることができる場合、正しいラウンドトリップ時間を推定するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "+--------+--------+--------+--------+\n|00101011|00000100|   Elapsed Time  |\n+--------+--------+--------+--------+\n Type=43    Len=4",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+--------+--------+--------+--------+--------+--------+\n|00101011|00000110|            Elapsed Time           |\n+--------+--------+--------+--------+--------+--------+\n Type=43    Len=6",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The option data, Elapsed Time, represents an estimated lower bound on the amount of time elapsed since the packet being acknowledged was received, with units of hundredths of milliseconds. If Elapsed Time is less than a half-second, the first, smaller form of the option SHOULD be used. Elapsed Times of more than 0.65535 seconds MUST be sent using the second form of the option. The special Elapsed Time value 4294967295, which corresponds to approximately 11.9 hours, is used to represent any Elapsed Time greater than 42949.67294 seconds. DCCP endpoints MUST NOT report Elapsed Times that are significantly larger than the true elapsed times. A connection MAY be reset with Reset Code 11, \"Aggression Penalty\", if one endpoint determines that the other is reporting a much-too-large Elapsed Time.",
      "ja": "オプションデータ、経過時間、認知されているパケットはミリ秒の100分の1単位で、受信されてから経過した時間の量に下限推定を表します。経過時間が0.5秒未満である場合、オプションの最初の、小型のフォームが使用されるべきです。以上0.65535秒の経過時間は、オプションの二番目の形式を使用させなければなりません。約11.9時間に対応する特別な経過時間値4294967295は、42949.67294秒よりも大きい任意の経過時間を表すために使用されます。 DCCP終点は、真の経過時間よりもかなり大きい経過時間を報告してはなりません。一方のエンドポイントは、他の多くの余りに大きな経過時間を報告していると判断した場合、接続は、リセットコード11、「侵略ペナルティ」でリセットされることがあります。"
    },
    {
      "indent": 3,
      "text": "Elapsed Time is measured in hundredths of milliseconds as a compromise between two conflicting goals. First, it provides enough granularity to reduce rounding error when measuring elapsed time over fast LANs; second, it allows many reasonable elapsed times to fit into two bytes of data.",
      "ja": "経過時間は、相反する2つの目標の間の妥協として、ミリ秒単位の百で測定されます。まず、それは速いLAN上の経過時間を計測丸め誤差を低減するのに十分な精度を提供します。第二、それは多くの合理的な経過時間は、2バイトのデータに適合することができます。"
    },
    {
      "indent": 0,
      "text": "13.3. Timestamp Echo Option",
      "section_title": true,
      "ja": "13.3. タイムスタンプエコーオプション"
    },
    {
      "indent": 3,
      "text": "This option is permitted in any DCCP packet, as long as at least one packet carrying the Timestamp option has been received. Generally, a DCCP endpoint should send one Timestamp Echo option for each Timestamp option it receives, and it should send that option as soon as is convenient. The length of the option is between 6 and 10 bytes, depending on whether Elapsed Time is included and how large it is.",
      "ja": "このオプションは限りタイムスタンプオプションを運ぶ少なくとも1つのパケットが受信されている、あらゆるDCCPパケットに許可されています。一般的に、DCCP終点は、それが受信した各タイムスタンプオプションの1つのタイムスタンプエコーオプションを送信する必要があり、それは、すぐに便利なように、そのオプションを送信する必要があります。オプションの長さは、経過時間が含まれ、それがどのように大きなされているかどうかに依存して、6〜10バイトです。"
    },
    {
      "indent": 3,
      "text": "+--------+--------+--------+--------+--------+--------+\n|00101010|00000110|           Timestamp Echo          |\n+--------+--------+--------+--------+--------+--------+\n Type=42    Len=6",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+--------+--------+------- ... -------+--------+--------+\n|00101010|00001000|  Timestamp Echo   |   Elapsed Time  |\n+--------+--------+------- ... -------+--------+--------+\n Type=42    Len=8       (4 bytes)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+--------+--------+------- ... -------+------- ... -------+\n|00101010|00001010|  Timestamp Echo   |    Elapsed Time   |\n+--------+--------+------- ... -------+------- ... -------+\n Type=42   Len=10       (4 bytes)           (4 bytes)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first four bytes of option data, Timestamp Echo, carry a Timestamp Value taken from a preceding received Timestamp option. Usually, this will be the last packet that was received -- the packet indicated by the Acknowledgement Number, if any -- but it might be a preceding packet. Each Timestamp received will generally result in exactly one Timestamp Echo transmitted. If an endpoint has received multiple Timestamp options since the last time it sent a packet, then it MAY ignore all Timestamp options but the one included on the packet with the greatest sequence number. Alternatively, it MAY include multiple Timestamp Echo options in its response, each corresponding to a different Timestamp option.",
      "ja": "オプションデータの最初の4バイト、タイムスタンプエコーは、前述の受信タイムスタンプオプションから採取されたタイムスタンプ値を運びます。もしあれば、確認応答番号で示されるパケット -   - 通常、これは、受信された最後のパケットになりますが、それは前のパケットであるかもしれません。各タイムスタンプは、一般的に、正確に1つのタイムスタンプエコーが送信になります受け取りました。エンドポイントは、それがパケットを送信した前回、複数のタイムスタンプオプションを受信した場合、それは、すべてのタイムスタンプオプションを無視するかもしれませんが、一つは、最大のシーケンス番号を持つパケットに含まれています。あるいは、それは、それぞれが異なるタイムスタンプオプションに対応し、その応答で複数のタイムスタンプエコーオプションを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "The Elapsed Time value, similar to that in the Elapsed Time option, indicates the amount of time elapsed since receiving the packet whose timestamp is being echoed. This time MUST have units of hundredths of milliseconds. Elapsed Time is meant to help the Timestamp sender separate the network round-trip time from the Timestamp receiver's processing time. This may be particularly important for CCIDs where acknowledgements are sent infrequently, so that there might be considerable delay between receiving a Timestamp option and sending the corresponding Timestamp Echo. A missing Elapsed Time field is equivalent to an Elapsed Time of zero. The smallest version of the option SHOULD be used that can hold the relevant Elapsed Time value.",
      "ja": "経過時間オプションと同様の経過時間の値は、そのタイムスタンプエコーされたパケットを受信して​​からの経過時間を示しています。この時間はミリ秒の100分の1単位を持たなければなりません。経過時間は、タイムスタンプ、送信者は、タイムスタンプ、受信機の処理時間からネットワーク往復時間を区切る助けるためのものです。タイムスタンプオプションを受信し、対応するタイムスタンプエコーを送信する間にかなりの遅延が生じる可能性がありますように、これは、確認応答が、まれに送信されますのCCIDsのために特に重要であるかもしれません。行方不明経過時間フィールドがゼロの経過時間に相当します。オプションの最小バージョンは、関連する経過時間の値を保持することができる使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "14. Maximum Packet Size",
      "section_title": true,
      "ja": "14.最大パケットサイズ"
    },
    {
      "indent": 3,
      "text": "A DCCP implementation MUST maintain the maximum packet size (MPS) allowed for each active DCCP session. The MPS is influenced by the maximum packet size allowed by the current congestion control mechanism (CCMPS), the maximum packet size supported by the path's links (PMTU, the Path Maximum Transmission Unit) [RFC1191], and the lengths of the IP and DCCP headers.",
      "ja": "DCCP実装は、各アクティブDCCPセッションに許可された最大パケットサイズ（MPS）を維持しなければなりません。 MPSは、現在の輻輳制御機構（CCMPS）によって許容される最大パケット・サイズ、パスのリンクによってサポートされる最大パケットサイズ（PMTU、パスの最大伝送単位）[RFC1191]、およびIPとDCCPの長さに影響されますヘッダ。"
    },
    {
      "indent": 3,
      "text": "A DCCP application interface SHOULD let the application discover DCCP's current MPS. Generally, the DCCP implementation will refuse to send any packet bigger than the MPS, returning an appropriate error to the application. A DCCP interface MAY allow applications to request fragmentation for packets larger than PMTU, but not larger than CCMPS. (Packets larger than CCMPS MUST be rejected in any case.) Fragmentation SHOULD NOT be the default, since it decreases robustness: an entire packet is discarded if even one of its fragments is lost. Applications can usually get better error tolerance by producing packets smaller than the PMTU.",
      "ja": "DCCPアプリケーションインターフェースは、アプリケーションがDCCPの現在のMPSを発見させてください。一般的に、DCCPの実装は、アプリケーションに適切なエラーを返す、MPSよりも大きな任意のパケットを送信することを拒否します。 DCCPインタフェースは、アプリケーションがCCMPSより大きいPMTUより大きくはなく、パケットのフラグメンテーションを要求することを可能にし得ます。 （CCMPSよりも大きなパケットは、どのような場合には拒絶しなければなりません。）フラグメンテーションはデフォルトすべきではない、それは堅牢性を減少するので：一つでもそのフラグメントのが失われた場合、パケット全体が廃棄されます。アプリケーションは通常、PMTUより小さいパケットを生成することによって、より良いエラー耐性を得ることができます。"
    },
    {
      "indent": 3,
      "text": "The MPS reported to the application SHOULD be influenced by the size expected to be required for DCCP headers and options. If the application provides data that, when combined with the options the DCCP implementation would like to include, would exceed the MPS, the implementation should either send the options on a separate packet (such as a DCCP-Ack) or lower the MPS, drop the data, and return an appropriate error to the application.",
      "ja": "MPSはDCCPヘッダーとオプションのために必要とされることが予想される大きさに影響されるべきであるアプリケーションに報告しました。アプリケーションがオプションと組み合わせた場合、DCCP実装が含まれたいデータを提供する場合、MPSを超える、MPSを（例えばDCCP-Ackのような）別のパケットのオプションを送信したり、下げなければならないのいずれかの実装では、ドロップデータ、およびアプリケーションに適切なエラーを返します。"
    },
    {
      "indent": 0,
      "text": "14.1. Measuring PMTU",
      "section_title": true,
      "ja": "14.1. 測定PMTU"
    },
    {
      "indent": 3,
      "text": "Each DCCP endpoint MUST keep track of the current PMTU for each connection, except that this is not required for IPv4 connections whose applications have requested fragmentation. The PMTU SHOULD be initialized from the interface MTU that will be used to send packets. The MPS will be initialized with the minimum of the PMTU and the CCMPS, if any.",
      "ja": "これは、そのアプリケーションの断片化を要求したIPv4接続のために必要とされていないことを除いて、各DCCP終点は、それぞれの接続のために現在のPMTUを追跡する必要があります。 PMTUは、パケットを送信するために使用されるインターフェイスのMTUから初期化する必要があります。もしあればMPSは、PMTUとCCMPSの最小で初期化されます。"
    },
    {
      "indent": 3,
      "text": "Classical PMTU discovery uses unfragmentable packets. In IPv4, these packets have the IP Don't Fragment (DF) bit set; in IPv6, all packets are unfragmentable once emitted by an end host. As specified in [RFC1191], when a router receives a packet with DF set that is larger than the next link's MTU, it sends an ICMP Destination Unreachable message back to the source whose Code indicates that an unfragmentable packet was too large to forward (a \"Datagram Too Big\" message). When a DCCP implementation receives a Datagram Too Big message, it decreases its PMTU to the Next-Hop MTU value given in the ICMP message. If the MTU given in the message is zero, the sender chooses a value for PMTU using the algorithm described in [RFC1191], Section 7. If the MTU given in the message is greater than the current PMTU, the Datagram Too Big message is ignored, as described in [RFC1191]. (We are aware that this may cause problems for DCCP endpoints behind certain firewalls.)",
      "ja": "クラシックPMTUの発見は、フラグメント化不能のパケットを使用しています。 IPv4では、これらのパケットは、IPを持っているフラグメント（DF）は、ビットセットしないでください。エンドホストから放出された後、IPv6では、すべてのパケットがフラグメント化不能です。 [RFC1191]で指定されているように、ルータは、次のリンクのMTUよりも大きいDFセットでパケットを受信したとき、それは戻って、そのコードフラグメント化不能パケットを転送するにはあまりにも大きかったことを示している（AソースにICMP宛先到達不能メッセージを送信します「データグラムが大きすぎます」というメッセージ）。 DCCP実装がデータグラム過大メッセージを受信すると、ICMPメッセージに指定されたネクストホップMTU値に対するPMTUを低下させます。メッセージに指定されたMTUがゼロである場合、送信者は[RFC1191]に記載されたアルゴリズムを使用して、PMTUの値を選択するメッセージで与えられたMTUが現在のPMTUより大きい場合、第7、データグラム過大メッセージは無視されます、[RFC1191]に記載されているように。 （これは、特定のファイアウォールの背後にあるDCCPエンドポイントの問題を引き起こす可能性があることを認識しています。）"
    },
    {
      "indent": 3,
      "text": "A DCCP implementation may allow the application occasionally to request that PMTU discovery be performed again. This will reset the PMTU to the outgoing interface's MTU. Such requests SHOULD be rate limited, to one per two seconds, for example.",
      "ja": "DCCPの実装では、アプリケーションが時折PMTU検出が再度行われることを要求することを可能にし得ます。これは、発信インターフェイスのMTUにPMTUをリセットします。このような要求は、例えば、2秒に1に、レート制限すべきです。"
    },
    {
      "indent": 3,
      "text": "A DCCP sender MAY treat the reception of an ICMP Datagram Too Big message as an indication that the packet being reported was not lost due to congestion, and so for the purposes of congestion control it MAY ignore the DCCP receiver's indication that this packet did not arrive. However, if this is done, then the DCCP sender MUST check the ECN bits of the IP header echoed in the ICMP message and only perform this optimization if these ECN bits indicate that the packet did not experience congestion prior to reaching the router whose link MTU it exceeded.",
      "ja": "DCCPの送信者は報告されているパケットが輻輳のために失われていなかったことを示す指標として、ICMPデータグラム過大メッセージの受信を扱うことができ、その輻輳制御の目的のためには、このパケットが到着しなかったことをDCCP受信機の表示を無視してもよい（MAY） 。しかし、これが行われた場合、その後、DCCPの送信者は、ICMPメッセージにエコーIPヘッダのECNビットをチェックしなければなりませんし、これらのみECNビットは、パケットが前にそのリンクMTUルータに到達する輻輳を経験しなかったことを示している場合は、この最適化を実行しますそれを超えました。"
    },
    {
      "indent": 3,
      "text": "A DCCP implementation SHOULD ensure, as far as possible, that ICMP Datagram Too Big messages were actually generated by routers, so that attackers cannot drive the PMTU down to a falsely small value. The simplest way to do this is to verify that the Sequence Number on the ICMP error's encapsulated header corresponds to a Sequence Number that the implementation recently sent. (According to current specifications, routers should return the full DCCP header and payload up to a maximum of 576 bytes [RFC1812] or the minimum IPv6 MTU [RFC2463], although they are not required to return more than 64 bits [RFC792]. Any amount greater than 128 bits will include the Sequence Number.) ICMP Datagram Too Big messages with incorrect or missing Sequence Numbers may be ignored, or the DCCP implementation may lower the PMTU only temporarily in response. If more than three odd Datagram Too Big messages are received and the other DCCP endpoint reports more than three lost packets, however, the DCCP implementation SHOULD assume the presence of a confused router and either obey the ICMP messages' PMTU or (on IPv4 networks) switch to allowing fragmentation.",
      "ja": "DCCPの実装では、攻撃者が誤って小さな値までPMTUを駆動することができないように、ICMPデータグラムが大きすぎメッセージは、実際に、ルータによって生成されたことを、可能な限り、確保すべきです。これを実行する最も簡単な方法は、ICMPエラーのカプセル化ヘッダのシーケンス番号は、実装が最近送られたシーケンス番号に対応することを確認することです。それらは64の以上のビット[RFC792]を返すように要求されないが（現在の仕様によれば、ルータは、完全DCCPヘッダーを返すべきであり、576バイト[RFC1812]または最小のIPv6 MTU [RFC2463]の最大値までペイロード。任意128ビットを超える量は、シーケンス番号が含まれます。）正しくないか欠落しているシーケンス番号を持つICMPデータグラムが大きすぎたメッセージは無視してもよいし、DCCPの実装は応答して一時的にしかPMTUを低下させることができます。以上の3つの奇数データグラムすぎるBigメッセージが受信され、他のDCCP終点は以上3つの失われたパケットを報告した場合、しかし、DCCP実装が混乱し、ルータの存在を前提とし、いずれかのICMPメッセージPMTUに従うか、すべきである（IPv4ネットワーク上）断片化を可能に切り替えます。"
    },
    {
      "indent": 3,
      "text": "DCCP also allows upward probing of the PMTU [PMTUD], where the DCCP endpoint begins by sending small packets with DF set and then gradually increases the packet size until a packet is lost. This mechanism does not require any ICMP error processing. DCCP-Sync packets are the best choice for upward probing, since DCCP-Sync probes do not risk application data loss. The DCCP implementation inserts arbitrary data into the DCCP-Sync application area, padding the packet to the right length. Since every valid DCCP-Sync generates an immediate DCCP-SyncAck in response, the endpoint will have a pretty good idea of when a probe is lost.",
      "ja": "DCCPも上方DCCP終点は、DFがセットされた小さなパケットを送信することによって開始し、パケットが失われるまで、徐々にパケットサイズが増加PMTU [PMTUD]のプロービングを可能にします。このメカニズムは、任意のICMPエラー処理を必要としません。 DCCP-Syncのプローブは、アプリケーションのデータ損失のリスクはありませんので、DCCP-Syncのパケットは、上向きの探査のための最良の選択です。 DCCP実装は、正しい長さのパケットをパディング、DCCP-Syncアプリケーション領域に任意のデータを挿入します。すべての有効なDCCP-Syncは応答して即時DCCP-SyncAckを生成しているため、エンドポイントは、プローブが失われた場合のかなり良いアイデアを持っています。"
    },
    {
      "indent": 0,
      "text": "14.2. Sender Behavior",
      "section_title": true,
      "ja": "14.2. 送信者の行動"
    },
    {
      "indent": 3,
      "text": "A DCCP sender SHOULD send every packet as unfragmentable, as described above, with the following exceptions.",
      "ja": "以下の例外を除いて、上記のようにDCCPの送信者は、フラグメント化不能としてすべてのパケットを送信すべきです。"
    },
    {
      "indent": 3,
      "text": "o On IPv4 connections whose applications have requested fragmentation, the sender SHOULD send packets with the DF bit not set.",
      "ja": "Oそのアプリケーションの断片化を要求したIPv4接続では、送信者はDFビットが設定されていないとパケットを送信すべきです。"
    },
    {
      "indent": 3,
      "text": "o On IPv6 connections whose applications have requested fragmentation, the sender SHOULD use fragmentation extension headers to fragment packets larger than PMTU into suitably-sized chunks. (Those chunks are, of course, unfragmentable.)",
      "ja": "Oそのアプリケーションの断片化を要求したIPv6接続では、送信者は、適切なサイズのチャンクにPMTUより大きいパケットを断片化するフラグメンテーション拡張ヘッダを使用するべきです。 （これらのチャンクは、当然のことながら、フラグメント化不能です。）"
    },
    {
      "indent": 3,
      "text": "o It is undesirable for PMTU discovery to occur on the initial connection setup handshake, as the connection setup process may not be representative of packet sizes used during the connection, and performing MTU discovery on the initial handshake might unnecessarily delay connection establishment. Thus, DCCP-Request and DCCP-Response packets SHOULD be sent as fragmentable. In addition, DCCP-Reset packets SHOULD be sent as fragmentable, although typically these would be small enough to not be a problem. For IPv4 connections, these packets SHOULD be sent with the DF bit not set; for IPv6 connections, they SHOULD be preemptively fragmented to a size not larger than the relevant interface MTU.",
      "ja": "PMTU発見は、接続設定処理は、接続中に使用されるパケットサイズの代表ではないかもしれないように、初期接続設定ハンドシェイクで発生することが、初期ハンドシェークにMTU探索を行うことが不必要に接続確立を遅らせる可能性があるため、Oそれは望ましくありません。したがって、DCCP-要求とDCCP-応答パケットがフラグメント化として送ってください。通常、これらは問題にならないほど十分に小さいだろうが、また、DCCP-リセットパケットは、フラグメント化として送ってください。 IPv4接続のために、これらのパケットはDFビットが設定されていないと送信されるべきです。 IPv6接続のために、彼らは、関連するインターフェイスMTUより大きくないサイズに先制断片化であるべきです。"
    },
    {
      "indent": 3,
      "text": "If the DCCP implementation has decreased the PMTU, the sending application has not requested fragmentation, and the sending application attempts to send a packet larger than the new MPS, the API MUST refuse to send the packet and return an appropriate error to the application. The application should then use the API to query the new value of MPS. The kernel might have some packets buffered for transmission that are smaller than the old MPS but larger than the new MPS. It MAY send these packets as fragmentable, or it MAY discard these packets; it MUST NOT send them as unfragmentable.",
      "ja": "DCCP実装がPMTUを減少している場合は、送信側アプリケーションは、断片化を要求していない、と送信アプリケーションが新しいMPSよりも大きいパケットを送信しようと、APIは、パケットを送信し、アプリケーションに適切なエラーを返すことを拒否しなければなりません。次に、アプリケーションは、MPSの新しい値を照会するAPIを使用する必要があります。カーネルは古いMPSよりも小さいが、新しいMPSより大きい伝送のためにバッファいくつかのパケットがあるかもしれません。これは、フラグメント化として、これらのパケットを送信することができ、またはそれは、これらのパケットを捨てるかもしれ。それは、フラグメント化不能としてそれらを送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "15. Forward Compatibility",
      "section_title": true,
      "ja": "15.上位互換性"
    },
    {
      "indent": 3,
      "text": "Future versions of DCCP may add new options and features. A few simple guidelines will let extended DCCPs interoperate with normal DCCPs.",
      "ja": "DCCPの将来のバージョンでは、新しいオプションと機能を追加することができます。いくつかの簡単なガイドラインは、拡張DCCPsが通常のDCCPsと相互運用できるようになります。"
    },
    {
      "indent": 3,
      "text": "o DCCP processors MUST NOT act punitively towards options and features they do not understand. For example, DCCP processors MUST NOT reset the connection if some field marked Reserved in this specification is non-zero; if some unknown option is present; or if some feature negotiation option mentions an unknown feature. Instead, DCCP processors MUST ignore these events. The Mandatory option is the single exception: if Mandatory precedes some unknown option or feature, the connection MUST be reset.",
      "ja": "O DCCPプロセッサは、彼らが理解していないオプションや機能に向けてpunitively行動してはなりません。いくつかのフィールドは、この仕様では予約がゼロでマークされている場合たとえば、DCCPプロセッサは、接続をリセットしてはいけません。いくつかの未知のオプションが存在する場合、またはいくつかの特徴交渉オプションは、未知の機能を言及している場合。代わりに、DCCPプロセッサは、これらのイベントを無視しなければなりません。必須オプションは、単一の例外である：必須のいくつかの未知のオプションや機能を先行している場合、接続をリセットする必要があります。"
    },
    {
      "indent": 3,
      "text": "o DCCP processors MUST anticipate the possibility of unknown feature values, which might occur as part of a negotiation for a known feature. For server-priority features, unknown values are handled as a matter of course: since the non-extended DCCP's priority list will not contain unknown values, the result of the negotiation cannot be an unknown value. A DCCP MUST respond with an empty Confirm option if it is assigned an unacceptable value for some non-negotiable feature.",
      "ja": "O DCCPプロセッサは、既知の機能のための交渉の一環として発生する可能性のある未知の特徴値、の可能性を予測しなければなりません。サーバー優先順位の機能については、未知の値は、当然のこととして扱われる：非拡張DCCPの優先順位リストが未知の値が含まれないため、交渉の結果は未知の値にすることはできません。それはいくつかの非交渉機能のために許容できない値が割り当てられている場合DCCPは、空のConfirmオプションで応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Each DCCP extension SHOULD be controlled by some feature. The default value of this feature SHOULD correspond to \"extension not available\". If an extended DCCP wants to use the extension, it SHOULD attempt to change the feature's value using a Change L or Change R option. Any non-extended DCCP will ignore the option, thus leaving the feature value at its default, \"extension not available\".",
      "ja": "O各DCCP拡張子は、一部の機能によって制御されなければなりません。この機能のデフォルト値は「利用できない拡張子」に対応する必要があります。拡張DCCP拡張子を使用したい場合は、変更Lまたは変更Rオプションを使用して機能の値を変更しようとすべきです。任意の非拡張DCCPは、「拡張子が使用できない」、これはデフォルトで特徴値を残して、オプションを無視します。"
    },
    {
      "indent": 3,
      "text": "Section 19 lists DCCP assigned numbers reserved for experimental and testing purposes.",
      "ja": "実験やテストの目的のために予約セクション19本のリストDCCP割り当てられた番号。"
    },
    {
      "indent": 0,
      "text": "16. Middlebox Considerations",
      "section_title": true,
      "ja": "16.ミドルの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes properties of DCCP that firewalls, network address translators, and other middleboxes should consider, including parts of the packet that middleboxes should not change. The intent is to draw attention to aspects of DCCP that may be useful, or dangerous, for middleboxes, or that differ significantly from TCP.",
      "ja": "このセクションでは、ファイアウォール、ネットワークアドレス変換、およびその他のミドルボックスは、ミドルボックスは変更されないパケットの部分を含め、検討すべきであることをDCCPのプロパティについて説明します。その意図は、ミドルボックスのために、有益な、または危険かもしれDCCPの側面に注意を引くためにある、またはそれはTCPとは大きく異なります。"
    },
    {
      "indent": 3,
      "text": "The Service Code field in DCCP-Request packets provides information that may be useful for stateful middleboxes. With Service Code, a middlebox can tell what protocol a connection will use without relying on port numbers. Middleboxes can disallow connections that attempt to access unexpected services by sending a DCCP-Reset with Reset Code 8, \"Bad Service Code\". Middleboxes should not modify the Service Code unless they are really changing the service a connection is accessing.",
      "ja": "DCCP-Requestパケットにおけるサービスコードフィールドには、ステートフルミドルボックスのために有用である可能性がある情報を提供します。サービスコードを使用すると、ミドルは、接続がポート番号に依存せずに使用するどのようなプロトコルを伝えることができます。ミドルボックスはリセットコード8、「悪い接客規範」とDCCP-リセットを送信することにより、予期しないサービスにアクセスしようとの接続を禁止することができます。彼らは本当に接続がアクセスしているサービスを変更されない限り、ミドルボックスは、サービスコードを変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "The Source and Destination Port fields are in the same packet locations as the corresponding fields in TCP and UDP, which may simplify some middlebox implementations.",
      "ja": "送信元と宛先ポートフィールドは、いくつかのミドル実装を簡素化する可能性がある、TCPとUDPの対応するフィールドと同じパケット位置にあります。"
    },
    {
      "indent": 3,
      "text": "The forward compatibility considerations in Section 15 apply to middleboxes as well. In particular, middleboxes generally shouldn't act punitively towards options and features they do not understand.",
      "ja": "第15節で、前方互換性に関する考慮事項は、同様にミドルボックスに適用されます。特に、ミドルボックスは、一般的に、彼らは理解していないオプションや機能に向けてpunitively行動するべきではありません。"
    },
    {
      "indent": 3,
      "text": "Modifying DCCP Sequence Numbers and Acknowledgement Numbers is more tedious and dangerous than modifying TCP sequence numbers. A middlebox that added packets to or removed packets from a DCCP connection would have to modify acknowledgement options, such as Ack Vector, and CCID-specific options, such as TFRC's Loss Intervals, at minimum. On ECN-capable connections, the middlebox would have to keep track of ECN Nonce information for packets it introduced or removed, so that the relevant acknowledgement options continued to have correct ECN Nonce Echoes, or risk the connection being reset for \"Aggression Penalty\". We therefore recommend that middleboxes not modify packet streams by adding or removing packets.",
      "ja": "DCCPシーケンス番号と確認応答番号を変更すると、TCPのシーケンス番号を変更するよりも手間と危険です。 DCCP接続からのパケットまたは削除パケットを添加ミドルボックスは、最小で、そのような肯定応答ベクトル、及びそのようなTFRCの損失区間としてCCID特有のオプションとして、確認応答オプションを変更しなければなりません。 ECN対応の接続では、ミドルは、関連する確認応答オプションが正しいECNのNonceエコーズを持っている、または「侵略ペナルティ」の接続がリセットされるリスクを継続するように、それが導入または削除パケットにECNナンス情報を追跡する必要があります。したがって、我々は、ミドルボックスは、パケットを追加または削除することによって、パケットストリームを変更しないことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Note that there is less need to modify DCCP's per-packet sequence numbers than to modify TCP's per-byte sequence numbers; for example, a middlebox can change the contents of a packet without changing its sequence number. (In TCP, sequence number modification is required to support protocols like FTP that carry variable-length addresses in the data stream. If such an application were deployed over DCCP, middleboxes would simply grow or shrink the relevant packets as necessary without changing their sequence numbers. This might involve fragmenting the packet.)",
      "ja": "TCPのバイトあたりのシーケンス番号を変更するよりも、DCCPのパケットごとのシーケンス番号を変更するには以下が必要であることに注意してください。例えば、ミドルボックスは、そのシーケンス番号を変更することなく、パケットの内容を変更することができます。 （TCPでは、シーケンス番号の変更は、データストリーム内の可変長アドレスを運ぶFTPなどのプロトコルをサポートする必要がある。そのようなアプリケーションがDCCP上に展開した場合、中間装置は、単に、それらのシーケンス番号を変更することなく、必要に応じて、関連するパケットを拡大または縮小なります。これは、パケットを断片伴うかもしれません。）"
    },
    {
      "indent": 3,
      "text": "Middleboxes may, of course, reset connections in progress. Clearly, this requires inserting a packet into one or both packet streams, but the difficult issues do not arise.",
      "ja": "Middleboxesは、当然のことながら、進行中の接続をリセットすることがあります。明らかに、これは一方または両方のパケット・ストリームにパケットを挿入する必要がありますが、困難な問題は発生しません。"
    },
    {
      "indent": 3,
      "text": "DCCP is somewhat unfriendly to \"connection splicing\" [SHHP00], in which clients' connection attempts are intercepted, but possibly later \"spliced in\" to external server connections via sequence number manipulations. A connection splicer at minimum would have to ensure that the spliced connections agreed on all relevant feature values, which might take some renegotiation.",
      "ja": "DCCPは、クライアントの接続試行をインターセプトが、おそらく後シーケンス番号の操作を介して、外部のサーバー接続へ 『にスプライスさ』された「接続スプライシング」[SHHP00]、幾分非友好的です。最低でも接続スプライサーは、スプライシングされた接続は、いくつかの再交渉がかかる場合があります関連するすべての特徴値、に合意したことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "The contents of this section should not be interpreted as a wholesale endorsement of stateful middleboxes.",
      "ja": "このセクションの内容は、ステートフルミドルボックスの卸売承認として解釈されるべきではありません。"
    },
    {
      "indent": 0,
      "text": "17. Relations to Other Specifications",
      "section_title": true,
      "ja": "他の仕様との関係17"
    },
    {
      "indent": 0,
      "text": "17.1. RTP",
      "section_title": true,
      "ja": "17.1.  RTP"
    },
    {
      "indent": 3,
      "text": "The Real-Time Transport Protocol, RTP [RFC3550], is currently used over UDP by many of DCCP's target applications (for instance, streaming media). Therefore, it is important to examine the relationship between DCCP and RTP and, in particular, the question of whether any changes in RTP are necessary or desirable when it is layered over DCCP instead of UDP.",
      "ja": "リアルタイムトランスポートプロトコル、RTP [RFC3550]は、現在、（例えば、ストリーミングメディア）DCCPのターゲットアプリケーションの多くでUDP上で使用されています。したがって、DCCPおよびRTPおよび、特に、それはDCCPの代わりにUDP上に積層されたときRTPの変更が必要又は望ましいかどうかの問題との関係を検討することが重要です。"
    },
    {
      "indent": 3,
      "text": "There are two potential sources of overhead in the RTP-over-DCCP combination: duplicated acknowledgement information and duplicated sequence numbers. Together, these sources of overhead add slightly more than 4 bytes per packet relative to RTP-over-UDP, and eliminating the redundancy would not reduce the overhead.",
      "ja": "重複確認応答情報と重複配列番号：2つのRTPオーバーDCCPの組み合わせでオーバーヘッドの潜在的な原因があります。一緒に、オーバーヘッドのこれらのソースは、RTPオーバーUDPパケットに比べ当たりわずかに4よりバイトを追加し、冗長性を排除することはオーバーヘッドを削減しないであろう。"
    },
    {
      "indent": 3,
      "text": "First, consider acknowledgements. Both RTP and DCCP report feedback about loss rates to data senders, via RTP Control Protocol Sender and Receiver Reports (RTCP SR/RR packets) and via DCCP acknowledgement options. These feedback mechanisms are potentially redundant. However, RTCP SR/RR packets contain information not present in DCCP acknowledgements, such as \"interarrival jitter\", and DCCP's acknowledgements contain information not transmitted by RTCP, such as the ECN Nonce Echo. Neither feedback mechanism makes the other redundant.",
      "ja": "まず、確認応答を考えます。 RTPとRTP制御プロトコルのSenderとReceiverレポート（RTCP SR / RRパケット）を経由し、DCCPの承認オプションを介してデータの送信者への損失率についてDCCPレポートフィードバック、どちらも。これらのフィードバック機構は、潜在的に冗長です。しかし、RTCP SR / RRパケットは、「到着間ジッタ」としてDCCP確認応答、に存在しない情報を含み、DCCPの肯定応答は、ECNノンスエコーとしてRTCPによって送信されない情報を含みます。どちらのフィードバック機構は、他の冗長になります。"
    },
    {
      "indent": 3,
      "text": "Sending both types of feedback need not be particularly costly either. RTCP reports may be sent relatively infrequently: once every 5 seconds on average, for low-bandwidth flows. In DCCP, some feedback mechanisms are expensive -- Ack Vector, for example, is frequent and verbose -- but others are relatively cheap: CCID 3 (TFRC) acknowledgements take between 16 and 32 bytes of options sent once per round-trip time. (Reporting less frequently than once per RTT would make congestion control less responsive to loss.) We therefore conclude that acknowledgement overhead in RTP-over-DCCP need not be significantly higher than for RTP-over-UDP, at least for CCID 3.",
      "ja": "フィードバックの両方のタイプを送信すると、いずれか、特に、高価である必要はありません。 RTCPレポートは、比較的低い頻度で送信されてよい：5秒ごとの平均で、低帯域幅のフローのために。 DCCPでは、いくつかのフィードバック機構は高価である - のAckベクトルは、例えば、頻繁に冗長である - しかし、他のものは、比較的安価である：CCID 3（TFRC）確認応答は、ラウンドトリップ時間ごとに一度送信されたオプションの16と32バイトとの間に取ります。 （それほど頻繁に一度RTTあたりより報告は損失に輻輳制御はあまり反応するだろう。）したがって、我々は、RTPオーバーDCCPに確認応答のオーバーヘッドを締結少なくともCCID 3のために、RTPオーバーUDPに比べて有意に高くある必要はありません。"
    },
    {
      "indent": 3,
      "text": "One clear redundancy can be addressed at the application level. The verbose packet-by-packet loss reports sent in RTCP Extended Reports Loss RLE Blocks [RFC3611] can be derived from DCCP's Ack Vector options. (The converse is not true, since Loss RLE Blocks contain no ECN information.) Since DCCP implementations should provide an API for application access to Ack Vector information, RTP-over-DCCP applications might request either DCCP Ack Vectors or RTCP Extended Report Loss RLE Blocks, but not both.",
      "ja": "一つの明確な冗長性は、アプリケーションレベルで対処することができます。 RTCP拡張レポート消失RLEブロック[RFC3611]で送信された冗長パケットごとの損失レポートはDCCPのAckをベクトルオプションから導出することができます。 （損失RLEブロックは何のECN情報を含んでいないので、逆は真ではありません。）DCCPの実装がAckでベクトル情報へのアプリケーションアクセスのためのAPIを提供しなければならないので、RTPオーバーDCCPアプリケーションがDCCPのAckなベクターまたはRTCPのいずれかの拡張レポート損失RLEを要求するかもしれませんブロック、両方ではありません。"
    },
    {
      "indent": 3,
      "text": "Now consider sequence number redundancy on data packets. The embedded RTP header contains a 16-bit RTP sequence number. Most data packets will use the DCCP-Data type; DCCP-DataAck and DCCP-Ack packets need not usually be sent. The DCCP-Data header is 12 bytes long without options, including a 24-bit sequence number. This is 4 bytes more than a UDP header. Any options required on data packets would add further overhead, although many CCIDs (for instance, CCID 3, TFRC) don't require options on most data packets.",
      "ja": "今、データパケットのシーケンス番号の冗長性を考慮してください。埋め込まれたRTPヘッダは、16ビットのRTPシーケンス番号を含みます。ほとんどのデータ・パケットは、DCCP-データ型を使用します。 DCCP-DataAckとDCCP-Ackのパケットが送信され、通常は必要はありません。 DCCP-データヘッダは、24ビットのシーケンス番号を含むオプションなしで12バイト長です。これは、UDPヘッダより4バイト以上です。多くのCCIDs（例えば、CCID 3、TFRC）は、ほとんどのデータ・パケットのオプションを必要としませんが、データパケットに必要なオプションは、さらにオーバーヘッドを追加します。"
    },
    {
      "indent": 3,
      "text": "The DCCP sequence number cannot be inferred from the RTP sequence number since it increments on non-data packets as well as data packets. The RTP sequence number cannot be inferred from the DCCP sequence number either [RFC3550]. Furthermore, removing RTP's sequence number would not save any header space because of alignment issues. We therefore recommend that RTP transmitted over DCCP use the same headers currently defined. The 4 byte header cost is a reasonable tradeoff for DCCP's congestion control features and access to ECN. Truly bandwidth-starved endpoints should use some header compression scheme.",
      "ja": "それは非データ・パケットとデータ・パケットにインクリメントするので、DCCPシーケンス番号は、RTPシーケンス番号から推測することができません。 RTPシーケンス番号は、DCCP配列番号のいずれか[RFC3550]から推論することはできません。さらに、RTPのシーケンス番号を削除すると、理由は、アライメントの問題のいずれかのヘッダースペースを保存しないでしょう。したがって、我々は、DCCPを介して送信RTPは、現在定義されている同じヘッダーを使用することをお勧めします。 4バイトのヘッダコストはDCCPの輻輳制御機能やECNへのアクセスのための合理的なトレードオフです。真に帯域飢餓エンドポイントは、いくつかのヘッダ圧縮スキームを使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "17.2. Congestion Manager and Multiplexing",
      "section_title": true,
      "ja": "17.2. 輻輳管理および多重化"
    },
    {
      "indent": 3,
      "text": "Since DCCP doesn't provide reliable, ordered delivery, multiple application sub-flows may be multiplexed over a single DCCP connection with no inherent performance penalty. Thus, there is no need for DCCP to provide built-in support for multiple sub-flows. This differs from SCTP [RFC2960].",
      "ja": "DCCPは信頼性が得られないため、配信を命じ、複数のアプリケーションのサブフローはない本来の性能ペナルティを有する単一のDCCP接続を介して多重化されてもよいです。このように、DCCPは、複数のサブフローのビルトインサポートを提供するための必要はありません。これは、SCTP [RFC2960]とは異なります。"
    },
    {
      "indent": 3,
      "text": "Some applications might want to share congestion control state among multiple DCCP flows that share the same source and destination addresses. This functionality could be provided by the Congestion Manager [RFC3124], a generic multiplexing facility. However, the CM would not fully support DCCP without change; it does not gracefully handle multiple congestion control mechanisms, for example.",
      "ja": "一部のアプリケーションは、同じ送信元アドレスと宛先アドレスを共有する複数のDCCPの流れの中で輻輳制御状態を共有したい場合があります。この機能は、輻輳マネージャ[RFC3124]、一般的な多重化機能によって提供することができます。しかし、CMは完全に変更することなく、DCCPをサポートしていません。それは優雅例えば、複数の輻輳制御機構を扱いません。"
    },
    {
      "indent": 0,
      "text": "18. Security Considerations",
      "section_title": true,
      "ja": "18.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "DCCP does not provide cryptographic security guarantees. Applications desiring cryptographic security services (integrity, authentication, confidentiality, access control, and anti-replay protection) should use IPsec or end-to-end security of some kind; Secure RTP is one candidate protocol [RFC3711].",
      "ja": "DCCPは、暗号化セキュリティ保証を提供していません。暗号化セキュリティサービス（整合性、認証、機密性、アクセス制御、およびアンチリプレイ保護を）希望するアプリケーションは、IPsecを使用するか、いくつかの種類のエンドツーエンドのセキュリティ必要があります。セキュアRTPは、一つの候補プロトコル[RFC3711]です。"
    },
    {
      "indent": 3,
      "text": "Nevertheless, DCCP is intended to protect against some classes of attackers: Attackers cannot hijack a DCCP connection (close the connection unexpectedly, or cause attacker data to be accepted by an endpoint as if it came from the sender) unless they can guess valid sequence numbers. Thus, as long as endpoints choose initial sequence numbers well, a DCCP attacker must snoop on data packets to get any reasonable probability of success. Sequence number validity checks provide this guarantee. Section 7.5.5 describes sequence number security further. This security property only holds assuming that DCCP's random numbers are chosen according to the guidelines in [RFC4086].",
      "ja": "それにも関わらず、DCCPは攻撃のいくつかのクラスに対して保護することを意図している：彼らは、有効なシーケンス番号を推測することができない限り、攻撃者は、DCCPコネクション（予期せず接続を閉じ、またはそれは、送信者から来たかのように攻撃者のデータは、エンドポイントで受け入れられるために原因を）乗っ取ることができません。このように、エンドポイントがうまく初期シーケンス番号を選択する限り、DCCPの攻撃者は、成功のいずれかの合理的な確率を取得するために、データパケットをスヌーピングしなければなりません。シーケンス番号の有効性チェックは、この保証を提供しています。 7.5.5項では、さらに、シーケンス番号のセキュリティを説明します。このセキュリティプロパティは、DCCPの乱数は、[RFC4086]のガイドラインに従って選択されていると仮定して保持しています。"
    },
    {
      "indent": 3,
      "text": "DCCP also provides mechanisms to limit the potential impact of some denial-of-service attacks. These mechanisms include Init Cookie (Section 8.1.4), the DCCP-CloseReq packet (Section 5.5), the Application Not Listening Drop Code (Section 11.7.2), limitations on the processing of options that might cause connection reset (Section 7.5.5), limitations on the processing of some ICMP messages (Section 14.1), and various rate limits, which let servers avoid extensive computation or packet generation (Sections 7.5.3, 8.1.3, and others).",
      "ja": "DCCPはまた、いくつかのサービス拒否攻撃の潜在的な影響を制限するためのメカニズムを提供します。これらのメカニズムは、初期クッキー（セクション8.1.4）、DCCP-CloseReqパケット（5.5節）、ドロップコード（セクション11.7.2）を聞いていないアプリケーションを含む、接続リセット（7.5節を引き起こす可能性がありますオプションの処理に関する制限。 5）サーバをさせ、いくつかのICMPメッセージ（セクション14.1）、および種々のレート制限の処理上の制限は広範計算やパケット生成（セクション7.5.3、8.1.3など）を避けます。"
    },
    {
      "indent": 3,
      "text": "DCCP provides no protection against attackers that can snoop on data packets.",
      "ja": "DCCPは、データパケットをスヌーピングすることができ、攻撃者に対する保護機能はありません。"
    },
    {
      "indent": 0,
      "text": "18.1. Security Considerations for Partial Checksums",
      "section_title": true,
      "ja": "18.1. 部分的なチェックサムのためのセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The partial checksum facility has a separate security impact, particularly in its interaction with authentication and encryption mechanisms. The impact is the same in DCCP as in the UDP-Lite protocol, and what follows was adapted from the corresponding text in the UDP-Lite specification [RFC3828].",
      "ja": "部分的なチェックサム機能は、特に認証と暗号化メカニズムとの相互作用では、個別のセキュリティ影響を有します。衝撃は、UDP-LiteのプロトコルとDCCPに同じであり、何以下がUDP-Liteの仕様[RFC3828]に対応するテキストから適合させました。"
    },
    {
      "indent": 3,
      "text": "When a DCCP packet's Checksum Coverage field is not zero, the uncovered portion of a packet may change in transit. This is contrary to the idea behind most authentication mechanisms: authentication succeeds if the packet has not changed in transit. Unless authentication mechanisms that operate only on the sensitive part of packets are developed and used, authentication will always fail for partially-checksummed DCCP packets whose uncovered part has been damaged.",
      "ja": "DCCPパケットのチェックサムカバー範囲フィールドが0でない場合、パケットの覆われていない部分は、輸送中に変更されることがあります。これは、ほとんどの認証メカニズムの背後にある考え方に反している：パケットが転送中に変更されていない場合、認証に成功しました。パケットの敏感な部分にのみ動作認証機構が開発され使用されていない限り、認証は常にその覆われていない一部損傷した部分的にチェックサムDCCPパケットのために失敗します。"
    },
    {
      "indent": 3,
      "text": "The IPsec integrity check (Encapsulation Security Protocol, ESP, or Authentication Header, AH) is applied (at least) to the entire IP packet payload. Corruption of any bit within that area will then result in the IP receiver's discarding a DCCP packet, even if the corruption happened in an uncovered part of the DCCP application data.",
      "ja": "IPsecの整合性チェック（カプセル化セキュリティプロトコル、ESP、または認証ヘッダー、AH）は、全IPパケットのペイロードに（少なくとも）を適用しています。その領域内の任意のビットの破損は、破損がDCCPアプリケーションデータの覆われていない部分で起こった場合でも、IPの受信機の廃棄DCCPパケットになります。"
    },
    {
      "indent": 3,
      "text": "When IPsec is used with ESP payload encryption, a link can not determine the specific transport protocol of a packet being forwarded by inspecting the IP packet payload. In this case, the link MUST provide a standard integrity check covering the entire IP packet and payload. DCCP partial checksums provide no benefit in this case.",
      "ja": "IPsecはESPペイロードの暗号化で使用されている場合、リンクがIPパケットのペイロードを検査することにより、転送されるパケットの特定のトランスポートプロトコルを決定することはできません。この場合、リンクはIPパケット全体とペイロードをカバーする標準の整合性チェックを提供しなければなりません。 DCCP部分的なチェックサムは、この場合には利益を提供しません。"
    },
    {
      "indent": 3,
      "text": "Encryption (e.g., at the transport or application levels) may be used. Note that omitting an integrity check can, under certain circumstances, compromise confidentiality [B98].",
      "ja": "（トランスポートまたはアプリケーションレベルで例えば）暗号化を使用することができます。 [B98]整合性チェックを省略すると、特定の状況下で、機密性を損なう可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If a few bits of an encrypted packet are damaged, the decryption transform will typically spread errors so that the packet becomes too damaged to be of use. Many encryption transforms today exhibit this behavior. There exist encryption transforms, stream ciphers, that do not cause error propagation. Proper use of stream ciphers can be quite difficult, especially when authentication checking is omitted [BB01]. In particular, an attacker can cause predictable changes to the ultimate plaintext, even without being able to decrypt the ciphertext.",
      "ja": "暗号化されたパケットの数ビットが破損している場合は、パケットが有用であることがあまりにも破損したように、復号化は一般的にエラーが広がっていく変換します。多くの暗号化は、今日はこの挙動を示す変換します。エラー伝播を引き起こさない暗号化変換、ストリーム暗号は、存在します。ストリーム暗号の適切な使用は、認証チェックは、[BB01]省略されている場合は特に、非常に難しいことができます。具体的には、攻撃者がさえ暗号文を解読できず、最終的に平文に予測可能な変化を引き起こす可能性があります。"
    },
    {
      "indent": 0,
      "text": "19. IANA Considerations",
      "section_title": true,
      "ja": "19. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has assigned IP Protocol Number 33 to DCCP.",
      "ja": "IANAは、DCCPにIPプロトコル番号33を割り当てています。"
    },
    {
      "indent": 3,
      "text": "DCCP introduces eight sets of numbers whose values should be allocated by IANA. We refer to allocation policies, such as Standards Action, outlined in [RFC2434], and most registries reserve some values for experimental and testing use [RFC3692]. In addition, DCCP requires that the IANA Port Numbers registry be opened for DCCP port registrations; Section 19.9 describes how. The IANA should feel free to contact the DCCP Expert Reviewer with questions on any registry, regardless of the registry policy, for clarification or if there is a problem with a request.",
      "ja": "DCCPは値IANAによって割り当てられるべき数字の8セットを紹介します。私たちは、[RFC2434]に概説され、このような標準化アクションとして割り当てポリシー、を参照してください、そしてほとんどのレジストリは、実験と[RFC3692]を使用してテストするためのいくつかの値を予約します。また、DCCPは、IANAポート番号のレジストリがDCCPポートの登録のために開かれることを必要とします。セクション19.9はどのように説明しています。 IANAは、明確化のためにまたは要求に問題がある場合は、関係なく、レジストリポリシーの、いずれかのレジストリ上の質問でDCCPエキスパートレビューに連絡して自由に感じるはずです。"
    },
    {
      "indent": 0,
      "text": "19.1. Packet Types Registry",
      "section_title": true,
      "ja": "19.1. パケットタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "Each entry in the DCCP Packet Types registry contains a packet type, which is a number in the range 0-15; a packet type name, such as DCCP-Request; and a reference to the RFC defining the packet type. The registry is initially populated using the values in Table 1 (Section 5.1). This document allocates packet types 0-9, and packet type 14 is permanently reserved for experimental and testing use. Packet types 10-13 and 15 are currently reserved and should be allocated with the Standards Action policy, which requires IESG review and approval and standards-track IETF RFC publication.",
      "ja": "DCCPパケットタイプレジストリ内の各エントリは、0〜15の数であり、パケットタイプを含み、このようDCCP-要求などのパケットタイプ名;パケットタイプを定義するRFCを参照。レジストリは、最初の表1（セクション5.1）の値を使用して取り込まれます。この文書では、パケットタイプ0-9を割り当て、パケットタイプ14は、永久に、実験やテストの使用のために予約されています。パケットタイプ10-13および15は、現在予約されており、IESGレビューと承認を必要とし、IETF RFC公表を標準トラック標準アクションポリシー、で割り当てる必要があります。"
    },
    {
      "indent": 0,
      "text": "19.2. Reset Codes Registry",
      "section_title": true,
      "ja": "19.2. コードレジストリをリセット"
    },
    {
      "indent": 3,
      "text": "Each entry in the DCCP Reset Codes registry contains a Reset Code, which is a number in the range 0-255; a short description of the Reset Code, such as \"No Connection\"; and a reference to the RFC defining the Reset Code. The registry is initially populated using the values in Table 2 (Section 5.6). This document allocates Reset Codes 0-11, and Reset Codes 120-126 are permanently reserved for experimental and testing use. Reset Codes 12-119 and 127 are currently reserved and should be allocated with the IETF Consensus policy, requiring an IETF RFC publication (standards track or not) with IESG review and approval. Reset Codes 128-255 are permanently reserved for CCID-specific registries; each CCID Profile document describes how the corresponding registry is managed.",
      "ja": "DCCPの各エントリは、レジストリは、0〜255の範囲内の数であり、リセットコードを含み、コードをリセット。そのような「接続なし」としてリセットコードの短い説明。そして、リセットコードを定義するRFCへの参照。レジストリは、最初の表2（セクション5.6）の値を使用して取り込まれます。この文書では、リセットコード0-11を割り当て、120-126は、永久に、実験やテストの使用のために予約されているコードをリセットします。コード12から119及び127は、現在予約されており、IESGレビューと承認を得てIETF RFC刊行物（標準化過程かどうか）を必要とする、IETFコンセンサスポリシーに割り当てるべきリセット。 128-255は、永久にCCID特有の登録簿のために予約されているコードをリセットします。各CCIDプロフィール文書は、対応するレジストリが管理されている方法について説明します。"
    },
    {
      "indent": 0,
      "text": "19.3. Option Types Registry",
      "section_title": true,
      "ja": "19.3. オプションの種類レジストリ"
    },
    {
      "indent": 3,
      "text": "Each entry in the DCCP option types registry contains an option type, which is a number in the range 0-255; the name of the option, such as \"Slow Receiver\"; and a reference to the RFC defining the option type. The registry is initially populated using the values in Table 3 (Section 5.8). This document allocates option types 0-2 and 32-44,",
      "ja": "DCCPオプションタイプレジストリ内の各エントリは、0〜255の範囲内の数であり、オプションタイプを含み、そのような「スローレシーバー」としてオプションの名前、;およびオプションタイプを定義するRFCへの参照。レジストリは、最初の表3（セクション5.8）の値を使用して取り込まれます。この文書では、オプションの種類0-2と32-44割り当て"
    },
    {
      "indent": 3,
      "text": "and option types 31 and 120-126 are permanently reserved for experimental and testing use. Option types 3-30, 45-119, and 127 are currently reserved and should be allocated with the IETF Consensus policy, requiring an IETF RFC publication (standards track or not) with IESG review and approval. Option types 128-255 are permanently reserved for CCID-specific registries; each CCID Profile document describes how the corresponding registry is managed.",
      "ja": "およびオプションの種類31および120-126は、永久に、実験やテスト用に予約されています。オプションの種類3-30、45から119、及び127は、現在予約されており、IESGレビューと承認を得てIETF RFC刊行物（標準化過程かどうか）を必要とする、IETFコンセンサスポリシーに割り当てられるべきです。オプションタイプ128-255は恒久的にCCID特有の登録簿のために予約されています。各CCIDプロフィール文書は、対応するレジストリが管理されている方法について説明します。"
    },
    {
      "indent": 0,
      "text": "19.4. Feature Numbers Registry",
      "section_title": true,
      "ja": "19.4. フィーチャー番号レジストリ"
    },
    {
      "indent": 3,
      "text": "Each entry in the DCCP feature numbers registry contains a feature number, which is a number in the range 0-255; the name of the feature, such as \"ECN Incapable\"; and a reference to the RFC defining the feature number. The registry is initially populated using the values in Table 4 (Section 6). This document allocates feature numbers 0-9, and feature numbers 120-126 are permanently reserved for experimental and testing use. Feature numbers 10-119 and 127 are currently reserved and should be allocated with the IETF Consensus policy, requiring an IETF RFC publication (standards track or not) with IESG review and approval. Feature numbers 128-255 are permanently reserved for CCID-specific registries; each CCID Profile document describes how the corresponding registry is managed.",
      "ja": "DCCP機能番号レジストリ内の各エントリは、0〜255の範囲内の数である機能数が含まれ;こうした「ECNできない」などの機能の名前、;そして、機能番号を定義するRFCへの参照。レジストリは、最初の表4（第6節）の値を使用して取り込まれます。この文書では、機能番号0-9、および120-126は、永久に、実験やテストの使用のために予約されている機能番号を割り当てます。機能番号10から119及び127は、現在予約されており、IESGレビューと承認を得てIETF RFC刊行物（標準化過程かどうか）を必要とする、IETFコンセンサスポリシーに割り当てられるべきです。フィーチャー番号128-255は、恒久的にCCID特有の登録簿のために予約されています。各CCIDプロフィール文書は、対応するレジストリが管理されている方法について説明します。"
    },
    {
      "indent": 0,
      "text": "19.5. Congestion Control Identifiers Registry",
      "section_title": true,
      "ja": "19.5. 輻輳制御識別子レジストリ"
    },
    {
      "indent": 3,
      "text": "Each entry in the DCCP Congestion Control Identifiers (CCIDs) registry contains a CCID, which is a number in the range 0-255; the name of the CCID, such as \"TCP-like Congestion Control\"; and a reference to the RFC defining the CCID. The registry is initially populated using the values in Table 5 (Section 10). CCIDs 2 and 3 are allocated by concurrently published profiles, and CCIDs 248-254 are permanently reserved for experimental and testing use. CCIDs 0, 1, 4-247, and 255 are currently reserved and should be allocated with the IETF Consensus policy, requiring an IETF RFC publication (standards track or not) with IESG review and approval.",
      "ja": "DCCP輻輳制御識別子（のCCIDs）内の各エントリは、レジストリは、0〜255の範囲の数でありCCIDを含み、例えば、「TCP-のような輻輳制御」などCCIDの名前、;そしてCCIDを定義するRFCを参照。レジストリは、最初の表5（第10項）の値を使用して取り込まれます。 CCIDs 2及び3を同時に公開されたプロファイルによって割り当てられ、そして248-254のCCIDsは恒久的実験および試験使用のために予約されています。 CCIDs 0、1、4から247、および255は、現在予約されており、IESGレビューと承認を得てIETF RFC刊行物（標準化過程かどうか）を必要とする、IETFコンセンサスポリシーに割り当てられるべきです。"
    },
    {
      "indent": 0,
      "text": "19.6. Ack Vector States Registry",
      "section_title": true,
      "ja": "19.6.  Ackベクトル州レジストリ"
    },
    {
      "indent": 3,
      "text": "Each entry in the DCCP Ack Vector States registry contains an Ack Vector State, which is a number in the range 0-3; the name of the State, such as \"Received ECN Marked\"; and a reference to the RFC defining the State. The registry is initially populated using the values in Table 6 (Section 11.4). This document allocates States 0, 1, and 3. State 2 is currently reserved and should be allocated with the Standards Action policy, which requires IESG review and approval and standards-track IETF RFC publication.",
      "ja": "DCCPのAckベクトル国レジストリの各エントリは、範囲0〜3の数字であるのAckベクトルの状態を、含まれています。以下のような国の名前は、「ECNはマーク、受信しました」;そして、状態を定義するRFCへの参照。レジストリは、最初の表6（セクション11.4）の値を使用して取り込まれます。この文書は、米国0、1を割り当て、3ステート2は、現在予約されており、IESGレビューと承認を必要とし、IETF RFC公表を標準トラック標準アクションポリシー、で割り当てる必要があります。"
    },
    {
      "indent": 0,
      "text": "19.7. Drop Codes Registry",
      "section_title": true,
      "ja": "19.7. ドロップコードレジストリ"
    },
    {
      "indent": 3,
      "text": "Each entry in the DCCP Drop Codes registry contains a Data Dropped Drop Code, which is a number in the range 0-7; the name of the Drop Code, such as \"Application Not Listening\"; and a reference to the RFC defining the Drop Code. The registry is initially populated using the values in Table 7 (Section 11.7). This document allocates Drop Codes 0-3 and 7. Drop Codes 4-6 are currently reserved, and should be allocated with the Standards Action policy, which requires IESG review and approval and standards-track IETF RFC publication.",
      "ja": "DCCPドロップコードレジストリの各エントリは、データが範囲0-7で数あるドロップコードを、ドロップ含まれています。例えば、「聞いていないアプリケーション」としてドロップコードの名前、;ドロップコードを定義するRFCへの参照。レジストリは、最初の表7（セクション11.7）の値を使用して取り込まれます。この文書では、ドロップコード0-3と7ドロップコードを4-6割り当て、現在予約されている、とIESGレビューと承認を必要とし、IETF RFC公表を標準トラック標準アクションポリシー、で割り当てる必要があります。"
    },
    {
      "indent": 0,
      "text": "19.8. Service Codes Registry",
      "section_title": true,
      "ja": "19.8. サービスコードレジストリ"
    },
    {
      "indent": 3,
      "text": "Each entry in the Service Codes registry contains a Service Code, which is a number in the range 0-4294967294; a short English description of the intended service; and an optional reference to an RFC or other publicly available specification defining the Service Code. The registry should list the Service Code's numeric value as a decimal number. When the Service Code may be represented in \"SC:\" format according to the rules in Section 8.1.2, the registry should also show the corresponding ASCII interpretation of the Service Code minus the \"SC:\" prefix. Thus, the number 1717858426 would additionally appear as \"fdpz\". Service Codes are not DCCP-specific. Service Code 0 is permanently reserved (it represents the absence of a meaningful Service Code), and Service Codes 1056964608-1073741823 (high byte ASCII \"?\") are reserved for Private Use. Note that 4294967295 is not a valid Service Code. Most of the remaining Service Codes are allocated First Come First Served, with no RFC publication required; exceptions are listed in Section 8.1.2. This document allocates a single Service Code, 1145656131 (\"DISC\"). This corresponds to the discard service, which discards all data sent to the service and sends no data in reply.",
      "ja": "サービスコードレジストリの各エントリには、0から4294967294の範囲の数値であるサービスコードを、含まれています。意図したサービスの短い英語の説明。そしてRFCまたは他の公的に利用可能な仕様に任意の参照は、サービスコードを定義します。レジストリは、10進数としてサービスコードの数値をリストする必要があります。サービスコードは「SC：」で表すことができるとき：接頭辞8.1.2項の規則に従ってフォーマット、レジストリはまた、サービスコードの対応するASCII解釈マイナス「SC」を示す必要があります。このように、番号1717858426は、さらに「fdpz」と表示されます。サービスコードは、DCCP-固有のものではありません。サービスコード0は永久に1056964608から1073741823（高バイトのASCII「？」）（それは意味のあるサービスコードが存在しないことを表して）予約、およびサービスコードされた私的使用のために予約されています。 4294967295が有効なサービスコードではないことに注意してください。残りのサービスコードのほとんどは、まず不要RFCの公表で、添え最初に来る割り当てられています。例外は、セクション8.1.2に記載されています。この文書は、単一のサービスコード、1145656131（「DISC」）を割り当てます。これは、サービスに送信されたすべてのデータを破棄し、応答ではデータを送信していない廃棄サービスに対応しています。"
    },
    {
      "indent": 0,
      "text": "19.9. Port Numbers Registry",
      "section_title": true,
      "ja": "19.9. ポート番号のレジストリ"
    },
    {
      "indent": 3,
      "text": "DCCP services may use contact port numbers to provide service to unknown callers, as in TCP and UDP. IANA is therefore requested to open the existing Port Numbers registry for DCCP using the following rules, which we intend to mesh well with existing Port Numbers registration procedures.",
      "ja": "DCCPのサービスは、TCPやUDPのように、未知の発信者にサービスを提供するために、連絡先のポート番号を使用することができます。 IANAは、したがって、我々は既存のポート番号の登録手順とよくメッシュしようとする次のルールを使用して、DCCPのための既存のポート番号のレジストリを開くように要求されています。"
    },
    {
      "indent": 3,
      "text": "Port numbers are divided into three ranges. The Well Known Ports are those from 0 through 1023, the Registered Ports are those from 1024 through 49151, and the Dynamic and/or Private Ports are those from 49152 through 65535. Well Known and Registered Ports are intended for use by server applications that desire a default contact point on a system. On most systems, Well Known Ports can only be used by system (or root) processes or by programs executed by privileged users, while Registered Ports can be used by ordinary user processes or programs executed by ordinary users. Dynamic and/or Private Ports are intended for temporary use, including client-side ports, out-of-band negotiated ports, and application testing prior to registration of a dedicated port; they MUST NOT be registered.",
      "ja": "ポート番号は、3つの範囲に分割されています。ウェルノウンポートが1023の0からのものであり、登録されたポートは、1024から49151によるものであり、かつ動的および/またはプライベートポート、よく知られており、登録されたポートは、サーバーアプリケーションでの使用を目的としている〜65535 49152からのものであり、望むことシステムのデフォルトの接触点。登録ポートは、通常のユーザープロセスか、通常のユーザーによって実行されるプログラムで使用することができながら、ほとんどのシステムでは、ウェルノウンポートのみが、システム（またはルート）プロセスによって、または特権ユーザーによって実行されるプログラムで使用することができます。動的および/またはプライベートポートは一時的な使用のために意図されている、専用ポートの登録に先立って、クライアント側のポート、アウトバンド交渉し、ポート、およびアプリケーションのテストを含みます。彼らは、登録してはなりません。"
    },
    {
      "indent": 3,
      "text": "The Port Numbers registry should accept registrations for DCCP ports in the Well Known Ports and Registered Ports ranges. Well Known and Registered Ports SHOULD NOT be used without registration. Although in some cases -- such as porting an application from UDP to DCCP -- it may seem natural to use a DCCP port before registration completes, we emphasize that IANA will not guarantee registration of particular Well Known and Registered Ports. Registrations should be requested as early as possible.",
      "ja": "ポート番号のレジストリは、ウェルノウンポートと登録済みポートの範囲のDCCPポートの登録を受け入れる必要があります。よく知られており、登録されたポートは、登録なしで使用されるべきではありません。そのようなUDPからDCCPにアプリケーションを移植など -   - いくつかのケースではあるが、それは登録が完了する前にDCCPポートを使用するように自然に見えるかもしれませんが、私たちは、IANAが特定のよく知られており、登録されたポートの登録を保証するものではありませんことを強調する。登録は可能な限り早期に要求されるべき。"
    },
    {
      "indent": 3,
      "text": "Each port registration SHALL include the following information:",
      "ja": "各ポートの登録は、以下の情報を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "o  A short port name, consisting entirely of letters (A-Z and a-z),\n   digits (0-9), and punctuation characters from \"-_+./*\" (not\n   including the quotes).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o The port number that is requested to be registered.",
      "ja": "O要求されているポート番号を登録します。"
    },
    {
      "indent": 3,
      "text": "o A short English phrase describing the port's purpose. This MUST include one or more space-separated textual Service Code descriptors naming the port's corresponding Service Codes (see Section 8.1.2).",
      "ja": "ポートの目的を説明する短い英語フレーズO。これは、（8.1.2項を参照）、ポートの対応するサービスコードを命名一つ以上のスペースで区切られたテキスト形式のサービスコードの記述子を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Name and contact information for the person or entity performing the registration, and possibly a reference to a document defining the port's use. Registrations coming from IETF working groups need only name the working group, but indicating a contact person is recommended.",
      "ja": "Oの名前と、おそらく個人または団体登録を実行し、ポートの使用を定義するドキュメントへの参照のための連絡先情報。 IETFワーキンググループからの登録は、ワーキンググループに名前を付ける必要はなく、担当者を示すことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Registrants are encouraged to follow these guidelines when submitting a registration.",
      "ja": "登録者は、登録を提出する際のガイドラインに従うことを奨励されています。"
    },
    {
      "indent": 3,
      "text": "o A port name SHOULD NOT be registered for more than one DCCP port number.",
      "ja": "Oポート名は、複数のDCCPポート番号に登録されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "o A port name registered for UDP MAY be registered for DCCP as well. Any such registration SHOULD use the same port number as the existing UDP registration.",
      "ja": "O UDPのために登録されているポート名は、同様にDCCPのために登録することも可能です。任意のそのような登録は、既存のUDPの登録と同じポート番号を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Concrete intent to use a port SHOULD precede port registration. For example, existing UDP ports SHOULD NOT be registered in advance of any intent to use those ports for DCCP.",
      "ja": "Oポートを使用するための具体的な目的は、ポートの登録を先行すべき。例えば、既存のUDPポートはDCCPのために、これらのポートを使用するための任意の意思を事前に登録されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "o A port name generally associated with TCP and/or SCTP SHOULD NOT be registered for DCCP, since that port name implies reliable transport. For example, we discourage registration of any \"http\" port for DCCP. However, if such a registration makes sense (that is, if there is concrete intent to use such a port), the DCCP registration SHOULD use the same port number as the existing registration.",
      "ja": "そのポート名が信頼できる輸送を意味するので、O、一般的にTCPおよび/またはSCTPに関連付けられているポート名は、DCCPのために登録されるべきではありません。たとえば、私たちはDCCPのための任意の「HTTP」のポートの登録を阻止します。そのような登録が（例えばポートを使用するための具体的な意図がある場合には、である）理にかなっている場合は、DCCP登録は、既存の登録と同じポート番号を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "o Multiple DCCP registrations for the same port number are allowed as long as the registrations' Service Codes do not overlap.",
      "ja": "Oポート番号と同じ番号に複数のDCCP登録は限り登録サービスコードが重複しないよう許可されています。"
    },
    {
      "indent": 3,
      "text": "This document registers the following port. (This should be considered a model registration.)",
      "ja": "このドキュメントでは、次のポートを登録します。 （これは、モデル登録考慮されるべきです。）"
    },
    {
      "indent": 3,
      "text": "discard 9/dccp Discard SC:DISC # IETF dccp WG, Eddie Kohler <kohler@cs.ucla.edu>, [RFC4340]",
      "ja": "DISC＃IETF DCCP WG、エディコーラー<kohler@cs.ucla.edu>、[RFC4340]：9 / DCCP破棄SCを破棄"
    },
    {
      "indent": 3,
      "text": "The discard service, which accepts DCCP connections on port 9, discards all incoming application data and sends no data in response. Thus, DCCP's discard port is analogous to TCP's discard port, and might be used to check the health of a DCCP stack.",
      "ja": "ポート9にDCCP接続を受け入れる廃棄サービスは、すべての着信アプリケーションデータを破棄し、それに応答してもデータを送信しません。このように、DCCPの廃棄ポートは、TCPの廃棄ポートに類似しており、DCCPスタックの健康状態をチェックするために使用される可能性があります。"
    },
    {
      "indent": 0,
      "text": "20. Thanks",
      "section_title": true,
      "ja": "20.感謝"
    },
    {
      "indent": 3,
      "text": "Thanks to Jitendra Padhye for his help with early versions of this specification.",
      "ja": "この仕様の初期のバージョンとの彼の助けのためのJitendra Padhyeに感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks to Junwen Lai and Arun Venkataramani, who, as interns at ICIR, built a prototype DCCP implementation. In particular, Junwen Lai recommended that the old feature negotiation mechanism be scrapped and co-designed the current mechanism. Arun Venkataramani's feedback improved Appendix A.",
      "ja": "ICIRでインターンとして、原型DCCPの実装を構築し、JunwenライとアルンVenkataramani、に感謝します。特に、Junwenライが古い特徴交渉メカニズムは、現在のメカニズムを廃棄し、共同設計されることをお勧めします。アルンVenkataramaniのフィードバック改善付録A."
    },
    {
      "indent": 3,
      "text": "We thank the staff and interns of ICIR and, formerly, ACIRI, the members of the End-to-End Research Group, and the members of the Transport Area Working Group for their feedback on DCCP. We especially thank the DCCP expert reviewers Greg Minshall, Eric Rescorla, and Magnus Westerlund for detailed written comments and problem spotting, and Rob Austein and Steve Bellovin for verbal comments and written notes. We also especially thank Aaron Falk, the working group chair during the development of this specification.",
      "ja": "私たちはDCCPの彼らのフィードバックのために、以前は、ACIRI、エンド・ツー・エンドの研究グループのメンバー、および交通地域作業部会のメンバーがスタッフとICIRのインターンに感謝して。我々は、特に口頭コメントと書かれたノートを詳細に書かれたコメントや問題スポッティングのためにDCCPの専門家の査読グレッグMinshall、エリックレスコラ、およびマグヌスウェスターに感謝し、そしてロブAusteinとスティーブBellovin氏。我々はまた、特にアーロンフォーク、この仕様の開発中にワーキンググループの議長に感謝します。"
    },
    {
      "indent": 3,
      "text": "We also thank those who provided comments and suggestions via the DCCP BOF, Working Group, and mailing lists, including Damon Lanphear, Patrick McManus, Colin Perkins, Sara Karlberg, Kevin Lai, Bernard Aboba, Youngsoo Choi, Pengfei Di, Dan Duchamp, Lars Eggert, Gorry Fairhurst, Derek Fawcus, David Timothy Fleeman, John Loughney, Ghyslain Pelletier, Hagen Paul Pfeifer, Tom Phelan, Stanislav",
      "ja": "また、デイモンLanphear、パトリック・マクマナス、コリンパーキンス、サラKarlberg、ケビン・ライ、バーナードAboba、Youngsooチェ、鵬飛ディ、ダン・デュシャン、ラース含むDCCP BOF、ワーキンググループ、およびメーリングリストを介してコメントや提案を提供した者に感謝しますエッゲルト、Gorry Fairhurst、デレクFawcus、デビッド・ティモシーFleeman、ジョンLoughney、Ghyslainペルティエ、ハーゲンポール・ファイファー、トム・フェラン、スタニスラフ"
    },
    {
      "indent": 3,
      "text": "Shalunov, Somsak Vanit-Anunchai, David Vos, Yufei Wang, and Michael Welzl. In particular, Colin Perkins provided extensive, detailed feedback, Michael Welzl suggested the Data Checksum option, Gorry Fairhurst provided extensive feedback on various checksum issues, and Somsak Vanit-Anunchai, Jonathan Billington, and Tul Kongprakaiwoot's Colored Petri Net model [VBK05] discovered several problems with message exchange.",
      "ja": "Shalunov、ソムサックVanit-Anunchai、デビッド・ヴォス、Yufei王、マイケルWelzl。特に、コリンパーキンスは広範囲、詳細なフィードバックを提供し、マイケルWelzlは、データチェックサムオプションを提案し、Gorry Fairhurstは、様々なチェックサムの問題に広範なフィードバックを提供し、ソムサックVanit-Anunchai、ジョナサン・ビリントン、およびTUL Kongprakaiwootのカラーペトリネットモデルは、[VBK05]いくつかの発見しましたメッセージ交換での問題。"
    },
    {
      "indent": 0,
      "text": "A. Appendix: Ack Vector Implementation Notes",
      "ja": "A.付録：Ackをベクトル実装ノート"
    },
    {
      "indent": 3,
      "text": "This appendix discusses particulars of DCCP acknowledgement handling in the context of an abstract implementation for Ack Vector. It is informative and not normative.",
      "ja": "この付録では、ACKベクトルのための抽象実装のコンテキストでDCCP承認取り扱いの詳細について説明します。それは有益で規範的ではありません。"
    },
    {
      "indent": 3,
      "text": "The first part of our implementation runs at the HC-Receiver, and therefore acknowledges data packets. It generates Ack Vector options. The implementation has the following characteristics:",
      "ja": "私たちの実装の最初の部分は、HC-レシーバで動作するため、データパケットを認めています。これは、ACKベクトルオプションを生成します。実装は次の特性があります。"
    },
    {
      "indent": 3,
      "text": "o At most one byte of state per acknowledged packet.",
      "ja": "O認めパケットあたりの状態の時に最大で1つのバイト。"
    },
    {
      "indent": 3,
      "text": "o O(1) time to update that state when a new packet arrives (normal case).",
      "ja": "新たなパケットが到着したときにその状態を更新するO O（1）時間（通常の場合）。"
    },
    {
      "indent": 3,
      "text": "o Cumulative acknowledgements.",
      "ja": "累積確認応答O。"
    },
    {
      "indent": 3,
      "text": "o Quick removal of old state.",
      "ja": "古い状態のOクイック除去。"
    },
    {
      "indent": 3,
      "text": "The basic data structure is a circular buffer containing information about acknowledged packets. Each byte in this buffer contains a state and run length; the state can be 0 (packet received), 1 (packet ECN marked), or 3 (packet not yet received). The buffer grows from right to left. The implementation maintains five variables, aside from the buffer contents:",
      "ja": "基本的なデータ構造は、確認応答パケットに関する情報を含む循環バッファです。このバッファ内の各バイトは、状態とランレングスが含まれています。状態が0（パケットを受信）、1（ECNがマークパケット）、または3（パケットがまだ受信していない）であってもよいです。バッファは、右から左に成長します。実装は、バッファの内容とは別に、5つの変数を維持します。"
    },
    {
      "indent": 3,
      "text": "o \"buf_head\" and \"buf_tail\", which mark the live portion of the buffer.",
      "ja": "バッファのライブ部分をマーク「buf_head」および「buf_tail」、O。"
    },
    {
      "indent": 3,
      "text": "o \"buf_ackno\", the Acknowledgement Number of the most recent packet acknowledged in the buffer. This corresponds to the \"head\" pointer.",
      "ja": "「buf_ackno」O、最新のパケットの確認応答番号は、バッファ内に認めました。これは、「ヘッド」ポインタに対応しています。"
    },
    {
      "indent": 3,
      "text": "o \"buf_nonce\", the one-bit sum (exclusive-or, or parity) of the ECN Nonces received on all packets acknowledged by the buffer with State 0.",
      "ja": "O「buf_nonce」は、ECNナンスの1ビットの和（排他的論理和、またはパリティ）は、状態0を有するバッファによって認めすべてのパケットで受信しました。"
    },
    {
      "indent": 3,
      "text": "We draw acknowledgement buffers like this:",
      "ja": "私たちは、このような確認応答バッファを描きます："
    },
    {
      "indent": 6,
      "text": "+---------------------------------------------------------------+\n|S,L|S,L|S,L|S,L|   |   |   |   |S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|\n+---------------------------------------------------------------+\n              ^                   ^\n           buf_tail     buf_head, buf_ackno = A     buf_nonce = E",
      "raw": true
    },
    {
      "indent": 16,
      "text": "<=== buf_head and buf_tail move this way <===",
      "ja": "<=== buf_headと、このように移動buf_tail <==="
    },
    {
      "indent": 3,
      "text": "Each \"S,L\" represents a State/Run length byte. We will draw these buffers showing only their live portion and will add an annotation showing the Acknowledgement Number for the last live byte in the buffer. For example:",
      "ja": "それぞれの「S、Lは、」州/ランレングスバイトを表します。私たちは彼らのライブ部分を示すこれらのバッファを描きますし、バッファ内の最後のライブのバイトに対する肯定応答番号を示す注釈を追加します。例えば："
    },
    {
      "indent": 6,
      "text": "  +-----------------------------------------------+\nA |S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L|S,L| T    BN[E]\n  +-----------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here, buf_nonce equals E and buf_ackno equals A.",
      "ja": "ここで、buf_nonceはEに等しく、buf_acknoはA.に等しいです"
    },
    {
      "indent": 3,
      "text": "We will use this buffer as a running example.",
      "ja": "私たちは、実行中の一例として、このバッファを使用します。"
    },
    {
      "indent": 6,
      "text": "   +---------------------------+\n10 |0,0|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[1]   [Example Buffer]\n   +---------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In concrete terms, its meaning is as follows:",
      "ja": "次のように具体的には、その意味は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Packet 10 was received. (The head of the buffer has sequence number 10, state 0, and run length 0.)",
      "ja": "パケット10は、受信しました。 （バッファの先頭は、配列番号10、状態0、及びランレングス0を有します）"
    },
    {
      "indent": 6,
      "text": "Packets 9, 8, and 7 have not yet been received. (The three bytes preceding the head each have state 3 and run length 0.)",
      "ja": "パケット9,8、および7はまだ受信されていません。 （各ヘッドの前の3つのバイトは、状態3とランレングス0を有します）"
    },
    {
      "indent": 6,
      "text": "Packets 6, 5, 4, 3, and 2 were received.",
      "ja": "パケット6、5、4、3、2は受信されました。"
    },
    {
      "indent": 6,
      "text": "Packet 1 was ECN marked.",
      "ja": "パケット1は、ECNがマークしました。"
    },
    {
      "indent": 6,
      "text": "Packet 0 was received.",
      "ja": "パケット0を受信しました。"
    },
    {
      "indent": 6,
      "text": "The one-bit sum of the ECN Nonces on packets 10, 6, 5, 4, 3, 2, and 0 equals 1.",
      "ja": "1ビットのパケット10、6、5、4、3、2にECNナンスの和、および0は1に等しいです。"
    },
    {
      "indent": 3,
      "text": "Additionally, the HC-Receiver must keep some information about the Ack Vectors it has recently sent. For each packet sent carrying an Ack Vector, it remembers four variables:",
      "ja": "また、HC-レシーバは、それが最近送信したのAckベクトルに関するいくつかの情報を保持しなければなりません。 Ackベクトルを運んで送られた各パケットの場合は、4つの変数を記憶しています："
    },
    {
      "indent": 3,
      "text": "o \"ack_seqno\", the Sequence Number used for the packet. This is an HC-Receiver sequence number.",
      "ja": "O「ack_seqno」、パケットに使用するシーケンス番号。これは、HC-レシーバのシーケンス番号です。"
    },
    {
      "indent": 3,
      "text": "o \"ack_ptr\", the value of buf_head at the time of acknowledgement.",
      "ja": "O「ack_ptr」、承認時のbuf_headの値。"
    },
    {
      "indent": 3,
      "text": "o \"ack_runlen\", the run length stored in the byte of buffer data at buf_head at the time of acknowledgement.",
      "ja": "「ack_runlen」O、ランレングスは、肯定応答時にbuf_headにおけるバッファデータのバイトに格納されています。"
    },
    {
      "indent": 3,
      "text": "o \"ack_ackno\", the Acknowledgement Number used for the packet. This is an HC-Sender sequence number. Since acknowledgements are cumulative, this single number completely specifies all necessary information about the packets acknowledged by this Ack Vector.",
      "ja": "「ack_ackno」O、承認番号は、パケットのために使用しました。これは、HC-送信者のシーケンス番号です。確認応答が累積的であるため、この単一の数値は完全にこの肯定応答ベクトルによって承認パケットに関するすべての必要な情報を指定します。"
    },
    {
      "indent": 3,
      "text": "o \"ack_nonce\", the one-bit sum of the ECN Nonces for all State 0 packets in the buffer from buf_head to ack_ackno, inclusive. Initially, this equals the Nonce Echo of the acknowledgement's Ack Vector (or, if the ack packet contained more than one Ack Vector, the exclusive-or of all the acknowledgement's Ack Vectors). It changes as information about old acknowledgements is removed (so ack_ptr and buf_head diverge) and as old packets arrive (so they change from State 3 or State 1 to State 0).",
      "ja": "O「ack_nonce」、ack_acknoするbuf_headから、バッファ内のすべての状態0のパケットのECNナンスの1ビットの合計、包括的。 （ACKパケットが複数のAckベクトル、排他的論理和のすべての承認者のAckのベクトルが含まれている場合、または）最初は、これは確認のAckをベクターのNonceのエコーに等しいです。これは、古い確認応答に関する情報が除去される（そうack_ptrとbuf_head発散）と同じくらい古いパケットが到着を変更する（ので、状態0の状態3又は状態1から変更します）。"
    },
    {
      "indent": 0,
      "text": "A.1. Packet Arrival",
      "ja": "A.1。パケット到着"
    },
    {
      "indent": 3,
      "text": "This section describes how the HC-Receiver updates its acknowledgement buffer as packets arrive from the HC-Sender.",
      "ja": "このセクションでは、パケットがHC-送信者から到着するようにHC-Receiverはその肯定応答バッファを更新する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "A.1.1. New Packets",
      "ja": "A.1.1。新しいパケット"
    },
    {
      "indent": 3,
      "text": "When a packet with Sequence Number greater than buf_ackno arrives, the HC-Receiver updates buf_head (by moving it to the left appropriately), buf_ackno (which is set to the new packet's Sequence Number), and possibly buf_nonce (if the packet arrived unmarked with ECN Nonce 1), in addition to the buffer itself. For example, if HC-Sender packet 11 arrived ECN marked, the Example Buffer above would enter this new state (changes are marked with stars):",
      "ja": "buf_acknoよりも大きいシーケンス番号を持つパケットが到着すると、HC-レシーバアップデートbuf_head（適切に左に移動することによって）、（新たなパケットのシーケンス番号に設定されている）buf_ackno、そしておそらくbuf_nonce（パケットが到着したとマークされていない場合バッファ自体に加えて、ECNノンス1）。 HC-送信者のパケット11は、ECNがマークされ到着した場合たとえば、上記の例のバッファは、この新しい状態を入力します（変更は星でマークされています）："
    },
    {
      "indent": 9,
      "text": "** +***----------------------------+\n11 |1,0|0,0|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[1]\n** +***----------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the packet's state equals the state at the head of the buffer, the HC-Receiver may choose to increment its run length (up to the maximum). For example, if HC-Sender packet 11 arrived without ECN marking and with ECN Nonce 0, the Example Buffer might enter this state instead:",
      "ja": "パケットの状態は、バッファの先頭に状態に等しければ、HC-レシーバは、（最大値まで）のランレングスをインクリメントすることもできます。例えば、HC-送信者のパケット11は、ECNマーキングなしで到着した場合やECNノンス0で、例のバッファが代わりにこの状態に入るかもしれません。"
    },
    {
      "indent": 13,
      "text": "** +--*------------------------+\n11 |0,1|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[1]\n** +--*------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Of course, the new packet's sequence number might not equal the expected sequence number. In this case, the HC-Receiver will enter the intervening packets as State 3. If several packets are missing, the HC-Receiver may prefer to enter multiple bytes with run length 0, rather than a single byte with a larger run length; this simplifies table updates if one of the missing packets arrives. For example, if HC-Sender packet 12 arrived with ECN Nonce 1, the Example Buffer would enter this state:",
      "ja": "もちろん、新しいパケットのシーケンス番号が期待されるシーケンス番号と等しくない場合があります。いくつかのパケットが欠落している場合この場合には、HC-Receiverが状態3の介在パケットに入り、HC-Receiverはランレングス0、というよりも大きいランレングスを有する単一のバイトで複数のバイトを入力することを好むことができます。欠落したパケットの1が到着した場合、これは、テーブルの更新を簡素化します。 HC-センダパケット12は、ECNノンス1で到着した場合、例えば、実施例バッファはこの状態に入るであろう。"
    },
    {
      "indent": 6,
      "text": "** +*******----------------------------+         *\n12 |0,0|3,0|0,1|3,0|3,0|3,0|0,4|1,0|0,0| 0    BN[0]\n** +*******----------------------------+         *",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Of course, the circular buffer may overflow when the HC-Sender is sending data at a very high rate, when the HC-Receiver's acknowledgements are not reaching the HC-Sender, or when the HC-Sender is forgetting to acknowledge those acks (so the HC-Receiver is unable to clean up old state). In this case, the HC-Receiver should either compress the buffer (by increasing run lengths when possible), transfer its state to a larger buffer, or, as a last resort, drop all received packets, without processing them at all, until its buffer shrinks again.",
      "ja": "HC-Senderがそれほど（HC-受信の確認応答がHC-送信者に到達していない、またはHC-SenderがそれらACKを確認するために忘れている場合と、非常に高いレートでデータを送信している場合もちろん、円形のバッファがオーバーフローしてもよいですHC-レシーバ）が古い状態をクリーンアップすることができません。この場合には、HC-Receiverは、（可能な場合ランレングスを増加させることによって）バッファを圧縮しなければならないのいずれか大きいバッファにその状態を転送する、または、最後の手段として、そのまで、すべてでそれらを処理することなく、すべての受信パケットをドロップバッファが再び縮小されます。"
    },
    {
      "indent": 0,
      "text": "A.1.2. Old Packets",
      "ja": "A.1.2。オールド・パケット"
    },
    {
      "indent": 3,
      "text": "When a packet with Sequence Number S <= buf_ackno arrives, the HC-Receiver will scan the table for the byte corresponding to S. (Indexing structures could reduce the complexity of this scan.) If S was previously lost (State 3), and it was stored in a byte with run length 0, the HC-Receiver can simply change the byte's state. For example, if HC-Sender packet 8 was received with ECN Nonce 0, the Example Buffer would enter this state:",
      "ja": "シーケンス番号Sとすると、パケット<= buf_acknoが到着すると、HC-レシーバはS.（インデックス構造は、このスキャンの複雑さを軽減することができます。）Sは、以前に失われた場合（状態3）に対応するバイトのテーブルをスキャンして、それはラン長0のバイトに格納されていた、HC-レシーバは単にバイトの状態を変更することができます。 HC-Senderのパケット8は、ECNノンス0で受信された場合、例えば、実施例バッファはこの状態に入るであろう。"
    },
    {
      "indent": 12,
      "text": "   +--------*------------------+\n10 |0,0|3,0|0,0|3,0|0,4|1,0|0,0| 0    BN[1]\n   +--------*------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If S was not marked as lost, or if it was not contained in the table, the packet is probably a duplicate and should be ignored. (The new packet's ECN marking state might differ from the state in the buffer; Section 11.4.1 describes what is allowed then.) If S's buffer byte has a non-zero run length, then the buffer might need to be reshuffled to make space for one or two new bytes.",
      "ja": "失われたとして、またはそれがテーブルに含まれていなかった場合はSがマークされていなかった場合、パケットはおそらく重複していると無視されるべきです。 （新しいパケットのECNマーキング状態は、バッファ状態は異なる場合があります;。11.4.1は、許可されている内容を説明）Sのバッファ・バイトが非ゼロのラン長を持っている場合、バッファにはスペースを作るために入れ替えが必要になる場合があります1または2の新しいバイトのために。"
    },
    {
      "indent": 3,
      "text": "The ack_nonce fields may also need manipulation when old packets arrive. In particular, when S transitions from State 3 or State 1 to State 0, and S had ECN Nonce 1, then the implementation should flip the value of ack_nonce for every acknowledgement with ack_ackno >= S.",
      "ja": "古いパケットが到着したときack_nonceフィールドも操作が必要な場合があります。特に、状態0の状態3又は状態1からSに遷移し、SがECNノンス1を有し、実装はack_ackno> = Sですべての肯定応答のためack_nonceの値を反転すべきです"
    },
    {
      "indent": 3,
      "text": "It is impossible with this data structure to shift packets from State 0 to State 1, since the buffer doesn't store individual packets' ECN Nonces.",
      "ja": "これは、バッファは、個々のパケットのECNナンスを格納していないので、状態1の状態0からのパケットをシフトするために、このデータ構造では不可能です。"
    },
    {
      "indent": 0,
      "text": "A.2. Sending Acknowledgements",
      "ja": "A.2。謝辞を送信"
    },
    {
      "indent": 3,
      "text": "Whenever the HC-Receiver needs to generate an acknowledgement, the buffer's contents can simply be copied into one or more Ack Vector options. Copied Ack Vectors might not be maximally compressed; for example, the Example Buffer above contains three adjacent 3,0 bytes that could be combined into a single 3,2 byte. The HC-Receiver might, therefore, choose to compress the buffer in place before sending the option, or to compress the buffer while copying it; either operation is simple.",
      "ja": "HC-Receiverの確認応答を生成する必要があるときはいつでも、バッファの内容は、単に一の以上のAckベクトルオプションにコピーすることができます。コピーされたAckベクターは最大限に圧縮されていない可能性があります。例えば、実施例バッファは、上記単一3,2バイトに組み合わせることができる3つの隣接する3,0バイトを含みます。 HC-レシーバは、したがって、オプションを送信する前に所定の位置にバッファを圧縮する、またはそれをコピーしている間にバッファを圧縮することを選択するかもしれません。どちらかの操作が簡単です。"
    },
    {
      "indent": 3,
      "text": "Every acknowledgement sent by the HC-Receiver SHOULD include the entire state of the buffer. That is, acknowledgements are cumulative.",
      "ja": "HC-受信機によって送信されたすべての肯定応答がバッファ全体の状態が含まれるべきです。これは、確認応答が累積され、です。"
    },
    {
      "indent": 3,
      "text": "If the acknowledgement fits in one Ack Vector, that Ack Vector's Nonce Echo simply equals buf_nonce. For multiple Ack Vectors, more care is required. The Ack Vectors should be split at points corresponding to previous acknowledgements, since the stored ack_nonce fields provide enough information to calculate correct Nonce Echoes. The implementation should therefore acknowledge data at least once per 253 bytes of buffer state. (Otherwise, there'd be no way to calculate a Nonce Echo.)",
      "ja": "確認応答が1のAckベクトルに収まる場合は、ACKベクトルのナンスエコーは、単にbuf_nonceに等しいこと。複数のACKベクターについて、より多くの注意が必要です。保存されたack_nonceフィールドが正しいノンスエコーを計算するために十分な情報を提供するためのAckベクターは、以前の肯定応答に対応する点で分割されなければなりません。実装は、従って、少なくとも一度バッファ状態の253バイト毎のデータを確認すべきです。 （そうでない場合は、ノンスエコーを計算する方法がないと思います。）"
    },
    {
      "indent": 3,
      "text": "For each acknowledgement it sends, the HC-Receiver will add an acknowledgement record. ack_seqno will equal the HC-Receiver sequence number it used for the ack packet; ack_ptr will equal buf_head; ack_runlen will equal the run length stored in the buffer's buf_head byte; ack_ackno will equal buf_ackno; and ack_nonce will equal buf_nonce.",
      "ja": "それが送信する各受信確認のために、HC-レシーバは承認レコードを追加します。 ack_seqnoがACKパケットに使用されるHC-受信シーケンス番号に等しくなります。 ack_ptr buf_headに等しくなります。 ack_runlenは、バッファのbuf_headバイトに保存されているラン長を等しくなります。 ack_ackno buf_acknoに等しくなります。そしてack_nonceはbuf_nonceに等しくなります。"
    },
    {
      "indent": 0,
      "text": "A.3. Clearing State",
      "ja": "A.3。状態をクリア"
    },
    {
      "indent": 3,
      "text": "Some of the HC-Sender's packets will include acknowledgement numbers, which ack the HC-Receiver's acknowledgements. When such an ack is received, the HC-Receiver finds the acknowledgement record R with the appropriate ack_seqno and then does the following:",
      "ja": "HC-送信者のパケットの中には、HC-Receiverの承認をackを確認応答番号が含まれます。そのようなACKが受信されると、HC-Receiverは、適切なack_seqnoと肯定応答レコードRを検索し、その後、次の処理を行います。"
    },
    {
      "indent": 3,
      "text": "o If the run length in the buffer's R.ack_ptr byte is greater than R.ack_runlen, then it decrements that run length by R.ack_runlen + 1 and sets buf_tail to R.ack_ptr. Otherwise, it sets buf_tail to R.ack_ptr + 1.",
      "ja": "バッファのR.ack_ptrバイトのラン長がR.ack_runlenよりも大きい場合は、O、それはR.ack_ptrにbuf_tail R.ack_runlen + 1とセットすることにより、そのラン長をデクリメント。それ以外の場合は、R.ack_ptr + 1にbuf_tail設定します。"
    },
    {
      "indent": 3,
      "text": "o If R.ack_nonce is 1, it flips buf_nonce, and the value of ack_nonce for every later ack record.",
      "ja": "R.ack_nonceが1の場合、O、それはbuf_nonce、すべての後にACKレコードのack_nonceの値を反転します。"
    },
    {
      "indent": 3,
      "text": "o It throws away R and every preceding ack record.",
      "ja": "OそれはRと、すべての前のACKのレコードを破棄します。"
    },
    {
      "indent": 3,
      "text": "(The HC-Receiver may choose to keep some older information, in case a lost packet shows up late.) For example, say that the HC-Receiver storing the Example Buffer had sent two acknowledgements already:",
      "ja": "（HC-レシーバは、後半に失われたパケットが現れる場合には、いくつかの古い情報を保持することもできます。）例えば、HC-レシーバは例のバッファがすでに2つの確認応答を送っていた保存と言います："
    },
    {
      "indent": 3,
      "text": "1. ack_seqno = 59, ack_runlen = 1, ack_ackno = 3, ack_nonce = 1.",
      "section_title": true,
      "ja": "1. ack_seqno = 59、ack_runlen = 1、ack_ackno = 3、ack_nonce = 1"
    },
    {
      "indent": 3,
      "text": "2. ack_seqno = 60, ack_runlen = 0, ack_ackno = 10, ack_nonce = 0.",
      "section_title": true,
      "ja": "2. ack_seqno = 60、ack_runlen = 0、ack_ackno = 10、ack_nonce = 0番目"
    },
    {
      "indent": 3,
      "text": "Say the HC-Receiver then received a DCCP-DataAck packet with Acknowledgement Number 59 from the HC-Sender. This informs the HC-Receiver that the HC-Sender received, and processed, all the information in HC-Receiver packet 59. This packet acknowledged HC-Sender packet 3, so the HC-Sender has now received HC-Receiver's acknowledgements for packets 0, 1, 2, and 3. The Example Buffer should enter this state:",
      "ja": "HC-受信機は、次にHC-送信者からの肯定応答番号59とDCCP-DataAckパケットを受信したと言います。これは、HC-送信者が受信したHC-Receiverを通知し、処理し、HC-レシーバパケット59のすべての情報は、このパケットは、HC-送信者のパケット3を認めたので、HC-送信者は現在、パケット0用HC-Receiverの承認を受けています、1、2、および3例のバッファはこの状態に入るべきです。"
    },
    {
      "indent": 12,
      "text": "   +------------------*+ *       *\n10 |0,0|3,0|3,0|3,0|0,2| 4    BN[0]\n   +------------------*+ *       *",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The tail byte's run length was adjusted, since packet 3 was in the middle of that byte. Since R.ack_nonce was 1, the buf_nonce field was flipped, as were the ack_nonce fields for later acknowledgements (here, the HC-Receiver Ack 60 record, not shown, has its ack_nonce flipped to 1). The HC-Receiver can also throw away stored information about HC-Receiver Ack 59 and any earlier acknowledgements.",
      "ja": "パケット3は、そのバイトの真ん中にあったので、テール・バイトのラン長は、調整しました。 R.ack_nonceが1であったので、後に肯定応答するためのack_nonceフィールドたように、buf_nonceフィールドは、反転した（ここで、HCレシーバのAck 60レコード、図示しないが、そのack_nonceは1に反転しています）。 HC-また、受信機は、HC-レシーバのAck 59およびそれ以前の承認に関する離れて保存されている情報を投げることができます。"
    },
    {
      "indent": 3,
      "text": "A careful implementation might try to ensure reasonable robustness to reordering. Suppose that the Example Buffer is as before, but that packet 9 now arrives, out of sequence. The buffer would enter this state:",
      "ja": "慎重な実装では、並べ替えに合理的な堅牢性を確保しようとするかもしれません。シーケンスのうちの、例のバッファが以前のようにですが、そのパケット9が今到着したと仮定します。バッファは、この状態を入力します。"
    },
    {
      "indent": 13,
      "text": "   +----*----------------------+\n10 |0,0|0,0|3,0|3,0|0,4|1,0|0,0| 0     BN[1]\n   +----*----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The danger is that the HC-Sender might acknowledge the HC-Receiver's previous acknowledgement (with sequence number 60), which says that Packet 9 was not received, before the HC-Receiver has a chance to send a new acknowledgement saying that Packet 9 actually was received. Therefore, when packet 9 arrived, the HC-Receiver might modify its acknowledgement record as follows:",
      "ja": "危険なのはHC-SenderがHC-レシーバが実際にそのパケット9を言って新しい確認応答を送信する機会を持って前に、パケット9は、受信されなかったことを言って、（シーケンス番号60を持つ）HC-Receiverの前の承認を認める可能性があるということです受信されました。パケット9が到着したとき、次のようにそのため、HC-レシーバは、その承認レコードを変更することがあります。"
    },
    {
      "indent": 3,
      "text": "1. ack_seqno = 59, ack_ackno = 3, ack_nonce = 1.",
      "section_title": true,
      "ja": "1. ack_seqno = 59、ack_ackno = 3、ack_nonce =第一"
    },
    {
      "indent": 3,
      "text": "2. ack_seqno = 60, ack_ackno = 3, ack_nonce = 1.",
      "section_title": true,
      "ja": "2. ack_seqno = 60、ack_ackno = 3、ack_nonce =第一"
    },
    {
      "indent": 3,
      "text": "That is, Ack 60 is now treated like a duplicate of Ack 59. This would prevent the Tail pointer from moving past packet 9 until the HC-Receiver knows that the HC-Sender has seen an Ack Vector indicating that packet's arrival.",
      "ja": "それは、ACK 60は今HC-Senderは、パケットの到着ことを示すACKベクトルを見ていることを知っている。これは、HC-レシーバまでの過去パケット9を移動するテールポインタを妨げるのAck 59の重複のように扱われています。"
    },
    {
      "indent": 0,
      "text": "A.4. Processing Acknowledgements",
      "ja": "A.4。処理謝辞"
    },
    {
      "indent": 3,
      "text": "When the HC-Sender receives an acknowledgement, it generally cares about the number of packets that were dropped and/or ECN marked. It simply reads this off the Ack Vector. Additionally, it should check the ECN Nonce for correctness. (As described in Section 11.4.1, it may want to keep more detailed information about acknowledged packets in case packets change states between acknowledgements, or in case the application queries whether a packet arrived.)",
      "ja": "HC-Senderが確認応答を受信すると、それは一般的にドロップされたおよび/またはECNがマークされたパケット数を気に。それは単にのAckベクトルを、これをオフに読み込みます。さらに、それが正しいかECN nonceを確認する必要があります。 （11.4.1項で説明したように、それは、パケットが到着したかどうかをアプリケーションのクエリを確認応答の間の状態を変更したり、ケースにケースパケットで確認応答パケットについてのより詳細な情報を保持することをお勧めします。）"
    },
    {
      "indent": 3,
      "text": "The HC-Sender must also acknowledge the HC-Receiver's acknowledgements so that the HC-Receiver can free old Ack Vector state. (Since Ack Vector acknowledgements are reliable, the HC-Receiver must maintain and resend Ack Vector information until it is sure that the HC-Sender has received that information.) A simple algorithm suffices: since Ack Vector acknowledgements are cumulative, a single acknowledgement number tells HC-Receiver how much ack information has arrived. Assuming that the HC-Receiver sends no data, the HC-Sender can ensure that at least once a round-trip time, it sends a DCCP-DataAck packet acknowledging the latest DCCP-Ack packet it has received. Of course, the HC-Sender only needs to acknowledge the HC-Receiver's acknowledgements if the HC-Sender is also sending data. If the HC-Sender is not sending data, then the HC-Receiver's Ack Vector state is stable, and there is no need to shrink it. The HC-Sender must watch for drops and ECN marks on received DCCP-Ack packets so that it can adjust the HC-Receiver's ack-sending rate in response to congestion, for example, with Ack Ratio.",
      "ja": "HC-レシーバが古いのAckベクトル状態を解放できるように、HC-送信者はまた、HC-Receiverの承認を確認する必要があります。 （肯定応答ベクトル肯定応答が信頼されているので、HC-Senderがその情報を受信したことを確認するまで、HC-受信機は、ACKベクトル情報を維持し、再送信しなければならない。）単純なアルゴリズムで十分：のAckベクトル確認応答が累積的であるため、単一確認応答番号ACK情報が到着したどのくらいのHC-Receiverを伝えます。 HC-レシーバがデータを送信しないと仮定すると、HC-送信者は、少なくとも一回のラウンドトリップ時間、それが受信した最新のDCCP-Ackパケットを認めDCCP-DataAckパケットを送信していることを確認することができます。もちろん、HC-送信者にのみHC-Senderは、データを送信している場合はHC-Receiverの確認応答を確認する必要があります。 HC-Senderがデータを送信していない場合は、HC-ReceiverのAckをベクトル状態は安定しており、それを縮小する必要はありません。それがACK比で、例えば、混雑に応じて、HC-ReceiverのACK-送信レートを調整できるように、HC-送信者は受信DCCP-ACKパケットに低下し、ECNマークを監視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the other half-connection is not quiescent -- that is, the HC-Receiver is sending data to the HC-Sender, possibly using another CCID -- then the acknowledgements on that half-connection are sufficient for the HC-Receiver to free its state.",
      "ja": "残りの半分接続が休止されていない場合 - つまり、HC-レシーバはおそらく別のCCIDを使用して、HC-Senderにデータを送信している - その半分の接続の確認応答が自由にHC-レシーバには十分ですその状態。"
    },
    {
      "indent": 0,
      "text": "B. Appendix: Partial Checksumming Design Motivation",
      "ja": "B.付録：部分的なチェックサムのデザイン動機"
    },
    {
      "indent": 3,
      "text": "A great deal of discussion has taken place regarding the utility of allowing a DCCP sender to restrict the checksum so that it does not cover the complete packet. This section attempts to capture some of the rationale behind specific details of DCCP design.",
      "ja": "議論の偉大な取引が、それは完全なパケットをカバーしないように、DCCP送信者がチェックサムを制限することを可能にする有用性について行われました。このセクションでは、DCCP設計の具体的な詳細の根拠の一部を捕獲しようとします。"
    },
    {
      "indent": 3,
      "text": "Many of the applications that we envisage using DCCP are resilient to some degree of data loss, or they would typically have chosen a reliable transport. Some of these applications may also be resilient to data corruption -- some audio payloads, for example. These resilient applications might rather receive corrupted data than have DCCP drop corrupted packets. This is particularly because of congestion control: DCCP cannot tell the difference between packets dropped due to corruption and packets dropped due to congestion, and so it must reduce the transmission rate accordingly. This response may cause the connection to receive less bandwidth than it is due; corruption in some networking technologies is independent of, or at least not always correlated to, congestion. Therefore, corrupted packets do not need to cause as strong a reduction in transmission rate as the congestion response would dictate (as long as the DCCP header and options are not corrupt).",
      "ja": "私たちはDCCPを使用して想定するアプリケーションの多くは、データ損失のある程度弾力性のある、またはそれらは一般的に信頼性の高いトランスポートを選択しているだろう。これらのアプリケーションのいくつかは、データの破損に弾力があり - いくつかのオーディオペイロード、例えば。これらの弾力性のアプリケーションではなく、DCCPドロップ破損したパケットを持っているよりも破損したデータを受信する場合があります。これは、輻輳制御のために特にです：DCCPが原因汚職に低下し、パケットが輻輳による滴下し、それはそれに応じて伝送速度を減少させなければならないパケット間の違いを見分けることはできません。この応答は、それが原因であるよりも少ない帯域幅を受け取るために接続を引き起こす可能性があります。いくつかのネットワーク技術の腐敗は独立して、または少なくとも常に混雑、に相関していません。そのため、破損したパケットは、（限り、DCCPヘッダーとオプションが破損していないよう）指示するでしょう輻輳応答として送信レートのような強力な低下を引き起こすする必要はありません。"
    },
    {
      "indent": 3,
      "text": "Thus DCCP allows the checksum to cover all of the packet, just the DCCP header, or both the DCCP header and some number of bytes from the application data. If the application cannot tolerate any data corruption, then the checksum must cover the whole packet. If the application would prefer to tolerate some corruption rather than have the packet dropped, then it can set the checksum to cover only part of the packet (but always the DCCP header). In addition, if the application wishes to decouple checksumming of the DCCP header from checksumming of the application data, it may do so by including the Data Checksum option. This would allow DCCP to discard corrupted application data without mistaking the corruption for network congestion.",
      "ja": "したがってDCCPは、チェックサムは、パケットのすべて、単にDCCPヘッダー、またはDCCPヘッダおよびアプリケーションデータから数バイトの両方をカバーすることを可能にします。アプリケーションがデータの破損に耐えることができない場合は、チェックサムは、パケット全体をカバーしなければなりません。アプリケーションは、いくつかの汚職を容認することを好む場合ではなく、パケットは廃棄されている、それだけでパケットの一部（常にDCCPヘッダー）をカバーするためにチェックサムを設定することができます。アプリケーションは、アプリケーションデータのチェックサムからDCCPヘッダのチェックサムを分離したい場合に加えて、それは、データチェックサムオプションを含めることによって、これを行うことができます。これは、DCCPは、ネットワークの混雑のために破損を間違えずに破損したアプリケーションデータを破棄することが可能になります。"
    },
    {
      "indent": 3,
      "text": "Thus, from the application point of view, partial checksums seem to be a desirable feature. However, the usefulness of partial checksums depends on partially corrupted packets being delivered to the receiver. If the link-layer CRC always discards corrupted packets, then this will not happen, and so the usefulness of partial checksums would be restricted to corruption that occurred in routers and other places not covered by link CRCs. There does not appear to be consensus on how likely it is that future network links that suffer significant corruption will not cover the entire packet with a single strong CRC. DCCP makes it possible to tailor such links to the application, but it is difficult to predict if this will be compelling for future link technologies.",
      "ja": "したがって、アプリケーションの観点から、部分的チェックサムは望ましい特徴であるように見えます。しかし、部分的なチェックサムの有用性は、部分的に破損したパケットが受信機に配信さに依存します。リンク層のCRCは、常に破損したパケットを破棄した場合、これは発生しません、ので、部分的なチェックサムの有用性は、ルータやリンクのCRCで保護されていない他の場所で発生した破損に限定されるであろう。それは重大な破損を受け、将来のネットワークリンクは、単一の強力なCRCを持つパケット全体をカバーしていないということですかそうでコンセンサスがあるように表示されません。 DCCPは、アプリケーションにこのようなリンクを調整することが可能となり、これは将来のリンク技術のための説得力になるかどうかを予測することは困難です。"
    },
    {
      "indent": 3,
      "text": "In addition, partial checksums do not co-exist well with IP-level authentication mechanisms such as IPsec AH, which cover the entire packet with a cryptographic hash. Thus, if cryptographic authentication mechanisms are required to co-exist with partial checksums, the authentication must be carried in the application data. A possible mode of usage would appear to be similar to that of Secure RTP. However, such \"application-level\" authentication does not protect the DCCP option negotiation and state machine from forged packets. An alternative would be to use IPsec ESP, and to use encryption to protect the DCCP headers against attack, while using the DCCP header validity checks to authenticate that the header is from someone who possessed the correct key. While this is resistant to replay (due to the DCCP sequence number), it is not by itself resistant to some forms of man-in-the-middle attacks because the application data is not tightly coupled to the packet header. Thus, an application-level authentication probably needs to be coupled with IPsec ESP or a similar mechanism to provide a reasonably complete security solution. The overhead of such a solution might be unacceptable for some applications that would otherwise wish to use partial checksums.",
      "ja": "加えて、部分的チェックサムは、暗号ハッシュとパケット全体を覆うようにIPsec AHなどのIPレベルの認証メカニズムとよく共存していません。暗号認証メカニズムは、部分チェックサムと共存する必要がある場合はこのように、認証は、アプリケーションデータに実行されなければなりません。利用可能なモードでは、Secure RTPのものと同様であるように思われます。しかし、そのような「アプリケーションレベル」の認証を偽造パケットからDCCPオプションのネゴシエーションやステートマシンを保護しません。代替は、IPsec ESPを使用すると、ヘッダが正しいキーを持っていた誰かからのものであることを認証するためにDCCPヘッダーの妥当性チェックを使用している間、攻撃に対してDCCPヘッダを保護するために暗号化を使用することであろう。これは（これはDCCPのシーケンス番号に）再生に対して耐性であるが、アプリケーションデータがしっかりパケットヘッダに連結されていないので、それはそれ自体でman-in-the-middle攻撃のいくつかの形態に耐性ではありません。このように、アプリケーションレベルの認証は、おそらくIPsecのESPまたは合理的に完全なセキュリティソリューションを提供するために、同様のメカニズムと結合する必要があります。このようなソリューションのオーバーヘッドはそうでない部分のチェックサムを使用したいでしょういくつかのアプリケーションのために受け入れられないかもしれません。"
    },
    {
      "indent": 3,
      "text": "On balance, the authors believe that DCCP partial checksums have the potential to enable some future uses that would otherwise be difficult. As the cost and complexity of supporting them is small, it seems worth including them at this time. It remains to be seen whether they are useful in practice.",
      "ja": "バランスで、著者はDCCP部分的なチェックサムがそうでなければ困難であろういくつかの将来の使用を可能にする可能性を持っていると信じています。それらが小さいサポートのコストと複雑さと、それはこの時点でそれらを含めて価値があると思われます。それは、彼らが実際に有用であるかどうかを見守らなければなりません。"
    },
    {
      "indent": 0,
      "text": "Normative References",
      "ja": "引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191]ムガール人、J.とS.デアリング、 \"パスMTUディスカバリ\"、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, September 2001.",
      "ja": "\"IPに明示的輻輳通知の添加（ECN）\" [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3309] Stone, J., Stewart, R., and D. Otis, \"Stream Control Transmission Protocol (SCTP) Checksum Change\", RFC 3309, September 2002.",
      "ja": "[RFC3309]石、J.、スチュワート、R.、およびD.オーティス、 \"ストリーム制御伝送プロトコル（SCTP）チェックサムの変更\"、RFC 3309、2002年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3692] Narten, T., \"Assigning Experimental and Testing Numbers Considered Useful\", BCP 82, RFC 3692, January 2004.",
      "ja": "[RFC3692] Narten氏、T.、 \"役に立つと考えられ割り当て実験とテスト番号\"、BCP 82、RFC 3692、2004年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3775] Johnson, D., Perkins, C., and J. Arkko, \"Mobility Support in IPv6\", RFC 3775, June 2004.",
      "ja": "[RFC3775]ジョンソン、D.、パーキンス、C.、およびJ. Arkko、 \"IPv6におけるモビリティサポート\"、RFC 3775、2004年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3828] Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., and G. Fairhurst, \"The Lightweight User Datagram Protocol (UDP-Lite)\", RFC 3828, July 2004.",
      "ja": "[RFC3828] Larzon、L-A。、Degermark、M.、ピンク、S.、ヨンソン、L-E。、およびG. Fairhurst、 \"軽量ユーザーデータグラムプロトコル（UDP-Liteの）\"、RFC 3828、2004年7月。"
    },
    {
      "indent": 0,
      "text": "Informative References",
      "ja": "参考文献"
    },
    {
      "indent": 3,
      "text": "[B98] Bellovin, S.M., \"Cryptography and the Internet\", CRYPTO '98 (LNCS 1462), pp 46-55, August 1988.",
      "ja": "[B98] Bellovin氏、S.M.、 \"暗号とインターネット\"、CRYPTO '98（LNCS 1462）、頁46-55、1988年8月。"
    },
    {
      "indent": 3,
      "text": "[BB01] Bellovin, S.M. and M. Blaze, \"Cryptographic Modes of Operation for the Internet\", 2nd NIST Workshop on Modes of Operation, August 2001.",
      "ja": "[BB01] Bellovin氏、S。M.そして、M.ブレイズ、「インターネットのための操作の暗号モード」、オペレーション、2001年8月のモードに関する第2回ワークショップNIST。"
    },
    {
      "indent": 3,
      "text": "[M85] Morris, R.T., \"A Weakness in the 4.2BSD Unix TCP/IP Software\", Computer Science Technical Report 117, AT&T Bell Laboratories, Murray Hill, NJ, February 1985.",
      "ja": "[M85]モリス、R.T.、 \"4.2BSD UnixのTCP / IPソフトウェアで弱点\"、コンピュータサイエンステクニカルレポート117、AT＆Tベル研究所、マリーヒル、ニュージャージー州、1985年2月。"
    },
    {
      "indent": 3,
      "text": "[PMTUD] Mathis, M. and J. Heffner, \"Path MTU Discovery\", Work in Progress, March 2006.",
      "ja": "[PMTUD]マシス、M.とJ. Heffner、 \"パスMTUディスカバリー\"、進歩、2006年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[RFC792] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, September 1981.",
      "ja": "[RFC792]ポステル、J.、 \"インターネット制御メッセージプロトコル\"、STD 5、RFC 792、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1812] Baker, F., \"Requirements for IP Version 4 Routers\", RFC 1812, June 1995.",
      "ja": "[RFC1812]ベイカー、F.、RFC 1812、1995年6月 \"IPバージョン4つのルータのための要件\"。"
    },
    {
      "indent": 3,
      "text": "[RFC1948] Bellovin, S., \"Defending Against Sequence Number Attacks\", RFC 1948, May 1996.",
      "ja": "[RFC1948] Bellovin氏、S.、 \"シーケンス番号攻撃からの保護\"、RFC 1948、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1982] Elz, R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982, August 1996.",
      "ja": "[RFC1982]エルツ、R.とR.ブッシュ大統領、 \"シリアル番号演算\"、RFC 1982、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgement Options\", RFC 2018, October 1996.",
      "ja": "[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 \"TCPの選択確認応答オプション\"、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2401] Kent, S. and R. Atkinson, \"Security Architecture for the Internet Protocol\", RFC 2401, November 1998.",
      "ja": "[RFC2401]ケント、S.とR.アトキンソン、 \"インターネットプロトコルのためのセキュリティー体系\"、RFC 2401、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2463] Conta, A. and S. Deering, \"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification\", RFC 2463, December 1998.",
      "ja": "[RFC2463]コンタ、A.、およびS.デアリング、 \"インターネットプロトコルバージョン6（IPv6）仕様のためのインターネット制御メッセージプロトコル（ICMPv6の）\"、RFC 2463（1998年12月）。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] Allman, M., Paxson, V., and W. Stevens, \"TCP Congestion Control\", RFC 2581, April 1999.",
      "ja": "[RFC2581]オールマン、M.、パクソン、V.、およびW.スティーブンス、 \"TCP輻輳制御\"、RFC 2581、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2960] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L., and V. Paxson, \"Stream Control Transmission Protocol\", RFC 2960, October 2000.",
      "ja": "[RFC2960]スチュワート、R.、謝、Q.、Morneault、K.、シャープ、C.、Schwarzbauer、H.、テイラー、T.、Rytina、I.、カラ、M.、チャン、L.、およびV 。パクソン、 \"ストリーム制御伝送プロトコル\"、RFC 2960、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC3124] Balakrishnan, H. and S. Seshan, \"The Congestion Manager\", RFC 3124, June 2001.",
      "ja": "[RFC3124]バラクリシュナン、H.とS. Seshan、 \"輻輳管理\"、RFC 3124、2001年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3360] Floyd, S., \"Inappropriate TCP Resets Considered Harmful\", BCP 60, RFC 3360, August 2002.",
      "ja": "[RFC3360]フロイド、S.、 \"有害考慮不適切なTCPリセット\"、BCP 60、RFC 3360、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3448] Handley, M., Floyd, S., Padhye, J., and J. Widmer, \"TCP Friendly Rate Control (TFRC): Protocol Specification\", RFC 3448, January 2003.",
      "ja": "[RFC3448]ハンドレー、M.、フロイド、S.、Padhye、J.、およびJ.ウィトマー、 \"TCPフレンドリーレート制御（TFRC）：プロトコル仕様\"、RFC 3448、2003年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3540] Spring, N., Wetherall, D., and D. Ely, \"Robust Explicit Congestion Notification (ECN) Signaling with Nonces\", RFC 3540, June 2003.",
      "ja": "[RFC3540]春、N.、Wetherall、D.、およびD.イーリー、 \"ロバスト明示的輻輳通知（ECN）ナンスとシグナリング\"、RFC 3540、2003年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, July 2003.",
      "ja": "[RFC3550] Schulzrinneと、H.、Casner、S.、フレデリック、R.、およびV.ヤコブソン、 \"RTP：リアルタイムアプリケーションのためのトランスポートプロトコル\"、STD 64、RFC 3550、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3611] Friedman, T., Caceres, R., and A. Clark, \"RTP Control Protocol Extended Reports (RTCP XR)\", RFC 3611, November 2003.",
      "ja": "[RFC3611]フリードマン、T.、カセレス、R.、およびA.クラーク、 \"RTP制御プロトコル拡張レポート（RTCP XR）\"、RFC 3611、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, March 2004.",
      "ja": "[RFC3711] Baugher、M.、マグリュー、D.、Naslund、M.、カララ、E.、およびK. Norrman、 \"セキュアリアルタイム転送プロトコル（SRTP）\"、RFC 3711、2004年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3819] Karn, P., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, \"Advice for Internet Subnetwork Designers\", BCP 89, RFC 3819, July 2004.",
      "ja": "[RFC3819]カーン、P.、ボルマン、C.、Fairhurst、G.、グロスマン、D.、ルートヴィヒ、R.、Mahdavi、J.、モンテネグロ、G.、タッチ、J.、およびL.ウッド、「アドバイスインターネットサブネットワークデザイナー」、BCP 89、RFC 3819、2004年7月のため。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、3、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4341] Floyd, S. and E. Kohler, \"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control\", RFC 4341, March 2006.",
      "ja": "[RFC4341]フロイド、S.、およびE.コーラー、 \"データグラム輻輳制御プロトコル（DCCP）輻輳制御ID 2用のプロフィール：TCPのような輻輳制御\"、RFC 4341、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4342] Floyd, S., Kohler, E., and J. Padhye, \"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 3: TCP-Friendly Rate Control (TFRC)\", RFC 4342, March 2006.",
      "ja": "[RFC4342]フロイド、S.、コーラー、E.、およびJ. Padhye、 \"データグラム混雑制御プロトコル（DCCP）輻輳制御ID 3のプロフィール：TCPフレンドリーレート制御（TFRC）\"、RFC 4342、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[SHHP00] Spatscheck, O., Hansen, J.S., Hartman, J.H., and L.L. Peterson, \"Optimizing TCP Forwarder Performance\", IEEE/ACM Transactions on Networking 8(2):146-157, April 2000.",
      "ja": "\"TCPフォワーダパフォーマンスの最適化\" [SHHP00] Spatscheck、O.、ハンセン、J.S.、ハートマン、J.H.、およびL.L.ピーターソン、ネットワーク8上のIEEE / ACMの取引（2）：146-157、2000年4月。"
    },
    {
      "indent": 3,
      "text": "[SYNCOOKIES] Bernstein, D.J., \"SYN Cookies\", http://cr.yp.to/syncookies.html, as of March 2006.",
      "ja": "2006年3月のように[syncookies機能]バーンスタイン、D.J.、 \"SYNクッキー\"、http://cr.yp.to/syncookies.html、。"
    },
    {
      "indent": 3,
      "text": "[VBK05] Vanit-Anunchai, S., Billington, J., and T. Kongprakaiwoot, \"Discovering Chatter and Incompleteness in the Datagram Congestion Control Protocol\", FORTE 2005, pp 143-158, October 2005.",
      "ja": "【VBK05] Vanit-Anunchai、S.、ビリントン、J.、およびT. Kongprakaiwoot、 \"データグラム輻輳制御プロトコルで発見びびり及び不完全\"、FORTE 2005頁143-158、2005年10月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Eddie Kohler 4531C Boelter Hall UCLA Computer Science Department Los Angeles, CA 90095 USA",
      "ja": "エディー・コーラー4531C BoelterホールUCLAコンピュータサイエンス学部ロサンゼルス、CA 90095 USA"
    },
    {
      "indent": 3,
      "text": "EMail: kohler@cs.ucla.edu",
      "ja": "メールアドレス：kohler@cs.ucla.edu"
    },
    {
      "indent": 3,
      "text": "Mark Handley Department of Computer Science University College London Gower Street London WC1E 6BT UK",
      "ja": "コンピュータサイエンス大学ロンドンガウアーストリートロンドンWC1E 6BT英国のマーク・ハンドリー部門"
    },
    {
      "indent": 3,
      "text": "EMail: M.Handley@cs.ucl.ac.uk",
      "ja": "メールアドレス：M.Handley@cs.ucl.ac.uk"
    },
    {
      "indent": 3,
      "text": "Sally Floyd ICSI Center for Internet Research 1947 Center Street, Suite 600 Berkeley, CA 94704 USA",
      "ja": "インターネットリサーチ1947センターストリートのためのサリーフロイドICSIセンター、スイート600バークレー、CA 94704 USA"
    },
    {
      "indent": 3,
      "text": "EMail: floyd@icir.org",
      "ja": "メールアドレス：floyd@icir.org"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディタ機能のための資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}