{
  "title": {
    "text": "RFC 4960 - Stream Control Transmission Protocol",
    "ja": "RFC 4960 - ストリーム制御伝送プロトコル"
  },
  "number": 4960,
  "created_at": "2019-10-29 13:22:45.739065+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                    R. Stewart, Ed.\nRequest for Comments: 4960                                September 2007\nObsoletes: 2960, 3309\nCategory: Standards Track",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Stream Control Transmission Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 2960 and RFC 3309. It describes the Stream Control Transmission Protocol (SCTP). SCTP is designed to transport Public Switched Telephone Network (PSTN) signaling messages over IP networks, but is capable of broader applications.",
      "ja": "この文書では、それはストリーム制御伝送プロトコル（SCTP）について説明RFC 2960およびRFC 3309を廃止します。 SCTPは、公衆交換電話網（PSTN）、IPネットワーク上でシグナリングメッセージを交換が、より広範な用途が可能である輸送するように設計されています。"
    },
    {
      "indent": 3,
      "text": "SCTP is a reliable transport protocol operating on top of a connectionless packet network such as IP. It offers the following services to its users:",
      "ja": "SCTPは、IPのようなコネクションレスパケット網の上で作動する信頼性の高いトランスポートプロトコルです。これは、そのユーザーに次のサービスを提供しています："
    },
    {
      "indent": 3,
      "text": "-- acknowledged error-free non-duplicated transfer of user data,",
      "ja": " - 、ユーザデータのエラーのない非重複転送を認めました"
    },
    {
      "indent": 3,
      "text": "-- data fragmentation to conform to discovered path MTU size,",
      "ja": " - 発見されたパスMTUサイズに適合するために、データの断片化、"
    },
    {
      "indent": 3,
      "text": "-- sequenced delivery of user messages within multiple streams, with an option for order-of-arrival delivery of individual user messages,",
      "ja": " - 個々のユーザメッセージの順序の到着送達のためのオプションを使用して、複数のストリーム内のユーザ・メッセージの配信を配列決定"
    },
    {
      "indent": 3,
      "text": "-- optional bundling of multiple user messages into a single SCTP packet, and",
      "ja": " - 単一SCTPパケットに複数のユーザメッセージのオプションバンドル、および"
    },
    {
      "indent": 3,
      "text": "-- network-level fault tolerance through supporting of multi-homing at either or both ends of an association.",
      "ja": " - 関連の一方または両端マルチホーミングの支持を介してネットワーク・レベルのフォールトトレランス。"
    },
    {
      "indent": 3,
      "text": "The design of SCTP includes appropriate congestion avoidance behavior and resistance to flooding and masquerade attacks.",
      "ja": "SCTPのデザインは、適切な輻輳回避行動や洪水への耐性やなりすまし攻撃が含まれています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n   1.1. Motivation .................................................5\n   1.2. Architectural View of SCTP .................................6\n   1.3. Key Terms ..................................................6\n   1.4. Abbreviations .............................................10\n   1.5. Functional View of SCTP ...................................10\n        1.5.1. Association Startup and Takedown ...................11\n        1.5.2. Sequenced Delivery within Streams ..................12\n        1.5.3. User Data Fragmentation ............................12\n        1.5.4. Acknowledgement and Congestion Avoidance ...........12\n        1.5.5. Chunk Bundling .....................................13\n        1.5.6. Packet Validation ..................................13\n        1.5.7. Path Management ....................................13\n   1.6. Serial Number Arithmetic ..................................14\n   1.7. Changes from RFC 2960 .....................................15\n2. Conventions ....................................................15\n3. SCTP Packet Format .............................................15\n   3.1. SCTP Common Header Field Descriptions .....................16\n   3.2. Chunk Field Descriptions ..................................17\n        3.2.1. Optional/Variable-Length Parameter Format ..........19\n        3.2.2. Reporting of Unrecognized Parameters ...............21\n   3.3. SCTP Chunk Definitions ....................................21\n        3.3.1. Payload Data (DATA) (0) ............................22\n        3.3.2. Initiation (INIT) (1) ..............................24\n               3.3.2.1. Optional/Variable-Length\n                        Parameters in INIT ........................27\n        3.3.3. Initiation Acknowledgement (INIT ACK) (2) ..........30\n               3.3.3.1. Optional or Variable-Length Parameters ....33\n        3.3.4. Selective Acknowledgement (SACK) (3) ...............34\n        3.3.5. Heartbeat Request (HEARTBEAT) (4) ..................38\n        3.3.6. Heartbeat Acknowledgement (HEARTBEAT ACK) (5) ......39\n        3.3.7. Abort Association (ABORT) (6) ......................40\n        3.3.8. Shutdown Association (SHUTDOWN) (7) ................41\n        3.3.9. Shutdown Acknowledgement (SHUTDOWN ACK) (8) ........41\n        3.3.10. Operation Error (ERROR) (9) .......................42\n               3.3.10.1. Invalid Stream Identifier (1) ............44\n               3.3.10.2. Missing Mandatory Parameter (2) ..........44\n               3.3.10.3. Stale Cookie Error (3) ...................45\n               3.3.10.4. Out of Resource (4) ......................45\n               3.3.10.5. Unresolvable Address (5) .................46\n               3.3.10.6. Unrecognized Chunk Type (6) ..............46\n               3.3.10.7. Invalid Mandatory Parameter (7) ..........47\n               3.3.10.8. Unrecognized Parameters (8) ..............47\n               3.3.10.9. No User Data (9) .........................48\n               3.3.10.10. Cookie Received While Shutting\n                          Down (10) ...............................48",
      "raw": true
    },
    {
      "indent": 3,
      "text": "               3.3.10.11. Restart of an Association with\n                          New Addresses (11) ......................49\n               3.3.10.12. User-Initiated Abort (12) ...............49\n               3.3.10.13. Protocol Violation (13) .................50\n        3.3.11. Cookie Echo (COOKIE ECHO) (10) ....................50\n        3.3.12. Cookie Acknowledgement (COOKIE ACK) (11) ..........51\n        3.3.13. Shutdown Complete (SHUTDOWN COMPLETE) (14) ........51\n4. SCTP Association State Diagram .................................52\n5. Association Initialization .....................................56\n   5.1. Normal Establishment of an Association ....................56\n        5.1.1. Handle Stream Parameters ...........................58\n        5.1.2. Handle Address Parameters ..........................58\n        5.1.3. Generating State Cookie ............................61\n        5.1.4. State Cookie Processing ............................62\n        5.1.5. State Cookie Authentication ........................62\n        5.1.6. An Example of Normal Association Establishment .....64\n   5.2. Handle Duplicate or Unexpected INIT, INIT ACK,\n        COOKIE ECHO, and ..........................................65\n        5.2.1. INIT Received in COOKIE-WAIT or\n               COOKIE-ECHOED State (Item B) .......................66\n        5.2.2. Unexpected INIT in States Other than\n               CLOSED, COOKIE-ECHOED, .............................66\n        5.2.3. Unexpected INIT ACK ................................67\n        5.2.4. Handle a COOKIE ECHO when a TCB Exists .............67\n               5.2.4.1. An Example of a Association Restart .......69\n        5.2.5. Handle Duplicate COOKIE-ACK. .......................71\n        5.2.6. Handle Stale COOKIE Error ..........................71\n   5.3. Other Initialization Issues ...............................72\n        5.3.1. Selection of Tag Value .............................72\n   5.4. Path Verification .........................................72\n6. User Data Transfer .............................................73\n   6.1. Transmission of DATA Chunks ...............................75\n   6.2. Acknowledgement on Reception of DATA Chunks ...............78\n        6.2.1. Processing a Received SACK .........................81\n   6.3. Management of Retransmission Timer ........................83\n        6.3.1. RTO Calculation ....................................83\n        6.3.2. Retransmission Timer Rules .........................85\n        6.3.3. Handle T3-rtx Expiration ...........................86\n   6.4. Multi-Homed SCTP Endpoints ................................87\n        6.4.1. Failover from an Inactive Destination Address ......88\n   6.5. Stream Identifier and Stream Sequence Number ..............88\n   6.6. Ordered and Unordered Delivery ............................88\n   6.7. Report Gaps in Received DATA TSNs .........................89\n   6.8. CRC32c Checksum Calculation ...............................90\n   6.9. Fragmentation and Reassembly ..............................91\n   6.10. Bundling .................................................92\n7. Congestion Control .............................................93\n   7.1. SCTP Differences from TCP Congestion Control ..............94",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   7.2. SCTP Slow-Start and Congestion Avoidance ..................95\n        7.2.1. Slow-Start .........................................96\n        7.2.2. Congestion Avoidance ...............................97\n        7.2.3. Congestion Control .................................98\n        7.2.4. Fast Retransmit on Gap Reports .....................98\n   7.3. Path MTU Discovery .......................................100\n8. Fault Management ..............................................100\n   8.1. Endpoint Failure Detection ...............................100\n   8.2. Path Failure Detection ...................................101\n   8.3. Path Heartbeat ...........................................102\n   8.4. Handle \"Out of the Blue\" Packets .........................104\n   8.5. Verification Tag .........................................105\n        8.5.1. Exceptions in Verification Tag Rules ..............105\n9. Termination of Association ....................................106\n   9.1. Abort of an Association ..................................107\n   9.2. Shutdown of an Association ...............................107\n10. Interface with Upper Layer ...................................110\n   10.1. ULP-to-SCTP .............................................110\n   10.2. SCTP-to-ULP .............................................120\n11. Security Considerations ......................................123\n   11.1. Security Objectives .....................................123\n   11.2. SCTP Responses to Potential Threats .....................124\n        11.2.1. Countering Insider Attacks .......................124\n        11.2.2. Protecting against Data Corruption in the\n                Network ..........................................124\n        11.2.3. Protecting Confidentiality .......................124\n        11.2.4. Protecting against Blind\n                Denial-of-Service Attacks ........................125\n               11.2.4.1. Flooding ................................125\n               11.2.4.2. Blind Masquerade ........................126\n               11.2.4.3. Improper Monopolization of Services .....127\n   11.3. SCTP Interactions with Firewalls ........................127\n   11.4. Protection of Non-SCTP-Capable Hosts ....................128\n12. Network Management Considerations ............................128\n13. Recommended Transmission Control Block (TCB) Parameters ......129\n   13.1. Parameters Necessary for the SCTP Instance ..............129\n   13.2. Parameters Necessary per Association (i.e., the TCB) ....129\n   13.3. Per Transport Address Data ..............................131\n   13.4. General Parameters Needed ...............................132\n14. IANA Considerations ..........................................132\n   14.1. IETF-defined Chunk Extension ............................132\n   14.2. IETF-Defined Chunk Parameter Extension ..................133\n   14.3. IETF-Defined Additional Error Causes ....................133\n   14.4. Payload Protocol Identifiers ............................134\n   14.5. Port Numbers Registry ...................................134\n15. Suggested SCTP Protocol Parameter Values .....................136\n16. Acknowledgements .............................................137\nAppendix A. Explicit Congestion Notification .....................139",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Appendix B. CRC32c Checksum Calculation ..........................140\nAppendix C. ICMP Handling ........................................142\nReferences .......................................................149\n   Normative References ..........................................149\n   Informative References ........................................150",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This section explains the reasoning behind the development of the Stream Control Transmission Protocol (SCTP), the services it offers, and the basic concepts needed to understand the detailed description of the protocol.",
      "ja": "このセクションでは、ストリーム制御伝送プロトコル（SCTP）、それが提供するサービス、およびプロトコルの詳細な説明を理解するために必要な基本的な概念の発展の背後にある理由を説明しています。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes [RFC2960] and [RFC3309].",
      "ja": "この文書では、[RFC2960]と[RFC3309]を廃止します。"
    },
    {
      "indent": 0,
      "text": "1.1. Motivation",
      "section_title": true,
      "ja": "1.1。動機"
    },
    {
      "indent": 3,
      "text": "TCP [RFC0793] has performed immense service as the primary means of reliable data transfer in IP networks. However, an increasing number of recent applications have found TCP too limiting, and have incorporated their own reliable data transfer protocol on top of UDP [RFC0768]. The limitations that users have wished to bypass include the following:",
      "ja": "TCP [RFC0793]はIPネットワークにおける信頼性の高いデータ転送の主要な手段として巨大サービスを行いました。しかし、最近のアプリケーションの増加数はTCPがあまりにも制限を発見した、とUDP [RFC0768]の上に、独自の信頼性の高いデータ転送プロトコルが組み込まれています。ユーザーがバイパスに願っている制限事項は、次のものがあります。"
    },
    {
      "indent": 3,
      "text": "-- TCP provides both reliable data transfer and strict order-of-transmission delivery of data. Some applications need reliable transfer without sequence maintenance, while others would be satisfied with partial ordering of the data. In both of these cases, the head-of-line blocking offered by TCP causes unnecessary delay.",
      "ja": " -  TCPは信頼性のあるデータ転送とデータの厳密な順序の伝送送達の両方を提供します。他の人がデータの一部の順序付けで満足するだろうが一部のアプリケーションでは、シーケンス・メンテナンスなしで信頼性の高い転送を必要とします。どちらの場合も、TCPが提供するヘッドオブラインブロッキングが不要な遅延が発生します。"
    },
    {
      "indent": 3,
      "text": "-- The stream-oriented nature of TCP is often an inconvenience. Applications must add their own record marking to delineate their messages, and must make explicit use of the push facility to ensure that a complete message is transferred in a reasonable time.",
      "ja": " -  TCPのストリーム指向の性質はしばしば不便です。アプリケーションは、彼らのメッセージを描写するためにマーキング自分のレコードを追加しなければならない、と完全なメッセージが適切な時間内に転送されることを保証するためにプッシュ機能を明示的に使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "-- The limited scope of TCP sockets complicates the task of providing highly-available data transfer capability using multi-homed hosts.",
      "ja": " -  TCPソケットの限られた範囲は、マルチホームホストを使用して、高可用性データ転送能力を提供するタスクを複雑にします。"
    },
    {
      "indent": 3,
      "text": "-- TCP is relatively vulnerable to denial-of-service attacks, such as SYN attacks.",
      "ja": " -  TCPは、SYN攻撃などのサービス拒否攻撃に比較的脆弱です。"
    },
    {
      "indent": 3,
      "text": "Transport of PSTN signaling across the IP network is an application for which all of these limitations of TCP are relevant. While this application directly motivated the development of SCTP, other applications may find SCTP a good match to their requirements.",
      "ja": "IPネットワークを介してシグナリングをPSTNの輸送は、TCPのこれらの制限のすべてが関連されるアプリケーションです。このアプリケーションは直接SCTPの開発を動機としながら、他のアプリケーションがSCTPにその要件に良い一致を見つけることができます。"
    },
    {
      "indent": 0,
      "text": "1.2. Architectural View of SCTP",
      "section_title": true,
      "ja": "1.2。 SCTPの建築を見ます"
    },
    {
      "indent": 3,
      "text": "SCTP is viewed as a layer between the SCTP user application (\"SCTP user\" for short) and a connectionless packet network service such as IP. The remainder of this document assumes SCTP runs on top of IP. The basic service offered by SCTP is the reliable transfer of user messages between peer SCTP users. It performs this service within the context of an association between two SCTP endpoints. Section 10 of this document sketches the API that should exist at the boundary between the SCTP and the SCTP user layers.",
      "ja": "SCTPは、SCTPユーザアプリケーション（略して「SCTPユーザ」）とIPなどのコネクションレスのパケットネットワークサービスとの間の層として観察されます。このドキュメントの残りの部分は、SCTPがIPの上で実行を前提としています。 SCTPによって提供される基本的なサービスは、ピアSCTPユーザ間でユーザメッセージの信頼性の転送です。それは2つのSCTPエンドポイントとの間の関連のコンテキスト内で、このサービスを実行します。このドキュメントのセクション10は、SCTPとSCTPユーザ層の境界に存在するはずAPIをスケッチ。"
    },
    {
      "indent": 3,
      "text": "SCTP is connection-oriented in nature, but the SCTP association is a broader concept than the TCP connection. SCTP provides the means for each SCTP endpoint (Section 1.3) to provide the other endpoint (during association startup) with a list of transport addresses (i.e., multiple IP addresses in combination with an SCTP port) through which that endpoint can be reached and from which it will originate SCTP packets. The association spans transfers over all of the possible source/destination combinations that may be generated from each endpoint's lists.",
      "ja": "SCTPはコネクション指向の性質であるが、SCTPアソシエーションはTCPコネクションよりも広い概念です。 SCTPトランスポートアドレスのリストと各SCTPエンドポイント（1.3節）（関連の起動時に）他のエンドポイントを提供するための手段を提供する（すなわち、SCTPポートと組み合わせて、複数のIPアドレス）がそこを通ってそのエンドポイントに達するとからすることができそれはSCTPパケットを発信します。会合は、各エンドポイントのリストから生成することができる可能なソース/宛先の組み合わせ全てにわたって転送をまたがります。"
    },
    {
      "indent": 6,
      "text": " _____________                                      _____________\n|  SCTP User  |                                    |  SCTP User  |\n| Application |                                    | Application |\n|-------------|                                    |-------------|\n|    SCTP     |                                    |    SCTP     |\n|  Transport  |                                    |  Transport  |\n|   Service   |                                    |   Service   |\n|-------------|                                    |-------------|\n|             |One or more    ----      One or more|             |\n| IP Network  |IP address      \\/        IP address| IP Network  |\n|   Service   |appearances     /\\       appearances|   Service   |\n|_____________|               ----                 |_____________|",
      "raw": true
    },
    {
      "indent": 8,
      "text": "SCTP Node A |<-------- Network transport ------->| SCTP Node B",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 1: An SCTP Association",
      "ja": "図1：SCTP協会"
    },
    {
      "indent": 0,
      "text": "1.3. Key Terms",
      "section_title": true,
      "ja": "1.3。重要な用語"
    },
    {
      "indent": 3,
      "text": "Some of the language used to describe SCTP has been introduced in the previous sections. This section provides a consolidated list of the key terms and their definitions.",
      "ja": "SCTPを記述するために使用される言語のいくつかは、前のセクションで導入されました。このセクションでは、重要な用語とその定義の統合されたリストを提供します。"
    },
    {
      "indent": 3,
      "text": "o Active destination transport address: A transport address on a peer endpoint that a transmitting endpoint considers available for receiving user messages.",
      "ja": "Oアクティブ宛先トランスポートアドレス：送信エンドポイントは、ユーザ・メッセージを受信するために利用できると考えてピアエンドポイントのトランスポート・アドレス。"
    },
    {
      "indent": 3,
      "text": "o Bundling: An optional multiplexing operation, whereby more than one user message may be carried in the same SCTP packet. Each user message occupies its own DATA chunk.",
      "ja": "Oバンドリング：複数のユーザメッセージが同じSCTPパケットに実施することができることにより、任意の多重化動作。各ユーザーのメッセージは、独自のデータチャンクを占めています。"
    },
    {
      "indent": 3,
      "text": "o Chunk: A unit of information within an SCTP packet, consisting of a chunk header and chunk-specific content.",
      "ja": "Oチャンク：チャンクのヘッダ及びチャンク固有のコンテンツからなるSCTPパケット内の情報の単位。"
    },
    {
      "indent": 3,
      "text": "o Congestion window (cwnd): An SCTP variable that limits the data, in number of bytes, a sender can send to a particular destination transport address before receiving an acknowledgement.",
      "ja": "O輻輳ウィンドウ（CWND）：バイト数で、データを制限するSCTP変数は、送信者が確認応答を受信する前に、特定の送付先輸送アドレスに送信することができます。"
    },
    {
      "indent": 3,
      "text": "o Cumulative TSN Ack Point: The TSN of the last DATA chunk acknowledged via the Cumulative TSN Ack field of a SACK.",
      "ja": "O累積TSN Ackをポイント：最後のDATAチャンクのTSNはSACKの累積TSN ACKフィールドを経由して認めました。"
    },
    {
      "indent": 3,
      "text": "o Idle destination address: An address that has not had user messages sent to it within some length of time, normally the HEARTBEAT interval or greater.",
      "ja": "Oアイドル宛先アドレス：ある程度の時間内に送信されたユーザメッセージを持っていないアドレス、通常はハートビート間隔以上です。"
    },
    {
      "indent": 3,
      "text": "o Inactive destination transport address: An address that is considered inactive due to errors and unavailable to transport user messages.",
      "ja": "O非アクティブ先のトランスポートアドレス：エラーのため、非アクティブと見なされているアドレスとユーザーのメッセージを転送する使用できません。"
    },
    {
      "indent": 3,
      "text": "o Message = user message: Data submitted to SCTP by the Upper Layer Protocol (ULP).",
      "ja": "Oメッセージ=ユーザメッセージ：データは上位層プロトコル（ULP）でSCTPに提出。"
    },
    {
      "indent": 3,
      "text": "o Message Authentication Code (MAC): An integrity check mechanism based on cryptographic hash functions using a secret key. Typically, message authentication codes are used between two parties that share a secret key in order to validate information transmitted between these parties. In SCTP, it is used by an endpoint to validate the State Cookie information that is returned from the peer in the COOKIE ECHO chunk. The term \"MAC\" has different meanings in different contexts. SCTP uses this term with the same meaning as in [RFC2104].",
      "ja": "Oメッセージ認証コード（MAC）：秘密鍵を使って暗号化ハッシュ関数に基づいて、整合性のチェック機構。典型的には、メッセージ認証コードは、これらの当事者間で送信された情報を検証するために秘密鍵を共有する2つの当事者間で使用されています。 SCTPでは、COOKIE ECHOチャンクにピアから返される状態のCookie情報を検証するために、エンドポイントによって使用されます。用語「MAC」は、異なる文脈で異なる意味を持っています。 SCTPは、[RFC2104]と同じ意味でこの用語を使用しています。"
    },
    {
      "indent": 3,
      "text": "o Network Byte Order: Most significant byte first, a.k.a., big endian.",
      "ja": "Oネットワークバイト順：最上位バイトまず、別称、ビッグエンディアン。"
    },
    {
      "indent": 3,
      "text": "o Ordered Message: A user message that is delivered in order with respect to all previous user messages sent within the stream on which the message was sent.",
      "ja": "O順序メッセージ：メッセージが送信されたストリーム内で送信されたすべての以前のユーザメッセージに対して順番に配信されるユーザメッセージ。"
    },
    {
      "indent": 3,
      "text": "o Outstanding TSN (at an SCTP endpoint): A TSN (and the associated DATA chunk) that has been sent by the endpoint but for which it has not yet received an acknowledgement.",
      "ja": "O優れたTSN（SCTPエンドポイントで）：エンドポイントではなく、それはまだ確認応答を受信しなかったために送信されたTSN（および関連するデータチャンク）。"
    },
    {
      "indent": 3,
      "text": "o Path: The route taken by the SCTP packets sent by one SCTP endpoint to a specific destination transport address of its peer SCTP endpoint. Sending to different destination transport addresses does not necessarily guarantee getting separate paths.",
      "ja": "Oパス：ピアSCTPエンドポイントの特定の宛先トランスポートアドレス1つのSCTPエンドポイントによって送信されるSCTPパケットによって取られる経路。異なる宛先トランスポートアドレスに送信すると、必然的に別々のパスを取得して保証するものではありません。"
    },
    {
      "indent": 3,
      "text": "o Primary Path: The primary path is the destination and source address that will be put into a packet outbound to the peer endpoint by default. The definition includes the source address since an implementation MAY wish to specify both destination and source address to better control the return path taken by reply chunks and on which interface the packet is transmitted when the data sender is multi-homed.",
      "ja": "Oプライマリパス：プライマリパスは、デフォルトでは、ピアエンドポイントにパケットの発信に入れられます、宛先と送信元アドレスです。定義は、実装がよりよい応答チャンクによって撮影されたリターンパスを制御するために、両方の宛先および送信元アドレスを指定することを望むかもしれないので、送信元アドレスを含み、その上にデータ送信者がマルチホームである場合、パケットが送信されるインターフェイス。"
    },
    {
      "indent": 3,
      "text": "o Receiver Window (rwnd): An SCTP variable a data sender uses to store the most recently calculated receiver window of its peer, in number of bytes. This gives the sender an indication of the space available in the receiver's inbound buffer.",
      "ja": "Oレシーバウィンドウ（RWND）：データ送信側はバイト数で、そのピアの最も最近に計算され、受信機ウィンドウを格納するために使用するSCTP変数。これは、送信者に受信者の着信バッファ内の利用可能なスペースの表示を提供します。"
    },
    {
      "indent": 3,
      "text": "o SCTP association: A protocol relationship between SCTP endpoints, composed of the two SCTP endpoints and protocol state information including Verification Tags and the currently active set of Transmission Sequence Numbers (TSNs), etc. An association can be uniquely identified by the transport addresses used by the endpoints in the association. Two SCTP endpoints MUST NOT have more than one SCTP association between them at any given time.",
      "ja": "O SCTPアソシエーション2つのSCTPエンドポイントからなるSCTPエンドポイント、および検証タグと伝送シーケンス番号（TSNを）の現在のアクティブセットを含むプロトコル状態情報との間のプロトコルの関係等関連一意に使用されるトランスポート・アドレスによって同定することができます協会内のエンドポイントによって。二つのSCTPエンドポイントは、任意の時点で、それらの間に複数のSCTPアソシエーションを持ってはいけません。"
    },
    {
      "indent": 3,
      "text": "o SCTP endpoint: The logical sender/receiver of SCTP packets. On a multi-homed host, an SCTP endpoint is represented to its peers as a combination of a set of eligible destination transport addresses to which SCTP packets can be sent and a set of eligible source transport addresses from which SCTP packets can be received. All transport addresses used by an SCTP endpoint must use the same port number, but can use multiple IP addresses. A transport address used by an SCTP endpoint must not be used by another SCTP endpoint. In other words, a transport address is unique to an SCTP endpoint.",
      "ja": "OのSCTP端末：SCTPパケットの論理的な送信者/受信機。マルチホームホスト上で、SCTP終点は、SCTPパケットが送信可能な対象先輸送アドレスのセットとSCTPパケットを受信することができ、そこから対象ソーストランスポートアドレスのセットの組み合わせとして、そのピアに表されています。 SCTP終点によって使用されるすべてのトランスポートアドレスは同じポート番号を使用する必要がありますが、複数のIPアドレスを使用することができます。 SCTP終点によって使用されるトランスポートアドレスは別のSCTP終点で使用することはできません。つまり、トランスポートアドレスは、SCTP端末に固有のものです。"
    },
    {
      "indent": 3,
      "text": "o SCTP packet (or packet): The unit of data delivery across the interface between SCTP and the connectionless packet network (e.g., IP). An SCTP packet includes the common SCTP header, possible SCTP control chunks, and user data encapsulated within SCTP DATA chunks.",
      "ja": "OのSCTPパケット（またはパケット）：SCTPコネクションとパケット網（例えば、IP）との間の界面を横切ってデータ配信のユニット。 SCTPパケットは、SCTPデータチャンク内に封入共通SCTPヘッダ、可能なSCTP制御チャンク、及びユーザデータを含みます。"
    },
    {
      "indent": 3,
      "text": "o SCTP user application (SCTP user): The logical higher-layer application entity which uses the services of SCTP, also called the Upper-Layer Protocol (ULP).",
      "ja": "O SCTPユーザアプリケーション（SCTPユーザ）：SCTPのサービスを使用する論理上位層のアプリケーションエンティティは、また、上位層プロトコル（ULP）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "o Slow-Start Threshold (ssthresh): An SCTP variable. This is the threshold that the endpoint will use to determine whether to perform slow start or congestion avoidance on a particular destination transport address. Ssthresh is in number of bytes.",
      "ja": "Oスロースタート閾値（SSTHRESH）：SCTP変数。これは、エンドポイントが特定の宛先トランスポートアドレスにスロースタートや輻輳回避を実行するかどうかを決定するために使用する閾値です。 SSTHRESHは、バイト数です。"
    },
    {
      "indent": 3,
      "text": "o Stream: A unidirectional logical channel established from one to another associated SCTP endpoint, within which all user messages are delivered in sequence except for those submitted to the unordered delivery service.",
      "ja": "Oストリーム：すべてのユーザメッセージが順不同配信サービスに提出されるものを除いて配列で配信される内の別の関連SCTPエンドポイント、1つの確立された一方向の論理チャネル。"
    },
    {
      "indent": 3,
      "text": "Note: The relationship between stream numbers in opposite directions is strictly a matter of how the applications use them. It is the responsibility of the SCTP user to create and manage these correlations if they are so desired.",
      "ja": "注意：逆方向のストリーム番号との関係は、厳密にアプリケーションがそれらを使用する方法の問題です。彼らがそのように望まれている場合は、これらの相関関係を作成し、管理するためにSCTPユーザの責任です。"
    },
    {
      "indent": 3,
      "text": "o Stream Sequence Number: A 16-bit sequence number used internally by SCTP to ensure sequenced delivery of the user messages within a given stream. One Stream Sequence Number is attached to each user message.",
      "ja": "Oストリームシーケンス番号：指定されたストリーム内のユーザメッセージの配列決定の送達を確実にするために、SCTPによって内部的に使用される16ビットのシーケンス番号。一つのストリームシーケンス番号は、各ユーザのメッセージに添付されています。"
    },
    {
      "indent": 3,
      "text": "o Tie-Tags: Two 32-bit random numbers that together make a 64-bit nonce. These tags are used within a State Cookie and TCB so that a newly restarting association can be linked to the original association within the endpoint that did not restart and yet not reveal the true Verification Tags of an existing association.",
      "ja": "Oタイタグ：一緒に64ビットのnonceを作る2つの32ビットの乱数。新しく再開会合が再起動しないと、まだ既存の関連付けの真の検証タグを明らかにしなかったエンドポイント内の元組合にリンクすることができるように、これらのタグは、国家CookieとTCB内で使用されています。"
    },
    {
      "indent": 3,
      "text": "o Transmission Control Block (TCB): An internal data structure created by an SCTP endpoint for each of its existing SCTP associations to other SCTP endpoints. TCB contains all the status and operational information for the endpoint to maintain and manage the corresponding association.",
      "ja": "O伝送制御ブロック（TCB）：他のSCTPエンドポイントに対する既存のSCTPアソシエーションのそれぞれに対するSCTPエンドポイントによって作成された内部データ構造。 TCBは、対応する関連を維持し、管理するためのエンドポイントのすべてのステータスおよび運用情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Transmission Sequence Number (TSN): A 32-bit sequence number used internally by SCTP. One TSN is attached to each chunk containing user data to permit the receiving SCTP endpoint to acknowledge its receipt and detect duplicate deliveries.",
      "ja": "O送信シーケンス番号（TSN）：SCTPによって内部的に使用される32ビットのシーケンス番号。一つのTSNは、その受領を確認し、重複配達を検出するために、受信したSCTP終点を可能にするために、ユーザー・データを含む各チャンクに取り付けられています。"
    },
    {
      "indent": 3,
      "text": "o Transport address: A transport address is traditionally defined by a network-layer address, a transport-layer protocol, and a transport-layer port number. In the case of SCTP running over IP, a transport address is defined by the combination of an IP address and an SCTP port number (where SCTP is the transport protocol).",
      "ja": "Oトランスポートアドレス：トランスポートアドレスは、従来のネットワーク層アドレス、トランスポート層プロトコル、およびトランスポート層のポート番号によって定義されます。 SCTPは、IP上で動作する場合には、トランスポートアドレスはIPアドレス及び（SCTPトランスポートプロトコルである）SCTPポート番号の組み合わせで定義されています。"
    },
    {
      "indent": 3,
      "text": "o Unacknowledged TSN (at an SCTP endpoint): A TSN (and the associated DATA chunk) that has been received by the endpoint but for which an acknowledgement has not yet been sent. Or in the opposite case, for a packet that has been sent but no acknowledgement has been received.",
      "ja": "（SCTPエンドポイントで）O未確認TSN：エンドポイントではなく、肯定応答がまだ送信されていないために受信されたTSN（および関連するデータチャンク）。あるいは逆の場合は、送られてきたが、確認応答を受信して​​いないパケットのため。"
    },
    {
      "indent": 3,
      "text": "o Unordered Message: Unordered messages are \"unordered\" with respect to any other message; this includes both other unordered messages as well as other ordered messages. An unordered message might be delivered prior to or later than ordered messages sent on the same stream.",
      "ja": "O順不同メッセージ：順不同のメッセージは他のメッセージに対して「無秩序」です。これは他の順不同のメッセージだけでなく、他の注文したメッセージの両方を含んでいます。順不同のメッセージは、前または後に同じストリームで送信された注文メッセージより配信されることがあります。"
    },
    {
      "indent": 3,
      "text": "o User message: The unit of data delivery across the interface between SCTP and its user.",
      "ja": "Oユーザメッセージ：SCTPとユーザとの間の界面を横切るデータ配信のユニット。"
    },
    {
      "indent": 3,
      "text": "o Verification Tag: A 32-bit unsigned integer that is randomly generated. The Verification Tag provides a key that allows a receiver to verify that the SCTP packet belongs to the current association and is not an old or stale packet from a previous association.",
      "ja": "O検証タグ：ランダムに生成される32ビットの符号なし整数。検証タグは、受信機がSCTPパケットが現在のアソシエーションに属し、以前の関連付けから古いまたは古いパケットではないことを確認することができますキーを提供します。"
    },
    {
      "indent": 0,
      "text": "1.4. Abbreviations",
      "section_title": true,
      "ja": "1.4。略語"
    },
    {
      "indent": 3,
      "text": "MAC - Message Authentication Code [RFC2104]",
      "ja": "MAC  - メッセージ認証コード[RFC2104]"
    },
    {
      "indent": 3,
      "text": "RTO - Retransmission Timeout",
      "ja": "RTO  - 再送信タイムアウト"
    },
    {
      "indent": 3,
      "text": "RTT - Round-Trip Time",
      "ja": "RTT  - ラウンドトリップ時間"
    },
    {
      "indent": 3,
      "text": "RTTVAR - Round-Trip Time Variation",
      "ja": "RTTVAR  - ラウンドトリップ時間の変動"
    },
    {
      "indent": 3,
      "text": "SCTP - Stream Control Transmission Protocol",
      "ja": "SCTP  - ストリーム制御伝送プロトコル"
    },
    {
      "indent": 3,
      "text": "SRTT - Smoothed RTT",
      "ja": "SRTT  -  RTT平滑化"
    },
    {
      "indent": 3,
      "text": "TCB - Transmission Control Block",
      "ja": "TCB  - 伝送制御ブロック"
    },
    {
      "indent": 3,
      "text": "TLV - Type-Length-Value coding format",
      "ja": "TLV  - なType-Length-値符号化フォーマット"
    },
    {
      "indent": 3,
      "text": "TSN - Transmission Sequence Number",
      "ja": "TSN  - 送信シーケンス番号"
    },
    {
      "indent": 3,
      "text": "ULP - Upper-Layer Protocol",
      "ja": "ULP  - 上位層プロトコル"
    },
    {
      "indent": 0,
      "text": "1.5. Functional View of SCTP",
      "section_title": true,
      "ja": "1.5。 SCTPの機能を表示"
    },
    {
      "indent": 3,
      "text": "The SCTP transport service can be decomposed into a number of functions. These are depicted in Figure 2 and explained in the remainder of this section.",
      "ja": "SCTP輸送サービスは、多数の機能に分解することができます。これらは、図2に示され、このセクションの残りの部分で説明されています。"
    },
    {
      "indent": 27,
      "text": "SCTP User Application",
      "ja": "SCTPユーザアプリケーション"
    },
    {
      "indent": 12,
      "text": "-----------------------------------------------------\n _____________                  ____________________\n|             |                | Sequenced Delivery |\n| Association |                |   within Streams   |\n|             |                |____________________|\n|   Startup   |\n|             |         ____________________________\n|     and     |        |    User Data Fragmentation |\n|             |        |____________________________|\n|   Takedown  |\n|             |         ____________________________\n|             |        |     Acknowledgement        |\n|             |        |          and               |\n|             |        |    Congestion Avoidance    |\n|             |        |____________________________|\n|             |\n|             |         ____________________________\n|             |        |       Chunk Bundling       |\n|             |        |____________________________|\n|             |\n|             |     ________________________________\n|             |    |      Packet Validation         |\n|             |    |________________________________|\n|             |\n|             |     ________________________________\n|             |    |     Path Management            |\n|_____________|    |________________________________|",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 2: Functional View of the SCTP Transport Service",
      "ja": "図2：SCTPトランスポートサービスの機能を表示"
    },
    {
      "indent": 0,
      "text": "1.5.1. Association Startup and Takedown",
      "section_title": true,
      "ja": "1.5.1。協会起動とテイクダウン"
    },
    {
      "indent": 3,
      "text": "An association is initiated by a request from the SCTP user (see the description of the ASSOCIATE (or SEND) primitive in Section 10).",
      "ja": "関連付けはSCTPユーザからの要求によって開始される（セクション10内のプリミティブ）を関連付けるの説明を参照してください（またはSEND）。"
    },
    {
      "indent": 3,
      "text": "A cookie mechanism, similar to one described by Karn and Simpson in [RFC2522], is employed during the initialization to provide protection against synchronization attacks. The cookie mechanism uses a four-way handshake, the last two legs of which are allowed to carry user data for fast setup. The startup sequence is described in Section 5 of this document.",
      "ja": "[RFC2522]でカーンとシンプソンによって記載したものと同様のクッキー機構は、同期攻撃に対する保護を提供するために、初期化中に使用されます。クッキーメカニズムは4ウェイハンドシェイク、高速なセットアップ用のユーザデータを運ぶために許可されているの最後の2足を使用しています。起動シーケンスは、このドキュメントのセクション5に記載されています。"
    },
    {
      "indent": 3,
      "text": "SCTP provides for graceful close (i.e., shutdown) of an active association on request from the SCTP user. See the description of the SHUTDOWN primitive in Section 10. SCTP also allows ungraceful close (i.e., abort), either on request from the user (ABORT primitive) or as a result of an error condition detected within the SCTP layer. Section 9 describes both the graceful and the ungraceful close procedures.",
      "ja": "SCTPはSCTPユーザからのリクエストに応じてアクティブ・アソシエーションの優雅近い（すなわち、シャットダウン）を提供します。また無様な（すなわち、中断）、いずれかのユーザからの要求に近い（プリミティブABORT）又はSCTP層内で検出されたエラー状態の結果としての可能セクション10 SCTPにおけるプリミティブSHUTDOWNの説明を参照してください。第9章は、優雅で無様に近い手順の両​​方を説明します。"
    },
    {
      "indent": 3,
      "text": "SCTP does not support a half-open state (like TCP) wherein one side may continue sending data while the other end is closed. When either endpoint performs a shutdown, the association on each peer will stop accepting new data from its user and only deliver data in queue at the time of the graceful close (see Section 9).",
      "ja": "SCTPは、他端を閉じた状態で一方の側がデータを送信し続けることができる特徴（TCPなど）半開状態をサポートしていません。いずれかのエンドポイントがシャットダウンを行う場合、各ピアの関連付けは、ユーザからの新しいデータの受け入れを停止のみ（セクション9を参照）優雅なクローズ時にキュー内のデータを配信します。"
    },
    {
      "indent": 0,
      "text": "1.5.2. Sequenced Delivery within Streams",
      "section_title": true,
      "ja": "1.5.2。ストリーム内のシーケンス・配達"
    },
    {
      "indent": 3,
      "text": "The term \"stream\" is used in SCTP to refer to a sequence of user messages that are to be delivered to the upper-layer protocol in order with respect to other messages within the same stream. This is in contrast to its usage in TCP, where it refers to a sequence of bytes (in this document, a byte is assumed to be 8 bits).",
      "ja": "用語「流れ」は、同じストリーム内の他のメッセージに対して順番に上位層プロトコルに配信されるユーザメッセージの配列を指すためにSCTPで用いられます。これは、（本書では、バイトは8ビットであると仮定される）バイトの配列を指すTCPにおけるその使用とは対照的です。"
    },
    {
      "indent": 3,
      "text": "The SCTP user can specify at association startup time the number of streams to be supported by the association. This number is negotiated with the remote end (see Section 5.1.1). User messages are associated with stream numbers (SEND, RECEIVE primitives, Section 10). Internally, SCTP assigns a Stream Sequence Number to each message passed to it by the SCTP user. On the receiving side, SCTP ensures that messages are delivered to the SCTP user in sequence within a given stream. However, while one stream may be blocked waiting for the next in-sequence user message, delivery from other streams may proceed.",
      "ja": "SCTPユーザはアソシエーションの起動時にアソシエーションによってサポートされるストリームの数を指定することができます。この番号は、リモートエンド（5.1.1項を参照）と交渉しています。ユーザのメッセージは（セクション10、プリミティブを受信し、SEND）ストリーム番号に関連付けられています。内部的には、SCTPはSCTPユーザによって渡された各メッセージにストリームシーケンス番号を割り当てます。受信側では、SCTPメッセージが与えられたストリーム内の配列にSCTPユーザに配信されることを保証します。一つのストリームが次にシーケンスユーザメッセージを待ってブロックされるかもしれないが、他のストリームからの送達が進行してもよいです。"
    },
    {
      "indent": 3,
      "text": "SCTP provides a mechanism for bypassing the sequenced delivery service. User messages sent using this mechanism are delivered to the SCTP user as soon as they are received.",
      "ja": "SCTPは、配列決定配信サービスをバイパスするための機構を提供します。このメカニズムを使用して送信されたユーザー・メッセージは、すぐに彼らが受信されるSCTPユーザに配信されます。"
    },
    {
      "indent": 0,
      "text": "1.5.3. User Data Fragmentation",
      "section_title": true,
      "ja": "1.5.3。ユーザーデータの断片化"
    },
    {
      "indent": 3,
      "text": "When needed, SCTP fragments user messages to ensure that the SCTP packet passed to the lower layer conforms to the path MTU. On receipt, fragments are reassembled into complete messages before being passed to the SCTP user.",
      "ja": "必要な場合には、SCTPは、下位層に渡されるSCTPパケットがパスMTUに準拠していることを保証するために、ユーザメッセージを断片化します。領収書では、フラグメントは、SCTPユーザに渡される前に、完全なメッセージに再構築されています。"
    },
    {
      "indent": 0,
      "text": "1.5.4. Acknowledgement and Congestion Avoidance",
      "section_title": true,
      "ja": "1.5.4。謝辞および輻輳回避"
    },
    {
      "indent": 3,
      "text": "SCTP assigns a Transmission Sequence Number (TSN) to each user data fragment or unfragmented message. The TSN is independent of any Stream Sequence Number assigned at the stream level. The receiving end acknowledges all TSNs received, even if there are gaps in the sequence. In this way, reliable delivery is kept functionally separate from sequenced stream delivery.",
      "ja": "SCTPは、各ユーザのデータフラグメントまたはフラグメント化されていないメッセージの送信シーケンス番号（TSN）を割り当てます。 TSNはストリームレベルで割り当てられた任意のストリームシーケンス番号とは無関係です。受信端はシーケンスにギャップがあっても、全てのTSNが受信確認応答します。このように、信頼性の高い配信は、シーケンスされたストリーム配信から機能的に分離して保持されます。"
    },
    {
      "indent": 3,
      "text": "The acknowledgement and congestion avoidance function is responsible for packet retransmission when timely acknowledgement has not been received. Packet retransmission is conditioned by congestion avoidance procedures similar to those used for TCP. See Section 6 and Section 7 for a detailed description of the protocol procedures associated with this function.",
      "ja": "タイムリーに確認応答を受信して​​いない時に確認し、輻輳回避機能は、パケットの再送を担当しています。パケットの再送はTCPのために使用されるものと同様の輻輳回避手順によって調整されます。この機能に関連付けられたプロトコル手順の詳細な説明については、セクション6とセクション7を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.5.5. Chunk Bundling",
      "section_title": true,
      "ja": "1.5.5。チャンクバンドル"
    },
    {
      "indent": 3,
      "text": "As described in Section 3, the SCTP packet as delivered to the lower layer consists of a common header followed by one or more chunks. Each chunk may contain either user data or SCTP control information. The SCTP user has the option to request bundling of more than one user message into a single SCTP packet. The chunk bundling function of SCTP is responsible for assembly of the complete SCTP packet and its disassembly at the receiving end.",
      "ja": "第3節で説明したように、下層に送られるようSCTPパケットは、一つ以上のチャンクに続く共通ヘッダから成ります。各チャンクは、ユーザデータ又はSCTP制御情報のいずれかを含むことができます。 SCTPユーザは、単一のSCTPパケットに複数のユーザメッセージのバンドルを要求するオプションがあります。 SCTPのチャンク束ねる機能は、完全なSCTPパケットの組み立てと受信端での解体を担当しています。"
    },
    {
      "indent": 3,
      "text": "During times of congestion, an SCTP implementation MAY still perform bundling even if the user has requested that SCTP not bundle. The user's disabling of bundling only affects SCTP implementations that may delay a small period of time before transmission (to attempt to encourage bundling). When the user layer disables bundling, this small delay is prohibited but not bundling that is performed during congestion or retransmission.",
      "ja": "輻輳時に、SCTPの実装はまだユーザーがSCTPをバンドルしていないことを要求した場合でも、バンドルを実行するかもしれません。同梱のユーザーの無効化が唯一の送信前の時間の小さな期間を遅らせる可能性がSCTPの実装に影響を与えます（バンドル奨励しようとします）。ユーザ層がバンドリングを無効にしたときに、この小さな遅延が禁止されているが、それを束ねていないが、輻輳又は再送信の間に行われます。"
    },
    {
      "indent": 0,
      "text": "1.5.6. Packet Validation",
      "section_title": true,
      "ja": "1.5.6。パケット検証"
    },
    {
      "indent": 3,
      "text": "A mandatory Verification Tag field and a 32-bit checksum field (see Appendix B for a description of the CRC32c checksum) are included in the SCTP common header. The Verification Tag value is chosen by each end of the association during association startup. Packets received without the expected Verification Tag value are discarded, as a protection against blind masquerade attacks and against stale SCTP packets from a previous association. The CRC32c checksum should be set by the sender of each SCTP packet to provide additional protection against data corruption in the network. The receiver of an SCTP packet with an invalid CRC32c checksum silently discards the packet.",
      "ja": "必須の検証タグフィールドと32ビットのチェックサムフィールドは、（CRC32Cチェックサムの説明については、付録Bを参照）SCTP共通ヘッダに含まれています。検証タグ値は、協会の起動時に協会のそれぞれの端部によって選択されます。予想される検証タグ値なしで受信されたパケットは、ブラインドマスカレード攻撃に対する防御として、前の協会からの古いSCTPパケットに対して、破棄されます。 CRC32Cチェックサムは、ネットワーク内のデータ破損に対する追加の保護を提供するために、各SCTPパケットの送信者によって設定されるべきです。無効なCRC32CチェックサムとのSCTPパケットの受信機は静かにパケットを廃棄します。"
    },
    {
      "indent": 0,
      "text": "1.5.7. Path Management",
      "section_title": true,
      "ja": "1.5.7。パス管理"
    },
    {
      "indent": 3,
      "text": "The sending SCTP user is able to manipulate the set of transport addresses used as destinations for SCTP packets through the primitives described in Section 10. The SCTP path management function chooses the destination transport address for each outgoing SCTP packet based on the SCTP user's instructions and the currently perceived reachability status of the eligible destination set. The path management function monitors reachability through heartbeats when other packet traffic is inadequate to provide this information and advises the SCTP user when reachability of any far-end transport address changes. The path management function is also responsible for reporting the eligible set of local transport addresses to the far end during association startup, and for reporting the transport addresses returned from the far end to the SCTP user.",
      "ja": "送信SCTPユーザは、SCTPパス管理機能は、SCTPユーザの指示に基づいて各発信SCTPパケットの宛先トランスポート・アドレスを選択し、セクション10に記載プリミティブを通じてSCTPパケットの宛先として使用されるトランスポート・アドレスのセットを操作することが可能です現在、適格な宛先セットの到達可能性ステータスを感じました。他のパケットトラフィックがこの情報を提供するには不十分であり、任意の遠端トランスポートアドレスの変更の際に到達可能SCTPユーザに通知する際に、パス管理機能は、ハートビートを介して到達可能性を監視します。パス管理機能も協会の起動時に遠端にローカルトランスポートアドレスの適格なセットを報告するための、およびトランスポート・アドレスは、SCTPユーザに遠端から戻って報告する責任があります。"
    },
    {
      "indent": 3,
      "text": "At association startup, a primary path is defined for each SCTP endpoint, and is used for normal sending of SCTP packets.",
      "ja": "関連の起動時に、プライマリパスは、各SCTPエンドポイントのために定義され、通常は、SCTPパケットの送信のために使用されます。"
    },
    {
      "indent": 3,
      "text": "On the receiving end, the path management is responsible for verifying the existence of a valid SCTP association to which the inbound SCTP packet belongs before passing it for further processing.",
      "ja": "受信側では、パス管理は、インバウンドSCTPパケットがさらなる処理のためにそれを渡す前に属する有効なSCTPアソシエーションの存在を確認する責任があります。"
    },
    {
      "indent": 3,
      "text": "Note: Path Management and Packet Validation are done at the same time, so although described separately above, in reality they cannot be performed as separate items.",
      "ja": "注：別々に上述したが、実際にはそれらは別々のアイテムとして行うことができないので、パス管理とパケット検証は、同時に行われます。"
    },
    {
      "indent": 0,
      "text": "1.6. Serial Number Arithmetic",
      "section_title": true,
      "ja": "1.6。シリアル番号の算術"
    },
    {
      "indent": 3,
      "text": "It is essential to remember that the actual Transmission Sequence Number space is finite, though very large. This space ranges from 0 to 2**32 - 1. Since the space is finite, all arithmetic dealing with Transmission Sequence Numbers must be performed modulo 2**32. This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2**32 - 1 to 0 again. There are some subtleties to computer modulo arithmetic, so great care should be taken in programming the comparison of such values. When referring to TSNs, the symbol \"=<\" means \"less than or equal\"(modulo 2**32).",
      "ja": "非常に大きいけれども実際の送信シーケンス番号空間が有限であることを覚えておくことが不可欠です。 1.スペースが有限であるため、伝送シーケンス番号を扱う全ての演算がモジュロ2 ** 32を実行しなければならない - この空間は0から2 ** 32の範囲です。再び1 0  - この符号なしの算術演算は、2 ** 32から彼らサイクルとしてシーケンス番号の関係を維持します。いくつかの微妙なので、細心の注意がこのような値の比較をプログラミングに注意する必要があり、コンピュータのモジュロ演算にあります。 TSNを、記号「= <」に言及するとき（モジュロ2 ** 32）「以下」を意味します。"
    },
    {
      "indent": 3,
      "text": "Comparisons and arithmetic on TSNs in this document SHOULD use Serial Number Arithmetic as defined in [RFC1982] where SERIAL_BITS = 32.",
      "ja": "[RFC1982]ここでSERIAL_BITS = 32で定義されるように、この文書に記載されているのTSNに比較演算は、シリアル番号演算を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD NOT transmit a DATA chunk with a TSN that is more than 2**31 - 1 above the beginning TSN of its current send window. Doing so will cause problems in comparing TSNs.",
      "ja": "現在の送信ウィンドウの先頭TSN上記1  - エンドポイントは、2 ** 31以上であるTSNを持つデータチャンクを送信すべきではありません。そうすることのTSNを比較する際に問題が発生します。"
    },
    {
      "indent": 3,
      "text": "Transmission Sequence Numbers wrap around when they reach 2**32 - 1. That is, the next TSN a DATA chunk MUST use after transmitting TSN = 2*32 - 1 is TSN = 0.",
      "ja": "彼らは2 ** 32に達したとき、送信シーケンス番号がラップアラウンド -  1 TSN = 0  -  1であることを、次のTSNがDATAチャンクがTSN = 2 * 32を送信した後に使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Any arithmetic done on Stream Sequence Numbers SHOULD use Serial Number Arithmetic as defined in [RFC1982] where SERIAL_BITS = 16. All other arithmetic and comparisons in this document use normal arithmetic.",
      "ja": "この文書に記載されているSERIAL_BITS = 16他のすべての演算と比較は通常の算術演算を使用する[RFC1982]で定義されるようにストリームシーケンス番号に行わ任意算術シリアル番号演算を使用すべきです。"
    },
    {
      "indent": 1,
      "text": "1.7. Changes from",
      "section_title": true,
      "ja": "1.7。からの変更点"
    },
    {
      "indent": 3,
      "text": "SCTP was originally defined in [RFC2960], which this document obsoletes. Readers interested in the details of the various changes that this document incorporates are asked to consult [RFC4460].",
      "ja": "SCTPはもともとこの文書は廃止[RFC2960]で定義されました。この文書は組み込まれ、さまざまな変更の詳細に興味がある読者は、[RFC4460]を相談するように求められます。"
    },
    {
      "indent": 0,
      "text": "2. Conventions",
      "section_title": true,
      "ja": "2.表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. SCTP Packet Format",
      "section_title": true,
      "ja": "3. SCTPパケットフォーマット"
    },
    {
      "indent": 3,
      "text": "An SCTP packet is composed of a common header and chunks. A chunk contains either control information or user data.",
      "ja": "SCTPパケットは、共通ヘッダ及びチャンクで構成されています。チャンクは、制御情報やユーザーデータのいずれかを含みます。"
    },
    {
      "indent": 3,
      "text": "The SCTP packet format is shown below:",
      "ja": "SCTPパケットフォーマットを以下に示します。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Common Header                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Chunk #1                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           ...                                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Chunk #n                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Multiple chunks can be bundled into one SCTP packet up to the MTU size, except for the INIT, INIT ACK, and SHUTDOWN COMPLETE chunks. These chunks MUST NOT be bundled with any other chunk in a packet. See Section 6.10 for more details on chunk bundling.",
      "ja": "複数のチャンクはINIT、INIT ACK、およびSHUTDOWN COMPLETEチャンクを除いて、MTUサイズまでの1つのSCTPパケットにバンドルすることができます。これらのチャンクは、パケット内の他のチャンクとバンドルしてはなりません。チャンクバンドリングの詳細については、セクション6.10を参照してください。"
    },
    {
      "indent": 3,
      "text": "If a user data message doesn't fit into one SCTP packet it can be fragmented into multiple chunks using the procedure defined in Section 6.9.",
      "ja": "ユーザデータメッセージは1つのSCTPパケットに収まらない場合には、6.9節で定義された手順を使用して複数のチャンクに分割することができます。"
    },
    {
      "indent": 3,
      "text": "All integer fields in an SCTP packet MUST be transmitted in network byte order, unless otherwise stated.",
      "ja": "特に明記しない限り、SCTPパケット内のすべての整数フィールドは、ネットワークバイト順序で送信されなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.1. SCTP Common Header Field Descriptions",
      "section_title": true,
      "ja": "3.1。 SCTP共通ヘッダフィールドの説明"
    },
    {
      "indent": 23,
      "text": "SCTP Common Header Format",
      "ja": "SCTP共通ヘッダのフォーマット"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Source Port Number        |     Destination Port Number   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Verification Tag                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Checksum                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Source Port Number: 16 bits (unsigned integer)",
      "ja": "送信元ポート番号：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This is the SCTP sender's port number. It can be used by the receiver in combination with the source IP address, the SCTP destination port, and possibly the destination IP address to identify the association to which this packet belongs. The port number 0 MUST NOT be used.",
      "ja": "これは、SCTP送信者のポート番号です。このパケットが属する関連付けを識別するために、送信元IPアドレス、SCTP宛先ポート、および場合によって宛先IPアドレスと組み合わせて、受信機で使用することができます。ポート番号0を使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "Destination Port Number: 16 bits (unsigned integer)",
      "ja": "宛先ポート番号：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This is the SCTP port number to which this packet is destined. The receiving host will use this port number to de-multiplex the SCTP packet to the correct receiving endpoint/application. The port number 0 MUST NOT be used.",
      "ja": "これは、このパケットの宛先されているSCTPポート番号です。受信ホストは、正しい受信エンドポイント/アプリケーションにSCTPパケットを逆多重化するために、このポート番号を使用します。ポート番号0を使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "Verification Tag: 32 bits (unsigned integer)",
      "ja": "検証タグ：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "The receiver of this packet uses the Verification Tag to validate the sender of this SCTP packet. On transmit, the value of this Verification Tag MUST be set to the value of the Initiate Tag received from the peer endpoint during the association initialization, with the following exceptions:",
      "ja": "このパケットの受信機は、このSCTPパケットの送信元を検証する検証タグを使用しています。送信には、この検証タグの値は、以下の例外を除き、関連の初期化中に、ピアエンドポイントから受信した開始タグの値に設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "- A packet containing an INIT chunk MUST have a zero Verification Tag.",
      "ja": " -  INITチャンクを含むパケットはゼロ検証タグを持たなければなりません。"
    },
    {
      "indent": 6,
      "text": "- A packet containing a SHUTDOWN COMPLETE chunk with the T bit set MUST have the Verification Tag copied from the packet with the SHUTDOWN ACK chunk.",
      "ja": " -  TビットセットとSHUTDOWN COMPLETEチャンクを含むパケットがSHUTDOWN ACKチャンクを持つパケットからコピーされた検証タグを持たなければなりません。"
    },
    {
      "indent": 6,
      "text": "- A packet containing an ABORT chunk may have the verification tag copied from the packet that caused the ABORT to be sent. For details see Section 8.4 and Section 8.5.",
      "ja": " -  ABORTチャンクを含むパケットは、アボートが送信される原因となったパケットからコピーされた検証タグを有していてもよいです。詳細については、セクション8.4とセクション8.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "An INIT chunk MUST be the only chunk in the SCTP packet carrying it.",
      "ja": "INITチャンクはそれを運ぶSCTPパケットの中の唯一のチャンクでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Checksum: 32 bits (unsigned integer)",
      "ja": "チェックサム：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This field contains the checksum of this SCTP packet. Its calculation is discussed in Section 6.8. SCTP uses the CRC32c algorithm as described in Appendix B for calculating the checksum.",
      "ja": "このフィールドは、このSCTPパケットのチェックサムが含まれています。その計算は、6.8節で説明されています。チェックサムを計算するために、付録Bに記載されているようにSCTPはCRC32Cアルゴリズムを使用します。"
    },
    {
      "indent": 0,
      "text": "3.2. Chunk Field Descriptions",
      "section_title": true,
      "ja": "3.2。チャンクフィールドの説明"
    },
    {
      "indent": 3,
      "text": "The figure below illustrates the field format for the chunks to be transmitted in the SCTP packet. Each chunk is formatted with a Chunk Type field, a chunk-specific Flag field, a Chunk Length field, and a Value field.",
      "ja": "以下の図は、SCTPパケットで送信されるチャンクのフィールドフォーマットを示します。各チャンクは、チャンクタイプフィールド、チャンク固有のフラグフィールド、チャンク長フィールド、および値フィールドでフォーマットされています。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Chunk Type  | Chunk  Flags  |        Chunk Length           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                          Chunk Value                          /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Type: 8 bits (unsigned integer)",
      "ja": "チャンクタイプ：8ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This field identifies the type of information contained in the Chunk Value field. It takes a value from 0 to 254. The value of 255 is reserved for future use as an extension field.",
      "ja": "このフィールドは、チャンク値フィールドに含まれる情報の種類を識別します。これは、0から255の値は、拡張フィールドとして将来の使用のために予約されている254の値をとります。"
    },
    {
      "indent": 6,
      "text": "The values of Chunk Types are defined as follows:",
      "ja": "以下のようにチャンクタイプの値が定義されています。"
    },
    {
      "indent": 3,
      "text": "ID Value    Chunk Type\n-----       ----------\n0          - Payload Data (DATA)\n1          - Initiation (INIT)\n2          - Initiation Acknowledgement (INIT ACK)\n3          - Selective Acknowledgement (SACK)\n4          - Heartbeat Request (HEARTBEAT)\n5          - Heartbeat Acknowledgement (HEARTBEAT ACK)\n6          - Abort (ABORT)\n7          - Shutdown (SHUTDOWN)\n8          - Shutdown Acknowledgement (SHUTDOWN ACK)\n9          - Operation Error (ERROR)\n10         - State Cookie (COOKIE ECHO)\n11         - Cookie Acknowledgement (COOKIE ACK)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "12 - Reserved for Explicit Congestion Notification Echo (ECNE) 13 - Reserved for Congestion Window Reduced (CWR) 14 - Shutdown Complete (SHUTDOWN COMPLETE) 15 to 62 - available 63 - reserved for IETF-defined Chunk Extensions 64 to 126 - available 127 - reserved for IETF-defined Chunk Extensions 128 to 190 - available 191 - reserved for IETF-defined Chunk Extensions 192 to 254 - available 255 - reserved for IETF-defined Chunk Extensions",
      "ja": "12  - 明示的輻輳通知エコー（ECNE）13のために予約は - 減少輻輳ウィンドウ（CWR）14のために予約 - シャットダウン完了（COMPLETE SHUTDOWN）15 62  - 利用可能な63  -  64〜126 IETF定義のチャンクの拡張のために予約 -  127入手可能 - IETF定義のチャンク拡張128〜190のために予約 - 利用可能な191  -  IETF定義のチャンク拡張192〜254のために予約 -  255入手可能 -  IETF定義のチャンクの拡張のために予約"
    },
    {
      "indent": 6,
      "text": "Chunk Types are encoded such that the highest-order 2 bits specify the action that must be taken if the processing endpoint does not recognize the Chunk Type.",
      "ja": "チャンクタイプは、最上位2ビットが処理エンドポイントがチャンクタイプを認識しない場合に注意しなければならないアクションを指定するように符号化されます。"
    },
    {
      "indent": 6,
      "text": "00 - Stop processing this SCTP packet and discard it, do not process any further chunks within it.",
      "ja": "00  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理しません。"
    },
    {
      "indent": 6,
      "text": "01 - Stop processing this SCTP packet and discard it, do not process any further chunks within it, and report the unrecognized chunk in an 'Unrecognized Chunk Type'.",
      "ja": "01  - このSCTPパケットの処理を停止し、それを破棄し、その内の任意の更なるチャンクを処理し、「認識できないチャンクタイプ」で認識されていないチャンクを報告しません。"
    },
    {
      "indent": 6,
      "text": "10 - Skip this chunk and continue processing.",
      "ja": "10  - このチャンクをスキップして、処理を続行。"
    },
    {
      "indent": 6,
      "text": "11 - Skip this chunk and continue processing, but report in an ERROR chunk using the 'Unrecognized Chunk Type' cause of error.",
      "ja": "11  - このチャンクをスキップして、処理を続行しますが、エラーの「認識できないチャンクタイプ」原因を使用してERRORチャンクで報告しています。"
    },
    {
      "indent": 6,
      "text": "Note: The ECNE and CWR chunk types are reserved for future use of Explicit Congestion Notification (ECN); see Appendix A.",
      "ja": "注：ECNEおよびCWRチャンクタイプは、明示的輻輳通知（ECN）の将来の使用のために予約されています。付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "The usage of these bits depends on the Chunk type as given by the Chunk Type field. Unless otherwise specified, they are set to 0 on transmit and are ignored on receipt.",
      "ja": "チャンクタイプフィールドによって与えられるように、これらのビットの使用は、チャンクタイプに依存します。特に指定しない限り、彼らは、送信時に0に設定され、領収書の上で無視されます。"
    },
    {
      "indent": 3,
      "text": "Chunk Length: 16 bits (unsigned integer)",
      "ja": "チャンクの長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the size of the chunk in bytes, including the Chunk Type, Chunk Flags, Chunk Length, and Chunk Value fields. Therefore, if the Chunk Value field is zero-length, the Length field will be set to 4. The Chunk Length field does not count any chunk padding.",
      "ja": "この値は、チャンクタイプ、チャンクフラグ、チャンク長、およびチャンク値フィールドを含むバイト単位のチャンクのサイズを表します。チャンク値フィールドが長さゼロの場合はそのため、長さフィールドは、任意のチャンクのパディングをカウントしない4.チャンク長フィールドに設定されます。"
    },
    {
      "indent": 6,
      "text": "Chunks (including Type, Length, and Value fields) are padded out by the sender with all zero bytes to be a multiple of 4 bytes long. This padding MUST NOT be more than 3 bytes in total. The Chunk Length value does not include terminating padding of the chunk. However, it does include padding of any variable-length parameter except the last parameter in the chunk. The receiver MUST ignore the padding.",
      "ja": "（タイプ、長さ、および値フィールドを含む）チャンクが長い4バイトの倍数になるように、すべてのゼロバイトの送信側によってパディングされます。このパディングは合計で3つの以上のバイト以下でなければなりません。チャンク長値は、チャンクのパディングを終了含まれていません。しかし、それはチャンクで最後のパラメータを除くすべての可変長パラメータのパディングを含みません。受信機は、パディングを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: A robust implementation should accept the chunk whether or not the final padding has been included in the Chunk Length.",
      "ja": "注：堅牢な実装では、最終的なパディングがチャンク長に含まれているか否かのチャンクを受け入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "Chunk Value: variable length",
      "ja": "チャンク値：可変長"
    },
    {
      "indent": 6,
      "text": "The Chunk Value field contains the actual information to be transferred in the chunk. The usage and format of this field is dependent on the Chunk Type.",
      "ja": "チャンク値フィールドは、チャンクに転送される実際の情報が含まれています。このフィールドの使用方法と形式は、チャンクタイプに依存しています。"
    },
    {
      "indent": 3,
      "text": "The total length of a chunk (including Type, Length, and Value fields) MUST be a multiple of 4 bytes. If the length of the chunk is not a multiple of 4 bytes, the sender MUST pad the chunk with all zero bytes, and this padding is not included in the Chunk Length field. The sender MUST NOT pad with more than 3 bytes. The receiver MUST ignore the padding bytes.",
      "ja": "（タイプ、長さ、および値フィールドを含む）のチャンクの合計長さが4バイトの倍数でなければなりません。チャンクの長さが4バイトの倍数でない場合、送信者MUSTパッドは全てゼロバイトのチャンク、このパディングは、チャンク長フィールドに含まれていません。送信者は、以上の3バイトのパッドはいけません。受信機は、パディングバイトを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "SCTP-defined chunks are described in detail in Section 3.3. The guidelines for IETF-defined chunk extensions can be found in Section 14.1 of this document.",
      "ja": "SCTP定義のチャンクは、第3.3節に詳細に記載されています。 IETF定義のチャンクの拡張のためのガイドラインは、このドキュメントのセクション14.1で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Optional/Variable-Length Parameter Format",
      "section_title": true,
      "ja": "3.2.1。オプション/可変長パラメータ書式"
    },
    {
      "indent": 3,
      "text": "Chunk values of SCTP control chunks consist of a chunk-type-specific header of required fields, followed by zero or more parameters. The optional and variable-length parameters contained in a chunk are defined in a Type-Length-Value format as shown below.",
      "ja": "SCTP制御チャンクのチャンク値は、ゼロ以上のパラメータが続く必須フィールドのチャンクタイプ固有のヘッダから成ります。以下に示すように、チャンクに含まれるオプションの可変長パラメータは、タイプレングス値の形式で定義されています。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Parameter Type       |       Parameter Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                       Parameter Value                         /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Parameter Type: 16 bits (unsigned integer)",
      "ja": "チャンクパラメータタイプ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "The Type field is a 16-bit identifier of the type of parameter. It takes a value of 0 to 65534.",
      "ja": "Typeフィールドは、パラメータのタイプの16ビットの識別子です。これは、65534から0の値をとります。"
    },
    {
      "indent": 6,
      "text": "The value of 65535 is reserved for IETF-defined extensions. Values other than those defined in specific SCTP chunk descriptions are reserved for use by IETF.",
      "ja": "65535の値は、IETF定義の拡張のために予約されています。特定のSCTPチャンクの記述で定義されたもの以外の値は、IETFで使用するために予約されています。"
    },
    {
      "indent": 3,
      "text": "Chunk Parameter Length: 16 bits (unsigned integer)",
      "ja": "チャンクパラメータの長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "The Parameter Length field contains the size of the parameter in bytes, including the Parameter Type, Parameter Length, and Parameter Value fields. Thus, a parameter with a zero-length Parameter Value field would have a Length field of 4. The Parameter Length does not include any padding bytes.",
      "ja": "パラメータ長フィールドは、パラメータ型、パラメータ長、およびパラメータ値フィールドを含むバイト単位でのパラメータの大きさを、含まれています。したがって、長さゼロのパラメータ値フィールドとパラメータがパラメータの長さは、任意のパディングバイトを含まない4の長さフィールドを有するであろう。"
    },
    {
      "indent": 3,
      "text": "Chunk Parameter Value: variable length",
      "ja": "チャンクパラメータ値：可変長"
    },
    {
      "indent": 6,
      "text": "The Parameter Value field contains the actual information to be transferred in the parameter.",
      "ja": "パラメータ値フィールドには、パラメータに転送される実際の情報が含まれています。"
    },
    {
      "indent": 6,
      "text": "The total length of a parameter (including Type, Parameter Length, and Value fields) MUST be a multiple of 4 bytes. If the length of the parameter is not a multiple of 4 bytes, the sender pads the parameter at the end (i.e., after the Parameter Value field) with all zero bytes. The length of the padding is not included in the Parameter Length field. A sender MUST NOT pad with more than 3 bytes. The receiver MUST ignore the padding bytes.",
      "ja": "（タイプ、パラメータの長さ、および値フィールドを含む）パラメータの合計長さが4バイトの倍数でなければなりません。パラメータの長さが4バイトの倍数でない場合、すべてのゼロバイトの送信元パッド端におけるパラメータ（すなわち、パラメータ値フィールドの後）。詰め物の長さはパラメータ長フィールドに含まれていません。送信者は、以上の3バイトのパッドはいけません。受信機は、パディングバイトを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The Parameter Types are encoded such that the highest-order 2 bits specify the action that must be taken if the processing endpoint does not recognize the Parameter Type.",
      "ja": "パラメータタイプは、最上位2ビットが処理エンドポイントがパラメータ型を認識しない場合に注意しなければならないアクションを指定するように符号化されます。"
    },
    {
      "indent": 6,
      "text": "00 - Stop processing this parameter; do not process any further parameters within this chunk.",
      "ja": "00  - このパラメータの処理を停止。このチャンク内の任意の他のパラメータを処理しません。"
    },
    {
      "indent": 6,
      "text": "01 - Stop processing this parameter, do not process any further parameters within this chunk, and report the unrecognized parameter in an 'Unrecognized Parameter', as described in Section 3.2.2.",
      "ja": "01  - このチャンク内の任意の他のパラメータを処理していない、このパラメータの処理を停止し、セクション3.2.2に記載したように、「認識できないパラメータ」に認識されていないパラメータを報告します。"
    },
    {
      "indent": 6,
      "text": "10 - Skip this parameter and continue processing.",
      "ja": "10  - このパラメータをスキップして、処理を続行。"
    },
    {
      "indent": 6,
      "text": "11 - Skip this parameter and continue processing but report the unrecognized parameter in an 'Unrecognized Parameter', as described in Section 3.2.2.",
      "ja": "11  -  3.2.2項で説明したように、このパラメータをスキップして、処理を続行しますが「認識できないパラメータ」で認識されていないパラメータを報告しています。"
    },
    {
      "indent": 3,
      "text": "Please note that in all four cases, an INIT ACK or COOKIE ECHO chunk is sent. In the 00 or 01 case, the processing of the parameters after the unknown parameter is canceled, but no processing already done is rolled back.",
      "ja": "すべての4例では、INIT ACKまたはCOOKIE ECHOチャンクが送信されますのでご注意ください。 00または01の場合に、未知パラメータの後にパラメータの処理がキャンセルされるが、既に行われない処理がロールバックされません。"
    },
    {
      "indent": 3,
      "text": "The actual SCTP parameters are defined in the specific SCTP chunk sections. The rules for IETF-defined parameter extensions are defined in Section 14.2. Note that a parameter type MUST be unique across all chunks. For example, the parameter type '5' is used to represent an IPv4 address (see Section 3.3.2.1). The value '5' then is reserved across all chunks to represent an IPv4 address and MUST NOT be reused with a different meaning in any other chunk.",
      "ja": "実際のSCTPパラメータは、特定のSCTPチャンクセクションで定義されています。 IETF定義のパラメータの拡張のための規則は、セクション14.2で定義されています。パラメータの型は、すべてのチャンクで一意である必要があります。例えば、パラメータタイプが「5」（セクション3.3.2.1を参照）、IPv4アドレスを表すために使用されます。値が「5」そして、IPv4アドレスを表すために、すべてのチャンク間で予約されており、他のチャンクで異なる意味を再利用してはいけません。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Reporting of Unrecognized Parameters",
      "section_title": true,
      "ja": "3.2.2。認識できないパラメータの報告"
    },
    {
      "indent": 3,
      "text": "If the receiver of an INIT chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it MUST put the 'Unrecognized Parameter' parameter(s) in the INIT ACK chunk sent in response to the INIT chunk. Note that if the receiver of the INIT chunk is NOT going to establish an association (e.g., due to lack of resources), an 'Unrecognized Parameter' would NOT be included with any ABORT being sent to the sender of the INIT.",
      "ja": "INITチャンクの受信機が認識できないパラメータを検出し、3.2.1項に従ってそれらを報告しなければならない場合、それはINITチャンクに応答して送信INIT ACKチャンクに「認識できないパラメータ」パラメータ（複数可）を置く必要があります。 INITチャンクの受信機は、（リソース不足のため、例えば）アソシエーションを確立しようとされていない場合は任意のABORTがINITの送信者に送信された状態で、「認識できないパラメータが」含まれないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the receiver of an INIT ACK chunk detects unrecognized parameters and has to report them according to Section 3.2.1, it SHOULD bundle the ERROR chunk containing the 'Unrecognized Parameters' error cause with the COOKIE ECHO chunk sent in response to the INIT ACK chunk. If the receiver of the INIT ACK cannot bundle the COOKIE ECHO chunk with the ERROR chunk, the ERROR chunk MAY be sent separately but not before the COOKIE ACK has been received.",
      "ja": "INIT ACKチャンクの受信機が認識できないパラメータを検出し、3.2.1項に従ってそれらを報告しなければならない場合、それはINIT ACKチャンクに応答して送信されたCOOKIE ECHOチャンクと「認識できないパラメーター」エラー原因を含むERRORチャンクをバンドルすべきです。 INIT ACKの受信機はERRORチャンクでCOOKIE ECHOチャンクをバンドルすることができない場合はCOOKIE A​​CKが受信される前に、ERRORチャンクは個別にではなく、送信されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Note: Any time a COOKIE ECHO is sent in a packet, it MUST be the first chunk.",
      "ja": "注意：COOKIE ECHOはパケットで送信されたすべての時間は、それは最初のチャンクでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3. SCTP Chunk Definitions",
      "section_title": true,
      "ja": "3.3。 SCTPチャンクの定義"
    },
    {
      "indent": 3,
      "text": "This section defines the format of the different SCTP chunk types.",
      "ja": "このセクションでは、異なるSCTPチャンクタイプのフォーマットを定義します。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Payload Data (DATA) (0)",
      "section_title": true,
      "ja": "3.3.1。ペイロードデータ（DATA）（0）"
    },
    {
      "indent": 3,
      "text": "The following format MUST be used for the DATA chunk:",
      "ja": "次の形式は、DATAチャンクを使用しなければなりません。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 0    | Reserved|U|B|E|    Length                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              TSN                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Stream Identifier S      |   Stream Sequence Number n    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  Payload Protocol Identifier                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                 User Data (seq n of Stream S)                 /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Reserved: 5 bits",
      "ja": "予約：5ビット"
    },
    {
      "indent": 6,
      "text": "Should be set to all '0's and ignored by the receiver.",
      "ja": "すべての「0に設定され、受信機によって無視されるべきです。"
    },
    {
      "indent": 3,
      "text": "U bit: 1 bit",
      "ja": "Uビット：1ビット"
    },
    {
      "indent": 6,
      "text": "The (U)nordered bit, if set to '1', indicates that this is an unordered DATA chunk, and there is no Stream Sequence Number assigned to this DATA chunk. Therefore, the receiver MUST ignore the Stream Sequence Number field.",
      "ja": "（U）norderedビット、「1」に設定されている場合、これは非順序DATAチャンクであることを示し、このデータチャンクに割り当てられたストリームのシーケンス番号がありません。そのため、受信機はストリームシーケンス番号フィールドを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "After reassembly (if necessary), unordered DATA chunks MUST be dispatched to the upper layer by the receiver without any attempt to reorder.",
      "ja": "（必要ならば）再組立後、順不同DATAチャンクは、並べ替えしようとすることなく、受信機によって上位層に送出されなければなりません。"
    },
    {
      "indent": 6,
      "text": "If an unordered user message is fragmented, each fragment of the message MUST have its U bit set to '1'.",
      "ja": "順序付けられていないユーザメッセージが断片化されている場合、メッセージの各断片は、そのUが「1」に設定ビットがなければなりません。"
    },
    {
      "indent": 3,
      "text": "B bit: 1 bit",
      "ja": "Bビット：1ビット"
    },
    {
      "indent": 6,
      "text": "The (B)eginning fragment bit, if set, indicates the first fragment of a user message.",
      "ja": "（B）eginningフラグメントビットは、設定されている場合、ユーザ・メッセージの最初のフラグメントを示します。"
    },
    {
      "indent": 3,
      "text": "E bit: 1 bit",
      "ja": "Eビット：1ビット"
    },
    {
      "indent": 6,
      "text": "The (E)nding fragment bit, if set, indicates the last fragment of a user message.",
      "ja": "（E）nding断片ビットが設定されている場合、ユーザメッセージの最後の断片を示します。"
    },
    {
      "indent": 3,
      "text": "An unfragmented user message shall have both the B and E bits set to '1'. Setting both B and E bits to '0' indicates a middle fragment of a multi-fragment user message, as summarized in the following table:",
      "ja": "断片化されていないユーザメッセージが「1」にセットBとEビットの両方を持たなければなりません。以下の表にまとめたように「0」にBとEビットの両方を設定すると、マルチ断片ユーザメッセージの中央断片を示します。"
    },
    {
      "indent": 12,
      "text": "   B E                  Description\n============================================================\n|  1 0 | First piece of a fragmented user message          |\n+----------------------------------------------------------+\n|  0 0 | Middle piece of a fragmented user message         |\n+----------------------------------------------------------+\n|  0 1 | Last piece of a fragmented user message           |\n+----------------------------------------------------------+\n|  1 1 | Unfragmented message                              |\n============================================================\n|             Table 1: Fragment Description Flags          |\n============================================================",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When a user message is fragmented into multiple chunks, the TSNs are used by the receiver to reassemble the message. This means that the TSNs for each fragment of a fragmented user message MUST be strictly sequential.",
      "ja": "ユーザメッセージが複数のチャンクに分割されると、TSNを、メッセージを再構築するために受信機によって使用されます。これは、断片化されたユーザメッセージの各断片のためのTSNは厳密にシーケンシャルなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer)",
      "ja": "長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This field indicates the length of the DATA chunk in bytes from the beginning of the type field to the end of the User Data field excluding any padding. A DATA chunk with one byte of user data will have Length set to 17 (indicating 17 bytes).",
      "ja": "このフィールドは、任意のパディングを除いたユーザデータフィールドの最後にタイプフィールドの先頭からのバイトのデータチャンクの長さを示します。ユーザデータの1つのバイトを有するデータチャンクは、長さが（17のバイトを示す）17に設定されます。"
    },
    {
      "indent": 6,
      "text": "A DATA chunk with a User Data field of length L will have the Length field set to (16 + L) (indicating 16+L bytes) where L MUST be greater than 0.",
      "ja": "長さLのユーザデータフィールドを有するデータチャンクは、Lは0より大きくなければならない（16 + Lバイトを示す）（16 + L）に長さフィールドが設定されています。"
    },
    {
      "indent": 3,
      "text": "TSN: 32 bits (unsigned integer)",
      "ja": "TSN：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the TSN for this DATA chunk. The valid range of TSN is from 0 to 4294967295 (2**32 - 1). TSN wraps back to 0 after reaching 4294967295.",
      "ja": "この値は、このデータチャンクのTSNを表します。 TSNの有効範囲は0から4294967295（ -  1 2 ** 32）です。 TSNは4294967295に達した後、バック0にラップします。"
    },
    {
      "indent": 3,
      "text": "Stream Identifier S: 16 bits (unsigned integer)",
      "ja": "ストリーム識別子S：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Identifies the stream to which the following user data belongs.",
      "ja": "次のユーザーデータが属するストリームを識別します。"
    },
    {
      "indent": 3,
      "text": "Stream Sequence Number n: 16 bits (unsigned integer)",
      "ja": "ストリームシーケンス番号N：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the Stream Sequence Number of the following user data within the stream S. Valid range is 0 to 65535.",
      "ja": "この値は、ストリームS.有効範囲内の次のユーザデータのストリームシーケンス番号は0〜65535であることを表します。"
    },
    {
      "indent": 6,
      "text": "When a user message is fragmented by SCTP for transport, the same Stream Sequence Number MUST be carried in each of the fragments of the message.",
      "ja": "ユーザメッセージを搬送するためのSCTPによって断片化される場合、同じストリーム・シーケンス番号は、メッセージのフラグメントの各々において実行されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Payload Protocol Identifier: 32 bits (unsigned integer)",
      "ja": "ペイロードプロトコル識別子：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This value represents an application (or upper layer) specified protocol identifier. This value is passed to SCTP by its upper layer and sent to its peer. This identifier is not used by SCTP but can be used by certain network entities, as well as by the peer application, to identify the type of information being carried in this DATA chunk. This field must be sent even in fragmented DATA chunks (to make sure it is available for agents in the middle of the network). Note that this field is NOT touched by an SCTP implementation; therefore, its byte order is NOT necessarily big endian. The upper layer is responsible for any byte order conversions to this field.",
      "ja": "この値は、アプリケーション（上層）指定されたプロトコル識別子を表します。この値は、上位層によってSCTPに渡され、そのピアに送信されます。この識別子は、SCTPによって使用されていないが、このデータチャンクに運ばれる情報のタイプを識別するために、特定のネットワークエンティティによって、ならびにピアアプリケーションで使用することができます。このフィールドは、（必ず、それがネットワークの途中でエージェントに利用できるようにするために）も、断片化されたデータのチャンクで送信する必要があります。このフィールドはSCTP実装によって触れないことに注意してください。そのため、そのバイト順は必ずしもビッグエンディアンではありません。上位層は、このフィールドに任意のバイトオーダー変換する責任があります。"
    },
    {
      "indent": 6,
      "text": "The value 0 indicates that no application identifier is specified by the upper layer for this payload data.",
      "ja": "値0は、アプリケーション識別子は、このペイロードデータの上位レイヤによって指定されていないことを示しています。"
    },
    {
      "indent": 3,
      "text": "User Data: variable length",
      "ja": "ユーザーデータ：可変長"
    },
    {
      "indent": 6,
      "text": "This is the payload user data. The implementation MUST pad the end of the data to a 4-byte boundary with all-zero bytes. Any padding MUST NOT be included in the Length field. A sender MUST never add more than 3 bytes of padding.",
      "ja": "これは、ペイロードのユーザデータです。実施MUSTパッドすべてゼロバイトの4バイト境界へのデータの終わり。任意のパディングは、Lengthフィールドに含んではいけません。送信者は、パディングの3つの以上のバイトを追加してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Initiation (INIT) (1)",
      "section_title": true,
      "ja": "3.3.2。開始（INIT）（1）"
    },
    {
      "indent": 3,
      "text": "This chunk is used to initiate an SCTP association between two endpoints. The format of the INIT chunk is shown below:",
      "ja": "このチャンクは、2つのエンドポイント間にSCTPアソシエーションを開始するために使用されます。 INITチャンクのフォーマットを以下に示します。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 1    |  Chunk Flags  |      Chunk Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Initiate Tag                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Advertised Receiver Window Credit (a_rwnd)          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Number of Outbound Streams   |  Number of Inbound Streams    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Initial TSN                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/              Optional/Variable-Length Parameters              /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The INIT chunk contains the following parameters. Unless otherwise noted, each parameter MUST only be included once in the INIT chunk.",
      "ja": "INITチャンクには、次のパラメータが含まれています。特に断りのない限り、各パラメータは一度だけINITチャンクに含まれなければなりません。"
    },
    {
      "indent": 12,
      "text": "Fixed Parameters                     Status\n----------------------------------------------\nInitiate Tag                        Mandatory\nAdvertised Receiver Window Credit   Mandatory\nNumber of Outbound Streams          Mandatory\nNumber of Inbound Streams           Mandatory\nInitial TSN                         Mandatory",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Variable Parameters                  Status     Type Value\n-------------------------------------------------------------\nIPv4 Address (Note 1)               Optional    5 IPv6 Address\n(Note 1)               Optional    6 Cookie Preservative\nOptional    9 Reserved for ECN Capable (Note 2)   Optional\n32768 (0x8000) Host Name Address (Note 3)          Optional\n11 Supported Address Types (Note 4)    Optional    12",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note 1: The INIT chunks can contain multiple addresses that can be IPv4 and/or IPv6 in any combination.",
      "ja": "注1：INITチャンクは、任意の組み合わせでIPv4および/またはIPv6であることができる複数のアドレスを含むことができます。"
    },
    {
      "indent": 3,
      "text": "Note 2: The ECN Capable field is reserved for future use of Explicit Congestion Notification.",
      "ja": "注2：ECN可能フィールドは明示的輻輳通知の将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Note 3: An INIT chunk MUST NOT contain more than one Host Name Address parameter. Moreover, the sender of the INIT MUST NOT combine any other address types with the Host Name Address in the INIT. The receiver of INIT MUST ignore any other address types if the Host Name Address parameter is present in the received INIT chunk.",
      "ja": "注3：INITチャンクは、複数のホスト名Addressパラメータを含めることはできません。また、INITの送信者はINITでのホスト名のアドレスを他のアドレスタイプを組み合わせるてはなりません。ホスト名アドレスパラメータが受信INITチャンクに存在する場合にINITの受信者は、他のアドレスタイプを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note 4: This parameter, when present, specifies all the address types the sending endpoint can support. The absence of this parameter indicates that the sending endpoint can support any address type.",
      "ja": "注4：このパラメータは、存在する場合、送信エンドポイントがサポートできるすべてのアドレスの種類を指定します。このパラメータが存在しない場合は、送信側エンドポイントが任意のアドレスタイプをサポートできることを示しています。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: If an INIT chunk is received with known parameters that are not optional parameters of the INIT chunk, then the receiver SHOULD process the INIT chunk and send back an INIT ACK. The receiver of the INIT chunk MAY bundle an ERROR chunk with the COOKIE ACK chunk later. However, restrictive implementations MAY send back an ABORT chunk in response to the INIT chunk.",
      "ja": "実装注：INITチャンクはINITチャンクのオプションのパラメータではない既知のパラメータを用いて受信された場合、受信機は、INITチャンクを処理し、INIT ACKを返送すべきです。 INITチャンクの受信機は、後にCOOKIE A​​CKチャンクでERRORチャンクをバンドルするかもしれません。しかし、制限の実装はINITチャンクに対応してABORTチャンクを送り返します。"
    },
    {
      "indent": 3,
      "text": "The Chunk Flags field in INIT is reserved, and all bits in it should be set to 0 by the sender and ignored by the receiver. The sequence of parameters within an INIT can be processed in any order.",
      "ja": "INITでチャンクフラグフィールドが予約されており、その中のすべてのビットは、送信者によって0に設定され、受信機によって無視されるべきです。 INIT内のパラメータの順序は、任意の順序で処理することができます。"
    },
    {
      "indent": 3,
      "text": "Initiate Tag: 32 bits (unsigned integer)",
      "ja": "タグを開始：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "The receiver of the INIT (the responding end) records the value of the Initiate Tag parameter. This value MUST be placed into the Verification Tag field of every SCTP packet that the receiver of the INIT transmits within this association.",
      "ja": "INIT（応答側）の受信機は、タグの開始パラメータの値を記録します。この値は、INITの受信機は、このアソシエーション内で送信するすべてのSCTPパケットの検証タグフィールドに入れなければなりません。"
    },
    {
      "indent": 6,
      "text": "The Initiate Tag is allowed to have any value except 0. See Section 5.3.1 for more on the selection of the tag value.",
      "ja": "開始タグは、タグ値の選択の詳細については0を参照してくださいセクション5.3.1以外の任意の値を持つことが許されます。"
    },
    {
      "indent": 6,
      "text": "If the value of the Initiate Tag in a received INIT chunk is found to be 0, the receiver MUST treat it as an error and close the association by transmitting an ABORT.",
      "ja": "受信したINITチャンクで開始タグの値が0であることが見出された場合、受信機は、エラーとして扱い、ABORTを送信することにより関連付けを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)",
      "ja": "アドバタイズ受信ウィンドウクレジット（a_rwnd）：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the dedicated buffer space, in number of bytes, the sender of the INIT has reserved in association with this window. During the life of the association, this buffer space SHOULD NOT be lessened (i.e., dedicated buffers taken away from this association); however, an endpoint MAY change the value of a_rwnd it sends in SACK chunks.",
      "ja": "この値は、バイト数で、INITの送信者は、このウィンドウに関連して予約した、専用のバッファ・スペースを表します。関連の生活の間に、このバッファスペースは、（この協会から連れ去らすなわち、専用のバッファ）を軽減すべきではありません。しかし、エンドポイントは、それがSACKチャンクに送るa_rwndの値を変更することがあります。"
    },
    {
      "indent": 3,
      "text": "Number of Outbound Streams (OS): 16 bits (unsigned integer)",
      "ja": "アウトバウンドストリーム数（OS）：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the number of outbound streams the sender of this INIT chunk wishes to create in this association. The value of 0 MUST NOT be used.",
      "ja": "このINITチャンクの送信者がこの協会で作成したいのアウトバウンドストリームの数を定義します。 0の値を使用してはいけません。"
    },
    {
      "indent": 6,
      "text": "Note: A receiver of an INIT with the OS value set to 0 SHOULD abort the association.",
      "ja": "注：0に設定OS値とINITの受信機は、関連付けを中止すべきです。"
    },
    {
      "indent": 3,
      "text": "Number of Inbound Streams (MIS): 16 bits (unsigned integer)",
      "ja": "インバウンドストリーム数（MIS）：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the maximum number of streams the sender of this INIT chunk allows the peer end to create in this association. The value 0 MUST NOT be used.",
      "ja": "このINITチャンクの送信者は、ピアエンドこの関連で作成することができるストリームの最大数を定義します。値0を使用してはいけません。"
    },
    {
      "indent": 6,
      "text": "Note: There is no negotiation of the actual number of streams but instead the two endpoints will use the min(requested, offered). See Section 5.1.1 for details.",
      "ja": "注意：そこのストリームの実際の数のいかなる交渉ではありませんが、代わりに2つのエンドポイントは、（提供要求）分を使用します。詳細については、セクション5.1.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "Note: A receiver of an INIT with the MIS value of 0 SHOULD abort the association.",
      "ja": "注：0のMIS値とINITの受信機は、関連付けを中止すべきです。"
    },
    {
      "indent": 3,
      "text": "Initial TSN (I-TSN): 32 bits (unsigned integer)",
      "ja": "初期TSN（I-TSN）：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the initial TSN that the sender will use. The valid range is from 0 to 4294967295. This field MAY be set to the value of the Initiate Tag field.",
      "ja": "送信者が使用する初期TSNを定義します。有効な範囲は、このフィールドは、開始タグフィールドの値に設定されるかもしれ0〜4294967295です。"
    },
    {
      "indent": 0,
      "text": "3.3.2.1. Optional/Variable-Length Parameters in INIT",
      "section_title": true,
      "ja": "3.3.2.1。 INITにおけるオプション/可変長パラメータ"
    },
    {
      "indent": 3,
      "text": "The following parameters follow the Type-Length-Value format as defined in Section 3.2.1. Any Type-Length-Value fields MUST come after the fixed-length fields defined in the previous section.",
      "ja": "セクション3.2.1で定義されるように、以下のパラメータは、タイプレングス値の形式に従います。任意のタイプレングス値フィールドは、前のセクションで定義された固定長フィールドの後に来なければなりません。"
    },
    {
      "indent": 3,
      "text": "IPv4 Address Parameter (5)",
      "ja": "IPv4アドレスパラメータ（5）"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Type = 5               |      Length = 8               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        IPv4 Address                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IPv4 Address: 32 bits (unsigned integer)",
      "ja": "IPv4アドレス：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Contains an IPv4 address of the sending endpoint. It is binary encoded.",
      "ja": "送信エンドポイントのIPv4アドレスが含まれています。これは、バイナリエンコードされています。"
    },
    {
      "indent": 3,
      "text": "IPv6 Address Parameter (6)",
      "ja": "IPv6アドレスのパラメータ（6）"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Type = 6           |          Length = 20          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                         IPv6 Address                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IPv6 Address: 128 bits (unsigned integer)",
      "ja": "IPv6アドレス：128ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Contains an IPv6 [RFC2460] address of the sending endpoint. It is binary encoded.",
      "ja": "送信エンドポイントのIPv6の[RFC2460]のアドレスが含まれています。これは、バイナリエンコードされています。"
    },
    {
      "indent": 6,
      "text": "Note: A sender MUST NOT use an IPv4-mapped IPv6 address [RFC4291], but should instead use an IPv4 Address parameter for an IPv4 address.",
      "ja": "注意：送信者はIPv4射影IPv6アドレス[RFC4291]を使用してはならないが、その代わりにIPv4アドレスのIPv4アドレスパラメータを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "Combined with the Source Port Number in the SCTP common header, the value passed in an IPv4 or IPv6 Address parameter indicates a transport address the sender of the INIT will support for the association being initiated. That is, during the life time of this association, this IP address can appear in the source address field of an IP datagram sent from the sender of the INIT, and can be used as a destination address of an IP datagram sent from the receiver of the INIT.",
      "ja": "SCTP共通ヘッダ内の送信元ポート番号と組み合わせることで、IPv4またはIPv6アドレスのパラメータに渡された値は、INITの送信者が開始されている関連付けのためにサポートするトランスポート・アドレスを示しています。すなわち、このアソシエーションのライフタイムの間、このIPアドレスは、INITの送信者から送信されたIPデータグラムのソースアドレスフィールドに現れることができるされ、および受信機から送信されたIPデータグラムの宛先アドレスとして使用することができますINIT。"
    },
    {
      "indent": 6,
      "text": "More than one IP Address parameter can be included in an INIT chunk when the INIT sender is multi-homed. Moreover, a multi-homed endpoint may have access to different types of network; thus, more than one address type can be present in one INIT chunk, i.e., IPv4 and IPv6 addresses are allowed in the same INIT chunk.",
      "ja": "INITの送信者は、マルチホームされたときに複数のIPアドレスパラメータはINITチャンクに含めることができます。また、マルチホームエンドポイントは、ネットワークの異なるタイプへのアクセスを有していてもよいです。従って、複数のアドレス・タイプ、すなわち1つのINITチャンク、中に存在することができ、IPv4およびIPv6アドレスは同じINITチャンクで許可されています。"
    },
    {
      "indent": 6,
      "text": "If the INIT contains at least one IP Address parameter, then the source address of the IP datagram containing the INIT chunk and any additional address(es) provided within the INIT can be used as destinations by the endpoint receiving the INIT. If the INIT does not contain any IP Address parameters, the endpoint receiving the INIT MUST use the source address associated with the received IP datagram as its sole destination address for the association.",
      "ja": "INITは、INITを受信エンドポイントによって宛先として使用することができる少なくとも1つのIPアドレスパラメータ、INITチャンクとINIT内に設けられた追加のアドレスを含むIPデータグラムのソース・アドレスが含まれている場合。 INITは、任意のIPアドレスパラメータが含まれていない場合は、INITを受けたエンドポイントは、協会のためにその唯一の宛先アドレスとして受信したIPデータグラムに関連したソースアドレスを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note that not using any IP Address parameters in the INIT and INIT ACK is an alternative to make an association more likely to work across a NAT box.",
      "ja": "INITで任意のIPアドレスパラメータを使用し、INIT ACKがNATボックスを越えて動作する関連付けが可能性を高めるための代替ではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Cookie Preservative (9)",
      "ja": "クッキー防腐剤（9）"
    },
    {
      "indent": 3,
      "text": "The sender of the INIT shall use this parameter to suggest to the receiver of the INIT for a longer life-span of the State Cookie.",
      "ja": "INITの送信者は、国家クッキーの長寿命のためにINITの受信者に提案するために、このパラメータを使用しなければなりません。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type = 9             |          Length = 8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Suggested Cookie Life-Span Increment (msec.)          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Suggested Cookie Life-Span Increment: 32 bits (unsigned integer)",
      "ja": "32ビット（符号なし整数）：クッキー寿命増分を示唆"
    },
    {
      "indent": 6,
      "text": "This parameter indicates to the receiver how much increment in milliseconds the sender wishes the receiver to add to its default cookie life-span.",
      "ja": "このパラメータは、送信者がデフォルトのクッキーの寿命に追加するために受信機を望んでどのくらいの増分ミリ秒単位で受信機に示します。"
    },
    {
      "indent": 6,
      "text": "This optional parameter should be added to the INIT chunk by the sender when it reattempts establishing an association with a peer to which its previous attempt of establishing the association failed due to a stale cookie operation error. The receiver MAY choose to ignore the suggested cookie life-span increase for its own security reasons.",
      "ja": "それはアソシエーションを確立する以前の試みは古くなったクッキー操作エラーによる失敗するピアとのアソシエーションを確立する再試行したときに、このオプションのパラメータは、送信者がINITチャンクに追加されるべきです。受信機は、独自のセキュリティ上の理由のために提案されたクッキー寿命の増加を無視することを選択するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Host Name Address (11)",
      "ja": "ホスト名のアドレス（11）"
    },
    {
      "indent": 3,
      "text": "The sender of INIT uses this parameter to pass its Host Name (in place of its IP addresses) to its peer. The peer is responsible for resolving the name. Using this parameter might make it more likely for the association to work across a NAT box.",
      "ja": "INITの送信者は、そのピアに（そのIPアドレスの代わりに）そのホスト名を渡すために、このパラメータを使用しています。ピアは名前を解決する責任があります。このパラメータを使用すると、それは可能性が高い関連がNATボックスを越えて動作できるようにするためかもしれません。"
    },
    {
      "indent": 7,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type = 11            |          Length               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                          Host Name                            /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Host Name: variable length",
      "ja": "ホスト名：可変長"
    },
    {
      "indent": 6,
      "text": "This field contains a host name in \"host name syntax\" per RFC 1123 Section 2.1 [RFC1123]. The method for resolving the host name is out of scope of SCTP.",
      "ja": "このフィールドは、RFCごとに、「ホスト名の構文」1123セクション2.1 [RFC1123]でホスト名が含まれています。ホスト名を解決するための方法は、SCTPの範囲外です。"
    },
    {
      "indent": 6,
      "text": "Note: At least one null terminator is included in the Host Name string and must be included in the length.",
      "ja": "注：少なくとも1つのヌルターミネータは、ホスト名の文字列に含まれていて、長さに含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "Supported Address Types (12)",
      "ja": "サポートされているアドレス型（12）"
    },
    {
      "indent": 3,
      "text": "The sender of INIT uses this parameter to list all the address types it can support.",
      "ja": "INITの送信者は、それがサポートすることができ、すべてのアドレスの種類の一覧を表示するには、このパラメータを使用しています。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type = 12            |          Length               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Address Type #1        |        Address Type #2        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            ......                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Address Type: 16 bits (unsigned integer)",
      "ja": "アドレスタイプ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This is filled with the type value of the corresponding address TLV (e.g., IPv4 = 5, IPv6 = 6, Host name = 11).",
      "ja": "これは、対応するアドレスTLV（例えば、= 5のIPv4、IPv6の= 6、ホスト名= 11）の型の値で満たされています。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Initiation Acknowledgement (INIT ACK) (2)",
      "section_title": true,
      "ja": "3.3.3。開始応答（INIT ACK）（2）"
    },
    {
      "indent": 3,
      "text": "The INIT ACK chunk is used to acknowledge the initiation of an SCTP association.",
      "ja": "INIT ACKチャンクはSCTPアソシエーションの開始を確認するために使用されています。"
    },
    {
      "indent": 3,
      "text": "The parameter part of INIT ACK is formatted similarly to the INIT chunk. It uses two extra variable parameters: The State Cookie and the Unrecognized Parameter:",
      "ja": "INIT ACKのパラメータの一部は、INITチャンクと同様にフォーマットされます。州Cookieと認識されないパラメータ：それは2つの余分な変数のパラメータを使用します。"
    },
    {
      "indent": 3,
      "text": "The format of the INIT ACK chunk is shown below:",
      "ja": "INIT ACKチャンクのフォーマットを以下に示します。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 2    |  Chunk Flags  |      Chunk Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Initiate Tag                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|              Advertised Receiver Window Credit                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Number of Outbound Streams   |  Number of Inbound Streams    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Initial TSN                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/              Optional/Variable-Length Parameters              /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initiate Tag: 32 bits (unsigned integer)",
      "ja": "タグを開始：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "The receiver of the INIT ACK records the value of the Initiate Tag parameter. This value MUST be placed into the Verification Tag field of every SCTP packet that the INIT ACK receiver transmits within this association.",
      "ja": "INIT ACKの受信機は、開始タグのパラメータの値を記録します。この値は、INIT ACKの受信機は、このアソシエーション内で送信するすべてのSCTPパケットの検証タグフィールドに入れなければなりません。"
    },
    {
      "indent": 6,
      "text": "The Initiate Tag MUST NOT take the value 0. See Section 5.3.1 for more on the selection of the Initiate Tag value.",
      "ja": "開始タグは、開始タグの値の選択の詳細については値0を参照してくださいセクション5.3.1を取るてはなりません。"
    },
    {
      "indent": 6,
      "text": "If the value of the Initiate Tag in a received INIT ACK chunk is found to be 0, the receiver MUST destroy the association discarding its TCB. The receiver MAY send an ABORT for debugging purpose.",
      "ja": "受信したINIT ACKチャンク内の開始タグの値が0であることが見出された場合、受信機は、そのTCBを破棄会合を破壊しなければなりません。受信機は、目的をデバッグするためのABORTを送信することができます。"
    },
    {
      "indent": 3,
      "text": "Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)",
      "ja": "アドバタイズ受信ウィンドウクレジット（a_rwnd）：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This value represents the dedicated buffer space, in number of bytes, the sender of the INIT ACK has reserved in association with this window. During the life of the association, this buffer space SHOULD NOT be lessened (i.e., dedicated buffers taken away from this association).",
      "ja": "この値は、バイト数で、INIT ACKの送信者がこのウィンドウに関連して予約した、専用のバッファ・スペースを表します。関連の生活の間に、このバッファスペースは、（この協会から連れ去らすなわち、専用のバッファ）軽減されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Number of Outbound Streams (OS): 16 bits (unsigned integer)",
      "ja": "アウトバウンドストリーム数（OS）：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the number of outbound streams the sender of this INIT ACK chunk wishes to create in this association. The value of 0 MUST",
      "ja": "このINIT ACKチャンクの送信者がこの協会で作成したいのアウトバウンドストリームの数を定義します。 0 MUSTの値"
    },
    {
      "indent": 6,
      "text": "NOT be used, and the value MUST NOT be greater than the MIS value sent in the INIT chunk.",
      "ja": "使用しないで、その値はINITチャンクで送信されたMIS値よりも大きくすることはできません。"
    },
    {
      "indent": 6,
      "text": "Note: A receiver of an INIT ACK with the OS value set to 0 SHOULD destroy the association discarding its TCB.",
      "ja": "注：0に設定OS値とINIT ACKの受信機は、そのTCBを破棄会合を破壊するべきです。"
    },
    {
      "indent": 3,
      "text": "Number of Inbound Streams (MIS): 16 bits (unsigned integer)",
      "ja": "インバウンドストリーム数（MIS）：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the maximum number of streams the sender of this INIT ACK chunk allows the peer end to create in this association. The value 0 MUST NOT be used.",
      "ja": "このINIT ACKチャンクの送信者は、ピアエンドこの関連で作成することができるストリームの最大数を定義します。値0を使用してはいけません。"
    },
    {
      "indent": 6,
      "text": "Note: There is no negotiation of the actual number of streams but instead the two endpoints will use the min(requested, offered). See Section 5.1.1 for details.",
      "ja": "注意：そこのストリームの実際の数のいかなる交渉ではありませんが、代わりに2つのエンドポイントは、（提供要求）分を使用します。詳細については、セクション5.1.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "Note: A receiver of an INIT ACK with the MIS value set to 0 SHOULD destroy the association discarding its TCB.",
      "ja": "注：0に設定MIS値とINIT ACKの受信機は、そのTCBを破棄会合を破壊するべきです。"
    },
    {
      "indent": 3,
      "text": "Initial TSN (I-TSN): 32 bits (unsigned integer)",
      "ja": "初期TSN（I-TSN）：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the initial TSN that the INIT ACK sender will use. The valid range is from 0 to 4294967295. This field MAY be set to the value of the Initiate Tag field.",
      "ja": "INIT ACKの送信者が使用する初期TSNを定義します。有効な範囲は、このフィールドは、開始タグフィールドの値に設定されるかもしれ0〜4294967295です。"
    },
    {
      "indent": 9,
      "text": "Fixed Parameters                     Status\n----------------------------------------------\nInitiate Tag                        Mandatory\nAdvertised Receiver Window Credit   Mandatory\nNumber of Outbound Streams          Mandatory\nNumber of Inbound Streams           Mandatory\nInitial TSN                         Mandatory",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Variable Parameters                  Status     Type Value\n-------------------------------------------------------------\nState Cookie                        Mandatory   7\nIPv4 Address (Note 1)               Optional    5\nIPv6 Address (Note 1)               Optional    6\nUnrecognized Parameter              Optional    8\nReserved for ECN Capable (Note 2)   Optional    32768 (0x8000)\nHost Name Address (Note 3)          Optional    11",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note 1: The INIT ACK chunks can contain any number of IP address parameters that can be IPv4 and/or IPv6 in any combination.",
      "ja": "注1：INITのACKチャンクは、任意の組み合わせでIPv4および/またはIPv6であることができるIPアドレスの任意の数のパラメータを含むことができます。"
    },
    {
      "indent": 3,
      "text": "Note 2: The ECN Capable field is reserved for future use of Explicit Congestion Notification.",
      "ja": "注2：ECN可能フィールドは明示的輻輳通知の将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Note 3: The INIT ACK chunks MUST NOT contain more than one Host Name Address parameter. Moreover, the sender of the INIT ACK MUST NOT combine any other address types with the Host Name Address in the INIT ACK. The receiver of the INIT ACK MUST ignore any other address types if the Host Name Address parameter is present.",
      "ja": "注3：INITのACKチャンクは、複数のホスト名Addressパラメータを含めることはできません。また、INIT ACKの送信者はINIT ACKでのホスト名のアドレスを他のアドレスタイプを組み合わせるてはなりません。ホスト名アドレスパラメータが存在する場合はINIT ACKの受信機は、他のアドレスの種類を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: An implementation MUST be prepared to receive an INIT ACK that is quite large (more than 1500 bytes) due to the variable size of the State Cookie AND the variable address list. For example if a responder to the INIT has 1000 IPv4 addresses it wishes to send, it would need at least 8,000 bytes to encode this in the INIT ACK.",
      "ja": "実装上の注意：実装が原因州クッキーの可変サイズと可変アドレス一覧にかなり大きいのINIT ACK（以上1500バイト）を受け取るように準備しなければなりません。 INITへの応答が1000のIPv4は、それが送信したいアドレスを持っている場合たとえば、それはINIT ACKでこれをエンコードするために、少なくとも8,000バイトが必要になります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: If an INIT ACK chunk is received with known parameters that are not optional parameters of the INIT ACK chunk, then the receiver SHOULD process the INIT ACK chunk and send back a COOKIE ECHO. The receiver of the INIT ACK chunk MAY bundle an ERROR chunk with the COOKIE ECHO chunk. However, restrictive implementations MAY send back an ABORT chunk in response to the INIT ACK chunk.",
      "ja": "実装注：INIT ACKチャンクはINIT ACKチャンクのオプションのパラメータではない既知のパラメータを用いて受信された場合、受信機は、INIT ACKチャンクを処理し、COOKIE ECHOを返送すべきです。 INIT ACKチャンクの受信機は、COOKIE ECHOチャンクとERRORチャンクをバンドルするかもしれません。しかし、制限の実装はINIT ACKチャンクに対応してABORTチャンクを送り返します。"
    },
    {
      "indent": 3,
      "text": "In combination with the Source Port carried in the SCTP common header, each IP Address parameter in the INIT ACK indicates to the receiver of the INIT ACK a valid transport address supported by the sender of the INIT ACK for the life time of the association being initiated.",
      "ja": "SCTP共通ヘッダで運ばれた送信元ポートとの組み合わせでは、INIT ACKの各IPアドレスパラメータが開始されているINIT ACKの受信機に関連の寿命のためのINIT ACKの送信元でサポートされている有効なトランスポート・アドレスを示しています。"
    },
    {
      "indent": 3,
      "text": "If the INIT ACK contains at least one IP Address parameter, then the source address of the IP datagram containing the INIT ACK and any additional address(es) provided within the INIT ACK may be used as destinations by the receiver of the INIT ACK. If the INIT ACK does not contain any IP Address parameters, the receiver of the INIT ACK MUST use the source address associated with the received IP datagram as its sole destination address for the association.",
      "ja": "INIT ACKはINIT ACKの受信により宛先として使用することができる少なくとも1つのIPアドレスパラメータ、INIT ACKとINIT ACK内に設けられた追加のアドレスを含むIPデータグラムのソース・アドレスが含まれている場合。 INIT ACKが任意のIPアドレスパラメータが含まれていない場合は、INIT ACKの受信機は、協会のためにその唯一の宛先アドレスとして受信したIPデータグラムに関連したソースアドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The State Cookie and Unrecognized Parameters use the Type-Length-Value format as defined in Section 3.2.1 and are described below. The other fields are defined the same as their counterparts in the INIT chunk.",
      "ja": "セクション3.2.1で定義され、以下に記載されるような状態クッキーと認識されていないパラメータなType-Length-Valueのフォーマットを使用します。他のフィールドは、INITチャンクでの対応と同じように定義されています。"
    },
    {
      "indent": 0,
      "text": "3.3.3.1. Optional or Variable-Length Parameters",
      "section_title": true,
      "ja": "3.3.3.1。オプションまたは可変長のパラメータ"
    },
    {
      "indent": 3,
      "text": "State Cookie",
      "ja": "状態クッキー"
    },
    {
      "indent": 3,
      "text": "Parameter Type Value: 7",
      "ja": "パラメータタイプ値：7"
    },
    {
      "indent": 6,
      "text": "Parameter Length: Variable size, depending on size of Cookie.",
      "ja": "パラメータの長さ：可変サイズ、クッキーのサイズによって異なります。"
    },
    {
      "indent": 3,
      "text": "Parameter Value:",
      "ja": "パラメータ値："
    },
    {
      "indent": 6,
      "text": "This parameter value MUST contain all the necessary state and parameter information required for the sender of this INIT ACK to create the association, along with a Message Authentication Code (MAC). See Section 5.1.3 for details on State Cookie definition.",
      "ja": "このパラメータの値は、メッセージ認証コード（MAC）と共に、関連付けを作成するには、このINIT ACKの送信者のために必要なすべての状態とパラメータ情報を含まなければなりません。状態クッキーの定義の詳細については、セクション5.1.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Unrecognized Parameter:",
      "ja": "認識できないパラメータ："
    },
    {
      "indent": 6,
      "text": "Parameter Type Value: 8",
      "ja": "パラメータタイプ値：8"
    },
    {
      "indent": 3,
      "text": "Parameter Length: Variable size.",
      "ja": "パラメータの長さ：可変サイズ。"
    },
    {
      "indent": 3,
      "text": "Parameter Value:",
      "ja": "パラメータ値："
    },
    {
      "indent": 6,
      "text": "This parameter is returned to the originator of the INIT chunk when the INIT contains an unrecognized parameter that has a value that indicates it should be reported to the sender. This parameter value field will contain unrecognized parameters copied from the INIT chunk complete with Parameter Type, Length, and Value fields.",
      "ja": "INITは、それが送信者に報告されるべきであることを示す値を持っている認識されていないパラメータが含まれている場合、このパラメータはINITチャンクの元に返されます。このパラメータの値フィールドは、パラメータタイプ、長さ、および値のフィールドを持つ完全なINITチャンクからコピーされた認識できないパラメータが含まれています。"
    },
    {
      "indent": 0,
      "text": "3.3.4. Selective Acknowledgement (SACK) (3)",
      "section_title": true,
      "ja": "3.3.4。選択的確認応答（SACK）（3）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent to the peer endpoint to acknowledge received DATA chunks and to inform the peer endpoint of gaps in the received subsequences of DATA chunks as represented by their TSNs.",
      "ja": "このチャンクは、受信したデータチャンクを確認し、それらのTSNによって示されるように、データチャンクの受信サブシーケンスのギャップのピアエンドポイントに知らせるためにピアエンドポイントに送信されます。"
    },
    {
      "indent": 3,
      "text": "The SACK MUST contain the Cumulative TSN Ack, Advertised Receiver Window Credit (a_rwnd), Number of Gap Ack Blocks, and Number of Duplicate TSNs fields.",
      "ja": "SACKが累積TSN Ackを、アドバタイズレシーバーウィンドウクレジット（a_rwnd）、ギャップAckブロックの数、および重複のTSNフィールドの数を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "By definition, the value of the Cumulative TSN Ack parameter is the last TSN received before a break in the sequence of received TSNs occurs; the next TSN value following this one has not yet been received at the endpoint sending the SACK. This parameter therefore acknowledges receipt of all TSNs less than or equal to its value.",
      "ja": "定義によると、累積TSN ACK]パラメータの値は、最後のTSNは、受信したTSN発生のシーケンスの中断前に受信されます。これを、次の次のTSN値はまだSACKを送信するエンドポイントで受信されていません。このパラメータは、したがって、その値以下の全てのTSNの受信を確認します。"
    },
    {
      "indent": 3,
      "text": "The handling of a_rwnd by the receiver of the SACK is discussed in detail in Section 6.2.1.",
      "ja": "SACKの受信機によるa_rwndの取り扱いはセクション6.2.1で詳しく説明されています。"
    },
    {
      "indent": 3,
      "text": "The SACK also contains zero or more Gap Ack Blocks. Each Gap Ack Block acknowledges a subsequence of TSNs received following a break in the sequence of received TSNs. By definition, all TSNs acknowledged by Gap Ack Blocks are greater than the value of the Cumulative TSN Ack.",
      "ja": "SACKもゼロ以上のギャップAckブロックが含まれています。各ギャップAckブロックはなTSNのサブシーケンスは、受信したTSNの順にブレーク次受け取っ認めています。定義では、ギャップAckブロックによって承認すべてのTSNは累積TSN Ackをの値よりも大きいです。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 3    |Chunk  Flags   |      Chunk Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Cumulative TSN Ack                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Advertised Receiver Window Credit (a_rwnd)           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = X |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Gap Ack Block #1 Start       |   Gap Ack Block #1 End        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n\\                              ...                              \\\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Gap Ack Block #N Start      |  Gap Ack Block #N End         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Duplicate TSN 1                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n\\                              ...                              \\\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Duplicate TSN X                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to all '0's on transmit and ignored on receipt.",
      "ja": "送信時にすべての「0年代に設定して、領収書の上で無視。"
    },
    {
      "indent": 3,
      "text": "Cumulative TSN Ack: 32 bits (unsigned integer)",
      "ja": "累積TSNのAck：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This parameter contains the TSN of the last DATA chunk received in sequence before a gap. In the case where no DATA chunk has been received, this value is set to the peer's Initial TSN minus one.",
      "ja": "このパラメータは、ギャップの前に順番に受け取った最後のDATAチャンクのTSNが含まれています。 NO DATAチャンクを受信して​​いない場合は、この値は、ピアの初期TSNマイナス1に設定されています。"
    },
    {
      "indent": 3,
      "text": "Advertised Receiver Window Credit (a_rwnd): 32 bits (unsigned integer)",
      "ja": "アドバタイズ受信ウィンドウクレジット（a_rwnd）：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This field indicates the updated receive buffer space in bytes of the sender of this SACK; see Section 6.2.1 for details.",
      "ja": "このフィールドは更新され、このSACKの送信元のバイト単位で受信バッファスペースを示します。詳細については、6.2.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Number of Gap Ack Blocks: 16 bits (unsigned integer)",
      "ja": "ギャップAckブロックの数：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Indicates the number of Gap Ack Blocks included in this SACK.",
      "ja": "ギャップAckブロックの数がこのSACKに含ま示します。"
    },
    {
      "indent": 3,
      "text": "Number of Duplicate TSNs: 16 bit",
      "ja": "重複のTSNの数：16ビット"
    },
    {
      "indent": 6,
      "text": "This field contains the number of duplicate TSNs the endpoint has received. Each duplicate TSN is listed following the Gap Ack Block list.",
      "ja": "このフィールドは、エンドポイントが受信した重複したTSNの数が含まれています。それぞれのTSNはギャップAckブロックリスト以下のリストされている重複します。"
    },
    {
      "indent": 3,
      "text": "Gap Ack Blocks:",
      "ja": "ギャップAckブロック："
    },
    {
      "indent": 6,
      "text": "These fields contain the Gap Ack Blocks. They are repeated for each Gap Ack Block up to the number of Gap Ack Blocks defined in the Number of Gap Ack Blocks field. All DATA chunks with TSNs greater than or equal to (Cumulative TSN Ack + Gap Ack Block Start) and less than or equal to (Cumulative TSN Ack + Gap Ack Block End) of each Gap Ack Block are assumed to have been received correctly.",
      "ja": "これらのフィールドはギャップAckブロックが含まれています。彼らは、ギャップAckブロックフィールドの数で定義されたギャップAckブロックの数まで、各ギャップAckブロックごとに繰り返されます。以上（累積TSNのAck +ギャップAckブロックスタート）に等しく、以下の各ギャップAckブロックの（累積TSNのAck +ギャップAckブロックエンド）に等しいTSNを有するすべてのデータチャンクが正しく受信されているものとします。"
    },
    {
      "indent": 3,
      "text": "Gap Ack Block Start: 16 bits (unsigned integer)",
      "ja": "ギャップAckブロックスタート：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Indicates the Start offset TSN for this Gap Ack Block. To calculate the actual TSN number the Cumulative TSN Ack is added to this offset number. This calculated TSN identifies the first TSN in this Gap Ack Block that has been received.",
      "ja": "スタートは、このギャップAckブロックのためにTSNを相殺することを示します。実際のTSN番号を算出する累積TSN ACKは、このオフセット数に加算されます。この計算されたTSNが受信されています。このギャップAckブロックの最初のTSNを識別する。"
    },
    {
      "indent": 3,
      "text": "Gap Ack Block End: 16 bits (unsigned integer)",
      "ja": "ギャップAckブロック終了：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Indicates the End offset TSN for this Gap Ack Block. To calculate the actual TSN number, the Cumulative TSN Ack is added to this offset number. This calculated TSN identifies the TSN of the last DATA chunk received in this Gap Ack Block.",
      "ja": "エンドは、このギャップAckブロックのためにTSNを相殺することを示します。実際のTSN番号を計算するために、累積TSN ACKは、このオフセット数に加算されます。この計算されたTSNは、このギャップAckブロックで受信した最後のデータチャンクのTSNを識別する。"
    },
    {
      "indent": 3,
      "text": "For example, assume that the receiver has the following DATA chunks newly arrived at the time when it decides to send a Selective ACK,",
      "ja": "例えば、それは選択的ACKを送信することを決定したときに受信機は次のデータチャンクは、新た時間に到着したと仮定し、"
    },
    {
      "indent": 27,
      "text": "----------\n| TSN=17 |\n----------\n|        | <- still missing\n----------\n| TSN=15 |\n----------\n| TSN=14 |\n----------\n|        | <- still missing\n----------\n| TSN=12 |\n----------\n| TSN=11 |\n----------\n| TSN=10 |\n----------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "then the parameter part of the SACK MUST be constructed as follows (assuming the new a_rwnd is set to 4660 by the sender):",
      "ja": "次いで、SACKのパラメータの一部は、（送信者4660に設定されている新しいa_rwndを仮定して）以下のように構築されなければなりません。"
    },
    {
      "indent": 21,
      "text": "+--------------------------------+\n|   Cumulative TSN Ack = 12      |\n+--------------------------------+\n|        a_rwnd = 4660           |\n+----------------+---------------+\n| num of block=2 | num of dup=0  |\n+----------------+---------------+\n|block #1 strt=2 |block #1 end=3 |\n+----------------+---------------+\n|block #2 strt=5 |block #2 end=5 |\n+----------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Duplicate TSN: 32 bits (unsigned integer)",
      "ja": "重複TSN：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Indicates the number of times a TSN was received in duplicate since the last SACK was sent. Every time a receiver gets a duplicate TSN (before sending the SACK), it adds it to the list of duplicates. The duplicate count is reinitialized to zero after sending each SACK.",
      "ja": "最後のSACKが送信されたので、TSNが重複して受信された回数を示します。受信機は（SACKを送信する前に）重複TSNを取得するたびに、重複のリストに追加します。重複カウントは各SACKを送った後、ゼロに再初期化されます。"
    },
    {
      "indent": 3,
      "text": "For example, if a receiver were to get the TSN 19 three times it would list 19 twice in the outbound SACK. After sending the SACK, if it received yet one more TSN 19 it would list 19 as a duplicate once in the next outgoing SACK.",
      "ja": "受信機は、TSN 19三回を取得した場合たとえば、それはアウトバウンドSACKで二回19をリストします。それはまだ1以上TSN 19を受け取った場合はSACKを送った後、それはかつて次の発信SACKに重複として19をリストします。"
    },
    {
      "indent": 0,
      "text": "3.3.5. Heartbeat Request (HEARTBEAT) (4)",
      "section_title": true,
      "ja": "3.3.5。ハートビート要求（ハートビート）（4）"
    },
    {
      "indent": 3,
      "text": "An endpoint should send this chunk to its peer endpoint to probe the reachability of a particular destination transport address defined in the present association.",
      "ja": "エンドポイントは、現在対応して定義された特定の宛先トランスポート・アドレスの到達可能性を調べるために、そのピアエンドポイントにこのチャンクを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The parameter field contains the Heartbeat Information, which is a variable-length opaque data structure understood only by the sender.",
      "ja": "パラメータフィールドは、送信者によって理解される可変長の不透明データ構造である心拍情報を含んでいます。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 4    | Chunk  Flags  |      Heartbeat Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/            Heartbeat Information TLV (Variable-Length)        /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to 0 on transmit and ignored on receipt.",
      "ja": "送信時に0に設定して、領収書の上で無視。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Length: 16 bits (unsigned integer)",
      "ja": "ハートビート長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the chunk in bytes, including the chunk header and the Heartbeat Information field.",
      "ja": "チャンクヘッダーと心拍情報フィールドを含む、バイトチャンクのサイズに設定。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Information: variable length",
      "ja": "ハートビート情報：可変長"
    },
    {
      "indent": 6,
      "text": "Defined as a variable-length parameter using the format described in Section 3.2.1, i.e.:",
      "ja": "すなわち、セクション3.2.1に記載の形式を使用して、可変長のパラメータとして定義され："
    },
    {
      "indent": 9,
      "text": "Variable Parameters                  Status     Type Value\n-------------------------------------------------------------\nHeartbeat Info                       Mandatory   1",
      "raw": true
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Heartbeat Info Type=1      |         HB Info Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                  Sender-Specific Heartbeat Info               /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Sender-Specific Heartbeat Info field should normally include information about the sender's current time when this HEARTBEAT chunk is sent and the destination transport address to which this HEARTBEAT is sent (see Section 8.3). This information is simply reflected back by the receiver in the HEARTBEAT ACK message (see Section 3.3.6). Note also that the HEARTBEAT message is both for reachability checking and for path verification (see Section 5.4). When a HEARTBEAT chunk is being used for path verification purposes, it MUST hold a 64-bit random nonce.",
      "ja": "送信者固有のハートビートInfoフィールドは、通常、送信者の現在のこのHEARTBEATチャンクが送信された時点と、このHEARTBEATが送られる先のトランスポートアドレス（セクション8.3を参照）に関する情報を含める必要があります。この情報は、単にバックHEARTBEAT ACKメッセージのレシーバによって反射される（セクション3.3.6参照）。メモはまた、ハートビート・メッセージは、両方の到達可能性チェックにパス検証のためのものであること（セクション5.4を参照します）。 HEARTBEATチャンクはパス検証のために使用されている場合、それは64ビットのランダムnonceを保持しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3.6. Heartbeat Acknowledgement (HEARTBEAT ACK) (5)",
      "section_title": true,
      "ja": "3.3.6。ハートビート確認応答（HEARTBEAT ACK）（5）"
    },
    {
      "indent": 3,
      "text": "An endpoint should send this chunk to its peer endpoint as a response to a HEARTBEAT chunk (see Section 8.3). A HEARTBEAT ACK is always sent to the source IP address of the IP datagram containing the HEARTBEAT chunk to which this ack is responding.",
      "ja": "エンドポイントは、（8.3節を参照）HEARTBEATチャンクへの応答として、ピアエンドポイントにこのチャンクを送信する必要があります。 HEARTBEAT ACKのは、常にこのACKが応答されたHEARTBEATチャンクを含むIPデータグラムの送信元IPアドレスに送信されます。"
    },
    {
      "indent": 3,
      "text": "The parameter field contains a variable-length opaque data structure.",
      "ja": "パラメータフィールドは、可変長の不透明なデータ構造が含まれています。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 5    | Chunk  Flags  |    Heartbeat Ack Length       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/            Heartbeat Information TLV (Variable-Length)        /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to 0 on transmit and ignored on receipt.",
      "ja": "送信時に0に設定して、領収書の上で無視。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Ack Length: 16 bits (unsigned integer)",
      "ja": "ハートビートのAck長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the chunk in bytes, including the chunk header and the Heartbeat Information field.",
      "ja": "チャンクヘッダーと心拍情報フィールドを含む、バイトチャンクのサイズに設定。"
    },
    {
      "indent": 3,
      "text": "Heartbeat Information: variable length",
      "ja": "ハートビート情報：可変長"
    },
    {
      "indent": 6,
      "text": "This field MUST contain the Heartbeat Information parameter of the Heartbeat Request to which this Heartbeat Acknowledgement is responding.",
      "ja": "このフィールドは、このハートビート確認応答が応答されているハートビート要求のハートビート情報パラメータを含まなければなりません。"
    },
    {
      "indent": 9,
      "text": "Variable Parameters                  Status     Type Value\n-------------------------------------------------------------\nHeartbeat Info                       Mandatory   1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3.7. Abort Association (ABORT) (6)",
      "section_title": true,
      "ja": "3.3.7。中止協会（ABORT）（6）"
    },
    {
      "indent": 3,
      "text": "The ABORT chunk is sent to the peer of an association to close the association. The ABORT chunk may contain Cause Parameters to inform the receiver about the reason of the abort. DATA chunks MUST NOT be bundled with ABORT. Control chunks (except for INIT, INIT ACK, and SHUTDOWN COMPLETE) MAY be bundled with an ABORT, but they MUST be placed before the ABORT in the SCTP packet or they will be ignored by the receiver.",
      "ja": "ABORTチャンクはアソシエーションを閉じるために、関連のピアに送信されます。 ABORTチャンクは中止の理由について、受信機に通知する原因のパラメータが含まれていてもよいです。 DATAチャンクはABORTとバンドルしてはなりません。 （INIT、INIT ACK、およびSHUTDOWN COMPLETEを除く）制御チャンクはABORTとバンドルされるかもしれないが、それらはSCTPパケットにABORT前に配置しなければならないか、またはそれらが受信機によって無視されます。"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives an ABORT with a format error or no TCB is found, it MUST silently discard it. Moreover, under any circumstances, an endpoint that receives an ABORT MUST NOT respond to that ABORT by sending an ABORT of its own.",
      "ja": "エンドポイントは、フォーマットエラーでABORTを受信するか、または全くTCBが見つからない場合、それは静かにそれを捨てなければなりません。また、どのような状況の下で、ABORTを受けたエンドポイントは、自身のABORTを送信することによって、そのABORTに応じてはいけません。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 6    |Reserved     |T|           Length              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                   zero or more Error Causes                   /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Reserved: 7 bits",
      "ja": "予約：7ビット"
    },
    {
      "indent": 6,
      "text": "Set to 0 on transmit and ignored on receipt.",
      "ja": "送信時に0に設定して、領収書の上で無視。"
    },
    {
      "indent": 6,
      "text": "T bit: 1 bit",
      "ja": "Tビット：1ビット"
    },
    {
      "indent": 6,
      "text": "The T bit is set to 0 if the sender filled in the Verification Tag expected by the peer. If the Verification Tag is reflected, the T bit MUST be set to 1. Reflecting means that the sent Verification Tag is the same as the received one.",
      "ja": "送信側がピアによって期待される検証タグ内に充填された場合にTビットが0に設定されています。検証タグが反映されている場合、Tビットは、送信された検証タグは、受信したものと同じであると反射手段を1に設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: Special rules apply to this chunk for verification; please see Section 8.5.1 for details.",
      "ja": "注意：特別なルールは検証のために、この塊に適用されます。詳細については、8.5.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer)",
      "ja": "長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the chunk in bytes, including the chunk header and all the Error Cause fields present.",
      "ja": "チャンクヘッダと存在するすべてのエラー原因フィールドを含むバイト単位のチャンクの大きさに設定。"
    },
    {
      "indent": 6,
      "text": "See Section 3.3.10 for Error Cause definitions.",
      "ja": "エラー原因の定義については、セクション3.3.10を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.8. Shutdown Association (SHUTDOWN) (7)",
      "section_title": true,
      "ja": "3.3.8。シャットダウン協会（SHUTDOWN）（7）"
    },
    {
      "indent": 3,
      "text": "An endpoint in an association MUST use this chunk to initiate a graceful close of the association with its peer. This chunk has the following format.",
      "ja": "関連エンドポイントは、そのピアと関連の優雅なクローズを開始するために、このチャンクを使用しなければなりません。このチャンクは次の形式を持っています。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 7    | Chunk  Flags  |      Length = 8               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Cumulative TSN Ack                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to 0 on transmit and ignored on receipt.",
      "ja": "送信時に0に設定して、領収書の上で無視。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer)",
      "ja": "長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Indicates the length of the parameter. Set to 8.",
      "ja": "パラメータの長さを示します。 8に設定します。"
    },
    {
      "indent": 3,
      "text": "Cumulative TSN Ack: 32 bits (unsigned integer)",
      "ja": "累積TSNのAck：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This parameter contains the TSN of the last chunk received in sequence before any gaps.",
      "ja": "このパラメータは、任意のギャップの前に順序で受信された最後のチャンクのTSNが含まれています。"
    },
    {
      "indent": 6,
      "text": "Note: Since the SHUTDOWN message does not contain Gap Ack Blocks, it cannot be used to acknowledge TSNs received out of order. In a SACK, lack of Gap Ack Blocks that were previously included indicates that the data receiver reneged on the associated DATA chunks. Since SHUTDOWN does not contain Gap Ack Blocks, the receiver of the SHUTDOWN shouldn't interpret the lack of a Gap Ack Block as a renege. (See Section 6.2 for information on reneging.)",
      "ja": "注意：SHUTDOWNメッセージはギャップAckブロックが含まれていないので、するTSNは順不同で受信確認するために使用することはできません。 SACKでは、以前に含まれていたギャップAckブロックの欠如は、データ受信機は、関連するデータチャンクに破っていることを示しています。 SHUTDOWNはギャップAckブロックが含まれていないので、SHUTDOWNの受信機はrenegeとしてギャップAckブロックの欠如を解釈するべきではありません。 （renegingの詳細については、セクション6.2を参照してください。）"
    },
    {
      "indent": 0,
      "text": "3.3.9. Shutdown Acknowledgement (SHUTDOWN ACK) (8)",
      "section_title": true,
      "ja": "3.3.9。シャットダウン応答（SHUTDOWN ACKの）（8）"
    },
    {
      "indent": 3,
      "text": "This chunk MUST be used to acknowledge the receipt of the SHUTDOWN chunk at the completion of the shutdown process; see Section 9.2 for details.",
      "ja": "このチャンクはシャットダウン処理の完了時にSHUTDOWNチャンクの受信を確認するために使用されなければなりません。詳細については、セクション9.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The SHUTDOWN ACK chunk has no parameters.",
      "ja": "SHUTDOWN ACKチャンクにはパラメータはありません。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 8    |Chunk  Flags   |      Length = 4               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to 0 on transmit and ignored on receipt.",
      "ja": "送信時に0に設定して、領収書の上で無視。"
    },
    {
      "indent": 0,
      "text": "3.3.10. Operation Error (ERROR) (9)",
      "section_title": true,
      "ja": "3.3.10。操作エラー（ERROR）（9）"
    },
    {
      "indent": 3,
      "text": "An endpoint sends this chunk to its peer endpoint to notify it of certain error conditions. It contains one or more error causes. An Operation Error is not considered fatal in and of itself, but may be used with an ABORT chunk to report a fatal condition. It has the following parameters:",
      "ja": "エンドポイントは、特定のエラー状態のことを通知するために、ピアエンドポイントにこのチャンクを送信します。これは、1つの以上のエラーの原因が含まれています。操作エラーは、それ自体の致命的と見なされていないが、致命的な状態を報告するためにABORTチャンクで使用することができます。これは、次のパラメータがあります。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 9    | Chunk  Flags  |           Length              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               \\\n/                    one or more Error Causes                   /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to 0 on transmit and ignored on receipt.",
      "ja": "送信時に0に設定して、領収書の上で無視。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer)",
      "ja": "長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the chunk in bytes, including the chunk header and all the Error Cause fields present.",
      "ja": "チャンクヘッダと存在するすべてのエラー原因フィールドを含むバイト単位のチャンクの大きさに設定。"
    },
    {
      "indent": 3,
      "text": "Error causes are defined as variable-length parameters using the format described in Section 3.2.1, that is:",
      "ja": "エラーの原因は、セクション3.2.1で説明したフォーマットを使用して、可変長のパラメータとして定義され、すなわち："
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Cause Code          |       Cause Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                    Cause-Specific Information                 /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cause Code: 16 bits (unsigned integer)",
      "ja": "原因コード：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Defines the type of error conditions being reported.",
      "ja": "報告されたエラー条件のタイプを定義します。"
    },
    {
      "indent": 9,
      "text": "Cause Code\nValue           Cause Code\n---------      ----------------\n 1              Invalid Stream Identifier\n 2              Missing Mandatory Parameter\n 3              Stale Cookie Error\n 4              Out of Resource\n 5              Unresolvable Address\n 6              Unrecognized Chunk Type\n 7              Invalid Mandatory Parameter\n 8              Unrecognized Parameters\n 9              No User Data\n10              Cookie Received While Shutting Down\n11              Restart of an Association with New Addresses\n12              User Initiated Abort\n13              Protocol Violation",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cause Length: 16 bits (unsigned integer)",
      "ja": "原因長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the parameter in bytes, including the Cause Code, Cause Length, and Cause-Specific Information fields.",
      "ja": "原因コード、原因の長さ、および原因固有の情報フィールドを含むバイト単位でのパラメータの大きさに設定してください。"
    },
    {
      "indent": 3,
      "text": "Cause-Specific Information: variable length",
      "ja": "原因固有の情報：可変長"
    },
    {
      "indent": 6,
      "text": "This field carries the details of the error condition.",
      "ja": "このフィールドには、エラー状態の詳細を運びます。"
    },
    {
      "indent": 3,
      "text": "Section 3.3.10.1 - Section 3.3.10.13 define error causes for SCTP. Guidelines for the IETF to define new error cause values are discussed in Section 14.3.",
      "ja": "セクション3.3.10.1  - セクション3.3.10.13エラーがSCTPの原因を定義します。新しいエラー原因値を定義するために、IETFのためのガイドラインは、セクション14.3で議論されています。"
    },
    {
      "indent": 0,
      "text": "3.3.10.1. Invalid Stream Identifier (1)",
      "section_title": true,
      "ja": "3.3.10.1。無効なストリーム識別子（1）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Invalid Stream Identifier: Indicates endpoint received a DATA chunk sent to a nonexistent stream.",
      "ja": "無効なストリーム識別子：エンドポイントが存在しないストリームに送信されたデータチャンクを受け取ったことを示します。"
    },
    {
      "indent": 7,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=1              |      Cause Length=8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Stream Identifier      |         (Reserved)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Stream Identifier: 16 bits (unsigned integer)",
      "ja": "ストリーム識別子：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Contains the Stream Identifier of the DATA chunk received in error.",
      "ja": "エラーで受信したデータチャンクのストリーム識別子が含まれています。"
    },
    {
      "indent": 3,
      "text": "Reserved: 16 bits",
      "ja": "予約：16ビット"
    },
    {
      "indent": 6,
      "text": "This field is reserved. It is set to all 0's on transmit and ignored on receipt.",
      "ja": "このフィールドは予約されています。それは、送信上のすべて0に設定して、領収書の上で無視されます。"
    },
    {
      "indent": 0,
      "text": "3.3.10.2. Missing Mandatory Parameter (2)",
      "section_title": true,
      "ja": "3.3.10.2。必須パラメータがありません（2）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Missing Mandatory Parameter: Indicates that one or more mandatory TLV parameters are missing in a received INIT or INIT ACK.",
      "ja": "必須パラメータがありません：一個の以上の必須TLVパラメータは、受信INITまたはINIT ACKに欠けていることを示します。"
    },
    {
      "indent": 7,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=2              |      Cause Length=8+N*2       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   Number of missing params=N                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Missing Param Type #1       |   Missing Param Type #2       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Missing Param Type #N-1     |   Missing Param Type #N       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Number of Missing params: 32 bits (unsigned integer)",
      "ja": "欠落のparamsの数：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This field contains the number of parameters contained in the Cause-Specific Information field.",
      "ja": "このフィールドは、原因別情報フィールドに含まれるパラメータの数が含まれています。"
    },
    {
      "indent": 3,
      "text": "Missing Param Type: 16 bits (unsigned integer)",
      "ja": "行方不明のParamタイプ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Each field will contain the missing mandatory parameter number.",
      "ja": "各フィールドには、不足している必須パラメータ番号が含まれています。"
    },
    {
      "indent": 0,
      "text": "3.3.10.3. Stale Cookie Error (3)",
      "section_title": true,
      "ja": "3.3.10.3。古いCookieのエラー（3）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n--------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Stale Cookie Error: Indicates the receipt of a valid State Cookie that has expired.",
      "ja": "古いCookieのエラー：期限切れの有効な状態クッキーの受信を示します。"
    },
    {
      "indent": 7,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=3              |       Cause Length=8          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Measure of Staleness (usec.)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Measure of Staleness: 32 bits (unsigned integer)",
      "ja": "陳腐化の目安：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "This field contains the difference, in microseconds, between the current time and the time the State Cookie expired.",
      "ja": "このフィールドは、現在の時刻と状態クッキーの有効期限が切れた時間の間、マイクロ秒で、違いが含まれています。"
    },
    {
      "indent": 6,
      "text": "The sender of this error cause MAY choose to report how long past expiration the State Cookie is by including a non-zero value in the Measure of Staleness field. If the sender does not wish to provide this information, it should set the Measure of Staleness field to the value of zero.",
      "ja": "このエラーの原因の送信者は、どのくらい過去満了州クッキー報告することを選ぶかもしれ古フィールドの尺度でゼロ以外の値を含めることです。送信者がこの情報を提供したくない場合は、ゼロの値に古フィールドの尺度を設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.10.4. Out of Resource (4)",
      "section_title": true,
      "ja": "3.3.10.4。リソースのうち、（4）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Out of Resource: Indicates that the sender is out of resource. This is usually sent in combination with or within an ABORT.",
      "ja": "リソースの不足：送信者がリソースの外であることを示します。これは通常、またはABORT以内に組み合わせて送信されます。"
    },
    {
      "indent": 7,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=4              |      Cause Length=4           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3.10.5. Unresolvable Address (5)",
      "section_title": true,
      "ja": "3.3.10.5。解決できないアドレス（5）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Unresolvable Address: Indicates that the sender is not able to resolve the specified address parameter (e.g., type of address is not supported by the sender). This is usually sent in combination with or within an ABORT.",
      "ja": "解決不能アドレス：送信者が（例えば、アドレスの種類は、送信者によってサポートされていません）指定されたアドレスのパラメータを解決できないことを示します。これは通常、またはABORT以内に組み合わせて送信されます。"
    },
    {
      "indent": 7,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=5              |      Cause Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                  Unresolvable Address                         /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Unresolvable Address: variable length",
      "ja": "解決不能住所：可変長"
    },
    {
      "indent": 6,
      "text": "The Unresolvable Address field contains the complete Type, Length, and Value of the address parameter (or Host Name parameter) that contains the unresolvable address or host name.",
      "ja": "解決できないアドレスフィールドには、解決できないアドレスまたはホスト名が含まれている完全なタイプ、長さ、およびアドレス・パラメータ（またはホスト名パラメータ）の値が含まれています。"
    },
    {
      "indent": 0,
      "text": "3.3.10.6. Unrecognized Chunk Type (6)",
      "section_title": true,
      "ja": "3.3.10.6。認識できないチャンクタイプ（6）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Unrecognized Chunk Type: This error cause is returned to the originator of the chunk if the receiver does not understand the chunk and the upper bits of the 'Chunk Type' are set to 01 or 11.",
      "ja": "認識できないチャンクタイプ：受信機はチャンクと01または11に設定されている「チャンクタイプ」の上位ビットを理解していない場合、このエラーの原因は、チャンクの創始者に返されます。"
    },
    {
      "indent": 7,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=6              |      Cause Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                  Unrecognized Chunk                           /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Unrecognized Chunk: variable length",
      "ja": "認識できないチャンク：可変長"
    },
    {
      "indent": 6,
      "text": "The Unrecognized Chunk field contains the unrecognized chunk from the SCTP packet complete with Chunk Type, Chunk Flags, and Chunk Length.",
      "ja": "認識できないチャンクのフィールドは、チャンクタイプ、チャンクフラグ、およびチャンク長との完全なSCTPパケットから認識されていないチャンクが含まれています。"
    },
    {
      "indent": 0,
      "text": "3.3.10.7. Invalid Mandatory Parameter (7)",
      "section_title": true,
      "ja": "3.3.10.7。無効な必須パラメータ（7）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Invalid Mandatory Parameter: This error cause is returned to the originator of an INIT or INIT ACK chunk when one of the mandatory parameters is set to an invalid value.",
      "ja": "無効な必須パラメータ：このエラーの原因は、必須パラメータの一つが無効な値に設定されているINITまたはINIT ACKチャンクの元に返されます。"
    },
    {
      "indent": 7,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=7              |      Cause Length=4           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3.10.8. Unrecognized Parameters (8)",
      "section_title": true,
      "ja": "3.3.10.8。認識できないパラメータ（8）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Unrecognized Parameters: This error cause is returned to the originator of the INIT ACK chunk if the receiver does not recognize one or more Optional TLV parameters in the INIT ACK chunk.",
      "ja": "認識されないパラメータは：受信機がINIT ACKチャンク内の1つまたは複数のオプションのTLVパラメータを認識しない場合、このエラー原因はINIT ACKチャンクの元に返されます。"
    },
    {
      "indent": 7,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=8              |      Cause Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                  Unrecognized Parameters                      /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Unrecognized Parameters: variable length",
      "ja": "認識できないパラメータ：可変長"
    },
    {
      "indent": 6,
      "text": "The Unrecognized Parameters field contains the unrecognized parameters copied from the INIT ACK chunk complete with TLV. This error cause is normally contained in an ERROR chunk bundled with the COOKIE ECHO chunk when responding to the INIT ACK, when the sender of the COOKIE ECHO chunk wishes to report unrecognized parameters.",
      "ja": "認識できないパラメータフィールドはTLVとの完全なINIT ACKチャンクからコピーされた認識できないパラメータが含まれています。このエラーの原因は通常、COOKIE ECHOチャンクの送信者が認識できないパラメータを報告したい場合、INIT ACKに応答するときCOOKIE ECHOチャンクにバンドルERRORチャンクに含まれています。"
    },
    {
      "indent": 0,
      "text": "3.3.10.9. No User Data (9)",
      "section_title": true,
      "ja": "3.3.10.9。ユーザデータ（9）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "No User Data: This error cause is returned to the originator of a",
      "ja": "ユーザデータ：このエラーの原因は、Aの元に返されません"
    },
    {
      "indent": 3,
      "text": "DATA chunk if a received DATA chunk has no user data.",
      "ja": "受信したデータチャンクはユーザデータを持っていない場合、データの塊。"
    },
    {
      "indent": 7,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=9              |      Cause Length=8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                  TSN value                                    /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "TSN value: 32 bits (unsigned integer)",
      "ja": "TSN値：32ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "The TSN value field contains the TSN of the DATA chunk received with no user data field.",
      "ja": "TSN値フィールドは、ユーザデータフィールドと、受信したデータチャンクのTSNを含んでいます。"
    },
    {
      "indent": 6,
      "text": "This cause code is normally returned in an ABORT chunk (see Section 6.2).",
      "ja": "この原因コードは、通常ABORTチャンクで返されます（セクション6.2を参照してください）。"
    },
    {
      "indent": 0,
      "text": "3.3.10.10. Cookie Received While Shutting Down (10)",
      "section_title": true,
      "ja": "3.3.10.10。シャットダウン中に受信したクッキー（10）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n---------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cookie Received While Shutting Down: A COOKIE ECHO was received while the endpoint was in the SHUTDOWN-ACK-SENT state. This error is usually returned in an ERROR chunk bundled with the retransmitted SHUTDOWN ACK.",
      "ja": "エンドポイントがSHUTDOWN-ACK-SENT状態にあったCOOKIE ECHOを受信しました：クッキーは、シャットダウン中に受信しました。このエラーは通常、再送さSHUTDOWNのACKにバンドルERRORチャンクで返されます。"
    },
    {
      "indent": 7,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Cause Code=10              |      Cause Length=4          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3.10.11. Restart of an Association with New Addresses (11)",
      "section_title": true,
      "ja": "3.3.10.11。新しいアドレスを持つ協会の再起動（11）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n--------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Restart of an association with new addresses: An INIT was received on an existing association. But the INIT added addresses to the association that were previously NOT part of the association. The new addresses are listed in the error code. This ERROR is normally sent as part of an ABORT refusing the INIT (see Section 5.2).",
      "ja": "新しいアドレスとの関連の再起動：INITは、既存の関連付けに受信しました。しかし、INITは、以前協会の一部ではなかった協会にアドレスを追加しました。新しいアドレスは、エラーコードに記載されています。このエラーは通常、INITを拒否ABORTの一部として送信される（5.2節を参照してください）。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Cause Code=11         |      Cause Length=Variable    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                       New Address TLVs                        /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: Each New Address TLV is an exact copy of the TLV that was found in the INIT chunk that was new, including the Parameter Type and the Parameter Length.",
      "ja": "注意：それぞれの新しいアドレスTLVは、パラメータタイプとパラメータ長を含む、新しいだったINITチャンクで発見されたTLVの正確なコピーです。"
    },
    {
      "indent": 0,
      "text": "3.3.10.12. User-Initiated Abort (12)",
      "section_title": true,
      "ja": "3.3.10.12。ユーザ起動の中止（12）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n--------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This error cause MAY be included in ABORT chunks that are sent because of an upper-layer request. The upper layer can specify an Upper Layer Abort Reason that is transported by SCTP transparently and MAY be delivered to the upper-layer protocol at the peer.",
      "ja": "このエラーの原因があるため、上位レイヤの要求で送信されたABORTチャンクに含まれるかもしれません。上層を透過SCTPによって搬送され、ピアに上位層プロトコルに送達することができる上位層アボート理由を指定することができます。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Cause Code=12         |      Cause Length=Variable    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                    Upper Layer Abort Reason                   /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3.10.13. Protocol Violation (13)",
      "section_title": true,
      "ja": "3.3.10.13。プロトコル違反（13）"
    },
    {
      "indent": 3,
      "text": "Cause of error\n--------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This error cause MAY be included in ABORT chunks that are sent because an SCTP endpoint detects a protocol violation of the peer that is not covered by the error causes described in Section 3.3.10.1 to Section 3.3.10.12. An implementation MAY provide additional information specifying what kind of protocol violation has been detected.",
      "ja": "このエラーの原因は、SCTP終点がセクション3.3.10.12にセクション3.3.10.1に記載されているエラーの原因によって覆われていない相手のプロトコル違反を検出したため、送信されたABORTチャンクに含まれるかもしれません。実装が検出されたプロトコル違反の種類を指定する追加情報を提供することができます。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Cause Code=13         |      Cause Length=Variable    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                    Additional Information                     /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3.11. Cookie Echo (COOKIE ECHO) (10)",
      "section_title": true,
      "ja": "3.3.11。クッキーエコー（COOKIE ECHO）（10）"
    },
    {
      "indent": 3,
      "text": "This chunk is used only during the initialization of an association. It is sent by the initiator of an association to its peer to complete the initialization process. This chunk MUST precede any DATA chunk sent within the association, but MAY be bundled with one or more DATA chunks in the same packet.",
      "ja": "このチャンクのみ関連の初期化中に使用されます。初期化プロセスを完了するために、そのピアに関連のイニシエータによって送信されます。この塊は協会内で送信されるデータチャンクを先行しなければなりませんが、同じパケット内の1つまたは複数のDATAチャンクにバンドルされるかもしれません。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 10   |Chunk  Flags   |         Length                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                     Cookie                                    /\n\\                                                               \\\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bit",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to 0 on transmit and ignored on receipt.",
      "ja": "送信時に0に設定して、領収書の上で無視。"
    },
    {
      "indent": 3,
      "text": "Length: 16 bits (unsigned integer)",
      "ja": "長さ：16ビット（符号なし整数）"
    },
    {
      "indent": 6,
      "text": "Set to the size of the chunk in bytes, including the 4 bytes of the chunk header and the size of the cookie.",
      "ja": "チャンクヘッダーとクッキーのサイズの4つのバイトを含む、バイトチャンクのサイズに設定。"
    },
    {
      "indent": 3,
      "text": "Cookie: variable size",
      "ja": "クッキー：可変サイズ"
    },
    {
      "indent": 6,
      "text": "This field must contain the exact cookie received in the State Cookie parameter from the previous INIT ACK.",
      "ja": "このフィールドは、前のINIT ACKから州Cookieパラメタで受信し、正確なクッキーが含まれている必要があります。"
    },
    {
      "indent": 6,
      "text": "An implementation SHOULD make the cookie as small as possible to ensure interoperability.",
      "ja": "実装は、相互運用性を確保することができるようクッキーは限り小さくすべきです。"
    },
    {
      "indent": 6,
      "text": "Note: A Cookie Echo does NOT contain a State Cookie parameter; instead, the data within the State Cookie's Parameter Value becomes the data within the Cookie Echo's Chunk Value. This allows an implementation to change only the first 2 bytes of the State Cookie parameter to become a COOKIE ECHO chunk.",
      "ja": "注意：クッキーエコーは州Cookieパラメタが含まれていません。代わりに、国家クッキーのパラメータ値内のデータは、クッキーエコーのチャンク値内のデータとなります。これは、実装がCOOKIE ECHOチャンクになるように状態クッキーパラメータの最初の2つのバイトを変更することを可能にします。"
    },
    {
      "indent": 0,
      "text": "3.3.12. Cookie Acknowledgement (COOKIE ACK) (11)",
      "section_title": true,
      "ja": "3.3.12。クッキー確認応答（COOKIE A​​CK）（11）"
    },
    {
      "indent": 3,
      "text": "This chunk is used only during the initialization of an association. It is used to acknowledge the receipt of a COOKIE ECHO chunk. This chunk MUST precede any DATA or SACK chunk sent within the association, but MAY be bundled with one or more DATA chunks or SACK chunk's in the same SCTP packet.",
      "ja": "このチャンクのみ関連の初期化中に使用されます。 COOKIE ECHOチャンクの受信を確認するために使用されます。この塊は協会内に送信データやSACK塊に先行しなければなりませんが、同じSCTPパケット内の1つのまたは複数のDATAチャンクまたはSACKチャンクのにバンドルされるかもしれません。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 11   |Chunk  Flags   |     Length = 4                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Set to 0 on transmit and ignored on receipt.",
      "ja": "送信時に0に設定して、領収書の上で無視。"
    },
    {
      "indent": 0,
      "text": "3.3.13. Shutdown Complete (SHUTDOWN COMPLETE) (14)",
      "section_title": true,
      "ja": "3.3.13。シャットダウン完了（SHUTDOWN COMPLETE）（14）"
    },
    {
      "indent": 3,
      "text": "This chunk MUST be used to acknowledge the receipt of the SHUTDOWN ACK chunk at the completion of the shutdown process; see Section 9.2 for details.",
      "ja": "このチャンクはシャットダウン処理の完了時にSHUTDOWN ACKチャンクの受信を確認するために使用されなければなりません。詳細については、セクション9.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The SHUTDOWN COMPLETE chunk has no parameters.",
      "ja": "SHUTDOWN COMPLETEチャンクはパラメータはありません。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 14   |Reserved     |T|      Length = 4               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Chunk Flags: 8 bits",
      "ja": "チャンクフラグ：8ビット"
    },
    {
      "indent": 6,
      "text": "Reserved: 7 bits",
      "ja": "予約：7ビット"
    },
    {
      "indent": 9,
      "text": "Set to 0 on transmit and ignored on receipt.",
      "ja": "送信時に0に設定して、領収書の上で無視。"
    },
    {
      "indent": 9,
      "text": "T bit: 1 bit",
      "ja": "Tビット：1ビット"
    },
    {
      "indent": 6,
      "text": "The T bit is set to 0 if the sender filled in the Verification Tag expected by the peer. If the Verification Tag is reflected, the T bit MUST be set to 1. Reflecting means that the sent Verification Tag is the same as the received one.",
      "ja": "送信側がピアによって期待される検証タグ内に充填された場合にTビットが0に設定されています。検証タグが反映されている場合、Tビットは、送信された検証タグは、受信したものと同じであると反射手段を1に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: Special rules apply to this chunk for verification, please see Section 8.5.1 for details.",
      "ja": "注意：特別なルールは検証のために、このチャンクに適用されます、詳細については、セクション8.5.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "4. SCTP Association State Diagram",
      "section_title": true,
      "ja": "4. SCTP協会の状態図"
    },
    {
      "indent": 3,
      "text": "During the life time of an SCTP association, the SCTP endpoint's association progresses from one state to another in response to various events. The events that may potentially advance an association's state include:",
      "ja": "SCTPアソシエーションのライフタイムの間に、SCTPエンドポイントの関連付けは、様々なイベントに応じて、ある状態から別の状態に進行します。潜在的に関連性の状態を進める可能性のあるイベントは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o SCTP user primitive calls, e.g., [ASSOCIATE], [SHUTDOWN], [ABORT],",
      "ja": "OのSCTPユーザプリミティブコール、例えば、[ASSOCIATE]、[SHUTDOWN]、[ABORT]"
    },
    {
      "indent": 3,
      "text": "o Reception of INIT, COOKIE ECHO, ABORT, SHUTDOWN, etc., control chunks, or",
      "ja": "O INIT、COOKIE ECHO、ABORT、SHUTDOWNなどの受信、制御チャンク、または"
    },
    {
      "indent": 3,
      "text": "o Some timeout events.",
      "ja": "いくつかのタイムアウトイベントO。"
    },
    {
      "indent": 3,
      "text": "The state diagram in the figures below illustrates state changes, together with the causing events and resulting actions. Note that some of the error conditions are not shown in the state diagram. Full descriptions of all special cases are found in the text.",
      "ja": "図中の状態図は、以下一緒に原因事象と結果のアクションと、状態の変化を示す図です。エラー条件のいくつかは、状態図には示されていないことに留意されたいです。すべての特殊例全記述は、テキストに記載されています。"
    },
    {
      "indent": 3,
      "text": "Note: Chunk names are given in all capital letters, while parameter names have the first letter capitalized, e.g., COOKIE ECHO chunk type vs. State Cookie parameter. If more than one event/message can occur that causes a state transition, it is labeled (A), (B), etc.",
      "ja": "注意：パラメータ名は最初の文字は州Cookieパラメタ対、例えば、COOKIE ECHOチャンクタイプを資産計上していながら、チャンク名は、すべて大文字で指定されています。複数のイベント/メッセージは、状態遷移を引き起こすことが起こり得る場合には、標識されている（A）、（B）、等"
    },
    {
      "indent": 3,
      "text": "                   -----          -------- (from any state)\n                 /       \\      /  rcv ABORT      [ABORT]\nrcv INIT        |         |    |   ----------  or ----------\n--------------- |         v    v   delete TCB     snd ABORT\ngenerate Cookie  \\    +---------+                 delete TCB\nsnd INIT ACK       ---|  CLOSED |\n                      +---------+\n                       /      \\      [ASSOCIATE]\n                      /        \\     ---------------\n                     |          |    create TCB\n                     |          |    snd INIT\n                     |          |    strt init timer\n      rcv valid      |          |\n    COOKIE  ECHO     |          v\n(1) ---------------- |      +------------+\n    create TCB       |      | COOKIE-WAIT| (2)\n    snd COOKIE ACK   |      +------------+\n                     |          |\n                     |          |    rcv INIT ACK\n                     |          |    -----------------\n                     |          |    snd COOKIE ECHO\n                     |          |    stop init timer\n                     |          |    strt cookie timer\n                     |          v\n                     |      +--------------+\n                     |      | COOKIE-ECHOED| (3)\n                     |      +--------------+\n                     |          |\n                     |          |    rcv COOKIE ACK\n                     |          |    -----------------\n                     |          |    stop cookie timer\n                     v          v\n                   +---------------+\n                   |  ESTABLISHED  |\n                   +---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                 (from the ESTABLISHED state only)\n                               |\n                               |\n                      /--------+--------\\\n  [SHUTDOWN]         /                   \\\n  -------------------|                   |\n  check outstanding  |                   |\n  DATA chunks        |                   |\n                     v                   |\n                +---------+              |\n                |SHUTDOWN-|              | rcv SHUTDOWN\n                |PENDING  |              |------------------\n                +---------+              | check outstanding\n                     |                   | DATA chunks\nNo more outstanding  |                   |\n---------------------|                   |\nsnd SHUTDOWN         |                   |\nstrt shutdown timer  |                   |\n                     v                   v\n                +---------+        +-----------+\n            (4) |SHUTDOWN-|        | SHUTDOWN- |  (5,6)\n                |SENT     |        | RECEIVED  |\n                +---------+        +-----------+\n                     |  \\                |\n(A) rcv SHUTDOWN ACK  |   \\               |\n----------------------|    \\              |\nstop shutdown timer   |     \\rcv:SHUTDOWN |\nsend SHUTDOWN COMPLETE|      \\  (B)       |\ndelete TCB            |       \\           |\n                      |        \\          | No more outstanding\n                      |         \\         |-----------------\n                      |          \\        | send SHUTDOWN ACK\n(B)rcv SHUTDOWN       |           \\       | strt shutdown timer\n----------------------|            \\      |\nsend SHUTDOWN ACK     |             \\     |\nstart shutdown timer  |              \\    |\nmove to SHUTDOWN-     |               \\   |\nACK-SENT              |                |  |\n                      |                v  |\n                      |             +-----------+\n                      |             | SHUTDOWN- | (7)\n                      |             | ACK-SENT  |\n                      |             +----------+-\n                      |                   | (C)rcv SHUTDOWN COMPLETE\n                      |                   |-----------------\n                      |                   | stop shutdown timer\n                      |                   | delete TCB\n                      |                   |",
      "raw": true
    },
    {
      "indent": 25,
      "text": "|                   | (D)rcv SHUTDOWN ACK\n|                   |--------------\n|                   | stop shutdown timer\n|                   | send SHUTDOWN COMPLETE\n|                   | delete TCB\n|                   |\n\\    +---------+    /\n \\-->| CLOSED  |<--/\n     +---------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 3: State Transition Diagram of SCTP",
      "ja": "図3：SCTPの状態遷移図"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 3,
      "text": "1) If the State Cookie in the received COOKIE ECHO is invalid (i.e., failed to pass the integrity check), the receiver MUST silently discard the packet. Or, if the received State Cookie is expired (see Section 5.1.5), the receiver MUST send back an ERROR chunk. In either case, the receiver stays in the CLOSED state.",
      "ja": "1）受信したCOOKIE ECHOで州Cookieが無効である場合（すなわち、整合性チェックを通過することができなかった）、受信機は静かにパケットを捨てなければなりません。受信状態クッキー（5.1.5項を参照）有効期限が切れている場合は、受信機はERRORチャンクを返送しなければなりません。いずれの場合も、受信機は、CLOSED状態にとどまります。"
    },
    {
      "indent": 3,
      "text": "2) If the T1-init timer expires, the endpoint MUST retransmit INIT and restart the T1-init timer without changing state. This MUST be repeated up to 'Max.Init.Retransmits' times. After that, the endpoint MUST abort the initialization process and report the error to the SCTP user.",
      "ja": "T1-INITタイマーが満了した場合2）、エンドポイントは、INITを再送し、状態を変更することなく、T1-INITタイマーを再起動する必要があります。これは、「Max.Init.Retransmits」回まで繰り返さなければなりません。その後、エンドポイントは、初期化プロセスを中止しなければなりませんし、SCTPユーザにエラーを報告します。"
    },
    {
      "indent": 3,
      "text": "3) If the T1-cookie timer expires, the endpoint MUST retransmit COOKIE ECHO and restart the T1-cookie timer without changing state. This MUST be repeated up to 'Max.Init.Retransmits' times. After that, the endpoint MUST abort the initialization process and report the error to the SCTP user.",
      "ja": "T1-クッキータイマーが満了した場合3）、エンドポイントは、COOKIE ECHOを再送して状態を変更することなく、T1-クッキータイマーを再起動する必要があります。これは、「Max.Init.Retransmits」回まで繰り返さなければなりません。その後、エンドポイントは、初期化プロセスを中止しなければなりませんし、SCTPユーザにエラーを報告します。"
    },
    {
      "indent": 3,
      "text": "4) In the SHUTDOWN-SENT state, the endpoint MUST acknowledge any received DATA chunks without delay.",
      "ja": "4）SHUTDOWN-SENT状態で、エンドポイントは、遅滞なく、任意の受信したデータチャンクを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "5) In the SHUTDOWN-RECEIVED state, the endpoint MUST NOT accept any new send requests from its SCTP user.",
      "ja": "5）SHUTDOWN-RECEIVED状態では、エンドポイントは、そのSCTPユーザからの新しい送信要求を受け入れてはいけません。"
    },
    {
      "indent": 3,
      "text": "6) In the SHUTDOWN-RECEIVED state, the endpoint MUST transmit or retransmit data and leave this state when all data in queue is transmitted.",
      "ja": "6）SHUTDOWN-RECEIVED状態で、エンドポイントは、データを送信または再送信キュー内のすべてのデータが送信されるときに、この状態のままにしなければなりません。"
    },
    {
      "indent": 3,
      "text": "7) In the SHUTDOWN-ACK-SENT state, the endpoint MUST NOT accept any new send requests from its SCTP user.",
      "ja": "7）SHUTDOWN-ACK-SENT状態では、エンドポイントは、そのSCTPユーザからの新しい送信要求を受け入れてはいけません。"
    },
    {
      "indent": 3,
      "text": "The CLOSED state is used to indicate that an association is not created (i.e., doesn't exist).",
      "ja": "CLOSED状態に関連（すなわち、存在していない）が作成されていないことを示すために使用されます。"
    },
    {
      "indent": 0,
      "text": "5. Association Initialization",
      "section_title": true,
      "ja": "5.協会の初期化"
    },
    {
      "indent": 3,
      "text": "Before the first data transmission can take place from one SCTP endpoint (\"A\") to another SCTP endpoint (\"Z\"), the two endpoints must complete an initialization process in order to set up an SCTP association between them.",
      "ja": "最初のデータ伝送が別のSCTPエンドポイント（「Z」）、1つのSCTPエンドポイント（「A」）から行うことができる前に、2つのエンドポイントは、それらの間のSCTPアソシエーションを設定するために初期化プロセスを完了しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The SCTP user at an endpoint should use the ASSOCIATE primitive to initialize an SCTP association to another SCTP endpoint.",
      "ja": "エンドポイントSCTPユーザは、別のSCTPエンドポイントにSCTPアソシエーションを初期化するためにプリミティブASSOCIATEを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: From an SCTP user's point of view, an association may be implicitly opened, without an ASSOCIATE primitive (see Section 10.1 B) being invoked, by the initiating endpoint's sending of the first user data to the destination endpoint. The initiating SCTP will assume default values for all mandatory and optional parameters for the INIT/INIT ACK.",
      "ja": "実装注：ビューのSCTPユーザの観点から、関連付けは暗黙プリミティブASSOCIATEことなく、開放することができる（セクション10.1 Bを参照）を開始するエンドポイントの宛先エンドポイントに最初のユーザデータを送信することによって、呼び出されます。開始SCTPはINIT / INIT ACKのためのすべての必須およびオプションパラメータのデフォルト値を仮定します。"
    },
    {
      "indent": 3,
      "text": "Once the association is established, unidirectional streams are open for data transfer on both ends (see Section 5.1.1).",
      "ja": "アソシエーションが確立されると、単方向ストリームは、両端でのデータ転送のために開いている（セクション5.1.1を参照）。"
    },
    {
      "indent": 0,
      "text": "5.1. Normal Establishment of an Association",
      "section_title": true,
      "ja": "5.1。協会の通常の設立"
    },
    {
      "indent": 3,
      "text": "The initialization process consists of the following steps (assuming that SCTP endpoint \"A\" tries to set up an association with SCTP endpoint \"Z\" and \"Z\" accepts the new association):",
      "ja": "初期化プロセスは、以下のステップ（SCTPエンドポイント「A」は、SCTP終点「Z」および「Z」との関連付けを設定しようとすると仮定すると、新しいアソシエーションを受け入れる）から構成されています。"
    },
    {
      "indent": 3,
      "text": "A) \"A\" first sends an INIT chunk to \"Z\". In the INIT, \"A\" must provide its Verification Tag (Tag_A) in the Initiate Tag field. Tag_A SHOULD be a random number in the range of 1 to 4294967295 (see Section 5.3.1 for Tag value selection). After sending the INIT, \"A\" starts the T1-init timer and enters the COOKIE-WAIT state.",
      "ja": "A） \"\" 第一 \"Z\" へINITチャンクを送信します。 INITでは、「」開始タグフィールドでの検証タグ（TAG_A）を提供しなければなりません。 TAG_A 1（タグ値の選択については、セクション5.3.1を参照）4294967295の範囲の乱数であるべきです。 INITを送った後、「」T1-INITタイマーを起動し、COOKIE-WAIT状態になります。"
    },
    {
      "indent": 3,
      "text": "B) \"Z\" shall respond immediately with an INIT ACK chunk. The destination IP address of the INIT ACK MUST be set to the source IP address of the INIT to which this INIT ACK is responding. In the response, besides filling in other parameters, \"Z\" must set the Verification Tag field to Tag_A, and also provide its own Verification Tag (Tag_Z) in the Initiate Tag field.",
      "ja": "B）「Z」はINIT ACKチャンクですぐに応答しなければなりません。 INIT ACKの送信先IPアドレスは、このINIT ACKが応答されたINITの送信元IPアドレスに設定しなければなりません。これに応答して、他のパラメータに記入に加え、「Z」TAG_Aに検証タグフィールドを設定し、また、開始タグフィールドに独自の検証タグ（Tag_Z）を提供しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Moreover, \"Z\" MUST generate and send along with the INIT ACK a State Cookie. See Section 5.1.3 for State Cookie generation.",
      "ja": "また、「Z」は、生成しINIT ACK州Cookieと共に送らなければなりません。州Cookieの生成については、セクション5.1.3を参照してください。"
    },
    {
      "indent": 6,
      "text": "Note: After sending out INIT ACK with the State Cookie parameter, \"Z\" MUST NOT allocate any resources or keep any states for the new association. Otherwise, \"Z\" will be vulnerable to resource attacks.",
      "ja": "注意：州CookieパラメタでINIT ACKを送信した後、「Z」は、任意のリソースを割り当ててはならないか、新しいアソシエーションを任意の状態を保ちます。それ以外の場合は、「Z」リソース攻撃に対して脆弱になります。"
    },
    {
      "indent": 3,
      "text": "C) Upon reception of the INIT ACK from \"Z\", \"A\" shall stop the T1- init timer and leave the COOKIE-WAIT state. \"A\" shall then send the State Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, start the T1-cookie timer, and enter the COOKIE-ECHOED state.",
      "ja": "「Z」からINIT ACKを受信すると、C）は、「」T1- INITタイマーを停止し、COOKIE-WAIT状態のままにしなければなりません。 「」その後、国家クッキーがCOOKIE ECHOチャンクでINIT ACKチャンクで受信し送信しなければならない、T1-クッキータイマーを開始し、COOKIE-ECHOED状態に入ります。"
    },
    {
      "indent": 6,
      "text": "Note: The COOKIE ECHO chunk can be bundled with any pending outbound DATA chunks, but it MUST be the first chunk in the packet and until the COOKIE ACK is returned the sender MUST NOT send any other packets to the peer.",
      "ja": "注：COOKIE ECHOチャンクは保留中のアウトバウンドDATAチャンクにバンドルすることができますが、それは、パケットの最初のチャンクでなければならないとCOOKIEのACKが返されるまで送信側がピアに他のパケットを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "D) Upon reception of the COOKIE ECHO chunk, endpoint \"Z\" will reply with a COOKIE ACK chunk after building a TCB and moving to the ESTABLISHED state. A COOKIE ACK chunk may be bundled with any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK chunk MUST be the first chunk in the packet.",
      "ja": "COOKIE ECHOチャンク、エンドポイント「Z」を受信すると、D）は、TCBを構築し、確立された状態に移動した後COOKIE A​​CK塊で応答します。 COOKIE A​​CK塊は、任意の保留データチャンク（および/またはSACKチャンク）にバンドルされてもよいが、COOKIE A​​CK塊は、パケット内の最初のチャンクでなければなりません。"
    },
    {
      "indent": 6,
      "text": "IMPLEMENTATION NOTE: An implementation may choose to send the Communication Up notification to the SCTP user upon reception of a valid COOKIE ECHO chunk.",
      "ja": "実装上の注意：実装は有効なCOOKIE ECHOチャンクの受信時にSCTPユーザにコミュニケーションアップ通知を送信することもできます。"
    },
    {
      "indent": 3,
      "text": "E) Upon reception of the COOKIE ACK, endpoint \"A\" will move from the COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1- cookie timer. It may also notify its ULP about the successful establishment of the association with a Communication Up notification (see Section 10).",
      "ja": "COOKIE A​​CKの受信、エンドポイント時にE）は、「」T1-クッキータイマを停止、ESTABLISHED状態にCOOKIE-ECHOED状態から移動します。また、コミュニケーションアップ通知との関連の成功設立についてそのULPに通知することができる（セクション10を参照）。"
    },
    {
      "indent": 3,
      "text": "An INIT or INIT ACK chunk MUST NOT be bundled with any other chunk. They MUST be the only chunks present in the SCTP packets that carry them.",
      "ja": "INITまたはINIT ACKチャンクは他のチャンクとバンドルしてはなりません。彼らはそれらを運ぶSCTPパケット中に存在する唯一のチャンクでなければなりません。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST send the INIT ACK to the IP address from which it received the INIT.",
      "ja": "エンドポイントは、それがINITを受け、そこからIPアドレスにINIT ACKを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: T1-init timer and T1-cookie timer shall follow the same rules given in Section 6.3.",
      "ja": "注：T1-INITタイマー及びT1-クッキータイマはセクション6.3で与えられた同じルールに従うものとします。"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives an INIT, INIT ACK, or COOKIE ECHO chunk but decides not to establish the new association due to missing mandatory parameters in the received INIT or INIT ACK, invalid parameter values, or lack of local resources, it SHOULD respond with an ABORT chunk. It SHOULD also specify the cause of abort, such as the type of the missing mandatory parameters, etc., by including the error cause parameters with the ABORT chunk. The Verification Tag field in the common header of the outbound SCTP packet containing the ABORT chunk MUST be set to the Initiate Tag value of the peer.",
      "ja": "エンドポイントは、INIT、INIT ACK、またはCOOKIE ECHOチャンクを受信するが、受信INITまたはINIT ACKで必須パラメータ、無効なパラメータ値、またはローカルリソースの不足が欠けによる新しいアソシエーションを確立しないことを決定し、それがで応答する必要がある場合チャンクを中止します。またABORTチャンクとエラー原因パラメータを含むことによって、など不足している必須パラメータの種類として、アボートの原因を指定する必要があります。 ABORTチャンクを含むアウトバウンドSCTPパケットの共通ヘッダに検証タグフィールドは、ピアの開始タグの値に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that a COOKIE ECHO chunk that does NOT pass the integrity check is NOT considered an 'invalid parameter' and requires special handling; see Section 5.1.5.",
      "ja": "整合性チェックに合格しないCOOKIE ECHOチャンクが「無効なパラメータ」とみなされ、特別な処理を必要としないことに注意してください。セクション5.1.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "After the reception of the first DATA chunk in an association the endpoint MUST immediately respond with a SACK to acknowledge the DATA chunk. Subsequent acknowledgements should be done as described in Section 6.2.",
      "ja": "協会の最初のデータチャンクの受信後にエンドポイントは、すぐにデータチャンクを確認するためにSACKで応じなければなりません。 6.2節で説明したように、その後の確認応答が行われるべきです。"
    },
    {
      "indent": 3,
      "text": "When the TCB is created, each endpoint MUST set its internal Cumulative TSN Ack Point to the value of its transmitted Initial TSN minus one.",
      "ja": "TCBが作成されると、各エンドポイントは、その送信初期TSNマイナス1の値にその内部の累積TSN Ackをポイントを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: The IP addresses and SCTP port are generally used as the key to find the TCB within an SCTP instance.",
      "ja": "実装上の注意：IPアドレスとSCTPポートは、一般的にSCTPインスタンス内でTCBを見つけるためのキーとして使用されています。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Handle Stream Parameters",
      "section_title": true,
      "ja": "5.1.1。ストリームのパラメータを扱います"
    },
    {
      "indent": 3,
      "text": "In the INIT and INIT ACK chunks, the sender of the chunk MUST indicate the number of outbound streams (OSs) it wishes to have in the association, as well as the maximum inbound streams (MISs) it will accept from the other endpoint.",
      "ja": "INITとINIT ACKチャンクは、チャンクの送信者は、それが他のエンドポイントから受け入れる関連を持っていることを望むだけでなく、最大のインバウンドストリーム（ミス）アウトバウンドストリーム（OSS）の数を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "After receiving the stream configuration information from the other side, each endpoint MUST perform the following check: If the peer's MIS is less than the endpoint's OS, meaning that the peer is incapable of supporting all the outbound streams the endpoint wants to configure, the endpoint MUST use MIS outbound streams and MAY report any shortage to the upper layer. The upper layer can then choose to abort the association if the resource shortage is unacceptable.",
      "ja": "他の側からのストリーム構成情報を受信した後、各エンドポイントは、次のチェックを実行しなければなりません：ピアのMISは、エンドポイントは、ピアがエンドポイントを設定したいすべての発信ストリームをサポートすることができないことを意味し、エンドポイントのOSよりも小さい場合MISアウトバウンド・ストリームを使用しなければならないし、上位層に任意の不足を報告することがあります。上層は、リソース不足が許容できない場合の関連付けを中止することを選択することができます。"
    },
    {
      "indent": 3,
      "text": "After the association is initialized, the valid outbound stream identifier range for either endpoint shall be 0 to min(local OS, remote MIS)-1.",
      "ja": "会合後、エンドポイントは分（ローカルOS、リモートMIS）-1 0でなければならないのいずれかの有効なアウトバウンドストリーム識別子の範囲を初期化されます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Handle Address Parameters",
      "section_title": true,
      "ja": "5.1.2。アドレスパラメータを扱います"
    },
    {
      "indent": 3,
      "text": "During the association initialization, an endpoint shall use the following rules to discover and collect the destination transport address(es) of its peer.",
      "ja": "関連の初期化中に、エンドポイントは発見とそのピアの宛先トランスポートアドレスを収集するために、以下の規則を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A) If there are no address parameters present in the received INIT or INIT ACK chunk, the endpoint shall take the source IP address from which the chunk arrives and record it, in combination with the SCTP source port number, as the only destination transport address for this peer.",
      "ja": "受信したINITまたはINIT ACKチャンクに存在しないアドレスのパラメータが存在しない場合A）、エンドポイントは、送信先トランスポートアドレスとして、SCTP送信元ポート番号との組合せで、チャンクが到着元のソースIPアドレスを取得し、それを記録しなければなりませんこのピアのために。"
    },
    {
      "indent": 3,
      "text": "B) If there is a Host Name parameter present in the received INIT or INIT ACK chunk, the endpoint shall resolve that host name to a list of IP address(es) and derive the transport address(es) of this peer by combining the resolved IP address(es) with the SCTP source port.",
      "ja": "受信INITまたはINIT ACKチャンクに存在するホスト名パラメータがある場合はB）、エンドポイントは、IPアドレス（複数可）のリストにそのホスト名を解決し、解決を組み合わせることにより、このピアのトランスポートアドレス（複数可）を導出するものSCTPソースポートとIPアドレス（複数可）。"
    },
    {
      "indent": 6,
      "text": "The endpoint MUST ignore any other IP Address parameters if they are also present in the received INIT or INIT ACK chunk.",
      "ja": "彼らはまた、受信したINITまたはINIT ACKチャンクに存在している場合、エンドポイントは、他のIPアドレスのパラメータを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The time at which the receiver of an INIT resolves the host name has potential security implications to SCTP. If the receiver of an INIT resolves the host name upon the reception of the chunk, and the mechanism the receiver uses to resolve the host name involves potential long delay (e.g., DNS query), the receiver may open itself up to resource attacks for the period of time while it is waiting for the name resolution results before it can build the State Cookie and release local resources.",
      "ja": "INITの受信者は、ホスト名を解決する時間は、SCTPへの潜在的なセキュリティ上の意味を持ちます。 INITの受信機は、チャンクの受信時にホスト名を解決し、受信機は、ホスト名を解決するために使用するメカニズムは、潜在的な長時間の遅延（例えば、DNSクエリ）を含み、受信機は、のために攻撃を資源に自分自身を開く可能性がある場合それは国家クッキーを構築し、ローカルリソースを解放することができます前に、それは名前解決の結果を待っている期間。"
    },
    {
      "indent": 6,
      "text": "Therefore, in cases where the name translation involves potential long delay, the receiver of the INIT MUST postpone the name resolution till the reception of the COOKIE ECHO chunk from the peer. In such a case, the receiver of the INIT SHOULD build the State Cookie using the received Host Name (instead of destination transport addresses) and send the INIT ACK to the source IP address from which the INIT was received.",
      "ja": "したがって、名前変換は、潜在的に長い遅延を伴う場合には、INITの受信ピアからCOOKIE ECHOチャンクの受信までの名前解決を延期しなければなりません。このような場合には、（代わりに送付先輸送アドレスの）受信したホスト名を使用して状態クッキーを構築する必要がありINITの受信機とは、INITが受信された送信元IPアドレスにINIT ACKを送信します。"
    },
    {
      "indent": 6,
      "text": "The receiver of an INIT ACK shall always immediately attempt to resolve the name upon the reception of the chunk.",
      "ja": "INIT ACKの受信機は、常にすぐにチャンクを受信すると、名前を解決しようとするもの。"
    },
    {
      "indent": 6,
      "text": "The receiver of the INIT or INIT ACK MUST NOT send user data (piggy-backed or stand-alone) to its peer until the host name is successfully resolved.",
      "ja": "ホスト名が正常に解決されるまで、INITまたはINIT ACKの受信機は、そのピアに（ピギーバックまたはスタンドアロン）のユーザデータを送ってはいけません。"
    },
    {
      "indent": 6,
      "text": "If the name resolution is not successful, the endpoint MUST immediately send an ABORT with \"Unresolvable Address\" error cause to its peer. The ABORT shall be sent to the source IP address from which the last peer packet was received.",
      "ja": "名前解決が成功しなかった場合、エンドポイントは、すぐにそのピアに「解決できないアドレス」エラーの原因とABORTを送らなければなりません。 ABORTは最後のピア・パケットが受信された送信元のIPアドレスに送信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "C) If there are only IPv4/IPv6 addresses present in the received INIT or INIT ACK chunk, the receiver MUST derive and record all the transport addresses from the received chunk AND the source IP address that sent the INIT or INIT ACK. The transport addresses are derived by the combination of SCTP source port (from the common header) and the IP Address parameter(s) carried in the INIT or INIT ACK chunk and the source IP address of the IP datagram. The receiver should use only these transport addresses as destination transport addresses when sending subsequent packets to its peer.",
      "ja": "C）のみのIPv4 / IPv6が受信INITあるいはINIT ACKチャンクに存在するアドレスがある場合、受信機は、導出し、受信したチャンクとINITまたはINIT ACKを送信した送信元IPアドレスからのすべてのトランスポートアドレスを記録しなければなりません。トランスポート・アドレスは、（共通ヘッダから）SCTP送信元ポートの組み合わせとINITあるいはINIT ACKチャンクとIPデータグラムの送信元IPアドレスで運ばれるIPアドレスパラメータ（単数または複数）によって導出されます。ピアへの後続のパケットを送信するとき、受信機は、送信先トランスポートアドレスとしてのみ、これらのトランスポート・アドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "D) An INIT or INIT ACK chunk MUST be treated as belonging to an already established association (or one in the process of being established) if the use of any of the valid address parameters contained within the chunk would identify an existing TCB.",
      "ja": "D）INITあるいはINIT ACKチャンクは、チャンク内に含まれる有効なアドレス・パラメータのいずれかの使用は、既存のTCBを識別するならば）確立の過程において既に確立されたアソシエーション（または1つに属するものとして扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In some cases (e.g., when the implementation doesn't control the source IP address that is used for transmitting), an endpoint might need to include in its INIT or INIT ACK all possible IP addresses from which packets to the peer could be transmitted.",
      "ja": "実装上の注意：いくつかのケースでは（例えば、実装は送信するために使用されている送信元IPアドレスを管理していない場合）、エンドポイントはそのINITまたはINIT ACKにどのパケットからピアに可能なすべてのIPアドレスを含める必要があります可能性があり送信すること。"
    },
    {
      "indent": 3,
      "text": "After all transport addresses are derived from the INIT or INIT ACK chunk using the above rules, the endpoint shall select one of the transport addresses as the initial primary path.",
      "ja": "すべてのトランスポートアドレスが上記の規則を使用して、INITまたはINIT ACKチャンクから誘導された後、エンドポイントは初期主要パスとして転送アドレスのいずれかを選択しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: The INIT ACK MUST be sent to the source address of the INIT.",
      "ja": "注意：INIT ACKはINITの送信元アドレスに送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sender of INIT may include a 'Supported Address Types' parameter in the INIT to indicate what types of address are acceptable. When this parameter is present, the receiver of INIT (initiate) MUST either use one of the address types indicated in the Supported Address Types parameter when responding to the INIT, or abort the association with an \"Unresolvable Address\" error cause if it is unwilling or incapable of using any of the address types indicated by its peer.",
      "ja": "INITの送信者は、許容されるどのようなアドレスの種類を示すために、INITの「サポートされているアドレス型」パラメータを含むことができます。このパラメータが存在する場合、INIT（初期化）の受信機は、INITに応答するときにサポートされるアドレスタイプパラメータで示されるアドレスのタイプのいずれかを使用しなければならないか、それが不本意である場合、「解決不能アドレス」エラー原因との関連付けを中止しますまたはそのピアによって示されるアドレスのタイプのいずれかを使用することができません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In the case that the receiver of an INIT ACK fails to resolve the address parameter due to an unsupported type, it can abort the initiation process and then attempt a reinitiation by using a 'Supported Address Types' parameter in the new INIT to indicate what types of address it prefers.",
      "ja": "実装上の注意：INIT ACKの受信機が原因サポートされていないタイプのアドレスパラメータを解決するために失敗した場合は、開始プロセスを中止することができ、その後に新しいINITに「サポートされているアドレス型」パラメータを使用して再開を試みますそれは好むアドレスの種類を示しています。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: If an SCTP endpoint that only supports either IPv4 or IPv6 receives IPv4 and IPv6 addresses in an INIT or INIT ACK chunk from its peer, it MUST use all the addresses belonging to the supported address family. The other addresses MAY be ignored. The endpoint SHOULD NOT respond with any kind of error indication.",
      "ja": "実装上の注意：のみIPv4またはIPv6のいずれかをサポートしているSCTP終点はそのピアからのINITまたはINIT ACKチャンクでIPv4アドレスとIPv6アドレスを受信した場合、それがサポートされるアドレスファミリに属する​​すべてのアドレスを使用しなければなりません。他のアドレスは無視してもよいです。エンドポイントは、エラー表示のいずれかの種類に応答すべきでありません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: If an SCTP endpoint lists in the 'Supported Address Types' parameter either IPv4 or IPv6, but uses the other family for sending the packet containing the INIT chunk, or if it also lists addresses of the other family in the INIT chunk, then the address family that is not listed in the 'Supported Address Types' parameter SHOULD also be considered as supported by the receiver of the INIT chunk. The receiver of the INIT chunk SHOULD NOT respond with any kind of error indication.",
      "ja": "実装上の注意：「サポートされているアドレス型」パラメータIPv4またはIPv6のいずれかでSCTP終点リストがなく、INITチャンクを含むパケットを送信するために他の家族が使用している場合、またはそれはまた、INITチャンクに他の家族のアドレスをリストした場合、 INITチャンクの受信機でサポートされているとして、その後「サポートされているアドレス型」パラメータにリストされていないアドレスファミリも考慮すべきです。 INITチャンクの受信機は、エラー表示のいずれかの種類に応答すべきでありません。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Generating State Cookie",
      "section_title": true,
      "ja": "5.1.3。生成状態クッキー"
    },
    {
      "indent": 3,
      "text": "When sending an INIT ACK as a response to an INIT chunk, the sender of INIT ACK creates a State Cookie and sends it in the State Cookie parameter of the INIT ACK. Inside this State Cookie, the sender should include a MAC (see [RFC2104] for an example), a timestamp on when the State Cookie is created, and the lifespan of the State Cookie, along with all the information necessary for it to establish the association.",
      "ja": "INITチャンクへの応答としてINIT ACKを送信する場合、INIT ACKの送信者は、国家クッキーを作成し、INIT ACKの州Cookieパラメタでそれを送信します。この状態クッキーの中に、送信者は、それが確立するために必要なすべての情報とともに、MAC（例えば、[RFC2104]を参照）、国家クッキーが作成されたときのタイムスタンプ、および国家クッキーの寿命を含める必要があります協会。"
    },
    {
      "indent": 3,
      "text": "The following steps SHOULD be taken to generate the State Cookie:",
      "ja": "次の手順は、国家クッキーを生成するために取られるべきです："
    },
    {
      "indent": 3,
      "text": "1) Create an association TCB using information from both the received INIT and the outgoing INIT ACK chunk,",
      "ja": "1）受信したINITと発信INIT ACKチャンクの両方からの情報を使用して関連TCBを作成し、"
    },
    {
      "indent": 3,
      "text": "2) In the TCB, set the creation time to the current time of day, and the lifespan to the protocol parameter 'Valid.Cookie.Life' (see Section 15),",
      "ja": "2）TCBで、（セクション15を参照）現在時刻、及びプロトコルパラメータ「Valid.Cookie.Life」の寿命を作成時刻を設定し、"
    },
    {
      "indent": 3,
      "text": "3) From the TCB, identify and collect the minimal subset of information needed to re-create the TCB, and generate a MAC using this subset of information and a secret key (see [RFC2104] for an example of generating a MAC), and",
      "ja": "3）TCBから、識別及びTCBを再作成するために必要な情報の最小のサブセットを収集し、この情報のサブセットと秘密鍵を用いてMACを生成し（MAC）を生成する、例えば、[RFC2104]を参照、及び"
    },
    {
      "indent": 3,
      "text": "4) Generate the State Cookie by combining this subset of information and the resultant MAC.",
      "ja": "4）この情報のサブセットと、得られたMACを組み合わせることにより、状態クッキーを生成します。"
    },
    {
      "indent": 3,
      "text": "After sending the INIT ACK with the State Cookie parameter, the sender SHOULD delete the TCB and any other local resource related to the new association, so as to prevent resource attacks.",
      "ja": "リソース攻撃を防止するために、州CookieパラメタでINIT ACKを送った後、送信者は、TCBと新しいアソシエーションに関連する他のローカルリソースを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "The hashing method used to generate the MAC is strictly a private matter for the receiver of the INIT chunk. The use of a MAC is mandatory to prevent denial-of-service attacks. The secret key SHOULD be random ([RFC4086] provides some information on randomness guidelines); it SHOULD be changed reasonably frequently, and the timestamp in the State Cookie MAY be used to determine which key should be used to verify the MAC.",
      "ja": "MACを生成するために使用されるハッシュ方式は、厳密にはINITチャンクの受信機のための個人的な問題です。 MACの使用は、サービス拒否攻撃を防ぐために必須です。秘密鍵はランダムであるべきである（[RFC4086]はランダム性のガイドラインについていくつかの情報を提供します）。それが合理的に頻繁に変更されるべきであり、国家クッキーのタイムスタンプは、MACを検証するために使用されるべきキーを決定するために使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD make the cookie as small as possible to ensure interoperability.",
      "ja": "実装は、相互運用性を確保することができるようクッキーは限り小さくすべきです。"
    },
    {
      "indent": 0,
      "text": "5.1.4. State Cookie Processing",
      "section_title": true,
      "ja": "5.1.4。状態クッキー処理"
    },
    {
      "indent": 3,
      "text": "When an endpoint (in the COOKIE-WAIT state) receives an INIT ACK chunk with a State Cookie parameter, it MUST immediately send a COOKIE ECHO chunk to its peer with the received State Cookie. The sender MAY also add any pending DATA chunks to the packet after the COOKIE ECHO chunk.",
      "ja": "（COOKIE-WAIT状態）エンドポイントが状態クッキーパラメータとINIT ACKチャンクを受信すると、それは即座に受信した状態クッキーとのピアにCOOKIE ECHOチャンクを送信しなければなりません。送信者はまた、COOKIE ECHOチャンクの後にパケットに保留中のDATAチャンクを追加するかもしれません。"
    },
    {
      "indent": 3,
      "text": "The endpoint shall also start the T1-cookie timer after sending out the COOKIE ECHO chunk. If the timer expires, the endpoint shall retransmit the COOKIE ECHO chunk and restart the T1-cookie timer. This is repeated until either a COOKIE ACK is received or 'Max.Init.Retransmits' (see Section 15) is reached causing the peer endpoint to be marked unreachable (and thus the association enters the CLOSED state).",
      "ja": "エンドポイントはまた、COOKIE ECHOチャンクを送信した後、T1-クッキータイマーをスタートします。タイマーが期限切れになった場合、エンドポイントは、COOKIE ECHOチャンクを再送信し、T1-クッキータイマを再スタートするものとします。クッキーACKのいずれかが受信されたか「Max.Init.Retransmits」は（セクション15を参照）ピアエンドポイントが（したがって関連が閉状態になる）到達不能とマークさせる達するまでこれが繰り返されます。"
    },
    {
      "indent": 0,
      "text": "5.1.5. State Cookie Authentication",
      "section_title": true,
      "ja": "5.1.5。州Cookie認証"
    },
    {
      "indent": 3,
      "text": "When an endpoint receives a COOKIE ECHO chunk from another endpoint with which it has no association, it shall take the following actions:",
      "ja": "エンドポイントが、それは何の関連性を持たないと、別のエンドポイントからCOOKIE ECHOチャンクを受信すると、次のアクションをとります。"
    },
    {
      "indent": 3,
      "text": "1) Compute a MAC using the TCB data carried in the State Cookie and the secret key (note the timestamp in the State Cookie MAY be used to determine which secret key to use). [RFC2104] can be used as a guideline for generating the MAC,",
      "ja": "1）州Cookieで運ばTCBデータと秘密鍵を（注意状態クッキーのタイムスタンプが使用する秘密鍵どの決定することができる）を使用してMACを計算します。 [RFC2104]は、MACを生成するための指針として使用することができます"
    },
    {
      "indent": 3,
      "text": "2) Authenticate the State Cookie as one that it previously generated by comparing the computed MAC against the one carried in the State Cookie. If this comparison fails, the SCTP packet, including the COOKIE ECHO and any DATA chunks, should be silently discarded,",
      "ja": "2）それは、以前州Cookieで運ば1に対して計算されたMACとを比較することによって生成されたものと州Cookieを認証。この比較が失敗した場合、COOKIE ECHOとどんなDATAチャンクを含むSCTPパケットは、黙って破棄しなければなりません、"
    },
    {
      "indent": 3,
      "text": "3) Compare the port numbers and the Verification Tag contained within the COOKIE ECHO chunk to the actual port numbers and the Verification Tag within the SCTP common header of the received packet. If these values do not match, the packet MUST be silently discarded.",
      "ja": "3）受信したパケットのSCTP共通ヘッダ内の実際のポート番号と検証タグにCOOKIE ECHOチャンク内に含まれるポート番号と検証タグを比較します。これらの値が一致しない場合、パケットは静かに捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "4) Compare the creation timestamp in the State Cookie to the current local time. If the elapsed time is longer than the lifespan carried in the State Cookie, then the packet, including the COOKIE ECHO and any attached DATA chunks, SHOULD be discarded, and the endpoint MUST transmit an ERROR chunk with a \"Stale Cookie\" error cause to the peer endpoint.",
      "ja": "4）現在のローカル時刻に状態クッキー内の作成タイムスタンプを比較してください。経過時間が長い状態クッキーに運ば寿命を超える場合は、COOKIE ECHOと接続されているすべてのDATA塊を含むパケットは、廃棄すべき、およびエンドポイントは、「古いクッキー」エラー原因とERRORチャンクを伝えなければなりませんピアエンドポイント。"
    },
    {
      "indent": 3,
      "text": "5) If the State Cookie is valid, create an association to the sender of the COOKIE ECHO chunk with the information in the TCB data carried in the COOKIE ECHO and enter the ESTABLISHED state.",
      "ja": "国家クッキーが有効であれば5）、COOKIE ECHOで運ばTCBデータに情報をCOOKIE ECHOチャンクの送信者に関連付けを作成し、ESTABLISHED状態に入ります。"
    },
    {
      "indent": 3,
      "text": "6) Send a COOKIE ACK chunk to the peer acknowledging receipt of the COOKIE ECHO. The COOKIE ACK MAY be bundled with an outbound DATA chunk or SACK chunk; however, the COOKIE ACK MUST be the first chunk in the SCTP packet.",
      "ja": "6）COOKIE ECHOの受信を確認ピアにCOOKIE A​​CKチャンクを送信します。 COOKIE A​​CKは、アウトバウンドのDATAチャンクまたはSACKチャンクにバンドルすることができ、しかし、COOKIE A​​CKは、SCTPパケット内の最初のチャンクでなければなりません。"
    },
    {
      "indent": 3,
      "text": "7) Immediately acknowledge any DATA chunk bundled with the COOKIE ECHO with a SACK (subsequent DATA chunk acknowledgement should follow the rules defined in Section 6.2). As mentioned in step 6, if the SACK is bundled with the COOKIE ACK, the COOKIE ACK MUST appear first in the SCTP packet.",
      "ja": "7）直後（次のデータチャンク応答）はセクション6.2で定義された規則に従うべきであるSACKとCOOKIE ECHOにバンドルされ、任意のデータチャンクを認めます。ステップ6で述べたようにSACKをCOOKIE A​​CKにバンドルされている場合、COOKIE A​​CKはSCTPパケット内の最初に表示されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a COOKIE ECHO is received from an endpoint with which the receiver of the COOKIE ECHO has an existing association, the procedures in Section 5.2 should be followed.",
      "ja": "COOKIE ECHOはCOOKIE ECHOの受信機は、既存の関連付けを有するとエンドポイントから受信した場合、5.2節の手順に従うべきです。"
    },
    {
      "indent": 0,
      "text": "5.1.6. An Example of Normal Association Establishment",
      "section_title": true,
      "ja": "5.1.6。通常の協会設立の例"
    },
    {
      "indent": 3,
      "text": "In the following example, \"A\" initiates the association and then sends a user message to \"Z\", then \"Z\" sends two user messages to \"A\" later (assuming no bundling or fragmentation occurs):",
      "ja": "次の例では、「」会合を開始した後、「Z」へのユーザメッセージを送信し、その後、「Z」は、後に（なしバンドルまたはフラグメンテーション発生を想定していない）「A」への2つのユーザ・メッセージを送信します。"
    },
    {
      "indent": 4,
      "text": "Endpoint A                                          Endpoint Z\n{app sets association with Z}\n(build TCB)\nINIT [I-Tag=Tag_A\n      & other info]  ------\\\n(Start T1-init timer)       \\\n(Enter COOKIE-WAIT state)    \\---> (compose temp TCB and Cookie_Z)\n                                /-- INIT ACK [Veri Tag=Tag_A,\n                               /             I-Tag=Tag_Z,\n(Cancel T1-init timer) <------/              Cookie_Z, & other info]\n                                     (destroy temp TCB)\nCOOKIE ECHO [Cookie_Z] ------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-ECHOED state)    \\---> (build TCB enter ESTABLISHED\n                                      state)\n                               /---- COOKIE-ACK\n                              /\n(Cancel T1-init timer, <-----/\n Enter ESTABLISHED state)\n{app sends 1st user data; strm 0}\nDATA [TSN=initial TSN_A\n    Strm=0,Seq=0 & user data]--\\\n(Start T3-rtx timer)            \\\n                                 \\->\n                               /----- SACK [TSN Ack=init\n                              /           TSN_A,Block=0]\n(Cancel T3-rtx timer) <------/\n                                      ...\n                                     {app sends 2 messages;strm 0}\n                               /---- DATA\n                              /        [TSN=init TSN_Z\n                          <--/          Strm=0,Seq=0 & user data 1]\nSACK [TSN Ack=init TSN_Z,      /---- DATA\n      Block=0]     --------\\  /        [TSN=init TSN_Z +1,\n                            \\/          Strm=0,Seq=1 & user data 2]\n                     <------/\\\n                              \\\n                               \\------>",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 4: INITIATION Example",
      "ja": "図4は開始例"
    },
    {
      "indent": 3,
      "text": "If the T1-init timer expires at \"A\" after the INIT or COOKIE ECHO chunks are sent, the same INIT or COOKIE ECHO chunk with the same Initiate Tag (i.e., Tag_A) or State Cookie shall be retransmitted and the timer restarted. This shall be repeated Max.Init.Retransmits times before \"A\" considers \"Z\" unreachable and reports the failure to its upper layer (and thus the association enters the CLOSED state).",
      "ja": "T1-INITタイマーが「A」で有効期限が切れるとINITまたはCOOKIE ECHOチャンクが送信された後、同じと同じINITまたはCOOKIE ECHOチャンクはタグを開始します（つまり、TAG_A）または状態クッキーが再送されなければならないとタイマーが再スタート。これは、その上位層に「」考える「Z」到達不能と報告故障前Max.Init.Retransmits回繰り返さなければならない（従って、関連付けは、CLOSED状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "When retransmitting the INIT, the endpoint MUST follow the rules defined in Section 6.3 to determine the proper timer value.",
      "ja": "INITを再送する場合、エンドポイントは、適切なタイマ値を決定するために、セクション6.3で定義されたルールに従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2. Handle Duplicate or Unexpected INIT, INIT ACK, COOKIE ECHO, and COOKIE ACK",
      "ja": "5.2。重複や予期しないINIT、INIT ACK、COOKIE ECHO、およびCOOKIE A​​CKを扱います"
    },
    {
      "indent": 3,
      "text": "During the life time of an association (in one of the possible states), an endpoint may receive from its peer endpoint one of the setup chunks (INIT, INIT ACK, COOKIE ECHO, and COOKIE ACK). The receiver shall treat such a setup chunk as a duplicate and process it as described in this section.",
      "ja": "（可能な状態のいずれかで）関連のライフタイムの間に、エンドポイントは、ピアエンドポイントからセットアップチャンク（INIT、INIT ACK、COOKIE ECHOおよびCOOKIE A​​CK）のいずれかを受け取ることができます。受信機は、重複するようなセットアップチャンクを治療し、このセクションで説明するように、それを処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: An endpoint will not receive the chunk unless the chunk was sent to an SCTP transport address and is from an SCTP transport address associated with this endpoint. Therefore, the endpoint processes such a chunk as part of its current association.",
      "ja": "注意：チャンクはSCTP輸送アドレスに送信され、このエンドポイントに関連付けられているSCTP輸送アドレスからでていない限り、エンドポイントがチャンクを受信しません。したがって、エンドポイントは、その現在のアソシエーションの一部としてそのようなチャンクを処理します。"
    },
    {
      "indent": 3,
      "text": "The following scenarios can cause duplicated or unexpected chunks:",
      "ja": "次のシナリオは、重複や予期しないチャンクを引き起こす可能性があります："
    },
    {
      "indent": 3,
      "text": "A) The peer has crashed without being detected, restarted itself, and sent out a new INIT chunk trying to restore the association,",
      "ja": "A）ピアは、それ自体を再起動し、関連付けを復元しようとする新しいINITチャンクを送出し、検出されることなくクラッシュしました"
    },
    {
      "indent": 3,
      "text": "B) Both sides are trying to initialize the association at about the same time,",
      "ja": "B）双方は、ほぼ同時にアソシエーションを初期化しようとしています、"
    },
    {
      "indent": 3,
      "text": "C) The chunk is from a stale packet that was used to establish the present association or a past association that is no longer in existence,",
      "ja": "C）チャンクは、本会合または存在しなくなった過去の関連付けを確立するために使用された失効パケットからのものです"
    },
    {
      "indent": 3,
      "text": "D) The chunk is a false packet generated by an attacker, or",
      "ja": "D）チャンクは、攻撃者によって生成された偽のパケットであるか、または"
    },
    {
      "indent": 3,
      "text": "E) The peer never received the COOKIE ACK and is retransmitting its COOKIE ECHO.",
      "ja": "E）ピアはCOOKIE A​​CKを受信して​​いないし、そのCOOKIE ECHOを再送されません。"
    },
    {
      "indent": 3,
      "text": "The rules in the following sections shall be applied in order to identify and correctly handle these cases.",
      "ja": "次のセクションでのルールは、これらの例を識別し、正しく処理するために適用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.1. INIT Received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)",
      "section_title": true,
      "ja": "5.2.1。 INITは、COOKIE-WAITまたはCOOKIE-エコー状態（商品B）で受信しました"
    },
    {
      "indent": 3,
      "text": "This usually indicates an initialization collision, i.e., each endpoint is attempting, at about the same time, to establish an association with the other endpoint.",
      "ja": "これは、通常、他のエンドポイントとのアソシエーションを確立するために、初期化の衝突、すなわち、各エンドポイントは、ほぼ同時に、試みていることを示します。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an INIT in the COOKIE-WAIT state, an endpoint MUST respond with an INIT ACK using the same parameters it sent in its original INIT chunk (including its Initiate Tag, unchanged). When responding, the endpoint MUST send the INIT ACK back to the same address that the original INIT (sent by this endpoint) was sent.",
      "ja": "COOKIE-WAIT状態でINITを受信すると、エンドポイントは、（変化しない、その開始タグを含む）は、元のINITチャンクで送信され、同じパラメータを使用してINITのACKで応答しなければなりません。応答する場合、エンドポイントは（このエンドポイントによって送信された）オリジナルのINITが送られたのと同じアドレスに戻すINIT ACKを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an INIT in the COOKIE-ECHOED state, an endpoint MUST respond with an INIT ACK using the same parameters it sent in its original INIT chunk (including its Initiate Tag, unchanged), provided that no NEW address has been added to the forming association. If the INIT message indicates that a new address has been added to the association, then the entire INIT MUST be discarded, and NO changes should be made to the existing association. An ABORT SHOULD be sent in response that MAY include the error 'Restart of an association with new addresses'. The error SHOULD list the addresses that were added to the restarting association.",
      "ja": "COOKIE-ECHOED状態におけるINITを受信すると、エンドポイントは、新しいアドレスが追加されていないことを条件とする、（不変の、その開始タグを含む）は、元のINITチャンクで送信され、同じパラメータを使用してINITのACKで応答しなければなりません関連付けを形成します。 INITメッセージは、新しいアドレスが関連付けに追加されたことを示す場合、全体INITは捨てなければなりません、及び変更は、既存の関連付けに対してなされるべきではありません。 ABORTはエラー「新しいアドレスとの関連付けの再起動」を含めてもよい対応して送ってください。エラーが再開協会に追加されたアドレスをリストする必要があります。"
    },
    {
      "indent": 3,
      "text": "When responding in either state (COOKIE-WAIT or COOKIE-ECHOED) with an INIT ACK, the original parameters are combined with those from the newly received INIT chunk. The endpoint shall also generate a State Cookie with the INIT ACK. The endpoint uses the parameters sent in its INIT to calculate the State Cookie.",
      "ja": "INIT ACKのいずれかの状態（COOKIE-WAITまたはCOOKIE-エコー）で応答する場合、元のパラメータは、新たに受信したINITチャンクからのものと組み合わされます。エンドポイントはまた、INIT ACKと状態クッキーを生成しなければなりません。エンドポイントは状態クッキーを計算するために、そのINITに送信されたパラメータを使用しています。"
    },
    {
      "indent": 3,
      "text": "After that, the endpoint MUST NOT change its state, the T1-init timer shall be left running, and the corresponding TCB MUST NOT be destroyed. The normal procedures for handling State Cookies when a TCB exists will resolve the duplicate INITs to a single association.",
      "ja": "エンドポイントがその状態を変更してはならないことをした後、T1-INITタイマーが実行中のままにされなければならない、と対応するTCBは破壊されてはなりません。 TCBが存在するときの状態クッキーを処理するための通常の手順は、単一の協会に複製のINIT解決されます。"
    },
    {
      "indent": 3,
      "text": "For an endpoint that is in the COOKIE-ECHOED state, it MUST populate its Tie-Tags within both the association TCB and inside the State Cookie (see Section 5.2.2 for a description of the Tie-Tags).",
      "ja": "COOKIE-ECHOED状態にあるエンドポイントのために、両方のアソシエーションTCB内および州Cookie（TIE-タグの説明については、セクション5.2.2を参照）の内部にそのタイタグを移入する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED, COOKIE-WAIT, and SHUTDOWN-ACK-SENT",
      "ja": "5.2.2。 CLOSEDより米国その他の予期しないINIT、COOKIE-ECHOED、COOKIE-WAIT、及びSHUTDOWN-ACK-SENT"
    },
    {
      "indent": 3,
      "text": "Unless otherwise stated, upon receipt of an unexpected INIT for this association, the endpoint shall generate an INIT ACK with a State Cookie. Before responding, the endpoint MUST check to see if the unexpected INIT adds new addresses to the association. If new addresses are added to the association, the endpoint MUST respond with an ABORT, copying the 'Initiate Tag' of the unexpected INIT into the 'Verification Tag' of the outbound packet carrying the ABORT. In the ABORT response, the cause of error MAY be set to 'restart of an association with new addresses'. The error SHOULD list the addresses that were added to the restarting association. If no new addresses are added, when responding to the INIT in the outbound INIT ACK, the endpoint MUST copy its current Tie-Tags to a reserved place within the State Cookie and the association's TCB. We shall refer to these locations inside the cookie as the Peer's-Tie-Tag and the Local-Tie-Tag. We will refer to the copy within an association's TCB as the Local Tag and Peer's Tag. The outbound SCTP packet containing this INIT ACK MUST carry a Verification Tag value equal to the Initiate Tag found in the unexpected INIT. And the INIT ACK MUST contain a new Initiate Tag (randomly generated; see Section 5.3.1). Other parameters for the endpoint SHOULD be copied from the existing parameters of the association (e.g., number of outbound streams) into the INIT ACK and cookie.",
      "ja": "特に明記しない限り、この関連付けのための予想外のINITの受信時に、エンドポイントは、国家クッキーとINIT ACKを生成するものとします。応答する前に、エンドポイントは、予想外のINITが協会に新しいアドレスを追加するかどうかを確認するためにチェックしなければなりません。新しいアドレスが関連付けに追加された場合、エンドポイントはABORTを運ぶアウトバウンドパケットの「検証タグ」内に予想外のINITの「タグを開始」コピー、ABORTで応じなければなりません。 ABORT応答では、エラーの原因は、「新しいアドレスとの関連付けの再起動」に設定されるかもしれません。エラーが再開協会に追加されたアドレスをリストする必要があります。新しいアドレスが追加されていない場合、アウトバウンドのINIT ACKにINITに応答するときに、エンドポイントは国家Cookieと協会のTCB内の予約済みの場所に現在のタイのタグをコピーしなければなりません。我々はPeer's-タイタグとローカル・タイタグとしてクッキー内のこれらの場所を指すものとします。私たちは、ローカルタグとピアのタグとして協会のTCB内のコピーを参照します。このINIT ACKを含むアウトバウンドSCTPパケットは、予期せぬINITで見つかった開始タグに等しい検証タグ値を運ばなければなりません。そして、INIT ACKは、新しい開始タグが含まれなければならない（ランダムに生成し、5.3.1項を参照してください）。エンドポイントの他のパラメータはINIT ACKとクッキーに関連（例えば、アウトバウンドストリーム数）の既存のパラメータからコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "After sending out the INIT ACK or ABORT, the endpoint shall take no further actions; i.e., the existing association, including its current state, and the corresponding TCB MUST NOT be changed.",
      "ja": "INIT ACKまたはABORTを送信した後、エンドポイントはこれ以上行動を取らないものとします。即ち、その現在の状態を含む既存の関連付け、および対応するTCBを変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "Note: Only when a TCB exists and the association is not in a COOKIE-WAIT or SHUTDOWN-ACK-SENT state are the Tie-Tags populated with a value other than 0. For a normal association INIT (i.e., the endpoint is in the CLOSED state), the Tie-Tags MUST be set to 0 (indicating that no previous TCB existed).",
      "ja": "注：TCBが存在し、アソシエーションがCOOKIE-WAITまたはSHUTDOWN-ACK-SENT状態にない場合にのみ通常関連INITについて0以外の値で埋めタイタグである（すなわち、エンドポイントでありますCLOSED状態）、タイタグ）以前のTCBが存在しないことを示している（0に設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Unexpected INIT ACK",
      "section_title": true,
      "ja": "5.2.3。予期しないINIT ACK"
    },
    {
      "indent": 3,
      "text": "If an INIT ACK is received by an endpoint in any state other than the COOKIE-WAIT state, the endpoint should discard the INIT ACK chunk. An unexpected INIT ACK usually indicates the processing of an old or duplicated INIT chunk.",
      "ja": "INIT ACKがCOOKIE-WAIT状態以外の状態でエンドポイントによって受信された場合、エンドポイントは、INIT ACKチャンクを破棄しなければなりません。予想外のINIT ACKは通常、古いまたは複製INITチャンクの処理を示しています。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Handle a COOKIE ECHO when a TCB Exists",
      "section_title": true,
      "ja": "5.2.4。 TCBが存在する場合にCOOKIE ECHOを扱います"
    },
    {
      "indent": 3,
      "text": "When a COOKIE ECHO chunk is received by an endpoint in any state for an existing association (i.e., not in the CLOSED state) the following rules shall be applied:",
      "ja": "COOKIE ECHOチャンク（すなわち、しない閉じた状態で）既存の関連付けのための任意の状態でエンドポイントによって受信される場合、以下の規則が適用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "1) Compute a MAC as described in step 1 of Section 5.1.5,",
      "ja": "セクション5.1.5のステップ1で説明したように1）、MACを計算します"
    },
    {
      "indent": 3,
      "text": "2) Authenticate the State Cookie as described in step 2 of Section 5.1.5 (this is case C or D above).",
      "ja": "セクション5.1.5のステップ2に記載したように2）（これは場合Cまたは上記Dである）州Cookieを認証。"
    },
    {
      "indent": 3,
      "text": "3) Compare the timestamp in the State Cookie to the current time. If the State Cookie is older than the lifespan carried in the State Cookie and the Verification Tags contained in the State Cookie do not match the current association's Verification Tags, the packet, including the COOKIE ECHO and any DATA chunks, should be discarded. The endpoint also MUST transmit an ERROR chunk with a \"Stale Cookie\" error cause to the peer endpoint (this is case C or D in Section 5.2).",
      "ja": "3）現在の時間に状態クッキーのタイムスタンプを比較してください。国家クッキーは現在のアソシエーションの検証タグと一致しない状態クッキーに含まれる国家クッキーと検証タグで運ばれた寿命よりも古い場合、COOKIE ECHOとどんなDATAチャンクを含むパケットは、破棄されなければなりません。エンドポイントは、（これはセクション5.2の場合CまたはDである）ピアエンドポイントに「古いクッキー」エラー原因でERRORチャンクを送信しなければなりません。"
    },
    {
      "indent": 7,
      "text": "If both Verification Tags in the State Cookie match the\nVerification Tags of the current association, consider the State\nCookie valid (this is case E in Section 5.2) even if the lifespan\nis exceeded.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4) If the State Cookie proves to be valid, unpack the TCB into a temporary TCB.",
      "ja": "国家クッキーが有効であることが判明した場合4）、一時的なTCBにTCBを解凍します。"
    },
    {
      "indent": 3,
      "text": "5) Refer to Table 2 to determine the correct action to be taken.",
      "ja": "5）取るべき正しいアクションを決定するために、表2を参照してください。"
    },
    {
      "indent": 0,
      "text": "+------------+------------+---------------+--------------+-------------+\n|  Local Tag | Peer's Tag | Local-Tie-Tag |Peer's-Tie-Tag|   Action/   |\n|            |            |               |              | Description |\n+------------+------------+---------------+--------------+-------------+\n|    X       |     X      |      M        |      M       |     (A)     |\n+------------+------------+---------------+--------------+-------------+\n|    M       |     X      |      A        |      A       |     (B)     |\n+------------+------------+---------------+--------------+-------------+\n|    M       |     0      |      A        |      A       |     (B)     |\n+------------+------------+---------------+--------------+-------------+\n|    X       |     M      |      0        |      0       |     (C)     |\n+------------+------------+---------------+--------------+-------------+\n|    M       |     M      |      A        |      A       |     (D)     |\n+======================================================================+\n|       Table 2: Handling of a COOKIE ECHO when a TCB Exists           |\n+======================================================================+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Legend:",
      "ja": "伝説："
    },
    {
      "indent": 6,
      "text": "X - Tag does not match the existing TCB. M - Tag matches the existing TCB. 0 - No Tie-Tag in cookie (unknown). A - All cases, i.e., M, X, or 0.",
      "ja": "X  - タグは既存のTCBと一致していません。 Mは - タグは既存のTCBに一致します。 0  - クッキー（不明）でノーネクタイタグ。 - すべてのケース、すなわち、M、X、または0。"
    },
    {
      "indent": 3,
      "text": "Note: For any case not shown in Table 2, the cookie should be silently discarded.",
      "ja": "注：表2に示されていない場合は、クッキーは静かに捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "Action",
      "ja": "アクション"
    },
    {
      "indent": 3,
      "text": "A) In this case, the peer may have restarted. When the endpoint recognizes this potential 'restart', the existing session is treated the same as if it received an ABORT followed by a new COOKIE ECHO with the following exceptions:",
      "ja": "A）この場合、ピアは、再起動してもよいです。エンドポイントは、この潜在的な「再起動」を認識すると、それは以下の例外を持つ新しいCOOKIEのECHO続いABORTを受けたかのように、既存のセッションが同じように扱われます。"
    },
    {
      "indent": 6,
      "text": "- Any SCTP DATA chunks MAY be retained (this is an implementation-specific option).",
      "ja": " - 任意のSCTP DATAチャンク（これは実装固有のオプションです）に保持することができます。"
    },
    {
      "indent": 6,
      "text": "- A notification of RESTART SHOULD be sent to the ULP instead of a \"COMMUNICATION LOST\" notification.",
      "ja": " -  RESTARTの通知はULPの代わりに「通信LOST」通知に送信されるべきです。"
    },
    {
      "indent": 6,
      "text": "All the congestion control parameters (e.g., cwnd, ssthresh) related to this peer MUST be reset to their initial values (see Section 6.2.1).",
      "ja": "このピアに関連する（例えば、CWND、SSTHRESH）を初期値にリセットする必要のあるすべての輻輳制御パラメータ（セクション6.2.1を参照します）。"
    },
    {
      "indent": 6,
      "text": "After this, the endpoint shall enter the ESTABLISHED state.",
      "ja": "この後、エンドポイントはESTABLISHED状態に入るものとします。"
    },
    {
      "indent": 6,
      "text": "If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes that the peer has restarted (Action A), it MUST NOT set up a new association but instead resend the SHUTDOWN ACK and send an ERROR chunk with a \"Cookie Received While Shutting Down\" error cause to its peer.",
      "ja": "エンドポイントがSHUTDOWN-ACK-SENT状態にあり、ピアが（アクションA）再起動したことを認識するとシャットダウンが、それは新しい関連付けを設定する代わりにSHUTDOWN ACKを再送し、受信した「クッキーとERRORチャンクを送ってはいけませんそのピアにエラー原因「ダウン。"
    },
    {
      "indent": 3,
      "text": "B) In this case, both sides may be attempting to start an association at about the same time, but the peer endpoint started its INIT after responding to the local endpoint's INIT. Thus, it may have picked a new Verification Tag, not being aware of the previous tag it had sent this endpoint. The endpoint should stay in or enter the ESTABLISHED state, but it MUST update its peer's Verification Tag from the State Cookie, stop any init or cookie timers that may be running, and send a COOKIE ACK.",
      "ja": "この場合、B）は、双方がほぼ同時にアソシエーションを開始しようとすることができるが、ピアエンドポイントは、ローカルエンドポイントのINITに応答した後、そのINITを開始しました。したがって、それは、このエンドポイントを送っていた以前のタグを意識することはない、新しい検証タグを選んだことがあります。エンドポイントは、中にとどまるか、ESTABLISHED状態に入るが、それは国家クッキーからそのピアの検証タグを更新しなければならない、実行されて任意の初期化やクッキータイマを停止し、COOKIE A​​CKを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "C) In this case, the local endpoint's cookie has arrived late. Before it arrived, the local endpoint sent an INIT and received an INIT ACK and finally sent a COOKIE ECHO with the peer's same tag but a new tag of its own. The cookie should be silently discarded. The endpoint SHOULD NOT change states and should leave any timers running.",
      "ja": "C）この場合、ローカルエンドポイントのクッキーが遅れて到着しました。それが到着する前に、ローカルエンドポイントは、INITを送信し、INIT ACKを受信し、最終的にピアの同じタグが、その独自の新しいタグでCOOKIE ECHOを送りました。クッキーは静かに捨てられるべきです。エンドポイントは状態を変更すべきではなく、実行しているすべてのタイマーを残す必要があります。"
    },
    {
      "indent": 3,
      "text": "D) When both local and remote tags match, the endpoint should enter the ESTABLISHED state, if it is in the COOKIE-ECHOED state. It should stop any cookie timer that may be running and send a COOKIE ACK.",
      "ja": "D）場合、ローカルとリモートの両方のタグが一致することがCOOKIE-ECHOED状態にある場合、エンドポイントは、ESTABLISHED状態に入るべきです。これは、実行されている可能性のあるクッキータイマーを停止し、COOKIE A​​CKを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The \"peer's Verification Tag\" is the tag received in the Initiate Tag field of the INIT or INIT ACK chunk.",
      "ja": "注意：「ピアの検証タグは」INITまたはINIT ACKチャンクの開始タグフィールドに受信したタグです。"
    },
    {
      "indent": 0,
      "text": "5.2.4.1. An Example of a Association Restart",
      "section_title": true,
      "ja": "5.2.4.1。協会の再起動の例"
    },
    {
      "indent": 3,
      "text": "In the following example, \"A\" initiates the association after a restart has occurred. Endpoint \"Z\" had no knowledge of the restart until the exchange (i.e., Heartbeats had not yet detected the failure of \"A\") (assuming no bundling or fragmentation occurs):",
      "ja": "次の例では、「」再起動が発生した後の関連付けを開始します。エンドポイント「Z」交換されるまで再起動の知識を有していなかった（非バンドルを想定していないか、断片化が起こる）（すなわち、ハートビートはまだ「A」の障害を検出しませんでした）。"
    },
    {
      "indent": 3,
      "text": "Endpoint A                                          Endpoint Z\n<-------------- Association is established---------------------->\nTag=Tag_A                                             Tag=Tag_Z\n<--------------------------------------------------------------->\n{A crashes and restarts}\n{app sets up a association with Z}\n(build TCB)\nINIT [I-Tag=Tag_A'\n      & other info]  --------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-WAIT state)      \\---> (find an existing TCB\n                                      compose temp TCB and Cookie_Z\n                                      with Tie-Tags to previous\n                                      association)\n                                /--- INIT ACK [Veri Tag=Tag_A',\n                               /               I-Tag=Tag_Z',\n(Cancel T1-init timer) <------/                Cookie_Z[TieTags=\n                                               Tag_A,Tag_Z\n                                                & other info]\n                                     (destroy temp TCB,leave original\n                                      in place)\nCOOKIE ECHO [Veri=Tag_Z',\n             Cookie_Z\n             Tie=Tag_A,\n             Tag_Z]----------\\\n(Start T1-init timer)         \\\n(Enter COOKIE-ECHOED state)    \\---> (Find existing association,\n                                      Tie-Tags match old tags,\n                                      Tags do not match, i.e.,\n                                      case X X M M above,\n                                      Announce Restart to ULP\n                                      and reset association).\n                               /---- COOKIE ACK\n(Cancel T1-init timer, <------/\n Enter ESTABLISHED state)\n{app sends 1st user data; strm 0}\nDATA [TSN=initial TSN_A\n    Strm=0,Seq=0 & user data]--\\\n(Start T3-rtx timer)            \\\n                                 \\->\n                              /--- SACK [TSN Ack=init TSN_A,Block=0]\n(Cancel T3-rtx timer) <------/",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 5: A Restart Example",
      "ja": "図5：再起動例"
    },
    {
      "indent": 0,
      "text": "5.2.5. Handle Duplicate COOKIE-ACK.",
      "section_title": true,
      "ja": "5.2.5。重複COOKIE-ACKを処理します。"
    },
    {
      "indent": 3,
      "text": "At any state other than COOKIE-ECHOED, an endpoint should silently discard a received COOKIE ACK chunk.",
      "ja": "COOKIE-エコー以外の状態では、終点は静かに受信されたクッキーACKチャンクを破棄しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.6. Handle Stale COOKIE Error",
      "section_title": true,
      "ja": "5.2.6。古いCOOKIEのエラーを処理"
    },
    {
      "indent": 3,
      "text": "Receipt of an ERROR chunk with a \"Stale Cookie\" error cause indicates one of a number of possible events:",
      "ja": "「古いクッキー」エラー原因とERRORチャンクの受信が可能なイベントの数のいずれかを示します。"
    },
    {
      "indent": 3,
      "text": "A) The association failed to completely setup before the State Cookie issued by the sender was processed.",
      "ja": "A）協会は、送信者によって発行された状態クッキーが処理される前に完全にセットアップに失敗しました。"
    },
    {
      "indent": 3,
      "text": "B) An old State Cookie was processed after setup completed.",
      "ja": "セットアップが完了した後、B）古い状態クッキーが処理されました。"
    },
    {
      "indent": 3,
      "text": "C) An old State Cookie is received from someone that the receiver is not interested in having an association with and the ABORT chunk was lost.",
      "ja": "C）古い状態クッキーは、受信機はとの関連を持つことに興味がないとABORTチャンクが失われたことを誰かから受信されます。"
    },
    {
      "indent": 3,
      "text": "When processing an ERROR chunk with a \"Stale Cookie\" error cause an endpoint should first examine if an association is in the process of being set up, i.e., the association is in the COOKIE-ECHOED state. In all cases, if the association is not in the COOKIE-ECHOED state, the ERROR chunk should be silently discarded.",
      "ja": "アソシエーションが設定中である場合、エンドポイントは、最初の検討すべき引き起こす「古いクッキー」エラーでERRORチャンクを処理する場合、すなわち、関連付けは、COOKIE-ECHOED状態にあります。協会がCOOKIE-ECHOED状態でない場合は、すべてのケースでは、ERRORチャンクは静かに捨てられるべきです。"
    },
    {
      "indent": 3,
      "text": "If the association is in the COOKIE-ECHOED state, the endpoint may elect one of the following three alternatives.",
      "ja": "協会がCOOKIE-ECHOED状態にある場合、エンドポイントは以下の3つの選択肢のいずれかを選ぶことができます。"
    },
    {
      "indent": 3,
      "text": "1) Send a new INIT chunk to the endpoint to generate a new State Cookie and reattempt the setup procedure.",
      "ja": "1）新しい状態クッキーを生成して、セットアップ手順を再試行するエンドポイントに新しいINITチャンクを送信します。"
    },
    {
      "indent": 3,
      "text": "2) Discard the TCB and report to the upper layer the inability to set up the association.",
      "ja": "2）TCBを破棄し、上位層に関連付けを設定することができないことを報告しています。"
    },
    {
      "indent": 3,
      "text": "3) Send a new INIT chunk to the endpoint, adding a Cookie Preservative parameter requesting an extension to the life time of the State Cookie. When calculating the time extension, an implementation SHOULD use the RTT information measured based on the previous COOKIE ECHO / ERROR exchange, and should add no more than 1 second beyond the measured RTT, due to long State Cookie life times making the endpoint more subject to a replay attack.",
      "ja": "3）国家クッキーの寿命の延長を要求するクッキー防腐剤パラメータを追加し、エンドポイントに新しいINITチャンクを送信します。時間の延長を計算する場合、実装は、以前のCOOKIE ECHO / ERROR交換に基づいて測定されたRTT情報を使用すべきである、とするエンドポイントは、より対象作るため、長い州Cookieの寿命時間に、測定されたRTTを超えせいぜい1秒を追加するべきではありませんリプレイ攻撃。"
    },
    {
      "indent": 0,
      "text": "5.3. Other Initialization Issues",
      "section_title": true,
      "ja": "5.3。その他の初期化の問題"
    },
    {
      "indent": 0,
      "text": "5.3.1. Selection of Tag Value",
      "section_title": true,
      "ja": "5.3.1。タグ値の選択"
    },
    {
      "indent": 3,
      "text": "Initiate Tag values should be selected from the range of 1 to 2**32 - 1. It is very important that the Initiate Tag value be randomized to help protect against \"man in the middle\" and \"sequence number\" attacks. The methods described in [RFC4086] can be used for the Initiate Tag randomization. Careful selection of Initiate Tags is also necessary to prevent old duplicate packets from previous associations being mistakenly processed as belonging to the current association.",
      "ja": "開始タグの値がの範囲から選択する必要があり、1〜2 ** 32  -  1。開始タグの値が「中間者」と「シーケンス番号」攻撃から保護するためにランダム化されることが非常に重要です。 [RFC4086]に記載された方法は、開始タグのランダム化のために使用することができます。タグを開始するの慎重な選択が誤って現在のアソシエーションに属するものとして処理される前の協会から古い重複パケットを防ぐためにも必要です。"
    },
    {
      "indent": 3,
      "text": "Moreover, the Verification Tag value used by either endpoint in a given association MUST NOT change during the life time of an association. A new Verification Tag value MUST be used each time the endpoint tears down and then reestablishes an association to the same peer.",
      "ja": "また、特定の団体のいずれかのエンドポイントで使用される検証タグ値は、協会の寿命の間に変化してはいけません。新しい検証タグ値は、エンドポイントが切断し、次いで同じピアへの関連付けを再確立するたびに使用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.4. Path Verification",
      "section_title": true,
      "ja": "5.4。パス検証"
    },
    {
      "indent": 3,
      "text": "During association establishment, the two peers exchange a list of addresses. In the predominant case, these lists accurately represent the addresses owned by each peer. However, it is possible that a misbehaving peer may supply addresses that it does not own. To prevent this, the following rules are applied to all addresses of the new association:",
      "ja": "アソシエーションの確立時には、2つのピアがアドレスのリストを交換します。支配的な場合には、これらのリストは正確に各ピアが所有するアドレスを表します。しかし、ふらちなピアは、それが所有していないアドレスを提供する可能性があります。これを防ぐには、以下のルールが新しいアソシエーションのすべてのアドレスに適用されます。"
    },
    {
      "indent": 3,
      "text": "1) Any address passed to the sender of the INIT by its upper layer is automatically considered to be CONFIRMED.",
      "ja": "1）その上位層によってINITの送信者に渡されたアドレスが自動的に確認されていると考えられます。"
    },
    {
      "indent": 3,
      "text": "2) For the receiver of the COOKIE ECHO, the only CONFIRMED address is the one to which the INIT-ACK was sent.",
      "ja": "2）COOKIE ECHOの受信機のための、唯一の確認された住所は、INIT-ACKが送信されたものです。"
    },
    {
      "indent": 3,
      "text": "3) All other addresses not covered by rules 1 and 2 are considered UNCONFIRMED and are subject to probing for verification.",
      "ja": "3）ルール1及び2によって覆われていない他のすべてのアドレス未確認とみなされ、検証のためにプロービングの対象とされています。"
    },
    {
      "indent": 3,
      "text": "To probe an address for verification, an endpoint will send HEARTBEATs including a 64-bit random nonce and a path indicator (to identify the address that the HEARTBEAT is sent to) within the HEARTBEAT parameter.",
      "ja": "検証のためのアドレスを調べるために、エンドポイントはHEARTBEATパラメータ内（HEARTBEATが送られるアドレスを識別するために）64ビットのランダムなノンスとパスインジケータを含むハートビートを送信します。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the HEARTBEAT ACK, a verification is made that the nonce included in the HEARTBEAT parameter is the one sent to the address indicated inside the HEARTBEAT parameter. When this match occurs, the address that the original HEARTBEAT was sent to is now considered CONFIRMED and available for normal data transfer.",
      "ja": "ハートビートACKを受信すると、検証がnonceがHEARTBEATパラメータに含まれると判断されたハートビートパラメータの内部に示されたアドレスに送信されたものです。このマッチが発生すると、オリジナルのHEARTBEATが送られたことをアドレスは、現在確認され、通常のデータ転送のために利用できると考えられています。"
    },
    {
      "indent": 3,
      "text": "These probing procedures are started when an association moves to the ESTABLISHED state and are ended when all paths are confirmed.",
      "ja": "これらの探査手順は、協会がESTABLISHED状態に移行したときに開始され、すべてのパスが確認されたときに終了しています。"
    },
    {
      "indent": 3,
      "text": "In each RTO, a probe may be sent on an active UNCONFIRMED path in an attempt to move it to the CONFIRMED state. If during this probing the path becomes inactive, this rate is lowered to the normal HEARTBEAT rate. At the expiration of the RTO timer, the error counter of any path that was probed but not CONFIRMED is incremented by one and subjected to path failure detection, as defined in Section 8.2. When probing UNCONFIRMED addresses, however, the association overall error count is NOT incremented.",
      "ja": "各RTOにおいて、プローブが確認状態に移動しようとして活性UNCONFIRMED経路上で送信することができます。この時のパスを探査することは非アクティブになると、このレートは、通常の心拍数に低下させます。セクション8.2で定義されるように、RTOタイマの満了時に、プローブが、確認されなかった任意のパスのエラーカウンタを1つインクリメントされ、パス障害検出を行いました。 UNCONFIRMEDアドレスをプロービングすると、しかし、協会全体のエラーカウントがインクリメントされていません。"
    },
    {
      "indent": 3,
      "text": "The number of HEARTBEATS sent at each RTO SHOULD be limited by the HB.Max.Burst parameter. It is an implementation decision as to how to distribute HEARTBEATS to the peer's addresses for path verification.",
      "ja": "各RTOで送信心拍数はHB.Max.Burstパラメータによって制限されるべきです。これは、パス検証のためのピアのアドレスにハートビートを配布する方法のような実装決定です。"
    },
    {
      "indent": 3,
      "text": "Whenever a path is confirmed, an indication MAY be given to the upper layer.",
      "ja": "パスが確認されるたびに、表示は上位層に与えてもよいです。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST NOT send any chunks to an UNCONFIRMED address, with the following exceptions:",
      "ja": "エンドポイントは、以下の例外を除いて、UNCONFIRMEDアドレスに任意の塊を送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "- A HEARTBEAT including a nonce MAY be sent to an UNCONFIRMED address.",
      "ja": " -  nonceを含むHEARTBEATをUNCONFIRMEDアドレスに送ってもよいです。"
    },
    {
      "indent": 3,
      "text": "- A HEARTBEAT ACK MAY be sent to an UNCONFIRMED address.",
      "ja": " -  HEARTBEAT ACKはUNCONFIRMEDアドレスに送ってもよいです。"
    },
    {
      "indent": 3,
      "text": "- A COOKIE ACK MAY be sent to an UNCONFIRMED address, but it MUST be bundled with a HEARTBEAT including a nonce. An implementation that does NOT support bundling MUST NOT send a COOKIE ACK to an UNCONFIRMED address.",
      "ja": " -  COOKIE A​​CKはUNCONFIRMEDアドレスに送信されるかもしれないが、それはナンスを含むHEARTBEATとバンドルされなければなりません。バンドルサポートしていない実装はUNCONFIRMEDアドレスにCOOKIE A​​CKを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "- A COOKIE ECHO MAY be sent to an UNCONFIRMED address, but it MUST be bundled with a HEARTBEAT including a nonce, and the packet MUST NOT exceed the path MTU. If the implementation does NOT support bundling or if the bundled COOKIE ECHO plus HEARTBEAT (including nonce) would exceed the path MTU, then the implementation MUST NOT send a COOKIE ECHO to an UNCONFIRMED address.",
      "ja": " -  COOKIE ECHO未確認アドレスに送信されても​​よく、それはナンスを含むHEARTBEATとバンドルされなければならない、そして、パケットはパスMTUを超えてはなりません。実装がバンドルまたはバンドルさCOOKIEのECHOプラス（ナンスを含む）HEARTBEATがパスMTUを超える場合はサポートしていない場合は、その実装はUNCONFIRMEDアドレスにCOOKIE ECHOを送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "6. User Data Transfer",
      "section_title": true,
      "ja": "6.ユーザデータ転送"
    },
    {
      "indent": 3,
      "text": "Data transmission MUST only happen in the ESTABLISHED, SHUTDOWN-PENDING, and SHUTDOWN-RECEIVED states. The only exception to this is that DATA chunks are allowed to be bundled with an outbound COOKIE ECHO chunk when in the COOKIE-WAIT state.",
      "ja": "データ送信はESTABLISHED、SHUTDOWN-PENDING、およびSHUTDOWN-RECEIVED状態で行われる必要があります。これに対する唯一の例外は、データチャンクがCOOKIE-WAIT状態のアウトバウンドCOOKIE ECHOチャンクにバンドルすることが許可されていることです。"
    },
    {
      "indent": 3,
      "text": "DATA chunks MUST only be received according to the rules below in ESTABLISHED, SHUTDOWN-PENDING, and SHUTDOWN-SENT. A DATA chunk received in CLOSED is out of the blue and SHOULD be handled per Section 8.4. A DATA chunk received in any other state SHOULD be discarded.",
      "ja": "DATAチャンクのみESTABLISHED、SHUTDOWN-PENDING、およびSHUTDOWN-SENTに以下の規則に従って受信されなければなりません。 CLOSEDに受信されたデータチャンクは、青色の外で、セクション8.4当たり処理されるべきです。他の状態で受信されたデータチャンクは、廃棄されるべきです。"
    },
    {
      "indent": 3,
      "text": "A SACK MUST be processed in ESTABLISHED, SHUTDOWN-PENDING, and SHUTDOWN-RECEIVED. An incoming SACK MAY be processed in COOKIE-ECHOED. A SACK in the CLOSED state is out of the blue and SHOULD be processed according to the rules in Section 8.4. A SACK chunk received in any other state SHOULD be discarded.",
      "ja": "SACKは、確立された、SHUTDOWN-PENDING、およびSHUTDOWNに受信で処理されなければなりません。入って来るSACKは、COOKIE-ECHOEDで処理することができます。閉状態におけるSACKは、青色の外であり、セクション8.4の規則に従って処理されるべきです。他の状態で受信されたSACKチャンクは廃棄されるべきです。"
    },
    {
      "indent": 3,
      "text": "An SCTP receiver MUST be able to receive a minimum of 1500 bytes in one SCTP packet. This means that an SCTP endpoint MUST NOT indicate less than 1500 bytes in its initial a_rwnd sent in the INIT or INIT ACK.",
      "ja": "SCTPの受信機は、一のSCTPパケット内の1500バイトの最小値を受け取ることができなければなりません。これは、SCTP終点はINITまたはINIT ACKで送信されたその初期a_rwndで1500バイト未満を示してはならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "For transmission efficiency, SCTP defines mechanisms for bundling of small user messages and fragmentation of large user messages. The following diagram depicts the flow of user messages through SCTP.",
      "ja": "伝送効率のために、SCTPは小さなユーザメッセージ及び大きなユーザメッセージのフラグメンテーションのバンドルするためのメカニズムを定義します。次の図は、SCTPを介してユーザメッセージの流れを示しています。"
    },
    {
      "indent": 3,
      "text": "In this section, the term \"data sender\" refers to the endpoint that transmits a DATA chunk and the term \"data receiver\" refers to the endpoint that receives a DATA chunk. A data receiver will transmit SACK chunks.",
      "ja": "このセクションでは、用語「データ送信者」は、データチャンクと、用語「データ受信」を送信データチャンクを受信するエンドポイントを指すエンドポイントを指します。データ受信装置はSACKチャンクを送信します。"
    },
    {
      "indent": 6,
      "text": "           +--------------------------+\n           |      User Messages       |\n           +--------------------------+\n SCTP user        ^  |\n==================|==|=======================================\n                  |  v (1)\n       +------------------+    +--------------------+\n       | SCTP DATA Chunks |    |SCTP Control Chunks |\n       +------------------+    +--------------------+\n                  ^  |             ^  |\n                  |  v (2)         |  v (2)\n               +--------------------------+\n               |      SCTP packets        |\n               +--------------------------+\n SCTP                      ^  |\n===========================|==|===========================\n                           |  v\n       Connectionless Packet Transfer Service (e.g., IP)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 6,
      "text": "1) When converting user messages into DATA chunks, an endpoint will fragment user messages larger than the current association path MTU into multiple DATA chunks. The data receiver will normally reassemble the fragmented message from DATA chunks before delivery to the user (see Section 6.9 for details).",
      "ja": "データチャンクにユーザメッセージを変換する場合1）、エンドポイントは、複数のデータチャンクに現在関連付け経路MTUよりも大きいユーザメッセージを断片化します。データ受信装置は、通常、ユーザ（詳細はセクション6.9を参照）に配信する前に、データチャンクから断片化されたメッセージを再アセンブルします。"
    },
    {
      "indent": 6,
      "text": "2) Multiple DATA and control chunks may be bundled by the sender into a single SCTP packet for transmission, as long as the final size of the packet does not exceed the current path MTU. The receiver will unbundle the packet back into the original chunks. Control chunks MUST come before DATA chunks in the packet.",
      "ja": "2）複数のデータ及び制御チャンクはパケットの最終的なサイズは、現在の経路MTUを超えない限り、送信のために単一のSCTPパケットに送信側で束ねてもよいです。受信機は、元のチャンクにパケットをアンバンドルされます。コントロールチャンクはパケット内のデータの塊の前に来なければなりません。"
    },
    {
      "indent": 16,
      "text": "Figure 6: Illustration of User Data Transfer",
      "ja": "図6：ユーザデータ転送のイラスト"
    },
    {
      "indent": 3,
      "text": "The fragmentation and bundling mechanisms, as detailed in Section 6.9 and Section 6.10, are OPTIONAL to implement by the data sender, but they MUST be implemented by the data receiver, i.e., an endpoint MUST properly receive and process bundled or fragmented data.",
      "ja": "断片化およびバンドリングメカニズム、セクション6.9およびセクション6.10に詳述されるように、データ送信側によって実現するためのオプションであるが、エンドポイントが適切に受信して処理バンドルまたは断片化しなければならないデータ、すなわち、データ受信機によって実装されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.1. Transmission of DATA Chunks",
      "section_title": true,
      "ja": "6.1。データチャンクの送信"
    },
    {
      "indent": 3,
      "text": "This document is specified as if there is a single retransmission timer per destination transport address, but implementations MAY have a retransmission timer for each DATA chunk.",
      "ja": "この文書は、宛先トランスポートアドレスごとに単一の再送信タイマーがあるかのように指定されていますが、実装は、各データチャンクの再送信タイマーを持っているかもしれません。"
    },
    {
      "indent": 3,
      "text": "The following general rules MUST be applied by the data sender for transmission and/or retransmission of outbound DATA chunks:",
      "ja": "以下の一般的なルールは、送信及び/又はアウトバウンド・データチャンクの再送信のためにデータ送信者によって適用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "A) At any given time, the data sender MUST NOT transmit new data to any destination transport address if its peer's rwnd indicates that the peer has no buffer space (i.e., rwnd is 0; see Section 6.2.1). However, regardless of the value of rwnd (including if it is 0), the data sender can always have one DATA chunk in flight to the receiver if allowed by cwnd (see rule B, below). This rule allows the sender to probe for a change in rwnd that the sender missed due to the SACK's having been lost in transit from the data receiver to the data sender.",
      "ja": "セクション6.2.1を参照）;そのピアのRWNDピア（すなわち、RWNDが0でないバッファスペースを有していないことを示す場合A）は、任意の所与の時点で、データ送信者は任意の宛先トランスポートアドレスに新しいデータを送信してはいけません。 CWNDによって許可されている場合しかし、関係なく（それが0である場合を含む）RWNDの値の、データの送信側は常に受信機に飛行中の一つのデータチャンクを有することができる（以下、ルールBを参照）。このルールは、送信者は送信者が原因SACKのデータ送信側にデータ受信機から輸送中に紛失されていたこと逃したRWNDの変化を調べることができます。"
    },
    {
      "indent": 6,
      "text": "When the receiver's advertised window is zero, this probe is called a zero window probe. Note that a zero window probe SHOULD only be sent when all outstanding DATA chunks have been cumulatively acknowledged and no DATA chunks are in flight. Zero window probing MUST be supported.",
      "ja": "受信機の広告ウィンドウがゼロの場合、このプローブは、ゼロウィンドウプローブと呼ばれています。すべての未処理データのチャンクが累積的に認められているとはデータのチャンクが飛行中でないときにゼロウィンドウプローブのみが送信されるべきであることに注意してください。プロービングゼロウィンドウをサポートしなければなりません。"
    },
    {
      "indent": 6,
      "text": "If the sender continues to receive new packets from the receiver while doing zero window probing, the unacknowledged window probes should not increment the error counter for the association or any destination transport address. This is because the receiver MAY keep its window closed for an indefinite time. Refer to Section 6.2 on the receiver behavior when it advertises a zero window. The sender SHOULD send the first zero window probe after 1 RTO when it detects that the receiver has closed its window and SHOULD increase the probe interval exponentially afterwards. Also note that the cwnd SHOULD be adjusted according to Section 7.2.1. Zero window probing does not affect the calculation of cwnd.",
      "ja": "プロービングゼロウィンドウをしている間、送信者が受信機から新しいパケットを受信し続ける場合、未確認ウィンドウプローブは結合または任意の宛先トランスポートアドレスのエラーカウンタを増分しないはずです。受信機は、そのウィンドウは無期限のため閉鎖続ける可能性があるためです。それがゼロウィンドウをアドバタイズするとき受信機の動作上のセクション6.2を参照してください。それは、受信機がそのウィンドウを閉じており、指数関数的にその後プローブ間隔を増やす必要があることを検出した場合、送信者は1 RTO後の最初のゼロウィンドウプローブを送るべきです。また、cwndは、セクション7.2.1に応じて調整する必要があることに注意してください。ゼロウィンドウのcwndの計算には影響しませんプロービング。"
    },
    {
      "indent": 6,
      "text": "The sender MUST also have an algorithm for sending new DATA chunks to avoid silly window syndrome (SWS) as described in [RFC0813]. The algorithm can be similar to the one described in Section 4.2.3.4 of [RFC1122].",
      "ja": "送信者はまた、[RFC0813]に記載されているように愚かなウィンドウ症候群（SWS）を避けるために、新しいデータチャンクを送信するためのアルゴリズムがなければなりません。アルゴリズムは、[RFC1122]のセクション4.2.3.4に記載したものと同様とすることができます。"
    },
    {
      "indent": 6,
      "text": "However, regardless of the value of rwnd (including if it is 0), the data sender can always have one DATA chunk in flight to the receiver if allowed by cwnd (see rule B below). This rule allows the sender to probe for a change in rwnd that the sender missed due to the SACK having been lost in transit from the data receiver to the data sender.",
      "ja": "CWNDによって許可されている場合しかし、関係なく（それが0である場合を含む）RWNDの値の、データの送信側は常に受信機に飛行中の一つのデータチャンクを有することができる（以下ルールBを参照）。このルールは、送信者は送信者が原因のデータ送信側にデータの受信機からのトランジットで失われたSACKに逃したRWNDの変化を調べることができます。"
    },
    {
      "indent": 3,
      "text": "B) At any given time, the sender MUST NOT transmit new data to a given transport address if it has cwnd or more bytes of data outstanding to that transport address.",
      "ja": "それはcwndをまたはそのトランスポートアドレスへの未処理データのより多くのバイトをしている場合B）任意の時点で、送信者は、与えられた輸送アドレスに新しいデータを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "C) When the time comes for the sender to transmit, before sending new DATA chunks, the sender MUST first transmit any outstanding DATA chunks that are marked for retransmission (limited by the current cwnd).",
      "ja": "送信者が送信するための時間が来るとC）、新しいデータチャンクを送信する前に、送信者は、まず現在のcwndによって制限された再送（）のためにマークされているすべての未処理データチャンクを伝えなければなりません。"
    },
    {
      "indent": 3,
      "text": "D) When the time comes for the sender to transmit new DATA chunks, the protocol parameter Max.Burst SHOULD be used to limit the number of packets sent. The limit MAY be applied by adjusting cwnd as follows:",
      "ja": "時刻が新しいデータチャンクを送信する送信者となるとD）、プロトコルパラメータMax.Burstは、送信されたパケットの数を制限するために使用されるべきです。制限は次のようにCWNDを調整することによって適用することができます。"
    },
    {
      "indent": 6,
      "text": "if((flightsize + Max.Burst*MTU) < cwnd) cwnd = flightsize + Max.Burst*MTU",
      "ja": "IF（（flightsize + Max.Burst * MTU）<CWND）CWND = flightsize + Max.Burst * MTU"
    },
    {
      "indent": 6,
      "text": "Or it MAY be applied by strictly limiting the number of packets emitted by the output routine.",
      "ja": "それとも、厳密に出力ルーチンによって放出されたパケットの数を制限することによって適用することもできます。"
    },
    {
      "indent": 3,
      "text": "E) Then, the sender can send out as many new DATA chunks as rule A and rule B allow.",
      "ja": "E）次に、送信者は、ルールAとルールBが許す限り多くの新しいDATAチャンクを送信することができます。"
    },
    {
      "indent": 3,
      "text": "Multiple DATA chunks committed for transmission MAY be bundled in a single packet. Furthermore, DATA chunks being retransmitted MAY be bundled with new DATA chunks, as long as the resulting packet size does not exceed the path MTU. A ULP may request that no bundling is performed, but this should only turn off any delays that an SCTP implementation may be using to increase bundling efficiency. It does not in itself stop all bundling from occurring (i.e., in case of congestion or retransmission).",
      "ja": "伝送のためにコミット複数のデータチャンクは、単一のパケットにバンドルされるかもしれません。また、再送されるデータチャンクは、得られたパケットサイズがパスMTUを超えない限り、新たなデータチャンクにバンドルされるかもしれません。 ULPにはバンドルが実行されないことを要求することができるが、これは、SCTP実装がバンドル効率を高めるために使用することができる任意の遅延をオフにしなければなりません。それ自体で発生するすべてのバンドルを停止しない（すなわち、輻輳や再送の場合）。"
    },
    {
      "indent": 3,
      "text": "Before an endpoint transmits a DATA chunk, if any received DATA chunks have not been acknowledged (e.g., due to delayed ack), the sender should create a SACK and bundle it with the outbound DATA chunk, as long as the size of the final SCTP packet does not exceed the current MTU. See Section 6.2.",
      "ja": "エンドポイントは、データチャンクを送信する前に、すべての受信したデータチャンクが確認されていない場合は、（例えば、遅延ACKのために）、送信者はSACKを作成する必要があり、最終的なSCTPの大き限り、アウトバウンドのDATAチャンクとの同梱パケットは、現在のMTUを超えてはなりません。 6.2節を参照してください。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: When the window is full (i.e., transmission is disallowed by rule A and/or rule B), the sender MAY still accept send requests from its upper layer, but MUST transmit no more DATA chunks until some or all of the outstanding DATA chunks are acknowledged and transmission is allowed by rule A and rule B again.",
      "ja": "実装上の注意：ウィンドウがいっぱいになると、送信者はまだその上位層からの要求を送信受け入れるかもしれが、卓越したの一部または全部までは複数のデータチャンクを送信しなければなりません（すなわち、送信は、ルールAおよび/またはルールBによって許可されません） DATAチャンクが確認されると、送信が再びルールAとルールBによって許可されています。"
    },
    {
      "indent": 3,
      "text": "Whenever a transmission or retransmission is made to any address, if the T3-rtx timer of that address is not currently running, the sender MUST start that timer. If the timer for that address is already running, the sender MUST restart the timer if the earliest (i.e., lowest TSN) outstanding DATA chunk sent to that address is being retransmitted. Otherwise, the data sender MUST NOT restart the timer.",
      "ja": "そのアドレスのT3-RTXタイマーが現在実行されていない場合は送信または再送信は、任意のアドレスに行われるたびに、送信者はそのタイマーを起動する必要があります。そのアドレスのタイマーがすでに実行されている場合は、そのアドレスに送信された最も初期の（すなわち、最低TSN）の未処理データチャンクが再送信されている場合、送信者はタイマーを再起動する必要があります。それ以外の場合は、データの送信者はタイマーを再起動してはなりません。"
    },
    {
      "indent": 3,
      "text": "When starting or restarting the T3-rtx timer, the timer value must be adjusted according to the timer rules defined in Sections 6.3.2 and 6.3.3.",
      "ja": "T3-RTXタイマーを起動または再起動すると、タイマ値はセクション6.3.2及び6.3.3で定義されたタイマールールに従って調整されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: The data sender SHOULD NOT use a TSN that is more than 2**31 - 1 above the beginning TSN of the current send window.",
      "ja": "注意：データの送信者は2 ** 31以上であるTSN使うべきではありません -  1現在の送信ウィンドウの開始TSNの上を。"
    },
    {
      "indent": 0,
      "text": "6.2. Acknowledgement on Reception of DATA Chunks",
      "section_title": true,
      "ja": "6.2。データチャンクのレセプションに謝辞"
    },
    {
      "indent": 3,
      "text": "The SCTP endpoint MUST always acknowledge the reception of each valid DATA chunk when the DATA chunk received is inside its receive window.",
      "ja": "受信したデータチャンクがその受信ウィンドウ内にあるとき、SCTP終点は常に、各有効なデータ・チャンクの受信を確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the receiver's advertised window is 0, the receiver MUST drop any new incoming DATA chunk with a TSN larger than the largest TSN received so far. If the new incoming DATA chunk holds a TSN value less than the largest TSN received so far, then the receiver SHOULD drop the largest TSN held for reordering and accept the new incoming DATA chunk. In either case, if such a DATA chunk is dropped, the receiver MUST immediately send back a SACK with the current receive window showing only DATA chunks received and accepted so far. The dropped DATA chunk(s) MUST NOT be included in the SACK, as they were not accepted. The receiver MUST also have an algorithm for advertising its receive window to avoid receiver silly window syndrome (SWS), as described in [RFC0813]. The algorithm can be similar to the one described in Section 4.2.3.3 of [RFC1122].",
      "ja": "受信機の広告ウィンドウが0の場合、受信機は、TSNがこれまでに受けた最大のより大きいTSNで任意の新しい着信データチャンクを削除する必要があります。新しい着信データチャンクはTSNがこれまでに受信した最大未満のTSN値を保持している場合、受信機は、並べ替えのために保持された最大のTSNをドロップし、新しい着信データチャンクを受け入れるべきです。いずれの場合においても、このようなデータチャンクが削除される場合、受信機はすぐに受信され、これまで受け入れられたデータのみチャンクを示す現在の受信ウィンドウとSACKを返送しなければなりません。彼らは受け入れられなかったとしてドロップされたデータのチャンク（複数可）、SACKに含まれてはいけません。受信機はまた、[RFC0813]に記載されているように、（SWS）を受信愚かウィンドウ症候群を避けるために、その受信ウィンドウを広告するためのアルゴリズムがなければなりません。アルゴリズムは、[RFC1122]のセクション4.2.3.3に記載したものと同様とすることができます。"
    },
    {
      "indent": 3,
      "text": "The guidelines on delayed acknowledgement algorithm specified in Section 4.2 of [RFC2581] SHOULD be followed. Specifically, an acknowledgement SHOULD be generated for at least every second packet (not every second DATA chunk) received, and SHOULD be generated within 200 ms of the arrival of any unacknowledged DATA chunk. In some situations, it may be beneficial for an SCTP transmitter to be more conservative than the algorithms detailed in this document allow. However, an SCTP transmitter MUST NOT be more aggressive than the following algorithms allow.",
      "ja": "[RFC2581]のセクション4.2で指定された遅延確認応答アルゴリズムのガイドラインに従わされるべきです。具体的には、肯定応答は、少なくとも毎秒パケット（必ずしもすべての第二のデータチャンク）を受信するために生成されるべきであり、任意の未確認DATAチャンクの到着の200ミリ秒以内に生成されるべきです。 SCTP送信機は、この文書に詳述アルゴリズムが許すよりも保守的であるために、いくつかの状況では、それは有益であり得ます。しかし、SCTP送信機は、以下のアルゴリズムが許すよりも、より積極的にすることはできません。"
    },
    {
      "indent": 3,
      "text": "An SCTP receiver MUST NOT generate more than one SACK for every incoming packet, other than to update the offered window as the receiving application consumes new data.",
      "ja": "SCTPの受信機は、受信側のアプリケーションは、新しいデータを消費として提供ウィンドウを更新するよりも、他のすべての着信パケットに複数のSACKを発生させてはいけません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: The maximum delay for generating an acknowledgement may be configured by the SCTP administrator, either statically or dynamically, in order to meet the specific timing requirement of the protocol being carried.",
      "ja": "実装注：肯定応答を生成するための最大遅延は、搬送されるプロトコルの特定のタイミング要件を満たすために、静的または動的に、SCTP管理者によって構成されていてもよいです。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST NOT allow the maximum delay to be configured to be more than 500 ms. In other words, an implementation MAY lower this value below 500 ms but MUST NOT raise it above 500 ms.",
      "ja": "実装は、最大遅延は500以上のミリ秒であるように構成されることを可能にしてはいけません。言い換えれば、実装は500ミリ秒以下、この値を下げるかもしれませんが、500ミリ秒を超える、それを発生させてはなりません。"
    },
    {
      "indent": 3,
      "text": "Acknowledgements MUST be sent in SACK chunks unless shutdown was requested by the ULP, in which case an endpoint MAY send an acknowledgement in the SHUTDOWN chunk. A SACK chunk can acknowledge the reception of multiple DATA chunks. See Section 3.3.4 for SACK chunk format. In particular, the SCTP endpoint MUST fill in the Cumulative TSN Ack field to indicate the latest sequential TSN (of a valid DATA chunk) it has received. Any received DATA chunks with TSN greater than the value in the Cumulative TSN Ack field are reported in the Gap Ack Block fields. The SCTP endpoint MUST report as many Gap Ack Blocks as can fit in a single SACK chunk limited by the current path MTU.",
      "ja": "シャットダウンが終点がSHUTDOWNチャンクに確認応答を送信することができ、その場合にはULPによって要求された場合を除き謝辞はSACKチャンクに送らなければなりません。 SACKチャンクは複数のDATAチャンクの受信を確認することができます。 SACKチャンク形式については、セクション3.3.4を参照してください。特に、SCTP終点は、それが受信した（有効なデータチャンクの）最新のシーケンシャルTSNを示すために、累積TSN ACKフィールドに記入しなければなりません。大きい累積TSN ACKフィールドの値よりもTSNを有する任意の受信したデータチャンクはギャップAckブロックフィールドに報告されています。現在のパスMTUによって制限され、単一のSACKチャンクに収まるようSCTP終点は、多くのギャップAckブロックとして報告しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: The SHUTDOWN chunk does not contain Gap Ack Block fields. Therefore, the endpoint should use a SACK instead of the SHUTDOWN chunk to acknowledge DATA chunks received out of order.",
      "ja": "注意：SHUTDOWNチャンクはギャップAckブロックフィールドが含まれていません。そのため、エンドポイントは、順不同で受信したデータチャンクを確認するためにSACKの代わりに、SHUTDOWNチャンクを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a packet arrives with duplicate DATA chunk(s) and with no new DATA chunk(s), the endpoint MUST immediately send a SACK with no delay. If a packet arrives with duplicate DATA chunk(s) bundled with new DATA chunks, the endpoint MAY immediately send a SACK. Normally, receipt of duplicate DATA chunks will occur when the original SACK chunk was lost and the peer's RTO has expired. The duplicate TSN number(s) SHOULD be reported in the SACK as duplicate.",
      "ja": "パケットが重複データチャンク（S）とし、新しいデータのチャンク（S）で到着すると、エンドポイントはすぐに遅延なしでSACKを送らなければなりません。パケットが新しいDATAチャンクにバンドルされ、重複データチャンク（S）で到着した場合、エンドポイントはすぐにSACKを送信することができます。オリジナルのSACKチャンクが失われたとピアのRTOが期限切れになったとき、通常、重複DATAチャンクの受信が発生します。重複TSN番号（複数可）は、重複するようにSACKで報告されるべきです。"
    },
    {
      "indent": 3,
      "text": "When an endpoint receives a SACK, it MAY use the duplicate TSN information to determine if SACK loss is occurring. Further use of this data is for future study.",
      "ja": "エンドポイントがSACKを受信すると、SACKロスが発生しているかどうかを判断するために、重複TSN情報を使用することができます。このデータのさらなる利用は、今後の検討課題です。"
    },
    {
      "indent": 3,
      "text": "The data receiver is responsible for maintaining its receive buffers. The data receiver SHOULD notify the data sender in a timely manner of changes in its ability to receive data. How an implementation manages its receive buffers is dependent on many factors (e.g., operating system, memory management system, amount of memory, etc.). However, the data sender strategy defined in Section 6.2.1 is based on the assumption of receiver operation similar to the following:",
      "ja": "データ受信機は、その受信バッファを維持する責任があります。データ受信装置は、データを受信する能力の変化をタイムリーにデータを送信者に通知すべきです。実装は、多くの要因に依存してその受信バッファを管理する方法（例えば、オペレーティングシステム、メモリ管理システム、メモリの量、など）。しかしながら、セクション6.2.1で定義されたデータの送信元戦略は、次のような受信機動作の仮定に基づいています。"
    },
    {
      "indent": 3,
      "text": "A) At initialization of the association, the endpoint tells the peer how much receive buffer space it has allocated to the association in the INIT or INIT ACK. The endpoint sets a_rwnd to this value.",
      "ja": "A）関連の初期化時に、エンドポイントは、INITまたはINIT ACKに関連する割り当てられたバッファスペースを受け取るどのくらいのピアに通知します。エンドポイントのセットは、この値にa_rwnd。"
    },
    {
      "indent": 3,
      "text": "B) As DATA chunks are received and buffered, decrement a_rwnd by the number of bytes received and buffered. This is, in effect, closing rwnd at the data sender and restricting the amount of data it can transmit.",
      "ja": "受信及びバッファリングされたバイト数によってB）DATAチャンクを受信して​​バッファリングされるように、デクリメントa_rwnd。これは、実際には、データ送信側でRWNDを閉じて、それが送信できるデータの量を制限する、です。"
    },
    {
      "indent": 3,
      "text": "C) As DATA chunks are delivered to the ULP and released from the receive buffers, increment a_rwnd by the number of bytes delivered to the upper layer. This is, in effect, opening up rwnd on the data sender and allowing it to send more data. The data receiver SHOULD NOT increment a_rwnd unless it has released bytes from its receive buffer. For example, if the receiver is holding fragmented DATA chunks in a reassembly queue, it should not increment a_rwnd.",
      "ja": "C）DATAチャンクがULPに送達し、上位層に配信されたバイト数によってa_rwnd受信バッファ、増分からリリースされます。これは、実際には、データの送信者にRWNDを開くと、それはより多くのデータを送信できるようにしています。それはその受信バッファからバイトをリリースしていない限り、データ受信機は、a_rwndを増加しないはずです。受信機が再組み立てキューに断片化されたデータチャンクを保持している場合、例えば、それはa_rwndインクリメントしてはなりません。"
    },
    {
      "indent": 3,
      "text": "D) When sending a SACK, the data receiver SHOULD place the current value of a_rwnd into the a_rwnd field. The data receiver SHOULD take into account that the data sender will not retransmit DATA chunks that are acked via the Cumulative TSN Ack (i.e., will drop from its retransmit queue).",
      "ja": "SACKを送信するときD）、データ受信機はa_rwndフィールドにa_rwndの現在の値を配置する必要があります。データ受信装置は、データ送信者が累積TSN ACK（すなわち、その再送信キューからドロップされます）を介してACKされたデータチャンクを再送しないであろう考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "Under certain circumstances, the data receiver may need to drop DATA chunks that it has received but hasn't released from its receive buffers (i.e., delivered to the ULP). These DATA chunks may have been acked in Gap Ack Blocks. For example, the data receiver may be holding data in its receive buffers while reassembling a fragmented user message from its peer when it runs out of receive buffer space. It may drop these DATA chunks even though it has acknowledged them in Gap Ack Blocks. If a data receiver drops DATA chunks, it MUST NOT include them in Gap Ack Blocks in subsequent SACKs until they are received again via retransmission. In addition, the endpoint should take into account the dropped data when calculating its a_rwnd.",
      "ja": "特定の状況下では、データ受信装置は、受信したが、その受信バッファ（すなわち、ULPに配信）から放出されていないデータチャンクを削除する必要があるかもしれません。これらのデータチャンクはギャップAckブロックにACKされている場合があります。それはバッファスペースを受け取るを使い果たしたときに、そのピアから断片化されたユーザメッセージを再組み立てしながら、例えば、データ受信機は、受信バッファ内のデータを保持することができます。それはギャップAckブロックでそれらを認めているにもかかわらず、これらのデータチャンクを低下することがあります。データ受信がDATAチャンクをドロップした場合、彼らは再送信を経由して再び受信するまで、それ以降の袋にギャップAckブロックにそれらを含めることはできません。そのa_rwndを計算する際に加えて、エンドポイントは考慮にドロップされたデータを取る必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD NOT revoke a SACK and discard data. Only in extreme circumstances should an endpoint use this procedure (such as out of buffer space). The data receiver should take into account that dropping data that has been acked in Gap Ack Blocks can result in suboptimal retransmission strategies in the data sender and thus in suboptimal performance.",
      "ja": "エンドポイントは、SACKを取り消すとデータを破棄すべきではありません。唯一の極端な状況では、エンドポイントは、（例えばバッファ空間のうちのような）この手順を使用しなければなりません。データ受信機は、ギャップAckブロックにACKされたドロップデータは、データ送信側では次善の再送戦略につながるため、次善のパフォーマンスにできることを考慮に入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "The following example illustrates the use of delayed acknowledgements:",
      "ja": "次の例では、遅延確認応答の使用を示しています。"
    },
    {
      "indent": 4,
      "text": "Endpoint A Endpoint Z",
      "ja": "エンドポイントAエンドポイントZ"
    },
    {
      "indent": 4,
      "text": "{App sends 3 messages; strm 0}\nDATA [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)\n(Start T3-rtx timer)",
      "raw": true
    },
    {
      "indent": 4,
      "text": "DATA [TSN=8,Strm=0,Seq=4] ------------> (send ack)\n                              /------- SACK [TSN Ack=8,block=0]\n(cancel T3-rtx timer)  <-----/",
      "raw": true
    },
    {
      "indent": 4,
      "text": "DATA [TSN=9,Strm=0,Seq=5] ------------> (ack delayed)\n(Start T3-rtx timer)\n                                       ...\n                                       {App sends 1 message; strm 1}\n                                       (bundle SACK with DATA)\n                                /----- SACK [TSN Ack=9,block=0] \\\n                               /         DATA [TSN=6,Strm=1,Seq=2]\n(cancel T3-rtx timer)  <------/        (Start T3-rtx timer)",
      "raw": true
    },
    {
      "indent": 4,
      "text": "(ack delayed)\n(send ack)\nSACK [TSN Ack=6,block=0] -------------> (cancel T3-rtx timer)",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 7: Delayed Acknowledgement Example",
      "ja": "図7：遅延確認応答の例"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives a DATA chunk with no user data (i.e., the Length field is set to 16), it MUST send an ABORT with error cause set to \"No User Data\".",
      "ja": "エンドポイントは（すなわち、長さフィールドが16に設定されている）のないデータでデータチャンクを受信した場合、それは「ユーザデータ」に設定し、エラーの原因とABORTを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD NOT send a DATA chunk with no user data part.",
      "ja": "エンドポイントが無いユーザデータ部とのデータチャンクを送るべきではありません。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Processing a Received SACK",
      "section_title": true,
      "ja": "6.2.1。受信したSACKの処理"
    },
    {
      "indent": 3,
      "text": "Each SACK an endpoint receives contains an a_rwnd value. This value represents the amount of buffer space the data receiver, at the time of transmitting the SACK, has left of its total receive buffer space (as specified in the INIT/INIT ACK). Using a_rwnd, Cumulative TSN Ack, and Gap Ack Blocks, the data sender can develop a representation of the peer's receive buffer space.",
      "ja": "エンドポイントが受信した各SACKはa_rwnd値を含んでいます。この値は、データ受信装置は、SACKを送信する時に、その全体の残っているバッファ空間の量を表す（INIT / INIT ACKに指定されている）バッファスペースを受け取ります。 a_rwnd使用して、累積TSN Ackを、そしてギャップAckブロックは、データの送信者は、ピアの受信バッファスペースの表現を開発することができます。"
    },
    {
      "indent": 3,
      "text": "One of the problems the data sender must take into account when processing a SACK is that a SACK can be received out of order. That is, a SACK sent by the data receiver can pass an earlier SACK and be received first by the data sender. If a SACK is received out of order, the data sender can develop an incorrect view of the peer's receive buffer space.",
      "ja": "SACKを処理するときにデータの送信者が考慮しなければならない問題の一つは、SACKは順不同で受信することができるということです。すなわち、以前のSACKを渡すことができ、データ送信者が最初に受信するデータ受信装置によって送信されたSACKです。 SACKは、順不同で受信された場合、データの送信者は、ピアの受信バッファスペースの間違った見解を開発することができます。"
    },
    {
      "indent": 3,
      "text": "Since there is no explicit identifier that can be used to detect out-of-order SACKs, the data sender must use heuristics to determine if a SACK is new.",
      "ja": "アウトオブオーダ袋を検出するために使用することができる明示的な識別子が存在しないので、データ送信者はSACKが新しいかどうかを決定するためのヒューリスティックを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD use the following rules to calculate the rwnd, using the a_rwnd value, the Cumulative TSN Ack, and Gap Ack Blocks in a received SACK.",
      "ja": "エンドポイントは、受信されたSACKでa_rwnd値、累積TSN ACK、及びギャップAckブロックを使用して、RWNDを計算するために次のルールを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "A) At the establishment of the association, the endpoint initializes the rwnd to the Advertised Receiver Window Credit (a_rwnd) the peer specified in the INIT or INIT ACK.",
      "ja": "A）アソシエーションの確立時に、エンドポイントは、アドバタイズ受信ウィンドウクレジット（a_rwnd）INITあるいはINIT ACKに指定されたピアにRWNDを初期化します。"
    },
    {
      "indent": 3,
      "text": "B) Any time a DATA chunk is transmitted (or retransmitted) to a peer, the endpoint subtracts the data size of the chunk from the rwnd of that peer.",
      "ja": "B）ピアへのデータチャンクを送信（または再送信される任意の時間）は、エンドポイントがそのピアのRWNDからチャンクのデータサイズを減算します。"
    },
    {
      "indent": 3,
      "text": "C) Any time a DATA chunk is marked for retransmission, either via T3-rtx timer expiration (Section 6.3.3) or via Fast Retransmit (Section 7.2.4), add the data size of those chunks to the rwnd.",
      "ja": "C）DATAチャンクが再送信のためにマークされているときはいつでも、いずれかのT3-RTXタイマ満了（セクション6.3.3）を介して、または高速再送信（7.2.4項）を介して、RWNDにそれらのチャンクのデータサイズを追加します。"
    },
    {
      "indent": 6,
      "text": "Note: If the implementation is maintaining a timer on each DATA chunk, then only DATA chunks whose timer expired would be marked for retransmission.",
      "ja": "注意：実装はそのタイマーの有効期限が切れ、再送信のためにマークされるだろうのみDATAチャンク、各データチャンクのタイマーを維持している場合。"
    },
    {
      "indent": 3,
      "text": "D) Any time a SACK arrives, the endpoint performs the following:",
      "ja": "D）SACKが到着するたびに、エンドポイントは以下を実行します。"
    },
    {
      "indent": 8,
      "text": "i) If Cumulative TSN Ack is less than the Cumulative TSN Ack\n   Point, then drop the SACK.  Since Cumulative TSN Ack is\n   monotonically increasing, a SACK whose Cumulative TSN Ack is\n   less than the Cumulative TSN Ack Point indicates an out-of-\n   order SACK.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "ii) Set rwnd equal to the newly received a_rwnd minus the number of bytes still outstanding after processing the Cumulative TSN Ack and the Gap Ack Blocks.",
      "ja": "ii）のセットは、新たに受信したa_rwndマイナス累積TSN ACKおよびギャップAckブロックを処理した後、まだ未処理のバイト数に等しいRWND。"
    },
    {
      "indent": 6,
      "text": "iii) If the SACK is missing a TSN that was previously acknowledged via a Gap Ack Block (e.g., the data receiver reneged on the data), then consider the corresponding DATA that might be possibly missing: Count one miss indication towards Fast Retransmit as described in Section 7.2.4, and if no retransmit timer is running for the destination address to which the DATA chunk was originally transmitted, then T3-rtx is started for that destination address.",
      "ja": "ⅲ）SACKが以前ギャップAckブロック（例えば、データ受信機がデータに破っ）を経由して認められたTSNが欠落している場合は、おそらく欠落している可能性があり、対応するデータを考慮してください。説明するように、高速再送信に向けた1つのミス表示をカウント何の再送信タイマーがDATAチャンクが最初に送信されたと宛先アドレスのために実行されていない場合は、セクション7.2.4に、そして、その後、T3-RTXは、その宛先アドレスに対して開始されます。"
    },
    {
      "indent": 7,
      "text": "iv) If the Cumulative TSN Ack matches or exceeds the Fast Recovery exitpoint (Section 7.2.4), Fast Recovery is exited.",
      "ja": "累積TSN Ackは一致するか、高速リカバリexitpoint（第7.2.4項）を超えた場合IV）、高速回復を終了します。"
    },
    {
      "indent": 0,
      "text": "6.3. Management of Retransmission Timer",
      "section_title": true,
      "ja": "6.3。再送信タイマーの管理"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint uses a retransmission timer T3-rtx to ensure data delivery in the absence of any feedback from its peer. The duration of this timer is referred to as RTO (retransmission timeout).",
      "ja": "SCTPエンドポイントは、そのピアからのフィードバックの非存在下でのデータ配信を保証するために、再送タイマT3-RTXを使用します。このタイマーの持続時間は、RTO（再送タイムアウト）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "When an endpoint's peer is multi-homed, the endpoint will calculate a separate RTO for each different destination transport address of its peer endpoint.",
      "ja": "エンドポイントのピアがマルチホームである場合、エンドポイントは、ピアエンドポイントのそれぞれ異なる宛先トランスポート・アドレスの別RTOを計算します。"
    },
    {
      "indent": 3,
      "text": "The computation and management of RTO in SCTP follow closely how TCP manages its retransmission timer. To compute the current RTO, an endpoint maintains two state variables per destination transport address: SRTT (smoothed round-trip time) and RTTVAR (round-trip time variation).",
      "ja": "SCTPにおけるRTOの計算と管理は、TCPが再送タイマを管理して密接にどのように従ってください。 SRTT（平滑化往復時間）とRTTVAR（ラウンドトリップ時間変動）：現在のRTOを計算するために、エンドポイントが宛先トランスポートアドレスごとに2つの状態変数を維持します。"
    },
    {
      "indent": 0,
      "text": "6.3.1. RTO Calculation",
      "section_title": true,
      "ja": "6.3.1。 RTOの計算"
    },
    {
      "indent": 3,
      "text": "The rules governing the computation of SRTT, RTTVAR, and RTO are as follows:",
      "ja": "次のようにSRTT、RTTVAR、およびRTOの計算を管理する規則は、以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "C1) Until an RTT measurement has been made for a packet sent to the given destination transport address, set RTO to the protocol parameter 'RTO.Initial'.",
      "ja": "C1）RTT測定が所与の宛先トランスポートアドレスに送信されたパケットのためになされたものまで、RTOはプロトコルパラメータ「RTO.Initial」に設定。"
    },
    {
      "indent": 3,
      "text": "C2) When the first RTT measurement R is made, set",
      "ja": "C2）最初のRTT計測Rが行われ、組"
    },
    {
      "indent": 8,
      "text": "SRTT <- R,",
      "ja": "SRTT < -  R、"
    },
    {
      "indent": 8,
      "text": "RTTVAR <- R/2, and",
      "ja": "RTTVAR < -  R / 2、及び"
    },
    {
      "indent": 8,
      "text": "RTO <- SRTT + 4 * RTTVAR.",
      "ja": "RTO < - 条件+ 4 * Rttvr。"
    },
    {
      "indent": 3,
      "text": "C3) When a new RTT measurement R' is made, set",
      "ja": "新しいRTT測定R」が行われるC3）、セット"
    },
    {
      "indent": 8,
      "text": "RTTVAR <- (1 - RTO.Beta) * RTTVAR + RTO.Beta * |SRTT - R'|",
      "ja": "Ratatvara < - （1  -  ratobita）* ratatvara + ratobita * | saratata  -  R「|"
    },
    {
      "indent": 8,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 8,
      "text": "SRTT <- (1 - RTO.Alpha) * SRTT + RTO.Alpha * R'",
      "ja": "SRTT < - （1  -  RTO.Alpha）* SRTT + RTO.Alpha * R」"
    },
    {
      "indent": 8,
      "text": "Note: The value of SRTT used in the update to RTTVAR is its value before updating SRTT itself using the second assignment.",
      "ja": "注：RTTVARの更新に使用されるSRTTの値が第2の割り当てを使用してSRTT自身を更新前の値です。"
    },
    {
      "indent": 8,
      "text": "After the computation, update RTO <- SRTT + 4 * RTTVAR.",
      "ja": "SRTT + 4 *のRTTVAR  - 計算した後、RTOを<更新。"
    },
    {
      "indent": 3,
      "text": "C4) When data is in flight and when allowed by rule C5 below, a new RTT measurement MUST be made each round trip. Furthermore, new RTT measurements SHOULD be made no more than once per round trip for a given destination transport address. There are two reasons for this recommendation: First, it appears that measuring more frequently often does not in practice yield any significant benefit [ALLMAN99]; second, if measurements are made more often, then the values of RTO.Alpha and RTO.Beta in rule C3 above should be adjusted so that SRTT and RTTVAR still adjust to changes at roughly the same rate (in terms of how many round trips it takes them to reflect new values) as they would if making only one measurement per round-trip and using RTO.Alpha and RTO.Beta as given in rule C3. However, the exact nature of these adjustments remains a research issue.",
      "ja": "C4）のデータが飛行中であり、以下のルールC5によって許可されたときに、新しいRTT測定は各ラウンドトリップを行わなければなりません。さらに、新しいRTT測定は、所定の宛先トランスポートアドレスには複数回往復ごとになされるべきです。この勧告には2つの理由があります。第一に、より頻繁に頻繁に測定することは実際には任意の重要な利点[ALLMAN99]が得られないことが表示されます。測定がより頻繁に行われる場合SRTTとRTTVARはまだどのように多くのラウンドトリップの点で（ほぼ同じ割合で変化に合わせるように、第2、次いで上記ルールC3におけるRTO.AlphaとRTO.Betaの値を調整しなければならないこと彼らは往復ごとに1つだけの測定を行うと、ルールC3に与えられたようRTO.AlphaとRTO.Betaを使用してしまうかのように）新しい値を反映するためにそれらを取ります。しかし、これらの調整の正確な性質は、研究課題のまま。"
    },
    {
      "indent": 3,
      "text": "C5) Karn's algorithm: RTT measurements MUST NOT be made using packets that were retransmitted (and thus for which it is ambiguous whether the reply was for the first instance of the chunk or for a later instance)",
      "ja": "C5）カーンのアルゴリズム：RTT測定値が再送信されたパケットを使用して作製されてはいけません（したがって、そのため、応答がチャンクの最初のインスタンスまたは後、例えばあったかどうか曖昧です）"
    },
    {
      "indent": 8,
      "text": "IMPLEMENTATION NOTE: RTT measurements should only be made using\na chunk with TSN r if no chunk with TSN less than or equal to r\nis retransmitted since r is first sent.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C6) Whenever RTO is computed, if it is less than RTO.Min seconds then it is rounded up to RTO.Min seconds. The reason for this rule is that RTOs that do not have a high minimum value are susceptible to unnecessary timeouts [ALLMAN99].",
      "ja": "それはそれはRTO.Min秒に切り上げられRTO.Min秒未満の場合RTOは、計算されるたびにC6）。このルールの理由は、高い最小値を持っていないRTOSは不要タイムアウト[ALLMAN99]の影響を受けやすいということです。"
    },
    {
      "indent": 3,
      "text": "C7) A maximum value may be placed on RTO provided it is at least RTO.max seconds.",
      "ja": "C7）の最大値は、RTO上に配置することができる、少なくともRTO.max秒提供されます。"
    },
    {
      "indent": 3,
      "text": "There is no requirement for the clock granularity G used for computing RTT measurements and the different state variables, other than:",
      "ja": "Gは、RTT測定値及び以外の異なる状態変数を計算するために使用されるクロックの粒度のための必要はありません。"
    },
    {
      "indent": 3,
      "text": "G1) Whenever RTTVAR is computed, if RTTVAR = 0, then adjust RTTVAR <- G.",
      "ja": "RTTVARが計算されるたびG1）、RTTVAR = 0の場合、RTTVARを<調整 -  Gを"
    },
    {
      "indent": 3,
      "text": "Experience [ALLMAN99] has shown that finer clock granularities (<= 100 msec) perform somewhat better than more coarse granularities.",
      "ja": "経験は[ALLMAN99]細かいクロック粒度（<= 100ミリ秒）より粗い粒度よりも幾分良好に機能することが示されています。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Retransmission Timer Rules",
      "section_title": true,
      "ja": "6.3.2。再送信タイマーのルール"
    },
    {
      "indent": 3,
      "text": "The rules for managing the retransmission timer are as follows:",
      "ja": "次のように再送タイマーを管理するためのルールは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "R1) Every time a DATA chunk is sent to any address (including a retransmission), if the T3-rtx timer of that address is not running, start it running so that it will expire after the RTO of that address. The RTO used here is that obtained after any doubling due to previous T3-rtx timer expirations on the corresponding destination address as discussed in rule E2 below.",
      "ja": "そのアドレスのT3-RTXタイマーが実行されていない場合R1）（）（再送信を含む）のDATAチャンクが任意のアドレスに送信されるたびに、それがそのアドレスのRTO後に期限切れになるように、それが実行を開始します。 RTOは、ここで使用により以下のルールE2で説明したように対応する宛先アドレスに前T3-RTXタイマーの期限切れに任意の倍加後に得られたということです。"
    },
    {
      "indent": 3,
      "text": "R2) Whenever all outstanding data sent to an address have been acknowledged, turn off the T3-rtx timer of that address.",
      "ja": "R2）たびアドレスに送信されたすべての未処理のデータは、そのアドレスのT3-RTXタイマーをオフにし、承認されています。"
    },
    {
      "indent": 3,
      "text": "R3) Whenever a SACK is received that acknowledges the DATA chunk with the earliest outstanding TSN for that address, restart the T3-rtx timer for that address with its current RTO (if there is still outstanding data on that address).",
      "ja": "R3）SACKが受信されるたびにそれがそのアドレスに対して最も初期の優れたTSNでデータチャンクを認識し、その現在のRTOとそのアドレスのT3-RTXタイマーを再起動します（そのアドレス上の未処理データが残っている場合）。"
    },
    {
      "indent": 3,
      "text": "R4) Whenever a SACK is received missing a TSN that was previously acknowledged via a Gap Ack Block, start the T3-rtx for the destination address to which the DATA chunk was originally transmitted if it is not already running.",
      "ja": "SACKが以前ギャップAckブロックを経て承認されたTSNが欠け受信するたびR4）が、それはまだ実行されていない場合は、DATAチャンクが最初に送信されたと宛先アドレスのT3-RTXを起動します。"
    },
    {
      "indent": 3,
      "text": "The following example shows the use of various timer rules (assuming that the receiver uses delayed acks).",
      "ja": "次の例は、（受信機が遅延ACKを使用すると仮定して）、様々なタイマルールの使用を示します。"
    },
    {
      "indent": 3,
      "text": "Endpoint A                                         Endpoint Z\n{App begins to send}\nData [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)\n(Start T3-rtx timer)\n                                        {App sends 1 message; strm 1}\n                                        (bundle ack with data)\nDATA [TSN=8,Strm=0,Seq=4] ----\\     /-- SACK [TSN Ack=7,Block=0]\n                               \\   /      DATA [TSN=6,Strm=1,Seq=2]\n                                \\ /     (Start T3-rtx timer)\n                                 \\\n                                / \\\n(Restart T3-rtx timer)  <------/   \\--> (ack delayed)\n(ack delayed)\n{send ack}\nSACK [TSN Ack=6,Block=0] --------------> (Cancel T3-rtx timer)\n                                        ..\n                                        (send ack)\n(Cancel T3-rtx timer)  <-------------- SACK [TSN Ack=8,Block=0]",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 8: Timer Rule Examples",
      "ja": "図8：タイマルールの例"
    },
    {
      "indent": 0,
      "text": "6.3.3. Handle T3-rtx Expiration",
      "section_title": true,
      "ja": "6.3.3。 T3-RTXの有効期限を扱います"
    },
    {
      "indent": 3,
      "text": "Whenever the retransmission timer T3-rtx expires for a destination address, do the following:",
      "ja": "再送タイマT3-RTXは、宛先アドレスのために期限が切れるたびに、次の手順を実行します。"
    },
    {
      "indent": 3,
      "text": "E1) For the destination address for which the timer expires, adjust its ssthresh with rules defined in Section 7.2.3 and set the cwnd <- MTU.",
      "ja": "タイマーが期限切れになるために宛先アドレスの場合E1）は、7.2.3項で定義されたルールとそのSSTHRESHを調整し、cwndは<セット -  MTUを。"
    },
    {
      "indent": 3,
      "text": "E2) For the destination address for which the timer expires, set RTO <- RTO * 2 (\"back off the timer\"). The maximum value discussed in rule C7 above (RTO.max) may be used to provide an upper bound to this doubling operation.",
      "ja": "RTO * 2（「バックオフタイマー」） - タイマーが期限切れになるために宛先アドレスのE2）は、<RTOを設定します。 （RTO.max）上記ルールC7で議論最大値は、この倍増操作に上限を提供するために使用され得ます。"
    },
    {
      "indent": 3,
      "text": "E3) Determine how many of the earliest (i.e., lowest TSN) outstanding DATA chunks for the address for which the T3-rtx has expired will fit into a single packet, subject to the MTU constraint for the path corresponding to the destination transport address to which the retransmission is being sent (this may be different from the address for which the timer expires; see Section 6.4). Call this value K. Bundle and retransmit those K DATA chunks in a single packet to the destination endpoint.",
      "ja": "E3））T3-RTXの有効期限が切れているアドレスのための優れたDATAチャンクが先輸送アドレスに対応するパスのMTUの制約を受け、単一のパケットに収まるどのように多くの早い（すなわち、最低のTSNの決定再送が送信されている（これはタイマーが期限切れになるためのアドレスと異なる場合があり、6.4節を参照してください）。この値K.バンドルを呼び出して、宛先エンドポイントに単一のパケットでそれらのK DATAチャンクを再送します。"
    },
    {
      "indent": 3,
      "text": "E4) Start the retransmission timer T3-rtx on the destination address to which the retransmission is sent, if rule R1 above indicates to do so. The RTO to be used for starting T3-rtx should be the one for the destination address to which the retransmission is sent, which, when the receiver is multi-homed, may be different from the destination address for which the timer expired (see Section 6.4 below).",
      "ja": "ルールR1は、上記そうすることを示している場合E4）、再送が送信された送信先アドレスに再送タイマT3-RTXを起動します。 RTOは、タイマが満了したため、宛先アドレスと異なる場合があり、受信機は、マルチホームで、再送が送信される宛先アドレスのためのものであるべきであるT3-RTXを開始するために使用される（セクションを参照下記6.4）。"
    },
    {
      "indent": 3,
      "text": "After retransmitting, once a new RTT measurement is obtained (which can happen only when new data has been sent and acknowledged, per rule C5, or for a measurement made from a HEARTBEAT; see Section 8.3), the computation in rule C3 is performed, including the computation of RTO, which may result in \"collapsing\" RTO back down after it has been subject to doubling (rule E2).",
      "ja": "新たなRTT測定が（ルールC5あたり、またはHEARTBEATから作られた測定のために、新たなデータが送信され、承認された場合にのみ起こることができる;セクション8.3を参照）得られたら再送信した後、ルールC3における計算は、実行されますそれは（E2ルール）倍加を受けた後にバックダウンRTOを「崩壊」をもたらす可能性がRTOの計算を含みます。"
    },
    {
      "indent": 3,
      "text": "Note: Any DATA chunks that were sent to the address for which the T3-rtx timer expired but did not fit in one MTU (rule E3 above) should be marked for retransmission and sent as soon as cwnd allows (normally, when a SACK arrives).",
      "ja": "注意：T3-RTXタイマーが満了したが1 MTU（上記のE3を支配する）は、再送信のためにマークとすぐにcwndは通常（許す限り、SACKが到着したときに送信されるべきでは収まらなかったのアドレスに送信された任意のデータチャンクを）。"
    },
    {
      "indent": 3,
      "text": "The final rule for managing the retransmission timer concerns failover (see Section 6.4.1):",
      "ja": "再送タイマの懸念のフェイルオーバーを管理するための最終規則（6.4.1項を参照してください）："
    },
    {
      "indent": 3,
      "text": "F1) Whenever an endpoint switches from the current destination transport address to a different one, the current retransmission timers are left running. As soon as the endpoint transmits a packet containing DATA chunk(s) to the new transport address, start the timer on that transport address, using the RTO value of the destination address to which the data is being sent, if rule R1 indicates to do so.",
      "ja": "F1）別のものに現在の宛先トランスポートアドレスからたびに、エンドポイントスイッチは、現在の再送タイマーが動作して残されています。エンドポイントが新しいトランスポートアドレスへのデータチャンク（複数可）を含むパケットを送信するとすぐに、ルールR1が何を示している場合、データが送信された宛先アドレスのRTO値を用いて、そのトランスポートアドレスにタイマーをスタートそう。"
    },
    {
      "indent": 0,
      "text": "6.4. Multi-Homed SCTP Endpoints",
      "section_title": true,
      "ja": "6.4。マルチホームSCTPエンドポイント"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint is considered multi-homed if there are more than one transport address that can be used as a destination address to reach that endpoint.",
      "ja": "そのエンドポイントに到達するために宛先アドレスとして使用することができる複数のトランスポート・アドレスがある場合SCTPエンドポイントがマルチホームであると考えられます。"
    },
    {
      "indent": 3,
      "text": "Moreover, the ULP of an endpoint shall select one of the multiple destination addresses of a multi-homed peer endpoint as the primary path (see Section 5.1.2 and Section 10.1 for details).",
      "ja": "また、エンドポイントのULPがプライマリパスとしてマルチホームピアエンドポイントの複数の宛先アドレスのいずれかを選択しなければならない（詳細については、セクション5.1.2及びセクション10.1を参照）。"
    },
    {
      "indent": 3,
      "text": "By default, an endpoint SHOULD always transmit to the primary path, unless the SCTP user explicitly specifies the destination transport address (and possibly source transport address) to use.",
      "ja": "SCTPユーザが明示的に使用するための宛先トランスポートアドレス（およびおそらくソーストランスポートアドレス）を指定しない限り、デフォルトでは、エンドポイントは常に、プライマリパスに送信しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK, etc.) to the same destination transport address from which it received the DATA or control chunk to which it is replying. This rule should also be followed if the endpoint is bundling DATA chunks together with the reply chunk.",
      "ja": "エンドポイントは、それが返信されたデータまたは制御チャンクを受け、そこから同じ宛先トランスポートアドレスへ（例えば、SACK、HEARTBEAT ACK等）を返信チャンクを送信しなければなりません。エンドポイントが応答チャンクと一緒DATAチャンクをバンドルされている場合は、このルールにも従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "However, when acknowledging multiple DATA chunks received in packets from different source addresses in a single SACK, the SACK chunk may be transmitted to one of the destination transport addresses from which the DATA or control chunks being acknowledged were received.",
      "ja": "単一のSACKに異なる送信元アドレスからのパケットで受信した複数のデータチャンクを認める場合しかし、SACKチャンクは、データまたは制御チャンクが受信された肯定応答され、そこから先輸送アドレスの1つに送信することができます。"
    },
    {
      "indent": 3,
      "text": "When a receiver of a duplicate DATA chunk sends a SACK to a multi-homed endpoint, it MAY be beneficial to vary the destination address and not use the source address of the DATA chunk. The reason is that receiving a duplicate from a multi-homed endpoint might indicate that the return path (as specified in the source address of the DATA chunk) for the SACK is broken.",
      "ja": "重複データチャンクの受信機は、マルチホームエンドポイントにSACKを送信すると、宛先アドレスを変更し、DATAチャンクの送信元アドレスを使用しないことが有益であり得ます。その理由は、マルチホームのエンドポイントからの複製を受信するためのSACK（DATAチャンクの送信元アドレスで指定されるように）、リターンパスが切断されたことを示す可能性があることです。"
    },
    {
      "indent": 3,
      "text": "Furthermore, when its peer is multi-homed, an endpoint SHOULD try to retransmit a chunk that timed out to an active destination transport address that is different from the last destination address to which the DATA chunk was sent.",
      "ja": "そのピアがマルチホームである場合さらに、エンドポイントは、データチャンクが送信されたために、最後の宛先アドレスと異なるアクティブ宛先トランスポートアドレスにタイムアウトチャンクを再送するようにしてください。"
    },
    {
      "indent": 3,
      "text": "Retransmissions do not affect the total outstanding data count. However, if the DATA chunk is retransmitted onto a different destination address, both the outstanding data counts on the new destination address and the old destination address to which the data chunk was last sent shall be adjusted accordingly.",
      "ja": "再送は、発行済データ数には影響を与えません。データチャンクが異なる宛先アドレスに再送された場合は、新しい宛先アドレスとデータチャンクが最後に送られたために、古い宛先アドレスに優れたデータ数の両方が相応に調整されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.4.1. Failover from an Inactive Destination Address",
      "section_title": true,
      "ja": "6.4.1。非アクティブな宛先アドレスからのフェイルオーバー"
    },
    {
      "indent": 3,
      "text": "Some of the transport addresses of a multi-homed SCTP endpoint may become inactive due to either the occurrence of certain error conditions (see Section 8.2) or adjustments from the SCTP user.",
      "ja": "マルチホームSCTPエンドポイントのトランスポート・アドレスの一部が原因特定のエラー条件が発生した（セクション8.2を参照）又はSCTPユーザからの調整のいずれかに非アクティブになることがあります。"
    },
    {
      "indent": 3,
      "text": "When there is outbound data to send and the primary path becomes inactive (e.g., due to failures), or where the SCTP user explicitly requests to send data to an inactive destination transport address, before reporting an error to its ULP, the SCTP endpoint should try to send the data to an alternate active destination transport address if one exists.",
      "ja": "ある場合、アウトバウンドデータは、送信するために、プライマリパスが（による故障に、例えば）非アクティブになる、またはSCTPのユーザーが明示的にULPにエラーを報告する前に、非アクティブ先輸送アドレスにデータを送信するために要求したところ、SCTP終点がすべき1が存在する場合は、代替アクティブ先輸送アドレスにデータを送信してみてください。"
    },
    {
      "indent": 3,
      "text": "When retransmitting data that timed out, if the endpoint is multi-homed, it should consider each source-destination address pair in its retransmission selection policy. When retransmitting timed-out data, the endpoint should attempt to pick the most divergent source-destination pair from the original source-destination pair to which the packet was transmitted.",
      "ja": "エンドポイントは、マルチホームの場合は、タイムアウトしたデータを再送すると、その再選択ポリシー内の各ソース先のアドレスのペアを検討すべきです。タイムアウトデータを再送する場合、エンドポイントは、パケットが送信された元の送信元と宛先のペアから最も発散ソースと宛先のペアを選択することを試みるべきです。"
    },
    {
      "indent": 3,
      "text": "Note: Rules for picking the most divergent source-destination pair are an implementation decision and are not specified within this document.",
      "ja": "注：ほとんどの発散元と宛先のペアを選ぶための規則は、実装の決定であり、この文書内で指定されていません。"
    },
    {
      "indent": 0,
      "text": "6.5. Stream Identifier and Stream Sequence Number",
      "section_title": true,
      "ja": "6.5。ストリーム識別子とストリームシーケンス番号"
    },
    {
      "indent": 3,
      "text": "Every DATA chunk MUST carry a valid stream identifier. If an endpoint receives a DATA chunk with an invalid stream identifier, it shall acknowledge the reception of the DATA chunk following the normal procedure, immediately send an ERROR chunk with cause set to \"Invalid Stream Identifier\" (see Section 3.3.10), and discard the DATA chunk. The endpoint may bundle the ERROR chunk in the same packet as the SACK as long as the ERROR follows the SACK.",
      "ja": "すべてのデータ・チャンクは有効なストリーム識別子を運ばなければなりません。エンドポイントが無効なストリーム識別子とデータチャンクを受信した場合、それはすぐに「無効なストリーム識別子」に設定し、原因とERRORチャンクを送って、通常の手順以下のDATAチャンクの受信を確認しなければならない（セクション3.3.10を参照）、およびデータチャンクを破棄します。エンドポイントは、限りERRORがSACKを次のようにSACKと同じパケットにERRORチャンクをバンドルすることがあります。"
    },
    {
      "indent": 3,
      "text": "The Stream Sequence Number in all the streams MUST start from 0 when the association is established. Also, when the Stream Sequence Number reaches the value 65535 the next Stream Sequence Number MUST be set to 0.",
      "ja": "アソシエーションが確立されると、すべてのストリーム内のストリームシーケンス番号は0から開始しなければなりません。ストリームシーケンス番号が値65535に到達したときにも、次のストリームシーケンス番号が0に設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.6. Ordered and Unordered Delivery",
      "section_title": true,
      "ja": "6.6。注文して順不同配信"
    },
    {
      "indent": 3,
      "text": "Within a stream, an endpoint MUST deliver DATA chunks received with the U flag set to 0 to the upper layer according to the order of their Stream Sequence Number. If DATA chunks arrive out of order of their Stream Sequence Number, the endpoint MUST hold the received DATA chunks from delivery to the ULP until they are reordered.",
      "ja": "ストリーム内で、エンドポイントは、そのストリーム・シーケンス番号の順序に従って上位階層に0に設定Uフラグで受信したデータチャンクを供給しなければなりません。 DATAチャンクが自分のストリームシーケンス番号の順不同で到着した場合、彼らは並べ替えされるまで、エンドポイントは、ULPへの配信から受信したデータチャンクを保持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "However, an SCTP endpoint can indicate that no ordered delivery is required for a particular DATA chunk transmitted within the stream by setting the U flag of the DATA chunk to 1.",
      "ja": "しかしながら、SCTPエンドポイントには順序付けられた配信が1へのデータチャンクのUフラグを設定することにより、ストリーム内で送信特定のデータチャンクのために必要とされないことを示すことができます。"
    },
    {
      "indent": 3,
      "text": "When an endpoint receives a DATA chunk with the U flag set to 1, it must bypass the ordering mechanism and immediately deliver the data to the upper layer (after reassembly if the user data is fragmented by the data sender).",
      "ja": "エンドポイントが1にセットUフラグでデータチャンクを受信すると、順序付けメカニズムを迂回しなければならないし、直ちに（ユーザデータは、データ送信側によって断片化された場合に再組立後）上位層にデータを配信します。"
    },
    {
      "indent": 3,
      "text": "This provides an effective way of transmitting \"out-of-band\" data in a given stream. Also, a stream can be used as an \"unordered\" stream by simply setting the U flag to 1 in all DATA chunks sent through that stream.",
      "ja": "これは、指定されたストリームの「アウトオブバンド」データを送信するのに有効な方法を提供します。また、ストリームは、単に、そのストリームを介して送信されるすべてのデータチャンク1にUフラグを設定することにより、「無秩序」ストリームとして使用することができます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: When sending an unordered DATA chunk, an implementation may choose to place the DATA chunk in an outbound packet that is at the head of the outbound transmission queue if possible.",
      "ja": "実装上の注意：順不同のデータチャンクを送信する場合、実装が可能な場合はアウトバウンド送信キューの先頭にあるアウトバウンドパケット内のデータのチャンクを配置することもできます。"
    },
    {
      "indent": 3,
      "text": "The 'Stream Sequence Number' field in a DATA chunk with U flag set to 1 has no significance. The sender can fill it with arbitrary value, but the receiver MUST ignore the field.",
      "ja": "1に設定Uフラグ付きデータチャンクに「ストリームシーケンス番号」フィールドには意味を持ちません。送信者は、任意の値でそれを埋めることができますが、受信機は、フィールドを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: When transmitting ordered and unordered data, an endpoint does not increment its Stream Sequence Number when transmitting a DATA chunk with U flag set to 1.",
      "ja": "注：注文し、順不同のデータを送信するときに1にセットUフラグ付きデータチャンクを送信する場合、エンドポイントはそのストリームシーケンス番号をインクリメントしません。"
    },
    {
      "indent": 0,
      "text": "6.7. Report Gaps in Received DATA TSNs",
      "section_title": true,
      "ja": "6.7。受信したデータのTSNでレポートギャップ"
    },
    {
      "indent": 3,
      "text": "Upon the reception of a new DATA chunk, an endpoint shall examine the continuity of the TSNs received. If the endpoint detects a gap in the received DATA chunk sequence, it SHOULD send a SACK with Gap Ack Blocks immediately. The data receiver continues sending a SACK after receipt of each SCTP packet that doesn't fill the gap.",
      "ja": "新しいデータチャンクを受信すると、エンドポイントは受け取ったTSNの継続性を検査しなければなりません。エンドポイントが受信したデータチャンクのシーケンスにおけるギャップを検出した場合、それは直ちにギャップAckブロックとSACKを送信すべきです。データ受信装置は、ギャップを埋めるない各SCTPパケットの受信後にSACKを送信し続けます。"
    },
    {
      "indent": 3,
      "text": "Based on the Gap Ack Block from the received SACK, the endpoint can calculate the missing DATA chunks and make decisions on whether to retransmit them (see Section 6.2.1 for details).",
      "ja": "受信SACKからのギャップAckブロックに基づいて、エンドポイントが欠落したデータチャンクを計算します（詳細は6.2.1項を参照）、それらを再送信するかどうかの決定を行うことができます。"
    },
    {
      "indent": 3,
      "text": "Multiple gaps can be reported in one single SACK (see Section 3.3.4).",
      "ja": "複数のギャップが1つのSACK（セクション3.3.4を参照）で報告することができます。"
    },
    {
      "indent": 3,
      "text": "When its peer is multi-homed, the SCTP endpoint SHOULD always try to send the SACK to the same destination address from which the last DATA chunk was received.",
      "ja": "そのピアがマルチホームである場合には、SCTP終点は、常に最後のDATAチャンクを受信した同じ宛先アドレスにSACKを送信しようとする必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon the reception of a SACK, the endpoint MUST remove all DATA chunks that have been acknowledged by the SACK's Cumulative TSN Ack from its transmit queue. The endpoint MUST also treat all the DATA chunks with TSNs not included in the Gap Ack Blocks reported by the SACK as \"missing\". The number of \"missing\" reports for each outstanding DATA chunk MUST be recorded by the data sender in order to make retransmission decisions. See Section 7.2.4 for details.",
      "ja": "SACKを受信すると、エンドポイントは、その送信キューからSACKの累積TSN Ackをによって承認されているすべてのデータのチャンクを削除する必要があります。エンドポイントは「行方不明」としてSACKで報告されたギャップAckブロックに含まれていないのTSNを持つすべてのデータの塊を扱わなければなりません。それぞれの未処理データのチャンクの「行方不明」報告書の数には再送信の意思決定を行うために、データの送信者を記録しなければなりません。詳細については、第7.2.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The following example shows the use of SACK to report a gap.",
      "ja": "次の例では、ギャップを報告するSACKの使用を示します。"
    },
    {
      "indent": 7,
      "text": "Endpoint A                                    Endpoint Z {App\nsends 3 messages; strm 0} DATA [TSN=6,Strm=0,Seq=2] ----------\n-----> (ack delayed) (Start T3-rtx timer)",
      "raw": true
    },
    {
      "indent": 7,
      "text": "DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)",
      "raw": true
    },
    {
      "indent": 7,
      "text": "DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,\n                                            immediately send ack)\n                                /----- SACK [TSN Ack=6,Block=1,\n                               /             Start=2,End=2]\n                        <-----/ (remove 6 from out-queue,\n and mark 7 as \"1\" missing report)",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 9: Reporting a Gap using SACK",
      "ja": "図9：SACKを使用してギャップを報告"
    },
    {
      "indent": 3,
      "text": "The maximum number of Gap Ack Blocks that can be reported within a single SACK chunk is limited by the current path MTU. When a single SACK cannot cover all the Gap Ack Blocks needed to be reported due to the MTU limitation, the endpoint MUST send only one SACK, reporting the Gap Ack Blocks from the lowest to highest TSNs, within the size limit set by the MTU, and leave the remaining highest TSN numbers unacknowledged.",
      "ja": "単一のSACKチャンク内に報告することができるギャップAckブロックの最大数は、現在のパスMTUによって制限されます。単一のSACKが原因MTU制限に報告するために必要なすべてのギャップAckブロックをカバーすることができない場合、エンドポイントは、MTUによって設定されたサイズ制限内で、最低から最高のTSNにギャップAckブロックを報告し、一つだけSACKを送らなければなりませんそして未確認の残りの最高TSN番号を残します。"
    },
    {
      "indent": 0,
      "text": "6.8. CRC32c Checksum Calculation",
      "section_title": true,
      "ja": "6.8。 CRC32Cチェックサムの計算"
    },
    {
      "indent": 3,
      "text": "When sending an SCTP packet, the endpoint MUST strengthen the data integrity of the transmission by including the CRC32c checksum value calculated on the packet, as described below.",
      "ja": "SCTPパケットを送信するとき、以下に記載されるように、エンドポイントは、パケットで計算CRC32Cチェックサム値を含むことによって、送信のデータの整合性を強化しなければなりません。"
    },
    {
      "indent": 3,
      "text": "After the packet is constructed (containing the SCTP common header and one or more control or DATA chunks), the transmitter MUST",
      "ja": "パケットが構築された後、送信機MUST（SCTP共通ヘッダと1つ以上の制御またはDATAチャンクを含みます）"
    },
    {
      "indent": 3,
      "text": "1) fill in the proper Verification Tag in the SCTP common header and initialize the checksum field to '0's,",
      "ja": "1）、SCTP共通ヘッダに適切な検証タグを記入し、「0年代にチェックサムフィールドを初期化します"
    },
    {
      "indent": 3,
      "text": "2) calculate the CRC32c checksum of the whole packet, including the SCTP common header and all the chunks (refer to Appendix B for details of the CRC32c algorithm); and",
      "ja": "2）SCTP共通ヘッダとすべてのチャンク（CRC32Cアルゴリズムの詳細については、付録Bを参照）を含む、パケット全体のCRC32Cチェックサムを計算します。そして"
    },
    {
      "indent": 3,
      "text": "3) put the resultant value into the checksum field in the common header, and leave the rest of the bits unchanged.",
      "ja": "3）共通ヘッダ内のチェックサムフィールドにその値を入れ、そして不変のビットの残りの部分を残します。"
    },
    {
      "indent": 3,
      "text": "When an SCTP packet is received, the receiver MUST first check the CRC32c checksum as follows:",
      "ja": "SCTPパケットが受信されると、以下のように、受信機は、第CRC32Cチェックサムをチェックしなければなりません。"
    },
    {
      "indent": 3,
      "text": "1) Store the received CRC32c checksum value aside.",
      "ja": "1）脇受信CRC32Cチェックサムの値を格納します。"
    },
    {
      "indent": 3,
      "text": "2) Replace the 32 bits of the checksum field in the received SCTP packet with all '0's and calculate a CRC32c checksum value of the whole received packet.",
      "ja": "2）全て「0で受信SCTPパケット内のチェックサムフィールドの32ビットを置き換え、パケットを受信した全体のCRC32Cチェックサム値を計算します。"
    },
    {
      "indent": 3,
      "text": "3) Verify that the calculated CRC32c checksum is the same as the received CRC32c checksum. If it is not, the receiver MUST treat the packet as an invalid SCTP packet.",
      "ja": "3）計算CRC32Cチェックサムは、受信CRC32Cチェックサムと同じであることを確認します。そうでない場合、受信機は、無効なSCTPパケットとしてパケットを扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "The default procedure for handling invalid SCTP packets is to silently discard them.",
      "ja": "無効なSCTPパケットを処理するためのデフォルトの手順は静かにそれらを捨てることです。"
    },
    {
      "indent": 3,
      "text": "Any hardware implementation SHOULD be done in a way that is verifiable by the software.",
      "ja": "任意のハードウェア実装は、ソフトウェアによって検証可能な方法で行うべきです。"
    },
    {
      "indent": 0,
      "text": "6.9. Fragmentation and Reassembly",
      "section_title": true,
      "ja": "6.9。フラグメンテーションおよび再構成"
    },
    {
      "indent": 3,
      "text": "An endpoint MAY support fragmentation when sending DATA chunks, but it MUST support reassembly when receiving DATA chunks. If an endpoint supports fragmentation, it MUST fragment a user message if the size of the user message to be sent causes the outbound SCTP packet size to exceed the current MTU. If an implementation does not support fragmentation of outbound user messages, the endpoint MUST return an error to its upper layer and not attempt to send the user message.",
      "ja": "DATAチャンクを送信するときに、エンドポイントは、断片化をサポートするかもしれませんが、データのチャンクを受信したときには、再構築をサポートしなければなりません。エンドポイントが断片化をサポートしている場合、ユーザ・メッセージのサイズが現在のMTUを超える発信SCTPパケットサイズを引き起こす送信する場合には、ユーザメッセージを断片化しなければなりません。実装は、発信ユーザメッセージの断片化をサポートしていない場合、エンドポイントは、その上位層にエラーを返すと、ユーザーのメッセージを送信しようとしないしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: If an implementation that supports fragmentation makes available to its upper layer a mechanism to turn off fragmentation, it may do so. However, in so doing, it MUST react just like an implementation that does NOT support fragmentation, i.e., it MUST reject sends that exceed the current Path MTU (P-MTU).",
      "ja": "注：断片化をサポートする実装は、断片化をオフにするために、その上位層にメカニズムを利用できるようにした場合、それはそうすることがあります。しかし、そうすることで、それだけフラグメンテーションをサポートしていない実装、すなわち、それは現在のパスMTU（P-MTU）を超えること送信拒絶しなければなりませんように反応しなければなりません。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In this error case, the Send primitive discussed in Section 10.1 would need to return an error to the upper layer.",
      "ja": "実装上の注意：このエラー場合は、10.1節で論じ送信プリミティブは、上位層にエラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If its peer is multi-homed, the endpoint shall choose a size no larger than the association Path MTU. The association Path MTU is the smallest Path MTU of all destination addresses.",
      "ja": "そのピアがマルチホームである場合、エンドポイントは、アソシエーションのパスMTUよりも大きくないサイズを選択しなければなりません。関連パスMTUは、すべての宛先アドレスの最小のパスMTUです。"
    },
    {
      "indent": 3,
      "text": "Note: Once a message is fragmented, it cannot be re-fragmented. Instead, if the PMTU has been reduced, then IP fragmentation must be used. Please see Section 7.3 for details of PMTU discovery.",
      "ja": "注：メッセージが断片化されたら、それは再断片化することはできません。 PMTUが減少した場合には代わりに、その後、IPフラグメンテーションを使用する必要があります。 PMTU発見の詳細については、セクション7.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "When determining when to fragment, the SCTP implementation MUST take into account the SCTP packet header as well as the DATA chunk header(s). The implementation MUST also take into account the space required for a SACK chunk if bundling a SACK chunk with the DATA chunk.",
      "ja": "断片化するときを決定するときに、SCTPの実装を考慮にSCTPパケットヘッダとデータチャンクヘッダ（単数または複数）を取らなければなりません。また、実装は、アカウントへのデータの塊でSACKチャンクをバンドルする場合はSACKチャンクに必要なスペースを取る必要があります。"
    },
    {
      "indent": 3,
      "text": "Fragmentation takes the following steps:",
      "ja": "断片化は、以下の手順を実行します。"
    },
    {
      "indent": 3,
      "text": "1) The data sender MUST break the user message into a series of DATA chunks such that each chunk plus SCTP overhead fits into an IP datagram smaller than or equal to the association Path MTU.",
      "ja": "1）データ送信側は、各チャンクプラスSCTPオーバーヘッドがアソシエーションパスMTU以下でIPデータグラムに収まるように、データチャンクのシリーズにユーザメッセージを破壊しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2) The transmitter MUST then assign, in sequence, a separate TSN to each of the DATA chunks in the series. The transmitter assigns the same SSN to each of the DATA chunks. If the user indicates that the user message is to be delivered using unordered delivery, then the U flag of each DATA chunk of the user message MUST be set to 1.",
      "ja": "2）次に、送信機は、シーケンスで、一連のデータのチャンクのそれぞれに別々のTSNを割り当てる必要があります。送信機は、データのチャンクのそれぞれに同じSSNを割り当てます。ユーザがメッセージは順不同配信を使用して配信されることを示している場合、ユーザ・メッセージの各データチャンクのUフラグが1に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "3) The transmitter MUST also set the B/E bits of the first DATA chunk in the series to '10', the B/E bits of the last DATA chunk in the series to '01', and the B/E bits of all other DATA chunks in the series to '00'.",
      "ja": "3）送信機はまた、「10」、「01」に直列に最後のデータチャンクのB / Eビットの系列の最初のデータチャンクのB / Eビットを設定しなければなりません、そしてB / Eビットの「00」にシリーズの他のすべてのデータの塊。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST recognize fragmented DATA chunks by examining the B/E bits in each of the received DATA chunks, and queue the fragmented DATA chunks for reassembly. Once the user message is reassembled, SCTP shall pass the reassembled user message to the specific stream for possible reordering and final dispatching.",
      "ja": "エンドポイントは、受信したデータチャンクの各々にB / Eビットを調べることによって断片化されたデータチャンクを認識、および再組み立てのために断片化されたデータチャンクをキューイングしなければいけません。ユーザメッセージが再組み立てされると、SCTPは可能並べ替え、最終的なディスパッチのために特定のストリームに再組み立てユーザメッセージを合格しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: If the data receiver runs out of buffer space while still waiting for more fragments to complete the reassembly of the message, it should dispatch part of its inbound message through a partial delivery API (see Section 10), freeing some of its receive buffer space so that the rest of the message may be received.",
      "ja": "データ受信バッファ領域が不足すると、まだメッセージの再組み立てを完了するために複数の断片を待っている間、それは部分的に配信APIを介して受信メッセージの一部を派遣すべきである（セクション10を参照）、その受信バッファの一部を解放します。注メッセージの残りの部分を受信することができるようにスペース。"
    },
    {
      "indent": 0,
      "text": "6.10. Bundling",
      "section_title": true,
      "ja": "6.10。バンドル"
    },
    {
      "indent": 3,
      "text": "An endpoint bundles chunks by simply including multiple chunks in one outbound SCTP packet. The total size of the resultant IP datagram,",
      "ja": "エンドポイントは、単に1つのアウトバウンドSCTPパケットで複数のチャンクを含むことにより、チャンクをバンドルしています。結果としてIPデータグラムの合計サイズ、"
    },
    {
      "indent": 3,
      "text": "including the SCTP packet and IP headers, MUST be less that or equal to the current Path MTU.",
      "ja": "SCTPパケットとIPヘッダを含む、より少ないこと、または現在のパスMTUに等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "If its peer endpoint is multi-homed, the sending endpoint shall choose a size no larger than the latest MTU of the current primary path.",
      "ja": "そのピアエンドポイントは、マルチホームである場合、送信側エンドポイントは、現在のプライマリパスの最新のMTUよりも大きくないサイズを選択しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When bundling control chunks with DATA chunks, an endpoint MUST place control chunks first in the outbound SCTP packet. The transmitter MUST transmit DATA chunks within an SCTP packet in increasing order of TSN.",
      "ja": "DATAチャンクと制御チャンクをバンドルする場合、エンドポイントは、アウトバウンドSCTPパケットに第一の制御塊を置かなければなりません。送信機は、TSNの昇順にSCTPパケット内のデータチャンクを送信しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: Since control chunks must be placed first in a packet and since DATA chunks must be transmitted before SHUTDOWN or SHUTDOWN ACK chunks, DATA chunks cannot be bundled with SHUTDOWN or SHUTDOWN ACK chunks.",
      "ja": "注：コントロールチャンクはパケット内に最初に配置されなければならないのでDATAチャンクはSHUTDOWNまたはSHUTDOWN ACKチャンクの前に送信されなければならないので、データチャンクはSHUTDOWNまたはSHUTDOWN ACKチャンクにバンドルすることはできません。"
    },
    {
      "indent": 3,
      "text": "Partial chunks MUST NOT be placed in an SCTP packet. A partial chunk is a chunk that is not completely contained in the SCTP packet; i.e., the SCTP packet is too short to contain all the bytes of the chunk as indicated by the chunk length.",
      "ja": "部分的なチャンクはSCTPパケットには設置しないでください。部分的なチャンクは完全にSCTPパケットに含まれていないチャンクです。すなわち、SCTPパケットは、チャンクの長さによって示されるように、チャンクのすべてのバイトを含むには短すぎます。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST process received chunks in their order in the packet. The receiver uses the Chunk Length field to determine the end of a chunk and beginning of the next chunk taking account of the fact that all chunks end on a 4-byte boundary. If the receiver detects a partial chunk, it MUST drop the chunk.",
      "ja": "エンドポイントMUSTプロセスは、パケット内の順序でチャンクを受け取りました。受信機は、すべてのチャンクが4バイト境界で終わるという事実を考慮して次のチャンクのチャンクと始まりの終わりを決定するためにチャンク長フィールドを使用しています。受信機は、部分的チャンクを検出した場合、それは塊を落とさなければなりません。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST NOT bundle INIT, INIT ACK, or SHUTDOWN COMPLETE with any other chunks.",
      "ja": "エンドポイントは、INIT、INIT ACK、または任意の他のチャンクとの完全なシャットダウンをバンドルしてはなりません。"
    },
    {
      "indent": 0,
      "text": "7. Congestion Control",
      "section_title": true,
      "ja": "7.輻輳制御"
    },
    {
      "indent": 3,
      "text": "Congestion control is one of the basic functions in SCTP. For some applications, it may be likely that adequate resources will be allocated to SCTP traffic to ensure prompt delivery of time-critical data -- thus, it would appear to be unlikely, during normal operations, that transmissions encounter severe congestion conditions. However, SCTP must operate under adverse operational conditions, which can develop upon partial network failures or unexpected traffic surges. In such situations, SCTP must follow correct congestion control steps to recover from congestion quickly in order to get data delivered as soon as possible. In the absence of network congestion, these preventive congestion control algorithms should show no impact on the protocol performance.",
      "ja": "輻輳制御はSCTPの基本的な機能の一つです。一部のアプリケーションでは、十分なリソースがタイムクリティカルなデータの迅速な配達を保証するために、SCTPトラフィックに割り当てられる可能性が高いかもしれ - したがって、送信が厳しい混雑状況に遭遇することを、通常の操作中に、そうであるように思われます。ただし、SCTPは、部分的なネットワーク障害や予期せぬトラフィックの急増時に開発することができる不利な動作条件の下で動作する必要があります。このような状況で、SCTPはできるだけ早く配信されるデータを得るために迅速輻輳から回復するために正しい輻輳制御手順を実行する必要があります。ネットワーク輻輳の不在下では、これらの予防輻輳制御アルゴリズムは、プロトコルのパフォーマンスに影響を示さないはずです。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: As far as its specific performance requirements are met, an implementation is always allowed to adopt a more conservative congestion control algorithm than the one defined below.",
      "ja": "実装上の注意：限り、その特定の性能要件が満たされているとして、実装は常に、以下に定義するものよりも保守的な輻輳制御アルゴリズムを採用することを許可されています。"
    },
    {
      "indent": 3,
      "text": "The congestion control algorithms used by SCTP are based on [RFC2581]. This section describes how the algorithms defined in [RFC2581] are adapted for use in SCTP. We first list differences in protocol designs between TCP and SCTP, and then describe SCTP's congestion control scheme. The description will use the same terminology as in TCP congestion control whenever appropriate.",
      "ja": "SCTPによって使用される輻輳制御アルゴリズムは[RFC2581]に基づいています。このセクションでは、[RFC2581]で定義されたアルゴリズムはSCTPにおける使用のために適合されている方法を説明します。私たちはTCPとSCTPの間のプロトコル設計における最初のリストの違い、そしてSCTPの輻輳制御方式を説明します。いつでも適切な説明は、TCPの輻輳制御と同じ用語を使用します。"
    },
    {
      "indent": 3,
      "text": "SCTP congestion control is always applied to the entire association, and not to individual streams.",
      "ja": "SCTP輻輳制御常に全体会合にはなく、個々のストリームに適用されます。"
    },
    {
      "indent": 0,
      "text": "7.1. SCTP Differences from TCP Congestion Control",
      "section_title": true,
      "ja": "7.1。 TCPの輻輳制御からSCTPの違い"
    },
    {
      "indent": 3,
      "text": "Gap Ack Blocks in the SCTP SACK carry the same semantic meaning as the TCP SACK. TCP considers the information carried in the SACK as advisory information only. SCTP considers the information carried in the Gap Ack Blocks in the SACK chunk as advisory. In SCTP, any DATA chunk that has been acknowledged by SACK, including DATA that arrived at the receiving end out of order, is not considered fully delivered until the Cumulative TSN Ack Point passes the TSN of the DATA chunk (i.e., the DATA chunk has been acknowledged by the Cumulative TSN Ack field in the SACK). Consequently, the value of cwnd controls the amount of outstanding data, rather than (as in the case of non-SACK TCP) the upper bound between the highest acknowledged sequence number and the latest DATA chunk that can be sent within the congestion window. SCTP SACK leads to different implementations of Fast Retransmit and Fast Recovery than non-SACK TCP. As an example, see [FALL96].",
      "ja": "SCTP SACKのギャップAckブロックは、TCP SACKと同じ意味論的な意味を運びます。 TCPは、情報はあくまで参考情報として、SACKで運ばれると考えています。 SCTPは顧問としてSACKチャンクにギャップAckブロックで運ばれた情報を考慮する。累積TSN AckをポイントがDATAチャンクのTSN（すなわち通過するまでSCTP、順不同で受信端に到着したデータを含め、SACKによって確認された任意のデータチャンクに、完全に配信考慮されていない、データチャンクはあり）SACKの累積TSN ACKフィールドによって承認され。したがって、CWNDの値が（非SACKのTCPの場合のように）よりむしろ未処理データの量、最も肯定応答シーケンス番号と輻輳ウィンドウ内で送信することができる最新のデータチャンクとの間の上限を制御します。 SCTP SACKは高速再送および非SACKのTCPよりも高速回復の異なる実装につながります。一例として、[FALL96]参照。"
    },
    {
      "indent": 3,
      "text": "The biggest difference between SCTP and TCP, however, is multi-homing. SCTP is designed to establish robust communication associations between two endpoints each of which may be reachable by more than one transport address. Potentially different addresses may lead to different data paths between the two endpoints; thus, ideally one may need a separate set of congestion control parameters for each of the paths. The treatment here of congestion control for multi-homed receivers is new with SCTP and may require refinement in the future. The current algorithms make the following assumptions:",
      "ja": "SCTPとTCPの最大の違いは、しかし、マルチホーミングです。 SCTPは、その各々が複数のトランスポート・アドレスによって到達可能であってもよい2つのエンドポイント間でロバストな通信のアソシエーションを確立するように設計されています。潜在的に異なるアドレスは、2つのエンドポイント間で異なるデータパスをもたらし得ます。従って、理想的には、パスのそれぞれについての輻輳制御パラメータの別のセットを必要とするかもしれません。マルチホームの受信機のため、ここでの輻輳制御の治療には、SCTPで新しく追加され、将来的に改善が必要な場合があります。現在のアルゴリズムは、以下の仮定を行います。"
    },
    {
      "indent": 3,
      "text": "o The sender usually uses the same destination address until being instructed by the upper layer to do otherwise; however, SCTP may change to an alternate destination in the event an address is marked inactive (see Section 8.2). Also, SCTP may retransmit to a different transport address than the original transmission.",
      "ja": "送信者は通常、そうやって上位層によって指示されるまで、同じ宛先アドレスを使用していますO;ただし、SCTPはアドレスが非アクティブにマークされている場合に、代替の宛先に変更されることがあります（セクション8.2を参照してください）。また、SCTPは、元の送信とは異なるトランスポートアドレスに再送信することができます。"
    },
    {
      "indent": 3,
      "text": "o The sender keeps a separate congestion control parameter set for each of the destination addresses it can send to (not each source-destination pair but for each destination). The parameters should decay if the address is not used for a long enough time period.",
      "ja": "送信者は、それが（それぞれのソースと宛先のペアではないが、各宛先のため）に送信できる宛先アドレスごとに個別の輻輳制御パラメータセットを保持し、O。アドレスは十分に長い期間のために使用されていない場合、パラメータが減衰しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o For each of the destination addresses, an endpoint does slow start upon the first transmission to that address.",
      "ja": "宛先アドレスの各々について、O、エンドポイントは、そのアドレスへの最初の送信時にスロースタートを行います。"
    },
    {
      "indent": 3,
      "text": "Note: TCP guarantees in-sequence delivery of data to its upper-layer protocol within a single TCP session. This means that when TCP notices a gap in the received sequence number, it waits until the gap is filled before delivering the data that was received with sequence numbers higher than that of the missing data. On the other hand, SCTP can deliver data to its upper-layer protocol even if there is a gap in TSN if the Stream Sequence Numbers are in sequence for a particular stream (i.e., the missing DATA chunks are for a different stream) or if unordered delivery is indicated. Although this does not affect cwnd, it might affect rwnd calculation.",
      "ja": "注：単一のTCPセッション内の上位層プロトコルへのデータのTCP保証インシーケンス配信。これは、TCPが受信されたシーケンス番号のギャップを通知するときのギャップが欠落データのより高いシーケンス番号で受信したデータを配信する前に満たされるまで、それが待機することを意味します。一方、SCTPストリームシーケンス番号が特定のストリーム（すなわち、欠落データチャンクは異なるストリームのためのものである）、または場合のシーケンスである場合、TSNにおけるギャップがあっても、その上位層プロトコルにデータを配信することができます順不同配信が示されています。これはcwndは影響しませんが、それはRWND計算に影響を与える可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.2. SCTP Slow-Start and Congestion Avoidance",
      "section_title": true,
      "ja": "7.2。 SCTPスロースタートと輻輳回避"
    },
    {
      "indent": 3,
      "text": "The slow-start and congestion avoidance algorithms MUST be used by an endpoint to control the amount of data being injected into the network. The congestion control in SCTP is employed in regard to the association, not to an individual stream. In some situations, it may be beneficial for an SCTP sender to be more conservative than the algorithms allow; however, an SCTP sender MUST NOT be more aggressive than the following algorithms allow.",
      "ja": "スロースタートと輻輳回避アルゴリズムは、ネットワークに注入されるデータの量を制御するために、エンドポイントによって使用されなければなりません。 SCTPにおける輻輳制御ではなく、個々のストリームに関連付けに関して使用されています。いくつかの状況では、SCTP送信者は、アルゴリズムが許すよりも保守的であるために有益であり得ます。ただし、SCTP送信者は、以下のアルゴリズムが許すよりも、より積極的にすることはできません。"
    },
    {
      "indent": 3,
      "text": "Like TCP, an SCTP endpoint uses the following three control variables to regulate its transmission rate.",
      "ja": "TCPと同様に、SCTP終点は、その伝送速度を調整するために、次の3つの制御変数を使用しています。"
    },
    {
      "indent": 3,
      "text": "o Receiver advertised window size (rwnd, in bytes), which is set by the receiver based on its available buffer space for incoming packets.",
      "ja": "Oレシーバは、着信パケットのために利用可能なバッファスペースに基づいて受信機によって設定されたウィンドウのサイズ（バイト単位RWNDを、）、アドバタイズ。"
    },
    {
      "indent": 6,
      "text": "Note: This variable is kept on the entire association.",
      "ja": "注：この変数は全体の協会に保たれています。"
    },
    {
      "indent": 3,
      "text": "o Congestion control window (cwnd, in bytes), which is adjusted by the sender based on observed network conditions.",
      "ja": "観測されたネットワーク状態に基づいて送信者によって調整されるO輻輳制御ウィンドウ（バイトCWND、）。"
    },
    {
      "indent": 6,
      "text": "Note: This variable is maintained on a per-destination-address basis.",
      "ja": "注意：この変数は、配送先ごとのアドレスベースで維持されています。"
    },
    {
      "indent": 3,
      "text": "o Slow-start threshold (ssthresh, in bytes), which is used by the sender to distinguish slow-start and congestion avoidance phases.",
      "ja": "Oスロースタート閾値（SSTHRESH、バイト単位）、スロースタートと輻輳回避フェーズを区別するために、送信者によって使用されます。"
    },
    {
      "indent": 6,
      "text": "Note: This variable is maintained on a per-destination-address basis.",
      "ja": "注意：この変数は、配送先ごとのアドレスベースで維持されています。"
    },
    {
      "indent": 3,
      "text": "SCTP also requires one additional control variable, partial_bytes_acked, which is used during congestion avoidance phase to facilitate cwnd adjustment.",
      "ja": "SCTPはまた、CWND調整を容易にするために、輻輳回避フェーズ中に使用されるpartial_bytes_acked一つの追加の制御変数を必要とします。"
    },
    {
      "indent": 3,
      "text": "Unlike TCP, an SCTP sender MUST keep a set of these control variables cwnd, ssthresh, and partial_bytes_acked for EACH destination address of its peer (when its peer is multi-homed). Only one rwnd is kept for the whole association (no matter if the peer is multi-homed or has a single address).",
      "ja": "TCPとは異なり、SCTP送信者は、これらの制御変数のセットを保持しなければならない（そのピアがマルチホームされた場合）、SSTHRESHをcwndを、そのピアの各宛先アドレスのpartial_bytes_acked。一つだけRWND全体協会（ピアがマルチホームであるか、単一のアドレスを持っている場合に関係なく）のために維持されます。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Slow-Start",
      "section_title": true,
      "ja": "7.2.1。スロースタート"
    },
    {
      "indent": 3,
      "text": "Beginning data transmission into a network with unknown conditions or after a sufficiently long idle period requires SCTP to probe the network to determine the available capacity. The slow-start algorithm is used for this purpose at the beginning of a transfer, or after repairing loss detected by the retransmission timer.",
      "ja": "未知の条件付きまたは十分長いアイドル期間の後にネットワークへのデータ送信を開始すると、使用可能な容量を決定するためにネットワークをプローブするSCTPが必要です。スロースタートアルゴリズムは、転送の開始時、または再送タイマによって検出された損失を修復した後、この目的のために使用されます。"
    },
    {
      "indent": 3,
      "text": "o The initial cwnd before DATA transmission or after a sufficiently long idle period MUST be set to min(4*MTU, max (2*MTU, 4380 bytes)).",
      "ja": "Oデータの送信前又は十分長いアイドル期間後の初期CWND（4 * MTU、MAX（2 * MTU、4380バイト））最小に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The initial cwnd after a retransmission timeout MUST be no more than 1*MTU.",
      "ja": "O再送タイムアウト後の初期のcwndはこれ以上* 1よりMTUでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The initial value of ssthresh MAY be arbitrarily high (for example, implementations MAY use the size of the receiver advertised window).",
      "ja": "SSTHRESHの初期値を任意に高くてもよいO（例えば、実装は、受信機のサイズがウィンドウをアドバタイズ使用してもよいです）。"
    },
    {
      "indent": 3,
      "text": "o Whenever cwnd is greater than zero, the endpoint is allowed to have cwnd bytes of data outstanding on that transport address.",
      "ja": "CWNDがゼロよりも大きいときはいつでも、O、エンドポイントは、そのトランスポートアドレス上の未処理データのcwndのバイトを持つことが許されます。"
    },
    {
      "indent": 3,
      "text": "o When cwnd is less than or equal to ssthresh, an SCTP endpoint MUST use the slow-start algorithm to increase cwnd only if the current congestion window is being fully utilized, an incoming SACK advances the Cumulative TSN Ack Point, and the data sender is not in Fast Recovery. Only when these three conditions are met can the cwnd be increased; otherwise, the cwnd MUST not be increased. If these conditions are met, then cwnd MUST be increased by, at most, the lesser of 1) the total size of the previously outstanding DATA chunk(s) acknowledged, and 2) the destination's path MTU. This upper bound protects against the ACK-Splitting attack outlined in [SAVAGE99].",
      "ja": "CWNDがSSTHRESH以下である場合、O、増加するスロースタートアルゴリズムを使用しなければならないSCTPエンドポイントはCWNDのみ現在の輻輳ウィンドウが完全に利用されている場合、着信SACKが累積TSNのAckポイントを進み、データ送信側でありますない高速リカバリインチこれら三つの条件が満たされた場合にのみにcwndを増加させることができます。そうでない場合は、CWNDが増加してはいけません。これらの条件が満たされている場合、CWNDは、以前の未処理データのチャンク（S）の合計サイズを認め、及び2）先のパスMTU）1より少ない、せいぜいによって増加されなければなりません。この上限は[SAVAGE99]で概説したACK分割攻撃から保護します。"
    },
    {
      "indent": 3,
      "text": "In instances where its peer endpoint is multi-homed, if an endpoint receives a SACK that advances its Cumulative TSN Ack Point, then it should update its cwnd (or cwnds) apportioned to the destination addresses to which it transmitted the acknowledged data. However, if the received SACK does not advance the Cumulative TSN Ack Point, the endpoint MUST NOT adjust the cwnd of any of the destination addresses.",
      "ja": "エンドポイントがその累積TSNのAckポイントを進めるSACKを受信した場合、そのピアエンドポイントがマルチホームされた事例では、それは、そのCWND（又はcwnds）を更新する必要があり、それは肯定応答データを送信した宛先アドレスに配分。受け取ったSACKが累積TSN Ackをポイントを進めていない場合は、エンドポイントは、宛先アドレスのいずれかのcwndのを調整してはなりません。"
    },
    {
      "indent": 3,
      "text": "Because an endpoint's cwnd is not tied to its Cumulative TSN Ack Point, as duplicate SACKs come in, even though they may not advance the Cumulative TSN Ack Point an endpoint can still use them to clock out new data. That is, the data newly acknowledged by the SACK diminishes the amount of data now in flight to less than cwnd, and so the current, unchanged value of cwnd now allows new data to be sent. On the other hand, the increase of cwnd must be tied to the Cumulative TSN Ack Point advancement as specified above. Otherwise, the duplicate SACKs will not only clock out new data, but also will adversely clock out more new data than what has just left the network, during a time of possible congestion.",
      "ja": "重複した袋が入ってくるよう、エンドポイントのCWNDが、彼らは累積TSN Ackをポイントを進めていなくても、その累積TSN Ackをポイントに結合されていないため、エンドポイントは、やはりクロックアウト新しいデータをそれらを使用することができます。それは、新たにSACKによって確認データはCWND未満への飛行中、今データの量を減少させ、そのためにcwndの現在、変わらない値は、新しいデータを送信することを可能にする、です。上記で特定した一方で、CWNDの増加が累積TSN Ackをポイント進歩に接続する必要があります。それ以外の場合は、重複した袋は、クロックアウト新しいデータをだけではなくなりますが、また、単に可能混雑の時間の間に、ネットワークを残しているものよりも新しいデータをクロックアウト悪影響を及ぼすだろう。"
    },
    {
      "indent": 3,
      "text": "o When the endpoint does not transmit data on a given transport address, the cwnd of the transport address should be adjusted to max(cwnd/2, 4*MTU) per RTO.",
      "ja": "エンドポイントが与えられたトランスポートアドレスにデータを送信しない場合には、O、トランスポート・アドレスのCWNDは、MAXに調整しなければならない（CWND / 2、4 * MTU）RTOあたり。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Congestion Avoidance",
      "section_title": true,
      "ja": "7.2.2。輻輳回避"
    },
    {
      "indent": 3,
      "text": "When cwnd is greater than ssthresh, cwnd should be incremented by 1*MTU per RTT if the sender has cwnd or more bytes of data outstanding for the corresponding transport address.",
      "ja": "CWNDがSSTHRESHより大きい場合、送信者はcwndをまたは対応するトランスポート・アドレスのための未処理データの複数のバイトた場合、CWNDは、RTTあたり1つの* MTUだけインクリメントされるべきです。"
    },
    {
      "indent": 3,
      "text": "In practice, an implementation can achieve this goal in the following way:",
      "ja": "実際には、実装は次のようにこの目標を達成することができます。"
    },
    {
      "indent": 3,
      "text": "o partial_bytes_acked is initialized to 0.",
      "ja": "O partial_bytes_ackedは0に初期化されます。"
    },
    {
      "indent": 3,
      "text": "o Whenever cwnd is greater than ssthresh, upon each SACK arrival that advances the Cumulative TSN Ack Point, increase partial_bytes_acked by the total number of bytes of all new chunks acknowledged in that SACK including chunks acknowledged by the new Cumulative TSN Ack and by Gap Ack Blocks.",
      "ja": "OたびCWNDが累積TSNのAckポイントを進める各SACKの到着時に、新たな累積TSNのAckによって、およびギャップAckブロックによって認めチャンクを含むことSACKに認めすべての新しいチャンクのバイトの総数によってpartial_bytes_acked、増加SSTHRESHより大きい。"
    },
    {
      "indent": 3,
      "text": "o When partial_bytes_acked is equal to or greater than cwnd and before the arrival of the SACK the sender had cwnd or more bytes of data outstanding (i.e., before arrival of the SACK, flightsize was greater than or equal to cwnd), increase cwnd by MTU, and reset partial_bytes_acked to (partial_bytes_acked - cwnd).",
      "ja": "partial_bytes_acked場合、O（すなわち、SACKの到着前に、flightsizeはcwndを以上であった）、MTUによってCWNDが増加に等しいかCWNDより大きく、送信者が未処理データのバイトをcwndを以上たSACKの到着の前にありますpartial_bytes_acked、リセット（partial_bytes_acked  -  CWND）。"
    },
    {
      "indent": 3,
      "text": "o Same as in the slow start, when the sender does not transmit DATA on a given transport address, the cwnd of the transport address should be adjusted to max(cwnd / 2, 4*MTU) per RTO.",
      "ja": "O送信者が与えられたトランスポートアドレスにデータを送信しないスロースタート、と同様に、トランスポート・アドレスのCWNDを最大に調整しなければならない（CWND / 2、4 * MTU）当たりRTO。"
    },
    {
      "indent": 3,
      "text": "o When all of the data transmitted by the sender has been acknowledged by the receiver, partial_bytes_acked is initialized to 0.",
      "ja": "O場合は、送信者が送信したデータのすべてが0に初期化されpartial_bytes_acked、受信機によって認められています。"
    },
    {
      "indent": 0,
      "text": "7.2.3. Congestion Control",
      "section_title": true,
      "ja": "7.2.3。輻輳制御"
    },
    {
      "indent": 3,
      "text": "Upon detection of packet losses from SACK (see Section 7.2.4), an endpoint should do the following:",
      "ja": "SACKからパケットロスを検出すると（第7.2.4項を参照）、エンドポイントは、以下の操作を行う必要があります。"
    },
    {
      "indent": 6,
      "text": "ssthresh = max(cwnd/2, 4*MTU) cwnd = ssthresh partial_bytes_acked = 0",
      "ja": "SSTHRESH = MAX（CWND / 2、4 * MTU）CWND = SSTHRESH partial_bytes_acked = 0"
    },
    {
      "indent": 3,
      "text": "Basically, a packet loss causes cwnd to be cut in half.",
      "ja": "基本的には、パケット損失がcwndを半分にカットされます。"
    },
    {
      "indent": 3,
      "text": "When the T3-rtx timer expires on an address, SCTP should perform slow start by:",
      "ja": "T3-RTXタイマーがアドレスに期限が切れると、SCTPはでスロースタートを実行する必要があります。"
    },
    {
      "indent": 6,
      "text": "ssthresh = max(cwnd/2, 4*MTU) cwnd = 1*MTU",
      "ja": "SSTHRESH = MAX（CWND / 2、4 * MTU）CWND = 1 * MTU"
    },
    {
      "indent": 3,
      "text": "and ensure that no more than one SCTP packet will be in flight for that address until the endpoint receives acknowledgement for successful delivery of data to that address.",
      "ja": "そしてエンドポイントがそのアドレスへのデータの成功配信のための肯定応答を受信するまでは、複数のSCTPパケットはそのアドレスの飛行にならないだろうことを確認してください。"
    },
    {
      "indent": 0,
      "text": "7.2.4. Fast Retransmit on Gap Reports",
      "section_title": true,
      "ja": "7.2.4。ギャップレポートの高速再送信"
    },
    {
      "indent": 3,
      "text": "In the absence of data loss, an endpoint performs delayed acknowledgement. However, whenever an endpoint notices a hole in the arriving TSN sequence, it SHOULD start sending a SACK back every time a packet arrives carrying data until the hole is filled.",
      "ja": "データ損失の不在下で、エンドポイントは、遅延確認応答を行います。エンドポイントが到着TSNシーケンスの穴に気づいたときにしかし、それはバックパケットは穴が満たされるまで、データを運ぶ到着するたびにSACKの送信を開始すべきです。"
    },
    {
      "indent": 3,
      "text": "Whenever an endpoint receives a SACK that indicates that some TSNs are missing, it SHOULD wait for two further miss indications (via subsequent SACKs for a total of three missing reports) on the same TSNs before taking action with regard to Fast Retransmit.",
      "ja": "エンドポイントはいくつかのTSNが欠落していることを示しているSACKを受信するたびに、それが高速再送信に関して行動を起こす前に、同じのTSNにさらに2つのミス適応症（3つの欠落しているレポートの合計のために、後続の袋を経由して）待つべき。"
    },
    {
      "indent": 3,
      "text": "Miss indications SHOULD follow the HTNA (Highest TSN Newly Acknowledged) algorithm. For each incoming SACK, miss indications are incremented only for missing TSNs prior to the highest TSN newly acknowledged in the SACK. A newly acknowledged DATA chunk is one not previously acknowledged in a SACK. If an endpoint is in Fast Recovery and a SACK arrives that advances the Cumulative TSN Ack Point, the miss indications are incremented for all TSNs reported missing in the SACK.",
      "ja": "ミス表示はHTNA（最高TSN新ADIは）アルゴリズムに従ってください。各着信SACKについて、ミス表示が前に新たSACKに認め最高TSNにだけ行方不明のTSNごとに増加しています。新たに認めたのDATAチャンクが以前にSACKで認められていないものです。エンドポイントは高速回復であるとSACKが累積TSN Ackをポイントを進め、その到着した場合、ミス表示がSACKに不足しているすべてのTSNについて報告インクリメントされています。"
    },
    {
      "indent": 3,
      "text": "When the third consecutive miss indication is received for a TSN(s), the data sender shall do the following:",
      "ja": "第三連続でミス表示がTSN（S）のために受信されると、データの送信者は、次の手順を実行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "1) Mark the DATA chunk(s) with three miss indications for retransmission.",
      "ja": "1）再送信のための3つのミスの適応症を持つデータチャンク（複数可）をマークします。"
    },
    {
      "indent": 3,
      "text": "2) If not in Fast Recovery, adjust the ssthresh and cwnd of the destination address(es) to which the missing DATA chunks were last sent, according to the formula described in Section 7.2.3.",
      "ja": "ない高速リカバリで場合2）、7.2.3項で説明した式に従って、欠落データチャンクが最後に送信された先のアドレス（ES）のSSTHRESHおよびCWNDを調整します。"
    },
    {
      "indent": 3,
      "text": "3) Determine how many of the earliest (i.e., lowest TSN) DATA chunks marked for retransmission will fit into a single packet, subject to constraint of the path MTU of the destination transport address to which the packet is being sent. Call this value K. Retransmit those K DATA chunks in a single packet. When a Fast Retransmit is being performed, the sender SHOULD ignore the value of cwnd and SHOULD NOT delay retransmission for this single packet.",
      "ja": "3）最も初期の何を決定する（すなわち、再送信のためにマークされた最も低いTSN）DATA塊は、パケットが送信された送付先輸送アドレスの経路MTUの制約を受ける単一のパケットに収まります。 K.は、単一のパケットでそれらのK DATAチャンクを再送この値を呼び出します。高速再送信が実行されている場合は、送信者はCWNDの値を無視すべきであり、この単一のパケットの再送信を遅らせるべきではありません。"
    },
    {
      "indent": 3,
      "text": "4) Restart the T3-rtx timer only if the last SACK acknowledged the lowest outstanding TSN number sent to that address, or the endpoint is retransmitting the first outstanding DATA chunk sent to that address.",
      "ja": "4）最後のSACKがそのアドレスに送信された最低の優れたTSN番号を認め、またはエンドポイントがそのアドレスに送信された最初の未処理データのチャンクを再送されている場合にのみ、T3-RTXタイマーを再起動します。"
    },
    {
      "indent": 3,
      "text": "5) Mark the DATA chunk(s) as being fast retransmitted and thus ineligible for a subsequent Fast Retransmit. Those TSNs marked for retransmission due to the Fast-Retransmit algorithm that did not fit in the sent datagram carrying K other TSNs are also marked as ineligible for a subsequent Fast Retransmit. However, as they are marked for retransmission they will be retransmitted later on as soon as cwnd allows.",
      "ja": "5）高速再送およびその後の高速再送信のためにこのように不適格であるように、データチャンク（複数可）をマーク。 K他のTSNを運ぶ送信されたデータグラムに収まらなかった高速再送アルゴリズムへの再送信のためにマークされ、これらのTSNはまた、その後の高速再送用として不適格とマークされています。彼らは再送信のためにマークされているようしかし、彼らはすぐにcwndが許す限り、後に再送されます。"
    },
    {
      "indent": 3,
      "text": "6) If not in Fast Recovery, enter Fast Recovery and mark the highest outstanding TSN as the Fast Recovery exit point. When a SACK acknowledges all TSNs up to and including this exit point, Fast Recovery is exited. While in Fast Recovery, the ssthresh and cwnd SHOULD NOT change for any destinations due to a subsequent Fast Recovery event (i.e., one SHOULD NOT reduce the cwnd further due to a subsequent Fast Retransmit).",
      "ja": "6）高速回復で、高速リカバリを入力して、高速リカバリ出口点として最高の優れたTSNをマークしていない場合。 SACKは、この出口点までを含むすべてのTSNを承認すると、高速リカバリが終了します。高速リカバリでいる間、SSTHRESHおよびCWNDは（すなわち、1は、後続の高速再送信することによってさらにCWNDを減らすべきではありません）、その後の高速リカバリイベントのために任意の宛先に変更すべきではありません。"
    },
    {
      "indent": 3,
      "text": "Note: Before the above adjustments, if the received SACK also acknowledges new DATA chunks and advances the Cumulative TSN Ack Point, the cwnd adjustment rules defined in Section 7.2.1 and Section 7.2.2 must be applied first.",
      "ja": "注：受信したSACKはまた、新しいデータチャンクを承認し、累積TSNのAckポイントを進める場合、上記の調整前に、セクション7.2.1及びセクション7.2.2で定義されたCWND調整ルールが最初に適用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "A straightforward implementation of the above keeps a counter for each TSN hole reported by a SACK. The counter increments for each consecutive SACK reporting the TSN hole. After reaching 3 and starting the Fast-Retransmit procedure, the counter resets to 0.",
      "ja": "上記の簡単な実装はSACKによって報告された各TSN穴用のカウンタを保持します。 TSN穴を報告各連続SACKのカウンタをインクリメント。 3に到達し、高速再送信手順を開始した後、カウンタが0にリセットします。"
    },
    {
      "indent": 3,
      "text": "Because cwnd in SCTP indirectly bounds the number of outstanding TSN's, the effect of TCP Fast Recovery is achieved automatically with no adjustment to the congestion control window size.",
      "ja": "SCTP中のcwndが間接的に優れたTSNの数を境界とするので、TCP高速回復の効果は、輻輳制御ウィンドウサイズに調整なしで自動的に達成されます。"
    },
    {
      "indent": 0,
      "text": "7.3. Path MTU Discovery",
      "section_title": true,
      "ja": "7.3。パスMTUディスカバリ"
    },
    {
      "indent": 3,
      "text": "[RFC4821], [RFC1981], and [RFC1191] specify \"Packetization Layer Path MTU Discovery\", whereby an endpoint maintains an estimate of the maximum transmission unit (MTU) along a given Internet path and refrains from sending packets along that path that exceed the MTU, other than occasional attempts to probe for a change in the Path MTU (PMTU). [RFC4821] is thorough in its discussion of the MTU discovery mechanism and strategies for determining the current end-to-end MTU setting as well as detecting changes in this value.",
      "ja": "[RFC4821]、[RFC1981]及び[RFC1191]のエンドポイントを超え、その経路に沿ってパケットを送信から所定のインターネットパスと控えるに沿って最大伝送単位（MTU）の推定値を維持することにより、「パケット化層のパスMTUディスカバリ」を指定時折試み以外のMTUは、パスMTU（PMTU）の変化を探索するために。 [RFC4821]はMTU発見メカニズムのその議論で完全であり、現在のエンド・ツー・エンドのMTU設定を決定するだけでなく、この値の変化を検出するための戦略。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD apply these techniques, and SHOULD do so on a per-destination-address basis.",
      "ja": "エンドポイントは、これらの技術を適用すべきである、とあたりの宛先アドレスに基づき、そうすべきです。"
    },
    {
      "indent": 3,
      "text": "There are two important SCTP-specific points regarding Path MTU discovery:",
      "ja": "パスMTUディスカバリに関する二つの重要なSCTP固有のポイントがあります。"
    },
    {
      "indent": 3,
      "text": "1) SCTP associations can span multiple addresses. An endpoint MUST maintain separate MTU estimates for each destination address of its peer.",
      "ja": "1）SCTPアソシエーションは、複数のアドレスをまたがることができます。エンドポイントは、そのピアの各宛先アドレスに対して別々のMTU推定値を維持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2) The sender should track an association PMTU that will be the smallest PMTU discovered for all of the peer's destination addresses. When fragmenting messages into multiple parts this association PMTU should be used to calculate the size of each fragment. This will allow retransmissions to be seamlessly sent to an alternate address without encountering IP fragmentation.",
      "ja": "2）送信者はピアの宛先アドレスのすべてのために発見された最小のPMTUなりアソシエーションPMTUを追跡する必要があります。複数の部分にメッセージを断片化すると、この関連PMTUは、各断片の大きさを計算するために使用されるべきです。これは、再送信がシームレスにIPフラグメンテーションに遭遇することなく別のアドレスに送信できるようになります。"
    },
    {
      "indent": 0,
      "text": "8. Fault Management",
      "section_title": true,
      "ja": "8.障害管理"
    },
    {
      "indent": 0,
      "text": "8.1. Endpoint Failure Detection",
      "section_title": true,
      "ja": "8.1。エンドポイントの障害検出"
    },
    {
      "indent": 3,
      "text": "An endpoint shall keep a counter on the total number of consecutive retransmissions to its peer (this includes retransmissions to all the destination transport addresses of the peer if it is multi-homed), including unacknowledged HEARTBEAT chunks. If the value of this counter exceeds the limit indicated in the protocol parameter 'Association.Max.Retrans', the endpoint shall consider the peer endpoint unreachable and shall stop transmitting any more data to it (and thus the association enters the CLOSED state). In addition, the endpoint MAY report the failure to the upper layer and optionally report back all outstanding user data remaining in its outbound queue. The association is automatically closed when the peer endpoint becomes unreachable.",
      "ja": "エンドポイントは、未確認HEARTBEATチャンクを含む、（マルチホームである場合、これは、ピアのすべての宛先トランスポートアドレスへの再送信を含む）ピアへの連続再送信の総数カウンタを維持しなければなりません。このカウンタの値は、プロトコルパラメータ「Association.Max.Retrans」で示さ限界を超えた場合、エンドポイントは、ピアエンドポイントが到達不能に考慮しなければならないし、それが（したがって、関連が閉状態になる）に、任意のより多くのデータの送信を停止しなければなりません。また、エンドポイントは、上位層に障害を報告し、必要に応じてその送信キューに残っているすべての未処理のユーザデータをバック報告することがあります。ピアエンドポイントが到達不能になったときに関連付けは自動的に閉じられます。"
    },
    {
      "indent": 3,
      "text": "The counter shall be reset each time a DATA chunk sent to that peer endpoint is acknowledged (by the reception of a SACK) or a HEARTBEAT ACK is received from the peer endpoint.",
      "ja": "カウンタ又はACKがピア・エンドポイントから受信されたHEARTBEAT（SACKの受信によって）そのピアエンドポイントに送信されたデータチャンクが確認されるたびにリセットされなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.2. Path Failure Detection",
      "section_title": true,
      "ja": "8.2。パスの障害検出"
    },
    {
      "indent": 3,
      "text": "When its peer endpoint is multi-homed, an endpoint should keep an error counter for each of the destination transport addresses of the peer endpoint.",
      "ja": "ピアエンドポイントがマルチホームである場合、エンドポイントは、ピアエンドポイントの宛先トランスポートアドレスのそれぞれに対してエラーカウンタを維持するべきです。"
    },
    {
      "indent": 3,
      "text": "Each time the T3-rtx timer expires on any address, or when a HEARTBEAT sent to an idle address is not acknowledged within an RTO, the error counter of that destination address will be incremented. When the value in the error counter exceeds the protocol parameter 'Path.Max.Retrans' of that destination address, the endpoint should mark the destination transport address as inactive, and a notification SHOULD be sent to the upper layer.",
      "ja": "アイドルアドレスに送信されたHEARTBEATがRTO内に認めていないときにT3-RTXタイマーが任意のアドレスに期限が切れるたびに、または、その送信先アドレスのエラーカウンタがインクリメントされます。エラーカウンタの値がその宛先アドレスのプロトコルパラメータ「Path.Max.Retrans」を超えたときに、エンドポイントが非アクティブとして宛先トランスポートアドレスをマークする必要があり、通知は、上位層に送信されるべきです。"
    },
    {
      "indent": 3,
      "text": "When an outstanding TSN is acknowledged or a HEARTBEAT sent to that address is acknowledged with a HEARTBEAT ACK, the endpoint shall clear the error counter of the destination transport address to which the DATA chunk was last sent (or HEARTBEAT was sent). When the peer endpoint is multi-homed and the last chunk sent to it was a retransmission to an alternate address, there exists an ambiguity as to whether or not the acknowledgement should be credited to the address of the last chunk sent. However, this ambiguity does not seem to bear any significant consequence to SCTP behavior. If this ambiguity is undesirable, the transmitter may choose not to clear the error counter if the last chunk sent was a retransmission.",
      "ja": "優れたTSNが認められているか、そのアドレスに送信されたHEARTBEATがHEARTBEATのACKで承認された場合、エンドポイントは、どのデータチャンクが送信された最後だったし（またはHEARTBEATが送られた）先のトランスポートアドレスのエラーカウンタをクリアしなければなりません。ピアエンドポイントである場合にマルチホームおよびそれに送信された最後のチャンクは、肯定応答が送信された最後のチャンクのアドレスに入金されるべきか否かの代替アドレスに再送が、曖昧さが存在しました。しかし、この曖昧さは、SCTPの動作に重大な結果を負担していないようです。このあいまいさが望ましくない場合は、送信機は、送信された最後のチャンクが再送信であった場合、エラーカウンタをクリアしないこともできます。"
    },
    {
      "indent": 3,
      "text": "Note: When configuring the SCTP endpoint, the user should avoid having the value of 'Association.Max.Retrans' larger than the summation of the 'Path.Max.Retrans' of all the destination addresses for the remote endpoint. Otherwise, all the destination addresses may become inactive while the endpoint still considers the peer endpoint reachable. When this condition occurs, how SCTP chooses to function is implementation specific.",
      "ja": "注：SCTP終点を設定する場合、ユーザーが「Association.Max.Retransのリモートエンドポイントのすべての宛先アドレスの「Path.Max.Retrans」の合計よりも大きな値を持つことは避けてください。エンドポイントがまだ到達可能なピア・エンドポイントを考慮しながら、それ以外の場合は、すべての宛先アドレスが非アクティブになることがあります。この状態が発生すると、SCTPが機能することを選択した方法を実装固有のものです。"
    },
    {
      "indent": 3,
      "text": "When the primary path is marked inactive (due to excessive retransmissions, for instance), the sender MAY automatically transmit new packets to an alternate destination address if one exists and is active. If more than one alternate address is active when the primary path is marked inactive, only ONE transport address SHOULD be chosen and used as the new destination transport address.",
      "ja": "プライマリパスが（例えば、過度の再送信に）非アクティブとマークされたときに一方が存在し、アクティブである場合、送信者は自動的に代替の宛先アドレスに新しいパケットを送信することができます。プライマリパスが非アクティブとマークされたときに、複数の代替アドレスがアクティブである場合、唯一つのトランスポートアドレスを選択し、新しい宛先トランスポートアドレスとして使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "8.3. Path Heartbeat",
      "section_title": true,
      "ja": "8.3。パスのハートビート"
    },
    {
      "indent": 3,
      "text": "By default, an SCTP endpoint SHOULD monitor the reachability of the idle destination transport address(es) of its peer by sending a HEARTBEAT chunk periodically to the destination transport address(es). HEARTBEAT sending MAY begin upon reaching the ESTABLISHED state and is discontinued after sending either SHUTDOWN or SHUTDOWN-ACK. A receiver of a HEARTBEAT MUST respond to a HEARTBEAT with a HEARTBEAT-ACK after entering the COOKIE-ECHOED state (INIT sender) or the ESTABLISHED state (INIT receiver), up until reaching the SHUTDOWN-SENT state (SHUTDOWN sender) or the SHUTDOWN-ACK-SENT state (SHUTDOWN receiver).",
      "ja": "デフォルトでは、SCTP終点は、宛先トランスポートアドレス（ES）に定期的にHEARTBEATチャンクを送信することによって、そのピアのアイドル先トランスポートアドレス（ES）の到達性を監視する必要があります。送信HEARTBEATがESTABLISHED状態に達したときに開始することとSHUTDOWNやSHUTDOWN-ACKのいずれかを送った後に中止されます。 HEARTBEATの受信機がSHUTDOWN-SENT状態（SHUTDOWN送信者）またはSHUTDOWNに達するまで、（INITの送信者）または確立された状態（INIT受信機）COOKIE-ECHOED状態に入った後HEARTBEAT-ACKとHEARTBEATに応答しなければなりません-ACK-SENT状態（SHUTDOWN受信機）。"
    },
    {
      "indent": 3,
      "text": "A destination transport address is considered \"idle\" if no new chunk that can be used for updating path RTT (usually including first transmission DATA, INIT, COOKIE ECHO, HEARTBEAT, etc.) and no HEARTBEAT has been sent to it within the current heartbeat period of that address. This applies to both active and inactive destination addresses.",
      "ja": "経路RTT（通常、最初の送信データを含む、INIT、COOKIE ECHO、HEARTBEAT、等）を更新するために使用することができ、ハートビート、現在の心拍以内に送信されていない新たなチャンク場合宛先トランスポートアドレスが「アイドル」であると考えられますそのアドレスの期間。これは、アクティブおよび非アクティブの両方の宛先アドレスに適用されます。"
    },
    {
      "indent": 3,
      "text": "The upper layer can optionally initiate the following functions:",
      "ja": "上位層は、必要に応じて、以下の機能を開始することができます。"
    },
    {
      "indent": 3,
      "text": "A) Disable heartbeat on a specific destination transport address of a given association,",
      "ja": "A）指定された関連の特定の宛先トランスポートアドレスに無効ハートビート、"
    },
    {
      "indent": 3,
      "text": "B) Change the HB.interval,",
      "ja": "B）、HB.intervalを変更"
    },
    {
      "indent": 3,
      "text": "C) Re-enable heartbeat on a specific destination transport address of a given association, and",
      "ja": "C）所与アソシエーションの特定の宛先トランスポートアドレスにハートビートを再有効化、および"
    },
    {
      "indent": 3,
      "text": "D) Request an on-demand HEARTBEAT on a specific destination transport address of a given association.",
      "ja": "D）指定されたアソシエーションの特定の宛先トランスポートアドレスオンデマンドHEARTBEATを求めます。"
    },
    {
      "indent": 3,
      "text": "The endpoint should increment the respective error counter of the destination transport address each time a HEARTBEAT is sent to that address and not acknowledged within one RTO.",
      "ja": "エンドポイントは、宛先トランスポートアドレスのそれぞれのエラーカウンタHEARTBEATがそのアドレスに送信され、1 RTO内に認めていないされるたびに増分する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the value of this counter reaches the protocol parameter 'Path.Max.Retrans', the endpoint should mark the corresponding destination address as inactive if it is not so marked, and may also optionally report to the upper layer the change of reachability of this destination address. After this, the endpoint should continue HEARTBEAT on this destination address but should stop increasing the counter.",
      "ja": "このカウンタの値はプロトコルパラメータ「Path.Max.Retrans」に達したときに、エンドポイントは、それがそのようにマークされていない場合、非アクティブとして対応する宛先アドレスをマークする必要があり、また、必要に応じて上位レイヤにこの到達可能性の変化を報告すること宛先アドレス。この後、エンドポイントは、この宛先アドレスにHEARTBEATを続けるべきであるが、カウンタが増加停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "The sender of the HEARTBEAT chunk should include in the Heartbeat Information field of the chunk the current time when the packet is sent out and the destination address to which the packet is sent.",
      "ja": "HEARTBEATチャンクの送信者は、チャンクのハートビート情報フィールドにパケットが送出され、現在の時刻と、パケットが送信されると、宛先アドレスを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: An alternative implementation of the heartbeat mechanism that can be used is to increment the error counter variable every time a HEARTBEAT is sent to a destination. Whenever a HEARTBEAT ACK arrives, the sender SHOULD clear the error counter of the destination that the HEARTBEAT was sent to. This in effect would clear the previously stroked error (and any other error counts as well).",
      "ja": "実装上の注意：使用可能なハートビート・メカニズムの代替実装では、エラーカウンタ変数にHEARTBEATが宛先に送信されるたびにインクリメントすることです。 HEARTBEAT ACKが到着するたびに、送信者はHEARTBEATが送られた先のエラーカウンタをクリアする必要があります。これは、実際には、以前になでエラーをクリアします（およびその他のエラーも同様にカウントします）。"
    },
    {
      "indent": 3,
      "text": "The receiver of the HEARTBEAT should immediately respond with a HEARTBEAT ACK that contains the Heartbeat Information TLV, together with any other received TLVs, copied unchanged from the received HEARTBEAT chunk.",
      "ja": "HEARTBEATの受信機はすぐに一緒に受け取ったHEARTBEATチャンクからそのままコピーされ、他の受信のTLVと、ハートビートインフォメーションTLVが含まれているハートビートACKで応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT should clear the error counter of the destination transport address to which the HEARTBEAT was sent, and mark the destination transport address as active if it is not so marked. The endpoint may optionally report to the upper layer when an inactive destination address is marked as active due to the reception of the latest HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also clear the association overall error count as well (as defined in Section 8.1).",
      "ja": "HEARTBEAT ACKを受信すると、HEARTBEATの送信者は、HEARTBEATが送られた先のトランスポートアドレスのエラーカウンタをクリアする必要があり、それはそうとマークされていない場合は、アクティブとして、宛先トランスポートアドレスをマーク。非アクティブな宛先アドレスが原因最新HEARTBEAT ACKの受信にアクティブとしてマークされている場合、エンドポイントは、必要に応じて上位層に報告することができます。 HEARTBEAT ACKの受信機は、（セクション8.1で定義されるように）同様にカウントアソシエーション全体のエラーをクリアしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The receiver of the HEARTBEAT ACK should also perform an RTT measurement for that destination transport address using the time value carried in the HEARTBEAT ACK chunk.",
      "ja": "HEARTBEAT ACKの受信機は、HEARTBEAT ACKチャンクで運ば時間値を使用してその先のトランスポートアドレスのRTT測定を行うべきです。"
    },
    {
      "indent": 3,
      "text": "On an idle destination address that is allowed to heartbeat, it is recommended that a HEARTBEAT chunk is sent once per RTO of that destination address plus the protocol parameter 'HB.interval', with jittering of +/- 50% of the RTO value, and exponential backoff of the RTO if the previous HEARTBEAT is unanswered.",
      "ja": "ハートビートさせ、アイドル宛先アドレスに、ハートビート・チャンクがRTO値の+/- 50％のジッタと、一度その宛先アドレスとプロトコルパラメータ「HB.interval」のRTOごとに送信することが推奨されますそして、RTOの指数バックオフ前のHEARTBEATが応答がない場合。"
    },
    {
      "indent": 3,
      "text": "A primitive is provided for the SCTP user to change the HB.interval and turn on or off the heartbeat on a given destination address. The heartbeat interval set by the SCTP user is added to the RTO of that destination (including any exponential backoff). Only one heartbeat should be sent each time the heartbeat timer expires (if multiple destinations are idle). It is an implementation decision on how to choose which of the candidate idle destinations to heartbeat to (if more than one destination is idle).",
      "ja": "プリミティブはHB.intervalを変更し、与えられた宛先アドレスにハートビートオンまたはオフにするSCTPユーザのために提供されます。 SCTPユーザにより設定されたハートビート間隔は、（任意の指数バックオフを含む）をその宛先のRTOに添加されます。一つだけのハートビートは、（複数の宛先がアイドル状態になっている場合）、ハートビートタイマーの期限が切れるたびに送信する必要があります。これは、（複数の宛先がアイドル状態の場合）に心拍候補アイドルの宛先のかを選択する方法については実装決定です。"
    },
    {
      "indent": 3,
      "text": "Note: When tuning the heartbeat interval, there is a side effect that SHOULD be taken into account. When this value is increased, i.e., the HEARTBEAT takes longer, the detection of lost ABORT messages takes longer as well. If a peer endpoint ABORTs the association for any reason and the ABORT chunk is lost, the local endpoint will only discover the lost ABORT by sending a DATA chunk or HEARTBEAT chunk (thus causing the peer to send another ABORT). This must be considered when tuning the HEARTBEAT timer. If the HEARTBEAT is disabled, only sending DATA to the association will discover a lost ABORT from the peer.",
      "ja": "注意：ハートビート間隔をチューニングする場合、考慮に入れるべき副作用があります。この値を大きくすると、すなわち、HEARTBEATが時間がかかり、失われたABORTメッセージの検出にも時間がかかります。ピアエンドポイントが何らかの理由で関連付けを中止し、ABORTチャンクが失われた場合、ローカルエンドポイントは（従って別のABORTを送信するピアを引き起こす）DATAチャンクまたはHEARTBEATチャンクを送信することによって失われたABORTを発見するだけであろう。 HEARTBEATタイマーをチューニングするときに考慮しなければなりません。 HEARTBEATが無効になっている場合、唯一の関連にデータを送信することは、ピアから失われたABORTを発見するでしょう。"
    },
    {
      "indent": 0,
      "text": "8.4. Handle \"Out of the Blue\" Packets",
      "section_title": true,
      "ja": "8.4。パケット「ブルーのうち」ハンドル"
    },
    {
      "indent": 3,
      "text": "An SCTP packet is called an \"out of the blue\" (OOTB) packet if it is correctly formed (i.e., passed the receiver's CRC32c check; see Section 6.8), but the receiver is not able to identify the association to which this packet belongs.",
      "ja": "しかし、受信機は、このパケットが属する団体を識別することができません。それは正しく形成されている場合SCTPパケットは（6.8節を参照してくださいつまり、受信者のCRC32Cチェックに合格した）「青のうち」（OOTB）パケットと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "The receiver of an OOTB packet MUST do the following:",
      "ja": "OOTBパケットの受信機は、以下を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "1) If the OOTB packet is to or from a non-unicast address, a receiver SHOULD silently discard the packet. Otherwise,",
      "ja": "OOTBパケットが非ユニキャストアドレスへ又はからのものである場合は1）、受信機は静かにパケットを破棄すべきです。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "2) If the OOTB packet contains an ABORT chunk, the receiver MUST silently discard the OOTB packet and take no further action. Otherwise,",
      "ja": "OOTBパケットはABORTチャンクが含まれている場合は2）、受信機は静かOOTBパケットを破棄し、さらなる行動を取るてはなりません。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "3) If the packet contains an INIT chunk with a Verification Tag set to '0', process it as described in Section 5.1. If, for whatever reason, the INIT cannot be processed normally and an ABORT has to be sent in response, the Verification Tag of the packet containing the ABORT chunk MUST be the Initiate Tag of the received INIT chunk, and the T bit of the ABORT chunk has to be set to 0, indicating that the Verification Tag is NOT reflected.",
      "ja": "3）5.1節で説明したように、パケットがINIT「0」に設定検証タグとチャンク、プロセス、それが含まれている場合。何らかの理由で、INITが正常に処理できないとABORTが応答して送信する必要があり、ABORTチャンクを含むパケットの検証タグは、受信INITチャンクのタグ、およびABORTのTビットを開始しなければなりません、場合チャンクは、検証タグが反映されないことを示す、0に設定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "4) If the packet contains a COOKIE ECHO in the first chunk, process it as described in Section 5.1. Otherwise,",
      "ja": "4）5.1節で説明したように、パケットは、それが、最初のチャンクの処理をCOOKIE ECHOを含む場合。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "5) If the packet contains a SHUTDOWN ACK chunk, the receiver should respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE. When sending the SHUTDOWN COMPLETE, the receiver of the OOTB packet must fill in the Verification Tag field of the outbound packet with the Verification Tag received in the SHUTDOWN ACK and set the T bit in the Chunk Flags to indicate that the Verification Tag is reflected. Otherwise,",
      "ja": "パケットがSHUTDOWN ACKチャンクが含まれている場合5）、受信機は、SHUTDOWNのCOMPLETEとOOTBパケットの送信者に応答する必要があります。 SHUTDOWNが完了し送信するとき、OOTBパケットの受信機は、シャットダウンACKに受信した検証タグとアウトバウンドパケットの検証タグフィールドに入力し、検証タグが反映されることを示すために、チャンクフラグのTビットをセットしなければなりません。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "6) If the packet contains a SHUTDOWN COMPLETE chunk, the receiver should silently discard the packet and take no further action. Otherwise,",
      "ja": "パケットがSHUTDOWN COMPLETEチャンクが含まれている場合は6）、受信機は静かにパケットを破棄し、それ以上の行動を取るべきではありません。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "7) If the packet contains a \"Stale Cookie\" ERROR or a COOKIE ACK, the SCTP packet should be silently discarded. Otherwise,",
      "ja": "パケットは「古いクッキー」ERRORまたはCOOKIEのACKが含まれている場合は7）、SCTPパケットは静かに捨てられるべきです。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "8) The receiver should respond to the sender of the OOTB packet with an ABORT. When sending the ABORT, the receiver of the OOTB packet MUST fill in the Verification Tag field of the outbound packet with the value found in the Verification Tag field of the OOTB packet and set the T bit in the Chunk Flags to indicate that the Verification Tag is reflected. After sending this ABORT, the receiver of the OOTB packet shall discard the OOTB packet and take no further action.",
      "ja": "8）受信機は、ABORTとOOTBパケットの送信者に応答すべきです。 ABORTを送信する場合、OOTBパケットの受信機はOOTBパケットの検証タグフィールドで見つかった値とアウトバウンドパケットの検証タグフィールドに記入して示すためにチャンクフラグのTビットをセットしなければならないことを検証タグ反射してる。このABORTを送信した後、OOTBパケットの受信機はOOTBパケットを破棄し、それ以上の措置を講じてはなりません。"
    },
    {
      "indent": 0,
      "text": "8.5. Verification Tag",
      "section_title": true,
      "ja": "8.5。検証タグ"
    },
    {
      "indent": 3,
      "text": "The Verification Tag rules defined in this section apply when sending or receiving SCTP packets that do not contain an INIT, SHUTDOWN COMPLETE, COOKIE ECHO (see Section 5.1), ABORT, or SHUTDOWN ACK chunk. The rules for sending and receiving SCTP packets containing one of these chunk types are discussed separately in Section 8.5.1.",
      "ja": "送信またはINIT、COMPLETE SHUTDOWN、COOKIE ECHO（セクション5.1を参照）、ABORT、またはSHUTDOWN ACKチャンクを含まないSCTPパケットを受信したときに、このセクションで定義された検証タグの規則が適用されます。これらのチャンクタイプのいずれかを含むSCTPパケットを送受信するための規則は、セクション8.5.1に別々に議論されています。"
    },
    {
      "indent": 3,
      "text": "When sending an SCTP packet, the endpoint MUST fill in the Verification Tag field of the outbound packet with the tag value in the Initiate Tag parameter of the INIT or INIT ACK received from its peer.",
      "ja": "SCTPパケットを送信する場合、エンドポイントは、INIT ACKがピアから受信したINITまたは開始タグパラメータのタグ値を持つ発信パケットの検証タグフィールドに入力しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When receiving an SCTP packet, the endpoint MUST ensure that the value in the Verification Tag field of the received SCTP packet matches its own tag. If the received Verification Tag value does not match the receiver's own tag value, the receiver shall silently discard the packet and shall not process it any further except for those cases listed in Section 8.5.1 below.",
      "ja": "SCTPパケットを受信すると、エンドポイントは受け取ったSCTPパケットの検証タグフィールドの値は、独自のタグと一致していることを確認しなければなりません。受け取った検証タグ値が受信者自身のタグ値と一致しない場合、受信機は静かにパケットを破棄するものとし、以下のセクション8.5.1に記載されているような場合を除き、いかなるさらにそれを処理してはなりません。"
    },
    {
      "indent": 0,
      "text": "8.5.1. Exceptions in Verification Tag Rules",
      "section_title": true,
      "ja": "8.5.1。検証タグのルールでの例外"
    },
    {
      "indent": 3,
      "text": "A) Rules for packet carrying INIT:",
      "ja": "A）INITを運ぶパケットのためのルール："
    },
    {
      "indent": 3,
      "text": "- The sender MUST set the Verification Tag of the packet to 0.",
      "ja": " - 送信者は0に、パケットの検証タグを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "- When an endpoint receives an SCTP packet with the Verification Tag set to 0, it should verify that the packet contains only an INIT chunk. Otherwise, the receiver MUST silently discard the packet.",
      "ja": " - エンドポイントが0に設定され検証タグとSCTPパケットを受信すると、パケットが唯一のINITチャンクが含まれていることを確認する必要があります。そうでない場合、受信機は静かにパケットを捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "B) Rules for packet carrying ABORT:",
      "ja": "B）ABORTを運ぶパケットのためのルール："
    },
    {
      "indent": 3,
      "text": "- The endpoint MUST always fill in the Verification Tag field of the outbound packet with the destination endpoint's tag value, if it is known.",
      "ja": " - それがわかっている場合エンドポイントは常に、宛先エンドポイントのタグ値とアウトバウンドパケットの検証タグフィールドに入力する必要があります。"
    },
    {
      "indent": 3,
      "text": "- If the ABORT is sent in response to an OOTB packet, the endpoint MUST follow the procedure described in Section 8.4.",
      "ja": " -  ABORTはOOTBパケットに応答して送信された場合、エンドポイントは、8.4節で説明する手順に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "- The receiver of an ABORT MUST accept the packet if the Verification Tag field of the packet matches its own tag and the T bit is not set OR if it is set to its peer's tag and the T bit is set in the Chunk Flags. Otherwise, the receiver MUST silently discard the packet and take no further action.",
      "ja": " - パケットの検証タグフィールドは、独自のタグと一致し、Tビットがセットされていないか、それはそのピアのタグに設定された場合にTビットはチャンクフラグに設定されている場合、ABORTの受信機は、パケットを受け入れなければなりません。そうでない場合、受信機は静かにパケットを破棄し、それ以上の行動を取らないしなければなりません。"
    },
    {
      "indent": 3,
      "text": "C) Rules for packet carrying SHUTDOWN COMPLETE:",
      "ja": "SHUTDOWNのCOMPLETEを運ぶパケットのためC）ルール："
    },
    {
      "indent": 3,
      "text": "- When sending a SHUTDOWN COMPLETE, if the receiver of the SHUTDOWN ACK has a TCB, then the destination endpoint's tag MUST be used, and the T bit MUST NOT be set. Only where no TCB exists should the sender use the Verification Tag from the SHUTDOWN ACK, and MUST set the T bit.",
      "ja": " - シャットダウンCOMPLETEを送信するときSHUTDOWN ACKの受信機はTCBを有する場合、宛先エンドポイントのタグを使用しなければなりません、そしてTビットが設定されてはいけません。何TCBは、送信者はSHUTDOWNのACKから検証タグを使用する必要がありますし、Tビットを設定しなければなりません存在しない場合のみ。"
    },
    {
      "indent": 3,
      "text": "- The receiver of a SHUTDOWN COMPLETE shall accept the packet if the Verification Tag field of the packet matches its own tag and the T bit is not set OR if it is set to its peer's tag and the T bit is set in the Chunk Flags. Otherwise, the receiver MUST silently discard the packet and take no further action. An endpoint MUST ignore the SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.",
      "ja": " - パケットの検証タグフィールドは、独自のタグと一致し、Tビットがセットされていないか、それはそのピアのタグに設定された場合にTビットはチャンクフラグに設定されている場合、COMPLETE SHUTDOWNの受信機がパケットを受け入れるもの。そうでない場合、受信機は静かにパケットを破棄し、それ以上の行動を取らないしなければなりません。それはSHUTDOWN-ACK-SENT状態にない場合、エンドポイントは、SHUTDOWNのCOMPLETEを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "D) Rules for packet carrying a COOKIE ECHO",
      "ja": "D）COOKIE ECHOを運ぶパケットのためのルール"
    },
    {
      "indent": 3,
      "text": "- When sending a COOKIE ECHO, the endpoint MUST use the value of the Initiate Tag received in the INIT ACK.",
      "ja": " -  COOKIE ECHOを送信する場合、エンドポイントは、INIT ACKで受信開始タグの値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "- The receiver of a COOKIE ECHO follows the procedures in Section 5.",
      "ja": " -  COOKIE ECHOの受信機は、第5の手順に従います。"
    },
    {
      "indent": 3,
      "text": "E) Rules for packet carrying a SHUTDOWN ACK",
      "ja": "SHUTDOWN ACKを運ぶパケットのためのE）のルール"
    },
    {
      "indent": 3,
      "text": "- If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state the procedures in Section 8.4 SHOULD be followed; in other words, it should be treated as an Out Of The Blue packet.",
      "ja": " - 受信機がCOOKIE-ECHOEDまたはCOOKIE-WAIT状態にある場合、セクション8.4の手順に従うべきです。言い換えれば、それはブルーパケットのうち、として扱われるべきです。"
    },
    {
      "indent": 0,
      "text": "9. Termination of Association",
      "section_title": true,
      "ja": "協会の9.終了"
    },
    {
      "indent": 3,
      "text": "An endpoint should terminate its association when it exits from service. An association can be terminated by either abort or shutdown. An abort of an association is abortive by definition in that any data pending on either end of the association is discarded and not delivered to the peer. A shutdown of an association is considered a graceful close where all data in queue by either endpoint is delivered to the respective peers. However, in the case of a shutdown, SCTP does not support a half-open state (like TCP) wherein one side may continue sending data while the other end is closed. When either endpoint performs a shutdown, the association on each peer will stop accepting new data from its user and only deliver data in queue at the time of sending or receiving the SHUTDOWN chunk.",
      "ja": "それはサービスから出たとき、エンドポイントは、その関連付けを終了する必要があります。協会は、中止またはシャットダウンのいずれかによって終了することができます。関連の中止は、関連の両端に保留中のデータが破棄され、ピアに配信されないという点で、定義により不完全です。関連のシャットダウンは、いずれかのエンドポイントによってキュー内のすべてのデータが各ピアに配信される優雅近いと考えられます。しかし、シャットダウンの場合には、SCTPは、他端を閉じた状態で一方の側がデータを送信し続けることができる特徴（TCPなど）半開状態をサポートしていません。いずれかのエンドポイントがシャットダウンを行う場合、各ピアの関連付けは、ユーザからの新しいデータの受け入れを停止のみSHUTDOWNチャンクを送信または受信時にキュー内のデータを配信します。"
    },
    {
      "indent": 0,
      "text": "9.1. Abort of an Association",
      "section_title": true,
      "ja": "9.1。協会の中止"
    },
    {
      "indent": 3,
      "text": "When an endpoint decides to abort an existing association, it MUST send an ABORT chunk to its peer endpoint. The sender MUST fill in the peer's Verification Tag in the outbound packet and MUST NOT bundle any DATA chunk with the ABORT. If the association is aborted on request of the upper layer, a User-Initiated Abort error cause (see Section 3.3.10.12) SHOULD be present in the ABORT chunk.",
      "ja": "エンドポイントは、既存の関連付けを中止することを決定したときは、そのピアエンドポイントにABORTチャンクを送らなければなりません。送信者は、発信パケットにピアの検証タグに記入しなければならないとABORTで任意のデータチャンクをバンドルしてはなりません。関連付けは、上層の要求に中止された場合、ユーザー開始アボートエラー原因（セクション3.3.10.12参照）ABORTチャンク中に存在すべきです。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST NOT respond to any received packet that contains an ABORT chunk (also see Section 8.4).",
      "ja": "エンドポイントは、（また、8.4節を参照）ABORTチャンクを含む任意の受信パケットに応じてはいけません。"
    },
    {
      "indent": 3,
      "text": "An endpoint receiving an ABORT MUST apply the special Verification Tag check rules described in Section 8.5.1.",
      "ja": "ABORTを受けたエンドポイントは、セクション8.5.1で説明した特別な検証タグのチェックルールを適用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "After checking the Verification Tag, the receiving endpoint MUST remove the association from its record and SHOULD report the termination to its upper layer. If a User-Initiated Abort error cause is present in the ABORT chunk, the Upper Layer Abort Reason SHOULD be made available to the upper layer.",
      "ja": "検証タグをチェックした後、受信側のエンドポイントは、そのレコードから関連付けを削除しなければならないし、その上層に終了を報告する必要があります。ユーザ起動中止エラー原因がABORTチャンクに存在する場合、上位層中止理由は、上位層に利用できるようにすべきです。"
    },
    {
      "indent": 0,
      "text": "9.2. Shutdown of an Association",
      "section_title": true,
      "ja": "9.2。協会のシャットダウン"
    },
    {
      "indent": 3,
      "text": "Using the SHUTDOWN primitive (see Section 10.1), the upper layer of an endpoint in an association can gracefully close the association. This will allow all outstanding DATA chunks from the peer of the shutdown initiator to be delivered before the association terminates.",
      "ja": "プリミティブSHUTDOWNを使用して（10.1節を参照）、関連エンドポイントの上層が正常アソシエーションを閉じることができます。これは、関連付けが終了する前にシャットダウン開始のピアからのすべての未処理データのチャンクが配信されるようになります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the SHUTDOWN primitive from its upper layer, the endpoint enters the SHUTDOWN-PENDING state and remains there until all outstanding data has been acknowledged by its peer. The endpoint accepts no new data from its upper layer, but retransmits data to the far end if necessary to fill gaps.",
      "ja": "その上位層からプリミティブSHUTDOWNを受信すると、エンドポイントは、SHUTDOWN-PENDING状態に入り、すべての未処理データは、そのピアによって承認されるまで残っています。エンドポイントは、その上位層から新しいデータを受け入れませんが、ギャップを埋めるために必要に応じて、遠端にデータを再送します。"
    },
    {
      "indent": 3,
      "text": "Once all its outstanding data has been acknowledged, the endpoint shall send a SHUTDOWN chunk to its peer including in the Cumulative TSN Ack field the last sequential TSN it has received from the peer. It shall then start the T2-shutdown timer and enter the SHUTDOWN-SENT state. If the timer expires, the endpoint must resend the SHUTDOWN with the updated last sequential TSN received from its peer.",
      "ja": "そのすべての未処理データが確認された後、エンドポイントは、それがピアから受信した累積TSN ACKフィールドの最後のシーケンシャルTSNを含むピアにSHUTDOWNチャンクを送信しなければなりません。その後、T2-シャットダウンタイマーを起動し、SHUTDOWN-SENT状態に入るものとします。タイマーが期限切れになった場合、エンドポイントはTSNがピアから受信した最後に更新シーケンシャルでSHUTDOWNを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The rules in Section 6.3 MUST be followed to determine the proper timer value for T2-shutdown. To indicate any gaps in TSN, the endpoint may also bundle a SACK with the SHUTDOWN chunk in the same SCTP packet.",
      "ja": "セクション6.3のルールは、T2-シャットダウンのための適切なタイマ値を決定するために従わなければなりません。 TSNの任意のギャップを示すために、エンドポイントは、同じSCTPパケットにSHUTDOWNチャンクとSACKをバンドルすることができます。"
    },
    {
      "indent": 3,
      "text": "An endpoint should limit the number of retransmissions of the SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'. If this threshold is exceeded, the endpoint should destroy the TCB and MUST report the peer endpoint unreachable to the upper layer (and thus the association enters the CLOSED state). The reception of any packet from its peer (i.e., as the peer sends all of its queued DATA chunks) should clear the endpoint's retransmission count and restart the T2-shutdown timer, giving its peer ample opportunity to transmit all of its queued DATA chunks that have not yet been sent.",
      "ja": "エンドポイントは、プロトコルパラメータ「Association.Max.Retrans」にSHUTDOWNチャンクの再送回数を制限する必要があります。このしきい値を超えた場合、エンドポイントはTCBを破壊する必要があり、上位層に到達できピアエンドポイントを報告しなければならない（したがって、関連付けは、CLOSED状態に入ります）。そのピア（すなわち、ピアはそのキューに入れられたDATAチャンクの全てを送りなど）から任意のパケットの受信は、エンドポイントの再送回数をクリアし、T2-シャットダウンタイマーを再起動し、そのそのキューに入れられたDATAチャンクの全てを送信するピア十分な機会を与えなければなりませんまだ送信されていません。"
    },
    {
      "indent": 3,
      "text": "Upon reception of the SHUTDOWN, the peer endpoint shall",
      "ja": "SHUTDOWNを受信すると、ピアエンドポイントは、条"
    },
    {
      "indent": 3,
      "text": "- enter the SHUTDOWN-RECEIVED state,",
      "ja": " -  SHUTDOWN-RECEIVED状態に入り、"
    },
    {
      "indent": 3,
      "text": "- stop accepting new data from its SCTP user, and",
      "ja": " - そのSCTPユーザからの新しいデータの受け入れを停止し、"
    },
    {
      "indent": 3,
      "text": "- verify, by checking the Cumulative TSN Ack field of the chunk, that all its outstanding DATA chunks have been received by the SHUTDOWN sender.",
      "ja": " - そのすべての未処理データチャンクは、SHUTDOWN送信者が受信したことを、チャンクの累積TSN ACKフィールドをチェックして、確認してください。"
    },
    {
      "indent": 3,
      "text": "Once an endpoint has reached the SHUTDOWN-RECEIVED state, it MUST NOT send a SHUTDOWN in response to a ULP request, and should discard subsequent SHUTDOWN chunks.",
      "ja": "エンドポイントがSHUTDOWN-RECEIVED状態に達したら、それはULPの要求に応じてSHUTDOWNを送ってはいけません、そしてそれに続くSHUTDOWNチャンクを破棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If there are still outstanding DATA chunks left, the SHUTDOWN receiver MUST continue to follow normal data transmission procedures defined in Section 6, until all outstanding DATA chunks are acknowledged; however, the SHUTDOWN receiver MUST NOT accept new data from its SCTP user.",
      "ja": "左の未処理データチャンクがまだある場合、SHUTDOWN受信機は、すべての未処理データチャンクが確認されるまで、セクション6で定義された通常のデータ送信手順に従うし続けなければなりません。しかし、SHUTDOWN受信機はそのSCTPユーザからの新しいデータを受け入れてはいけません。"
    },
    {
      "indent": 3,
      "text": "While in the SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately respond to each received packet containing one or more DATA chunks with a SHUTDOWN chunk and restart the T2-shutdown timer. If a SHUTDOWN chunk by itself cannot acknowledge all of the received DATA chunks (i.e., there are TSNs that can be acknowledged that are larger than the cumulative TSN, and thus gaps exist in the TSN sequence), or if duplicate TSNs have been received, then a SACK chunk MUST also be sent.",
      "ja": "SHUTDOWN-SENT状態にある間、SHUTDOWN送信者はすぐにSHUTDOWNチャンク1つのまたは複数のデータチャンクを含む各受信パケットに対応し、T2-シャットダウンタイマーを再起動する必要があります。重複のTSNが受信された場合、それ自体でSHUTDOWNチャンクは、受信したデータチャンクの全て（すなわち、累積TSNよりも大きいことを認識し、したがってギャップがTSN配列内に存在することができるのTSNがある）、または確認できない場合、その後、SACKチャンクも送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sender of the SHUTDOWN MAY also start an overall guard timer 'T5-shutdown-guard' to bound the overall time for the shutdown sequence. At the expiration of this timer, the sender SHOULD abort the association by sending an ABORT chunk. If the 'T5-shutdown-guard' timer is used, it SHOULD be set to the recommended value of 5 times 'RTO.Max'.",
      "ja": "SHUTDOWNの送信者は、全体的なガードタイマ「T5シャットダウン・ガード」はシャットダウンシーケンスのための全体的な時間を拘束するために起動することがあります。このタイマーの満了時に、送信側はABORTチャンクを送信することにより、関連付けを中止すべきです。 「T5シャットダウン・ガード」タイマーが使用されている場合、それが5回「RTO.Max」の推奨値に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the receiver of the SHUTDOWN has no more outstanding DATA chunks, the SHUTDOWN receiver MUST send a SHUTDOWN ACK and start a T2- shutdown timer of its own, entering the SHUTDOWN-ACK-SENT state. If the timer expires, the endpoint must resend the SHUTDOWN ACK.",
      "ja": "SHUTDOWNの受信機はこれ以上の未処理データチャンクを持っていない場合は、SHUTDOWN受信機はSHUTDOWN-ACK-SENT状態に入る、SHUTDOWN ACKを送信し、独自のT2-シャットダウンタイマーを起動する必要があります。タイマーが期限切れになった場合、エンドポイントは、SHUTDOWN ACKを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The sender of the SHUTDOWN ACK should limit the number of retransmissions of the SHUTDOWN ACK chunk to the protocol parameter 'Association.Max.Retrans'. If this threshold is exceeded, the endpoint should destroy the TCB and may report the peer endpoint unreachable to the upper layer (and thus the association enters the CLOSED state).",
      "ja": "SHUTDOWN ACKの送信者は、プロトコルパラメータ「Association.Max.Retrans」にSHUTDOWN ACKチャンクの再送回数を制限する必要があります。このしきい値を超えた場合、エンドポイントはTCBを破壊する必要があり、上位層に到達できピアエンドポイントを報告することができる（したがって、関連付けは、CLOSED状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its peer, and remove all record of the association.",
      "ja": "SHUTDOWNのACKを受信すると、SHUTDOWN送信者は、T2-シャットダウンタイマーを停止しなければならないピアにSHUTDOWN COMPLETEチャンクを送信し、協会のすべてのレコードを削除します。"
    },
    {
      "indent": 3,
      "text": "Upon reception of the SHUTDOWN COMPLETE chunk, the endpoint will verify that it is in the SHUTDOWN-ACK-SENT state; if it is not, the chunk should be discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state, the endpoint should stop the T2-shutdown timer and remove all knowledge of the association (and thus the association enters the CLOSED state).",
      "ja": "SHUTDOWN COMPLETEチャンクを受信すると、エンドポイントは、それがSHUTDOWN-ACK-SENT状態にあることを確認します。そうでない場合、チャンクは破棄されなければなりません。エンドポイントがSHUTDOWN-ACK-SENT状態にある場合、エンドポイントは、T2-シャットダウンタイマを停止し、関連のすべての知識を削除しなければならない（従って、関連付けは、CLOSED状態に入ります）。"
    },
    {
      "indent": 3,
      "text": "An endpoint SHOULD ensure that all its outstanding DATA chunks have been acknowledged before initiating the shutdown procedure.",
      "ja": "エンドポイントは、そのすべての未処理データのチャンクはシャットダウン手順を開始する前に承認されていることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint should reject any new data request from its upper layer if it is in the SHUTDOWN-PENDING, SHUTDOWN-SENT, SHUTDOWN-RECEIVED, or SHUTDOWN-ACK-SENT state.",
      "ja": "それはSHUTDOWN-PENDING、SHUTDOWN-SENT、SHUTDOWN-RECEIVED、またはSHUTDOWN-ACK-SENT状態にある場合、エンドポイントは、上位層から新たなデータ要求を拒否すべきです。"
    },
    {
      "indent": 3,
      "text": "If an endpoint is in the SHUTDOWN-ACK-SENT state and receives an INIT chunk (e.g., if the SHUTDOWN COMPLETE was lost) with source and destination transport addresses (either in the IP addresses or in the INIT chunk) that belong to this association, it should discard the INIT chunk and retransmit the SHUTDOWN ACK chunk.",
      "ja": "エンドポイントは、SHUTDOWN-ACK-SENT状態にあり、（SHUTDOWNのCOMPLETEが失われた場合など、）INITチャンクを受信した場合、この協会に所属し、送信元と宛先トランスポートアドレス（IPアドレスまたはINITチャンク内のいずれか）と、それはINITチャンクを破棄し、SHUTDOWN ACKチャンクを再送する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: Receipt of an INIT with the same source and destination IP addresses as used in transport addresses assigned to an endpoint but with a different port number indicates the initialization of a separate association.",
      "ja": "注：エンドポイントに割り当てられたトランスポート・アドレスではなく異なるポート番号で使用したのと同じ送信元および宛先IPアドレスを持つINITの受信は別の関連の初期化を示しています。"
    },
    {
      "indent": 3,
      "text": "The sender of the INIT or COOKIE ECHO should respond to the receipt of a SHUTDOWN ACK with a stand-alone SHUTDOWN COMPLETE in an SCTP packet with the Verification Tag field of its common header set to the same tag that was received in the SHUTDOWN ACK packet. This is considered an Out of the Blue packet as defined in Section 8.4. The sender of the INIT lets T1-init continue running and remains in the COOKIE-WAIT or COOKIE-ECHOED state. Normal T1-init timer expiration will cause the INIT or COOKIE chunk to be retransmitted and thus start a new association.",
      "ja": "INITまたはCOOKIE ECHOの送信者はSHUTDOWN ACKパケットで受信された同じタグに設定された共通ヘッダの検証タグフィールドを持つSCTPパケット内COMPLETEスタンドアロンSHUTDOWNとSHUTDOWN ACKの受信に応答しなければなりません。セクション8.4で定義されたように、これはブルーパケットのうち、と考えられています。 INITの送信者はT1-initが実行を継続することができますし、COOKIE-WAITまたはCOOKIE-ECHOED状態のまま。通常T1-のinitタイマ満了はINITまたはCOOKIEチャンクが再送させ、したがって、新しい関連付けを開始します。"
    },
    {
      "indent": 3,
      "text": "If a SHUTDOWN is received in the COOKIE-WAIT or COOKIE ECHOED state, the SHUTDOWN chunk SHOULD be silently discarded.",
      "ja": "シャットダウンがCOOKIE-WAITまたはCOOKIEエコー状態で受信された場合、SHUTDOWNチャンクは静かに捨てられるべきです。"
    },
    {
      "indent": 3,
      "text": "If an endpoint is in the SHUTDOWN-SENT state and receives a SHUTDOWN chunk from its peer, the endpoint shall respond immediately with a SHUTDOWN ACK to its peer, and move into the SHUTDOWN-ACK-SENT state restarting its T2-shutdown timer.",
      "ja": "エンドポイントがSHUTDOWN-SENT状態にあり、そのピアからSHUTDOWNチャンクを受信した場合、エンドポイントは、そのピアにSHUTDOWNのACKで即座に対応し、そのT2-シャットダウンタイマーを再起動SHUTDOWN-ACK-SENT状態に移行するものとします。"
    },
    {
      "indent": 3,
      "text": "If an endpoint is in the SHUTDOWN-ACK-SENT state and receives a SHUTDOWN ACK, it shall stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its peer, and remove all record of the association.",
      "ja": "エンドポイントがSHUTDOWN-ACK-SENT状態にあり、SHUTDOWN ACKを受信した場合、それは、T2-シャットダウンタイマーを停止するピアにSHUTDOWN COMPLETEチャンクを送信し、協会のすべてのレコードを削除しなければなりません。"
    },
    {
      "indent": 0,
      "text": "10. Interface with Upper Layer",
      "section_title": true,
      "ja": "上位層とのインタフェース10"
    },
    {
      "indent": 3,
      "text": "The Upper Layer Protocols (ULPs) shall request services by passing primitives to SCTP and shall receive notifications from SCTP for various events.",
      "ja": "上位層プロトコル（のULP）がSCTPにプリミティブを渡すことによってサービスを要求するものとし、様々なイベントのためにSCTPから通知を受けなければなりません。"
    },
    {
      "indent": 3,
      "text": "The primitives and notifications described in this section should be used as a guideline for implementing SCTP. The following functional description of ULP interface primitives is shown for illustrative purposes. Different SCTP implementations may have different ULP interfaces. However, all SCTPs must provide a certain minimum set of services to guarantee that all SCTP implementations can support the same protocol hierarchy.",
      "ja": "このセクションで説明するプリミティブと通知はSCTPを実施するための指針として使用されるべきです。 ULPインターフェースプリミティブの以下の機能の説明は、例示の目的で示されています。異なるSCTP実装は異なるULPインターフェイスを有していてもよいです。しかし、すべてのSCTPsは、すべてのSCTP実装が同じプロトコル階層をサポートできることを保証するために、サービスの特定の最小セットを提供しなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.1. ULP-to-SCTP",
      "section_title": true,
      "ja": "10.1。 ULPツーSCTP"
    },
    {
      "indent": 3,
      "text": "The following sections functionally characterize a ULP/SCTP interface. The notation used is similar to most procedure or function calls in high-level languages.",
      "ja": "以下のセクションでは、機能ULP / SCTPインタフェースを特徴付けます。使用される表記法は、高レベル言語で最もプロシージャまたは関数呼び出しと同様です。"
    },
    {
      "indent": 3,
      "text": "The ULP primitives described below specify the basic functions that SCTP must perform to support inter-process communication. Individual implementations must define their own exact format, and may provide combinations or subsets of the basic functions in single calls.",
      "ja": "以下に説明するULPプリミティブは、SCTPは、プロセス間通信をサポートするために必要な基本機能を指定します。個々の実装は、独自の正確な形式を定義する必要があり、単一の呼び出しで基本的な機能の組み合わせまたはサブセットを提供することができます。"
    },
    {
      "indent": 3,
      "text": "A) Initialize",
      "ja": "A）の初期化"
    },
    {
      "indent": 6,
      "text": "Format: INITIALIZE ([local port],[local eligible address list])-> local SCTP instance name",
      "ja": "フォーマット：INITIALIZE（[ローカルポート]、[ローカル適格アドレスリスト]） - >ローカルSCTPインスタンス名"
    },
    {
      "indent": 3,
      "text": "This primitive allows SCTP to initialize its internal data structures and allocate necessary resources for setting up its operation environment. Once SCTP is initialized, ULP can communicate directly with other endpoints without re-invoking this primitive.",
      "ja": "このプリミティブは、SCTPは、その内部データ構造を初期化し、その動作環境を設定するために必要なリソースを割り当てることができます。 SCTPが初期化されると、ULPは、このプリミティブを再起動せずに他のエンドポイントと直接通信することができます。"
    },
    {
      "indent": 3,
      "text": "SCTP will return a local SCTP instance name to the ULP.",
      "ja": "SCTPはULPにローカルSCTPインスタンス名を返します。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "無し。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "The following types of attributes may be passed along with the primitive:",
      "ja": "属性の種類は次のプリミティブと一緒に渡されます："
    },
    {
      "indent": 3,
      "text": "o local port - SCTP port number, if ULP wants it to be specified.",
      "ja": "Oローカルポート -  SCTPポート番号、ULPはこれを指定したい場合。"
    },
    {
      "indent": 3,
      "text": "o local eligible address list - an address list that the local SCTP endpoint should bind. By default, if an address list is not included, all IP addresses assigned to the host should be used by the local endpoint.",
      "ja": "Oローカル適格アドレスリスト - ローカルSCTPエンドポイントがバインドするアドレスリスト。アドレスリストが含まれていない場合、デフォルトでは、ホストに割り当てられたすべてのIPアドレスは、ローカルエンドポイントで使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: If this optional attribute is supported by an implementation, it will be the responsibility of the implementation to enforce that the IP source address field of any SCTP packets sent out by this endpoint contains one of the IP addresses indicated in the local eligible address list.",
      "ja": "実装上の注意：このオプションの属性が実装によってサポートされている場合は、このエンドポイントによって送信されるすべてのSCTPパケットのIPソースアドレスフィールドは、ローカル資格のアドレスに示されているIPアドレスの1つが含まれていることを強制するために、実装の責任になりますリスト。"
    },
    {
      "indent": 3,
      "text": "B) Associate",
      "ja": "B）准"
    },
    {
      "indent": 6,
      "text": "Format: ASSOCIATE(local SCTP instance name, destination transport addr, outbound stream count) -> association id [,destination transport addr list] [,outbound stream count]",
      "ja": "フォーマット：ASSOCIATE（ローカルSCTPインスタンス名、宛先輸送ADDR、アウトバウンドストリーム数） - >アソシエーションID [、送信先トランスポートADDRリスト] [、アウトバウンドストリーム数]"
    },
    {
      "indent": 3,
      "text": "This primitive allows the upper layer to initiate an association to a specific peer endpoint.",
      "ja": "このプリミティブは、上位層が特定のピアエンドポイントにアソシエーションを開始することを可能にします。"
    },
    {
      "indent": 3,
      "text": "The peer endpoint shall be specified by one of the transport addresses that defines the endpoint (see Section 1.3). If the local SCTP instance has not been initialized, the ASSOCIATE is considered an error.",
      "ja": "ピアエンドポイントがエンドポイントを定義するトランスポート・アドレスのいずれかで指定しなければならない（セクション1.3を参照）。ローカルSCTPインスタンスが初期化されていない場合、ASSOCIATEは誤りであると考えられます。"
    },
    {
      "indent": 3,
      "text": "An association id, which is a local handle to the SCTP association, will be returned on successful establishment of the association. If SCTP is not able to open an SCTP association with the peer endpoint, an error is returned.",
      "ja": "SCTP協会のローカルのハンドルである協会イドは、協会の成功の確立に返されます。 SCTPは、ピアエンドポイントとのSCTPアソシエーションを開くことができない場合は、エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Other association parameters may be returned, including the complete destination transport addresses of the peer as well as the outbound stream count of the local endpoint. One of the transport addresses from the returned destination addresses will be selected by the local endpoint as default primary path for sending SCTP packets to this peer. The returned \"destination transport addr list\" can be used by the ULP to change the default primary path or to force sending a packet to a specific transport address.",
      "ja": "他の関連パラメータは、ピアの完全な宛先トランスポートアドレス、ならびにローカルエンドポイントのアウトバウンドストリーム数を含め、戻されてもよいです。返された宛先アドレスからトランスポート・アドレスの一つは、このピアにSCTPパケットを送信するためのデフォルトのプライマリパスとしてローカルエンドポイントによって選択されるであろう。返された「宛先輸送addrのリストは、」デフォルトのプライマリ・パスを変更したり、特定のトランスポートアドレスにパケットを送信する強制的にULPで使用することができます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: If ASSOCIATE primitive is implemented as a blocking function call, the ASSOCIATE primitive can return association parameters in addition to the association id upon successful establishment. If ASSOCIATE primitive is implemented as a non-blocking call, only the association id shall be returned and association parameters shall be passed using the COMMUNICATION UP notification.",
      "ja": "実装上の注意：ASSOCIATEプリミティブはブロッキング関数呼び出しとして実装されている場合は、プリミティブASSOCIATEは成功確立時に協会イドに加えて、関連パラメータを返すことができます。 ASSOCIATEプリミティブが非ブロッキング・コールとして実装されている場合、唯一の関連IDが返さなければならないと関連パラメータは、通知を通信を使用して渡さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o local SCTP instance name - obtained from the INITIALIZE operation.",
      "ja": "OローカルSCTPインスタンス名 -  INITIALIZE操作から得られました。"
    },
    {
      "indent": 3,
      "text": "o destination transport addr - specified as one of the transport addresses of the peer endpoint with which the association is to be established.",
      "ja": "O宛先輸送ADDR  - アソシエーションが確立されるべきピア・エンドポイントのトランスポート・アドレスの一つとして指定されました。"
    },
    {
      "indent": 3,
      "text": "o outbound stream count - the number of outbound streams the ULP would like to open towards this peer endpoint.",
      "ja": "Oアウトバウンドストリーム数 - アウトバウンドストリームの数は、ULPは、このピアエンドポイントに向けて開くようにしたいと思います。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "無し。"
    },
    {
      "indent": 3,
      "text": "C) Shutdown",
      "ja": "C）シャットダウン"
    },
    {
      "indent": 6,
      "text": "Format: SHUTDOWN(association id) -> result",
      "ja": "フォーマット：SHUTDOWN（協会イド） - >結果"
    },
    {
      "indent": 3,
      "text": "Gracefully closes an association. Any locally queued user data will be delivered to the peer. The association will be terminated only after the peer acknowledges all the SCTP packets sent. A success code will be returned on successful termination of the association. If attempting to terminate the association results in a failure, an error code shall be returned.",
      "ja": "優雅に関連付けを閉じます。任意のローカルでキューイングされたユーザデータは、ピアに配信されます。協会は、ピアが送信されたすべてのSCTPパケットを認識した後にのみ終了します。成功コードは、協会の成功終了時に返却されます。故障に関連した結果を終了しようとした場合、エラーコードが返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "無し。"
    },
    {
      "indent": 3,
      "text": "D) Abort",
      "ja": "D）アボート"
    },
    {
      "indent": 6,
      "text": "Format: ABORT(association id [, Upper Layer Abort Reason]) -> result",
      "ja": "フォーマット：ABORT（アソシエーションID [上層中止理由]） - >結果"
    },
    {
      "indent": 3,
      "text": "Ungracefully closes an association. Any locally queued user data will be discarded, and an ABORT chunk is sent to the peer. A success code will be returned on successful abort of the association. If attempting to abort the association results in a failure, an error code shall be returned.",
      "ja": "不正に関連付けを閉じます。任意のローカルキューに入れられたユーザデータが破棄され、ABORTチャンクはピアに送信されます。成功コードは、協会の成功中止に返されます。失敗に関連した結果を中止しようとした場合、エラーコードが返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o Upper Layer Abort Reason - reason of the abort to be passed to the peer.",
      "ja": "O上位層は、理由を中止 - 中断の理由は、ピアに渡されます。"
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "無し。"
    },
    {
      "indent": 3,
      "text": "E) Send",
      "ja": "E）を送信"
    },
    {
      "indent": 4,
      "text": "Format: SEND(association id, buffer address, byte count [,context] [,stream id] [,life time] [,destination transport address] [,unordered flag] [,no-bundle flag] [,payload protocol-id] ) -> result",
      "ja": "フォーマット：（アソシエーションID、バッファアドレス、バイトカウント[コンテキスト] [、ストリームID] [ライフタイム] [、送信先トランスポートアドレス] [、順不同フラグ] [無バンドルフラグ] [、ペイロードプロトコル-IDを送信します]） - >結果"
    },
    {
      "indent": 3,
      "text": "This is the main method to send user data via SCTP.",
      "ja": "これは、SCTPを介してユーザデータを送信するための主要な方法です。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o buffer address - the location where the user message to be transmitted is stored.",
      "ja": "Oバッファアドレス - 送信すべきユーザメッセージが格納される場所。"
    },
    {
      "indent": 3,
      "text": "o byte count - the size of the user data in number of bytes.",
      "ja": "Oバイト数 - バイト数でのユーザーデータのサイズ。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o context - an optional 32-bit integer that will be carried in the sending failure notification to the ULP if the transportation of this user message fails.",
      "ja": "Oコンテキスト - このユーザメッセージの輸送に障害が発生した場合ULPへ送信失敗通知に実施される任意の32ビット整数。"
    },
    {
      "indent": 3,
      "text": "o stream id - to indicate which stream to send the data on. If not specified, stream 0 will be used.",
      "ja": "OストリームIDは - 上でデータを送信するためにどのストリームを示します。指定されていない場合は、ストリーム0が使用されます。"
    },
    {
      "indent": 3,
      "text": "o life time - specifies the life time of the user data. The user data will not be sent by SCTP after the life time expires. This parameter can be used to avoid efforts to transmit stale user messages. SCTP notifies the ULP if the data cannot be initiated to transport (i.e., sent to the destination via SCTP's send primitive) within the life time variable. However, the user data will be transmitted if SCTP has attempted to transmit a chunk before the life time expired.",
      "ja": "Oの人生の時間 - ユーザーデータのライフタイムを指定します。人生の時間が経過した後に、ユーザデータは、SCTPによって送信されません。このパラメータは、古いユーザーメッセージを送信するための努力を回避するために使用することができます。 SCTPは、データを転送するために開始することができない場合はULPに通知する（すなわち、SCTPの送信プリミティブを経由して目的地に送られた）人生の時間変数内。 SCTPは、人生の時間の期限が切れる前にチャンクを送信しようとした場合は、ユーザデータが送信されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In order to better support the data life time option, the transmitter may hold back the assigning of the TSN number to an outbound DATA chunk to the last moment. And, for implementation simplicity, once a TSN number has been assigned the sender should consider the send of this DATA chunk as committed, overriding any life time option attached to the DATA chunk.",
      "ja": "実装上の注意：より良いデータの寿命オプションをサポートするために、送信機は最後の瞬間に、アウトバウンドのDATAチャンクのTSN番号の割り当てをバック保持してもよいです。 TSN番号が割り当てられた後のDATAチャンクに添付されたライフタイム・オプションをオーバーライドし、約束通りや、実装の簡略化のために、送信者は、このデータチャンクの送信を検討すべきです。"
    },
    {
      "indent": 3,
      "text": "o destination transport address - specified as one of the destination transport addresses of the peer endpoint to which this packet should be sent. Whenever possible, SCTP should use this destination transport address for sending the packets, instead of the current primary path.",
      "ja": "O宛先トランスポートアドレス - このパケットが送られるべきであるため、ピアエンドポイントの宛先トランスポートアドレスの一つとして指定されました。可能な限り、SCTPではなく、現在のプライマリパスの、パケットを送信するために、この先のトランスポートアドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o unordered flag - this flag, if present, indicates that the user would like the data delivered in an unordered fashion to the peer (i.e., the U flag is set to 1 on all DATA chunks carrying this message).",
      "ja": "O順不同フラグ - このフラグは、存在する場合、ユーザは、（すなわち、Uフラグは、このメッセージを運ぶすべてのデータチャンクに1に設定されている）ピアに無秩序な方法で配信されたデータを希望することを示しています。"
    },
    {
      "indent": 3,
      "text": "o no-bundle flag - instructs SCTP not to bundle this user data with other outbound DATA chunks. SCTP MAY still bundle even when this flag is present, when faced with network congestion.",
      "ja": "無バンドルフラグ○ - 他のアウトバウンド・データチャンクと、このユーザデータをバンドルしないSCTPを指示します。ネットワークの混雑に直面したとき、このフラグは、存在する場合でも、SCTPはまだバンドルするかもしれません。"
    },
    {
      "indent": 3,
      "text": "o payload protocol-id - a 32-bit unsigned integer that is to be passed to the peer indicating the type of payload protocol data being transmitted. This value is passed as opaque data by SCTP.",
      "ja": "OペイロードプロトコルID  - 送信されるペイロードのプロトコルデータの種類を示すピアに渡される32ビット符号なし整数。この値は、SCTPで不透明なデータとして渡されます。"
    },
    {
      "indent": 3,
      "text": "F) Set Primary",
      "ja": "F）を設定し、プライマリ"
    },
    {
      "indent": 6,
      "text": "Format: SETPRIMARY(association id, destination transport address, [source transport address] ) -> result",
      "ja": "フォーマット：setprimaryを（アソシエーションID、送信先トランスポート・アドレス、[ソーストランスポートアドレス]） - >結果"
    },
    {
      "indent": 3,
      "text": "Instructs the local SCTP to use the specified destination transport address as the primary path for sending packets.",
      "ja": "パケットを送信するための主要経路として指定された宛先のトランスポート・アドレスを使用するローカルSCTPを指示します。"
    },
    {
      "indent": 3,
      "text": "The result of attempting this operation shall be returned. If the specified destination transport address is not present in the \"destination transport address list\" returned earlier in an associate command or communication up notification, an error shall be returned.",
      "ja": "この操作をしようとした結果が返されなければなりません。指定された宛先トランスポートアドレスが「宛先トランスポートアドレスリスト」に存在しない場合は準コマンドや通信アップ通知に早く返され、エラーが返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o destination transport address - specified as one of the transport addresses of the peer endpoint, which should be used as the primary address for sending packets. This overrides the current primary address information maintained by the local SCTP endpoint.",
      "ja": "O宛先トランスポートアドレス - ピア・エンドポイントのトランスポート・アドレスの一つとして指定され、パケットを送信するための一次アドレスとして使用されるべきです。これは、ローカルSCTP終点によって維持、現在のプライマリアドレス情報を上書きします。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o source transport address - optionally, some implementations may allow you to set the default source address placed in all outgoing IP datagrams.",
      "ja": "Oソーストランスポートアドレスは - 必要に応じて、いくつかの実装では、すべての発信IPデータグラムに配置されたデフォルトの送信元アドレスを設定できるようにしてもよいです。"
    },
    {
      "indent": 3,
      "text": "G) Receive",
      "ja": "G）を受信"
    },
    {
      "indent": 4,
      "text": "Format: RECEIVE(association id, buffer address, buffer size [,stream id]) -> byte count [,transport address] [,stream id] [,stream sequence number] [,partial flag] [,delivery number] [,payload protocol-id]",
      "ja": "フォーマット：受信（アソシエーションID、バッファアドレス、バッファサイズ[、ストリームID]） - >バイト数〔、トランスポートアドレス] [、ストリームID] [、ストリーム・シーケンス番号] [、パーシャルフラグ] [伝票番号] [ペイロードプロトコルID]"
    },
    {
      "indent": 3,
      "text": "This primitive shall read the first user message in the SCTP in-queue into the buffer specified by ULP, if there is one available. The size of the message read, in bytes, will be returned. It may, depending on the specific implementation, also return other information such as the sender's address, the stream id on which it is received, whether there are more messages available for retrieval, etc. For ordered messages, their Stream Sequence Number may also be returned.",
      "ja": "利用できるものがある場合には、このプリミティブは、ULPによって指定されたバッファ内にキューSCTPにおける最初のユーザメッセージを読み取るものとします。メッセージの読み取りのサイズは、バイト単位で、返されます。検索のために利用可能なより多くのメッセージがあるかどうかは、特定の実装に応じて、また、そのような送信者のアドレス、それが受信されたストリームIDとして他の情報を返すことができる、等のためにメッセージを注文し、それらのストリームシーケンス番号があってもよいです戻ってきた。"
    },
    {
      "indent": 3,
      "text": "Depending upon the implementation, if this primitive is invoked when no message is available the implementation should return an indication of this condition or should block the invoking process until data does become available.",
      "ja": "このプリミティブはないメッセージが利用できない場合、実装は、この状態の表示を返すべきか、データが利用可能になるなるまで呼び出しプロセスをブロックする呼び出された場合、実装に応じ。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association",
      "ja": "O協会イド -  SCTP協会へのローカルハンドル"
    },
    {
      "indent": 3,
      "text": "o buffer address - the memory location indicated by the ULP to store the received message.",
      "ja": "Oバッファアドレス - 受信したメッセージを格納するためにULPによって示されるメモリ位置。"
    },
    {
      "indent": 3,
      "text": "o buffer size - the maximum size of data to be received, in bytes.",
      "ja": "Oバッファサイズ - データの最大サイズをバイト単位で、受信されます。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o stream id - to indicate which stream to receive the data on.",
      "ja": "OストリームID  - でデータを受信するためにどのストリーム示します。"
    },
    {
      "indent": 3,
      "text": "o Stream Sequence Number - the Stream Sequence Number assigned by the sending SCTP peer.",
      "ja": "Oストリームシーケンス番号 - 送信SCTPピアによって割り当てられたストリームシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this Receive contains a partial delivery of the whole message. When this flag is set, the stream id and Stream Sequence Number MUST accompany this receive. When this flag is set to 0, it indicates that no more deliveries will be received for this Stream Sequence Number.",
      "ja": "O分フラグ - この返さフラグが1に設定されている場合、これは受信メッセージ全体の一部の配信を含んでいます。このフラグが設定されている場合、ストリームID及びストリーム・シーケンス番号は、この受信添付しなければなりません。このフラグが0に設定されている場合、それはより多くの配達は、このストリームシーケンス番号のために受信されないことを示しています。"
    },
    {
      "indent": 3,
      "text": "o payload protocol-id - a 32-bit unsigned integer that is received from the peer indicating the type of payload protocol of the received data. This value is passed as opaque data by SCTP.",
      "ja": "OペイロードプロトコルID  - 受信したデータのペイロードプロトコルの種類を示すピアから受信される32ビットの符号なし整数。この値は、SCTPで不透明なデータとして渡されます。"
    },
    {
      "indent": 3,
      "text": "H) Status",
      "ja": "H）ステータス"
    },
    {
      "indent": 6,
      "text": "Format: STATUS(association id) -> status data",
      "ja": "フォーマット：STATUS（協会イド） - >ステータスデータ"
    },
    {
      "indent": 3,
      "text": "This primitive should return a data block containing the following information:",
      "ja": "このプリミティブは、以下の情報を含むデータブロックを返す必要があります："
    },
    {
      "indent": 6,
      "text": "association connection state, destination transport address list, destination transport address reachability states, current receiver window size, current congestion window sizes, number of unacknowledged DATA chunks, number of DATA chunks pending receipt, primary path, most recent SRTT on primary path, RTO on primary path, SRTT and RTO on other destination addresses, etc.",
      "ja": "領収書、プライマリパス、プライマリパス上の最新のSRTT、RTOの保留中の関連接続状態、先のトランスポートアドレスリスト、送信先トランスポートアドレスの到達可能性の状態、現在の受信ウィンドウサイズ、現在の輻輳ウィンドウサイズ、未確認のDATAチャンクの数、DATAチャンクの数など、他の宛先アドレス、上のプライマリパス、SRTTとRTO"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "無し。"
    },
    {
      "indent": 3,
      "text": "I) Change Heartbeat",
      "ja": "I）の変更ハートビート"
    },
    {
      "indent": 6,
      "text": "Format: CHANGE HEARTBEAT(association id, destination transport address, new state [,interval]) -> result",
      "ja": "フォーマット：CHANGEハートビート（アソシエーションID、送信先トランスポートアドレス、新たな状態[インターバル]） - >結果"
    },
    {
      "indent": 3,
      "text": "Instructs the local endpoint to enable or disable heartbeat on the specified destination transport address.",
      "ja": "指定された宛先トランスポートアドレスにハートビートを有効または無効にするローカルエンドポイントを指示します。"
    },
    {
      "indent": 3,
      "text": "The result of attempting this operation shall be returned.",
      "ja": "この操作をしようとした結果が返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: Even when enabled, heartbeat will not take place if the destination transport address is not idle.",
      "ja": "注：有効場合でも、宛先トランスポートアドレスがアイドル状態でない場合は、ハートビートは行われません。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o destination transport address - specified as one of the transport addresses of the peer endpoint.",
      "ja": "O宛先トランスポートアドレス - ピア・エンドポイントのトランスポート・アドレスの一つとして指定されました。"
    },
    {
      "indent": 3,
      "text": "o new state - the new state of heartbeat for this destination transport address (either enabled or disabled).",
      "ja": "O新しい状態 - この先輸送アドレス（有効または無効のいずれか）のハートビートの新しい状態。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o interval - if present, indicates the frequency of the heartbeat if this is to enable heartbeat on a destination transport address. This value is added to the RTO of the destination transport address. This value, if present, affects all destinations.",
      "ja": "O間隔は - これは、宛先トランスポートアドレスにハートビートを有効にすることである場合に存在する場合、ハートビートの周波数を示します。この値は、先のトランスポートアドレスのRTOに追加されます。この値は、存在する場合、すべての宛先に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "J) Request HeartBeat",
      "ja": "J）リクエストハートビート"
    },
    {
      "indent": 6,
      "text": "Format: REQUESTHEARTBEAT(association id, destination transport address) -> result",
      "ja": "フォーマット：REQUESTHEARTBEAT（アソシエーションID、送信先トランスポートアドレス） - >結果"
    },
    {
      "indent": 3,
      "text": "Instructs the local endpoint to perform a HeartBeat on the specified destination transport address of the given association. The returned result should indicate whether the transmission of the HEARTBEAT chunk to the destination address is successful.",
      "ja": "所与の関連の指定された宛先のトランスポートアドレスにハートビートを実行するローカルエンドポイントに指示します。返される結果は、宛先アドレスにHEARTBEATチャンクの送信が成功したかどうかを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o destination transport address - the transport address of the association on which a heartbeat should be issued.",
      "ja": "O先輸送アドレス - ハートビートが発行されるべきで協会のトランスポートアドレス。"
    },
    {
      "indent": 3,
      "text": "K) Get SRTT Report",
      "ja": "K）SRTTレポートを取得"
    },
    {
      "indent": 6,
      "text": "Format: GETSRTTREPORT(association id, destination transport address) -> srtt result",
      "ja": "フォーマット：GETSRTTREPORT（アソシエーションID、送信先トランスポートアドレス） - > SRTT結果"
    },
    {
      "indent": 3,
      "text": "Instructs the local SCTP to report the current SRTT measurement on the specified destination transport address of the given association. The returned result can be an integer containing the most recent SRTT in milliseconds.",
      "ja": "ローカルSCTPアソシエーションが所与の指定された宛先のトランスポートアドレスに現在のSRTT測定値を報告するように指示します。返される結果は、ミリ秒単位で最新のSRTTを含む整数を指定できます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o destination transport address - the transport address of the association on which the SRTT measurement is to be reported.",
      "ja": "O宛先トランスポートアドレス -  SRTT測定が報告されるべきで関連のトランスポート・アドレス。"
    },
    {
      "indent": 3,
      "text": "L) Set Failure Threshold",
      "ja": "L）エラーしきい値を設定します"
    },
    {
      "indent": 6,
      "text": "Format: SETFAILURETHRESHOLD(association id, destination transport address, failure threshold)",
      "ja": "フォーマット：SETFAILURETHRESHOLD（アソシエーションID、送信先トランスポートアドレス、故障閾値）"
    },
    {
      "indent": 6,
      "text": "-> result",
      "ja": " - >結果"
    },
    {
      "indent": 3,
      "text": "This primitive allows the local SCTP to customize the reachability failure detection threshold 'Path.Max.Retrans' for the specified destination address.",
      "ja": "このプリミティブは、ローカルSCTPが指定した宛先アドレスの到達可能性の障害検出閾値「Path.Max.Retrans」をカスタマイズすることができます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o destination transport address - the transport address of the association on which the failure detection threshold is to be set.",
      "ja": "O宛先トランスポートアドレス - 故障検出閾値を設定するされている関連のトランスポート・アドレス。"
    },
    {
      "indent": 3,
      "text": "o failure threshold - the new value of 'Path.Max.Retrans' for the destination address.",
      "ja": "O障害しきい値 - 宛先アドレスのための「Path.Max.Retrans」の新しい値。"
    },
    {
      "indent": 3,
      "text": "M) Set Protocol Parameters",
      "ja": "M）セットのプロトコル・パラメータ"
    },
    {
      "indent": 6,
      "text": "Format: SETPROTOCOLPARAMETERS(association id, [,destination transport address,] protocol parameter list) -> result",
      "ja": "フォーマット：SETPROTOCOLPARAMETERS（アソシエーションID、[、送信先トランスポート・アドレス、]プロトコルパラメータリスト） - >結果"
    },
    {
      "indent": 3,
      "text": "This primitive allows the local SCTP to customize the protocol parameters.",
      "ja": "このプリミティブは、ローカルSCTPは、プロトコルパラメータをカスタマイズすることができます。"
    },
    {
      "indent": 3,
      "text": "Mandatory attributes:",
      "ja": "必須の属性："
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o protocol parameter list - the specific names and values of the protocol parameters (e.g., Association.Max.Retrans; see Section 15) that the SCTP user wishes to customize.",
      "ja": "Oプロトコルパラメータリスト - プロトコルパラメータの特定の名前と値（例えば、Association.Max.Retrans、セクション15を参照）をSCTPユーザがカスタマイズすることを望みます。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o destination transport address - some of the protocol parameters may be set on a per destination transport address basis.",
      "ja": "O宛先トランスポートアドレス - プロトコルパラメータの一部は、宛先ごとにトランスポートアドレスに基づいて設定してもよいです。"
    },
    {
      "indent": 3,
      "text": "N) Receive Unsent Message",
      "ja": "N）未送信のメッセージを受け取ります"
    },
    {
      "indent": 6,
      "text": "Format: RECEIVE_UNSENT(data retrieval id, buffer address, buffer size [,stream id] [, stream sequence number] [,partial flag] [,payload protocol-id])",
      "ja": "フォーマット：RECEIVE_UNSENT（データ検索ID、バッファアドレス、バッファサイズ[、ストリームID] [、ストリーム・シーケンス番号] [、パーシャルフラグ] [、ペイロードプロトコルID]）"
    },
    {
      "indent": 3,
      "text": "o data retrieval id - the identification passed to the ULP in the failure notification.",
      "ja": "Oデータ検索IDは - 識別は、障害通知にULPに渡されます。"
    },
    {
      "indent": 3,
      "text": "o buffer address - the memory location indicated by the ULP to store the received message.",
      "ja": "Oバッファアドレス - 受信したメッセージを格納するためにULPによって示されるメモリ位置。"
    },
    {
      "indent": 3,
      "text": "o buffer size - the maximum size of data to be received, in bytes.",
      "ja": "Oバッファサイズ - データの最大サイズをバイト単位で、受信されます。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o stream id - this is a return value that is set to indicate which stream the data was sent to.",
      "ja": "OストリームID  - これはに送信されたデータストリームを示すように設定されている戻り値です。"
    },
    {
      "indent": 3,
      "text": "o Stream Sequence Number - this value is returned indicating the Stream Sequence Number that was associated with the message.",
      "ja": "Oストリームシーケンス番号 - この値は、メッセージに関連付けられたストリームシーケンス番号を示す返されます。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this message is a partial delivery of the whole message. When this flag is set, the stream id and Stream Sequence Number MUST accompany this receive. When this flag is set to 0, it indicates that no more deliveries will be received for this Stream Sequence Number.",
      "ja": "O分フラグ - この返さフラグが1に設定されている場合、このメッセージは、メッセージ全体の部分的な送達です。このフラグが設定されている場合、ストリームID及びストリーム・シーケンス番号は、この受信添付しなければなりません。このフラグが0に設定されている場合、それはより多くの配達は、このストリームシーケンス番号のために受信されないことを示しています。"
    },
    {
      "indent": 3,
      "text": "o payload protocol-id - The 32 bit unsigned integer that was sent to be sent to the peer indicating the type of payload protocol of the received data.",
      "ja": "OペイロードプロトコルID  - 受信したデータのペイロードプロトコルの種類を示すピアに送信されるように送られた32ビット符号なし整数。"
    },
    {
      "indent": 3,
      "text": "o Receive Unacknowledged Message",
      "ja": "O未確認のメッセージが表示されます"
    },
    {
      "indent": 6,
      "text": "Format: RECEIVE_UNACKED(data retrieval id, buffer address, buffer size, [,stream id] [, stream sequence number] [,partial flag] [,payload protocol-id])",
      "ja": "フォーマット：RECEIVE_UNACKED（データ検索ID、バッファアドレス、バッファのサイズ、[、ストリームID] [、ストリーム・シーケンス番号] [、パーシャルフラグ] [、ペイロードプロトコルID]）"
    },
    {
      "indent": 3,
      "text": "o data retrieval id - the identification passed to the ULP in the failure notification.",
      "ja": "Oデータ検索IDは - 識別は、障害通知にULPに渡されます。"
    },
    {
      "indent": 3,
      "text": "o buffer address - the memory location indicated by the ULP to store the received message.",
      "ja": "Oバッファアドレス - 受信したメッセージを格納するためにULPによって示されるメモリ位置。"
    },
    {
      "indent": 3,
      "text": "o buffer size - the maximum size of data to be received, in bytes.",
      "ja": "Oバッファサイズ - データの最大サイズをバイト単位で、受信されます。"
    },
    {
      "indent": 3,
      "text": "Optional attributes:",
      "ja": "オプションの属性："
    },
    {
      "indent": 3,
      "text": "o stream id - this is a return value that is set to indicate which stream the data was sent to.",
      "ja": "OストリームID  - これはに送信されたデータストリームを示すように設定されている戻り値です。"
    },
    {
      "indent": 3,
      "text": "o Stream Sequence Number - this value is returned indicating the Stream Sequence Number that was associated with the message.",
      "ja": "Oストリームシーケンス番号 - この値は、メッセージに関連付けられたストリームシーケンス番号を示す返されます。"
    },
    {
      "indent": 3,
      "text": "o partial flag - if this returned flag is set to 1, then this message is a partial delivery of the whole message. When this flag is set, the stream id and Stream Sequence Number MUST accompany this receive. When this flag is set to 0, it indicates that no more deliveries will be received for this Stream Sequence Number.",
      "ja": "O分フラグ - この返さフラグが1に設定されている場合、このメッセージは、メッセージ全体の部分的な送達です。このフラグが設定されている場合、ストリームID及びストリーム・シーケンス番号は、この受信添付しなければなりません。このフラグが0に設定されている場合、それはより多くの配達は、このストリームシーケンス番号のために受信されないことを示しています。"
    },
    {
      "indent": 3,
      "text": "o payload protocol-id - the 32-bit unsigned integer that was sent to the peer indicating the type of payload protocol of the received data.",
      "ja": "OペイロードプロトコルID  - 受信したデータのペイロードプロトコルの種類を示すピアに送られた32ビットの符号なし整数。"
    },
    {
      "indent": 3,
      "text": "P) Destroy SCTP Instance",
      "ja": "P）SCTPインスタンスを破棄"
    },
    {
      "indent": 6,
      "text": "Format: DESTROY(local SCTP instance name)",
      "ja": "フォーマット：DESTROY（ローカルSCTPインスタンス名）"
    },
    {
      "indent": 3,
      "text": "o local SCTP instance name - this is the value that was passed to the application in the initialize primitive and it indicates which SCTP instance is to be destroyed.",
      "ja": "ローカルSCTPインスタンス名○ - このプリミティブの初期化中にアプリケーションに渡された値であり、それは、インスタンスが破棄されるべきSCTP示します。"
    },
    {
      "indent": 0,
      "text": "10.2. SCTP-to-ULP",
      "section_title": true,
      "ja": "10.2。 SCTPツーULP"
    },
    {
      "indent": 3,
      "text": "It is assumed that the operating system or application environment provides a means for the SCTP to asynchronously signal the ULP process. When SCTP does signal a ULP process, certain information is passed to the ULP.",
      "ja": "オペレーティングシステムやアプリケーション環境は、SCTPが非同期ULPプロセスに合図するための手段を提供することが想定されます。 SCTPはULPプロセスに合図ない場合、特定の情報がULPに渡されます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In some cases, this may be done through a separate socket or error channel.",
      "ja": "実装注：いくつかのケースでは、これは別のソケットまたはエラー・チャネルを介して行われてもよいです。"
    },
    {
      "indent": 3,
      "text": "A) DATA ARRIVE notification",
      "ja": "A）DATAは、通知に到着します"
    },
    {
      "indent": 3,
      "text": "SCTP shall invoke this notification on the ULP when a user message is successfully received and ready for retrieval.",
      "ja": "ユーザ・メッセージが正常に受信され、検索のために準備されたときにSCTPはULPにこの通知を起動しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following may optionally be passed with the notification:",
      "ja": "以下に、必要に応じて通知して渡すことができます。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o stream id - to indicate which stream the data is received on.",
      "ja": "OストリームID  - データに受信したストリーミング示します。"
    },
    {
      "indent": 3,
      "text": "B) SEND FAILURE notification",
      "ja": "B）障害通知を送信します"
    },
    {
      "indent": 3,
      "text": "If a message cannot be delivered, SCTP shall invoke this notification on the ULP.",
      "ja": "メッセージが配信できない場合は、SCTPがULPにこの通知を呼び出すものとします。"
    },
    {
      "indent": 3,
      "text": "The following may optionally be passed with the notification:",
      "ja": "以下に、必要に応じて通知して渡すことができます。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o data retrieval id - an identification used to retrieve unsent and unacknowledged data.",
      "ja": "Oデータ検索ID  - 未送信及び未確認データを取得するために使用される識別。"
    },
    {
      "indent": 3,
      "text": "o cause code - indicating the reason of the failure, e.g., size too large, message life time expiration, etc.",
      "ja": "O原因コード - 失敗の理由を示す、例えば、サイズが大きすぎる、メッセージのライフタイムの有効期限、等"
    },
    {
      "indent": 3,
      "text": "o context - optional information associated with this message (see D in Section 10.1).",
      "ja": "Oコンテキスト - このメッセージに関連付けられた任意の情報（セクション10.1でDを参照）。"
    },
    {
      "indent": 3,
      "text": "C) NETWORK STATUS CHANGE notification",
      "ja": "C）ネットワークステータス変更通知"
    },
    {
      "indent": 3,
      "text": "When a destination transport address is marked inactive (e.g., when SCTP detects a failure) or marked active (e.g., when SCTP detects a recovery), SCTP shall invoke this notification on the ULP.",
      "ja": "宛先トランスポートアドレスは（例えば、SCTPは、復旧を検出した場合）（例えば、SCTPの障害を検出した場合）、非アクティブとしてマークまたはアクティブとしてマークされたとき、SCTPはULPにこの通知を起動しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following shall be passed with the notification:",
      "ja": "以下は、通知を渡さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o destination transport address - this indicates the destination transport address of the peer endpoint affected by the change.",
      "ja": "O宛先トランスポートアドレス - これは、変更により影響を受けるピアエンドポイントの宛先トランスポートアドレスを示します。"
    },
    {
      "indent": 3,
      "text": "o new-status - this indicates the new status.",
      "ja": "O新しいステータス - これは新しい状態を示します。"
    },
    {
      "indent": 3,
      "text": "D) COMMUNICATION UP notification",
      "ja": "D）通信UP通知"
    },
    {
      "indent": 3,
      "text": "This notification is used when SCTP becomes ready to send or receive user messages, or when a lost communication to an endpoint is restored.",
      "ja": "SCTPはユーザメッセージを送信または受信する準備ができなった場合、またはエンドポイントへの失われた通信が回復したときに、この通知が使用されています。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: If the ASSOCIATE primitive is implemented as a blocking function call, the association parameters are returned as a result of the ASSOCIATE primitive itself. In that case, COMMUNICATION UP notification is optional at the association initiator's side.",
      "ja": "実装上の注意：プリミティブASSOCIATEは、ブロッキング関数呼び出しとして実装されている場合は、関連パラメータがASSOCIATEプリミティブ自体の結果として返されます。その場合、通信UP通知は、アソシエーション開始者側で任意です。"
    },
    {
      "indent": 3,
      "text": "The following shall be passed with the notification:",
      "ja": "以下は、通知を渡さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o status - This indicates what type of event has occurred.",
      "ja": "Oステータス - これは、発生したイベントの種類を示します。"
    },
    {
      "indent": 3,
      "text": "o destination transport address list - the complete set of transport addresses of the peer.",
      "ja": "O先輸送アドレスリスト - ピアのトランスポートアドレスの完全なセット。"
    },
    {
      "indent": 3,
      "text": "o outbound stream count - the maximum number of streams allowed to be used in this association by the ULP.",
      "ja": "Oアウトバウンドストリーム数 -  ULPにより、この関連で使用することを許可ストリームの最大数。"
    },
    {
      "indent": 3,
      "text": "o inbound stream count - the number of streams the peer endpoint has requested with this association (this may not be the same number as 'outbound stream count').",
      "ja": "Oインバウンドストリーム数 - ピアエンドポイントは、この関連で要求したストリーム数（これは「アウトバウンドストリーム数」と同数でなくてもよいです）。"
    },
    {
      "indent": 3,
      "text": "E) COMMUNICATION LOST notification",
      "ja": "E）COMMUNICATION LOST通知"
    },
    {
      "indent": 3,
      "text": "When SCTP loses communication to an endpoint completely (e.g., via Heartbeats) or detects that the endpoint has performed an abort operation, it shall invoke this notification on the ULP.",
      "ja": "SCTP（例えば、ハートビートを介して）完全にエンドポイントとの通信を失ったか、エンドポイントが中断操作が行われたことを検出すると、それはULPにこの通知を起動しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following shall be passed with the notification:",
      "ja": "以下は、通知を渡さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o status - this indicates what type of event has occurred; the status may indicate that a failure OR a normal termination event occurred in response to a shutdown or abort request.",
      "ja": "Oステータス - これは、発生したイベントの種類を示します。ステータスが障害または正常終了イベントはシャットダウンに反応して発生したことを示したり、要求を中止することがあります。"
    },
    {
      "indent": 3,
      "text": "The following may be passed with the notification:",
      "ja": "以下は通知で渡されます："
    },
    {
      "indent": 3,
      "text": "o data retrieval id - an identification used to retrieve unsent and unacknowledged data.",
      "ja": "Oデータ検索ID  - 未送信及び未確認データを取得するために使用される識別。"
    },
    {
      "indent": 3,
      "text": "o last-acked - the TSN last acked by that peer endpoint.",
      "ja": "O最後-ACKさ -  TSN最後のそのピアエンドポイントでACKさ。"
    },
    {
      "indent": 3,
      "text": "o last-sent - the TSN last sent to that peer endpoint.",
      "ja": "O最後に送られた -  TSNは最後にその同輩終点に送られます。"
    },
    {
      "indent": 3,
      "text": "o Upper Layer Abort Reason - the abort reason specified in case of a user-initiated abort.",
      "ja": "O上位層アボート理由 - ユーザーが開始アボートの場合には指定された中止理由。"
    },
    {
      "indent": 3,
      "text": "F) COMMUNICATION ERROR notification",
      "ja": "F）通信エラー通知"
    },
    {
      "indent": 3,
      "text": "When SCTP receives an ERROR chunk from its peer and decides to notify its ULP, it can invoke this notification on the ULP.",
      "ja": "SCTPは、ピアからのエラーチャンクを受信し、ULPに通知することを決定する場合、それはULPに関するこの通知を呼び出すことができます。"
    },
    {
      "indent": 3,
      "text": "The following can be passed with the notification:",
      "ja": "以下は、通知を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "o error info - this indicates the type of error and optionally some additional information received through the ERROR chunk.",
      "ja": "Oエラー情報 - これはエラーの種類およびエラーチャンクを介して受信し、任意にいくつかの追加情報を示しています。"
    },
    {
      "indent": 3,
      "text": "G) RESTART notification",
      "ja": "G）RESTART通知"
    },
    {
      "indent": 3,
      "text": "When SCTP detects that the peer has restarted, it may send this notification to its ULP.",
      "ja": "SCTPは、ピアが再起動されたことを検出すると、それはそのULPにこの通知を送信することができます。"
    },
    {
      "indent": 3,
      "text": "The following can be passed with the notification:",
      "ja": "以下は、通知を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 3,
      "text": "H) SHUTDOWN COMPLETE notification",
      "ja": "H）SHUTDOWN COMPLETE通知"
    },
    {
      "indent": 3,
      "text": "When SCTP completes the shutdown procedures (Section 9.2), this notification is passed to the upper layer.",
      "ja": "SCTPは、シャットダウン手順（セクション9.2）を完了すると、この通知は、上位層に渡されます。"
    },
    {
      "indent": 3,
      "text": "The following can be passed with the notification:",
      "ja": "以下は、通知を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "o association id - local handle to the SCTP association.",
      "ja": "OアソシエーションID  -  SCTP協会のローカルのハンドル。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11.セキュリティについての考慮事項"
    },
    {
      "indent": 0,
      "text": "11.1. Security Objectives",
      "section_title": true,
      "ja": "11.1。セキュリティ対策方針"
    },
    {
      "indent": 3,
      "text": "As a common transport protocol designed to reliably carry time-sensitive user messages, such as billing or signaling messages for telephony services, between two networked endpoints, SCTP has the following security objectives.",
      "ja": "確実に2つのネットワーク上のエンドポイント間では、そのような請求や電話サービスのためのシグナリングメッセージとして、時間に敏感なユーザーメッセージを運ぶために設計された一般的なトランスポートプロトコルとして、SCTPは、以下のセキュリティ対策方針を持っています。"
    },
    {
      "indent": 3,
      "text": "- availability of reliable and timely data transport services",
      "ja": " - 信頼性の高いタイムリーなデータ・トランスポート・サービスの可用性"
    },
    {
      "indent": 3,
      "text": "- integrity of the user-to-user information carried by SCTP",
      "ja": " -  SCTPによって運ばれるユーザ・ユーザ情報の完全性"
    },
    {
      "indent": 0,
      "text": "11.2. SCTP Responses to Potential Threats",
      "section_title": true,
      "ja": "11.2。潜在的な脅威へのSCTP応答"
    },
    {
      "indent": 3,
      "text": "SCTP may potentially be used in a wide variety of risk situations. It is important for operators of systems running SCTP to analyze their particular situations and decide on the appropriate counter-measures.",
      "ja": "SCTPは、潜在的に危険な状況の多種多様に使用することができます。 SCTPを実行しているシステムの事業者は、特定の状況を分析し、適切な対策を決定することが重要です。"
    },
    {
      "indent": 3,
      "text": "Operators of systems running SCTP should consult [RFC2196] for guidance in securing their site.",
      "ja": "SCTPを実行しているシステムのオペレータは、自分のサイトを確保する上での指針のために[RFC2196]を相談してください。"
    },
    {
      "indent": 0,
      "text": "11.2.1. Countering Insider Attacks",
      "section_title": true,
      "ja": "11.2.1。インサイダー攻撃に対抗"
    },
    {
      "indent": 3,
      "text": "The principles of [RFC2196] should be applied to minimize the risk of theft of information or sabotage by insiders. Such procedures include publication of security policies, control of access at the physical, software, and network levels, and separation of services.",
      "ja": "[RFC2196]の原理は、インサイダーによる情報またはサボタージュの盗難のリスクを最小限にするために適用されるべきです。このような手順は、セキュリティポリシー、物理的にアクセスの制御、ソフトウェア、およびネットワークレベルの出版物、およびサービスの分離が含まれます。"
    },
    {
      "indent": 0,
      "text": "11.2.2. Protecting against Data Corruption in the Network",
      "section_title": true,
      "ja": "11.2.2。ネットワークでのデータ破損からの保護"
    },
    {
      "indent": 3,
      "text": "Where the risk of undetected errors in datagrams delivered by the lower-layer transport services is considered to be too great, additional integrity protection is required. If this additional protection were provided in the application layer, the SCTP header would remain vulnerable to deliberate integrity attacks. While the existing SCTP mechanisms for detection of packet replays are considered sufficient for normal operation, stronger protections are needed to protect SCTP when the operating environment contains significant risk of deliberate attacks from a sophisticated adversary.",
      "ja": "下層輸送サービスによって提供されたデータグラムで検出されないエラーのリスクが大きすぎると考えられている場合は、追加の完全性保護が必要です。この追加の保護は、アプリケーション層で提供された場合は、SCTPヘッダが完全性攻撃を審議するために脆弱なままとなります。パケットリプレイの検出のための既存のSCTPメカニズムが正常動作のために十分であると考えられているが、より強力な保護が動作環境は、洗練された敵からの意図的な攻撃の重大なリスクが含まれている場合、SCTPを保護するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "The SCTP Authentication extension SCTP-AUTH [RFC4895] MAY be used when the threat environment requires stronger integrity protections, but does not require confidentiality.",
      "ja": "脅威の環境は強い整合性保護を必要としますが、機密性を必要としないとき、SCTP認証拡張SCTP-AUTH [RFC4895]は使用されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "11.2.3. Protecting Confidentiality",
      "section_title": true,
      "ja": "11.2.3。機密性を保護します"
    },
    {
      "indent": 3,
      "text": "In most cases, the risk of breach of confidentiality applies to the signaling data payload, not to the SCTP or lower-layer protocol overheads. If that is true, encryption of the SCTP user data only might be considered. As with the supplementary checksum service, user data encryption MAY be performed by the SCTP user application. Alternately, the user application MAY use an implementation-specific API to request that the IP Encapsulating Security Payload (ESP) [RFC4303] be used to provide confidentiality and integrity.",
      "ja": "ほとんどの場合、機密性の侵害の危険性がないSCTPまたは下位層プロトコルオーバーヘッドに、シグナリングデータ・ペイロードに適用されます。それが本当であれば、SCTPユーザデータの暗号化のみが考慮されるかもしれません。補足チェックサムサービスと同様に、ユーザデータの暗号化には、SCTPユーザアプリケーションによって実行することができます。代わりに、ユーザアプリケーションは、IPカプセル化セキュリティペイロード（ESP）[RFC4303]は、機密性と完全性を提供するために使用されることを要求するために、実装固有のAPIを使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Particularly for mobile users, the requirement for confidentiality might include the masking of IP addresses and ports. In this case, ESP SHOULD be used instead of application-level confidentiality. If ESP is used to protect confidentiality of SCTP traffic, an ESP cryptographic transform that includes cryptographic integrity protection MUST be used, because if there is a confidentiality threat there will also be a strong integrity threat.",
      "ja": "特に、モバイルユーザーのために、機密性の要件は、IPアドレスとポートのマスキングが含まれる場合があります。この場合、ESPは、代わりにアプリケーション・レベルの機密性の使用されるべきです。 ESPは、SCTPトラフィックの機密性を保護するために使用されている場合は、ESPは、機密性の脅威がある場合にも、強い整合性の脅威が存在しますので、暗号完全性保護は、使用しなければならない含ん変換暗号化。"
    },
    {
      "indent": 3,
      "text": "Whenever ESP is in use, application-level encryption is not generally required.",
      "ja": "ESPが使用されているときはいつでも、アプリケーションレベルの暗号化は、一般的に必要とされていません。"
    },
    {
      "indent": 3,
      "text": "Regardless of where confidentiality is provided, the Internet Key Exchange Protocol version 2 (IKEv2) [RFC4306] SHOULD be used for key management.",
      "ja": "かかわらず、機密性が提供される場合の、インターネット鍵交換プロトコルバージョン2（IKEv2の）[RFC4306]は鍵管理のために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Operators should consult [RFC4301] for more information on the security services available at and immediately above the Internet Protocol layer.",
      "ja": "オペレータは、利用可能とすぐに、インターネットプロトコル層の上のセキュリティ・サービスの詳細については、[RFC4301]を相談してください。"
    },
    {
      "indent": 0,
      "text": "11.2.4. Protecting against Blind Denial-of-Service Attacks",
      "section_title": true,
      "ja": "11.2.4。ブラインドサービス拒否攻撃からの保護"
    },
    {
      "indent": 3,
      "text": "A blind attack is one where the attacker is unable to intercept or otherwise see the content of data flows passing to and from the target SCTP node. Blind denial-of-service attacks may take the form of flooding, masquerade, or improper monopolization of services.",
      "ja": "ブラインド攻撃は、攻撃者が傍受又は他の方法および目標SCTPノードから通過するデータフローの内容を見ることができないものです。ブラインドサービス拒否攻撃は、洪水、仮面舞踏会、またはサービスの不適切な独占の形をとることができます。"
    },
    {
      "indent": 0,
      "text": "11.2.4.1. Flooding",
      "section_title": true,
      "ja": "11.2.4.1。冠水"
    },
    {
      "indent": 3,
      "text": "The objective of flooding is to cause loss of service and incorrect behavior at target systems through resource exhaustion, interference with legitimate transactions, and exploitation of buffer-related software bugs. Flooding may be directed either at the SCTP node or at resources in the intervening IP Access Links or the Internet. Where the latter entities are the target, flooding will manifest itself as loss of network services, including potentially the breach of any firewalls in place.",
      "ja": "洪水の目的は、資源の枯渇、正当な取引との干渉、およびバッファ関連のソフトウェアのバグの搾取を介してターゲット・システムでサービスや不正な動作の損失を引き起こすことがあります。洪水は、SCTPノードで、または介在IPアクセスリンクまたはインターネット内のリソースのいずれかで向けることができます。後者の実体がターゲットである場合、洪水は、代わりに任意のファイアウォールの潜在的な違反を含め、ネットワークサービスの損失として現れます。"
    },
    {
      "indent": 3,
      "text": "In general, protection against flooding begins at the equipment design level, where it includes measures such as:",
      "ja": "：一般的には、浸水に対する保護は、それはのような措置が含まれる機器の設計レベルで始まり、"
    },
    {
      "indent": 3,
      "text": "- avoiding commitment of limited resources before determining that the request for service is legitimate.",
      "ja": " - サービスの要求が正当なものであることを決定する前に、限られた資源のコミットメントを回避することができます。"
    },
    {
      "indent": 3,
      "text": "- giving priority to completion of processing in progress over the acceptance of new work.",
      "ja": " - 新しい作業の受け入れを介して進行中の処理の完了を優先。"
    },
    {
      "indent": 3,
      "text": "- identification and removal of duplicate or stale queued requests for service.",
      "ja": " - 識別とサービスのための複製または古いキューに入れられた要求の除去。"
    },
    {
      "indent": 3,
      "text": "- not responding to unexpected packets sent to non-unicast addresses.",
      "ja": " - 非ユニキャストアドレスに送信された予想外のパケットに応答しません。"
    },
    {
      "indent": 3,
      "text": "Network equipment should be capable of generating an alarm and log if a suspicious increase in traffic occurs. The log should provide information such as the identity of the incoming link and source address(es) used, which will help the network or SCTP system operator to take protective measures. Procedures should be in place for the operator to act on such alarms if a clear pattern of abuse emerges.",
      "ja": "ネットワーク機器は、アラームを生成することができ、トラフィックで不審な増加が発生した場合、ログインする必要があります。ログは、このような保護措置を講ずるために、ネットワークまたはSCTPシステムオペレータを助ける使用着信リンクおよびソースアドレス（複数可）のアイデンティティ、等の情報を提供しなければなりません。手続きは、虐待の明確なパターンが現れた場合、そのようなアラームに作用するオペレータのための場所にする必要があります。"
    },
    {
      "indent": 3,
      "text": "The design of SCTP is resistant to flooding attacks, particularly in its use of a four-way startup handshake, its use of a cookie to defer commitment of resources at the responding SCTP node until the handshake is completed, and its use of a Verification Tag to prevent insertion of extraneous packets into the flow of an established association.",
      "ja": "SCTPのデザインは、特に4ウェイスタートアップハンドシェイクの使用におけるフラッディング攻撃、ハンドシェイクが完了するまで応答SCTPノードでリソースのコミットメントを延期するクッキーの使用に耐性があり、かつ検証タグの使用確立されたアソシエーションの流れに無関係なパケットの挿入を防止します。"
    },
    {
      "indent": 3,
      "text": "The IP Authentication Header and Encapsulating Security Payload might be useful in reducing the risk of certain kinds of denial-of-service attacks.",
      "ja": "IP認証ヘッダや暗号ペイロードは、サービス拒否攻撃の特定の種類のリスクを低減するのに有用であるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The use of the host name feature in the INIT chunk could be used to flood a target DNS server. A large backlog of DNS queries, resolving the host name received in the INIT chunk to IP addresses, could be accomplished by sending INITs to multiple hosts in a given domain. In addition, an attacker could use the host name feature in an indirect attack on a third party by sending large numbers of INITs to random hosts containing the host name of the target. In addition to the strain on DNS resources, this could also result in large numbers of INIT ACKs being sent to the target. One method to protect against this type of attack is to verify that the IP addresses received from DNS include the source IP address of the original INIT. If the list of IP addresses received from DNS does not include the source IP address of the INIT, the endpoint MAY silently discard the INIT. This last option will not protect against the attack against the DNS.",
      "ja": "INITチャンクのホスト名機能を使用すると、ターゲットDNSサーバーをあふれさせるために使用することができます。 DNSクエリの大きなバックログは、IPアドレスにINITチャンクに受信したホスト名を解決し、特定のドメイン内の複数のホストへのINIT送信することによって達成することができます。また、攻撃者は、ターゲットのホスト名を含むランダムホストへのINITを大量に送信することにより、第三者への間接的な攻撃のホスト名機能を使用することができます。 DNSリソース上の歪みに加えて、これはまた、ターゲットに送信されたINIT ACKの多数につながる可能性があります。このタイプの攻撃から保護するための一つの方法は、DNSから受信したIPアドレスは、元のINITの送信元IPアドレスを含めることを確認することです。 DNSから受信したIPアドレスのリストは、INITの送信元IPアドレスが含まれていない場合、エンドポイントは、静かにINITを捨てるかもしれ。この最後のオプションは、DNSへの攻撃を防ぐことはできません。"
    },
    {
      "indent": 0,
      "text": "11.2.4.2. Blind Masquerade",
      "section_title": true,
      "ja": "11.2.4.2。ブラインドマスカレード"
    },
    {
      "indent": 3,
      "text": "Masquerade can be used to deny service in several ways:",
      "ja": "マスカレードは、いくつかの方法でサービスを拒否するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "- by tying up resources at the target SCTP node to which the impersonated node has limited access. For example, the target node may by policy permit a maximum of one SCTP association with the impersonated SCTP node. The masquerading attacker may attempt to establish an association purporting to come from the impersonated node so that the latter cannot do so when it requires it.",
      "ja": " - ターゲットSCTPノードでリソースを占有することによってどの偽装ノードは、アクセスが制限されています。例えば、ターゲット・ノードは、ポリシーによって偽装SCTPノードを有するものSCTPアソシエーションの最大を可能にすることができます。マスカレード攻撃者は、それを必要とするとき、後者はそうではないことができるように偽装したノードから来るようにという趣旨の関連付けを確立することを試みることができます。"
    },
    {
      "indent": 3,
      "text": "- by deliberately allowing the impersonation to be detected, thereby provoking counter-measures that cause the impersonated node to be locked out of the target SCTP node.",
      "ja": " - 故意それによって偽装ノ​​ードがターゲットSCTPノードからロックアウトさせる対策を誘発する、なりすましを検出することを可能にすることによって。"
    },
    {
      "indent": 3,
      "text": "- by interfering with an established association by inserting extraneous content such as a SHUTDOWN request.",
      "ja": " - そのようなシャットダウン要求として無関係なコンテンツを挿入することによって確立されたアソシエーションを妨害することによって。"
    },
    {
      "indent": 3,
      "text": "SCTP reduces the risk of blind masquerade attacks through IP spoofing by use of the four-way startup handshake. Because the initial exchange is memory-less, no lockout mechanism is triggered by blind masquerade attacks. In addition, the INIT ACK containing the State Cookie is transmitted back to the IP address from which it received the INIT. Thus, the attacker would not receive the INIT ACK containing the State Cookie. SCTP protects against insertion of extraneous packets into the flow of an established association by use of the Verification Tag.",
      "ja": "SCTPは、4ウェイスタートアップハンドシェイクを使用してIPスプーフィングによってブラインドマスカレード攻撃のリスクを低減します。最初の交換は、メモリレスなので、何もロックアウト機構は、盲目の仮面舞踏会攻撃によってトリガされません。また、州Cookieを含むINIT ACKがそれがINITを受け、そこからIPアドレスに返送されます。このため、攻撃者は州のCookieを含むINIT ACKを受信しないでしょう。 SCTPは、検証タグを使用することによって確立された協会の流れの中に異質なパケットの挿入から保護します。"
    },
    {
      "indent": 3,
      "text": "Logging of received INIT requests and abnormalities such as unexpected INIT ACKs might be considered as a way to detect patterns of hostile activity. However, the potential usefulness of such logging must be weighed against the increased SCTP startup processing it implies, rendering the SCTP node more vulnerable to flooding attacks. Logging is pointless without the establishment of operating procedures to review and analyze the logs on a routine basis.",
      "ja": "そのような予想外のINIT ACKの受信などINIT要求や異常のロギングは敵対的な活動のパターンを検出する方法として考えられるかもしれません。しかし、そのような伐採の潜在的有用性は、フラッド攻撃を受けやすくSCTPノードをレンダリング、それは意味の増加SCTPの起動処理と比較検討しなければなりません。ログは定期的にログを確認し、分析するための操作手順の確立なしに無意味です。"
    },
    {
      "indent": 0,
      "text": "11.2.4.3. Improper Monopolization of Services",
      "section_title": true,
      "ja": "11.2.4.3。役務の不正な独占"
    },
    {
      "indent": 3,
      "text": "Attacks under this heading are performed openly and legitimately by the attacker. They are directed against fellow users of the target SCTP node or of the shared resources between the attacker and the target node. Possible attacks include the opening of a large number of associations between the attacker's node and the target, or transfer of large volumes of information within a legitimately established association.",
      "ja": "この見出しの下の攻撃は、攻撃者によって公然と合法的に行われています。彼らは、ターゲットSCTPノードのか、攻撃者とターゲット・ノード間の共有リソースの仲間のユーザに対して向けられています。可能な攻撃は正当確立されたアソシエーション内の攻撃者のノードとターゲット、または大量の情報の転送との間の関連の多数の開口部を含みます。"
    },
    {
      "indent": 3,
      "text": "Policy limits should be placed on the number of associations per adjoining SCTP node. SCTP user applications should be capable of detecting large volumes of illegitimate or \"no-op\" messages within a given association and either logging or terminating the association as a result, based on local policy.",
      "ja": "ポリシーの制限は、隣接するSCTPノードあたりの団体の数に配置する必要があります。 SCTPユーザアプリケーションは、ローカルポリシーに基づいて、所定のアソシエーションおよびロギングのいずれかの中に不正または「ノーオペレーション」メッセージを大量に検出又は結果としての関連付けを終了することができなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.3. SCTP Interactions with Firewalls",
      "section_title": true,
      "ja": "11.3。ファイアウォールとSCTPの相互作用"
    },
    {
      "indent": 3,
      "text": "It is helpful for some firewalls if they can inspect just the first fragment of a fragmented SCTP packet and unambiguously determine whether it corresponds to an INIT chunk (for further information, please refer to [RFC1858]). Accordingly, we stress the requirements, stated in Section 3.1, that (1) an INIT chunk MUST NOT be bundled",
      "ja": "それらは断片化されたSCTPパケットのちょうど最初のフラグメントを検査し、明確にそれがINITチャンクに対応するか否かを判断することができる場合、それはいくつかのファイアウォールのために有用である（詳細については、[RFC1858]を参照）。したがって、我々は、（1）INITチャンクが同梱されてはならないことを、3.1節で述べたように、要件を強調します"
    },
    {
      "indent": 3,
      "text": "with any other chunk in a packet, and (2) a packet containing an INIT chunk MUST have a zero Verification Tag. Furthermore, we require that the receiver of an INIT chunk MUST enforce these rules by silently discarding an arriving packet with an INIT chunk that is bundled with other chunks or has a non-zero verification tag and contains an INIT-chunk.",
      "ja": "パケット内の任意の他のチャンクと、及び（2）INITチャンクを含むパケットは、ゼロ検証タグを持たなければなりません。さらに、我々は、INITチャンクの受信機が静かに他のチャンクにバンドルまたは非ゼロの検証タグを有し、INITチャンクを含んでいるINITチャンクで到着するパケットを廃棄することによって、これらのルールを適用しなければならないことを要求します。"
    },
    {
      "indent": 0,
      "text": "11.4. Protection of Non-SCTP-Capable Hosts",
      "section_title": true,
      "ja": "11.4。非SCTP-対応ホストの保護"
    },
    {
      "indent": 3,
      "text": "To provide a non-SCTP-capable host with the same level of protection against attacks as for SCTP-capable ones, all SCTP stacks MUST implement the ICMP handling described in Appendix C.",
      "ja": "SCTP対応のもののためなどの攻撃に対する保護のと同じレベルで非SCTP対応のホストを提供するために、すべてのSCTPスタックは、付録Cで説明ICMP処理を実装しなければなりません"
    },
    {
      "indent": 3,
      "text": "When an SCTP stack receives a packet containing multiple control or DATA chunks and the processing of the packet requires the sending of multiple chunks in response, the sender of the response chunk(s) MUST NOT send more than one packet. If bundling is supported, multiple response chunks that fit into a single packet MAY be bundled together into one single response packet. If bundling is not supported, then the sender MUST NOT send more than one response chunk and MUST discard all other responses. Note that this rule does NOT apply to a SACK chunk, since a SACK chunk is, in itself, a response to DATA and a SACK does not require a response of more DATA.",
      "ja": "SCTPスタックは、複数の制御またはDATAチャンクとパケットの処理を含むパケットを受信し、応答して複数のチャンクの送信を必要とするとき、応答チャンク（S）の送信者は、複数のパケットを送ってはいけません。バンドルがサポートされている場合、単一のパケットに収まる複数の応答チャンクは、1つの応答パケットに束ねられるかもしれません。バンドルがサポートされていない場合は、送信者は、複数の応答チャンクを送ってはいけませんし、他のすべての応答を捨てなければなりません。この規則は、SACKチャンクには適用されませんSACKチャンクであるため、それ自体が、データに応答し、SACKは、より多くのデータの応答を必要としないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "An SCTP implementation SHOULD abort the association if it receives a SACK acknowledging a TSN that has not been sent.",
      "ja": "それが送信されていないTSNを認めるSACKを受信した場合、SCTPの実装は、関連付けを中止すべきです。"
    },
    {
      "indent": 3,
      "text": "An SCTP implementation that receives an INIT that would require a large packet in response, due to the inclusion of multiple ERROR parameters, MAY (at its discretion) elect to omit some or all of the ERROR parameters to reduce the size of the INIT ACK. Due to a combination of the size of the COOKIE parameter and the number of addresses a receiver of an INIT may be indicating to a peer, it is always possible that the INIT ACK will be larger than the original INIT. An SCTP implementation SHOULD attempt to make the INIT ACK as small as possible to reduce the possibility of byte amplification attacks.",
      "ja": "複数のエラーパラメータの包含に、応答して大きなパケットを必要とするINITを受信SCTP実装は、MAY（その裁量で）INIT ACKのサイズを小さくするエラーパラメータの一部または全部を省略することを選択します。起因COOKIEパラメータの大きさとINITの受信ピアに知らせることができるアドレスの数の組み合わせには、INIT ACKが元INITより大きくなることは常に可能です。 SCTPの実装は、バイト増幅攻撃の可能性を減らすために可能な限り小さくINIT ACKを試みるべきです。"
    },
    {
      "indent": 0,
      "text": "12. Network Management Considerations",
      "section_title": true,
      "ja": "12.ネットワーク管理の考慮事項"
    },
    {
      "indent": 3,
      "text": "The MIB module for SCTP defined in [RFC3873] applies for the version of the protocol specified in this document.",
      "ja": "[RFC3873]で定義されたSCTPのためのMIBモジュールは、本書で指定されたプロトコルのバージョンに適用されます。"
    },
    {
      "indent": 0,
      "text": "13. Recommended Transmission Control Block (TCB) Parameters",
      "section_title": true,
      "ja": "13.推奨伝送制御ブロック（TCB）のパラメータ"
    },
    {
      "indent": 3,
      "text": "This section details a recommended set of parameters that should be contained within the TCB for an implementation. This section is for illustrative purposes and should not be deemed as requirements on an implementation or as an exhaustive list of all parameters inside an SCTP TCB. Each implementation may need its own additional parameters for optimization.",
      "ja": "このセクションでは、実装のためにTCB内に含まれるべきパラメータの推奨セットを詳述します。このセクションでは、例示の目的のためであり、実装上又はSCTPのTCB内のすべてのパラメータの網羅的なリストとして要求としてみなされるべきではありません。各実装には、最適化のための独自の追加パラメータが必要な場合があります。"
    },
    {
      "indent": 0,
      "text": "13.1. Parameters Necessary for the SCTP Instance",
      "section_title": true,
      "ja": "13.1。 SCTPインスタンスに必要なパラメータ"
    },
    {
      "indent": 3,
      "text": "Associations: A list of current associations and mappings to the data consumers for each association. This may be in the form of a hash table or other implementation-dependent structure. The data consumers may be process identification information such as file descriptors, named pipe pointer, or table pointers dependent on how SCTP is implemented.",
      "ja": "協会：各協会のデータ消費者への現在の協会とマッピングのリスト。これは、ハッシュテーブルまたは他の実装依存構造の形態であってもよいです。データコンシューマは、ファイルディスクリプタ、名前付きパイプポインタ、またはSCTPの実装方法に依存テーブルポインタとして処理識別情報であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Secret Key: A secret key used by this endpoint to compute the MAC. This SHOULD be a cryptographic quality random number with a sufficient length. Discussion in RFC 4086 can be helpful in selection of the key.",
      "ja": "秘密鍵：MACを計算するために、このエンドポイントで使用する秘密鍵。これは、十分な長さの暗号の品質乱数であるべきです。 RFC 4086での議論は、キーの選択に役立ちます。"
    },
    {
      "indent": 3,
      "text": "Address List: The list of IP addresses that this instance has bound. This information is passed to one's peer(s) in INIT and INIT ACK chunks.",
      "ja": "アドレス一覧：IPのリストは、このインスタンスがバインドされたことを対処しています。この情報は、INITとINIT ACKチャンクの1のピア（複数可）に渡されます。"
    },
    {
      "indent": 3,
      "text": "SCTP Port: The local SCTP port number to which the endpoint is bound.",
      "ja": "SCTPポート：エンドポイントがバインドされているローカルSCTPポート番号。"
    },
    {
      "indent": 0,
      "text": "13.2. Parameters Necessary per Association (i.e., the TCB)",
      "section_title": true,
      "ja": "13.2。協会（すなわち、TCB）当たりの必要なパラメータ"
    },
    {
      "indent": 3,
      "text": "Peer : Tag value to be sent in every packet and is received Verification: in the INIT or INIT ACK chunk. Tag :",
      "ja": "ピア：タグの値は、すべてのパケットで送信されると検証を受けている：INITまたはINIT ACKチャンクに。鬼ごっこ ："
    },
    {
      "indent": 3,
      "text": "My : Tag expected in every inbound packet and sent in the Verification: INIT or INIT ACK chunk. Tag :",
      "ja": "私：タグは、すべての着信パケットに期待し、検証に送ら：INITまたはINIT ACKチャンク。鬼ごっこ ："
    },
    {
      "indent": 3,
      "text": "State : A state variable indicating what state the association : is in, i.e., COOKIE-WAIT, COOKIE-ECHOED, ESTABLISHED, : SHUTDOWN-PENDING, SHUTDOWN-SENT, SHUTDOWN-RECEIVED, : SHUTDOWN-ACK-SENT.",
      "ja": "状態：どのような状態の関連性を示す状態変数：すなわち、COOKIE-WAIT、COOKIE-エコーは、確立され、である：SHUTDOWN-PENDING、SHUTDOWN-SENT、SHUTDOWN-受信：SHUTDOWN-ACK-SENT。"
    },
    {
      "indent": 17,
      "text": "Note: No \"CLOSED\" state is illustrated since if a\nassociation is \"CLOSED\" its TCB SHOULD be removed.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Peer : A list of SCTP transport addresses to which the peer Transport : is bound. This information is derived from the INIT or Address : INIT ACK and is used to associate an inbound packet List : with a given association. Normally, this information : is hashed or keyed for quick lookup and access of the : TCB.",
      "ja": "ピア：バインドされている：ピアトランスポートは、先のSCTP輸送アドレスのリスト。この情報は、INITまたはアドレスから派生している：INIT ACKとインバウンドパケットの一覧を関連付けるために使用されます。与えられた協会で。通常、この情報は：ハッシュ化またはクイックルックとのアクセスのためのキーが付いて：TCB。"
    },
    {
      "indent": 3,
      "text": "Primary : This is the current primary destination transport Path : address of the peer endpoint. It may also specify a : source transport address on this endpoint.",
      "ja": "プライマリ：ピアエンドポイントのアドレス：これは、現在の主要な目的地の搬送路です。このエンドポイント上のソーストランスポートアドレス：それも指定することができます。"
    },
    {
      "indent": 3,
      "text": "Overall : The overall association error count. Error Count :",
      "ja": "全体：全体的な関連付けエラーカウント。エラー数："
    },
    {
      "indent": 3,
      "text": "Overall : The threshold for this association that if the Overall Error : Error Count reaches will cause this association to be Threshold : torn down.",
      "ja": "全体：取り壊さ：エラーカウントに達する。この会合はしきい値ことになります：総合エラーがあればことを、この関連付けのしきい値。"
    },
    {
      "indent": 3,
      "text": "Peer Rwnd : Current calculated value of the peer's rwnd.",
      "ja": "ピアのRWNDの現在の計算値：RWNDピア。"
    },
    {
      "indent": 3,
      "text": "Next TSN : The next TSN number to be assigned to a new DATA chunk. : This is sent in the INIT or INIT ACK chunk to the peer : and incremented each time a DATA chunk is assigned a : TSN (normally just prior to transmit or during : fragmentation).",
      "ja": "次のTSN：新しいDATAチャンクに割り当てられる次のTSN番号。 ：これは、ピアにINITまたはINIT ACKチャンクで送信され：およびDATAチャンクが割り当てられるたびにインクリメント：TSNを（通常は単に送信する前または中：フラグメンテーション）。"
    },
    {
      "indent": 3,
      "text": "Last Rcvd : This is the last TSN received in sequence. This value TSN : is set initially by taking the peer's initial TSN, : received in the INIT or INIT ACK chunk, and : subtracting one from it.",
      "ja": "最終受信数：これは最後のTSNが順番に受けています。この値TSNは：、ピアの初期TSNを取ることによって最初に設定されている：INITあるいはINIT ACKチャンクに受信され、：それから1を減算します。"
    },
    {
      "indent": 3,
      "text": "Mapping : An array of bits or bytes indicating which out-of-Array : order TSNs have been received (relative to the : Last Rcvd TSN). If no gaps exist, i.e., no out-of-: order packets have been received, this array will : be set to all zero. This structure may be in the : form of a circular buffer or bit array.",
      "ja": "マッピング：（に対して：最終受信数TSN）オーダーのTSNが受信された：アウト・オブ・アレイ示すビット又はバイトのアレイ。全くギャップが存在しない場合、すなわち、ノーアウトオブ：注文パケットが受信された、この配列はます：すべてゼロに設定すること。循環バッファまたはビット列の形：この構造は、であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Ack State : This flag indicates if the next received packet : is to be responded to with a SACK. This is initialized : to 0. When a packet is received it is incremented. : If this value reaches 2 or more, a SACK is sent and the : value is reset to 0. Note: This is used only when no : DATA chunks are received out of order. When DATA : chunks are out of order, SACKs are not delayed (see : Section 6).",
      "ja": "Ack状態：SACKで応答する：次の受信パケットがあれば、このフラグは示しています。これは初期化されます：0に、パケットは、それがインクリメントされる受信した場合。 ：データチャンク順不同で受信されない：これは、何をする場合にのみ使用されている：この値は2以上に達した場合、SACKが送信され：値は0に注意することがリセットされます。 DATAとき：チャンクは順不同であり、袋は（：第6節を参照してください）遅れていません。"
    },
    {
      "indent": 3,
      "text": "Inbound : An array of structures to track the inbound streams, Streams : normally including the next sequence number expected : and possibly the stream number.",
      "ja": "インバウンド：そしておそらくストリーム番号：通常予想される次のシーケンス番号を含む：インバウンドストリーム、ストリームを追跡する構造体の配列。"
    },
    {
      "indent": 3,
      "text": "Outbound : An array of structures to track the outbound streams, Streams : normally including the next sequence number to : be sent on the stream.",
      "ja": "アウトバウンド：アウトバウンドストリームを追跡する構造体の配列、ストリーム：ストリーム上で送信される：通常に次のシーケンス番号を含みます。"
    },
    {
      "indent": 3,
      "text": "Reasm Queue : A reassembly queue.",
      "ja": "Reasmキュー：再組み立てキュー。"
    },
    {
      "indent": 3,
      "text": "Local : The list of local IP addresses bound in to this Transport : association. Address : List :",
      "ja": "ローカル：このトランスポートにバインドして、ローカルIPアドレスのリスト：関連。住所：一覧："
    },
    {
      "indent": 3,
      "text": "Association : The smallest PMTU discovered for all of the PMTU : peer's transport addresses.",
      "ja": "協会：PMTUのすべてのために発見された最小のPMTU：同輩のトランスポートアドレス。"
    },
    {
      "indent": 0,
      "text": "13.3. Per Transport Address Data",
      "section_title": true,
      "ja": "13.3。トランスポートアドレスデータ毎"
    },
    {
      "indent": 3,
      "text": "For each destination transport address in the peer's address list derived from the INIT or INIT ACK chunk, a number of data elements need to be maintained including:",
      "ja": "ピアのINITに由来するアドレスリストまたはINIT ACKチャンク内の各宛先トランスポートアドレスに対して、データ要素の数を含めて維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "Error Count : The current error count for this destination.",
      "ja": "エラー数：この先の現在のエラーカウント。"
    },
    {
      "indent": 3,
      "text": "Error : Current error threshold for this destination, i.e., Threshold : what value marks the destination down if error count : reaches this value.",
      "ja": "この値に達する：エラー：この宛先の現在のエラーしきい値、すなわち、しきい値：エラーカウントがあればどのような値がダウンして目的地をマーク。"
    },
    {
      "indent": 3,
      "text": "cwnd : The current congestion window.",
      "ja": "cwnd：現在の輻輳ウィンドウ。"
    },
    {
      "indent": 3,
      "text": "ssthresh : The current ssthresh value.",
      "ja": "SSTHRESH：現在SSTHRESH値。"
    },
    {
      "indent": 3,
      "text": "RTO : The current retransmission timeout value.",
      "ja": "RTO：現在の再送タイムアウト値。"
    },
    {
      "indent": 3,
      "text": "SRTT : The current smoothed round-trip time.",
      "ja": "SRTT：現在の平滑化往復時間。"
    },
    {
      "indent": 3,
      "text": "RTTVAR : The current RTT variation.",
      "ja": "RTTVAR：現在のRTTの変化。"
    },
    {
      "indent": 3,
      "text": "partial : The tracking method for increase of cwnd when in bytes acked : congestion avoidance mode (see Section 7.2.2).",
      "ja": "部分：バイト単位でACKさCWNDの増加追跡方法：輻輳回避モード（7.2.2項参照）。"
    },
    {
      "indent": 3,
      "text": "state : The current state of this destination, i.e., DOWN, UP, : ALLOW-HB, NO-HEARTBEAT, etc.",
      "ja": "状態：この先の現在の状態、即ち、DOWN、UP、：ALLOW-HB、NO-HEARTBEAT、等"
    },
    {
      "indent": 3,
      "text": "PMTU : The current known path MTU.",
      "ja": "PMTU：現在知られているパスMTU。"
    },
    {
      "indent": 3,
      "text": "Per : A timer used by each destination. Destination : Timer :",
      "ja": "パー：各宛先が使用するタイマー。目的地：タイマー："
    },
    {
      "indent": 3,
      "text": "RTO-Pending : A flag used to track if one of the DATA chunks sent to : this address is currently being used to compute an : RTT. If this flag is 0, the next DATA chunk sent to : this destination should be used to compute an RTT and : this flag should be set. Every time the RTT : calculation completes (i.e., the DATA chunk is SACK'd), : clear this flag.",
      "ja": "RTO係属：RTT：このアドレスは、現在計算するために使用されている。データチャンクのいずれかに送られた場合に追跡するために使用されるフラグ。このフラグが0である場合、に送られ、次のデータチャンク：この宛先は、RTTを計算するために使用すべきであり、このフラグが設定されなければなりません。 RTT毎時間：計算が完了した（すなわち、データチャンクはSACK'dである）、このフラグをクリアします。"
    },
    {
      "indent": 3,
      "text": "last-time : The time to which this destination was last sent. : This can be to determine if a HEARTBEAT is needed.",
      "ja": "前回：この先は最後に送信された時間。 ：これはHEARTBEATが必要かどうかを決定することができます。"
    },
    {
      "indent": 0,
      "text": "13.4. General Parameters Needed",
      "section_title": true,
      "ja": "13.4。一般的なパラメータが必要"
    },
    {
      "indent": 3,
      "text": "Out Queue : A queue of outbound DATA chunks.",
      "ja": "アウトキュー：アウトバウンドDATAチャンクのキュー。"
    },
    {
      "indent": 3,
      "text": "In Queue : A queue of inbound DATA chunks.",
      "ja": "キュー内：インバウンドDATAチャンクのキュー。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "SCTP defines three registries that IANA maintains:",
      "ja": "SCTPは、IANAが管理する3つのレジストリを定義しています。"
    },
    {
      "indent": 3,
      "text": "- through definition of additional chunk types, - through definition of additional parameter types, or - through definition of additional cause codes within ERROR chunks.",
      "ja": " - 追加のチャンクタイプの定義による - 追加のパラメータの型の定義によって、あるいは -  ERRORチャンク内の追加原因コードの定義による。"
    },
    {
      "indent": 3,
      "text": "SCTP requires that the IANA Port Numbers registry be opened for SCTP port registrations, Section 14.5 describes how. An IESG-appointed Expert Reviewer supports IANA in evaluating SCTP port allocation requests.",
      "ja": "SCTPは、14.5節はどのように説明し、IANAポート番号のレジストリがSCTPポートの登録のために開かれている必要があります。 IESG-任命エキスパートレビューはSCTPポート割り当て要求を評価する際にIANAをサポートしています。"
    },
    {
      "indent": 0,
      "text": "14.1. IETF-Defined Chunk Extension",
      "section_title": true,
      "ja": "14.1。 IETF定義のチャンク拡張"
    },
    {
      "indent": 3,
      "text": "The assignment of new chunk parameter type codes is done through an IETF Consensus action, as defined in [RFC2434]. Documentation of the chunk parameter MUST contain the following information:",
      "ja": "新しいチャンクパラメータタイプコードの割り当ては、[RFC2434]で定義されるように、IETF Consensus動作を介して行われます。チャンクパラメータのドキュメントには、以下の情報を含まなければなりません："
    },
    {
      "indent": 3,
      "text": "a) A long and short name for the new chunk type.",
      "ja": "A）新しいチャンクタイプのために長いと短い名前。"
    },
    {
      "indent": 3,
      "text": "b) A detailed description of the structure of the chunk, which MUST conform to the basic structure defined in Section 3.2.",
      "ja": "B）セクション3.2で定義された基本構造に従わなければなりませんチャンクの構造の詳細な説明。"
    },
    {
      "indent": 3,
      "text": "c) A detailed definition and description of intended use of each field within the chunk, including the chunk flags if any.",
      "ja": "C）もしあればチャンクフラグを含むチャンク内の各フィールドの用途の詳細な定義と説明を。"
    },
    {
      "indent": 3,
      "text": "d) A detailed procedural description of the use of the new chunk type within the operation of the protocol.",
      "ja": "D）プロトコルの動作中に新しいチャンクタイプの使用の詳細な手続き説明。"
    },
    {
      "indent": 3,
      "text": "The last chunk type (255) is reserved for future extension if necessary.",
      "ja": "必要に応じて、最後のチャンクタイプ（255）は、将来の拡張のために予約されています。"
    },
    {
      "indent": 0,
      "text": "14.2. IETF-Defined Chunk Parameter Extension",
      "section_title": true,
      "ja": "14.2。 IETF定義のチャンクパラメータの拡張"
    },
    {
      "indent": 3,
      "text": "The assignment of new chunk parameter type codes is done through an IETF Consensus action as defined in [RFC2434]. Documentation of the chunk parameter MUST contain the following information:",
      "ja": "[RFC2434]で定義されるように、新しいチャンクのパラメータ型コードの割り当ては、IETF Consensus動作を介して行われます。チャンクパラメータのドキュメントには、以下の情報を含まなければなりません："
    },
    {
      "indent": 3,
      "text": "a) Name of the parameter type.",
      "ja": "パラメータの型のa）の名前。"
    },
    {
      "indent": 3,
      "text": "b) Detailed description of the structure of the parameter field. This structure MUST conform to the general Type-Length-Value format described in Section 3.2.1.",
      "ja": "パラメータフィールドの構造のb）の詳細な説明。この構造は、セクション3.2.1に記載した一般的なType-Length-Valueのフォーマットに従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "c) Detailed definition of each component of the parameter value.",
      "ja": "C）パラメータ値の各構成要素の詳細な定義。"
    },
    {
      "indent": 3,
      "text": "d) Detailed description of the intended use of this parameter type, and an indication of whether and under what circumstances multiple instances of this parameter type may be found within the same chunk.",
      "ja": "D）の詳細は、このパラメータ・タイプの使用目的の記述、及びこのパラメータの型の複数のインスタンスが同じチャンク内に見出すことができるかどうか、およびどのような状況下での指示。"
    },
    {
      "indent": 3,
      "text": "e) Each parameter type MUST be unique across all chunks.",
      "ja": "e）の各パラメータの型はすべてのチャンクで一意である必要があります。"
    },
    {
      "indent": 0,
      "text": "14.3. IETF-Defined Additional Error Causes",
      "section_title": true,
      "ja": "14.3。 IETF定義の追加のエラーの原因"
    },
    {
      "indent": 3,
      "text": "Additional cause codes may be allocated in the range 11 to 65535 through a Specification Required action as defined in [RFC2434]. Provided documentation must include the following information:",
      "ja": "[RFC2434]で定義されるように、追加の原因コードは、仕様必要なアクションを介して65535の範囲11に配置されてもよいです。提供された文書は、次の情報を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "a) Name of the error condition.",
      "ja": "エラー条件のa）の名前。"
    },
    {
      "indent": 3,
      "text": "b) Detailed description of the conditions under which an SCTP endpoint should issue an ERROR (or ABORT) with this cause code.",
      "ja": "この原因コードとのSCTP終点がERRORを発行する（またはABORTする条件）のb）の詳細な説明。"
    },
    {
      "indent": 3,
      "text": "c) Expected action by the SCTP endpoint that receives an ERROR (or ABORT) chunk containing this cause code.",
      "ja": "この原因コードを含むERROR（またはABORT）塊を受けるSCTP終点によるc）期待のアクション。"
    },
    {
      "indent": 3,
      "text": "d) Detailed description of the structure and content of data fields that accompany this cause code.",
      "ja": "この原因コードに付随するデータフィールドの構造と内容のd）の詳細な説明。"
    },
    {
      "indent": 3,
      "text": "The initial word (32 bits) of a cause code parameter MUST conform to the format shown in Section 3.3.10, i.e.:",
      "ja": "原因コードパラメータの最初のワード（32ビット）すなわち、セクション3.3.10に示すフォーマットに従わなければなりません："
    },
    {
      "indent": 3,
      "text": "- first 2 bytes contain the cause code value - last 2 bytes contain the length of the cause parameter.",
      "ja": " - 最初の2つのバイトは、原因コード値を含む - 最後の2つのバイトは、原因パラメータの長さを含みます。"
    },
    {
      "indent": 0,
      "text": "14.4. Payload Protocol Identifiers",
      "section_title": true,
      "ja": "14.4。ペイロードプロトコル識別子"
    },
    {
      "indent": 3,
      "text": "Except for value 0, which is reserved by SCTP to indicate an unspecified payload protocol identifier in a DATA chunk, SCTP will not be responsible for standardizing or verifying any payload protocol identifiers; SCTP simply receives the identifier from the upper layer and carries it with the corresponding payload data.",
      "ja": "データチャンクに不特定のペイロードプロトコル識別子を示すために、SCTPによって予約された値0を除いて、SCTPは、任意のペイロード・プロトコル識別子を標準化または検証する責任を負いません。 SCTPは、単に上位層から識別子を受信し、対応するペイロード・データとそれを運びます。"
    },
    {
      "indent": 3,
      "text": "The upper layer, i.e., the SCTP user, SHOULD standardize any specific protocol identifier with IANA if it is so desired. The use of any specific payload protocol identifier is out of the scope of SCTP.",
      "ja": "それが所望される場合、上層、すなわち、SCTPユーザは、IANAとの任意の特定のプロトコル識別子を標準化すべきです。任意の特定のペイロードプロトコル識別子の使用は、SCTPの範囲外です。"
    },
    {
      "indent": 0,
      "text": "14.5. Port Numbers Registry",
      "section_title": true,
      "ja": "14.5。ポート番号のレジストリ"
    },
    {
      "indent": 3,
      "text": "SCTP services may use contact port numbers to provide service to unknown callers, as in TCP and UDP. IANA is therefore requested to open the existing Port Numbers registry for SCTP using the following rules, which we intend to mesh well with existing Port Numbers registration procedures. An IESG-appointed Expert Reviewer supports IANA in evaluating SCTP port allocation requests, according to the procedure defined in [RFC2434].",
      "ja": "SCTPサービスは、TCPやUDPのように、未知の発信者にサービスを提供するために、連絡先のポート番号を使用することができます。 IANAは、したがって、我々は既存のポート番号の登録手順とよくメッシュしようとする次のルールを使用して、SCTPのための既存のポート番号のレジストリを開くように要求されています。 IESG-任命エキスパートレビュー[RFC2434]で定義された手順に従って、SCTPポート割り当て要求を評価する際にIANAをサポートしています。"
    },
    {
      "indent": 3,
      "text": "Port numbers are divided into three ranges. The Well Known Ports are those from 0 through 1023, the Registered Ports are those from 1024 through 49151, and the Dynamic and/or Private Ports are those from 49152 through 65535. Well Known and Registered Ports are intended for use by server applications that desire a default contact point on a system. On most systems, Well Known Ports can only be used by system (or root) processes or by programs executed by privileged users, while Registered Ports can be used by ordinary user processes or programs executed by ordinary users. Dynamic and/or Private Ports are intended for temporary use, including client-side ports, out-of-band negotiated ports, and application testing prior to registration of a dedicated port; they MUST NOT be registered.",
      "ja": "ポート番号は、3つの範囲に分割されています。ウェルノウンポートが1023の0からのものであり、登録されたポートは、1024から49151によるものであり、かつ動的および/またはプライベートポート、よく知られており、登録されたポートは、サーバーアプリケーションでの使用を目的としている〜65535 49152からのものであり、望むことシステムのデフォルトの接触点。登録ポートは、通常のユーザープロセスか、通常のユーザーによって実行されるプログラムで使用することができながら、ほとんどのシステムでは、ウェルノウンポートのみが、システム（またはルート）プロセスによって、または特権ユーザーによって実行されるプログラムで使用することができます。動的および/またはプライベートポートは一時的な使用のために意図されている、専用ポートの登録に先立って、クライアント側のポート、アウトバンド交渉し、ポート、およびアプリケーションのテストを含みます。彼らは、登録してはなりません。"
    },
    {
      "indent": 3,
      "text": "The Port Numbers registry should accept registrations for SCTP ports in the Well Known Ports and Registered Ports ranges. Well Known and Registered Ports SHOULD NOT be used without registration. Although in some cases -- such as porting an application from TCP to SCTP -- it may seem natural to use an SCTP port before registration completes, we emphasize that IANA will not guarantee registration of particular Well Known and Registered Ports. Registrations should be requested as early as possible.",
      "ja": "ポート番号のレジストリは、ウェルノウンポートと登録済みポートの範囲のSCTPポートの登録を受け入れる必要があります。よく知られており、登録されたポートは、登録なしで使用されるべきではありません。このようTCPからSCTPにアプリケーションを移植など -   - いくつかのケースではあるが、それは登録が完了する前に、SCTPポートを使用するように自然に見えるかもしれませんが、私たちは、IANAが特定のよく知られており、登録されたポートの登録を保証するものではありませんことを強調する。登録は可能な限り早期に要求されるべき。"
    },
    {
      "indent": 3,
      "text": "Each port registration SHALL include the following information:",
      "ja": "各ポートの登録は、以下の情報を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "o  A short port name, consisting entirely of letters (A-Z and a-z),\n   digits (0-9), and punctuation characters from \"-_+./*\" (not\n   including the quotes).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o The port number that is requested for registration.",
      "ja": "登録のために要求されているポート番号O。"
    },
    {
      "indent": 3,
      "text": "o A short English phrase describing the port's purpose.",
      "ja": "ポートの目的を説明する短い英語フレーズO。"
    },
    {
      "indent": 3,
      "text": "o Name and contact information for the person or entity performing the registration, and possibly a reference to a document defining the port's use. Registrations coming from IETF working groups need only name the working group, but indicating a contact person is recommended.",
      "ja": "Oの名前と、おそらく個人または団体登録を実行し、ポートの使用を定義するドキュメントへの参照のための連絡先情報。 IETFワーキンググループからの登録は、ワーキンググループに名前を付ける必要はなく、担当者を示すことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Registrants are encouraged to follow these guidelines when submitting a registration.",
      "ja": "登録者は、登録を提出する際のガイドラインに従うことを奨励されています。"
    },
    {
      "indent": 3,
      "text": "o A port name SHOULD NOT be registered for more than one SCTP port number.",
      "ja": "Oポート名は、複数のSCTPポート番号に登録されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "o A port name registered for TCP MAY be registered for SCTP as well. Any such registration SHOULD use the same port number as the existing TCP registration.",
      "ja": "O TCPのために登録されているポート名は、同様にSCTPのために登録することも可能です。任意のそのような登録は、既存のTCP登録と同じポート番号を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Concrete intent to use a port SHOULD precede port registration. For example, existing TCP ports SHOULD NOT be registered in advance of any intent to use those ports for SCTP.",
      "ja": "Oポートを使用するための具体的な目的は、ポートの登録を先行すべき。例えば、既存のTCPポートは、SCTPのためにこれらのポートを使用するように任意の意思を事前に登録されるべきではありません。"
    },
    {
      "indent": 6,
      "text": "This document registers the following ports. (These registrations should be considered models to follow for future allocation requests.)",
      "ja": "このドキュメントでは、次のポートを登録します。 （これらの登録には、モデルは、将来の割当て要求のために従うことを考慮すべきです。）"
    },
    {
      "indent": 9,
      "text": "discard 9/sctp Discard # IETF TSVWG # Randall Stewart <rrs@cisco.com> # [RFC4960]",
      "ja": "廃棄9 / SCTP破棄＃IETF TSVWG＃ランドールスチュワート<rrs@cisco.com>＃[RFC4960]"
    },
    {
      "indent": 12,
      "text": "The discard service, which accepts SCTP connections on port 9, discards all incoming application data and sends no data in response. Thus, SCTP's discard port is analogous to TCP's discard port, and might be used to check the health of an SCTP stack.",
      "ja": "ポート9にSCTP接続を受け入れる廃棄サービスは、すべての着信アプリケーションデータを破棄し、それに応答してもデータを送信しません。このように、SCTPの廃棄ポートは、TCPの廃棄ポートに類似しており、SCTPスタックの健康状態をチェックするために使用される可能性があります。"
    },
    {
      "indent": 9,
      "text": "ftp-data 20/sctp FTP # IETF TSVWG # Randall Stewart <rrs@cisco.com> # [RFC4960]",
      "ja": "FTPデータ20 / SCTP FTP＃IETF TSVWG＃ランドールスチュワート<rrs@cisco.com>＃[RFC4960]"
    },
    {
      "indent": 9,
      "text": "ftp 21/sctp FTP # IETF TSVWG # Randall Stewart <rrs@cisco.com> # [RFC4960]",
      "ja": "FTP 21 / SCTP FTP＃IETF TSVWG＃ランドールスチュワート<rrs@cisco.com>＃[RFC4960]"
    },
    {
      "indent": 12,
      "text": "File Transfer Protocol (FTP) data (20) and control ports (21).",
      "ja": "ファイル転送プロトコル（FTP）データ（20）と制御ポート（21）。"
    },
    {
      "indent": 9,
      "text": "ssh 22/sctp SSH # IETF TSVWG # Randall Stewart <rrs@cisco.com> # [RFC4960]",
      "ja": "SSH 22 / SCTP SSH位IETF TSVWG＃ランドールスチュワート<rrs@cisco.com>＃[RFC4960]"
    },
    {
      "indent": 12,
      "text": "The Secure Shell (SSH) remote login service, which allows secure shell logins to a host.",
      "ja": "ホストにセキュアシェルログインを可能にするセキュアシェル（SSH）、リモートログインサービス、。"
    },
    {
      "indent": 9,
      "text": "http 80/sctp HTTP # IETF TSVWG # Randall Stewart <rrs@cisco.com> # [RFC4960]",
      "ja": "HTTP 80 / SCTP HTTP＃IETF TSVWG＃ランドールスチュワート<rrs@cisco.com>＃[RFC4960]"
    },
    {
      "indent": 12,
      "text": "World Wide Web HTTP over SCTP.",
      "ja": "SCTPオーバーワールド・ワイド・ウェブHTTP。"
    },
    {
      "indent": 9,
      "text": "bgp 179/sctp BGP # IETF TSVWG # Randall Stewart <rrs@cisco.com> # [RFC4960]",
      "ja": "BGP 179 / SCTP BGP＃IETF TSVWG＃ランドールスチュワート<rrs@cisco.com>＃[RFC4960]"
    },
    {
      "indent": 12,
      "text": "Border Gateway Protocol over SCTP.",
      "ja": "SCTPオーバーボーダーゲートウェイプロトコル。"
    },
    {
      "indent": 9,
      "text": "https 443/sctp HTTPS # IETF TSVWG # Randall Stewart <rrs@cisco.com> # [RFC4960]",
      "ja": "HTTPS 443 / SCTP HTTPS＃IETF TSVWG＃ランドールスチュワート<rrs@cisco.com>＃[RFC4960]"
    },
    {
      "indent": 12,
      "text": "World Wide Web HTTP over TLS/SSL over SCTP.",
      "ja": "SCTP上のTLS / SSL上のWorld Wide Web HTTP。"
    },
    {
      "indent": 0,
      "text": "15. Suggested SCTP Protocol Parameter Values",
      "section_title": true,
      "ja": "15. SCTPプロトコルパラメータ値を推奨しました"
    },
    {
      "indent": 3,
      "text": "The following protocol parameters are RECOMMENDED:",
      "ja": "以下のプロトコルパラメータを推奨します。"
    },
    {
      "indent": 6,
      "text": "RTO.Initial - 3 seconds RTO.Min - 1 second RTO.Max - 60 seconds Max.Burst - 4 RTO.Alpha - 1/8 RTO.Beta - 1/4 Valid.Cookie.Life - 60 seconds Association.Max.Retrans - 10 attempts",
      "ja": "RTO.Initial  -  3秒RTO.Min  -  1秒RTO.Max  -  4 RTO.Alpha  -   -  Max.Burst 60秒1/8 RTO.Beta  -  1/4 Valid.Cookie.Life  -  60秒Association.Max.Retrans -  10回"
    },
    {
      "indent": 6,
      "text": "Path.Max.Retrans - 5 attempts (per destination address) Max.Init.Retransmits - 8 attempts HB.interval - 30 seconds HB.Max.Burst - 1",
      "ja": "Path.Max.Retrans  - （宛先アドレスごと）5つの試みMax.Init.Retransmits  -  8つの試みHB.interval  -  30秒HB.Max.Burst  -  1"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: The SCTP implementation may allow ULP to customize some of these protocol parameters (see Section 10).",
      "ja": "実装上の注意：SCTPの実装は（セクション10を参照）ULPは、これらのプロトコルパラメータの一部をカスタマイズすることを可能にします。"
    },
    {
      "indent": 3,
      "text": "Note: RTO.Min SHOULD be set as recommended above.",
      "ja": "注：上記の推奨通りRTO.Minを設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "16. Acknowledgements",
      "section_title": true,
      "ja": "16.謝辞"
    },
    {
      "indent": 3,
      "text": "An undertaking represented by this updated document is not a small feat and represents the summation of the initial authors of RFC 2960: Q. Xie, K. Morneault, C. Sharp, H. Schwarzbauer, T. Taylor, I. Rytina, M. Kalla, L. Zhang, and V. Paxson.",
      "ja": "この更新されたドキュメントによって表される仕事は小さな偉業ではなく、RFC 2960の最初の著者の総和を表し：Q.謝、K. Morneault、C.シャープ、H. Schwarzbauer、T.テイラー、I. Rytina、Mをカラ、L.チャン、およびV.パクソン。"
    },
    {
      "indent": 3,
      "text": "Add to that, the comments from everyone who contributed to the original RFC:",
      "ja": "、その元のRFCに貢献してみんなからのコメントを追加します。"
    },
    {
      "indent": 3,
      "text": "Mark Allman, R.J. Atkinson, Richard Band, Scott Bradner, Steve Bellovin, Peter Butler, Ram Dantu, R. Ezhirpavai, Mike Fisk, Sally Floyd, Atsushi Fukumoto, Matt Holdrege, Henry Houh, Christian Huitema, Gary Lehecka, Jonathan Lee, David Lehmann, John Loughney, Daniel Luan, Barry Nagelberg, Thomas Narten, Erik Nordmark, Lyndon Ong, Shyamal Prasad, Kelvin Porter, Heinz Prantner, Jarno Rajahalme, Raymond E. Reeves, Renee Revis, Ivan Arias Rodriguez, A. Sankar, Greg Sidebottom, Brian Wyld, La Monte Yarroll, and many others for their invaluable comments.",
      "ja": "マーク・オールマン、R.J.アトキンソン、リチャード・バンド、スコット・ブラッドナー、スティーブBellovin氏、ピーター・バトラー、ラムDantu、R. Ezhirpavai、マイク・フィスク、サリー・フロイド、敦福本、マット・ホールドレッジ、ヘンリーHouh、クリスチャンのHuitema、ゲイリーLehecka、ジョナサン・リー、デビッド・レーマン、ジョンLoughney 、ダニエル・ルアン、バリーNagelberg、トーマスNarten氏、エリックNordmarkと、リンドンオング、Shyamalプラサド、ケルビンポーター、ハインツPrantner、ヤルノRajahalme、レイモンドE.リーブス、レニーRevis、イバン・ロドリゲス・アリアス、A. Sankarの、グレッグSidebottom、ブライアンWyld、ラ・モンテYarroll、そして彼らの貴重なコメントのための他の多くの。"
    },
    {
      "indent": 3,
      "text": "Then, add the authors of the SCTP implementor's guide, I. Arias-Rodriguez, K. Poon, A. Caro, and M. Tuexen.",
      "ja": "次に、SCTPの実装者のガイド、I.アリアス・ロドリゲス、K.プーン、A.カロ、およびM. Tuexenの著者を追加します。"
    },
    {
      "indent": 3,
      "text": "Then add to these the efforts of all the subsequent seven SCTP interoperability tests and those who commented on RFC 4460 as shown in its acknowledgements:",
      "ja": "その後、後続のすべての7つのSCTPの相互運用性テストとその謝辞に示すように、RFC 4460にコメントした人のこれらの努力に追加します。"
    },
    {
      "indent": 3,
      "text": "Barry Zuckerman, La Monte Yarroll, Qiaobing Xie, Wang Xiaopeng, Jonathan Wood, Jeff Waskow, Mike Turner, John Townsend, Sabina Torrente, Cliff Thomas, Yuji Suzuki, Manoj Solanki, Sverre Slotte, Keyur Shah, Jan Rovins, Ben Robinson, Renee Revis, Ian Periam, RC Monee, Sanjay Rao, Sujith Radhakrishnan, Heinz Prantner, Biren Patel, Nathalie Mouellic, Mitch Miers, Bernward Meyknecht, Stan McClellan, Oliver Mayor, Tomas Orti Martin, Sandeep Mahajan, David Lehmann, Jonathan Lee, Philippe Langlois, Karl Knutson, Joe Keller, Gareth Keily, Andreas Jungmaier, Janardhan Iyengar, Mutsuya Irie, John Hebert, Kausar Hassan, Fred Hasle, Dan Harrison, Jon Grim, Laurent Glaude, Steven Furniss, Atsushi Fukumoto, Ken Fujita, Steve Dimig,",
      "ja": "バリー・ズッカーマン、ラ・モンテYarroll、Qiaobing謝、王Xiaopeng、ジョナサン・ウッド、ジェフWaskow、マイク・ターナー、ジョン・タウンゼント、サビーナトレンテ、クリフ・トーマス、鈴木雄二、ManojさんSolanki、スヴェレSlotte、Keyurシャー、ヤンRovins、ベン・ロビンソン、レニーRevis、イアンPeriam、RCモニー、サンジャイ・ラオ、Sujithラダクリシュナン、ハインツPrantner、Birenパテル、ナタリーMouellic、ミッチMIERS、Bernward Meyknecht、スタン・マクレラン、オリバー市長、トマスORTIマーティン、サンディープマハジャン、デビッド・レーマン、ジョナサン・リー、フィリップ・ラングロワ、カール・Knutson、ジョー・ケラー、ガレスKeily、アンドレアスJungmaier、Janardhanアイアンガー、Mutsuya入江、ジョン・エベール、Kausarハッサン、フレッドハスレ、ダン・ハリスン、ジョン・グリム、ローランGlaude、スティーブン・Furniss、敦福本、ケン・藤田、スティーブDimig、"
    },
    {
      "indent": 3,
      "text": "Thomas Curran, Serkan Cil, Melissa Campbell, Peter Butler, Rob Brennan, Harsh Bhondwe, Brian Bidulock, Caitlin Bestler, Jon Berger, Robby Benedyk, Stephen Baucke, Sandeep Balani, and Ronnie Sellar.",
      "ja": "トーマス・カラン、セルカンCIL、メリッサ・キャンベル、ピーター・バトラー、ロブ・ブレナン、過酷なBhondwe、ブライアンBidulock、ケイトリンBestler、ジョン・バージャー、ロビーBenedyk、スティーブンBaucke、サンディープBalani、そしてロニートルコ鞍。"
    },
    {
      "indent": 3,
      "text": "A special thanks to Mark Allman, who should actually be a co-author for his work on the max-burst, but managed to wiggle out due to a technicality. Also, we would like to acknowledge Lyndon Ong and Phil Conrad for their valuable input and many contributions.",
      "ja": "実際には、最大バーストの彼の仕事のための共著者であってもよいが、原因専門的に出て小刻みに管理しなければならないマーク・オールマンに感謝、。また、我々は彼らの貴重な入力と多くの貢献のためにリンドン・オングとフィル・コンラッドを確認したいと思います。"
    },
    {
      "indent": 3,
      "text": "And finally, you have this document, and those who have commented upon that including Alfred Hoenes and Ronnie Sellars.",
      "ja": "そして最後に、あなたはこの文書を持っている、とアルフレッドHoenesとロニー・セラーズなど、その時にコメントしている人たち。"
    },
    {
      "indent": 3,
      "text": "My thanks cannot be adequately expressed to all of you who have participated in the coding, testing, and updating process of this document. All I can say is, Thank You!",
      "ja": "私のおかげで適切にコーディング、テスト、およびこのドキュメントの更新処理に参加した人あなたのすべてに表現することができません。すべて私に言えることです、ありがとうございました！"
    },
    {
      "indent": 3,
      "text": "Randall Stewart - Editor",
      "ja": "ランドール・スチュワート - エディタ"
    },
    {
      "indent": 0,
      "text": "Appendix A. Explicit Congestion Notification",
      "ja": "付録A.明示的輻輳通知"
    },
    {
      "indent": 3,
      "text": "ECN [RFC3168] describes a proposed extension to IP that details a method to become aware of congestion outside of datagram loss. This is an optional feature that an implementation MAY choose to add to SCTP. This appendix details the minor differences implementers will need to be aware of if they choose to implement this feature. In general, [RFC3168] should be followed with the following exceptions.",
      "ja": "ECN [RFC3168]は、データグラムの損失の外輻輳の自覚する方法を詳述IPに提案された拡張を記述しています。これは、実装がSCTPに追加することを選択するかもしれないオプション機能です。この付録では、彼らがこの機能を実装することを選択した場合、実装が注意する必要がありますわずかな違いを詳しく説明します。一般的には、[RFC3168]は以下の例外を除いて従うべきです。"
    },
    {
      "indent": 3,
      "text": "Negotiation:",
      "ja": "ネゴシエーション："
    },
    {
      "indent": 3,
      "text": "[RFC3168] details negotiation of ECN during the SYN and SYN-ACK stages of a TCP connection. The sender of the SYN sets 2 bits in the TCP flags, and the sender of the SYN-ACK sets only 1 bit. The reasoning behind this is to ensure that both sides are truly ECN capable. For SCTP, this is not necessary. To indicate that an endpoint is ECN capable, an endpoint SHOULD add to the INIT and or INIT ACK chunk the TLV reserved for ECN. This TLV contains no parameters, and thus has the following format:",
      "ja": "[RFC3168]はTCP接続のSYNおよびSYN-ACK段階でECNのネゴシエーションを詳述します。 SYNの送信者は、TCPフラグに2ビットを設定し、SYN-ACKの送信者は、1ビットのみを設定します。この背後にある理由は、両側が本当にECN能力があることを確認することです。 SCTPの場合、これは必要ありません。エンドポイントができるECNであることを示すために、エンドポイントは、TLVがECNのために予約INIT及びまたはINIT ACKチャンクに追加する必要があります。このTLVはパラメータが含まれていないので、次の形式があります。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Parameter Type = 32768      |     Parameter Length = 4      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ECN-Echo:",
      "ja": "ECN-エコー："
    },
    {
      "indent": 3,
      "text": "[RFC3168] details a specific bit for a receiver to send back in its TCP acknowledgements to notify the sender of the Congestion Experienced (CE) bit having arrived from the network. For SCTP, this same indication is made by including the ECNE chunk. This chunk contains one data element, i.e., the lowest TSN associated with the IP datagram marked with the CE bit, and looks as follows:",
      "ja": "[RFC3168]は、受信機が経験輻輳の送信者に通知するために、そのTCP確認応答で返送するための特定のビットを詳細（CE）ビットがネットワークから到着しました。 SCTPのために、この同じ表示はECNEチャンクを含むことによって行われます。このチャンクは、1つのデータ要素、すなわち、CEビットでマークされたIPデータグラムに関連した最低のTSNが含まれており、次のようになります。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Chunk Type=12 | Flags=00000000|    Chunk Length = 8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Lowest TSN Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Note: The ECNE is considered a Control chunk.",
      "ja": "注意：ECNEは、コントロールチャンクと考えられています。"
    },
    {
      "indent": 3,
      "text": "CWR:",
      "ja": "CWR："
    },
    {
      "indent": 3,
      "text": "[RFC3168] details a specific bit for a sender to send in the header of its next outbound TCP segment to indicate to its peer that it has reduced its congestion window. This is termed the CWR bit. For SCTP, the same indication is made by including the CWR chunk. This chunk contains one data element, i.e., the TSN number that was sent in the ECNE chunk. This element represents the lowest TSN number in the datagram that was originally marked with the CE bit.",
      "ja": "[RFC3168]は、その輻輳ウィンドウを減少させたことをピアに示すために、その次のアウトバウンドTCPセグメントのヘッダに送信する送信者の特定のビットを詳述します。これは、CWRビットと呼ばれます。 SCTPのために、同じ表示がCWRチャンクを含むことによって行われます。このチャンクは、1つのデータ要素、すなわち、ECNEチャンクで送信されたTSN番号を含みます。この要素は元々CEビットでマークされたデータグラムで最も低いTSNの数を表します。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Chunk Type=13 | Flags=00000000|    Chunk Length = 8           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Lowest TSN Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Note: The CWR is considered a Control chunk.",
      "ja": "注意：CWRは、コントロールチャンクと考えられています。"
    },
    {
      "indent": 0,
      "text": "Appendix B. CRC32c Checksum Calculation",
      "ja": "付録B. CRC32Cチェックサムの計算"
    },
    {
      "indent": 3,
      "text": "We define a 'reflected value' as one that is the opposite of the normal bit order of the machine. The 32-bit CRC (Cyclic Redundancy Check) is calculated as described for CRC32c and uses the polynomial code 0x11EDC6F41 (Castagnoli93) or x^32+x^28+x^27+x^26+x^25 +x^23+x^22+x^20+x^19+x^18+ x^14+x^13+x^11+x^10+x^9+x^8+x^6+x^0. The CRC is computed using a procedure similar to ETHERNET CRC [ITU32], modified to reflect transport-level usage.",
      "ja": "我々は、機械の通常のビット順序の逆であるとして「反射値を」定義します。 32ビットのCRC（巡回冗長検査）がCRC32Cについて説明したように計算された多項式コード0x11EDC6F41（Castagnoli93）またはX ^ 32 + X ^ 28 + X ^ 27 + X ^ 26 + X ^ 25 + X ^ 23 +を使用していますX ^ 22 + X ^ 20 + X ^ 19 + X ^ 18 + X ^ 14 + X ^ 13 + X ^ 11 + X ^ 10 + X ^ 9 + X ^ 8 + X ^ 6 + X ^ 0。 CRCは、トランスポートレベルの使用を反映するように変更ETHERNET CRC [ITU32]と同様の手順を使用して計算されます。"
    },
    {
      "indent": 3,
      "text": "CRC computation uses polynomial division. A message bit-string M is transformed to a polynomial, M(X), and the CRC is calculated from M(X) using polynomial arithmetic.",
      "ja": "CRCの計算は、多項式除算を使用しています。メッセージビット列Mは多項式M（X）に変換され、そしてCRCは、多項式演算を使用してM（X）から計算されます。"
    },
    {
      "indent": 3,
      "text": "When CRCs are used at the link layer, the polynomial is derived from on-the-wire bit ordering: the first bit 'on the wire' is the high-order coefficient. Since SCTP is a transport-level protocol, it cannot know the actual serial-media bit ordering. Moreover, different links in the path between SCTP endpoints may use different link-level bit orders.",
      "ja": "CRCはリンク層で使用される場合、多項式がオン・ザ・ワイヤビットの順序から導出される：「ワイヤ上の」最初のビットは、高次係数です。 SCTPは、トランスポートレベルのプロトコルであるので、実際のシリアルメディアビット順序を知ることができません。また、SCTPエンドポイント間の経路における異なるリンクは、異なるリンク・レベルのビット順序を使用してもよいです。"
    },
    {
      "indent": 3,
      "text": "A convention must therefore be established for mapping SCTP transport messages to polynomials for purposes of CRC computation. The bit-ordering for mapping SCTP messages to polynomials is that bytes are taken most-significant first, but within each byte, bits are taken least-significant first. The first byte of the message provides the eight highest coefficients. Within each byte, the least-significant SCTP bit gives the most-significant polynomial coefficient within that byte, and the most-significant SCTP bit is the least-significant polynomial coefficient in that byte. (This bit ordering is sometimes called 'mirrored' or 'reflected' [WILLIAMS93].) CRC polynomials are to be transformed back into SCTP transport-level byte values, using a consistent mapping.",
      "ja": "大会は、したがって、CRC計算の目的のために多項式にマッピングSCTP輸送メッセージのために確立されなければなりません。多項式にマッピングSCTPメッセージのビット順序は、バイトが最初の最上位取られているが、各バイト内のビットは最下位第取られることです。メッセージの最初のバイトは8つの最高の係数を提供します。各バイト内、最下位SCTPビットがそのバイト内の最上位の多項式係数を与え、そして最上位SCTPビットがそのバイトの最下位多項式の係数です。 （このビットの順序は、時に[WILLIAMS93]「ミラー」または「反射」と呼ばれる。）CRC多項式一致マッピングを使用して、バックSCTPトランスポートレベルのバイト値に変換されます。"
    },
    {
      "indent": 3,
      "text": "The SCTP transport-level CRC value should be calculated as follows:",
      "ja": "次のようにSCTPトランスポートレベルのCRC値が計算されるべきです。"
    },
    {
      "indent": 3,
      "text": "- CRC input data are assigned to a byte stream, numbered from 0 to N-1.",
      "ja": " -  CRC入力データが0からN-1までの番号が付けられたバイトストリームに割り当てられます。"
    },
    {
      "indent": 3,
      "text": "- The transport-level byte stream is mapped to a polynomial value. An N-byte PDU with j bytes numbered 0 to N-1 is considered as coefficients of a polynomial M(x) of order 8N-1, with bit 0 of byte j being coefficient x^(8(N-j)-8), and bit 7 of byte j being coefficient x^(8(N-j)-1).",
      "ja": " - トランスポートレベルのバイトストリームは、多項式の値にマッピングされます。 JのバイトのNバイトのPDUは、バイトJある係数X ^（8（NJ）-8）のビット0と、オーダー8N-1の多項式M（x）の係数として考えられるN-1に0の番号が付けバイトjのある係数X ^（8（NJ）-1）のビット7。"
    },
    {
      "indent": 3,
      "text": "- The CRC remainder register is initialized with all 1s and the CRC is computed with an algorithm that simultaneously multiplies by x^32 and divides by the CRC polynomial.",
      "ja": " -  CRC剰余レジスタはすべて1で初期化され、CRCが同時にX ^ 32によって乗算し、CRC多項式で除算アルゴリズムを用いて計算されます。"
    },
    {
      "indent": 3,
      "text": "- The polynomial is multiplied by x^32 and divided by G(x), the generator polynomial, producing a remainder R(x) of degree less than or equal to 31.",
      "ja": " - 多項式は、x ^ 32によって乗算され、31以下程度の剰余R（x）を生成し、G（x）は、生成多項式で割りました。"
    },
    {
      "indent": 3,
      "text": "- The coefficients of R(x) are considered a 32-bit sequence.",
      "ja": " -  Rの係数（x）は32ビットのシーケンスであると考えられます。"
    },
    {
      "indent": 3,
      "text": "- The bit sequence is complemented. The result is the CRC polynomial.",
      "ja": " - ビットシーケンスが補完されます。結果は、CRC多項式です。"
    },
    {
      "indent": 3,
      "text": "- The CRC polynomial is mapped back into SCTP transport-level bytes. The coefficient of x^31 gives the value of bit 7 of SCTP byte 0, and the coefficient of x^24 gives the value of bit 0 of byte 0. The coefficient of x^7 gives bit 7 of byte 3, and the coefficient of x^0 gives bit 0 of byte 3. The resulting 4-byte transport-level sequence is the 32-bit SCTP checksum value.",
      "ja": " -  CRC多項式はバックSCTPトランスポートレベルのバイトにマッピングされます。 X ^ 31の係数は、SCTPのバイト0のビット7の値を与え、そしてx ^ 24の係数は、バイト0のビット0の値を与えるX ^ 7の係数がバイト3、及び係数のビット7を与えます0 X ^では、得られた4バイトのトランスポートレベルのシーケンスが32ビットSCTPチェックサム値であるバイト3のビット0を与えます。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: Standards documents, textbooks, and vendor literature on CRCs often follow an alternative formulation, in which the register used to hold the remainder of the long-division algorithm is initialized to zero rather than all-1s, and instead the first 32 bits of the message are complemented. The long-division algorithm used in our formulation is specified such that the initial multiplication by 2^32 and the long-division are combined into one simultaneous operation. For such algorithms, and for messages longer than 64 bits, the two specifications are precisely equivalent. That equivalence is the intent of this document.",
      "ja": "実装注：標準ドキュメント、教科書、及びCRCの上のベンダー文献は、多くの場合、レジスタがゼロではなく、すべての-1Sに初期化される長い分割アルゴリズムの残りの部分を保持するために使用される代替製剤、その代わりに最初の32ビットをたどりますメッセージの補完されています。我々の製剤に使用される長い分割アルゴリズムは、2 ^ 32による初期乗算と長い分割は、1つの同時操作に結合されるように指定されています。そのようなアルゴリズムのために、64ビットより長いメッセージのために、2つの仕様を正確に等価です。その等価性は、この文書の意図です。"
    },
    {
      "indent": 3,
      "text": "Implementors of SCTP are warned that both specifications are to be found in the literature, sometimes with no restriction on the long-division algorithm. The choice of formulation in this document is to permit non-SCTP usage, where the same CRC algorithm may be used to protect messages shorter than 64 bits.",
      "ja": "SCTPの実装は、両方の仕様は、時には長い分割アルゴリズム上の制限なく、文献に見出されることを警告されています。この文書に記載されている製剤の選択は、同じCRCアルゴリズムは、64ビットより短いメッセージを保護するために使用することができる非SCTPの使用を、可能にすることです。"
    },
    {
      "indent": 3,
      "text": "There may be a computational advantage in validating the association against the Verification Tag, prior to performing a checksum, as invalid tags will result in the same action as a bad checksum in most cases. The exceptions for this technique would be INIT and some SHUTDOWN-COMPLETE exchanges, as well as a stale COOKIE ECHO. These special-case exchanges must represent small packets and will minimize the effect of the checksum calculation.",
      "ja": "検証タグに対する関連性を検証し、計算で利点がある可能性があり、チェックサムを実行する前には、無効としてタグは、ほとんどの場合、不正なチェックサムと同じ動作になります。この技術のための例外はINITと、いくつかのSHUTDOWN-COMPLETEの交流だけでなく、古いCOOKIEのECHOだろう。これらの特別なケースの交換は小さなパケットを表しなければならず、チェックサム計算の影響を最小化します。"
    },
    {
      "indent": 0,
      "text": "Appendix C. ICMP Handling",
      "ja": "付録C. ICMPの取り扱い"
    },
    {
      "indent": 3,
      "text": "Whenever an ICMP message is received by an SCTP endpoint, the following procedures MUST be followed to ensure proper utilization of the information being provided by layer 3.",
      "ja": "ICMPメッセージはSCTPエンドポイントによって受信されるたびに、次の手順では、レイヤ3によって提供される情報の適切な使用を確実にするために従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "ICMP1) An implementation MAY ignore all ICMPv4 messages where the type field is not set to \"Destination Unreachable\".",
      "ja": "ICMP1）の実装は、タイプフィールドが「宛先到達不能」に設定されていないすべてのICMPv4メッセージを無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "ICMP2) An implementation MAY ignore all ICMPv6 messages where the type field is not \"Destination Unreachable\", \"Parameter Problem\",, or \"Packet Too Big\".",
      "ja": "ICMP2）の実装は、「パラメータ問題」,,または「パケット過大」をタイプフィールドは「宛先到達不能」ではない、すべてのICMPv6メッセージを無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "ICMP3) An implementation MAY ignore any ICMPv4 messages where the code does not indicate \"Protocol Unreachable\" or \"Fragmentation Needed\".",
      "ja": "ICMP3）実装では、コードは「プロトコル到達不能」または「断片化必要」を示すものではありません任意のICMPv4のメッセージを無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "ICMP4) An implementation MAY ignore all ICMPv6 messages of type \"Parameter Problem\" if the code is not \"Unrecognized Next Header Type Encountered\".",
      "ja": "コードは「認識できない次のヘッダタイプが発生しました」でない場合ICMP4）実装がタイプ「パラメータ問題」のすべてのICMPv6メッセージを無視してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "ICMP5) An implementation MUST use the payload of the ICMP message (v4 or v6) to locate the association that sent the message to which ICMP is responding. If the association cannot be found, an implementation SHOULD ignore the ICMP message.",
      "ja": "ICMP5）実装はICMPが応答されたメッセージを送信した関連付けを検索するためにICMPメッセージ（V4またはV6）のペイロードを使用しなければなりません。関連付けが見つからない場合、実装はICMPメッセージを無視すべきです。"
    },
    {
      "indent": 3,
      "text": "ICMP6) An implementation MUST validate that the Verification Tag contained in the ICMP message matches the Verification Tag of the peer. If the Verification Tag is not 0 and does NOT match, discard the ICMP message. If it is 0 and the ICMP message contains enough bytes to verify that the chunk type is an INIT chunk and that the Initiate Tag matches the tag of the peer, continue with ICMP7. If the ICMP message is too short or the chunk type or the Initiate Tag does not match, silently discard the packet.",
      "ja": "ICMP6）実装はICMPメッセージに含まれる検証タグは、ピアの検証タグと一致することを検証しなければなりません。検証タグが0ではないと一致しない場合は、ICMPメッセージを破棄します。それが0であり、ICMPメッセージは、チャンクタイプがINITチャンクであることを確認するのに十分なバイトが含まれており、タグを開始することをICMP7に進み、ピアのタグと一致する場合。 ICMPメッセージが短すぎるか、チャンクタイプまたは開始タグが一致しない場合は、静かにパケットを破棄する。"
    },
    {
      "indent": 3,
      "text": "ICMP7) If the ICMP message is either a v6 \"Packet Too Big\" or a v4 \"Fragmentation Needed\", an implementation MAY process this information as defined for PATH MTU discovery.",
      "ja": "ICMPメッセージはv6の「パケット過大」またはV4「断片化が必要」のいずれかである場合はPATH MTUの発見のために定義されているようICMP7）、実装はこの情報を処理することができます。"
    },
    {
      "indent": 3,
      "text": "ICMP8) If the ICMP code is an \"Unrecognized Next Header Type Encountered\" or a \"Protocol Unreachable\", an implementation MUST treat this message as an abort with the T bit set if it does not contain an INIT chunk. If it does contain an INIT chunk and the association is in the COOKIE-WAIT state, handle the ICMP message like an ABORT.",
      "ja": "ICMPコードが「認識されない次のヘッダタイプが発生しました」または「プロトコル到達不能」である場合、それはINITチャンクが含まれていない場合、TはビットセットでICMP8）は、実装が中止として、このメッセージを扱わなければなりません。それがINITチャンクを含んでいますし、協会がCOOKIE-WAIT状態にある場合は、ABORTのようなICMPメッセージを処理します。"
    },
    {
      "indent": 3,
      "text": "ICMP9) If the ICMPv6 code is \"Destination Unreachable\", the implementation MAY mark the destination into the unreachable state or alternatively increment the path error counter.",
      "ja": "ICMP9 ICMPv6のコードが「到達不能宛先」である場合）、実装が到達不能状態に宛先をマーク又は代替パス・エラー・カウンタをインクリメントするかもしれません。"
    },
    {
      "indent": 3,
      "text": "Note that these procedures differ from [RFC1122] and from its requirements for processing of port-unreachable messages and the requirements that an implementation MUST abort associations in response to a \"protocol unreachable\" message. Port-unreachable messages are not processed, since an implementation will send an ABORT, not a port unreachable. The stricter handling of the \"protocol unreachable\" message is due to security concerns for hosts that do NOT support SCTP.",
      "ja": "これらの手順は[RFC1122]から、そのポート到達不能メッセージを処理するための要件と実装が「プロトコル到達不能」メッセージに応答して関連付けを中止しなければならない要件とは異なることに留意されたいです。実装はABORT、到達不可能ではないポートをお送りしますので、ポート到達不能メッセージは、処理されません。 「プロトコル到達不能」メッセージの厳格な取り扱いは、SCTPをサポートしていないホストのためのセキュリティ上の問題によるものです。"
    },
    {
      "indent": 3,
      "text": "The following non-normative sample code is taken from an open-source CRC generator [WILLIAMS93], using the \"mirroring\" technique and yielding a lookup table for SCTP CRC32c with 256 entries, each 32 bits wide. While neither especially slow nor especially fast, as software table-lookup CRCs go, it has the advantage of working on both big-endian and little-endian CPUs, using the same (host-order) lookup tables, and using only the predefined ntohl() and htonl() operations. The code is somewhat modified from [WILLIAMS93], to ensure portability between big-endian and little-endian architectures. (Note that if the byte endian-ness of the target architecture is known to be little-endian, the final bit-reversal and byte-reversal steps can be folded into a single operation.)",
      "ja": "以下の非規範的なサンプル・コードは、「ミラーリング」技術を使用して256のエントリ、広い各32ビットでSCTPのCRC32Cのルックアップテーブルをもたらす、オープンソースのCRC生成器[WILLIAMS93]から取られます。しばらくどちらもいないソフトウェアのテーブルルックアップCRCが行くように、それは、両方のビッグエンディアンとリトルエンディアンのCPUに取り組んで同じ（ホスト順）ルックアップテーブルを使用して、事前に定義されたntohlを使用することの利点を持っている、特に低速でも特に速いです（）とhtonl（）操作。コードは幾分ビッグエンディアンとリトルエンディアンアーキテクチャ間の移植性を確保するために、[WILLIAMS93]から変更されています。 （ターゲット・アーキテクチャのバイトエンディアンネスは、リトルエンディアンであることが知られている場合、最終的なビット反転とバイト反転ステップは単一の動作に折り畳むことができることに留意されたいです。）"
    },
    {
      "indent": 3,
      "text": "/*************************************************************/\n/* Note Definition for Ross Williams table generator would   */\n/* be: TB_WIDTH=4, TB_POLLY=0x1EDC6F41, TB_REVER=TRUE        */\n/* For Mr. Williams direct calculation code use the settings */\n/* cm_width=32, cm_poly=0x1EDC6F41, cm_init=0xFFFFFFFF,      */\n/* cm_refin=TRUE, cm_refot=TRUE, cm_xorort=0x00000000        */\n/*************************************************************/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Example of the crc table file */\n#ifndef __crc32cr_table_h__\n#define __crc32cr_table_h__",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define CRC32C_POLY 0x1EDC6F41 #define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])",
      "ja": "#define CRC32C_POLY 0x1EDC6F41に#define CRC32C（C、D）（C =（C >> 8）^ crc_c [（C ^（D））＆0xFFで]）"
    },
    {
      "indent": 3,
      "text": "unsigned long crc_c[256] = { 0x00000000L, 0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L, 0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L, 0xD4CA64EBL, 0x8AD958CFL, 0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL, 0x4D43CFD0L, 0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L, 0x105EC76FL, 0xE235446CL, 0xF165B798L, 0x030E349BL, 0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L, 0x9A879FA0L, 0x68EC1CA3L, 0x7BBCEF57L, 0x89D76C54L, 0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L, 0x4E4DFB4BL, 0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL, 0xE72719C1L, 0x154C9AC2L, 0x061C6936L, 0xF477EA35L, 0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L, 0xB93425E5L, 0x6DFE410EL, 0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL, 0x30E349B1L, 0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L,",
      "ja": "unsigned long型crc_c [256] = {0x00000000L、0xF26B8303L、0xE13B70F7L、0x1350F3F4L、0xC79A971FL、0x35F1141CL、0x26A1E7E8L、0xD4CA64EBL、0x8AD958CFL、0x78B2DBCCL、0x6BE22838L、0x9989AB3BL、0x4D43CFD0L、0xBF284CD3L、0xAC78BF27L、0x5E133C24L、0x105EC76FL、0xE235446CL、0xF165B798L、0x030E349BL、0xD7C45070L、 0x25AFD373L、0x36FF2087L、0xC494A384L、0x9A879FA0L、0x68EC1CA3L、0x7BBCEF57L、0x89D76C54L、0x5D1D08BFL、0xAF768BBCL、0xBC267848L、0x4E4DFB4BL、0x20BD8EDEL、0xD2D60DDDL、0xC186FE29L、0x33ED7D2AL、0xE72719C1L、0x154C9AC2L、0x061C6936L、0xF477EA35L、0xAA64D611L、0x580F5512L、0x4B5FA6E6L、0xB93425E5L、0x6DFE410EL、0x9F95C20DL、 0x8CC531F9L、0x7EAEB2FAL、0x30E349B1L、0xC288CAB2L、0xD1D83946L、0x23B3BA45L、"
    },
    {
      "indent": 3,
      "text": "0xF779DEAEL, 0x05125DADL, 0x1642AE59L, 0xE4292D5AL, 0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL, 0x7DA08661L, 0x8FCB0562L, 0x9C9BF696L, 0x6EF07595L, 0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL, 0x522BEE48L, 0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L, 0xCBA24573L, 0x39C9C670L, 0x2A993584L, 0xD8F2B687L, 0x0C38D26CL, 0xFE53516FL, 0xED03A29BL, 0x1F682198L, 0x5125DAD3L, 0xA34E59D0L, 0xB01EAA24L, 0x42752927L, 0x96BF4DCCL, 0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L, 0xDBFC821CL, 0x2997011FL, 0x3AC7F2EBL, 0xC8AC71E8L, 0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L, 0x61C69362L, 0x93AD1061L, 0x80FDE395L, 0x72966096L, 0xA65C047DL, 0x5437877EL, 0x4767748AL, 0xB50CF789L, 0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L, 0x2C855CB2L, 0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L, 0x7198540DL, 0x83F3D70EL, 0x90A324FAL, 0x62C8A7F9L, 0xB602C312L, 0x44694011L, 0x5739B3E5L, 0xA55230E6L, 0xFB410CC2L, 0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L, 0x3CDB9BDDL, 0xCEB018DEL, 0xDDE0EB2AL, 0x2F8B6829L, 0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL, 0x456CAC67L, 0xB7072F64L, 0xA457DC90L, 0x563C5F93L, 0x082F63B7L, 0xFA44E0B4L, 0xE9141340L, 0x1B7F9043L, 0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL, 0x92A8FC17L, 0x60C37F14L, 0x73938CE0L, 0x81F80FE3L, 0x55326B08L, 0xA759E80BL, 0xB4091BFFL, 0x466298FCL,",
      "ja": "0xF779DEAEL、0x05125DADL、0x1642AE59L、0xE4292D5AL、0xBA3A117EL、0x4851927DL、0x5B016189L、0xA96AE28AL、0x7DA08661L、0x8FCB0562L、0x9C9BF696L、0x6EF07595L、0x417B1DBCL、0xB3109EBFL、0xA0406D4BL、0x522BEE48L、0x86E18AA3L、0x748A09A0L、0x67DAFA54L、0x95B17957L、0xCBA24573L、0x39C9C670L、0x2A993584L、0xD8F2B687L、0x0C38D26CL、 0xFE53516FL、0xED03A29BL、0x1F682198L、0x5125DAD3L、0xA34E59D0L、0xB01EAA24L、0x42752927L、0x96BF4DCCL、0x64D4CECFL、0x77843D3BL、0x85EFBE38L、0xDBFC821CL、0x2997011FL、0x3AC7F2EBL、0xC8AC71E8L、0x1C661503L、0xEE0D9600L、0xFD5D65F4L、0x0F36E6F7L、0x61C69362L、0x93AD1061L、0x80FDE395L、0x72966096L、0xA65C047DL、0x5437877EL、 0x4767748AL、0xB50CF789L、0xEB1FCBADL、0x197448AEL、0x0A24BB5AL、0xF84F3859L、0x2C855CB2L、0xDEEEDFB1L、0xCDBE2C45L、0x3FD5AF46L、0x7198540DL、0x83F3D70EL、0x90A324FAL、0x62C8A7F9L、0xB602C312L、0x44694011L、0x5739B3E5L、0xA55230E6L、0xFB410CC2L、0x092A8FC1L、0x1A7A7C35L、0xE811FF36L、0x3CDB9BDDL、0xCEB018DEL、0xDDE0EB2AL、 0x2F8B6829L、0x82F63B78L、 0x709DB87BL、0x63CD4B8FL、0x91A6C88CL、0x456CAC67L、0xB7072F64L、0xA457DC90L、0x563C5F93L、0x082F63B7L、0xFA44E0B4L、0xE9141340L、0x1B7F9043L、0xCFB5F4A8L、0x3DDE77ABL、0x2E8E845FL、0xDCE5075CL、0x92A8FC17L、0x60C37F14L、0x73938CE0L、0x81F80FE3L、0x55326B08L、0xA759E80BL、0xB4091BFFL、0x466298FCL、"
    },
    {
      "indent": 3,
      "text": "0x1871A4D8L, 0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL, 0xDFEB33C7L, 0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L, 0xA24BB5A6L, 0x502036A5L, 0x4370C551L, 0xB11B4652L, 0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL, 0x2892ED69L, 0xDAF96E6AL, 0xC9A99D9EL, 0x3BC21E9DL, 0xEF087A76L, 0x1D63F975L, 0x0E330A81L, 0xFC588982L, 0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL, 0x758FE5D6L, 0x87E466D5L, 0x94B49521L, 0x66DF1622L, 0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L, 0x2B9CD9F2L, 0xFF56BD19L, 0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL, 0xC38D26C4L, 0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L, 0x0417B1DBL, 0xF67C32D8L, 0xE52CC12CL, 0x1747422FL, 0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL, 0x8ECEE914L, 0x7CA56A17L, 0x6FF599E3L, 0x9D9E1AE0L, 0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL, 0xC083125FL, 0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L, 0x590AB964L, 0xAB613A67L, 0xB831C993L, 0x4A5A4A90L, 0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL, 0x8DC0DD8FL, 0xE330A81AL, 0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL, 0x24AA3F05L, 0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L, 0x69E9F0D5L, 0x9B8273D6L, 0x88D28022L, 0x7AB90321L, 0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL, 0xF36E6F75L, 0x0105EC76L, 0x12551F82L, 0xE03E9C81L,",
      "ja": "0x1871A4D8L、0xEA1A27DBL、0xF94AD42FL、0x0B21572CL、0xDFEB33C7L、0x2D80B0C4L、0x3ED04330L、0xCCBBC033L、0xA24BB5A6L、0x502036A5L、0x4370C551L、0xB11B4652L、0x65D122B9L、0x97BAA1BAL、0x84EA524EL、0x7681D14DL、0x2892ED69L、0xDAF96E6AL、0xC9A99D9EL、0x3BC21E9DL、0xEF087A76L、0x1D63F975L、0x0E330A81L、0xFC588982L、0xB21572C9L、 0x407EF1CAL、0x532E023EL、0xA145813DL、0x758FE5D6L、0x87E466D5L、0x94B49521L、0x66DF1622L、0x38CC2A06L、0xCAA7A905L、0xD9F75AF1L、0x2B9CD9F2L、0xFF56BD19L、0x0D3D3E1AL、0x1E6DCDEEL、0xEC064EEDL、0xC38D26C4L、0x31E6A5C7L、0x22B65633L、0xD0DDD530L、0x0417B1DBL、0xF67C32D8L、0xE52CC12CL、0x1747422FL、0x49547E0BL、0xBB3FFD08L、 0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、 0xF0605BEEL、0x24AA3F05L、 0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、"
    },
    {
      "indent": 3,
      "text": "0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL, 0x27A40B9EL, 0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL, 0xBE2DA0A5L, 0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L, };",
      "ja": "0x34F4F86AL、0xC69F7B69L、0xD5CF889DL、0x27A40B9EL、0x79B737BAL、0x8BDCB4B9L、0x988C474DL、0x6AE7C44EL、0xBE2DA0A5L、0x4C4623A6L、0x5F16D052L、0xAD7D5351L、}。"
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endifの"
    },
    {
      "indent": 4,
      "text": "/* Example of table build routine */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#include <stdio.h> #include <stdlib.h>",
      "ja": "書式#include <stdio.hに>する#include <stdlib.h>に含ま"
    },
    {
      "indent": 3,
      "text": "#define OUTPUT_FILE   \"crc32cr.h\"\n#define CRC32C_POLY    0x1EDC6F41L\nFILE *tf;\nunsigned long\nreflect_32 (unsigned long b)\n{\n  int i;\n  unsigned long rw = 0L;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "for (i = 0; i < 32; i++){ if (b & 1) rw |= 1 << (31 - i);",
      "ja": "用（i = 0; iは32 <; iは++）{IF（B＆1）RW | = 1 <<（31  -  I）。"
    },
    {
      "indent": 3,
      "text": "      b >>= 1;\n  }\n  return (rw);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "unsigned long\nbuild_crc_table (int index)\n{\n  int i;\n  unsigned long rb;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "rb = reflect_32 (index);",
      "ja": "RB = reflect_32（インデックス）"
    },
    {
      "indent": 3,
      "text": "  for (i = 0; i < 8; i++){\n      if (rb & 0x80000000L)\n       rb = (rb << 1) ^ CRC32C_POLY;\n      else\n       rb <<= 1;\n  }\n  return (reflect_32 (rb));\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "main () { int i;",
      "ja": "メイン（）{I int型。"
    },
    {
      "indent": 5,
      "text": "printf (\"\\nGenerating CRC-32c table file <%s>\\n\",\nOUTPUT_FILE);\nif ((tf = fopen (OUTPUT_FILE, \"w\")) == NULL){\n    printf (\"Unable to open %s\\n\", OUTPUT_FILE);\n    exit (1);\n}\nfprintf (tf, \"#ifndef __crc32cr_table_h__\\n\");\nfprintf (tf, \"#define __crc32cr_table_h__\\n\\n\");\nfprintf (tf, \"#define CRC32C_POLY 0x%08lX\\n\",\nCRC32C_POLY);\nfprintf (tf,\n\"#define CRC32C(c,d) (c=(c>>8)^crc_c[(c^(d))&0xFF])\\n\");\nfprintf (tf, \"\\nunsigned long  crc_c[256] =\\n{\\n\");\nfor (i = 0; i < 256; i++){\n    fprintf (tf, \"0x%08lXL, \", build_crc_table (i));\n    if ((i & 3) == 3)\n      fprintf (tf, \"\\n\");\n}\nfprintf (tf, \"};\\n\\n#endif\\n\");",
      "raw": true
    },
    {
      "indent": 5,
      "text": "if (fclose (tf) != 0) printf (\"Unable to close <%s>.\" OUTPUT_FILE);",
      "ja": "（もし！fcloseを（TF）= 0）のprintf（ \"<％s>をクローズできません。\" OUTPUT_FILE）。"
    },
    {
      "indent": 3,
      "text": " else printf (\"\\nThe CRC-32c table has been written to <%s>.\\n\", OUTPUT_FILE); }",
      "ja": "他のprintf（ \"\\ nのCRC-32cのテーブルが書き込まれている<％S> \\ nまで。\"、OUTPUT_FILE）。 }"
    },
    {
      "indent": 3,
      "text": "/* Example of crc insertion */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#include \"crc32cr.h\"",
      "ja": "#include \"crc32cr.h\""
    },
    {
      "indent": 3,
      "text": "unsigned long\ngenerate_crc32c(unsigned char *buffer, unsigned int length)\n{\n  unsigned int i;\n  unsigned long crc32 = ~0L;\n  unsigned long result;\n  unsigned char byte0,byte1,byte2,byte3;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "for (i = 0; i < length; i++){ CRC32C(crc32, buffer[i]); }",
      "ja": "用（i = 0; iは長さ<; iは++）{CRC32C（CRC32は、緩衝液[I]）。 }"
    },
    {
      "indent": 5,
      "text": "result = ~crc32;",
      "ja": "結果=〜CRC32。"
    },
    {
      "indent": 5,
      "text": "/*  result now holds the negated polynomial remainder;\n *  since the table and algorithm is \"reflected\" [williams95].\n *  That is, result has the same value as if we mapped the message\n *  to a polynomial, computed the host-bit-order polynomial\n *  remainder, performed final negation, then did an end-for-end\n *  bit-reversal.\n *  Note that a 32-bit bit-reversal is identical to four inplace\n *  8-bit reversals followed by an end-for-end byteswap.\n *  In other words, the bytes of each bit are in the right order,\n *  but the bytes have been byteswapped.  So we now do an explicit\n *  byteswap.  On a little-endian machine, this byteswap and\n *  the final ntohl cancel out and could be elided.\n */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  byte0 = result & 0xff;\n  byte1 = (result>>8) & 0xff;\n  byte2 = (result>>16) & 0xff;\n  byte3 = (result>>24) & 0xff;\n  crc32 = ((byte0 << 24) |\n           (byte1 << 16) |\n           (byte2 << 8)  |\n           byte3);\n  return ( crc32 );\n} int\ninsert_crc32(unsigned char *buffer, unsigned int length)\n{\n  SCTP_message *message;\n  unsigned long crc32;\n  message = (SCTP_message *) buffer;\n  message->common_header.checksum = 0L;\n  crc32 = generate_crc32c(buffer,length);\n  /* and insert it into the message */\n  message->common_header.checksum = htonl(crc32);\n  return 1;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "int\nvalidate_crc32(unsigned char *buffer, unsigned int length)\n{\n  SCTP_message *message;\n  unsigned int i;\n  unsigned long original_crc32;\n  unsigned long crc32 = ~0L;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  /* save and zero checksum */\n  message = (SCTP_message *) buffer;\n  original_crc32 = ntohl(message->common_header.checksum);\n  message->common_header.checksum = 0L;\n  crc32 = generate_crc32c(buffer,length);\n  return ((original_crc32 == crc32)? 1 : -1);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "リファレンス"
    },
    {
      "indent": 0,
      "text": "Normative References",
      "ja": "引用規格"
    },
    {
      "indent": 3,
      "text": "[ITU32] \"ITU-T Recommendation V.42, \"Error-correcting procedures for DCEs using asynchronous-to-synchronous conversion\".\", ITU-T section 8.1.1.6.2.",
      "ja": "[ITU32]非同期に同期変換を使用してのDCEは、 \"ITU-T勧告V.42、 \"エラー訂正手順\"。\"、ITU-Tセクション8.1.1.6.2。"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[RFC0768]ポステル、J.、 \"ユーザ・データグラム・プロトコル\"、STD 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC0793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122]ブレーデン、R.、エド、 \"インターネットホストのための要件 - 通信層\"。、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1123] Braden, R., Ed., \"Requirements for Internet Hosts - Application and Support\", STD 3, RFC 1123, October 1989.",
      "ja": "[RFC1123]ブレーデン、R.、エド、 \"インターネットホストのための要件 - 、アプリケーションとサポート\"。、STD 3、RFC 1123、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191]ムガール人、J.とS.デアリング、 \"パスMTUディスカバリ\"、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1981] McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, August 1996.",
      "ja": "[RFC1981]マッキャン、J.、デアリング、S.、およびJ.ムガール人、RFC 1981、1996年8月 \"IPバージョン6のパスMTUディスカバリー\"。"
    },
    {
      "indent": 3,
      "text": "[RFC1982] Elz, R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982, August 1996.",
      "ja": "[RFC1982]エルツ、R.とR.ブッシュ大統領、 \"シリアル番号演算\"、RFC 1982、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] Allman, M., Paxson, V., and W. Stevens, \"TCP Congestion Control\", RFC 2581, April 1999.",
      "ja": "[RFC2581]オールマン、M.、パクソン、V.、およびW.スティーブンス、 \"TCP輻輳制御\"、RFC 2581、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3873] Pastor, J. and M. Belinchon, \"Stream Control Transmission Protocol (SCTP) Management Information Base (MIB)\", RFC 3873, September 2004.",
      "ja": "[RFC3873]牧師、J.とM. Belinchon、 \"ストリーム制御伝送プロトコル（SCTP）管理情報ベース（MIB）\"、RFC 3873、2004年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4291] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 4291, February 2006.",
      "ja": "[RFC4291] HindenとR.とS.デアリング、 \"IPバージョン6アドレッシング体系\"、RFC 4291、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[RFC4303]ケント、S.、 \"IPカプセル化セキュリティペイロード（ESP）\"、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4306] Kaufman, C., Ed., \"Internet Key Exchange (IKEv2) Protocol\", RFC 4306, December 2005.",
      "ja": "[RFC4306]カウフマン、C.、エド。、 \"インターネットキーエクスチェンジ（IKEv2の）プロトコル\"、RFC 4306、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, March 2007.",
      "ja": "[RFC4821]マシス、M.とJ. Heffner、 \"パケット化レイヤのパスMTUディスカバリ\"、RFC 4821、2007年3月。"
    },
    {
      "indent": 0,
      "text": "Informative References",
      "ja": "参考文献"
    },
    {
      "indent": 3,
      "text": "[FALL96] Fall, K. and S. Floyd, \"Simulation-based Comparisons of Tahoe, Reno, and SACK TCP\", SIGCOMM'99 V. 26 N. 3 pp 5- 21, July 1996.",
      "ja": "【FALL96]秋、K.およびS.フロイド、 \"タホ、リノ、およびSACK TCPのシミュレーションベースの比較\"、SIGCOMM'99 V. 26 N. 3頁5 21 1996年7月。"
    },
    {
      "indent": 3,
      "text": "[SAVAGE99] Savage, S., Cardwell, N., Wetherall, D., and T. Anderson, \"TCP Congestion Control with a Misbehaving Receiver\", ACM Computer Communications Review 29(5), October 1999.",
      "ja": "[SAVAGE99]サベージ、S.、カードウェル、N.、Wetherall、D.、およびT.アンダーソン、 \"ふらちなレシーバーとのTCP輻輳制御\"、ACMコンピュータコミュニケーションレビュー29（5）、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[ALLMAN99] Allman, M. and V. Paxson, \"On Estimating End-to-End Network Path Properties\", SIGCOMM'99 , 1999.",
      "ja": "「エンドツーエンドのネットワークパスのプロパティの推定について」[ALLMAN99]オールマン、M.およびV.パクソン、SIGCOMM'99、1999。"
    },
    {
      "indent": 3,
      "text": "[WILLIAMS93] Williams, R., \"A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS\", Internet publication, http://www.geocities.com/SiliconValley/Pines/ 8659/crc.htm, August 1993.",
      "ja": "[WILLIAMS93]ウィリアムズ、R.、インターネット出版 \"CRCエラー検出アルゴリズム無痛ガイド\"、http://www.geocities.com/SiliconValley/Pines/ 8659 / crc.htm、1993年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0813] Clark, D., \"Window and Acknowledgement Strategy in TCP\", RFC 813, July 1982.",
      "ja": "[RFC0813]クラーク、D.、 \"ウィンドウとTCPで謝辞戦略\"、RFC 813、1982年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC1858] Ziemba, G., Reed, D., and P. Traina, \"Security Considerations for IP Fragment Filtering\", RFC 1858, October 1995.",
      "ja": "[RFC1858] Ziemba、G.、リード、D.、およびP. Trainaの、 \"IPフラグメントフィルタリングのためのセキュリティの考慮事項\"、RFC 1858、1995年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2196] Fraser, B., \"Site Security Handbook\", FYI 8, RFC 2196, September 1997.",
      "ja": "[RFC2196]フレイザー、B.、 \"サイトセキュリティハンドブック\"、FYI 8、RFC 2196、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2522] Karn, P. and W. Simpson, \"Photuris: Session-Key Management Protocol\", RFC 2522, March 1999.",
      "ja": "[RFC2522]カーン、P.とW.シンプソン、 \"Photuris：セッション鍵管理プロトコル\"、RFC 2522、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2960] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L., and V. Paxson, \"Stream Control Transmission Protocol\", RFC 2960, October 2000.",
      "ja": "[RFC2960]スチュワート、R.、謝、Q.、Morneault、K.、シャープ、C.、Schwarzbauer、H.、テイラー、T.、Rytina、I.、カラ、M.、チャン、L.、およびV 。パクソン、 \"ストリーム制御伝送プロトコル\"、RFC 2960、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC3309] Stone, J., Stewart, R., and D. Otis, \"Stream Control Transmission Protocol (SCTP) Checksum Change\", RFC 3309, September 2002.",
      "ja": "[RFC3309]石、J.、スチュワート、R.、およびD.オーティス、 \"ストリーム制御伝送プロトコル（SCTP）チェックサムの変更\"、RFC 3309、2002年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, September 2001.",
      "ja": "\"IPに明示的輻輳通知の添加（ECN）\" [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、3、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4460] Stewart, R., Arias-Rodriguez, I., Poon, K., Caro, A., and M. Tuexen, \"Stream Control Transmission Protocol (SCTP) Specification Errata and Issues\", RFC 4460, April 2006.",
      "ja": "[RFC4460]スチュワート、R.、アリアス - ロドリゲス、I.、プーン、K.、カロ、A.、およびM. Tuexen、 \"ストリーム制御伝送プロトコル（SCTP）仕様正誤表と課題\"、RFC 4460、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4895] Tuexen, M., Stewart, R., Lei, P., and E. Rescorla, \"Authenticated Chunks for Stream Control Transmission Protocol (SCTP)\", RFC 4895, August 2007.",
      "ja": "[RFC4895] Tuexen、M.、スチュワート、R.、レイ、P.、およびE.レスコラ、RFC 4895、2007年8月、 \"ストリーム制御伝送プロトコル（SCTP）に対して認証チャンク\"。"
    },
    {
      "indent": 0,
      "text": "Editor's Address",
      "ja": "編集者の住所"
    },
    {
      "indent": 3,
      "text": "Randall R. Stewart 4875 Forest Drive Suite 200 Columbia, SC 29206 US",
      "ja": "ランドールR.スチュワート4875森ドライブスイート200コロンビア、SC 29206米国"
    },
    {
      "indent": 3,
      "text": "EMail: rrs@cisco.com",
      "ja": "メールアドレス：rrs@cisco.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "著作権（C）IETFトラスト（2007）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットSOCIETY、（もしあれば）を後援し、IETF TRUST ANDインターネットエンジニアリングタスクフォース放棄ALLに設けられています。保証は、明示または黙示、この情報の利用および特定目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証がこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    }
  ]
}