{
  "title": {
    "text": "RFC 4465 - Signaling Compression (SigComp) Torture Tests",
    "ja": "RFC 4465 - シグナリング圧縮（SigCompの）拷問テスト"
  },
  "number": 4465,
  "created_at": "2019-10-25 11:21:34.676947+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         A. Surtees\nRequest for Comments: 4465                                       M. West\nCategory: Informational                      Siemens/Roke Manor Research\n                                                               June 2006",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Signaling Compression (SigComp) Torture Tests",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document provides a set of \"torture tests\" for implementers of the Signaling Compression (SigComp) protocol. The torture tests check each of the SigComp Universal Decompressor Virtual Machine instructions in turn, focusing in particular on the boundary and error cases that are not generally encountered when running well-behaved compression algorithms. Tests are also provided for other SigComp entities such as the dispatcher and the state handler.",
      "ja": "この文書では、シグナリング圧縮（SigCompの）プロトコルの実装のための「拷問テスト」のセットを提供します。拷問テストは行儀の圧縮アルゴリズムを実行するとき、一般的に遭遇されていない境界およびエラーの場合に特に焦点を当て、順番にSigCompのユニバーサルデコンプレッサ仮想マシン命令のそれぞれを確認してください。テストはまた、ディスパッチャや状態ハンドラとして他のSigCompエンティティのために提供されています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Torture Tests for UDVM ..........................................4\n   2.1. Bit Manipulation ...........................................4\n   2.2. Arithmetic .................................................5\n   2.3. Sorting ....................................................7\n   2.4. SHA-1 ......................................................8\n   2.5. LOAD and MULTILOAD .........................................9\n   2.6. COPY ......................................................11\n   2.7. COPY-LITERAL and COPY-OFFSET ..............................12\n   2.8. MEMSET ....................................................14\n   2.9. CRC .......................................................15\n   2.10. INPUT-BITS ...............................................16\n   2.11. INPUT-HUFFMAN ............................................17\n   2.12. INPUT-BYTES ..............................................19\n   2.13. Stack Manipulation .......................................20\n   2.14. Program Flow .............................................22\n   2.15. State Creation ...........................................23\n   2.16. STATE-ACCESS .............................................26\n3. Torture Tests for Dispatcher ...................................28\n   3.1. Useful Values .............................................28\n   3.2. Cycles Checking ...........................................31\n   3.3. Message-based Transport ...................................32\n   3.4. Stream-based Transport ....................................34\n   3.5. Input Past the End of a Message ...........................36\n4. Torture Tests for State Handler ................................38\n   4.1. SigComp Feedback Mechanism ................................38\n   4.2. State Memory Management ...................................41\n   4.3. Multiple Compartments .....................................44\n   4.4. Accessing RFC 3485 State ..................................49\n   4.5. Bytecode State Creation ...................................50\n5. Security Considerations ........................................53\n6. Acknowledgements ...............................................53\n7. Normative References ...........................................53\nAppendix A.  UDVM Bytecode for the Torture Tests ..................54\n   A.1. Instructions ..............................................54\n        A.1.1. Bit Manipulation ...................................54\n        A.1.2. Arithmetic .........................................55\n        A.1.3. Sorting ............................................55\n        A.1.4. SHA-1 ..............................................56\n        A.1.5. LOAD and MULTILOAD .................................56\n        A.1.6. COPY ...............................................56\n        A.1.7. COPY-LITERAL and COPY-OFFSET .......................57\n        A.1.8. MEMSET .............................................57\n        A.1.9. CRC ................................................57\n        A.1.10. INPUT-BITS ........................................57\n        A.1.11. INPUT-HUFFMAN .....................................58",
      "raw": true
    },
    {
      "indent": 6,
      "text": "     A.1.12. INPUT-BYTES .......................................58\n     A.1.13. Stack Manipulation ................................58\n     A.1.14. Program Flow ......................................59\n     A.1.15. State Creation ....................................59\n     A.1.16. STATE-ACCESS ......................................60\nA.2. Dispatcher Tests ..........................................61\n     A.2.1. Useful Values ......................................61\n     A.2.2. Cycles Checking  ...................................62\n     A.2.3. Message-based Transport ............................62\n     A.2.4. Stream-based Transport .............................62\n     A.2.5. Input Past the End of a Message ....................63\nA.3. State Handler Tests .......................................64\n     A.3.1. SigComp Feedback Mechanism .........................64\n     A.3.2. State Memory Management ............................64\n     A.3.3. Multiple Compartments ..............................65\n     A.3.4. Accessing RFC 3485 State ...........................66\n     A.3.5. Bytecode State Creation ............................66",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document provides a set of \"torture tests\" for implementers of the SigComp protocol, RFC 3320 [2]. The idea behind SigComp is to standardize a Universal Decompressor Virtual Machine (UDVM) that can be programmed to understand the output of many well-known compressors including DEFLATE and LZW. The bytecode for the chosen decompressor is uploaded to the UDVM as part of the SigComp message flow.",
      "ja": "この文書では、[2]のSigCompプロトコル、RFC 3320の実装は、「拷問テスト」のセットを提供します。 SigCompの背後にある考え方は、DEFLATEとLZWなど、多くのよく知られているコンプレッサーの出力を理解するようにプログラムすることができるユニバーサルデコンプレッサ仮想マシン（UDVM）を標準化することです。選択されたデコンプレッサのためのバイトコードは、のSigCompメッセージフローの一部としてUDVMにアップロードされます。"
    },
    {
      "indent": 3,
      "text": "The SigComp User's Guide [1] gives examples of a number of different algorithms that can be used by the SigComp protocol. However, the bytecode for the corresponding decompressors is relatively well behaved and does not test the boundary and error cases that may potentially be exploited by malicious SigComp messages.",
      "ja": "SigCompのユーザーズガイド[1]のSigCompプロトコルによって使用することができる異なるアルゴリズムの多数の例を与えます。ただし、対応する圧縮解除のためのバイトコードは、比較的行儀され、潜在的に悪質なのSigCompメッセージによって悪用される境界とエラーケースをテストするものではありません。"
    },
    {
      "indent": 3,
      "text": "This document is divided into a number of sections, each containing a piece of code designed to test a particular function of one of the SigComp entities (UDVM, dispatcher, and state handler). The specific boundary and error cases tested by the bytecode are also listed, as are the output the code should produce and the number of UDVM cycles that should be used.",
      "ja": "この文書は、それぞれがSigCompのエンティティ（UDVM、ディスパッチャ、および状態ハンドラ）のいずれかの特定の機能をテストするために設計されたコードの一部を含む、セクションの数に分割されます。コードが生成すべき出力と使用されるべきであるUDVMサイクルの数であるとして、バイトコードによって試験特定の境界とエラー場合も、記載されています。"
    },
    {
      "indent": 3,
      "text": "Each test runs in the SigComp minimum decompression memory size (that is, 2K), within the minimum number of cycles per bit (that is, 16) and in tests where state is stored 2K state memory size is needed.",
      "ja": "各試験は、ビット当たりの最小サイクル数（すなわち16）内に状態が2K状態メモリサイズが必要とされる格納されている試験で、（すなわち、2Kである）のSigComp最小減圧メモリサイズで実行されます。"
    },
    {
      "indent": 0,
      "text": "2. Torture Tests for UDVM",
      "section_title": true,
      "ja": "UDVM 2.拷問テスト"
    },
    {
      "indent": 3,
      "text": "The following sections each provide code to test one or more UDVM instructions. In the interests of readability, the code is given using the SigComp assembly language: a description of how to convert this assembly code into UDVM bytecode can be found in the SigComp User's Guide [1].",
      "ja": "以下のセクションでは、各コードが1つまたは複数のUDVMインストラクションをテストするために提供します。可読性の利益では、コードはSigCompのアセンブリ言語を使用して与えられます。UDVMバイトコードに、このアセンブリコードを変換する方法の説明はSigCompのユーザーズガイドに記載されています[1]。"
    },
    {
      "indent": 3,
      "text": "The raw UDVM bytecode for each torture test is given in Appendix A.",
      "ja": "各拷問テストのための生のUDVMバイトコードは、付録Aに記載されています"
    },
    {
      "indent": 3,
      "text": "Each section also lists the number of UDVM cycles required to execute the code. Note that this figure only takes into account the cost of executing each UDVM instruction (in particular, it ignores the fact that the UDVM can gain extra cycles as a result of inputting more data).",
      "ja": "各セクションには、コードを実行するために必要なUDVMサイクルの数を示しています。この図は、唯一のアカウントに（特に、それはUDVMは、より多くのデータを入力した結果として、余分なサイクルを得ることができるという事実を無視して）各UDVM命令を実行するコストを要することに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "2.1. Bit Manipulation",
      "section_title": true,
      "ja": "2.1。ビット操作"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the AND, OR, NOT, LSHIFT, and RSHIFT instructions. When the instructions have a multitype operand, the code tests the case where the multitype contains a fixed integer value, and the case where it contains a memory address at which the 2-byte operand value can be found. In addition, the code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、AND、OR、NOT、LSHIFT、およびRSHIFT命令をテストするためのアセンブリコードを示します。命令は、マルチタイプのオペランドを有する場合、コードは、マルチタイプは、固定の整数値が含まれている場合をテストし、それが2バイトのオペランドの値を見つけることが可能なメモリアドレスを含む場合。また、コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The instructions overwrite themselves with the result of the bit manipulation operation, in which case execution continues normally.",
      "ja": "1.命令は、ケースの実行が正常に連続するビット操作演算の結果で自身を上書き。"
    },
    {
      "indent": 3,
      "text": "2. The LSHIFT or RSHIFT instructions shift bits beyond the 2-byte boundary, in which case the bits must be discarded.",
      "ja": "2. LSHIFTまたはRSHIFT命令はビットを破棄しなければならない場合に、2バイト境界を超えてビットをシフトします。"
    },
    {
      "indent": 3,
      "text": "3. The UDVM registers byte_copy_left and byte_copy_right are used to store the results of the bit manipulation operations. Since no byte copying is taking place, these registers should behave in exactly the same manner as ordinary UDVM memory addresses.",
      "ja": "3. UDVMはbyte_copy_left登録しbyte_copy_rightは、ビット操作オペレーションの結果を格納するために使用されます。何バイトのコピーは行われていないので、これらのレジスタは、通常のUDVMメモリアドレスとまったく同じように振る舞うべきです。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":a pad (2) :b pad (2)",
      "ja": "：パッド（2）：Bのパッド（2）"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "JUMP (start) ; Jump to address 255",
      "ja": "ジャンプスタート） ; 255に対応するためにジャンプ"
    },
    {
      "indent": 3,
      "text": "at (255)",
      "ja": "で（255）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：開始"
    },
    {
      "indent": 3,
      "text": "; The multitypes are values ; $start = 448 (first 2 bytes of AND instr) AND ($start, 21845) ; 448 & 21845 = 320 = 0x0140 OR ($a, 42) ; 0 | 42 = 42 = 0x002a NOT ($b) ; ~0 = 65535 = 0xffff LSHIFT ($a, 3) ; 42 << 3 = 336 = 0x0150 RSHIFT ($b, 65535) ; 65535 >> 65535 = 0 = 0x0000",
      "ja": "; multitypesは値です。 $ = 448（第2のバイトINSTR）AND（$開始、21845）を起動します。 448＆21845 = 320 = 0x0140 OR（$ 42）。 0 | 42 = 42 = 0x002a NOT（$ B）; 〜0 = 65535 = 0xffffとLSHIFT（$、3）; 42 << 3 = 336 = 0x0150 RSHIFT（$ B、65535）。 65535 >> 65535 = 0 = 0000"
    },
    {
      "indent": 3,
      "text": "OUTPUT (64, 4) ; Output 0x0150 0000",
      "ja": "OUTPUT（64、4）。出力0x0150 0000"
    },
    {
      "indent": 3,
      "text": "; The multitypes are references",
      "ja": "; multitypesは言及されています"
    },
    {
      "indent": 3,
      "text": "AND ($a, $start) ; 336 & 320 = 320 = 0x0140 OR ($a, $a) ; 320 | 320 = 320 = 0x0140 NOT ($a) ; ~320 = 65215 = 0xfebf LSHIFT ($b, $a) ; 0 << 65215 = 0 = 0x0000 RSHIFT ($a, $b) ; 65215 >> 0 = 65215 = 0xfebf",
      "ja": "AND（$、$スタート）。 336＆320 = 320 = 0x0140 OR（$、$ A）。 320 | 320 = 320 = 0x0140 NOT（$ A）。 〜320 = 65215 = 0xfebf LSHIFT（$ Bは、$ A）。 0 << 65215 = 0 = 0000 RSHIFT（$、$ b）は、 65215 >> 0 = 65215 = 0xfebf"
    },
    {
      "indent": 3,
      "text": "OUTPUT (64, 4) ; Output 0xfebf 0000",
      "ja": "OUTPUT（64、4）。 0000 0xfebf出力"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x0150 0000 febf 0000. Executing the code costs a total of 22 UDVM cycles.",
      "ja": "コードの出力は、コードを実行する0x0150 0000 febf 0000 22 UDVMサイクルの総コストです。"
    },
    {
      "indent": 0,
      "text": "2.2. Arithmetic",
      "section_title": true,
      "ja": "2.2。算術"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the ADD, SUBTRACT, MULTIPLY, DIVIDE, and REMAINDER instructions. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、ADD、減算、乗算、除算、剰余命令をテストするためのアセンブリコードを与えます。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The instructions overwrite themselves with the result of the arithmetic operation, resulting in continuation as if the bytes were not bytecode.",
      "ja": "1.命令はバイトは、バイトコードではなかったかのように連続して得られた、算術演算の結果で自身を上書き。"
    },
    {
      "indent": 3,
      "text": "2. The result does not lie between 0 and 2^16 - 1 inclusive, in which case it must be taken modulo 2^16.",
      "ja": "それは2 ^ 16を法として取らなければならない場合には、1包括 -  2.結果は0から2 ^ 16との間に存在しません。"
    },
    {
      "indent": 3,
      "text": "3. The divisor in the DIVIDE or REMAINDER instructions is 0 (in which case decompression failure must occur).",
      "ja": "3. DIVIDE又はREMAINDER命令における除数は（この場合、解凍の失敗が発生しなければならない）、0です。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":a pad (2) :b pad (2) :type pad (1) :type_lsb pad (1)",
      "ja": "：パッド（2）：Bのパッド（2）：型パッド（1）：type_lsbパッド（1）"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, type_lsb, decomp_failure) SUBTRACT ($type, 1) JUMP (start) :decomp_failure DECOMPRESSION-FAILURE",
      "ja": "INPUT-BYTES（1、type_lsb、decomp_failure）SUBTRACT（$タイプ、1）JUMP（開始）：decomp_failure解凍-FAILURE"
    },
    {
      "indent": 3,
      "text": "; Now the value in $type should be 0xffff, 0x0000, or 0x0001 ; according to whether the input was 0x00, 0x01, or 0x02.",
      "ja": ";今$タイプの値は0xFFFFで、0000、または0x0001にする必要があります。入力が0x00で、0×01、または0×02であったかどうかに記載の方法。"
    },
    {
      "indent": 3,
      "text": "at (255)",
      "ja": "で（255）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：開始"
    },
    {
      "indent": 3,
      "text": "; The multitypes are values ; For all three messages ; $start = 1728 (first 2 bytes of ADD instr) ADD ($start, 63809) ; 1728 + 63809 = 1 = 0x0001 SUBTRACT ($a, 1) ; 0 - 1 = 65535 = 0xffff MULTIPLY ($a, 1001) ; 65535 * 1001 = 64535 = 0xfc17 DIVIDE ($a, 101) ; 64535 / 101 = 638 = 0x027e REMAINDER ($a, 11) ; 638 % 11 = 0 = 0x0000",
      "ja": "; multitypesは値です。すべての3つのメッセージのために。 $ = 1728（ADDのINSTRの最初の2バイト）を追加（$開始、63809）を起動します。 1728 + 63809 = 1 = 0x0001のSUBTRACT（$ 1）。 、0  -  1 = 65535 = 0xFFFFのMULTIPLY（$ 1001）。 65535 * 1001 = 64535 = 0xfc17 DIVIDE（$、101）; 64535/101 = 638 = 0x027e余り（$ 11）。 638パーセント11 = 0 = 0000"
    },
    {
      "indent": 3,
      "text": "OUTPUT (64, 4) ; output 0x0000 0000",
      "ja": "OUTPUT（64、4）。出力0000 0000"
    },
    {
      "indent": 3,
      "text": "; The multitypes are references ADD ($b, $start) ; 0 + 1 = 1 = 0x0001 ; If the message is 0x00 SUBTRACT ($b, $type) ; 1 - 65535 = 2 = 0x0002 MULTIPLY ($b, $b) ; 2 * 2 = 4 = 0x0004 DIVIDE ($a, $b) ; 0 / 4 = 0 = 0x0000 REMAINDER ($b, $type) ; 4 % 65535 = 4 = 0x0004",
      "ja": "; multitypesは、参照は（$ bの、$ start）を追加しています。 0 + 1 = 1 = 0x0001の、メッセージには、0x00のSUBTRACT（$ B、$型）である場合には、 1から65535 = 2 = 0×0002 MULTIPLY（$ Bと$ b）は、 2×2 = 4 = 0x0004はDIVIDE（$、$ b）は、 0/4 = 0 = 0000余り（$ B、$型）。 4％65535 = 4 = 0x0004は"
    },
    {
      "indent": 3,
      "text": "OUTPUT (64, 4) ; output 0x0000 0004",
      "ja": "OUTPUT（64、4）。出力0000 0004"
    },
    {
      "indent": 27,
      "text": "; If the message is 0x01, $type = 0\n; so decompression failure occurs at\n; REMAINDER ($b, $type)",
      "raw": true
    },
    {
      "indent": 27,
      "text": "; If the message is 0x02, $type = 1 so ; $b becomes 0 and decompression failure ; occurs at DIVIDE ($a, $b)",
      "ja": ";メッセージが0x02である場合は、$タイプ= 1そう。 $ bは0と減圧失敗となり、 DIVIDEで発生（$、$ b）は"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "If the compressed message is 0x00, then the output of the code is 0x0000 0000 0000 0004 and the execution cost should be 25 UDVM cycles. However, if the compressed message is 0x01 or 0x02, then decompression failure occurs.",
      "ja": "圧縮されたメッセージが0x00である場合、コードの出力は、0000 0000 0000 0004で、実行コストは25回のUDVMサイクルであるべきです。圧縮されたメッセージは、0x01のまたは0x02である場合は、その後減圧障害が発生します。"
    },
    {
      "indent": 0,
      "text": "2.3. Sorting",
      "section_title": true,
      "ja": "2.3。整理"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the SORT-ASCENDING and SORT-DESCENDING instructions. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、SORT-昇順とSORT-DESCENDING命令をテストするためにアセンブリコードを与えます。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The sorting instructions sort integers with the same value, in which case the original ordering of the integers must be preserved.",
      "ja": "1.ソート命令は、整数の元の順序が保存されている必要があり、その場合には同じ値を持つ整数を並べ替えます。"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "SORT-DESCENDING (256, 2, 23) SORT-ASCENDING (256, 2, 23)",
      "ja": "SORT-降順（256、2、23）SORT-昇順（256、2、23）"
    },
    {
      "indent": 3,
      "text": "OUTPUT (302, 45) END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "OUTPUT（302、45）END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "at (256)",
      "ja": "で（256）"
    },
    {
      "indent": 3,
      "text": "word (10, 10, 17, 7, 22, 3, 3, 3, 19, 1, 16, 14, 8, 2, 13, 20, 18, 23, 15, 21, 12, 6, 9)",
      "ja": "ワード（10、10、17、7、22、3、3、3、19、1、16、14、8、2、13、20、18、23、15、21、12、6、9）"
    },
    {
      "indent": 3,
      "text": "word (28263, 8297, 30057, 8308, 26996, 11296, 31087, 29991, 8275, 18031, 28263, 24864, 30066, 29284, 28448, 29807, 28206, 11776, 28773, 28704, 28276, 29285, 28265)",
      "ja": "ワード（28263、8297、30057、8308、26996、11296、31087、29991、8275、18031、28263、24864、30066、29284、28448、29807、28206、11776、28773、28704、28276、29285、28265）"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x466f 7264 2c20 796f 7527 7265 2074 7572 6e69 6e67 2069 6e74 6f20 6120 7065 6e67 7569 6e2e 2053 746f 7020 6974 2e, and the number of cycles required is 371.",
      "ja": "コードの出力は0x466f 7264 2c20 796f 7527 7265 2074 7572 6e69 6e67 2069 6e74 6f20 6120 7065 6e67 7569 6e2e 2053 7020 6974 2E 746fであり、必要なサイクル数は371です。"
    },
    {
      "indent": 0,
      "text": "2.4. SHA-1",
      "section_title": true,
      "ja": "２。４。 しゃー１"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the SHA-1 instruction. The code performs four tests on the SHA-1 algorithm itself and, in addition, checks the following boundary cases specific to the UDVM:",
      "ja": "このセクションでは、SHA-1命令をテストするためのアセンブリコードを与えます。コードは、SHA-1アルゴリズム自体に4つのテストを実行し、加えて、UDVMに特異以下境界ケースをチェックします。"
    },
    {
      "indent": 3,
      "text": "1. The input string for the SHA-1 hash is obtained by byte copying over an area of the UDVM memory.",
      "ja": "1 SHA-1ハッシュの入力文字列がUDVMメモリの領域上にバイトをコピーすることによって得られます。"
    },
    {
      "indent": 3,
      "text": "2. The SHA-1 hash overwrites its own input string.",
      "section_title": true,
      "ja": "2. SHA-1ハッシュは、それ自体の入力文字列を上書きします。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :hash_value pad (20)",
      "ja": "：パッドbyte_copy_left（2）：byte_copy_rightパッド（2）：HASH_VALUEパッド（20）"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "SHA-1 (test_one, 3, hash_value) OUTPUT (hash_value, 20)",
      "ja": "SHA-1（test_one、3、HASH_VALUE）OUTPUT（HASH_VALUE、20）"
    },
    {
      "indent": 3,
      "text": "SHA-1 (test_two, 56, hash_value) OUTPUT (hash_value, 20)",
      "ja": "SHA-1（test_two、56、HASH_VALUE）OUTPUT（HASH_VALUE、20）"
    },
    {
      "indent": 3,
      "text": "; Set up a 1-byte buffer LOAD (byte_copy_left, test_three) LOAD (byte_copy_right, test_four)",
      "ja": "; 1バイトのバッファの負荷を設定する（byte_copy_left、test_three）LOAD（byte_copy_right、test_four）"
    },
    {
      "indent": 3,
      "text": "; Perform SHA-1 over 16384 bytes in a 1-byte buffer SHA-1 (test_three, 16384, hash_value) OUTPUT (hash_value, 20)",
      "ja": "; 1のByteBufferのSHA1で16384バイト（テスト3、16384、HASH_VALUE）OUTPUT上SHA1を行う（HASH_VALUE、20）"
    },
    {
      "indent": 3,
      "text": "; Set up an 8-byte buffer LOAD (byte_copy_left, test_four) LOAD (byte_copy_right, test_end)",
      "ja": "; 8バイトのバッファの負荷を設定する（byte_copy_left、test_four）LOAD（byte_copy_right、test_end）"
    },
    {
      "indent": 3,
      "text": "; Perform SHA-1 over 640 bytes in an 8-byte buffer SHA-1 (test_four, 640, test_four) OUTPUT (test_four, 20)",
      "ja": "; 8バイトのバッファSHA-1（test_four、640、test_four）OUTPUTにSHA-1 640バイト以上を行う（test_four、20）"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":test_one",
      "ja": "：test_one"
    },
    {
      "indent": 3,
      "text": "byte (97, 98, 99)",
      "ja": "バイト（97、98、99）"
    },
    {
      "indent": 3,
      "text": ":test_two byte (97, 98, 99, 100, 98, 99, 100, 101, 99, 100, 101, 102, 100, 101, 102, 103, 101, 102, 103, 104, 102, 103, 104, 105, 103, 104, 105, 106, 104, 105, 106, 107, 105, 106, 107, 108, 106, 107, 108, 109, 107, 108, 109, 110, 108, 109, 110, 111, 109, 110, 111, 112, 110, 111, 112, 113)",
      "ja": "：test_twoバイト（97、98、99、100、98、99、100、101、99、100、101、102、100、101、102、103、101、102、103、104、102、103、104、 105、103、104、105、106、104、105、106、107、105、106、107、108、106、107、108、109、107、108、109、110、108、109、110、111、 109、110、111、112、110、111、112、113）"
    },
    {
      "indent": 3,
      "text": ":test_three",
      "ja": "：test_three"
    },
    {
      "indent": 3,
      "text": "byte (97)",
      "ja": "バイト（97）"
    },
    {
      "indent": 3,
      "text": ":test_four",
      "ja": "：test_four"
    },
    {
      "indent": 3,
      "text": "byte (48, 49, 50, 51, 52, 53, 54, 55)",
      "ja": "バイト（48、49、50、51、52、53、54、55）"
    },
    {
      "indent": 3,
      "text": ":test_end",
      "ja": "：test_end"
    },
    {
      "indent": 3,
      "text": "The output of the code is as follows:",
      "ja": "次のようにコードの出力は次のようになります。"
    },
    {
      "indent": 3,
      "text": "0xa999 3e36 4706 816a ba3e 2571 7850 c26c 9cd0 d89d 0x8498 3e44 1c3b d26e baae 4aa1 f951 29e5 e546 70f1 0x12ff 347b 4f27 d69e 1f32 8e6f 4b55 73e3 666e 122f 0x4f46 0452 ebb5 6393 4f46 0452 ebb5 6393 4f46 0452",
      "ja": "0xa999 3e36 4706 816A ba3e 2571 7850 c26c 9cd0 d89d 0x8498 3e44 1c3b d26e baae 4aa1 f951 29e5 e546 70f1 0x12ff 347B 4f27 d69e 1f32 8e6f 4b55 73e3 666e 122F 0x4f46 0452 ebb5 6393 4f46 0452 ebb5 6393 4f46 0452"
    },
    {
      "indent": 3,
      "text": "Executing the code costs a total of 17176 UDVM cycles.",
      "ja": "コードを実行すると、17176 UDVMサイクルの合計がかかります。"
    },
    {
      "indent": 0,
      "text": "2.5. LOAD and MULTILOAD",
      "section_title": true,
      "ja": "2.5。 LOADとMULTILOAD"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the LOAD and MULTILOAD instructions. The code is designed to test the following boundary cases:",
      "ja": "このセクションでは、LOADとMULTILOAD命令をテストするためにアセンブリコードを示します。コードは以下の境界例をテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The MULTILOAD instruction overwrites itself or any of its operands, in which case decompression failure occurs.",
      "ja": "1. MULTILOAD命令は、ケース伸張障害が発生した、それ自体またはそのオペランドのいずれかを上書き。"
    },
    {
      "indent": 3,
      "text": "2. The memory references of MULTILOAD instruction operands are evaluated step-by-step rather than all at once before starting to copy data.",
      "ja": "2. MULTILOAD命令のオペランドのメモリ参照は、データをコピーするために開始する前に、ステップバイステップではなく、一度にすべてを評価されます。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":start pad (1) :start_lsb pad (1)",
      "ja": "：start_lsbパッド（1）：パッド（1）開始します"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "set (location_a, 128) set (location_b, 132)",
      "ja": "セット（location_a、128）を設定（location_b、132）"
    },
    {
      "indent": 3,
      "text": "LOAD (128, 132) ; address 128 contains 132 = 0x0084 LOAD (130, $location_a) ; address 130 contains 132 = 0x0084 LOAD ($location_a, 134) ; address 132 contains 134 = 0x0086 LOAD ($location_b, $location_b) ; address 134 contains 134 = 0x0086 OUTPUT (128, 8) ; output 0x0084 0084 0086 0086",
      "ja": "LOAD（128、132）。 128 132 = 0x0084負荷（130、$のlocation_a）を含むアドレス。 130は132 = 0x0084のLOAD（$のlocation_a、134）を含むアドレス。 132は134 = 0x0086のLOADを（$ location_b、$ location_b）が含まれてい取り組みます。 134は134 = 0x0086出力（128 8）を含むアドレス。出力0x0084 0084 0086 0086"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, start_lsb, decompression_failure) MULTIPLY ($start, 2) ADD ($start, 60) MULTILOAD ($start, 3, overlap_start, overlap_end, 128)",
      "ja": "INPUTバイト（1、start_lsb、decompression_failure）MULTIPLYは、（$開始、2）（$開始60）MULTILOAD（$開始、3、overlap_start、overlap_end、128）を追加"
    },
    {
      "indent": 3,
      "text": ":position",
      "ja": "：ポジション"
    },
    {
      "indent": 3,
      "text": "set (overlap_start, (position - 7))",
      "ja": "セット（overlap_start、（位置 -  7））"
    },
    {
      "indent": 3,
      "text": "MULTILOAD ($start, 4, 42, 128, $location_a, $location_b)",
      "ja": "MULTILOAD（$開始、4、42、128、$ location_a、$ location_b）"
    },
    {
      "indent": 3,
      "text": ":end",
      "ja": "：終わり"
    },
    {
      "indent": 3,
      "text": "set (overlap_end, (end - 1))",
      "ja": "セット（overlap_end、（エンド -  1））"
    },
    {
      "indent": 3,
      "text": "OUTPUT (128, 8) END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "OUTPUT（128、8）END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":decompression_failure DECOMPRESSION-FAILURE",
      "ja": "：decompression_failure解凍-FAILURE"
    },
    {
      "indent": 3,
      "text": "The INPUT-BYTES, MULTIPLY, and ADD instructions give the following values for $start = $64 just before the MULTILOADs begin:",
      "ja": "INPUT-BYTES、MULTIPLY、およびADD命令は$のために以下の値がMULTILOADsが始まる直前に= $ 64開始与えます："
    },
    {
      "indent": 3,
      "text": "Input $start before 1st MULTILOAD 0x00 60 0x01 62 0x02 64",
      "ja": "入力$開始第一MULTILOADは0x00 60 0x01の62 0x02の64の前に"
    },
    {
      "indent": 3,
      "text": "Consequently, after the first MULTILOAD the values of $start are the following:",
      "ja": "その結果、第1 MULTILOAD後$開始の値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Input $start before 2nd MULTILOAD 0x00 128 0x01 overlap_end = 177 = last byte of 2nd MULTILOAD instruction 0x02 overlap_start = 162 = 7 bytes before 2nd MULTILOAD instruction",
      "ja": "第二MULTILOAD命令の第二MULTILOADは0x00 0x01の128 overlap_end = 177 =最後のバイト前に入力$開始0x02のoverlap_start = 162 =第二MULTILOAD命令の前に7つのバイト"
    },
    {
      "indent": 3,
      "text": "Consequently, execution of the 2nd MULTILOAD (and any remaining code) gives the following:",
      "ja": "これにより、第2 MULTILOADの実行（および任意の残りのコード）は以下を与えます："
    },
    {
      "indent": 3,
      "text": "Input Outcome 0x00 MULTILOAD reads and writes operand by operand. The output is 0x0084 0084 0086 0086 002a 0080 002a 002a, and the cost of executing the code is 36 UDVM cycles.",
      "ja": "入力転帰は0x00 MULTILOAD読み取りとオペランドでオペランドを書き込みます。出力は0x0084 0084 0086 0086 0080 002A 002A 002Aであり、コードの実行のコストは36回のUDVMサイクルです。"
    },
    {
      "indent": 3,
      "text": "0x01 The first write of the MULTILOAD instruction would overwrite the last byte of the final MULTILOAD operand, so decompression failure occurs.",
      "ja": "解凍障害が発生したので、0x01のMULTILOAD命令の最初の書き込みは、最終MULTILOADオペランドの最後のバイトを上書きします。"
    },
    {
      "indent": 3,
      "text": "0x02 The last write of the MULTILOAD would overwrite the MULTILOAD opcode, so decompression failure occurs.",
      "ja": "解凍障害が発生したので、0x02のMULTILOADの最後の書き込みは、MULTILOADオペコードを上書きします。"
    },
    {
      "indent": 0,
      "text": "2.6. COPY",
      "section_title": true,
      "ja": "2.6。 COPY"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the COPY instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、COPY命令をテストするためのアセンブリコードを示します。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The COPY instruction copies data from both outside the circular buffer and inside the circular buffer within the same operation.",
      "ja": "1.両方から循環バッファ外部と同じ操作内の循環バッファ内のCOPY命令データをコピーします。"
    },
    {
      "indent": 3,
      "text": "2. The COPY instruction performs byte-by-byte copying (i.e., some of the later bytes to be copied are themselves written into the UDVM memory by the COPY instruction currently being executed).",
      "ja": "2.コピー指示（すなわち、後バイトのいくつかは、自身が現在実行されているコピー命令によってUDVMメモリに書き込まれ、コピーされる）バイト単位でのコピーを行います。"
    },
    {
      "indent": 3,
      "text": "3. The COPY instruction overwrites itself and continues executing.",
      "section_title": true,
      "ja": "前記コピー命令は、それ自体を上書きし、実行を継続します。"
    },
    {
      "indent": 3,
      "text": "4. The COPY instruction overwrites the UDVM registers byte_copy_left and byte_copy_right.",
      "ja": "前記コピー命令は、UDVMはbyte_copy_leftとbyte_copy_right登録上書き。"
    },
    {
      "indent": 3,
      "text": "5. The COPY instruction writes to and reads from the right of the buffer beginning at byte_copy_right.",
      "ja": "5. COPY命令はに書き込み、byte_copy_rightから始まるバッファの右から読み込みます。"
    },
    {
      "indent": 3,
      "text": "6. The COPY instruction implements byte copying rules when the destination wraps around the buffer.",
      "ja": "宛先バッファの周りにラップするとき前記コピー命令は、バイトコピールールを実装します。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) at (128) ; Set up buffer between addresses 64 & 128 LOAD (32, 16384) LOAD (byte_copy_left, 64) LOAD (byte_copy_right, 128)",
      "ja": "：パッドbyte_copy_left（2）：（128）でbyte_copy_rightパッド（2）。設定アドレス64＆128負荷との間にバッファ（32、16384）LOAD（byte_copy_left、64）LOAD（byte_copy_right、128）"
    },
    {
      "indent": 3,
      "text": "COPY (32, 128, 33) ; Copy byte by byte starting to the left of ; the buffer, into the buffer and wrapping ; the buffer (inc overwriting the ; boundaries)",
      "ja": "COPY（32、128、33）。の左に開始バイト単位でコピーバイト。緩衝液および包装に緩衝液;バッファ（上書きINC。の境界）"
    },
    {
      "indent": 3,
      "text": "LOAD (64, 16640) ; Change the start of the buffer to be ; beyond bytecode",
      "ja": "LOAD（64、16640）。なるように、バッファの開始を変更します。バイトコードを越えて"
    },
    {
      "indent": 3,
      "text": "COPY (64, 85, 65) ; Copy to the left of the buffer, ; overwriting this instruction",
      "ja": "COPY（64、85、65）。バッファの左にコピーします。この命令を上書きします"
    },
    {
      "indent": 3,
      "text": "OUTPUT (32, 119) ; Output 32 * 0x40 + 86 * 0x41 + 0x55, ; which is 32 * '@' + 86 'A' + 'U'",
      "ja": "OUTPUT（32、119）。出力32 * 0x40の+ 86 * 0×41 + 0x55を、。 32 *である 'を@' + 86 '' + 'U'"
    },
    {
      "indent": 3,
      "text": " ; Set a new small buffer LOAD (byte_copy_left, 32) LOAD (byte_copy_right, 48)",
      "ja": ";新しい小さなバッファ負荷を設定（byte_copy_left、32）LOAD（byte_copy_right、48）"
    },
    {
      "indent": 3,
      "text": "MEMSET (32, 4, 65, 1) ; Set first 4 bytes of the buffer to be ; 'ABCD' COPY (32, 4, 48) ; Copy from byte_copy_right (i.e., not ; in buffer)",
      "ja": "memsetの（32、4、65、1）。ことがバッファの最初の4つのバイトを設定します。 'ABCD' COPY（32、4、48）。 byte_copy_rightからコピー（すなわち、ない;緩衝液中）"
    },
    {
      "indent": 3,
      "text": "OUTPUT (48, 4) ; Output 0x4142 4344, which is 'ABCD'",
      "ja": "OUTPUT（48、4）。 'ABCD' で出力0x4142 4344、"
    },
    {
      "indent": 3,
      "text": "COPY (48, 4, 46) ; Copy from two before byte_copy_right to ; wrap around the buffer OUTPUT (32, 2) ; Output 0x4344, which is 'CD'",
      "ja": "COPY（48、4、46）。 byte_copy_right前〜2からコピーします。バッファ出力（32、2）を包み込みます。 「CD」で出力0x4344、"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output is above, and executing the code costs a total of 365 UDVM cycles.",
      "ja": "出力は、上記され、そしてコードを実行すると、365 UDVMサイクルの総コスト。"
    },
    {
      "indent": 0,
      "text": "2.7. COPY-LITERAL and COPY-OFFSET",
      "section_title": true,
      "ja": "2.7。 COPYリテラルおよびCOPY-OFFSET"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the COPY-LITERAL and COPY-OFFSET instructions. The code is designed to test similar boundary cases to the code for the COPY instruction, as well as the following condition specific to COPY-LITERAL and COPY-OFFSET:",
      "ja": "このセクションでは、COPYリテラルおよびCOPYオフセット命令をテストするためにアセンブリコードを与えます。コードがコピー命令のためのコード、ならびにCOPYリテラルするとCOPYオフセット特異以下の条件と同様の境界ケースをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The COPY-LITERAL or COPY-OFFSET instruction overwrites the value of its destination.",
      "ja": "1. COPYリテラルまたはCOPYオフセット命令は、その先の値を上書きします。"
    },
    {
      "indent": 3,
      "text": "2. The COPY-OFFSET instruction reads from an offset that wraps around the buffer (i.e., the offset is larger than the distance between byte_copy_left and the destination).",
      "ja": "2. COPYオフセット命令（byte_copy_leftと宛先との間の距離よりも大きい、すなわち、オフセット）バッファを包み込むそのオフセットから読み出します。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :destination pad (2) :offset pad (2)",
      "ja": "：パッドbyte_copy_left（2）：byte_copy_rightパッド（2）：先のパッド（2）：オフセットパッド（2）"
    },
    {
      "indent": 3,
      "text": "at (128) ; Set up circular buffer, source, and ; destination LOAD (32, 16640) LOAD (byte_copy_left, 64) LOAD (byte_copy_right, 128) LOAD (destination, 33)",
      "ja": "（128）において、循環バッファ、ソースなどを設定します。先LOAD（32、16640）LOAD（byte_copy_left、64）LOAD（byte_copy_right、128）LOAD（宛先、33）"
    },
    {
      "indent": 3,
      "text": "COPY-LITERAL (32, 128, $destination) ; Copy from the left of the ; buffer overwriting bcl, bcr, and ; destination wrapping around the buffer OUTPUT (64, 8) ; Check destination has been updated ; Output 0x4141 4141 0061 4141",
      "ja": "COPYリテラル（32、128、$先）。の左からコピーします。バッファ上書きBCL、BCR、と。バッファ出力（64、8）周りに宛先ラッピング。先が更新されている確認してください。出力0x4141 4141 0061 4141"
    },
    {
      "indent": 3,
      "text": "LOAD (destination, copy)",
      "ja": "LOAD（宛先、コピー）"
    },
    {
      "indent": 3,
      "text": ":copy ; Overwrite the copy instruction COPY-LITERAL (32, 2, $destination) OUTPUT (copy, 2) ; Output 0x4141",
      "ja": "：コピー;コピー指示COPYリテラル（32、2、$宛先）出力を上書き（コピー、2）。出力0x4141"
    },
    {
      "indent": 3,
      "text": "LOAD (byte_copy_left, 72) ; Set up new circular buffer LOAD (byte_copy_right, 82) LOAD (destination, 82) ; Set destination to byte_copy_right",
      "ja": "LOAD（byte_copy_left、72）。新たな循環バッファLOAD（byte_copy_right、82）LOAD（宛先、82）を設定します。 byte_copy_rightに設定した目的地"
    },
    {
      "indent": 3,
      "text": "MEMSET (72, 10, 65, 1) ; Fill the buffer with 0x41 - 4A",
      "ja": "memsetの（72、10、65、1）。 0×41でバッファを満たす -  4Aを"
    },
    {
      "indent": 3,
      "text": "COPY-OFFSET (2, 6, $destination) ; Copy from within circular ; buffer to outside buffer",
      "ja": "COPYオフセット（2、6、$先）。円形内からコピーします。外のバッファにバッファ"
    },
    {
      "indent": 3,
      "text": "LOAD (offset, 6) COPY-OFFSET ($offset, 4, $destination) ; Copy from byte_copy_right ; so reading outside buffer",
      "ja": "LOAD COPYオフセット（$オフセット、4、$先）（6、オフセット）。 byte_copy_rightからコピーします。その外のバッファを読んで"
    },
    {
      "indent": 3,
      "text": "OUTPUT ($byte_copy_right, 10) ; Output 0x494A 4142 4344 494A 4142, ; which is 'IJABCDIJAB' LOAD (destination, 80) ; Put destination within the ; buffer COPY-OFFSET (4, 4, $destination) ; Copy where destination wraps OUTPUT (destination, 2) ; Output 0x004A",
      "ja": "OUTPUT（$ byte_copy_right、10）;出力0x494A 4142 4344 494A 4142;これ 'IJABCDIJAB' LOAD（宛先、80）です。内の宛先を置きます。バッファコピーオフセット（4、4、$先）。宛先出力ラップコピー（先、2）。出力0x004A"
    },
    {
      "indent": 3,
      "text": "COPY-OFFSET (5, 4, $destination) ; Copy where offset wraps from ; left back around to the right OUTPUT (destination, 2) ; Output 0x004E OUTPUT ($byte_copy_left, 10) ; Output the circular buffer ; 0x4748 4845 4647 4748 4546, ; which is 'GHHEFGGHEF'",
      "ja": "COPYオフセット（5、4、$先）。からラップオフセットコピー。右出力程度左後方（先、2）;出力0x004EのOUTPUT（$ byte_copy_left、10）;出力循環バッファ。 0x4748 4845 4647 4748 4546;これは「GHHEFGGHEF」です"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output of the code is above, and the cost of execution is 216 UDVM cycles.",
      "ja": "コードの出力は、上述され、実行のコストは216回のUDVMサイクルです。"
    },
    {
      "indent": 0,
      "text": "2.8. MEMSET",
      "section_title": true,
      "ja": "2.8。 memsetを"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the MEMSET instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、memsetの命令をテストするためのアセンブリコードを示します。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The MEMSET instruction overwrites the registers byte_copy_left and byte_copy_right.",
      "ja": "1. memsetの命令は、レジスタがbyte_copy_leftとbyte_copy_right上書き。"
    },
    {
      "indent": 3,
      "text": "2. The output values of the MEMSET instruction do not lie between 0 and 255 inclusive (in which case they must be taken modulo 2^8).",
      "ja": "2. memsetの命令の出力値が（それらがモジュロ2 ^ 8を取らなければならない場合）0〜255包括的にありません。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2)",
      "ja": "：パッドbyte_copy_left（2）：byte_copy_rightパッド（2）"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "LOAD (byte_copy_left, 128) ; sets up a circular buffer LOAD (byte_copy_right, 129) ; of 1 byte between 0x0080 and 0x0081",
      "ja": "LOAD（byte_copy_left、128）。循環バッファLOAD（byte_copy_right、129）を設定します。 0x0080と0x0081の間で1バイトの"
    },
    {
      "indent": 3,
      "text": "MEMSET (64, 129, 0, 1) ; fills up the memory in the range ; 0x0040-0x007f with 0x00, ... 0x3f; ; then it writes successively at ; 0x0080 the following values 0x40, ... 0x80 ; as a side effect, the values of ; bcl and bcr are modified.",
      "ja": "memsetの（64、129、0、1）。範囲内のメモリがいっぱいになります。 0x00ので0x0040-0x007f、... 0x3fを。 ;それはで連続的に書き込みます。 0x0080以下の値が0x40、0x80を...。副作用として、の値; BCLとBCRが変更されています。"
    },
    {
      "indent": 24,
      "text": "; before and during the MEMSET:\n; byte_copy_left: 0x0080 byte_copy_right: 0x0081\n; after the MEMSET:\n; byte_copy_left: 0x0001 byte_copy_right: 0x0203",
      "raw": true
    },
    {
      "indent": 3,
      "text": "MEMSET (129, 15, 64, 15) ; fills the memory range 0x0080-0x008f ; with values 0x40, 0x4f, ... 0xf4, 0x03, 0x12. ; as a side effect, it overwrites a ; part of the code including itself",
      "ja": "memsetの（129、15、64、15）。メモリ範囲0x0080-0x008fを満たします。値が0x40、0x4f、... 0xf4、0x03を、0x12を持ちます。 ;副作用として、それが上書き。自体を含むコードの一部"
    },
    {
      "indent": 3,
      "text": "OUTPUT (128, 16) ; outputs 0x8040 4f5e 6d7c 8b9a ; a9b8 c7d6 e5f4 0312",
      "ja": "OUTPUT（128、16）。出力0x8040 4f5e 6d7c 8b9a。 a9b8のc7d6のe5f4 0312"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x8040 4f5e 6d7c 8b9a a9b8 c7d6 e5f4 0312. Executing the code costs 166 UDVM cycles.",
      "ja": "コードの出力は、コードを実行する0x8040 4f5e 6d7c 8b9a a9b8 c7d6 e5f4 0312. 166 UDVMサイクルコストれます。"
    },
    {
      "indent": 0,
      "text": "2.9. CRC",
      "section_title": true,
      "ja": "2.9。 CRC"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the CRC instruction. The code does not test any specific boundary cases (as there do not appear to be any) but focuses instead on verifying the CRC algorithm.",
      "ja": "このセクションでは、CRC命令をテストするためにアセンブリコードを与えます。コードは（どのようにそこに表示されないように）任意の特定の境界の例をテストするが、CRCアルゴリズムを検証するには代わりに焦点を当てていません。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :crc_value pad (2) :crc_string_a pad (24) :crc_string_b pad (20)",
      "ja": "：パッドbyte_copy_left（2）：byte_copy_rightパッド（2）：crc_valueパッド（2）：crc_string_aパッド（24）：crc_string_bパッド（20）"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "MEMSET (crc_string_a, 24, 1, 1) ; sets up between 0x0046 and 0x005d ; a byte string containing 0x01, ; 0x02, ... 0x18",
      "ja": "memset（crc_string_a、24、1、1）。 0x0046と0x005dの間で設定します。 0x01のを、含むバイト文字列。 0x02の、... 0x18の"
    },
    {
      "indent": 3,
      "text": "MEMSET (crc_string_b, 20, 128, 1) ; sets up between 0x005e and 0x0071 ; a byte string containing 0x80, ; 0x81, ... 0x93",
      "ja": "memset（crc_string_b、20、128、1）。 0x005eと0x0071の間で設定します。 0x80とを、含むバイト文字列。 0x81と、... 0x93"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (2, crc_value, decompression_failure) ; reads in 2 bytes representing ; the CRC value of the byte string ; of 44 bytes starting at 0x0046",
      "ja": "INPUTバイト（2、crc_value、decompression_failure）。表す2つのバイトを読み込みます。バイト文字列のCRC値。 0x0046から始まる44バイトの"
    },
    {
      "indent": 3,
      "text": "CRC ($crc_value, crc_string_a, 44, decompression_failure) ; computes the CRC value of the ; byte string crc_string_a ; concatenated with byte string ; crc_string_b (with a total ; length of 44 bytes). ; if the computed value does ; not match the 2-byte value read ; previously, the program ends ; with DECOMPRESSION-FAILURE. END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "CRC（$のcrc_value、crc_string_a、44、decompression_failure）。のCRC値を計算します。バイト文字列crc_string_a。バイト文字列と連結。 （合計、44バイトの長さ）crc_string_b。 ;計算された値がない場合は、読んで2バイトの値と一致していません。以前、プログラムは終了します。圧縮解除-FAILUREと。 END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":decompression_failure DECOMPRESSION-FAILURE",
      "ja": "：decompression_failure解凍-FAILURE"
    },
    {
      "indent": 3,
      "text": "If the compressed message is 0x62cb, then the code should successfully terminate with no output, and with a total execution cost of 95 UDVM cycles. For different 2-byte compressed messages, the code should terminate with a decompression failure.",
      "ja": "圧縮されたメッセージが0x62cbである場合、コードが正常に出力なしで終了し、そして95 UDVMサイクルの総執行費用を有するべきです。異なる2バイトの圧縮されたメッセージの場合、コードは、解凍の失敗で終了しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.10. INPUT-BITS",
      "section_title": true,
      "ja": "2.10。 INPUT-BITS"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the INPUT-BITS instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、入力ビット命令をテストするためにアセンブリコードを与えます。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The INPUT-BITS instruction changes between any of the four possible bit orderings defined by the input_bit_order register.",
      "ja": "1.入力ビット命令はinput_bit_orderレジスタで定義された4つの可能なビット順序のいずれかの間で変化します。"
    },
    {
      "indent": 3,
      "text": "2. The INPUT-BITS instruction inputs 0 bits.",
      "section_title": true,
      "ja": "2.入力ビット命令入力0ビット。"
    },
    {
      "indent": 3,
      "text": "3. The INPUT-BITS instruction requests data that lies beyond the end of the compressed message.",
      "ja": "3. INPUT-BITS命令は、圧縮されたメッセージの終わりを超えてあるデータを要求します。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :input_bit_order pad (2) :result pad (2) at (128)",
      "ja": "：パッドbyte_copy_left（2）：byte_copy_rightパッド（2）：パッドinput_bit_order（2）：（128）での結果のパッド（2）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：開始"
    },
    {
      "indent": 3,
      "text": "INPUT-BITS ($input_bit_order, result, end_of_message) ; reads in ; exactly as many bits as the 2-byte ; value written in the input_bit_order ; register, get out of the loop when ; no more bits are available at input.",
      "ja": "INPUT-BITS（$のinput_bit_order、その結果、end_of_message）。で読み込みます。 2バイトとして正確に同じ数のビット。 input_bit_orderに書き込まれた値。登録、ときループから抜け出します。それ以上のビットが入力で利用可能でありません。"
    },
    {
      "indent": 3,
      "text": "OUTPUT (result, 2) ; outputs as a 2-byte integer ; the previously read bits",
      "ja": "OUTPUT（その2）。 2バイト整数として出力します。以前に読んビット"
    },
    {
      "indent": 3,
      "text": "ADD ($input_bit_order, 1) ; if at the beginning of this loop the ; register input_bit_order is 0, REMAINDER ($input_bit_order, 7) ; then its value varies periodically ; like this: 2, 4, 6, 1, 3, 5, 7. ADD ($input_bit_order, 1) ; that gives for the FHP bits: 010, ; 100, 110, 001, 011, 101, 111",
      "ja": "（$のinput_bit_order、1）を追加します。このループの最初であれば、登録input_bit_orderは0、REMAINDERである（$のinput_bit_order、7）;その値が周期的に変化します。このような：2、4、6、1、3、5、7 ADD（$のinput_bit_order、1）。それはFHPビットのために提供します：010; 100、110、001、011、101、111"
    },
    {
      "indent": 3,
      "text": "JUMP (start) ; run the loop once more",
      "ja": "ジャンプスタート） ;もう一度ループを実行します"
    },
    {
      "indent": 3,
      "text": ":end_of_message",
      "ja": "：end_of_message"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "An example of a compressed message is 0x932e ac71, which decompresses to give the output 0x0000 0002 0002 0013 0000 0003 001a 0038. Executing the code costs 66 UDVM cycles.",
      "ja": "圧縮されたメッセージの例は、コードを実行し、出力0000を0002 0002 0013 0000 0003 001A 0038.を与える伸張0x932e ac71は、66 UDVMサイクルコストれます。"
    },
    {
      "indent": 0,
      "text": "2.11. INPUT-HUFFMAN",
      "section_title": true,
      "ja": "2.11。 INPUT-HUFFMAN"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the INPUT-HUFFMAN instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、入力ハフマン指示をテストするためにアセンブリコードを与えます。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The INPUT-HUFFMAN instruction changes between any of the four possible bit orderings defined by the input_bit_order register.",
      "ja": "1. INPUT  - ハフマン指示はinput_bit_orderレジスタで定義された4つの可能なビット順序のいずれかの間で変化します。"
    },
    {
      "indent": 3,
      "text": "2. The INPUT-HUFFMAN instruction inputs 0 bits.",
      "section_title": true,
      "ja": "2. INPUT  - ハフマン指示入力0ビット。"
    },
    {
      "indent": 3,
      "text": "3. The INPUT-HUFFMAN instruction requests data that lies beyond the end of the compressed message.",
      "ja": "3. INPUT-ハフマン指示は、圧縮されたメッセージの終わりを超えてあるデータを要求します。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :input_bit_order pad (2) :result pad (2)",
      "ja": "：パッドbyte_copy_left（2）：byte_copy_rightパッド（2）：input_bit_orderパッド（2）：結果のパッド（2）"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：開始"
    },
    {
      "indent": 3,
      "text": "INPUT-HUFFMAN (result, end_of_message, 2, $input_bit_order, 0, $input_bit_order, $input_bit_order, $input_bit_order, 0, 65535, 0) OUTPUT (result, 2)",
      "ja": "INPUT-ハフマン（その結果、end_of_message、2、$ input_bit_order、0、$ input_bit_order、$ input_bit_order、$ input_bit_order、0、65535、0）OUTPUT（結果2）"
    },
    {
      "indent": 3,
      "text": "ADD ($input_bit_order, 1) REMAINDER ($input_bit_order, 7) ADD ($input_bit_order, 1)",
      "ja": "ADD（$のinput_bit_orderは、1）REMAINDER（$のinput_bit_orderは、7）ADD（$のinput_bit_order、1）"
    },
    {
      "indent": 3,
      "text": "JUMP (start)",
      "ja": "ジャンプスタート）"
    },
    {
      "indent": 3,
      "text": ":end_of_message",
      "ja": "：end_of_message"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "An example of a compressed message is 0x932e ac71 66d8 6f, which decompresses to give the output 0x0000 0003 0008 04d7 0002 0003 0399 30fe. Executing the code costs 84 UDVM cycles.",
      "ja": "圧縮されたメッセージの例は、出力0000を0003 0008 0002 0003 0399 04d7 30feを与えるために伸張れ、0x932e ac71 66d8 6Fです。コードを実行すると、84回のUDVMサイクルがかかります。"
    },
    {
      "indent": 3,
      "text": "As the code is run, the input_bit_order changes through all possible values to check usage of the H and P bits. The number of bits to input each time is taken from the value of input_bit_order. The sequence is the following:",
      "ja": "コードが実行されるように、すべての可能な値を通るinput_bit_order変化はHとPビットの使用状況をチェックします。ビットの数を入力するたびにinput_bit_orderの値から取られます。順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Input_bit_order (bin) Total bits input by Huffman Value 000 0 0 010 2 3 100 4 8 110 12 1239 001 P-bit changed, throw away 6 bits 001 1 2 011 3 3 101 10 921 111 14 12542 010 P-bit changed, throw away 4 bits 010 0 - not enough bits so terminate",
      "ja": "ハフマン値によってInput_bit_order（ビン）合計ビット入力000 0 0 010 2 3 100 4 8 110 12 1239 001は、Pビットは、Pビットが変化離れ6ビット001 1 2 011 3 3 101 10 921 111 14 12542 010を投げる、変更しました捨てる4ビット010 0  - 十分なビットがそう終了していません"
    },
    {
      "indent": 0,
      "text": "2.12. INPUT-BYTES",
      "section_title": true,
      "ja": "2.12。 INPUT-BYTES"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the INPUT-BYTES instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、入力バイトの命令をテストするためにアセンブリコードを与えます。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The INPUT-BYTES instruction inputs 0 bytes.",
      "section_title": true,
      "ja": "1. INPUTバイト命令入力0バイト。"
    },
    {
      "indent": 3,
      "text": "2. The INPUT-BYTES instruction requests data that lies beyond the end of the compressed message.",
      "ja": "2. INPUT-BYTES命令は、圧縮されたメッセージの終わりを超えてあるデータを要求します。"
    },
    {
      "indent": 3,
      "text": "3. The INPUT-BYTES instruction is used after part of a byte has been input (e.g., by the INPUT-BITS instruction).",
      "ja": "バイトの部分（INPUTビット命令で、例えば）が入力された後の3 INPUTバイト命令が使用されます。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :input_bit_order pad (2) :result pad (2) :output_start pad (4) :output_end",
      "ja": "：byte_copy_leftパッド（2）：byte_copy_rightパッド（2）：パッドinput_bit_order（2）：結果のパッド（2）：output_startパッド（4）：output_end"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "LOAD (byte_copy_left, output_start) LOAD (byte_copy_right, output_end)",
      "ja": "LOAD（byte_copy_left、output_start）LOAD（byte_copy_right、output_end）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：開始"
    },
    {
      "indent": 3,
      "text": "INPUT-BITS ($input_bit_order, result, end_of_message) OUTPUT (result, 2)",
      "ja": "INPUT-BITS（$のinput_bit_order、その結果、end_of_message）OUTPUT（結果、2）"
    },
    {
      "indent": 3,
      "text": "ADD ($input_bit_order, 2) REMAINDER ($input_bit_order, 7)",
      "ja": "ADD（$のinput_bit_order、2）REMAINDER（$のinput_bit_order、7）"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES ($input_bit_order, output_start, end_of_message) OUTPUT (output_start, $input_bit_order)",
      "ja": "INPUT-BYTES（$のinput_bit_order、output_start、end_of_message）OUTPUT（output_start、$ input_bit_order）"
    },
    {
      "indent": 3,
      "text": "ADD ($input_bit_order, 1) JUMP (start)",
      "ja": "ADD（$のinput_bit_order、1）JUMP（スタート）"
    },
    {
      "indent": 3,
      "text": ":end_of_message",
      "ja": "：end_of_message"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "An example of a compressed message is 0x932e ac71 66d8 6fb1 592b dc9a 9734 d847 a733 874e 1bcb cd51 b5dc 9659 9d6a, which decompresses to give the output 0x0000 932e 0001 b166 d86f b100 1a2b 0003 9a97 34d8 0007 0001 3387 4e00 08dc 9651 b5dc 9600 599d 6a. Executing the code costs 130 UDVM cycles.",
      "ja": "圧縮されたメッセージの例は、0x932e ac71 66d8 6fb1 592B dc9a 9734 d847 a733 874e 1bcb CD51 b5dc 9600 599D部6a b5dc b166のd86fのB100の1a2b 0003 9a97 34d8 0007 0001 3387 4e00 08dc 9651 0000 932e 0001出力を与えるために伸張9659 9d6a、。コードを実行すると、130回のUDVMサイクルがかかります。"
    },
    {
      "indent": 3,
      "text": "As the code is run, the input_bit_order changes through all possible values to check usage of the F and P bits. The number of bits or bytes to input each time is taken from the value of input_bit_order. For each INPUT-BYTES instruction, the remaining bits of the byte are thrown away. The P-bit always changes on the byte boundary so no bits are thrown away. The sequence is the following:",
      "ja": "コードが実行されるように、すべての可能な値を通るinput_bit_order変化は、FとPビットの使用状況をチェックします。ビットまたはバイトの数を入力するたびにinput_bit_orderの値から取られます。各入力バイトの命令のために、バイトの残りのビットは捨てられます。何ビットが捨てられていませんので、Pビットは常にバイト境界に変更します。順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Input_bit_order (bin) Input bits Input bytes Output 000 0 0x0000 010 2 0x932e 011 3 0x0001 101 5 0xb166 d866 b1 110 6 0x001a 001 1 0x2b 010 2 0x0003 100 4 0x9a97 34d8 101 5 0x0007 000 0 001 1 0x0001 011 3 0x3384 4e 100 4 0x0008 110 6 0xdc96 51b5 dc96 111 7 0x0059 010 2 0x9d6a 011 3 - no bits left so terminate",
      "ja": "Input_bit_orderの入力ビット（ビン）入力001 1 0x2Bを010 2 0x0003 100 4 0x9a97 34d8 101 5 0x0007 000 0 001 1は0x0001 011 3 0x3384 4E 100 4 0x001a出力000 0 0000 010 2 0x932e 011 3は0x0001 101 5 0xb166 d866 b1の110 6バイト0x0008で110 6 0xdc96 51b5 dc96 111 7 0x0059 010 2 0x9d6a 011 3  - 何ビットがそう終了残っていません"
    },
    {
      "indent": 0,
      "text": "2.13. Stack Manipulation",
      "section_title": true,
      "ja": "2.13。スタック操作"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the PUSH, POP, CALL, and RETURN instructions. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、PUSH、POP、CALL、およびRETURN命令をテストするためにアセンブリコードを与えます。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The stack manipulation instructions overwrite the UDVM register stack_location.",
      "ja": "1.スタック操作命令はUDVMレジスタstack_locationを上書きします。"
    },
    {
      "indent": 3,
      "text": "2. The CALL instruction specifies a reference operand rather than an absolute value.",
      "ja": "2. CALL命令は、参照オペランドではなく絶対値を指定します。"
    },
    {
      "indent": 3,
      "text": "3. The PUSH instruction pushes the value contained in stack_fill onto the stack.",
      "ja": "3. PUSH命令はスタックにstack_fillに含まれる値をプッシュします。"
    },
    {
      "indent": 3,
      "text": "4. The stack_location register contains an odd integer.",
      "section_title": true,
      "ja": "4. stack_locationレジスタは奇数の整数を含んでいます。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :input_bit_order pad (2) :stack_location pad (2) :next_address pad (2)",
      "ja": "：パッドbyte_copy_left（2）：byte_copy_rightパッド（2）：input_bit_orderパッド（2）：stack_locationパッド（2）：next_addressパッド（2）"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "LOAD (stack_location, 64) PUSH (2) PUSH ($64) PUSH (66) ; Stack now contains 2, 1, 66 ; so $stack_location = 66",
      "ja": "LOAD（stack_location、64）PUSH（2）PUSH（$ 64）PUSH（66）。スタックは今、66 1、2含まれています。そう$ stack_location = 66"
    },
    {
      "indent": 3,
      "text": "OUTPUT (64, 8) ; Output 0x0003 0002 0001 0042",
      "ja": "OUTPUT（64、8）。出力0x0003 0002 0001 0042"
    },
    {
      "indent": 3,
      "text": "POP (64) ; Pop value 66 from address 70 to address 64 POP ($stack_location) ; Pop value 1 from address 68 to address 66 ; so stack_fill is overwritten to be 1 POP (stack_location) ; Pop value 1 from address 68 to address 70",
      "ja": "POP（64）。 64 POP（$ stack_location）に対処するためのアドレス70からポップ値66。 66に対応するためのアドレス68からポップ値1。そうstack_fill 1つのPOP（stack_location）であることが上書きされます。 70に対応するためのアドレス68からポップ値1"
    },
    {
      "indent": 3,
      "text": "OUTPUT (64, 8) ; Output 0x0042 0000 0001 0001 JUMP (address_a)",
      "ja": "OUTPUT（64、8）。出力0x0042 0000 0001 0001 JUMP（address_a）"
    },
    {
      "indent": 3,
      "text": "at (192)",
      "ja": "で（192）"
    },
    {
      "indent": 3,
      "text": ":address_a",
      "ja": "：address_a"
    },
    {
      "indent": 3,
      "text": "LOAD (stack_location, 32) LOAD (next_address, address_c) SUBTRACT ($next_address, address_b) ; next_address = 64 CALL (address_b) ; push 204 on stack",
      "ja": "LOAD（stack_location、32）LOAD（next_address、address_c）SUBTRACT（$ next_address、address_b）。 next_address = 64 CALL（address_b）。スタックに204をプッシュ"
    },
    {
      "indent": 3,
      "text": "at (256)",
      "ja": "で（256）"
    },
    {
      "indent": 3,
      "text": ":address_b",
      "ja": "：address_b"
    },
    {
      "indent": 3,
      "text": "CALL ($next_address) ; push 256 on stack",
      "ja": "CALL（$ next_address）。スタックに256をプッシュ"
    },
    {
      "indent": 3,
      "text": "at (320)",
      "ja": "で（320）"
    },
    {
      "indent": 3,
      "text": ":address_c",
      "ja": "：address_c"
    },
    {
      "indent": 3,
      "text": "LOAD (stack_location, 383) LOAD (383, 26) ; overwrite $stack_location with 26 MULTILOAD (432, 3, 1, 49153, 32768)",
      "ja": "LOAD（stack_location、383）LOAD（383、26）。 26 MULTILOAD（432、3、1、49153、32768）と$ stack_locationを上書き"
    },
    {
      "indent": 36,
      "text": "; write bytes so that 433 and 434\n; contain 0x01c0 = 448 and\n; 435 and 436 contain 0x0180 = 384",
      "raw": true
    },
    {
      "indent": 3,
      "text": "RETURN ; pop 383 from the stack and jump ; there = 384, which is lsb of ; stack_fill, which now contains 25, ; which is UDVM instruction RETURN ; pop 448 from the stack and jump ; there at (448)",
      "ja": "RETURN;スタックとジャンプから383をポップ。 LSBである384は、そこ=。今25が含まれているstack_fill、、;これUDVM命令RETURNです。スタックとジャンプから448をポップ。そこでの（448）"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x0003 0002 0001 0042 0042 0000 0001 0001, and a total of 40 UDVM cycles are used.",
      "ja": "コードの出力は、0x0003 0002 0001 0042 0042 0000 0001 0001であり、そして40 UDVMサイクルの合計が使用されます。"
    },
    {
      "indent": 0,
      "text": "2.14. Program Flow",
      "section_title": true,
      "ja": "2.14。プログラム・フロー"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the JUMP, COMPARE, and SWITCH instructions. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、JUMPをテスト比較し、指示をスイッチにアセンブリコードを示します。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The address operands are specified as references to memory addresses rather than as absolute values.",
      "ja": "1.アドレスオペランドは、メモリアドレスへの参照ではなく、絶対値として指定されています。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":next_address pad (2) :counter pad (1) :counter_lsb pad (1) :switch_counter pad (2)",
      "ja": "：next_addressパッド（2）：カウンタのパッド（1）：counter_lsbパッド（1）：switch_counterパッド（2）"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "LOAD (switch_counter, 4)",
      "ja": "LOAD（switch_counter、4）"
    },
    {
      "indent": 3,
      "text": ":address_a",
      "ja": "：address_a"
    },
    {
      "indent": 3,
      "text": "LOAD (next_address, address_c) SUBTRACT ($next_address, address_b) ; address_c - address_b OUTPUT (counter_lsb, 1)",
      "ja": "LOAD（next_address、address_c）SUBTRACT（$ next_address、address_b）。 address_c  -  address_b出力（counter_lsb、1）"
    },
    {
      "indent": 3,
      "text": ":address_b",
      "ja": "：address_b"
    },
    {
      "indent": 3,
      "text": "JUMP ($next_address) ; Jump to address_c",
      "ja": "JUMP（$ next_address）。 address_cへジャンプ"
    },
    {
      "indent": 3,
      "text": ":address_c",
      "ja": "：address_c"
    },
    {
      "indent": 3,
      "text": "ADD ($counter, 1) LOAD (next_address, address_a) SUBTRACT ($next_address, address_d) ; address_a - address_d OUTPUT (counter_lsb, 1)",
      "ja": "（$カウンタ、1）LOAD（next_address、address_a）SUBTRACT（$ next_address、address_d）を追加します。 address_a  -  address_d OUTPUT（counter_lsb、1）"
    },
    {
      "indent": 3,
      "text": ":address_d",
      "ja": "：address_d"
    },
    {
      "indent": 3,
      "text": "COMPARE ($counter, 6, $next_address, address_c, address_e) ; counter < 6, $next_address gives ; jump to address_a",
      "ja": "COMPARE（$カウンタ、6、$のnext_address、address_c、address_e）。カウンター<6、$のnext_addressができます。 address_aにジャンプ"
    },
    {
      "indent": 3,
      "text": ":address_e",
      "ja": "：address_e"
    },
    {
      "indent": 3,
      "text": "SUBTRACT ($switch_counter, 1) ; switch_counter = 3 LOAD (next_address, address_a) SUBTRACT ($next_address, address_f) ; address_a - address_f OUTPUT (counter_lsb, 1)",
      "ja": "SUBTRACT（$のswitch_counter、1）; switch_counter = 3 LOAD（next_address、address_a）SUBTRACT（$ next_address、address_f）。 address_a  -  address_f OUTPUT（counter_lsb、1）"
    },
    {
      "indent": 3,
      "text": ":address_f",
      "ja": "：address_f"
    },
    {
      "indent": 3,
      "text": "SWITCH (4, $switch_counter, address_g, $next_address, address_c, address_e) ; when $switch_counter = 1, ; $next_address gives jump to ; address_a",
      "ja": "SWITCH（4、$ switch_counter、address_g、$ next_address、address_c、address_e）。ときの$ switch_counter = 1; $のnext_addressはへのジャンプを与えます。 address_a"
    },
    {
      "indent": 3,
      "text": ":address_g",
      "ja": "：address_g"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x0001 0102 0203 0304 0405 0506 0707 0708 0808 0909, and a total of 131 UDVM cycles are used.",
      "ja": "コードの出力は、0x0001の0102 0203 0304 0405 0506 0707 0708 0808 0909であり、そして131 UDVMサイクルの合計が使用されます。"
    },
    {
      "indent": 0,
      "text": "2.15. State Creation",
      "section_title": true,
      "ja": "2.15。ステートの作成"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the STATE-CREATE and STATE-FREE instructions. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、STATE-CREATEおよびSTATE-FREEの指示をテストするためにアセンブリコードを示します。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. An item of state is created that duplicates an existing state item.",
      "ja": "1状態の項目は、既存の状態の項目を複製が作成されます。"
    },
    {
      "indent": 3,
      "text": "2. An item of state is freed when the state has not been created.",
      "section_title": true,
      "ja": "状態が作成されていないときの状態の2項目が解放されます。"
    },
    {
      "indent": 3,
      "text": "3. An item of state is created and then freed by the same message.",
      "section_title": true,
      "ja": "3.状態の項目が作成され、同じメッセージによって解放されます。"
    },
    {
      "indent": 3,
      "text": "4. The STATE-FREE instruction frees a state item by sending fewer bytes of the state_identifier than the minimum_access_length.",
      "ja": "4. STATE-FREE命令はminimum_access_lengthよりstate_identifierの少ないバイトを送信することによって、状態の項目を解放します。"
    },
    {
      "indent": 3,
      "text": "5. The STATE-FREE instruction has partial_identifier_length operand shorter than 6 or longer than 20.",
      "ja": "5. STATE-FREE命令は6より短いまたはより長い20 partial_identifier_lengthオペランドを持っています。"
    },
    {
      "indent": 3,
      "text": "6. The STATE-FREE instruction specifies a partial_identifier that matches with two state items in the compartment.",
      "ja": "6. STATE-FREE命令は、区画内の2つの状態の項目と一致partial_identifierを指定します。"
    },
    {
      "indent": 3,
      "text": "7. The bytes of the identifier are written to the position specified in the STATE-FREE instruction after the STATE-FREE instruction has been run (and before END-MESSAGE).",
      "ja": "STATE-FREE命令が実行された後の7識別子のバイトはSTATE-FREE命令で指定された位置に書き込まれます（とEND-MESSAGE前）。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :states pad (1) :states_lsb pad (1) :min_len pad (1) :min_len_lsb pad (1)",
      "ja": "：パッドbyte_copy_left（2）：byte_copy_rightパッド（2）：states_lsbパッド（1）：min_lenパッド（1）：min_len_lsbパッド（1）パッド（1）の状態"
    },
    {
      "indent": 3,
      "text": ":state_identifier pad (20)",
      "ja": "：state_identifierパッド（20）"
    },
    {
      "indent": 3,
      "text": "set (state_length, 10)",
      "ja": "セット（state_length、10）"
    },
    {
      "indent": 3,
      "text": "at (127) :decompression_failure at (128)",
      "ja": "時（127）（128）でdecompression_failure"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, states_lsb, decompression_failure)",
      "ja": "INPUTバイト（1、states_lsb、decompression_failure）"
    },
    {
      "indent": 3,
      "text": ":test_one LSHIFT ($states, 11) COMPARE ($states, 32768, test_two, create_state_a2, create_state_a2)",
      "ja": "：test_oneのLSHIFT（$状態、11）COMPARE（$州、32768、test_two、create_state_a2、create_state_a2）"
    },
    {
      "indent": 3,
      "text": ":create_state_a2 STATE-CREATE (state_length, state_address2, 0, 20, 0)",
      "ja": "：create_state_a2 STATE-CREATE（state_length、state_address2、0、20、0）"
    },
    {
      "indent": 3,
      "text": ":test_two LSHIFT ($states, 1) COMPARE ($states, 32768, test_three, create_state_a, create_state_a)",
      "ja": "：test_two LSHIFT（$の状態は、1）COMPARE（$州、32768、test_three、create_state_a、create_state_a）"
    },
    {
      "indent": 3,
      "text": ":create_state_a STATE-CREATE (state_length, state_address, 0, 20, 0)",
      "ja": "：create_state_a状態-CREATE（state_length、state_address、0、20、0）"
    },
    {
      "indent": 3,
      "text": ":test_three LSHIFT ($states, 1) COMPARE ($states, 32768, test_four, free_state, free_state)",
      "ja": "：test_three LSHIFT（$の状態は、1）（$州、32768、test_four、free_state、free_state）を比較します"
    },
    {
      "indent": 3,
      "text": ":free_state INPUT-BYTES (1, min_len_lsb, decompression_failure) STATE-FREE (state_identifier, $min_len) COPY (identifier1, $min_len, state_identifier)",
      "ja": "：free_state INPUT-BYTES（1、min_len_lsb、decompression_failure）STATE-FREE（state_identifier、$ min_len）COPY（identifier1、$ min_len、state_identifier）"
    },
    {
      "indent": 3,
      "text": ":test_four",
      "ja": "：test_four"
    },
    {
      "indent": 3,
      "text": "LSHIFT ($states, 1) COMPARE ($states, 32768, test_five, free_state2, free_state2)",
      "ja": "LSHIFT（$状態、1）COMPARE（$州、32768、test_five、free_state2、free_state2）"
    },
    {
      "indent": 3,
      "text": ":free_state2 STATE-FREE (identifier1, 6)",
      "ja": "：free_state2 STATE-FREE（identifier1、6）"
    },
    {
      "indent": 3,
      "text": ":test_five LSHIFT ($states, 1) COMPARE ($states, 32768, end, create_state_b, create_state_b)",
      "ja": "：test_five LSHIFT（$状態、1）COMPARE（$州、32768、終わり、create_state_b、create_state_b）"
    },
    {
      "indent": 3,
      "text": ":create_state_b END-MESSAGE (0, 0, state_length, state_address, 0, 20, 0)",
      "ja": "：create_state_b END-MESSAGE（0、0、state_length、state_address、0、20、0）"
    },
    {
      "indent": 3,
      "text": ":end END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "：エンドEND-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":identifier1 byte (67, 122, 232, 10, 15, 220, 30, 106, 135, 193, 182, 42, 118, 118, 185, 115, 49, 140, 14, 245)",
      "ja": "：identifier1バイト（67、122、232、10、15、220、30、106、135、193、182、42、118、118、185、115、49、140、14、245）"
    },
    {
      "indent": 3,
      "text": "at (256) :state_address byte (192, 204, 63, 238, 121, 188, 252, 143, 209, 8)",
      "ja": "state_addressバイト（192、204、63、238、121、188、252、143、209、8）：（256）で"
    },
    {
      "indent": 3,
      "text": ":state_address2 byte (101, 232, 3, 82, 238, 41, 119, 23, 223, 87)",
      "ja": "：state_address2バイト（101、232、3、82、238、41、119、23、223、87）"
    },
    {
      "indent": 3,
      "text": "Upon reaching the END-MESSAGE instruction, the UDVM does not output any decompressed data, but instead may make one or more state creation or state free requests to the state handler. Assuming that the application does not veto the state creation request (and that sufficient state memory is available) the code results in 0, 1, or 2 state items being present in the compartment.",
      "ja": "END-MESSAGE命令に達すると、UDVMは、出力任意の解凍されたデータをしませんが、代わりに、状態ハンドラへの一つ以上の状態の作成や状態自由請求をすることができます。区画中に存在する0,1、又は2状態項目のコードの結果は、アプリケーションが状態作成要求を拒否しないと仮定すると（および十分な状態メモリが利用可能です）。"
    },
    {
      "indent": 3,
      "text": "The following table lists ten different compressed messages, the states created and freed by each, the number of states left after each message, and the number of UDVM cycles used. There are 3 state creation instructions:",
      "ja": "次の表は、10の異なる圧縮されたメッセージを一覧表示し、作成し、それぞれによって解放された状態は、状態の数は、各メッセージの後左、及びUDVMサイクルの数は、使用されます。 3つのステートの作成命令があります。"
    },
    {
      "indent": 6,
      "text": "create state_a, which has hash identifier1 create state_b (in END-MESSAGE), which is identical to state_a create state_a2, which has a different identifier, but the first 6 bytes are the same as those of identifier1.",
      "ja": "ハッシュidentifier1が異なる識別子を有するstate_a2を作成STATE_Aと同一であり、（END-MESSAGE IN）STATE_Bを作成有するが、最初の6つのバイトはidentifier1のものと同じである、STATE_Aを作成します。"
    },
    {
      "indent": 3,
      "text": "Message: Effect: # state items: #cycles: 0x01 create state_b 1 23 0x02 free (id1, 6) = state_b 0 14 0x03 free (id1, 6) = state_b; create state_b 1 24",
      "ja": "メッセージ：効果：＃状態アイテム：#cyclesは：STATE_B作成0x01の1 23 0×02フリー（ID1、6）= STATE_B 0 14 0×03フリー（ID1、6）= STATE_B。 STATE_B 1 24を作成します"
    },
    {
      "indent": 3,
      "text": "0x0405 free (id1, 5) Decompression failure 0x0415 free (id1, 21) Decompression failure",
      "ja": "0x0405フリー（ID1、5）解凍失敗0x0415フリー（ID1、21）解凍失敗"
    },
    {
      "indent": 3,
      "text": "0x0406 free (id1, 6) = state_b 0 23",
      "ja": "0x0406フリー（ID1、6）= 0 STATE_B 23"
    },
    {
      "indent": 3,
      "text": "0x09 create state_a; create state_b 1 34",
      "ja": "0x09のSTATE_Aを作成します。 STATE_B 1 34を作成します"
    },
    {
      "indent": 3,
      "text": "0x1e06     create state_a2; create state_a;\n           free (id1, 6) = matches both so no free;\n           free (id1, 6) = matches both so no free;   2           46",
      "raw": true
    },
    {
      "indent": 3,
      "text": "0x1e07     create state_a2; create state_a;\n           free (id1, 7) = state_a;\n           free (id1, 6) = state_a2                   0           47",
      "raw": true
    },
    {
      "indent": 3,
      "text": "0x1e14     create state_a2; create state_a;\n           free (id1, 20) = state_a;\n           free (id1, 6) = state_a2                   0           60",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.16. STATE-ACCESS",
      "section_title": true,
      "ja": "2.16。 STATE-ACCESS"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the STATE-ACCESS instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、ステートアクセス命令をテストするためにアセンブリコードを与えます。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. A subset of the bytes contained in a state item is copied to the UDVM memory.",
      "ja": "1.状態の項目に含まれるバイトのサブセットは、UDVMメモリにコピーされます。"
    },
    {
      "indent": 3,
      "text": "2. Bytes are copied from beyond the end of the state value.",
      "section_title": true,
      "ja": "2バイトは、状態値の端を越えてからコピーされます。"
    },
    {
      "indent": 3,
      "text": "3. The state_instruction operand is set to 0.",
      "section_title": true,
      "ja": "3. state_instructionオペランドが0に設定されています。"
    },
    {
      "indent": 3,
      "text": "4. The state cannot be accessed because the partial state identifier is too short.",
      "ja": "パーシャル状態識別子が短すぎるため、4状態にアクセスすることはできません。"
    },
    {
      "indent": 3,
      "text": "5. The state identifier is overwritten by the state item being accessed.",
      "ja": "前記状態識別子は、状態項目がアクセスされることによって上書きされます。"
    },
    {
      "indent": 3,
      "text": "The following bytecode needs to be run first to set up the state for the rest of the test.",
      "ja": "次のバイトコードは、テストの残りの状態を設定することが最初に実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, state_length, state_start, 0, 20, 0)",
      "ja": "END-MESSAGE（0、0、state_length、STATE_START、0、20、0）"
    },
    {
      "indent": 3,
      "text": "; The bytes between state_start and state_end are derived from ; translation of the following mnemonic code: ; ; at (512) ; OUTPUT (data, 4) ; END-MESSAGE (0,0,0,0,0,0,0) ; :data ; byte (116, 101, 115, 116)",
      "ja": "; STATE_STARTとstate_end間のバイトは、以下から誘導されます。以下のニーモニックコードの翻訳：; ; （512）において、 OUTPUT（データ、4）。 END-MESSAGE（0,0,0,0,0,0,0）。 ：データ;バイト（116、101、115、116）"
    },
    {
      "indent": 3,
      "text": "at (512) :state_start byte (34, 162, 12,4, 35, 0, 0, 0, 0, 0, 0, 0, 116, 101, 115, 116) :state_end",
      "ja": "STATE_STARTバイト（34、162、12,4、35、0、0、0、0、0、0、0、116、101、115、116）、（512）でstate_end"
    },
    {
      "indent": 3,
      "text": "set (state_length, (state_end - state_start))",
      "ja": "セット（state_length、（state_end  -  STATE_START））"
    },
    {
      "indent": 3,
      "text": "This is the bytecode for the rest of the test.",
      "ja": "これはテストの残りのバイトコードです。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :type pad (1) :type_lsb pad (1) :state_value pad (4)",
      "ja": "：パッドbyte_copy_left（2）：byte_copy_rightパッド（2）：型パッド（1）：type_lsbパッド（1）：state_valueパッド（4）"
    },
    {
      "indent": 3,
      "text": "at (127) :decompression_failure at (128)",
      "ja": "時（127）（128）でdecompression_failure"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, type_lsb, decompression_failure) COMPARE ($type, 1, execute_state, extract_state, error_conditions)",
      "ja": "INPUT-BYTES（1、type_lsb、decompression_failure）COMPARE（$タイプ、1、execute_state、extract_state、error_conditions）"
    },
    {
      "indent": 3,
      "text": ":execute_state",
      "ja": "：execute_state"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier, 20, 0, 0, 0, 512)",
      "ja": "STATE-ACCESS（state_identifier、20、0、0、0、512）"
    },
    {
      "indent": 3,
      "text": ":extract_state",
      "ja": "：extract_state"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier, 20, 12, 4, state_value, 0) OUTPUT (state_value, 4) JUMP (end)",
      "ja": "STATE-ACCESS（state_identifier、20、12、4、state_value、0）OUTPUT（state_value、4）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": ":error_conditions",
      "ja": "：error_conditions"
    },
    {
      "indent": 3,
      "text": "COMPARE ($type, 3, state_not_found, id_too_short, state_too_short)",
      "ja": "COMPARE（$タイプ、3、state_not_found、id_too_short、state_too_short）"
    },
    {
      "indent": 3,
      "text": ":state_not_found",
      "ja": "：state_not_found"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (128, 20, 0, 0, 0, 0) JUMP (end)",
      "ja": "STATE-ACCESS（128、20、0、0、0、0）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": ":id_too_short",
      "ja": "：id_too_short"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier, 19, 6, 4, state_value, 0) JUMP (end)",
      "ja": "STATE-ACCESS（state_identifier、19、6、4、state_value、0）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": ":state_too_short",
      "ja": "：state_too_short"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier, 20, 12, 5, state_value, 0) JUMP (end)",
      "ja": "STATE-ACCESS（state_identifier、20、12、5、state_value、0）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": "at (484)",
      "ja": "で（484）"
    },
    {
      "indent": 3,
      "text": ":end",
      "ja": "：終わり"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "at (512)",
      "ja": "で（512）"
    },
    {
      "indent": 3,
      "text": ":state_identifier",
      "ja": "：state_identifier"
    },
    {
      "indent": 3,
      "text": "byte (0x5d, 0xf8, 0xbc, 0x3e, 0x20, 0x93, 0xb5, 0xab, 0xe1, 0xf1, 0x70, 0x13, 0x42, 0x4c, 0xe7, 0xfe, 0x05, 0xe0, 0x69, 0x39)",
      "ja": "バイト（0x5d、0xf8、の0xBC、0x3e、の0x20、0x93、0xb5、0xab、0xE1の、0xf1、0x70、0x13に、0x42に、0x4c、0xe7、0xFEの、0x05の、0xE0となっ、0x69の、ます。0x39）"
    },
    {
      "indent": 3,
      "text": "If the compressed message is 0x00, then the output of the code is 0x7465 7374, and a total of 26 UDVM cycles are used. If the compressed message is 0x01, then the output of the code is also 0x7465 7374 but in this case using a total of 15 UDVM cycles. If the compressed message is 0x02, 0x03, or 0x04, then decompression failure occurs.",
      "ja": "圧縮されたメッセージが0x00である場合、コードの出力は0x7465 7374であり、そして26 UDVMサイクルの合計が使用されます。圧縮されたメッセージが0x01の場合は、コードの出力はまた、0x7465 7374であるが、この場合、15 UDVMサイクルの合計を使用します。圧縮されたメッセージは、0x02の、0x03の、または0x04の場合は、解凍の失敗が発生します。"
    },
    {
      "indent": 0,
      "text": "3. Torture Tests for Dispatcher",
      "section_title": true,
      "ja": "Dispatcherの3拷問テスト"
    },
    {
      "indent": 3,
      "text": "The following sections give code to test the various functions of the SigComp dispatcher.",
      "ja": "以下のセクションでは、SigCompのディスパッチャの様々な機能をテストするためのコードを与えます。"
    },
    {
      "indent": 0,
      "text": "3.1. Useful Values",
      "section_title": true,
      "ja": "3.1。有用な値"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test that the SigComp \"Useful Values\" are correctly initialized in the UDVM memory. It also tests that the UDVM is correctly terminated if the bytecode uses too many UDVM cycles or tries to write beyond the end of the available memory.",
      "ja": "このセクションでは、SigCompの「有用な値は、」正しくUDVMメモリに初期化されていることをテストするためにアセンブリコードを示します。また、バイトコードは、あまりにも多くのUDVMサイクルを使用するか、使用可能なメモリの終わりを超えて書き込もうとした場合UDVMが正しく終端されていることをテストします。"
    },
    {
      "indent": 3,
      "text": "The code tests that the following boundary cases have been correctly implemented:",
      "ja": "以下の境界例が正しく実装されているコードをテストします。"
    },
    {
      "indent": 3,
      "text": "1. The bytecode uses exactly as many UDVM cycles as are available (in which case no problems should arise) or one cycle too many (in which case decompression failure should occur). A liberal implementation could allow more cycles to be used than are strictly available, in which case decompression failure will not occur. This is an implementation choice. If this choice is made, the implementer must be sure that the cycles are checked eventually and that decompression failure does occur when bytecode uses an excessive number of cycles. This is tested in Section 3.2.",
      "ja": "利用可能である（この場合、何ら問題は生じないはずである）、または1つのサイクル数が多すぎる（この場合、解凍の失敗が発生した場合）と1バイトコードは、正確に同じ数のUDVMサイクルを使用します。リベラルな実装が厳密に使用できる数より多くのサイクルがその場合には、解凍の失敗が発生しない、使用される可能性があります。これは、実装の選択です。この選択が行われた場合、実装者は、サイクルが最終的にチェックされ、バイトコードは、サイクルの過剰な数を使用する場合、その解凍障害が発生していることを確認する必要があります。これは、セクション3.2でテストされています。"
    },
    {
      "indent": 3,
      "text": "2. The bytecode writes to the highest memory address available (in which case no problems should arise) or to the memory address immediately following the highest available address (in which case decompression failure must occur).",
      "ja": "2.バイトコードは（何も問題は生じないはずである場合には）利用可能な最高のメモリアドレスまたは、すぐに利用可能な最高のアドレス（この場合、解凍の失敗が発生しなければならない）、次のメモリアドレスに書き込みます。"
    },
    {
      "indent": 3,
      "text": ":udvm_memory_size pad (2) :cycles_per_bit pad (2) :sigcomp_version pad (2) :partial_state_id_length pad (2) :state_length pad (2)",
      "ja": "：udvm_memory_sizeパッド（2）：cycles_per_bitパッド（2）：sigcomp_versionパッド（2）：partial_state_id_lengthパッド（2）：state_lengthパッド（2）"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :remaining_cycles pad (2) :check_memory pad (1) :check_memory_lsb pad (1) :check_cycles pad (1) :check_cycles_lsb pad (1)",
      "ja": "：byte_copy_leftパッド（2）：byte_copy_rightパッド（2）：check_memoryパッド（1）：check_memory_lsbパッド（1）：check_cyclesパッド（1）：check_cycles_lsbパッド（1）パッド（2）remaining_cycles"
    },
    {
      "indent": 3,
      "text": "at (127) :decompression_failure at (128) ; Set up a 1-byte buffer LOAD (byte_copy_left, 32) LOAD (byte_copy_right, 33)",
      "ja": "時（127）（128）でdecompression_failure。 1バイトのバッファの負荷を設定する（byte_copy_left、32）LOAD（byte_copy_right、33）"
    },
    {
      "indent": 3,
      "text": ":test_version",
      "ja": "：test_version"
    },
    {
      "indent": 3,
      "text": "; Input a byte containing the version of SigComp being run INPUT-BYTES (1, check_memory_lsb, decompression_failure) COMPARE ($sigcomp_version, $check_memory, decompression_failure, test_state_access, decompression_failure)",
      "ja": "; SigCompのバージョンを含む入力バイトがINPUT-BYTES（1、check_memory_lsb、decompression_failure）COMPAREを実行されている（$ sigcomp_version、$のcheck_memory、decompression_failure、test_state_access、decompression_failure）"
    },
    {
      "indent": 3,
      "text": ":test_state_access",
      "ja": "：test_state_access"
    },
    {
      "indent": 3,
      "text": "COMPARE ($partial_state_id_length, 0, decompression_failure, test_length_equals_zero, test_state_length)",
      "ja": "COMPARE（$のpartial_state_id_length、0、decompression_failure、test_length_equals_zero、test_state_length）"
    },
    {
      "indent": 3,
      "text": ":test_length_equals_zero ; No state was accessed so state_length ; should be zero (first message) COMPARE ($state_length, 0, decompression_failure, end, decompression_failure)",
      "ja": "：test_length_equals_zero;いいえ状態がstate_lengthようにアクセスされませんでした。ゼロ（最初のメッセージ）COMPARE（$のstate_length、0、decompression_failure、端、decompression_failure）でなければなりません"
    },
    {
      "indent": 3,
      "text": ":test_state_length ; State was accessed so state_length ; should be 960 COMPARE ($state_length, 960, decompression_failure, test_udvm_memory, decompression_failure)",
      "ja": "：test_state_length;状態はstate_lengthので、アクセスされました。 960 COMPARE（$のstate_length、960、decompression_failure、test_udvm_memory、decompression_failure）でなければなりません"
    },
    {
      "indent": 3,
      "text": ":test_udvm_memory ; Copy one byte to ; udvm_memory_size + input - 1 ; Succeed when input byte is 0x00 ; Fail when input byte is 0x01",
      "ja": "：test_udvm_memory; 1つのバイトをコピーします。 udvm_memory_size +入力 -  1。入力バイトが0x00であるときに成功します。入力バイトが0x01であるときに失敗します"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, check_memory_lsb, decompression_failure) ADD ($check_memory, $udvm_memory_size) SUBTRACT ($check_memory, 1) COPY (32, 1, $check_memory)",
      "ja": "INPUTバイト（1、check_memory_lsb、decompression_failure）（$ check_memory、$ udvm_memory_size）SUBTRACT（$のcheck_memory、1）COPY（32、1、$のcheck_memory）を追加"
    },
    {
      "indent": 3,
      "text": ":test_udvm_cycles",
      "ja": "：test_udvm_cycles"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, check_cycles_lsb, decompression_failure)",
      "ja": "INPUTバイト（1、check_cycles_lsb、decompression_failure）"
    },
    {
      "indent": 3,
      "text": "; Work out the total number of cycles available to the UDVM ; total_UDVM_cycles = cycles_per_bit * (8 * message_size + 1000) ; ; = cycles_per_bit * (8 * (partial_state_id_length + 3) + 1000)",
      "ja": "; UDVMが利用可能なサイクル数の合計をワークアウト。 total_UDVM_cycles = cycles_per_bit *（8 * MESSAGE_SIZE + 1000）。 ; = cycles_per_bitの*（8 *（partial_state_id_length + 3）+ 1000）"
    },
    {
      "indent": 3,
      "text": "LOAD (remaining_cycles, $partial_state_id_length) ADD ($remaining_cycles, 3) MULTIPLY ($remaining_cycles, 8) ADD ($remaining_cycles, 1000)",
      "ja": "LOAD（remaining_cycles、$ partial_state_id_length）（、$ remaining_cyclesを3）ADD MULTIPLY（$ remaining_cycles、8）は（$ remaining_cycles、1000）ADD"
    },
    {
      "indent": 3,
      "text": "MULTIPLY ($remaining_cycles, $cycles_per_bit)",
      "ja": "MULTIPLY（$ remaining_cycles、$のcycles_per_bit）"
    },
    {
      "indent": 3,
      "text": "ADD ($remaining_cycles, $check_cycles)",
      "ja": "ADD（$ remaining_cycles、$ check_cycles）"
    },
    {
      "indent": 3,
      "text": "set (cycles_used_by_bytecode, 856)",
      "ja": "セット（cycles_used_by_bytecode、856）"
    },
    {
      "indent": 3,
      "text": "SUBTRACT ($remaining_cycles, cycles_used_by_bytecode) COPY (32, $remaining_cycles, 32) ; Copy to use up all cycles available + input byte ; Succeeds when input byte = 0x00 ; Fail when input byte = 0x01",
      "ja": "SUBTRACT（$ remaining_cycles、cycles_used_by_bytecode）COPY（32、$ remaining_cycles、32）。入力バイトを+利用可能なすべてのサイクルを使用するためにコピーします。成功したときに入力バイト= 0x00で、とき入力バイトを失敗= 0x01で"
    },
    {
      "indent": 3,
      "text": ":end ; Create 960 bytes of state for future ; reference END-MESSAGE (0, 0, 960, 64, 128, 6, 0)",
      "ja": "：終わり ;将来のための国家の960のバイトを作成します。基準END-MESSAGE（0、0、960、64、128、6、0）"
    },
    {
      "indent": 3,
      "text": "The bytecode must be executed a total of four times in order to fully test the SigComp Useful Values. In the first case, the bytecode is uploaded as part of the SigComp message with a 1-byte compressed message corresponding to the version of SigComp being run. This causes the UDVM to request creation of a new state item and uses a total of 968 UDVM cycles.",
      "ja": "バイトコードは、完全にSigComp有用な値をテストするために合計4回実行されなければなりません。最初のケースでは、バイトコードは、SigCompのあるランのバージョンに対応する1バイトの圧縮されたメッセージとのSigCompメッセージの一部としてアップロードされます。これは、新しい状態項目の作成を要求するためにUDVMを引き起こし、968 UDVMサイクルの合計を使用しています。"
    },
    {
      "indent": 3,
      "text": "Subsequent tests access this state by uploading the state identifier as part of the SigComp message. Note that the SigComp message should not contain a returned feedback item (as this would cause the bytecode to calculate the total number of available UDVM cycles incorrectly).",
      "ja": "その後の試験はのSigCompメッセージの一部として、状態識別子をアップロードすることによってこの状態にアクセスします。 （これは間違って利用できるUDVMサイクルの合計数を計算するためにバイトコードを引き起こすよう）のSigCompメッセージが返されたフィードバック項目を含めるべきではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "A 3-byte compressed message is required for the second and subsequent cases, the first byte of which is the version of SigComp in use, 0xnn. If the message is 0xnn0000, then the UDVM should successfully terminate using exactly the number of available UDVM cycles. However, if the message is 0xnn0001, then the UDVM should use too many cycles and hence terminate with decompression failure. Furthermore, if the message is 0xnn0100, then decompression failure must occur because the UDVM attempts to write beyond its available memory.",
      "ja": "3バイトの圧縮されたメッセージは、第二及びその後のケースのための最初のバイトは、使用中0xnnにSigCompのバージョンで必要とされます。メッセージが0xnn0000ですであれば、UDVMが正常に正確に利用できるUDVMサイクルの数を使用して終了する必要があります。メッセージが0xnn0001ある場合は、その後、UDVMは、あまりにも多くのサイクルを使用する必要がありますので、解凍の失敗で終了します。メッセージが0xnn0100ある場合UDVMは、その使用可能なメモリを越えて書き込もうとしているため、さらに、その後、減圧障害が発生しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2. Cycles Checking",
      "section_title": true,
      "ja": "3.2。チェックサイクル"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 3.1, it is possible to write an implementation that takes a liberal approach to checking the cycles used and allows some extra cycles. The implementer must be sure that decompression failure does not occur too early and that in the case of excessive use of cycles, decompression failure does eventually occur. This test checks that:",
      "ja": "3.1節で述べたように、使用されるサイクルを確認するにリベラルなアプローチを取り、いくつかの余分なサイクルを可能にする実装を作成することが可能です。実装者は解凍障害が早すぎると、そのサイクルの過剰な使用の場合には、解凍の失敗は、最終的に発生しない発生しないことを確認する必要があります。このテストでチェックしています："
    },
    {
      "indent": 3,
      "text": "1. Decompression failure occurs eventually when there is an infinite loop.",
      "ja": "無限ループがある場合1.減圧障害は、最終的に発生します。"
    },
    {
      "indent": 3,
      "text": "at (64) :byte_copy_left pad (2) :byte_copy_right pad (2) :value pad (2) :copy_next pad (2)",
      "ja": "パッドbyte_copy_left（2）：（64）でbyte_copy_rightパッド（2）：値パッド（2）：copy_nextパッド（2）"
    },
    {
      "indent": 3,
      "text": "at(128) MULTILOAD (byte_copy_left, 4, 32, 41, 0, 34) ; Set up a 10-byte buffer",
      "ja": "で（128）MULTILOAD（byte_copy_left、4、32、41、0、34）; 10バイトのバッファを設定します"
    },
    {
      "indent": 3,
      "text": " ; Set the value to copy ; Copy it 100 times, ; output the value, ; increment the counter :loop COPY (value, 2, $byte_copy_left) COPY-OFFSET (2, 100, $copy_next) OUTPUT (value, 2) ADD ($value, 1) JUMP (loop)",
      "ja": ";コピーする値を設定します。 、それを100回コピーします。出力値は、。カウンタをインクリメント：ループCOPY（値、2、$のbyte_copy_left）COPYオフセット（2、100、$のcopy_next）OUTPUT（値は、2）（$値、1）JUMP（ループ）を追加"
    },
    {
      "indent": 3,
      "text": "If the cycles are counted exactly and cycles per bit (cpb) = 16, then decompression failure will occur at COPY-OFFSET when value = 180 = 0xB4. If cpb = 32, then decompression failure will occur when value = 361 = 0x0169. If they are not counted exactly, then decompression failure MUST occur eventually.",
      "ja": "サイクルが正確とビットあたりのサイクル（CPB）= 16カウントされる場合、次いで減圧障害がで発生すると、値= 180 = 0xB4 COPYオフセット。 CPB = 32場合、解凍の失敗は、いつ値= 361 = 0x0169を発生します。彼らは正確にカウントされない場合は、解凍の失敗は、最終的に行われなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3. Message-based Transport",
      "section_title": true,
      "ja": "3.3。メッセージベースの交通"
    },
    {
      "indent": 3,
      "text": "This section provides a set of messages to test the SigComp header over a message-based transport such as UDP. The messages test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、UDPのようなメッセージベースのトランスポート上のSigCompヘッダをテストするメッセージのセットを提供します。メッセージには、次の境界例が正しく実装されていることをテストします。"
    },
    {
      "indent": 3,
      "text": "1. The UDVM bytecode is copied to different areas of the UDVM memory.",
      "ja": "1. UDVMバイトコードは、UDVMメモリの異なる領域にコピーされます。"
    },
    {
      "indent": 3,
      "text": "2. The decompression memory size is set to an incorrect value.",
      "section_title": true,
      "ja": "2.解凍メモリサイズが不正な値に設定されています。"
    },
    {
      "indent": 3,
      "text": "3. The SigComp message is too short.",
      "section_title": true,
      "ja": "3.のSigCompメッセージが短すぎます。"
    },
    {
      "indent": 3,
      "text": "4. The destination address is invalid.",
      "section_title": true,
      "ja": "4.宛先アドレスが無効です。"
    },
    {
      "indent": 3,
      "text": "The basic version of the code used in the test is given below. Note that the code is designed to calculate the decompression memory size based on the Useful Values provided to the UDVM:",
      "ja": "試験に使用されるコードの基本的なバージョンを以下に示します。コードは、UDVMに提供有用な値に基づいて、解凍メモリサイズを計算するように設計されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": ":udvm_memory_size pad (2) :cycles_per_bit pad (2) :sigcomp_version pad (2) :partial_state_id_length pad (2) :state_length pad (2)",
      "ja": "：udvm_memory_sizeパッド（2）：cycles_per_bitパッド（2）：sigcomp_versionパッド（2）：partial_state_id_lengthパッド（2）：state_lengthパッド（2）"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": ":code_start",
      "ja": "：code_start"
    },
    {
      "indent": 3,
      "text": "; udvm_memory_size for message-based transport ; = DMS - total_message_size",
      "ja": ";メッセージベースの輸送のためudvm_memory_size。 = DMS  -  total_message_size"
    },
    {
      "indent": 3,
      "text": "ADD ($udvm_memory_size, total_message_size) OUTPUT (udvm_memory_size, 2) END-MESSAGE (0, 0, 0, 0, 0, 0, 1)",
      "ja": "（$ udvm_memory_size、total_message_size）OUTPUT（udvm_memory_size、2）END-MESSAGE ADD（0、0、0、0、0、0、1）"
    },
    {
      "indent": 3,
      "text": ":code_end",
      "ja": "：code_end"
    },
    {
      "indent": 3,
      "text": "set (header_size, 3) set (code_size, (code_end - code_start)) set (total_message_size, (header_size + code_size))",
      "ja": "セット（ヘッダサイズ、3）セット（CODE_SIZE、（code_end  -  code_start））セット（total_message_size、（ヘッダサイズ+ CODE_SIZE））"
    },
    {
      "indent": 3,
      "text": "A number of complete SigComp messages are given below, each containing some or all of the above code. In each case, it is indicated whether the message will successfully output the decompression memory size or whether it will cause a decompression failure to occur (together with the reason for the failure):",
      "ja": "完全のSigCompメッセージの数は、それぞれ、上記のコードの一部または全部を含む、以下に与えられます。それぞれの場合において、メッセージが正常に出力減圧メモリサイズは、またはそれが原因となるかどうかを解凍失敗が（失敗の理由と共に）が発生するかどうかを示しています。"
    },
    {
      "indent": 3,
      "text": "SigComp message: Effect:",
      "ja": "SigCompメッセージ：効果："
    },
    {
      "indent": 3,
      "text": "0xf8 Fails (message too short)",
      "ja": "0xf8が失敗する（メッセージ短すぎます）"
    },
    {
      "indent": 3,
      "text": "0xf800 Fails (message too short)",
      "ja": "0xf800が失敗する（メッセージ短すぎます）"
    },
    {
      "indent": 3,
      "text": "0xf800 e106 0011 2200 0223 Outputs the decompression_memory_size 0x0000 0000 0000 01",
      "ja": "0xf800のE106 0011 2200 0223出力decompression_memory_size 0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "0xf800 f106 0011 2200 0223 Fails (message too short) 0x0000 0000 0000 01",
      "ja": "0xf800 F106 0011 2200 0223（メッセージ短すぎる）0000 0000 0000 01失敗します"
    },
    {
      "indent": 3,
      "text": "0xf800 e006 0011 2200 0223 Fails (invalid destination address) 0x0000 0000 0000 01",
      "ja": "0xf800 E006 0011 2200 0223（無効な宛先アドレス）失敗0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "0xf800 ee06 0011 2200 0223 Outputs the decompression_memory_size 0x0000 0000 0000 01",
      "ja": "0xf800のee06 0011 2200 0223出力decompression_memory_size 0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "The messages should be decompressed in the order given to check that an error in one message does not interfere with the successful decompression of subsequent messages.",
      "ja": "メッセージは一つのメッセージにエラーが後続のメッセージの解凍の成功を妨げないことを確認するために与えられた順序で解凍する必要があります。"
    },
    {
      "indent": 3,
      "text": "The two messages that successfully decompress each use a total of 5 UDVM cycles.",
      "ja": "成功した各解凍2件のメッセージが5つのUDVMサイクルの合計を使用します。"
    },
    {
      "indent": 0,
      "text": "3.4. Stream-based Transport",
      "section_title": true,
      "ja": "3.4。ストリームベースの輸送"
    },
    {
      "indent": 3,
      "text": "This section provides a byte stream to test the SigComp header and delimiters over a stream-based transport such as TCP. The byte stream tests all of the boundary cases covered in Section 3.2, as well as the following cases specific to stream-based transports:",
      "ja": "このセクションでは、TCPのようなストリームベースのトランスポート上のSigCompヘッダとデリミタをテストするバイトストリームを提供します。ストリームベースのトランスポートに固有のセクション3.2でカバーされた境界例バイトストリームテストすべて、ならびに以下の例："
    },
    {
      "indent": 3,
      "text": "1. Quoted bytes are used by the record marking scheme.",
      "section_title": true,
      "ja": "1.引用符で囲まれたバイトは、レコードマーキング方式で使用されています。"
    },
    {
      "indent": 3,
      "text": "2. Multiple delimiters are used between the same pair of messages.",
      "section_title": true,
      "ja": "2.複数の区切り文字は、メッセージの同一の対の間に使用されます。"
    },
    {
      "indent": 3,
      "text": "3. Unnecessary delimiters are included at the start of the stream.",
      "section_title": true,
      "ja": "3.不要な区切り文字は、ストリームの先頭に含まれています。"
    },
    {
      "indent": 3,
      "text": "The basic version of the code used in the test is given below. Note that the code is designed to calculate the decompression memory size based on the Useful Values provided to the UDVM:",
      "ja": "試験に使用されるコードの基本的なバージョンを以下に示します。コードは、UDVMに提供有用な値に基づいて、解凍メモリサイズを計算するように設計されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": ":udvm_memory_size pad (2) :cycles_per_bit pad (2) :sigcomp_version pad (2) :partial_state_id_length pad (2) :state_length pad (2)",
      "ja": "：udvm_memory_sizeパッド（2）：cycles_per_bitパッド（2）：sigcomp_versionパッド（2）：partial_state_id_lengthパッド（2）：state_lengthパッド（2）"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "; udvm_memory_size for stream based transport = DMS / 2",
      "ja": ";ストリームベースのトランスポート= DMS / 2 udvm_memory_size"
    },
    {
      "indent": 3,
      "text": "MULTIPLY ($udvm_memory_size, 2) OUTPUT (udvm_memory_size, 2) OUTPUT (test_record_marking, 5) END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "MULTIPLY（$ udvm_memory_size、2）OUTPUT（udvm_memory_size、2）OUTPUT（test_record_marking、5）END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":test_record_marking",
      "ja": "：test_record_marking"
    },
    {
      "indent": 3,
      "text": "byte (255, 255, 255, 255, 255)",
      "ja": "バイト（255、255、255、255、255）"
    },
    {
      "indent": 3,
      "text": "The above assembly code has been compiled and used to generate the following byte stream:",
      "ja": "上記のアセンブリコードはコンパイルされ、次のバイトストリームを生成するために使用されています："
    },
    {
      "indent": 3,
      "text": "0xffff f801 7108 0002 2200 0222 a092 0523 0000 0000 0000 00ff 00ff 0x03ff ffff ffff ffff f801 7e08 0002 2200 0222 a3d2 0523 0000 0000 0x0000 00ff 04ff ffff ffff ffff ffff ff",
      "ja": "7108 0222 2200 0523 0000 0002 0000 0000 FFFF FFFF 0xFFFFのF801のA092は00FF F801 0x03ff 7e08 a3d2 0222 0523 2200 0000 0002 0000 FFFF FFFF FFFF 00FF 00FFは0x0000 FFFF FFを04ff FFFF"
    },
    {
      "indent": 3,
      "text": "Note that this byte stream can be divided into five distinct portions (two SigComp messages and three sets of delimiters) as illustrated below:",
      "ja": "以下に示すように、このバイトストリームは、5つの別個の部分（2つのSigCompメッセージとデリミタ3組）に分割することができることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Portion of byte stream: Meaning:",
      "ja": "バイトストリームの一部：意味："
    },
    {
      "indent": 3,
      "text": "0xffff Delimiter",
      "ja": "0xffffの区切り文字"
    },
    {
      "indent": 3,
      "text": "0xf801 7108 0002 2200 0222 a092 0523 First message 0x0000 0000 0000 00ff 00ff 03ff ffff",
      "ja": "0xf801 7108 0002 2200 0222 A092 0523まずメッセージ0000 0000 0000 00FF 00FFの03FFのFFFF"
    },
    {
      "indent": 3,
      "text": "0xffff ffff Delimiter",
      "ja": "0xffffのFFFFデリミタ"
    },
    {
      "indent": 3,
      "text": "0xf801 7e08 0002 2200 0222 a3d2 0523 Second message 0x0000 0000 0000 00ff 04ff ffff ff",
      "ja": "0000 0000 0000 0523第二にメッセージ00FF 04ffのFFFF FFのa3d2 0xf801 7e08 0002 2200 0222"
    },
    {
      "indent": 3,
      "text": "0xffff ffff ffff Delimiter",
      "ja": "0xFFFFのFFFF FFFFデリミタ"
    },
    {
      "indent": 3,
      "text": "When the complete byte stream is supplied to the decompressor dispatcher, the record marking scheme must use the delimiters to partition the stream into two distinct SigComp messages. Both of these messages successfully output the decompression memory size (as a 2-byte value), followed by 5 consecutive 0xff bytes to test that the record marking scheme is working correctly. A total of 11 UDVM cycles are used in each case.",
      "ja": "完全なバイトストリームは、デコンプレッサディスパッチャに供給されると、レコードのマーキングスキームは、2つの異なるのSigCompメッセージにストリームを分割する区切り文字を使用する必要があります。スキームマーキングレコードが正常に動作していることをテストするために連続5 0xffのバイトに続くこれらのメッセージ正常出力減圧メモリサイズ（2バイト値として）の両方。 11 UDVMサイクルの合計は、それぞれの場合に使用されています。"
    },
    {
      "indent": 3,
      "text": "It must also be checked that the dispatcher can handle the same error cases as covered in Section 3.2. Each of the following byte streams should cause a decompression failure to occur for the reason stated:",
      "ja": "また、3.2節でカバーと、ディスパッチャは、同じエラーケースを処理できることを確認しなければなりません。以下のバイトストリームのそれぞれは述べた理由で発生するの解凍失敗の原因となる必要があります。"
    },
    {
      "indent": 3,
      "text": "Byte stream: Reason for failure:",
      "ja": "バイトストリーム：失敗の理由："
    },
    {
      "indent": 3,
      "text": "0xf8ff ff Message too short",
      "ja": "0xf8ff FFメッセージが短すぎます"
    },
    {
      "indent": 3,
      "text": "0xf800 ffff Message too short",
      "ja": "0xf800 FFFFメッセージが短すぎます"
    },
    {
      "indent": 3,
      "text": "0xf801 8108 0002 2200 0222 a092 0523 ffff Message too short 0x0000 0000 0000 00ff 00ff 03ff ffff",
      "ja": "8108 0002 2200 0222 0xf801はA092 0523 FFFFメッセージが短すぎる0000 0000 0000 00FF 00FFの03FFのFFFF"
    },
    {
      "indent": 3,
      "text": "0xf801 7008 0002 2200 0222 a092 0523 ffff Invalid destination 0x0000 0000 0000 00ff 04ff ffff ff",
      "ja": "0xf801 7008 0002 2200 0222 0523 A092 FFFF無効な宛先0000 0000 0000 00FF 04ffのFFFFのFF"
    },
    {
      "indent": 0,
      "text": "3.5. Input Past the End of a Message",
      "section_title": true,
      "ja": "3.5。メッセージの最後過去の入力"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test that the implementation correctly handles input past the end of a SigComp message. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、実装が正しくのSigCompメッセージの終わりを越えて入力を処理することをテストするためにアセンブリコードを与えます。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. An INPUT instruction requests data that lies beyond the end of the message. In this case, the dispatcher should not return any data to the UDVM. Moreover, the message bytes held by the dispatcher should still be available for retrieval by subsequent INPUT instructions.",
      "ja": "1. INPUT命令は、メッセージの最後向こうにあるデータを要求します。この場合、ディスパッチャはUDVMにデータを戻しません。また、ディスパッチャによって保持されたメッセージのバイトは依然として次の入力指示による検索のために利用可能であるべきです。"
    },
    {
      "indent": 3,
      "text": "2. The INPUT-BYTES instruction is used after part of a byte has been input (e.g., by the INPUT-BITS instruction). In this case, the remaining partial byte must be discarded, even if the INPUT-BYTES instruction requests data that lies beyond the end of the message.",
      "ja": "バイトの部分（INPUTビット命令で、例えば）が入力された後2.入力バイト命令が使用されます。この場合、残りの部分のバイトは、INPUT-BYTES命令はメッセージの終わりを超えてあるデータを要求した場合でも、廃棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :input_bit_order pad (2) :result pad (1) :result_lsb pad (6) :right",
      "ja": "：byte_copy_leftパッド（2）：byte_copy_rightパッド（2）：パッドinput_bit_order（2）：結果のパッド（1）：result_lsbパッド（6）：右"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "LOAD (byte_copy_left, result) LOAD (byte_copy_right, right)",
      "ja": "LOAD（byte_copy_left、結果）LOAD（byte_copy_right、右）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：開始"
    },
    {
      "indent": 3,
      "text": "; Input bits to ensure that the remaining message is not byte aligned",
      "ja": ";残りのメッセージはバイト整列されないことを確実にするために入力ビット"
    },
    {
      "indent": 3,
      "text": "INPUT-BITS (9, result, decompression_failure1) ; Input 0x1FF (9 bits)",
      "ja": "INPUT-BITS（9、結果、decompression_failure1）。入力0x1FF（9ビット）"
    },
    {
      "indent": 3,
      "text": "; Attempt to read 7 bytes",
      "ja": "; 7つのバイトを読み取ろう"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (7, result, next_bytes) ; This should fail, throw away ; 7 bits with value Ox7a and ; jump to next_bytes",
      "ja": "INPUTバイト（7、結果、next_bytes）。これは、失敗捨てるべきです。値Ox7aとを有する7ビット。 next_bytesにジャンプ"
    },
    {
      "indent": 3,
      "text": ":decompression_failure1 DECOMPRESSION-FAILURE ; This instruction is never ; executed but is used to ; separate success and failure ; to input bytes.",
      "ja": "：圧縮解除-FAILURE decompression_failure1。この命令は、決してありません。実行これらに使用されています。別の成功と失敗。入力バイトへ。"
    },
    {
      "indent": 3,
      "text": ":next_bytes",
      "ja": "：next_bytes"
    },
    {
      "indent": 3,
      "text": "; Read 7 bits - this removes the byte alignment of the message",
      "ja": "; 7ビットを読む - これは、メッセージのバイトアライメントを除去します"
    },
    {
      "indent": 3,
      "text": "; If the bits have not been thrown away where they should be, then ; the message will be 1 byte longer than necessary and the output ; will be incorrect.",
      "ja": ";ビットが捨てられていない場合、彼らはその後、あるべき場所。メッセージには、必要に応じて出力より1台のバイト長くなります。不正確になります。"
    },
    {
      "indent": 3,
      "text": "INPUT-BITS (7, result, decompression_failure1) ; Input 0x00 (7 bits)",
      "ja": "INPUT-BITS（7、結果、decompression_failure1）。入力は0x00（7ビット）"
    },
    {
      "indent": 3,
      "text": "; Read 2 bytes",
      "ja": "; 2つのバイトを読みます"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (2, result, decompression_failure1) ; Throw away 1 bit value 0 ; Input 0x6869 OUTPUT (result, 2) ; Output 0x6869",
      "ja": "INPUTバイト（2、その結果、decompression_failure1）。 1ビット値0を捨てます。入力0x6869出力（結果2）。出力0x6869"
    },
    {
      "indent": 3,
      "text": " ; Attempt to read more bits than INPUT-BITS (16, result, bits) ; there are to ensure they ; remain available",
      "ja": "; INPUT-BITS（16、その結果、ビット）以上のビットを読み取るしようとします。彼らを確保するためにあります。引き続き使用可能"
    },
    {
      "indent": 3,
      "text": ":decompression_failure2 DECOMPRESSION-FAILURE ; This instruction is never ; executed but is used to ; separate success and failure ; to input bits.",
      "ja": "：圧縮解除-FAILURE decompression_failure2。この命令は、決してありません。実行これらに使用されています。別の成功と失敗。入力ビットに。"
    },
    {
      "indent": 3,
      "text": ":bits",
      "ja": "：ビット"
    },
    {
      "indent": 3,
      "text": "; Read 8 bits",
      "ja": "; 8ビットを読みます"
    },
    {
      "indent": 3,
      "text": "INPUT-BITS (8, result, decompression_failure2) ; Input 0x21 or fail OUTPUT (result_lsb, 1) ; Output 0x21",
      "ja": "INPUTビット（8、結果、decompression_failure2）。入力0x21で又は失敗OUTPUT（result_lsb、1）。出力0x21で"
    },
    {
      "indent": 3,
      "text": ":end_message",
      "ja": "：end_message"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "If the compressed message is 0xfffa 0068 6921, then the code terminates successfully with the output 0x6869 21, and a total of 23 UDVM cycles are used. However, if the compressed message is 0xfffa 0068 69, then decompression failure occurs (at the final INPUT-BITS).",
      "ja": "圧縮されたメッセージは0xfffa 0068 6921であれば、コードが出力0x6869 21で正常に終了し、23 UDVMサイクルの合計が使用されます。圧縮されたメッセージは0xfffa 0068 69である場合は、その後減圧障害（最終INPUTビットで）起こります。"
    },
    {
      "indent": 0,
      "text": "4. Torture Tests for State Handler",
      "section_title": true,
      "ja": "状態ハンドラ4.拷問テスト"
    },
    {
      "indent": 3,
      "text": "The following sections give code to test the various functions of the SigComp state handler.",
      "ja": "以下のセクションでは、SigCompの状態ハンドラの様々な機能をテストするためのコードを与えます。"
    },
    {
      "indent": 0,
      "text": "4.1. SigComp Feedback Mechanism",
      "section_title": true,
      "ja": "4.1。 SigCompフィードバックメカニズム"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the SigComp feedback mechanism. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、SigCompのフィードバック機構をテストするためにアセンブリコードを与えます。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. Both the short and the long versions of the SigComp feedback item are used.",
      "ja": "1.ショートとのSigCompフィードバックアイテムの長いバージョンが使用されている両方。"
    },
    {
      "indent": 3,
      "text": "2. The chain of returned SigComp parameters is terminated by a non-zero value.",
      "ja": "返さのSigCompパラメータの2鎖は、非ゼロ値によって終了されます。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":type pad (1) :type_lsb pad (1)",
      "ja": "：型パッド（1）：type_lsbパッド（1）"
    },
    {
      "indent": 3,
      "text": ":requested_feedback_location pad (1) :requested_feedback_length pad (1) :requested_feedback_bytes pad (127)",
      "ja": "：requested_feedback_locationパッド（1）：requested_feedback_lengthパッド（1）：パッド（127）requested_feedback_bytes"
    },
    {
      "indent": 3,
      "text": ":returned_parameters_location pad (2) :length_of_partial_state_id_a pad (1) :partial_state_identifier_a pad (6) :length_of_partial_state_id_b pad (1) :partial_state_identifier_b pad (12) :length_of_partial_state_id_c pad (1) :partial_state_identifier_c pad (20) :terminate_returned_parameters pad (1)",
      "ja": "：returned_pa​​rameters_locationパッド（2）：length_of_partial_state_id_aパッド（1）：partial_state_identifier_aパッド（6）：length_of_partial_state_id_bパッド（1）：partial_state_identifier_bパッド（12）：length_of_partial_state_id_cパッド（1）：partial_state_identifier_cパッド（20）：terminate_returned_pa​​rametersパッド（1）"
    },
    {
      "indent": 3,
      "text": "align (128)",
      "ja": "（128）整列"
    },
    {
      "indent": 3,
      "text": "set (q_bit, 1) set (s_bit, 0) set (i_bit, 0) set (flags, (((4 * q_bit) + (2 * s_bit)) + i_bit))",
      "ja": "セット（q_bit、1）セット（s_bit、0）セット（i_bit、0）セット（フラグ、（（（4 * q_bit）+（2 * s_bit））+ i_bit））"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, type_lsb, decompression_failure)",
      "ja": "INPUTバイト（1、type_lsb、decompression_failure）"
    },
    {
      "indent": 3,
      "text": "COMPARE ($type, 1, short_feedback_item, long_feedback_item, decompression_failure)",
      "ja": "COMPARE（$タイプ、1、short_feedback_item、long_feedback_item、decompression_failure）"
    },
    {
      "indent": 3,
      "text": ":short_feedback_item",
      "ja": "：short_feedback_item"
    },
    {
      "indent": 3,
      "text": "set (requested_feedback_data, 127) set (short_feedback_value, ((flags * 256) + requested_feedback_data))",
      "ja": "セット（requested_feedback_data、127）を設定（short_feedback_value、（（フラグ* 256）+ requested_feedback_data））"
    },
    {
      "indent": 3,
      "text": "LOAD (requested_feedback_location, short_feedback_value) JUMP (return_sigcomp_parameters)",
      "ja": "LOAD（requested_feedback_location、short_feedback_value）JUMP（return_sigcomp_parameters）"
    },
    {
      "indent": 3,
      "text": ":long_feedback_item",
      "ja": "：long_feedback_item"
    },
    {
      "indent": 3,
      "text": "set (requested_feedback_field, 255) set (long_feedback_value, ((flags * 256) + requested_feedback_field))",
      "ja": "セット（requested_feedback_field、255）セット（long_feedback_value、（（旗* 256）+ requested_feedback_field））"
    },
    {
      "indent": 3,
      "text": "LOAD (requested_feedback_location, long_feedback_value) MEMSET (requested_feedback_bytes, 127, 1, 1)",
      "ja": "LOAD（requested_feedback_location、long_feedback_value）のmemset（requested_feedback_bytes、127、1、1）"
    },
    {
      "indent": 3,
      "text": ":return_sigcomp_parameters",
      "ja": "：return_sigcomp_parameters"
    },
    {
      "indent": 3,
      "text": "set (cpb, 0) set (dms, 1) set (sms, 0) set (sigcomp_version, 1)",
      "ja": "セット（CPB、0）セット（DMS、1）セット（SMS、0）セット（sigcomp_version、1）"
    },
    {
      "indent": 3,
      "text": "set (parameters_msb, (((64 * cpb) + (8 * dms)) + sms)) set (sigcomp_parameters, ((256 * parameters_msb) + sigcomp_version))",
      "ja": "セット（parameters_msb、（（（64 *のCPB）+（8×DMS））+ SMS））を設定（sigcomp_parameters、（（256 * parameters_msb）+ sigcomp_version））"
    },
    {
      "indent": 3,
      "text": "LOAD (returned_parameters_location, sigcomp_parameters)",
      "ja": "LOAD（returned_pa​​rameters_location、sigcomp_parameters）"
    },
    {
      "indent": 3,
      "text": "LOAD (length_of_partial_state_id_a, 1536) ; length 6 first byte 0 LOAD (length_of_partial_state_id_b, 3072) ; length 12 first byte 0 LOAD (length_of_partial_state_id_c, 5120) ; length 20 first byte 0 LOAD (terminate_returned_parameters, 5376) ; length 21 ; used to terminate the ; returned parameters MEMSET (partial_state_identifier_a, 6, 0, 1) MEMSET (partial_state_identifier_b, 12, 0, 1) MEMSET (partial_state_identifier_c, 20, 0, 1)",
      "ja": "LOAD（length_of_partial_state_id_a 1536）。長さ6最初のバイト0 LOAD（length_of_partial_state_id_b、3072）。長さ12最初のバイト0 LOAD（length_of_partial_state_id_c、5120）。長さ20最初のバイト0 LOAD（terminate_returned_pa​​rameters、5376）。長さ21;終了するために使用されます。返されるパラメータのmemset（partial_state_identifier_a、6、0、1）のmemset（partial_state_identifier_b、12、0、1）のmemset（partial_state_identifier_c、20、0、1）"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (requested_feedback_location, returned_parameters_location, 0, 0, 0, 0, 0) :decompression_failure DECOMPRESSION-FAILURE",
      "ja": "END-MESSAGE（requested_feedback_location、returned_pa​​rameters_location、0、0、0、0、0）：decompression_failure解凍-FAILURE"
    },
    {
      "indent": 3,
      "text": "When the above code is executed, it supplies a requested feedback item to the state handler. If the compressed message is 0x00, then the short (1-byte) version of the feedback is used. Executing the bytecode in this case costs a total of 52 UDVM cycles. Assuming that the feedback request is successful, the feedback item should be returned in the first SigComp message to be sent in the reverse direction. The SigComp message returning the feedback should begin as follows:",
      "ja": "上記のコードが実行されると、ステートハンドラに要求されたフィードバック・アイテムを供給する。圧縮されたメッセージが0x00である場合には、フィードバックの短い（1バイト）バージョンが使用されます。この場合には、バイトコードを実行すると、52 UDVMサイクルの合計がかかります。フィードバック要求が成功したと仮定すると、フィードバック項目は、逆方向に送信される最初のSigCompメッセージに返されるべきです。次のようなフィードバックを返すのSigCompメッセージを開始する必要があります："
    },
    {
      "indent": 3,
      "text": "+---+---+---+---+---+---+---+---+\n| 1   1   1   1   1   1 |   X   |   first header byte\n+---+---+---+---+---+---+---+---+\n| 0 |            127            |   returned feedback field\n+---+---+---+---+---+---+---+---+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "So the first 2 bytes of the returning SigComp message should be 0xfn7f where n = c, d, e, or f (the choice of n is determined by the compressor generating the returning SigComp message, which is not under the control of the above code).",
      "ja": "そう復帰のSigCompメッセージの最初の2つのバイトは、ここで、n = C、D、E、又はF 0xfn7fされるべきである（n個の選択は、上記のコードの制御下にない復帰のSigCompメッセージを生成する圧縮機によって決定され）。"
    },
    {
      "indent": 3,
      "text": "If the compressed message is 0x01, then the long version of the feedback item is used. Executing the bytecode in this case costs a total of 179 UDVM cycles and the SigComp message returning the feedback should begin as follows:",
      "ja": "圧縮されたメッセージが0x01である場合、フィードバックアイテムの長いバージョンが使用されます。この場合には、バイトコードを実行すると、179 UDVMサイクルの総コストと、次のようなフィードバックを返すのSigCompメッセージを開始する必要があります："
    },
    {
      "indent": 3,
      "text": "+---+---+---+---+---+---+---+---+\n| 1   1   1   1   1   1 |   X   |   first header byte\n+---+---+---+---+---+---+---+---+\n| 1 |            127            |   returned feedback length\n+---+---+---+---+---+---+---+---+\n|               1               |              ^\n+---+---+---+---+---+---+---+---+              |\n|               2               |              |\n+---+---+---+---+---+---+---+---+\n|               3               |   returned feedback field\n+---+---+---+---+---+---+---+---+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "So the first 129 bytes of the SigComp message should be 0xfnff 0102 0304 ... 7e7f where n = c, d, e, or f as above.",
      "ja": "だからのSigCompメッセージの最初の129のバイトは、n = C、D、E、又はFとして上記0102 0304 ... 7e7f 0xfnffであるべきです。"
    },
    {
      "indent": 3,
      "text": "As well as testing the requested and returned feedback items, the above code also announces values for each of the SigComp parameters. The supplied version of the code announces only the minimum possible values for the cycles_per_bit, decompression_memory_size, state_memory_size, and SigComp_version (although this can easily be adjusted to test different values for these parameters).",
      "ja": "同様に、要求されて返さフィードバック項目を試験として、上記のコードは、SigCompのパラメータの各々の値を発表しました。 （これは簡単にこれらのパラメータの異なる値をテストするために調整することができるが）コードの供給バージョンはcycles_per_bit、decompression_memory_size、state_memory_size、及びSigComp_versionに対してのみ可能な最小値を発表しました。"
    },
    {
      "indent": 3,
      "text": "The code should also announce the availability of state items with the following partial state identifiers:",
      "ja": "コードは、次の部分状態識別子と状態項目の可用性を発表する必要があります。"
    },
    {
      "indent": 3,
      "text": "0x0001 0203 0405 0x0001 0203 0405 0607 0809 0a0b 0x0001 0203 0405 0607 0809 0a0b 0c0d 0e0f 1011 1213",
      "ja": "0x0001 0203 0405 1213 0a0b 0c0d 0e0f 1011 0a0bは0x0001 0203 0405 0607 0809 0405 0607 0809 0203は0x0001"
    },
    {
      "indent": 3,
      "text": "Note that different implementations may make use of the announcement information in different ways. It is a valid implementation choice to simply ignore all of the announcement data and use only the minimum resources that are guaranteed to be available to all endpoints. However, the above code is useful for checking that an endpoint interprets the announcement data correctly (in particular ensuring that it does not mistakenly use resources that have not in fact been announced).",
      "ja": "異なる実装が異なる方法で告知情報を利用することができることに注意してください。単に、発表データのすべてを無視して、すべてのエンドポイントが利用できることが保証されているだけ最小限のリソースを使用するには、有効な実装の選択肢です。しかし、上記のコードは、（特に、それが誤って実際に発表されていないリソースを使用しないことを確実にすること）エンドポイントが正しく告知データを解釈することを確認するのに便利です。"
    },
    {
      "indent": 0,
      "text": "4.2. State Memory Management",
      "section_title": true,
      "ja": "4.2。状態のメモリ管理"
    },
    {
      "indent": 3,
      "text": "The following section gives assembly code to test the memory management features of the state handler. The code checks that the correct states are retained by the state handler when insufficient memory is available to store all of the requested states.",
      "ja": "次のセクションでは、状態ハンドラのメモリ管理機能をテストするためのアセンブリコードを与えます。コードは、十分なメモリが要求された状態のすべてを記憶するのに利用可能であるときに正しい状態が状態ハンドラにより保持されていることをチェックします。"
    },
    {
      "indent": 3,
      "text": "The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. A state item is created that exceeds the total state_memory_size for the compartment.",
      "ja": "1.状態項目は、区画の合計state_memory_sizeを超えていると作成されます。"
    },
    {
      "indent": 3,
      "text": "2. States are created with a non-zero state_retention_priority.",
      "section_title": true,
      "ja": "2.国は、非ゼロstate_retention_priorityで作成されます。"
    },
    {
      "indent": 3,
      "text": "3. A new state item is created that has a lower state_retention_priority than existing state items in the compartment.",
      "ja": "3.新しい状態項目は、区画内の既存の状態のアイテムより低いstate_retention_priorityを有するように作成されます。"
    },
    {
      "indent": 3,
      "text": "For the duration of this test, it is assumed that all states will be saved in a single compartment with a state_memory_size of 2048 bytes.",
      "ja": "この試験の期間中、すべての状態が2048バイトのstate_memory_size有する単一の区画に保存されることが想定されます。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :order pad (2) :type pad (1) :type_lsb pad (1) :state_length pad (2) :state_retention_priority pad (2) at(127) :decompression_failure at (128)",
      "ja": "：パッドbyte_copy_left（2）：byte_copy_rightパッド（2）：注文のパッド（2）：型パッド（1）：type_lsbパッド（1）：state_lengthパッド（2）：（127）でstate_retention_priorityパッド（2）：decompression_failure（AT 128）"
    },
    {
      "indent": 3,
      "text": "MULTILOAD (byte_copy_left, 2, state_start, order_data)",
      "ja": "MULTILOAD（byte_copy_left、2、STATE_START、ORDER_DATA）"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, type_lsb, decompression_failure) COMPARE ($type, 5, general_test, large_state, verify_state)",
      "ja": "INPUT-BYTES（1、type_lsb、decompression_failure）COMPARE（$タイプ、5、general_test、large_state、verify_state）"
    },
    {
      "indent": 3,
      "text": ":general_test",
      "ja": "：general_test"
    },
    {
      "indent": 3,
      "text": "COMPARE ($type, 3, start, state_present, state_not_present)",
      "ja": "COMPARE（$タイプ、3、スタート、state_present、state_not_present）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：開始"
    },
    {
      "indent": 3,
      "text": "MULTIPLY ($type, 6) ADD ($type, order_data) LOAD (order, $type) ADD ($type, 6)",
      "ja": "MULTIPLY（$タイプ、6）（$タイプ、ORDER_DATA）LOAD（オーダー、$タイプ）ADD ADD（$タイプを、6）"
    },
    {
      "indent": 3,
      "text": "; Finish with the value (order_data + 6*n) in order where ; n is the input value 0x00, 0x01, or 0x02 ; type = order + 6 ; These values are used to index into the 'order_data' ; that is used to work out state retention priorities and lengths",
      "ja": ";値（ORDER_DATA + 6×n個）で終了ために、 nが、入力値は0x00、0x01の、または0x02です。タイプ=オーダー+ 6。これらの値は、「ORDER_DATA」内にインデックスを付けるために使用されています。それは、状態保持優先事項と長さをうまくするために使用されます"
    },
    {
      "indent": 3,
      "text": ":loop",
      "ja": "：ループ"
    },
    {
      "indent": 3,
      "text": "COPY ($order, 2, state_retention_priority) COMPARE ($order, $type, continue, end, decompression_failure)",
      "ja": "COPY（$順序、2、state_retention_priority）（$順、$タイプ、継続、終了、decompression_failure）を比較"
    },
    {
      "indent": 3,
      "text": ":continue",
      "ja": "：持続する"
    },
    {
      "indent": 3,
      "text": "; Set up a state creation each time through the loop",
      "ja": ";ループを通る状態の作成を毎回設定します"
    },
    {
      "indent": 3,
      "text": "LOAD (state_length, $state_retention_priority) MULTIPLY ($state_length, 256) STATE-CREATE ($state_length, state_start, 0, 6, $state_retention_priority)",
      "ja": "LOAD（state_length、$ state_retention_priority）MULTIPLY（$のstate_length、256）STATE-CREATE（$のstate_length、STATE_START、0、6、$のstate_retention_priority）"
    },
    {
      "indent": 3,
      "text": "ADD ($order, 2) JUMP (loop)",
      "ja": "ADD（$オーダー、2）JUMP（ループ）"
    },
    {
      "indent": 3,
      "text": ":state_present",
      "ja": "：state_present"
    },
    {
      "indent": 3,
      "text": "; Access the states that should be present STATE-ACCESS (state_identifier_a, 6, 0, 0, 0, 0) STATE-ACCESS (state_identifier_b, 6, 0, 0, 0, 0)",
      "ja": ";本ステートアクセスでなければならない状態（state_identifier_a、6、0、0、0、0）STATE-ACCESS（state_identifier_b、6、0、0、0、0）にアクセス"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier_c, 6, 0, 0, 0, 0) STATE-ACCESS (state_identifier_e, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": "STATE-ACCESS（state_identifier_c、6、0、0、0、0）STATE-ACCESS（state_identifier_e、6、0、0、0、0）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": ":state_not_present",
      "ja": "：state_not_present"
    },
    {
      "indent": 3,
      "text": "; Check that the state that shouldn't be present is not present. STATE-ACCESS (state_identifier_d, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": ";存在してはならない状態が存在しないことを確認してください。 STATE-ACCESS（state_identifier_d、6、0、0、0、0）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": ":large_state",
      "ja": "：large_state"
    },
    {
      "indent": 3,
      "text": "STATE-CREATE (2048, state_start, 0, 6, 0) JUMP (end)",
      "ja": "STATE-CREATE（2048、STATE_START、0、6、0）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": ":verify_state",
      "ja": "：verify_state"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (large_state_identifier, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": "STATE-ACCESS（large_state_identifier、6、0、0、0、0）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": ":end",
      "ja": "：終わり"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "at (512)",
      "ja": "で（512）"
    },
    {
      "indent": 3,
      "text": ":state_start",
      "ja": "：STATE_START"
    },
    {
      "indent": 3,
      "text": "byte (116, 101, 115, 116)",
      "ja": "バイト（116、101、115、116）"
    },
    {
      "indent": 3,
      "text": ":order_data ; This data is used to generate the retention priority ; and state length of each state creation.",
      "ja": "：ORDER_DATA;このデータは保持優先順位を生成するために使用されます。各状態の作成と状態の長さ。"
    },
    {
      "indent": 3,
      "text": "word (0, 1, 2, 3, 4, 3, 2, 1, 0)",
      "ja": "ワード（0、1、2、3、4、3、2、1、0）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_a",
      "ja": "：state_identifier_a"
    },
    {
      "indent": 3,
      "text": "byte (142, 234, 75, 67, 167, 135)",
      "ja": "バイト（142、234、75、67、167、135）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_b",
      "ja": "：state_identifier_b"
    },
    {
      "indent": 3,
      "text": "byte (249, 1, 14, 239, 86, 123)",
      "ja": "バイト（249、1、14、239、86、123）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_c",
      "ja": "：state_identifier_c"
    },
    {
      "indent": 3,
      "text": "byte (35, 154, 52, 107, 21, 166)",
      "ja": "バイト（35、154、52、107、21、166）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_d",
      "ja": "：state_identifier_d"
    },
    {
      "indent": 3,
      "text": "byte (180, 15, 192, 228, 77, 44)",
      "ja": "バイト（180、15、192、228、77、44）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_e",
      "ja": "：state_identifier_e"
    },
    {
      "indent": 3,
      "text": "byte (212, 162, 33, 71, 230, 10)",
      "ja": "バイト（212、162、33、71、230、10）"
    },
    {
      "indent": 3,
      "text": ":large_state_identifier",
      "ja": "：large_state_identifier"
    },
    {
      "indent": 3,
      "text": "byte (239, 242, 188, 15, 182, 175)",
      "ja": "バイト（239、242、188、15、182、175）"
    },
    {
      "indent": 3,
      "text": "The above code must be executed a total of 7 times in order to complete the test. Each time the code is executed, a 1-byte compressed message should be provided as below. The effects of the messages are given below. States are described in the form (name, x, y) where name corresponds to the name of the identifier in the mnemonic code, x is the length of the state, and y is the retention priority of the state.",
      "ja": "上記のコードは、テストを完了するために7回の合計を実行しなければなりません。コードが実行されるたびに、1バイトの圧縮されたメッセージは、以下のように提供されるべきです。メッセージの効果は以下の通りです。状態は名前がニーモニックコード内の識別子の名前に対応するフォーム（名前、X、Y）に記載されており、xは状態の長さであり、そしてYは、状態の保持優先度です。"
    },
    {
      "indent": 3,
      "text": "Message: Effect: #cycles: 0x00 create states: 811 (a,0,0), (b,256,1), (c,512,2) 0x01 create states: 2603 (d,768,3), (e,1024,4) - deleting a, b, c 0x02 create states: 811 (c,512,2), - deleting d (b,256,1), (a,0,0) 0x03 access states a,b,c,e 1805 0x04 access state d - not present so decompression failure 0x05 create states: 2057 (large, 2048,0) - deleting a, b, c, e 0x06 access large state 1993",
      "ja": "メッセージ：効果：#cycles：状態の作成は0x00：811（0,0）、（B、256,1）、（C、512,2）状態を作成0×01：2603（D、768,3）、（E 、1024,4） - 、B、C、0×02を削除して状態を作成する： - 削除D（B、256,1）、（0,0）0x03のアクセス状態、B、811（C、512,2）を、 C、E 1805 0x04のアクセス状態D  - は存在しない減圧障害ので、0x05の状態を作成する：2057（大、2048,0） -  E 0x06でアクセス大きい状態1993、B、Cを削除"
    },
    {
      "indent": 3,
      "text": "Note that as new states are created, some of the existing states will be pushed out of the compartment due to lack of memory.",
      "ja": "新しい状態が作成されると、既存の状態の一部がメモリ不足のためコンパートメントから押し出されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.3. Multiple Compartments",
      "section_title": true,
      "ja": "4.3。複数のコンパートメント"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the interaction between multiple SigComp compartments. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、複数のSigCompコンパートメントとの間の相互作用をテストするためのアセンブリコードを与えます。コードは以下の境界例が正しく実装されていることをテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The same state item is saved in more than one compartment.",
      "section_title": true,
      "ja": "1.同じ状態の項目は、複数の区画に保存されます。"
    },
    {
      "indent": 3,
      "text": "2. A state item stored in multiple compartments has the same state identifier but a different state_retention_priority in each case.",
      "ja": "2.複数の区画に格納された状態の項目が同じ状態識別子が、それぞれの場合において異なるstate_retention_priorityを有しています。"
    },
    {
      "indent": 3,
      "text": "3. A state item is deleted from one compartment but still belongs to a different compartment.",
      "ja": "3.状態項目は、一つの区画から削除し、それでも異なる区画に属しています。"
    },
    {
      "indent": 3,
      "text": "4. A state item belonging to multiple compartments is deleted from every compartment to which it belongs.",
      "ja": "前記複数の区画に属する状態項目は、それが属しているすべての区画から削除されます。"
    },
    {
      "indent": 3,
      "text": "The test requires a total of three compartments to be available, which will be referred to as Compartment 0, Compartment 1, and Compartment 2. Each of the three compartments should have a state_memory_size of 2048 bytes.",
      "ja": "試験は、3つの区画の合計が2048バイトのstate_memory_sizeを有するべきコンパートメント0、コンパートメント1、コンパートメント2の3つの区画のそれぞれと称する、利用可能であることが必要です。"
    },
    {
      "indent": 3,
      "text": "The assembly code for the test is given below:",
      "ja": "試験のためのアセンブリコードを以下に示します："
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "（64）で、"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left pad (2) :byte_copy_right pad (2) :type pad (1) :type_lsb pad (1)",
      "ja": "：パッドbyte_copy_left（2）：byte_copy_rightパッド（2）：型パッド（1）：type_lsbパッド（1）"
    },
    {
      "indent": 3,
      "text": "at (127) :decompression_failure at (128)",
      "ja": "時（127）（128）でdecompression_failure"
    },
    {
      "indent": 3,
      "text": "MULTILOAD (byte_copy_left, 2, state_start, state_end) INPUT-BYTES (1, type_lsb, decompression_failure) COMPARE ($type, 3, create_state, overwrite_state, temp)",
      "ja": "MULTILOAD（byte_copy_left、2、STATE_START、state_end）INPUTバイト（1、type_lsb、decompression_failure）COMPARE（$型、3、create_state、overwrite_state、TEMP）"
    },
    {
      "indent": 3,
      "text": ":temp",
      "ja": "：一時"
    },
    {
      "indent": 3,
      "text": "COMPARE ($type, 5, overwrite_state, access_state, error_conditions)",
      "ja": "COMPARE（$タイプ、5、overwrite_state、access_state、error_conditions）"
    },
    {
      "indent": 3,
      "text": ":create_state ; starting byte identified by $type according to input: ; Input 0x00 0x01 0x02 ; $type 512 513 514",
      "ja": "：create_state;入力に応じた$タイプによって識別されるバイトを始めます;入力は0x00 0x01の0x02の。 $タイプ512 513 514"
    },
    {
      "indent": 3,
      "text": "ADD ($type, state_start) STATE-CREATE (448, $type, 0, 6, 0)",
      "ja": "ADD（$型、STATE_START）STATE-CREATE（448、$タイプ、0、6、0）"
    },
    {
      "indent": 3,
      "text": "; create state again, beginning in different place in buffer ; starting byte identified by $type according to input: ; Input 0x00 0x01 0x02",
      "ja": ";バッファ内の別の場所で始めて、再び状態を作成します。入力に応じた$タイプによって識別されるバイトを始めます;入力は0x00 0x01を0x02で"
    },
    {
      "indent": 3,
      "text": "; $type 515 516 517",
      "ja": "; $タイプ515 516 517"
    },
    {
      "indent": 3,
      "text": "ADD ($type, 3) STATE-CREATE (448, $type, 0, 6, 0)",
      "ja": "（$タイプ、3）STATE-CREATE ADD（448、$タイプ、0、6、0）"
    },
    {
      "indent": 3,
      "text": "; create a third time beginning in different place again ; starting byte identified by $type according to input: ; Input 0x00 0x01 0x02 ; $type 516 517 515",
      "ja": ";再び別の場所に始まる第三の時間を作成します。入力に応じた$タイプによって識別されるバイトを始めます;入力は0x00 0x01の0x02の。 $タイプ516 517 515"
    },
    {
      "indent": 3,
      "text": "SUBTRACT ($type, temp_one) REMAINDER ($type, 3) ADD ($type, temp_two) STATE-CREATE (448, $type, 0, 6, 0)",
      "ja": "SUBTRACT（$型、temp_one）余り（$タイプ、3）（$型、temp_two）STATE-CREATE（448、$型、0、6、0）を追加"
    },
    {
      "indent": 3,
      "text": ":common_state",
      "ja": "：common_state"
    },
    {
      "indent": 3,
      "text": "STATE-CREATE (448, temp_three, 0, 6, $type) JUMP (end)",
      "ja": "STATE-CREATE（448、temp_three、0、6、$型）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": ":overwrite_state",
      "ja": "：overwrite_state"
    },
    {
      "indent": 3,
      "text": "STATE-CREATE (1984, 32, 0, 6, 0) JUMP (end)",
      "ja": "STATE-CREATE（6、0、32、1984、0）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": ":access_state",
      "ja": "：access_state"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier_c, 6, 0, 0, 0, 0) STATE-ACCESS (state_identifier_d, 6, 0, 0, 0, 0) STATE-ACCESS (state_identifier_f, 6, 0, 0, 0, 0) STATE-ACCESS (state_identifier_g, 6, 0, 0, 0, 0)",
      "ja": "STATE-ACCESS（state_identifier_c、6、0、0、0、0）STATE-ACCESS（state_identifier_d、6、0、0、0、0）STATE-ACCESS（state_identifier_f、6、0、0、0、0）状態 - ACCESS（state_identifier_g、6、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":end",
      "ja": "：終わり"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":error_conditions",
      "ja": "：error_conditions"
    },
    {
      "indent": 3,
      "text": "COMPARE ($type, 7, access_a, access_b, access_e)",
      "ja": "COMPARE（$タイプ、7、access_a、access_b、access_e）"
    },
    {
      "indent": 3,
      "text": ":access_a",
      "ja": "：access_a"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier_a, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": "STATE-ACCESS（state_identifier_a、6、0、0、0、0）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": ":access_b",
      "ja": "：access_b"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier_b, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": "STATE-ACCESS（state_identifier_b、6、0、0、0、0）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": ":access_e",
      "ja": "：あっせっｓ＿え"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier_e, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": "STATE-ACCESS（state_identifier_e、6、0、0、0、0）JUMP（端部）"
    },
    {
      "indent": 3,
      "text": "at (512)",
      "ja": "で（512）"
    },
    {
      "indent": 3,
      "text": ":state_start",
      "ja": "：STATE_START"
    },
    {
      "indent": 3,
      "text": "byte (0, 1, 2, 3, 4, 5, 6)",
      "ja": "バイト（0、1、2、3、4、5、6）"
    },
    {
      "indent": 3,
      "text": ":state_end",
      "ja": "：state_end"
    },
    {
      "indent": 3,
      "text": "set (temp_one, (state_start + 2)) ; = 514 set (temp_two, (state_start + 3)) ; = 515 set (temp_three, (state_end - 1)) ; = 518",
      "ja": "セット（temp_one、（STATE_START + 2））。 = 514セット（temp_two、（STATE_START + 3））。 = 515セット（temp_three、（state_end  -  1））。 = 518"
    },
    {
      "indent": 3,
      "text": ":state_identifier_a ; start state at 512",
      "ja": "：state_identifier_a; 512の状態を開始"
    },
    {
      "indent": 3,
      "text": "byte (172, 166, 11, 142, 178, 131)",
      "ja": "バイト（172、166、11、142、178、131）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_b ; start state at 513",
      "ja": "：state_identifier_b; 513の状態を開始"
    },
    {
      "indent": 3,
      "text": "byte (157, 191, 175, 198, 61, 210)",
      "ja": "バイト（157、191、175、198、61、210）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_c ; start state at 514",
      "ja": "：state_identifier_c; 514の状態を開始"
    },
    {
      "indent": 3,
      "text": "byte (52, 197, 217, 29, 83, 97)",
      "ja": "バイト（52、197、217、29、83、97）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_d ; start state at 515",
      "ja": "：state_identifier_d; 515の状態を開始"
    },
    {
      "indent": 3,
      "text": "byte (189, 214, 186, 42, 198, 90)",
      "ja": "バイト（189、214、186、42、198、90）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_e ; start state at 516",
      "ja": "：state_identifier_e; 516の状態を開始"
    },
    {
      "indent": 3,
      "text": "byte (71, 194, 24, 20, 238, 7)",
      "ja": "バイト（71、194、24、20、238、7）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_f ; start state at 517",
      "ja": "：state_identifier_f; 517の状態を開始"
    },
    {
      "indent": 3,
      "text": "byte (194, 117, 148, 29, 215, 161)",
      "ja": "バイト（194、117、148、29、215、161）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_g ; start state at 518",
      "ja": "：state_identifier_g; 518の状態を開始"
    },
    {
      "indent": 3,
      "text": "byte (72, 135, 156, 141, 233, 14)",
      "ja": "バイト（72、135、156、141、233、14）"
    },
    {
      "indent": 3,
      "text": "The above code must be executed a total of 9 times in order to complete the test. Each time the code is executed, a 1-byte compressed message N should be provided, taking the values 0x00 to 0x08 in ascending order (so the compressed message should be 0x00 the first time the code is run, 0x01 the second, and so on).",
      "ja": "上記のコードは、テストを完了するために9回の合計を実行しなければなりません。コードが実行されるたびに、1バイトの圧縮されたメッセージNは2番目が0x01ので、圧縮されたメッセージは、コードが実行される最初の時間は0x00でなければならない（昇順に0x08にする値は0x00を取って、提供されるべきで）。"
    },
    {
      "indent": 3,
      "text": "If the code makes a state creation request, then the state must be saved in Compartment (N modulo 3).",
      "ja": "コードは、状態の作成要求を行った場合、その状態はコンパートメント（Nを法3）に保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the compressed message is 0x00, 0x01, or 0x02, the code makes four state creation requests in compartments 0, 1, and 2, respectively. This creates a total of seven distinct state items referred to as State a through State g. The states should be distributed among the three compartments as illustrated in Figure 1 (note that some states belong to more than one compartment).",
      "ja": "圧縮されたメッセージが0x00で、0x01の、または0x02である場合、コードは、それぞれの区画0、1、及び2、の4つの状態の作成要求を行います。これは、状態Gを介して状態という7つの異なる状態の項目の合計を作成します。図1に示すように、状態は3つの区画間で分散されるべきである（いくつかの状態が複数の区画に属していることに留意されたいです）。"
    },
    {
      "indent": 3,
      "text": "When the compressed message is 0x03 or 0x04, the code overwrites all of the states in Compartments 0 and 1, respectively. This means that States a, b, and e will be unavailable because they are no longer present in any of the three compartments.",
      "ja": "圧縮されたメッセージは、0x03のまたは0x04の場合には、コードは、それぞれ、区画0と1の状態の全てを上書きします。これは、その国のA、Bを意味し、彼らは3つの区画のいずれかにもはや存在しているため、電子が使用できなくなることはありません。"
    },
    {
      "indent": 3,
      "text": "When the compressed message is 0x05, the code checks that the States c, d, f, and g are still available. Decompression should terminate successfully in this case.",
      "ja": "圧縮されたメッセージが0x05である場合、コードは米国のC、D、F、およびGは、まだ利用可能であることをチェックします。解凍は、この場合には、正常に終了すべきです。"
    },
    {
      "indent": 3,
      "text": "When the compressed message is 0x06, 0x07, or 0x08, the code attempts to access States a, b, and e, respectively. Decompression failure should occur in this case because the relevant states are no longer available.",
      "ja": "圧縮されたメッセージが0x06で、0x07の、または0x08にある場合、コードは、それぞれ、米国のA、B、及びEにアクセスしよう。関連する状態は、もはや利用可能であるため、解凍の失敗は、この場合には発生しません。"
    },
    {
      "indent": 3,
      "text": "The cost in UDVM cycles for each compressed message is given below (except for messages 0x06, 0x07, and 0x08 where decompression failure should to occur):",
      "ja": "各圧縮されたメッセージのUDVMサイクルにおけるコストは（0x07の、メッセージ0x06で除き、そして0x08の場合解凍障害が発生する必要があります）以下に示します。"
    },
    {
      "indent": 3,
      "text": "Compressed message: 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08",
      "ja": "圧縮されたメッセージ：0x00を0x01の0x02の0x03の0x04の0x05を0x06の0x07の0x08に"
    },
    {
      "indent": 3,
      "text": "Cost in UDVM cycles: 1809 1809 1809 1993 1994 1804 N/A N/A N/A",
      "ja": "UDVMサイクルにおけるコスト：1809 1809 1809 1993 1994 1804 N / A N / A N / A"
    },
    {
      "indent": 11,
      "text": "          +-----------------------------+\n          |        Compartment 0        |\n          |                             |\n          |                             |\n          |           State a           |\n          |                             |\n          |         +-------------------+---------+\n          |         |                   |         |\n          |         |                   |         |\n          |         |           State d |         |\n          |         |                   |         |\n          |         |                   |         |\n+---------+---------+---------+         |         |\n|         |         |         |         |         |\n|         |         |         |         |         |\n|         | State e | State g |         | State c |\n|         |         |         |         |         |\n|         |         |         |         |         |\n|         +---------+---------+---------+         |\n|                   |         |                   |\n|                   |         |                   |\n|           State b | State f |                   |\n|                   |         |                   |\n|                   |         |   Compartment 2   |\n|                   +---------+-------------------+\n|                             |\n|                             |\n|                             |\n|                             |\n|        Compartment 1        |\n+-----------------------------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 1: States created in the three compartments",
      "ja": "図1：3つの区画内に作成州"
    },
    {
      "indent": 0,
      "text": "4.4. Accessing State",
      "section_title": true,
      "ja": "4.4。州へのアクセス"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test accessing SIP-SDP static dictionary state [3]. The code first accesses the state and then outputs the result.",
      "ja": "このセクションでは、アクセスSIP-SDP静的辞書の状態をテストするためにアセンブリコードを与える[3]。コードは、最初の状態にアクセスし、その結果を出力します。"
    },
    {
      "indent": 3,
      "text": "at (32)",
      "ja": "（32）で"
    },
    {
      "indent": 3,
      "text": ":input pad (1) :input2 pad (1) :input3 pad (1) at (128)",
      "ja": "：入力パッド（1）：INPUT2パッド（1）：でINPUT3パッド（1）（128）"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (sip_dictionary, 20, 0xcfe, 1, input, 0) STATE-ACCESS (sip_dictionary, 6, 0xcff, 1, input2, 0) STATE-ACCESS (sip_dictionary, 12, 0xd00, 1, input3, 0)",
      "ja": "STATE-ACCESS（sip_dictionary、20、0xcfe、1、入力、0）STATE-ACCESS（sip_dictionary、6、0xcff、1、INPUT2、0）STATE-ACCESS（sip_dictionary、12、0xd00、1、INPUT3、0）"
    },
    {
      "indent": 3,
      "text": "OUTPUT (input, 3)",
      "ja": "OUTPUT（入力、3）"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "END-MESSAGE（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":sip_dictionary byte (0xfb, 0xe5, 0x07, 0xdf, 0xe5, 0xe6) byte (0xaa, 0x5a, 0xf2, 0xab, 0xb9, 0x14) byte (0xce, 0xaa, 0x05, 0xf9, 0x9c, 0xe6) byte (0x1b, 0xa5)",
      "ja": "：sip_dictionaryバイト（0xfb、0xe5、0x07の、0xdf、0xe5、0xe6）バイト（0xAAを、0x5a、0xf2、0xab、0xb9、0x14の）バイト（0xce、0xAAを、0x05の、0xf9、0x9c、0xe6）バイト（として0x1B、0xA5の）"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x5349 50, and the cost is 11 UDVM cycles.",
      "ja": "コードの出力は0x5349 50であり、コストは11回のUDVMサイクルです。"
    },
    {
      "indent": 0,
      "text": "4.5. Bytecode State Creation",
      "section_title": true,
      "ja": "4.5。バイトコードの状態の作成"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test storing bytecode using END-MESSAGE and later loading the bytecode using a partial state identifier within the SigComp header. The assembly code is designed to test the following cases:",
      "ja": "このセクションでは、END-MESSAGEを使用してバイトコードを記憶し、後のSigCompヘッダ内の部分状態識別子を使用してバイトコードをロードテストするためのアセンブリコードを与えます。アセンブリコードは、次の場合をテストするために設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The bytes to be saved are changed after the state create request has been made.",
      "ja": "状態の後に変更されて保存する1バイトは、要求が行われている作成します。"
    },
    {
      "indent": 3,
      "text": "2. The uploaded bytecode is modified before execution.",
      "section_title": true,
      "ja": "2.アップロードされたバイトコードは、実行前に変更されます。"
    },
    {
      "indent": 3,
      "text": "3. The bytecode is loaded using the partial state identifier and is modified before execution.",
      "ja": "3.バイトコードは、部分的な状態識別子を使用してロードされ、実行前に修正されます。"
    },
    {
      "indent": 3,
      "text": "4. The bytecode is loaded to an address lower than 128, using the partial state identifier.",
      "ja": "4.バイトコードは、部分状態識別子を使用して、128よりも低いアドレスにロードされます。"
    },
    {
      "indent": 3,
      "text": "5. The bytecode is loaded using the partial state identifier. Part of the loaded memory is reserved area, which is overwritten after loading the bytecode.",
      "ja": "5.バイトコードは、部分状態識別子を使用してロードされます。ロードされたメモリの一部は、バイトコードをロードした後に上書きされる予約領域です。"
    },
    {
      "indent": 3,
      "text": "6. The loading of the bytecode fails because the partial state identifier is too short.",
      "ja": "部分状態識別子が短すぎるので、6バイトコードのロードは失敗します。"
    },
    {
      "indent": 3,
      "text": "at (30) :save_area1 set (saved_instr1, (save_area1 + (code_start2 - start_saved))) ; = 33",
      "ja": "save_area1セット（saved_instr1、（save_area1 +（code_start2  -  start_saved）））;（30）で= 33"
    },
    {
      "indent": 3,
      "text": "at (80) :save_area2 set (saved_instr2, (save_area2 + (code_start2 - start_saved))) ; = 83",
      "ja": "save_area2セット（saved_instr2、（save_area2 +（code_start2  -  start_saved）））;（80）で= 83"
    },
    {
      "indent": 3,
      "text": "at (128) :code_start",
      "ja": "code_start：（128）で、"
    },
    {
      "indent": 3,
      "text": "COPY (start_saved, saved_len, save_area1) ; copy 'ok2', OUTPUT (save_area2,3) END-MESSAGE ; to position 30 and create as state STATE-CREATE (saved_len, save_area1, saved_instr1, 6, 10)",
      "ja": "COPY（start_saved、saved_len、save_area1）。コピー 'OK2'、OUTPUT（save_area2,3）END-MESSAGE; 30を配置した状態STATE-CREATE（saved_len、save_area1、saved_instr1、6、10）として作成します"
    },
    {
      "indent": 3,
      "text": "set (modify1, (save_area1 + 5)) ; = 35 LOAD (modify1, 0x1e03) ; modify save_area2 to be save_area1 in the ; created state",
      "ja": "セット（modify1、（save_area1 + 5））。 = 35 LOAD（modify1、0x1e03）。でsave_area1するsave_area2を修正。作成された状態"
    },
    {
      "indent": 3,
      "text": "COPY (start_saved, saved_len, save_area2) STATE-CREATE (saved_len, save_area2, saved_instr2, 20, 10) STATE-CREATE (saved_len, save_area2, saved_instr2, 12, 10) ; copy 'ok2', OUTPUT (save_area2,3) END-MESSAGE ; to position 80 and create as state twice with ; min access len 20 and 12",
      "ja": "COPY（start_saved、saved_len、save_area2）STATE-CREATE（saved_len、save_area2、saved_instr2、20、10）STATE-CREATE（saved_len、save_area2、saved_instr2、12、10）。コピー 'OK2'、OUTPUT（save_area2,3）END-MESSAGE; 80を配置して二回状態として作成します。分アクセスLEN 20と12"
    },
    {
      "indent": 3,
      "text": "JUMP (modify)",
      "ja": "JUMP（修正）"
    },
    {
      "indent": 3,
      "text": ":ok1 byte (0x4f, 0x4b, 0x31)",
      "ja": "：OK1バイト（0x4f、0x4b、0x31）"
    },
    {
      "indent": 3,
      "text": "set (after_output_minus1, (after_output - 1))",
      "ja": "セット（after_output_minus1、（after_output  -  1））"
    },
    {
      "indent": 3,
      "text": ":modify INPUT-BYTES (1, after_output_minus1, decompression_failure) ; Input overwrites the next instruction OUTPUT (ok1, 3) ; Now is OUTPUT (ok1, 2) so output is 0x4f4b",
      "ja": "：INPUTバイト（1、after_output_minus1、decompression_failure）を修正します。入力は、次の命令の出力を上書きする（OK1、3）。今OUTPUTある（OK1、2）ので、出力は0x4f4bです"
    },
    {
      "indent": 3,
      "text": ":after_output",
      "ja": "：after_output"
    },
    {
      "indent": 3,
      "text": "; Save from ok1 to the opcode of END-MESSAGE",
      "ja": "; END-MESSAGEのオペコードにOK1から保存"
    },
    {
      "indent": 3,
      "text": "set (modify_len, ((after_output + 1) - ok1)) ; = 13",
      "ja": "セット（modify_len、（（1）+ after_output  -  OK1））。 = 13"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, modify_len, ok1, modify, 6, 10) ; Save 'ok1', INPUT-BYTES, OUTPUT as state",
      "ja": "END-MESSAGE（0、0、modify_len、OK1、変更、6、10）。保存 'OK1'、INPUT-BYTES、状態としてOUTPUT"
    },
    {
      "indent": 3,
      "text": "set (saved_len, (end_saved - start_saved)) ; = 8",
      "ja": "セット（saved_len、（end_saved  -  start_saved））。 = 8"
    },
    {
      "indent": 3,
      "text": ":start_saved byte (0x4f, 0x4b, 0x32)",
      "ja": "：start_savedバイト（0x4f、0x4b、0x32の）"
    },
    {
      "indent": 3,
      "text": ":code_start2",
      "ja": "：code_start2"
    },
    {
      "indent": 3,
      "text": "; Translated bytecode for OUTPUT (save_area2, 3) byte (0x22, 0xa0, 0x50, 0x03)",
      "ja": ";出力のために翻訳されたバイトコード（save_area2、3）バイト（ただし0x22、0xA0を、0x50を、0×03）"
    },
    {
      "indent": 3,
      "text": "; Translated bytecode for END-MESSAGE (0, 0, 0, 0, 0, 0, 0) ; The zeros do not need to be sent because UDVM is initialised to 0 byte (0x23)",
      "ja": "; END-メッセージの翻訳バイトコード（0、0、0、0、0、0、0）; UDVMが0バイト（0x23）に初期化されるので、ゼロが送信される必要はありません。"
    },
    {
      "indent": 3,
      "text": ":end_saved :decompression_failure",
      "ja": "：end_saved：decompression_failure"
    },
    {
      "indent": 3,
      "text": "The outputs and cycle usages are:",
      "ja": "出力サイクルの用途は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Message Output Cycles 1 0x4f4b 66 2 0x4f4b 31 7 3 0x4f4b 32 5 4 0x0000 32 5 5 None Decompression failure",
      "ja": "メッセージ出力サイクル1 0x4f4b 66 2 0x4f4b 31 7 3 0x4f4b 32 5 4 0000 32 5なし減圧障害"
    },
    {
      "indent": 3,
      "text": "First message: mnemonic code annotated above",
      "ja": "最初のメッセージ：上記の注釈付きのニーモニックコード"
    },
    {
      "indent": 3,
      "text": "0xf804 6112 a0be 081e 2008 1e21 060a 0e23 be03 12a0 be08 a050 2008 0xa050 a053 140a 2008 a050 a053 0c0a 1606 004f 4b31 1c01 a0b3 fc22 0xa0a8 0323 0000 0da0 a8a0 ab06 0a4f 4b32 22a0 5003 2302",
      "ja": "0xf804 6112 a0beの081e 2008 1E21 060a 0e23 be03 12a0 be08 A050 2008 0xa050 A053 140A 2008 A050 A053の0C0A 1606 004f 4b31 1C01 a0b3 FC22 0xa0a8 0323 0000 0da0 a8a0 AB06 0a4f 4b32 22a0 5003 2302"
    },
    {
      "indent": 3,
      "text": "Second message: access and run last state saved by previous message - 'ok1', INPUT-BYTES, OUTPUT, END-MESSAGE.",
      "ja": "2番目のメッセージ：アクセスと前のメッセージで保存された実行最後の状態 -  'OK1'、INPUT-BYTES、OUTPUT、END-MESSAGE。"
    },
    {
      "indent": 3,
      "text": "0xf905 b88c e72c 9103",
      "ja": "0xf905 b88cのe72c 9103"
    },
    {
      "indent": 3,
      "text": "Third message: access and run state from save_area2 with 12 bytes of state identifier - 'ok2', INPUT-BYTES, OUTPUT, END-MESSAGE.",
      "ja": "第三のメッセージ：アクセスと状態識別子の12バイトでsave_area2から状態を実行します -  'OK2'、INPUT-BYTES、OUTPUT、END-MESSAGE。"
    },
    {
      "indent": 3,
      "text": "0xfb24 63cd ff5c f8c7 6df6 a289 ff",
      "ja": "0xfb24 63cd ff5c f8c7 6df6 a289 FF"
    },
    {
      "indent": 3,
      "text": "Fourth message: access and run state from save_area1. The state is 'ok2', INPUT-BYTES, OUTPUT, END-MESSAGE but the first two bytes should be overwritten when initialising UDVM memory.",
      "ja": "4番目のメッセージ：アクセスとsave_area1から状態を実行します。状態は「OK2」、INPUTバイト、OUTPUT、END-MESSAGEが、UDVMメモリを初期化するときに最初の2つのバイトは、上書きされるべきです。"
    },
    {
      "indent": 3,
      "text": "0xf95b 4b43 d567 83",
      "ja": "0xf95bの4b43のd567 83"
    },
    {
      "indent": 3,
      "text": "Fifth message: attempt to access state from save_area2 with fewer than 20 bytes of state identifier.",
      "ja": "第5のメッセージ：状態識別子未満の20バイトでsave_area2から状態へのアクセスを試みます。"
    },
    {
      "indent": 3,
      "text": "0xf9de 8126 1199 1f",
      "ja": "0xf9de 8126 1199 1F"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This document describes torture tests for the SigComp protocol RFC 3320 [2]. Consequently, the security considerations for this document match those of SigComp.",
      "ja": "この文書では、SigCompのプロトコルRFC 3320 [2]のための拷問テストを記述します。したがって、この文書のセキュリティ上の考慮事項はにSigCompのものと一致します。"
    },
    {
      "indent": 3,
      "text": "In addition, the torture tests include tests for a significant number of \"boundary and error cases\" for execution of the UDVM bytecode. Boundary and error problems are common vectors for security attacks, so ensuring that a UDVM implementation executes this set of torture tests correctly should contribute to the security of the implementation.",
      "ja": "また、拷問テストはUDVMバイトコードを実行するための「境界およびエラーの場合、」かなりの数のテストが含まれています。境界およびエラーの問題はそうUDVM実装が正しく拷問テストのこのセットを実行し、実装の安全保障に貢献すべきであることを保証し、セキュリティ攻撃のための共通のベクトルです。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgements",
      "section_title": true,
      "ja": "6.謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Richard Price and Pekka Pessi for test contributions and to Pekka Pessi and Cristian Constantin, who served as committed working group document reviewers.",
      "ja": "テストの貢献のため、コミットワーキンググループ文書の校閲を務めペッカPessiとクリスティアン・コンスタンティン、とリチャード価格とペッカPessiに感謝します。"
    },
    {
      "indent": 0,
      "text": "7. Normative References",
      "section_title": true,
      "ja": "7.引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Surtees, A. and M. West, \"Signaling Compression (SigComp) Users' Guide\", RFC 4464, May 2006.",
      "ja": "[1]サーティース、A.とM.西、 \"シグナリング圧縮（SigCompの）ユーザーのガイド\"、RFC 4464、2006年5月。"
    },
    {
      "indent": 3,
      "text": "[2] Price, R., Bormann, C., Christoffersson, J., Hannu, H., Liu, Z., and J. Rosenberg, \"Signaling Compression (SigComp)\", RFC 3320, January 2003.",
      "ja": "[2]価格、R.、ボルマン、C.、Christoffersson、J.、ハンヌ、H.、劉、Z.、およびJ.ローゼンバーグ、 \"シグナリング圧縮（SigCompの）\"、RFC 3320、2003年1月。"
    },
    {
      "indent": 3,
      "text": "[3] Garcia-Martin, M., Bormann, C., Ott, J., Price, R., and A.B. Roach, \"The Session Initiation Protocol (SIP) and Session Description Protocol (SDP) Static Dictionary for Signaling Compression (SigComp)\", RFC 3485, February 2003.",
      "ja": "[3]ガルシア - マーチン、M.、ボルマン、C.、オット、J.、価格、R.、およびA.B.ローチ、 \"セッション開始プロトコル（SIP）およびセッション記述プロトコル（SDP）シグナリング圧縮（SigCompの）のための静的辞書\"、RFC 3485、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[4] Roach, A.B., \"A Negative Acknowledgement Mechanism for Signaling Compression\", RFC 4077, May 2005.",
      "ja": "[4]ローチ、A.B.、 \"シグナリング圧縮のための否定応答メカニズム\"、RFC 4077、2005年5月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. UDVM Bytecode for the Torture Tests",
      "ja": "拷問テストの付録A. UDVMバイトコード"
    },
    {
      "indent": 3,
      "text": "The following sections list the raw UDVM bytecode generated for each test. The bytecode is presented in the form of a complete SigComp message, including the appropriate header. It is followed by input messages, the output they produce, and where the decompression succeeds the number of cycles used.",
      "ja": "次のセクションでは、各テストのために生成された生UDVMバイトコードをリストします。バイトコードは、適切なヘッダを含む完全にSigCompメッセージの形で提示されます。これは、入力メッセージ、それらが生成出力され、ここで減圧を使用サイクル数を成功が続きます。"
    },
    {
      "indent": 3,
      "text": "In some cases, the test is designed to be run several times with different compressed messages appended to the code. In the cases where multiple whole messages are used for a test, e.g., Appendix A.2.3, these are supplied. In the case where decompression failure occurs, the high-level reason for it is given as a reason code defined in NACK [4].",
      "ja": "いくつかのケースでは、テストがコードに追加異なる圧縮されたメッセージで数回実行するように設計されています。複数の全体のメッセージは、テストのために使用される場合には、例えば、付録A.2.3は、これらが供給されます。減圧障害が発生した場合に、そのための高レベルの理由は、NACK [4]で定義された理由コードとして与えられます。"
    },
    {
      "indent": 3,
      "text": "Note that the different assemblers can output different bytecode for the same piece of assembly code, so a valid assembler can produce results different from those presented below. However, the following bytecode should always generate the same results on any UDVM.",
      "ja": "異なるアセンブラが出力アセンブリコードの同じ部分に異なるバイトコードので、有効なアセンブラは以下に示すものとは異なる結果を生成することができることに留意されたいです。ただし、次のバイトコードは常にUDVMに同じ結果を生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "A.1. Instructions",
      "ja": "A.1。説明書"
    },
    {
      "indent": 0,
      "text": "A.1.1. Bit Manipulation",
      "ja": "A.1.1。ビット操作"
    },
    {
      "indent": 3,
      "text": "0xf80a 7116 a07f 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x01c0 00ff 8055 5502 202a 0321 0420 0305 21ff 2286 0401 20c0 ff02 0x2060 0320 0421 6005 2061 2286 0423",
      "ja": "0xf80a 7116 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 a07f 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x01c0の00FF 8055 5502 202A 0321 0420 0305 2286 0401 21FF 20c0 FF02 0x2060 0320 0421 6005 2061 2286 0423"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x0150 0000 febf 0000 Cycles: 22",
      "ja": "入力：なし出力：0x0150 0000 febf 0000サイクル：22"
    },
    {
      "indent": 0,
      "text": "A.1.2. Arithmetic",
      "ja": "A.1.2。算術"
    },
    {
      "indent": 3,
      "text": "0xf80a a11c 01a0 450b 0722 0116 a077 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x06c0 00ff 9941 0720 0108 20a3 e909 20a0 650a 200b 2286 0406 21c0 0xff07 2162 0821 6109 2061 0a21 6222 8604 23",
      "ja": "0xf80aのA11Cの01A0の450B 0722 0116 A077 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x06c0の00FF 9941 0720 0108 20A3 e909 20a0 650A 200B 2286 0406 21c0 0xff07 2162 0821 6109 2061 0a21 6222 8604 23 0000 0000に"
    },
    {
      "indent": 3,
      "text": "Input: 0x00 Output: 0x0000 0000 0000 0004 Cycles: 25",
      "ja": "入力：0x00の出力：0000 0000 0000 0004サイクル：25"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 DECOMPRESSION-FAILURE DIV_BY_ZERO",
      "ja": "入力：0x01の圧縮解除-FAILURE DIV_BY_ZERO"
    },
    {
      "indent": 3,
      "text": "Input: 0x02 DECOMPRESSION-FAILURE DIV_BY_ZERO",
      "ja": "入力：0x02の圧縮解除-FAILURE DIV_BY_ZERO"
    },
    {
      "indent": 0,
      "text": "A.1.3. Sorting",
      "ja": "A.1.3。整理"
    },
    {
      "indent": 3,
      "text": "0xf80d c10c 8802 170b 8802 1722 a12e 2d23 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0a00 0a00 1100 0700 1600 0300 0300 0300 1300 0100 1000 0e00 0x0800 0200 0d00 1400 1200 1700 0f00 1500 0c00 0600 096e 6720 6975 0x6920 7469 742c 2079 6f75 2720 5346 6f6e 6761 2075 7272 646f 2074 0x6f6e 2e2e 0070 6570 206e 7472 656e 69",
      "ja": "0xf80d c10c 8802 170B 8802 1722 a12eの2d23 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0A00 0A00 1100 0700 1600 0300 0300 0300 1300 0100 1000年0e00 0x0800で0200 0d00 1400 1200 1700 0f00 1500 0C00 0600 096e 6720 6975 0000 6f75 2720 5346 7469 742C 2079 6f6e 6761 0x6920 2075 7272 2074 646f 0x6f6eの2e2e 0070 6570 206E 7472 656e 69"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x466f 7264 2c20 796f 7527 7265 2074 7572 6e69 6e67 0x2069 6e74 6f20 6120 7065 6e67 7569 6e2e 2053 746f 0x7020 6974 2e Cycles: 371",
      "ja": "入力：なし出力：0x466f 7264 2c20 796f 7527 7265 2074 7572 6e69 6e67 0x2069 6e74 6f20 6120 7065 6e67 7569 6e2e 2053 746f 0x7020 6974 2Eサイクル：371"
    },
    {
      "indent": 0,
      "text": "A.1.4. SHA-1",
      "ja": "あ。１。４。 しゃー１"
    },
    {
      "indent": 3,
      "text": "0xf808 710d a0c3 03a0 4422 a044 140d a0c6 38a0 4422 a044 140e 86a0 0xfe0e a042 a0ff 0da0 fe8e a044 22a0 4414 0e86 a0ff 0ea0 42a1 070d 0xa0ff a280 a0ff 22a0 ff14 2300 0000 0000 0000 6162 6361 6263 6462 0x6364 6563 6465 6664 6566 6765 6667 6866 6768 6967 6869 6a68 696a 0x6b69 6a6b 6c6a 6b6c 6d6b 6c6d 6e6c 6d6e 6f6d 6e6f 706e 6f70 7161 0x3031 3233 3435 3637",
      "ja": "0ea0 42A1 070d 0xa0ffのA280 A0FF 0xf808 710D a0c3 03a0 4422 A044 140D a0c6 38a0 4422 A044 140E 86a0 0xfe0e A042 A0FF 0da0 fe8e A044 22a0 4414 0e86 22a0 FF14 2300 0000 0000 0000 6162 6361 6263 6462 A0FF 6563 6465 6664 6566 6765 6667 6866 6768 6967 6869 0x6364 6a68 696a 0x6b69 6a6b 6c6a 6b6c 6d6b 6c6d 6e6c 6d6e 6f6d 6e6f 706e 6f70 7161 0x3031 3233 3435 3637"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0xa999 3e36 4706 816a ba3e 2571 7850 c26c 9cd0 d89d 0x8498 3e44 1c3b d26e baae 4aa1 f951 29e5 e546 70f1 0x12ff 347b 4f27 d69e 1f32 8e6f 4b55 73e3 666e 122f 0x4f46 0452 ebb5 6393 4f46 0452 ebb5 6393 4f46 0452 Cycles: 17176",
      "ja": "入力：なし出力：0xa999 3e36 4706 816A ba3e 2571 7850 c26c 9cd0 d89d 0x8498 3e44 1c3b d26e baae 4aa1 f951 29e5 e546 70f1 0x12ff 347B 4f27 d69e 1f32 8e6f 4b55 73e3 666e 122F 0x4f46 0452 ebb5 6393 4f46 0452 ebb5 6393 4f46 0452サイクル：17176"
    },
    {
      "indent": 0,
      "text": "A.1.5. LOAD and MULTILOAD",
      "ja": "A.1.5。 LOADとMULTILOAD"
    },
    {
      "indent": 3,
      "text": "0xf803 610e 87a0 840e a082 c080 0ec0 80a0 860e c084 c084 2287 081c 0x01a0 4127 0820 0206 203c 0f60 03a0 a2a0 b187 0f60 042a 87c0 80c0 0x8422 8708 23",
      "ja": "0xf803 610E 87a0 840E A082のC080 0ec0 80A0 860E c084 c084 2287 081cの0x01a0 4127 0820 0206 203C 0f60 03a0 a2a0のb187の0f60 042a 87c0 80C0 0x8422 8708 23"
    },
    {
      "indent": 3,
      "text": "Input: 0x00 Output: 0x0084 0084 0086 0086 002a 0080 002a 002a Cycles: 36",
      "ja": "入力：0x00の出力：0x0084 0084 0086 0086 002A 0080 002A 002Aサイクル：36"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 DECOMPRESSION-FAILURE MULTILOAD_OVERWRITTEN",
      "ja": "入力：0x01の圧縮解除-FAILURE MULTILOAD_OVERWRITTEN"
    },
    {
      "indent": 3,
      "text": "Input: 0x02 DECOMPRESSION-FAILURE MULTILOAD_OVERWRITTEN",
      "ja": "入力：0x02の圧縮解除-FAILURE MULTILOAD_OVERWRITTEN"
    },
    {
      "indent": 0,
      "text": "A.1.6. COPY",
      "ja": "A.1.6。 COPY"
    },
    {
      "indent": 3,
      "text": "0xf803 910e 208e 0e86 860e a042 8712 2087 210e 8680 4100 1286 a055 0xa041 2220 a077 0e86 200e a042 3015 2004 a041 0112 2004 3022 3004 0x1230 042e 2220 0223",
      "ja": "A041 0112 2004 3022 3004 0x1230 042e 2220 0223 A055 0xa041 2220 A077 0e86 200E A042 3015 2004 A042 8712 2087 210E 8680 4100 1286 0xf803 910E 208E 860E 0e86"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x4040 4040 4040 4040 4040 4040 4040 4040 4040 4040 0x4040 4040 4040 4040 4040 4040 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 5541 0x4243 4443 44 Cycles: 365",
      "ja": "入力：なし出力：0x4040 4040 4040 4040 4040 4040 4040 4040 4040 4040 0x4040 4040 4040 4040 4040 4040 4141 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 5541 0x4141 0x4243 4443 44サイクル：365"
    },
    {
      "indent": 0,
      "text": "A.1.7. COPY-LITERAL and COPY-OFFSET",
      "ja": "A.1.7。 COPYリテラルおよびCOPY-OFFSET"
    },
    {
      "indent": 3,
      "text": "0xf806 110e 2080 4100 0e86 860e a042 870e a044 2113 2087 2222 8608 0x0ea0 44a0 9c13 2002 2222 a09c 020e 86a0 480e a042 a052 0ea0 44a0 0x5215 a048 0aa0 4101 1402 0622 0ea0 4606 1463 0422 2261 0a0e a044 0xa050 1404 0422 22a0 4402 1405 0422 22a0 4402 2260 0a23",
      "ja": "0xf806 110E 2080 4100 0e86 860E A042 870eのA044 2113 2087 2222 8608 0x0ea0 44a0 9c13 2002 2222 a09cの020e 86a0 480e A042のA052 0ea0 44a0 0x5215 A048の0aa0 4101 1402 0622 0ea0 4606 1463 0422 2261 0a0eのA044 0xa050 1404 0422 22a0 4402 1405 0422 22a0 4402 2260 0a23"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x4141 4141 0061 4141 4141 494A 4142 4344 494A 4142 0x004A 004E 4748 4845 4647 4748 4546 Cycles: 216",
      "ja": "入力：なし出力：0x4141 4141 0061 4141 4141 494A 4142 4344 494A 4142 0x004A 004E 4748 4845 4647 4748 4546サイクル：216"
    },
    {
      "indent": 0,
      "text": "A.1.8. MEMSET",
      "ja": "A.1.8。 memsetを"
    },
    {
      "indent": 3,
      "text": "0xf801 810e 8687 0ea0 42a0 8115 86a0 8100 0115 a081 0f86 0f22 8710 0x23",
      "ja": "810E 8687 0xf801 0ea0 42a0 8115 86a0 8100 0115 A081の0f86の0f22 8710 0x23"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x8040 4f5e 6d7c 8b9a a9b8 c7d6 e5f4 0312 Cycles: 166",
      "ja": "入力：なし出力：0x8040 4f5e 6d7c 8b9a a9b8 c7d6 e5f4 0312サイクル：166"
    },
    {
      "indent": 0,
      "text": "A.1.9. CRC",
      "ja": "あ。１。９。 ＣＲＣ"
    },
    {
      "indent": 3,
      "text": "0xf801 8115 a046 1801 0115 a05e 1487 011c 02a0 4413 1b62 a046 2c0e 0x23",
      "ja": "8115 A046 1801 0115 a05e 1487 0xf801 011C 02a0 4413 1b62 A046の2c0e 0x23"
    },
    {
      "indent": 3,
      "text": "Input: 0x62cb Output: None Cycles: 95",
      "ja": "入力：0x62cb出力：なしサイクル：95"
    },
    {
      "indent": 3,
      "text": "Input: 0xabcd DECOMPRESSION FAILURE USER_REQUESTED (CRC mismatch)",
      "ja": "入力：0xABCDと解凍FAILURE USER_REQUESTED（CRCの不一致）"
    },
    {
      "indent": 0,
      "text": "A.1.10. INPUT-BITS",
      "ja": "A.1.10。 INPUT-BITS"
    },
    {
      "indent": 3,
      "text": "0xf801 511d 62a0 4614 22a0 4602 0622 010a 2207 0622 0116 ee23",
      "ja": "0xf801 511D 62a0 4614 22a0 4602 0622 010A 2207 0622 0116 EE23"
    },
    {
      "indent": 3,
      "text": "Input: 0x932e ac71 Output: 0x0000 0002 0002 0013 0000 0003 001a 0038 Cycles: 66",
      "ja": "入力：0x932e ac71出力：0000 0002 0002 0013 0000 0003 001A 0038サイクル：66"
    },
    {
      "indent": 0,
      "text": "A.1.11. INPUT-HUFFMAN",
      "ja": "A.1.11。 INPUT-HUFFMAN"
    },
    {
      "indent": 3,
      "text": "0xf801 d11e a046 1c02 6200 6262 6200 ff00 22a0 4602 0622 010a 2207 0x0622 0116 e623",
      "ja": "0116 e623 0x0622 0xf801 d11eのA046の1c02 FF00 22a0 4602 0622 010A 2207 6200 6262 6200"
    },
    {
      "indent": 3,
      "text": "Input: 0x932e ac71 66d8 6f Output: 0x0000 0003 0008 04d7 0002 0003 0399 30fe Cycles: 84",
      "ja": "入力：0x932e ac71 66d8 6F出力：0000 0003 0008 0002 0003 0399 04d7 30feサイクル：84"
    },
    {
      "indent": 0,
      "text": "A.1.12. INPUT-BYTES",
      "ja": "A.1.12。 INPUT-BYTES"
    },
    {
      "indent": 3,
      "text": "0xf802 710e 86a0 480e a042 a04c 1d62 a046 1d22 a046 0206 2202 0a22 0x071c 62a0 480e 22a0 4862 0622 0116 e523",
      "ja": "0xf802 710E 86a0 480e A042 a04cの1d62のA046の1d22のA046 0206 2202 0a22 0x071c 62a0 480e 22a0 4862 0622 0116 e523"
    },
    {
      "indent": 3,
      "text": "Input: 0x932e ac71 66d8 6fb1 592b dc9a 9734 d847 a733 874e 0x1bcb cd51 b5dc 9659 9d6a Output: 0x0000 932e 0001 b166 d86f b100 1a2b 0003 9a97 34d8 0x0007 0001 3387 4e00 08dc 9651 b5dc 9600 599d 6a Cycles: 130",
      "ja": "入力：0x932e ac71 66d8 6fb1 592B dc9a 9734 d847 a733 874e 0x1bcb CD51 b5dc 9659 9d6a出力：130：9651 b5dc 9600 599D 6aのサイクル08dc 0000 932e 0001 b166 d86f B100 1a2b 0003 9a97 34d8 0x0007 0001 3387 4e00"
    },
    {
      "indent": 0,
      "text": "A.1.13. Stack Manipulation",
      "ja": "A.1.13。スタック操作"
    },
    {
      "indent": 3,
      "text": "0xf814 110e a046 8610 0210 6010 a042 2286 0811 8611 6311 a046 2286 0x0816 2800 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 000e a046 200e a048 a140 0724 0x8818 3400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0018 6400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 000e a046 a17f 0ea1 7f1a 0fa1 b003 0x0180 c001 8f19 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0023",
      "ja": "0xf814 110E A046 8610 0210 6010 A042 2286 0811 8611 6311 A046 2286 0x0816 2800 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 000E A046 200E A048 A140 0724 3400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x8818 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0018 6400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 000EのA046のa17f 0000 0ea1 7f1a 0fa1 B003 0x0180 C001 8f19 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0023 0000 0000 0000 0000 0000 0000 0000"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x0003 0002 0001 0042 0042 0000 0001 0001 Cycles: 40",
      "ja": "入力：なし出力：0x0003 0002 0001 0042 0042 0000 0001 0001サイクル：40"
    },
    {
      "indent": 0,
      "text": "A.1.14. Program Flow",
      "ja": "A.1.14。プログラム・フロー"
    },
    {
      "indent": 3,
      "text": "0xf803 f10e a044 040e 86a0 9207 20a0 9022 a043 0116 6006 2101 0e86 0xa084 0720 a0a1 22a0 4301 1761 0660 f106 0722 010e 86a0 8407 20a0 0xb622 a043 011a 0462 0860 9fdc f123",
      "ja": "0xf803 F10E A044 a0a1 22a0 4301 1761 0660 0722 F106 010e 86a0 8407 20a0 0xb622 A043 011A 0462 0860 9fdcのF123 A043 0116 6006 2101 0e86 0xa084 0720 040e 86a0 9207 20a0 9022"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x0001 0102 0203 0304 0405 0506 0707 0708 0808 0909 Cycles: 131",
      "ja": "入力：なし出力：0x0001の0102 0203 0304 0405 0506 0707 0708 0808 0909サイクル：131"
    },
    {
      "indent": 0,
      "text": "A.1.15. State Creation",
      "ja": "A.1.15。ステートの作成"
    },
    {
      "indent": 3,
      "text": "0xf809 411c 01a0 45ff 0422 0b17 628f 0d06 0620 0aa1 0a00 1400 0422 0x0117 628f 0c06 0620 0a88 0014 0004 2201 1762 8f16 0606 1c01 a047 0x9fd2 21a0 4863 12a0 e363 a048 0422 0117 628f 0a06 0621 a0e3 0604 0x2201 1762 8f0e 0606 2300 000a 8800 1400 2300 0000 0000 0000 437a 0xe80a 0fdc 1e6a 87c1 b62a 7676 b973 318c 0ef5 0000 0000 0000 0000 0x00c0 cc3f ee79 bcfc 8fd1 0865 e803 52ee 2977 17df 57",
      "ja": "0xf809 8f16 0606 411C 01A0 45ff 0422 0b17 628f 0d06 0620 0aa1 0A00 1400 0422 0x0117 628f 0c06 0620 0a88 0014 0004 2201 1762 1C01 a047 0x9fd2 21A0 4863 12a0 e363のA048 0422 0117 628f 0a06 0621 0604 a0e3 1762 8f0e 0606 2300 000A 8800 1400 2300 0000 0000 0x2201 0000 437A 0xe80a 0fdc 1e6a 87c1 b62a 7676 b973の318C 0ef5 0000 0000 0000 0000 0x00c0 cc3f ee79 B-CFC 8fd1 0865 E803 52ee 2977 17df 57"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 Output: None Cycles: 23",
      "ja": "入力：0x01の出力：なしサイクル：23"
    },
    {
      "indent": 3,
      "text": "Input: 0x02 Output: None Cycles: 14",
      "ja": "入力：0x02の出力：なしサイクル：14"
    },
    {
      "indent": 3,
      "text": "Input: 0x03 Output: None Cycles: 24",
      "ja": "入力：0x03の出力：なしサイクル：24"
    },
    {
      "indent": 3,
      "text": "Input: 0x0405 DECOMPRESSION-FAILURE INVALID_STATE_ID_LENGTH",
      "ja": "入力：0x0405圧縮解除-FAILUREのINVALID_STATE_ID_LENGTH"
    },
    {
      "indent": 3,
      "text": "Input: 0x0415 DECOMPRESSION-FAILURE INVALID_STATE_ID_LENGTH",
      "ja": "入力：0x0415圧縮解除-FAILUREのINVALID_STATE_ID_LENGTH"
    },
    {
      "indent": 3,
      "text": "Input: 0x0406 Output: None Cycles: 23",
      "ja": "入力：0x0406出力：なしサイクル：23"
    },
    {
      "indent": 3,
      "text": "Input: 0x09 Output: None Cycles: 34",
      "ja": "入力：0x09の出力：なしサイクル：34"
    },
    {
      "indent": 3,
      "text": "Input: 0x1e06 Output: None Cycles: 46",
      "ja": "入力：0x1e06出力：なしサイクル：46"
    },
    {
      "indent": 3,
      "text": "Input: 0x1e07 Output: None Cycles: 47",
      "ja": "入力：0x1e07出力：なしサイクル：47"
    },
    {
      "indent": 3,
      "text": "Input: 0x1e14 Output: None Cycles: 60",
      "ja": "入力：0x1e14出力：なしサイクル：60"
    },
    {
      "indent": 0,
      "text": "A.1.16. STATE-ACCESS",
      "ja": "A.1.16。 STATE-ACCESS"
    },
    {
      "indent": 3,
      "text": "Set up bytecode: 0xf819 0123 0000 1089 0014 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0022 a20c 0x0423 0000 0000 0000 0074 6573 74",
      "ja": "設定したバイトコード：0xf819 0123 0000 1089 0014 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 000 0000 a20cの0x0423 0000 0000 0000 0074 6573 74 0000 0000 0022 0"
    },
    {
      "indent": 3,
      "text": "Input: None",
      "ja": "入力：なし"
    },
    {
      "indent": 3,
      "text": "0xf819 411c 01a0 45ff 1762 0106 0d1c 1f89 1400 0000 891f 8914 0c04 0xa046 0022 a046 0416 a146 1762 0306 101b 1f87 1400 0000 0016 a136 0x1f89 1306 04a0 4600 16a1 2b1f 8914 0c05 a046 0016 a120 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0023 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 005d f8bc 0x3e20 93b5 abe1 f170 1342 4ce7 fe05 e069 39",
      "ja": "0xf819 411C 01A0の45ff 1762 0106 0d1c 1f89 A120 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 A136 0x1f89 1306 04a0 4600 16A1 2b1f 8914 0c05 A046 0016 A146 1762 0306 101bは1f87 1400 0000 0016 1400 0000 891f 8914 0c04 0xa046 0022 A046 0416 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0023 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 005D f8bc 0x3e20 93b5 abe1 F170 1342 4ce7 FE05 e069 39"
    },
    {
      "indent": 3,
      "text": "Input: 0x00 Output: 0x7465 7374 Cycles: 26",
      "ja": "入力：0x00の出力：0x7465 7374サイクル：26"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 Output: 0x7465 7374 Cycles: 15",
      "ja": "入力：0x01の出力：0x7465 7374サイクル：15"
    },
    {
      "indent": 3,
      "text": "Input: 0x02 DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": "入力：0x02の圧縮解除-FAILURE STATE_NOT_FOUND"
    },
    {
      "indent": 3,
      "text": "Input: 0x03 DECOMPRESSION-FAILURE STATE_NOT_FOUND (len < min_acc_len)",
      "ja": "入力：0x03の圧縮解除-FAILUREのSTATE_NOT_FOUND（LEN <min_acc_len）"
    },
    {
      "indent": 3,
      "text": "Input: 0x04 DECOMPRESSION-FAILURE STATE_TOO_SHORT",
      "ja": "入力：0x04を圧縮解除-FAILURE STATE_TOO_SHORT"
    },
    {
      "indent": 0,
      "text": "A.2. Dispatcher Tests",
      "ja": "A.2。ディスパッチャのテスト"
    },
    {
      "indent": 0,
      "text": "A.2.1. Useful Values",
      "ja": "A.2.1。有用な値"
    },
    {
      "indent": 3,
      "text": "0xf805 f10e 8620 0ea0 4221 1c01 a047 f817 4263 f306 f317 4300 ed06 0x0c17 4400 e73f e717 44a3 c0e1 07e1 1c01 a047 9fda 0623 4007 2301 0x1220 0163 1c01 a049 9fca 0ea0 4443 0622 0308 2208 0622 a3e8 0822 0x4106 2264 0722 a358 1220 6220 2300 00a3 c086 8706",
      "ja": "0163 0x1220 0xf805 F10E 8620 0ea0 4221 1C01 a047のf817 4263 F306のF317 4300 ed06 0x0c17 4400 e73f e717 44a3 c0e1 07e1 1C01 a047の9fda 0623 4007 2301 1C01 a049 9fca 0ea0 4443 0622 0308 2208 0622 a3e8 0822 2264 0722 a358 1220 6220 2300 00A3 c086 8706 0x4106"
    },
    {
      "indent": 3,
      "text": "Input: 1 byte of SigComp version Output: None Cycles: 968",
      "ja": "入力：SigCompのバージョン出力の1バイト：なしサイクル：968"
    },
    {
      "indent": 3,
      "text": "0xf93a db1d 3d20 aa",
      "ja": "0xf93aは3d20 AAをdb1d"
    },
    {
      "indent": 3,
      "text": "Input: 1 byte of SigComp version then 0x0000 Output: None Cycles: cycles_per_bit * 1080",
      "ja": "入力：SigCompのバージョンの1バイト、その後0000出力：なしサイクル：cycles_per_bit * 1080"
    },
    {
      "indent": 3,
      "text": "Input: 1 byte of SigComp version then 0x0001 DECOMPRESSION-FAILURE CYCLES_EXHAUSTED",
      "ja": "入力：SigCompのバージョンの1バイト、その後は0x0001圧縮解除-FAILURE CYCLES_EXHAUSTED"
    },
    {
      "indent": 3,
      "text": "Input: 1 byte of SigComp version then 0x0100 DECOMPRESSION-FAILURE SEGFAULT",
      "ja": "入力：SigCompのバージョンの1バイト、その後は0x0100圧縮解除-FAILUREセグメンテーション違反"
    },
    {
      "indent": 0,
      "text": "A.2.2. Cycles Checking",
      "ja": "A.2.2。チェックサイクル"
    },
    {
      "indent": 3,
      "text": "0xf801 a10f 8604 2029 0022 12a0 4402 6014 02a0 6423 22a0 4402 0622 0x0116 ef",
      "ja": "8604 2029 0022 4402 6014 12a0 02a0 22a0 6423 4402 0622 0x0116 a10f 0xf801場合"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE CYCLES_EXHAUSTED",
      "ja": "入力：なし解凍-FAILURE CYCLES_EXHAUSTED"
    },
    {
      "indent": 0,
      "text": "A.2.3. Message-based Transport",
      "ja": "A.2.3。メッセージベースの交通"
    },
    {
      "indent": 3,
      "text": "0xf8",
      "ja": "0xf8"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：なし圧縮解除-FAILUREのMESSAGE_TOO_SHORT"
    },
    {
      "indent": 3,
      "text": "0xf800",
      "ja": "0xf800"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：なし圧縮解除-FAILUREのMESSAGE_TOO_SHORT"
    },
    {
      "indent": 3,
      "text": "0xf800 e106 0011 2200 0223 0000 0000 0000 01",
      "ja": "0xf800 E106 0011 2200 0223 0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "Input: None Output: decompression_memory_size Cycles: 5",
      "ja": "入力：なし出力：decompression_memory_sizeサイクル：5"
    },
    {
      "indent": 3,
      "text": "0xf800 f106 0011 2200 0223 0000 0000 0000 01",
      "ja": "0xf800 F106 0011 2200 0223 0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：なし圧縮解除-FAILUREのMESSAGE_TOO_SHORT"
    },
    {
      "indent": 3,
      "text": "0xf800 e006 0011 2200 0223 0000 0000 0000 01",
      "ja": "0xf800 E006 0011 2200 0223 0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE INVALID_CODE_LOCATION",
      "ja": "入力：なし圧縮解除-FAILUREのINVALID_CODE_LOCATION"
    },
    {
      "indent": 3,
      "text": "0xf800 ee06 0011 2200 0223 0000 0000 0000 01",
      "ja": "0xf800 ee06 0011 2200 0223 0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "Input: None Output: decompression_memory_size Cycles: 5",
      "ja": "入力：なし出力：decompression_memory_sizeサイクル：5"
    },
    {
      "indent": 0,
      "text": "A.2.4. Stream-based Transport",
      "ja": "A.2.4。ストリームベースの輸送"
    },
    {
      "indent": 3,
      "text": "0xffff f801 7108 0002 2200 0222 a092 0523 0000 0000 0000 00ff 00ff 0x03ff ffff ffff ffff f801 7e08 0002 2200 0222 a3d2 0523 0000 0000 0x0000 00ff 04ff ffff ffff ffff ffff ff",
      "ja": "7108 0222 2200 0523 0000 0002 0000 0000 FFFF FFFF 0xFFFFのF801のA092は00FF F801 0x03ff 7e08 a3d2 0222 0523 2200 0000 0002 0000 FFFF FFFF FFFF 00FF 00FFは0x0000 FFFF FFを04ff FFFF"
    },
    {
      "indent": 3,
      "text": "The above stream contains two messages:",
      "ja": "上記の流れは、2つのメッセージを含んでいます。"
    },
    {
      "indent": 3,
      "text": "Output: decompression_memory_size Cycles: 11",
      "ja": "出力：decompression_memory_sizeサイクル：11"
    },
    {
      "indent": 3,
      "text": "Output: decompression_memory_size Cycles: 11",
      "ja": "出力：decompression_memory_sizeサイクル：11"
    },
    {
      "indent": 3,
      "text": "0xf8ff ff",
      "ja": "0xf8ffのFF"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：なし圧縮解除-FAILUREのMESSAGE_TOO_SHORT"
    },
    {
      "indent": 3,
      "text": "0xf800 ffff",
      "ja": "0xf800 FFFF"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：なし圧縮解除-FAILUREのMESSAGE_TOO_SHORT"
    },
    {
      "indent": 3,
      "text": "0xf801 8108 0002 2200 0222 a092 0523 ffff 0000 0000 0000 00ff 00ff 0x03ff ffff",
      "ja": "0xf801 A092 0222 2200 8108 0523 0002 0000 0000 0000 FFFF FFFF 00FFの00FFの0x03ff"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：なし圧縮解除-FAILUREのMESSAGE_TOO_SHORT"
    },
    {
      "indent": 3,
      "text": "0xf801 7008 0002 2200 0222 a092 0523 ffff 0000 0000 0000 00ff 04ff 0xffff ff",
      "ja": "0xf801 A092 0222 2200 7008 0523 0002 0000 0000 0000 FFFF FFの00FFの04ffは0xFFFF"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE INVALID_CODE_LOCATION",
      "ja": "入力：なし圧縮解除-FAILUREのINVALID_CODE_LOCATION"
    },
    {
      "indent": 0,
      "text": "A.2.5. Input Past the End of a Message",
      "ja": "A.2.5。メッセージの最後過去の入力"
    },
    {
      "indent": 3,
      "text": "0xf803 210e 86a0 460e a042 a04d 1d09 a046 0a1c 07a0 4606 001d 07a0 0x46ff 1c02 a046 fa22 a046 021d 10a0 4606 001d 08a0 46ff 22a0 4701 0x23",
      "ja": "0xf803 210E 86a0 460E A042 a04d 1d09 A046 0a1c 07a0 4606 001D 07a0 0x46ff 1c02 A046 fa22 A046 021d 10a0 4606 001D 08a0 46ff 22a0 4701 0x23"
    },
    {
      "indent": 3,
      "text": "Input: 0xfffa 0068 6921 Output: 0x6869 21 Cycles: 23",
      "ja": "入力：0xfffa 0068 6921出力：0x6869 21サイクル：23"
    },
    {
      "indent": 3,
      "text": "Input: 0xfffa 0068 69 DECOMPRESSION-FAILURE USER_REQUESTED (not enough bits)",
      "ja": "入力：0xfffa 0068 69圧縮解除-FAILURE USER_REQUESTED（足りないビット）"
    },
    {
      "indent": 0,
      "text": "A.3. State Handler Tests",
      "ja": "A.3。状態ハンドラのテスト"
    },
    {
      "indent": 0,
      "text": "A.3.1. SigComp Feedback Mechanism",
      "ja": "A.3.1。 SigCompフィードバックメカニズム"
    },
    {
      "indent": 3,
      "text": "0xf805 031c 01a0 41a0 5517 6001 070e a04f 0ea0 42a4 7f16 0e0e a042 0xa4ff 15a0 44a0 7f01 010e a0c3 a801 0ea0 c5a6 000e a0cc ac00 0ea0 0xd9b4 000e a0ee b500 15a0 c606 0001 15a0 cd0c 0001 15a0 da14 0001 0x23a0 42a0 c3",
      "ja": "0ea0 42a4 7F16 0e0eのA042 0xa4ff 15a0 44a0 7f01 010e a0c3 A801 0ea0 c5a6 000E a0cc AC00 0ea0 0xd9b4 000E a0ee B500 15a0 C606 0001 15a0 cd0c 0001 15a0 DA14 0001 0x23a0 42a0 C3 a04f 0xf805 031c 01A0 41a0 5517 6001 070e"
    },
    {
      "indent": 3,
      "text": "Input: 0x00 Output: None Cycles: 52",
      "ja": "入力：0x00の出力：なしサイクル：52"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 Output: None Cycles: 179",
      "ja": "入力：0x01の出力：なしサイクル：179"
    },
    {
      "indent": 0,
      "text": "A.3.2. State Memory Management",
      "ja": "A.3.2。状態のメモリ管理"
    },
    {
      "indent": 3,
      "text": "0xf81b a10f 8602 89a2 041c 01a0 47f9 1763 0508 a068 a070 1763 0307 0x34a0 5608 2306 0623 a204 0ea0 4463 0623 0612 6202 a04a 1762 6308 0xa058 9fd2 0ea0 4865 0824 8820 6489 0006 6506 2202 16e3 1fa2 1606 0x0000 0000 1fa2 1c06 0000 0000 1fa2 2206 0000 0000 1fa2 2e06 0000 0x0000 161e 1fa2 2806 0000 0000 1614 208b 8900 0600 160c 1fa2 3406 0x0000 0000 1602 2300 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0074 6573 0x7400 0000 0100 0200 0300 0400 0300 0200 0100 008e ea4b 43a7 87f9 0x010e ef56 7b23 9a34 6b15 a6b4 0fc0 e44d 2cd4 a221 47e6 0aef f2bc 0x0fb6 af",
      "ja": "5608 2306 0623 A204の0ea0 4463 0623 0612 6202 A04A 1762 6308 0xa058 9fd2 0ea0 4865 0824 8820 6489 0006 6506 2202 16e3 1fa2 1606 0000 0000 1fa2 1c06 0000 0000 1fa2 2206 0000 0000 1fa2 0x34a0 8602 89a2 041c 01A0 47f9 1763 0508 A068とA070 1763 0307 a10f 0xf81b 160C 1fa2 3406×0000 0000 1602 2300 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 208B 8900 0600 2e06 0000×0000 161E 1fa2 2806 0000 0000 1614 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0074 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 6573 0100 0200 0300 0400 0300 0200 0100 0000 0x7400 008eのea4b 43a7 87f9の0x010eのef56 7b23 9a34 6b15 a6b4 0fc0 E44D 2cd4 A221 47e6 0aef f2bc 0x0fb6 AF"
    },
    {
      "indent": 3,
      "text": "Input: 0x00 Output: None Cycles: 811",
      "ja": "入力：0x00の出力：なしサイクル：811"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 Output: None Cycles: 2603",
      "ja": "入力：0x01の出力：なしサイクル：2603"
    },
    {
      "indent": 3,
      "text": "Input: 0x02 Output: None Cycles: 811",
      "ja": "入力：0x02の出力：なしサイクル：811"
    },
    {
      "indent": 3,
      "text": "Input: 0x03 Output: None Cycles: 1805",
      "ja": "入力：0x03の出力：なしサイクル：1805"
    },
    {
      "indent": 3,
      "text": "Input: 0x04 DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": "入力：0x04を圧縮解除-FAILURE STATE_NOT_FOUND"
    },
    {
      "indent": 3,
      "text": "Input: 0x05 Output: None Cycles: 2057",
      "ja": "入力：0x05の出力：なしサイクル：2057"
    },
    {
      "indent": 3,
      "text": "Input: 0x06 Output: None Cycles: 1993",
      "ja": "入力：0x06の出力：なしサイクル：1993"
    },
    {
      "indent": 0,
      "text": "A.3.3. Multiple Compartments",
      "ja": "A.3.3。複数のコンパートメント"
    },
    {
      "indent": 3,
      "text": "0xf81b 110f 8602 89a2 071c 01a0 45f9 1762 030d 3d06 1762 0537 86a0 0x6806 2289 20a1 c062 0006 0006 2203 20a1 c062 0006 0007 22a2 020a 0x2203 0622 a203 20a1 c062 0006 0020 a1c0 a206 0006 6216 2b20 a7c0 0x2000 0600 1622 1fa2 1306 0000 0000 1fa2 1906 0000 0000 1fa2 2506 0x0000 0000 1fa2 2b06 0000 0000 2300 0000 0000 0000 1762 0706 101a 0x1fa2 0706 0000 0000 16ea 1fa2 0d06 0000 0000 16e0 1fa2 1f06 0000 0x0000 169f d600 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0102 0x0304 0506 aca6 0b8e b283 9dbf afc6 3dd2 34c5 d91d 5361 bdd6 ba2a 0xc65a 47c2 1814 ee07 c275 941d d7a1 4887 9c8d e90e",
      "ja": "0xf81b 110F 45f9 1762 030d 3d06 1762 0537 86a0 0x6806 2289 20A1 c062 0006 0006 2203 20A1 c062 0006 0007 22A2 020A 0x2203 0622 8602 89a2 071c 01A0 A203 20A1 c062 0006 0020 a1c0のA206 0006 6216 2b20 1fa2 1906 0000 0000 0x2000で0600 1622 1fa2 1306 0000 0000 a7c0 1fa2 2506 0000 0000 1fa2 2b06 0000 0000 2300 0000 0000 0000 1762 0706 101A 0x1fa2 0706 0000 0000 16ea 1fa2 0d06 0000 0000 16e0 1fa2 1f06 0000 0000 D600 169f 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0102 0506 0x0304 aca6の0b8eのb283 9dbf afc6 3dd2 34c5 d91d 5361 bdd6 ba2a 0xc65a 47c2 1814 ee07 c275 941D d7a1 4887 9c8d e90e"
    },
    {
      "indent": 3,
      "text": "Input: 0x00 Output: None Cycles: 1809",
      "ja": "入力：0x00の出力：なしサイクル：1809"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 Output: None Cycles: 1809",
      "ja": "入力：0x01の出力：なしサイクル：1809"
    },
    {
      "indent": 3,
      "text": "Input: 0x02 Output: None Cycles: 1809",
      "ja": "入力：0x02の出力：なしサイクル：1809"
    },
    {
      "indent": 3,
      "text": "Input: 0x03 Output: None Cycles: 1993",
      "ja": "入力：0x03の出力：なしサイクル：1993"
    },
    {
      "indent": 3,
      "text": "Input: 0x04 Output: None Cycles: 1994",
      "ja": "入力：0x04を出力：なしサイクル：1994"
    },
    {
      "indent": 3,
      "text": "Input: 0x05 Output: None Cycles: 1804",
      "ja": "入力：0x05の出力：なしサイクル：1804"
    },
    {
      "indent": 3,
      "text": "Input: 0x06 DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": "入力：0x06の圧縮解除-FAILURE STATE_NOT_FOUND"
    },
    {
      "indent": 3,
      "text": "Input: 0x07 DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": "入力：0x07の圧縮解除-FAILURE STATE_NOT_FOUND"
    },
    {
      "indent": 3,
      "text": "Input: 0x08 DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": "入力：0x08に圧縮解除-FAILURE STATE_NOT_FOUND"
    },
    {
      "indent": 0,
      "text": "A.3.4. Accessing State",
      "ja": "A.3.4。州へのアクセス"
    },
    {
      "indent": 3,
      "text": "0xf803 a11f a0a6 14ac fe01 2000 1fa0 a606 acff 0121 001f a0a6 0cad 0x0001 2200 2220 0323 0000 0000 0000 00fb e507 dfe5 e6aa 5af2 abb9 0x14ce aa05 f99c e61b a5",
      "ja": "0121 001F a0a6 0CADは0x0001 2220 0323 0000 0000 0000 2200 00fb E507 dfe5 e6aa 5af2 abb9 0x14ce aa05 f99c e61b A5 acff 0xf803 a11f a0a6 14ac FE01 2000 1fa0のA606"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x5349 50 Cycles: 11",
      "ja": "入力：なし出力：0x5349 50サイクル：11"
    },
    {
      "indent": 0,
      "text": "A.3.5. Bytecode State Creation",
      "ja": "A.3.5。バイトコードの状態の作成"
    },
    {
      "indent": 3,
      "text": "0xf804 6112 a0be 081e 2008 1e21 060a 0e23 be03 12a0 be08 a050 2008 0xa050 a053 140a 2008 a050 a053 0c0a 1606 004f 4b31 1c01 a0b3 fc22 0xa0a8 0323 0000 0da0 a8a0 ab06 0a4f 4b32 22a0 5003 2302",
      "ja": "0xf804 6112 a0beの081e 2008 1E21 060a 0e23 be03 12a0 be08 A050 2008 0xa050 A053 140A 2008 A050 A053の0C0A 1606 004f 4b31 1C01 a0b3 FC22 0xa0a8 0323 0000 0da0 a8a0 AB06 0a4f 4b32 22a0 5003 2302"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x4f4b Cycles: 66",
      "ja": "入力：なし出力：0x4f4bサイクル：66"
    },
    {
      "indent": 3,
      "text": "0xf905 b88c e72c 9103",
      "ja": "0xf905 b88cのe72c 9103"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x4f4b 31 Cycles: 7",
      "ja": "入力：なし出力：0x4f4b 31サイクル：7"
    },
    {
      "indent": 3,
      "text": "0xfb24 63cd ff5c f8c7 6df6 a289 ff",
      "ja": "0xfb24 63cd ff5c f8c7 6df6 a289 FF"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x4f4b 32 Cycles: 5",
      "ja": "入力：なし出力：0x4f4b 32サイクル：5"
    },
    {
      "indent": 3,
      "text": "0xf95b 4b43 d567 83",
      "ja": "0xf95bの4b43のd567 83"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x0000 32 Cycles: 5",
      "ja": "入力：なし出力：0x0000に32サイクル：5"
    },
    {
      "indent": 3,
      "text": "0xf9de 8126 1199 1f",
      "ja": "0xf9de 8126 1199 1F"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": "入力：なし解凍-FAILURE STATE_NOT_FOUND"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Abigail Surtees Siemens/Roke Manor Research Roke Manor Research Ltd. Romsey, Hants SO51 0ZN UK",
      "ja": "アビゲイルサーティースシーメンス/ Rokeマナー研究Rokeマナーリサーチ株式会社ロムジー、ハンツSO51 0ZN英国"
    },
    {
      "indent": 3,
      "text": "Phone: +44 (0)1794 833131 EMail: abigail.surtees@roke.co.uk URI: http://www.roke.co.uk",
      "ja": "電話：+44（0）1794 833131 Eメール：URI abigail.surtees@roke.co.uk：http://www.roke.co.uk"
    },
    {
      "indent": 3,
      "text": "Mark A. West Siemens/Roke Manor Research Roke Manor Research Ltd. Romsey, Hants SO51 0ZN UK",
      "ja": "マーク・A.西シーメンス/ Rokeマナー研究Rokeマナーリサーチ株式会社ロムジー、ハンツSO51 0ZN英国"
    },
    {
      "indent": 3,
      "text": "Phone: +44 (0)1794 833311 EMail: mark.a.west@roke.co.uk URI: http://www.roke.co.uk",
      "ja": "電話：+44（0）1794 833311 Eメール：mark.a.west@roke.co.uk URI：http://www.roke.co.uk"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "著作権（C）インターネット協会（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディタ機能のための資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}