{
  "title": {
    "text": "RFC 4210 - Internet X.509 Public Key Infrastructure Certificate Management Protocol (CMP)",
    "ja": "RFC 4210 - インターネットX.509公開鍵基盤証明書管理プロトコル（CMP）"
  },
  "number": 4210,
  "created_at": "2019-10-21 23:53:53.310470+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           C. Adams\nRequest for Comments: 4210                          University of Ottawa\nObsoletes: 2510                                               S. Farrell\nCategory: Standards Track                         Trinity College Dublin\n                                                                T. Kause\n                                                                     SSH\n                                                              T. Mononen\n                                                                 SafeNet\n                                                          September 2005",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Internet X.509 Public Key Infrastructure\n  Certificate Management Protocol (CMP)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes the Internet X.509 Public Key Infrastructure (PKI) Certificate Management Protocol (CMP). Protocol messages are defined for X.509v3 certificate creation and management. CMP provides on-line interactions between PKI components, including an exchange between a Certification Authority (CA) and a client system.",
      "ja": "このドキュメントはインターネットX.509公開鍵基盤（PKI）証明書管理プロトコル（CMP）について説明します。プロトコルメッセージは、X.509v3証明書の作成と管理のために定義されています。 CMPは、証明機関（CA）とクライアント・システムとの間の交換を含むPKIコンポーネント間のオンライン相互作用を提供します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n2. Requirements ....................................................5\n3. PKI Management Overview .........................................5\n   3.1. PKI Management Model .......................................6\n        3.1.1. Definitions of PKI Entities .........................6\n               3.1.1.1. Subjects and End Entities ..................6\n               3.1.1.2. Certification Authority ....................7\n               3.1.1.3. Registration Authority .....................7\n        3.1.2. PKI Management Requirements .........................8\n        3.1.3. PKI Management Operations ..........................10\n4. Assumptions and Restrictions ...................................14\n   4.1. End Entity Initialization .................................14",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   4.2. Initial Registration/Certification ........................14\n        4.2.1. Criteria Used ......................................15\n               4.2.1.1. Initiation of Registration/Certification ..15\n               4.2.1.2. End Entity Message Origin Authentication ..15\n               4.2.1.3. Location of Key Generation ................15\n               4.2.1.4. Confirmation of Successful Certification ..16\n        4.2.2. Mandatory Schemes ..................................16\n               4.2.2.1. Centralized Scheme ........................16\n               4.2.2.2. Basic Authenticated Scheme ................17\n   4.3. Proof-of-Possession (POP) of Private Key ..................17\n        4.3.1. Signature Keys .....................................18\n        4.3.2. Encryption Keys ....................................18\n        4.3.3. Key Agreement Keys .................................19\n   4.4. Root CA Key Update ........................................19\n        4.4.1. CA Operator Actions ................................20\n        4.4.2. Verifying Certificates .............................21\n               4.4.2.1. Verification in Cases 1, 4, 5, and 8 ......22\n               4.4.2.2. Verification in Case 2 ....................22\n               4.4.2.3. Verification in Case 3 ....................23\n               4.4.2.4. Failure of Verification in Case 6 .........23\n               4.4.2.5. Failure of Verification in Case 7 .........23\n        4.4.3. Revocation - Change of CA Key ......................23\n5. Data Structures ................................................24\n   5.1. Overall PKI Message .......................................24\n        5.1.1. PKI Message Header .................................24\n               5.1.1.1. ImplicitConfirm ...........................27\n               5.1.1.2. ConfirmWaitTime ...........................27\n        5.1.2. PKI Message Body ...................................27\n        5.1.3. PKI Message Protection .............................28\n               5.1.3.1. Shared Secret Information .................29\n               5.1.3.2. DH Key Pairs ..............................30\n               5.1.3.3. Signature .................................30\n               5.1.3.4. Multiple Protection .......................30\n   5.2. Common Data Structures ....................................31\n        5.2.1. Requested Certificate Contents .....................31\n        5.2.2. Encrypted Values ...................................31\n        5.2.3. Status codes and Failure Information for\n               PKI Messages .......................................32\n        5.2.4. Certificate Identification .........................33\n        5.2.5. Out-of-band root CA Public Key .....................33\n        5.2.6. Archive Options ....................................34\n        5.2.7. Publication Information ............................34\n        5.2.8. Proof-of-Possession Structures .....................34\n               5.2.8.1. Inclusion of the Private Key ..............35\n               5.2.8.2. Indirect Method ...........................35\n               5.2.8.3. Challenge-Response Protocol ...............35\n               5.2.8.4. Summary of PoP Options ....................37",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   5.3. Operation-Specific Data Structures ........................38\n        5.3.1. Initialization Request .............................38\n        5.3.2. Initialization Response ............................39\n        5.3.3. Certification Request ..............................39\n        5.3.4. Certification Response .............................39\n        5.3.5. Key Update Request Content .........................40\n        5.3.6. Key Update Response Content ........................41\n        5.3.7. Key Recovery Request Content .......................41\n        5.3.8. Key Recovery Response Content ......................41\n        5.3.9. Revocation Request Content .........................41\n        5.3.10. Revocation Response Content .......................42\n        5.3.11. Cross Certification Request Content ...............42\n        5.3.12. Cross Certification Response Content ..............42\n        5.3.13. CA Key Update Announcement Content ................42\n        5.3.14. Certificate Announcement ..........................43\n        5.3.15. Revocation Announcement ...........................43\n        5.3.16. CRL Announcement ..................................43\n        5.3.17. PKI Confirmation Content ..........................43\n        5.3.18. Certificate Confirmation Content ..................44\n        5.3.19. PKI General Message Content .......................44\n               5.3.19.1. CA Protocol Encryption Certificate .......44\n               5.3.19.2. Signing Key Pair Types ...................45\n               5.3.19.3. Encryption/Key Agreement Key Pair Types ..45\n               5.3.19.4. Preferred Symmetric Algorithm ............45\n               5.3.19.5. Updated CA Key Pair ......................45\n               5.3.19.6. CRL ......................................46\n               5.3.19.7. Unsupported Object Identifiers ...........46\n               5.3.19.8. Key Pair Parameters ......................46\n               5.3.19.9. Revocation Passphrase ....................46\n               5.3.19.10. ImplicitConfirm .........................46\n               5.3.19.11. ConfirmWaitTime .........................47\n               5.3.19.12. Original PKIMessage .....................47\n               5.3.19.13. Supported Language Tags .................47\n        5.3.20. PKI General Response Content ......................47\n        5.3.21. Error Message Content .............................47\n        5.3.22. Polling Request and Response ......................48\n6. Mandatory PKI Management Functions .............................51\n   6.1. Root CA Initialization ....................................51\n   6.2. Root CA Key Update ........................................51\n   6.3. Subordinate CA Initialization .............................51\n   6.4. CRL production ............................................52\n   6.5. PKI Information Request ...................................52\n   6.6. Cross Certification .......................................52\n        6.6.1. One-Way Request-Response Scheme: ...................52\n   6.7. End Entity Initialization .................................54\n        6.7.1. Acquisition of PKI Information .....................54\n        6.7.2. Out-of-Band Verification of Root-CA Key ............55\n   6.8. Certificate Request .......................................55",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   6.9. Key Update ................................................55\n7. Version Negotiation ............................................56\n   7.1. Supporting RFC 2510 Implementations .......................56\n        7.1.1. Clients Talking to RFC 2510 Servers ................56\n        7.1.2. Servers Receiving Version cmp1999 PKIMessages ......57\n8. Security Considerations ........................................57\n   8.1. Proof-Of-Possession with a Decryption Key .................57\n   8.2. Proof-Of-Possession by Exposing the Private Key ...........57\n   8.3. Attack Against Diffie-Hellman Key Exchange ................57\n9. IANA Considerations ............................................58\nNormative References ..............................................58\nInformative References ............................................59\nA. Reasons for the Presence of RAs ................................61\nB. The Use of Revocation Passphrase ...............................61\nC. Request Message Behavioral Clarifications ......................63\nD. PKI Management Message Profiles (REQUIRED) .....................65\n   D.1. General Rules for Interpretation of These Profiles ........65\n   D.2. Algorithm Use Profile .....................................66\n   D.3. Proof-of-Possession Profile ...............................68\n   D.4. Initial Registration/Certification (Basic\n        Authenticated Scheme) .....................................68\n   D.5. Certificate Request .......................................74\n   D.6. Key Update Request ........................................75\nE. PKI Management Message Profiles (OPTIONAL) .....................75\n   E.1. General Rules for Interpretation of These Profiles ........76\n   E.2. Algorithm Use Profile .....................................76\n   E.3. Self-Signed Certificates ..................................76\n   E.4. Root CA Key Update ........................................77\n   E.5. PKI Information Request/Response ..........................77\n   E.6. Cross Certification Request/Response (1-way) ..............79\n   E.7. In-Band Initialization Using External Identity\n        Certificate  ..............................................82\nF. Compilable ASN.1 Definitions ...................................83\nG. Acknowledgements ...............................................93",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the Internet X.509 Public Key Infrastructure (PKI) Certificate Management Protocol (CMP). Protocol messages are defined for certificate creation and management. The term \"certificate\" in this document refers to an X.509v3 Certificate as defined in [X509].",
      "ja": "このドキュメントはインターネットX.509公開鍵基盤（PKI）証明書管理プロトコル（CMP）について説明します。プロトコルメッセージは、証明書の作成と管理のために定義されています。 [X509]で定義されるように、この文書に記載されている用語「証明書」のX.509v3証明書をいいます。"
    },
    {
      "indent": 3,
      "text": "This specification obsoletes RFC 2510. This specification differs from RFC 2510 in the following areas:",
      "ja": "この仕様は、この仕様は、以下の分野でRFC 2510と異なりRFC 2510を廃止します："
    },
    {
      "indent": 6,
      "text": "The PKI management message profile section is split to two appendices: the required profile and the optional profile. Some of the formerly mandatory functionality is moved to the optional profile.",
      "ja": "必要なプロファイル及び任意プロファイル：PKI管理メッセージプロファイルセクションでは、2本の付録に分割されます。以前は必須の機能のいくつかは、オプションのプロファイルに移動します。"
    },
    {
      "indent": 6,
      "text": "The message confirmation mechanism has changed substantially.",
      "ja": "メッセージ確認機構は、実質的に変化しています。"
    },
    {
      "indent": 6,
      "text": "A new polling mechanism is introduced, deprecating the old polling method at the CMP transport level.",
      "ja": "新しいポーリング機構はCMP輸送レベルで古いポーリング方式を非推奨、導入されます。"
    },
    {
      "indent": 6,
      "text": "The CMP transport protocol issues are handled in a separate document [CMPtrans], thus the Transports section is removed.",
      "ja": "CMPトランスポートプロトコルの問題は、このように移送部が除去された別の文書[CMPtrans]で処理されます。"
    },
    {
      "indent": 6,
      "text": "A new implicit confirmation method is introduced to reduce the number of protocol messages exchanged in a transaction.",
      "ja": "新しい暗黙の確認方法は、トランザクションで交換されたプロトコルメッセージの数を減らすために導入されます。"
    },
    {
      "indent": 6,
      "text": "The new specification contains some less prominent protocol enhancements and improved explanatory text on several issues.",
      "ja": "新しい仕様では、いくつかの目立たプロトコルの拡張機能といくつかの問題についての改善説明テキストが含まれています。"
    },
    {
      "indent": 0,
      "text": "2. Requirements",
      "section_title": true,
      "ja": "2.要件"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document (in uppercase, as shown) are to be interpreted as described in [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、（図示のように、大文字で）この文書では、 \"SHOULD\"、 \"推奨\" \"NOT SHOULD\"、 \"MAY\"、 \"OPTIONAL\" は可能になっています[RFC2119]で説明されるように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. PKI Management Overview",
      "section_title": true,
      "ja": "3. PKI管理の概要"
    },
    {
      "indent": 3,
      "text": "The PKI must be structured to be consistent with the types of individuals who must administer it. Providing such administrators with unbounded choices not only complicates the software required, but also increases the chances that a subtle mistake by an administrator or software developer will result in broader compromise. Similarly, restricting administrators with cumbersome mechanisms will cause them not to use the PKI.",
      "ja": "PKIは、それを管理する必要があり、個人のタイプと一致するように構成されなければなりません。無限の選択肢が、このような管理者に提供するだけでなく、必要なソフトウェアを複雑にするだけでなく、管理者やソフトウェア開発者によって微妙なミスはより広範な妥協につながる可能性が高くなり。同様に、面倒なメカニズムを管理者に制限すると、彼らはPKIを使用しない原因となります。"
    },
    {
      "indent": 3,
      "text": "Management protocols are REQUIRED to support on-line interactions between Public Key Infrastructure (PKI) components. For example, a management protocol might be used between a Certification Authority (CA) and a client system with which a key pair is associated, or between two CAs that issue cross-certificates for each other.",
      "ja": "管理プロトコルは、公開鍵基盤（PKI）コンポーネント間のオンライン対話をサポートする必要があります。例えば、管理プロトコルは、認証局（CA）と鍵ペアが関連付けられた、または、互いに相互証明書を発行2つのCA間しているクライアントシステムの間で使用されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.1. PKI Management Model",
      "section_title": true,
      "ja": "3.1。 PKI管理モデル"
    },
    {
      "indent": 3,
      "text": "Before specifying particular message formats and procedures, we first define the entities involved in PKI management and their interactions (in terms of the PKI management functions required). We then group these functions in order to accommodate different identifiable types of end entities.",
      "ja": "特定のメッセージフォーマットおよび手順を指定する前に、まずPKI管理と（必要なPKI管理機能の点で）それらの相互作用に関与するエンティティを定義します。私たちは、グループの順序でこれらの機能は、エンドエンティティの異なる識別可能なタイプに対応します。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Definitions of PKI Entities",
      "section_title": true,
      "ja": "3.1.1。 PKIエンティティの定義"
    },
    {
      "indent": 3,
      "text": "The entities involved in PKI management include the end entity (i.e., the entity to whom the certificate is issued) and the certification authority (i.e., the entity that issues the certificate). A registration authority MAY also be involved in PKI management.",
      "ja": "PKI管理に関与するエンティティは、エンドエンティティが含まれる（すなわち、証明書が発行された人に実体）と認証局（すなわち、証明書を発行するエンティティ）。登録機関はまた、PKI管理に関与している可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1. Subjects and End Entities",
      "section_title": true,
      "ja": "3.1.1.1。対象およびエンドエンティティ"
    },
    {
      "indent": 3,
      "text": "The term \"subject\" is used here to refer to the entity to whom the certificate is issued, typically named in the subject or subjectAltName field of a certificate. When we wish to distinguish the tools and/or software used by the subject (e.g., a local certificate management module), we will use the term \"subject equipment\". In general, the term \"end entity\" (EE), rather than \"subject\", is preferred in order to avoid confusion with the field name. It is important to note that the end entities here will include not only human users of applications, but also applications themselves (e.g., for IP security). This factor influences the protocols that the PKI management operations use; for example, application software is far more likely to know exactly which certificate extensions are required than are human users. PKI management entities are also end entities in the sense that they are sometimes named in the subject or subjectAltName field of a certificate or cross-certificate. Where appropriate, the term \"end-entity\" will be used to refer to end entities who are not PKI management entities.",
      "ja": "「対象」という用語は、一般的に、証明書のサブジェクトまたはのsubjectAltNameフィールドで指定された証明書が発行され、誰に実体を参照するためにここで使用されます。我々は被験者によって使用されるツールおよび/またはソフトウェア（例えば、ローカル証明書管理モジュール）を区別したいとき、私たちは、用語「対象機器」を使用します。一般に、用語むしろ「対象」よりも「エンドエンティティ」（EE）は、フィールド名との混同を避けるために好ましいです。 （IPセキュリティのために、例えば）ここでは、エンドエンティティだけでなく、人間のアプリケーションのユーザーだけでなく、アプリケーション自体が含まれることに注意することが重要です。この要因は、PKI管理操作が使用するプロトコルに影響を与えます。例えば、アプリケーションソフトウェアは、証明書の拡張は、人間のユーザーよりも必要とされているかを正確に知ることがはるかに可能性が高いです。 PKI管理エンティティはまた、彼らは時々証明書またはクロス証明書のサブジェクトまたはのsubjectAltNameフィールドで指定されているという意味でエンティティを終了しています。適切な場合には、用語「エンドエンティティは、」PKI管理エンティティでないエンティティを終了するために参照するために使用されます。"
    },
    {
      "indent": 3,
      "text": "All end entities require secure local access to some information -- at a minimum, their own name and private key, the name of a CA that is directly trusted by this entity, and that CA's public key (or a fingerprint of the public key where a self-certified version is available elsewhere). Implementations MAY use secure local storage for more than this minimum (e.g., the end entity's own certificate or application-specific information). The form of storage will also vary -- from files to tamper-resistant cryptographic tokens. The information stored in such local, trusted storage is referred to here as the end entity's Personal Security Environment (PSE).",
      "ja": "最低でも、自分の名前と秘密鍵、直接このエンティティから信頼されるCAの名前、およびCAの公開鍵ということ（あるいは公開鍵どこの指紋 - すべてのエンドエンティティは、いくつかの情報へのローカルアクセスを確保する必要が自己認定バージョン）他の場所で使用可能です。実装は、この最小値以上（例えば、エンドエンティティ自身の証明書またはアプリケーション固有の情報）のために安全なローカルストレージを使用するかもしれません。ストレージの形も変化します - 暗号化トークン耐性を改ざんするファイルから。ローカル、信頼されたストレージに格納されている情報は、エンドエンティティのパーソナルセキュリティ環境（PSE）と、ここで呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Though PSE formats are beyond the scope of this document (they are very dependent on equipment, et cetera), a generic interchange format for PSEs is defined here: a certification response message MAY be used.",
      "ja": "PSE形式はこのドキュメントの範囲を超えていますが（彼らは機器に非常に依存している、とcetera）、のPSEのための一般的な交換形式はここで定義される：認証応答メッセージが使用されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.1.1.2. Certification Authority",
      "section_title": true,
      "ja": "3.1.1.2。認証局"
    },
    {
      "indent": 3,
      "text": "The certification authority (CA) may or may not actually be a real \"third party\" from the end entity's point of view. Quite often, the CA will actually belong to the same organization as the end entities it supports.",
      "ja": "認証局（CA）は、あるいは、実際にビューのエンドエンティティの視点から本当の「第三者」であってもなくてもよいです。かなり頻繁に、CAは、実際にそれがサポートするエンド・エンティティと同じ組織に属しています。"
    },
    {
      "indent": 3,
      "text": "Again, we use the term \"CA\" to refer to the entity named in the issuer field of a certificate. When it is necessary to distinguish the software or hardware tools used by the CA, we use the term \"CA equipment\".",
      "ja": "ここでも、我々は、証明書の発行人欄に名前付きエンティティを参照するために用語「CA」を使用します。それはCAが使用するソフトウェアやハードウェアのツールを区別する必要があるとき、私たちは、用語「CA機器」を使用します。"
    },
    {
      "indent": 3,
      "text": "The CA equipment will often include both an \"off-line\" component and an \"on-line\" component, with the CA private key only available to the \"off-line\" component. This is, however, a matter for implementers (though it is also relevant as a policy issue).",
      "ja": "CA機器は、多くの場合、「オフライン」コンポーネントにのみ利用可能CA秘密鍵で、「オフライン」コンポーネントおよび「オンライン」コンポーネントの両方が含まれます。 （それはまた、政策課題として適切であるが）これは、しかし、実装の問題です。"
    },
    {
      "indent": 3,
      "text": "We use the term \"root CA\" to indicate a CA that is directly trusted by an end entity; that is, securely acquiring the value of a root CA public key requires some out-of-band step(s). This term is not meant to imply that a root CA is necessarily at the top of any hierarchy, simply that the CA in question is trusted directly.",
      "ja": "私たちは直接エンドエンティティによって信頼されるCAを示すために、用語「ルートCA」を使用します。それは確実に、ルートCAの公開鍵の値を取得することは、いくつかのアウトオブバンドの工程（単数または複数）が必要です。この用語は、ルートCAは、問題のCAが直接信頼されていることだけで、あらゆる階層の最上位に必然であることを意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "A \"subordinate CA\" is one that is not a root CA for the end entity in question. Often, a subordinate CA will not be a root CA for any entity, but this is not mandatory.",
      "ja": "「下位CAは、」問題のエンドエンティティのルートCAではないものです。多くの場合、下位CAは、任意のエンティティのルートCAではありませんが、これは必須ではありません。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3. Registration Authority",
      "section_title": true,
      "ja": "3.1.1.3。登録認定機関"
    },
    {
      "indent": 3,
      "text": "In addition to end-entities and CAs, many environments call for the existence of a Registration Authority (RA) separate from the Certification Authority. The functions that the registration authority may carry out will vary from case to case but MAY include personal authentication, token distribution, revocation reporting, name assignment, key generation, archival of key pairs, et cetera.",
      "ja": "およびCAS-エンドエンティティに加えて、多くの環境では、認証局とは別の登録機関（RA）の存在を呼び出します。登録機関が行うようにしてもよい機能は場合によって異なるだろうが、個人認証、トークン配布、失効報告、名前の割り当て、鍵生成、鍵ペアのアーカイブ、エトセトラを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "This document views the RA as an OPTIONAL component: when it is not present, the CA is assumed to be able to carry out the RA's functions so that the PKI management protocols are the same from the end-entity's point of view.",
      "ja": "この文書では、任意成分としてRAを見：それが存在しない場合、CAは、PKI管理プロトコルは、ビューのエンドエンティティの点から同じであるように、RAの機能を実行することができるものとします。"
    },
    {
      "indent": 3,
      "text": "Again, we distinguish, where necessary, between the RA and the tools used (the \"RA equipment\").",
      "ja": "ここでも、我々はRAと使用するツール（「RA機器」）との間で、必要に応じ区別します。"
    },
    {
      "indent": 3,
      "text": "Note that an RA is itself an end entity. We further assume that all RAs are in fact certified end entities and that RAs have private keys that are usable for signing. How a particular CA equipment identifies some end entities as RAs is an implementation issue (i.e., this document specifies no special RA certification operation). We do not mandate that the RA is certified by the CA with which it is interacting at the moment (so one RA may work with more than one CA whilst only being certified once).",
      "ja": "RAはエンドエンティティそのものであることに注意してください。我々はさらに、すべてのRASが実際にエンドエンティティを認定し、RASが署名のために使用可能な秘密鍵を持っていることをしていることを前提としています。 Rasは、実装の問題であるように、特定のCA機器は、いくつかのエンドエンティティを特定する方法（すなわち、この文書には、特別なRA認証操作を指定していません）。私たちは、RAが、それは現時点で対話しているCAによって認定されていることを強制しません（その1 RAは一度しか認定されている間に複数のCAで動作可能）。"
    },
    {
      "indent": 3,
      "text": "In some circumstances, end entities will communicate directly with a CA even where an RA is present. For example, for initial registration and/or certification, the subject may use its RA, but communicate directly with the CA in order to refresh its certificate.",
      "ja": "いくつかの状況では、エンドエンティティはRAが存在してもCAと直接通信します。例えば、初期登録および/または認証のために、被験者は、RAを使用することができるが、その証明書をリフレッシュするためにCAと直接通信します。"
    },
    {
      "indent": 0,
      "text": "3.1.2. PKI Management Requirements",
      "section_title": true,
      "ja": "3.1.2。 PKI管理の要件"
    },
    {
      "indent": 3,
      "text": "The protocols given here meet the following requirements on PKI management",
      "ja": "ここで与えられたプロトコルは、PKI管理に関する次の要件を満たしています"
    },
    {
      "indent": 3,
      "text": "1. PKI management must conform to the ISO/IEC 9594-8/ITU-T X.509 standards.",
      "ja": "1. PKI管理は、ISO / IEC 9594から8 / ITU-TのX.509標準に準拠しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. It must be possible to regularly update any key pair without affecting any other key pair.",
      "ja": "2.定期的に他のキーのペアに影響を与えることなく、任意のキーのペアを更新することが可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. The use of confidentiality in PKI management protocols must be kept to a minimum in order to ease acceptance in environments where strong confidentiality might cause regulatory problems.",
      "ja": "3. PKI管理プロトコルにおける機密性の使用は強い機密性は規制問題を引き起こす可能性がある環境での受け入れを容易にするために最小限に抑える必要があります。"
    },
    {
      "indent": 3,
      "text": "4. PKI management protocols must allow the use of different industry-standard cryptographic algorithms (specifically including RSA, DSA, MD5, and SHA-1). This means that any given CA, RA, or end entity may, in principle, use whichever algorithms suit it for its own key pair(s).",
      "ja": "4. PKI管理プロトコル（具体的にRSA、DSA、MD5およびSHA-1など）の異なる業界標準の暗号化アルゴリズムの使用を可能にしなければなりません。これは、任意のCA、RA、またはエンドエンティティは、原則として、使用どちらのアルゴリズムは、独自の鍵のペア（S）のためにそれに合うことを意味します。"
    },
    {
      "indent": 3,
      "text": "5. PKI management protocols must not preclude the generation of key pairs by the end-entity concerned, by an RA, or by a CA. Key generation may also occur elsewhere, but for the purposes of PKI management we can regard key generation as occurring wherever the key is first present at an end entity, RA, or CA.",
      "ja": "5. PKI管理プロトコルはRAにより、またはCAによって、当該エンドエンティティによって鍵ペアの生成を妨げてはなりません鍵の生成は、他の場所でも発生する可能性がありますが、PKI管理の目的のために、我々は、キーはエンドエンティティに最初存在しているところはどこでも起こるようRAをキー生成を考えることができ、またはCA."
    },
    {
      "indent": 3,
      "text": "6. PKI management protocols must support the publication of certificates by the end-entity concerned, by an RA, or by a CA. Different implementations and different environments may choose any of the above approaches.",
      "ja": "6. PKI管理プロトコルはRAにより、またはCAによって、当該エンドエンティティによって証明書の公開をサポートしなければなりません異なる実装と異なる環境は、上記のアプローチのいずれかを選択できます。"
    },
    {
      "indent": 3,
      "text": "7. PKI management protocols must support the production of Certificate Revocation Lists (CRLs) by allowing certified end entities to make requests for the revocation of certificates. This must be done in such a way that the denial-of-service attacks, which are possible, are not made simpler.",
      "ja": "7. PKI管理プロトコルは、認定エンドエンティティが証明書の失効要求を行うようにすることによって、証明書失効リスト（CRL）の生産をサポートしている必要があります。これが可能なサービス拒否攻撃は、簡素化されていないような方法で行われなければなりません。"
    },
    {
      "indent": 3,
      "text": "8. PKI management protocols must be usable over a variety of \"transport\" mechanisms, specifically including mail, http, TCP/IP and ftp.",
      "ja": "8. PKI管理プロトコルは、具体的には、メール、HTTP、TCP / IPおよびFTPなどの「輸送」のメカニズム、各種超える使用可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "9. Final authority for certification creation rests with the CA. No RA or end-entity equipment can assume that any certificate issued by a CA will contain what was requested; a CA may alter certificate field values or may add, delete, or alter extensions according to its operating policy. In other words, all PKI entities (end-entities, RAs, and CAs) must be capable of handling responses to requests for certificates in which the actual certificate issued is different from that requested (for example, a CA may shorten the validity period requested). Note that policy may dictate that the CA must not publish or otherwise distribute the certificate until the requesting entity has reviewed and accepted the newly-created certificate (typically through use of the certConf message).",
      "ja": "証明作成のための9.最終的な権限は、CAにかかっていますいいえRAまたはエンドエンティティ機器は、CAが発行した証明書が要求されたものを含むことを前提とすることはできません。 CAは、証明書のフィールド値を変更したり、追加、削除、またはその運用方針に応じた拡張を変更することができます。言い換えれば、すべてのPKIエンティティ（エンドエンティティ、RAS、およびCAS）が発行され、実際の証明書が要求されたものとは異なるとした証明書の要求に応答を扱うことができなければならない（例えば、CAは、要求された有効期間を短縮することが）。そのポリシーは、要求エンティティがレビューし、（通常はcertConfメッセージを使用して）新しく作成された証明書を受け入れたまではCAが証明書を発行するか、そうでない場合は、配布してはならないことを指示することがあります。"
    },
    {
      "indent": 3,
      "text": "10. A graceful, scheduled change-over from one non-compromised CA key pair to the next (CA key update) must be supported (note that if the CA key is compromised, re-initialization must be performed for all entities in the domain of that CA). An end entity whose PSE contains the new CA public key (following a CA key update) must also be able to verify certificates verifiable using the old public key. End entities who directly trust the old CA key pair must also be able to verify certificates signed using the new CA private key (required for situations where the old CA public key is \"hardwired\" into the end entity's cryptographic equipment).",
      "ja": "次（CAの鍵更新）への1つの非妥協CA鍵ペアから10優雅な、スケジュールされた切換はサポートされなければならない（CA鍵が危険にさらされた場合、再初期化は、ドメイン内のすべてのエンティティに対して実行されなければならないことに注意してくださいそのCAの）。そのPSE（CA鍵の更新以下）の新しいCA公開鍵を含むエンドエンティティは、古い公開鍵を使って検証可能な証明書を検証できなければなりません。直接古いCA鍵ペアを信頼してエンドエンティティはまた、証明書を確認することができなければならない（古いCA公開鍵は、エンドエンティティの暗号化機器への「ハードワイヤード」である状況のために必要な）新しいCAの秘密鍵を使って署名しました。"
    },
    {
      "indent": 3,
      "text": "11. The functions of an RA may, in some implementations or environments, be carried out by the CA itself. The protocols must be designed so that end entities will use the same protocol regardless of whether the communication is with an RA or CA. Naturally, the end entity must use the correct RA of CA public key to protect the communication.",
      "ja": "RAの11の機能は、いくつかの実装形態または環境では、CA自体によって行うことができます。エンドエンティティは関係なく通信がRAまたはCAであるか否かの同じプロトコルを使用するようにプロトコルが設計されなければなりません当然のことながら、エンドエンティティが通信を保護するためにCAの公開鍵の正しいRAを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "12. Where an end entity requests a certificate containing a given public key value, the end entity must be ready to demonstrate possession of the corresponding private key value. This may be accomplished in various ways, depending on the type of certification request. See Section 4.3 for details of the in-band methods defined for the PKIX-CMP (i.e., Certificate Management Protocol) messages.",
      "ja": "12.エンド・エンティティは、指定された公開鍵値を含む証明書を要求した場合、エンドエンティティが対応する秘密鍵の値の所有を証明する準備ができなければなりません。これは、認証要求のタイプに応じて、様々な方法で達成することができます。 PKIX-CMP（すなわち、証明書管理プロトコル）メッセージのために定義された帯域内のメソッドの詳細については、セクション4.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1.3. PKI Management Operations",
      "section_title": true,
      "ja": "3.1.3。 PKI管理操作"
    },
    {
      "indent": 3,
      "text": "The following diagram shows the relationship between the entities defined above in terms of the PKI management operations. The letters in the diagram indicate \"protocols\" in the sense that a defined set of PKI management messages can be sent along each of the lettered lines.",
      "ja": "次の図は、PKI管理操作の点で上記定義されたエンティティとの関係を示しています。図中の文字は、PKI管理メッセージの定義されたセットは、文字の線の各々に沿って送信することができるという意味で、「プロトコル」を示します。"
    },
    {
      "indent": 5,
      "text": "+---+     cert. publish        +------------+      j\n|   |  <---------------------  | End Entity | <-------\n| C |             g            +------------+      \"out-of-band\"\n| e |                            | ^                loading\n| r |                            | |      initial\n| t |                          a | | b     registration/\n|   |                            | |       certification\n| / |                            | |      key pair recovery\n|   |                            | |      key pair update\n| C |                            | |      certificate update\n| R |  PKI \"USERS\"               V |      revocation request\n| L | -------------------+-+-----+-+------+-+-------------------\n|   |  PKI MANAGEMENT    | ^              | ^\n|   |    ENTITIES      a | | b          a | | b\n| R |                    V |              | |\n| e |             g   +------+    d       | |\n| p |   <------------ | RA   | <-----+    | |\n| o |      cert.      |      | ----+ |    | |\n| s |       publish   +------+   c | |    | |\n| i |                              | |    | |\n| t |                              V |    V |\n| o |          g                 +------------+   i\n| r |   <------------------------|     CA     |------->\n| y |          h                 +------------+  \"out-of-band\"\n|   |      cert. publish              | ^         publication\n|   |      CRL publish                | |\n+---+                                 | |    cross-certification\n                                    e | | f  cross-certificate\n                                      | |       update\n                                      | |\n                                      V |\n                                    +------+\n                                    | CA-2 |\n                                    +------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 1 - PKI Entities",
      "ja": "図1  -  PKIエンティティ"
    },
    {
      "indent": 5,
      "text": "At a high level, the set of operations for which management messages are defined can be grouped as follows.",
      "ja": "次のようにハイレベルで、管理メッセージが定義されている操作のセットをグループ化することができます。"
    },
    {
      "indent": 3,
      "text": "1. CA establishment: When establishing a new CA, certain steps are required (e.g., production of initial CRLs, export of CA public key).",
      "ja": "1. CAの確立：新しいCAを確立するとき、特定の手順が必要とされている（例えば、初期のCRLの生産、CA公開鍵のエクスポート）。"
    },
    {
      "indent": 3,
      "text": "2. End entity initialization: this includes importing a root CA public key and requesting information about the options supported by a PKI management entity.",
      "ja": "2.エンド・エンティティの初期化：これは、ルートCAの公開鍵をインポートし、PKI管理エンティティによってサポートされているオプションについての情報を要求しています。"
    },
    {
      "indent": 3,
      "text": "3. Certification: various operations result in the creation of new certificates:",
      "ja": "3.認定：様々な操作は、新しい証明書が作成されます。"
    },
    {
      "indent": 7,
      "text": "1.  initial registration/certification: This is the process\n    whereby an end entity first makes itself known to a CA or RA,\n    prior to the CA issuing a certificate or certificates for\n    that end entity.  The end result of this process (when it is\n    successful) is that a CA issues a certificate for an end\n    entity's public key, and returns that certificate to the end\n    entity and/or posts that certificate in a public repository.\n    This process may, and typically will, involve multiple\n    \"steps\", possibly including an initialization of the end\n    entity's equipment.  For example, the end entity's equipment\n    must be securely initialized with the public key of a CA, to\n    be used in validating certificate paths.  Furthermore, an end\n    entity typically needs to be initialized with its own key\n    pair(s).",
      "raw": true
    },
    {
      "indent": 7,
      "text": "2. key pair update: Every key pair needs to be updated regularly (i.e., replaced with a new key pair), and a new certificate needs to be issued.",
      "ja": "2.鍵ペア更新：すべての鍵ペアは（すなわち、新しい鍵ペアに置き換え）定期的に更新する必要があり、新しい証明書を発行する必要があります。"
    },
    {
      "indent": 7,
      "text": "3. certificate update: As certificates expire, they may be \"refreshed\" if nothing relevant in the environment has changed.",
      "ja": "3.証明書の更新：証明書が失効したような環境で関連するものは何も変わっていない場合、彼らは「リフレッシュ」であってもよいです。"
    },
    {
      "indent": 7,
      "text": "4. CA key pair update: As with end entities, CA key pairs need to be updated regularly; however, different mechanisms are required.",
      "ja": "4. CA鍵ペア更新：エンドエンティティと同じように、CA鍵ペアは定期的に更新する必要があります。しかし、別のメカニズムが必要とされています。"
    },
    {
      "indent": 7,
      "text": "5. cross-certification request: One CA requests issuance of a cross-certificate from another CA. For the purposes of this standard, the following terms are defined. A \"cross-certificate\" is a certificate in which the subject CA and the issuer CA are distinct and SubjectPublicKeyInfo contains a verification key (i.e., the certificate has been issued for the subject CA's signing key pair). When it is necessary to distinguish more finely, the following terms may be used: a cross-certificate is called an \"inter-domain cross-certificate\" if the subject and issuer CAs belong to different administrative domains; it is called an \"intra-domain cross-certificate\" otherwise.",
      "ja": "5.相互認証要求は：一つのCAが別のCAからクロス証明書の発行を依頼しますこの規格の目的のために、以下の用語が定義されています。 「相互認証」とは、対象のCAと発行者のCAは別個であり、SubjectPublicKeyInfoでは、検証鍵（すなわち、証明書がサブジェクトCAの署名鍵ペアに対して発行された）が含まれた証明書です。それはより細かく区別する必要がある場合、以下の用語が使用されてもよい：件名と発行者CAは異なる管理ドメインに属している場合、クロス証明書「は、ドメイン間相互認証」と呼ばれています。それは、そうでない場合は、「ドメイン内のクロス証明書」と呼ばれています。"
    },
    {
      "indent": 11,
      "text": "1.  Note 1.  The above definition of \"cross-certificate\"\n    aligns with the defined term \"CA-certificate\" in X.509.\n    Note that this term is not to be confused with the X.500\n    \"cACertificate\" attribute type, which is unrelated.",
      "raw": true
    },
    {
      "indent": 11,
      "text": "2. Note 2. In many environments, the term \"cross-certificate\", unless further qualified, will be understood to be synonymous with \"inter-domain cross-certificate\" as defined above.",
      "ja": "2.注2は、多くの環境では、用語「相互認証」は、さらに修飾されていない限り、上記で定義した「ドメイン間の相互認証」と同義であると理解されるであろう。"
    },
    {
      "indent": 11,
      "text": "3. Note 3. Issuance of cross-certificates may be, but is not necessarily, mutual; that is, two CAs may issue cross-certificates for each other.",
      "ja": "相互認証の3注記3発行はあり得るが、必ずしもではないが、相互できます。つまり、2つのCAはお互いのクロス証明書を発行することができます。"
    },
    {
      "indent": 7,
      "text": "6. cross-certificate update: Similar to a normal certificate update, but involving a cross-certificate.",
      "ja": "6.クロス証明書の更新：通常の証明書の更新と同様に、しかし、クロス証明書を含みます。"
    },
    {
      "indent": 3,
      "text": "4. Certificate/CRL discovery operations: some PKI management operations result in the publication of certificates or CRLs:",
      "ja": "4.証明書/ CRL発見動作：一部のPKI管理操作は、証明書やCRLの公表につながります："
    },
    {
      "indent": 7,
      "text": "1.  certificate publication: Having gone to the trouble of\n    producing a certificate, some means for publishing it is\n    needed.  The \"means\" defined in PKIX MAY involve the messages\n    specified in Sections 5.3.13 to 5.3.16, or MAY involve other\n    methods (LDAP, for example) as described in [RFC2559],\n    [RFC2585] (the \"Operational Protocols\" documents of the PKIX\n    series of specifications).",
      "raw": true
    },
    {
      "indent": 7,
      "text": "2. CRL publication: As for certificate publication.",
      "section_title": true,
      "ja": "2. CRLの発行：証明書の出版について。"
    },
    {
      "indent": 3,
      "text": "5. Recovery operations: some PKI management operations are used when an end entity has \"lost\" its PSE:",
      "ja": "5.リカバリ操作：エンドエンティティは、そのPSEを「失われた」したときに、いくつかのPKI管理操作が使用されます。"
    },
    {
      "indent": 7,
      "text": "1.  key pair recovery: As an option, user client key materials\n    (e.g., a user's private key used for decryption purposes) MAY\n    be backed up by a CA, an RA, or a key backup system\n    associated with a CA or RA.  If an entity needs to recover\n    these backed up key materials (e.g., as a result of a\n    forgotten password or a lost key chain file), a protocol\n    exchange may be needed to support such recovery.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6. Revocation operations: some PKI operations result in the creation of new CRL entries and/or new CRLs:",
      "ja": "6.失効操作：いくつかのPKI操作が新しいCRLエントリおよび/または新規のCRLが作成されます。"
    },
    {
      "indent": 7,
      "text": "1.  revocation request: An authorized person advises a CA of an\n    abnormal situation requiring certificate revocation.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7. PSE operations: whilst the definition of PSE operations (e.g., moving a PSE, changing a PIN, etc.) are beyond the scope of this specification, we do define a PKIMessage (CertRepMessage) that can form the basis of such operations.",
      "ja": "7. PSE操作：PSEオペレーションの定義一方（例えば、PSEを移動、PINを変更する、など）本明細書の範囲を超えて、我々は、そのような操作の基礎を形成することができるPKIMessage（CertRepMessage）を定義行います。"
    },
    {
      "indent": 3,
      "text": "Note that on-line protocols are not the only way of implementing the above operations. For all operations, there are off-line methods of achieving the same result, and this specification does not mandate use of on-line protocols. For example, when hardware tokens are used, many of the operations MAY be achieved as part of the physical token delivery.",
      "ja": "オンラインプロトコルは上記の動作を実現するための唯一の方法ではないことに注意してください。すべての操作のために、そこに同じ結果を達成するためのオフラインの方法があり、この仕様はオンラインプロトコルの使用を強制しません。ハードウェアトークンが使用される場合、例えば、動作の多くは、物理的なトークンの配信の一部として実現することができます。"
    },
    {
      "indent": 3,
      "text": "Later sections define a set of standard messages supporting the above operations. Transport protocols for conveying these exchanges in different environments (file-based, on-line, E-mail, and WWW) are beyond the scope of this document and are specified separately.",
      "ja": "その後のセクションでは、上記の操作をサポートする標準メッセージのセットを定義します。異なる環境（ファイルベース、オンライン、Eメール、およびWWW）でこれらの交換を搬送するためのトランスポートプロトコルは、このドキュメントの範囲を超えて、個別に指定されています。"
    },
    {
      "indent": 0,
      "text": "4. Assumptions and Restrictions",
      "section_title": true,
      "ja": "4.前提と制限"
    },
    {
      "indent": 0,
      "text": "4.1. End Entity Initialization",
      "section_title": true,
      "ja": "4.1。エンド・エンティティの初期化"
    },
    {
      "indent": 3,
      "text": "The first step for an end entity in dealing with PKI management entities is to request information about the PKI functions supported and to securely acquire a copy of the relevant root CA public key(s).",
      "ja": "PKI管理エンティティに対処するエンドエンティティの最初のステップは、サポートされているPKI機能に関する情報を要求するために、かつ確実に、関連するルートCAの公開鍵（単数または複数）のコピーを取得することです。"
    },
    {
      "indent": 0,
      "text": "4.2. Initial Registration/Certification",
      "section_title": true,
      "ja": "4.2。初期登録/認証"
    },
    {
      "indent": 3,
      "text": "There are many schemes that can be used to achieve initial registration and certification of end entities. No one method is suitable for all situations due to the range of policies that a CA may implement and the variation in the types of end entity which can occur.",
      "ja": "エンドエンティティの初期登録と認証を達成するために使用することができる多くの方式があります。誰の方法は、CAが実施することができるポリシーの範囲と発生することができ、エンドエンティティの種類の変化に起因するすべての状況に適していません。"
    },
    {
      "indent": 3,
      "text": "However, we can classify the initial registration/certification schemes that are supported by this specification. Note that the word \"initial\", above, is crucial: we are dealing with the situation where the end entity in question has had no previous contact with the PKI. Where the end entity already possesses certified keys, then some simplifications/alternatives are possible.",
      "ja": "しかし、我々は、この仕様でサポートされている初期登録/認証制度を分類することができます。 「最初の」という言葉は、上記の、非常に重要であることに注意してください：私たちは、問題のエンドエンティティがPKIとは、以前の接触を持っていない状況を扱っています。エンドエンティティは、すでに認定の鍵を持っている場合は、その後、いくつかの単純化/代替が可能です。"
    },
    {
      "indent": 3,
      "text": "Having classified the schemes that are supported by this specification we can then specify some as mandatory and some as optional. The goal is that the mandatory schemes cover a sufficient number of the cases that will arise in real use, whilst the optional schemes are available for special cases that arise less frequently. In this way, we achieve a balance between flexibility and ease of implementation.",
      "ja": "私たちは、その後、いくつかの必須として、いくつかなどのオプションを指定することができ、この仕様でサポートされているスキームを分類しました。目標は、オプションのスキームはそれほど頻繁に発生する特別な場合のために用意されていながら、必須のスキームは、実際の使用中に起きる例に十分な数をカバーしていることです。このように、我々は柔軟性と実装の容易さを両立します。"
    },
    {
      "indent": 3,
      "text": "We will now describe the classification of initial registration/certification schemes.",
      "ja": "私たちは今、初期登録/認証制度の分類を説明します。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Criteria Used",
      "section_title": true,
      "ja": "4.2.1。使用する基準"
    },
    {
      "indent": 0,
      "text": "4.2.1.1. Initiation of Registration/Certification",
      "section_title": true,
      "ja": "4.2.1.1。登録/認証の開始"
    },
    {
      "indent": 3,
      "text": "In terms of the PKI messages that are produced, we can regard the initiation of the initial registration/certification exchanges as occurring wherever the first PKI message relating to the end entity is produced. Note that the real-world initiation of the registration/certification procedure may occur elsewhere (e.g., a personnel department may telephone an RA operator).",
      "ja": "生成されたPKIメッセージの面では、我々は、エンドエンティティに関連する第一のPKIメッセージが生成されている場所に生じるような初期登録/認証交換の開始とみなすことができます。登録/認証手順の現実世界の開始が他の場所で発生する可能性があることに注意してください（例えば、人事部は、RAのオペレータに電話してもよいです）。"
    },
    {
      "indent": 3,
      "text": "The possible locations are at the end entity, an RA, or a CA.",
      "ja": "可能な場所は、エンドエンティティ、RA、またはCA.であります"
    },
    {
      "indent": 0,
      "text": "4.2.1.2. End Entity Message Origin Authentication",
      "section_title": true,
      "ja": "4.2.1.2。エンドエンティティのメッセージ発信元認証"
    },
    {
      "indent": 3,
      "text": "The on-line messages produced by the end entity that requires a certificate may be authenticated or not. The requirement here is to authenticate the origin of any messages from the end entity to the PKI (CA/RA).",
      "ja": "証明書を必要とするエンドエンティティによって生成されたオンラインメッセージが認証してもしなくてもよいです。ここでの要件は、PKI（CA / RA）へのエンドエンティティからのメッセージの発信元を認証することです。"
    },
    {
      "indent": 3,
      "text": "In this specification, such authentication is achieved by the PKI (CA/RA) issuing the end entity with a secret value (initial authentication key) and reference value (used to identify the secret value) via some out-of-band means. The initial authentication key can then be used to protect relevant PKI messages.",
      "ja": "本明細書では、そのような認証は、いくつかのアウトオブバンド手段を介して（秘密値を識別するために使用される）秘密の値（初期認証キー）と基準値とエンドエンティティを発行するPKI（CA / RA）によって達成されます。初期認証キーは、関連するPKIメッセージを保護するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Thus, we can classify the initial registration/certification scheme according to whether or not the on-line end entity -> PKI messages are authenticated or not.",
      "ja": "したがって、我々は、かどうかのオンラインエンドエンティティに応じて初期登録/認証スキームを分類することができます - > PKIメッセージは、認証やされていません。"
    },
    {
      "indent": 3,
      "text": "Note 1: We do not discuss the authentication of the PKI -> end entity messages here, as this is always REQUIRED. In any case, it can be achieved simply once the root-CA public key has been installed at the end entity's equipment or it can be based on the initial authentication key.",
      "ja": "注1： - これは常に必要とされるように、ここで>エンドエンティティのメッセージ私たちは、PKIの認証については説明しません。ルートCAの公開鍵は、エンドエンティティの機器にインストールされているか、それが初期認証キーに基づくことができたら、どのような場合には、それは簡単に達成することができます。"
    },
    {
      "indent": 3,
      "text": "Note 2: An initial registration/certification procedure can be secure where the messages from the end entity are authenticated via some out-of-band means (e.g., a subsequent visit).",
      "ja": "注2：エンドエンティティからのメッセージは、いくつかのアウトオブバンド手段（例えば、その後の訪問）を介して認証されている場合、初期登録/認証手順がセキュアであることができます。"
    },
    {
      "indent": 0,
      "text": "4.2.1.3. Location of Key Generation",
      "section_title": true,
      "ja": "4.2.1.3。キー生成の場所"
    },
    {
      "indent": 3,
      "text": "In this specification, \"key generation\" is regarded as occurring wherever either the public or private component of a key pair first occurs in a PKIMessage. Note that this does not preclude a centralized key generation service; the actual key pair MAY have been generated elsewhere and transported to the end entity, RA, or CA using a (proprietary or standardized) key generation request/response protocol (outside the scope of this specification).",
      "ja": "本明細書において、「鍵生成」は、いずれかの鍵ペアの公開またはプライベートコンポーネントが最初PKIMessageで起こるどこ生じると考えられます。これは中央集中型の鍵生成サービスを排除するものではないことに注意してください。実際の鍵ペアは、他の場所で生成され、（本明細書の範囲外）（独自仕様または標準化された）鍵生成要求/応答プロトコルを使用して、エンドエンティティ、RA、またはCAに搬送されていてもよいです。"
    },
    {
      "indent": 3,
      "text": "Thus, there are three possibilities for the location of \"key generation\": the end entity, an RA, or a CA.",
      "ja": "エンドエンティティ、RA、またはCa：したがって、「鍵生成」の位置のための3つの可能性があります"
    },
    {
      "indent": 0,
      "text": "4.2.1.4. Confirmation of Successful Certification",
      "section_title": true,
      "ja": "4.2.1.4。成功した認証の確認"
    },
    {
      "indent": 3,
      "text": "Following the creation of an initial certificate for an end entity, additional assurance can be gained by having the end entity explicitly confirm successful receipt of the message containing (or indicating the creation of) the certificate. Naturally, this confirmation message must be protected (based on the initial authentication key or other means).",
      "ja": "エンドエンティティの最初の証明書の作成後、追加の保証は、エンドエンティティが明示的に含む（または作成示す）証明書をメッセージの正常な受信を確認有することによって得ることができます。当然のことながら、この確認メッセージは、（初期認証キーまたは他の手段に基づいて）保護されなければなりません。"
    },
    {
      "indent": 3,
      "text": "This gives two further possibilities: confirmed or not.",
      "ja": "確認したかどうか：これは、さらに2つの可能性を提供します。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Mandatory Schemes",
      "section_title": true,
      "ja": "4.2.2。必須スキーム"
    },
    {
      "indent": 3,
      "text": "The criteria above allow for a large number of initial registration/certification schemes. This specification mandates that conforming CA equipment, RA equipment, and EE equipment MUST support the second scheme listed below (Section 4.2.2.2). Any entity MAY additionally support other schemes, if desired.",
      "ja": "上記の基準は、初期登録/認証制度の多数を可能とします。 CA装置、RA機器、EE装置を適合この仕様の義務は下記の第2の方式（セクション4.2.2.2）をサポートしなければなりません。必要に応じて任意のエンティティは、さらに、他のスキームをサポートするかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. Centralized Scheme",
      "section_title": true,
      "ja": "4.2.2.1。一元化スキーム"
    },
    {
      "indent": 3,
      "text": "In terms of the classification above, this scheme is, in some ways, the simplest possible, where:",
      "ja": "上記分類の観点で、このスキームは、ここで、最も単純な、いくつかの方法では、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o initiation occurs at the certifying CA;",
      "ja": "Oの開始は証明CAで発生します。"
    },
    {
      "indent": 3,
      "text": "o no on-line message authentication is required;",
      "ja": "O無オンラインメッセージ認証が必要です。"
    },
    {
      "indent": 3,
      "text": "o \"key generation\" occurs at the certifying CA (see Section 4.2.1.3);",
      "ja": "O「キーの生成は、」証明CA（セクション4.2.1.3を参照）で発生します。"
    },
    {
      "indent": 3,
      "text": "o no confirmation message is required.",
      "ja": "Oは確認メッセージは必要ありません。"
    },
    {
      "indent": 3,
      "text": "In terms of message flow, this scheme means that the only message required is sent from the CA to the end entity. The message must contain the entire PSE for the end entity. Some out-of-band means must be provided to allow the end entity to authenticate the message received and to decrypt any encrypted values.",
      "ja": "メッセージフローの点で、このスキームは、必要なメッセージのみがエンドエンティティにCAから送信されたことを意味します。メッセージは、エンドエンティティの全体PSEが含まれている必要があります。いくつかのアウトオブバンド手段は、エンドエンティティが受信したメッセージを認証し、任意の暗号化された値を復号化できるようにするために提供されなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2.2.2. Basic Authenticated Scheme",
      "section_title": true,
      "ja": "4.2.2.2。 Basic認証スキーム"
    },
    {
      "indent": 3,
      "text": "In terms of the classification above, this scheme is where:",
      "ja": "上記分類の観点で、このスキームは、ここです。"
    },
    {
      "indent": 3,
      "text": "o initiation occurs at the end entity;",
      "ja": "O開始は、エンドエンティティで起こります。"
    },
    {
      "indent": 3,
      "text": "o message authentication is REQUIRED;",
      "ja": "Oメッセージ認証が必要です。"
    },
    {
      "indent": 3,
      "text": "o \"key generation\" occurs at the end entity (see Section 4.2.1.3);",
      "ja": "O「キー生成」は終わりの実体で起こる（セクション4.2.1.3を参照）。"
    },
    {
      "indent": 3,
      "text": "o a confirmation message is REQUIRED.",
      "ja": "O確認メッセージが必要です。"
    },
    {
      "indent": 3,
      "text": "In terms of message flow, the basic authenticated scheme is as follows:",
      "ja": "次のようにメッセージ・フローに関しては、基本的な認証方式です。"
    },
    {
      "indent": 5,
      "text": "End entity                                          RA/CA\n==========                                      =============\n     out-of-band distribution of Initial Authentication\n     Key (IAK) and reference value (RA/CA -> EE)\nKey generation\nCreation of certification request\nProtect request with IAK\n              -->>-- certification request -->>--\n                                               verify request\n                                               process request\n                                               create response\n              --<<-- certification response --<<--\nhandle response\ncreate confirmation\n              -->>-- cert conf message      -->>--\n                                               verify confirmation\n                                               create response\n              --<<-- conf ack (optional)    --<<--\nhandle response",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(Where verification of the cert confirmation message fails, the RA/CA MUST revoke the newly issued certificate if it has been published or otherwise made available.)",
      "ja": "（CERT確認メッセージの検証が失敗した場合は、それが公開またはそうでなければ利用可能になっている場合には、RA / CAは、新たに発行された証明書を取り消す必要があります。）"
    },
    {
      "indent": 0,
      "text": "4.3. Proof-of-Possession (POP) of Private Key",
      "section_title": true,
      "ja": "4.3。実証の所有秘密鍵の（POP）"
    },
    {
      "indent": 3,
      "text": "In order to prevent certain attacks and to allow a CA/RA to properly check the validity of the binding between an end entity and a key pair, the PKI management operations specified here make it possible for an end entity to prove that it has possession of (i.e., is able to use) the private key corresponding to the public key for which a certificate is requested. A given CA/RA is free to choose how to enforce POP (e.g., out-of-band procedural means versus PKIX-CMP in-band messages) in its certification exchanges (i.e., this may be a policy issue). However, it is REQUIRED that CAs/RAs MUST enforce POP by some means because there are currently many non-PKIX operational protocols in use (various electronic mail protocols are one example) that do not explicitly check the binding between the end entity and the private key. Until operational protocols that do verify the binding (for signature, encryption, and key agreement key pairs) exist, and are ubiquitous, this binding can only be assumed to have been verified by the CA/RA. Therefore, if the binding is not verified by the CA/RA, certificates in the Internet Public-Key Infrastructure end up being somewhat less meaningful.",
      "ja": "特定の攻撃を防止し、CA / RAが適切にエンドエンティティと鍵ペア間の結合の有効性を確認できるようにするために、ここで指定したPKI管理操作は、それがの所持を持っていることを証明するために、エンドエンティティのためにそれを可能にします証明書が要求されている公開鍵に対応する秘密鍵（すなわち、使用することができます）。 （すなわち、これは、ポリシーの問題であってもよい）、その認証交換に（PKIX-CMPインバンドメッセージに対して、例えば、アウト・オブ・バンド手続き手段）CA / RAがPOPを適用する方法を自由に選択することが与えられました。しかし、現在使用中の多くの非PKIX運用プロトコル（様々な電子メールプロトコルは一例です）明示的にエンドエンティティとプライベートの間の結合をチェックしないことがあるので、CAは/ RASが何らかの手段でPOPを施行しなければならないことが必要とされますキー。 （署名、暗号化、および鍵合意鍵ペアのための）結合を確認するん運用プロトコルが存在し、かつユビキタスになるまで、この結合はCA / RAによって検証されているものとすることができます。結合がCA / RAによって検証されていない場合はそのため、インターネット公開鍵インフラストラクチャ内の証明書はややあまり意味になってしまいます。"
    },
    {
      "indent": 3,
      "text": "POP is accomplished in different ways depending upon the type of key for which a certificate is requested. If a key can be used for multiple purposes (e.g., an RSA key) then any appropriate method MAY",
      "ja": "POPは、証明書が要求されたキーの種類に応じて異なる方法で達成されます。キーは、複数の目的に使用することができる場合（例えば、RSA鍵）を、任意の適切な方法MAY"
    },
    {
      "indent": 3,
      "text": "be used (e.g., a key that may be used for signing, as well as other purposes, SHOULD NOT be sent to the CA/RA in order to prove possession).",
      "ja": "使用すること（例えば、署名のために使用することができるキー、ならびに他の目的、所有を証明するためにCA / RAに送るべきではありません）。"
    },
    {
      "indent": 3,
      "text": "This specification explicitly allows for cases where an end entity supplies the relevant proof to an RA and the RA subsequently attests to the CA that the required proof has been received (and validated!). For example, an end entity wishing to have a signing key certified could send the appropriate signature to the RA, which then simply notifies the relevant CA that the end entity has supplied the required proof. Of course, such a situation may be disallowed by some policies (e.g., CAs may be the only entities permitted to verify POP during certification).",
      "ja": "この仕様は、明示的にエンドエンティティがその後RAとRAに関連する証拠を提供し、必要な証拠が受信されたことをCAに証明（および検証！）例が可能になります。例えば、認定署名鍵を持っていることを望むエンドエンティティは、単にエンドエンティティは、必要な証拠を提供したことの関連CAを通知RAに適切な署名を送信することができます。もちろん、このような状況は、いくつかのポリシーで禁止することができる（例えば、CAはエンティティのみが認証中にPOPを検証できるようにしてもよいです）。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Signature Keys",
      "section_title": true,
      "ja": "4.3.1。署名鍵"
    },
    {
      "indent": 3,
      "text": "For signature keys, the end entity can sign a value to prove possession of the private key.",
      "ja": "署名鍵の場合、エンドエンティティは秘密鍵の所有を証明するために値を署名することができます。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Encryption Keys",
      "section_title": true,
      "ja": "4.3.2。暗号化キー"
    },
    {
      "indent": 3,
      "text": "For encryption keys, the end entity can provide the private key to the CA/RA, or can be required to decrypt a value in order to prove possession of the private key (see Section 5.2.8). Decrypting a value can be achieved either directly or indirectly.",
      "ja": "暗号化キーの場合は、エンドエンティティがCA / RAに秘密鍵を提供することができ、または（5.2.8項を参照）、秘密鍵の所有を証明するために、値を復号化するために必要なことができます。値を復号化する直接的または間接的に達成することができます。"
    },
    {
      "indent": 3,
      "text": "The direct method is for the RA/CA to issue a random challenge to which an immediate response by the EE is required.",
      "ja": "RA / CAがEEによって即時応答が必要とされているランダムなチャレンジを発行するための直接的な方法です。"
    },
    {
      "indent": 3,
      "text": "The indirect method is to issue a certificate that is encrypted for the end entity (and have the end entity demonstrate its ability to decrypt this certificate in the confirmation message). This allows a CA to issue a certificate in a form that can only be used by the intended end entity.",
      "ja": "間接的な方法は、エンドエンティティのために暗号化された証明書を発行（およびエンドエンティティが確認メッセージにこの証明書を復号化する能力を実証してい）することです。これは、CAが唯一の目的とするエンドエンティティで使用できる形式で証明書を発行することができます。"
    },
    {
      "indent": 3,
      "text": "This specification encourages use of the indirect method because it requires no extra messages to be sent (i.e., the proof can be demonstrated using the {request, response, confirmation} triple of messages).",
      "ja": "それは（すなわち、証明メッセージのトリプル{要求、応答、確認}を使用して実証することができる）送信する余分なメッセージを必要としないので、この仕様では、間接的な方法の使用を奨励します。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Key Agreement Keys",
      "section_title": true,
      "ja": "4.3.3。鍵共有キー"
    },
    {
      "indent": 3,
      "text": "For key agreement keys, the end entity and the PKI management entity (i.e., CA or RA) must establish a shared secret key in order to prove that the end entity has possession of the private key.",
      "ja": "鍵合意鍵の場合、エンドエンティティおよびPKI管理エンティティ（すなわち、CAまたはRA）は、エンドエンティティは秘密鍵の所有を持っていることを証明するために、共有秘密鍵を確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that this need not impose any restrictions on the keys that can be certified by a given CA. In particular, for Diffie-Hellman keys the end entity may freely choose its algorithm parameters provided that the CA can generate a short-term (or one-time) key pair with the appropriate parameters when necessary.",
      "ja": "これは与えられたCAが認定することができ、キーに制限を課す必要はないことに注意してください特に、のDiffie-Hellmanキーのエンドエンティティが自由にアルゴリズムパラメータが必要な場合、CAは、適切なパラメータを用いて、短期（または1時間）鍵ペアを生成することができることを条件とする選択してもよいです。"
    },
    {
      "indent": 0,
      "text": "4.4. Root CA Key Update",
      "section_title": true,
      "ja": "4.4。ルートCAキー更新"
    },
    {
      "indent": 3,
      "text": "This discussion only applies to CAs that are directly trusted by some end entities. Self-signed CAs SHALL be considered as directly trusted CAs. Recognizing whether a non-self-signed CA is supposed to be directly trusted for some end entities is a matter of CA policy and is thus beyond the scope of this document.",
      "ja": "この議論は、直接、いくつかのエンドエンティティによって信頼されたCAに適用されます。自己署名CAは、直接として信頼性のあるCAを考慮しなければなりません。非自己署名CAが直接いくつかのエンドエンティティに対して信頼されるようになっているかどうかを認識することはCAのポリシーの問題であり、この文書の範囲外であるため。"
    },
    {
      "indent": 3,
      "text": "The basis of the procedure described here is that the CA protects its new public key using its previous private key and vice versa. Thus, when a CA updates its key pair it must generate two extra cACertificate attribute values if certificates are made available using an X.500 directory (for a total of four: OldWithOld, OldWithNew, NewWithOld, and NewWithNew).",
      "ja": "ここで説明する手順の基本は、CAがその前の秘密鍵およびその逆を使用して、その新しい公開鍵を保護することです。 CAがその鍵ペアを更新したときに証明書が（：OldWithOld、OldWithNew、NewWithOld、およびNewWithNew 4の合計）X.500ディレクトリを使用して利用できるようにしている場合はこのように、2つの追加のcaCertificate属性値を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a CA changes its key pair, those entities who have acquired the old CA public key via \"out-of-band\" means are most affected. It is these end entities who will need access to the new CA public key protected with the old CA private key. However, they will only require this for a limited period (until they have acquired the new CA public key via the \"out-of-band\" mechanism). This will typically be easily achieved when these end entities' certificates expire.",
      "ja": "CAがその鍵ペアを変更すると、「アウトオブバンド」手段を介して、古いCA公開鍵を取得しているそれらのエンティティが最も影響を受けています。それは昔のCA秘密鍵で保護された新しいCA公開鍵にアクセスする必要がありますこれらのエンドエンティティです。 （彼らは「アウトオブバンド」機構を介して新しいCA公開鍵を取得するまで）しかし、彼らは限られた期間のためにこれが必要になります。これらのエンドエンティティの証明書の有効期限が切れるとき、これは一般的に容易に達成されます。"
    },
    {
      "indent": 3,
      "text": "The data structure used to protect the new and old CA public keys is a standard certificate (which may also contain extensions). There are no new data structures required.",
      "ja": "新旧CA公開鍵を保護するために使用されるデータ構造は、（また、拡張子を含んでいてもよい）の標準的な証明書です。必要な新しいデータ構造がありません。"
    },
    {
      "indent": 3,
      "text": "Note 1. This scheme does not make use of any of the X.509 v3 extensions as it must be able to work even for version 1 certificates. The presence of the KeyIdentifier extension would make for efficiency improvements.",
      "ja": "それも、バージョン1つの証明書のために働くことができなければならないよう注意1.この方式は、X.509 v3の拡張のいずれかを使用しません。 KeyIdentifier拡張の存在は、効率改善のためになるだろう。"
    },
    {
      "indent": 3,
      "text": "Note 2. While the scheme could be generalized to cover cases where the CA updates its key pair more than once during the validity period of one of its end entities' certificates, this generalization seems of dubious value. Not having this generalization simply means that the validity periods of certificates issued with the old CA key pair cannot exceed the end of the OldWithNew validity period.",
      "ja": "スキームは、CAはそのエンドエンティティの証明書の一つの有効期間中に何度もその鍵ペアの詳細を更新し、この一般化は、怪しげな値のようだ例をカバーするために一般化することができますが2に注意してください。この一般化を持っていないことは、単に古いCA鍵ペアに発行された証明書の有効期間は、OldWithNewの有効期間の終わりを超えてはならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Note 3. This scheme ensures that end entities will acquire the new CA public key, at the latest by the expiry of the last certificate they owned that was signed with the old CA private key (via the \"out-of-band\" means). Certificate and/or key update operations occurring at other times do not necessarily require this (depending on the end entity's equipment).",
      "ja": "注3.このスキームは、エンドエンティティが新しいCA公開鍵を取得することを保証し、彼らはそれを所有していた最後の証明書の失効により、遅くとも旧CA秘密鍵で署名された（「アウトオブバンド」経由意味） 。他の時に発生した証明書および/または鍵の更新操作が必ずしも（エンドエンティティの機器に応じて）これを必要としません。"
    },
    {
      "indent": 0,
      "text": "4.4.1. CA Operator Actions",
      "section_title": true,
      "ja": "4.4.1。 CAオペレータアクション"
    },
    {
      "indent": 3,
      "text": "To change the key of the CA, the CA operator does the following:",
      "ja": "CAのキーを変更するには、CAオペレータは次のことを行います。"
    },
    {
      "indent": 3,
      "text": "1. Generate a new key pair;",
      "section_title": true,
      "ja": "1.新しい鍵ペアを生成します。"
    },
    {
      "indent": 3,
      "text": "2. Create a certificate containing the old CA public key signed with the new private key (the \"old with new\" certificate);",
      "ja": "2.（証明書「の新しいと古い」）新しい秘密鍵で署名した古いCA公開鍵を含む証明書を作成します。"
    },
    {
      "indent": 3,
      "text": "3. Create a certificate containing the new CA public key signed with the old private key (the \"new with old\" certificate);",
      "ja": "3.古い秘密鍵（証明書「古いと新しい」）に署名した新しいCA公開鍵を含む証明書を作成します。"
    },
    {
      "indent": 3,
      "text": "4. Create a certificate containing the new CA public key signed with the new private key (the \"new with new\" certificate);",
      "ja": "4.新しい秘密鍵で署名した新しいCA公開鍵を含む証明書を作成します（証明書「新持つ新しいです」）;"
    },
    {
      "indent": 3,
      "text": "5. Publish these new certificates via the repository and/or other means (perhaps using a CAKeyUpdAnn message);",
      "ja": "5.リポジトリおよび/または他の手段（おそらくCAKeyUpdAnnメッセージを用いて）を介して、これらの新しい証明書を公開します。"
    },
    {
      "indent": 3,
      "text": "6. Export the new CA public key so that end entities may acquire it using the \"out-of-band\" mechanism (if required).",
      "ja": "6.エクスポートエンドエンティティが（必要な場合）、「アウトオブバンド」のメカニズムを使用してそれを取得することができるように、新しいCA公開鍵。"
    },
    {
      "indent": 3,
      "text": "The old CA private key is then no longer required. However, the old CA public key will remain in use for some time. The old CA public key is no longer required (other than for non-repudiation) when all end entities of this CA have securely acquired the new CA public key.",
      "ja": "旧CA秘密鍵は、もはや必要とされません。しかし、古いCA公開鍵はしばらくの間、使用のままになります。このCAのすべてのエンドエンティティがしっかりと新しいCA公開鍵を取得したときに、古いCA公開鍵は、もはや（否認防止用以外）必要ありません。"
    },
    {
      "indent": 3,
      "text": "The \"old with new\" certificate must have a validity period starting at the generation time of the old key pair and ending at the expiry date of the old public key.",
      "ja": "「古いと新しい」証明書は、有効期間の古い鍵ペアの生成時に始まり、古い公開鍵の有効期限で終了している必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"new with old\" certificate must have a validity period starting at the generation time of the new key pair and ending at the time by which all end entities of this CA will securely possess the new CA public key (at the latest, the expiry date of the old public key).",
      "ja": "「新しい古い」証明書は、有効期間、新しい鍵ペアの生成時に始まり、このCAのすべてのエンドエンティティは、遅くとも（新しいCA公開鍵を持って安全になることによって、時間で終了、有効期限を持っている必要があります古い公開鍵の日付）。"
    },
    {
      "indent": 3,
      "text": "The \"new with new\" certificate must have a validity period starting at the generation time of the new key pair and ending at or before the time by which the CA will next update its key pair.",
      "ja": "証明書「新と新は、」CAは、次の鍵ペアを更新しますそれによって新しい鍵ペアの生成時に始まり、一度にまたは前に終わる有効期間を持っている必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Verifying Certificates",
      "section_title": true,
      "ja": "4.4.2。確認証明書"
    },
    {
      "indent": 3,
      "text": "Normally when verifying a signature, the verifier verifies (among other things) the certificate containing the public key of the signer. However, once a CA is allowed to update its key there are a range of new possibilities. These are shown in the table below.",
      "ja": "（とりわけ）、通常の署名を検証する、検証の検証署名者の公開鍵を含む証明書。しかし、一度CAは、新しい可能性の範囲があり、そのキーを更新することが許可されています。これらは、以下の表に示されています。"
    },
    {
      "indent": 16,
      "text": "Repository contains NEW     Repository contains only OLD\n  and OLD public keys        public key (due to, e.g.,\n                              delay in publication)",
      "raw": true
    },
    {
      "indent": 15,
      "text": " PSE PSE Contains PSE Contains PSE Contains Contains OLD public NEW public OLD public NEW public key key key key",
      "ja": "PSE PSEは、PSEは、PSEが含まれて含まれていOLD公共NEW OLD公共、公開NEW公開鍵キーキーキーが含まれています含まれてい"
    },
    {
      "indent": 4,
      "text": "Signer's Case 1: Case 3: Case 5: Case 7: certifi- This is In this case Although the In this case cate is the the verifier CA operator the CA protected standard must access has not operator has using NEW case where the updated the not updated public the repository in repository the the repository key verifier order to get verifier can and so the can the value of verify the verification directly the NEW certificate will FAIL verify the public key directly - certificate this is thus without the same as using the case 1. repository",
      "ja": "署名者のケース1：ケース3：ケース5：ケース7：この場合、ケイトは、CAは、標準の必須アクセスは、オペレータが更新されていないところNEWケースを使用しているしていない保護された検証のCAオペレータであるが、このcertifi-はこの場合でありますリポジトリ缶検証を取得するので、ザ・検証を確認の値が直接新しい証明書が直接公開鍵を検証失敗することができるリポジトリキー検証のために更新された公開リポジトリ - この証明書はせず、したがってケース1を使用するのと同じです。 倉庫"
    },
    {
      "indent": 4,
      "text": "Signer's Case 2: Case 4: Case 6: Case 8: certifi- In this In this case The verifier Although the cate is case the the verifier thinks this CA operator protected verifier can directly is the has not using OLD must verify the situation of updated the public access the certificate case 2 and repository the key repository without will access verifier can in order using the the verify the to get the repository repository; certificate value of however, the directly - the OLD verification this is thus public key will FAIL the same as case 4.",
      "ja": "署名者のケース2：ケース4：ケース6：ケース8：この中certifi-この場合は、ケイトが、検証者は、検証者が保護された検証者が直接OLDを使用していないされてすることができ、このCAのオペレータは、更新の状況を検証しなければならないと考えた場合でありますパブリックアクセス証明書ケース2と意志のアクセス検証せずにキーリポジトリをリポジトリは順番にリポジトリリポジトリを取得するために検証する使用することができます。しかしの証明書の値は、直接 - この古い検証は、公開鍵は、ケース4と同じように失敗することです。"
    },
    {
      "indent": 0,
      "text": "4.4.2.1. Verification in Cases 1, 4, 5, and 8",
      "section_title": true,
      "ja": "4.4.2.1。ケース1での検証、4、5、および8"
    },
    {
      "indent": 3,
      "text": "In these cases, the verifier has a local copy of the CA public key that can be used to verify the certificate directly. This is the same as the situation where no key change has occurred.",
      "ja": "これらのケースでは、検証者は、直接証明書を検証するために使用することができるCAの公開鍵のローカルコピーを持っています。これは何のキーの変更が発生していない状況と同じです。"
    },
    {
      "indent": 3,
      "text": "Note that case 8 may arise between the time when the CA operator has generated the new key pair and the time when the CA operator stores the updated attributes in the repository. Case 5 can only arise if",
      "ja": "CAオペレータが新しい鍵ペアとCAオペレータは、リポジトリ内の更新された属性を格納する時間を生成した時点との間に生じる可能性があるような場合注8。場合にのみ発生する可能性がケース5"
    },
    {
      "indent": 3,
      "text": "the CA operator has issued both the signer's and verifier's certificates during this \"gap\" (the CA operator SHOULD avoid this as it leads to the failure cases described below)",
      "ja": "CAオペレータは、（それが下記の失敗例につながるとして、CAのオペレータがこれを避ける必要があります）この「ギャップ」中に署名者と検証者の両方の証明書を発行しています"
    },
    {
      "indent": 0,
      "text": "4.4.2.2. Verification in Case 2",
      "section_title": true,
      "ja": "4.4.2.2。ケース2で検証"
    },
    {
      "indent": 3,
      "text": "In case 2, the verifier must get access to the old public key of the CA. The verifier does the following:",
      "ja": "ケース2では、検証はCAの古い公開鍵へのアクセスを取得する必要があります検証者は、次のことを行います。"
    },
    {
      "indent": 3,
      "text": "1.  Look up the caCertificate attribute in the repository and pick\n    the OldWithNew certificate (determined based on validity periods;\n    note that the subject and issuer fields must match);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. Verify that this is correct using the new CA key (which the verifier has locally);",
      "ja": "2.これは（検証者が局所的に有する）新しいCAキーを使用して正しいことを確認します。"
    },
    {
      "indent": 3,
      "text": "3. If correct, check the signer's certificate using the old CA key.",
      "section_title": true,
      "ja": "3.正しい場合は、古いCAキーを使用して署名者の証明書を確認してください。"
    },
    {
      "indent": 3,
      "text": "Case 2 will arise when the CA operator has issued the signer's certificate, then changed the key, and then issued the verifier's certificate; so it is quite a typical case.",
      "ja": "ケース2は、CAオペレータが署名者の証明書を発行したとき、キーを変更して、検証の証明書を発行したが生じます。それは非常に典型的なケースです。"
    },
    {
      "indent": 0,
      "text": "4.4.2.3. Verification in Case 3",
      "section_title": true,
      "ja": "4.4.2.3。ケース3での検証"
    },
    {
      "indent": 3,
      "text": "In case 3, the verifier must get access to the new public key of the CA. The verifier does the following:",
      "ja": "ケース3では、検証はCAの新しい公開鍵へのアクセスを取得する必要があります検証者は、次のことを行います。"
    },
    {
      "indent": 3,
      "text": "1.  Look up the CACertificate attribute in the repository and pick\n    the NewWithOld certificate (determined based on validity periods;\n    note that the subject and issuer fields must match);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. Verify that this is correct using the old CA key (which the verifier has stored locally);",
      "ja": "2.これは（検証者がローカルに格納されている）古いCAキーを使用して、正しいことを確認します。"
    },
    {
      "indent": 3,
      "text": "3. If correct, check the signer's certificate using the new CA key.",
      "section_title": true,
      "ja": "3.正しい場合は、新しいCAキーを使用して署名者の証明書を確認してください。"
    },
    {
      "indent": 3,
      "text": "Case 3 will arise when the CA operator has issued the verifier's certificate, then changed the key, and then issued the signer's certificate; so it is also quite a typical case.",
      "ja": "ケース3は、CAオペレータが検証の証明書を発行したとき、キーを変更し、その後、署名者の証明書を発行したが生じます。それもかなり典型的なケースです。"
    },
    {
      "indent": 0,
      "text": "4.4.2.4. Failure of Verification in Case 6",
      "section_title": true,
      "ja": "4.4.2.4。ケース6における検証の失敗"
    },
    {
      "indent": 3,
      "text": "In this case, the CA has issued the verifier's PSE, which contains the new key, without updating the repository attributes. This means that the verifier has no means to get a trustworthy version of the CA's old key and so verification fails.",
      "ja": "この場合、CAは、リポジトリの属性を更新せずに、新しいキーが含まれている検証のPSEを、発行しています。これは、検証がCAの古いキーの信頼できるバージョンを取得するための手段を持たないので、検証が失敗したことを意味します。"
    },
    {
      "indent": 3,
      "text": "Note that the failure is the CA operator's fault.",
      "ja": "障害がCAオペレータの障害であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.4.2.5. Failure of Verification in Case 7",
      "section_title": true,
      "ja": "4.4.2.5。事例7での検証の失敗"
    },
    {
      "indent": 3,
      "text": "In this case, the CA has issued the signer's certificate protected with the new key without updating the repository attributes. This means that the verifier has no means to get a trustworthy version of the CA's new key and so verification fails.",
      "ja": "この場合、CAは、リポジトリの属性を更新せずに新しいキーで保護された署名者の証明書を発行しました。これは、検証がCAの新しいキーの信頼できるバージョンを取得するための手段を持たないので、検証が失敗したことを意味します。"
    },
    {
      "indent": 3,
      "text": "Note that the failure is again the CA operator's fault.",
      "ja": "障害が再びCAオペレータの障害であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Revocation - Change of CA Key",
      "section_title": true,
      "ja": "4.4.3。失効 -  CAキーの変更"
    },
    {
      "indent": 3,
      "text": "As we saw above, the verification of a certificate becomes more complex once the CA is allowed to change its key. This is also true for revocation checks as the CA may have signed the CRL using a newer private key than the one within the user's PSE.",
      "ja": "上で見たようCAは、そのキーを変更することが許可されたら、証明書の検証が複雑になります。 CAは、ユーザーのPSE内のものより新しい秘密鍵を使用してCRLに署名したことがあり、これは、失効チェックのためにも当てはまります。"
    },
    {
      "indent": 3,
      "text": "The analysis of the alternatives is the same as for certificate verification.",
      "ja": "代替案の分析は、証明書検証のためのと同じです。"
    },
    {
      "indent": 0,
      "text": "5. Data Structures",
      "section_title": true,
      "ja": "5.データ構造"
    },
    {
      "indent": 3,
      "text": "This section contains descriptions of the data structures required for PKI management messages. Section 6 describes constraints on their values and the sequence of events for each of the various PKI management operations.",
      "ja": "このセクションでは、PKI管理メッセージのために必要なデータ構造の記述が含まれています。第6節は、それらの値の制約や、様々なPKI管理操作のそれぞれのイベントのシーケンスを説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Overall PKI Message",
      "section_title": true,
      "ja": "5.1。全体のPKIメッセージ"
    },
    {
      "indent": 3,
      "text": "All of the messages used in this specification for the purposes of PKI management use the following structure:",
      "ja": "PKI管理の目的のために本明細書中で使用されるすべてのメッセージは、次の構造を使用します。"
    },
    {
      "indent": 5,
      "text": " PKIMessage ::= SEQUENCE {\n    header           PKIHeader,\n    body             PKIBody,\n    protection   [0] PKIProtection OPTIONAL,\n    extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate\n                     OPTIONAL\n}\nPKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The PKIHeader contains information that is common to many PKI messages.",
      "ja": "PKIHeaderは、多くのPKIメッセージに共通する情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The PKIBody contains message-specific information.",
      "ja": "PKIBodyは、メッセージ固有の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The PKIProtection, when used, contains bits that protect the PKI message.",
      "ja": "使用PKIProtectionは、PKIメッセージを保護ビットを含みます。"
    },
    {
      "indent": 3,
      "text": "The extraCerts field can contain certificates that may be useful to the recipient. For example, this can be used by a CA or RA to present an end entity with certificates that it needs to verify its own new certificate (if, for example, the CA that issued the end entity's certificate is not a root CA for the end entity). Note that this field does not necessarily contain a certification path; the recipient may have to sort, select from, or otherwise process the extra certificates in order to use them.",
      "ja": "extraCertsフィールドは、受信者に有用である可能性がある証明書を含めることができます。例えば、エンドエンティティの証明書を発行したCAがエンドのルートCAではないが、たとえば、これは、独自の新しい証明書を検証する必要がある証明書を使用して、エンドエンティティ（存在するCAまたはRAで使用することができますエンティティ）。このフィールドは、必ずしも証明書パスが含まれていないことに注意してください。受信者は、並べ替えから選択するか、そうでない場合はそれらを使用するためには、余分な証明書を処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1. PKI Message Header",
      "section_title": true,
      "ja": "5.1.1。 PKIメッセージヘッダ"
    },
    {
      "indent": 3,
      "text": "All PKI messages require some header information for addressing and transaction identification. Some of this information will also be present in a transport-specific envelope. However, if the PKI message is protected, then this information is also protected (i.e., we make no assumption about secure transport).",
      "ja": "すべてのPKIメッセージアドレッシングとトランザクション識別のためのいくつかのヘッダ情報を必要としています。この情報の一部はまた、トランスポート固有の封筒で存在するであろう。 PKIメッセージが保護されている場合は、この情報も（すなわち、私たちは安全な輸送についての仮定をしない）保護されています。"
    },
    {
      "indent": 3,
      "text": "The following data structure is used to contain this information:",
      "ja": "次のようなデータ構造は、この情報を格納するために使用されます。"
    },
    {
      "indent": 5,
      "text": "PKIHeader ::= SEQUENCE {\n    pvno                INTEGER     { cmp1999(1), cmp2000(2) },\n    sender              GeneralName,\n    recipient           GeneralName,\n    messageTime     [0] GeneralizedTime         OPTIONAL,\n    protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,\n    senderKID       [2] KeyIdentifier           OPTIONAL,\n    recipKID        [3] KeyIdentifier           OPTIONAL,\n    transactionID   [4] OCTET STRING            OPTIONAL,\n    senderNonce     [5] OCTET STRING            OPTIONAL,\n    recipNonce      [6] OCTET STRING            OPTIONAL,\n    freeText        [7] PKIFreeText             OPTIONAL,\n    generalInfo     [8] SEQUENCE SIZE (1..MAX) OF\n                        InfoTypeAndValue     OPTIONAL\n}\nPKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The pvno field is fixed (at 2) for this version of this specification.",
      "ja": "PVNOフィールドは、この明細書のこのバージョンのために（2の）固定されています。"
    },
    {
      "indent": 3,
      "text": "The sender field contains the name of the sender of the PKIMessage. This name (in conjunction with senderKID, if supplied) should be sufficient to indicate the key to use to verify the protection on the message. If nothing about the sender is known to the sending entity (e.g., in the init. req. message, where the end entity may not know its own Distinguished Name (DN), e-mail name, IP address, etc.), then the \"sender\" field MUST contain a \"NULL\" value; that is, the SEQUENCE OF relative distinguished names is of zero length. In such a case, the senderKID field MUST hold an identifier (i.e., a reference number) that indicates to the receiver the appropriate shared secret information to use to verify the message.",
      "ja": "送信者フィールドはPKIMessageの送信者の名前が含まれています。この名前は、（senderKIDと併せて、提供されている場合）メッセージの保護を確認するために使用するキーを示すのに十分であるべきです。送信者に関する何も送信エンティティに知られていない場合（initの中など、。REQエンドエンティティは、など、独自の識別名（DN）、電子メール名、IPアドレスを知らないかもしれない。メッセージ、）、その後、 「送信者」欄には、「NULL」値を含まなければなりません。つまり、相対識別名のシーケンスは、長さがゼロです。このような場合には、senderKIDフィールドは、メッセージを検証するために使用する受信機に適切な共有秘密情報を示している（すなわち、参照番号）識別子を保持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The recipient field contains the name of the recipient of the PKIMessage. This name (in conjunction with recipKID, if supplied) should be usable to verify the protection on the message.",
      "ja": "受信者フィールドはPKIMessageの受信者の名前が含まれています。この名前は、（recipKIDと一緒に供給された場合）メッセージに保護を検証するために使用可能であるべきです。"
    },
    {
      "indent": 3,
      "text": "The protectionAlg field specifies the algorithm used to protect the message. If no protection bits are supplied (note that PKIProtection is OPTIONAL) then this field MUST be omitted; if protection bits are supplied, then this field MUST be supplied.",
      "ja": "protectionAlgフィールドは、メッセージを保護するために使用するアルゴリズムを指定します。いかなる保護ビットが供給されていない場合、このフィールドを省略しなければならない（PKIProtectionがオプションであることに留意されたいです）。保護ビットが供給されている場合は、このフィールドを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "senderKID and recipKID are usable to indicate which keys have been used to protect the message (recipKID will normally only be required where protection of the message uses Diffie-Hellman (DH) keys).",
      "ja": "senderKIDとrecipKIDは、（メッセージの保護は、ディフィー・ヘルマン（DH）鍵が使用recipKIDが正常にのみ必要とされる）メッセージを保護するために使用されているキーを示すために使用可能です。"
    },
    {
      "indent": 3,
      "text": "These fields MUST be used if required to uniquely identify a key (e.g., if more than one key is associated with a given sender name) and SHOULD be omitted otherwise.",
      "ja": "これらのフィールドは、一意のキーを識別するために必要な場合に使用しなければならない（例えば、複数のキーを指定された送信者名に関連付けられている場合）、そうでない場合は省略されるべきです。"
    },
    {
      "indent": 3,
      "text": "The transactionID field within the message header is to be used to allow the recipient of a message to correlate this with an ongoing transaction. This is needed for all transactions that consist of more than just a single request/response pair. For transactions that consist of a single request/response pair, the rules are as follows. A client MAY populate the transactionID field of the request. If a server receives such a request that has the transactionID field set, then it MUST set the transactionID field of the response to the same value. If a server receives such request with a missing transactionID field, then it MAY set transactionID field of the response.",
      "ja": "メッセージヘッダ内のトランザクションIDフィールドは、メッセージの受信者は、進行中のトランザクションでこれを相関することを可能にするために使用されます。これは、単に1つの要求/応答のペアよりも多くで構成され、すべての取引のために必要とされています。次のように単一の要求/応答対から成る取引について、ルールがあります。クライアントは、要求のトランザクションIDフィールドを移入してもよい（MAY）。サーバがトランザクションIDのフィールドが設定されているような要求を受けた場合、それは同じ値に応じてのトランザクションIDフィールドを設定しなければなりません。サーバが不足しているトランザクションIDフィールドを持つような要求を受信した場合、それは、応答のトランザクションIDフィールドを設定することができます。"
    },
    {
      "indent": 3,
      "text": "For transactions that consist of more than just a single request/response pair, the rules are as follows. Clients SHOULD generate a transactionID for the first request. If a server receives such a request that has the transactionID field set, then it MUST set the transactionID field of the response to the same value. If a server receives such request with a missing transactionID field, then it MUST populate the transactionID field of the response with a server-generated ID. Subsequent requests and responses MUST all set the transactionID field to the thus established value. In all cases where a transactionID is being used, a given client MUST NOT have more than one transaction with the same transactionID in progress at any time (to a given server). Servers are free to require uniqueness of the transactionID or not, as long as they are able to correctly associate messages with the corresponding transaction. Typically, this means that a server will require the {client, transactionID} tuple to be unique, or even the transactionID alone to be unique, if it cannot distinguish clients based on transport-level information. A server receiving the first message of a transaction (which requires more than a single request/response pair) that contains a transactionID that does not allow it to meet the above constraints (typically because the transactionID is already in use) MUST send back an ErrorMsgContent with a PKIFailureInfo of transactionIdInUse. It is RECOMMENDED that the clients fill the transactionID field with 128 bits of (pseudo-) random data for the start of a transaction to reduce the probability of having the transactionID in use at the server.",
      "ja": "次のようにただ1つの要求/応答対以上から成る取引について、ルールがあります。クライアントは、最初の要求のためのトランザクションIDを生成する必要があります。サーバがトランザクションIDのフィールドが設定されているような要求を受けた場合、それは同じ値に応じてのトランザクションIDフィールドを設定しなければなりません。サーバーが見つからないトランザクションIDのフィールドで、このような要求を受信した場合、それは、サーバが生成したIDを持つ応答のトランザクションIDフィールドを移入する必要があります。後続の要求と応答はすべてのため設立された値にトランザクションIDフィールドを設定しなければなりません。トランザクションIDが使用されているすべての場合において、与えられたクライアントは、（特定のサーバへの）任意の時点で進行中の同じトランザクションIDを持つ複数のトランザクションを持ってはいけません。サーバは、彼らが正しく対応するトランザクションとメッセージを関連付けることができます限り、トランザクションIDやないの一意性を必要とするのは自由です。典型的には、これは、サーバーが一意である{クライアント、トランザクションID}タプルを必要とする、またはそれは、トランスポート・レベルの情報に基づいてクライアントを区別することができない場合は、単独であってもトランザクションIDは、一意であることを意味します。 （トランザクションIDがすでに使用されている典型的ので）、それは上記の制約を満たすことができないトランザクションIDを含んでいる（単一の要求/応答のペア以上を必要とする）、トランザクションの最初のメッセージを受信したサーバはErrorMsgContentを返送しなければなりませんtransactionIdInUseのPKIFailureInfoと。クライアントがサーバで使用中のトランザクションIDを有する確率を減らすためにトランザクションの開始のための（擬似）ランダムな128ビットのデータとトランザクションIDのフィールドを埋めることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "The senderNonce and recipNonce fields protect the PKIMessage against replay attacks. The senderNonce will typically be 128 bits of (pseudo-) random data generated by the sender, whereas the recipNonce is copied from the senderNonce of the previous message in the transaction.",
      "ja": "senderNonceとrecipNonceフィールドは、リプレイ攻撃に対するPKIMessageを保護します。 recipNonceトランザクション内の前のメッセージのsenderNonceからコピーされるのに対し、senderNonceは、典型的には、送信者によって生成された（擬似）ランダムなデータの128ビットとなります。"
    },
    {
      "indent": 3,
      "text": "The messageTime field contains the time at which the sender created the message. This may be useful to allow end entities to correct/check their local time for consistency with the time on a central system.",
      "ja": "messageTimeフィールドは、送信者がメッセージを作成した時刻が含まれています。これは、エンドエンティティが中央システムに時間との整合性のために自分のローカル時間をチェック/修正することを可能にするのに有用である可能性があります。"
    },
    {
      "indent": 3,
      "text": "The freeText field may be used to send a human-readable message to the recipient (in any number of languages). The first language used in this sequence indicates the desired language for replies.",
      "ja": "フリーテキストフィールドは、（言語の任意の数の）受信者に人間が読めるメッセージを送信するために使用されてもよいです。このシーケンスで使用される第1言語は、応答のための所望の言語を示します。"
    },
    {
      "indent": 3,
      "text": "The generalInfo field may be used to send machine-processable additional data to the recipient. The following generalInfo extensions are defined and MAY be supported.",
      "ja": "generalInfoフィールドは、受信者に機械処理の追加データを送信するために使用することができます。次generalInfoの拡張が定義されており、サポートされるかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.1.1.1. ImplicitConfirm",
      "section_title": true,
      "ja": "5.1.1.1。 ImplicitConfirm"
    },
    {
      "indent": 3,
      "text": "This is used by the EE to inform the CA that it does not wish to send a certificate confirmation for issued certificates.",
      "ja": "これは、それが発行された証明書の証明書の確認を送信したくないCAに通知するためにEEで使用されています。"
    },
    {
      "indent": 9,
      "text": "implicitConfirm OBJECT IDENTIFIER ::= {id-it 13}\nImplicitConfirmValue ::= NULL",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the CA grants the request to the EE, it MUST put the same extension in the PKIHeader of the response. If the EE does not find the extension in the response, it MUST send the certificate confirmation.",
      "ja": "CAは、EEへの要求を許可した場合、それは応答のPKIHeaderに同じ拡張子を置く必要があります。 EEが応答した拡張子が見つからない場合は、証明書の確認を送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.1.2. ConfirmWaitTime",
      "section_title": true,
      "ja": "5.1.1.2。 ConfirmWaitTime"
    },
    {
      "indent": 3,
      "text": "This is used by the CA to inform the EE how long it intends to wait for the certificate confirmation before revoking the certificate and deleting the transaction.",
      "ja": "これは、それが証明書を失効し、トランザクションを削除する前に、証明書の確認を待つつもりでどのくらいのEEに通知するためにCAによって使用されます。"
    },
    {
      "indent": 9,
      "text": "confirmWaitTime OBJECT IDENTIFIER ::= {id-it 14}\nConfirmWaitTimeValue ::= GeneralizedTime",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.1.2. PKI Message Body",
      "section_title": true,
      "ja": "5.1.2。 PKIメッセージ本文"
    },
    {
      "indent": 8,
      "text": "PKIBody ::= CHOICE {\n  ir       [0]  CertReqMessages,       --Initialization Req\n  ip       [1]  CertRepMessage,        --Initialization Resp\n  cr       [2]  CertReqMessages,       --Certification Req\n  cp       [3]  CertRepMessage,        --Certification Resp\n  p10cr    [4]  CertificationRequest,  --PKCS #10 Cert.  Req.\n  popdecc  [5]  POPODecKeyChallContent --pop Challenge\n  popdecr  [6]  POPODecKeyRespContent, --pop Response\n  kur      [7]  CertReqMessages,       --Key Update Request\n  kup      [8]  CertRepMessage,        --Key Update Response\n  krr      [9]  CertReqMessages,       --Key Recovery Req krp      [10] KeyRecRepContent,      --Key Recovery Resp\n  rr       [11] RevReqContent,         --Revocation Request\n  rp       [12] RevRepContent,         --Revocation Response\n  ccr      [13] CertReqMessages,       --Cross-Cert.  Request\n  ccp      [14] CertRepMessage,        --Cross-Cert.  Resp\n  ckuann   [15] CAKeyUpdAnnContent,    --CA Key Update Ann.\n  cann     [16] CertAnnContent,        --Certificate Ann.\n  rann     [17] RevAnnContent,         --Revocation Ann.\n  crlann   [18] CRLAnnContent,         --CRL Announcement\n  pkiconf  [19] PKIConfirmContent,     --Confirmation\n  nested   [20] NestedMessageContent,  --Nested Message\n  genm     [21] GenMsgContent,         --General Message\n  genp     [22] GenRepContent,         --General Response\n  error    [23] ErrorMsgContent,       --Error Message\n  certConf [24] CertConfirmContent,    --Certificate confirm\n  pollReq  [25] PollReqContent,        --Polling request\n  pollRep  [26] PollRepContent         --Polling response\n  }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The specific types are described in Section 5.3 below.",
      "ja": "特定の種類は、以下のセクション5.3で説明されています。"
    },
    {
      "indent": 0,
      "text": "5.1.3. PKI Message Protection",
      "section_title": true,
      "ja": "5.1.3。 PKIメッセージ保護"
    },
    {
      "indent": 3,
      "text": "Some PKI messages will be protected for integrity. (Note that if an asymmetric algorithm is used to protect a message and the relevant public component has been certified already, then the origin of the message can also be authenticated. On the other hand, if the public component is uncertified, then the message origin cannot be automatically authenticated, but may be authenticated via out-of-band means.)",
      "ja": "一部のPKIメッセージは、完全性のために保護されます。 （非対称アルゴリズムは、メッセージを保護するために使用され、関連するパブリックコンポーネントが既に認証された場合、パブリックコンポーネントは、メッセージの起源その後、未認証である場合、メッセージの起源はまた、一方、認証することができることに注意してください自動的に認証することができないが、アウトオブバンド手段を介して認証することができます。）"
    },
    {
      "indent": 3,
      "text": "When protection is applied, the following structure is used:",
      "ja": "保護が適用されると、次のような構造が使用されます。"
    },
    {
      "indent": 8,
      "text": "PKIProtection ::= BIT STRING",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The input to the calculation of PKIProtection is the DER encoding of the following data structure:",
      "ja": "PKIProtectionの計算への入力は、次のデータ構造のDER符号化です。"
    },
    {
      "indent": 8,
      "text": "ProtectedPart ::= SEQUENCE {\n    header    PKIHeader,\n    body      PKIBody\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "There MAY be cases in which the PKIProtection BIT STRING is deliberately not used to protect a message (i.e., this OPTIONAL field is omitted) because other protection, external to PKIX, will be applied instead. Such a choice is explicitly allowed in this specification. Examples of such external protection include PKCS #7",
      "ja": "PKIX外部の他の保護は、代わりに適用されるので、PKIProtectionビット列は、意図的にメッセージを保護するために使用されない場合がある（すなわち、このオプションのフィールドは省略されます）。このような選択は、明示的にこの仕様で許可されています。そのような外部保護の例としては、PKCS＃7が含まれます"
    },
    {
      "indent": 3,
      "text": "[PKCS7] and Security Multiparts [RFC1847] encapsulation of the PKIMessage (or simply the PKIBody (omitting the CHOICE tag), if the relevant PKIHeader information is securely carried in the external mechanism). It is noted, however, that many such external mechanisms require that the end entity already possesses a public-key certificate, and/or a unique Distinguished Name, and/or other such infrastructure-related information. Thus, they may not be appropriate for initial registration, key-recovery, or any other process with \"boot-strapping\" characteristics. For those cases it may be necessary that the PKIProtection parameter be used. In the future, if/when external mechanisms are modified to accommodate boot-strapping scenarios, the use of PKIProtection may become rare or non-existent.",
      "ja": "[PKCS7]とPKIMessageのセキュリティマルチパート[RFC1847]カプセル化（または単にPKIBody（CHOICEタグを省略）、関連PKIHeader情報が確実に外部機構で搬送されている場合）。多くのそのような外部のメカニズムは、エンドエンティティがすでに公開鍵証明書、および/または固有の識別名、および/またはその他などのインフラ関連の情報を保有することを要求すること、しかし、注意すべきです。このように、彼らは初期登録、キー・リカバリー、または「ブートストラップ」の特性を持つ他のプロセスのために適切でないかもしれません。そのような場合のために、PKIProtectionパラメータが使用されることが必要かもしれません。外部メカニズムはブートストラップのシナリオに対応するために変更されたとき/場合、将来的に、PKIProtectionの使用は稀なまたは非存在になることができます。"
    },
    {
      "indent": 3,
      "text": "Depending on the circumstances, the PKIProtection bits may contain a Message Authentication Code (MAC) or signature. Only the following cases can occur:",
      "ja": "状況に応じて、PKIProtectionビットは、メッセージ認証コード（MAC）または署名を含んでいてもよいです。次の場合のみが発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.1.3.1. Shared Secret Information",
      "section_title": true,
      "ja": "5.1.3.1。共有秘密情報"
    },
    {
      "indent": 3,
      "text": "In this case, the sender and recipient share secret information (established via out-of-band means or from a previous PKI management operation). PKIProtection will contain a MAC value and the protectionAlg will be the following (see also Appendix D.2):",
      "ja": "（アウト・オブ・バンド手段を介して、または前のPKI管理操作から確立された）この場合、送信者と受信者の共有秘密情報。 PKIProtectionは、MAC値が含まれていますし、protectionAlgは（も付録D.2を参照）、以下のようになります。"
    },
    {
      "indent": 5,
      "text": "id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}\nPBMParameter ::= SEQUENCE {\n  salt                OCTET STRING,\n  owf                 AlgorithmIdentifier,\n  iterationCount      INTEGER,\n  mac                 AlgorithmIdentifier\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the above protectionAlg, the salt value is appended to the shared secret input. The OWF is then applied iterationCount times, where the salted secret is the input to the first iteration and, for each successive iteration, the input is set to be the output of the previous iteration. The output of the final iteration (called \"BASEKEY\" for ease of reference, with a size of \"H\") is what is used to form the symmetric key. If the MAC algorithm requires a K-bit key and K <= H, then the most significant K bits of BASEKEY are used. If K > H, then all of BASEKEY is used for the most significant H bits of the key, OWF(\"1\" || BASEKEY) is used for the next most significant H bits of the key, OWF(\"2\" || BASEKEY) is used for the next most significant H bits of the key, and so on, until all K bits have been derived. [Here \"N\" is the ASCII byte encoding the number N and \"||\" represents concatenation.]",
      "ja": "上記protectionAlgでは、ソルト値は、共有シークレットの入力に付加されます。 OWFは、各連続する反復について、入力は前の反復の出力に設定され、塩漬け秘密は最初の反復に入力さiterationCount回印加されます。最後の反復（「H」の大きさで、参照を容易にするための「BASEKEY」と呼ばれる）の出力は、対称鍵を形成するために使用されるものです。 MACアルゴリズムは、Kビットの鍵とK <= Hを必要とする場合、次にBASEKEYの上位kビットが使用されます。 K> Hは、次いでBASEKEYの全てがキーの最上位Hビットに使用される場合、OWF（「1」|| BASEKEY）は、キー、OWF（「2」の次の最上位Hビットのために使用される||すべてのKビットが導出されるまでBASEKEY）が、ようにキーの次の最上位Hビットのために使用され、以下同様です。 [ここで、「N」は、数Nと「||」をコードするASCIIバイトであります連結を表します。]"
    },
    {
      "indent": 3,
      "text": "Note: it is RECOMMENDED that the fields of PBMParameter remain constant throughout the messages of a single transaction (e.g., ir/ip/certConf/pkiConf) in order to reduce the overhead associated with PasswordBasedMac computation).",
      "ja": "注：）PBMParameterのフィールドはPasswordBasedMac計算に関連するオーバーヘッドを低減するために、単一のトランザクション（例えば、IR / IP / certConf / pkiConf）のメッセージを通じて一定のままであることが推奨されます。"
    },
    {
      "indent": 0,
      "text": "5.1.3.2. DH Key Pairs",
      "section_title": true,
      "ja": "5.1.3.2。 DH鍵ペア"
    },
    {
      "indent": 3,
      "text": "Where the sender and receiver possess Diffie-Hellman certificates with compatible DH parameters, in order to protect the message the end entity must generate a symmetric key based on its private DH key value and the DH public key of the recipient of the PKI message. PKIProtection will contain a MAC value keyed with this derived symmetric key and the protectionAlg will be the following:",
      "ja": "どこ送信者と受信者は、エンドエンティティは、その秘密DH鍵の値とPKIメッセージの受信者のDH公開鍵に基づいて対称鍵を生成しなければならないメッセージを保護するために、互換性のDHパラメータとのDiffie-Hellman証明書を持っています。 PKIProtectionは、この導出対称鍵をキーMAC値が含まれていますし、protectionAlgは次のようになります。"
    },
    {
      "indent": 8,
      "text": "id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}",
      "raw": true
    },
    {
      "indent": 8,
      "text": "DHBMParameter ::= SEQUENCE {\n    owf                 AlgorithmIdentifier,\n    -- AlgId for a One-Way Function (SHA-1 recommended)\n    mac                 AlgorithmIdentifier\n    -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],\n}   -- or HMAC [RFC2104, RFC2202])",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the above protectionAlg, OWF is applied to the result of the Diffie-Hellman computation. The OWF output (called \"BASEKEY\" for ease of reference, with a size of \"H\") is what is used to form the symmetric key. If the MAC algorithm requires a K-bit key and K <= H, then the most significant K bits of BASEKEY are used. If K > H, then all of BASEKEY is used for the most significant H bits of the key, OWF(\"1\" || BASEKEY) is used for the next most significant H bits of the key, OWF(\"2\" || BASEKEY) is used for the next most significant H bits of the key, and so on, until all K bits have been derived. [Here \"N\" is the ASCII byte encoding the number N and \"||\" represents concatenation.]",
      "ja": "上記protectionAlgにおいて、OWFはのDiffie-Hellman計算の結果に適用されます。 （「H」の大きさで、参照を容易にするため、「BASEKEY」と呼ばれる）OWF出力は、対称鍵を形成するために使用されるものです。 MACアルゴリズムは、Kビットの鍵とK <= Hを必要とする場合、次にBASEKEYの上位kビットが使用されます。 K> Hは、次いでBASEKEYの全てがキーの最上位Hビットに使用される場合、OWF（「1」|| BASEKEY）は、キー、OWF（「2」の次の最上位Hビットのために使用される||すべてのKビットが導出されるまでBASEKEY）が、ようにキーの次の最上位Hビットのために使用され、以下同様です。 [ここで、「N」は、数Nと「||」をコードするASCIIバイトであります連結を表します。]"
    },
    {
      "indent": 0,
      "text": "5.1.3.3. Signature",
      "section_title": true,
      "ja": "5.1.3.3。署名"
    },
    {
      "indent": 3,
      "text": "In this case, the sender possesses a signature key pair and simply signs the PKI message. PKIProtection will contain the signature value and the protectionAlg will be an AlgorithmIdentifier for a digital signature (e.g., md5WithRSAEncryption or dsaWithSha-1).",
      "ja": "この場合、送信者は、署名鍵ペアを有し、単にPKIメッセージに署名します。 PKIProtectionは、署名値を含むであろうとprotectionAlgは、デジタル署名（例えば、md5WithRSAEncryption又はdsaWithSha-1）のためのAlgorithmIdentifierであろう。"
    },
    {
      "indent": 0,
      "text": "5.1.3.4. Multiple Protection",
      "section_title": true,
      "ja": "5.1.3.4。複数の保護"
    },
    {
      "indent": 3,
      "text": "In cases where an end entity sends a protected PKI message to an RA, the RA MAY forward that message to a CA, attaching its own protection (which MAY be a MAC or a signature, depending on the information and certificates shared between the RA and the CA). This is accomplished by nesting the entire message sent by the end entity within a new PKI message. The structure used is as follows.",
      "ja": "エンドエンティティは、RAに保護されたPKIメッセージを送信する場合には、RAはRAとの間で共有される情報と証明書に応じて、MAC又は署名することができる（独自の保護を取り付ける、CAにそのメッセージを転送することができるとCA）。これは、新しいPKIメッセージ内のエンドエンティティによって送信されたメッセージ全体を入れ子にすることによって達成されます。次のように使用された構造です。"
    },
    {
      "indent": 10,
      "text": "NestedMessageContent ::= PKIMessages",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(The use of PKIMessages, a SEQUENCE OF PKIMessage, lets the RA batch the requests of several EEs in a single new message. For simplicity, all messages in the batch MUST be of the same type (e.g., ir).) If the RA wishes to modify the message(s) in some way (e.g., add particular field values or new extensions), then it MAY create its own desired PKIBody. The original PKIMessage from the EE MAY be included in the generalInfo field of PKIHeader (to accommodate, for example, cases in which the CA wishes to check POP or other information on the original EE message). The infoType to be used in this situation is {id-it 15} (see Section 5.3.19 for the value of id-it) and the infoValue is PKIMessages (contents MUST be in the same order as the requests in PKIBody).",
      "ja": "（PKIMessagesの使用、PKIMessageのシーケンスは、単一の新しいメッセージにRAのバッチを数のEEの要求をすることができます。簡単にするために、バッチ内のすべてのメッセージは、同じタイプ（例えば、IR）でなければなりません。）RA場合何らかの方法でメッセージ（複数可）を変更したい、それは自身の希望PKIBodyを作成することができ、（例えば、特定のフィールド値または新しい拡張機能を追加します）。 EEからオリジナルPKIMessageは（CAは、元EEメッセージにPOPまたは他の情報を確認することを希望する、例えば、ケースに対応するために）PKIHeaderのgeneralInfoフィールドに含まれるかもしれません。このような状況で使用するのinfoTypeは、{ID-IT 15}（ID-ITの値については、セクション5.3.19を参照のこと）とinfoValueはPKIMessages（内容PKIBodyにおける要求と同じ順序でなければなりません）です。"
    },
    {
      "indent": 0,
      "text": "5.2. Common Data Structures",
      "section_title": true,
      "ja": "5.2。一般的なデータ構造"
    },
    {
      "indent": 3,
      "text": "Before specifying the specific types that may be placed in a PKIBody, we define some data structures that are used in more than one case.",
      "ja": "PKIBodyに配置することができる特定のタイプを指定する前に、我々は、複数のケースで使用されるいくつかのデータ構造を定義します。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Requested Certificate Contents",
      "section_title": true,
      "ja": "5.2.1。要求された証明書の内容"
    },
    {
      "indent": 3,
      "text": "Various PKI management messages require that the originator of the message indicate some of the fields that are required to be present in a certificate. The CertTemplate structure allows an end entity or RA to specify as much as it wishes about the certificate it requires. CertTemplate is identical to a Certificate, but with all fields optional.",
      "ja": "様々なPKI管理メッセージは、メッセージの発信者が証明書に存在することが要求されるフィールドの一部を示していることを必要とします。 CertTemplateの構造は、エンドエンティティまたはRAは、それが必要となる証明書についての希望な限り多くを指定することができます。 CertTemplateの証明書と同じですが、すべてのフィールドではオプション。"
    },
    {
      "indent": 3,
      "text": "Note that even if the originator completely specifies the contents of a certificate it requires, a CA is free to modify fields within the certificate actually issued. If the modified certificate is unacceptable to the requester, the requester MUST send back a certConf message that either does not include this certificate (via a CertHash), or does include this certificate (via a CertHash) along with a status of \"rejected\". See Section 5.3.18 for the definition and use of CertHash and the certConf message.",
      "ja": "発信元が完全にそれが必要とする証明書の内容を指定した場合でも、CAは、実際に発行された証明書内のフィールドを自由に変更することに注意してください。修飾された証明書が要求者に受け入れられない場合、リクエスタは（CERTHASHを介して）この証明書が含まれていないいずれかのことcertConfメッセージを返送しなければならない、または「拒否」のステータスと共に（CERTHASHを介して）この証明書が含まれません。 CERTHASHの定義および使用のためのセクション5.3.18とcertConfメッセージを参照してください。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertTemplate syntax.",
      "ja": "CertTemplateの構文については、[CRMF]および付録Cを参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Encrypted Values",
      "section_title": true,
      "ja": "5.2.2。暗号化された値"
    },
    {
      "indent": 3,
      "text": "Where encrypted values (restricted, in this specification, to be either private keys or certificates) are sent in PKI messages, the EncryptedValue data structure is used.",
      "ja": "（秘密鍵や証明書のいずれかであることを、本明細書では、制限された）暗号化された値は、PKIメッセージで送信されている場合は、EncryptedValueデータ構造が使用されています。"
    },
    {
      "indent": 3,
      "text": "See [CRMF] for EncryptedValue syntax.",
      "ja": "EncryptedValueの構文については、[CRMF]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Use of this data structure requires that the creator and intended recipient be able to encrypt and decrypt, respectively. Typically, this will mean that the sender and recipient have, or are able to generate, a shared secret key.",
      "ja": "このデータ構造を使用すると、作成者と受信者が、それぞれ、暗号化と復号化できる必要があります。通常、これは、送信者と受信者が持っている、または、共有秘密鍵を生成することが可能であることを意味します。"
    },
    {
      "indent": 3,
      "text": "If the recipient of the PKIMessage already possesses a private key usable for decryption, then the encSymmKey field MAY contain a session key encrypted using the recipient's public key.",
      "ja": "PKIMessageの受信者がすでに解読のために使用可能な秘密鍵を所有している場合は、encSymmKeyフィールドは、受信者の公開鍵を使って暗号化されたセッション鍵を含むかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Status codes and Failure Information for PKI Messages",
      "section_title": true,
      "ja": "5.2.3。 PKIメッセージのステータスコードと障害情報"
    },
    {
      "indent": 3,
      "text": "All response messages will include some status information. The following values are defined.",
      "ja": "すべての応答メッセージは、一部のステータス情報が含まれます。次の値が定義されています。"
    },
    {
      "indent": 8,
      "text": "PKIStatus ::= INTEGER {\n    accepted               (0),\n    grantedWithMods        (1),\n    rejection              (2),\n    waiting                (3),\n    revocationWarning      (4),\n    revocationNotification (5),\n    keyUpdateWarning       (6)\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Responders may use the following syntax to provide more information about failure cases.",
      "ja": "レスポンダは失敗例に関する詳細な情報を提供するために、次の構文を使用することができます。"
    },
    {
      "indent": 8,
      "text": "PKIFailureInfo ::= BIT STRING {\n    badAlg              (0),\n    badMessageCheck     (1),\n    badRequest          (2),\n    badTime             (3),\n    badCertId           (4),\n    badDataFormat       (5),\n    wrongAuthority      (6),\n    incorrectData       (7),\n    missingTimeStamp    (8),\n    badPOP              (9),\n    certRevoked         (10),\n    certConfirmed       (11),\n    wrongIntegrity      (12),\n    badRecipientNonce   (13),\n    timeNotAvailable    (14),\n    unacceptedPolicy    (15),\n    unacceptedExtension (16),\n    addInfoNotAvailable (17), badSenderNonce      (18),\n    badCertTemplate     (19),\n    signerNotTrusted    (20),\n    transactionIdInUse  (21),\n    unsupportedVersion  (22),\n    notAuthorized       (23),\n    systemUnavail       (24),\n    systemFailure       (25),\n    duplicateCertReq    (26)\n}",
      "raw": true
    },
    {
      "indent": 8,
      "text": "PKIStatusInfo ::= SEQUENCE {\n    status        PKIStatus,\n    statusString  PKIFreeText     OPTIONAL,\n    failInfo      PKIFailureInfo  OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.2.4. Certificate Identification",
      "section_title": true,
      "ja": "5.2.4。証明書識別"
    },
    {
      "indent": 3,
      "text": "In order to identify particular certificates, the CertId data structure is used.",
      "ja": "特定の証明書を識別するために、CertIdデータ構造が使用されます。"
    },
    {
      "indent": 3,
      "text": "See [CRMF] for CertId syntax.",
      "ja": "CertIdの構文については、[CRMF]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.5. Out-of-band root CA Public Key",
      "section_title": true,
      "ja": "5.2.5。ルートCA公開鍵アウトオブバンド"
    },
    {
      "indent": 3,
      "text": "Each root CA must be able to publish its current public key via some \"out-of-band\" means. While such mechanisms are beyond the scope of this document, we define data structures that can support such mechanisms.",
      "ja": "各ルートCAは、いくつかの「アウトオブバンド」手段を介して、現在の公開鍵を公開することができなければなりません。そのようなメカニズムはこのドキュメントの範囲を超えていますが、我々はそのようなメカニズムをサポートすることが可能なデータ構造を定義します。"
    },
    {
      "indent": 3,
      "text": "There are generally two methods available: either the CA directly publishes its self-signed certificate, or this information is available via the Directory (or equivalent) and the CA publishes a hash of this value to allow verification of its integrity before use.",
      "ja": "一般的に二つの方法使用できますがあります。どちらかのCAは、直接その自己署名証明書を発行し、あるいはこの情報はディレクトリ（または同等）を介して利用可能であり、CAは使用前にその完全性の検証をできるようにするには、この値のハッシュを発行しています。"
    },
    {
      "indent": 8,
      "text": "OOBCert ::= Certificate",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields within this certificate are restricted as follows:",
      "ja": "次のようにこの証明書内のフィールドが制限されています："
    },
    {
      "indent": 3,
      "text": "o The certificate MUST be self-signed (i.e., the signature must be verifiable using the SubjectPublicKeyInfo field);",
      "ja": "O証明書は自己署名（すなわち、署名はSubjectPublicKeyInfoでフィールドを使用して検証可能でなければならない）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The subject and issuer fields MUST be identical;",
      "ja": "O被写体と発行者フィールドが同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the subject field is NULL, then both subjectAltNames and issuerAltNames extensions MUST be present and have exactly the same value;",
      "ja": "サブジェクトフィールドがNULLの場合、O、次いでsubjectAltNamesをissuerAltNamesと拡張の両方が存在することと正確に同じ値を持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "o The values of all other extensions must be suitable for a self-signed certificate (e.g., key identifiers for subject and issuer must be the same).",
      "ja": "他のすべての拡張の値は、自己署名証明書に適していなければならないO（例えば、被験者及び発行者のためのキー識別子は同じでなければなりません）。"
    },
    {
      "indent": 8,
      "text": "OOBCertHash ::= SEQUENCE {\n    hashAlg     [0] AlgorithmIdentifier     OPTIONAL,\n    certId      [1] CertId                  OPTIONAL,\n    hashVal         BIT STRING\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The intention of the hash value is that anyone who has securely received the hash value (via the out-of-band means) can verify a self-signed certificate for that CA.",
      "ja": "ハッシュ値の意図は（アウト・オブ・バンド手段を介して）確実にハッシュ値を受信したことのある人は、そのCAの自己署名証明書を検証することができるということです"
    },
    {
      "indent": 0,
      "text": "5.2.6. Archive Options",
      "section_title": true,
      "ja": "5.2.6。アーカイブオプション"
    },
    {
      "indent": 3,
      "text": "Requesters may indicate that they wish the PKI to archive a private key value using the PKIArchiveOptions structure.",
      "ja": "リクエスタは、彼らがPKIArchiveOptions構造を使用してプライベートキーの値をアーカイブするPKIを望むことを示してもよいです。"
    },
    {
      "indent": 3,
      "text": "See [CRMF] for PKIArchiveOptions syntax.",
      "ja": "PKIArchiveOptionsの構文については、[CRMF]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.7. Publication Information",
      "section_title": true,
      "ja": "5.2.7。文献の情報"
    },
    {
      "indent": 3,
      "text": "Requesters may indicate that they wish the PKI to publish a certificate using the PKIPublicationInfo structure.",
      "ja": "リクエスタは、彼らがPKIPublicationInfo構造を使用して証明書を発行するPKIを望むことを示してもよいです。"
    },
    {
      "indent": 3,
      "text": "See [CRMF] for PKIPublicationInfo syntax.",
      "ja": "PKIPublicationInfoの構文については、[CRMF]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.8. Proof-of-Possession Structures",
      "section_title": true,
      "ja": "5.2.8。実証の所有構造"
    },
    {
      "indent": 3,
      "text": "If the certification request is for a signing key pair (i.e., a request for a verification certificate), then the proof-of-possession of the private signing key is demonstrated through use of the POPOSigningKey structure.",
      "ja": "認証要求（すなわち、検証証明書の要求）、次いで秘密署名鍵の証明の所持はPOPOSigningKey構造の使用によって実証されている署名鍵ペアのためのものである場合。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for POPOSigningKey syntax, but note that POPOSigningKeyInput has the following semantic stipulations in this specification.",
      "ja": "POPOSigningKeyの構文については、[CRMF]および付録Cを参照してください、しかしPOPOSigningKeyInputはこの仕様で、以下の意味上の規定を持っていることに注意してください。"
    },
    {
      "indent": 8,
      "text": "POPOSigningKeyInput ::= SEQUENCE {\n    authInfo            CHOICE {\n        sender              [0] GeneralName,\n        publicKeyMAC            PKMACValue\n    },\n    publicKey           SubjectPublicKeyInfo\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "On the other hand, if the certification request is for an encryption key pair (i.e., a request for an encryption certificate), then the proof-of-possession of the private decryption key may be demonstrated in one of three ways.",
      "ja": "一方、認証要求は、暗号鍵ペアのためのものである場合（すなわち、暗号化証明書の要求が）、その後、秘密復号鍵の証明の所持は、3つの方法のいずれかで示すことができます。"
    },
    {
      "indent": 0,
      "text": "5.2.8.1. Inclusion of the Private Key",
      "section_title": true,
      "ja": "5.2.8.1。秘密鍵を含めます"
    },
    {
      "indent": 3,
      "text": "By the inclusion of the private key (encrypted) in the CertRequest (in the thisMessage field of POPOPrivKey (see Appendix C) or in the PKIArchiveOptions control structure, depending upon whether or not archival of the private key is also desired).",
      "ja": "certrequestコマンドで（暗号化された）秘密鍵を含めることによって（POPOPrivKeyのthisMessageフィールドに（付録Cを参照）またはPKIArchiveOptions制御構造において、所望される秘密鍵のアーカイブか否かに応じて）。"
    },
    {
      "indent": 0,
      "text": "5.2.8.2. Indirect Method",
      "section_title": true,
      "ja": "5.2.8.2。間接法"
    },
    {
      "indent": 3,
      "text": "By having the CA return not the certificate, but an encrypted certificate (i.e., the certificate encrypted under a randomly-generated symmetric key, and the symmetric key encrypted under the public key for which the certification request is being made) -- this is the \"indirect\" method mentioned previously in Section 4.3.2. The end entity proves knowledge of the private decryption key to the CA by providing the correct CertHash for this certificate in the certConf message. This demonstrates POP because the EE can only compute the correct CertHash if it is able to recover the certificate, and it can only recover the certificate if it is able to decrypt the symmetric key using the required private key. Clearly, for this to work, the CA MUST NOT publish the certificate until the certConf message arrives (when certHash is to be used to demonstrate POP). See Section 5.3.18 for further details.",
      "ja": "これは - （すなわち、ランダムに生成された対称キーで暗号化された証明書、および認証要求が行われてされている公開鍵で暗号化対称鍵が）いないCAのリターン証明書が、暗号化された証明書を持つことにより、 4.3.2項で前述した「間接的な」方法。エンドエンティティはcertConfメッセージにこの証明書の正しいCERTHASHを提供することにより、CAに秘密復号鍵の知識を証明しています。証明書を回復することができるならばEEのみ正しいCERTHASHを計算することができ、必要な秘密鍵を使用して対称鍵を解読することができている場合にのみ証明書を回復することができますので、これはPOPを示しています。これが機能するために（CERTHASHがPOPを実証するために使用される場合）certConfメッセージが到着するまで、明らかに、CAは、証明書を発行してはなりません。詳細については、セクション5.3.18を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.8.3. Challenge-Response Protocol",
      "section_title": true,
      "ja": "5.2.8.3。チャレンジ応答プロトコル"
    },
    {
      "indent": 3,
      "text": "By having the end entity engage in a challenge-response protocol (using the messages POPODecKeyChall and POPODecKeyResp; see below) between CertReqMessages and CertRepMessage -- this is the \"direct\" method mentioned previously in Section 4.3.2. (This method would typically be used in an environment in which an RA verifies POP and then makes a certification request to the CA on behalf of the end entity. In such a scenario, the CA trusts the RA to have done POP correctly before the RA requests a certificate for the end entity.) The complete protocol then looks as follows (note that req' does not necessarily encapsulate req as a nested message):",
      "ja": "CertReqMessagesとCertRepMessage間 - これは、セクション4.3.2に前述の「直接」法であり、エンドエンティティを有すること（下記参照メッセージPOPODecKeyChallとPOPODecKeyRespを使用して）チャレンジ - レスポンスプロトコルに従事する。 （この方法は、典型的には、RAがPOPを検証して、エンドエンティティに代わってCAに証明書要求を行うする環境で使用されるだろう。このようなシナリオでは、CAは、RAの前に正しくPOPを行っているためにRAを信頼しますエンドエンティティの証明書を要求）（必ずしもネストされたメッセージとしてREQをカプセル化しないことREQ」に注意してください）以下のように完全なプロトコルは、その後に見えます。："
    },
    {
      "indent": 19,
      "text": "EE            RA            CA\n ---- req ---->\n <--- chall ---\n ---- resp --->\n               ---- req' --->\n               <--- rep -----\n               ---- conf --->\n               <--- ack -----\n <--- rep -----\n ---- conf --->\n <--- ack -----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This protocol is obviously much longer than the 3-way exchange given in choice (2) above, but allows a local Registration Authority to be involved and has the property that the certificate itself is not actually created until the proof-of-possession is complete. In some environments, a different order of the above messages may be required, such as the following (this may be determined by policy):",
      "ja": "このプロトコルは、明らかな選択で与えられた3ウェイ交換（2）上記よりはるかに長いですが、地元の登録機関が関与することが可能となり、実証の所持が完了するまで、証明書自体は実際に作成されていない性質を持っています。いくつかの環境では、上記メッセージの異なった順序（これはポリシーによって決定されてもよい）、以下のような、必要とされ得ます。"
    },
    {
      "indent": 19,
      "text": "EE            RA            CA\n ---- req ---->\n <--- chall ---\n ---- resp --->\n               ---- req' --->\n               <--- rep -----\n <--- rep -----\n ---- conf --->\n               ---- conf --->\n               <--- ack -----\n <--- ack -----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the cert. request is for a key agreement key (KAK) pair, then the POP can use any of the 3 ways described above for enc. key pairs, with the following changes: (1) the parenthetical text of bullet 2) is replaced with \"(i.e., the certificate encrypted under the symmetric key derived from the CA's private KAK and the public key for which the certification request is being made)\"; (2) the first parenthetical text of the challenge field of \"Challenge\" below is replaced with \"(using PreferredSymmAlg (see Section 5.3.19.4 and Appendix E.5) and a symmetric key derived from the CA's private KAK and the public key for which the certification request is being made)\". Alternatively, the POP can use the POPOSigningKey structure given in [CRMF] (where the alg field is DHBasedMAC and the signature field is the MAC) as a fourth alternative for demonstrating POP if the CA already has a D-H certificate that is known to the EE.",
      "ja": "証明書の場合。要求が鍵合意鍵（KAK）ペアのためのものである場合、POPは、ENCのために、上述の3つの方法のいずれかを使用することができます。弾丸2の（1）の括弧のテキスト）に置き換えられている「（すなわち、CAの秘密KAK由来対称鍵と公開鍵で暗号化された証明書はそのための認証要求が行われている：次のように変更とキーのペア、 ） \"; （2）（PreferredSymmAlgを使用して以下に置き換えている「チャレンジ」」のチャレンジフィールドの最初のカッコ内のテキストは（セクション5.3.19.4および付録E.5）とCAのプライベートKAK由来対称鍵と公開鍵のためを参照してくださいその証明書要求が行われています）」。代替的に、POPは、CAが既にEEにはよく知られているDH証明書を持っている場合POPを実証するための第4の代替として（ALGフィールドがDHBasedMACと署名フィールドであるMACである）[CRMF]で与えられるPOPOSigningKey構造を使用することができ。"
    },
    {
      "indent": 3,
      "text": "The challenge-response messages for proof-of-possession of a private decryption key are specified as follows (see [MvOV97], p.404 for details). Note that this challenge-response exchange is associated with the preceding cert. request message (and subsequent cert. response and confirmation messages) by the transactionID used in the PKIHeader and by the protection (MACing or signing) applied to the PKIMessage.",
      "ja": "（、[MvOV97]詳細については、p.404を参照）、以下のように実証の所持秘密復号鍵のためのチャレンジレスポンスメッセージが指定されています。このチャレンジ・レスポンス交換は、先行する証明書に関連付けられていることに注意してください。トランザクションIDによって要求メッセージ（およびその後のCERT。応答、確認メッセージ）PKIHeaderで使用され、保護（MACingまたは署名）によってPKIMessageに適用しました。"
    },
    {
      "indent": 8,
      "text": "POPODecKeyChallContent ::= SEQUENCE OF Challenge\nChallenge ::= SEQUENCE {\n    owf                 AlgorithmIdentifier  OPTIONAL,\n    witness             OCTET STRING,\n    challenge           OCTET STRING\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that the size of Rand needs to be appropriate for encryption under the public key of the requester. Given that \"int\" will typically not be longer than 64 bits, this leaves well over 100 bytes of room for the \"sender\" field when the modulus is 1024 bits. If, in some environment, names are so long that they cannot fit (e.g., very long DNs), then whatever portion will fit should be used (as long as it includes at least the common name, and as long as the receiver is able to deal meaningfully with the abbreviation).",
      "ja": "ランドの大きさは、要求者の公開鍵の下で暗号化のために適当であることが必要であることに注意してください。弾性率が1024ビットであるとき、「INT」は、通常よりも長く64ビットではないだろうことを考えると、これは「送信者」フィールドのための部屋のほか、100以上のバイトを残します。一部の環境では、名前は、彼らが（例えば、非常に長いDN）を適合しないことができるように長く、場合、一部が収まるどんな限り、受信機が可能な限り、それは少なくとも共通名が含まれて（使用すべきであり、略語を有意義に対処するため）。"
    },
    {
      "indent": 8,
      "text": "POPODecKeyRespContent ::= SEQUENCE OF INTEGER",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.2.8.4. Summary of PoP Options",
      "section_title": true,
      "ja": "5.2.8.4。 PoPのオプションの概要"
    },
    {
      "indent": 3,
      "text": "The text in this section provides several options with respect to POP techniques. Using \"SK\" for \"signing key\", \"EK\" for \"encryption key\", and \"KAK\" for \"key agreement key\", the techniques may be summarized as follows:",
      "ja": "このセクション内のテキストは、POP技術に関していくつかのオプションを提供します。次のように「署名キー」「暗号化キー」のため、「EK」、および「鍵合意キー」のための「KAK」のための「SK」を使用して、技術を要約することができます。"
    },
    {
      "indent": 9,
      "text": "RAVerified;\nSKPOP;\nEKPOPThisMessage;\nKAKPOPThisMessage;\nKAKPOPThisMessageDHMAC;\nEKPOPEncryptedCert;\nKAKPOPEncryptedCert;\nEKPOPChallengeResp; and\nKAKPOPChallengeResp.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Given this array of options, it is natural to ask how an end entity can know what is supported by the CA/RA (i.e., which options it may use when requesting certificates). The following guidelines should clarify this situation for EE implementers.",
      "ja": "オプションのこの配列を考えると、エンドエンティティが（証明書を要求するときに、それは使用することができ、すなわち、どのオプション）CA / RAによってサポートされているかを知ることができますどのように尋ねるのが自然です。次のガイドラインは、EEの実装のために、このような状況を明確にする必要があります。"
    },
    {
      "indent": 3,
      "text": "RAVerified. This is not an EE decision; the RA uses this if and only if it has verified POP before forwarding the request on to the CA, so it is not possible for the EE to choose this technique.",
      "ja": "RAVerified。これは、EEの決定ではありません。 RAは、CAへの要求を転送する前に、このことが確認された場合にのみあればPOPを使用するため、EEは、この手法を選択することはできません。"
    },
    {
      "indent": 3,
      "text": "SKPOP. If the EE has a signing key pair, this is the only POP method specified for use in the request for a corresponding certificate.",
      "ja": "SKPOP。 EEは、署名鍵ペアを持っている場合、これは、対応する証明書の要求で使用するために指定された唯一のPOP方法です。"
    },
    {
      "indent": 3,
      "text": "EKPOPThisMessage and KAKPOPThisMessage. Whether or not to give up its private key to the CA/RA is an EE decision. If the EE decides to reveal its key, then these are the only POP methods available in this specification to achieve this (and the key pair type will determine which of these two methods to use).",
      "ja": "EKPOPThisMessageとKAKPOPThisMessage。 CA / RAにその秘密鍵を放棄するかどうかは、EEの決定です。 EEは、その鍵を明らかにすることを決定した場合、これらは、これを達成するために本明細書で利用可能な唯一のPOP方法（および使用するこれらの2つの方法のどちらかを決定する鍵ペアタイプ）です。"
    },
    {
      "indent": 3,
      "text": "KAKPOPThisMessageDHMAC. The EE can only use this method if (1) the CA has a DH certificate available for this purpose, and (2) the EE already has a copy of this certificate. If both these conditions hold, then this technique is clearly supported and may be used by the EE, if desired.",
      "ja": "KAKPOPThisMessageDHMAC。 （1）CAは、この目的のために利用可能なDH証明書を有し、（2）EEはすでにこの証明書のコピーを有する場合EEは、この方法を使用することができます。これらの両方の条件が成立した場合、この技術は明らかにサポートされ、必要に応じて、EEによって使用されてもよいです。"
    },
    {
      "indent": 3,
      "text": "EKPOPEncryptedCert, KAKPOPEncryptedCert, EKPOPChallengeResp, KAKPOPChallengeResp. The EE picks one of these (in the subsequentMessage field) in the request message, depending upon preference and key pair type. The EE is not doing POP at this point; it is simply indicating which method it wants to use. Therefore, if the CA/RA replies with a \"badPOP\" error, the EE can re-request using the other POP method chosen in subsequentMessage. Note, however, that this specification encourages the use of the EncryptedCert choice and, furthermore, says that the challenge-response would typically be used when an RA is involved and doing POP verification. Thus, the EE should be able to make an intelligent decision regarding which of these POP methods to choose in the request message.",
      "ja": "EKPOPEncryptedCert、KAKPOPEncryptedCert、EKPOPChallengeResp、KAKPOPChallengeResp。 EEは、嗜好および鍵ペアの種類に応じて、要求メッセージに（subsequentMessageフィールドに）これらのいずれかを選択します。 EEは、この時点でPOPをやっていません。単にそれを使用したい方法を示しています。 CA / RAが「badPOP」エラーで応答する場合したがって、EEはsubsequentMessageに選択された他のPOPの方法を使用して要求を再ことができます。この仕様は、さらに、EncryptedCert選択の使用を奨励していること、しかし、注意してください、RAが関与してPOPの検証を行っている際に、チャレンジレスポンスが一般的に使用されるだろうと述べています。このように、EEは、要求メッセージに選択するには、これらのPOP方法のに関する知的な決定を下すことができるはずです。"
    },
    {
      "indent": 0,
      "text": "5.3. Operation-Specific Data Structures",
      "section_title": true,
      "ja": "5.3。操作固有のデータ構造"
    },
    {
      "indent": 0,
      "text": "5.3.1. Initialization Request",
      "section_title": true,
      "ja": "5.3.1。初期化要求"
    },
    {
      "indent": 3,
      "text": "An Initialization request message contains as the PKIBody a CertReqMessages data structure, which specifies the requested certificate(s). Typically, SubjectPublicKeyInfo, KeyId, and Validity are the template fields which may be supplied for each certificate requested (see Appendix D profiles for further information). This message is intended to be used for entities when first initializing into the PKI.",
      "ja": "初期化要求メッセージは、要求された証明書（複数可）を指定PKIBody CertReqMessagesデータ構造として含んでいます。典型的には、SubjectPublicKeyInfoで、鍵ID、および正当性が要求された各証明書のために供給することができるテンプレートフィールドがある（詳細については、付録Dプロファイルを参照）。このメッセージは、最初のPKIに初期化するエンティティのために使用されることを意図しています。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertReqMessages syntax.",
      "ja": "CertReqMessagesの構文については、[CRMF]および付録Cを参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Initialization Response",
      "section_title": true,
      "ja": "5.3.2。初期化応答"
    },
    {
      "indent": 3,
      "text": "An Initialization response message contains as the PKIBody an CertRepMessage data structure, which has for each certificate requested a PKIStatusInfo field, a subject certificate, and possibly a private key (normally encrypted with a session key, which is itself encrypted with the protocolEncrKey).",
      "ja": "初期化応答メッセージはPKIBody、各証明書のPKIStatusInfoフィールド、対象証明書、および場合によっては秘密鍵（通常はそれ自体がprotocolEncrKeyで暗号化されたセッション鍵を用いて暗号化された）要求したCertRepMessageデータ構造を含んでいます。"
    },
    {
      "indent": 3,
      "text": "See Section 5.3.4 for CertRepMessage syntax. Note that if the PKI Message Protection is \"shared secret information\" (see Section 5.1.3), then any certificate transported in the caPubs field may be directly trusted as a root CA certificate by the initiator.",
      "ja": "CertRepMessageの構文については、セクション5.3.4を参照してください。 PKIメッセージ保護は、その後caPubsフィールドに運ばすべての証明書は、直接イニシエータによってルートCA証明書として信頼することができる、（5.1.3項を参照してください）「秘密情報を共有」されている場合があります。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Certification Request",
      "section_title": true,
      "ja": "5.3.3。証明書要求"
    },
    {
      "indent": 3,
      "text": "A Certification request message contains as the PKIBody a CertReqMessages data structure, which specifies the requested certificates. This message is intended to be used for existing PKI entities who wish to obtain additional certificates.",
      "ja": "認証要求メッセージは、要求された証明書を指定するPKIBody CertReqMessagesデータ構造、などが含まれています。このメッセージは、追加の証明書を取得したい既存のPKIエンティティのために使用されることを意図しています。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertReqMessages syntax.",
      "ja": "CertReqMessagesの構文については、[CRMF]および付録Cを参照してください。"
    },
    {
      "indent": 3,
      "text": "Alternatively, the PKIBody MAY be a CertificationRequest (this structure is fully specified by the ASN.1 structure CertificationRequest given in [PKCS10]). This structure may be required for certificate requests for signing key pairs when interoperation with legacy systems is desired, but its use is strongly discouraged whenever not absolutely necessary.",
      "ja": "あるいは、PKIBodyはCertificationRequest（この構造は完全[PKCS10]で与えられたASN.1構造CertificationRequestによって指定されている）であってもよいです。この構造は、レガシーシステムとの相互運用が望まれますが、いつでも絶対に必要ではない、その使用が強く推奨されたときに鍵ペアに署名するための証明書要求のために必要となる場合があります。"
    },
    {
      "indent": 0,
      "text": "5.3.4. Certification Response",
      "section_title": true,
      "ja": "5.3.4。認定レスポンス"
    },
    {
      "indent": 3,
      "text": "A Certification response message contains as the PKIBody a CertRepMessage data structure, which has a status value for each certificate requested, and optionally has a CA public key, failure information, a subject certificate, and an encrypted private key.",
      "ja": "認証応答メッセージは、要求された各証明書のステータス値を有し、そして必要に応じてCA公開鍵、故障情報、対象証明書、及び暗号化された秘密鍵を有するPKIBody CertRepMessageデータ構造として含んでいます。"
    },
    {
      "indent": 5,
      "text": "CertRepMessage ::= SEQUENCE {\n    caPubs          [1] SEQUENCE SIZE (1..MAX) OF Certificate\n                        OPTIONAL,\n    response            SEQUENCE OF CertResponse\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "CertResponse ::= SEQUENCE {\n    certReqId           INTEGER,\n    status              PKIStatusInfo,\n    certifiedKeyPair    CertifiedKeyPair    OPTIONAL,\n    rspInfo             OCTET STRING        OPTIONAL\n    -- analogous to the id-regInfo-utf8Pairs string defined",
      "raw": true
    },
    {
      "indent": 5,
      "text": " -- for regInfo in CertReqMsg [CRMF] }",
      "ja": " - } CertReqMsgでREGINFO [CRMF]のために"
    },
    {
      "indent": 5,
      "text": "CertifiedKeyPair ::= SEQUENCE {\n    certOrEncCert       CertOrEncCert,\n    privateKey      [0] EncryptedValue      OPTIONAL,\n    -- see [CRMF] for comment on encoding\n    publicationInfo [1] PKIPublicationInfo  OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "CertOrEncCert ::= CHOICE {\n    certificate     [0] Certificate,\n    encryptedCert   [1] EncryptedValue\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Only one of the failInfo (in PKIStatusInfo) and certificate (in CertifiedKeyPair) fields can be present in each CertResponse (depending on the status). For some status values (e.g., waiting), neither of the optional fields will be present.",
      "ja": "のみ（PKIStatusInfoで）failInfo及び（CertifiedKeyPairで）証明書のいずれかのフィールドは、各CertResponse（状況に応じて）で存在することができます。一部のステータス値（例えば、待機中）のために、オプションフィールドのどちらが存在するであろう。"
    },
    {
      "indent": 3,
      "text": "Given an EncryptedCert and the relevant decryption key, the certificate may be obtained. The purpose of this is to allow a CA to return the value of a certificate, but with the constraint that only the intended recipient can obtain the actual certificate. The benefit of this approach is that a CA may reply with a certificate even in the absence of a proof that the requester is the end entity that can use the relevant private key (note that the proof is not obtained until the certConf message is received by the CA). Thus, the CA will not have to revoke that certificate in the event that something goes wrong with the proof-of-possession (but MAY do so anyway, depending upon policy).",
      "ja": "EncryptedCertと関連する復号鍵を考えると、証明書を取得することができます。この目的はなく、対象とする受信者だけが、実際の証明書を取得することができ制約と、CAは証明書の値を返すことができるようにすることです。このアプローチの利点は、CAも要求者が、関連する秘密鍵を使用することができ、エンドエンティティであることの証明が存在しない場合に証明書を使用して応答することができるということである（certConfメッセージがによって受信されるまで証拠が得られないことに注意してくださいCA）。したがって、CAは何かが実証の所持とうまくいかない（が、ポリシーに応じて、とにかくそうするかもしれない）という場合には、その証明書を失効させる必要はありません。"
    },
    {
      "indent": 0,
      "text": "5.3.5. Key Update Request Content",
      "section_title": true,
      "ja": "5.3.5。鍵更新要求内容"
    },
    {
      "indent": 3,
      "text": "For key update requests the CertReqMessages syntax is used. Typically, SubjectPublicKeyInfo, KeyId, and Validity are the template fields that may be supplied for each key to be updated. This message is intended to be used to request updates to existing (non-revoked and non-expired) certificates (therefore, it is sometimes referred to as a \"Certificate Update\" operation). An update is a replacement certificate containing either a new subject public key or the current subject public key (although the latter practice may not be appropriate for some environments).",
      "ja": "鍵の更新要求の場合CertReqMessages構文が使用されています。典型的には、SubjectPublicKeyInfoで、鍵ID、および有効性は各キーを更新するために供給することができるテンプレートのフィールドがあります。このメッセージは、既存の更新を要求するために使用されることが意図されている（非失効および非期限切れ）証明書は（したがって、それは時々「証明書更新」動作と呼びます）。更新は、新しい対象の公開鍵、または現在のサブジェクト公開鍵（後者の実施は、一部の環境に適切ではないかもしれないが）のいずれかを含有する置換証明書です。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertReqMessages syntax.",
      "ja": "CertReqMessagesの構文については、[CRMF]および付録Cを参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.6. Key Update Response Content",
      "section_title": true,
      "ja": "5.3.6。キー更新応答内容"
    },
    {
      "indent": 3,
      "text": "For key update responses, the CertRepMessage syntax is used. The response is identical to the initialization response.",
      "ja": "キー更新応答では、CertRepMessageの構文が使用されています。応答は、初期化応答と同じです。"
    },
    {
      "indent": 3,
      "text": "See Section 5.3.4 for CertRepMessage syntax.",
      "ja": "CertRepMessageの構文については、セクション5.3.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.7. Key Recovery Request Content",
      "section_title": true,
      "ja": "5.3.7。キー回復要求内容"
    },
    {
      "indent": 3,
      "text": "For key recovery requests the syntax used is identical to the initialization request CertReqMessages. Typically, SubjectPublicKeyInfo and KeyId are the template fields that may be used to supply a signature public key for which a certificate is required (see Appendix D profiles for further information).",
      "ja": "キー回復要求に使用する構文は、初期化要求CertReqMessagesと同じです。典型的には、SubjectPublicKeyInfoで及び鍵IDは（詳細については、付録Dプロファイルを参照）証明書が要求される署名公開鍵を供給するために使用することができるテンプレートフィールドです。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertReqMessages syntax. Note that if a key history is required, the requester must supply a Protocol Encryption Key control in the request message.",
      "ja": "CertReqMessagesの構文については、[CRMF]および付録Cを参照してください。キー履歴が必要な場合は、要求者は、要求メッセージ内のプロトコルの暗号化キーコントロールを供給しなければならないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.3.8. Key Recovery Response Content",
      "section_title": true,
      "ja": "5.3.8。キー回復の応答内容"
    },
    {
      "indent": 3,
      "text": "For key recovery responses, the following syntax is used. For some status values (e.g., waiting) none of the optional fields will be present.",
      "ja": "キー回復応答の場合は、次の構文が使用されています。一部のステータス値のため（例えば、待機）オプションフィールドのいずれも存在しないであろう。"
    },
    {
      "indent": 4,
      "text": "KeyRecRepContent ::= SEQUENCE {\n    status          PKIStatusInfo,\n    newSigCert  [0] Certificate                   OPTIONAL,\n    caCerts     [1] SEQUENCE SIZE (1..MAX) OF\n                                 Certificate      OPTIONAL,\n    keyPairHist [2] SEQUENCE SIZE (1..MAX) OF\n                                 CertifiedKeyPair OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.3.9. Revocation Request Content",
      "section_title": true,
      "ja": "5.3.9。失効要求内容"
    },
    {
      "indent": 3,
      "text": "When requesting revocation of a certificate (or several certificates), the following data structure is used. The name of the requester is present in the PKIHeader structure.",
      "ja": "証明書（またはいくつかの証明書）の失効を要求するとき、次のデータ構造が使用されています。依頼者の名前がPKIHeader構造中に存在しています。"
    },
    {
      "indent": 4,
      "text": "RevReqContent ::= SEQUENCE OF RevDetails",
      "raw": true
    },
    {
      "indent": 4,
      "text": "RevDetails ::= SEQUENCE {\n    certDetails         CertTemplate,\n    crlEntryDetails     Extensions       OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.3.10. Revocation Response Content",
      "section_title": true,
      "ja": "5.3.10。失効応答内容"
    },
    {
      "indent": 3,
      "text": "The revocation response is the response to the above message. If produced, this is sent to the requester of the revocation. (A separate revocation announcement message MAY be sent to the subject of the certificate for which revocation was requested.)",
      "ja": "失効応答は、上記のメッセージに対する応答です。生成した場合、これは、失効の要求者に送信されます。 （別失効通知メッセージが失効要求された証明書のサブジェクトに送ってもよいです。）"
    },
    {
      "indent": 5,
      "text": "RevRepContent ::= SEQUENCE {\n    status        SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,\n    revCerts  [0] SEQUENCE SIZE (1..MAX) OF CertId OPTIONAL,\n    crls      [1] SEQUENCE SIZE (1..MAX) OF CertificateList\n                  OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.3.11. Cross Certification Request Content",
      "section_title": true,
      "ja": "5.3.11。相互認証の要求内容"
    },
    {
      "indent": 3,
      "text": "Cross certification requests use the same syntax (CertReqMessages) as normal certification requests, with the restriction that the key pair MUST have been generated by the requesting CA and the private key MUST NOT be sent to the responding CA. This request MAY also be used by subordinate CAs to get their certificates signed by the parent CA.",
      "ja": "相互認証要求は鍵のペアが応答CAに送ってはいけません要求CAと秘密鍵によって生成されていなければならない制限で、通常の認証要求と同じ構文（CertReqMessages）を使用しますこの要求は、その証明書が親CAによって署名を取得するために下位CAで使用することもできます"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertReqMessages syntax.",
      "ja": "CertReqMessagesの構文については、[CRMF]および付録Cを参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.12. Cross Certification Response Content",
      "section_title": true,
      "ja": "5.3.12。相互認証の応答内容"
    },
    {
      "indent": 3,
      "text": "Cross certification responses use the same syntax (CertRepMessage) as normal certification responses, with the restriction that no encrypted private key can be sent.",
      "ja": "相互認証応答には暗号化された秘密鍵が送信されないことを制限して、通常の認証応答と同じ構文（CertRepMessage）を使用します。"
    },
    {
      "indent": 3,
      "text": "See Section 5.3.4 for CertRepMessage syntax.",
      "ja": "CertRepMessageの構文については、セクション5.3.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.13. CA Key Update Announcement Content",
      "section_title": true,
      "ja": "5.3.13。 CAキーの更新アナウンスコンテンツ"
    },
    {
      "indent": 3,
      "text": "When a CA updates its own key pair, the following data structure MAY be used to announce this event.",
      "ja": "CAは、自身の鍵ペアを更新すると、次のようなデータ構造は、このイベントを発表するために使用されるかもしれません。"
    },
    {
      "indent": 4,
      "text": "CAKeyUpdAnnContent ::= SEQUENCE {\n   oldWithNew         Certificate,\n   newWithOld         Certificate,\n   newWithNew         Certificate\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.3.14. Certificate Announcement",
      "section_title": true,
      "ja": "5.3.14。証明書のお知らせ"
    },
    {
      "indent": 3,
      "text": "This structure MAY be used to announce the existence of certificates.",
      "ja": "この構造は、証明書の存在を発表するために使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Note that this message is intended to be used for those cases (if any) where there is no pre-existing method for publication of certificates; it is not intended to be used where, for example, X.500 is the method for publication of certificates.",
      "ja": "証明書の公開のための既存の方法が存在しない場合、このメッセージは、（もしあれば）そのような場合に使用されることが意図されていることに注意してください。たとえば、X.500証明書の公開のための方法であり、使用されるものではありません。"
    },
    {
      "indent": 8,
      "text": "CertAnnContent ::= Certificate",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.3.15. Revocation Announcement",
      "section_title": true,
      "ja": "5.3.15。失効お知らせ"
    },
    {
      "indent": 3,
      "text": "When a CA has revoked, or is about to revoke, a particular certificate, it MAY issue an announcement of this (possibly upcoming) event.",
      "ja": "CAは、特定の証明書を失効し、または取り消すしようとしているときは、この（おそらく今後の）イベントの告知を発行することができます。"
    },
    {
      "indent": 8,
      "text": "RevAnnContent ::= SEQUENCE {\n    status              PKIStatus,\n    certId              CertId,\n    willBeRevokedAt     GeneralizedTime,\n    badSinceDate        GeneralizedTime,\n    crlDetails          Extensions  OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A CA MAY use such an announcement to warn (or notify) a subject that its certificate is about to be (or has been) revoked. This would typically be used where the request for revocation did not come from the subject concerned.",
      "ja": "CAは、証明書がされようとしている（またはされている）失効被験者に警告（または通知）するためにそのようなアナウンスを使用するかもしれません。失効の要求が懸念対象から来ていなかったところでは、一般的に使用されます。"
    },
    {
      "indent": 3,
      "text": "The willBeRevokedAt field contains the time at which a new entry will be added to the relevant CRLs.",
      "ja": "willBeRevokedAtフィールドには、新しいエントリが、関連のCRLに追加する時刻が含まれています。"
    },
    {
      "indent": 0,
      "text": "5.3.16. CRL Announcement",
      "section_title": true,
      "ja": "5.3.16。 CRLのお知らせ"
    },
    {
      "indent": 3,
      "text": "When a CA issues a new CRL (or set of CRLs) the following data structure MAY be used to announce this event.",
      "ja": "CAは新しいCRL（またはCRLのセット）を発行すると次のようなデータ構造、このイベントを発表するために使用されるかもしれません。"
    },
    {
      "indent": 8,
      "text": "CRLAnnContent ::= SEQUENCE OF CertificateList",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.3.17. PKI Confirmation Content",
      "section_title": true,
      "ja": "5.3.17。 PKI確認コンテンツ"
    },
    {
      "indent": 3,
      "text": "This data structure is used in the protocol exchange as the final PKIMessage. Its content is the same in all cases -- actually there is no content since the PKIHeader carries all the required information.",
      "ja": "このデータ構造は、最終PKIMessageなどのプロトコル交換に使用されます。その内容は、すべての場合に同じである - 実際にPKIHeaderは、すべての必要な情報を運ぶので、何のコンテンツがありません。"
    },
    {
      "indent": 8,
      "text": "PKIConfirmContent ::= NULL",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Use of this message for certificate confirmation is NOT RECOMMENDED; certConf SHOULD be used instead. Upon receiving a PKIConfirm for a certificate response, the recipient MAY treat it as a certConf with all certificates being accepted.",
      "ja": "証明書の確認のため、このメッセージの使用は推奨されていません。 certConfを代わりに使用してください。証明書応答のためのPKIConfirmを受信すると、受信者が受け入れられているすべての証明書とcertConfとしてそれを扱うかもしれ。"
    },
    {
      "indent": 0,
      "text": "5.3.18. Certificate Confirmation Content",
      "section_title": true,
      "ja": "5.3.18。証明書の確認内容"
    },
    {
      "indent": 3,
      "text": "This data structure is used by the client to send a confirmation to the CA/RA to accept or reject certificates.",
      "ja": "このデータ構造は、証明書を受け入れるか拒否するCA / RAに確認を送信するためにクライアントによって使用されます。"
    },
    {
      "indent": 9,
      "text": "CertConfirmContent ::= SEQUENCE OF CertStatus",
      "raw": true
    },
    {
      "indent": 9,
      "text": "CertStatus ::= SEQUENCE {\n   certHash    OCTET STRING,\n   certReqId   INTEGER,\n   statusInfo  PKIStatusInfo OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For any particular CertStatus, omission of the statusInfo field indicates ACCEPTANCE of the specified certificate. Alternatively, explicit status details (with respect to acceptance or rejection) MAY be provided in the statusInfo field, perhaps for auditing purposes at the CA/RA.",
      "ja": "任意の特定のにCertStatusため、statusInfoフィールドの省略は、指定された証明書の受け入れを示しています。あるいは、（受諾または拒否に対して）明示的なステータスの詳細は、CA / RAに監査目的のために、おそらく、statusInfoフィールドに提供されてもよいです。"
    },
    {
      "indent": 3,
      "text": "Within CertConfirmContent, omission of a CertStatus structure corresponding to a certificate supplied in the previous response message indicates REJECTION of the certificate. Thus, an empty CertConfirmContent (a zero-length SEQUENCE) MAY be used to indicate rejection of all supplied certificates. See Section 5.2.8, item (2), for a discussion of the certHash field with respect to proof-of-possession.",
      "ja": "CertConfirmContent内、前回応答メッセージで提供証明書に対応するにCertStatus構造の省略は、証明書の拒絶反応を示しています。したがって、空CertConfirmContent（長さゼロのシーケンス）は、すべての供給証明書の拒絶を示すために使用され得ます。プルーフ・オブ・所持に対してCERTHASHフィールドの説明については、セクション5.2.8、項目（2）を参照されたいです。"
    },
    {
      "indent": 0,
      "text": "5.3.19. PKI General Message Content",
      "section_title": true,
      "ja": "5.3.19。 PKI一般的なメッセージの内容"
    },
    {
      "indent": 5,
      "text": "InfoTypeAndValue ::= SEQUENCE {\n    infoType               OBJECT IDENTIFIER,\n    infoValue              ANY DEFINED BY infoType  OPTIONAL\n}\n-- where {id-it} = {id-pkix 4} = {1 3 6 1 5 5 7 4}\nGenMsgContent ::= SEQUENCE OF InfoTypeAndValue",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.3.19.1. CA Protocol Encryption Certificate",
      "section_title": true,
      "ja": "5.3.19.1。 CAプロトコルの暗号化証明書"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the EE to get a certificate from the CA to use to protect sensitive information during the protocol.",
      "ja": "これは、プロトコル間の機密情報を保護するために使用するCAから証明書を取得するためにEEで使用されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "GenMsg: {id-it 1}, < absent > GenRep: {id-it 1}, Certificate | < absent >",
      "ja": "GenMsg：{ID-その1}、<不在> GenRep：{ID-その1}、証明書| <不在>"
    },
    {
      "indent": 3,
      "text": "EEs MUST ensure that the correct certificate is used for this purpose.",
      "ja": "EEのは、正しい証明書は、この目的のために使用されていることを確認しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.19.2. Signing Key Pair Types",
      "section_title": true,
      "ja": "5.3.19.2。署名鍵ペアの種類"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the EE to get the list of signature algorithms (e.g., RSA, DSA) whose subject public key values the CA is willing to certify. Note that for the purposes of this exchange, rsaEncryption and rsaWithSHA1, for example, are considered to be equivalent; the question being asked is, \"Is the CA willing to certify an RSA public key?\"",
      "ja": "これは、対象の公開鍵値CAが証明する意思がある署名アルゴリズム（例えば、RSA、DSA）のリストを取得するためにEEによって使用されてもよいです。この交換の目的のためになお、rsaEncryptionとrsaWithSHA1、例えば、等価であると考えられています。頼まれての質問は、「RSA公開鍵を証明するために喜んCAですか？」され"
    },
    {
      "indent": 6,
      "text": "GenMsg: {id-it 2}, < absent > GenRep: {id-it 2}, SEQUENCE SIZE (1..MAX) OF AlgorithmIdentifier",
      "ja": "GenMsg：{ID-IT 2}、<不在> GenRep：{ID-IT 2}、のAlgorithmIdentifierのシーケンスSIZE（1..MAX）"
    },
    {
      "indent": 0,
      "text": "5.3.19.3. Encryption/Key Agreement Key Pair Types",
      "section_title": true,
      "ja": "5.3.19.3。暗号化/鍵合意鍵ペアの種類"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get the list of encryption/key agreement algorithms whose subject public key values the CA is willing to certify.",
      "ja": "これは、サブジェクトの公開鍵値CAが証明していく所存です暗号化/鍵合意アルゴリズムのリストを取得するために、クライアントによって使用されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "GenMsg: {id-it 3}, < absent > GenRep: {id-it 3}, SEQUENCE SIZE (1..MAX) OF AlgorithmIdentifier",
      "ja": "GenMsg：{ID-IT 3}、<不在> GenRep：{ID-IT 3}、のAlgorithmIdentifierのシーケンスSIZE（1..MAX）"
    },
    {
      "indent": 0,
      "text": "5.3.19.4. Preferred Symmetric Algorithm",
      "section_title": true,
      "ja": "5.3.19.4。優先対称アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get the CA-preferred symmetric encryption algorithm for any confidential information that needs to be exchanged between the EE and the CA (for example, if the EE wants to send its private decryption key to the CA for archival purposes).",
      "ja": "EEは、アーカイブのためにCAにその秘密復号鍵を送信したい場合、これは、例えばEEとCA（間で交換される必要があるすべての機密情報のためのCA-優先対称暗号化アルゴリズムを取得するために、クライアントによって使用されるかもしれ目的）。"
    },
    {
      "indent": 6,
      "text": "GenMsg: {id-it 4}, < absent > GenRep: {id-it 4}, AlgorithmIdentifier",
      "ja": "GenMsg：{ID-それ4}、<不在> GenRep：{ID-それ4}、のAlgorithmIdentifier"
    },
    {
      "indent": 0,
      "text": "5.3.19.5. Updated CA Key Pair",
      "section_title": true,
      "ja": "5.3.19.5。更新されたCAキー・ペア"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the CA to announce a CA key update event.",
      "ja": "これは、CAの鍵更新イベントを発表するCAによって使用されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "GenMsg: {id-it 5}, CAKeyUpdAnnContent",
      "ja": "GenMsg：{ID-それ5}、CAKeyUpdAnnContent"
    },
    {
      "indent": 0,
      "text": "5.3.19.6. CRL",
      "section_title": true,
      "ja": "5.3.19.6。 CRL"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get a copy of the latest CRL.",
      "ja": "これは、最新のCRLのコピーを取得するためにクライアントによって使用されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "GenMsg: {id-it 6}, < absent > GenRep: {id-it 6}, CertificateList",
      "ja": "GenMsg：{ID-それ6}、<不在> GenRep：{ID-それ6}、CertificateListの"
    },
    {
      "indent": 0,
      "text": "5.3.19.7. Unsupported Object Identifiers",
      "section_title": true,
      "ja": "5.3.19.7。サポートされていないオブジェクト識別子"
    },
    {
      "indent": 3,
      "text": "This is used by the server to return a list of object identifiers that it does not recognize or support from the list submitted by the client.",
      "ja": "これは、クライアントが提出したリストから認識またはサポートしないオブジェクト識別子のリストを返すためにサーバーによって使用されます。"
    },
    {
      "indent": 6,
      "text": "GenRep: {id-it 7}, SEQUENCE SIZE (1..MAX) OF OBJECT IDENTIFIER",
      "ja": "GenRep：オブジェクト識別子{ID-それ7}、SEQUENCEサイズ（1..MAX）"
    },
    {
      "indent": 0,
      "text": "5.3.19.8. Key Pair Parameters",
      "section_title": true,
      "ja": "5.3.19.8。鍵ペアのパラメータ"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the EE to request the domain parameters to use for generating the key pair for certain public-key algorithms. It can be used, for example, to request the appropriate P, Q, and G to generate the DH/DSA key, or to request a set of well-known elliptic curves.",
      "ja": "これは、特定の公開鍵アルゴリズムの鍵ペアを生成するために使用するドメインパラメータを要求するためにEEによって使用されてもよいです。 DH / DSA鍵を生成するために、または周知の楕円曲線のセットを要求するために、適切なP、Q、及びGを要求するために、例えば、使用することができます。"
    },
    {
      "indent": 6,
      "text": "GenMsg: {id-it 10}, OBJECT IDENTIFIER -- (Algorithm object-id) GenRep: {id-it 11}, AlgorithmIdentifier | < absent >",
      "ja": "GenMsg：{ID-IT 10}、オブジェクト識別子 - （アルゴリズムオブジェクト-ID）GenRep：{ID-IT 11}、のAlgorithmIdentifier | <不在>"
    },
    {
      "indent": 3,
      "text": "An absent infoValue in the GenRep indicates that the algorithm specified in GenMsg is not supported.",
      "ja": "GenRepには存在しないinfoValueはGenMsgで指定されたアルゴリズムがサポートされていないことを示しています。"
    },
    {
      "indent": 3,
      "text": "EEs MUST ensure that the parameters are acceptable to it and that the GenRep message is authenticated (to avoid substitution attacks).",
      "ja": "EEのは、パラメータがそれに許容可能であることを確認しなければならないとGenRepメッセージが認証されていること（代替攻撃を避けるため）。"
    },
    {
      "indent": 0,
      "text": "5.3.19.9. Revocation Passphrase",
      "section_title": true,
      "ja": "5.3.19.9。失効パスフレーズ"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the EE to send a passphrase to a CA/RA for the purpose of authenticating a later revocation request (in the case that the appropriate signing private key is no longer available to authenticate the request). See Appendix B for further details on the use of this mechanism.",
      "ja": "これは、（適切な署名秘密鍵が要求を認証するために利用できるもはやである場合には）、後に失効要求を認証する目的のためにCA / RAにパスフレーズを送信するためにEEで使用されるかもしれません。このメカニズムの使用に関する詳細については、付録Bを参照してください。"
    },
    {
      "indent": 6,
      "text": "GenMsg: {id-it 12}, EncryptedValue GenRep: {id-it 12}, < absent >",
      "ja": "GenMsg：{ID-IT 12}、EncryptedValue GenRep：{ID-IT 12}、<不在>"
    },
    {
      "indent": 0,
      "text": "5.3.19.10. ImplicitConfirm",
      "section_title": true,
      "ja": "5.3.19.10。 ImplicitConfirm"
    },
    {
      "indent": 3,
      "text": "See Section 5.1.1.1 for the definition and use of {id-it 13}.",
      "ja": "{ID-IT 13}の定義および使用のために、セクション5.1.1.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.19.11. ConfirmWaitTime",
      "section_title": true,
      "ja": "5.3.19.11。 ConfirmWaitTime"
    },
    {
      "indent": 3,
      "text": "See Section 5.1.1.2 for the definition and use of {id-it 14}.",
      "ja": "{ID-IT 14}の定義および使用のために、セクション5.1.1.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.19.12 Original PKIMessage",
      "section_title": true,
      "ja": "5.3.19.12オリジナルPKIMessage"
    },
    {
      "indent": 3,
      "text": "See Section 5.1.3 for the definition and use of {id-it 15}.",
      "ja": "{ID-IT 15}の定義および使用のために、セクション5.1.3を参照。"
    },
    {
      "indent": 0,
      "text": "5.3.19.13. Supported Language Tags",
      "section_title": true,
      "ja": "5.3.19.13。サポートされている言語タグ"
    },
    {
      "indent": 3,
      "text": "This MAY be used to determine the appropriate language tag to use in subsequent messages. The sender sends its list of supported languages (in order, most preferred to least); the receiver returns the one it wishes to use. (Note: each UTF8String MUST include a language tag.) If none of the offered tags are supported, an error MUST be returned.",
      "ja": "これは、後続のメッセージに使用する適切な言語タグを決定するために使用されるかもしれません。送信者がサポートされている言語のリストを（順番に、最も以上に好ま）を送ります。受信機は、それが使用したいものを返します。 （注：各UTF8Stringを言語タグを含まなければなりません。）提供されるタグのいずれもサポートされていない場合、エラーが返されなければなりません。"
    },
    {
      "indent": 6,
      "text": "GenMsg: {id-it 16}, SEQUENCE SIZE (1..MAX) OF UTF8String GenRep: {id-it 16}, SEQUENCE SIZE (1) OF UTF8String",
      "ja": "GenMsg：{ID-IT 16}、UTF8StringをGenRepのシーケンスSIZE（1..MAX）：{ID-IT 16}、UTF8Stringを一連のサイズ（1）"
    },
    {
      "indent": 0,
      "text": "5.3.20. PKI General Response Content",
      "section_title": true,
      "ja": "5.3.20。 PKI一般的な応答内容"
    },
    {
      "indent": 6,
      "text": "GenRepContent ::= SEQUENCE OF InfoTypeAndValue",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Examples of GenReps that MAY be supported include those listed in the subsections of Section 5.3.19.",
      "ja": "サポートされるかもしれGenRepsの例としては、セクション5.3.19のサブセクションに記載されたものを含みます。"
    },
    {
      "indent": 0,
      "text": "5.3.21. Error Message Content",
      "section_title": true,
      "ja": "5.3.21。エラーメッセージの内容"
    },
    {
      "indent": 3,
      "text": "This data structure MAY be used by EE, CA, or RA to convey error info.",
      "ja": "このデータ構造は、エラー情報を伝えるためにEE、CA、またはRAによって使用されるかもしれません。"
    },
    {
      "indent": 4,
      "text": "ErrorMsgContent ::= SEQUENCE {\n    pKIStatusInfo          PKIStatusInfo,\n    errorCode              INTEGER           OPTIONAL,\n    errorDetails           PKIFreeText       OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This message MAY be generated at any time during a PKI transaction. If the client sends this request, the server MUST respond with a PKIConfirm response, or another ErrorMsg if any part of the header is not valid. Both sides MUST treat this message as the end of the transaction (if a transaction is in progress).",
      "ja": "このメッセージは、PKIのトランザクション中にいつでも生成することができます。クライアントがこの要求を送信する場合、ヘッダのどの部分が有効でない場合、サーバはPKIConfirm応答、または他のERRORMSGで応じなければなりません。 （トランザクションが進行中の場合）双方は、トランザクションの終わりにこのメッセージを処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If protection is desired on the message, the client MUST protect it using the same technique (i.e., signature or MAC) as the starting message of the transaction. The CA MUST always sign it with a signature key.",
      "ja": "保護がメッセージに所望される場合、クライアントは、トランザクションの開始メッセージと同様の手法（すなわち、署名またはMAC）を使用して保護しなければなりません。 CAは、常に署名鍵とそれに署名しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.22. Polling Request and Response",
      "section_title": true,
      "ja": "5.3.22。ポーリング要求と応答"
    },
    {
      "indent": 3,
      "text": "This pair of messages is intended to handle scenarios in which the client needs to poll the server in order to determine the status of an outstanding ir, cr, or kur transaction (i.e., when the \"waiting\" PKIStatus has been received).",
      "ja": "メッセージのこのペアは、クライアントが優れたIR、CR、またはKUR取引（すなわち、PKIStatusが受信されている「待機中」）の状態を判断するためにサーバをポーリングする必要のあるシナリオを処理することを意図しています。"
    },
    {
      "indent": 4,
      "text": "PollReqContent ::= SEQUENCE OF SEQUENCE {\n    certReqId    INTEGER }",
      "raw": true
    },
    {
      "indent": 4,
      "text": "PollRepContent ::= SEQUENCE OF SEQUENCE {\n    certReqId    INTEGER,\n    checkAfter   INTEGER,  -- time in seconds\n    reason       PKIFreeText OPTIONAL }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following clauses describe when polling messages are used, and how they are used. It is assumed that multiple certConf messages can be sent during transactions. There will be one sent in response to each ip, cp, or kup that contains a CertStatus for an issued certificate.",
      "ja": "ポーリングメッセージが使用され、そしてそれらがどのように使用されている場合は、次の句は、説明します。複数のcertConfメッセージがトランザクション中に送信することができるものとします。発行された証明書のためにCertStatusを含む各IP、CP、またはKUPに応答して送信された1があります。"
    },
    {
      "indent": 3,
      "text": "1. In response to an ip, cp, or kup message, an EE will send a certConf for all issued certificates and, following the ack, a pollReq for all pending certificates.",
      "ja": "1. IP、CP、またはKUPメッセージに応答して、EEは、ACK、すべての保留中の証明書のpollReq以下のすべての発行された証明書と、ためcertConfをお送りします。"
    },
    {
      "indent": 3,
      "text": "2. In response to a pollReq, a CA/RA will return an ip, cp, or kup if one or more of the pending certificates is ready; otherwise, it will return a pollRep.",
      "ja": "2. pollReqに応じて、CA / RAは、IPを返す、CP、または保留中の証明書の一つ以上の準備ができている場合KUPます。それ以外の場合は、pollRepを返します。"
    },
    {
      "indent": 3,
      "text": "3. If the EE receives a pollRep, it will wait for at least as long as the checkAfter value before sending another pollReq.",
      "ja": "3. EEはpollRepを受信した場合、それは別のpollReqを送信する前に、少なくとも限りcheckAfter値として待ちます。"
    },
    {
      "indent": 3,
      "text": "4. If an ip, cp, or kup is received in response to a pollReq, then it will be treated in the same way as the initial response.",
      "ja": "4. IP、CP、またはKUPはpollReqに応答して受信された場合、それは最初の応答と同じように扱われます。"
    },
    {
      "indent": 4,
      "text": "                           START\n                             |\n                             v\n                          Send ir\n                             | ip\n                             v\n                        Check status\n                        of returned <------------------------+\n                           certs                             |\n                             |                               |\n   +------------------------>|<------------------+           |\n   |                         |                   |           |\n   |        (issued)         v       (waiting)   |           |\n Add to <----------- Check CertResponse ------> Add to       |\nconf list           for each certificate      pending list   |\n                             /                               |\n                            /                                |\n               (conf list) /     (empty conf list)           |\n                          /                     ip           |\n                         /                 +----------------+\n  (empty pending list)  /                  |    pRep\n    END <---- Send certConf         Send pReq------------>Wait\n                     |                 ^   ^               |\n                     |                 |   |               |\n                     +-----------------+   +---------------+\n                        (pending list)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the following exchange, the end entity is enrolling for two certificates in one request.",
      "ja": "次の交換に、エンドエンティティは、一つのリクエストに2つの証明書のために登録されています。"
    },
    {
      "indent": 4,
      "text": "Step  End Entity                       PKI\n--------------------------------------------------------------------\n1   Format ir\n2                    -> ir      ->\n3                                    Handle ir\n4                                    Manual intervention is\n                                     required for both certs.\n5                    <- ip      <-\n6   Process ip\n7   Format pReq\n8                    -> pReq     ->\n9                                    Check status of cert requests\n10                                   Certificates not ready\n11                                   Format pRep\n12                   <- pRep     <-\n13  Wait\n14  Format pReq\n15                   -> pReq     ->\n16                                   Check status of cert requests\n17                                   One certificate is ready\n18                                   Format ip\n19                   <- ip       <-\n20  Handle ip\n21  Format certConf\n22                   -> certConf ->\n23                                   Handle certConf\n24                                   Format ack\n25                   <- pkiConf   <-\n26  Format pReq\n27                   -> pReq     ->\n28                                   Check status of certificate\n29                                   Certificate is ready\n30                                   Format ip\n31                   <- ip       <-\n31  Handle ip\n32  Format certConf\n33                   -> certConf ->\n34                                   Handle certConf\n35                                   Format ack\n36                   <- pkiConf  <-",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6. Mandatory PKI Management Functions",
      "section_title": true,
      "ja": "6.必須PKI管理機能"
    },
    {
      "indent": 3,
      "text": "Some of the PKI management functions outlined in Section 3.1 above are described in this section.",
      "ja": "上記セクション3.1に概説PKI管理機能のいくつかはこのセクションで説明されています。"
    },
    {
      "indent": 3,
      "text": "This section deals with functions that are \"mandatory\" in the sense that all end entity and CA/RA implementations MUST be able to provide the functionality described. This part is effectively the profile of the PKI management functionality that MUST be supported. Note, however, that the management functions described in this section do not need to be accomplished using the PKI messages defined in Section 5 if alternate means are suitable for a given environment (see Appendix D for profiles of the PKIMessages that MUST be supported).",
      "ja": "すべてのエンドエンティティとCA / RAの実装が記載された機能を提供できなければならないという意味で「必須」な機能を持つこのセクションでは扱っています。この部分は、効果的にサポートしなければならないPKI管理機能のプロファイルです。 （サポートしなければならないPKIMessagesのプロファイルについては、付録Dを参照）、代替手段は、特定の環境に適している場合は、このセクションで説明する管理機能は、セクション5で定義されたPKIメッセージを使用して達成する必要がないこと、しかし、注意してください。"
    },
    {
      "indent": 0,
      "text": "6.1. Root CA Initialization",
      "section_title": true,
      "ja": "6.1。ルートCAの初期化"
    },
    {
      "indent": 3,
      "text": "[See Section 3.1.1.2 for this document's definition of \"root CA\".]",
      "ja": "[「ルートCA」のこのドキュメントの定義については、セクション3.1.1.2を参照してください。]"
    },
    {
      "indent": 3,
      "text": "A newly created root CA must produce a \"self-certificate\", which is a Certificate structure with the profile defined for the \"newWithNew\" certificate issued following a root CA key update.",
      "ja": "新しく作成されたルートCAは、ルートCA鍵の更新次発行の「newWithNew」証明書用に定義されたプロファイルを使用して証明書の構造である、「自己証明書」を生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In order to make the CA's self certificate useful to end entities that do not acquire the self certificate via \"out-of-band\" means, the CA must also produce a fingerprint for its certificate. End entities that acquire this fingerprint securely via some \"out-of-band\" means can then verify the CA's self-certificate and, hence, the other attributes contained therein.",
      "ja": "「アウトオブバンド」手段を介して自己証明書を取得していないエンドエンティティにCAの自己証明書を有用にするために、CAはまた、その証明書のフィンガープリントを生成しなければなりません。いくつかの「アウトオブバンド」手段を介して安全にこのフィンガープリントを取得し、エンドエンティティは、その後、それ故に、そこに含まれる他の属性をCAの自己証明書を検証することができます。"
    },
    {
      "indent": 3,
      "text": "The data structure used to carry the fingerprint is the OOBCertHash.",
      "ja": "指紋を運ぶために使用されるデータ構造はOOBCertHashです。"
    },
    {
      "indent": 0,
      "text": "6.2. Root CA Key Update",
      "section_title": true,
      "ja": "6.2。ルートCAキー更新"
    },
    {
      "indent": 3,
      "text": "CA keys (as all other keys) have a finite lifetime and will have to be updated on a periodic basis. The certificates NewWithNew, NewWithOld, and OldWithNew (see Section 4.4.1) MAY be issued by the CA to aid existing end entities who hold the current self-signed CA certificate (OldWithOld) to transition securely to the new self-signed CA certificate (NewWithNew), and to aid new end entities who will hold NewWithNew to acquire OldWithOld securely for verification of existing data.",
      "ja": "（他のすべてのキーなど）CAキーは有限の寿命を持っており、定期的に更新する必要があります。証明書NewWithNew、NewWithOld、およびOldWithNew（セクション4.4.1を参照）の新しい自己署名CA証明書を安全に移行するために、現在の自己署名CA証明書（OldWithOld）を保持する既存のエンドエンティティを支援するためにCAによって発行することができます（ NewWithNew）、および既存のデータの検証のためにしっかりOldWithOld取得するNewWithNewを保持する新しいエンドエンティティを支援します。"
    },
    {
      "indent": 0,
      "text": "6.3. Subordinate CA Initialization",
      "section_title": true,
      "ja": "6.3。下位CAの初期化"
    },
    {
      "indent": 3,
      "text": "[See Section 3.1.1.2 for this document's definition of \"subordinate CA\".]",
      "ja": "[「下位CA」のこのドキュメントの定義については、セクション3.1.1.2を参照してください。]"
    },
    {
      "indent": 3,
      "text": "From the perspective of PKI management protocols, the initialization of a subordinate CA is the same as the initialization of an end entity. The only difference is that the subordinate CA must also produce an initial revocation list.",
      "ja": "PKI管理プロトコルの観点から、下位CAの初期化は、エンドエンティティの初期設定と同じです。唯一の違いは、下位のCAはまた、最初の失効リストを生成しなければならないということです。"
    },
    {
      "indent": 0,
      "text": "6.4. CRL production",
      "section_title": true,
      "ja": "6.4。 CRLの生産"
    },
    {
      "indent": 3,
      "text": "Before issuing any certificates, a newly established CA (which issues CRLs) must produce \"empty\" versions of each CRL which are to be periodically produced.",
      "ja": "すべての証明書を発行する前に、（CRLを発行）新しく設立されたCAは、定期的に生成される各CRLの「空」のバージョンを生成しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.5. PKI Information Request",
      "section_title": true,
      "ja": "6.5。 PKI情報リクエスト"
    },
    {
      "indent": 3,
      "text": "When a PKI entity (CA, RA, or EE) wishes to acquire information about the current status of a CA, it MAY send that CA a request for such information.",
      "ja": "PKIエンティティ（CA、RA、またはEE）はCAの現在のステータスに関する情報を取得したい場合、このような情報のためにCAその要求を送信することができます。"
    },
    {
      "indent": 3,
      "text": "The CA MUST respond to the request by providing (at least) all of the information requested by the requester. If some of the information cannot be provided, then an error must be conveyed to the requester.",
      "ja": "CAは、（少なくとも）依頼者から要求された情報のすべてを提供することにより、要求に応じなければなりません。情報の一部を提供することができない場合は、エラーが要求者に伝えなければなりません。"
    },
    {
      "indent": 3,
      "text": "If PKIMessages are used to request and supply this PKI information, then the request MUST be the GenMsg message, the response MUST be the GenRep message, and the error MUST be the Error message. These messages are protected using a MAC based on shared secret information (i.e., PasswordBasedMAC) or using any other authenticated means (if the end entity has an existing certificate).",
      "ja": "PKIMessagesこのPKI情報要求と供給するために使用される場合、要求はGenMsgメッセージでなければなりません、応答はGenRepメッセージでなければなりません、エラーがエラーメッセージでなければなりません。これらのメッセージは、共有秘密情報に基づいてMACを使用して（すなわち、PasswordBasedMAC）または（エンドエンティティは、既存の証明書を持っている場合）、他の認証手段を使用して保護されています。"
    },
    {
      "indent": 0,
      "text": "6.6. Cross Certification",
      "section_title": true,
      "ja": "6.6。相互認証"
    },
    {
      "indent": 3,
      "text": "The requester CA is the CA that will become the subject of the cross-certificate; the responder CA will become the issuer of the cross-certificate.",
      "ja": "リクエスタCAは、相互認証の対象となるであろうCAです。レスポンダーCAは、相互認証の発行者となります。"
    },
    {
      "indent": 3,
      "text": "The requester CA must be \"up and running\" before initiating the cross-certification operation.",
      "ja": "依頼者CAは、相互認証作業を開始する前に「起動して実行」でなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.6.1. One-Way Request-Response Scheme:",
      "section_title": true,
      "ja": "6.6.1。一方向のリクエスト - レスポンススキーム："
    },
    {
      "indent": 3,
      "text": "The cross-certification scheme is essentially a one way operation; that is, when successful, this operation results in the creation of one new cross-certificate. If the requirement is that cross-certificates be created in \"both directions\", then each CA, in turn, must initiate a cross-certification operation (or use another scheme).",
      "ja": "相互認証方式は、本質的に一方向の動作です。つまり、とき1新しいクロス証明書の作成に成功し、この操作は結果。要件は、相互認証が「両方向」で作成されることがある場合、各CAは、次に、相互認証動作を開始（または別のスキームを使用）しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This scheme is suitable where the two CAs in question can already verify each other's signatures (they have some common points of trust) or where there is an out-of-band verification of the origin of the certification request.",
      "ja": "このスキームは、問題の2つのCAは、すでにお互いの署名を検証することができます（彼らは信頼のいくつかの共通点を持っている）、または証明書要求の起源のアウトオブバンドの検証がある場合には適切な場合です。"
    },
    {
      "indent": 3,
      "text": "Detailed Description:",
      "ja": "詳細な説明："
    },
    {
      "indent": 3,
      "text": "Cross certification is initiated at one CA known as the responder. The CA administrator for the responder identifies the CA it wants to cross certify and the responder CA equipment generates an authorization code. The responder CA administrator passes this authorization code by out-of-band means to the requester CA administrator. The requester CA administrator enters the authorization code at the requester CA in order to initiate the on-line exchange.",
      "ja": "相互認証は、レスポンダとして知られている1つのCAで開始されます。応答者のためのCAの管理者は、それが証明横断したいCAを識別し、応答CA機器は、認証コードを生成します。応答CA管理者は、要求元CA管理者に意味アウト・オブ・バンドによるこの認証コードを渡します。要求元CAの管理者は、オンライン交換を開始するために、リクエスタCAの認証コードを入力します。"
    },
    {
      "indent": 3,
      "text": "The authorization code is used for authentication and integrity purposes. This is done by generating a symmetric key based on the authorization code and using the symmetric key for generating Message Authentication Codes (MACs) on all messages exchanged. (Authentication may alternatively be done using signatures instead of MACs, if the CAs are able to retrieve and validate the required public keys by some means, such as an out-of-band hash comparison.)",
      "ja": "認証コードは、認証と完全性の目的のために使用されます。これは、認証コードに基づいて対称鍵を生成し、交換されるすべてのメッセージにメッセージ認証コード（MAC）を生成するための対称鍵を用いて行われます。 （CAは、このようなアウトオブバンドハッシュ比較のようないくつかの手段によって必要な公開鍵を取得し、検証することが可能である場合、認証は、代わりに、代わりにMACの署名を使用して行われてもよいです。）"
    },
    {
      "indent": 3,
      "text": "The requester CA initiates the exchange by generating a cross-certification request (ccr) with a fresh random number (requester random number). The requester CA then sends the ccr message to the responder CA. The fields in this message are protected from modification with a MAC based on the authorization code.",
      "ja": "リクエスタCAは、新鮮な乱数（リクエスタ乱数）との相互認証の要求（CCR）を生成することにより、交換を開始します。リクエスタCAは、レスポンダーCAにCCRメッセージを送信しますこのメッセージ内のフィールドは、認証コードに基づいてMACとの変更から保護されています。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the ccr message, the responder CA validates the message and the MAC, saves the requester random number, and generates its own random number (responder random number). It then generates (and archives, if desired) a new requester certificate that contains the requester CA public key and is signed with the responder CA signature private key. The responder CA responds with the cross certification response (ccp) message. The fields in this message are protected from modification with a MAC based on the authorization code.",
      "ja": "CCRメッセージを受信すると、CAは、メッセージおよびMACを検証応答者は、リクエスタ乱数を保存し、自身の乱数（レスポンダ乱数）を生成します。 （必要に応じて、およびアーカイブ）その後、リクエスタCAの公開鍵が含まれており、レスポンダCA署名秘密鍵で署名された新しい要求者証明書が生成されます。レスポンダCAは、相互認証応答（CCP）メッセージで応答します。このメッセージ内のフィールドは、認証コードに基づいてMACとの変更から保護されています。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the ccp message, the requester CA validates the message (including the received random numbers) and the MAC. The requester CA responds with the certConf message. The fields in this message are protected from modification with a MAC based on the authorization code. The requester CA MAY write the requester certificate to the Repository as an aid to later certificate path construction.",
      "ja": "CCPメッセージを受信すると、要求元CAは、（受信した乱数を含む）メッセージ及びMACを検証します。依頼者CAはcertConfメッセージで応答します。このメッセージ内のフィールドは、認証コードに基づいてMACとの変更から保護されています。依頼者CAは、後に証明書パス構築への支援としてリポジトリに依頼者証明書を書き込むことができます。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the certConf message, the responder CA validates the message and the MAC, and sends back an acknowledgement using the PKIConfirm message. It MAY also publish the requester certificate as an aid to later path construction.",
      "ja": "certConfメッセージを受信すると、レスポンダーCAは、メッセージとMACを検証し、PKIConfirmメッセージを使用して確認応答を送り返します。また、後にパス構築への支援として、依頼者の証明書を発行するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 3,
      "text": "1. The ccr message must contain a \"complete\" certification request; that is, all fields except the serial number (including, e.g., a BasicConstraints extension) must be specified by the requester CA.",
      "ja": "1. CCRメッセージは、「完全」の認証要求を含める必要があります。つまり、（BasicConstraints拡張機能などを含む）、シリアル番号を除くすべてのフィールドが要求元CAによって指定されなければなりません"
    },
    {
      "indent": 3,
      "text": "2. The ccp message SHOULD contain the verification certificate of the responder CA; if present, the requester CA must then verify this certificate (for example, via the \"out-of-band\" mechanism).",
      "ja": "2. CCPメッセージは、レスポンダCAの検証証明書を入れておく必要があります。存在する場合、リクエスタCAは、次に、（「アウトオブバンド」機構を介して、例えば）この証明書を検証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "(A simpler, non-interactive model of cross-certification may also be envisioned, in which the issuing CA acquires the subject CA's public key from some repository, verifies it via some out-of-band mechanism, and creates and publishes the cross-certificate without the subject CA's explicit involvement. This model may be perfectly legitimate for many environments, but since it does not require any protocol message exchanges, its detailed description is outside the scope of this specification.)",
      "ja": "（相互認証の単純な、非対話型モデルはまた、発行CAは、対象にいくつかのリポジトリからCAの公開鍵を取得する、想定することができる、いくつかのアウトオブバンドメカニズムを介してそれを検証し、そしてクロスを作成し、発行し被験者CAの明示的な関与なし証明書。このモデルは、多くの環境のために完全に合法的であってもよいが、それは任意のプロトコルメッセージ交換を必要としないので、その詳細な説明は、本明細書の範囲外です。）"
    },
    {
      "indent": 0,
      "text": "6.7. End Entity Initialization",
      "section_title": true,
      "ja": "6.7。エンド・エンティティの初期化"
    },
    {
      "indent": 3,
      "text": "As with CAs, end entities must be initialized. Initialization of end entities requires at least two steps:",
      "ja": "CAのと同じように、エンドエンティティは初期化する必要があります。エンドエンティティの初期化は、少なくとも2つの手順が必要です。"
    },
    {
      "indent": 3,
      "text": "o acquisition of PKI information",
      "ja": "PKI情報のO取得"
    },
    {
      "indent": 3,
      "text": "o out-of-band verification of one root-CA public key",
      "ja": "Oアウトオブバンド1ルートCAの公開鍵の検証"
    },
    {
      "indent": 3,
      "text": "(other possible steps include the retrieval of trust condition information and/or out-of-band verification of other CA public keys).",
      "ja": "（他の可能な手順は、信託条件情報の検索及び/又は他のCAの公開鍵の帯域外検証を含みます）。"
    },
    {
      "indent": 0,
      "text": "6.7.1. Acquisition of PKI Information",
      "section_title": true,
      "ja": "6.7.1。 PKI情報の取得"
    },
    {
      "indent": 3,
      "text": "The information REQUIRED is:",
      "ja": "必要な情報は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o the current root-CA public key",
      "ja": "現在のルートCAの公開鍵O"
    },
    {
      "indent": 3,
      "text": "o (if the certifying CA is not a root-CA) the certification path from the root CA to the certifying CA together with appropriate revocation lists",
      "ja": "証明CAのルートCAからO（証明CAがルートCAでない場合）、認証パス一緒に適切な失効リストと"
    },
    {
      "indent": 3,
      "text": "o the algorithms and algorithm parameters that the certifying CA supports for each relevant usage",
      "ja": "証明CAは、各関連の使用のためのサポートアルゴリズムとアルゴリズムパラメータO"
    },
    {
      "indent": 3,
      "text": "Additional information could be required (e.g., supported extensions or CA policy information) in order to produce a certification request that will be successful. However, for simplicity we do not mandate that the end entity acquires this information via the PKI messages. The end result is simply that some certification requests may fail (e.g., if the end entity wants to generate its own encryption key, but the CA doesn't allow that).",
      "ja": "追加情報は、成功する証明書要求を生成するために（例えば、拡張やCAポリシー情報をサポート）要求される可能性があります。しかし、簡単にするために、我々は、エンドエンティティがPKIメッセージを介してこの情報を取得することを強制しません。最終結果は（エンドエンティティは、独自の暗号化キーを生成したいと考えていますが、CAはそれを許可しない場合、例えば）いくつかの認証要求が失敗する可能性があることだけです。"
    },
    {
      "indent": 3,
      "text": "The required information MAY be acquired as described in Section 6.5.",
      "ja": "6.5節で説明したように必要な情報を取得することができます。"
    },
    {
      "indent": 0,
      "text": "6.7.2. Out-of-Band Verification of Root-CA Key",
      "section_title": true,
      "ja": "6.7.2。アウトオブバンドルート-CA鍵の検証"
    },
    {
      "indent": 3,
      "text": "An end entity must securely possess the public key of its root CA. One method to achieve this is to provide the end entity with the CA's self-certificate fingerprint via some secure \"out-of-band\" means. The end entity can then securely use the CA's self-certificate.",
      "ja": "エンドエンティティは、しっかりとそのルートCAの公開鍵を持っていなければなりませんこれを達成するための一つの方法は、いくつかの安全な「アウトオブバンド」手段を介してCAの自己証明書のフィンガープリントをエンドエンティティを提供することです。エンドエンティティは、しっかりとCAの自己証明書を使用することができます。"
    },
    {
      "indent": 3,
      "text": "See Section 6.1 for further details.",
      "ja": "詳細は、6.1節を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.8. Certificate Request",
      "section_title": true,
      "ja": "6.8。証明書要求"
    },
    {
      "indent": 3,
      "text": "An initialized end entity MAY request an additional certificate at any time (for any purpose). This request will be made using the certification request (cr) message. If the end entity already possesses a signing key pair (with a corresponding verification certificate), then this cr message will typically be protected by the entity's digital signature. The CA returns the new certificate (if the request is successful) in a CertRepMessage.",
      "ja": "初期化され、エンドエンティティは、（任意の目的のために）いつでも追加の証明書を要求することができます。この要求は、認証要求（CR）メッセージを使用して行われます。エンドエンティティが既に（対応する検証証明書を使用して）署名鍵ペアを所有している場合、このCRメッセージは、典型的には、エンティティのデジタル署名によって保護されます。 CertRepMessageに（要求が成功した場合）、CAは新しい証明書を返します。"
    },
    {
      "indent": 0,
      "text": "6.9. Key Update",
      "section_title": true,
      "ja": "6.9。キー更新"
    },
    {
      "indent": 3,
      "text": "When a key pair is due to expire, the relevant end entity MAY request a key update; that is, it MAY request that the CA issue a new certificate for a new key pair (or, in certain circumstances, a new certificate for the same key pair). The request is made using a key update request (kur) message (referred to, in some environments, as a \"Certificate Update\" operation). If the end entity already possesses a signing key pair (with a corresponding verification certificate), then this message will typically be protected by the entity's digital signature. The CA returns the new certificate (if the request is successful) in a key update response (kup) message, which is syntactically identical to a CertRepMessage.",
      "ja": "鍵ペアが期限切れになると、該当するエンドエンティティが鍵の更新を要求することができます。それはそれがCAの問題新しい鍵ペア（または、特定の状況では、同じ鍵ペアのための新しい証明書）のための新しい証明書を要求することができる、です。要求は鍵更新要求（KUR）メッセージ（「証明書更新」動作として、いくつかの環境では、と呼ばれる）を用いて行われます。エンドエンティティが既に（対応する検証証明書を使用して）署名鍵ペアを所有している場合、このメッセージは、典型的には、エンティティのデジタル署名によって保護されます。 CAが新しい証明書を返すCertRepMessageと構文的に同一である鍵更新応答（KUP）メッセージで（要求が成功した場合）。"
    },
    {
      "indent": 0,
      "text": "7. Version Negotiation",
      "section_title": true,
      "ja": "7.バージョンのネゴシエーション"
    },
    {
      "indent": 3,
      "text": "This section defines the version negotiation used to support older protocols between client and servers.",
      "ja": "このセクションでは、クライアントとサーバ間の古いプロトコルをサポートするために使用されるバージョン交渉を定義します。"
    },
    {
      "indent": 3,
      "text": "If a client knows the protocol version(s) supported by the server (e.g., from a previous PKIMessage exchange or via some out-of-band means), then it MUST send a PKIMessage with the highest version supported by both it and the server. If a client does not know what version(s) the server supports, then it MUST send a PKIMessage using the highest version it supports.",
      "ja": "クライアントは、サーバがサポートしているプロトコルバージョン（複数可）（例えば、アウト・オブ・バンドが意味前回PKIMessage交換からまたは一部を介した）を知っている場合、それはそれとサーバーの両方でサポートされている最も高いバージョンでPKIMessageを送らなければなりません。クライアントは、サーバーがサポートしているバージョン（複数可）を知らない場合、それはそれがサポートする最上位バージョンを使用してPKIMessageを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a server receives a message with a version that it supports, then the version of the response message MUST be the same as the received version. If a server receives a message with a version higher or lower than it supports, then it MUST send back an ErrorMsg with the unsupportedVersion bit set (in the failureInfo field of the pKIStatusInfo). If the received version is higher than the highest supported version, then the version in the error message MUST be the highest version the server supports; if the received version is lower than the lowest supported version then the version in the error message MUST be the lowest version the server supports.",
      "ja": "サーバがサポートしているバージョンでメッセージを受信した場合は、応答メッセージのバージョンは、受け取ったバージョンと同じでなければなりません。サーバがサポートするよりも高いまたは低いバージョンのメッセージを受信した場合、それはunsupportedVersionとERRORMSGを返送しなければならない（pKIStatusInfoのfailureInfoフィールドに）ビットセット。受信バージョンは最高のサポートされているバージョンよりも高い場合、エラーメッセージのバージョンは、サーバーがサポートする最上位バージョンである必要があります。受信バージョンは最低のサポートされているバージョンよりも低い場合、エラーメッセージ内のバージョンは、サーバーがサポートしている最低のバージョンである必要があります。"
    },
    {
      "indent": 3,
      "text": "If a client gets back an ErrorMsgContent with the unsupportedVersion bit set and a version it supports, then it MAY retry the request with that version.",
      "ja": "クライアントは、ビットセットunsupportedVersionとそれがサポートするバージョンとErrorMsgContentを取り戻すなら、それはそのバージョンでリクエストを再試行することができます。"
    },
    {
      "indent": 0,
      "text": "7.1. Supporting Implementations",
      "section_title": true,
      "ja": "7.1。実装をサポート"
    },
    {
      "indent": 3,
      "text": "RFC 2510 did not specify the behaviour of implementations receiving versions they did not understand since there was only one version in existence. With the introduction of the present revision of the specification, the following versioning behaviour is recommended.",
      "ja": "RFC 2510は1つのバージョンのみが存在していたので、彼らは理解していなかったバージョンを受け取る実装の動作を指定しませんでした。仕様の現在のリビジョンの導入により、以下のバージョン管理動作が推奨されます。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Clients Talking to Servers",
      "section_title": true,
      "ja": "7.1.1。サーバーに話すクライアント"
    },
    {
      "indent": 3,
      "text": "If, after sending a cmp2000 message, a client receives an ErrorMsgContent with a version of cmp1999, then it MUST abort the current transaction. It MAY subsequently retry the transaction using version cmp1999 messages.",
      "ja": "、cmp2000メッセージを送信した後、クライアントはcmp1999のバージョンでErrorMsgContentを受信した場合、それは現在のトランザクションを中止しなければなりません。これは、その後、バージョンcmp1999メッセージを使用してトランザクションを再試行することができます。"
    },
    {
      "indent": 3,
      "text": "If a client receives a non-error PKIMessage with a version of cmp1999, then it MAY decide to continue the transaction (if the transaction hasn't finished) using RFC 2510 semantics. If it does not choose to do so and the transaction is not finished, then it MUST abort the transaction and send an ErrorMsgContent with a version of cmp1999.",
      "ja": "クライアントはcmp1999のバージョンと非エラーPKIMessageを受信した場合、それは（トランザクションが終了していない場合）RFC 2510のセマンティクスを使用して取引を継続することを決定することができます。それはそうすることを選択しないと、トランザクションが終了していない場合、それはトランザクションをアボートし、cmp1999のバージョンでErrorMsgContentを送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Servers Receiving Version cmp1999 PKIMessages",
      "section_title": true,
      "ja": "7.1.2。バージョンcmp1999 PKIMessagesを受信サーバー"
    },
    {
      "indent": 3,
      "text": "If a server receives a version cmp1999 message it MAY revert to RFC 2510 behaviour and respond with version cmp1999 messages. If it does not choose to do so, then it MUST send back an ErrorMsgContent as described above in Section 7.",
      "ja": "サーバは、バージョンcmp1999メッセージを受信した場合には、RFC 2510の動作に戻すと、バージョンcmp1999メッセージで応答することができます。それはそうすることを選択しない場合、それは第7節で前述したようにErrorMsgContentを返送しなければなりません。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Proof-Of-Possession with a Decryption Key",
      "section_title": true,
      "ja": "8.1。実証のボール支配率復号化キーで"
    },
    {
      "indent": 3,
      "text": "Some cryptographic considerations are worth explicitly spelling out. In the protocols specified above, when an end entity is required to prove possession of a decryption key, it is effectively challenged to decrypt something (its own certificate). This scheme (and many others!) could be vulnerable to an attack if the possessor of the decryption key in question could be fooled into decrypting an arbitrary challenge and returning the cleartext to an attacker. Although in this specification a number of other failures in security are required in order for this attack to succeed, it is conceivable that some future services (e.g., notary, trusted time) could potentially be vulnerable to such attacks. For this reason, we re-iterate the general rule that implementations should be very careful about decrypting arbitrary \"ciphertext\" and revealing recovered \"plaintext\" since such a practice can lead to serious security vulnerabilities.",
      "ja": "いくつかの暗号の考慮事項は、明示的に綴る価値があります。エンドエンティティは、復号鍵の所有を証明するために必要とされる時には、上記指定されたプロトコルで、それを効果的に何か（自身の証明書）を復号化するために挑戦しています。問題の復号鍵の所有者は、任意のチャレンジを復号化し、攻撃者に平文を返すにだまされることができれば、このスキーム（および他の多くは！）攻撃に対して脆弱である可能性があります。この仕様では、セキュリティの他の失敗の数が成功するには、この攻撃のために必要とされるが、いくつかの将来のサービス（例えば、公証人、信頼できる時間）は、潜在的な攻撃に対して脆弱であることが考えられます。このような理由から、我々は、実装は、そのような練習は重大なセキュリティ上の脆弱性につながることができますので、「平文」を回復し、任意の「暗号文」を解読し、明らかに非常に注意しなければならない一般的なルールを、反復再。"
    },
    {
      "indent": 0,
      "text": "8.2. Proof-Of-Possession by Exposing the Private Key",
      "section_title": true,
      "ja": "8.2。実証のボール支配率秘密鍵を暴露することによって"
    },
    {
      "indent": 3,
      "text": "Note also that exposing a private key to the CA/RA as a proof-of-possession technique can carry some security risks (depending upon whether or not the CA/RA can be trusted to handle such material appropriately). Implementers are advised to:",
      "ja": "ノートも実証の所有技術としてCA / RAに秘密鍵を露出する（CA / RAが適切にそのような材料を処理するために信頼できるか否かに応じて）いくつかのセキュリティ上のリスクを運ぶことができます。実装者がすることをお勧めします："
    },
    {
      "indent": 6,
      "text": "Exercise caution in selecting and using this particular POP mechanism",
      "ja": "この特定のPOPメカニズムを選択し、使用する際には注意が必要"
    },
    {
      "indent": 6,
      "text": "When appropriate, have the user of the application explicitly state that they are willing to trust the CA/RA to have a copy of their private key before proceeding to reveal the private key.",
      "ja": "適切な場合、アプリケーションのユーザーが明示的に彼らは秘密鍵を明らかに進む前に、自分の秘密鍵のコピーを持っているCA / RAを信頼して喜んでいると述べているしています。"
    },
    {
      "indent": 0,
      "text": "8.3. Attack Against Diffie-Hellman Key Exchange",
      "section_title": true,
      "ja": "8.3。 Diffie-Hellman鍵交換への攻撃"
    },
    {
      "indent": 3,
      "text": "A small subgroup attack during a Diffie-Hellman key exchange may be carried out as follows. A malicious end entity may deliberately choose D-H parameters that enable him/her to derive (a significant number of bits of) the D-H private key of the CA during a key archival or key recovery operation. Armed with this knowledge, the",
      "ja": "以下のようにDiffie-Hellman鍵交換中小サブグループ攻撃を行ってもよいです。悪質なエンドエンティティが故意に（のビットのかなりの数）を導出するために彼/彼女を有効にD-Hパラメータキーのアーカイブまたはキー回復動作時のCAのD-Hの秘密鍵を選択することができます。この知識を武器に、"
    },
    {
      "indent": 3,
      "text": "EE would then be able to retrieve the decryption private key of another unsuspecting end entity, EE2, during EE2's legitimate key archival or key recovery operation with that CA. In order to avoid the possibility of such an attack, two courses of action are available. (1) The CA may generate a fresh D-H key pair to be used as a protocol encryption key pair for each EE with which it",
      "ja": "EEは、そのCAとEE2の正当なキーのアーカイブやキーリカバリ操作中に、他の疑いを持たないエンドエンティティの復号化秘密鍵、EE2を取得することができるだろうこのような攻撃の可能性を避けるために、アクションの2つのコースが用意されています。 （1）CAは、各EEのためのプロトコルの暗号鍵ペアとして使用される新鮮D-H鍵ペアを生成することができます"
    },
    {
      "indent": 3,
      "text": "interacts. (2) The CA may enter into a key validation protocol (not specified in this document) with each requesting end entity to ensure that the EE's protocol encryption key pair will not facilitate this attack. Option (1) is clearly simpler (requiring no extra protocol exchanges from either party) and is therefore RECOMMENDED.",
      "ja": "対話します。 （2）CAは、EEのプロトコルの暗号化キーのペアは、この攻撃を促進しないことを保証するために、各要求エンドエンティティと（この文書で指定されていない）キーバリデーションプロトコルに入ることがあります。オプション（1）（いずれかの当事者から余分なプロトコル交換を必要としない）、明らかに単純であるため、推奨されています。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The PKI General Message types are identified by object identifiers (OIDs). The OIDs for the PKI General Message types defined in this document were assigned from an arc delegated by the IANA to the PKIX Working Group.",
      "ja": "PKI一般的なメッセージの種類は、オブジェクト識別子（OID）によって識別されます。この文書で定義されたPKIの一般的なメッセージタイプのOIDは、PKIXワーキンググループにIANAによって委任アークから割り当てられました。"
    },
    {
      "indent": 3,
      "text": "The cryptographic algorithms referred to in this document are identified by object identifiers (OIDs). The OIDs for cryptographic algorithms were assigned from several arcs owned by various organizations, including RSA Security, Entrust Technologies, IANA and IETF.",
      "ja": "本文書で言及暗号化アルゴリズムは、オブジェクト識別子（OID）によって識別されます。暗号化アルゴリズムのためのOIDはRSAセキュリティ、エントラストテクノロジー、IANAやIETFなどの様々な団体が所有する複数の円弧から割り当てられました。"
    },
    {
      "indent": 3,
      "text": "Should additional encryption algorithms be introduced, the advocates for such algorithms are expected to assign the necessary OIDs from their own arcs.",
      "ja": "追加の暗号化アルゴリズムを導入しなければならない、そのようなアルゴリズムのための支持者は、独自のアークから必要なOIDを割り当てることが期待されています。"
    },
    {
      "indent": 3,
      "text": "No further action by the IANA is necessary for this document or any anticipated updates.",
      "ja": "IANAによってそれ以上のアクションは、この文書または任意の予想されるアップデートの必要はありません。"
    },
    {
      "indent": 0,
      "text": "Normative References",
      "ja": "引用規格"
    },
    {
      "indent": 3,
      "text": "[X509] International Organization for Standardization and International Telecommunications Union, \"Information technology - Open Systems Interconnection - The Directory: Public-key and attribute certificate frameworks\", ISO Standard 9594-8:2001, ITU-T Recommendation X.509, March 2000.",
      "ja": "[X509]標準化と国際電気通信連合のための国際組織、「情報技術 - 開放型システム間相互接続 - ディレクトリ：公開鍵と属性証明書の枠組み」、ISO規格9594から8：2001、ITU-T勧告X.509、2000年3月。"
    },
    {
      "indent": 3,
      "text": "[MvOV97] Menezes, A., van Oorschot, P. and S. Vanstone, \"Handbook of Applied Cryptography\", CRC Press ISBN 0-8493-8523-7, 1996.",
      "ja": "[MvOV97]メネゼス、A.、バンOorschot、P.とS. Vanstone著、 \"応用暗号のハンドブック\"、CRCプレスISBN 0-8493-8523-7、1996。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2202] Cheng, P. and R. Glenn, \"Test Cases for HMAC-MD5 and HMAC-SHA-1\", RFC 2202, September 1997.",
      "ja": "[RFC2202]チェン、P.およびR.グレン、 \"HMAC-MD5とHMAC-SHA-1のテストケース\"、RFC 2202、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2482] Whistler, K. and G. Adams, \"Language Tagging in Unicode Plain Text\", RFC 2482, January 1999.",
      "ja": "[RFC2482]ウィスラー、K.とG.アダムス、 \"Unicodeのテキスト形式での言語タグ付け\"、RFC 2482、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[CRMF] Schaad, J., \"Internet X.509 Public Key Infrastructure Certificate Request Message Format (CRMF)\", RFC 4211, September 2005.",
      "ja": "[CRMF] Schaad、J.、 \"インターネットX.509公開鍵暗号基盤証明書要求メッセージ・フォーマット（CRMF）\"、RFC 4211、2005年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3066] Alvestrand, H., \"Tags for the Identification of Languages\", BCP 47, RFC 3066, January 2001.",
      "ja": "[RFC3066] Alvestrand、H.、 \"言語識別のためのタグ\"、BCP 47、RFC 3066、2001年1月。"
    },
    {
      "indent": 0,
      "text": "Informative References",
      "ja": "参考文献"
    },
    {
      "indent": 3,
      "text": "[CMPtrans] Kapoor, A., Tschalar, R. and T. Kause, \"Internet X.509 Public Key Infrastructure -- Transport Protocols for CMP\", Work in Progress. 2004.",
      "ja": "[CMPtrans]カプール、A.、Tschalar、R.とT. Kause、 \"インターネットX.509公開鍵基盤 -  CMPのためのトランスポートプロトコル\" が進行中で働いて。 2004。"
    },
    {
      "indent": 3,
      "text": "[PKCS7] RSA Laboratories, \"The Public-Key Cryptography Standards - Cryptographic Message Syntax Standard. Version 1.5\", PKCS 7, November 1993.",
      "ja": "[PKCS7] RSA Laboratories社、 \"公開鍵暗号規格 - 。暗号メッセージ構文規格バージョン1.5\"、PKCS 7、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[PKCS10] Nystrom, M., and B. Kaliski, \"The Public-Key Cryptography Standards - Certification Request Syntax Standard, Version 1.7\", RFC 2986, May 2000.",
      "ja": "[PKCS10] Nystrom、M.、およびB. Kaliski、 \"公開鍵暗号規格 - 証明書要求の構文標準、バージョン1.7\"、RFC 2986、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[PKCS11] RSA Laboratories, \"The Public-Key Cryptography Standards - Cryptographic Token Interface Standard. Version 2.10\", PKCS 11, December 1999.",
      "ja": "[PKCS11] RSA Laboratories社、 \"公開鍵暗号規格 - 。暗号化トークンインタフェース規格バージョン2.10\"、PKCS 11、1999年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1847] Galvin, J., Murphy, S., Crocker, S., and N. Freed, \"Security Multiparts for MIME: Multipart/Signed and Multipart/Encrypted\", RFC 1847, October 1995.",
      "ja": "[RFC1847]ガルビン、J.、マーフィー、S.、クロッカー、S.、およびN.フリード、 \"セキュリティマルチパートMIMEのために：マルチパート/署名およびマルチパート/暗号化\"、RFC 1847、1995年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2559] Boeyen, S., Howes, T. and P. Richard, \"Internet X.509 Public Key Infrastructure Operational Protocols - LDAPv2\", RFC 2559, April 1999.",
      "ja": "[RFC2559] Boeyen、S.、ハウズ、T.、およびP.リチャード、 \"インターネットX.509公開鍵基盤運用プロトコル - のLDAPv2\"、RFC 2559、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2585] Housley, R. and P. Hoffman, \"Internet X.509 Public Key Infrastructure Operational Protocols: FTP and HTTP\", RFC 2585, May 1999.",
      "ja": "[RFC2585] Housley氏、R.とP.ホフマン、 \"インターネットX.509公開鍵基盤運用プロトコル：FTPやHTTP\"、RFC 2585、1999年5月。"
    },
    {
      "indent": 3,
      "text": "[FIPS-180] National Institute of Standards and Technology, \"Secure Hash Standard\", FIPS PUB 180-1, May 1994.",
      "ja": "[FIPS-180]米国国立標準技術研究所、1994年5月、FIPS PUB 180-1の \"ハッシュ標準セキュア\"。"
    },
    {
      "indent": 3,
      "text": "[FIPS-186] National Institute of Standards and Technology, \"Digital Signature Standard\", FIPS PUB 186, May 1994.",
      "ja": "[FIPS-186]国立標準技術研究所、 \"デジタル署名標準\"、FIPS PUBの186、1994年5月。"
    },
    {
      "indent": 3,
      "text": "[ANSI-X9.42] American National Standards Institute, \"Public Key Cryptography for The Financial Services Industry: Agreement of Symmetric Keys Using Discrete Logarithm Cryptography\", ANSI X9.42, February 2000.",
      "ja": "[ANSI-X9.42]米国規格協会、「金融サービス業界向け公開鍵暗号：離散対数暗号使用対称鍵の契約」、ANSI X9.42、2000年2月を。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Reasons for the Presence of RAs",
      "ja": "Rasの存在について、付録A.理由"
    },
    {
      "indent": 3,
      "text": "The reasons that justify the presence of an RA can be split into those that are due to technical factors and those which are organizational in nature. Technical reasons include the following.",
      "ja": "RAの存在を正当化する理由は技術的要因と自然の中で組織的なものに起因しているものに分けることができます。技術的な理由は以下のものが挙げられます。"
    },
    {
      "indent": 3,
      "text": "o If hardware tokens are in use, then not all end entities will have the equipment needed to initialize these; the RA equipment can include the necessary functionality (this may also be a matter of policy).",
      "ja": "ハードウェア・トークンを使用している場合は、O、そしてないすべてのエンドエンティティは、これらを初期化するために必要な設備を持っています。 RA機器は、必要な機能を（これはまた、ポリシーの問題かもしれない）含めることができます。"
    },
    {
      "indent": 3,
      "text": "o Some end entities may not have the capability to publish certificates; again, the RA may be suitably placed for this.",
      "ja": "O一部のエンドエンティティ証明書を発行する機能を持っていないかもしれません。再び、RAは、適切にこれを配置することができます。"
    },
    {
      "indent": 3,
      "text": "o The RA will be able to issue signed revocation requests on behalf of end entities associated with it, whereas the end entity may not be able to do this (if the key pair is completely lost).",
      "ja": "O RAは、エンドエンティティは（鍵のペアが完全に失われた場合）、これを行うことができない場合があり、一方、それに関連付けられたエンドエンティティに代わって署名した失効要求を発行することができるようになります。"
    },
    {
      "indent": 3,
      "text": "Some of the organizational reasons that argue for the presence of an RA are the following.",
      "ja": "RAの存在を主張する組織的な理由のいくつかは、以下の通りです。"
    },
    {
      "indent": 3,
      "text": "o It may be more cost effective to concentrate functionality in the RA equipment than to supply functionality to all end entities (especially if special token initialization equipment is to be used).",
      "ja": "Oそれは（特別なトークンの初期化装置を使用する場合は特に）すべてのエンドエンティティに機能を供給するよりも、RA機器に機能を集中するために有効な、よりコストとすることができます。"
    },
    {
      "indent": 3,
      "text": "o Establishing RAs within an organization can reduce the number of CAs required, which is sometimes desirable.",
      "ja": "ことが望ましい場合がある必要なCAの数を減らすことができ、組織内のRAの確立O。"
    },
    {
      "indent": 3,
      "text": "o RAs may be better placed to identify people with their \"electronic\" names, especially if the CA is physically remote from the end entity.",
      "ja": "O RAは良くCAは、エンドエンティティから物理的に離れている場合は特に、彼らの「電子」の名前を持つ人々を識別するために配置することができます。"
    },
    {
      "indent": 3,
      "text": "o For many applications, there will already be in place some administrative structure so that candidates for the role of RA are easy to find (which may not be true of the CA).",
      "ja": "RAの役割のための候補は（CAの真実ではない場合もある）を見つけることは容易になるように、O、多くのアプリケーションでは、すでに場所でいくつかの管理構造が存在します。"
    },
    {
      "indent": 0,
      "text": "Appendix B. The Use of Revocation Passphrase",
      "ja": "失効パスフレーズの付録B.ザ・利用"
    },
    {
      "indent": 3,
      "text": "A revocation request must incorporate suitable security mechanisms, including proper authentication, in order to reduce the probability of successful denial-of-service attacks. A digital signature on the request -- MANDATORY to support within this specification if revocation requests are supported -- can provide the authentication required, but there are circumstances under which an alternative mechanism may be desirable (e.g., when the private key is no longer accessible and the entity wishes to request a revocation prior to re-certification of another key pair). In order to accommodate such circumstances, a PasswordBasedMAC on the request is also MANDATORY to support within this specification (subject to local security policy for a given environment) if revocation requests are supported and if shared secret information can be established between the requester and the responder prior to the need for revocation.",
      "ja": "失効要求が成功したサービス拒否攻撃の可能性を減少させるために、適切な認証を含む適切なセキュリティ機構を組み込む必要があります。ご要望に応じてデジタル署名 - 失効要求がサポートされている場合は、この仕様の範囲内にサポートするMANDATORYは - 必要な認証を提供することができますが、代替メカニズムが望ましいかもしれれる状況（例えば、秘密鍵はアクセスできなくなったときがありますエンティティ）は、別の鍵ペアの失効前に再認証を要求することを望みます。このような状況に対応するために、要求にPasswordBasedMACは失効要求がサポートされている場合も、本明細書内に（特定の環境のためのローカルセキュリティポリシーに従う）をサポートするために必須であり、共有秘密情報は、リクエスタとレスポンダとの間で確立することができれば失効の必要性に先立っ。"
    },
    {
      "indent": 3,
      "text": "A mechanism that has seen use in some environments is \"revocation passphrase\", in which a value of sufficient entropy (i.e., a relatively long passphrase rather than a short password) is shared between (only) the entity and the CA/RA at some point prior to revocation; this value is later used to authenticate the revocation request.",
      "ja": "いくつかの環境での使用を見ているメカニズムは十分エントロピーの値（すなわち、比較的長いパスフレーズはなく、短いパスワードが）いくつかで（のみ）エンティティおよびCA / RAとの間で共有された「取消しパスフレーズ」でありますポイント失効する前に、この値は、後に失効要求を認証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "In this specification, the following technique to establish shared secret information (i.e., a revocation passphrase) is OPTIONAL to support. Its precise use in CMP messages is as follows.",
      "ja": "本明細書では、共有秘密情報（すなわち、失効パスフレーズ）を確立するには、以下の技術がサポートするためのオプションです。次のようにCMPメッセージにおけるその正確な使用があります。"
    },
    {
      "indent": 3,
      "text": "o The OID and value specified in Section 5.3.19.9 MAY be sent in a GenMsg message at any time, or MAY be sent in the generalInfo field of the PKIHeader of any PKIMessage at any time. (In particular, the EncryptedValue may be sent in the header of the certConf message that confirms acceptance of certificates requested in an initialization request or certificate request message.) This conveys a revocation passphrase chosen by the entity (i.e., the decrypted bytes of the encValue field) to the relevant CA/RA; furthermore, the transfer is accomplished with appropriate confidentiality characteristics (because the passphrase is encrypted under the CA/RA's protocolEncryptionKey).",
      "ja": "O節5.3.19.9に指定されたOID、値はいつでもGenMsgメッセージで送信されても​​よく、または任意の時点で任意PKIMessageのPKIHeaderのgeneralInfoフィールドで送られてもよいです。 （特に、EncryptedValueは、初期化要求または認証要求メッセージで要求された証明書の受け入れを確認certConfメッセージのヘッダに送信されても​​よい。）これはencValueの実体（すなわち、復号化されたバイトによって選択された失効パスフレーズを搬送します関連するCA / RAにフィールド）; （パスフレーズがCA / RAのprotocolEncryptionKey下で暗号化されているため）さらに、転送が適切な機密性の特性を用いて達成されます。"
    },
    {
      "indent": 3,
      "text": "o If a CA/RA receives the revocation passphrase (OID and value specified in Section 5.3.19.9) in a GenMsg, it MUST construct and send a GenRep message that includes the OID (with absent value) specified in Section 5.3.19.9. If the CA/RA receives the revocation passphrase in the generalInfo field of a PKIHeader of any PKIMessage, it MUST include the OID (with absent value) in the generalInfo field of the PKIHeader of the corresponding response PKIMessage. If the CA/RA is unable to return the appropriate response message for any reason, it MUST send an error message with a status of \"rejection\" and, optionally, a failInfo reason set.",
      "ja": "CAは、/ RAがGenMsgに失効パスフレーズ（OID、セクション5.3.19.9に指定された値）を受信した場合、O、それはセクション5.3.19.9で指定された（存在しない値を持つ）OIDを含むGenRepメッセージを作成して送信しなければなりません。 CA / RAは、任意PKIMessageのPKIHeaderのgeneralInfoフィールドに無効化パスフレーズを受信した場合、それは対応する応答PKIMessageのPKIHeaderのgeneralInfoフィールドに（存在しない値を持つ）OIDを含まなければなりません。 CA / RAが何らかの理由のために適切な応答メッセージを返すことができない場合、それは、必要に応じて、failInfo理由セットを「拒絶」のステータスとエラーメッセージを送信しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The valueHint field of EncryptedValue MAY contain a key identifier (chosen by the entity, along with the passphrase itself) to assist in later retrieval of the correct passphrase (e.g., when the revocation request is constructed by the entity and received by the CA/RA).",
      "ja": "O失効要求をエンティティによって構成され、CAによって受信されたときEncryptedValueのvalueHintフィールドが正しいパスフレーズ（例えば、の後の検索を支援するために（パスフレーズ自体とともに、エンティティによって選択された）鍵識別子を含むかもしれ/ RA）。"
    },
    {
      "indent": 3,
      "text": "o The revocation request message is protected by a PasswordBasedMAC, with the revocation passphrase as the key. If appropriate, the senderKID field in the PKIHeader MAY contain the value previously transmitted in valueHint.",
      "ja": "O失効要求メッセージはキーとして取り消しパスフレーズと、PasswordBasedMACによって保護されています。適切な場合には、PKIHeaderでsenderKIDフィールドは、以前valueHintに送信された値を含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "Using the technique specified above, the revocation passphrase may be initially established and updated at any time without requiring extra messages or out-of-band exchanges. For example, the revocation request message itself (protected and authenticated through a MAC that uses the revocation passphrase as a key) may contain, in the PKIHeader, a new revocation passphrase to be used for authenticating future revocation requests for any of the entity's other certificates. In some environments this may be preferable to mechanisms that reveal the passphrase in the revocation request message, since this can allow a denial-of-service attack in which the revealed passphrase is used by an unauthorized third party to authenticate revocation requests on the entity's other certificates. However, because the passphrase is not revealed in the request message, there is no requirement that the passphrase must always be updated when a revocation request is made (that is, the same passphrase MAY be used by an entity to authenticate revocation requests for different certificates at different times).",
      "ja": "上記指定された技術を使用して、失効パスフレーズは、最初に確立され、余分なメッセージまたはアウトオブバンド交換を必要とすることなく、いつでも更新することができます。例えば、失効要求メッセージ自体（キーとして失効パスフレーズを使用することを保護し、MACを介して認証された）は、PKIHeaderに、エンティティの他の証明書のいずれかの将来の失効要求を認証するために使用される新しい失効パスフレーズを含んでいてもよいです。これは明らかにパスフレーズがエンティティの他に失効要求を認証するために、不正な第三者によって使用されるサービス拒否攻撃を可能にすることができるので、一部の環境では、これは、失効要求メッセージにパスフレーズを明らかにする機構に好ましいかもしれません証明書。パスフレーズを要求メッセージで明らかにされていないためしかし、失効要求が行われたときにパスフレーズは常に更新されなければならないという要件（つまりはありません、同じパスフレーズは異なる証明書の失効要求を認証するエンティティによって使用されるかもしれ異なる時間に）。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the above technique can provide strong cryptographic protection over the entire revocation request message even when a digital signature is not used. Techniques that do authentication of the revocation request by simply revealing the revocation passphrase typically do not provide cryptographic protection over the fields of the request message (so that a request for revocation of one certificate may be modified by an unauthorized third party to a request for revocation of another certificate for that entity).",
      "ja": "また、上記の技術は、デジタル署名を使用しなくても全体の失効要求メッセージ上に強力な暗号化保護を提供することができます。 1つの証明書の失効要求が失効の要求に権限のない第三者によって修正することができるように、単純に失効パスフレーズを明らかにすることによって失効要求の認証を行う技術は、一般に、要求メッセージ（の分野にわたる暗号保護を提供していません。そのエンティティのための別の証明書の）。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Request Message Behavioral Clarifications",
      "ja": "付録C.要求メッセージ行動の明確化"
    },
    {
      "indent": 3,
      "text": "In the case of updates to [CRMF], which cause interpretation or interoperability issues, [CRMF] SHALL be the normative document.",
      "ja": "解釈や相互運用性の問題を引き起こす[CRMF]への更新の場合は、[CRMF]規範的文書であるものとします。"
    },
    {
      "indent": 3,
      "text": "The following definitions are from [CRMF]. They are included here in order to codify behavioral clarifications to that request message; otherwise, all syntax and semantics are identical to [CRMF].",
      "ja": "以下の定義は、[CRMF]からのものです。彼らは、その要求メッセージに対する行動の明確化を体系化するためにここに含まれています。そうでない場合は、すべての構文およびセマンティクスは、[CRMF]と同じです。"
    },
    {
      "indent": 3,
      "text": "CertRequest ::= SEQUENCE {\n    certReqId     INTEGER,\n    certTemplate  CertTemplate,\n    controls      Controls OPTIONAL }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- If certTemplate is an empty SEQUENCE (i.e., all fields -- omitted), then controls MAY contain the",
      "ja": " -  CertTemplateのが空のシーケンスである場合（すなわち、すべてのフィールドが - 省略）、その後コントロールが含むかもしれ"
    },
    {
      "indent": 3,
      "text": "-- id-regCtrl-altCertTemplate control, specifying a template -- for a certificate other than an X.509v3 public-key -- certificate. Conversely, if certTemplate is not empty -- (i.e., at least one field is present), then controls MUST -- NOT contain id-regCtrl- altCertTemplate. The new control is -- defined as follows:",
      "ja": " -  ID-regCtrl-altCertTemplate制御、テンプレートを指定 - 証明書 - のX.509v3公開鍵以外の証明書。 CertTemplateのが空でない場合、逆に、 - （すなわち、少なくとも一つのフィールドが存在する）、次いで、コントロールがしなければならない -  ID-regCtrl- altCertTemplateが含まれていません。新しいコントロールがされる - 次のように定義します："
    },
    {
      "indent": 3,
      "text": "id-regCtrl-altCertTemplate OBJECT IDENTIFIER ::= {id-regCtrl 7}\nAltCertTemplate ::= AttributeTypeAndValue",
      "raw": true
    },
    {
      "indent": 3,
      "text": "POPOSigningKey ::= SEQUENCE {\n    poposkInput           [0] POPOSigningKeyInput OPTIONAL,\n    algorithmIdentifier   AlgorithmIdentifier,\n    signature             BIT STRING }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- ********** -- * For the purposes of this specification, the ASN.1 comment -- * given in [CRMF] pertains not only to certTemplate, but -- * also to the altCertTemplate control. That is, -- ********** -- * The signature (using \"algorithmIdentifier\") is on the -- * DER-encoded value of poposkInput (i.e., the \"value\" OCTETs -- * of the POPOSigningKeyInput DER). NOTE: If CertReqMsg -- * certReq certTemplate (or the altCertTemplate control) -- * contains the subject and publicKey values, then poposkInput -- * MUST be omitted and the signature MUST be computed on the -- * DER-encoded value of CertReqMsg certReq (or the DER--- * encoded value of AltCertTemplate). If -- * certTemplate/altCertTemplate does not contain both the -- * subject and public key values (i.e., if it contains only -- * one of these, or neither), then poposkInput MUST be present -- * and MUST be signed. -- **********",
      "ja": " -  **********  -  *本明細書の目的のために、ASN.1コメント -  *で与えられたが[CRMF] CertTemplateののみならず関係が、 -  *もaltCertTemplateコントロールに。すなわち、 -  **********  -  *（「のAlgorithmIdentifier」を使用して）署名がオン - 同時にpoposkInputの* DER符号化された値（すなわち、「値」オクテット -  *のPOPOSigningKeyInput DER）。注： -  * CERTREQ CertTemplateの（又はaltCertTemplate制御） -  *被写体と公開鍵値が含まれ、次いで同時にpoposkInput  -  CertReqMsgが場合*省略しなければならなくて、署名がで計算しなければなりません -  CertReqMsgの* DER符号化された値CERTREQ（またはDER AltCertTemplateの--- *エンコードされた値）。もし -  * CertTemplateの/ altCertTemplateの両方が含まれていません -  *対象と公開鍵の値を（それだけ含まれている場合、すなわち、 -  *これらのいずれか、またはどちらも）、そして同時にpoposkInputが存在しなければならない -  *と署名する必要があります。 -  **********"
    },
    {
      "indent": 3,
      "text": "POPOPrivKey ::= CHOICE {\n    thisMessage       [0] BIT STRING,",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- ********** -- * the type of \"thisMessage\" is given as BIT STRING in -- * [CRMF]; it should be \"EncryptedValue\" (in accordance -- * with Section 5.2.2, \"Encrypted Values\", of this specification). -- * Therefore, this document makes the behavioral clarification -- * of specifying that the contents of \"thisMessage\" MUST be encoded -- * as an EncryptedValue and then wrapped in a BIT STRING. This -- * allows the necessary conveyance and protection of the -- * private key while maintaining bits-on-the-wire compatibility -- * with [CRMF]. -- **********",
      "ja": ";  -  **********  -  * [CRMF]  -  * \"thisMessage\" のタイプは、ビット列として与えられます。それは（ -  *セクション5.2.2、この仕様の「暗号化された値」、に従って）「EncryptedValue」でなければなりません。 -  *「thisMessage」の内容は、符号化されなければならないことを指定する -   -  EncryptedValueとして*その後、ビット列に包まれて*そのため、この資料は、行動の明確化を行います。ビット・オン・ワイヤの互換性を維持しながら*秘密鍵 -   - これは -  *の必要搬送および保護を可能にする* [CRMF]と。 -  **********"
    },
    {
      "indent": 7,
      "text": "subsequentMessage [1] SubsequentMessage,\ndhMAC             [2] BIT STRING }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix D. PKI Management Message Profiles (REQUIRED).",
      "ja": "付録D. PKI管理メッセージプロファイル（REQUIRED）。"
    },
    {
      "indent": 3,
      "text": "This appendix contains detailed profiles for those PKIMessages that MUST be supported by conforming implementations (see Section 6).",
      "ja": "この付録では、適合実装（セクション6を参照）によってサポートされなければならないものをPKIMessagesの詳細なプロファイルが含まれています。"
    },
    {
      "indent": 3,
      "text": "Profiles for the PKIMessages used in the following PKI management operations are provided:",
      "ja": "以下のPKI管理操作で使用PKIMessagesのプロファイルが用意されています。"
    },
    {
      "indent": 3,
      "text": "o initial registration/certification",
      "ja": "O初期登録/認証"
    },
    {
      "indent": 3,
      "text": "o basic authenticated scheme",
      "ja": "基本的な認証スキームO"
    },
    {
      "indent": 3,
      "text": "o certificate request",
      "ja": "Oの証明書の要求"
    },
    {
      "indent": 3,
      "text": "o key update",
      "ja": "Oキーを更新"
    },
    {
      "indent": 0,
      "text": "D.1. General Rules for Interpretation of These Profiles.",
      "ja": "D.1。これらのプロファイルの解釈のための一般的なルール。"
    },
    {
      "indent": 3,
      "text": "1. Where OPTIONAL or DEFAULT fields are not mentioned in individual profiles, they SHOULD be absent from the relevant message (i.e., a receiver can validly reject a message containing such fields as being syntactically incorrect). Mandatory fields are not mentioned if they have an obvious value (e.g., in this version of the specification, pvno is always 2).",
      "ja": "1.オプションまたはDEFAULTフィールドは、個々のプロファイルで言及されていない場合、それらは、関連するメッセージ（即ち、受信機が有効に構文的に正しくないものとして、そのようなフィールドを含むメッセージを拒否することができる）から不在であるべきです。彼らは明らか値を持っている場合、必須フィールドが言及されていない（例えば、仕様のこのバージョンでは、PVNO 2常に）。"
    },
    {
      "indent": 3,
      "text": "2. Where structures occur in more than one message, they are separately profiled as appropriate.",
      "ja": "2.構造は複数のメッセージで発生した場合、それらは個別に適切に紹介されます。"
    },
    {
      "indent": 3,
      "text": "3. The algorithmIdentifiers from PKIMessage structures are profiled separately.",
      "ja": "3. PKIMessage構造からalgorithmIdentifiersは個別に紹介されます。"
    },
    {
      "indent": 3,
      "text": "4. A \"special\" X.500 DN is called the \"NULL-DN\"; this means a DN containing a zero-length SEQUENCE OF RelativeDistinguishedNames (its DER encoding is then '3000'H).",
      "ja": "4.「特別」X.500 DNは、「NULL-DN」と呼ばれています。これはする相対識別名（そのDERエンコーディングが次にある「3000'H）のゼロ長の配列を含むDNを意味します。"
    },
    {
      "indent": 3,
      "text": "5. Where a GeneralName is required for a field, but no suitable value is available (e.g., an end entity produces a request before knowing its name), then the GeneralName is to be an X.500 NULL-DN (i.e., the Name field of the CHOICE is to contain a NULL-DN). This special value can be called a \"NULL-GeneralName\".",
      "ja": "GeneralNameがフィールドのために必要とされる5、ない適切な値が利用できない場合、のGeneralNameはX.500のNULL-DN（つまり、名前になることです（例えば、エンドエンティティは、その名前を知っている前に、要求を生成します） CHOICEのフィールドはNULL-DN）を含むことになります。この特別な値は「NULL-のGeneralName」と呼ぶことができます。"
    },
    {
      "indent": 3,
      "text": "6. Where a profile omits to specify the value for a GeneralName, then the NULL-GeneralName value is to be present in the relevant PKIMessage field. This occurs with the sender field of the PKIHeader for some messages.",
      "ja": "プロファイルはのGeneralNameの値を指定するために省略6は、次にNULL-のGeneralName値は、関連PKIMessageフィールドに存在することがあります。これは、いくつかのメッセージのPKIHeaderの差出人フィールドで発生します。"
    },
    {
      "indent": 3,
      "text": "7. Where any ambiguity arises due to naming of fields, the profile names these using a \"dot\" notation (e.g., \"certTemplate.subject\" means the subject field within a field called certTemplate).",
      "ja": "任意のあいまいさは、フィールドの名称により生じる7は、プロファイル名「ドット」表記法を使用して、これら（例えば、「certTemplate.subject」はCertTemplateのと呼ばれるフィールド内のサブジェクトフィールドを意味します）。"
    },
    {
      "indent": 3,
      "text": "8. Where a \"SEQUENCE OF types\" is part of a message, a zero-based array notation is used to describe fields within the SEQUENCE OF (e.g., crm[0].certReq.certTemplate.subject refers to a subfield of the first CertReqMsg contained in a request message).",
      "ja": "「タイプの配列は、」メッセージの一部である8は、ゼロベースの配列表記（例えば、CRMのシーケンス内のフィールドを記述するために使用される[0] .certReq.certTemplate.subjectは、最初のサブフィールドを指し要求メッセージに含まCertReqMsg）。"
    },
    {
      "indent": 3,
      "text": "9. All PKI message exchanges in Appendix D.4 to D.6 require a certConf message to be sent by the initiating entity and a PKIConfirm to be sent by the responding entity. The PKIConfirm is not included in some of the profiles given since its body is NULL and its header contents are clear from the context. Any authenticated means can be used for the protectionAlg (e.g., password-based MAC, if shared secret information is known, or signature).",
      "ja": "D.6の付録D.4 9.すべてのPKIのメッセージ交換は、開始エンティティによって送信するcertConfメッセージと応答エンティティによって送信するPKIConfirmが必要です。その本体はNULLであり、そのヘッダの内容が文脈から明らかであるのでPKIConfirmは、所与のプロファイルの一部に含まれていません。任意の認証手段がprotectionAlg（例えば、パスワードベースのMAC、共有秘密情報が既知である場合、または署名）のために使用することができます。"
    },
    {
      "indent": 0,
      "text": "D.2. Algorithm Use Profile",
      "ja": "D.2。アルゴリズムを使用するプロファイル"
    },
    {
      "indent": 3,
      "text": "The following table contains definitions of algorithm uses within PKI management protocols. The columns in the table are:",
      "ja": "次の表は、アルゴリズムの定義は、PKI管理プロトコルの中に使用していますが含まれています。表の列は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Name: an identifier used for message profiles",
      "ja": "名前：メッセージプロファイルするための識別子"
    },
    {
      "indent": 3,
      "text": "Use: description of where and for what the algorithm is used",
      "ja": "使用：のアルゴリズムが使用されているものの説明を"
    },
    {
      "indent": 3,
      "text": "Mandatory: an AlgorithmIdentifier which MUST be supported by conforming implementations",
      "ja": "必須：準拠実装によってサポートされなければならないのAlgorithmIdentifier"
    },
    {
      "indent": 3,
      "text": "Others: alternatives to the mandatory AlgorithmIdentifier",
      "ja": "その他：必須のAlgorithmIdentifierの代替"
    },
    {
      "indent": 4,
      "text": "Name Use Mandatory Others",
      "ja": "必須のその他の使用に名前を付けます"
    },
    {
      "indent": 4,
      "text": "MSG_SIG_ALG Protection of PKI DSA/SHA-1 RSA/MD5, messages using signature ECDSA, ... MSG_MAC_ALG protection of PKI PasswordBasedMac HMAC, messages using MACing X9.9... SYM_PENC_ALG symmetric encryption of 3-DES (3-key- AES,RC5, an end entity's private EDE, CBC mode) CAST-128... key where symmetric key is distributed out-of-band PROT_ENC_ALG asymmetric algorithm D-H RSA, used for encryption of ECDH, ... (symmetric keys for encryption of) private keys transported in",
      "ja": "PKI DSA / SHA-1 RSA / MD5のMSG_SIG_ALG保護、署名ECDSAを使用してメッセージ、... PKI PasswordBasedMac HMACのMSG_MAC_ALG保護、MACing X9.9を使用してメッセージ... 3-DES（3-KEY- AESのSYM_PENC_ALG対称暗号化対称鍵は、の暗号化のためのアウトオブバンドPROT_ENC_ALG非対称アルゴリズムのDH ECDHの暗号化に使用されるRSA、...（対称鍵を配布され、RC5、エンドエンティティのプライベートEDE、CBCモード）CAST-128 ...キーで輸送）秘密鍵"
    },
    {
      "indent": 4,
      "text": " PKIMessages PROT_SYM_ALG symmetric encryption 3-DES (3-key- AES,RC5, algorithm used for EDE, CBC mode) CAST-128... encryption of private key bits (a key of this type is encrypted using PROT_ENC_ALG)",
      "ja": "PKIMessages PROT_SYM_ALG対称暗号3-DES（EDE、CBCモードのために使用される3-KEY- AES、RC5、アルゴリズム）CAST-128 ...秘密鍵のビット（このタイプのキーはPROT_ENC_ALGを使用して暗号化される）の暗号化"
    },
    {
      "indent": 3,
      "text": "Mandatory AlgorithmIdentifiers and Specifications:",
      "ja": "必須AlgorithmIdentifiersと仕様："
    },
    {
      "indent": 3,
      "text": "DSA/SHA-1: AlgId: {1 2 840 10040 4 3};",
      "ja": "DSA / SHA-1：AlgId：{1 2 840 10040 4 3}。"
    },
    {
      "indent": 3,
      "text": "Digital Signature Standard [FIPS-186]",
      "ja": "デジタル署名標準[FIPS-186]"
    },
    {
      "indent": 5,
      "text": "Public Modulus size: 1024 bits.",
      "ja": "公開モジュラスサイズ：1024ビット。"
    },
    {
      "indent": 3,
      "text": "PasswordBasedMac:",
      "ja": "PasswordBasedMac："
    },
    {
      "indent": 5,
      "text": "AlgId: {1 2 840 113533 7 66 13}, with SHA-1 {1 3 14 3 2 26} as the owf parameter and HMAC-SHA1 {1 3 6 1 5 5 8 1 2} as the mac parameter;",
      "ja": "AlgId：{1 2 840 113533 7 66 13}、OWFパラメータとMACパラメータとしてHMAC-SHA1 {1 3 6 1 5 8 1 2}としてSHA1 {1 3 14 3 2 26}を有します。"
    },
    {
      "indent": 5,
      "text": "(this specification), along with",
      "ja": "一緒に（本明細書）、"
    },
    {
      "indent": 3,
      "text": "Secure Hash Standard [FIPS-180] and [RFC2104]",
      "ja": "セキュアハッシュ標準[FIPS-180]と[RFC2104]を"
    },
    {
      "indent": 5,
      "text": "HMAC key size: 160 bits (i.e., \"K\" = \"H\" in Section 5.1.3.1, \"Shared secret information\")",
      "ja": "HMAC鍵サイズ：160ビット（セクション5.1.3.1で、すなわち、 \"K\" = \"H\"、 \"共有秘密情報\"）"
    },
    {
      "indent": 3,
      "text": "3-DES:",
      "ja": "3-DES："
    },
    {
      "indent": 5,
      "text": "AlgId: {1 2 840 113549 3 7}; (used in RSA's BSAFE and in S/MIME).",
      "ja": "AlgId：{1 2 840 113549 3 7}。 （RSA BSAFEの中やS / MIMEで使用）。"
    },
    {
      "indent": 3,
      "text": "D-H:",
      "ja": "D-H："
    },
    {
      "indent": 5,
      "text": "AlgId: {1 2 840 10046 2 1};",
      "ja": "AlgId：{1 2 840 10046 2 1}。"
    },
    {
      "indent": 3,
      "text": "[ANSI-X9.42]",
      "ja": "[ANSI-X9.42]"
    },
    {
      "indent": 5,
      "text": "Public Modulus Size:  1024 bits.\nDomainParameters ::= SEQUENCE {\n   p       INTEGER, -- odd prime, p=jq +1\n   g       INTEGER, -- generator, g^q = 1 mod p\n   q       INTEGER, -- prime factor of p-1\n   j       INTEGER OPTIONAL, -- cofactor, j>=2\n   validationParms  ValidationParms OPTIONAL",
      "raw": true
    },
    {
      "indent": 5,
      "text": "}\nValidationParms ::= SEQUENCE {\n   seed          BIT STRING, -- seed for prime generation\n   pGenCounter   INTEGER     -- parameter verification\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "D.3. Proof-of-Possession Profile",
      "ja": "D.3。実証の所持プロフィール"
    },
    {
      "indent": 3,
      "text": "POP fields for use (in signature field of pop field of ProofOfPossession structure) when proving possession of a private signing key that corresponds to a public verification key for which a certificate has been requested.",
      "ja": "（ProofOfPossession構造のポップ・フィールドの署名フィールドで）使用するPOPフィールド証明書が要求された公開検証鍵に対応する秘密署名鍵の所有を証明します。"
    },
    {
      "indent": 4,
      "text": "Field Value Comment",
      "ja": "フィールド値コメント"
    },
    {
      "indent": 4,
      "text": "algorithmIdentifier MSG_SIG_ALG only signature protection is allowed for this proof",
      "ja": "AlgorithmIdentifier MSG_SIG_ALGのみ署名保護は、この証明のために許可されています"
    },
    {
      "indent": 4,
      "text": "signature present bits calculated using MSG_SIG_ALG",
      "ja": "MSG_SIG_ALGを用いて計算署名本ビット"
    },
    {
      "indent": 3,
      "text": "Proof-of-possession of a private decryption key that corresponds to a public encryption key for which a certificate has been requested does not use this profile; the CertHash field of the certConf message is used instead.",
      "ja": "実証の所有証明書は、このプロファイルを使用していません要求された公開暗号鍵に対応する秘密復号鍵の。 certConfメッセージのCERTHASHフィールドが代わりに使用されます。"
    },
    {
      "indent": 3,
      "text": "Not every CA/RA will do Proof-of-Possession (of signing key, decryption key, or key agreement key) in the PKIX-CMP in-band certification request protocol (how POP is done MAY ultimately be a policy issue that is made explicit for any given CA in its publicized Policy OID and Certification Practice Statement). However, this specification MANDATES that CA/RA entities MUST do POP (by some means) as part of the certification process. All end entities MUST be prepared to provide POP (i.e., these components of the PKIX-CMP protocol MUST be supported).",
      "ja": "すべてのCA / RAは、帯域内の認証要求プロトコルPKIX-CMPにおける実証の所持（署名鍵、復号鍵、または鍵合意キーのを）やるわけではありません（POPがどのように行われるか、最終的に行われている政策課題かもしれその公表ポリシーOIDと認証実施規定）内の任意のCAを明示的に。しかし、CA / RAエンティティが認証プロセスの一環として、（何らかの手段で）POPを行う必要があります、この仕様の義務。すべてのエンドエンティティ（すなわち、PKIX-CMPプロトコルのこれらの構成要素がサポートしなければならない）POPを提供するために準備しなければなりません。"
    },
    {
      "indent": 0,
      "text": "D.4. Initial Registration/Certification (Basic Authenticated Scheme)",
      "ja": "D.4。初期登録/認証（基本認証スキーム）"
    },
    {
      "indent": 3,
      "text": "An (uninitialized) end entity requests a (first) certificate from a CA. When the CA responds with a message containing a certificate, the end entity replies with a certificate confirmation. The CA sends a PKIConfirm back, closing the transaction. All messages are authenticated.",
      "ja": "（初期化されていない）エンドエンティティがCAから（最初の）証明書を要求しますCAが証明書を含むメッセージで応答する場合、エンドエンティティは、証明書確認で応答します。 CAは、トランザクションを閉じ、バックPKIConfirmを送信します。すべてのメッセージが認証されます。"
    },
    {
      "indent": 3,
      "text": "This scheme allows the end entity to request certification of a locally-generated public key (typically a signature key). The end entity MAY also choose to request the centralized generation and certification of another key pair (typically an encryption key pair).",
      "ja": "このスキームは、エンドエンティティがローカルで生成された公開鍵（通常は署名鍵）の認証を要求することを可能にします。エンドエンティティは、別の鍵ペア（通常、暗号鍵ペア）の中央集中生成と認証を要求するために選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "Certification may only be requested for one locally generated public key (for more, use separate PKIMessages).",
      "ja": "認定は、唯一のローカルで生成された公開鍵のために要求することができる（詳細について、個別のPKIMessagesを使用します）。"
    },
    {
      "indent": 3,
      "text": "The end entity MUST support proof-of-possession of the private key associated with the locally-generated public key.",
      "ja": "エンドエンティティは、プルーフ・オブ・所持ローカルに生成した公開鍵に関連付けられた秘密鍵のをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 3,
      "text": "1. The end entity can authenticate the CA's signature based on out-of-band means",
      "ja": "1.エンドエンティティは、帯域外の手段に基づいてCAの署名を認証することができます"
    },
    {
      "indent": 3,
      "text": "2. The end entity and the CA share a symmetric MACing key",
      "section_title": true,
      "ja": "2.エンドエンティティとCAは、対称MACing鍵を共有します"
    },
    {
      "indent": 3,
      "text": "Message flow:",
      "ja": "メッセージフロー："
    },
    {
      "indent": 4,
      "text": "Step# End entity PKI 1 format ir 2 -> ir -> 3 handle ir 4 format ip 5 <- ip <- 6 handle ip 7 format certConf 8 -> certConf -> 9 handle certConf 10 format PKIConf 11 <- PKIConf <- 12 handle PKIConf",
      "ja": "ステップ＃エンドエンティティPKI 1フォーマットIR 2  - > IR  - > 3ハンドルIR 4フォーマットIP 5 < -  IP < -  6ハンドルIP 7形式certConf 8  - > certConf  - > 9ハンドルcertConf 10フォーマットPKIConf 11 < -  PKIConf < - 12ハンドルPKIConf"
    },
    {
      "indent": 3,
      "text": "For this profile, we mandate that the end entity MUST include all (i.e., one or two) CertReqMsg in a single PKIMessage, and that the PKI (CA) MUST produce a single response PKIMessage that contains the complete response (i.e., including the OPTIONAL second key pair, if it was requested and if centralized key generation is supported). For simplicity, we also mandate that this message MUST be the final one (i.e., no use of \"waiting\" status value).",
      "ja": "すなわち、オプションを含めて（このプロファイルのために、我々は、エンドエンティティが単一PKIMessage内のすべての（すなわち、1または2）CertReqMsgを含まなければならないことを義務付けること、およびPKI（CA）は、完全な応答を含む単一の応答PKIMessageを生成しなければなりませんそれは要求された場合、集中鍵生成がサポートされている場合）、第2の鍵ペア。簡単にするために、我々はまた、このメッセージは、最終的な1でなければならないことを義務付ける（すなわち、「待機中」のステータス値を用いません）。"
    },
    {
      "indent": 3,
      "text": "The end entity has an out-of-band interaction with the CA/RA. This transaction established the shared secret, the referenceNumber and OPTIONALLY the distinguished name used for both sender and subject name in the certificate template. It is RECOMMENDED that the shared secret be at least 12 characters long.",
      "ja": "エンドエンティティがCA / RAとアウトオブバンド相互作用を持っています。このトランザクションは、共有秘密を確立referenceNumberし、証明書テンプレートに差出人と件名名の両方に使用する識別名を任意で。共有秘密は、少なくとも12文字の長することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Initialization Request -- ir",
      "ja": "初期化要求 -  IR"
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "recipient CA name",
      "ja": "受信者CA名"
    },
    {
      "indent": 3,
      "text": " -- the name of the CA who is being asked to produce a certificate protectionAlg MSG_MAC_ALG -- only MAC protection is allowed for this request, based -- on initial authentication key senderKID referenceNum -- the reference number which the CA has previously issued -- to the end entity (together with the MACing key) transactionID present -- implementation-specific value, meaningful to end -- entity. -- [If already in use at the CA, then a rejection message MUST -- be produced by the CA]",
      "ja": " - 最初の認証キーsenderKID referenceNumに -   - 、唯一のMAC保護は、この要求のために許可されているベース -  CAが以前に発行された参照番号protectionAlg MSG_MAC_ALGは、証明書を生成するように要求されているCAの名前 - 実装固有の値、末尾に有意義 -   - エンティティ（共にMACingキーで）エンドエンティティトランザクションIDに存在します。 -  [すでに使用中のCAであれば、拒否メッセージがなければなりません -  CAによって製造すること]"
    },
    {
      "indent": 3,
      "text": "senderNonce present -- 128 (pseudo-)random bits freeText any valid value body ir (CertReqMessages) only one or two CertReqMsg are allowed -- if more certificates are required, requests MUST be -- packaged in separate PKIMessages",
      "ja": "senderNonce存在する - より多くの証明書が必要な場合、要求はしていなければなりません -   - 別PKIMessagesに包装128（擬似）ランダムビット（CertReqMessages）1つまたは2つCertReqMsgが許可されている任意の有効な値本体IRをフリーテキスト"
    },
    {
      "indent": 3,
      "text": "CertReqMsg one or two present -- see below for details, note: crm[0] means the first -- (which MUST be present), crm[1] means the second (which -- is OPTIONAL, and used to ask for a centrally-generated key)",
      "ja": "CertReqMsg一つまた​​は二つ存在する - 注意、詳細については下記を参照：CRM [0]第一の手段 - （存在しなければならない）、CRM [1]（第2を意味する - オプションとを求めるために使用され中央に生成されたキー）"
    },
    {
      "indent": 3,
      "text": "crm[0].certReq. fixed value of zero certReqId -- this is the index of the template within the message crm[0].certReq present certTemplate -- MUST include subject public key value, otherwise unconstrained crm[0].pop... optionally present if public key POPOSigningKey from crm[0].certReq.certTemplate is a signing key -- proof-of-possession MAY be required in this exchange -- (see Appendix D.3 for details) crm[0].certReq. optionally present controls.archiveOptions -- the end entity MAY request that the locally-generated -- private key be archived",
      "ja": "CRMは、[0] .certReq。ゼロcertReqIdの固定値 - これは[0] .certReq本CertTemplateのメッセージCRM内のテンプレートの指標である - サブジェクト公開鍵の値、そうでなければ非拘束CRMを含まなければなりません[0] .pop ...任意に存在する公開鍵場合CRMからPOPOSigningKey [0] .certReq.certTemplateは、署名鍵である - 実証の所有この交換に必要とされ得る - （詳細については、付録D.3を参照）CRM [0] .certReq。任意に存在するcontrols.archiveOptions  - ローカルで生成されたエンドエンティティMAY要求 - プライベートキーをアーカイブします"
    },
    {
      "indent": 3,
      "text": "crm[0].certReq. optionally present controls.publicationInfo -- the end entity MAY ask for publication of resulting cert.",
      "ja": "CRMは、[0] .certReq。任意に存在controls.publicationInfo  - エンドエンティティの証明書を得られたの出版を求めることができます。"
    },
    {
      "indent": 3,
      "text": "crm[1].certReq fixed value of one",
      "ja": "CRMは、[1]一方の固定値を.certReq"
    },
    {
      "indent": 3,
      "text": " certReqId -- the index of the template within the message crm[1].certReq present certTemplate -- MUST NOT include actual public key bits, otherwise -- unconstrained (e.g., the names need not be the same as in -- crm[0]). Note that subjectPublicKeyInfo MAY be present -- and contain an AlgorithmIdentifier followed by a -- zero-length BIT STRING for the subjectPublicKey if it is -- desired to inform the CA/RA of algorithm and parameter -- preferences regarding the to-be-generated key pair.",
      "ja": "certReqId  - メッセージ、CRM内のテンプレートのインデックス[1] .certReq本CertTemplateの - そうでなければ、実際の公開鍵のビットを含んではいけません - 拘束されない（例えば、名前はと同じである必要はない -  CRM [0 ]）。そして、続いてのAlgorithmIdentifierが含まれている -   - された場合のsubjectPublicKeyゼロ長のビット列 - アルゴリズムとパラメータのCA / RAを通知するために、所望 -  SubjectPublicKeyInfoでは存在してもよいことに注意-BE-へに関する嗜好鍵ペアを生成しました。"
    },
    {
      "indent": 3,
      "text": "crm[1].certReq. present [object identifier MUST be PROT_ENC_ALG]",
      "ja": "CRMは、[1] .certReq。本【オブジェクト識別子でなければなりませんPROT_ENC_ALG]"
    },
    {
      "indent": 5,
      "text": " controls.protocolEncrKey -- if centralized key generation is supported by this CA, -- this short-term asymmetric encryption key (generated by -- the end entity) will be used by the CA to encrypt (a -- symmetric key used to encrypt) a private key generated by -- the CA on behalf of the end entity",
      "ja": "controls.protocolEncrKey  - 集中鍵生成は、このCAによってサポートされている場合 - （によって生成された - エンドエンティティ）この短期非対称暗号化キーは、暗号化するためにCAによって使用される（暗号化するために使用される非対称鍵）によって生成された秘密鍵 - エンドエンティティに代わってCA"
    },
    {
      "indent": 3,
      "text": "crm[1].certReq. optionally present controls.archiveOptions crm[1].certReq. optionally present controls.publicationInfo protection present -- bits calculated using MSG_MAC_ALG",
      "ja": "CRMは、[1] .certReq。任意に存在controls.archiveOptionsのCRM [1] .certReq。任意に存在controls.publicationInfo保護現在 -  MSG_MAC_ALGを用いて算出ビット"
    },
    {
      "indent": 3,
      "text": "Initialization Response -- ip",
      "ja": "初期化応答 -  IP"
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "sender CA name -- the name of the CA who produced the message messageTime present -- time at which CA produced message protectionAlg MS_MAC_ALG -- only MAC protection is allowed for this response senderKID referenceNum -- the reference number that the CA has previously issued to the -- end entity (together with the MACing key) transactionID present -- value from corresponding ir message senderNonce present -- 128 (pseudo-)random bits recipNonce present -- value from senderNonce in corresponding ir message freeText any valid value body ip (CertRepMessage) contains exactly one response for each request",
      "ja": "送信者CA名 - メッセージmessageTimeの存在を作り出したCAの名前 -  CAがメッセージprotectionAlg MS_MAC_ALGを生成する時間 - のみMAC保護は、この応答senderKID referenceNumのために許可されている - 参照番号CAが以前に発行されたこと - 対応するIRメッセージsenderNonce存在から値 -   -  128（擬似）ランダムビットrecipNonce存在 -  IRメッセージを対応でsenderNonceから値任意の有効な値本体IPをFREETEXT（エンドエンティティは（一緒にMACingキーで）存在するTRANSACTIONID CertRepMessage）要求ごとに正確に一つの回答が含まれています"
    },
    {
      "indent": 3,
      "text": " -- The PKI (CA) responds to either one or two requests as -- appropriate. crc[0] denotes the first (always present); -- crc[1] denotes the second (only present if the ir message -- contained two requests and if the CA supports centralized -- key generation). crc[0]. fixed value of zero certReqId -- MUST contain the response to the first request in the -- corresponding ir message",
      "ja": " - 適切 -  PKI（CA）のような1つのまたは2つの要求に応答します。 CRC [0]（常に存在する）最初を示し、 （鍵生成 -   -  2つの要求を含み、CA集中をサポートしている場合、IRメッセージは次の場合のみ存在する） -  CRC [1]秒です。 CRC [0]。ゼロcertReqIdの固定値 - 対応するIRメッセージ - の最初の要求に対する応答を含まなければなりません"
    },
    {
      "indent": 3,
      "text": "crc[0].status. present, positive values allowed: status \"accepted\", \"grantedWithMods\" negative values allowed: \"rejection\" crc[0].status. present if and only if failInfo crc[0].status.status is \"rejection\" crc[0]. present if and only if certifiedKeyPair crc[0].status.status is \"accepted\" or \"grantedWithMods\" certificate present unless end entity's public key is an encryption key and POP is done in this in-band exchange encryptedCert present if and only if end entity's public key is an encryption key and POP done in this in-band exchange publicationInfo optionally present",
      "ja": "CRCは[0] .status。現在、正の値は許さ：ステータス \"受け入れ\"、 \"grantedWithMods\" 負の値は許され： \"拒否\" CRC [0] .status。存在する場合とfailInfoのCRC [0] .status.statusである場合にのみ、 \"拒否\"、CRC [0]。存在場合に限りcertifiedKeyPairのCRC [0] .status.statusは「受け入れられた」または「grantedWithMods」証明書の存在エンドエンティティの公開鍵は、暗号化キーがあるとPOPが存在する場合、このインバンド交換encryptedCertで行われない限り、端部のみの場合エンティティの公開鍵は、任意に存在するこのインバンド交換publicationInfoで行われた暗号鍵とPOPです"
    },
    {
      "indent": 5,
      "text": "-- indicates where certificate has been published (present -- at discretion of CA)",
      "ja": " - 証明書が発行されている場所を示す（存在 -  CAの裁量で）"
    },
    {
      "indent": 3,
      "text": "crc[1]. fixed value of one certReqId -- MUST contain the response to the second request in the -- corresponding ir message crc[1].status. present, positive values allowed: status \"accepted\", \"grantedWithMods\" negative values allowed: \"rejection\" crc[1].status. present if and only if failInfo crc[0].status.status is \"rejection\" crc[1]. present if and only if certifiedKeyPair crc[0].status.status is \"accepted\" or \"grantedWithMods\" certificate present privateKey present -- see Appendix C, Request Message Behavioral Clarifications publicationInfo optionally present -- indicates where certificate has been published (present -- at discretion of CA)",
      "ja": "CRC [1]。 1 certReqIdの固定値 -  [1] .status対応するIRメッセージのCRC  - で第2の要求に対する応答を含まなければなりません。現在、正の値は許さ：ステータス \"受け入れ\"、 \"grantedWithMods\" 負の値は許され： \"拒否\" CRC [1] .status。存在する場合とfailInfoのCRC [0] .status.statusである場合にのみ、 \"拒否\"、CRC [1]。存在する場合にのみcertifiedKeyPairのCRC [0] .status.statusが「受け入れ」または「grantedWithMods」証明書現在のPrivateKey存在 - 付録Cを参照して、メッセージ行動明確化publicationInfo任意に存在するが、要求 - 証明書（現在公開されている場所を示します -  - ）CAの裁量で"
    },
    {
      "indent": 3,
      "text": "protection present -- bits calculated using MSG_MAC_ALG extraCerts optionally present -- the CA MAY provide additional certificates to the end -- entity",
      "ja": "保護存在する - 任意に存在MSG_MAC_ALGのextraCertsを用いて算出ビット -  CAが終わりに追加の証明書を提供してもよい（MAY） - エンティティ"
    },
    {
      "indent": 3,
      "text": "Certificate confirm; certConf",
      "ja": "証明書の確認。 certConf"
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "sender present -- same as in ir recipient CA name -- the name of the CA who was asked to produce a certificate transactionID present -- value from corresponding ir and ip messages senderNonce present -- 128 (pseudo-) random bits recipNonce present -- value from senderNonce in corresponding ip message protectionAlg MSG_MAC_ALG -- only MAC protection is allowed for this message. The -- MAC is based on the initial authentication key shared -- between the EE and the CA.",
      "ja": "センダ本 -  IR受信者CA名と同じ - 証明書トランザクションIDの存在を生成するように頼まれたCAの名称 -  IRおよびIPメッセージsenderNonce存在する対応の値 -  128（擬似）ランダムビットrecipNonce存在 -  - 対応するIPメッセージprotectionAlg MSG_MAC_ALGでsenderNonceから値 - のみMAC保護は、このメッセージのために許可されています。 -  EEとCAの間 -  MACは、共有初期認証キーに基づいています"
    },
    {
      "indent": 3,
      "text": "senderKID referenceNum -- the reference number which the CA has previously issued -- to the end entity (together with the MACing key)",
      "ja": "senderKID referenceNum  - エンドエンティティに（一緒にMACingキー付き） -  CAが以前に発行された参照番号"
    },
    {
      "indent": 3,
      "text": "body certConf -- see Section 5.3.18, \"PKI Confirmation Content\", for the -- contents of the certConf fields. -- Note: two CertStatus structures are required if both an -- encryption and a signing certificate were sent.",
      "ja": "ボディcertConf  -  certConfフィールドの内容 - のために、セクション5.3.18、「PKI確認コンテンツ」を参照してください。 - 注：両方の場合は2つのにCertStatus構造が必要とされている - 暗号化と署名証明書が送られました。"
    },
    {
      "indent": 3,
      "text": "protection present -- bits calculated using MSG_MAC_ALG",
      "ja": "保護現在 -  MSG_MAC_ALGを用いて算出ビット"
    },
    {
      "indent": 3,
      "text": "Confirmation; PKIConf",
      "ja": "確認; PKIConf"
    },
    {
      "indent": 3,
      "text": "Field Value sender present -- same as in ip recipient present -- sender name from certConf transactionID present -- value from certConf message senderNonce present -- 128 (pseudo-) random bits recipNonce present -- value from senderNonce from certConf message protectionAlg MSG_MAC_ALG -- only MAC protection is allowed for this message. senderKID referenceNum body PKIConf protection present -- bits calculated using MSG_MAC_ALG",
      "ja": "フィールド値送信元現在 -  certConfメッセージsenderNonce存在から値 -   -  certConfトランザクションIDの存在から送信者名 -  128（擬似）ランダムビットrecipNonce存在 -  certConfメッセージprotectionAlg MSG_MAC_ALGからsenderNonceから値Ipレシピエント中に存在すると同じ -  - 唯一のMAC保護は、このメッセージのために許可されています。 senderKID referenceNum本体PKIConf保護現在 -  MSG_MAC_ALGを用いて算出ビット"
    },
    {
      "indent": 0,
      "text": "D.5. Certificate Request",
      "ja": "D.5。証明書要求"
    },
    {
      "indent": 3,
      "text": "An (initialized) end entity requests a certificate from a CA (for any reason). When the CA responds with a message containing a certificate, the end entity replies with a certificate confirmation. The CA replies with a PKIConfirm, to close the transaction. All messages are authenticated.",
      "ja": "（初期化）エンドエンティティが（何らかの理由で）CAから証明書を要求します。 CAが証明書を含むメッセージで応答する場合、エンドエンティティは、証明書確認で応答します。 CAは、トランザクションを閉じるには、PKIConfirmで応答します。すべてのメッセージが認証されます。"
    },
    {
      "indent": 3,
      "text": "The profile for this exchange is identical to that given in Appendix D.4, with the following exceptions:",
      "ja": "この交換のためのプロファイルは、次の例外を除いて、付録D.4に与えられたものと同一であります："
    },
    {
      "indent": 3,
      "text": "o sender name SHOULD be present",
      "ja": "O送信者名が存在すべきである（SHOULD）"
    },
    {
      "indent": 3,
      "text": "o protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY also be supported) in request, response, certConfirm, and PKIConfirm messages;",
      "ja": "O MSG_SIG_ALGのprotectionAlgは、要求、応答、certConfirm、及びPKIConfirmメッセージで（MSG_MAC_ALGもサポートすることができる）をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "o senderKID and recipKID are only present if required for message verification;",
      "ja": "O senderKIDとrecipKIDは、メッセージ検証のために必要な場合にのみ存在します。"
    },
    {
      "indent": 3,
      "text": "o body is cr or cp;",
      "ja": "O体は、CrやCPです。"
    },
    {
      "indent": 3,
      "text": "o body may contain one or two CertReqMsg structures, but either CertReqMsg may be used to request certification of a locally-generated public key or a centrally-generated public key (i.e., the position-dependence requirement of Appendix D.4 is removed);",
      "ja": "O本体は、1つのまたは2つのCertReqMsg構造を含んでいてもよいが、いずれかCertReqMsgは、ローカルに生成された公開鍵又は中央に生成された公開鍵（すなわち、付録D.4の位置依存性の要件が除去される）の認証を要求するために使用されてもよいです。"
    },
    {
      "indent": 3,
      "text": "o protection bits are calculated according to the protectionAlg field.",
      "ja": "O保護ビットはprotectionAlgフィールドに従って計算されます。"
    },
    {
      "indent": 0,
      "text": "D.6. Key Update Request",
      "ja": "D.6。鍵更新要求"
    },
    {
      "indent": 3,
      "text": "An (initialized) end entity requests a certificate from a CA (to update the key pair and/or corresponding certificate that it already possesses). When the CA responds with a message containing a certificate, the end entity replies with a certificate confirmation. The CA replies with a PKIConfirm, to close the transaction. All messages are authenticated.",
      "ja": "（初期化）エンドエンティティが（それが既に所有している鍵のペアおよび/または対応する証明書を更新するために）CAから証明書を要求します。 CAが証明書を含むメッセージで応答する場合、エンドエンティティは、証明書確認で応答します。 CAは、トランザクションを閉じるには、PKIConfirmで応答します。すべてのメッセージが認証されます。"
    },
    {
      "indent": 3,
      "text": "The profile for this exchange is identical to that given in Appendix D.4, with the following exceptions:",
      "ja": "この交換のためのプロファイルは、次の例外を除いて、付録D.4に与えられたものと同一であります："
    },
    {
      "indent": 3,
      "text": "1. sender name SHOULD be present",
      "section_title": true,
      "ja": "1.送信者名が存在すべきである（SHOULD）"
    },
    {
      "indent": 3,
      "text": "2. protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY also be supported) in request, response, certConfirm, and PKIConfirm messages;",
      "ja": "MSG_SIG_ALGの2 protectionAlgは、要求、応答、certConfirm、及びPKIConfirmメッセージで（MSG_MAC_ALGもサポートすることができる）をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. senderKID and recipKID are only present if required for message verification;",
      "ja": "3. senderKIDとrecipKIDは、メッセージ検証のために必要な場合にのみ存在します。"
    },
    {
      "indent": 3,
      "text": "4. body is kur or kup;",
      "section_title": true,
      "ja": "4.体はKURまたはKUPです。"
    },
    {
      "indent": 3,
      "text": "5. body may contain one or two CertReqMsg structures, but either CertReqMsg may be used to request certification of a locally-generated public key or a centrally-generated public key (i.e., the position-dependence requirement of Appendix D.4 is removed);",
      "ja": "前記本体は、1つのまたは2つのCertReqMsg構造を含んでいてもよいが、いずれかCertReqMsgがローカルに生成した公開鍵または中央に生成された公開鍵の証明書を要求するために使用されてもよい（すなわち、付録D.4の位置依存性の要件が除去されます） ;"
    },
    {
      "indent": 3,
      "text": "6. protection bits are calculated according to the protectionAlg field;",
      "ja": "前記保護ビットはprotectionAlgフィールドに従って計算されます。"
    },
    {
      "indent": 3,
      "text": "7. regCtrl OldCertId SHOULD be used (unless it is clear to both sender and receiver -- by means not specified in this document -- that it is not needed).",
      "ja": "（それは送信者と受信者の両方に明らかでない限り - この文書で指定されていない手段によって - それが必要とされないこと）7. regCtrl OldCertIdを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "Appendix E. PKI Management Message Profiles (OPTIONAL).",
      "ja": "付録E. PKI管理メッセージプロファイル（オプション）。"
    },
    {
      "indent": 3,
      "text": "This appendix contains detailed profiles for those PKIMessages that MAY be supported by implementations (in addition to the messages which MUST be supported; see Section 6 and Appendix D).",
      "ja": "この付録では、（;第6章および付録Dを参照してサポートしなければならないメッセージに加えて）実装によってサポートされるかもしれそれらPKIMessagesの詳細なプロファイルを含みます。"
    },
    {
      "indent": 3,
      "text": "Profiles for the PKIMessages used in the following PKI management operations are provided:",
      "ja": "以下のPKI管理操作で使用PKIMessagesのプロファイルが用意されています。"
    },
    {
      "indent": 3,
      "text": "o root CA key update",
      "ja": "OルートCA鍵の更新"
    },
    {
      "indent": 3,
      "text": "o information request/response o cross-certification request/response (1-way)",
      "ja": "相互認証の要求/応答（1ウェイ）O O情報要求/応答"
    },
    {
      "indent": 3,
      "text": "o in-band initialization using external identity certificate",
      "ja": "外部ID証明書を使用してO帯域内の初期化"
    },
    {
      "indent": 3,
      "text": "Later versions of this document may extend the above to include profiles for the operations listed below (along with other operations, if desired).",
      "ja": "（所望であれば、他の操作と一緒に）は、この文書の後のバージョンは、以下の操作のプロファイルを含むことが上記延びてもよいです。"
    },
    {
      "indent": 3,
      "text": "o revocation request",
      "ja": "Oの取り消し要求"
    },
    {
      "indent": 3,
      "text": "o certificate publication",
      "ja": "O証明書発行"
    },
    {
      "indent": 3,
      "text": "o CRL publication",
      "ja": "シールの出版"
    },
    {
      "indent": 0,
      "text": "E.1. General Rules for Interpretation of These Profiles.",
      "ja": "E.1。これらのプロファイルの解釈のための一般的なルール。"
    },
    {
      "indent": 3,
      "text": "Identical to Appendix D.1.",
      "ja": "付録D.1と同じです。"
    },
    {
      "indent": 0,
      "text": "E.2. Algorithm Use Profile",
      "ja": "E.2。アルゴリズムを使用するプロファイル"
    },
    {
      "indent": 3,
      "text": "Identical to Appendix D.2.",
      "ja": "付録D.2と同じです。"
    },
    {
      "indent": 0,
      "text": "E.3. Self-Signed Certificates",
      "ja": "E.3。自己署名証明書"
    },
    {
      "indent": 3,
      "text": "Profile of how a Certificate structure may be \"self-signed\". These structures are used for distribution of CA public keys. This can occur in one of three ways (see Section 4.4 above for a description of the use of these structures):",
      "ja": "証明書の構造は、「自己署名」することができる方法のプロフィール。これらの構造は、CAの公開鍵を配布するために使用されています。これは、次の3つの方法（これらの構造体の使用の説明については、上記のセクション4.4を参照）のいずれかで発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Type          Function\n-----------------------------------------------------------------\nnewWithNew a true \"self-signed\" certificate; the contained\n           public key MUST be usable to verify the signature\n           (though this provides only integrity and no\n           authentication whatsoever)\noldWithNew previous root CA public key signed with new private key\nnewWithOld new root CA public key signed with previous private key",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Such certificates (including relevant extensions) must contain \"sensible\" values for all fields. For example, when present, subjectAltName MUST be identical to issuerAltName, and, when present, keyIdentifiers must contain appropriate values, et cetera.",
      "ja": "（関連する拡張を含む）このような証明書は、すべてのフィールドの「賢明な」値が含まれている必要があります。例えば、存在する場合、のsubjectAltNameはissuerAltNameと同一でなければならない、そして、存在する場合、keyIdentifiersはエトセトラ適切な値を含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "E.4. Root CA Key Update",
      "ja": "E.4。ルートCAキー更新"
    },
    {
      "indent": 3,
      "text": "A root CA updates its key pair. It then produces a CA key update announcement message that can be made available (via some transport mechanism) to the relevant end entities. A confirmation message is NOT REQUIRED from the end entities.",
      "ja": "ルートCAは、その鍵ペアを更新します。これは、関連するエンド・エンティティに（一部のトランスポート機構を介して）利用することができるCAの鍵更新通知メッセージを生成します。確認メッセージは、エンドエンティティから必要ありません。"
    },
    {
      "indent": 3,
      "text": "ckuann message:",
      "ja": "ckuannメッセージ："
    },
    {
      "indent": 3,
      "text": " Field        Value                        Comment\n--------------------------------------------------------------\n sender       CA name CA name\n body         ckuann(CAKeyUpdAnnContent)\n oldWithNew   present                  see Appendix E.3 above\n newWithOld   present                  see Appendix E.3 above\n newWithNew   present                  see Appendix E.3 above\n extraCerts   optionally present       can be used to \"publish\"\n                                       certificates (e.g.,\n                                       certificates signed using\n                                       the new private key)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "E.5. PKI Information Request/Response",
      "ja": "E.5。 PKI情報リクエスト/レスポンス"
    },
    {
      "indent": 3,
      "text": "The end entity sends a general message to the PKI requesting details that will be required for later PKI management operations. RA/CA responds with a general response. If an RA generates the response, then it will simply forward the equivalent message that it previously received from the CA, with the possible addition of certificates to the extraCerts fields of the PKIMessage. A confirmation message is NOT REQUIRED from the end entity.",
      "ja": "エンドエンティティは、後にPKI管理操作のために必要とされるPKI要求内容に一般的なメッセージを送信します。 RA / CAは、一般的な応答で応答します。 RAは、応答を生成した場合、それは単にPKIMessageのextraCertsフィールドに証明書の可能加えて、それは以前にCAから受信した同等のメッセージを転送します。確認メッセージは、エンドエンティティから必要ありません。"
    },
    {
      "indent": 3,
      "text": "Message Flows:",
      "ja": "メッセージ・フロー："
    },
    {
      "indent": 3,
      "text": "Step# End entity PKI",
      "ja": "ステップ＃エンドエンティティPKI"
    },
    {
      "indent": 6,
      "text": "1 format genm 2 -> genm -> 3 handle genm 4 produce genp 5 <- genp <- 6 handle genp",
      "ja": "1フォーマットgenm 2  - > genm  - > 3ハンドルgenm 4農産物genp 5 < -  genp < -  6ハンドルgenp"
    },
    {
      "indent": 3,
      "text": "genM:",
      "ja": "genM："
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "recipient CA name -- the name of the CA as contained in issuerAltName",
      "ja": "受信者CA名 -  issuerAltNameに含まれるCAの名前"
    },
    {
      "indent": 3,
      "text": " -- extensions or issuer fields within certificates protectionAlg MSG_MAC_ALG or MSG_SIG_ALG -- any authenticated protection alg. SenderKID present if required -- must be present if required for verification of message -- protection freeText any valid value body genr (GenReqContent) GenMsgContent empty SEQUENCE -- all relevant information requested protection present -- bits calculated using MSG_MAC_ALG or MSG_SIG_ALG",
      "ja": " - 証明書protectionAlg MSG_MAC_ALGまたはMSG_SIG_ALG内の拡張や発行者フィールド - 任意の認証された保護ALG。メッセージの検証に必要な場合に存在しなければならない -   -  MSG_MAC_ALG又はMSG_SIG_ALGを用いて算出ビット - すべての関連情報要求保護現在 - 保護フリーテキスト任意の有効な値本体GENR（GenReqContent）空のシーケンスをGenMsgContent必要に応じて存在するSenderKID"
    },
    {
      "indent": 3,
      "text": "genP:",
      "ja": "GENP："
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "sender CA name -- name of the CA which produced the message protectionAlg MSG_MAC_ALG or MSG_SIG_ALG -- any authenticated protection alg. senderKID present if required -- must be present if required for verification of message -- protection body genp (GenRepContent) CAProtEncCert present (object identifier one of PROT_ENC_ALG), with relevant value -- to be used if end entity needs to encrypt information for -- the CA (e.g., private key for recovery purposes)",
      "ja": "送信者CA名 - 任意の認証された保護ALG  - メッセージprotectionAlg MSG_MAC_ALGまたはMSG_SIG_ALGを生産したCAの名前。 senderKID本必要に応じて - 関連値と、保護体genp（GenRepContent）CAProtEncCert存在する（オブジェクト識別子PROT_ENC_ALGの1つ） -   - エンドエンティティのための情報を暗号化する必要がある場合に使用されるメッセージの検証に必要な場合に存在しなければなりません -  -  CA（例えば、復旧のための秘密鍵）"
    },
    {
      "indent": 3,
      "text": "SignKeyPairTypes present, with relevant value -- the set of signature algorithm identifiers that this CA will -- certify for subject public keys EncKeyPairTypes present, with relevant value -- the set of encryption/key agreement algorithm identifiers that -- this CA will certify for subject public keys PreferredSymmAlg present (object identifier one of PROT_SYM_ALG) , with relevant value -- the symmetric algorithm that this CA expects to be used -- in later PKI messages (for encryption) CAKeyUpdateInfo optionally present, with relevant value -- the CA MAY provide information about a relevant root CA -- key pair using this field (note that this does not imply -- that the responding CA is the root CA in question) CurrentCRL optionally present, with relevant value",
      "ja": "関連する値を有する本SignKeyPairTypes、 - 関連する値で、対象の公開鍵EncKeyPairTypes存在のための証明 -   - このCAがために認定する - 暗号化/キー合意アルゴリズム識別子のセットを、このCAがします署名アルゴリズム識別子のセット関連値を有する対象の公開鍵PreferredSymmAlg本（オブジェクト識別子PROT_SYM_ALGの1つ）、 - 関連する値と、それ以降のPKIメッセージで（暗号化用）、任意に存在CAKeyUpdateInfo  -   - このCAが使用されることを期待する対称アルゴリズムCA MAY関連するルートCAに関する情報を提供する - このフィールドを使用して、鍵ペア（これは意味しないことに注意してください - 応答CAが当該ルートCAであること）関連値と、任意に存在CurrentCRL"
    },
    {
      "indent": 3,
      "text": " -- the CA MAY provide a copy of a complete CRL (i.e., -- fullest possible one) protection present -- bits calculated using MSG_MAC_ALG or MSG_SIG_ALG extraCerts optionally present -- can be used to send some certificates to the end -- entity. An RA MAY add its certificate here.",
      "ja": " -  CAは、完全なCRLのコピーを提供する（すなわち、 - 最大限可能なもの）の保護本 -  MSG_MAC_ALG又はMSG_SIG_ALG extraCerts任意に存在を使用して計算ビットは - エンティティ - 端部にいくつかの証明書を送信するために使用することができます。 RAは、ここにその証明書を追加するかもしれません。"
    },
    {
      "indent": 0,
      "text": "E.6. Cross Certification Request/Response (1-way)",
      "ja": "E.6。相互認証要求/応答（1ウェイ）"
    },
    {
      "indent": 3,
      "text": "Creation of a single cross-certificate (i.e., not two at once). The requesting CA MAY choose who is responsible for publication of the cross-certificate created by the responding CA through use of the PKIPublicationInfo control.",
      "ja": "単一のクロス証明書の作成（すなわち、しない2で1回）。要求CAはPKIPublicationInfoコントロールを使用して応答CAによって作成されたクロス証明書の発行責任者選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 3,
      "text": "1. Responding CA can verify the origin of the request (possibly requiring out-of-band means) before processing the request.",
      "ja": "要求の発信元を確認することができる。1.応答CAは要求を処理する前に（おそらく、帯域外の意味必要）。"
    },
    {
      "indent": 3,
      "text": "2. Requesting CA can authenticate the authenticity of the origin of the response (possibly requiring out-of-band means) before processing the response",
      "ja": "2. CAを要求する応答を処理する前に（おそらく帯域外要求手段）応答の起源の真正性を認証することができます"
    },
    {
      "indent": 3,
      "text": "The use of certificate confirmation and the corresponding server confirmation is determined by the generalInfo field in the PKIHeader (see Section 5.1.1). The following profile does not mandate support for either confirmation.",
      "ja": "証明書確認及び対応するサーバ確認の使用はPKIHeader（セクション5.1.1を参照）generalInfoフィールドによって決定されます。次のプロファイルは、どちらかの確認のためのサポートを強制しません。"
    },
    {
      "indent": 3,
      "text": "Message Flows:",
      "ja": "メッセージ・フロー："
    },
    {
      "indent": 3,
      "text": "Step# Requesting CA Responding CA 1 format ccr 2 -> ccr -> 3 handle ccr 4 produce ccp 5 <- ccp <- 6 handle ccp",
      "ja": "> CCR  -   - > 3ハンドルCCR 4農産物CCP 5 < -  CCP < -  6ハンドルCCPステップ＃CA 1フォーマットCCR 2を応答CAの要求"
    },
    {
      "indent": 3,
      "text": "ccr:",
      "ja": "CCR："
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "sender Requesting CA name -- the name of the CA who produced the message recipient Responding CA name -- the name of the CA who is being asked to produce a certificate messageTime time of production of message",
      "ja": "CA名を対応メッセージの受信者を作成したCAの名前 -   - メッセージの生産の証明書messageTime時間を生成するように要求されているCAの名前CA名を要求する送信者"
    },
    {
      "indent": 3,
      "text": " -- current time at requesting CA protectionAlg MSG_SIG_ALG -- only signature protection is allowed for this request senderKID present if required -- must be present if required for verification of message -- protection recipKID present if required -- must be present if required for verification of message -- protection transactionID present -- implementation-specific value, meaningful to requesting CA. -- [If already in use at responding CA then a rejection message -- MUST be produced by responding CA] senderNonce present -- 128 (pseudo-)random bits freeText any valid value body ccr (CertReqMessages) only one CertReqMsg allowed -- if multiple cross certificates are required, they MUST be -- packaged in separate PKIMessages certTemplate present -- details follow version v1 or v3 -- v3 STRONGLY RECOMMENDED signingAlg present -- the requesting CA must know in advance with which algorithm it -- wishes the certificate to be signed",
      "ja": " - 現在時刻がCA protectionAlg MSG_SIG_ALGを要求する時に - 必要であれば、この要求は、本senderKIDのみ署名保護が許可されている - 必要であれば保護が存在recipKID  -   - メッセージの検証に必要な場合に存在しなければならない検証するために必要な場合に存在しなければなりません保護トランザクションIDの存在 -   - メッセージの要求CAに実装固有の値で、意味のありますsenderNonce本 -  [CA応答することによって生成されなければならない既に次に拒否メッセージをCA応答での使用に場合]  -   -  128（擬似）ランダムビットは任意の有効な値体CCR（CertReqMessages）をフリーテキストのみCertReqMsgが許可 - 場合複数のクロス証明書は、彼らがしなければならない要求されている - 別のPKIMessages CertTemplateの存在にパッケージ - 詳細はバージョンV1またはV3に従ってください - を強くお勧めv3のsigningAlgの存在 - 要求CAは、アルゴリズムを持つ事前に知っていなければならない - 証明書を希望します署名されます"
    },
    {
      "indent": 3,
      "text": "subject present -- may be NULL-DN only if subjectAltNames extension value proposed validity present -- MUST be completely specified (i.e., both fields present) issuer present -- may be NULL-DN only if issuerAltNames extension value proposed publicKey present -- the key to be certified (which must be for a signing algorithm) extensions optionally present -- a requesting CA must propose values for all extensions -- that it requires to be in the cross-certificate POPOSigningKey present -- see Section D3: Proof-of-possession profile protection present -- bits calculated using MSG_SIG_ALG extraCerts optionally present -- MAY contain any additional certificates that requester wishes -- to include",
      "ja": "被験者本 -  NULL-DNであってもよいsubjectAltNamesを拡張値提案されている場合にのみ有効現在 - 完全に指定されなければならない（すなわち、本両方のフィールド）発行者の存在は -  issuerAltNames拡張値が公開鍵存在を提案した場合にのみNULL-DNであってもよいです - （署名アルゴリズムのためでなければならない）認定する鍵拡張必要に応じて存在 - 要求CAは、すべての拡張機能の値を提案しなければならない - それは、クロス証明書POPOSigningKey存在であることが必要であること - 第D3を参照してください実証の-possessionプロファイル保護現在 - 任意に存在MSG_SIG_ALG extraCertsを用いて計算したビット - 含めるように - 要求者が希望する任意の追加の証明書を含むかもしれ"
    },
    {
      "indent": 3,
      "text": "ccp:",
      "ja": "CCP："
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "sender Responding CA name -- the name of the CA who produced the message recipient Requesting CA name -- the name of the CA who asked for production of a certificate messageTime time of production of message -- current time at responding CA protectionAlg MSG_SIG_ALG -- only signature protection is allowed for this message senderKID present if required -- must be present if required for verification of message -- protection recipKID present if required transactionID present -- value from corresponding ccr message senderNonce present -- 128 (pseudo-)random bits recipNonce present -- senderNonce from corresponding ccr message freeText any valid value body ccp (CertRepMessage) only one CertResponse allowed -- if multiple cross certificates are required they MUST be -- packaged in separate PKIMessages response present status present",
      "ja": "送信側の対応CA名 - メッセージの生産の証明書messageTime時間の生産のために尋ねたCAの名前 -   -  CA名を要求するメッセージの受信者を作成したCAの名前CA protectionAlg MSG_SIG_ALG応答における現在の時間 - メッセージの検証に必要な場合に存在しなければならない -   - 値に対応するCCRメッセージsenderNonce存在から -   - 保護が存在TRANSACTIONID必要であれば、本recipKID必要な場合にのみ署名保護がこのメッセージに存在senderKID許可さ128（擬似）ランダムビットrecipNonce存在 - 複数のクロス証明書が必要な場合、それらがなければなりません -   - 別PKIMessagesに包装現状存在を応答senderNonce CCRメッセージを対応からは、許容唯一CertResponseは任意の有効な値体CCP（CertRepMessage）をフリーテキスト"
    },
    {
      "indent": 3,
      "text": "PKIStatusInfo.status present -- if PKIStatusInfo.status is one of: -- accepted, or -- grantedWithMods, -- then certifiedKeyPair MUST be present and failInfo MUST -- be absent",
      "ja": "PKIStatusInfo.status存在 -  PKIStatusInfo.statusは、のいずれかである場合： - 受け入れ、又は -  grantedWithMods、 - 次いでcertifiedKeyPairが存在していなければなりませんとfailInfoがなければなりません - 存在しないこと"
    },
    {
      "indent": 3,
      "text": "failInfo present depending on PKIStatusInfo.status -- if PKIStatusInfo.status is: -- rejection -- then certifiedKeyPair MUST be absent and failInfo MUST be -- present and contain appropriate bit settings",
      "ja": "PKIStatusInfo.statusに応じfailInfo存在 -  PKIStatusInfo.statusである場合： - 拒否 - 次いでcertifiedKeyPairが存在してはならないとfailInfoでなければなりません - 存在し、適切なビット設定を含みます"
    },
    {
      "indent": 3,
      "text": "certifiedKeyPair present depending on PKIStatusInfo.status certificate present depending on certifiedKeyPair",
      "ja": "certifiedKeyPair存在certifiedKeyPairに応じてPKIStatusInfo.status証明書の存在に応じて、"
    },
    {
      "indent": 3,
      "text": " -- content of actual certificate must be examined by requesting CA -- before publication protection present -- bits calculated using MSG_SIG_ALG extraCerts optionally present -- MAY contain any additional certificates that responder wishes -- to include",
      "ja": " - 出版保護存在前 -   - 実際の証明書の内容は、CAを要求することによって検査されなければならない必要に応じて、本MSG_SIG_ALG extraCertsを用いて計算したビット - 願いをレスポンダ任意の追加の証明書を含むかもしれ - 含めることが"
    },
    {
      "indent": 0,
      "text": "E.7. In-Band Initialization Using External Identity Certificate",
      "ja": "E.7。インバンド外部ID証明書を使用して初期化"
    },
    {
      "indent": 3,
      "text": "An (uninitialized) end entity wishes to initialize into the PKI with a CA, CA-1. It uses, for authentication purposes, a pre-existing identity certificate issued by another (external) CA, CA-X. A trust relationship must already have been established between CA-1 and CA-X so that CA-1 can validate the EE identity certificate signed by CA-X. Furthermore, some mechanism must already have been established within the Personal Security Environment (PSE) of the EE that would allow it to authenticate and verify PKIMessages signed by CA-1 (as one example, the PSE may contain a certificate issued for the public key of CA-1, signed by another CA that the EE trusts on the basis of out-of-band authentication techniques).",
      "ja": "（初期化されていない）エンドエンティティがCA、CA-1とPKIに初期化することを望みます。それは別の（外部）CA、CA-Xによって発行された既存のID証明書、認証目的のために、使用しています。 CA-1は、CA-Xによって署名EE ID証明書を検証できるように信頼関係がすでにCA-1とCA-X間で確立されている必要があります。さらに、いくつかのメカニズムはすでにそれがCA-1によって署名PKIMessagesを認証し、検証することが可能になるEEのパーソナルセキュリティ環境（PSE）内に設置されている必要があります（一例として、PSEは、公開鍵に対して発行された証明書が含まれていてもよいですCA-1を、アウトバンド認証技術に基づいてEE信託）別のCAによって署名されました。"
    },
    {
      "indent": 3,
      "text": "The EE sends an initialization request to start the transaction. When CA-1 responds with a message containing the new certificate, the end entity replies with a certificate confirmation. CA-1 replies with a PKIConfirm to close the transaction. All messages are signed (the EE messages are signed using the private key that corresponds to the public key in its external identity certificate; the CA-1 messages are signed using the private key that corresponds to the public key in a",
      "ja": "EEは、トランザクションを開始するための初期化要求を送信します。 CA-1は、新しい証明書を含むメッセージで応答する場合、エンドエンティティは、証明書確認で応答します。 CA-1は、トランザクションを閉じるためPKIConfirmで応答します。すべてのメッセージは、EEのメッセージは、その外部ID証明書の公開鍵に対応する秘密鍵を使って署名される（署名され、CA-1のメッセージは、公開鍵に対応する秘密鍵を使って署名されています"
    },
    {
      "indent": 3,
      "text": "certificate that can be chained to a trust anchor in the EE's PSE).",
      "ja": "EEのPSEの信頼アンカーにチェーンできる証明書）。"
    },
    {
      "indent": 3,
      "text": "The profile for this exchange is identical to that given in Appendix D.4, with the following exceptions:",
      "ja": "この交換のためのプロファイルは、次の例外を除いて、付録D.4に与えられたものと同一であります："
    },
    {
      "indent": 3,
      "text": "o the EE and CA-1 do not share a symmetric MACing key (i.e., there is no out-of-band shared secret information between these entities);",
      "ja": "O EEおよびCA-1が対称MACing鍵を共有していない（すなわち、これらのエンティティ間にはアウト・オブ・バンド共有秘密情報が存在しません）。"
    },
    {
      "indent": 3,
      "text": "o sender name in ir MUST be present (and identical to the subject name present in the external identity certificate);",
      "ja": "IR中のO、送信者名（外部のアイデンティティ証明書のサブジェクト名が存在すると同じ）が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o protectionAlg of MSG_SIG_ALG MUST be used in all messages;",
      "ja": "O MSG_SIG_ALGのprotectionAlgは、すべてのメッセージに使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o external identity cert. MUST be carried in ir extraCerts field",
      "ja": "O外部ID証明書。 IR extraCertsフィールドで運ばなければなりません"
    },
    {
      "indent": 3,
      "text": "o senderKID and recipKID are not used; o body is ir or ip;",
      "ja": "O senderKIDとrecipKIDは使用されません。 O体は、IRまたはIPです。"
    },
    {
      "indent": 3,
      "text": "o protection bits are calculated according to the protectionAlg field.",
      "ja": "O保護ビットはprotectionAlgフィールドに従って計算されます。"
    },
    {
      "indent": 0,
      "text": "Appendix F. Compilable ASN.1 Definitions",
      "ja": "付録F.コンパイル可能のASN.1定義"
    },
    {
      "indent": 5,
      "text": "PKIXCMP {iso(1) identified-organization(3)\n      dod(6) internet(1) security(5) mechanisms(5) pkix(7)\n      id-mod(0) id-mod-cmp2000(16)}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "DEFINITIONS EXPLICIT TAGS ::=",
      "raw": true
    },
    {
      "indent": 5,
      "text": "BEGIN",
      "ja": "ベギン"
    },
    {
      "indent": 5,
      "text": "-- EXPORTS ALL --",
      "ja": " - すべてのエクスポート - "
    },
    {
      "indent": 5,
      "text": "IMPORTS",
      "ja": "輸入"
    },
    {
      "indent": 9,
      "text": "Certificate, CertificateList, Extensions, AlgorithmIdentifier,\nUTF8String -- if required; otherwise, comment out\n       FROM PKIX1Explicit88 {iso(1) identified-organization(3)\n       dod(6) internet(1) security(5) mechanisms(5) pkix(7)\n       id-mod(0) id-pkix1-explicit-88(1)}",
      "raw": true
    },
    {
      "indent": 9,
      "text": "GeneralName, KeyIdentifier FROM PKIX1Implicit88 {iso(1) identified-organization(3) dod(6) internet(1) security(5) mechanisms(5) pkix(7) id-mod(0) id-pkix1-implicit-88(2)}",
      "ja": "GeneralName、KeyIdentifier PKIX1Implicit88 FROM {ISO（1）同定された組織（3）DOD（6）インターネット（1）セキュリティ（5）メカニズム（5）PKIX（7）ID-MOD（0）ID-pkix1-暗黙-88（ 2）}"
    },
    {
      "indent": 9,
      "text": "CertTemplate, PKIPublicationInfo, EncryptedValue, CertId, CertReqMessages FROM PKIXCRMF-2005 {iso(1) identified-organization(3) dod(6) internet(1) security(5) mechanisms(5) pkix(7) id-mod(0) id-mod-crmf2005(36)}",
      "ja": "CertTemplateの、PKIPublicationInfo、EncryptedValue、CertId、PKIXCRMF-2005 FROM CertReqMessages {ISO（1）同定された組織（3）DOD（6）インターネット（1）セキュリティ（5）メカニズム（5）PKIX（7）ID-MOD（0） ID-MOD-crmf2005（36）}"
    },
    {
      "indent": 9,
      "text": "-- see also the behavioral clarifications to CRMF codified in -- Appendix C of this specification",
      "ja": " - この仕様の付録C  - またして成文化CRMFに対する行動の明確化を参照してください"
    },
    {
      "indent": 9,
      "text": "CertificationRequest FROM PKCS-10 {iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-10(10) modules(1) pkcs-10(1)}",
      "ja": "PKCS-10 {ISO（1）部材本体（2）米国（840）RSADSI（113549）PKCS（1）PKCS-10（10）モジュール（1）PKCS-10（1）} FROM CertificationRequest"
    },
    {
      "indent": 9,
      "text": "-- (specified in RFC 2986 with 1993 ASN.1 syntax and IMPLICIT -- tags). Alternatively, implementers may directly include -- the [PKCS10] syntax in this module",
      "ja": " - （ - タグ1993 ASN.1構文とIMPLICITとRFC 2986で指定）。代替として、実装者は直接含んでいてもよい - このモジュールの[PKCS10]構文"
    },
    {
      "indent": 9,
      "text": ";",
      "ja": "；"
    },
    {
      "indent": 3,
      "text": "-- the rest of the module contains locally-defined OIDs and -- constructs",
      "ja": " - 構造 - モジュールの残りの部分は、ローカルに定義されたOIDとが含まれています"
    },
    {
      "indent": 3,
      "text": "   CMPCertificate ::= CHOICE {\n      x509v3PKCert        Certificate\n   }\n-- This syntax, while bits-on-the-wire compatible with the\n-- standard X.509 definition of \"Certificate\", allows the\n-- possibility of future certificate types (such as X.509\n-- attribute certificates, WAP WTLS certificates, or other kinds\n-- of certificates) within this certificate management protocol,\n-- should a need ever arise to support such generality.  Those\n-- implementations that do not foresee a need to ever support\n-- other certificate types MAY, if they wish, comment out the\n-- above structure and \"un-comment\" the following one prior to\n-- compiling this ASN.1 module.  (Note that interoperability\n-- with implementations that don't do this will be unaffected by\n-- this change.)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- CMPCertificate ::= Certificate",
      "raw": true
    },
    {
      "indent": 5,
      "text": " PKIMessage ::= SEQUENCE {\n    header           PKIHeader,\n    body             PKIBody,\n    protection   [0] PKIProtection OPTIONAL,\n    extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate\n                     OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "PKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage",
      "raw": true
    },
    {
      "indent": 5,
      "text": "PKIHeader ::= SEQUENCE {\n    pvno                INTEGER     { cmp1999(1), cmp2000(2) },\n    sender              GeneralName,\n    -- identifies the sender\n    recipient           GeneralName,\n    -- identifies the intended recipient\n    messageTime     [0] GeneralizedTime         OPTIONAL,\n    -- time of production of this message (used when sender\n    -- believes that the transport will be \"suitable\"; i.e.,\n    -- that the time will still be meaningful upon receipt)\n    protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,\n    -- algorithm used for calculation of protection bits\n    senderKID       [2] KeyIdentifier           OPTIONAL,\n    recipKID        [3] KeyIdentifier           OPTIONAL,\n    -- to identify specific keys used for protection transactionID   [4] OCTET STRING            OPTIONAL,\n    -- identifies the transaction; i.e., this will be the same in\n    -- corresponding request, response, certConf, and PKIConf\n    -- messages\n    senderNonce     [5] OCTET STRING            OPTIONAL,\n    recipNonce      [6] OCTET STRING            OPTIONAL,\n    -- nonces used to provide replay protection, senderNonce\n    -- is inserted by the creator of this message; recipNonce\n    -- is a nonce previously inserted in a related message by\n    -- the intended recipient of this message\n    freeText        [7] PKIFreeText             OPTIONAL,\n    -- this may be used to indicate context-specific instructions\n    -- (this field is intended for human consumption)\n    generalInfo     [8] SEQUENCE SIZE (1..MAX) OF\n                           InfoTypeAndValue     OPTIONAL\n    -- this may be used to convey context-specific information\n    -- (this field not primarily intended for human consumption)\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "PKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String\n    -- text encoded as UTF-8 String [RFC3629] (note: each\n    -- UTF8String MAY include an [RFC3066] language tag\n    -- to indicate the language of the contained text\n    -- see [RFC2482] for details)",
      "raw": true
    },
    {
      "indent": 5,
      "text": "PKIBody ::= CHOICE {       -- message-specific body elements\n    ir       [0]  CertReqMessages,        --Initialization Request\n    ip       [1]  CertRepMessage,         --Initialization Response\n    cr       [2]  CertReqMessages,        --Certification Request\n    cp       [3]  CertRepMessage,         --Certification Response\n    p10cr    [4]  CertificationRequest,   --imported from [PKCS10]\n    popdecc  [5]  POPODecKeyChallContent, --pop Challenge\n    popdecr  [6]  POPODecKeyRespContent,  --pop Response\n    kur      [7]  CertReqMessages,        --Key Update Request\n    kup      [8]  CertRepMessage,         --Key Update Response\n    krr      [9]  CertReqMessages,        --Key Recovery Request\n    krp      [10] KeyRecRepContent,       --Key Recovery Response\n    rr       [11] RevReqContent,          --Revocation Request\n    rp       [12] RevRepContent,          --Revocation Response\n    ccr      [13] CertReqMessages,        --Cross-Cert. Request\n    ccp      [14] CertRepMessage,         --Cross-Cert. Response\n    ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann.\n    cann     [16] CertAnnContent,         --Certificate Ann.\n    rann     [17] RevAnnContent,          --Revocation Ann.\n    crlann   [18] CRLAnnContent,          --CRL Announcement\n    pkiconf  [19] PKIConfirmContent,      --Confirmation\n    nested   [20] NestedMessageContent,   --Nested Message\n    genm     [21] GenMsgContent,          --General Message genp     [22] GenRepContent,          --General Response\n    error    [23] ErrorMsgContent,        --Error Message\n    certConf [24] CertConfirmContent,     --Certificate confirm\n    pollReq  [25] PollReqContent,         --Polling request\n    pollRep  [26] PollRepContent          --Polling response\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "PKIProtection ::= BIT STRING",
      "raw": true
    },
    {
      "indent": 5,
      "text": "ProtectedPart ::= SEQUENCE {\n    header    PKIHeader,\n    body      PKIBody\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}\nPBMParameter ::= SEQUENCE {\n    salt                OCTET STRING,\n    -- note:  implementations MAY wish to limit acceptable sizes\n    -- of this string to values appropriate for their environment\n    -- in order to reduce the risk of denial-of-service attacks\n    owf                 AlgorithmIdentifier,\n    -- AlgId for a One-Way Function (SHA-1 recommended)\n    iterationCount      INTEGER,\n    -- number of times the OWF is applied\n    -- note:  implementations MAY wish to limit acceptable sizes\n    -- of this integer to values appropriate for their environment\n    -- in order to reduce the risk of denial-of-service attacks\n    mac                 AlgorithmIdentifier\n    -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],\n}   -- or HMAC [RFC2104, RFC2202])",
      "raw": true
    },
    {
      "indent": 5,
      "text": "id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}\nDHBMParameter ::= SEQUENCE {\n    owf                 AlgorithmIdentifier,\n    -- AlgId for a One-Way Function (SHA-1 recommended)\n    mac                 AlgorithmIdentifier\n    -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],\n}   -- or HMAC [RFC2104, RFC2202])",
      "raw": true
    },
    {
      "indent": 5,
      "text": "NestedMessageContent ::= PKIMessages",
      "raw": true
    },
    {
      "indent": 5,
      "text": "PKIStatus ::= INTEGER {\n    accepted                (0),\n    -- you got exactly what you asked for\n    grantedWithMods        (1),\n    -- you got something like what you asked for; the\n    -- requester is responsible for ascertaining the differences rejection              (2),\n    -- you don't get it, more information elsewhere in the message\n    waiting                (3),\n    -- the request body part has not yet been processed; expect to\n    -- hear more later (note: proper handling of this status\n    -- response MAY use the polling req/rep PKIMessages specified\n    -- in Section 5.3.22; alternatively, polling in the underlying\n    -- transport layer MAY have some utility in this regard)\n    revocationWarning      (4),\n    -- this message contains a warning that a revocation is\n    -- imminent\n    revocationNotification (5),\n    -- notification that a revocation has occurred\n    keyUpdateWarning       (6)\n    -- update already done for the oldCertId specified in\n    -- CertReqMsg\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "PKIFailureInfo ::= BIT STRING {\n-- since we can fail in more than one way!\n-- More codes may be added in the future if/when required.\n    badAlg              (0),\n    -- unrecognized or unsupported Algorithm Identifier\n    badMessageCheck     (1),\n    -- integrity check failed (e.g., signature did not verify)\n    badRequest          (2),\n    -- transaction not permitted or supported\n    badTime             (3),\n    -- messageTime was not sufficiently close to the system time,\n    -- as defined by local policy\n    badCertId           (4),\n    -- no certificate could be found matching the provided criteria\n    badDataFormat       (5),\n    -- the data submitted has the wrong format\n    wrongAuthority      (6),\n    -- the authority indicated in the request is different from the\n    -- one creating the response token\n    incorrectData       (7),\n    -- the requester's data is incorrect (for notary services)\n    missingTimeStamp    (8),\n    -- when the timestamp is missing but should be there\n    -- (by policy)\n    badPOP              (9),\n    -- the proof-of-possession failed\n    certRevoked         (10),\n       -- the certificate has already been revoked\n    certConfirmed       (11),\n       -- the certificate has already been confirmed",
      "raw": true
    },
    {
      "indent": 5,
      "text": " wrongIntegrity (12), -- invalid integrity, password based instead of signature or -- vice versa badRecipientNonce (13), -- invalid recipient nonce, either missing or wrong value timeNotAvailable (14), -- the TSA's time source is not available unacceptedPolicy (15), -- the requested TSA policy is not supported by the TSA. unacceptedExtension (16), -- the requested extension is not supported by the TSA. addInfoNotAvailable (17), -- the additional information requested could not be -- understood or is not available badSenderNonce (18), -- invalid sender nonce, either missing or wrong size badCertTemplate (19), -- invalid cert. template or missing mandatory information signerNotTrusted (20), -- signer of the message unknown or not trusted transactionIdInUse (21), -- the transaction identifier is already in use unsupportedVersion (22), -- the version of the message is not supported notAuthorized (23), -- the sender was not authorized to make the preceding -- request or perform the preceding action systemUnavail (24), -- the request cannot be handled due to system unavailability systemFailure (25), -- the request cannot be handled due to system failure duplicateCertReq (26) -- certificate cannot be issued because a duplicate -- certificate already exists }",
      "ja": "wrongIntegrity（12）、 - 無効な整合性、パスワードの代わりに署名またはのベース - その逆badRecipientNonce（13）、 - 無効な受信者のナンス、いずれかの欠落または誤った値timeNotAvailable（14）、 -  TSAの時刻ソースが利用できませんunacceptedPolicy（15）は、 - 要求されたTSAポリシーがTSAによってサポートされていません。 unacceptedExtension（16）、 - 要求された拡張がTSAによってサポートされていません。 addInfoNotAvailable（17）、 - 要求された追加情報があることができなかったが - 、badSenderNonce（18）を理解したり使用できない - 無効な送信者ナンスを、いずれかの欠落または間違ったサイズbadCertTemplate（19）は、 - 無効な証明書を。テンプレートまたは欠落必須情報signerNotTrusted（20）、 - 未知のメッセージの署名者か否かを信頼transactionIdInUse（21）は、 - トランザクション識別子がすでに使用中unsupportedVersion（22）であり、 - メッセージのバージョンでサポートされていないnotAuthorized送信者が先行を行うことを許可されなかった -   - （23）、リクエスト又は先行アクションsystemUnavail（24）を実行する、 - 要求をすることはできません - 要求は、によりシステム利用不可のsystemFailure（25）に扱うことができません重複しているため、証明書を発行することができない -   - 証明書がすでに存在する}によりシステム故障duplicateCertReq（26）に扱わ"
    },
    {
      "indent": 5,
      "text": "PKIStatusInfo ::= SEQUENCE {\n    status        PKIStatus,\n    statusString  PKIFreeText     OPTIONAL,\n    failInfo      PKIFailureInfo  OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "OOBCert ::= CMPCertificate",
      "raw": true
    },
    {
      "indent": 5,
      "text": "OOBCertHash ::= SEQUENCE {\n    hashAlg     [0] AlgorithmIdentifier     OPTIONAL,\n    certId      [1] CertId                  OPTIONAL,\n    hashVal         BIT STRING",
      "raw": true
    },
    {
      "indent": 5,
      "text": " -- hashVal is calculated over the DER encoding of the -- self-signed certificate with the identifier certID. }",
      "ja": " - 識別子certIDと自己署名証明書 -  hashValはのDERエンコーディングにわたって計算されます。 }"
    },
    {
      "indent": 5,
      "text": "POPODecKeyChallContent ::= SEQUENCE OF Challenge\n-- One Challenge per encryption key certification request (in the\n-- same order as these requests appear in CertReqMessages).",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Challenge ::= SEQUENCE {\n    owf                 AlgorithmIdentifier  OPTIONAL,",
      "raw": true
    },
    {
      "indent": 9,
      "text": "-- MUST be present in the first Challenge; MAY be omitted in\n-- any subsequent Challenge in POPODecKeyChallContent (if\n-- omitted, then the owf used in the immediately preceding\n-- Challenge is to be used).",
      "raw": true
    },
    {
      "indent": 5,
      "text": "    witness             OCTET STRING,\n    -- the result of applying the one-way function (owf) to a\n    -- randomly-generated INTEGER, A.  [Note that a different\n    -- INTEGER MUST be used for each Challenge.]\n    challenge           OCTET STRING\n    -- the encryption (under the public key for which the cert.\n    -- request is being made) of Rand, where Rand is specified as\n    --   Rand ::= SEQUENCE {\n    --      int      INTEGER,\n    --       - the randomly-generated INTEGER A (above)\n    --      sender   GeneralName\n    --       - the sender's name (as included in PKIHeader)\n    --   }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "POPODecKeyRespContent ::= SEQUENCE OF INTEGER\n-- One INTEGER per encryption key certification request (in the\n-- same order as these requests appear in CertReqMessages).  The\n-- retrieved INTEGER A (above) is returned to the sender of the\n-- corresponding Challenge.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "CertRepMessage ::= SEQUENCE {\n    caPubs       [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate\n                     OPTIONAL,\n    response         SEQUENCE OF CertResponse\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "CertResponse ::= SEQUENCE {\n    certReqId           INTEGER,\n    -- to match this response with corresponding request (a value\n    -- of -1 is to be used if certReqId is not specified in the\n    -- corresponding request) status              PKIStatusInfo,\n    certifiedKeyPair    CertifiedKeyPair    OPTIONAL,\n    rspInfo             OCTET STRING        OPTIONAL\n    -- analogous to the id-regInfo-utf8Pairs string defined\n    -- for regInfo in CertReqMsg [CRMF]\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "CertifiedKeyPair ::= SEQUENCE {\n    certOrEncCert       CertOrEncCert,\n    privateKey      [0] EncryptedValue      OPTIONAL,\n    -- see [CRMF] for comment on encoding\n    publicationInfo [1] PKIPublicationInfo  OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "CertOrEncCert ::= CHOICE {\n    certificate     [0] CMPCertificate,\n    encryptedCert   [1] EncryptedValue\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "KeyRecRepContent ::= SEQUENCE {\n    status                  PKIStatusInfo,\n    newSigCert          [0] CMPCertificate OPTIONAL,\n    caCerts             [1] SEQUENCE SIZE (1..MAX) OF\n                                        CMPCertificate OPTIONAL,\n    keyPairHist         [2] SEQUENCE SIZE (1..MAX) OF\n                                        CertifiedKeyPair OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RevReqContent ::= SEQUENCE OF RevDetails",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RevDetails ::= SEQUENCE {\n    certDetails         CertTemplate,\n    -- allows requester to specify as much as they can about\n    -- the cert. for which revocation is requested\n    -- (e.g., for cases in which serialNumber is not available)\n    crlEntryDetails     Extensions       OPTIONAL\n    -- requested crlEntryExtensions\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RevRepContent ::= SEQUENCE {\n    status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,\n    -- in same order as was sent in RevReqContent\n    revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId\n                                        OPTIONAL,\n    -- IDs for which revocation was requested\n    -- (same order as status)\n    crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList\n                                        OPTIONAL",
      "raw": true
    },
    {
      "indent": 5,
      "text": " -- the resulting CRLs (there may be more than one) }",
      "ja": " - 得られたCRLは、（複数あってもよいです）}"
    },
    {
      "indent": 5,
      "text": "CAKeyUpdAnnContent ::= SEQUENCE {\n    oldWithNew   CMPCertificate, -- old pub signed with new priv\n    newWithOld   CMPCertificate, -- new pub signed with old priv\n    newWithNew   CMPCertificate  -- new pub signed with new priv\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "CertAnnContent ::= CMPCertificate",
      "raw": true
    },
    {
      "indent": 5,
      "text": "RevAnnContent ::= SEQUENCE {\n    status              PKIStatus,\n    certId              CertId,\n    willBeRevokedAt     GeneralizedTime,\n    badSinceDate        GeneralizedTime,\n    crlDetails          Extensions  OPTIONAL\n    -- extra CRL details (e.g., crl number, reason, location, etc.)\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "CRLAnnContent ::= SEQUENCE OF CertificateList",
      "raw": true
    },
    {
      "indent": 5,
      "text": "CertConfirmContent ::= SEQUENCE OF CertStatus",
      "raw": true
    },
    {
      "indent": 5,
      "text": "CertStatus ::= SEQUENCE {\n   certHash    OCTET STRING,\n   -- the hash of the certificate, using the same hash algorithm\n   -- as is used to create and verify the certificate signature\n   certReqId   INTEGER,\n   -- to match this confirmation with the corresponding req/rep\n   statusInfo  PKIStatusInfo OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "PKIConfirmContent ::= NULL",
      "raw": true
    },
    {
      "indent": 5,
      "text": "InfoTypeAndValue ::= SEQUENCE {\n    infoType               OBJECT IDENTIFIER,\n    infoValue              ANY DEFINED BY infoType  OPTIONAL\n}\n-- Example InfoTypeAndValue contents include, but are not limited\n-- to, the following (un-comment in this ASN.1 module and use as\n-- appropriate for a given environment):\n--\n--   id-it-caProtEncCert    OBJECT IDENTIFIER ::= {id-it 1}\n--      CAProtEncCertValue      ::= CMPCertificate\n--   id-it-signKeyPairTypes OBJECT IDENTIFIER ::= {id-it 2}\n--      SignKeyPairTypesValue   ::= SEQUENCE OF AlgorithmIdentifier\n--   id-it-encKeyPairTypes  OBJECT IDENTIFIER ::= {id-it 3}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "--      EncKeyPairTypesValue    ::= SEQUENCE OF AlgorithmIdentifier\n--   id-it-preferredSymmAlg OBJECT IDENTIFIER ::= {id-it 4}\n--      PreferredSymmAlgValue   ::= AlgorithmIdentifier\n--   id-it-caKeyUpdateInfo  OBJECT IDENTIFIER ::= {id-it 5}\n--      CAKeyUpdateInfoValue    ::= CAKeyUpdAnnContent\n--   id-it-currentCRL       OBJECT IDENTIFIER ::= {id-it 6}\n--      CurrentCRLValue         ::= CertificateList\n--   id-it-unsupportedOIDs  OBJECT IDENTIFIER ::= {id-it 7}\n--      UnsupportedOIDsValue    ::= SEQUENCE OF OBJECT IDENTIFIER\n--   id-it-keyPairParamReq  OBJECT IDENTIFIER ::= {id-it 10}\n--      KeyPairParamReqValue    ::= OBJECT IDENTIFIER\n--   id-it-keyPairParamRep  OBJECT IDENTIFIER ::= {id-it 11}\n--      KeyPairParamRepValue    ::= AlgorithmIdentifer\n--   id-it-revPassphrase    OBJECT IDENTIFIER ::= {id-it 12}\n--      RevPassphraseValue      ::= EncryptedValue\n--   id-it-implicitConfirm  OBJECT IDENTIFIER ::= {id-it 13}\n--      ImplicitConfirmValue    ::= NULL\n--   id-it-confirmWaitTime  OBJECT IDENTIFIER ::= {id-it 14}\n--      ConfirmWaitTimeValue    ::= GeneralizedTime\n--   id-it-origPKIMessage   OBJECT IDENTIFIER ::= {id-it 15}\n--      OrigPKIMessageValue     ::= PKIMessages\n--   id-it-suppLangTags     OBJECT IDENTIFIER ::= {id-it 16}\n--      SuppLangTagsValue       ::= SEQUENCE OF UTF8String\n--\n-- where\n--\n--   id-pkix OBJECT IDENTIFIER ::= {\n--      iso(1) identified-organization(3)\n--      dod(6) internet(1) security(5) mechanisms(5) pkix(7)}\n-- and\n--   id-it   OBJECT IDENTIFIER ::= {id-pkix 4}\n--\n--\n-- This construct MAY also be used to define new PKIX Certificate\n-- Management Protocol request and response messages, or general-\n-- purpose (e.g., announcement) messages for future needs or for\n-- specific environments.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "GenMsgContent ::= SEQUENCE OF InfoTypeAndValue",
      "raw": true
    },
    {
      "indent": 5,
      "text": "-- May be sent by EE, RA, or CA (depending on message content). -- The OPTIONAL infoValue parameter of InfoTypeAndValue will -- typically be omitted for some of the examples given above. -- The receiver is free to ignore any contained OBJ. IDs that it -- does not recognize. If sent from EE to CA, the empty set -- indicates that the CA may send -- any/all information that it wishes.",
      "ja": " -  EE、RA、またはCA（メッセージの内容に応じて）によって送信されても​​よいです。 -  InfoTypeAndValueのOPTIONAL infoValueパラメータがあろう - 典型的には、上記の例のいくつかのために省略されます。 - 受信機は、任意の含まOBJを無視して自由です。認識しない - それはIDが。 EEからCAに送信された場合は、空のセットが - どんな/それは希望するすべての情報を -  CAが送ることを示しています。"
    },
    {
      "indent": 5,
      "text": "GenRepContent ::= SEQUENCE OF InfoTypeAndValue\n-- Receiver MAY ignore any contained OIDs that it does not\n-- recognize.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "ErrorMsgContent ::= SEQUENCE {\n    pKIStatusInfo          PKIStatusInfo,\n    errorCode              INTEGER           OPTIONAL,\n    -- implementation-specific error codes\n    errorDetails           PKIFreeText       OPTIONAL\n    -- implementation-specific error details\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "PollReqContent ::= SEQUENCE OF SEQUENCE {\n    certReqId              INTEGER\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "PollRepContent ::= SEQUENCE OF SEQUENCE {\n    certReqId              INTEGER,\n    checkAfter             INTEGER,  -- time in seconds\n    reason                 PKIFreeText OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "END -- of CMP module",
      "ja": "END  -  CMPモジュールの"
    },
    {
      "indent": 0,
      "text": "Appendix G. Acknowledgements",
      "ja": "付録G.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors gratefully acknowledge the contributions of various members of the IETF PKIX Working Group and the ICSA CA-talk mailing list (a list solely devoted to discussing CMP interoperability efforts). Many of these contributions significantly clarified and improved the utility of this specification. Tomi Kause thanks Vesa Suontama and Toni Tammisalo for review and comments.",
      "ja": "作者は感謝して、様々なIETF PKIXワーキンググループのメンバーとICSA CA-トークメーリングリスト（専らCMPの相互運用性への取り組みを議論に捧げリスト）の拠出を認めます。これらの貢献の多くは、大幅にこの仕様の有用性を明らかにし、改善されました。レビューやコメントのトミKause感謝のVesa SuontamaとトニTammisalo。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Carlisle Adams University of Ottawa 800 King Edward Avenue P.O.Box 450, Station A Ottawa, Ontario K1N 6N5 CA",
      "ja": "オタワのカーライルアダムス大学800キングエドワードアベニューP.O.Box 450、ステーションAオタワオンタリオ州6N5 CA"
    },
    {
      "indent": 3,
      "text": "Phone: (613) 562-5800 ext. 2345 Fax: (613) 562-5664 EMail: cadams@site.uottawa.ca",
      "ja": "電話：（613）562-5800内線。 2345ファックス：（613）562から5664 Eメール：cadams@site.uottawa.ca"
    },
    {
      "indent": 3,
      "text": "Stephen Farrell Trinity College Dublin Distributed Systems Group Computer Science Department Dublin IE",
      "ja": "スティーブン・ファレルトリニティ・カレッジ・ダブリンは、システムグループコンピュータサイエンス学部ダブリンIE分散します"
    },
    {
      "indent": 3,
      "text": "Phone: +353-1-608-2945 EMail: stephen.farrell@cs.tcd.ie",
      "ja": "電話：+ 353-1-608-2945 Eメール：stephen.farrell@cs.tcd.ie"
    },
    {
      "indent": 3,
      "text": "Tomi Kause SSH Communications Security Corp Valimotie 17 Helsinki 00380 FI",
      "ja": "トミKause SSHコミュニケーションズ・セキュリティ社Valimotie 17ヘルシンキ00380 FI"
    },
    {
      "indent": 3,
      "text": "Phone: +358 20 500 7415 EMail: toka@ssh.com",
      "ja": "電話番号：+358 20 500 7415 Eメール：toka@ssh.com"
    },
    {
      "indent": 3,
      "text": "Tero Mononen SafeNet, Inc. Fredrikinkatu 47 Helsinki 00100 FI",
      "ja": "TERO Mononen SafeNetの株式会社Fredrikinkatu 47 00100ヘルシンキFI"
    },
    {
      "indent": 3,
      "text": "Phone: +358 20 500 7814 EMail: tmononen@safenet-inc.com",
      "ja": "電話番号：+358 20 500 7814 Eメール：tmononen@safenet-inc.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}