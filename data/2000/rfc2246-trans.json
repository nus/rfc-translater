{
  "title": {
    "text": "RFC 2246 - The TLS Protocol Version 1.0",
    "ja": "RFC 2246 - TLSプロトコルバージョン1.0"
  },
  "number": 2246,
  "created_at": "2019-10-22 01:34:58.039778+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         T. Dierks\nRequest for Comments: 2246                                     Certicom\nCategory: Standards Track                                      C. Allen\n                                                               Certicom\n                                                           January 1999",
      "raw": true
    },
    {
      "indent": 28,
      "text": "The TLS Protocol\n  Version 1.0",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1999）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies Version 1.0 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications privacy over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.",
      "ja": "この文書では、トランスポート層セキュリティ（TLS）プロトコルのバージョン1.0を指定します。 TLSプロトコルは、インターネット上で通信プライバシーを提供します。プロトコルは、クライアント/サーバアプリケーションは、盗聴、改ざん、またはメッセージ偽造を防ぐために設計された方法で通信することができます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction 3 2. Goals 4 3. Goals of this document 5 4. Presentation language 5 4.1. Basic block size 6 4.2. Miscellaneous 6 4.3. Vectors 6 4.4. Numbers 7 4.5. Enumerateds 7 4.6. Constructed types 8 4.6.1. Variants 9 4.7. Cryptographic attributes 10 4.8. Constants 11 5. HMAC and the pseudorandom function 11 6. The TLS Record Protocol 13 6.1. Connection states 14",
      "ja": "1.はじめに3つの2.目標本書の4つの3.目標5 4.プレゼンテーション言語5 4.1。基本ブロックサイズ6 4.2。その他6 4.3。ベクトル6 4.4。数字7 4.5。 7 4.6を、列挙。建設タイプ8 4.6.1。バリアント9 4.7。暗号化は、10 4.8属性。定数11 5. HMACと擬似ランダム関数11 6. TLSレコードプロトコル13 6.1。接続状態14"
    },
    {
      "indent": 3,
      "text": "6.2. Record layer 16 6.2.1. Fragmentation 16 6.2.2. Record compression and decompression 17 6.2.3. Record payload protection 18 6.2.3.1. Null or standard stream cipher 19 6.2.3.2. CBC block cipher 19 6.3. Key calculation 21 6.3.1. Export key generation example 22 7. The TLS Handshake Protocol 23 7.1. Change cipher spec protocol 24 7.2. Alert protocol 24 7.2.1. Closure alerts 25 7.2.2. Error alerts 26 7.3. Handshake Protocol overview 29 7.4. Handshake protocol 32 7.4.1. Hello messages 33 7.4.1.1. Hello request 33 7.4.1.2. Client hello 34 7.4.1.3. Server hello 36 7.4.2. Server certificate 37 7.4.3. Server key exchange message 39 7.4.4. Certificate request 41 7.4.5. Server hello done 42 7.4.6. Client certificate 43 7.4.7. Client key exchange message 43 7.4.7.1. RSA encrypted premaster secret message 44 7.4.7.2. Client Diffie-Hellman public value 45 7.4.8. Certificate verify 45 7.4.9. Finished 46 8. Cryptographic computations 47 8.1. Computing the master secret 47 8.1.1. RSA 48 8.1.2. Diffie-Hellman 48 9. Mandatory Cipher Suites 48 10. Application data protocol 48 A. Protocol constant values 49 A.1. Record layer 49 A.2. Change cipher specs message 50 A.3. Alert messages 50 A.4. Handshake protocol 51 A.4.1. Hello messages 51 A.4.2. Server authentication and key exchange messages 52 A.4.3. Client authentication and key exchange messages 53 A.4.4. Handshake finalization message 54 A.5. The CipherSuite 54 A.6. The Security Parameters 56 B. Glossary 57 C. CipherSuite definitions 61",
      "ja": "6.2. 記録層16 6.2.1。断片化16 6.2.2。レコード圧縮と解凍17 6.2.3。レコードペイロード保護18 6.2.3.1。 NULLまたは標準のストリーム暗号19 6.2.3.2。 CBCブロック暗号19 6.3。主な計算21 6.3.1。エクスポート鍵生成例22 7. TLSハンドシェイクプロトコル23 7.1。暗号仕様プロトコル24 7.2を変更します。アラートプロトコル24 7.2.1。閉鎖は25 7.2.2に警告します。エラーが26 7.3を警告します。ハンドシェイクプロトコル概要29 7.4。ハンドシェイク・プロトコル32 7.4.1。メッセージ33 7.4.1.1こんにちは。こんにちは、要求33 7.4.1.2。クライアントハロー34 7.4.1.3。サーバーハロー36 7.4.2。サーバ証明書37 7.4.3。サーバー鍵交換メッセージ39 7.4.4。証明書要求41 7.4.5。サーバーハロー42 7.4.6を行って。クライアント証明書43 7.4.7。クライアント鍵交換メッセージ43 7.4.7.1。 RSAは、前マスター秘密のメッセージ44 7.4.7.2を暗号化。クライアントのDiffie-Hellman公開値45 7.4.8。証明書は45 7.4.9を検証します。 46 8.暗号47 8.1計算終了。 47 8.1.1マスター秘密を計算します。 RSA 48 8.1.2。ディフィー・ヘルマン48 9.必須の暗号スイート48 10.アプリケーション・データ・プロトコル48のA.プロトコル定数値49 A.1。記録層49 A.2。暗号仕様にメッセージ50 A.3を変更します。アラートメッセージ50 A.4。ハンドシェイク・プロトコル51 A.4.1。メッセージ51 A.4.2こんにちは。サーバー認証と鍵交換メッセージ52 A.4.3。クライアント認証と鍵交換メッセージ53 A.4.4。ハンドシェイクファイナライズメッセージ54 A.5。 CipherSuite 54 A.6。セキュリティパラメータ56 B.用語集57 C.のCipherSuite 61を画成"
    },
    {
      "indent": 3,
      "text": "D. Implementation Notes 64 D.1. Temporary RSA keys 64 D.2. Random Number Generation and Seeding 64 D.3. Certificates and authentication 65 D.4. CipherSuites 65 E. Backward Compatibility With SSL 66 E.1. Version 2 client hello 67 E.2. Avoiding man-in-the-middle version rollback 68 F. Security analysis 69 F.1. Handshake protocol 69 F.1.1. Authentication and key exchange 69 F.1.1.1. Anonymous key exchange 69 F.1.1.2. RSA key exchange and authentication 70 F.1.1.3. Diffie-Hellman key exchange with authentication 71 F.1.2. Version rollback attacks 71 F.1.3. Detecting attacks against the handshake protocol 72 F.1.4. Resuming sessions 72 F.1.5. MD5 and SHA 72 F.2. Protecting application data 72 F.3. Final notes 73 G. Patent Statement 74 Security Considerations 75 References 75 Credits 77 Comments 78 Full Copyright Statement 80",
      "ja": "D.実装は64 D.1ノート。一時的RSA鍵64 D.2。乱数生成および播種64 D.3。証明書と認証65 D.4。 SSL 66 E.1しているCipherSuite 65 E.下位互換性。バージョン2クライアントのhello 67 E.2。 man-in-the-middleバージョンロールバック68 F.セキュリティ解析69 F.1を回避します。ハンドシェイクプロトコル69 F.1.1。認証と鍵交換69 F.1.1.1。匿名鍵交換69 F.1.1.2。 RSA鍵交換と認証70 F.1.1.3。認証71 F.1.2とのDiffie-Hellman鍵交換を。バージョンロールバック攻撃71 F.1.3。ハンドシェイクプロトコル72 F.1.4に対する攻撃を検出します。セッション72 F.1.5を再開。 MD5とSHA 72 F.2。アプリケーションデータ72 F.3を保護します。最終的なノート73 G.特許声明74のセキュリティの考慮事項75参考文献75クレジット77件のコメント78完全な著作権声明80"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The primary goal of the TLS Protocol is to provide privacy and data integrity between two communicating applications. The protocol is composed of two layers: the TLS Record Protocol and the TLS Handshake Protocol. At the lowest level, layered on top of some reliable transport protocol (e.g., TCP[TCP]), is the TLS Record Protocol. The TLS Record Protocol provides connection security that has two basic properties:",
      "ja": "TLSプロトコルの主な目的は、2つの通信アプリケーション間のプライバシーとデータの整合性を提供することです。 TLSレコードプロトコルとTLSハンドシェイクプロトコル：プロトコルは二つの層から構成されています。最下位レベルでは、いくつかの信頼性の高いトランスポートプロトコル（例えば、TCP [TCP]）の上に積層、TLSレコード・プロトコルです。 TLSレコードプロトコルは、2つの基本的な性質を持っている接続のセキュリティを提供します。"
    },
    {
      "indent": 5,
      "text": "- The connection is private. Symmetric cryptography is used for data encryption (e.g., DES [DES], RC4 [RC4], etc.) The keys for this symmetric encryption are generated uniquely for each connection and are based on a secret negotiated by another protocol (such as the TLS Handshake Protocol). The Record Protocol can also be used without encryption.",
      "ja": " - 接続はプライベートです。対称暗号は、データの暗号化（例えば、DES [DES]、RC4 [RC4]など）は、この対称暗号用の鍵は、接続ごとに固有に生成されるために使用され、TLSなどの別のプロトコル（によって交渉秘密に基づいていますハンドシェイクプロトコル）。レコードプロトコルは、暗号化せずに使用することができます。"
    },
    {
      "indent": 5,
      "text": "- The connection is reliable. Message transport includes a message integrity check using a keyed MAC. Secure hash functions (e.g., SHA, MD5, etc.) are used for MAC computations. The Record Protocol can operate without a MAC, but is generally only used in this mode while another protocol is using the Record Protocol as a transport for negotiating security parameters.",
      "ja": " - 接続が信頼性があります。メッセージトランスポートは、鍵付きMACを使用して、メッセージの整合性チェックが含まれています。セキュアハッシュ関数（例えば、SHA、MD5など）はMAC計算のために使用されます。レコードプロトコルは、MACなしで動作することができるが、他のプロトコルは、セキュリティパラメータを交渉するためのトランスポートとしてレコードプロトコルを使用している間、一般的にこのモードでのみ使用されています。"
    },
    {
      "indent": 3,
      "text": "The TLS Record Protocol is used for encapsulation of various higher level protocols. One such encapsulated protocol, the TLS Handshake Protocol, allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives its first byte of data. The TLS Handshake Protocol provides connection security that has three basic properties:",
      "ja": "TLSレコードプロトコルは、様々な上位レベルのプロトコルのカプセル化に使用されます。そのようなカプセル化されたプロトコル、TLSハンドシェイクプロトコルは、サーバーとクライアントが互いを認証し、アプリケーションプロトコルは、データの最初のバイトを送信または受信する前に、暗号化アルゴリズムと暗号鍵を交渉することを可能にします。 TLSハンドシェイクプロトコルは、3つの基本的な性質を持っている接続のセキュリティを提供します。"
    },
    {
      "indent": 5,
      "text": "- The peer's identity can be authenticated using asymmetric, or public key, cryptography (e.g., RSA [RSA], DSS [DSS], etc.). This authentication can be made optional, but is generally required for at least one of the peers.",
      "ja": " - ピアのアイデンティティは、非対称、または公開鍵暗号（たとえば、RSA [RSA]、DSS [DSS]など）を使用して認証することができます。この認証はオプションで行うことができますが、一般的にピアの少なくとも一方のために必要とされます。"
    },
    {
      "indent": 5,
      "text": "- The negotiation of a shared secret is secure: the negotiated secret is unavailable to eavesdroppers, and for any authenticated connection the secret cannot be obtained, even by an attacker who can place himself in the middle of the connection.",
      "ja": " - 共有秘密の交渉は安全である：交渉さの秘密は、盗聴者に利用できない、と任意の認証済みの接続のために秘密であっても、接続の途中で自分自身を配置することができ、攻撃者により、得ることができません。"
    },
    {
      "indent": 5,
      "text": "- The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the parties to the communication.",
      "ja": " - 交渉は信頼性がある：なし攻撃者は、通信の当事者によって検出されることなく交渉コミュニケーションを変更できません。"
    },
    {
      "indent": 3,
      "text": "One advantage of TLS is that it is application protocol independent. Higher level protocols can layer on top of the TLS Protocol transparently. The TLS standard, however, does not specify how protocols add security with TLS; the decisions on how to initiate TLS handshaking and how to interpret the authentication certificates exchanged are left up to the judgment of the designers and implementors of protocols which run on top of TLS.",
      "ja": "TLSの利点の一つは、それが独立したアプリケーションプロトコルであることです。より高いレベルのプロトコルが透過的TLSプロトコルの上の層ができます。 TLS標準は、しかし、プロトコルはTLSを使用してセキュリティを追加する方法を指定しません。 TLSハンドシェイクを開始すると、交換した認証証明書をどのように解釈するかをどのように決定はTLSの上で動作するプロトコルの設計者と実装者の判断に委ねています。"
    },
    {
      "indent": 0,
      "text": "2. Goals",
      "section_title": true,
      "ja": "2.目標"
    },
    {
      "indent": 3,
      "text": "The goals of TLS Protocol, in order of their priority, are:",
      "ja": "TLSプロトコルの目標は、その優先度の高い順に、以下のとおりです。"
    },
    {
      "indent": 4,
      "text": "1. Cryptographic security: TLS should be used to establish a secure connection between two parties.",
      "ja": "1.暗号セキュリティ：TLSは、二者間の安全な接続を確立するために使用する必要があります。"
    },
    {
      "indent": 4,
      "text": "2. Interoperability: Independent programmers should be able to develop applications utilizing TLS that will then be able to successfully exchange cryptographic parameters without knowledge of one another's code.",
      "ja": "2.相互運用性：独立したプログラマは、その後に成功し、互いのコードの知識がなくても、暗号化パラメータを交換することができるようになりますTLSを利用するアプリケーションを開発することができるはずです。"
    },
    {
      "indent": 4,
      "text": "3. Extensibility: TLS seeks to provide a framework into which new public key and bulk encryption methods can be incorporated as necessary. This will also accomplish two sub-goals: to prevent the need to create a new protocol (and risking the introduction of possible new weaknesses) and to avoid the need to implement an entire new security library.",
      "ja": "3.拡張性：TLSは、新しい公開鍵とバルク暗号化の方法は、必要に応じて組み込むことができるにフレームワークを提供することを目的とします。これは、2つのサブ目標を達成します：新しいプロトコルを作成する必要性を防ぐ（および可能な新しい弱点の導入を危険にさらし）と全体の新しいセキュリティライブラリを実装する必要性を避けるためにします。"
    },
    {
      "indent": 4,
      "text": "4. Relative efficiency: Cryptographic operations tend to be highly CPU intensive, particularly public key operations. For this reason, the TLS protocol has incorporated an optional session caching scheme to reduce the number of connections that need to be established from scratch. Additionally, care has been taken to reduce network activity.",
      "ja": "4.相対的効率：暗号操作は、特に公開鍵操作、非常にCPU集中する傾向があります。この理由のために、TLSプロトコルは、最初から確立される必要がある接続の数を減少させる任意のセッションキャッシュ方式を組み込んでいます。さらに、ケアはネットワーク活動を減らすためにとられています。"
    },
    {
      "indent": 0,
      "text": "3. Goals of this document",
      "section_title": true,
      "ja": "このドキュメントの3目標"
    },
    {
      "indent": 3,
      "text": "This document and the TLS protocol itself are based on the SSL 3.0 Protocol Specification as published by Netscape. The differences between this protocol and SSL 3.0 are not dramatic, but they are significant enough that TLS 1.0 and SSL 3.0 do not interoperate (although TLS 1.0 does incorporate a mechanism by which a TLS implementation can back down to SSL 3.0). This document is intended primarily for readers who will be implementing the protocol and those doing cryptographic analysis of it. The specification has been written with this in mind, and it is intended to reflect the needs of those two groups. For that reason, many of the algorithm-dependent data structures and rules are included in the body of the text (as opposed to in an appendix), providing easier access to them.",
      "ja": "Netscapeが発表され、このドキュメントとTLSプロトコル自体は、SSL 3.0プロトコル仕様に基づいています。このプロトコルとSSL 3.0の違いは劇的ではありませんが、（TLS 1.0がTLSの実装は、SSL 3.0にダウンバックアップできるメカニズムが組み込まれていますが）TLS 1.0およびSSL 3.0を相互運用していないことを十分に重要です。この文書は、主に、プロトコルとそれとはやって暗号解析を実行することになるの読者を対象としています。仕様では、これを念頭において書かれている、これら二つのグループのニーズを反映することを意図しています。そのため、アルゴリズム依存のデータ構造と規則の多くは、それらへの容易なアクセスを提供し、（付録のではなく）テキストの本文に含まれています。"
    },
    {
      "indent": 3,
      "text": "This document is not intended to supply any details of service definition nor interface definition, although it does cover select areas of policy as they are required for the maintenance of solid security.",
      "ja": "この文書は、それらが固体安全の維持のために必要とされる、それは政策の選択領域をカバーんが、サービスの定義や、インターフェースの定義に関する詳細を提供するものではありません。"
    },
    {
      "indent": 0,
      "text": "4. Presentation language",
      "section_title": true,
      "ja": "4.プレゼンテーション言語"
    },
    {
      "indent": 3,
      "text": "This document deals with the formatting of data in an external representation. The following very basic and somewhat casually defined presentation syntax will be used. The syntax draws from several sources in its structure. Although it resembles the programming language \"C\" in its syntax and XDR [XDR] in both its syntax and intent, it would be risky to draw too many parallels. The purpose of this presentation language is to document TLS only, not to have general application beyond that particular goal.",
      "ja": "この文書は、外部表現内のデータのフォーマットを扱います。以下の非常に基本的な、ややカジュアルに定義されたプレゼンテーション構文が使用されます。構文は、その構造中にいくつかのソースから描画します。それはその構文と意図の両方に[XDR]の構文とXDRでのプログラミング言語「C」に似ているが、あまりにも多くの類似点を描画することは危険だろう。このプレゼンテーション言語の目的は、TLSのみを文書化するために、特定の目標を超えた一般的なアプリケーションを持っているではありません。"
    },
    {
      "indent": 0,
      "text": "4.1. Basic block size",
      "section_title": true,
      "ja": "4.1. 基本ブロックサイズ"
    },
    {
      "indent": 3,
      "text": "The representation of all data items is explicitly specified. The basic data block size is one byte (i.e. 8 bits). Multiple byte data items are concatenations of bytes, from left to right, from top to bottom. From the bytestream a multi-byte item (a numeric in the example) is formed (using C notation) by:",
      "ja": "すべてのデータ項目の表現は、明示的に指定されています。基本的なデータ・ブロック・サイズは、1バイト（すなわち8ビット）です。上から下へ、左から右への複数バイトのデータ項目は、バイトの連結です。バイトストリームからマルチバイト項目（例の数値）は、により（C表記を使用して）形成されています。"
    },
    {
      "indent": 7,
      "text": "value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |\n        ... | byte[n-1];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This byte ordering for multi-byte values is the commonplace network byte order or big endian format.",
      "ja": "マルチバイト値のためのこのバイト順は、平凡なネットワークバイト順序またはビッグエンディアン形式です。"
    },
    {
      "indent": 0,
      "text": "4.2. Miscellaneous",
      "section_title": true,
      "ja": "4.2. 雑多"
    },
    {
      "indent": 3,
      "text": "Comments begin with \"/*\" and end with \"*/\".",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Optional components are denoted by enclosing them in \"[[ ]]\" double brackets.",
      "ja": "オプションのコンポーネントは、「[[]]」二重括弧で囲んで示しています。"
    },
    {
      "indent": 3,
      "text": "Single byte entities containing uninterpreted data are of type opaque.",
      "ja": "未解釈のデータを含む単一のバイト実体がタイプで不透明です。"
    },
    {
      "indent": 0,
      "text": "4.3. Vectors",
      "section_title": true,
      "ja": "4.3. ベクトル"
    },
    {
      "indent": 3,
      "text": "A vector (single dimensioned array) is a stream of homogeneous data elements. The size of the vector may be specified at documentation time or left unspecified until runtime. In either case the length declares the number of bytes, not the number of elements, in the vector. The syntax for specifying a new type T' that is a fixed length vector of type T is",
      "ja": "ベクター（単一寸法のアレイ）は均質のデータ要素のストリームです。ベクトルの大きさは、ドキュメンテーション時に指定されるか、または実行時まで未指定のままにすることができます。いずれの場合においても長さは、ベクター内のバイト数ではなく、要素の数を宣言する。タイプTの固定長ベクトルである新しいタイプT」を指定するための構文は"
    },
    {
      "indent": 7,
      "text": "T T'[n];",
      "ja": "T T '[n]は、"
    },
    {
      "indent": 3,
      "text": "Here T' occupies n bytes in the data stream, where n is a multiple of the size of T. The length of the vector is not included in the encoded stream.",
      "ja": "ここでT」は、nはベクトルの長さを符号化ストリームに含まれていないTのサイズの複数のデータストリームにnバイトを占めます。"
    },
    {
      "indent": 3,
      "text": "In the following example, Datum is defined to be three consecutive bytes that the protocol does not interpret, while Data is three consecutive Datum, consuming a total of nine bytes.",
      "ja": "データは9バイトの合計を消費する、三つの連続データムである次の例では、データムは、プロトコルが解釈しない三つの連続バイトであると定義されます。"
    },
    {
      "indent": 7,
      "text": "opaque Datum[3];      /* three uninterpreted bytes */\nDatum Data[9];        /* 3 consecutive 3 byte vectors */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Variable length vectors are defined by specifying a subrange of legal lengths, inclusively, using the notation <floor..ceiling>. When encoded, the actual length precedes the vector's contents in the byte stream. The length will be in the form of a number consuming as many bytes as required to hold the vector's specified maximum (ceiling) length. A variable length vector with an actual length field of zero is referred to as an empty vector.",
      "ja": "可変長ベクトルは、表記<floor..ceiling>を使用して、包括的、法的な長さの部分範囲を指定することによって定義されます。エンコードされた場合、実際の長さはバイトストリームでベクトルのコンテンツに先行します。長さは、ベクトルの指定された最大（天井）の長さを保持するのに必要な数のバイトを消費数の形態であろう。ゼロの実際の長さフィールドを持つ可変長ベクトルは空ベクターと呼ばれます。"
    },
    {
      "indent": 7,
      "text": "T T'<floor..ceiling>;",
      "ja": "T T '<floor..ceiling>。"
    },
    {
      "indent": 3,
      "text": "In the following example, mandatory is a vector that must contain between 300 and 400 bytes of type opaque. It can never be empty. The actual length field consumes two bytes, a uint16, sufficient to represent the value 400 (see Section 4.4). On the other hand, longer can represent up to 800 bytes of data, or 400 uint16 elements, and it may be empty. Its encoding will include a two byte actual length field prepended to the vector. The length of an encoded vector must be an even multiple of the length of a single element (for example, a 17 byte vector of uint16 would be illegal).",
      "ja": "次の例では、必須では、不透明なタイプの300と400バイトの間に含んでいなければならないベクトルです。それは空になることはありません。実際の長さフィールドは、2バイト、値400を表現するのに十分なuint16のを、（4.4節を参照）を消費します。一方、長いデータの最大800バイト、または400個のuint16の要素を表すことができ、それが空であってもよいです。そのエンコーディングは、ベクターの先頭に追加2バイト、実際の長さフィールドが含まれます。エンコードされたベクトルの長さは、単一の要素（例えば、uint16の17バイトベクトルは違法であろう）の長さの偶数倍でなければなりません。"
    },
    {
      "indent": 7,
      "text": "opaque mandatory<300..400>;\n      /* length field is 2 bytes, cannot be empty */\nuint16 longer<0..800>;\n      /* zero to 400 16-bit unsigned integers */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.4. Numbers",
      "section_title": true,
      "ja": "4.4. 数字"
    },
    {
      "indent": 3,
      "text": "The basic numeric data type is an unsigned byte (uint8). All larger numeric data types are formed from fixed length series of bytes concatenated as described in Section 4.1 and are also unsigned. The following numeric types are predefined.",
      "ja": "基本的な数値データ型は、符号なしバイト（uint8の）です。すべての大きな数値データ・タイプは、セクション4.1に記載し、また、符号なしであるように連結されたバイトの固定長シリーズから形成されます。以下の数値型は事前に定義されています。"
    },
    {
      "indent": 7,
      "text": "uint8 uint16[2];\nuint8 uint24[3];\nuint8 uint32[4];\nuint8 uint64[8];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All values, here and elsewhere in the specification, are stored in \"network\" or \"big-endian\" order; the uint32 represented by the hex bytes 01 02 03 04 is equivalent to the decimal value 16909060.",
      "ja": "すべての値は、ここおよび本明細書の他の箇所で、「ネットワーク」または「ビッグエンディアン」の順番で格納されます。ヘクスで表さUINT32 01 02 03 04進値16909060に相当するバイト。"
    },
    {
      "indent": 0,
      "text": "4.5. Enumerateds",
      "section_title": true,
      "ja": "4.5.  、列挙"
    },
    {
      "indent": 3,
      "text": "An additional sparse data type is available called enum. A field of type enum can only assume the values declared in the definition. Each definition is a different type. Only enumerateds of the same type may be assigned or compared. Every element of an enumerated must be assigned a value, as demonstrated in the following example. Since the elements of the enumerated are not ordered, they can be assigned any unique value, in any order.",
      "ja": "追加のまばらなデータ型は、列挙型と呼ば可能です。型列挙型のフィールドが定義のみで宣言された値をとることができます。各定義は異なるタイプです。同じタイプの列挙品目のみが割り当てまたは比較することができます。次の例で示されるように列挙のすべての要素は、値が割り当てられなければなりません。列挙の要素が順序付けされていないので、彼らは任意の順序で、任意の一意の値を割り当てることができます。"
    },
    {
      "indent": 7,
      "text": "enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;",
      "ja": "列挙{E1（V1）、E2（V2）、...、S（VN）[[（N）]]}テ。"
    },
    {
      "indent": 3,
      "text": "Enumerateds occupy as much space in the byte stream as would its maximal defined ordinal value. The following definition would cause one byte to be used to carry fields of type Color.",
      "ja": "その最大の順序値を定義したと同じように、列挙はバイトストリームのように多くのスペースを占有します。以下の定義は、1バイトのタイプ色のフィールドを運ぶために使用されることを引き起こします。"
    },
    {
      "indent": 7,
      "text": "enum { red(3), blue(5), white(7) } Color;",
      "ja": "列挙{赤（3）、青（5）、ホワイト（7）}カラー。"
    },
    {
      "indent": 3,
      "text": "One may optionally specify a value without its associated tag to force the width definition without defining a superfluous element. In the following example, Taste will consume two bytes in the data stream but can only assume the values 1, 2 or 4.",
      "ja": "一つは、必要に応じて余分な要素を定義することなく、幅の定義を強制的にその関連タグなしで値を指定することができます。以下の例では、味は、データストリーム内の2つのバイトを消費するだけの値1、2又は4をとることができます。"
    },
    {
      "indent": 7,
      "text": "enum { sweet(1), sour(2), bitter(4), (32000) } Taste;",
      "ja": "列挙{甘い（1）、サワー（2）、苦味（4）、（32000）}味。"
    },
    {
      "indent": 3,
      "text": "The names of the elements of an enumeration are scoped within the defined type. In the first example, a fully qualified reference to the second element of the enumeration would be Color.blue. Such qualification is not required if the target of the assignment is well specified.",
      "ja": "列挙の要素の名前は、定義された型内にスコープされています。最初の例では、列挙の2番目の要素への完全修飾参照はColor.blueあろう。割り当てのターゲットがよく指定されている場合、このような資格は必要ありません。"
    },
    {
      "indent": 7,
      "text": "Color color = Color.blue;     /* overspecified, legal */\nColor color = blue;           /* correct, type implicit */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For enumerateds that are never converted to external representation, the numerical information may be omitted.",
      "ja": "外部表現に変換されることはない列挙に関しては、数値情報を省略してもよいです。"
    },
    {
      "indent": 7,
      "text": "enum { low, medium, high } Amount;",
      "ja": "列挙{低、中、高}量;"
    },
    {
      "indent": 0,
      "text": "4.6. Constructed types",
      "section_title": true,
      "ja": "4.6. 建設種類"
    },
    {
      "indent": 3,
      "text": "Structure types may be constructed from primitive types for convenience. Each specification declares a new, unique type. The syntax for definition is much like that of C.",
      "ja": "構造タイプは便宜のためにプリミティブ型から構築することができます。各仕様は、新しい、ユニークなタイプを宣言します。定義の構文はCのようなくらいです"
    },
    {
      "indent": 7,
      "text": "struct {\n  T1 f1;\n  T2 f2;\n  ...\n  Tn fn;\n} [[T]];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields within a structure may be qualified using the type's name using a syntax much like that available for enumerateds. For example, T.f2 refers to the second field of the previous declaration. Structure definitions may be embedded.",
      "ja": "構造内のフィールドは、列挙において利用できるように多くの構文を使用したタイプの名前を使用して修飾することができます。例えば、T.f2は、以前の宣言の2番目のフィールドを意味します。構造体の定義が埋め込まれていてもよいです。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Variants",
      "section_title": true,
      "ja": "4.6.1. バリアント"
    },
    {
      "indent": 3,
      "text": "Defined structures may have variants based on some knowledge that is available within the environment. The selector must be an enumerated type that defines the possible variants the structure defines. There must be a case arm for every element of the enumeration declared in the select. The body of the variant structure may be given a label for reference. The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.",
      "ja": "定義された構造が環境で利用できる情報に基づいたバリエーションを有することができます。セレクタは、構造が定義可能な変形を定義する列挙型でなければなりません。選択で宣言された列挙のすべての要素のためのケースアームが存在する必要があります。変異体構造の本体は、参照のためにラベルを与えることができます。バリアントは、実行時に選択されるメカニズムは、プレゼンテーションの言語で規定されていません。"
    },
    {
      "indent": 7,
      "text": "struct {\n    T1 f1;\n    T2 f2;\n    ....\n    Tn fn;\n    select (E) {\n        case e1: Te1;\n        case e2: Te2;\n        ....\n        case en: Ten;\n    } [[fv]];\n} [[Tv]];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 7,
      "text": "enum { apple, orange } VariantTag;\nstruct {\n    uint16 number;\n    opaque string<0..10>; /* variable length */\n} V1;\nstruct {\n    uint32 number;\n    opaque string[10];    /* fixed length */\n} V2;\nstruct {\n    select (VariantTag) { /* value of selector is implicit */\n        case apple: V1;   /* VariantBody, tag = apple */\n        case orange: V2;  /* VariantBody, tag = orange */\n    } variant_body;       /* optional label on variant */\n} VariantRecord;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Variant structures may be qualified (narrowed) by specifying a value for the selector prior to the type. For example, a",
      "ja": "変異体の構造は、型の前にセレクタの値を指定して（狭く）修飾されてもよいです。たとえば、"
    },
    {
      "indent": 7,
      "text": "orange VariantRecord",
      "ja": "オレンジVariantRecord"
    },
    {
      "indent": 3,
      "text": "is a narrowed type of a VariantRecord containing a variant_body of type V2.",
      "ja": "タイプV2のvariant_bodyを含むVariantRecordの狭窄タイプです。"
    },
    {
      "indent": 0,
      "text": "4.7. Cryptographic attributes",
      "section_title": true,
      "ja": "4.7. 暗号化属性"
    },
    {
      "indent": 3,
      "text": "The four cryptographic operations digital signing, stream cipher encryption, block cipher encryption, and public key encryption are designated digitally-signed, stream-ciphered, block-ciphered, and public-key-encrypted, respectively. A field's cryptographic processing is specified by prepending an appropriate key word designation before the field's type specification. Cryptographic keys are implied by the current session state (see Section 6.1).",
      "ja": "4つの暗号化操作のデジタル署名は、デジタル署名されたストリーム暗号、ブロック暗号、及び公開鍵で暗号化され、それぞれ指定された暗号の暗号化、ブロック暗号の暗号化、及び公開鍵暗号をストリーミングします。フィールドの暗号処理は、フィールドの型を指定する前に、適切なキーワードの指定を付加することによって特定されます。暗号化キーは、現在のセッション状態によって暗示されている（6.1節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "In digital signing, one-way hash functions are used as input for a signing algorithm. A digitally-signed element is encoded as an opaque vector <0..2^16-1>, where the length is specified by the signing algorithm and key.",
      "ja": "デジタル署名では、一方向ハッシュ関数は署名アルゴリズムのための入力として使用されます。デジタル署名された要素は、長さが署名アルゴリズムと鍵によって指定された不透明なベクトル<0..2 ^ 16-1>としてコード化されます。"
    },
    {
      "indent": 3,
      "text": "In RSA signing, a 36-byte structure of two hashes (one SHA and one MD5) is signed (encrypted with the private key). It is encoded with PKCS #1 block type 0 or type 1 as described in [PKCS1].",
      "ja": "RSA署名では、2つのハッシュ（一方SHAと一つMD5）の36バイト構造（秘密鍵で暗号化された）署名されます。 [PKCS1]に記載されているように、それは、PKCS＃1ブロックタイプ0またはタイプ1で符号化されます。"
    },
    {
      "indent": 3,
      "text": "In DSS, the 20 bytes of the SHA hash are run directly through the Digital Signing Algorithm with no additional hashing. This produces two values, r and s. The DSS signature is an opaque vector, as above, the contents of which are the DER encoding of:",
      "ja": "DSSでは、SHAハッシュの20のバイトは追加論じ尽くすことのないデジタル署名アルゴリズムを通じて直接実行されています。これは、2つの値、rおよびsを生成します。 DSS署名は、上記のように、のDER符号化された内容不透明ベクトルです。"
    },
    {
      "indent": 7,
      "text": "Dss-Sig-Value  ::=  SEQUENCE  {\n     r       INTEGER,\n     s       INTEGER\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In stream cipher encryption, the plaintext is exclusive-ORed with an identical amount of output generated from a cryptographically-secure keyed pseudorandom number generator.",
      "ja": "ストリーム暗号の暗号化では、平文は、暗号的に安全な鍵付き擬似乱数生成器から生成される出力の同じ量の排他的論理和です。"
    },
    {
      "indent": 3,
      "text": "In block cipher encryption, every block of plaintext encrypts to a block of ciphertext. All block cipher encryption is done in CBC (Cipher Block Chaining) mode, and all items which are block-ciphered will be an exact multiple of the cipher block length.",
      "ja": "ブロック暗号の暗号化では、平文のすべてのブロックは、暗号文のブロックに暗号化します。全てのブロック暗号の暗号化は、CBC（Cipher Block Chaining）モードで行われ、ブロック暗号化されているすべての項目が暗号ブロック長の正確な倍数であろう。"
    },
    {
      "indent": 3,
      "text": "In public key encryption, a public key algorithm is used to encrypt data in such a way that it can be decrypted only with the matching private key. A public-key-encrypted element is encoded as an opaque vector <0..2^16-1>, where the length is specified by the signing algorithm and key.",
      "ja": "公開鍵暗号では、公開鍵アルゴリズムは、それだけで対応する秘密鍵で復号することができるような方法でデータを暗号化するために使用されます。公開鍵暗号化された要素は、長さが署名アルゴリズムと鍵によって指定された不透明なベクトル<0..2 ^ 16-1>としてコード化されます。"
    },
    {
      "indent": 3,
      "text": "An RSA encrypted value is encoded with PKCS #1 block type 2 as described in [PKCS1].",
      "ja": "[PKCS1]で説明されるようにRSA暗号化された値は、PKCS＃1ブロックタイプ2で符号化されます。"
    },
    {
      "indent": 3,
      "text": "In the following example:",
      "ja": "次の例では："
    },
    {
      "indent": 7,
      "text": "stream-ciphered struct {\n    uint8 field1;\n    uint8 field2;\n    digitally-signed opaque hash[20];\n} UserType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of hash are used as input for the signing algorithm, then the entire structure is encrypted with a stream cipher. The length of this structure, in bytes would be equal to 2 bytes for field1 and field2, plus two bytes for the length of the signature, plus the length of the output of the signing algorithm. This is known due to the fact that the algorithm and key used for the signing are known prior to encoding or decoding this structure.",
      "ja": "ハッシュの内容物は、次いで、全体の構造は、ストリーム暗号で暗号化され、署名アルゴリズムのための入力として使用されます。この構造の長さは、バイト単位でフィールド1及びフィールド2用の2つのバイトに加え、署名の長さ2バイト、プラス署名アルゴリズムの出力の長さに等しくなります。これにより、署名に使用されるアルゴリズムと鍵を符号化するか、この構造をデコードする前に知られているという事実のために知られています。"
    },
    {
      "indent": 0,
      "text": "4.8. Constants",
      "section_title": true,
      "ja": "4.8. 定数"
    },
    {
      "indent": 3,
      "text": "Typed constants can be defined for purposes of specification by declaring a symbol of the desired type and assigning values to it. Under-specified types (opaque, variable length vectors, and structures that contain opaque) cannot be assigned values. No fields of a multi-element structure or vector may be elided.",
      "ja": "型付き定数は、所望のタイプのシンボルを宣言し、それに値を割り当てることにより明細書の目的のために定義することができます。アンダー指定されたタイプ（不透明、可変長ベクトル、および不透明含む構造）の値を割り当てることはできません。多素子構造又はベクターのないフィールドは省略されなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "For example,",
      "ja": "例えば、"
    },
    {
      "indent": 7,
      "text": "struct {\n    uint8 f1;\n    uint8 f2;\n} Example1;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. HMAC and the pseudorandom function",
      "section_title": true,
      "ja": "5. HMACと擬似ランダム機能"
    },
    {
      "indent": 3,
      "text": "A number of operations in the TLS record and handshake layer required a keyed MAC; this is a secure digest of some data protected by a secret. Forging the MAC is infeasible without knowledge of the MAC secret. The construction we use for this operation is known as HMAC, described in [HMAC].",
      "ja": "キー付きMACを必要TLS記録と握手層における操作の数。これは秘密で保護されたいくつかのデータの安全なダイジェストです。 MACを鍛造すると、MACの秘密の知識がなくても実行不可能です。我々は、この操作に使用する構造は[HMAC]に記載の、HMACとして知られています。"
    },
    {
      "indent": 3,
      "text": "HMAC can be used with a variety of different hash algorithms. TLS uses it in the handshake with two different algorithms: MD5 and SHA-1, denoting these as HMAC_MD5(secret, data) and HMAC_SHA(secret, data). Additional hash algorithms can be defined by cipher suites and used to protect record data, but MD5 and SHA-1 are hard coded into the description of the handshaking for this version of the protocol.",
      "ja": "HMACは、異なるハッシュアルゴリズムの様々な使用することができます。 HMAC_MD5（秘密データ）とHMAC_SHA（秘密データ）としてこれらを表す、MD5とSHA-1：TLSは、二つの異なるアルゴリズムを用いてハンドシェイクでそれを使用します。追加のハッシュアルゴリズムは暗号スイートによって定義され、記録データを保護するために使用されるが、MD5とSHA-1は、ハードプロトコルのこのバージョンのハンドシェイクの記述に符号化されることができます。"
    },
    {
      "indent": 3,
      "text": "In addition, a construction is required to do expansion of secrets into blocks of data for the purposes of key generation or validation. This pseudo-random function (PRF) takes as input a secret, a seed, and an identifying label and produces an output of arbitrary length.",
      "ja": "さらに、工事が、キー生成や検証の目的のためにデータのブロックに秘密の拡張を行うために必要とされます。この擬似ランダム関数（PRF）は、入力として、秘密、種子、及び識別ラベルを取得し、任意の長さの出力を生成します。"
    },
    {
      "indent": 3,
      "text": "In order to make the PRF as secure as possible, it uses two hash algorithms in a way which should guarantee its security if either algorithm remains secure.",
      "ja": "可能な限り安全なようPRFを作るためには、どちらかのアルゴリズムが安全なままであれば、そのセキュリティを保証すべきであるように、2つのハッシュアルゴリズムを使用しています。"
    },
    {
      "indent": 3,
      "text": "First, we define a data expansion function, P_hash(secret, data) which uses a single hash function to expand a secret and seed into an arbitrary quantity of output:",
      "ja": "まず、秘密を展開し、出力の任意の量に播種するために単一のハッシュ関数を使用してデータ拡張機能、P_hash（秘密、データ）を定義します。"
    },
    {
      "indent": 7,
      "text": "P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +\n                       HMAC_hash(secret, A(2) + seed) +\n                       HMAC_hash(secret, A(3) + seed) + ...",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Where + indicates concatenation.",
      "ja": "+は、連結を示す場合。"
    },
    {
      "indent": 3,
      "text": "A() is defined as: A(0) = seed A(i) = HMAC_hash(secret, A(i-1))",
      "ja": "（）のように定義される：A（0）=シードA（I）= HMAC_hash（秘密、A（I-1））"
    },
    {
      "indent": 3,
      "text": "P_hash can be iterated as many times as is necessary to produce the required quantity of data. For example, if P_SHA-1 was being used to create 64 bytes of data, it would have to be iterated 4 times (through A(4)), creating 80 bytes of output data; the last 16 bytes of the final iteration would then be discarded, leaving 64 bytes of output data.",
      "ja": "P_hashは、データの必要な量を生成するのに必要な回数だけ反復することができます。 P_SHA-1は、64バイトのデータを作成するために使用されていた場合、例えば、出力データの80のバイトを作成、4倍（（4）を介して）を繰り返さなければなりません。最後の反復の最後の16のバイトは、出力データの64のバイトを残して、廃棄されます。"
    },
    {
      "indent": 3,
      "text": "TLS's PRF is created by splitting the secret into two halves and using one half to generate data with P_MD5 and the other half to generate data with P_SHA-1, then exclusive-or'ing the outputs of these two expansion functions together.",
      "ja": "TLSのPRFは、その後、一緒にこれらの2つの拡張機能の出力を排他的論理和、半分に秘密を分割し、P_SHA-1との間でデータを生成するP_MD5および他の半分でデータを生成するために半分を使用して作成されます。"
    },
    {
      "indent": 3,
      "text": "S1 and S2 are the two halves of the secret and each is the same length. S1 is taken from the first half of the secret, S2 from the second half. Their length is created by rounding up the length of the overall secret divided by two; thus, if the original secret is an odd number of bytes long, the last byte of S1 will be the same as the first byte of S2.",
      "ja": "S1とS2は、秘密の二つの半分であり、それぞれが同じ長さです。 S1は、後半から秘密の前半、S2から取られます。その長さは2で割った全体的な秘密の長さを切り上げて作成されます。元の秘密が長いバイト数が奇数である場合、従って、S1の最後のバイトは、S2の最初のバイトと同じになります。"
    },
    {
      "indent": 7,
      "text": "L_S = length in bytes of secret;\nL_S1 = L_S2 = ceil(L_S / 2);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The secret is partitioned into two halves (with the possibility of one shared byte) as described above, S1 taking the first L_S1 bytes and S2 the last L_S2 bytes.",
      "ja": "秘密は、上述したように（つの共有バイトの可能性）は、2つの半分に分割され、S1は第L_S1バイトとS2最後L_S2バイトを取ります。"
    },
    {
      "indent": 3,
      "text": "The PRF is then defined as the result of mixing the two pseudorandom streams by exclusive-or'ing them together.",
      "ja": "PRFは、次いで、それらを一緒に排他的論理和ことにより、2つの擬似ランダムストリームを混合した結果として定義されます。"
    },
    {
      "indent": 7,
      "text": "PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR\n                           P_SHA-1(S2, label + seed);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The label is an ASCII string. It should be included in the exact form it is given without a length byte or trailing null character. For example, the label \"slithy toves\" would be processed by hashing the following bytes:",
      "ja": "ラベルには、ASCII文字列です。それはそれは、長さバイトまたは末尾のヌル文字なしで指定された正確な形式に含まれるべきです。たとえば、ラベル次のバイトをハッシュすることによって処理される「slithy toves」は"
    },
    {
      "indent": 7,
      "text": "73 6C 69 74 68 79 20 74 6F 76 65 73",
      "ja": "73 74 TtsのTaqポリメラーゼのTaq右2074テフはTKH 73上陸しました"
    },
    {
      "indent": 3,
      "text": "Note that because MD5 produces 16 byte outputs and SHA-1 produces 20 byte outputs, the boundaries of their internal iterations will not be aligned; to generate a 80 byte output will involve P_MD5 being iterated through A(5), while P_SHA-1 will only iterate through A(4).",
      "ja": "MD5は、16のバイトの出力を生成し、SHA-1は、20のバイトの出力を生成するので、それらの内部反復の境界が整列されないことに注意してください。 P_SHA-1のみ（4）を反復する一方生成するために、80バイトの出力は、P_MD5（5）を介して反復される含むであろう。"
    },
    {
      "indent": 0,
      "text": "6. The TLS Record Protocol",
      "section_title": true,
      "ja": "6. TLSレコードプロトコル"
    },
    {
      "indent": 3,
      "text": "The TLS Record Protocol is a layered protocol. At each layer, messages may include fields for length, description, and content. The Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, optionally compresses the data, applies a MAC, encrypts, and transmits the result. Received data is decrypted, verified, decompressed, and reassembled, then delivered to higher level clients.",
      "ja": "TLSレコードプロトコルは、階層型プロトコルです。各レイヤでは、メッセージの長さ、説明、コンテンツのためのフィールドを含むことができます。レコードプロトコルは、メッセージを送信するのにかかる管理ブロックにデータを断片化し、必要に応じてデータを圧縮し、MACを適用し、暗号化し、結果を送信します。受信したデータは、復号化された検証、解凍、および再組み立て、その後、より高いレベルのクライアントに配信されます。"
    },
    {
      "indent": 3,
      "text": "Four record protocol clients are described in this document: the handshake protocol, the alert protocol, the change cipher spec protocol, and the application data protocol. In order to allow extension of the TLS protocol, additional record types can be supported by the record protocol. Any new record types should allocate type values immediately beyond the ContentType values for the four record types described here (see Appendix A.2). If a TLS implementation receives a record type it does not understand, it should just ignore it. Any protocol designed for use over TLS must be carefully designed to deal with all possible attacks against it. Note that because the type and length of a record are not protected by encryption, care should be take to minimize the value of traffic analysis of these values.",
      "ja": "四の、レコードプロトコルクライアントは、この文書で説明されています。ハンドシェイクプロトコル、アラートのプロトコル、変化暗号仕様プロトコル、およびアプリケーションデータプロトコルを。 TLSプロトコルの拡張を可能にするために、追加のレコードタイプは、レコード・プロトコルによってサポートすることができます。すべての新しいレコードタイプは、ここで説明した4つのレコードタイプのContentType値を超えて、すぐに型の値を割り当てる必要があります（付録A.2を参照してください）。 TLSの実装は、それが理解していないレコードタイプを受信した場合、それはそれを無視するべきです。 TLS以上の使用のために設計されたプロトコルは、慎重にそれに対するすべての可能な攻撃に対処するように設計されなければなりません。レコードのタイプと長さが暗号化によって保護されていないので、ケアは、これらの値のトラフィック分析の値を最小化するために取るべきであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "6.1. Connection states",
      "section_title": true,
      "ja": "6.1. 接続状態"
    },
    {
      "indent": 3,
      "text": "A TLS connection state is the operating environment of the TLS Record Protocol. It specifies a compression algorithm, encryption algorithm, and MAC algorithm. In addition, the parameters for these algorithms are known: the MAC secret and the bulk encryption keys and IVs for the connection in both the read and the write directions. Logically, there are always four connection states outstanding: the current read and write states, and the pending read and write states. All records are processed under the current read and write states. The security parameters for the pending states can be set by the TLS Handshake Protocol, and the Handshake Protocol can selectively make either of the pending states current, in which case the appropriate current state is disposed of and replaced with the pending state; the pending state is then reinitialized to an empty state. It is illegal to make a state which has not been initialized with security parameters a current state. The initial current state always specifies that no encryption, compression, or MAC will be used.",
      "ja": "TLS接続状態はTLSレコードプロトコルの動作環境です。これは、圧縮アルゴリズム、暗号化アルゴリズム、およびMACアルゴリズムを指定します。また、これらのアルゴリズムのためのパラメータが知られています：読み取りと書き込みの両方向での接続のためのMACの秘密とバルク暗号化鍵とIVを。現在の読み取りおよび状態を書き、そして読み保留中と状態を記述します。論理的には、優れた4つの接続状態が常にあります。すべてのレコードは、現在の読み取りと書き込みの状態の下で処理されています。ペンディング状態のセキュリティパラメータは、TLSハンドシェイクプロトコルにより設定することができ、ハンドシェイクプロトコルを選択、適切な現在の状態で配置され、保留状態に置き換えた場合には、現在の保留中の状態、のいずれかを行うことができます。保留状態は、空の状態に再初期化されます。セキュリティパラメータの現在の状態に初期化されていない状態を作ることは違法です。初期の現在の状態は常に何の暗号化、圧縮、またはMACを使用しないことを指定します。"
    },
    {
      "indent": 3,
      "text": "The security parameters for a TLS Connection read and write state are set by providing the following values:",
      "ja": "TLS接続の読み取りと書き込み状態のためのセキュリティパラメータは、以下の値を提供することで、設定されています。"
    },
    {
      "indent": 3,
      "text": "connection end Whether this entity is considered the \"client\" or the \"server\" in this connection.",
      "ja": "接続は、このエンティティは、これに関連して、「クライアント」または「サーバー」と見なされているかどうかに終了します。"
    },
    {
      "indent": 3,
      "text": "bulk encryption algorithm An algorithm to be used for bulk encryption. This specification includes the key size of this algorithm, how much of that key is secret, whether it is a block or stream cipher, the block size of the cipher (if appropriate), and whether it is considered an \"export\" cipher.",
      "ja": "バルク暗号化アルゴリズムアルゴリズムは、バルク暗号化に使用します。この仕様はこのアルゴリズムのキーサイズ、どれだけそのキーのは、それがブロックまたはストリーム暗号、暗号（適切な場合）のブロックサイズであるかどうか、秘密であり、それは「輸出」暗号とみなされるかどうかを含んでいます。"
    },
    {
      "indent": 3,
      "text": "MAC algorithm An algorithm to be used for message authentication. This specification includes the size of the hash which is returned by the MAC algorithm.",
      "ja": "MACは、メッセージの認証に使用するアルゴリズムをアルゴリズムです。この仕様は、MACアルゴリズムによって返されるハッシュのサイズが含まれます。"
    },
    {
      "indent": 3,
      "text": "compression algorithm An algorithm to be used for data compression. This specification must include all information the algorithm requires to do compression.",
      "ja": "圧縮は、データ圧縮に使用するアルゴリズムをアルゴリズムです。この仕様はアルゴリズムが圧縮を行うために必要なすべての情報を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "master secret A 48 byte secret shared between the two peers in the connection.",
      "ja": "マスターシークレット接続における2つのピア間で共有さ48バイトの秘密。"
    },
    {
      "indent": 3,
      "text": "client random A 32 byte value provided by the client.",
      "ja": "クライアントによって提供されるクライアントランダム32バイト値。"
    },
    {
      "indent": 3,
      "text": "server random A 32 byte value provided by the server.",
      "ja": "サーバーが提供するサーバランダム32バイト値。"
    },
    {
      "indent": 3,
      "text": "These parameters are defined in the presentation language as:",
      "ja": "これらのパラメータは、次のようにプレゼンテーション言語で定義されています。"
    },
    {
      "indent": 7,
      "text": "enum { server, client } ConnectionEnd;",
      "ja": "列挙{サーバー、クライアント} ConnectionEnd。"
    },
    {
      "indent": 7,
      "text": "enum { null, rc4, rc2, des, 3des, des40 } BulkCipherAlgorithm;",
      "ja": "列挙{ヌル、RC4、RC2、DES、3DES、DES40} BulkCipherAlgorithm。"
    },
    {
      "indent": 7,
      "text": "enum { stream, block } CipherType;",
      "ja": "列挙{ストリーム、ブロック} CipherType。"
    },
    {
      "indent": 7,
      "text": "enum { true, false } IsExportable;",
      "ja": "列挙{TRUE、FALSE} IsExportable。"
    },
    {
      "indent": 7,
      "text": "enum { null, md5, sha } MACAlgorithm;",
      "ja": "列挙{ヌル、MD5、SHA} MACAlgorithm。"
    },
    {
      "indent": 7,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "ja": "列挙{ヌル（0）、（255）} CompressionMethod。"
    },
    {
      "indent": 7,
      "text": "/* The algorithms specified in CompressionMethod,\n   BulkCipherAlgorithm, and MACAlgorithm may be added to. */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "struct {\n    ConnectionEnd          entity;\n    BulkCipherAlgorithm    bulk_cipher_algorithm;\n    CipherType             cipher_type;\n    uint8                  key_size;\n    uint8                  key_material_length;\n    IsExportable           is_exportable;\n    MACAlgorithm           mac_algorithm;\n    uint8                  hash_size;\n    CompressionMethod      compression_algorithm;\n    opaque                 master_secret[48];\n    opaque                 client_random[32];\n    opaque                 server_random[32];\n} SecurityParameters;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The record layer will use the security parameters to generate the following six items:",
      "ja": "記録層には、以下の6つの項目を生成するために、セキュリティパラメータを使用します。"
    },
    {
      "indent": 7,
      "text": "client write MAC secret\nserver write MAC secret\nclient write key\nserver write key\nclient write IV (for block ciphers only)\nserver write IV (for block ciphers only)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The client write parameters are used by the server when receiving and processing records and vice-versa. The algorithm used for generating these items from the security parameters is described in section 6.3.",
      "ja": "クライアント書き込みパラメータが記録及びその逆を受信して​​処理するときにサーバーが使用されます。セキュリティパラメータからこれらの項目を生成するために使用されるアルゴリズムは、セクション6.3に記載されています。"
    },
    {
      "indent": 3,
      "text": "Once the security parameters have been set and the keys have been generated, the connection states can be instantiated by making them the current states. These current states must be updated for each record processed. Each connection state includes the following elements:",
      "ja": "セキュリティパラメータが設定されているとキーが生成されたら、接続状態は、それらの現在の状態作ることによってインスタンス化することができます。これらの現在の状態は、処理された各レコードに更新する必要があります。それぞれの接続状態は、以下の要素が含まれています。"
    },
    {
      "indent": 3,
      "text": "compression state The current state of the compression algorithm.",
      "ja": "圧縮は圧縮アルゴリズムの現在の状態を述べます。"
    },
    {
      "indent": 3,
      "text": "cipher state The current state of the encryption algorithm. This will consist of the scheduled key for that connection. In addition, for block ciphers running in CBC mode (the only mode specified for TLS), this will initially contain the IV for that connection state and be updated to contain the ciphertext of the last block encrypted or decrypted as records are processed. For stream ciphers, this will contain whatever the necessary state information is to allow the stream to continue to encrypt or decrypt data.",
      "ja": "暗号状態暗号化アルゴリズムの現在の状態。これは、その接続のためにスケジュールされたキーから構成されます。また、CBCモード（TLS用に指定された専用モード）で実行されているブロック暗号のために、これは最初にその接続状態のためにIVが含まれ、レコードが処理されると、暗号化や復号化された最後のブロックの暗号文を含むように更新されます。ストリーム暗号の場合、これは必要な状態情報は、ストリームデータを暗号化または復号化を継続できるようにするためには何でも含まれています。"
    },
    {
      "indent": 3,
      "text": "MAC secret The MAC secret for this connection as generated above.",
      "ja": "上記生成され、この接続のためのMAC秘密のMAC秘密。"
    },
    {
      "indent": 3,
      "text": "sequence number Each connection state contains a sequence number, which is maintained separately for read and write states. The sequence number must be set to zero whenever a connection state is made the active state. Sequence numbers are of type uint64 and may not exceed 2^64-1. A sequence number is incremented after each record: specifically, the first record which is transmitted under a particular connection state should use sequence number 0.",
      "ja": "シーケンス番号は、各接続状態が読み取りおよび書き込み状態に対して別々に維持されているシーケンス番号を含んでいます。シーケンス番号は、接続状態がアクティブ状態にされるたびにゼロに設定されなければなりません。シーケンス番号は、タイプUINT64のものであり、2 ^ 64-1を超えてはなりません。シーケンス番号は、各レコードの後に​​インクリメントされる。具体的には、特定の接続状態で送信される最初のレコードは、シーケンス番号0を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2. Record layer",
      "section_title": true,
      "ja": "6.2. 記録層"
    },
    {
      "indent": 3,
      "text": "The TLS Record Layer receives uninterpreted data from higher layers in non-empty blocks of arbitrary size.",
      "ja": "TLSレコード層は、任意のサイズの空でないブロック内の上位層からの未解釈のデータを受信します。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Fragmentation",
      "section_title": true,
      "ja": "6.2.1. フラグメンテーション"
    },
    {
      "indent": 3,
      "text": "The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Client message boundaries are not preserved in the record layer (i.e., multiple client messages of the same ContentType may be coalesced into a single TLSPlaintext record, or a single message may be fragmented across several records).",
      "ja": "記録層は2 ^ 14バイト以下のチャンクでデータを搬送するのTLSPlaintextレコードに情報ブロックをフラグメント。クライアントメッセージの境界は、記録層に保存されていない（すなわち、同一のContentTypeの複数のクライアントメッセージは、単一のTLSPlaintextレコードに合体してもよいし、単一のメッセージがいくつかのレコードを横切って断片化することができます）。"
    },
    {
      "indent": 7,
      "text": "struct {\n    uint8 major, minor;\n} ProtocolVersion; enum {\n    change_cipher_spec(20), alert(21), handshake(22),\n    application_data(23), (255)\n} ContentType;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    opaque fragment[TLSPlaintext.length];\n} TLSPlaintext;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "type The higher level protocol used to process the enclosed fragment.",
      "ja": "囲まれたフラグメントを処理するために使用されるより高いレベルのプロトコルを入力します。"
    },
    {
      "indent": 3,
      "text": "version The version of the protocol being employed. This document describes TLS Version 1.0, which uses the version { 3, 1 }. The version value 3.1 is historical: TLS version 1.0 is a minor modification to the SSL 3.0 protocol, which bears the version value 3.0. (See Appendix A.1).",
      "ja": "バージョン使用されているプロトコルのバージョン。この文書は、バージョン{3,1}を使用してTLSバージョン1.0を、記載されています。バージョン値3.1は歴史ある：TLSバージョン1.0は、バージョン値3.0を負うSSL 3.0プロトコルにマイナーな修正です。 （付録A.1を参照してください）。"
    },
    {
      "indent": 3,
      "text": "length The length (in bytes) of the following TLSPlaintext.fragment. The length should not exceed 2^14.",
      "ja": "以下のTLSPlaintext.fragmentの長さ長さ（バイト単位）。長さが2 ^ 14を超えてはなりません。"
    },
    {
      "indent": 3,
      "text": "fragment The application data. This data is transparent and treated as an independent block to be dealt with by the higher level protocol specified by the type field.",
      "ja": "アプリケーションデータを断片化。このデータは、透明で、タイプフィールドで指定されたより高いレベルのプロトコルによって対処される独立したブロックとして扱われます。"
    },
    {
      "indent": 1,
      "text": "Note: Data of different TLS Record layer content types may be interleaved. Application data is generally of lower precedence for transmission than other content types.",
      "ja": "注：別のTLSレコード層コンテンツタイプのデータをインターリーブすることができます。アプリケーションデータは、一般に、他のコンテンツタイプより送信に対して低い優先順位のものです。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Record compression and decompression",
      "section_title": true,
      "ja": "6.2.2. レコード圧縮と解凍"
    },
    {
      "indent": 3,
      "text": "All records are compressed using the compression algorithm defined in the current session state. There is always an active compression algorithm; however, initially it is defined as CompressionMethod.null. The compression algorithm translates a TLSPlaintext structure into a TLSCompressed structure. Compression functions are initialized with default state information whenever a connection state is made active.",
      "ja": "すべてのレコードは、現在のセッション状態に定義された圧縮アルゴリズムを使用して圧縮されています。アクティブな圧縮アルゴリズムは常にあります。しかし、当初はCompressionMethod.nullと定義されます。圧縮アルゴリズムはTLSCompressed構造にのTLSPlaintext構造を変換します。圧縮機能は、接続状態がアクティブになるたびデフォルト状態の情報で初期化されています。"
    },
    {
      "indent": 3,
      "text": "Compression must be lossless and may not increase the content length by more than 1024 bytes. If the decompression function encounters a TLSCompressed.fragment that would decompress to a length in excess of 2^14 bytes, it should report a fatal decompression failure error.",
      "ja": "圧縮はロスレスでなければならず、1024バイト以上で、コンテンツの長さを増加させないかもしれません。解凍機能は、2 ^ 14バイトを超える長さに解凍しまうのTLSCompressed.fragmentに遭遇した場合、それは致命的な減圧失敗誤りを報告する必要があります。"
    },
    {
      "indent": 7,
      "text": "struct {\n    ContentType type;       /* same as TLSPlaintext.type */\n    ProtocolVersion version;/* same as TLSPlaintext.version */\n    uint16 length;\n    opaque fragment[TLSCompressed.length];\n} TLSCompressed;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "length The length (in bytes) of the following TLSCompressed.fragment. The length should not exceed 2^14 + 1024.",
      "ja": "以下のTLSCompressed.fragmentの長さ長さ（バイト単位）。長さは、+ 1024年2 ^ 14を超えてはなりません。"
    },
    {
      "indent": 3,
      "text": "fragment The compressed form of TLSPlaintext.fragment.",
      "ja": "TLSPlaintext.fragmentの圧縮形式を断片。"
    },
    {
      "indent": 1,
      "text": "Note: A CompressionMethod.null operation is an identity operation; no fields are altered.",
      "ja": "注意：CompressionMethod.null操作は一致演算です。分野は全く変更されません。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Decompression functions are responsible for ensuring that messages cannot cause internal buffer overflows.",
      "ja": "実装上の注意：解凍機能は、メッセージが内部バッファオーバーフローを引き起こさないことを保証する責任があります。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Record payload protection",
      "section_title": true,
      "ja": "6.2.3. レコードペイロード保護"
    },
    {
      "indent": 3,
      "text": "The encryption and MAC functions translate a TLSCompressed structure into a TLSCiphertext. The decryption functions reverse the process. The MAC of the record also includes a sequence number so that missing, extra or repeated messages are detectable.",
      "ja": "暗号化とMAC機能はTLSCiphertextにTLSCompressed構造を翻訳します。復号化機能は、プロセスを逆転します。レコードのMACも不足している、余分なまたは反復メッセージが検出可能であるように、シーケンス番号が含まれています。"
    },
    {
      "indent": 7,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    select (CipherSpec.cipher_type) {\n        case stream: GenericStreamCipher;\n        case block: GenericBlockCipher;\n    } fragment;\n} TLSCiphertext;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "type The type field is identical to TLSCompressed.type.",
      "ja": "タイプフィールドを入力してTLSCompressed.typeと同じです。"
    },
    {
      "indent": 3,
      "text": "version The version field is identical to TLSCompressed.version.",
      "ja": "バージョンバージョンフィールドはTLSCompressed.versionと同じです。"
    },
    {
      "indent": 3,
      "text": "length The length (in bytes) of the following TLSCiphertext.fragment. The length may not exceed 2^14 + 2048.",
      "ja": "以下のTLSCiphertext.fragmentの長さ長さ（バイト単位）。長さは、+ 2048年2 ^ 14を超えてはなりません。"
    },
    {
      "indent": 3,
      "text": "fragment The encrypted form of TLSCompressed.fragment, with the MAC.",
      "ja": "MACで、のTLSCompressed.fragmentの暗号化された形式を断片化。"
    },
    {
      "indent": 0,
      "text": "6.2.3.1. Null or standard stream cipher",
      "section_title": true,
      "ja": "6.2.3.1。 NULLまたは標準のストリーム暗号"
    },
    {
      "indent": 3,
      "text": "Stream ciphers (including BulkCipherAlgorithm.null - see Appendix A.6) convert TLSCompressed.fragment structures to and from stream TLSCiphertext.fragment structures.",
      "ja": "ストリーム暗号（BulkCipherAlgorithm.nullを含む - は付録A.6を参照）ストリームのTLSCiphertext.fragment構造からTLSCompressed.fragment構造を変換。"
    },
    {
      "indent": 7,
      "text": "stream-ciphered struct {\n    opaque content[TLSCompressed.length];\n    opaque MAC[CipherSpec.hash_size];\n} GenericStreamCipher;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The MAC is generated as:",
      "ja": "MACは次のように生成されます。"
    },
    {
      "indent": 7,
      "text": "HMAC_hash(MAC_write_secret, seq_num + TLSCompressed.type +\n              TLSCompressed.version + TLSCompressed.length +\n              TLSCompressed.fragment));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where \"+\" denotes concatenation.",
      "ja": "ここで、「+」連結を意味します。"
    },
    {
      "indent": 3,
      "text": "seq_num The sequence number for this record.",
      "ja": "このための一連番号が記録するseq_num。"
    },
    {
      "indent": 3,
      "text": "hash The hashing algorithm specified by SecurityParameters.mac_algorithm.",
      "ja": "SecurityParameters.mac_algorithmで指定されたハッシュアルゴリズムをハッシュ。"
    },
    {
      "indent": 3,
      "text": "Note that the MAC is computed before encryption. The stream cipher encrypts the entire block, including the MAC. For stream ciphers that do not use a synchronization vector (such as RC4), the stream cipher state from the end of one record is simply used on the subsequent packet. If the CipherSuite is TLS_NULL_WITH_NULL_NULL, encryption consists of the identity operation (i.e., the data is not encrypted and the MAC size is zero implying that no MAC is used). TLSCiphertext.length is TLSCompressed.length plus CipherSpec.hash_size.",
      "ja": "MACは、暗号化の前に計算されることに注意してください。ストリーム暗号はMACを含むブロック全体を、暗号化します。 （例えば、RC4など）同期ベクトルを使用しないストリーム暗号のために、一つのレコードの終わりからストリーム暗号状態は、単に次のパケットに使用されます。 CipherSuiteがTLS_NULL_WITH_NULL_NULLである場合、暗号化は同一の動作で構成され（すなわち、データは暗号化及びMACのサイズにはMACが使用されないことを意味ゼロでない場合）。 TLSCiphertext.lengthはTLSCompressed.lengthプラスCipherSpec.hash_sizeです。"
    },
    {
      "indent": 0,
      "text": "6.2.3.2. CBC block cipher",
      "section_title": true,
      "ja": "6.2.3.2。 CBCブロック暗号"
    },
    {
      "indent": 3,
      "text": "For block ciphers (such as RC2 or DES), the encryption and MAC functions convert TLSCompressed.fragment structures to and from block TLSCiphertext.fragment structures.",
      "ja": "（例えばRC2またはDESなどの）ブロック暗号は、暗号化とMAC機能ブロックのTLSCiphertext.fragment構造からTLSCompressed.fragment構造を変換します。"
    },
    {
      "indent": 7,
      "text": "block-ciphered struct {\n    opaque content[TLSCompressed.length];\n    opaque MAC[CipherSpec.hash_size];\n    uint8 padding[GenericBlockCipher.padding_length];\n    uint8 padding_length;\n} GenericBlockCipher;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The MAC is generated as described in Section 6.2.3.1.",
      "ja": "セクション6.2.3.1に記載されるようにMACが生成されます。"
    },
    {
      "indent": 3,
      "text": "padding Padding that is added to force the length of the plaintext to be an integral multiple of the block cipher's block length. The padding may be any length up to 255 bytes long, as long as it results in the TLSCiphertext.length being an integral multiple of the block length. Lengths longer than necessary might be desirable to frustrate attacks on a protocol based on analysis of the lengths of exchanged messages. Each uint8 in the padding data vector must be filled with the padding length value.",
      "ja": "ブロック暗号のブロック長の整数倍となるように、平文の長さを強制するために添加されるパディングパディング。パディングは、それがブロック長の整数倍であるTLSCiphertext.lengthになるように、長255バイトまでの任意の長さまでであってもよいです。必要以上に長い長が交換されたメッセージの長さの分析に基づいたプロトコルへの攻撃を挫折させることが望ましいかもしれません。パディングデータベクトルの各UINT8は、パディング長の値で充填されなければなりません。"
    },
    {
      "indent": 3,
      "text": "padding_length The padding length should be such that the total size of the GenericBlockCipher structure is a multiple of the cipher's block length. Legal values range from zero to 255, inclusive. This length specifies the length of the padding field exclusive of the padding_length field itself.",
      "ja": "するpadding_lengthパディングの長さはのGenericBlockCipher構造体の合計サイズが暗号のブロック長の倍数であるようなものであるべきです。有効な値は、包括的、ゼロから255までの範囲。この長さはするpadding_lengthフィールド自体の排他的なパディングフィールドの長さを指定します。"
    },
    {
      "indent": 3,
      "text": "The encrypted data length (TLSCiphertext.length) is one more than the sum of TLSCompressed.length, CipherSpec.hash_size, and padding_length.",
      "ja": "暗号化されたデータ長（TLSCiphertext.length）はTLSCompressed.length、CipherSpec.hash_size、およびpadding_lengthの合計より1です。"
    },
    {
      "indent": 1,
      "text": "Example: If the block length is 8 bytes, the content length (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, the length before padding is 82 bytes. Thus, the padding length modulo 8 must be equal to 6 in order to make the total length an even multiple of 8 bytes (the block length). The padding length can be 6, 14, 22, and so on, through 254. If the padding length were the minimum necessary, 6, the padding would be 6 bytes, each containing the value 6. Thus, the last 8 octets of the GenericBlockCipher before block encryption would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.",
      "ja": "例：ブロック長が8バイトである場合、コンテンツの長さ（TLSCompressed.length）は61バイトであり、MACの長さは20バイトで、パディング前の長さは82バイトです。従って、パディング長モジュロ8は、全8バイト長（ブロック長）の偶数倍にするために、6に等しくなければなりません。パディング長パディングが6バイト、したがって、値6をそれぞれ含む、最後の8つのオクテットであろう、6最低限必要であればパディングの長さは254を通るように6、14、22、とすることができますxxは、MACの最後のオクテットがどこにあるのGenericBlockCipherは、ブロック暗号化の前に、06 06 06 06 06 06 06 xxをされるだろう。"
    },
    {
      "indent": 1,
      "text": "Note: With block ciphers in CBC mode (Cipher Block Chaining) the initialization vector (IV) for the first record is generated with the other keys and secrets when the security parameters are set. The IV for subsequent records is the last ciphertext block from the previous record.",
      "ja": "注：CBCモードにおけるブロック暗号（暗号ブロック連鎖）セキュリティパラメータが設定されている場合、他のキーと秘密で生成された最初のレコードの初期化ベクトル（IV）です。後続のレコードのためのIVは、前のレコードから最後の暗号文ブロックです。"
    },
    {
      "indent": 0,
      "text": "6.3. Key calculation",
      "section_title": true,
      "ja": "6.3. 主な計算"
    },
    {
      "indent": 3,
      "text": "The Record Protocol requires an algorithm to generate keys, IVs, and MAC secrets from the security parameters provided by the handshake protocol.",
      "ja": "レコードプロトコルは、ハンドシェイクプロトコルによって提供されるセキュリティパラメータから鍵、IVを、およびMACシークレットを生成するアルゴリズムが必要です。"
    },
    {
      "indent": 3,
      "text": "The master secret is hashed into a sequence of secure bytes, which are assigned to the MAC secrets, keys, and non-export IVs required by the current connection state (see Appendix A.6). CipherSpecs require a client write MAC secret, a server write MAC secret, a client write key, a server write key, a client write IV, and a server write IV, which are generated from the master secret in that order. Unused values are empty.",
      "ja": "マスターシークレットが現在の接続状態によって必要とされるMACシークレット、キー、および非輸出のIVに割り当てられている安全なバイトのシーケンスにハッシュされる（付録A.6を参照）。 CipherSpecは、クライアントが、サーバが、クライアントの書き込みキー、サーバーの書き込みキー、クライアントの書き込みIV、及びそのために、マスターシークレットから生成されているサーバーの書き込みIVを、MACの秘密を書き、MACの秘密を書く必要があります。未使用の値は空です。"
    },
    {
      "indent": 3,
      "text": "When generating keys and MAC secrets, the master secret is used as an entropy source, and the random values provide unencrypted salt material and IVs for exportable ciphers.",
      "ja": "鍵とMACシークレットを生成する際に、マスターシークレットは、エントロピー源として使用され、ランダムな値をエクスポート暗号のための暗号化されていない塩材料及びIVを提供します。"
    },
    {
      "indent": 3,
      "text": "To generate the key material, compute",
      "ja": "キーマテリアルを生成するには、計算"
    },
    {
      "indent": 7,
      "text": "key_block = PRF(SecurityParameters.master_secret,\n                   \"key expansion\",\n                   SecurityParameters.server_random +\n                   SecurityParameters.client_random);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "until enough output has been generated. Then the key_block is partitioned as follows:",
      "ja": "まで十分な出力が生成されています。次に、以下のようなkey_blockが仕切られています。"
    },
    {
      "indent": 7,
      "text": "client_write_MAC_secret[SecurityParameters.hash_size]\nserver_write_MAC_secret[SecurityParameters.hash_size]\nclient_write_key[SecurityParameters.key_material_length]\nserver_write_key[SecurityParameters.key_material_length]\nclient_write_IV[SecurityParameters.IV_size]\nserver_write_IV[SecurityParameters.IV_size]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The client_write_IV and server_write_IV are only generated for non-export block ciphers. For exportable block ciphers, the initialization vectors are generated later, as described below. Any extra key_block material is discarded.",
      "ja": "client_write_IVとserver_write_IVは唯一の非輸出ブロック暗号のために生成されます。以下に説明するようにエクスポートブロック暗号のために、初期化ベクトルは、後に生成されます。余分なkey_block材料が破棄されます。"
    },
    {
      "indent": 3,
      "text": "Implementation note: The cipher spec which is defined in this document which requires the most material is 3DES_EDE_CBC_SHA: it requires 2 x 24 byte keys, 2 x 20 byte MAC secrets, and 2 x 8 byte IVs, for a total of 104 bytes of key material.",
      "ja": "実装注：ほとんどの材料を必要とする本文書で定義されている暗号スペックは3DES_EDE_CBC_SHAある：それはキーの104バイトの合計2×24バイトのキー、2×20のバイトのMAC秘密、および2×8つのバイトIVを、必要材料。"
    },
    {
      "indent": 3,
      "text": "Exportable encryption algorithms (for which CipherSpec.is_exportable is true) require additional processing as follows to derive their final write keys:",
      "ja": "輸出可能な暗号化アルゴリズム（CipherSpec.is_exportableが真である）以下のように最終的な書き込み鍵を導出するために追加の処理が必要です。"
    },
    {
      "indent": 7,
      "text": "final_client_write_key =\nPRF(SecurityParameters.client_write_key,\n                           \"client write key\",\n                           SecurityParameters.client_random +\n                           SecurityParameters.server_random);\nfinal_server_write_key =\nPRF(SecurityParameters.server_write_key,\n                           \"server write key\",\n                           SecurityParameters.client_random +\n                           SecurityParameters.server_random);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Exportable encryption algorithms derive their IVs solely from the random values from the hello messages:",
      "ja": "輸出可能な暗号化アルゴリズムは、helloメッセージからランダムな値のみからそのIVを導き出します："
    },
    {
      "indent": 7,
      "text": "iv_block = PRF(\"\", \"IV block\", SecurityParameters.client_random +\n               SecurityParameters.server_random);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The iv_block is partitioned into two initialization vectors as the key_block was above:",
      "ja": "なkey_blockは、上記たようiv_blockは、二つの初期化ベクトルに分割されます。"
    },
    {
      "indent": 7,
      "text": "client_write_IV[SecurityParameters.IV_size]\nserver_write_IV[SecurityParameters.IV_size]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that the PRF is used without a secret in this case: this just means that the secret has a length of zero bytes and contributes nothing to the hashing in the PRF.",
      "ja": "PRFは、この場合には秘密なしで使用されることに注意してください：これはちょうど秘密はゼロバイトの長さを有し、PRFでハッシュに何も寄与しないことを意味します。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Export key generation example",
      "section_title": true,
      "ja": "6.3.1. 輸出の鍵生成例"
    },
    {
      "indent": 3,
      "text": "TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 requires five random bytes for each of the two encryption keys and 16 bytes for each of the MAC keys, for a total of 42 bytes of key material. The PRF output is stored in the key_block. The key_block is partitioned, and the write keys are salted because this is an exportable encryption algorithm.",
      "ja": "TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5は、鍵材料の42バイトの合計で、2つの暗号化鍵とMAC鍵のそれぞれについて16バイトのそれぞれのための5つのランダムバイトを必要とします。 PRF出力はなkey_blockに格納されています。なkey_blockが分割され、輸出可能な暗号化アルゴリズムであるため、書き込みキーが塩漬けされています。"
    },
    {
      "indent": 7,
      "text": "key_block               = PRF(master_secret,\n                              \"key expansion\",\n                              server_random +\n                              client_random)[0..41]\nclient_write_MAC_secret = key_block[0..15]\nserver_write_MAC_secret = key_block[16..31]\nclient_write_key        = key_block[32..36]\nserver_write_key        = key_block[37..41] final_client_write_key  = PRF(client_write_key,\n                              \"client write key\",\n                              client_random +\n                              server_random)[0..15]\nfinal_server_write_key  = PRF(server_write_key,\n                              \"server write key\",\n                              client_random +\n                              server_random)[0..15]",
      "raw": true
    },
    {
      "indent": 7,
      "text": "iv_block = PRF(\"\", \"IV block\", client_random + server_random)[0..15] client_write_IV = iv_block[0..7] server_write_IV = iv_block[8..15]",
      "ja": "iv_block = PRF（ \"\"、 \"IVブロック\"、client_random + server_random）[0..15] client_write_IV = iv_block [0..7] server_write_IV = iv_block [8..15]"
    },
    {
      "indent": 0,
      "text": "7. The TLS Handshake Protocol",
      "section_title": true,
      "ja": "7. TLSハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "The TLS Handshake Protocol consists of a suite of three sub-protocols which are used to allow peers to agree upon security parameters for the record layer, authenticate themselves, instantiate negotiated security parameters, and report error conditions to each other.",
      "ja": "TLSハンドシェイクプロトコルは、ピアは、自分自身を認証、記録層のためのセキュリティパラメータに合意交渉されたセキュリティ・パラメータをインスタンス化し、相互にエラー状況を報告できるようにするために使用される3つのサブプロトコルのスイートで構成されています。"
    },
    {
      "indent": 3,
      "text": "The Handshake Protocol is responsible for negotiating a session, which consists of the following items:",
      "ja": "ハンドシェイクプロトコルは、以下の項目で構成されたセッションを、交渉を担当します。"
    },
    {
      "indent": 3,
      "text": "session identifier An arbitrary byte sequence chosen by the server to identify an active or resumable session state.",
      "ja": "セッション識別子アクティブまたは再開可能なセッション状態を識別するためにサーバによって選択された任意のバイトシーケンス。"
    },
    {
      "indent": 3,
      "text": "peer certificate X509v3 [X509] certificate of the peer. This element of the state may be null.",
      "ja": "ピアのピア証明書X509v3 [X509]証明書。状態のこの要素はnullの場合もあります。"
    },
    {
      "indent": 3,
      "text": "compression method The algorithm used to compress data prior to encryption.",
      "ja": "圧縮方式暗号化の前にデータを圧縮するために使用されるアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "cipher spec Specifies the bulk data encryption algorithm (such as null, DES, etc.) and a MAC algorithm (such as MD5 or SHA). It also defines cryptographic attributes such as the hash_size. (See Appendix A.6 for formal definition)",
      "ja": "暗号仕様は、バルクデータ暗号化アルゴリズムと（例えばMD5やSHAのような）MACアルゴリズム（例えばヌル、DESなど）を指定します。また、hash_sizeなどの暗号属性を定義します。 （正式な定義については付録A.6を参照してください）"
    },
    {
      "indent": 3,
      "text": "master secret 48-byte secret shared between the client and server.",
      "ja": "クライアントとサーバの間で共有される秘密48バイトの秘密を習得。"
    },
    {
      "indent": 3,
      "text": "is resumable A flag indicating whether the session can be used to initiate new connections.",
      "ja": "再開可能セッションが新しい接続を開始するために使用することができるか否かを示すフラグです。"
    },
    {
      "indent": 3,
      "text": "These items are then used to create security parameters for use by the Record Layer when protecting application data. Many connections can be instantiated using the same session through the resumption feature of the TLS Handshake Protocol.",
      "ja": "これらの項目は、アプリケーションのデータを保護する際にレコード層で使用するためのセキュリティパラメータを作成するために使用されています。多くの接続は、TLSハンドシェイクプロトコルの再開機能を使用して、同じセッションを使用してインスタンス化することができます。"
    },
    {
      "indent": 0,
      "text": "7.1. Change cipher spec protocol",
      "section_title": true,
      "ja": "7.1. 暗号仕様のプロトコルを変更します"
    },
    {
      "indent": 3,
      "text": "The change cipher spec protocol exists to signal transitions in ciphering strategies. The protocol consists of a single message, which is encrypted and compressed under the current (not the pending) connection state. The message consists of a single byte of value 1.",
      "ja": "変化暗号仕様プロトコルは、暗号化戦略の遷移を通知するために存在しています。プロトコルは、（保留中ではない）現在の接続状態の下で暗号化され、圧縮された単一のメッセージからなります。メッセージは、値1の単一バイトから成ります。"
    },
    {
      "indent": 7,
      "text": "struct {\n    enum { change_cipher_spec(1), (255) } type;\n} ChangeCipherSpec;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The change cipher spec message is sent by both the client and server to notify the receiving party that subsequent records will be protected under the newly negotiated CipherSpec and keys. Reception of this message causes the receiver to instruct the Record Layer to immediately copy the read pending state into the read current state. Immediately after sending this message, the sender should instruct the record layer to make the write pending state the write active state. (See section 6.1.) The change cipher spec message is sent during the handshake after the security parameters have been agreed upon, but before the verifying finished message is sent (see section 7.4.9).",
      "ja": "変化暗号仕様メッセージは、後続のレコードは、新たに交渉のCipherSpecと鍵の下で保護されます受信者に通知するために、クライアントとサーバの両方で送信されます。このメッセージの受信は、受信機はすぐに読み、現在の状態に読み取り保留状態をコピーするレコード層を指示する原因となります。すぐにこのメッセージを送信した後、送信者は、書き込み保留状態の書き込みアクティブ状態を作るために、記録層に指示する必要があります。 （6.1節を参照してください。）ChangeCipherSpecメッセージは、セキュリティパラメータが合意された後の握手の間に送信されますが、検証完成メッセージが送信される前に、（セクション7.4.9を参照）されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Alert protocol",
      "section_title": true,
      "ja": "7.2. アラートプロトコル"
    },
    {
      "indent": 3,
      "text": "One of the content types supported by the TLS Record layer is the alert type. Alert messages convey the severity of the message and a description of the alert. Alert messages with a level of fatal result in the immediate termination of the connection. In this case, other connections corresponding to the session may continue, but the session identifier must be invalidated, preventing the failed session from being used to establish new connections. Like other messages, alert messages are encrypted and compressed, as specified by the current connection state.",
      "ja": "TLSレコード層によってサポートされているコンテンツタイプのひとつは、アラートタイプです。アラートメッセージには、メッセージの重要度やアラートの説明を伝えます。接続の即時終了で致命的な結果のレベルにアラートメッセージ。この場合、セッションに対応する他の接続が継続してもよいが、セッション識別子を無効にする必要があり、新しい接続を確立するために使用されるの失敗したセッションを防止します。現在の接続状態によって指定された他のメッセージと同様に、警告メッセージは、暗号化および圧縮されています。"
    },
    {
      "indent": 7,
      "text": "enum { warning(1), fatal(2), (255) } AlertLevel;",
      "ja": "列挙{（1）警告致命的な（2）、（255）} AlertLevel。"
    },
    {
      "indent": 7,
      "text": "enum { close_notify(0), unexpected_message(10), bad_record_mac(20), decryption_failed(21), record_overflow(22), decompression_failure(30), handshake_failure(40), bad_certificate(42), unsupported_certificate(43), certificate_revoked(44), certificate_expired(45), certificate_unknown(46), illegal_parameter(47), unknown_ca(48), access_denied(49), decode_error(50), decrypt_error(51), export_restriction(60), protocol_version(70), insufficient_security(71), internal_error(80), user_canceled(90), no_renegotiation(100), (255) } AlertDescription;",
      "ja": "certificate_revoked列挙{decryption_failedは、close_notify（0）、unexpected_message（10）、bad_record_mac（20）、（21）、record_overflow（22）、decompression_failure（30）、握手_（40）、bad_certificate（42）、unsupported_certificate（43）、（44 ）、certificate_expired（45）、ACCESS_DENIED certificate_unknown（46）、illegal_parameter（47）、unknown_ca（48）、（49）、decode_error（50）、decrypt_error（51）、export_restriction（60）、PROTOCOL_VERSION（70）、insufficient_security（71 user_canceled）、INTERNAL_ERROR（80）、（90）、no_renegotiation（100）、（255）} AlertDescription。"
    },
    {
      "indent": 7,
      "text": "struct {\n    AlertLevel level;\n    AlertDescription description;\n} Alert;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2.1. Closure alerts",
      "section_title": true,
      "ja": "7.2.1. 閉鎖アラート"
    },
    {
      "indent": 3,
      "text": "The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack. Either party may initiate the exchange of closing messages.",
      "ja": "クライアントとサーバーの接続がトランケーション攻撃を避けるために終了しているという知識を共有しなければなりません。いずれの当事者から終了メッセージの交換を開始することができます。"
    },
    {
      "indent": 3,
      "text": "close_notify This message notifies the recipient that the sender will not send any more messages on this connection. The session becomes unresumable if any connection is terminated without proper close_notify messages with level equal to warning.",
      "ja": "close_notifyこのメッセージは、送信者がこの接続上の任意の複数のメッセージを送信しません受信者に通知します。任意の接続が警告に等しいレベルで適切なは、close_notifyメッセージなしで終了した場合、セッションはunresumableになります。"
    },
    {
      "indent": 3,
      "text": "Either party may initiate a close by sending a close_notify alert. Any data received after a closure alert is ignored.",
      "ja": "いずれの当事者は、は、close_notifyを送信することにより、クローズを開始することができます。閉鎖警報後に受信したデータはすべて無視されます。"
    },
    {
      "indent": 3,
      "text": "Each party is required to send a close_notify alert before closing the write side of the connection. It is required that the other party respond with a close_notify alert of its own and close down the connection immediately, discarding any pending writes. It is not required for the initiator of the close to wait for the responding close_notify alert before closing the read side of the connection.",
      "ja": "各当事者は、接続の書き込み側を閉じる前には、close_notifyを送信するために必要とされます。他の当事者は、独自のは、close_notifyで応答し、すぐにコネクションを閉じ、保留中の書き込みを捨てることが必要とされます。接続の読み取り側を閉じる前に、応答は、close_notifyを待つために近くのイニシエータは必要ありません。"
    },
    {
      "indent": 3,
      "text": "If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation must receive the responding close_notify alert before indicating to the application layer that the TLS connection has ended. If the application protocol will not transfer any additional data, but will only close the underlying transport connection, then the implementation may choose to close the transport without waiting for the responding close_notify. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.",
      "ja": "TLSを使用してアプリケーションプロトコルは、TLS接続が閉じられた後、任意のデータは、基礎となるトランスポートを介して行うことができることを提供する場合、TLSの実装は、TLS接続が終了したことをアプリケーション層に示す前に、応答は、close_notifyアラートを受信しなければなりません。アプリケーションプロトコルが追加のデータを転送することはありませんが、唯一の基礎となるトランスポート接続をクローズする場合は、その実装は、応答は、close_notifyを待たずにトランスポートを閉じるように選択することができます。この規格のいかなる部分も、TLSの使用プロファイルは、接続が開いているか閉じているときを含め、そのデータ転送を管理する方法を決定するために取られるべきではありません。"
    },
    {
      "indent": 3,
      "text": "NB: It is assumed that closing a connection reliably delivers pending data before destroying the transport.",
      "ja": "NB：確実な接続を閉じると輸送を破壊する前に、保留中のデータを配信するものとします。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Error alerts",
      "section_title": true,
      "ja": "7.2.2. エラーアラート"
    },
    {
      "indent": 3,
      "text": "Error handling in the TLS Handshake protocol is very simple. When an error is detected, the detecting party sends a message to the other party. Upon transmission or receipt of an fatal alert message, both parties immediately close the connection. Servers and clients are required to forget any session-identifiers, keys, and secrets associated with a failed connection. The following error alerts are defined:",
      "ja": "TLSハンドシェイクプロトコルにおけるエラー処理は非常に簡単です。エラーが検出されると、検出当事者が他の当事者にメッセージを送信します。致命的な警告メッセージの送信または受信すると、両当事者は、直ちに接続を閉じます。サーバとクライアントは、失敗した接続に関連付けられているすべてのセッション識別子、キー、および秘密を忘れるために必要とされています。次のエラーアラートが定義されています。"
    },
    {
      "indent": 3,
      "text": "unexpected_message An inappropriate message was received. This alert is always fatal and should never be observed in communication between proper implementations.",
      "ja": "unexpected_message不適切なメッセージが受信されました。このアラートは常にfatalである。適切な実装間の通信に観察すべきではありません。"
    },
    {
      "indent": 3,
      "text": "bad_record_mac This alert is returned if a record is received with an incorrect MAC. This message is always fatal.",
      "ja": "レコードが正しくないMACで受信された場合にbad_record_macこのアラートが返されます。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "decryption_failed A TLSCiphertext decrypted in an invalid way: either it wasn`t an even multiple of the block length or its padding values, when checked, weren`t correct. This message is always fatal.",
      "ja": "TLSCiphertextが無効な方法で復号化されたdecryption_failed：チェックすると、それは、ブロック長やそのパディング値の偶数倍をwasn`tのいずれか、正しいweren`t。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "record_overflow A TLSCiphertext record was received which had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always fatal.",
      "ja": "record_overflow A TLSCiphertextレコードは長さ以上2 ^ 14 + 2048バイト、または以上2 ^ 14の+ 1024バイトとTLSCompressedレコードに復号化されたレコードを有している受信されました。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "decompression_failure The decompression function received improper input (e.g. data that would expand to excessive length). This message is always fatal.",
      "ja": "減圧機能decompression_failure不適切な入力（過剰な長さに拡大する例えばデータ）を受信しました。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "handshake_failure Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available. This is a fatal error.",
      "ja": "握手_警告メッセージの握手_レセプションは、送信者が利用可能なオプション特定のセキュリティパラメータの許容可能なセットを交渉することができなかったことを示しています。これは致命的なエラーです。"
    },
    {
      "indent": 3,
      "text": "bad_certificate A certificate was corrupt, contained signatures that did not verify correctly, etc.",
      "ja": "証明書が破損したbad_certificate、正しく検証しませんでした署名などが含まれてい"
    },
    {
      "indent": 3,
      "text": "unsupported_certificate A certificate was of an unsupported type.",
      "ja": "unsupported_certificate証明書はサポートされていないタイプでした。"
    },
    {
      "indent": 3,
      "text": "certificate_revoked A certificate was revoked by its signer.",
      "ja": "証明書は、その署名者によって取り消されましたcertificate_revoked。"
    },
    {
      "indent": 3,
      "text": "certificate_expired A certificate has expired or is not currently valid.",
      "ja": "証明書の有効期限が切れたり、現在有効ではありませんしていcertificate_expired。"
    },
    {
      "indent": 3,
      "text": "certificate_unknown Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.",
      "ja": "他のいくつかの（詳細不明）問題certificate_unknown容認できない、それをレンダリング、証明書の処理で生じました。"
    },
    {
      "indent": 3,
      "text": "illegal_parameter A field in the handshake was out of range or inconsistent with other fields. This is always fatal.",
      "ja": "握手のフィールドillegal_parameter範囲外であったか、他のフィールドと矛盾。これは、常に致命的です。"
    },
    {
      "indent": 3,
      "text": "unknown_ca A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn`t be matched with a known, trusted CA. This message is always fatal.",
      "ja": "unknown_ca有効な証明書チェーンまたは部分的にチェーンを受信しましたが、CA証明書が見つかりませんでしたか、知られている、信頼できるCAと一致するcouldn`tので、証明書は受け入れられませんでしたこのメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "access_denied A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation. This message is always fatal.",
      "ja": "ACCESS_DENIED有効な証明書を受信しましたが、アクセス制御が適用されたとき、送信者が交渉を進めないことを決定しました。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "decode_error A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This message is always fatal.",
      "ja": "いくつかのフィールドは、指定された範囲外であったか、メッセージの長さが間違っていたのでdecode_errorメッセージをデコードできませんでした。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "decrypt_error A handshake cryptographic operation failed, including being unable to correctly verify a signature, decrypt a key exchange, or validate a finished message.",
      "ja": "ハンドシェーク暗号演算decrypt_error正しく署名を検証鍵交換を復号化、または完成したメッセージを検証することができないことを含めて、失敗しました。"
    },
    {
      "indent": 3,
      "text": "export_restriction A negotiation not in compliance with export restrictions was detected; for example, attempting to transfer a 1024 bit ephemeral RSA key for the RSA_EXPORT handshake method. This message is always fatal.",
      "ja": "輸出規制に準拠した交渉ではないが検出されたexport_restriction。例えば、RSA_EXPORTハンドシェーク方法1024ビットエフェメラルRSA鍵を転送しようとします。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "protocol_version The protocol version the client has attempted to negotiate is recognized, but not supported. (For example, old protocol versions might be avoided for security reasons). This message is always fatal.",
      "ja": "クライアントが交渉しようとしたプロトコルバージョンをPROTOCOL_VERSION認識したが、サポートされていません。 （例えば、古いプロトコルバージョンは、セキュリティ上の理由から回避される可能性があります）。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "insufficient_security Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal.",
      "ja": "サーバがクライアントによってサポートされているものよりもより安全な暗号を必要とするため、交渉が具体的に失敗したときinsufficient_securityは握手_の代わりに返されます。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "internal_error An internal error unrelated to the peer or the correctness of the protocol makes it impossible to continue (such as a memory allocation failure). This message is always fatal.",
      "ja": "ピアまたはプロトコルの正しさとは無関係に、内部エラーINTERNAL_ERRORが不可能（例えば、メモリ割り当て障害など）を続行することができます。このメッセージは常に致命的です。"
    },
    {
      "indent": 3,
      "text": "user_canceled This handshake is being canceled for some reason unrelated to a protocol failure. If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate. This alert should be followed by a close_notify. This message is generally a warning.",
      "ja": "user_canceledこのハンドシェイクは、プロトコルのエラーとは関係のない理由でキャンセルされています。握手だけでは、close_notifyを送信することにより、接続を閉じる、完了した後、ユーザーが操作をキャンセルした場合、より適切です。このアラートの後には、close_notifyが続くべきです。このメッセージは、一般的警告です。"
    },
    {
      "indent": 3,
      "text": "no_renegotiation Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert; at that point, the original requester can decide whether to proceed with the connection. One case where this would be appropriate would be where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc.) at startup and it might be difficult to communicate changes to these parameters after that point. This message is always a warning.",
      "ja": "no_renegotiationは、初期ハンドシェイクの後にクライアントハローに応じて、ハロー要求に応じて、クライアントまたはサーバーによって送信されます。これらのいずれかが正常に再交渉につながります。それが適切でない場合、受信者はこのアラートに応答すべきです。その時点で、オリジナルのリクエスタは、接続を続行するかどうかを決定することができます。サーバは要求を満たすためのプロセスを生み出した場合、これは適切であろう一つの場合は、あろう。このプロセスは、起動時にセキュリティパラメータ（鍵長、認証など）を受ける可能性があり、その時点の後に、これらのパラメータの変更を通信することは困難かもしれません。このメッセージは、常に警告です。"
    },
    {
      "indent": 3,
      "text": "For all errors where an alert level is not explicitly specified, the sending party may determine at its discretion whether this is a fatal error or not; if an alert with a level of warning is received, the receiving party may decide at its discretion whether to treat this as a fatal error or not. However, all messages which are transmitted with a level of fatal must be treated as fatal messages.",
      "ja": "警戒レベルが明示的に指定されていないすべてのエラーのため、送信側は、これは致命的なエラーであるかどうかをその裁量により決定することができます。警告のレベルの警報を受信した場合、受信側は致命的なエラーとしてこれを治療するかどうかをその裁量で決めることができます。しかし、致命的なレベルで送信されるすべてのメッセージは致命的なメッセージとして扱われなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.3. Handshake Protocol overview",
      "section_title": true,
      "ja": "7.3. ハンドシェイクプロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The cryptographic parameters of the session state are produced by the TLS Handshake Protocol, which operates on top of the TLS Record Layer. When a TLS client and server first start communicating, they agree on a protocol version, select cryptographic algorithms, optionally authenticate each other, and use public-key encryption techniques to generate shared secrets.",
      "ja": "セッション状態の暗号パラメータは、TLSレコード層の上で動作TLSハンドシェイクプロトコルによって生成されます。 TLSクライアントとサーバが最初に通信を開始すると、彼らは、必要に応じて相互に認証、暗号化アルゴリズムを選択し、共有秘密を生成するために、公開鍵暗号化技術を使用し、プロトコルバージョンについては同意します。"
    },
    {
      "indent": 3,
      "text": "The TLS Handshake Protocol involves the following steps:",
      "ja": "TLSハンドシェイクプロトコルは、次の手順を実行します。"
    },
    {
      "indent": 5,
      "text": "- Exchange hello messages to agree on algorithms, exchange random values, and check for session resumption.",
      "ja": " - 為替helloメッセージは、アルゴリズムに同意し、ランダムな値を交換し、セッション再開をチェックします。"
    },
    {
      "indent": 5,
      "text": "- Exchange the necessary cryptographic parameters to allow the client and server to agree on a premaster secret.",
      "ja": " - クライアントとサーバがプレマスター秘密に同意できるようにするために必要な暗号パラメータを交換します。"
    },
    {
      "indent": 5,
      "text": "- Exchange certificates and cryptographic information to allow the client and server to authenticate themselves.",
      "ja": " - 為替証明書と暗号情報は、クライアントとサーバーが自分自身を認証できるようにします。"
    },
    {
      "indent": 5,
      "text": "- Generate a master secret from the premaster secret and exchanged random values.",
      "ja": " - このpremaster_secretからマスターシークレットを生成し、ランダムな値を交換しました。"
    },
    {
      "indent": 5,
      "text": "- Provide security parameters to the record layer.",
      "ja": " - 記録層にセキュリティパラメータを提供します。"
    },
    {
      "indent": 5,
      "text": "- Allow the client and server to verify that their peer has calculated the same security parameters and that the handshake occurred without tampering by an attacker.",
      "ja": " - クライアントとサーバがそのピアが同じセキュリティパラメータを計算し、ハンドシェイクが攻撃者によって改ざんせずに発生したことをしていることを確認できるようにします。"
    },
    {
      "indent": 3,
      "text": "Note that higher layers should not be overly reliant on TLS always negotiating the strongest possible connection between two peers: there are a number of ways a man in the middle attacker can attempt to make two entities drop down to the least secure method they support. The protocol has been designed to minimize this risk, but there are still attacks available: for example, an attacker could block access to the port a secure service runs on, or attempt to get the peers to negotiate an unauthenticated connection. The fundamental rule is that higher levels must be cognizant of what their security requirements are and never transmit information over a channel less secure than what they require. The TLS protocol is secure, in that any cipher suite offers its promised level of security: if you negotiate 3DES with a 1024 bit RSA key exchange with a host whose certificate you have verified, you can expect to be that secure.",
      "ja": "上位層は、TLSは常に2つのピア間の最強の可能な接続のネゴシエーションに過度に依存すべきではないことに注意してください：ミドル攻撃者の男は、2つのエンティティは、彼らがサポートする最も安全な方法まで低下させることを試みることができるいくつかの方法があります。プロトコルは、このリスクを最小限に抑えるように設計されていますが、利用可能な攻撃が残っています。たとえば、攻撃者がポートへのアクセスをブロックすることができ、安全なサービスが稼動する、またはピアが認証されていない接続を交渉するために取得しようとします。基本的なルールは、より高いレベルがそのセキュリティ要件が何であるかを認識することと、彼らが必要とするものよりも安全チャネルを介して情報を送信することはありませんしなければならないということです。 TLSプロトコルはその中で、任意のセキュアな暗号スイートは、セキュリティの約束のレベルを提供しています：あなたは、その証明書あなたが確認したホストと1024ビットRSA鍵交換と3DESを交渉するならば、それは安全であると期待できます。"
    },
    {
      "indent": 3,
      "text": "However, you should never send data over a link encrypted with 40 bit security unless you feel that data is worth no more than the effort required to break that encryption.",
      "ja": "しかし、あなたは、データがその暗号を破るために必要な労力を超えない価値があると感じていない限り、40ビットのセキュリティと暗号化されたリンクを介してデータを送信することはありません。"
    },
    {
      "indent": 3,
      "text": "These goals are achieved by the handshake protocol, which can be summarized as follows: The client sends a client hello message to which the server must respond with a server hello message, or else a fatal error will occur and the connection will fail. The client hello and server hello are used to establish security enhancement capabilities between client and server. The client hello and server hello establish the following attributes: Protocol Version, Session ID, Cipher Suite, and Compression Method. Additionally, two random values are generated and exchanged: ClientHello.random and ServerHello.random.",
      "ja": "これらの目標は、次のように要約することができるハンドシェイクプロトコルによって達成される：クライアントは、サーバがサーバハローメッセージで応答しなければならない、または他の致命的なエラーが発生しますと、接続が失敗する先のクライアントhelloメッセージを送信します。クライアントハローとサーバハローは、クライアントとサーバ間のセキュリティ強化機能を確立するために使用されています。プロトコルバージョン、セッションID、暗号スイート、および圧縮方法：クライアントハローとサーバはハロー次の属性を確立します。さらに、2つのランダムな値が生成され、交換される：ClientHello.randomとしてServerHello.randomを。"
    },
    {
      "indent": 3,
      "text": "The actual key exchange uses up to four messages: the server certificate, the server key exchange, the client certificate, and the client key exchange. New key exchange methods can be created by specifying a format for these messages and defining the use of the messages to allow the client and server to agree upon a shared secret. This secret should be quite long; currently defined key exchange methods exchange secrets which range from 48 to 128 bytes in length.",
      "ja": "サーバ証明書、サーバの鍵交換、クライアント証明書、およびクライアント鍵交換：実際のキー交換は4つのまでのメッセージを使用しています。新しい鍵交換方法は、これらのメッセージのフォーマットを指定すると、クライアントとサーバが共有秘密に同意することを可能にするメッセージの使用を定義することによって作成することができます。この秘密は非常に長くすべきです。現在、長さが48から128バイトの範囲で鍵交換方法交換秘密を定義しました。"
    },
    {
      "indent": 3,
      "text": "Following the hello messages, the server will send its certificate, if it is to be authenticated. Additionally, a server key exchange message may be sent, if it is required (e.g. if their server has no certificate, or if its certificate is for signing only). If the server is authenticated, it may request a certificate from the client, if that is appropriate to the cipher suite selected. Now the server will send the server hello done message, indicating that the hello-message phase of the handshake is complete. The server will then wait for a client response. If the server has sent a certificate request message, the client must send the certificate message. The client key exchange message is now sent, and the content of that message will depend on the public key algorithm selected between the client hello and the server hello. If the client has sent a certificate with signing ability, a digitally-signed certificate verify message is sent to explicitly verify the certificate.",
      "ja": "それが認証される場合はhelloメッセージに続き、サーバは、その証明書を送信します。それが必要な場合、さらに、サーバーキー交換メッセージは、送信されても​​よい（例えば、それらのサーバは全く証明書を持たない場合、またはその証明書は、署名のためのものである場合）。サーバーが認証された場合には、選択された暗号スイートに適切であれば、それは、クライアントからの証明書を要求することができます。今、サーバは、サーバのハローがハンドシェイクのハロー・メッセージフェーズが完了したことを示す、メッセージを行って送信します。その後、サーバーはクライアントの応答を待ちます。サーバが証明書要求メッセージを送信した場合、クライアントは、証明書のメッセージを送信する必要があります。クライアント鍵交換メッセージは、現在送信され、そのメッセージの内容は、クライアントハローとサーバハローの間で選択された公開鍵アルゴリズムに依存します。クライアントが署名能力を持つ証明書を送信した場合、デジタル署名された証明書は、メッセージが明示的に証明書を検証するために送信されることを確認します。"
    },
    {
      "indent": 3,
      "text": "At this point, a change cipher spec message is sent by the client, and the client copies the pending Cipher Spec into the current Cipher Spec. The client then immediately sends the finished message under the new algorithms, keys, and secrets. In response, the server will send its own change cipher spec message, transfer the pending to the current Cipher Spec, and send its finished message under the new",
      "ja": "この時点で、ChangeCipherSpecメッセージは、現在の暗号スペックに未決の暗号スペックをクライアントから送信され、クライアントコピーされます。その後、クライアントは、直ちに新しいアルゴリズム、鍵、および秘密の下に完成したメッセージを送信します。応答では、サーバーは、現在の暗号スペックに保留転送、自身のChangeCipherSpecメッセージを送信し、新しいの下でその完成メッセージを送ります"
    },
    {
      "indent": 3,
      "text": "Cipher Spec. At this point, the handshake is complete and the client and server may begin to exchange application layer data. (See flow chart below.)",
      "ja": "暗号仕様。この時点で、ハンドシェイクが完了し、クライアントとサーバは、アプリケーション層のデータを交換し始めるかもしれません。 （以下のフローチャートを参照してください）。"
    },
    {
      "indent": 6,
      "text": "Client Server",
      "ja": "クライアントサーバー"
    },
    {
      "indent": 6,
      "text": "ClientHello                  -------->\n                                                ServerHello\n                                               Certificate*\n                                         ServerKeyExchange*\n                                        CertificateRequest*\n                             <--------      ServerHelloDone\nCertificate*\nClientKeyExchange\nCertificateVerify*\n[ChangeCipherSpec]\nFinished                     -------->\n                                         [ChangeCipherSpec]\n                             <--------             Finished\nApplication Data             <------->     Application Data",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Fig. 1 - Message flow for a full handshake",
      "ja": "図1  - フルハンドシェークのメッセージフロー"
    },
    {
      "indent": 3,
      "text": "* Indicates optional or situation-dependent messages that are not always sent.",
      "ja": "*常に送信されていないオプションや状況依存のメッセージを示します。"
    },
    {
      "indent": 2,
      "text": "Note: To help avoid pipeline stalls, ChangeCipherSpec is an independent TLS Protocol content type, and is not actually a TLS handshake message.",
      "ja": "注意：パイプラインの停止を避けるために、ChangeCipherSpecを、独立したTLSプロトコルコンテンツタイプであり、実際TLSハンドシェイクメッセージではありません。"
    },
    {
      "indent": 3,
      "text": "When the client and server decide to resume a previous session or duplicate an existing session (instead of negotiating new security parameters) the message flow is as follows:",
      "ja": "クライアントとサーバーは、メッセージ・フローを、前のセッションを再開するか、（代わりに新しいセキュリティパラメータを交渉の）既存のセッションを複製することを決定した場合は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "The client sends a ClientHello using the Session ID of the session to be resumed. The server then checks its session cache for a match. If a match is found, and the server is willing to re-establish the connection under the specified session state, it will send a ServerHello with the same Session ID value. At this point, both client and server must send change cipher spec messages and proceed directly to finished messages. Once the re-establishment is complete, the client and server may begin to exchange application layer data. (See flow chart below.) If a Session ID match is not found, the server generates a new session ID and the TLS client and server perform a full handshake.",
      "ja": "クライアントが再開されるセッションのセッションIDを使用してClientHelloを送信します。その後、サーバーは、一致するセッションキャッシュをチェックします。一致するものが見つかった、とサーバーが指定されたセッション状態の下でコネクションを再確立しようとした場合は、同じセッションIDの値を含めたServerHelloメッセージを送信します。この時点で、クライアントとサーバの両方は、ChangeCipherSpecメッセージを送信する必要があり、完成したメッセージに直接進みます。再確立が完了すると、クライアントとサーバは、アプリケーション層のデータを交換し始めるかもしれません。セッションIDの一致が見つからない場合（下のフローチャートを参照してください。）、サーバーは新しいセッションIDを生成し、TLSクライアントとサーバは完全な握手を実行します。"
    },
    {
      "indent": 6,
      "text": "Client Server",
      "ja": "クライアントサーバー"
    },
    {
      "indent": 6,
      "text": "ClientHello                   -------->\n                                                 ServerHello\n                                          [ChangeCipherSpec]\n                              <--------             Finished\n[ChangeCipherSpec]\nFinished                      -------->\nApplication Data              <------->     Application Data",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Fig. 2 - Message flow for an abbreviated handshake",
      "ja": "図2  - 。略すハンドシェイクのメッセージフロー"
    },
    {
      "indent": 3,
      "text": "The contents and significance of each message will be presented in detail in the following sections.",
      "ja": "コンテンツ及び各メッセージの意味は、以下のセクションで詳細に提示されるであろう。"
    },
    {
      "indent": 0,
      "text": "7.4. Handshake protocol",
      "section_title": true,
      "ja": "7.4. ハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "The TLS Handshake Protocol is one of the defined higher level clients of the TLS Record Protocol. This protocol is used to negotiate the secure attributes of a session. Handshake messages are supplied to the TLS Record Layer, where they are encapsulated within one or more TLSPlaintext structures, which are processed and transmitted as specified by the current active session state.",
      "ja": "TLSハンドシェイクプロトコルは、TLSレコードプロトコルの定義された高いレベルのクライアントの一つです。このプロトコルは、セッションの安全な属性を交渉するために使用されます。ハンドシェイクメッセージは、それらが現在アクティブなセッション状態によって指定されるように処理され、送信される1つのまたは複数のTLSPlaintext構造内に封入されているTLSレコード層に供給されます。"
    },
    {
      "indent": 7,
      "text": "enum {\n    hello_request(0), client_hello(1), server_hello(2),\n    certificate(11), server_key_exchange (12),\n    certificate_request(13), server_hello_done(14),\n    certificate_verify(15), client_key_exchange(16),\n    finished(20), (255)\n} HandshakeType;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "struct {\n    HandshakeType msg_type;    /* handshake type */\n    uint24 length;             /* bytes in message */\n    select (HandshakeType) {\n        case hello_request:       HelloRequest;\n        case client_hello:        ClientHello;\n        case server_hello:        ServerHello;\n        case certificate:         Certificate;\n        case server_key_exchange: ServerKeyExchange;\n        case certificate_request: CertificateRequest;\n        case server_hello_done:   ServerHelloDone;\n        case certificate_verify:  CertificateVerify;\n        case client_key_exchange: ClientKeyExchange;\n        case finished:            Finished;\n    } body;\n} Handshake;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The handshake protocol messages are presented below in the order they must be sent; sending handshake messages in an unexpected order results in a fatal error. Unneeded handshake messages can be omitted, however. Note one exception to the ordering: the Certificate message is used twice in the handshake (from server to client, then from client to server), but described only in its first position. The one message which is not bound by these ordering rules in the Hello Request message, which can be sent at any time, but which should be ignored by the client if it arrives in the middle of a handshake.",
      "ja": "握手プロトコルメッセージは、それらが送られなければならないために、以下に提示します。致命的なエラーで予期しないため結果にハンドシェイクメッセージを送信します。不要なハンドシェイクメッセージは、しかし、省略することができます。順序に一つの例外に注意してください：Certificateメッセージは、（サーバからクライアントに、クライアントからサーバーへの）ハンドシェイクで二回使用されるが、その最初の位置にのみ記載されています。いつでも送信することができますが、それは握手の途中に到着した場合、クライアントによって無視されるべきこんにちはRequestメッセージ、これらの発注ルールに縛られていない一つのメッセージ。"
    },
    {
      "indent": 0,
      "text": "7.4.1. Hello messages",
      "section_title": true,
      "ja": "7.4.1.  helloメッセージ"
    },
    {
      "indent": 3,
      "text": "The hello phase messages are used to exchange security enhancement capabilities between the client and server. When a new session begins, the Record Layer's connection state encryption, hash, and compression algorithms are initialized to null. The current connection state is used for renegotiation messages.",
      "ja": "ハロー位相メッセージは、クライアントとサーバ間のセキュリティ強化機能を交換するために使用されています。新しいセッションが始まると、レコード層の接続状態の暗号化、ハッシュ、および圧縮アルゴリズムはnullに初期化されます。現在の接続状態が再交渉メッセージに使用されます。"
    },
    {
      "indent": 0,
      "text": "7.4.1.1. Hello request",
      "section_title": true,
      "ja": "7.4.1.1。こんにちはリクエスト"
    },
    {
      "indent": 3,
      "text": "When this message will be sent: The hello request message may be sent by the server at any time.",
      "ja": "ときにこのメッセージが送信されます：ハロー要求メッセージは、いつでもサーバによって送信することができます。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message: Hello request is a simple notification that the client should begin the negotiation process anew by sending a client hello message when convenient. This message will be ignored by the client if the client is currently negotiating a session. This message may be ignored by the client if it does not wish to renegotiate a session, or the client may, if it wishes, respond with a no_renegotiation alert. Since handshake messages are intended to have transmission precedence over application data, it is expected that the negotiation will begin before no more than a few records are received from the client. If the server sends a hello request but does not receive a client hello in response, it may close the connection with a fatal alert.",
      "ja": "このメッセージの意味：こんにちは要求は、クライアントが都合のよいときに、クライアントのhelloメッセージを送信することにより、新たに交渉プロセスを開始する必要があり、単純な通知です。クライアントが現在のセッションを交渉している場合、このメッセージはクライアントによって無視されます。それは、セッションを再交渉したくない場合、このメッセージは、クライアントによって無視されてもよいし、クライアントは、それが希望する場合、no_renegotiationのアラートに応答することができます。ハンドシェイクメッセージは、アプリケーションデータを介した送信の優先順位を有することが意図されているので、それを超えない数のレコードがクライアントから受信される前に交渉が開始されることが期待されます。サーバはハローリクエストを送信しますが、応答でクライアントのhelloを受信しない場合、それは致命的な警告との接続を閉じることができます。"
    },
    {
      "indent": 3,
      "text": "After sending a hello request, servers should not repeat the request until the subsequent handshake negotiation is complete.",
      "ja": "その後の握手交渉が完了するまでのhello要求を送信した後、サーバはリクエストを繰り返すべきではありません。"
    },
    {
      "indent": 3,
      "text": "Structure of this message: struct { } HelloRequest;",
      "ja": "このメッセージの構造：構造体{} HelloRequest。"
    },
    {
      "indent": 1,
      "text": "Note: This message should never be included in the message hashes which are maintained throughout the handshake and used in the finished messages and the certificate verify message.",
      "ja": "注：このメッセージは、ハンドシェイクを通じて維持し、完成したメッセージで使用された証明書は、メッセージを確認しているメッセージのハッシュに含まれるべきではありません。"
    },
    {
      "indent": 0,
      "text": "7.4.1.2. Client hello",
      "section_title": true,
      "ja": "7.4.1.2。クライアントハロー"
    },
    {
      "indent": 3,
      "text": "When this message will be sent: When a client first connects to a server it is required to send the client hello as its first message. The client can also send a client hello in response to a hello request or on its own initiative in order to renegotiate the security parameters in an existing connection.",
      "ja": "このメッセージが送信されるとき：クライアントが最初のサーバに接続するときには、その最初のメッセージとして、クライアントのhelloを送信するために必要とされます。また、クライアントは、ハロー要求したり、既存の接続におけるセキュリティパラメータを再交渉するために、自らに応じて、クライアントのhelloを送信することができます。"
    },
    {
      "indent": 7,
      "text": "Structure of this message:\n    The client hello message includes a random structure, which is\n    used later in the protocol.",
      "raw": true
    },
    {
      "indent": 11,
      "text": "struct {\n   uint32 gmt_unix_time;\n   opaque random_bytes[28];\n} Random;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "gmt_unix_time The current time and date in standard UNIX 32-bit format (seconds since the midnight starting Jan 1, 1970, GMT) according to the sender's internal clock. Clocks are not required to be set correctly by the basic TLS Protocol; higher level or application protocols may define additional requirements.",
      "ja": "送信者の内部クロックに応じて（1970年1月1日、GMTを開始午前0時からの秒）の標準的なUNIX 32ビットフォーマットで現在の時刻と日付をgmt_unix_time。時計は、基本的なTLSプロトコルによって正しく設定されている必要はありません。より高いレベルまたはアプリケーションプロトコルが追加要件を定義してもよいです。"
    },
    {
      "indent": 3,
      "text": "random_bytes 28 bytes generated by a secure random number generator.",
      "ja": "安全な乱数生成器によって生成された28のバイトをrandom_bytes。"
    },
    {
      "indent": 3,
      "text": "The client hello message includes a variable length session identifier. If not empty, the value identifies a session between the same client and server whose security parameters the client wishes to reuse. The session identifier may be from an earlier connection, this connection, or another currently active connection. The second option is useful if the client only wishes to update the random structures and derived values of a connection, while the third option makes it possible to establish several independent secure connections without repeating the full handshake protocol. These independent connections may occur sequentially or simultaneously; a SessionID becomes valid when the handshake negotiating it completes with the exchange of Finished messages and persists until removed due to aging or because a fatal error was encountered on a connection associated with the session. The actual contents of the SessionID are defined by the server.",
      "ja": "クライアントのhelloメッセージは、可変長のセッション識別子を含みます。空でない場合、値は、セキュリティパラメータ、クライアントが再利用しようと、同じクライアントとサーバ間のセッションを識別する。セッション識別子は、以前の接続、これに関連し、または別の現在アクティブな接続からのものであってもよいです。第三の選択肢は、完全なハンドシェイクプロトコルを繰り返さずに、いくつかの独立した安全な接続を確立することを可能にする一方で、クライアントはのみ、ランダム構造および接続の派生値を更新したい場合は、2番目のオプションが便利です。これらの独立した接続を順次又は同時に起こり得ます。それを交渉のハンドシェイクが完成メッセージの交換を完了し、経年変化や致命的なエラーがセッションに関連付けられている接続に遭遇したため、削除されるまで持続したときにセッションIDが有効になります。セッションIDの実際の内容はサーバーによって定義されています。"
    },
    {
      "indent": 7,
      "text": "opaque SessionID<0..32>;",
      "ja": "不透明なセッションID <0 32>。"
    },
    {
      "indent": 3,
      "text": "Warning: Because the SessionID is transmitted without encryption or immediate MAC protection, servers must not place confidential information in session identifiers or let the contents of fake session identifiers cause any breach of security. (Note that the content of the handshake as a whole, including the SessionID, is protected by the Finished messages exchanged at the end of the handshake.)",
      "ja": "警告：セッションIDは、暗号化または即時MAC保護なしで送信されるため、サーバはセッション識別子に秘密情報を置くか、偽のセッション識別子の内容は、セキュリティの違反を起こさせてはなりません。 （ハンドシェイクの終了時に交換SessionIDを含む全体としてのハンドシェイクのコンテンツは、Finishedメッセージによって保護されることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "The CipherSuite list, passed from the client to the server in the client hello message, contains the combinations of cryptographic algorithms supported by the client in order of the client's preference (favorite choice first). Each CipherSuite defines a key exchange algorithm, a bulk encryption algorithm (including secret key length) and a MAC algorithm. The server will select a cipher suite or, if no acceptable choices are presented, return a handshake failure alert and close the connection.",
      "ja": "クライアントのhelloメッセージでクライアントからサーバに渡されたのCipherSuiteのリストは、クライアントの好み（最初のお気に入りの選択）のために、クライアントでサポートされている暗号アルゴリズムの組み合わせが含まれています。それぞれのCipherSuiteは、鍵交換アルゴリズム、（秘密鍵の長さを含む）をバルク暗号化アルゴリズムとMACアルゴリズムを定義します。サーバーは、暗号スイートを選択するか、受け入れ可能な選択肢が提示されていない場合、handshake_failureアラートを返して接続を閉じます。"
    },
    {
      "indent": 7,
      "text": "uint8 CipherSuite[2];    /* Cryptographic suite selector */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The client hello includes a list of compression algorithms supported by the client, ordered according to the client's preference.",
      "ja": "クライアントのhelloが、クライアントの好みに応じて注文したクライアントでサポートされている圧縮アルゴリズムのリストが含まれています。"
    },
    {
      "indent": 7,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "ja": "列挙{ヌル（0）、（255）} CompressionMethod。"
    },
    {
      "indent": 7,
      "text": "struct {\n    ProtocolVersion client_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suites<2..2^16-1>;\n    CompressionMethod compression_methods<1..2^8-1>;\n} ClientHello;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "client_version The version of the TLS protocol by which the client wishes to communicate during this session. This should be the latest (highest valued) version supported by the client. For this version of the specification, the version will be 3.1 (See Appendix E for details about backward compatibility).",
      "ja": "クライアントがこのセッション中に通信することを希望することにより、TLSプロトコルのバージョンをクライアント_。これは、クライアントがサポートする最新（最高のもの）であるべきです。仕様のこのバージョンでは、バージョンは3.1（後方互換性の詳細については、付録Eを参照してください）となります。"
    },
    {
      "indent": 3,
      "text": "random A client-generated random structure.",
      "ja": "ランダムクライアントが生成したランダム構造。"
    },
    {
      "indent": 3,
      "text": "session_id The ID of a session the client wishes to use for this connection. This field should be empty if no session_id is available or the client wishes to generate new security parameters.",
      "ja": "クライアントは、この接続のために使用したいセッションのIDを。 session_idが利用可能でない場合、またはクライアントが新しいセキュリティパラメータを生成することを希望する場合は、このフィールドは空でなければなりません。"
    },
    {
      "indent": 3,
      "text": "cipher_suites This is a list of the cryptographic options supported by the client, with the client's first preference first. If the session_id field is not empty (implying a session resumption request) this vector must include at least the cipher_suite from that session. Values are defined in Appendix A.5.",
      "ja": "cipher_suitesこれは、最初のクライアントの最初の好みで、クライアントによってサポートされている暗号オプションのリストです。 SESSION_IDフィールドが空でない場合、このベクトルはそのセッションから少なくとも暗号_スイートを含まなければならない（セッション再開リクエストを意味します）。値は、付録A.5で定義されています。"
    },
    {
      "indent": 3,
      "text": "compression_methods This is a list of the compression methods supported by the client, sorted by client preference. If the session_id field is not empty (implying a session resumption request) it must include the compression_method from that session. This vector must contain, and all implementations must support, CompressionMethod.null. Thus, a client and server will always be able to agree on a compression method.",
      "ja": "圧縮_これは、クライアントの好みによってソートされたクライアントによってサポートされている圧縮方法のリストです。 SESSION_IDフィールドは、（セッション再開要求を含意して）空でない場合には、そのセッションのcompression_methodを含まなければなりません。このベクターは、含まれている必要があり、そしてすべての実装は、CompressionMethod.nullをサポートしている必要があります。このように、クライアントとサーバは常に圧縮方法に同意することができるようになります。"
    },
    {
      "indent": 3,
      "text": "After sending the client hello message, the client waits for a server hello message. Any other handshake message returned by the server except for a hello request is treated as a fatal error.",
      "ja": "クライアントのhelloメッセージを送信した後、クライアントは、サーバのhelloメッセージを待機します。ハロー要求を除いて、サーバから返された任意の他の握手メッセージは致命的なエラーとして扱われます。"
    },
    {
      "indent": 3,
      "text": "Forward compatibility note: In the interests of forward compatibility, it is permitted for a client hello message to include extra data after the compression methods. This data must be included in the handshake hashes, but must otherwise be ignored. This is the only handshake message for which this is legal; for all other messages, the amount of data in the message must match the description of the message precisely.",
      "ja": "前方互換性に関する注意：上位互換性の利益では、圧縮方法の後に余分なデータが含まれるように、クライアントのhelloメッセージのために許可されています。このデータは握手ハッシュに含まれなければならないが、それ以外は無視されなければなりません。これは、これが法的であるためにのみ握手メッセージです。他のすべてのメッセージのために、メッセージ内のデータの量が正確にメッセージの記述と一致する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.4.1.3. Server hello",
      "section_title": true,
      "ja": "7.4.1.3。サーバーハロー"
    },
    {
      "indent": 3,
      "text": "When this message will be sent: The server will send this message in response to a client hello message when it was able to find an acceptable set of algorithms. If it cannot find such a match, it will respond with a handshake failure alert.",
      "ja": "ときにこのメッセージが送信されます：許容できるセットのアルゴリズムを見つけることができたとき、サーバは、クライアントのhelloメッセージに応答して、このメッセージを送信します。それは、このような一致が見つからない場合は、握手故障警報で応じるでしょう。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:\n    struct {\n        ProtocolVersion server_version;\n        Random random;\n        SessionID session_id;\n        CipherSuite cipher_suite;\n        CompressionMethod compression_method;\n    } ServerHello;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "server_version This field will contain the lower of that suggested by the client in the client hello and the highest supported by the server. For this version of the specification, the version is 3.1 (See Appendix E for details about backward compatibility).",
      "ja": "SERVER_VERSIONこのフィールドは、クライアントハローにクライアントによって示唆の下を含み、最高サーバによってサポートされます。仕様のこのバージョンでは、バージョンが（後方互換性の詳細については、付録Eを参照してください）3.1です。"
    },
    {
      "indent": 3,
      "text": "random This structure is generated by the server and must be different from (and independent of) ClientHello.random.",
      "ja": "ランダムこの構造は、サーバによって生成され、ClientHello.randomとは異なる（そして独立）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "session_id This is the identity of the session corresponding to this connection. If the ClientHello.session_id was non-empty, the server will look in its session cache for a match. If a match is found and the server is willing to establish the new connection using the specified session state, the server will respond with the same value as was supplied by the client. This indicates a resumed session and dictates that the parties must proceed directly to the finished messages. Otherwise this field will contain a different value identifying the new session. The server may return an empty session_id to indicate that the session will not be cached and therefore cannot be resumed. If a session is resumed, it must be resumed using the same cipher suite it was originally negotiated with.",
      "ja": "SESSION_IDこれは、この接続に対応するセッションのアイデンティティがあります。 ClientHello.session_idが空だった場合、サーバーは、一致のためにそのセッションキャッシュになります。一致するものが見つかったと、サーバーは、指定されたセッション状態を使用して新しい接続を確立するために喜んでいる場合は、サーバはクライアントによって供給されたのと同じ値で応答します。これは再開しているセッションを示し、当事者が完成メッセージへ進まなければなりません。それ以外の場合、このフィールドには、新しいセッションを特定する別の値が含まれます。サーバーは、セッションがキャッシュされませんので、再開できないことを示すために、空のsession_idを返す場合があります。セッションが再開された場合、それは元々と交渉したのと同じ暗号スイートを使用して再開する必要があります。"
    },
    {
      "indent": 3,
      "text": "cipher_suite The single cipher suite selected by the server from the list in ClientHello.cipher_suites. For resumed sessions this field is the value from the state of the session being resumed.",
      "ja": "でClientHello.cipher_内のリストからサーバーによって選ばれた単一の暗号スイートを暗号_スイート。このフィールドが再開されたセッションの状態からの値であるセッションを再開しました。"
    },
    {
      "indent": 3,
      "text": "compression_method The single compression algorithm selected by the server from the list in ClientHello.compression_methods. For resumed sessions this field is the value from the resumed session state.",
      "ja": "ClientHello.compression_メソッドのリストから、サーバによって選択された単一の圧縮アルゴリズムを圧縮_。再開したセッションの場合、このフィールドは再開セッション状態からの値です。"
    },
    {
      "indent": 0,
      "text": "7.4.2. Server certificate",
      "section_title": true,
      "ja": "7.4.2. サーバ証明書"
    },
    {
      "indent": 3,
      "text": "When this message will be sent: The server must send a certificate whenever the agreed-upon key exchange method is not an anonymous one. This message will always immediately follow the server hello message.",
      "ja": "ときにこのメッセージが送信されます：合意された鍵交換方式が匿名のものではない時はいつでも、サーバーが証明書を送信する必要があります。このメッセージは、常にすぐにサーバーのhelloメッセージに従います。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message: The certificate type must be appropriate for the selected cipher suite's key exchange algorithm, and is generally an X.509v3 certificate. It must contain a key which matches the key exchange method, as follows. Unless otherwise specified, the signing algorithm for the certificate must be the same as the algorithm for the certificate key. Unless otherwise specified, the public key may be of any length.",
      "ja": "このメッセージの意味：証明書の種類は、選択した暗号スイートの鍵交換アルゴリズムに適切である、と一般的にX.509v3証明書である必要があります。それは次のように、鍵交換方式に一致するキーが含まれている必要があります。特に指定がない限り、証明書の署名アルゴリズムは、証明書のキーのためのアルゴリズムと同じでなければなりません。特に指定しない限り、公開鍵は、任意の長さのものであってもよいです。"
    },
    {
      "indent": 7,
      "text": "Key Exchange Algorithm Certificate Key Type",
      "ja": "鍵交換アルゴリズム証明書キーの種類"
    },
    {
      "indent": 7,
      "text": "RSA RSA public key; the certificate must allow the key to be used for encryption.",
      "ja": "RSA RSA公開鍵。証明書は、鍵が暗号化に使用できるようにする必要があります。"
    },
    {
      "indent": 7,
      "text": "RSA_EXPORT RSA public key of length greater than 512 bits which can be used for signing, or a key of 512 bits or shorter which can be used for either encryption or signing.",
      "ja": "RSA_EXPORT RSA署名、または暗号化または署名のいずれかのために使用することができる512ビットまたは短いのキーのために使用することができる512ビットを超える長さの公開鍵。"
    },
    {
      "indent": 7,
      "text": "DHE_DSS DSS public key.",
      "ja": "DHE_DSS DSS公開鍵。"
    },
    {
      "indent": 7,
      "text": "DHE_DSS_EXPORT DSS public key.",
      "ja": "DHE_DSS_EXPORT DSS公開鍵。"
    },
    {
      "indent": 7,
      "text": "DHE_RSA RSA public key which can be used for signing.",
      "ja": "署名に使用することができますDHE_RSA RSA公開鍵。"
    },
    {
      "indent": 7,
      "text": "DHE_RSA_EXPORT RSA public key which can be used for signing.",
      "ja": "署名に使用することができますDHE_RSA_EXPORT RSA公開鍵。"
    },
    {
      "indent": 7,
      "text": "DH_DSS Diffie-Hellman key. The algorithm used to sign the certificate should be DSS.",
      "ja": "DH_DSSのDiffie-Hellman鍵。証明書に署名するために使用されるアルゴリズムはDSSでなければなりません。"
    },
    {
      "indent": 7,
      "text": "DH_RSA Diffie-Hellman key. The algorithm used to sign the certificate should be RSA.",
      "ja": "DH_RSAのDiffie-Hellman鍵。証明書に署名するために使用されるアルゴリズムはRSAでなければなりません。"
    },
    {
      "indent": 3,
      "text": "All certificate profiles, key and cryptographic formats are defined by the IETF PKIX working group [PKIX]. When a key usage extension is present, the digitalSignature bit must be set for the key to be eligible for signing, as described above, and the keyEncipherment bit must be present to allow encryption, as described above. The keyAgreement bit must be set on Diffie-Hellman certificates.",
      "ja": "すべての証明書プロファイルは、キーと暗号化フォーマットは、IETF PKIXワーキンググループ[PKIX]によって定義されています。鍵用途拡張が存在する場合、デジタル署名ビットは上述したように、署名の対象とするキーに設定する必要があり、keyEnciphermentビットは、上述したように、暗号化を可能にするために存在しなければなりません。するKeyAgreementビットはのDiffie-Hellman証明書に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "As CipherSuites which specify new key exchange methods are specified for the TLS Protocol, they will imply certificate format and the required encoded keying information.",
      "ja": "新しい鍵交換方法を指定しているCipherSuiteは、TLSプロトコルに指定されているとして、彼らは、証明書の形式と必要なエンコードされたキーイング情報を意味します。"
    },
    {
      "indent": 3,
      "text": "Structure of this message: opaque ASN.1Cert<1..2^24-1>;",
      "ja": "このメッセージの構造：不透明ASN.1Cert <1..2 ^ 24-1>;"
    },
    {
      "indent": 7,
      "text": "struct {\n    ASN.1Cert certificate_list<0..2^24-1>;\n} Certificate;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "certificate_list This is a sequence (chain) of X.509v3 certificates. The sender's certificate must come first in the list. Each following certificate must directly certify the one preceding it. Because certificate validation requires that root keys be distributed independently, the self-signed certificate which specifies the root certificate authority may optionally be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case.",
      "ja": "certificate_listこれはのX.509v3証明書のシーケンス（連鎖）です。送信者の証明書は、リストの最初に来なければなりません。それぞれの次の証明書は直接それに先行するものを証明する必要があります。証明書の検証がルートキーは独立に分布されることを必要とするので、ルート認証局を特定する自己署名証明書は、必要に応じて、リモートエンドが既にどのような場合に、それを検証するためにそれを持っていなければならないという仮定の下で、チェーンから省略されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The same message type and structure will be used for the client's response to a certificate request message. Note that a client may send no certificates if it does not have an appropriate certificate to send in response to the server's authentication request.",
      "ja": "同じメッセージタイプと構造は、証明書要求メッセージに対するクライアントの応答のために使用されます。それは、サーバーの認証要求に応答して送信するための適切な証明書を持っていない場合、クライアントは何の証明書を送信しないことに注意してください。"
    },
    {
      "indent": 1,
      "text": "Note: PKCS #7 [PKCS7] is not used as the format for the certificate vector because PKCS #6 [PKCS6] extended certificates are not used. Also PKCS #7 defines a SET rather than a SEQUENCE, making the task of parsing the list more difficult.",
      "ja": "注：PKCS＃6 [PKCS6】拡張証明書が使用されないので、PKCS＃7 [PKCS7]は、証明書ベクトルの形式として使用されていません。また、＃7は、リストを解析する作業がより困難、というよりも、SEQUENCE SETを定義PKCS。"
    },
    {
      "indent": 0,
      "text": "7.4.3. Server key exchange message",
      "section_title": true,
      "ja": "7.4.3. サーバー鍵交換メッセージ"
    },
    {
      "indent": 3,
      "text": "When this message will be sent: This message will be sent immediately after the server certificate message (or the server hello message, if this is an anonymous negotiation).",
      "ja": "このメッセージが送信されるとき：（これが匿名の交渉である場合、またはサーバーのhelloメッセージ）このメッセージは、サーバ証明書のメッセージの直後に送信されます。"
    },
    {
      "indent": 7,
      "text": "The server key exchange message is sent by the server only when\nthe server certificate message (if sent) does not contain enough\ndata to allow the client to exchange a premaster secret. This is\ntrue for the following key exchange methods:",
      "raw": true
    },
    {
      "indent": 11,
      "text": "RSA_EXPORT (if the public key in the server certificate is\nlonger than 512 bits)\nDHE_DSS\nDHE_DSS_EXPORT\nDHE_RSA\nDHE_RSA_EXPORT\nDH_anon",
      "raw": true
    },
    {
      "indent": 7,
      "text": "It is not legal to send the server key exchange message for the following key exchange methods:",
      "ja": "次の鍵交換方式のためのサーバ鍵交換メッセージを送信するために法的ではありません。"
    },
    {
      "indent": 11,
      "text": "RSA\nRSA_EXPORT (when the public key in the server certificate is\nless than or equal to 512 bits in length)\nDH_DSS\nDH_RSA",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Meaning of this message: This message conveys cryptographic information to allow the client to communicate the premaster secret: either an RSA public key to encrypt the premaster secret with, or a Diffie-Hellman public key with which the client can complete a key exchange (with the result being the premaster secret.)",
      "ja": "このメッセージの意味：このメッセージは、クライアントが秘密のプレマスターを通信できるようにするために、暗号化情報を伝える：どちらかとプリマスターシークレットを暗号化するために、RSA公開鍵、またはクライアントが鍵交換を完了することができたとのDiffie-Hellman公開鍵（と結果は、このpremaster_secretています。）"
    },
    {
      "indent": 3,
      "text": "As additional CipherSuites are defined for TLS which include new key exchange algorithms, the server key exchange message will be sent if and only if the certificate type associated with the key exchange algorithm does not provide enough information for the client to exchange a premaster secret.",
      "ja": "追加のCipherSuitesが新しい鍵交換アルゴリズムを含むTLSのために定義されているとおりとだけ鍵交換アルゴリズムに関連付けられた証明書の種類がプレマスターの秘密を交換するためのクライアントのための十分な情報を提供していない場合場合、サーバー鍵交換メッセージが送信されます。"
    },
    {
      "indent": 1,
      "text": "Note: According to current US export law, RSA moduli larger than 512 bits may not be used for key exchange in software exported from the US. With this message, the larger RSA keys encoded in certificates may be used to sign temporary shorter RSA keys for the RSA_EXPORT key exchange method.",
      "ja": "注意：現在の米国輸出法によると、RSAは、512ビットが米国からエクスポートソフトウェアでの鍵交換のために使用することはできませんよりも大きなモジュラスを。このメッセージでは、証明書にエンコードされ、より大きなRSA鍵はRSA_EXPORT鍵交換方式のための一時的な短いRSA鍵を署名するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Structure of this message: enum { rsa, diffie_hellman } KeyExchangeAlgorithm;",
      "ja": "このメッセージの構造：列挙{RSA、diffie_hellman}のKeyExchangeAlgorithm。"
    },
    {
      "indent": 7,
      "text": "struct {\n    opaque rsa_modulus<1..2^16-1>;\n    opaque rsa_exponent<1..2^16-1>;\n} ServerRSAParams;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "rsa_modulus The modulus of the server's temporary RSA key.",
      "ja": "RSAは、サーバーの一時的RSA鍵のモジュラスモジュラス。"
    },
    {
      "indent": 7,
      "text": "rsa_exponent The public exponent of the server's temporary RSA key.",
      "ja": "サーバーの一時的RSA鍵の公開指数をrsa_exponent。"
    },
    {
      "indent": 7,
      "text": "struct {\n    opaque dh_p<1..2^16-1>;\n    opaque dh_g<1..2^16-1>;\n    opaque dh_Ys<1..2^16-1>;\n} ServerDHParams;     /* Ephemeral DH parameters */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "dh_p The prime modulus used for the Diffie-Hellman operation.",
      "ja": "Diffie-Hellman演算に使用されるプライムモジュラスをdh_p。"
    },
    {
      "indent": 7,
      "text": "dh_g The generator used for the Diffie-Hellman operation.",
      "ja": "Diffie-Hellman演算に使用される発電機をdh_g。"
    },
    {
      "indent": 7,
      "text": "dh_Ys The server's Diffie-Hellman public value (g^X mod p).",
      "ja": "サーバーののDiffie-Hellman公開値（g ^ Xモッズp）dh_Ys。"
    },
    {
      "indent": 7,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case diffie_hellman:\n            ServerDHParams params;\n            Signature signed_params;\n        case rsa:\n            ServerRSAParams params;\n            Signature signed_params;\n    };\n} ServerKeyExchange;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "params The server's key exchange parameters.",
      "ja": "サーバの鍵交換パラメータをparamsは。"
    },
    {
      "indent": 7,
      "text": "signed_params For non-anonymous key exchanges, a hash of the corresponding params value, with the signature appropriate to that hash applied.",
      "ja": "非匿名鍵交換のsigned_pa​​rams、そのハッシュに適切な署名を有する対応のparams値のハッシュは、適用しました。"
    },
    {
      "indent": 7,
      "text": "md5_hash MD5(ClientHello.random + ServerHello.random + ServerParams);",
      "ja": "md5_hash MD5（ClientHello.randomと+ ServerHello.random + ServerParams）。"
    },
    {
      "indent": 7,
      "text": "sha_hash SHA(ClientHello.random + ServerHello.random + ServerParams);",
      "ja": "sha_hash SHA（ClientHello.randomと+ ServerHello.random + ServerParams）。"
    },
    {
      "indent": 7,
      "text": "enum { anonymous, rsa, dsa } SignatureAlgorithm;",
      "ja": "列挙{匿名、RSA、DSA}のsignatureAlgorithm。"
    },
    {
      "indent": 7,
      "text": "select (SignatureAlgorithm)\n{   case anonymous: struct { };\n    case rsa:\n        digitally-signed struct {\n            opaque md5_hash[16];\n            opaque sha_hash[20];\n        };\n    case dsa:\n        digitally-signed struct {\n            opaque sha_hash[20];\n        };\n} Signature;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.4.4. Certificate request",
      "section_title": true,
      "ja": "7.4.4. 証明書の要求"
    },
    {
      "indent": 3,
      "text": "When this message will be sent: A non-anonymous server can optionally request a certificate from the client, if appropriate for the selected cipher suite. This message, if sent, will immediately follow the Server Key Exchange message (if it is sent; otherwise, the Server Certificate message).",
      "ja": "ときにこのメッセージが送信されます：選択した暗号スイートに適切な場合には非匿名のサーバは、クライアントからの要求に証明書をオプションすることができます。 （それが送られた場合、それ以外の場合、サーバー証明書のメッセージ）このメッセージは、送信された場合は、すぐにサーバ鍵交換メッセージに従います。"
    },
    {
      "indent": 3,
      "text": "Structure of this message: enum { rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4), (255) } ClientCertificateType;",
      "ja": "このメッセージの構造：列挙{rsa_sign（1）、dss_sign（2）、rsa_fixed_dh（3）、dss_fixed_dh（4）、（255）} ClientCertificateType。"
    },
    {
      "indent": 7,
      "text": "opaque DistinguishedName<1..2^16-1>;",
      "ja": "不透明な識別名<1..2 ^ 16-1>;"
    },
    {
      "indent": 7,
      "text": "struct {\n    ClientCertificateType certificate_types<1..2^8-1>;\n    DistinguishedName certificate_authorities<3..2^16-1>;\n} CertificateRequest;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "certificate_types This field is a list of the types of certificates requested, sorted in order of the server's preference.",
      "ja": "証明書_このフィールドは、サーバの優先順にソートされた要求された証明書の種類のリストがあります。"
    },
    {
      "indent": 7,
      "text": "certificate_authorities A list of the distinguished names of acceptable certificate authorities. These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used both to describe known roots and a desired authorization space.",
      "ja": "許容できる認証局の識別名のリストを証明してください。これらの識別名は、ルートCAまたは下位CAのために必要な識別名を指定することもできます。したがって、このメッセージは、既知の根および所望の許可スペースを記述するために両方を使用することができます。"
    },
    {
      "indent": 1,
      "text": "Note: DistinguishedName is derived from [X509].",
      "ja": "注：識別名は[X509]から誘導されます。"
    },
    {
      "indent": 1,
      "text": "Note: It is a fatal handshake_failure alert for an anonymous server to request client identification.",
      "ja": "注意：これは、クライアントの識別を要求する匿名サーバーのための致命的なhandshake_failureアラートとなります。"
    },
    {
      "indent": 0,
      "text": "7.4.5. Server hello done",
      "section_title": true,
      "ja": "7.4.5.  Serverは、ハロー行われ"
    },
    {
      "indent": 3,
      "text": "When this message will be sent: The server hello done message is sent by the server to indicate the end of the server hello and associated messages. After sending this message the server will wait for a client response.",
      "ja": "このメッセージが送信されるとき：サーバハロー行わメッセージは、サーバハローとそれに関連するメッセージの終わりを示すために、サーバによって送信されます。このメッセージを送信した後、サーバはクライアント応答を待っています。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message: This message means that the server is done sending messages to support the key exchange, and the client can proceed with its phase of the key exchange.",
      "ja": "このメッセージの意味：このメッセージは、サーバーが鍵交換をサポートするために、メッセージを送信して行われていることを意味し、クライアントは鍵交換のその段階に進むことができます。"
    },
    {
      "indent": 7,
      "text": "Upon receipt of the server hello done message the client should\nverify that the server provided a valid certificate if required\nand check that the server hello parameters are acceptable.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Structure of this message: struct { } ServerHelloDone;",
      "ja": "このメッセージの構造：構造体{} ServerHelloDone。"
    },
    {
      "indent": 0,
      "text": "7.4.6. Client certificate",
      "section_title": true,
      "ja": "7.4.6. クライアント証明書"
    },
    {
      "indent": 3,
      "text": "When this message will be sent: This is the first message the client can send after receiving a server hello done message. This message is only sent if the server requests a certificate. If no suitable certificate is available, the client should send a certificate message containing no certificates. If client authentication is required by the server for the handshake to continue, it may respond with a fatal handshake failure alert. Client certificates are sent using the Certificate structure defined in Section 7.4.2.",
      "ja": "このメッセージが送信されるとき：これは、クライアントがサーバハロー行ってメッセージを受信した後、送信することができます最初のメッセージです。サーバーが証明書を要求した場合、このメッセージにのみ送信されます。もし適切な証明書が利用できない場合、クライアントは証明書を全く含まない証明書メッセージを送信する必要があります。クライアント認証を継続するためのハンドシェイクのために、サーバーによって要求された場合、それは致命的な握手故障警報で応答することができます。クライアント証明書は、セクション7.4.2で定義された証明書の構造を使用して送信されます。"
    },
    {
      "indent": 1,
      "text": "Note: When using a static Diffie-Hellman based key exchange method (DH_DSS or DH_RSA), if client authentication is requested, the Diffie-Hellman group and generator encoded in the client's certificate must match the server specified Diffie-Hellman parameters if the client's parameters are to be used for the key exchange.",
      "ja": "注：静的なディフィー・ヘルマンベースの鍵交換方式（DH_DSSまたはDH_RSA）を使用する場合、クライアント認証が要求された場合、クライアントのパラメータ場合は、クライアントの証明書でエンコードのDiffie-Hellmanグループとジェネレータは、サーバー指定のDiffie-Hellmanパラメータを一致させる必要があります鍵交換のために使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "7.4.7. Client key exchange message",
      "section_title": true,
      "ja": "7.4.7. クライアント鍵交換メッセージ"
    },
    {
      "indent": 3,
      "text": "When this message will be sent: This message is always sent by the client. It will immediately follow the client certificate message, if it is sent. Otherwise it will be the first message sent by the client after it receives the server hello done message.",
      "ja": "ときにこのメッセージが送信されます：このメッセージは、常にクライアントによって送信されます。それが送信された場合は、直ちに、クライアント証明書のメッセージに従います。それは、サーバハロー行ってメッセージを受信した後、それ以外の場合は、クライアントから送信された最初のメッセージになります。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message: With this message, the premaster secret is set, either though direct transmission of the RSA-encrypted secret, or by the transmission of Diffie-Hellman parameters which will allow each side to agree upon the same premaster secret. When the key exchange method is DH_RSA or DH_DSS, client certification has been requested, and the client was able to respond with a certificate which contained a Diffie-Hellman public key whose parameters (group and generator) matched those specified by the server in its certificate, this message will not contain any data.",
      "ja": "このメッセージの意味：このメッセージでは、プレマスターの秘密は、RSA暗号化秘密の直接伝送けれども、またはそれぞれの側が同じプレマスター秘密に同意することを可能にするのDiffie-Hellmanパラメータを送信することにより、いずれか、設定されています。鍵交換方式がDH_RSAまたはDH_DSSである場合には、クライアント認証が要求されている、そしてクライアントがパラメータ（グループおよび発電機）のDiffie-Hellman公開鍵を含ま証明書で応答することができた、その証明書のサーバーで指定されたものと一致しましたこのメッセージは、すべてのデータは含まれません。"
    },
    {
      "indent": 3,
      "text": "Structure of this message: The choice of messages depends on which key exchange method has been selected. See Section 7.4.3 for the KeyExchangeAlgorithm definition.",
      "ja": "このメッセージの構造：メッセージの選択が鍵交換方式が選択されているに依存します。 KeyExchangeAlgorithm定義に関してセクション7.4.3を参照してください。"
    },
    {
      "indent": 7,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case rsa: EncryptedPreMasterSecret;\n        case diffie_hellman: ClientDiffieHellmanPublic;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    } exchange_keys;\n} ClientKeyExchange;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.4.7.1. RSA encrypted premaster secret message",
      "section_title": true,
      "ja": "7.4.7.1。 RSAは、プリマスター秘密のメッセージを暗号化"
    },
    {
      "indent": 3,
      "text": "Meaning of this message: If RSA is being used for key agreement and authentication, the client generates a 48-byte premaster secret, encrypts it using the public key from the server's certificate or the temporary RSA key provided in a server key exchange message, and sends the result in an encrypted premaster secret message. This structure is a variant of the client key exchange message, not a message in itself.",
      "ja": "このメッセージの意味：RSAが主要な協定と認証に使用されている場合、クライアントは、48バイトのpremaster_secretを生成するサーバーの証明書またはサーバーキー交換メッセージに提供する一時的RSA鍵から公開鍵を使って暗号化し、暗号化されたプレマスター秘密のメッセージに結果を送信します。この構造は、クライアント鍵交換メッセージのバリアントではなく、それ自体がメッセージです。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:\n    struct {\n        ProtocolVersion client_version;\n        opaque random[46];\n    } PreMasterSecret;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "client_version\n    The latest (newest) version supported by the client. This is\n    used to detect version roll-back attacks. Upon receiving the\n    premaster secret, the server should check that this value\n    matches the value transmitted by the client in the client\n    hello message.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "random 46 securely-generated random bytes.",
      "ja": "ランダム46確実に、生成されたランダムバイト。"
    },
    {
      "indent": 7,
      "text": "struct {\n    public-key-encrypted PreMasterSecret pre_master_secret;\n} EncryptedPreMasterSecret;",
      "raw": true
    },
    {
      "indent": 1,
      "text": "Note: An attack discovered by Daniel Bleichenbacher [BLEI] can be used to attack a TLS server which is using PKCS#1 encoded RSA. The attack takes advantage of the fact that by failing in different ways, a TLS server can be coerced into revealing whether a particular message, when decrypted, is properly PKCS#1 formatted or not.",
      "ja": "注意：Daniel Bleichenbacherによって発見された攻撃は、[BLEI] PKCS＃1を使用しているTLSサーバは、RSAをエンコード攻撃するために使用することができます。攻撃が解読特定のメッセージが、PKCS正しくフォーマット＃1であるか否かの異なる方法で失敗することによって、TLSサーバは明らかに強制することができるという事実を利用します。"
    },
    {
      "indent": 7,
      "text": "The best way to avoid vulnerability to this attack is to treat\nincorrectly formatted messages in a manner indistinguishable from\ncorrectly formatted RSA blocks. Thus, when it receives an\nincorrectly formatted RSA block, a server should generate a\nrandom 48-byte value and proceed using it as the premaster\nsecret. Thus, the server will act identically whether the\nreceived RSA block is correctly encoded or not.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "pre_master_secret This random value is generated by the client and is used to generate the master secret, as specified in Section 8.1.",
      "ja": "pre_master_secretはこの乱数値はクライアントによって生成され、セクション8.1で指定されるように、マスターシークレットを生成するために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.4.7.2. Client Diffie-Hellman public value",
      "section_title": true,
      "ja": "7.4.7.2。クライアントのDiffie-Hellman公開値"
    },
    {
      "indent": 3,
      "text": "Meaning of this message: This structure conveys the client's Diffie-Hellman public value (Yc) if it was not already included in the client's certificate. The encoding used for Yc is determined by the enumerated PublicValueEncoding. This structure is a variant of the client key exchange message, not a message in itself.",
      "ja": "このメッセージの意味：それはすでにクライアントの証明書に含まれていなかった場合は、この構造はクライアントのディフィー-Hellman公開値（YC）を伝えます。 Ycのために使用される符号化は、列挙型のPublicValueEncodingによって決定されます。この構造は、クライアント鍵交換メッセージのバリアントではなく、それ自体がメッセージです。"
    },
    {
      "indent": 3,
      "text": "Structure of this message: enum { implicit, explicit } PublicValueEncoding;",
      "ja": "このメッセージの構造：列挙{暗黙的、明示}のPublicValueEncoding。"
    },
    {
      "indent": 7,
      "text": "implicit\n    If the client certificate already contains a suitable\n    Diffie-Hellman key, then Yc is implicit and does not need to\n    be sent again. In this case, the Client Key Exchange message\n    will be sent, but will be empty.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "explicit Yc needs to be sent.",
      "ja": "明示的なYcを送信する必要があります。"
    },
    {
      "indent": 7,
      "text": "struct {\n    select (PublicValueEncoding) {\n        case implicit: struct { };\n        case explicit: opaque dh_Yc<1..2^16-1>;\n    } dh_public;\n} ClientDiffieHellmanPublic;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "dh_Yc The client's Diffie-Hellman public value (Yc).",
      "ja": "クライアントのディフィー-Hellman公開値（YC）dh_Yc。"
    },
    {
      "indent": 0,
      "text": "7.4.8. Certificate verify",
      "section_title": true,
      "ja": "7.4.8. 証明書が検証します"
    },
    {
      "indent": 3,
      "text": "When this message will be sent: This message is used to provide explicit verification of a client certificate. This message is only sent following a client certificate that has signing capability (i.e. all certificates except those containing fixed Diffie-Hellman parameters). When sent, it will immediately follow the client key exchange message.",
      "ja": "このメッセージが送信されるとき：このメッセージは、クライアント証明書の検証を行うのに使用されています。このメッセージは、機能のみを署名したクライアント証明書（固定のDiffie-Hellmanパラメータを含むもの以外のすなわちすべての証明書）は、次の送信されます。送信された場合は、すぐにクライアント鍵交換メッセージに従います。"
    },
    {
      "indent": 3,
      "text": "Structure of this message:\n    struct {\n         Signature signature;\n    } CertificateVerify;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "The Signature type is defined in 7.4.3.",
      "ja": "署名タイプが7.4.3で定義されています。"
    },
    {
      "indent": 7,
      "text": "CertificateVerify.signature.md5_hash MD5(handshake_messages);",
      "ja": "CertificateVerify.signature.md5_hash MD5（握手）。"
    },
    {
      "indent": 7,
      "text": "Certificate.signature.sha_hash SHA(handshake_messages);",
      "ja": "Certificate.signature.sha_hash SHA（握手）。"
    },
    {
      "indent": 3,
      "text": "Here handshake_messages refers to all handshake messages sent or received starting at client hello up to but not including this message, including the type and length fields of the handshake messages. This is the concatenation of all the Handshake structures as defined in 7.4 exchanged thus far.",
      "ja": "ここでは、クライアントから始まる送信または受信したすべてのハンドシェイクメッセージを参照握手ハローが、ハンドシェイクメッセージのタイプと長さフィールドを含む、このメッセージを含めないようにアップ。これは、7.4で定義されているようにすべてのHandshake構造の連結は、これまでに交換されます。"
    },
    {
      "indent": 0,
      "text": "7.4.9. Finished",
      "section_title": true,
      "ja": "7.4.9. 完成"
    },
    {
      "indent": 3,
      "text": "When this message will be sent: A finished message is always sent immediately after a change cipher spec message to verify that the key exchange and authentication processes were successful. It is essential that a change cipher spec message be received between the other handshake messages and the Finished message.",
      "ja": "ときにこのメッセージが送信されます。完成したメッセージは、常に鍵交換と認証プロセスが成功したことを確認するために、すぐにChangeCipherSpecメッセージの後に送信されます。 ChangeCipherSpecメッセージは、他のハンドシェイクメッセージとFinishedメッセージの間で送受信されることが不可欠です。"
    },
    {
      "indent": 3,
      "text": "Meaning of this message: The finished message is the first protected with the just-negotiated algorithms, keys, and secrets. Recipients of finished messages must verify that the contents are correct. Once a side has sent its Finished message and received and validated the Finished message from its peer, it may begin to send and receive application data over the connection.",
      "ja": "このメッセージの意味：Finishedメッセージはただ交渉アルゴリズム、鍵、および秘密で保護最初です。完成したメッセージの受信者は、内容が正しいことを確認する必要があります。側面がFinishedメッセージを送受信し、そのピアからのFinishedメッセージを検証した後、それが接続を介してアプリケーションデータを送受信するために開始することができます。"
    },
    {
      "indent": 7,
      "text": "struct {\n    opaque verify_data[12];\n} Finished;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "verify_data PRF(master_secret, finished_label, MD5(handshake_messages) + SHA-1(handshake_messages)) [0..11];",
      "ja": "verify_data PRF（マスター_、finished_label、MD5（握手）+ SHA-1（握手））[0..11]。"
    },
    {
      "indent": 7,
      "text": "finished_label For Finished messages sent by the client, the string \"client finished\". For Finished messages sent by the server, the string \"server finished\".",
      "ja": "クライアントから送信されたFinishedメッセージについてはfinished_label、文字列「クライアントが終了しました」。サーバによって送信されるFinishedメッセージについては、文字列「サーバが終わっ」。"
    },
    {
      "indent": 7,
      "text": "handshake_messages All of the data from all handshake messages up to but not including this message. This is only data visible at the handshake layer and does not include record layer headers.",
      "ja": "このメッセージを含むすべてのハンドシェイクメッセージまでではなく、データの握手すべて。これは、ハンドシェイク層における可視データのみであり、記録層ヘッダを含んでいません。"
    },
    {
      "indent": 11,
      "text": "This is the concatenation of all the Handshake structures as\ndefined in 7.4 exchanged thus far.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It is a fatal error if a finished message is not preceded by a change cipher spec message at the appropriate point in the handshake.",
      "ja": "完成したメッセージが握手で適切なポイントでChangeCipherSpecメッセージに先行されていない場合は、致命的なエラーです。"
    },
    {
      "indent": 3,
      "text": "The hash contained in finished messages sent by the server incorporate Sender.server; those sent by the client incorporate Sender.client. The value handshake_messages includes all handshake messages starting at client hello up to, but not including, this finished message. This may be different from handshake_messages in Section 7.4.8 because it would include the certificate verify message (if sent). Also, the handshake_messages for the finished message sent by the client will be different from that for the finished message sent by the server, because the one which is sent second will include the prior one.",
      "ja": "サーバー組み込むSender.serverによって送信され、完成したメッセージに含まれるハッシュ。クライアントによって送信されるものにはSender.clientを組み込みます。ここでhandshake_messagesは、クライアントから始まる、しかし、この完成したメッセージを含んでいないすべてのハンドシェイクメッセージが含まれています。 （送信された場合）は、証明書検証メッセージを含むことになるので、これは、セクション7.4.8に握手異なっていてもよいです。第二送信されたもの前いずれかを含むことになるので、また、クライアントによって送信された完成メッセージの握手は、サーバによって送信された完了メッセージとは異なるであろう。"
    },
    {
      "indent": 1,
      "text": "Note: Change cipher spec messages, alerts and any other record types are not handshake messages and are not included in the hash computations. Also, Hello Request messages are omitted from handshake hashes.",
      "ja": "注意：メッセージはハンドシェイクされていない暗号仕様メッセージ、アラートや他のレコードタイプを変更し、ハッシュ計算に含まれていません。また、ハロー要求メッセージは握手ハッシュから省略されています。"
    },
    {
      "indent": 0,
      "text": "8. Cryptographic computations",
      "section_title": true,
      "ja": "8.暗号計算"
    },
    {
      "indent": 3,
      "text": "In order to begin connection protection, the TLS Record Protocol requires specification of a suite of algorithms, a master secret, and the client and server random values. The authentication, encryption, and MAC algorithms are determined by the cipher_suite selected by the server and revealed in the server hello message. The compression algorithm is negotiated in the hello messages, and the random values are exchanged in the hello messages. All that remains is to calculate the master secret.",
      "ja": "接続保護を開始するためには、TLSレコードプロトコルは、アルゴリズムのスイート、マスターシークレット、およびクライアントとサーバーのランダムな値を指定する必要があります。認証、暗号化、およびMACアルゴリズムがサーバハローメッセージ内のサーバによって選択されたと明らかにした暗号_スイートによって決定されます。圧縮アルゴリズムは、helloメッセージに交渉され、ランダムな値がhelloメッセージで交換されています。残っているのは、マスターシークレットを計算することです。"
    },
    {
      "indent": 0,
      "text": "8.1. Computing the master secret",
      "section_title": true,
      "ja": "8.1. マスターシークレットの計算"
    },
    {
      "indent": 3,
      "text": "For all key exchange methods, the same algorithm is used to convert the pre_master_secret into the master_secret. The pre_master_secret should be deleted from memory once the master_secret has been computed.",
      "ja": "すべての鍵交換方法については、同じアルゴリズムがpre_master_secretをmaster_secretに変換するために使用されます。 master_secretが計算されると、pre_master_secretはメモリから削除されなければなりません。"
    },
    {
      "indent": 7,
      "text": "master_secret = PRF(pre_master_secret, \"master secret\",\n                    ClientHello.random + ServerHello.random)\n[0..47];",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The master secret is always exactly 48 bytes in length. The length of the premaster secret will vary depending on key exchange method.",
      "ja": "マスターシークレットの長さは常に正確に48バイトです。このpremaster_secretの長さは、鍵交換方式によって異なります。"
    },
    {
      "indent": 0,
      "text": "8.1.1. RSA",
      "section_title": true,
      "ja": "8.1.1.  RSA"
    },
    {
      "indent": 3,
      "text": "When RSA is used for server authentication and key exchange, a 48- byte pre_master_secret is generated by the client, encrypted under the server's public key, and sent to the server. The server uses its private key to decrypt the pre_master_secret. Both parties then convert the pre_master_secret into the master_secret, as specified above.",
      "ja": "RSAは、サーバー認証と鍵交換のために使用されている場合は、48-バイトのpre_master_secretは、クライアントによって生成されたサーバの公開鍵で暗号化し、サーバーに送信されます。サーバーは、前_のマスター_秘密を解読するためにその秘密鍵を使用しています。両当事者は、その後、上記のような方法でmaster_secretに前_のマスター_秘密に変換します。"
    },
    {
      "indent": 3,
      "text": "RSA digital signatures are performed using PKCS #1 [PKCS1] block type 1. RSA public key encryption is performed using PKCS #1 block type 2.",
      "ja": "RSAデジタル署名は、PKCS＃1を使用して行われる[PKCS1ブロックタイプ1 RSA公開鍵暗号は、PKCS＃1ブロックタイプ2を使用して実行されます。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Diffie-Hellman",
      "section_title": true,
      "ja": "8.1.2. ディフィー・ヘルマン"
    },
    {
      "indent": 3,
      "text": "A conventional Diffie-Hellman computation is performed. The negotiated key (Z) is used as the pre_master_secret, and is converted into the master_secret, as specified above.",
      "ja": "従来のDiffie-Hellman計算が行われます。ネゴシエートされたキー（Z）は、前_のマスター_秘密として使用され、上記指定されるように、マスター_に変換されます。"
    },
    {
      "indent": 1,
      "text": "Note: Diffie-Hellman parameters are specified by the server, and may be either ephemeral or contained within the server's certificate.",
      "ja": "注意：のDiffie-Hellmanパラメータは、サーバによって指定され、一時的またはサーバーの証明書に含まれるのいずれであってもよいです。"
    },
    {
      "indent": 0,
      "text": "9. Mandatory Cipher Suites",
      "section_title": true,
      "ja": "9.必須の暗号スイート"
    },
    {
      "indent": 3,
      "text": "In the absence of an application profile standard specifying otherwise, a TLS compliant application MUST implement the cipher suite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA.",
      "ja": "そうでなければ特定のアプリケーションプロファイル規格の非存在下で、TLS準拠アプリケーションは、暗号スイートTLS_DHE_DSS_WITH_3DES_EDE_CBC_SHAを実装しなければなりません。"
    },
    {
      "indent": 0,
      "text": "10. Application data protocol",
      "section_title": true,
      "ja": "10.アプリケーション・データ・プロトコル"
    },
    {
      "indent": 3,
      "text": "Application data messages are carried by the Record Layer and are fragmented, compressed and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.",
      "ja": "アプリケーションデータメッセージはレコード層によって運ばれ、断片化され、圧縮され、現在の接続状態に基づいて暗号化されています。メッセージは、記録層への透過的なデータとして扱われます。"
    },
    {
      "indent": 0,
      "text": "A. Protocol constant values",
      "ja": "A.プロトコル定数値"
    },
    {
      "indent": 3,
      "text": "This section describes protocol types and constants.",
      "ja": "このセクションでは、プロトコルの種類と定数について説明します。"
    },
    {
      "indent": 0,
      "text": "A.1. Record layer",
      "ja": "A.1。記録層"
    },
    {
      "indent": 4,
      "text": "struct {\n    uint8 major, minor;\n} ProtocolVersion;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "ProtocolVersion version = { 3, 1 };     /* TLS v1.0 */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "enum { change_cipher_spec(20), alert(21), handshake(22), application_data(23), (255) } ContentType;",
      "ja": "列挙{change_cipher_spec（20）、警告（21）、ハンドシェイク（22）、application_data（23）、（255）}のContentType。"
    },
    {
      "indent": 4,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    opaque fragment[TLSPlaintext.length];\n} TLSPlaintext;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    opaque fragment[TLSCompressed.length];\n} TLSCompressed;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct {\n    ContentType type;\n    ProtocolVersion version;\n    uint16 length;\n    select (CipherSpec.cipher_type) {\n        case stream: GenericStreamCipher;\n        case block:  GenericBlockCipher;\n    } fragment;\n} TLSCiphertext;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "stream-ciphered struct {\n    opaque content[TLSCompressed.length];\n    opaque MAC[CipherSpec.hash_size];\n} GenericStreamCipher;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "block-ciphered struct {\n    opaque content[TLSCompressed.length]; opaque MAC[CipherSpec.hash_size];\n    uint8 padding[GenericBlockCipher.padding_length];\n    uint8 padding_length;\n} GenericBlockCipher;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.2. Change cipher specs message",
      "ja": "A.2。暗号仕様メッセージを変更します"
    },
    {
      "indent": 4,
      "text": "struct {\n    enum { change_cipher_spec(1), (255) } type;\n} ChangeCipherSpec;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.3. Alert messages",
      "ja": "A.3。アラートメッセージ"
    },
    {
      "indent": 4,
      "text": "enum { warning(1), fatal(2), (255) } AlertLevel;",
      "ja": "列挙{（1）警告致命的な（2）、（255）} AlertLevel。"
    },
    {
      "indent": 8,
      "text": "enum {\n    close_notify(0),\n    unexpected_message(10),\n    bad_record_mac(20),\n    decryption_failed(21),\n    record_overflow(22),\n    decompression_failure(30),\n    handshake_failure(40),\n    bad_certificate(42),\n    unsupported_certificate(43),\n    certificate_revoked(44),\n    certificate_expired(45),\n    certificate_unknown(46),\n    illegal_parameter(47),\n    unknown_ca(48),\n    access_denied(49),\n    decode_error(50),\n    decrypt_error(51),\n    export_restriction(60),\n    protocol_version(70),\n    insufficient_security(71),\n    internal_error(80),\n    user_canceled(90),\n    no_renegotiation(100),\n    (255)\n} AlertDescription;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct {\n    AlertLevel level;\n    AlertDescription description;\n} Alert;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.4. Handshake protocol",
      "ja": "A.4。ハンドシェイクプロトコル"
    },
    {
      "indent": 4,
      "text": "enum {\n    hello_request(0), client_hello(1), server_hello(2),\n    certificate(11), server_key_exchange (12),\n    certificate_request(13), server_hello_done(14),\n    certificate_verify(15), client_key_exchange(16),\n    finished(20), (255)\n} HandshakeType;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct {\n    HandshakeType msg_type;\n    uint24 length;\n    select (HandshakeType) {\n        case hello_request:       HelloRequest;\n        case client_hello:        ClientHello;\n        case server_hello:        ServerHello;\n        case certificate:         Certificate;\n        case server_key_exchange: ServerKeyExchange;\n        case certificate_request: CertificateRequest;\n        case server_hello_done:   ServerHelloDone;\n        case certificate_verify:  CertificateVerify;\n        case client_key_exchange: ClientKeyExchange;\n        case finished:            Finished;\n    } body;\n} Handshake;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.4.1. Hello messages",
      "ja": "A.4.1。 helloメッセージ"
    },
    {
      "indent": 4,
      "text": "struct { } HelloRequest;",
      "ja": "構造体{} HelloRequest。"
    },
    {
      "indent": 4,
      "text": "struct {\n    uint32 gmt_unix_time;\n    opaque random_bytes[28];\n} Random;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "opaque SessionID<0..32>;",
      "ja": "不透明なセッションID <0 32>。"
    },
    {
      "indent": 4,
      "text": "uint8 CipherSuite[2];",
      "ja": "UINT8のCipherSuite [2]。"
    },
    {
      "indent": 4,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "ja": "列挙{ヌル（0）、（255）} CompressionMethod。"
    },
    {
      "indent": 4,
      "text": "struct {\n    ProtocolVersion client_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suites<2..2^16-1>;\n    CompressionMethod compression_methods<1..2^8-1>;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "} ClientHello;",
      "ja": "ClientHello}。"
    },
    {
      "indent": 4,
      "text": "struct {\n    ProtocolVersion server_version;\n    Random random;\n    SessionID session_id;\n    CipherSuite cipher_suite;\n    CompressionMethod compression_method;\n} ServerHello;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.4.2. Server authentication and key exchange messages",
      "ja": "A.4.2。サーバー認証と鍵交換メッセージ"
    },
    {
      "indent": 4,
      "text": "opaque ASN.1Cert<2^24-1>;",
      "ja": "不透明ASN.1Cert <2 ^ 24-1>;"
    },
    {
      "indent": 4,
      "text": "struct {\n    ASN.1Cert certificate_list<1..2^24-1>;\n} Certificate;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "enum { rsa, diffie_hellman } KeyExchangeAlgorithm;",
      "ja": "列挙{RSA、diffie_hellman}のKeyExchangeAlgorithm。"
    },
    {
      "indent": 4,
      "text": "struct {\n    opaque RSA_modulus<1..2^16-1>;\n    opaque RSA_exponent<1..2^16-1>;\n} ServerRSAParams;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct {\n    opaque DH_p<1..2^16-1>;\n    opaque DH_g<1..2^16-1>;\n    opaque DH_Ys<1..2^16-1>;\n} ServerDHParams;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case diffie_hellman:\n            ServerDHParams params;\n            Signature signed_params;\n        case rsa:\n            ServerRSAParams params;\n            Signature signed_params;\n    };\n} ServerKeyExchange;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "enum { anonymous, rsa, dsa } SignatureAlgorithm;",
      "ja": "列挙{匿名、RSA、DSA}のsignatureAlgorithm。"
    },
    {
      "indent": 4,
      "text": "select (SignatureAlgorithm) { case anonymous: struct { }; case rsa: digitally-signed struct {",
      "ja": "} {構造体;（のsignatureAlgorithm）{ケース匿名を選択ケースRSA：デジタル署名された構造体{"
    },
    {
      "indent": 4,
      "text": "            opaque md5_hash[16];\n            opaque sha_hash[20];\n        };\n    case dsa:\n        digitally-signed struct {\n            opaque sha_hash[20];\n        };\n} Signature;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "enum { rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4), (255) } ClientCertificateType;",
      "ja": "列挙{rsa_sign（1）、dss_sign（2）、rsa_fixed_dh（3）、dss_fixed_dh（4）、（255）} ClientCertificateType。"
    },
    {
      "indent": 4,
      "text": "opaque DistinguishedName<1..2^16-1>;",
      "ja": "不透明な識別名<1..2 ^ 16-1>;"
    },
    {
      "indent": 4,
      "text": "struct {\n    ClientCertificateType certificate_types<1..2^8-1>;\n    DistinguishedName certificate_authorities<3..2^16-1>;\n} CertificateRequest;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct { } ServerHelloDone;",
      "ja": "構造体{} ServerHelloDone。"
    },
    {
      "indent": 0,
      "text": "A.4.3. Client authentication and key exchange messages",
      "ja": "A.4.3。クライアント認証と鍵交換メッセージ"
    },
    {
      "indent": 4,
      "text": "struct {\n    select (KeyExchangeAlgorithm) {\n        case rsa: EncryptedPreMasterSecret;\n        case diffie_hellman: DiffieHellmanClientPublicValue;\n    } exchange_keys;\n} ClientKeyExchange;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct {\n    ProtocolVersion client_version;\n    opaque random[46];",
      "raw": true
    },
    {
      "indent": 4,
      "text": "} PreMasterSecret;",
      "ja": "}たPreMasterSecret。"
    },
    {
      "indent": 4,
      "text": "struct {\n    public-key-encrypted PreMasterSecret pre_master_secret;\n} EncryptedPreMasterSecret;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "enum { implicit, explicit } PublicValueEncoding;",
      "ja": "列挙{暗黙的、明示}のPublicValueEncoding。"
    },
    {
      "indent": 4,
      "text": "struct {\n    select (PublicValueEncoding) {\n        case implicit: struct {};\n        case explicit: opaque DH_Yc<1..2^16-1>;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "    } dh_public;\n} ClientDiffieHellmanPublic;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct {\n    Signature signature;\n} CertificateVerify;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.4.4. Handshake finalization message",
      "ja": "A.4.4。ハンドシェイクファイナライズメッセージ"
    },
    {
      "indent": 4,
      "text": "struct {\n    opaque verify_data[12];\n} Finished;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.5. The CipherSuite",
      "ja": "A.5。 CipherSuite"
    },
    {
      "indent": 3,
      "text": "The following values define the CipherSuite codes used in the client hello and server hello messages.",
      "ja": "次の値は、クライアントハローとサーバのhelloメッセージに使用されるのCipherSuiteコードを定義します。"
    },
    {
      "indent": 3,
      "text": "A CipherSuite defines a cipher specification supported in TLS Version 1.0.",
      "ja": "CipherSuiteは、TLSバージョン1.0でサポートされる暗号仕様を定義します。"
    },
    {
      "indent": 3,
      "text": "TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a TLS connection during the first handshake on that channel, but must not be negotiated, as it provides no more protection than an unsecured connection.",
      "ja": "TLS_NULL_WITH_NULL_NULLは、指定された、そのチャネル上の最初のハンドシェイクの間のTLS接続の初期状態であり、それはセキュリティで保護されていない接続を超えない保護を提供するように、交渉されてはならないれます。"
    },
    {
      "indent": 4,
      "text": "CipherSuite TLS_NULL_WITH_NULL_NULL = { 0x00,0x00 };",
      "ja": "CipherSuite TLS_NULL_WITH_NULL_NULL = {0x00,0x00}。"
    },
    {
      "indent": 3,
      "text": "The following CipherSuite definitions require that the server provide an RSA certificate that can be used for key exchange. The server may request either an RSA or a DSS signature-capable certificate in the certificate request message.",
      "ja": "以下のCipherSuite定義は、サーバーが鍵交換のために使用することができるRSA証明書を提供する必要があります。サーバは、RSAまたは証明書要求メッセージにおけるDSS署名可能な証明書のいずれかを要求することができます。"
    },
    {
      "indent": 4,
      "text": "CipherSuite TLS_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };\nCipherSuite TLS_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };\nCipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };\nCipherSuite TLS_RSA_WITH_RC4_128_MD5               = { 0x00,0x04 };\nCipherSuite TLS_RSA_WITH_RC4_128_SHA               = { 0x00,0x05 };\nCipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };\nCipherSuite TLS_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07 };\nCipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };\nCipherSuite TLS_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };\nCipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following CipherSuite definitions are used for server-authenticated (and optionally client-authenticated) Diffie-Hellman. DH denotes cipher suites in which the server's certificate contains the Diffie-Hellman parameters signed by the certificate authority (CA). DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman parameters are signed by a DSS or RSA certificate, which has been signed by the CA. The signing algorithm used is specified after the DH or DHE parameter. The server can request an RSA or DSS signature-capable certificate from the client for client authentication or it may request a Diffie-Hellman certificate. Any Diffie-Hellman certificate provided by the client must use the parameters (group and generator) described by the server.",
      "ja": "以下のCipherSuite定義は、サーバ認証（および必要に応じてクライアント認証）のDiffie-Hellmanのために使用されます。 DHは、サーバーの証明書は、認証局（CA）によって署名のDiffie-Hellmanパラメータが含まれている暗号スイートを示しています。 DHEはのDiffie-Hellmanパラメータは、CAによって署名されたDSSまたはRSA証明書によって署名され短命ディフィー - ヘルマンを示し使用署名アルゴリズムは、DHまたはDHEパラメータの後に指定されています。サーバは、クライアント認証のためにクライアントからRSAまたはDSS署名可能な証明書を要求することができるか、のDiffie-Hellman証明書を要求することができます。クライアントによって提供される任意のDiffie-Hellman証明書がサーバによって記述パラメータ（群と発電機）を使用しなければなりません。"
    },
    {
      "indent": 4,
      "text": "CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B };\nCipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };\nCipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };\nCipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };\nCipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };\nCipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };\nCipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };\nCipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };\nCipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };\nCipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };\nCipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };\nCipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following cipher suites are used for completely anonymous Diffie-Hellman communications in which neither party is authenticated. Note that this mode is vulnerable to man-in-the-middle attacks and is therefore deprecated.",
      "ja": "次の暗号スイートは、いずれの当事者が認証されている完全に匿名のDiffie-Hellman通信に使用されています。このモードでは、man-in-the-middle攻撃に対して脆弱であるため、推奨されませんので注意してください。"
    },
    {
      "indent": 4,
      "text": "CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };\nCipherSuite TLS_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };\nCipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };\nCipherSuite TLS_DH_anon_WITH_DES_CBC_SHA           = { 0x00,0x1A };\nCipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1B };",
      "raw": true
    },
    {
      "indent": 1,
      "text": "Note: All cipher suites whose first byte is 0xFF are considered private and can be used for defining local/experimental algorithms. Interoperability of such types is a local matter.",
      "ja": "注：その最初のバイト0xFFであるすべての暗号スイートは、プライベートとみなされ、ローカル/実験的アルゴリズムを定義するために使用することができます。このようなタイプの相互運用性は、ローカルの問題です。"
    },
    {
      "indent": 1,
      "text": "Note: Additional cipher suites can be registered by publishing an RFC which specifies the cipher suites, including the necessary TLS protocol information, including message encoding, premaster secret derivation, symmetric encryption and MAC calculation and appropriate reference information for the algorithms involved. The RFC editor's office may, at its discretion, choose to publish specifications for cipher suites which are not completely described (e.g., for classified algorithms) if it finds the specification to be of technical interest and completely specified.",
      "ja": "注意：追加の暗号スイートは、関与するアルゴリズムのためのメッセージの符号化、前マスター秘密の導出、対称暗号化及びMAC計算と適切な参照情報を含む必要なTLSプロトコル情報を含む暗号スイートを指定するRFCを発行することによって登録することができます。 RFCエディタのオフィスは、その裁量で、それは技術的な関心があると仕様を検出し、完全に指定されていれば（分類されたアルゴリズムのために、例えば）完全に記述されていない暗号スイートの仕様を公開することもできます。"
    },
    {
      "indent": 1,
      "text": "Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are reserved to avoid collision with Fortezza-based cipher suites in SSL 3.",
      "ja": "注：暗号スイート値{0x00で、0x1cに}及び{0x00の、0x1Dの}は、SSL 3にフォルテッツァベースの暗号スイートとの衝突を回避するために予約されています。"
    },
    {
      "indent": 0,
      "text": "A.6. The Security Parameters",
      "ja": "A.6。セキュリティパラメータ"
    },
    {
      "indent": 3,
      "text": "These security parameters are determined by the TLS Handshake Protocol and provided as parameters to the TLS Record Layer in order to initialize a connection state. SecurityParameters includes:",
      "ja": "これらのセキュリティパラメータは、TLSハンドシェイクプロトコルによって決定され、接続状態を初期化するためにTLSレコード層へのパラメータとして提供されています。 SecurityParametersが含まれています："
    },
    {
      "indent": 7,
      "text": "enum { null(0), (255) } CompressionMethod;",
      "ja": "列挙{ヌル（0）、（255）} CompressionMethod。"
    },
    {
      "indent": 7,
      "text": "enum { server, client } ConnectionEnd;",
      "ja": "列挙{サーバー、クライアント} ConnectionEnd。"
    },
    {
      "indent": 7,
      "text": "enum { null, rc4, rc2, des, 3des, des40, idea } BulkCipherAlgorithm;",
      "ja": "列挙{ヌル、RC4、RC2、DES、3DES、DES40アイデアBulkCipherAlgorithm}。"
    },
    {
      "indent": 7,
      "text": "enum { stream, block } CipherType;",
      "ja": "列挙{ストリーム、ブロック} CipherType。"
    },
    {
      "indent": 7,
      "text": "enum { true, false } IsExportable;",
      "ja": "列挙{TRUE、FALSE} IsExportable。"
    },
    {
      "indent": 7,
      "text": "enum { null, md5, sha } MACAlgorithm;",
      "ja": "列挙{ヌル、MD5、SHA} MACAlgorithm。"
    },
    {
      "indent": 3,
      "text": "/* The algorithms specified in CompressionMethod,\nBulkCipherAlgorithm, and MACAlgorithm may be added to. */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "struct {\n    ConnectionEnd entity;\n    BulkCipherAlgorithm bulk_cipher_algorithm;\n    CipherType cipher_type;\n    uint8 key_size;\n    uint8 key_material_length;\n    IsExportable is_exportable;\n    MACAlgorithm mac_algorithm;\n    uint8 hash_size;\n    CompressionMethod compression_algorithm;\n    opaque master_secret[48];\n    opaque client_random[32];\n    opaque server_random[32];\n} SecurityParameters;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "B. Glossary",
      "ja": "B.用語集"
    },
    {
      "indent": 3,
      "text": "application protocol An application protocol is a protocol that normally layers directly on top of the transport layer (e.g., TCP/IP). Examples include HTTP, TELNET, FTP, and SMTP.",
      "ja": "アプリケーションプロトコルアプリケーションプロトコルは、（例えば、TCP / IP）、トランスポート層の上に直接、通常、層のプロトコルです。例としては、HTTP、TELNET、FTP、およびSMTPが含まれます。"
    },
    {
      "indent": 3,
      "text": "asymmetric cipher See public key cryptography.",
      "ja": "非対称暗号は、公開鍵暗号方式を参照してください。"
    },
    {
      "indent": 3,
      "text": "authentication Authentication is the ability of one entity to determine the identity of another entity.",
      "ja": "認証認証とは別のエンティティの同一性を決定する一つのエンティティの能力です。"
    },
    {
      "indent": 3,
      "text": "block cipher A block cipher is an algorithm that operates on plaintext in groups of bits, called blocks. 64 bits is a common block size.",
      "ja": "ブロック暗号暗号ブロックは、ブロックと呼ばれる、ビットのグループに平文で動作するアルゴリズムです。 64ビットは、共通のブロックサイズです。"
    },
    {
      "indent": 3,
      "text": "bulk cipher A symmetric encryption algorithm used to encrypt large quantities of data.",
      "ja": "バルク暗号大量のデータを暗号化するために使用される対称暗号化アルゴリズム。"
    },
    {
      "indent": 3,
      "text": "cipher block chaining (CBC) CBC is a mode in which every plaintext block encrypted with a block cipher is first exclusive-ORed with the previous ciphertext block (or, in the case of the first block, with the initialization vector). For decryption, every block is first decrypted, then exclusive-ORed with the previous ciphertext block (or IV).",
      "ja": "暗号ブロック連鎖（CBC）CBCは、（初期化ベクトルを用いて、または、最初のブロックの場合）ブロック暗号で暗号化されたすべての平文ブロックは、前の暗号文ブロックと第一の排他的論理和するモードです。復号化のために、すべてのブロックが最初に排他的論理和は、前の暗号文ブロック（またはIV）を用いて、復号化されます。"
    },
    {
      "indent": 3,
      "text": "certificate As part of the X.509 protocol (a.k.a. ISO Authentication framework), certificates are assigned by a trusted Certificate Authority and provide a strong binding between a party's identity or some other attributes and its public key.",
      "ja": "X.509プロトコル（別称、ISO認証フレームワーク）の一環として、証明書、証明書は信頼できる認証局によって割り当てられ、党のアイデンティティまたはその他の属性と公開鍵の間に強い結合を提供しています。"
    },
    {
      "indent": 3,
      "text": "client The application entity that initiates a TLS connection to a server. This may or may not imply that the client initiated the underlying transport connection. The primary operational difference between the server and client is that the server is generally authenticated, while the client is only optionally authenticated.",
      "ja": "クライアントサーバーへのTLS接続を開始アプリケーションエンティティ。これは、クライアントが、ベースとなるトランスポート接続を開始したことを意味しない場合があります。サーバとクライアントとの間の主な操作上の違いは、クライアントが唯一のオプションとして認証されている間、サーバーは、一般的に、認証されていることです。"
    },
    {
      "indent": 3,
      "text": "client write key The key used to encrypt data written by the client.",
      "ja": "クライアントは、クライアントによって書き込まれたデータを暗号化するために使用されるキーのキーを書きます。"
    },
    {
      "indent": 3,
      "text": "client write MAC secret The secret data used to authenticate data written by the client.",
      "ja": "クライアントは、MACの秘密クライアントによって書き込まれたデータを認証するために使用される秘密データを書き込みます。"
    },
    {
      "indent": 3,
      "text": "connection A connection is a transport (in the OSI layering model definition) that provides a suitable type of service. For TLS, such connections are peer to peer relationships. The connections are transient. Every connection is associated with one session.",
      "ja": "接続接続は、サービスの適切なタイプを提供する（OSI階層化モデルの定義で）輸送です。 TLSのために、このような接続はピアツーピア関係をされています。接続が一時的なものです。すべての接続は、1つのセッションに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Data Encryption Standard DES is a very widely used symmetric encryption algorithm. DES is a block cipher with a 56 bit key and an 8 byte block size. Note that in TLS, for key generation purposes, DES is treated as having an 8 byte key length (64 bits), but it still only provides 56 bits of protection. (The low bit of each key byte is presumed to be set to produce odd parity in that key byte.) DES can also be operated in a mode where three independent keys and three encryptions are used for each block of data; this uses 168 bits of key (24 bytes in the TLS key generation method) and provides the equivalent of 112 bits of security. [DES], [3DES]",
      "ja": "データ暗号化規格DESは非常に広く使用されている対称暗号化アルゴリズムです。 DESは56ビットキーと8バイトのブロックサイズを有するブロック暗号です。 TLSでなお、鍵生成のために、DESは8バイトの鍵長（64ビット）を有するように処理され、それはまだのみ保護の56ビットを提供します。 （各キーのバイトの下位ビットは、その鍵バイトにおける奇数パリティを生成するように設定されると推定される。）DESはまた、三つの独立したキー三個の暗号化は、データの各ブロックのために使用されるモードで動作させることができます。これは、キーの168ビット（TLS鍵生成方法における24バイト）を使用し、セキュリティの112ビットの同等物を提供します。 [DES]、[3DES]"
    },
    {
      "indent": 3,
      "text": "Digital Signature Standard (DSS) A standard for digital signing, including the Digital Signing Algorithm, approved by the National Institute of Standards and Technology, defined in NIST FIPS PUB 186, \"Digital Signature Standard,\" published May, 1994 by the U.S. Dept. of Commerce. [DSS]",
      "ja": "デジタル署名標準（DSS）NIST FIPSのPUB 186で定義されたアメリカ国立標準技術研究所によって承認されたデジタル署名アルゴリズムを含むデジタル署名、のための標準は、「デジタル署名標準、」米国部門で月、1994年に公開しますコマースの。 [DSS]"
    },
    {
      "indent": 3,
      "text": "digital signatures Digital signatures utilize public key cryptography and one-way hash functions to produce a signature of the data that can be authenticated, and is difficult to forge or repudiate.",
      "ja": "デジタル署名デジタル署名を認証することができるデータの署名を生成するために公開鍵暗号と一方向ハッシュ関数を利用して、偽造又は否認することは困難です。"
    },
    {
      "indent": 3,
      "text": "handshake An initial negotiation between client and server that establishes the parameters of their transactions.",
      "ja": "その取引のパラメータを確立するために、クライアントとサーバ間の最初のネゴシエーションをハンドシェイク。"
    },
    {
      "indent": 3,
      "text": "Initialization Vector (IV) When a block cipher is used in CBC mode, the initialization vector is exclusive-ORed with the first plaintext block prior to encryption.",
      "ja": "ブロック暗号がCBCモードで使用される初期化ベクトル（IV）は、初期化ベクトルは、暗号化の前に最初の平文ブロックとの排他的論理和です。"
    },
    {
      "indent": 3,
      "text": "IDEA A 64-bit block cipher designed by Xuejia Lai and James Massey. [IDEA]",
      "ja": "Xuejia LaiとJames Masseyによって設計IDEA 64ビットブロック暗号。 [アイデア]"
    },
    {
      "indent": 3,
      "text": "Message Authentication Code (MAC) A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.",
      "ja": "メッセージ認証コード（MAC）メッセージ認証コードは、メッセージおよび何らかの秘密データから計算された一方向ハッシュです。秘密データを知らずに偽造することは困難です。その目的は、メッセージが変更されたかどうかを検出することです。"
    },
    {
      "indent": 3,
      "text": "master secret Secure secret data used for generating encryption keys, MAC secrets, and IVs.",
      "ja": "暗号化キー、MACシークレット、IVを生成するために使用される秘密セキュアな秘密データを習得。"
    },
    {
      "indent": 3,
      "text": "MD5 MD5 is a secure hashing function that converts an arbitrarily long data stream into a digest of fixed size (16 bytes). [MD5]",
      "ja": "MD5 MD5は、固定サイズのダイジェスト（16バイト）に任意に長いデータ・ストリームを変換するセキュアハッシュ関数です。 [MD5]"
    },
    {
      "indent": 3,
      "text": "public key cryptography A class of cryptographic techniques employing two-key ciphers. Messages encrypted with the public key can only be decrypted with the associated private key. Conversely, messages signed with the private key can be verified with the public key.",
      "ja": "2個の鍵を使用する暗号技術の公開鍵暗号Aクラス。公開鍵で暗号化されたメッセージにのみ関連する秘密鍵で復号化することができます。逆に、秘密鍵で署名されたメッセージは、公開鍵で検証することができます。"
    },
    {
      "indent": 3,
      "text": "one-way hash function A one-way transformation that converts an arbitrary amount of data into a fixed-length hash. It is computationally hard to reverse the transformation or to find collisions. MD5 and SHA are examples of one-way hash functions.",
      "ja": "一方向ハッシュ関数固定長のハッシュへのデータの任意の量を変換する一方向変換。変換を逆にするか、衝突を発見するのは困難です。 MD5とSHAは、一方向ハッシュ関数の例です。"
    },
    {
      "indent": 3,
      "text": "RC2 A block cipher developed by Ron Rivest at RSA Data Security, Inc. [RSADSI] described in [RC2].",
      "ja": "[RC2]で説明したRSA Data Security社[RSADSI]でロナルド・リベストによって開発されたRC2ブロック暗号。"
    },
    {
      "indent": 3,
      "text": "RC4 A stream cipher licensed by RSA Data Security [RSADSI]. A compatible cipher is described in [RC4].",
      "ja": "RSAデータセキュリティ[RSADSI]によってライセンスRC4ストリーム暗号。互換性のある暗号は[RC4]に記載されています。"
    },
    {
      "indent": 3,
      "text": "RSA A very widely used public-key algorithm that can be used for either encryption or digital signing. [RSA]",
      "ja": "RSA Aは非常に広く、暗号化、デジタル署名のどちらにも使用することができ、公開鍵アルゴリズムを使用していました。 [RSA]"
    },
    {
      "indent": 3,
      "text": "salt Non-secret random data used to make export encryption keys resist precomputation attacks.",
      "ja": "輸出暗号化キーを作成するために使用される塩非秘密のランダムデータは事前​​計算攻撃に抵抗します。"
    },
    {
      "indent": 3,
      "text": "server The server is the application entity that responds to requests for connections from clients. See also under client.",
      "ja": "サーバーサーバーは、クライアントからの接続のための要求に応答するアプリケーションエンティティです。クライアントの下でも参照してください。"
    },
    {
      "indent": 3,
      "text": "session A TLS session is an association between a client and a server. Sessions are created by the handshake protocol. Sessions define a set of cryptographic security parameters, which can be shared among multiple connections. Sessions are used to avoid the expensive negotiation of new security parameters for each connection.",
      "ja": "セッションTLSセッションは、クライアントとサーバの間の関連付けです。セッションはハンドシェイクプロトコルによって作成されます。セッションは、複数の接続の間で共有することができる暗号化セキュリティパラメータのセットを定義します。セッションは、接続ごとに新しいセキュリティパラメータの高価な交渉を回避するために使用されています。"
    },
    {
      "indent": 3,
      "text": "session identifier A session identifier is a value generated by a server that identifies a particular session.",
      "ja": "セッション識別子は、セッション識別子は、特定のセッションを識別するサーバによって生成された値です。"
    },
    {
      "indent": 3,
      "text": "server write key The key used to encrypt data written by the server.",
      "ja": "サーバーは、サーバーによって書き込まれたデータを暗号化するために使用されるキーをキー書きます。"
    },
    {
      "indent": 3,
      "text": "server write MAC secret The secret data used to authenticate data written by the server.",
      "ja": "サーバーは、MACの秘密にサーバーによって書き込まれたデータを認証するために使用される秘密データを書き込みます。"
    },
    {
      "indent": 3,
      "text": "SHA The Secure Hash Algorithm is defined in FIPS PUB 180-1. It produces a 20-byte output. Note that all references to SHA actually use the modified SHA-1 algorithm. [SHA]",
      "ja": "SHAセキュアハッシュアルゴリズムは、FIPS PUB 180-1の中で定義されています。これは、20バイトの出力を生成します。 SHAへのすべての参照が実際に変更SHA-1アルゴリズムを使用することに注意してください。 [SHA]"
    },
    {
      "indent": 3,
      "text": "SSL Netscape's Secure Socket Layer protocol [SSL3]. TLS is based on SSL Version 3.0",
      "ja": "SSL Netscapeのセキュアソケットレイヤプロトコル[SSL3]。 TLSは、SSLバージョン3.0に基づいています"
    },
    {
      "indent": 3,
      "text": "stream cipher An encryption algorithm that converts a key into a cryptographically-strong keystream, which is then exclusive-ORed with the plaintext.",
      "ja": "その後、平文との排他的論理和である、暗号-強いキーストリーム、にキーを変換する暗号化アルゴリズムの暗号ストリーム。"
    },
    {
      "indent": 3,
      "text": "symmetric cipher See bulk cipher.",
      "ja": "対称暗号は、バルク暗号を参照してください。"
    },
    {
      "indent": 3,
      "text": "Transport Layer Security (TLS) This protocol; also, the Transport Layer Security working group of the Internet Engineering Task Force (IETF). See \"Comments\" at the end of this document.",
      "ja": "トランスポート層セキュリティ（TLS）このプロトコル。インターネットエンジニアリングタスクフォース（IETF）のも、トランスポート・レイヤ・セキュリティワーキンググループ。このドキュメントの最後に「コメント」を参照してください。"
    },
    {
      "indent": 0,
      "text": "C. CipherSuite definitions",
      "ja": "C.のCipherSuite定義"
    },
    {
      "indent": 0,
      "text": "CipherSuite Is Key Cipher Hash Exportable Exchange",
      "ja": "CipherSuiteは鍵暗号ハッシュエクスポート可能な交換であります"
    },
    {
      "indent": 0,
      "text": "TLS_NULL_WITH_NULL_NULL * NULL NULL NULL TLS_RSA_WITH_NULL_MD5 * RSA NULL MD5 TLS_RSA_WITH_NULL_SHA * RSA NULL SHA TLS_RSA_EXPORT_WITH_RC4_40_MD5 * RSA_EXPORT RC4_40 MD5 TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 * RSA_EXPORT RC2_CBC_40 MD5 TLS_RSA_WITH_IDEA_CBC_SHA RSA IDEA_CBC SHA TLS_RSA_EXPORT_WITH_DES40_CBC_SHA * RSA_EXPORT DES40_CBC SHA TLS_RSA_WITH_DES_CBC_SHA RSA DES_CBC SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA * DH_DSS_EXPORT DES40_CBC SHA TLS_DH_DSS_WITH_DES_CBC_SHA DH_DSS DES_CBC SHA TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHA TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA * DH_RSA_EXPORT DES40_CBC SHA TLS_DH_RSA_WITH_DES_CBC_SHA DH_RSA DES_CBC SHA TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC SHA TLS_DHE_DSS_WITH_DES_CBC_SHA DHE_DSS DES_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC SHA TLS_DHE_RSA_WITH_DES_CBC_SHA DHE_RSA DES_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 * DH_anon_EXPORT RC4_40 MD5 TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA DH_anon DES40_CBC SHA TLS_DH_anon_WITH_DES_CBC_SHA DH_anon DES_CBC SHA TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC SHA",
      "ja": "TLS_NULL_WITH_NULL_NULL * NULL NULL NULL TLS_RSA_WITH_NULL_MD5 * RSA NULL MD5 TLS_RSA_WITH_NULL_SHA * RSA NULL SHA TLS_RSA_EXPORT_WITH_RC4_40_MD5 * RSA_EXPORT RC4_40 MD5 TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 * RSA_EXPORT RC2_CBC_40 MD5 TLS_RSA_WITH_IDEA_CBC_SHA RSA IDEA_CBC SHA TLS_RSA_EXPORT_WITH_DES40_CBC_SHA * RSA_EXPORT DES40_CBC SHA TLS_RSA_WITH_DES_CBC_SHA RSA DES_CBC SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA * DH_DSS_EXPORT DES40_CBC SHA TLS_DH_DSS_WITH_DES_CBC_SHA DH_DSS DES_CBC SHA TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHA TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA * DH_RSA_EXPORT DES40_CBC SHA TLS_DH_RSA_WITH_DES_CBC_SHA DH_RSA DES_CBC SHA TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC SHA TLS_DHE_DSS_WITH_DES_CBC_SHA DHE_DSS DES_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC _SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC SHA TLS_DHE_RSA_WITH_DES_CBC_SHA DHE_RSA DES_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 * DH_anon_EXPORT RC4_40 MD5 TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA DH_anon DES40_CBC SHA TLS_DH_anon_WITH_DES_CBC_SHA DH_anon DES_CBC SHA TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC SHA"
    },
    {
      "indent": 3,
      "text": "* Indicates IsExportable is True",
      "ja": "* IsExportableがTrueであることを示します"
    },
    {
      "indent": 6,
      "text": "Key Exchange Algorithm Description Key size limit",
      "ja": "鍵交換アルゴリズムの説明キーサイズ制限"
    },
    {
      "indent": 6,
      "text": "DHE_DSS Ephemeral DH with DSS signatures None DHE_DSS_EXPORT Ephemeral DH with DSS signatures DH = 512 bits DHE_RSA Ephemeral DH with RSA signatures None DHE_RSA_EXPORT Ephemeral DH with RSA signatures DH = 512 bits, RSA = none DH_anon Anonymous DH, no signatures None DH_anon_EXPORT Anonymous DH, no signatures DH = 512 bits",
      "ja": "= 512ビットRSA署名のDHを持つ= 512ビットRSA署名なしDHE_RSA_EXPORTエフェメラルDHとDHE_RSAエフェメラルDH DSS署名のDHとDSS署名なしDHE_DSS_EXPORTエフェメラルDHとDHE_DSSエフェメラルDH、RSA =なしDH_anon匿名DH、無署名なしDH_anon_EXPORT匿名DH、なし署名DH = 512ビット"
    },
    {
      "indent": 6,
      "text": "DH_DSS DH with DSS-based certificates None DH_DSS_EXPORT DH with DSS-based certificates DH = 512 bits DH_RSA DH with RSA-based certificates None DH_RSA_EXPORT DH with RSA-based certificates DH = 512 bits, RSA = none NULL No key exchange N/A RSA RSA key exchange None RSA_EXPORT RSA key exchange RSA = 512 bits",
      "ja": "DSSベースの証明書なしDH_DSS_EXPORT DHとDH_DSS DH RSAベースの証明書とのDHが= 512ビットDH_RSA DHを= 512ビットRSAベースの証明書のDHとなしDH_RSA_EXPORT DH、NULL RSA =なしなし鍵交換N / A RSA DSSベースの証明書とRSA鍵交換なしRSA_EXPORT RSA鍵交換RSA = 512ビット"
    },
    {
      "indent": 3,
      "text": "Key size limit The key size limit gives the size of the largest public key that can be legally used for encryption in cipher suites that are exportable.",
      "ja": "キーサイズ制限はキーのサイズ制限は、法的にエクスポートされている暗号スイートに暗号化のために使用することができる最大の公開鍵のサイズを与えます。"
    },
    {
      "indent": 4,
      "text": " Key Expanded Effective IV Block Cipher Type Material Key Material Key Bits Size Size",
      "ja": "主な拡張有効IVブロック暗号タイプ材質主材質キー・ビットサイズサイズ"
    },
    {
      "indent": 4,
      "text": "NULL * Stream 0 0 0 0 N/A IDEA_CBC Block 16 16 128 8 8 RC2_CBC_40 * Block 5 16 40 8 8 RC4_40 * Stream 5 16 40 0 N/A RC4_128 Stream 16 16 128 0 N/A DES40_CBC * Block 5 8 40 8 8 DES_CBC Block 8 8 56 8 8 3DES_EDE_CBC Block 24 24 168 8 8",
      "ja": "NULL *ストリーム0 0 0 0 N / IDEA_CBCブロック16 16 128 8 8 RC2_CBC_40 *ブロック5 16 40 8 8 RC4_40 *ストリーム5 16 40 0 N / A RC4_128ストリーム16 16 128 0 N / DES40_CBC *ブロック5 8 40 8 8 DES_CBCブロック8 8 56 8 8 3DES_EDE_CBCブロック24 24 168 8 8"
    },
    {
      "indent": 3,
      "text": "* Indicates IsExportable is true.",
      "ja": "* IsExportableが真であることを示します。"
    },
    {
      "indent": 3,
      "text": "Type Indicates whether this is a stream cipher or a block cipher running in CBC mode.",
      "ja": "タイプは、これはストリーム暗号やCBCモードで実行されているブロック暗号であるかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "Key Material The number of bytes from the key_block that are used for generating the write keys.",
      "ja": "暗号化キーの書き込みキーを生成するために使用されているなkey_blockからのバイト数。"
    },
    {
      "indent": 3,
      "text": "Expanded Key Material The number of bytes actually fed into the encryption algorithm",
      "ja": "暗号化キーの拡張バイトの数は、実際には、暗号化アルゴリズムに供給します"
    },
    {
      "indent": 3,
      "text": "Effective Key Bits How much entropy material is in the key material being fed into the encryption routines.",
      "ja": "エントロピー材料は暗号化ルーチンに供給されるキーマテリアルであるどのくらいのビットの有効鍵。"
    },
    {
      "indent": 3,
      "text": "IV Size How much data needs to be generated for the initialization vector. Zero for stream ciphers; equal to the block size for block ciphers.",
      "ja": "どのくらいのデータIVサイズは、初期化ベクトルを生成する必要があります。ストリーム暗号のためのゼロ。ブロック暗号のブロックサイズに等しいです。"
    },
    {
      "indent": 3,
      "text": "Block Size The amount of data a block cipher enciphers in one chunk; a block cipher running in CBC mode can only encrypt an even multiple of its block size.",
      "ja": "ブロックサイズデータの量が1つのチャンク内のブロック暗号暗号化し、 CBCモードで実行されているブロック暗号はそのブロックサイズの倍数を暗号化することができます。"
    },
    {
      "indent": 4,
      "text": " Hash Hash Padding function Size Size NULL 0 0 MD5 16 48 SHA 20 40",
      "ja": "ハッシュハッシュ関数パディングサイズサイズNULL 0 MD5 16 48 20 40 SHA"
    },
    {
      "indent": 0,
      "text": "D. Implementation Notes",
      "ja": "D.実装ノート"
    },
    {
      "indent": 3,
      "text": "The TLS protocol cannot prevent many common security mistakes. This section provides several recommendations to assist implementors.",
      "ja": "TLSプロトコルは、多くの一般的なセキュリティ上のミスを防ぐことはできません。このセクションでは、実装を支援するために、いくつかの提言を提供します。"
    },
    {
      "indent": 0,
      "text": "D.1. Temporary RSA keys",
      "ja": "D.1。一時的RSA鍵"
    },
    {
      "indent": 3,
      "text": "US Export restrictions limit RSA keys used for encryption to 512 bits, but do not place any limit on lengths of RSA keys used for signing operations. Certificates often need to be larger than 512 bits, since 512-bit RSA keys are not secure enough for high-value transactions or for applications requiring long-term security. Some certificates are also designated signing-only, in which case they cannot be used for key exchange.",
      "ja": "米国の輸出規制は、512ビットに暗号化に使用されるRSA鍵を制限しますが、署名の操作に使用されるRSA鍵の長さは上の任意の制限を置かないでください。 512ビットのRSA鍵は、高価値のトランザクションまたは長期的なセキュリティを必要とするアプリケーションのために十分に確保されないので、証明書は、多くの場合、512ビットよりも大きくする必要があります。いくつかの証明書はまた、彼らは鍵交換に使用することはできません、その場合には、署名のみ指定されています。"
    },
    {
      "indent": 3,
      "text": "When the public key in the certificate cannot be used for encryption, the server signs a temporary RSA key, which is then exchanged. In exportable applications, the temporary RSA key should be the maximum allowable length (i.e., 512 bits). Because 512-bit RSA keys are relatively insecure, they should be changed often. For typical electronic commerce applications, it is suggested that keys be changed daily or every 500 transactions, and more often if possible. Note that while it is acceptable to use the same temporary key for multiple transactions, it must be signed each time it is used.",
      "ja": "証明書の公開鍵は、暗号化に使用することができない場合は、サーバーは、交換され、一時的RSA鍵を、署名します。エクスポート用途において、一時的RSA鍵は、最大許容長（すなわち、512ビット）であるべきです。 512ビットのRSA鍵は比較的安全ではないので、彼らはしばしば変更する必要があります。典型的な電子商取引アプリケーションでは、可能な場合は、キーをより頻繁に、毎日変更またはすべての500件の取引、およびすることが示唆されます。それは複数のトランザクションのために同じ一時的鍵を使用することが許容されている間、それが使用されるたびに署名しなければならないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "RSA key generation is a time-consuming process. In many cases, a low-priority process can be assigned the task of key generation.",
      "ja": "RSAキーの生成は時間のかかるプロセスです。多くの場合、優先度の低いプロセスは、鍵生成のタスクを割り当てることができます。"
    },
    {
      "indent": 3,
      "text": "Whenever a new key is completed, the existing temporary key can be replaced with the new one.",
      "ja": "新しいキーが完了するたびに、既存の一時鍵は新しいものと交換することができます。"
    },
    {
      "indent": 0,
      "text": "D.2. Random Number Generation and Seeding",
      "ja": "D.2。乱数生成と播種"
    },
    {
      "indent": 3,
      "text": "TLS requires a cryptographically-secure pseudorandom number generator (PRNG). Care must be taken in designing and seeding PRNGs. PRNGs based on secure hash operations, most notably MD5 and/or SHA, are acceptable, but cannot provide more security than the size of the random number generator state. (For example, MD5-based PRNGs usually provide 128 bits of state.)",
      "ja": "TLSは、暗号的に安全な擬似乱数生成器（PRNG）が必要です。ケアのPRNGの設計と播種に注意する必要があります。セキュアハッシュ操作に基づいのPRNG、最も顕著にはMD5および/またはSHAは、許容可能であるが、乱数発生器の状態のサイズよりも多くのセキュリティを提供することができません。 （例えば、MD5ベースのPRNGは、通常状態の128ビットを提供します。）"
    },
    {
      "indent": 3,
      "text": "To estimate the amount of seed material being produced, add the number of bits of unpredictable information in each seed byte. For example, keystroke timing values taken from a PC compatible's 18.2 Hz timer provide 1 or 2 secure bits each, even though the total size of the counter value is 16 bits or more. To seed a 128-bit PRNG, one would thus require approximately 100 such timer values.",
      "ja": "生産されたシード材料の量を推定するために、各シードバイトの予測不可能な情報のビット数を追加します。例えば、のPC互換18.2 Hzのタイマーから採取したキーストロークタイミング値は、カウンタ値の合計サイズが16ビット以上であっても、1つの又は2の安全なビットそれぞれを提供します。 128ビットのPRNGをシードするためには、このようにして、約100そのようなタイマ値を必要とするであろう。"
    },
    {
      "indent": 1,
      "text": "Warning: The seeding functions in RSAREF and versions of BSAFE prior to 3.0 are order-independent. For example, if 1000 seed bits are supplied, one at a time, in 1000 separate calls to the seed function, the PRNG will end up in a state which depends only on the number of 0 or 1 seed bits in the seed data (i.e., there are 1001 possible final states). Applications using BSAFE or RSAREF must take extra care to ensure proper seeding. This may be accomplished by accumulating seed bits into a buffer and processing them all at once or by processing an incrementing counter with every seed bit; either method will reintroduce order dependence into the seeding process.",
      "ja": "警告：3.0より前に播種RSAREFの関数とBSAFEのバージョンは、順序非依存です。 1000個のシードビットが供給される場合、例えば、一度に1つずつは、シード関数1000回の別々の呼び出しで、PRNGは、シード・データに0又は1種ビットの数（すなわち、に依存する状態になってしまいます、1001の可能な最終状態）があります。 BSAFEまたはRSAREFを使用するアプリケーションは、適切な播種を保証するために、余分な世話をする必要があります。これは、バッファにシードビットを蓄積し、一度にまたはすべてのシードビットとインクリメントカウンタを処理することによってそれらをすべて処理することによって達成することができます。どちらの方法は、シーディングプロセスに順序依存性を再導入します。"
    },
    {
      "indent": 0,
      "text": "D.3. Certificates and authentication",
      "ja": "D.3。証明書と認証"
    },
    {
      "indent": 3,
      "text": "Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Certificates should always be verified to ensure proper signing by a trusted Certificate Authority (CA). The selection and addition of trusted CAs should be done very carefully. Users should be able to view information about the certificate and root CA.",
      "ja": "実装は、証明書の有効性について検証する責任があり、一般的に証明書失効メッセージをサポートする必要があります。証明書は常に信頼できる認証局（CA）によって適切な署名を確認するために検証する必要があります。信頼できるCAの選択や追加は非常に慎重に行われるべきです。ユーザーは、証明書とルートCAの情報を閲覧することができるはずです"
    },
    {
      "indent": 0,
      "text": "D.4. CipherSuites",
      "ja": "D.4。 CipherSuites"
    },
    {
      "indent": 3,
      "text": "TLS supports a range of key sizes and security levels, including some which provide no or minimal security. A proper implementation will probably not support many cipher suites. For example, 40-bit encryption is easily broken, so implementations requiring strong security should not allow 40-bit keys. Similarly, anonymous Diffie-Hellman is strongly discouraged because it cannot prevent man-in-the-middle attacks. Applications should also enforce minimum and maximum key sizes. For example, certificate chains containing 512-bit RSA keys or signatures are not appropriate for high-security applications.",
      "ja": "TLSはないか、最小限のセキュリティを提供するいくつかを含むキーのサイズとセキュリティレベルの範囲を、サポートしています。適切な実装は、おそらく多くの暗号スイートをサポートしていません。強力なセキュリティを必要とする実装が40ビットのキーを許可してはならないので、例えば、40ビットの暗号化を容易に破壊されます。それはman-in-the-middle攻撃を防ぐことができないので、同様に、匿名のDiffie-Hellmanは強くお勧めします。また、アプリケーションは、最小と最大のキーサイズを強制する必要があります。例えば、512ビットのRSAキーまたは署名を含む証明書チェーンは、高セキュリティアプリケーションに適していません。"
    },
    {
      "indent": 0,
      "text": "E. Backward Compatibility With SSL",
      "ja": "SSLでE.下位互換性"
    },
    {
      "indent": 3,
      "text": "For historical reasons and in order to avoid a profligate consumption of reserved port numbers, application protocols which are secured by TLS 1.0, SSL 3.0, and SSL 2.0 all frequently share the same connection port: for example, the https protocol (HTTP secured by SSL or TLS) uses port 443 regardless of which security protocol it is using. Thus, some mechanism must be determined to distinguish and negotiate among the various protocols.",
      "ja": "歴史的な理由と予約済みポート番号の浪費消費を回避するために、TLS 1.0、SSL 3.0、およびSSL 2.0によって固定されているアプリケーションプロトコルは、全ての頻繁に同一の接続ポートを共有する：SSLで固定例えば、HTTPSプロトコル（HTTPまたはTLS）は関係なく、それが使用されているセキュリティプロトコルのポート443を使用しています。したがって、いくつかのメカニズムが識別及び様々なプロトコルの間で交渉するために決定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "TLS version 1.0 and SSL 3.0 are very similar; thus, supporting both is easy. TLS clients who wish to negotiate with SSL 3.0 servers should send client hello messages using the SSL 3.0 record format and client hello structure, sending {3, 1} for the version field to note that they support TLS 1.0. If the server supports only SSL 3.0, it will respond with an SSL 3.0 server hello; if it supports TLS, with a TLS server hello. The negotiation then proceeds as appropriate for the negotiated protocol.",
      "ja": "TLSバージョン1.0とSSL 3.0は非常に似ています。このように、両方をサポートするのは簡単です。 SSLと3.0のサーバーを交渉したいTLSクライアントは、TLS 1.0をサポートすることに注意するバージョンフィールドのために、{3,1}を送信し、ハローSSL 3.0レコード形式とクライアントを使用してハロー構造を、メッセージをクライアントに送信する必要があります。サーバーのみSSL 3.0をサポートしている場合、それはハローSSL 3.0サーバーで応答します。それはTLSサーバーで、TLSをサポートしている場合こんにちは。ネゴシエーションは、その後ネゴシエートプロトコルに応じて進みます。"
    },
    {
      "indent": 3,
      "text": "Similarly, a TLS server which wishes to interoperate with SSL 3.0 clients should accept SSL 3.0 client hello messages and respond with an SSL 3.0 server hello if an SSL 3.0 client hello is received which has a version field of {3, 0}, denoting that this client does not support TLS.",
      "ja": "同様に、SSL 3.0クライアントと相互運用することを望むTLSサーバは、SSL 3.0クライアントハローメッセージを受け入れ、SSL 3.0クライアントハローがいることを示す、{3,0}のバージョンフィールドを有する受信された場合にハローSSL 3.0サーバーで応答しなければなりませんこのクライアントはTLSをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "Whenever a client already knows the highest protocol known to a server (for example, when resuming a session), it should initiate the connection in that native protocol.",
      "ja": "（セッションを再開する際に、例えば）クライアントがすでにサーバーに知られている最上位のプロトコルを知っているときはいつでも、それは、そのネイティブプロトコルで接続を開始する必要があります。"
    },
    {
      "indent": 3,
      "text": "TLS 1.0 clients that support SSL Version 2.0 servers must send SSL Version 2.0 client hello messages [SSL2]. TLS servers should accept either client hello format if they wish to support SSL 2.0 clients on the same connection port. The only deviations from the Version 2.0 specification are the ability to specify a version with a value of three and the support for more ciphering types in the CipherSpec.",
      "ja": "SSLバージョン2.0のサーバをサポートしてTLS 1.0のクライアントは、SSLバージョン2.0クライアントhelloメッセージ[SSL2]を送信する必要があります。彼らは同じ接続ポートでSSL 2.0のクライアントをサポートしたい場合は、TLSサーバは、クライアントのhello形式のいずれかを受け入れる必要があります。バージョン2.0の仕様から唯一の偏差が3の値とのCipherSpecでより多くの暗号化の種類をサポートしたバージョンを指定する機能です。"
    },
    {
      "indent": 1,
      "text": "Warning: The ability to send Version 2.0 client hello messages will be phased out with all due haste. Implementors should make every effort to move forward as quickly as possible. Version 3.0 provides better mechanisms for moving to newer versions.",
      "ja": "警告：バージョン2.0クライアントのhelloメッセージを送信する機能は、すべての原因急いで段階的に廃止されます。実装者は、可能な限り迅速に前進するためにあらゆる努力をするべきです。バージョン3.0は、新しいバージョンへの移行のためのより良いメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "The following cipher specifications are carryovers from SSL Version 2.0. These are assumed to use RSA for key exchange and authentication.",
      "ja": "以下の暗号仕様は、SSLバージョン2.0から引き継がれたものです。これらは、鍵交換と認証にRSAを使用することを想定しています。"
    },
    {
      "indent": 7,
      "text": "V2CipherSpec TLS_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };\nV2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };\nV2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };",
      "raw": true
    },
    {
      "indent": 7,
      "text": "V2CipherSpec TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5\n                                           = { 0x04,0x00,0x80 };\nV2CipherSpec TLS_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };\nV2CipherSpec TLS_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };\nV2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Cipher specifications native to TLS can be included in Version 2.0 client hello messages using the syntax below. Any V2CipherSpec element with its first byte equal to zero will be ignored by Version 2.0 servers. Clients sending any of the above V2CipherSpecs should also include the TLS equivalent (see Appendix A.5):",
      "ja": "TLSへのネイティブ暗号仕様は、以下の構文を使用して、バージョン2.0クライアントのhelloメッセージに含めることができます。ゼロに等しいその最初のバイトを持つ任意のV2CipherSpec要素は、バージョン2.0のサーバーによって無視されます。上記V2CipherSpecsのいずれかを送信するクライアントはまた、（付録A.5を参照）TLSと同等のものを含める必要があります。"
    },
    {
      "indent": 7,
      "text": "V2CipherSpec (see TLS name) = { 0x00, CipherSuite };",
      "ja": "V2CipherSpec（TLS名を参照）= {0x00で、のCipherSuite}。"
    },
    {
      "indent": 0,
      "text": "E.1. Version 2 client hello",
      "ja": "E.1。バージョン2クライアントのhello"
    },
    {
      "indent": 3,
      "text": "The Version 2.0 client hello message is presented below using this document's presentation model. The true definition is still assumed to be the SSL Version 2.0 specification.",
      "ja": "バージョン2.0クライアントのhelloメッセージは、このドキュメントのプレゼンテーションモデルを用いて以下に提示されます。真の定義は、まだSSLバージョン2.0の仕様を想定しています。"
    },
    {
      "indent": 7,
      "text": "uint8 V2CipherSpec[3];",
      "ja": "UINT8 V2CipherSpec [3]。"
    },
    {
      "indent": 7,
      "text": "struct {\n    uint8 msg_type;\n    Version version;\n    uint16 cipher_spec_length;\n    uint16 session_id_length;\n    uint16 challenge_length;\n    V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];\n    opaque session_id[V2ClientHello.session_id_length];\n    Random challenge;\n} V2ClientHello;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "msg_type This field, in conjunction with the version field, identifies a version 2 client hello message. The value should be one (1).",
      "ja": "このフィールドをMSG_TYPE、バージョンフィールドと連動して、バージョン2クライアントのhelloメッセージを識別する。値は1（1）であるべきです。"
    },
    {
      "indent": 3,
      "text": "version The highest version of the protocol supported by the client (equals ProtocolVersion.version, see Appendix A.1).",
      "ja": "バージョンのクライアントでサポートされているプロトコルの最も高いバージョンは（これはProtocolVersion.versionに等しい。付録A.1を参照してください）。"
    },
    {
      "indent": 3,
      "text": "cipher_spec_length This field is the total length of the field cipher_specs. It cannot be zero and must be a multiple of the V2CipherSpec length (3).",
      "ja": "cipher_spec長さこのフィールドは、フィールドcipher_specsの長さの合計です。それはゼロにすることはできず、V2暗号スペック長さ（3）の倍数でなければなりません。"
    },
    {
      "indent": 3,
      "text": "session_id_length This field must have a value of either zero or 16. If zero, the client is creating a new session. If 16, the session_id field will contain the 16 bytes of session identification.",
      "ja": "session_id_lengthこのフィールドはゼロまたは16のいずれかがゼロの場合、クライアントは新しいセッションを作成しているの価値を持っている必要があります。 16場合は、SESSION_IDフィールドは、セッション識別の16のバイトが含まれています。"
    },
    {
      "indent": 3,
      "text": "challenge_length The length in bytes of the client's challenge to the server to authenticate itself. This value must be 32.",
      "ja": "自身を認証するために、サーバーへのクライアントの挑戦の長さをバイト単位でchallenge_length。この値は32でなければなりません。"
    },
    {
      "indent": 3,
      "text": "cipher_specs This is a list of all CipherSpecs the client is willing and able to use. There must be at least one CipherSpec acceptable to the server.",
      "ja": "cipher_specsこれは、クライアントが喜んでと使用することができ、すべてのCipherSpecのリストです。サーバーへの許容可能な少なくとも一つのCipherSpecがなければなりません。"
    },
    {
      "indent": 3,
      "text": "session_id If this field's length is not zero, it will contain the identification for a session that the client wishes to resume.",
      "ja": "このフィールドの長さがゼロでない場合はSESSION_ID、それは、クライアントが再開したいセッションの識別が含まれています。"
    },
    {
      "indent": 3,
      "text": "challenge The client challenge to the server for the server to identify itself is a (nearly) arbitrary length random. The TLS server will right justify the challenge data to become the ClientHello.random data (padded with leading zeroes, if necessary), as specified in this protocol specification. If the length of the challenge is greater than 32 bytes, only the last 32 bytes are used. It is legitimate (but not necessary) for a V3 server to reject a V2 ClientHello that has fewer than 16 bytes of challenge data.",
      "ja": "自身を識別するためのサーバのサーバへのクライアントの課題に挑戦することは（ほとんど）任意の長さのランダムです。 TLSサーバは、右のこのプロトコル仕様で指定され、（必要に応じて、先行ゼロで埋め）のClientHello.randomデータになるためにチャレンジデータを正当化します。チャレンジの長さが32のバイトよりも大きい場合、最後の32のバイトが使用されます。 V3サーバーは、チャレンジデータの16のバイトよりも少ないを持っているV2のClientHelloを拒絶することが（必要ではない）正当なものです。"
    },
    {
      "indent": 1,
      "text": "Note: Requests to resume a TLS session should use a TLS client hello.",
      "ja": "注：TLSセッションを再開する要求はTLSクライアントのhelloを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "E.2. Avoiding man-in-the-middle version rollback",
      "ja": "E.2。回避のman-in-the-middleバージョンのロールバック"
    },
    {
      "indent": 3,
      "text": "When TLS clients fall back to Version 2.0 compatibility mode, they should use special PKCS #1 block formatting. This is done so that TLS servers will reject Version 2.0 sessions with TLS-capable clients.",
      "ja": "TLSクライアントがバックバージョン2.0互換モードにフォールすると、彼らは特別なPKCS＃1ブロックフォーマットを使用する必要があります。 TLSサーバがTLS対応のクライアントとのバージョン2.0セッションを拒絶するように行われます。"
    },
    {
      "indent": 3,
      "text": "When TLS clients are in Version 2.0 compatibility mode, they set the right-hand (least-significant) 8 random bytes of the PKCS padding (not including the terminal null of the padding) for the RSA encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY to 0x03 (the other padding bytes are random). After decrypting the ENCRYPTED-KEY-DATA field, servers that support TLS should issue an error if these eight padding bytes are 0x03. Version 2.0 servers receiving blocks padded in this manner will proceed normally.",
      "ja": "TLSクライアントがバージョン2.0互換モードである場合、それらは暗号化-KEY-DATAフィールドのRSA暗号化のため（パディングの端子ヌルを含まない）PKCSパディングの（最下位）8ランダムバイト右側を設定しました0×03にCLIENT-MASTER-KEYの（他のパディングバイトがランダムです）。これら8つのパディングバイトが0x03であればENCRYPTED-KEY-DATAフィールドを復号化した後、TLSをサポートするサーバーはエラーを発行する必要があります。このように埋められたブロックを受けるバージョン2.0のサーバーが正常に進行します。"
    },
    {
      "indent": 0,
      "text": "F. Security analysis",
      "ja": "F.セキュリティ解析"
    },
    {
      "indent": 3,
      "text": "The TLS protocol is designed to establish a secure connection between a client and a server communicating over an insecure channel. This document makes several traditional assumptions, including that attackers have substantial computational resources and cannot obtain secret information from sources outside the protocol. Attackers are assumed to have the ability to capture, modify, delete, replay, and otherwise tamper with messages sent over the communication channel. This appendix outlines how TLS has been designed to resist a variety of attacks.",
      "ja": "TLSプロトコルは、クライアントと安全でないチャネルを介して通信サーバ間の安全な接続を確立するために設計されています。この文書では、攻撃者が実質的な計算リソースを持っており、プロトコル外部ソースから秘密情報を得ることができないことを含め、いくつかの伝統的な仮定を行います。攻撃者は、キャプチャ、変更、削除、再生、およびそれ以外の通信チャネルを介して送信されたメッセージを改ざんする能力を持っていると想定されています。この付録では、TLSがさまざまな攻撃に耐えるように設計されている方法について説明します。"
    },
    {
      "indent": 0,
      "text": "F.1. Handshake protocol",
      "ja": "F.1。ハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "The handshake protocol is responsible for selecting a CipherSpec and generating a Master Secret, which together comprise the primary cryptographic parameters associated with a secure session. The handshake protocol can also optionally authenticate parties who have certificates signed by a trusted certificate authority.",
      "ja": "ハンドシェイクプロトコルは、のCipherSpecを選択し、一緒に安全なセッションに関連付けられたプライマリ暗号パラメータを含むマスターシークレットを生成する責任があります。ハンドシェイクプロトコルはまた、必要に応じて、信頼できる認証局によって署名された証明書を持って、当事者を認証することができます。"
    },
    {
      "indent": 0,
      "text": "F.1.1. Authentication and key exchange",
      "ja": "F.1.1。認証と鍵交換"
    },
    {
      "indent": 3,
      "text": "TLS supports three authentication modes: authentication of both parties, server authentication with an unauthenticated client, and total anonymity. Whenever the server is authenticated, the channel is secure against man-in-the-middle attacks, but completely anonymous sessions are inherently vulnerable to such attacks. Anonymous servers cannot authenticate clients. If the server is authenticated, its certificate message must provide a valid certificate chain leading to an acceptable certificate authority. Similarly, authenticated clients must supply an acceptable certificate to the server. Each party is responsible for verifying that the other's certificate is valid and has not expired or been revoked.",
      "ja": "両当事者の認証、認証されていないクライアントとサーバー認証、および総匿名：TLSは、3つの認証モードをサポートしています。サーバーが認証されるたびに、チャネルは、man-in-the-middle攻撃に対して安全であるが、完全に匿名のセッションはそのような攻撃にさらされやすいです。匿名のサーバはクライアントを認証することはできません。サーバーが認証されている場合は、その証明書のメッセージは許容できる認証局につながる有効な証明書チェーンを提供する必要があります。同様に、認証されたクライアントは、サーバーへの許容可能な証明書を提供する必要があります。各当事者は、他の証明書が有効で、期限が切れていないか、取り消されていることを検証する責任があります。"
    },
    {
      "indent": 3,
      "text": "The general goal of the key exchange process is to create a pre_master_secret known to the communicating parties and not to attackers. The pre_master_secret will be used to generate the master_secret (see Section 8.1). The master_secret is required to generate the certificate verify and finished messages, encryption keys, and MAC secrets (see Sections 7.4.8, 7.4.9 and 6.3). By sending a correct finished message, parties thus prove that they know the correct pre_master_secret.",
      "ja": "鍵交換プロセスの一般的な目標は、通信相手にしていない攻撃者に知られている前_のマスター_秘密を作成することです。前_のマスター_秘密をmaster_secretを生成するのに使用されます（8.1節を参照してください）。でマスター_は、証明書を確認し、完成したメッセージ、暗号化キー、およびMAC秘密を（セクション7.4.8、7.4.9および6.3を参照）を生成するために必要とされます。正しいFinishedメッセージを送信することにより、関係者は、このように、彼らは正しい前_のマスター_秘密を知っていることを証明します。"
    },
    {
      "indent": 0,
      "text": "F.1.1.1. Anonymous key exchange",
      "ja": "F.1.1.1。匿名の鍵交換"
    },
    {
      "indent": 3,
      "text": "Completely anonymous sessions can be established using RSA or Diffie-Hellman for key exchange. With anonymous RSA, the client encrypts a pre_master_secret with the server's uncertified public key extracted from the server key exchange message. The result is sent in a client key exchange message. Since eavesdroppers do not know the server's private key, it will be infeasible for them to decode the pre_master_secret. (Note that no anonymous RSA Cipher Suites are defined in this document).",
      "ja": "完全に匿名のセッションは、鍵交換のためのRSAまたはディフィー・ヘルマンを使用して確立することができます。匿名RSAでは、クライアントは、サーバ鍵交換メッセージから抽出されたサーバーの未認定公開鍵で前_のマスター_秘密を暗号化します。結果は、クライアント鍵交換メッセージで送信されます。盗聴者は、サーバの秘密鍵を知らないので、彼らはpre_master_secretを復号することは実行不可能になります。 （匿名のRSA暗号スイートは、この文書で定義されていないことに注意してください）。"
    },
    {
      "indent": 3,
      "text": "With Diffie-Hellman, the server's public parameters are contained in the server key exchange message and the client's are sent in the client key exchange message. Eavesdroppers who do not know the private values should not be able to find the Diffie-Hellman result (i.e. the pre_master_secret).",
      "ja": "ディフィー・ヘルマンでは、サーバの公開パラメータは、サーバ鍵交換メッセージに含まれており、クライアントのは、クライアント鍵交換メッセージで送信されます。民間の値を知らない盗聴者は、Diffie-Hellman結果（すなわち、前_のマスター_秘密を）見つけることができないようにする必要があり。"
    },
    {
      "indent": 1,
      "text": "Warning: Completely anonymous connections only provide protection against passive eavesdropping. Unless an independent tamper-proof channel is used to verify that the finished messages were not replaced by an attacker, server authentication is required in environments where active man-in-the-middle attacks are a concern.",
      "ja": "警告：完全に匿名接続のみ受動的盗聴に対する保護を提供します。独立した改ざん防止チャンネルが完成し、メッセージが攻撃者に取り替えられなかったことを確認するために使用されていない限り、サーバー認証がアクティブman-in-the-middle攻撃が懸念されている環境で必要とされます。"
    },
    {
      "indent": 0,
      "text": "F.1.1.2. RSA key exchange and authentication",
      "ja": "F.1.1.2。 RSA鍵交換と認証"
    },
    {
      "indent": 3,
      "text": "With RSA, key exchange and server authentication are combined. The public key may be either contained in the server's certificate or may be a temporary RSA key sent in a server key exchange message. When temporary RSA keys are used, they are signed by the server's RSA or DSS certificate. The signature includes the current ClientHello.random, so old signatures and temporary keys cannot be replayed. Servers may use a single temporary RSA key for multiple negotiation sessions.",
      "ja": "RSAでは、鍵交換およびサーバー認証が組み合わされています。公開鍵は、サーバーの証明書に含まれていてもよいいずれか、またはサーバーの鍵交換メッセージで送信された一時的RSA鍵かもしれません。一時的RSA鍵が使用される場合、それらはサーバのRSAまたはDSS証明書によって署名されています。署名は、現在のClientHello.random、とても古い署名と一時キーは再生できないことが含まれます。サーバは、複数の交渉セッションのための単一の一時的RSA鍵を使用することができます。"
    },
    {
      "indent": 1,
      "text": "Note: The temporary RSA key option is useful if servers need large certificates but must comply with government-imposed size limits on keys used for key exchange.",
      "ja": "注意：サーバが大規模な証明書が必要ですが、鍵交換のために使用されるキーに関する政府・サイズ制限を遵守しなければならない場合は、一時的なRSAキーオプションが便利です。"
    },
    {
      "indent": 3,
      "text": "After verifying the server's certificate, the client encrypts a pre_master_secret with the server's public key. By successfully decoding the pre_master_secret and producing a correct finished message, the server demonstrates that it knows the private key corresponding to the server certificate.",
      "ja": "サーバーの証明書を検証した後、クライアントは、サーバの公開鍵で前_のマスター_秘密を暗号化します。首尾よく前_のマスター_秘密を解読し、正しいFinishedメッセージを出すことによって、サーバは、サーバ証明書に対応する秘密鍵を知っていることを示しています。"
    },
    {
      "indent": 3,
      "text": "When RSA is used for key exchange, clients are authenticated using the certificate verify message (see Section 7.4.8). The client signs a value derived from the master_secret and all preceding handshake messages. These handshake messages include the server certificate, which binds the signature to the server, and ServerHello.random, which binds the signature to the current handshake process.",
      "ja": "RSAは、鍵交換に使用されている場合、クライアントは証明書（セクション7.4.8を参照）のメッセージを確認するを使用して認証されます。クライアントは、マスター_と先行するすべてのハンドシェイクメッセージから得られた値に署名します。これらのハンドシェイクメッセージは、現在のハンドシェイクプロセスへの署名をバインドするサーバーサーバーへの署名を結合した証明書、およびServerHello.randomが含まれます。"
    },
    {
      "indent": 0,
      "text": "F.1.1.3. Diffie-Hellman key exchange with authentication",
      "ja": "F.1.1.3。認証付きのDiffie-Hellman鍵交換を"
    },
    {
      "indent": 3,
      "text": "When Diffie-Hellman key exchange is used, the server can either supply a certificate containing fixed Diffie-Hellman parameters or can use the server key exchange message to send a set of temporary Diffie-Hellman parameters signed with a DSS or RSA certificate. Temporary parameters are hashed with the hello.random values before signing to ensure that attackers do not replay old parameters. In either case, the client can verify the certificate or signature to ensure that the parameters belong to the server.",
      "ja": "Diffie-Hellman鍵交換を使用した場合、サーバは、固定のDiffie-Hellmanパラメータを含む証明書を提供するか、またはDSSまたはRSA証明書で署名された一時的のDiffie-Hellmanパラメータのセットを送信するためにサーバ鍵交換メッセージを使用することができます。一時的なパラメータは、攻撃者が古いパラメータを再生していないことを保証するために署名する前のhello.random値でハッシュ化されています。いずれの場合も、クライアントは、パラメータがサーバーに属していることを確認するために証明書または署名を検証することができます。"
    },
    {
      "indent": 3,
      "text": "If the client has a certificate containing fixed Diffie-Hellman parameters, its certificate contains the information required to complete the key exchange. Note that in this case the client and server will generate the same Diffie-Hellman result (i.e., pre_master_secret) every time they communicate. To prevent the pre_master_secret from staying in memory any longer than necessary, it should be converted into the master_secret as soon as possible. Client Diffie-Hellman parameters must be compatible with those supplied by the server for the key exchange to work.",
      "ja": "クライアントが固定Diffie-Hellmanパラメータを含む証明書を持っている場合は、その証明書は、鍵交換を完了するために必要な情報が含まれています。この場合、クライアントとサーバが同一のDiffie-Hellman結果（すなわち、前_のマスター_秘密）は、それらが通信するたびに発生することに注意してください。もはや必要以上にメモリに滞在から前_のマスター_秘密を防止するためには、できるだけ早くmaster_secretへ変換する必要があります。クライアントのDiffie-Hellmanパラメータは、鍵交換を行うために、サーバによって提供されたものと互換性がなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the client has a standard DSS or RSA certificate or is unauthenticated, it sends a set of temporary parameters to the server in the client key exchange message, then optionally uses a certificate verify message to authenticate itself.",
      "ja": "クライアントが標準DSSまたはRSA証明書を持っているか、認証されていない場合には、それはクライアント鍵交換メッセージでサーバーに一時的なパラメータのセットを送信し、その後、必要に応じて自分自身を認証するためのメッセージを確認し、証明書を使用しています。"
    },
    {
      "indent": 0,
      "text": "F.1.2. Version rollback attacks",
      "ja": "F.1.2。バージョンロールバック攻撃"
    },
    {
      "indent": 3,
      "text": "Because TLS includes substantial improvements over SSL Version 2.0, attackers may try to make TLS-capable clients and servers fall back to Version 2.0. This attack can occur if (and only if) two TLS-capable parties use an SSL 2.0 handshake.",
      "ja": "TLSは、SSLバージョン2.0からのかなりの改良が含まれているため、攻撃者は、TLS対応のクライアントとサーバがバージョン2.0に戻すようにさせるかもしれません。 （および場合のみ）2 TLS対応の当事者はSSL 2.0ハンドシェイクを使用する場合は、この攻撃が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Although the solution using non-random PKCS #1 block type 2 message padding is inelegant, it provides a reasonably secure way for Version 3.0 servers to detect the attack. This solution is not secure against attackers who can brute force the key and substitute a new ENCRYPTED-KEY-DATA message containing the same key (but with normal padding) before the application specified wait threshold has expired. Parties concerned about attacks of this scale should not be using 40-bit encryption keys anyway. Altering the padding of the least-significant 8 bytes of the PKCS padding does not impact security for the size of the signed hashes and RSA key lengths used in the protocol, since this is essentially equivalent to increasing the input block size by 8 bytes.",
      "ja": "非ランダムPKCS＃1ブロック型2メッセージパディングを使用したソリューションは無粋ですが、それはバージョン3.0のサーバーが攻撃を検出するための合理的に安全な方法を提供します。このソリューションでは、キーをブルートフォースし、アプリケーション指定の待機しきい値が経過する前に同じキーを（ただし、通常のパディングを持つ）を含む新しいENCRYPTED-KEY-DATAメッセージを置き換えることができ、攻撃者に対して安全ではありません。この規模の攻撃を懸念締約国はとにかく40ビットの暗号化キーを使用するべきではありません。これは8バイトの入力ブロックサイズを大きくすると本質的に同等であるので、PKCSパディングの最下位8バイトのパディングを変更すると、署名されたハッシュとプロトコルで使用されるRSA鍵の長さのサイズのセキュリティに影響を与えません。"
    },
    {
      "indent": 0,
      "text": "F.1.3. Detecting attacks against the handshake protocol",
      "ja": "F.1.3。ハンドシェイクプロトコルに対する攻撃を検出"
    },
    {
      "indent": 3,
      "text": "An attacker might try to influence the handshake exchange to make the parties select different encryption algorithms than they would normally choose. Because many implementations will support 40-bit exportable encryption and some may even support null encryption or MAC algorithms, this attack is of particular concern.",
      "ja": "攻撃者は、当事者が、彼らは通常、選ぶだろうとは異なる暗号化アルゴリズムを選択するためにハンドシェイク交換に影響を与えることを試みるかもしれません。多くの実装は、40ビットのエクスポート暗号化をサポートし、いくつかのもヌル暗号化やMACアルゴリズムをサポートする可能性があるので、この攻撃は特に懸念されます。"
    },
    {
      "indent": 3,
      "text": "For this attack, an attacker must actively change one or more handshake messages. If this occurs, the client and server will compute different values for the handshake message hashes. As a result, the parties will not accept each others' finished messages. Without the master_secret, the attacker cannot repair the finished messages, so the attack will be discovered.",
      "ja": "この攻撃では、攻撃者が積極的に一つ以上のハンドシェイクメッセージを変更する必要があります。この問題が発生した場合、クライアントとサーバーはハンドシェイクメッセージのハッシュに異なる値を計算します。その結果、当事者はお互いのFinishedメッセージを受け付けません。攻撃が検出されますので、マスター_がなければ、攻撃者は、完成したメッセージを修復することはできません。"
    },
    {
      "indent": 0,
      "text": "F.1.4. Resuming sessions",
      "ja": "F.1.4。セッションを再開"
    },
    {
      "indent": 3,
      "text": "When a connection is established by resuming a session, new ClientHello.random and ServerHello.random values are hashed with the session's master_secret. Provided that the master_secret has not been compromised and that the secure hash operations used to produce the encryption keys and MAC secrets are secure, the connection should be secure and effectively independent from previous connections. Attackers cannot use known encryption keys or MAC secrets to compromise the master_secret without breaking the secure hash operations (which use both SHA and MD5).",
      "ja": "接続がセッションを再開することによって確立されたとき、新しいClientHello.randomととServerHello.random値はセッションのマスター_秘密で論じ尽くされます。マスター_が損なわれていないことと、暗号化鍵とMACシークレットを生成するために使用されるセキュアハッシュ操作が安全であることを条件とする、接続は、以前の接続から安全かつ効果的に独立であるべきです。攻撃者は、（SHAとMD5の両方を使用）、セキュアハッシュ演算を壊すことなくでマスター_を損なうことが知られている暗号化キーまたはMAC秘密を使用することはできません。"
    },
    {
      "indent": 3,
      "text": "Sessions cannot be resumed unless both the client and server agree. If either party suspects that the session may have been compromised, or that certificates may have expired or been revoked, it should force a full handshake. An upper limit of 24 hours is suggested for session ID lifetimes, since an attacker who obtains a master_secret may be able to impersonate the compromised party until the corresponding session ID is retired. Applications that may be run in relatively insecure environments should not write session IDs to stable storage.",
      "ja": "クライアントとサーバの両方が同意しない限り、セッションは再開できません。いずれかの当事者が、セッションが侵害された可能性があること、または証明書の期限が切れたか、取り消されていることを疑った場合、それは完全なハンドシェイクを強制する必要があります。対応するセッションIDがリタイアするまでmaster_secretを入手した攻撃者は妥協がパーティを偽装することができる可能性があるため、24時間の上限は、セッションIDの寿命のために提案されます。比較的安全でない環境で実行されるアプリケーションは、安定したストレージにセッションIDを書くべきではありません。"
    },
    {
      "indent": 0,
      "text": "F.1.5. MD5 and SHA",
      "ja": "F.1.5。 MD5とSHA"
    },
    {
      "indent": 3,
      "text": "TLS uses hash functions very conservatively. Where possible, both MD5 and SHA are used in tandem to ensure that non-catastrophic flaws in one algorithm will not break the overall protocol.",
      "ja": "TLSは非常に保守的ハッシュ関数を使用しています。可能であれば、MD5とSHAの両方を1つのアルゴリズムにおける非致命的な欠陥が、全体的なプロトコルを壊さないようにするためにタンデムで使用されています。"
    },
    {
      "indent": 0,
      "text": "F.2. Protecting application data",
      "ja": "F.2。アプリケーションデータの保護"
    },
    {
      "indent": 3,
      "text": "The master_secret is hashed with the ClientHello.random and ServerHello.random to produce unique data encryption keys and MAC secrets for each connection.",
      "ja": "でマスター_は、接続ごとに固有のデータ暗号化鍵とMACシークレットを生成するためのClientHello.randomとServerHello.randomでハッシュされます。"
    },
    {
      "indent": 3,
      "text": "Outgoing data is protected with a MAC before transmission. To prevent message replay or modification attacks, the MAC is computed from the MAC secret, the sequence number, the message length, the message contents, and two fixed character strings. The message type field is necessary to ensure that messages intended for one TLS Record Layer client are not redirected to another. The sequence number ensures that attempts to delete or reorder messages will be detected. Since sequence numbers are 64-bits long, they should never overflow. Messages from one party cannot be inserted into the other's output, since they use independent MAC secrets. Similarly, the server-write and client-write keys are independent so stream cipher keys are used only once.",
      "ja": "送信データが送信される前にMACで保護されています。メッセージの再生または変更攻撃を防ぐために、MACはMACの秘密、シーケンス番号、メッセージ長、メッセージの内容、および2つの固定文字列から計算されます。メッセージタイプフィールドは1つのTLSレコード層クライアント向けのメッセージを別のにリダイレクトされていないことを確認する必要があります。シーケンス番号は、メッセージを削除したり、並べ替えしようとする試みが検出されることを保証します。シーケンス番号は64ビット長であるので、それらはオーバーフローありません。彼らは独立したMAC秘密を使用するので、1回のパーティーからのメッセージは、相手の出力に挿入することはできません。同様に、サーバ・ライトおよびクライアント・ライトキーが独立しているので、暗号鍵は一度だけ使用されているストリーム。"
    },
    {
      "indent": 3,
      "text": "If an attacker does break an encryption key, all messages encrypted with it can be read. Similarly, compromise of a MAC key can make message modification attacks possible. Because MACs are also encrypted, message-alteration attacks generally require breaking the encryption algorithm as well as the MAC.",
      "ja": "攻撃者が暗号化キーを破るない場合、それを用いて暗号化されたすべてのメッセージを読み取ることができます。同様に、MACキーの妥協は、メッセージ変更攻撃を可能にすることができます。 MACのも暗号化されているので、メッセージ改ざん攻撃は、一般的に、暗号化アルゴリズムと同様にMACを破る必要があります。"
    },
    {
      "indent": 1,
      "text": "Note: MAC secrets may be larger than encryption keys, so messages can remain tamper resistant even if encryption keys are broken.",
      "ja": "注意：メッセージは暗号化キーが壊れている場合でも、耐タンパ残ることができるようにMACの秘密は、暗号化キーより大きいかもしれません。"
    },
    {
      "indent": 0,
      "text": "F.3. Final notes",
      "ja": "F.3。最終的なノート"
    },
    {
      "indent": 3,
      "text": "For TLS to be able to provide a secure connection, both the client and server systems, keys, and applications must be secure. In addition, the implementation must be free of security errors.",
      "ja": "TLSが安全な接続を提供することができるようにするには、クライアントとサーバシステム、キー、およびアプリケーションの両方が安全でなければなりません。また、実装は、セキュリティエラーがあってはなりません。"
    },
    {
      "indent": 3,
      "text": "The system is only as strong as the weakest key exchange and authentication algorithm supported, and only trustworthy cryptographic functions should be used. Short public keys, 40-bit bulk encryption keys, and anonymous servers should be used with great caution. Implementations and users must be careful when deciding which certificates and certificate authorities are acceptable; a dishonest certificate authority can do tremendous damage.",
      "ja": "システムは、最も弱いキー交換および認証アルゴリズムがサポートされる唯一のような強く、唯一信頼できる暗号化機能を使用すべきです。短い公開鍵、40ビットバルク暗号化キー、および匿名のサーバは十分に注意して使用する必要があります。証明書と認証局が許容されるかを決めるとき、実装し、ユーザーが注意しなければなりません。不正認証局は多大なダメージを与えることができます。"
    },
    {
      "indent": 0,
      "text": "G. Patent Statement",
      "ja": "G.特許声明"
    },
    {
      "indent": 3,
      "text": "Some of the cryptographic algorithms proposed for use in this protocol have patent claims on them. In addition Netscape Communications Corporation has a patent claim on the Secure Sockets Layer (SSL) work that this standard is based on. The Internet Standards Process as defined in RFC 2026 requests that a statement be obtained from a Patent holder indicating that a license will be made available to applicants under reasonable terms and conditions.",
      "ja": "このプロトコルで使用するために提案されている暗号アルゴリズムのいくつかは、それらの上に、特許請求の範囲を持っています。またネットスケープ・コミュニケーションズ社は、Secure Sockets Layer（SSL）この規格が基づいている仕事上の特許クレームを持っています。ステートメントは、ライセンスが合理的諸条件の下で出願人に利用可能にされることを示す特許権者から得ることがRFC 2026の要求に定義されているインターネット標準化過程。"
    },
    {
      "indent": 3,
      "text": "The Massachusetts Institute of Technology has granted RSA Data Security, Inc., exclusive sub-licensing rights to the following patent issued in the United States:",
      "ja": "マサチューセッツ工科大学はRSA Data Security社、米国で発行された以下の特許への排他的、サブライセンス権付与しました："
    },
    {
      "indent": 7,
      "text": "Cryptographic Communications System and Method (\"RSA\"), No.\n4,405,829",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Netscape Communications Corporation has been issued the following patent in the United States:",
      "ja": "ネットスケープ・コミュニケーションズ社は、米国では、以下の特許を発行されています："
    },
    {
      "indent": 7,
      "text": "Secure Socket Layer Application Program Apparatus And Method\n(\"SSL\"), No. 5,657,390",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Netscape Communications has issued the following statement:",
      "ja": "ネットスケープ・コミュニケーションズは、次の文を発行しました："
    },
    {
      "indent": 7,
      "text": "Intellectual Property Rights",
      "ja": "知的財産権"
    },
    {
      "indent": 7,
      "text": "Secure Sockets Layer",
      "ja": "セキュア・ソケット・レイヤー"
    },
    {
      "indent": 7,
      "text": "The United States Patent and Trademark Office (\"the PTO\") recently issued U.S. Patent No. 5,657,390 (\"the SSL Patent\") to Netscape for inventions described as Secure Sockets Layers (\"SSL\"). The IETF is currently considering adopting SSL as a transport protocol with security features. Netscape encourages the royalty-free adoption and use of the SSL protocol upon the following terms and conditions:",
      "ja": "米国特許商標庁（「PTO」）最近発行された米国特許第5657390（「SSL特許」）のNetscapeへのセキュア・ソケット・レイヤー（「SSL」）として記載される本発明のために。 IETFは現在、セキュリティ機能を持つトランスポートプロトコルとしてSSLを採用検討しています。 Netscapeは、以下の条件に応じロイヤリティフリーの採用とSSLプロトコルの使用を奨励します："
    },
    {
      "indent": 9,
      "text": "* If you already have a valid SSL Ref license today which includes source code from Netscape, an additional patent license under the SSL patent is not required.",
      "ja": "すでにネットスケープからソースコードが含まれ、有効なSSL参考ライセンス今日を持っている場合は*、SSLの特許に基づく追加的な特許ライセンスは必要ありません。"
    },
    {
      "indent": 9,
      "text": "* If you don't have an SSL Ref license, you may have a royalty free license to build implementations covered by the SSL Patent Claims or the IETF TLS specification provided that you do not to assert any patent rights against Netscape or other companies for the implementation of SSL or the IETF TLS recommendation.",
      "ja": "*あなたはSSLのRefライセンスをお持ちでない場合は、あなたがのためにNetscapeや他の企業に対して、任意の特許権を主張しないことを提供するSSL特許クレームやIETF TLS仕様でカバー実装を構築するためのロイヤリティフリーのライセンスを持っていることSSLやTLS IETF勧告の実装。"
    },
    {
      "indent": 7,
      "text": "What are \"Patent Claims\":",
      "ja": "「特許クレームは、」どのようなものです："
    },
    {
      "indent": 7,
      "text": "Patent claims are claims in an issued foreign or domestic patent that:",
      "ja": "特許クレームは、その発行した外国や国内の特許のクレームのとおりです。"
    },
    {
      "indent": 8,
      "text": "1) must be infringed in order to implement methods or build products according to the IETF TLS specification; or",
      "ja": "1）メソッドを実装するか、IETF TLS仕様に応じて製品を構築するために侵害されなければなりません。または"
    },
    {
      "indent": 8,
      "text": "2) patent claims which require the elements of the SSL patent claims and/or their equivalents to be infringed.",
      "ja": "2）SSLの特許請求の範囲及び/又はそれらの均等物の構成要素を必要とする特許請求の範囲を侵害します。"
    },
    {
      "indent": 3,
      "text": "The Internet Society, Internet Architecture Board, Internet Engineering Steering Group and the Corporation for National Research Initiatives take no position on the validity or scope of the patents and patent applications, nor on the appropriateness of the terms of the assurance. The Internet Society and other groups mentioned above have not made any determination as to any other intellectual property rights which may apply to the practice of this standard. Any further consideration of these matters is the user's own responsibility.",
      "ja": "インターネット協会、インターネットアーキテクチャ委員会、インターネットエンジニアリング運営グループや国立研究イニシアチブのための社は、特許および特許出願の有効性や適用範囲にはポジションを取るなく、また保証の条件の妥当性について。インターネット協会および上記の他のグループは、この標準の実践に適用する可能性のあるその他の知的財産権に関するどのような決意を行っていません。これらの問題のいずれかの更なる検討は、ユーザー自身の責任です。"
    },
    {
      "indent": 0,
      "text": "Security Considerations",
      "ja": "セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Security issues are discussed throughout this memo.",
      "ja": "セキュリティの問題は、このメモ中で議論されています。"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "リファレンス"
    },
    {
      "indent": 3,
      "text": "[3DES] W. Tuchman, \"Hellman Presents No Shortcut Solutions To DES,\" IEEE Spectrum, v. 16, n. 7, July 1979, pp40-41.",
      "ja": "[3DES] W. Tuchmanは、nは、IEEEスペクトラム、V。16 \"HellmanはDESへの近道のソリューションを提示していません\"。 7、1979年7月、pp40-41。"
    },
    {
      "indent": 3,
      "text": "[BLEI] Bleichenbacher D., \"Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1\" in Advances in Cryptology -- CRYPTO'98, LNCS vol. 1462, pages: 1--12, 1998.",
      "ja": "【BLEI] BleichenbacherのD.、暗号理論における進歩で「RSA暗号化標準PKCS＃1に基づくプロトコルに対して選択暗号文攻撃」 -  CRYPTO'98、LNCS体積。 1462、ページ：1--12、1998。"
    },
    {
      "indent": 3,
      "text": "[DES] ANSI X3.106, \"American National Standard for Information Systems-Data Link Encryption,\" American National Standards Institute, 1983.",
      "ja": "[DES] ANSI X3.106、米国規格協会、1983年「情報システム、データリンク暗号化、アメリカ国家規格」。"
    },
    {
      "indent": 3,
      "text": "[DH1] W. Diffie and M. E. Hellman, \"New Directions in Cryptography,\" IEEE Transactions on Information Theory, V. IT-22, n. 6, Jun 1977, pp. 74-84.",
      "ja": "[DH1] W.ディフィーとM. E.ヘルマン、 \"暗号に関する新、\" 情報理論に関するIEEEトランザクション、V. IT-22、N。 6、1977年6月、頁74から84。"
    },
    {
      "indent": 3,
      "text": "[DSS] NIST FIPS PUB 186, \"Digital Signature Standard,\" National Institute of Standards and Technology, U.S. Department of Commerce, May 18, 1994.",
      "ja": "[DSS] NIST FIPS PUB 186、 \"デジタル署名標準、\" アメリカ国立標準技術研究所、米国商務省が、1994年5月18日。"
    },
    {
      "indent": 3,
      "text": "[FTP] Postel J., and J. Reynolds, \"File Transfer Protocol\", STD 9, RFC 959, October 1985.",
      "ja": "[FTP]ポステルJ.、およびJ.レイノルズ、 \"ファイル転送プロトコル\"、STD 9、RFC 959、1985年10月。"
    },
    {
      "indent": 3,
      "text": "[HTTP] Berners-Lee, T., Fielding, R., and H. Frystyk, \"Hypertext Transfer Protocol -- HTTP/1.0\", RFC 1945, May 1996.",
      "ja": "[HTTP]バーナーズ=リー、T.、フィールディング、R.、およびH. Frystyk、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.0\"、RFC 1945、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[HMAC] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication,\" RFC 2104, February 1997.",
      "ja": "[HMAC] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ、\" RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[IDEA] X. Lai, \"On the Design and Security of Block Ciphers,\" ETH Series in Information Processing, v. 1, Konstanz: Hartung-Gorre Verlag, 1992.",
      "ja": "[IDEA] X.ライ、 \"ブロック暗号のデザインとセキュリティ上、\" 情報処理におけるETHシリーズ、V 1、コンスタンツ：。アルトゥング-Gorre Verlag社、1992。"
    },
    {
      "indent": 3,
      "text": "[MD2] Kaliski, B., \"The MD2 Message Digest Algorithm\", RFC 1319, April 1992.",
      "ja": "[MD2] Kaliski、B.、 \"MD2メッセージダイジェストアルゴリズム\"、RFC 1319、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[MD5] Rivest, R., \"The MD5 Message Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[MD5] Rivest氏、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[PKCS1] RSA Laboratories, \"PKCS #1: RSA Encryption Standard,\" version 1.5, November 1993.",
      "ja": "[PKCS1] RSA Laboratories社、 \"PKCS＃1：RSA暗号化規格、\" バージョン1.5、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[PKCS6] RSA Laboratories, \"PKCS #6: RSA Extended Certificate Syntax Standard,\" version 1.5, November 1993.",
      "ja": "[PKCS6] RSA Laboratories社、 \"PKCS＃6：RSA拡張証明書の構文規格、\" バージョン1.5、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[PKCS7] RSA Laboratories, \"PKCS #7: RSA Cryptographic Message Syntax Standard,\" version 1.5, November 1993.",
      "ja": "[PKCS7] RSA Laboratories社、 \"PKCS＃7：RSA暗号メッセージ構文規格、\" バージョン1.5、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[PKIX] Housley, R., Ford, W., Polk, W. and D. Solo, \"Internet Public Key Infrastructure: Part I: X.509 Certificate and CRL Profile\", RFC 2459, January 1999.",
      "ja": "[PKIX] Housley氏、R.、フォード、W.、ポーク、W.およびD.ソロ、 \"インターネット公開鍵インフラストラクチャ：パートI：X.509証明書とCRLプロファイル\"、RFC 2459、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[RC2] Rivest, R., \"A Description of the RC2(r) Encryption Algorithm\", RFC 2268, January 1998.",
      "ja": "[RC2]リベスト、R.、 \"RC2（R）暗号化アルゴリズムの説明\"、RFC 2268、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[RC4] Thayer, R. and K. Kaukonen, A Stream Cipher Encryption Algorithm, Work in Progress.",
      "ja": "[RC4]セイヤー、R.及びK. Kaukonen、ストリーム暗号の暗号化アルゴリズム、進行中で働いています。"
    },
    {
      "indent": 3,
      "text": "[RSA] R. Rivest, A. Shamir, and L. M. Adleman, \"A Method for Obtaining Digital Signatures and Public-Key Cryptosystems,\" Communications of the ACM, v. 21, n. 2, Feb 1978, pp. 120- 126.",
      "ja": "[RSA] R.リベスト、A. Shamir、およびL. M.エイドルマン、N、ACM、V。21の通信 \"デジタル署名と公開鍵暗号得るための方法\"。 2、1978年2月、頁120〜126。"
    },
    {
      "indent": 3,
      "text": "[RSADSI] Contact RSA Data Security, Inc., Tel: 415-595-8782",
      "ja": "[RSADSI]連絡先RSA Data Security社、電話：415-595-8782"
    },
    {
      "indent": 3,
      "text": "[SCH] B. Schneier. Applied Cryptography: Protocols, Algorithms, and Source Code in C, Published by John Wiley & Sons, Inc. 1994.",
      "ja": "[SCH] B.シュナイアー。応用暗号：ジョン・ワイリー＆サンズ社1994年発行Cでのプロトコル、アルゴリズム、およびソースコード、。"
    },
    {
      "indent": 3,
      "text": "[SHA] NIST FIPS PUB 180-1, \"Secure Hash Standard,\" National Institute of Standards and Technology, U.S. Department of Commerce, Work in Progress, May 31, 1994.",
      "ja": "[SHA] NIST FIPS PUB 180-1の、「セキュアハッシュ標準、」アメリカ国立標準技術研究所、米国商務省が進行中で働いて、1994年5月31日。"
    },
    {
      "indent": 3,
      "text": "[SSL2] Hickman, Kipp, \"The SSL Protocol\", Netscape Communications Corp., Feb 9, 1995.",
      "ja": "[SSL2]ヒックマン、キップ、 \"SSLプロトコル\"、ネットスケープ・コミュニケーションズ社、1995年2月9日。"
    },
    {
      "indent": 3,
      "text": "[SSL3] A. Frier, P. Karlton, and P. Kocher, \"The SSL 3.0 Protocol\", Netscape Communications Corp., Nov 18, 1996.",
      "ja": "[SSL3] A. Frier、P. Karlton、およびP.コッヘル、 \"SSL 3.0プロトコル\"、ネットスケープ・コミュニケーションズ社、1996年11月18日。"
    },
    {
      "indent": 3,
      "text": "[TCP] Postel, J., \"Transmission Control Protocol,\" STD 7, RFC 793, September 1981.",
      "ja": "[TCP]ポステル、J.、 \"伝送制御プロトコル、\" STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[TEL] Postel J., and J. Reynolds, \"Telnet Protocol Specifications\", STD 8, RFC 854, May 1993.",
      "ja": "[TEL]ポステルJ.、およびJ.レイノルズ、 \"Telnetプロトコル仕様\"、STD 8、RFC 854、1993年5月。"
    },
    {
      "indent": 3,
      "text": "[TEL] Postel J., and J. Reynolds, \"Telnet Option Specifications\", STD 8, RFC 855, May 1993.",
      "ja": "[TEL]ポステルJ.、およびJ.レイノルズ、 \"Telnetオプション仕様\"、STD 8、RFC 855、1993年5月。"
    },
    {
      "indent": 3,
      "text": "[X509] CCITT. Recommendation X.509: \"The Directory - Authentication Framework\". 1988.",
      "ja": "[X509] CCITT。勧告X.509：「ディレクトリ - 認証フレームワーク」。 1988。"
    },
    {
      "indent": 3,
      "text": "[XDR] R. Srinivansan, Sun Microsystems, RFC-1832: XDR: External Data Representation Standard, August 1995.",
      "ja": "[XDR] R. Srinivansan、サン・マイクロシステムズ、RFC-1832：XDR：外部データ表現標準、1995年8月。"
    },
    {
      "indent": 0,
      "text": "Credits",
      "ja": "クレジット"
    },
    {
      "indent": 3,
      "text": "Win Treese Open Market",
      "ja": "勝利Treeseオープン市場"
    },
    {
      "indent": 3,
      "text": "EMail: treese@openmarket.com",
      "ja": "メールアドレス：treese@openmarket.com"
    },
    {
      "indent": 3,
      "text": "Editors",
      "ja": "編集者"
    },
    {
      "indent": 3,
      "text": "Christopher Allen Tim Dierks Certicom Certicom",
      "ja": "クリストファー・アレンティム・ダークスのCerticomのCerticom"
    },
    {
      "indent": 3,
      "text": "EMail: callen@certicom.com EMail: tdierks@certicom.com",
      "ja": "電子メール：callen@certicom.com Eメール：tdierks@certicom.com"
    },
    {
      "indent": 3,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tim Dierks Philip L. Karlton Certicom Netscape Communications",
      "ja": "ティム・ダークスフィリップL. Karlton Certicomのネットスケープ・コミュニケーションズ"
    },
    {
      "indent": 3,
      "text": "EMail: tdierks@certicom.com",
      "ja": "メールアドレス：tdierks@certicom.com"
    },
    {
      "indent": 3,
      "text": "Alan O. Freier Paul C. Kocher Netscape Communications Independent Consultant",
      "ja": "アラン・O.フライアーポールC.コッヘルネットスケープ・コミュニケーションズの独立コンサルタント"
    },
    {
      "indent": 3,
      "text": "EMail: freier@netscape.com EMail: pck@netcom.com",
      "ja": "電子メール：freier@netscape.com Eメール：pck@netcom.com"
    },
    {
      "indent": 3,
      "text": "Other contributors",
      "ja": "その他の貢献者"
    },
    {
      "indent": 3,
      "text": "Martin Abadi Robert Relyea Digital Equipment Corporation Netscape Communications",
      "ja": "マーティン・アバディロバートRelyeaディジタル・イクイップメント・コーポレーションネットスケープ・コミュニケーションズ"
    },
    {
      "indent": 3,
      "text": "EMail: ma@pa.dec.com EMail: relyea@netscape.com",
      "ja": "電子メール：ma@pa.dec.com Eメール：relyea@netscape.com"
    },
    {
      "indent": 3,
      "text": "Ran Canetti Jim Roskind IBM Watson Research Center Netscape Communications",
      "ja": "蘭カネッティジムRoskind IBMワトソン研究所ネットスケープ・コミュニケーションズ"
    },
    {
      "indent": 3,
      "text": "EMail: canetti@watson.ibm.com EMail: jar@netscape.com",
      "ja": "電子メール：canetti@watson.ibm.com Eメール：jar@netscape.com"
    },
    {
      "indent": 3,
      "text": "Taher Elgamal Micheal J. Sabin, Ph. D. Securify Consulting Engineer",
      "ja": "タハー・エルガマルマイケルJ.セービンあり、Ph。D. Securifyコンサルティングエンジニア"
    },
    {
      "indent": 3,
      "text": "EMail: elgamal@securify.com EMail: msabin@netcom.com",
      "ja": "電子メール：elgamal@securify.com Eメール：msabin@netcom.com"
    },
    {
      "indent": 3,
      "text": "Anil R. Gangolli Dan Simon Structured Arts Computing Corp. Microsoft",
      "ja": "アニルはrを。ダンサイモンは芸術コンピューティング社Gangoliをstreturd。マイクロソフト"
    },
    {
      "indent": 3,
      "text": "EMail: gangolli@structuredarts.com EMail: dansimon@microsoft.com",
      "ja": "電子メール：gangolli@structuredarts.com Eメール：dansimon@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Kipp E.B. Hickman Tom Weinstein Netscape Communications Netscape Communications",
      "ja": "キップE.B.ヒックマントム・ワインスタインネットスケープコミュニケーションズネットスケープ・コミュニケーションズ"
    },
    {
      "indent": 3,
      "text": "EMail: kipp@netscape.com EMail: tomw@netscape.com",
      "ja": "電子メール：kipp@netscape.com Eメール：tomw@netscape.com"
    },
    {
      "indent": 3,
      "text": "Hugo Krawczyk IBM Watson Research Center",
      "ja": "ヒューゴKrawczyk IBMワトソン研究所"
    },
    {
      "indent": 3,
      "text": "EMail: hugo@watson.ibm.com",
      "ja": "メールアドレス：hugo@watson.ibm.com"
    },
    {
      "indent": 0,
      "text": "Comments",
      "ja": "注釈"
    },
    {
      "indent": 3,
      "text": "The discussion list for the IETF TLS working group is located at the e-mail address <ietf-tls@lists.consensus.com>. Information on the group and information on how to subscribe to the list is at <http://lists.consensus.com/>.",
      "ja": "IETF TLSワーキンググループの議論のリストは、電子メールアドレス<ietf-tls@lists.consensus.com>に位置しています。リストの購読方法グループ情報に関する情報は、<http://lists.consensus.com/>です。"
    },
    {
      "indent": 3,
      "text": "Archives of the list can be found at: <http://www.imc.org/ietf-tls/mail-archive/>",
      "ja": "<http://www.imc.org/ietf-tls/mail-archive/>：リストのアーカイブはで見つけることができます"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1999）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    }
  ]
}