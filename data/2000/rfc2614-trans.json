{
  "title": {
    "text": "RFC 2614 - An API for Service Location",
    "ja": "RFC 2614 - サービスロケーションのためのAPI"
  },
  "number": 2614,
  "created_at": "2019-10-27 12:12:24.906972+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          J. Kempf\nRequest for Comments: 2614                                   E. Guttman\nCategory: Informational                                Sun Microsystems\n                                                              June 1999",
      "raw": true
    },
    {
      "indent": 22,
      "text": "An API for Service Location",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Service Location Protocol (SLP) provides a new way for clients to dynamically discovery network services. With SLP, it is simple to offer highly available services that require no user configuration or assistance from network administrators prior to use. This document describes standardized APIs for SLP in C and Java. The APIs are modular and are designed to allow implementations to offer just the feature set needed. In addition, standardized file formats for configuration and serialized registrations are defined, allowing SLP agents to set network and other parameters in a portable way. The serialized file format allows legacy services to be registered with SLP directory agents in cases where modifying the legacy service program code is difficult or impossible, and to portably exchange a registration database.",
      "ja": "サービスロケーションプロトコル（SLP）クライアントに動的に発見ネットワークサービスのための新しい方法を提供します。 SLPと、使用する前にネットワーク管理者からのユーザ設定や援助を必要としない可用性の高いサービスを提供するのは簡単です。このドキュメントでは、CやJavaでのSLPのための標準化されたAPIについて説明します。 APIは、モジュール式であり、実装が必要なだけの機能セットを提供できるように設計されています。加えて、構成およびシリアライズ登録のための標準化されたファイル形式は、SLPエージェントは、ポータブルな方法でネットワークおよび他のパラメータを設定することができ、定義されています。シリアル化されたファイル形式は、従来のサービスは、従来のサービス・プログラム・コードを変更することは困難または不可能である場合にはSLPディレクトリエージェントに登録することができ、そして移植登録データベースを交換します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 4,
      "text": "1. Introduction                                                    4\n    1.1. Goals  . . . . . . . . . . . . . . . . . . . . . . . .    4\n    1.2. Terminology  . . . . . . . . . . . . . . . . . . . . .    4\n2. File Formats                                                    7\n    2.1. Configuration File Format  . . . . . . . . . . . . . .    8\n          2.1.1. DA configuration   . . . . . . . . . . . . . .    9\n          2.1.2. Static Scope Configuration . . . . . . . . . .    9\n          2.1.3. Tracing and Logging  . . . . . . . . . . . . .   11\n          2.1.4. Serialized Proxy Registrations . . . . . . . .   11\n          2.1.5. Network Configuration Properties . . . . . . .   12\n          2.1.6. SA Configuration . . . . . . . . . . . . . . .   14\n          2.1.7. UA Configuration . . . . . . . . . . . . . . .   14\n          2.1.8. Security   . . . . . . . . . . . . . . . . . .   15\n    2.2. Multihomed Machines. . . . . . . . . . . . . . . . . .   16\n    2.3. Serialized Registration File . . . . . . . . . . . . .   16",
      "raw": true
    },
    {
      "indent": 4,
      "text": "    2.4. Processing Serialized Registration and Configuration\n         Files  . . . . . . . . . . . . . . . . . . . . . . . .   18\n3. Binding Independent Implementation Considerations              18\n    3.1. Multithreading . . . . . . . . . . . . . . . . . . . .   18\n    3.2. Asynchronous and Incremental . . . . . . . . . . . . .   19\n    3.3. Type Checking for Service Types. . . . . . . . . . . .   19\n    3.4. Refreshing Registrations . . . . . . . . . . . . . . .   19\n    3.5. Configuration File Processing  . . . . . . . . . . . .   19\n    3.6. Attribute Types  . . . . . . . . . . . . . . . . . . .   20\n    3.7. Removal of Duplicates  . . . . . . . . . . . . . . . .   20\n    3.8. Character Set Encoding . . . . . . . . . . . . . . . .   20\n    3.9. Error Semantics  . . . . . . . . . . . . . . . . . . .   20\n   3.10. Modular Implementations  . . . . . . . . . . . . . . .   24\n   3.11. Handling Special Service Types . . . . . . . . . . . .   24\n   3.12. Scope Discovery and Handling . . . . . . . . . . . . .   24\n4. C Language Binding                                             25\n    4.1. Constant Types . . . . . . . . . . . . . . . . . . . .   26\n          4.1.1. URL Lifetimes. . . . . . . . . . . . . . . . .   26\n          4.1.2. Error Codes. . . . . . . . . . . . . . . . . .   26\n          4.1.3. SLPBoolean . . . . . . . . . . . . . . . . . .   27\n    4.2. Struct Types   . . . . . . . . . . . . . . . . . . . .   28\n          4.2.1. SLPSrvURL  . . . . . . . . . . . . . . . . . .   28\n          4.2.2. SLPHandle  . . . . . . . . . . . . . . . . . .   29\n    4.3. Callbacks  . . . . . . . . . . . . . . . . . . . . . .   29\n          4.3.1. SLPRegReport   . . . . . . . . . . . . . . . .   30\n          4.3.2. SLPSrvTypeCallback . . . . . . . . . . . . . .   30\n          4.3.3. SLPSrvURLCallback  . . . . . . . . . . . . . .   31\n          4.3.4. SLPAttrCallback  . . . . . . . . . . . . . . .   33\n    4.4. Opening and Closing an SLPHandle . . . . . . . . . . .   34\n          4.4.1. SLPOpen. . . . . . . . . . . . . . . . . . . .   34\n          4.4.2. SLPClose . . . . . . . . . . . . . . . . . . .   35\n    4.5. Protocol API   . . . . . . . . . . . . . . . . . . . .   36\n          4.5.1. SLPReg . . . . . . . . . . . . . . . . . . . .   36\n          4.5.2. SLPDereg . . . . . . . . . . . . . . . . . . .   37\n          4.5.3. SLPDelAttrs  . . . . . . . . . . . . . . . . .   38\n          4.5.4. SLPFindSrvTypes. . . . . . . . . . . . . . . .   39\n          4.5.5. SLPFindSrvs  . . . . . . . . . . . . . . . . .   41\n          4.5.6. SLPFindAttrs . . . . . . . . . . . . . . . . .   42\n    4.6. Miscellaneous Functions  . . . . . . . . . . . . . . .   43\n          4.6.1. SLPGetRefreshInterval  . . . . . . . . . . . .   44\n          4.6.2. SLPFindScopes  . . . . . . . . . . . . . . . .   44\n          4.6.3. SLPParseSrvURL . . . . . . . . . . . . . . . .   45\n          4.6.4. SLPEscape  . . . . . . . . . . . . . . . . . .   46\n          4.6.5. SLPUnescape  . . . . . . . . . . . . . . . . .   47\n          4.6.6. SLPFree  . . . . . . . . . . . . . . . . . . .   48\n          4.6.7. SLPGetProperty . . . . . . . . . . . . . . . .   48\n          4.6.8. SLPSetProperty . . . . . . . . . . . . . . . .   49\n    4.7. Implementation Notes   . . . . . . . . . . . . . . . .   49",
      "raw": true
    },
    {
      "indent": 3,
      "text": "           4.7.1. Refreshing Registrations . . . . . . . . . . .   49\n           4.7.2. Syntax for String Parameters . . . . . . . . .   49\n           4.7.3. Client Side Syntax Checking  . . . . . . . . .   50\n           4.7.4. System Properties  . . . . . . . . . . . . . .   50\n           4.7.5. Memory Management  . . . . . . . . . . . . . .   51\n           4.7.6. Asynchronous and Incremental Return Semantics.   51\n     4.8. Example. . . . . . . . . . . . . . . . . . . . . . . .   52\n 5. Java Language Binding                                          56\n     5.1. Introduction . . . . . . . . . . . . . . . . . . . . .   56\n     5.2. Exceptions and Errors  . . . . . . . . . . . . . . . .   56\n           5.2.1. Class ServiceLocationException . . . . . . . .   57\n     5.3. Basic Data Structures  . . . . . . . . . . . . . . . .   58\n           5.3.1. Interface ServiceLocationEnumeration . . . . .   58\n           5.3.2. Class ServiceLocationAttribute   . . . . . . .   58\n           5.3.3. Class ServiceType  . . . . . . . . . . . . . .   61\n           5.3.4. Class ServiceURL   . . . . . . . . . . . . . .   63\n     5.4. SLP Access Interfaces  . . . . . . . . . . . . . . . .   67\n           5.4.1. Interface Advertiser . . . . . . . . . . . . .   67\n           5.4.2. Interface Locator  . . . . . . . . . . . . . .   69\n     5.5. The Service Location Manager . . . . . . . . . . . . .   72\n           5.5.1. Class ServiceLocationManager . . . . . . . . .   72\n     5.6. Service Template Introspection . . . . . . . . . . . .   74\n           5.6.1. Abstract Class TemplateRegistry  . . . . . . .   74\n           5.6.2. Interface ServiceLocationAttributeVerifier . .   77\n           5.6.3. Interface ServiceLocationAttributeDescriptor .   79\n     5.7. Implementation Notes . . . . . . . . . . . . . . . . .   81\n           5.7.1. Refreshing Registrations . . . . . . . . . . .   81\n           5.7.2. Parsing Alternate Transports in ServiceURL . .   81\n           5.7.3. String Attribute Values  . . . . . . . . . . .   82\n           5.7.4. Client Side Syntax Checking. . . . . . . . . .   82\n           5.7.5. Language Locale Handling . . . . . . . . . . .   82\n           5.7.6. Setting SLP System Properties. . . . . . . . .   83\n           5.7.7. Multithreading . . . . . . . . . . . . . . . .   83\n           5.7.8. Modular Implementations  . . . . . . . . . . .   83\n           5.7.9. Asynchronous and Incremental Return Semantics.   84\n     5.8. Example. . . . . . . . . . . . . . . . . . . . . . . .   85\n 6. Internationalization Considerations                            87\n     6.1. service URL. . . . . . . . . . . . . . . . . . . . . .   87\n     6.2. Character Set Encoding . . . . . . . . . . . . . . . .   87\n     6.3. Language Tagging   . . . . . . . . . . . . . . . . . .   88\n 7. Security Considerations                                        88\n 8. Acknowledgements                                               88\n 9. References                                                     89\n10. Authors' Addresses                                             90\n11. Full Copyright Statement                                       91",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Service Location API is designed for standardized access to the Service Location Protocol (SLP). The APIs allow client and service programs to be be written or modified in a very simple manner to provide dynamic service discovery and selection. Bindings in the C and Java languages are defined in this document. In addition, standardized formats for configuration files and for serialized registration files are presented. These files allow SLP agents to configure network parameters, to register legacy services that have not been SLP enabled, and to portably exchange registration databases.",
      "ja": "サービスロケーションAPIは、サービスロケーションプロトコル（SLP）への標準化されたアクセスのために設計されています。 APIは、クライアントとサービスのプログラムが書かれたか、動的サービス発見と選択を提供することは非常に簡単な方法で変更することができるようにします。 CやJava言語のバインディングは、この文書で定義されています。また、設定ファイルのシリアライズ登録ファイルのための標準化されたフォーマットが提示されています。これらのファイルは、SLPエージェントは、SLPが有効になっていない、と可搬性登録データベースを交換する従来のサービスを登録するには、ネットワークパラメータを設定することができます。"
    },
    {
      "indent": 0,
      "text": "1.1. Goals",
      "section_title": true,
      "ja": "1.1。目標"
    },
    {
      "indent": 3,
      "text": "The overall goal of the API is to enable source portability of applications that use the API between different implementations of SLP. The result should facilitate the adoption of SLP, and conversion of clients and service programs to SLP.",
      "ja": "APIの全体的な目標は、SLPの異なる実装間のAPIを使用するアプリケーションのソースの移植を可能にするためです。結果は、SLPのクライアントとサービスプログラムのSLPの採用、および変換を容易にするはずです。"
    },
    {
      "indent": 3,
      "text": "The goals of the C binding are to create a minimal but complete access to the functionality of the SLP protocol, allowing for simple memory management and limited code size.",
      "ja": "バインディングCの目標は単純なメモリ管理と制限されたコードサイズを考慮して、SLPプロトコルの機能への最小限のが、完全なアクセスを作成することです。"
    },
    {
      "indent": 3,
      "text": "The Java API provides for modular implementations (where unneeded features can be omitted) and an object oriented interface to the complete set of SLP data and functionality.",
      "ja": "Java APIは、（不必要な機能を省略することができる）モジュラー実装とSLPデータおよび機能の完全なセットに対するオブジェクト指向インタフェースを提供します。"
    },
    {
      "indent": 3,
      "text": "The standardized configuration file and serialized file formats provide a simple syntax with complete functional coverage of the protocol, but without system dependent properties and secure information.",
      "ja": "標準化されたコンフィギュレーションファイルとシリアライズファイルフォーマットは、プロトコルの完全な機能カバレッジを持つ単純な構文を提供するが、システム依存特性と安全な情報がありません。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2。用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [1].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119に記載されるように解釈される[1]。"
    },
    {
      "indent": 6,
      "text": "Service Location Protocol (SLP)",
      "ja": "サービス・ロケーション・プロトコル（SLP）"
    },
    {
      "indent": 9,
      "text": "The underlying protocol allowing dynamic and scalable service discovery. This protocol is specified in the Service Location Protocol Version 2 [7].",
      "ja": "ダイナミックかつスケーラブルなサービスの発見が可能になるプロトコル。このプロトコルは、サービスロケーションプロトコルバージョン2で指定されている[7]。"
    },
    {
      "indent": 6,
      "text": "SLP framework",
      "ja": "SLPのフレームワーク"
    },
    {
      "indent": 9,
      "text": "When a 'Service Location framework' is mentioned, it refers to both the SLP implementation and interface implementation; i.e. whatever provides the SLP functionality to user level programs. This includes remote agents.",
      "ja": "「サービスロケーションフレームワーク」が記載されている場合、それは、SLPの実装およびインタフェースの実装の両方を指します。すなわち、ユーザレベルプログラムへSLP機能を提供どの。これは、リモートエージェントが含まれています。"
    },
    {
      "indent": 6,
      "text": "Directory Agent (DA)",
      "ja": "ディレクトリエージェント（DA）"
    },
    {
      "indent": 9,
      "text": "A service that automatically gathers service advertisements from SAs in order to provide them to UAs.",
      "ja": "自動のUAにそれらを提供するために、SAのからサービスの広告を収集したサービス。"
    },
    {
      "indent": 6,
      "text": "User Agent (UA)",
      "ja": "ユーザーエージェント（UA）"
    },
    {
      "indent": 9,
      "text": "This is the Service Location process or library that allows SLP requests to be made on behalf of a client process. UAs automatically direct requests to DAs when they exist. In their absence, UAs make requests to SAs.",
      "ja": "これは、SLP要求がクライアントプロセスに代わって行うことを可能にするサービスロケーションプロセスまたはライブラリです。 DAのへのUA自動的に直接要求が存在します。彼らの不在では、UAはSAのに要求を行います。"
    },
    {
      "indent": 6,
      "text": "Service Agent (SA)",
      "ja": "サービスエージェント（SA）"
    },
    {
      "indent": 9,
      "text": "This is the Service Location process or library that allows service software to register and deregister itself with the SLP framework. SAs respond to UA service requests, detect DAs and register service advertisements with them.",
      "ja": "これは、サービスソフトウェアは、SLPのフレームワークに自身を登録し、登録解除することを可能にするサービスロケーションプロセスまたはライブラリです。 SAは、UAのサービス要求に応答DAを検出し、それらをサービス通知を登録します。"
    },
    {
      "indent": 6,
      "text": "SA Server",
      "ja": "SAサーバー"
    },
    {
      "indent": 9,
      "text": "Many operating system platforms only allow a single process to listen on a particular port number. Since SAs are required to listen on a multicast address for SLP service requests, implementations of the SLP framework on such platforms that want to support multiple SAs on one machine need to arrange for a single process to do the listening while the advertising SAs communicate with that process through another mechanism. The single listening process is called an SA server. SA servers share many characteristics with DAs, but they are not the same.",
      "ja": "多くのオペレーティング・システム・プラットフォームは、単一のプロセスが特定のポート番号をリッスンすることができます。 SAはSLPサービス要求のためのマルチキャストアドレスをリッスンするために必要とされているので、1つのマシン上で複数のSAをサポートしたいようなプラットフォーム上のSLPのフレームワークの実装では、広告のSAは、それと通信しながら、1つのプロセスがリスニングを行うための手配をする必要があります別の機構を介してのプロセス。単一のリスニングプロセスは、SAサーバーと呼ばれています。 SAサーバは、DASと多くの特徴を共有し、彼らは同じではありません。"
    },
    {
      "indent": 6,
      "text": "Service Advertisement",
      "ja": "サービス広告"
    },
    {
      "indent": 9,
      "text": "A URL possibly combined with service attributes. These are made available to UAs by SAs, either directly or via a DA.",
      "ja": "URLはおそらくサービス属性と組み合わせます。これらは、直接またはDAを経由して、SAのでのUAに利用できるようになります。"
    },
    {
      "indent": 6,
      "text": "Locale",
      "ja": "ローカル"
    },
    {
      "indent": 9,
      "text": "The language localization that applies to strings passed into or returned from the SLP API. The Locale is expressed using a Language Tag [6]. All attribute strings are associated with a",
      "ja": "文字列に渡されたか、SLPのAPIから返されるに適用される言語ローカリゼーション。ロケールは、言語タグを使用して表現される[6]。すべての属性の文字列が関連付けられています"
    },
    {
      "indent": 9,
      "text": "particular locale. The locale is completely orthogonal to the ANSI C locale. The SLP locale is mapped into the Java locale in the Java API.",
      "ja": "特定のロケール。ロケールは、ANSI Cロケールに完全に直交しています。 SLPのロケールは、Java APIのJavaロケールにマッピングされています。"
    },
    {
      "indent": 6,
      "text": "Service Template",
      "ja": "サービステンプレート"
    },
    {
      "indent": 9,
      "text": "A document that describes the syntax of the URL for a given service type and a definition of all service attributes including the meaning, defaults, and constraints on values the attributes may take. See [8] for more information on service templates.",
      "ja": "指定されたサービスの種類と属性が取り得る値の意味は、デフォルト、および制約を含むすべてのサービス属性の定義については、URLの構文を記述した文書。サービステンプレートの詳細については、[8]を参照してください。"
    },
    {
      "indent": 6,
      "text": "The service: URL",
      "ja": "サービス：URL"
    },
    {
      "indent": 9,
      "text": "A service of a particular type announces its availability with a service: URL that includes its service access point (domain name or IP address, and possibly its port number) and optionally basic configuration parameters. The syntax of the service: URL is defined in the service template. Other URL's can be used in service advertisements if desired.",
      "ja": "そのサービス・アクセス・ポイント（ドメイン名またはIPアドレス、およびおそらくそのポート番号）と、必要に応じて基本的な設定パラメータを含むURL：特定のタイプのサービスは、サービスとの可用性を発表しました。サービスの構文：URLは、サービステンプレートで定義されています。必要に応じて他のURLのは、サービスの広告に使用することができます。"
    },
    {
      "indent": 6,
      "text": "Service Attributes",
      "ja": "サービス属性"
    },
    {
      "indent": 9,
      "text": "The attributes associated with a given service. The values that can be assigned to service attributes are defined by the service template.",
      "ja": "特定のサービスに関連付けられた属性。サービスの属性に割り当てることができる値は、サービステンプレートで定義されています。"
    },
    {
      "indent": 6,
      "text": "Scope",
      "ja": "範囲"
    },
    {
      "indent": 9,
      "text": "A string used to control the availability of service advertisements. Every SLP Agent is configured with one or more scope strings. Scopes are assigned by site administrators to group services for many purposes, but chiefly as a means of scalability. DAs store only services advertised having a scope string matching the scopes with which they are configured.",
      "ja": "サービス通知の可用性を制御するために使用される文字列。すべてのSLPエージェントは、一つ以上のスコープの文字列で構成されています。スコープはなく、主にスケーラビリティの手段として、多くの目的のためにグループのサービスへのサイトの管理者によって割り当てられます。 DAをストアのみサービスは、それらが構成されているとスコープにマッチ範囲文字列を有するアドバタイズ。"
    },
    {
      "indent": 6,
      "text": "Naming Authority (NA)",
      "ja": "命名オーソリティ（NA）"
    },
    {
      "indent": 9,
      "text": "This is a 'suffix' to the service type string. It completely changes the meaning of the service type. NAs are used for private definitions of well known Service Types and experimental Service Type extensions. The default NA is \"IANA\", which must not be explicitly included. Service types with the IANA naming authority are registered with the Internet Assigned Numbers Authority (see [8] for more information on the registration procedure).",
      "ja": "これは、サービスタイプ文字列に「接尾辞」です。それは完全にサービスタイプの意味を変更します。 NASはよく知られているサービスのタイプと実験的サービスタイプの拡張のプライベートな定義のために使用されています。デフォルトのNAは、明示的に含めてはならない「IANA」、です。 IANAの命名権限を持つサービスの種類は、Internet Assigned Numbers機関（登録手続きの詳細については、[8]を参照）に登録されています。"
    },
    {
      "indent": 0,
      "text": "2. File Formats",
      "section_title": true,
      "ja": "2.ファイル形式"
    },
    {
      "indent": 3,
      "text": "This section describes the configuration and serialized registration file formats. Both files are defined in the UTF-8 character set [3].",
      "ja": "このセクションでは、構成、およびシリアル化された登録ファイル形式について説明します。どちらのファイルは、UTF-8文字セットで定義されている[3]。"
    },
    {
      "indent": 3,
      "text": "Attribute tags and values in the serialized registration file require SLP reserved characters to be escaped. The SLP reserved characters are `(', `)', `,', `\\', `!', `<', `=', `>', `~' and control characters (characters with UTF codes less than 0x0020 and the character 0x007f, which is US-ASCII DEL). The escapes are formed exactly as for the wire protocol, i.e. a backslash followed by two hex digits representing the character. For example, the escape for ' ,' is '\\2c'. In addition, the characters `\\n', `\\r', `\\t', and `_' are prohibited from attribute tags by the SLP wire syntax grammar. [7]",
      "ja": "シリアル化された登録ファイル内のタグと値がSLPをエスケープする文字を予約必要属性。 SLPの予約文字は `（ '`）'、 `、 '` \\'、 `！ '` <'、 `= '`>'、 `〜」と制御文字（未満UTFコードを持つ文字0x0020に及びUS-ASCII DEL）である文字0x007f、。エスケープは、すなわち文字を表す2進数字が続くバックスラッシュ、正確にワイヤプロトコル用として形成されています。例えば、脱出のための「」「\\ 2cを」です。また、文字 `\\ n 'は、` \\ rを'、 `\\ tの 'と` _' のSLPワイヤ構文文法によって属性タグが禁止されています。 [7]"
    },
    {
      "indent": 3,
      "text": "In serialized registration files, escaped strings beginning with `\\ff`, an encoding for a nonUTF-8 character, are treated as opaques. Exactly as in the wire protocol, syntactically correct opaque encodings consist of a string beginning with `\\ff` and containing *only* escaped characters that are transformed to bytes. Such strings are only syntactically correct in the serialized registration file as attribute values. In other cases, whenever an escape is encountered and the character is not an SLP reserved character, an error is signaled.",
      "ja": "シリアル化された登録ファイルでは、 `\\ ff`、nonUTF-8文字のエンコーディングで始まる文字列をエスケープし、opaquesとして扱われます。正確にワイヤプロトコルのように、構文的に正しい不透明なエンコーディングは `\\のff`で始まり、バイトに変換されている*だけ*エスケープ文字を含む文字列で構成されています。このような文字列は、属性値としてシリアライズされた登録ファイルにのみ構文的に正しいです。他の例では、エスケープが発生した文字がSLP予約文字ではありませんされるたびに、エラーが通知されます。"
    },
    {
      "indent": 3,
      "text": "Escaped characters in URLs in serialized registration files use the URL escape convention. [2].",
      "ja": "シリアライズ登録ファイル内のURLでエスケープ文字はURLエスケープ規則を使用しています。 [2]。"
    },
    {
      "indent": 3,
      "text": "Property names and values in the configuration file have a few reserved characters that are involved in file's lexical definition. The characters '.' and '=' are reserved in property names and must be escape. The characters ',', '(', and ')' are reserved in property values and must be escaped. In addition, scope names in the net.slp.useScopes property use the SLP wire format escape convention for SLP reserved characters. This simplifies implementation, since the same code can be used to unescape scope names as is used in processing the serialized registration file or for formatting wire messages.",
      "ja": "設定ファイルのプロパティ名と値は、ファイルの字句の定義に関与しているいくつかの予約文字を持っています。キャラクター '。'そして、「=」プロパティ名に予約されており、エスケープする必要があります。文字「」、 『（』と 『）』プロパティの値に予約されており、エスケープする必要があります。また、のnet.slp.useScopesプロパティ使用中のスコープ名SLPについてSLPワイヤ形式のエスケープ規則は、文字を禁じます。同じコードがシリアル登録ファイルを処理する際に、またはワイヤ・メッセージをフォーマットするために使用されるスコープ名をエスケープ解除するために使用することができるので、これは、実装を簡素化します。"
    },
    {
      "indent": 3,
      "text": "On platforms that only support US-ASCII and not UTF-8, the upper bit of bytes incoming from the configuration and registration files determines whether the character is US-ASCII or not US-ASCII. According to the standard UTF-8 encoding, the upper bit is zero if the character is US-ASCII and one if the character is multibyte and thus not US-ASCII. Platforms without intrinsic UTF-8 support are required to parse the multibyte character and store it in an appropriate internal format. Support for UTF-8 is required to implement the SLP protocol (see [7]), and can therefore be used in file processing as well.",
      "ja": "唯一のUS-ASCIIではなくUTF-8をサポートするプラットフォームでは、コンフィギュレーションファイルと登録ファイルから着信バイトの上位ビットは、文字がUS-ASCIIかUS-ASCIIであるか否かを判断します。文字はUS-ASCIIのマルチバイトであるため、ない場合は文字がUS-ASCIIと1であれば、標準のUTF-8エンコーディングによると、上位ビットがゼロです。本来のUTF-8サポートしていないプラットフォームは、マルチバイト文字を解析し、適切な内部フォーマットに保管する必要があります。 UTF-8のサポートは（[7]を参照）SLPプロトコルを実装する必要があるので、同様にファイルの処理に使用することができます。"
    },
    {
      "indent": 3,
      "text": "The location and name of the configuration file is system-dependent, but implementations of the API are encouraged to locate it together with other configuration files and name it consistently.",
      "ja": "設定ファイルの場所と名前はシステムに依存しますが、APIの実装は、他の設定ファイルと一緒にそれを見つけて、それを一貫して名前を付けることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "2.1. Configuration File Format",
      "section_title": true,
      "ja": "2.1。設定ファイルの形式"
    },
    {
      "indent": 3,
      "text": "The configuration file format consists of a newline delimited list of zero or more property definitions. Each property definition corresponds to a particular configurable SLP, network, or other parameter in one or more of the three SLP agents. The file format grammar in ABNF [5] syntax is:",
      "ja": "設定ファイルの形式は、ゼロ個以上のプロパティ定義の改行区切りのリストで構成されています。各プロパティの定義は、三SLP剤の一つ以上の特定の構成SLP、ネットワーク、または他のパラメータに相当します。 ABNFでのファイル形式の文法[5]構文は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "config-file = line-list line-list = line / line line-list line = property-line / comment-line comment-line = ( \"#\" / \";\" ) 1*allchar newline property-line = property newline property = tag \"=\" value-list tag = prop / prop \".\" tag prop = 1*tagchar value-list = value / value \",\" value-list value = int / bool / \"(\" value-list \")\" / string int = 1*DIGIT bool = \"true\" / \"false\" / \"TRUE\" / \"FALSE\" newline = CR / ( CRLF ) string = 1*stringchar tagchar = DIGIT / ALPHA / tother / escape tother = %x21-%x2d / %x2f / %x3a / %x3c-%x40 / %x5b-%x60 / %7b-%7e ; i.e., all characters except `.', ; and `='. stringchar = DIGIT / ALPHA / sother / escape sother = %x21-%x29 / %x2a-%x2b / %x2d-%x2f / %x3a-%x40 / %x5b-%x60 / %7b-%7e ; i.e., all characters except `,' allchar = DIGIT / ALPHA / HTAB / SP escape = \"\\\" HEXDIG HEXDIG ; Used for reserved characters",
      "ja": "設定ファイル=ラインリストラインリスト=行/ラインラインリストライン=プロパティ行/コメント行コメント行=（「＃」/「;」）1 * allchar改行プロパティライン=プロパティ改行プロパティ=タグ「=」値リストタグ=小道具/小道具「」タグプロップ= 1 * tagchar値リスト=値/値 \"\" 値リスト値= INT / BOOL / \"（\" 値リスト \"）\" /文字列はint = 1 * DIGITブール値= \"true\" を/ \"偽\" / \"TRUE\" / \"FALSE\" 改行= CR /（CRLF）文字列= 1 * stringchar tagchar = DIGIT / ALPHA / tother / totherエスケープ=％x21-％x2d /％x2f /％X3A /％x3c-％X40 /％ x5b-％X60 /％7b-％7E。すなわち、 `除く '、すべての文字。そして、 `=」。 stringchar = DIGIT / ALPHA / sother / sother =％x21-％X29 /％x2a-％X2B /％x2d-％x2f /％x3a-％X40 /％x5b-％X60 /％7b-％7E逃げます。すなわち、 `」allchar = DIGIT / ALPHA / HTAB / SPエスケープを除くすべての文字= \"\\\" HEXDIG HEXDIG。予約文字のために使用されます"
    },
    {
      "indent": 3,
      "text": "With the exception of net.slp.useScopes, net.slp.DAAddresses, and net.slp.isBroadcastOnly, all other properties can be changed through property accessors in the C and Java APIs. The property accessors only change the property values in the running agent program and do not affect the values in the configuration file. The net.slp.useScopes and net.slp.DAAddresses properties are read-only because they control the agent's view of the scopes and DAs and are therefore critical to the function of the API scope discovery algorithm. Attempts to modify them are unlikely to yield productive results, and could harm the ability of the agent to find scopes and use DAs. The net.slp.isBroadcastOnly property is read-only because the API library needs to configure networking upon start up and changing this property might invalidate the configuration. Whether the local network uses broadcast or multicast is not likely to change during the course of the program's execution.",
      "ja": "net.slp.useScopes、net.slp.DAAddresses、及びに従って、net.slp.isBroadcastOnlyを除いて、他のすべてのプロパティは、CおよびJava APIの中にプロパティアクセサを介して変更することができます。プロパティアクセサのみが実行されているエージェントプログラム内のプロパティ値を変更すると、構成ファイル内の値に影響を与えません。 net.slp.useScopesとnet.slp.DAAddressesプロパティは読み取り専用で、彼らはスコープおよびDASのエージェントの表示を制御し、したがって、APIスコープ発見アルゴリズムの機能に重要であるため。それらを修正しようとすると、生産的な結果をもたらす可能性は低い、とスコープを見つけて、DAを使用する薬剤の能力に悪影響を及ぼす可能性があります。 net.slp.isBroadcastOnlyプロパティは読み取り専用で起動して、このプロパティを変更すると、設定を無効にする可能性がある時にAPIライブラリは、ネットワークを構成する必要があるため。ローカルネットワークがブロードキャストやマルチキャストを使用するかどうかは、プログラムの実行の過程で変更される可能性が低いです。"
    },
    {
      "indent": 3,
      "text": "The properties break down into the following subsections describes an area and its properties.",
      "ja": "プロパティは、以下のサブセクションに分解地区とそのプロパティについて説明します。"
    },
    {
      "indent": 0,
      "text": "2.1.1. DA configuration",
      "section_title": true,
      "ja": "2.1.1。 DA設定"
    },
    {
      "indent": 3,
      "text": "Important configuration properties for DAs are included in this section. These are:",
      "ja": "DASの重要な構成プロパティは、このセクションに含まれています。これらは："
    },
    {
      "indent": 6,
      "text": "net.slp.isDA",
      "ja": "net.slp.isDA"
    },
    {
      "indent": 9,
      "text": "A boolean indicating if the SLP server is to act as a DA. If false, not run as a DA. Default is false.",
      "ja": "SLPサーバがDAとして機能するかどうかを示すboolean。 falseの場合、DAとして実行されません。デフォルトはfalseです。"
    },
    {
      "indent": 6,
      "text": "net.slp.DAHeartBeat",
      "ja": "net.slp.DAHeartbeat"
    },
    {
      "indent": 9,
      "text": "A 32 bit integer giving the number of seconds for the DA heartbeat. Default is 3 hours (10800 seconds). This property corresponds to the protocol specification parameter CONFIG_DA_BEAT [7]. Ignored if isDA is false.",
      "ja": "DAハートビートの秒数を与える32ビットの整数。デフォルトは3時間（10800秒）です。このプロパティは、プロトコル指定パラメータCONFIG_DA_BEAT [7]に相当します。 ISDAがfalseの場合は無視されます。"
    },
    {
      "indent": 6,
      "text": "net.slp.DAAttributes",
      "ja": "net.slp.DAAttributes"
    },
    {
      "indent": 9,
      "text": "A comma-separated list of parenthesized attribute/value list pairs that the DA must advertise in DAAdverts. The property must be in the SLP attribute list wire format, including escapes for reserved characters. [7]",
      "ja": "DAはDAAdvertsに広告を掲載しなければならないことを、括弧内の属性/値リストのペアのコンマ区切りのリスト。プロパティは、予約文字のエスケープを含め、SLP属性一覧ワイヤー形式でなければなりません。 [7]"
    },
    {
      "indent": 0,
      "text": "2.1.2. Static Scope Configuration",
      "section_title": true,
      "ja": "2.1.2。静的スコープ構成"
    },
    {
      "indent": 3,
      "text": "These properties allow various aspects of scope handling to be configured.",
      "ja": "これらのプロパティは、スコープの取り扱いのさまざまな側面を設定することを可能にします。"
    },
    {
      "indent": 6,
      "text": "net.slp.useScopes",
      "ja": "net.slp.useScopes"
    },
    {
      "indent": 9,
      "text": "A value-list of strings indicating the only scopes a UA or SA is allowed to use when making requests or registering, or the scopes a DA must support. If not present for the DA and SA, then in the absence of scope information from DHCP, the default scope \"DEFAULT\" is used. If not present for the UA, and there is no scope information available from DHCP, then the user scoping model is in force. Active and passive DA discovery or SA discovery are used for scope discovery, and the scope \"DEFAULT\" is used if no other information is available. If a DA or SA gets another scope in a request, a SCOPE_NOT_SUPPORTED error should be returned, unless the request was multicast, in which case it should be dropped. If a DA gets another scope in a registration, a SCOPE_NOT_SUPPORTED error must be returned. Unlike other properties, this property is \"read-only\", so attempts to change it after the configuration file has been read are ignored. See Section 3.12 for the algorithm the API uses in determining what scope information to present.",
      "ja": "のみを示す文字列の値リストは、UAスコープまたはSAが要求を行うか、登録、またはDAがサポートしなければならないスコープときに使用することが許可されています。 DAとSAのため、その後、DHCPからスコープ情報がない場合に存在しない場合は、デフォルトのスコープ「DEFAULT」が使用されます。 UAのために提示し、DHCPから利用可能な範囲の情報がないではない場合は、ユーザーのスコープモデルは力です。アクティブおよびパッシブDAの発見やSAの発見は、スコープの発見のために使用され、他の情報が利用できない場合はスコープ「DEFAULT」が使用されます。 DAまたはSAが要求に別のスコープを取得した場合、要求がマルチキャストでない限り、SCOPE_NOT_SUPPORTEDエラーは、それがドロップされるべき場合には、返されるべきです。 DAは登録に別のスコープを取得した場合、SCOPE_NOT_SUPPORTED誤りを返さなければなりません。設定ファイルが読み込まれた後にそれを変更しようとする試みは無視されるように、他のプロパティとは異なり、このプロパティは、「読み取り専用」です。 APIは、スコープ情報が存在するかを決定する際に使用するアルゴリズムについては、セクション3.12を参照してください。"
    },
    {
      "indent": 6,
      "text": "net.slp.DAAddresses",
      "ja": "net.slp.DAAddresses"
    },
    {
      "indent": 9,
      "text": "A value-list of IP addresses or DNS resolvable host names giving the SLPv2 DAs to use for statically configured UAs and SAs. Ignored by DAs (unless the DA is also an SA server). Default is none. Unlike other properties, this property is \"read-only\", so attempts to change it after the configuration file has been read are ignored.",
      "ja": "IPアドレスまたは静的に設定さUAとSAに使用するSLPv2のDAを与えるDNS解決可能なホスト名の値リスト。 DAの（DAもSAサーバでない限り）によって無視されます。デフォルトはnoneです。設定ファイルが読み込まれた後にそれを変更しようとする試みは無視されるように、他のプロパティとは異なり、このプロパティは、「読み取り専用」です。"
    },
    {
      "indent": 9,
      "text": "The following grammar describes the property:",
      "ja": "次の文法は、プロパティについて説明します。"
    },
    {
      "indent": 15,
      "text": "addr-list     =  addr / addr \",\" addr-list\naddr          =  fqdn / hostnumber\nfqdn          =  ALPHA / ALPHA *[ anum / \"-\" ] anum\nanum          =  ALPHA / DIGIT\nhostnumber    =  1*3DIGIT 3(\".\" 1*3DIGIT)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "An example is:",
      "ja": "例は次のとおりです。"
    },
    {
      "indent": 16,
      "text": "sawah,mandi,sambal",
      "ja": "フィールド、シャワー、サンバル"
    },
    {
      "indent": 9,
      "text": "IP addresses can be used instead of host names in networks where DNS is not deployed, but network administrators are reminded that using IP addresses will complicate machine renumbering, since the SLP configuration property files in statically configured networks will have to be changed. Similarly, if host names are used, implementors must be careful that a name service is available before SLP starts, in other words, SLP cannot be used to find the name service.",
      "ja": "IPアドレスは、DNSが展開されていませんが、ネットワーク管理者は、静的に設定されたネットワークのSLPの構成プロパティファイルを変更する必要がありますので、IPアドレスを使用すると、マシンのリナンバリングが複雑になることを思い出しているネットワーク内のホスト名の代わりに使用することができます。ホスト名が使用されている場合は同様に、実装者はSLPを開始する前にネームサービスが利用可能であることに注意しなければならない、つまり、SLPは、ネームサービスを見つけるために使用することはできません。"
    },
    {
      "indent": 0,
      "text": "2.1.3. Tracing and Logging",
      "section_title": true,
      "ja": "2.1.3。トレースおよびログ"
    },
    {
      "indent": 3,
      "text": "This section allows tracing and logging information to be printed by the various agents.",
      "ja": "このセクションでは、様々な薬剤によって印刷される情報を追跡し、ロギングができます。"
    },
    {
      "indent": 6,
      "text": "net.slp.traceDATraffic",
      "ja": "net.slp.traceDATraffic"
    },
    {
      "indent": 9,
      "text": "A boolean controlling printing of messages about traffic with DAs. Default is false.",
      "ja": "DASとトラフィックに関するメッセージの出力を制御するブール値。デフォルトはfalseです。"
    },
    {
      "indent": 6,
      "text": "net.slp.traceMsg",
      "ja": "net.slp.traceMsg"
    },
    {
      "indent": 9,
      "text": "A boolean controlling printing of details on SLP messages. The fields in all incoming messages and outgoing replies are printed. Default is false.",
      "ja": "SLPメッセージについての詳細の印刷を制御するブール値。すべての受信メッセージと発信回答のフィールドが印刷されています。デフォルトはfalseです。"
    },
    {
      "indent": 6,
      "text": "net.slp.traceDrop",
      "ja": "net.slp.traceDrop"
    },
    {
      "indent": 9,
      "text": "A boolean controlling printing details when a SLP message is dropped for any reason. Default is false.",
      "ja": "SLPメッセージが何らかの理由でドロップされたときに、印刷の詳細を制御するブール値。デフォルトはfalseです。"
    },
    {
      "indent": 6,
      "text": "net.slp.traceReg",
      "ja": "net.slp.traceReg"
    },
    {
      "indent": 9,
      "text": "A boolean controlling dumps of all registered services upon registration and deregistration. If true, the contents of the DA or SA server are dumped after a registration or deregistration occurs. Default is false.",
      "ja": "登録および登録解除の際に登録されているすべてのサービスのダンプを制御するブール値。 trueの場合、DAまたはSAサーバーの内容は、登録または登録解除が発生した後にダンプされます。デフォルトはfalseです。"
    },
    {
      "indent": 0,
      "text": "2.1.4. Serialized Proxy Registrations",
      "section_title": true,
      "ja": "2.1.4。直列化されたプロキシ登録"
    },
    {
      "indent": 3,
      "text": "These properties control the reading and writing of serialized registrations.",
      "ja": "これらのプロパティは、シリアライズされた登録の読み書きを制御します。"
    },
    {
      "indent": 6,
      "text": "net.slp.serializedRegURL",
      "ja": "net.slp.serializedRegURL"
    },
    {
      "indent": 9,
      "text": "A string containing a URL pointing to a document containing serialized registrations that should be processed when the DA or SA server starts up. Default is none.",
      "ja": "DAまたはSAサーバーの起動時に処理されなければならないシリアライズされた登録を含む文書を指すURLを含む文字列。デフォルトはnoneです。"
    },
    {
      "indent": 0,
      "text": "2.1.5. Network Configuration Properties",
      "section_title": true,
      "ja": "2.1.5。ネットワークの構成プロパティ"
    },
    {
      "indent": 3,
      "text": "The properties in this section allow various network configuration properties to be set.",
      "ja": "このセクションの特性は、様々なネットワーク構成プロパティを設定することを可能にします。"
    },
    {
      "indent": 6,
      "text": "net.slp.isBroadcastOnly",
      "ja": "net.slp.isBroadcastOnly"
    },
    {
      "indent": 9,
      "text": "A boolean indicating if broadcast should be used instead of multicast. Like the net.slp.useScopes and net.slp.DAAddresses properties, this property is \"read-only\", so attempts to change it after the configuration file has been read are ignored. Default is false.",
      "ja": "ブロードキャストではなくマルチキャストの使用されるべきかどうかを示すブール値。設定ファイルが読み込まれた後にそれを変更しようとする試みは無視されるようにのnet.slp.useScopesとnet.slp.DAAddressesプロパティと同様に、このプロパティは、「読み取り専用」です。デフォルトはfalseです。"
    },
    {
      "indent": 6,
      "text": "net.slp.passiveDADetection",
      "ja": "net.slp.passiveDADetection"
    },
    {
      "indent": 9,
      "text": "A boolean indicating whether passive DA detection should be used. Default is true.",
      "ja": "パッシブDA検出を使用すべきかどうかを示すブール。デフォルトはtrueです。"
    },
    {
      "indent": 6,
      "text": "net.slp.multicastTTL",
      "ja": "net.slp.multicast TTL"
    },
    {
      "indent": 9,
      "text": "A positive integer less than or equal to 255, giving the multicast TTL. Default is 255.",
      "ja": "マルチキャストTTLを与える未満または255に等しい正の整数であり、。デフォルトは255です。"
    },
    {
      "indent": 6,
      "text": "net.slp.DAActiveDiscoveryInterval",
      "ja": "net.slp.DAActiveDiscoveryInterval"
    },
    {
      "indent": 9,
      "text": "A 16 bit positive integer giving the number of seconds between DA active discovery queries. Default is 900 seconds (15 minutes). This property corresponds to the protocol specification parameter CONFIG_DA_FIND [7]. If the property is set to zero, active discovery is turned off. This is useful when the DAs available are explicitly restricted to those obtained from DHCP or the net.slp.DAAddresses property.",
      "ja": "DAの能動的検出クエリー間の秒数を与える16ビットの正の整数。デフォルトは900秒（15分）です。このプロパティは、プロトコル指定パラメータCONFIG_DA_FIND [7]に相当します。プロパティをゼロに設定されている場合は、アクティブな発見がオフになっています。利用可能DAのが明示的にDHCPまたはnet.slp.DAAddressesプロパティから取得したものに限定されている場合に便利です。"
    },
    {
      "indent": 6,
      "text": "net.slp.multicastMaximumWait",
      "ja": "net.slp.multicastMaximumWait"
    },
    {
      "indent": 9,
      "text": "A 32 bit integer giving the maximum amount of time to perform multicast, in milliseconds. Default is 15000 ms (15 sec.). This property corresponds to the CONFIG_MC_MAX parameter in the protocol specification [7].",
      "ja": "ミリ秒単位で、マルチキャストを実行する時間の最大量を与える32ビットの整数。デフォルトは15000ミリ秒（15秒）。このプロパティは、プロトコル仕様[7]におけるCONFIG_MC_MAXパラメータに相当します。"
    },
    {
      "indent": 6,
      "text": "net.slp.multicastTimeouts",
      "ja": "net.slp.multicastTimeouts"
    },
    {
      "indent": 9,
      "text": "A value-list of 32 bit integers used as timeouts, in milliseconds, to implement the multicast convergence algorithm. Each value specifies the time to wait before sending the next request, or until nothing new has been learned from two successive requests. Default is: 3000,3000,3000,3000,3000. In a fast network the aggressive values of 1000,1250,1500,2000,4000 allow better performance. This property corresponds to the CONFIG_MC_RETRY parameter in the protocol specification [7]. Note that the net.slp.DADiscoveryTimeouts property must be used for active DA discovery.",
      "ja": "32ビット整数の値リストは、マルチキャスト収束アルゴリズムを実装するために、ミリ秒単位のタイムアウトとして使用します。各値は次の要求を送信する前に、または二つの連続要求から学習された新しい何もするまで待機する時間を指定します。デフォルトは：3000,3000,3000,3000,3000。高速ネットワークでは1000,1250,1500,2000,4000の積極的な値は、優れたパフォーマンスを可能にします。このプロパティは、プロトコル仕様[7]におけるCONFIG_MC_RETRYパラメータに相当します。 net.slp.DADiscoveryTimeoutsプロパティは、アクティブなDA発見のために使用されなければならないことに注意してください。"
    },
    {
      "indent": 6,
      "text": "net.slp.DADiscoveryTimeouts",
      "ja": "net.slp.DADiscoveryTimeouts"
    },
    {
      "indent": 9,
      "text": "A value-list of 32 bit integers used as timeouts, in milliseconds, to implement the multicast convergence algorithm during active DA discovery. Each value specifies the time to wait before sending the next request, or until nothing new has been learned from two successive requests. This property corresponds to the protocol specification parameter CONFIG_RETRY [7]. Default is: 2000,2000,2000,2000,3000,4000.",
      "ja": "アクティブDA検出時にマルチキャスト収束アルゴリズムを実装するために、ミリ秒単位のタイムアウトとして使用される32ビット整数の値リスト。各値は次の要求を送信する前に、または二つの連続要求から学習された新しい何もするまで待機する時間を指定します。このプロパティは、プロトコル指定パラメータCONFIG_RETRY [7]に相当します。デフォルトは：2000,2000,2000,2000,3000,4000。"
    },
    {
      "indent": 6,
      "text": "net.slp.datagramTimeouts",
      "ja": "net.slp.datagramTimeouts"
    },
    {
      "indent": 9,
      "text": "A value-list of 32 bit integers used as timeouts, in milliseconds, to implement unicast datagram transmission to DAs. The nth value gives the time to block waiting for a reply on the nth try to contact the DA. The sum of these values is the protocol specification property CONFIG_RETRY_MAX [7].",
      "ja": "32ビット整数の値リストは、DASへのユニキャストデータグラムの送信を実現するために、ミリ秒単位のタイムアウトとして使用します。 n番目の値はDAに連絡するn番目の試みで返事を待ってブロックする時間を与えます。これらの値の和は、プロトコル仕様プロパティCONFIG_RETRY_MAXである[7]。"
    },
    {
      "indent": 6,
      "text": "net.slp.randomWaitBound",
      "ja": "net.slp.randomWaitBound"
    },
    {
      "indent": 9,
      "text": "A 32 bit integer giving the maximum value for all random wait parameters, in milliseconds. Default is 1000 (1 sec.). This value corresponds to the protocol specification parameters CONFIG_START_WAIT, CONFIG_REG_PASSIVE, and CONFIG_REG_ACTIVE [7].",
      "ja": "ミリ秒単位で、全てのランダム待機パラメータの最大値を与える32ビットの整数。デフォルトは1000（1秒）です。この値は、[7]プロトコル仕様パラメータCONFIG_START_WAIT、CONFIG_REG_PASSIVE、及びCONFIG_REG_ACTIVEに相当します。"
    },
    {
      "indent": 6,
      "text": "net.slp.MTU",
      "ja": "net.slp.MTU"
    },
    {
      "indent": 9,
      "text": "A 16 bit integer giving the network packet MTU, in bytes. This is the maximum size of any datagram to send, but the implementation might receive a larger datagram. The maximum size includes IP, and UDP or TCP headers. Default is 1400.",
      "ja": "バイトで、ネットワークパケットMTUを付与する16ビット整数。これは、送信するすべてのデータグラムの最大サイズですが、実装は、より大きなデータグラムを受け取ることがあります。最大サイズは、IP、およびUDPまたはTCPヘッダを含んでいます。デフォルトは1400です。"
    },
    {
      "indent": 6,
      "text": "net.slp.interfaces",
      "ja": "net.slp.interfaces"
    },
    {
      "indent": 9,
      "text": "Value-list of strings giving the IP addresses of network interfaces on which the DA or SA should listen on port 427 for multicast, unicast UDP, and TCP messages. Default is empty, i.e. use the default network interface. The grammar for this property is:",
      "ja": "DAまたはSAは、マルチキャスト、ユニキャストUDP、およびTCPメッセージのポート427上でリッスンするネットワークインターフェイスのIPアドレスを与える文字列の値リスト。デフォルトでは、デフォルトのネットワーク・インタフェースを使用し、すなわち空です。このプロパティの文法は次のとおりです。"
    },
    {
      "indent": 15,
      "text": "addr-list     =  hostnumber / hostnumber \",\" addr-list\nhostnumber    =  1*3DIGIT 3(\".\" 1*3DIGIT)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "An example is:",
      "ja": "例は次のとおりです。"
    },
    {
      "indent": 18,
      "text": "195.42.42.42,195.42.142.1,195.42.120.1",
      "section_title": true,
      "ja": "１９５。４２。４２。４２、１９５。４２。１４２。１、１９５。４２。１２０。１"
    },
    {
      "indent": 9,
      "text": "The example machine has three interfaces on which the DA should listen.",
      "ja": "例えば、マシンはDAが待ち受ける3つのインタフェースを持っています。"
    },
    {
      "indent": 9,
      "text": "Note that since this property only takes IP addresses, it will need to be changed if the network is renumbered.",
      "ja": "このプロパティは、IPアドレスのみがかかるため、ネットワークが付け直されている場合、それは変更する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.1.6. SA Configuration",
      "section_title": true,
      "ja": "2.1.6。 SAの設定"
    },
    {
      "indent": 3,
      "text": "This section contains configuration properties for the SA. These properties are typically set programmatically by the SA, since they are specific to each SA.",
      "ja": "このセクションでは、SAの設定プロパティが含まれています。それらは各SAに対して特異的であるので、これらの特性は、典型的には、SAによってプログラムで設定されています。"
    },
    {
      "indent": 6,
      "text": "net.slp.SAAttributes",
      "ja": "Netcalapcattriputs"
    },
    {
      "indent": 9,
      "text": "A comma-separated list of parenthesized attribute/value list pairs that the SA must advertise in SAAdverts. The property must be in the SLP attribute list wire format, including escapes for reserved characters. [7]",
      "ja": "SAはSAAdvertsにアドバタイズする必要があり、括弧内の属性/値リストのペアのコンマ区切りのリスト。プロパティは、予約文字のエスケープを含め、SLP属性一覧ワイヤー形式でなければなりません。 [7]"
    },
    {
      "indent": 0,
      "text": "2.1.7. UA Configuration",
      "section_title": true,
      "ja": "2.1.7。 UAの設定"
    },
    {
      "indent": 3,
      "text": "This section contains configuration properties for the UA. These properties can be set either programmatically by the UA or in the configuration file.",
      "ja": "このセクションでは、UAの構成プロパティが含まれています。これらのプロパティは、プログラムUAによって、または構成ファイルのいずれかに設定することができます。"
    },
    {
      "indent": 6,
      "text": "net.slp.locale",
      "ja": "net.slp.locale"
    },
    {
      "indent": 9,
      "text": "A RFC 1766 Language Tag [6] for the language locale. Setting this property causes the property value to become the default locale for SLP messages. Default is \"en\". This property is also used for SA and DA configuration.",
      "ja": "言語ロケールのためのRFC 1766言語タグ[6]。このプロパティを設定すると、プロパティの値は、SLPのメッセージのデフォルトロケールになるようにします。デフォルトは「EN」です。このプロパティは、SAとDAコンフィギュレーションのために使用されています。"
    },
    {
      "indent": 6,
      "text": "net.slp.maxResults",
      "ja": "net.slp.maxResults"
    },
    {
      "indent": 9,
      "text": "A 32 bit integer giving the maximum number of results to accumulate and return for a synchronous request before the timeout, or the maximum number of results to return through a callback if the request results are reported asynchronously.",
      "ja": "要求結果は非同期に報告された場合、コールバックを介して戻すためにタイムアウトする前に蓄積し、同期要求に対して返される結果の最大数、または結果の最大数を与える32ビットの整数。"
    },
    {
      "indent": 9,
      "text": "Positive integers and -1 are legal values. If -1, indicates that all results should be returned. Default value is -1.",
      "ja": "正の整数とは-1正当な値です。 -1場合は、すべての結果が返されるべきであることを示しています。デフォルト値は-1です。"
    },
    {
      "indent": 9,
      "text": "DAs and SAs always return all results that match the request. This configuration value applies only to UAs, that filter incoming results and only return as many values as net.slp.maxResults indicates.",
      "ja": "DASおよびSAは常に要求に一致するすべての結果を返します。この設定値は、UAは、そのフィルタ受信結果に適用され、net.slp.maxResultsが示すようにのみなど、多くの値を返します。"
    },
    {
      "indent": 6,
      "text": "net.slp.typeHint",
      "ja": "net.slp.typeHint"
    },
    {
      "indent": 9,
      "text": "A value-list of service type names. In the absence of any DAs, UAs perform SA discovery for finding scopes. These SA discovery requests may contain a request for service types as an attribute.",
      "ja": "サービスタイプ名の値リスト。任意のDAが存在しない場合には、UAはスコープを見つけるためのSA発見を行います。これらのSAのディスカバリ要求を属性としてサービスタイプの要求が含まれていてもよいです。"
    },
    {
      "indent": 9,
      "text": "The API implementation will use the service type names supplied by this property to discover only those SAs (and their scopes) which support the desired service type or types. For example, if net.slp.typeHint is set to \"service:imap,service:pop3\" then SA discovery requests will include the search filter:",
      "ja": "APIの実装では、希望するサービスの種類やタイプをサポートのみのSA（およびそのスコープ）を発見するために、このプロパティによって提供されるサービスタイプ名を使用します。 net.slp.typeHintに設定されている場合たとえば、「サービス：IMAP、サービス：POP3、」その後、SAのディスカバリ要求は、検索フィルタが含まれます："
    },
    {
      "indent": 9,
      "text": "(|(service-type=service:imap)(service-type=service:pop3))",
      "ja": "（|（サービス型=サービス：IMAP）（サービス型=サービス：POP3））"
    },
    {
      "indent": 9,
      "text": "The API library can also use unicast to contact the discovered SAs for subsequent requests for these service types, to optimize network access.",
      "ja": "APIライブラリは、ネットワークへのアクセスを最適化するために、これらのサービスタイプのための後続の要求のために発見されたSAを連絡するユニキャストを使用することができます。"
    },
    {
      "indent": 0,
      "text": "2.1.8. Security",
      "section_title": true,
      "ja": "2.1.8。セキュリティ"
    },
    {
      "indent": 3,
      "text": "The property in this section allows security for all agents to be set on or off. When the property is true, then the agent must include security information on all SLP messages transacted by that agent. Since security policy must be set network wide to be effective, a single property controls security for all agents. Key management and management of SLP SPI strings [7] are implementation and policy dependent.",
      "ja": "このセクションのプロパティがオンまたはオフに設定するすべてのエージェントのセキュリティを可能にします。プロパティがtrueの場合、エージェントはそのエージェントによって取引すべてのSLPメッセージのセキュリティ情報を含める必要があります。セキュリティポリシーが有効であると幅広いネットワークを設定しなければならないので、単一のプロパティには、すべてのエージェントのセキュリティを制御します。 SLP SPI文字列のキー管理と管理は、[7]の実装とポリシーに依存しています。"
    },
    {
      "indent": 6,
      "text": "net.slp.securityEnabled",
      "ja": "net.slp.securityEnabled"
    },
    {
      "indent": 9,
      "text": "A boolean indicating whether the agent should enable security for URLs, attribute lists, DAAdverts, and SAAdverts. Each agent is responsible for interpreting the property appropriately. Default is false.",
      "ja": "エージェントは、URLのセキュリティを有効にするかどうかを示すブール値は、リスト、DAAdverts、およびSAAdverts属性。各エージェントは、適切なプロパティを解釈する責任があります。デフォルトはfalseです。"
    },
    {
      "indent": 0,
      "text": "2.2. Multihomed Machines",
      "section_title": true,
      "ja": "2.2。マルチホームマシン"
    },
    {
      "indent": 3,
      "text": "On multihomed machines, the bandwidth and latency characteristics on different network interfaces may differ considerably, to the point where different configuration properties are necessary to achieve optimal performance. The net.slp.interfaces property indicates which network interfaces are SLP enabled. An API library implementation may support configuration customization on a per network interface basis by allowing the interface IP address to be appended to the property name. In that case, the values of the property are only used for that particular interface, the generic property (or defaults if no generic property is set) applies to all others.",
      "ja": "マルチホームマシンでは、異なるネットワークインタフェース上の帯域幅と遅延特性が異なる構成の特性が最適な性能を達成するために必要である点に、かなり異なっていてもよいです。 net.slp.interfacesプロパティは、ネットワークインタフェースがSLPが有効であるかを示します。 APIライブラリの実装では、インターフェイスのIPアドレスは、プロパティ名に付加できるようにすることで、ネットワークインターフェイスごとに設定のカスタマイズをサポートすることができます。 （非ジェネリックプロパティが設定されていない場合、またはデフォルト）その場合、プロパティの値は、その特定のインタフェース、汎用性のために使用される他のすべてに適用されます。"
    },
    {
      "indent": 3,
      "text": "For example, if a configuration has the following properties:",
      "ja": "例えば、構成は次の性質を持っている場合："
    },
    {
      "indent": 6,
      "text": "net.slp.interfaces=125.196.42.41,125.196.42.42,125.196.42.43 net.slp.multicastTTL.125.196.42.42=1",
      "ja": "net.slp.interfaces = 125.196.42.41,125.196.42.42,125.196.42.43 net.slp.multicastTTL.125.196.42.42 = 1"
    },
    {
      "indent": 3,
      "text": "then the network interface on subnet 42 is restricted to a TTL of 1, while the interfaces on the other subnets have the default multicast radius, 255.",
      "ja": "他のサブネット上のインターフェイスはデフォルトマルチキャスト半径255を有しながらサブネット42上のネットワークインタフェースは、1のTTLに制限されます。"
    },
    {
      "indent": 3,
      "text": "The net.slp.interfaces property must only be set if there is no routing between the interfaces. If the property is set, the DA (if any) and SAs should advertise with the IP address or host name appropriate to the interface on the interfaces in the list. If packets are routed between the interfaces, then the DA and SAs should only advertise on the default interface. The property should also be set if broadcast is used rather than multicast on the subnets connected to the interfaces. Note that even if unicast packets are not routed between the interfaces, multicast may be routed through another router. The danger in listening for multicast on multiple interfaces when multicast packets are routed is that the DA or SA may receive the same multicast request via more than one interface. Since the IP address is different on each interface, the DA or SA cannot identify the request as having already being answered via the previous responder's list. The requesting agent will end up getting URLs that refer to the same DA or service but have different addresses or host names.",
      "ja": "インターフェイス間のルーティングがない場合のnet.slp.interfacesプロパティにのみ設定されなければなりません。プロパティが設定されている場合は、DA（もしあれば）とSAは、リスト内のインターフェイスのインターフェイスに適切なIPアドレスまたはホスト名で宣伝する必要があります。パケットがインターフェイス間でルーティングされている場合は、DAとSAは、デフォルトのインターフェイスに広告を掲載する必要があります。ブロードキャストではなくインターフェイスに接続されたサブネット上でマルチキャストより使用されている場合プロパティも設定する必要があります。ユニキャストパケットは、インターフェース間でルーティングされていない場合でも、マルチキャストは別のルータを介してルーティングされてもよいことに留意されたいです。マルチキャストパケットがルーティングされる複数のインターフェイス上でマルチキャストをリッスンに危険がDAまたはSAが複数のインタフェースを介して同じマルチキャスト要求を受信することができるということです。 IPアドレスは、各インターフェイスに異なるので、DAまたはSAは、すでに前の応答者のリストを経由して答えされているものとして、要求を識別することはできません。要求エージェントは、同じDAやサービスを参照してくださいが、異なるアドレスまたはホスト名を持っているURLを取得することになります。"
    },
    {
      "indent": 0,
      "text": "2.3. Serialized Registration File",
      "section_title": true,
      "ja": "2.3。直列化された登録ファイル"
    },
    {
      "indent": 3,
      "text": "The serialized registration file contains a group of registrations that a DA or SA server (if one exists) registers when it starts up. These registrations are primarily for older service programs that do not internally support SLP and cannot be converted, and for portably exchanging registrations between SLP implementations. The character encoding of the registrations is required to be UTF-8.",
      "ja": "シリアル化された登録ファイルは、起動時にDAまたはSAサーバーが（存在する場合）を登録登録のグループが含まれています。これらの登録は内部SLPをサポートしていないと変換できない、と移植性SLP実装間の登録を交換するため、古いサービスプログラムのために主にあります。登録の文字エンコーディングはUTF-8であることが必要です。"
    },
    {
      "indent": 3,
      "text": "The syntax of the serialized registration file, in ABNF format [5], is as follows:",
      "ja": "次のようにABNF形式でシリアライズ登録ファイルの構文は、[5]、です。"
    },
    {
      "indent": 6,
      "text": "ser-file = reg-list reg-list = reg / reg reg-list reg = creg / ser-reg creg = comment-line ser-reg comment-line = ( \"#\" / \";\" ) 1*allchar newline ser-reg = url-props [slist] [attr-list] newline url-props = surl \",\" lang \",\" ltime [ \",\" type ] newline surl = ;The registration's URL. See ; [8] for syntax. lang = 1*8ALPHA [ \"-\" 1*8ALPHA ] ;RFC 1766 Language Tag see [6]. ltime = 1*5DIGIT ; A positive 16-bit integer ; giving the lifetime ; of the registration. type = ; The service type name, see [7] ; and [8] for syntax. slist = \"scopes\" \"=\" scope-list newline scope-list = scope-name / scope-name \",\" scope-list scope = ; See grammar of [7] for ; scope-name syntax. attr-list = attr-def / attr-def attr-list attr-def = ( attr / keyword ) newline keyword = attr-id attr = attr-id \"=\" attr-val-list attr-id = ;Attribute id, see [7] for syntax. attr-val-list = attr-val / attr-val \",\" attr-val-list attr-val = ;Attribute value, see [7] for syntax. allchar = char / WSP char = DIGIT / ALPHA / other other = %x21-%x2f / %x3a-%x40 / %x5b-%x60 / %7b-%7e ; All printable, nonwhitespace US-ASCII ; characters. newline = CR / ( CRLF )",
      "ja": "SER-ファイル= REG-リストREG-リスト= REG / REG REG-リストREG =クレッグ/ SER-REGのCREG =コメントラインSER-REGのコメント行=（ \"＃\" / \";\"）1 * allchar改行SER -reg = URL-小道具[SLIST] [attrのリスト]改行のurl-小道具= SURLを \"\" LANG \"\" LTIMEの[ \"\" タイプ]改行SURL =;登録のURL。見る ; [8]構文について。 LANG = 1 * 8ALPHA [ \" - \" 1 * 8ALPHA]; RFC 1766言語タグは、[6]を参照してください。 LTIME = 1 * 5DIGIT。正の16ビット整数。寿命を与えます。登録。タイプ=;サービスタイプ名、[7]を参照。そして[8]構文について。 SLIST =「スコープ」「=」スコープリスト改行スコープリスト=スコープ名/スコープ名「」スコープリストスコープ=; [7]のための文法を参照。スコープ名の構文。 ATTRリスト= ATTR-DEF / ATTR-DEF ATTRリストATTR-DEF =（ATTR /キーワード）改行キーワード= ATTR-ID ATTR = ATTR-ID \"=\" ATTR-VALリストATTR-ID =;属性ID、構文については、[7]を参照してください。 ATTR-VAL-リスト= ATTR-valが/ ATTR-VAL \"は、\" ATTR-VAL-リストATTR-VAL =;属性値は、構文[7]を参照します。 allchar =チャー/ WSPチャー= DIGIT / ALPHA /他他=％x21-％x2f /％x3a-％X40 /％x5b-％X60 /％7b-％7E。すべての印刷可能な、空白以外のUS-ASCII;文字。改行= CR /（CRLF）"
    },
    {
      "indent": 3,
      "text": "The syntax for scope names, attribute tags, and attribute values requires escapes for special characters as specified in [7]. DAs and SA servers that process serialized registrations must handle them exactly as if they were registered by an SA. In the url-props production, the type token is optional. If the type token is present for a service: URL, a warning is signaled and the type name is ignored. If the maximum lifetime is specified (65535 sec.), the registration is taken to be permanent, and is continually refreshed by the DA or SA server until it exits. Scopes can be included in a registration by including an attribute definition with tag \"scopes\" followed by a comma separated list of scope names immediately after the url-props production. If the optional scope list is present, the registrations are made in the indicated scopes; otherwise, they are registered in the scopes with which the DA or SA server was configured through the net.slp.useScopes property.",
      "ja": "[7]で指定されたスコープ名、属性タグ、および属性値の構文は、特殊文字のエスケープが必要です。彼らはSAによって登録されたかのようにシリアル化された登録を処理DASおよびSAのサーバーが正確にそれらを処理しなければなりません。 URL-小道具の制作では、タイプのトークンはオプションです。タイプのトークンがサービスのために存在している場合：URL、警告が通知され、タイプ名は無視されます。最大寿命は（65535秒）を指定した場合、登録は恒久的であると解釈され、それが終了するまで継続的にDAまたはSAサーバーによって更新されます。スコープは、すぐに、URLの小道具制作後のスコープ名のカンマ区切りリストが続くタグ「スコープ」と属性の定義を含めることにより、登録に含めることができます。オプションのスコープリストが存在する場合、登録は示さスコープで行われます。それ以外の場合は、DAまたはSAサーバーがのnet.slp.useScopesプロパティを介して設定されたときのスコープに登録されています。"
    },
    {
      "indent": 3,
      "text": "If the scope list contains scopes that are not in the net.slp.useScopes property (provided that property is set) or are not specified by DHCP, the API library should reject the registration and issue a warning message.",
      "ja": "スコープリストはのnet.slp.useScopesプロパティにはないスコープが含まれている場合（プロパティが設定されている場合）またはDHCPによって指定されていない、APIライブラリは登録を拒否し、警告メッセージを発行する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4. Processing Serialized Registration and Configuration Files",
      "section_title": true,
      "ja": "2.4。直列化された登録と設定ファイルの処理"
    },
    {
      "indent": 3,
      "text": "Implementations are encouraged to make processing of configuration and serialized files as transparent as possible to clients of the API. At the latest, errors must be caught when the relevant configuration item is used. At the earliest, errors may be caught when the relevant file is loaded into the executing agent. Errors should be reported by logging to the appropriate platform logging file, error output, or log device, and the default value substituted. Serialized registration file entries should be caught and reported when the file is loaded.",
      "ja": "実装は、APIのクライアントに対して可能な限り透明として設定し、シリアル化されたファイルの処理を行うことが奨励されています。関連する設定項目が使用されている場合、最新で、エラーがキャッチされなければなりません。該当するファイルを実行するエージェントにロードされたときに早くても、エラーがキャッチすることができます。エラーは、適切なプラットフォームのログファイル、エラー出力にログインすることにより報告された、またはデバイスのログを記録し、デフォルト値が代入されなければなりません。直列化された登録ファイルのエントリがキャッチされ、ファイルがロードされたときに報告されるべきです。"
    },
    {
      "indent": 3,
      "text": "Configuration file loading must be complete prior to the initiation of the first networking connection. Serialized registration must be complete before the DA accepts the first network request.",
      "ja": "設定ファイルの読み込みは、最初のネットワーク接続の開始前に完了しなければなりません。 DAが最初のネットワーク要求を受け入れる前に直列化され登録が完了していなければなりません。"
    },
    {
      "indent": 0,
      "text": "3. Binding Independent Implementation Considerations",
      "section_title": true,
      "ja": "3.バインディング独立した実装に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section discusses a number of implementation considerations independent of language binding, with language specific notes where applicable.",
      "ja": "このセクションでは、該当する言語固有の注意事項と、言語バインディングの独立した実装上の考慮事項の数について説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Multithreading",
      "section_title": true,
      "ja": "3.1。マルチスレッド"
    },
    {
      "indent": 3,
      "text": "Implementations of both the C and Java APIs are required to make API calls thread-safe. Access to data structures shared between threads must be co-ordinated to avoid corruption or invalid access. One way to achieve this goal is to allow only one thread at a time in the implementing library. Performance in such an implementation suffers, however. Therefore, where possible, implementations are encouraged to allow multiple threads within the SLP API library.",
      "ja": "両方のCとJavaのAPIの実装は、APIはスレッドセーフ呼び出しを行うために必要とされています。スレッド間で共有データ構造へのアクセスは、汚職や不正なアクセスを防ぐために共同とれなければなりません。この目標を達成するための一つの方法は、実装ライブラリーで同時に複数のスレッドを可能にすることです。このような実装でのパフォーマンスは、しかし、苦しんでいます。そのため、可能な場合、実装は、SLP APIライブラリ内の複数のスレッドを許可することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "3.2. Asynchronous and Incremental",
      "section_title": true,
      "ja": "3.2。非同期とインクリメンタル"
    },
    {
      "indent": 3,
      "text": "The APIs are designed to encourage implementations supporting asynchronous and incremental client interaction. The goal is to allow large numbers of returned service URLs, service types, and attributes without requiring the allocation of huge chunks of memory. The particular design features to support this goal differ in the two language bindings.",
      "ja": "APIは、非同期と増分クライアントとの対話をサポートする実装を奨励するために設計されています。目標は、メモリの巨大な塊の割り当てを必要とせずに返されるサービスURL、サービスタイプ、および属性の多数を可能にすることです。この目標をサポートするための特定の設計上の特徴は、二つの言語バインディングが異なります。"
    },
    {
      "indent": 0,
      "text": "3.3. Type Checking for Service Types",
      "section_title": true,
      "ja": "3.3。サービスの種類の確認入力"
    },
    {
      "indent": 3,
      "text": "Service templates [8] allow SLP registrations to be type checked for correctness. Implementations of the API are free to make use of service type information for type checking, but are not required to do so. If a type error occurs, the registration should terminate with TYPE_ERROR.",
      "ja": "サービステンプレートは、[8] SLP登録が正しいかどうかチェックタイプであることを可能にします。 APIの実装は、型チェックのためのサービスタイプ情報を利用することは自由ですが、その必要はありません。型エラーが発生した場合、登録はTYPE_ERRORで終了しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.4. Refreshing Registrations",
      "section_title": true,
      "ja": "3.4。さわやか登録"
    },
    {
      "indent": 3,
      "text": "SLP advertisements carry an explicit lifetime with them. After the lifetime expires, the DA flushes the registration from its cache. In some cases, an application may want to have the URL continue being registered for the entire time during which the application is executing. The API includes provision for clients to indicate whether they want URLs to be automatically refreshed. Implementations of the SA API must provide this automatic refreshing capability. Note that a client which uses this facility should explicitly deregister the service URL before exiting, since the API implementation may not be able to assure that the URL is deregistered when the application exits, although it will time out in the DA eventually.",
      "ja": "SLPの広告は彼らと明示的な寿命を運びま​​す。寿命が満了した後、DAは、そのキャッシュからの登録をフラッシュします。いくつかのケースでは、アプリケーションは、アプリケーションが実行されている間の時間全体のために登録され続けるURLを持っている場合があります。 APIは、クライアントがURLは自動的にリフレッシュするかどうかを指定するための条項を含んでいます。 SAのAPIの実装は、この自動更新機能を提供しなければなりません。それは最終的にはDAにタイムアウトしますが、APIの実装では、URLがアプリケーションの終了時に登録解除されることを保証することができないかもしれないので、この機能を使用するクライアントが明示的に、終了する前に、サービスURLの登録を解除する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.5. Configuration File Processing",
      "section_title": true,
      "ja": "3.5。コンフィギュレーション・ファイル処理"
    },
    {
      "indent": 3,
      "text": "DAs, SAs and UAs processing the configuration file, and DAs and SA servers processing the serialized registration file are required to log any errors using whatever underlying error mechanism is appropriate for the platform. Examples include writing error messages to the standard output, writing to a system logging device, or displaying the errors to a logging window. After the error is reported, the offending property must be set to the default and program execution continued. An agent MUST NOT fail if a file format error occurs.",
      "ja": "シリアル化された登録ファイルを処理したDA、SASおよびコンフィギュレーション・ファイルを処理するUA、およびDASとSAサーバは、根本的なエラー・メカニズムはプラットフォームに適したものは何でも使ってすべてのエラーをログに記録する必要があります。例としては、標準出力にエラーメッセージを書き込み、システムロギングデバイスへの書き込み、またはロギングウィンドウにエラーを表示しています。エラーが報告された後、問題のプロパティがデフォルト値に設定され、プログラムの実行を継続する必要があります。ファイル形式エラーが発生した場合、エージェントは失敗してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.6. Attribute Types",
      "section_title": true,
      "ja": "3.6。属性タイプ"
    },
    {
      "indent": 3,
      "text": "String encoded attribute values do not include explicit type information. All UA implementations and those SA and DA implementations that choose to support type checking should use the type rules described in [8] in order to convert from the string representation on the wire to an object typed appropriately.",
      "ja": "文字列のエンコードされた属性値は、明示的な型情報が含まれていません。全てのUA実装およびタイプチェックが適切な型のオブジェクトにワイヤ上の文字列表現から変換するために、[8]に記載のタイプのルールを使用する必要がサポートすることを選択し、それらのSAおよびDAの実装。"
    },
    {
      "indent": 0,
      "text": "3.7. Removal of Duplicates",
      "section_title": true,
      "ja": "3.7。重複の除去"
    },
    {
      "indent": 3,
      "text": "The UA implementation SHOULD always collate results to remove duplicates during synchronous operations and for the Java API. During asynchronous operation in C, the UA implementation SHOULD forgo duplicate elimination to reduce memory requirements in the library. This allows the API library to simply take the returned attribute value list strings, URL strings, or service type list strings and call the callback function with it, without any additional processing. Naturally, the burden of duplicate elimination is thrown onto the client in this case.",
      "ja": "UAの実装は常に同期操作中およびJava APIのための重複を削除した結果を照合すべきです。 Cでの非同期動作の間、UAの実装では、ライブラリ内のメモリ要件を減らすために、重複排除を見送るべきです。これは、APIライブラリは、単純に返される属性値のリストの文字列、URL文字列、またはサービスタイプのリストの文字列を取得し、任意の追加の処理をせずに、それにコールバック関数を呼び出すことができます。当然のことながら、重複排除の負担は、この場合には、クライアント上にスローされます。"
    },
    {
      "indent": 0,
      "text": "3.8. Character Set Encoding",
      "section_title": true,
      "ja": "3.8。文字セットエンコーディング"
    },
    {
      "indent": 3,
      "text": "Character string parameters in the Java API are all represented in Unicode internally because that is the Java-supported character set. Characters buffer parameters in the C API are represented in UTF-8 to maintain maximum compatibility on platforms that only support US-ASCII and not UTF-8. API functions are still required to handle the full range of UTF-8 characters because the SLP protocol requires it, but the API implementation can represent the characters internally in any convenient way. On the wire, all characters are converted to UTF-8. Inside URLs, characters that are not allowed by URL syntax [2] must be escaped according to the URL escape character convention. Strings that are included in SLP messages may include SLP reserved characters and can be escaped by clients through convenience functions provided by the API. The character encoding used in escapes is UTF-8.",
      "ja": "それは、Javaがサポートする文字セットであるため、Java APIの文字列パラメータはすべて内部的にUnicodeで表現されています。 C APIの文字バッファパラメータはUS-ASCIIではなくUTF-8をサポートするプラットフォーム上での最大の互換性を維持するために、UTF-8で表現されています。 API関数は、まだSLPプロトコルがそれを必要とするため、UTF-8文字の完全な範囲を扱うために必要とされますが、APIの実装では、任意の便利な方法で内部的に文字を表現することができます。ワイヤーでは、すべての文字がUTF-8に変換されます。 URLの内部では、URLの構文によって許可されていない文字は、[2] URLエスケープ文字の規則に従ってエスケープする必要があります。 SLPメッセージに含まれている文字列は、SLPが文字を予約し、APIが提供する便利な機能を通じてクライアントでエスケープすることができ挙げられます。エスケープに使用される文字エンコーディングはUTF-8です。"
    },
    {
      "indent": 3,
      "text": "Due to constraints in SLP, no string parameter passed to the C or Java API may exceed 64K bytes in length.",
      "ja": "SLPに制約のため、CまたはJava APIに渡されない文字列パラメータは、長さが64Kバイトを超えないことができます。"
    },
    {
      "indent": 0,
      "text": "3.9. Error Semantics",
      "section_title": true,
      "ja": "3.9。エラーセマンティクス"
    },
    {
      "indent": 3,
      "text": "All errors encountered processing SLP messages should be logged. For synchronous calls, an error is only reported on a call if no successful replies were received from any SLP framework entity. If an error occurred among one of several successful replies, then the error should be logged and the successful replies returned. For asynchronous calls, an error occurring during correspondence with a particular remote SLP agent is reported through the first callback (in the C API) or enumeration method invocation (in the Java API) after the error occurs, which would normally report the results of the correspondence. This allows the callback or client code to determine whether the operation should be terminated or continue. In some cases, the error returned from the SLP framework may be fatal (SLP_PARSE_ERROR, etc.). In these cases, the API library terminates the operation.",
      "ja": "SLPメッセージの処理に発生したすべてのエラーがログに記録されなければなりません。何も成功した回答は任意のSLPのフレームワークエンティティから受信されなかった場合、同期コールの場合、エラーが唯一のコールで報告されます。エラーは、いくつかの成功の応答の1の間で発生した場合は、エラーがログに記録されなければならないと成功した応答が返されます。非同期呼び出しのためにエラーが発生した後、特定のリモートSLPエージェントと対応間に生じるエラー（C APIの）最初のコールバックを介して報告されている、または（Java APIの）列挙メソッド呼び出し、通常の結果を報告することになります対応。これは、コールバックやクライアントコードは動作を終了するか継続するかどうかを決定することができます。いくつかのケースでは、エラーが致命的（SLP_PARSE_ERROR、等）であってもよいSLPフレームワークから返さ。これらのケースでは、APIライブラリは動作を終了します。"
    },
    {
      "indent": 3,
      "text": "Both the Java and C APIs contain language specific error code mechanisms for returning error information. The names of the error codes are consistent between the two implementations, however.",
      "ja": "両方のJavaおよびC APIは、エラー情報を返すための言語固有のエラーコードメカニズムを含みます。エラーコードの名前は、しかし、2つの実装の間で一致しています。"
    },
    {
      "indent": 3,
      "text": "The following error codes are returned from a remote agent (DA or SA server):",
      "ja": "以下のエラーコードは、リモートエージェント（DAまたはSAサーバ）から返されます。"
    },
    {
      "indent": 6,
      "text": "LANGUAGE_NOT_SUPPORTED",
      "ja": "LANGUAGE_NOT_SUPPORTED"
    },
    {
      "indent": 9,
      "text": "No DA or SA has service advertisement or attribute information in the language requested, but at least one DA or SA indicated, via the LANGUAGE_NOT_SUPPORTED error code, that it might have information for that service in another language.",
      "ja": "いいえDAやSAはサービスの広告を持っていないか、要求された言語の属性情報が、少なくとも1 DAまたはSAは、それが別の言語で、そのサービスの情報を持っている可能性があることを、LANGUAGE_NOT_SUPPORTEDエラーコードを経由して、示されました。"
    },
    {
      "indent": 6,
      "text": "PARSE_ERROR",
      "ja": "パースエラー"
    },
    {
      "indent": 9,
      "text": "The SLP message was rejected by a remote SLP agent. The API returns this error only when no information was retrieved, and at least one SA or DA indicated a protocol error. The data supplied through the API may be malformed or a may have been damaged in transit.",
      "ja": "SLPメッセージがリモートSLPエージェントによって拒否されました。 APIは、何も情報を取得しない、少なくとも1つのSAまたはDAがプロトコルエラーを示した場合にのみ、このエラーを返します。 APIを介して供給されたデータは、不正な形式してもよいし、輸送中に破損している可能性があります。"
    },
    {
      "indent": 6,
      "text": "INVALID_REGISTRATION",
      "ja": "INVALID登録"
    },
    {
      "indent": 9,
      "text": "The API may return this error if an attempt to register a service was rejected by all DAs because of a malformed URL or attributes. SLP does not return the error if at least one DA accepted the registration.",
      "ja": "サービスを登録しようとする試みが原因で不正なURLまたは属性のすべてのDAによって拒否された場合、APIは、このエラーを返すことがあります。少なくとも一つのDAが登録を受け入れた場合SLPはエラーを返しません。"
    },
    {
      "indent": 6,
      "text": "AUTHENTICATION_ABSENT",
      "ja": "AUTHENTICATION_ABSENT"
    },
    {
      "indent": 9,
      "text": "If the SLP framework supports authentication, this error arises when the UA or SA failed to send an authenticator for requests or registrations in a protected scope.",
      "ja": "SLPのフレームワークは、認証をサポートしている場合はUAまたはSAは、保護された範囲内の要求や登録のためのオーセンティケータを送信するために失敗した場合、このエラーが発生します。"
    },
    {
      "indent": 6,
      "text": "INVALID_UPDATE",
      "ja": "INVALID_UPDATE"
    },
    {
      "indent": 9,
      "text": "An update for a non-existing registration was issued, or the update includes a service type or scope different than that in the initial registration, etc.",
      "ja": "非既存の登録の更新が発行された、または更新が初期登録などのそれとは異なるサービスの種類や範囲を含み"
    },
    {
      "indent": 3,
      "text": "The following errors result from interactions with remote agents or can occur locally:",
      "ja": "次のエラーは、リモートエージェントとの相互作用に起因する、または局所的に発生する可能性があります。"
    },
    {
      "indent": 6,
      "text": "AUTHENTICATION_FAILED",
      "ja": "認証に失敗しました"
    },
    {
      "indent": 9,
      "text": "If the SLP framework supports authentication, this error arises when a authentication on an SLP message failed.",
      "ja": "SLPのフレームワークは、認証をサポートしている場合、このエラーはSLPメッセージの認証が失敗したときに生じます。"
    },
    {
      "indent": 6,
      "text": "SCOPE_NOT_SUPPORTED",
      "ja": "SCOPE_NOT_SUPPORTED"
    },
    {
      "indent": 9,
      "text": "The API returns this error if the SA has been configured with net.slp.useScopes value-list of scopes and the SA request did not specify one or more of these allowable scopes, and no others. It may be returned by a DA or SA if the scope included in a request is not supported by the DA or SA.",
      "ja": "SAは、スコープののnet.slp.useScopes値リストで構成されているとSA要求がこれらの許容スコープの一つ以上を指定しないと、何も他の人しなかった場合、APIは、このエラーを返します。要求に含まれる範囲は、DAまたはSAによってサポートされていない場合には、DAまたはSAによって戻されてもよいです。"
    },
    {
      "indent": 6,
      "text": "REFRESH_REJECTED",
      "ja": "REFRESH_REJECTED"
    },
    {
      "indent": 9,
      "text": "The SA attempted to refresh a registration more frequently than the minimum refresh interval. The SA should call the appropriate API function to obtain the minimum refresh interval to use.",
      "ja": "SAは、最小更新間隔よりも頻繁に登録を更新しようとしました。 SAは、使用する最小リフレッシュ間隔を得るために、適切なAPI関数を呼び出す必要があります。"
    },
    {
      "indent": 3,
      "text": "The following errors are generated through a program interacting with the API implementation. They do not involve a remote SLP agent.",
      "ja": "以下のエラーがAPIの実装との相互作用プログラムによって生成されます。彼らは、リモートSLPエージェントを含みません。"
    },
    {
      "indent": 6,
      "text": "NOT_IMPLEMENTED",
      "ja": "NOT_IMPLEMENTED"
    },
    {
      "indent": 9,
      "text": "If an unimplemented feature is used, this error is returned.",
      "ja": "実装されていない機能を使用する場合、このエラーが返されます。"
    },
    {
      "indent": 6,
      "text": "NETWORK_INIT_FAILED",
      "ja": "NETWORK_INIT_FAILED"
    },
    {
      "indent": 9,
      "text": "If the network cannot initialize properly, this error is returned.",
      "ja": "ネットワークを正しく初期化できない場合は、このエラーが返されます。"
    },
    {
      "indent": 6,
      "text": "NETWORK_TIMED_OUT",
      "ja": "NETWORK_TIMED_OUT"
    },
    {
      "indent": 9,
      "text": "When no reply can be obtained in the time specified by the configured timeout interval for a unicast request, this error is returned.",
      "ja": "返事をユニキャスト要求のために構成されたタイムアウト間隔で指定された時間内に得ることができない場合、このエラーが返されます。"
    },
    {
      "indent": 6,
      "text": "NETWORK_ERROR",
      "ja": "ネットワークエラー"
    },
    {
      "indent": 9,
      "text": "The failure of networking during normal operations causes this error to be returned.",
      "ja": "通常の操作中のネットワークに障害が発生すると、このエラーが返されるようにします。"
    },
    {
      "indent": 6,
      "text": "BUFFER_OVERFLOW",
      "ja": "BUFFER_OVERFLOW"
    },
    {
      "indent": 9,
      "text": "An outgoing request overflowed the maximum network MTU size. The request should be reduced in size or broken into pieces and tried again.",
      "ja": "発信要求が最大のネットワークのMTUサイズをオーバーフローしました。要求は、小型化または小片に破壊して、再度試みなければなりません。"
    },
    {
      "indent": 6,
      "text": "MEMORY_ALLOC_FAILED",
      "ja": "MEMORY_ALLOC_FAILED"
    },
    {
      "indent": 9,
      "text": "If the API fails to allocate memory, the operation is aborted and returns this.",
      "ja": "APIは、メモリの割り当てに失敗した場合、操作は中止され、これを返します。"
    },
    {
      "indent": 6,
      "text": "PARAMETER_BAD",
      "ja": "PARAMETER_BAD"
    },
    {
      "indent": 9,
      "text": "If a parameter passed into an interface is bad, this error is returned.",
      "ja": "インタフェースに渡されたパラメータが不良である場合、このエラーが返されます。"
    },
    {
      "indent": 6,
      "text": "INTERNAL_SYSTEM_ERROR",
      "ja": "INTERNAL_SYSTEM_ERROR"
    },
    {
      "indent": 9,
      "text": "A basic failure of the API causes this error to be returned. This occurs when a system call or library fails. The operation could not recover.",
      "ja": "APIの基本的な失敗は、このエラーが返されるようにします。システムコールやライブラリが失敗した場合に発生します。操作は回復することができませんでした。"
    },
    {
      "indent": 6,
      "text": "HANDLE_IN_USE",
      "ja": "HANDLE_IN_USE"
    },
    {
      "indent": 9,
      "text": "In the C API, callback functions are not permitted to recursively call into the API on the same SLPHandle, either directly or indirectly. If an attempt is made to do so, this error is returned from the called API function.",
      "ja": "C APIでは、コールバック関数が再帰的に直接または間接的に、同じSLPHandleにAPIを呼び出すことを許可されていません。試みがそうするように作られている場合、このエラーは、呼び出されたAPI関数から返されます。"
    },
    {
      "indent": 6,
      "text": "TYPE_ERROR",
      "ja": "TYPE_ERROR"
    },
    {
      "indent": 9,
      "text": "If the API supports type checking of registrations against service type templates, this error can arise if the attributes in a registration do not match the service type template for the service.",
      "ja": "APIは、サービスタイプのテンプレートに対する登録の型チェックをサポートしている場合は、登録の属性は、サービスのサービスタイプのテンプレートと一致しない場合、このエラーが発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some error codes are handled differently in the Java API. These differences are discussed in Section 5.",
      "ja": "いくつかのエラーコードは、Java APIに異なる方法で処理されています。これらの違いは、第5節で議論されています。"
    },
    {
      "indent": 3,
      "text": "The SLP protocol errors OPTION_NOT_UNDERSTOOD, VERSION_NOT_SUPPORTED, INTERNAL_ERROR, MSG_NOT_SUPPORTED, AUTHENTICATON_UNKNOWN, and DA_BUSY_NOW should be handled internally and not surfaced to clients through the API.",
      "ja": "SLPプロトコルエラーのOPTION_NOT_UNDERSTOOD、VERSION_NOT_SUPPORTED、INTERNAL_ERROR、MSG_NOT_SUPPORTED、AUTHENTICATON_UNKNOWN、およびDA_BUSY_NOWは内部的に処理し、APIを介してクライアントに浮上していないする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.10. Modular Implementations",
      "section_title": true,
      "ja": "3.10。モジュラー実装"
    },
    {
      "indent": 3,
      "text": "Subset implementations that do not support the full range of functionality are required to nevertheless support every interface in order to maintain link compatibility between compliant API implementations and applications. If a particular operation is not supported, a NOT_IMPLEMENTED error should be returned. The Java API has some additional conventions for handling subsets. Applications that are expected to run on a wide variety of platforms should be prepared for subset API implementations by checking returned error codes.",
      "ja": "機能の全範囲をサポートしていないサブセットの実装は、それにもかかわらず、準拠したAPIの実装とアプリケーション間のリンクの互換性を維持するために、すべてのインターフェイスをサポートする必要があります。特定の操作がサポートされていない場合、NOT_IMPLEMENTEDエラーが返されるべきです。 Java APIは、サブセットを処理するためのいくつかの追加の規則があります。多様なプラットフォーム上で実行することが予想されているアプリケーションは、返されるエラーコードをチェックしてサブセットAPIの実装のために準備されるべきです。"
    },
    {
      "indent": 0,
      "text": "3.11. Handling Special Service Types",
      "section_title": true,
      "ja": "3.11。特別なサービスタイプの取り扱い"
    },
    {
      "indent": 3,
      "text": "The service types service:directory-agent and service:service-agent are used internally in the SLP framework to discover DAs and SAs. The mechanism of DA and SA discovery is not normally exposed to the API client; however, the client may have interest in discovering DAs and SAs independently of their role in discovering other services. For example, a network management application may want to determine which machines are running SLP DAs. To facilitate that, API implementations must handle requests to find services and attributes for these two service types so that API clients obtain the information they expect.",
      "ja": "サービスの種類サービス：ディレクトリエージェントとサービス：サービス・エージェントは、DASとSAを発見するSLPフレームワークで内部的に使用されています。 DAとSA発見のメカニズムは、通常、APIのクライアントに公開されていません。ただし、クライアントは、独立して、他のサービスを発見する役割のDASおよびSAを発見することに関心を持っていることがあります。たとえば、ネットワーク管理アプリケーションは、マシンがSLP DAを実行しているかを決定することをお勧めします。それを容易にするために、APIの実装は、サービスを見つけるための要求を処理し、APIクライアントは、彼らが期待する情報を得るように、これら2つのサービスの種類の属性をしなければなりません。"
    },
    {
      "indent": 3,
      "text": "In particular, if the UA is using a DA, SrvRqst and AttrRqst for these service types must be multicast and not unicast to the DA, as is the case for other service types. If the requests are not multicast, the DA will respond with an empty reply to a request for services of type service:service-agent and with its URL only to a request for services of type service:directory-agent. The UA would therefore not obtain a complete picture of the available DAs and SAs.",
      "ja": "具体的には、UAは、これらのサービスタイプのためにDA、SrvRqstとAttrRqstを使用している場合、他のサービスタイプの場合のように、DAにユニキャスト、マルチキャストなくなければなりません。ディレクトリエージェント：のみ型サービスのサービスの要求にサービス・エージェントとそのURLで：リクエストがマルチキャストでない場合は、DA型サービスのサービスの要求に空の応答で応答します。 UAは、したがって、可能なDASおよびSAの全体像を得られないでしょう。"
    },
    {
      "indent": 0,
      "text": "3.12. Scope Discovery and Handling",
      "section_title": true,
      "ja": "3.12。スコープ発見と取り扱い"
    },
    {
      "indent": 3,
      "text": "Both APIs contain an operation to obtain a list of currently known scope names. This scope information comes from a variety of places: DHCP, the net.slp.useScopes property, unicast to DAs configured via DHCP or the net.slp.DAAddresses property, and active and passive discovery.",
      "ja": "どちらのAPIは、現在知られているスコープ名のリストを取得するための操作が含まれています。このスコープ情報は、さまざまな場所から来ている：DHCP、のnet.slp.useScopesプロパティ、DHCPまたはnet.slp.DAAddressesプロパティから構成されたDAにユニキャスト、アクティブおよびパッシブ発見。"
    },
    {
      "indent": 3,
      "text": "The API is required to be implemented in a way that re-enforces the administrative and user scoping models described in [7]. SA clients only support the administrative scoping model. SAs must know a priori what DAs they need to register with since there is typically no human intervention in scope selection for SAs. UAs must support both administrative and user scoping because an application may require human intervention in scope selection.",
      "ja": "APIは、[7]に記載の管理およびユーザスコープモデル再施行方法で実装する必要があります。 SAクライアントは、管理スコープモデルをサポートしています。 SAは、彼らは通常、SAの範囲の選択には、人間の介入がないために登録するために必要なものDAを演繹的に知っている必要があります。アプリケーションは、スコープ選択における人間の介入が必要な場合がありますので、UAは、管理者とユーザーの両方のスコープをサポートしている必要があります。"
    },
    {
      "indent": 3,
      "text": "API implementations are required to support administrative scoping in the following way. Scopes configured by DHCP and scopes of DAs configured by DHCP have first priority (in that order) and must be returned if they are available. The net.slp.useScopes property has second priority, and scopes discovered through the net.slp.useScopes property must be returned if this property is set and there are no scopes available from DHCP. If scopes are not available from either of these sources and the net.slp.DAAddresses property is set, then the scopes available from the configured DAs must be returned. Note that if both DAs and scopes are configured, the scopes of the configured DAs must match the configured scope list; otherwise and error is signaled and agent execution is terminated. If no configured scope information is available, then an SA client has default scope, \"DEFAULT\", and a UA client employs user scoping.",
      "ja": "APIの実装は次のように管理スコープをサポートする必要があります。 DHCPおよびDHCPによって構成されたDAのスコープで構成されたスコープは、（この順番で）最初の優先順位を持っており、彼らが利用可能な場合に返さなければなりません。 net.slp.useScopesプロパティには、次の優先順位があり、このプロパティを設定し、DHCPから利用可能なスコープが存在していない場合のnet.slp.useScopesプロパティを介して発見されたスコープは返さなければなりません。スコープが設定されているこれらのソースとnet.slp.DAAddressesプロパティのいずれかから入手できない場合は、設定されたDAから入手可能なスコープを返さなければなりません。 DASおよびスコープの両方が設定されている場合、構成のDAのスコープが構成されたスコープリストに一致しなければならないことに注意してください。そうでない場合は、エラー通知され、エージェントの実行が終了されます。全く構成されたスコープ情報が利用できない場合は、SAクライアントは、デフォルトのスコープを持っている、「DEFAULT」、およびUAクライアントは、ユーザーのスコープを採用しています。"
    },
    {
      "indent": 3,
      "text": "User scoping is supported in the following way. Scopes discovered from active DA discovery, and from passive DA discovery all must be returned. If no information is available from active and passive DA discovery, then the API library may perform SA discovery, using the service types in the net.slp.typeHint property to limit the search to SAs supporting particular service types. If no net.slp.typeHint property is set, the UA may perform SA discovery without any service type query. In the absence of any of the above sources of information, the API must return the default scope, \"DEFAULT\". Note that the API must always return some scope information.",
      "ja": "ユーザースコープは、次のようにサポートされています。アクティブDAの発見から、および受動的DAの発見から発見されたスコープはすべて返却しなければなりません。何の情報は、アクティブとパッシブのDA発見から利用できない場合は、APIライブラリは、特定のサービスの種類をサポートしているのSAに検索を制限するためにnet.slp.typeHintプロパティ内のサービスタイプを使用して、SAの探索を行うことができます。何net.slp.typeHintプロパティが設定されていない場合、UAは、任意のサービスタイプのクエリなしでSAの発見を行うことができます。情報の上記ソースのいずれかが存在しない場合には、APIは、「DEFAULT」をデフォルトのスコープを返す必要があります。 APIは、常にいくつかのスコープ情報を返す必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "SLP requires that SAs must perform their operations in all scopes currently known to them. [7]. The API enforces this constraint by not requiring the API client to supply any scopes as parameters to API operations. The API library must obtain all currently known scopes and use them in SA operations. UA API clients should use a scope obtained through one of the API operations for finding scopes. Any other scope name may result in a SCOPE_NOT_SUPPORTED error from a remote agent. The UA API library can optionally check the scope and return the error without contacting a remote agent.",
      "ja": "SLPは、SAは現在、彼らに知られているすべてのスコープでその操作を実行している必要があります。 [7]。 APIは、API操作にパラメータとして任意のスコープを供給するためにAPIクライアントを必要としないことにより、この制約を強制します。 APIライブラリは、現在知られている全てのスコープを取得し、SA操作でそれらを使用する必要があります。 UA APIクライアントは、スコープを見つけるためのAPI操作のうちの1つを介して取得したスコープを使用する必要があります。他のスコープ名は、リモートエージェントからSCOPE_NOT_SUPPORTED誤差をもたらし得ます。 UA APIライブラリは、必要に応じて範囲をチェックして、リモートエージェントに接触することなく、エラーを返すことができます。"
    },
    {
      "indent": 0,
      "text": "4. C Language Binding",
      "section_title": true,
      "ja": "4. C言語バインディング"
    },
    {
      "indent": 3,
      "text": "The C language binding presents a minimal overhead implementation that maps directly into the protocol. There is one C language function per protocol request, with the exception of the SLPDereg() and SLPDelAttrs() functions, which map into different uses of the SLP deregister request. Parameters are for the most part character buffers. Memory management is kept simple by having the client allocate most memory and requiring that client callback functions copy incoming parameters into memory allocated by the client code. Any memory returned directly from the API functions is deallocated using the SLPFree() function.",
      "ja": "バインディングC言語は、プロトコルに直接マップする最小のオーバーヘッドの実装を提供します。プロトコル要求ごとにC言語の関数はSLPDereg（）とSLPDelAttrs（）SLPの登録解除要求の異なる用途にマッピング機能を除いて、存在します。パラメータは、ほとんどの部分文字バッファのためのものです。メモリ管理は、ほとんどのメモリを割り当て、クライアントのコールバック関数は、クライアント・コードによって割り当てられたメモリへの着信パラメータをコピーすることを必要とするクライアントを有することによって簡単に保たれます。 API関数から直接返されたメモリはSLPFree（）関数を使用して割り当てを解除されます。"
    },
    {
      "indent": 3,
      "text": "To conform with standard C practice, all character strings passed to and returned through the API are null terminated, even though the SLP protocol does not use null terminated strings. Strings passed as parameters are UTF-8 but they may still be passed as a C string (a null terminated sequence of bytes.) Escaped characters must be encoded by the API client as UTF-8. In the common case of US-ASCII, the usual one byte per character C strings work. API functions assist in escaping and unescaping strings.",
      "ja": "標準Cの練習に準拠するため、すべての文字列に渡され、APIを通じて返さはnullで終了され、SLPプロトコルはNULLを使用していないにもかかわらず、文字列を終了しました。パラメータとして渡された文字列はUTF-8ですが、彼らはまだ（nullはバイトのシーケンスを終了しました。）C文字列として渡された文字はUTF-8などのAPIクライアントによって符号化されなければならないエスケープすることができます。 US-ASCIIの一般的なケースでは、文字C列ごとに通常の1つのバイトが働きます。 API関数は、文字列をエスケープし、アンエスケープを支援します。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise noted, parameters to API functions and callbacks are non-NULL. Some parameters may have other restrictions. If any parameter fails to satisfy the restrictions on its value, the operation returns a PARAMETER_BAD error.",
      "ja": "特に断りのない限り、API関数とコールバックへのパラメータは非NULLです。いくつかのパラメータは、他の制約がある場合があります。いずれかのパラメータは、その値の制限を満たすために失敗した場合、操作はPARAMETER_BADエラーを返します。"
    },
    {
      "indent": 0,
      "text": "4.1. Constant Types",
      "section_title": true,
      "ja": "4.1。一定のタイプ"
    },
    {
      "indent": 0,
      "text": "4.1.1. URL Lifetimes",
      "section_title": true,
      "ja": "4.1.1。 URLの有効期限"
    },
    {
      "indent": 0,
      "text": "4.1.1.1. Synopsis",
      "section_title": true,
      "ja": "4.1.1.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "typedef enum {\n  SLP_LIFETIME_DEFAULT = 10800,\n  SLP_LIFETIME_MAXIMUM = 65535\n} SLPURLLifetime;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.1.1.2. Description",
      "section_title": true,
      "ja": "4.1.1.2。説明"
    },
    {
      "indent": 3,
      "text": "The SLPURLLifetime enum type contains URL lifetime values, in seconds, that are frequently used. SLP_LIFETIME_DEFAULT is 3 hours, while SLP_LIFETIME_MAXIMUM is about 18 hours and corresponds to the maximum size of the lifetime field in SLP messages.",
      "ja": "SLPURLLifetimeの列挙型は頻繁に使用される秒単位のURLのライフタイム値を、含まれています。 SLP_LIFETIME_MAXIMUMは約18時間であり、SLPメッセージにおける寿命フィールドの最大サイズに対応しているSLP_LIFETIME_DEFAULTは、3時間です。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Error Codes",
      "section_title": true,
      "ja": "4.1.2。エラーコード"
    },
    {
      "indent": 0,
      "text": "4.1.2.1. Synopsis",
      "section_title": true,
      "ja": "4.1.2.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "typedef enum {\n  SLP_LAST_CALL                    = 1,\n  SLP_OK                           = 0,\n  SLP_LANGUAGE_NOT_SUPPORTED       = -1,\n  SLP_PARSE_ERROR                  = -2,\n  SLP_INVALID_REGISTRATION         = -3,\n  SLP_SCOPE_NOT_SUPPORTED          = -4,\n  SLP_AUTHENTICATION_ABSENT        = -6,\n  SLP_AUTHENTICATION_FAILED        = -7,",
      "raw": true
    },
    {
      "indent": 3,
      "text": " SLP_INVALID_UPDATE = -13, SLP_REFRESH_REJECTED = -15, SLP_NOT_IMPLEMENTED = -17, SLP_BUFFER_OVERFLOW = -18, SLP_NETWORK_TIMED_OUT = -19, SLP_NETWORK_INIT_FAILED = -20, SLP_MEMORY_ALLOC_FAILED = -21, SLP_PARAMETER_BAD = -22, SLP_NETWORK_ERROR = -23, SLP_INTERNAL_SYSTEM_ERROR = -24, SLP_HANDLE_IN_USE = -25, SLP_TYPE_ERROR = -26 } SLPError ;",
      "ja": "SLP_INVALID_UPDATE = -13、SLP_REFRESH_REJECTED = -15、SLP_NOT_IMPLEMENTED = -17、SLP_BUFFER_OVERFLOW = -18、SLP_NETWORK_TIMED_OUT = -19、SLP_NETWORK_INIT_FAILED = -20、SLP_MEMORY_ALLOC_FAILED = -21、SLP_PARAMETER_BAD = -22、SLP_NETWORK_ERROR = -23、SLP_INTERNAL_SYSTEM_ERROR = -24、 SLP_HANDLE_IN_USE = -25、SLP_TYPE_ERROR = -26} SLPError。"
    },
    {
      "indent": 0,
      "text": "4.1.2.2. Description",
      "section_title": true,
      "ja": "4.1.2.2。説明"
    },
    {
      "indent": 3,
      "text": "The SLPError enum contains error codes that are returned from API functions.",
      "ja": "SLPError列挙型は、API関数から返されるエラーコードが含まれています。"
    },
    {
      "indent": 3,
      "text": "The SLP_OK code indicates that the no error occurred during the operation.",
      "ja": "SLP_OKコードは何の操作中にエラーが発生していないことを示しています。"
    },
    {
      "indent": 3,
      "text": "The SLP_LAST_CALL code is passed to callback functions when the API library has no more data for them and therefore no further calls will be made to the callback on the currently outstanding operation. The callback can use this to signal the main body of the client code that no more data will be forthcoming on the operation, so that the main body of the client code can break out of data collection loops. On the last call of a callback during both a synchronous and asynchronous call, the error code parameter has value SLP_LAST_CALL, and the other parameters are all NULL. If no results are returned by an API operation, then only one call is made, with the error parameter set to SLP_LAST_CALL.",
      "ja": "SLP_LAST_CALLコードはAPIライブラリが彼らのためにそれ以上のデータを持っていないので、それ以上のコールが現在卓越した操作上のコールバックに行われることはありません時にコールバック関数に渡されます。コールバックは、クライアントコードの本体がデータ収集ループから抜け出すことができるように、それ以上のデータが操作に来ることはないだろうクライアントコードの本体を知らせるためにこれを使用することができます。同期および非同期呼び出し中のコールバックの最後の呼び出しで、エラーコードパラメータは、値SLP_LAST_CALLを有し、そして他のパラメータは全てNULLです。何の結果はAPI操作で返されない場合は、コールは1つだけではSLP_LAST_CALLに設定されたエラーパラメータで、作られています。"
    },
    {
      "indent": 0,
      "text": "4.1.3. SLPBoolean",
      "section_title": true,
      "ja": "4.1.3。 SLPBoolean"
    },
    {
      "indent": 0,
      "text": "4.1.3.1. Synopsis",
      "section_title": true,
      "ja": "4.1.3.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "typedef enum {\n   SLP_FALSE = 0,\n   SLP_TRUE = 1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "} SLPBoolean;",
      "ja": "} SLPBoolean。"
    },
    {
      "indent": 0,
      "text": "4.1.3.2. Description",
      "section_title": true,
      "ja": "4.1.3.2。説明"
    },
    {
      "indent": 3,
      "text": "The SLPBoolean enum is used as a boolean flag.",
      "ja": "SLPBoolean列挙ブールフラグとして使用されます。"
    },
    {
      "indent": 0,
      "text": "4.2. Struct Types",
      "section_title": true,
      "ja": "4.2。構造体の種類"
    },
    {
      "indent": 0,
      "text": "4.2.1. SLPSrvURL",
      "section_title": true,
      "ja": "4.2.1。 SLPSrvURL"
    },
    {
      "indent": 0,
      "text": "4.2.1.1. Synopsis",
      "section_title": true,
      "ja": "4.2.1.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "typedef struct srvurl {\n  char *s_pcSrvType;\n  char *s_pcHost;\n  int   s_iPort;\n  char *s_pcNetFamily;\n  char *s_pcSrvPart;\n} SLPSrvURL;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2.1.2. Description",
      "section_title": true,
      "ja": "4.2.1.2。説明"
    },
    {
      "indent": 3,
      "text": "The SLPSrvURL structure is filled in by the SLPParseSrvURL() function with information parsed from a character buffer containing a service URL. The fields correspond to different parts of the URL. Note that the structure is in conformance with the standard Berkeley sockets struct servent, with the exception that the pointer to an array of characters for aliases (s_aliases field) is replaced by the pointer to host name (s_pcHost field).",
      "ja": "SLPSrvURL構造は、サービスURLを含む文字バッファから解析された情報とSLPParseSrvURL（）関数によって充填されます。フィールドはURLの異なる部分に対応します。構造は、エイリアス（s_aliasesフィールド）のための文字の配列へのポインタは、名前（s_pcHostフィールド）ホストへのポインタで置き換えられていることを除いて、標準的なバークレーソケット構造体のサーバントに準拠していることに留意されたいです。"
    },
    {
      "indent": 6,
      "text": "s_pcSrvType",
      "ja": "s_pcSrvType"
    },
    {
      "indent": 9,
      "text": "A pointer to a character string containing the service type name, including naming authority. The service type name includes the \"service:\" if the URL is of the service: scheme. [7]",
      "ja": "権威を命名するなど、サービスタイプ名を含む文字列へのポインタ。 URLがサービスである場合：スキーム：サービスタイプ名は、「サービス」が含まれています。 [7]"
    },
    {
      "indent": 6,
      "text": "s_pcHost",
      "ja": "s_pcHost"
    },
    {
      "indent": 9,
      "text": "A pointer to a character string containing the host identification information.",
      "ja": "ホスト識別情報を含む文字列へのポインタ。"
    },
    {
      "indent": 6,
      "text": "s_iPort",
      "ja": "S_iport"
    },
    {
      "indent": 9,
      "text": "The port number, or zero if none. The port is only available if the transport is IP.",
      "ja": "ポート番号、またはゼロ。ない場合。ポートは、トランスポートがIPの場合にのみ使用可能です。"
    },
    {
      "indent": 6,
      "text": "s_pcNetFamily",
      "ja": "s_pcNetFamily"
    },
    {
      "indent": 9,
      "text": "A pointer to a character string containing the network address family identifier. Possible values are \"ipx\" for the IPX family, \"at\" for the Appletalk family, and \"\" (i.e. the empty string) for the IP address family.",
      "ja": "ネットワークアドレスファミリ識別子を含む文字列へのポインタ。可能な値は、IPアドレスファミリのAppleTalk家族のため、そして「」（すなわち、空の文字列）「で」IPXの家族のための「IPX」、です。"
    },
    {
      "indent": 6,
      "text": "s_pcSrvPart",
      "ja": "s_pcSrvPart"
    },
    {
      "indent": 9,
      "text": "The remainder of the URL, after the host identification.",
      "ja": "ホスト識別後のURLの残りの部分。"
    },
    {
      "indent": 3,
      "text": "The host and port should be sufficient to open a socket to the machine hosting the service, and the remainder of the URL should allow further differentiation of the service.",
      "ja": "ホストとポートは、サービスをホストしているマシンへのソケットをオープンするのに十分であるべきであり、URLの残りの部分は、サービスの更なる差別化を可能にしなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2.2. SLPHandle",
      "section_title": true,
      "ja": "4.2.2。 SLPHandle"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. Synopsis",
      "section_title": true,
      "ja": "4.2.2.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "typedef void* SLPHandle;",
      "ja": "typedef void *型SLPHandle。"
    },
    {
      "indent": 3,
      "text": "The SLPHandle type is returned by SLPOpen() and is a parameter to all SLP functions. It serves as a handle for all resources allocated on behalf of the process by the SLP library. The type is opaque, since the exact nature differs depending on the implementation.",
      "ja": "SLPHandleタイプはSLPOpen（）によって返された、すべてのSLP関数のパラメータです。これは、SLPライブラリによってプロセスのために割り当てられたすべてのリソースのハンドルとして機能します。正確な性質は、実装によって異なりますので、種類は、不透明です。"
    },
    {
      "indent": 0,
      "text": "4.3. Callbacks",
      "section_title": true,
      "ja": "4.3。コールバック"
    },
    {
      "indent": 3,
      "text": "A function pointer to a callback function specific to a particular API operation is included in the parameter list when the API function is invoked. The callback function is called with the results of the operation in both the synchronous and asynchronous cases. The memory included in the callback parameters is owned by the API library, and the client code in the callback must copy out the contents if it wants to maintain the information longer than the duration of the current callback call.",
      "ja": "API関数が呼び出されたときに特定のAPI操作に特定のコールバック関数への関数ポインタは、パラメータリストに含まれています。コールバック関数は、同期と非同期の両方の場合の動作の結果と呼ばれます。コールバックパラメータに含まれるメモリは、APIライブラリによって所有され、それが現在のコールバックコールの持続時間よりも長い情報を維持したい場合は、コールバックでのクライアントコードは、内容をコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition to parameters for reporting the results of the operation, each callback parameter list contains an error code parameter and a cookie parameter. The error code parameter reports the error status of the ongoing (for asynchronous) or completed (for synchronous) operation. The cookie parameter allows the client code that starts the operation by invoking the API function to pass information down to the callback without using global variables. The callback returns an SLPBoolean to indicate whether the API library should continue processing the operation. If the value returned from the callback is",
      "ja": "操作の結果を報告するためのパラメータに加えて、各コールバックパラメータリストは、エラーコードパラメータとクッキーのパラメータを含んでいます。エラーコードパラメータは、進行中の（非同期の場合）または（同期のために）完了した操作のエラーステータスを報告します。クッキーのパラメータは、グローバル変数を使用せずにコールバックに情報を伝承するためにAPI関数を呼び出すことによって動作を開始し、クライアントコードすることができます。コールバックは、APIライブラリは、操作の処理を続行するかどうかを示すためにSLPBooleanを返します。コールバックから返された値がある場合"
    },
    {
      "indent": 3,
      "text": "SLP_TRUE, asynchronous operations are terminated, synchronous operations ignore the return (since the operation is already complete).",
      "ja": "非同期動作が終了される（動作が既に完了しているため）SLP_TRUEは、同期操作がリターンを無視します。"
    },
    {
      "indent": 0,
      "text": "4.3.1. SLPRegReport",
      "section_title": true,
      "ja": "4.3.1。 SLPRegReport"
    },
    {
      "indent": 0,
      "text": "4.3.1.1. Synopsis",
      "section_title": true,
      "ja": "4.3.1.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "typedef void SLPRegReport(SLPHandle hSLP, SLPError errCode, void *pvCookie);",
      "ja": "typedefは無効SLPRegReport（SLPHandle hSLP、SLPError ERRCODE、void *型pvCookie）。"
    },
    {
      "indent": 0,
      "text": "4.3.1.2. Description",
      "section_title": true,
      "ja": "4.3.1.2。説明"
    },
    {
      "indent": 3,
      "text": "The SLPRegReport callback type is the type of the callback function to the SLPReg(), SLPDereg(), and SLPDelAttrs() functions.",
      "ja": "SLPRegReportコールバックタイプSLPReg（）、SLPDereg（）、及びSLPDelAttrs（）関数へのコールバック関数の一種です。"
    },
    {
      "indent": 0,
      "text": "4.3.1.3. Parameters",
      "section_title": true,
      "ja": "4.3.1.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "hSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle used to initiate the operation.",
      "ja": "SLPHandleは動作を開始するために使用されます。"
    },
    {
      "indent": 6,
      "text": "errCode",
      "ja": "ERRCODE"
    },
    {
      "indent": 9,
      "text": "An error code indicating if an error occurred during the operation.",
      "ja": "操作中にエラーが発生したかどうかを示すエラーコード。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvCookie"
    },
    {
      "indent": 9,
      "text": "Memory passed down from the client code that called the original API function, starting the operation. May be NULL.",
      "ja": "メモリは動作を開始し、オリジナルのAPI関数を呼び出し、クライアントコードから伝わります。 nullの場合もあります。"
    },
    {
      "indent": 0,
      "text": "4.3.2. SLPSrvTypeCallback",
      "section_title": true,
      "ja": "4.3.2。 SLPSrvTypeCallback"
    },
    {
      "indent": 0,
      "text": "4.3.2.1. Synopsis",
      "section_title": true,
      "ja": "4.3.2.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "typedef SLPBoolean SLPSrvTypeCallback(SLPHandle hSLP, const char* pcSrvTypes, SLPError errCode, void *pvCookie);",
      "ja": "typedefのSLPBoolean SLPSrvTypeCallback（SLPHandle hSLP、constのchar型* pcSrvTypes、SLPError ERRCODE、void *型pvCookie）。"
    },
    {
      "indent": 0,
      "text": "4.3.2.2. Description",
      "section_title": true,
      "ja": "4.3.2.2。説明"
    },
    {
      "indent": 3,
      "text": "The SLPSrvTypeCallback type is the type of the callback function parameter to SLPFindSrvTypes() function. If the hSLP handle parameter was opened asynchronously, the results returned through the callback MAY be uncollated. If the hSLP handle parameter was opened synchronously, then the returned results must be collated and duplicates eliminated.",
      "ja": "SLPSrvTypeCallbackタイプはSLPFindSrvTypes（）関数へのコールバック関数パラメータのタイプです。 hSLPハンドルパラメータが非同期で開いた場合、その結果は、コールバックによって返さUNCOLLATEDかもしれません。 hSLPハンドルパラメータが同期的に開かれた場合、返される結果を照合し、重複を排除しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.3.2.3. Parameters",
      "section_title": true,
      "ja": "4.3.2.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "hSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle used to initiate the operation.",
      "ja": "SLPHandleは動作を開始するために使用されます。"
    },
    {
      "indent": 6,
      "text": "pcSrvTypes",
      "ja": "pcSrvTypes"
    },
    {
      "indent": 9,
      "text": "A character buffer containing a comma separated, null terminated list of service types.",
      "ja": "カンマ区切りを含む文字バッファは、ヌルは、サービスタイプのリストを終了しました。"
    },
    {
      "indent": 6,
      "text": "errCode",
      "ja": "ERRCODE"
    },
    {
      "indent": 9,
      "text": "An error code indicating if an error occurred during the operation. The callback should check this error code before processing the parameters. If the error code is other than SLP_OK, then the API library may choose to terminate the outstanding operation.",
      "ja": "操作中にエラーが発生したかどうかを示すエラーコード。コールバックは、パラメータを処理する前に、このエラーコードを確認してください。エラーコードがSLP_OK以外の場合は、APIライブラリは、優れた操作を終了することもできます。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvCookie"
    },
    {
      "indent": 9,
      "text": "Memory passed down from the client code that called the original API function, starting the operation. May be NULL.",
      "ja": "メモリは動作を開始し、オリジナルのAPI関数を呼び出し、クライアントコードから伝わります。 nullの場合もあります。"
    },
    {
      "indent": 0,
      "text": "4.3.2.4. Returns",
      "section_title": true,
      "ja": "4.3.2.4。返却値"
    },
    {
      "indent": 3,
      "text": "The client code should return SLP_TRUE if more data is desired, otherwise SLP_FALSE.",
      "ja": "より多くのデータが所望される場合は、クライアントコードは、そうでない場合SLP_FALSEをSLP_TRUEを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.3. SLPSrvURLCallback",
      "section_title": true,
      "ja": "4.3.3。 SLPSrvURLCallback"
    },
    {
      "indent": 0,
      "text": "4.3.3.1. Synopsis",
      "section_title": true,
      "ja": "4.3.3.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "typedef SLPBoolean SLPSrvURLCallback(SLPHandle hSLP, const char* pcSrvURL, unsigned short sLifetime, SLPError errCode, void *pvCookie);",
      "ja": "SLPBoolean SLPSrvURLCallback（SLPHandle hSLP、constのchar型* pcSrvURL、符号なしの短いsLifetime、SLPError ERRCODE、void *型pvCookie）のtypedef。"
    },
    {
      "indent": 0,
      "text": "4.3.3.2. Description",
      "section_title": true,
      "ja": "4.3.3.2。説明"
    },
    {
      "indent": 3,
      "text": "The SLPSrvURLCallback type is the type of the callback function parameter to SLPFindSrvs() function. If the hSLP handle parameter was opened asynchronously, the results returned through the callback MAY be uncollated. If the hSLP handle parameter was opened synchronously, then the returned results must be collated and duplicates eliminated.",
      "ja": "SLPSrvURLCallbackタイプはSLPFindSrvs（）関数へのコールバック関数パラメータのタイプです。 hSLPハンドルパラメータが非同期で開いた場合、その結果は、コールバックによって返さUNCOLLATEDかもしれません。 hSLPハンドルパラメータが同期的に開かれた場合、返される結果を照合し、重複を排除しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.3.3.3. Parameters",
      "section_title": true,
      "ja": "4.3.3.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "hSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle used to initiate the operation.",
      "ja": "SLPHandleは動作を開始するために使用されます。"
    },
    {
      "indent": 6,
      "text": "pcSrvURL",
      "ja": "pcSrvURL"
    },
    {
      "indent": 9,
      "text": "A character buffer containing the returned service URL.",
      "ja": "返されたサービスのURLを含む文字バッファ。"
    },
    {
      "indent": 6,
      "text": "sLifetime",
      "ja": "sLifetime"
    },
    {
      "indent": 9,
      "text": "An unsigned short giving the life time of the service advertisement, in seconds. The value must be an unsigned integer less than or equal to SLP_LIFETIME_MAXIMUM.",
      "ja": "秒に、サービスアドバタイズメントのライフタイムを与える符号なしshort。値は以下SLP_LIFETIME_MAXIMUMに等しい符号なし整数でなければなりません。"
    },
    {
      "indent": 6,
      "text": "errCode",
      "ja": "ERRCODE"
    },
    {
      "indent": 9,
      "text": "An error code indicating if an error occurred during the operation. The callback should check this error code before processing the parameters. If the error code is other than SLP_OK, then the API library may choose to terminate the outstanding operation.",
      "ja": "操作中にエラーが発生したかどうかを示すエラーコード。コールバックは、パラメータを処理する前に、このエラーコードを確認してください。エラーコードがSLP_OK以外の場合は、APIライブラリは、優れた操作を終了することもできます。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvCookie"
    },
    {
      "indent": 9,
      "text": "Memory passed down from the client code that called the original API function, starting the operation. May be NULL.",
      "ja": "メモリは動作を開始し、オリジナルのAPI関数を呼び出し、クライアントコードから伝わります。 nullの場合もあります。"
    },
    {
      "indent": 0,
      "text": "4.3.3.4. Returns",
      "section_title": true,
      "ja": "4.3.3.4。返却値"
    },
    {
      "indent": 3,
      "text": "The client code should return SLP_TRUE if more data is desired, otherwise SLP_FALSE.",
      "ja": "より多くのデータが所望される場合は、クライアントコードは、そうでない場合SLP_FALSEをSLP_TRUEを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.4. SLPAttrCallback",
      "section_title": true,
      "ja": "4.3.4。 SLPAttrCallback"
    },
    {
      "indent": 0,
      "text": "4.3.4.1. Synopsis",
      "section_title": true,
      "ja": "4.3.4.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "typedef SLPBoolean SLPAttrCallback(SLPHandle hSLP, const char* pcAttrList, SLPError errCode, void *pvCookie);",
      "ja": "SLPBoolean SLPAttrCallback（SLPHandle hSLP、constのchar型* pcAttrList、SLPError ERRCODE、void *型pvCookie）のtypedef。"
    },
    {
      "indent": 0,
      "text": "4.3.4.2. Description",
      "section_title": true,
      "ja": "4.3.4.2。説明"
    },
    {
      "indent": 3,
      "text": "The SLPAttrCallback type is the type of the callback function parameter to SLPFindAttrs() function.",
      "ja": "SLPAttrCallbackタイプはSLPFindAttrs（）関数へのコールバック関数パラメータのタイプです。"
    },
    {
      "indent": 3,
      "text": "The behavior of the callback differs depending on whether the attribute request was by URL or by service type. If the SLPFindAttrs() operation was originally called with a URL, the callback is called once regardless of whether the handle was opened asynchronously or synchronously. The pcAttrList parameter contains the requested attributes as a comma separated list (or is empty if no attributes matched the original tag list).",
      "ja": "コールバックの振る舞いは、属性要求は、URLまたはサービスタイプであったかどうかによって異なります。 SLPFindAttrs（）操作は、もともとURLで呼び出された場合、コールバックは一度にかかわらず、ハンドルが非同期または同期開かれたかどうかに呼ばれています。 pcAttrListパラメータは、カンマ区切りリストとして要求された属性を含む（または、属性が元のタグのリストと一致しない場合は空です）。"
    },
    {
      "indent": 3,
      "text": "If the SLPFindAttrs() operation was originally called with a service type, the value of pcAttrList and calling behavior depend on whether the handle was opened asynchronously or synchronously. If the handle was opened asynchronously, the callback is called every time the API library has results from a remote agent. The pcAttrList parameter MAY be uncollated between calls. It contains a comma separated list with the results from the agent that immediately returned results. If the handle was opened synchronously, the results must be collated from all returning agents and the callback is called once, with the pcAttrList parameter set to the collated result.",
      "ja": "SLPFindAttrs（）操作は、もともとサービスタイプで呼び出された場合は、pcAttrListの値と呼び出し振る舞いは、ハンドルが非同期または同期開かれたかどうかによって異なります。ハンドルが非同期で開いた場合、コールバックは、APIライブラリは、リモートエージェントからの結果を持っているたびに呼び出されます。 pcAttrListパラメータは、呼び出しの間UNCOLLATEDかもしれません。それはすぐに結果を返したエージェントからの結果をカンマ区切りのリストが含まれています。ハンドルが同期開いた場合、その結果はすべて返すエージェントから照合する必要があり、コールバックは一度呼び出され、照合結果に設定pcAttrListパラメーターを指定しました。"
    },
    {
      "indent": 0,
      "text": "4.3.4.3. Parameters",
      "section_title": true,
      "ja": "4.3.4.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "hSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle used to initiate the operation.",
      "ja": "SLPHandleは動作を開始するために使用されます。"
    },
    {
      "indent": 6,
      "text": "pcAttrList",
      "ja": "pcAttrList"
    },
    {
      "indent": 9,
      "text": "A character buffer containing a comma separated, null terminated list of attribute id/value assignments, in SLP wire format; i.e. \"(attr-id=attr-value-list)\" [7].",
      "ja": "SLPワイヤ形式で、属性ID /値の割り当て、ヌル終了リストカンマ区切りを含む文字バッファとすなわち、 \"（ATTR-ID = ATTR値リスト）\" [7]。"
    },
    {
      "indent": 6,
      "text": "errCode",
      "ja": "ERRCODE"
    },
    {
      "indent": 9,
      "text": "An error code indicating if an error occurred during the operation. The callback should check this error code before processing the parameters. If the error code is other than SLP_OK, then the API library may choose to terminate the outstanding operation.",
      "ja": "操作中にエラーが発生したかどうかを示すエラーコード。コールバックは、パラメータを処理する前に、このエラーコードを確認してください。エラーコードがSLP_OK以外の場合は、APIライブラリは、優れた操作を終了することもできます。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvCookie"
    },
    {
      "indent": 9,
      "text": "Memory passed down from the client code that called the original API function, starting the operation. May be NULL.",
      "ja": "メモリは動作を開始し、オリジナルのAPI関数を呼び出し、クライアントコードから伝わります。 nullの場合もあります。"
    },
    {
      "indent": 0,
      "text": "4.3.4.4. Returns",
      "section_title": true,
      "ja": "4.3.4.4。返却値"
    },
    {
      "indent": 3,
      "text": "The client code should return SLP_TRUE if more data is desired, otherwise SLP_FALSE.",
      "ja": "より多くのデータが所望される場合は、クライアントコードは、そうでない場合SLP_FALSEをSLP_TRUEを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Opening and Closing an SLPHandle",
      "section_title": true,
      "ja": "4.4。 SLPHandleを開閉"
    },
    {
      "indent": 0,
      "text": "4.4.1. SLPOpen",
      "section_title": true,
      "ja": "4.4.1。 SLPOpen"
    },
    {
      "indent": 0,
      "text": "4.4.1.1. Synopsis",
      "section_title": true,
      "ja": "4.4.1.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "SLPError SLPOpen(const char *pcLang, SLPBoolean isAsync, SLPHandle *phSLP);",
      "ja": "SLPError SLPOpen（CONSTチャー* pcLang、SLPBooleanのisAsync、SLPHandle * phSLP）。"
    },
    {
      "indent": 0,
      "text": "4.4.1.2. Description",
      "section_title": true,
      "ja": "4.4.1.2。説明"
    },
    {
      "indent": 3,
      "text": "Returns a SLPHandle handle in the phSLP parameter for the language locale passed in as the pcLang parameter. The client indicates if operations on the handle are to be synchronous or asynchronous through the isAsync parameter. The handle encapsulates the language locale for SLP requests issued through the handle, and any other resources required by the implementation. However, SLP properties are not encapsulated by the handle; they are global. The return value of the function is an SLPError code indicating the status of the operation. Upon failure, the phSLP parameter is NULL.",
      "ja": "pcLangパラメータとして渡された言語ロケールのphSLPパラメータでSLPHandleハンドルを返します。ハンドルの操作はのisAsyncパラメータを使用して同期または非同期にしている場合、クライアントを示します。ハンドルは、SLPハンドルを通じて発行された要求、およびインプリメンテーションが必要とするその他のリソースの言語ロケールをカプセル化します。しかし、SLPのプロパティは、ハンドルによってカプセル化されていません。彼らはグローバルです。関数の戻り値は、操作の状態を示すSLPErrorコードです。障害が発生すると、phSLPパラメータがNULLです。"
    },
    {
      "indent": 3,
      "text": "An SLPHandle can only be used for one SLP API operation at a time. If the original operation was started asynchronously, any attempt to start an additional operation on the handle while the original operation is pending results in the return of an SLP_HANDLE_IN_USE error from the API function. The SLPClose() API function terminates any outstanding calls on the handle. If an implementation is unable to support a asynchronous( resp. synchronous) operation, due to memory constraints or lack of threading support, the SLP_NOT_IMPLEMENTED flag may be returned when the isAsync flag is",
      "ja": "SLPHandleは、一度に1つのSLPのAPI操作に使用することができます。本来の動作は非同期で開始された場合は、元の操作はAPI関数からSLP_HANDLE_IN_USEエラーの戻り値で結果を保留している間、任意の試みは、ハンドルの上に追加の操作を開始します。 SLPClose（）API関数は、ハンドル上の未解決のコールを終了します。実装はメモリの制約または支持体を通すの欠如に起因する非同期（それぞれ同期）動作をサポートすることができない場合のisAsyncフラグがある場合、SLP_NOT_IMPLEMENTEDフラグを返すことができます"
    },
    {
      "indent": 3,
      "text": "SLP_TRUE (resp. SLP_FALSE).",
      "ja": "SLP_TRUE（RESP。SLP_FALSE）。"
    },
    {
      "indent": 0,
      "text": "4.4.1.3. Parameters",
      "section_title": true,
      "ja": "4.4.1.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "pcLang",
      "ja": "pcLang"
    },
    {
      "indent": 9,
      "text": "A pointer to an array of characters containing the RFC 1766 Language Tag [6] for the natural language locale of requests and registrations issued on the handle.",
      "ja": "ハンドルに発行された要求と登録の自然言語ロケールのための[6] RFC 1766言語タグを含む文字の配列へのポインタ。"
    },
    {
      "indent": 6,
      "text": "isAsync",
      "ja": "isAsync"
    },
    {
      "indent": 9,
      "text": "An SLPBoolean indicating whether the SLPHandle should be opened for asynchronous operation or not.",
      "ja": "SLPHandleは、非同期操作のためか開かれるかどうかを示すSLPBoolean。"
    },
    {
      "indent": 6,
      "text": "phSLP",
      "ja": "phSLP"
    },
    {
      "indent": 9,
      "text": "A pointer to an SLPHandle, in which the open SLPHandle is returned. If an error occurs, the value upon return is NULL.",
      "ja": "オープンSLPHandleが返されるSLPHandleへのポインタ。エラーが発生した場合、復帰時値はNULLです。"
    },
    {
      "indent": 0,
      "text": "4.4.2. SLPClose",
      "section_title": true,
      "ja": "4.4.2。 SLPClose"
    },
    {
      "indent": 0,
      "text": "4.4.2.1. Synopsis",
      "section_title": true,
      "ja": "4.4.2.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "void SLPClose(SLPHandle hSLP);",
      "ja": "空SLPClose（SLPHandle hSLP）。"
    },
    {
      "indent": 0,
      "text": "4.4.2.2. Description",
      "section_title": true,
      "ja": "4.4.2.2。説明"
    },
    {
      "indent": 3,
      "text": "Frees all resources associated with the handle. If the handle was invalid, the function returns silently. Any outstanding synchronous or asynchronous operations are cancelled so their callback functions will not be called any further.",
      "ja": "ハンドルに関連付けられたすべてのリソースを解放します。ハンドルが無効だった場合、この関数は黙って返します。そのコールバック関数は、任意のさらなる呼び出されませんので、未処理の同期または非同期操作がキャンセルされています。"
    },
    {
      "indent": 0,
      "text": "4.4.2.3. Parameters",
      "section_title": true,
      "ja": "4.4.2.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "SLPHandle",
      "ja": "SLPHandle"
    },
    {
      "indent": 9,
      "text": "A SLPHandle handle returned from a call to SLPOpen().",
      "ja": "SLPHandleハンドル）がSLPOpen（への呼び出しから返されました。"
    },
    {
      "indent": 0,
      "text": "4.5. Protocol API",
      "section_title": true,
      "ja": "4.5。プロトコルAPI"
    },
    {
      "indent": 0,
      "text": "4.5.1. SLPReg",
      "section_title": true,
      "ja": "4.5.1。 SLPReg"
    },
    {
      "indent": 0,
      "text": "4.5.1.1. Synopsis",
      "section_title": true,
      "ja": "4.5.1.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "SLPError SLPReg(SLPHandle hSLP, const char *pcSrvURL, const unsigned short usLifetime, const char *pcSrvType, const char *pcAttrs SLPBoolean fresh, SLPRegReport callback, void *pvCookie);",
      "ja": "SLPError SLPReg（SLPHandle hSLP、CONSTのchar * pcSrvURL、CONST符号なしの短いusLifetime、CONSTするchar * pcSrvType、CONSTのchar * pcAttrs SLPBoolean新鮮、SLPRegReportコールバック、ボイド* pvCookie）。"
    },
    {
      "indent": 0,
      "text": "4.5.1.2. Description",
      "section_title": true,
      "ja": "4.5.1.2。説明"
    },
    {
      "indent": 3,
      "text": "Registers the URL in pcSrvURL having the lifetime usLifetime with the attribute list in pcAttrs. The pcAttrs list is a comma separated list of attribute assignments in the wire format (including escaping of reserved characters). The usLifetime parameter must be nonzero and less than or equal to SLP_LIFETIME_MAXIMUM. If the fresh flag is SLP_TRUE, then the registration is new (the SLP protocol FRESH flag is set) and the registration replaces any existing registrations. The pcSrvType parameter is a service type name and can be included for service URLs that are not in the service: scheme. If the URL is in the service: scheme, the pcSrvType parameter is ignored. If the fresh flag is SLP_FALSE, then an existing registration is updated. Rules for new and updated registrations, and the format for pcAttrs and pcScopeList can be found in [7]. Registrations and updates take place in the language locale of the hSLP handle.",
      "ja": "pcAttrsでの属性リストと寿命をusLifetime持つpcSrvURLでURLを登録します。 pcAttrsリスト（予約文字のエスケープを含む）は、ワイヤ形式で属性割り当てのコンマ区切りのリストです。 usLifetimeパラメータは非ゼロと以下SLP_LIFETIME_MAXIMUMに等しくなければなりません。新鮮なフラグがSLP_TRUEであれば、登録は（SLPプロトコルFRESHフラグが設定されている）、新規であると登録は、既存の登録を置き換えます。 pcSrvTypeパラメータは、サービスタイプ名で、サービスに含まれていないサービスのURLのために含めることができる：スキーム。 URLがサービスである場合：スキーム、pcSrvTypeパラメータは無視されます。新鮮なフラグがSLP_FALSEであれば、既存の登録が更新されます。新規および更新登録のための規則、およびpcAttrsとpcScopeListの形式は、[7]に記載されています。登録と更新はhSLPハンドルの言語ロケールで行われます。"
    },
    {
      "indent": 3,
      "text": "The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "APIライブラリは、構成によって得られたすべてのスコープで操作を行う必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5.1.3. Parameters",
      "section_title": true,
      "ja": "4.5.1.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "hSLP"
    },
    {
      "indent": 9,
      "text": "The language specific SLPHandle on which to register the advertisement.",
      "ja": "広告を登録するに言語固有のSLPHandle。"
    },
    {
      "indent": 6,
      "text": "pcSrvURL",
      "ja": "pcSrvURL"
    },
    {
      "indent": 9,
      "text": "The URL to register. May not be the empty string.",
      "ja": "URLを登録します。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "usLifetime",
      "ja": "usLifetime"
    },
    {
      "indent": 9,
      "text": "An unsigned short giving the life time of the service advertisement, in seconds. The value must be an unsigned integer less than or equal to SLP_LIFETIME_MAXIMUM and greater than zero.",
      "ja": "秒に、サービスアドバタイズメントのライフタイムを与える符号なしshort。値は、符号なし整数以下SLP_LIFETIME_MAXIMUMに等しく、ゼロより大きくなければなりません。"
    },
    {
      "indent": 6,
      "text": "pcSrvType",
      "ja": "pcSrvType"
    },
    {
      "indent": 9,
      "text": "The service type. If pURL is a service: URL, then this parameter is ignored.",
      "ja": "サービスタイプ。 PURLがサービスの場合：URLは、このパラメータは無視されます。"
    },
    {
      "indent": 6,
      "text": "pcAttrs",
      "ja": "pcAttrs"
    },
    {
      "indent": 9,
      "text": "A comma separated list of attribute assignment expressions for the attributes of the advertisement. Use empty string, \"\" for no attributes.",
      "ja": "コンマは、広告の属性の属性代入式のリストを分離しました。無属性の「」、空の文字列を使用してください。"
    },
    {
      "indent": 6,
      "text": "fresh",
      "ja": "新鮮な"
    },
    {
      "indent": 9,
      "text": "An SLPBoolean that is SLP_TRUE if the registration is new or SLP_FALSE if a reregistration.",
      "ja": "再登録場合、登録は、新規またはSLP FALSEであればSLP_TRUEあるSLPのブール。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話"
    },
    {
      "indent": 9,
      "text": "A callback to report the operation completion status.",
      "ja": "操作の完了状況を報告するためのコールバック。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvCookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからのコールバックのコードに渡されます。 nullの場合もあります。"
    },
    {
      "indent": 0,
      "text": "4.5.1.4. Returns",
      "section_title": true,
      "ja": "4.5.1.4。返却値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "エラーが動作を開始する際に発生した場合、SLPErrorコードのいずれかが返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.2. SLPDereg",
      "section_title": true,
      "ja": "4.5.2。 SLPDereg"
    },
    {
      "indent": 0,
      "text": "4.5.2.1. Synopsis",
      "section_title": true,
      "ja": "4.5.2.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "SLPError SLPDereg(SLPHandle hSLP, const char *pcURL, SLPRegReport callback, void *pvCookie);",
      "ja": "SLPError SLPDereg（SLPHandle hSLP、constのchar型* pcURL、SLPRegReportコールバック、void *型pvCookie）。"
    },
    {
      "indent": 0,
      "text": "4.5.2.2. Description",
      "section_title": true,
      "ja": "4.5.2.2。説明"
    },
    {
      "indent": 3,
      "text": "Deregisters the advertisement for URL pcURL in all scopes where the service is registered and all language locales. The deregistration is not just confined to the locale of the SLPHandle, it is in all locales. The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "サービスが登録されているすべてのスコープとすべての言語ロケールでのURL pcURLの広告の登録を解除します。登録解除はちょうどSLPHandleのロケールに限定されていない、それはすべてのロケールです。 APIライブラリは、構成によって得られたすべてのスコープで操作を行う必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5.2.3. Parameters",
      "section_title": true,
      "ja": "4.5.2.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "hSLP"
    },
    {
      "indent": 9,
      "text": "The language specific SLPHandle to use for deregistering.",
      "ja": "登録抹消のために使用する言語固有のSLPHandle。"
    },
    {
      "indent": 6,
      "text": "pcURL",
      "ja": "pcURL"
    },
    {
      "indent": 9,
      "text": "The URL to deregister. May not be the empty string.",
      "ja": "登録解除するURL。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話"
    },
    {
      "indent": 9,
      "text": "A callback to report the operation completion status.",
      "ja": "操作の完了状況を報告するためのコールバック。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvCookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからのコールバックのコードに渡されます。 nullの場合もあります。"
    },
    {
      "indent": 0,
      "text": "4.5.2.4. Returns",
      "section_title": true,
      "ja": "4.5.2.4。返却値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "エラーが動作を開始する際に発生した場合、SLPErrorコードのいずれかが返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.3. SLPDelAttrs",
      "section_title": true,
      "ja": "4.5.3。 SLPDelAttrs"
    },
    {
      "indent": 0,
      "text": "4.5.3.1. Synopsis",
      "section_title": true,
      "ja": "4.5.3.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "SLPError SLPDelAttrs(SLPHandle hSLP, const char *pcURL, const char *pcAttrs, SLPRegReport callback, void *pvCookie);",
      "ja": "SLPError SLPDelAttrs（SLPHandle hSLP、constのchar型* pcURL、constのchar型* pcAttrs、SLPRegReportコールバック、void *型pvCookie）。"
    },
    {
      "indent": 0,
      "text": "4.5.3.2. Description",
      "section_title": true,
      "ja": "4.5.3.2。説明"
    },
    {
      "indent": 3,
      "text": "Delete the selected attributes in the locale of the SLPHandle. The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "SLPHandleのロケールで選択した属性を削除します。 APIライブラリは、構成によって得られたすべてのスコープで操作を行う必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5.3.3. Parameters",
      "section_title": true,
      "ja": "4.5.3.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "hSLP"
    },
    {
      "indent": 9,
      "text": "The language specific SLPHandle to use for deleting attributes.",
      "ja": "属性を削除するために使用する言語固有のSLPHandle。"
    },
    {
      "indent": 6,
      "text": "pcURL",
      "ja": "pcURL"
    },
    {
      "indent": 9,
      "text": "The URL of the advertisement from which the attributes should be deleted. May not be the empty string.",
      "ja": "属性を削除する必要があり、そこから広告のURL。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "pcAttrs",
      "ja": "pcAttrs"
    },
    {
      "indent": 9,
      "text": "A comma separated list of attribute ids for the attributes to deregister. See Section 9.8 in [7] for a description of the list format. May not be the empty string.",
      "ja": "コンマは、登録を解除するには、属性の属性IDのリストを分離しました。リスト形式の説明については、[7]に、セクション9.8を参照。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話"
    },
    {
      "indent": 9,
      "text": "A callback to report the operation completion status.",
      "ja": "操作の完了状況を報告するためのコールバック。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvCookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからのコールバックのコードに渡されます。 nullの場合もあります。"
    },
    {
      "indent": 0,
      "text": "4.5.3.4. Returns",
      "section_title": true,
      "ja": "4.5.3.4。返却値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "エラーが動作を開始する際に発生した場合、SLPErrorコードのいずれかが返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.4. SLPFindSrvTypes",
      "section_title": true,
      "ja": "4.5.4。 SLPFindSrvTypes"
    },
    {
      "indent": 0,
      "text": "4.5.4.1. Synopsis",
      "section_title": true,
      "ja": "4.5.4.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "SLPError SLPFindSrvTypes(SLPHandle hSLP, const char *pcNamingAuthority, const char *pcScopeList, SLPSrvTypeCallback callback, void *pvCookie);",
      "ja": "SLPError SLPFindSrvTypes（SLPHandle hSLP、constのchar型* pcNamingAuthority、constのchar型* pcScopeList、SLPSrvTypeCallbackコールバック、void *型pvCookie）。"
    },
    {
      "indent": 3,
      "text": "The SLPFindSrvType() function issues an SLP service type request for service types in the scopes indicated by the pcScopeList. The results are returned through the callback parameter. The service types are independent of language locale, but only for services registered in one of scopes and for the indicated naming authority.",
      "ja": "SLPFindSrvType（）関数はpcScopeListによって示されるスコープ内のサービスタイプのためのSLPサービスタイプ要求を発行します。結果は、コールバックパラメータを使用して返されます。サービスタイプは、だけスコープのいずれかに登録されたサービスのためにと指示された命名機関のために、言語のロケールとは無関係です。"
    },
    {
      "indent": 3,
      "text": "If the naming authority is \"*\", then results are returned for all naming authorities. If the naming authority is the empty string, i.e. \"\", then the default naming authority, \"IANA\", is used. \"IANA\" is not a valid naming authority name, and it is a PARAMETER_BAD error to include it explicitly.",
      "ja": "命名機関は、「*」であれば、結果はすべての命名当局のために返されます。命名機関は、空の文字列、すなわち「ある場合」、そして権威を命名デフォルトでは、「IANA」が使用されています。 「IANAは、」有効な命名機関名ではありません、明示的に含まれるようにPARAMETER_BADエラーです。"
    },
    {
      "indent": 3,
      "text": "The service type names are returned with the naming authority intact. If the naming authority is the default (i.e. empty string) then it is omitted, as is the separating \".\". Service type names from URLs of the service: scheme are returned with the \"service:\" prefix intact. [7] See [8] for more information on the syntax of service type names.",
      "ja": "サービスタイプ名はそのまま命名機関で返されます。命名機関がデフォルト（すなわち、空の文字列）である場合、分離があるとして、省略されています「」。サービスのURLをからサービスタイプ名：接頭そのまま：スキームは、「サービス」と返されます。 [7]サービスタイプ名の構文の詳細については、[8]を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.5.4.2. Parameters",
      "section_title": true,
      "ja": "4.5.4.2。パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "hSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle on which to search for types.",
      "ja": "タイプを検索するにSLPHandle。"
    },
    {
      "indent": 6,
      "text": "pcNamingAuthority",
      "ja": "pcNamingAuthority"
    },
    {
      "indent": 9,
      "text": "The naming authority to search. Use \"*\" for all naming authorities and the empty string, \"\", for the default naming authority.",
      "ja": "検索する命名機関。デフォルトの命名権威のために、「」、すべての命名当局と空の文字列のために「*」を使用します。"
    },
    {
      "indent": 6,
      "text": "pcScopeList",
      "ja": "pcScopeList"
    },
    {
      "indent": 9,
      "text": "A pointer to a char containing comma separated list of scope names to search for service types. May not be the empty string, \"\".",
      "ja": "コンマを含むチャーへのポインタは、サービスタイプを検索するスコープ名のリストを分離しました。空の文字列、「」ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話"
    },
    {
      "indent": 9,
      "text": "A callback function through which the results of the operation are reported.",
      "ja": "演算の結果が報告されるときに通過するコールバック関数。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvCookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからのコールバックのコードに渡されます。 nullの場合もあります。"
    },
    {
      "indent": 0,
      "text": "4.5.4.3. Returns",
      "section_title": true,
      "ja": "4.5.4.3。返却値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "エラーが動作を開始する際に発生した場合、SLPErrorコードのいずれかが返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.5. SLPFindSrvs",
      "section_title": true,
      "ja": "4.5.5。 SLPFindSrvs"
    },
    {
      "indent": 0,
      "text": "4.5.5.1. Synopsis",
      "section_title": true,
      "ja": "4.5.5.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "SLPError SLPFindSrvs(SLPHandle hSLP, const char *pcServiceType, const char *pcScopeList, const char *pcSearchFilter, SLPSrvURLCallback callback, void *pvCookie);",
      "ja": "SLPError SLPFindSrvs（SLPHandle hSLP、constのchar型* pcServiceType、constのchar型* pcScopeList、constのchar型* pcSearchFilter、SLPSrvURLCallbackコールバック、void *型pvCookie）。"
    },
    {
      "indent": 0,
      "text": "4.5.5.2. Description",
      "section_title": true,
      "ja": "4.5.5.2。説明"
    },
    {
      "indent": 3,
      "text": "Issue the query for services on the language specific SLPHandle and return the results through the callback. The parameters determine the results",
      "ja": "言語固有SLPHandle上のサービスのためのクエリを発行し、コールバックを通じて結果を返します。パラメータは、結果を決定します"
    },
    {
      "indent": 0,
      "text": "4.5.5.3. Parameters",
      "section_title": true,
      "ja": "4.5.5.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "hSLP"
    },
    {
      "indent": 9,
      "text": "The language specific SLPHandle on which to search for services.",
      "ja": "言語サービスを検索する上で特定のSLPHandle。"
    },
    {
      "indent": 6,
      "text": "pcServiceType",
      "ja": "pcServiceType"
    },
    {
      "indent": 9,
      "text": "The Service Type String, including authority string if any, for the request, such as can be discovered using SLPSrvTypes(). This could be, for example \"service:printer:lpr\" or \"service:nfs\". May not be the empty string.",
      "ja": "SLPSrvTypesを使用して発見することができますなどの要求に対してあれば権限文字列を含むサービスタイプ文字列、、（）。または「サービス：NFS」これは、例えば「：プリンタLPRサービス」である可能性があります。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "pcScopeList",
      "ja": "pcScopeList"
    },
    {
      "indent": 9,
      "text": "A pointer to a char containing comma separated list of scope names. May not be the empty string, \"\".",
      "ja": "コンマを含むチャーへのポインタは、スコープ名のリストを分離しました。空の文字列、「」ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "pcSearchFilter",
      "ja": "pcSearchFilter"
    },
    {
      "indent": 9,
      "text": "A query formulated of attribute pattern matching expressions in the form of a LDAPv3 Search Filter, see [4]. If this filter is empty, i.e. \"\", all services of the requested type in the specified scopes are returned.",
      "ja": "LDAPv3の検索フィルタの形式で属性パターンマッチング式の処方クエリは、参照[4]。このフィルタは、すなわち「」空の場合は、指定されたスコープで要求されたタイプのすべてのサービスが返されます。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話"
    },
    {
      "indent": 9,
      "text": "A callback function through which the results of the operation are reported.",
      "ja": "演算の結果が報告されるときに通過するコールバック関数。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvCookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからのコールバックのコードに渡されます。 nullの場合もあります。"
    },
    {
      "indent": 0,
      "text": "4.5.5.4. Returns",
      "section_title": true,
      "ja": "4.5.5.4。返却値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "エラーが動作を開始する際に発生した場合、SLPErrorコードのいずれかが返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.6. SLPFindAttrs",
      "section_title": true,
      "ja": "4.5.6。 SLPFindAttrs"
    },
    {
      "indent": 0,
      "text": "4.5.6.1. Synopsis",
      "section_title": true,
      "ja": "4.5.6.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "SLPError SLPFindAttrs(SLPHandle hSLP, const char *pcURLOrServiceType, const char *pcScopeList, const char *pcAttrIds, SLPAttrCallback callback, void *pvCookie);",
      "ja": "SLPError SLPFindAttrs（SLPHandle hSLP、constのchar型* pcURLOrServiceType、CONSTするchar * pcScopeList、CONSTのchar * pcAttrIds、SLPAttrCallbackコールバック、void *型pvCookie）。"
    },
    {
      "indent": 0,
      "text": "4.5.6.2. Description",
      "section_title": true,
      "ja": "4.5.6.2。説明"
    },
    {
      "indent": 3,
      "text": "This function returns service attributes matching the attribute ids for the indicated service URL or service type. If pcURLOrServiceType is a service URL, the attribute information returned is for that particular advertisement in the language locale of the SLPHandle.",
      "ja": "この関数は、指定されたサービスのURLまたはサービスタイプの属性IDに一致するサービス属性を返します。 pcURLOrServiceTypeがサービスURLである場合、返される属性情報は、SLPHandleの言語ロケールでその特定の広告のためです。"
    },
    {
      "indent": 3,
      "text": "If pcURLOrServiceType is a service type name (including naming authority if any), then the attributes for all advertisements of that service type are returned regardless of the language of registration. Results are returned through the callback.",
      "ja": "pcURLOrServiceTypeが（もしあれば権威を命名含む）サービスタイプの名前である場合、そのサービスタイプのすべての広告の属性にかかわらず、登録の言語の返されます。結果は、コールバックによって返されます。"
    },
    {
      "indent": 3,
      "text": "The result is filtered with an SLP attribute request filter string parameter, the syntax of which is described in [7]. If the filter string is the empty string, i.e. \"\", all attributes are returned.",
      "ja": "結果は、SLP属性要求フィルター文字列パラメータと[7]に記載された構文を濾過します。フィルタ文字列が空の文字列、すなわち「」である場合、すべての属性が返されます。"
    },
    {
      "indent": 0,
      "text": "4.5.6.3. Parameters",
      "section_title": true,
      "ja": "4.5.6.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "hSLP"
    },
    {
      "indent": 9,
      "text": "The language specific SLPHandle on which to search for attributes.",
      "ja": "言語の属性を検索するための特定のSLPHandle。"
    },
    {
      "indent": 6,
      "text": "pcURLOrServiceType",
      "ja": "pcURLOrServiceType"
    },
    {
      "indent": 9,
      "text": "The service URL or service type. See [7] for URL and service type syntax. May not be the empty string.",
      "ja": "サービスのURLまたはサービスタイプ。 URLおよびサービスタイプ構文については、[7]を参照してください。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "pcScopeList",
      "ja": "pcScopeList"
    },
    {
      "indent": 9,
      "text": "A pointer to a char containing a comma separated list of scope names. May not be the empty string, \"\".",
      "ja": "スコープ名のカンマ区切りリストを含む文字へのポインタ。空の文字列、「」ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "pcAttrIds",
      "ja": "pcAttrIds"
    },
    {
      "indent": 9,
      "text": "The filter string indicating which attribute values to return. Use empty string, \"\", to indicate all values. Wildcards matching all attribute ids having a particular prefix or suffix are also possible. See [7] for the exact format of the filter string.",
      "ja": "属性値を示すフィルタ文字列が返されます。すべての値を示すために、「」、空の文字列を使用してください。特定の接頭辞または接尾辞を持つすべての属性IDに一致するワイルドカードも可能です。フィルタ文字列の正確な形式[7]参照。"
    },
    {
      "indent": 6,
      "text": "callback",
      "ja": "折り返し電話"
    },
    {
      "indent": 9,
      "text": "A callback function through which the results of the operation are reported.",
      "ja": "演算の結果が報告されるときに通過するコールバック関数。"
    },
    {
      "indent": 6,
      "text": "pvCookie",
      "ja": "pvCookie"
    },
    {
      "indent": 9,
      "text": "Memory passed to the callback code from the client. May be NULL.",
      "ja": "メモリは、クライアントからのコールバックのコードに渡されます。 nullの場合もあります。"
    },
    {
      "indent": 0,
      "text": "4.5.6.4. Returns",
      "section_title": true,
      "ja": "4.5.6.4。返却値"
    },
    {
      "indent": 3,
      "text": "If an error occurs in starting the operation, one of the SLPError codes is returned.",
      "ja": "エラーが動作を開始する際に発生した場合、SLPErrorコードのいずれかが返されます。"
    },
    {
      "indent": 0,
      "text": "4.6. Miscellaneous Functions",
      "section_title": true,
      "ja": "4.6。その他の関数"
    },
    {
      "indent": 0,
      "text": "4.6.1. SLPGetRefreshInterval",
      "section_title": true,
      "ja": "4.6.1。 SLPGetRefreshInterval"
    },
    {
      "indent": 0,
      "text": "4.6.1.1. Synopsis",
      "section_title": true,
      "ja": "4.6.1.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "unsigned short SLPGetRefreshInterval();",
      "ja": "符号なしの短いSLPGetRefreshInterval（）。"
    },
    {
      "indent": 0,
      "text": "4.6.1.2. Description",
      "section_title": true,
      "ja": "4.6.1.2。説明"
    },
    {
      "indent": 3,
      "text": "Returns the maximum across all DAs of the min-refresh-interval attribute. This value satisfies the advertised refresh interval bounds for all DAs, and, if used by the SA, assures that no refresh registration will be rejected. If no DA advertises a min-refresh-interval attribute, a value of 0 is returned.",
      "ja": "min-refresh-interval属性のすべてのDA間で最大値を返します。この値は、すべてのDAのための広告を出してリフレッシュ間隔の範囲を満たし、かつ、SAが使用している場合、何のリフレッシュ登録が拒否されないことを保証します。何DAが最小リフレッシュ間隔属性をアドバタイズしていない場合は、0の値が返されます。"
    },
    {
      "indent": 0,
      "text": "4.6.1.3. Returns",
      "section_title": true,
      "ja": "4.6.1.3。返却値"
    },
    {
      "indent": 3,
      "text": "If no error, the maximum refresh interval value allowed by all DAs (a positive integer). If no DA advertises a min-refresh-interval attribute, returns 0. If an error occurs, returns an SLP error code.",
      "ja": "エラー無しであれば、すべてのDAによって許容される最大リフレッシュ間隔値（正の整数）。何DAが最小リフレッシュ間隔属性をアドバタイズしない場合、エラーが発生した場合、0を返すSLPエラーコードを返します。"
    },
    {
      "indent": 0,
      "text": "4.6.2. SLPFindScopes",
      "section_title": true,
      "ja": "4.6.2。 SLPFindScopes"
    },
    {
      "indent": 0,
      "text": "4.6.2.1. Synopsis",
      "section_title": true,
      "ja": "4.6.2.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "SLPError SLPFindScopes(SLPHandle hSLP, char** ppcScopeList);",
      "ja": "SLPError SLPFindScopes（SLPHandle hSLP、チャー** ppcScopeList）。"
    },
    {
      "indent": 0,
      "text": "4.6.2.2. Description",
      "section_title": true,
      "ja": "4.6.2.2。説明"
    },
    {
      "indent": 3,
      "text": "Sets ppcScopeList parameter to a pointer to a comma separated list including all available scope values. The list of scopes comes from a variety of sources: the configuration file's net.slp.useScopes property, unicast to DAs on the net.slp.DAAddresses property, DHCP, or through the DA discovery process. If there is any order to the scopes, preferred scopes are listed before less desirable scopes. There is always at least one name in the list, the default scope, \"DEFAULT\".",
      "ja": "ppcScopeListパラメータは、すべての利用可能な範囲の値を含むコンマ区切りリストへのポインタを設定します。スコープのリストは、さまざまなソースから来ている：設定ファイルのプロパティのnet.slp.useScopes、net.slp.DAAddressesプロパティ上のDAにユニキャスト、DHCP、またはDAの検出プロセスを通じて。スコープに任意の順序がある場合は、好ましい範囲はあまり望ましくスコープ前に記載されています。リスト内の少なくとも1人の名前、デフォルトのスコープ、「DEFAULT」は常にあります。"
    },
    {
      "indent": 0,
      "text": "4.6.2.3. Parameters",
      "section_title": true,
      "ja": "4.6.2.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "hSLP",
      "ja": "hSLP"
    },
    {
      "indent": 9,
      "text": "The SLPHandle on which to search for scopes.",
      "ja": "スコープを検索するにSLPHandle。"
    },
    {
      "indent": 6,
      "text": "ppcScopeList",
      "ja": "ppcScopeList"
    },
    {
      "indent": 9,
      "text": "A pointer to char pointer into which the buffer pointer is placed upon return. The buffer is null terminated. The memory should be freed by calling SLPFree().",
      "ja": "バッファポインタは復帰時に置かれるポインタをcharへのポインタ。バッファは、NULL終端されます。メモリはSLPFree（）を呼び出すことによって解放されなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.6.2.4. Returns",
      "section_title": true,
      "ja": "4.6.2.4。返却値"
    },
    {
      "indent": 3,
      "text": "If no error occurs, returns SLP_OK, otherwise, the appropriate error code.",
      "ja": "エラーが発生しない場合は、そうでなければSLP_OK、適切なエラーコードを返します。"
    },
    {
      "indent": 0,
      "text": "4.6.3. SLPParseSrvURL",
      "section_title": true,
      "ja": "4.6.3。 SLPParseSrvURL"
    },
    {
      "indent": 0,
      "text": "4.6.3.1. Synopsis",
      "section_title": true,
      "ja": "4.6.3.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "SLPError SLPParseSrvURL(char *pcSrvURL SLPSrvURL** ppSrvURL);",
      "ja": "SLPError SLPParseSrvURL（CHAR * pcSrvURL SLPSrvURL ** ppSrvURL）。"
    },
    {
      "indent": 0,
      "text": "4.6.3.2. Description",
      "section_title": true,
      "ja": "4.6.3.2。説明"
    },
    {
      "indent": 3,
      "text": "Parses the URL passed in as the argument into a service URL structure and returns it in the ppSrvURL pointer. If a parse error occurs, returns SLP_PARSE_ERROR. The input buffer pcSrvURL is destructively modified during the parse and used to fill in the fields of the return structure. The structure returned in ppSrvURL should be freed with SLPFreeURL(). If the URL has no service part, the s_pcSrvPart string is the empty string, \"\", i.e. not NULL. If pcSrvURL is not a service: URL, then the s_pcSrvType field in the returned data structure is the URL's scheme, which might not be the same as the service type under which the URL was registered. If the transport is IP, the s_pcTransport field is the empty string. If the transport is not IP or there is no port number, the s_iPort field is zero.",
      "ja": "サービスのURL構造に引数として渡されたURLを解析し、ppSrvURLポインタでそれを返します。パースエラーが発生した場合は、SLP_PARSE_ERRORを返します。入力バッファpcSrvURLは破壊的解析中に変更とリターン構造のフィールドに入力するために使用されます。 ppSrvURLで返される構造体は、SLPFreeURLて解放する必要があります（）。 URLは何のサービス部分を持っていない場合は、s_pcSrvPart文字列が空の文字列、「」、つまりNULLではありません。 pcSrvURLがサービスされていない場合：URLは、返されたデータ構造でs_pcSrvTypeフィールドは、URLが登録された下のサービスの種類と同じではないかもしれないURLのスキーム、です。トランスポートがIPであれば、s_pcTransportフィールドが空の文字列です。トランスポートはIPではないか、ポート番号がない場合は、s_iPortフィールドはゼロです。"
    },
    {
      "indent": 0,
      "text": "4.6.3.3. Parameters",
      "section_title": true,
      "ja": "4.6.3.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "pcSrvURL",
      "ja": "pcSrvURL"
    },
    {
      "indent": 9,
      "text": "A pointer to a character buffer containing the null terminated URL string to parse. It is destructively modified to produce the output structure.",
      "ja": "解析するnullで終了URL文字列を含む文字バッファへのポインタ。破壊的出力構造を生成するように修正されます。"
    },
    {
      "indent": 6,
      "text": "ppSrvURL",
      "ja": "ppSrvURL"
    },
    {
      "indent": 9,
      "text": "A pointer to a pointer for the SLPSrvURL structure to receive the parsed URL. The memory should be freed by a call to SLPFree() when no longer needed.",
      "ja": "解析されたURLを受信するSLPSrvURL構造体のポインタへのポインタ。不要になったときにメモリがSLPFreeへの呼び出しで（）を解放する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.3.4. Returns",
      "section_title": true,
      "ja": "4.6.3.4。返却値"
    },
    {
      "indent": 3,
      "text": "If no error occurs, the return value is SLP_OK. Otherwise, the appropriate error code is returned.",
      "ja": "エラーが発生しなかった場合、戻り値はSLP_OKです。そうでない場合、適切なエラーコードが返されます。"
    },
    {
      "indent": 0,
      "text": "4.6.4. SLPEscape",
      "section_title": true,
      "ja": "4.6.4。 SLPEscape"
    },
    {
      "indent": 0,
      "text": "4.6.4.1. Synopsis",
      "section_title": true,
      "ja": "4.6.4.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "SLPError SLPEscape(const char* pcInbuf, char** ppcOutBuf, SLPBoolean isTag);",
      "ja": "SLPError SLPEscape（のconst char型*のpcInbuf、文字** ppcOutBuf、SLPBooleanのISTag）。"
    },
    {
      "indent": 0,
      "text": "4.6.4.2. Description",
      "section_title": true,
      "ja": "4.6.4.2。説明"
    },
    {
      "indent": 3,
      "text": "Process the input string in pcInbuf and escape any SLP reserved characters. If the isTag parameter is SLPTrue, then look for bad tag characters and signal an error if any are found by returning the SLP_PARSE_ERROR code. The results are put into a buffer allocated by the API library and returned in the ppcOutBuf parameter. This buffer should be deallocated using SLPFree() when the memory is no longer needed.",
      "ja": "pcInbufで入力文字列を処理し、任意のSLP予約文字をエスケープします。 ISTagパラメータがSLPTrueであれば、悪いタグ文字を探して、任意のSLP_PARSE_ERRORコードを返すことによって発見された場合、エラーを通知。結果は、APIライブラリによって割り当てられたバッファに入れ、ppcOutBufパラメータに返されます。このバッファはメモリが不要になったときSLPFree（）を使用していない割り当てを解除する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.4.3. Parameters",
      "section_title": true,
      "ja": "4.6.4.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "pcInbuf",
      "ja": "pcInbuf"
    },
    {
      "indent": 9,
      "text": "Pointer to he input buffer to process for escape characters.",
      "ja": "エスケープ文字のために処理するために、彼の入力バッファへのポインタ。"
    },
    {
      "indent": 6,
      "text": "ppcOutBuf",
      "ja": "ppcOutBuf"
    },
    {
      "indent": 9,
      "text": "Pointer to a pointer for the output buffer with the SLP reserved characters escaped. Must be freed using SLPFree() when the memory is no longer needed.",
      "ja": "予約文字をエスケープSLPと出力バッファのポインタへのポインタ。メモリが不要になったときSLPFree（）を使用して解放する必要があります。"
    },
    {
      "indent": 6,
      "text": "isTag",
      "ja": "ISTag"
    },
    {
      "indent": 9,
      "text": "When true, the input buffer is checked for bad tag characters.",
      "ja": "trueの場合、入力バッファが悪いタグ文字がチェックされます。"
    },
    {
      "indent": 0,
      "text": "4.6.4.4. Returns",
      "section_title": true,
      "ja": "4.6.4.4。返却値"
    },
    {
      "indent": 3,
      "text": "Return SLP_PARSE_ERROR if any characters are bad tag characters and the isTag flag is true, otherwise SLP_OK, or the appropriate error code if another error occurs.",
      "ja": "リターンSLP_PARSE_ERROR別のエラーが発生した場合、任意の文字が悪いタグ文字であるとのISTagフラグが真であり、そうでなければSLP_OK、または適切なエラーコード場合。"
    },
    {
      "indent": 0,
      "text": "4.6.5. SLPUnescape",
      "section_title": true,
      "ja": "4.6.5。 SLPUnescape"
    },
    {
      "indent": 0,
      "text": "4.6.5.1. Synopsis",
      "section_title": true,
      "ja": "4.6.5.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "SLPError SLPUnescape(const char* pcInbuf, char** ppcOutBuf, SLPBoolean isTag);",
      "ja": "SLPError SLPUnescape（のconst char型*のpcInbuf、文字** ppcOutBuf、SLPBooleanのISTag）。"
    },
    {
      "indent": 0,
      "text": "4.6.5.2. Description",
      "section_title": true,
      "ja": "4.6.5.2。説明"
    },
    {
      "indent": 3,
      "text": "Process the input string in pcInbuf and unescape any SLP reserved characters. If the isTag parameter is SLPTrue, then look for bad tag characters and signal an error if any are found with the SLP_PARSE_ERROR code. No transformation is performed if the input string is an opaque. The results are put into a buffer allocated by the API library and returned in the ppcOutBuf parameter. This buffer should be deallocated using SLPFree() when the memory is no longer needed.",
      "ja": "pcInbufで入力文字列を処理し、任意のSLP予約文字をエスケープ解除。 ISTagパラメータがSLPTrueであれば、悪いタグ文字を探して、いずれかがSLP_PARSE_ERRORコードで発見された場合はエラーを通知します。入力文字列が不透明であれば何の変換は行われません。結果は、APIライブラリによって割り当てられたバッファに入れ、ppcOutBufパラメータに返されます。このバッファはメモリが不要になったときSLPFree（）を使用していない割り当てを解除する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.5.3. Parameters",
      "section_title": true,
      "ja": "4.6.5.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "pcInbuf",
      "ja": "pcInbuf"
    },
    {
      "indent": 9,
      "text": "Pointer to he input buffer to process for escape characters.",
      "ja": "エスケープ文字のために処理するために、彼の入力バッファへのポインタ。"
    },
    {
      "indent": 6,
      "text": "ppcOutBuf",
      "ja": "ppcOutBuf"
    },
    {
      "indent": 9,
      "text": "Pointer to a pointer for the output buffer with the SLP reserved characters escaped. Must be freed using SLPFree() when the memory is no longer needed.",
      "ja": "予約文字をエスケープSLPと出力バッファのポインタへのポインタ。メモリが不要になったときSLPFree（）を使用して解放する必要があります。"
    },
    {
      "indent": 6,
      "text": "isTag",
      "ja": "ISTag"
    },
    {
      "indent": 9,
      "text": "When true, the input buffer is checked for bad tag characters.",
      "ja": "trueの場合、入力バッファが悪いタグ文字がチェックされます。"
    },
    {
      "indent": 0,
      "text": "4.6.5.4. Returns",
      "section_title": true,
      "ja": "4.6.5.4。返却値"
    },
    {
      "indent": 3,
      "text": "Return SLP_PARSE_ERROR if any characters are bad tag characters and the isTag flag is true, otherwise SLP_OK, or the appropriate error code if another error occurs.",
      "ja": "リターンSLP_PARSE_ERROR別のエラーが発生した場合、任意の文字が悪いタグ文字であるとのISTagフラグが真であり、そうでなければSLP_OK、または適切なエラーコード場合。"
    },
    {
      "indent": 0,
      "text": "4.6.6. SLPFree",
      "section_title": true,
      "ja": "4.6.6。 SLPFree"
    },
    {
      "indent": 0,
      "text": "4.6.6.1. Synopsis",
      "section_title": true,
      "ja": "4.6.6.1。シノプシス"
    },
    {
      "indent": 6,
      "text": "void SLPFree(void* pvMem);",
      "ja": "空SLPFree（void *型pvMem）。"
    },
    {
      "indent": 0,
      "text": "4.6.6.2. Description",
      "section_title": true,
      "ja": "4.6.6.2。説明"
    },
    {
      "indent": 3,
      "text": "Frees memory returned from SLPParseSrvURL(), SLPFindScopes(), SLPEscape(), and SLPUnescape().",
      "ja": "SLPParseSrvURL（から返されたメモリ）を解放し、SLPFindScopes（）、SLPEscape（）、及びSLPUnescape（）。"
    },
    {
      "indent": 0,
      "text": "4.6.6.3. Parameters",
      "section_title": true,
      "ja": "4.6.6.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "pvMem",
      "ja": "Pvmen"
    },
    {
      "indent": 9,
      "text": "A pointer to the storage allocated by the SLPParseSrvURL(), SLPEscape(), SLPUnescape(), or SLPFindScopes() function. Ignored if NULL.",
      "ja": "SLPParseSrvURL（）、SLPEscape（）、SLPUnescape（）、またはSLPFindScopes（）関数によって割り当てられた記憶領域へのポインタ。 NULLの場合は無視されます。"
    },
    {
      "indent": 0,
      "text": "4.6.7. SLPGetProperty",
      "section_title": true,
      "ja": "4.6.7。 SLPGetProperty"
    },
    {
      "indent": 0,
      "text": "4.6.7.1. Synopsis",
      "section_title": true,
      "ja": "4.6.7.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "const char* SLPGetProperty(const char* pcName);",
      "ja": "constのchar * SLPGetProperty（のconst char型*のpcName）。"
    },
    {
      "indent": 0,
      "text": "4.6.7.2. Description",
      "section_title": true,
      "ja": "4.6.7.2。説明"
    },
    {
      "indent": 3,
      "text": "Returns the value of the corresponding SLP property name. The returned string is owned by the library and MUST NOT be freed.",
      "ja": "対応するSLPのプロパティ名の値を返します。返される文字列は、ライブラリによって所有され、解放されてはなりません。"
    },
    {
      "indent": 0,
      "text": "4.6.7.3. Parameters",
      "section_title": true,
      "ja": "4.6.7.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "pcName",
      "ja": "pcName"
    },
    {
      "indent": 9,
      "text": "Null terminated string with the property name, from Section 2.1.",
      "ja": "ヌルはセクション2.1から、プロパティ名の文字列を終了しました。"
    },
    {
      "indent": 0,
      "text": "4.6.7.4. Returns",
      "section_title": true,
      "ja": "4.6.7.4。返却値"
    },
    {
      "indent": 3,
      "text": "If no error, returns a pointer to a character buffer containing the property value. If the property was not set, returns the default value. If an error occurs, returns NULL. The returned string MUST NOT be freed.",
      "ja": "エラーがない場合は、プロパティ値を含む文字バッファへのポインタを返します。プロパティが設定されていない場合は、デフォルト値を返します。エラーが発生した場合は、NULLを返します。返される文字列は解放されてはなりません。"
    },
    {
      "indent": 0,
      "text": "4.6.8. SLPSetProperty",
      "section_title": true,
      "ja": "4.6.8。 SLPSetProperty"
    },
    {
      "indent": 0,
      "text": "4.6.8.1. Synopsis",
      "section_title": true,
      "ja": "4.6.8.1。シノプシス"
    },
    {
      "indent": 6,
      "text": "void SLPSetProperty(const char *pcName,\n                    const char *pcValue);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.6.8.2. Description",
      "section_title": true,
      "ja": "4.6.8.2。説明"
    },
    {
      "indent": 3,
      "text": "Sets the value of the SLP property to the new value. The pcValue parameter should be the property value as a string.",
      "ja": "新しい値にSLPプロパティの値を設定します。 pcValueパラメータは文字列としてプロパティ値でなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.6.8.3. Parameters",
      "section_title": true,
      "ja": "4.6.8.3。パラメーター"
    },
    {
      "indent": 6,
      "text": "pcName",
      "ja": "pcName"
    },
    {
      "indent": 9,
      "text": "Null terminated string with the property name, from Section 2.1.",
      "ja": "ヌルはセクション2.1から、プロパティ名の文字列を終了しました。"
    },
    {
      "indent": 6,
      "text": "pcValue",
      "ja": "pcValue"
    },
    {
      "indent": 9,
      "text": "Null terminated string with the property value, in UTF-8 character encoding.",
      "ja": "ヌルは、UTF-8文字エンコーディングでは、プロパティ値を持つ文字列を終了しました。"
    },
    {
      "indent": 0,
      "text": "4.7. Implementation Notes",
      "section_title": true,
      "ja": "4.7。実装の注意事項"
    },
    {
      "indent": 0,
      "text": "4.7.1. Refreshing Registrations",
      "section_title": true,
      "ja": "4.7.1。さわやか登録"
    },
    {
      "indent": 3,
      "text": "Clients indicate that they want URLs to be automatically refreshed by setting the usLifetime parameter in the SLPReg() function call to SLP_LIFETIME_MAXIMUM. This will cause the API implementation to refresh the URL before it times out. Although using SLP_LIFETIME_MAXIMUM to designate automatic reregistration means that a transient URL can't be registered for the maximum lifetime, little hardship is likely to occur, since service URL lifetimes are measured in seconds and the client can simply use a lifetime of SLP_LIFETIME_MAXIMUM - 1 if a transient URL near the maximum lifetime is desired. API implementations MUST provide this facility.",
      "ja": "クライアントは、URLが自動的にSLP_LIFETIME_MAXIMUMにSLPReg（）関数呼び出しでusLifetimeパラメータを設定することで、リフレッシュしたいことを示しています。これは、その前にタイムアウトにURLをリフレッシュするためにAPIの実装が発生します。自動再登録を指定するSLP_LIFETIME_MAXIMUMを使用すると、過渡URLが最大寿命のために登録することができないことを意味しますが、サービスのURLの寿命を秒単位で測定されているので、少し苦労は、発生する可能性があり、クライアントは単にSLP_LIFETIME_MAXIMUMの寿命を使用することができます -  1であれば最大寿命に近い過渡URLが望まれています。 APIの実装は、この機能を提供しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.7.2. Syntax for String Parameters",
      "section_title": true,
      "ja": "4.7.2。文字列パラメータの構文"
    },
    {
      "indent": 3,
      "text": "Query strings, attribute registration lists, attribute deregistration lists, scope lists, and attribute selection lists follow the syntax described in [7] for the appropriate requests. The API directly reflects the strings passed in from clients into protocol requests, and directly reflects out strings returned from protocol replies to clients. As a consequence, clients are responsible for formatting request strings, including escaping and converting opaque values to escaped byte encoded strings. Similarly, on output, clients are required to unescape strings and convert escaped string encoded opaques to binary. The functions SLPEscape() and SLPUnescape() can be used for escaping SLP reserved characters, but perform no opaque processing.",
      "ja": "クエリ文字列、属性登録リスト、属性登録解除リスト、範囲リスト、および属性選択リストには、適切な要求に対して、[7]に記載されている構文に従ってください。 APIは、直接プロトコル要求にクライアントから渡された文字列を反映して、直接プロトコルから返された文字列を反映して、クライアントに応答します。その結果、クライアントは、エスケープとエスケープバイトエンコードされた文字列への不透明値を変換するなど、リクエスト文字列をフォーマットする責任があります。同様に、出力に、クライアントは、文字列をエスケープ解除し、バイナリにエスケープされた文字列エンコードopaquesを変換する必要があります。 SLPEscape（）とSLPUnescape（）関数は、SLP予約文字をエスケープするために使用されるが、しかし不透明な処理を行うことができません。"
    },
    {
      "indent": 3,
      "text": "Opaque values consist of a character buffer containing a UTF-8- encoded string, the first characters of which are the nonUTF-8 encoding '\\ff'. Subsequent characters are the escaped values for the original bytes in the opaque. The escape convention is relatively simple. An escape consists of a backslash followed by the two hexadecimal digits encoding the byte. An example is '\\2c' for the byte 0x2c. Clients handle opaque processing themselves, since the algorithm is relatively simple and uniform.",
      "ja": "不透明な値はUTF-8でエンコードされた文字列を含む文字バッファで構成され、最初の文字は、そのnonUTF-8エンコーディング「\\ FF」です。それ以降の文字は不透明で、元バイトのためのエスケープ値です。エスケープ規則は比較的簡単です。エスケープバイトをコードする2つの16進数字が続くバックスラッシュから成ります。例では、バイト0x2cのための「\\ 2cを」です。アルゴリズムは比較的単純かつ均一であるため、クライアントは、自分自身を処理する不透明なハンドル。"
    },
    {
      "indent": 0,
      "text": "4.7.3. Client Side Syntax Checking",
      "section_title": true,
      "ja": "4.7.3。クライアント側の構文チェック"
    },
    {
      "indent": 3,
      "text": "Client side API implementations may do syntax checking of scope names, naming authority names, and service type names, but are not required to do so. Since the C API is designed to be a thin layer over the protocol, some low memory SA implementations may find extensive syntax checking on the client side to be burdensome. If syntax checking uncovers an error in a parameter, the SLP_PARAMETER_BAD error must be returned. If any parameter is NULL and is required to be nonNULL, SLP_PARAMETER_BAD is returned.",
      "ja": "クライアント側のAPIの実装では、権限名、およびサービスタイプ名を命名、スコープ名の構文チェックを行うことができますが、その必要はありません。 C APIはプロトコル上に薄い層になるように設計されているので、いくつかの低メモリSA実装が厄介であることがクライアント側でチェック広範構文を見つけることができます。構文チェックは、パラメータに誤りが明らかにした場合、SLP_PARAMETER_BADエラーが返されなければなりません。任意のパラメータがNULLで、NULL以外にする必要がある場合は、SLP_PARAMETER_BADが返されます。"
    },
    {
      "indent": 0,
      "text": "4.7.4. System Properties",
      "section_title": true,
      "ja": "4.7.4。システムプロパティ"
    },
    {
      "indent": 3,
      "text": "The system properties established in the configuration file are accessible through the SLPGetProperty() and SLPSetProperty() functions. The SLPSetProperty() function only modifies properties in the running process, not in the configuration file. Properties are global to the process, affecting all threads and all handles created with SLPOpen. Errors are checked when the property is used and, as with parsing the configuration file, are logged. Program execution continues without interruption by substituting the default for the erroneous parameter. With the exception of net.slp.locale, net.slp.typeHint, and net.slp.maxResults, clients of the API should rarely be required to override these properties, since they reflect properties of the SLP network that are not of concern to individual agents. If changes are required, system administrators should modify the configuration file.",
      "ja": "構成ファイルで確立されたシステム特性はSLPGetProperty（）とSLPSetProperty（）関数を介してアクセス可能です。 SLPSetProperty（）関数は、実行中のプロセスではなく、構成ファイル内のプロパティを修正します。プロパティは、すべてのスレッドとSLPOpenで作成されたすべてのハンドルに影響を与え、プロセスにグローバルです。エラーは、設定ファイルの構文解析と同様に、ログに記録され、プロパティを使用する場合にチェックしています。プログラムの実行は、誤ったパラメータのデフォルトを代入することにより、中断することなく継続されます。それらが問題にする必要がありませんSLPネットワークの性質を反映しているのでnet.slp.locale、net.slp.typeHint、およびnet.slp.maxResultsを除いて、APIのクライアントはめったに、これらのプロパティをオーバーライドするために必要とされるべきでありません個々のエージェント。変更が必要な場合は、システム管理者は、設定ファイルを変更する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.7.5. Memory Management",
      "section_title": true,
      "ja": "4.7.5。メモリ管理"
    },
    {
      "indent": 3,
      "text": "The only API functions returning memory specifically requiring deallocation on the part of the client are SLPParseSrvURL(), SLPFindScopes(), SLPEscape(), and SLPUnescape(). This memory should be freed using SLPFree() when no longer needed. Character strings returned via the SLPGetProperty() function should NOT be freed, they are owned by the SLP library.",
      "ja": "具体的には、クライアントの一部に割り当て解除を要求するメモリを返すだけAPI関数はSLPParseSrvURL（）、SLPFindScopes（）、SLPEscape（）、及びSLPUnescape（）です。このメモリは不要になったときに（）SLPFreeを使用して解放する必要があります。 SLPGetProperty（）関数を介して返された文字列を解放してはいけません、彼らは、SLPライブラリによって所有されています。"
    },
    {
      "indent": 3,
      "text": "Memory passed to callbacks belongs to the library and MUST NOT be retained by the client code. Otherwise, crashes are possible. Clients are required to copy data out of the callback parameters. No other use of the parameter memory in callback parameters is allowed.",
      "ja": "コールバックに渡されたメモリは、ライブラリに属し、クライアントコードによって保持されてはなりません。そうしないと、クラッシュが可能です。クライアントは、コールバックパラメータの外にデータをコピーする必要があります。コールバックパラメータのパラメータメモリの他の使用が許可されていません。"
    },
    {
      "indent": 0,
      "text": "4.7.6. Asynchronous and Incremental Return Semantics",
      "section_title": true,
      "ja": "4.7.6。非同期および増分リターンセマンティクス"
    },
    {
      "indent": 3,
      "text": "If a handle parameter to an API function was opened asynchronously, API function calls on the handle check the other parameters, open the appropriate operation and return immediately. In an error occurs in the process of starting the operation, an error code is returned. If the handle parameter was opened synchronously, the API function call blocks until all results are available, and returns only after the results are reported through the callback function. The return code indicates whether any errors occurred both starting and during the operation.",
      "ja": "API関数へのハンドルパラメータが非同期で開いた場合は、API関数を扱う上で呼び出して、他のパラメータをチェックし、適切な操作を開き、すぐに戻ります。エラーにエラーコードが返され、動作を開始する過程で起こります。すべての結果が利用可能であり、結果はコールバック関数で報告された後にのみ返すまで、ハンドルパラメータは、同期API関数呼び出しのブロックを開いた場合。戻りコードは、エラーが両方起動し、操作中に発生したかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "The callback function is called whenever the API library has results to report. The callback code is required to check the error code parameter before looking at the other parameters. If the error code is not SLP_OK, the other parameters may be invalid. The API library has the option of terminating any outstanding operation on which an error occurs. The callback code can similarly indicate that the operation should be terminated by passing back SLP_FALSE. Callback functions are not permitted to recursively call into the API on the same SLPHandle. If an attempt is made to recursively call into the API, the API function returns SLP_HANDLE_IN_USE. Prohibiting recursive callbacks on the same handle simplifies implementation of thread safe code, since locks held on the handle will not be in place during a second outcall on the handle. On the other hand, it means that handle creation should be fairly lightweight so a client program can easily support multiple outstanding calls.",
      "ja": "APIライブラリは、レポートに結果を持っていたときにコールバック関数が呼び出されます。コールバック・コードは、他のパラメータを見る前に、エラーコードのパラメータをチェックするために必要とされます。エラーコードがSLP_OKされていない場合は、他のパラメータが無効である可能性があります。 APIライブラリは、エラーが発生した未処理の動作を終了するオプションがあります。コールバックのコードは、同様の操作がSLP_FALSEバック通過させることによって終了されるべきであることを示すことができます。コールバック関数を再帰的に同じSLPHandleのAPIを呼び出すことが許可されていません。試みが再帰的にAPIを呼び出すためになされた場合、API関数はSLP_HANDLE_IN_USEを返します。ハンドルに開催されたロックはハンドル上の第二のアウトコールの間の場所ではありませんので、同じハンドル上の再帰的コールバックを禁止する、スレッドセーフコードの実装を簡素化します。一方、ハンドルの作成がとてもクライアントプログラムが簡単に複数の未処理のコールをサポートすることができ、かなり軽量でなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The total number of results received can be controlled by setting the net.slp.maxResults parameter.",
      "ja": "受信された結果の総数はnet.slp.maxResultsパラメータを設定することによって制御することができます。"
    },
    {
      "indent": 3,
      "text": "On the last call to a callback, whether asynchronous or synchronous, the status code passed to the callback has value SLP_LAST_CALL. There are four reasons why the call can terminate:",
      "ja": "コールバックへの最後の呼び出しでは、非同期または同期するかどうか、コールバックに渡されたステータスコードは、値SLP_LAST_CALLを持っています。通話が終了することができる理由4つの理由があります。"
    },
    {
      "indent": 6,
      "text": "DA reply received",
      "ja": "DA応答が受信します"
    },
    {
      "indent": 9,
      "text": "A reply from a DA has been received and therefore nothing more is expected.",
      "ja": "DAからの応答が受信されているので、より多くの何も期待されていません。"
    },
    {
      "indent": 6,
      "text": "Multicast terminated",
      "ja": "マルチキャスト終了"
    },
    {
      "indent": 9,
      "text": "The multicast convergence time has elapsed and the API library multicast code is giving up.",
      "ja": "マルチキャスト収束時間が経過し、APIライブラリマルチキャストコードはあきらめています。"
    },
    {
      "indent": 6,
      "text": "Multicast null results",
      "ja": "マルチキャストヌル結果"
    },
    {
      "indent": 9,
      "text": "Nothing new has been received during multicast for a while and the API library multicast code is giving up on that (as an optimization).",
      "ja": "新しいものは何もしばらくの間、マルチキャスト中に受信されていないと、APIライブラリマルチキャストコードは（最適化として）その上に与えています。"
    },
    {
      "indent": 6,
      "text": "Maximum results",
      "ja": "最大の結果"
    },
    {
      "indent": 9,
      "text": "The user has set the net.slp.maxResults property and that number of replies has been collected and returned",
      "ja": "ユーザーはnet.slp.maxResultsプロパティを設定していると回答の数を収集し、戻ってきました"
    },
    {
      "indent": 0,
      "text": "4.8. Example",
      "section_title": true,
      "ja": "4.8。例"
    },
    {
      "indent": 3,
      "text": "This example illustrates how to discover a mailbox.",
      "ja": "この例では、メールボックスを発見する方法を示しています。"
    },
    {
      "indent": 3,
      "text": "A POP3 server registers itself with the SLP framework. The attributes it registers are \"USER\", a list of all users whose mail is available through the POP3 server.",
      "ja": "POP3サーバは、SLPのフレームワークに自身を登録します。それが登録する属性は、「USER」、メールPOP3サーバで入手することができ、すべてのユーザのリストです。"
    },
    {
      "indent": 3,
      "text": "The POP3 server code is the following:",
      "ja": "POP3サーバのコードは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "SLPHandle slph;\nSLPRegReport errCallback = POPRegErrCallback;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Create an English SLPHandle, asynchronous processing. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SLPError err = SLPOpen(\"en\", SLP_TRUE, &slph);",
      "ja": "SLPError ERR = SLPOpen（ \"EN\"、SLP_TRUE、＆slph）。"
    },
    {
      "indent": 3,
      "text": "if( err != SLP_OK ) {",
      "ja": "{（ERR！= SLP_OK）の場合"
    },
    {
      "indent": 5,
      "text": "/* Deal with error. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "/* Create the service: URL and attribute parameters. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const char* surl = \"service:pop3://mail.netsurf.de\"; /* the URL */ const char *pcAttrs = \"(user=zaphod,trillian,roger,marvin)\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Perform the registration. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "err = SLPReg(slph, surl, SLP_LIFETIME_DEFAULT, ppcAttrs, errCallback, NULL);",
      "ja": "ERR = SLPReg（slph、SURL、SLP_LIFETIME_DEFAULT、ppcAttrs、errCallback、NULL）;"
    },
    {
      "indent": 3,
      "text": "if (err != SLP_OK ) {",
      "ja": "{（ERR！= SLP_OK）の場合"
    },
    {
      "indent": 6,
      "text": "/*Deal with error.*/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "The errCallback reports any errors:",
      "ja": "errCallbackは、すべてのエラーを報告します。"
    },
    {
      "indent": 3,
      "text": "void POPRegErrCallback(SLPHandle hSLP, SLPError errCode, unsigned short usLifetime, void* pvCookie) {",
      "ja": "ボイドPOPRegErrCallback（SLPHandle hSLP、SLPError ERRCODE、符号なしの短いusLifetime、ボイド* pvCookie）{"
    },
    {
      "indent": 6,
      "text": "if( errCode != SLP_OK ) {",
      "ja": "もし（ERRCODE！= SLP_OK）{"
    },
    {
      "indent": 8,
      "text": "/* Report error through a dialog, message, etc. */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 6,
      "text": "/*Use lifetime interval to update periodically. */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "The POP3 client locates the server for the user with the following code:",
      "ja": "POP3クライアントは、次のコードを持つユーザーのためのサーバーを検索します："
    },
    {
      "indent": 3,
      "text": "/*\n * The client calls SLPOpen(), exactly as above.\n */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const char *pcSrvType   = \"service:pop3\"; /* the service type  */\nconst char *pcScopeList = \"default\";      /* the scope         */\nconst char *pcFilter    = \"(user=roger)\"; /* the search filter */\nSLPSrvURLCallback srvCallback =           /* the callback      */\n                                POPSrvURLCallback;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "err = SLPFindSrvs(slph, pcSrvType, pcScopeList, pcFilter, srvCallback, NULL);",
      "ja": "ERR = SLPFindSrvs（slph、pcSrvType、pcScopeList、pcFilter、srvCallback、NULL）;"
    },
    {
      "indent": 3,
      "text": "if( err != SLP_OK ) {",
      "ja": "{（ERR！= SLP_OK）の場合"
    },
    {
      "indent": 7,
      "text": "/* Deal with error. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "Within the callback, the client code can use the returned POP service:",
      "ja": "コールバック内では、クライアント・コードが返されたPOPサービスを使用することができます。"
    },
    {
      "indent": 2,
      "text": "SLPBoolean POPSrvURLCallback(SLPHandle hSLP, const char* pcSrvURL, unsigned short sLifetime, SLPError errCode, void* pvCookie) {",
      "ja": "SLPBoolean POPSrvURLCallback（SLPHandle hSLP、CONSTのchar * pcSrvURL、符号なしの短いsLifetime、SLPError ERRCODE、ボイド* pvCookie）{"
    },
    {
      "indent": 5,
      "text": "if( errCode != SLP_OK ) {",
      "ja": "もし（ERRCODE！= SLP_OK）{"
    },
    {
      "indent": 8,
      "text": "/* Deal with error. */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 5,
      "text": "SLPSrvURL* pSrvURL;",
      "ja": "SLPSrvURL * pSrvURL。"
    },
    {
      "indent": 5,
      "text": "errCode = SLPParseSrvURL(pcSrvURL, &pSrvURL);",
      "ja": "ERRCODE = SLPParseSrvURL（pcSrvURL、＆pSrvURL）。"
    },
    {
      "indent": 5,
      "text": "if (err != SLP_OK ) {",
      "ja": "{（ERR！= SLP_OK）の場合"
    },
    {
      "indent": 7,
      "text": "/* Deal with error. */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "} else {",
      "ja": "}他{"
    },
    {
      "indent": 7,
      "text": "/* get the server's address */",
      "raw": true
    },
    {
      "indent": 7,
      "text": "struct hostent *phe = gethostbyname(pSrvURL.s_pcHost);",
      "ja": "構造体たhostent *のPhe =のgethostbyname（pSrvURL.s_pcHost）。"
    },
    {
      "indent": 7,
      "text": "/* use hostname in pSrvURL to connect to the POP3 server\n *     . . .\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "  SLPFreeSrvURL((void*)pSrvURL);  /* Free the pSrvURL storage */\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "return SLP_FALSE;                 /* Done! */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "A client that wanted to discover all the users receiving mail at the server uses with the following query:",
      "ja": "サーバーでメールを受信したすべてのユーザーを発見したいクライアントは、次のクエリを使用しています："
    },
    {
      "indent": 3,
      "text": "/*\n * The client calls SLPOpen(), exactly as above. We assume the\n * service: URL was retrieved into surl.\n */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const char *pcScopeList = \"default\";      /* the scope            */\nconst char *pcAttrFilter    = \"use\";      /* the attribute filter */\nSLPAttrCallback attrCallBack =            /* the callback         */\n                               POPUsersCallback",
      "raw": true
    },
    {
      "indent": 3,
      "text": "err = SLPFindAttrs(slph, surl, pcScopeList, pcAttrFilter, attrCallBack, NULL);",
      "ja": "ERR = SLPFindAttrs（slph、SURL、pcScopeList、pcAttrFilter、attrCallBack、NULL）;"
    },
    {
      "indent": 3,
      "text": "if( err != SLP_OK ) {",
      "ja": "{（ERR！= SLP_OK）の場合"
    },
    {
      "indent": 8,
      "text": "/* Deal with error. */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "The callback processes the attributes:",
      "ja": "コールバックは、属性を処理します。"
    },
    {
      "indent": 3,
      "text": "SLPBoolean POPUsersCallback(const char* pcAttrList, SLPError errCode, void* pvCookie) {",
      "ja": "SLPBoolean POPUsersCallback（CONSTチャー* pcAttrList、SLPError ERRCODE、ボイド* pvCookie）{"
    },
    {
      "indent": 5,
      "text": "if( errCode != SLP_OK ) {",
      "ja": "もし（ERRCODE！= SLP_OK）{"
    },
    {
      "indent": 7,
      "text": "/* Deal with error. */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "} else {",
      "ja": "}他{"
    },
    {
      "indent": 7,
      "text": "/* Parse attributes. */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 5,
      "text": "return SLP_FALSE;  /* Done! */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 0,
      "text": "5. Java Language Binding",
      "section_title": true,
      "ja": "5. Java言語バインディング"
    },
    {
      "indent": 0,
      "text": "5.1. Introduction",
      "section_title": true,
      "ja": "5.1。前書き"
    },
    {
      "indent": 3,
      "text": "The Java API is designed to model the various SLP entities in classes and objects. APIs are provided for SA, UA, and service type template access capabilities. The ServiceLocationManager class contains methods that return instances of objects implementing SA and UA capability. Each of these is modeled in an interface. The Locator interface provides UA capability and the Advertiser interface provides SA capability. The TemplateRegistry abstract class contains methods that return objects for template introspection and attribute type checking. The ServiceURL, ServiceType, and ServiceLocationAttribute classes model the basic SLP concepts. A concrete subclass instance of TemplateRegistry is returned by a class method.",
      "ja": "Java APIは、クラスとオブジェクトのさまざまなSLPエンティティをモデル化するように設計されています。 APIはSA、UA、およびサービスタイプテンプレートアクセス能力のために提供されています。 ServiceLocationManagerクラスは、SAおよびUAの機能を実装するオブジェクトのインスタンスを返すメソッドが含まれています。これらのそれぞれは、インタフェースでモデル化されます。ロケータ・インタフェースは、UAの機能を提供し、広告主インタフェースは、SAの機能を提供します。 TemplateRegistry抽象クラスは、テンプレートのイントロスペクションと属性の型チェックのためのオブジェクトを返すメソッドが含まれています。 serviceURLの、サービス種別、およびServiceLocationAttributeクラスモデルの基本的なSLPの概念。 TemplateRegistryの具体的なサブクラスのインスタンスは、クラスメソッドによって返されます。"
    },
    {
      "indent": 3,
      "text": "All SLP classes and interfaces are located within a single package. The package name should begin with the name of the implementation and conclude with the suffix \"slp\". Thus, the name for a hypothetical implementation from the University of Michigan would look like:",
      "ja": "すべてのSLPのクラスとインタフェースは、単一のパッケージ内に配置されています。パッケージ名は、実装の名前で始まり、接尾辞「SLP」を締結すべきです。このように、ミシガン大学からの仮想的な実装の名前は次のようになります。"
    },
    {
      "indent": 29,
      "text": "edu.umich.slp",
      "ja": "edu.umich.slp"
    },
    {
      "indent": 3,
      "text": "This follows the Java convention of prepending the top level DNS domain name for the organization implementing the package onto the organization's name and using that as the package prefix.",
      "ja": "これは、そのパッケージの接頭辞として、組織の名前の上にパッケージを実装する組織のために、トップレベルのDNSドメイン名を付加して使用するのJava規則に従います。"
    },
    {
      "indent": 0,
      "text": "5.2. Exceptions and Errors",
      "section_title": true,
      "ja": "5.2。例外とエラー"
    },
    {
      "indent": 3,
      "text": "Most parameters to API methods are required to be non-null. The API description indicates if a null parameter is acceptable, or if other restrictions constrain a parameter. When parameters are checked for validity (such as not being null) or their syntax is checked, an error results in the RuntimeException subclass IllegalArgumentException being thrown. Clients of the API are reminded that IllegalArgumentException, derived from RuntimeException, is unchecked by the compiler. Clients should thus be careful to include try/catch blocks for it if the relevant parameters could be erroneous.",
      "ja": "APIメソッドへのほとんどのパラメータはnull以外であることが要求されています。他の制限は、パラメータを制約する場合はnullパラメータが許容可能である場合、またはAPIの説明を示します。ときのパラメータは、（例えば、ヌルではないものとして）有効性をチェックされているか、その構文がチェックされている、のRuntimeExceptionのサブクラスはIllegalArgumentExceptionのエラー結果がスローされます。 APIのクライアントは、RuntimeExceptionが由来はIllegalArgumentExceptionが、コンパイラによってチェックされていることを思い出しています。クライアントは、このように関連するパラメータが誤ってできればそれのためのtry / catchブロックを含めるように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "Standard Java practice is to encode every exceptional condition as a separate subclass of Exception. Because of the relatively high cost in code size of Exception subclasses, the API contains only a single Exception subclass with different conditions being determined by an integer error code property. A subset, appropriate to Java, of the error codes described in Section 3 are available as constants on the ServiceLocationException class. The subset excludes error codes such as MEMORY_ALLOC_FAILED.",
      "ja": "標準的なJavaの練習は、例外の別のサブクラスとして、すべての例外条件を符号化することです。なぜなら例外サブクラスのコードサイズが比較的高いコストのため、APIは、整数エラーコードプロパティによって決定される異なる条件で単一の例外サブクラスを含んでいます。セクション3に記載されたエラーコードのJavaへの適切なサブセットは、ServiceLocationExceptionクラスの定数として利用可能です。サブセットは、MEMORY_ALLOC_FAILEDとしてエラーコードを除外する。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Class ServiceLocationException",
      "section_title": true,
      "ja": "5.2.1。クラスServiceLocationException"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. Synopsis",
      "section_title": true,
      "ja": "5.2.1.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "public class ServiceLocationException extends Exception",
      "ja": "パブリッククラスServiceLocationExceptionは例外を拡張します"
    },
    {
      "indent": 0,
      "text": "5.2.1.2. Description",
      "section_title": true,
      "ja": "5.2.1.2。説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationException class is thrown by all methods when exceptional conditions occur in the SLP framework. The error code property determines the exact nature of the condition, and an optional message may provide more information.",
      "ja": "例外的な条件は、SLPの枠組みの中で発生した場合ServiceLocationExceptionクラスは、すべてのメソッドによってスローされます。エラーコードプロパティは条件の正確な性質を決定し、任意のメッセージがより多くの情報を提供してもよいです。"
    },
    {
      "indent": 0,
      "text": "5.2.1.3. Fields",
      "section_title": true,
      "ja": "5.2.1.3。フィールド"
    },
    {
      "indent": 3,
      "text": "public static final short LANGUAGE_NOT_SUPPORTED = 1 public static final short PARSE_ERROR = 2 public static final short INVALID_REGISTRATION = 3 public static final short SCOPE_NOT_SUPPORTED = 4 public static final short AUTHENTICATION_ABSENT = 6 public static final short AUTHENTICATION_FAILED = 7 public static final short INVALID_UPDATE = 13 public static final short REFRESH_REJECTED = 15 public static final short NOT_IMPLEMENTED = 16 public static final short NETWORK_INIT_FAILED 17 public static final short NETWORK_TIMED_OUT = 18 public static final short NETWORK_ERROR = 19 public static final short INTERNAL_SYSTEM_ERROR = 20 public static final short TYPE_ERROR = 21 public static final short BUFFER_OVERFLOW = 22",
      "ja": "パブリック静的最終短いLANGUAGE_NOT_SUPPORTED = 1のpublic static final短いPARSE_ERROR = 2のpublic static final短いINVALID_REGISTRATION = 3のpublic static final短いSCOPE_NOT_SUPPORTED = 4のpublic static final短いAUTHENTICATION_ABSENT = 6のpublic static final短いAUTHENTICATION_FAILED = 7のpublic static final短いINVALID_UPDATE = 13公衆= 21のpublic static final = 20のpublic static final短いTYPE_ERROR = 19のpublic static final短いINTERNAL_SYSTEM_ERROR = 18のpublic static final短いNETWORK_ERROR REFRESH_REJECTED = 15のpublic static final短いNOT_IMPLEMENTED = 16のpublic static final短いNETWORK_INIT_FAILED 17のpublic static final短いNETWORK_TIMED_OUT静的最終短いです短いBUFFER_OVERFLOW = 22"
    },
    {
      "indent": 0,
      "text": "5.2.1.4. Instance Methods",
      "section_title": true,
      "ja": "5.2.1.4。インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public short getErrorCode()",
      "ja": "公共短いgetErrorCode（）"
    },
    {
      "indent": 3,
      "text": "Return the error code. The error code takes on one of the static field values.",
      "ja": "エラーコードを返します。エラーコードは、静的フィールドの値のいずれかになります。"
    },
    {
      "indent": 0,
      "text": "5.3. Basic Data Structures",
      "section_title": true,
      "ja": "5.3。基本的なデータ構造"
    },
    {
      "indent": 0,
      "text": "5.3.1. Interface ServiceLocationEnumeration",
      "section_title": true,
      "ja": "5.3.1。インタフェースServiceLocationEnumeration"
    },
    {
      "indent": 3,
      "text": "public interface ServiceLocationEnumeration extends Enumeration",
      "ja": "パブリックインターフェイスServiceLocationEnumerationはEnumerationを拡張します"
    },
    {
      "indent": 0,
      "text": "5.3.1.1. Description",
      "section_title": true,
      "ja": "5.3.1.1。説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationEnumeration class is the return type for all Locator SLP operations. The Java API library may implement this class to block until results are available from the SLP operation, so that the client can achieve asynchronous operation by retrieving results from the enumeration in a separate thread. Clients use the superclass nextElement() method if they are unconcerned with SLP exceptions.",
      "ja": "ServiceLocationEnumerationクラスは、すべてのロケータSLP操作の戻り値の型です。 JavaのAPIライブラリは、クライアントが別のスレッドでの列挙から結果を取得することで、非同期操作を実現することができるように結果は、SLPの操作から利用可能になるまでブロックするために、このクラスを実装することができます。彼らはSLPの例外を除いて無関心であれば、クライアントは、スーパークラスのnextElement（）メソッドを使用します。"
    },
    {
      "indent": 0,
      "text": "5.3.1.2. Instance Methods",
      "section_title": true,
      "ja": "5.3.1.2。インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract Object next() throws ServiceLocationException",
      "ja": "次のパブリック抽象オブジェクトは、（）ServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Return the next value or block until it becomes available.",
      "ja": "それが利用可能になるまで次の値またはブロックを返します。"
    },
    {
      "indent": 3,
      "text": "Throws:",
      "ja": "例外："
    },
    {
      "indent": 6,
      "text": "ServiceLocationException",
      "ja": "ServiceLocationException"
    },
    {
      "indent": 9,
      "text": "Thrown if the SLP operation encounters an error.",
      "ja": "SLPの操作でエラーが発生した場合にスローされます。"
    },
    {
      "indent": 6,
      "text": "NoSuchElementException",
      "ja": "NoSuchElementException"
    },
    {
      "indent": 9,
      "text": "If there are no more elements to return.",
      "ja": "返すためにそれ以上の要素が存在しない場合。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Class ServiceLocationAttribute",
      "section_title": true,
      "ja": "5.3.2。クラスServiceLocationAttribute"
    },
    {
      "indent": 0,
      "text": "5.3.2.1. Synopsis",
      "section_title": true,
      "ja": "5.3.2.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "public class ServiceLocationAttribute extends Object implements Serializable",
      "ja": "パブリッククラスServiceLocationAttributeは、オブジェクトがSerializableを実装拡張します"
    },
    {
      "indent": 0,
      "text": "5.3.2.2. Description",
      "section_title": true,
      "ja": "5.3.2.2。説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationAttribute class models SLP attributes. Instances of this class are returned by Locator.findAttributes() and are communicated along with register/deregister requests.",
      "ja": "SLP属性ServiceLocationAttributeクラスモデル。このクラスのインスタンスは（Locator.findAttributesによって返される）、レジスタ/登録解除要求と共に通信されます。"
    },
    {
      "indent": 0,
      "text": "5.3.2.3. Constructors",
      "section_title": true,
      "ja": "5.3.2.3。コンストラクタ"
    },
    {
      "indent": 3,
      "text": "public ServiceLocationAttribute(String id,Vector values)",
      "ja": "公共ServiceLocationAttribute（文字列ID、ベクトル値）"
    },
    {
      "indent": 3,
      "text": "Construct a service location attribute. Errors in the id or values vector result in an IllegalArgumentException.",
      "ja": "サービスの場所属性を構築します。 IllegalArgumentExceptionのidまたは値ベクトルの結果にエラー。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "id",
      "ja": "ID"
    },
    {
      "indent": 9,
      "text": "The attribute name. The String can consist of any Unicode character.",
      "ja": "属性名。文字列は、任意のUnicode文字で構成することができます。"
    },
    {
      "indent": 6,
      "text": "values",
      "ja": "値"
    },
    {
      "indent": 9,
      "text": "A Vector of one or more attribute values. Vector contents must be uniform in type and one of Integer, String, Boolean, or byte[]. If the attribute is a keyword attribute, then the parameter should be null. String values can consist of any Unicode character.",
      "ja": "1つ以上の属性値のベクトル。ベクトルの内容は[]、種類及び整数のいずれかの文字列、ブール、またはバイト均一でなければなりません。属性がキーワード属性である場合、そのパラメータはnullでなければなりません。文字列値は、任意のUnicode文字で構成することができます。"
    },
    {
      "indent": 0,
      "text": "5.3.2.4. Class Methods",
      "section_title": true,
      "ja": "5.3.2.4。クラスメソッド"
    },
    {
      "indent": 3,
      "text": "public static String escapeId(String id)",
      "ja": "公共の静的な文字列escapeId（文字列ID）"
    },
    {
      "indent": 3,
      "text": "Returns an escaped version of the id parameter, suitable for inclusion in a query. Any reserved characters as specified in [7] are escaped using UTF-8 encoding. If any characters in the tag are illegal, throws IllegalArgumentException.",
      "ja": "クエリに含めるのに適したidパラメーターのエスケープバージョンを返します。 [7]で指定されるように、任意の予約文字は、UTF-8エンコーディングを使用してエスケープされています。タグ内の任意の文字が違法である場合は、IllegalArgumentExceptionをスローします。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "id",
      "ja": "ID"
    },
    {
      "indent": 9,
      "text": "The attribute id to escape. ServiceLocationException is thrown if any characters are illegal for an attribute tag.",
      "ja": "脱出する属性ID。任意の文字が属性タグのため違法である場合ServiceLocationExceptionがスローされます。"
    },
    {
      "indent": 3,
      "text": "public static String escapeValue(Object value)",
      "ja": "公共の静的な文字列escapeValue（Object値）"
    },
    {
      "indent": 3,
      "text": "Returns a String containing the escaped value parameter as a string, suitable for inclusion in a query. If the parameter is a string, any reserved characters as specified in [7] are escaped using UTF-8 encoding. If the parameter is a byte array, then the escaped string begins with the nonUTF-8 sequence `\\ff` and the rest of the string consists of the escaped bytes, which is the encoding for opaques. If the value parameter is a Boolean or Integer, then the returned string contains the object converted into a string. If the value is any type other than String, Integer, Boolean or byte[], an IllegalArgumentException is thrown.",
      "ja": "クエリに含めるのに適した文字列としてエスケープ値パラメータを含む文字列を返します。パラメータは、で指定された文字列、任意の予約文字である場合、[7] UTF-8エンコーディングを使用してエスケープされています。パラメータがバイト配列の場合、エスケープされた文字列はnonUTF-8シーケンス `\\ ff`で始まり、文字列の残りの部分はopaquesのエンコーディングである、エスケープバイトで構成されます。 valueパラメータは、ブールまたは整数の場合、返される文字列は、文字列に変換されたオブジェクトが含まれています。値は文字列、整数、ブールかバイト[]以外の任意の型である場合、IllegalArgumentExceptionがスローされます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "value",
      "ja": "値"
    },
    {
      "indent": 9,
      "text": "The attribute value to be converted into a string and escaped.",
      "ja": "属性値が文字列に変換し、エスケープします。"
    },
    {
      "indent": 0,
      "text": "5.3.2.5. Instance Methods",
      "section_title": true,
      "ja": "5.3.2.5。インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public Vector getValues()",
      "ja": "公共のベクトルでgetValues（）"
    },
    {
      "indent": 3,
      "text": "Returns a cloned vector of attribute values, or null if the attribute is a keyword attribute. If the attribute is single-valued, then the vector contains only one object.",
      "ja": "属性がキーワード属性である場合にはクローン化された属性値のベクトル、またはnullを返します。属性が単一値である場合、そのベクトルは、1つのオブジェクトのみが含まれています。"
    },
    {
      "indent": 3,
      "text": "public String getId()",
      "ja": "公共の文字列のgetId（）"
    },
    {
      "indent": 3,
      "text": "Returns the attribute's name.",
      "ja": "属性の名前を返します。"
    },
    {
      "indent": 3,
      "text": "public boolean equals(Object o)",
      "ja": "パブリックブールのequals（オブジェクトo）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.equals(). Two attributes are equal if their identifiers are equal and their value vectors contain the same number of equal values as determined by the Object equals() method. Values having byte[] type are equal if the contents of all byte arrays in both attribute vectors match. Note that the SLP string matching algorithm [7] MUST NOT be used for comparing attribute identifiers or string values.",
      "ja": "オーバーライドはObject.equals（）。その識別子が等しく、オブジェクトのequals（）メソッドによって決定され、それらの値のベクトルが等しい同じ数の値を含む場合、2つの属性が等しいです。両方の中のすべてのバイト配列の内容がベクトル一致属性場合、バイト[]型の値が等しいです。 SLP文字列照合アルゴリズム[7]属性識別子または文字列値を比較するために使用してはならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "public String toString()",
      "ja": "公共の文字列のtoString（）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.toString(). The string returned contains a formatted representation of the attribute, giving the attribute's id, values, and the Java type of the values. The returned string is suitable for debugging purposes, but is not in SLP wire format.",
      "ja": "Object.ToStringをオーバーライドします（）。返される文字列は、属性のID、値を与える属性をフォーマット化、および値のJava型が含まれています。返される文字列は、デバッグ目的に適しているが、SLPワイヤ形式ではありません。"
    },
    {
      "indent": 3,
      "text": "public int hashCode()",
      "ja": "公共int型のhashCode（）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.hashCode(). Hashes on the attribute's identifier.",
      "ja": "オーバーライドObject.hashCode（）。属性の識別子にハッシュします。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Class ServiceType",
      "section_title": true,
      "ja": "5.3.3。クラスのサービス種別"
    },
    {
      "indent": 0,
      "text": "5.3.3.1. Synopsis",
      "section_title": true,
      "ja": "5.3.3.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "public class ServiceType extends Object implements Serializable",
      "ja": "パブリッククラスサービス種別は、オブジェクトがSerializableを実装拡張します"
    },
    {
      "indent": 0,
      "text": "5.3.3.2. Description",
      "section_title": true,
      "ja": "5.3.3.2。説明"
    },
    {
      "indent": 3,
      "text": "The ServiceType object models the SLP service type. It parses a string based service type specifier into its various components, and contains property accessors to return the components. URL schemes, protocol service types, and abstract service types are all handled.",
      "ja": "サービス種別のオブジェクトモデルSLPサービスタイプ。それは、そのさまざまなコンポーネントに文字列ベースのサービスの型指定を解析し、コンポーネントを返すために、プロパティアクセサが含まれています。 URLスキーム、プロトコルサービスの種類、および抽象的なサービスタイプはすべて処理されます。"
    },
    {
      "indent": 0,
      "text": "5.3.3.3. Constructors",
      "section_title": true,
      "ja": "5.3.3.3。コンストラクタ"
    },
    {
      "indent": 3,
      "text": "public ServiceType(String type)",
      "ja": "公共サービス種別（文字列型）"
    },
    {
      "indent": 3,
      "text": "Construct a service type object from the service type specifier. Throws IllegalArgumentException if the type name is syntactically incorrect.",
      "ja": "サービスの型指定子からサービス型オブジェクトを構築します。タイプ名は構文的に誤っている場合、IllegalArgumentExceptionが発生します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ"
    },
    {
      "indent": 9,
      "text": "The service type name as a String. If the service type is from a service: URL, the \"service:\" prefix must be intact.",
      "ja": "文字列としてサービスタイプ名。サービスタイプは、サービスからの場合：URL、「サービス：」プレフィックスは無傷でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.3.4. Methods",
      "section_title": true,
      "ja": "5.3.3.4。メソッド"
    },
    {
      "indent": 3,
      "text": "public boolean isServiceURL()",
      "ja": "パブリックブールisServiceURL（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the type name contains the \"service:\" prefix.",
      "ja": "接頭辞：タイプ名が「サービス」が含まれている場合にtrueを返します。"
    },
    {
      "indent": 3,
      "text": "public boolean isAbstractType()",
      "ja": "パブリックブールisAbstractType（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the type name is for an abstract type.",
      "ja": "型名は抽象型のためである場合はtrueを返します。"
    },
    {
      "indent": 3,
      "text": "public boolean isNADefault()",
      "ja": "パブリックブールisNADefault（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the naming authority is the default, i.e. is the empty string.",
      "ja": "命名機関は、すなわち、デフォルトでは空の文字列である場合はtrueを返します。"
    },
    {
      "indent": 3,
      "text": "public String getConcreteTypeName()",
      "ja": "公共の文字列getConcreteTypeName（）"
    },
    {
      "indent": 3,
      "text": "Returns the concrete type name in an abstract type, or the empty string if the service type is not abstract. For example, if the type name is \"service:printing:ipp\", the method returns \"ipp\". If the type name is \"service:ftp\", the method returns \"\".",
      "ja": "サービスタイプが抽象的でない場合は抽象型、または空の文字列で、具体的なタイプの名前を返します。 「：印刷：サービスIPP」タイプ名がある場合たとえば、この方法は、「IPP」を返します。タイプ名がある場合は、「サービス：FTPは」、この方法は、「」を返します。"
    },
    {
      "indent": 3,
      "text": "public String getPrincipleTypeName()",
      "ja": "公共の文字列getPrincipleTypeName（）"
    },
    {
      "indent": 3,
      "text": "Returns the abstract type name for an abstract type, the protocol name in a protocol type, or the URL scheme for a generic URL. For example, in the abstract type name \"service:printing:ipp\", the method returns \"printing\". In the protocol type name \"service:ftp\", the method returns \"ftp\".",
      "ja": "抽象型、プロトコルタイプのプロトコル名、またはジェネリックURLのURLスキームのための抽象型の名前を返します。例えば、抽象型名「サービス：印刷：IPP」で、この方法は、「印刷」を返します。プロトコルタイプ名「サービス：ftpの」において、この方法は、「FTP」を返します。"
    },
    {
      "indent": 3,
      "text": "public String getAbstractTypeName()",
      "ja": "公共の文字列getAbstractTypeName（）"
    },
    {
      "indent": 3,
      "text": "If the type is an abstract type, returns the fully formatted abstract type name including the \"service:\" and naming authority but without the concrete type name or intervening colon. If not an abstract type, returns the empty string. For example, in the abstract type name \"service:printing:ipp\", the method returns \"service:printing\".",
      "ja": "権威を命名ますが、具体的なタイプ名または介在コロンなし：型が抽象型である場合は、「サービス」を含め、完全にフォーマットされた抽象型の名前を返します。ない抽象型場合は、空の文字列を返します。たとえば、抽象タイプ名に「サービス：印刷：IPP」、メソッドが返す「サービス：印刷」。"
    },
    {
      "indent": 3,
      "text": "public String getNamingAuthority()",
      "ja": "公共の文字列getNamingAuthority（）"
    },
    {
      "indent": 3,
      "text": "Return the naming authority name, or the empty string if the naming authority is the default.",
      "ja": "命名機関名、または命名機関がデフォルトである場合は、空の文字列を返します。"
    },
    {
      "indent": 3,
      "text": "public boolean equals(Object obj)",
      "ja": "パブリックブールのequals（オブジェクトobj）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.equals(). The two objects are equal if they are both ServiceType objects and the components of both are equal.",
      "ja": "オーバーライドはObject.equals（）。彼らは両方のサービス・タイプのオブジェクトであり、両方の成分が等しければ2つのオブジェクトが等しいです。"
    },
    {
      "indent": 3,
      "text": "public String toString()",
      "ja": "公共の文字列のtoString（）"
    },
    {
      "indent": 3,
      "text": "Returns the fully formatted type name, including the \"service:\" if the type was originally from a service: URL.",
      "ja": "タイプがサービスから元々だった場合：URL：「サービス」を含め、完全にフォーマットタイプ名を返します。"
    },
    {
      "indent": 3,
      "text": "public int hashCode()",
      "ja": "公共int型のhashCode（）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.hashCode(). Hashes on the string value of the \"service\" prefix, naming authority, if any, abstract and concrete type names for abstract types, protocol type name for protocol types, and URL scheme for generic URLs.",
      "ja": "オーバーライドObject.hashCode（）。もしあれば、権威を命名、「サービス」の接頭辞の文字列値にハッシュ抽象型、プロトコルタイプのプロトコルタイプ名、およびジェネリックURLのURLスキームのための抽象と具象タイプ名。"
    },
    {
      "indent": 0,
      "text": "5.3.4. Class ServiceURL",
      "section_title": true,
      "ja": "5.3.4。クラスのserviceURL"
    },
    {
      "indent": 0,
      "text": "5.3.4.1. Synopsis",
      "section_title": true,
      "ja": "5.3.4.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "public class ServiceURL extends Object implements Serializable",
      "ja": "パブリッククラスserviceURLのオブジェクトがSerializableを実装拡張します"
    },
    {
      "indent": 0,
      "text": "5.3.4.2. Description",
      "section_title": true,
      "ja": "5.3.4.2。説明"
    },
    {
      "indent": 3,
      "text": "The ServiceURL object models the advertised SLP service URL. It can be either a service: URL or a regular URL. These objects are returned from service lookup requests, and describe the registered services. This class should be a subclass of java.net.URL but can't since that class is final.",
      "ja": "serviceURLのオブジェクトモデル公示さSLPサービスURL。 URLまたは正規URL：それはサービスのいずれかになります。これらのオブジェクトは、サービスの検索要求から返され、登録されたサービスを記述しています。このクラスは、のjava.net.URLのサブクラスではなく、そのクラスが最終であるので、できないはずです。"
    },
    {
      "indent": 0,
      "text": "5.3.4.3. Class Variables",
      "section_title": true,
      "ja": "5.3.4.3。クラス変数"
    },
    {
      "indent": 3,
      "text": "public static final int NO_PORT = 0",
      "ja": "public static final int型のNO_PORT = 0"
    },
    {
      "indent": 3,
      "text": "Indicates that no port information is required or was returned for this URL.",
      "ja": "何のポート情報が必要とされないか、このURLのために返されたことを示します。"
    },
    {
      "indent": 3,
      "text": "public static final int LIFETIME_NONE = 0",
      "ja": "= 0のpublic static final int型LIFETIME_NONE"
    },
    {
      "indent": 3,
      "text": "Indicates that the URL has a zero lifetime. This value is never returned from the API, but can be used to create a ServiceURL object to deregister, delete attributes, or find attributes.",
      "ja": "URLはゼロ寿命であることを示します。この値は、APIから返されることはありません、しかし、登録解除の属性を削除、または属性を見つけるために、serviceURLのオブジェクトを作成するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "public static final int LIFETIME_DEFAULT = 10800",
      "ja": "public static final int型LIFETIME_DEFAULT = 10800"
    },
    {
      "indent": 3,
      "text": "The default URL lifetime (3 hours) in seconds.",
      "ja": "秒のデフォルトのURLの有効期間（3時間）。"
    },
    {
      "indent": 3,
      "text": "public static final int LIFETIME_MAXIMUM = 65535",
      "ja": "public static final int型LIFETIME_MAXIMUM = 65535"
    },
    {
      "indent": 3,
      "text": "The maximum URL lifetime (about 18 hours) in seconds.",
      "ja": "秒で最大URLの寿命（約18時間）。"
    },
    {
      "indent": 3,
      "text": "public static final int LIFETIME_PERMANENT = -1",
      "ja": "public static final int型のLIFETIME_PERMANENT = -1"
    },
    {
      "indent": 3,
      "text": "Indicates that the API implementation should continuously re-register the URL until the application exits.",
      "ja": "APIの実装では、継続的にアプリケーションが終了するまで、URLを再登録する必要があることを示します。"
    },
    {
      "indent": 0,
      "text": "5.3.4.4. Constructors",
      "section_title": true,
      "ja": "5.3.4.4。コンストラクタ"
    },
    {
      "indent": 3,
      "text": "public ServiceURL(String URL,int lifetime)",
      "ja": "公共のserviceURL（文字列のURL、int型の寿命）"
    },
    {
      "indent": 3,
      "text": "Construct a service URL object having the specified lifetime.",
      "ja": "指定された寿命を持つサービスURLオブジェクトを構築します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL as a string. Must be either a service: URL or a valid generic URL according to RFC 2396 [2].",
      "ja": "文字列としてURL。 RFC 2396によるURLまたは有効なジェネリックURL [2]：サービスのいずれかでなければなりません。"
    },
    {
      "indent": 6,
      "text": "lifetime",
      "ja": "一生"
    },
    {
      "indent": 9,
      "text": "The service advertisement lifetime in seconds. This value may be between LIFETIME_NONE and LIFETIME_MAXIMUM.",
      "ja": "秒単位のサービス広告寿命。この値は、LIFETIME_NONEとLIFETIME_MAXIMUMの間であってもよいです。"
    },
    {
      "indent": 0,
      "text": "5.3.4.5. Methods",
      "section_title": true,
      "ja": "5.3.4.5。メソッド"
    },
    {
      "indent": 3,
      "text": "public ServiceType getServiceType()",
      "ja": "公共のServiceType getServiceType（）"
    },
    {
      "indent": 3,
      "text": "Returns the service type object representing the service type name of the URL.",
      "ja": "URLのサービスタイプの名前を表すサービスタイプオブジェクトを返します。"
    },
    {
      "indent": 2,
      "text": "public final void setServiceType(ServiceType type) throws ServiceLocationException",
      "ja": "公共の最終ボイドsetServiceType（サービス・タイプタイプ）ServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Set the service type name to the object. Ignored if the URL is a service: URL.",
      "ja": "オブジェクトへのサービスタイプ名を設定します。 URL：URLはサービスの場合は無視されます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ"
    },
    {
      "indent": 9,
      "text": "The service type object.",
      "ja": "サービスタイプオブジェクト。"
    },
    {
      "indent": 3,
      "text": "public String getTransport()",
      "ja": "公共の文字列getTransport（）"
    },
    {
      "indent": 3,
      "text": "Get the network layer transport identifier. If the transport is IP, an empty string, \"\", is returned.",
      "ja": "ネットワーク層、トランスポート識別子を取得します。トランスポートはIP、空の文字列、「」である場合、返されます。"
    },
    {
      "indent": 3,
      "text": "public String getHost()",
      "ja": "公共の文字列はGetHost（）"
    },
    {
      "indent": 3,
      "text": "Returns the host identifier. For IP, this will be the machine name or IP address.",
      "ja": "ホスト識別子を返します。 IPの場合、これはマシン名またはIPアドレスになります。"
    },
    {
      "indent": 3,
      "text": "public int getPort()",
      "ja": "公共int型のgetPort（）"
    },
    {
      "indent": 3,
      "text": "Returns the port number, if any. For non-IP transports, always returns NO_PORT.",
      "ja": "もしあれば、ポート番号を返します。非IPトランスポートのために、常にNO_PORTを返します。"
    },
    {
      "indent": 3,
      "text": "public String getURLPath()",
      "ja": "公共の文字列getURLPath（）"
    },
    {
      "indent": 3,
      "text": "Returns the URL path description, if any.",
      "ja": "もしあれば、URLパスの説明を返します。"
    },
    {
      "indent": 3,
      "text": "public int getLifetime()",
      "ja": "公共int型getLifetime（）"
    },
    {
      "indent": 3,
      "text": "Returns the service advertisement lifetime. This will be a positive int between LIFETIME_NONE and LIFETIME_MAXIMUM.",
      "ja": "サービス広告寿命を返します。これはLIFETIME_NONEとLIFETIME_MAXIMUMとの間には正の整数になります。"
    },
    {
      "indent": 3,
      "text": "public boolean equals(Object obj)",
      "ja": "パブリックブールのequals（オブジェクトobj）"
    },
    {
      "indent": 3,
      "text": "Compares the object to the ServiceURL and returns true if the two are the same. Two ServiceURL objects are equal if their current service types match and they have the same host, port, transport, and URL path.",
      "ja": "serviceURLのにオブジェクトを比較し、両者が同じであればtrueを返します。彼らの現在のサービスタイプが一致し、それらが同じホスト、ポート、輸送、およびURLパスを持っている場合、2つのserviceURLオブジェクトが等しいです。"
    },
    {
      "indent": 3,
      "text": "public String toString()",
      "ja": "公共の文字列のtoString（）"
    },
    {
      "indent": 3,
      "text": "Returns a formatted string with the URL. Overrides Object.toString(). The returned URL has the original service type or URL scheme, not the current service type.",
      "ja": "URLでフォーマットされた文字列を返します。 Object.ToStringをオーバーライドします（）。返されたURLは、元のサービスタイプまたはURLスキームではなく、現在のサービスの種類があります。"
    },
    {
      "indent": 3,
      "text": "public int hashCode()",
      "ja": "公共int型のhashCode（）"
    },
    {
      "indent": 3,
      "text": "Overrides Object.hashCode(). Hashes on the current service type, transport, host, port, and URL part.",
      "ja": "オーバーライドObject.hashCode（）。現在のサービスの種類、輸送、ホスト、ポート、およびURLの一部にハッシュ。"
    },
    {
      "indent": 0,
      "text": "5.4. SLP Access Interfaces",
      "section_title": true,
      "ja": "5.4。 SLPアクセスインターフェイス"
    },
    {
      "indent": 0,
      "text": "5.4.1. Interface Advertiser",
      "section_title": true,
      "ja": "5.4.1。インタフェースの広告主"
    },
    {
      "indent": 0,
      "text": "5.4.1.1. Synopsis",
      "section_title": true,
      "ja": "5.4.1.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "public interface Advertiser",
      "ja": "パブリックインターフェイスの広告主"
    },
    {
      "indent": 0,
      "text": "5.4.1.2. Description",
      "section_title": true,
      "ja": "5.4.1.2。説明"
    },
    {
      "indent": 3,
      "text": "The Advertiser is the SA interface, allowing clients to register new service instances with SLP, to change the attributes of existing services, and to deregister service instances. New registrations and modifications of attributes are made in the language locale with which the Advertiser was created, deregistrations of service instances are made for all locales.",
      "ja": "広告主は、クライアントが既存のサービスの属性を変更して、サービスインスタンスの登録を解除するために、SLPで新しいサービスインスタンスを登録することができ、SAインタフェースです。新規登録と属性の変更は広告主が作成された言語のロケールで行われ、サービスインスタンスの登録解除は、すべてのロケールのために作られています。"
    },
    {
      "indent": 0,
      "text": "5.4.1.3. Instance Methods",
      "section_title": true,
      "ja": "5.4.1.3。インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract Locale getLocale()",
      "ja": "パブリック抽象ロケールのgetLocale（）"
    },
    {
      "indent": 3,
      "text": "Return the language locale with which this object was created.",
      "ja": "このオブジェクトが作成された言語ロケールを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract void register(ServiceURL URL, Vector attributes) throws ServiceLocationException",
      "ja": "パブリック抽象ボイドレジスタ（serviceURLのURL、ベクター属性）ServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Register a new service with SLP having the given attributes.",
      "ja": "SLPは、指定された属性を持つ新しいサービスを登録します。"
    },
    {
      "indent": 3,
      "text": "The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "APIライブラリは、構成によって得られたすべてのスコープで操作を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL for the service.",
      "ja": "サービスのURL。"
    },
    {
      "indent": 6,
      "text": "attributes",
      "ja": "属性"
    },
    {
      "indent": 9,
      "text": "A vector of ServiceLocationAttribute objects describing the service.",
      "ja": "ServiceLocationAttributeのベクターは、サービスを記述するオブジェクト。"
    },
    {
      "indent": 3,
      "text": "public abstract void deregister(ServiceURL URL) throws ServiceLocationException",
      "ja": "パブリック抽象ボイド登録解除（serviceURLのURLは）ServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Deregister a service from the SLP framework. This has the effect of deregistering the service from every language locale. The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "SLPのフレームワークからサービスの登録を解除。これは、すべての言語ロケールからサービスを登録解除する効果があります。 APIライブラリは、構成によって得られたすべてのスコープで操作を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL for the service.",
      "ja": "サービスのURL。"
    },
    {
      "indent": 3,
      "text": "public abstract void addAttributes(ServiceURL URL, Vector attributes) throws ServiceLocationException",
      "ja": "公共の抽象無効addAttributes（serviceURLのURLは、ベクター属性）ServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Update the registration by adding the given attributes. The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "指定された属性を追加することにより、登録を更新します。 APIライブラリは、構成によって得られたすべてのスコープで操作を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL for the service.",
      "ja": "サービスのURL。"
    },
    {
      "indent": 6,
      "text": "attributes",
      "ja": "属性"
    },
    {
      "indent": 9,
      "text": "A Vector of ServiceLocationAttribute objects to add to the existing registration. Use an empty vector to update the URL alone. May not be null.",
      "ja": "ServiceLocationAttributeのベクトルは、既存の登録に追加するオブジェクト。単独のURLを更新するために、空のベクターを使用してください。 nullではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "public abstract void deleteAttributes(ServiceURL URL, Vector attributeIds) throws ServiceLocationException",
      "ja": "公共の抽象無効deleteAttributes（serviceURLのURL、ベクトルattributeIds）がServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Delete the attributes from a URL for the locale with which the Advertiser was created. The API library is required to perform the operation in all scopes obtained through configuration.",
      "ja": "広告主が作成されたロケールのためのURLから属性を削除します。 APIライブラリは、構成によって得られたすべてのスコープで操作を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL for the service.",
      "ja": "サービスのURL。"
    },
    {
      "indent": 6,
      "text": "attributeIds",
      "ja": "attributeIds"
    },
    {
      "indent": 9,
      "text": "A vector of Strings indicating the ids of the attributes to remove. The strings may be attribute ids or they may be wildcard patterns to match ids. See [7] for the syntax of wildcard patterns. The strings may include SLP reserved characters, they will be escaped by the API before transmission. May not be the empty vector or null.",
      "ja": "除去するために、属性のIDを表す文字列のベクトル。文字列は、属性IDであってもよく、またはそれらは、IDと一致するワイルドカードパターンかもしれません。ワイルドカードパターンの構文については、[7]を参照してください。文字列は、SLPの予約文字を含むことができ、彼らは、送信前にAPIによってエスケープされます。空のベクターまたはnullではないかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Interface Locator",
      "section_title": true,
      "ja": "5.4.2。インターフェイスのロケータ"
    },
    {
      "indent": 0,
      "text": "5.4.2.1. Synopsis",
      "section_title": true,
      "ja": "5.4.2.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "public interface Locator",
      "ja": "パブリックインターフェイスロケータ"
    },
    {
      "indent": 0,
      "text": "5.4.2.2. Description",
      "section_title": true,
      "ja": "5.4.2.2。説明"
    },
    {
      "indent": 3,
      "text": "The Locator is the UA interface, allowing clients to query the SLP framework about existing service types, services instances, and about the attributes of an existing service instance or service type. Queries for services and attributes are made in the locale with which the Locator was created, queries for service types are independent of locale.",
      "ja": "ロケータは、クライアントは既存のサービスタイプについてSLPのフレームワークを照会することができ、UAインタフェースであるサービスインスタンス、および既存のサービス・インスタンスまたはサービスタイプの属性について。サービスや属性のクエリは、サービスの種類のクエリは、ロケールから独立している、ロケータが作成されたロケールで作られています。"
    },
    {
      "indent": 0,
      "text": "5.4.2.3. Instance Methods",
      "section_title": true,
      "ja": "5.4.2.3。インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract Locale getLocale()",
      "ja": "パブリック抽象ロケールのgetLocale（）"
    },
    {
      "indent": 3,
      "text": "Return the language locale with which this object was created.",
      "ja": "このオブジェクトが作成された言語ロケールを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationEnumeration findServiceTypes(String namingAuthority, Vector scopes) throws ServiceLocationException",
      "ja": "パブリック抽象ServiceLocation列挙findServiceTypes（文字列庁、ベクトルスコープを命名）はServiceLocation例外がスローされます"
    },
    {
      "indent": 3,
      "text": "Returns an enumeration of ServiceType objects giving known service types for the given scopes and given naming authority. If no service types are found, an empty enumeration is returned.",
      "ja": "与えられたスコープと与えられた命名機関のための既知のサービスタイプを与えるサービス・タイプオブジェクトの列挙を返します。何のサービスタイプが見つからない場合は、空の列挙が返されます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "namingAuthority",
      "ja": "namingAuthority"
    },
    {
      "indent": 9,
      "text": "The naming authority. Use \"\" for the default naming authority and \"*\" for all naming authorities.",
      "ja": "命名機関。すべての命名当局のための*「「権威と命名デフォルトのために」」を使用します。"
    },
    {
      "indent": 6,
      "text": "scopes",
      "ja": "スコープ"
    },
    {
      "indent": 9,
      "text": "A Vector of scope names. The vector should be selected from the results of a findScopes() API invocation. Use \"DEFAULT\" for the default scope.",
      "ja": "スコープ名のベクトル。ベクターはfindScopes（）API呼び出しの結果から選択しなければなりません。デフォルトのスコープのための「DEFAULT」を使用してください。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationEnumeration findServices(ServiceType type, Vector scopes, String searchFilter) throws ServiceLocationException",
      "ja": "パブリック抽象ServiceLocationEnumerationのfindServices（サービス・タイプタイプ、ベクトルスコープ、文字列searchFilter）ServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Returns a vector of ServiceURL objects for services matching the query, and having a matching type in the given scopes. If no services are found, an empty enumeration is returned.",
      "ja": "クエリに一致するサービスのためのserviceURLオブジェクトのベクトルを返し、そして与えられたスコープ内の一致する型を有します。何のサービスが見つからない場合は、空の列挙が返されます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ"
    },
    {
      "indent": 9,
      "text": "The SLP service type of the service.",
      "ja": "サービスのSLPサービスタイプ。"
    },
    {
      "indent": 6,
      "text": "scopes",
      "ja": "スコープ"
    },
    {
      "indent": 9,
      "text": "A Vector of scope names. The vector should be selected from the results of a findScopes() API invocation. Use \"DEFAULT\" for the default scope.",
      "ja": "スコープ名のベクトル。ベクターはfindScopes（）API呼び出しの結果から選択しなければなりません。デフォルトのスコープのための「DEFAULT」を使用してください。"
    },
    {
      "indent": 6,
      "text": "searchFilter",
      "ja": "searchFilter"
    },
    {
      "indent": 9,
      "text": "An LDAPv3 [4] string encoded query. If the filter is empty, i.e. \"\", all services of the requested type in the specified scopes are returned. SLP reserved characters must be escaped in the query. Use ServiceLocationAttribute.escapeId() and ServiceLocationAttribute.escapeValue() to construct the query.",
      "ja": "LDAPv3の[4]の文字列エンコードされたクエリ。フィルタが空の場合、つまり「」、指定されたスコープで要求されたタイプのすべてのサービスが返されます。 SLP予約文字は、クエリでエスケープする必要があります。クエリを構築するためにServiceLocationAttribute.escapeId（）とServiceLocationAttribute.escapeValue（）を使用します。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationEnumeration findAttributes(ServiceURL URL, Vector scopes, Vector attributeIds) throws ServiceLocationException",
      "ja": "パブリック抽象ServiceLocationEnumerationのfindAttributes（serviceURLのURL、ベクトルスコープ、ベクトルattributeIds）がServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "For the URL and scope, return a Vector of ServiceLocationAttribute objects whose ids match the String patterns in the attributeIds Vector. The request is made in the language locale of the Locator. If no attributes match, an empty enumeration is returned.",
      "ja": "URLと範囲については、IDS attributeIds Vector内の文字列パターンに一致するServiceLocationAttributeオブジェクトのベクトルを返します。要求は、ロケータの言語ロケールに行われます。何の属性が一致しない場合は、空の列挙が返されます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "URL",
      "ja": "URL"
    },
    {
      "indent": 9,
      "text": "The URL for which the attributes are desired.",
      "ja": "属性が望まれているURL。"
    },
    {
      "indent": 6,
      "text": "scopes",
      "ja": "スコープ"
    },
    {
      "indent": 9,
      "text": "A Vector of scope names. The vector should be selected from the results of a findScopes() API invocation. Use \"DEFAULT\" for the default scope.",
      "ja": "スコープ名のベクトル。ベクターはfindScopes（）API呼び出しの結果から選択しなければなりません。デフォルトのスコープのための「DEFAULT」を使用してください。"
    },
    {
      "indent": 6,
      "text": "attributeIds",
      "ja": "attributeIds"
    },
    {
      "indent": 9,
      "text": "A Vector of String patterns identifying the desired attributes. An empty vector means return all attributes. As described in [7], the patterns may include wildcards to match substrings. The strings may include SLP reserved characters, they will be escaped by the API before transmission.",
      "ja": "所望の属性を特定する文字列パターンのベクター。空のベクターは、すべての属性を返すことを意味します。 [7]で説明したように、パターンがサブストリングに一致するようにワイルドカードを含むことができます。文字列は、SLPの予約文字を含むことができ、彼らは、送信前にAPIによってエスケープされます。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationEnumeration findAttributes(ServiceType type, Vector scopes, Vector attributeIds) throws ServiceLocationException",
      "ja": "パブリック抽象ServiceLocationEnumerationのfindAttributes（サービス・タイプタイプ、ベクトルスコープ、ベクトルattributeIds）ServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "For the type and scope, return a Vector of all ServiceLocationAttribute objects whose ids match the String patterns in the attributeIds Vector regardless of the Locator's locale. The request is made independent of language locale. If no attributes are found, an empty vector is returned.",
      "ja": "種類と範囲については、IDSかかわらずロケータのロケールのattributeIdsベクトルで文字列パターンに一致するすべてのServiceLocationAttributeオブジェクトのベクトルを返します。リクエストは、言語のロケールとは独立して行われます。属性が見つからない場合は、空のベクトルが返されます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "serviceType",
      "ja": "サービスの種類"
    },
    {
      "indent": 9,
      "text": "The service type.",
      "ja": "サービスタイプ。"
    },
    {
      "indent": 6,
      "text": "scopes",
      "ja": "スコープ"
    },
    {
      "indent": 9,
      "text": "A Vector of scope names. The vector should be selected from the results of a findScopes() API invocation. Use \"DEFAULT\" for the default scope.",
      "ja": "スコープ名のベクトル。ベクターはfindScopes（）API呼び出しの結果から選択しなければなりません。デフォルトのスコープのための「DEFAULT」を使用してください。"
    },
    {
      "indent": 6,
      "text": "attributeIds",
      "ja": "attributeIds"
    },
    {
      "indent": 9,
      "text": "A Vector of String patterns identifying the desired attributes. An empty vector means return all attributes. As described in [7], the patterns may include wildcards to match all prefixes or suffixes. The patterns may include SLP reserved characters, they will be escaped by the API before transmission.",
      "ja": "所望の属性を特定する文字列パターンのベクター。空のベクターは、すべての属性を返すことを意味します。 [7]で説明したように、パターンは、すべてのプレフィックスまたはサフィックスと一致するワイルドカードを含むことができます。パターンはSLP予約文字を含むことができ、それらは送信前にAPIによってエスケープされます。"
    },
    {
      "indent": 0,
      "text": "5.5. The Service Location Manager",
      "section_title": true,
      "ja": "5.5。サービスロケーションマネージャ"
    },
    {
      "indent": 0,
      "text": "5.5.1. Class ServiceLocationManager",
      "section_title": true,
      "ja": "5.5.1。クラスServiceLocationManager"
    },
    {
      "indent": 0,
      "text": "5.5.1.1. Synopsis",
      "section_title": true,
      "ja": "5.5.1.1。シノプシス"
    },
    {
      "indent": 4,
      "text": "public class ServiceLocationManager\nextends Object",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.5.1.2. Description",
      "section_title": true,
      "ja": "5.5.1.2。説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationManager manages access to the service location framework. Clients obtain the Locator and Advertiser objects for UA and SA, and a Vector of known scope names from the ServiceLocationManager.",
      "ja": "ServiceLocationManagerは、サービス・ロケーション・フレームワークへのアクセスを管理します。クライアントは、UAとSA、およびServiceLocationManagerから知られているスコープ名のベクトル用のLocatorおよび広告主のオブジェクトを取得します。"
    },
    {
      "indent": 0,
      "text": "5.5.1.3. Class Methods",
      "section_title": true,
      "ja": "5.5.1.3。クラスメソッド"
    },
    {
      "indent": 3,
      "text": "public static int getRefreshInterval() throws ServiceLocationException",
      "ja": "公共の静的なint型getRefreshIntervalは（）ServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Returns the maximum across all DAs of the min-refresh-interval attribute. This value satisfies the advertised refresh interval bounds for all DAs, and, if used by the SA, assures that no refresh registration will be rejected. If no DA advertises a min-refresh-interval attribute, a value of 0 is returned.",
      "ja": "min-refresh-interval属性のすべてのDA間で最大値を返します。この値は、すべてのDAのための広告を出してリフレッシュ間隔の範囲を満たし、かつ、SAが使用している場合、何のリフレッシュ登録が拒否されないことを保証します。何DAが最小リフレッシュ間隔属性をアドバタイズしていない場合は、0の値が返されます。"
    },
    {
      "indent": 3,
      "text": "public static Vector findScopes() throws ServiceLocationException",
      "ja": "パブリック静的ベクトルfindScopes（）ServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Returns an Vector of strings with all available scope names. The list of scopes comes from a variety of sources, see Section 2.1 for the scope discovery algorithm. There is always at least one string in the Vector, the default scope, \"DEFAULT\".",
      "ja": "利用可能なすべてのスコープ名を持つ文字列のベクトルを返します。スコープのリストは、さまざまなソースから来て、スコープの発見アルゴリズムについては、セクション2.1を参照してください。ベクトル、デフォルトのスコープ、「DEFAULT」内の少なくとも1つの文字列が常にあります。"
    },
    {
      "indent": 3,
      "text": "public static Locator getLocator(Locale locale) throws ServiceLocationException",
      "ja": "公共の静的なロケータgetLocator（ロケールロケールは）ServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Return a Locator object for the given language Locale. If the implementation does not support UA functionality, returns null.",
      "ja": "特定の言語のロケールのためのLocatorオブジェクトを返します。実装はUAの機能をサポートしていない場合は、nullを返します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "locale",
      "ja": "ローカル"
    },
    {
      "indent": 9,
      "text": "The language locale of the Locator. The default SLP locale is used if null.",
      "ja": "ロケータの言語ロケール。 nullの場合、デフォルトSLPのロケールが使用されています。"
    },
    {
      "indent": 3,
      "text": "public static Advertiser getAdvertiser(Locale locale) throws ServiceLocationException",
      "ja": "公共の静的な広告主getAdvertiser（ロケールロケールは）ServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Return an Advertiser object for the given language locale. If the implementation does not support SA functionality, returns null.",
      "ja": "与えられた言語ロケールのための広告主オブジェクトを返します。実装がSAの機能をサポートしていない場合は、nullを返します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "locale",
      "ja": "ローカル"
    },
    {
      "indent": 9,
      "text": "The language locale of the Advertiser. The default SLP locale is used if null.",
      "ja": "広告主の言語ロケール。 nullの場合、デフォルトSLPのロケールが使用されています。"
    },
    {
      "indent": 0,
      "text": "5.6. Service Template Introspection",
      "section_title": true,
      "ja": "5.6。サービステンプレートのイントロスペクション"
    },
    {
      "indent": 0,
      "text": "5.6.1. Abstract Class TemplateRegistry",
      "section_title": true,
      "ja": "5.6.1。抽象クラスTemplateRegistry"
    },
    {
      "indent": 0,
      "text": "5.6.1.1. Synopsis",
      "section_title": true,
      "ja": "5.6.1.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "public abstract class TemplateRegistry",
      "ja": "パブリック抽象クラスTemplateRegistry"
    },
    {
      "indent": 0,
      "text": "5.6.1.2. Description",
      "section_title": true,
      "ja": "5.6.1.2。説明"
    },
    {
      "indent": 3,
      "text": "Subclasses of the TemplateRegistry abstract class provide access to service location templates [8]. Classes implementing TemplateRegistry perform a variety of functions. They manage the registration and access of service type template documents. They create attribute verifiers from service templates, for verification of attributes and introspection on template documents. Note that clients of the Advertiser are not required to verify attributes before registering (though they may get a TYPE_ERROR if the implementation supports type checking and there is a mismatch with the template).",
      "ja": "TemplateRegistry抽象クラスのサブクラスは、サービス・ロケーション・テンプレートへのアクセスを提供[8]。 TemplateRegistryを実装するクラスは、さまざまな機能を実行します。彼らは、サービスタイプのテンプレート文書の登録とアクセスを管理します。彼らは、テンプレート文書の属性と内省の検証のために、サービステンプレートから属性検証を作成します。 （実装は型チェックをサポートし、テンプレートとのミスマッチがある場合、彼らはTYPE_ERRORを得るかもしれません）広告主のクライアントが登録する前に、属性を検証するために必要とされていないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.6.1.3. Class Methods",
      "section_title": true,
      "ja": "5.6.1.3。クラスメソッド"
    },
    {
      "indent": 3,
      "text": "public static TemplateRegistry getTemplateRegistry();",
      "ja": "パブリック静的TemplateRegistry getTemplateRegistry（）;"
    },
    {
      "indent": 3,
      "text": "Returns the distinguished TemplateRegistry object for performing operations on and with service templates. Returns null if the implementation doesn't support TemplateRegistry functionality.",
      "ja": "上およびサービステンプレートで操作を実行するために区別TemplateRegistryオブジェクトを返します。実装がTemplateRegistry機能をサポートしていない場合はnullを返します。"
    },
    {
      "indent": 0,
      "text": "5.6.1.4. Instance Methods",
      "section_title": true,
      "ja": "5.6.1.4。インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract void registerServiceTemplate(ServiceType type, String documentURL, Locale locale, String version) throws ServiceLocationException",
      "ja": "パブリック抽象ボイドregisterServiceTemplate（サービス・タイプの種類、文字列documentURL、ロケールロケール、文字列バージョン）がServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Register the service template with the template registry.",
      "ja": "テンプレートレジストリでサービステンプレートを登録します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ"
    },
    {
      "indent": 9,
      "text": "The service type.",
      "ja": "サービスタイプ。"
    },
    {
      "indent": 6,
      "text": "documentURL",
      "ja": "DocumentUrl"
    },
    {
      "indent": 9,
      "text": "A string containing the URL of the template document. May not be the empty string.",
      "ja": "テンプレート文書のURLを含む文字列。空の文字列ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "locale",
      "ja": "ローカル"
    },
    {
      "indent": 9,
      "text": "A Locale object containing the language locale of the template.",
      "ja": "テンプレートの言語ロケールを含むLocaleオブジェクト。"
    },
    {
      "indent": 6,
      "text": "version",
      "ja": "版"
    },
    {
      "indent": 9,
      "text": "The version number identifier of template document.",
      "ja": "テンプレートドキュメントのバージョン番号識別子。"
    },
    {
      "indent": 3,
      "text": "public abstract void",
      "ja": "公共の抽象無効"
    },
    {
      "indent": 3,
      "text": "deregisterServiceTemplate(ServiceType type, Locale locale, String version) throws ServiceLocationException",
      "ja": "deregisterServiceTemplate（サービス・タイプタイプ、ロケールロケール、文字列バージョン）がServiceLocationExceptionをスロー"
    },
    {
      "indent": 3,
      "text": "Deregister the template for the service type.",
      "ja": "サービスタイプのテンプレートの登録を解除します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ"
    },
    {
      "indent": 9,
      "text": "The service type.",
      "ja": "サービスタイプ。"
    },
    {
      "indent": 6,
      "text": "locale",
      "ja": "ローカル"
    },
    {
      "indent": 9,
      "text": "A Locale object containing the language locale of the template.",
      "ja": "テンプレートの言語ロケールを含むLocaleオブジェクト。"
    },
    {
      "indent": 6,
      "text": "version",
      "ja": "版"
    },
    {
      "indent": 9,
      "text": "A String containing the version number. Use null to indicate the latest version.",
      "ja": "バージョン番号を含むString。最新バージョンを示すためにnullを使用します。"
    },
    {
      "indent": 3,
      "text": "public abstract String findTemplateURL(ServiceType type, Locale locale, String version) throws ServiceLocationException",
      "ja": "パブリック抽象文字列findTemplateURL（サービス・タイプタイプ、ロケールロケールは、文字列バージョン）がServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Returns the URL for the template document.",
      "ja": "テンプレートドキュメントのURLを返します。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "type",
      "ja": "タイプ"
    },
    {
      "indent": 9,
      "text": "The service type.",
      "ja": "サービスタイプ。"
    },
    {
      "indent": 6,
      "text": "locale",
      "ja": "ローカル"
    },
    {
      "indent": 9,
      "text": "A Locale object containing the language locale of the template.",
      "ja": "テンプレートの言語ロケールを含むLocaleオブジェクト。"
    },
    {
      "indent": 6,
      "text": "version",
      "ja": "版"
    },
    {
      "indent": 9,
      "text": "A String containing the version number. Use null to indicate the latest version.",
      "ja": "バージョン番号を含むString。最新バージョンを示すためにnullを使用します。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationAttributeVerifier attributeVerifier(String documentURL) throws ServiceLocationException",
      "ja": "パブリック抽象ServiceLocationAttributeVerifier attributeVerifier（文字列documentURL）はServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Reads the template document URL and returns an attribute verifier for the service type. The attribute verifier can be used for verifying that registration attributes match the template, and for introspection on the template definition.",
      "ja": "テンプレートドキュメントのURLを読み込み、サービスタイプの属性の検証を返します。属性検証は、登録属性がテンプレートと一致することを確認するため、およびテンプレート定義のイントロスペクションのために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "documentURL",
      "ja": "DocumentUrl"
    },
    {
      "indent": 9,
      "text": "A String containing the template document's URL. May not be the empty string.",
      "ja": "テンプレート文書のURLを含む文字列。空の文字列ではないかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.6.2. Interface ServiceLocationAttributeVerifier",
      "section_title": true,
      "ja": "5.6.2。インタフェースServiceLocationAttributeVerifier"
    },
    {
      "indent": 0,
      "text": "5.6.2.1. Synopsis",
      "section_title": true,
      "ja": "5.6.2.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "public interface ServiceLocationAttributeVerifier",
      "ja": "パブリックインターフェイスServiceLocationAttributeVerifier"
    },
    {
      "indent": 0,
      "text": "5.6.2.2. Description",
      "section_title": true,
      "ja": "5.6.2.2。説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationAttributeVerifier provides access to service templates. Classes implementing this interface parse SLP template definitions, provide information on attribute definitions for service types, and verify whether a ServiceLocationAttribute object matches a template for a particular service type. Clients obtain ServiceLocationAttributeVerifier objects for specific SLP service types through the TemplateRegistry.",
      "ja": "ServiceLocationAttributeVerifierは、サービステンプレートへのアクセスを提供します。 SLPテンプレートの定義解析このインタフェースを実装するクラスは、サービスタイプの属性定義に関する情報を提供し、ServiceLocationAttributeオブジェクトは、特定のサービスタイプのテンプレートと一致するかどうかを確認します。クライアントはTemplateRegistryを通じて、特定のSLPサービスタイプのためのServiceLocationAttributeVerifierオブジェクトを取得します。"
    },
    {
      "indent": 0,
      "text": "5.6.2.3. Instance Methods",
      "section_title": true,
      "ja": "5.6.2.3。インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceType getServiceType()",
      "ja": "パブリック抽象のServiceType getServiceType（）"
    },
    {
      "indent": 3,
      "text": "Returns the SLP service type for which this is the verifier.",
      "ja": "これは検証されたSLPサービスタイプを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract Locale getLocale()",
      "ja": "パブリック抽象ロケールのgetLocale（）"
    },
    {
      "indent": 3,
      "text": "Return the language locale of the template.",
      "ja": "テンプレートの言語ロケールを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract String getVersion()",
      "ja": "パブリック抽象文字列GETVERSION（）"
    },
    {
      "indent": 3,
      "text": "Return the template version number identifier.",
      "ja": "テンプレートのバージョン番号識別子を返します。"
    },
    {
      "indent": 3,
      "text": "public abstract String getURLSyntax()",
      "ja": "パブリック抽象文字列getURLSyntax（）"
    },
    {
      "indent": 3,
      "text": "Return the URL syntax expression for the service: URL.",
      "ja": "URL：サービスのURL構文式を返します。"
    },
    {
      "indent": 3,
      "text": "public abstract String getDescription()",
      "ja": "パブリック抽象文字列のgetDescription（）"
    },
    {
      "indent": 3,
      "text": "Return the descriptive help text for the template.",
      "ja": "テンプレートの説明ヘルプテキストを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract ServiceLocationAttributeDescriptor getAttributeDescriptor(String attrId)",
      "ja": "パブリック抽象ServiceLocationAttributeDescriptor getAttributeDescriptor（文字列attrId）"
    },
    {
      "indent": 3,
      "text": "Return the ServiceLocationAttributeDescriptor for the attribute having the named id. If no such attribute exists in this template, return null. This method is primarily for GUI tools to display attribute information. Programmatic verification of attributes should use the verifyAttribute() method.",
      "ja": "idという名前を持つ属性のServiceLocationAttributeDescriptorを返します。そのような属性は、このテンプレートに存在しない場合は、nullを返します。このメソッドは、主に属性情報を表示するためのGUIツールです。属性のプログラムによる検証がverifyAttribute（）メソッドを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "public abstract Enumeration getAttributeDescriptors()",
      "ja": "パブリック抽象列挙getAttributeDescriptors（）"
    },
    {
      "indent": 3,
      "text": "Returns an Enumeration allowing introspection on the attribute definition in the service template. The Enumeration returns ServiceLocationAttributeDescriptor objects for the attributes. This method is primarily for GUI tools to display attribute information. Programmatic verification of attributes should use the verifyAttribute() method.",
      "ja": "サービステンプレート内の属性定義にイントロスペクションを可能Enumerationを返します。列挙属性のServiceLocationAttributeDescriptorオブジェクトを返します。このメソッドは、主に属性情報を表示するためのGUIツールです。属性のプログラムによる検証がverifyAttribute（）メソッドを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "public abstract void verifyAttribute( ServiceLocationAttribute attribute) throws ServiceLocationException",
      "ja": "公共の抽象無効verifyAttribute（ServiceLocationAttribute属性）がServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Verify that the attribute matches the template definition. If the attribute doesn't match, ServiceLocationException is thrown with the error code as ServiceLocationException.PARSE_ERROR.",
      "ja": "属性は、テンプレートの定義と一致することを確認します。属性が一致しない場合は、ServiceLocationExceptionはServiceLocationException.PARSE_ERRORとしてエラーコードでスローされます。"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "attribute",
      "ja": "属性"
    },
    {
      "indent": 9,
      "text": "The ServiceLocationAttribute object to be verified.",
      "ja": "ServiceLocationAttributeオブジェクトを検証します。"
    },
    {
      "indent": 3,
      "text": "public abstract void verifyRegistration( Vector attributeVector) throws ServiceLocationException",
      "ja": "パブリック抽象ボイドverifyRegistration（ベクターattributeVector）はServiceLocationExceptionを投げます"
    },
    {
      "indent": 3,
      "text": "Verify that the Vector of ServiceLocationAttribute objects matches the template for this service type. The vector must contain all the required attributes, and all attributes must match their template definitions. If the attributes don't match, ServiceLocationException is thrown with the error code as ServiceLocationException.PARSE_ERROR",
      "ja": "ServiceLocationAttributeオブジェクトのベクトルがこのサービスタイプのテンプレートと一致することを確認します。ベクターは、必要なすべての属性が含まれている必要があり、そしてすべての属性は、そのテンプレートの定義と一致する必要があります。属性が一致しない場合は、ServiceLocationExceptionはServiceLocationException.PARSE_ERRORとしてエラーコードでスローされます"
    },
    {
      "indent": 3,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 6,
      "text": "attributeVector",
      "ja": "属性ベクトル"
    },
    {
      "indent": 9,
      "text": "A Vector of ServiceLocationAttribute objects for the registration.",
      "ja": "ServiceLocationAttributeのベクトルは、登録のためのオブジェクト。"
    },
    {
      "indent": 0,
      "text": "5.6.3. Interface ServiceLocationAttributeDescriptor",
      "section_title": true,
      "ja": "5.6.3。インタフェースServiceLocationAttributeDescriptor"
    },
    {
      "indent": 0,
      "text": "5.6.3.1. Synopsis",
      "section_title": true,
      "ja": "5.6.3.1。シノプシス"
    },
    {
      "indent": 3,
      "text": "public interface ServiceLocationAttributeDescriptor",
      "ja": "パブリックインターフェイスServiceLocationAttributeDescriptor"
    },
    {
      "indent": 0,
      "text": "5.6.3.2. Description",
      "section_title": true,
      "ja": "5.6.3.2。説明"
    },
    {
      "indent": 3,
      "text": "The ServiceLocationAttributeDescriptor interface provides introspection on a template attribute definition. Classes implementing the ServiceLocationAttributeDescriptor interface return information on a particular service location attribute definition from the service template. This information is primarily for GUI tools. Programmatic attribute verification should be done through the ServiceLocationAttributeVerifier.",
      "ja": "ServiceLocationAttributeDescriptorインタフェースは、テンプレート属性の定義にイントロスペクションを提供します。特定のサービスの場所にServiceLocationAttributeDescriptorインターフェイスのリターン情報を実装するクラスは、サービステンプレートから属性定義。この情報は、主にGUIツールです。プログラムによる属性検証はServiceLocationAttributeVerifierを介して行われるべきです。"
    },
    {
      "indent": 0,
      "text": "5.6.3.3. Instance Methods",
      "section_title": true,
      "ja": "5.6.3.3。インスタンスメソッド"
    },
    {
      "indent": 3,
      "text": "public abstract String getId()",
      "ja": "パブリック抽象文字列のgetId（）"
    },
    {
      "indent": 3,
      "text": "Return a String containing the attribute's id.",
      "ja": "属性のIDを含むStringを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract String getValueType()",
      "ja": "パブリック抽象文字列getValueType（）"
    },
    {
      "indent": 3,
      "text": "Return a String containing the fully package-qualified Java type of the attribute. SLP types are translated into Java types as follows:",
      "ja": "属性の完全パッケージ修飾Javaタイプを含む文字列を返します。次のようにSLPタイプは、Javaの型に変換されます："
    },
    {
      "indent": 6,
      "text": "STRING",
      "ja": "STRING"
    },
    {
      "indent": 9,
      "text": "\"java.lang.String\"",
      "ja": "\"java.lang.Stringで\""
    },
    {
      "indent": 6,
      "text": "INTEGER",
      "ja": "整数"
    },
    {
      "indent": 9,
      "text": "\"java.lang.Integer\"",
      "ja": "\"java.lang.Integerの\""
    },
    {
      "indent": 6,
      "text": "BOOLEAN",
      "ja": "BOOLEAN"
    },
    {
      "indent": 9,
      "text": "\"java.lang.Boolean\"",
      "ja": "\"java.lang.Booleanの\""
    },
    {
      "indent": 6,
      "text": "OPAQUE",
      "ja": "OPAQUE"
    },
    {
      "indent": 9,
      "text": "\"[B\" (i.e. array of byte, byte[])",
      "ja": "\"[B\"（バイトのすなわち配列、バイト[]）"
    },
    {
      "indent": 6,
      "text": "KEYWORD",
      "ja": "キーワード"
    },
    {
      "indent": 9,
      "text": "empty string, \"\"",
      "ja": "空の文字列、「」"
    },
    {
      "indent": 1,
      "text": "public abstract String getDescription()",
      "ja": "パブリック抽象文字列のgetDescription（）"
    },
    {
      "indent": 3,
      "text": "Return a String containing the attribute's help text.",
      "ja": "属性のヘルプテキストを含むStringを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract Enumeration getAllowedValues()",
      "ja": "パブリック抽象列挙getAllowedValues（）"
    },
    {
      "indent": 3,
      "text": "Return an Enumeration of allowed values for the attribute type. For keyword attributes returns null. For no allowed values (i.e. unrestricted) returns an empty Enumeration.",
      "ja": "属性タイプのための許容値のEnumerationを返します。キーワードの場合はnullを返します属性。無許可された値（すなわち、無制限）のための空の列挙を返します。"
    },
    {
      "indent": 3,
      "text": "public abstract Enumeration getDefaultValues()",
      "ja": "パブリック抽象列挙getDefaultValues（）"
    },
    {
      "indent": 3,
      "text": "Return an Enumeration of default values for the attribute type. For keyword attributes returns null. For no allowed values (i.e. unrestricted) returns an empty Enumeration.",
      "ja": "属性タイプのデフォルト値のEnumerationを返します。キーワードの場合はnullを返します属性。無許可された値（すなわち、無制限）のための空の列挙を返します。"
    },
    {
      "indent": 3,
      "text": "public abstract boolean getRequiresExplicitMatch()",
      "ja": "パブリック抽象ブールgetRequiresExplicitMatch（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the \"X\"\" flag is set, indicating that the attribute should be included in an any Locator.findServices() request search filter.",
      "ja": "属性は任意Locator.findServices（）リクエスト検索フィルタに含まれるべきであることを示し、「X」」フラグが設定されている場合にtrueを返し。"
    },
    {
      "indent": 3,
      "text": "public abstract boolean getIsMultivalued()",
      "ja": "getIsMultivaluedパブリック抽象ブール（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the \"M\" flag is set.",
      "ja": "「M」フラグが設定されている場合はtrueを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract boolean getIsOptional()",
      "ja": "パブリック抽象ブールgetIsOptional（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the \"O\"\" flag is set.",
      "ja": "「O」」フラグが設定されている場合はtrueを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract boolean getIsLiteral()",
      "ja": "パブリック抽象ブールgetIsLiteral（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the \"L\" flag is set.",
      "ja": "「L」フラグが設定されている場合はtrueを返します。"
    },
    {
      "indent": 3,
      "text": "public abstract boolean getIsKeyword()",
      "ja": "パブリック抽象ブールgetIsKeyword（）"
    },
    {
      "indent": 3,
      "text": "Returns true if the attribute is a keyword attribute.",
      "ja": "属性がキーワード属性である場合にtrueを返します。"
    },
    {
      "indent": 0,
      "text": "5.7. Implementation Notes",
      "section_title": true,
      "ja": "5.7。実装の注意事項"
    },
    {
      "indent": 0,
      "text": "5.7.1. Refreshing Registrations",
      "section_title": true,
      "ja": "5.7.1。さわやか登録"
    },
    {
      "indent": 3,
      "text": "A special lifetime constant, ServiceURL.LIFETIME_PERMANENT, is used by clients to indicate that the URL should be automatically refreshed until the application exits. The API implementation should interpret this flag as indicating that the URL lifetime is ServiceURL.LIFETIME_MAXIMUM, and MUST arrange for automatic refresh to occur.",
      "ja": "特別寿命定数、ServiceURL.LIFETIME_PERMANENTは、URLが自動的にアプリケーションが終了するまでリフレッシュする必要があることを示すために、クライアントによって使用されます。 APIの実装では、URL寿命がServiceURL.LIFETIME_MAXIMUMであることを示すように、このフラグを解釈しなければならない、と自動リフレッシュが発生するのを手配しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.7.2. Parsing Alternate Transports in ServiceURL",
      "section_title": true,
      "ja": "5.7.2。 serviceURLの中で代替トランスポートの解析"
    },
    {
      "indent": 3,
      "text": "The ServiceURL class is designed to handle multiple transports. The standard API performs no additional processing on transports other than IP except to separate out the host identifier and the URL path. However, implementations are free to subclass ServiceURL and support additional methods that provide more detailed parsing of alternate transport information. For IP transport, the port number, if any, is returned from the getPort() method. For non-IP transports, the getPort() method returns NO_PORT.",
      "ja": "serviceURLのクラスは、複数のトランスポートを処理するように設計されています。標準APIは、ホスト識別子とURLパスを分離する以外にIP以外のトランスポートには、追加の処理を行いません。しかし、実装はのserviceURLをサブクラス化し、代替トランスポート情報のより詳細な解析を提供する追加の方法をサポートして自由です。 IPトランスポートのために、ポート番号は、もしあれば、のgetPort（）メソッドから返されます。非IPのトランスポートのために、のgetPort（）メソッドはNO_PORTを返します。"
    },
    {
      "indent": 0,
      "text": "5.7.3. String Attribute Values",
      "section_title": true,
      "ja": "5.7.3。文字列の属性値"
    },
    {
      "indent": 3,
      "text": "In general, translation between Java types for attribute values and the SLP on-the-wire string is straightforward. However, there are two corner cases. If the Java attribute value type is String and the value of the string has an on-the-wire representation that is inferred by SLP as an integer, the registered attribute value may not be what the API client intended. A similar problem could result if the Java attribute value is the string \"true\" or \"false\", in which case the on-the-wire representation is inferred to boolean. To handle these corner cases, the Java API prepends a space onto the string. So, for example, if the string attribute value is \"123\", the Java API transforms the value to \"123 \", which will have an on-the-wire representation that is inferred by SLP to be string. Since appended and prepended spaces have no effect on query handling, this procedure should cause no problem with queries. API clients need to be aware, however, that the transformation is occurring.",
      "ja": "一般的には、属性値とSLPオン・ワイヤー文字列のJava型間の変換は簡単です。しかし、2つの角ケースがあります。 Javaは値型が文字列であると、文字列の値が整数としてSLPによって推論されたオン・ワイヤー表現を持つ属性場合は、登録した属性値は、APIクライアントが意図したものではないかもしれません。 Java属性の値は、オン・ワイヤー表現はブールと推測されている場合には、文字列「true」または「false」である場合、同様の問題が発生する可能性があります。これらのコーナーケースを処理するには、Java APIには、文字列にスペースを付加します。文字列の属性値が「123」であれば、例えば、Java APIには、文字列であることをSLPによって推論されたオン・ワイヤーの表現があります値を「123」に、変換します。追加され、先頭に追加スペースは、クエリの処理に影響を与えないので、この手順は、クエリで問題ないはずです。 APIクライアントは、変換が発生していること、しかし、注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.7.4. Client Side Syntax Checking",
      "section_title": true,
      "ja": "5.7.4。クライアント側の構文チェック"
    },
    {
      "indent": 3,
      "text": "The syntax of scope names, service type names, naming authority names, and URLs is described in [7] and [8]. The various methods and classes taking String parameters for these entities SHOULD type check the parameters for syntax errors on the client side, and throw an IllegalArgumentException if an error occurs. In addition, character escaping SHOULD be implemented before network transmission for escapable characters in attribute ids and String values. This reduces the number of error messages transmitted. The ServiceLocationAttribute class provides methods for clients to obtain escaped attribute id and value strings to facilitate query construction.",
      "ja": "スコープ名、サービスタイプ名、命名権限名、URLの構文はに記載されている[7]と[8]。これらのエンティティのための文字列パラメータを取り、様々なメソッドやクラスは、クライアント側での構文エラーのためのパラメータをチェック入力し、エラーが発生した場合、IllegalArgumentExceptionをスローする必要があります。また、文字のエスケープには、属性IDと文字列値のエスケープ対象の文字のためのネットワーク伝送の前に実施されるべきです。これは、送信されたエラーメッセージの数を減らします。 ServiceLocationAttributeクラスは、クエリの構築を容易にするために、エスケープ属性IDと値の文字列を取得するために、クライアントのための方法を提供します。"
    },
    {
      "indent": 0,
      "text": "5.7.5. Language Locale Handling",
      "section_title": true,
      "ja": "5.7.5。言語ロケールの取り扱い"
    },
    {
      "indent": 3,
      "text": "The Locator and Advertiser interfaces are created with a Locale parameter. The language locale with which these objects are created is used in all SLP requests issued through the object. If the Locale parameter is null, the default SLP locale is used. The default SLP locale is determined by, first, checking the net.slp.locale System property. If that is unset, then the default SLP locale [7] is used, namely \"en\". Note that the default SLP locale may not be the same as the default Java locale.",
      "ja": "Locatorおよび広告主インタフェースは、Localeパラメータを使用して作成されます。これらのオブジェクトが作成されると言語ロケールは、オブジェクトを介して発行されたすべてのSLP要求で使用されています。 Localeパラメータがnullの場合、デフォルトのSLPのロケールが使用されています。デフォルトSLPのロケールはnet.slp.localeシステムプロパティをチェックし、最初に、によって決定されます。それが設定されていない場合、デフォルトのSLPロケール[7]すなわち「EN」、使用されています。デフォルトのSLPのロケールがデフォルトのJavaロケールと同じではないかもしれないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.7.6. Setting SLP System Properties",
      "section_title": true,
      "ja": "5.7.6。 SLPシステムのプロパティの設定"
    },
    {
      "indent": 3,
      "text": "SLP system properties that are originally set in the configuration file can be overridden programmatically in API clients by simply invoking the System.getProperties() operation to get a copy of the system properties, modifying or adding the SLP property in question, then using System.setProperties() to set the properties to the modified Property object. Program execution continues without interruption by substituting the default for the erroneous parameter. Errors are checked when the property is used and are logged.",
      "ja": "もともと構成ファイルで設定されているSLPのシステムプロパティは、単純に、システムプロパティのコピーを取得するにはSystem.getProperties（）操作を呼び出す変更したり、質問にSLPのプロパティを追加し、システムを使用してAPIクライアントにプログラムで上書きすることができます。修飾されたプロパティオブジェクトにプロパティを設定するためのsetProperties（）。プログラムの実行は、誤ったパラメータのデフォルトを代入することにより、中断することなく継続されます。エラーがプロパティが使用されたときにチェックされ、記録されます。"
    },
    {
      "indent": 3,
      "text": "The SLP configuration file cannot be read with the java.util.Properties file reader because there are some syntactic differences. The SLP configuration file syntax defines a different escape convention for non-ASCII characters than the Java syntax. However, after the file has been read, the properties are stored and retrieved from java.util.Properties objects.",
      "ja": "いくつかの構文上の違いがあるので、SLPの設定ファイルは、java.util.Propertiesファイルリーダーで読み取ることができません。 SLP設定ファイルの構文は、Javaの文法よりも非ASCII文字に異なるエスケープ規則を定義します。ファイルが読み込まれた後しかし、プロパティが格納され、java.util.Propertiesオブジェクトから取り出されます。"
    },
    {
      "indent": 3,
      "text": "Properties are global for a process, affecting all threads and all Locator and Advertiser objects obtained through the ServiceLocationManager. With the exception of the net.slp.locale, net.slp.typeHint, and net.slp.maxResults properties, clients should rarely be required to override these properties, since they reflect properties of the SLP network that are not of concern to individual agents. If changes are required, system administrators should modify the configuration file.",
      "ja": "プロパティはServiceLocationManagerによって得られたすべてのスレッドとすべてのLocatorおよび広告主のオブジェクトに影響を与え、プロセスのグローバルです。彼らは個々に懸念はないSLPネットワークの性質を反映しているのでnet.slp.locale、net.slp.typeHint、およびnet.slp.maxResultsプロパティを除き、クライアントはめったに、これらのプロパティをオーバーライドするために必要とされるべきでありません薬。変更が必要な場合は、システム管理者は、設定ファイルを変更する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.7.7. Multithreading",
      "section_title": true,
      "ja": "5.7.7。マルチスレッド"
    },
    {
      "indent": 3,
      "text": "Thread-safe operation is relatively easy to achieve in Java. By simply making each method in the classes implementing the Locator and Advertiser interfaces synchronized, and by synchronizing access to any shared data structures within the class, the Locator and Advertiser interfaces are made safe. Alternatively, finer grained synchronization is also possible within the classes implementing Advertiser and Locator.",
      "ja": "スレッドセーフな操作は、Javaで実現することは比較的容易です。単に同期Locatorおよび広告主インターフェースを実装するクラスの各メソッドを作成し、クラス内の任意の共有データ構造へのアクセスを同期させることにより、ロケータ及び広告主インターフェースが安全にされている。によってまた、より細かい粒度の同期が広告主とロケータを実装するクラスの中にも可能です。"
    },
    {
      "indent": 0,
      "text": "5.7.8. Modular Implementations",
      "section_title": true,
      "ja": "5.7.8。モジュラー実装"
    },
    {
      "indent": 3,
      "text": "While, at first glance, the API may look rather heavyweight, the design has been carefully arranged so that modular implementations that provide only SA, only UA, or only service template access capability, or any combination of the three, are possible.",
      "ja": "一見、APIはヘビー級むしろ見えるかもしれないが唯一のSA、唯一のUA、または唯一のサービステンプレートのアクセス機能、または3のいずれかの組み合わせを提供するモジュール式の実装が可能となるように、デザインは慎重に配置されています。"
    },
    {
      "indent": 3,
      "text": "Because the objects returned from the ServiceLocationManager.getLocator() and ServiceLocationManager.getAdvertiser() operations are interfaces, and because the objects returned through those interfaces are in the set of base data structures, an implementation is free to omit either UA or SA capability by simply returning null from the instance creation operation if the classes implementing the missing function cannot be dynamically linked. API clients are encouraged to check for such a contingency, and to signal an exception if it occurs. Similarly, the TemplateRegistry concrete subclass can simply be omitted from an implementation that only supports UA and/or SA clients, and the TemplateRegistry.getRegistry() method can return null. In this way, the API implementation can be tailored for the particular memory requirements at hand.",
      "ja": "オブジェクトが（）操作はインターフェースであり、オブジェクトはこれらのインタフェースを介して返されるので、基本データ構造の組にあるServiceLocationManager.getLocator（）とServiceLocationManager.getAdvertiserから返されるので、実装は、UAによって、またはSAのいずれかの機能を省略して自由です不足している機能を実装するクラスを動的にリンクすることができない場合は、単純にインスタンス作成操作からnullを返します。 APIクライアントは、このような不測の事態を確認するために、それが発生した場合に例外を通知することをお勧めします。同様に、TemplateRegistry具象サブクラスは、単にだけUAおよび/またはSAクライアントをサポートする実装を省略することができ、及びTemplateRegistry.getRegistry（）メソッドがnullを返すことができます。このように、APIの実装では、手元にある特定のメモリ要件に合わせて調整することができます。"
    },
    {
      "indent": 3,
      "text": "In addition, if an implementation only supports the minimal subset of SLP [7], the unsupported Locator and Advertiser interface operations can throw an exception with ServiceLocationException.NOT_IMPLEMENTED as the error code. This supports better source portability between low and high memory platforms.",
      "ja": "実装のみSLP [7]の最小のサブセットをサポートしている場合に加えて、サポートされていないロケータ及び広告主インタフェース動作は、エラーコードとしてServiceLocationException.NOT_IMPLEMENTEDと例外をスローすることができます。これは、低および高メモリプラットフォーム間で、より良いソースの移植性をサポートしています。"
    },
    {
      "indent": 0,
      "text": "5.7.9. Asynchronous and Incremental Return Semantics",
      "section_title": true,
      "ja": "5.7.9。非同期および増分リターンセマンティクス"
    },
    {
      "indent": 3,
      "text": "The Java API contains no specific support for asynchronous operation. Incremental return is not needed for the Advertiser because service registrations can be broken up into pieces when large. Asynchronous return is also not needed because clients can always issue the Advertiser operation in a separate thread if the calling thread can't block.",
      "ja": "Java APIは、非同期操作のための特定のサポートが含まれていません。ときに大きなサービス登録が断片に分割することができますので、増分リターンが広告主のために必要とされていません。呼び出し元のスレッドをブロックすることができない場合、クライアントは常に別のスレッドで広告主の操作を発行することができるので、非同期復帰も必要とされていません。"
    },
    {
      "indent": 3,
      "text": "The Locator can be implemented either synchronously or asynchronously. Since the return type for Locator calls is ServiceLocationEnumeration, a Java API implementation that supports asynchronous semantics can implement ServiceLocationEnumeration to dole results out as they come in, blocking when no results are available. If the client code needs to support other processing while the results are trickling in, the call into the enumeration to retrieve the results can be done in a separate thread.",
      "ja": "ロケータは、同期的または非同期的に実装することができます。ロケータの戻り値の型は、呼び出しているのでServiceLocationEnumeration、彼らは何の結果が利用できないとき、ブロッキング、入ってくるような結果を分け与えるためにServiceLocationEnumerationを実装することができ、非同期のセマンティクスをサポートするJava APIの実装です。クライアントコードは、結果がで散水している間、他の処理をサポートする必要がある場合は、結果を取得するための列挙への呼び出しが別のスレッドで実行することができます。"
    },
    {
      "indent": 3,
      "text": "Unlike the C case, collation semantics for return of attributes when an attribute request by service type is made require that the API collate returned values so that only one attribute having a collation of all returned values appear to the API client. In practice, this may limit the amount of asynchronous processing possible with the findAttributes() method. This requirement is imposed because memory management is much easier in Java and so implementing collation as part of the API should not be as difficult as in C, and it saves the client from having to do the collation.",
      "ja": "Cの場合とは異なり、サービスの種類によって属性の要求が行われた属性の復帰のための照合のセマンティクスは、1つの属性のみがすべて返された値の照合がAPIクライアントに表示されたように、APIのCOLLATEが値を返されている必要があります。実際には、これはfindAttributes（）メソッドを使用して可能な非同期処理の量を制限することができます。メモリ管理は、Javaの方がはるかに簡単ですので、APIの一部として照合を実装するCほど難しいことではありませんので、この要件が課され、それは照合を行うすることからクライアントを節約できます。"
    },
    {
      "indent": 0,
      "text": "5.8. Example",
      "section_title": true,
      "ja": "5.8。例"
    },
    {
      "indent": 3,
      "text": "In this example, a printer server advertises its availability to clients. Additionally, the server advertises a service template for use by client software in validating service requests:",
      "ja": "この例では、プリンタサーバは、クライアントにその可用性をアドバタイズします。また、サーバは、サービス要求の検証では、クライアントソフトウェアで使用するためのサービステンプレートをアドバタイズします。"
    },
    {
      "indent": 2,
      "text": "//Get the Advertiser and TemplateRegistry.",
      "ja": "//広告主とTemplateRegistryを取得します。"
    },
    {
      "indent": 2,
      "text": "Advertiser adv = null; TemplateRegistry tr = null",
      "ja": "広告主ADV = NULL; TemplateRegistry TR = nullを"
    },
    {
      "indent": 2,
      "text": "try {",
      "ja": "{試します"
    },
    {
      "indent": 4,
      "text": "adv = ServiceLocationManager.getAdvertiser(\"en\");",
      "ja": "ADV = ServiceLocationManager.getAdvertiser（ \"を\"）;"
    },
    {
      "indent": 4,
      "text": "tr = TemplateRegistry.getTemplateRegistry();",
      "ja": "TR = TemplateRegistry.getTemplateRegistry（）。"
    },
    {
      "indent": 2,
      "text": "} catch( ServiceLocationException ex ) { } //Deal with error.",
      "ja": "}キャッチ（ServiceLocationExceptionのEX）{} //エラーに対処。"
    },
    {
      "indent": 2,
      "text": "if( adv == null ) {",
      "ja": "IF（ADV == NULL）{"
    },
    {
      "indent": 4,
      "text": "//Serious error as printer can't be registered // if the implementation doesn't support SA // functionality.",
      "ja": "実装がSA //機能をサポートしていない場合は、プリンタとして//重大なエラーが//登録することはできません。"
    },
    {
      "indent": 2,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 2,
      "text": "//Get the printer's attributes, from a file or // otherwise. We assume that the attributes // conform to the template, otherwise, we // could register the template here and verify // them.",
      "ja": "//そうでない場合は、ファイルまたは//から、プリンターの属性を取得します。私たちは、属性は、テンプレートに準拠//そうでない場合、私たちはここにテンプレートを登録することができ//と//それらを確認することを前提としています。"
    },
    {
      "indent": 2,
      "text": "Vector attributes = getPrinterAttributes();",
      "ja": "ベクトル）（=のgetPrinterAttributes属性。"
    },
    {
      "indent": 2,
      "text": "//Create the service: URL for the printer.",
      "ja": "//サービスを作成します。プリンタのURL。"
    },
    {
      "indent": 2,
      "text": "ServiceURL printerURL = new ServiceURL( \"service:printer:lpr://printshop/color2\", ServiceURL.LIFETIME_MAXIMUM);",
      "ja": "serviceURLのprinterURL =新しいのserviceURL（ \"サービス：プリンタ：LPR：//印刷所/カラー2\"、ServiceURL.LIFETIME_MAXIMUM）。"
    },
    {
      "indent": 2,
      "text": "try {",
      "ja": "{試します"
    },
    {
      "indent": 4,
      "text": "//Register the printer.",
      "ja": "//プリンタを登録します。"
    },
    {
      "indent": 4,
      "text": "adv.register(printerURL, attributes);",
      "ja": "adv.register（printerURL、属性）;"
    },
    {
      "indent": 4,
      "text": "//If the template registry is available, // register the printer's template.",
      "ja": "テンプレートレジストリが利用可能な場合は//、//プリンタのテンプレートを登録します。"
    },
    {
      "indent": 4,
      "text": "if( tr != null ) { tr.registerServiceTemplate( new ServiceType(\"service:printer:lpr\"), \"http://shop.arv/printer/printer-lpr.slp\", new Locale(\"en\",\"\"), \"1.0\");",
      "ja": "（もし！TR = NULL）{tr.registerServiceTemplate（新サービス種別（ \"サービス：プリンタ：LPR\"）、 \"HTTP：//shop.arv/printer/printer-lpr.slp\"、新しいロケール（ \"EN\"、」 「）、 \"1.0\"）;"
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 2,
      "text": "} catch( ServiceLocationException ex ) { } //Deal with error.",
      "ja": "}キャッチ（ServiceLocationExceptionのEX）{} //エラーに対処。"
    },
    {
      "indent": 3,
      "text": "Suppose a client is looking for color printer. The following code is used to issue a request for printer advertisements:",
      "ja": "クライアントは、カラープリンタを探していると仮定します。次のコードは、プリンタの広告のための要求を発行するために使用されます。"
    },
    {
      "indent": 2,
      "text": "Locator loc = null;\nTemplateRegistry tr = null;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "try {",
      "ja": "{試します"
    },
    {
      "indent": 4,
      "text": "loc = ServiceLocationManager.getLocator(\"en\");",
      "ja": "代わり= ServiceLocationManager.getLocator（ \"EN\"）。"
    },
    {
      "indent": 2,
      "text": "} catch( ServiceLocationException ex ) { } //Deal with error.",
      "ja": "}キャッチ（ServiceLocationExceptionのEX）{} //エラーに対処。"
    },
    {
      "indent": 2,
      "text": "if( loc == null ) {",
      "ja": "IF（LOC == NULL）{"
    },
    {
      "indent": 4,
      "text": "//Serious error as client can't be located // if the implementation doesn't support // UA functionality.",
      "ja": "実装は// UAの機能をサポートしていない場合は、クライアントとして//重大なエラーが//に配置することができません。"
    },
    {
      "indent": 2,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 2,
      "text": "//We want a color printer that does CMYK // and prints at least 600 dpi.",
      "ja": "//私たちは、CMYK //と版画少なくとも600 dpiの処理を行い、カラープリンタをしたいです。"
    },
    {
      "indent": 2,
      "text": "String query = \"(&(marker-type=CMYK)(resolution=600))\";",
      "ja": "ストリングクエリ= \"（＆（マーカー型= CMYK）（分解能= 600））\"。"
    },
    {
      "indent": 2,
      "text": "//Get scopes.",
      "ja": "//スコープを取得します。"
    },
    {
      "indent": 2,
      "text": "Vector scopes = ServiceLocationManager.findScopes();",
      "ja": "ベクトルスコープ=サービスLocationManager.findスコープ（）。"
    },
    {
      "indent": 2,
      "text": "Enumeration services;",
      "ja": "列挙型サービス。"
    },
    {
      "indent": 2,
      "text": "try {",
      "ja": "{試します"
    },
    {
      "indent": 4,
      "text": "services = loc.findServices(new ServiceType(\"service:printer\"),scopes,query);",
      "ja": "サービス=のloc.findServices（新サービス種別（ \"サービス：プリンタ\"）、スコープ、クエリ）;"
    },
    {
      "indent": 2,
      "text": "} catch { } //Deal with error.",
      "ja": "}キャッチ{} //エラーに対処します。"
    },
    {
      "indent": 2,
      "text": "if (services.hasMoreElements() ) {",
      "ja": "IF（services.hasMoreElements（））{"
    },
    {
      "indent": 4,
      "text": "//Printers can now be used. ServiceURL surl = (ServiceURL) services.next();",
      "ja": "//プリンタが使用できるようになりました。 serviceURL SURL =（のserviceURL）services.next（）;"
    },
    {
      "indent": 4,
      "text": "Socket sock = new Socket(surl.getHost, surl.getPort());",
      "ja": "ソケット靴下=新しいソケット（surl.getHost、surl.getPort（））;"
    },
    {
      "indent": 4,
      "text": "// Use the Socket...",
      "ja": "//ソケットを使用して..."
    },
    {
      "indent": 2,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 0,
      "text": "6. Internationalization Considerations",
      "section_title": true,
      "ja": "6.国際化に関する注意事項"
    },
    {
      "indent": 0,
      "text": "6.1. service URL",
      "section_title": true,
      "ja": "6.1。サービスURL"
    },
    {
      "indent": 3,
      "text": "The service URL itself must be encoded using the rules set forth in [2]. The character set encoding is limited to specific ranges within the UTF-8 character set [3].",
      "ja": "サービスURL自体は、[2]に記載された規則を使用して符号化されなければなりません。文字セットエンコーディングは、UTF-8文字セット内の特定の範囲に制限されている[3]。"
    },
    {
      "indent": 3,
      "text": "The attribute information associated with the service URL must be expressed in UTF-8. See [8] for attribute internationalization guidelines.",
      "ja": "サービスのURLに関連付けられた属性情報がUTF-8で表現しなければなりません。属性の国際ガイドラインのための[8]を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.2. Character Set Encoding",
      "section_title": true,
      "ja": "6.2。文字セットエンコーディング"
    },
    {
      "indent": 3,
      "text": "Configuration and serialized registration files are encoded in the UTF-8 character set [3]. This is fully compatible with US-ASCII character values. C platforms that do not support UTF-8 are required to check the top bit of input bytes to determine whether the incoming character is multibyte. If it is, the character should be dealt with accordingly. This should require no additional implementation effort, since the SLP wire protocol requires that strings are encoded as UTF-8. C platforms without UTF-8 support need to supply their own support, if only in the form of multibyte string handling.",
      "ja": "設定およびシリアル化された登録ファイルは、UTF-8文字セットでエンコードされている[3]。これはUS-ASCII文字値と完全に互換性があります。 UTF-8をサポートしていないCプラットフォームは、入力のトップビットが入ってくるの文字がマルチバイトであるかどうかを判断するためにバイトをチェックする必要があります。もしそうであれば、文字はそれに応じて対処する必要があります。 SLPワイヤプロトコルは、文字列はUTF-8としてエンコードされている必要がありますので、これは、追加の実装の労力を必要としないはずです。唯一のマルチバイト文字列操作の形であればUTF-8のサポートなしでCプラットフォームは、自分自身のサポートを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "At the API level, the character encoding is specified to be Unicode for Java and UTF-8 for C. Unicode is the default in Java. For C, the standard US-ASCII 8 bits per character, null terminated C strings are a subset of the UTF-8 character set, and so work in the API. Because the C API is very simple, the API library needs to do a minimum of processing on UTF-8 strings. The strings primarily just need to be reflected into the outgoing SLP messages, and reflected out of the",
      "ja": "APIレベルでは、文字エンコーディングはC. UnicodeのためのJavaのUnicodeとUTF-8に指定されたJavaのデフォルトです。 C、標準のUS-ASCII文字あたり8ビットの場合、ヌルはC文字列がUTF-8文字セットのサブセットであるので、APIで作業終了しました。 C APIは非常にシンプルであるため、APIライブラリは、UTF-8文字列の処理の最小を行う必要があります。文字列は、主にだけ、発信SLPメッセージに反映する必要がある、との外に反射しました"
    },
    {
      "indent": 3,
      "text": "API from incoming SLP messages.",
      "ja": "入ってくるSLPメッセージからAPI。"
    },
    {
      "indent": 0,
      "text": "6.3. Language Tagging",
      "section_title": true,
      "ja": "6.3。言語タグ付け"
    },
    {
      "indent": 3,
      "text": "All SLP requests and registrations are tagged to indicate in which language the strings included are encoded. This allows multiple languages to be supported. It also presents the possibility that error conditions result when a request is made in a language that is not supported. In this case, an error is only returned when there is data available, but not obtainable in the language requested.",
      "ja": "すべてのSLPの要求と登録が含まれた文字列がエンコードされている言語で示すためにタグ付けされています。これは、複数の言語をサポートすることができます。また、要求がサポートされていない言語で行われたときのエラー状態が発生する可能性を提示します。利用可能なデータがある場合にはこの場合、エラーのみが返されますが、要求された言語では得られません。"
    },
    {
      "indent": 3,
      "text": "The dialect portion of the Language Tag is used on 'best effort' basis for matching strings by SLP. Dialects that match are preferred over those which don't. Dialects that do not match will not prevent string matching or comparisons from occurring.",
      "ja": "言語タグの方言部分は、SLPによって、文字列を一致させるための「ベストエフォート」に基づき使用されています。一致方言はないものよりも好ましいです。一致していない方言が発生してから、文字列マッチングや比較を防ぐことはできません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Security is handled within the API library and is not exposed to API clients except in the form of exceptions. The net.slp.securityEnabled, property determines whether an SA client's messages are signed, but a UA client should be prepared for an authentication exception at any time, because it may contact a DA with authenticated advertisements.",
      "ja": "セキュリティは、APIライブラリ内で処理されると、例外の形を除いてAPIクライアントに公開されていません。 net.slp.securityEnabledは、プロパティには、SAクライアントのメッセージが署名されているかどうかを判断し、それが認証済み広告でDAに連絡する可能性があるため、UAクライアントは、任意の時点で認証例外のために準備されるべきです。"
    },
    {
      "indent": 3,
      "text": "An adversary could delete valid service advertisements, provide false service information and deny UAs knowledge of existing services unless the mechanisms in SLP for authenticating SLP messages are used. These mechanisms allow DAAdverts, SAAdverts, Service URLs and Service Attributes to be verified using digital cryptography. For this reason, all SLP agents should be configured to use SLP SPIs. See [7] for a description of how this mechanism works.",
      "ja": "敵は、有効なサービスの広告を削除する偽のサービス情報を提供し、SLPメッセージを認証するためのSLPでのメカニズムが使用されていない限り、既存のサービスのUAの知識を否定することができます。これらのメカニズムはDAAdverts、SAAdverts、サービスのURLを許可し、サービスは、デジタル暗号化を使用して検証する属性。このため、すべてのSLPエージェントは、SLP SPIを使用するように設定する必要があります。このメカニズムがどのように動作するかの説明については、[7]を参照してください。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgements",
      "section_title": true,
      "ja": "8.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Don Provan for his pioneering work during the initial stages of API definition.",
      "ja": "著者は、APIの定義の初期段階の間に彼の先駆的な仕事のためにドンProvanに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 4,
      "text": "[1] Bradner, S., \"Key Words for Use in RFCs to Indicate\n    Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "raw": true
    },
    {
      "indent": 4,
      "text": "[2] Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform Resource Identifiers (URI): Generic Syntax\", RFC 2396, August 1998.",
      "ja": "[2]バーナーズ=リー、T.、フィールディング、R.、およびL. Masinter、 \"統一資源識別子（URI）：一般的な構文\"、RFC 2396、1998年8月。"
    },
    {
      "indent": 4,
      "text": "[3] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", RFC 2279, January 1998.",
      "ja": "[3] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、RFC 2279、1998年1月。"
    },
    {
      "indent": 4,
      "text": "[4] Howes, T., \"The String Representation of LDAP Search Filters\", RFC 2254 December 1997.",
      "ja": "[4]ハウズ、T.、 \"LDAP検索フィルタの文字列表現\"、RFC 2254 1997年12月。"
    },
    {
      "indent": 4,
      "text": "[5] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", RFC 2234, November 1997.",
      "ja": "[5]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、RFC 2234、1997年11月。"
    },
    {
      "indent": 4,
      "text": "[6] Alvestrand, H., \"Tags for the Identification of Languages\", RFC 1766, March 1995.",
      "ja": "[6] Alvestrand、H.、 \"言語識別のためのタグ\"、RFC 1766、1995年3月。"
    },
    {
      "indent": 4,
      "text": "[7] Guttman, E., Perkins, C., Veizades, J. and M. Day, \"Service Location Protocol, Version 2\", RFC 2608, June 1999.",
      "ja": "[7]ガットマン、E.、パーキンス、C.、Veizades、J.とM.日、 \"サービスロケーションプロトコル、バージョン2\"、RFC 2608、1999年6月。"
    },
    {
      "indent": 4,
      "text": "[8] Guttman, E., Perkins, C. and J. Kempf, \"Service Templates and Service: Schemes\", RFC 2609, June 1999.",
      "ja": "[8]ガットマン、E.、パーキンス、C.及びJ.ケンプ、 \"サービステンプレートとサービス：スキーム\"、RFC 2609、1999年6月。"
    },
    {
      "indent": 0,
      "text": "10. Authors' Addresses",
      "section_title": true,
      "ja": "10.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Questions about this memo can be directed to:",
      "ja": "このメモに関する質問に向けることができます。"
    },
    {
      "indent": 3,
      "text": "James Kempf Sun Microsystems 901 San Antonio Rd. Palo Alto, CA, 94303 USA",
      "ja": "ジェームズ・ケンプSun Microsystemsの901サンアントニオRdを。パロアルト、CA、94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 786 5890 Fax: +1 650 786 6445 EMail: james.kempf@sun.com",
      "ja": "電話：+1 650 786 5890ファックス：+1 650 786 6445 Eメール：james.kempf@sun.com"
    },
    {
      "indent": 3,
      "text": "Erik Guttman Sun Microsystems Bahnstr. 2 74915 Waibstadt Germany",
      "ja": "エリック・グットマンSun MicrosystemsのBahnstr。 2 74915ヴァイプシュタットドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49 7263 911 701 EMail: erik.guttman@sun.com",
      "ja": "電話：+49 7263 911 701 Eメール：erik.guttman@sun.com"
    },
    {
      "indent": 0,
      "text": "11. Full Copyright Statement",
      "section_title": true,
      "ja": "11.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1999）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\"",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています権利または特定の目的に対する商品性または適合性の黙示の保証を侵害し。」"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}