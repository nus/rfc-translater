{
  "title": {
    "text": "RFC 2435 - RTP Payload Format for JPEG-compressed Video",
    "ja": "RFC 2435 - JPEG圧縮されたビデオのためのRTPペイロードフォーマット"
  },
  "number": 2435,
  "created_at": "2019-10-24 14:20:16.669390+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                            L. Berc\nRequest for Comments: 2435                 Digital Equipment Corporation\nObsoletes: 2035                                                W. Fenner\nCategory: Standards Track                                     Xerox PARC\n                                                            R. Frederick\n                                                              Xerox PARC\n                                                              S. McCanne\n                                            Lawrence Berkeley Laboratory\n                                                              P. Stewart\n                                                              Xerox PARC\n                                                            October 1998",
      "raw": true
    },
    {
      "indent": 14,
      "text": "RTP Payload Format for JPEG-compressed Video",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo describes the RTP payload format for JPEG video streams. The packet format is optimized for real-time video streams where codec parameters change rarely from frame to frame.",
      "ja": "このメモはJPEGビデオストリームのためのRTPペイロード形式について説明します。パケットフォーマットは、コーデックのパラメータはフレームごとにほとんど変更されないリアルタイムビデオストリーム用に最適化されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Audio-Video Transport working group within the Internet Engineering Task Force. Comments are solicited and should be addressed to the working group's mailing list at rem-conf@es.net and/or the author(s).",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース内のオーディオビデオ輸送ワーキンググループの製品です。コメントが募集され、rem-conf@es.netおよび/または作者でワーキンググループのメーリングリストに対処する必要があります。"
    },
    {
      "indent": 0,
      "text": "Changes from RFC 2035",
      "ja": "RFC 2035からの変更点"
    },
    {
      "indent": 3,
      "text": "Most of this memo is identical to RFC 2035. The changes made to the protocol are summarized in Appendix D.",
      "ja": "このメモのほとんどは、付録Dに要約されているプロトコルに加えられた変更RFC 2035と同じです"
    },
    {
      "indent": 0,
      "text": "Key Words",
      "ja": "キーワード"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [9].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119に記載されるように解釈される[9]。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Joint Photographic Experts Group (JPEG) standard [1,2,3] defines a family of compression algorithms for continuous-tone, still images. This still image compression standard can be applied to video by compressing each frame of video as an independent still image and transmitting them in series. Video coded in this fashion is often called Motion-JPEG.",
      "ja": "ジョイントフォトグラフィックエキスパートグループ（JPEG）規格[1,2,3]連続階調、静止画像の圧縮アルゴリズムのファミリーを定義します。この静止画像圧縮標準は、独立した静止画像として、ビデオの各フレームを圧縮し、直列にそれらを送信することによって、ビデオにも適用することができます。この方法で符号化された映像は、多くの場合、モーションJPEGと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "We first give an overview of JPEG and then describe the specific subset of JPEG that is supported in RTP and the mechanism by which JPEG frames are carried as RTP payloads.",
      "ja": "まずJPEGの概観を与え、その後、RTPとJPEGフレームはRTPペイロードとして搬送される機構に支持されているJPEGの特定のサブセットを記述する。"
    },
    {
      "indent": 3,
      "text": "The JPEG standard defines four modes of operation: the sequential DCT mode, the progressive DCT mode, the lossless mode, and the hierarchical mode. Depending on the mode, the image is represented in one or more passes. Each pass (called a frame in the JPEG standard) is further broken down into one or more scans. Within each scan, there are one to four components, which represent the three components of a color signal (e.g., \"red, green, and blue\", or a luminance signal and two chrominance signals). These components can be encoded as separate scans or interleaved into a single scan.",
      "ja": "シーケンシャルDCTモード、プログレッシブDCTモード、可逆モード、及び階層モード：JPEG規格は、4つの動作モードを定義します。モードに応じて、画像は、一つ以上のパスで表されています。 （JPEG規格におけるフレームと呼ばれる）、各パスは、1回の以上のスキャンに分解されます。各スキャン内で、色信号（例えば、「赤、緑、及び青」、または輝度信号と2つのクロミナンス信号）の3つの成分を表し、1〜4個のコンポーネントが存在します。これらのコンポーネントは、別々のスキャンとして符号化又は単一のスキャンにインターリーブすることができます。"
    },
    {
      "indent": 3,
      "text": "Each frame and scan is preceded with a header containing optional definitions for compression parameters like quantization tables and Huffman coding tables. The headers and optional parameters are identified with \"markers\" and comprise a marker segment; each scan appears as an entropy-coded bit stream within two marker segments. Markers are aligned to byte boundaries and (in general) cannot appear in the entropy-coded segment, allowing scan boundaries to be determined without parsing the bit stream.",
      "ja": "各フレームとスキャンは、量子化テーブル及びハフマン符号化テーブルのような圧縮パラメータのための任意の定義を含むヘッダが先行します。ヘッダーとオプションのパラメータは、「マーカー」と識別され、マーカセグメントを含むされます。各スキャンは、2つのマーカ・セグメント内のエントロピー符号化ビットストリームとして現れます。マーカーバイト境界に整列され、（一般に）され、スキャン境界がビットストリームを解析することなく決定することができるように、エントロピー符号化されたセグメントに現れることはできません。"
    },
    {
      "indent": 3,
      "text": "Compressed data is represented in one of three formats: the interchange format, the abbreviated format, or the table-specification format. The interchange format contains definitions for all the tables used by the entropy-coded segments, while the abbreviated format might omit some assuming they were defined out-of-band or by a \"previous\" image.",
      "ja": "交換フォーマット、略称フォーマット、またはテーブル指定形式：圧縮されたデータは、3つの形式のいずれかで表されています。略記フォーマットは、それらがの帯域外または「前」画像によって定義されたと仮定すると、いくつかを省略するかもしれないが交換フォーマットは、エントロピー符号化されたセグメントで使用されるすべてのテーブルの定義を含みます。"
    },
    {
      "indent": 3,
      "text": "The JPEG standard does not define the meaning or format of the components that comprise the image. Attributes like the color space and pixel aspect ratio must be specified out-of-band with respect to the JPEG bit stream. The JPEG File Interchange Format (JFIF) [4] is a de-facto standard that provides this extra information using an application marker segment (APP0). Note that a JFIF file is simply a JPEG interchange format image along with the APP0 segment. In the case of video, additional parameters must be defined out-of-band (e.g., frame rate, interlaced vs. non-interlaced, etc.).",
      "ja": "JPEG規格は、画像を構成するコンポーネントの意味又はフォーマットを定義していません。色空間及び画素アスペクト比などの属性は、JPEGビットストリームに対して帯域外に指定されなければなりません。 JPEGファイル交換フォーマット（JFIF）[4]アプリケーションマーカセグメント（APP0）を使用して、この追加情報を提供するデファクトスタンダードです。 JFIFファイルは単にAPP0セグメントと共にJPEG交換用フォーマットの画像であることに留意されたいです。ビデオの場合には、追加のパラメータを定義する必要があり、アウトオブバンド（例えば、フレームレートなど、対ノンインターレースインターレース）。"
    },
    {
      "indent": 3,
      "text": "While the JPEG standard provides a rich set of algorithms for flexible compression, cost-effective hardware implementations of the full standard have not appeared. Instead, most hardware JPEG video codecs implement only a subset of the sequential DCT mode of operation. Typically, marker segments are interpreted in software (which \"re-programs\" the hardware) and the hardware is presented with a single, interleaved entropy-coded scan represented in the YUV color space.",
      "ja": "JPEG規格は柔軟な圧縮のためのアルゴリズムの豊富なセットを提供していますが、完全な標準の費用対効果の高いハードウェア実装が登場していません。代わりに、ほとんどのハードウェアJPEGビデオコーデックは、操作のシーケンシャルDCTモードのサブセットのみを実装しています。典型的には、マーカセグメントは、ソフトウェアで解釈され（これは「再プログラム」ハードウェア）およびハードウェアは、YUV色空間で表される単一のインターリーブエントロピー符号化されたスキャンが提示されます。"
    },
    {
      "indent": 3,
      "text": "The scan contains an ordered sequence of Minimum Coded Units, or MCUs, which are the smallest group of image data coded in a JPEG bit stream. Each MCU defines the image data for a small rectangular block of the output image.",
      "ja": "スキャンは、JPEGビットストリームで符号化された画像データの最も小さいグループである最小コード化単位、又はマイコンの順序付けられた配列を含みます。各MCUは、出力画像の小さな矩形ブロックの画像データを定義します。"
    },
    {
      "indent": 3,
      "text": "Restart markers in the JPEG data denote a point where the decoder should reset its state. As defined by JPEG, restart markers are the only type of marker that may appear embedded in the entropy-coded segment, and they may only appear on an MCU boundary. A \"restart interval\" is defined to be a block of data containing a restart marker followed by some fixed number of MCUs. An exception is made for the first restart interval in each frame, which omits the initial restart marker and just begins with the MCU data. When these markers are used, each frame is composed of some fixed number of back-to-back restart intervals.",
      "ja": "JPEGデータにリスタートマーカーは、デコーダがその状態をリセットしなければならない点を表します。 JPEGによって定義されるように、マーカーを再起動してエントロピー符号化されたセグメント中に埋め込まれ表示されることマーカーの唯一のタイプであり、それらは、MCUの境界に表示されてもよいです。 「再起動間隔は、」マイコンのいくつかの固定された数字が続くリスタートマーカを含むデータのブロックであると定義されます。例外は、最初のリスタートマーカを省略し、単にMCUデータで始まり、各フレームの最初の再起動間隔、のために作られています。これらのマーカーが使用される場合、各フレームは、バックツーバック再起動間隔のいくつかの固定された数で構成されています。"
    },
    {
      "indent": 0,
      "text": "2. JPEG Over RTP",
      "section_title": true,
      "ja": "2. JPEGオーバーRTP"
    },
    {
      "indent": 3,
      "text": "To maximize interoperability among hardware-based codecs, we assume the sequential DCT operating mode [1,Annex F] and restrict the set of predefined RTP/JPEG \"type codes\" (defined below) to single-scan, interleaved images. While this is more restrictive than even baseline JPEG, many hardware implementation fall short of the baseline specification (e.g., most hardware cannot decode non-interleaved scans).",
      "ja": "ハードウェアベースのコーデック間の相互運用性を最大にするために、我々は、順次DCT動作モード[1、付属書F]を仮定し、事前定義されたRTP / JPEG（以下に定義）「種別コード」は、単一のスキャンに、インターリーブされた画像のセットを制限します。これは、ベースライン仕様の短いもベースラインJPEG、多くのハードウェア実装の落下（例えば、ほとんどのハードウェアは、非インターリーブスキャンを復号することができない）よりも制限されています。"
    },
    {
      "indent": 3,
      "text": "In practice, most of the table-specification data rarely changes from frame to frame within a single video stream. Therefore RTP/JPEG data is represented in abbreviated format, with all of the tables omitted from the bit stream where possible. Each frame begins immediately with the (single) entropy-coded scan. The information that would otherwise be in both the frame and scan headers is represented entirely within the RTP/JPEG header (defined below) that lies between the RTP header and the JPEG payload.",
      "ja": "実際には、表指定データのほとんどはめったに単一のビデオストリーム内のフレームごとに変化しません。したがって、RTP / JPEGデータをビットストリームから省略可能テーブルの全てで、省略形で表されています。各フレームは（単一）エントロピー符号化されたスキャンと直ちに始まります。そうでなければ、フレームとスキャンヘッダーの両方であろう情報は完全RTPヘッダ及びJPEGペイロードの間にある（以下に定義）RTP / JPEGヘッダ内に表されています。"
    },
    {
      "indent": 3,
      "text": "While parameters like Huffman tables and color space are likely to remain fixed for the lifetime of the video stream, other parameters should be allowed to vary, notably the quantization tables and image size (e.g., to implement rate-adaptive transmission or allow a user to adjust the \"quality level\" or resolution manually). Thus explicit fields in the RTP/JPEG header are allocated to represent this information. Since only a small set of quantization tables are typically used, we encode the entire set of quantization tables in a small integer field. Customized quantization tables are accommodated by using a special range of values in this field, and then placing the table before the beginning of the JPEG payload. The image width and height are encoded explicitly.",
      "ja": "ハフマンテーブル色空間のようなパラメータは、ビデオストリームの存続期間中固定されたまま可能性があるが、他のパラメータは、特に量子化テーブルと画像サイズ（例えば、レート適応送信を実装するかをユーザに可能にするために、変化させなければなりません「品質レベル」、または手動解像度）を調整します。したがってRTP / JPEGヘッダ内の明示的なフィールドは、この情報を表すために割り当てられます。量子化テーブルのほんのセットが典型的に使用されているので、我々は小さな整数フィールドの量子化テーブルのセット全体をコードします。カスタマイズされた量子化テーブルは、このフィールドに値の特別な範囲を使用して、JPEGペイロードの開始前にテーブルを配置することにより、収容されています。画像の幅と高さを明示的にコードされています。"
    },
    {
      "indent": 3,
      "text": "Because JPEG frames are typically larger than the underlying network's maximum packet size, frames must often be fragmented into several packets. One approach is to allow the network layer below RTP (e.g., IP) to perform the fragmentation. However, this precludes rate-controlling the resulting packet stream or partial delivery in the presence of loss, and frames may be larger than the maximum network layer reassembly length (see [10] for more information). To avoid these limitations, RTP/JPEG defines a simple fragmentation and reassembly scheme at the RTP level.",
      "ja": "JPEGフレームは通常、基礎となるネットワークの最大パケットサイズよりも大きいので、フレームは、多くの場合、いくつかのパケットに分割する必要があります。一つのアプローチは、RTP（例えば、IP）下のネットワーク層は、断片化を実行できるようにすることです。しかしながら、これは、結果として得られるパケットストリームまたは損失の存在下で部分的送達を速度制御排除、及びフレーム（詳細については[10]を参照）最大ネットワーク層再構成長さよりも大きくてもよいです。これらの制限を回避するために、RTP / JPEGはRTPレベルでの簡単な断片化と再構築スキームを定義します。"
    },
    {
      "indent": 0,
      "text": "3. RTP/JPEG Packet Format",
      "section_title": true,
      "ja": "3. RTP / JPEGパケットフォーマット"
    },
    {
      "indent": 3,
      "text": "The RTP timestamp is in units of 90000Hz. The same timestamp MUST appear in each fragment of a given frame. The RTP marker bit MUST be set in the last packet of a frame.",
      "ja": "RTPタイムスタンプは、90000Hzの単位です。同じタイムスタンプは、所与のフレームの各断片に現れなければなりません。 RTPマーカービットは、フレームの最後のパケットに設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.1. JPEG header",
      "section_title": true,
      "ja": "3.1.  JPEGヘッダ"
    },
    {
      "indent": 3,
      "text": "Each packet contains a special JPEG header which immediately follows the RTP header. The first 8 bytes of this header, called the \"main JPEG header\", are as follows:",
      "ja": "各パケットはすぐにRTPヘッダを以下の特別なJPEGヘッダが含まれています。次のように「メインJPEGヘッダ」と呼ばれるこのヘッダの最初の8つのバイトは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Type-specific |              Fragment Offset                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Type     |       Q       |     Width     |     Height    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All fields in this header except for the Fragment Offset field MUST remain the same in all packets that correspond to the same JPEG frame.",
      "ja": "フラグメントオフセットフィールドを除いて、このヘッダのすべてのフィールドは、同じJPEGフレームに対応するすべてのパケットに同じままでなければなりません。"
    },
    {
      "indent": 3,
      "text": "A Restart Marker header and/or Quantization Table header may follow this header, depending on the values of the Type and Q fields.",
      "ja": "再起動マーカーヘッダ及び/又は量子化テーブルヘッダは、タイプおよびQフィールドの値に応じて、このヘッダーに従うことができます。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Type-specific: 8 bits",
      "section_title": true,
      "ja": "3.1.1. 型特異：8ビット"
    },
    {
      "indent": 3,
      "text": "Interpretation depends on the value of the type field. If no interpretation is specified, this field MUST be zeroed on transmission and ignored on reception.",
      "ja": "解釈はタイプフィールドの値に依存します。何の解釈が指定されていない場合、このフィールドは、送信時にゼロとレセプションで無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Fragment Offset: 24 bits",
      "section_title": true,
      "ja": "3.1.2. フラグメントオフセット：24ビット"
    },
    {
      "indent": 3,
      "text": "The Fragment Offset is the offset in bytes of the current packet in the JPEG frame data. This value is encoded in network byte order (most significant byte first). The Fragment Offset plus the length of the payload data in the packet MUST NOT exceed 2^24 bytes.",
      "ja": "オフセット断片はJPEGフレームデータ内の現在のパケットのバイトにオフセットされています。この値は、ネットワークバイトオーダー（最上位バイトが最初）でエンコードされます。フラグメントオフセットプラスパケットにおけるペイロードデータの長さは2 ^ 24バイトを超えてはなりません。"
    },
    {
      "indent": 0,
      "text": "3.1.3. Type: 8 bits",
      "section_title": true,
      "ja": "3.1.3. タイプ：8ビット"
    },
    {
      "indent": 3,
      "text": "The type field specifies the information that would otherwise be present in a JPEG abbreviated table-specification as well as the additional JFIF-style parameters not defined by JPEG. Types 0-63 are reserved as fixed, well-known mappings to be defined by this document and future revisions of this document. Types 64-127 are the same as types 0-63, except that restart markers are present in the JPEG data and a Restart Marker header appears immediately following the main JPEG header. Types 128-255 are free to be dynamically defined by a session setup protocol (which is beyond the scope of this document).",
      "ja": "タイプフィールドは、そうでなければJPEG略記表仕様ならびにJPEGで定義されていない追加のJFIFスタイルパラメータで存在するであろう情報を指定します。タイプは0-63は、このドキュメントと、このドキュメントの今後の改正によって定義される固定は、周知のマッピングとして予約されています。そのリスタートマーカは、JPEGデータの中に存在し、再起動マーカヘッダーがすぐにメインのJPEGヘッダ次のように表示さ除きタイプ64-127は、タイプ0-63と同じです。タイプ128-255は、動的に（このドキュメントの範囲を超えている）セッションセットアッププロトコルによって定義されることは自由です。"
    },
    {
      "indent": 0,
      "text": "3.1.4. Q: 8 bits",
      "section_title": true,
      "ja": "3.1.4.  Q：8ビット"
    },
    {
      "indent": 3,
      "text": "The Q field defines the quantization tables for this frame. Q values 0-127 indicate the quantization tables are computed using an algorithm determined by the Type field (see below). Q values 128-255 indicate that a Quantization Table header appears after the main JPEG header (and the Restart Marker header, if present) in the first packet of the frame (fragment offset 0). This header can be used to explicitly specify the quantization tables in-band.",
      "ja": "Qフィールドは、このフレームの量子化テーブルを定義します。 Q値0〜127は、量子化テーブルが（下記参照）Typeフィールドによって決定されるアルゴリズムを使用して計算される示します。 Qは、（存在する場合、再起動マーカーヘッダ）128-255は、（フラグメントがオフセット0）フレームの最初のパケットで量子化テーブルヘッダは、メインJPEGヘッダの後に表示されていることを示す値。このヘッダは、明示的に帯域内の量子化テーブルを指定するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.1.5. Width: 8 bits",
      "section_title": true,
      "ja": "3.1.5. 幅：8ビット"
    },
    {
      "indent": 3,
      "text": "This field encodes the width of the image in 8-pixel multiples (e.g., a width of 40 denotes an image 320 pixels wide). The maximum width is 2040 pixels.",
      "ja": "このフィールドは、（例えば、40の幅が320個のピクセル幅の画像を表す）は、8画素の倍数で画像の幅を符号化します。最大幅2040ピクセルです。"
    },
    {
      "indent": 0,
      "text": "3.1.6. Height: 8 bits",
      "section_title": true,
      "ja": "3.1.6. 身長：8ビット"
    },
    {
      "indent": 3,
      "text": "This field encodes the height of the image in 8-pixel multiples (e.g., a height of 30 denotes an image 240 pixels tall). When encoding interlaced video, this is the height of a video field, since fields are individually JPEG encoded. The maximum height is 2040 pixels.",
      "ja": "このフィールドは、（例えば、30の高さが240個のピクセル背の高い画像を表す）は、8画素の倍数で画像の高さを符号化します。インターレースビデオをエンコードするときにフィールドが個別にJPEG符号化されるので、これは、ビデオフィールドの高さです。最大高さが2040ピクセルです。"
    },
    {
      "indent": 0,
      "text": "3.1.7. Restart Marker header",
      "section_title": true,
      "ja": "3.1.7. リスタートマーカヘッダ"
    },
    {
      "indent": 3,
      "text": "This header MUST be present immediately after the main JPEG header when using types 64-127. It provides the additional information required to properly decode a data stream containing restart markers.",
      "ja": "タイプ64-127を使用する場合、このヘッダは、直ちにメインJPEGヘッダの後に存在していなければなりません。これは、適切にリスタートマーカを含むデータストリームをデコードするのに必要な追加情報を提供します。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Restart Interval        |F|L|       Restart Count       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Restart Interval field specifies the number of MCUs that appear between restart markers. It is identical to the 16 bit value that would appear in the DRI marker segment of a JFIF header. This value MUST NOT be zero.",
      "ja": "再起動間隔]フィールドには、リスタートマーカの間に表示されたMCUの数を指定します。これは、JFIFヘッダーのDRIマーカセグメントに表示される16ビットの値と同じです。この値がゼロであってはなりません。"
    },
    {
      "indent": 3,
      "text": "If the restart intervals in a frame are not guaranteed to be aligned with packet boundaries, the F (first) and L (last) bits MUST be set to 1 and the Restart Count MUST be set to 0x3FFF. This indicates that a receiver MUST reassemble the entire frame before decoding it.",
      "ja": "フレーム内の再起動間隔は、パケット境界に整列されることが保証されていない場合は、F（第一）及びL（最後の）ビットが1に設定しなければならなくて、再起動カウントが0x3FFFのに設定しなければなりません。これは、受信機がそれを復号する前にフレーム全体を再構築しなければならないことを示しています。"
    },
    {
      "indent": 3,
      "text": "To support partial frame decoding, the frame is broken into \"chunks\" each containing an integral number of restart intervals. The Restart Count field contains the position of the first restart interval in the current \"chunk\" so that receivers know which part of the frame this data corresponds to. A Restart Interval value SHOULD be chosen to allow a \"chunk\" to completely fit within a single packet. In this case, both the F and L bits of the packet are set to 1. However, if a chunk needs to be spread across multiple packets, the F bit will be set to 1 in the first packet of the chunk (and only that one) and the L bit will be set to 1 in the last packet of the chunk (and only that one).",
      "ja": "部分フレームの復号化をサポートするために、フレームは、各々が再起動間隔の整数を含む「チャンク」に分割されます。受信機は、このデータが対応するフレームのどの部分を知っているように、再起動カウントフィールドには、現在の「チャンク」の最初の再起動間隔の位置が含まれています。再起動間隔の値は、完全に単一パケット内に収まるように、「チャンク」を許可するように選択する必要があります。この場合、パケットの両方のFとLビットは、チャンクが複数のパケットに分散する必要がある場合には、Fビットがチャンクの最初のパケットで1にセット（のみということであろう1に設定されています1）及びLビットは、チャンクの最後のパケット（およびのみ1つ）で1にセットされます。"
    },
    {
      "indent": 0,
      "text": "3.1.8. Quantization Table header",
      "section_title": true,
      "ja": "3.1.8. 量子化テーブルヘッダ"
    },
    {
      "indent": 3,
      "text": "This header MUST be present after the main JPEG header (and after the Restart Marker header, if present) when using Q values 128-255. It provides a way to specify the quantization tables associated with this Q value in-band.",
      "ja": "このヘッダは、メインJPEGヘッダの後に存在していなければなりません（再起動マーカーヘッダの後、もし存在すれば）Qを使用する場合は、128-255値。これは、インバンドこのQ値に関連付けられた量子化テーブルを指定する方法を提供します。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      MBZ      |   Precision   |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Quantization Table Data                    |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Length field is set to the length in bytes of the quantization table data to follow. The Length field MAY be set to zero to indicate that no quantization table data is included in this frame. See section 4.2 for more information. If the Length field in a received packet is larger than the remaining number of bytes, the packet MUST be discarded.",
      "ja": "Lengthフィールドは、後続する量子化テーブルデータのバイト単位の長さに設定されています。 Lengthフィールドには、量子化テーブルデータは、このフレームに含まれていないことを示すためにゼロに設定されてもよいです。詳細については、セクション4.2を参照してください。受信したパケットの長さフィールドはバイトの残りの数よりも大きい場合、パケットは廃棄されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When table data is included, the number of tables present depends on the JPEG type field. For example, type 0 uses two tables (one for the luminance component and one shared by the chrominance components). Each table is an array of 64 values given in zig-zag order, identical to the format used in a JFIF DQT marker segment.",
      "ja": "テーブルデータが含まれている場合、本テーブルの数は、JPEGタイプフィールドに依存します。例えば、タイプ0は、二つのテーブル（輝度成分と色差成分により共有される1つに対して1つ）を使用します。各テーブルには、JFIF DQTマーカセグメントで使用されるフォーマットと同じジグザグの順序で与えられた64の値の配列です。"
    },
    {
      "indent": 3,
      "text": "For each quantization table present, a bit in the Precision field specifies the size of the coefficients in that table. If the bit is zero, the coefficients are 8 bits yielding a table length of 64 bytes. If the bit is one, the coefficients are 16 bits for a table length of 128 bytes. For 16 bit tables, the coefficients are presented in network byte order. The rightmost bit in the Precision field (bit 15 in the diagram above) corresponds to the first table and each additional table uses the next bit to the left. Bits beyond those corresponding to the tables needed by the type in use MUST be ignored.",
      "ja": "各量子化テーブルに存在するため、高精度フィールドのビットは、そのテーブル内の係数の大きさを指定します。ビットがゼロである場合、係数は64バイトのテーブル長さが得られる8ビットです。ビットが1である場合、係数は128バイトのテーブルの長さは16ビットです。 16ビットのテーブルでは、係数はネットワークバイト順に提示されます。精密フィールド（上図におけるビット15）の右端のビットは、最初のテーブルに対応し、各追加のテーブルは左に次のビットを使用します。使用中のタイプに必要な表に対応したもの以外のビットは無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For Q values from 128 to 254, the Q value to quantization table data mapping MUST be static, i.e., the receivers are guaranteed that they only need to read the table data once in order to correctly decode frames sent with that Q value. A Q value of 255 denotes that the quantization table mapping is dynamic and can change on every frame. Decoders MUST NOT depend on any previous version of the tables, and need to reload these tables on every frame. Packets MUST NOT contain Q = 255 and Length = 0.",
      "ja": "128から254のQ値、Q値の量子化テーブルデータへのマッピングは静的である必要がありため、すなわち、受信機は、それらが唯一正しくそのQ値と送信されたフレームを復号するために一度テーブルデータを読み出す必要があることが保証されます。 255のQ値は、量子化テーブルのマッピングは動的であり、フレーム毎に変更することができることを示します。デコーダは、テーブルの以前のバージョンに依存し、すべてのフレームでこれらのテーブルをリロードする必要がありますてはなりません。パケットは、Q = 255とLength = 0を含めることはできません。"
    },
    {
      "indent": 0,
      "text": "3.1.9. JPEG Payload",
      "section_title": true,
      "ja": "3.1.9.  JPEGペイロード"
    },
    {
      "indent": 3,
      "text": "The data following the RTP/JPEG headers is an entropy-coded segment consisting of a single scan. The scan header is not present and is inferred from the RTP/JPEG header. The scan is terminated either implicitly (i.e., the point at which the image is fully parsed), or explicitly with an EOI marker. The scan may be padded to arbitrary length with undefined bytes. (Some existing hardware codecs generate extra lines at the bottom of a video frame and removal of these lines would require a Huffman-decoding pass over the data.)",
      "ja": "RTP / JPEGヘッダー以下のデータは、単一のスキャンから成るエントロピー符号化セグメントです。スキャンヘッダは存在せず、RTP / JPEGヘッダから推測されます。スキャンは、暗黙的のいずれかで終了する（すなわち、画像が完全に解析された時点）、または明示的にEOIマーカーを有します。スキャンは未定義バイトで任意の長さにパディングすることができます。 （いくつかの既存のハードウェアコーデックは、ビデオフレームとデータオーバーハフマン復号パスを必要とするこれらのラインの除去の下部に余分な行を生成します。）"
    },
    {
      "indent": 3,
      "text": "The type code determines whether restart markers are present. If a type supports restart markers, the packet MUST contain a non-zero Restart Interval value in a Restart Marker Header and restart markers MUST appear on byte aligned boundaries beginning with an 0xFF between MCUs at that interval. Additional 0xFF bytes MAY appear between restart intervals. This can be used in the packetization process to align data to something like a word boundary for more efficient copying. Restart markers MUST NOT appear anywhere else in the JPEG payload. Types which do not support restart makers MUST NOT contain restart markers anywhere in the JPEG payload. All packets MUST contain a \"stuffed\" 0x00 byte following any true 0xFF byte generated by the entropy coder [1, Sec. B.1.1.5].",
      "ja": "タイプコードは、リスタートマーカーが存在するか否かを判定する。種類はリスタートマーカをサポートしている場合、パケットは再起動マーカーヘッダー内の非ゼロの再起動間隔の値を含み、マーカーはその間隔でのMCU間の0xFFで始まるバイト整列境界に現れなければならない再起動する必要があります。追加の0xFFのバイトは、再起動間隔の間で表示されることがあります。これは、より効率的なコピーのためのワード境界のようなものにデータを整列するためにパケット化プロセスで使用することができます。再起動マーカーはJPEGペイロードのどこにも現れてはなりません。再起動のメーカーをサポートしていないタイプはJPEGペイロード内の任意の場所にリスタートマーカを含めることはできません。すべてのパケットは、エントロピー符号化器[1、SECによって生成された、真の0xFFバイト以下の「詰め」は0x00のバイトを含まなければなりません。 B.1.1.5]。"
    },
    {
      "indent": 0,
      "text": "4. Discussion",
      "section_title": true,
      "ja": "4。討議"
    },
    {
      "indent": 0,
      "text": "4.1. The Type Field",
      "section_title": true,
      "ja": "4.1. タイプフィールド"
    },
    {
      "indent": 3,
      "text": "The Type field defines the abbreviated table-specification and additional JFIF-style parameters not defined by JPEG, since they are not present in the body of the transmitted JPEG data.",
      "ja": "それらは送信JPEGデータの本体には存在しないので、Typeフィールドは、JPEGで定義されていない略称テーブル仕様と追加JFIF形式のパラメータを定義します。"
    },
    {
      "indent": 3,
      "text": "Three ranges of the type field are currently defined. Types 0-63 are reserved as fixed, well-known mappings to be defined by this document and future revisions of this document. Types 64-127 are the same as types 0-63, except that restart markers are present in the JPEG data and a Restart Marker header appears immediately following the main JPEG header. Types 128-255 are free to be dynamically defined by a session setup protocol (which is beyond the scope of this document).",
      "ja": "タイプフィールドの3つの範囲は、現在定義されています。タイプは0-63は、このドキュメントと、このドキュメントの今後の改正によって定義される固定は、周知のマッピングとして予約されています。そのリスタートマーカは、JPEGデータの中に存在し、再起動マーカヘッダーがすぐにメインのJPEGヘッダ次のように表示さ除きタイプ64-127は、タイプ0-63と同じです。タイプ128-255は、動的に（このドキュメントの範囲を超えている）セッションセットアッププロトコルによって定義されることは自由です。"
    },
    {
      "indent": 3,
      "text": "Of the first group of fixed mappings, types 0 and 1 are currently defined, along with the corresponding types 64 and 65 that indicate the presence of restart markers. They correspond to an abbreviated table-specification indicating the \"Baseline DCT sequential\" mode, 8-bit samples, square pixels, three components in the YUV color space, standard Huffman tables as defined in [1, Annex K.3], and a single interleaved scan with a scan component selector indicating components 1, 2, and 3 in that order. The Y, U, and V color planes correspond to component numbers 1, 2, and 3, respectively. Component 1 (i.e., the luminance plane) uses Huffman table number 0 and quantization table number 0 (defined below) and components 2 and 3 (i.e., the chrominance planes) use Huffman table number 1 and quantization table number 1 (defined below).",
      "ja": "固定されたマッピングの第1グループの、タイプ0および1は、現在、リスタートマーカの存在を示す、対応するタイプ64及び65と共に、定義されます。彼らは、「ベースラインDCTシーケンシャル」モード、8ビットサンプル、正方形の画素、YUV色空間における3つの構成要素を示す略記テーブル仕様に対応し、で定義されるような標準的なハフマンテーブル[1、附属書K.3]、及び成分1、2、の順に3を示すスキャンコンポーネントセレクタを有する単一のインターリーブされたスキャン。 Y、U、及びVの色平面は、それぞれ成分番号1、2、および3に対応します。成分1（即ち、輝度面）ハフマンテーブル番号0及び（以下に定義）量子化テーブル番号0と部品2及び3（すなわち、クロミナンス面）を使用するハフマンテーブル番号1及び（以下に定義）量子化テーブル番号1を使用します。"
    },
    {
      "indent": 3,
      "text": "Type numbers 2-5 are reserved and SHOULD NOT be used. Applications based on previous versions of this document (RFC 2035) should be updated to indicate the presence of restart markers with type 64 or 65 and the Restart Marker header.",
      "ja": "タイプ番号2-5は、予約されているため、使用しないでください。この文書（RFC 2035）の以前のバージョンに基づいて、アプリケーションは、タイプ64または65と再起動マーカーヘッダでリスタートマーカーの存在を示すように更新されるべきです。"
    },
    {
      "indent": 3,
      "text": "The two RTP/JPEG types currently defined are described below:",
      "ja": "現在、定義された2つのRTP / JPEGの種類は以下のとおりです："
    },
    {
      "indent": 9,
      "text": "                   horizontal   vertical   Quantization\n  types  component samp. fact. samp. fact. table number\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       |  1 (Y)  |     2     |     1     |     0     |\n| 0, 64 |  2 (U)  |     1     |     1     |     1     |\n|       |  3 (V)  |     1     |     1     |     1     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       |  1 (Y)  |     2     |     2     |     0     |\n| 1, 65 |  2 (U)  |     1     |     1     |     1     |\n|       |  3 (V)  |     1     |     1     |     1     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "These sampling factors indicate that the chrominance components of type 0 video is downsampled horizontally by 2 (often called 4:2:2) while the chrominance components of type 1 video are downsampled both horizontally and vertically by 2 (often called 4:2:0).",
      "ja": "これらのサンプリング因子はタイプ0映像の色差成分が2で水平にダウンサンプリングされることを示している（しばしば4と呼ば：2：2）：2：0タイプ1映像の色差成分を2で水平および垂直ダウンサンプリングされている間（しばしば4と呼ばれます）。"
    },
    {
      "indent": 3,
      "text": "Types 0 and 1 can be used to carry both progressively scanned and interlaced image data. This is encoded using the Type-specific field in the main JPEG header. The following values are defined:",
      "ja": "タイプ0と1の両方順次走査及びインターレース画像データを運ぶために使用することができます。これは、メインJPEGヘッダ内のタイプの特定のフィールドを使用して符号化されます。次の値が定義されています。"
    },
    {
      "indent": 6,
      "text": "0 : Image is progressively scanned. On a computer monitor, it can be displayed as-is at the specified width and height.",
      "ja": "0：画像を順次走査されます。コンピュータモニタ上で、指定された幅と高さであるように、表示することができます。"
    },
    {
      "indent": 6,
      "text": "1 : Image is an odd field of an interlaced video signal. The height specified in the main JPEG header is half of the height of the entire displayed image. This field should be de-interlaced with the even field following it such that lines from each of the images alternate. Corresponding lines from the even field should appear just above those same lines from the odd field.",
      "ja": "1：画像は、インターレース映像信号の奇数フィールドです。メインJPEGヘッダで指定された高さが全体表示される画像の高さの半分です。このフィールドは、そのようなライン画像の代替のそれぞれからその次の偶数フィールドでデインタレースされるべきです。偶数フィールドからラインを対応するだけで奇数フィールドからのものと同じライン上に表示されます。"
    },
    {
      "indent": 6,
      "text": "2 : Image is an even field of an interlaced video signal.",
      "ja": "2：画像は、インターレースビデオ信号の偶数フィールドです。"
    },
    {
      "indent": 6,
      "text": "3 : Image is a single field from an interlaced video signal, but it should be displayed full frame as if it were received as both the odd & even fields of the frame. On a computer monitor, each line in the image should be displayed twice, doubling the height of the image.",
      "ja": "3：画像は、インタレース映像信号から単一のフィールドであるが、それはフレームの奇数と偶数フィールドの両方として受信されたかのように、完全なフレームを表示すべきです。コンピュータモニタ上で、画像内の各ラインは、画像の高さを倍、2回表示されるべきです。"
    },
    {
      "indent": 3,
      "text": "Appendix B contains C source code for transforming the RTP/JPEG header parameters into the JPEG frame and scan headers that are absent from the data payload.",
      "ja": "付録Bは、JPEGフレームにRTP / JPEGヘッダパラメータを変換するためのCのソースコードを含み、データペイロードには存在しないヘッダをスキャンします。"
    },
    {
      "indent": 0,
      "text": "4.2. The Q Field",
      "section_title": true,
      "ja": "4.2.  Qフィールド"
    },
    {
      "indent": 3,
      "text": "For JPEG types 0 and 1 (and their corresponding types 64 and 65), Q values between 1 and 99 inclusive are defined as follows. Other values less than 128 are reserved. Additional types are encouraged to use this definition if applicable.",
      "ja": "次のように1から99までの間のJPEGタイプ0及び1（及びそれらの対応する型64および65）、Q値のために定義されています。少ない128以外の値が予約されています。追加のタイプは、該当する場合、この定義を使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Both type 0 and type 1 JPEG require two quantization tables. These tables are calculated as follows. For 1 <= Q <= 99, the Independent JPEG Group's formula [5] is used to produce a scale factor S as:",
      "ja": "どちらのタイプ0とタイプ1 JPEGは2つの量子化テーブルを必要とします。次のようにこれらのテーブルが計算されます。 1ため<= Q <= 99、独立したJPEGグループの式[5]のようにスケールファクタSを生成するために使用されます。"
    },
    {
      "indent": 11,
      "text": "S = 5000 / Q          for  1 <= Q <= 50\n  = 200 - 2 * Q       for 51 <= Q <= 99",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This value is then used to scale Tables K.1 and K.2 from [1] (saturating each value to 8 bits) to give quantization table numbers 0 and 1, respectively. C source code is provided in Appendix A to compute these tables.",
      "ja": "この値は、それぞれ、量子化テーブル番号0および1を与えるためにK.1テーブルをスケーリングし、[1]（8ビットに各値を飽和）からK.2するために使用されます。 Cのソースコードは、これらのテーブルを計算するために、付録Aに設けられています。"
    },
    {
      "indent": 3,
      "text": "For Q values 128-255, dynamically defined quantization tables are used. These tables may be specified either in-band or out of band by something like a session setup protocol, but the Quantization Table header MUST be present in the first packet of every frame. When the tables are specified out of band, they may be omitted from the packet by setting the Length field in this header to 0.",
      "ja": "Q値の128から255の場合は、動的に定義された量子化テーブルが使用されています。これらの表は、セッション設定プロトコルのようなものによって、帯域内または帯域外のいずれかで指定することができるが、量子化テーブルのヘッダは、各フレームの最初のパケット内に存在していなければなりません。テーブルは帯域外で指定されている場合、それらは0にヘッダの長さフィールドを設定することにより、パケットから省略されてもよいです。"
    },
    {
      "indent": 3,
      "text": "When the quantization tables are sent in-band, they need not be sent with every frame. Like the out of band case, frames which do not contain tables will have a Quantization Table header with a Length field of 0. While this does decrease the overhead of including the tables, new receivers will be unable to properly decode frames from the time they start up until they receive the tables.",
      "ja": "量子化テーブルは、帯域内で送信されると、それらはすべてのフレームを送る必要はありません。このテーブルを含むのオーバーヘッドを低減しながらバンドケースのうちのように、テーブルが含まれていないフレームは、0の長さフィールドを持つ量子化テーブルヘッダを持つことになり、新たな受信機は適切に時間彼らからのフレームをデコードすることができません彼らはテーブルを受信するまで起動します。"
    },
    {
      "indent": 0,
      "text": "4.3. Fragmentation and Reassembly",
      "section_title": true,
      "ja": "4.3. フラグメンテーションおよび再構成"
    },
    {
      "indent": 3,
      "text": "Since JPEG frames can be large, they must often be fragmented. Frames SHOULD be fragmented into packets in a manner avoiding fragmentation at a lower level. If support for partial frame decoding is desired, frames SHOULD be fragmented such that each packet contains an integral number of restart intervals (see below).",
      "ja": "JPEGフレームが大きくなる可能性があるので、彼らはしばしば断片化されなければなりません。フレームは、より低いレベルの断片化を回避するようにしてパケットに断片化されるべきです。部分フレーム復号のためのサポートが望まれる場合、フレームは、各パケットは、再起動間隔の整数（下記参照）を含むように断片化されるべきです。"
    },
    {
      "indent": 3,
      "text": "Each packet that makes up a single frame MUST have the same timestamp, and the RTP marker bit MUST be set on the last packet in a frame. The fragment offset field of each packet is set to the byte offset of its payload data within the original frame. Packets making up a frame SHOULD be sent sequentially and the fragments they contain MUST NOT overlap one another.",
      "ja": "単一のフレームを構成する各パケットは同じタイムスタンプを持っていなければならない、とRTPマーカービットはフレーム内の最後のパケットに設定しなければなりません。各パケットのフラグメントオフセットフィールドは、元のフレーム内のペイロードデータのバイトオフセットに設定されています。フレームを構成するパケットは、順次送信されるべきであり、そこに含まれる断片は、互いに重複しないようにします。"
    },
    {
      "indent": 3,
      "text": "An entire frame can be identified as a sequence of packets beginning with a packet having a zero fragment offset and ending with a packet having the RTP marker bit set. Missing packets can be detected either with RTP sequence numbers or with the fragment offset and lengths of each packet. Reassembly could be carried out without the offset field (i.e., using only the RTP marker bit and sequence numbers), but an efficient single-copy implementation would not otherwise be possible in the presence of misordered packets. Moreover, if the last packet of the previous frame (containing the marker bit) were dropped, then a receiver could not always detect that the current frame is entirely intact.",
      "ja": "フレーム全体は、パケットゼロオフセット断片を有し、RTPマーカビットのセットを有するパケットで終わるから始まるパケットのシーケンスとして識別することができます。欠落パケットは、RTPシーケンス番号またはフラグメントオフセットと、各パケットの長さのいずれかを検出することができます。再アセンブリ（すなわち、唯一のRTPマーカビットとシーケンス番号を使用して）オフセットフィールドなしで行うことができるが、効率的な単一コピーの実装では、そうでなければmisorderedパケットの存在下では可能ではないであろう。 （マーカービットを含む）を、前のフレームの最後のパケットがドロップされた場合はさらに、受信機は常に現在のフレームが完全に無傷であることを検出できませんでした。"
    },
    {
      "indent": 0,
      "text": "4.4. Restart Markers",
      "section_title": true,
      "ja": "4.4. 再起動マーカー"
    },
    {
      "indent": 3,
      "text": "Restart markers indicate a point in the JPEG stream at which the Huffman decoder and DC predictors are reset, allowing partial decoding starting at that point. To fully take advantage of this, however, a decoder must know which MCUs of a frame a particular restart interval encodes. While the original JPEG specification does provide a small sequence number field in the restart markers for this purpose, it is not large enough to properly cope with the loss of an entire packet's worth of data at a typical network MTU size. The RTP/JPEG Restart Marker header contains the additional information needed to accomplish this.",
      "ja": "リスタートマーカーは、その時点で始まる部分的な復号化を可能にハフマンデコーダ及びDC予測値がリセットされるJPEGストリーム内の点を示します。十分これを利用するために、しかし、デコーダは、特定の再起動間隔がコードフレームのどのマイコンを知っていなければなりません。オリジナルのJPEG仕様は、この目的のためにリスタートマーカに小さなシーケンス番号フィールドを提供していますが、正しく、典型的なネットワークのMTUサイズでデータのパケット全体の価値の損失に対処するのに十分な大きさではありません。 RTP / JPEG再起動マーカヘッダは、これを達成するために必要な追加情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The size of restart intervals SHOULD be chosen to always allow an integral number of restart intervals to fit within a single packet. This will guarantee that packets can be decoded independently from one another. If a restart interval ends up being larger than a packet, the F and L bits in the Restart Marker header can be used to fragment it, but the resulting set of packets must all be received by a decoder for that restart interval to be decoded properly.",
      "ja": "再起動間隔の大きさは、常に再起動間隔の整数は、単一のパケット内に収まるように選択する必要があります。これは、パケットが互いに独立してデコードすることができることを保証します。再起動間隔がパケットよりも大きくなってしまう場合には、再起動マーカーヘッダにFとLビットは、それを断片化するために使用することができるが、その再起動間隔を適切に復号するためにパケットの結果セットは、すべてのデコーダによって受信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once a decoder has received either a single packet with both the F and L bits set on or a contiguous sequence of packets (based on the RTP sequence number) which begin with an F bit and end with an L bit, it can begin decoding. The position of the MCU at the beginning of the data can be determined by multiplying the Restart Count value by the Restart Interval value. A packet (or group of packets as identified by the F and L bits) may contain any number of consecutive restart intervals.",
      "ja": "デコーダはFおよびLビットとFビットと端で始まるLの上に設定されたビットまたは（RTPシーケンス番号に基づいて）パケットの連続する配列の両方を有する単一のパケットのいずれかを受信した後、それが復号を開始することができます。データの先頭のMCUの位置は、再起動間隔の値によって再起動カウント値を乗じることによって決定することができます。パケット（又はF及びLビットによって識別されるパケットのグループ）が連続再起動間隔の任意の数を含んでいてもよいです。"
    },
    {
      "indent": 3,
      "text": "To accommodate encoders which generate frames with restart markers in them but cannot fragment the data in this manner, the Restart Count field may be set to 0x3FFF with the F and L bits both set to 1. This indicates to decoders that the entire frame must be reassembled before decoding it.",
      "ja": "それらにリスタートマーカのフレームを生成するが、このようにデータを断片化することができないエンコーダを収容するために、再起動カウントフィールドがFおよびLビットで0x3FFFのに設定の両方を1に設定することができるこれは、フレーム全体がなければならないデコーダに示しそれをデコードする前に再組み立て。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "RTP packets using the payload format defined in this specification are subject to the security considerations discussed in the RTP specification [6], and any appropriate RTP profile (for example [7]). This implies that confidentiality of the media streams is achieved by encryption. Because the data compression used with this payload format is applied end-to-end, encryption may be performed after compression so there is no conflict between the two operations.",
      "ja": "本明細書で定義されたペイロードフォーマットを使用して、RTPパケットは、RTP仕様[6]で議論したセキュリティ問題を受けることであり、任意の適切なRTPプロファイル（例えば[7]）。これは、メディアストリームの機密性は、暗号化によって達成されることを意味します。このペイロードフォーマットに使用されるデータ圧縮は、エンドツーエンドで適用されるので、二つの操作の間に競合がないので、暗号化は、圧縮後に行ってもよいです。"
    },
    {
      "indent": 3,
      "text": "A potential denial-of-service threat exists for data encodings using compression techniques that have non-uniform receiver-end computational load. The attacker can inject pathological datagrams into the stream which are complex to decode and cause the receiver to be overloaded. However, this encoding does not exhibit any significant non-uniformity.",
      "ja": "潜在的なサービス拒否の脅威は、不均一な受信端計算負荷を有する圧縮技術を使用してデータ・エンコーディングのために存在します。攻撃者が復号及び受信機が過負荷にさせるのに複雑であるストリームに病理学的なデータグラムを注入することができます。しかし、このエンコーディングは、有意な不均一性を示しません。"
    },
    {
      "indent": 3,
      "text": "Another potential denial-of-service threat exists around the fragmentation mechanism presented here. Receivers should be prepared to limit the total amount of data associated with assembling received frames so as to avoid resource exhaustion.",
      "ja": "別の潜在的なサービス拒否の脅威は、ここに提示した断片化メカニズムの周りに存在します。受信機は、リソースの枯渇を回避するように受信したフレームを組み立てるに関連付けられたデータの総量を制限するために用意されなければなりません。"
    },
    {
      "indent": 3,
      "text": "As with any IP-based protocol, in some circumstances a receiver may be overloaded simply by the receipt of too many packets, either desired or undesired. Network-layer authentication may be used to discard packets from undesired sources, but the processing cost of the authentication itself may be too high. In a multicast environment, pruning of specific sources will be implemented in a future version of IGMP [8] and in multicast routing protocols to allow a receiver to select which sources are allowed to reach it.",
      "ja": "任意のIPベースのプロトコルと同様に、いくつかの状況では、受信機は、所望のまたは望ましくないのいずれかで、あまりに多くのパケットを受信することによって簡単にオーバーロードされてもよいです。ネットワーク層認証は、望ましくないソースからのパケットを破棄するために使用することができるが、認証自体の処理コストが高すぎるかもしれません。マルチキャスト環境では、特定の供給源の剪定は、それに到達するために許可されているソースを選択するために受信機を可能にするためにIGMP [8]の将来のバージョンおよびマルチキャストルーティングプロトコルに実装されるであろう。"
    },
    {
      "indent": 3,
      "text": "A security review of this payload format found no additional considerations beyond those in the RTP specification.",
      "ja": "このペイロード形式のセキュリティレビューは、RTP仕様のものを超えて追加の考慮事項は認められませんでした。"
    },
    {
      "indent": 0,
      "text": "6. Authors' Addresses",
      "section_title": true,
      "ja": "6.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Lance M. Berc Systems Research Center Digital Equipment Corporation 130 Lytton Ave Palo Alto CA 94301",
      "ja": "ランス・M. Bercシステム研究センターディジタル・イクイップメント・コーポレーション130リットンアヴェパロアルトCA 94301"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 853 2100 EMail: berc@pa.dec.com",
      "ja": "電話：+1 650 853 2100 Eメール：berc@pa.dec.com"
    },
    {
      "indent": 3,
      "text": "William C. Fenner Xerox PARC 3333 Coyote Hill Road Palo Alto, CA 94304",
      "ja": "ウィリアム・C・フェナーゼロックスPARC 3333コヨーテヒルロードパロアルト、CA 94304"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 812 4816 EMail: fenner@parc.xerox.com",
      "ja": "電話：+1 650 812 4816 Eメール：fenner@parc.xerox.com"
    },
    {
      "indent": 3,
      "text": "Ron Frederick Xerox PARC 3333 Coyote Hill Road Palo Alto, CA 94304",
      "ja": "ロン・フレデリックゼロックスPARC 3333コヨーテヒルロードパロアルト、CA 94304"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 812 4459 EMail: frederick@parc.xerox.com",
      "ja": "電話：+1 650 812 4459 Eメール：frederick@parc.xerox.com"
    },
    {
      "indent": 3,
      "text": "Steven McCanne University of California at Berkeley Electrical Engineering and Computer Science 633 Soda Hall Berkeley, CA 94720",
      "ja": "バークレー電気工学とコンピュータサイエンス633ソーダホールバークレー、CA 94720カリフォルニアのスティーブンMcCanne大学"
    },
    {
      "indent": 3,
      "text": "Phone: +1 510 642 0865 EMail: mccanne@cs.berkeley.edu",
      "ja": "電話：+1 510 642 0865 Eメール：mccanne@cs.berkeley.edu"
    },
    {
      "indent": 3,
      "text": "Paul Stewart Xerox PARC 3333 Coyote Hill Road Palo Alto, CA 94304",
      "ja": "ポール・スチュワートゼロックスPARC 3333コヨーテヒルロードパロアルト、CA 94304"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 812 4821 EMail: stewart@parc.xerox.com",
      "ja": "電話：+1 650 812 4821 Eメール：stewart@parc.xerox.com"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 3,
      "text": "[1] ISO DIS 10918-1. Digital Compression and Coding of Continuous-tone Still Images (JPEG), CCITT Recommendation T.81.",
      "ja": "[1] ISO DIS 10918-1。デジタル圧縮と連続階調静止画（JPEG）、CCITT勧告T.81のコーディング。"
    },
    {
      "indent": 3,
      "text": "[2] William B. Pennebaker, Joan L. Mitchell, JPEG: Still Image Data Compression Standard, Van Nostrand Reinhold, 1993.",
      "ja": "[2]ウィリアムB. Pennebaker、ジョーン・L.ミッチェル、JPEG：静止画像データの圧縮規格、ヴァン・ノストランドラインホルト、1993。"
    },
    {
      "indent": 3,
      "text": "[3] Gregory K. Wallace, The JPEG Sill Picture Compression Standard, Communications of the ACM, April 1991, Vol 34, No. 1, pp. 31-44.",
      "ja": "[3]グレゴリーK.ウォレス、JPEG静止画圧縮標準、ACMのコミュニケーション、1991年4月、第34巻、第1号、PP。31-44。"
    },
    {
      "indent": 3,
      "text": "[4] The JPEG File Interchange Format. Maintained by C-Cube Microsystems, Inc., and available in ftp://ftp.uu.net/graphics/jpeg/jfif.ps.gz.",
      "ja": "[4] JPEGは、ファイル交換形式。 C-キューブMicrosystems、Inc.が維持され、そしてftp://ftp.uu.net/graphics/jpeg/jfif.ps.gzで利用できます。"
    },
    {
      "indent": 3,
      "text": "[5] Tom Lane et. al., The Independent JPEG Group software JPEG codec. Source code available in ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6a.tar.gz.",
      "ja": "[5]トム・レーンら。アル。、Independent JPEG GroupがソフトJPEGコーデック。 ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6a.tar.gzで利用可能なソースコード。"
    },
    {
      "indent": 3,
      "text": "[6] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", RFC 1889, January 1996.",
      "ja": "[6] Schulzrinneと、H.、Casner、S.、フレデリック、R.とV. Jacobson氏、 \"RTP：リアルタイムアプリケーションのためのトランスポートプロトコル\"、RFC 1889、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[7] Schulzrinne, H., \"RTP Profile for Audio and Video Conferences with Minimal Control\", RFC 1890, January 1996.",
      "ja": "[7] Schulzrinneと、H.、 \"最小量のコントロールがあるオーディオとビデオ会議システムのためのRTPプロフィール\"、RFC 1890、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[8] Fenner, W., \"Internet Group Management Protocol Version 2\", RFC 2236, November 1997.",
      "ja": "[8]フェナー、W.、 \"インターネットグループ管理プロトコルバージョン2\"、RFC 2236、1997年11月。"
    },
    {
      "indent": 3,
      "text": "[9] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[9]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[10] Kent C., and J. Mogul, \"Fragmentation Considered Harmful\", Proceedings of the ACM SIGCOMM '87 Workshop on Frontiers in Computer Communications Technology, August 1987.",
      "ja": "[10]ケントC.、およびJ.モーグル、「有害であると考えられた断片化」、コンピュータ通信技術、1987年8月にフロンティアにACM SIGCOMM '87ワークショップの議事録。"
    },
    {
      "indent": 0,
      "text": "Appendix A",
      "ja": "付録A"
    },
    {
      "indent": 3,
      "text": "The following code can be used to create a quantization table from a Q factor:",
      "ja": "次のコードは、Q値から量子化テーブルを作成するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "/*\n * Table K.1 from JPEG spec.\n */\nstatic const int jpeg_luma_quantizer[64] = {\n        16, 11, 10, 16, 24, 40, 51, 61,\n        12, 12, 14, 19, 26, 58, 60, 55,\n        14, 13, 16, 24, 40, 57, 69, 56,\n        14, 17, 22, 29, 51, 87, 80, 62,\n        18, 22, 37, 56, 68, 109, 103, 77,\n        24, 35, 55, 64, 81, 104, 113, 92,\n        49, 64, 78, 87, 103, 121, 120, 101,\n        72, 92, 95, 98, 112, 100, 103, 99\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n * Table K.2 from JPEG spec.\n */\nstatic const int jpeg_chroma_quantizer[64] = {\n        17, 18, 24, 47, 99, 99, 99, 99,\n        18, 21, 26, 66, 99, 99, 99, 99,\n        24, 26, 56, 99, 99, 99, 99, 99,\n        47, 66, 99, 99, 99, 99, 99, 99,\n        99, 99, 99, 99, 99, 99, 99, 99,\n        99, 99, 99, 99, 99, 99, 99, 99,\n        99, 99, 99, 99, 99, 99, 99, 99,\n        99, 99, 99, 99, 99, 99, 99, 99\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n * Call MakeTables with the Q factor and two u_char[64] return arrays\n */\nvoid\nMakeTables(int q, u_char *lqt, u_char *cqt)\n{\n  int i;\n  int factor = q;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "if (q < 1) factor = 1;\nif (q > 99) factor = 99;\nif (q < 50)\n  q = 5000 / factor;\nelse\n  q = 200 - factor*2;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "for (i=0; i < 64; i++) {\n  int lq = (jpeg_luma_quantizer[i] * q + 50) / 100;\n  int cq = (jpeg_chroma_quantizer[i] * q + 50) / 100;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Limit the quantizers to 1 <= q <= 255 */\nif (lq < 1) lq = 1;\nelse if (lq > 255) lq = 255;\nlqt[i] = lq;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "    if (cq < 1) cq = 1;\n    else if (cq > 255) cq = 255;\n    cqt[i] = cq;\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix B",
      "ja": "付録B"
    },
    {
      "indent": 3,
      "text": "The following routines can be used to create the JPEG marker segments corresponding to the table-specification data that is absent from the RTP/JPEG body.",
      "ja": "以下のルーチンは、RTP / JPEG体には存在しない表指​​定データに対応するJPEGマーカセグメントを作成するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "u_char lum_dc_codelens[] = { 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, };",
      "ja": "u_char型lum_dc_codelens [] = {0、1、5、1、1、1、1、1、1、0、0、0、0、0、0、0}。"
    },
    {
      "indent": 0,
      "text": "u_char lum_dc_symbols[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, };",
      "ja": "u_char型lum_dc_symbols [] = {0、1、2、3、4、5、6、7、8、9、10、11}。"
    },
    {
      "indent": 0,
      "text": "u_char lum_ac_codelens[] = { 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d, };",
      "ja": "u_char型lum_ac_codelens [] = {0、2、1、3、3、2、4、3、5、5、4、4、0、0、1、0x7d、}。"
    },
    {
      "indent": 0,
      "text": "u_char lum_ac_symbols[] = { 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, };",
      "ja": "u_char型lum_ac_symbols [] = {が0x01、0x02の、0x03の、0x00に、0x04を、0x11を、0x05の、0x12を、0x21で、0x31、0x41から、0x06で、0x13に、0x51、の0x61、0x07の、ただし0x22、（0x71）を、0x14に、0x32の、0x81と、0x91を、 0xA1の、0x08に、0x23、0x42に、の0xB1、0xc1、0x15の、0x52、0xd1、0xF0が、0x24を、0x33の、0x62、0x72、0x82と、0x09の、は0x0A、0x16、0x17の、0x18の、0x19、0x1a、0x25、0x26、は0x27、 0x2aの0x28、0x29、0x34の、0x35の0x36、0x37は、0x38、ます。0x39、0x3a、0x43この、0x44の、0x45、0x46の、0x47、0x48、0x49、0x4a、$ 53、が0x54、0x55を、0x56、0x57、0x58、0x59、 0x5a、は0x63、0x64、0x65、は0x66、0x67、0x68、0x69の、0x6a、0x73、0x74、0x75、0x76、0x77、0x78と、0x79、0x7Aの、0x83の、0x84の、0x85、0x86で、0x87の、0x88、0x89、0x8a、 0x92、0x93、0x94、0x95、0x96、0x97、0×98、0x99、0x9a、0xa2、0xA3の、0xA4の、0xA5の、は0xA6、0xa7、0xa8、0xa9、0xAAを、コード（0xB2）、0xb3、0xb4、0xb5、0xb6、0xb7、0xb8、 0xb9、0xba、に0xC2、0xc3、0xc4、0xc5、0xc6、0xc7の、0xc8、0xc9、0xca、0xd2、0xd3、は0xD4、に0xD5、0xd6、0xd7、0xd8、0xd9、0xda、0xE1の、0xe2、0xe3、0xe4、0xe5、 0xe6、0xe7、0xe8、0xe9、0xea、0xf1、0xf2、0xf3、0xf4、0xf5、0xf6、0xf7、0xf8、0xf9、0xfa、 }。"
    },
    {
      "indent": 0,
      "text": "u_char chm_dc_codelens[] = { 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, };",
      "ja": "u_char型chm_dc_codelens [] = {0、3、1、1、1、1、1、1、1、1、1、0、0、0、0、0}。"
    },
    {
      "indent": 0,
      "text": "u_char chm_dc_symbols[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,",
      "ja": "u_char型chm_dc_symbols [] = {0、1、2、3、4、5、6、7、8、9、10、11、"
    },
    {
      "indent": 0,
      "text": "};",
      "ja": "｝；"
    },
    {
      "indent": 0,
      "text": "u_char chm_ac_codelens[] = { 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77, };",
      "ja": "u_char型chm_ac_codelens [] = {0、2、1、2、4、4、3、4、7、5、4、4、0、1、2、0x77}。"
    },
    {
      "indent": 0,
      "text": "u_char chm_ac_symbols[] = { 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, };",
      "ja": "u_char型chm_ac_symbols [] = {0x00で、0x01の、0x02の、0x03の、0x11を、0x04が、0x05の、0x21で、0x31、0x06で、0x12を、0×41、0x51、0x07の、の0x61、（0x71）を、0x13に、ただし0x22、0x32の、0x81と、0x08に、0x14に、 0x42、0x91を、0xA1の、の0xB1、0xc1、0x09の、0x23、0x33の、0x52、0xF0が、0x15の、0x62、0x72、0xd1、は0x0A、0x16、0x24を、0x34の、0xE1の、0x25、0xf1、0x17の、0x18の、0x19、0x1a、 0x2a 0x26、は0x27、の0x28、0x29、0x35の0x36、0x37は、0x38、ます。0x39、0x3a、0x43この、0x44の、0x45、0x46の、0x47、0x48、0x49、0x4a、$ 53、が0x54、0x55を、0x56、0x57、0x58、 0x59、0x5a、は0x63、0x64、0x65、は0x66、0x67、0x68、0x69の、0x6a、0x73、0x74、0x75、0x76、0x77、0x78と、0x79、0x7Aの、0x82と、0x83の、0x84の、0x85、0x86で、0x87の、0x88、 0x89、0x8a、0x92、0x93、0x94、0x95、0x96、0x97、0×98、0x99、0x9a、0xa2、0xA3の、0xA4の、0xA5の、は0xA6、0xa7、0xa8、0xa9、0xAAを、コード（0xB2）、0xb3、0xb4、0xb5、0xb6、 0xb7、0xb8、0xb9、0xba、に0xC2、0xc3、0xc4、0xc5、0xc6、0xc7の、0xc8、0xc9、0xca、0xd2、0xd3、は0xD4、に0xD5、0xd6、0xd7、0xd8、0xd9、0xda、0xe2、0xe3、0xe4、 0xe5、0xe6、0xe7、0xe8、0xe9、0xea、0xf2、0xf3、0xf4、0xf5、0xf6、0xf7、0xf8、0xf9、0xfa、 }。"
    },
    {
      "indent": 0,
      "text": "u_char *\nMakeQuantHeader(u_char *p, u_char *qt, int tableNo)\n{\n        *p++ = 0xff;\n        *p++ = 0xdb;            /* DQT */\n        *p++ = 0;               /* length msb */\n        *p++ = 67;              /* length lsb */\n        *p++ = tableNo;\n        memcpy(p, qt, 64);\n        return (p + 64);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "u_char * MakeHuffmanHeader(u_char *p, u_char *codelens, int ncodes, u_char *symbols, int nsymbols, int tableNo, int tableClass) { *p++ = 0xff;",
      "ja": "u_char型* MakeHuffmanHeader（u_char型* P、u_char型* codelens、int型ncodes、u_char型*記号、INT nsymbols、INT tableNo、INT tableClass）{* P ++ = 0xFFで;"
    },
    {
      "indent": 0,
      "text": "        *p++ = 0xc4;            /* DHT */\n        *p++ = 0;               /* length msb */\n        *p++ = 3 + ncodes + nsymbols; /* length lsb */\n        *p++ = (tableClass << 4) | tableNo;\n        memcpy(p, codelens, ncodes);\n        p += ncodes;\n        memcpy(p, symbols, nsymbols);\n        p += nsymbols;\n        return (p);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "u_char *\nMakeDRIHeader(u_char *p, u_short dri) {\n        *p++ = 0xff;\n        *p++ = 0xdd;            /* DRI */\n        *p++ = 0x0;             /* length msb */\n        *p++ = 4;               /* length lsb */\n        *p++ = dri >> 8;        /* dri msb */\n        *p++ = dri & 0xff;      /* dri lsb */\n        return (p);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n *  Arguments:\n *    type, width, height: as supplied in RTP/JPEG header\n *    lqt, cqt: quantization tables as either derived from\n *         the Q field using MakeTables() or as specified\n *         in section 4.2.\n *    dri: restart interval in MCUs, or 0 if no restarts.\n *\n *    p: pointer to return area\n *\n *  Return value:\n *    The length of the generated headers.\n *\n *    Generate a frame and scan headers that can be prepended to the\n *    RTP/JPEG data payload to produce a JPEG compressed image in\n *    interchange format (except for possible trailing garbage and\n *    absence of an EOI marker to terminate the scan).\n */\nint MakeHeaders(u_char *p, int type, int w, int h, u_char *lqt,\n                u_char *cqt, u_short dri)\n{\n        u_char *start = p;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "/* convert from blocks to pixels */\nw <<= 3;\nh <<= 3;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "*p++ = 0xff;\n*p++ = 0xd8;            /* SOI */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "p = MakeQuantHeader(p, lqt, 0);\np = MakeQuantHeader(p, cqt, 1);",
      "raw": true
    },
    {
      "indent": 8,
      "text": "if (dri != 0) p = MakeDRIHeader(p, dri);",
      "ja": "（DRI = 0！）の場合、P = MakeDRIHeader（P、DRI）。"
    },
    {
      "indent": 8,
      "text": "*p++ = 0xff;\n*p++ = 0xc0;            /* SOF */\n*p++ = 0;               /* length msb */\n*p++ = 17;              /* length lsb */\n*p++ = 8;               /* 8-bit precision */\n*p++ = h >> 8;          /* height msb */\n*p++ = h;               /* height lsb */\n*p++ = w >> 8;          /* width msb */\n*p++ = w;               /* wudth lsb */\n*p++ = 3;               /* number of components */\n*p++ = 0;               /* comp 0 */\nif (type == 0)\n        *p++ = 0x21;    /* hsamp = 2, vsamp = 1 */\nelse\n        *p++ = 0x22;    /* hsamp = 2, vsamp = 2 */\n*p++ = 0;               /* quant table 0 */\n*p++ = 1;               /* comp 1 */\n*p++ = 0x11;            /* hsamp = 1, vsamp = 1 */\n*p++ = 1;               /* quant table 1 */\n*p++ = 2;               /* comp 2 */\n*p++ = 0x11;            /* hsamp = 1, vsamp = 1 */\n*p++ = 1;               /* quant table 1 */\np = MakeHuffmanHeader(p, lum_dc_codelens,\n                      sizeof(lum_dc_codelens),\n                      lum_dc_symbols,\n                      sizeof(lum_dc_symbols), 0, 0);\np = MakeHuffmanHeader(p, lum_ac_codelens,\n                      sizeof(lum_ac_codelens),\n                      lum_ac_symbols,\n                      sizeof(lum_ac_symbols), 0, 1);\np = MakeHuffmanHeader(p, chm_dc_codelens,\n                      sizeof(chm_dc_codelens),\n                      chm_dc_symbols,\n                      sizeof(chm_dc_symbols), 1, 0);\np = MakeHuffmanHeader(p, chm_ac_codelens,\n                      sizeof(chm_ac_codelens),\n                      chm_ac_symbols,\n                      sizeof(chm_ac_symbols), 1, 1);",
      "raw": true
    },
    {
      "indent": 8,
      "text": "*p++ = 0xff;\n*p++ = 0xda;            /* SOS */\n*p++ = 0;               /* length msb */\n*p++ = 12;              /* length lsb */\n*p++ = 3;               /* 3 components */\n*p++ = 0;               /* comp 0 */\n*p++ = 0;               /* huffman table 0 */\n*p++ = 1;               /* comp 1 */\n*p++ = 0x11;            /* huffman table 1 */\n*p++ = 2;               /* comp 2 */\n*p++ = 0x11;            /* huffman table 1 */\n*p++ = 0;               /* first DCT coeff */\n*p++ = 63;              /* last DCT coeff */\n*p++ = 0;               /* sucessive approx. */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "        return (p - start);\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix C",
      "ja": "付録C"
    },
    {
      "indent": 3,
      "text": "The following routine is used to illustrate the RTP/JPEG packet fragmentation and header creation.",
      "ja": "以下のルーチンは、RTP / JPEGパケットフラグメンテーションとヘッダ作成を説明するために使用されます。"
    },
    {
      "indent": 3,
      "text": "For clarity and brevity, the structure definitions are only valid for 32-bit big-endian (most significant octet first) architectures. Bit fields are assumed to be packed tightly in big-endian bit order, with no additional padding. Modifications would be required to construct a portable implementation.",
      "ja": "明快かつ簡潔にするために、構造体の定義は、32ビットのビッグエンディアン（最上位オクテット）アーキテクチャでのみ有効です。ビットフィールドを追加せず、パディングと、ビッグエンディアンのビット順に密に充填されているものとします。修正は、ポータブルな実装を構築するために必要とされるであろう。"
    },
    {
      "indent": 0,
      "text": "/*\n * RTP data header from RFC1889\n */\ntypedef struct {\n        unsigned int version:2;   /* protocol version */\n        unsigned int p:1;         /* padding flag */\n        unsigned int x:1;         /* header extension flag */\n        unsigned int cc:4;        /* CSRC count */\n        unsigned int m:1;         /* marker bit */\n        unsigned int pt:7;        /* payload type */\n        u_int16 seq;              /* sequence number */\n        u_int32 ts;               /* timestamp */\n        u_int32 ssrc;             /* synchronization source */\n        u_int32 csrc[1];          /* optional CSRC list */\n} rtp_hdr_t;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#define RTP_HDR_SZ 12",
      "ja": "RTP_HDR_SZ 12の#define"
    },
    {
      "indent": 0,
      "text": "/* The following definition is from RFC1890 */\n#define RTP_PT_JPEG             26",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct jpeghdr {\n        unsigned int tspec:8;   /* type-specific field */\n        unsigned int off:24;    /* fragment byte offset */\n        u_int8 type;            /* id of jpeg decoder params */\n        u_int8 q;               /* quantization factor (or table id) */\n        u_int8 width;           /* frame width in 8 pixel blocks */\n        u_int8 height;          /* frame height in 8 pixel blocks */\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct jpeghdr_rst {\n        u_int16 dri;\n        unsigned int f:1;\n        unsigned int l:1;\n        unsigned int count:14;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct jpeghdr_qtable {\n        u_int8  mbz;\n        u_int8  precision;\n        u_int16 length;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#define RTP_JPEG_RESTART 0x40",
      "ja": "#define RTP_JPEG_RESTARTの0x40"
    },
    {
      "indent": 0,
      "text": "/* Procedure SendFrame:\n *\n *  Arguments:\n *    start_seq: The sequence number for the first packet of the current\n *               frame.\n *    ts: RTP timestamp for the current frame\n *    ssrc: RTP SSRC value\n *    jpeg_data: Huffman encoded JPEG scan data\n *    len: Length of the JPEG scan data\n *    type: The value the RTP/JPEG type field should be set to\n *    typespec: The value the RTP/JPEG type-specific field should be set\n *              to\n *    width: The width in pixels of the JPEG image\n *    height: The height in pixels of the JPEG image\n *    dri: The number of MCUs between restart markers (or 0 if there\n *         are no restart markers in the data\n *    q: The Q factor of the data, to be specified using the Independent\n *       JPEG group's algorithm if 1 <= q <= 99, specified explicitly\n *       with lqt and cqt if q >= 128, or undefined otherwise.\n *    lqt: The quantization table for the luminance channel if q >= 128\n *    cqt: The quantization table for the chrominance channels if\n *         q >= 128\n *\n *  Return value:\n *    the sequence number to be sent for the first packet of the next\n *    frame.\n *\n * The following are assumed to be defined:\n *\n * PACKET_SIZE                         - The size of the outgoing packet\n * send_packet(u_int8 *data, int len)  - Sends the packet to the network\n */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "u_int16 SendFrame(u_int16 start_seq, u_int32 ts, u_int32 ssrc,\n                   u_int8 *jpeg_data, int len, u_int8 type,\n                   u_int8 typespec, int width, int height, int dri,\n                   u_int8 q, u_int8 *lqt, u_int8 *cqt) {\n        rtp_hdr_t rtphdr;\n        struct jpeghdr jpghdr;\n        struct jpeghdr_rst rsthdr;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct jpeghdr_qtable qtblhdr;\nu_int8 packet_buf[PACKET_SIZE];\nu_int8 *ptr;\nint bytes_left = len;\nint seq = start_seq;\nint pkt_len, data_len;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "/* Initialize RTP header\n */\nrtphdr.version = 2;\nrtphdr.p = 0;\nrtphdr.x = 0;\nrtphdr.cc = 0;\nrtphdr.m = 0;\nrtphdr.pt = RTP_PT_JPEG;\nrtphdr.seq = start_seq;\nrtphdr.ts = ts;\nrtphdr.ssrc = ssrc;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "/* Initialize JPEG header\n */\njpghdr.tspec = typespec;\njpghdr.off = 0;\njpghdr.type = type | ((dri != 0) ? RTP_JPEG_RESTART : 0);\njpghdr.q = q;\njpghdr.width = width / 8;\njpghdr.height = height / 8;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "/* Initialize DRI header\n */\nif (dri != 0) {\n        rsthdr.dri = dri;\n        rsthdr.f = 1;        /* This code does not align RIs */\n        rsthdr.l = 1;\n        rsthdr.count = 0x3fff;\n}",
      "raw": true
    },
    {
      "indent": 8,
      "text": "/* Initialize quantization table header\n */\nif (q >= 128) {\n        qtblhdr.mbz = 0;\n        qtblhdr.precision = 0; /* This code uses 8 bit tables only */\n        qtblhdr.length = 128;  /* 2 64-byte tables */\n}",
      "raw": true
    },
    {
      "indent": 8,
      "text": "while (bytes_left > 0) {\n        ptr = packet_buf + RTP_HDR_SZ;\n        memcpy(ptr, &jpghdr, sizeof(jpghdr));",
      "raw": true
    },
    {
      "indent": 16,
      "text": "ptr += sizeof(jpghdr);",
      "ja": "（JPEGのHDR）のPTR + =サイズ。"
    },
    {
      "indent": 16,
      "text": "if (dri != 0) {\n        memcpy(ptr, &rsthdr, sizeof(rsthdr));\n        ptr += sizeof(rsthdr);\n}",
      "raw": true
    },
    {
      "indent": 16,
      "text": "if (q >= 128 && jpghdr.off == 0) {\n        memcpy(ptr, &qtblhdr, sizeof(qtblhdr));\n        ptr += sizeof(qtblhdr);\n        memcpy(ptr, lqt, 64);\n        ptr += 64;\n        memcpy(ptr, cqt, 64);\n        ptr += 64;\n}",
      "raw": true
    },
    {
      "indent": 16,
      "text": "data_len = PACKET_SIZE - (ptr - packet_buf);\nif (data_len >= bytes_left) {\n        data_len = bytes_left;\n        rtphdr.m = 1;\n}",
      "raw": true
    },
    {
      "indent": 16,
      "text": "memcpy(packet_buf, &rtphdr, RTP_HDR_SZ);\nmemcpy(ptr, jpeg_data + jpghdr.off, data_len);",
      "raw": true
    },
    {
      "indent": 16,
      "text": "send_packet(packet_buf, (ptr - packet_buf) + data_len);",
      "ja": "send_packet（packet_buf、（PTR  -  packet_buf）+ DATA_LEN）。"
    },
    {
      "indent": 0,
      "text": "                jpghdr.off += data_len;\n                bytes_left -= data_len;\n                rtphdr.seq++;\n        }\n        return rtphdr.seq;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix D",
      "ja": "付録D"
    },
    {
      "indent": 3,
      "text": "This section outlines the changes between this document and its precdecessor, RFC 2035. The changes to the protocol were made with an eye towards causing as few interoperability problems between implementations based on the older text and newer implementations, and indeed, many of the obsolete conventions can still be unambiguously decoded by a newer implementation. However, use of the older conventions in newer implementations is strongly discouraged.",
      "ja": "このセクションでは、実際に廃止された規則の多くは、古いテキストに基づいて実装と新しい実装間など、いくつかの相互運用性の問題を引き起こし向けて、この文書とそのprecdecessor、RFC 2035プロトコルへの変更が目に行われた間の変更を概説し、まだ明確に新しい実装によって復号化することができます。しかし、新しい実装では、古い慣習を使用することを強くお勧めします。"
    },
    {
      "indent": 4,
      "text": "o Types 0 and 1 have been augmented to allow for the encoding of interlaced video images, using 2 bits of the type-specific field. See section 4.1 for details.",
      "ja": "Oタイプ0および1は、タイプ固有のフィールドの2ビットを用いて、インターレース映像の符号化を可能にするために拡張されてきました。詳細については、4.1節を参照してください。"
    },
    {
      "indent": 4,
      "text": "o There has been discussion in the working group arguing for more flexibility in specifying the JPEG quantization tables. This memo allows table coefficients to be specified explicitly through the use of an optional Quantization Table header, discussed in sections 3.1.8 and 4.2.",
      "ja": "O JPEG量子化テーブルを指定することで、より柔軟性を主張ワーキンググループでの議論がなされてきました。このメモは、テーブル係数はセクション3.1.8および4.2で説明した、オプションの量子化テーブルヘッダの使用を介して明示的に指定することを可能にします。"
    },
    {
      "indent": 4,
      "text": "o In RFC 2035, the encoding of restart marker information in the Type field made it difficult to add new types. Additionally, the type- specific field was used for the restart count, making it unavailable for other type-specific purposes. This memo moves the restart marker indication to a particular bit in the Type field, and adds an optional header to hold the additional information required, leaving the type-specific field free for its intended purpose. The handling of partial frame decoding was also made more robust against packet loss. See sections 3.1.7 and 4.4 for details.",
      "ja": "O RFC 2035では、Typeフィールドでのリスタートマーカ情報の符号化は、それが困難な新しいタイプを追加しました。また、タイプ - 特定のフィールドは、他のタイプ固有の目的のために、それが使用できなくなって、再起動回数を使用しました。このメモは、Typeフィールドの特定のビットにリスタートマーカ表示を移動し、必要な追加情報を保持するオプションヘッダを付加し、その意図された目的のために遊離型特異フィールドを残します。部分フレームデコードの処理は、パケット損失に対してより堅牢ました。セクションに詳細については、3.1.7と4.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    }
  ]
}