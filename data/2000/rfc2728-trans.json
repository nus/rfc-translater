{
  "title": {
    "text": "RFC 2728 - The Transmission of IP Over the Vertical Blanking Interval of a Television Signal",
    "ja": "RFC 2728 - テレビ信号の垂直ブランキング間隔でIPの伝送"
  },
  "number": 2728,
  "created_at": "2019-10-29 08:07:42.110561+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                    R. Panabaker\nRequest for Comments: 2728                                  Microsoft\nCategory: Standards Track                                  S. Wegerif\n                                               Philips Semiconductors\n                                                           D. Zigmond\n                                                       WebTV Networks\n                                                        November 1999",
      "raw": true
    },
    {
      "indent": 4,
      "text": "The Transmission of IP Over the Vertical Blanking Interval of a\n                       Television Signal",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1999）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "1. Abstract",
      "section_title": true,
      "ja": "1.要約"
    },
    {
      "indent": 3,
      "text": "This document describes a method for broadcasting IP data in a unidirectional manner using the vertical blanking interval of television signals. It includes a description for compressing IP headers on unidirectional networks, a framing protocol identical to SLIP, a forward error correction scheme, and the NABTS byte structures.",
      "ja": "この文書は、テレビジョン信号の垂直帰線消去期間を用いて、一方向の方法で放送IPデータのための方法が記載されています。これは、単方向ネットワーク上でIPヘッダを圧縮するための説明、SLIPと同じフレーミングプロトコル、前方誤り訂正方式、およびNABTSバイト構造を含みます。"
    },
    {
      "indent": 0,
      "text": "2. Introduction",
      "section_title": true,
      "ja": "2.はじめに"
    },
    {
      "indent": 3,
      "text": "This RFC proposes several protocols to be used in the transmission of IP datagrams using the Vertical Blanking Interval (VBI) of a television signal. The VBI is a non-viewable portion of the television signal that can be used to provide point-to-multipoint IP data services which will relieve congestion and traffic in the traditional Internet access networks. Wherever possible these protocols make use of existing RFC standards and non-standards.",
      "ja": "このRFCは、テレビジョン信号の垂直ブランキング期間（VBI）を使用してIPデータグラムの送信に使用されるいくつかのプロトコルを提案しています。 VBIは、伝統的なインターネットアクセスネットワークの輻輳やトラフィックを軽減しますポイント・ツー・マルチポイントIPデータサービスを提供するために使用することができるテレビジョン信号の不可視部分です。可能な限りこれらのプロトコルは、既存のRFC標準と非標準の使用を作ります。"
    },
    {
      "indent": 3,
      "text": "Traditionally, point-to-point connections (TCP/IP) have been used even for the transmission of broadcast type data. Distribution of the same content--news feeds, stock quotes, newsgroups, weather reports, and the like--are typically sent repeatedly to individual clients rather than being broadcast to the large number of users who want to receive such data.",
      "ja": "伝統的に、ポイントツーポイント接続（TCP / IP）があっても、放送型データの送信のために使用されてきました。ニュースフィード、株価情報、ニュースグループ、天気予報、など -   - 同じ内容の配布は、通常、むしろ、そのようなデータを受信するユーザーの大多数に放送されているよりも、個々のクライアントに繰り返し送信されます。"
    },
    {
      "indent": 3,
      "text": "Today, IP is quickly becoming the preferred method of distributing one-to-many data on intranets and the Internet. The coming availability of low cost PC hardware for receiving television signals accompanied by broadcast data streams makes a defined standard for the transmission of data over traditional broadcast networks imperative. A lack of standards in this area as well as the expense of hardware has prevented traditional broadcast networks from becoming effective deliverers of data to the home and office.",
      "ja": "今日では、IPはすぐにイントラネットおよびインターネット上で1対多のデー​​タを配布するための好ましい方法になってきています。放送データストリームを伴うテレビ信号を受信するための低コストのPCハードウェアの今後の可用性が不可欠従来の放送ネットワーク上でデータを伝送するための定義された標準になります。この分野での標準の欠如だけでなく、ハードウェアの費用は、家庭やオフィスへのデータの効果的な配信業者になることから、従来の放送ネットワークを防いでいます。"
    },
    {
      "indent": 3,
      "text": "This document describes the transmission of IP using the North American Basic Teletext Standard (NABTS), a recognized and industry-supported method of transporting data on the VBI. NABTS is traditionally used on 525-line television systems such as NTSC. Another byte structure, WST, is traditionally used on 625-line systems such as PAL and SECAM. These generalizations have exceptions, and countries should be treated on an individual basis. These existing television system standards will enable the television and Internet communities to provide inexpensive broadcast data services. A set of existing protocols will be layered above the specific FEC for NABTS including a serial stream framing protocol similar to SLIP (RFC 1055 [Romkey 1988]) and a compression technique for unidirectional UDP/IP headers.",
      "ja": "この文書では、北米基本テレテキスト標準（NABTS）、VBIにデータを転送するの認識と業界サポートの方法を使用してIPの伝送を説明します。 NABTSは、伝統的なNTSCとして525ラインのテレビシステムで使用されています。別のバイト構造、WSTは、伝統的なPALやSECAMなど625ラインシステムで使用されています。これらの一般化は例外があり、国は個別に扱われるべきです。これらの既存のテレビシステム規格は、安価な放送データサービスを提供するために、テレビやインターネットコミュニティを可能にします。既存のプロトコルのセットがスリップし同様のシリアルストリームフレーミングプロトコル（RFC 1055 [Romkey 1988]）及び一方向UDP / IPヘッダの圧縮技術を含むNABTSに特異的なFEC上に積層されます。"
    },
    {
      "indent": 3,
      "text": "The protocols described in this document are intended for the unidirectional delivery of IP datagrams using the VBI. That is, no return channel is described, or for that matter possible, in the VBI.",
      "ja": "この文書に記載されているプロトコルは、VBIを使用してIPデータグラムの一方向の配信のために意図されています。それはノーリターンチャンネルがVBIに、可能説明しない、またはそのことについてはされています。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119に記載されるように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Proposed protocol stack",
      "section_title": true,
      "ja": "3.提案プロトコルスタック"
    },
    {
      "indent": 3,
      "text": "The following protocol stack demonstrates the layers used in the transmission of VBI data. Each layer has no knowledge of the data it encapsulates, and is therefore abstracted from the other layers. At the link layer, the NABTS protocol defines the modulation scheme used to transport data on the VBI. At the network layer, IP handles the movement of data to the appropriate clients. In the transport layer, UDP determines the flow of data to the appropriate processes and applications.",
      "ja": "以下のプロトコルスタックは、VBIデータの送信に使用される層を示しています。各レイヤは、それがカプセル化データの知識を持たないので、他の層から抽出されます。リンク層で、NABTSプロトコルがVBIのデータを転送するために使用される変調方式を規定します。ネットワーク層では、IPは、適切なクライアントへのデータの移動を処理します。トランスポート層では、UDPは、適切なプロセスおよびアプリケーションへのデータの流れを決定します。"
    },
    {
      "indent": 14,
      "text": "+-------------------+\n|                   |\n|    Application    |\n|                   |\n+-------------------+\n|                   |  )\n|        UDP        |   )\n|                   |   )\n+-------------------+   (-- IP\n|                   |   )\n|        IP         |   )\n|                   |  )\n+-------------------+\n|    SLIP-style     |\n|   encapsulation   |\n|                   |\n+-------------------+\n|        FEC        |\n|-------------------|\n|       NABTS       |\n|                   |\n+---------+---------+\n|                   |\n|     NTSC/other    |\n|                   |\n+-------------------+\n          |\n          |\n          |            cable, off-air, etc.\n          +--------<----<----<--------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "These protocols can be described in a bottom up component model using the example of NABTS carried over NTSC modulation as follows:",
      "ja": "これらのプロトコルは、以下のようにNTSC方式の変調を介して搬送NABTSの例を用いてボトムアップコンポーネントモデルで記述することができます。"
    },
    {
      "indent": 3,
      "text": "Video signal --> NABTS --> FEC --> serial data stream --> Framing protocol --> compressed UDP/IP headers --> application data",
      "ja": "ビデオ信号 - > NABTS  - > FEC  - >シリアル・データ・ストリーム - >フレーミングプロトコル - >圧縮されたUDP / IPヘッダ - >アプリケーションデータ"
    },
    {
      "indent": 3,
      "text": "This diagram can be read as follows: television signals have NABTS packets, which contain a Forward Error Correction (FEC) protocol, modulated onto them. The data contained in these sequential, ordered packets form a serial data stream on which a framing protocol indicates the location of IP packets, with compressed headers, containing application data.",
      "ja": "次のようにこの図を読み取ることができるテレビジョン信号は、それらの上に変調前方誤り訂正（FEC）プロトコルを含むNABTSパケットを有します。パケットを順序付けられたこれらシーケンシャルに含まれるデータは、フレーミングプロトコルは、アプリケーション・データを含む、圧縮ヘッダと、IPパケットの位置を示したシリアル・データ・ストリームを形成します。"
    },
    {
      "indent": 3,
      "text": "The structure of these components and protocols are described in following subsections.",
      "ja": "これらの構成要素とプロトコルの構造は、サブセクションを以下に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.1. VBI",
      "section_title": true,
      "ja": "3.1。 VBI"
    },
    {
      "indent": 3,
      "text": "The characteristics and definition of the VBI is dependent on the television system in use, be it NTSC, PAL, SECAM or some other. For more information on Television standards worldwide, see ref [12].",
      "ja": "特性やVBIの定義は、それはNTSC、PAL、SECAMまたは他のいくつかのこと、使用中のテレビシステムに依存しています。世界中のテレビ規格の詳細については、REF [12]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1.1. 525 line systems",
      "section_title": true,
      "ja": "3.1.1。 525のラインシステム"
    },
    {
      "indent": 3,
      "text": "A 525-line television frame is comprised of two fields of 262.5 horizontal scan lines each. The first 21 lines of each field are not part of the visible picture and are collectively called the Vertical Blanking Interval (VBI).",
      "ja": "525ラインのテレビフレームは262.5水平走査線毎の2つのフィールドから構成されています。各フィールドの最初の21行は、可視画像の一部ではなく、一括して垂直ブランキング期間（VBI）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Of these 21 lines, the first 9 are used while repositioning the cathode ray to the top of the screen, but the remaining lines are available for data transport.",
      "ja": "画面の上部に陰極を再配置するが、残りの行は、データ伝送のために利用可能であるが、これらの21株のうち、最初の9が使用されています。"
    },
    {
      "indent": 3,
      "text": "There are 12 possible VBI lines being broadcast 60 times a second (each field 30 times a second). In some countries Line 21 is reserved for the transport of closed captioning data (Ref.[11]). In that case, there are 11 possible VBI lines, some or all of which could be used for IP transport. It should be noted that some of these lines are sometimes used for existing, proprietary, data and testing services. IP delivery therefore becomes one more data service using a subset or all of these lines.",
      "ja": "60回秒（各フィールド30回秒）放送されて12本の可能なVBIラインが存在します。いくつかの国ではライン21は、クローズドキャプションデータの輸送のために予約されている（参考文献[11]）。その場合には、IPトランスポートのために使用することができるいくつかまたは全ては11本の可能なVBIラインが存在します。これらの行のいくつかは、時には既存の、独自のデータとテストサービスのために使用されていることに留意すべきです。 IP配信は、したがってサブセットまたはこれらのラインの全てを用いて1つの以上のデータサービスとなります。"
    },
    {
      "indent": 0,
      "text": "3.1.2. 625 Line Systems",
      "section_title": true,
      "ja": "3.1.2。 625のラインシステム"
    },
    {
      "indent": 3,
      "text": "A 625-line television frame is comprised of two fields of 312.5 horizontal scan lines each. The first few lines of each field are used while repositioning the cathode ray to the top of the screen. The lines available for data insertion are 6-22 in the first field and 319-335 in the second field.",
      "ja": "625ラインのテレビフレームは312.5水平走査線毎の2つのフィールドから構成されています。画面の上部に陰極を再配置しながら、各フィールドの最初の数行が使用されます。データ挿入のために利用可能な行が最初のフィールドで6-22および第2のフィールドに319から335です。"
    },
    {
      "indent": 3,
      "text": "There are, therefore, 17 possible VBI lines being broadcast 50 times a second (each field 25 times a second), some or all of which could be used for IP transport. It should be noted that some of these lines are sometimes used for existing, proprietary, data and testing services. IP, therefore, becomes one more data service using a subset or all of these lines.",
      "ja": "従って、17本の可能なVBIラインが50回（各フィールドが25回秒）は、第2の放送されて、いくつかまたはそのすべてがIPトランスポートのために使用することができ、そこです。これらの行のいくつかは、時には既存の、独自のデータとテストサービスのために使用されていることに留意すべきです。 IPは、従って、サブセットまたはこれらのラインの全てを用いて1つの以上のデータサービスとなります。"
    },
    {
      "indent": 0,
      "text": "3.2. NABTS",
      "section_title": true,
      "ja": "3.2。 NABTS"
    },
    {
      "indent": 3,
      "text": "The North American Basic Teletext Standard is defined in the Electronic Industry Association's EIA-516, Ref. [2], and ITU.R BT.653-2, system C, Ref. [13]. It provides an industry-accepted",
      "ja": "北米基本テレテキスト標準は、電子工業協会のEIA-516、文献で定義されています。 [2]、及びITU.R BT.653-2、システムC、文献。 [13]。これは、業界で受け入れを提供します"
    },
    {
      "indent": 3,
      "text": "method of modulating data onto the VBI, usually of an NTSC signal. This section describes the NABTS packet format as it is used for the transport of IP.",
      "ja": "通常NTSC信号の、VBI上にデータを変調する方法。それはIPを搬送するために使用されるように、このセクションでは、NABTSパケットフォーマットを説明しています。"
    },
    {
      "indent": 3,
      "text": "It should be noted that only a subset of the NABTS standard is used, as is common practice in NABTS implementations. Further information concerning the NABTS standard and its implementation can be found in EIA-516.",
      "ja": "一般的な方法は、NABTS実装であるように、NABTS規格のサブセットのみが使用されることに留意すべきです。 NABTS標準およびその実施に関するさらなる情報は、EIA-516に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "The NABTS packet is a 36-byte structure encoded onto one horizontal scan line of a television signal having the following structure:",
      "ja": "NABTSパケットは、以下の構造を有するテレビジョン信号の1本の水平走査ライン上に符号化された36バイトの構造体です。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            clock sync         |   byte sync   |  packet addr. |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  packet address (cont.)       |  cont. index  |PcktStructFlags|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      user data (26 bytes)                     |\n:                                                               :\n:                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|\n|                               |              FEC              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The two-byte Clock Synchronization and one-byte Byte Synchronization are located at the beginning of every scan line containing a NABTS packet and are used to synchronize the decoding sampling rate and byte timing.",
      "ja": "2バイトのクロック同期と1バイトのバイト同期はNABTSパケットを含むすべての走査線の先頭に位置していると、復号サンプリングレートとバイトのタイミングを同期させるために使用されています。"
    },
    {
      "indent": 3,
      "text": "The three-byte Packet Address field is Hamming encoded (as specified in EIA-516), provides 4 data bits per byte, and thus provides 4096 possible packet addresses. These addresses are used to distinguish related services originating from the same source. This is necessary for the receiver to determine which packets are related, and part of the same service. NABTS packet addresses therefore distinguish different data services, possibly inserted at different points of the transmission system, and most likely totally unrelated. Section 4 of this document discusses Packet Addresses in detail.",
      "ja": "3バイトパケットアドレスフィールドは、（EIA-516で指定されるように）符号化されたハミングされたバイトあたり4つのデータビットを提供し、従って4096個の可能なパケットのアドレスを提供します。これらのアドレスは、同じソースから発生する関連サービスを区別するために使用されています。これは、パケットが関連しているかを決定するための受信機と同じサービスの一部に必要です。 NABTSパケットアドレスは、したがって、おそらく伝送システムの異なる点に挿入された異なるデータサービスを、区別し、全く関係のない最も可能性が高いです。このドキュメントのセクション4が詳細にパケットアドレスについて説明します。"
    },
    {
      "indent": 3,
      "text": "The one-byte Continuity Index field is a Hamming encoded byte, which is incremented by one for each subsequent packet of a given Packet Address. The value or number of the Continuity Index sequences from 0 to 15. It increments by one each time a data packet is transmitted. This allows the decoder to determine if packets were lost during transmission.",
      "ja": "半角継続Indexフィールドは、指定されたパケットアドレスの後続の各パケットについて1だけインクリメントされたハミング符号化されたバイトです。 0から15までの値または継続ランキング配列の数は、これは、1つによって、データパケットが送信されるたびにインクリメントします。これは、パケットが送信中に失われた場合、デコーダが決定することを可能にします。"
    },
    {
      "indent": 3,
      "text": "The Packet Structure field is also a Hamming encoded byte, which contains information about the structure of the remaining portions of the packet. The least significant bit is always \"0\" in this implementation. The second least significant bit specifies if the Data Block is full--\"0\" indicates the data block is full of useful data, and \"1\" indicates some or all of the data is filler data. The two most significant bits are used to indicate the length of the suffix of the Data Block--in this implementation, either 2 or 28 bytes (10 for 2-byte FEC suffix, 11 for 28-byte FEC suffix). This suffix is used for the forward error correction described in the next section. The following table shows the possible values of the Packet Structure field:",
      "ja": "パケット構造フィールドは、パケットの残りの部分の構造に関する情報が含まれてハミング符号化されたバイトです。最下位ビットは、この実装では、常に「0」です。データブロックが満杯である場合は、2番目の最下位ビットを指定 - 「0」データブロックが有効なデータでいっぱいであることを示し、「1」データの一部または全部が充填データであることを示します。 2つの最上位ビットは、データブロックの接尾語の長さを示すために使用されている - この実装では、2または28バイト（28バイトのFECサフィックスの2バイトのFECサフィックスの10、11）。この接尾辞は、次のセクションで説明した前方誤り訂正のために使用されています。次の表は、パケット構造フィールドの可能な値を示します。"
    },
    {
      "indent": 9,
      "text": "Data Packet, no filler                     D0\nData Packet, with filler                   8C\nFEC Packet                                 A1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Data Block field is 26 bytes, zero to 26 of which is useful data (part of a IP packet or SLIP frame), the remainder is filler data. Data is byte-ordered least significant bit first. Filler data is indicated by an Ox15 followed by as many OxEA as are needed to fill the Data Block field. Sequential data blocks minus the filler data form an asynchronous serial stream of data.",
      "ja": "データブロックフィールドは、残りは充填データであり、26バイト、ゼロその26には、有用なデータ（IPパケットまたはSLIPフレームの一部）です。データは、最初のバイト順の最下位ビットです。フィラーデータは、データブロックのフィールドを埋めるために必要な限り多くのOxEA続いOx15で示されています。シーケンシャルデータブロックマイナスフィラーデータは、データの非同期シリアル・ストリームを形成します。"
    },
    {
      "indent": 3,
      "text": "These NABTS packets are modulated onto the television signal sequentially and on any combination of lines.",
      "ja": "これらNABTSパケットは、テレビジョン信号を順次に及び線の任意の組み合わせに変調されます。"
    },
    {
      "indent": 0,
      "text": "3.3. FEC",
      "section_title": true,
      "ja": "3.3。 FEC"
    },
    {
      "indent": 3,
      "text": "Due to the unidirectional nature of VBI data transport, Forward Error Correction (FEC) is needed to ensure the integrity of data at the receiver. The type of FEC described here and in the appendix of this document for NABTS has been in use for a number of years, and has proven popular with the broadcast industry. It is capable of correcting single-byte errors and single- and double-byte erasures in the data block and suffix of a NABTS packet. In a system using NABTS, the FEC algorithm splits a serial stream of data into 364-byte \"bundles\". The data is arranged as 14 packets of 26 bytes each. A function is applied to the 26 bytes of each packet to determine the two suffix bytes, which (with the addition of a header) complete the NABTS packet (8+26+2).",
      "ja": "VBIデータ転送の一方向性の性質のために、前方誤り訂正（FEC）は、受信機でのデータの整合性を確保するために必要とされます。 FECの種類は、ここで説明するとNABTSについては、このドキュメントの付録に記載されている数年のために使用されている、と放送業界に人気が証明されています。それはNABTSパケットのデータブロックと接尾辞でシングルバイトエラーとシングルとダブルバイト消去を補正することができます。 NABTSを使用するシステムでは、FECアルゴリズムは、364バイトの「束」にデータのシリアルストリームを分割します。データは、26バイト毎の14のパケットとして配置されています。関数は、（ヘッダを加えて）NABTSパケット（8 + 26 + 2）完全な2つのサフィックス・バイトを決定するために、各パケットの26のバイトに適用されます。"
    },
    {
      "indent": 3,
      "text": "For every 14 packets in the bundle, two additional packets are appended which contain only FEC data, each of which contain 28 bytes of FEC data. The first packet in the bundle has a Continuity Index value of 0, and the two FEC only packets at the end have Continuity Index values of 14 and 15 respectively. This data is obtained by first writing the packets into a table of 16 rows and 28 columns.",
      "ja": "バンドル内のすべての14のパケットの場合、二つの追加のパケットがFECデータの28のバイトを含んでいて各々が唯一のFECデータを、含有する添付されています。バンドル内の最初のパケットは0の連続インデックス値を有し、末端に2つのFECパケットだけは、それぞれ14及び15の連続インデックス値を有します。このデータは、最初の16行と28列のテーブルにパケットを書き込むことにより得られます。"
    },
    {
      "indent": 3,
      "text": "The same expression as above can be used on the columns of the table with the suffix now represented by the bytes at the base of the columns in rows 15 and 16. With NABTS headers on each of these rows, we now have a bundle of 16 NABTS packets ready for sequential modulation onto lines of the television signal.",
      "ja": "上記と同様の式は、現在これらの行の各々にNABTSヘッダの列15および16の列の基部でバイトで表されるサフィックスを持つテーブルの列で使用することができ、現在、16の束を持っていますNABTSは、テレビジョン信号のライン上に連続的な変調のために準備パケット。"
    },
    {
      "indent": 3,
      "text": "At the receiver, these formulae can be used to verify the validity of the data with very high accuracy. If single bit errors, double bit errors, single-byte errors or single- and double-byte erasures are found in any row or column (including an entire packet lost) they can be corrected using the algorithms found in the appendix. The success at correcting errors will depend on the particular implementation used on the receiver.",
      "ja": "受信機では、これらの式は、非常に高い精度でデータの妥当性を検証するために使用することができます。シングルビットエラー、ダブルビットエラー、シングルバイトエラーやシングルおよびダブルバイトの消失は、任意の行または列に見出される場合、それらは付録に見出されるアルゴリズムを用いて補正することができる（パケット全体が失わ含みます）。エラーの修正の成功は、受信機に使用される特定の実装に依存します。"
    },
    {
      "indent": 0,
      "text": "3.4. Framing",
      "section_title": true,
      "ja": "3.4。フレーミング"
    },
    {
      "indent": 3,
      "text": "A framing protocol identical to SLIP is proposed for encapsulating the packets described in the following section, thus abstracting this data from the lower protocol layers. This protocol uses two special characters: END (0xc0) and ESC (0xdb). To send a packet, the host will send the packet followed by the END character. If a data byte in the packet is the same code as END character, a two-byte sequence of ESC (0xdb) and 0xdc is sent instead. If a data byte is the same code as ESC character, a two-byte sequence of ESC (0xdb) and 0xdd is sent instead. SLIP implementations are widely available; see RFC 1055 [Romkey 1988] for more detail.",
      "ja": "SLIPと同じフレーミングプロトコルは、このように下位プロトコル層からこのデータを抽出、次のセクションで説明したパケットをカプセル化するために提案されています。 END（0xc0から）とESC（0xdb）：このプロトコルは、2つの特殊文字を使用しています。パケットを送信するには、ホストがENDの文字が続くパケットを送信します。パケット内のデータバイトが終了文字と同じコードである場合には、ESC（0xdb）と0xdcの2バイトシーケンスが代わりに送信されます。データ・バイトは、ESC文字と同じコードである場合には、ESC（0xdb）と0xddの2バイトシーケンスが代わりに送信されます。 SLIPの実装が広く利用可能です。詳細については、RFC 1055 [Romkey 1988]を参照してください。"
    },
    {
      "indent": 6,
      "text": "+--------------+--+------------+--+--+---------+--+\n|   packet     |c0|    packet  |db|dd|         |c0|\n+--------------+--+------------+--+--+---------+--+\n                END              ESC            END",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The packet framed in this manner shall be formatted according to its schema type identified by the schema field, which shall start every packet:",
      "ja": "このようにフレームパケットは、すべてのパケットを開始しなければならないスキーマフィールドによって識別される、そのスキーマ型に従ってフォーマットされなければなりません。"
    },
    {
      "indent": 6,
      "text": "+-----------+---------------------------------------------+\n|  schema   |   packet (formatted according to schema)    |\n|  1 byte   |      ?? bytes (schema dependant length)     |\n+-----------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the case where the most significant bit in this field is set to \"1\", the length of the field extends to two bytes, allowing for 32768 additional schemas:",
      "ja": "このフィールドの最上位ビットが「1」に設定されている場合には、フィールドの長さが32768の追加スキーマを可能にする、2バイトに及びます。"
    },
    {
      "indent": 6,
      "text": "+-----------+---------------------------------------------+\n| extended  |   packet (formatted according to schema)    |\n|  schema   |       ?? bytes (schema dependant length)    |\n|   2 bytes |                                             |\n+-----------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the section 3.5, one such schema for sending IP is described. This is the only schema specified by this document. Additional schemas may be proposed for other packet types or other compression schemes as described in section 7.",
      "ja": "セクション3.5において、IPを送信するための1つのそのようなスキーマが記載されています。これは、この文書で指定されたスキーマのみです。セクション7で説明したように、追加のスキーマは、他のパケットタイプまたは他の圧縮方式のために提案されてもよいです。"
    },
    {
      "indent": 0,
      "text": "3.4.1 Maximum Transmission Unit Size",
      "section_title": true,
      "ja": "3.4.1最大伝送ユニットサイズ"
    },
    {
      "indent": 3,
      "text": "The maximum length of an uncompressed IP packet, or Maximum-Transmission Unit (MTU) size is 1500 octets. Packets larger than 1500 octets MUST be fragmented before transmission, and the client VBI interface MUST be able to receive full 1500 octet packet transmissions.",
      "ja": "最大圧縮されていないIPパケットの長さ、又は最大伝送単位（MTU）サイズ1500オクテットです。 1500オクテットより大きいパケットは、送信前に断片化されなければならない、とクライアントVBIインタフェースはフル1500のオクテットのパケット送信を受け取ることができなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.5. IP Header Compression Scheme",
      "section_title": true,
      "ja": "3.5。 IPヘッダー圧縮スキーム"
    },
    {
      "indent": 3,
      "text": "The one-byte scheme defines the format for encoding the IP packet itself. Due to the value of bandwidth, it may be desirable to introduce as much efficiency as possible in this encoding. One such efficiency is the optional compression of the UDP/IP header using a method related to the TCP/IP header compression as described by Van Jacobson (RFC 1144). UDP/IP header compression is not identical due to the limitation of unidirectional transmission. One such scheme is proposed in this document for the compression of UDP/IP version 4. It is assigned a value of 0x00. All future encapsulation schemes should use a unique value in this field.",
      "ja": "半角方式がIPパケット自体を符号化するためのフォーマットを定義します。帯域幅の値は、この符号化で可能な限り効率を導入することが望ましい場合があります。一つのこのような効率は、バン・ジェイコブソン（RFC 1144）によって記載されているようにTCP / IPヘッダー圧縮に関連する方法を使用して、UDP / IPヘッダのオプションの圧縮です。 UDP / IPヘッダー圧縮が原因一方向伝送の制限と同一ではありません。そのようなスキームはそれは$ 00の値が割り当てられているUDP / IPバージョン4の圧縮のため、この文書で提案されています。すべての将来のカプセル化スキームは、このフィールドに一意の値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Only schema 0x00 is defined in this document; this schema must be supported by all receivers. In schema 0x00, the format of the IP packet itself takes one of two forms. Packets can be sent with full, uncompressed headers as follows:",
      "ja": "スキーマだけは0x00は、この文書で定義されています。このスキーマは、すべての受信機によってサポートされなければなりません。スキーマは0x00では、IPパケット自体の形式は、次の2つの形式のいずれかをとります。次のようにパケットは、完全な、非圧縮ヘッダを送信することができます。"
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0|    group    |         uncompressed IP header (20 bytes)     |\n+-+-+-+-+-+-+-+-+                                               +\n|                                                               |\n:                             ....                              :\n+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               |        uncompressed UDP header (8 bytes)      |\n+-+-+-+-+-+-+-+-+                                               +\n|                                                               |\n+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               |              payload  (<1472 bytes)           |\n+-+-+-+-+-+-+-+-+                                               +\n|                                                               |\n:                              ....                             :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              CRC                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first byte in the 0x00 scheme is the Compression Key. It is a one-byte value: the first bit indicates if the header has been compressed, and the remaining seven bits indicate the compression group to which it belongs.",
      "ja": "0x00のスキームの最初のバイトは、圧縮キーです。それは、1バイトの値である：最初のビットは、ヘッダが圧縮されているかどうかを示し、残りの7ビットは、それが属する圧縮グループを示しています。"
    },
    {
      "indent": 3,
      "text": "If the high bit of the Compression Key is set to zero, no compression is performed and the full header is sent, as shown above. The client VBI interface should store the most recent uncompressed header for a given group value for future potential use in rebuilding subsequent compressed headers. Packets with identical group bits are assumed to have identical UDP/IP headers for all UDP and IP fields, with the exception of the \"IP identification\" and \"UDP checksum\" fields.",
      "ja": "圧縮キーの上位ビットがゼロに設定されている場合、圧縮は実行されず、上記のように、完全なヘッダは、送信されます。クライアントVBIインタフェースは、その後の圧縮ヘッダを再構築における将来の潜在的な使用のために与えられたグループ値の最新の圧縮されていないヘッダを格納する必要があります。同じグループのビットを有するパケットは、「IP識別」および「UDPチェックサム」フィールドを除いて、すべてのUDPおよびIPフィールドの同じUDP / IPヘッダを有すると仮定されます。"
    },
    {
      "indent": 3,
      "text": "Group values may be recycled following 60 seconds of nonuse by the preceding UDP/IP session (no uncompressed packets sent), or by sending packets with uncompressed headers for the 60-second duration following the last packet in the preceding UDP/IP session. Furthermore, the first packet sent following 60 seconds of nonuse, or compressed header packets only use, must use an uncompressed header. Client VBI interfaces should disregard compressed packets received 60 or more seconds after the last uncompressed packet using a given group address. This avoids any incorrectly decompressed packets due to group number reuse, and limits the outage due to a lost uncompressed packet to 60 seconds.",
      "ja": "グループの値は、先行するUDP / IPセッション（送信無し非圧縮パケット）によって、又は先行するUDP / IPセッションの最後のパケットに続く60秒の持続時間の非圧縮ヘッダを持つパケットを送信することによって、不使用の60秒以下リサイクルすることができます。また、不使用、または圧縮ヘッダーパケットの60秒以下送信最初のパケットのみが解凍されたヘッダーを使用する必要があり、使用します。クライアントVBIインタフェースは、圧縮されたパケットが所与のグループアドレスを使用して最後の非圧縮パケットの後に60秒以上を受け無視すべきです。これは、グループ番号の再利用に起因するいかなる間違って解凍したパケットを回避し、そしてによる60秒に失われた非圧縮パケットに停止を制限します。"
    },
    {
      "indent": 3,
      "text": "If the high bit of the Compression Key is set to one, a compressed version of the UDP/IP header is sent. The client VBI interface must then combine the compressed header with the stored uncompressed header of the same group and recreate a full packet. For compressed packets, the only portions of the UDP/IP header sent are the \"IP identification\" and \"UDP checksum\" fields:",
      "ja": "圧縮キーの高いビットが1に設定されている場合は、UDP / IPヘッダの圧縮されたバージョンが送信されます。クライアントVBIインタフェースは、同じグループの格納された非圧縮ヘッダと圧縮ヘッダを組み合わせて完全なパケットを再作成しなければなりません。圧縮されたパケットの場合、送信されたUDP / IPヘッダの部分のみが、「IP識別」および「UDPチェックサム」フィールドです。"
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|1|    group    |        IP identification        | UDP checksum|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|UDP cksm (cont)|           payload  (<1472 bytes)              |\n+-+-+-+-+-+-+-+-+                                               +\n:                              ....                             :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              CRC                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All datagrams belonging to a multi fragment IP packet shall be sent with full headers, in the uncompressed header format. Therefore, only packets that have not been fragmented can be sent with the most significant bit of the compression key set to \"1\".",
      "ja": "マルチフラグメントIPパケットに属するすべてのデータグラムは、非圧縮ヘッダフォーマットにおいて、フルヘッダーとともに送信されなければなりません。そのため、断片化されていないパケットのみを「1」に設定された圧縮キーの最上位ビットを送信することができます。"
    },
    {
      "indent": 3,
      "text": "A 32-bit CRC has also been added to the end of every packet in this scheme to ensure data integrity. It is performed over the entire packet including schema byte, compression key, and either compressed or uncompressed headers. It uses the same algorithm as the MPEG-2 transport stream (ISO/IEC 13818-1). The generator polynomial is:",
      "ja": "32ビットCRCは、データの整合性を確保するために、この方式では、すべてのパケットの末尾に追加されました。これは、スキーマバイト、圧縮キー、および圧縮または非圧縮のいずれかのヘッダを含むパケット全体にわたって行われます。これは、MPEG-2トランスポートストリーム（ISO / IEC 13818-1）と同じアルゴリズムを使用します。生成多項式は次のようになります。"
    },
    {
      "indent": 3,
      "text": "1 + D + D2 + D4 + D5 + D7 + D8 + D10 + D11 + D12 + D16 + D22 + D23 + D26 + D32",
      "ja": "1 + D + D2 + D4 + D5 + D7 + D8 + D10 + D11 + D12 + D16 + D22 + D23 + D26 + D32"
    },
    {
      "indent": 3,
      "text": "As in the ISO/IEC 13818-1 specification, the initial state of the sum is 0xFFFFFFFF. This is not the same algorithm used by Ethernet. This CRC provides a final check for damaged datagrams that span FEC bundles or were not properly corrected by FEC.",
      "ja": "ISO / IEC 13818-1規格のように、和の初期状態は0xFFFFFFFFのです。これは、イーサネットで使用されるのと同じアルゴリズムではありません。このCRCは、FECバンドルをまたがるか、適切にFECによって訂正されていない破損したデータグラムの最終チェックを提供します。"
    },
    {
      "indent": 0,
      "text": "4. Addressing Considerations",
      "section_title": true,
      "ja": "4.アドレス指定の考慮事項"
    },
    {
      "indent": 3,
      "text": "The addressing of IP packets should adhere to existing standards in this area. The inclusion of an appropriate source address is needed to ensure the receiving client can distinguish between sources and thus services if multiple hosts are sharing an insertion point and NABTS packet address.",
      "ja": "IPパケットのアドレッシング、この領域内の既存の標準に準拠しなければなりません。適切なソースアドレスを含めることは、複数のホストが挿入ポイントとNABTSパケットアドレスを共有している場合、受信クライアントは、ソース、従ってサービスを区別できることを確認するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "NABTS packet addressing is not regulated or standardized and requires care to ensure that unrelated services on the same channel are not broadcasting with the same packet address. This could occur due to multiple possible NABTS insertion sites, including show production, network redistribution, regional operator, and local operator.",
      "ja": "NABTSパケットのアドレス指定は、規制や標準化と同じチャンネルに関係のないサービスが同じパケットアドレスをブロードキャストしないように注意が必要ですされていません。これは、番組制作、ネットワークの再分配、地域の事業者、およびローカルオペレータを含む複数の可能NABTS挿入部位に発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Traditionally, the marketplace has recognized this concern and made amicable arrangements for the distribution of these addresses for each channel.",
      "ja": "伝統的に、市場はこの問題を認識し、各チャネルのこれらのアドレスの分配のための友好的な手配をしました。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA will register new schemas on a \"First Come First Served\" basis [RFC 2434]. Anyone can register a scheme, so long as they provide a point of contact and a brief description. The scheme number will be assigned by IANA. Registrants are encouraged to publish complete specifications for new schemas (preferably as standards-track RFCs), but this is not required.",
      "ja": "IANAは、「まず第一に役立っ是非」基礎[RFC 2434]で新しいスキーマを登録します。誰もが限り、彼らが接触し、簡単な説明のポイントを提供するよう、スキームを登録することができます。スキーム番号は、IANAによって割り当てられます。登録者は、（好ましくは標準トラックRFCとして）新しいスキーマの完全な仕様を公開することが奨励されているが、これは必須ではありません。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "As with any broadcast network, there are security issues due to the accessibility of data. It is assumed that the responsibility for securing data lies in other protocol layers, including the IP Security (IPSEC) protocol suite, Transport Layer Security (TLS) protocols, as well as application layer protocols appropriate for a broadcast-only network.",
      "ja": "任意の放送ネットワークと同様に、データのアクセスに起因するセキュリティ上の問題があります。これは、データを保護するための責任はIPセキュリティ（IPSEC）プロトコルスイートを含む他のプロトコル層であることが想定され、トランスポート層セキュリティ（TLS）プロトコルだけでなく、放送専用のネットワークに適したアプリケーション層プロトコル。"
    },
    {
      "indent": 0,
      "text": "7. Conclusions",
      "section_title": true,
      "ja": "7、結論"
    },
    {
      "indent": 3,
      "text": "This document provides a method for broadcasting Internet data over a television signal for reception by client devices. With an appropriate broadcast content model, this will become an attractive method of providing data services to end users. By using existing standards and a layered protocol approach, this document has also provided a model for data transmission on unidirectional and broadcast networks.",
      "ja": "この文書では、クライアントデバイスによって受信するテレビ信号を介してインターネットデータを放送するための方法を提供します。適切な放送コンテンツモデルでは、これは、エンドユーザにデータサービスを提供する魅力的な方法となります。既存の規格およびプロトコル階層アプローチを使用して、この文書はまた、単方向放送ネットワーク上のデータ伝送のためのモデルを提供しました。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgements",
      "section_title": true,
      "ja": "8.謝辞"
    },
    {
      "indent": 3,
      "text": "The description of the FEC in Appendix A is taken from a document prepared by Trevor Dee of Norpak Corporation. Dean Blackketter of WebTV Networks, Inc., edited the final draft of this document.",
      "ja": "付録AにおけるFECの説明はNorpak社のトレバーディーによって作成された文書から取られます。ウェブTVネットワークス社のディーンBlackketterは、この文書の最終草案を編集しました。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 3,
      "text": "[1] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[1]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[2] Deering, S., \"Host Extensions for IP Multicasting\", STD 5, RFC 1112, August 1989.",
      "ja": "[2]デアリング、S.、 \"IPマルチキャスティングのためのホスト拡大\"、STD 5、RFC 1112、1989年8月。"
    },
    {
      "indent": 3,
      "text": "[3] EIA-516, \"Joint EIA/CVCC Recommended Practice for Teletext: North American Basic Teletext Specification (NABTS)\" Washington: Electronic Industries Association, c1988",
      "ja": "ワシントン：電子工業会、c1988：[3] EIA-516を、 \"北米基本テレテキスト仕様（NABTS）テレテキストのための練習を推奨共同EIA / CVCC\""
    },
    {
      "indent": 3,
      "text": "[4] International Telecommunications Union Recommendation. ITU-R BT.470-5 (02/98) \"Conventional TV Systems\"",
      "ja": "[4]国際電気通信連合勧告。 ITU-R BT.470-5（02/98） \"従来のテレビシステム\""
    },
    {
      "indent": 3,
      "text": "[5] International Telecommunications Union Recommendation. ITU.R BT.653-2, system C",
      "ja": "[5]国際電気通信連合勧告。 ITU.R BT.653-2、システムC"
    },
    {
      "indent": 3,
      "text": "[6] Jack, Keith. \"Video Demystified: A Handbook for the Digital Engineer, Second Edition,\" San Diego: HighText Pub. c1996.",
      "ja": "[6]ジャック、キース。 「ビデオ詳解：デジタルエンジニアのためのハンドブック、第2版、」サンディエゴ：HighTextパブ。 c1996。"
    },
    {
      "indent": 3,
      "text": "[7] Jacobson, V., \"Compressing TCP/IP Headers for Low-Speed Serial Links\", RFC 1144, February 1990.",
      "ja": "[7]ジェーコブソン、V.、 \"圧縮TCP /低速シリアルリンクのIPヘッダ\"、RFC 1144、1990年2月。"
    },
    {
      "indent": 3,
      "text": "[8] Mortimer, Brian. \"An Error-correction system for the Teletext Transmission in the Case of Transparent Data\" c1989 Department of Mathematics and Statistics, Carleton University, Ottawa Canada",
      "ja": "[8]モーティマー、ブライアン。数学と統計のc1989科、カールトン大学、オタワカナダの「透過データの場合には文字放送の伝送のための誤り訂正システム」"
    },
    {
      "indent": 3,
      "text": "[9] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[9] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[10] Norpak Corporation \"TTX71x Programming Reference Manual\", c1996, Kanata, Ontario, Canada",
      "ja": "[10] Norpak株式会社 \"TTX71xプログラミング・リファレンス・マニュアル\"、c1996、カナタ、オンタリオ、カナダ"
    },
    {
      "indent": 3,
      "text": "[11] Norpak Corporation, \"TES3 EIA-516 NABTS Data Broadcast Encoder Software User's Manual.\" c1996, Kanata, Ontario, Canada",
      "ja": "[11] Norpakコーポレーション、 \"TES3 EIA-516 NABTSデータ放送エンコーダーソフトウェアユーザーズマニュアル。\" c1996、カナタ、オンタリオ、カナダ"
    },
    {
      "indent": 3,
      "text": "[12] Norpak Corporation, \"TES3/GES3 Hardware Manual\" c1996, Kanata, Ontario, Canada",
      "ja": "[12] Norpakコーポレーション、 \"TES3 / GES3ハードウェアマニュアル\" c1996、カナタ、オンタリオ、カナダ"
    },
    {
      "indent": 3,
      "text": "[13] Pretzel, Oliver. \"Correcting Codes and Finite Fields: Student Edition\" OUP, c1996",
      "ja": "[13]プレッツェル、オリバー。 「訂正符号と有限体：学生版」OUP、c1996"
    },
    {
      "indent": 3,
      "text": "[14] Rorabaugh, C. Britton. \"Error Coding Cookbook\" McGraw Hill, c1996",
      "ja": "[14] Rorabaugh、C.ブリトン。マグロウヒル「エラーがクックブックのコーディング」、c1996"
    },
    {
      "indent": 3,
      "text": "[15] Romkey, J., \"A Nonstandard for Transmission of IP Datagrams Over Serial Lines: SLIP\", STD 47, RFC 1055, June 1988.",
      "ja": "[15] Romkey、J.、 \"シリアル回線を介したIPデータグラムの送信のための非標準：SLIP\"、STD 47、RFC 1055、1988年6月。"
    },
    {
      "indent": 3,
      "text": "[16] Recommended Practice for Line 21 Data Service (ANSI/EIA-608-94) (Sept., 1994)",
      "ja": "[16] 21行データサービス（ANSI / EIA-608から94）の推奨プラクティス（9月、1994）"
    },
    {
      "indent": 3,
      "text": "[17] Stevens, W. Richard. \"TCP/IP Illustrated, Volume 1,: The Protocols\" Reading: Addison-Wesley Publishing Company, c1994.",
      "ja": "[17]スティーブンス、W.リチャード。 「TCP / IPイラスト、プロトコル,: 1巻」を読む：アディソン・ウェズリー出版社、c1994。"
    },
    {
      "indent": 0,
      "text": "10. Acronyms",
      "section_title": true,
      "ja": "10.略語"
    },
    {
      "indent": 3,
      "text": "FEC - Forward Error Correction IP - Internet Protocol NABTS - North American Basic Teletext Standard NTSC - National Television Standards Committee NTSC-J - NTSC-Japanese PAL - Phase Alternation Line RFC - Request for Comments SECAM - Sequentiel Couleur Avec Memoire (sequential color with memory) SLIP - Serial Line Internet Protocol TCP - Transmission Control Protocol UDP - User Datagram Protocol VBI - Vertical Blanking Interval WST - World System Teletext",
      "ja": "FEC  - 前方誤り訂正IP  - インターネットプロトコルNABTS  - 北米基本テレテキスト標準NTSC  - ナショナル・テレビジョン標準委員会NTSC-J  -  NTSC  - 日本のPAL  - フェーズ交替ラインRFC  - コメントSECAM依頼 -  SequentielクルールAvecのメモワール（シーケンシャルカラーメモリと）SLIP  - シリアル回線インターネットプロトコルTCP  - 伝送制御プロトコルUDP  - ユーザーデータグラムプロトコルVBI  - 垂直ブランキング期間WST  - 世界システム・テレテキスト"
    },
    {
      "indent": 0,
      "text": "11. Editors' Addresses and Contacts",
      "section_title": true,
      "ja": "11.エディタのアドレスと連絡先"
    },
    {
      "indent": 3,
      "text": "Ruston Panabaker, co-editor Microsoft One Microsoft Way Redmond, WA 98052",
      "ja": "ラストンPanabaker、共同編集者マイクロソフト1マイクロソフト道、レッドモンド、ワシントン98052"
    },
    {
      "indent": 3,
      "text": "EMail: rustonp@microsoft.com",
      "ja": "メールアドレス：rustonp@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Simon Wegerif, co-editor Philips Semiconductors 811 E. Arques Avenue M/S 52, P.O. Box 3409 Sunnyvale, CA 94088-3409",
      "ja": "Wegerifサイモン、共同編集者Philips Semiconductors社811 E.アルクアベニューM / S 52、P。ボックス3409サニーベール、CA 94088から3409"
    },
    {
      "indent": 3,
      "text": "EMail: Simon.Wegerif@sv.sc.philips.com",
      "ja": "メールアドレス：Simon.Wegerif@sv.sc.philips.com"
    },
    {
      "indent": 3,
      "text": "Dan Zigmond, WG Chair WebTV Networks One Microsoft Way Redmond, WA 98052",
      "ja": "ダンZigmond、WG議長のWebTV Networksの1つのマイクロソフト道、レッドモンド、WA 98052"
    },
    {
      "indent": 3,
      "text": "EMail: djz@corp.webtv.net",
      "ja": "メールアドレス：djz@corp.webtv.net"
    },
    {
      "indent": 0,
      "text": "12. : Forward Error Correction Specification",
      "section_title": true,
      "ja": "12.：前方誤り訂正仕様"
    },
    {
      "indent": 3,
      "text": "This FEC is optimized for data carried in the VBI of a television signal. Teletext has been in use for many years and data transmission errors have been categorized into three main types: 1) Randomly distributed single bit errors 2) Loss of lines of NABTS data 3) Burst Errors",
      "ja": "このFECは、テレビジョン信号のVBIで搬送されたデータ用に最適化されています。テレテキストは、長年使用されており、データ伝送エラーは三つの主要なタイプに分類されている：1）ランダムに分布シングルビットエラー2）NABTSデータのラインの損失は3）バースト誤り"
    },
    {
      "indent": 3,
      "text": "The quantity and distribution of these errors is highly variable and dependent on many factors. The FEC is designed to fix all these types of errors.",
      "ja": "これらのエラーの量及び分布は高度に可変であり、多くの要因に依存します。 FECは、エラーのすべてのこれらのタイプを修正するように設計されています。"
    },
    {
      "indent": 0,
      "text": "12.1. Mathematics used in the FEC",
      "section_title": true,
      "ja": "12.1。 FECで使用される数学"
    },
    {
      "indent": 3,
      "text": "Galois fields form the basis for the FEC algorithm presented here. Rather then explain these fields in general, a specific explanation is given of the Galois field used in the FEC algorithm.",
      "ja": "ガロア体は、ここに示さFECアルゴリズムの基礎を形成します。むしろ、その後、一般的にこれらのフィールドを説明し、具体的な説明は、FECアルゴリズムで使用されるガロア体について説明します。"
    },
    {
      "indent": 3,
      "text": "The Galois field used is GF(2^8) with a primitive element alpha of 00011101. This is a set of 256 elements, along with the operations of \"addition\", \"subtraction\", \"division\", and \"multiplication\" on these elements. An 8-bit binary number represents each element.",
      "ja": "使用されるガロア体は、これは、「追加」、「減算」、「分割」の操作と一緒に、256個の要素の集合である00011101.の原始元アルファと（^ 8 2）GFであり、そしてこれらの「乗算」要素。 8ビットの2進数は、各要素を表しています。"
    },
    {
      "indent": 3,
      "text": "The operations of \"addition\" and \"subtraction\" are the same for this Galois field. Both operations are the XOR of two elements. Thus, the \"sum\" of 00011011 and 00000111 is 00011100.",
      "ja": "「追加」および「減算」の動作は、このガロア体のために同じです。両方の操作は二つの要素のXORです。このように、00011011と00000111の「合計は」00011100です。"
    },
    {
      "indent": 3,
      "text": "Division of two elements is done using long division with subtraction operations replaced by XOR. For multiplication, standard long multiplication is used but with the final addition stage replaced with XOR.",
      "ja": "二つの要素の分割は、XORに置き換え減算演算と長い除算を使用して行われます。乗算のために、標準の長乗算がなく、XORに置き換え最終加算段階で使用されています。"
    },
    {
      "indent": 3,
      "text": "All arithmetic in the following FEC is done modulo 100011101; for instance, after you multiply two numbers, you replace the result with its remainder when divided by 100011101. There are 256 values in this field (256 possible remainders), the 8-bit numbers. It is very important to remember that when we write A*B = C, we more accurately imply modulo(A*B) = C.",
      "ja": "次FECのすべての算術演算はモジュロ100011101行われます。あなたは2つの数値を乗算した後100011101.で割ったときに、たとえば、あなたは256個の値は、このフィールド（256の可能余り）、8ビットの数値であり、その余りで結果を置き換えます。 C. =私たちは* Bを書くとき= Cは、我々はより正確にモジュロ（* B）を暗示することを覚えておくことは非常に重要なことです"
    },
    {
      "indent": 3,
      "text": "It is obvious from the above description that multiplication and division is time consuming to perform. Elements of the Galois Field share two important properties with real numbers.",
      "ja": "これは、乗算や除算は時間がかかる実行することであること以上の説明から明らかです。ガロア体の要素は実数で2つの重要な特性を共有します。"
    },
    {
      "indent": 3,
      "text": "A*B = POWERalpha(LOGalpha(A) + LOGalpha(B)) A/B = POWERalpha(LOGalpha(A) - LOGalpha(B))",
      "ja": "*のB = POWERalpha（LOGalpha（A）+ LOGalpha（B））A / B = POWERalpha（LOGalpha（A） -  LOGalpha（B））"
    },
    {
      "indent": 3,
      "text": "The Galois Field is limited to 256 entries so the power and log tables are limited to 256 entries. The addition and subtraction shown is standard so the result must be modulo alpha. Written as a \"C\" expression:",
      "ja": "ガロア体は、電源に256個のエントリに制限され、ログテーブル256個のエントリに制限されています。図示加算と減算は標準であるので、結果はモジュロアルファでなければなりません。 「C」の式のように記述："
    },
    {
      "indent": 3,
      "text": "A*B = apower[alog[A] + alog[B]] A/B = apower[255 + alog[A] - alog[B]]",
      "ja": "*のB = apower [ALOG [A] + ALOG [B] A / B = apower [255 + ALOG [A]  -  ALOG [B]"
    },
    {
      "indent": 3,
      "text": "You may note that alog[A] + alog[B] can be greater than 255 and therefore a modulo operation should be performed. This is not necessary if the power table is extended to 512 entries by repeating the table. The same logic is true for division as shown. The power and log tables are calculated once using the long multiplication shown above.",
      "ja": "あなたは、[A] + ALOG [B]とすることができる255よりも大きく、したがって、モジュロ演算を実行すべきことALOGに注意してもよいです。パワーテーブルはテーブルを繰り返すことにより、512個のエントリに拡張される場合、これは不要です。示されるように同じロジックが分割についても同様です。電源およびログ表は、一度上記のように長い乗算を使用して計算されます。"
    },
    {
      "indent": 0,
      "text": "12.2. Calculating FEC bytes",
      "section_title": true,
      "ja": "12.2。 FECバイトの計算"
    },
    {
      "indent": 3,
      "text": "The FEC algorithm splits a serial stream of data into \"bundles\". These are arranged as 16 packets of 28 bytes when the correction bytes are included. The bundle therefore has 16 horizontal codewords interleaved with 28 vertical codewords. Two sums are calculated for a codeword, S0 and S1. S0 is the sum of all bytes of the codeword each multiplied by alpha to the power of its index in the codeword. S1 is the sum of all bytes of the codeword each multiplied by alpha to the power of three times its index in the codeword. In \"C\" the sum calculations would look like:",
      "ja": "FECアルゴリズムは、「バンドル」へのデータのシリアル・ストリームを分割します。これらは、訂正バイトが含まれている28バイトの16のパケットとして配置されています。バンドルは、従って28個の垂直符号語にインターリーブ16個の水平符号語を有しています。 2人の合計は、コードワード、S0とS1のために計算されています。 S0は、各コードワードにおけるインデックスの電力にアルファで乗算コードワードのすべてのバイトの合計です。 S1は、各コードワードで三回インデックスの電力にアルファで乗算コードワードのすべてのバイトの合計です。 「C」は、和の計算は次のようになります。"
    },
    {
      "indent": 3,
      "text": "Sum0 = 0;\n   Sum1 = 0;\n   For (i = 0;i < m;i++)\n   {\n      if (codeword[i] != 0)\n      {\n         Sum0 = sum0 ^ power[i + alog[codeword[i]]];\n         Sum1 = sum1 ^ power[3*i + alog[codeword[i]]];\n         }\n      }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that the codeword order is different from the packet order. Codeword positions 0 and 1 are the suffix bytes at the end of a packet horizontally or at the end of a column vertically.",
      "ja": "コードワードの順序は、パケットの順序が異なることに注意してください。コードワード位置0と1は、パケットの末尾にサフィックス・バイト水平方向または垂直方向の列の端部です。"
    },
    {
      "indent": 3,
      "text": "When calculating the two FEC bytes, the summation above must produce two sums of zero. All codewords except 0 and 1 are know so the sums for the known codewords can be calculated. Let's call these values tot0 and tot1.",
      "ja": "2つのFECバイトを計算する際に、上記合計がゼロの2点の合計を生成しなければなりません。知られているコードワードのための合計を算出することができるように、0と1を除くすべてのコードワードが知られています。のは、これらの値のTOT0とTOT1を呼ぶことにしましょう。"
    },
    {
      "indent": 3,
      "text": "Sum0 = tot0^power[0+alog[codeword[0]]]^power[1+alog[codeword[1]]] Sum1 = tot1^power[0+alog[codeword[0]]]^power[3+alog[codeword[1]]]",
      "ja": "SUM0 = TOT0 ^電力[0 + ALOG [符号語[0]]] ^電力[1 + ALOG [符号語[1]]] Sum1とTOT1 = ^電力[0 + ALOG [符号語[0]]] ^パワー[3+ ALOG [符号語[1]]]"
    },
    {
      "indent": 3,
      "text": "This gives us two equations with the two unknowns that we can solve:",
      "ja": "これは、私たちが解決することができる2つの未知数を持つ2つの方程式が得られます。"
    },
    {
      "indent": 3,
      "text": "codeword[1] = power[255+alog[tot0^tot1]-alog[power[1]^power[3]]] codeword[0] = tot0^power[alog[codeword[1]]+alog[power[1]]]",
      "ja": "コードワード[1] =電力[255 + ALOG [TOT0 ^ TOT1] -alog [電力[1] ^電力[3]]]コードワード[0] = TOT0 ^電力[ALOG [符号語は、[1] + [電源をALOG 1]]]"
    },
    {
      "indent": 0,
      "text": "12.3. Correcting Errors",
      "section_title": true,
      "ja": "12.3。エラーの修正"
    },
    {
      "indent": 3,
      "text": "This section describes the procedure for detecting and correcting\nerrors using the FEC data calculated above.  Upon reception, we begin\nby rebuilding the bundle.  This is perhaps the most important part of\nthe procedure because if the bundle is not built correctly it cannot\npossibly correct any errors.  The continuity index is used to\ndetermine the order of the packets and if any packets are missing\n(not captured by the hardware).  The recommendation, when building\nthe bundle, is to convert the bundle from packet order to codeword\norder.  This conversion will simplify the codeword calculations. This\nis done by taking the last byte of a packet and making it the second\nbyte of the codeword and taking the second last byte of a packet and\nmaking it the first byte of a codeword.  Also the packet with\ncontinuity index 15 becomes codeword position one and the packet with\ncontinuity index 14 becomes codeword position zero.  The same FEC is\nused regardless of the number of bytes in the codeword.  So let's\nthink of the codewords as an array codeword[vert][hor] where vert is\n16 packets and hor is 28.  Each byte in the array is protected by\nboth a horizontal and a vertical codeword.  For each of the\ncodewords, the sums must be calculated. If both the sums for a\ncodeword are zero then no errors have been detected for that\ncodeword.  Otherwise, an error has been detected and further steps\nneed to be taken to see if the error can be corrected.  In \"C\" the\nhorizontal summation would look like: for (i = 0; i < 16; i++)\n{\n   sum0 = 0;\n   sum1 = 0;\n   for (j = 0;j < hor;j++)\n   {\n      if (codeword[i][j] != 0)\n      {\n         sum0 = sum0 ^ power[j + alog[codeword[i][j]];\n         sum1 = sum1 ^ power[3*j + alog[codeword[i][j]];\n      }\n   }\n   if ((sum0 != 0) || (sum1 != 0))\n   {\n      Try Correcting Packet\n   }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Similarly, vertical looks like:",
      "ja": "同様に、垂直方向のルックスが好き："
    },
    {
      "indent": 3,
      "text": "for (j = 0;i < hor;i++)\n{\n   sum0 = 0;\n   sum1 = 0;\n   for (i = 0;i < 16;i++)\n   {\n      if (codeword[i][j] != 0)\n      {\n         sum0 = sum0 ^ power[i + alog[codeword[i][j]];\n         sum1 = sum1 ^ power[3*i + alog[codeword[i][j]];\n      }\n   }\n   if ((sum0 != 0) || (sum1 != 0))\n   {\n      Try Correcting Column\n   }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "12.4. Correction Schemes",
      "section_title": true,
      "ja": "12.4。訂正方式"
    },
    {
      "indent": 3,
      "text": "This FEC provides four possible corrections: 1) Single bit correction in codeword. All single bit errors. 2) Double bit correction in a codeword. Most two-bit errors. 3) Single byte correction in a codeword. All single-byte errors. 4) Packet replacement. One or two missing packets from a bundle.",
      "ja": "コードワード1）シングルビット訂正：このFECは、四つの可能な修正を行っています。すべてのシングルビットエラー。符号語2）ダブルビット修正。ほとんどの2ビットエラー。コードワードで3）シングルバイト補正。すべてのシングルバイト・エラー。 4）パケット交換。一つまたはバンドルからのパケットが欠落して2。"
    },
    {
      "indent": 0,
      "text": "12.4.1. Single Bit Correction",
      "section_title": true,
      "ja": "12.4.1。シングルビット訂正"
    },
    {
      "indent": 3,
      "text": "When correcting a single-bit in a codeword, the byte and bit position must be calculated. The equations are:",
      "ja": "符号語内の単一ビットを修正するとき、バイト及びビット位置を計算しなければなりません。方程式は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Byte = 1/2LOGalpha(S1/S0) Bit = 8LOGalpha(S0/POWERalpha(Byte))",
      "ja": "バイト= 1 / 2LOGalpha（S1 / S0）ビット= 8LOGalpha（S0 / POWERalpha（バイト））"
    },
    {
      "indent": 3,
      "text": "In \"C\" this is written:",
      "ja": "「C」で、これは書かれています："
    },
    {
      "indent": 3,
      "text": "Byte = alog[power[255 + alog[sum1] - alog[sum0]]];\nif (Byte & 1)\n   Byte = Byte + 255;\nByte = Byte >> 1;\nBit = alog[power[255 + alog[sum0] - Byte]] << 3;\nwhile (Bit > 255)\n   Bit = Bit - 255;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The error is correctable if Byte is less than the number of bytes in the codeword and Bit is less than eight. For this math to be valid both sum0 and sum1 must be non-zero. The codeword is corrected by:",
      "ja": "バイトが8未満であるコードワードとビットのバイト数より少ない場合は、エラーが訂正可能です。この数学を有効にするにはSUM0とSUM1の両方が非ゼロでなければなりません。コードワードが補正されます。"
    },
    {
      "indent": 3,
      "text": "codeword[Byte] = codeword[Byte] ^ (1 << Bit);",
      "ja": "コードワード[バイト] =符号語[バイト] ^（1 <<ビット）。"
    },
    {
      "indent": 0,
      "text": "12.4.2. Double Bit Correction",
      "section_title": true,
      "ja": "12.4.2。ダブルビット訂正"
    },
    {
      "indent": 3,
      "text": "Double bit correction is much more complex than single bit correction for two reasons. First, not all double bit errors are deterministic. That is two different bit patterns can generate the same sums. Second, the solution is iterative. To find two bit errors you assume one bit in error and then solve for the second error as a single bit error.",
      "ja": "ダブルビット修正ははるかに複雑な二つの理由のための単一ビット訂正よりです。まず、すべてのダブルビットエラーは決定されています。すなわち、2つの異なるビットパターンが同一の和を生成することが可能です。第二に、解決策は反復的です。 2ビットエラーを見つけるには、エラーで1ビットを想定して、シングルビットエラーのような第2のエラーについて解きます。"
    },
    {
      "indent": 3,
      "text": "The procedure is to iteratively move through the bits of the codeword changing each bit's state. The new sums are calculated for the modified codeword. Then the single bit calculation above determines if this is the correct solution. If not, the bit is restored and the next bit is tried.",
      "ja": "手順は反復各ビットの状態を変更するコードワードのビットを移動することです。新しい和が変更されたコードワードに対して計算されています。これが正解である場合、上記シングルビット演算が決定します。そうでない場合、ビットが復元され、次のビットが試されます。"
    },
    {
      "indent": 3,
      "text": "For a long codeword, this can involve many calculations. However, tricks can speed the process. For example, the vertical sums give a strong indication of which bytes are in error horizontally. Bits in other bytes need not be tried.",
      "ja": "長いコードワードの場合、これは多くの計算を含むことができます。しかし、トリックは、プロセスを高速化することができます。例えば、垂直合計バイトが水平エラーであるの強力な指標を与えます。他のバイトのビットが試される必要がありません。"
    },
    {
      "indent": 0,
      "text": "12.4.3. Single Byte Correction",
      "section_title": true,
      "ja": "12.4.3。シングルバイト・修正"
    },
    {
      "indent": 3,
      "text": "For single byte correction, the byte position and bits to correct must be calculated. The equations are:",
      "ja": "単一バイトの補正のために、補正するバイト位置のビットを計算しなければなりません。方程式は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Byte = 1/2*LOGalpha(S1/S0) Mask = S0/POWERalpha[Byte]",
      "ja": "バイト= 1/2 * LOGalpha（S1 / S0）= S0 / POWERalpha [バイト]マスク"
    },
    {
      "indent": 3,
      "text": "Notice that the byte position is the same calculation as for single bit correction. The mask will allow more than one bit in the byte to be corrected. In \"C\" the mask calculation looks like:",
      "ja": "バイト位置は、単一ビット補正のと同じ計算であることに注意してください。マスクは、バイト内の複数のビットを修正することができるようになります。 「C」は、マスクの計算は次のようになります。"
    },
    {
      "indent": 3,
      "text": "Mask = power[255 + alog[sum0] - Byte]",
      "ja": "マスク=電力[255 + ALOG [SUM0]  - バイト]"
    },
    {
      "indent": 3,
      "text": "Both sum0 and sum1 must be non-zero for the calculations to be valid. The Byte value must be less than the codeword length but Mask can be any value. This corrects the byte in the codeword by:",
      "ja": "SUM0とSUM1の両方が計算が有効であるために非ゼロでなければなりません。バイト値は、符号語の長さ未満でなければならないが、マスクは、任意の値とすることができます。これは、コードワードによってでバイトを修正します。"
    },
    {
      "indent": 3,
      "text": "Codeword[Byte] = Codeword[Byte] ^ Mask",
      "ja": "コードワード[バイト] =コードワード[バイト] ^マスク"
    },
    {
      "indent": 0,
      "text": "12.4.4. Packet Replacement",
      "section_title": true,
      "ja": "12.4.4。パケット交換"
    },
    {
      "indent": 3,
      "text": "If a packet is missing, as determined by the continuity index, then its byte position is known and does not need to be calculated. The formula for single packet replacement is therefore the same as for the Mask calculation of single byte correction. Instead of XORing an existing byte with the Mask, the Mask replaces the missing codeword position:",
      "ja": "パケットが欠落している場合は、継続性の指標によって決定されるように、そのバイト位置が知られており、計算する必要はありません。単一のパケット交換のための式は、したがって、単一バイト訂正のマスク演算の場合と同じです。代わりにマスクを持つ既存のバイトをXORの、マスクが不足しているコードワードの位置を置き換えます。"
    },
    {
      "indent": 3,
      "text": "Codeword[Byte] = Mask",
      "ja": "コードワード[バイト] =マスク"
    },
    {
      "indent": 3,
      "text": "When two packets are missing, both the codeword positions are known by the continuity index. This again gives two equations with two unknowns, which is solved to give the following equations. Mask2 = POWERalpha(2*Byte1)*S0+S1",
      "ja": "2つのパケットが失われている場合は、両方のコードワードの位置が継続インデックスによって知られています。これは、再び、次の式を得るために解か2つの未知数を有する2つの方程式が得られます。 MASK2 = POWERalpha（2 *バイト1）* S0 + S1"
    },
    {
      "indent": 3,
      "text": "POWERalpha(2*Byte1+Byte2) +POWERalpha(3*BYTE2) Mask1 = S0 + Mask2*POWERalpha(Byte2)/POWERalpha(BYTE1)",
      "ja": "POWERalpha（2 *バイト1 +バイト2）+ POWERalpha（3 * BYTE2）MASK1 = S0 + MASK2 * POWERalpha（バイト2）/ POWERalpha（BYTE1）"
    },
    {
      "indent": 0,
      "text": "In \"C\" these equations are written:",
      "ja": "「C」では、これらの方程式は書かれています。"
    },
    {
      "indent": 0,
      "text": "if (sum0 == 0)\n{\n   if (sum1 == 0)\n      mask2 = 0;\n   else\n      mask2=power[255+alog[sum1]-alog[power[byte2+2*byte1]\n                  ^power[3*Byte2]]];\n}\nelse\n{\n   if ((a=sum1^power[alog[sum0]+2*byte1]) == 0)\n      mask2 = 0;\n   else\n      mask2 =\npower[255+alog[a]-alog[power[byte2+2*byte1]^power[3*byte2]]];\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "if (mask2 = 0)\n{\n   if (sum0 == 0)\n      mask1 = 0;\n   else\n      mask1 = power[255+alog[sum0]-byte1];\n}\nelse\n{\n   if ((a=sum0^power[alog[mask2] + byte2]) == 0)\n      mask1 = 0;\n   else\n      mask1 = power[255+alog[a]-byte1];\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Notice that, in the code above, care is taken to check for zero values. The missing codeword position can be fixed by:",
      "ja": "上記のコードでは、注意がゼロ値をチェックするために取られる、ことに注意してください。不足しているコードワードの位置は固定ですることができます。"
    },
    {
      "indent": 9,
      "text": "codeword[byte1] = mask1;\ncodeword[byte2] = mask2;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "12.5. FEC Performance Considerations",
      "section_title": true,
      "ja": "12.5。 FECパフォーマンスの考慮事項"
    },
    {
      "indent": 3,
      "text": "The section above shows how to correct the different types of errors. It does not suggest how these corrections may be used in an algorithm to correct a bundle. There are many possible algorithms and the one chosen depends on many variables. These include:",
      "ja": "上記のセクションは、エラーの種類を修正する方法を示しています。これは、これらの修正は、バンドルを修正するためのアルゴリズムで使用することができる方法を示唆していません。そこに多くの可能なアルゴリズムがあり、選ばれた一つは、多くの変数に依存します。これらは、次のとおりです。"
    },
    {
      "indent": 6,
      "text": ". The amount of processing power available . The number of packets per VBI to process . The type of hardware capturing the data . The delivery path of the VBI . How the code is implemented",
      "ja": "。利用可能な電力を処理量。 VBIあたりのパケット数が処理します。データをキャプチャするハードウェアの種類。 VBIの配信パス。どのようにコードが実装されています"
    },
    {
      "indent": 3,
      "text": "As a minimum, it is recommended that the algorithm use single bit or single byte correction for one pass in each direction followed by packet replacement if appropriate. It is possible to do more than one pass of error correction in each direction. The theory is that errors not corrected in the first pass may be corrected in the second pass because error correction in the other direction has removed some errors.",
      "ja": "最小ように、アルゴリズムが適切であれば、パケット交換、続いて各方向に1つのパスのための単一ビットまたは単一バイトの補正を使用することをお勧めします。各方向に誤り訂正の複数のパスを行うことが可能です。理論は、他の方向の誤り訂正が多少の誤差を除去しているので、最初のパスで補正されないエラーが第二のパスにおいて補正することができることです。"
    },
    {
      "indent": 3,
      "text": "In making choices, it is important to remember that the code has several possible states:",
      "ja": "選択をすることで、コードは、いくつかの可能な状態を持っていることを覚えておくことが重要です。"
    },
    {
      "indent": 3,
      "text": "1) Shows codeword as correct and it is.",
      "ja": "1）正しいとコードワードを表示し、それがあります。"
    },
    {
      "indent": 3,
      "text": "2) Shows codeword as correct and it is not (detection failure).",
      "ja": "2）正しいとコードワードを示し、それは（検出失敗）ではありません。"
    },
    {
      "indent": 3,
      "text": "3) Shows codeword as incorrect but cannot correct (detection).",
      "ja": "3）間違ったとして、コードワードを表示しますが、（検出）を補正することはできません。"
    },
    {
      "indent": 3,
      "text": "4) Shows codeword as incorrect and corrects it correctly (correction).",
      "ja": "4）間違ったとして、コードワードを表示し、それを正しく修正（補正）。"
    },
    {
      "indent": 3,
      "text": "5) Shows codeword as incorrect but corrects wrong bits (false correction).",
      "ja": "5）間違ったとして、コードワードを表示しますが、間違ったビット（誤補正）を補正します。"
    },
    {
      "indent": 3,
      "text": "There is actually overlap among the different types of errors. For example, a pair of sums may indicate both a double bit error and a byte error. It is not possible to know at the code level which is correct and which is a false correction. In fact, neither might be correct if both are false corrections.",
      "ja": "実際には異なるタイプのエラーの間で重複があります。例えば、合計一対のダブルビットエラーとバイトエラーの両方を示すことができます。正しく、誤補正されているコード・レベルで知ることはできません。両方が偽の修正であれば実際には、どちらも正しいことはないかもしれません。"
    },
    {
      "indent": 3,
      "text": "If you know something about the types of errors in the delivery channel, you can greatly improve efficiency. If you know that errors are randomly distributed (as in a weak terrestrial broadcast) then single and double bit correction are more powerful than single byte.",
      "ja": "あなたが配信チャネルにおけるエラーの種類について何かを知っているなら、あなたは効率を大幅に向上させることができます。あなたはエラーがランダムに（弱い地上波放送のように）分散していることがわかっている場合は、シングルとダブルビットの補正は、単一のバイトよりも強力です。"
    },
    {
      "indent": 0,
      "text": "13. : Architecture",
      "section_title": true,
      "ja": "13.：建築"
    },
    {
      "indent": 3,
      "text": "The architecture that this document is addressing can be broken down into three areas: insertion, distribution network, and receiving client.",
      "ja": "挿入、流通ネットワーク、および受信側のクライアント：この文書が取り組んでいるアーキテクチャは、次の3つの領域に分けることができます。"
    },
    {
      "indent": 3,
      "text": "The insertion of IP data onto the television signal can occur at any part of the delivery system. A VBI encoder typically accepts a video signal and an asynchronous serial stream of bytes forming framed IP packets as inputs and subsequently packetizes the data onto a selected set of lines using NABTS and an FEC. This composite signal is then modulated with other channels before being broadcast onto the distribution network. Operators further down the distribution chain could then add their own data, to other unused lines, as well. The distribution networks include coax plant, off-air, and analog satellite systems and are primarily unidirectional broadcast networks. They must provide a signal to noise ratio, which is sufficient for FEC to recover any lost data for the broadcast of data to be effective.",
      "ja": "テレビジョン信号にIPデータの挿入は、送達システムの任意の部分で起こり得ます。 VBI符号器は、典型的には、映像信号及び入力としてフレーム化IPパケットを形成するバイトの非同期シリアル・ストリームを受け取り、その後NABTS及びFECを使用した行の選択されたセットにデータをパケット化します。この複合信号は、次に、配信ネットワーク上に放送される前に、他のチャネルで変調されます。さらに流通チェーンダウンオペレータは、次いで同様に、他の未使用ラインに、独自のデータを追加することができます。配信ネットワークは同軸植物、オフ空気、アナログ衛星システムを含み、主に一方向ブロードキャストネットワークです。これらは、FECが有効であるために、データの放送のために失われたデータを回復するために十分である雑音比に対して信号を提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The receiving client must be capable of tuning, NABTS waveform sampling as appropriate, filtering on NABTS addresses as appropriate, forward error correction, unframing, verification of the CRC and decompressing the UDP/IP header if they are compressed. All of the above functions can be carried out in PC software and inexpensive off-the-shelf hardware.",
      "ja": "受信クライアントは、NABTSにフィルタリングするなどの適切な、順方向誤り訂正、unframing、CRCの検証に対処し、それらが圧縮されている場合にUDP / IPヘッダを解凍、適切にチューニング、NABTS波形サンプリングすることができなければなりません。上記の機能のすべてがPCソフトウェアと安価な既製のハードウェアで行うことができます。"
    },
    {
      "indent": 0,
      "text": "14. : Scope of proposed protocols",
      "section_title": true,
      "ja": "14：提案されたプロトコルの範囲"
    },
    {
      "indent": 3,
      "text": "The protocols described in this document are for transmitting IP packets. However, their scope may be extensible to other applications outside this area. Many of the protocols in this document could be implemented on any unidirectional network.",
      "ja": "この文書に記載されているプロトコルは、IPパケットを送信するためのものです。しかしながら、その範囲はこの領域外の他の用途に拡張可能であってもよいです。この文書に記載されているプロトコルの多くは、任意の単方向ネットワーク上で実現することができます。"
    },
    {
      "indent": 3,
      "text": "The unidirectional framing protocol provides encapsulation of IP datagrams on the serial stream, and the compression of the UDP/IP headers reduces the overhead on transmission, thus conserving bandwidth. These two protocols could be widely used on different unidirectional broadcast networks or modulation schemes to efficiently transport any type of packet data. In particular, new versions of Internet protocols can be supported to provide a standardized method of data transport.",
      "ja": "一方向フレーミングプロトコルがシリアル・ストリームのIPデータグラムのカプセル化を提供し、UDP / IPヘッダの圧縮は、このように帯域幅を節約し、伝送のオーバーヘッドを減少させます。これら2つのプロトコルが広く効率的にパケットデータの任意のタイプを輸送するために異なる一方向ブロードキャストネットワーク又は変調方式で使用することができます。具体的には、インターネットプロトコルの新しいバージョンは、データ転送の標準化された方法を提供することで支持することができます。"
    },
    {
      "indent": 0,
      "text": "15. Full Copyright Statement",
      "section_title": true,
      "ja": "15.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1999）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}