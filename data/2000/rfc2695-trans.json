{
  "title": {
    "text": "RFC 2695 - Authentication Mechanisms for ONC RPC",
    "ja": "RFC 2695 - ONC RPCの認証メカニズム"
  },
  "number": 2695,
  "created_at": "2019-10-28 21:20:50.036378+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           A. Chiu\nRequest for Comments: 2695                             Sun Microsystems\nCategory: Informational                                  September 1999",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Authentication Mechanisms for ONC RPC",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1999）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "ABSTRACT",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes two authentication mechanisms created by Sun Microsystems that are commonly used in conjunction with the ONC Remote Procedure Call (ONC RPC Version 2) protocol.",
      "ja": "この文書では、一般的にONCリモートプロシージャコール（ONC RPCバージョン2）プロトコルと組み合わせて使用​​されている、Sun Microsystemsによって作成された2つの認証メカニズムを説明しています。"
    },
    {
      "indent": 0,
      "text": "WARNING",
      "ja": "警告"
    },
    {
      "indent": 3,
      "text": "The DH authentication as defined in Section 2 in this document refers to the authentication mechanism with flavor AUTH_DH currently implemented in ONC RPC. It uses the underlying Diffie-Hellman algorithm for key exchange. The DH authentication defined in this document is flawed due to the selection of a small prime for the BASE field (Section 2.5). To avoid the flaw a new DH authentication mechanism could be defined with a larger prime. However, the new DH authentication would not be interoperable with the existing DH authentication.",
      "ja": "この文書のセクション2で定義されるようにDH認証は、現在ONC RPCで実装風味AUTH_DHとの認証メカニズムを指します。これは、鍵交換のための基礎となるのDiffie-Hellmanアルゴリズムを使用しています。この文書で定義されたDH認証が原因BASEフィールド（2.5節）のための小さなプライムの選択に欠陥があります。新しいDH認証メカニズムが大きくプライムで定義することができ、欠陥を避けるために。しかし、新しいDH認証は、既存のDH認証と相互運用可能ではないでしょう。"
    },
    {
      "indent": 3,
      "text": "As illustrated in [10], a large number of attacks are possible on ONC RPC system services that use non-secure authentication mechanisms. Other secure authentication mechanisms need to be developed for ONC RPC. RFC 2203 describes the RPCSEC_GSS ONC RPC security flavor, a secure authentication mechanism that enables RPC protocols to use Generic Security Service Application Program Interface (RFC 2078) to provide security services, integrity and privacy, that are independent of the underlying security mechanisms.",
      "ja": "[10]に示すように、攻撃の多くは、非セキュアな認証メカニズムを使用ONC RPCシステムサービスに可能です。その他のセキュアな認証メカニズムは、ONC RPC用に開発する必要があります。 RFC 2203は、RPCSEC_GSS ONC RPCセキュリティ風味、基本的なセキュリティメカニズムに依存しないセキュリティサービス、整合性とプライバシーを提供するために、一般的なセキュリティサービスアプリケーションプログラムインターフェイス（RFC 2078）を使用するRPCプロトコルを有効にし、安全な認証メカニズムを説明しています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 6,
      "text": "1. Introduction ............................................... 2\n2. Diffie-Hellman Authentication .............................. 2\n2.1 Naming .................................................... 3\n2.2 DH Authentication Verifiers ............................... 3\n2.3 Nicknames and Clock Synchronization ....................... 5\n2.4 DH Authentication Protocol Specification .................. 5\n2.4.1 The Full Network Name Credential and Verifier (Client) .. 6\n2.4.2 The Nickname Credential and Verifier (Client) ........... 8\n2.4.3 The Nickname Verifier (Server) .......................... 9\n2.5 Diffie-Hellman Encryption ................................. 9\n3. Kerberos-based Authentication ............................. 10\n3.1 Naming ................................................... 11\n3.2 Kerberos-based Authentication Protocol Specification ..... 11\n3.2.1 The Full Network Name Credential and Verifier (Client) . 12\n3.2.2 The Nickname Credential and Verifier (Client) .......... 14\n3.2.3 The Nickname Verifier (Server) ......................... 15\n3.2.4 Kerberos-specific Authentication Status Values ......... 15\n4. Security Considerations ................................... 16\n5. REFERENCES ................................................ 16\n6. AUTHOR'S ADDRESS .......................................... 17\n7. FULL COPYRIGHT STATEMENT ...................................18",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The ONC RPC protocol provides the fields necessary for a client to identify itself to a service, and vice-versa, in each call and reply message. Security and access control mechanisms can be built on top of this message authentication. Several different authentication protocols can be supported.",
      "ja": "ONC RPCプロトコルは、各コールと応答メッセージで、サービスに自分自身を識別するために、クライアントのために必要なフィールド、およびその逆を提供します。セキュリティとアクセス制御メカニズムは、このメッセージ認証の上に構築することができます。いくつかの異なる認証プロトコルをサポートすることができます。"
    },
    {
      "indent": 3,
      "text": "This document specifies two authentication protocols created by Sun Microsystems that are commonly used: Diffie-Hellman (DH) authentication and Kerberos (Version 4) based authentication.",
      "ja": "ディフィー・ヘルマン（DH）認証とKerberos（バージョン4）に基づく認証：この文書では、一般的に使用されている、Sun Microsystemsによって作成された2つの認証プロトコルを指定します。"
    },
    {
      "indent": 3,
      "text": "As a prerequisite to reading this document, the reader is expected to be familiar with [1] and [2]. This document uses terminology and definitions from [1] and [2].",
      "ja": "この原稿の読み取りを前提として、読者が精通であると予想される[1]と[2]。この文書からの用語および定義を使用する[1]と[2]。"
    },
    {
      "indent": 0,
      "text": "2. Diffie-Hellman Authentication",
      "section_title": true,
      "ja": "2.のDiffie-Hellman認証"
    },
    {
      "indent": 3,
      "text": "System authentication (defined in [1]) suffers from some problems. It is very UNIX oriented, and can be easily faked (there is no attempt to provide cryptographically secure authentication).",
      "ja": "（[1]で定義された）システム認証は、いくつかの問題があります。これは、（暗号化された安全な認証を提供する試みはありません）非常にUNIXが指向され、簡単に偽造することができます。"
    },
    {
      "indent": 3,
      "text": "DH authentication was created to address these problems. However, it has been compromised [9] due to the selection of a small length for the prime in the ONC RPC implementation. While the information provided here will be useful for implementors to ensure interoperability with existing applications that use DH authentication, it is strongly recommended that new applications use more secure authentication, and that existing applications that currently use DH authentication migrate to more robust authentication mechanisms.",
      "ja": "DH認証は、これらの問題に対処するために作成されました。しかし、[9]により、ONC RPC実装でプライムするための小さな長さの選択に侵害されています。実装者は、DH認証を使用する既存のアプリケーションとの相互運用性を確保するためにはここを提供される情報は有用であろうが、それは強く、新たなアプリケーションをより安全な認証を使用することをお勧めし、現在DH認証移行するためには、より強固な認証メカニズムを使用している既存のアプリケーションされます。"
    },
    {
      "indent": 0,
      "text": "2.1 Naming",
      "section_title": true,
      "ja": "2.1ネーミング"
    },
    {
      "indent": 3,
      "text": "The client is addressed by a simple string of characters instead of by an operating system specific integer. This string of characters is known as the \"netname\" or network name of the client. The server is not allowed to interpret the contents of the client's name in any other way except to identify the client. Thus, netnames should be unique for every client in the Internet.",
      "ja": "クライアントは、文字の単純な文字列ではなく、オペレーティング・システム固有の整数によって対処されます。この文字列のことは、クライアントの「ネット名」またはネットワーク名として知られています。サーバーは、クライアントを識別する以外、他の方法で、クライアントの名前の内容を解釈することはできません。このように、ネット名は、インターネット内のすべてのクライアントに対して一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "It is up to each operating system's implementation of DH authentication to generate netnames for its users that insure this uniqueness when they call upon remote servers. Operating systems already know how to distinguish users local to their systems. It is usually a simple matter to extend this mechanism to the network. For example, a UNIX(tm) user at Sun with a user ID of 515 might be assigned the following netname: \"unix.515@sun.com\". This netname contains three items that serve to insure it is unique. Going backwards, there is only one naming domain called \"sun.com\" in the Internet. Within this domain, there is only one UNIX(tm) user with user ID 515. However, there may be another user on another operating system, for example VMS, within the same naming domain that, by coincidence, happens to have the same user ID. To insure that these two users can be distinguished we add the operating system name. So one user is \"unix.515@sun.com\" and the other is \"vms.515@sun.com\". The first field is actually a naming method rather than an operating system name. It happens that today there is almost a one-to-one correspondence between naming methods and operating systems. If the world could agree on a naming standard, the first field could be the name of that standard, instead of an operating system name.",
      "ja": "それは彼らがリモートサーバー上に呼び出すときに、この一意性を保証するそのユーザーのためのネット名を生成するために、DH認証の各オペレーティングシステムの実装次第です。オペレーティングシステムは既に、システムのローカルユーザーを識別する方法を知っています。通常、ネットワークにこのメカニズムを拡張することは簡単なことです。 「unix.515@sun.com」：たとえば、515のユーザーIDとSunのUNIX（TM）ユーザーは、以下のネット名を割り当てられることがあります。このネット名は、それが一意である保証するのに役立つ3つの項目が含まれています。後方に行く、インターネットに「sun.com」と呼ばれる唯一の命名ドメインがあります。このドメイン内で、偶然、同じユーザを有することがたまたま同じ命名ドメイン内、例えばVMSのために、別のオペレーティングシステム上の別のユーザが存在してもよい。しかし、ユーザID 515を持つ唯一のUNIX（登録商標）ユーザが存在しますID。これらの2人のユーザーが区別できることを保証するために、我々は、オペレーティングシステムの名前を追加します。だから、一人のユーザーは、「unix.515@sun.com」であり、他は「vms.515@sun.com」です。最初のフィールドは、実際の命名法ではなく、オペレーティングシステム名です。今日の命名方法とオペレーティングシステム間の1対1の対応はほとんどがあることを起こります。世界が命名標準に合意する可能性がある場合、最初のフィールドは、標準の名前の代わりに、オペレーティングシステム名である可能性があります。"
    },
    {
      "indent": 0,
      "text": "2.2 DH Authentication Verifiers",
      "section_title": true,
      "ja": "2.2 DH認証検証者"
    },
    {
      "indent": 3,
      "text": "Unlike System authentication, DH authentication does have a verifier so the server can validate the client's credential (and vice-versa). The contents of this verifier are primarily an encrypted timestamp. The server can decrypt this timestamp, and if it is within an accepted range relative to the current time, then the client must have encrypted it correctly. The only way the client could encrypt it correctly is to know the \"conversation key\" of the RPC session, and if the client knows the conversation key, then it must be the real client.",
      "ja": "システムの認証とは異なり、DH認証は、サーバがクライアントの資格（またはその逆）を検証することができるように検証を持っています。この検証の内容は主に、暗号化されたタイムスタンプです。サーバーは、このタイムスタンプを復号化することができ、それが現在の時刻からの相対許容される範囲内であれば、クライアントはそれを正しく暗号化されている必要があります。クライアントが正しく、それを暗号化することができる唯一の方法は、RPCセッションの「会話キー」を知ることであり、クライアントは会話鍵を知っているならば、それは本当のクライアントである必要があります。"
    },
    {
      "indent": 3,
      "text": "The conversation key is a DES [5] key which the client generates and passes to the server in the first RPC call of a session. The conversation key is encrypted using a public key scheme in this first transaction. The particular public key scheme used in DH authentication is Diffie-Hellman [3] with 192-bit keys. The details of this encryption method are described later.",
      "ja": "会話キーは、クライアントが生成し、セッションの最初のRPCコール内のサーバに渡さDES [5]キーです。会話鍵は、この最初のトランザクションでは、公開鍵方式を使用して暗号化されます。 DH認証に使用される特定の公開鍵方式は、ディフィー - ヘルマン[3] 192ビットのキーです。この暗号化方式の詳細については後述します。"
    },
    {
      "indent": 3,
      "text": "The client and the server need the same notion of the current time in order for all of this to work, perhaps by using the Network Time Protocol [4]. If network time synchronization cannot be guaranteed, then the client can determine the server's time before beginning the conversation using a time request protocol.",
      "ja": "クライアントとサーバは、おそらくネットワーク・タイム・プロトコルを使用することにより、動作するように、このすべてのためには、現在の時刻の同じ概念を必要とする[4]。ネットワーク時刻同期が保証できない場合、クライアントは、時間の要求プロトコルを使用して対話を開始する前に、サーバーの時間を決定することができます。"
    },
    {
      "indent": 3,
      "text": "The way a server determines if a client timestamp is valid is somewhat complicated. For any other transaction but the first, the server just checks for two things:",
      "ja": "サーバは、クライアントのタイムスタンプが有効であるかどうかを判断する方法は多少複雑です。他のトランザクションが、最初の場合は、サーバは、ちょうど2つのものをチェックします。"
    },
    {
      "indent": 3,
      "text": "(1) the timestamp is greater than the one previously seen from the same client. (2) the timestamp has not expired.",
      "ja": "（1）タイムスタンプが以前に同じクライアントから見たものよりも大きいです。 （2）タイムスタンプの有効期限が切れていません。"
    },
    {
      "indent": 3,
      "text": "A timestamp is expired if the server's time is later than the sum of the client's timestamp plus what is known as the client's \"ttl\" (standing for \"time-to-live\" - you can think of this as the lifetime for the client's credential). The \"ttl\" is a number the client passes (encrypted) to the server in its first transaction.",
      "ja": "あなたがクライアントの資格の有効期間と考えることができます - サーバーの時刻がクライアントのタイムスタンプの合計よりもプラス何クライアントの「TTL」として知られている（「生存時間」のために立っている場合、タイムスタンプの有効期限が切れています）。 「TTL」は、最初のトランザクションでは、サーバーへのクライアントが通過する数（暗号化）です。"
    },
    {
      "indent": 3,
      "text": "In the first transaction, the server checks only that the timestamp has not expired. Also, as an added check, the client sends an encrypted item in the first transaction known as the \"ttl verifier\" which must be equal to the time-to-live minus 1, or the server will reject the credential. If either check fails, the server rejects the credential with an authentication status of AUTH_BADCRED, however if the timestamp is earlier than the previous one seen, the server returns an authentication status of AUTH_REJECTEDCRED.",
      "ja": "最初のトランザクションでは、サーバーは、タイムスタンプの有効期限が切れていないことだけをチェックします。また、追加のチェックとして、クライアントは、生存時間マイナス1、または資格を拒否するサーバーと同じでなければなりません「TTLの検証」として知られている最初のトランザクションで暗号化されたアイテムを送信します。いずれかのチェックに失敗した場合、サーバはAUTH_BADCREDの認証ステータスを持つ資格を拒否、しかし、タイムスタンプが見られ、以前のものよりも前である場合、サーバはAUTH_REJECTEDCREDの認証状態を返します。"
    },
    {
      "indent": 3,
      "text": "The client too must check the verifier returned from the server to be sure it is legitimate. The server sends back to the client the timestamp it received from the client, minus one second, encrypted with the conversation key. If the client gets anything different than this, it will reject it, returning an AUTH_INVALIDRESP authentication status to the user.",
      "ja": "クライアントは、あまりにもそれが正当であることを確認するために、サーバから返されたベリファイアをチェックしなければなりません。サーバーは、クライアントは、クライアントから受信したタイムスタンプに送り返し、マイナス1秒、対話鍵で暗号化されました。クライアントはこれよりも異なる何かを取得した場合、それはユーザーにAUTH_INVALIDRESP認証ステータスを返し、それを拒否します。"
    },
    {
      "indent": 0,
      "text": "2.3 Nicknames and Clock Synchronization",
      "section_title": true,
      "ja": "2.3ニックネームとクロック同期"
    },
    {
      "indent": 3,
      "text": "After the first transaction, the server's DH authentication subsystem returns in its verifier to the client an integer \"nickname\" which the client may use in its further transactions instead of passing its netname. The nickname could be an index into a table on the server which stores for each client its netname, decrypted conversation key and ttl.",
      "ja": "最初のトランザクションの後、クライアントはそのネット名を渡すのではなく、そのさらなる取引に使用することができ、クライアントの整数「ニックネーム」への検証で、サーバのDH認証サブシステムに戻ります。ニックネームは、各クライアントのネット名、復号化された会話のキーとTTLのために格納するサーバ上のテーブルへのインデックスである可能性があります。"
    },
    {
      "indent": 3,
      "text": "Though they originally were synchronized, the client's and server's clocks can get out of synchronization again. When this happens the server returns to the client an authentication status of AUTH_REJECTEDVERF at which point the client should attempt to resynchronize.",
      "ja": "彼らはもともと同期したものの、クライアントの、サーバーの時計は再び同期から抜け出すことができます。これは、クライアントが再同期を試みる必要がある時点でAUTH_REJECTEDVERFのクライアント認証ステータスにサーバーが返すが発生した場合。"
    },
    {
      "indent": 3,
      "text": "A client may also get an AUTH_BADCRED error when using a nickname that was previously valid. The reason is that the server's nickname table is a limited size, and it may flush entries whenever it wants. A client should resend its original full name credential in this case and the server will give it a new nickname. If a server crashes, the entire nickname table gets flushed, and all clients will have to resend their original credentials.",
      "ja": "以前に有効であったニックネームを使用した場合、クライアントにもAUTH_BADCREDエラーが出ることがあります。その理由は、サーバーのニックネームテーブルが限られたサイズであり、それが望んでいる時はいつでも、それはエントリをフラッシュすることです。クライアントは、この場合には、元のフルネームの資格を再送信する必要がありますし、サーバーはそれを新しいニックネームを与えるだろう。サーバーがクラッシュした場合、ニックネームテーブル全体がフラッシュされます、そして、すべてのクライアントは、元の資格情報を再送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4 DH Authentication Protocol Specification",
      "section_title": true,
      "ja": "2.4 DH認証プロトコルの仕様"
    },
    {
      "indent": 3,
      "text": "There are two kinds of credentials: one in which the client uses its full network name, and one in which it uses its \"nickname\" (just an unsigned integer) given to it by the server. The client must use its fullname in its first transaction with the server, in which the server will return to the client its nickname. The client may use its nickname in all further transactions with the server. There is no requirement to use the nickname, but it is wise to use it for performance reasons.",
      "ja": "クライアントは、その完全なネットワーク名を使用してその一つで、それは、サーバによってそれに与えられたその「ニックネーム」（単なる符号なし整数）を使用した1：2の資格情報の種類があります。クライアントは、サーバがクライアントにそのニックネームに戻りますするサーバーとの最初の取引でそのフルネームを使用する必要があります。クライアントは、サーバーとのすべての更なるトランザクションでそのニックネームを使用することができます。そこニックネームを使用するための要件はありませんが、パフォーマンス上の理由のためにそれを使用するのが賢明です。"
    },
    {
      "indent": 3,
      "text": "The following definitions are used for describing the protocol:",
      "ja": "以下の定義は、プロトコルを記述するために使用されます。"
    },
    {
      "indent": 6,
      "text": "enum authdh_namekind { ADN_FULLNAME = 0, ADN_NICKNAME = 1 };",
      "ja": "列挙authdh_namekind {ADN_FULLNAME = 0、ADN_NICKNAME = 1}。"
    },
    {
      "indent": 6,
      "text": "typedef opaque des_block[8]; /* 64-bit block of encrypted data */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "const MAXNETNAMELEN = 255;   /* maximum length of a netname */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The flavor used for all DH authentication credentials and verifiers\nis \"AUTH_DH\", with the numerical value 3.  The opaque data\nconstituting the client credential encodes the following structure: union authdh_cred switch (authdh_namekind namekind) {\ncase ADN_FULLNAME:\n   authdh_fullname fullname;\ncase ADN_NICKNAME:\n   authdh_nickname nickname;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The opaque data constituting a verifier that accompanies a client credential encodes the following structure:",
      "ja": "クライアントの信任状を伴う検証を構成する不透明なデータは、以下の構造をコードします。"
    },
    {
      "indent": 3,
      "text": "union authdh_verf switch (authdh_namekind namekind) {\ncase ADN_FULLNAME:\n   authdh_fullname_verf fullname_verf;\ncase ADN_NICKNAME:\n   authdh_nickname_verf nickname_verf;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The opaque data constituting a verifier returned by a server in response to a client request encodes the following structure:",
      "ja": "クライアント要求に応答してサーバによって返された検証を構成する不透明なデータは、以下の構造をコードします。"
    },
    {
      "indent": 3,
      "text": "struct authdh_server_verf;",
      "ja": "構造体authdh_server_verf。"
    },
    {
      "indent": 3,
      "text": "These structures are described in detail below.",
      "ja": "これらの構造は、以下に詳細に記載されています。"
    },
    {
      "indent": 0,
      "text": "2.4.1 The Full Network Name Credential and Verifier (Client)",
      "section_title": true,
      "ja": "2.4.1ザ・フル・ネットワーク名資格と検証（クライアント）"
    },
    {
      "indent": 3,
      "text": "First, the client creates a conversation key for the session. Next, the client fills out the following structure:",
      "ja": "まず、クライアントは、セッションのための会話のキーを作成します。次に、クライアントは、次のような構造を記入します："
    },
    {
      "indent": 6,
      "text": "+---------------------------------------------------------------+\n|   timestamp   |  timestamp    |               |               |\n|   seconds     | micro seconds |      ttl      |   ttl - 1     |\n|   32 bits     |    32 bits    |    32 bits    |   32 bits     |\n+---------------------------------------------------------------+\n0              31              63              95             127",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields are stored in XDR (external data representation) format. The timestamp encodes the time since midnight, January 1, 1970. These 128 bits of data are then encrypted in the DES CBC mode, using the conversation key for the session, and with an initialization vector of 0. This yields:",
      "ja": "フィールドは、XDR（外部データ表現）形式で格納されます。タイムスタンプは、データのこれらの128ビットは、セッションのための会話キーを使用して、DES CBCモードで暗号化されている1970年1月1日、午前零時からの時間をコードし、および0.1の初期化ベクトルを有するこの収率："
    },
    {
      "indent": 6,
      "text": "+---------------------------------------------------------------+\n|               T               |               |               |\n|     T1               T2       |      W1       |     W2        |\n|   32 bits     |    32 bits    |    32 bits    |   32 bits     |\n+---------------------------------------------------------------+\n0              31              63              95             127",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where T1, T2, W1, and W2 are all 32-bit quantities, and have some correspondence to the original quantities occupying their positions, but are now interdependent on each other for proper decryption. The 64 bit sequence comprising T1 and T2 is denoted by T.",
      "ja": "ここで、T1、T2、W1及びW2は、全ての32ビット量であり、それらの位置を占める元の量に一部対応しているが、今適切な復号化のためにお互いに相互依存しています。 T1およびT2を含む64ビット・シーケンスは、Tで表され"
    },
    {
      "indent": 3,
      "text": "The full network name credential is represented as follows using XDR notation:",
      "ja": "XDR表記法を使用して次のように完全なネットワーク名資格が表されます。"
    },
    {
      "indent": 3,
      "text": "struct authdh_fullname {\n   string name<MAXNETNAMELEN>;  /* netname of client             */\n   des_block key;               /* encrypted conversation key    */\n   opaque w1[4];                /* W1                            */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The conversation key is encrypted using the \"common key\" using the ECB mode. The common key is a DES key that is derived from the Diffie-Hellman public and private keys, and is described later.",
      "ja": "会話鍵は、ECBモードを使用して「共通鍵」を使用して暗号化されています。共通鍵のDiffie-Hellman公開鍵と秘密鍵から導出されたDESキーであり、後に説明されます。"
    },
    {
      "indent": 3,
      "text": "The verifier is represented as follows:",
      "ja": "次のように検証が表されます。"
    },
    {
      "indent": 3,
      "text": "struct authdh_fullname_verf {\n   des_block timestamp;         /* T (the 64 bits of T1 and T2) */\n   opaque w2[4];                /* W2                           */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that all of the encrypted quantities (key, w1, w2, timestamp) in the above structures are opaque.",
      "ja": "上記構成において、暗号化量（鍵、W1、W2、タイムスタンプ）の全てが不透明であることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The fullname credential and its associated verifier together contain the network name of the client, an encrypted conversation key, the ttl, a timestamp, and a ttl verifier that is one less than the ttl. The ttl is actually the lifetime for the credential. The server will accept the credential if the current server time is \"within\" the time indicated in the timestamp plus the ttl. Otherwise, the server rejects the credential with an authentication status of AUTH_BADCRED. One way to insure that requests are not replayed would be for the server to insist that timestamps are greater than the previous one seen, unless it is the first transaction. If the timestamp is earlier than the previous one seen, the server returns an authentication status of AUTH_REJECTEDCRED.",
      "ja": "フルネーム資格とそれに関連する検証は一緒に、暗号化された対話鍵、TTL、タイムスタンプ、およびTTLよりも1小さいTTL検証をクライアントのネットワーク名が含まれています。 TTLは実際に資格の有効期間です。現在のサーバー時刻がタイムスタンププラスTTLで示された時間「以内」であれば、サーバーは証明書を受け入れます。そうしないと、サーバーはAUTH_BADCREDの認証ステータスを持つ資格を拒否します。要求が再生されていないことを保証するための一つの方法は、それが最初のトランザクションでない限り、タイムスタンプは、見て、以前のものより大きいことを主張するために、サーバーのためになります。タイムスタンプが見られ、以前のものより前の場合、サーバーはAUTH_REJECTEDCREDの認証状態を返します。"
    },
    {
      "indent": 3,
      "text": "The server returns a authdh_server_verf structure, which is described in detail below. This structure contains a \"nickname\", which may be used for subsequent requests in the current conversation.",
      "ja": "サーバは、以下に詳細に記載されてauthdh_server_verf構造を返します。この構造は、現在の会話の中で後続の要求のために使用することができる「ニックネーム」を、含まれています。"
    },
    {
      "indent": 0,
      "text": "2.4.2 The Nickname Credential and Verifier (Client)",
      "section_title": true,
      "ja": "ニックネーム資格および2.4.2検証（クライアント）"
    },
    {
      "indent": 3,
      "text": "In transactions following the first, the client may use the shorter nickname credential and verifier for efficiency. First, the client fills out the following structure:",
      "ja": "最初に以下の取引では、クライアントは、効率のために短いニックネーム資格とベリファイアを使用することができます。まず、クライアントは、次のような構造を記入します："
    },
    {
      "indent": 6,
      "text": "+-------------------------------+\n|   timestamp   |  timestamp    |\n|   seconds     | micro seconds |\n|   32 bits     |    32 bits    |\n+-------------------------------+\n0              31              63",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields are stored in XDR (external data representation) format. These 64 bits of data are then encrypted in the DES ECB mode, using the conversation key for the session. This yields:",
      "ja": "フィールドは、XDR（外部データ表現）形式で格納されます。これらのデータの64ビットは、セッションのための対話鍵を使用して、DES ECBモードで暗号化されています。この利回り："
    },
    {
      "indent": 6,
      "text": "+-------------------------------+\n|     (T1)      |      (T2)     |\n|               T               |\n|             64 bits           |\n+-------------------------------+\n0              31              63",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The nickname credential is represented as follows using XDR notation:",
      "ja": "XDR表記法を使用して次のようにニックネーム資格が表されます。"
    },
    {
      "indent": 3,
      "text": "struct authdh_nickname {\n   unsigned int nickname;       /* nickname returned by server   */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The nickname verifier is represented as follows using XDR notation:",
      "ja": "XDR表記法を使用して次のようにニックネーム検証が表されます。"
    },
    {
      "indent": 3,
      "text": "struct authdh_nickname_verf {\n   des_block timestamp;         /* T (the 64 bits of T1 and T2) */\n   opaque w[4];                 /* Set to zero                  */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The nickname credential may be reject by the server for several reasons. An authentication status of AUTH_BADCRED indicates that the nickname is no longer valid. The client should retry the request using the fullname credential. AUTH_REJECTEDVERF indicates that the nickname verifier is not valid. Again, the client should retry the request using the fullname credential.",
      "ja": "ニックネーム資格はいくつかの理由のために、サーバによって拒否することができます。 AUTH_BADCREDの認証ステータスは、ニックネームはもはや有効であることを示していません。クライアントは、フルネームの資格情報を使用して要求を再試行する必要があります。 AUTH_REJECTEDVERFは、ニックネーム検証が有効でないことを示しています。ここでも、クライアントは、フルネームの資格情報を使用して要求を再試行する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4.3 The Nickname Verifier (Server)",
      "section_title": true,
      "ja": "2.4.3ニックネーム検証（サーバー）"
    },
    {
      "indent": 3,
      "text": "The server never returns a credential. It returns only one kind of verifier, i.e., the nickname verifier. This has the following XDR representation:",
      "ja": "サーバーは、証明書を返すことはありません。それは、検証の一種類、即ち、ニックネーム検証を返します。これは、次のXDR表現があります。"
    },
    {
      "indent": 3,
      "text": "struct authdh_server_verf {\n   des_block timestamp_verf; /* timestamp verifier (encrypted)    */\n   unsigned int nickname;    /* new client nickname (unencrypted) */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The timestamp verifier is constructed in exactly the same way as the client nickname credential. The server sets the timestamp value to the value the client sent minus one second and encrypts it in DES ECB mode using the conversation key. The server also sends the client a nickname to be used in future transactions (unencrypted).",
      "ja": "タイムスタンプの検証は、クライアントのニックネーム資格とまったく同じように構成されています。サーバーは、クライアントが1秒減じたもの送られた値にタイムスタンプ値を設定し、対話鍵を使用してDESのECBモードでそれを暗号化します。また、サーバはクライアントに将来の取引（暗号化されていない）で使用するニックネームを送信します。"
    },
    {
      "indent": 0,
      "text": "2.5 Diffie-Hellman Encryption",
      "section_title": true,
      "ja": "2.5のDiffie-Hellmanの暗号化"
    },
    {
      "indent": 3,
      "text": "In this scheme, there are two constants \"BASE\" and \"MODULUS\" [3]. The particular values Sun has chosen for these for the DH authentication protocol are:",
      "ja": "この方式では、ある2つの定数「BASE」と「モジュラス」[3]。 SunはDH認証プロトコルのためにこれらのために選択した特定の値は、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "const BASE = 3;\nconst MODULUS = \"d4a0ba0250b6fd2ec626e7efd637df76c716e22d0944b88b\";",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that the modulus is represented above as a hexadecimal string.",
      "ja": "弾性率は16進数の文字列として上記に示されていることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The way this scheme works is best explained by an example. Suppose there are two people \"A\" and \"B\" who want to send encrypted messages to each other. So, A and B both generate \"secret\" keys at random which they do not reveal to anyone. Let these keys be represented as SK(A) and SK(B). They also publish in a public directory their \"public\" keys. These keys are computed as follows:",
      "ja": "この方式が機能する方法は、最良の例で説明されています。お互いに暗号化されたメッセージを送信したい2人の「A」と「B」があるとします。だから、AとBの両方が、彼らが誰にも明らかにしていませんランダムに「秘密」鍵を生成します。これらのキーは、SK（A）とSK（B）のように表すことがしてみましょう。彼らはまた、公開ディレクトリに自分の「パブリック」キーを発行しています。次のようにこれらのキーは、計算されます。"
    },
    {
      "indent": 6,
      "text": "PK(A) = ( BASE ** SK(A) ) mod MODULUS PK(B) = ( BASE ** SK(B) ) mod MODULUS",
      "ja": "PK（A）=（BASE ** SK（A））MOD係数PK（B）=（BASE ** SK（B））MODモジュラス"
    },
    {
      "indent": 3,
      "text": "The \"**\" notation is used here to represent exponentiation. Now, both A and B can arrive at the \"common\" key between them, represented here as CK(A, B), without revealing their secret keys.",
      "ja": "「**」の表記は、べき乗を表すためにここで使用されます。さて、AとBの両方が彼らの秘密鍵を明らかにすることなく、CK（A、B）ただしここでは、それらの間の「共通」キー、に到着することができます。"
    },
    {
      "indent": 3,
      "text": "A computes:",
      "ja": "計算します。"
    },
    {
      "indent": 6,
      "text": "CK(A, B) = ( PK(B) ** SK(A)) mod MODULUS",
      "ja": "CK（A、B）=（PK（B）** SK（A））MODモジュラス"
    },
    {
      "indent": 3,
      "text": "while B computes:",
      "ja": "Bは、計算中："
    },
    {
      "indent": 6,
      "text": "CK(A, B) = ( PK(A) ** SK(B)) mod MODULUS",
      "ja": "CK（A、B）=（PK（A）** SK（B））MODモジュラス"
    },
    {
      "indent": 3,
      "text": "These two can be shown to be equivalent:",
      "ja": "これら二つは同等であることを示すことができます。"
    },
    {
      "indent": 6,
      "text": "(PK(B) ** SK(A)) mod MODULUS = (PK(A) ** SK(B)) mod MODULUS",
      "ja": "（PK（B）** SK（A））MODモジュラス=（PK（A）** SK（B））MODモジュラス"
    },
    {
      "indent": 3,
      "text": "We drop the \"mod MODULUS\" parts and assume modulo arithmetic to simplify things:",
      "ja": "私たちは「モッズMODULUS」の部分を削除し、物事を単純化するためにモジュロ算術を前提としています。"
    },
    {
      "indent": 6,
      "text": "PK(B) ** SK(A) = PK(A) ** SK(B)",
      "ja": "PK（B）** SK（A）= PK（A）** SK（B）"
    },
    {
      "indent": 3,
      "text": "Then, replace PK(B) by what B computed earlier and likewise for PK(A).",
      "ja": "その後、以前と同様に、PK（A）について計算何BによってPK（B）を置き換えます。"
    },
    {
      "indent": 6,
      "text": "(BASE ** SK(B)) ** SK(A) = (BASE ** SK(A)) ** SK(B)",
      "ja": "（BASE ** SK（B））** SK（A）=（BASE ** SK（A））** SK（B）"
    },
    {
      "indent": 3,
      "text": "which leads to:",
      "ja": "これにつながります。"
    },
    {
      "indent": 6,
      "text": "BASE ** (SK(A) * SK(B)) = BASE ** (SK(A) * SK(B))",
      "ja": "BASE **（SK（A）* SK（B））= BASE **（SK（A）* SK（B））"
    },
    {
      "indent": 3,
      "text": "This common key CK(A, B) is not used to encrypt the timestamps used in the protocol. Rather, it is used only to encrypt a conversation key which is then used to encrypt the timestamps. The reason for doing this is to use the common key as little as possible, for fear that it could be broken. Breaking the conversation key is a far less damaging, since conversations are relatively short-lived.",
      "ja": "この共通鍵CK（A、B）は、プロトコルで使用されるタイムスタンプを暗号化するために使用されていません。むしろ、その後、タイムスタンプを暗号化するために使用された対話鍵を暗号化するためにのみ使用されます。このようにする理由は、それが破られる可能性があることを恐れて、できるだけ共通鍵を使用することです。会話は比較的短命であるため、会話鍵を破ることは、はるかに少ない有害です。"
    },
    {
      "indent": 3,
      "text": "The conversation key is encrypted using 56-bit DES keys, yet the common key is 192 bits. To reduce the number of bits, 56 bits are selected from the common key as follows. The middle-most 8-bytes are selected from the common key, and then parity is added to the lower order bit of each byte, producing a 56-bit key with 8 bits of parity.",
      "ja": "会話鍵は56ビットDES鍵を用いて暗号化された、まだ共通鍵は192ビットです。次のようにビット数を減らすために、56ビットは共通鍵から選択されます。中間最も8バイトは共通鍵から選択され、そしてその後、パリティは、パリティの8ビットと56ビットの鍵を生成する、各バイトの下位ビットに付加されます。"
    },
    {
      "indent": 3,
      "text": "Only 48 bits of the 8-byte conversation key are used in the DH Authentication scheme. The least and most significant bits of each byte of the conversation key are unused.",
      "ja": "8バイトの会話キーの唯一の48ビットは、DH認証方式で使用されています。会話キーの各バイトの最小と最上位ビットは未使用です。"
    },
    {
      "indent": 0,
      "text": "3. Kerberos-based Authentication",
      "section_title": true,
      "ja": "3. Kerberosベースの認証"
    },
    {
      "indent": 3,
      "text": "Conceptually, Kerberos-based authentication is very similar to DH authentication. The major difference is, Kerberos-based authentication takes advantage of the fact that Kerberos tickets have encoded in them the client name and the conversation key. This RFC does not describe Kerberos name syntax, protocols and ticket formats. The reader is referred to [6], [7], and [8].",
      "ja": "概念的には、Kerberosベースの認証は、DH認証と非常によく似ています。主な違いは、Kerberosベースの認証は、Kerberosチケットは、それらのクライアント名と会話キーをコード化しているという事実を利用して、あります。このRFCは、Kerberos名の構文、プロトコル、およびチケット形式を説明していません。読者が参照される[6]、[7]と[8]。"
    },
    {
      "indent": 0,
      "text": "3.1 Naming",
      "section_title": true,
      "ja": "3.1ネーミング"
    },
    {
      "indent": 3,
      "text": "A Kerberos name contains three parts. The first is the principal name, which is usually a user's or service's name. The second is the instance, which in the case of a user is usually NULL. Some users may have privileged instances, however, such as root or admin. In the case of a service, the instance is the name of the machine on which it runs; that is, there can be an NFS service running on the machine ABC, which is different from the NFS service running on the machine XYZ. The third part of a Kerberos name is the realm. The realm corresponds to the Kerberos service providing authentication for the principal. When writing a Kerberos name, the principal name is separated from the instance (if not NULL) by a period, and the realm (if not the local realm) follows, preceded by an \"@\" sign. The following are examples of valid Kerberos names:",
      "ja": "Kerberos名は、3つの部分が含まれています。最初は通常、ユーザーまたはサービスの名称であるプリンシパル名、です。第二は、ユーザの場合には通常NULLである場合、です。一部のユーザーは、rootまたは管理者として、しかし、特権のインスタンスを有することができます。サービスの場合、インスタンスは、それが実行されているマシンの名前です。つまり、マシンXYZで実行されているNFSサービスが異なるマシンABC、上で実行されているNFSサービスが存在することができます。 Kerberos名の3番目の部分はレルムです。レルムは、プリンシパルの認証を提供するKerberosサービスに対応しています。 Kerberos名を記述する場合、プリンシパル名は、インスタンスから分離され（そうでない場合はNULL）期間によって、およびレルム（そうでない場合、ローカルレルム）以下、「@」記号が先行します。以下は、有効なKerberos名の例を示します。"
    },
    {
      "indent": 6,
      "text": "billb jis.admin srz@lcs.mit.edu treese.root@athena.mit.edu",
      "ja": "Billbo jis.admin srz@lcs.mit.edu treese.root@athena.mit.edu"
    },
    {
      "indent": 0,
      "text": "3.2 Kerberos-based Authentication Protocol Specification",
      "section_title": true,
      "ja": "3.2 Kerberosベースの認証プロトコルの仕様"
    },
    {
      "indent": 3,
      "text": "The Kerberos-based authentication protocol described is based on Kerberos version 4.",
      "ja": "説明Kerberosベースの認証プロトコルは、Kerberosバージョン4に基づいています。"
    },
    {
      "indent": 3,
      "text": "There are two kinds of credentials: one in which the client uses its full network name, and one in which it uses its \"nickname\" (just an unsigned integer) given to it by the server. The client must use its fullname in its first transaction with the server, in which the server will return to the client its nickname. The client may use its nickname in all further transactions with the server. There is no requirement to use the nickname, but it is wise to use it for performance reasons.",
      "ja": "クライアントは、その完全なネットワーク名を使用してその一つで、それは、サーバによってそれに与えられたその「ニックネーム」（単なる符号なし整数）を使用した1：2の資格情報の種類があります。クライアントは、サーバがクライアントにそのニックネームに戻りますするサーバーとの最初の取引でそのフルネームを使用する必要があります。クライアントは、サーバーとのすべての更なるトランザクションでそのニックネームを使用することができます。そこニックネームを使用するための要件はありませんが、パフォーマンス上の理由のためにそれを使用するのが賢明です。"
    },
    {
      "indent": 3,
      "text": "The following definitions are used for describing the protocol:",
      "ja": "以下の定義は、プロトコルを記述するために使用されます。"
    },
    {
      "indent": 6,
      "text": "enum authkerb4_namekind { AKN_FULLNAME = 0, AKN_NICKNAME = 1 };",
      "ja": ".NUM authkerb4_namekind KN_FULLNAME {A = 0、A = 1} KN_NICKNAME。"
    },
    {
      "indent": 3,
      "text": "The flavor used for all Kerberos-based authentication credentials and verifiers is \"AUTH_KERB4\", with numerical value 4. The opaque data constituting the client credential encodes the following structure:",
      "ja": "全てのKerberosベースの認証資格証明と検証のために使用されるフレーバーは、クライアント証明書を構成する不透明なデータ4.数値で「AUTH_KERB4」は、以下の構造をコードしています。"
    },
    {
      "indent": 3,
      "text": "union authkerb4_cred switch (authkerb4_namekind namekind) {\ncase AKN_FULLNAME:\n   authkerb4_fullname fullname;\ncase AKN_NICKNAME:\n   authkerb4_nickname nickname;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The opaque data constituting a verifier that accompanies a client credential encodes the following structure:",
      "ja": "クライアントの信任状を伴う検証を構成する不透明なデータは、以下の構造をコードします。"
    },
    {
      "indent": 3,
      "text": "union authkerb4_verf switch (authkerb4_namekind namekind) {\ncase AKN_FULLNAME:\n   authkerb4_fullname_verf fullname_verf;\ncase AKN_NICKNAME:\n   authkerb4_nickname_verf nickname_verf;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The opaque data constituting a verifier returned by a server in response to a client request encodes the following structure:",
      "ja": "クライアント要求に応答してサーバによって返された検証を構成する不透明なデータは、以下の構造をコードします。"
    },
    {
      "indent": 3,
      "text": "struct authkerb4_server_verf;",
      "ja": "構造体authkerb4_server_verf。"
    },
    {
      "indent": 3,
      "text": "These structures are described in detail below.",
      "ja": "これらの構造は、以下に詳細に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.2.1 The Full Network Name Credential and Verifier (Client)",
      "section_title": true,
      "ja": "3.2.1ザ・フル・ネットワーク名資格と検証（クライアント）"
    },
    {
      "indent": 3,
      "text": "First, the client must obtain a Kerberos ticket from the Kerberos Server. The ticket contains a Kerberos session key, which will become the conversation key. Next, the client fills out the following structure:",
      "ja": "まず、クライアントは、KerberosサーバからKerberosチケットを取得する必要があります。チケットは、会話のキーとなりますケルベロスセッションキーが含まれています。次に、クライアントは、次のような構造を記入します："
    },
    {
      "indent": 6,
      "text": "+---------------------------------------------------------------+\n|   timestamp   |  timestamp    |               |               |\n|   seconds     | micro seconds |      ttl      |   ttl - 1     |\n|   32 bits     |    32 bits    |    32 bits    |   32 bits     |\n+---------------------------------------------------------------+\n0              31              63              95             127",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields are stored in XDR (external data representation) format. The timestamp encodes the time since midnight, January 1, 1970. \"ttl\" is identical in meaning to the corresponding field in Diffie-Hellman authentication: the credential \"time-to-live\" for the conversation being initiated. These 128 bits of data are then encrypted in the DES CBC mode, using the conversation key, and with an initialization vector of 0. This yields:",
      "ja": "フィールドは、XDR（外部データ表現）形式で格納されます。資格「生存時間」が開始された会話のため：タイムスタンプは真夜中からの時間をエンコードし、1970年1月1日「TTLは」のDiffie-Hellman認証の対応するフィールドと同義です。データのこれらの128ビットは、会話鍵を使用して、DES CBCモードで暗号化され、そして0この収率の初期化ベクトルとされます。"
    },
    {
      "indent": 6,
      "text": "+---------------------------------------------------------------+\n|               T               |               |               |\n|     T1               T2       |      W1       |     W2        |\n|   32 bits     |    32 bits    |    32 bits    |   32 bits     |\n+---------------------------------------------------------------+\n0              31              63              95             127",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where T1, T2, W1, and W2 are all 32-bit quantities, and have some correspondence to the original quantities occupying their positions, but are now interdependent on each other for proper decryption. The 64 bit sequence comprising T1 and T2 is denoted by T.",
      "ja": "ここで、T1、T2、W1及びW2は、全ての32ビット量であり、それらの位置を占める元の量に一部対応しているが、今適切な復号化のためにお互いに相互依存しています。 T1およびT2を含む64ビット・シーケンスは、Tで表され"
    },
    {
      "indent": 3,
      "text": "The full network name credential is represented as follows using XDR notation:",
      "ja": "XDR表記法を使用して次のように完全なネットワーク名資格が表されます。"
    },
    {
      "indent": 3,
      "text": "struct authkerb4_fullname {\n   opaque ticket<>;         /* kerberos ticket for the server */\n   opaque w1[4];            /* W1                             */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The verifier is represented as follows:",
      "ja": "次のように検証が表されます。"
    },
    {
      "indent": 3,
      "text": "struct authkerb4_fullname_verf {\n   des_block timestamp;         /* T (the 64 bits of T1 and T2) */\n   opaque w2[4];                /* W2                           */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that all of the client-encrypted quantities (w1, w2, timestamp) in the above structures are opaque. The client does not encrypt the Kerberos ticket for the server.",
      "ja": "上記の構造では、クライアント暗号化された量（W1、W2、タイムスタンプ）のすべてが不透明であることに注意してください。クライアントは、サーバーのKerberosチケットを暗号化しません。"
    },
    {
      "indent": 3,
      "text": "The fullname credential and its associated verifier together contain the Kerberos ticket (which contains the client name and the conversation key), the ttl, a timestamp, and a ttl verifier that is one less than the ttl. The ttl is actually the lifetime for the credential. The server will accept the credential if the current server time is \"within\" the time indicated in the timestamp plus the ttl. Otherwise, the server rejects the credential with an authentication status of AUTH_BADCRED. One way to insure that requests are not replayed would be for the server to insist that timestamps are greater than the previous one seen, unless it is the first transaction. If the timestamp is earlier than the previous one seen, the server returns an authentication status of AUTH_REJECTEDCRED.",
      "ja": "フルネーム資格とそれに関連する検証者は、一緒に（クライアント名と会話キーを含む）Kerberosチケット、TTL、タイムスタンプ、およびTTLよりも1小さいTTL検証が含まれています。 TTLは実際に資格の有効期間です。現在のサーバー時刻がタイムスタンププラスTTLで示された時間「以内」であれば、サーバーは証明書を受け入れます。そうしないと、サーバーはAUTH_BADCREDの認証ステータスを持つ資格を拒否します。要求が再生されていないことを保証するための一つの方法は、それが最初のトランザクションでない限り、タイムスタンプは、見て、以前のものより大きいことを主張するために、サーバーのためになります。タイムスタンプが見られ、以前のものより前の場合、サーバーはAUTH_REJECTEDCREDの認証状態を返します。"
    },
    {
      "indent": 3,
      "text": "The server returns a authkerb4_server_verf structure, which is described in detail below. This structure contains a \"nickname\", which may be used for subsequent requests in the current session.",
      "ja": "サーバは、以下に詳細に記載されてauthkerb4_server_verf構造を返します。この構造は、現在のセッションで後続の要求のために使用することができる「ニックネーム」を、含まれています。"
    },
    {
      "indent": 0,
      "text": "3.2.2 The Nickname Credential and Verifier (Client)",
      "section_title": true,
      "ja": "ニックネーム資格および3.2.2検証（クライアント）"
    },
    {
      "indent": 3,
      "text": "In transactions following the first, the client may use the shorter nickname credential and verifier for efficiency. First, the client fills out the following structure:",
      "ja": "最初に以下の取引では、クライアントは、効率のために短いニックネーム資格とベリファイアを使用することができます。まず、クライアントは、次のような構造を記入します："
    },
    {
      "indent": 6,
      "text": "+-------------------------------+\n|   timestamp   |  timestamp    |\n|   seconds     | micro seconds |\n|   32 bits     |    32 bits    |\n+-------------------------------+\n0              31              63",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields are stored in XDR (external data representation) format. These 64 bits of data are then encrypted in the DES ECB mode, using the conversation key for the session. This yields:",
      "ja": "フィールドは、XDR（外部データ表現）形式で格納されます。これらのデータの64ビットは、セッションのための対話鍵を使用して、DES ECBモードで暗号化されています。この利回り："
    },
    {
      "indent": 6,
      "text": "+-------------------------------+\n|     (T1)      |      (T2)     |\n|               T               |\n|             64 bits           |\n+-------------------------------+\n0              31              63",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The nickname credential is represented as follows using XDR notation:",
      "ja": "XDR表記法を使用して次のようにニックネーム資格が表されます。"
    },
    {
      "indent": 3,
      "text": "struct authkerb4_nickname {\n   unsigned int nickname;       /* nickname returned by server   */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The nickname verifier is represented as follows using XDR notation:",
      "ja": "XDR表記法を使用して次のようにニックネーム検証が表されます。"
    },
    {
      "indent": 3,
      "text": "struct authkerb4_nickname_verf {\n   des_block timestamp;         /* T (the 64 bits of T1 and T2) */\n   opaque w[4];                 /* Set to zero                  */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The nickname credential may be reject by the server for several reasons. An authentication status of AUTH_BADCRED indicates that the nickname is no longer valid. The client should retry the request using the fullname credential. AUTH_REJECTEDVERF indicates that the nickname verifier is not valid. Again, the client should retry the request using the fullname credential. AUTH_TIMEEXPIRE indicates that the session's Kerberos ticket has expired. The client should initiate a new session by obtaining a new Kerberos ticket.",
      "ja": "ニックネーム資格はいくつかの理由のために、サーバによって拒否することができます。 AUTH_BADCREDの認証ステータスは、ニックネームはもはや有効であることを示していません。クライアントは、フルネームの資格情報を使用して要求を再試行する必要があります。 AUTH_REJECTEDVERFは、ニックネーム検証が有効でないことを示しています。ここでも、クライアントは、フルネームの資格情報を使用して要求を再試行する必要があります。 AUTH_TIMEEXPIREは、セッションのKerberosチケットの有効期限が切れていることを示しています。クライアントは、新しいKerberosチケットを得ることによって、新しいセッションを開始する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.3 The Nickname Verifier (Server)",
      "section_title": true,
      "ja": "3.2.3ニックネーム検証（サーバー）"
    },
    {
      "indent": 3,
      "text": "The server never returns a credential. It returns only one kind of verifier, i.e., the nickname verifier. This has the following XDR representation:",
      "ja": "サーバーは、証明書を返すことはありません。それは、検証の一種類、即ち、ニックネーム検証を返します。これは、次のXDR表現があります。"
    },
    {
      "indent": 3,
      "text": "struct authkerb4_server_verf {\n   des_block timestamp_verf; /* timestamp verifier (encrypted)    */\n   unsigned int nickname;    /* new client nickname (unencrypted) */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The timestamp verifier is constructed in exactly the same way as the client nickname credential. The server sets the timestamp value to the value the client sent minus one second and encrypts it in DES ECB mode using the conversation key. The server also sends the client a nickname to be used in future transactions (unencrypted).",
      "ja": "タイムスタンプの検証は、クライアントのニックネーム資格とまったく同じように構成されています。サーバーは、クライアントが1秒減じたもの送られた値にタイムスタンプ値を設定し、対話鍵を使用してDESのECBモードでそれを暗号化します。また、サーバはクライアントに将来の取引（暗号化されていない）で使用するニックネームを送信します。"
    },
    {
      "indent": 0,
      "text": "3.2.4 Kerberos-specific Authentication Status Values",
      "section_title": true,
      "ja": "3.2.4 Kerberosの固有の認証ステータス値"
    },
    {
      "indent": 3,
      "text": "The server may return to the client one of the following errors in the authentication status field:",
      "ja": "サーバーはクライアントに認証ステータスフィールドに次のいずれかのエラーを返すことがあります。"
    },
    {
      "indent": 2,
      "text": "enum auth_stat {\n    ...\n    /*\n     * kerberos errors\n     */\n    AUTH_KERB_GENERIC = 8,  /* Any Kerberos-specific error other\n                               than the following                   */\n    AUTH_TIMEEXPIRE = 9,    /* The client's ticket has expired      */\n    AUTH_TKT_FILE = 10,     /* The server was unable to find the\n                               ticket file.  The client should\n                               create a new session by obtaining a\n                               new ticket                           */\n    AUTH_DECODE = 11,       /* The server is unable to decode the\n                               authenticator of the client's ticket */\n    AUTH_NET_ADDR = 12      /* The network address of the client\n                               does not match the address contained\n                               in the ticket                        */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "    /* and more to be defined */\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "The DH authentication mechanism and the Kerberos V4 authentication mechanism are described in this document only for informational purposes.",
      "ja": "DH認証メカニズムとKerberos V4の認証メカニズムは、情報提供のみを目的とし、この文書に記述されています。"
    },
    {
      "indent": 3,
      "text": "In addition to the weakness pointed out earlier in this document (see WARNING on page 1), the two security mechanisms described herein lack the support for integrity and privacy data protection. It is strongly recommended that new applications use more secure mechanisms, and that existing applications migrate to more robust mechanisms.",
      "ja": "弱さに加えて、（1ページの警告を参照）、本明細書中に記載の2つのセキュリティメカニズムは、整合性とプライバシーデータ保護をサポートしていないこの資料で先に指摘しました。新しいアプリケーションをより安全なメカニズムを使用し、その既存のアプリケーションは、より堅牢なメカニズムに移行することを強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS ONC RPC security flavor, specified in RFC 2203, allows applications built on top of RPC to access security mechanisms that adhere to the GSS-API specification. It provides a GSS-API based security framework that allows for strong security mechanisms. RFC 1964 describes the Kerberos Version 5 GSS-API security mechanism which provides integrity and privacy, in addition to authentication. RFC 2623 [14] describes how Kerberos V5 is pluggued into RPCSEC_GSS, and how the Version 2 and Version 3 of the NFS protocol use Kerberos V5 via RPCSEC_GSS. The RPCSEC_GSS/GSS-API/Kerberos-V5 stack provides a robust security mechanism for applications that require strong protection.",
      "ja": "RFC 2203で指定されたRPCSEC_GSS ONC RPCセキュリティ風味は、RPCの上に構築されたアプリケーションは、GSS-API仕様に準拠したセキュリティ・メカニズムにアクセスすることができます。それは、強力なセキュリティメカニズムを可能GSS-APIベースのセキュリティフレームワークを提供します。 RFC 1964は、認証に加えて、整合性とプライバシーを提供してKerberosバージョン5 GSS-APIセキュリティー・メカニズムについて説明します。 RFC 2623 [14] RPCSEC_GSS介しケルベロスV5をRPCSEC_GSSにplugguedする方法を説明し、どのバージョン2とNFSプロトコル使用ケルベロスV5のバージョン3。 RPCSEC_GSS / GSS-API / Kerberosの-V5スタックは、強力な保護を必要とするアプリケーションのための堅牢なセキュリティメカニズムを提供します。"
    },
    {
      "indent": 0,
      "text": "5. REFERENCES",
      "section_title": true,
      "ja": "5.参考文献"
    },
    {
      "indent": 3,
      "text": "[1] Srinivasan, R., \"Remote Procedure Call Protocol Version 2\", RFC 1831, August 1995.",
      "ja": "[1]スリニバサン、R.、 \"リモートプロシージャコールプロトコルバージョン2\"、RFC 1831、1995年8月。"
    },
    {
      "indent": 3,
      "text": "[2] Srinivasan, R., \"XDR: External Data Representation Standard\", RFC 1832, August 1995.",
      "ja": "[2]スリニバサン、R.、 \"XDR：外部データ表現標準\"、RFC 1832、1995年8月。"
    },
    {
      "indent": 3,
      "text": "[3] Diffie & Hellman, \"New Directions in Cryptography\", IEEE Transactions on Information Theory IT-22, November 1976.",
      "ja": "[3]ディフィー＆ヘルマン、 \"暗号に関する新\"、情報理論IT-22、1976年11月にIEEEトランザクション。"
    },
    {
      "indent": 3,
      "text": "[4] Mills, D., \"Network Time Protocol (Version 3)\", RFC 1305, March 1992.",
      "ja": "[4]ミルズ、D.、 \"ネットワーク時間プロトコル（バージョン3）\"、RFC 1305、1992年3月。"
    },
    {
      "indent": 3,
      "text": "[5] National Bureau of Standards, \"Data Encryption Standard\", Federal Information Processing Standards Publication 46, January 1977.",
      "ja": "[5]国立標準局、「データ暗号化規格」、連邦情報処理規格出版46、1977年1月。"
    },
    {
      "indent": 3,
      "text": "[6] Miller, S., Neuman, C., Schiller, J. and J. Saltzer, \"Section E.2.1: Kerberos Authentication and Authorization System\", December 1987.",
      "ja": "[6]ミラー、S.、ニューマン、C.、シラー、J.およびJ. Saltzer、 \"セクションE.2.1：Kerberos認証及び認可システム\"、1987年12月。"
    },
    {
      "indent": 3,
      "text": "[7] Steiner, J., Neuman, C. and J. Schiller, \"Kerberos: An Authentication Service for Open Network Systems\", pp. 191-202 in Usenix Conference Proceedings, Dallas, Texas, February, 1988.",
      "ja": "[7]シュタイナー、J.、ニューマン、C.とJ.シラー、 \"ケルベロス：オープンネットワークシステムのための認証サービス\" のUsenix会議の議事録、ダラス、テキサス、2月、1988年、頁191-202。"
    },
    {
      "indent": 3,
      "text": "[8] Kohl, J. and C. Neuman, \"The Kerberos Network Authentication Service (V5)\", RFC 1510, September 1993.",
      "ja": "[8]コールズ、J.及びC.ノイマン、 \"ケルベロスネットワーク認証サービス（V5）\"、RFC 1510、1993年9月。"
    },
    {
      "indent": 3,
      "text": "[9] La Macchia, B.A., and Odlyzko, A.M., \"Computation of Discrete Logarithms in Prime Fields\", pp. 47-62 in \"Designs, Codes and Cryptography\", Kluwer Academic Publishers, 1991.",
      "ja": "[9]ラマッキア、B.A.、およびOdlyzko、午前、「首相分野における離散対数の計算」、頁47-62で「デザイン、コード、および暗号化」、Kluwerの学術出版、1991。"
    },
    {
      "indent": 3,
      "text": "[10] Cheswick, W.R., and Bellovin, S.M., \"Firewalls and Internet Security,\" Addison-Wesley, 1995.",
      "ja": "[10]チェスウィック、W.R.、およびBellovin氏、S.M.、 \"ファイアウォールとインターネットセキュリティ、\" アディソン・ウェズリー、1995。"
    },
    {
      "indent": 3,
      "text": "[11] Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\", RFC 1964, June 1996.",
      "ja": "[11]リン、J.、 \"ケルベロスバージョン5 GSS-API機構\"、RFC 1964、1996年6月。"
    },
    {
      "indent": 3,
      "text": "[12] Linn, J., \"Generic Security Service Application Program Interface, Version 2\", RFC 2078, January 1997.",
      "ja": "[12]リン、J.、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェース、バージョン2\"、RFC 2078、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[13] Eisler, M., Chiu, A., and Ling, L., \"RPCSEC_GSS Protocol Specification\", RFC 2203, September 1997.",
      "ja": "[13]アイスラー、M.、チウ、A.、およびリン、L.、 \"RPCSEC_GSSプロトコル仕様\"、RFC 2203、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[14] Eisler, M., \"NFS Version 2 and Version 3 Security Issues and the NFS Protocol's Use of RPCSEC_GSS and Kerberos V5\", RFC 2623, June 1999.",
      "ja": "[14]アイスラー、M.、 \"NFSバージョン2およびバージョン3のセキュリティ問題とRPCSEC_GSSとケルベロスV5のNFSプロトコルの使用\"、RFC 2623、1999年6月。"
    },
    {
      "indent": 0,
      "text": "6. AUTHOR'S ADDRESS",
      "section_title": true,
      "ja": "6.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Alex Chiu Sun Microsystems, Inc. 901 San Antonio Road Palo Alto, CA 94303",
      "ja": "アレックス・チウサン・マイクロシステムズ株式会社901サンアントニオの道パロアルト、CA 94303"
    },
    {
      "indent": 3,
      "text": "Phone: +1 (650) 786-6465 EMail: alex.chiu@Eng.sun.com",
      "ja": "電話：+1（650）786-6465 Eメール：alex.chiu@Eng.sun.com"
    },
    {
      "indent": 0,
      "text": "7. Full Copyright Statement",
      "section_title": true,
      "ja": "7.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1999）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}