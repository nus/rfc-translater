{
  "title": {
    "text": "RFC 2747 - RSVP Cryptographic Authentication",
    "ja": "RFC 2747 - RSVP暗号化認証"
  },
  "number": 2747,
  "created_at": "2019-10-29 17:28:25.245895+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           F. Baker\nRequest for Comments: 2747                                         Cisco\nCategory: Standards Track                                     B. Lindell\n                                                                 USC/ISI\n                                                               M. Talwar\n                                                               Microsoft\n                                                            January 2000",
      "raw": true
    },
    {
      "indent": 19,
      "text": "RSVP Cryptographic Authentication",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2000）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes the format and use of RSVP's INTEGRITY object to provide hop-by-hop integrity and authentication of RSVP messages.",
      "ja": "この文書では、RSVPメッセージのホップバイホップ整合性と認証を提供するために、RSVPのINTEGRITYオブジェクトの形式と使用を記載しています。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Resource ReSerVation Protocol RSVP [1] is a protocol for setting up distributed state in routers and hosts, and in particular for reserving resources to implement integrated service. RSVP allows particular users to obtain preferential access to network resources, under the control of an admission control mechanism. Permission to make a reservation will depend both upon the availability of the requested resources along the path of the data, and upon satisfaction of policy rules.",
      "ja": "資源予約プロトコルRSVP [1]ルータとホストに分布状態を設定するため、特に、統合サービスを実装するためにリソースを予約するためのプロトコルです。 RSVPは、アドミッション制御機構の制御下で、特定のユーザーがネットワークリソースへの優先アクセスを得ることができます。予約を行うための許可は、データのパスに沿って要求されたリソースの可用性に応じ両方に依存し、ポリシールールの満足度に応じます。"
    },
    {
      "indent": 3,
      "text": "To ensure the integrity of this admission control mechanism, RSVP requires the ability to protect its messages against corruption and spoofing. This document defines a mechanism to protect RSVP message integrity hop-by-hop. The proposed scheme transmits an authenticating digest of the message, computed using a secret Authentication Key and a keyed-hash algorithm. This scheme provides protection against forgery or message modification. The INTEGRITY object of each RSVP message is tagged with a one-time-use sequence number. This allows the message receiver to identify playbacks and hence to thwart replay attacks. The proposed mechanism does not afford confidentiality, since messages stay in the clear; however, the mechanism is also exportable from most countries, which would be impossible were a privacy algorithm to be used. Note: this document uses the terms \"sender\" and \"receiver\" differently from [1]. They are used here to refer to systems that face each other across an RSVP hop, the \"sender\" being the system generating RSVP messages.",
      "ja": "このアドミッション制御メカニズムの整合性を確保するために、RSVPは、汚職やなりすましに対してそのメッセージを保護する能力が必要です。この文書では、ホップバイホップRSVPメッセージの完全性を保護するためのメカニズムを定義します。提案方式は、メッセージの認証ダイジェストを送信し、秘密認証キーとキー付きハッシュアルゴリズムを使用して計算。この方式は、偽造やメッセージの変更に対する保護を提供します。各RSVPメッセージのINTEGRITYオブジェクトは、一回使用のシーケンス番号でタグ付けされています。これは、メッセージ受信機が再生回数を識別し、したがってリプレイ攻撃を阻止することを可能にします。メッセージは明確にとどまるため、提案されたメカニズムは、機密性を買う余裕はありません。しかし、メカニズムは、プライバシーのアルゴリズムが使用されたことは不可能だろうほとんどの国からのエクスポートです。注意：この文書は、異なる[1]から「送信者」及び「受信機」の用語を使用しています。彼らは、「送信者が」RSVPメッセージを生成するシステムである、RSVPホップを挟んで対向のシステムを参照するためにここで使用されています。"
    },
    {
      "indent": 3,
      "text": "The message replay prevention algorithm is quite simple. The sender generates packets with monotonically increasing sequence numbers. In turn, the receiver only accepts packets that have a larger sequence number than the previous packet. To start this process, a receiver handshakes with the sender to get an initial sequence number. This memo discusses ways to relax the strictness of the in-order delivery of messages as well as techniques to generate monotonically increasing sequence numbers that are robust across sender failures and restarts.",
      "ja": "メッセージリプレイ防止アルゴリズムは非常に簡単です。送信者は単調に増加するシーケンス番号を持つパケットを生成します。次に、受信機は、以前のパケットよりも大きいシーケンス番号を持つパケットを受け付けます。このプロセスを開始するには、送信側と受信側のハンドシェイクは、初期シーケンス番号を取得します。このメモは、メッセージの順序どおりの配信の厳しさだけでなく、単調に送信者の障害や再起動に強固である増加するシーケンス番号を生成するためのテクニックを緩和する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "The proposed mechanism is independent of a specific cryptographic algorithm, but the document describes the use of Keyed-Hashing for Message Authentication using HMAC-MD5 [7]. As noted in [7], there exist stronger hashes, such as HMAC-SHA1; where warranted, implementations will do well to make them available. However, in the general case, [7] suggests that HMAC-MD5 is adequate to the purpose at hand and has preferable performance characteristics. [7] also offers source code and test vectors for this algorithm, a boon to those who would test for interoperability. HMAC-MD5 is required as a baseline to be universally included in RSVP implementations providing cryptographic authentication, with other proposals optional (see Section 6 on Conformance Requirements).",
      "ja": "提案されたメカニズムは、特定の暗号化アルゴリズムとは無関係であるが、文書はHMAC-MD5を使用してメッセージ認証のための鍵付きハッシュ化の使用を記載している[7]。で述べたように[7]、そのようなHMAC-SHA1などの強力なハッシュは、そこに存在します。保証ところ、実装がそれらを利用できるようにうまくやるだろう。しかし、一般的な場合には、[7] HMAC-MD5が手元目的に適しており、好ましい性能特性を有することを示唆しています。 [7]また、このアルゴリズムのソースコードとテストベクトル、相互運用性をテストしようとする者たちに恩恵を提供しています。 HMAC-MD5は、普遍任意他の提案（適合要件のセクション6を参照）と、暗号認証を提供RSVP実装に含まれるベースラインとして必要とされます。"
    },
    {
      "indent": 3,
      "text": "The RSVP checksum MAY be disabled (set to zero) when the INTEGRITY object is included in the message, as the message digest is a much stronger integrity check.",
      "ja": "INTEGRITYオブジェクトがメッセージに含まれているときに、メッセージダイジェストがはるかに強い整合性チェックであるとしてRSVPチェックサムは、（ゼロに設定）無効になることがあります。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions used in this document",
      "section_title": true,
      "ja": "1.1。この文書で使用されている表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [8].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[8]で説明されるように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Why not use the Standard IPSEC Authentication Header?",
      "section_title": true,
      "ja": "1.2。なぜ標準IPSEC認証ヘッダを使用していませんか？"
    },
    {
      "indent": 3,
      "text": "One obvious question is why, since there exists a standard authentication mechanism, IPSEC [3,5], we would choose not to use it. This was discussed at length in the working group, and the use of IPSEC was rejected for the following reasons.",
      "ja": "標準の認証機構、IPSEC [3,5]が存在するので、我々はそれを使用しないことを選択する理由、1つの明白な疑問があります。これは、ワーキンググループの長さで議論された、とIPSECの使用は、以下の理由で拒否されました。"
    },
    {
      "indent": 3,
      "text": "The security associations in IPSEC are based on destination address. It is not clear that RSVP messages are well defined for either source or destination based security associations, as a router must forward PATH and PATH TEAR messages using the same source address as the sender listed in the SENDER TEMPLATE. RSVP traffic may otherwise not follow exactly the same path as data traffic. Using either source or destination based associations would require opening a new security association among the routers for which a reservation traverses.",
      "ja": "IPSECのセキュリティアソシエーションが宛先アドレスに基づいています。ルータがSENDERテンプレートに記載されている送信者と同じ送信元アドレスを使用してPATHおよびPATH TEARメッセージを転送しなければならないとして、RSVPメッセージがよく、ソースまたは宛先ベースのセキュリティアソシエーションのために定義されていることは明らかではありません。 RSVPのトラフィックは、そうでない場合は、データトラフィックと全く同じ道をたどるないかもしれません。送信元または宛先ベースの関連付けのいずれかを使用することにより、予約が横断するためのルータ間で新しいセキュリティアソシエーションを開く必要とするであろう。"
    },
    {
      "indent": 3,
      "text": "In addition, it was noted that neighbor relationships between RSVP systems are not limited to those that face one another across a communication channel. RSVP relationships across non-RSVP clouds, such as those described in Section 2.9 of [1], are not necessarily visible to the sending system. These arguments suggest the use of a key management strategy based on RSVP router to RSVP router associations instead of IPSEC.",
      "ja": "また、RSVPシステム間の隣接関係は、通信チャネルを介して互いに対向するものに限定されないことが留意されました。そのようなセクション2.9に記載されるもののような非RSVP雲横切るRSVP関係は、[1]、必ずしも送信システムには見えません。これらの引数は、代わりにIPSECのルータの関連付けをRSVPにRSVPルータに基づいて、鍵管理戦略の使用を示唆しています。"
    },
    {
      "indent": 0,
      "text": "2. Data Structures",
      "section_title": true,
      "ja": "2.データ構造"
    },
    {
      "indent": 0,
      "text": "2.1. INTEGRITY Object Format",
      "section_title": true,
      "ja": "2.1。 INTEGRITYオブジェクトフォーマット"
    },
    {
      "indent": 3,
      "text": "An RSVP message consists of a sequence of \"objects,\" which are type-length-value encoded fields having specific purposes. The information required for hop-by-hop integrity checking is carried in an INTEGRITY object. The same INTEGRITY object type is used for both IPv4 and IPv6.",
      "ja": "RSVPメッセージは、特定の目的を有するタイプレングス値符号化されたフィールドである「オブジェクト」の配列からなります。ホップバイホップの整合性チェックのために必要な情報がINTEGRITYオブジェクトで運ばれます。同じINTEGRITYオブジェクトタイプは、IPv4とIPv6の両方のために使用されます。"
    },
    {
      "indent": 3,
      "text": "The INTEGRITY object has the following format:",
      "ja": "INTEGRITYオブジェクトの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Keyed Message Digest INTEGRITY Object: Class = 4, C-Type = 1",
      "ja": "キー付きメッセージダイジェストINTEGRITYオブジェクト：クラス= 4、C-タイプ= 1"
    },
    {
      "indent": 7,
      "text": "+-------------+-------------+-------------+-------------+\n|    Flags    | 0 (Reserved)|                           |\n+-------------+-------------+                           +\n|                    Key Identifier                     |\n+-------------+-------------+-------------+-------------+\n|                    Sequence Number                    |\n|                                                       |\n+-------------+-------------+-------------+-------------+\n|                                                       |\n+                                                       +\n|                                                       |\n+                  Keyed Message Digest                 |\n|                                                       |\n+                                                       +\n|                                                       |\n+-------------+-------------+-------------+-------------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "o Flags: An 8-bit field with the following format:",
      "ja": "Oフラグ：次の形式の8ビットのフィールド："
    },
    {
      "indent": 38,
      "text": "Flags",
      "ja": "国旗"
    },
    {
      "indent": 24,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| H |                           |\n| F |             0             |\n+---+---+---+---+---+---+---+---+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Currently only one flag (HF) is defined. The remaining flags are reserved for future use and MUST be set to 0.",
      "ja": "現在は、1つのフラグ（HF）が定義されます。残りのフラグは、将来の使用のために予約され、0に設定しなければなりません。"
    },
    {
      "indent": 10,
      "text": "o Bit 0: Handshake Flag (HF) concerns the integrity handshake mechanism (Section 4.3). Message senders willing to respond to integrity handshake messages SHOULD set this flag to 1 whereas those that will reject integrity handshake messages SHOULD set this to 0.",
      "ja": "Oビット0：ハンドシェイクフラグ（HF）は、完全性ハンドシェークメカニズム（4.3節）を懸念します。メッセージは、0に設定する必要があり、完全性ハンドシェイクメッセージを拒否しますものに対し、1にこのフラグを設定する必要があり、完全性ハンドシェークメッセージに応答して喜ん送信者。"
    },
    {
      "indent": 5,
      "text": "o Key Identifier: An unsigned 48-bit number that MUST be unique for a given sender. Locally unique Key Identifiers can be generated using some combination of the address (IP or MAC or LIH) of the sending interface and the key number. The combination of the Key Identifier and the sending system's IP address uniquely identifies the security association (Section 2.2).",
      "ja": "Oキー識別子：特定の送信者に対して一意でなければならない符号なしの48ビット数。ローカルで一意のキー識別子は、送信インタフェースとキー番号のアドレス（IPまたはMACまたはLIH）のいくつかの組み合わせを使用して生成することができます。キー識別子と送信システムのIPアドレスの組み合わせが一意のセキュリティアソシエーション（セクション2.2）を識別する。"
    },
    {
      "indent": 5,
      "text": "o Sequence Number: An unsigned 64-bit monotonically increasing, unique sequence number.",
      "ja": "Oシーケンス番号：符号なし64ビットの単調に増加し、固有のシーケンス番号。"
    },
    {
      "indent": 10,
      "text": "Sequence Number values may be any monotonically increasing\nsequence that provides the INTEGRITY object [of each RSVP\nmessage] with a tag that is unique for the associated key's\nlifetime.  Details on sequence number generation are presented\nin Section 3.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "o Keyed Message Digest: The digest MUST be a multiple of 4 octets long. For HMAC-MD5, it will be 16 bytes long.",
      "ja": "Oキー付きメッセージダイジェストは：ダイジェストは長い4つのオクテットの倍数でなければなりません。 HMAC-MD5の場合は、16バイト長になります。"
    },
    {
      "indent": 0,
      "text": "2.2. Security Association",
      "section_title": true,
      "ja": "2.2。セキュリティアソシエーション"
    },
    {
      "indent": 3,
      "text": "The sending and receiving systems maintain a security association for each authentication key that they share. This security association includes the following parameters:",
      "ja": "送信側と受信側のシステムでは、彼らが共有し、各認証キーのためのセキュリティアソシエーションを維持します。このセキュリティ・アソシエーションは、以下のパラメータが含まれています。"
    },
    {
      "indent": 5,
      "text": "o Authentication algorithm and algorithm mode being used.",
      "ja": "O認証アルゴリズムとアルゴリズムモードが使用されています。"
    },
    {
      "indent": 5,
      "text": "o Key used with the authentication algorithm.",
      "ja": "Oキーは、認証アルゴリズムで使用されます。"
    },
    {
      "indent": 5,
      "text": "o Lifetime of the key.",
      "ja": "キーのO寿命。"
    },
    {
      "indent": 5,
      "text": "o Associated sending interface and other security association selection criteria [REQUIRED at Sending System].",
      "ja": "O関連する[システムの送信で必要】インタフェース及び他のセキュリティ関連の選択基準を送信します。"
    },
    {
      "indent": 5,
      "text": "o Source Address of the sending system [REQUIRED at Receiving System].",
      "ja": "送信側システムのOソースアドレス[受信システムで必要とされます]。"
    },
    {
      "indent": 5,
      "text": "o Latest sending sequence number used with this key identifier [REQUIRED at Sending System].",
      "ja": "[システムの送信で必要このキー識別子に用いられるo-最新の送信シーケンス番号。"
    },
    {
      "indent": 5,
      "text": "o List of last N sequence numbers received with this key identifier [REQUIRED at Receiving System].",
      "ja": "O最後のN個のシーケンス番号の一覧は、[受信システムで必要とされる]このキー識別子を受け取りました。"
    },
    {
      "indent": 0,
      "text": "3. Generating Sequence Numbers",
      "section_title": true,
      "ja": "3.生成シーケンス番号"
    },
    {
      "indent": 3,
      "text": "In this section we describe methods that could be chosen to generate the sequence numbers used in the INTEGRITY object of an RSVP message. As previous stated, there are two important properties that MUST be satisfied by the generation procedure. The first property is that the sequence numbers are unique, or one-time, for the lifetime of the integrity key that is in current use. A receiver can use this property to unambiguously distinguish between a new or a replayed message. The second property is that the sequence numbers are generated in monotonically increasing order, modulo 2^64. This is required to greatly reduce the amount of saved state, since a receiver only needs to save the value of the highest sequence number seen to avoid a replay attack. Since the starting sequence number might be arbitrarily large, the modulo operation is required to accommodate sequence number roll-over within some key's lifetime. This solution draws from TCP's approach [9].",
      "ja": "このセクションでは、RSVPメッセージの完全性目的で使用されるシーケンス番号を生成するために選択することができる方法を記載しています。前に述べたように、生成手順によって満たされなければならない二つの重要な特性があります。最初のプロパティは、シーケンス番号が現在使用されている完全性鍵の寿命のために、ユニークである、または一回ということです。受信機は、明確に新しい又は再生メッセージを区別するために、このプロパティを使用することができます。第二の特性は、シーケンス番号が単調に増加するため、モジュロ2 ^ 64で生成されることです。受信機が唯一のリプレイ攻撃を回避するために見て最も高いシーケンス番号の値を保存する必要があるので、これは、非常に保存された状態の量を低減することが要求されます。開始シーケンス番号は、任意の大きさであるかもしれないので、モジュロ演算は、いくつかのキーの有効期間内のシーケンス番号のロールオーバーに対応するために必要とされます。このソリューションは、TCPのアプローチ[9]から描画します。"
    },
    {
      "indent": 3,
      "text": "The sequence number field is chosen to be a 64-bit unsigned quantity. This is large enough to avoid exhaustion over the key lifetime. For example, if a key lifetime was conservatively defined as one year, there would be enough sequence number values to send RSVP messages at an average rate of about 585 gigaMessages per second. A 32-bit sequence number would limit this average rate to about 136 messages per second.",
      "ja": "シーケンス番号フィールドは、64ビットの符号量となるように選択されます。これは、キー寿命にわたって枯渇を回避するのに十分な大きさです。キーの有効期間は、保守的に1年と定義した場合、例えば、毎秒約585 gigaMessagesの平均速度でRSVPメッセージを送信するのに十分なシーケンス番号値が存在することになります。 32ビットのシーケンス番号は、毎秒約136メッセージにこの平均速度を制限します。"
    },
    {
      "indent": 3,
      "text": "The ability to generate unique monotonically increasing sequence numbers across a failure and restart implies some form of stable storage, either local to the device or remotely over the network. Three sequence number generation procedures are described below.",
      "ja": "故障、再起動を横切ってユニークな単調に増加するシーケンス番号を生成する能力は、デバイスにローカルまたはリモートネットワーク上のいずれかで、安定したストレージのいくつかのフォームを意味しています。三のシーケンス番号生成手順は以下の通りです。"
    },
    {
      "indent": 0,
      "text": "3.1. Simple Sequence Numbers",
      "section_title": true,
      "ja": "3.1。シンプルなシーケンス番号"
    },
    {
      "indent": 3,
      "text": "The most straightforward approach is to generate a unique sequence number using a message counter. Each time a message is transmitted for a given key, the sequence number counter is incremented. The current value of this counter is continually or periodically saved to stable storage. After a restart, the counter is recovered using this stable storage. If the counter was saved periodically to stable storage, the count should be recovered by increasing the saved value to be larger than any possible value of the counter at the time of the failure. This can be computed, knowing the interval at which the counter was saved to stable storage and incrementing the stored value by that amount.",
      "ja": "最も簡単な方法は、メッセージカウンタを使用して固有のシーケンス番号を生成することです。メッセージは、指定された鍵のために送信されるたびに、シーケンス番号カウンタをインクリメントします。このカウンタの現在値が継続的にまたは定期的に安定したストレージに保存されます。再起動後、カウンタは、この安定したストレージを使用して回収されます。カウンタは、定期的に安定したストレージに保存された場合、カウントは障害発生時にカウンタのいずれかの可能性のある値よりも大きくなるように保存された値を大きくすることによって回収されなければなりません。このカウンタは、安定したストレージに保存され、その量によって格納された値をインクリメントした間隔を知ること、計算することができます。"
    },
    {
      "indent": 0,
      "text": "3.2. Sequence Numbers Based on a Real Time Clock",
      "section_title": true,
      "ja": "3.2。リアルタイムクロックに基づいてシーケンス番号"
    },
    {
      "indent": 3,
      "text": "Most devices will probably not have the capability to save sequence number counters to stable storage for each key. A more universal solution is to base sequence numbers on the stable storage of a real time clock. Many computing devices have a real time clock module that includes stable storage of the clock. These modules generally include some form of nonvolatile memory to retain clock information in the event of a power failure.",
      "ja": "ほとんどのデバイスは、おそらく各キーのために安定したストレージにシーケンス番号カウンタを保存する機能を持っていません。より普遍的なソリューションは、リアルタイムクロックの安定したストレージ上の塩基配列番号にあります。多くのコンピューティングデバイスは、クロックの安定した記憶装置を含むリアルタイムクロックモジュールを持っています。これらのモジュールは、一般的に電源障害が発生した場合にクロック情報を保持する不揮発性メモリの何らかの形態を含みます。"
    },
    {
      "indent": 3,
      "text": "In this approach, we could use an NTP based timestamp value as the sequence number. The roll-over period of an NTP timestamp is about 136 years, much longer than any reasonable lifetime of a key. In addition, the granularity of the NTP timestamp is fine enough to allow the generation of an RSVP message every 200 picoseconds for a given key. Many real time clock modules do not have the resolution of an NTP timestamp. In these cases, the least significant bits of the timestamp can be generated using a message counter, which is reset every clock tick. For example, when the real time clock provides a resolution of 1 second, the 32 least significant bits of the sequence number can be generated using a message counter. The remaining 32 bits are filled with the 32 least significant bits of the timestamp. Assuming that the recovery time after failure takes longer than one tick of the real time clock, the message counter for the low order bits can be safely reset to zero after a restart.",
      "ja": "このアプローチでは、我々は、シーケンス番号としてNTPベースのタイムスタンプ値を使用することができます。 NTPタイムスタンプのロールオーバー期間がはるかに長いキーのいずれかの合理的な寿命より、およそ136年です。また、NTPタイムスタンプの粒度は、すべて200ピコ秒与えられたキーのRSVPメッセージの生成を可能にするのに十分で結構です。多くのリアルタイムクロックモジュールは、NTPタイムスタンプの解像度を持っていません。これらのケースでは、タイムスタンプの最下位ビットは各クロックティックをリセットさメッセージカウンタを用いて生成することができます。リアルタイムクロックは、1秒の分解能を提供する場合、例えば、配列番号32個の最下位ビットは、メッセージカウンタを用いて生成することができます。残りの32ビットは、タイムスタンプの32個の最下位ビットが充填されています。障害発生後の回復時間は、リアルタイムクロックの1つの目盛りよりも時間がかかり、下位ビットのメッセージカウンタが安全に再起動後にゼロにリセットすることができると仮定すると。"
    },
    {
      "indent": 0,
      "text": "3.3. Sequence Numbers Based on a Network Recovered Clock",
      "section_title": true,
      "ja": "3.3。ネットワーク回復しクロックに基づいてシーケンス番号"
    },
    {
      "indent": 3,
      "text": "If the device does not contain any stable storage of sequence number counters or of a real time clock, it could recover the real time clock from the network using NTP. Once the clock has been recovered following a restart, the sequence number generation procedure would be identical to the procedure described above.",
      "ja": "デバイスは、シーケンス番号カウンタのか、リアルタイムクロックのいずれかの安定した記憶装置が含まれていない場合は、NTPを使用してネットワークからのリアルタイムクロックを回復することができます。クロックが再起動後に回収された後、シーケンス番号生成手順は、上述した手順と同じであろう。"
    },
    {
      "indent": 0,
      "text": "4. Message Processing",
      "section_title": true,
      "ja": "4.メッセージ処理"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD allow specification of interfaces that are to be secured, for either sending messages, or receiving them, or both. The sender must ensure that all RSVP messages sent on secured sending interfaces include an INTEGRITY object, generated using the appropriate Key. Receivers verify whether RSVP messages, except of the type \"Integrity Challenge\" (Section 4.3), arriving on a secured receiving interface contain the INTEGRITY object. If the INTEGRITY object is absent, the receiver discards the message.",
      "ja": "実装は、インターフェースの仕様は、メッセージを送信し、またはそれらを受信する、あるいはその両方のために、固定することを可能にするべきです。送信者は、セキュアな送信のインターフェイス上で送信されたすべてのRSVPメッセージは、適切なキーを使用して生成さINTEGRITYオブジェクトを、含まれていることを確認する必要があります。レシーバは、セキュリティで保護された受信インターフェイスに到着タイプ「整合性の挑戦」（4.3節）のを除き、RSVPメッセージは、INTEGRITYオブジェクトが含まれているかどうかを確認します。 INTEGRITYオブジェクトが存在しない場合、受信機はメッセージを破棄する。"
    },
    {
      "indent": 3,
      "text": "Security associations are simplex - the keys that a sending system uses to sign its messages may be different from the keys that its receivers use to sign theirs. Hence, each association is associated with a unique sending system and (possibly) multiple receiving systems.",
      "ja": "セキュリティアソシエーションは単純です - 送信側のシステムはそのメッセージに署名するために使用するキーは、その受信機が彼らに署名するために使用するキーと異なる場合があります。したがって、各関連付けはユニーク送信システムと、（おそらく）複数の受信システムと関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Each sender SHOULD have distinct security associations (and keys) per secured sending interface (or LIH). While administrators may configure all the routers and hosts on a subnet (or for that matter, in their network) using a single security association, implementations MUST assume that each sender may send using a distinct security association on each secured interface. At the sender, security association selection is based on the interface through which the message is sent. This selection MAY include additional criteria, such as the destination address (when sending the message unicast, over a broadcast LAN with a large number of hosts) or user identities at the sender or receivers [2]. Finally, all intended message recipients should participate in this security association. Route flaps in a non RSVP cloud might cause messages for the same receiver to be sent on different interfaces at different times. In such cases, the receivers should participate in all possible security associations that may be selected for the interfaces through which the message might be sent.",
      "ja": "各送信者が確保送信インターフェイス（またはLIH）ごとに個別のセキュリティアソシエーション（およびキー）を持つべきである（SHOULD）。管理者は、単一のセキュリティアソシエーションを使用して（またはそのことについて、彼らのネットワーク内）サブネット上のすべてのルータおよびホストを構成することができるが、実装は、各送信者が各セキュアインターフェイス上の別個のセキュリティ・アソシエーションを使用して送信することができると仮定しなければなりません。送信側で、セキュリティアソシエーションの選択は、メッセージが送信されるインターフェイスに基づいています。この選択は、[2]の送信者または受信機において、宛先アドレス（ホストの数が多いブロードキャストLAN上で、メッセージのユニキャストを送信する場合）またはユーザIDなどの追加の基準を含んでもよいです。最後に、すべての意図したメッセージの受信者は、このセキュリティアソシエーションに参加すべきです。非RSVPクラウド内のルートフラップが同じ受信機のためのメッセージは、異なる時間に異なるインターフェイス上で送信される場合があります。このような場合、受信機は、メッセージが送信されるかもしれない、それを通してインターフェイスのために選択することができるすべての可能なセキュリティアソシエーションに参加すべきです。"
    },
    {
      "indent": 3,
      "text": "Receivers select keys based on the Key Identifier and the sending system's IP address. The Key Identifier is included in the INTEGRITY object. The sending system's address can be obtained either from the RSVP_HOP object, or if that's not present (as is the case with PathErr and ResvConf messages) from the IP source address. Since the Key Identifier is unique for a sender, this method uniquely identifies the key.",
      "ja": "キー識別子と送信側システムのIPアドレスに基づいて受信機選択キー。キー識別子はINTEGRITYオブジェクトに含まれています。 IPソースアドレスから（のPathErrとResvConfメッセージの場合のように）送信システムのアドレスのいずれかRSVP_HOPオブジェクトから取得することができ、またはそれが存在しない場合。キー識別子は、送信者のためにユニークであるので、この方法は、一意のキーを識別する。"
    },
    {
      "indent": 3,
      "text": "The integrity mechanism slightly modifies the processing rules for RSVP messages, both when including the INTEGRITY object in a message sent over a secured sending interface and when accepting a message received on a secured receiving interface. These modifications are detailed below.",
      "ja": "固定受信インターフェイス上で受信されたメッセージを受け付けると固定送信インターフェースを介して送信されたメッセージに完全性物体を含むとき完全性機構はわずかに両方の、RSVPメッセージの処理ルールを修正します。これらの変更は、以下に詳述されています。"
    },
    {
      "indent": 0,
      "text": "4.1. Message Generation",
      "section_title": true,
      "ja": "4.1。メッセージ生成"
    },
    {
      "indent": 3,
      "text": "For an RSVP message sent over a secured sending interface, the message is created as described in [1], with these exceptions:",
      "ja": "[1]で説明したようにセキュア送信インタフェースを介して送信されたRSVPメッセージのために、メッセージは、これらの例外を除いて、作成されます。"
    },
    {
      "indent": 5,
      "text": "(1) The RSVP checksum field is set to zero. If required, an RSVP checksum can be calculated when the processing of the INTEGRITY object is complete.",
      "ja": "（1）RSVPチェックサムフィールドはゼロに設定されます。必要に応じてINTEGRITYオブジェクトの処理が完了したとき、RSVPチェックサムを計算することができます。"
    },
    {
      "indent": 5,
      "text": "(2) The INTEGRITY object is inserted in the appropriate place, and its location in the message is remembered for later use.",
      "ja": "（2）INTEGRITYオブジェクトが適切な場所に挿入され、メッセージ中のその位置は、後の使用のために記憶されています。"
    },
    {
      "indent": 5,
      "text": "(3) The sending interface and other appropriate criteria (as mentioned above) are used to determine the Authentication Key and the hash algorithm to be used.",
      "ja": "（3）送信インタフェース及び他の適切な基準は、（上述のように）認証キーとハッシュアルゴリズムを使用するかを決定するために使用されます。"
    },
    {
      "indent": 5,
      "text": "(4) The unused flags and the reserved field in the INTEGRITY object MUST be set to 0. The Handshake Flag (HF) should be set according to rules specified in Section 2.1.",
      "ja": "（4）INTEGRITYオブジェクト内の未使用フラグおよび予約フィールドが0ザ・ハンドシェイクフラグを設定しなければなりません（HF）セクション2.1で指定された規則に従って設定されなければなりません。"
    },
    {
      "indent": 5,
      "text": "(5) The sending sequence number MUST be updated to ensure a unique, monotonically increasing number. It is then placed in the Sequence Number field of the INTEGRITY object.",
      "ja": "（5）送信シーケンス番号は、固有の、単調に増加する数を確保するために更新されなければなりません。次に、それをINTEGRITYオブジェクトのシーケンス番号フィールドに配置されます。"
    },
    {
      "indent": 5,
      "text": "(6) The Keyed Message Digest field is set to zero.",
      "ja": "（6）鍵付きメッセージダイジェストフィールドがゼロに設定されます。"
    },
    {
      "indent": 5,
      "text": "(7) The Key Identifier is placed into the INTEGRITY object.",
      "ja": "（7）鍵識別子はINTEGRITYオブジェクトに配置されます。"
    },
    {
      "indent": 5,
      "text": "(8) An authenticating digest of the message is computed using the Authentication Key in conjunction with the keyed-hash algorithm. When the HMAC-MD5 algorithm is used, the hash calculation is described in [7].",
      "ja": "（8）メッセージの認証ダイジェストは鍵付きハッシュアルゴリズムと併せて認証キーを使用して計算されます。 HMAC-MD5アルゴリズムを使用した場合、ハッシュ計算は、[7]に記載されています。"
    },
    {
      "indent": 5,
      "text": "(9) The digest is written into the Cryptographic Digest field of the INTEGRITY object.",
      "ja": "（9）ダイジェストはINTEGRITYオブジェクトの暗号ダイジェストフィールドに書き込まれます。"
    },
    {
      "indent": 0,
      "text": "4.2. Message Reception",
      "section_title": true,
      "ja": "4.2。メッセージ受信"
    },
    {
      "indent": 3,
      "text": "When the message is received on a secured receiving interface, and is not of the type \"Integrity Challenge\", it is processed in the following manner:",
      "ja": "メッセージは、セキュアな受信インタフェース上で受信し、タイプ「インテグリティチャレンジ」のではない場合、それは次のように処理されます。"
    },
    {
      "indent": 5,
      "text": "(1) The RSVP checksum field is saved and the field is subsequently set to zero.",
      "ja": "（1）RSVPチェックサムフィールドが保存され、フィールドが続いてゼロに設定されます。"
    },
    {
      "indent": 5,
      "text": "(2) The Cryptographic Digest field of the INTEGRITY object is saved and the field is subsequently set to zero.",
      "ja": "（2）INTEGRITYオブジェクトの暗号ダイジェストフィールドが保存され、フィールドが続いてゼロに設定されます。"
    },
    {
      "indent": 5,
      "text": "(3) The Key Identifier field and the sending system address are used to uniquely determine the Authentication Key and the hash algorithm to be used. Processing of this packet might be delayed when the Key Management System (Appendix 1) is queried for this information.",
      "ja": "（3）キー識別子フィールドと送信システムアドレスが一意に認証キーとハッシュアルゴリズムを使用することを決定するために使用されます。キー管理システム（付録1）は、この情報が照会されたときに、このパケットの処理が遅れる場合がございます。"
    },
    {
      "indent": 5,
      "text": "(4) A new keyed-digest is calculated using the indicated algorithm and the Authentication Key.",
      "ja": "（4）新たなキー入力-ダイジェストが示されたアルゴリズムと認証キーを使用して計算されます。"
    },
    {
      "indent": 5,
      "text": "(5) If the calculated digest does not match the received digest, the message is discarded without further processing.",
      "ja": "算出されたダイジェストは、受信したダイジェストと一致しない場合（5）、メッセージをさらに処理することなく破棄されます。"
    },
    {
      "indent": 5,
      "text": "(6) If the message is of type \"Integrity Response\", verify that the CHALLENGE object identically matches the originated challenge. If it matches, save the sequence number in the INTEGRITY object as the largest sequence number received to date.",
      "ja": "メッセージタイプ「整合性応答」である場合（6）、CHALLENGEオブジェクトが同じ発信チャレンジと一致することを検証します。それが一致した場合、最大シーケンス番号がこれまでに受け取ったとして、INTEGRITYオブジェクトのシーケンス番号を保存します。"
    },
    {
      "indent": 10,
      "text": "Otherwise, for all other RSVP Messages, the sequence number is\nvalidated to prevent replay attacks, and messages with invalid\nsequence numbers are ignored by the receiver.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "When a message is accepted, the sequence number of that message could update a stored value corresponding to the largest sequence number received to date. Each subsequent message must then have a larger (modulo 2^64) sequence number to be accepted. This simple processing rule prevents message replay attacks, but it must be modified to tolerate limited out-of-order message delivery. For example, if several messages were sent in a burst (in a periodic refresh generated by a router, or as a result of a tear down function), they might get reordered and then the sequence numbers would not be received in an increasing order.",
      "ja": "メッセージが受け付けられると、そのメッセージのシーケンス番号は、現在までに受信した最大のシーケンス番号に対応する格納された値を更新することができました。各後続メッセージは、シーケンス番号が受け入れられるように、より大きな（モジュロ2 ^ 64）を有していなければなりません。この単純な処理ルールは、メッセージリプレイ攻撃を防ぐことが、限られたアウトオブオーダーメッセージ配信を許容するように変更する必要があります。いくつかのメッセージがバーストで送信された場合例えば、（ルータによって生成された定期的な更新で、または涙ダウン機能の結果として）、彼らは、並べ替えてしまうかもしれませんし、その後のシーケンス番号が昇順で受信されません。"
    },
    {
      "indent": 10,
      "text": "An implementation SHOULD allow administrative configuration that sets the receiver's tolerance to out-of-order message delivery. A simple approach would allow administrators to specify a message window corresponding to the worst case reordering behavior. For example, one might specify that packets reordered within a 32 message window would be accepted. If no reordering can occur, the window is set to one.",
      "ja": "実装は、アウトオブオーダーメッセージ配信にレシーバの許容範囲を設定し、管理者の設定を可能にしなければなりません。単純なアプローチは、管理者が行動を並べ替え、最悪の場合に対応するメッセージウィンドウを指定することができるようになります。例えば、一方が32メッセージウィンドウ内で並べ替えパケットは受け入れられるように指定するかもしれません。何の並べ替えが発生しないことができる場合、ウィンドウは1に設定されています。"
    },
    {
      "indent": 10,
      "text": "The receiver must store a list of all sequence numbers seen within the reordering window. A received sequence number is valid if (a) it is greater than the maximum sequence number received or (b) it is a past sequence number lying within the reordering window and not recorded in the list. Acceptance of a sequence number implies adding it to the list and removing a number from the lower end of the list. Messages received with sequence numbers lying below the lower end of the list or marked seen in the list are discarded.",
      "ja": "受信機は、並べ替えウィンドウ内で見られるすべてのシーケンス番号のリストを格納する必要があります。 （a）は、受信した最大シーケンス番号よりも大きいか、（B）は並べ替えウィンドウ内にある過去のシーケンス番号であり、リストに記録されていない場合は、受信したシーケンス番号が有効です。シーケンス番号の受諾リストに追加し、リストの下端から番号を削除する意味しています。メッセージは、リストの下端の下にあるシーケンス番号で受信または破棄されるリストで見られるとマーク。"
    },
    {
      "indent": 3,
      "text": "When an \"Integrity Challenge\" message is received on a secured sending interface it is processed in the following manner:",
      "ja": "「インテグリティチャレンジ」メッセージが確保送信インターフェイス上で受信されたとき、それは、以下のように処理されます。"
    },
    {
      "indent": 5,
      "text": "(1) An \"Integrity Response\" message is formed using the Challenge object received in the challenge message.",
      "ja": "（1）「整合性応答」メッセージは、チャレンジメッセージで受信したチャレンジ・オブジェクトを使用して形成されています。"
    },
    {
      "indent": 5,
      "text": "(2) The message is sent back to the receiver, based on the source IP address of the challenge message, using the \"Message Generation\" steps outlined above. The selection of the Authentication Key and the hash algorithm to be used is determined by the key identifier supplied in the challenge message.",
      "ja": "（2）メッセージが上記で概説「メッセージ生成」手順を使用して、チャレンジメッセージの送信元IPアドレスに基づいて、受信機に返送されます。認証キーと、使用するハッシュアルゴリズムの選択は、チャレンジメッセージで供給キー識別子によって決定されます。"
    },
    {
      "indent": 0,
      "text": "4.3. Integrity Handshake at Restart or Initialization of the Receiver",
      "section_title": true,
      "ja": "4.3。再起動またはReceiverの初期化時に整合性のハンドシェイク"
    },
    {
      "indent": 3,
      "text": "To obtain the starting sequence number for a live Authentication Key, the receiver MAY initiate an integrity handshake with the sender. This handshake consists of a receiver's Challenge and the sender's Response, and may be either initiated during restart or postponed until a message signed with that key arrives.",
      "ja": "ライブ認証キーの開始シーケンス番号を取得するには、受信側は送信側との整合性のハンドシェイクを開始することができます。このハンドシェイクは、受信者のチャレンジと送信者の応答で構成されており、そのキーで署名されたメッセージが到着するまでのいずれかの再起動時に開始されるか、または延期することができます。"
    },
    {
      "indent": 3,
      "text": "Once the receiver has decided to initiate an integrity handshake for a particular Authentication Key, it identifies the sender using the sending system's address configured in the corresponding security association. The receiver then sends an RSVP Integrity Challenge message to the sender. This message contains the Key Identifier to identify the sender's key and MUST have a unique challenge cookie that is based on a local secret to prevent guessing. see Section 2.5.3 of [4]). It is suggested that the cookie be an MD5 hash of a local secret and a timestamp to provide uniqueness (see Section 9).",
      "ja": "受信機は、特定の認証キーの完全性ハンドシェイクを開始することを決定した後、それは対応するセキュリティアソシエーションに構成され、送信側システムのアドレスを使用して送信者を識別する。そして、受信機は、送信者にRSVP整合性チャレンジメッセージを送信します。このメッセージは送信者のキーを識別するためのキー識別子が含まれていると推測防ぐために、地元の秘密に基づいて独自の挑戦クッキーを持たなければなりません。 [4]）のセクション2.5.3を参照。クッキー（セクション9を参照）は、ローカル秘密のMD5ハッシュと一意性を提供するためのタイムスタンプであることを示唆しています。"
    },
    {
      "indent": 3,
      "text": "An RSVP Integrity Challenge message will carry a message type of 11. The message format is as follows:",
      "ja": "RSVP整合性チャレンジメッセージは、11のメッセージフォーマットのメッセージタイプを運ぶ以下の通りであります："
    },
    {
      "indent": 5,
      "text": "<Integrity Challenge message> ::= <Common Header> <CHALLENGE>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "he CHALLENGE object has the following format:",
      "ja": "CHALLENGEオブジェクトの形式は次のとおりです。"
    },
    {
      "indent": 16,
      "text": "CHALLENGE Object: Class = 64, C-Type = 1",
      "ja": "CHALLENGEオブジェクト：クラス= 64、C-タイプ= 1"
    },
    {
      "indent": 7,
      "text": "+-------------+-------------+-------------+-------------+\n|        0 (Reserved)       |                           |\n+-------------+-------------+                           +\n|                    Key Identifier                     |\n+-------------+-------------+-------------+-------------+\n|                    Challenge Cookie                   |\n|                                                       |\n+-------------+-------------+-------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sender accepts the \"Integrity Challenge\" without doing an integrity check. It returns an RSVP \"Integrity Response\" message that contains the original CHALLENGE object. It also includes an INTEGRITY object, signed with the key specified by the Key Identifier included in the \"Integrity Challenge\".",
      "ja": "送信者は、整合性チェックを行わず、「整合性の挑戦」を受け入れます。これは、元CHALLENGEオブジェクトを含むRSVP「整合性応答」メッセージを返します。また、キー識別子で指定された鍵で署名されたINTEGRITYオブジェクトは、「インテグリティチャレンジ」に含ま含みます。"
    },
    {
      "indent": 3,
      "text": "An RSVP Integrity Response message will carry a message type of 12. The message format is as follows:",
      "ja": "RSVP整合レスポンスメッセージ12のメッセージフォーマットのメッセージタイプを運ぶ以下の通りであります："
    },
    {
      "indent": 5,
      "text": "<Integrity Response message> ::= <Common Header> <INTEGRITY>\n                                 <CHALLENGE>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"Integrity Response\" message is accepted by the receiver (challenger) only if the returned CHALLENGE object matches the one sent in the \"Integrity Challenge\" message. This prevents replay of old \"Integrity Response\" messages. If the match is successful, the receiver saves the Sequence Number from the INTEGRITY object as the latest sequence number received with the key identifier included in the CHALLENGE.",
      "ja": "「整合性応答」メッセージが返さCHALLENGEオブジェクトが「インテグリティチャレンジ」メッセージで送信されたものと一致する場合にのみ、受信機（チャレンジャー）によって受け入れられます。これは、古い「整合性応答」メッセージのリプレイを防ぐことができます。マッチが成功した場合、受信機はCHALLENGEに含まれる鍵識別子を受信した最新のシーケンス番号としてINTEGRITYオブジェクトからシーケンス番号が保存されます。"
    },
    {
      "indent": 3,
      "text": "If a response is not received within a given period of time, the challenge is repeated. When the integrity handshake successfully completes, the receiver begins accepting normal RSVP signaling messages from that sender and ignores any other \"Integrity Response\" messages.",
      "ja": "応答が所定の期間内に受信されない場合は、挑戦は繰り返されます。整合性のハンドシェイクが正常に完了すると、受信機は、その送信者からの通常のRSVPシグナリングメッセージを受け入れ始め、他の「整合性の応答」メッセージを無視します。"
    },
    {
      "indent": 3,
      "text": "The Handshake Flag (HF) is used to allow implementations the flexibility of not including the integrity handshake mechanism. By setting this flag to 1, message senders that implement the integrity handshake distinguish themselves from those that do not. Receivers SHOULD NOT attempt to handshake with senders whose INTEGRITY object has HF = 0.",
      "ja": "ハンドシェイクフラグ（HF）は、実装に完全性ハンドシェーク機構を含まないの柔軟性を可能にするために使用されます。このフラグを1に設定することで、整合性握手を実装するメッセージの送信者は、そうでないものから身を区別します。レシーバは、そのINTEGRITYオブジェクトHF = 0を持っている送信者とハンドシェイクを試みるべきではありません。"
    },
    {
      "indent": 3,
      "text": "An integrity handshake may not be necessary in all environments. A common use of RSVP integrity will be between peering domain routers, which are likely to be processing a steady stream of RSVP messages due to aggregation effects. When a router restarts after a crash, valid RSVP messages from peering senders will probably arrive within a short time. Assuming that replay messages are injected into the stream of valid RSVP messages, there may be only a small window of opportunity for a replay attack before a valid message is processed. This valid message will set the largest sequence number seen to a value greater than any number that had been stored prior to the crash, preventing any further replays.",
      "ja": "整合性の握手は、すべての環境で必要ではないかもしれません。 RSVPの整合性の一般的な使用は、凝集効果にRSVPメッセージの安定したストリームを処理する可能性があるドメインルータを、ピアリングの間になります。ルータがクラッシュした後に再起動すると、ピアリング送信者から有効なRSVPメッセージは、おそらく短い時間内に到着します。有効なメッセージが処理される前に、メッセージが有効なRSVPメッセージの流れの中に注入されるリプレイを想定すると、リプレイ攻撃の機会のほんの窓があるかもしれません。この有効なメッセージはそれ以上のリプレイを防ぐ、クラッシュする前に保存されていた任意の数よりも大きい値に見られる最大のシーケンス番号を設定します。"
    },
    {
      "indent": 3,
      "text": "On the other hand, not using an integrity handshake could allow exposure to replay attacks if there is a long period of silence from a given sender following a restart of a receiver. Hence, it SHOULD be an administrative decision whether or not the receiver performs an integrity handshake with senders that are willing to respond to \"Integrity Challenge\" messages, and whether it accepts any messages from senders that refuse to do so. These decisions will be based on assumptions related to a particular network environment.",
      "ja": "一方、整合性のハンドシェイクを使用していないと、受信機の再起動後、与えられた送信者からの沈黙の長い期間がある場合、露出がリプレイ攻撃する可能性があります。したがって、受信機は、「整合性のチャレンジ」のメッセージに応答して喜んでいる送信者との整合性のハンドシェイクを実行するか否か行政の決定であるべきであり、それがそうすることを拒否した送信者からのメッセージを受け入れるかどうか。これらの決定は、特定のネットワーク環境に関連した仮定に基づいて行われます。"
    },
    {
      "indent": 0,
      "text": "5. Key Management",
      "section_title": true,
      "ja": "5.キー管理"
    },
    {
      "indent": 3,
      "text": "It is likely that the IETF will define a standard key management protocol. It is strongly desirable to use that key management protocol to distribute RSVP Authentication Keys among communicating RSVP implementations. Such a protocol would provide scalability and significantly reduce the human administrative burden. The Key Identifier can be used as a hook between RSVP and such a future protocol. Key management protocols have a long history of subtle flaws that are often discovered long after the protocol was first described in public. To avoid having to change all RSVP implementations should such a flaw be discovered, integrated key management protocol techniques were deliberately omitted from this specification.",
      "ja": "IETFが標準キー管理プロトコルを定義する可能性があります。通信RSVP実装間RSVP認証キーを配布するために、その鍵管理プロトコルを使用することが強く望まれます。このようなプロトコルは、拡張性を提供し、大幅に人間の管理負担を軽減します。キー識別子は、RSVPと、そのような将来のプロトコルとの間のフックとして使用することができます。鍵管理プロトコルは、プロトコルが最初の公開で説明した後、多くの場合、長い発見される微妙な欠陥の長い歴史を持っています。このような欠陥が発見されなければならないすべてのRSVP実装を変更することを避けるために、統合された鍵管理プロトコル技術が故意にこの仕様書から除外されました。"
    },
    {
      "indent": 0,
      "text": "5.1. Key Management Procedures",
      "section_title": true,
      "ja": "5.1。キー管理手順"
    },
    {
      "indent": 3,
      "text": "Each key has a lifetime associated with it that is recorded in all systems (sender and receivers) configured with that key. The concept of a \"key lifetime\" merely requires that the earliest (KeyStartValid) and latest (KeyEndValid) times that the key is valid be programmable in a way the system understands. Certain key generation mechanisms, such as Kerberos or some public key schemes, may directly produce ephemeral keys. In this case, the lifetime of the key is implicitly defined as part of the key.",
      "ja": "各キーは、そのキーで構成されたすべてのシステム（送信者と受信機）に記録され、それに関連付けられた寿命を有します。 「キー生涯」の概念は、単にキーが有効である（KeyStartValid）最初と最後の（KeyEndValid）回というシステムが理解する方法でプログラム可能であることが必要です。そのようなケルベロスまたはいくつかの公開鍵方式などの特定の鍵生成メカニズムは、直接はかないキーを生成することができます。この場合、キーの寿命は、暗黙的にキーの一部として定義されます。"
    },
    {
      "indent": 3,
      "text": "In general, no key is ever used outside its lifetime (but see Section 5.3). Possible mechanisms for managing key lifetime include the Network Time Protocol and hardware time-of-day clocks.",
      "ja": "一般的には、何のキーは、これまでその寿命外で使用されていません（ただし、5.3節を参照してください）。キーの有効期間を管理するための可能なメカニズムは、ネットワーク・タイム・プロトコルおよびハードウェアの時刻クロックが含まれます。"
    },
    {
      "indent": 3,
      "text": "To maintain security, it is advisable to change the RSVP Authentication Key on a regular basis. It should be possible to switch the RSVP Authentication Key without loss of RSVP state or denial of reservation service, and without requiring people to change all the keys at once. This requires an RSVP implementation to support the storage and use of more than one active RSVP Authentication Key at the same time. Hence both the sender and receivers might have multiple active keys for a given security association.",
      "ja": "セキュリティを維持するためには、定期的にRSVP認証キーを変更することをお勧めします。一度にすべてのキーを変更するために人々を必要とせずにRSVP状態または予約サービス拒否を損なうことなく、RSVP認証キーを切り替えることが可能でなければなりません。これは、同時に複数のアクティブなRSVP認証キーの保管や使用をサポートするために、RSVPの実装が必要です。したがって、送信者と受信者の両方が与えられたセキュリティアソシエーションのために複数のアクティブなキーを持っているかもしれません。"
    },
    {
      "indent": 3,
      "text": "Since keys are shared between a sender and (possibly) multiple receivers, there is a region of uncertainty around the time of key switch-over during which some systems may still be using the old key and others might have switched to the new key. The size of this uncertainty region is related to clock synchrony of the systems. Administrators should configure the overlap between the expiration time of the old key (KeyEndValid) and the validity of the new key (KeyStartValid) to be at least twice the size of this uncertainty interval. This will allow the sender to make the key switch-over at the midpoint of this interval and be confident that all receivers are now accepting the new key. For the duration of the overlap in key lifetimes, a receiver must be prepared to authenticate messages using either key.",
      "ja": "キーは、送信者と（おそらく）複数の受信機の間で共有されているので、不確実性の領域は、いくつかのシステムがまだ古いキーなどを使用している場合があり、その間、キースイッチオーバーの時期があり、新しいキーに切り替えている場合があります。この不確定領域のサイズは、システムのクロック同期に関連しています。管理者は、この不確実性間隔の少なくとも2倍のサイズであることを古いキー（KeyEndValid）の有効期限、新しいキー（KeyStartValid）の有効性との間のオーバーラップを設定する必要があります。これは、送信者がこの区間の中間点で、キースイッチオーバーを作成し、すべての受信機は、新しい鍵を受け入れていることを確信できるようになります。キーの有効期間におけるオーバーラップの持続時間の間、受信機は、いずれかのキーを使用してメッセージを認証するために用意されなければなりません。"
    },
    {
      "indent": 3,
      "text": "During a key switch-over, it will be necessary for each receiver to handshake with the sender using the new key. As stated before, a receiver has the choice of initiating a handshake during the switchover or postponing the handshake until the receipt of a message using that key.",
      "ja": "各受信機は新しいキーを使用して、送信者とハンドシェイクするためのキースイッチオーバー時には、それが必要になります。前に述べたように、受信機は、スイッチオーバー中のハンドシェイクを開始するか、その鍵を使ってメッセージを受信するまで握手を延期する選択肢を持っています。"
    },
    {
      "indent": 0,
      "text": "5.2. Key Management Requirements",
      "section_title": true,
      "ja": "5.2。キー管理の要件"
    },
    {
      "indent": 3,
      "text": "Requirements on an implementation are as follows:",
      "ja": "以下のような実装上の要件は以下のとおりです。"
    },
    {
      "indent": 5,
      "text": "o It is strongly desirable that a hypothetical security breach in one Internet protocol not automatically compromise other Internet protocols. The Authentication Key of this specification SHOULD NOT be stored using protocols or algorithms that have known flaws.",
      "ja": "O 1つのインターネットプロトコルで仮想的なセキュリティ侵害が自動的に他のインターネットプロトコルを妥協しないことを強く望まれます。この仕様書の認証キーは、プロトコルや傷を知っていたのアルゴリズムを使用して保存しないでください。"
    },
    {
      "indent": 5,
      "text": "o An implementation MUST support the storage and use of more than one key at the same time, for both sending and receiving systems.",
      "ja": "実装oを両方のシステムを送受信するために、同時に複数のキーの保管および使用をサポートしなければなりません。"
    },
    {
      "indent": 5,
      "text": "o An implementation MUST associate a specific lifetime (i.e., KeyStartValid and KeyEndValid) with each key and the corresponding Key Identifier.",
      "ja": "O実装は、それぞれのキーと対応するキー識別子を有する特定寿命（すなわち、KeyStartValidとKeyEndValid）を関連付ける必要があります。"
    },
    {
      "indent": 5,
      "text": "o An implementation MUST support manual key distribution (e.g., the privileged user manually typing in the key, key lifetime, and key identifier on the console). The lifetime may be infinite.",
      "ja": "O実装は、（コンソール上の例えば、特権ユーザが手動でキーを入力し、鍵の有効期間、および鍵識別子）手動鍵配布をサポートしなければなりません。寿命は無限かもしれません。"
    },
    {
      "indent": 5,
      "text": "o If more than one algorithm is supported, then the implementation MUST require that the algorithm be specified for each key at the time the other key information is entered.",
      "ja": "複数のアルゴリズムがサポートされている場合は、O、その後、実装は、アルゴリズムは、他のキー情報が入力された時点で、各キーに指定することを要求する必要があります。"
    },
    {
      "indent": 5,
      "text": "o Keys that are out of date MAY be automatically deleted by the implementation.",
      "ja": "古くなっているOキーは自動的に実装によって削除されることがあります。"
    },
    {
      "indent": 5,
      "text": "o Manual deletion of active keys MUST also be supported.",
      "ja": "Oアクティブなキーの手動削除もサポートしなければなりません。"
    },
    {
      "indent": 5,
      "text": "o Key storage SHOULD persist across a system restart, warm or cold, to ease operational usage.",
      "ja": "Oキーストレージ運用の使用を容易にするために、温かいまたは冷たい、システムの再起動間で保持すべきです。"
    },
    {
      "indent": 0,
      "text": "5.3. Pathological Case",
      "section_title": true,
      "ja": "5.3。病理学的ケース"
    },
    {
      "indent": 3,
      "text": "It is possible that the last key for a given security association has expired. When this happens, it is unacceptable to revert to an unauthenticated condition, and not advisable to disrupt current reservations. Therefore, the system should send a \"last authentication key expiration\" notification to the network manager and treat the key as having an infinite lifetime until the lifetime is extended, the key is deleted by network management, or a new key is configured.",
      "ja": "特定のセキュリティアソシエーションの最後のキーの有効期限が切れている可能性があります。これが起こるとき、現在の予約を破壊することはお勧めできません認証されていない状態に戻すために受け入れられない、と。したがって、システムは、ネットワーク管理者への「最後の認証キーの有効期限」の通知を送信し、寿命が延長されるまで、無限の寿命を持つようにキーを扱う必要があり、鍵はネットワーク管理によって削除されるか、または新しいキーが設定されています。"
    },
    {
      "indent": 0,
      "text": "6. Conformance Requirements",
      "section_title": true,
      "ja": "6.適合性要件"
    },
    {
      "indent": 3,
      "text": "To conform to this specification, an implementation MUST support all of its aspects. The HMAC-MD5 authentication algorithm defined in [7] MUST be implemented by all conforming implementations. A conforming implementation MAY also support other authentication algorithms such as NIST's Secure Hash Algorithm (SHA). Manual key distribution as described above MUST be supported by all conforming implementations. All implementations MUST support the smooth key roll over described under \"Key Management Procedures.\"",
      "ja": "この仕様に準拠するために、実装は、その態様のすべてをサポートしなければなりません。 [7]で定義されたHMAC-MD5認証アルゴリズムは、すべての準拠実装によって実装されなければなりません。適合実装はまた、NISTのセキュア・ハッシュ・アルゴリズム（SHA）などの他の認証アルゴリズムをサポートするかもしれません。上述したように手動鍵配布は、すべての準拠実装によってサポートされなければなりません。下に説明の上にすべての実装がスムーズにキーロールをサポートしなければならない「キー管理手順。」"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD support a standard key management protocol for secure distribution of RSVP Authentication Keys once such a key management protocol is standardized by the IETF.",
      "ja": "このような鍵管理プロトコルはIETFで標準化されると、実装はRSVP認証キーの安全な配布のための標準的な鍵管理プロトコルをサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Kerberos generation of RSVP Authentication Keys",
      "section_title": true,
      "ja": "RSVP認証キーの7ケルベロス生成"
    },
    {
      "indent": 3,
      "text": "Kerberos[10] MAY be used to generate the RSVP Authentication key used in generating a signature in the Integrity Object sent from a RSVP sender to a receiver. Kerberos key generation avoids the use of shared keys between RSVP senders and receivers such as hosts and routers. Kerberos allows for the use of trusted third party keying relationships between security principals (RSVP sender and receivers) where the Kerberos key distribution center(KDC) establishes an ephemeral session key that is subsequently shared between RSVP sender and receivers. In the multicast case all receivers of a multicast RSVP message MUST share a single key with the KDC (e.g. the receivers are in effect the same security principal with respect to Kerberos).",
      "ja": "ケルベロス[10]受信機にRSVP送信側から送信された整合性オブジェクトに署名を生成する際に使用されるRSVP認証鍵を生成するために用いられ得ます。ケルベロス鍵生成は、ホストやルータなどのRSVP送信側と受信側との間の共有鍵の使用を回避します。 Kerberosは、ケルベロス鍵配布センタ（KDC）は、続いてRSVP送信機と受信機の間で共有されるエフェメラルセッション鍵を確立するセキュリティプリンシパル（RSVP送信機と受信機）との関係をキーイング信頼できるサードパーティの使用を可能にします。マルチキャストの場合、マルチキャストRSVPメッセージのすべての受信機は、KDC（例えば、受信機が有効にケルベロスに対して同じセキュリティプリンシパルである）を有する単一の鍵を共有しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Key information determined by the sender MAY specify the use of Kerberos in place of configured shared keys as the mechanism for establishing a key between the sender and receiver. The Kerberos identity of the receiver is established as part of the sender's interface configuration or it can be established through other mechanisms. When generating the first RSVP message for a specific key identifier the sender requests a Kerberos service ticket and gets back an ephemeral session key and a Kerberos ticket from the KDC. The sender encapsulates the ticket and the identity of the sender in an Identity Policy Object[2]. The sender includes the Policy Object in the RSVP message. The session key is then used by the sender as the RSVP Authentication key in section 4.1 step (3) and is stored as Key information associated with the key identifier.",
      "ja": "送信者によって決定されたキー情報は、送信者と受信者の間でキーを確立するためのメカニズムとして構成された共有鍵の代わりに、ケルベロスの使用を指定するかもしれません。受信機のKerberos識別情報は、送信者のインターフェース構成の一部として確立されているか、他の機構を介して確立することができます。特定のキー識別子のための最初のRSVPメッセージを生成するとき、送信者は、Kerberosサービスチケットを要求し、はかないセッションキーとKDCからKerberosチケットを取り戻します。送信者は、チケットとアイデンティティポリシーオブジェクト[2]で、送信者の身元をカプセル化します。送信者は、RSVPメッセージ内のポリシーオブジェクトが含まれています。セッション鍵は、その後、セクション4.1、工程（3）におけるRSVP認証キーとして送信者によって使用され、鍵識別子に関連付けられたキー情報として記憶されます。"
    },
    {
      "indent": 3,
      "text": "Upon RSVP Message reception, the receiver retrieves the Kerberos Ticket from the Identity Policy Object, decrypts the ticket and retrieves the session key from the ticket. The session key is the same key as used by the sender and is used as the key in section 4.2 step (3). The receiver stores the key for use in processing subsequent RSVP messages.",
      "ja": "RSVPメッセージを受信すると、受信機は、アイデンティティポリシーオブジェクトからのKerberosチケットを取得し、チケットを復号化し、チケットからセッションキーを取得します。セッション鍵は、送信者によって使用され、セクション4.2ステップ（3）中のキーとして使用されるのと同じキーです。受信機は、後続のRSVPメッセージの処理に使用するための鍵を格納します。"
    },
    {
      "indent": 3,
      "text": "Kerberos tickets have lifetimes and the sender MUST NOT use tickets that have expired. A new ticket MUST be requested and used by the sender for the receiver prior to the ticket expiring.",
      "ja": "Kerberosチケットには寿命があり、送信者は、期限が切れたチケットを使用してはなりません。新しいチケットが要求され、チケットの満了前に受信機のために送信者によって使用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.1. Optimization when using Kerberos Based Authentication",
      "section_title": true,
      "ja": "7.1。最適化のKerberosベースの認証を使用して"
    },
    {
      "indent": 3,
      "text": "Kerberos tickets are relatively long (> 500 bytes) and it is not necessary to send a ticket in every RSVP message. The ephemeral session key can be cached by the sender and receiver and can be used for the lifetime of the Kerberos ticket. In this case, the sender only needs to include the Kerberos ticket in the first Message generated. Subsequent RSVP messages use the key identifier to retrieve the cached key (and optionally other identity information) instead of passing tickets from sender to receiver in each RSVP message.",
      "ja": "Kerberosチケットは、比較的長いです（> 500バイト）と、すべてのRSVPメッセージにチケットを送信する必要はありません。はかないセッションキーは、送信者と受信者でキャッシュできるとKerberosチケットの有効期間のために使用することができます。この場合、送信者にのみ生成された最初のメッセージにKerberosチケットを含める必要があります。その後のRSVPメッセージは、キャッシュされたキーを取得（及び他の識別情報を任意に）代わりに、各RSVPメッセージで送信側から受信側へのチケットを渡すためにキー識別子を使用します。"
    },
    {
      "indent": 3,
      "text": "A receiver may not have cached key state with an associated Key Identifier due to reboot or route changes. If the receiver's policy indicates the use of Kerberos keys for integrity checking, the receiver can send an integrity Challenge message back to the sender. Upon receiving an integrity Challenge message a sender MUST send an Identity object that includes the Kerberos ticket in the integrity Response message, thereby allowing the receiver to retrieve and store the session key from the Kerberos ticket for subsequent Integrity checking.",
      "ja": "受信機は、再起動またはルート変更に起因する関連したキー識別子とキーの状態をキャッシュしていないかもしれません。受信者のポリシーは整合性チェックのためのKerberosキーの使用を示している場合、受信側は送信者に整合性チャレンジメッセージを送ることができます。整合性チャレンジメッセージを受信すると、送信者は、これにより、受信機が確認し、その後の整合性のためのKerberosチケットからセッションキーを取得して保存することができ、整合性の応答メッセージにKerberosチケットを含んアイデンティティオブジェクトを送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgments",
      "section_title": true,
      "ja": "8.謝辞"
    },
    {
      "indent": 3,
      "text": "This document is derived directly from similar work done for OSPF and RIP Version II, jointly by Ran Atkinson and Fred Baker. Significant editing was done by Bob Braden, resulting in increased clarity. Significant comments were submitted by Steve Bellovin, who actually understands this stuff. Matt Crawford and Dan Harkins helped revise the document.",
      "ja": "この文書は、共同でのRanアトキンソンとフレッド・ベイカーで、OSPFとRIPバージョンIIのために行わ同様の作業から直接誘導されます。重要な編集が増加明快で、その結果、ボブブレーデンによって行われました。重要なコメントは、実際にこのようなものを理解し、スティーブBellovin氏によって提出されました。マット・クロフォードとダンハーキンズは、文書を改訂助けました。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 3,
      "text": "[1] Braden, R., Zhang, L., Berson, S., Herzog, S. and S. Jamin, \"Resource ReSerVation Protocol (RSVP) -- Version 1 Functional Specification\", RFC 2205, September 1997.",
      "ja": "[1]ブレーデン、R.、チャン、L.、Berson氏、S.、ハーツォグ、S.とS.ヤミン、 \"リソース予約プロトコル（RSVP） - バージョン1の機能的な仕様\"、RFC 2205、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[2] Yadav, S., et al., \"Identity Representation for RSVP\", RFC 2752, January 2000.",
      "ja": "[2] Yadavが、S.、ら、 \"RSVPのためのアイデンティティ表現\"、RFC 2752、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[3] Atkinson, R. and S. Kent, \"Security Architecture for the Internet Protocol\", RFC 2401, November 1998.",
      "ja": "[3]アトキンソン、R.とS.ケント、 \"インターネットプロトコルのためのセキュリティー体系\"、RFC 2401、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[4] Maughan, D., Schertler, M., Schneider, M. and J. Turner, \"Internet Security Association and Key Management Protocol (ISAKMP)\", RFC 2408, November 1998.",
      "ja": "[4]モーガン、D.、Schertler、M.、シュナイダー、M.とJ.ターナー、 \"インターネットセキュリティ協会と鍵管理プロトコル（ISAKMP）\"、RFC 2408、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[5] Kent, S. and R. Atkinson, \"IP Authentication Header\", RFC 2402, November 1998.",
      "ja": "[5]ケント、S.とR.アトキンソン、 \"IP認証ヘッダー\"、RFC 2402、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[6] Kent, S. and R. Atkinson, \"IP Encapsulating Security Payload (ESP)\", RFC 2406, November 1998.",
      "ja": "[6]ケント、S.とR.アトキンソン、 \"IPカプセル化セキュリティペイロード（ESP）\"、RFC 2406、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[7] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, March 1996.",
      "ja": "[7] Krawczyk、H.、ベラー、M。およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1996年3月。"
    },
    {
      "indent": 3,
      "text": "[8] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[8]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[9] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[9]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[10] Kohl, J. and C. Neuman, \"The Kerberos Network Authentication Service (V5)\", RFC 1510, September 1993.",
      "ja": "[10]コールズ、J.及びC.ノイマン、 \"ケルベロスネットワーク認証サービス（V5）\"、RFC 1510、1993年9月。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This entire memo describes and specifies an authentication mechanism for RSVP that is believed to be secure against active and passive attacks.",
      "ja": "この全体のメモは、アクティブおよび受動的攻撃に対して安全であると考えられているRSVPのための認証メカニズムを説明して指定します。"
    },
    {
      "indent": 3,
      "text": "The quality of the security provided by this mechanism depends on the strength of the implemented authentication algorithms, the strength of the key being used, and the correct implementation of the security mechanism in all communicating RSVP implementations. This mechanism also depends on the RSVP Authentication Keys being kept confidential by all parties. If any of these assumptions are incorrect or procedures are insufficiently secure, then no real security will be provided to the users of this mechanism.",
      "ja": "このメカニズムによって提供されるセキュリティの品質を実現する認証アルゴリズムの強度、使用されるキーの強さ、およびすべての通信RSVP実装のセキュリティメカニズムの正しい実装に依存します。このメカニズムは、すべての当事者が秘密にされているRSVP認証キーに依存します。これらの仮定のいずれかが間違っているか、手順が不十分に安全である場合には、本当のセキュリティは、このメカニズムのユーザに提供されません。"
    },
    {
      "indent": 3,
      "text": "While the handshake \"Integrity Response\" message is integrity-checked, the handshake \"Integrity Challenge\" message is not. This was done intentionally to avoid the case when both peering routers do not have a starting sequence number for each other's key. Consequently, they will each keep sending handshake \"Integrity Challenge\" messages that will be dropped by the other end. Moreover, requiring only the response to be integrity-checked eliminates a dependency on an security association in the opposite direction.",
      "ja": "握手「整合性応答」メッセージは整合性検査済みですが、握手「誠実チャレンジ」メッセージではありません。これは、両方のピアリングルータがお互いのキーの開始シーケンス番号を持っていない場合を避けるために、意図的に行われていました。その結果、彼らはお互いの端によって破棄されます握手「誠実チャレンジ」メッセージを送信し続けます。また、整合性チェックするのみの応答を必要とする逆方向のセキュリティアソシエーションの依存性を排除します。"
    },
    {
      "indent": 3,
      "text": "This, however, lets an intruder generate fake handshaking challenges with a certain challenge cookie. It could then save the response and attempt to play it against a receiver that is in recovery. If it was lucky enough to have guessed the challenge cookie used by the receiver at recovery time it could use the saved response. This response would be accepted, since it is properly signed, and would have a smaller sequence number for the sender because it was an old message. This opens the receiver up to replays. Still, it seems very difficult to exploit. It requires not only guessing the challenge cookie (which is based on a locally known secret) in advance, but also being able to masquerade as the receiver to generate a handshake \"Integrity Challenge\" with the proper IP address and not being caught.",
      "ja": "これは、しかし、侵入者が特定の挑戦クッキーと偽のハンドシェイクの課題を生成することができます。その後、応答を保存し、回復している受信機に対してそれを再生しようとする可能性があり。それは、回復時に受信機によって使用されるチャレンジクッキーを推測しているには十分に幸運だった場合には、保存された応答を使用することができます。この応答は、それが適切に署名されているので、受け入れられる、それは古いメッセージだったので、送信者のための小さいシーケンス番号を持っているでしょう。これは、リプレイまでのレシーバを開きます。それでも、それが活用するのは非常に難しいと思われます。これは、事前に（ローカルに知られている秘密に基づいている）チャレンジクッキーを推測するだけでなく、適切なIPアドレスとキャッチされていないとの握手「誠実チャレンジ」を生成するために受信機になりすますことができないだけで必要です。"
    },
    {
      "indent": 3,
      "text": "Confidentiality is not provided by this mechanism. If confidentiality is required, IPSEC ESP [6] may be the best approach, although it is subject to the same criticisms as IPSEC Authentication, and therefore would be applicable only in specific environments. Protection against traffic analysis is also not provided. Mechanisms such as bulk link encryption might be used when protection against traffic analysis is required.",
      "ja": "機密性は、このメカニズムによって提供されていません。機密性が必要な場合、IPSEC ESP [6]がIPSEC認証と同じ批判対象であるが、最善の方法であってもよく、従って、特定の環境に適用可能であろう。トラフィック分析に対する保護も提供されていません。トラフィック解析からの保護が必要な場合に、このようなバルクリンク暗号化などのメカニズムが使用される可能性があります。"
    },
    {
      "indent": 0,
      "text": "11. Authors' Addresses",
      "section_title": true,
      "ja": "11.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Fred Baker Cisco Systems 519 Lado Drive Santa Barbara, CA 93111",
      "ja": "フレッドベイカーシスコシステムズ519ラドドライブサンタバーバラ、CA 93111"
    },
    {
      "indent": 3,
      "text": "Phone: (408) 526-4257 EMail: fred@cisco.com",
      "ja": "電話：（408）526-4257 Eメール：fred@cisco.com"
    },
    {
      "indent": 3,
      "text": "Bob Lindell USC Information Sciences Institute 4676 Admiralty Way Marina del Rey, CA 90292",
      "ja": "ボブ・リンデルUSC情報科学研究所4676アドミラルティWayマリナデルレイ、CA 90292"
    },
    {
      "indent": 3,
      "text": "Phone: (310) 822-1511 EMail: lindell@ISI.EDU",
      "ja": "電話：（310）822-1511 Eメール：lindell@ISI.EDU"
    },
    {
      "indent": 3,
      "text": "Mohit Talwar Microsoft Corporation One Microsoft Way Redmond, WA 98052",
      "ja": "Mohit Talwarマイクロソフト社1マイクロソフト道、レッドモンド、ワシントン98052"
    },
    {
      "indent": 3,
      "text": "Phone: +1 425 705 3131 EMail: mohitt@microsoft.com",
      "ja": "電話：+1 425 705 3131 Eメール：mohitt@microsoft.com"
    },
    {
      "indent": 0,
      "text": "12. Appendix 1: Key Management Interface",
      "section_title": true,
      "ja": "12.付録1：キー管理インターフェイス"
    },
    {
      "indent": 3,
      "text": "This appendix describes a generic interface to Key Management. This description is at an abstract level realizing that implementations may need to introduce small variations to the actual interface.",
      "ja": "この付録では、キー管理するための一般的なインターフェースを説明しています。この説明は、実装が実際のインターフェースに小さな変化を導入する必要があるかもしれないことを実現する抽象レベルです。"
    },
    {
      "indent": 3,
      "text": "At the start of execution, RSVP would use this interface to obtain the current set of relevant keys for sending and receiving messages. During execution, RSVP can query for specific keys given a Key Identifier and Source Address, discover newly created keys, and be informed of those keys that have been deleted. The interface provides both a polling and asynchronous upcall style for wider applicability.",
      "ja": "実行の開始時に、RSVPは、メッセージの送受信のために、関連するキーの現在のセットを取得するために、このインターフェイスを使用します。実行時には、RSVPは、キー識別子と送信元アドレスを指定した特定のキーを照会新しく作成された鍵を発見し、削除されたそれらのキーを知ることができます。インターフェイスは、より広い適用のためのポーリングおよび非同期アップコールスタイルの両方を提供します。"
    },
    {
      "indent": 0,
      "text": "12.1. Data Structures",
      "section_title": true,
      "ja": "12.1。データ構造"
    },
    {
      "indent": 3,
      "text": "Information about keys is returned using the following KeyInfo data structure:",
      "ja": "キーに関する情報は、次のキー情報のデータ構造を使用して返されます。"
    },
    {
      "indent": 5,
      "text": "KeyInfo { Key Type (Send or Receive) KeyIdentifier Key Authentication Algorithm Type and Mode KeyStartValid KeyEndValid Status (Active or Deleted) Outgoing Interface (for Send only) Other Outgoing Security Association Selection Criteria (for Send only, optional) Sending System Address (for Receive Only) }",
      "ja": "KeyInfoに{受信のためのキータイプ（送信または受信）の送信システムアドレス（のみ、オプションの送信のための）他の発信セキュリティアソシエーションの選択基準（送信のみ）KeyIdentifier鍵認証アルゴリズムの種類とモードKeyStartValid KeyEndValidステータス（アクティブまたは削除済み）発信インターフェイス（のみ）}"
    },
    {
      "indent": 0,
      "text": "12.2. Default Key Table",
      "section_title": true,
      "ja": "12.2。デフォルトのキーテーブル"
    },
    {
      "indent": 3,
      "text": "This function returns a list of KeyInfo data structures corresponding to all of the keys that are configured for sending and receiving RSVP messages and have an Active Status. This function is usually called at the start of execution but there is no limit on the number of times that it may be called.",
      "ja": "この関数は、RSVPメッセージを送受信するために設定し、アクティブステータスを持っている全てのキーに対応するキー情報のデータ構造のリストを返します。この機能は、通常、実行の開始時に呼び出されるが、それが呼ばれる回数に制限はありません。"
    },
    {
      "indent": 5,
      "text": "KM_DefaultKeyTable() -> KeyInfoList",
      "ja": "KM_DefaultKeyTable（） - > KeyInfoList"
    },
    {
      "indent": 0,
      "text": "12.3. Querying for Unknown Receive Keys",
      "section_title": true,
      "ja": "12.3。不明な受信キーの問い合わせ"
    },
    {
      "indent": 3,
      "text": "When a message arrives with an unknown Key Identifier and Sending System Address pair, RSVP can use this function to query the Key Management System for the appropriate key. The status of the element returned, if any, must be Active.",
      "ja": "メッセージが未知のキー識別子と送信側システムのアドレスのペアで到着すると、RSVPは、適切なキーのためのキー管理システムを照会するために、この機能を使用することができます。要素のステータスが存在する場合、返された、アクティブでなければなりません。"
    },
    {
      "indent": 5,
      "text": "KM_GetRecvKey( INTEGRITY Object, SrcAddress ) -> KeyInfo",
      "ja": "KM_GetRecvKey（INTEGRITYオブジェクト、srcaddress送信） - >のKeyInfo"
    },
    {
      "indent": 0,
      "text": "12.4. Polling for Updates",
      "section_title": true,
      "ja": "12.4。更新のポーリング"
    },
    {
      "indent": 3,
      "text": "This function returns a list of KeyInfo data structures corresponding to any incremental changes that have been made to the default key table or requested keys since the last call to either KM_KeyTablePoll, KM_DefaultKeyTable, or KM_GetRecvKey. The status of some elements in the returned list may be set to Deleted.",
      "ja": "この関数はKM_KeyTablePoll、KM_DefaultKeyTable、またはKM_GetRecvKeyのいずれかへの最後の呼び出しのために、デフォルトのキーテーブルまたは要求されたキーに行われたすべての増分変化に対応したキー情報のデータ構造のリストを返します。返されたリストにあるいくつかの要素のステータスは削除済に設定することができます。"
    },
    {
      "indent": 6,
      "text": "KM_KeyTablePoll() -> KeyInfoList",
      "ja": "KM_KeyTablePoll（） - > KeyInfoList"
    },
    {
      "indent": 0,
      "text": "12.5. Asynchronous Upcall Interface",
      "section_title": true,
      "ja": "12.5。非同期アップコール・インタフェース"
    },
    {
      "indent": 3,
      "text": "Rather than repeatedly calling the KM_KeyTablePoll(), an implementation may choose to use an asynchronous event model. This function registers interest to key changes for a given Key Identifier or for all keys if no Key Identifier is specified. The upcall function is called each time a change is made to a key.",
      "ja": "むしろ繰り返しKM_KeyTablePoll（）を呼び出すよりも、実装は非同期イベントモデルを使用することもできます。何のキー識別子が指定されていない場合、この関数は、指定したキー識別子またはすべてのキーのキーの変更への関心を登録します。アップコール機能は、変更がキーに作られるたびに呼ばれています。"
    },
    {
      "indent": 5,
      "text": "KM_KeyUpdate ( Function [, KeyIdentifier ] )",
      "ja": "KM_KeyUpdate（関数[、KeyIdentifier]）"
    },
    {
      "indent": 3,
      "text": "where the upcall function is parameterized as follows:",
      "ja": "次のようにアップコールの機能はパラメータです。"
    },
    {
      "indent": 5,
      "text": "Function ( KeyInfo )",
      "ja": "機能（のKeyInfo）"
    },
    {
      "indent": 0,
      "text": "13. Full Copyright Statement",
      "section_title": true,
      "ja": "13.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2000). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2000）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}