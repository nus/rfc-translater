{
  "title": {
    "text": "RFC 2292 - Advanced Sockets API for IPv6",
    "ja": "RFC 2292 - IPv6用の拡張ソケットAPI"
  },
  "number": 2292,
  "created_at": "2019-10-22 17:57:15.249595+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        W. Stevens\nRequest for Comments: 2292                                   Consultant\nCategory: Informational                                       M. Thomas\n                                                              AltaVista\n                                                          February 1998",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Advanced Sockets API for IPv6",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Specifications are in progress for changes to the sockets API to support IP version 6 [RFC-2133]. These changes are for TCP and UDP-based applications and will support most end-user applications in use today: Telnet and FTP clients and servers, HTTP clients and servers, and the like.",
      "ja": "仕様は、[RFC-2133] IPバージョン6をサポートするためのソケットAPIへの変更のために進行中です。これらの変更は、TCPおよびUDPベースのアプリケーションのためのものであり、使用されているほとんどのエンドユーザーアプリケーション今日をサポートします：TelnetやFTPクライアントとサーバ、HTTPクライアントとサーバ、などが挙げられます。"
    },
    {
      "indent": 3,
      "text": "But another class of applications exists that will also be run under IPv6. We call these \"advanced\" applications and today this includes programs such as Ping, Traceroute, routing daemons, multicast routing daemons, router discovery daemons, and the like. The API feature typically used by these programs that make them \"advanced\" is a raw socket to access ICMPv4, IGMPv4, or IPv4, along with some knowledge of the packet header formats used by these protocols. To provide portability for applications that use raw sockets under IPv6, some standardization is needed for the advanced API features.",
      "ja": "しかし、アプリケーションの別のクラスは、IPv6の下で実行されるものが存在します。我々は、これらの「高度な」アプリケーションを呼び出すと、今日、このようなPingの、トレースルート、ルーティングデーモン、マルチキャストルーティングデーモン、ルータディスカバリデーモンなどのプログラムが含まれます。通常、それら作るこれらのプログラムによって使用されるAPIの機能は、「高度な」、これらのプロトコルで使用されるパケットのヘッダフォーマットのいくつかの知識とともに、ICMPv4の、IGMPv4、またはIPv4にアクセスするために、生のソケットです。 IPv6の下rawソケットを使用するアプリケーションのための移植性を提供するために、いくつかの標準化が進んだAPI機能のために必要とされています。"
    },
    {
      "indent": 3,
      "text": "There are other features of IPv6 that some applications will need to access: interface identification (specifying the outgoing interface and determining the incoming interface) and IPv6 extension headers that are not addressed in [RFC-2133]: Hop-by-Hop options, Destination options, and the Routing header (source routing). This document provides API access to these features too.",
      "ja": "ホップバイホップオプション、宛先：[RFC-2133]で扱われていないインタフェース識別（発信インターフェイスを指定して、着信インターフェイスを決定する）とIPv6拡張ヘッダ：他のいくつかのアプリケーションがアクセスする必要があることのIPv6の特徴がありますオプション、およびルーティングヘッダ（ソースルーティング）。この文書では、あまりにも、これらの機能へのAPIアクセスを提供します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 4,
      "text": "1.  Introduction ................................................3\n2.  Common Structures and Definitions ...........................5\n   2.1.  The ip6_hdr Structure ..................................5\n        2.1.1.  IPv6 Next Header Values .........................6\n        2.1.2.  IPv6 Extension Headers ..........................6\n   2.2.  The icmp6_hdr Structure ................................8\n        2.2.1.  ICMPv6 Type and Code Values .....................8\n        2.2.2.  ICMPv6 Neighbor Discovery Type and Code Values ..9\n   2.3.  Address Testing Macros .................................12\n   2.4.  Protocols File .........................................12\n3.  IPv6 Raw Sockets ............................................13\n   3.1.  Checksums ..............................................14\n   3.2.  ICMPv6 Type Filtering ..................................14\n4.  Ancillary Data ..............................................17\n   4.1.  The msghdr Structure ...................................18\n   4.2.  The cmsghdr Structure ..................................18\n   4.3.  Ancillary Data Object Macros ...........................19\n        4.3.1.  CMSG_FIRSTHDR ...................................20\n        4.3.2.  CMSG_NXTHDR .....................................22\n        4.3.3.  CMSG_DATA .......................................22\n        4.3.4.  CMSG_SPACE ......................................22\n        4.3.5.  CMSG_LEN ........................................22\n   4.4.  Summary of Options Described Using Ancillary Data ......23\n   4.5.  IPV6_PKTOPTIONS Socket Option ..........................24\n        4.5.1.  TCP Sticky Options ..............................25\n        4.5.2.  UDP and Raw Socket Sticky Options ...............26\n5.  Packet Information ..........................................26\n   5.1.  Specifying/Receiving the Interface .....................27\n   5.2.  Specifying/Receiving Source/Destination Address ........27\n   5.3.  Specifying/Receiving the Hop Limit .....................28\n   5.4.  Specifying the Next Hop Address ........................29\n   5.5.  Additional Errors with sendmsg() .......................29\n6.  Hop-By-Hop Options ..........................................30\n   6.1.  Receiving Hop-by-Hop Options ...........................31\n   6.2.  Sending Hop-by-Hop Options .............................31\n   6.3.  Hop-by-Hop and Destination Options Processing ..........32\n        6.3.1.  inet6_option_space ..............................32\n        6.3.2.  inet6_option_init ...............................32\n        6.3.3.  inet6_option_append .............................33\n        6.3.4.  inet6_option_alloc ..............................33\n        6.3.5.  inet6_option_next ...............................34\n        6.3.6.  inet6_option_find ...............................35\n        6.3.7.  Options Examples ................................35\n7.  Destination Options .........................................42\n   7.1.  Receiving Destination Options ..........................42\n   7.2.  Sending Destination Options ............................43",
      "raw": true
    },
    {
      "indent": 3,
      "text": " 8.  Routing Header Option .......................................43\n    8.1.  inet6_rthdr_space ......................................44\n    8.2.  inet6_rthdr_init .......................................45\n    8.3.  inet6_rthdr_add ........................................45\n    8.4.  inet6_rthdr_lasthop ....................................46\n    8.5.  inet6_rthdr_reverse ....................................46\n    8.6.  inet6_rthdr_segments ...................................46\n    8.7.  inet6_rthdr_getaddr ....................................46\n    8.8.  inet6_rthdr_getflags ...................................47\n    8.9.  Routing Header Example .................................47\n 9.  Ordering of Ancillary Data and IPv6 Extension Headers .......53\n10.  IPv6-Specific Options with IPv4-Mapped IPv6 Addresses .......54\n11.  rresvport_af ................................................55\n12.  Future Items ................................................55\n    12.1.  Flow Labels ...........................................55\n    12.2.  Path MTU Discovery and UDP ............................56\n    12.3.  Neighbor Reachability and UDP .........................56\n13.  Summary of New Definitions ..................................56\n14.  Security Considerations .....................................59\n15.  Change History ..............................................59\n16.  References ..................................................65\n17.  Acknowledgments .............................................65\n18.  Authors' Addresses ..........................................66\n19.  Full Copyright Statement ....................................67",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Specifications are in progress for changes to the sockets API to support IP version 6 [RFC-2133]. These changes are for TCP and UDP-based applications. The current document defines some the \"advanced\" features of the sockets API that are required for applications to take advantage of additional features of IPv6.",
      "ja": "仕様は、[RFC-2133] IPバージョン6をサポートするためのソケットAPIへの変更のために進行中です。これらの変更は、TCPおよびUDPベースのアプリケーションのためのものです。現在のドキュメントは、IPv6の追加機能を利用するアプリケーションのために必要とされるソケットAPIのいくつかの「高度な」機能を定義します。"
    },
    {
      "indent": 3,
      "text": "Today, the portability of applications using IPv4 raw sockets is quite high, but this is mainly because most IPv4 implementations started from a common base (the Berkeley source code) or at least started with the Berkeley headers. This allows programs such as Ping and Traceroute, for example, to compile with minimal effort on many hosts that support the sockets API. With IPv6, however, there is no common source code base that implementors are starting from, and the possibility for divergence at this level between different implementations is high. To avoid a complete lack of portability amongst applications that use raw IPv6 sockets, some standardization is necessary.",
      "ja": "今日、IPv4の生のソケットを使用するアプリケーションの移植性は非常に高いが、ほとんどのIPv4実装が共通のベース（バークレーソースコード）から起動または少なくともバークレーヘッダで開始するので、これは主にあります。これは、pingやtracerouteのようなプログラムは、例えば、ソケットAPIをサポートする多くのホスト上で最小限の労力でコンパイルすることができます。 IPv6では、しかし、そこに実装から始めて共通ソースコードベースはなく、異なる実装の間でこのレベルの発散の可能性が高いです。生のIPv6ソケットを使用するアプリケーション間での移植性の完全な欠如を避けるために、いくつかの標準化が必要です。"
    },
    {
      "indent": 3,
      "text": "There are also features from the basic IPv6 specification that are not addressed in [RFC-2133]: sending and receiving Hop-by-Hop options, Destination options, and Routing headers, specifying the outgoing interface, and being told of the receiving interface.",
      "ja": "送信側と受信側のホップバイホップオプション、宛先オプション、およびルーティングヘッダを、発信インターフェイスを指定し、受信インタフェースの言われて：[RFC-2133]で扱われていない基本IPv6仕様から機能もあります。"
    },
    {
      "indent": 3,
      "text": "This document can be divided into the following main sections.",
      "ja": "このドキュメントは、次の主要なセクションに分けることができます。"
    },
    {
      "indent": 3,
      "text": "1. Definitions of the basic constants and structures required for applications to use raw IPv6 sockets. This includes structure definitions for the IPv6 and ICMPv6 headers and all associated constants (e.g., values for the Next Header field).",
      "ja": "生のIPv6ソケットを使用するアプリケーションに必要な基本的な定数と構造体の1.定義。これは、IPv6とICMPv6のヘッダと関連するすべての定数（例えば、次ヘッダフィールドの値）のための構造定義を含みます。"
    },
    {
      "indent": 3,
      "text": "2. Some basic semantic definitions for IPv6 raw sockets. For example, a raw ICMPv4 socket requires the application to calculate and store the ICMPv4 header checksum. But with IPv6 this would require the application to choose the source IPv6 address because the source address is part of the pseudo header that ICMPv6 now uses for its checksum computation. It should be defined that with a raw ICMPv6 socket the kernel always calculates and stores the ICMPv6 header checksum.",
      "ja": "2. IPv6のrawソケットのためのいくつかの基本的なセマンティック定義が。例えば、生ICMPv4のソケットはICMPv4のヘッダチェックサムを計算して格納するアプリケーションを必要とします。しかし、IPv6でこれは、送信元アドレスは、ICMPv6のは今そのチェックサムの計算に使用する擬似ヘッダの一部であるため、送信元IPv6アドレスを選択するためのアプリケーションが必要になります。生のICMPv6ソケットにカーネルは常にICMPv6のヘッダチェックサムを計算し、記憶することが定義されるべきです。"
    },
    {
      "indent": 3,
      "text": "3. Packet information: how applications can obtain the received interface, destination address, and received hop limit, along with specifying these values on a per-packet basis. There are a class of applications that need this capability and the technique should be portable.",
      "ja": "前記パケット情報：アプリケーションは、受信インタフェース、宛先アドレス、およびパケット単位でこれらの値を指定するとともに、ホップ制限を受けを得ることができる方法。ポータブルである必要があり、この機能と技術を必要とするアプリケーションのクラスがあります。"
    },
    {
      "indent": 3,
      "text": "4. Access to the optional Hop-by-Hop, Destination, and Routing headers.",
      "ja": "オプションのホップバイホップ、送信先、およびルーティングヘッダーへのアクセス4。"
    },
    {
      "indent": 3,
      "text": "5. Additional features required for IPv6 application portability.",
      "section_title": true,
      "ja": "IPv6のアプリケーションの移植性のために必要な5.その他の機能。"
    },
    {
      "indent": 3,
      "text": "The packet information along with access to the extension headers (Hop-by-Hop options, Destination options, and Routing header) are specified using the \"ancillary data\" fields that were added to the 4.3BSD Reno sockets API in 1990. The reason is that these ancillary data fields are part of the Posix.1g standard (which should be approved in 1997) and should therefore be adopted by most vendors.",
      "ja": "拡張ヘッダーへのアクセス（ホップバイホップオプション、宛先オプション、およびルーティングヘッダ）と共にパケット情報は、理由は1990年に4.3BSDレノソケットAPIに追加された「補助データ」フィールドを使用して指定されていますこれらの補助データフィールドは、（1997年に承認されなければならない）Posix.1g標準の一部であるため、ほとんどのベンダーによって採用されるべきです。"
    },
    {
      "indent": 3,
      "text": "This document does not address application access to either the authentication header or the encapsulating security payload header.",
      "ja": "この文書では、認証ヘッダやカプセル化セキュリティペイロードヘッダのいずれかへのアクセスをアプリケーションに対応していません。"
    },
    {
      "indent": 3,
      "text": "All examples in this document omit error checking in favor of brevity and clarity.",
      "ja": "このドキュメントのすべての例では、簡潔かつ明瞭に賛成してエラーチェックを省略します。"
    },
    {
      "indent": 3,
      "text": "We note that many of the functions and socket options defined in this document may have error returns that are not defined in this document. Many of these possible error returns will be recognized only as implementations proceed.",
      "ja": "私たちは、この文書で定義された関数とソケットのオプションの多くは、この文書で定義されていないエラーリターンを持っているかもしれないことに注意します。これらの可能性のあるエラーを返すの多くは、実装が進むだけとして認識されます。"
    },
    {
      "indent": 3,
      "text": "Datatypes in this document follow the Posix.1g format: intN_t means a signed integer of exactly N bits (e.g., int16_t) and uintN_t means an unsigned integer of exactly N bits (e.g., uint32_t).",
      "ja": "この文書に記載されているデータ型はPosix.1gフォーマットは、次のとおりintN_tは正確にNビットの符号付き整数（例えば、int16_t）を意味し、uintN_tは正確にNビットの符号なし整数（例えば、のuint32_t）を意味します。"
    },
    {
      "indent": 3,
      "text": "Note that we use the (unofficial) terminology ICMPv4, IGMPv4, and ARPv4 to avoid any confusion with the newer ICMPv6 protocol.",
      "ja": "我々は新しいICMPv6のプロトコルとの混同を避けるために（非公式）用語ICMPv4の、IGMPv4、およびARPv4を使用することに注意してください。"
    },
    {
      "indent": 0,
      "text": "2. Common Structures and Definitions",
      "section_title": true,
      "ja": "2.一般的な構造と定義"
    },
    {
      "indent": 3,
      "text": "Many advanced applications examine fields in the IPv6 header and set and examine fields in the various ICMPv6 headers. Common structure definitions for these headers are required, along with common constant definitions for the structure members.",
      "ja": "多くの高度なアプリケーションは、IPv6ヘッダーのフィールドを調べて、各種のICMPv6ヘッダー内のフィールドを設定して調べ。これらのヘッダーのための一般的な構造体の定義は、構造体のメンバーのための共通の定数の定義とともに、必要とされます。"
    },
    {
      "indent": 3,
      "text": "Two new headers are defined: <netinet/ip6.h> and <netinet/icmp6.h>.",
      "ja": "二つの新しいヘッダが定義されています。<netinetの/ ip6.h>と<netinetの/ icmp6.h>。"
    },
    {
      "indent": 3,
      "text": "When an include file is specified, that include file is allowed to include other files that do the actual declaration or definition.",
      "ja": "インクルードファイルを指定すると、そのファイルが含まれるが、実際の宣言または定義を行う他のファイルを含めることが許可されています。"
    },
    {
      "indent": 0,
      "text": "2.1. The ip6_hdr Structure",
      "section_title": true,
      "ja": "2.1.  ip6_hdr構造"
    },
    {
      "indent": 3,
      "text": "The following structure is defined as a result of including <netinet/ip6.h>. Note that this is a new header.",
      "ja": "以下の構造は、<netinetの/ ip6.h>などの結果として定義されます。これは新しいヘッダであることに注意してください。"
    },
    {
      "indent": 4,
      "text": "struct ip6_hdr {\n  union {\n    struct ip6_hdrctl {\n      uint32_t ip6_un1_flow;   /* 24 bits of flow-ID */\n      uint16_t ip6_un1_plen;   /* payload length */\n      uint8_t  ip6_un1_nxt;    /* next header */\n      uint8_t  ip6_un1_hlim;   /* hop limit */\n    } ip6_un1;\n    uint8_t ip6_un2_vfc;       /* 4 bits version, 4 bits priority */\n  } ip6_ctlun;\n  struct in6_addr ip6_src;      /* source address */\n  struct in6_addr ip6_dst;      /* destination address */\n};",
      "raw": true
    },
    {
      "indent": 4,
      "text": "#define ip6_vfc ip6_ctlun.ip6_un2_vfc #define ip6_flow ip6_ctlun.ip6_un1.ip6_un1_flow #define ip6_plen ip6_ctlun.ip6_un1.ip6_un1_plen #define ip6_nxt ip6_ctlun.ip6_un1.ip6_un1_nxt #define ip6_hlim ip6_ctlun.ip6_un1.ip6_un1_hlim",
      "ja": "#define ip6_vfc ip6_ctlun.ip6_un2_vfcの#define ip6_flow ip6_ctlun.ip6_un1.ip6_un1_flowの#define ip6_plen ip6_ctlun.ip6_un1.ip6_un1_plenの#define ip6_nxt ip6_ctlun.ip6_un1.ip6_un1_nxtの#define ip6_hlim ip6_ctlun.ip6_un1.ip6_un1_hlim"
    },
    {
      "indent": 4,
      "text": "#define ip6_hops ip6_ctlun.ip6_un1.ip6_un1_hlim",
      "ja": "#define ip6_hops ip6_ctlun.ip6_un1.ip6_un1_hlim"
    },
    {
      "indent": 0,
      "text": "2.1.1. IPv6 Next Header Values",
      "section_title": true,
      "ja": "2.1.1.  IPv6の次のヘッダ値"
    },
    {
      "indent": 3,
      "text": "IPv6 defines many new values for the Next Header field. The following constants are defined as a result of including <netinet/in.h>.",
      "ja": "IPv6は、次ヘッダフィールドのための多くの新しい値を定義します。以下の定数は、<netinetの/ in.h>などの結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "#define IPPROTO_HOPOPTS        0 /* IPv6 Hop-by-Hop options */\n#define IPPROTO_IPV6          41 /* IPv6 header */\n#define IPPROTO_ROUTING       43 /* IPv6 Routing header */\n#define IPPROTO_FRAGMENT      44 /* IPv6 fragmentation header */\n#define IPPROTO_ESP           50 /* encapsulating security payload */\n#define IPPROTO_AH            51 /* authentication header */\n#define IPPROTO_ICMPV6        58 /* ICMPv6 */\n#define IPPROTO_NONE          59 /* IPv6 no next header */\n#define IPPROTO_DSTOPTS       60 /* IPv6 Destination options */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Berkeley-derived IPv4 implementations also define IPPROTO_IP to be 0. This should not be a problem since IPPROTO_IP is used only with IPv4 sockets and IPPROTO_HOPOPTS only with IPv6 sockets.",
      "ja": "バークレー由来のIPv4実装もIPPROTO_IPのみIPv6ソケットとIPv4のみのソケットとIPPROTO_HOPOPTSと共に使用されるので、これは問題にはならない0にIPPROTO_IPを定義します。"
    },
    {
      "indent": 0,
      "text": "2.1.2. IPv6 Extension Headers",
      "section_title": true,
      "ja": "2.1.2.  IPv6拡張ヘッダー"
    },
    {
      "indent": 3,
      "text": "Six extension headers are defined for IPv6. We define structures for all except the Authentication header and Encapsulating Security Payload header, both of which are beyond the scope of this document. The following structures are defined as a result of including <netinet/ip6.h>.",
      "ja": "シックス・拡張ヘッダは、IPv6のために定義されています。私たちは、このドキュメントの範囲を超えて、どちらも認証ヘッダーとカプセル化セキュリティペイロードヘッダ、以外のすべてのための構造を定義します。以下の構造は、<netinetの/ ip6.h>を含めた結果として定義されています。"
    },
    {
      "indent": 3,
      "text": "/* Hop-by-Hop options header */\n/* XXX should we pad it to force alignment on an 8-byte boundary? */\nstruct ip6_hbh {\n  uint8_t  ip6h_nxt;        /* next header */\n  uint8_t  ip6h_len;        /* length in units of 8 octets */\n    /* followed by options */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Destination options header */\n/* XXX should we pad it to force alignment on an 8-byte boundary? */\nstruct ip6_dest {\n  uint8_t  ip6d_nxt;        /* next header */\n  uint8_t  ip6d_len;        /* length in units of 8 octets */\n    /* followed by options */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Routing header */\nstruct ip6_rthdr {",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  uint8_t  ip6r_nxt;        /* next header */\n  uint8_t  ip6r_len;        /* length in units of 8 octets */\n  uint8_t  ip6r_type;       /* routing type */\n  uint8_t  ip6r_segleft;    /* segments left */\n    /* followed by routing type specific data */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Type 0 Routing header */\nstruct ip6_rthdr0 {\n  uint8_t  ip6r0_nxt;       /* next header */\n  uint8_t  ip6r0_len;       /* length in units of 8 octets */\n  uint8_t  ip6r0_type;      /* always zero */\n  uint8_t  ip6r0_segleft;   /* segments left */\n  uint8_t  ip6r0_reserved;  /* reserved field */\n  uint8_t  ip6r0_slmap[3];  /* strict/loose bit map */\n  struct in6_addr  ip6r0_addr[1];  /* up to 23 addresses */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Fragment header */\nstruct ip6_frag {\n  uint8_t   ip6f_nxt;       /* next header */\n  uint8_t   ip6f_reserved;  /* reserved field */\n  uint16_t  ip6f_offlg;     /* offset, reserved, and flag */\n  uint32_t  ip6f_ident;     /* identification */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#if     BYTE_ORDER == BIG_ENDIAN\n#define IP6F_OFF_MASK       0xfff8  /* mask out offset from _offlg */\n#define IP6F_RESERVED_MASK  0x0006  /* reserved bits in ip6f_offlg */\n#define IP6F_MORE_FRAG      0x0001  /* more-fragments flag */\n#else   /* BYTE_ORDER == LITTLE_ENDIAN */\n#define IP6F_OFF_MASK       0xf8ff  /* mask out offset from _offlg */\n#define IP6F_RESERVED_MASK  0x0600  /* reserved bits in ip6f_offlg */\n#define IP6F_MORE_FRAG      0x0100  /* more-fragments flag */\n#endif",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Defined constants for fields larger than 1 byte depend on the byte ordering that is used. This API assumes that the fields in the protocol headers are left in the network byte order, which is big-endian for the Internet protocols. If not, then either these constants or the fields being tested must be converted at run-time, using something like htons() or htonl().",
      "ja": "1バイトを超えるフィールドの定義された定数が使用されているバイト順序に依存します。このAPIは、プロトコルヘッダ内のフィールドは、インターネットプロトコルのためのビッグエンディアンであるネットワークバイト順、に残されていることを前提としています。そうでない場合には、これらの定数またはテストされているいずれかのフィールドはhtons（）やhtonl（）のようなものを使用して、実行時に変換する必要があります。"
    },
    {
      "indent": 3,
      "text": "(Note: We show an implementation that supports both big-endian and little-endian byte ordering, assuming a hypothetical compile-time #if test to determine the byte ordering. The constant that we show,",
      "ja": "（注：私たちは、バイト順序を決定するために、テストの#if架空のコンパイル時を想定し、ビッグエンディアンとリトルエンディアンバイト順の両方サポートする実装を示し、我々は示すことが定数、"
    },
    {
      "indent": 3,
      "text": "BYTE_ORDER, with values of BIG_ENDIAN and LITTLE_ENDIAN, are for example purposes only. If an implementation runs on only one type of hardware it need only define the set of constants for that hardware's byte ordering.)",
      "ja": "BYTE_ORDER、BIG_ENDIANとLITTLE_ENDIANの値で、例のみを目的としています。実装は、ハードウェアの一種類のみで実行されている場合にのみ、そのハードウェアのバイト順の定数のセットを定義する必要が。）"
    },
    {
      "indent": 0,
      "text": "2.2. The icmp6_hdr Structure",
      "section_title": true,
      "ja": "2.2.  icmp6_hdr構造"
    },
    {
      "indent": 3,
      "text": "The ICMPv6 header is needed by numerous IPv6 applications including Ping, Traceroute, router discovery daemons, and neighbor discovery daemons. The following structure is defined as a result of including <netinet/icmp6.h>. Note that this is a new header.",
      "ja": "ICMPv6のヘッダはPingの、トレースルート、ルータディスカバリデーモン、近傍検索デーモンを含む多数のIPv6アプリケーションで必要とされます。以下の構造は、<netinetの/ icmp6.h>などの結果として定義されます。これは新しいヘッダであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "struct icmp6_hdr {\n  uint8_t     icmp6_type;   /* type field */\n  uint8_t     icmp6_code;   /* code field */\n  uint16_t    icmp6_cksum;  /* checksum field */\n  union {\n    uint32_t  icmp6_un_data32[1]; /* type-specific field */\n    uint16_t  icmp6_un_data16[2]; /* type-specific field */\n    uint8_t   icmp6_un_data8[4];  /* type-specific field */\n  } icmp6_dataun;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define icmp6_data32    icmp6_dataun.icmp6_un_data32\n#define icmp6_data16    icmp6_dataun.icmp6_un_data16\n#define icmp6_data8     icmp6_dataun.icmp6_un_data8\n#define icmp6_pptr      icmp6_data32[0]  /* parameter prob */\n#define icmp6_mtu       icmp6_data32[0]  /* packet too big */\n#define icmp6_id        icmp6_data16[0]  /* echo request/reply */\n#define icmp6_seq       icmp6_data16[1]  /* echo request/reply */\n#define icmp6_maxdelay  icmp6_data16[0]  /* mcast group membership */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.2.1. ICMPv6 Type and Code Values",
      "section_title": true,
      "ja": "2.2.1.  ICMPv6のタイプとコード値"
    },
    {
      "indent": 3,
      "text": "In addition to a common structure for the ICMPv6 header, common definitions are required for the ICMPv6 type and code fields. The following constants are also defined as a result of including <netinet/icmp6.h>.",
      "ja": "ICMPv6のヘッダの共通の構造に加えて、一般的な定義は、ICMPv6のタイプとコードフィールドに必要とされます。以下の定数はまた、<netinetの/ icmp6.h>などの結果として定義されます。"
    },
    {
      "indent": 0,
      "text": "#define ICMP6_DST_UNREACH 1 #define ICMP6_PACKET_TOO_BIG 2 #define ICMP6_TIME_EXCEEDED 3 #define ICMP6_PARAM_PROB 4",
      "ja": "#define ICMP6_DST_UNREACH 1の#define ICMP6_PACKET_TOO_BIG 2の#define ICMP6_TIME_EXCEEDED 3の#define ICMP6_PARAM_PROB 4"
    },
    {
      "indent": 0,
      "text": "#define ICMP6_INFOMSG_MASK  0x80    /* all informational messages */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#define ICMP6_ECHO_REQUEST 128 #define ICMP6_ECHO_REPLY 129",
      "ja": "#define ICMP6_ECHO_REQUEST 128の#define ICMP6_ECHO_REPLY 129"
    },
    {
      "indent": 0,
      "text": "#define ICMP6_MEMBERSHIP_QUERY 130 #define ICMP6_MEMBERSHIP_REPORT 131 #define ICMP6_MEMBERSHIP_REDUCTION 132",
      "ja": "#define ICMP6_MEMBERSHIP_QUERY 130の#define ICMP6_MEMBERSHIP_REPORT 131の#define ICMP6_MEMBERSHIP_REDUCTION 132"
    },
    {
      "indent": 0,
      "text": "#define ICMP6_DST_UNREACH_NOROUTE     0 /* no route to destination */\n#define ICMP6_DST_UNREACH_ADMIN       1 /* communication with */\n                                        /* destination */\n                                        /* administratively */\n                                        /* prohibited */\n#define ICMP6_DST_UNREACH_NOTNEIGHBOR 2 /* not a neighbor */\n#define ICMP6_DST_UNREACH_ADDR        3 /* address unreachable */\n#define ICMP6_DST_UNREACH_NOPORT      4 /* bad port */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#define ICMP6_TIME_EXCEED_TRANSIT     0 /* Hop Limit == 0 in transit */\n#define ICMP6_TIME_EXCEED_REASSEMBLY  1 /* Reassembly time out */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#define ICMP6_PARAMPROB_HEADER        0 /* erroneous header field */\n#define ICMP6_PARAMPROB_NEXTHEADER    1 /* unrecognized Next Header */\n#define ICMP6_PARAMPROB_OPTION        2 /* unrecognized IPv6 option */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The five ICMP message types defined by IPv6 neighbor discovery (133- 137) are defined in the next section.",
      "ja": "IPv6近隣探索（133- 137）によって定義された5つのICMPメッセージタイプは、次のセクションで定義されています。"
    },
    {
      "indent": 0,
      "text": "2.2.2. ICMPv6 Neighbor Discovery Type and Code Values",
      "section_title": true,
      "ja": "2.2.2.  ICMPv6の近隣探索タイプとコード値"
    },
    {
      "indent": 3,
      "text": "The following structures and definitions are defined as a result of including <netinet/icmp6.h>.",
      "ja": "以下の構造および定義は、<netinetの/ icmp6.h>などの結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "#define ND_ROUTER_SOLICIT 133 #define ND_ROUTER_ADVERT 134 #define ND_NEIGHBOR_SOLICIT 135 #define ND_NEIGHBOR_ADVERT 136 #define ND_REDIRECT 137",
      "ja": "#define ND_ROUTER_SOLICIT 133の#define ND_ROUTER_ADVERT 134の#define ND_NEIGHBOR_SOLICIT 135の#define ND_NEIGHBOR_ADVERT 136の#define ND_REDIRECT 137"
    },
    {
      "indent": 3,
      "text": "struct nd_router_solicit {     /* router solicitation */\n  struct icmp6_hdr  nd_rs_hdr;\n    /* could be followed by options */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define nd_rs_type nd_rs_hdr.icmp6_type #define nd_rs_code nd_rs_hdr.icmp6_code #define nd_rs_cksum nd_rs_hdr.icmp6_cksum #define nd_rs_reserved nd_rs_hdr.icmp6_data32[0]",
      "ja": "#define nd_rs_type nd_rs_hdr.icmp6_typeの#define nd_rs_code nd_rs_hdr.icmp6_codeの#define nd_rs_cksum nd_rs_hdr.icmp6_cksumの#define nd_rs_reserved nd_rs_hdr.icmp6_data32 [0]"
    },
    {
      "indent": 3,
      "text": "struct nd_router_advert {      /* router advertisement */\n  struct icmp6_hdr  nd_ra_hdr;\n  uint32_t   nd_ra_reachable;   /* reachable time */\n  uint32_t   nd_ra_retransmit;  /* retransmit timer */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    /* could be followed by options */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define nd_ra_type nd_ra_hdr.icmp6_type #define nd_ra_code nd_ra_hdr.icmp6_code #define nd_ra_cksum nd_ra_hdr.icmp6_cksum #define nd_ra_curhoplimit nd_ra_hdr.icmp6_data8[0] #define nd_ra_flags_reserved nd_ra_hdr.icmp6_data8[1] #define ND_RA_FLAG_MANAGED 0x80 #define ND_RA_FLAG_OTHER 0x40 #define nd_ra_router_lifetime nd_ra_hdr.icmp6_data16[1]",
      "ja": "#define nd_ra_type nd_ra_hdr.icmp6_typeの#define nd_ra_code nd_ra_hdr.icmp6_codeの#define nd_ra_cksum nd_ra_hdr.icmp6_cksumの#define nd_ra_curhoplimit nd_ra_hdr.icmp6_data8 [0]の#define nd_ra_flags_reserved nd_ra_hdr.icmp6_data8 [1]の#define ND_RA_FLAG_MANAGEDは0x80の#define ND_RA_FLAG_OTHER 0x40のに#define nd_ra_router_lifetime nd_ra_hdr.icmp6_data16 [1]"
    },
    {
      "indent": 3,
      "text": "struct nd_neighbor_solicit {   /* neighbor solicitation */\n  struct icmp6_hdr  nd_ns_hdr;\n  struct in6_addr   nd_ns_target; /* target address */\n    /* could be followed by options */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define nd_ns_type nd_ns_hdr.icmp6_type #define nd_ns_code nd_ns_hdr.icmp6_code #define nd_ns_cksum nd_ns_hdr.icmp6_cksum #define nd_ns_reserved nd_ns_hdr.icmp6_data32[0]",
      "ja": "#define nd_ns_type nd_ns_hdr.icmp6_typeの#define nd_ns_code nd_ns_hdr.icmp6_codeの#define nd_ns_cksum nd_ns_hdr.icmp6_cksumの#define nd_ns_reserved nd_ns_hdr.icmp6_data32 [0]"
    },
    {
      "indent": 3,
      "text": "struct nd_neighbor_advert {    /* neighbor advertisement */\n  struct icmp6_hdr  nd_na_hdr;\n  struct in6_addr   nd_na_target; /* target address */\n    /* could be followed by options */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define nd_na_type               nd_na_hdr.icmp6_type\n#define nd_na_code               nd_na_hdr.icmp6_code\n#define nd_na_cksum              nd_na_hdr.icmp6_cksum\n#define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]\n#if     BYTE_ORDER == BIG_ENDIAN\n#define ND_NA_FLAG_ROUTER        0x80000000\n#define ND_NA_FLAG_SOLICITED     0x40000000\n#define ND_NA_FLAG_OVERRIDE      0x20000000\n#else   /* BYTE_ORDER == LITTLE_ENDIAN */\n#define ND_NA_FLAG_ROUTER        0x00000080\n#define ND_NA_FLAG_SOLICITED     0x00000040\n#define ND_NA_FLAG_OVERRIDE      0x00000020\n#endif",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct nd_redirect {           /* redirect */\n  struct icmp6_hdr  nd_rd_hdr;\n  struct in6_addr   nd_rd_target; /* target address */\n  struct in6_addr   nd_rd_dst;    /* destination address */\n    /* could be followed by options */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "};",
      "ja": "｝；"
    },
    {
      "indent": 3,
      "text": "#define nd_rd_type nd_rd_hdr.icmp6_type #define nd_rd_code nd_rd_hdr.icmp6_code #define nd_rd_cksum nd_rd_hdr.icmp6_cksum #define nd_rd_reserved nd_rd_hdr.icmp6_data32[0]",
      "ja": "#define nd_rd_type nd_rd_hdr.icmp6_typeの#define nd_rd_code nd_rd_hdr.icmp6_codeの#define nd_rd_cksum nd_rd_hdr.icmp6_cksumの#define nd_rd_reserved nd_rd_hdr.icmp6_data32 [0]"
    },
    {
      "indent": 3,
      "text": "struct nd_opt_hdr {           /* Neighbor discovery option header */\n  uint8_t  nd_opt_type;\n  uint8_t  nd_opt_len;        /* in units of 8 octets */\n    /* followed by option specific data */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define ND_OPT_SOURCE_LINKADDR 1 #define ND_OPT_TARGET_LINKADDR 2 #define ND_OPT_PREFIX_INFORMATION 3 #define ND_OPT_REDIRECTED_HEADER 4 #define ND_OPT_MTU 5",
      "ja": "#define ND_OPT_SOURCE_LINKADDR 1の#define ND_OPT_TARGET_LINKADDR 2の#define ND_OPT_PREFIX_INFORMATION 3の#define ND_OPT_REDIRECTED_HEADER 4の#define ND_OPT_MTU 5"
    },
    {
      "indent": 3,
      "text": "struct nd_opt_prefix_info {    /* prefix information */\n  uint8_t   nd_opt_pi_type;\n  uint8_t   nd_opt_pi_len;\n  uint8_t   nd_opt_pi_prefix_len;\n  uint8_t   nd_opt_pi_flags_reserved;\n  uint32_t  nd_opt_pi_valid_time;\n  uint32_t  nd_opt_pi_preferred_time;\n  uint32_t  nd_opt_pi_reserved2;\n  struct in6_addr  nd_opt_pi_prefix;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define ND_OPT_PI_FLAG_ONLINK 0x80 #define ND_OPT_PI_FLAG_AUTO 0x40",
      "ja": "#define ND_OPT_PI_FLAG_ONLINKは0x80に#define ND_OPT_PI_FLAG_AUTOは0x40"
    },
    {
      "indent": 3,
      "text": "struct nd_opt_rd_hdr {         /* redirected header */\n  uint8_t   nd_opt_rh_type;\n  uint8_t   nd_opt_rh_len;\n  uint16_t  nd_opt_rh_reserved1;\n  uint32_t  nd_opt_rh_reserved2;\n    /* followed by IP header and data */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct nd_opt_mtu {            /* MTU option */\n  uint8_t   nd_opt_mtu_type;\n  uint8_t   nd_opt_mtu_len;\n  uint16_t  nd_opt_mtu_reserved;\n  uint32_t  nd_opt_mtu_mtu;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "We note that the nd_na_flags_reserved flags have the same byte ordering problems as we discussed with ip6f_offlg.",
      "ja": "我々はip6f_offlgして説明したようにnd_na_flags_reservedフラグは同じバイト順序の問題を抱えていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.3. Address Testing Macros",
      "section_title": true,
      "ja": "2.3. テストマクロアドレス"
    },
    {
      "indent": 3,
      "text": "The basic API ([RFC-2133]) defines some macros for testing an IPv6 address for certain properties. This API extends those definitions with additional address testing macros, defined as a result of including <netinet/in.h>.",
      "ja": "基本的なAPI（[RFC-2133]）は、特定のプロパティのIPv6アドレスをテストするためのいくつかのマクロを定義します。このAPIは、<netinetの/ in.h>を含めた結果として定義され、追加のアドレステストマクロとそれらの定義を拡張します。"
    },
    {
      "indent": 4,
      "text": "int IN6_ARE_ADDR_EQUAL(const struct in6_addr *, const struct in6_addr *);",
      "ja": "int型IN6_ARE_ADDR_EQUAL（constの構造体のin6_addr *、constの構造体のin6_addr *）。"
    },
    {
      "indent": 0,
      "text": "2.4. Protocols File",
      "section_title": true,
      "ja": "2.4. プロトコルファイル"
    },
    {
      "indent": 3,
      "text": "Many hosts provide the file /etc/protocols that contains the names of the various IP protocols and their protocol number (e.g., the value of the protocol field in the IPv4 header for that protocol, such as 1 for ICMP). Some programs then call the function getprotobyname() to obtain the protocol value that is then specified as the third argument to the socket() function. For example, the Ping program contains code of the form",
      "ja": "多くのホストは、様々なIPプロトコルの名前とそのプロトコル番号を含む、ファイル/ etc /プロトコルを提供する（例えば、そのプロトコルのIPv4ヘッダのプロトコルフィールドの値は、ICMPのような1）。いくつかのプログラムは、次いで、ソケット（）関数の3番目の引数として指定されたプロトコル値を得るために、関数getprotobyname（）を呼び出します。たとえば、pingプログラムは、フォームのコードが含まれています"
    },
    {
      "indent": 7,
      "text": "struct protoent *proto;",
      "ja": "構造体protoent *プロト。"
    },
    {
      "indent": 7,
      "text": "proto = getprotobyname(\"icmp\");",
      "ja": "プロト= getprotobyname（ \"ICMP\"）。"
    },
    {
      "indent": 7,
      "text": "s = socket(AF_INET, SOCK_RAW, proto->p_proto);",
      "ja": "S =ソケット（aphaiset、sockra、プロト> pproto）。"
    },
    {
      "indent": 3,
      "text": "Common names are required for the new IPv6 protocols in this file, to provide portability of applications that call the getprotoXXX() functions.",
      "ja": "一般的な名前はgetprotoXXX（）関数を呼び出すアプリケーションの移植性を提供するために、このファイルに新しいIPv6プロトコルのために必要とされます。"
    },
    {
      "indent": 3,
      "text": "We define the following protocol names with the values shown. These are taken from ftp://ftp.isi.edu/in-notes/iana/assignments/protocol-numbers.",
      "ja": "私たちは、示された値と、次のプロトコル名を定義します。これらは、ftp://ftp.isi.edu/in-notes/iana/assignments/protocol-numbersから取得されます。"
    },
    {
      "indent": 7,
      "text": "hopopt           0    # hop-by-hop options for ipv6\nipv6            41    # ipv6\nipv6-route      43    # routing header for ipv6\nipv6-frag       44    # fragment header for ipv6\nesp             50    # encapsulating security payload for ipv6\nah              51    # authentication header for ipv6\nipv6-icmp       58    # icmp for ipv6\nipv6-nonxt      59    # no next header for ipv6\nipv6-opts       60    # destination options for ipv6",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3. IPv6 Raw Sockets",
      "section_title": true,
      "ja": "3. IPv6のrawソケット"
    },
    {
      "indent": 3,
      "text": "Raw sockets bypass the transport layer (TCP or UDP). With IPv4, raw sockets are used to access ICMPv4, IGMPv4, and to read and write IPv4 datagrams containing a protocol field that the kernel does not process. An example of the latter is a routing daemon for OSPF, since it uses IPv4 protocol field 89. With IPv6 raw sockets will be used for ICMPv6 and to read and write IPv6 datagrams containing a Next Header field that the kernel does not process. Examples of the latter are a routing daemon for OSPF for IPv6 and RSVP (protocol field 46).",
      "ja": "rawソケットは、トランスポート層（TCPまたはUDP）をバイパスします。 IPv4では、rawソケットがICMPv4の、IGMPv4にアクセスするには、カーネルが処理しないことをプロトコルフィールドを含むIPv4のデータグラムを読み書きするために使用されています。それはICMPv6のために使用され、カーネルが処理をしないことを次のヘッダーフィールドを含むIPv6データグラムを読み書きするIPv6の生のソケットをIPv4プロトコルフィールド89を使用するので、後者の例は、OSPFのルーティングデーモンです。後者の例は、IPv6とRSVP（プロトコルフィールド46）のためのOSPFのルーティングデーモンです。"
    },
    {
      "indent": 3,
      "text": "All data sent via raw sockets MUST be in network byte order and all data received via raw sockets will be in network byte order. This differs from the IPv4 raw sockets, which did not specify a byte ordering and typically used the host's byte order.",
      "ja": "rawソケット経由で送信されたすべてのデータはネットワークバイト順でなければならず、生のソケットを介して受信されたすべてのデータはネットワークバイト順になります。これは、バイト順序を指定して、通常、ホストのバイト順序を使用していなかったのIPv4生ソケットとは異なります。"
    },
    {
      "indent": 3,
      "text": "Another difference from IPv4 raw sockets is that complete packets (that is, IPv6 packets with extension headers) cannot be read or written using the IPv6 raw sockets API. Instead, ancillary data objects are used to transfer the extension headers, as described later in this document. Should an application need access to the complete IPv6 packet, some other technique, such as the datalink interfaces BPF or DLPI, must be used.",
      "ja": "IPv4の生のソケットから別の違いは、完全なパケット（つまり、拡張ヘッダを持つIPv6パケットである）のIPv6生ソケットAPIを使用して読み書きすることができないことです。本書で後述するように、その代わりに、補助的なデータオブジェクトは、拡張ヘッダを転送するために使用されます。アプリケーションは、完全なIPv6パケットにアクセスする必要がある場合は、そのようなデータリンクインタフェースなどのいくつかの他の技術、BPFやDLPIは、使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "All fields in the IPv6 header that an application might want to change (i.e., everything other than the version number) can be modified using ancillary data and/or socket options by the application for output. All fields in a received IPv6 header (other than the version number and Next Header fields) and all extension headers are also made available to the application as ancillary data on input. Hence there is no need for a socket option similar to the IPv4 IP_HDRINCL socket option.",
      "ja": "IPv6におけるすべてのフィールドは、アプリケーションが変更する可能性があることをヘッダ（すなわち、バージョン番号以外のすべて）を出力するためのアプリケーションで補助的なデータ及び/又はソケットオプションを使用して修正することができます。 （バージョン番号と次ヘッダフィールドを除く）を受信したIPv6ヘッダ内のすべてのフィールドと全ての拡張ヘッダは、入力上の補助データとしてアプリケーションに利用可能にされます。そのためのIPv4 IP_HDRINCLソケットオプションに似たソケットオプションは必要ありません。"
    },
    {
      "indent": 3,
      "text": "When writing to a raw socket the kernel will automatically fragment the packet if its size exceeds the path MTU, inserting the required fragmentation headers. On input the kernel reassembles received fragments, so the reader of a raw socket never sees any fragment headers.",
      "ja": "生のソケットに書き込むときに、そのサイズがパスMTUを超えた場合、カーネルは自動的に必要な断片化ヘッダを挿入し、パケットを断片化します。入力時にカーネルは受け取った断片を再構成するので、生のソケットの読者は、任意のフラグメントヘッダを見たことがありません。"
    },
    {
      "indent": 3,
      "text": "When we say \"an ICMPv6 raw socket\" we mean a socket created by calling the socket function with the three arguments PF_INET6, SOCK_RAW, and IPPROTO_ICMPV6.",
      "ja": "私たちは「ICMPv6の生のソケット」と言うとき、私たちは三つの引数PF_INET6、SOCK_RAW、およびIPPROTO_ICMPV6とソケット関数を呼び出すことによって作成されたソケットを意味します。"
    },
    {
      "indent": 3,
      "text": "Most IPv4 implementations give special treatment to a raw socket created with a third argument to socket() of IPPROTO_RAW, whose value is normally 255. We note that this value has no special meaning to an IPv6 raw socket (and the IANA currently reserves the value of 255 when used as a next-header field). (Note: This feature was added to IPv4 in 1988 by Van Jacobson to support traceroute, allowing a complete IP header to be passed by the application, before the IP_HDRINCL socket option was added.)",
      "ja": "ほとんどのIPv4の実装では、その値が、通常255です。私たちは、この値はIPv6の生のソケット（およびIANAには特別な意味が現在値を予約していないことに注意してくださいIPPROTO_RAW、の）（ソケットへの第三引数で作成された生のソケットに特別な治療を与えます次ヘッダフィールドとして使用される255）の。 （注：この機能は、IP_HDRINCLソケットオプションを添加する前に完全なIPヘッダは、アプリケーションによって渡されることを可能にする、tracerouteをサポートするために、バン・ジェイコブソンによって1988年にはIPv4に添加しました。）"
    },
    {
      "indent": 0,
      "text": "3.1. Checksums",
      "section_title": true,
      "ja": "3.1. チェックサム"
    },
    {
      "indent": 3,
      "text": "The kernel will calculate and insert the ICMPv6 checksum for ICMPv6 raw sockets, since this checksum is mandatory.",
      "ja": "このチェックサムは必須であるため、カーネルは、ICMPv6の生のソケット用のICMPv6チェックサムを計算して挿入します。"
    },
    {
      "indent": 3,
      "text": "For other raw IPv6 sockets (that is, for raw IPv6 sockets created with a third argument other than IPPROTO_ICMPV6), the application must set the new IPV6_CHECKSUM socket option to have the kernel (1) compute and store a checksum for output, and (2) verify the received checksum on input, discarding the packet if the checksum is in error. This option prevents applications from having to perform source address selection on the packets they send. The checksum will incorporate the IPv6 pseudo-header, defined in Section 8.1 of [RFC-1883]. This new socket option also specifies an integer offset into the user data of where the checksum is located.",
      "ja": "他の生のIPv6ソケット（すなわちIPPROTO_ICMPV6以外の第三引数で作成された生のIPv6ソケットのために）、カーネルを持つ新しいIPV6_CHECKSUMソケットオプションを設定する必要があり、アプリケーション（1）を計算して出力するためのチェックサムを格納し、（2 ）チェックサムがエラーである場合、パケットを廃棄する、入力に受信したチェックサムを検証します。このオプションは、彼らが送信するパケットに送信元アドレス選択を実行することからアプリケーションを防ぎます。チェックサムは、[RFC-1883]のセクション8.1で定義されたIPv6疑似ヘッダを組み込みます。この新しいソケットオプションもチェックサムが配置されている場所のユーザデータへのオフセットの整数を指定します。"
    },
    {
      "indent": 4,
      "text": "int  offset = 2;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_CHECKSUM, &offset, sizeof(offset));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "By default, this socket option is disabled. Setting the offset to -1 also disables the option. By disabled we mean (1) the kernel will not calculate and store a checksum for outgoing packets, and (2) the kernel will not verify a checksum for received packets.",
      "ja": "デフォルトでは、このソケットオプションが無効になっています。オフセットに-1を設定すると、オプションを無効にします。無効にすることで、我々は、（1）カーネルが計算し、発信パケットのチェックサムを格納し、（2）カーネルは、受信したパケットのチェックサムを検証しませんしませんを意味します。"
    },
    {
      "indent": 3,
      "text": "(Note: Since the checksum is always calculated by the kernel for an ICMPv6 socket, applications are not able to generate ICMPv6 packets with incorrect checksums (presumably for testing purposes) using this API.)",
      "ja": "（注：チェックサムは常にのICMPv6ソケットのカーネルによって計算されるので、アプリケーションはこのAPIを使用して、おそらくテスト目的のために間違ったチェックサム（）とのICMPv6パケットを生成することができません。）"
    },
    {
      "indent": 0,
      "text": "3.2. ICMPv6 Type Filtering",
      "section_title": true,
      "ja": "3.2.  ICMPv6のタイプのフィルタリング"
    },
    {
      "indent": 3,
      "text": "ICMPv4 raw sockets receive most ICMPv4 messages received by the kernel. (We say \"most\" and not \"all\" because Berkeley-derived kernels never pass echo requests, timestamp requests, or address mask requests to a raw socket. Instead these three messages are processed entirely by the kernel.) But ICMPv6 is a superset of ICMPv4, also including the functionality of IGMPv4 and ARPv4. This means that an ICMPv6 raw socket can potentially receive many more messages than would be received with an ICMPv4 raw socket: ICMP messages similar to ICMPv4, along with neighbor solicitations, neighbor advertisements, and the three group membership messages.",
      "ja": "ICMPv4の生のソケットは、カーネルが受信したほとんどのICMPv4のメッセージを受信します。 （バークレー由来カーネルがrawソケットにエコー要求、タイムスタンプ要求、またはアドレスマスク要求を渡すことはありませんので、我々は。代わりに、これらの3件のメッセージがカーネルによって完全に処理されます。「すべて」「ほとんど」とされていないと言う）しかし、ICMPv6がスーパーセットでICMPv4のの、またIGMPv4とARPv4の機能を含みます。近隣要請、近隣広告、および3グループメンバーシップのメッセージとともに、ICMPv4のに似たICMPメッセージ：これはICMPv6の生のソケットが潜在的に多くのより多くのICMPv4生ソケットで受信されるよりもメッセージを受信できることを意味します。"
    },
    {
      "indent": 3,
      "text": "Most applications using an ICMPv6 raw socket care about only a small subset of the ICMPv6 message types. To transfer extraneous ICMPv6 messages from the kernel to user can incur a significant overhead. Therefore this API includes a method of filtering ICMPv6 messages by the ICMPv6 type field.",
      "ja": "ICMPv6メッセージの種類の小さなサブセットのみについてのICMPv6 rawソケットのケアを使用してほとんどのアプリケーション。大きなオーバーヘッドが発生することができ、ユーザにカーネルから余分なICMPv6メッセージを転送します。したがって、このAPIはICMPv6のタイプフィールドでICMPv6メッセージをフィルタリングする方法を含みます。"
    },
    {
      "indent": 3,
      "text": "Each ICMPv6 raw socket has an associated filter whose datatype is defined as",
      "ja": "各ICMPv6の生のソケットは、そのデータ型として定義されている関連するフィルタを有します"
    },
    {
      "indent": 7,
      "text": "struct icmp6_filter;",
      "ja": "構造体icmp6_filter。"
    },
    {
      "indent": 3,
      "text": "This structure, along with the macros and constants defined later in this section, are defined as a result of including the <netinet/icmp6.h> header.",
      "ja": "この構造は、この節の後半で定義されたマクロおよび定数とともに、<netinetの/ icmp6.h>ヘッダを含むの結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "The current filter is fetched and stored using getsockopt() and setsockopt() with a level of IPPROTO_ICMPV6 and an option name of ICMP6_FILTER.",
      "ja": "現在のフィルタは、フェッチとIPPROTO_ICMPV6のレベルとICMP6_FILTERのオプション名とのgetsockopt（）とのsetsockopt（）を使用して格納されます。"
    },
    {
      "indent": 3,
      "text": "Six macros operate on an icmp6_filter structure:",
      "ja": "シックス・マクロはicmp6_filter構造に動作します。"
    },
    {
      "indent": 7,
      "text": "void ICMP6_FILTER_SETPASSALL (struct icmp6_filter *);\nvoid ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "void ICMP6_FILTER_SETPASS ( int, struct icmp6_filter *);\nvoid ICMP6_FILTER_SETBLOCK( int, struct icmp6_filter *);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "int  ICMP6_FILTER_WILLPASS (int, const struct icmp6_filter *);\nint  ICMP6_FILTER_WILLBLOCK(int, const struct icmp6_filter *);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first argument to the last four macros (an integer) is an ICMPv6 message type, between 0 and 255. The pointer argument to all six macros is a pointer to a filter that is modified by the first four macros examined by the last two macros.",
      "ja": "最後の4つのマクロ（整数）の最初の引数は、0と255の間にすべての6つのマクロへのポインタ引数が最後の二つのマクロによって調べ、最初の4つのマクロによって変更されるフィルタへのポインタは、ICMPv6メッセージのタイプであります。"
    },
    {
      "indent": 3,
      "text": "The first two macros, SETPASSALL and SETBLOCKALL, let us specify that all ICMPv6 messages are passed to the application or that all ICMPv6 messages are blocked from being passed to the application.",
      "ja": "最初の二つのマクロ、SETPASSALLとSETBLOCKALL、私たちはすべてのICMPv6メッセージがアプリケーションに渡されるか、すべてのICMPv6メッセージがアプリケーションに渡されてからブロックされていることをされていることを指定できます。"
    },
    {
      "indent": 3,
      "text": "The next two macros, SETPASS and SETBLOCK, let us specify that messages of a given ICMPv6 type should be passed to the application or not passed to the application (blocked).",
      "ja": "次の二つのマクロ、SETPASSとSETBLOCK、私たちは与えられたのICMPv6タイプのメッセージがアプリケーションに渡される、またはアプリケーション（ブロック）に渡されないべきであることを指定しましょう。"
    },
    {
      "indent": 3,
      "text": "The final two macros, WILLPASS and WILLBLOCK, return true or false depending whether the specified message type is passed to the application or blocked from being passed to the application by the filter pointed to by the second argument.",
      "ja": "最後の二つのマクロ、WILLPASSとWILLBLOCKは、指定されたメッセージタイプがアプリケーションに渡されるか、フィルタによってアプリケーションに渡されるから遮断されているかどうかをtrueまたはfalseを返すによって第二引数によって指さ。"
    },
    {
      "indent": 3,
      "text": "When an ICMPv6 raw socket is created, it will by default pass all ICMPv6 message types to the application.",
      "ja": "ICMPv6の生のソケットが作成されると、それはデフォルトでは、アプリケーションにすべてのICMPv6メッセージタイプを渡します。"
    },
    {
      "indent": 3,
      "text": "As an example, a program that wants to receive only router advertisements could execute the following:",
      "ja": "例として、唯一のルータ広告を受信したい番組は、次のコマンドを実行できます。"
    },
    {
      "indent": 0,
      "text": "struct icmp6_filter myfilt;",
      "ja": "構造体icmp6_filterのmyfilt。"
    },
    {
      "indent": 0,
      "text": "fd = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);",
      "ja": "FD =ソケット（PF_INET6、SOCK_RAW、IPPROTO_ICMPV6）"
    },
    {
      "indent": 0,
      "text": "ICMP6_FILTER_SETBLOCKALL(&myfilt);\nICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &myfilt);\nsetsockopt(fd, IPPROTO_ICMPV6, ICMP6_FILTER, &myfilt, sizeof(myfilt));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The filter structure is declared and then initialized to block all messages types. The filter structure is then changed to allow router advertisement messages to be passed to the application and the filter is installed using setsockopt().",
      "ja": "フィルタ構造が宣言され、すべてのメッセージの種類をブロックするために初期化されます。フィルタ構造は、ルータ広告メッセージをアプリケーションに渡すことができるように変更され、フィルタは、（）のsetsockoptを使用してインストールされています。"
    },
    {
      "indent": 3,
      "text": "The icmp6_filter structure is similar to the fd_set datatype used with the select() function in the sockets API. The icmp6_filter structure is an opaque datatype and the application should not care how it is implemented. All the application does with this datatype is allocate a variable of this type, pass a pointer to a variable of this type to getsockopt() and setsockopt(), and operate on a variable of this type using the six macros that we just defined.",
      "ja": "icmp6_filter構造は、ソケットAPIの選択（）関数で使用FD_SETデータ型と類似しています。 icmp6_filter構造は不透明なデータ型であり、アプリケーションは、それがどのように実装されるか気にしてはいけません。すべてのアプリケーションは、このデータ型で行い、この型の変数を割り当てる（GETSOCKOPTするために、この型の変数へのポインタを渡す）とのsetsockopt（）、と私たちは定義された6つのマクロを使用して、この型の変数を操作しています。"
    },
    {
      "indent": 3,
      "text": "Nevertheless, it is worth showing a simple implementation of this datatype and the six macros.",
      "ja": "それにもかかわらず、このデータ型の単純な実装と6つのマクロを示す価値があります。"
    },
    {
      "indent": 0,
      "text": "struct icmp6_filter {\n  uint32_t  icmp6_filt[8];  /* 8*32 = 256 bits */\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#define ICMP6_FILTER_WILLPASS(type, filterp) \\ ((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) != 0) #define ICMP6_FILTER_WILLBLOCK(type, filterp) \\ ((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) == 0) #define ICMP6_FILTER_SETPASS(type, filterp) \\ ((((filterp)->icmp6_filt[(type) >> 5]) |= (1 << ((type) & 31)))) #define ICMP6_FILTER_SETBLOCK(type, filterp) \\ ((((filterp)->icmp6_filt[(type) >> 5]) &= ~(1 << ((type) & 31)))) #define ICMP6_FILTER_SETPASSALL(filterp) \\ memset((filterp), 0xFF, sizeof(struct icmp6_filter)) #define ICMP6_FILTER_SETBLOCKALL(filterp) \\ memset((filterp), 0, sizeof(struct icmp6_filter))",
      "ja": "#define ICMP6_FILTER_WILLPASS（タイプ、filterpは）\\（（（（filterpは）！ - > icmp6_filt [（タイプ）>> 5]）＆（1 <<（（タイプ）＆31）））= 0）の#define ICMP6_FILTER_WILLBLOCK（タイプ、filterpは）\\（（（（filterpは） - > icmp6_filt [（タイプ）>> 5]）＆（1 <<（（タイプ）＆31）））== 0）の#define ICMP6_FILTER_SETPASS（タイプ、filterpは）\\（ （（（filterpは） - > icmp6_filt [（タイプ）>> 5]）| =（1 <<（（タイプ）＆31））））の#define ICMP6_FILTER_SETBLOCK（タイプ、filterpは）\\（（（（filterpは） - > icmp6_filt [（タイプ）>> 5]）＆=〜（1 <<（（タイプ）＆31））））の#define ICMP6_FILTER_SETPASSALL（filterpは）\\のmemset（（filterpは）、0xFFで、はsizeof（構造体icmp6_filter））の#define ICMP6_FILTER_SETBLOCKALL（filterpは）\\ memsetの（（filterpは）、0、はsizeof（構造体icmp6_filter））"
    },
    {
      "indent": 3,
      "text": "(Note: These sample definitions have two limitations that an implementation may want to change. The first four macros evaluate their first argument two times. The second two macros require the inclusion of the <string.h> header for the memset() function.)",
      "ja": "（注：これらのサンプルの定義は、実装は、最初の4つのマクロは、その最初の引数を2回評価変更することを第2のマクロは<string.hの>ヘッダのmemset（）関数を含めることを必要とする2つの制限を有します。 ）"
    },
    {
      "indent": 0,
      "text": "4. Ancillary Data",
      "section_title": true,
      "ja": "4.補助データ"
    },
    {
      "indent": 3,
      "text": "4.2BSD allowed file descriptors to be transferred between separate processes across a UNIX domain socket using the sendmsg() and recvmsg() functions. Two members of the msghdr structure, msg_accrights and msg_accrightslen, were used to send and receive the descriptors. When the OSI protocols were added to 4.3BSD Reno in 1990 the names of these two fields in the msghdr structure were changed to msg_control and msg_controllen, because they were used by the OSI protocols for \"control information\", although the comments in the source code call this \"ancillary data\".",
      "ja": "4.2BSDは、ファイル記述子がにsendmsg（）とのrecvmsg（）関数を使用して、UNIXドメインソケットを横切って別のプロセスとの間で転送することができました。 msghdr構造体の2人のメンバー、msg_accrightsとmsg_accrightslenは、ディスクリプタを送受信するために使用されました。 OSIプロトコルは、1990年に4.3BSDレノに添加したときに、ソースコード内のコメントが、それらは、「制御情報」のOSIプロトコルによって使用されたので、msghdr構造体におけるこれら二つのフィールドの名前は、msg_controlおよびmsg_controllenに変更しましたこの「補助データ」と呼びます。"
    },
    {
      "indent": 3,
      "text": "Other than the OSI protocols, the use of ancillary data has been rare. In 4.4BSD, for example, the only use of ancillary data with IPv4 is to return the destination address of a received UDP datagram if the IP_RECVDSTADDR socket option is set. With Unix domain sockets ancillary data is still used to send and receive descriptors.",
      "ja": "OSIプロトコル以外に、補助的なデータの使用は稀となっています。 4.4BSDでは、例えば、IPv4のと補助データの使用のみがIP_RECVDSTADDRソケットオプションが設定されている場合、受信したUDPデータグラムの宛先アドレスを返すことです。 Unixドメインソケットで補助データはまだ記述子を送受信するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Nevertheless the ancillary data fields of the msghdr structure provide a clean way to pass information in addition to the data that is being read or written. The inclusion of the msg_control and msg_controllen members of the msghdr structure along with the cmsghdr structure that is pointed to by the msg_control member is required by the Posix.1g sockets API standard (which should be completed during 1997).",
      "ja": "それでもmsghdr構造体の補助的なデータフィールドは、読み取りまたは書き込みが行われているデータの他に情報を渡すためにクリーンな方法を提供します。 msg_control部材によって指されるcmsghdr構造体と共にmsg_controlとmsghdr構造体のmsg_controllenメンバーを含めることは（1997の間に完了しなければならない）Posix.1gソケットAPI規格によって必要とされます。"
    },
    {
      "indent": 3,
      "text": "In this document ancillary data is used to exchange the following optional information between the application and the kernel:",
      "ja": "本書で補助データは、アプリケーションとカーネルとの間の次のオプションの情報を交換するために使用されます。"
    },
    {
      "indent": 7,
      "text": "1.  the send/receive interface and source/destination address,\n2.  the hop limit,\n3.  next hop address,\n4.  Hop-by-Hop options,\n5.  Destination options, and\n6.  Routing header.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Before describing these uses in detail, we review the definition of the msghdr structure itself, the cmsghdr structure that defines an ancillary data object, and some functions that operate on the ancillary data objects.",
      "ja": "詳細にこれらの用途を説明する前に、我々はmsghdr構造体の定義自体、補助的なデータオブジェクトを定義するcmsghdr構造体、および補助的なデータオブジェクトを操作するいくつかの機能を確認します。"
    },
    {
      "indent": 0,
      "text": "4.1. The msghdr Structure",
      "section_title": true,
      "ja": "4.1.  msghdr構造体"
    },
    {
      "indent": 3,
      "text": "The msghdr structure is used by the recvmsg() and sendmsg() functions. Its Posix.1g definition is:",
      "ja": "msghdr構造体は、のrecvmsg（）とsendmsgの（）関数によって使用されます。そのPosix.1g定義は次のとおりです。"
    },
    {
      "indent": 4,
      "text": "struct msghdr {\n  void      *msg_name;        /* ptr to socket address structure */\n  socklen_t  msg_namelen;     /* size of socket address structure */\n  struct iovec  *msg_iov;     /* scatter/gather array */\n  size_t     msg_iovlen;      /* # elements in msg_iov */\n  void      *msg_control;     /* ancillary data */\n  socklen_t  msg_controllen;  /* ancillary data buffer length */\n  int        msg_flags;       /* flags on received message */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The structure is declared as a result of including <sys/socket.h>.",
      "ja": "構造体は<sysの/ socket.h>に含めた結果として宣言されています。"
    },
    {
      "indent": 3,
      "text": "(Note: Before Posix.1g the two \"void *\" pointers were typically \"char *\", and the two socklen_t members and the size_t member were typically integers. Earlier drafts of Posix.1g had the two socklen_t members as size_t, but Draft 6.6 of Posix.1g, apparently the final draft, changed these to socklen_t to simplify binary portability for 64-bit implementations and to align Posix.1g with X/Open's Networking Services, Issue 5. The change in msg_control to a \"void *\" pointer affects any code that increments this pointer.)",
      "ja": "（注：。Posix.1g 2「void *型」のポインタは、典型的には、「char型*」だった、と2人のsocklen_tメンバーとsize_tのメンバーは、一般的に整数になる前Posix.1gの以前のドラフトはsize_tのように2人のsocklen_tメンバーを持っていたが、ドラフトPosix.1gの6.6、明らかに最終案は、64ビットの実装のためのバイナリポータビリティを簡素化し、X / OpenのネットワークサービスとのPosix.1gを整列させるのsocklen_tする「void *型」にmsg_controlの変化5.問題がこれらを変更しましたポインタは、このポインタをインクリメントするコードに影響を与えます。）"
    },
    {
      "indent": 3,
      "text": "Most Berkeley-derived implementations limit the amount of ancillary data in a call to sendmsg() to no more than 108 bytes (an mbuf). This API requires a minimum of 10240 bytes of ancillary data, but it is recommended that the amount be limited only by the buffer space reserved by the socket (which can be modified by the SO_SNDBUF socket option). (Note: This magic number 10240 was picked as a value that should always be large enough. 108 bytes is clearly too small as the maximum size of a Type 0 Routing header is 376 bytes.)",
      "ja": "最もバークレー由来の実装では、これ以上108バイト以内（MBUF）まで）（SENDMSG呼び出しにおける補助データの量を制限します。このAPIは、補助データの10240バイトの最小値を必要とするが、量が（SO_SNDBUFソケットオプションによって変更することができる）ソケットによって予約バッファ空間によってのみ制限されることが推奨されます。 （注：このマジックナンバー10240は、常に十分に大きくなければならない値として選ばれた108のバイトが明確に376バイトであり、タイプ0ルーティングヘッダの最大サイズが小さすぎます。）。"
    },
    {
      "indent": 0,
      "text": "4.2. The cmsghdr Structure",
      "section_title": true,
      "ja": "4.2.  cmsghdr構造体"
    },
    {
      "indent": 3,
      "text": "The cmsghdr structure describes ancillary data objects transferred by recvmsg() and sendmsg(). Its Posix.1g definition is:",
      "ja": "cmsghdr構造体は、補助データのrecvmsgによって転送オブジェクト（）とsendmsgのを記述する（）。そのPosix.1g定義は次のとおりです。"
    },
    {
      "indent": 4,
      "text": "struct cmsghdr {\n  socklen_t  cmsg_len;   /* #bytes, including this header */\n  int        cmsg_level; /* originating protocol */\n  int        cmsg_type;  /* protocol-specific type */\n             /* followed by unsigned char cmsg_data[]; */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This structure is declared as a result of including <sys/socket.h>.",
      "ja": "この構造体は、<sysの/ socket.h>に含めた結果として宣言されています。"
    },
    {
      "indent": 3,
      "text": "As shown in this definition, normally there is no member with the name cmsg_data[]. Instead, the data portion is accessed using the CMSG_xxx() macros, as described shortly. Nevertheless, it is common to refer to the cmsg_data[] member.",
      "ja": "この定義に示されているように、通常は[] CMSG_DATA名前のメンバが存在しません。すぐに記載されるように代わりに、データ部分は、CMSG_xxx（）マクロを使用してアクセスされます。それにもかかわらず、CMSG_DATA []メンバーを参照するのが一般的です。"
    },
    {
      "indent": 3,
      "text": "(Note: Before Posix.1g the cmsg_len member was an integer, and not a socklen_t. See the Note in the previous section for why socklen_t is used here.)",
      "ja": "（注意：Posix.1g前CMSG_LENメンバーは、整数、およびないのsocklen_tたのsocklen_tがここで使用されている理由については、前のセクションでノートを参照してください。）"
    },
    {
      "indent": 3,
      "text": "When ancillary data is sent or received, any number of ancillary data objects can be specified by the msg_control and msg_controllen members of the msghdr structure, because each object is preceded by a cmsghdr structure defining the object's length (the cmsg_len member). Historically Berkeley-derived implementations have passed only one object at a time, but this API allows multiple objects to be passed in a single call to sendmsg() or recvmsg(). The following example shows two ancillary data objects in a control buffer.",
      "ja": "補助データが送信または受信されたときに、各オブジェクトは、オブジェクトの長さを画定するcmsghdr構造体（CMSG_LEN部材​​）が先行しているため、補助データオブジェクトの任意の数は、msg_controlとmsghdr構造体のmsg_controllenメンバーで指定することができます。歴史的にはバークレー由来の実装は、一度に1つのオブジェクトに合格したが、このAPIは、複数のオブジェクトが（SENDMSGする単一の呼び出しに渡されることを可能にする）またはのrecvmsg（）。次の例では、制御バッファ内の2つの補助的なデータオブジェクトを示しています。"
    },
    {
      "indent": 0,
      "text": "|<--------------------------- msg_controllen -------------------------->|\n|                                                                       |\n|<----- ancillary data object ----->|<----- ancillary data object ----->|\n|<---------- CMSG_SPACE() --------->|<---------- CMSG_SPACE() --------->|\n|                                   |                                   |\n|<---------- cmsg_len ---------->|  |<--------- cmsg_len ----------->|  |\n|<--------- CMSG_LEN() --------->|  |<-------- CMSG_LEN() ---------->|  |\n|                                |  |                                |  |\n+-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+\n|cmsg_|cmsg_|cmsg_|XX|           |XX|cmsg_|cmsg_|cmsg_|XX|           |XX|\n|len  |level|type |XX|cmsg_data[]|XX|len  |level|type |XX|cmsg_data[]|XX|\n+-----+-----+-----+--+-----------+--+-----+-----+-----+--+-----------+--+\n ^\n |\nmsg_control\npoints here",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields shown as \"XX\" are possible padding, between the cmsghdr structure and the data, and between the data and the next cmsghdr structure, if required by the implementation.",
      "ja": "実装によって必要とされる場合は、「XX」として表示されるフィールドは、cmsghdr構造体との間でデータ、及びデータと次のcmsghdr構造体との間に、可能パディングです。"
    },
    {
      "indent": 0,
      "text": "4.3. Ancillary Data Object Macros",
      "section_title": true,
      "ja": "4.3. 補助データオブジェクトのマクロ"
    },
    {
      "indent": 3,
      "text": "To aid in the manipulation of ancillary data objects, three macros from 4.4BSD are defined by Posix.1g: CMSG_DATA(), CMSG_NXTHDR(), and CMSG_FIRSTHDR(). Before describing these macros, we show the following example of how they might be used with a call to recvmsg().",
      "ja": "補助的なデータオブジェクトの操作を助けるために、4.4BSDからの3つのマクロがPosix.1gによって定義されています。CMSG_DATA（）、CMSG_NXTHDR（）、およびCMSG_FIRSTHDR（）。これらのマクロを説明する前に、我々は、彼らが（）をrecvmsgのための呼び出しで使用されるかもしれない方法の以下の例を示しています。"
    },
    {
      "indent": 4,
      "text": "struct msghdr   msg;\nstruct cmsghdr  *cmsgptr;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* fill in msg */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* call recvmsg() */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL;\n     cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) {\n    if (cmsgptr->cmsg_level == ... && cmsgptr->cmsg_type == ... ) {\n        u_char  *ptr;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "        ptr = CMSG_DATA(cmsgptr);\n        /* process data pointed to by ptr */\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "We now describe the three Posix.1g macros, followed by two more that are new with this API: CMSG_SPACE() and CMSG_LEN(). All these macros are defined as a result of including <sys/socket.h>.",
      "ja": "CMSG_SPACE（）とCMSG_LEN（）：私たちは、今、このAPIを使用して新しいある以上2に続く3つのPosix.1gマクロを記述します。すべてのこれらのマクロは、<SYS / socket.h>に含めた結果として定義されています。"
    },
    {
      "indent": 0,
      "text": "4.3.1. CMSG_FIRSTHDR",
      "section_title": true,
      "ja": "4.3.1.  CMSG_FIRSTHDR"
    },
    {
      "indent": 7,
      "text": "struct cmsghdr *CMSG_FIRSTHDR(const struct msghdr *mhdr);",
      "ja": "構造体のcmsghdr * CMSG_FIRSTHDR（constの構造体のmsghdr * MHDR）。"
    },
    {
      "indent": 3,
      "text": "CMSG_FIRSTHDR() returns a pointer to the first cmsghdr structure in the msghdr structure pointed to by mhdr. The macro returns NULL if there is no ancillary data pointed to the by msghdr structure (that is, if either msg_control is NULL or if msg_controllen is less than the size of a cmsghdr structure).",
      "ja": "CMSG_FIRSTHDR（）は、msghdr構造体の最初のcmsghdr構造体へのポインタは、MHDRによって指さ戻ります。 NULLマクロ戻るには補助データが存在しない場合（いずれかmsg_controlがNULLであるかmsg_controllen場合はcmsghdr構造体のサイズよりも小さい場合には、である）msghdr構造体によって指されます。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be",
      "ja": "1つの可能な実装は、可能性があり"
    },
    {
      "indent": 7,
      "text": "#define CMSG_FIRSTHDR(mhdr) \\\n    ( (mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? \\\n      (struct cmsghdr *)(mhdr)->msg_control : \\\n      (struct cmsghdr *)NULL )",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(Note: Most existing implementations do not test the value of msg_controllen, and just return the value of msg_control. The value of msg_controllen must be tested, because if the application asks recvmsg() to return ancillary data, by setting msg_control to point to the application's buffer and setting msg_controllen to the length of this buffer, the kernel indicates that no ancillary data is available by setting msg_controllen to 0 on return. It is also easier to put this test into this macro, than making the application perform the test.)",
      "ja": "（注：ほとんどの既存の実装がmsg_controllenの値をテストし、ちょうどmsg_controlの値を返しませんmsg_controllenの値をテストする必要があり、アプリケーションが指すようにmsg_controlを設定することにより、補助データを返すために（）のrecvmsgを要求した場合ので。アプリケーションのバッファと、このバッファの長さにmsg_controllenを設定するには、カーネルには補助データは、リターン時に0にmsg_controllenを設定することにより、利用できないことを示している。アプリケーションがテストを実行することよりも、このマクロにこのテストを置くことも簡単です。）"
    },
    {
      "indent": 0,
      "text": "4.3.2. CMSG_NXTHDR",
      "section_title": true,
      "ja": "4.3.2.  CMSG_NXTHDR"
    },
    {
      "indent": 7,
      "text": "struct cmsghdr *CMSG_NXTHDR(const struct msghdr *mhdr,\n                            const struct cmsghdr *cmsg);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "CMSG_NXTHDR() returns a pointer to the cmsghdr structure describing the next ancillary data object. mhdr is a pointer to a msghdr structure and cmsg is a pointer to a cmsghdr structure. If there is not another ancillary data object, the return value is NULL.",
      "ja": "CMSG_NXTHDR（）は、次の補助データオブジェクトを記述したcmsghdr構造体へのポインタを返します。 MHDRはmsghdr構造体へのポインタであり、CMSGはcmsghdr構造体へのポインタです。別の補助的なデータオブジェクトが存在しない場合、戻り値はNULLです。"
    },
    {
      "indent": 3,
      "text": "The following behavior of this macro is new to this API: if the value of the cmsg pointer is NULL, a pointer to the cmsghdr structure describing the first ancillary data object is returned. That is, CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr). If there are no ancillary data objects, the return value is NULL. This provides an alternative way of coding the processing loop shown earlier:",
      "ja": "このマクロの次の動作は、このAPIの新しいですCMSGポインタの値がNULLの場合、最初の補助データオブジェクトを記述したcmsghdr構造体へのポインタが返されます。つまり、CMSG_NXTHDR（MHDR、NULL）がCMSG_FIRSTHDR（MHDR）に相当します。何の補助的なデータオブジェクトが存在しない場合、戻り値はNULLです。これは、先に示した処理ループを符号化する別の方法を提供します。"
    },
    {
      "indent": 0,
      "text": "struct msghdr  msg;\nstruct cmsghdr  *cmsgptr = NULL;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* fill in msg */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* call recvmsg() */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "while ((cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) != NULL) { if (cmsgptr->cmsg_level == ... && cmsgptr->cmsg_type == ... ) { u_char *ptr;",
      "ja": "しばらく（！（cmsgptr = CMSG_NXTHDR（＆MSG、cmsgptr））= NULL）{場合（cmsgptr-> cmsg_levelメンバ== ... && cmsgptr-> cmsg_type == ...）{u_char型の*のPTR。"
    },
    {
      "indent": 0,
      "text": "        ptr = CMSG_DATA(cmsgptr);\n        /* process data pointed to by ptr */\n    }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "一つの可能​​な実装は次のようになります。"
    },
    {
      "indent": 4,
      "text": "#define CMSG_NXTHDR(mhdr, cmsg) \\ ( ((cmsg) == NULL) ? CMSG_FIRSTHDR(mhdr) : \\ (((u_char *)(cmsg) + ALIGN((cmsg)->cmsg_len) \\ + ALIGN(sizeof(struct cmsghdr)) > \\ (u_char *)((mhdr)->msg_control) + (mhdr)->msg_controllen) ? \\ (struct cmsghdr *)NULL : \\ (struct cmsghdr *)((u_char *)(cmsg) + ALIGN((cmsg)->cmsg_len))) )",
      "ja": "#define CMSG_NXTHDR（MHDR、CMSG）\\（（（CMSG）== NULL）CMSG_FIRSTHDR（MHDR）：？\\（（（u_char型*）（CMSG）+ ALIGN（（CMSG） - > CMSG_LEN）\\ + ALIGN（はsizeof（構造体のcmsghdr））> \\（u_char型*）（（MHDR） - > msg_control）+（MHDR） - > msg_controllen）\\（構造体のcmsghdr *）NULL：？\\（構造体のcmsghdr *）（（u_char型*）（CMSG）+ ALIGN（（CMSG） - > CMSG_LEN））））"
    },
    {
      "indent": 3,
      "text": "The macro ALIGN(), which is implementation dependent, rounds its argument up to the next even multiple of whatever alignment is required (probably a multiple of 4 or 8 bytes).",
      "ja": "実装に依存してマクロALIGN（）は、必要とされるどのような位置合わせの次の偶数倍（4または8バイトのおそらく複数）までの引数を丸め。"
    },
    {
      "indent": 0,
      "text": "4.3.3. CMSG_DATA",
      "section_title": true,
      "ja": "4.3.3.  CMSG_DATA"
    },
    {
      "indent": 7,
      "text": "unsigned char *CMSG_DATA(const struct cmsghdr *cmsg);",
      "ja": "unsigned char型* CMSG_DATA（constの構造体のcmsghdr *のCMSG）。"
    },
    {
      "indent": 3,
      "text": "CMSG_DATA() returns a pointer to the data (what is called the cmsg_data[] member, even though such a member is not defined in the structure) following a cmsghdr structure.",
      "ja": "CMSG_DATA（）は、cmsghdr構造体以下（例えば、部材が構造体で定義されていない場合でも、CMSG_DATA []メンバーと呼ばれるもの）データへのポインタを返します。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "一つの可能​​な実装は次のようになります。"
    },
    {
      "indent": 7,
      "text": "#define CMSG_DATA(cmsg) ( (u_char *)(cmsg) + \\\n                          ALIGN(sizeof(struct cmsghdr)) )",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3.4. CMSG_SPACE",
      "section_title": true,
      "ja": "4.3.4.  CMSG_SPACE"
    },
    {
      "indent": 7,
      "text": "unsigned int CMSG_SPACE(unsigned int length);",
      "ja": "unsigned int型CMSG_SPACE（unsigned int型の長さ）。"
    },
    {
      "indent": 3,
      "text": "This macro is new with this API. Given the length of an ancillary data object, CMSG_SPACE() returns the space required by the object and its cmsghdr structure, including any padding needed to satisfy alignment requirements. This macro can be used, for example, to allocate space dynamically for the ancillary data. This macro should not be used to initialize the cmsg_len member of a cmsghdr structure; instead use the CMSG_LEN() macro.",
      "ja": "このマクロは、このAPIで新しく追加されました。補助データオブジェクトの長さが与えられ、CMSG_SPACE（）は、アライメント要件を満たすために必要なパディングを含むオブジェクトとそのcmsghdr構造体に必要なスペースを返します。このマクロは、補助データのための動的領域を割り当てる、例えば、使用することができます。このマクロは、cmsghdr構造体のCMSG_LENメンバを初期化するために使用すべきではありません。代わりCMSG_LEN（）マクロを使用します。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "一つの可能​​な実装は次のようになります。"
    },
    {
      "indent": 7,
      "text": "#define CMSG_SPACE(length) ( ALIGN(sizeof(struct cmsghdr)) + \\\n                             ALIGN(length) )",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3.5. CMSG_LEN",
      "section_title": true,
      "ja": "4.3.5.  CMSG_LEN"
    },
    {
      "indent": 7,
      "text": "unsigned int CMSG_LEN(unsigned int length);",
      "ja": "unsigned int型CMSG_LEN（unsigned int型の長さ）。"
    },
    {
      "indent": 3,
      "text": "This macro is new with this API. Given the length of an ancillary data object, CMSG_LEN() returns the value to store in the cmsg_len member of the cmsghdr structure, taking into account any padding needed to satisfy alignment requirements.",
      "ja": "このマクロは、このAPIで新しく追加されました。補助データオブジェクトの長さが与えられ、CMSG_LEN（）は考慮アラインメント要件を満たすために必要なパディングを取って、cmsghdr構造体のCMSG_LENメンバに格納する値を返します。"
    },
    {
      "indent": 3,
      "text": "One possible implementation could be:",
      "ja": "一つの可能​​な実装は次のようになります。"
    },
    {
      "indent": 7,
      "text": "#define CMSG_LEN(length) ( ALIGN(sizeof(struct cmsghdr)) + length\n)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note the difference between CMSG_SPACE() and CMSG_LEN(), shown also in the figure in Section 4.2: the former accounts for any required padding at the end of the ancillary data object and the latter is the actual length to store in the cmsg_len member of the ancillary data object.",
      "ja": "補助データオブジェクトの末尾に必要なパディングのために元のアカウントを、後者はCMSG_LENメンバーに格納する実際の長さ：4.2節の図にも示さCMSG_SPACE（）とCMSG_LEN（）との差を、注意してください補助的なデータオブジェクト。"
    },
    {
      "indent": 0,
      "text": "4.4. Summary of Options Described Using Ancillary Data",
      "section_title": true,
      "ja": "4.4. オプションの概要は、補助データを用いて説明しました"
    },
    {
      "indent": 3,
      "text": "There are six types of optional information described in this document that are passed between the application and the kernel using ancillary data:",
      "ja": "補助的なデータを使用して、アプリケーションとカーネルの間で渡され、この文書で説明するオプション情報の6種類があります。"
    },
    {
      "indent": 7,
      "text": "1.  the send/receive interface and source/destination address,\n2.  the hop limit,\n3.  next hop address,\n4.  Hop-by-Hop options,\n5.  Destination options, and\n6.  Routing header.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "First, to receive any of this optional information (other than the next hop address, which can only be set), the application must call setsockopt() to turn on the corresponding flag:",
      "ja": "まず、この任意の情報のいずれか（のみ設定することができる次ホップアドレス以外）を受信するように、アプリケーションは、対応するフラグをオンにするのsetsockopt（）を呼び出す必要があります。"
    },
    {
      "indent": 7,
      "text": "int on = 1;",
      "ja": "= 1の整数;"
    },
    {
      "indent": 7,
      "text": "setsockopt(fd, IPPROTO_IPV6, IPV6_PKTINFO,  &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_HOPLIMIT, &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_HOPOPTS,  &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_DSTOPTS,  &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RTHDR,    &on, sizeof(on));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When any of these options are enabled, the corresponding data is returned as control information by recvmsg(), as one or more ancillary data objects.",
      "ja": "これらのオプションのいずれかが有効な場合、対応するデータは、一つ以上の補助的なデータオブジェクトとして）のrecvmsg（の制御情報として返されます。"
    },
    {
      "indent": 3,
      "text": "Nothing special need be done to send any of this optional information; the application just calls sendmsg() and specifies one or more ancillary data objects as control information.",
      "ja": "何も特別な必要性は、このオプションの情報のいずれかを送信するために行われます。アプリケーションだけにsendmsg（）を呼び出し、制御情報などの1つまたは複数の補助的なデータオブジェクトを特定します。"
    },
    {
      "indent": 3,
      "text": "We also summarize the three cmsghdr fields that describe the ancillary data objects:",
      "ja": "また、補助的なデータオブジェクトを記述する3つのcmsghdrフィールドを要約したものです。"
    },
    {
      "indent": 7,
      "text": "cmsg_level    cmsg_type      cmsg_data[]               #times\n------------  ------------   ------------------------  ------\nIPPROTO_IPV6  IPV6_PKTINFO   in6_pktinfo structure     once\nIPPROTO_IPV6  IPV6_HOPLIMIT  int                       once\nIPPROTO_IPV6  IPV6_NEXTHOP   socket address structure  once\nIPPROTO_IPV6  IPV6_HOPOPTS   implementation dependent  mult.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "IPPROTO_IPV6 IPV6_DSTOPTS implementation dependent mult. IPPROTO_IPV6 IPV6_RTHDR implementation dependent once",
      "ja": "IPPROTO_IPV6は実装に依存MULTをIPV6_DSTOPTS。一度依存IPPROTO_IPV6 IPV6_RTHDR実装"
    },
    {
      "indent": 3,
      "text": "The final column indicates how many times an ancillary data object of that type can appear as control information. The Hop-by-Hop and Destination options can appear multiple times, while all the others can appear only one time.",
      "ja": "最後の列は、そのタイプの補助データオブジェクトは、制御情報として表示することができる回数を示しています。他のすべては、一度だけを表示することができながら、バイホップホップと宛先オプションは、複数回表示されることができます。"
    },
    {
      "indent": 3,
      "text": "All these options are described in detail in following sections. All the constants beginning with IPV6_ are defined as a result of including the <netinet/in.h> header.",
      "ja": "これらのオプションはすべてのセクションを以下に詳細に記載されています。 IPV6_で始まるすべての定数は、<netinetの/ in.h>ヘッダを含めた結果として定義されます。"
    },
    {
      "indent": 3,
      "text": "(Note: We intentionally use the same constant for the cmsg_level member as is used as the second argument to getsockopt() and setsockopt() (what is called the \"level\"), and the same constant for the cmsg_type member as is used as the third argument to getsockopt() and setsockopt() (what is called the \"option name\"). This is consistent with the existing use of ancillary data in 4.4BSD: returning the destination address of an IPv4 datagram.)",
      "ja": "使用されるGETSOCKOPT第2の引数として使用される（我々が意図的cmsg_levelメンバ部材に同じ定数を使用）とのsetsockopt（）（「レベル」と呼ばれるもの）、およびcmsg_type部材に対して同じ定数（注第三GETSOCKOPTの引数（）と（「オプション名」と呼ばれるもの）のsetsockopt（）これは4.4BSDでの補助的なデータの既存の使用と一致している：。。のIPv4データグラムの宛先アドレスを返します）"
    },
    {
      "indent": 3,
      "text": "(Note: It is up to the implementation what it passes as ancillary data for the Hop-by-Hop option, Destination option, and Routing header option, since the API to these features is through a set of inet6_option_XXX() and inet6_rthdr_XXX() functions that we define later. These functions serve two purposes: to simplify the interface to these features (instead of requiring the application to know the intimate details of the extension header formats), and to hide the actual implementation from the application. Nevertheless, we show some examples of these features that store the actual extension header as the ancillary data. Implementations need not use this technique.)",
      "ja": "（注：それはホップバイホップオプション、宛先オプション、およびルーティング・ヘッダ・オプションと補助データを渡すもの実装に任されて、これらの機能のAPIはinet6_option_XXX（）とinet6_rthdr_XXXのセットを介してであるので（） 。我々は、後で定義する機能は、これらの機能は、2つの目的を果たす：それにもかかわらず（代わりに、拡張ヘッダフォーマットの親密な詳細を知るためのアプリケーションを必要とする）、これらの機能へのインタフェースを簡素化するために、アプリケーションからの実際の実装を隠すために、我々補助データとして実際の拡張ヘッダを格納し、これらの機能のいくつかの例を示す。実装は、この手法を使用する必要はありません。）"
    },
    {
      "indent": 0,
      "text": "4.5. IPV6_PKTOPTIONS Socket Option",
      "section_title": true,
      "ja": "4.5.  IPV6_PKTOPTIONSソケットオプション"
    },
    {
      "indent": 3,
      "text": "The summary in the previous section assumes a UDP socket. Sending and receiving ancillary data is easy with UDP: the application calls sendmsg() and recvmsg() instead of sendto() and recvfrom().",
      "ja": "前節の概要はUDPソケットを前提としています。送信と補助データを受信すると、UDPと簡単です：アプリケーションの呼び出しにsendmsg（）とのrecvmsg（）の代わりのsendto（）とのrecvfrom（）。"
    },
    {
      "indent": 3,
      "text": "But there might be cases where a TCP application wants to send or receive this optional information. For example, a TCP client might want to specify a Routing header and this needs to be done before calling connect(). Similarly a TCP server might want to know the received interface after accept() returns along with any Destination options.",
      "ja": "しかし、TCPアプリケーションは、このオプション情報を送信または受信したい場合があるかもしれません。たとえば、TCPクライアントは、ルーティングヘッダを指定したい場合があり、これは（）を呼び出す前に接続して行われる必要があります。同様にTCPサーバ）が後に（受け入れ受信したインターフェイスを知りたいかもしれない任意の宛先オプションと一緒に返します。"
    },
    {
      "indent": 3,
      "text": "A new socket option is defined that provides access to the optional information described in the previous section, but without using recvmsg() and sendmsg(). Setting the socket option specifies any of the optional output fields:",
      "ja": "新しいソケットオプションは、前のセクションで説明した任意の情報へのアクセスを提供し、その定義された、しかしのrecvmsg（）とにsendmsgを使用せずに（）されています。ソケットオプションを設定すると、オプションの出力フィールドのいずれかを指定します。"
    },
    {
      "indent": 7,
      "text": "setsockopt(fd, IPPROTO_IPV6, IPV6_PKTOPTIONS, &buf, len);",
      "ja": "setsockopt（FD、IPPROTO_IPV6、IPV6_PKTOPTIONS、＆BUF、LEN）。"
    },
    {
      "indent": 3,
      "text": "The fourth argument points to a buffer containing one or more ancillary data objects, and the fifth argument is the total length of all these objects. The application fills in this buffer exactly as if the buffer were being passed to sendmsg() as control information.",
      "ja": "一つ以上の補助的なデータオブジェクトを含むバッファへの第四引数点、及び5番目の引数は、すべてのこれらのオブジェクトの長さの合計です。アプリケーションは、このバッファに正確に（）バッファがSENDMSGに渡されていたかのように制御情報として埋め。"
    },
    {
      "indent": 3,
      "text": "The options set by calling setsockopt() for IPV6_PKTOPTIONS are called \"sticky\" options because once set they apply to all packets sent on that socket. The application can call setsockopt() again to change all the sticky options, or it can call setsockopt() with a length of 0 to remove all the sticky options for the socket.",
      "ja": "一度設定し、彼らはそのソケット上で送信されるすべてのパケットに適用されますのでIPV6_PKTOPTIONSは、setsockopt（）を呼び出すことによって設定されたオプションは、「スティッキー」オプションと呼ばれています。アプリケーションは、すべてのスティッキーオプションを変更するために、再度のsetsockopt（）を呼び出すことができ、またはそれはソケットのすべてのスティッキオプションを除去するために、0の長さ（）のsetsockoptを呼び出すことができます。"
    },
    {
      "indent": 3,
      "text": "The corresponding receive option",
      "ja": "オプションを受け取る対応"
    },
    {
      "indent": 7,
      "text": "getsockopt(fd, IPPROTO_IPV6, IPV6_PKTOPTIONS, &buf, &len);",
      "ja": "getsockopt（FD、IPPROTO_IPV6、IPV6_PKTOPTIONS、＆BUF、＆LEN）。"
    },
    {
      "indent": 3,
      "text": "returns a buffer with one or more ancillary data objects for all the optional receive information that the application has previously specified that it wants to receive. The fourth argument points to the buffer that is filled in by the call. The fifth argument is a pointer to a value-result integer: when the function is called the integer specifies the size of the buffer pointed to by the fourth argument, and on return this integer contains the actual number of bytes that were returned. The application processes this buffer exactly as if the buffer were returned by recvmsg() as control information.",
      "ja": "オプションは、アプリケーションが以前にそれを受信したいことを指定した情報を受信するすべてのための一つ以上の補助的なデータオブジェクトでバッファを返します。四番目の引数は、呼び出しによって記入されたバッファを指しています。 5番目の引数の値結果整数へのポインタである：関数が呼び出されたとき整数バッファのサイズは、第四の引数によって指さ特定し、リターンに、この整数が戻された実際のバイト数を含んでいます。バッファは、制御情報としてのrecvmsg（）によって返された正確かのようにアプリケーション・プロセスのバッファ。"
    },
    {
      "indent": 3,
      "text": "To simplify this document, in the remaining sections when we say \"can be specified as ancillary data to sendmsg()\" we mean \"can be specified as ancillary data to sendmsg() or specified as a sticky option using setsockopt() and the IPV6_PKTOPTIONS socket option\". Similarly when we say \"can be returned as ancillary data by recvmsg()\" we mean \"can be returned as ancillary data by recvmsg() or returned by getsockopt() with the IPV6_PKTOPTIONS socket option\".",
      "ja": "私たちが言うとき、残りのセクションでは、この文書を簡素化するために「SENDMSGする補助データ（）として指定することができ、」我々は「SENDMSGする補助データとして指定された（）またはのsetsockopt（）とIPV6_PKTOPTIONSを使用して粘着性のオプションとして指定することを意味しますソケットオプション」。私たちが言う場合も同様に「のrecvmsgによって補助データとして返すことができます（）」我々は意味「（のrecvmsgによって補助データとして返される）または（）IPV6_PKTOPTIONSソケットオプションでのgetsockoptで返すことができます」。"
    },
    {
      "indent": 0,
      "text": "4.5.1. TCP Sticky Options",
      "section_title": true,
      "ja": "4.5.1.  TCPスティッキーオプション"
    },
    {
      "indent": 3,
      "text": "When using getsockopt() with the IPV6_PKTOPTIONS option and a TCP socket, only the options from the most recently received segment are retained and returned to the caller, and only after the socket option has been set. That is, TCP need not start saving a copy of the options until the application says to do so.",
      "ja": "IPV6_PKTOPTIONSオプションとTCPソケットでのgetsockopt（）を使用する場合は、最後に受信したセグメントからの唯一のオプションは保持され、呼び出し元に返され、ソケットオプションが設定された後にのみされています。これは、アプリケーションがそうするようにと言うまで、TCPは、オプションのコピーの保存を開始する必要はない、です。"
    },
    {
      "indent": 3,
      "text": "The application is not allowed to specify ancillary data in a call to sendmsg() on a TCP socket, and none of the ancillary data that we describe in this document is ever returned as control information by recvmsg() on a TCP socket.",
      "ja": "TCPソケット上で）アプリケーションは、TCPソケット上）（SENDMSGへの呼び出しに補助データを指定することが許可されていない、と私たちは、この文書で説明する補助データのいずれも、これまでのrecvmsg（による制御情報として返されません。"
    },
    {
      "indent": 0,
      "text": "4.5.2. UDP and Raw Socket Sticky Options",
      "section_title": true,
      "ja": "4.5.2.  UDPと生ソケットスティッキーオプション"
    },
    {
      "indent": 3,
      "text": "The IPV6_PKTOPTIONS socket option can also be used with a UDP socket or with a raw IPv6 socket, normally to set some of the options once, instead of with each call to sendmsg().",
      "ja": "IPV6_PKTOPTIONSソケットオプションも）一度、いくつかのオプションを設定し、代わりに（SENDMSGするために、各コールにするために、通常、UDPソケットまたは生のIPv6ソケットで使用することができます。"
    },
    {
      "indent": 3,
      "text": "Unlike the TCP case, the sticky options can be overridden on a per-packet basis with ancillary data specified in a call to sendmsg() on a UDP or raw IPv6 socket. If any ancillary data is specified in a call to sendmsg(), none of the sticky options are sent with that datagram.",
      "ja": "TCPの場合とは異なり、粘着性のオプションは、UDPまたは生のIPv6ソケット上）（SENDMSGの呼び出しで指定された補助データをパケット単位で上書きすることができます。任意の補助データは、（）SENDMSGの呼び出しで指定されている場合は、粘着性のオプションのいずれもそのデータグラムで送信されません。"
    },
    {
      "indent": 0,
      "text": "5. Packet Information",
      "section_title": true,
      "ja": "5.パケット情報"
    },
    {
      "indent": 3,
      "text": "There are four pieces of information that an application can specify for an outgoing packet using ancillary data:",
      "ja": "アプリケーションは、補助的なデータを使用して発信パケットに指定できる4件の情報があります。"
    },
    {
      "indent": 7,
      "text": "1.  the source IPv6 address,\n2.  the outgoing interface index,\n3.  the outgoing hop limit, and\n4.  the next hop address.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Three similar pieces of information can be returned for a received packet as ancillary data:",
      "ja": "情報の三つの同様の部分は補助的なデータとして受信したパケットのために返すことができます。"
    },
    {
      "indent": 7,
      "text": "1.  the destination IPv6 address,\n2.  the arriving interface index, and\n3.  the arriving hop limit.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first two pieces of information are contained in an in6_pktinfo structure that is sent as ancillary data with sendmsg() and received as ancillary data with recvmsg(). This structure is defined as a result of including the <netinet/in.h> header.",
      "ja": "情報の最初の2枚（）にsendmsgと補助データとして送信さin6_pktinfo構造に含まれ、（）のrecvmsgと補助データとして受信されます。この構造体は、<netinetの/ in.h>ヘッダを含むの結果として定義されます。"
    },
    {
      "indent": 7,
      "text": "struct in6_pktinfo {\n  struct in6_addr ipi6_addr;    /* src/dst IPv6 address */\n  unsigned int    ipi6_ifindex; /* send/recv interface index */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_PKTINFO, and the first byte of cmsg_data[] will be the first byte of the in6_pktinfo structure.",
      "ja": "この補助データを含むcmsghdr構造体で、cmsg_levelメンバーはIPPROTO_IPV6なり、cmsg_type部材はIPV6_PKTINFOなり、CMSG_DATAの最初のバイトは[] in6_pktinfo構造の最初のバイトであろう。"
    },
    {
      "indent": 3,
      "text": "This information is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_PKTINFO socket option:",
      "ja": "この情報は、アプリケーションがIPV6_PKTINFOソケットオプションを有効にしている場合のみ）（のrecvmsgによって補助データとして返されます。"
    },
    {
      "indent": 7,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_PKTINFO, &on, sizeof(on));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Nothing special need be done to send this information: just specify the control information as ancillary data for sendmsg().",
      "ja": "この情報を送信するために行うことは何も特別な必要性：ただsendmsgのための補助的なデータとして制御情報を指定します（）。"
    },
    {
      "indent": 3,
      "text": "(Note: The hop limit is not contained in the in6_pktinfo structure for the following reason. Some UDP servers want to respond to client requests by sending their reply out the same interface on which the request was received and with the source IPv6 address of the reply equal to the destination IPv6 address of the request. To do this the application can enable just the IPV6_PKTINFO socket option and then use the received control information from recvmsg() as the outgoing control information for sendmsg(). The application need not examine or modify the in6_pktinfo structure at all. But if the hop limit were contained in this structure, the application would have to parse the received control information and change the hop limit member, since the received hop limit is not the desired value for an outgoing packet.)",
      "ja": "（注：ホップ限界は次の理由in6_pktinfo構造に含まれていないいくつかのUDPサーバは要求を受信したのと同じインターフェイスから、応答の送信元IPv6アドレスとその回答を送信することによって、クライアントの要求に応答します。リクエストの宛先IPv6アドレスに等しい。このアプリケーションだけIPV6_PKTINFOソケットオプションを有効にしてからは、sendmsg（の発信制御情報としてのrecvmsg（）から受信した制御情報を使用することができます行うには）。アプリケーションは、検査または変更する必要はありませんホップ限界がこの構造に含まれた場合in6_pktinfo構造は全く。しかし、アプリケーションは、受信したホップ限界は、発信パケットのための所望の値ではないので、受信した制御情報を解析し、ホップリミット部材を変更しなければなりません。）"
    },
    {
      "indent": 0,
      "text": "5.1. Specifying/Receiving the Interface",
      "section_title": true,
      "ja": "5.1. インターフェイスの受信/指定"
    },
    {
      "indent": 3,
      "text": "Interfaces on an IPv6 node are identified by a small positive integer, as described in Section 4 of [RFC-2133]. That document also describes a function to map an interface name to its interface index, a function to map an interface index to its interface name, and a function to return all the interface names and indexes. Notice from this document that no interface is ever assigned an index of 0.",
      "ja": "[RFC-2133]のセクション4で説明したようにIPv6ノード上のインタフェースは、小さな正の整数によって識別されます。その文書はまた、インタフェースインデックス、そのインタフェース名にインタフェースインデックスをマッピングする機能、およびすべてのインターフェイス名とインデックスを返す関数へのインターフェイス名をマッピングするための機能について説明します。何のインターフェースがこれまで0のインデックスが割り当てられていない、この文書から注意してください。"
    },
    {
      "indent": 3,
      "text": "When specifying the outgoing interface, if the ipi6_ifindex value is 0, the kernel will choose the outgoing interface. If the application specifies an outgoing interface for a multicast packet, the interface specified by the ancillary data overrides any interface specified by the IPV6_MULTICAST_IF socket option (described in [RFC-2133]), for that call to sendmsg() only.",
      "ja": "発信インターフェイスを指定する場合ipi6_ifindex値が0であれば、カーネルが発信インターフェイスを選択します。アプリケーションは、マルチキャストパケットの発信インターフェイスを指定している場合、補助データで指定されたインターフェイスのみ）（その呼び出しがSENDMSGするために、（[RFC-2133]に記載されている）IPV6_MULTICAST_IFソケットオプションで指定された任意のインターフェイスをオーバーライド。"
    },
    {
      "indent": 3,
      "text": "When the IPV6_PKTINFO socket option is enabled, the received interface index is always returned as the ipi6_ifindex member of the in6_pktinfo structure.",
      "ja": "IPV6_PKTINFOソケットオプションが有効になっている場合、受信インタフェースインデックスは常にin6_pktinfo構造のipi6_ifindexメンバーとして返されます。"
    },
    {
      "indent": 0,
      "text": "5.2. Specifying/Receiving Source/Destination Address",
      "section_title": true,
      "ja": "5.2. 指定受信/送信元/宛先アドレス"
    },
    {
      "indent": 3,
      "text": "The source IPv6 address can be specified by calling bind() before each output operation, but supplying the source address together with the data requires less overhead (i.e., fewer system calls) and requires less state to be stored and protected in a multithreaded application.",
      "ja": "送信元IPv6アドレスが各出力動作の前にバインド（）を呼び出すが、データと共にソースアドレスを供給することによって特定することができるが少ないオーバーヘッド（すなわち、より少ないシステムコール）を必要とし、記憶し、マルチスレッドのアプリケーションで保護されるべきより少ない状態を必要とします。"
    },
    {
      "indent": 3,
      "text": "When specifying the source IPv6 address as ancillary data, if the ipi6_addr member of the in6_pktinfo structure is the unspecified address (IN6ADDR_ANY_INIT), then (a) if an address is currently bound to the socket, it is used as the source address, or (b) if no address is currently bound to the socket, the kernel will choose the source address. If the ipi6_addr member is not the unspecified address, but the socket has already bound a source address, then the ipi6_addr value overrides the already-bound source address for this output operation only.",
      "ja": "in6_pktinfo構造のipi6_addr部材は、その後、不特定のアドレス（IN6ADDR_ANY_INIT）である場合、補助データとして送信元IPv6アドレスを指定するとき、アドレスが現在のソケットにバインドされている場合（A）には、送信元アドレスとして使用されるか、または（何のアドレスが現在のソケットにバインドされていない場合b）に、カーネルは、送信元アドレスを選択します。 ipi6_addrメンバーが未指定のアドレスではなく、ソケットがすでに元アドレスをバインドしている場合は、ipi6_addr値にのみ、この出力動作のためにすでに結合元アドレスを上書きします。"
    },
    {
      "indent": 3,
      "text": "The kernel must verify that the requested source address is indeed a unicast address assigned to the node.",
      "ja": "カーネルは、要求された送信元アドレスが実際にノードに割り当てられたユニキャストアドレスであることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the in6_pktinfo structure is returned as ancillary data by recvmsg(), the ipi6_addr member contains the destination IPv6 address from the received packet.",
      "ja": "in6_pktinfo構造が）のrecvmsg（によって補助データとして返されるとき、ipi6_addr部材は、受信したパケットから宛先IPv6アドレスを含んでいます。"
    },
    {
      "indent": 0,
      "text": "5.3. Specifying/Receiving the Hop Limit",
      "section_title": true,
      "ja": "5.3. ホップ制限を受ける/指定"
    },
    {
      "indent": 3,
      "text": "The outgoing hop limit is normally specified with either the IPV6_UNICAST_HOPS socket option or the IPV6_MULTICAST_HOPS socket option, both of which are described in [RFC-2133]. Specifying the hop limit as ancillary data lets the application override either the kernel's default or a previously specified value, for either a unicast destination or a multicast destination, for a single output operation. Returning the received hop limit is useful for programs such as Traceroute and for IPv6 applications that need to verify that the received hop limit is 255 (e.g., that the packet has not been forwarded).",
      "ja": "[RFC-2133]に記載されている両方とも発信ホップ制限は、通常、IPV6_UNICAST_HOPSソケットオプションまたはIPV6_MULTICAST_HOPSソケットオプションのいずれかで指定されています。補助データは、アプリケーションが単一出力操作のために、ユニキャスト宛先またはマルチキャストの宛先のいずれかのために、カーネルのデフォルトまたは以前に指定した値のいずれかをオーバーライドすることができますようホップ制限を指定します。受信ホップ限界を返すことは、このようなトレースルートのようなプログラムおよび受信ホップ制限が255（例えば、パケットが転送されていないこと）であることを確認する必要があるIPv6アプリケーションに有用です。"
    },
    {
      "indent": 3,
      "text": "The received hop limit is returned as ancillary data by recvmsg() only if the application has enabled the IPV6_HOPLIMIT socket option:",
      "ja": "受信ホップ限界は、アプリケーションがIPV6_HOPLIMITソケットオプションを有効にしている場合のみ）（のrecvmsgによって補助データとして返されます。"
    },
    {
      "indent": 7,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_HOPLIMIT, &on, sizeof(on));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_HOPLIMIT, and the first byte of cmsg_data[] will be the first byte of the integer hop limit.",
      "ja": "この補助データを含むcmsghdr構造体で、cmsg_levelメンバーはIPPROTO_IPV6なり、cmsg_type部材はIPV6_HOPLIMITなり、CMSG_DATAの最初のバイト[]は整数ホップ限界の最初のバイトであろう。"
    },
    {
      "indent": 3,
      "text": "Nothing special need be done to specify the outgoing hop limit: just specify the control information as ancillary data for sendmsg(). As specified in [RFC-2133], the interpretation of the integer hop limit value is",
      "ja": "何も特別な必要性が出ホップ制限を指定するために行われる。ただsendmsgのための補助的なデータとして制御情報を指定します（）。 [RFC-2133]で指定されるように、整数ホップ限界値の解釈であります"
    },
    {
      "indent": 7,
      "text": "x < -1:        return an error of EINVAL\nx == -1:       use kernel default\n0 <= x <= 255: use x\nx >= 256:      return an error of EINVAL",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.4. Specifying the Next Hop Address",
      "section_title": true,
      "ja": "5.4. ネクストホップアドレスを指定します"
    },
    {
      "indent": 3,
      "text": "The IPV6_NEXTHOP ancillary data object specifies the next hop for the datagram as a socket address structure. In the cmsghdr structure containing this ancillary data, the cmsg_level member will be IPPROTO_IPV6, the cmsg_type member will be IPV6_NEXTHOP, and the first byte of cmsg_data[] will be the first byte of the socket address structure.",
      "ja": "IPV6_NEXTHOP補助データオブジェクトは、ソケットアドレス構造体としてデータグラムのための次のホップを指定します。この補助データを含むcmsghdr構造体で、cmsg_levelメンバーはIPPROTO_IPV6なり、cmsg_type部材はIPV6_NEXTHOPなり、CMSG_DATAの最初のバイト[]はソケットアドレス構造の最初のバイトであろう。"
    },
    {
      "indent": 3,
      "text": "This is a privileged option. (Note: It is implementation defined and beyond the scope of this document to define what \"privileged\" means. Unix systems use this term to mean the process must have an effective user ID of 0.)",
      "ja": "これは特権オプションです。 （注：どのような「特権」の手段を定義するために、実装定義されており、このドキュメントの範囲を超えているUnixシステムは、プロセスを意味するためにこの用語を使用し、0の実効ユーザーIDを持っている必要があります。）"
    },
    {
      "indent": 3,
      "text": "If the socket address structure contains an IPv6 address (e.g., the sin6_family member is AF_INET6), then the node identified by that address must be a neighbor of the sending host. If that address equals the destination IPv6 address of the datagram, then this is equivalent to the existing SO_DONTROUTE socket option.",
      "ja": "ソケットアドレス構造体（例えば、sin6_family部材がAF_INET6である）のIPv6アドレスが含まれている場合は、そのアドレスによって識別されるノードは、送信ホストの近隣でなければなりません。そのアドレスがデータグラムの宛先IPv6アドレスに等しい場合、これは、既存のSO_DONTROUTEソケットオプションに相当します。"
    },
    {
      "indent": 0,
      "text": "5.5. Additional Errors with sendmsg()",
      "section_title": true,
      "ja": "5.5.  sendmsgのと追加のエラー（）"
    },
    {
      "indent": 3,
      "text": "With the IPV6_PKTINFO socket option there are no additional errors possible with the call to recvmsg(). But when specifying the outgoing interface or the source address, additional errors are possible from sendmsg(). The following are examples, but some of these may not be provided by some implementations, and some implementations may define additional errors:",
      "ja": "IPV6_PKTINFOソケットオプションで追加のエラーがrecvmsgの呼び出しで可能はありません（）。発信インターフェイスまたは送信元アドレスを指定する場合には、追加のエラーがsendmsgのから（）が可能です。以下は一例であり、これらのいくつかは、いくつかの実装によって提供されない場合があり、そしていくつかの実装形態は、追加のエラーを定義してもよいです。"
    },
    {
      "indent": 3,
      "text": "ENXIO The interface specified by ipi6_ifindex does not exist.",
      "ja": "ENXIO ipi6_ifindexで指定されたインターフェイスは存在しません。"
    },
    {
      "indent": 3,
      "text": "ENETDOWN The interface specified by ipi6_ifindex is not enabled for IPv6 use.",
      "ja": "ENETDOWN ipi6_ifindexで指定されたインターフェイスは、IPv6の使用が有効になっていません。"
    },
    {
      "indent": 3,
      "text": "EADDRNOTAVAIL ipi6_ifindex specifies an interface but the address ipi6_addr is not available for use on that interface.",
      "ja": "EADDRNOTAVAIL ipi6_ifindexインターフェイスを指定するが、アドレスipi6_addrは、そのインターフェイス上で使用することはできません。"
    },
    {
      "indent": 3,
      "text": "EHOSTUNREACH No route to the destination exists over the interface specified by ifi6_ifindex.",
      "ja": "EHOSTUNREACH宛先へのルートがifi6_ifindexによって指定されたインターフェイス上存在しません。"
    },
    {
      "indent": 0,
      "text": "6. Hop-By-Hop Options",
      "section_title": true,
      "ja": "6.ホップバイホップオプション"
    },
    {
      "indent": 3,
      "text": "A variable number of Hop-by-Hop options can appear in a single Hop-by-Hop options header. Each option in the header is TLV-encoded with a type, length, and value.",
      "ja": "ホップバイホップオプションの可変数は、単一のホップバイホップオプションヘッダに現れることができます。ヘッダの各オプションは、タイプ、長さ、および値でTLVエンコードされています。"
    },
    {
      "indent": 3,
      "text": "Today only three Hop-by-Hop options are defined for IPv6 [RFC-1883]: Jumbo Payload, Pad1, and PadN, although a proposal exists for a router-alert Hop-by-Hop option. The Jumbo Payload option should not be passed back to an application and an application should receive an error if it attempts to set it. This option is processed entirely by the kernel. It is indirectly specified by datagram-based applications as the size of the datagram to send and indirectly passed back to these applications as the length of the received datagram. The two pad options are for alignment purposes and are automatically inserted by a sending kernel when needed and ignored by",
      "ja": "今日は3つだけのホップバイホップオプションは、[RFC-1883] IPv6のために定義されています：ジャンボペイロード、パッド1、及びパッドN、提案はルータアラートホップバイホップオプションのために存在するが。巨大ペイロードオプションは、アプリケーションに戻されるべきではない、それはそれを設定しようとした場合にアプリケーションがエラーを受け取る必要があります。このオプションは、カーネルによって完全に処理されます。これは間接的に送信するためのデータグラムのサイズなどのデータグラムベースのアプリケーションによって指定され、間接的に受信したデータグラムの長さとして、これらのアプリケーションに戻されます。 2つのパッドオプションは、アライメント目的としたものであり、必要とで無視するときに自動的に送信するカーネルによって挿入されています"
    },
    {
      "indent": 3,
      "text": "the receiving kernel. This section of the API is therefore defined for future Hop-by-Hop options that an application may need to specify and receive.",
      "ja": "受信カーネル。 APIのこのセクションでは、したがって、アプリケーションが指定して受信する必要があり、将来のホップバイホップオプションのために定義されています。"
    },
    {
      "indent": 3,
      "text": "Individual Hop-by-Hop options (and Destination options, which are described shortly, and which are similar to the Hop-by-Hop options) may have specific alignment requirements. For example, the 4-byte Jumbo Payload length should appear on a 4-byte boundary, and IPv6 addresses are normally aligned on an 8-byte boundary. These requirements and the terminology used with these options are discussed in Section 4.2 and Appendix A of [RFC-1883]. The alignment of each option is specified by two values, called x and y, written as \"xn + y\". This states that the option must appear at an integer multiple of x bytes from the beginning of the options header (x can have the values 1, 2, 4, or 8), plus y bytes (y can have a value between 0 and 7, inclusive). The Pad1 and PadN options are inserted as needed to maintain the required alignment. Whatever code builds either a Hop-by-Hop options header or a Destination options header must know the values of x and y for each option.",
      "ja": "個々のホップバイホップオプション固有のアラインメント要件を有することができる（簡単に説明されており、及び宛先オプションは、ホップバイホップオプションと同様です）。例えば、4バイトのジャンボペイロード長は、4バイト境界上に表示され、そしてIPv6アドレスは、通常、8バイト境界で整列されています。これらの要件は、これらのオプションで使用される用語は、[RFC-1883]のセクション4.2および付録Aに記載されています。各オプションの整列は「XN + Y」と書かれたxとyと呼ばれる2つの値によって指定されます。このオプションは、オプションヘッダの先頭からxバイトの整数倍で現れなければならないと述べて、プラスYバイト（xは値1、2、4、または8を有することができる）（yは0と7の間の値を持つことができ、包括的）。必要な整列を維持するために必要に応じてパッド1およびパッドNオプションが挿入されています。どんなコードホップバイホップオプションヘッダまたは各オプションのxとyの値を知らなければならない宛先オプションヘッダのいずれかを構築します。"
    },
    {
      "indent": 3,
      "text": "Multiple Hop-by-Hop options can be specified by the application. Normally one ancillary data object describes all the Hop-by-Hop options (since each option is itself TLV-encoded) but the application can specify multiple ancillary data objects for the Hop-by-Hop options, each object specifying one or more options. Care must be taken designing the API for these options since",
      "ja": "複数のホップバイホップオプションは、アプリケーションによって指定することができます。通常1つの補助データオブジェクトは、すべてのホップバイホップオプションを（各オプションは、それ自体であるため、TLVエンコード）について説明が、アプリケーションは、ホップバイホップオプションの1つ以上のオプションを指定する各オブジェクトを複数の補助データオブジェクトを指定することができます。ケアは、以来、これらのオプションのAPIを設計取られなければなりません"
    },
    {
      "indent": 3,
      "text": "1. it may be possible for some future Hop-by-Hop options to be generated by the application and processed entirely by the application (e.g., the kernel may not know the alignment restrictions for the option),",
      "ja": "1.それは（例えば、カーネルは、オプションの位置合わせの制約を知らないかもしれない）アプリケーションによって生成され、アプリケーションによって完全に処理されるいくつかの将来のホップバイホップオプションの可能性があり、"
    },
    {
      "indent": 3,
      "text": "2. it must be possible for the kernel to insert its own Hop-by-Hop options in an outgoing packet (e.g., the Jumbo Payload option),",
      "ja": "2.それは、発信パケットの独自のホップバイホップオプション（例えば、巨大ペイロードオプション）を挿入するために、カーネルのために可能でなければなりません、"
    },
    {
      "indent": 3,
      "text": "3. the application can place one or more Hop-by-Hop options into a single ancillary data object,",
      "ja": "3.アプリケーションは、単一の補助データオブジェクトに一つ以上のホップバイホップオプションを配置することができ、"
    },
    {
      "indent": 3,
      "text": "4. if the application specifies multiple ancillary data objects, each containing one or more Hop-by-Hop options, the kernel must combine these a single Hop-by-Hop options header, and",
      "ja": "アプリケーションはそれぞれ、1つまたは複数のホップバイホップオプションを含む、複数の補助データオブジェクトを指定する場合、カーネルは、これらを単一ホップバイホップオプションヘッダを結合しなければならない4、及び"
    },
    {
      "indent": 3,
      "text": "5. it must be possible for the kernel to remove some Hop-by-Hop options from a received packet before returning the remaining Hop-by-Hop options to the application. (This removal might consist of the kernel converting the option into a pad option of the same length.)",
      "ja": "カーネルは、アプリケーションに残りのホップバイホップオプションを返す前に、受信したパケットから、いくつかのホップバイホップオプションを削除する5.ことが可能でなければなりません。 （この除去は、同じ長さのパッドオプションにオプションを変換カーネルから成るかもしれません。）"
    },
    {
      "indent": 3,
      "text": "Finally, we note that access to some Hop-by-Hop options or to some Destination options, might require special privilege. That is, normal applications (without special privilege) might be forbidden from setting certain options in outgoing packets, and might never see certain options in received packets.",
      "ja": "最後に、我々はいくつかのホップバイホップオプションまたはいくつかの宛先オプションへのアクセスは、特別な権限を必要とするかもしれないことに注意してください。それは、（特別な権限なし）通常のアプリケーションでは、発信パケットで特定のオプションを設定することが禁止される可能性がありますされ、受信したパケットで特定のオプションを見ることはないかもしれません。"
    },
    {
      "indent": 0,
      "text": "6.1. Receiving Hop-by-Hop Options",
      "section_title": true,
      "ja": "6.1. ホップバイホップオプションを受け取ります"
    },
    {
      "indent": 3,
      "text": "To receive Hop-by-Hop options the application must enable the IPV6_HOPOPTS socket option:",
      "ja": "ホップバイホップオプションを受信するにはアプリケーションがIPV6_HOPOPTSソケットオプションを有効にする必要があります。"
    },
    {
      "indent": 7,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_HOPOPTS, &on, sizeof(on));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All the Hop-by-Hop options are returned as one ancillary data object described by a cmsghdr structure. The cmsg_level member will be IPPROTO_IPV6 and the cmsg_type member will be IPV6_HOPOPTS. These options are then processed by calling the inet6_option_next() and inet6_option_find() functions, described shortly.",
      "ja": "すべてのホップバイホップオプションは、cmsghdr構造体によって説明したもの補助データオブジェクトとして返されます。 cmsg_levelメンバのメンバはIPPROTO_IPV6になり、cmsg_typeメンバーはIPV6_HOPOPTSになります。これらのオプションは、その後まもなく説明し、inet6_option_next（）とinet6_option_find（）関数を呼び出すことによって処理されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Sending Hop-by-Hop Options",
      "section_title": true,
      "ja": "6.2. ホップバイホップオプションを送信"
    },
    {
      "indent": 3,
      "text": "To send one or more Hop-by-Hop options, the application just specifies them as ancillary data in a call to sendmsg(). No socket option need be set.",
      "ja": "一つ以上のホップバイホップオプションを送信するには、アプリケーションがちょうどSENDMSGへの呼び出しで補助的なデータとしてそれらを指定します（）。いいえソケットオプションを設定する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Normally all the Hop-by-Hop options are specified by a single ancillary data object. Multiple ancillary data objects, each containing one or more Hop-by-Hop options, can also be specified, in which case the kernel will combine all the Hop-by-Hop options into a single Hop-by-Hop extension header. But it should be more efficient to use a single ancillary data object to describe all the Hop-by-Hop options. The cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is set to IPV6_HOPOPTS. The option is normally constructed using the inet6_option_init(), inet6_option_append(), and inet6_option_alloc() functions, described shortly.",
      "ja": "通常、すべてのホップバイホップオプションは、単一の補助データオブジェクトで指定されています。複数の補助的なデータオブジェクトは、それぞれ含有する1つ以上のホップバイホップオプションは、また、その場合、カーネルは単一ホップバイホップ拡張ヘッダにすべてのホップバイホップオプションを組み合わせるので、特定することができます。しかし、すべてのホップバイホップオプションを記述するために、単一の補助的なデータオブジェクトを使用する方が効率的でなければなりません。 cmsg_levelメンバメンバーはIPPROTO_IPV6に設定され、cmsg_typeメンバーはIPV6_HOPOPTSに設定されています。オプションは、通常、簡単に説明inet6_option_init（）、inet6_option_append（）、及びinet6_option_alloc（）関数を使用して構築されています。"
    },
    {
      "indent": 3,
      "text": "Additional errors may be possible from sendmsg() if the specified option is in error.",
      "ja": "指定されたオプションにエラーがある場合は、追加のエラーは）（にsendmsgから可能かもしれません。"
    },
    {
      "indent": 0,
      "text": "6.3. Hop-by-Hop and Destination Options Processing",
      "section_title": true,
      "ja": "6.3. ホップバイホップと宛先のオプション処理"
    },
    {
      "indent": 3,
      "text": "Building and parsing the Hop-by-Hop and Destination options is complicated for the reasons given earlier. We therefore define a set of functions to help the application. The function prototypes for these functions are all in the <netinet/in.h> header.",
      "ja": "ビルやバイホップホップと宛先オプションを解析するには、先に与えられた理由のために複雑です。したがって、我々は、アプリケーションを支援するための関数のセットを定義します。これらの関数の関数プロトタイプは<netinetの/ in.h>ヘッダ内の全てです。"
    },
    {
      "indent": 0,
      "text": "6.3.1. inet6_option_space",
      "section_title": true,
      "ja": "6.3.1.  inet6_option_space"
    },
    {
      "indent": 7,
      "text": "int inet6_option_space(int nbytes);",
      "ja": "int型inet6_option_space（int型でnbytes）;"
    },
    {
      "indent": 3,
      "text": "This function returns the number of bytes required to hold an option when it is stored as ancillary data, including the cmsghdr structure at the beginning, and any padding at the end (to make its size a multiple of 8 bytes). The argument is the size of the structure defining the option, which must include any pad bytes at the beginning (the value y in the alignment term \"xn + y\"), the type byte, the length byte, and the option data.",
      "ja": "この機能は、それが最初にcmsghdr構造体、及び終了時に任意のパディング（サイズ8バイトの倍数にするため）を含む補助データとして記憶されているオプションを保持するために必要なバイト数を返します。引数は、初めに、任意のパッドバイト（アライメント用語「XN + Y」の値y）、型バイト、長さバイト、及びオプションデータを含める必要がありますオプションを定義する構造体のサイズです。"
    },
    {
      "indent": 3,
      "text": "(Note: If multiple options are stored in a single ancillary data object, which is the recommended technique, this function overestimates the amount of space required by the size of N-1 cmsghdr structures, where N is the number of options to be stored in the object. This is of little consequence, since it is assumed that most Hop-by-Hop option headers and Destination option headers carry only one option (p. 33 of [RFC-1883]).)",
      "ja": "（注：複数のオプションを推奨技術である単一の補助データオブジェクトに格納されている場合、この関数はNをに格納するオプションの数であるN-1のcmsghdr構造のサイズによって必要なスペースの量を過大評価オブジェクト。最もホップバイホップオプションヘッダと宛先オプションヘッダは、一つだけのオプション（[RFC-1883]のP 33）を搬送することを想定しているので、これは、ほとんど重要ではありません。）"
    },
    {
      "indent": 0,
      "text": "6.3.2. inet6_option_init",
      "section_title": true,
      "ja": "6.3.2.  inet6_option_init"
    },
    {
      "indent": 7,
      "text": "int inet6_option_init(void *bp, struct cmsghdr **cmsgp, int\ntype);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This function is called once per ancillary data object that will contain either Hop-by-Hop or Destination options. It returns 0 on success or -1 on an error.",
      "ja": "この機能は含まれています補助的なデータオブジェクトごとに一度と呼ばれているいずれかのホップバイホップもしくは宛先オプション。これは、エラーの場合は-1成功すると0を返します。"
    },
    {
      "indent": 3,
      "text": "bp is a pointer to previously allocated space that will contain the ancillary data object. It must be large enough to contain all the individual options to be added by later calls to inet6_option_append() and inet6_option_alloc().",
      "ja": "BPは補助的なデータオブジェクトが含まれています以前に割り当てられた領域へのポインタです。 （）とinet6_option_alloc（）をinet6_option_appendし、後で呼び出しによって追加されるすべての個々のオプションを含むのに十分な大きさでなければなりません。"
    },
    {
      "indent": 3,
      "text": "cmsgp is a pointer to a pointer to a cmsghdr structure. *cmsgp is initialized by this function to point to the cmsghdr structure constructed by this function in the buffer pointed to by bp.",
      "ja": "cmsgpはcmsghdr構造体へのポインタへのポインタです。 * cmsgpは、緩衝液中で、この機能によって構築cmsghdr構造体を指すように、この関数によって初期化され、BPによって指さ。"
    },
    {
      "indent": 3,
      "text": "type is either IPV6_HOPOPTS or IPV6_DSTOPTS. This type is stored in the cmsg_type member of the cmsghdr structure pointed to by *cmsgp.",
      "ja": "タイプはIPV6_HOPOPTSかIPV6_DSTOPTSのいずれかです。 cmsghdr構造体のcmsg_typeメンバに格納されているこのタイプは、* cmsgpによって指されます。"
    },
    {
      "indent": 0,
      "text": "6.3.3. inet6_option_append",
      "section_title": true,
      "ja": "6.3.3.  inet6_option_append"
    },
    {
      "indent": 7,
      "text": "int inet6_option_append(struct cmsghdr *cmsg, const uint8_t *typep,\n                        int multx, int plusy);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This function appends a Hop-by-Hop option or a Destination option into an ancillary data object that has been initialized by inet6_option_init(). This function returns 0 if it succeeds or -1 on an error.",
      "ja": "この関数は、inet6_option_init（）によって初期化された補助的なデータオブジェクトにホップバイホップオプションまたはデスティネーションオプションを追加します。それが成功した場合や、エラー時に-1この関数は0を返します。"
    },
    {
      "indent": 3,
      "text": "cmsg is a pointer to the cmsghdr structure that must have been initialized by inet6_option_init().",
      "ja": "CMSGはinet6_option_initによって初期化（）されている必要がありますcmsghdr構造体へのポインタです。"
    },
    {
      "indent": 3,
      "text": "typep is a pointer to the 8-bit option type. It is assumed that this field is immediately followed by the 8-bit option data length field, which is then followed immediately by the option data. The caller initializes these three fields (the type-length-value, or TLV) before calling this function.",
      "ja": "typepは、8ビットのオプションタイプへのポインタです。なお、このフィールドは直ちに、オプションデータが直ちに続く8ビットのオプションデータ長フィールド、続いているものとします。呼び出し側は、この関数を呼び出す前に、これらの三つのフィールド（タイプ - 長さ - 値、またはTLV）を初期化します。"
    },
    {
      "indent": 3,
      "text": "The option type must have a value from 2 to 255, inclusive. (0 and 1 are reserved for the Pad1 and PadN options, respectively.)",
      "ja": "オプションタイプは、包括的、2から255までの値を持つ必要があります。 （0と1は、それぞれ、パッド1およびパッドNオプションのために予約されています。）"
    },
    {
      "indent": 3,
      "text": "The option data length must have a value between 0 and 255, inclusive, and is the length of the option data that follows.",
      "ja": "オプションのデータ長は、0〜255の値を持つ包括的、かつ以下のオプションデータの長さである必要があります。"
    },
    {
      "indent": 3,
      "text": "multx is the value x in the alignment term \"xn + y\" described earlier. It must have a value of 1, 2, 4, or 8.",
      "ja": "multxは、前述の配向用語「XN + Y」の値xです。これは、1、2、4、または8の値を有していなければなりません。"
    },
    {
      "indent": 3,
      "text": "plusy is the value y in the alignment term \"xn + y\" described earlier. It must have a value between 0 and 7, inclusive.",
      "ja": "plusyは、前述の配向用語「XN + Y」の値yです。これは、0から7までの値を持つ必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.4. inet6_option_alloc",
      "section_title": true,
      "ja": "6.3.4.  inet6_option_alloc"
    },
    {
      "indent": 7,
      "text": "uint8_t *inet6_option_alloc(struct cmsghdr *cmsg, int datalen,\n                             int multx, int plusy);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This function appends a Hop-by-Hop option or a Destination option into an ancillary data object that has been initialized by inet6_option_init(). This function returns a pointer to the 8-bit option type field that starts the option on success, or NULL on an error.",
      "ja": "この関数は、inet6_option_init（）によって初期化された補助的なデータオブジェクトにホップバイホップオプションまたはデスティネーションオプションを追加します。この関数は、成功、エラー時にNULLのオプションを開始し、8ビットのオプションタイプフィールドへのポインタを返します。"
    },
    {
      "indent": 3,
      "text": "The difference between this function and inet6_option_append() is that the latter copies the contents of a previously built option into the ancillary data object while the current function returns a pointer to the space in the data object where the option's TLV must then be built by the caller.",
      "ja": "現在の機能は、オプションのTLVは、それまでに構築されなければならないデータ・オブジェクト内の空間へのポインタを返すときにこの機能とinet6_option_append（差）は、補助的なデータオブジェクトに後者をコピーすることを以前に構築されたオプションの内容であります呼び出し側。"
    },
    {
      "indent": 3,
      "text": "cmsg is a pointer to the cmsghdr structure that must have been initialized by inet6_option_init().",
      "ja": "CMSGはinet6_option_initによって初期化（）されている必要がありますcmsghdr構造体へのポインタです。"
    },
    {
      "indent": 3,
      "text": "datalen is the value of the option data length byte for this option. This value is required as an argument to allow the function to determine if padding must be appended at the end of the option. (The inet6_option_append() function does not need a data length argument since the option data length must already be stored by the caller.)",
      "ja": "datalenを、このオプションのオプションデータ長バイトの値です。この値は、パディングはオプションの最後に追加されなければならない場合、この関数が決定できるようにするの引数として必要とされます。 （オプションのデータ長がすでに呼び出し側によって保存されなければならないのでinet6_option_append（）関数は、データ長引数を必要としません。）"
    },
    {
      "indent": 3,
      "text": "multx is the value x in the alignment term \"xn + y\" described earlier. It must have a value of 1, 2, 4, or 8.",
      "ja": "multxは、前述の配向用語「XN + Y」の値xです。これは、1、2、4、または8の値を有していなければなりません。"
    },
    {
      "indent": 3,
      "text": "plusy is the value y in the alignment term \"xn + y\" described earlier. It must have a value between 0 and 7, inclusive.",
      "ja": "plusyは、前述の配向用語「XN + Y」の値yです。これは、0から7までの値を持つ必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.5. inet6_option_next",
      "section_title": true,
      "ja": "6.3.5.  inet6_option_next"
    },
    {
      "indent": 7,
      "text": "int inet6_option_next(const struct cmsghdr *cmsg, uint8_t\n**tptrp);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This function processes the next Hop-by-Hop option or Destination option in an ancillary data object. If another option remains to be processed, the return value of the function is 0 and *tptrp points to the 8-bit option type field (which is followed by the 8-bit option data length, followed by the option data). If no more options remain to be processed, the return value is -1 and *tptrp is NULL. If an error occurs, the return value is -1 and *tptrp is not NULL.",
      "ja": "この機能は、補助的なデータオブジェクト内の次のホップバイホップオプションまたはデスティネーションオプションを処理します。別のオプションが処理されないままである場合、関数の戻り値は0と*（オプションデータに続く8ビットのオプションデータ長が続く）8ビットのオプションタイプフィールドにtptrpポイント。これ以上のオプションが処理されずに残っていない場合、戻り値は-1で、* tptrpはNULLです。エラーが発生した場合、戻り値は-1で、* tptrpはNULLではありません。"
    },
    {
      "indent": 3,
      "text": "cmsg is a pointer to cmsghdr structure of which cmsg_level equals IPPROTO_IPV6 and cmsg_type equals either IPV6_HOPOPTS or IPV6_DSTOPTS.",
      "ja": "CMSGはcmsg_levelメンバはIPPROTO_IPV6に等しく、cmsg_typeがIPV6_HOPOPTS又はIPV6_DSTOPTSのいずれかに等しいの構造をのcmsghdrへのポインタです。"
    },
    {
      "indent": 3,
      "text": "tptrp is a pointer to a pointer to an 8-bit byte and *tptrp is used by the function to remember its place in the ancillary data object each time the function is called. The first time this function is called for a given ancillary data object, *tptrp must be set to NULL.",
      "ja": "tptrpは8ビットのバイトへのポインタへのポインタで、* tptrpは補助的なデータオブジェクトに関数が呼び出されるたびにその場所を覚えておく機能で使用されます。この関数は、与えられた補助的なデータオブジェクトに対して初めて呼び出されたときには、* tptrpはNULLに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each time this function returns success, *tptrp points to the 8-bit option type field for the next option to be processed.",
      "ja": "この関数が成功を返すたびに、*次のオプションの8ビットのオプションタイプフィールドにtptrpポイントが処理されます。"
    },
    {
      "indent": 0,
      "text": "6.3.6. inet6_option_find",
      "section_title": true,
      "ja": "6.3.6.  inet6_option_find"
    },
    {
      "indent": 7,
      "text": "int inet6_option_find(const struct cmsghdr *cmsg, uint8_t *tptrp,\n                      int type);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This function is similar to the previously described inet6_option_next() function, except this function lets the caller specify the option type to be searched for, instead of always returning the next option in the ancillary data object. cmsg is a pointer to cmsghdr structure of which cmsg_level equals IPPROTO_IPV6 and cmsg_type equals either IPV6_HOPOPTS or IPV6_DSTOPTS.",
      "ja": "この機能は、発信者がオプションタイプを検索するように指定でき除き、この関数は常に補助データオブジェクト内の次のオプションを返すのではなく、前述のinet6_option_next（）関数に似ています。 CMSGはcmsg_levelメンバはIPPROTO_IPV6に等しく、cmsg_typeがIPV6_HOPOPTS又はIPV6_DSTOPTSのいずれかに等しいの構造をのcmsghdrへのポインタです。"
    },
    {
      "indent": 3,
      "text": "tptrp is a pointer to a pointer to an 8-bit byte and *tptrp is used by the function to remember its place in the ancillary data object each time the function is called. The first time this function is called for a given ancillary data object, *tptrp must be set to NULL.",
      "ja": "tptrpは8ビットのバイトへのポインタへのポインタで、* tptrpは補助的なデータオブジェクトに関数が呼び出されるたびにその場所を覚えておく機能で使用されます。この関数は、与えられた補助的なデータオブジェクトに対して初めて呼び出されたときには、* tptrpはNULLに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "This function starts searching for an option of the specified type beginning after the value of *tptrp. If an option of the specified type is located, this function returns 0 and *tptrp points to the 8- bit option type field for the option of the specified type. If an option of the specified type is not located, the return value is -1 and *tptrp is NULL. If an error occurs, the return value is -1 and *tptrp is not NULL.",
      "ja": "この関数は、* tptrpの値より後に開始する指定されたタイプのオプションのために検索を開始します。指定されたタイプのオプションが配置されている場合、この関数は、指定されたタイプのオプションの8ビットのオプションタイプフィールドに0と* tptrpポイントを返します。指定されたタイプのオプションが配置されていない場合、戻り値は-1で、* tptrpはNULLです。エラーが発生した場合、戻り値は-1で、* tptrpはNULLではありません。"
    },
    {
      "indent": 0,
      "text": "6.3.7. Options Examples",
      "section_title": true,
      "ja": "6.3.7. オプションの例"
    },
    {
      "indent": 3,
      "text": "We now provide an example that builds two Hop-by-Hop options. First we define two options, called X and Y, taken from the example in Appendix A of [RFC-1883]. We assume that all options will have structure definitions similar to what is shown below.",
      "ja": "私たちは今、2ホップバイホップオプションを構築する例を提供します。まず、[RFC-1883]の付録Aの例から採取されたXとYと呼ばれる2つのオプションを定義します。我々は、すべてのオプションを示しているものと同様の構造の定義を持っていることを前提としています。"
    },
    {
      "indent": 0,
      "text": "        /* option X and option Y are defined in [RFC-1883], pp. 33-34 */\n#define IP6_X_OPT_TYPE       X   /* replace X with assigned value */\n#define IP6_X_OPT_LEN       12\n#define IP6_X_OPT_MULTX      8   /* 8n + 2 alignment */\n#define IP6_X_OPT_OFFSETY    2",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct ip6_X_opt {\n  uint8_t   ip6_X_opt_pad[IP6_X_OPT_OFFSETY];\n  uint8_t   ip6_X_opt_type;\n  uint8_t   ip6_X_opt_len;\n  uint32_t  ip6_X_opt_val1;\n  uint64_t  ip6_X_opt_val2;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#define IP6_Y_OPT_TYPE       Y   /* replace Y with assigned value */\n#define IP6_Y_OPT_LEN        7\n#define IP6_Y_OPT_MULTX      4   /* 4n + 3 alignment */\n#define IP6_Y_OPT_OFFSETY    3",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct ip6_Y_opt {\n  uint8_t   ip6_Y_opt_pad[IP6_Y_OPT_OFFSETY];\n  uint8_t   ip6_Y_opt_type;\n  uint8_t   ip6_Y_opt_len;\n  uint8_t   ip6_Y_opt_val1;\n  uint16_t  ip6_Y_opt_val2;\n  uint32_t  ip6_Y_opt_val3;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "We now show the code fragment to build one ancillary data object containing both options.",
      "ja": "私たちは今、両方のオプションを含む1つの補助的なデータオブジェクトを構築するために、コードのフラグメントを示しました。"
    },
    {
      "indent": 0,
      "text": "struct msghdr  msg;\nstruct cmsghdr  *cmsgptr;\nstruct ip6_X_opt  optX;\nstruct ip6_Y_opt  optY;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "msg.msg_control = malloc(inet6_option_space(sizeof(optX) + sizeof(optY)));",
      "ja": "msg.msg_control = malloc関数（inet6_option_space（のsizeof（OPTX）+はsizeof（optY）））。"
    },
    {
      "indent": 0,
      "text": "inet6_option_init(msg.msg_control, &cmsgptr, IPV6_HOPOPTS);",
      "ja": "inet6_option_init（msg.msg_control、＆cmsgptr、IPV6_HOPOPTS）。"
    },
    {
      "indent": 0,
      "text": "optX.ip6_X_opt_type = IP6_X_OPT_TYPE;\noptX.ip6_X_opt_len  = IP6_X_OPT_LEN;\noptX.ip6_X_opt_val1 = <32-bit value>;\noptX.ip6_X_opt_val2 = <64-bit value>;\ninet6_option_append(cmsgptr, &optX.ip6_X_opt_type,\n                    IP6_X_OPT_MULTX, IP6_X_OPT_OFFSETY);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "optY.ip6_Y_opt_type = IP6_Y_OPT_TYPE;\noptY.ip6_Y_opt_len  = IP6_Y_OPT_LEN;\noptY.ip6_Y_opt_val1 = <8-bit value>;\noptY.ip6_Y_opt_val2 = <16-bit value>;\noptY.ip6_Y_opt_val3 = <32-bit value>;\ninet6_option_append(cmsgptr, &optY.ip6_Y_opt_type,\n                    IP6_Y_OPT_MULTX, IP6_Y_OPT_OFFSETY);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "msg.msg_controllen = cmsgptr->cmsg_len;",
      "ja": "msg.msg_controllen = cmsgptr-> CMSG_LEN。"
    },
    {
      "indent": 3,
      "text": "The call to inet6_option_init() builds the cmsghdr structure in the control buffer.",
      "ja": "inet6_option_init（）の呼び出しは、制御バッファにおけるcmsghdr構造体を構築します。"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = CMSG_LEN(0) = 12                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_HOPOPTS                                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here we assume a 32-bit architecture where sizeof(struct cmsghdr) equals 12, with a desired alignment of 4-byte boundaries (that is, the ALIGN() macro shown in the sample implementations of the CMSG_xxx() macros rounds up to a multiple of 4).",
      "ja": "ここでは、4バイト境界の所望の配向（すなわち、（CMSG_xxxの実装例に示すALIGN（）マクロで）マクロは、最大ラウンドではsizeof（構造体のcmsghdr）が12に等しい32ビットのアーキテクチャを想定し4の倍数）。"
    },
    {
      "indent": 3,
      "text": "The first call to inet6_option_append() appends the X option. Since this is the first option in the ancillary data object, 2 bytes are allocated for the Next Header byte and for the Hdr Ext Len byte. The former will be set by the kernel, depending on the type of header that follows this header, and the latter byte is set to 1. These 2 bytes form the 2 bytes of padding (IP6_X_OPT_OFFSETY) required at the beginning of this option.",
      "ja": "inet6_option_appendする最初の呼び出しは（）Xオプションを追加します。これは補助データオブジェクトの最初のオプションであるため、2つのバイトは次ヘッダーバイトおよびHDR拡張レンバイトに割り当てられます。前者は、このヘッダに続くヘッダのタイプに応じて、カーネルによって設定され、後者のバイトは、これらの2つのバイトは、このオプションの先頭に必要なパディング（IP6_X_OPT_OFFSETY）の2つのバイトを形成する1に設定されています。"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 28                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_HOPOPTS                                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         4-octet field                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                         8-octet field                         +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The cmsg_len member of the cmsghdr structure is incremented by 16, the size of the option.",
      "ja": "cmsghdr構造体のCMSG_LEN部材​​16、オプションのサイズだけインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "The next call to inet6_option_append() appends the Y option to the ancillary data object.",
      "ja": "inet6_option_appendする次の呼び出しは（）補助的なデータオブジェクトにYオプションを付加します。"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 44                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_HOPOPTS                                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=3 | Option Type=X |Opt Data Len=12|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         4-octet field                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                         8-octet field                         +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| PadN Option=1 |Opt Data Len=1 |       0       | Option Type=Y |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Opt Data Len=7 | 1-octet field |         2-octet field         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         4-octet field                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| PadN Option=1 |Opt Data Len=2 |       0       |       0       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "16 bytes are appended by this function, so cmsg_len becomes 44. The inet6_option_append() function notices that the appended data requires 4 bytes of padding at the end, to make the size of the ancillary data object a multiple of 8, and appends the PadN option before returning. The Hdr Ext Len byte is incremented by 2 to become 3.",
      "ja": "CMSG_LENは添付データが補助データのサイズが8の倍数オブジェクト作るために、最後のパディングの4つのバイトを必要とする44 inet6_option_append（）関数の通知となるように16のバイトは、この機能が付加されており、パッドNが追加します戻る前に、オプションを選択します。 HDRのExtレンバイトが3になるために2ずつ増加します。"
    },
    {
      "indent": 3,
      "text": "Alternately, the application could build two ancillary data objects, one per option, although this will probably be less efficient than combining the two options into a single ancillary data object (as just shown). The kernel must combine these into a single Hop-by-Hop extension header in the final IPv6 packet.",
      "ja": "（ちょうど示されるように）、これはおそらく単一の補助データオブジェクトに二つのオプションを組み合わせるよりも効率であろうが、交互に、アプリケーションは二つの補助的なデータオブジェクト、オプション1つずつ構築できます。カーネルは、最終的なIPv6パケット内の単一のホップバイホップ拡張ヘッダにこれらを結合しなければなりません。"
    },
    {
      "indent": 7,
      "text": "struct msghdr  msg;\nstruct cmsghdr  *cmsgptr;\nstruct ip6_X_opt  optX;\nstruct ip6_Y_opt  optY;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "msg.msg_control = malloc(inet6_option_space(sizeof(optX)) + inet6_option_space(sizeof(optY)));",
      "ja": "msg.msg_control = malloc関数（inet6_option_space（のsizeof（OPTX））+ inet6_option_space（のsizeof（optY）））。"
    },
    {
      "indent": 7,
      "text": "inet6_option_init(msg.msg_control, &cmsgptr, IPPROTO_HOPOPTS);",
      "ja": "inet6_option_init（msg.msg_control、＆cmsgptr、IPPROTO_HOPOPTS）"
    },
    {
      "indent": 7,
      "text": "optX.ip6_X_opt_type = IP6_X_OPT_TYPE;",
      "ja": "optX.ip6_X_opt_type = IP6_X_OPT_TYPE。"
    },
    {
      "indent": 7,
      "text": "optX.ip6_X_opt_len  = IP6_X_OPT_LEN;\noptX.ip6_X_opt_val1 = <32-bit value>;\noptX.ip6_X_opt_val2 = <64-bit value>;\ninet6_option_append(cmsgptr, &optX.ip6_X_opt_type,\n                    IP6_X_OPT_MULTX, IP6_X_OPT_OFFSETY);\nmsg.msg_controllen = CMSG_SPACE(sizeof(optX));",
      "raw": true
    },
    {
      "indent": 7,
      "text": "inet6_option_init((u_char *)msg.msg_control + msg.msg_controllen, &cmsgptr, IPPROTO_HOPOPTS);",
      "ja": "inet6_option_init（（u_char型*）+ msg.msg_control msg.msg_controllen、＆cmsgptr、IPPROTO_HOPOPTS）"
    },
    {
      "indent": 7,
      "text": "optY.ip6_Y_opt_type = IP6_Y_OPT_TYPE;\noptY.ip6_Y_opt_len  = IP6_Y_OPT_LEN;\noptY.ip6_Y_opt_val1 = <8-bit value>;\noptY.ip6_Y_opt_val2 = <16-bit value>;\noptY.ip6_Y_opt_val3 = <32-bit value>;\ninet6_option_append(cmsgptr, &optY.ip6_Y_opt_type,\n                    IP6_Y_OPT_MULTX, IP6_Y_OPT_OFFSETY);\nmsg.msg_controllen += cmsgptr->cmsg_len;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each call to inet6_option_init() builds a new cmsghdr structure, and the final result looks like the following:",
      "ja": "inet6_option_init（）を呼び出すたびに、新しいcmsghdr構造体を構築し、最終的な結果は次のようになります。"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 28                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_HOPOPTS                                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=1 | Option Type=X |Opt Data Len=12|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         4-octet field                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                         8-octet field                         +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 28                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_HOPOPTS                                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=1 | Pad1 Option=0 | Option Type=Y |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Opt Data Len=7 | 1-octet field |         2-octet field         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         4-octet field                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| PadN Option=1 |Opt Data Len=2 |       0       |       0       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When the kernel combines these two options into a single Hop-by-Hop extension header, the first 3 bytes of the second ancillary data object (the Next Header byte, the Hdr Ext Len byte, and the Pad1 option) will be combined into a PadN option occupying 3 bytes.",
      "ja": "カーネルは単一ホップバイホップ拡張ヘッダ中にこれら二つのオプションを組み合わせたときに、第二補助データオブジェクト（ネクストヘッダバイト、HDR拡張レンバイト、及びパッド1オプション）の最初の3バイトに結合され3つのバイトを占有パッドNオプション。"
    },
    {
      "indent": 3,
      "text": "The following code fragment is a redo of the first example shown (building two options in a single ancillary data object) but this time we use inet6_option_alloc().",
      "ja": "次のコードは、（単一の補助データオブジェクト内の2つのオプションがビルド）に示す第1例のやり直しが、我々は（inet6_option_alloc使用この時間）です。"
    },
    {
      "indent": 0,
      "text": "uint8_t  *typep;\nstruct msghdr  msg;\nstruct cmsghdr  *cmsgptr;\nstruct ip6_X_opt  *optXp;  /* now a pointer, not a struct */\nstruct ip6_Y_opt  *optYp;  /* now a pointer, not a struct */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "msg.msg_control = malloc(inet6_option_space(sizeof(*optXp) + sizeof(*optYp)));",
      "ja": "msg.msg_control = malloc関数（inet6_option_space（はsizeof（* optXp）+はsizeof（* optYp）））。"
    },
    {
      "indent": 0,
      "text": "inet6_option_init(msg.msg_control, &cmsgptr, IPV6_HOPOPTS);",
      "ja": "inet6_option_init（msg.msg_control、＆cmsgptr、IPV6_HOPOPTS）。"
    },
    {
      "indent": 0,
      "text": "typep = inet6_option_alloc(cmsgptr, IP6_X_OPT_LEN,\n                           IP6_X_OPT_MULTX, IP6_X_OPT_OFFSETY);\noptXp = (struct ip6_X_opt *) (typep - IP6_X_OPT_OFFSETY);\noptXp->ip6_X_opt_type = IP6_X_OPT_TYPE;\noptXp->ip6_X_opt_len  = IP6_X_OPT_LEN;\noptXp->ip6_X_opt_val1 = <32-bit value>;\noptXp->ip6_X_opt_val2 = <64-bit value>;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "typep = inet6_option_alloc(cmsgptr, IP6_Y_OPT_LEN,\n                           IP6_Y_OPT_MULTX, IP6_Y_OPT_OFFSETY);\noptYp = (struct ip6_Y_opt *) (typep - IP6_Y_OPT_OFFSETY);\noptYp->ip6_Y_opt_type = IP6_Y_OPT_TYPE;\noptYp->ip6_Y_opt_len  = IP6_Y_OPT_LEN;\noptYp->ip6_Y_opt_val1 = <8-bit value>;\noptYp->ip6_Y_opt_val2 = <16-bit value>;\noptYp->ip6_Y_opt_val3 = <32-bit value>;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "msg.msg_controllen = cmsgptr->cmsg_len;",
      "ja": "msg.msg_controllen = cmsgptr-> CMSG_LEN。"
    },
    {
      "indent": 3,
      "text": "Notice that inet6_option_alloc() returns a pointer to the 8-bit option type field. If the program wants a pointer to an option structure that includes the padding at the front (as shown in our definitions of the ip6_X_opt and ip6_Y_opt structures), the y-offset at the beginning of the structure must be subtracted from the returned pointer.",
      "ja": "8ビットのオプションタイプフィールドへのポインタを返す（）はinet6_option_allocに注意してください。プログラムは、（ip6_X_optとip6_Y_opt構造の我々の定義に示すように）前面にパディングを含んオプション構造体へのポインタを望んでいる場合は、Y-オフセット構造の初めには、返されたポインタから減算する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following code fragment shows the processing of Hop-by-Hop options using the inet6_option_next() function.",
      "ja": "次のコード断片はinet6_option_next（）関数を使用してホップバイホップオプションの処理を示しています。"
    },
    {
      "indent": 4,
      "text": "struct msghdr   msg;\nstruct cmsghdr  *cmsgptr;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* fill in msg */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* call recvmsg() */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL; cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) { if (cmsgptr->cmsg_level == IPPROTO_IPV6 && cmsgptr->cmsg_type == IPV6_HOPOPTS) {",
      "ja": "用（cmsgptr = CMSG_FIRSTHDR（＆MSG）;！cmsgptr = NULL; cmsgptr = CMSG_NXTHDR（＆MSG、cmsgptr））{IF（cmsgptr-> cmsg_levelメンバ== IPPROTO_IPV6 && cmsgptr-> cmsg_type == IPV6_HOPOPTS）{"
    },
    {
      "indent": 12,
      "text": "uint8_t *tptr = NULL;",
      "ja": "uint8_t * TPTR = NULL;"
    },
    {
      "indent": 12,
      "text": "while (inet6_option_next(cmsgptr, &tptr) == 0) { if (*tptr == IP6_X_OPT_TYPE) { struct ip6_X_opt *optXp;",
      "ja": "一方、（inet6_option_next（cmsgptr、＆TPTR）== 0）{IF（* TPTR == IP6_X_OPT_TYPE）{構造体ip6_X_opt * optXp。"
    },
    {
      "indent": 20,
      "text": "optXp = (struct ip6_X_opt *) (tptr - IP6_X_OPT_OFFSETY);\n<do whatever with> optXp->ip6_X_opt_val1;\n<do whatever with> optXp->ip6_X_opt_val2;",
      "raw": true
    },
    {
      "indent": 16,
      "text": "} else if (*tptr == IP6_Y_OPT_TYPE) { struct ip6_Y_opt *optYp;",
      "ja": "}もしそうでなければ（* TPTR == IP6_Y_OPT_TYPE）{構造体ip6_Y_opt * optYp。"
    },
    {
      "indent": 4,
      "text": "                optYp = (struct ip6_Y_opt *) (tptr - IP6_Y_OPT_OFFSETY);\n                <do whatever with> optYp->ip6_Y_opt_val1;\n                <do whatever with> optYp->ip6_Y_opt_val2;\n                <do whatever with> optYp->ip6_Y_opt_val3;\n            }\n        }\n        if (tptr != NULL)\n            <error encountered by inet6_option_next()>;\n    }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7. Destination Options",
      "section_title": true,
      "ja": "7.宛先オプション"
    },
    {
      "indent": 3,
      "text": "A variable number of Destination options can appear in one or more Destination option headers. As defined in [RFC-1883], a Destination options header appearing before a Routing header is processed by the first destination plus any subsequent destinations specified in the Routing header, while a Destination options header appearing after a Routing header is processed only by the final destination. As with the Hop-by-Hop options, each option in a Destination options header is TLV-encoded with a type, length, and value.",
      "ja": "宛先オプションの可変数は、1つ以上の宛先オプションヘッダーに表示されます。 [RFC-1883]で定義されるようにルーティングヘッダが最初の目的地プラスルーティングヘッダで指定された任意の後続の宛先によって処理される前に、宛先オプションは、最終によってのみ処理され、ルーティングヘッダの後に現れるヘッダながら、宛先オプションは、出現ヘッダ先。ホップバイホップオプションと同様に、宛先オプションヘッダの各オプションは、タイプ、長さ、および値でTLVエンコードされています。"
    },
    {
      "indent": 3,
      "text": "Today no Destination options are defined for IPv6 [RFC-1883], although proposals exist to use Destination options with mobility and anycasting.",
      "ja": "提案は、モビリティとエニーキャストと宛先オプションを使用するために存在するが、今日は何の宛先オプションは、IPv6の[RFC-1883]のために定義されていません。"
    },
    {
      "indent": 0,
      "text": "7.1. Receiving Destination Options",
      "section_title": true,
      "ja": "7.1. 宛先オプションを受け取ります"
    },
    {
      "indent": 3,
      "text": "To receive Destination options the application must enable the IPV6_DSTOPTS socket option:",
      "ja": "宛先オプションを受信するにはアプリケーションがIPV6_DSTOPTSソケットオプションを有効にする必要があります。"
    },
    {
      "indent": 7,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_DSTOPTS, &on, sizeof(on));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All the Destination options appearing before a Routing header are returned as one ancillary data object described by a cmsghdr structure and all the Destination options appearing after a Routing header are returned as another ancillary data object described by a cmsghdr structure. For these ancillary data objects, the cmsg_level member will be IPPROTO_IPV6 and the cmsg_type member will be IPV6_HOPOPTS. These options are then processed by calling the inet6_option_next() and inet6_option_find() functions.",
      "ja": "ルーティングヘッダの前に現れるすべての宛先オプションはcmsghdr構造体とルーティングヘッダはcmsghdr構造体によって記述される他の補助的なデータオブジェクトとして返された後に現れるすべての宛先オプションで説明したもの補助データオブジェクトとして返されます。これらの補助的なデータオブジェクトの場合は、cmsg_levelメンバメンバーはIPPROTO_IPV6になり、cmsg_typeメンバーはIPV6_HOPOPTSになります。これらのオプションは、その後inet6_option_next（）とinet6_option_find（）関数を呼び出すことによって処理されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Sending Destination Options",
      "section_title": true,
      "ja": "7.2. 宛先オプションを送信"
    },
    {
      "indent": 3,
      "text": "To send one or more Destination options, the application just specifies them as ancillary data in a call to sendmsg(). No socket option need be set.",
      "ja": "一つ以上の宛先オプションを送信するには、アプリケーションは、ちょうど）（コールで補助データがSENDMSGするようにそれらを指定します。いいえソケットオプションを設定する必要はありません。"
    },
    {
      "indent": 3,
      "text": "As described earlier, one set of Destination options can appear before a Routing header, and one set can appear after a Routing header. Each set can consist of one or more options.",
      "ja": "前述したように、宛先オプションの一組は、ルーティングヘッダの前に表示することができ、そして一組は、ルーティングヘッダの後に現れることができます。各セットは、1つまたは複数のオプションで構成されます。"
    },
    {
      "indent": 3,
      "text": "Normally all the Destination options in a set are specified by a single ancillary data object, since each option is itself TLV-encoded. Multiple ancillary data objects, each containing one or more Destination options, can also be specified, in which case the kernel will combine all the Destination options in the set into a single Destination extension header. But it should be more efficient to use a single ancillary data object to describe all the Destination options in a set. The cmsg_level member is set to IPPROTO_IPV6 and the cmsg_type member is set to IPV6_DSTOPTS. The option is normally constructed using the inet6_option_init(), inet6_option_append(), and inet6_option_alloc() functions.",
      "ja": "各オプションは、それ自体がTLVエンコードであるため、通常はセット内のすべての宛先オプションは、単一の補助データオブジェクトで指定されています。複数の補助データオブジェクトをそれぞれ含む1つ以上の宛先オプション、また、カーネルは、単一の宛先拡張ヘッダにセット内のすべての宛先オプションを組み合わせてなる場合には、指定することができます。しかし、セット内のすべての宛先オプションを記述するために、単一の補助的なデータオブジェクトを使用する方が効率的でなければなりません。 cmsg_levelメンバメンバーはIPPROTO_IPV6に設定され、cmsg_typeメンバーはIPV6_DSTOPTSに設定されています。オプションは、通常inet6_option_init（）、inet6_option_append（）、及びinet6_option_alloc（）関数を使用して構築されます。"
    },
    {
      "indent": 3,
      "text": "Additional errors may be possible from sendmsg() if the specified option is in error.",
      "ja": "指定されたオプションにエラーがある場合は、追加のエラーは）（にsendmsgから可能かもしれません。"
    },
    {
      "indent": 0,
      "text": "8. Routing Header Option",
      "section_title": true,
      "ja": "8.ルーティングヘッダオプション"
    },
    {
      "indent": 3,
      "text": "Source routing in IPv6 is accomplished by specifying a Routing header as an extension header. There can be different types of Routing headers, but IPv6 currently defines only the Type 0 Routing header [RFC-1883]. This type supports up to 23 intermediate nodes. With this maximum number of intermediate nodes, a source, and a destination, there are 24 hops, each of which is defined as a strict or loose hop.",
      "ja": "IPv6におけるソースルーティングは、拡張ヘッダなどのルーティングヘッダを指定することによって達成されます。そこにルーティングヘッダの異なるタイプであるが、IPv6は現在、タイプ0ルーティングヘッダ[RFC-1883]を定義することができます。このタイプは、23の中間ノードをサポートします。中間ノードのこの最大数、送信元、宛先と、厳密または緩いホップとして定義され、それぞれが24回のホップがあります。"
    },
    {
      "indent": 3,
      "text": "Source routing with IPv4 sockets API (the IP_OPTIONS socket option) requires the application to build the source route in the format that appears as the IPv4 header option, requiring intimate knowledge of the IPv4 options format. This IPv6 API, however, defines eight functions that the application calls to build and examine a Routing header. Four functions build a Routing header:",
      "ja": "IPv4では、ソースルーティングは、API（IP_OPTIONSソケットオプション）はIPv4オプションフォーマットの詳細な知識を必要とし、IPv4ヘッダーオプションとして表示される形式でソースルートを構築するためのアプリケーションを必要とするソケット。このIPv6のAPIは、しかし、アプリケーションが構築し、ルーティングヘッダを調べるために呼び出す8つの関数を定義しています。 4つの機能は、ルーティングヘッダを構築します："
    },
    {
      "indent": 3,
      "text": "inet6_rthdr_space() - return #bytes required for ancillary data inet6_rthdr_init() - initialize ancillary data for Routing header inet6_rthdr_add() - add IPv6 address & flags to Routing header inet6_rthdr_lasthop() - specify the flags for the final hop",
      "ja": "inet6_rthdr_space（） - 補助データinet6_rthdr_initために必要な戻り#bytes（） - ）（ヘッダinet6_rthdr_addをルーティングするための補助データを初期化 - （ヘッダinet6_rthdr_lasthopルーティングにIPv6アドレスとフラグを追加） - 最終ホップのためにフラグを指定"
    },
    {
      "indent": 3,
      "text": "Four functions deal with a returned Routing header:",
      "ja": "4つの関数は、返されたルーティングヘッダを扱います。"
    },
    {
      "indent": 4,
      "text": "inet6_rthdr_reverse() - reverse a Routing header inet6_rthdr_segments() - return #segments in a Routing header inet6_rthdr_getaddr() - fetch one address from a Routing header inet6_rthdr_getflags() - fetch one flag from a Routing header",
      "ja": "inet6_rthdr_reverse（） - ルーティングヘッダinet6_rthdr_segments（）逆 - ルーティングヘッダinet6_rthdr_getaddrに戻り#segmentsを（） - ルーティングヘッダinet6_rthdr_getflags（）から一つのアドレスをフェッチ - ルーティングヘッダから1つのフラグをフェッチ"
    },
    {
      "indent": 3,
      "text": "The function prototypes for these functions are all in the <netinet/in.h> header.",
      "ja": "これらの関数の関数プロトタイプは<netinetの/ in.h>ヘッダ内の全てです。"
    },
    {
      "indent": 3,
      "text": "To receive a Routing header the application must enable the IPV6_RTHDR socket option:",
      "ja": "ルーティングヘッダを受信するにはアプリケーションがIPV6_RTHDRソケットオプションを有効にする必要があります。"
    },
    {
      "indent": 7,
      "text": "int  on = 1;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RTHDR, &on, sizeof(on));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To send a Routing header the application just specifies it as ancillary data in a call to sendmsg().",
      "ja": "ルーティングヘッダを送信するために、アプリケーションは、単に（SENDMSGの呼び出しで補助データとして指定します）。"
    },
    {
      "indent": 3,
      "text": "A Routing header is passed between the application and the kernel as an ancillary data object. The cmsg_level member has a value of IPPROTO_IPV6 and the cmsg_type member has a value of IPV6_RTHDR. The contents of the cmsg_data[] member is implementation dependent and should not be accessed directly by the application, but should be accessed using the eight functions that we are about to describe.",
      "ja": "ルーティングヘッダは、アプリケーションと補助データオブジェクトとカーネルとの間に通されます。 cmsg_levelメンバ部材はIPPROTO_IPV6の値を有し、cmsg_type部材がIPV6_RTHDRの値を有します。 CMSG_DATA []メンバーの内容は実装依存であり、アプリケーションによって直接アクセスされるべきではなく、我々が説明しようとしている8つの関数を使用してアクセスされなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following constants are defined in the <netinet/in.h> header:",
      "ja": "以下の定数は、<netinetの/ in.h>ヘッダに定義されています。"
    },
    {
      "indent": 4,
      "text": "#define IPV6_RTHDR_LOOSE     0 /* this hop need not be a neighbor */\n#define IPV6_RTHDR_STRICT    1 /* this hop must be a neighbor */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "#define IPV6_RTHDR_TYPE_0    0 /* IPv6 Routing header type 0 */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When a Routing header is specified, the destination address specified for connect(), sendto(), or sendmsg() is the final destination address of the datagram. The Routing header then contains the addresses of all the intermediate nodes.",
      "ja": "ルーティングヘッダが指定されている場合、送信先の接続のための指定されたアドレス（）のsendto（）、またはsendmsgの（）は、データグラムの最終的な宛先アドレスです。ルーティングヘッダは、すべての中間ノードのアドレスを含みます。"
    },
    {
      "indent": 0,
      "text": "8.1. inet6_rthdr_space",
      "section_title": true,
      "ja": "8.1.  inet6_rthdr_space"
    },
    {
      "indent": 7,
      "text": "size_t inet6_rthdr_space(int type, int segments);",
      "ja": "size_tのinet6_rthdr_space（int型、INTセグメント）。"
    },
    {
      "indent": 3,
      "text": "This function returns the number of bytes required to hold a Routing header of the specified type containing the specified number of segments (addresses). For an IPv6 Type 0 Routing header, the number of segments must be between 1 and 23, inclusive. The return value includes the size of the cmsghdr structure that precedes the Routing header, and any required padding.",
      "ja": "この関数は、セグメント（アドレス）の指定された数を含む指定されたタイプのルーティングヘッダを保持するために必要なバイト数を返します。 IPv6のタイプ0ルーティングヘッダは、セグメントの数は、1〜23、包括的でなければなりません。戻り値は、ルーティングヘッダに先行cmsghdr構造体の大きさ、および任意の必要なパディングを含みます。"
    },
    {
      "indent": 3,
      "text": "If the return value is 0, then either the type of the Routing header is not supported by this implementation or the number of segments is invalid for this type of Routing header.",
      "ja": "戻り値が0である場合には、ルーティングヘッダのタイプは、この実装でサポートされていないか、またはセグメントの数は、ヘッダルーティングこのタイプの無効のいずれか。"
    },
    {
      "indent": 3,
      "text": "(Note: This function returns the size but does not allocate the space required for the ancillary data. This allows an application to allocate a larger buffer, if other ancillary data objects are desired, since all the ancillary data objects must be specified to sendmsg() as a single msg_control buffer.)",
      "ja": "（注：この関数はサイズを返すが、補助データに必要なスペースを割り当てない他の補助的なデータオブジェクトが所望される場合、すべての補助データオブジェクトがSENDMSGするために指定されなければならないので、これは、アプリケーションが大きなバッファを割り当てることができます（。 ）単一msg_controlバッファとして）。"
    },
    {
      "indent": 0,
      "text": "8.2. inet6_rthdr_init",
      "section_title": true,
      "ja": "8.2.  inet6_rthdr_init"
    },
    {
      "indent": 7,
      "text": "struct cmsghdr *inet6_rthdr_init(void *bp, int type);",
      "ja": "構造体のcmsghdr * inet6_rthdr_init（ボイド* bpの、int型）;"
    },
    {
      "indent": 3,
      "text": "This function initializes the buffer pointed to by bp to contain a cmsghdr structure followed by a Routing header of the specified type. The cmsg_len member of the cmsghdr structure is initialized to the size of the structure plus the amount of space required by the Routing header. The cmsg_level and cmsg_type members are also initialized as required.",
      "ja": "この関数は、バッファが指定されたタイプのルーティングヘッダに続くcmsghdr構造体を含むようにBPによって指さ初期化します。 cmsghdr構造体のCMSG_LEN部材​​は、構造のサイズとルーティングヘッダに必要なスペースの量に初期化されます。必要に応じて、cmsg_levelメンバとcmsg_typeメンバーも初期化されています。"
    },
    {
      "indent": 3,
      "text": "The caller must allocate the buffer and its size can be determined by calling inet6_rthdr_space().",
      "ja": "呼び出し側は、バッファを割り当てる必要があり、そのサイズはinet6_rthdr_space（）を呼び出すことによって決定することができます。"
    },
    {
      "indent": 3,
      "text": "Upon success the return value is the pointer to the cmsghdr structure, and this is then used as the first argument to the next two functions. Upon an error the return value is NULL.",
      "ja": "成功した場合、戻り値はcmsghdr構造体へのポインタであり、これは、次いで、次の二つの関数の最初の引数として使用されます。エラー時には、戻り値はNULLです。"
    },
    {
      "indent": 0,
      "text": "8.3. inet6_rthdr_add",
      "section_title": true,
      "ja": "8.3.  inet6_rthdr_add"
    },
    {
      "indent": 4,
      "text": "int inet6_rthdr_add(struct cmsghdr *cmsg,\n                    const struct in6_addr *addr, unsigned int flags);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This function adds the address pointed to by addr to the end of the Routing header being constructed and sets the type of this hop to the value of flags. For an IPv6 Type 0 Routing header, flags must be either IPV6_RTHDR_LOOSE or IPV6_RTHDR_STRICT.",
      "ja": "この関数は、アドレスが構成されているルーティングヘッダの終わりにADDRによって指さ加算し、フラグの値にこのホップのタイプを設定します。 IPv6のタイプ0ルーティングヘッダは、フラグはIPV6_RTHDR_LOOSE又はIPV6_RTHDR_STRICTのいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "If successful, the cmsg_len member of the cmsghdr structure is updated to account for the new address in the Routing header and the return value of the function is 0. Upon an error the return value of the function is -1.",
      "ja": "成功した場合、cmsghdr構造体のCMSG_LEN部材​​がルーティングヘッダに新しいアドレスを考慮するために更新され、関数の戻り値はエラー時に0である関数の戻り値は-1。"
    },
    {
      "indent": 0,
      "text": "8.4. inet6_rthdr_lasthop",
      "section_title": true,
      "ja": "8.4.  inet6_rthdr_lasthop"
    },
    {
      "indent": 7,
      "text": "int inet6_rthdr_lasthop(struct cmsghdr *cmsg,\n                        unsigned int flags);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This function specifies the Strict/Loose flag for the final hop of a Routing header. For an IPv6 Type 0 Routing header, flags must be either IPV6_RTHDR_LOOSE or IPV6_RTHDR_STRICT.",
      "ja": "この関数は、ルーティングヘッダの最終ホップのために厳密/ルースフラグを指定します。 IPv6のタイプ0ルーティングヘッダは、フラグはIPV6_RTHDR_LOOSE又はIPV6_RTHDR_STRICTのいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The return value of the function is 0 upon success, or -1 upon an error.",
      "ja": "関数の戻り値は成功時に0、あるいはエラー時に-1です。"
    },
    {
      "indent": 3,
      "text": "Notice that a Routing header specifying N intermediate nodes requires N+1 Strict/Loose flags. This requires N calls to inet6_rthdr_add() followed by one call to inet6_rthdr_lasthop().",
      "ja": "N中間ノードを指定するルーティングヘッダは、N + 1厳密/ルースフラグを必要とすることに注意してください。これは、）Nは（inet6_rthdr_addの呼び出しが必要です）（inet6_rthdr_lasthop 1つの呼び出しが続きます。"
    },
    {
      "indent": 0,
      "text": "8.5. inet6_rthdr_reverse",
      "section_title": true,
      "ja": "8.5.  inet6_rthdr_reverse"
    },
    {
      "indent": 4,
      "text": "int inet6_rthdr_reverse(const struct cmsghdr *in, struct cmsghdr *out);",
      "ja": "int型inet6_rthdr_reverse（constの構造体のcmsghdr *で、構造体のcmsghdr *アウト）。"
    },
    {
      "indent": 3,
      "text": "This function takes a Routing header that was received as ancillary data (pointed to by the first argument) and writes a new Routing header that sends datagrams along the reverse of that route. Both arguments are allowed to point to the same buffer (that is, the reversal can occur in place).",
      "ja": "この関数は、（最初​​の引数によって指される）補助データとして受信されたルーティングヘッダを取得し、そのルートの逆に沿ってデータグラムを送信する新しいルーティングヘッダを書き込みます。両方の引数は、同じ緩衝液（すなわち、反転が場所で起こり得る）を指すように許可されています。"
    },
    {
      "indent": 3,
      "text": "The return value of the function is 0 on success, or -1 upon an error.",
      "ja": "関数の戻り値は成功時に0、あるいはエラー時に-1です。"
    },
    {
      "indent": 0,
      "text": "8.6. inet6_rthdr_segments",
      "section_title": true,
      "ja": "8.6.  inet6_rthdr_segments"
    },
    {
      "indent": 7,
      "text": "int inet6_rthdr_segments(const struct cmsghdr *cmsg);",
      "ja": "inet6_rthdr_segments（constの構造体のcmsghdr *のCMSG）をint型。"
    },
    {
      "indent": 3,
      "text": "This function returns the number of segments (addresses) contained in the Routing header described by cmsg. On success the return value is between 1 and 23, inclusive. The return value of the function is -1 upon an error.",
      "ja": "この関数は、CMSGによって記述ルーティングヘッダに含まれるセグメント（アドレス）の数を返します。成功した場合、戻り値は1と23の間で、包括的です。関数の戻り値は、エラー時に-1です。"
    },
    {
      "indent": 0,
      "text": "8.7. inet6_rthdr_getaddr",
      "section_title": true,
      "ja": "8.7.  inet6_rthdr_getaddr"
    },
    {
      "indent": 4,
      "text": "struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *cmsg, int\nindex);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This function returns a pointer to the IPv6 address specified by index (which must have a value between 1 and the value returned by inet6_rthdr_segments()) in the Routing header described by cmsg. An application should first call inet6_rthdr_segments() to obtain the number of segments in the Routing header.",
      "ja": "この関数は、CMSGによって記述ルーティングヘッダ（1間の値とinet6_rthdr_segments（）によって返される値を有していなければならない）インデックスで指定されたIPv6アドレスへのポインタを返します。アプリケーションは、最初のルーティングヘッダ内のセグメントの数を得るために）（inet6_rthdr_segmentsを呼び出す必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon an error the return value of the function is NULL.",
      "ja": "エラー時には、関数の戻り値はNULLです。"
    },
    {
      "indent": 0,
      "text": "8.8. inet6_rthdr_getflags",
      "section_title": true,
      "ja": "8.8.  inet6_rthdr_getflags"
    },
    {
      "indent": 7,
      "text": "int inet6_rthdr_getflags(const struct cmsghdr *cmsg, int index);",
      "ja": "int型inet6_rthdr_getflags（のconst構造体のcmsghdr * CMSG、int型のインデックス）;"
    },
    {
      "indent": 3,
      "text": "This function returns the flags value specified by index (which must have a value between 0 and the value returned by inet6_rthdr_segments()) in the Routing header described by cmsg. For an IPv6 Type 0 Routing header the return value will be either IPV6_RTHDR_LOOSE or IPV6_RTHDR_STRICT.",
      "ja": "この関数は、CMSGによって記述ルーティングヘッダ内の（0の間の値とinet6_rthdr_segments（）によって返される値を有していなければならない）インデックスで指定されたフラグの値を返します。 IPv6のタイプ0ルーティングヘッダの戻り値はIPV6_RTHDR_LOOSE又はIPV6_RTHDR_STRICTのいずれかであろう。"
    },
    {
      "indent": 3,
      "text": "Upon an error the return value of the function is -1.",
      "ja": "エラー時の関数の戻り値は-1です。"
    },
    {
      "indent": 3,
      "text": "(Note: Addresses are indexed starting at 1, and flags starting at 0, to maintain consistency with the terminology and figures in [RFC-1883].)",
      "ja": "（注：アドレスは1から始まるインデックス付けされ、フラグが0から始まる、[RFC-1883]における用語と図面との整合性を維持するため）。"
    },
    {
      "indent": 0,
      "text": "8.9. Routing Header Example",
      "section_title": true,
      "ja": "8.9. ルーティングヘッダの例"
    },
    {
      "indent": 3,
      "text": "As an example of these Routing header functions, we go through the function calls for the example on p. 18 of [RFC-1883]. The source is S, the destination is D, and the three intermediate nodes are I1, I2, and I3. f0, f1, f2, and f3 are the Strict/Loose flags for each hop.",
      "ja": "これらのルーティングヘッダ機能の例として、我々は、p上の例えば、関数呼び出しを通過します。 [RFC-1883]の18。ソースがSであり、宛先がDであり、そして3つの中間ノードは、I1、I2、およびI3です。 F0、F1、F2、F3とは、各ホップのための厳格/ルースフラグです。"
    },
    {
      "indent": 15,
      "text": "    f0        f1        f2        f3\nS -----> I1 -----> I2 -----> I3 -----> D",
      "raw": true
    },
    {
      "indent": 7,
      "text": "src: * S S S S S dst: D I1 I2 I3 D D A[1]: I1 I2 I1 I1 I1 I1 A[2]: I2 I3 I3 I2 I2 I2 A[3]: I3 D D D I3 I3 #seg: 3 3 2 1 0 3",
      "ja": "SRC：* S S S S S DST：D I1 I2 I3 D D A [1]：I1 I2 I1 I1 I1 I1 A [2]：I2 I3 I3 I2 I2 I2 A [3]：I3 D D D I3 I3の#seg：3 ​​3 2 1 0 3"
    },
    {
      "indent": 7,
      "text": "check: f0 f1 f2 f3",
      "ja": "チェック：F0、F1、F2、F3"
    },
    {
      "indent": 3,
      "text": "src and dst are the source and destination IPv6 addresses in the IPv6 header. A[1], A[2], and A[3] are the three addresses in the Routing header. #seg is the Segments Left field in the Routing header. check indicates which bit of the Strict/Loose Bit Map (0 through 3, specified as f0 through f3) that node checks.",
      "ja": "SRCとDSTは、IPv6は、IPv6ヘッダのアドレス、送信元および宛先です。 [1]、A [2]、A [3]ルーティングヘッダ内に3つのアドレスです。 #segルーティングヘッダフィールドを左セグメントです。チェックは、（F3を通してF0として指定された0〜3）厳密/ルースビットマップそのノードチェックのどのビットを示します。"
    },
    {
      "indent": 3,
      "text": "The six values in the column beneath node S are the values in the Routing header specified by the application using sendmsg(). The function calls by the sender would look like:",
      "ja": "ノードSの下の列の6つの値は、sendmsgの（）を使用して、アプリケーションによって指定されたルーティングヘッダ内の値です。機能は次のようになります。送信者によって呼び出されます："
    },
    {
      "indent": 7,
      "text": "void  *ptr;\nstruct msghdr  msg;\nstruct cmsghdr  *cmsgptr;\nstruct sockaddr_in6  I1, I2, I3, D;\nunsigned int  f0, f1, f2, f3;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "ptr = malloc(inet6_rthdr_space(IPV6_RTHDR_TYPE_0, 3));\ncmsgptr = inet6_rthdr_init(ptr, IPV6_RTHDR_TYPE_0);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "inet6_rthdr_add(cmsgptr, &I1.sin6_addr, f0);\ninet6_rthdr_add(cmsgptr, &I2.sin6_addr, f1);\ninet6_rthdr_add(cmsgptr, &I3.sin6_addr, f2);\ninet6_rthdr_lasthop(cmsgptr, f3);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "msg.msg_control = ptr;\nmsg.msg_controllen = cmsgptr->cmsg_len;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/* finish filling in msg{}, msg_name = D */\n/* call sendmsg() */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "We also assume that the source address for the socket is not specified (i.e., the asterisk in the figure).",
      "ja": "我々はまた、ソケットの送信元アドレスが指定されていないことを前提とし（すなわち、図のアスタリスク）。"
    },
    {
      "indent": 3,
      "text": "The four columns of six values that are then shown between the five nodes are the values of the fields in the packet while the packet is in transit between the two nodes. Notice that before the packet is sent by the source node S, the source address is chosen (replacing the asterisk), I1 becomes the destination address of the datagram, the two addresses A[2] and A[3] are \"shifted up\", and D is moved to A[3]. If f0 is IPV6_RTHDR_STRICT, then I1 must be a neighbor of S.",
      "ja": "パケットが2つのノード間の通過している間に、次に5つのノードの間に示されている6つの値の4つの列は、パケットのフィールドの値です。パケットがソースノードSによって送信される前に、送信元アドレスは、（アスタリスクを置換する）選択されていることを確認し、I1は、データグラムの宛先アドレスとなり、二つのアドレス[2]、A [3]が「シフトアップ」 、およびDは、[3]に移動されます。 f0はIPV6_RTHDR_STRICTであれば、I1はS.の隣人である必要があります"
    },
    {
      "indent": 3,
      "text": "The columns of values that are shown beneath the destination node are the values returned by recvmsg(), assuming the application has enabled both the IPV6_PKTINFO and IPV6_RTHDR socket options. The source address is S (contained in the sockaddr_in6 structure pointed to by the msg_name member), the destination address is D (returned as an ancillary data object in an in6_pktinfo structure), and the ancillary data object specifying the Routing header will contain three addresses (I1, I2, and I3) and four flags (f0, f1, f2, and f3). The number of segments in the Routing header is known from the Hdr Ext Len field in the Routing header (a value of 6, indicating 3 addresses).",
      "ja": "宛先ノードの下に示されている値の列は、アプリケーションがIPV6_PKTINFOとIPV6_RTHDRソケットオプションの両方を有効にしていると仮定のrecvmsg（）によって返される値です。 S（sockaddr_in6構造体に含まれているが、はmsg_name部材によって指される）ソース・アドレスは、宛先アドレスがD（in6_pktinfo構造における補助データオブジェクトとして返される）である、ルーティングヘッダを指定する補助データオブジェクトは、3つのアドレスを含むことになります（I1、I2、及びI3）と4つのフラグ（F0、F1、F2、及びF3）。ルーティングヘッダ内のセグメントの数は（3つのアドレスを示し、6の値）ルーティングヘッダにHDR拡張LENフィールドから知られています。"
    },
    {
      "indent": 3,
      "text": "The return value from inet6_rthdr_segments() will be 3 and inet6_rthdr_getaddr(1) will return I1, inet6_rthdr_getaddr(2) will return I2, and inet6_rthdr_getaddr(3) will return I3, The return value from inet6_rthdr_flags(0) will be f0, inet6_rthdr_flags(1) will return f1, inet6_rthdr_flags(2) will return f2, and inet6_rthdr_flags(3) will return f3.",
      "ja": "inet6_rthdr_segmentsからの戻り値が（3）3及びinet6_rthdr_getaddr（1）I1、inet6_rthdr_getaddr（2）I2を返し、inet6_rthdr_getaddr（3）I3、inet6_rthdr_flagsからの戻り値は（0）F0となり戻り、inet6_rthdr_flags（戻りますであろう1）、F1返されinet6_rthdr_flags（2）F2を返し、inet6_rthdr_flags（3）F3を返します。"
    },
    {
      "indent": 3,
      "text": "If the receiving application then calls inet6_rthdr_reverse(), the order of the three addresses will become I3, I2, and I1, and the order of the four Strict/Loose flags will become f3, f2, f1, and f0.",
      "ja": "受信側アプリケーションは、その後、（）inet6_rthdr_reverseを呼び出した場合、3つのアドレスの順序はI3、I2、I1となり、四厳格/ルースフラグの順序は、F3、F2、F1、F0となります。"
    },
    {
      "indent": 3,
      "text": "We can also show what an implementation might store in the ancillary data object as the Routing header is being built by the sending process. If we assume a 32-bit architecture where sizeof(struct cmsghdr) equals 12, with a desired alignment of 4-byte boundaries, then the call to inet6_rthdr_space(3) returns 68: 12 bytes for the cmsghdr structure and 56 bytes for the Routing header (8 + 3*16).",
      "ja": "また、ルーティングヘッダが送信プロセスによって構築されているような実装は、補助的なデータオブジェクトに格納かもしれないものを表示することができます。我々ははsizeof（構造体のcmsghdr）が4バイト境界の所望の配向を有する、12に等しい32ビットのアーキテクチャを想定した場合、コールはinet6_rthdr_space（3）68戻り：ルーティングのためのcmsghdr構造体のための12バイト、56のバイトヘッダ（8 + 3 * 16）。"
    },
    {
      "indent": 3,
      "text": "The call to inet6_rthdr_init() initializes the ancillary data object to contain a Type 0 Routing header:",
      "ja": "inet6_rthdr_init（）の呼び出しはタイプ0ルーティングヘッダを含むように補助データオブジェクトを初期化します。"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 20                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_RTHDR                                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=0 | Routing Type=0|  Seg Left=0   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Reserved    |             Strict/Loose Bit Map              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first call to inet6_rthdr_add() adds I1 to the list.",
      "ja": "inet6_rthdr_addする最初の呼び出しは（）リストにI1を追加します。"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 36                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_RTHDR                                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=2 | Routing Type=0|  Seg Left=1   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Reserved    |X|           Strict/Loose Bit Map              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[1] = I1                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Bit 0 of the Strict/Loose Bit Map contains the value f0, which we just mark as X. cmsg_len is incremented by 16, the Hdr Ext Len field is incremented by 2, and the Segments Left field is incremented by 1.",
      "ja": "厳密/ルースビットマップのビット0がX.のCMSG_LENが16ずつインクリメントされるよう、我々はちょうどマーク値F0が、含まれている、HDRのExtレンフィールドは2インクリメントされ、そしてフィールド左セグメントは1だけインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "The next call to inet6_rthdr_add() adds I2 to the list.",
      "ja": "inet6_rthdr_addする次の呼び出しは（）リストにI2を追加します。"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 52                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_RTHDR                                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=4 | Routing Type=0|  Seg Left=2   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Reserved    |X|X|         Strict/Loose Bit Map              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[1] = I1                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[2] = I2                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The next bit of the Strict/Loose Bit Map contains the value f1. cmsg_len is incremented by 16, the Hdr Ext Len field is incremented by 2, and the Segments Left field is incremented by 1.",
      "ja": "厳密/ルースビットマップの次のビットは値f1が含まれています。 CMSG_LENを16だけインクリメントされ、HDR拡張LENフィールドは2だけインクリメントされ、そしてフィールド左セグメントは1だけインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "The last call to inet6_rthdr_add() adds I3 to the list.",
      "ja": "（inet6_rthdr_addへの最後の呼び出し）リストにI3を追加します。"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_len = 68                                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_level = IPPROTO_IPV6                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       cmsg_type = IPV6_RTHDR                                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Next Header  | Hdr Ext Len=6 | Routing Type=0|  Seg Left=3   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Reserved    |X|X|X|       Strict/Loose Bit Map              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[1] = I1                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[2] = I2                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                           Address[3] = I3                     +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The next bit of the Strict/Loose Bit Map contains the value f2. cmsg_len is incremented by 16, the Hdr Ext Len field is incremented by 2, and the Segments Left field is incremented by 1.",
      "ja": "厳密/ルースビットマップの次のビットは値F2が含まれています。 CMSG_LENを16だけインクリメントされ、HDR拡張LENフィールドは2だけインクリメントされ、そしてフィールド左セグメントは1だけインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "Finally, the call to inet6_rthdr_lasthop() sets the next bit of the Strict/Loose Bit Map to the value specified by f3. All the lengths remain unchanged.",
      "ja": "最後に、呼び出しは（）inet6_rthdr_lasthop F3で指定した値に厳密/ルースビットマップの次のビットをセットします。すべての長さは変わりません。"
    },
    {
      "indent": 0,
      "text": "9. Ordering of Ancillary Data and IPv6 Extension Headers",
      "section_title": true,
      "ja": "補助データとIPv6拡張ヘッダーの9.注文"
    },
    {
      "indent": 3,
      "text": "Three IPv6 extension headers can be specified by the application and returned to the application using ancillary data with sendmsg() and recvmsg(): Hop-by-Hop options, Destination options, and the Routing header. When multiple ancillary data objects are transferred via sendmsg() or recvmsg() and these objects represent any of these three extension headers, their placement in the control buffer is directly tied to their location in the corresponding IPv6 datagram. This API imposes some ordering constraints when using multiple ancillary data objects with sendmsg().",
      "ja": "三のIPv6拡張ヘッダは、アプリケーションによって指定され、（）にsendmsgと補助データを使用するアプリケーション（）とのrecvmsgに戻すことができる：ホップバイホップオプション、宛先オプション、ルーティングヘッダ。複数の補助データオブジェクトが（にsendmsgを介して転送）またはのrecvmsg（）と、これらのオブジェクトは、これらの3つの拡張ヘッダのいずれかを表している場合、制御バッファにおけるそれらの配置は、直接対応するIPv6データグラム内のそれらの位置に接続されています。複数の補助的なデータオブジェクトを使用している場合、このAPIは、（）にsendmsgでいくつかの順序制約を課します。"
    },
    {
      "indent": 3,
      "text": "When multiple IPv6 Hop-by-Hop options having the same option type are specified, these options will be inserted into the Hop-by-Hop options header in the same order as they appear in the control buffer. But when multiple Hop-by-Hop options having different option types are specified, these options may be reordered by the kernel to reduce padding in the Hop-by-Hop options header. Hop-by-Hop options may appear anywhere in the control buffer and will always be collected by the kernel and placed into a single Hop-by-Hop options header that immediately follows the IPv6 header.",
      "ja": "同じオプションタイプを有する複数のIPv6ホップバイホップオプションが指定されている場合、これらのオプションは、それらが制御バッファに現れるのと同じ順序でホップバイホップオプションヘッダに挿入されます。別のオプションタイプを有する複数のホップバイホップオプションが指定されている場合には、これらのオプションは、ホップバイホップオプションヘッダにパディングを低減するためにカーネルによって並べ替えることができます。ホップバイホップオプションは、制御バッファのどこにでも現れることがあり、常にカーネルによって収集し、直ちにIPv6ヘッダの後に続く単一ホップバイホップオプションヘッダに配置されます。"
    },
    {
      "indent": 3,
      "text": "Similar rules apply to the Destination options: (1) those of the same type will appear in the same order as they are specified, and (2) those of differing types may be reordered. But the kernel will build up to two Destination options headers: one to precede the Routing header and one to follow the Routing header. If the application specifies a Routing header then all Destination options that appear in the control buffer before the Routing header will appear in a Destination options header before the Routing header and these options might be reordered, subject to the two rules that we just stated. Similarly all Destination options that appear in the control buffer after the Routing header will appear in a Destination options header after the Routing header, and these options might be reordered, subject to the two rules that we just stated.",
      "ja": "同様のルールが宛先オプションに適用される：（1）同じタイプのものは、それらが指定されているのと同じ順序で表示され、（2）異なるタイプのものが並べ替えてもよいです。ルーティングヘッダに従うことをルーティングヘッダと1の前に1：しかし、カーネルは、2つの宛先オプションヘッダに構築されます。アプリケーションは、ルーティングヘッダを指定する場合は、ルーティングヘッダの前に制御バッファに表示されるすべての宛先オプションは、オプションは、ルーティングヘッダの前にヘッダーとこれらのオプションは、我々はちょうど述べた二つの規則の対象に再順序付けされる場合があります先に表示されます。同様にルーティングヘッダーの後に制御バッファに表示されるすべての宛先オプションは、ルーティングヘッダーの後に宛先オプションヘッダーに表示され、これらのオプションは、我々はちょうど述べた二つの規則の対象に再順序付けされる場合があります。"
    },
    {
      "indent": 3,
      "text": "As an example, assume that an application specifies control information to sendmsg() containing six ancillary data objects: the first containing two Hop-by-Hop options, the second containing one Destination option, the third containing two Destination options, the fourth containing a Routing header, the fifth containing a Hop-by-Hop option, and the sixth containing two Destination options. We also assume that all the Hop-by-Hop options are of different types, as are all the Destination options. We number these options 1-9, corresponding to their order in the control buffer, and show them on the left below.",
      "ja": "第四に含む、第一含む二つのホップバイホップオプション、1つの宛先オプションを含む第二、第三含む2つの宛先オプション：一例として、アプリケーションは、6つの補助的なデータオブジェクトを含む）（SENDMSGに制御情報を指定することを前提としていヘッダルーティング、ホップバイホップオプションを含む第五、および2つの宛先オプションを含む第六。我々はまた、すべての宛先オプションがあるように、すべてのホップバイホップオプションは、さまざまな種類のものであることを前提としています。私たちは、制御バッファ内の順序に対応し、これらのオプション1-9数、および下記の左側にそれらを表示します。"
    },
    {
      "indent": 3,
      "text": "In the middle we show the final arrangement of the options in the extension headers built by the kernel. On the right we show the four ancillary data objects returned to the receiving application.",
      "ja": "途中で我々はカーネルによって構築された拡張ヘッダのオプションの最終的配置を示します。右側には、我々は4つの補助的なデータオブジェクトは受信側アプリケーションに返さ示しました。"
    },
    {
      "indent": 7,
      "text": "   Sender's                                       Receiver's\nAncillary Data      -->   IPv6 Extension   -->  Ancillary Data\n   Objects                    Headers              Objects\n------------------        ---------------       --------------\nHOPOPT-1,2 (first)        HOPHDR(J,7,1,2)       HOPOPT-7,1,2\nDSTOPT-3                  DSTHDR(4,5,3)         DSTOPT-4,5,3\nDSTOPT-4,5                RTHDR(6)              RTHDR-6\nRTHDR-6                   DSTHDR(8,9)           DSTOPT-8,9\nHOPOPT-7\nDSTOPT-8,9 (last)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sender's two Hop-by-Hop ancillary data objects are reordered, as are the first two Destination ancillary data objects. We also show a Jumbo Payload option (denoted as J) inserted by the kernel before the sender's three Hop-by-Hop options. The first three Destination options must appear in a Destination header before the Routing header, and the final two Destination options must appear in a Destination header after the Routing header.",
      "ja": "最初の2つの宛先の補助データオブジェクトがそうであるように、送信者の2つのホップバイホップの補助的なデータオブジェクトは、並べ替えています。また、送信者の3ホップバイホップオプションの前にカーネルによって挿入された（Jと表記）巨大ペイロードオプションを示しています。最初の三つの宛先オプションは、ルーティングヘッダの前に宛先ヘッダに表示される必要があり、最終的な2つの宛先オプションは、ルーティングヘッダの後に宛先ヘッダに現れなければなりません。"
    },
    {
      "indent": 3,
      "text": "If Destination options are specified in the control buffer after a Routing header, or if Destination options are specified without a Routing header, the kernel will place those Destination options after an authentication header and/or an encapsulating security payload header, if present.",
      "ja": "宛先オプションがルーティングヘッダの後に制御バッファに指定されている場合宛先オプションがルーティングヘッダなしで指定された場合に存在する場合、または、カーネルは、認証ヘッダおよび/またはカプセル化セキュリティペイロードヘッダの後にそれらの宛先オプションを配置します。"
    },
    {
      "indent": 0,
      "text": "10. IPv6-Specific Options with IPv4-Mapped IPv6 Addresses",
      "section_title": true,
      "ja": "IPv4マップIPv6アドレスを持つ10 IPv6固有オプション"
    },
    {
      "indent": 3,
      "text": "The various socket options and ancillary data specifications defined in this document apply only to true IPv6 sockets. It is possible to create an IPv6 socket that actually sends and receives IPv4 packets, using IPv4-mapped IPv6 addresses, but the mapping of the options defined in this document to an IPv4 datagram is beyond the scope of this document.",
      "ja": "様々なソケットオプションと、この文書で定義された補助的なデータ仕様は真のIPv6ソケットにのみ適用されます。実際に送信し、IPv4射影IPv6アドレスを使用して、IPv4パケットを受信したIPv6ソケットを作成することは可能ですが、IPv4のデータグラムには、この文書で定義されたオプションのマッピングは、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "In general, attempting to specify an IPv6-only option, such as the Hop-by-Hop options, Destination options, or Routing header on an IPv6 socket that is using IPv4-mapped IPv6 addresses, will probably result in an error. Some implementations, however, may provide access to the packet information (source/destination address, send/receive interface, and hop limit) on an IPv6 socket that is using IPv4-mapped IPv6 addresses.",
      "ja": "一般に、このようなIPv4マップIPv6アドレスを使用しているIPv6ソケット上のホップバイホップオプション、宛先オプション、またはルーティングヘッダとして、IPv6のみのオプションを指定しようとすると、おそらくエラーになります。いくつかの実装では、しかし、IPv4マップIPv6アドレスを使用しているIPv6ソケットに（ソース/宛先アドレス、インターフェース、およびホップリミットを受信/送信）パケット情報へのアクセスを提供することができます。"
    },
    {
      "indent": 0,
      "text": "11. rresvport_af",
      "section_title": true,
      "ja": "11. rresvport_af"
    },
    {
      "indent": 3,
      "text": "The rresvport() function is used by the rcmd() function, and this function is in turn called by many of the \"r\" commands such as rlogin. While new applications are not being written to use the rcmd() function, legacy applications such as rlogin will continue to use it and these will be ported to IPv6.",
      "ja": "rresvport（）関数は、RCMD（）関数によって使用され、この機能は、今度は、そのようなrloginのような「R」コマンドの多くによって呼び出されます。新しいアプリケーションは、RCMD（）関数を使用するように書かれていないが、そのようなrloginなどのレガシーアプリケーションはそれを使用し続けると、これらは、IPv6に移植されます。"
    },
    {
      "indent": 3,
      "text": "rresvport() creates an IPv4/TCP socket and binds a \"reserved port\" to the socket. Instead of defining an IPv6 version of this function we define a new function that takes an address family as its argument.",
      "ja": "rresvport（）はIPv4の/ TCPソケットを作成し、ソケットに「予約ポート」をバインドします。代わりに、この機能のIPv6のバージョンを定義するので、私たちはその引数としてアドレスファミリを取る新しい関数を定義します。"
    },
    {
      "indent": 7,
      "text": "#include <unistd.h>",
      "ja": "書式#include <unistd.h>"
    },
    {
      "indent": 7,
      "text": "int rresvport_af(int *port, int family);",
      "ja": "あなたrresvport_af（あなた*ポート、あなたの家族）。"
    },
    {
      "indent": 3,
      "text": "This function behaves the same as the existing rresvport() function, but instead of creating an IPv4/TCP socket, it can also create an IPv6/TCP socket. The family argument is either AF_INET or AF_INET6, and a new error return is EAFNOSUPPORT if the address family is not supported.",
      "ja": "この機能は既存のrresvport（）関数と同じように動作し、代わりのIPv4 / TCPソケットを作成する、それはまたのIPv6 / TCPソケットを作成することができます。家族の引数は、どちらかAF_INETまたはAF_INET6で、アドレスファミリがサポートされていない場合、新しいエラーリターンはEAFNOSUPPORTです。"
    },
    {
      "indent": 3,
      "text": "(Note: There is little consensus on which header defines the rresvport() and rcmd() function prototypes. 4.4BSD defines it in <unistd.h>, others in <netdb.h>, and others don't define the function prototypes at all.)",
      "ja": "（注：少しヘッダがrresvportを定義したコンセンサス（）およびRCMD（）関数のプロトタイプがあり4.4BSDは<netdb.h>で他、<unistd.h>にそれを定義し、他のものは関数プロトタイプを定義していません。全然。）"
    },
    {
      "indent": 3,
      "text": "(Note: We define this function only, and do not define something like rcmd_af() or rcmd6(). The reason is that rcmd() calls gethostbyname(), which returns the type of address: AF_INET or AF_INET6. It should therefore be possible to modify rcmd() to support either IPv4 or IPv6, based on the address family returned by gethostbyname().)",
      "ja": "（注：私たちは、これだけの機能を定義し、rcmd_afのようなもの（）またはrcmd6（）を定義していない理由は）（アドレスの種類を返すのgethostbyname（）、つまりRCMD呼び出しです：AF_INETまたはAF_INET6をしたがって、する必要がありますgethostbyname（によって返されたアドレスファミリに基づいて、IPv4またはIPv6のいずれかをサポートするために（）RCMDを変更することも可能）。）"
    },
    {
      "indent": 0,
      "text": "12. Future Items",
      "section_title": true,
      "ja": "12.未来のアイテム"
    },
    {
      "indent": 3,
      "text": "Some additional items may require standardization, but no concrete proposals have been made for the API to perform these tasks. These may be addressed in a later document.",
      "ja": "いくつかの追加項目は、標準化が必要な場合がありますが、具体的な提案は、これらのタスクを実行するためのAPIのために作られていません。これらは、後に文書で対処することができます。"
    },
    {
      "indent": 0,
      "text": "12.1. Flow Labels",
      "section_title": true,
      "ja": "12.1. フローラベル"
    },
    {
      "indent": 3,
      "text": "Earlier revisions of this document specified a set of inet6_flow_XXX() functions to assign, share, and free IPv6 flow labels. Consensus, however, indicated that it was premature to specify this part of the API.",
      "ja": "この文書の以前のリビジョンはアサインするinet6_flow_XXX（）関数のセット、共有し、無料のIPv6フローラベルを指定しました。コンセンサスは、しかし、APIのこの部分を指定するのは時期尚早であることが示されました。"
    },
    {
      "indent": 0,
      "text": "12.2. Path MTU Discovery and UDP",
      "section_title": true,
      "ja": "12.2. パスMTUディスカバリーとUDP"
    },
    {
      "indent": 3,
      "text": "A standard method may be desirable for a UDP application to determine the \"maximum send transport-message size\" (Section 5.1 of [RFC-1981]) to a given destination. This would let the UDP application send smaller datagrams to the destination, avoiding fragmentation.",
      "ja": "UDPアプリケーションは、特定の宛先への（[RFC-1981のセクション5.1）を「最大送信トランスポート・メッセージのサイズ」を決定するための標準的な方法が望ましいかもしれません。これは、UDPアプリケーションが断片化を避け、先に小さなデータグラムを送ってみましょうだろう。"
    },
    {
      "indent": 0,
      "text": "12.3. Neighbor Reachability and UDP",
      "section_title": true,
      "ja": "12.3. ネイバー到達可能とUDP"
    },
    {
      "indent": 3,
      "text": "A standard method may be desirable for a UDP application to tell the kernel that it is making forward progress with a given peer (Section 7.3.1 of [RFC-1970]). This could save unneeded neighbor solicitations and neighbor advertisements.",
      "ja": "UDPアプリケーションが前方に所定のピア（[RFC-1970]のセクション7.3.1）と進展しているカーネルに通知するための標準的な方法が望ましいかもしれません。これは、不要な近隣要請と近隣広告を救うことができます。"
    },
    {
      "indent": 0,
      "text": "13. Summary of New Definitions",
      "section_title": true,
      "ja": "新しい定義の概要13"
    },
    {
      "indent": 3,
      "text": "The following list summarizes the constants and structure, definitions discussed in this memo, sorted by header.",
      "ja": "以下のリストは、ヘッダによってソート定数と構造、このメモで議論定義をまとめたものです。"
    },
    {
      "indent": 5,
      "text": "<netinet/icmp6.h> ICMP6_DST_UNREACH <netinet/icmp6.h> ICMP6_DST_UNREACH_ADDR <netinet/icmp6.h> ICMP6_DST_UNREACH_ADMIN <netinet/icmp6.h> ICMP6_DST_UNREACH_NOPORT <netinet/icmp6.h> ICMP6_DST_UNREACH_NOROUTE <netinet/icmp6.h> ICMP6_DST_UNREACH_NOTNEIGHBOR <netinet/icmp6.h> ICMP6_ECHO_REPLY <netinet/icmp6.h> ICMP6_ECHO_REQUEST <netinet/icmp6.h> ICMP6_INFOMSG_MASK <netinet/icmp6.h> ICMP6_MEMBERSHIP_QUERY <netinet/icmp6.h> ICMP6_MEMBERSHIP_REDUCTION <netinet/icmp6.h> ICMP6_MEMBERSHIP_REPORT <netinet/icmp6.h> ICMP6_PACKET_TOO_BIG <netinet/icmp6.h> ICMP6_PARAMPROB_HEADER <netinet/icmp6.h> ICMP6_PARAMPROB_NEXTHEADER <netinet/icmp6.h> ICMP6_PARAMPROB_OPTION <netinet/icmp6.h> ICMP6_PARAM_PROB <netinet/icmp6.h> ICMP6_TIME_EXCEEDED <netinet/icmp6.h> ICMP6_TIME_EXCEED_REASSEMBLY <netinet/icmp6.h> ICMP6_TIME_EXCEED_TRANSIT <netinet/icmp6.h> ND_NA_FLAG_OVERRIDE <netinet/icmp6.h> ND_NA_FLAG_ROUTER <netinet/icmp6.h> ND_NA_FLAG_SOLICITED <netinet/icmp6.h> ND_NEIGHBOR_ADVERT <netinet/icmp6.h> ND_NEIGHBOR_SOLICIT <netinet/icmp6.h> ND_OPT_MTU <netinet/icmp6.h> ND_OPT_PI_FLAG_AUTO <netinet/icmp6.h> ND_OPT_PI_FLAG_ONLINK <netinet/icmp6.h> ND_OPT_PREFIX_INFORMATION",
      "ja": "<netinetの/ icmp6.h> ICMP6_DST_UNREACH <netinetの/ icmp6.h> ICMP6_DST_UNREACH_ADDR <netinetの/ icmp6.h> ICMP6_DST_UNREACH_ADMIN <netinetの/ icmp6.h> ICMP6_DST_UNREACH_NOPORT <netinetの/ icmp6.h> ICMP6_DST_UNREACH_NOROUTE <netinetの/ icmp6.h> ICMP6_DST_UNREACH_NOTNEIGHBOR <netinetの/icmp6.h> ICMP6_ECHO_REPLY <netinetの/ icmp6.h> ICMP6_ECHO_REQUEST <netinetの/ icmp6.h> ICMP6_INFOMSG_MASK <netinetの/ icmp6.h> ICMP6_MEMBERSHIP_QUERY <netinetの/ icmp6.h> ICMP6_MEMBERSHIP_REDUCTION <netinetの/ icmp6.h> ICMP6_MEMBERSHIP_REPORT <netinetの/ ICMP6 .H> ICMP6_PACKET_TOO_BIG <netinetの/ icmp6.h> ICMP6_PARAMPROB_HEADER <netinetの/ icmp6.h> ICMP6_PARAMPROB_NEXTHEADER <netinetの/ icmp6.h> ICMP6_PARAMPROB_OPTION <netinetの/ icmp6.h> ICMP6_PARAM_PROB <netinetの/ icmp6.h> ICMP6_TIME_EXCEEDED <netinetの/ icmp6.h > ICMP6_TIME_EXCEED_REASSEMBLY <netinetの/ icmp6.h> ICMP6_TIME_EXCEED_TRANSIT <netinetの/ icmp6.h> ND_NA_FLAG_OVERRIDE <netinetの/ icmp6.h> ND_NA_FLAG_ROUTER <netinetの/ icmp6.h> ND_NA_FLAG_SOLICITED <netinetの/ icmp6.h> ND_NEIGHBOR_ADVERT <netinetの/ icmp6.h> ND_NEIGHBOR _SOLICIT <netinetの/ icmp6.h> ND_OPT_MTU <netinetの/ icmp6.h> ND_OPT_PI_FLAG_AUTO <netinetの/ icmp6.h> ND_OPT_PI_FLAG_ONLINK <netinetの/ icmp6.h> ND_OPT_PREFIX_INFORMATION"
    },
    {
      "indent": 5,
      "text": "<netinet/icmp6.h> ND_OPT_REDIRECTED_HEADER <netinet/icmp6.h> ND_OPT_SOURCE_LINKADDR <netinet/icmp6.h> ND_OPT_TARGET_LINKADDR <netinet/icmp6.h> ND_RA_FLAG_MANAGED <netinet/icmp6.h> ND_RA_FLAG_OTHER <netinet/icmp6.h> ND_REDIRECT <netinet/icmp6.h> ND_ROUTER_ADVERT <netinet/icmp6.h> ND_ROUTER_SOLICIT",
      "ja": "<netinetの/ icmp6.h> ND_OPT_REDIRECTED_HEADER <netinetの/ icmp6.h> ND_OPT_SOURCE_LINKADDR <netinetの/ icmp6.h> ND_OPT_TARGET_LINKADDR <netinetの/ icmp6.h> ND_RA_FLAG_MANAGED <netinetの/ icmp6.h> ND_RA_FLAG_OTHER <netinetの/ icmp6.h> ND_REDIRECT <netinetの/icmp6.h> ND_ROUTER_ADVERT <netinetの/ icmp6.h> ND_ROUTER_SOLICIT"
    },
    {
      "indent": 5,
      "text": "<netinet/icmp6.h> struct icmp6_filter{};\n<netinet/icmp6.h> struct icmp6_hdr{};\n<netinet/icmp6.h> struct nd_neighbor_advert{};\n<netinet/icmp6.h> struct nd_neighbor_solicit{};\n<netinet/icmp6.h> struct nd_opt_hdr{};\n<netinet/icmp6.h> struct nd_opt_mtu{};\n<netinet/icmp6.h> struct nd_opt_prefix_info{};\n<netinet/icmp6.h> struct nd_opt_rd_hdr{};\n<netinet/icmp6.h> struct nd_redirect{};\n<netinet/icmp6.h> struct nd_router_advert{};\n<netinet/icmp6.h> struct nd_router_solicit{};",
      "raw": true
    },
    {
      "indent": 5,
      "text": "<netinet/in.h> IPPROTO_AH <netinet/in.h> IPPROTO_DSTOPTS <netinet/in.h> IPPROTO_ESP <netinet/in.h> IPPROTO_FRAGMENT <netinet/in.h> IPPROTO_HOPOPTS <netinet/in.h> IPPROTO_ICMPV6 <netinet/in.h> IPPROTO_IPV6 <netinet/in.h> IPPROTO_NONE <netinet/in.h> IPPROTO_ROUTING <netinet/in.h> IPV6_DSTOPTS <netinet/in.h> IPV6_HOPLIMIT <netinet/in.h> IPV6_HOPOPTS <netinet/in.h> IPV6_NEXTHOP <netinet/in.h> IPV6_PKTINFO <netinet/in.h> IPV6_PKTOPTIONS <netinet/in.h> IPV6_RTHDR <netinet/in.h> IPV6_RTHDR_LOOSE <netinet/in.h> IPV6_RTHDR_STRICT <netinet/in.h> IPV6_RTHDR_TYPE_0 <netinet/in.h> struct in6_pktinfo{};",
      "ja": "<netinetの/ in.h> IPPROTO_AH <netinetの/ in.h> IPPROTO_DSTOPTS <netinetの/ in.h> IPPROTO_ESP <netinetの/ in.h> IPPROTO_FRAGMENT <netinetの/ in.h> IPPROTO_HOPOPTS <netinetの/ in.h> IPPROTO_ICMPV6 <netinetの/in.h> IPPROTO_IPV6 <netinetの/ in.h> IPPROTO_NONE <netinetの/ in.h> IPPROTO_ROUTING <netinetの/ in.h> IPV6_DSTOPTS <netinetの/ in.h> IPV6_HOPLIMIT <netinetの/ in.h> IPV6_HOPOPTS <netinetの/に.H> IPV6_NEXTHOP <netinetの/ in.h> IPV6_PKTINFO <netinetの/ in.h> IPV6_PKTOPTIONS <netinetの/ in.h> IPV6_RTHDR <netinetの/ in.h> IPV6_RTHDR_LOOSE <netinetの/ in.h> IPV6_RTHDR_STRICT <netinetの/ in.h > IPV6_RTHDR_TYPE_0 <netinetの/ in.h>構造体in6_pktinfo {}。"
    },
    {
      "indent": 5,
      "text": "<netinet/ip6.h>   IP6F_OFF_MASK\n<netinet/ip6.h>   IP6F_RESERVED_MASK\n<netinet/ip6.h>   IP6F_MORE_FRAG\n<netinet/ip6.h>   struct ip6_dest{};\n<netinet/ip6.h>   struct ip6_frag{};\n<netinet/ip6.h>   struct ip6_hbh{};",
      "raw": true
    },
    {
      "indent": 5,
      "text": "<netinet/ip6.h>   struct ip6_hdr{};\n<netinet/ip6.h>   struct ip6_rthdr{};\n<netinet/ip6.h>   struct ip6_rthdr0{};",
      "raw": true
    },
    {
      "indent": 5,
      "text": "<sys/socket.h>    struct cmsghdr{};\n<sys/socket.h>    struct msghdr{};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following list summarizes the function and macro prototypes discussed in this memo, sorted by header.",
      "ja": "以下のリストは、ヘッダによってソートこのメモで議論機能とマクロプロトタイプをまとめたものです。"
    },
    {
      "indent": 0,
      "text": "<netinet/icmp6.h> void ICMP6_FILTER_SETBLOCK(int,\n                                                struct icmp6_filter *);\n<netinet/icmp6.h> void ICMP6_FILTER_SETBLOCKALL(struct icmp6_filter *);\n<netinet/icmp6.h> void ICMP6_FILTER_SETPASS(int, struct icmp6_filter *);\n<netinet/icmp6.h> void ICMP6_FILTER_SETPASSALL(struct icmp6_filter *);\n<netinet/icmp6.h> int  ICMP6_FILTER_WILLBLOCK(int,\n                                           const struct icmp6_filter *);\n<netinet/icmp6.h> int  ICMP6_FILTER_WILLPASS(int,\n                                           const struct icmp6_filter *);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "<netinet/in.h> int IN6_ARE_ADDR_EQUAL(const struct in6_addr *, const struct in6_addr *);",
      "ja": "<netinetの/ in.h> INT IN6_ARE_ADDR_EQUAL（constの構造体のin6_addr *、constの構造体のin6_addr *）。"
    },
    {
      "indent": 0,
      "text": "<netinet/in.h>    uint8_t *inet6_option_alloc(struct cmsghdr *,\n                                               int, int, int);\n<netinet/in.h>    int inet6_option_append(struct cmsghdr *,\n                                          const uint8_t *, int, int);\n<netinet/in.h>    int inet6_option_find(const struct cmsghdr *,\n                                        uint8_t *, int);\n<netinet/in.h>    int inet6_option_init(void *, struct cmsghdr **, int);\n<netinet/in.h>    int inet6_option_next(const struct cmsghdr *,\n                                        uint8_t **);\n<netinet/in.h>    int inet6_option_space(int);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "<netinet/in.h>    int inet6_rthdr_add(struct cmsghdr *,\n                                      const struct in6_addr *,\n                                      unsigned int);\n<netinet/in.h>    struct in6_addr inet6_rthdr_getaddr(struct cmsghdr *,\n                                                      int);\n<netinet/in.h>    int inet6_rthdr_getflags(const struct cmsghdr *, int);\n<netinet/in.h>    struct cmsghdr *inet6_rthdr_init(void *, int);\n<netinet/in.h>    int inet6_rthdr_lasthop(struct cmsghdr *,\n                                                          unsigned int);\n<netinet/in.h>    int inet6_rthdr_reverse(const struct cmsghdr *,\n                                          struct cmsghdr *);\n<netinet/in.h>    int inet6_rthdr_segments(const struct cmsghdr *);\n<netinet/in.h>    size_t inet6_rthdr_space(int, int);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "<sys/socket.h>    unsigned char *CMSG_DATA(const struct cmsghdr *);\n<sys/socket.h>    struct cmsghdr *CMSG_FIRSTHDR(const struct msghdr *);\n<sys/socket.h>    unsigned int CMSG_LEN(unsigned int);\n<sys/socket.h>    struct cmsghdr *CMSG_NXTHDR(const struct msghdr *mhdr,\n                                              const struct cmsghdr *);\n<sys/socket.h>    unsigned int CMSG_SPACE(unsigned int);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "<unistd.h> int rresvport_af(int *, int);",
      "ja": "<Unistd.h>あなたrresvport_af（あなた*、あなた）。"
    },
    {
      "indent": 0,
      "text": "14. Security Considerations",
      "section_title": true,
      "ja": "14.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The setting of certain Hop-by-Hop options and Destination options may be restricted to privileged processes. Similarly some Hop-by-Hop options and Destination options may not be returned to nonprivileged applications.",
      "ja": "一定のホップバイホップオプションと宛先オプションの設定は特権プロセスに制限することができます。同様に、いくつかのホップバイホップオプションと宛先オプションは、非特権アプリケーションに返されないことがあります。"
    },
    {
      "indent": 0,
      "text": "15. Change History",
      "section_title": true,
      "ja": "15.変更履歴"
    },
    {
      "indent": 3,
      "text": "Changes from the June 1997 Edition (-03 draft)",
      "ja": "1997年6月版からの変更点（-03案）"
    },
    {
      "indent": 4,
      "text": "- Added a note that defined constants for multibyte fields are in network byte order. This affects the ip6f_offlg member of the Fragment header (Section 2.1.2) and the nd_na_flags_reserved member of the nd_neighbor_advert structure (Section 2.2.2).",
      "ja": " - マルチバイトフィールドの定数はネットワークバイトオーダーにある定義されたノートを追加しました。これは、フラグメントヘッダ（セクション2.1.2）のip6f_offlg部材とnd_neighbor_advert構造（セクション2.2.2）のnd_na_flags_reservedメンバーに影響を与えます。"
    },
    {
      "indent": 4,
      "text": "- Section 5: the ipi6_ifindex member of the in6_pktinfo structure should be \"unsigned int\" instead of \"int\", for consistency with the interface indexes in [RFC-2133].",
      "ja": " - セクション5：in6_pktinfo構造のipi6_ifindex部材は、[RFC-2133]におけるインターフェースインデックスとの整合のために代わりに「INT」の「unsigned int型」であるべきです。"
    },
    {
      "indent": 4,
      "text": "- Section 6.3.7: the three calls to inet6_option_space() in the examples needed to be arguments to malloc(). The final one of these was missing the \"6\" in the name \"inet6_option_space\".",
      "ja": " -  6.3.7項：inet6_option_spaceへの3つの呼び出し（）はmallocの引数（なるために必要な例で）。これらの最後の一つが「6」の名前で「inet6_option_spaceを」行方不明になりました。"
    },
    {
      "indent": 4,
      "text": "- Section 8.6: the function prototype for inet6_rthdr_segments() was missing the ending semicolon.",
      "ja": " - セクション8.6：inet6_rthdr_segmentsの関数プロトタイプは、（）の終了セミコロンがありませんでした。"
    },
    {
      "indent": 3,
      "text": "Changes from the March 1997 Edition (-02 draft)",
      "ja": "1997年3月版からの変更点（-02案）"
    },
    {
      "indent": 4,
      "text": "- In May 1997 Draft 6.6 of Posix 1003.1g (called Posix.1g herein) passed ballot and will be forwarded to the IEEE Standards Board later in 1997 for final approval. Some changes made for this final Posix draft are incorporated into this Internet Draft, specifically the datatypes mentioned in Section 1 (and used throughout the text), and the socklen_t datatype used in Section 4.1 and 4.2.",
      "ja": " -  1997年5月（ここPosix.1gと呼ばれる）のPosix 1003.1グラムのドラフト6.6には、投票用紙を渡され、最終承認のために、後に1997年にIEEE標準化委員会に転送されます。この最終のPosixドラフトのために作られたいくつかの変更は、このインターネットドラフト、セクション1（及びテキストを通して使用される）に記載された具体的データ型、およびセクション4.1および4.2で使用されるのsocklen_tデータ型に組み込まれます。"
    },
    {
      "indent": 4,
      "text": "- Section 1: Added the intN_t signed datatypes, changed the datatype u_intN_t to uintN_t (no underscore after the \"u\"), and removed the datatype u_intNm_t, as per Draft 6.6 of Posix.1g.",
      "ja": " - セクション1：追加intN_tはデータ型に署名し、（「U」の後には下線）uintN_tにデータ型u_intN_tを変えず、Posix.1gのドラフト6.6に従って、データ型u_intNm_tを除去します。"
    },
    {
      "indent": 4,
      "text": "- Name space issues for structure and constant names in Section 2: Many of the structure member names and constant names were changed so that the prefixes are the same. The following prefixes are used for structure members: \"ip6_\", \"icmp6_\", and \"nd_\". All constants have the prefixes \"ICMP6_\" and \"ND_\".",
      "ja": " - 第2節での構造や定数名のネームスペースの問題：プレフィックスが同じになるように構造体のメンバ名と定数名の多くが変更されました。 「ip6_」、「icmp6_」、および「nd_」：次の接頭辞は、構造体のメンバーのために使用されています。すべての定数は、接頭辞「ICMP6_」と「ND_」を持っています。"
    },
    {
      "indent": 4,
      "text": "- New definitions: Section 2.1.2: contains definitions for the IPv6 extension headers, other than AH and ESP. Section 2.2.2: contains additional structures and constants for the neighbor discovery option header and redirected header.",
      "ja": " - 新しい定義：セクション2.1.2：AHとESP以外の、IPv6拡張ヘッダーの定義が含まれています。 2.2.2項は：近隣探索オプションヘッダとリダイレクトヘッダのための追加の構造と定数が含まれています。"
    },
    {
      "indent": 4,
      "text": "- Section 2.2.2: the enum for the neighbor discovery option field was changed to be a set of #define constants.",
      "ja": " - セクション2.2.2：近隣探索オプションフィールドの列挙がの#define定数のセットに変更されました。"
    },
    {
      "indent": 4,
      "text": "- Changed the word \"function\" to \"macro\" for references to all the uppercase names in Sections 2.3 (IN6_ARE_ADDR_EQUAL), 3.2 (ICMPV6_FILTER_xxx), and 4.3 (CMSG_xxx).",
      "ja": " - セクション2.3（IN6_ARE_ADDR_EQUAL）内のすべての大文字の名前を参照するための「マクロ」、3.2（ICMPV6_FILTER_xxx）、および4.3（CMSG_xxx）に単語「機能」に変更。"
    },
    {
      "indent": 4,
      "text": "- Added more protocols to the /etc/protocols file (Section 2.4) and changed the name of \"icmpv6\" to \"ipv6-icmp\".",
      "ja": " - の/ etc / protocolsファイル（2.4節）に複数のプロトコルを追加し、 \"ICMPv6の\" への \"IPv6-ICMP\" の名称を変更しました。"
    },
    {
      "indent": 4,
      "text": "- Section 3: Made it more explicit that an application cannot read or write entire IPv6 packets, that all extension headers are passed as ancillary data. Added a sentence that the kernel fragments packets written to an IPv6 raw socket when necessary. Added a note that IPPROTO_RAW raw IPv6 sockets are not special.",
      "ja": " - 第3節：すべての拡張ヘッダは、補助データとして渡されていることを、アプリケーション全体のIPv6パケットを読み取りまたは書き込みができないこと、それは、より明確なメイド。必要なカーネルフラグメントパケットがIPv6生ソケットに書き込まれたという文を追加しました。 IPPROTO_RAW生のIPv6ソケットが特別ではないことに注意してくださいを追加しました。"
    },
    {
      "indent": 4,
      "text": "- Section 3.1: Explicitly stated that the checksum option applies to both outgoing packets and received packets.",
      "ja": " - セクション3.1：明示的にチェックサムオプションが発信パケットと受信パケットの両方に適用されると述べました。"
    },
    {
      "indent": 4,
      "text": "- Section 3.2: Changed the array name within the icmp6_filter structure from \"data\" to \"icmp6_filt\". Changes the prefix for the filter macros from \"ICMPV6_\" to \"ICMP6_\", for consistency with the names in Section 2.2. Changed the example from a ping program to a program that wants to receive only router advertisements.",
      "ja": " - セクション3.2：「icmp6_filt」に「データ」からicmp6_filter構造内の配列名を変更しました。 2.2節内の名前との整合性のために、「ICMP6_」を「ICMPV6_」からフィルタマクロの接頭辞を変更します。のみルータ広告を受信したいプログラムへのpingプログラムからの例を変更しました。"
    },
    {
      "indent": 4,
      "text": "- Section 4.1: Changed msg_namelen and msg_controllen from size_t to the Posix.1g socklen_t datatype. Updated the Note that follows.",
      "ja": " - セクション4.1：msg_namelen変更とPosix.1gのsocklen_tデータ型にsize_t型からmsg_controllen。以下の注意事項を更新しました。"
    },
    {
      "indent": 4,
      "text": "- Section 4.2: Changed cmsg_len from size_t to the Posix.1g socklen_t datatype. Updated the Note that follows.",
      "ja": " - セクション4.2：Posix.1gのsocklen_tデータ型にsize_t型からCMSG_LEN変更しました。以下の注意事項を更新しました。"
    },
    {
      "indent": 4,
      "text": "- Section 4.4: Added a Note that the second and third arguments to getsockopt() and setsockopt() are intentionally the same as the cmsg_level and cmsg_type members.",
      "ja": " - セクション4.4：第二および第三の引き数はGETSOCKOPTすることが追加された注（）とのsetsockopt（）意図cmsg_levelメンバとcmsg_typeメンバーと同じです。"
    },
    {
      "indent": 4,
      "text": "- Section 4.5: Reorganized the section into a description of the option, followed by the TCP semantics, and the UDP and raw socket semantics. Added a sentence on how to clear all the sticky options. Added a note that TCP need not save the options from the most recently received segment until the application says to do so. Added the statement that ancillary data is never passed with sendmsg() or recvmsg() on a TCP socket. Simplified the interaction of the sticky options with ancillary data for UDP or raw IP: none of the sticky options are sent if ancillary data is specified.",
      "ja": " - セクション4.5：TCP意味論が続くオプションの説明にセクション、およびUDPと生ソケットのセマンティクスを再編成しました。すべてのスティッキオプションをオフにする方法についての文を追加しました。 TCPは、アプリケーションがそうするようにと言うまで、最も最近に受信したセグメントからオプションを保存する必要はないことに注意を追加。補助データは、TCPソケット上にsendmsg（）またはのrecvmsg（）に渡されることはありませんという文を追加しました。 UDPまたはRaw IPのための補助的なデータを持つ粘着性のオプションの相互作用を簡素化された：補助データが指定されている場合はスティッキーオプションのいずれも送信されません。"
    },
    {
      "indent": 4,
      "text": "- Final paragraph of Section 5.1: ipi6_index should be ipi6_ifindex.",
      "ja": " -  5.1節の最後の段落：ipi6_indexがipi6_ifindexする必要があります。"
    },
    {
      "indent": 4,
      "text": "- Section 5.4: Added a note on the term \"privileged\".",
      "ja": " - セクション5.4：「特権」という用語に注釈を追加しました。"
    },
    {
      "indent": 4,
      "text": "- Section 5.5: Noted that the errors listed are examples, and the actual errors depend on the implementation.",
      "ja": " - セクション5.5：リストされたエラーは一例であり、実際のエラーは、実装に依存していることを指摘しました。"
    },
    {
      "indent": 4,
      "text": "- Removed Section 6 (\"Flow Labels\") as the consensus is that it is premature to try and specify an API for this feature. Access to the flow label field in the IPv6 header is still provided through the sin6_flowinfo member of the IPv6 socket address structure in [RFC-2133]. Added a subsection to Section 13 that this is a future item.",
      "ja": " - コンセンサスとして除去する第6章（「フローラベル」）は、しようとすると、この機能のためのAPIを指定するのは時期尚早であるということです。 IPv6ヘッダのフロー・ラベル・フィールドへのアクセスは依然として[RFC-2133]でIPv6のソケットアドレス構造のsin6_flowinfo部材を介して設けられています。これは将来のアイテムである第13のサブセクションを追加しました。"
    },
    {
      "indent": 7,
      "text": "All remaining changes are identified by their section number in the previous draft. With the removal of Section 6, the section numbers are decremented by one.",
      "ja": "残りのすべての変更は、以前のドラフトでのセクション番号で識別されます。第6節の除去と、セクション番号が1ずつ減少しています。"
    },
    {
      "indent": 4,
      "text": "- Section 7.3.7: the calls to malloc() in all three examples should be calls to inet6_option_space() instead. The two calls to inet6_option_append() in the third example should be calls to inet6_option_alloc(). The two calls to CMSG_SPACE() in the first and third examples should be calls to CMSG_LEN(). The second call to CMSG_SPACE() in the second example should be a call to CMSG_LEN().",
      "ja": " - セクション7.3.7：すべての3つの例ではmalloc（）への呼び出しではなく）（呼び出しがinet6_option_spaceしなければなりません。第三の例でinet6_option_appendするための2つの呼び出しは、（））（inet6_option_allocへの呼び出しであるべきです。第一及び第三の実施例におけるCMSG_SPACEへの2つの呼び出しは（））（CMSG_LENへの呼び出しであるべきです。第二の例でCMSG_SPACEに2回目の呼び出しは、（）CMSG_LENへの呼び出しであるべきです（）。"
    },
    {
      "indent": 4,
      "text": "- Section 7.3.7: All the opt_X_ and opt_Y_ structure member names were changed to be ip6_X_opt_ and ip6_Y_opt_. The two structure names ipv6_opt_X and ipv6_opt_Y were changed to ip6_X_opt and ip6_Y_opt. The constants beginning with IPV6_OPT_X_ and IPV6_OPT_Y_ were changed to begin with IP6_X_OPT_ and IP6_Y_OPT_.",
      "ja": " - セクション7.3.7：すべてopt_X_とopt_Y_構造体メンバ名はip6_X_opt_とip6_Y_opt_に変更されました。 2構造名ipv6_opt_Xとipv6_opt_Yはip6_X_optとip6_Y_optに変更しました。 IPV6_OPT_X_とIPV6_OPT_Y_で始まる定数はIP6_X_OPT_とIP6_Y_OPT_で始まるように変更されました。"
    },
    {
      "indent": 4,
      "text": "- Use the term \"Routing header\" throughout the draft, instead of \"source routing\". Changed the names of the eight inet6_srcrt_XXX() functions in Section 9 to inet6_rthdr_XXX(). Changed the name of the socket option from IPV6_SRCRT to IPV6_RTHDR, and the names of the three IPV6_SRCRT_xxx constants in Section 9 to IPV6_RTHDR_xxx.",
      "ja": " - 代わりに、「ソース・ルーティング」のドラフト全体用語「ルーティングヘッダ」を使用。 inet6_rthdr_XXXに9節で8 inet6_srcrt_XXX（）関数の名前を変更しました（）。 IPV6_RTHDRへIPV6_SRCRTからソケットオプション、およびIPV6_RTHDR_xxxに第9節で3つのIPV6_SRCRT_xxx定数の名前の名前を変更しました。"
    },
    {
      "indent": 4,
      "text": "- Added a paragraph to Section 9 on how to receive and send a Routing header.",
      "ja": " - ルーティングヘッダを受信して​​送信する方法については、セクション9に段落を追加しました。"
    },
    {
      "indent": 4,
      "text": "- Changed inet6_rthdr_add() and inet6_rthdr_reverse() so that they return -1 upon an error, instead of an Exxx errno value.",
      "ja": " - 彼らが返すよう-1エラー時に、代わりExxxのerrno値の（inet6_rthdr_add変更）とinet6_rthdr_reverse（）。"
    },
    {
      "indent": 4,
      "text": "- In the description of inet6_rthdr_space() in Section 9.1, added the qualifier \"For an IPv6 Type 0 Routing header\" to the restriction of between 1 and 23 segments.",
      "ja": " - セクション9.1でinet6_rthdr_space（）の説明では、1〜23のセグメントの制限への「IPv6タイプ0ルーティングヘッダの」修飾子を追加しました。"
    },
    {
      "indent": 4,
      "text": "- Refer to final function argument in Sections 9.7 and 9.8 as index, not offset.",
      "ja": " - セクション指標として9.7と9.8の最後の関数の引数を参照して、オフセットしていません。"
    },
    {
      "indent": 4,
      "text": "- Updated Section 14 with new names from Section 2.",
      "ja": " - 第2節から新しい名前で、セクション14を更新しました。"
    },
    {
      "indent": 4,
      "text": "- Changed the References from \"[n]\" to \"[RFC-abcd]\".",
      "ja": " - に \"[RFC-ABCD]\" \"[N]\" からの参照を変更しました。"
    },
    {
      "indent": 3,
      "text": "Changes from the February 1997 Edition (-01 draft)",
      "ja": "1997年2月版からの変更点（-01案）"
    },
    {
      "indent": 4,
      "text": "- Changed the name of the ip6hdr structure to ip6_hdr (Section 2.1) for consistency with the icmp6hdr structure. Also changed the name of the ip6hdrctl structure contained within the ip6_hdr structure to ip6_hdrctl (Section 2.1). Finally, changed the name of the icmp6hdr structure to icmp6_hdr (Section 2.2). All other occurrences of this structure name, within the Neighbor Discovery structures in Section 2.2.1, already contained the underscore.",
      "ja": " -  icmp6hdr構造との整合性のために（セクション2.1）ip6_hdrするip6hdr構造の名前を変更しました。また、（セクション2.1）ip6_hdrctlするip6_hdr構造内に含まれるip6hdrctl構造の名前を変更しました。最後に、（2.2節）をicmp6_hdrするicmp6hdr構造の名称を変更しました。この構造体名の他のすべての出現は、2.2.1節で近隣探索構造の中に、すでにアンダースコアが含まれていました。"
    },
    {
      "indent": 4,
      "text": "- The \"struct nd_router_solicit\" and \"struct nd_router_advert\" should both begin with \"nd6_\". (Section 2.2.2).",
      "ja": " - 「構造体nd_router_solicit」と「構造体nd_router_advertは」両方「nd6_」で始める必要があります。 （2.2.2項）。"
    },
    {
      "indent": 4,
      "text": "- Changed the name of in6_are_addr_equal to IN6_ARE_ADDR_EQUAL (Section 2.3) for consistency with basic API address testing functions. The header defining this macro is <netinet/in.h>.",
      "ja": " - 基本的なAPIアドレス・テスト機能との整合性を保つためにIN6_ARE_ADDR_EQUAL（2.3節）にin6_are_addr_equalの名前を変更しました。このマクロを定義するヘッダは、<netinetの/ in.h>です。"
    },
    {
      "indent": 4,
      "text": "- getprotobyname(\"ipv6\") now returns 41, not 0 (Section 2.4).",
      "ja": " -  getprotobyname（ \"IPv6は\"）、今ではない0（2.4節）、41を返します。"
    },
    {
      "indent": 4,
      "text": "- The first occurrence of \"struct icmpv6_filter\" in Section 3.2 should be \"struct icmp6_filter\".",
      "ja": " - セクション3.2の「構造体icmpv6_filter」の最初の発生は、「構造体icmp6_filter」でなければなりません。"
    },
    {
      "indent": 4,
      "text": "-  Changed the name of the CMSG_LENGTH() macro to CMSG_LEN()\n   (Section 4.3.5), since LEN is used throughout the <netinet/*.h>",
      "raw": true
    },
    {
      "indent": 7,
      "text": "headers.",
      "ja": "ヘッダ。"
    },
    {
      "indent": 4,
      "text": "- Corrected the argument name for the sample implementations of the CMSG_SPACE() and CMSG_LEN() macros to be \"length\" (Sections 4.3.4 and 4.3.5).",
      "ja": " - 「長さ」（セクション4.3.4および4.3.5）であることをCMSG_SPACE（）とCMSG_LEN（）マクロのサンプルの実装のための引数名を修正しました。"
    },
    {
      "indent": 4,
      "text": "- Corrected the socket option mentioned in Section 5.1 to specify the interface for multicasting from IPV6_ADD_MEMBERSHIP to IPV6_MULTICAST_IF.",
      "ja": " -  IPV6_ADD_MEMBERSHIPからIPV6_MULTICAST_IFにマルチキャストするためのインターフェイスを指定するには、セクション5.1で述べたソケットオプションを修正しました。"
    },
    {
      "indent": 4,
      "text": "- There were numerous errors in the previous draft that specified <netinet/ip6.h> that should have been <netinet/in.h>. These have all been corrected and the locations of all definitions is now summarized in the new Section 14 (\"Summary of New Definitions\").",
      "ja": " - されている必要があります。<netinetの/ ip6.h>指定された前回のドラフト<netinetの/ in.h>には多くの誤りがありました。これらはすべて修正されていると、すべての定義の位置は今、新たな第14条（「新しい定義の概要」）にまとめられています。"
    },
    {
      "indent": 4,
      "text": "Changes from the October 1996 Edition (-00 draft)",
      "ja": "1996年10月版からの変更点（-00案）"
    },
    {
      "indent": 4,
      "text": "- Numerous rationale added using the format (Note: ...).",
      "ja": "（：...注意してください） - 多くの理論的根拠は、形式を使用して追加しました。"
    },
    {
      "indent": 4,
      "text": "- Added note that not all errors may be defined.",
      "ja": " - すべてのエラーを定義することができないノートを追加しました。"
    },
    {
      "indent": 4,
      "text": "- Added note about ICMPv4, IGMPv4, and ARPv4 terminology.",
      "ja": " -  ICMPv4の、IGMPv4、およびARPv4の用語についての注意事項を追加しました。"
    },
    {
      "indent": 4,
      "text": "- Changed the name of <netinet/ip6_icmp.h> to <netinet/icmp6.h>.",
      "ja": " -  <netinetの/ icmp6.h>に<netinetの/ ip6_icmp.h>の名前を変更しました。"
    },
    {
      "indent": 4,
      "text": "- Changed some names in Section 2.2.1: ICMPV6_PKT_TOOBIG to ICMPV6_PACKET_TOOBIG, ICMPV6_TIME_EXCEED to ICMPV6_TIME_EXCEEDED, ICMPV6_ECHORQST to ICMPV6_ECHOREQUEST, ICMPV6_ECHORPLY to ICMPV6_ECHOREPLY, ICMPV6_PARAMPROB_HDR to ICMPV6_PARAMPROB_HEADER, ICMPV6_PARAMPROB_NXT_HDR to ICMPV6_PARAMPROB_NEXTHEADER, and ICMPV6_PARAMPROB_OPTS to ICMPV6_PARAMPROB_OPTION.",
      "ja": "ICMPV6_PARAMPROB_OPTIONにICMPV6_PARAMPROB_NEXTHEADERにICMPV6_PARAMPROB_HEADER、ICMPV6_PARAMPROB_NXT_HDRにICMPV6_ECHOREPLY、ICMPV6_PARAMPROB_HDRにICMPV6_ECHOREQUEST、ICMPV6_ECHORPLYにICMPV6_TIME_EXCEEDED、ICMPV6_ECHORQSTにICMPV6_PACKET_TOOBIG、ICMPV6_TIME_EXCEEDにICMPV6_PKT_TOOBIG、およびICMPV6_PARAMPROB_OPTS： - セクション2.2.1でいくつかの名前を変更しました。"
    },
    {
      "indent": 4,
      "text": "- Prepend the prefix \"icmp6_\" to the three members of the icmp6_dataun union of the icmp6hdr structure (Section 2.2).",
      "ja": " -  icmp6hdr構造（2.2節）のicmp6_dataun組合の三の者に接頭辞「icmp6_」を前に追加します。"
    },
    {
      "indent": 4,
      "text": "- Moved the neighbor discovery definitions into the <netinet/icmp6.h> header, instead of being in their own header (Section 2.2.1).",
      "ja": " - 代わりに独自のヘッダ（セクション2.2.1）であることの、<netinetの/ icmp6.h>ヘッダに近隣探索定義を動かしました。"
    },
    {
      "indent": 4,
      "text": "- Changed Section 2.3 (\"Address Testing\"). The basic macros are now in the basic API.",
      "ja": " - 変更セクション2.3（ \"アドレステスト\"）。基本的なマクロは、基本的なAPIになりました。"
    },
    {
      "indent": 4,
      "text": "- Added the new Section 2.4 on \"Protocols File\".",
      "ja": " - 「プロトコルファイル」に新しいセクション2.4が追加されました。"
    },
    {
      "indent": 4,
      "text": "- Added note to raw sockets description that something like BPF or DLPI must be used to read or write entire IPv6 packets.",
      "ja": " -  BPFやDLPIのようなものが全体のIPv6パケットを読み書きするために使用されなければならないrawソケットの説明にメモを追加しました。"
    },
    {
      "indent": 4,
      "text": "- Corrected example of IPV6_CHECKSUM socket option (Section 3.1). Also defined value of -1 to disable.",
      "ja": " -  IPV6_CHECKSUMソケットオプション（3.1節）の一例を修正しました。また、無効にするには、-1の値を定義しました。"
    },
    {
      "indent": 4,
      "text": "- Noted that <netinet/icmp6.h> defines all the ICMPv6 filtering constants, macros, and structures (Section 3.2).",
      "ja": " -  <netinetの/ icmp6.h>は、すべてのICMPv6フィルタリング定数、マクロ、および構造（セクション3.2）を定義することに留意しました。"
    },
    {
      "indent": 4,
      "text": "- Added note on magic number 10240 for amount of ancillary data (Section 4.1).",
      "ja": " - 補助データの量のためのマジックナンバー10240上の注意事項を追加しました（4.1節）。"
    },
    {
      "indent": 4,
      "text": "- Added possible padding to picture of ancillary data (Section 4.2).",
      "ja": " - 補助データ（セクション4.2）の画像に可能なパディングを追加しました。"
    },
    {
      "indent": 4,
      "text": "- Defined <sys/socket.h> header for CMSG_xxx() functions (Section 4.2).",
      "ja": " - 定義は<sys / socket.h>にCMSG_xxxのヘッダ（）関数（4.2節）。"
    },
    {
      "indent": 4,
      "text": "- Note that the data returned by getsockopt(IPV6_PKTOPTIONS) for a TCP socket is just from the optional headers, if present, of the most recently received segment. Also note that control information is never returned by recvmsg() for a TCP socket.",
      "ja": " - 存在する場合、TCPソケットのためのgetsockopt（IPV6_PKTOPTIONS）によって返されるデータは、最も最近に受信したセグメントを、単にオプションヘッダからであることに留意されたいです。また、制御情報は、TCPソケット用のrecvmsg（）によって返されることはありませんので注意してください。"
    },
    {
      "indent": 4,
      "text": "- Changed header for struct in6_pktinfo from <netinet.in.h> to <netinet/ip6.h> (Section 5).",
      "ja": " -  <netinetの/ ip6.h>（セクション5）に<netinet.in.h>から構造体in6_pktinfoのヘッダを変更しました。"
    },
    {
      "indent": 4,
      "text": "- Removed the old Sections 5.1 and 5.2, because the interface identification functions went into the basic API.",
      "ja": " - インタフェース識別機能は、基本的なAPIに入ったので、古いセクション5.1と5.2を削除しました。"
    },
    {
      "indent": 4,
      "text": "- Redid Section 5 to support the hop limit field.",
      "ja": " - やり直し第5節では、ホップ制限フィールドをサポートします。"
    },
    {
      "indent": 4,
      "text": "- New Section 5.4 (\"Next Hop Address\").",
      "ja": " - 新しいセクション5.4（「ネクストホップアドレス」）。"
    },
    {
      "indent": 4,
      "text": "- New Section 6 (\"Flow Labels\").",
      "ja": " - 新しいセクション6（ \"フローラベル\"）。"
    },
    {
      "indent": 4,
      "text": "- Changed all of Sections 7 and 8 dealing with Hop-by-Hop and Destination options. We now define a set of inet6_option_XXX() functions.",
      "ja": " - セクション7と8のすべてがバイホップホップと宛先オプションを扱う変更しました。私たちは今、inet6_option_XXX（）関数のセットを定義します。"
    },
    {
      "indent": 4,
      "text": "- Changed header for IPV6_SRCRT_xxx constants from <netinet.in.h> to <netinet/ip6.h> (Section 9).",
      "ja": " -  <netinet.in.h>から<netinetの/ ip6.h>にIPV6_SRCRT_xxx定数の変更ヘッダ（項9）。"
    },
    {
      "indent": 4,
      "text": "- Add inet6_rthdr_lasthop() function, and fix errors in description of Routing header (Section 9).",
      "ja": " -  inet6_rthdr_lasthop（）関数を追加し、ヘッダ（セクション9）ルーティングの説明でエラーを修正。"
    },
    {
      "indent": 4,
      "text": "- Reworded some of the Routing header descriptions to conform to the terminology in [RFC-1883].",
      "ja": " -  [RFC-1883]における用語に一致するように、ルーティングヘッダの説明の一部を言い換え。"
    },
    {
      "indent": 4,
      "text": "- Added the example from [RFC-1883] for the Routing header (Section 9.9).",
      "ja": " - ルーティングヘッダ（セクション9.9）のために[RFC-1883]からの例を追加しました。"
    },
    {
      "indent": 4,
      "text": "- Expanded the example in Section 10 to show multiple options per ancillary data object, and to show the receiver's ancillary data objects.",
      "ja": " - 補助データ・オブジェクトごとに複数のオプションを表示し、受信機の補助データオブジェクトを表示する第10の例を拡大しました。"
    },
    {
      "indent": 4,
      "text": "- New Section 11 (\"IPv6-Specific Options with IPv4-Mapped IPv6 Addresses\").",
      "ja": " - 新しいセクション11（「IPv4射影IPv6アドレスとIPv6固有のオプション」）。"
    },
    {
      "indent": 4,
      "text": "- New Section 12 (\"rresvport_af\").",
      "ja": " - 新しいセクション12（ \"rresvport_af\"）。"
    },
    {
      "indent": 4,
      "text": "- Redid old Section 10 (\"Additional Items\") into new Section 13 (\"Future Items\").",
      "ja": " - やり直し古いセクション10の新しいセクション13（「将来のアイテム」）への（「追加アイテム」）。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16.参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC-1883] Deering, S., and R. Hinden, \"Internet Protocol, Version 6 (IPv6), Specification\", RFC 1883, December 1995.",
      "ja": "[RFC-1883]デアリング、S.、およびR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の、仕様\"、RFC 1883、1995年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC-2133] Gilligan, R., Thomson, S., Bound, J., and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 2133, April 1997.",
      "ja": "[RFC-2133]ギリガン、R.、トムソン、S.、バウンド、J.、およびW.スティーブンス、 \"IPv6の基本的なソケットインタフェース拡張\"、RFC 2133、1997年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC-1981] McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, August 1996.",
      "ja": "[RFC-1981]マッキャン、J.、デアリング、S.、およびJ.モーグル、 \"経路MTUディスカバリIPバージョン6\"、RFC 1981、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC-1970] Narten, T., Nordmark, E., and W. Simpson, \"Neighbor Discovery for IP Version 6 (IPv6)\", RFC 1970, August 1996.",
      "ja": "[RFC-1970] Narten氏、T.、Nordmarkと、E.、およびW.シンプソン、 \"IPバージョン6（IPv6）のための近隣探索\"、RFC 1970、1996年8月。"
    },
    {
      "indent": 0,
      "text": "17. Acknowledgments",
      "section_title": true,
      "ja": "17.謝辞"
    },
    {
      "indent": 3,
      "text": "Matt Thomas and Jim Bound have been working on the technical details in this draft for over a year. Keith Sklower is the original implementor of ancillary data in the BSD networking code. Craig Metz provided lots of feedback, suggestions, and comments based on his implementing many of these features as the document was being written.",
      "ja": "バウンドマット・トーマスとジムは一年以上、この草稿で技術的な詳細に取り組んできました。キースSklowerはBSDのネットワークコードにおける補助データの元の実装です。クレイグ・メッツは、文書が書かれていたとして、彼はこれらの機能の多くを実装するに基づいて、フィードバック、提案、コメントの多くを提供します。"
    },
    {
      "indent": 3,
      "text": "The following provided comments on earlier drafts: Pascal Anelli, Hamid Asayesh, Ran Atkinson, Karl Auerbach, Hamid Asayesh, Matt Crawford, Sam T. Denton, Richard Draves, Francis Dupont, Bob Gilligan, Tim Hartrick, Masaki Hirabaru, Yoshinobu Inoue, Mukesh Kacker, A. N. Kuznetsov, Pedro Marques, Jack McCann, der Mouse, John Moy, Thomas Narten, Erik Nordmark, Steve Parker, Charles Perkins, Tom Pusateri, Pedro Roque, Sameer Shah, Peter Sjodin, Stephen P. Spackman, Jinmei Tatuya, Karen Tracey, Quaizar Vohra, Carl Williams, Steve Wise, and Kazu Yamamoto.",
      "ja": "以前のドラフトで次の提供のコメント：パスカルAnelli、ハミドAsayeshは、アトキンソン、カール・アウエルバッハ、ハミドAsayesh、マット・クロフォード、サム・T.デントン、リチャードDraves、フランシスデュポン、ボブギリガン、ティムHartrick、正樹平原、慶喜井上、ムケシュ蘭Kacker、クズネツォフ、ペドロ・マルケス、ジャック・マッキャン、デア・マウス、ジョン・モイ、トーマスNarten氏、エリックNordmarkと、スティーブ・パーカー、チャールズ・パーキンス、トムPusateri、ペドロ・ローク、サミール・シャー、ピーターSjodin、スティーブンP. Spackman、神明達也、カレントレイシー、Quaizar Vohra著、カール・ウィリアムズ、スティーブ・ワイズ、そしてカズ山本。"
    },
    {
      "indent": 0,
      "text": "18. Authors' Addresses",
      "section_title": true,
      "ja": "18.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "W. Richard Stevens 1202 E. Paseo del Zorro Tucson, AZ 85718",
      "ja": "Ｗ。 りちゃｒｄ Ｓてゔぇんｓ １２０２ え。 ぱせお でｌ ぞっろ つｃそん、 あＺ ８５７１８"
    },
    {
      "indent": 3,
      "text": "EMail: rstevens@kohala.com",
      "ja": "メールアドレス：rstevens@kohala.com"
    },
    {
      "indent": 3,
      "text": "Matt Thomas AltaVista Internet Software LJO2-1/J8 30 Porter Rd Littleton, MA 01460 EMail: matt.thomas@altavista-software.com",
      "ja": "マット・トーマスアルタビスタインターネットソフトウェアLJO2-1 / J8 30ポーターRdのリトルトン、MA 01460 Eメール：matt.thomas@altavista-software.com"
    },
    {
      "indent": 0,
      "text": "19. Full Copyright Statement",
      "section_title": true,
      "ja": "19.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    }
  ]
}