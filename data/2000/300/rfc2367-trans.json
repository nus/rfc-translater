{
  "title": {
    "text": "RFC 2367 - PF_KEY Key Management API, Version 2",
    "ja": "RFC 2367 - PF_KEYキー管理API、バージョン2"
  },
  "number": 2367,
  "created_at": "2019-10-23 18:41:22.924454+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       D. McDonald\nRequest for Comments: 2367                                      C. Metz\nCategory: Informational                                         B. Phan\n                                                              July 1998",
      "raw": true
    },
    {
      "indent": 18,
      "text": "PF_KEY Key Management API, Version 2",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "A generic key management API that can be used not only for IP Security [Atk95a] [Atk95b] [Atk95c] but also for other network security services is presented in this document. Version 1 of this API was implemented inside 4.4-Lite BSD as part of the U. S. Naval Research Laboratory's freely distributable and usable IPv6 and IPsec implementation[AMPMC96]. It is documented here for the benefit of others who might also adopt and use the API, thus providing increased portability of key management applications (e.g. a manual keying application, an ISAKMP daemon, a GKMP daemon [HM97a][HM97b], a Photuris daemon, or a SKIP certificate discovery protocol daemon).",
      "ja": "だけでなく、IPセキュリティのために使用することができる一般的な鍵管理APIは、[Atk95a] [Atk95b] [Atk95c]だけでなく、他のネットワーク・セキュリティ・サービスについては、この文書に提示されています。このAPIのバージョン1は、米国海軍研究所の自由に配布し、使用可能なIPv6とIPsecの実装[AMPMC96]の一環として、4.4-LiteのBSDの内側に実装されました。また、このように鍵管理アプリケーションの増加ポータビリティ（例えば手動キー入力アプリケーション、ISAKMPデーモン、GKMPデーモン[HM97a] [HM97b]、Photurisデーモンを提供し、APIを採用し、使用するかもしれない他の人の利益のためにここに文書化されています、またはSKIP証明書発見プロトコルデーモン）。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1      Introduction .............................................  3\n1.1    Terminology ..............................................  3\n1.2    Conceptual Model .........................................  4\n1.3    PF_KEY Socket Definition .................................  8\n1.4    Overview of PF_KEY Messaging Behavior ....................  8\n1.5    Common PF_KEY Operations .................................  9\n1.6    Differences Between PF_KEY and PF_ROUTE .................. 10\n1.7    Name Space ............................................... 11\n1.8    On Manual Keying ..........................................11\n2      PF_KEY Message Format .................................... 11\n2.1    Base Message Header Format ............................... 12\n2.2    Alignment of Headers and Extension Headers ............... 14\n2.3    Additional Message Fields ................................ 14\n2.3.1  Association Extension .................................... 15\n2.3.2  Lifetime Extension ....................................... 16",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2.3.3  Address Extension ........................................ 18\n2.3.4  Key Extension ............................................ 19\n2.3.5  Identity Extension ....................................... 21\n2.3.6  Sensitivity Extension .................................... 21\n2.3.7  Proposal Extension ....................................... 22\n2.3.8  Supported Algorithms Extension ........................... 25\n2.3.9  SPI Range Extension ...................................... 26\n2.4    Illustration of Message Layout ........................... 27\n3      Symbolic Names ........................................... 30\n3.1    Message Types ............................................ 31\n3.1.1  SADB_GETSPI .............................................. 32\n3.1.2  SADB_UPDATE .............................................. 33\n3.1.3  SADB_ADD ................................................. 34\n3.1.4  SADB_DELETE .............................................. 35\n3.1.5  SADB_GET ................................................. 36\n3.1.6  SADB_ACQUIRE ............................................. 36\n3.1.7  SADB_REGISTER ............................................ 38\n3.1.8  SADB_EXPIRE .............................................. 39\n3.1.9  SADB_FLUSH ............................................... 40\n3.1.10 SADB_DUMP ................................................ 40\n3.2    Security Association Flags ............................... 41\n3.3    Security Association States .............................. 41\n3.4    Security Association Types ............................... 41\n3.5    Algorithm Types .......................................... 42\n3.6    Extension Header Values .................................. 43\n3.7    Identity Extension Values ................................ 44\n3.8    Sensitivity Extension Values ............................. 45\n3.9    Proposal Extension Values ................................ 45\n4      Future Directions ........................................ 45\n5      Examples ................................................. 45\n5.1    Simple IP Security Example ............................... 46\n5.2    Proxy IP Security Example ................................ 47\n5.3    OSPF Security Example .................................... 50\n5.4    Miscellaneous ............................................ 50\n6      Security Considerations .................................. 51\n       Acknowledgments ............,............................. 52\n       References ............................................... 52\n       Disclaimer ............................................... 54\n       Authors' Addresses ....................................... 54\nA      Promiscuous Send/Receive Extension ....................... 55\nB      Passive Change Message Extension ......................... 57\nC      Key Management Private Data Extension .................... 58\nD      Sample Header File ....................................... 59\nE      Change Log ............................................... 64\nF      Full Copyright Statement ................................. 68",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1 Introduction",
      "ja": "1はじめに"
    },
    {
      "indent": 3,
      "text": "PF_KEY is a new socket protocol family used by trusted privileged key management applications to communicate with an operating system's key management internals (referred to here as the \"Key Engine\" or the Security Association Database (SADB)). The Key Engine and its structures incorporate the required security attributes for a session and are instances of the \"Security Association\" (SA) concept described in [Atk95a]. The names PF_KEY and Key Engine thus refer to more than cryptographic keys and are retained for consistency with the traditional phrase, \"Key Management\".",
      "ja": "PF_KEYは、（「キーエンジン」やセキュリティアソシエーションデータベース（SADB）とここで呼ばれる）、オペレーティング・システムの鍵管理の内部との通信に信頼され、特権鍵管理アプリケーションで使用される新しいソケットプロトコルファミリです。主エンジンとその構造は、必要なセキュリティは、セッション属性組み込み、[Atk95a]に記載されている「セキュリティアソシエーション」（SA）の概念のインスタンスです。名前PF_KEYとキーエンジンは、このように複数の暗号化キーを参照し、伝統的なフレーズ、「キー管理」との整合性のために保持されています。"
    },
    {
      "indent": 3,
      "text": "PF_KEY is derived in part from the BSD routing socket, PF_ROUTE. [Skl91] This document describes Version 2 of PF_KEY. Version 1 was implemented in the first five alpha test versions of the NRL IPv6+IPsec Software Distribution for 4.4-Lite BSD UNIX and the Cisco ISAKMP/Oakley key management daemon. Version 2 extends and refines this interface. Theoretically, the messages defined in this document could be used in a non-socket context (e.g. between two directly communicating user-level processes), but this document will not discuss in detail such possibilities.",
      "ja": "PF_KEYは、BSDルーティングソケット、PF_ROUTEから部分的に導出されます。 [Skl91]この文書では、PF_KEYのバージョン2を説明します。バージョン1は、4.4-LiteのBSD UNIXおよびCisco ISAKMP / Oakleyのキー管理デーモンのNRLのIPv6 + IPsecのソフトウェア配布の最初の5つのアルファテスト版で実装されました。バージョン2は、このインタフェースを拡張し、洗練します。理論的には、本文書で定義されたメッセージ（例えば2直接通信するユーザーレベルのプロセス間）の非ソケットのコンテキストで使用することができるが、この文書では詳細ような可能性に説明しません。"
    },
    {
      "indent": 3,
      "text": "Security policy is deliberately omitted from this interface. PF_KEY is not a mechanism for tuning systemwide security policy, nor is it intended to enforce any sort of key management policy. The developers of PF_KEY believe that it is important to separate security mechanisms (such as PF_KEY) from security policies. This permits a single mechanism to more easily support multiple policies.",
      "ja": "セキュリティポリシーは、故意にこのインタフェースから省略されています。 PF_KEYは、システム全体のセキュリティポリシーをチューニングするためのメカニズムではありません、またそれが鍵管理方針の任意の並べ替えを強制することを意図しています。 PF_KEYの開発者は、セキュリティポリシーから（例えばPF_KEYなど）のセキュリティメカニズムを分離することが重要であると考えています。これは、より簡単に複数のポリシーをサポートするための単一のメカニズムを許可します。"
    },
    {
      "indent": 0,
      "text": "1.1 Terminology",
      "section_title": true,
      "ja": "1.1用語"
    },
    {
      "indent": 3,
      "text": "Even though this document is not intended to be an actual Internet standard, the words that are used to define the significance of particular features of this interface are usually capitalized. Some of these words, including MUST, MAY, and SHOULD, are detailed in [Bra97].",
      "ja": "この文書は、実際のインターネット標準であることを意図していないにもかかわらず、このインタフェースの特定の機能の重要性を定義するために使用される単語は、通常、資産計上されます。 MUST、MAY、およびSHOULDを含むこれらの言葉のいくつかは、[Bra97]に詳述されています。"
    },
    {
      "indent": 3,
      "text": "- CONFORMANCE and COMPLIANCE",
      "ja": " -  CONFORMANCEとコンプライアンス"
    },
    {
      "indent": 3,
      "text": "Conformance to this specification has the same meaning as compliance to this specification. In either case, the mandatory-to-implement, or MUST, items MUST be fully implemented as specified here. If any mandatory item is not implemented as specified here, that implementation is not conforming and not compliant with this specification.",
      "ja": "この仕様への適合性は、この仕様に準拠したものと同じ意味を持っています。ここで指定されるようにいずれの場合にも、強制的に実装、またはなければならない項目が完全に実施されなければなりません。ここで指定されたすべての必須項目が実装されていない場合は、その実装が適合していないと、この仕様に準拠していません。"
    },
    {
      "indent": 3,
      "text": "This specification also uses many terms that are commonly used in the context of network security. Other documents provide more definitions and background information on these [VK83, HA94, Atk95a]. Two terms deserve special mention:",
      "ja": "また、この仕様は、一般的に、ネットワークセキュリティのコンテキストで使用されている多くの用語を使用しています。他の文書には、より多くの定義とこれらの[VK83、HA94、Atk95a]の背景情報を提供しています。 2つの用語は特別な言及に値します："
    },
    {
      "indent": 3,
      "text": "- (Encryption/Authentication) Algorithm",
      "ja": " - （暗号化/認証）アルゴリズム"
    },
    {
      "indent": 3,
      "text": "For PF_KEY purposes, an algorithm, whether encryption or authentication, is the set of operations performed on a packet to complete authentication or encryption as indicated by the SA type. A PF_KEY algorithm MAY consist of more than one cryptographic algorithm. Another possibility is that the same basic cryptographic algorithm may be applied with different modes of operation or some other implementation difference. These differences, henceforth called _algorithm differentiators_, distinguish between different PF_KEY algorithms, and options to the same algorithm. Algorithm differentiators will often cause fundamentally different security properties.",
      "ja": "PF_KEY目的で、アルゴリズムのための暗号化または認証するかどうか、SAタイプによって示されるように、認証または暗号化を完了するために、パケットに対して実行される動作のセットです。 PF_KEYアルゴリズムは、複数の暗号アルゴリズムから構成されてもよいです。別の可能性は、同じ基本的な暗号化アルゴリズムは、異なる動作モードまたはいくつかの他の実装差を印加することができることです。今後_algorithmのdifferentiators_と呼ばれるこれらの違いは、同じアルゴリズムに異なるPF_KEYアルゴリズム、およびオプションを区別します。アルゴリズムの差別化要因は、多くの場合、根本的に異なるセキュリティプロパティが発生します。"
    },
    {
      "indent": 3,
      "text": "For example, both DES and 3DES use the same cryptographic algorithm, but they are used differently and have different security properties. The triple-application of DES is considered an algorithm differentiator. There are therefore separate PF_KEY algorithms for DES and 3DES. Keyed-MD5 and HMAC-MD5 use the same hash function, but construct their message authentication codes differently. The use of HMAC is an algorithm differentiator. DES-ECB and DES-CBC are the same cryptographic algorithm, but use a different mode. Mode (e.g., chaining vs. code-book) is an algorithm differentiator. Blowfish with a 128-bit key, however, is similar to Blowfish with a 384-bit key, because the algorithm's workings are otherwise the same and therefore the key length is not an algorithm differentiator.",
      "ja": "たとえば、DESおよび3DESの両方が同じ暗号化アルゴリズムを使用しますが、それらは別々に使用され、異なるセキュリティ特性を有しています。 DESのトリプルアプリケーションは、アルゴリズムの差別化要因と考えられています。 DESおよび3DESのための独立したPF_KEYアルゴリズムは、したがって、あります。鍵付き-MD5とHMAC-MD5は、同じハッシュ関数を使用しますが、違った彼らのメッセージ認証コードを構築します。 HMACの使用は、アルゴリズムの差別化です。 DES-ECBとDES-CBCは、同じ暗号アルゴリズムですが、別のモードを使用しています。モード（例えば、コードブック対連鎖する）アルゴリズム微分です。アルゴリズムの働きが他の同一であり、したがって、キーの長さアルゴリズム微分ないため、128ビットの鍵でふぐは、しかし、384ビットの鍵でフグと同様です。"
    },
    {
      "indent": 3,
      "text": "In terms of IP Security, a general rule of thumb is that whatever might be labeled the \"encryption\" part of an ESP transform is probably a PF_KEY encryption algorithm. Whatever might be labelled the \"authentication\" part of an AH or ESP transform is probably a PF_KEY authentication algorithm.",
      "ja": "IPセキュリティの面では、一般的な経験則は、おそらくPF_KEY暗号化アルゴリズムであるESPの「暗号化」の部分が変換ラベル付けされるかもしれないものは何でもということです。 AHまたはESPの「認証」の部分が変換ラベル付けされるかもしれないものは何でも、おそらくPF_KEY認証アルゴリズムです。"
    },
    {
      "indent": 0,
      "text": "1.2 Conceptual Model",
      "section_title": true,
      "ja": "1.2概念モデル"
    },
    {
      "indent": 3,
      "text": "This section describes the conceptual model of an operating system that implements the PF_KEY key management application programming interface. This section is intended to provide background material useful to understand the rest of this document. Presentation of this conceptual model does not constrain a PF_KEY implementation to strictly adhere to the conceptual components discussed in this subsection.",
      "ja": "このセクションでは、PF_KEY鍵管理アプリケーション・プログラミング・インターフェースを実装するオペレーティングシステムの概念モデルを記載しています。このセクションでは、この文書の残りの部分を理解するのに便利なバックグラウンドの材料を提供することを意図しています。この概念モデルのプレゼンテーションは、厳密にこの節で説明する概念の部品に付着するPF_KEY実装を制限しません。"
    },
    {
      "indent": 3,
      "text": "Key management is most commonly implemented in whole or in part at the application layer. For example, the ISAKMP/Oakley, GKMP, and Photuris proposals for IPsec key management are all application-layer protocols. Manual keying is also done at the application layer. Even parts of the SKIP IP-layer keying proposal can be implemented at the application layer. Figure 1 shows the relationship between a Key Management daemon and PF_KEY. Key management daemons use PF_KEY to communicate with the Key Engine and use PF_INET (or PF_INET6 in the case of IPv6) to communicate, via the network, with a remote key management entity.",
      "ja": "鍵管理は、最も一般的にアプリケーション層で全体的または部分的に実装されています。例えば、IPsecの鍵管理のためのISAKMP /オークリー、GKMP、およびPhoturisの提案は、すべてのアプリケーション層のプロトコルがあります。手動キーは、アプリケーション層で行われます。 SKIP IPレイヤのキーイング提案のさえ部分はアプリケーション層で実装することができます。図1は、キー管理デーモンとPF_KEYとの関係を示したものです。鍵管理デーモンは、キーエンジンと通信し、リモート鍵管理エンティティと、ネットワークを介して通信する（IPv6の場合、またはPF_INET6）PF_INETを使用するPF_KEYを使用します。"
    },
    {
      "indent": 3,
      "text": "The \"Key Engine\" or \"Security Association Database (SADB)\" is a logical entity in the kernel that stores, updates, and deletes Security Association data for various security protocols. There are logical interfaces within the kernel (e.g. getassocbyspi(), getassocbysocket()) that security protocols inside the kernel (e.g. IP Security, aka IPsec) use to request and obtain Security Associations.",
      "ja": "「キーエンジン」や「セキュリティアソシエーションデータベース（SADB）は」カーネル店舗、アップデートで論理的なエンティティであり、様々なセキュリティプロトコルのためのセキュリティアソシエーションデータが削除されます。カーネル内の論理インタフェースは、そのカーネル内部のセキュリティプロトコル（例えばIPセキュリティ、別名IPsec）の要求に使用して、セキュリティアソシエーションを取得（getassocbysocket（）は、例えばgetassocbyspi（））があります。"
    },
    {
      "indent": 3,
      "text": "In the case of IPsec, if by policy a particular outbound packet needs processing, then the IPsec implementation requests an appropriate Security Association from the Key Engine via the kernel-internal interface. If the Key Engine has an appropriate SA, it allocates the SA to this session (marking it as used) and returns the SA to the IPsec implementation for use. If the Key Engine has no such SA but a key management application has previously indicated (via a PF_KEY SADB_REGISTER message) that it can obtain such SAs, then the Key Engine requests that such an SA be created (via a PF_KEY SADB_ACQUIRE message). When the key management daemon creates a new SA, it places it into the Key Engine for future use.",
      "ja": "ポリシーによって、特定のアウトバウンドパケットが処理を必要とする場合のIPsecの場合は、その後、IPsec実装は、カーネル内部のインターフェースを介して主エンジンから適切なセキュリティアソシエーションを要求します。主エンジンが適切なSAを持っている場合、それは（使用としてそれをマークする）このセッションにSAを割り当て、使用するIPsec実装にSAを返します。もし主エンジンにはそのようなSAを持っていませんが、鍵管理アプリケーションは、以前にそのようなSAを得ることができること（PF_KEY SADB_REGISTERメッセージを介して）を示しており、[キーエンジンは（PF_KEY SADB_ACQUIREメッセージを介して）、そのようなSAが作成されることを要求します。鍵管理デーモンが新しいSAを作成すると、それは将来の使用のための主要なエンジンにそれを配置します。"
    },
    {
      "indent": 15,
      "text": "      +---------------+\n      |Key Mgmt Daemon|\n      +---------------+\n        |           |\n        |           |\n        |           |                   Applications\n======[PF_KEY]====[PF_INET]==========================\n        |           |                   OS Kernel\n+------------+   +-----------------+\n| Key Engine |   | TCP/IP,         |\n|  or  SADB  |---| including IPsec |\n+------------+   |                 |\n                 +-----------------+\n                        |\n                    +-----------+\n                    | Network   |\n                    | Interface |\n                    +-----------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 1: Relationship of Key Mgmt to PF_KEY",
      "ja": "図1：PF_KEYへの鍵Mgmt（仮想ディスクの管理）の関係"
    },
    {
      "indent": 3,
      "text": "For performance reasons, some security protocols (e.g. IP Security) are usually implemented inside the operating system kernel. Other security protocols (e.g. OSPFv2 Cryptographic Authentication) are implemented in trusted privileged applications outside the kernel. Figure 2 shows a trusted, privileged routing daemon using PF_INET to communicate routing information with a remote routing daemon and using PF_KEY to request, obtain, and delete Security Associations used with a routing protocol.",
      "ja": "パフォーマンス上の理由から、いくつかのセキュリティプロトコル（例えば、IPセキュリティ）は、通常、オペレーティングシステムのカーネル内部に実装されています。他のセキュリティプロトコル（例えば、OSPFv2の暗号化認証）は、カーネル外の信頼された特権アプリケーションに実装されています。図2は、リモートルーティングデーモンとルーティング情報をルーティングプロトコルで使用されるセキュリティアソシエーションを要求し得る、および削除するPF_KEYを使用して通信するPF_INETを使用して、信頼できる、特権ルーティングデーモンを示しています。"
    },
    {
      "indent": 15,
      "text": "      +---------------+\n      |Routing  Daemon|\n      +---------------+\n        |           |\n        |           |\n        |           |                   Applications\n======[PF_KEY]====[PF_INET]==========================\n        |           |                   OS Kernel\n+------------+   +---------+\n| Key Engine |   | TCP/IP  |\n|  or  SADB  |---|         |\n+------------+   +---------+\n                        |\n                    +-----------+\n                    | Network   |\n                    | Interface |\n                    +-----------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 2: Relationship of Trusted Application to PF_KEY",
      "ja": "図2：PF_KEYの信頼できるアプリケーションの関係"
    },
    {
      "indent": 3,
      "text": "When a trusted privileged application is using the Key Engine but implements the security protocol within itself, then operation varies slightly. In this case, the application needing an SA sends a PF_KEY SADB_ACQUIRE message down to the Key Engine, which then either returns an error or sends a similar SADB_ACQUIRE message up to one or more key management applications capable of creating such SAs. As before, the key management daemon stores the SA into the Key Engine. Then, the trusted privileged application uses an SADB_GET message to obtain the SA from the Key Engine.",
      "ja": "信頼された特権アプリケーションがキーEngineを使用しますが、それ自体内のセキュリティプロトコルを実装した場合、操作は多少異なります。この場合には、SAを必要とするアプリケーションは、いずれかのエラーを返すか、そのようなSAを作成することができる1つの以上の鍵管理アプリケーションと同様SADB_ACQUIREメッセージを送信するキーエンジン、までPF_KEY SADB_ACQUIREメッセージを送信します。前と同じように、キー管理デーモンは、キーエンジンにSAを格納します。次に、信頼できる特権アプリケーションがキーEngineからSAを取得するためにSADB_GETメッセージを使用しています。"
    },
    {
      "indent": 3,
      "text": "In some implementations, policy may be implemented in user-space, even though the actual cryptographic processing takes place in the kernel. Such policy communication between the kernel mechanisms and the user-space policy MAY be implemented by PF_KEY extensions, or other such mechanism. This document does not specify such extensions. A PF_KEY implementation specified by the memo does NOT have to support configuring systemwide policy using PF_KEY.",
      "ja": "いくつかの実装では、ポリシーは、実際の暗号処理はカーネルで行われていても、ユーザ空間に実装することができます。カーネルメカニズムとユーザスペースポリシーとの間のこのようなポリシーの通信は、PF_KEY拡張、または他のそのような機構によって実現されてもよいです。この文書では、このような拡張子を指定しません。メモで指定されたPF_KEY実装は、PF_KEYを使用してシステム全体のポリシーの設定をサポートする必要はありません。"
    },
    {
      "indent": 3,
      "text": "Untrusted clients, for example a user's web browser or telnet client, do not need to use PF_KEY. Mechanisms not specified here are used by such untrusted client applications to request security services (e.g. IPsec) from an operating system. For security reasons, only trusted, privileged applications are permitted to open a PF_KEY socket.",
      "ja": "信頼されていないクライアントは、ユーザのWebブラウザやTelnetクライアントを例えば、PF_KEYを使用する必要はありません。ここで指定されていないメカニズムは、オペレーティングシステムからセキュリティ・サービス（例えば、IPsec）を要求するために、このような信頼できないクライアントアプリケーションによって使用されています。セキュリティ上の理由から、信頼できる、特権アプリケーションは、PF_KEYソケットを開くことが許可されています。"
    },
    {
      "indent": 0,
      "text": "1.3 PF_KEY Socket Definition",
      "section_title": true,
      "ja": "1.3 PF_KEYソケットの定義"
    },
    {
      "indent": 3,
      "text": "The PF_KEY protocol family (PF_KEY) symbol is defined in <sys/socket.h> in the same manner that other protocol families are defined. PF_KEY does not use any socket addresses. Applications using PF_KEY MUST NOT depend on the availability of a symbol named AF_KEY, but kernel implementations are encouraged to define that symbol for completeness.",
      "ja": "PF_KEYプロトコルファミリ（PF_KEY）シンボルは他のプロトコルファミリーが定義されているのと同じ方法では<sys / socket.h>に定義されています。 PF_KEYは、任意のソケットアドレスを使用していません。 PF_KEYを使用するアプリケーションはAF_KEYという名前のシンボルの可用性に依存してはなりませんが、カーネルの実装は、完全を期すため、そのシンボルを定義することをお勧めします。"
    },
    {
      "indent": 5,
      "text": "The key management socket is created as follows:",
      "ja": "次のようにキー管理ソケットが作成されます。"
    },
    {
      "indent": 5,
      "text": "#include <sys/types.h> #include <sys/socket.h> #include <net/pfkeyv2.h>",
      "ja": "書式#include <SYS / types.h>にする#include <sysの/ socket.h>にする#include <ネット/ pfkeyv2.h>"
    },
    {
      "indent": 5,
      "text": "int s;\ns = socket(PF_KEY, SOCK_RAW, PF_KEY_V2);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The PF_KEY domain currently supports only the SOCK_RAW socket type. The protocol field MUST be set to PF_KEY_V2, or else EPROTONOSUPPORT will be returned. Only a trusted, privileged process can create a PF_KEY socket. On conventional UNIX systems, a privileged process is a process with an effective userid of zero. On non-MLS proprietary operating systems, the notion of a \"privileged process\" is implementation-defined. On Compartmented Mode Workstations (CMWs) or other systems that claim to provide Multi-Level Security (MLS), a process MUST have the \"key management privilege\" in order to open a PF_KEY socket[DIA]. MLS systems that don't currently have such a specific privilege MUST add that special privilege and enforce it with PF_KEY in order to comply and conform with this specification. Some systems, most notably some popular personal computers, do not have the concept of an unprivileged user. These systems SHOULD take steps to restrict the programs allowed to access the PF_KEY API.",
      "ja": "PF_KEYドメインは現在、SOCK_RAWソケットタイプをサポートしています。プロトコルフィールドはPF_KEY_V2に設定しなければならない、または他のEPROTONOSUPPORTが返されます。唯一の信頼できる、特権プロセスは、PF_KEYソケットを作成することができます。従来のUNIXシステムでは、特権プロセスは、ゼロの有効なユーザーIDを持つプロセスです。非MLS独自のオペレーティングシステムでは、「特権プロセス」の概念は、実装定義です。コンパートメントモードワークステーション（CMWs）またはマルチレベルセキュリティ（MLS）を提供すると主張する他のシステムでは、プロセスは、PF_KEYソケット[DIA]を開くために、「鍵管理権限」を持たなければなりません。現在、このような特定の権限を持っていませんMLSシステムは、その特別な権限を追加し、遵守し、この仕様に準拠するために、PF_KEYでそれを強制しなければなりません。いくつかのシステム、最も注目すべきは、いくつかの人気のパーソナルコンピュータは、権限を持たないユーザーの概念がありません。これらのシステムは、PF_KEY APIにアクセスすることが許可されたプログラムを制限するための措置をとるべきです。"
    },
    {
      "indent": 0,
      "text": "1.4 Overview of PF_KEY Messaging Behavior",
      "section_title": true,
      "ja": "PF_KEYメッセージング動作の概要1.4"
    },
    {
      "indent": 3,
      "text": "A process interacts with the key engine by sending and receiving messages using the PF_KEY socket. Security association information can be inserted into and retrieved from the kernel's security association table using a set of predefined messages. In the normal case, all properly-formed messages sent to the kernel are returned to all open PF_KEY sockets, including the sender. Improperly formed messages will result in errors, and an implementation MUST check for a properly formed message before returning it to the appropriate listeners. Unlike the routing socket, most errors are sent in reply messages, not the errno field when write() or send() fails. PF_KEY message delivery is not guaranteed, especially in cases where kernel or socket buffers are exhausted and messages are dropped.",
      "ja": "プロセスは、PF_KEYソケットを使用してメッセージを送受信することにより、キーエンジンと相互作用します。セキュリティ関連情報が挿入事前に定義されたメッセージのセットを使用してカーネルのセキュリティアソシエーションテーブルから取得することができます。通常の場合には、カーネルに送信されたすべて適切に形成されたメッセージは、送信者を含め、開いているすべてのPF_KEYソケットに返されます。不適切形成されたメッセージは、エラーになります、と実装が適切なリスナーにそれを返す前に適切に形成されたメッセージのためにチェックしなければなりません。書き込み（）または送信（）が失敗したときに、ルーティングソケットとは異なり、ほとんどのエラーは、応答メッセージではないのerrnoフィールドに送信されます。 PF_KEYメッセージの配信は、特にカーネルやソケットバッファが枯渇していると、メッセージが削除されている場合には、保証されません。"
    },
    {
      "indent": 3,
      "text": "Some messages are generated by the operating system to indicate that actions need to be taken, and are not necessarily in response to any message sent down by the user. Such messages are not received by all PF_KEY sockets, but by sockets which have indicated that kernel-originated messages are to be received. These messages are special because of the expected frequency at which they will occur. Also, an implementation may further wish to restrict return messages from the kernel, in cases where not all PF_KEY sockets are in the same trust domain.",
      "ja": "一部のメッセージは、アクションが取られる必要があり、利用者によって下されたすべてのメッセージに応じて必ずしもではないことを示すために、オペレーティング・システムによって生成されます。このようなメッセージは、すべてのPF_KEYソケットで受信されませんが、ソケットにより、カーネル発信メッセージが受信されるべきであることを示しています。これらのメッセージは、なぜならそれらが発生するときの予想される頻度の特別です。また、実装はさらにないすべてのPF_KEYソケットは同じ信頼ドメインにある場合には、カーネルからのリターンメッセージを制限したいことがあります。"
    },
    {
      "indent": 3,
      "text": "Many of the normal BSD socket calls have undefined behavior on PF_KEY sockets. These include: bind(), connect(), socketpair(), accept(), getpeername(), getsockname(), ioctl(), and listen().",
      "ja": "通常のBSDソケット・コールの多くは、PF_KEYソケット上の振る舞いは未定義です。これらには、バインドを（）、接続（）、ソケットペア（）、受け入れる（）、getpeername（）、のgetsockname（）、IOCTL（）、および（）聞きます。"
    },
    {
      "indent": 0,
      "text": "1.5 Common PF_KEY Operations",
      "section_title": true,
      "ja": "1.5共通PF_KEY操作"
    },
    {
      "indent": 3,
      "text": "There are two basic ways to add a new Security Association into the kernel. The simplest is to send a single SADB_ADD message, containing all of the SA information, from the application into the kernel's Key Engine. This approach works particularly well with manual key management, which is required for IPsec, and other security protocols.",
      "ja": "カーネルに新しいセキュリティアソシエーションを追加するには2つの基本的な方法があります。最も簡単なのは、カーネルのキーエンジンにアプリケーションから、SA情報の全てを含む、単一SADB_ADDメッセージを送信することです。このアプローチは、IPsecのために必要とされる手動鍵管理、および他のセキュリティプロトコルに特に適しています。"
    },
    {
      "indent": 3,
      "text": "The second approach to add a new Security Association into the kernel is for the application to first request a Security Parameters Index (SPI) value from the kernel using the SADB_GETSPI message and then send an SADB_UPDATE message with the complete Security Association data. This second approach works well with key management daemons when the SPI values need to be known before the entire Security Association data is known (e.g. so the SPI value can be indicated to the remote end of the key management session).",
      "ja": "カーネルに新しいセキュリティアソシエーションを追加するための第2のアプローチは、最初の要求に適用するための完全なセキュリティアソシエーションデータとSADB_UPDATEメッセージを送信し、その後SADB_GETSPIメッセージを使用し、カーネルからのセキュリティパラメータインデックス（SPI）値です。 SPI値が全体のセキュリティアソシエーションデータが知られる前に（例えばようにSPI値はキー管理セッションのリモートエンドに指示することができる）既知である必要がある場合、この第2のアプローチは、鍵管理デーモンでうまく機能します。"
    },
    {
      "indent": 3,
      "text": "An individual Security Association can be deleted using the SADB_DELETE message. Categories of SAs or the entire kernel SA table can be deleted using the SADB_FLUSH message.",
      "ja": "個々のセキュリティ協会はSADB_DELETEメッセージを使用して削除することができます。 SASまたはカーネル全体のSAテーブルのカテゴリはSADB_FLUSHメッセージを使用して削除することができます。"
    },
    {
      "indent": 3,
      "text": "The SADB_GET message is used by a trusted application-layer process (e.g. routed(8) or gated(8)) to retrieve an SA (e.g. RIP SA or OSPF SA) from the kernel's Key Engine.",
      "ja": "SADB_GETメッセージが信頼できるアプリケーション層プロセスで使用されている（例えば、ルーティングされた（8）または（8）ゲートされた）カーネルのキーエンジンからSA（例えばRIP SAやOSPF SA）を取得します。"
    },
    {
      "indent": 3,
      "text": "The kernel or an application-layer can use the SADB_ACQUIRE message to request that a Security Association be created by some application-layer key management process that has registered with the kernel via an SADB_REGISTER message. This ACQUIRE message will have a sequence number associated with it. This sequence number MUST be used by followup SADB_GETSPI, SADB_UPDATE, and SADB_ADD messages, in order to keep track of which request gets its keying material. The sequence number (described below) is similar to a transaction ID in a remote procedure call.",
      "ja": "カーネルやアプリケーション層は、セキュリティアソシエーションがSADB_REGISTERメッセージを介してカーネルに登録されているいくつかのアプリケーション層の鍵管理プロセスによって作成されることを要求するためにSADB_ACQUIREメッセージを使用することができます。このACQUIREメッセージは、それに関連付けられたシーケンス番号を持つことになります。このシーケンス番号は、要求がその鍵素材を取得しているのを追跡するためには、フォローアップSADB_GETSPI、SADB_UPDATE、およびSADB_ADDメッセージで使用しなければなりません。シーケンス番号（後述）は、リモートプロシージャコールでトランザクションIDと同様です。"
    },
    {
      "indent": 3,
      "text": "The SADB_EXPIRE message is sent from the kernel to key management applications when the \"soft lifetime\" or \"hard lifetime\" of a Security Association has expired. Key management applications should use receipt of a soft lifetime SADB_EXPIRE message as a hint to negotiate a replacement SA so the replacement SA will be ready and in the kernel before it is needed.",
      "ja": "セキュリティアソシエーションの「ソフト寿命」または「ハードライフタイムが」期限が切れたときSADB_EXPIREメッセージは、鍵管理アプリケーションとカーネルから送られます。鍵管理アプリケーションは、それが必要とされる前に、交換用SAの準備ができて、カーネルになりますので、交換用のSAをネゴシエートするヒントとして、ソフト生涯SADB_EXPIREメッセージの受信を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "A SADB_DUMP message is also defined, but this is primarily intended for PF_KEY implementor debugging and is not used in ordinary operation of PF_KEY.",
      "ja": "SADB_DUMPメッセージも定義されているが、これは主にPF_KEYの実装デバッグのために意図されており、PF_KEYの通常の操作では使用されません。"
    },
    {
      "indent": 0,
      "text": "1.6 Differences Between PF_KEY and PF_ROUTE",
      "section_title": true,
      "ja": "PF_KEYとPF_ROUTE間の1.6の違い"
    },
    {
      "indent": 3,
      "text": "The following bullets are points of difference between the routing socket and PF_KEY. Programmers who are used to the routing socket semantics will find some differences in PF_KEY.",
      "ja": "以下の箇条書きは、ルーティングソケットとPF_KEYとの相違点です。ルーティングソケットのセマンティクスに使用されているプログラマは、PF_KEYでいくつかの違いがあります。"
    },
    {
      "indent": 3,
      "text": "* PF_KEY message errors are usually returned in PF_KEY messages instead of causing write() operations to fail and returning the error number in errno. This means that other listeners on a PF_KEY socket can be aware that requests from another process failed, which can be useful for auditing purposes. This also means that applications that fail to read PF_KEY messages cannot do error checking.",
      "ja": "* PF_KEYメッセージエラーは、通常、代わりに失敗する書き込み（）操作引き起こし、errnoにエラー番号を返すPF_KEYメッセージで返されます。これは、PF_KEYソケット上の他のリスナーが監査目的のために有用であることができ、別のプロセスからの要求が失敗したことを知ることができることを意味します。また、これは、PF_KEYメッセージを読み取ることができないアプリケーションがエラーチェックを行うことができないことを意味します。"
    },
    {
      "indent": 5,
      "text": "An implementation MAY return the errors EINVAL, ENOMEM, and ENOBUFS by causing write() operations to fail and returning the error number in errno. This is an optimization for common error cases in which it does not make sense for any other process to receive the error. An application MUST NOT depend on such errors being set by the write() call, but it SHOULD check for such errors, and handle them in an appropriate manner.",
      "ja": "実装は、書き込み（）操作が失敗し、errnoにエラー番号を返すさせることによりエラーEINVAL、ENOMEMとENOBUFSを返すことができます。これは、他のプロセスがエラーを受信することが意味を成さないような一般的なエラーケースの最適化です。アプリケーションは、このようなエラーが書き込み（）呼び出しで設定されているに依存してはなりませんが、それは、このようなエラーをチェックし、適切な方法でそれらを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The entire message isn't always reflected in the reply. A SADB_ADD message is an example of this.",
      "ja": "*メッセージ全体を常に返信には反映されません。 SADB_ADDメッセージは、この一例です。"
    },
    {
      "indent": 3,
      "text": "* The PID is not set by the kernel. The process that originates the message MUST set the sadb_msg_pid to its own PID. If the kernel ORIGINATES a message, it MUST set the sadb_msg_pid to 0. A reply to an original message SHOULD have the pid of the original message. (E.g. the kernel's response to an SADB_ADD SHOULD have its pid set to the pid value of the original SADB_ADD message.)",
      "ja": "* PIDはカーネルによって設定されていません。メッセージを発信するプロセスは、独自のPIDにsadb_msg_pidを設定しなければなりません。カーネルは、メッセージを発信した場合、それは元のメッセージのPIDを有するべきで0元のメッセージに返信するsadb_msg_pidを設定しなければなりません。 （例えばSADB_ADDにカーネルの応答は、元のSADB_ADDメッセージのPID値へのPIDが設定されているべきです。）"
    },
    {
      "indent": 0,
      "text": "1.7 Name Space",
      "section_title": true,
      "ja": "1.7名前空間"
    },
    {
      "indent": 3,
      "text": "All PF_KEYv2 preprocessor symbols and structure definitions are defined as a result of including the header file <net/pfkeyv2.h>. There is exactly one exception to this rule: the symbol \"PF_KEY\" (two exceptions if \"AF_KEY\" is also counted), which is defined as a result of including the header file <sys/socket.h>. All PF_KEYv2 preprocessor symbols start with the prefix \"SADB_\" and all structure names start with \"sadb_\". There are exactly two exceptions to this rule: the symbol \"PF_KEY_V2\" and the symbol \"PFKEYV2_REVISION\".",
      "ja": "全てPF_KEYv2プリプロセッサシンボルと構造の定義は、ヘッダファイル<ネット/ pfkeyv2.h>を含めた結果として定義されます。記号「PF_KEY」（「AF_KEY」はまた、カウントされている場合、2つの例外）、ヘッダファイルは<sys / socket.hに>を含めた結果として定義される。この規則の一つの例外は、正確あります。すべてのPF_KEYv2プリプロセッサシンボルは、接頭辞「SADB_」で始まり、すべての構造体の名前は「sadb_」で始まります。シンボル「PF_KEY_V2」とシンボル「PFKEYV2_REVISION」：このルールには2つの例外が正確にあります。"
    },
    {
      "indent": 3,
      "text": "The symbol \"PFKEYV2_REVISION\" is a date-encoded value not unlike certain values defined by POSIX and X/Open. The current value for PFKEYV2_REVISION is 199806L, where 1998 is the year and 06 is the month.",
      "ja": "記号「PFKEYV2_REVISION」がないPOSIXおよびX / Openで定義された特定の値とは異なり、日付、エンコードされた値です。 PFKEYV2_REVISIONのための電流値は1998年で、06月199806L、です。"
    },
    {
      "indent": 3,
      "text": "Inclusion of the file <net/pfkeyv2.h> MUST NOT define symbols or structures in the PF_KEYv2 name space that are not described in this document without the explicit prior permission of the authors. Any symbols or structures in the PF_KEYv2 name space that are not described in this document MUST start with \"SADB_X_\" or \"sadb_x_\". An implementation that fails to obey these rules IS NOT COMPLIANT WITH THIS SPECIFICATION and MUST NOT make any claim to be. These rules also apply to any files that might be included as a result of including the file <net/pfkeyv2.h>. This rule provides implementors with some assurance that they will not encounter namespace-related surprises.",
      "ja": "ファイルのインクルード</ネットpfkeyv2.h>作者の明示的な事前の許可なしに、本書に記載されていないPF_KEYv2名前空間内のシンボルや構造を定義してはなりません。この文書に記載されていないPF_KEYv2名前空間内の任意のシンボルまたは構造が「SADB_X_」または「sadb_x_」で開始する必要があります。これらのルールに従うことができない実装は、この仕様に準拠していないし、任意の請求があることをしてはなりません。これらのルールは、ファイル<ネット/ pfkeyv2.h>を含めた結果として含まれる可能性のあるすべてのファイルに適用されます。この規則は、彼らは、名前空間関連の驚きに遭遇しないことをいくつかの保証と実装を提供します。"
    },
    {
      "indent": 0,
      "text": "1.8 On Manual Keying",
      "section_title": true,
      "ja": "手動キー入力では1.8"
    },
    {
      "indent": 3,
      "text": "Not unlike the 4.4-Lite BSD PF_ROUTE socket, this interface allows an application full-reign over the security associations in a kernel that implements PF_KEY. A PF_KEY implementation MUST have some sort of manual interface to PF_KEY, which SHOULD allow all of the functionality of the programmatic interface described here.",
      "ja": "4.4-LiteのBSD PF_ROUTEソケットとは異なり、このインタフェースは、PF_KEYを実装し、カーネルにセキュリティアソシエーションを介してアプリケーションのフル治世を可能にするわけではありません。 PF_KEY実装は、ここで説明するプログラムインタフェースのすべての機能を可能にしなければならないPF_KEYへの手動インタフェースのいくつかの並べ替えを持っている必要があります。"
    },
    {
      "indent": 0,
      "text": "2. PF_KEY Message Format",
      "section_title": true,
      "ja": "2. PF_KEYメッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "PF_KEY messages consist of a base header followed by additional data fields, some of which may be optional. The format of the additional data is dependent on the type of message.",
      "ja": "PF_KEYメッセージは任意とすることができるいくつかの追加のデータフィールド、続いて基本ヘッダから成ります。付加データのフォーマットは、メッセージのタイプに依存しています。"
    },
    {
      "indent": 3,
      "text": "PF_KEY messages currently do not mandate any specific ordering for non-network multi-octet fields. Unless otherwise specified (e.g. SPI values), fields MUST be in host-specific byte order.",
      "ja": "PF_KEYメッセージは、現在、非ネットワークマルチオクテットフィールドの任意の特定の順序を強制しません。そうでない場合（例えばSPI値）が指定されない限り、フィールドは、ホスト固有のバイト順でなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.1 Base Message Header Format",
      "section_title": true,
      "ja": "2.1基本メッセージヘッダのフォーマット"
    },
    {
      "indent": 3,
      "text": "PF_KEY messages consist of the base message header followed by security association specific data whose types and lengths are specified by a generic type-length encoding.",
      "ja": "PF_KEYメッセージは、そのタイプと長さジェネリック型レングス符号化で指定されたセキュリティアソシエーションの特定のデータに続く塩基メッセージヘッダから成ります。"
    },
    {
      "indent": 3,
      "text": "This base header is shown below, using POSIX types. The fields are arranged primarily for alignment, and where possible, for reasons of clarity.",
      "ja": "この基本ヘッダは、POSIXタイプを使用して、以下に示されています。フィールドは、位置合わせのために主に配置されており、可能な場合、明確さの理由のためにされています。"
    },
    {
      "indent": 11,
      "text": "struct sadb_msg {\n        uint8_t sadb_msg_version;\n        uint8_t sadb_msg_type;\n        uint8_t sadb_msg_errno;\n        uint8_t sadb_msg_satype;\n        uint16_t sadb_msg_len;\n        uint16_t sadb_msg_reserved;\n        uint32_t sadb_msg_seq;\n        uint32_t sadb_msg_pid;\n};\n/* sizeof(struct sadb_msg) == 16 */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_msg_version The version field of this PF_KEY message. This MUST be set to PF_KEY_V2. If this is not set to PF_KEY_V2, the write() call MAY fail and return EINVAL. Otherwise, the behavior is undetermined, given that the application might not understand the formatting of the messages arriving from the kernel.",
      "ja": "このPF_KEYメッセージのバージョンフィールドをsadb_msg_version。これはPF_KEY_V2に設定しなければなりません。これはPF_KEY_V2に設定されていない場合、書き込み（）の呼び出しは失敗し、EINVALを返してもよいです。そうでなければ、動作は、アプリケーションがカーネルから到着するメッセージのフォーマットを理解していない可能性がありますことを考えると、未定です。"
    },
    {
      "indent": 3,
      "text": "sadb_msg_type Identifies the type of message. The valid message types are described later in this document.",
      "ja": "sadb_msg_typeは、メッセージの種類を識別します。有効なメッセージタイプは、このドキュメントの後半で説明されています。"
    },
    {
      "indent": 3,
      "text": "sadb_msg_errno Should be set to zero by the sender. The responder stores the error code in this field if an error has occurred. This includes the case where the responder is in user space. (e.g. user-space negotiation fails, an errno can be returned.)",
      "ja": "sadb_msg_errnoは、送信者によってゼロに設定されなければなりません。エラーが発生した場合、レスポンダは、このフィールドにエラーコードを格納します。これは、応答者がユーザ空間である場合を含みます。 （例えば、ユーザ空間の交渉は、errnoが返されることができ、失敗します。）"
    },
    {
      "indent": 3,
      "text": "sadb_msg_satype Indicates the type of security association(s). Valid Security Association types are declared in the file <net/pfkeyv2.h>. The current set of Security Association types is enumerated later in this document.",
      "ja": "sadb_msg_satypeは、セキュリティアソシエーション（複数可）のタイプを示します。有効なセキュリティアソシエーションタイプは、ファイル<ネット/ pfkeyv2.h>で宣言されています。セキュリティアソシエーションタイプの現在のセットは、このドキュメントの後半で列挙されています。"
    },
    {
      "indent": 3,
      "text": "sadb_msg_len Contains the total length, in 64-bit words, of all data in the PF_KEY message including the base header length and additional data after the base header, if any. This length includes any padding or extra space that might exist. Unless otherwise stated, all other length fields are also measured in 64-bit words.",
      "ja": "もしあればsadb_msg_lenは、ベースヘッダ長と基本ヘッダの後に追加のデータを含むPF_KEYメッセージ内のすべてのデータを、64ビットワードで、全長を含んでいます。この長さが存在する可能性があります任意の詰め物や余分なスペースが含まれています。特に明記しない限り、他のすべての長さフィールドは、64ビット・ワードで測定されます。"
    },
    {
      "indent": 19,
      "text": "On user to kernel messages, this field MUST be\nverified against the length of the inbound message.\nEMSGSIZE MUST be returned if the verification fails.\nOn kernel to user messages, a size mismatch is most\nlikely the result of the user not providing a large\nenough buffer for the message. In these cases, the\nuser application SHOULD drop the message, but it MAY\ntry and extract what information it can out of the\nmessage.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_msg_reserved Reserved value. It MUST be zeroed by the sender. All fields labeled reserved later in the document have the same semantics as this field.",
      "ja": "sadb_msg_reserved予約値。これは、送信者によってゼロにしなければなりません。ドキュメントの後の予約ラベルされたすべてのフィールドは、このフィールドと同じ意味を持っています。"
    },
    {
      "indent": 3,
      "text": "sadb_msg_seq Contains the sequence number of this message. This field, along with sadb_msg_pid, MUST be used to uniquely identify requests to a process. The sender is responsible for filling in this field. This responsibility also includes matching the sadb_msg_seq of a request (e.g. SADB_ACQUIRE).",
      "ja": "sadb_msg_seqは、このメッセージのシーケンス番号が含まれています。このフィールドは、sadb_msg_pidと共に、一意のプロセスへの要求を識別するために使用されなければなりません。送信者は、このフィールドに記入する責任があります。この責任はまた、要求（例えばSADB_ACQUIRE）のsadb_msg_seqに一致含みます。"
    },
    {
      "indent": 19,
      "text": "This field is similar to a transaction ID in a\nremote procedure call implementation.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_msg_pid Identifies the process which originated this message, or which process a message is bound for. For example, if process id 2112 sends an SADB_UPDATE message to the kernel, the process MUST set this field to 2112 and the kernel will set this field to 2112 in its reply to that SADB_UPDATE message. This field, along with sadb_msg_seq, can be used to uniquely identify requests to a process.",
      "ja": "sadb_msg_pidは、このメッセージを発信したプロセスを識別し、又はメッセージがためにバインドされているプロセス。プロセスID 2112は、カーネルにSADB_UPDATEメッセージを送信した場合、プロセスは2112にこのフィールドを設定しなければなりません、そして、カーネルはそのSADB_UPDATEメッセージへの応答として2112年にこのフィールドを設定します。このフィールドは、sadb_msg_seqと共に、一意のプロセスへの要求を識別するために使用することができます。"
    },
    {
      "indent": 19,
      "text": "It is currently assumed that a 32-bit quantity will\nhold an operating system's process ID space.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.2 Alignment of Headers and Extension Headers",
      "section_title": true,
      "ja": "ヘッダーと拡張ヘッダーの2.2アライメント"
    },
    {
      "indent": 3,
      "text": "The base message header is a multiple of 64 bits and fields after it in memory will be 64 bit aligned if the base itself is 64 bit aligned. Some of the subsequent extension headers have 64 bit fields in them, and as a consequence need to be 64 bit aligned in an environment where 64 bit quantities need to be 64 bit aligned.",
      "ja": "ベースメッセージヘッダは、ベース自体が整列さ64ビットである場合、64ビットが整列されるメモリに後の64ビットおよびフィールドの倍数です。その後の拡張ヘッダの一部は、それらの64ビット・フィールドを有し、64ビット量は64ビットで整列される必要がある場合、結果として環境に64ビットを整列する必要があります。"
    },
    {
      "indent": 3,
      "text": "The basic unit of alignment and length in PF_KEY Version 2 is 64 bits. Therefore:",
      "ja": "PF_KEYバージョン2のアライメントおよび長さの基本単位は64ビットです。したがって："
    },
    {
      "indent": 5,
      "text": "* All extension headers, inclusive of the sadb_ext overlay fields, MUST be a multiple of 64 bits long.",
      "ja": "* sadb_extオーバーレイフィールドを含むすべての拡張ヘッダは、64ビット長の倍数でなければなりません。"
    },
    {
      "indent": 5,
      "text": "* All variable length data MUST be padded appropriately such that its length in a message is a multiple of 64 bits.",
      "ja": "*すべての可変長データは、メッセージにその長さが64ビットの倍数であることが適切ようパディングされなければなりません。"
    },
    {
      "indent": 5,
      "text": "* All length fields are, unless otherwise specified, in units of 64 bits.",
      "ja": "特に断りのない限り*すべての長さフィールドは64ビット単位で、です。"
    },
    {
      "indent": 5,
      "text": "* Implementations may safely access quantities of between 8 and 64 bits directly within a message without risk of alignment faults.",
      "ja": "*実装は安全に整列障害のリスクなしに、直接メッセージ内のビット8〜64の量にアクセスすることができます。"
    },
    {
      "indent": 3,
      "text": "All PF_KEYv2 structures are packed and already have all intended padding. Implementations MUST NOT insert any extra fields, including hidden padding, into any structure in this document. This forbids implementations from \"extending\" or \"enhancing\" existing headers without changing the extension header type. As a guard against such insertion of silent padding, each structure in this document is labeled with its size in bytes. The size of these structures in an implementation MUST match the size listed.",
      "ja": "すべてのPF_KEYv2構造が詰め込まれており、すでにすべてのパディングを意図しています。実装は、この文書の任意の構造の中に、隠されたパディングを含む任意の余分なフィールドを、挿入してはなりません。これは、「拡張」又は拡張ヘッダタイプを変更することなく、既存のヘッダーを「増強」の実装を禁止します。サイレントパディングのような挿入に対してガードとして、この文書の各構造は、バイト単位のサイズで標識されています。実装におけるこれらの構造体のサイズが記載されているサイズと一致する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3 Additional Message Fields",
      "section_title": true,
      "ja": "2.3追加のメッセージ・フィールド"
    },
    {
      "indent": 3,
      "text": "The additional data following the base header consists of various length-type-values fields. The first 32-bits are of a constant form:",
      "ja": "基本ヘッダ以下の追加データは、様々な長さタイプ値フィールドから成ります。最初の32ビットは、一定の形式のものです。"
    },
    {
      "indent": 11,
      "text": "struct sadb_ext {\n        uint16_t sadb_ext_len;\n        uint16_t sadb_ext_type;\n};\n/* sizeof(struct sadb_ext) == 4 */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_ext_len Length of the extension header in 64 bit words, inclusive.",
      "ja": "64ビット・ワードに拡張ヘッダの長さをsadb_ext_len、包括。"
    },
    {
      "indent": 3,
      "text": "sadb_ext_type The type of extension header that follows. Values for this field are detailed later. The value zero is reserved.",
      "ja": "以下の拡張ヘッダのタイプをsadb_ext_type。このフィールドの値は、後に詳述されています。ゼロの値は予約されています。"
    },
    {
      "indent": 3,
      "text": "Types of extension headers include: Association, Lifetime(s), Address(s), Key(s), Identity(ies), Sensitivity, Proposal, and Supported. There MUST be only one instance of a extension type in a message. (e.g. Base, Key, Lifetime, Key is forbidden). An EINVAL will be returned if there are duplicate extensions within a message. Implementations MAY enforce ordering of extensions in the order presented in the EXTENSION HEADER VALUES section.",
      "ja": "拡張ヘッダの種類が含まれます：協会、ライフタイム（秒）、住所（s）は、キー（複数可）、アイデンティティ（IES）、感度、提案、およびサポートを。メッセージ中の拡張タイプのインスタンスは1つだけでなければなりません。 （例えば、ベース、キー寿命は、キーが禁止されています）。メッセージ内の重複した機能拡張がある場合、EINVALが返されます。実装は拡張ヘッダVALUESのセクションで提示された順序で拡張子の順序を強制するかもしれません。"
    },
    {
      "indent": 3,
      "text": "If an unknown extension type is encountered, it MUST be ignored. Applications using extension headers not specified in this document MUST be prepared to work around other system components not processing those headers. Likewise, if an application encounters an unknown extension from the kernel, it must be prepared to work around it. Also, a kernel that generates extra extension header types MUST NOT _depend_ on applications also understanding extra extension header types.",
      "ja": "不明な拡張タイプが発生した場合、それを無視しなければなりません。この文書で指定されていない拡張ヘッダを使用するアプリケーションは、これらのヘッダを処理していない他のシステム構成要素を回避するために準備しなければなりません。アプリケーションは、カーネルからの未知の拡張に遭遇した場合同様に、それを回避するために準備する必要があります。また、余分な拡張ヘッダタイプを生成カーネルはまた、余分な拡張ヘッダタイプを理解するアプリケーションに_depend_てはなりません。"
    },
    {
      "indent": 3,
      "text": "All extension definitions include these two fields (len and exttype) because they are instances of a generic extension (not unlike sockaddr_in and sockaddr_in6 are instances of a generic sockaddr). The sadb_ext header MUST NOT ever be present in a message without at least four bytes of extension header data following it, and, therefore, there is no problem with it being only four bytes long.",
      "ja": "彼らは一般的な拡張のインスタンス（ないとは異なり、sockaddr_in構造体とのsockaddr_in6はジェネリックなsockaddrのインスタンスである）であるため、すべての拡張定義は、これらの二つのフィールド（LENとexttype）が含まれます。 sadb_extヘッダは、これまでそれに続く拡張ヘッダデータの少なくとも4バイトせずにメッセージに存在してはならない、そして、したがって、それが唯一の4バイト長であるとの問題はありません。"
    },
    {
      "indent": 3,
      "text": "All extensions documented in this section MUST be implemented by a PF_KEY implementation.",
      "ja": "このセクションに記載のすべての拡張機能は、PF_KEY実装によって実装されなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.3.1 Association Extension",
      "section_title": true,
      "ja": "2.3.1協会拡張"
    },
    {
      "indent": 3,
      "text": "The Association extension specifies data specific to a single security association. The only times this extension is not present is when control messages (e.g. SADB_FLUSH or SADB_REGISTER) are being passed and on the SADB_ACQUIRE message.",
      "ja": "協会の拡張子は、単一のセキュリティアソシエーションに固有のデータを指定します。制御メッセージ（例えばSADB_FLUSH又はSADB_REGISTER）が渡されSADB_ACQUIREメッセージにされている場合、この拡張が存在しないだけの時間です。"
    },
    {
      "indent": 11,
      "text": "struct sadb_sa {\n        uint16_t sadb_sa_len;\n        uint16_t sadb_sa_exttype;\n        uint32_t sadb_sa_spi;\n        uint8_t sadb_sa_replay;\n        uint8_t sadb_sa_state;\n        uint8_t sadb_sa_auth;\n        uint8_t sadb_sa_encrypt;\n        uint32_t sadb_sa_flags;\n};",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* sizeof(struct sadb_sa) == 16 */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_sa_spi The Security Parameters Index value for the security association. Although this is a 32-bit field, some types of security associations might have an SPI or key identifier that is less than 32-bits long. In this case, the smaller value shall be stored in the least significant bits of this field and the unneeded bits shall be zero. This field MUST be in network byte order.",
      "ja": "セキュリティアソシエーションのためのセキュリティパラメータインデックス値をsadb_sa_spi。この32ビットのフィールドであるが、セキュリティアソシエーションのいくつかのタイプは、SPIまたは長い32ビット未満であるキー識別子を持つかもしれません。この場合には、小さい値がこのフィールドの最下位ビットに格納されるものとし、不要なビットはゼロでなければなりません。このフィールドは、ネットワークバイト順でなければなりません。"
    },
    {
      "indent": 3,
      "text": "sadb_sa_replay The size of the replay window, if not zero. If zero, then no replay window is in use.",
      "ja": "ゼロでない場合は、リプレイウィンドウのサイズをsadb_sa_replay。ゼロの場合は、何のリプレイウィンドウが使用されていません。"
    },
    {
      "indent": 3,
      "text": "sadb_sa_state The state of the security association. The currently defined states are described later in this document.",
      "ja": "セキュリティアソシエーションの状態をsadb_sa_state。現在定義されている状態は、このドキュメントの後半で説明されています。"
    },
    {
      "indent": 3,
      "text": "sadb_sa_auth The authentication algorithm to be used with this security association. The valid authentication algorithms are described later in this document. A value of zero means that no authentication is used for this security association.",
      "ja": "このセキュリティアソシエーションで使用する認証アルゴリズムをsadb_sa_auth。有効な認証アルゴリズムは、このドキュメントの後半で説明されています。ゼロという値は認証がこのセキュリティアソシエーションのために使用されないことを意味します。"
    },
    {
      "indent": 3,
      "text": "sadb_sa_encrypt The encryption algorithm to be used with this security association. The valid encryption algorithms are described later in this document. A value of zero means that no encryption is used for this security association.",
      "ja": "このセキュリティアソシエーションで使用される暗号化アルゴリズムをsadb_sa_encrypt。有効な暗号化アルゴリズムは、このドキュメントの後半で説明されています。ゼロの値は、暗号化は、このセキュリティアソシエーションのために使用されていないことを意味します。"
    },
    {
      "indent": 3,
      "text": "sadb_sa_flags A bitmap of options defined for the security association. The currently defined flags are described later in this document.",
      "ja": "セキュリティアソシエーションのために定義されたオプションのビットマップをsadb_sa_flags。現在定義されているフラグは、このドキュメントの後半で説明されています。"
    },
    {
      "indent": 3,
      "text": "The kernel MUST check these values where appropriate. For example, IPsec AH with no authentication algorithm is probably an error.",
      "ja": "適切な場合にカーネルがこれらの値をチェックしなければなりません。例えば、無認証アルゴリズムとのIPsec AHは、おそらくエラーです。"
    },
    {
      "indent": 3,
      "text": "When used with some messages, the values in some fields in this header should be ignored.",
      "ja": "いくつかのメッセージで使用される場合、このヘッダーの一部のフィールドの値は無視されるべきです。"
    },
    {
      "indent": 0,
      "text": "2.3.2 Lifetime Extension",
      "section_title": true,
      "ja": "2.3.2長寿命化"
    },
    {
      "indent": 3,
      "text": "The Lifetime extension specifies one or more lifetime variants for this security association. If no Lifetime extension is present the association has an infinite lifetime. An association SHOULD have a lifetime of some sort associated with it. Lifetime variants come in three varieties, HARD - indicating the hard-limit expiration, SOFT - indicating the soft-limit expiration, and CURRENT - indicating the current state of a given security association. The Lifetime extension looks like:",
      "ja": "寿命延長は、このセキュリティアソシエーションのための一つ以上の寿命変異体を指定します。何の寿命延長が存在しない場合関連は無限の寿命を有します。協会は、それに関連するいくつかの並べ替えの寿命を持つべきである（SHOULD）。寿命変異体は、HARD、3種類に来る - ソフトリミットの有効期限を示す、電流 -   - 指定されたセキュリティアソシエーションの現在の状態を示すSOFTハードリミット有効期限を示します。寿命延長は、次のようになります。"
    },
    {
      "indent": 11,
      "text": "struct sadb_lifetime {\n        uint16_t sadb_lifetime_len;\n        uint16_t sadb_lifetime_exttype;\n        uint32_t sadb_lifetime_allocations;\n        uint64_t sadb_lifetime_bytes;\n        uint64_t sadb_lifetime_addtime;\n        uint64_t sadb_lifetime_usetime;\n};\n/* sizeof(struct sadb_lifetime) == 32 */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_lifetime_allocations For CURRENT, the number of different connections, endpoints, or flows that the association has been allocated towards. For HARD and SOFT, the number of these the association may be allocated towards before it expires. The concept of a connection, flow, or endpoint is system specific.",
      "ja": "電流のsadb_lifetime_allocations、異なる接続の数、エンドポイント、または関連が向かって割り当てられていることを流れます。ハードとソフトのために、これらの関連付けの数は、それが期限切れになる前に向かって割り当てられてもよいです。接続、フロー、またはエンドポイントの概念は、システム固有です。"
    },
    {
      "indent": 3,
      "text": "sadb_lifetime_bytes For CURRENT, how many bytes have been processed using this security association. For HARD and SOFT, the number of bytes that may be processed using this security association before it expires.",
      "ja": "電流のsadb_lifetime_bytes、どのように多くのバイトは、このセキュリティアソシエーションを使用して処理されています。ハードとソフトのために、それが期限切れになる前に、このセキュリティアソシエーションを使用して処理することができるバイトの数。"
    },
    {
      "indent": 3,
      "text": "sadb_lifetime_addtime For CURRENT, the time, in seconds, when the association was created. For HARD and SOFT, the number of seconds after the creation of the association until it expires.",
      "ja": "関連付けが作成されたときに、秒単位で、電流の時間をsadb_lifetime_addtime。 HARDとSOFTのために、関連の作成後の秒数は、それが切れるまで。"
    },
    {
      "indent": 19,
      "text": "For such time fields, it is assumed that 64-bits is\nsufficiently large to hold the POSIX time_t value.\nIf this assumption is wrong, this field will have to\nbe revisited.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_lifetime_usetime For CURRENT, the time, in seconds, when association was first used. For HARD and SOFT, the number of seconds after the first use of the association until it expires.",
      "ja": "アソシエーションが最初に使用された秒単位の電流のsadb_lifetime_usetime、時間、、。 HARDとSOFTのため、協会の最初の使用後の秒数は、それが切れるまで。"
    },
    {
      "indent": 3,
      "text": "The semantics of lifetimes are inclusive-OR, first-to-expire. This means that if values for bytes and time, or multiple times, are passed in, the first of these values to be reached will cause a lifetime expiration.",
      "ja": "寿命のセマンティクスは、包括-OR、最初ツー有効期限が切れています。これは、バイトと時間、または複数回の値は、渡された場合、到達するために、これらの値の最初は生涯有効期限を引き起こすことを意味します。"
    },
    {
      "indent": 0,
      "text": "2.3.3 Address Extension",
      "section_title": true,
      "ja": "2.3.3アドレス拡張"
    },
    {
      "indent": 3,
      "text": "The Address extension specifies one or more addresses that are associated with a security association. Address extensions for both source and destination MUST be present when an Association extension is present. The format of an Address extension is:",
      "ja": "アドレス拡張は、セキュリティアソシエーションに関連付けられている1つ以上のアドレスを指定します。協会の拡張子が存在する場合、ソースと宛先の両方のアドレスの拡張機能が存在しなければなりません。アドレス拡張の形式は次のとおりです。"
    },
    {
      "indent": 11,
      "text": "struct sadb_address {\n        uint16_t sadb_address_len;\n        uint16_t sadb_address_exttype;\n        uint8_t sadb_address_proto;\n        uint8_t sadb_address_prefixlen;\n        uint16_t sadb_address_reserved;\n};\n/* sizeof(struct sadb_address) == 8 */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* followed by some form of struct sockaddr */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sockaddr structure SHOULD conform to the sockaddr structure of the system implementing PF_KEY. If the system has an sa_len field, so SHOULD the sockaddrs in the message. If the system has NO sa_len field, the sockaddrs SHOULD NOT have an sa_len field. All non-address information in the sockaddrs, such as sin_zero for AF_INET sockaddrs, and sin6_flowinfo for AF_INET6 sockaddrs, MUST be zeroed out. The zeroing of ports (e.g. sin_port and sin6_port) MUST be done for all messages except for originating SADB_ACQUIRE messages, which SHOULD fill them in with ports from the relevant TCP or UDP session which generates the ACQUIRE message. If the ports are non-zero, then the sadb_address_proto field, normally zero, MUST be filled in with the transport protocol's number. If the sadb_address_prefixlen is non-zero, then the address has a prefix (often used in KM access control decisions), with length specified in sadb_address_prefixlen. These additional fields may be useful to KM applications.",
      "ja": "sockaddr構造体は、PF_KEYを実装するシステムのsockaddr構造体に準拠すべきです。システムはSA_LENフィールドを持っている、その場合はメッセージでsockaddrs必要があります。システムはNO SA_LENフィールドを持っていない場合は、sockaddrsはSA_LENフィールドを持つべきではありません。このようAF_INETのsockaddrsためsin_zero、およびAF_INET6のsockaddrsのためのsin6_flowinfoとしてsockaddrs、すべての非アドレス情報は、ゼロにしなければなりません。ポート（例えばsin_portは及びsin6_port）のゼロ化は、ACQUIREメッセージを生成し、関連するTCPまたはUDPセッションからポートとそれらを記入すべきであるSADB_ACQUIREメッセージを、発信元を除くすべてのメッセージに対して行われなければなりません。ポートが非ゼロである場合、sadb_address_protoフィールドは、通常0は、トランスポートプロトコルの番号で埋めなければなりません。 sadb_address_prefixlenがゼロでない場合、アドレスはsadb_address_prefixlenで指定した長さと（多くの場合、KMアクセス制御の決定に使用される）の接頭辞を持っています。これらの追加のフィールドは、KMの用​​途に有用である可能性があります。"
    },
    {
      "indent": 3,
      "text": "The SRC and DST addresses for a security association MUST be in the same protocol family and MUST always be present or absent together in a message. The PROXY address MAY be in a different protocol family, and for most security protocols, represents an actual originator of a packet. (For example, the inner-packets's source address in a tunnel.)",
      "ja": "セキュリティアソシエーションのためのSRCとDSTアドレスは、同じプロトコルファミリ内にあり、常にメッセージに一緒に存在するか又は存在してはなりません。 PROXYアドレスが異なるプロトコルファミリでは、ほとんどのセキュリティプロトコルのためであってもよいし、パケットの実際の発信元を表します。 （例えば、トンネル内の内部パケットのソースアドレス）。"
    },
    {
      "indent": 3,
      "text": "The SRC address MUST be a unicast or unspecified (e.g., INADDR_ANY) address. The DST address can be any valid destination address (unicast, multicast, or even broadcast). The PROXY address SHOULD be a unicast address (there are experimental security protocols where PROXY semantics may be different than described above).",
      "ja": "SRCアドレスはユニキャスト又は不特定（例えば、INADDR_ANY）アドレスでなければなりません。 DSTアドレスは、任意の有効な宛先アドレス（ユニキャスト、マルチキャスト、あるいはブロードキャスト）することができます。プロキシアドレスがユニキャストアドレスでなければなりません（PROXYセマンティクスは、上記とは異なる場合があり、実験セキュリティプロトコルが存在します）。"
    },
    {
      "indent": 0,
      "text": "2.3.4 Key Extension",
      "section_title": true,
      "ja": "2.3.4キー拡張"
    },
    {
      "indent": 3,
      "text": "The Key extension specifies one or more keys that are associated with a security association. A Key extension will not always be present with messages, because of security risks. The format of a Key extension is:",
      "ja": "主な拡張機能は、セキュリティアソシエーションに関連付けられている1つ以上のキーを指定します。主な拡張機能は常にあるため、セキュリティリスクの、メッセージでは存在しません。主な拡張機能の形式は次のとおりです。"
    },
    {
      "indent": 11,
      "text": "struct sadb_key {\n        uint16_t sadb_key_len;\n        uint16_t sadb_key_exttype;\n        uint16_t sadb_key_bits;\n        uint16_t sadb_key_reserved;\n};\n/* sizeof(struct sadb_key) == 8 */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* followed by the key data */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_key_bits The length of the valid key data, in bits. A value of zero in sadb_key_bits MUST cause an error.",
      "ja": "ビットで、有効なキーデータの長さをsadb_key_bits。 sadb_key_bitsでゼロの値は、エラーが発生しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The key extension comes in two varieties. The AUTH version is used with authentication keys (e.g. IPsec AH, OSPF MD5) and the ENCRYPT version is used with encryption keys (e.g. IPsec ESP). PF_KEY deals only with fully formed cryptographic keys, not with \"raw key material\". For example, when ISAKMP/Oakley is in use, the key management daemon is always responsible for transforming the result of the Diffie-Hellman computation into distinct fully formed keys PRIOR to sending those keys into the kernel via PF_KEY. This rule is made because PF_KEY is designed to support multiple security protocols (not just IP Security) and also multiple key management schemes including manual keying, which does not have the concept of \"raw key material\". A clean, protocol-independent interface is important for portability to different operating systems as well as for portability to different security protocols.",
      "ja": "キー拡張は2種類で提供されます。 AUTHバージョン（例えばIPsecのAH、OSPF MD5）認証キーと共に使用され、暗号化バージョンは、暗号化キー（例えば、IPsecのESP）と共に使用されます。唯一の「生のキーマテリアル」と完全に形成された暗号化キー、ないとPF_KEY予約。 ISAKMP / Oakleyの使用時、例えば、鍵管理デーモンは常にPF_KEYを介してカーネルにこれらのキーを送信する前に、別個の完全に形成されたキーへのDiffie-Hellman計算の結果を変換する責任があります。 PF_KEYは、「生のキーマテリアル」の概念がありません手動キー入力、などの複数のセキュリティプロトコル（だけでなく、IPセキュリティ）と、複数の鍵管理方式をサポートするように設計されているため、このルールが作られています。きれいな、プロトコルに依存しないインタフェースが異なるオペレーティングシステムへの移植のためだけでなく、異なるセキュリティプロトコルへの移植のために重要です。"
    },
    {
      "indent": 3,
      "text": "If an algorithm defines its key to include parity bits (e.g. DES) then the key used with PF_KEY MUST also include those parity bits. For example, this means that a single DES key is always a 64-bit quantity.",
      "ja": "アルゴリズムは、パリティビット（例えばDES）を含むように、そのキーを定義する場合、PF_KEYで使用される鍵はまた、これらのパリティビットを含まなければなりません。例えば、これは、単一のDESキーは常に64ビット量であることを意味します。"
    },
    {
      "indent": 3,
      "text": "When a particular security protocol only requires one authentication and/or one encryption key, the fully formed key is transmitted using the appropriate key extension. When a particular security protocol requires more than one key for the same function (e.g. Triple-DES using 2 or 3 keys, and asymmetric algorithms), then those two fully formed keys MUST be concatenated together in the order used for outbound packet processing. In the case of multiple keys, the algorithm MUST be able to determine the lengths of the individual keys based on the information provided. The total key length (when combined with knowledge of the algorithm in use) usually provides sufficient information to make this determination.",
      "ja": "特定のセキュリティプロトコルが唯一の認証および/または1つの暗号鍵を必要とする場合、完全に形成されたキーは、適切な鍵拡張を使用して送信されます。特定のセキュリティプロトコルは、複数の（2つのまたは3つのキーを使用して、例えばトリプルDES、および非対称アルゴリズム）は、同じ機能のためのキーを必要とする場合、次いでこれら二つの完全に形成されたキーは、アウトバウンドパケット処理に用いられるために、一緒に連結されなければなりません。複数のキーの場合には、アルゴリズムは、提供された情報に基づいて、個々のキーの長さを決定できなければなりません。 （使用中のアルゴリズムの知識と組み合わせて）、合計キーの長さは、通常、この決意を行うのに十分な情報を提供します。"
    },
    {
      "indent": 3,
      "text": "Keys are always passed through the PF_KEY interface in the order that they are used for outbound packet processing. For inbound processing, the correct order that keys are used might be different from this canonical concatenation order used with the PF_KEY interface. It is the responsibility of the implementation to use the keys in the correct order for both inbound and outbound processing.",
      "ja": "キーは常に彼らは、アウトバウンドパケットの処理に使用されている順序でPF_KEYインタフェースを介して渡されます。インバウンド処理のために、キーが使用されていることを正しい順序は、PF_KEYインタフェースと共に使用されるこの正規連結順序とは異なるかもしれません。インバウンドとアウトバウンドの両方の処理のために正しい順序でキーを使用して、実装の責任です。"
    },
    {
      "indent": 3,
      "text": "For example, consider a pair of nodes communicating unicast using an ESP three-key Triple-DES Security Association. Both the outbound SA on the sender node, and the inbound SA on the receiver node will contain key-A, followed by key-B, followed by key-C in their respective ENCRYPT key extensions. The outbound SA will use key-A first, followed by key-B, then key-C when encrypting. The inbound SA will use key-C, followed by key-B, then key-A when decrypting. (NOTE: We are aware that 3DES is actually encrypt-decrypt-encrypt.) The canonical ordering of key-A, key-B, key-C is used for 3DES, and should be documented. The order of \"encryption\" is the canonical order for this example. [Sch96]",
      "ja": "たとえば、ESP 3キートリプルDESセキュリティアソシエーションを使用して、ユニキャスト通信ノードのペアを考えます。送信ノードに送信SA、およびインバウンドSA両方の受信ノードがそれぞれの暗号鍵拡張にキー-Cに続いて、鍵B、続いてキーAを含有するであろうに。アウトバウンドSAは、キーB、次いで鍵-C暗号化に続く、キー最初に使用します。インバウンドSAを復号する際のキーB、次にキーAに続いてキー-Cを使用します。 （注：私たちは、3DESが実際に暗号化 - 復号化 - 暗号化をしていることを認識している）キーA、キーBの標準的な順序は、キーCが3DESのために使用され、文書化されなければなりません。 「暗号化」の順序は、この例の標準的な順序です。 [Sch96]"
    },
    {
      "indent": 3,
      "text": "The key data bits are arranged most-significant to least significant. For example, a 22-bit key would take up three octets, with the least significant two bits not containing key material. Five additional octets would then be used for padding to the next 64-bit boundary.",
      "ja": "キー・データ・ビットは、最下位の最上位に配置されています。例えば、22ビットの鍵は、鍵材料を含有しない最下位2ビットと、3つのオクテットを取るであろう。 5つの追加オクテットは、次の64ビット境界にパディングのために使用されます。"
    },
    {
      "indent": 3,
      "text": "While not directly related to PF_KEY, there is a user interface issue regarding odd-digit hexadecimal representation of keys. Consider the example of the 16-bit number:",
      "ja": "直接PF_KEYに関連していないが、キーの奇数桁の16進表現に関するユーザインターフェイスの問題があります。 16ビット数の例を考えます。"
    },
    {
      "indent": 11,
      "text": "0x123",
      "ja": "0x123"
    },
    {
      "indent": 3,
      "text": "That will require two octets of storage. In the absence of other information, however, unclear whether the value shown is stored as:",
      "ja": "これは、ストレージの2オクテットが必要になります。他の情報の非存在下で、しかし、示される値は次のように格納されているかどうかは不明。"
    },
    {
      "indent": 11,
      "text": "01 23 OR 12 30",
      "ja": "01 23または12 30"
    },
    {
      "indent": 3,
      "text": "It is the opinion of the authors that the former (0x123 == 0x0123) is the better way to interpret this ambiguity. Extra information (for example, specifying 0x0123 or 0x1230, or specifying that this is only a twelve-bit number) would solve this problem.",
      "ja": "旧（0x123 == 0x0123）は、この曖昧さを解釈するためのより良い方法であると筆者の意見です。追加情報（例えば、0x0123または0x1230を指定し、又はこれが唯一の12ビットの数であることを指定する）は、この問題を解決するだろう。"
    },
    {
      "indent": 0,
      "text": "2.3.5 Identity Extension",
      "section_title": true,
      "ja": "2.3.5アイデンティティ拡張"
    },
    {
      "indent": 3,
      "text": "The Identity extension contains endpoint identities. This information is used by key management to select the identity certificate that is used in negotiations. This information may also be provided by a kernel to network security aware applications to identify the remote entity, possibly for access control purposes. If this extension is not present, key management MUST assume that the addresses in the Address extension are the only identities for this Security Association. The Identity extension looks like:",
      "ja": "アイデンティティの拡張子は、エンドポイントのIDが含まれています。この情報は、交渉に使用されているID証明書を選択するために、鍵管理で使用されています。この情報は、おそらく、アクセス制御の目的のために、リモートエンティティを識別するために、セキュリティ対応アプリケーションをネットワークにカーネルによって提供されてもよいです。この拡張が存在しない場合、鍵管理は、アドレス拡張のアドレスは、このセキュリティアソシエーションのための唯一のアイデンティティがあると仮定しなければなりません。アイデンティティの拡張子は、次のようになります。"
    },
    {
      "indent": 11,
      "text": "struct sadb_ident {\n        uint16_t sadb_ident_len;\n        uint16_t sadb_ident_exttype;\n        uint16_t sadb_ident_type;\n        uint16_t sadb_ident_reserved;\n        uint64_t sadb_ident_id;\n};\n/* sizeof(struct sadb_ident) == 16 */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* followed by the identity string, if present */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_ident_type The type of identity information that follows. Currently defined identity types are described later in this document.",
      "ja": "次のアイデンティティ情報の種類をsadb_ident_type。現在、定義されたアイデンティティのタイプは、このドキュメントの後半で説明されています。"
    },
    {
      "indent": 3,
      "text": "sadb_ident_id An identifier used to aid in the construction of an identity string if none is present. A POSIX user id value is one such identifier that will be used in this field. Use of this field is described later in this document.",
      "ja": "何も存在しない場合は、ID列の構築を支援するために使用される識別子をsadb_ident_id。 POSIXユーザーID値は、この分野で使用されるそのような識別子です。このフィールドの使用は、このドキュメントで後述します。"
    },
    {
      "indent": 3,
      "text": "A C string containing a textual representation of the identity information optionally follows the sadb_ident extension. The format of this string is determined by the value in sadb_ident_type, and is described later in this document.",
      "ja": "識別情報のテキスト表現を含むC文字列は、必要に応じてsadb_ident拡張に従います。この文字列の形式はsadb_ident_typeの値によって決定され、本書で後述します。"
    },
    {
      "indent": 0,
      "text": "2.3.6 Sensitivity Extension",
      "section_title": true,
      "ja": "2.3.6感度拡張"
    },
    {
      "indent": 3,
      "text": "The Sensitivity extension contains security labeling information for a security association. If this extension is not present, no sensitivity-related data can be obtained from this security association. If this extension is present, then the need for explicit security labeling on the packet is obviated.",
      "ja": "感度拡張は、セキュリティアソシエーションのセキュリティラベルの情報が含まれています。この拡張が存在しない場合、感度関連データは、このセキュリティアソシエーションから得ることができません。この拡張が存在する場合、パケットの明示的なセキュリティラベルの必要性が回避されます。"
    },
    {
      "indent": 11,
      "text": "struct sadb_sens {\n        uint16_t sadb_sens_len;\n        uint16_t sadb_sens_exttype;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "        uint32_t sadb_sens_dpd;\n        uint8_t sadb_sens_sens_level;\n        uint8_t sadb_sens_sens_len;\n        uint8_t sadb_sens_integ_level;\n        uint8_t sadb_sens_integ_len;\n        uint32_t sadb_sens_reserved;\n};\n/* sizeof(struct sadb_sens) == 16 */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* followed by:\n        uint64_t sadb_sens_bitmap[sens_len];\n        uint64_t sadb_integ_bitmap[integ_len]; */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_sens_dpd Describes the protection domain, which allows interpretation of the levels and compartment bitmaps. sadb_sens_sens_level The sensitivity level. sadb_sens_sens_len The length, in 64 bit words, of the sensitivity bitmap. sadb_sens_integ_level The integrity level. sadb_sens_integ_len The length, in 64 bit words, of the integrity bitmap.",
      "ja": "sadb_sens_dpdはレベルとコンパートメントビットマップの解釈を可能にする保護ドメインを、説明しています。感度レベルをsadb_sens_sens_level。長sadb_sens_sens_len、64ビット・ワードで、感度マップの。整合性レベルをsadb_sens_integ_level。長さsadb_sens_integ_len、64ビット・ワードで、整合性ビットマップの。"
    },
    {
      "indent": 3,
      "text": "This sensitivity extension is designed to support the Bell-LaPadula [BL74] security model used in compartmented-mode or multi-level secure systems, the Clark-Wilson [CW87] commercial security model, and/or the Biba integrity model [Biba77]. These formal models can be used to implement a wide variety of security policies. The definition of a particular security policy is outside the scope of this document. Each of the bitmaps MUST be padded to a 64-bit boundary if they are not implicitly 64-bit aligned.",
      "ja": "この感度拡張は区画モードまたはマルチレベルのセキュアなシステムで使用されるベル -  LaPadula [BL74]セキュリティモデルをサポートするように設計され、クラーク・ウィルソン[CW87]商用セキュリティモデル、および/またはビバ整合性モデル[Biba77]。これらの形式モデルは、セキュリティポリシーの多種多様を実装するために使用することができます。特定のセキュリティポリシーの定義は、この文書の範囲外です。彼らは暗黙のうち、64ビット整列されていない場合はビットマップは、それぞれ64ビット境界に水増しされなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.3.7 Proposal Extension",
      "section_title": true,
      "ja": "2.3.7提案拡張"
    },
    {
      "indent": 3,
      "text": "The Proposal extension contains a \"proposed situation\" of algorithm preferences. It looks like:",
      "ja": "提案の拡張は、アルゴリズムの好みの「提案された状況」が含まれています。それは次のようになります。"
    },
    {
      "indent": 11,
      "text": "struct sadb_prop {\n        uint16_t sadb_prop_len;\n        uint16_t sadb_prop_exttype;\n        uint8_t sadb_prop_replay;\n        uint8_t sadb_prop_reserved[3];\n};\n/* sizeof(struct sadb_prop) == 8 */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* followed by:\n   struct sadb_comb sadb_combs[(sadb_prop_len *\n       sizeof(uint64_t) - sizeof(struct sadb_prop)) /\n       sizeof(struct sadb_comb)]; */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Following the header is a list of proposed parameter combinations in preferential order. The values in these fields have the same definition as the fields those values will move into if the combination is chosen.",
      "ja": "ヘッダに続いて優先順位に提案パラメータの組み合わせのリストです。これらのフィールドの値は、これらの値は、組み合わせが選択された場合に移動するフィールドと同じ定義を持っています。"
    },
    {
      "indent": 7,
      "text": "NOTE: Some algorithms in some security protocols will have\n      variable IV lengths per algorithm.  Variable length IVs\n      are not supported by PF_KEY v2.  If they were, however,\n      proposed IV lengths would go in the Proposal Extension.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "These combinations look like:",
      "ja": "これらの組み合わせは次のようになります。"
    },
    {
      "indent": 11,
      "text": "struct sadb_comb {\n        uint8_t sadb_comb_auth;\n        uint8_t sadb_comb_encrypt;\n        uint16_t sadb_comb_flags;\n        uint16_t sadb_comb_auth_minbits;\n        uint16_t sadb_comb_auth_maxbits;\n        uint16_t sadb_comb_encrypt_minbits;\n        uint16_t sadb_comb_encrypt_maxbits;\n        uint32_t sadb_comb_reserved;\n        uint32_t sadb_comb_soft_allocations;\n        uint32_t sadb_comb_hard_allocations;\n        uint64_t sadb_comb_soft_bytes;\n        uint64_t sadb_comb_hard_bytes;\n        uint64_t sadb_comb_soft_addtime;\n        uint64_t sadb_comb_hard_addtime;\n        uint64_t sadb_comb_soft_usetime;\n        uint64_t sadb_comb_hard_usetime;\n};",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* sizeof(struct sadb_comb) == 72 */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_comb_auth If this combination is accepted, this will be the value of sadb_sa_auth.",
      "ja": "この組み合わせが受け入れられた場合sadb_comb_auth、これはsadb_sa_authの値になります。"
    },
    {
      "indent": 3,
      "text": "sadb_comb_encrypt If this combination is accepted, this will be the value of sadb_sa_encrypt.",
      "ja": "この組み合わせが受け入れられた場合sadb_comb_encrypt、これはsadb_sa_encryptの値になります。"
    },
    {
      "indent": 3,
      "text": "sadb_comb_auth_minbits;\nsadb_comb_auth_maxbits;\n                The minimum and maximum acceptable authentication\n                key lengths, respectably, in bits. If sadb_comb_auth\n                is zero, both of these values MUST be zero. If\n                sadb_comb_auth is nonzero, both of these values MUST\n                be nonzero. If this combination is accepted, a value\n                between these (inclusive) will be stored in the\n                sadb_key_bits field of KEY_AUTH. The minimum MUST\n                NOT be greater than the maximum.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_comb_encrypt_minbits;\nsadb_comb_encrypt_maxbits;\n                The minimum and maximum acceptable encryption key\n                lengths, respectably, in bits. If sadb_comb_encrypt\n                is zero, both of these values MUST be zero. If\n                sadb_comb_encrypt is nonzero, both of these values\n                MUST be nonzero. If this combination is accepted, a\n                value between these (inclusive) will be stored in\n                the sadb_key_bits field of KEY_ENCRYPT. The minimum\n                MUST NOT be greater than the maximum.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_comb_soft_allocations sadb_comb_hard_allocations If this combination is accepted, these are proposed values of sadb_lifetime_allocations in the SOFT and HARD lifetimes, respectively.",
      "ja": "sadb_comb_soft_allocationsのsadb_comb_hard_allocationsこの組み合わせが受け入れられた場合、これらはそれぞれ、ソフトとハードの寿命にsadb_lifetime_allocationsの値を提案しています。"
    },
    {
      "indent": 3,
      "text": "sadb_comb_soft_bytes sadb_comb_hard_bytes If this combination is accepted, these are proposed values of sadb_lifetime_bytes in the SOFT and HARD lifetimes, respectively.",
      "ja": "この組み合わせが受け入れられた場合sadb_comb_soft_bytes sadb_comb_hard_bytes、これらはそれぞれ、SOFTとHARD寿命でsadb_lifetime_bytesの値を提案しています。"
    },
    {
      "indent": 3,
      "text": "sadb_comb_soft_addtime sadb_comb_hard_addtime If this combination is accepted, these are proposed values of sadb_lifetime_addtime in the SOFT and HARD lifetimes, respectively.",
      "ja": "この組み合わせが受け入れられた場合sadb_comb_soft_addtime sadb_comb_hard_addtime、これらはそれぞれ、ソフトとハードの寿命にsadb_lifetime_addtimeの値を提案しています。"
    },
    {
      "indent": 3,
      "text": "sadb_comb_soft_usetime sadb_comb_hard_usetime If this combination is accepted, these are proposed values of sadb_lifetime_usetime in the SOFT and HARD lifetimes, respectively.",
      "ja": "この組み合わせが受け入れられた場合sadb_comb_soft_usetime sadb_comb_hard_usetime、これらはそれぞれ、ソフトとハードの寿命にsadb_lifetime_usetimeの値を提案しています。"
    },
    {
      "indent": 3,
      "text": "Each combination has an authentication and encryption algorithm, which may be 0, indicating none. A combination's flags are the same as the flags in the Association extension. The minimum and maximum key lengths (which are in bits) are derived from possible a priori policy decisions, along with basic properties of the algorithm. Lifetime attributes are also included in a combination, as some algorithms may know something about their lifetimes and can suggest lifetime limits.",
      "ja": "各組み合わせはどれもないことを示す、0とすることができる認証および暗号化アルゴリズムを有します。組み合わせのフラグは、協会の拡張子のフラグと同じです。最小および最大の鍵の長さを（ビットである）アルゴリズムの基本的な特性とともに、可能先験的ポリシー決定に由来します。いくつかのアルゴリズムが自分の寿命について何かを知っている可能性があり、寿命の限界を提案できるよう生涯属性も、組み合わせに含まれています。"
    },
    {
      "indent": 0,
      "text": "2.3.8 Supported Algorithms Extension",
      "section_title": true,
      "ja": "2.3.8サポートされているアルゴリズムの拡張"
    },
    {
      "indent": 3,
      "text": "The Supported Algorithms extension contains a list of all algorithms supported by the system. This tells key management what algorithms it can negotiate. Available authentication algorithms are listed in the SUPPORTED_AUTH extension and available encryption algorithms are listed in the SUPPORTED_ENCRYPT extension. The format of these extensions is:",
      "ja": "サポートされているアルゴリズムの拡張機能は、システムでサポートされているすべてのアルゴリズムのリストが含まれています。これは、交渉することができますどのようなアルゴリズムの鍵管理に指示します。利用可能な認証アルゴリズムはSUPPORTED_AUTH拡張にリストされ、使用可能な暗号化アルゴリズムはSUPPORTED_ENCRYPT拡張子に記載されています。これらの拡張機能の形式は次のとおりです。"
    },
    {
      "indent": 11,
      "text": "struct sadb_supported {\n        uint16_t sadb_supported_len;\n        uint16_t sadb_supported_exttype;\n        uint32_t sadb_supported_reserved;\n};\n/* sizeof(struct sadb_supported) == 8 */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* followed by:\n   struct sadb_alg sadb_algs[(sadb_supported_len *\n       sizeof(uint64_t) - sizeof(struct sadb_supported)) /\n       sizeof(struct sadb_alg)]; */",
      "raw": true
    },
    {
      "indent": 3,
      "text": " This header is followed by one or more algorithm descriptions. An algorithm description looks like:",
      "ja": "このヘッダは、一つ以上のアルゴリズム記述が続きます。アルゴリズム記述は次のようになります。"
    },
    {
      "indent": 11,
      "text": "struct sadb_alg {\n        uint8_t sadb_alg_id;\n        uint8_t sadb_alg_ivlen;\n        uint16_t sadb_alg_minbits;\n        uint16_t sadb_alg_maxbits;\n        uint16_t sadb_alg_reserved;\n};\n/* sizeof(struct sadb_alg) == 8 */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_alg_id The algorithm identification value for this algorithm. This is the value that is stored in sadb_sa_auth or sadb_sa_encrypt if this algorithm is selected.",
      "ja": "このアルゴリズムのためのアルゴリズムの識別値をsadb_alg_id。これは、このアルゴリズムが選択されている場合sadb_sa_auth又はsadb_sa_encryptに格納された値です。"
    },
    {
      "indent": 3,
      "text": "sadb_alg_ivlen The length of the initialization vector to be used for the algorithm. If an IV is not needed, this value MUST be set to zero.",
      "ja": "アルゴリズムに使用される初期化ベクトルの長さをsadb_alg_ivlen。 IVが必要とされていない場合、この値はゼロに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "sadb_alg_minbits The minimum acceptable key length, in bits. A value of zero is invalid.",
      "ja": "ビットで、最小許容されるキーの長さをsadb_alg_minbits。ゼロの値が無効です。"
    },
    {
      "indent": 3,
      "text": "sadb_alg_maxbits The maximum acceptable key length, in bits. A value of zero is invalid. The minimum MUST NOT be greater than the maximum.",
      "ja": "ビットで、最大許容鍵長をsadb_alg_maxbits。ゼロの値が無効です。最小値は最大値を超えてはなりません。"
    },
    {
      "indent": 0,
      "text": "2.3.9 SPI Range Extension",
      "section_title": true,
      "ja": "2.3.9 SPIレンジ拡張"
    },
    {
      "indent": 3,
      "text": "One PF_KEY message, SADB_GETSPI, might need a range of acceptable SPI values. This extension performs such a function.",
      "ja": "一つPF_KEYメッセージ、SADB_GETSPIは、許容可能なSPI値の範囲を必要とする場合があります。この拡張は、このような機能を実行します。"
    },
    {
      "indent": 11,
      "text": "struct sadb_spirange {\n        uint16_t sadb_spirange_len;\n        uint16_t sadb_spirange_exttype;\n        uint32_t sadb_spirange_min;\n        uint32_t sadb_spirange_max;\n        uint32_t sadb_spirange_reserved;\n};\n/* sizeof(struct sadb_spirange) == 16 */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sadb_spirange_min The minimum acceptable SPI value.",
      "ja": "最小許容SPI値をsadb_spirange_min。"
    },
    {
      "indent": 3,
      "text": "sadb_spirange_max The maximum acceptable SPI value. The maximum MUST be greater than or equal to the minimum.",
      "ja": "最大許容SPI値をsadb_spirange_max。最大値は最小値以上でなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.4 Illustration of Message Layout",
      "section_title": true,
      "ja": "メッセージのレイアウトの2.4イラスト"
    },
    {
      "indent": 3,
      "text": "The following shows how the octets are laid out in a PF_KEY message. Optional fields are indicated as such.",
      "ja": "以下は、オクテットがPF_KEYメッセージ内にレイアウトされている方法を示しています。オプションのフィールドは、このようなとして示されています。"
    },
    {
      "indent": 3,
      "text": "The base header is as follows:",
      "ja": "次のように基本ヘッダです。"
    },
    {
      "indent": 4,
      "text": " 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7\n+---------------+---------------+---------------+---------------+\n|  ...version   | sadb_msg_type | sadb_msg_errno| ...msg_satype |\n+---------------+---------------+---------------+---------------+\n|          sadb_msg_len         |       sadb_msg_reserved       |\n+---------------+---------------+---------------+---------------+\n|                         sadb_msg_seq                          |\n+---------------+---------------+---------------+---------------+\n|                         sadb_msg_pid                          |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The base header may be followed by one or more of the following extension fields, depending on the values of various base header fields. The following fields are ordered such that if they appear, they SHOULD appear in the order presented below.",
      "ja": "基本ヘッダは、様々な基地ヘッダフィールドの値に応じて、以下の拡張フィールドの一つ以上が続いてもよいです。次のフィールドは、彼らが表示された場合、彼らは以下に順番に表示されるようにように命じています。"
    },
    {
      "indent": 3,
      "text": "An extension field MUST not be repeated. If there is a situation where an extension MUST be repeated, it should be brought to the attention of the authors.",
      "ja": "拡張フィールドを繰り返してはいけません。延長が繰り返されなければならない状況がある場合、それは作者の注意を喚起しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Association extension",
      "ja": "協会の拡張子"
    },
    {
      "indent": 7,
      "text": "0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7\n+---------------+---------------+---------------+---------------+\n|          sadb_sa_len          |        sadb_sa_exttype        |\n+---------------+---------------+---------------+---------------+\n|                          sadb_sa_spi                          |\n+---------------+---------------+---------------+---------------+\n|   ...replay   | sadb_sa_state | sadb_sa_auth  |sadb_sa_encrypt|\n+---------------+---------------+---------------+---------------+\n|                         sadb_sa_flags                         |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Lifetime extension",
      "ja": "寿命延長"
    },
    {
      "indent": 7,
      "text": "+---------------+---------------+---------------+---------------+\n|         sadb_lifetime_len     |    sadb_lifetime_exttype      |\n+---------------+---------------+---------------+---------------+\n|                   sadb_lifetime_allocations                   |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "+---------------+---------------+---------------+---------------+\n|                    sadb_lifetime_bytes                        |\n|                           (64 bits)                           |\n+---------------+---------------+---------------+---------------+\n|                    sadb_lifetime_addtime                      |\n|                           (64 bits)                           |\n+---------------+---------------+---------------+---------------+\n|                    sadb_lifetime_usetime                      |\n|                           (64 bits)                           |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Address extension",
      "ja": "アドレス拡張"
    },
    {
      "indent": 7,
      "text": "+---------------+---------------+---------------+---------------+\n|       sadb_address_len        |     sadb_address_exttype      |\n+---------------+---------------+---------------+---------------+\n| _address_proto| ..._prefixlen |     sadb_address_reserved     |\n+---------------+---------------+---------------+---------------+\n>     Some form of 64-bit aligned struct sockaddr goes here.    <\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Key extension",
      "ja": "主な拡張機能"
    },
    {
      "indent": 7,
      "text": "+---------------+---------------+---------------+---------------+\n|         sadb_key_len          |         sadb_key_exttype      |\n+---------------+---------------+---------------+---------------+\n|        sadb_key_bits          |        sadb_key_reserved      |\n+---------------+---------------+---------------+---------------+\n>    A key, padded to 64-bits, most significant bits to least.  >\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Identity extension",
      "ja": "アイデンティティの拡張子"
    },
    {
      "indent": 7,
      "text": "+---------------+---------------+---------------+---------------+\n|        sadb_ident_len         |      sadb_ident_exttype       |\n+---------------+---------------+---------------+---------------+\n|        sadb_ident_type        |      sadb_ident_reserved      |\n+---------------+---------------+---------------+---------------+\n|                         sadb_ident_id                         |\n|                           (64 bits)                           |\n+---------------+---------------+---------------+---------------+\n>  A null-terminated C-string which MUST be padded out for      >\n<  64-bit alignment.                                            <\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Sensitivity extension",
      "ja": "感度拡張"
    },
    {
      "indent": 7,
      "text": "+---------------+---------------+---------------+---------------+\n|         sadb_sens_len         |      sadb_sens_exttype        |\n+---------------+---------------+---------------+---------------+\n|                         sadb_sens_dpd                         |\n+---------------+---------------+---------------+---------------+\n| ...sens_level | ...sens_len   |..._integ_level| ..integ_len   |\n+---------------+---------------+---------------+---------------+\n|                       sadb_sens_reserved                      |\n+---------------+---------------+---------------+---------------+\n>    The sensitivity bitmap, followed immediately by the        <\n<    integrity bitmap, each is an array of uint64_t.            >\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Proposal extension",
      "ja": "提案延長"
    },
    {
      "indent": 7,
      "text": "+---------------+---------------+---------------+---------------+\n|         sadb_prop_len         |       sadb_prop_exttype       |\n+---------------+---------------+---------------+---------------+\n|...prop_replay |           sadb_prop_reserved                  |\n+---------------+---------------+---------------+---------------+\n>     One or more combinations, specified as follows...         <\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Combination\n+---------------+---------------+---------------+---------------+\n|sadb_comb_auth |sadb_comb_encr |        sadb_comb_flags        |\n+---------------+---------------+---------------+---------------+\n|    sadb_comb_auth_minbits     |     sadb_comb_auth_maxbits    |\n+---------------+---------------+---------------+---------------+\n|   sadb_comb_encrypt_minbits   |    sadb_comb_encrypt_maxbits  |\n+---------------+---------------+---------------+---------------+\n|                       sadb_comb_reserved                      |\n+---------------+---------------+---------------+---------------+\n|                   sadb_comb_soft_allocations                  |\n+---------------+---------------+---------------+---------------+\n|                   sadb_comb_hard_allocations                  |\n+---------------+---------------+---------------+---------------+\n|                      sadb_comb_soft_bytes                     |\n|                           (64 bits)                           |\n+---------------+---------------+---------------+---------------+\n|                      sadb_comb_hard_bytes                     |\n|                           (64 bits)                           |\n+---------------+---------------+---------------+---------------+\n|                     sadb_comb_soft_addtime                    |\n|                           (64 bits)                           |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "+---------------+---------------+---------------+---------------+\n|                     sadb_comb_hard_addtime                    |\n|                           (64 bits)                           |\n+---------------+---------------+---------------+---------------+\n|                     sadb_comb_soft_usetime                    |\n|                           (64 bits)                           |\n+---------------+---------------+---------------+---------------+\n|                     sadb_comb_hard_usetime                    |\n|                           (64 bits)                           |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Supported Algorithms extension",
      "ja": "サポートされているアルゴリズムの拡張"
    },
    {
      "indent": 7,
      "text": "+---------------+---------------+---------------+---------------+\n|      sadb_supported_len       |     sadb_supported_exttype    |\n+---------------+---------------+---------------+---------------+\n|                    sadb_supported_reserved                    |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Followed by one or more Algorithm Descriptors",
      "ja": "一つ以上のアルゴリズム記述が続きます"
    },
    {
      "indent": 7,
      "text": "+---------------+---------------+---------------+---------------+\n|  sadb_alg_id  | sadb_alg_ivlen|       sadb_alg_minbits        |\n+---------------+---------------+---------------+---------------+\n|        sadb_alg_maxbits       |       sadb_alg_reserved       |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The SPI Range extension",
      "ja": "SPIレンジ拡張"
    },
    {
      "indent": 7,
      "text": "+---------------+---------------+---------------+---------------+\n|       sadb_spirange_len       |     sadb_spirange_exttype     |\n+---------------+---------------+---------------+---------------+\n|                      sadb_spirange_min                        |\n+---------------+---------------+---------------+---------------+\n|                      sadb_spirange_max                        |\n+---------------+---------------+---------------+---------------+\n|                    sadb_spirange_reserved                     |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3 Symbolic Names",
      "ja": "3シンボリック名"
    },
    {
      "indent": 3,
      "text": "This section defines various symbols used with PF_KEY and the semantics associated with each symbol. Applications MUST use the symbolic names in order to be portable. The numeric definitions shown are for illustrative purposes, unless explicitly stated otherwise. The numeric definition MAY vary on other systems. The symbolic name MUST be kept the same for all conforming implementations.",
      "ja": "このセクションでは、様々なPF_KEYで使用される記号および各シンボルに関連付けられたセマンティクスを定義します。アプリケーションは移植可能にするために、シンボル名を使用しなければなりません。特に明記しない限り、示された数値の定義は、例示的な目的のためのものです。数値の定義は、他のシステムで異なる場合があります。シンボリック名は、すべての適合実装のために同じに保たなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.1 Message Types",
      "section_title": true,
      "ja": "3.1メッセージタイプ"
    },
    {
      "indent": 3,
      "text": "The following message types are used with PF_KEY. These are defined in the file <net/pfkeyv2.h>.",
      "ja": "次のメッセージタイプは、PF_KEYで使用されています。これらは、ファイル<ネット/ pfkeyv2.h>で定義されています。"
    },
    {
      "indent": 11,
      "text": "#define SADB_RESERVED    0\n#define SADB_GETSPI      1\n#define SADB_UPDATE      2\n#define SADB_ADD         3\n#define SADB_DELETE      4\n#define SADB_GET         5\n#define SADB_ACQUIRE     6\n#define SADB_REGISTER    7\n#define SADB_EXPIRE      8\n#define SADB_FLUSH       9",
      "raw": true
    },
    {
      "indent": 11,
      "text": "#define SADB_DUMP        10   /* not used normally */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "#define SADB_MAX 10",
      "ja": "SADB_MAX 10の#define"
    },
    {
      "indent": 3,
      "text": "Each message has a behavior. A behavior is defined as where the initial message travels (e.g. user to kernel), and what subsequent actions are expected to take place. Contents of messages are illustrated as:",
      "ja": "各メッセージには、行動を持っています。動作は、初期メッセージ（例えば、ユーザカーネルへ）移動し、その後のアクションが起こることが予想されるどの場所として定義されます。メッセージの内容は、次のように例示されています。"
    },
    {
      "indent": 3,
      "text": "<base, REQUIRED EXTENSION, REQ., (OPTIONAL EXT.,) (OPT)>",
      "ja": "<塩基、REQUIRED EXTENSION、REQ。、（OPTIONAL EXT。、）（OPT）>"
    },
    {
      "indent": 3,
      "text": "The SA extension is sometimes used only for its SPI field. If all other fields MUST be ignored, this is represented by \"SA(*)\".",
      "ja": "SAの拡張子は時々だけのSPIフィールドに使用されます。他のすべてのフィールドを無視しなければなりません場合は、これは「SA（*）」で表されます。"
    },
    {
      "indent": 3,
      "text": "The lifetime extensions are represented with one to three letters after the word \"lifetime,\" representing (H)ARD, (S)OFT, and (C)URRENT.",
      "ja": "寿命の延長部は、（H）ARD、（S）OFT、及び（C）URRENTを表す単語「寿命」の後に1から3個の文字で表されています。"
    },
    {
      "indent": 3,
      "text": "The address extensions are represented with one to three letters after the word \"address,\" representing (S)RC, (D)ST, (P)ROXY.",
      "ja": "アドレス拡張は、（S）RC、（D）ST、（P）ROXYを示す \"アドレス\" という単語の後に1から3個の文字で表されています。"
    },
    {
      "indent": 7,
      "text": "NOTE: Some security association types do not use a source\n       address for SA identification, where others do.  This may\n       cause EEXIST errors for some SA types where others do not\n       report collisions.  It is expected that application\n       authors know enough about the underlying security\n       association types to understand these differences.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The key extensions are represented with one or two letters after the word \"key,\" representing (A)UTH and (E)NCRYPT.",
      "ja": "鍵拡張は（A）UTH及び（E）NCRYPTを表す言葉「キー、」後に一つまたは二つの文字で表されています。"
    },
    {
      "indent": 3,
      "text": "The identity extensions are represented with one or two letters after the word \"identity,\" representing (S)RC and (D)ST.",
      "ja": "同一の拡張は、ワード（S）RCおよび（D）を表す「同一」ST後に一つまたは二つの文字で表されています。"
    },
    {
      "indent": 3,
      "text": "In the case of an error, only the base header is returned.",
      "ja": "エラーの場合には、唯一の基本ヘッダが返されます。"
    },
    {
      "indent": 3,
      "text": "Note that any standard error could be returned for any message.",
      "ja": "任意の標準誤差は、任意のメッセージを返すことができることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Typically, they will be either one of the errors specifically listed in the description for a message or one of the following:",
      "ja": "典型的には、彼らは、具体的には、メッセージまたは以下のいずれかの説明に記載されているエラーのいずれかであろう。"
    },
    {
      "indent": 11,
      "text": "EINVAL  Various message improprieties, including SPI ranges\n        that are malformed.\nENOMEM  Needed memory was not available.\nENOBUFS Needed memory was not available.\nEMSGSIZ The message exceeds the maximum length allowed.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1.1 SADB_GETSPI",
      "section_title": true,
      "ja": "3.1.1 SADB_GETSPI"
    },
    {
      "indent": 3,
      "text": "The SADB_GETSPI message allows a process to obtain a unique SPI value for given security association type, source address, and destination address. This message followed by an SADB_UPDATE is one way to create a security association (SADB_ADD is the other method). The process specifies the type in the base header, the source and destination address in address extension. If the SADB_GETSPI message is in response to a kernel-generated SADB_ACQUIRE, the sadb_msg_seq MUST be the same as the SADB_ACQUIRE message. The application may also specify the SPI. This is done by having the kernel select within a range of SPI values by using the SPI range extension. To specify a single SPI value to be verified, the application sets the high and low values to be equal. Permitting range specification is important because the kernel can allocate an SPI value based on what it knows about SPI values already in use. The kernel returns the same message with the allocated SPI value stored in the spi field of an association extension. The allocate SPI (and destination address) refer to a LARVAL security association. An SADB_UPDATE message can later be used to add an entry with the requested SPI value.",
      "ja": "SADB_GETSPIメッセージは、プロセスが特定のセキュリティアソシエーションのタイプ、送信元アドレス、宛先アドレスの一意のSPI値を得ることができます。 SADB_UPDATE続いて、このメッセージは、セキュリティアソシエーション（SADB_ADDが他の方法である）を作成する一つの方法です。プロセスは、基本ヘッダ、アドレス拡張の送信元と宛先アドレスタイプを指定します。 SADB_GETSPIメッセージがカーネル生成SADB_ACQUIREに応答する場合、sadb_msg_seqはSADB_ACQUIREメッセージと同じでなければなりません。また、アプリケーションは、SPIを指定することもできます。これは、カーネルは、SPIの範囲の拡張を使用して、SPI値の範囲内で選択させることによって行われます。検証する単一のSPI値を指定するために、アプリケーションは、ハイとローの値が等しくなるように設定します。カーネルは、それがすでに使用中のSPI値を知っているものに基づいてSPI値を割り当てることができますので、範囲指定を許可することが重要です。カーネルは、関連拡張のSPIフィールドに格納された割り当てられたSPI値と同じメッセージを返します。 SPI（宛先アドレス）を割り当てる幼生セキュリティアソシエーションを指します。 SADB_UPDATEメッセージは、後で要求されたSPI値を持つエントリを追加するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "It is recommended that associations that are created with SADB_GETSPI SHOULD be automatically deleted within a fixed amount of time if they are not updated by an SADB_UPDATE message. This allows SA storage not to get cluttered with larval associations.",
      "ja": "それらがSADB_UPDATEメッセージによって更新されない場合SADB_GETSPIで作成された団体は、自動的に一定時間以内に削除することをお勧めします。これは幼虫団体と雑然とを取得しないようにSA格納することができます。"
    },
    {
      "indent": 5,
      "text": "The message behavior of the SADB_GETSPI message is:",
      "ja": "SADB_GETSPIメッセージのメッセージの動作は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "Send an SADB_GETSPI message from a user process to the kernel.",
      "ja": "カーネルにユーザプロセスからSADB_GETSPIメッセージを送信します。"
    },
    {
      "indent": 8,
      "text": "<base, address, SPI range>",
      "ja": "<塩基、アドレス、SPI範囲>"
    },
    {
      "indent": 8,
      "text": "The kernel returns the SADB_GETSPI message to all listening processes.",
      "ja": "カーネルは、すべてのリスニングプロセスにSADB_GETSPIメッセージを返します。"
    },
    {
      "indent": 8,
      "text": "<base, SA(*), address(SD)>",
      "ja": "<ベース、SA（*）、アドレス（SD）>"
    },
    {
      "indent": 5,
      "text": "Errors:",
      "ja": "エラー："
    },
    {
      "indent": 8,
      "text": "EEXIST Requested SPI or SPI range is not available or already used.",
      "ja": "SPIまたはSPIの範囲を要求EEXISTが利用可能であるか、またはすでに使用されていません。"
    },
    {
      "indent": 0,
      "text": "3.1.2 SADB_UPDATE Message",
      "section_title": true,
      "ja": "3.1.2 SADB_UPDATEメッセージ"
    },
    {
      "indent": 3,
      "text": "The SADB_UPDATE message allows a process to update the information in an existing Security Association. Since SADB_GETSPI does not allow setting of certain parameters, this message is needed to fully form the SADB_SASTATE_LARVAL security association created with SADB_GETSPI. The format of the update message is a base header, followed by an association header and possibly by several extension headers. The kernel searches for the security association with the same type, spi, source address and destination address specified in the message and updates the Security Association information using the content of the SADB_UPDATE message.",
      "ja": "SADB_UPDATEメッセージは、プロセスは、既存のセキュリティアソシエーションの情報を更新することができます。 SADB_GETSPIは、特定のパラメータの設定を許可しないので、このメッセージは、完全にSADB_GETSPIで作成SADB_SASTATE_LARVALセキュリティアソシエーションを形成するために必要とされます。更新メッセージのフォーマットは、関連ヘッダが、おそらくいくつかの拡張ヘッダに続く基本ヘッダです。メッセージで指定された同じタイプ、SPI、送信元アドレスと宛先アドレスとのセキュリティアソシエーションのためのカーネルの検索とSADB_UPDATEメッセージの内容を使用してセキュリティアソシエーションの情報が更新されます。"
    },
    {
      "indent": 3,
      "text": "The kernel MAY disallow SADB_UPDATE to succeed unless the message is issued from the same socket that created the security association. Such enforcement significantly reduces the chance of accidental changes to an in-use security association. Malicious trusted parties could still issue an SADB_FLUSH or SADB_DELETE message, but deletion of associations is more easily detected and less likely to occur accidentally than an erroneous SADB_UPDATE. The counter argument to supporting this behavior involves the case where a user-space key management application fails and is restarted. The new instance of the application will not have the same socket as the creator of the security association.",
      "ja": "カーネルは、メッセージがセキュリティアソシエーションを作成したのと同じソケットから発行されていない限り、成功するためにSADB_UPDATEを許可しない場合があります。このような執行が大幅に使用中のセキュリティアソシエーションに誤って変更の可能性を低減します。悪意のある信頼できる当事者は、まだSADB_FLUSHまたはSADB_DELETEメッセージを発行することもできますが、団体の削除は、より容易に検出し、誤ったSADB_UPDATEよりも偶然に起こりにくいです。この動作をサポートするカウンタ引数は、ユーザースペースキー管理アプリケーションに障害が発生し、再起動する場合が含まれます。アプリケーションの新しいインスタンスは、セキュリティアソシエーションの作成者と同じソケットを持っていません。"
    },
    {
      "indent": 3,
      "text": "The kernel MUST sanity check all significant values submitted in an SADB_UPDATE message before changing the SA in its database and MUST return EINVAL if any of the values are invalid. Examples of checks that should be performed are DES key parity bits, key length checking, checks for keys known to be weak for the specified algorithm, and checks for flags or parameters known to be incompatible with the specified algorithm.",
      "ja": "カーネルは、そのデータベースにSAを変更する前にSADB_UPDATEメッセージで送信されたすべての重要な値をチェックしなければなら正気と値のいずれかが無効な場合はEINVALを返さなければなりません。行うべき検査の例は、DES鍵パリティビット、鍵長チェック、指定されたアルゴリズムの弱いことが知られているキーをチェックし、指定されたアルゴリズムと互換性があることが知られているフラグまたはパラメータをチェックしています。"
    },
    {
      "indent": 3,
      "text": "Only SADB_SASTATE_MATURE SAs may be submitted in an SADB_UPDATE message. If the original SA is an SADB_SASTATE_LARVAL SA, then any value in the SA may be changed except for the source address, destination address, and SPI. If the original SA is an SADB_SASTATE_DEAD SA, any attempt to perform an SADB_UPDATE on the SA",
      "ja": "唯一のSADB_SASTATE_MATURE SAはSADB_UPDATEメッセージ内に提出することができます。オリジナルのSAがSADB_SASTATE_LARVAL SAである場合には、SA内の任意の値は、送信元アドレス、宛先アドレス、およびSPIを除いて変更することができます。元SAはSADB_SASTATE_DEAD SA、SAにSADB_UPDATEを実行しようとする場合には"
    },
    {
      "indent": 3,
      "text": "MUST return EINVAL. It is not valid for established keying or algorithm information to change without the SPI changing, which would require creation of a new SA rather than a change to an existing SA. Once keying and algorithm information is negotiated, address and identity information is fixed for the SA. Therefore, if the original SA is an SADB_SASTATE_MATURE or DYING SA, only the sadb_sa_state field in the SA header and lifetimes (hard, soft, and current) may be changed and any attempt to change other values MUST result in an error return of EINVAL.",
      "ja": "EINVALを返さなければなりません。設立キーイングまたはアルゴリズムの情報が新しいSAを作成するのではなく、既存のSAへの変更を必要とするSPIの変化、なしに変更することは有効ではありません。キーイングとアルゴリズム情報が交渉されると、アドレスと身元情報は、SAのために固定されています。オリジナルのSAがSADB_SASTATE_MATUREまたはSAを死にかけている場合したがって、SAヘッダと寿命でのみsadb_sa_stateフィールド（、ハードソフト、および電流）が変更されてもよく、他の値を変更しようとすると、EINVALのエラーリターンをもたらさなければなりません。"
    },
    {
      "indent": 5,
      "text": "The message behavior of the SADB_UPDATE message is:",
      "ja": "SADB_UPDATEメッセージのメッセージの動作は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "Send an SADB_UPDATE message from a user process to the kernel.",
      "ja": "カーネルにユーザプロセスからSADB_UPDATEメッセージを送信します。"
    },
    {
      "indent": 8,
      "text": "<base, SA, (lifetime(HSC),) address(SD), (address(P),) key(AE), (identity(SD),) (sensitivity)>",
      "ja": "<塩基、SA（寿命（HSC）、）アドレス（SD）、（アドレス（P））のキー（AE）、（アイデンティティ（SD））（感度）>"
    },
    {
      "indent": 8,
      "text": "The kernel returns the SADB_UPDATE message to all listening processes.",
      "ja": "カーネルは、すべてのリスニングプロセスにSADB_UPDATEメッセージを返します。"
    },
    {
      "indent": 8,
      "text": "<base, SA, (lifetime(HSC),) address(SD), (address(P),) (identity(SD),) (sensitivity)>",
      "ja": "<塩基、SA（寿命（HSC）、）アドレス（SD）、（アドレス（P））（同一性（SD））（感度）>"
    },
    {
      "indent": 3,
      "text": "The keying material is not returned on the message from the kernel to listening sockets because listeners might not have the privileges to see such keying material.",
      "ja": "リスナーは、このようなキーイング材料を参照する権限を持っていない可能性がありますので、キーイング材料は、リスニングソケットにカーネルからのメッセージに返されません。"
    },
    {
      "indent": 5,
      "text": "Errors: ESRCH The security association to be updated was not found. EINVAL In addition to other possible causes, this error is returned if sanity checking on the SA values (such as the keys) fails. EACCES Insufficient privilege to update entry. The socket issuing the SADB_UPDATE is not creator of the entry to be updated.",
      "ja": "エラー：更新されるセキュリティアソシエーションをESRCHが見つかりませんでした。 （例えばキーなど）SA値にチェック正気が失敗した場合、他の原因に加えてEINVALは、このエラーが返されます。エントリを更新するための十分な権限がなかっEACCES。 SADB_UPDATEを発行ソケットが更新されるエントリの作成者ではありません。"
    },
    {
      "indent": 0,
      "text": "3.1.3 SADB_ADD",
      "section_title": true,
      "ja": "3.1.3 SADB_ADD"
    },
    {
      "indent": 3,
      "text": "The SADB_ADD message is nearly identical to the SADB_UPDATE message, except that it does not require a previous call to SADB_GETSPI. The SADB_ADD message is used in manual keying applications, and in other cases where the uniqueness of the SPI is known immediately.",
      "ja": "SADB_ADDメッセージは、それがSADB_GETSPIに対する前回のコールを必要としないことを除いて、SADB_UPDATEメッセージとほぼ同じです。 SADB_ADDメッセージは、手動キーイング用途において、およびSPIの一意性を即座に知られている他の場合に使用されます。"
    },
    {
      "indent": 3,
      "text": "An SADB_ADD message is also used when negotiation is finished, and the second of a pair of associations is added. The SPI for this association was determined by the peer machine. The sadb_msg_seq",
      "ja": "ネゴシエーションが完了するとSADB_ADDメッセージも使用され、関連の対の第二添加します。この関連付けのためのSPIは、ピア・マシンによって決定しました。 sadb_msg_seq"
    },
    {
      "indent": 3,
      "text": "MUST be set to the value set in a kernel-generated SADB_ACQUIRE so that both associations in a pair are bound to the same ACQUIRE request.",
      "ja": "ペアの両方の関連付けが同じ取得要求に結合されるように、カーネル生成SADB_ACQUIREに設定された値に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The kernel MUST sanity check all used fields in the SA submitted in an SADB_ADD message before adding the SA to its database and MUST return EINVAL if any of the values are invalid.",
      "ja": "カーネルは、そのデータベースにSAを追加する前にSADB_ADDメッセージで提出SA内のすべての使用のフィールドをチェックしなければなら正気と値のいずれかが無効な場合はEINVALを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Only SADB_SASTATE_MATURE SAs may be submitted in an SADB_ADD message. SADB_SASTATE_LARVAL SAs are created by SADB_GETSPI and it is not sensible to add a new SA in the DYING or SADB_SASTATE_DEAD state. Therefore, the sadb_sa_state field of all submitted SAs MUST be SADB_SASTATE_MATURE and the kernel MUST return an error if this is not true.",
      "ja": "唯一のSADB_SASTATE_MATURE SAはSADB_ADDメッセージ内に提出することができます。 SADB_SASTATE_LARVAL SAはSADB_GETSPIによって作成され、DYINGまたはSADB_SASTATE_DEAD状態で新しいSAを追加するために賢明ではありません。したがって、すべてのサブミットSAのsadb_sa_stateフィールドはSADB_SASTATE_MATUREなければならず、これが真でない場合、カーネルはエラーを返さなければなりません。"
    },
    {
      "indent": 5,
      "text": "The message behavior of the SADB_ADD message is:",
      "ja": "SADB_ADDメッセージのメッセージの動作は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "Send an SADB_ADD message from a user process to the kernel.",
      "ja": "カーネルにユーザプロセスからSADB_ADDメッセージを送信します。"
    },
    {
      "indent": 8,
      "text": "<base, SA, (lifetime(HS),) address(SD), (address(P),) key(AE), (identity(SD),) (sensitivity)>",
      "ja": "<塩基、SA（寿命（HS））アドレス（SD）、（アドレス（P））のキー（AE）、（アイデンティティ（SD））（感度）>"
    },
    {
      "indent": 8,
      "text": "The kernel returns the SADB_ADD message to all listening processes.",
      "ja": "カーネルは、すべてのリスニングプロセスにSADB_ADDメッセージを返します。"
    },
    {
      "indent": 8,
      "text": "<base, SA, (lifetime(HS),) address(SD), (identity(SD),) (sensitivity)>",
      "ja": "<塩基、SA（寿命（HS））アドレス（SD）、（アイデンティティ（SD））（感度）>"
    },
    {
      "indent": 3,
      "text": "The keying material is not returned on the message from the kernel to listening sockets because listeners may not have the privileges to see such keying material.",
      "ja": "リスナーは、このようなキーイング材料を参照する権限を持っていない可能性があるため、キーイング材料は、リスニングソケットにカーネルからのメッセージに返されません。"
    },
    {
      "indent": 5,
      "text": "Errors:",
      "ja": "エラー："
    },
    {
      "indent": 8,
      "text": "EEXIST The security association that was to be added already exists. EINVAL In addition to other possible causes, this error is returned if sanity checking on the SA values (such as the keys) fails.",
      "ja": "すでに存在して追加することとしたセキュリティアソシエーションをEEXIST。 （例えばキーなど）SA値にチェック正気が失敗した場合、他の原因に加えてEINVALは、このエラーが返されます。"
    },
    {
      "indent": 0,
      "text": "3.1.4 SADB_DELETE",
      "section_title": true,
      "ja": "3.1.4 SADB_DELETE"
    },
    {
      "indent": 3,
      "text": "The SADB_DELETE message causes the kernel to delete a Security Association from the key table. The delete message consists of the base header followed by the association, and the source and destination sockaddrs in the address extension. The kernel deletes the security association matching the type, spi, source address, and destination address in the message.",
      "ja": "SADB_DELETEメッセージは、キーテーブルからセキュリティアソシエーションを削除するには、カーネルの原因となります。削除メッセージは、関連続いベースヘッダ、アドレス拡張のソースと宛先sockaddrsから成ります。カーネルは、メッセージを入力し、SPI、送信元アドレス、宛先アドレスに一致するセキュリティアソシエーションを削除します。"
    },
    {
      "indent": 5,
      "text": "The message behavior for SADB_DELETE is as follows:",
      "ja": "次のようにSADB_DELETEのメッセージ動作は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "Send an SADB_DELETE message from a user process to the kernel.",
      "ja": "カーネルにユーザプロセスからSADB_DELETEメッセージを送信します。"
    },
    {
      "indent": 8,
      "text": "<base, SA(*), address(SD)>",
      "ja": "<ベース、SA（*）、アドレス（SD）>"
    },
    {
      "indent": 8,
      "text": "The kernel returns the SADB_DELETE message to all listening processes.",
      "ja": "カーネルは、すべてのリスニングプロセスにSADB_DELETEメッセージを返します。"
    },
    {
      "indent": 8,
      "text": "<base, SA(*), address(SD)>",
      "ja": "<ベース、SA（*）、アドレス（SD）>"
    },
    {
      "indent": 0,
      "text": "3.1.5 SADB_GET",
      "section_title": true,
      "ja": "3.1.5 SADB_GET"
    },
    {
      "indent": 3,
      "text": "The SADB_GET message allows a process to retrieve a copy of a Security Association from the kernel's key table. The get message consists of the base header follows by the relevant extension fields. The Security Association matching the type, spi, source address, and destination address is returned.",
      "ja": "SADB_GETメッセージは、プロセスがカーネルのキーテーブルからセキュリティアソシエーションのコピーを取得することができます。 GETメッセージは、基本ヘッダで構成され、関連する拡張フィールドによって続きます。タイプ、SPI、送信元アドレス、宛先アドレスに一致するセキュリティアソシエーションが返されます。"
    },
    {
      "indent": 6,
      "text": "The message behavior of the SADB_GET message is:",
      "ja": "SADB_GETメッセージのメッセージの動作は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "Send an SADB_GET message from a user process to the kernel.",
      "ja": "カーネルにユーザプロセスからSADB_GETメッセージを送信します。"
    },
    {
      "indent": 9,
      "text": "<base, SA(*), address(SD)>",
      "ja": "<ベース、SA（*）、アドレス（SD）>"
    },
    {
      "indent": 9,
      "text": "The kernel returns the SADB_GET message to the socket that sent the SADB_GET message.",
      "ja": "カーネルはSADB_GETメッセージを送信したソケットにSADB_GETメッセージを返します。"
    },
    {
      "indent": 9,
      "text": "<base, SA, (lifetime(HSC),) address(SD), (address(P),) key(AE), (identity(SD),) (sensitivity)>",
      "ja": "<塩基、SA（寿命（HSC）、）アドレス（SD）、（アドレス（P））のキー（AE）、（アイデンティティ（SD））（感度）>"
    },
    {
      "indent": 5,
      "text": "Errors: ESRCH The sought security association was not found.",
      "ja": "エラー：ESRCHザ・セキュリティ協会を求めては見つかりませんでした。"
    },
    {
      "indent": 0,
      "text": "3.1.6 SADB_ACQUIRE",
      "section_title": true,
      "ja": "3.1.6 SADB_ACQUIRE"
    },
    {
      "indent": 3,
      "text": "The SADB_ACQUIRE message is typically sent only by the kernel to key socket listeners who have registered their key socket (see SADB_REGISTER message). SADB_ACQUIRE messages can be sent by application-level consumers of security associations (such as an OSPFv2 implementation that uses OSPF security). The SADB_ACQUIRE message is a base header along with an address extension, possibly an identity extension, and a proposal extension. The proposed situation contains a list of desirable algorithms that can be used if the algorithms in the base header are not available. The values for the fields in the base header and in the security association data which follows the base header indicate the properties of the Security Association that the listening process should attempt to acquire. If the message originates from the kernel (i.e. the sadb_msg_pid is 0), the sadb_msg_seq number MUST be used by a subsequent SADB_GETSPI and SADB_UPDATE, or subsequent SADB_ADD message to bind a security association to the request. This avoids the race condition of two TCP connections between two IP hosts that each require unique associations, and having one steal another's security association. The sadb_msg_errno and sadb_msg_state fields should be ignored by the listening process.",
      "ja": "SADB_ACQUIREメッセージは、典型的には、そのキーソケット（SADB_REGISTERメッセージを参照）を登録したキーソケットリスナーにのみカーネルによって送信されます。 SADB_ACQUIREメッセージは、（OSPFセキュリティを使用OSPFv2の実装など）セキュリティアソシエーションのアプリケーションレベルの消費者によって送信することができます。 SADB_ACQUIREメッセージは、アドレス拡張、おそらく同一の拡張、及び提案の拡張と共に基本ヘッダです。提案される状態は、基本ヘッダでアルゴリズムが利用できない場合に使用することができることが望ましいアルゴリズムのリストを含みます。ベースヘッダ内と基本ヘッダの後に続くセキュリティアソシエーションデータのフィールドの値は、リスニングプロセスが獲得を試みるべきであることをセキュリティアソシエーションの特性を示しています。メッセージはカーネルに由来する場合（すなわちsadb_msg_pidが0で）、sadb_msg_seq数は要求にセキュリティアソシエーションを結合するために、後続のSADB_GETSPI及びSADB_UPDATE、または後続SADB_ADDメッセージによって使用されなければなりません。これは、それぞれが独自の関連付けを必要とする2つのIPホスト間の2つのTCP接続の競合状態を回避し、もう1つは盗む有する他は、セキュリティアソシエーションです。 sadb_msg_errnoとsadb_msg_stateフィールドは、リスニングプロセスによって無視されるべきです。"
    },
    {
      "indent": 3,
      "text": "The SADB_ACQUIRE message is typically triggered by an outbound packet that needs security but for which there is no applicable Security Association existing in the key table. If the packet can be sufficiently protected by more than one algorithm or combination of options, the SADB_ACQUIRE message MUST order the preference of possibilities in the Proposal extension.",
      "ja": "SADB_ACQUIREメッセージは、一般的なセキュリティを必要とするが、そのためのキーテーブル内の既存の該当セキュリティアソシエーションが存在しないアウトバウンドパケットによってトリガされます。パケットが十分に複数のアルゴリズムまたはオプションの組み合わせによって保護することができる場合、SADB_ACQUIREメッセージが提案拡張における可能性の嗜好を注文しなければなりません。"
    },
    {
      "indent": 3,
      "text": "There are three messaging behaviors for SADB_ACQUIRE. The first is where the kernel needs a security association (e.g. for IPsec).",
      "ja": "SADB_ACQUIREための3つのメッセージング・行動があります。カーネル（例えばIPsecの）セキュリティアソシエーションを必要とする場合に最初のです。"
    },
    {
      "indent": 5,
      "text": "The kernel sends an SADB_ACQUIRE message to registered sockets.",
      "ja": "カーネルは、登録されたソケットにSADB_ACQUIREメッセージを送信します。"
    },
    {
      "indent": 8,
      "text": "<base, address(SD), (address(P)), (identity(SD),) (sensitivity,) proposal>",
      "ja": "<ベースアドレス（SD）、（アドレス（P））、（アイデンティティ（SD））（感度）提案>"
    },
    {
      "indent": 8,
      "text": "NOTE: The address(SD) extensions MUST have the port fields filled in with the port numbers of the session requiring keys if appropriate.",
      "ja": "注：アドレス（SD）の拡張機能は、適切な場合には、キーを必要とするセッションのポート番号で埋めポートフィールドを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "The second is when, for some reason, key management fails, it can send an ACQUIRE message with the same sadb_msg_seq as the initial ACQUIRE with a non-zero errno.",
      "ja": "第二には、いくつかの理由のために、鍵管理が失敗したとき、それは非ゼロerrnoを持つ初期ACQUIREと同じsadb_msg_seqとACQUIREメッセージを送ることができます。"
    },
    {
      "indent": 8,
      "text": "Send an SADB_ACQUIRE to indicate key management failure.",
      "ja": "鍵管理の失敗を示すためにSADB_ACQUIREを送信します。"
    },
    {
      "indent": 8,
      "text": "<base>",
      "ja": "<ベース>"
    },
    {
      "indent": 3,
      "text": "The third is where an application-layer consumer of security associations (e.g. an OSPFv2 or RIPv2 daemon) needs a security association.",
      "ja": "セキュリティアソシエーションのアプリケーション層の消費者（例えばOSPFv2のまたはRIPv2のデーモン）がセキュリティアソシエーションを必要とする場合に第三です。"
    },
    {
      "indent": 8,
      "text": "Send an SADB_ACQUIRE message from a user process to the kernel.",
      "ja": "カーネルにユーザプロセスからSADB_ACQUIREメッセージを送信します。"
    },
    {
      "indent": 8,
      "text": "<base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal>",
      "ja": "<ベースアドレス（SD）、（アドレス（P））（同一性（SD））（感度）提案>"
    },
    {
      "indent": 8,
      "text": "The kernel returns an SADB_ACQUIRE message to registered sockets.",
      "ja": "カーネルは、登録されたソケットにSADB_ACQUIREメッセージを返します。"
    },
    {
      "indent": 8,
      "text": "<base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal>",
      "ja": "<ベースアドレス（SD）、（アドレス（P））（同一性（SD））（感度）提案>"
    },
    {
      "indent": 8,
      "text": "The user-level consumer waits for an SADB_UPDATE or SADB_ADD message for its particular type, and then can use that association by using SADB_GET messages.",
      "ja": "ユーザーレベルのコンシューマはSADB_GETメッセージを使用して、その関連付けを使用することができ、その特定のタイプのSADB_UPDATE又はSADB_ADDメッセージを待ち、そして。"
    },
    {
      "indent": 3,
      "text": "Errors: EINVAL Invalid acquire request. EPROTONOSUPPORT No KM application has registered with the Key Engine as being able to obtain the requested SA type, so the requested SA cannot be acquired.",
      "ja": "エラー：EINVAL無効な要求を獲得します。 EPROTONOSUPPORTませんKMアプリケーションが要求されたSAの種類を得ることができることなどの主要なエンジンに登録されているので、要求されたSAを取得することはできません。"
    },
    {
      "indent": 0,
      "text": "3.1.7 SADB_REGISTER",
      "section_title": true,
      "ja": "3.1.7 SADB_REGISTER"
    },
    {
      "indent": 3,
      "text": "The SADB_REGISTER message allows an application to register its key socket as able to acquire new security associations for the kernel. SADB_REGISTER allows a socket to receive SADB_ACQUIRE messages for the type of security association specified in sadb_msg_satype. The application specifies the type of security association that it can acquire for the kernel in the type field of its register message. If an application can acquire multiple types of security association, it MUST register each type in a separate message. Only the base header is needed for the register message. Key management applications MAY register for a type not known to the kernel, because the consumer may be in user-space (e.g. OSPFv2 security).",
      "ja": "SADB_REGISTERメッセージは、カーネル用の新しいセキュリティアソシエーションを取得することができるように、そのキーソケットを登録するためのアプリケーションを可能にします。 SADB_REGISTERはソケットがsadb_msg_satypeに指定されたセキュリティアソシエーションのタイプにSADB_ACQUIREメッセージを受け取ることができます。アプリケーションは、その登録メッセージのタイプフィールドでのカーネルのために取得できるセキュリティアソシエーションのタイプを指定します。アプリケーションは、セキュリティアソシエーションの複数の種類を取得することができる場合、それは別のメッセージの各タイプを登録しなければなりません。唯一の基本ヘッダは、レジスタメッセージのために必要とされます。消費者は、ユーザー空間（例えば、OSPFv2のセキュリティ）であってもよいので、鍵管理アプリケーションは、カーネルに知られていないタイプのために登録することもできます。"
    },
    {
      "indent": 3,
      "text": "The reply of the SADB_REGISTER message contains a supported algorithm extension. That field contains an array of supported algorithms, one per octet. This allows key management applications to know what algorithm are supported by the kernel.",
      "ja": "SADB_REGISTERメッセージの返信がサポートされたアルゴリズムの拡張機能が含まれています。そのフィールドはサポートされているアルゴリズム、オクテットごとに1の配列が含まれています。これは、鍵管理アプリケーションは、カーネルによってサポートされているアルゴリズムを知ることができます。"
    },
    {
      "indent": 3,
      "text": "In an environment where algorithms can be dynamically loaded and unloaded, an asynchronous SADB_REGISTER reply MAY be generated. The list of supported algorithms MUST be a complete list, so the application can make note of omissions or additions.",
      "ja": "アルゴリズムは、動的にロードおよびアンロードできる環境では、非同期SADB_REGISTER応答が生成されてもよいです。アプリケーションは省略または追加のノートを作ることができるようにサポートされているアルゴリズムのリストは、完全なリストでなければなりません。"
    },
    {
      "indent": 5,
      "text": "The messaging behavior of the SADB_REGISTER message is:",
      "ja": "SADB_REGISTERメッセージのメッセージングの動作は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "Send an SADB_REGISTER message from a user process to the kernel.",
      "ja": "カーネルにユーザプロセスからSADB_REGISTERメッセージを送信します。"
    },
    {
      "indent": 8,
      "text": "<base>",
      "ja": "<ベース>"
    },
    {
      "indent": 8,
      "text": "The kernel returns an SADB_REGISTER message to registered sockets, with algorithm types supported by the kernel being indicated in the supported algorithms field.",
      "ja": "カーネルは、サポートされているアルゴリズムフィールドに示されているカーネルでサポートされているアルゴリズムの種類と、登録されたソケットにSADB_REGISTERメッセージを返します。"
    },
    {
      "indent": 8,
      "text": "NOTE: This message may arrive asynchronously due to an algorithm being loaded or unloaded into a dynamically linked kernel.",
      "ja": "注：このメッセージは、原因動的にリンクされたカーネルにロードまたはアンロードされるアルゴリズムに非同期に到着するかもしれません。"
    },
    {
      "indent": 8,
      "text": "<base, supported>",
      "ja": "<ベース、サポート>"
    },
    {
      "indent": 0,
      "text": "3.1.8 SADB_EXPIRE Message",
      "section_title": true,
      "ja": "3.1.8 SADB_EXPIREメッセージ"
    },
    {
      "indent": 3,
      "text": "The operating system kernel is responsible for tracking SA expirations for security protocols that are implemented inside the kernel. If the soft limit or hard limit of a Security Association has expired for a security protocol implemented inside the kernel, then the kernel MUST issue an SADB_EXPIRE message to all key socket listeners. If the soft limit or hard limit of a Security Association for a user-level security protocol has expired, the user-level protocol SHOULD issue an SADB_EXPIRE message.",
      "ja": "オペレーティングシステムのカーネルは、カーネル内部に実装されているセキュリティプロトコルのためのSAの有効期限を追跡する責任があります。セキュリティアソシエーションのソフト制限やハード制限は、カーネル内部に実装するセキュリティプロトコルのための有効期限が切れている場合、そのカーネルは、すべてのキーソケットリスナーにSADB_EXPIREメッセージを発行しなければなりません。ユーザーレベルのセキュリティプロトコルのセキュリティアソシエーションのソフト制限またはハード制限の有効期限が切れている場合は、ユーザーレベルのプロトコルは、SADB_EXPIREメッセージを発行する必要があります。"
    },
    {
      "indent": 3,
      "text": "The base header will contain the security association information followed by the source sockaddr, destination sockaddr, (and, if present, internal sockaddr,) (and, if present, one or both compartment bitmaps).",
      "ja": "基本ヘッダは、ソースのsockaddr、先のsockaddr、（及び、存在する場合、内部のsockaddr）（及び、存在する場合、一方または両方の区画のビットマップ）、続いて、セキュリティアソシエーション情報を含むことになります。"
    },
    {
      "indent": 3,
      "text": "The lifetime extension of an SADB_EXPIRE message is important to indicate which lifetime expired. If a HARD lifetime extension is included, it indicates that the HARD lifetime expired. This means the association MAY be deleted already from the SADB. If a SOFT lifetime extension is included, it indicates that the SOFT lifetime expired. The CURRENT lifetime extension will indicate the current status, and comparisons to the HARD or SOFT lifetime will indicate which limit was reached. HARD lifetimes MUST take precedence over SOFT lifetimes, meaning if the HARD and SOFT lifetimes are the same, the HARD lifetime will appear on the EXPIRE message. The pathological case of HARD lifetimes being shorter than SOFT lifetimes is handled such that the SOFT lifetime will never expire.",
      "ja": "SADB_EXPIREメッセージの寿命延長の期限が切れた寿命を示すことが重要です。 HARD寿命延長が含まれている場合、それはHARD寿命の期限が切れていることを示しています。これは、関連付けがSADBからすでに削除されることがありますを意味します。 SOFT寿命延長が含まれている場合、それはSOFT寿命の期限が切れていることを示しています。現在の有効期間の延長は、現在の状態を示すであろう、と硬質または軟質寿命との比較に達した限界を示すであろう。 HARD寿命はHARDとSOFT寿命が同じであれば、HARD寿命がEXPIREメッセージに表示されますつまり、SOFT寿命よりも優先されなければなりません。 SOFT寿命よりも短いHARD寿命の病的な場合は、SOFT寿命が期限切れになりませんように扱われます。"
    },
    {
      "indent": 5,
      "text": "The messaging behavior of the SADB_EXPIRE message is:",
      "ja": "SADB_EXPIREメッセージのメッセージングの動作は次のとおりです。"
    },
    {
      "indent": 11,
      "text": "The kernel sends an SADB_EXPIRE message to all listeners when\nthe soft limit of a security association has been expired.",
      "raw": true
    },
    {
      "indent": 11,
      "text": "<base, SA, lifetime(C and one of HS), address(SD)>",
      "ja": "<塩基、SA、寿命（C及びHSのいずれか）、アドレス（SD）>"
    },
    {
      "indent": 3,
      "text": "Note that the SADB_EXPIRE message is ONLY sent by the kernel to the KMd. It is a one-way informational message that does not have a reply.",
      "ja": "SADB_EXPIREメッセージはONLY KMDにカーネルによって送られることに注意してください。これは、応答を持っていない一方通行の情報メッセージです。"
    },
    {
      "indent": 0,
      "text": "3.1.9 SADB_FLUSH",
      "section_title": true,
      "ja": "3.1.9 SADB_FLUSH"
    },
    {
      "indent": 3,
      "text": "The SADB_FLUSH message causes the kernel to delete all entries in its key table for a certain sadb_msg_satype. Only the base header is required for a flush message. If sadb_msg_satype is filled in with a specific value, only associations of that type are deleted. If it is filled in with SADB_SATYPE_UNSPEC, ALL associations are deleted.",
      "ja": "SADB_FLUSHメッセージは、特定のsadb_msg_satypeために、そのキーテーブル内のすべてのエントリを削除するには、カーネルの原因となります。唯一の基本ヘッダは、フラッシュメッセージのために必要とされます。 sadb_msg_satypeが特定の値で満たされている場合は、そのタイプの唯一の関連付けが削除されます。それはSADB_SATYPE_UNSPECで満たされている場合は、すべての関連付けが削除されます。"
    },
    {
      "indent": 5,
      "text": "The messaging behavior for SADB_FLUSH is:",
      "ja": "SADB_FLUSHのためのメッセージングの動作は次のとおりです。"
    },
    {
      "indent": 11,
      "text": "Send an SADB_FLUSH message from a user process to the kernel.",
      "ja": "カーネルにユーザプロセスからSADB_FLUSHメッセージを送信します。"
    },
    {
      "indent": 11,
      "text": "<base>",
      "ja": "<ベース>"
    },
    {
      "indent": 11,
      "text": "The kernel will return an SADB_FLUSH message to all listening sockets.",
      "ja": "カーネルは、すべてのリスニングソケットにSADB_FLUSHメッセージを返します。"
    },
    {
      "indent": 11,
      "text": "<base>",
      "ja": "<ベース>"
    },
    {
      "indent": 11,
      "text": "The reply message happens only after the actual flushing of security associations has been attempted.",
      "ja": "応答メッセージは、セキュリティアソシエーションの実際のフラッシュが試みられてきた後にのみ起こります。"
    },
    {
      "indent": 0,
      "text": "3.1.10 SADB_DUMP",
      "section_title": true,
      "ja": "3.1.10 SADB_DUMP"
    },
    {
      "indent": 3,
      "text": "The SADB_DUMP message causes the kernel to dump the operating system's entire Key Table to the requesting key socket. As in SADB_FLUSH, if a sadb_msg_satype value is in the message, only associations of that type will be dumped. If SADB_SATYPE_UNSPEC is specified, all associations will be dumped. Each Security Association is returned in its own SADB_DUMP message. A SADB_DUMP message with a sadb_seq field of zero indicates the end of the dump transaction. The dump message is used for debugging purposes only and is not intended for production use.",
      "ja": "SADB_DUMPメッセージは、要求キーソケットにオペレーティング・システムの全体のキーテーブルをダンプするカーネルの原因となります。 sadb_msg_satype値がメッセージ内にある場合SADB_FLUSHのように、その種類の唯一の関連付けがダンプされます。 SADB_SATYPE_UNSPECが指定されている場合は、すべての関連付けがダンプされます。各セキュリティアソシエーションは、独自のSADB_DUMPメッセージで返されます。ゼロのsadb_seqフィールドとSADB_DUMPメッセージは、ダンプ・トランザクションの終了を示します。ダンプメッセージはデバッグ目的でのみ使用され、本番環境での使用を目的としていません。"
    },
    {
      "indent": 3,
      "text": "Support for the dump message MAY be discontinued in future versions of PF_KEY. Key management applications MUST NOT depend on this message for basic operation.",
      "ja": "ダンプ・メッセージのサポートは、PF_KEYの将来のバージョンで廃止されるかもしれません。鍵管理アプリケーションは、基本的な操作のために、このメッセージに依存してはなりません。"
    },
    {
      "indent": 5,
      "text": "The messaging behavior for SADB_DUMP is:",
      "ja": "SADB_DUMPのためのメッセージングの動作は次のとおりです。"
    },
    {
      "indent": 11,
      "text": "Send an SADB_DUMP message from a user process to the kernel.",
      "ja": "カーネルにユーザプロセスからSADB_DUMPメッセージを送信します。"
    },
    {
      "indent": 11,
      "text": "<base>",
      "ja": "<ベース>"
    },
    {
      "indent": 11,
      "text": "Several SADB_DUMP messages will return from the kernel to the sending socket.",
      "ja": "いくつかのSADB_DUMPメッセージが送信ソケットにカーネルから戻ります。"
    },
    {
      "indent": 11,
      "text": "<base, SA, (lifetime (HSC),) address(SD), (address(P),) key(AE), (identity(SD),) (sensitivity)>",
      "ja": "<塩基、SA（寿命（HSC）、）アドレス（SD）、（アドレス（P））のキー（AE）、（アイデンティティ（SD））（感度）>"
    },
    {
      "indent": 0,
      "text": "3.2 Security Association Flags",
      "section_title": true,
      "ja": "3.2セキュリティアソシエーションの国旗"
    },
    {
      "indent": 3,
      "text": "The Security Association's flags are a bitmask field. These flags also appear in a combination that is part of a PROPOSAL extension. The related symbolic definitions below should be used in order that applications will be portable:",
      "ja": "セキュリティ協会のフラグはビットフィールドです。これらのフラグはまた、提案拡張の一部である組み合わせで表示されます。下記の関連シンボル定義は、アプリケーションが移植できるようにするために使用する必要があります。"
    },
    {
      "indent": 5,
      "text": "#define SADB_SAFLAGS_PFS 1    /* perfect forward secrecy */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The SADB_SAFLAGS_PFS flag indicates to key management that this association should have perfect forward secrecy in its key. (In other words, any given session key cannot be determined by cryptanalysis of previous session keys or some master key.)",
      "ja": "SADB_SAFLAGS_PFSフラグは、この協会がそのキーに完全転送秘密を持っている必要があり、鍵管理に示します。 （換言すれば、任意の所与のセッションキーは、前のセッションキー又は一部マスターキーの暗号解読することによって決定することができません。）"
    },
    {
      "indent": 0,
      "text": "3.3 Security Association States",
      "section_title": true,
      "ja": "3.3セキュリティアソシエーションの状態"
    },
    {
      "indent": 3,
      "text": "The security association state field is an integer that describes the states of a security association. They are:",
      "ja": "セキュリティアソシエーションの状態フィールドは、セキュリティアソシエーションの状態を記述する整数です。彼らです："
    },
    {
      "indent": 5,
      "text": "#define SADB_SASTATE_LARVAL 0 #define SADB_SASTATE_MATURE 1 #define SADB_SASTATE_DYING 2 #define SADB_SASTATE_DEAD 3",
      "ja": "#define SADB_SASTATE_LARVAL 0の#define SADB_SASTATE_MATURE 1の#define SADB_SASTATE_DYING 2の#define SADB_SASTATE_DEAD 3"
    },
    {
      "indent": 5,
      "text": "#define SADB_SASTATE_MAX 3",
      "ja": "#define SADB_SASTATE_MAX 3"
    },
    {
      "indent": 3,
      "text": "A SADB_SASTATE_LARVAL security association is one that was created by the SADB_GETSPI message. A SADB_SASTATE_MATURE association is one that was updated with the SADB_UPDATE message or added with the SADB_ADD message. A DYING association is one whose soft lifetime has expired. A SADB_SASTATE_DEAD association is one whose hard lifetime has expired, but hasn't been reaped by system garbage collection. If a consumer of security associations has to extend an association beyond its normal lifetime (e.g. OSPF Security) it MUST only set the soft lifetime for an association.",
      "ja": "SADB_SASTATE_LARVALセキュリティアソシエーションがSADB_GETSPIメッセージによって作成されたものです。 SADB_SASTATE_MATUREアソシエーションはSADB_UPDATEメッセージで更新またはSADB_ADDメッセージを添加したものです。 DYING協会は、そのソフト生涯有効期限が切れたものです。 SADB_SASTATE_DEAD協会は、そのハード寿命、期​​限が切れていますが、システムのガベージコレクションによって刈り取られていないものです。セキュリティアソシエーションの消費者が通常の寿命（例えばOSPFセキュリティ）を超えて関連を延長する必要がある場合にのみ関連付けのためにソフト寿命を設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.4 Security Association Types",
      "section_title": true,
      "ja": "3.4セキュリティアソシエーションの種類"
    },
    {
      "indent": 3,
      "text": "This defines the type of Security Association in this message. The symbolic names are always the same, even on different implementations. Applications SHOULD use the symbolic name in order to have maximum portability across different implementations. These are defined in the file <net/pfkeyv2.h>.",
      "ja": "これは、このメッセージにセキュリティアソシエーションのタイプを定義します。シンボリック名でも異なる実装上で、常に同じです。アプリケーションは、異なる実装間の最大の移植性を持つためにシンボリック名を使用する必要があります。これらは、ファイル<ネット/ pfkeyv2.h>で定義されています。"
    },
    {
      "indent": 5,
      "text": "#define SADB_SATYPE_UNSPEC 0",
      "ja": "#define SADB_SATYPE_UNSPEC 0"
    },
    {
      "indent": 5,
      "text": "#define SADB_SATYPE_AH            2  /* RFC-1826 */\n#define SADB_SATYPE_ESP           3  /* RFC-1827 */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "#define SADB_SATYPE_RSVP          5  /* RSVP Authentication */\n#define SADB_SATYPE_OSPFV2        6  /* OSPFv2 Authentication */\n#define SADB_SATYPE_RIPV2         7  /* RIPv2 Authentication */\n#define SADB_SATYPE_MIP           8  /* Mobile IP Auth. */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "#define SADB_SATYPE_MAX 8",
      "ja": "#define SADB_SATYPE_MAX 8"
    },
    {
      "indent": 3,
      "text": "SADB_SATYPE_UNSPEC is defined for completeness and means no specific type of security association. This type is never used with PF_KEY SAs.",
      "ja": "SADB_SATYPE_UNSPECは完全を期すために定義されたセキュリティ関連のない特定のタイプを意味しています。このタイプは、PF_KEYのSAで使用されることはありません。"
    },
    {
      "indent": 3,
      "text": "SADB_SATYPE_AH is for the IP Authentication Header [Atk95b].",
      "ja": "SADB_SATYPE_AHは、IP認証ヘッダ[Atk95b]です。"
    },
    {
      "indent": 3,
      "text": "SADB_SATYPE_ESP is for the IP Encapsulating Security Payload [Atk95c].",
      "ja": "SADB_SATYPE_ESPは[Atk95c] IPカプセル化セキュリティペイロードのためです。"
    },
    {
      "indent": 3,
      "text": "SADB_SATYPE_RSVP is for the RSVP Integrity Object.",
      "ja": "SADB_SATYPE_RSVPは、RSVPのIntegrityオブジェクトのためです。"
    },
    {
      "indent": 3,
      "text": "SADB_SATYPE_OSPFV2 is for OSPFv2 Cryptographic authentication [Moy98].",
      "ja": "SADB_SATYPE_OSPFV2は[Moy98] OSPFv2の暗号認証のためのものです。"
    },
    {
      "indent": 3,
      "text": "SADB_SATYPE_RIPV2 is for RIPv2 Cryptographic authentication [BA97].",
      "ja": "SADB_SATYPE_RIPV2は、RIPv2の暗号認証[BA97]です。"
    },
    {
      "indent": 3,
      "text": "SADB_SATYPE_MIP is for Mobile IP's authentication extensions [Per97].",
      "ja": "SADB_SATYPE_MIPは、モバイルIPの認証拡張[Per97]です。"
    },
    {
      "indent": 3,
      "text": "SADB_SATYPE_MAX is always set to the highest valid numeric value.",
      "ja": "SADB_SATYPE_MAXは、常に最高の有効な数値に設定されています。"
    },
    {
      "indent": 0,
      "text": "3.5 Algorithm Types",
      "section_title": true,
      "ja": "3.5アルゴリズムの種類"
    },
    {
      "indent": 3,
      "text": "The algorithm type is interpreted in the context of the Security Association type defined above. The numeric value might vary between implementations, but the symbolic name MUST NOT vary between implementations. Applications should use the symbolic name in order to have maximum portability to various implementations.",
      "ja": "アルゴリズムの種類は、上記で定義されたセキュリティアソシエーション型の文脈で解釈されます。数値は、実装間で異なる可能性がありますが、シンボリック名は、実装によって異なりてはなりません。アプリケーションは、さまざまな実装への最大の移植性を持つためにシンボリック名を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some of the algorithm types defined below might not be standardized or might be deprecated in the future. To obtain an assignment for a symbolic name, contact the authors.",
      "ja": "以下に定義されたアルゴリズムの種類の中には、標準化されないことがありますか、将来的に廃止されるかもしれません。シンボリック名の割り当てを取得するには、著者にお問い合わせください。"
    },
    {
      "indent": 5,
      "text": "The symbols below are defined in <net/pfkeyv2.h>.",
      "ja": "以下の記号は、<ネット/ pfkeyv2.h>で定義されています。"
    },
    {
      "indent": 11,
      "text": "/* Authentication algorithms */\n#define SADB_AALG_NONE          0\n#define SADB_AALG_MD5HMAC       2\n#define SADB_AALG_SHA1HMAC      3\n#define SADB_AALG_MAX           3",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* Encryption algorithms */\n#define SADB_EALG_NONE          0\n#define SADB_EALG_DESCBC        2\n#define SADB_EALG_3DESCBC       3\n#define SADB_EALG_NULL          11\n#define SADB_EALG_MAX           11",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The algorithm for SADB_AALG_MD5_HMAC is defined in [MG98a]. The algorithm for SADB_AALG_SHA1HMAC is defined in [MG98b]. The algorithm for SADB_EALG_DESCBC is defined in [MD98]. SADB_EALG_NULL is the NULL encryption algorithm, defined in [GK98]. The SADB_EALG_NONE value is not to be used in any security association except those which have no possible encryption algorithm in them (e.g. IPsec AH).",
      "ja": "SADB_AALG_MD5_HMACためのアルゴリズムは[MG98a]で定義されています。 SADB_AALG_SHA1HMACためのアルゴリズムは[MG98b]で定義されています。 SADB_EALG_DESCBCためのアルゴリズムは[MD98]で定義されています。 SADB_EALG_NULLは[GK98]で定義されたNULL暗号化アルゴリズムです。 SADB_EALG_NONE値がそれらには可能な暗号化アルゴリズム（例えば、IPsecのAH）を有していないものを除き、任意のセキュリティ関連して使用されるべきではありません。"
    },
    {
      "indent": 0,
      "text": "3.6 Extension Header Values",
      "section_title": true,
      "ja": "3.6拡張ヘッダの値"
    },
    {
      "indent": 3,
      "text": "To briefly recap the extension header values:",
      "ja": "簡単に拡張ヘッダ値を復習します。"
    },
    {
      "indent": 11,
      "text": "#define SADB_EXT_RESERVED          0\n#define SADB_EXT_SA                1\n#define SADB_EXT_LIFETIME_CURRENT  2\n#define SADB_EXT_LIFETIME_HARD     3\n#define SADB_EXT_LIFETIME_SOFT     4\n#define SADB_EXT_ADDRESS_SRC       5\n#define SADB_EXT_ADDRESS_DST       6\n#define SADB_EXT_ADDRESS_PROXY     7\n#define SADB_EXT_KEY_AUTH          8\n#define SADB_EXT_KEY_ENCRYPT       9\n#define SADB_EXT_IDENTITY_SRC      10\n#define SADB_EXT_IDENTITY_DST      11\n#define SADB_EXT_SENSITIVITY       12\n#define SADB_EXT_PROPOSAL          13\n#define SADB_EXT_SUPPORTED_AUTH    14\n#define SADB_EXT_SUPPORTED_ENCRYPT 15\n#define SADB_EXT_SPIRANGE          16",
      "raw": true
    },
    {
      "indent": 11,
      "text": "#define SADB_EXT_MAX 16",
      "ja": "SADB_EXT_MAX 16の#define"
    },
    {
      "indent": 0,
      "text": "3.7 Identity Extension Values",
      "section_title": true,
      "ja": "3.7アイデンティティ拡張値"
    },
    {
      "indent": 3,
      "text": "Each identity can have a certain type.",
      "ja": "それぞれのアイデンティティは、特定のタイプを持つことができます。"
    },
    {
      "indent": 11,
      "text": "#define SADB_IDENTTYPE_RESERVED  0\n#define SADB_IDENTTYPE_PREFIX    1\n#define SADB_IDENTTYPE_FQDN      2\n#define SADB_IDENTTYPE_USERFQDN  3",
      "raw": true
    },
    {
      "indent": 11,
      "text": "#define SADB_IDENTTYPE_MAX 3",
      "ja": "#define SADB_IDENTTYPE_MAX 3"
    },
    {
      "indent": 3,
      "text": "The PREFIX identity string consists of a network address followed by a forward slash and a prefix length. The network address is in a printable numeric form appropriate for the protocol family. The prefix length is a decimal number greater than or equal to zero and less than the number of bits in the network address. It indicates the number of bits in the network address that are significant; all bits in the network address that are not significant MUST be set to zero. Note that implementations MUST parse the contents of the printable address into a binary form for comparison purposes because multiple printable strings are valid representations of the same address in many protocol families (for example, some allow leading zeros and some have letters that are case insensitive). Examples of PREFIX identities are \"199.33.248.64/27\" and \"3ffe::1/128\". If the source or destination identity is a PREFIX identity, the source or destination address for the SA (respectively) MUST be within that prefix. The sadb_ident_id field is zeroed for these identity types.",
      "ja": "PREFIXアイデンティティ文字列はスラッシュとプレフィックス長に続いてネットワークアドレスで構成されています。ネットワークアドレスは、プロトコルファミリのための印刷可能な数値形式の適切です。プレフィックス長を10進数ゼロ以上とネットワークアドレスのビット数よりも少ないです。これは重要であるネットワークアドレスのビット数を示します。重要でないネットワークアドレスのすべてのビットはゼロに設定しなければなりません。複数の印刷可能文字列が多くのプロトコルファミリ内の同じアドレスの有効な表現（例えば、いくつかの先行ゼロを可能にし、いくつかは大文字と小文字を区別している文字を持っている）しているので、実装は比較目的のためにバイナリ形式に印刷可能なアドレスの内容を解析する必要があります。 PREFIXアイデンティティの例としては、 \"199.33.248.64/27\" と \"3FFE :: 1/128\" です。送信元または宛先IDがPREFIX同一である場合、SA（それぞれ）のソースまたは宛先アドレスは、プレフィックス内になければなりません。 sadb_ident_idフィールドは、これらのアイデンティティのタイプのためにゼロにされます。"
    },
    {
      "indent": 3,
      "text": "The FQDN identity string contains a fully qualified domain name. An example FQDN identity is \"ministry-of-truth.inner.net\". The sadb_ident_id field is zeroed for these identity types.",
      "ja": "FQDNのアイデンティティ文字列は、完全修飾ドメイン名が含まれています。例えば、FQDNのアイデンティティは「ministry-of-truth.inner.net」です。 sadb_ident_idフィールドは、これらのアイデンティティのタイプのためにゼロにされます。"
    },
    {
      "indent": 3,
      "text": "The UserFQDN identity consists of a text string in the format commonly used for Internet-standard electronic mail. The syntax is the text username, followed by the \"@\" character, followed in turn by the appropriate fully qualified domain name. This identity specifies both a username and an associated FQDN. There is no requirement that this string specify a mailbox valid for SMTP or other electronic mail use. This identity is useful with protocols supporting user-oriented keying. It is a convenient identity form because the DNS Security extensions can be used to distribute signed public key values by associating KEY and SIG records with an appropriate MB DNS record. An example UserFQDN identity is \"julia@ministry-of-love.inner.net\". The sadb_ident_id field is used to contain a POSIX user id in the absence of an identity string itself so that a user-level application can use the getpwuid{,_r}() routine to obtain a textual user login id. If a string is present, it SHOULD match the numeric value in the sadb_ident_id field. If it does not match, the string SHOULD override the numeric value.",
      "ja": "UserFQDNのアイデンティティは、一般的に、インターネット標準の電子メールのために使用される形式でテキスト文字列で構成されています。構文は、適切な完全修飾ドメイン名が順番に続き、「@」の文字が続く、テキストのユーザ名です。このIDは、ユーザ名と関連付けられているFQDNの両方を指定します。この文字列は、SMTPまたは他の電子メールの使用のための有効なメールボックスを指定する必要はありません。このIDは、ユーザー指向のキーをサポートしているプロトコルと便利です。 DNSセキュリティ拡張が適切なMBのDNSレコードとKEYとSIGレコードを関連付けることにより、署名した公開鍵値を配布するために使用することができますので、これは便利なアイデンティティ形です。例UserFQDN同一性「はjulia@ministry-of-love.inner.net」です。 sadb_ident_idフィールドは、ユーザーレベルのアプリケーションは、テキストのユーザのログインIDを取得する{_ R}（）ルーチンgetpwuidを使用できるように識別文字列自体が存在しない場合にPOSIXユーザーIDを含むために使用されます。文字列が存在する場合、それはsadb_ident_idフィールドの数値と一致する必要があります。それが一致しない場合、文字列が数値をオーバーライドする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.8 Sensitivity Extension Values",
      "section_title": true,
      "ja": "3.8感度拡張値"
    },
    {
      "indent": 3,
      "text": "The only field currently defined in the sensitivity extension is the sadb_sens_dpd, which represents the data protection domain. The other data in the sensitivity extension is based off the sadb_sens_dpd value.",
      "ja": "現在、感度拡張で定義された唯一のフィールドは、データの保護ドメインを表しsadb_sens_dpd、です。感度拡張内の他のデータはsadb_sens_dpd値をオフに基づいています。"
    },
    {
      "indent": 3,
      "text": "The DP/DOI is defined to be the same as the \"Labeled Domain Identifier Value\" of the IP Security DOI specification [Pip98]. As noted in that specification, values in the range 0x80000000 to 0xffffffff (inclusive) are reserved for private use and values in the range 0x00000001 through 0x7fffffff are assigned by IANA. The all-zeros DP/DOI value is permanently reserved to mean that \"no DP/DOI is in use\".",
      "ja": "DP / DOIはIPセキュリティDOI仕様[Pip98]の「標識されたドメイン識別子値」と同じであると定義されます。その明細書で述べたように、0xFFFFFFFFの範囲は0x80000000（含む）の値0x7FFFFFFFでを通じて範囲0x00000001の民間用途および値のために予約されているが、IANAによって割り当てられます。 DP / DOI値が永続的に予約されているすべてゼロ「にはDP / DOIが使用されていない」ことを意味します。"
    },
    {
      "indent": 0,
      "text": "3.9 Proposal Extension Values",
      "section_title": true,
      "ja": "3.9提案拡張値"
    },
    {
      "indent": 3,
      "text": "These are already mentioned in the Algorithm Types and Security Association Flags sections.",
      "ja": "これらは、すでにアルゴリズムタイプとセキュリティアソシエーションフラグのセクションに記載されています。"
    },
    {
      "indent": 0,
      "text": "4 Future Directions",
      "ja": "4つの今後の方向性"
    },
    {
      "indent": 3,
      "text": "While the current specification for the Sensitivity and Integrity Labels is believed to be general enough, if a case should arise that can't work with the current specification then this might cause a change in a future version of PF_KEY.",
      "ja": "感度と整合性ラベルの現在の仕様は場合は、それが現在の仕様では動作しないことができ生じたかどうかを、十分に一般的であると考えられているが、これはPF_KEYの将来のバージョンで変更が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Similarly, PF_KEY might need extensions to work with other kinds of Security Associations in future. It is strongly desirable for such extensions to be made in a backwards-compatible manner should they be needed.",
      "ja": "同様に、PF_KEYは、将来的にセキュリティアソシエーションの他の種類で動作するように拡張が必要になる場合があります。それは彼らが必要とされなければならない後方互換性のある方法で行われるためにそのような拡張のために強く望まれています。"
    },
    {
      "indent": 3,
      "text": "When more experience is gained with certificate management, it is possible that the IDENTITY extension will have to be revisited to allow a finer grained selection of certificate identities.",
      "ja": "より多くの経験が証明書の管理を獲得した場合、IDENTITY拡張が証明書のアイデンティティのより細かい粒度の選択を可能にするために再検討されなければならない可能性があります。"
    },
    {
      "indent": 0,
      "text": "5. Examples",
      "section_title": true,
      "ja": "5.例"
    },
    {
      "indent": 3,
      "text": "The following examples illustrate how PF_KEY is used. The first example is an IP Security example, where the consumer of the security associations is inside an operating system kernel. The second example is an OSPF Security example, which illustrates a user-level consumer of security associations. The third example covers things not mentioned by the first two examples. A real system may closely conform to one of these examples, or take parts of them. These examples are purely illustrative, and are not intended to mandate a particular implementation method.",
      "ja": "次の例では、PF_KEYを使用する方法を示しています。最初の例では、セキュリティアソシエーションの消費者は、オペレーティングシステムのカーネル内にあるIPセキュリティ例、です。第二の例では、セキュリティアソシエーションのユーザーレベルのコンシューマを示すOSPFセキュリティ一例です。第3の例は、最初の2つの例により記載されていないものをカバーします。実際のシステムは密接にこれらの例のいずれかに適合し、またはそれらの一部を取ることがあります。これらの例は純粋に例示であり、特定の実装方法を強制するものではありません。"
    },
    {
      "indent": 0,
      "text": "5.1 Simple IP Security Example",
      "section_title": true,
      "ja": "5.1シンプルIPセキュリティの例"
    },
    {
      "indent": 15,
      "text": "      +---------------+    +-------------+\n      |Key Mgmt Daemon|    | Application |\n      +---------------+    +-------------+\n        |           |     /\n        |           |    /\n        |           |    |              Applications\n======[PF_KEY]====[PF_INET]==========================\n        |           |    |              OS Kernel\n+------------+   +-----------------+\n| Key Engine |   | TCP/IP,         |\n|  or  SADB  |---| including IPsec |\n+------------+   |                 |\n                 +-----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When the Key Management daemon (KMd) begins. It must tell PF_KEY that it is willing to accept message for the two IPsec services, AH and ESP. It does this by sending down two SADB_REGISTER messages.",
      "ja": "ときにキー管理デーモン（KMD）が開始されます。 2つのIPSecサービス、AHとESPのためのメッセージを受け入れても構わないと思っているPF_KEYを伝える必要があります。これは、2つのSADB_REGISTERメッセージをダウン送信することにより、これを行います。"
    },
    {
      "indent": 5,
      "text": "KMd->Kernel: SADB_REGISTER for ESP Kernel->Registered: SADB_REGISTER for ESP, Supported Algorithms KMd->Kernel: SADB_REGISTER for AH Kernel->Registered: SADB_REGISTER for AH, Supported Algorithms",
      "ja": "KMd->カーネル：SADB_REGISTERのためのESP Kernel->登録：SADB_REGISTER ESPのため、サポートされているアルゴリズムKMd->カーネル：AH Kernel-ためSADB_REGISTER>登録：AHのためSADB_REGISTER、サポートされるアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Each REGISTER message will cause a reply to go to all PF_KEY sockets registered for ESP and AH respectively (including the requester).",
      "ja": "各REGISTERメッセージには返信が（依頼者を含む）は、それぞれ、ESPとAHのために登録されたすべてのPF_KEYソケットに行くことになります。"
    },
    {
      "indent": 3,
      "text": "Assume that no security associations currently exist for IPsec to use. Consider when a network application begins transmitting data (e.g. a TCP SYN). Because of policy, or the application's request, the kernel IPsec module needs an AH security association for this data. Since there is not one present, the following message is generated:",
      "ja": "IPsecを使用するために何のセキュリティアソシエーションが現在存在しないことを前提としています。ネットワークアプリケーション（例えばTCP SYN）がデータの送信を開始するときに考慮する。そのため、ポリシー、またはアプリケーションの要求によって、カーネルのIPsecモジュールは、このデータのためのAHセキュリティアソシエーションを必要とします。 1つの存在しないため、次のメッセージが生成されます。"
    },
    {
      "indent": 5,
      "text": "Kernel->Registered: SADB_ACQUIRE for AH, addrs, ID, sens, proposals",
      "ja": "Kernel->登録：AHのためSADB_ACQUIRE、アドレスが使われる、ID、SENS、提案"
    },
    {
      "indent": 3,
      "text": "The KMd reads the ACQUIRE message, especially the sadb_msg_seq number. Before it begins the negotiation, it sends down an SADB_GETSPI message with the sadb_msg_seq number equal to the one received in the ACQUIRE. The kernel returns the results of the GETSPI to all listening sockets.",
      "ja": "KMDはACQUIREメッセージ、特にsadb_msg_seq番号を読み込みます。それが交渉を開始する前に、それはACQUIREで受信した1つに等しいsadb_msg_seq番号でSADB_GETSPIメッセージをダウン送信します。カーネルは、すべてのリスニングソケットにGETSPIの結果を返します。"
    },
    {
      "indent": 5,
      "text": "KMd->Kernel: SADB_GETSPI for AH, addr, SPI range Kernel->All: SADB_GETSPI for AH, assoc, addrs",
      "ja": "KMd->カーネル：AHのためSADB_GETSPI、addrは、SPI範囲Kernel->すべて：AHのためSADB_GETSPI、連想、アドレスが使われます"
    },
    {
      "indent": 3,
      "text": "The KMd may perform a second GETSPI operation if it needs both directions of IPsec SPI values. Now that the KMd has an SPI for at least one of the security associations, it begins negotiation. After deriving keying material, and negotiating other parameters, it sends down one (or more) SADB_UPDATE messages with the same value in sadb_msg_seq.",
      "ja": "これは、IPSec SPI値の両方向を必要とする場合KMDは、第GETSPI動作を実行することができます。今KMDは、セキュリティアソシエーションの少なくとも一方のためのSPIを持っていること、それが交渉を開始します。鍵材料を導出する、およびその他のパラメータを交渉した後、それは1つ（または複数）sadb_msg_seqに同じ値を持つSADB_UPDATEメッセージをダウン送信します。"
    },
    {
      "indent": 3,
      "text": "If a KMd has any error at all during its negotiation, it can send down:",
      "ja": "KMDはそのネゴシエーション中にまったくエラーが発生した場合、それがダウンして送信することができます："
    },
    {
      "indent": 5,
      "text": "KMd->Kernel: SADB_ACQUIRE for AH, assoc (with an error) Kernel->All: SADB_ACQUIRE for AH, assoc (same error)",
      "ja": "KMd->カーネル：AHのためのSADB_ACQUIRE（エラーで）、連想Kernel->すべて：AHのためSADB_ACQUIRE、連想（同じエラー）"
    },
    {
      "indent": 3,
      "text": "but if it succeeds, it can instead:",
      "ja": "それが成功した場合、それは代わりにすることができます："
    },
    {
      "indent": 5,
      "text": "KMd->Kernel: SADB_UPDATE for AH, assoc, addrs, keys, <etc.> Kernel->All: SADB_UPDATE for AH, assoc, addrs, <etc.>",
      "ja": "KMd->カーネル：AHなど連想、アドレスが使われる、キー、<> Kernel->すべてのためのSADB_UPDATE：AHのためSADB_UPDATE、連想、アドレスが使われる、<など>"
    },
    {
      "indent": 3,
      "text": "The results of the UPDATE (minus the actual keys) are sent to all listening sockets. If only one SPI value was determined locally, the other SPI (since IPsec SAs are unidirectional) must be added with an SADB_ADD message.",
      "ja": "UPDATE（マイナス実際のキー）の結果は、全てのリスニングソケットに送信されます。唯一のSPI値が局所的に決定された場合、他のSPIは（のIPsec SAは単方向であるため）SADB_ADDメッセージに追加されなければなりません。"
    },
    {
      "indent": 5,
      "text": "KMd->Kernel: SADB_ADD for AH, assoc, addrs, keys, <etc.> Kernel->All: SADB_ADD for AH, assoc, addrs, <etc.>",
      "ja": "KMd->カーネル：AHのためSADB_ADD、連想、アドレスが使われる、キー、<など> Kernel->すべて：AHのためSADB_ADD、連想、アドレスが使われる、<など>"
    },
    {
      "indent": 3,
      "text": "If one of the extensions passed down was a Lifetime extension, it is possible at some point an SADB_EXPIRE message will arrive when one of the lifetimes has expired.",
      "ja": "受け継が拡張子の一つは寿命延長した場合の寿命の1が経過したとき、それが可能であるかの時点でSADB_EXPIREメッセージが届きます。"
    },
    {
      "indent": 5,
      "text": "Kernel->All: SADB_EXPIRE for AH, assoc, addrs, Hard or Soft, Current, <etc.>",
      "ja": "Kernel->すべて：AH、連想、アドレスが使われる、ハードやソフトのためSADB_EXPIRE、現在、<など>"
    },
    {
      "indent": 3,
      "text": "The KMd can use this as a clue to begin negotiation, or, if it has some say in policy, send an SADB_UPDATE down with a lifetime extension.",
      "ja": "KMDは、交渉を開始するための手がかりとしてこれを使用するか、または、それはいくつかのポリシーに言っている場合、寿命延長とSADB_UPDATEを下に送ることができます。"
    },
    {
      "indent": 0,
      "text": "5.2 Proxy IP Security Example",
      "section_title": true,
      "ja": "5.2プロキシのIPセキュリティの例"
    },
    {
      "indent": 3,
      "text": "Many people are interested in using IP Security in a \"proxy\" or \"firewall\" configuration in which an intermediate system provides security services for \"inside\" hosts. In these environments, the intermediate systems can use PF_KEY to communicate with key management applications almost exactly as they would if they were the actual endpoints. The messaging behavior of PF_KEY in these cases is exactly the same as the previous example, but the address information is slightly different.",
      "ja": "多くの人々は、中間システムは、「内部」ホストのセキュリティサービスを提供する「プロキシ」または「ファイアウォール」の設定でIPセキュリティを使用することに興味を持っています。これらの環境では、中間システムは、ほぼ正確に彼らと同じように、彼らは実際のエンドポイントであれば、鍵管理アプリケーションとの通信にPF_KEYを使用することができます。これらのケースでPF_KEYのメッセージング動作は、前の例とまったく同じですが、アドレス情報は多少異なります。"
    },
    {
      "indent": 5,
      "text": "Consider this case:",
      "ja": "このような場合を考えてみます。"
    },
    {
      "indent": 21,
      "text": "A ========= B --------- C",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Key: A \"outside\" host that implements IPsec B \"firewall\" that implements IPsec C \"inside\" host that does not implement IPsec",
      "ja": "キー：IPsecを実装しないホスト「内」IPsecのCを実装したIPsec B「ファイアウォール」を実装し、「外」のホスト"
    },
    {
      "indent": 15,
      "text": "===         IP_{A<->B} ESP [ IP_{A<->C} ULP ]\n---         IP_{A<->C} ULP",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A is a single system that wishes to communicate with the \"inside\" system C. B is a \"firewall\" between C and the outside world that will do ESP and tunneling on C's behalf. A discovers that it needs to send traffic to C via B through methods not described here (Use of the DNS' KX record might be one method for discovering this).",
      "ja": "AはC. BはCとCの代わりにESPとトンネリングを行います外界との間の「ファイアウォール」で「内部」システムと通信することを希望する単一のシステムです。 Aは、それが（DNS」KXレコードの使用がこれを発見するための一つの方法かもしれません）、ここで説明されていないメソッドを介してBを経由してCにトラフィックを送信する必要があることを発見します。"
    },
    {
      "indent": 3,
      "text": "For packets that flow from left to right, A and B need an IPsec Security Association with:",
      "ja": "左から右に流れてパケットの場合、AとBは、IPsecセキュリティアソシエーションをして必要があります。"
    },
    {
      "indent": 11,
      "text": "SA type of ESP tunnel-mode\nSource Identity that dominates A (e.g. A's address)\nDestination Identity that dominates B (e.g. B's address)\nSource Address of A\nDestination Address of B",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For packets to flow from right to left, A and B need an IPsec Security Association with:",
      "ja": "パケットが右から左に流れるようにするために、AとBは、IPsecセキュリティ協会とが必要になります。"
    },
    {
      "indent": 11,
      "text": "SA type of ESP tunnel-mode\nSource Identity that dominates C\nDestination Identity that dominates A\nSource Address of B\nDestination Address of A\nProxy Address of C",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For this second SA (for packets flowing from C towards A), node A MUST verify that the inner source address is dominated by the Source Identity for the SA used with those packets. If node A does not do this, an adversary could forge packets with an arbitrary Source Identity and defeat the packet origin protections provided by IPsec.",
      "ja": "この第二のSAのために（CからAに向かって流れるパケットのために）、ノードAは、内部ソースアドレスは、これらのパケットと一緒に使用するためのSAソースアイデンティティによって支配されていることを確認しなければなりません。ノードAは、これを実行しない場合、攻撃者は任意のソースのアイデンティティを持つパケットを偽造とIPsecが提供するパケットの発信元の保護を倒すことができました。"
    },
    {
      "indent": 5,
      "text": "Now consider a slightly more complex case:",
      "ja": "今、もう少し複雑なケースを考えてみます。"
    },
    {
      "indent": 15,
      "text": "A_1 --|                  |-- D_1\n      |--- B ====== C ---|\nA_2 --|                  |-- D_2",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Key:\n          A_n     \"inside\" host on net 1 that does not do IPsec.\n          B       \"firewall\" for net 1 that supports IPsec.\n          C       \"firewall\" for net 2 that supports IPsec.\n          D_n     \"inside\" host on net 2 that does not do IPsec.\n          ===     IP_{B<->C} ESP [ IP_{A<->C} ULP ]\n          ---     IP_{A<->C} ULP",
      "raw": true
    },
    {
      "indent": 11,
      "text": "For A_1 to send a packet to D_1, B and C need an SA with:",
      "ja": "A_1はD_1にパケットを送信するためには、BとCは、SAと必要があります。"
    },
    {
      "indent": 19,
      "text": "SA Type of ESP\nSource Identity that dominates A_1\nDestination Identity that dominates C\nSource Address of B\nDestination Address of C\nProxy Address of A_1",
      "raw": true
    },
    {
      "indent": 11,
      "text": "For D_1 to send a packet to A_1, C and B need an SA with: SA Type of ESP Tunnel-mode Source Identity that dominates D_1 Destination Identity that dominates B Source Address of C Destination Address of B Proxy Address of D_1",
      "ja": "D_1はA_1、CおよびBにパケットを送信するためにとSAを必要とする：D_1のBプロキシアドレスのCの宛先アドレスのBの送信元アドレスを支配D_1先のアイデンティティを支配ESPトンネルモードのソース・アイデンティティのSAタイプ"
    },
    {
      "indent": 3,
      "text": "Note that A_2 and D_2 could be substituted for A_1 and D_1 (respectively) here; the association of an SA with a particular pair of ends or group of those pairs is a policy decision on B and/or C and not necessarily a function of key management. The same check of the Source Identity against the inner source IP address MUST also be performed in this case for the same reason.",
      "ja": "ここで（それぞれ）A_2とD_2はA_1とD_1の代わりに用いることができることに留意されたいです。これらのペアの端部またはグループの特定の対とSAの関連付けは、B及び/又はCと鍵管理の必要はない機能上のポリシー決定です。内側の送信元IPアドレスに対するソースのアイデンティティの同じ検査も同様の理由で、この場合に実行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For a more detailed discussion of the use of IP Security in complex cases, please see [Atk97].",
      "ja": "複雑なケースでのIPセキュリティの使用のより詳細な議論については、[Atk97]を参照してください。"
    },
    {
      "indent": 5,
      "text": "NOTE: The notion of identity domination might be unfamiliar. Let H represent some node. Let Hn represent H's fully qualified domain name. Let Ha represent the IP address of H. Let Hs represent the IP subnet containing Ha. Let Hd represent a fully qualified domain name that is a parent of the fully qualified domain name of H. Let M be a UserFQDN identity that whose right-hand part is Hn or Ha.",
      "ja": "注：アイデンティティ支配の概念はなじみのないかもしれません。 Hは、いくつかのノードを表してみましょう。 HnはHの完全修飾ドメイン名を表してみましょう。ハハを含むIPサブネットを表すH.レッツHsとのIPアドレスを表してみましょう。 HDはH.レッツMの完全修飾ドメイン名の親が右手部分がHnのかハですUserFQDNアイデンティティことで完全修飾ドメイン名を表してみましょう。"
    },
    {
      "indent": 5,
      "text": "Any of M, Hn, Ha, Hs, and Hd is considered to dominate H in the example above. Hs dominates any node having an IP address within the IP address range represented by Hs. Hd dominates any node having a fully qualified domain name within underneath Hd.",
      "ja": "M、Hnを、ハはHS、およびHDのいずれかは、上記の例ではHを支配すると考えられます。 HSは、HSで表されるIPアドレス範囲内のIPアドレスを有する任意のノードを支配します。 HDは、下のHD内の完全修飾ドメイン名を持つ任意のノードを支配します。"
    },
    {
      "indent": 0,
      "text": "5.3 OSPF Security Example",
      "section_title": true,
      "ja": "5.3 OSPFのセキュリティの例"
    },
    {
      "indent": 5,
      "text": "      +---------------+    +-------------+\n      |Key Mgmt Daemon|    | OSPF daemon |\n      +---------------+    +-------------+\n        |           |     /    /        |\n        |    /------|----+    /         |\n        |   /       |    +---+          |           Applications\n======[PF_KEY]====[PF_INET]===========[PF_ROUTE]================\n        |           |    |              |           OS Kernel\n+------------+   +-----------------+  +---------+\n| Key Engine |   | TCP/IP,         |  | Routing |\n|  or  SADB  |---| including IPsec |--| Table   |\n+------------+   |                 |  +---------+\n                 +-----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "As in the previous examples, the KMd registers itself with the Key Engine via PF_KEY. Even though the consumer of the security associations is in user-space, the PF_KEY and Key Engine implementation knows enough to store SAs and to relay messages.",
      "ja": "前の例のように、KMDはPF_KEYを介して主エンジンに自身を登録します。セキュリティアソシエーションの消費者は、ユーザ空間であっても、PF_KEYとキーエンジンの実装では、SAを格納すると、メッセージを中継するために十分に知っています。"
    },
    {
      "indent": 3,
      "text": "When the OSPF daemon needs to communicate securely with its peers, it would perform an SADB_GET message and retrieve the appropriate association:",
      "ja": "OSPFデーモンがそのピアと安全に通信する必要があるとき、それはSADB_GETメッセージを実行し、適切な関連付けを検索するであろう。"
    },
    {
      "indent": 5,
      "text": "OSPFd->Kernel: SADB_GET of OSPF, assoc, addrs Kernel->OSPFd: SADB_GET of OSPF, assoc, addrs, keys, <etc.>",
      "ja": "OSPFd->カーネル：OSPFのSADB_GET、連想、アドレスが使わKernel-> OSPFd：OSPFのSADB_GET、連想、アドレスが使われる、キー、<など>"
    },
    {
      "indent": 3,
      "text": "If this GET fails, the OSPFd may need to acquire a new security association. This interaction is as follows:",
      "ja": "このGETが失敗した場合、OSPFdは、新しいセキュリティアソシエーションを取得する必要があります。次のようにこの相互作用は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "OSPFd->Kernel: SADB_ACQUIRE of OSPF, addrs, <ID, sens,> proposal Kernel->Registered: SADB_ACQUIRE of OSPF, <same as sent message>",
      "ja": "OSPFd->カーネル：OSPFのSADB_ACQUIRE、アドレスが使われる、<ID、SENS、>提案Kernel->登録：OSPFのSADB_ACQUIRE、<送信されたメッセージと同じ>"
    },
    {
      "indent": 3,
      "text": "The KMd sees this and performs actions similar to the previous example. One difference, however, is that when the UPDATE message comes back, the OSPFd will then perform a GET of the updated SA to retrieve all of its parameters.",
      "ja": "KMDはこれを見て、前の例と同様のアクションを実行します。 1つの違いは、しかし、UPDATEメッセージが戻ってきたときに、OSPFdは、そのパラメータのすべてを取得するために、更新SAのGETを実行するということです。"
    },
    {
      "indent": 0,
      "text": "5.4 Miscellaneous",
      "section_title": true,
      "ja": "5.4その他"
    },
    {
      "indent": 3,
      "text": "Some messages work well only in system maintenance programs, for debugging, or for auditing. In a system panic situation, such as a detected compromise, an SADB_FLUSH message should be issued for a particular SA type, or for ALL SA types.",
      "ja": "一部のメッセージは、デバッグのために、または監査のために、唯一のシステムメンテナンスプログラムでうまく機能します。システムパニック状況では、そのような検出された妥協として、SADB_FLUSHメッセージは、特定のSAタイプに対して発行された、またはすべてのSAタイプのなければなりません。"
    },
    {
      "indent": 5,
      "text": "Program->Kernel: SADB_FLUSH for ALL <Kernel then flushes all internal SAs> Kernel->All: SADB_FLUSH for ALL",
      "ja": "プログラム - >カーネル：ALLためSADB_FLUSH <カーネルは、すべての内部SAをフラッシュ> Kernel-> all：すべてのためのSADB_FLUSH"
    },
    {
      "indent": 3,
      "text": "Some SAs may need to be explicitly deleted, either by a KMd, or by a system maintenance program.",
      "ja": "いくつかのSAはKMDによって、またはシステムメンテナンスプログラムのいずれかによって、明示的に削除する必要があるかもしれません。"
    },
    {
      "indent": 5,
      "text": "Program->Kernel: SADB_DELETE for AH, association, addrs Kernel->All: SADB_DELETE for AH, association, addrs",
      "ja": "プログラム - >カーネル：AHのためSADB_DELETE、協会、アドレスが使われる：AH、協会、アドレスが使わKernel->すべてのためのSADB_DELETE"
    },
    {
      "indent": 3,
      "text": "Common usage of the SADB_DUMP message is discouraged. For debugging purposes, however, it can be quite useful. The output of a DUMP message should be read quickly, in order to avoid socket buffer overflows.",
      "ja": "SADB_DUMPメッセージの一般的な使い方はお勧めしません。デバッグのために、しかし、それは非常に便利です。 DUMPメッセージの出力は、ソケットバッファオーバーフローを避けるために、すぐに読まれるべきです。"
    },
    {
      "indent": 5,
      "text": "Program->Kernel: SADB_DUMP for ESP Kernel->Program: SADB_DUMP for ESP, association, <all fields> Kernel->Program: SADB_DUMP for ESP, association, <all fields> Kernel->Program: SADB_DUMP for ESP, association, <all fields> <ad nauseam...>",
      "ja": "プログラム - >カーネル：ESP Kernel-ためSADB_DUMP>プログラム：ESP、関連付けのSADB_DUMP、<すべてのフィールド> Kernel->プログラム：ESP、関連付けのSADB_DUMP、<すべてのフィールド> Kernel->プログラム：ESP、関連付けのSADB_DUMP、<すべてのフィールド> <広告nauseam ...>"
    },
    {
      "indent": 0,
      "text": "6 Security Considerations",
      "ja": "6セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This memo discusses a method for creating, reading, modifying, and deleting Security Associations from an operating system. Only trusted, privileged users and processes should be able to perform any of these operations. It is unclear whether this mechanism provides any security when used with operating systems not having the concept of a trusted, privileged user.",
      "ja": "このメモは、作成、読み取り、修正、およびオペレーティングシステムからセキュリティアソシエーションを削除するための方法を論じています。唯一の信頼できる、特権ユーザーやプロセスはこれらの操作のいずれかを実行することができるはずです。オペレーティング・システムは、信頼できる、特権ユーザの概念を持っていないで使用した場合、このメカニズムがどのようなセキュリティを提供するかどうかは不明です。"
    },
    {
      "indent": 3,
      "text": "If an unprivileged user is able to perform any of these operations, then the operating system cannot actually provide the related security services. If an adversary knows the keys and algorithms in use, then cryptography cannot provide any form of protection.",
      "ja": "特権のないユーザがこれらの操作のいずれかを実行することが可能である場合には、オペレーティングシステムは、実際には関連するセキュリティサービスを提供することはできません。敵が使用中の鍵とアルゴリズムを知っている場合は、暗号は、保護の任意のフォームを提供することはできません。"
    },
    {
      "indent": 3,
      "text": "This mechanism is not a panacea, but it does provide an important operating system component that can be useful in creating a secure internetwork.",
      "ja": "このメカニズムは万能薬ではないが、それは安全なインターネットワークを作成するのに有用であることができ、重要なオペレーティングシステムコンポーネントを提供します。"
    },
    {
      "indent": 3,
      "text": "Users need to understand that the quality of the security provided by an implementation of this specification depends completely upon the overall security of the operating system, the correctness of the PF_KEY implementation, and upon the security and correctness of the applications that connect to PF_KEY. It is appropriate to use high assurance development techniques when implementing PF_KEY and the related security association components of the operating system.",
      "ja": "ユーザーは、この仕様の実装によって提供されるセキュリティの品質は、オペレーティング・システム、PF_KEY実装の正しさの全体的なセキュリティに完全に依存し、PF_KEYに接続するアプリケーションのセキュリティと正確性に応じていることを理解する必要があります。 PF_KEYとオペレーティング・システムの関連するセキュリティアソシエーション・コンポーネントを実装する場合、高保証開発技法を使用することが適切です。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors of this document are listed primarily in alphabetical order. Randall Atkinson and Ron Lee provided useful feedback on earlier versions of this document.",
      "ja": "本書の著者は、主にアルファベット順に表示されます。ランドール・アトキンソンとロン・リーは、このドキュメントの以前のバージョンで有用なフィードバックを提供します。"
    },
    {
      "indent": 3,
      "text": "At one time or other, all of the authors worked at the Center for High Assurance Computer Systems at the U.S. Naval Research Laboratory. This work was sponsored by the Information Security Program Office (PMW-161), U.S. Space and Naval Warfare Systems Command (SPAWAR) and the Computing Systems Technology Office, Defense Advanced Research Projects Agency (DARPA/CSTO). We really appreciate their sponsorship of our efforts and their continued support of PF_KEY development. Without that support, PF_KEY would not exist.",
      "ja": "1時間または他には、著者のすべては、米国海軍研究所で高保証コンピュータシステムのためのセンターで働いていました。この作品は、情報セキュリティプログラムオフィス（PMW-161）、米国宇宙海戦システムコマンド（SPAWAR）とコンピューティングシステム技術事務所、米国防総省の国防高等研究計画庁（DARPA / CSTO）が主催ました。私たちは本当に私たちの努力の彼らのスポンサーとPF_KEY開発の彼らの継続的な支援に感謝しています。その支援がなければ、PF_KEYは存在しません。"
    },
    {
      "indent": 3,
      "text": "The \"CONFORMANCE and COMPLIANCE\" wording was taken from [MSST98].",
      "ja": "「CONFORMANCEとコンプライアンス」の文言は、[MSST98]から取られました。"
    },
    {
      "indent": 3,
      "text": "Finally, the authors would like to thank those who sent in comments and questions on the various iterations of this document. This specification and implementations of it are discussed on the PF_KEY mailing list. If you would like to be added to this list, send a note to <pf_key-request@inner.net>.",
      "ja": "最後に、著者は、この文書の様々なイテレーションのコメントや質問に送られた人たちに感謝したいと思います。この仕様とその実装は、PF_KEYのメーリングリストで議論されています。あなたはこのリストに追加することを希望される場合は、<pf_key-request@inner.net>にメモを送ります。"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "リファレンス"
    },
    {
      "indent": 3,
      "text": "[AMPMC96] Randall J. Atkinson, Daniel L. McDonald, Bao G. Phan, Craig W. Metz, and Kenneth C. Chin, \"Implementation of IPv6 in 4.4-Lite BSD\", Proceedings of the 1996 USENIX Conference, San Diego, CA, January 1996, USENIX Association.",
      "ja": "[AMPMC96]ランドール・J・アトキンソン、ダニエル・L.マクドナルド、バオG. Phanさん、クレイグW.メッツ、およびケネスC.チン、 \"4.4-LiteのBSDでのIPv6の実装\"、1996 USENIX会議、サンディエゴの議事録を、 CA、1996年1月、USENIX協会。"
    },
    {
      "indent": 3,
      "text": "[Atk95a] Atkinson, R., \"IP Security Architecture\", RFC 1825, August 1995.",
      "ja": "[Atk95a]アトキンソン、R.、 \"IPセキュリティアーキテクチャ\"、RFC 1825、1995年8月。"
    },
    {
      "indent": 3,
      "text": "[Atk95b] Atkinson, R., \"IP Authentication Header\", RFC 1826, August 1995.",
      "ja": "[Atk95b]アトキンソン、R.、 \"IP認証ヘッダー\"、RFC 1826、1995年8月。"
    },
    {
      "indent": 3,
      "text": "[Atk95c] Atkinson, R., \"IP Encapsulating Security Payload\", RFC 1827, August 1995.",
      "ja": "[Atk95c]アトキンソン、R.、 \"IPカプセル化セキュリティペイロード\"、RFC 1827、1995年8月。"
    },
    {
      "indent": 3,
      "text": "[Atk97] Atkinson, R., \"Key Exchange Delegation Record for the Domain Name System\", RFC 2230, October 1997.",
      "ja": "[Atk97]アトキンソン、R.、 \"ドメインネームシステムのための鍵交換委任録音\"、RFC 2230、1997年10月。"
    },
    {
      "indent": 3,
      "text": "[BA97] Baker, F., and R. Atkinson, \"RIP-2 MD5 Authentication\", RFC 2082, January 1997.",
      "ja": "[BA97]ベーカー、F.、およびR.アトキンソン、 \"RIP-2 MD5認証\"、RFC 2082、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[Biba77] K. J. Biba, \"Integrity Considerations for Secure Computer Systems\", MTR-3153, The MITRE Corporation, June 1975; ESD-TR-76-372, April 1977.",
      "ja": "【Biba77] K. J.ビバ、「安全なコンピュータシステムのための整合性の考慮事項」、MTR-3153、MITRE社、1975年6月。 ESD-TR-76から372、1977年4月。"
    },
    {
      "indent": 3,
      "text": "[BL74] D. Elliot Bell and Leonard J. LaPadula, \"Secure Computer Systems: Unified Exposition and Multics Interpretation\", MTR 2997, The MITRE Corporation, April 1974. (AD/A 020 445)",
      "ja": "[BL74] D.エリオット・ベルとレオナルド・J. LaPadula、 \"コンピュータシステムをセキュア：統一博覧会とのMultics解釈\"、MTR 2997、MITRE社、4月1974（AD / 020 445）"
    },
    {
      "indent": 3,
      "text": "[Bra97] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[Bra97]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[CW87] D. D. Clark and D. R. Wilson, \"A Comparison of Commercial and Military Computer Security Policies\", Proceedings of the 1987 Symposium on Security and Privacy, pp. 184-195, IEEE Computer Society, Washington, D.C., 1987.",
      "ja": "[CW87] D. D.クラークとD. R.ウィルソン、「商用および軍用コンピュータセキュリティポリシーの比較」、セキュリティ上の1987シンポジウムやプライバシー、頁184から195、IEEEコンピュータ学会、ワシントン、D.C.、1987。"
    },
    {
      "indent": 3,
      "text": "[DIA] US Defense Intelligence Agency (DIA), \"Compartmented Mode Workstation Specification\", Technical Report DDS-2600-6243-87.",
      "ja": "[DIA]米国防情報局（DIA）、 \"コンパートメントモードワークステーションの仕様\"、技術報告書DDS-2600-6243-87。"
    },
    {
      "indent": 3,
      "text": "[GK98] Glenn, R., and S. Kent, \"The NULL Encryption Algorithm and Its Use with IPsec\", Work in Progress.",
      "ja": "[GK98]グレン、R.、およびS.ケント、「NULL暗号化アルゴリズムとIPsecでの使用」が進行中で働いています。"
    },
    {
      "indent": 3,
      "text": "[HM97a] Harney, H., and C. Muckenhirn, \"Group Key Management Protocol (GKMP) Specification\", RFC 2093, July 1997.",
      "ja": "[HM97a]ハーニー、H.、およびC. Muckenhirn、 \"グループ鍵管理プロトコル（GKMP）仕様\"、RFC 2093、1997年7月。"
    },
    {
      "indent": 3,
      "text": "[HM97b] Harney, H., and C. Muckenhirn, \"Group Key Management Protocol (GKMP) Architecture\", RFC 2094, July 1997.",
      "ja": "[HM97b]ハーニー、H.、およびC. Muckenhirn、 \"グループ鍵管理プロトコル（GKMP）アーキテクチャ\"、RFC 2094、1997年7月。"
    },
    {
      "indent": 3,
      "text": "[MD98] Madsen, C., and N. Doraswamy, \"The ESP DES-CBC Cipher Algorithm With Explicit IV\", Work in Progress.",
      "ja": "[MD98]マドセン、C.、およびN. Doraswamy、 \"明示的なIVとESP DES-CBC暗号アルゴリズム\" が進行中で働いています。"
    },
    {
      "indent": 3,
      "text": "[MG98a] Madsen, C., and R. Glenn, \"The Use of HMAC-MD5-96 within ESP and AH\", Work in Progress.",
      "ja": "[MG98a]マドセン、C.、およびR.グレン、 \"ESPおよびAH内のHMAC-MD5-96の使用\" が進行中で働いています。"
    },
    {
      "indent": 3,
      "text": "[MG98b] Madsen, C., and R. Glenn, \"The Use of HMAC-SHA-1-96 within ESP and AH\", Work in Progress.",
      "ja": "【MG98b]マドセン、C.、およびR.グレン、 \"HMAC-SHA-1-96 ESPおよびAH内の使用\"、ProgressのWork。"
    },
    {
      "indent": 3,
      "text": "[MSST98] Maughan, D., Schertler, M., Schneider, M., and J. Turner, \"Internet Security Association and Key Management Protocol (ISAKMP)\", Work in Progress.",
      "ja": "[MSST98]モーガン、D.、Schertler、M.、シュナイダー、M.、およびJ.ターナー、 \"インターネットセキュリティ協会と鍵管理プロトコル（ISAKMP）\" が進行中で働いています。"
    },
    {
      "indent": 3,
      "text": "[Moy98] Moy, J., \"OSPF Version 2\", STD 54, RFC 2328, April 1998.",
      "ja": "【Moy98】モイ、J.、 \"OSPFバージョン2\"、STD 54、RFC 2328、1998年4月。"
    },
    {
      "indent": 3,
      "text": "[Per97] Perkins, C., \"IP Mobility Support\", RFC 2002, October 1996.",
      "ja": "[Per97]パーキンス、C.、 \"IPモビリティサポート\"、RFC 2002、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[Pip98] Piper, D., \"The Internet IP Security Domain of Interpretation for ISAKMP\", Work in Progress.",
      "ja": "[Pip98]パイパー、D.、「ISAKMPのための解釈のインターネットIPセキュリティー領域」が進行中で働いています。"
    },
    {
      "indent": 3,
      "text": "[Sch96] Bruce Schneier, Applied Cryptography, p. 360, John Wiley & Sons, Inc., 1996.",
      "ja": "[Sch96]ブルース・シュナイアー、応用暗号、P。 360、John Wiley＆Sons社、1996年。"
    },
    {
      "indent": 3,
      "text": "[Skl91] Keith Sklower, \"A Tree-based Packet Routing Table for Berkeley UNIX\", Proceedings of the Winter 1991 USENIX Conference, Dallas, TX, USENIX Association. 1991. pp. 93-103.",
      "ja": "[Skl91]キースSklower、「バークレーUNIX用のツリーベースのパケットルーティングテーブル」、冬の1991 USENIX会議、ダラス、TX、USENIX協会の議事。 1991頁。93-103。"
    },
    {
      "indent": 0,
      "text": "Disclaimer",
      "ja": "免責条項"
    },
    {
      "indent": 3,
      "text": "The views and specification here are those of the editors and are not necessarily those of their employers. The employers have not passed judgment on the merits, if any, of this work. The editors and their employers specifically disclaim responsibility for any problems arising from correct or incorrect implementation or use of this specification.",
      "ja": "ここでビューと仕様は、編集者のものであり、必ずしもその雇用者のそれではありません。雇用者は、この作品であれば、本案の判断を経過していません。編集者とその雇用者は、具体的に正しいか正しくないの実装や、この仕様の利用から生じるいかなる問題の責任を負いかねます。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Daniel L. McDonald Sun Microsystems, Inc. 901 San Antonio Road, MS UMPK17-202 Palo Alto, CA 94303",
      "ja": "ダニエル・L.マクドナルドサン・マイクロシステムズ社901サンアントニオの道、MS UMPK17-202パロアルト、CA 94303"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 786 6815 EMail: danmcd@eng.sun.com",
      "ja": "電話：+1 650 786 6815 Eメール：danmcd@eng.sun.com"
    },
    {
      "indent": 3,
      "text": "Craig Metz (for Code 5544) U.S. Naval Research Laboratory 4555 Overlook Ave. SW Washington, DC 20375",
      "ja": "クレイグ・メッツ（コード5544用）、米国海軍研究所4555オーバールックアベニュー。 SWワシントンD.C. 20375"
    },
    {
      "indent": 3,
      "text": "Phone: (DSN) 754-8590 EMail: cmetz@inner.net",
      "ja": "電話番号：（DSN）754から8590 Eメール：cmetz@inner.net"
    },
    {
      "indent": 3,
      "text": "Bao G. Phan U. S. Naval Research Laboratory",
      "ja": "バオG.ファンティエット米国海軍研究所"
    },
    {
      "indent": 3,
      "text": "EMail: phan@itd.nrl.navy.mil",
      "ja": "メールアドレス：phan@itd.nrl.navy.mil"
    },
    {
      "indent": 0,
      "text": "Appendix A: Promiscuous Send/Receive Message Type",
      "ja": "付録A：無差別送信/受信メッセージの種類"
    },
    {
      "indent": 3,
      "text": "A kernel supporting PF_KEY MAY implement the following extension for development and debugging purposes. If it does, it MUST implement the extension as specified here. An implementation MAY require an application to have additional privileges to perform promiscuous send and/or receive operations.",
      "ja": "PF_KEYをサポートするカーネルは、開発とデバッグの目的のために、以下の拡張を実施することができます。それがない場合は、ここで指定されているように、拡張を実装しなければなりません。実装は無差別送信を実行するために追加の権限を持っているアプリケーションを必要とする、および/または操作を受け取ることができます。"
    },
    {
      "indent": 3,
      "text": "The SADB_X_PROMISC message allows an application to send and receive messages in a \"promiscuous mode.\" There are two forms of this message: control and data. The control form consists of only a message header. This message is used to toggle the promiscuous-receive function. A value of one in the sadb_msg_satype field enables promiscuous message reception for this socket, while a value of zero in that field disables it.",
      "ja": "SADB_X_PROMISCメッセージは、アプリケーションがでメッセージを送受信することを可能にする「無差別モード。」制御とデータ：このメッセージの2つの形式があります。制御形態は、メッセージヘッダから成ります。このメッセージは、プロミスキャス・受信機能を切り替えるために使用されます。そのフィールドにゼロの値は、それを無効にしながらsadb_msg_satypeフィールド内の1つの値は、このソケットの無差別メッセージ受信を可能にします。"
    },
    {
      "indent": 3,
      "text": "The second form of this message is the data form. This is used to send or receive messages in their raw form. Messages in the data form consist of a message header followed by an entire new message. There will be two message headers in a row: one for the SADB_X_PROMISC message, and one for the payload message.",
      "ja": "このメッセージの第二の形態は、データ形式です。これは、彼らの生の形式でメッセージを送信または受信するために使用されます。データ形式のメッセージは、全体新しいメッセージに続くメッセージヘッダから成ります。 SADB_X_PROMISCメッセージのための1つ、およびペイロードメッセージのいずれかの行の2つのメッセージ・ヘッダが存在するであろう。"
    },
    {
      "indent": 3,
      "text": "Data messages sent from the application are sent to either the PF_KEY socket of a single process identified by a nonzero sadb_msg_seq or to all PF_KEY sockets if sadb_msg_seq is zero. These messages are sent without any processing of their contents by the PF_KEY interface (including sanity checking). This promiscuous-send capability allows an application to send messages as if it were the kernel. This also allows it to send erroneous messages.",
      "ja": "アプリケーションから送られたデータメッセージはsadb_msg_seqがゼロの場合、ゼロ以外sadb_msg_seqによって、または全てPF_KEYソケットに識別された単一のプロセスのPF_KEYソケットのいずれかに送られます。これらのメッセージは、（健全性チェックを含む）PF_KEYインタフェースによりその内容の処理を行わずに送信されます。この無差別-SEND機能は、それがカーネルであるかのようにアプリケーションがメッセージを送信することができます。また、これは誤ったメッセージを送ることができます。"
    },
    {
      "indent": 3,
      "text": "If the promiscuous-receive function has been enabled, a copy of any message sent via PF_KEY by another application or by the kernel is sent to the promiscuous application. This is done before any processing of the message's contents by the PF_KEY interface (again, including sanity checking). This promiscuous-receive capability allows an application to receive all messages sent by other parties using PF_KEY.",
      "ja": "無差別-受信機能が有効になっている場合は、別のアプリケーションによってまたはカーネルによってPF_KEYを経由して送信されたメッセージのコピーが無差別アプリケーションに送信されます。これは（再び、正気のチェックを含む）PF_KEYインタフェースにより、メッセージの内容のいずれかの処理の前に行われます。この無差別-受信機能は、アプリケーションがPF_KEYを使用して他の当事者によって送信されたすべてのメッセージを受け取ることができます。"
    },
    {
      "indent": 5,
      "text": "The messaging behavior of the SADB_X_PROMISC message is:",
      "ja": "SADB_X_PROMISCメッセージのメッセージングの動作は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "Send a control-form SADB_X_PROMISC message from a user process\nto the kernel.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "<base>",
      "ja": "<ベース>"
    },
    {
      "indent": 9,
      "text": "The kernel returns the SADB_X_PROMISC message to all listening processes.",
      "ja": "カーネルは、すべてのリスニングプロセスにSADB_X_PROMISCメッセージを返します。"
    },
    {
      "indent": 9,
      "text": "<base>",
      "ja": "<ベース>"
    },
    {
      "indent": 9,
      "text": "Send a data-form SADB_X_PROMISC message from a user process to the kernel.",
      "ja": "カーネルにユーザプロセスからのデータ形式SADB_X_PROMISCメッセージを送信します。"
    },
    {
      "indent": 9,
      "text": "<base, base(, others)>",
      "ja": "<塩基、塩基（他人）>"
    },
    {
      "indent": 9,
      "text": "The kernel sends the encapsulated message to the target process(s).",
      "ja": "カーネルは、ターゲット・プロセス（複数可）にカプセル化されたメッセージを送信します。"
    },
    {
      "indent": 9,
      "text": "<base(, others)>",
      "ja": "<塩基（他人）>"
    },
    {
      "indent": 9,
      "text": "If promiscuous-receive is enabled, the kernel will encapsulate and send copies of all messages sent via the PF_KEY interface.",
      "ja": "無差別-受信が有効になっている場合、カーネルは、カプセル化し、PF_KEYインタフェースを介して送信されたすべてのメッセージのコピーを送信します。"
    },
    {
      "indent": 9,
      "text": "<base, base(, others)>",
      "ja": "<塩基、塩基（他人）>"
    },
    {
      "indent": 5,
      "text": "Errors: EPERM Additional privileges are required to perform the requested operations. ESRCH (Data form, sending) The target process in sadb_msg_seq does not exist or does not have an open PF_KEY Version 2 socket.",
      "ja": "エラー：EPERM追加の権限が要求された操作を実行するために必要とされています。 ESRCH（データ形式、送信）sadb_msg_seqにおけるターゲット・プロセスが存在しないか、またはオープンPF_KEY Version 2のソケットを持っていません。"
    },
    {
      "indent": 0,
      "text": "Appendix B: Passive Change Message Type",
      "ja": "付録B：パッシブ変更メッセージタイプ"
    },
    {
      "indent": 3,
      "text": "The SADB_X_PCHANGE message is a passive-side (aka. the \"listener\" or \"receiver\") counterpart to the SADB_ACQUIRE message. It is useful for when key management applications wish to more effectively handle incoming key management requests for passive-side sessions that deviate from systemwide default security services. If a passive session requests that only certain levels of security service be allowed, the SADB_X_PCHANGE message expresses this change to any registered PF_KEY sockets. Unlike SADB_ACQUIRE, this message is purely informational, and demands no other PF_KEY interaction.",
      "ja": "SADB_X_PCHANGEメッセージは、受動側（別名「リスナー」または「レシーバ」）SADB_ACQUIREメッセージに対応します。鍵管理アプリケーションをより効果的にシステム全体のデフォルトのセキュリティサービスから外れるパッシブ側のセッションの着信キー管理要求を処理したいときに便利です。セキュリティサービスの唯一の特定のレベルが許可される受動的なセッションを要求した場合、SADB_X_PCHANGEメッセージは、任意の登録PF_KEYソケットへのこの変化を表します。 SADB_ACQUIREとは異なり、このメッセージは純粋に情報であり、他のPF_KEYとの対話を要求しません。"
    },
    {
      "indent": 3,
      "text": "The SADB_X_PCHANGE message is typically triggered by either a change in an endpoint's requested security services, or when an endpoint that made a special request disappears. In the former case, an SADB_X_PCHANGE looks like an SADB_ACQUIRE, complete with an sadb_proposal extension indicating the preferred algorithms, lifetimes, and other attributes. When a passive session either disappears, or reverts to a default behavior, an SADB_X_PCHANGE will be issued with _no_ sadb_proposal extension, indicating that the exception to systemwide default behavior has disappeared.",
      "ja": "SADB_X_PCHANGEメッセージは通常、エンドポイントの要求されたセキュリティサービスの変更、または時に特別な要求をしたエンドポイントが消えるのいずれかによってトリガされます。前者の場合、SADB_X_PCHANGEは好ましいアルゴリズム、寿命、及び他の属性を示すsadb_proposal拡張子を持つ完全SADB_ACQUIRE、のように見えます。受動的なセッションが消える、またはデフォルトの動作に戻りいずれかの場合には、SADB_X_PCHANGEは、システム全体のデフォルトの動作に例外が消滅したことを示す、_no_ sadb_proposal拡張子が発行されます。"
    },
    {
      "indent": 3,
      "text": "There are two messaging behaviors for SADB_X_PCHANGE. The first is the kernel-originated case:",
      "ja": "SADB_X_PCHANGEのための2つのメッセージング行動があります。最初はカーネル発のケースです。"
    },
    {
      "indent": 8,
      "text": "The kernel sends an SADB_X_PCHANGE message to registered\nsockets.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "<base, address(SD), (identity(SD),) (sensitivity,) (proposal)>",
      "ja": "<ベースアドレス（SD）、（アイデンティティ（SD））（感度）（案）>"
    },
    {
      "indent": 8,
      "text": "NOTE: The address(SD) extensions MUST have the port fields filled in with the port numbers of the session requiring keys if appropriate.",
      "ja": "注：アドレス（SD）の拡張機能は、適切な場合には、キーを必要とするセッションのポート番号で埋めポートフィールドを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "The second is for a user-level consumer of SAs.",
      "ja": "第二は、SASのユーザーレベルの消費者のためのものです。"
    },
    {
      "indent": 8,
      "text": "Send an SADB_X_PCHANGE message from a user process to the\nkernel.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "<base, address(SD), (identity(SD),) (sensitivity,) (proposal)>",
      "ja": "<ベースアドレス（SD）、（アイデンティティ（SD））（感度）（案）>"
    },
    {
      "indent": 8,
      "text": "The kernel returns an SADB_X_PCHANGE message to registered sockets.",
      "ja": "カーネルは、登録されたソケットにSADB_X_PCHANGEメッセージを返します。"
    },
    {
      "indent": 8,
      "text": "<base, address(SD), (identity(SD),) (sensitivity,) (proposal)>",
      "ja": "<ベースアドレス（SD）、（アイデンティティ（SD））（感度）（案）>"
    },
    {
      "indent": 0,
      "text": "Appendix C: Key Management Private Data Extension",
      "ja": "付録C：キー管理プライベートデータ拡張"
    },
    {
      "indent": 3,
      "text": "The Key Management Private Data extension is attached to either an SADB_ADD or an SADB_UPDATE message. It attaches a single piece of arbitrary data to a security association. It may be useful for key managment applications that could use an SADB_DUMP or SADB_GET message to obtain additional state if it needs to restart or recover after a crash. The format of this extension is:",
      "ja": "キー管理プライベートデータの拡張子はSADB_ADDまたはSADB_UPDATEメッセージのいずれかに取り付けられています。これは、セキュリティアソシエーションに、任意の単一のデータを添付します。それが再起動するか、クラッシュ後に回復する必要がある場合は、追加の状態を取得するためにSADB_DUMPまたはSADB_GETメッセージを使用することができ、キー経営管理論の適用のために有用である可能性があります。この拡張機能の形式は次のとおりです。"
    },
    {
      "indent": 11,
      "text": "#define SADB_X_EXT_KMPRIVATE 17",
      "ja": "#define SADB_X_EXT_KMPRIVATE 17"
    },
    {
      "indent": 11,
      "text": "struct sadb_x_kmprivate {\n        uint16_t sadb_x_kmprivate_len;\n        uint16_t sadb_x_kmprivate_exttype;\n        uint32_t sadb_x_kmprivate_reserved;\n};\n/* sizeof(struct sadb_x_kmprivate) == 8 */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* followed by arbitrary data */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The data following the sadb_x_kmprivate extension can be anything. It will be stored with the actual security association in the kernel. Like all data, it must be padded to an eight byte boundary.",
      "ja": "sadb_x_kmprivate拡張以下のデータは何もすることができます。これは、カーネル内の実際のセキュリティアソシエーションで保存されます。すべてのデータのように、それは8つのバイト境界に水増しされなければなりません。"
    },
    {
      "indent": 0,
      "text": "Appendix D: Sample Header File",
      "ja": "付録D：サンプルヘッダーファイル"
    },
    {
      "indent": 3,
      "text": "/*\nThis file defines structures and symbols for the PF_KEY Version 2\nkey management interface. It was written at the U.S. Naval Research\nLaboratory. This file is in the public domain. The authors ask that\nyou leave this credit intact on any copies of this file.\n*/\n#ifndef __PFKEY_V2_H\n#define __PFKEY_V2_H 1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define PF_KEY_V2 2 #define PFKEYV2_REVISION 199806L",
      "ja": "#define PF_KEY_V2 2の#define PFKEYV2_REVISION 199806L"
    },
    {
      "indent": 3,
      "text": "#define SADB_RESERVED 0 #define SADB_GETSPI 1 #define SADB_UPDATE 2 #define SADB_ADD 3 #define SADB_DELETE 4 #define SADB_GET 5 #define SADB_ACQUIRE 6 #define SADB_REGISTER 7 #define SADB_EXPIRE 8 #define SADB_FLUSH 9 #define SADB_DUMP 10 #define SADB_X_PROMISC 11 #define SADB_X_PCHANGE 12 #define SADB_MAX 12",
      "ja": "#define SADB_RESERVED 0の#define SADB_GETSPI 1の#define SADB_UPDATE 2の#define SADB_ADD 3の#define SADB_DELETE 4の#define SADB_GET 5の#define SADB_ACQUIRE 6の#define SADB_REGISTER 7の#define SADB_EXPIRE 8の#define SADB_FLUSH 9の#define SADB_DUMP 10の#define SADB_X_PROMISC 11の#define SADB_X_PCHANGE 12の#define SADB_MAX 12"
    },
    {
      "indent": 3,
      "text": "struct sadb_msg {\n  uint8_t sadb_msg_version;\n  uint8_t sadb_msg_type;\n  uint8_t sadb_msg_errno;\n  uint8_t sadb_msg_satype;\n  uint16_t sadb_msg_len;\n  uint16_t sadb_msg_reserved;\n  uint32_t sadb_msg_seq;\n  uint32_t sadb_msg_pid;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_ext {\n  uint16_t sadb_ext_len;\n  uint16_t sadb_ext_type;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_sa {\n  uint16_t sadb_sa_len;\n  uint16_t sadb_sa_exttype;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  uint32_t sadb_sa_spi;\n  uint8_t sadb_sa_replay;\n  uint8_t sadb_sa_state;\n  uint8_t sadb_sa_auth;\n  uint8_t sadb_sa_encrypt;\n  uint32_t sadb_sa_flags;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_lifetime {\n  uint16_t sadb_lifetime_len;\n  uint16_t sadb_lifetime_exttype;\n  uint32_t sadb_lifetime_allocations;\n  uint64_t sadb_lifetime_bytes;\n  uint64_t sadb_lifetime_addtime;\n  uint64_t sadb_lifetime_usetime;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_address {\n  uint16_t sadb_address_len;\n  uint16_t sadb_address_exttype;\n  uint8_t sadb_address_proto;\n  uint8_t sadb_address_prefixlen;\n  uint16_t sadb_address_reserved;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_key {\n  uint16_t sadb_key_len;\n  uint16_t sadb_key_exttype;\n  uint16_t sadb_key_bits;\n  uint16_t sadb_key_reserved;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_ident {\n  uint16_t sadb_ident_len;\n  uint16_t sadb_ident_exttype;\n  uint16_t sadb_ident_type;\n  uint16_t sadb_ident_reserved;\n  uint64_t sadb_ident_id;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_sens {\n  uint16_t sadb_sens_len;\n  uint16_t sadb_sens_exttype;\n  uint32_t sadb_sens_dpd;\n  uint8_t sadb_sens_sens_level;\n  uint8_t sadb_sens_sens_len;\n  uint8_t sadb_sens_integ_level;\n  uint8_t sadb_sens_integ_len;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  uint32_t sadb_sens_reserved;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_prop {\n  uint16_t sadb_prop_len;\n  uint16_t sadb_prop_exttype;\n  uint8_t sadb_prop_replay;\n  uint8_t sadb_prop_reserved[3];\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_comb {\n  uint8_t sadb_comb_auth;\n  uint8_t sadb_comb_encrypt;\n  uint16_t sadb_comb_flags;\n  uint16_t sadb_comb_auth_minbits;\n  uint16_t sadb_comb_auth_maxbits;\n  uint16_t sadb_comb_encrypt_minbits;\n  uint16_t sadb_comb_encrypt_maxbits;\n  uint32_t sadb_comb_reserved;\n  uint32_t sadb_comb_soft_allocations;\n  uint32_t sadb_comb_hard_allocations;\n  uint64_t sadb_comb_soft_bytes;\n  uint64_t sadb_comb_hard_bytes;\n  uint64_t sadb_comb_soft_addtime;\n  uint64_t sadb_comb_hard_addtime;\n  uint64_t sadb_comb_soft_usetime;\n  uint64_t sadb_comb_hard_usetime;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_supported {\n  uint16_t sadb_supported_len;\n  uint16_t sadb_supported_exttype;\n  uint32_t sadb_supported_reserved;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_alg {\n  uint8_t sadb_alg_id;\n  uint8_t sadb_alg_ivlen;\n  uint16_t sadb_alg_minbits;\n  uint16_t sadb_alg_maxbits;\n  uint16_t sadb_alg_reserved;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_spirange {\n  uint16_t sadb_spirange_len;\n  uint16_t sadb_spirange_exttype;\n  uint32_t sadb_spirange_min;\n  uint32_t sadb_spirange_max;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  uint32_t sadb_spirange_reserved;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sadb_x_kmprivate {\n  uint16_t sadb_x_kmprivate_len;\n  uint16_t sadb_x_kmprivate_exttype;\n  uint32_t sadb_x_kmprivate_reserved;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "#define SADB_EXT_RESERVED 0 #define SADB_EXT_SA 1 #define SADB_EXT_LIFETIME_CURRENT 2 #define SADB_EXT_LIFETIME_HARD 3 #define SADB_EXT_LIFETIME_SOFT 4 #define SADB_EXT_ADDRESS_SRC 5 #define SADB_EXT_ADDRESS_DST 6 #define SADB_EXT_ADDRESS_PROXY 7 #define SADB_EXT_KEY_AUTH 8 #define SADB_EXT_KEY_ENCRYPT 9 #define SADB_EXT_IDENTITY_SRC 10 #define SADB_EXT_IDENTITY_DST 11 #define SADB_EXT_SENSITIVITY 12 #define SADB_EXT_PROPOSAL 13 #define SADB_EXT_SUPPORTED_AUTH 14 #define SADB_EXT_SUPPORTED_ENCRYPT 15 #define SADB_EXT_SPIRANGE 16 #define SADB_X_EXT_KMPRIVATE 17 #define SADB_EXT_MAX 17 #define SADB_SATYPE_UNSPEC 0 #define SADB_SATYPE_AH 2 #define SADB_SATYPE_ESP 3 #define SADB_SATYPE_RSVP 5 #define SADB_SATYPE_OSPFV2 6 #define SADB_SATYPE_RIPV2 7 #define SADB_SATYPE_MIP 8 #define SADB_SATYPE_MAX 8",
      "ja": "#define SADB_EXT_RESERVED 0の#define SADB_EXT_SA 1の#define SADB_EXT_LIFETIME_CURRENT 2の#define SADB_EXT_LIFETIME_HARD 3の#define SADB_EXT_LIFETIME_SOFT 4の#define SADB_EXT_ADDRESS_SRC 5の#define SADB_EXT_ADDRESS_DST 6の#define SADB_EXT_ADDRESS_PROXY 7の#define SADB_EXT_KEY_AUTH 8の#define SADB_EXT_KEY_ENCRYPT 9の#define SADB_EXT_IDENTITY_SRC 10の#define SADB_EXT_IDENTITY_DST 11の#define SADB_EXT_SENSITIVITY 12の#define SADB_EXT_PROPOSAL 13の#define SADB_EXT_SUPPORTED_AUTH 14の#define SADB_EXT_SUPPORTED_ENCRYPT 15の#define SADB_EXT_SPIRANGE 16の#define SADB_X_EXT_KMPRIVATE 17の#define SADB_EXT_MAX 17の#define SADB_SATYPE_UNSPEC 0の#define SADB_SATYPE_AH 2の#define SADB_SATYPE_ESP 3の#define SADB_SATYPE_RSVP 5の#define SADB_SATYPE_OSPFV2 6の#define SADB_SATYPE_RIPV2 7 #define SADB_SATYPE_MIP 8の#define SADB_SATYPE_MAX 8"
    },
    {
      "indent": 3,
      "text": "#define SADB_SASTATE_LARVAL 0 #define SADB_SASTATE_MATURE 1 #define SADB_SASTATE_DYING 2 #define SADB_SASTATE_DEAD 3 #define SADB_SASTATE_MAX 3",
      "ja": "#define SADB_SASTATE_LARVAL 0の#define SADB_SASTATE_MATURE 1の#define SADB_SASTATE_DYING 2の#define SADB_SASTATE_DEAD 3の#define SADB_SASTATE_MAX 3"
    },
    {
      "indent": 3,
      "text": "#define SADB_SAFLAGS_PFS 1",
      "ja": "#define SADB_SAFLAGS_PFS 1"
    },
    {
      "indent": 3,
      "text": "#define SADB_AALG_NONE 0 #define SADB_AALG_MD5HMAC 2 #define SADB_AALG_SHA1HMAC 3",
      "ja": "#define SADB_AALG_NONE 0の#define SADB_AALG_MD5HMAC 2の#define SADB_AALG_SHA1HMAC 3"
    },
    {
      "indent": 3,
      "text": "#define SADB_AALG_MAX 3",
      "ja": "#define SADB_AALG_MAX 3"
    },
    {
      "indent": 3,
      "text": "#define SADB_EALG_NONE 0 #define SADB_EALG_DESCBC 2 #define SADB_EALG_3DESCBC 3 #define SADB_EALG_NULL 11 #define SADB_EALG_MAX 11",
      "ja": "#define SADB_EALG_NONE 0の#define SADB_EALG_DESCBC 2の#define SADB_EALG_3DESCBC 3の#define SADB_EALG_NULL 11の#define SADB_EALG_MAX 11"
    },
    {
      "indent": 3,
      "text": "#define SADB_IDENTTYPE_RESERVED 0 #define SADB_IDENTTYPE_PREFIX 1 #define SADB_IDENTTYPE_FQDN 2 #define SADB_IDENTTYPE_USERFQDN 3 #define SADB_IDENTTYPE_MAX 3",
      "ja": "#define SADB_IDENTTYPE_RESERVED 0の#define SADB_IDENTTYPE_PREFIX 1の#define SADB_IDENTTYPE_FQDN 2の#define SADB_IDENTTYPE_USERFQDN 3の#define SADB_IDENTTYPE_MAX 3"
    },
    {
      "indent": 3,
      "text": "#define SADB_KEY_FLAGS_MAX 0\n#endif /* __PFKEY_V2_H */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix E: Change Log",
      "ja": "付録E：変更ログ"
    },
    {
      "indent": 3,
      "text": "The following changes were made between 05 and 06:",
      "ja": "次の変更は、05と06の間で行われました。"
    },
    {
      "indent": 3,
      "text": "* Last change before becoming an informational RFC. Removed all Internet-Draft references. Also standardized citation strings. Now cite RFC 2119 for MUST, etc.",
      "ja": "*情報のRFCなる前に最後の変更。すべてのインターネットドラフトの参照を削除しました。また、引用文字列を標準化しました。さてなど、MUSTのためのRFC 2119を引用"
    },
    {
      "indent": 3,
      "text": "* New appendix on optional KM private data extension.",
      "ja": "*オプションのKMプライベートデータの拡張子の新しい付録。"
    },
    {
      "indent": 3,
      "text": "* Fixed example to indicate the ACQUIRE messages with errno mean KM failure.",
      "ja": "* KMの失敗を意味し、errnoにACQUIREメッセージを示すために例を修正しました。"
    },
    {
      "indent": 3,
      "text": "* Added SADB_EALG_NULL.",
      "ja": "*追加SADB_EALG_NULL。"
    },
    {
      "indent": 3,
      "text": "* Clarified proxy examples to match definition of PROXY address being the inner packet's source address. (Basically a sign-flip. The example still shows how to protect against policy vulnerabilities in tunnel endpoints.)",
      "ja": "*内側のパケットの送信元アドレスであることPROXYアドレスの定義と一致するように、プロキシの例を明らかにしました。 （基本的に符号フリップフロッ。例はまだトンネルエンドポイントでポリシーの脆弱性から保護する方法を示しています。）"
    },
    {
      "indent": 3,
      "text": "* Loosened definition of a destination address to include broadcast.",
      "ja": "*放送が含まれるように、宛先アドレスの定義を緩み。"
    },
    {
      "indent": 3,
      "text": "* Recommended that LARVAL security associations have implicit short lifetimes.",
      "ja": "*幼生セキュリティアソシエーションが暗黙の短い寿命を持っていることを推奨。"
    },
    {
      "indent": 3,
      "text": "The following changes were made between 04 and 05:",
      "ja": "次の変更は、04と05の間で行われました。"
    },
    {
      "indent": 3,
      "text": "* New appendix on Passive Change message.",
      "ja": "*パッシブの変更メッセージの新しい付録。"
    },
    {
      "indent": 3,
      "text": "* New sadb_address_prefixlen field.",
      "ja": "*新しいsadb_address_prefixlenフィールド。"
    },
    {
      "indent": 3,
      "text": "* Small clarifications on sadb_ident_id usage.",
      "ja": "* sadb_ident_id使用に関する小明確化。"
    },
    {
      "indent": 3,
      "text": "* New PFKEYV2_REVISION value.",
      "ja": "*新しいPFKEYV2_REVISION値。"
    },
    {
      "indent": 3,
      "text": "* Small clarification on what a PROXY address is.",
      "ja": "* PROXYアドレスが何であるかに小さな明確化。"
    },
    {
      "indent": 3,
      "text": "* Corrected sadb_spirange_{min,max} language.",
      "ja": "*修正sadb_spirange_ {最小、最大}言語。"
    },
    {
      "indent": 3,
      "text": "* In ADD messages that are in response to an ACQUIRE, the sadb_msg_seq MUST be the same as that of the originating ACQUIRE.",
      "ja": "*で取得するために対応しているメッセージを追加し、sadb_msg_seqは、発信ACQUIREのと同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Corrected ACQUIRE message behavior, ACQUIRE message SHOULD send up PROXY addresses when it needs them.",
      "ja": "*修正しACQUIREメッセージの振る舞い、それはそれらを必要とするとき、ACQUIREメッセージは、プロキシアドレスを送るべきです。"
    },
    {
      "indent": 3,
      "text": "* Clarification on SADB_EXPIRE and user-level security protocols.",
      "ja": "* SADB_EXPIREとユーザーレベルのセキュリティプロトコル上の明確化。"
    },
    {
      "indent": 3,
      "text": "The following changes were made between 03 and 04:",
      "ja": "次の変更は、03と04の間で行われました。"
    },
    {
      "indent": 3,
      "text": "* Stronger language about manual keying.",
      "ja": "*手動キー入力についてのより強力な言語。"
    },
    {
      "indent": 3,
      "text": "* PFKEYV2_REVISION, ala POSIX.",
      "ja": "* PFKEYV2_REVISION、ALA POSIX。"
    },
    {
      "indent": 3,
      "text": "* Put in language about sockaddr ports in ACQUIRE messages.",
      "ja": "* ACQUIREメッセージ内のsockaddrポートについての言語に入れてください。"
    },
    {
      "indent": 3,
      "text": "* Mention of asymmetric algorithms.",
      "ja": "*非対称アルゴリズムの言及。"
    },
    {
      "indent": 3,
      "text": "* New sadb_ident_id field for easier construction of USER_FQDN identity strings.",
      "ja": "USER_FQDNアイデンティティ文字列を簡単に構築するための*新しいsadb_ident_idフィールド。"
    },
    {
      "indent": 3,
      "text": "* Caveat about source addresses not always used for collision detection. (e.g. IPsec)",
      "ja": "*常に衝突検出のために使用されていない送信元アドレスについての警告。 （例えばIPsec）の"
    },
    {
      "indent": 3,
      "text": "The following changes were made between 02 and 03:",
      "ja": "次の変更は、02と03の間で行われました。"
    },
    {
      "indent": 3,
      "text": "* Formatting changes.",
      "ja": "*フォーマットの変更。"
    },
    {
      "indent": 3,
      "text": "* Many editorial cleanups, rewordings, clarifications.",
      "ja": "*多くの社説清掃、rewordings、明確化。"
    },
    {
      "indent": 3,
      "text": "* Restrictions that prevent many strange and invalid cases.",
      "ja": "*多くの奇妙なと無効な例を防ぐ制限。"
    },
    {
      "indent": 3,
      "text": "* Added definitions section.",
      "ja": "*定義セクションを追加しました。"
    },
    {
      "indent": 3,
      "text": "* Removed connection identity type (this will reappear when it is more clear what it should look like).",
      "ja": "*削除接続IDのタイプ（どのように見えるか、より明確であるとき、これが再び表示されます）。"
    },
    {
      "indent": 3,
      "text": "* Removed 5.2.1 (Why involve the kernel?).",
      "ja": "* 5.2.1を削除しました（なぜカーネルを必要とします？）。"
    },
    {
      "indent": 3,
      "text": "* Removed INBOUND, OUTBOUND, and FORWARD flags; they can be computed from src, dst, and proxy and you had to anyway for sanity checking.",
      "ja": "*削除INBOUND、OUTBOUND、およびFORWARDフラグ。彼らは、SRC、DST、およびプロキシから計算することができ、あなたは正気をチェックするためとにかくしなければなりませんでした。"
    },
    {
      "indent": 3,
      "text": "* Removed REPLAY flag; sadb_sa_replay==0 means the same thing.",
      "ja": "*削除REPLAYフラグ。 sadb_sa_replay == 0は、同じことを意味します。"
    },
    {
      "indent": 3,
      "text": "* Renamed bit lengths to \"bits\" to avoid potential confusion.",
      "ja": "*潜在的な混乱を避けるために、「ビット」にビット長の名前を変更しました。"
    },
    {
      "indent": 3,
      "text": "* Explicitly listed lengths for structures.",
      "ja": "*明示的な構造のための長さを記載されています。"
    },
    {
      "indent": 3,
      "text": "* Reworked identities to always use a string format.",
      "ja": "*常に文字列形式を使用してアイデンティティを作り直しました。"
    },
    {
      "indent": 3,
      "text": "* Removed requirements for support of shutdown() and SO_USELOOPBACK.",
      "ja": "*シャットダウンをサポートするための要件（）とSO_USELOOPBACKを削除しました。"
    },
    {
      "indent": 3,
      "text": "* 64 bit alignment and 64 bit lengths instead of 32 bit.",
      "ja": "* 64ビットのアライメントおよび64ビット長の代わりに、32ビット。"
    },
    {
      "indent": 3,
      "text": "* time_t replaced with uint64 in lifetimes.",
      "ja": "* time_t型は寿命でuint64型に置き換えます。"
    },
    {
      "indent": 3,
      "text": "* Inserted Appendix A (SADB_X_PROMISC) and Appendix B (SAMPLE HEADER FILE).",
      "ja": "*挿入付録A（SADB_X_PROMISC）および付録B（SAMPLEヘッダファイル）。"
    },
    {
      "indent": 3,
      "text": "* Explicit error if PF_KEY_V2 not set at socket() call.",
      "ja": "* PF_KEY_V2はソケット（）の呼び出しで設定されていない場合は明示的なエラー。"
    },
    {
      "indent": 3,
      "text": "* More text on SO_USELOOPBACK.",
      "ja": "* SO_USELOOPBACKの詳細テキスト。"
    },
    {
      "indent": 3,
      "text": "* Made fields names and symbol names more consistent.",
      "ja": "*フィールド名とシンボル名は、より一貫性のメイド。"
    },
    {
      "indent": 3,
      "text": "* Explicit error if PF_KEY_V2 is not in sadb_msg_version field.",
      "ja": "* PF_KEY_V2がsadb_msg_versionフィールドにない場合、明示的なエラー。"
    },
    {
      "indent": 3,
      "text": "* Bytes lifetime field now a 64-bit quantity.",
      "ja": "今64ビット量*バイト寿命フィールド。"
    },
    {
      "indent": 3,
      "text": "* Explicit len/exttype wording.",
      "ja": "*明示LEN / exttype文言。"
    },
    {
      "indent": 3,
      "text": "* Flattening out of extensions (LIFETIME_HARD, LIFETIME_SOFT, etc.)",
      "ja": "*拡張子のうちのフラット化（LIFETIME_HARD、LIFETIME_SOFT、など）"
    },
    {
      "indent": 3,
      "text": "* UI example (0x123 == 0x1230 or 0x0123).",
      "ja": "* UI例（0x123 == 0x1230または0x0123）。"
    },
    {
      "indent": 3,
      "text": "* Cleaned up and fixed some message behavior examples.",
      "ja": "*クリーンアップと、いくつかのメッセージの動作例を修正しました。"
    },
    {
      "indent": 3,
      "text": "The following changes were made between 01 and 02:",
      "ja": "次の変更は、01と02の間で行われました。"
    },
    {
      "indent": 3,
      "text": "* Mentioned that people COULD use these same messages between user progs. (Also mentioned why you still might want to use the actual socket.)",
      "ja": "*人々は、ユーザーprogsの間でこれらの同じメッセージを使用することができることを述べました。 （あなたはまだ、実際のソケットを使用する理由も言及しました。）"
    },
    {
      "indent": 3,
      "text": "* Various wordsmithing changes.",
      "ja": "*様々なwordsmithing変化します。"
    },
    {
      "indent": 3,
      "text": "* Took out netkey/ directory, and make net/pfkeyv2.h",
      "ja": "* netkey /ディレクトリを取り出し、およびネット/ pfkeyv2.hを作ります"
    },
    {
      "indent": 3,
      "text": "* Inserted PF_KEY_V2 proto argument per C. Metz.",
      "ja": "* C.メッツあたりの挿入PF_KEY_V2プロト引数。"
    },
    {
      "indent": 3,
      "text": "* Mentioned other socket calls and how their PF_KEY behavior is undefined.",
      "ja": "*他のソケット呼び出しを言及し、そのPF_KEYの行動がどのように定義されていません。"
    },
    {
      "indent": 3,
      "text": "* SADB_EXPIRE now communicates both hard and soft lifetime expires.",
      "ja": "* SADB_EXPIREは今、両方のハードとソフトの寿命が満了した通信を行います。"
    },
    {
      "indent": 3,
      "text": "* New \"association\" extension, even smaller base header.",
      "ja": "*新しい「関連」拡張、さらに小さい基本ヘッダ。"
    },
    {
      "indent": 3,
      "text": "* Lifetime extension improvements.",
      "ja": "*寿命延長の改善。"
    },
    {
      "indent": 3,
      "text": "* Length now first in extensions.",
      "ja": "*今、最初の拡張の長さ。"
    },
    {
      "indent": 3,
      "text": "* Errors can be sent from kernel to user, also.",
      "ja": "*エラーはまた、ユーザーにカーネルから送信することができます。"
    },
    {
      "indent": 3,
      "text": "* Examples section inserted.",
      "ja": "*実施例のセクションを挿入します。"
    },
    {
      "indent": 3,
      "text": "* Some bitfield cleanups, including STATE and SA_OPTIONS cleanup.",
      "ja": "* STATEとSA_OPTIONSクリーンアップなどの一部のビットフィールドのクリーンアップ、。"
    },
    {
      "indent": 3,
      "text": "* Key splitting now only across auth algorithm and encryption algorithm. Thanks for B. Sommerfeld for clues here.",
      "ja": "*主な分裂今だけ認証アルゴリズムと暗号化アルゴリズム間。ここでの手がかりのためのB.ゾンマーフェルトいただきありがとうございます。"
    },
    {
      "indent": 3,
      "text": "The following changes were made between 00 and 01:",
      "ja": "次の変更は、00と01の間で行われました。"
    },
    {
      "indent": 3,
      "text": "* Added this change log.",
      "ja": "*この変更ログを追加しました。"
    },
    {
      "indent": 3,
      "text": "* Simplified TLV header syntax.",
      "ja": "*簡体TLVヘッダー構文。"
    },
    {
      "indent": 3,
      "text": "* Splitting of algorithms. This may be controversial, but it allows PF_KEY to be used for more than just IPsec. It also allows some kinds of policies to be placed in the KMd easier.",
      "ja": "*アルゴリズムの分割。これは物議を醸すかもしれないが、それはPF_KEYはただのIPsec以外にも使用することができます。また、政策のいくつかの種類がKMDより簡単に配置することができます。"
    },
    {
      "indent": 3,
      "text": "* Added solid definitions and formats for certificate identities, multiple keys, etc.",
      "ja": "*証明書ID、複数のキーなどに固体の定義とフォーマットを追加しました"
    },
    {
      "indent": 3,
      "text": "* Specified how keys are to be layed out (most-to-least bits).",
      "ja": "*キーが（最もツー少なくともビット）にレイアウトされる方法を指定。"
    },
    {
      "indent": 3,
      "text": "* Changed sequence number semantics to be like an RPC transaction ID number.",
      "ja": "* RPCトランザクションID番号のようになり、シーケンス番号のセマンティクスを変更しました。"
    },
    {
      "indent": 0,
      "text": "F. Full Copyright Statement",
      "ja": "F.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    }
  ]
}