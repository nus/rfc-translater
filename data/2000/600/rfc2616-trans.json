{
  "title": {
    "text": "RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1",
    "ja": "RFC 2616 - ハイパーテキスト転送プロトコル -  HTTP / 1.1"
  },
  "number": 2616,
  "created_at": "2019-10-27 13:30:41.283125+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                      R. Fielding\nRequest for Comments: 2616                                   UC Irvine\nObsoletes: 2068                                              J. Gettys\nCategory: Standards Track                                   Compaq/W3C\n                                                              J. Mogul\n                                                                Compaq\n                                                            H. Frystyk\n                                                               W3C/MIT\n                                                           L. Masinter\n                                                                 Xerox\n                                                              P. Leach\n                                                             Microsoft\n                                                        T. Berners-Lee\n                                                               W3C/MIT\n                                                             June 1999",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Hypertext Transfer Protocol -- HTTP/1.1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1999）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. It is a generic, stateless, protocol which can be used for many tasks beyond its use for hypertext, such as name servers and distributed object management systems, through extension of its request methods, error codes and headers [47]. A feature of HTTP is the typing and negotiation of data representation, allowing systems to be built independently of the data being transferred.",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、分散、協調、ハイパーメディア情報システムのためのアプリケーションレベルのプロトコルです。それは、そのリクエストメソッド、エラーコードとヘッダ[47]の拡張を介して、そのようなネームサーバ及び分散オブジェクト管理システムとしてのハイパーテキストのためのその使用を超えて多くのタスクに使用することができる一般的な、ステートレスなプロトコルです。 HTTPの特徴は、システムは、独立して転送されるデータを構築することを可能にする、データの表現のタイピング及び交渉です。"
    },
    {
      "indent": 3,
      "text": "HTTP has been in use by the World-Wide Web global information initiative since 1990. This specification defines the protocol referred to as \"HTTP/1.1\", and is an update to RFC 2068 [33].",
      "ja": "HTTPは、この仕様は、プロトコルが「HTTP / 1.1」という定義し、RFC 2068 [33]に更新され、1990年以来、ワールドワイドウェブグローバル情報イニシアティブによって使用されています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1   Introduction ...................................................7\n1.1    Purpose......................................................7\n1.2   Requirements .................................................8\n1.3   Terminology ..................................................8\n1.4   Overall Operation ...........................................12\n2   Notational Conventions and Generic Grammar ....................14\n2.1   Augmented BNF ...............................................14\n2.2   Basic Rules .................................................15\n3   Protocol Parameters ...........................................17\n3.1   HTTP Version ................................................17\n3.2   Uniform Resource Identifiers ................................18\n3.2.1    General Syntax ...........................................19\n3.2.2    http URL .................................................19\n3.2.3    URI Comparison ...........................................20\n3.3   Date/Time Formats ...........................................20\n3.3.1    Full Date ................................................20\n3.3.2    Delta Seconds ............................................21\n3.4   Character Sets ..............................................21\n3.4.1    Missing Charset ..........................................22\n3.5   Content Codings .............................................23\n3.6   Transfer Codings ............................................24\n3.6.1    Chunked Transfer Coding ..................................25\n3.7   Media Types .................................................26\n3.7.1    Canonicalization and Text Defaults .......................27\n3.7.2    Multipart Types ..........................................27\n3.8   Product Tokens ..............................................28\n3.9   Quality Values ..............................................29\n3.10  Language Tags ...............................................29\n3.11  Entity Tags .................................................30\n3.12  Range Units .................................................30\n4   HTTP Message ..................................................31\n4.1   Message Types ...............................................31\n4.2   Message Headers .............................................31\n4.3   Message Body ................................................32\n4.4   Message Length ..............................................33\n4.5   General Header Fields .......................................34\n5   Request .......................................................35\n5.1   Request-Line ................................................35\n5.1.1    Method ...................................................36\n5.1.2    Request-URI ..............................................36\n5.2   The Resource Identified by a Request ........................38\n5.3   Request Header Fields .......................................38\n6   Response ......................................................39\n6.1   Status-Line .................................................39\n6.1.1    Status Code and Reason Phrase ............................39\n6.2   Response Header Fields ......................................41",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7   Entity ........................................................42\n7.1   Entity Header Fields ........................................42\n7.2   Entity Body .................................................43\n7.2.1    Type .....................................................43\n7.2.2    Entity Length ............................................43\n8   Connections ...................................................44\n8.1   Persistent Connections ......................................44\n8.1.1    Purpose ..................................................44\n8.1.2    Overall Operation ........................................45\n8.1.3    Proxy Servers ............................................46\n8.1.4    Practical Considerations .................................46\n8.2   Message Transmission Requirements ...........................47\n8.2.1    Persistent Connections and Flow Control ..................47\n8.2.2    Monitoring Connections for Error Status Messages .........48\n8.2.3    Use of the 100 (Continue) Status .........................48\n8.2.4    Client Behavior if Server Prematurely Closes Connection ..50\n9   Method Definitions ............................................51\n9.1   Safe and Idempotent Methods .................................51\n9.1.1    Safe Methods .............................................51\n9.1.2    Idempotent Methods .......................................51\n9.2   OPTIONS .....................................................52\n9.3   GET .........................................................53\n9.4   HEAD ........................................................54\n9.5   POST ........................................................54\n9.6   PUT .........................................................55\n9.7   DELETE ......................................................56\n9.8   TRACE .......................................................56\n9.9   CONNECT .....................................................57\n10   Status Code Definitions ......................................57\n10.1  Informational 1xx ...........................................57\n10.1.1   100 Continue .............................................58\n10.1.2   101 Switching Protocols ..................................58\n10.2  Successful 2xx ..............................................58\n10.2.1   200 OK ...................................................58\n10.2.2   201 Created ..............................................59\n10.2.3   202 Accepted .............................................59\n10.2.4   203 Non-Authoritative Information ........................59\n10.2.5   204 No Content ...........................................60\n10.2.6   205 Reset Content ........................................60\n10.2.7   206 Partial Content ......................................60\n10.3  Redirection 3xx .............................................61\n10.3.1   300 Multiple Choices .....................................61\n10.3.2   301 Moved Permanently ....................................62\n10.3.3   302 Found ................................................62\n10.3.4   303 See Other ............................................63\n10.3.5   304 Not Modified .........................................63\n10.3.6   305 Use Proxy ............................................64\n10.3.7   306 (Unused) .............................................64",
      "raw": true
    },
    {
      "indent": 3,
      "text": "10.3.8   307 Temporary Redirect ...................................65\n10.4  Client Error 4xx ............................................65\n10.4.1    400 Bad Request .........................................65\n10.4.2    401 Unauthorized ........................................66\n10.4.3    402 Payment Required ....................................66\n10.4.4    403 Forbidden ...........................................66\n10.4.5    404 Not Found ...........................................66\n10.4.6    405 Method Not Allowed ..................................66\n10.4.7    406 Not Acceptable ......................................67\n10.4.8    407 Proxy Authentication Required .......................67\n10.4.9    408 Request Timeout .....................................67\n10.4.10   409 Conflict ............................................67\n10.4.11   410 Gone ................................................68\n10.4.12   411 Length Required .....................................68\n10.4.13   412 Precondition Failed .................................68\n10.4.14   413 Request Entity Too Large ............................69\n10.4.15   414 Request-URI Too Long ................................69\n10.4.16   415 Unsupported Media Type ..............................69\n10.4.17   416 Requested Range Not Satisfiable .....................69\n10.4.18   417 Expectation Failed ..................................70\n10.5  Server Error 5xx ............................................70\n10.5.1   500 Internal Server Error ................................70\n10.5.2   501 Not Implemented ......................................70\n10.5.3   502 Bad Gateway ..........................................70\n10.5.4   503 Service Unavailable ..................................70\n10.5.5   504 Gateway Timeout ......................................71\n10.5.6   505 HTTP Version Not Supported ...........................71\n11   Access Authentication ........................................71\n12   Content Negotiation ..........................................71\n12.1  Server-driven Negotiation ...................................72\n12.2  Agent-driven Negotiation ....................................73\n12.3  Transparent Negotiation .....................................74\n13   Caching in HTTP ..............................................74\n13.1.1   Cache Correctness ........................................75\n13.1.2   Warnings .................................................76\n13.1.3   Cache-control Mechanisms .................................77\n13.1.4   Explicit User Agent Warnings .............................78\n13.1.5   Exceptions to the Rules and Warnings .....................78\n13.1.6   Client-controlled Behavior ...............................79\n13.2  Expiration Model ............................................79\n13.2.1   Server-Specified Expiration ..............................79\n13.2.2   Heuristic Expiration .....................................80\n13.2.3   Age Calculations .........................................80\n13.2.4   Expiration Calculations ..................................83\n13.2.5   Disambiguating Expiration Values .........................84\n13.2.6   Disambiguating Multiple Responses ........................84\n13.3  Validation Model ............................................85\n13.3.1   Last-Modified Dates ......................................86",
      "raw": true
    },
    {
      "indent": 3,
      "text": "13.3.2   Entity Tag Cache Validators ..............................86\n13.3.3   Weak and Strong Validators ...............................86\n13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89\n13.3.5   Non-validating Conditionals ..............................90\n13.4  Response Cacheability .......................................91\n13.5  Constructing Responses From Caches ..........................92\n13.5.1   End-to-end and Hop-by-hop Headers ........................92\n13.5.2   Non-modifiable Headers ...................................92\n13.5.3   Combining Headers ........................................94\n13.5.4   Combining Byte Ranges ....................................95\n13.6  Caching Negotiated Responses ................................95\n13.7  Shared and Non-Shared Caches ................................96\n13.8  Errors or Incomplete Response Cache Behavior ................97\n13.9  Side Effects of GET and HEAD ................................97\n13.10   Invalidation After Updates or Deletions ...................97\n13.11   Write-Through Mandatory ...................................98\n13.12   Cache Replacement .........................................99\n13.13   History Lists .............................................99\n14   Header Field Definitions ....................................100\n14.1  Accept .....................................................100\n14.2  Accept-Charset .............................................102\n14.3  Accept-Encoding ............................................102\n14.4  Accept-Language ............................................104\n14.5  Accept-Ranges ..............................................105\n14.6  Age ........................................................106\n14.7  Allow ......................................................106\n14.8  Authorization ..............................................107\n14.9  Cache-Control ..............................................108\n14.9.1   What is Cacheable .......................................109\n14.9.2   What May be Stored by Caches ............................110\n14.9.3   Modifications of the Basic Expiration Mechanism .........111\n14.9.4   Cache Revalidation and Reload Controls ..................113\n14.9.5   No-Transform Directive ..................................115\n14.9.6   Cache Control Extensions ................................116\n14.10   Connection ...............................................117\n14.11   Content-Encoding .........................................118\n14.12   Content-Language .........................................118\n14.13   Content-Length ...........................................119\n14.14   Content-Location .........................................120\n14.15   Content-MD5 ..............................................121\n14.16   Content-Range ............................................122\n14.17   Content-Type .............................................124\n14.18   Date .....................................................124\n14.18.1   Clockless Origin Server Operation ......................125\n14.19   ETag .....................................................126\n14.20   Expect ...................................................126\n14.21   Expires ..................................................127\n14.22   From .....................................................128",
      "raw": true
    },
    {
      "indent": 3,
      "text": "14.23   Host .....................................................128\n14.24   If-Match .................................................129\n14.25   If-Modified-Since ........................................130\n14.26   If-None-Match ............................................132\n14.27   If-Range .................................................133\n14.28   If-Unmodified-Since ......................................134\n14.29   Last-Modified ............................................134\n14.30   Location .................................................135\n14.31   Max-Forwards .............................................136\n14.32   Pragma ...................................................136\n14.33   Proxy-Authenticate .......................................137\n14.34   Proxy-Authorization ......................................137\n14.35   Range ....................................................138\n14.35.1    Byte Ranges ...........................................138\n14.35.2    Range Retrieval Requests ..............................139\n14.36   Referer ..................................................140\n14.37   Retry-After ..............................................141\n14.38   Server ...................................................141\n14.39   TE .......................................................142\n14.40   Trailer ..................................................143\n14.41  Transfer-Encoding..........................................143\n14.42   Upgrade ..................................................144\n14.43   User-Agent ...............................................145\n14.44   Vary .....................................................145\n14.45   Via ......................................................146\n14.46   Warning ..................................................148\n14.47   WWW-Authenticate .........................................150\n15 Security Considerations .......................................150\n15.1      Personal Information....................................151\n15.1.1   Abuse of Server Log Information .........................151\n15.1.2   Transfer of Sensitive Information .......................151\n15.1.3   Encoding Sensitive Information in URI's .................152\n15.1.4   Privacy Issues Connected to Accept Headers ..............152\n15.2  Attacks Based On File and Path Names .......................153\n15.3  DNS Spoofing ...............................................154\n15.4  Location Headers and Spoofing ..............................154\n15.5  Content-Disposition Issues .................................154\n15.6  Authentication Credentials and Idle Clients ................155\n15.7  Proxies and Caching ........................................155\n15.7.1    Denial of Service Attacks on Proxies....................156\n16   Acknowledgments .............................................156\n17   References ..................................................158\n18   Authors' Addresses ..........................................162\n19   Appendices ..................................................164\n19.1  Internet Media Type message/http and application/http ......164\n19.2  Internet Media Type multipart/byteranges ...................165\n19.3  Tolerant Applications ......................................166\n19.4  Differences Between HTTP Entities and RFC 2045 Entities ....167",
      "raw": true
    },
    {
      "indent": 3,
      "text": "19.4.1   MIME-Version ............................................167\n19.4.2   Conversion to Canonical Form ............................167\n19.4.3   Conversion of Date Formats ..............................168\n19.4.4   Introduction of Content-Encoding ........................168\n19.4.5   No Content-Transfer-Encoding ............................168\n19.4.6   Introduction of Transfer-Encoding .......................169\n19.4.7   MHTML and Line Length Limitations .......................169\n19.5  Additional Features ........................................169\n19.5.1   Content-Disposition .....................................170\n19.6  Compatibility with Previous Versions .......................170\n19.6.1   Changes from HTTP/1.0 ...................................171\n19.6.2   Compatibility with HTTP/1.0 Persistent Connections ......172\n19.6.3   Changes from RFC 2068 ...................................172\n20   Index .......................................................175\n21   Full Copyright Statement ....................................176",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1 Introduction",
      "ja": "1はじめに"
    },
    {
      "indent": 0,
      "text": "1.1 Purpose",
      "section_title": true,
      "ja": "1.1目的"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. HTTP has been in use by the World-Wide Web global information initiative since 1990. The first version of HTTP, referred to as HTTP/0.9, was a simple protocol for raw data transfer across the Internet. HTTP/1.0, as defined by RFC 1945 [6], improved the protocol by allowing messages to be in the format of MIME-like messages, containing metainformation about the data transferred and modifiers on the request/response semantics. However, HTTP/1.0 does not sufficiently take into consideration the effects of hierarchical proxies, caching, the need for persistent connections, or virtual hosts. In addition, the proliferation of incompletely-implemented applications calling themselves \"HTTP/1.0\" has necessitated a protocol version change in order for two communicating applications to determine each other's true capabilities.",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、分散、協調、ハイパーメディア情報システムのためのアプリケーションレベルのプロトコルです。 1990年HTTPの最初のバージョンは、HTTP / 0.9と呼ばれるので、HTTPは、World-Wide Webのグローバルな情報イニシアチブによって使用されている、インターネットを経由した生データ転送のための単純なプロトコルでした。 RFC 1945によって定義されるようにHTTP / 1.0は、[6]、要求/応答セマンティクスに転送されたデータと修飾に関するメタ情報を含む、メッセージがMIMEのようなメッセージの形式であるようにすることによってプロトコルを改善しました。しかし、HTTP / 1.0を十分に考慮した階層プロキシ、キャッシング、持続的な接続の必要性、または仮想ホストの効果を負いません。また、自分自身を呼び出す不完全に実装されたアプリケーションの急増は、「HTTP / 1.0は、」お互いの本当の能力を決定するために2つの通信アプリケーションのための順序でプロトコルバージョンの変更を必要としています。"
    },
    {
      "indent": 3,
      "text": "This specification defines the protocol referred to as \"HTTP/1.1\". This protocol includes more stringent requirements than HTTP/1.0 in order to ensure reliable implementation of its features.",
      "ja": "本明細書では、「HTTP / 1.1」と呼ばれるプロトコルを定義します。このプロトコルは、その機能の確実な実施を確保するために、HTTP / 1.0よりも厳しい要件が含まれています。"
    },
    {
      "indent": 3,
      "text": "Practical information systems require more functionality than simple retrieval, including search, front-end update, and annotation. HTTP allows an open-ended set of methods and headers that indicate the purpose of a request [47]. It builds on the discipline of reference provided by the Uniform Resource Identifier (URI) [3], as a location (URL) [4] or name (URN) [20], for indicating the resource to which a",
      "ja": "実用的な情報システムは、検索、フロントエンドアップデート、および注釈を含め、簡易検索よりも多くの機能を必要とします。 HTTPリクエスト[47]の目的を示す方法およびヘッダのオープンエンドセットを可能にします。これは、[3]、場所（URL）[4]または名（URN）[20]のようにリソースを表示するためのURI（Uniform Resource Identifier）によって提供される基準の規律に基づいて構築します"
    },
    {
      "indent": 3,
      "text": "method is to be applied. Messages are passed in a format similar to that used by Internet mail [9] as defined by the Multipurpose Internet Mail Extensions (MIME) [7].",
      "ja": "この方法は、適用されます。多目的インターネットメール拡張（MIME）によって定義されたメッセージは、[7] [9]インターネットメールで使用されるものと同様の形式で渡されます。"
    },
    {
      "indent": 3,
      "text": "HTTP is also used as a generic protocol for communication between user agents and proxies/gateways to other Internet systems, including those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2], and WAIS [10] protocols. In this way, HTTP allows basic hypermedia access to resources available from diverse applications.",
      "ja": "HTTPは、ユーザエージェントとプロキシ/ SMTP [16]、NNTP [13]、FTP [18]、ゴーファー[2]、及びWAIS [により支持されるものを含む他のインターネットシステムへのゲートウェイとの間の通信のための一般的なプロトコルとして使用されています10]のプロトコル。このように、HTTPは、多様なアプリケーションから利用可能なリソースへの基本的なハイパーメディアアクセスを可能にします。"
    },
    {
      "indent": 0,
      "text": "1.2 Requirements",
      "section_title": true,
      "ja": "1.2要件"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [34].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [34]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "An implementation is not compliant if it fails to satisfy one or more of the MUST or REQUIRED level requirements for the protocols it implements. An implementation that satisfies all the MUST or REQUIRED level and all the SHOULD level requirements for its protocols is said to be \"unconditionally compliant\"; one that satisfies all the MUST level requirements but not all the SHOULD level requirements for its protocols is said to be \"conditionally compliant.\"",
      "ja": "それが実装されたプロトコルのためのMUSTまたはREQUIREDレベル要件の一つ以上を満たすために失敗した場合、実装は準拠していません。すべてのMUSTまたは必要なレベルとそのプロトコルのためのすべてのSHOULDレベルの要件を満たす実装は「無条件に準拠した」と言われて。すべてのMUSTレベルの要件を満たしているが、そのプロトコルのためではない、すべてのSHOULDレベルの要件があると言われて一つの「条件付きで準拠しています。」"
    },
    {
      "indent": 0,
      "text": "1.3 Terminology",
      "section_title": true,
      "ja": "1.3用語"
    },
    {
      "indent": 3,
      "text": "This specification uses a number of terms to refer to the roles played by participants in, and objects of, the HTTP communication.",
      "ja": "この仕様は、参加者によって果たされる役割を参照するために多くの用語を使用し、HTTP通信のオブジェクト。"
    },
    {
      "indent": 3,
      "text": "connection A transport layer virtual circuit established between two programs for the purpose of communication.",
      "ja": "接続通信のために二つのプログラム間に確立されたトランスポート層仮想回路。"
    },
    {
      "indent": 3,
      "text": "message The basic unit of HTTP communication, consisting of a structured sequence of octets matching the syntax defined in section 4 and transmitted via the connection.",
      "ja": "メッセージセクション4で定義され、接続を介して送信されたシンタックスに一致オクテットの構造配列からなるHTTP通信の基本ユニット。"
    },
    {
      "indent": 3,
      "text": "request An HTTP request message, as defined in section 5.",
      "ja": "セクション5で定義されるように、HTTPリクエストメッセージを要求します。"
    },
    {
      "indent": 3,
      "text": "response An HTTP response message, as defined in section 6.",
      "ja": "セクション6で定義されるように、HTTPレスポンスメッセージを応答。"
    },
    {
      "indent": 3,
      "text": "resource A network data object or service that can be identified by a URI, as defined in section 3.2. Resources may be available in multiple representations (e.g. multiple languages, data formats, size, and resolutions) or vary in other ways.",
      "ja": "セクション3.2で定義されるように、URIによって識別することができるネットワーク・データ・オブジェクトまたはサービスリソース。リソースが複数の表現に利用可能である（例えば、複数の言語、データフォーマット、サイズ、解像度）、または他の方法で変えることができます。"
    },
    {
      "indent": 3,
      "text": "entity The information transferred as the payload of a request or response. An entity consists of metainformation in the form of entity-header fields and content in the form of an entity-body, as described in section 7.",
      "ja": "エンティティ要求または応答のペイロードとして転送される情報。セクション7で説明したように、エンティティは、エンティティ - ヘッダフィールド及びエンティティ - 本体の形のコンテンツの形でメタ情報から構成されています。"
    },
    {
      "indent": 3,
      "text": "representation An entity included with a response that is subject to content negotiation, as described in section 12. There may exist multiple representations associated with a particular response status.",
      "ja": "表現エンティティは、セクション12で説明したように特定の応答ステータスに関連付けられた複数の表現が存在することができる、コンテンツネゴシエーションの対象となる応答に含ま。"
    },
    {
      "indent": 3,
      "text": "content negotiation The mechanism for selecting the appropriate representation when servicing a request, as described in section 12. The representation of entities in any response can be negotiated (including error responses).",
      "ja": "要求をサービスする際の任意の応答部12エンティティの表現で説明したように、適切な表現を選択するための機構（エラー応答を含む）コンテンツネゴシエーションをネゴシエートすることができます。"
    },
    {
      "indent": 3,
      "text": "variant A resource may have one, or more than one, representation(s) associated with it at any given instant. Each of these representations is termed a `varriant'. Use of the term `variant' does not necessarily imply that the resource is subject to content negotiation.",
      "ja": "バリアントリソースは、1つ、または任意の所与の瞬間に、それに関連付けられた複数の、表現（単数または複数）を有していてもよいです。これらの表現はそれぞれ、 `varriant」と呼ばれています。用語 `バリアント」の使用は、必ずしもリソースが内容交渉の対象であることを意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "client A program that establishes connections for the purpose of sending requests.",
      "ja": "クライアントのリクエストを送信する目的のために接続を確立するプログラム。"
    },
    {
      "indent": 3,
      "text": "user agent The client which initiates a request. These are often browsers, editors, spiders (web-traversing robots), or other end user tools.",
      "ja": "ユーザエージェント要求を開始するクライアント。これらは、しばしばブラウザ、エディタ、クモ（ウェブ横断ロボット）、または他のエンドユーザツールです。"
    },
    {
      "indent": 3,
      "text": "server An application program that accepts connections in order to service requests by sending back responses. Any given program may be capable of being both a client and a server; our use of these terms refers only to the role being performed by the program for a particular connection, rather than to the program's capabilities in general. Likewise, any server may act as an origin server, proxy, gateway, or tunnel, switching behavior based on the nature of each request.",
      "ja": "サーバーの応答を返送することにより、サービス要求に順に接続を受け入れるアプリケーションプログラム。任意のプログラムは、クライアントとサーバの両方であることの可能であってもよいです。私たちのこれらの用語の使用は、特定の接続のためのプログラムによって実行される役割にではなく、一般的には、プログラムの機能を指します。同様に、いずれかのサーバは、それぞれの要求の性質に基づいて動作を切り替える、オリジンサーバ、プロキシ、ゲートウェイ、またはトンネルとして作用することができます。"
    },
    {
      "indent": 3,
      "text": "origin server The server on which a given resource resides or is to be created.",
      "ja": "オリジンサーバ与えられたリソースが存在するか、作成されるサーバー。"
    },
    {
      "indent": 3,
      "text": "proxy An intermediary program which acts as both a server and a client for the purpose of making requests on behalf of other clients. Requests are serviced internally or by passing them on, with possible translation, to other servers. A proxy MUST implement both the client and server requirements of this specification. A \"transparent proxy\" is a proxy that does not modify the request or response beyond what is required for proxy authentication and identification. A \"non-transparent proxy\" is a proxy that modifies the request or response in order to provide some added service to the user agent, such as group annotation services, media type transformation, protocol reduction, or anonymity filtering. Except where either transparent or non-transparent behavior is explicitly stated, the HTTP proxy requirements apply to both types of proxies.",
      "ja": "プロキシ他のクライアントに代わってリクエストを作成する目的のために、サーバーとクライアントの両方として動作する仲介プログラム。要求は、他のサーバーに、可能な翻訳で、内部またはそれらを渡すことによってサービスされています。プロキシは、この仕様のクライアントとサーバの両方の要件を実装しなければなりません。 「透過型プロキシは」プロキシ認証と識別のために必要とされるものを超えて、要求または応答を変更しないプロキシです。 「非透過プロキシ」は、グループ注釈サービス、メディアタイプ変換、プロトコル低減、または匿名のフィルタリングなどのユーザエージェント、にいくつかの追加サービスを提供するために要求または応答を改変するプロキシです。透明または不透明な行動のいずれかを明示的に記述されている場合を除き、HTTPプロキシの要件は、プロキシの両方のタイプに適用されます。"
    },
    {
      "indent": 3,
      "text": "gateway A server which acts as an intermediary for some other server. Unlike a proxy, a gateway receives requests as if it were the origin server for the requested resource; the requesting client may not be aware that it is communicating with a gateway.",
      "ja": "いくつかの他のサーバの媒体として機能するサーバーゲートウェイ。それは要求されたリソースのためのオリジンサーバであるかのようにプロキシとは異なり、ゲートウェイは、要求を受け取り、要求しているクライアントは、それがゲートウェイと通信していることを認識していなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "tunnel An intermediary program which is acting as a blind relay between two connections. Once active, a tunnel is not considered a party to the HTTP communication, though the tunnel may have been initiated by an HTTP request. The tunnel ceases to exist when both ends of the relayed connections are closed.",
      "ja": "トンネル2つの接続間のブラインドリレーとして動作している仲介プログラム。トンネルはHTTPリクエストによって開始されているかもしれませんが、アクティブたら、トンネルは、HTTP通信の当事者とはみなされません。トンネルは、中継接続の両端が閉じているときに存在しなくなります。"
    },
    {
      "indent": 3,
      "text": "cache A program's local store of response messages and the subsystem that controls its message storage, retrieval, and deletion. A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests. Any client or server may include a cache, though a cache cannot be used by a server that is acting as a tunnel.",
      "ja": "プログラムのローカル応答メッセージのストアとそのメッセージの保存、検索、および削除を制御するサブシステムをキャッシュします。キャッシュは、将来、同等の要求の応答時間とネットワーク帯域幅の消費量を削減するために、キャッシュ可能な応答を格納します。キャッシュはトンネルとして動作しているサーバーで使用することはできないものの、任意のクライアントまたはサーバは、キャッシュを備えることができます。"
    },
    {
      "indent": 3,
      "text": "cacheable A response is cacheable if a cache is allowed to store a copy of the response message for use in answering subsequent requests. The rules for determining the cacheability of HTTP responses are defined in section 13. Even if a resource is cacheable, there may be additional constraints on whether a cache can use the cached copy for a particular request.",
      "ja": "キャッシュが後続の要求に答える中で使用するための応答メッセージのコピーを保存することが許可されている場合、レスポンスはキャッシュ可能であるキャッシュ可能。 HTTPレスポンスのキャッシュ可能性を決定するためのルールは、リソースがキャッシュ可能である場合でも、セクション13で定義され、キャッシュが特定の要求のためにキャッシュされたコピーを使用できるかどうかに追加の制約があってもよいです。"
    },
    {
      "indent": 3,
      "text": "first-hand A response is first-hand if it comes directly and without unnecessary delay from the origin server, perhaps via one or more proxies. A response is also first-hand if its validity has just been checked directly with the origin server.",
      "ja": "それはおそらく、一の以上のプロキシを経由して、直接オリジンサーバから不要な遅延なしに来れば最初の手応答は、最初の手です。その有効性は、単にオリジンサーバと直接チェックされた場合、応答はまた、最初の手です。"
    },
    {
      "indent": 3,
      "text": "explicit expiration time The time at which the origin server intends that an entity should no longer be returned by a cache without further validation.",
      "ja": "明示的な有効期限オリジンサーバが実体は、もはやさらなる検証せずに、キャッシュによって返されるべきであることを意図していない時刻。"
    },
    {
      "indent": 3,
      "text": "heuristic expiration time An expiration time assigned by a cache when no explicit expiration time is available.",
      "ja": "ヒューリスティックの有効期限明示的な有効期限が利用できないキャッシュによって割り当てられた有効期限。"
    },
    {
      "indent": 3,
      "text": "age The age of a response is the time since it was sent by, or successfully validated with, the origin server.",
      "ja": "年齢はレスポンスの年齢はそれがによって送信され、または成功したオリジンサーバ、で検証されてからの時間です。"
    },
    {
      "indent": 3,
      "text": "freshness lifetime The length of time between the generation of a response and its expiration time.",
      "ja": "鮮度寿命応答の生成とその有効期限の間の時間の長さ。"
    },
    {
      "indent": 3,
      "text": "fresh A response is fresh if its age has not yet exceeded its freshness lifetime.",
      "ja": "その年齢がまだその新鮮寿命を超えていない場合は、新鮮なレスポンスが新鮮です。"
    },
    {
      "indent": 3,
      "text": "stale A response is stale if its age has passed its freshness lifetime.",
      "ja": "その年齢がその新鮮寿命を経過している場合、古いレスポンスが古くなっています。"
    },
    {
      "indent": 3,
      "text": "semantically transparent A cache behaves in a \"semantically transparent\" manner, with respect to a particular response, when its use affects neither the requesting client nor the origin server, except to improve performance. When a cache is semantically transparent, the client receives exactly the same response (except for hop-by-hop headers) that it would have received had its request been handled directly by the origin server.",
      "ja": "意味的に透過キャッシュは、パフォーマンスを向上させるために除いて、その使用は、要求元のクライアントにもオリジンサーバのいずれも影響を与え、特定の応答を基準にして、「意味的に透明」ように動作します。キャッシュが意味的に透明である場合、クライアントは、その要求がオリジンサーバによって直接処理されていた、それが受け取ったであろう（ホップバイホップヘッダを除く）と全く同じ応答を受け取ります。"
    },
    {
      "indent": 3,
      "text": "validator A protocol element (e.g., an entity tag or a Last-Modified time) that is used to find out whether a cache entry is an equivalent copy of an entity.",
      "ja": "バリデータキャッシュのエントリは、エンティティの等価なコピーであるかどうかを調べるために使用されるプロトコル要素（例えば、エンティティタグや最終更新時刻）。"
    },
    {
      "indent": 3,
      "text": "upstream/downstream Upstream and downstream describe the flow of a message: all messages flow from upstream to downstream.",
      "ja": "上流/下流の上流及び下流には、メッセージの流れを説明：すべてのメッセージは、上流側から下流側に流れます。"
    },
    {
      "indent": 3,
      "text": "inbound/outbound Inbound and outbound refer to the request and response paths for messages: \"inbound\" means \"traveling toward the origin server\", and \"outbound\" means \"traveling toward the user agent\"",
      "ja": "メッセージの要求と応答のパスを参照し、インバウンド/アウトバウンドインバウンドとアウトバウンド：「インバウンド」とは、「オリジンサーバに向かう」を意味し、「アウトバウンド」「ユーザーエージェントへ向かう」という意味します"
    },
    {
      "indent": 0,
      "text": "1.4 Overall Operation",
      "section_title": true,
      "ja": "1.4全体動作"
    },
    {
      "indent": 3,
      "text": "The HTTP protocol is a request/response protocol. A client sends a request to the server in the form of a request method, URI, and protocol version, followed by a MIME-like message containing request modifiers, client information, and possible body content over a connection with a server. The server responds with a status line, including the message's protocol version and a success or error code, followed by a MIME-like message containing server information, entity metainformation, and possible entity-body content. The relationship between HTTP and MIME is described in appendix 19.4.",
      "ja": "HTTPプロトコルは、要求/応答プロトコルです。クライアントがサーバとの接続を介してMIME状要求修飾子を含むメッセージは、クライアント情報、および可能なボディ・コンテンツに続くリクエストメソッド、URI、プロトコルバージョンの形式でサーバに要求を送信します。サーバは、サーバ情報、エンティティメタ情報、および可能なエンティティボディコンテンツを含むMIMEのようなメッセージが続くメッセージのプロトコルバージョンと成功またはエラーコード、を含む、ステータス行で応答します。 HTTPとMIMEの関係は付録19.4に記載されています。"
    },
    {
      "indent": 3,
      "text": "Most HTTP communication is initiated by a user agent and consists of a request to be applied to a resource on some origin server. In the simplest case, this may be accomplished via a single connection (v) between the user agent (UA) and the origin server (O).",
      "ja": "ほとんどのHTTP通信は、ユーザエージェントによって開始され、いくつかのオリジンサーバ上のリソースに適用するリクエストで構成されています。最も単純な場合、これはユーザエージェント（UA）とオリジンサーバ（O）との間の単一の接続（V）を介して達成することができます。"
    },
    {
      "indent": 7,
      "text": "   request chain ------------------------>\nUA -------------------v------------------- O\n   <----------------------- response chain",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A more complicated situation occurs when one or more intermediaries are present in the request/response chain. There are three common forms of intermediary: proxy, gateway, and tunnel. A proxy is a forwarding agent, receiving requests for a URI in its absolute form, rewriting all or part of the message, and forwarding the reformatted request toward the server identified by the URI. A gateway is a receiving agent, acting as a layer above some other server(s) and, if necessary, translating the requests to the underlying server's protocol. A tunnel acts as a relay point between two connections without changing the messages; tunnels are used when the communication needs to pass through an intermediary (such as a firewall) even when the intermediary cannot understand the contents of the messages.",
      "ja": "一つ以上の仲介者は、要求/応答鎖中に存在する場合、より複雑な状況が生じます。プロキシ、ゲートウェイ、およびトンネル：3つの一般的な中間の形態があります。プロキシは、その絶対的な形でURIに対する要求を受信し、メッセージの全部または一部を書き換え、およびURIによって識別されるサーバに向かって再フォーマットされた要求を転送する、転送エージェントです。ゲートウェイは、基礎となるサーバのプロトコルに要求を変換する、いくつかの他のサーバ（複数可）と、必要に応じて上記層として作用する、受信エージェントです。トンネルは、メッセージを変更せずに2つの接続間の中継点として機能します。トンネルは、通信仲介メッセージの内容を理解できない場合でも（ファイアウォールなど）の中間を通過する必要があるときに使用されます。"
    },
    {
      "indent": 7,
      "text": "   request chain -------------------------------------->\nUA -----v----- A -----v----- B -----v----- C -----v----- O\n   <------------------------------------- response chain",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The figure above shows three intermediaries (A, B, and C) between the user agent and origin server. A request or response message that travels the whole chain will pass through four separate connections. This distinction is important because some HTTP communication options may apply only to the connection with the nearest, non-tunnel neighbor, only to the end-points of the chain, or to all connections along the chain. Although the diagram is linear, each participant may be engaged in multiple, simultaneous communications. For example, B may be receiving requests from many clients other than A, and/or forwarding requests to servers other than C, at the same time that it is handling A's request.",
      "ja": "上図は、ユーザエージェントとオリジンサーバ間の3人の仲介者（A、B、及びC）を示します。チェーン全体を移動要求または応答メッセージは、4つの別々の接続を通過することになります。いくつかのHTTP通信オプションは、又は鎖に沿ってすべての接続にのみチェーンのエンドポイントに最も近い、非トンネルネイバーとの接続にのみ適用することができるので、この区別は重要です。図は線形であるが、各参加者は、複数の同時通信に従事することができます。例えば、Bは、Aの要求を処理すると同時に、A以外の多くのクライアントからの要求を受信し、および/またはC以外のサーバに要求を転送することができます。"
    },
    {
      "indent": 3,
      "text": "Any party to the communication which is not acting as a tunnel may employ an internal cache for handling requests. The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request. The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request which has not been cached by UA or A.",
      "ja": "トンネルとして動作していない通信の当事者は、要求を処理するための内部キャッシュを使用することができます。キャッシュの効果がチェーンに沿って参加者の1人がその要求に適用可能なキャッシュされた応答を持っている場合は、要求/応答チェーンが短縮されるということです。 Bは、UAまたはAによってキャッシュされていない要求の（Cを介して）Oからの以前の応答のキャッシュされたコピーを有する場合、以下が得られるチェーンを示します"
    },
    {
      "indent": 7,
      "text": "   request chain ---------->\nUA -----v----- A -----v----- B - - - - - - C - - - - - - O\n   <--------- response chain",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Not all responses are usefully cacheable, and some requests may contain modifiers which place special requirements on cache behavior. HTTP requirements for cache behavior and cacheable responses are defined in section 13.",
      "ja": "いないすべての応答が有効にキャッシュ可能であり、いくつかの要求はキャッシュの動作に特別な要件を置く修飾を含むこともできます。キャッシュの動作やキャッシュ可能なレスポンスのHTTP要求は、セクション13で定義されています。"
    },
    {
      "indent": 3,
      "text": "In fact, there are a wide variety of architectures and configurations of caches and proxies currently being experimented with or deployed across the World Wide Web. These systems include national hierarchies of proxy caches to save transoceanic bandwidth, systems that broadcast or multicast cache entries, organizations that distribute subsets of cached data via CD-ROM, and so on. HTTP systems are used in corporate intranets over high-bandwidth links, and for access via PDAs with low-power radio links and intermittent connectivity. The goal of HTTP/1.1 is to support the wide diversity of configurations already deployed while introducing protocol constructs that meet the needs of those who build web applications that require high reliability and, failing that, at least reliable indications of failure.",
      "ja": "実際には、アーキテクチャやキャッシュやプロキシの設定現在で実験やワールド・ワイド・ウェブ（WWW）に配備されているさまざまながあります。これらのシステムはように国家の大洋横断の帯域幅を節約するために、プロキシキャッシュの階層、ブロードキャストやマルチキャストのキャッシュエントリシステム、CD-ROMを経由して、キャッシュされたデータのサブセットを配布する組織などが含まれます。 HTTPシステムは高帯域幅のリンクを介して企業のイントラネットで使用され、低消費電力の無線リンクと断続的な接続とPDAなどを経由してアクセスするためにされています。 HTTP / 1.1の目標は、高い信頼性と、それを失敗し、失敗の少なくとも信頼性の高い表示を必要とするWebアプリケーションを構築する人々のニーズを満たすプロトコル構造を導入しながら、既に展開された構成の広い多様性をサポートすることです。"
    },
    {
      "indent": 3,
      "text": "HTTP communication usually takes place over TCP/IP connections. The default port is TCP 80 [19], but other ports can be used. This does not preclude HTTP from being implemented on top of any other protocol on the Internet, or on other networks. HTTP only presumes a reliable transport; any protocol that provides such guarantees can be used; the mapping of the HTTP/1.1 request and response structures onto the transport data units of the protocol in question is outside the scope of this specification.",
      "ja": "HTTP通信は、通常、TCP / IP接続を介して行われます。デフォルトポートはTCP 80 [19]であるが、他のポートを使用することができます。これは、インターネット上の、または他のネットワーク上の他のプロトコルの上に実装されてからHTTPを排除するものではありません。 HTTPは、唯一の信頼できる輸送を想定しています。そのような保証を提供する任意のプロトコルを使用することができます。当該プロトコルのトランスポート・データ・ユニットへのHTTP / 1.1リクエストとレスポンス構造のマッピングは、本明細書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "In HTTP/1.0, most implementations used a new connection for each request/response exchange. In HTTP/1.1, a connection may be used for one or more request/response exchanges, although connections may be closed for a variety of reasons (see section 8.1).",
      "ja": "HTTP / 1.0では、ほとんどの実装では、各要求/応答交換のため新しい接続を使用します。接続は、様々な理由のため閉鎖されてもよいがHTTP / 1.1では、接続は（セクション8.1を参照）、1つまたは複数の要求/応答の交換のために使用することができます。"
    },
    {
      "indent": 0,
      "text": "2 Notational Conventions and Generic Grammar",
      "ja": "2つの表記規則と一般的な文法"
    },
    {
      "indent": 0,
      "text": "2.1 Augmented BNF",
      "section_title": true,
      "ja": "2.1増補BNF"
    },
    {
      "indent": 3,
      "text": "All of the mechanisms specified in this document are described in both prose and an augmented Backus-Naur Form (BNF) similar to that used by RFC 822 [9]. Implementors will need to be familiar with the notation in order to understand this specification. The augmented BNF includes the following constructs:",
      "ja": "この文書で指定された機構の全ては、RFC 822によって使用されるものと同様の散文と拡張バッカスナウア記法（BNF）[9]の両方に記載されています。実装者はこの仕様を理解するために、表記法に精通している必要があります。増補BNFは、以下の構造が含まれています。"
    },
    {
      "indent": 3,
      "text": "name = definition The name of a rule is simply the name itself (without any enclosing \"<\" and \">\") and is separated from its definition by the equal \"=\" character. White space is only significant in that indentation of continuation lines is used to indicate a rule definition that spans more than one line. Certain basic rules are in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle brackets are used within definitions whenever their presence will facilitate discerning the use of rule names.",
      "ja": "名前ルールの名前は、単に名前自体である=定義（任意封入せずに「<」と「>」）と等しい「=」キャラクタによってその定義から分離されます。ホワイトスペースは、継続行のインデントが複数行にわたるルールの定義を示すために使用されている中で唯一重要です。特定の基本的なルールは、アングルブラケットは、その存在がルール名の使用を見分ける容易にするたびに定義内で使用される等SP、LWS、HT、CRLF、DIGIT、ALPHA、として、大文字です。"
    },
    {
      "indent": 3,
      "text": "\"literal\" Quotation marks surround literal text. Unless stated otherwise, the text is case-insensitive.",
      "ja": "「リテラル」引用符はリテラルテキストを囲みます。特に明記しない限り、テキストは大文字と小文字を区別しません。"
    },
    {
      "indent": 3,
      "text": "rule1 | rule2 Elements separated by a bar (\"|\") are alternatives, e.g., \"yes | no\" will accept yes or no.",
      "ja": "ルール1 |バーで区切らRULE2 Elementsは（「|」）の選択肢は、例えば、「はい|いいえ」はい受け入れる、あるいは全くます。"
    },
    {
      "indent": 3,
      "text": "(rule1 rule2) Elements enclosed in parentheses are treated as a single element. Thus, \"(elem (foo | bar) elem)\" allows the token sequences \"elem foo elem\" and \"elem bar elem\".",
      "ja": "（rule1 rule2）括弧で囲まれた要素は単一の要素として扱われます。したがって、 \"（elemは（FOO |バー）のelem）は、\" 可能にトークンシーケンス \"elemはfooというのelem\" と \"elem bar elem\"。"
    },
    {
      "indent": 3,
      "text": "*rule The character \"*\" preceding an element indicates repetition. The full form is \"<n>*<m>element\" indicating at least <n> and at most <m> occurrences of element. Default values are 0 and infinity so that \"*(element)\" allows any number, including zero; \"1*element\" requires at least one; and \"1*2element\" allows one or two.",
      "ja": "*「*」要素に先行する繰り返しを示す文字を支配。完全形は素子の少なくとも<N>と高々<M>の発生を示す「<N> * <M>要素」です。 「*（要素）」はゼロを含む任意の数を、可能にするようにデフォルト値は0と無限大です。 「1 *要素」とは、少なくとも1つが必要です。そして「1 *の2element」は1か2を可能にします。"
    },
    {
      "indent": 3,
      "text": "[rule] Square brackets enclose optional elements; \"[foo bar]\" is equivalent to \"*1(foo bar)\".",
      "ja": "[ルール]角括弧は、オプションの要素を囲みます。 \"[FOOバー]は\" \"* 1（FOOバー）\" に相当します。"
    },
    {
      "indent": 3,
      "text": "N rule Specific repetition: \"<n>(element)\" is equivalent to \"<n>*<n>(element)\"; that is, exactly <n> occurrences of (element). Thus 2DIGIT is a 2-digit number, and 3ALPHA is a string of three alphabetic characters.",
      "ja": "N特定の繰り返しルール： \"<N>（要素）は\" \"<N> * <N>（要素）\" に相当します。つまり、正確に<N>（要素）の発生。したがって2DIGITは、2桁の数字であり、そして3ALPHAはアルファベット3文字の文字列です。"
    },
    {
      "indent": 3,
      "text": "#rule A construct \"#\" is defined, similar to \"*\", for defining lists of elements. The full form is \"<n>#<m>element\" indicating at least <n> and at most <m> elements, each separated by one or more commas (\",\") and OPTIONAL linear white space (LWS). This makes the usual form of lists very easy; a rule such as ( *LWS element *( *LWS \",\" *LWS element )) can be shown as 1#element Wherever this construct is used, null elements are allowed, but do not contribute to the count of elements present. That is, \"(element), , (element) \" is permitted, but counts as only two elements. Therefore, where at least one element is required, at least one non-null element MUST be present. Default values are 0 and infinity so that \"#element\" allows any number, including zero; \"1#element\" requires at least one; and \"1#2element\" allows one or two.",
      "ja": "#rule構築物「＃」の要素のリストを定義するために、「*」に似た、定義されます。完全形は（「」）それぞれが1つ以上のカンマで区切られた、少なくとも<n>は、ほとんど<M>要素に示す「<N>＃<M>要素」であり、任意の線形空白（LWS）。これは、リストの通常の形は非常に簡単になります。このような（* LWS要素*（* LWS「」* LWS要素））のようなルールは、この構築物が使用される場合はいつでも、null要素が許可されている1つの＃要素として示すことができるが、本要素の数に寄与しません。すなわち、「（要素）、（要素）」許可、2つだけの要素としてカウントされます。少なくとも一つの要素が必要とされるため、少なくとも一つの非ヌル要素が存在しなければなりません。 「#element」はゼロを含む、任意の数のを可能にするようにデフォルト値は0と無限大です。 「1＃要素」とは、少なくとも1つが必要です。そして「1つの＃の2element」は1か2を可能にします。"
    },
    {
      "indent": 3,
      "text": "; comment A semi-colon, set off some distance to the right of rule text, starts a comment that continues to the end of line. This is a simple way of including useful notes in parallel with the specifications.",
      "ja": ";セミコロンコメント、ルールテキストの右にある距離をオフに設定し、行の終わりまで続くコメントを開始します。これは仕様に対して有用な注釈をつけるための簡単な方法です。"
    },
    {
      "indent": 3,
      "text": "implied *LWS The grammar described by this specification is word-based. Except where noted otherwise, linear white space (LWS) can be included between any two adjacent words (token or quoted-string), and between adjacent words and separators, without changing the interpretation of a field. At least one delimiter (LWS and/or",
      "ja": "暗示*この仕様で記述文法は単語ベースでLWS。特記する場合を除いて、線形空白（LWS）は、フィールドの解釈を変えることなく、任意の2つの隣接する単語（トークンまたは引用文字列）の間に、隣接する単語とセパレータとの間に含めることができます。少なくとも一つのデリミタ（LWS及び/又は"
    },
    {
      "indent": 6,
      "text": "separators) MUST exist between any two tokens (for the definition of \"token\" below), since they would otherwise be interpreted as a single token.",
      "ja": "それらがそうでなければ、単一のトークンとして解釈されるので、セパレータ）は、以下の「トークン」の定義のための任意の2つのトークン（）間に存在しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2 Basic Rules",
      "section_title": true,
      "ja": "2.2基本ルール"
    },
    {
      "indent": 3,
      "text": "The following rules are used throughout this specification to describe basic parsing constructs. The US-ASCII coded character set is defined by ANSI X3.4-1986 [21].",
      "ja": "次のルールは、基本的な構文解析構造を記述するために本明細書を通して使用されています。 US-ASCIIコード化文字セットはANSI X3.4-1986 [21]によって定義されます。"
    },
    {
      "indent": 7,
      "text": "OCTET          = <any 8-bit sequence of data>\nCHAR           = <any US-ASCII character (octets 0 - 127)>\nUPALPHA        = <any US-ASCII uppercase letter \"A\"..\"Z\">\nLOALPHA        = <any US-ASCII lowercase letter \"a\"..\"z\">\nALPHA          = UPALPHA | LOALPHA\nDIGIT          = <any US-ASCII digit \"0\"..\"9\">\nCTL            = <any US-ASCII control character\n                 (octets 0 - 31) and DEL (127)>\nCR             = <US-ASCII CR, carriage return (13)>\nLF             = <US-ASCII LF, linefeed (10)>\nSP             = <US-ASCII SP, space (32)>\nHT             = <US-ASCII HT, horizontal-tab (9)>\n<\">            = <US-ASCII double-quote mark (34)>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all protocol elements except the entity-body (see appendix 19.3 for tolerant applications). The end-of-line marker within an entity-body is defined by its associated media type, as described in section 3.7.",
      "ja": "HTTP / 1.1（耐性用途のための付録19.3を参照）エンティティボディ以外のすべてのプロトコル要素のための行末マーカーとしてシーケンスCR LFを定義します。セクション3.7で説明したようにエンティティボディ内の行末マーカーは、その関連するメディアタイプによって定義されます。"
    },
    {
      "indent": 7,
      "text": "CRLF = CR LF",
      "ja": "CRLF = CR LF"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 header field values can be folded onto multiple lines if the continuation line begins with a space or horizontal tab. All linear white space, including folding, has the same semantics as SP. A recipient MAY replace any linear white space with a single SP before interpreting the field value or forwarding the message downstream.",
      "ja": "継続行はスペースまたは水平タブで始まる場合HTTP / 1.1ヘッダフィールドの値が複数行に折り畳むことができます。折りたたみを含むすべてのリニアホワイトスペースは、SPと同じ意味を持っています。受信者は、フィールドの値を解釈するか、下流のメッセージを転送する前に、単一のSPを持つ任意の線形空白を置き換えることができます。"
    },
    {
      "indent": 7,
      "text": "LWS = [CRLF] 1*( SP | HT )",
      "ja": "LWS = [CRLF] 1 *（SP | HT）"
    },
    {
      "indent": 3,
      "text": "The TEXT rule is only used for descriptive field contents and values that are not intended to be interpreted by the message parser. Words of *TEXT MAY contain characters from character sets other than ISO-8859-1 [22] only when encoded according to the rules of RFC 2047 [14].",
      "ja": "TEXTルールは、メッセージパーサによって解釈されることを意図するものではない記述フィールドの内容と値のために使用されます。 TEXT *の言葉は、文字から文字を含めることができ[14] RFC 2047の規則に従ってエンコードされた場合にのみ、[22] ISO-8859-1以外の設定します。"
    },
    {
      "indent": 7,
      "text": "TEXT           = <any OCTET except CTLs,\n                 but including LWS>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A CRLF is allowed in the definition of TEXT only as part of a header field continuation. It is expected that the folding LWS will be replaced with a single SP before interpretation of the TEXT value.",
      "ja": "CRLFだけヘッダーフィールド継続の一部としてテキストの定義で許可されています。折りたたみLWSはTEXT値の解釈前に、単一のSPに置き換えされることが期待されます。"
    },
    {
      "indent": 3,
      "text": "Hexadecimal numeric characters are used in several protocol elements.",
      "ja": "進数字は、いくつかのプロトコル要素で使用されています。"
    },
    {
      "indent": 7,
      "text": "HEX            = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n               | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | DIGIT",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Many HTTP/1.1 header field values consist of words separated by LWS or special characters. These special characters MUST be in a quoted string to be used within a parameter value (as defined in section 3.6).",
      "ja": "多くのHTTP / 1.1ヘッダフィールドの値は、LWSまたは特殊文字で区切られた単語から成ります。これらの特殊文字は（セクション3.6で定義されるように）パラメータ値内で使用される引用符で囲まれた文字列でなければなりません。"
    },
    {
      "indent": 7,
      "text": "token          = 1*<any CHAR except CTLs or separators>\nseparators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n               | \",\" | \";\" | \":\" | \"\\\" | <\">\n               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n               | \"{\" | \"}\" | SP | HT",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Comments can be included in some HTTP header fields by surrounding the comment text with parentheses. Comments are only allowed in fields containing \"comment\" as part of their field value definition. In all other fields, parentheses are considered part of the field value.",
      "ja": "コメントは括弧とコメントテキストを囲むことにより、いくつかのHTTPヘッダフィールドに含めることができます。コメントは自分のフィールド値定義の一部として「コメント」を含むフィールドで許可されています。他のすべてのフィールドでは、括弧はフィールド値の一部とみなされます。"
    },
    {
      "indent": 7,
      "text": "comment        = \"(\" *( ctext | quoted-pair | comment ) \")\"\nctext          = <any TEXT excluding \"(\" and \")\">",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A string of text is parsed as a single word if it is quoted using double-quote marks.",
      "ja": "それは、二重引用符を使用して引用されている場合は、テキストの文字列は、単一の単語として解析されます。"
    },
    {
      "indent": 7,
      "text": "quoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\nqdtext         = <any TEXT except <\">>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The backslash character (\"\\\") MAY be used as a single-character quoting mechanism only within quoted-string and comment constructs.",
      "ja": "バックスラッシュ文字（「\\」）は唯一の引用された文字列とコメント構文内の単一文字引用メカニズムとして使用することができます。"
    },
    {
      "indent": 7,
      "text": "quoted-pair = \"\\\" CHAR",
      "ja": "引用されたペア=「\\」CHAR"
    },
    {
      "indent": 0,
      "text": "3 Protocol Parameters",
      "ja": "3つのプロトコルパラメータ"
    },
    {
      "indent": 0,
      "text": "3.1 HTTP Version",
      "section_title": true,
      "ja": "3.1 HTTPバージョン"
    },
    {
      "indent": 3,
      "text": "HTTP uses a \"<major>.<minor>\" numbering scheme to indicate versions of the protocol. The protocol versioning policy is intended to allow the sender to indicate the format of a message and its capacity for understanding further HTTP communication, rather than the features obtained via that communication. No change is made to the version number for the addition of message components which do not affect communication behavior or which only add to extensible field values. The <minor> number is incremented when the changes made to the protocol add features which do not change the general message parsing algorithm, but which may add to the message semantics and imply additional capabilities of the sender. The <major> number is incremented when the format of a message within the protocol is changed. See RFC 2145 [36] for a fuller explanation.",
      "ja": "HTTPプロトコルのバージョンを示すために、「<主要な>。<マイナー>」番号方式を使用しています。プロトコルのバージョン管理ポリシーは、メッセージのフォーマットおよび機能は、通信を介して取得するのではなく、さらにHTTP通信を理解するための能力を示すために、送信者を許可することを意図しています。変更なしは、通信動作に影響を与えるか、のみ拡張可能なフィールド値に追加されていないメッセージ成分の添加のためのバージョン番号に行われません。プロトコルに加えられた変更は、アルゴリズムを解析し、一般的なメッセージを変更しませんが、メッセージのセマンティクスに追加して、送信者の追加機能を暗示している機能を追加するとき、<マイナー>番号がインクリメントされます。プロトコル内のメッセージのフォーマットが変更された場合、<メジャー>数をインクリメントします。充実の説明については、RFC 2145 [36]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The version of an HTTP message is indicated by an HTTP-Version field in the first line of the message.",
      "ja": "HTTPメッセージのバージョンはメッセージの最初の行にHTTP-Versionフィールドで示されています。"
    },
    {
      "indent": 7,
      "text": "HTTP-Version = \"HTTP\" \"/\" 1*DIGIT \".\" 1*DIGIT",
      "ja": "HTTP-バージョン= \"HTTP\" \"/\" 1 * DIGIT \"\" 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "Note that the major and minor numbers MUST be treated as separate integers and that each MAY be incremented higher than a single digit. Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and MUST NOT be sent.",
      "ja": "メジャー番号とマイナー番号が別々の整数として扱われ、それぞれが一桁以上高い増分することができることをしなければならないことに注意してください。従って、HTTP / 2.4はHTTP / 2.13、今度はHTTP / 12.3未満であるよりも低いバージョンです。先頭のゼロは、受信者によって無視されなければならないと送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "An application that sends a request or response message that includes HTTP-Version of \"HTTP/1.1\" MUST be at least conditionally compliant with this specification. Applications that are at least conditionally compliant with this specification SHOULD use an HTTP-Version of \"HTTP/1.1\" in their messages, and MUST do so for any message that is not compatible with HTTP/1.0. For more details on when to send specific HTTP-Version values, see RFC 2145 [36].",
      "ja": "「HTTP / 1.1」のHTTP-バージョンを含む要求または応答メッセージを送信するアプリケーションは、本明細書と少なくとも条件に準拠しなければなりません。この仕様で少なくとも条件に準拠しているアプリケーションは、そのメッセージにHTTP-バージョン「HTTP / 1.1」のを使用すべきである、とHTTP / 1.0との互換性はありません任意のメッセージのためにそうしなければなりません。特定のHTTP-バージョン値を送信する際の詳細については、RFC 2145 [36]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The HTTP version of an application is the highest HTTP version for which the application is at least conditionally compliant.",
      "ja": "アプリケーションのHTTPバージョンはアプリケーションが少なくとも条件に準拠しているため、最も高いHTTPバージョンです。"
    },
    {
      "indent": 3,
      "text": "Proxy and gateway applications need to be careful when forwarding messages in protocol versions different from that of the application. Since the protocol version indicates the protocol capability of the sender, a proxy/gateway MUST NOT send a message with a version indicator which is greater than its actual version. If a higher version request is received, the proxy/gateway MUST either downgrade the request version, or respond with an error, or switch to tunnel behavior.",
      "ja": "プロキシとゲートウェイアプリケーションは、アプリケーションとは異なるプロトコル・バージョンでメッセージを転送するときに注意する必要があります。プロトコルバージョンは、送信者のプロトコル能力を示すので、プロキシ/ゲートウェイは、実際のバージョンよりも大きいバージョンインジケータとメッセージを送ってはいけません。より高いバージョン要求が受信された場合、プロキシ/ゲートウェイは、リクエストのバージョンをダウングレード、あるいはエラーで応答、またはトンネル動作に切り替える必要があります。"
    },
    {
      "indent": 3,
      "text": "Due to interoperability problems with HTTP/1.0 proxies discovered since the publication of RFC 2068[33], caching proxies MUST, gateways MAY, and tunnels MUST NOT upgrade the request to the highest version they support. The proxy/gateway's response to that request MUST be in the same major version as the request.",
      "ja": "HTTPとの相互運用性の問題に/ 1.0プロキシがRFC 2068の出版以来、発見された[33]は、キャッシングプロキシは、ゲートウェイは、トンネルとは、サポートする最新のバージョンに要求をアップグレードしてはならないかもしれないしなければなりません。その要求へのプロキシ/ゲートウェイのレスポンスはリクエストと同じメジャーバージョンでなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: Converting between versions of HTTP may involve modification of header fields required or forbidden by the versions involved.",
      "ja": "注：HTTPのバージョン間の変換は関与バージョンによって必要とされる又は禁止ヘッダフィールドの変更を伴ってもよいです。"
    },
    {
      "indent": 0,
      "text": "3.2 Uniform Resource Identifiers",
      "section_title": true,
      "ja": "3.2統一資源識別子"
    },
    {
      "indent": 3,
      "text": "URIs have been known by many names: WWW addresses, Universal Document Identifiers, Universal Resource Identifiers [3], and finally the combination of Uniform Resource Locators (URL) [4] and Names (URN) [20]. As far as HTTP is concerned, Uniform Resource Identifiers are simply formatted strings which identify--via name, location, or any other characteristic--a resource.",
      "ja": "[20] WWWアドレス、ユニバーサルドキュメント識別子、ユニバーサルリソース識別子[3]、及びユニフォームリソースロケータ（URL）の最後に組み合わせ[4]と名前（URN）：URIは多くの名前で知られています。リソース - 名前、場所、または他の任意の特徴を介して - 限りHTTPに関しては、ユニフォームリソース識別子は、単純に特定の文字列を書式設定されています。"
    },
    {
      "indent": 0,
      "text": "3.2.1 General Syntax",
      "section_title": true,
      "ja": "3.2.1一般的な構文"
    },
    {
      "indent": 3,
      "text": "URIs in HTTP can be represented in absolute form or relative to some known base URI [11], depending upon the context of their use. The two forms are differentiated by the fact that absolute URIs always begin with a scheme name followed by a colon. For definitive information on URL syntax and semantics, see \"Uniform Resource Identifiers (URI): Generic Syntax and Semantics,\" RFC 2396 [42] (which replaces RFCs 1738 [4] and RFC 1808 [11]). This specification adopts the definitions of \"URI-reference\", \"absoluteURI\", \"relativeURI\", \"port\", \"host\",\"abs_path\", \"rel_path\", and \"authority\" from that specification.",
      "ja": "HTTPにおけるURIは、それらの使用状況に応じて、絶対的な形態またはいくつかの既知のベースURI [11]に対してで表すことができます。二つの形式は絶対URIが常にコロンスキーム名で開始しているという事実によって区別されます。 URLの構文およびセマンティクスに関する明確な情報については、 \"統一資源識別子（URI）：一般的な構文とセマンティクス、\" RFC 2396 [42]（RFCを置き換える1738 [4]およびRFC 1808 [11]）。この仕様はその仕様から「URI参照」、「absoluteURIで」、「relativeURI」、「ポート」、「ホスト」、「腹筋_経路」、「rel_path」、および「権威」の定義を採用しています。"
    },
    {
      "indent": 3,
      "text": "The HTTP protocol does not place any a priori limit on the length of a URI. Servers MUST be able to handle the URI of any resource they serve, and SHOULD be able to handle URIs of unbounded length if they provide GET-based forms that could generate such URIs. A server SHOULD return 414 (Request-URI Too Long) status if a URI is longer than the server can handle (see section 10.4.15).",
      "ja": "HTTPプロトコルは、URIの長さに任意のアプリオリ制限を課しません。サーバは彼らが提供するリソースのURIを扱うことができなければならない、と彼らは、そのようなURIを生成することができGETベースのフォームを提供する場合、無制限の長さのURIを処理できる必要があります。 URIは、サーバーが（セクション10.4.15を参照）を扱うことができるよりも長い場合、サーバは414（要求URIが長すぎます）のステータスを返すべきです。"
    },
    {
      "indent": 6,
      "text": "Note: Servers ought to be cautious about depending on URI lengths above 255 bytes, because some older client or proxy implementations might not properly support these lengths.",
      "ja": "注意：サーバーは、一部の古いクライアントやプロキシ実装が適切にこれらの長さをサポートしていない可能性がありますので、255バイト以上のURIの長さに応じて、約慎重であるべきです。"
    },
    {
      "indent": 0,
      "text": "3.2.2 http URL",
      "section_title": true,
      "ja": "3.2.2 HTTPのURL"
    },
    {
      "indent": 3,
      "text": "The \"http\" scheme is used to locate network resources via the HTTP protocol. This section defines the scheme-specific syntax and semantics for http URLs.",
      "ja": "「HTTP」スキームはHTTPプロトコルを介してネットワークリソースを検索するために使用されます。このセクションでは、HTTP URLのスキーム固有の構文およびセマンティクスを定義します。"
    },
    {
      "indent": 3,
      "text": "http_URL = \"http:\" \"//\" host [ \":\" port ] [ abs_path [ \"?\" query ]]",
      "ja": "HTTP_URL = \"HTTP：\" \"//\" ホスト[ \"：\" ポート] [腹筋_経路の[ \"\"？クエリ]]"
    },
    {
      "indent": 3,
      "text": "If the port is empty or not given, port 80 is assumed. The semantics are that the identified resource is located at the server listening for TCP connections on that port of that host, and the Request-URI for the resource is abs_path (section 5.1.2). The use of IP addresses in URLs SHOULD be avoided whenever possible (see RFC 1900 [24]). If the abs_path is not present in the URL, it MUST be given as \"/\" when used as a Request-URI for a resource (section 5.1.2). If a proxy receives a host name which is not a fully qualified domain name, it MAY add its domain to the host name it received. If a proxy receives a fully qualified domain name, the proxy MUST NOT change the host name.",
      "ja": "ポートが指定された空またはされていない場合、ポート80が仮定されます。セマンティクスは、特定されたリソースは、そのホストのそのポートでTCP接続の待機サーバーに配置されていることであり、資源のためのRequest-URIが腹筋_経路（セクション5.1.2）です。 URLでIPアドレスの使用は、（RFC 1900 [24]参照）可能な限り避けるべきです。腹筋_経路がURLに存在しない場合は、「/」リソースの要求-URIとして使用（セクション5.1.2）のように与えられなければなりません。プロキシは完全修飾ドメイン名ではありませんホスト名を受信した場合、それが受信したホスト名にそのドメインを追加するかもしれません。プロキシは完全修飾ドメイン名を受信した場合、プロキシは、ホスト名を変更しないでください。"
    },
    {
      "indent": 0,
      "text": "3.2.3 URI Comparison",
      "section_title": true,
      "ja": "3.2.3 URIの比較"
    },
    {
      "indent": 3,
      "text": "When comparing two URIs to decide if they match or not, a client SHOULD use a case-sensitive octet-by-octet comparison of the entire URIs, with these exceptions:",
      "ja": "それらが一致するかどうかを判断するために2つのURIを比較するか、しない場合、クライアントは、これらの例外を除いて、全体のURIの大文字と小文字を区別オクテットごとのオクテットの比較を、使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "- A port that is empty or not given is equivalent to the default port for that URI-reference;",
      "ja": " - 空であるか与えられていないポートは、URI参照のデフォルトのポートと等価です。"
    },
    {
      "indent": 8,
      "text": "- Comparisons of host names MUST be case-insensitive;",
      "ja": " - ホスト名の比較は大文字と小文字を区別してはなりません。"
    },
    {
      "indent": 8,
      "text": "- Comparisons of scheme names MUST be case-insensitive;",
      "ja": " - スキーム名の比較は大文字と小文字を区別しなければなりません。"
    },
    {
      "indent": 8,
      "text": "- An empty abs_path is equivalent to an abs_path of \"/\".",
      "ja": " - 空の腹筋_経路は、「/」の腹筋_経路に相当します。"
    },
    {
      "indent": 3,
      "text": "Characters other than those in the \"reserved\" and \"unsafe\" sets (see RFC 2396 [42]) are equivalent to their \"\"%\" HEX HEX\" encoding.",
      "ja": "「予約」と「安全でない」セット（RFC 2396 [42]参照）は「」％「HEX HEX」符号化に相当するもの以外の文字。"
    },
    {
      "indent": 3,
      "text": "For example, the following three URIs are equivalent:",
      "ja": "たとえば、次の三つのURIは等価です。"
    },
    {
      "indent": 6,
      "text": "http://abc.com:80/~smith/home.html http://ABC.com/%7Esmith/home.html http://ABC.com:/%7esmith/home.html",
      "ja": "ｈっｔｐ：／／あｂｃ。こｍ：８０／〜ｓみｔｈ／ほめ。ｈｔｍｌ ｈっｔｐ：／／あＢＣ。こｍ／％７えｓみｔｈ／ほめ。ｈｔｍｌ ｈっｔｐ：／／あＢＣ。こｍ：／％７えｓみｔｈ／ほめ。ｈｔｍｌ"
    },
    {
      "indent": 0,
      "text": "3.3 Date/Time Formats",
      "section_title": true,
      "ja": "3.3日付/時刻書式"
    },
    {
      "indent": 0,
      "text": "3.3.1 Full Date",
      "section_title": true,
      "ja": "3.3.1完全な日付"
    },
    {
      "indent": 3,
      "text": "HTTP applications have historically allowed three different formats for the representation of date/time stamps:",
      "ja": "HTTPアプリケーションは歴史的に、日付/タイムスタンプの表現のための3つの異なるフォーマットを許可しています："
    },
    {
      "indent": 6,
      "text": "Sun, 06 Nov 1994 08:49:37 GMT ; RFC 822, updated by RFC 1123 Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036 Sun Nov 6 08:49:37 1994 ; ANSI C's asctime() format",
      "ja": "日、1994年11月6日午前8時49分37秒GMT。 RFC 822、日曜日RFC 1123によって更新、06  -  11月 -  94 8時49分37秒GMT。 RFC 1036日11月6日午前8時49分37秒1994で廃止R​​FC 850、。 ANSI Cの関数は、asctime（）フォーマット"
    },
    {
      "indent": 3,
      "text": "The first format is preferred as an Internet standard and represents a fixed-length subset of that defined by RFC 1123 [8] (an update to RFC 822 [9]). The second format is in common use, but is based on the obsolete RFC 850 [12] date format and lacks a four-digit year. HTTP/1.1 clients and servers that parse the date value MUST accept all three formats (for compatibility with HTTP/1.0), though they MUST only generate the RFC 1123 format for representing HTTP-date values in header fields. See section 19.3 for further information.",
      "ja": "最初の形式は、（[9] RFC 822への更新）インターネット標準として好ましく、RFC 1123によって定義された固定長の部分集合[8]を示しています。第二の形式は、一般的に使用されているが、廃止されたRFC 850 [12]日付フォーマットに基づいており、4桁の年を欠いています。彼らは唯一のヘッダフィールドにHTTP-日付値を表すためのRFC 1123形式を生成しなければならないのにHTTP /日付値を解析1.1クライアントとサーバは、（HTTP / 1.0との互換性のための）3つのすべてのフォーマットを受け入れなければなりません。詳細については項19.3を参照してください。"
    },
    {
      "indent": 6,
      "text": "Note: Recipients of date values are encouraged to be robust in accepting date values that may have been sent by non-HTTP applications, as is sometimes the case when retrieving or posting messages via proxies/gateways to SMTP or NNTP.",
      "ja": "注：日付値の受信者は、SMTPまたはNNTPへのプロキシ/ゲートウェイを介してメッセージを取得するか、投稿するときに時々そうであるように、非HTTPアプリケーションによって送信された可能性があり日付値を受け入れるに堅牢であることを奨励されています。"
    },
    {
      "indent": 3,
      "text": "All HTTP date/time stamps MUST be represented in Greenwich Mean Time (GMT), without exception. For the purposes of HTTP, GMT is exactly equal to UTC (Coordinated Universal Time). This is indicated in the first two formats by the inclusion of \"GMT\" as the three-letter abbreviation for time zone, and MUST be assumed when reading the asctime format. HTTP-date is case sensitive and MUST NOT include additional LWS beyond that specifically included as SP in the grammar.",
      "ja": "すべてのHTTP日付/時刻スタンプは例外なく、グリニッジ標準時（GMT）で表されなければなりません。 HTTPの目的のために、GMTはUTC（協定世界時）に正確に等しいです。これは、タイムゾーンの3文字の省略形として「GMT」を含めることによって最初の2つの形式で示され、そしているasctimeフォーマットを読み取る場合に想定されなければなりません。 HTTP-日は、大文字と小文字が区別され、具体的文法でSPとして含まそれを超えて追加のLWSを含んではいけません。"
    },
    {
      "indent": 7,
      "text": "HTTP-date    = rfc1123-date | rfc850-date | asctime-date\nrfc1123-date = wkday \",\" SP date1 SP time SP \"GMT\"\nrfc850-date  = weekday \",\" SP date2 SP time SP \"GMT\"\nasctime-date = wkday SP date3 SP time SP 4DIGIT\ndate1        = 2DIGIT SP month SP 4DIGIT\n               ; day month year (e.g., 02 Jun 1982)\ndate2        = 2DIGIT \"-\" month \"-\" 2DIGIT\n               ; day-month-year (e.g., 02-Jun-82)\ndate3        = month SP ( 2DIGIT | ( SP 1DIGIT ))\n               ; month day (e.g., Jun  2)\ntime         = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT\n               ; 00:00:00 - 23:59:59\nwkday        = \"Mon\" | \"Tue\" | \"Wed\"\n             | \"Thu\" | \"Fri\" | \"Sat\" | \"Sun\"\nweekday      = \"Monday\" | \"Tuesday\" | \"Wednesday\"\n             | \"Thursday\" | \"Friday\" | \"Saturday\" | \"Sunday\"\nmonth        = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\n             | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n             | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Note: HTTP requirements for the date/time stamp format apply only to their usage within the protocol stream. Clients and servers are not required to use these formats for user presentation, request logging, etc.",
      "ja": "注：HTTP日付/時刻スタンプ形式の要件は、プロトコルストリーム内のそれらの使用法にのみ適用されます。クライアントとサーバーは、ユーザーの提示、要求ロギングなどのために、これらのフォーマットを使用する必要はありません"
    },
    {
      "indent": 0,
      "text": "3.3.2 Delta Seconds",
      "section_title": true,
      "ja": "3.3.2デルタ秒"
    },
    {
      "indent": 3,
      "text": "Some HTTP header fields allow a time value to be specified as an integer number of seconds, represented in decimal, after the time that the message was received.",
      "ja": "いくつかのHTTPヘッダフィールドは、時間値は、メッセージが受信された時間の後に10進数で表される秒の整数として指定されることを可能にします。"
    },
    {
      "indent": 7,
      "text": "delta-seconds = 1*DIGIT",
      "ja": "デルタ秒= 1 * DIGIT"
    },
    {
      "indent": 0,
      "text": "3.4 Character Sets",
      "section_title": true,
      "ja": "3.4文字セット"
    },
    {
      "indent": 3,
      "text": "HTTP uses the same definition of the term \"character set\" as that described for MIME:",
      "ja": "HTTPはMIMEのために記載されるような用語「文字セット」の同じ定義を使用しています。"
    },
    {
      "indent": 3,
      "text": "The term \"character set\" is used in this document to refer to a method used with one or more tables to convert a sequence of octets into a sequence of characters. Note that unconditional conversion in the other direction is not required, in that not all characters may be available in a given character set and a character set may provide more than one sequence of octets to represent a particular character. This definition is intended to allow various kinds of character encoding, from simple single-table mappings such as US-ASCII to complex table switching methods such as those that use ISO-2022's techniques. However, the definition associated with a MIME character set name MUST fully specify the mapping to be performed from octets to characters. In particular, use of external profiling information to determine the exact mapping is not permitted.",
      "ja": "用語「文字セット」は、文字のシーケンスにオクテットのシーケンスを変換するために、1つまたは複数のテーブルで使用する方法を参照するために、このドキュメントで使用されています。他の方向に無条件変換が必要とされないことが、その中のすべての文字が指定された文字セットと文字セットで利用可能なものがない注特定の文字を表すオクテットの複数のシーケンスを提供することができます。この定義は、ISO-2022の技術を使用するものなどの方法を切り替えるようにUS-ASCIIなどの簡単な単一テーブルマッピングから複雑なテーブルに、文字エンコーディングの様々な種類を許可するように意図されます。しかし、MIME文字セット名に関連付けられている定義は、完全に文字にオクテットから実行されるマッピングを指定する必要があります。特に、正確なマッピングを決定するために、外部のプロファイリング情報の使用が許可されていません。"
    },
    {
      "indent": 6,
      "text": "Note: This use of the term \"character set\" is more commonly referred to as a \"character encoding.\" However, since HTTP and MIME share the same registry, it is important that the terminology also be shared.",
      "ja": "注意：用語「文字セット」のこの使用は、より一般に呼ばれる「文字エンコーディング。」 HTTPとMIMEが同じレジストリを共有しているのでしかし、専門用語も共有することが重要です。"
    },
    {
      "indent": 3,
      "text": "HTTP character sets are identified by case-insensitive tokens. The complete set of tokens is defined by the IANA Character Set registry [19].",
      "ja": "HTTP文字セットは大文字と小文字を区別しないトークンによって識別されます。トークンの完全なセットは、IANA文字セット登録[19]によって定義されます。"
    },
    {
      "indent": 7,
      "text": "charset = token",
      "ja": "文字セット=トークン"
    },
    {
      "indent": 3,
      "text": "Although HTTP allows an arbitrary token to be used as a charset value, any token that has a predefined value within the IANA Character Set registry [19] MUST represent the character set defined by that registry. Applications SHOULD limit their use of character sets to those defined by the IANA registry.",
      "ja": "HTTPはcharset値、IANA文字セットレジストリ内の予め定義された値を有する任意のトークンとして使用される任意のトークンを可能にするが[19]、そのレジストリで定義されている文字セットを表現しなければなりません。アプリケーションは、IANAレジストリで定義されたものに文字セットの使用を制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementors should be aware of IETF character set requirements [38] [41].",
      "ja": "実装者は、[38] [41] IETF文字セットの要件に注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4.1 Missing Charset",
      "section_title": true,
      "ja": "3.4.1不足している文字セット"
    },
    {
      "indent": 3,
      "text": "Some HTTP/1.0 software has interpreted a Content-Type header without charset parameter incorrectly to mean \"recipient should guess.\" Senders wishing to defeat this behavior MAY include a charset parameter even when the charset is ISO-8859-1 and SHOULD do so when it is known that it will not confuse the recipient.",
      "ja": "いくつかのHTTP / 1.0ソフトウェアが正しく意味するcharsetパラメータなしのContent-Typeヘッダを解釈した「受信者は推測する必要があります。」文字セットはISO-8859-1であると、受信者を混乱させないことが知られているときに行う必要があります場合でも、この動作を無効にしたい送信者は、charsetパラメータを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, some older HTTP/1.0 clients did not deal properly with an explicit charset parameter. HTTP/1.1 recipients MUST respect the charset label provided by the sender; and those user agents that have a provision to \"guess\" a charset MUST use the charset from the content-type field if they support that charset, rather than the recipient's preference, when initially displaying a document. See section 3.7.1.",
      "ja": "残念ながら、いくつかの古いHTTP / 1.0クライアントは、明示的なcharsetパラメータを適切に処理しませんでした。 HTTP / 1.1の受信者は、送信者が提供する文字セットのラベルを尊重しなければなりません。彼らはその文字セットをサポートしている場合、最初に文書を表示するときや文字セットを「推測」する規定を持って、それらのユーザーエージェントは、むしろ受信者の好みよりも、Content-Typeフィールドから文字セットを使用しなければなりません。セクション3.7.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.5 Content Codings",
      "section_title": true,
      "ja": "3.5コンテンツコーディング"
    },
    {
      "indent": 3,
      "text": "Content coding values indicate an encoding transformation that has been or can be applied to an entity. Content codings are primarily used to allow a document to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information. Frequently, the entity is stored in coded form, transmitted directly, and only decoded by the recipient.",
      "ja": "コンテンツ符号化値がされている、またはエンティティに適用することができる符号変換を示します。内容コーディングは、主に文書がその根底にあるメディアタイプのアイデンティティを失うことなく、情報の損失なしに圧縮されるか、またはそうでなければ有効に変換することができるようにするために使用されています。しばしば、エンティティは、符号化された形式で格納されている直接送信され、受信者だけによって復号されます。"
    },
    {
      "indent": 7,
      "text": "content-coding = token",
      "ja": "コンテンツコーディング=トークン"
    },
    {
      "indent": 3,
      "text": "All content-coding values are case-insensitive. HTTP/1.1 uses content-coding values in the Accept-Encoding (section 14.3) and Content-Encoding (section 14.11) header fields. Although the value describes the content-coding, what is more important is that it indicates what decoding mechanism will be required to remove the encoding.",
      "ja": "すべてのコンテンツコーディング値は、大文字と小文字を区別しません。 HTTP / 1.1は受け入れエンコード（セクション14.3）とContent-符号化（セクション14.11）ヘッダーフィールドのコンテンツ符号化値を使用します。値は、コンテンツの符号化を記載しているが、何より重要なことは、それが復号機構が符号化を除去するために必要とされるかを示すことです。"
    },
    {
      "indent": 3,
      "text": "The Internet Assigned Numbers Authority (IANA) acts as a registry for content-coding value tokens. Initially, the registry contains the following tokens:",
      "ja": "IANA（Internet Assigned Numbers Authority）は、コンテンツコード値トークンのレジストリとして作用します。最初は、レジストリは次のトークンが含まれています。"
    },
    {
      "indent": 3,
      "text": "gzip An encoding format produced by the file compression program \"gzip\" (GNU zip) as described in RFC 1952 [25]. This format is a Lempel-Ziv coding (LZ77) with a 32 bit CRC.",
      "ja": "RFC 1952 [25]に記載されているように、ファイル圧縮プログラム「GZIP」（GNUのzip）によって生成された符号化形式をgzip。このフォーマットは、32ビットのCRCを有するLempel-Zivコーディング（LZ77）です。"
    },
    {
      "indent": 3,
      "text": "compress The encoding format produced by the common UNIX file compression program \"compress\". This format is an adaptive Lempel-Ziv-Welch coding (LZW).",
      "ja": "一般的なUNIXファイル圧縮プログラム「圧縮」によって生成エンコード形式を圧縮します。この形式は、適応符号化のLempel-Ziv符号-ウェルチ（LZW）です。"
    },
    {
      "indent": 8,
      "text": "Use of program names for the identification of encoding formats\nis not desirable and is discouraged for future encodings. Their\nuse here is representative of historical practice, not good\ndesign. For compatibility with previous implementations of HTTP,\napplications SHOULD consider \"x-gzip\" and \"x-compress\" to be\nequivalent to \"gzip\" and \"compress\" respectively.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "deflate The \"zlib\" format defined in RFC 1950 [31] in combination with the \"deflate\" compression mechanism described in RFC 1951 [29].",
      "ja": "RFC 1951 [29]に記載の「収縮」圧縮機構と組み合わせてRFC 1950 [31]で定義された「ZLIB」形式を収縮させます。"
    },
    {
      "indent": 3,
      "text": "identity The default (identity) encoding; the use of no transformation whatsoever. This content-coding is used only in the Accept-Encoding header, and SHOULD NOT be used in the Content-Encoding header.",
      "ja": "アイデンティティデフォルト（アイデンティティ）エンコーディング。一切の変換を使用します。このコンテンツコーディングは、唯一のAccept-Encodingヘッダで使用され、およびContent-Encodingヘッダーで使用すべきではありません。"
    },
    {
      "indent": 3,
      "text": "New content-coding value tokens SHOULD be registered; to allow interoperability between clients and servers, specifications of the content coding algorithms needed to implement a new value SHOULD be publicly available and adequate for independent implementation, and conform to the purpose of content coding defined in this section.",
      "ja": "新コンテンツコーディング値トークンを登録する必要があります。クライアントとサーバ間の相互運用性を可能にし、新たな価値を実現するために必要な符号化アルゴリズムコンテンツの仕様は、独立した実装のために公に利用可能と十分であり、このセクションで定義されたコンテンツの符号化の目的に合致すべきです。"
    },
    {
      "indent": 0,
      "text": "3.6 Transfer Codings",
      "section_title": true,
      "ja": "3.6転送コーディング"
    },
    {
      "indent": 3,
      "text": "Transfer-coding values are used to indicate an encoding transformation that has been, can be, or may need to be applied to an entity-body in order to ensure \"safe transport\" through the network. This differs from a content coding in that the transfer-coding is a property of the message, not of the original entity.",
      "ja": "転送符号化値がされた符号化変換を示すために使用される、とすることができる、またはネットワークを介して「安全輸送」を確保するために、エンティティボディに適用される必要があるかもしれません。これは転送コーディングがメッセージのではなく、元のエンティティのプロパティであることを符号化コンテンツとは異なります。"
    },
    {
      "indent": 7,
      "text": "transfer-coding         = \"chunked\" | transfer-extension\ntransfer-extension      = token *( \";\" parameter )",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Parameters are in the form of attribute/value pairs.",
      "ja": "パラメータは、属性/値のペアの形です。"
    },
    {
      "indent": 7,
      "text": "parameter               = attribute \"=\" value\nattribute               = token\nvalue                   = token | quoted-string",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All transfer-coding values are case-insensitive. HTTP/1.1 uses transfer-coding values in the TE header field (section 14.39) and in the Transfer-Encoding header field (section 14.41).",
      "ja": "すべての転送コーディング値は、大文字と小文字を区別しません。 HTTP / 1.1は、TEヘッダフィールド（セクション14.39）および転送符号化ヘッダフィールド（セクション14.41）で転送コーディング値を使用します。"
    },
    {
      "indent": 3,
      "text": "Whenever a transfer-coding is applied to a message-body, the set of transfer-codings MUST include \"chunked\", unless the message is terminated by closing the connection. When the \"chunked\" transfer-coding is used, it MUST be the last transfer-coding applied to the message-body. The \"chunked\" transfer-coding MUST NOT be applied more than once to a message-body. These rules allow the recipient to determine the transfer-length of the message (section 4.4).",
      "ja": "転送コーディングがメッセージボディに適用されたとき、転送コーディングのセットは、メッセージが接続を閉じることによって終了されない限り、「チャンク」を含まなければなりません。 「チャンク」転送符号化が使用される場合、それは最後の転送コーディングメッセージボディに適用されなければなりません。 「チャンク」転送コーディングは、メッセージ本文に複数回適用してはなりません。これらのルールは、受信者がメッセージ（セクション4.4）の転送長を決定することを可能にします。"
    },
    {
      "indent": 3,
      "text": "Transfer-codings are analogous to the Content-Transfer-Encoding values of MIME [7], which were designed to enable safe transport of binary data over a 7-bit transport service. However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP, the only unsafe characteristic of message-bodies is the difficulty in determining the exact body length (section 7.2.2), or the desire to encrypt data over a shared transport.",
      "ja": "転送コーディングは、7ビットのトランスポート・サービス上のバイナリデータの安全な輸送を可能にするために設計されたMIMEのコンテンツ転送エンコード値[7]に類似しています。しかし、安全な輸送は、8ビット・クリーンな転送プロトコルの異なる焦点を持っています。 HTTPでは、メッセージ体の唯一危険な特性は、正確な本体長さ（セクション7.2.2）、または共有トランスポートを介してデータを暗号化したいという要望を決定するのが困難なことです。"
    },
    {
      "indent": 3,
      "text": "The Internet Assigned Numbers Authority (IANA) acts as a registry for transfer-coding value tokens. Initially, the registry contains the following tokens: \"chunked\" (section 3.6.1), \"identity\" (section 3.6.2), \"gzip\" (section 3.5), \"compress\" (section 3.5), and \"deflate\" (section 3.5).",
      "ja": "IANA（Internet Assigned Numbers Authority）は転送コーディング値トークンのレジストリとして作用します。最初は、レジストリは次のトークンが含まれています（セクション3.6.1）、 \"アイデンティティ\"（セクション3.6.2）、 \"GZIP\"（セクション3.5）、 \"チャンク\"、（セクション3.5） \"を圧縮\"、および \"収縮します\"（セクション3.5）。"
    },
    {
      "indent": 3,
      "text": "New transfer-coding value tokens SHOULD be registered in the same way as new content-coding value tokens (section 3.5).",
      "ja": "新しい転送コーディング値トークンは、新しいコンテンツコーディング値トークン（セクション3.5）と同じ方法で登録する必要があります。"
    },
    {
      "indent": 3,
      "text": "A server which receives an entity-body with a transfer-coding it does not understand SHOULD return 501 (Unimplemented), and close the connection. A server MUST NOT send transfer-codings to an HTTP/1.0 client.",
      "ja": "転送コーディングそれが理解できないとエンティティボディを受信したサーバ501（未実装）を返し、接続を閉じる必要があります。サーバは、HTTP / 1.0クライアントに転送コーディングを送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "3.6.1 Chunked Transfer Coding",
      "section_title": true,
      "ja": "3.6.1チャンク転送コーディング"
    },
    {
      "indent": 3,
      "text": "The chunked encoding modifies the body of a message in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer containing entity-header fields. This allows dynamically produced content to be transferred along with the information necessary for the recipient to verify that it has received the full message.",
      "ja": "チャンク符号化は、エンティティヘッダフィールドを含むオプショントレーラが続くチャンクのシリーズ、独自のサイズインジケータと各、としてそれを転送するためにメッセージの本文を修正します。これは、完全なメッセージを受信したことを確認するために受信者に必要な情報とともに転送される動的に生成されるコンテンツを可能にします。"
    },
    {
      "indent": 7,
      "text": "Chunked-Body   = *chunk\n                 last-chunk\n                 trailer\n                 CRLF",
      "raw": true
    },
    {
      "indent": 7,
      "text": "chunk = chunk-size [ chunk-extension ] CRLF chunk-data CRLF chunk-size = 1*HEX last-chunk = 1*(\"0\") [ chunk-extension ] CRLF",
      "ja": "= 1 * HEX最後のチャンク= 1 *（「0」）[チャンク・エクステンション] CRLFチャンク=チャンクサイズ[チャンク拡張] CRLFチャンクデータCRLFチャンクサイズ"
    },
    {
      "indent": 7,
      "text": "chunk-extension= *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] ) chunk-ext-name = token chunk-ext-val = token | quoted-string chunk-data = chunk-size(OCTET) trailer = *(entity-header CRLF)",
      "ja": "チャンク拡張子= *（ \";\" チャンク-EXT-名[ \"=\" チャンク-EXT-VAL]）チャンク-EXT-名=トークンチャンク-EXT-VAL =トークン|引用符で囲まれた文字列のチャンクデータ=チャンクサイズ（オクテット）トレーラー= *（エンティティヘッダCRLF）"
    },
    {
      "indent": 3,
      "text": "The chunk-size field is a string of hex digits indicating the size of the chunk. The chunked encoding is ended by any chunk whose size is zero, followed by the trailer, which is terminated by an empty line.",
      "ja": "チャンクサイズのフィールドは、チャンクのサイズを示す進数字の列です。チャンクエンコーディングは、その大きさがゼロである、空行で終了しトレーラー、続いて任意のチャンクによって終了されます。"
    },
    {
      "indent": 3,
      "text": "The trailer allows the sender to include additional HTTP header fields at the end of the message. The Trailer header field can be used to indicate which header fields are included in a trailer (see section 14.40).",
      "ja": "トレーラは、送信者がメッセージの最後に追加のHTTPヘッダフィールドを含めることができます。トレーラーヘッダフィールドは、ヘッダフィールドがトレーラに含まれるかを示すために使用することができる（セクション14.40を参照）。"
    },
    {
      "indent": 3,
      "text": "A server using chunked transfer-coding in a response MUST NOT use the trailer for any header fields unless at least one of the following is true:",
      "ja": "以下の少なくとも一つが真でなければ応答してチャンク転送符号化を使用して、サーバは、任意のヘッダフィールドのトレーラーを使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "a)the request included a TE header field that indicates \"trailers\" is acceptable in the transfer-coding of the response, as described in section 14.39; or,",
      "ja": "a）リクエストは、セクション14.39に記載されているように「トレーラー」を示すTEヘッダフィールドは、応答の転送コーディングで許容含まれます。または、"
    },
    {
      "indent": 3,
      "text": "b)the server is the origin server for the response, the trailer fields consist entirely of optional metadata, and the recipient could use the message (in a manner acceptable to the origin server) without receiving this metadata. In other words, the origin server is willing to accept the possibility that the trailer fields might be silently discarded along the path to the client.",
      "ja": "b）は、サーバが応答するためのオリジンサーバであり、トレーラフィールドは、オプションのメタデータを完全に構成され、受信者はこのメタデータを受信することなく、オリジンサーバに許容されるようにメッセージ（）を使用することができます。言い換えれば、オリジンサーバは、トレーラーのフィールドは黙っクライアントへのパスに沿って捨てられるかもしれないという可能性を受け入れることを望んでいます。"
    },
    {
      "indent": 3,
      "text": "This requirement prevents an interoperability failure when the message is being received by an HTTP/1.1 (or later) proxy and forwarded to an HTTP/1.0 recipient. It avoids a situation where compliance with the protocol would have necessitated a possibly infinite buffer on the proxy.",
      "ja": "この要件は、メッセージがHTTP / 1.1（またはそれ以降）プロキシによって受信され、HTTP / 1.0の受信者に転送されている相互運用性の障害を防止することができます。これは、プロトコルの遵守がプロキシ上の可能性が無限のバッファを必要としているでしょう事態を避けることができます。"
    },
    {
      "indent": 3,
      "text": "An example process for decoding a Chunked-Body is presented in appendix 19.4.6.",
      "ja": "チャンク・ボディを復号化するためのプロセス例は、付録19.4.6に提示されています。"
    },
    {
      "indent": 3,
      "text": "All HTTP/1.1 applications MUST be able to receive and decode the \"chunked\" transfer-coding, and MUST ignore chunk-extension extensions they do not understand.",
      "ja": "すべてのHTTP / 1.1のアプリケーションが受け取ると、「チャンク」転送コーディングをデコードできなければならない、と彼らは理解していないチャンクの拡張機能拡張を無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.7 Media Types",
      "section_title": true,
      "ja": "3.7メディアタイプ"
    },
    {
      "indent": 3,
      "text": "HTTP uses Internet Media Types [17] in the Content-Type (section 14.17) and Accept (section 14.1) header fields in order to provide open and extensible data typing and type negotiation.",
      "ja": "HTTPは、コンテンツタイプ（セクション14.17）、インターネットメディアタイプ[17]を使用し、オープンで拡張可能なデータタイプ及びタイプのネゴシエーションを提供するために（セクション14.1）ヘッダフィールドを受け入れます。"
    },
    {
      "indent": 7,
      "text": "media-type     = type \"/\" subtype *( \";\" parameter )\ntype           = token\nsubtype        = token",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Parameters MAY follow the type/subtype in the form of attribute/value pairs (as defined in section 3.6).",
      "ja": "（セクション3.6で定義されるように）パラメータは、属性/値のペアの形式でタイプ/サブタイプに従うことができます。"
    },
    {
      "indent": 3,
      "text": "The type, subtype, and parameter attribute names are case-insensitive. Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name. Linear white space (LWS) MUST NOT be used between the type and subtype, nor between an attribute and its value. The presence or absence of a parameter might be significant to the processing of a media-type, depending on its definition within the media type registry.",
      "ja": "タイプ、サブタイプ、およびパラメータ属性名は大文字と小文字を区別しません。パラメータ値は、パラメータ名のセマンティクスに応じて、大文字と小文字が区別されない場合があります。リニアホワイトスペース（LWS）はタイプとサブタイプの間で、また属性とその値の間で使用してはいけません。パラメータの有無メディアタイプレジストリ内のその定義に応じて、メディアタイプの処理に重要であるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Note that some older HTTP applications do not recognize media type parameters. When sending data to older HTTP applications, implementations SHOULD only use media type parameters when they are required by that type/subtype definition.",
      "ja": "一部の古いHTTPアプリケーションはメディアタイプパラメータを認識しないことに注意してください。古いHTTPアプリケーションにデータを送信するとき、彼らはそのタイプ/サブタイプの定義によって必要とされている場合、実装は唯一のメディアタイプパラメータを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Media-type values are registered with the Internet Assigned Number Authority (IANA [19]). The media type registration process is outlined in RFC 1590 [17]. Use of non-registered media types is discouraged.",
      "ja": "メディアタイプの値は、インターネット割り当て番号機関（IANA [19]）に登録されています。メディアタイプ登録処理は、RFC 1590 [17]に概説されています。非登録済みメディアタイプの使用は推奨されません。"
    },
    {
      "indent": 0,
      "text": "3.7.1 Canonicalization and Text Defaults",
      "section_title": true,
      "ja": "3.7.1正規化とテキストデフォルト"
    },
    {
      "indent": 3,
      "text": "Internet media types are registered with a canonical form. An entity-body transferred via HTTP messages MUST be represented in the appropriate canonical form prior to its transmission except for \"text\" types, as defined in the next paragraph.",
      "ja": "インターネットメディアタイプは、標準的な形式で登録されています。次の段落で定義されるようにHTTPを介して転送されるエンティティボディは、メッセージは、「テキスト」タイプ以外の送信前に適切な標準形で表現されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When in canonical form, media subtypes of the \"text\" type use CRLF as the text line break. HTTP relaxes this requirement and allows the transport of text media with plain CR or LF alone representing a line break when it is done consistently for an entire entity-body. HTTP applications MUST accept CRLF, bare CR, and bare LF as being representative of a line break in text media received via HTTP. In addition, if the text is represented in a character set that does not use octets 13 and 10 for CR and LF respectively, as is the case for some multi-byte character sets, HTTP allows the use of whatever octet sequences are defined by that character set to represent the equivalent of CR and LF for line breaks. This flexibility regarding line breaks applies only to text media in the entity-body; a bare CR or LF MUST NOT be substituted for CRLF within any of the HTTP control structures (such as header fields and multipart boundaries).",
      "ja": "テキストの改行として「テキスト」タイプの利用CRLFの場合は正規の形式で、メディアサブタイプ。 HTTPは、この要件を緩和し、単独でそれが全体エンティティボディのために一貫して行われる改行を表す普通CRまたはLFのテキストメディアの輸送を可能にします。 HTTPアプリケーションはテキストメディアがHTTPを介して受信に改行の代表的なものとしてCRLF、むき出しのCR、およびむき出しのLFを受け入れなければなりません。また、テキストは、いくつかのマルチバイト文字セットの場合のように、HTTPは、配列がそのによって定義されるどんなオクテットを使用することができ、それぞれ、CRとLFのためのオクテット13と10を使用していない文字セットで表現されている場合文字は、改行のためのCRとLFと同等のものを表すように設定します。改行に関するこの柔軟性はエンティティボディのテキストメディアに適用されます。裸のCRまたはLFは、（ヘッダ・フィールドとマルチパート境界など）HTTP制御構造のいずれかの内にCRLFを置換してはいけません。"
    },
    {
      "indent": 3,
      "text": "If an entity-body is encoded with a content-coding, the underlying data MUST be in a form defined above prior to being encoded.",
      "ja": "エンティティボディは、コンテンツの符号化で符号化される場合、基礎となるデータは、符号化される前に上で定義された形態でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"charset\" parameter is used with some media types to define the character set (section 3.4) of the data. When no explicit charset parameter is provided by the sender, media subtypes of the \"text\" type are defined to have a default charset value of \"ISO-8859-1\" when received via HTTP. Data in character sets other than \"ISO-8859-1\" or its subsets MUST be labeled with an appropriate charset value. See section 3.4.1 for compatibility problems.",
      "ja": "「文字セット」パラメータは、データの文字セット（セクション3.4）を定義するために、いくつかのメディアタイプで使用されています。明示的なcharsetパラメータが送信者によって提供されていない場合は、「テキスト」タイプのメディアサブタイプは、HTTPを介して受信されたとき、「ISO-8859-1」のデフォルトの文字セット値を持つように定義されています。キャラクターのデータは、「ISO-8859-1」以外の設定またはそのサブセットは、適切なcharset値でラベル付けされなければなりません。互換性の問題のためのセクション3.4.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.7.2 Multipart Types",
      "section_title": true,
      "ja": "3.7.2マルチパートタイプ"
    },
    {
      "indent": 3,
      "text": "MIME provides for a number of \"multipart\" types -- encapsulations of one or more entities within a single message-body. All multipart types share a common syntax, as defined in section 5.1.1 of RFC 2046",
      "ja": "単一メッセージボディ内の1つの以上のエンティティのカプセル化 -  MIMEは、「マルチパート」型の数を提供します。 RFC 2046のセクション5.1.1で定義されているすべてのマルチパートタイプは、共通の構文を共有します"
    },
    {
      "indent": 3,
      "text": "[40], and MUST include a boundary parameter as part of the media type value. The message body is itself a protocol element and MUST therefore use only CRLF to represent line breaks between body-parts. Unlike in RFC 2046, the epilogue of any multipart message MUST be empty; HTTP applications MUST NOT transmit the epilogue (even if the original multipart contains an epilogue). These restrictions exist in order to preserve the self-delimiting nature of a multipart message-body, wherein the \"end\" of the message-body is indicated by the ending multipart boundary.",
      "ja": "[40]、およびメディアタイプ値の一部として境界パラメータを含まなければなりません。メッセージ本体は、プロトコル素子自体であり、したがって、身体部分との間の改行を表すためにのみCRLFを使用しなければなりません。 RFC 2046とは異なり、任意のマルチパートメッセージのエピローグが空でなければなりません。 HTTPアプリケーションは（元のマルチパートがエピローグが含まれていても）エピローグを送信してはなりません。これらの制限は、メッセージ本体の「終了」が終了マルチパート境界によって示されており、マルチパートメッセージボディの自己画定性質を維持するために存在します。"
    },
    {
      "indent": 3,
      "text": "In general, HTTP treats a multipart message-body no differently than any other media type: strictly as payload. The one exception is the \"multipart/byteranges\" type (appendix 19.2) when it appears in a 206 (Partial Content) response, which will be interpreted by some HTTP caching mechanisms as described in sections 13.5.4 and 14.16. In all other cases, an HTTP user agent SHOULD follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type. The MIME header fields within each body-part of a multipart message-body do not have any significance to HTTP beyond that defined by their MIME semantics.",
      "ja": "一般に、HTTPは全く異なる他のメディアタイプよりもマルチパートメッセージボディを扱うない：厳密ペイロードとして。それはセクション13.5.4および14.16に記載されているように、いくつかのHTTPキャッシングメカニズムによって解釈される206（部分コンテンツ）応答に表示されたとき唯一の例外は、「マルチパート/ byteranges」タイプ（付録19.2）です。他のすべての場合において、HTTPユーザエージェントは、MIMEユーザエージェントと同一又は類似の挙動に従わなければならないだろうマルチタイプを受信します。マルチパートメッセージボディの各身体部分内のMIMEヘッダフィールドは、そのMIMEセマンティクスによって定義されたものを超えたHTTPのいずれかの意味を持っていません。"
    },
    {
      "indent": 3,
      "text": "In general, an HTTP user agent SHOULD follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type. If an application receives an unrecognized multipart subtype, the application MUST treat it as being equivalent to \"multipart/mixed\".",
      "ja": "一般に、HTTPユーザエージェントは、MIMEユーザエージェントと同一又は類似の挙動に従わなければならないだろうマルチタイプを受信します。アプリケーションが認識されないマルチパートサブタイプを受け取った場合、アプリケーションは「混合/マルチパート」と等価であるとして、それを扱わなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: The \"multipart/form-data\" type has been specifically defined for carrying form data suitable for processing via the POST request method, as described in RFC 1867 [15].",
      "ja": "注：RFC 1867年に記載されているように、「マルチパート/フォームデータ」型は、特に、POSTリクエストメソッドを介して処理に適した形式のデータを運ぶために定義されている[15]。"
    },
    {
      "indent": 0,
      "text": "3.8 Product Tokens",
      "section_title": true,
      "ja": "3.8製品のトークン"
    },
    {
      "indent": 3,
      "text": "Product tokens are used to allow communicating applications to identify themselves by software name and version. Most fields using product tokens also allow sub-products which form a significant part of the application to be listed, separated by white space. By convention, the products are listed in order of their significance for identifying the application.",
      "ja": "製品のトークンはソフトウェアの名前とバージョンによって自分自身を識別するために、アプリケーションを通信可能にするために使用されています。また、ホワイトスペースで区切られたリストするアプリケーションの重要な部分を形成する副生成物を、許可製品トークンを使用してほとんどのフィールド。慣例により、製品がアプリケーションを識別するためのその重要性の順に記載されています。"
    },
    {
      "indent": 7,
      "text": "product         = token [\"/\" product-version]\nproduct-version = token",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 7,
      "text": "User-Agent: CERN-LineMode/2.15 libwww/2.17b3\nServer: Apache/0.8.4",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Product tokens SHOULD be short and to the point. They MUST NOT be used for advertising or other non-essential information. Although any token character MAY appear in a product-version, this token SHOULD only be used for a version identifier (i.e., successive versions of the same product SHOULD only differ in the product-version portion of the product value).",
      "ja": "製品トークンは短く、ポイントとすべきです。彼らは、広告や他の非必須情報のために使用してはいけません。任意のトークンの文字が製品バージョンに現れるかもしれないが、このトークンは唯一のバージョン識別子のために使用されるべきである（すなわち、同じ製品の連続的なバージョンは、製品価値の製品バージョン部分で異なるべきです）。"
    },
    {
      "indent": 0,
      "text": "3.9 Quality Values",
      "section_title": true,
      "ja": "3.9品質値"
    },
    {
      "indent": 3,
      "text": "HTTP content negotiation (section 12) uses short \"floating point\" numbers to indicate the relative importance (\"weight\") of various negotiable parameters. A weight is normalized to a real number in the range 0 through 1, where 0 is the minimum and 1 the maximum value. If a parameter has a quality value of 0, then content with this parameter is `not acceptable' for the client. HTTP/1.1 applications MUST NOT generate more than three digits after the decimal point. User configuration of these values SHOULD also be limited in this fashion.",
      "ja": "HTTPコンテンツネゴシエーション（セクション12）は、様々な交渉パラメータの相対的重要度（「重量」）を示すために、短い「浮動小数点」番号を使用します。重みは0が最小値と最大値1である場合、1から0の範囲内の実数値に正規化されます。パラメータが0の品質値を持っている場合は、このパラメータを使用してコンテンツには、クライアントのための「`許容ではありません。 HTTP / 1.1のアプリケーションは、小数点以下3桁以上を生成してはなりません。これらの値のユーザ設定もこの方法で制限すべきです。"
    },
    {
      "indent": 7,
      "text": "qvalue         = ( \"0\" [ \".\" 0*3DIGIT ] )\n               | ( \"1\" [ \".\" 0*3(\"0\") ] )",
      "raw": true
    },
    {
      "indent": 3,
      "text": "\"Quality values\" is a misnomer, since these values merely represent relative degradation in desired quality.",
      "ja": "「品質値」は、これらの値は、単に、所望の品質の相対的な低下を表しているので、誤った名称です。"
    },
    {
      "indent": 0,
      "text": "3.10 Language Tags",
      "section_title": true,
      "ja": "3.10言語タグ"
    },
    {
      "indent": 3,
      "text": "A language tag identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded. HTTP uses language tags within the Accept-Language and Content-Language fields.",
      "ja": "言語タグが書き込まれ、またはそうでなければ他の人間への情報の通信のための人間によって運ば、発話自然言語を識別する。コンピュータ言語は明示的に除外されています。 HTTPは受け入れ言語とContent-言語フィールド内言語タグを使用しています。"
    },
    {
      "indent": 3,
      "text": "The syntax and registry of HTTP language tags is the same as that defined by RFC 1766 [1]. In summary, a language tag is composed of 1 or more parts: A primary language tag and a possibly empty series of subtags:",
      "ja": "HTTP言語タグの構文およびレジストリ[1] RFC 1766によって定義されたものと同じです。主言語タグとサブタグの空の場合シリーズ：要約すると、言語タグは1つの以上の部分から構成されています。"
    },
    {
      "indent": 8,
      "text": "language-tag  = primary-tag *( \"-\" subtag )\nprimary-tag   = 1*8ALPHA\nsubtag        = 1*8ALPHA",
      "raw": true
    },
    {
      "indent": 3,
      "text": "White space is not allowed within the tag and all tags are case-insensitive. The name space of language tags is administered by the IANA. Example tags include:",
      "ja": "ホワイトスペースは、タグ内で許可されていないと、すべてのタグは大文字と小文字を区別しません。言語タグの名前空間はIANAによって管理されます。例タグが含まれます："
    },
    {
      "indent": 7,
      "text": "en, en-US, en-cockney, i-cherokee, x-pig-latin",
      "ja": "エン、EN-US、エンコックニー、I-チェロキー、X-豚 - ラテン"
    },
    {
      "indent": 3,
      "text": "where any two-letter primary-tag is an ISO-639 language abbreviation and any two-letter initial subtag is an ISO-3166 country code. (The last three tags above are not registered tags; all but the last are examples of tags which could be registered in future.)",
      "ja": "任意の2文字の主要タグはISO-639言語短縮形と任意の2文字の最初のサブタグですISO-3166国コードです。 （上記の最後の3つのタグは、タグが登録されていない、すべてが、最後には、将来的に登録することができるタグの例です。）"
    },
    {
      "indent": 0,
      "text": "3.11 Entity Tags",
      "section_title": true,
      "ja": "3.11エンティティタグ"
    },
    {
      "indent": 3,
      "text": "Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the ETag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. The definition of how they are used and compared as cache validators is in section 13.3.3. An entity tag consists of an opaque quoted string, possibly prefixed by a weakness indicator.",
      "ja": "エンティティタグは同じ要求されたリソースからの二つ以上のエンティティを比較するために使用されています。 HTTP / 1.1のETag（セクション14.19）で、場合マッチ（セクション14.24）、（14.26部）なし - マッチした場合、及び場合レンジ（セクション14.27）ヘッダフィールドエンティティタグを使用します。彼らはキャッシュバリデータとして使用され、比較される方法の定義はセクション13.3.3です。エンティティタグは、おそらく弱インジケータで始まる不透明な引用符で囲まれた文字列で構成されています。"
    },
    {
      "indent": 6,
      "text": "entity-tag = [ weak ] opaque-tag weak = \"W/\" opaque-tag = quoted-string",
      "ja": "エンティティタグ= [弱]不透明タグ弱=「W /」不透明タグ=引用符で囲まれた文字列"
    },
    {
      "indent": 3,
      "text": "A \"strong entity tag\" MAY be shared by two entities of a resource only if they are equivalent by octet equality.",
      "ja": "「強いエンティティタグは」彼らはオクテットの平等によって同等である場合にのみ、リソースの2つのエンティティによって共有されてもよいです。"
    },
    {
      "indent": 3,
      "text": "A \"weak entity tag,\" indicated by the \"W/\" prefix, MAY be shared by two entities of a resource only if the entities are equivalent and could be substituted for each other with no significant change in semantics. A weak entity tag can only be used for weak comparison.",
      "ja": "「W /」接頭辞によって示され、「弱いエンティティタグ」は、エンティティが同等であり、意味論に有意な変化を用いて互いに置換することができた場合にのみ、リソースの2つのエンティティにより共有されてもよいです。弱いエンティティタグは、弱い比較のために使用することができます。"
    },
    {
      "indent": 3,
      "text": "An entity tag MUST be unique across all versions of all entities associated with a particular resource. A given entity tag value MAY be used for entities obtained by requests on different URIs. The use of the same entity tag value in conjunction with entities obtained by requests on different URIs does not imply the equivalence of those entities.",
      "ja": "エンティティタグは、特定のリソースに関連付けられているすべてのエンティティのすべてのバージョンで一意である必要があります。与えられたエンティティタグの値が異なるのURI上の要求によって得られるエンティティに対して使用されるかもしれません。別のURIでの要求によって得られるエンティティと一緒に同じエンティティタグ値の使用は、それらのエンティティの等価性を意味するものではありません。"
    },
    {
      "indent": 0,
      "text": "3.12 Range Units",
      "section_title": true,
      "ja": "3.12レンジユニット"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 allows a client to request that only part (a range of) the response entity be included within the response. HTTP/1.1 uses range units in the Range (section 14.35) and Content-Range (section 14.16) header fields. An entity can be broken down into subranges according to various structural units.",
      "ja": "HTTP / 1.1クライアントは一部のみ（の範囲）応答エンティティが応答内に含まれることを要求することを可能にします。 HTTP / 1.1の用途の範囲内（セクション14.35）及びコンテンツレンジ（セクション14.16）ヘッダーフィールド単位の範囲です。エンティティは、種々の構成単位に係る部分的範囲に分解することができます。"
    },
    {
      "indent": 6,
      "text": "range-unit = bytes-unit | other-range-unit bytes-unit = \"bytes\" other-range-unit = token",
      "ja": "レンジ・ユニット=バイト単位|他のレンジユニットのバイト単位は= =トークン他のレンジユニットを「バイト」"
    },
    {
      "indent": 3,
      "text": "The only range unit defined by HTTP/1.1 is \"bytes\". HTTP/1.1 implementations MAY ignore ranges specified using other units.",
      "ja": "HTTP / 1.1によって定義された範囲のみの単位は「バイト」です。 HTTP / 1.1の実装は、他の単位を使用して、指定された範囲を無視してもよいです。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 has been designed to allow implementations of applications that do not depend on knowledge of ranges.",
      "ja": "HTTP / 1.1は、範囲の知識に依存しないアプリケーションの実装を許可するように設計されています。"
    },
    {
      "indent": 0,
      "text": "4 HTTP Message",
      "ja": "4 HTTPメッセージ"
    },
    {
      "indent": 0,
      "text": "4.1 Message Types",
      "section_title": true,
      "ja": "4.1メッセージタイプ"
    },
    {
      "indent": 3,
      "text": "HTTP messages consist of requests from client to server and responses from server to client.",
      "ja": "HTTPメッセージは、サーバーからクライアントへのクライアントからサーバーへの要求と応答で構成されています。"
    },
    {
      "indent": 7,
      "text": "HTTP-message = Request | Response ; HTTP/1.1 messages",
      "ja": "HTTPメッセージ=リクエスト|応答; HTTP / 1.1のメッセージ"
    },
    {
      "indent": 3,
      "text": "Request (section 5) and Response (section 6) messages use the generic message format of RFC 822 [9] for transferring entities (the payload of the message). Both types of message consist of a start-line, zero or more header fields (also known as \"headers\"), an empty line (i.e., a line with nothing preceding the CRLF) indicating the end of the header fields, and possibly a message-body.",
      "ja": "要求（セクション5）と応答（セクション6）メッセージは、エンティティ（メッセージのペイロード）を転送するための[9] RFC 822の一般的なメッセージフォーマットを使用します。メッセージの両方のタイプは、スタートラインの（また、「ヘッダー」としても知られる）は、ゼロ以上のヘッダフィールド、ヘッダフィールドの終わりを示す空行（すなわち、CRLFの前に何もない線）からなり、おそらくはメッセージ本文。"
    },
    {
      "indent": 8,
      "text": "generic-message = start-line\n                  *(message-header CRLF)\n                  CRLF\n                  [ message-body ]\nstart-line      = Request-Line | Status-Line",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the interest of robustness, servers SHOULD ignore any empty line(s) received where a Request-Line is expected. In other words, if the server is reading the protocol stream at the beginning of a message and receives a CRLF first, it should ignore the CRLF.",
      "ja": "堅牢性の関心では、サーバは要求ラインが期待されている（s）が受信したすべての空行を無視します。サーバは、メッセージの先頭にプロトコルストリームを読み取り、最初のCRLFを受信した場合、他の言葉では、それはCRLFを無視すべきです。"
    },
    {
      "indent": 3,
      "text": "Certain buggy HTTP/1.0 client implementations generate extra CRLF's after a POST request. To restate what is explicitly forbidden by the BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an extra CRLF.",
      "ja": "特定のバギーHTTP / 1.0クライアントの実装は、POSTリクエストの後に余分なCRLF年代を生成します。明示的BNFによって禁止されているものを言い換えるするには、HTTP / 1.1クライアントは、序文や余分なCRLFとの要求に従ってはなりません。"
    },
    {
      "indent": 0,
      "text": "4.2 Message Headers",
      "section_title": true,
      "ja": "4.2メッセージヘッダ"
    },
    {
      "indent": 3,
      "text": "HTTP header fields, which include general-header (section 4.5), request-header (section 5.3), response-header (section 6.2), and entity-header (section 7.1) fields, follow the same generic format as that given in Section 3.1 of RFC 822 [9]. Each header field consists of a name followed by a colon (\":\") and the field value. Field names are case-insensitive. The field value MAY be preceded by any amount of LWS, though a single SP is preferred. Header fields can be extended over multiple lines by preceding each extra line with at least one SP or HT. Applications ought to follow \"common form\", where one is known or indicated, when generating HTTP constructs, since there might exist some implementations that fail to accept anything beyond the common forms.",
      "ja": "一般的なヘッダを含むHTTPヘッダフィールド、（セクション4.5）、リクエストヘッダ（セクション5.3）、応答ヘッダ（セクション6.2）、およびエンティティヘッダ（セクション7.1）フィールドは、セクションで与えられたものと同じ一般的なフォーマットに従いますRFC 822の3.1 [9]。フィールド値：各ヘッダフィールドは、コロン（「」）が続く名前で構成されています。フィールド名は大文字と小文字を区別しません。単一のSPが好ましいもののフィールド値は、LWSの任意の量によって先行されるかもしれません。ヘッダフィールドは、少なくとも1つのSPまたはHT各追加のラインを先行することによって、複数の行にわたって拡張することができます。アプリケーションは、1が知られているか、または一般的な形態を超えた何かを受け入れるように失敗するいくつかの実装が存在する可能性があるため、HTTP構造物を生成するとき、表示され、「一般的な形式」を、従うべきです。"
    },
    {
      "indent": 7,
      "text": "message-header = field-name \":\" [ field-value ]\nfield-name     = token\nfield-value    = *( field-content | LWS )\nfield-content  = <the OCTETs making up the field-value\n                 and consisting of either *TEXT or combinations\n                 of token, separators, and quoted-string>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The field-content does not include any leading or trailing LWS: linear white space occurring before the first non-whitespace character of the field-value or after the last non-whitespace character of the field-value. Such leading or trailing LWS MAY be removed without changing the semantics of the field value. Any LWS that occurs between field-content MAY be replaced with a single SP before interpreting the field value or forwarding the message downstream.",
      "ja": "フィールド・コンテンツが先頭または末尾LWSが含まれていません：リニアホワイトスペースは、フィールド値の最初の非空白文字の前またはフィールド値の最後の非空白文字の後に発生します。そのような先頭または末尾LWSは、フィールド値のセマンティクスを変更することなく除去することができます。フィールド・コンテンツとの間に生じるいかなるLWSは、フィールド値を解釈または下流メッセージを転送する前に、単一のSPに置き換えてもよいです。"
    },
    {
      "indent": 3,
      "text": "The order in which header fields with differing field names are received is not significant. However, it is \"good practice\" to send general-header fields first, followed by request-header or response-header fields, and ending with the entity-header fields.",
      "ja": "異なるフィールド名を持つヘッダフィールドが受信される順序は重要ではありません。しかし、リクエストヘッダやレスポンスヘッダフィールドに続く最初の一般的なヘッダフィールドを、送信するために「お勧め」であり、エンティティヘッダフィールドで終わります。"
    },
    {
      "indent": 3,
      "text": "Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. It MUST be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.",
      "ja": "同じフィールド名を持つ複数のメッセージヘッダフィールドがあれば、メッセージ内に存在してもよく、そのヘッダフィールドの全体のフィールド値がカンマで区切られたリスト[すなわち、＃（値）]として定義されている場合にのみ。カンマで区切られ、最初に後続の各フィールド値を追加することによって、メッセージのセマンティクスを変更することなく、「フィールド値のフィールド名」ペア1つに複数のヘッダフィールドを組み合わせることが可能でなければなりません。同じフィールド名を持つヘッダフィールドが受信される順序は、結合フィールド値の解釈することが重要であり、メッセージが転送されるとき、したがって、プロキシは、これらのフィールドの値の順序を変更しないでください。"
    },
    {
      "indent": 0,
      "text": "4.3 Message Body",
      "section_title": true,
      "ja": "4.3メッセージ本文"
    },
    {
      "indent": 3,
      "text": "The message-body (if any) of an HTTP message is used to carry the entity-body associated with the request or response. The message-body differs from the entity-body only when a transfer-coding has been applied, as indicated by the Transfer-Encoding header field (section 14.41).",
      "ja": "HTTPメッセージのメッセージボディには、（もしあれば）要求または応答に関連付けられたエンティティボディを搬送するために使用されます。メッセージ・ボディは、転送符号化ヘッダフィールド（14.41部）によって示されるように転送コーディングが適用された場合にのみ、エンティティボディと異なります。"
    },
    {
      "indent": 7,
      "text": "message-body = entity-body\n             | <entity-body encoded as per Transfer-Encoding>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Transfer-Encoding MUST be used to indicate any transfer-codings applied by an application to ensure safe and proper transfer of the message. Transfer-Encoding is a property of the message, not of the entity, and thus MAY be added or removed by any application along the request/response chain. (However, section 3.6 places restrictions on when certain transfer-codings may be used.)",
      "ja": "転送符号化は、メッセージの安全かつ適切な転送を保証するために、アプリケーションによって適用される任意の転送コーディングを示すために使用されなければなりません。転送符号化は、メッセージのではなく、エンティティのプロパティであるため、要求/応答チェーンに沿った任意のアプリケーションによって追加又は除去することができます。 （ただし、3.6節特定の転送コーディングを使用することができるときに場所の制限）。"
    },
    {
      "indent": 3,
      "text": "The rules for when a message-body is allowed in a message differ for requests and responses.",
      "ja": "メッセージボディがメッセージに許可されているときの規則は、要求と応答で異なります。"
    },
    {
      "indent": 3,
      "text": "The presence of a message-body in a request is signaled by the inclusion of a Content-Length or Transfer-Encoding header field in the request's message-headers. A message-body MUST NOT be included in a request if the specification of the request method (section 5.1.1) does not allow sending an entity-body in requests. A server SHOULD read and forward a message-body on any request; if the request method does not include defined semantics for an entity-body, then the message-body SHOULD be ignored when handling the request.",
      "ja": "要求内のメッセージボディの存在はリクエストのメッセージ・ヘッダー内のContent-Lengthまたは転送符号化ヘッダフィールドを含めることによって通知されます。リクエストメソッド（セクション5.1.1）の仕様が要求にエンティティボディを送信する許可しない場合、メッセージボディは、要求に含まれてはいけません。サーバーはすべてのリクエストにメッセージボディを読み、転送すべきです。リクエストメソッドがエンティティボディのために定義された意味が含まれていない場合は、要求を処理する際に、そのメッセージボディは無視されるべきです。"
    },
    {
      "indent": 3,
      "text": "For response messages, whether or not a message-body is included with a message is dependent on both the request method and the response status code (section 6.1.1). All responses to the HEAD request method MUST NOT include a message-body, even though the presence of entity-header fields might lead one to believe they do. All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a message-body. All other responses do include a message-body, although it MAY be of zero length.",
      "ja": "応答メッセージは、メッセージボディがメッセージに含まれているか否かをリクエストメソッドとレスポンスステータスコード（セクション6.1.1）の両方に依存します。 HEADリクエストメソッドへのすべての応答は、エンティティヘッダフィールドの存在は、彼らが信じるように1を招く可能性があるにもかかわらず、メッセージボディを含んではいけません。全ての1xx（情報）、204（コンテンツなし）、および304（変更されない）の応答は、メッセージボディを含めることはできません。他のすべての応答は、それがゼロの長さであり得るが、メッセージボディが含まれません。"
    },
    {
      "indent": 0,
      "text": "4.4 Message Length",
      "section_title": true,
      "ja": "4.4メッセージの長さ"
    },
    {
      "indent": 3,
      "text": "The transfer-length of a message is the length of the message-body as it appears in the message; that is, after any transfer-codings have been applied. When a message-body is included with a message, the transfer-length of that body is determined by one of the following (in order of precedence):",
      "ja": "メッセージの転送長さは、それがメッセージに表示されるメッセージボディの長さです。すべての転送コーディングが適用された後、それは、あります。メッセージ本体がメッセージに含まれている場合に、その身体の転送長さは、（優先順位で）次のいずれかによって決定されます。"
    },
    {
      "indent": 3,
      "text": "1.Any response message which \"MUST NOT\" include a message-body (such as the 1xx, 204, and 304 responses and any response to a HEAD request) is always terminated by the first empty line after the header fields, regardless of the entity-header fields present in the message.",
      "ja": "（例えば1XX、204、及び304個の応答とHEAD要求に対する応答として）メッセージ本体を含む「MUST NOT」1.Any応答メッセージは常にかかわらず、ヘッダフィールドの後の最初の空行で終了しますメッセージ中に存在するエンティティヘッダフィールド。"
    },
    {
      "indent": 3,
      "text": "2.If a Transfer-Encoding header field (section 14.41) is present and has any value other than \"identity\", then the transfer-length is defined by use of the \"chunked\" transfer-coding (section 3.6), unless the message is terminated by closing the connection.",
      "ja": "転送符号化ヘッダフィールド（セクション14.41）2.Ifは存在し、「同一性」以外の値を有し、その後、転送長は、メッセージがない限り、転送符号化（セクション3.6）を「チャンク」を用いて定義されます接続を閉じることで終了されます。"
    },
    {
      "indent": 3,
      "text": "3.If a Content-Length header field (section 14.13) is present, its decimal value in OCTETs represents both the entity-length and the transfer-length. The Content-Length header field MUST NOT be sent if these two lengths are different (i.e., if a Transfer-Encoding header field is present). If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.",
      "ja": "Content-Lengthヘッダフィールド（セクション14.13）3.Ifはオクテットで10進数は、エンティティ長と転送長さの両方を表し、存在します。これら2つの長さが異なる場合、Content-Lengthヘッダフィールドは、送信されてはいけません（すなわち、転送符号化ヘッダ・フィールドが存在する場合）。メッセージが転送エンコーディングヘッダフィールドおよびContent-Lengthヘッダフィールドの両方で受信される場合、後者は無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "4.If the message uses the media type \"multipart/byteranges\", and the ransfer-length is not otherwise specified, then this self-elimiting media type defines the transfer-length. This media type UST NOT be used unless the sender knows that the recipient can arse it; the presence in a request of a Range header with ultiple byte-range specifiers from a 1.1 client implies that the lient can parse multipart/byteranges responses.",
      "ja": "メッセージ4.Ifメディアタイプ「マルチパート/ byteranges」を使用し、ransfer長が他に指定されていない場合、この自己elimitingメディアタイプは、転送長を規定します。送信者は受信者がそれをお尻ができることを知っていなければ、このメディアタイプUSTを使用するわけではありません。 1.1クライアントからultipleバイト範囲指定子とのRangeヘッダの要求における存在はlientマルチパート/ byteranges応答を解析することができることを意味します。"
    },
    {
      "indent": 7,
      "text": "A range header might be forwarded by a 1.0 proxy that does not\nunderstand multipart/byteranges; in this case the server MUST\ndelimit the message using methods defined in items 1,3 or 5 of\nthis section.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5.By the server closing the connection. (Closing the connection cannot be used to indicate the end of a request body, since that would leave no possibility for the server to send back a response.)",
      "ja": "接続を閉じるサーバーを5.By。 （つまり、サーバがレスポンスを返送するための可能性を残していないことになるので、接続を閉じると、リクエストボディの終了を示すために使用できません。）"
    },
    {
      "indent": 3,
      "text": "For compatibility with HTTP/1.0 applications, HTTP/1.1 requests containing a message-body MUST include a valid Content-Length header field unless the server is known to be HTTP/1.1 compliant. If a request contains a message-body and a Content-Length is not given, the server SHOULD respond with 400 (bad request) if it cannot determine the length of the message, or with 411 (length required) if it wishes to insist on receiving a valid Content-Length.",
      "ja": "サーバは、HTTP / 1.1準拠であることが知られていない限りHTTP / 1.0アプリケーションとの互換性のため、メッセージボディを含むHTTP / 1.1リクエストが有効なContent-Lengthヘッダフィールドを含まなければなりません。要求が含まれている場合は、メッセージ本体およびコンテンツ長が指定されていないそれが主張することを望む場合、サーバは、メッセージの長さを決定できない場合、400（悪い要求）で応答、または411（長さが必要）とすべきです有効なContent-Lengthを受けます。"
    },
    {
      "indent": 3,
      "text": "All HTTP/1.1 applications that receive entities MUST accept the \"chunked\" transfer-coding (section 3.6), thus allowing this mechanism to be used for messages when the message length cannot be determined in advance.",
      "ja": "エンティティは受け入れなければならない受け取るすべてのHTTP / 1.1アプリケーションは、このようにメッセージの長さを事前に決定することができない場合、この機構は、メッセージのために使用することができるように、転送符号化（セクション3.6）を「チャンク」。"
    },
    {
      "indent": 3,
      "text": "Messages MUST NOT include both a Content-Length header field and a non-identity transfer-coding. If the message does include a non-identity transfer-coding, the Content-Length MUST be ignored.",
      "ja": "メッセージは、Content-Lengthヘッダフィールドと非同一の転送コーディングの両方を含んではいけません。メッセージは非同一の転送コーディングを含まれている場合、コンテンツの長さを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a Content-Length is given in a message where a message-body is allowed, its field value MUST exactly match the number of OCTETs in the message-body. HTTP/1.1 user agents MUST notify the user when an invalid length is received and detected.",
      "ja": "コンテンツの長さがメッセージボディが許可されているメッセージに与えられた場合、そのフィールドの値が正確にメッセージボディのオクテットの数と一致しなければなりません。無効な長さを受信し、検出されたときにHTTP / 1.1ユーザエージェントはユーザに通知しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.5 General Header Fields",
      "section_title": true,
      "ja": "4.5一般ヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "There are a few header fields which have general applicability for both request and response messages, but which do not apply to the entity being transferred. These header fields apply only to the message being transmitted.",
      "ja": "エンティティが転送されているには適用されません両方の要求メッセージと応答メッセージのための一般的な適用性を持っているが、いくつかのヘッダフィールドがあります。これらのヘッダーフィールドは、送信されるメッセージに適用されます。"
    },
    {
      "indent": 7,
      "text": "general-header = Cache-Control            ; Section 14.9\n               | Connection               ; Section 14.10\n               | Date                     ; Section 14.18\n               | Pragma                   ; Section 14.32\n               | Trailer                  ; Section 14.40\n               | Transfer-Encoding        ; Section 14.41\n               | Upgrade                  ; Section 14.42\n               | Via                      ; Section 14.45\n               | Warning                  ; Section 14.46",
      "raw": true
    },
    {
      "indent": 3,
      "text": "General-header field names can be extended reliably only in combination with a change in the protocol version. However, new or experimental header fields may be given the semantics of general header fields if all parties in the communication recognize them to be general-header fields. Unrecognized header fields are treated as entity-header fields.",
      "ja": "一般ヘッダフィールド名は、プロトコルバージョンにおける変化と組み合わせて、確実に拡張することができます。通信のすべての当事者が一般ヘッダフィールドであることをそれらを認識場合は、新しいまたは実験ヘッダフィールドは、一般的なヘッダフィールドの意味論を与えてもよいです。認識されていないヘッダフィールドは、エンティティヘッダフィールドとして扱われます。"
    },
    {
      "indent": 0,
      "text": "5 Request",
      "ja": "5リクエスト"
    },
    {
      "indent": 3,
      "text": "A request message from a client to a server includes, within the first line of that message, the method to be applied to the resource, the identifier of the resource, and the protocol version in use.",
      "ja": "クライアントからサーバへの要求メッセージは、そのメッセージの最初のライン内で、メソッドは、リソース、リソースの識別子、および使用中のプロトコル・バージョンに適用することを含みます。"
    },
    {
      "indent": 8,
      "text": "Request       = Request-Line              ; Section 5.1\n                *(( general-header        ; Section 4.5\n                 | request-header         ; Section 5.3\n                 | entity-header ) CRLF)  ; Section 7.1\n                CRLF\n                [ message-body ]          ; Section 4.3",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.1 Request-Line",
      "section_title": true,
      "ja": "5.1リクエストライン"
    },
    {
      "indent": 3,
      "text": "The Request-Line begins with a method token, followed by the Request-URI and the protocol version, and ending with CRLF. The elements are separated by SP characters. No CR or LF is allowed except in the final CRLF sequence.",
      "ja": "リクエストラインは、Request-URIとプロトコルバージョンが続き、CRLFで終わる、メソッドトークンで始まります。要素はSP文字で区切られます。 CRまたはLF NOが最終のCRLFシーケンス以外で許可されていません。"
    },
    {
      "indent": 8,
      "text": "Request-Line = Method SP Request-URI SP HTTP-Version CRLF",
      "ja": "リクエストライン=メソッドのSPのRequest-URI SP HTTP-バージョンCRLF"
    },
    {
      "indent": 0,
      "text": "5.1.1 Method",
      "section_title": true,
      "ja": "5.1.1メソッド"
    },
    {
      "indent": 3,
      "text": "The Method token indicates the method to be performed on the resource identified by the Request-URI. The method is case-sensitive.",
      "ja": "メソッドトークンは、Request-URIによって識別されたリソース上で実行される方法を示しています。この方法は、大文字と小文字が区別されます。"
    },
    {
      "indent": 7,
      "text": "Method         = \"OPTIONS\"                ; Section 9.2\n               | \"GET\"                    ; Section 9.3\n               | \"HEAD\"                   ; Section 9.4\n               | \"POST\"                   ; Section 9.5\n               | \"PUT\"                    ; Section 9.6\n               | \"DELETE\"                 ; Section 9.7\n               | \"TRACE\"                  ; Section 9.8\n               | \"CONNECT\"                ; Section 9.9\n               | extension-method\nextension-method = token",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The list of methods allowed by a resource can be specified in an Allow header field (section 14.7). The return code of the response always notifies the client whether a method is currently allowed on a resource, since the set of allowed methods can change dynamically. An origin server SHOULD return the status code 405 (Method Not Allowed) if the method is known by the origin server but not allowed for the requested resource, and 501 (Not Implemented) if the method is unrecognized or not implemented by the origin server. The methods GET and HEAD MUST be supported by all general-purpose servers. All other methods are OPTIONAL; however, if the above methods are implemented, they MUST be implemented with the same semantics as those specified in section 9.",
      "ja": "リソースが許可されるメソッドのリストは、許可ヘッダーフィールド（セクション14.7）で指定することができます。レスポンスのリターンコードは常に許可メソッドのセットを動的に変更することができますので、この方法は、現在、リソース上で許可されているかどうかをクライアントに通知します。この方法は、未認識またはオリジンサーバによって実装されていない場合メソッドがオリジンサーバによって知られているが、要求されたリソースのために許可されていない、及び501は、（実装されていない）されている場合、オリジンサーバは、（方法不可）ステータスコード405を返すべきです。メソッドはGETとHEADは、すべての汎用サーバでサポートしなければなりません。他のすべてのメソッドはオプションです。上記の方法が実装されている場合は、それらは、セクション9で指定されたものと同じ意味で実現されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.2 Request-URI",
      "section_title": true,
      "ja": "5.1.2要求URI"
    },
    {
      "indent": 3,
      "text": "The Request-URI is a Uniform Resource Identifier (section 3.2) and identifies the resource upon which to apply the request.",
      "ja": "リクエストURIは、ユニフォームリソース識別子（セクション3.2）であり、要求を適用する際にリソースを識別する。"
    },
    {
      "indent": 7,
      "text": "Request-URI = \"*\" | absoluteURI | abs_path | authority",
      "ja": "Request-URI = \"*\" | absoluteURIで|腹筋_経路|権限"
    },
    {
      "indent": 3,
      "text": "The four options for Request-URI are dependent on the nature of the request. The asterisk \"*\" means that the request does not apply to a particular resource, but to the server itself, and is only allowed when the method used does not necessarily apply to a resource. One example would be",
      "ja": "要求URIのための4つのオプションはリクエストの性質に依存しています。アスタリスク「*」は、要求が特定のリソースに適用されますが、サーバー自体に、および使用方法は、必ずしもリソースには適用されない場合にのみ許可されていないことを意味します。一つの例は次のようになります"
    },
    {
      "indent": 7,
      "text": "OPTIONS * HTTP/1.1",
      "ja": "OPTIONS * HTTP / 1.1"
    },
    {
      "indent": 3,
      "text": "The absoluteURI form is REQUIRED when the request is being made to a proxy. The proxy is requested to forward the request or service it from a valid cache, and return the response. Note that the proxy MAY forward the request on to another proxy or directly to the server specified by the absoluteURI. In order to avoid request loops, a proxy MUST be able to recognize all of its server names, including any aliases, local variations, and the numeric IP address. An example Request-Line would be:",
      "ja": "要求がプロキシになされているときabsoluteURIでフォームが必要とされます。プロキシが要求を転送するか、有効なキャッシュからそれにサービスを提供し、応答を返すように要求されています。プロキシが別のプロキシまたは直接absoluteURIでで指定されたサーバーに要求を転送することができることに注意してください。リクエストのループを避けるために、プロキシは任意のエイリアス、ローカルバリエーション、数値IPアドレスなど、そのサーバー名のすべてを認識できなければなりません。例えば、リクエストラインは次のようになります。"
    },
    {
      "indent": 7,
      "text": "GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1",
      "ja": "GET http://www.w3.org/pub/WWW/TheProject.html HTTP / 1.1"
    },
    {
      "indent": 3,
      "text": "To allow for transition to absoluteURIs in all requests in future versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI form in requests, even though HTTP/1.1 clients will only generate them in requests to proxies.",
      "ja": "HTTPの将来のバージョンですべての要求でabsoluteURIsへの移行を可能にするため、すべてのHTTP / 1.1サーバは、HTTP / 1.1クライアントにのみプロキシへの要求にそれらを生成しますにもかかわらず、要求でabsoluteURIでフォームを受け入れなければなりません。"
    },
    {
      "indent": 3,
      "text": "The authority form is only used by the CONNECT method (section 9.9).",
      "ja": "権限フォームは、CONNECTメソッド（セクション9.9）でのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "The most common form of Request-URI is that used to identify a resource on an origin server or gateway. In this case the absolute path of the URI MUST be transmitted (see section 3.2.1, abs_path) as the Request-URI, and the network location of the URI (authority) MUST be transmitted in a Host header field. For example, a client wishing to retrieve the resource above directly from the origin server would create a TCP connection to port 80 of the host \"www.w3.org\" and send the lines:",
      "ja": "リクエストURIの最も一般的な形態は、オリジンサーバやゲートウェイ上のリソースを識別するために使用されるということです。この場合、URIの絶対パスは、Request-URIとして（セクション3.2.1、腹筋_経路を参照）を送信しなければならない、およびURI（権限）のネットワーク位置は、Hostヘッダフィールドで送信されなければなりません。例えば、オリジンサーバから直接上記のリソースを取得したいクライアントはホスト「www.w3.org」のポート80へのTCP接続を作成し、行を送信します："
    },
    {
      "indent": 7,
      "text": "GET /pub/WWW/TheProject.html HTTP/1.1\nHost: www.w3.org",
      "raw": true
    },
    {
      "indent": 3,
      "text": "followed by the remainder of the Request. Note that the absolute path cannot be empty; if none is present in the original URI, it MUST be given as \"/\" (the server root).",
      "ja": "リクエストの残りの部分が続きます。絶対パスが空でないことに注意してください。いずれも、元のURIに存在しない場合、それは「/」（ルートサーバ）として与えられなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Request-URI is transmitted in the format specified in section 3.2.1. If the Request-URI is encoded using the \"% HEX HEX\" encoding [42], the origin server MUST decode the Request-URI in order to properly interpret the request. Servers SHOULD respond to invalid Request-URIs with an appropriate status code.",
      "ja": "リクエストURIはセクション3.2.1で指定された形式で送信されます。 Request-URIは「％HEX HEX」エンコーディング[42]を用いて符号化される場合、オリジンサーバは、リクエストを適切に解釈するために、リクエストURIをデコードしなければなりません。サーバは、適切なステータスコードで無効な要求-URIに応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "A transparent proxy MUST NOT rewrite the \"abs_path\" part of the received Request-URI when forwarding it to the next inbound server, except as noted above to replace a null abs_path with \"/\".",
      "ja": "「/」でヌル腹筋_経路を交換するために、上述したよう除き、次のインバウンドサーバに転送する際に透過型プロキシは、受信したリクエスト-URIの「腹筋_経路」の部分を書き換えてはなりません。"
    },
    {
      "indent": 6,
      "text": "Note: The \"no rewrite\" rule prevents the proxy from changing the meaning of the request when the origin server is improperly using a non-reserved URI character for a reserved purpose. Implementors should be aware that some pre-HTTP/1.1 proxies have been known to rewrite the Request-URI.",
      "ja": "注：「いいえリライト」ルールはオリジンサーバが不正に予約された目的のために予約されていないURIの文字を使用している場合、要求の意味を変更プロキシを防ぐことができます。実装者は、いくつかの事前HTTP / 1.1プロキシが要求URIを書き換えることが知られていることに注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2 The Resource Identified by a Request",
      "section_title": true,
      "ja": "5.2リクエストで識別されるリソース"
    },
    {
      "indent": 3,
      "text": "The exact resource identified by an Internet request is determined by examining both the Request-URI and the Host header field.",
      "ja": "インターネット要求によって識別正確な資源は、Request-URIとHostヘッダフィールドの両方を調べることによって決定されます。"
    },
    {
      "indent": 3,
      "text": "An origin server that does not allow resources to differ by the requested host MAY ignore the Host header field value when determining the resource identified by an HTTP/1.1 request. (But see section 19.6.1.1 for other requirements on Host support in HTTP/1.1.)",
      "ja": "HTTP / 1.1リクエストによって識別されたリソースを決定する際のリソースが要求されたホストによって異なることはできませんオリジンサーバはHostヘッダフィールドの値を無視するかもしれません。 （しかし、HTTP / 1.1のホストサポートの他の要件については、セクション19.6.1.1を参照してください。）"
    },
    {
      "indent": 3,
      "text": "An origin server that does differentiate resources based on the host requested (sometimes referred to as virtual hosts or vanity host names) MUST use the following rules for determining the requested resource on an HTTP/1.1 request:",
      "ja": "要求されたホストに基づいてリソースを区別し、オリジンサーバは、（時々、仮想ホストまたはバニティホスト名と呼ぶ）HTTP / 1.1リクエストで要求されたリソースを決定するための以下の規則を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. If Request-URI is an absoluteURI, the host is part of the Request-URI. Any Host header field value in the request MUST be ignored.",
      "ja": "1のRequest-URIがabsoluteURIである場合、ホストは、Request-URIの一部です。要求内の任意のホストヘッダーフィールドの値を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If the Request-URI is not an absoluteURI, and the request includes a Host header field, the host is determined by the Host header field value.",
      "ja": "2.リクエストURIがabsoluteURIでなく、リクエストがHostヘッダフィールドが含まれている場合、ホストは、ホストヘッダフィールド値によって決定されます。"
    },
    {
      "indent": 3,
      "text": "3. If the host as determined by rule 1 or 2 is not a valid host on the server, the response MUST be a 400 (Bad Request) error message.",
      "ja": "3.ルール1又は2によって決定されるように、ホストは、サーバ上で有効なホストでない場合、応答は400（悪いRequest）エラーメッセージでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Recipients of an HTTP/1.0 request that lacks a Host header field MAY attempt to use heuristics (e.g., examination of the URI path for something unique to a particular host) in order to determine what exact resource is being requested.",
      "ja": "ヒューリスティックを使用しようとする可能性のあるホストヘッダフィールドを欠いているHTTP / 1.0リクエストの受信者（例えば、特定のホストに固有のもののためのURIパスの検査）要求されている正確なものリソースを決定するためです。"
    },
    {
      "indent": 0,
      "text": "5.3 Request Header Fields",
      "section_title": true,
      "ja": "5.3リクエストヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "The request-header fields allow the client to pass additional information about the request, and about the client itself, to the server. These fields act as request modifiers, with semantics equivalent to the parameters on a programming language method invocation.",
      "ja": "リクエスト・ヘッダー・フィールドは、クライアントが要求に関する追加情報を渡すことができ、且つサーバへのクライアント自体、約。これらのフィールドは、プログラミング言語のメソッド呼び出しのパラメータと同等の意味を持つ、リクエスト修飾子として動作します。"
    },
    {
      "indent": 7,
      "text": "request-header = Accept                   ; Section 14.1\n               | Accept-Charset           ; Section 14.2\n               | Accept-Encoding          ; Section 14.3\n               | Accept-Language          ; Section 14.4\n               | Authorization            ; Section 14.8\n               | Expect                   ; Section 14.20\n               | From                     ; Section 14.22\n               | Host                     ; Section 14.23\n               | If-Match                 ; Section 14.24",
      "raw": true
    },
    {
      "indent": 22,
      "text": "| If-Modified-Since        ; Section 14.25\n| If-None-Match            ; Section 14.26\n| If-Range                 ; Section 14.27\n| If-Unmodified-Since      ; Section 14.28\n| Max-Forwards             ; Section 14.31\n| Proxy-Authorization      ; Section 14.34\n| Range                    ; Section 14.35\n| Referer                  ; Section 14.36\n| TE                       ; Section 14.39\n| User-Agent               ; Section 14.43",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Request-header field names can be extended reliably only in combination with a change in the protocol version. However, new or experimental header fields MAY be given the semantics of request-header fields if all parties in the communication recognize them to be request-header fields. Unrecognized header fields are treated as entity-header fields.",
      "ja": "リクエストヘッダフィールド名はプロトコルバージョンにおける変化との組み合わせでのみ確実に拡張することができます。通信のすべての当事者がリクエストヘッダフィールドであることをそれらを認識場合は、新しいまたは実験ヘッダフィールドは、リクエストヘッダフィールドの意味論を与えてもよいです。認識されていないヘッダフィールドは、エンティティヘッダフィールドとして扱われます。"
    },
    {
      "indent": 0,
      "text": "6 Response",
      "ja": "6レスポンス"
    },
    {
      "indent": 3,
      "text": "After receiving and interpreting a request message, a server responds with an HTTP response message.",
      "ja": "要求メッセージを受信し、解釈した後、サーバはHTTP応答メッセージで応答します。"
    },
    {
      "indent": 7,
      "text": "Response      = Status-Line               ; Section 6.1\n                *(( general-header        ; Section 4.5\n                 | response-header        ; Section 6.2\n                 | entity-header ) CRLF)  ; Section 7.1\n                CRLF\n                [ message-body ]          ; Section 7.2",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.1 Status-Line",
      "section_title": true,
      "ja": "6.1ステータスライン"
    },
    {
      "indent": 3,
      "text": "The first line of a Response message is the Status-Line, consisting of the protocol version followed by a numeric status code and its associated textual phrase, with each element separated by SP characters. No CR or LF is allowed except in the final CRLF sequence.",
      "ja": "応答メッセージの最初の行は、数値ステータスコードとSPの文字で区切られた各要素とその関連テキストフレーズ、続くプロトコルバージョンからなる、ステータスラインです。 CRまたはLF NOが最終のCRLFシーケンス以外で許可されていません。"
    },
    {
      "indent": 7,
      "text": "Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF",
      "ja": "ステータスライン= HTTP-バージョンSPステータスコードSP理由-フレーズCRLF"
    },
    {
      "indent": 0,
      "text": "6.1.1 Status Code and Reason Phrase",
      "section_title": true,
      "ja": "6.1.1ステータスコードおよび理由句"
    },
    {
      "indent": 3,
      "text": "The Status-Code element is a 3-digit integer result code of the attempt to understand and satisfy the request. These codes are fully defined in section 10. The Reason-Phrase is intended to give a short textual description of the Status-Code. The Status-Code is intended for use by automata and the Reason-Phrase is intended for the human user. The client is not required to examine or display the Reason-Phrase.",
      "ja": "ステータスコードエレメントは、理解し、要求を満足させる試みの3桁の整数の結果コードです。これらのコードが完全部10で定義されている理由、フレーズステータスコードの短いテキスト記述を与えることを意図しています。ステータスコードは、オートマトンによる使用を目的としており、理由-フレーズは人間のユーザを対象としています。クライアントが理由-フレーズを調べたり、表示するために必要とされていません。"
    },
    {
      "indent": 3,
      "text": "The first digit of the Status-Code defines the class of response. The last two digits do not have any categorization role. There are 5 values for the first digit:",
      "ja": "ステータスコードの最初の数字は応答のクラスを定義します。最後の2桁は任意の分類の役割を持っていません。最初の数字のための5つの値があります。"
    },
    {
      "indent": 6,
      "text": "- 1xx: Informational - Request received, continuing process",
      "ja": " - の1xx：情報 - リクエスト受け、継続的なプロセス"
    },
    {
      "indent": 6,
      "text": "- 2xx: Success - The action was successfully received, understood, and accepted",
      "ja": " - の2xx：成功 - アクションが成功し、受信理解し、受け入れられました"
    },
    {
      "indent": 6,
      "text": "- 3xx: Redirection - Further action must be taken in order to complete the request",
      "ja": " -  300番台：リダイレクション - さらなるアクションが要求を完了するために取られなければなりません"
    },
    {
      "indent": 6,
      "text": "- 4xx: Client Error - The request contains bad syntax or cannot be fulfilled",
      "ja": " -  4XX：クライアントエラー - 要求が不正な構文を含む、または満たすことができません"
    },
    {
      "indent": 6,
      "text": "- 5xx: Server Error - The server failed to fulfill an apparently valid request",
      "ja": " -  5xxの：サーバーエラー - サーバーが明らかに有効な要求を満たすことができませんでした"
    },
    {
      "indent": 3,
      "text": "The individual values of the numeric status codes defined for HTTP/1.1, and an example set of corresponding Reason-Phrase's, are presented below. The reason phrases listed here are only recommendations -- they MAY be replaced by local equivalents without affecting the protocol.",
      "ja": "HTTP / 1.1のために定義された数値ステータスコードの個々の値、および対応する理由-フレーズのセットの例は、以下に提示されています。ここに記載されている理由の句は推奨されている - 彼らはプロトコルに影響を与えることなく、地元の同等物に置き換えることができます。"
    },
    {
      "indent": 6,
      "text": "Status-Code = \"100\" ; Section 10.1.1: Continue | \"101\" ; Section 10.1.2: Switching Protocols | \"200\" ; Section 10.2.1: OK | \"201\" ; Section 10.2.2: Created | \"202\" ; Section 10.2.3: Accepted | \"203\" ; Section 10.2.4: Non-Authoritative Information | \"204\" ; Section 10.2.5: No Content | \"205\" ; Section 10.2.6: Reset Content | \"206\" ; Section 10.2.7: Partial Content | \"300\" ; Section 10.3.1: Multiple Choices | \"301\" ; Section 10.3.2: Moved Permanently | \"302\" ; Section 10.3.3: Found | \"303\" ; Section 10.3.4: See Other | \"304\" ; Section 10.3.5: Not Modified | \"305\" ; Section 10.3.6: Use Proxy | \"307\" ; Section 10.3.8: Temporary Redirect | \"400\" ; Section 10.4.1: Bad Request | \"401\" ; Section 10.4.2: Unauthorized | \"402\" ; Section 10.4.3: Payment Required | \"403\" ; Section 10.4.4: Forbidden | \"404\" ; Section 10.4.5: Not Found | \"405\" ; Section 10.4.6: Method Not Allowed | \"406\" ; Section 10.4.7: Not Acceptable",
      "ja": "ステータスコード=「100」; 10.1.1項：続行| 「101」。 10.1.2項：プロトコルの切り替え| 「200」。 10.2.1項：OK | 「201」。 10.2.2項：作成しました| 「202」。 10.2.3：受理| 「203」。 10.2.4項：非信頼できる情報| 「204」。 10.2.5項：いいえコンテンツ| 「205」。 10.2.6項：コンテンツをリセット| 「206」。 10.2.7項​​：部分コンテンツ| 「300」。 10.3.1項：複数の選択肢| 「301」。 10.3.2項：恒久的に移動| 「302」。 10.3.3項：実測値| 「303」。セクション10.3.4：その他を見ます| 「304」。 10.3.5項：修正ません| 「305」。セクション10.3.6：プロキシを使用| 「307」。 10.3.8：一時的なリダイレクト| 「400」。セクション10.4.1：不正な要求| 「401」。 10.4.2項：無許可| 「402」。 10.4.3項：支払いが必要| 「403」。 10.4.4項：禁断| 「404」。セクション10.4.5：見つかりません| 「405」。セクション10.4.6：メソッドは許可されていません| 「406」。セクション10.4.7：許容できません"
    },
    {
      "indent": 10,
      "text": "| \"407\"  ; Section 10.4.8: Proxy Authentication Required\n| \"408\"  ; Section 10.4.9: Request Time-out\n| \"409\"  ; Section 10.4.10: Conflict\n| \"410\"  ; Section 10.4.11: Gone\n| \"411\"  ; Section 10.4.12: Length Required\n| \"412\"  ; Section 10.4.13: Precondition Failed\n| \"413\"  ; Section 10.4.14: Request Entity Too Large\n| \"414\"  ; Section 10.4.15: Request-URI Too Large\n| \"415\"  ; Section 10.4.16: Unsupported Media Type\n| \"416\"  ; Section 10.4.17: Requested range not satisfiable\n| \"417\"  ; Section 10.4.18: Expectation Failed\n| \"500\"  ; Section 10.5.1: Internal Server Error\n| \"501\"  ; Section 10.5.2: Not Implemented\n| \"502\"  ; Section 10.5.3: Bad Gateway\n| \"503\"  ; Section 10.5.4: Service Unavailable\n| \"504\"  ; Section 10.5.5: Gateway Time-out\n| \"505\"  ; Section 10.5.6: HTTP Version not supported\n| extension-code",
      "raw": true
    },
    {
      "indent": 6,
      "text": "extension-code = 3DIGIT Reason-Phrase = *<TEXT, excluding CR, LF>",
      "ja": "拡張コード= 3DIGIT理由-フレーズ= * <TEXT除くCR、LF>"
    },
    {
      "indent": 3,
      "text": "HTTP status codes are extensible. HTTP applications are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable. However, applications MUST understand the class of any status code, as indicated by the first digit, and treat any unrecognized response as being equivalent to the x00 status code of that class, with the exception that an unrecognized response MUST NOT be cached. For example, if an unrecognized status code of 431 is received by the client, it can safely assume that there was something wrong with its request and treat the response as if it had received a 400 status code. In such cases, user agents SHOULD present to the user the entity returned with the response, since that entity is likely to include human-readable information which will explain the unusual status.",
      "ja": "HTTPステータスコードは、拡張可能です。そのような理解は明らかに望ましいですが、HTTPアプリケーションは、登録されているすべてのステータスコードの意味を理解する必要はありません。ただし、アプリケーションは最初の数字で示されるように、任意のステータスコードのクラスを理解し、認識されない応答をキャッシュしてはならないことを除いて、そのクラスのX00ステータスコードと同等のものとして認識されない応答を扱わなければなりません。例えば、431の認識されていないステータスコードがクライアントによって受信された場合、それは安全にその要求に何か問題があったと仮定することができますし、それが400のステータスコードを受け取ったかのように応答を扱います。そのエンティティが異常状態を説明する人間可読情報を含む可能性があるので、このような場合、ユーザエージェントは、エンティティが応答で返さユーザに提示しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2 Response Header Fields",
      "section_title": true,
      "ja": "6.2レスポンスヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "The response-header fields allow the server to pass additional information about the response which cannot be placed in the Status-Line. These header fields give information about the server and about further access to the resource identified by the Request-URI.",
      "ja": "レスポンスヘッダフィールドは、サーバがステータスラインに配置することができない応答に関する追加情報を通過させます。これらのヘッダーフィールドは、サーバに関するとRequest-URIによって識別されたリソースへのさらなるアクセスについての情報を与えます。"
    },
    {
      "indent": 7,
      "text": "response-header = Accept-Ranges           ; Section 14.5\n                | Age                     ; Section 14.6\n                | ETag                    ; Section 14.19\n                | Location                ; Section 14.30\n                | Proxy-Authenticate      ; Section 14.33",
      "raw": true
    },
    {
      "indent": 23,
      "text": "| Retry-After             ; Section 14.37\n| Server                  ; Section 14.38\n| Vary                    ; Section 14.44\n| WWW-Authenticate        ; Section 14.47",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Response-header field names can be extended reliably only in combination with a change in the protocol version. However, new or experimental header fields MAY be given the semantics of response-header fields if all parties in the communication recognize them to be response-header fields. Unrecognized header fields are treated as entity-header fields.",
      "ja": "レスポンスヘッダフィールド名はプロトコルバージョンにおける変化との組み合わせでのみ確実に拡張することができます。通信のすべての当事者がレスポンスヘッダフィールドであることをそれらを認識場合は、新しいまたは実験ヘッダフィールドは、レスポンスヘッダフィールドの意味論を与えてもよいです。認識されていないヘッダフィールドは、エンティティヘッダフィールドとして扱われます。"
    },
    {
      "indent": 0,
      "text": "7 Entity",
      "ja": "7エンティティ"
    },
    {
      "indent": 3,
      "text": "Request and Response messages MAY transfer an entity if not otherwise restricted by the request method or response status code. An entity consists of entity-header fields and an entity-body, although some responses will only include the entity-headers.",
      "ja": "そうでない場合は、要求メソッドやレスポンスのステータスコードによって制限されていない場合は要求メッセージと応答メッセージは、エンティティを転送することができます。いくつかの応答のみエンティティヘッダを含むであろうが、エンティティは、エンティティ - ヘッダフィールド及びエンティティ - 本体から成ります。"
    },
    {
      "indent": 3,
      "text": "In this section, both sender and recipient refer to either the client or the server, depending on who sends and who receives the entity.",
      "ja": "このセクションでは、送信者と受信者の両方を送信し、誰エンティティの受信者に応じて、クライアントまたはサーバのいずれかを参照してください。"
    },
    {
      "indent": 0,
      "text": "7.1 Entity Header Fields",
      "section_title": true,
      "ja": "7.1エンティティヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "Entity-header fields define metainformation about the entity-body or, if no body is present, about the resource identified by the request. Some of this metainformation is OPTIONAL; some might be REQUIRED by portions of this specification.",
      "ja": "全く体が存在しない場合、エンティティヘッダフィールドは、要求によって識別されたリソースについて、エンティティボディについてのメタ情報を定義しますか。このメタ情報の一部はオプションです。いくつかは、この仕様の部分で必要になることがあります。"
    },
    {
      "indent": 7,
      "text": "entity-header  = Allow                    ; Section 14.7\n               | Content-Encoding         ; Section 14.11\n               | Content-Language         ; Section 14.12\n               | Content-Length           ; Section 14.13\n               | Content-Location         ; Section 14.14\n               | Content-MD5              ; Section 14.15\n               | Content-Range            ; Section 14.16\n               | Content-Type             ; Section 14.17\n               | Expires                  ; Section 14.21\n               | Last-Modified            ; Section 14.29\n               | extension-header",
      "raw": true
    },
    {
      "indent": 7,
      "text": "extension-header = message-header",
      "ja": "拡張ヘッダー=メッセージ・ヘッダ"
    },
    {
      "indent": 3,
      "text": "The extension-header mechanism allows additional entity-header fields to be defined without changing the protocol, but these fields cannot be assumed to be recognizable by the recipient. Unrecognized header fields SHOULD be ignored by the recipient and MUST be forwarded by transparent proxies.",
      "ja": "拡張ヘッダメカニズムは、追加のエンティティヘッダフィールドは、プロトコルを変更せずに定義されるように、これらのフィールドは、受信者によって認識可能であると仮定することができない可能にします。認識されていないヘッダフィールドは、受信者によって無視されるべきであり、透明なプロキシによって転送されなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.2 Entity Body",
      "section_title": true,
      "ja": "7.2エンティティボディ"
    },
    {
      "indent": 3,
      "text": "The entity-body (if any) sent with an HTTP request or response is in a format and encoding defined by the entity-header fields.",
      "ja": "HTTP要求または応答と共に送信エンティティボディは、（もしあれば）エンティティヘッダフィールドによって定義されたフォーマット及び符号化です。"
    },
    {
      "indent": 7,
      "text": "entity-body = *OCTET",
      "ja": "エンティティボディ= * OCTET"
    },
    {
      "indent": 3,
      "text": "An entity-body is only present in a message when a message-body is present, as described in section 4.3. The entity-body is obtained from the message-body by decoding any Transfer-Encoding that might have been applied to ensure safe and proper transfer of the message.",
      "ja": "メッセージ本体が存在する場合のセクション4.3に記載したようにエンティティボディは、メッセージ中にのみ存在します。エンティティボディは、メッセージの安全かつ適切な転送を保証するために適用されている可能性のある転送エンコードをデコードして、メッセージボディから得られます。"
    },
    {
      "indent": 0,
      "text": "7.2.1 Type",
      "section_title": true,
      "ja": "7.2.1タイプ"
    },
    {
      "indent": 3,
      "text": "When an entity-body is included with a message, the data type of that body is determined via the header fields Content-Type and Content-Encoding. These define a two-layer, ordered encoding model:",
      "ja": "エンティティボディがメッセージに含まれている場合に、その身体のデータ・タイプは、ヘッダフィールドのContent-TypeとContent-エンコーディングを介して決定されます。これらは、二層、注文したエンコーディングモデルを定義します。"
    },
    {
      "indent": 7,
      "text": "entity-body := Content-Encoding( Content-Type( data ) )",
      "ja": "エンティティボディ：=コンテンツのエンコーディング（Content-Typeの（データ））"
    },
    {
      "indent": 3,
      "text": "Content-Type specifies the media type of the underlying data. Content-Encoding may be used to indicate any additional content codings applied to the data, usually for the purpose of data compression, that are a property of the requested resource. There is no default encoding.",
      "ja": "コンテンツタイプは、基礎となるデータのメディアタイプを指定します。コンテンツのエンコーディングは要求されたリソースの所有物であり、通常はデータ圧縮の目的のために、データに適用された追加コンテンツのコーディングを示すために使用されてもよいです。デフォルトのエンコーディングはありません。"
    },
    {
      "indent": 3,
      "text": "Any HTTP/1.1 message containing an entity-body SHOULD include a Content-Type header field defining the media type of that body. If and only if the media type is not given by a Content-Type field, the recipient MAY attempt to guess the media type via inspection of its content and/or the name extension(s) of the URI used to identify the resource. If the media type remains unknown, the recipient SHOULD treat it as type \"application/octet-stream\".",
      "ja": "エンティティボディを含む任意のHTTP / 1.1メッセージは、そのボディのメディアタイプを定義するContent-Typeヘッダフィールドを含むべきです。メディアタイプは、Content-Typeフィールドで指定されていない場合にのみ、かつ、受信者はその内容および/またはURIの拡張子（S）の検査を経てメディアタイプを推測しようと可能性がある場合、リソースを識別するために使用されます。メディアタイプが不明のままである場合、受信者はタイプ「アプリケーション/オクテットストリーム」として扱うべきです。"
    },
    {
      "indent": 0,
      "text": "7.2.2 Entity Length",
      "section_title": true,
      "ja": "7.2.2エンティティの長さ"
    },
    {
      "indent": 3,
      "text": "The entity-length of a message is the length of the message-body before any transfer-codings have been applied. Section 4.4 defines how the transfer-length of a message-body is determined.",
      "ja": "メッセージの実体の長さの任意の転送コーディングが適用された前のメッセージボディの長さです。セクション4.4は、メッセージボディの転送長さが決定される方法を定義します。"
    },
    {
      "indent": 0,
      "text": "8 Connections",
      "ja": "8つの接続"
    },
    {
      "indent": 0,
      "text": "8.1 Persistent Connections",
      "section_title": true,
      "ja": "8.1永続的な接続"
    },
    {
      "indent": 0,
      "text": "8.1.1 Purpose",
      "section_title": true,
      "ja": "8.1.1目的"
    },
    {
      "indent": 3,
      "text": "Prior to persistent connections, a separate TCP connection was established to fetch each URL, increasing the load on HTTP servers and causing congestion on the Internet. The use of inline images and other associated data often require a client to make multiple requests of the same server in a short amount of time. Analysis of these performance problems and results from a prototype implementation are available [26] [30]. Implementation experience and measurements of actual HTTP/1.1 (RFC 2068) implementations show good results [39]. Alternatives have also been explored, for example, T/TCP [27].",
      "ja": "持続的な接続に先立って、別々のTCP接続はHTTPサーバーの負荷を増加し、インターネット上の混雑を引き起こして、各URLを取得するために設立されました。インライン画像や他の関連するデータの使用は、多くの場合、短時間で同じサーバの複数の要求を行うために、クライアントが必要です。プロトタイプの実装のこれらの性能の問題と結果の解析が利用可能である[26] [30]。実装経験と実際のHTTP / 1.1（RFC 2068）の測定を実装する[39]良好な結果を示しています。代替はまた、例えば、検討されている、T / TCP [27]。"
    },
    {
      "indent": 3,
      "text": "Persistent HTTP connections have a number of advantages:",
      "ja": "永続的なHTTP接続は、多くの利点を持っています："
    },
    {
      "indent": 6,
      "text": "- By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways, tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.",
      "ja": " - オープン少ないTCP接続を閉じることによって、CPU時間は、ルータとホスト（クライアント、サーバ、プロキシ、ゲートウェイ、トンネル、またはキャッシュ）に保存され、TCPプロトコル制御ブロックのために使用されるメモリは、ホストに保存することができます。"
    },
    {
      "indent": 6,
      "text": "- HTTP requests and responses can be pipelined on a connection. Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.",
      "ja": " -  HTTPリクエストとレスポンスは接続上でパイプライン化することができます。パイプラインは、はるかに低い経過時間で、はるかに効率的に使用するための単一のTCP接続を許可する、クライアントはそれぞれの応答を待たずに複数の要求を行うことができます。"
    },
    {
      "indent": 6,
      "text": "- Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network.",
      "ja": " - ネットワークの輻輳をTCPが開くことによって、引き起こされるパケットの数を減らすことによって、ネットワークの輻輳状態を決定するためにTCP十分な時間を可能にすることによって低減されます。"
    },
    {
      "indent": 6,
      "text": "- Latency on subsequent requests is reduced since there is no time spent in TCP's connection opening handshake.",
      "ja": " -  TCPの接続口握手で過ごした時間がないので、後続の要求の待ち時間が短縮されます。"
    },
    {
      "indent": 6,
      "text": "- HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection. Clients using future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old semantics after an error is reported.",
      "ja": " - エラーがTCP接続を閉じるのペナルティなしに報告することができますので、HTTPは、より優雅に進化させることができます。 HTTPの将来のバージョンを使用しているクライアントは、楽観的な新機能を試してみますが、古いサーバと通信する場合は、エラーが報告された後、古いセマンティクスを再試行することがあります。"
    },
    {
      "indent": 3,
      "text": "HTTP implementations SHOULD implement persistent connections.",
      "ja": "HTTP実装は、持続的な接続を実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.1.2 Overall Operation",
      "section_title": true,
      "ja": "8.1.2全体の動作"
    },
    {
      "indent": 3,
      "text": "A significant difference between HTTP/1.1 and earlier versions of HTTP is that persistent connections are the default behavior of any HTTP connection. That is, unless otherwise indicated, the client SHOULD assume that the server will maintain a persistent connection, even after error responses from the server.",
      "ja": "HTTPのHTTP / 1.1およびそれ以前のバージョンとの間に有意な差は持続的な接続が任意のHTTP接続のデフォルトの動作であるということです。特に断らない限り、つまり、クライアントは、サーバでも、サーバーからエラー応答の後、持続的な接続を維持することを前提とすべきです。"
    },
    {
      "indent": 3,
      "text": "Persistent connections provide a mechanism by which a client and a server can signal the close of a TCP connection. This signaling takes place using the Connection header field (section 14.10). Once a close has been signaled, the client MUST NOT send any more requests on that connection.",
      "ja": "持続的接続は、クライアントとサーバーは、TCPコネクションのクローズを知らせることができるメカニズムを提供します。このシグナリングは、Connectionヘッダフィールド（セクション14.10）を使用して行われます。近くには合図された後、クライアントはその接続上の任意のより多くのリクエストを送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "8.1.2.1 Negotiation",
      "section_title": true,
      "ja": "8.1.2.1交渉"
    },
    {
      "indent": 3,
      "text": "An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to maintain a persistent connection unless a Connection header including the connection-token \"close\" was sent in the request. If the server chooses to close the connection immediately after sending the response, it SHOULD send a Connection header including the connection-token close.",
      "ja": "HTTP / 1.1サーバは、HTTP / 1.1クライアントが要求で送信された「クローズ」接続トークンを含むConnectionヘッダない限り、永続的な接続を維持する意向であることを仮定してもよいです。サーバが応答を送信した後すぐに接続を閉じることを選択した場合、それは接続トークン近い含む接続ヘッダを送るべきです。"
    },
    {
      "indent": 3,
      "text": "An HTTP/1.1 client MAY expect a connection to remain open, but would decide to keep it open based on whether the response from a server contains a Connection header with the connection-token close. In case the client does not want to maintain a connection for more than that request, it SHOULD send a Connection header including the connection-token close.",
      "ja": "HTTP / 1.1クライアントは、接続が開いたままに期待するかもしれないが、それは、サーバーからの応答は、接続トークン近いとの接続ヘッダーが含まれているかどうかに基づいて、開いたまますることを決定します。クライアントがそのリクエスト以上の接続を維持したくない場合は、接続トークンクローズ含むConnectionヘッダを送るべきです。"
    },
    {
      "indent": 3,
      "text": "If either the client or the server sends the close token in the Connection header, that request becomes the last one for the connection.",
      "ja": "クライアントまたはサーバのどちらかがConnectionヘッダに近いトークンを送信する場合、その要求は、接続のための最後のものとなります。"
    },
    {
      "indent": 3,
      "text": "Clients and servers SHOULD NOT assume that a persistent connection is maintained for HTTP versions less than 1.1 unless it is explicitly signaled. See section 19.6.2 for more information on backward compatibility with HTTP/1.0 clients.",
      "ja": "クライアントとサーバーは、それが明示的にシグナリングされない限り、永続的な接続が1.1未満HTTPのバージョンのために維持されていることを仮定するべきではありません。 HTTP / 1.0クライアントとの後方互換性の詳細については、セクション19.6.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "In order to remain persistent, all messages on the connection MUST have a self-defined message length (i.e., one not defined by closure of the connection), as described in section 4.4.",
      "ja": "セクション4.4で説明したように、永続的維持するために、接続上のすべてのメッセージは、（すなわち、一方が接続の閉鎖によって定義されていない）の自己定義されたメッセージの長さを持たなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.1.2.2 Pipelining",
      "section_title": true,
      "ja": "8.1.2.2パイプライン"
    },
    {
      "indent": 3,
      "text": "A client that supports persistent connections MAY \"pipeline\" its requests (i.e., send multiple requests without waiting for each response). A server MUST send its responses to those requests in the same order that the requests were received.",
      "ja": "持続的接続をサポートするクライアントは、「パイプライン」の要求が（すなわち、各応答を待たずに複数のリクエストを送信）するかもしれません。サーバーは、要求が受け取られたのと同じ順序でこれらの要求への応答を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Clients which assume persistent connections and pipeline immediately after connection establishment SHOULD be prepared to retry their connection if the first pipelined attempt fails. If a client does such a retry, it MUST NOT pipeline before it knows the connection is persistent. Clients MUST also be prepared to resend their requests if the server closes the connection before sending all of the corresponding responses.",
      "ja": "接続確立後すぐに持続的接続とパイプラインを想定してクライアントは、最初のパイプライン化の試行が失敗した場合、その接続を再試行するために準備する必要があります。クライアントは、このような再試行を行う場合は、接続が永続的であることを知っている前に、それは、パイプラインはいけません。また、クライアントは、サーバが対応するすべての応答を送信する前に、接続を閉じた場合、その要求を再送信するために準備しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT pipeline requests using non-idempotent methods or non-idempotent sequences of methods (see section 9.1.2). Otherwise, a premature termination of the transport connection could lead to indeterminate results. A client wishing to send a non-idempotent request SHOULD wait to send that request until it has received the response status for the previous request.",
      "ja": "非冪等の方法または方法の非冪等のシーケンスを（セクション9.1.2を参照）を使用しているクライアントがないはずのパイプラインを要求。それ以外の場合は、トランスポート接続の早期終了が不確定な結果につながる可能性があります。非べき等の要求を送信したいクライアントは、それが以前の要求に対する応答ステータスを受信するまで、その要求を送信するために待機しなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.1.3 Proxy Servers",
      "section_title": true,
      "ja": "8.1.3プロキシサーバ"
    },
    {
      "indent": 3,
      "text": "It is especially important that proxies correctly implement the properties of the Connection header field as specified in section 14.10.",
      "ja": "セクション14.10で指定されたプロキシが正しく接続ヘッダフィールドのプロパティを実装することが特に重要です。"
    },
    {
      "indent": 3,
      "text": "The proxy server MUST signal persistent connections separately with its clients and the origin servers (or other proxy servers) that it connects to. Each persistent connection applies to only one transport link.",
      "ja": "プロキシサーバは、それが接続する、クライアントとオリジンサーバ（または他のプロキシサーバ）とは別に、永続的な接続を通知しなければなりません。各永続的な接続は、唯一のトランスポートリンクに適用されます。"
    },
    {
      "indent": 3,
      "text": "A proxy server MUST NOT establish a HTTP/1.1 persistent connection with an HTTP/1.0 client (but see RFC 2068 [33] for information and discussion of the problems with the Keep-Alive header implemented by many HTTP/1.0 clients).",
      "ja": "プロキシサーバは、HTTP / 1.0クライアントとHTTP / 1.1の永続的な接続を確立する（しかし、多くのHTTP / 1.0クライアントによって実装キープアライブヘッダーでの問題の情報と議論のためにRFC 2068 [33]を参照）してはなりません。"
    },
    {
      "indent": 0,
      "text": "8.1.4 Practical Considerations",
      "section_title": true,
      "ja": "8.1.4実用的な考慮事項"
    },
    {
      "indent": 3,
      "text": "Servers will usually have some time-out value beyond which they will no longer maintain an inactive connection. Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same server. The use of persistent connections places no requirements on the length (or existence) of this time-out for either the client or the server.",
      "ja": "サーバは通常、彼らはもはや非アクティブな接続を維持します、それを超えるいくつかのタイムアウト値を持つことになります。クライアントが同じサーバーを介して複数の接続を行うされる可能性があるため、プロキシサーバーは、この高い値になるかもしれません。持続的な接続を使用するには、クライアントまたはサーバーのいずれかのために、このタイムアウトの長さ（または存在）に何の要件を置きません。"
    },
    {
      "indent": 3,
      "text": "When a client or server wishes to time-out it SHOULD issue a graceful close on the transport connection. Clients and servers SHOULD both constantly watch for the other side of the transport close, and respond to it as appropriate. If a client or server does not detect the other side's close promptly it could cause unnecessary resource drain on the network.",
      "ja": "クライアントまたはサーバがタイムアウトすることを望むときには、トランスポート接続上の優雅なクローズを発行する必要があります。クライアントとサーバーは両方絶えず輸送の近くの他の側面を監視し、必要に応じてそれに応答する必要があります。クライアントまたはサーバーが他の側のクローズを検出しない場合、速やかには、ネットワーク上の不必要なリソース消耗を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the \"idle\" connection. From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress.",
      "ja": "クライアント、サーバ、またはプロキシは、いつでも輸送接続を終えるかもしれません。例えば、クライアントは、サーバーが「アイドル」の接続をクローズすることを決定したと同時に、新しいリクエストを送信し始めているかもしれません。それがアイドル状態であったサーバの観点からは、接続が閉じられているが、クライアントの観点から、要求が進行中です。"
    },
    {
      "indent": 3,
      "text": "This means that clients, servers, and proxies MUST be able to recover from asynchronous close events. Client software SHOULD reopen the transport connection and retransmit the aborted sequence of requests without user interaction so long as the request sequence is idempotent (see section 9.1.2). Non-idempotent methods or sequences MUST NOT be automatically retried, although user agents MAY offer a human operator the choice of retrying the request(s). Confirmation by user-agent software with semantic understanding of the application MAY substitute for user confirmation. The automatic retry SHOULD NOT be repeated if the second sequence of requests fails.",
      "ja": "これは、クライアント、サーバ、およびプロキシは非同期クローズイベントから回復できなければならないことを意味しています。クライアントソフトウェアは、（セクション9.1.2を参照）トランスポート接続を再オープンし、リクエストシーケンスが冪等である限り、ユーザーとの対話なしで要求の中止されたシーケンスを再送信すべきです。ユーザーエージェントが再試行の選択要求（複数可）人間のオペレータを提供することがありますが、非冪等メソッドやシーケンスは自動的に、再試行してはなりません。アプリケーションの意味理解を持つユーザー・エージェント・ソフトウェアによる確認は、ユーザーの確認を置換することができます。リクエストの第二の配列に失敗した場合に自動再試行が繰り返されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Servers SHOULD always respond to at least one request per connection, if at all possible. Servers SHOULD NOT close a connection in the middle of transmitting a response, unless a network or client failure is suspected.",
      "ja": "可能で、すべての場合、サーバーは常に、接続ごとに少なくとも1つの要求に応答する必要があります。サーバーは、ネットワークやクライアントの障害が疑われる場合を除き、応答を送信の途中で接続をクローズすべきではありません。"
    },
    {
      "indent": 3,
      "text": "Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server. A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy. A proxy SHOULD use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users. These guidelines are intended to improve HTTP response times and avoid congestion.",
      "ja": "持続的接続を使用するクライアントは、彼らが特定のサーバーに維持する同時接続数を制限する必要があります。シングルユーザクライアントは、任意のサーバーまたはプロキシとの2つの以上の接続を維持すべきではありません。プロキシは、Nが同時にアクティブユーザの数であり、別のサーバまたはプロキシ、2つの* N接続まで使用すべきです。これらのガイドラインはHTTPレスポンスタイムを改善し、輻輳を回避することを意図しています。"
    },
    {
      "indent": 0,
      "text": "8.2 Message Transmission Requirements",
      "section_title": true,
      "ja": "8.2メッセージ伝送要件"
    },
    {
      "indent": 0,
      "text": "8.2.1 Persistent Connections and Flow Control",
      "section_title": true,
      "ja": "8.2.1永続的な接続とフローコントロール"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's flow control mechanisms to resolve temporary overloads, rather than terminating connections with the expectation that clients will retry. The latter technique can exacerbate network congestion.",
      "ja": "HTTP / 1.1サーバは、持続的な接続を維持し、むしろ、クライアントが再試行することを期待しての接続を終了するよりも、一時的な過負荷を解決するためにTCPのフロー制御メカニズムを使用すべきです。後者の技術は、ネットワークの輻輳を悪化させることができます。"
    },
    {
      "indent": 0,
      "text": "8.2.2 Monitoring Connections for Error Status Messages",
      "section_title": true,
      "ja": "エラーステータスメッセージの8.2.2モニタの接続"
    },
    {
      "indent": 3,
      "text": "An HTTP/1.1 (or later) client sending a message-body SHOULD monitor the network connection for an error status while it is transmitting the request. If the client sees an error status, it SHOULD immediately cease transmitting the body. If the body is being sent using a \"chunked\" encoding (section 3.6), a zero length chunk and empty trailer MAY be used to prematurely mark the end of the message. If the body was preceded by a Content-Length header, the client MUST close the connection.",
      "ja": "それは、要求を送信している間、メッセージボディを送信するHTTP / 1.1（またはそれ以降）のクライアントは、エラー状態のためのネットワーク接続を監視する必要があります。クライアントがエラー状態を見れば、それはすぐに身体を送信中止すべきです。本体は、符号化（セクション3.6）、「チャンク」を使用して送信されている場合、長さゼロのチャンクと空のトレーラは、早期のメッセージの終わりをマークするために使用されるかもしれません。ボディがContent-Lengthヘッダが先行していた場合、クライアントは接続を閉じる必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2.3 Use of the 100 (Continue) Status",
      "section_title": true,
      "ja": "100（続行）ステータスの8.2.3を使用します"
    },
    {
      "indent": 3,
      "text": "The purpose of the 100 (Continue) status (see section 10.1.1) is to allow a client that is sending a request message with a request body to determine if the origin server is willing to accept the request (based on the request headers) before the client sends the request body. In some cases, it might either be inappropriate or highly inefficient for the client to send the body if the server will reject the message without looking at the body.",
      "ja": "100（続行）状態の目的は、オリジンサーバが要求を受け入れるかどうかを判断するためにリクエストボディに要求メッセージを送信しているクライアントを許可するようにされた（セクション10.1.1を参照してください）（リクエストヘッダに基づいて）クライアントがリクエストボディを送信する前に。サーバが身体を見ずにメッセージを拒否するかどうか、クライアントは身体を送信するためにいくつかのケースでは、それはどちらか不適切か、非常に非効率的であるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Requirements for HTTP/1.1 clients:",
      "ja": "HTTP / 1.1クライアントの要件："
    },
    {
      "indent": 6,
      "text": "- If a client will wait for a 100 (Continue) response before sending the request body, it MUST send an Expect request-header field (section 14.20) with the \"100-continue\" expectation.",
      "ja": " - クライアントがリクエストボディを送信する前に100（続行）応答を待機する場合は、「100-継続」を期待して期待リクエストヘッダフィールド（セクション14.20）を送らなければなりません。"
    },
    {
      "indent": 6,
      "text": "- A client MUST NOT send an Expect request-header field (section 14.20) with the \"100-continue\" expectation if it does not intend to send a request body.",
      "ja": " - それはリクエストボディを送信することを意図していない場合、クライアントは「100続行」期待していリクエストヘッダフィールド（セクション14.20）を送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "Because of the presence of older implementations, the protocol allows ambiguous situations in which a client may send \"Expect: 100- continue\" without receiving either a 417 (Expectation Failed) status or a 100 (Continue) status. Therefore, when a client sends this header field to an origin server (possibly via a proxy) from which it has never seen a 100 (Continue) status, the client SHOULD NOT wait for an indefinite period before sending the request body.",
      "ja": "417（期待は失敗）ステータスまたは100（続行）状態のいずれかを受信することなく、次の理由古い実装が存在する、プロトコルは、クライアントが「100-継続期待」送信できる、あいまいな状況を可能にします。クライアントが100（続行）の状態を見たことがなかったから、（おそらくプロキシ経由）オリジンサーバに、このヘッダフィールドを送信したときしたがって、クライアントがリクエストボディを送信する前に無期限に待つべきではありません。"
    },
    {
      "indent": 3,
      "text": "Requirements for HTTP/1.1 origin servers:",
      "ja": "HTTP / 1.1オリジンサーバの要件："
    },
    {
      "indent": 6,
      "text": "- Upon receiving a request which includes an Expect request-header field with the \"100-continue\" expectation, an origin server MUST either respond with 100 (Continue) status and continue to read from the input stream, or respond with a final status code. The origin server MUST NOT wait for the request body before sending the 100 (Continue) response. If it responds with a final status code, it MAY close the transport connection or it MAY continue to read and discard the rest of the request. It MUST NOT perform the requested method if it returns a final status code.",
      "ja": " - 「100続行」期待していリクエストヘッダフィールドを含むリクエストを受信すると、オリジンサーバ100（続行）の状態で応答し、入力ストリームから読み込む、または最終状態コードで応答し続けなければならないのいずれかで。オリジンサーバは100（続行）応答を送信する前に、リクエストボディを待つてはなりません。それは、最終的なステータスコードで応答した場合、それはトランスポート接続を閉じたり、それが読み込まれ、要求の残りの部分を破棄し続けることができます。それは、最終的なステータスコードを返した場合には要求されたメソッドを実行してはなりません。"
    },
    {
      "indent": 6,
      "text": "- An origin server SHOULD NOT send a 100 (Continue) response if the request message does not include an Expect request-header field with the \"100-continue\" expectation, and MUST NOT send a 100 (Continue) response if such a request comes from an HTTP/1.0 (or earlier) client. There is an exception to this rule: for compatibility with RFC 2068, a server MAY send a 100 (Continue) status in response to an HTTP/1.1 PUT or POST request that does not include an Expect request-header field with the \"100- continue\" expectation. This exception, the purpose of which is to minimize any client processing delays associated with an undeclared wait for 100 (Continue) status, applies only to HTTP/1.1 requests, and not to requests with any other HTTP-version value.",
      "ja": " - オリジンサーバは、要求メッセージは、「100-継続」を期待して期待リクエストヘッダフィールドが含まれていない場合は100（続行）応答を送るべきではありませんし、そのような要求が来た場合に100（続行）応答を送ってはいけませんHTTP / 1.0（またはそれ以前）のクライアントから。この規則の例外があります：RFC 2068との互換性のために、サーバは「100-と期待リクエストヘッダフィールドが含まれていないHTTP / 1.1 PUTやPOSTリクエストに応じて、100（続行）のステータスを送信することができ「期待を続けます。この例外は、100（続行）ステータスを宣言されていない待機に関連付けられている任意のクライアント処理遅延を最小化することでその目的は、唯一のHTTP / 1.1リクエストにではなく、他のHTTP-バージョン値とのリクエストに適用されます。"
    },
    {
      "indent": 6,
      "text": "- An origin server MAY omit a 100 (Continue) response if it has already received some or all of the request body for the corresponding request.",
      "ja": " - それは、すでに対応する要求のためのリクエストボディの一部または全部を受信した場合、オリジンサーバは100（続行）応答を省略することができます。"
    },
    {
      "indent": 6,
      "text": "- An origin server that sends a 100 (Continue) response MUST ultimately send a final status code, once the request body is received and processed, unless it terminates the transport connection prematurely.",
      "ja": " - 要求本体が受信され処理されると、それが途中でトランスポート接続を終了しない限り、100を送信オリジンサーバ（続行）応答は、最終的に、最終的なステータスコードを送信しなければなりません。"
    },
    {
      "indent": 6,
      "text": "- If an origin server receives a request that does not include an Expect request-header field with the \"100-continue\" expectation, the request includes a request body, and the server responds with a final status code before reading the entire request body from the transport connection, then the server SHOULD NOT close the transport connection until it has read the entire request, or until the client closes the connection. Otherwise, the client might not reliably receive the response message. However, this requirement is not be construed as preventing a server from defending itself against denial-of-service attacks, or from badly broken client implementations.",
      "ja": " - オリジンサーバが「100続行」期待していリクエスト・ヘッダー・フィールドが含まれていない要求を受信した場合、要求は、要求本体を含み、そしてサーバから全体の要求本体を読み取る前に、最終的なステータス・コードで応答それは全体の要求を読んだまで、トランスポート接続は、サーバーはトランスポート接続をクローズすべきではない、またはクライアントが接続を閉じるまで。そうでない場合、クライアントは確実に応答メッセージを受信しないことがあります。しかし、この要件は、サービス拒否攻撃から自身を守るから、またはひどく破損クライアント実装からサーバーを防止するように解釈されません。"
    },
    {
      "indent": 3,
      "text": "Requirements for HTTP/1.1 proxies:",
      "ja": "HTTP / 1.1プロキシの要件："
    },
    {
      "indent": 6,
      "text": "- If a proxy receives a request that includes an Expect request-header field with the \"100-continue\" expectation, and the proxy either knows that the next-hop server complies with HTTP/1.1 or higher, or does not know the HTTP version of the next-hop server, it MUST forward the request, including the Expect header field.",
      "ja": " - プロキシは、「100続行」期待していリクエストヘッダフィールドを含むリクエストを受信すると、プロキシのいずれかネクストホップサーバがHTTP / 1.1以上に準拠していることを知っている、またはHTTPのバージョンがわからない場合ネクストホップサーバ、それが期待ヘッダフィールドを含む、要求を転送しなければなりません。"
    },
    {
      "indent": 6,
      "text": "- If the proxy knows that the version of the next-hop server is HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST respond with a 417 (Expectation Failed) status.",
      "ja": " - プロキシがネクストホップサーバのバージョンはHTTP / 1.0以下であることを知っている場合は、その要求を転送してはならない、それは417（期待に失敗しました）状態で応じなければなりません。"
    },
    {
      "indent": 6,
      "text": "- Proxies SHOULD maintain a cache recording the HTTP version numbers received from recently-referenced next-hop servers.",
      "ja": " - プロキシは、最近参照ネクストホップサーバから受信したHTTPのバージョン番号を記録するキャッシュを維持する必要があります。"
    },
    {
      "indent": 6,
      "text": "- A proxy MUST NOT forward a 100 (Continue) response if the request message was received from an HTTP/1.0 (or earlier) client and did not include an Expect request-header field with the \"100-continue\" expectation. This requirement overrides the general rule for forwarding of 1xx responses (see section 10.1).",
      "ja": " - 要求メッセージがHTTP / 1.0（またはそれ以前）クライアントから受信し、「100-継続」期待してリクエストヘッダフィールドを期待含まれていない場合、プロキシは100（続行）応答を転送してはいけません。この要件は、の1xx応答（セクション10.1を参照）の転送のための一般的なルールを上書き。"
    },
    {
      "indent": 0,
      "text": "8.2.4 Client Behavior if Server Prematurely Closes Connection",
      "section_title": true,
      "ja": "サーバーが途中で接続をクローズする場合は8.2.4クライアントの動作"
    },
    {
      "indent": 3,
      "text": "If an HTTP/1.1 client sends a request which includes a request body, but which does not include an Expect request-header field with the \"100-continue\" expectation, and if the client is not directly connected to an HTTP/1.1 origin server, and if the client sees the connection close before receiving any status from the server, the client SHOULD retry the request. If the client does retry this request, it MAY use the following \"binary exponential backoff\" algorithm to be assured of obtaining a reliable response:",
      "ja": "HTTP / 1.1クライアントは、要求本体を含む要求を送信するが、これは「100続行」期待していリクエスト・ヘッダー・フィールドが含まれていない、及びクライアントが直接HTTP / 1.1オリジンサーバに接続されていない場合場合クライアントがサーバーから任意のステータスを受け取る前に密接な関係を見た場合、および、クライアントが要求を再試行する必要があります。クライアントがこの要求を再試行しない場合、それは信頼性の高いレスポンスを得る保証するために、以下の「バイナリ指数バックオフ」のアルゴリズムを使用することがあります："
    },
    {
      "indent": 6,
      "text": "1. Initiate a new connection to the server",
      "section_title": true,
      "ja": "1.サーバーへの新しい接続を開始"
    },
    {
      "indent": 6,
      "text": "2. Transmit the request-headers",
      "section_title": true,
      "ja": "2.リクエストヘッダを送信"
    },
    {
      "indent": 6,
      "text": "3. Initialize a variable R to the estimated round-trip time to the server (e.g., based on the time it took to establish the connection), or to a constant value of 5 seconds if the round-trip time is not available.",
      "ja": "往復時間が利用できない場合3.サーバへの推定ラウンドトリップ時間（例えば、それが接続を確立するのに要した時間に基づいて）、または5秒の一定値に変数Rを初期化します。"
    },
    {
      "indent": 6,
      "text": "4. Compute T = R * (2**N), where N is the number of previous retries of this request.",
      "ja": "Nは、この要求の前の再試行の回数である。4.計算T = R *（2 ** N）。"
    },
    {
      "indent": 6,
      "text": "5. Wait either for an error response from the server, or for T seconds (whichever comes first)",
      "ja": "5.（いずれか早い方）のいずれかのサーバからエラー応答のために、又はT秒待ち"
    },
    {
      "indent": 6,
      "text": "6. If no error response is received, after T seconds transmit the body of the request.",
      "ja": "6.エラー応答が受信されない場合、T秒は、要求の本体を送信した後。"
    },
    {
      "indent": 6,
      "text": "7. If client sees that the connection is closed prematurely, repeat from step 1 until the request is accepted, an error response is received, or the user becomes impatient and terminates the retry process.",
      "ja": "クライアントは、接続要求が受け付けられるまで、ステップ1から繰り返す、早期閉鎖されていることを認識した場合7.、エラー応答が受信されるか、またはユーザがせっかちになり、リトライ処理を終了します。"
    },
    {
      "indent": 3,
      "text": "If at any point an error status is received, the client",
      "ja": "いずれかの時点でエラーステータスが受信された場合、クライアント"
    },
    {
      "indent": 6,
      "text": "- SHOULD NOT continue and",
      "ja": " - 継続すべきではなく、"
    },
    {
      "indent": 6,
      "text": "- SHOULD close the connection if it has not completed sending the request message.",
      "ja": " - それは要求メッセージを送信完了していない場合、接続を閉じる必要があります。"
    },
    {
      "indent": 0,
      "text": "9 Method Definitions",
      "ja": "9つのメソッド定義"
    },
    {
      "indent": 3,
      "text": "The set of common methods for HTTP/1.1 is defined below. Although this set can be expanded, additional methods cannot be assumed to share the same semantics for separately extended clients and servers.",
      "ja": "HTTP / 1.1のための一般的な方法のセットが以下に定義されます。このセットを拡張することができますが、追加の方法は、個別に拡張クライアントとサーバで同じ意味を共有すると仮定することはできません。"
    },
    {
      "indent": 3,
      "text": "The Host request-header field (section 14.23) MUST accompany all HTTP/1.1 requests.",
      "ja": "ホストリクエストヘッダフィールド（セクション14.23）は、すべてのHTTP / 1.1リクエストを添付しなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.1 Safe and Idempotent Methods",
      "section_title": true,
      "ja": "9.1安全でべき等のメソッド"
    },
    {
      "indent": 0,
      "text": "9.1.1 Safe Methods",
      "section_title": true,
      "ja": "9.1.1安全な方法"
    },
    {
      "indent": 3,
      "text": "Implementors should be aware that the software represents the user in their interactions over the Internet, and should be careful to allow the user to be aware of any actions they might take which may have an unexpected significance to themselves or others.",
      "ja": "実装者は、ソフトウェアがインターネット上でそれらの相互作用でユーザーを表していることに注意する必要があり、ユーザーが自分自身や他人への予期せぬ意義を有していてもよく、彼らがかかる場合があります任意のアクションを認識することができるように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "In particular, the convention has been established that the GET and HEAD methods SHOULD NOT have the significance of taking an action other than retrieval. These methods ought to be considered \"safe\". This allows user agents to represent other methods, such as POST, PUT and DELETE, in a special way, so that the user is made aware of the fact that a possibly unsafe action is being requested.",
      "ja": "特に、規則はGETとHEADメソッドは、検索以外の行動を取るの重要性を持つべきではないことが確立されてきました。これらのメソッドは「安全」とみなされるべきです。これは、ユーザエージェントは、例えばPOSTなどの他の方法を表すユーザはおそらく安全でないアクションが要求されているという事実を認識させられるように、特別な方法で、入れて削除することができます。"
    },
    {
      "indent": 3,
      "text": "Naturally, it is not possible to ensure that the server does not generate side-effects as a result of performing a GET request; in fact, some dynamic resources consider that a feature. The important distinction here is that the user did not request the side-effects, so therefore cannot be held accountable for them.",
      "ja": "当然、サーバがGET要求を実行した結果として副作用を生成しないことを保証することは不可能です。実際には、いくつかの動的なリソースが機能することを検討してください。ここでの重要な違いは、ユーザが副作用を要求しなかったので、したがって、彼らのために責任を負うことはできないということです。"
    },
    {
      "indent": 0,
      "text": "9.1.2 Idempotent Methods",
      "section_title": true,
      "ja": "9.1.2べき等のメソッド"
    },
    {
      "indent": 3,
      "text": "Methods can also have the property of \"idempotence\" in that (aside from error or expiration issues) the side-effects of N > 0 identical requests is the same as for a single request. The methods GET, HEAD, PUT and DELETE share this property. Also, the methods OPTIONS and TRACE SHOULD NOT have side effects, and so are inherently idempotent.",
      "ja": "方法は、N> 0の同一の要求の副作用が単一のリクエストと同じである（余談エラーまたは有効期限の問題から）という点で、「冪等性」の性質を有することができます。メソッドはGET、HEADは、PUTと共有して、このプロパティを削除します。また、メソッドのOPTIONSとTRACEは副作用を持つべきではない、ので、本質的に冪等です。"
    },
    {
      "indent": 3,
      "text": "However, it is possible that a sequence of several requests is non-idempotent, even if all of the methods executed in that sequence are idempotent. (A sequence is idempotent if a single execution of the entire sequence always yields a result that is not changed by a reexecution of all, or part, of that sequence.) For example, a sequence is non-idempotent if its result depends on a value that is later modified in the same sequence.",
      "ja": "しかし、いくつかの要求の順序は、その順序で実行されたメソッドのすべてが冪等であっても、非冪等であることも可能です。 （シーケンス全体の単一の実行が常にその配列の、全ての再実行、または一部によって変更されないという結果をもたらす場合シーケンスが冪等である。）その結果に依存する場合、例えば、配列が非冪等であります後で同じ順序で変更された値。"
    },
    {
      "indent": 3,
      "text": "A sequence that never has side effects is idempotent, by definition (provided that no concurrent operations are being executed on the same set of resources).",
      "ja": "副作用を持っていませんシーケンスは、定義（何の同時操作は、リソースの同じセット上で実行されていないことを提供する）、冪等です。"
    },
    {
      "indent": 0,
      "text": "9.2 OPTIONS",
      "section_title": true,
      "ja": "9.2 OPTIONS"
    },
    {
      "indent": 3,
      "text": "The OPTIONS method represents a request for information about the communication options available on the request/response chain identified by the Request-URI. This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.",
      "ja": "OPTIONSメソッドは、Request-URIによって識別される要求/応答チェーン上の利用可能な通信オプションについての情報の要求を表します。このメソッドは、リソースアクションを暗示するか、リソース検索を開始することなく、クライアントはオプションおよび/またはリソースに関連する要件、またはサーバーの能力を決定することができます。"
    },
    {
      "indent": 3,
      "text": "Responses to this method are not cacheable.",
      "ja": "このメソッドのレスポンスはキャッシュ可能ではありません。"
    },
    {
      "indent": 3,
      "text": "If the OPTIONS request includes an entity-body (as indicated by the presence of Content-Length or Transfer-Encoding), then the media type MUST be indicated by a Content-Type field. Although this specification does not define any use for such a body, future extensions to HTTP might use the OPTIONS body to make more detailed queries on the server. A server that does not support such an extension MAY discard the request body.",
      "ja": "OPTIONS要求は、エンティティボディを（コンテンツ長や転送エンコードの存在によって示されるように）含まれている場合、メディアタイプは、Content-Typeフィールドによって示さなければなりません。この仕様は、このような身体のための任意の使用を定義していませんが、HTTPの将来の拡張では、サーバー上のより詳細なクエリを作成するためにOPTIONS本体を使用する場合があります。そのような拡張機能をサポートしていないサーバがリクエストボディを捨てるかもしれ。"
    },
    {
      "indent": 3,
      "text": "If the Request-URI is an asterisk (\"*\"), the OPTIONS request is intended to apply to the server in general rather than to a specific resource. Since a server's communication options typically depend on the resource, the \"*\" request is only useful as a \"ping\" or \"no-op\" type of method; it does nothing beyond allowing the client to test the capabilities of the server. For example, this can be used to test a proxy for HTTP/1.1 compliance (or lack thereof).",
      "ja": "リクエスト-URIがアスタリスク（「*」）である場合は、OPTIONS要求は、一般的にではなく、特定のリソースへのサーバーに適用されるものとします。サーバの通信オプションは、典型的には、リソースに依存するので、「*」要求は、メソッドの「ピング」または「ノーオペレーション」タイプとしてのみ有用です。それは、クライアントがサーバの機能をテストすることができますを超えて何もしません。例えば、これはHTTP / 1.1コンプライアンス（またはその欠如）のプロキシをテストするために使用することができます。"
    },
    {
      "indent": 3,
      "text": "If the Request-URI is not an asterisk, the OPTIONS request applies only to the options that are available when communicating with that resource.",
      "ja": "リクエスト-URIがアスタリスクでない場合は、OPTIONSリクエストはそのリソースと通信するときに利用可能なオプションにのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "A 200 response SHOULD include any header fields that indicate optional features implemented by the server and applicable to that resource (e.g., Allow), possibly including extensions not defined by this specification. The response body, if any, SHOULD also include information about the communication options. The format for such a body is not defined by this specification, but might be defined by future extensions to HTTP. Content negotiation MAY be used to select the appropriate response format. If no response body is included, the response MUST include a Content-Length field with a field-value of \"0\".",
      "ja": "200応答は、おそらくこの仕様で定義されていない拡張を含む、サーバとそのリソースに適用（例えば、許可）によって実装オプション機能を示す任意のヘッダフィールドを含むべきです。レスポンスボディは、いかなる場合も、通信オプションについての情報を含むべきです。そのようなボディのための形式は、この仕様で定義されていませんが、HTTPの将来の拡張によって定義される可能性があります。コンテンツネゴシエーションは適切な応答形式を選択するために使用されるかもしれません。何のレスポンスボディが含まれていない場合、応答が「0」のフィールド値でのContent-Lengthフィールドを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Max-Forwards request-header field MAY be used to target a specific proxy in the request chain. When a proxy receives an OPTIONS request on an absoluteURI for which request forwarding is permitted, the proxy MUST check for a Max-Forwards field. If the Max-Forwards field-value is zero (\"0\"), the proxy MUST NOT forward the message; instead, the proxy SHOULD respond with its own communication options. If the Max-Forwards field-value is an integer greater than zero, the proxy MUST decrement the field-value when it forwards the request. If no Max-Forwards field is present in the request, then the forwarded request MUST NOT include a Max-Forwards field.",
      "ja": "マックスを転送リクエストヘッダフィールドは、要求チェーン内の特定のプロキシを標的化するために使用されるかもしれません。プロキシは、要求の転送を許可するためにabsoluteURIでOPTIONS要求を受信すると、プロキシは、最大転送しフィールドをチェックしなければなりません。最大転送し、フィールド値がゼロ（「0」）である場合、プロキシはメッセージを転送してはいけません。代わりに、プロキシは、独自の通信オプションを使用して応答する必要があります。最大転送し、フィールド値がゼロよりも大きい整数である場合、それは要求を転送するとき、プロキシは、フィールドの値をデクリメントしなければなりません。何のマックス・フォワードフィールドがリクエストに存在しない場合は、転送された要求は、マックス・フォワード分野を含んではいけません。"
    },
    {
      "indent": 0,
      "text": "9.3 GET",
      "section_title": true,
      "ja": "9.3 GET"
    },
    {
      "indent": 3,
      "text": "The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process, unless that text happens to be the output of the process.",
      "ja": "GETメソッドは、Request-URIによって識別されるどんな情報（エンティティの形で）を取得します。リクエストURIがデータ生成プロセスを指す場合、そのテキストがプロセスの出力であることを起こる場合を除き、それは、生成された応答内のエンティティとして返さなければならないデータはなく、プロセスのソーステキストです。"
    },
    {
      "indent": 3,
      "text": "The semantics of the GET method change to a \"conditional GET\" if the request message includes an If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range header field. A conditional GET method requests that the entity be transferred only under the circumstances described by the conditional header field(s). The conditional GET method is intended to reduce unnecessary network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring data already held by the client.",
      "ja": "要求メッセージは、もし修飾-ので、場合非改変-ので、場合マッチ、なし、マッチした場合、または場合-Rangeヘッダフィールドを含む場合、「条件付きGET」にGETメソッド変化の意味論。条件付きGETメソッドは、エンティティが唯一の条件付きヘッダフィールド（複数可）に記載状況下で転送されることを要求します。条件付きGETメソッドは、キャッシュされたエンティティが複数の要求を必要とするか、すでにクライアントが保持するデータを転送せずにリフレッシュすることができるようにすることで、不要なネットワークの使用量を低減することを目的とします。"
    },
    {
      "indent": 3,
      "text": "The semantics of the GET method change to a \"partial GET\" if the request message includes a Range header field. A partial GET requests that only part of the entity be transferred, as described in section 14.35. The partial GET method is intended to reduce unnecessary network usage by allowing partially-retrieved entities to be completed without transferring data already held by the client.",
      "ja": "要求メッセージがRangeヘッダフィールドを含む場合に「部分GET」にGETメソッド変化の意味論。セクション14.35に記載されているように、エンティティの一部のみが、転送すべき部分GETリクエスト。部分的GETメソッドは、部分的に取り出されたエンティティはすでにクライアントが保持しているデータを転送せずに完了することができるようにすることで、不要なネットワークの使用量を低減することを目的とします。"
    },
    {
      "indent": 3,
      "text": "The response to a GET request is cacheable if and only if it meets the requirements for HTTP caching described in section 13.",
      "ja": "GET要求に対する応答がキャッシュ可能な場合であり、それはセクション13で説明したHTTPキャッシングのための要件を満たしている場合のみ。"
    },
    {
      "indent": 3,
      "text": "See section 15.1.3 for security considerations when used for forms.",
      "ja": "フォームで使用する場合、セキュリティの考慮事項についてはセクション15.1.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.4 HEAD",
      "section_title": true,
      "ja": "9.4 HEAD"
    },
    {
      "indent": 3,
      "text": "The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response. The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request. This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself. This method is often used for testing hypertext links for validity, accessibility, and recent modification.",
      "ja": "HEADメソッドは、サーバが応答でメッセージボディを返してはならないことを除いて取得することと同じです。 HEADリクエストに応答して、HTTPヘッダに含まれるメタ情報は、GET要求に応答して送信された情報と同一であるべきです。この方法は、エンティティボディ自体を転送することなく要求によって暗示エンティティに関するメタ情報を取得するために使用することができます。この方法は、多くの場合、妥当性、アクセシビリティ、および最近の変更のためのハイパーテキストリンクをテストするために使用されています。"
    },
    {
      "indent": 3,
      "text": "The response to a HEAD request MAY be cacheable in the sense that the information contained in the response MAY be used to update a previously cached entity from that resource. If the new field values indicate that the cached entity differs from the current entity (as would be indicated by a change in Content-Length, Content-MD5, ETag or Last-Modified), then the cache MUST treat the cache entry as stale.",
      "ja": "HEAD要求に対する応答は、応答に含まれる情報は、そのリソースから、以前にキャッシュされたエンティティを更新するために使用され得るという意味でキャッシュ可能であるかもしれ。新しいフィールド値がキャッシュされたエンティティが現在のエンティティ（コンテンツ長の変化によって示されることになるよう、コンテンツ-MD5、ETagのかのLast-Modified）とは異なることを示している場合は、キャッシュが古いとキャッシュエントリを扱わなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.5 POST",
      "section_title": true,
      "ja": "9.5 POST"
    },
    {
      "indent": 3,
      "text": "The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line. POST is designed to allow a uniform method to cover the following functions:",
      "ja": "POSTメソッドは、オリジンサーバがリクエストライン中のRequest-URIによって識別されるリソースの新しい従属として、リクエストに囲まれたエンティティを受け入れることを要求するために使用されます。 POSTは、以下の機能をカバーする均一な方法を可能にするように設計されています。"
    },
    {
      "indent": 6,
      "text": "- Annotation of existing resources;",
      "ja": " - 既存のリソースの注釈。"
    },
    {
      "indent": 6,
      "text": "- Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;",
      "ja": " - 掲示板、ニュースグループ、メーリングリスト、または物品の類似のグループにメッセージを投稿。"
    },
    {
      "indent": 6,
      "text": "- Providing a block of data, such as the result of submitting a form, to a data-handling process;",
      "ja": " - そのようなデータ処理プロセスに、フォームを送信した結果として、データのブロックを提供するステップと"
    },
    {
      "indent": 6,
      "text": "- Extending a database through an append operation.",
      "ja": " - 追加操作を介してデータベースを拡張します。"
    },
    {
      "indent": 3,
      "text": "The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI. The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database.",
      "ja": "POSTメソッドによって実行される実際の機能はサーバによって決定され、通常のRequest-URIに依存しています。掲載実体がファイルがそれを含むディレクトリに従属するのと同じ方法で、そのURIに従属する、ニュース記事は、それが掲載されているニュースグループに従属し、またはレコードがデータベースに従属します。"
    },
    {
      "indent": 3,
      "text": "The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.",
      "ja": "POSTメソッドによって実行されるアクションは、URIで識別できるリソースにつながるしない場合があります。この場合には、200（OK）または204（いいえコンテンツ）のいずれかが応答結果を記述するエンティティが含まれているか否かに応じて、適切な応答状態です。"
    },
    {
      "indent": 3,
      "text": "If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header (see section 14.30).",
      "ja": "リソースがオリジンサーバ上に作成されている場合、応答は201（作成される）であると（セクション14.30を参照）要求のステータスを説明し、新たなリソースを指すエンティティ、およびLocationヘッダを含むべきです。"
    },
    {
      "indent": 3,
      "text": "Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields. However, the 303 (See Other) response can be used to direct the user agent to retrieve a cacheable resource.",
      "ja": "応答が適切なキャッシュ・コントロールを含むまたはヘッダーフィールドを有効期限がない限り、このメソッドへの応答は、キャッシュ可能ではありません。しかし、303（参照その他）レスポンスはキャッシュ可能なリソースを取得するためにユーザーエージェントを指示するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "POST requests MUST obey the message transmission requirements set out in section 8.2.",
      "ja": "POSTリクエストは、セクション8.2に記載されたメッセージの伝送要件に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "See section 15.1.3 for security considerations.",
      "ja": "セキュリティ上の考慮事項についてはセクション15.1.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.6 PUT",
      "section_title": true,
      "ja": "9.6 PUT"
    },
    {
      "indent": 3,
      "text": "The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response. If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request. If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem. The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.",
      "ja": "PUTメソッドは、囲まれたエンティティが供給されるのRequest-URIの下に格納されることを要求します。リクエストURIがすでに既存のリソースを参照する場合、囲まれたエンティティはオリジンサーバ上に存在する一方の変更バージョンとして考慮されるべきです。リクエスト-URIが既存のリソースを指していない、とURIが要求するユーザエージェントによって新しいリソースとして定義されることが可能であるとした場合、オリジンサーバはそのURIを持つリソースを作成することができます。新しいリソースが作成された場合、オリジンサーバは201（作成された）応答を介してユーザエージェントを通知しなければなりません。既存のリソースは、200（OK）または204のいずれかが変更された場合（NOコンテンツ）応答コードは、要求が正常に完了したことを示すために送信されるべきではありません。リソースが作成されたかのRequest-URIを変更することができなかった場合は、適切なエラー応答は、問題の性質を反映している与えられるべきです。エンティティの受信者は、それが理解したり実装し、このような場合には501（未実装）応答を返さなければなりませんしませんどんなのContent *（例えばコンテンツレンジ）ヘッダを無視してはいけません。"
    },
    {
      "indent": 3,
      "text": "If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable.",
      "ja": "要求がキャッシュを通過し、要求URIが一つ以上の現在キャッシュされたエンティティを識別した場合、それらのエントリが古くなったとして扱われるべきです。このメソッドのレスポンスはキャッシュ可能ではありません。"
    },
    {
      "indent": 3,
      "text": "The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource. If the server desires that the request be applied to a different URI, it MUST send a 301 (Moved Permanently) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.",
      "ja": "POST及びPUT要求との間の根本的な違いは、リクエストURIの別の意味に反映されます。 POSTリクエストにおけるURIは同封の実体を処理するリソースを識別する。そのリソースは、データ受付処理、いくつかの他のプロトコル、または注釈を受け入れる別のエンティティへのゲートウェイであるかもしれません。これとは対照的に、PUT要求におけるURIは、要求に囲まれたエンティティを識別する - ユーザエージェントは、URIが意図されているものを知っていると、サーバは、いくつかの他のリソースへの要求を適用することを試みてはいけません。サーバが要求を異なるURIに適用されることを望む場合、それは、301（恒久的に移動）応答を送信しなければなりません。ユーザエージェントはその要求をリダイレクトするかどうかについて、独自の意思決定を行うことができます。"
    },
    {
      "indent": 3,
      "text": "A single resource MAY be identified by many different URIs. For example, an article might have a URI for identifying \"the current version\" which is separate from the URI identifying each particular version. In this case, a PUT request on a general URI might result in several other URIs being defined by the origin server.",
      "ja": "単一のリソースは、さまざまなURIによって識別することができます。例えば、物品は、それぞれの特定のバージョンを識別するURIから分離されている「現在のバージョン」を識別するためのURIを持っているかもしれません。この場合、一般的なURIにPUTリクエストはオリジンサーバによって定義されている他のいくつかのURIになる可能性があります。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 does not define how a PUT method affects the state of an origin server.",
      "ja": "HTTP / 1.1は、PUTメソッドがオリジンサーバの状態をどのように影響するかを定義していません。"
    },
    {
      "indent": 3,
      "text": "PUT requests MUST obey the message transmission requirements set out in section 8.2.",
      "ja": "PUTリクエストは、セクション8.2に記載されたメッセージの伝送要件に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise specified for a particular entity-header, the entity-headers in the PUT request SHOULD be applied to the resource created or modified by the PUT.",
      "ja": "そうでなければ特定のエンティティヘッダに指定されない限り、PUT要求内のエンティティヘッダはPUTによって作成または変更されたリソースに適用すべきです。"
    },
    {
      "indent": 0,
      "text": "9.7 DELETE",
      "section_title": true,
      "ja": "9.7 DELETE"
    },
    {
      "indent": 3,
      "text": "The DELETE method requests that the origin server delete the resource identified by the Request-URI. This method MAY be overridden by human intervention (or other means) on the origin server. The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully. However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location.",
      "ja": "DELETEメソッドは、オリジンサーバがRequest-URIによって識別されるリソースを削除するよう要求します。このメソッドは、オリジンサーバ上の人間の介入（または他の手段）によって上書きされることがあります。クライアントは、オリジンサーバから返されたステータスコードはアクションが正常に完了したことを示していても、操作が行われていることを保証するものではありません。しかし、サーバが応答が与えられた時点で、それはリソースを削除したりアクセスできない場所に移動する予定で、しない限り、成功を示すべきではありません。"
    },
    {
      "indent": 3,
      "text": "A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content) if the action has been enacted but the response does not include an entity.",
      "ja": "成功した応答は、応答のステータスを記述するエンティティを含む場合、アクションが制定されている場合、202（承認）アクションがまだ制定ないれていない場合、または204（コンテンツなし）200（OK）であるべきであるが、応答が含まれていませんエンティティ。"
    },
    {
      "indent": 3,
      "text": "If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable.",
      "ja": "要求がキャッシュを通過し、要求URIが一つ以上の現在キャッシュされたエンティティを識別した場合、それらのエントリが古くなったとして扱われるべきです。このメソッドのレスポンスはキャッシュ可能ではありません。"
    },
    {
      "indent": 0,
      "text": "9.8 TRACE",
      "section_title": true,
      "ja": "9.8 TRACE"
    },
    {
      "indent": 3,
      "text": "The TRACE method is used to invoke a remote, application-layer loop-back of the request message. The final recipient of the request SHOULD reflect the message received back to the client as the entity-body of a 200 (OK) response. The final recipient is either the origin server or the first proxy or gateway to receive a Max-Forwards value of zero (0) in the request (see section 14.31). A TRACE request MUST NOT include an entity.",
      "ja": "TRACEメソッドは、要求メッセージのリモート、アプリケーション層のループバックを呼び出すために使用されます。リクエストの最終的な受信者は、200（OK）応答のエンティティボディとしてクライアントに受信したメッセージを反映すべきです。最終受信者は、オリジンサーバまたは要求にゼロの最大転送した値を受信する最初のプロキシまたはゲートウェイ（0）（セクション14.31を参照）のいずれかです。 TRACE要求は実体を含んではいけません。"
    },
    {
      "indent": 3,
      "text": "TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. The value of the Via header field (section 14.45) is of particular interest, since it acts as a trace of the request chain. Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.",
      "ja": "TRACEは、クライアントが要求チェーンの他方の端部に受信されているかを確認し、テストまたは診断情報のためにそのデータを使用することを可能にします。それは、要求チェーンのトレースとして作用するためのViaヘッダフィールド（セクション14.45）の値は、特に重要です。最大Forwardsヘッダーフィールドの使用は、クライアントが無限ループにメッセージを転送するプロキシの鎖を試験するために有用である要求鎖の長さを制限することを可能にします。"
    },
    {
      "indent": 3,
      "text": "If the request is valid, the response SHOULD contain the entire request message in the entity-body, with a Content-Type of \"message/http\". Responses to this method MUST NOT be cached.",
      "ja": "要求が有効である場合は、応答が「メッセージ/ HTTP」のコンテンツタイプと、エンティティボディ全体要求メッセージを含むべきです。このメソッドへの応答はキャッシュされてはなりません。"
    },
    {
      "indent": 0,
      "text": "9.9 CONNECT",
      "section_title": true,
      "ja": "9.9 CONNECT"
    },
    {
      "indent": 3,
      "text": "This specification reserves the method name CONNECT for use with a proxy that can dynamically switch to being a tunnel (e.g. SSL tunneling [44]).",
      "ja": "この仕様は、動的トンネル（例えば、SSLトンネリング[44]）であることに切り替えることができ、プロキシで使用するためのメソッド名CONNECTを留保します。"
    },
    {
      "indent": 0,
      "text": "10 Status Code Definitions",
      "ja": "10のステータスコードの定義"
    },
    {
      "indent": 3,
      "text": "Each Status-Code is described below, including a description of which method(s) it can follow and any metainformation required in the response.",
      "ja": "各ステータスコードは、メソッド（複数可）が従うことができると応答して必要なメタ情報の記述を含む、以下に説明します。"
    },
    {
      "indent": 0,
      "text": "10.1 Informational 1xx",
      "section_title": true,
      "ja": "10.1情報の1xx"
    },
    {
      "indent": 3,
      "text": "This class of status code indicates a provisional response, consisting only of the Status-Line and optional headers, and is terminated by an empty line. There are no required headers for this class of status code. Since HTTP/1.0 did not define any 1xx status codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client except under experimental conditions.",
      "ja": "ステータスコードのこのクラスは、ステータスラインとオプションヘッダから成る、暫定的な応答を示し、空行で終了します。ステータスコードのこのクラスには、必要なヘッダはありません。 HTTP / 1.0はどんなの1xxステータスコードを定義していませんでしたので、サーバーは、実験条件の下で除き、HTTP / 1.0クライアントへの1xxレスポンスを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "A client MUST be prepared to accept one or more 1xx status responses prior to a regular response, even if the client does not expect a 100 (Continue) status message. Unexpected 1xx status responses MAY be ignored by a user agent.",
      "ja": "クライアントは、クライアントが100（続行）ステータスメッセージを期待していない場合でも、定期的に応答する前に、一の以上の1xx状態応答を受け入れるように準備しなければなりません。予期しないの1xxステータス応答は、ユーザエージェントによって無視されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Proxies MUST forward 1xx responses, unless the connection between the proxy and its client has been closed, or unless the proxy itself requested the generation of the 1xx response. (For example, if a proxy adds a \"Expect: 100-continue\" field when it forwards a request, then it need not forward the corresponding 100 (Continue) response(s).)",
      "ja": "プロキシとそのクライアント間の接続が閉じられた場合を除き、またはプロキシ自体がの1xx応答の生成を要求した場合を除きます。プロキシは、の1xx応答を転送しなければなりません（プロキシが追加した場合たとえば、「期待：100-続ける」フィールドには、要求を転送するとき、それは、対応する100（続行）応答（複数可）を転送する必要はありません。）"
    },
    {
      "indent": 0,
      "text": "10.1.1 100 Continue",
      "section_title": true,
      "ja": "10.1.1 100は続行します"
    },
    {
      "indent": 3,
      "text": "The client SHOULD continue with its request. This interim response is used to inform the client that the initial part of the request has been received and has not yet been rejected by the server. The client SHOULD continue by sending the remainder of the request or, if the request has already been completed, ignore this response. The server MUST send a final response after the request has been completed. See section 8.2.3 for detailed discussion of the use and handling of this status code.",
      "ja": "クライアントは要求を継続する必要があり。この暫定応答は、要求の最初の部分が受信されていて、まだサーバーによって拒否されていないクライアントに通知するために使用されています。クライアントは、要求の残りを送信することにより続行するか、要求がすでに完了している場合は、この応答を無視します。要求が完了した後、サーバーは最終的な応答を送らなければなりません。このステータスコードの使用や取扱いの詳細な議論のためのセクション8.2.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.1.2 101 Switching Protocols",
      "section_title": true,
      "ja": "10.1.2 101スイッチングプロトコル"
    },
    {
      "indent": 3,
      "text": "The server understands and is willing to comply with the client's request, via the Upgrade message header field (section 14.42), for a change in the application protocol being used on this connection. The server will switch protocols to those defined by the response's Upgrade header field immediately after the empty line which terminates the 101 response.",
      "ja": "サーバは理解し、この接続で使用されているアプリケーション・プロトコルの変化のために、アップグレードメッセージヘッダフィールド（セクション14.42）を介して、クライアントの要求を遵守する意志があります。サーバーは、すぐに101レスポンスを終了空行の後にレスポンスのUpgradeヘッダフィールドによって定義されたものにプロトコルを切り替えます。"
    },
    {
      "indent": 3,
      "text": "The protocol SHOULD be switched only when it is advantageous to do so. For example, switching to a newer version of HTTP is advantageous over older versions, and switching to a real-time, synchronous protocol might be advantageous when delivering resources that use such features.",
      "ja": "そうすることが有利である場合にのみ、プロトコルは、切り替えるべき。例えば、HTTPの新しいバージョンへの切り替えは、旧バージョンよりも有利であり、そのような機能を使用するリソースを配信する際にリアルタイムに切り替えることは、同期プロトコルが有利かもしれません。"
    },
    {
      "indent": 0,
      "text": "10.2 Successful 2xx",
      "section_title": true,
      "ja": "10.2成功2XX"
    },
    {
      "indent": 3,
      "text": "This class of status code indicates that the client's request was successfully received, understood, and accepted.",
      "ja": "このクラスのステータスコードは、クライアントの要求が正常に受信されたことを示して理解し、受け入れられました。"
    },
    {
      "indent": 0,
      "text": "10.2.1 200 OK",
      "section_title": true,
      "ja": "10.2.1 200 OK"
    },
    {
      "indent": 3,
      "text": "The request has succeeded. The information returned with the response is dependent on the method used in the request, for example:",
      "ja": "リクエストが成功しました。応答で返された情報は、例えば、要求に使用される方法に依存しています。"
    },
    {
      "indent": 3,
      "text": "GET an entity corresponding to the requested resource is sent in the response;",
      "ja": "応答して送信される要求されたリソースに対応するエンティティを取得します。"
    },
    {
      "indent": 3,
      "text": "HEAD the entity-header fields corresponding to the requested resource are sent in the response without any message-body;",
      "ja": "要求されたリソースに対応するエンティティヘッダフィールドは、任意のメッセージボディなしに応答して送信されているヘッド。"
    },
    {
      "indent": 3,
      "text": "POST an entity describing or containing the result of the action;",
      "ja": "記述またはアクションの結果を含むエンティティをPOST。"
    },
    {
      "indent": 3,
      "text": "TRACE an entity containing the request message as received by the end server.",
      "ja": "エンド・サーバによって受信されるよう要求メッセージを含むエンティティをトレース。"
    },
    {
      "indent": 0,
      "text": "10.2.2 201 Created",
      "section_title": true,
      "ja": "10.2.2 201初出"
    },
    {
      "indent": 3,
      "text": "The request has been fulfilled and resulted in a new resource being created. The newly created resource can be referenced by the URI(s) returned in the entity of the response, with the most specific URI for the resource given by a Location header field. The response SHOULD include an entity containing a list of resource characteristics and location(s) from which the user or user agent can choose the one most appropriate. The entity format is specified by the media type given in the Content-Type header field. The origin server MUST create the resource before returning the 201 status code. If the action cannot be carried out immediately, the server SHOULD respond with 202 (Accepted) response instead.",
      "ja": "要求が満たされ、新しいリソースが作成されているが生じてきました。新しく作成されたリソースは、URI（S）で参照することができるLocationヘッダフィールドで指定されたリソースのための最も特異的なURIと、応答のエンティティに返されます。応答は、ユーザーまたはユーザーエージェントが最も適切なものを選択することができ、そこからリソース特性および位置（単数または複数）のリストを含むエンティティを含むべきです。エンティティフォーマットはContent-Typeヘッダフィールドで指定されたメディアタイプによって指定されます。オリジンサーバは201のステータスコードを返す前にリソースを作成する必要があります。アクションがすぐに実行できない場合、サーバは代わりに202（受理）応答で応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "A 201 response MAY contain an ETag response header field indicating the current value of the entity tag for the requested variant just created, see section 14.19.",
      "ja": "201応答は、セクション14.19を参照して、先ほど作成した要求されたバリアントのエンティティタグの現在の値を示すのETagレスポンスヘッダフィールドを含むかもしれません。"
    },
    {
      "indent": 0,
      "text": "10.2.3 202 Accepted",
      "section_title": true,
      "ja": "10.2.3 202受理"
    },
    {
      "indent": 3,
      "text": "The request has been accepted for processing, but the processing has not been completed. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place. There is no facility for re-sending a status code from an asynchronous operation such as this.",
      "ja": "リクエストが処理のために受け入れられているが、処理は完了していません。処理が実際に行われるとき、それは禁止されるかもしれないよう要求がまたは最終的には、作用されない場合があります。このような非同期動作からステータスコードを再送信するための機能はありません。"
    },
    {
      "indent": 3,
      "text": "The 202 response is intentionally non-committal. Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the server persist until the process is completed. The entity returned with this response SHOULD include an indication of the request's current status and either a pointer to a status monitor or some estimate of when the user can expect the request to be fulfilled.",
      "ja": "202応答は、意図的に非コミットです。その目的は、サーバプロセスが完了するまで、サーバへのユーザエージェントの接続が存続することを必要とせず、他のプロセス（だけ1日1回実行され、おそらくバッチ指向プロセス）の要求を受け入れることを可能にすることです。エンティティは、リクエストの現在のステータスの表示といずれかの状態モニタへのポインタか、ユーザーが要求が満たされることを期待することができたときにいくつかの推定値を含むべきである。この応答で返さ。"
    },
    {
      "indent": 0,
      "text": "10.2.4 203 Non-Authoritative Information",
      "section_title": true,
      "ja": "10.2.4 203非信頼できる情報"
    },
    {
      "indent": 3,
      "text": "The returned metainformation in the entity-header is not the definitive set as available from the origin server, but is gathered from a local or a third-party copy. The set presented MAY be a subset or superset of the original version. For example, including local annotation information about the resource might result in a superset of the metainformation known by the origin server. Use of this response code is not required and is only appropriate when the response would otherwise be 200 (OK).",
      "ja": "エンティティヘッダーに戻されるメタ情報は、オリジンサーバから入手可能な最終的なセットではなく、ローカルまたはサードパーティコピーから集められています。提示セットは元のバージョンのサブセットまたはスーパーセットである場合があります。たとえば、リソースについてなど、地元の注釈情報は、オリジンサーバによって知られているメタ情報のスーパーセットになる可能性があります。この応答コードの使用が必要と応答が他の200（OK）であろう場合にのみ適切であるれていません。"
    },
    {
      "indent": 0,
      "text": "10.2.5 204 No Content",
      "section_title": true,
      "ja": "10.2.5 204コンテンツなし"
    },
    {
      "indent": 3,
      "text": "The server has fulfilled the request but does not need to return an entity-body, and might want to return updated metainformation. The response MAY include new or updated metainformation in the form of entity-headers, which if present SHOULD be associated with the requested variant.",
      "ja": "サーバーは要求を満たしていますが、エンティティボディを返す必要はありません。また、更新されたメタ情報を返すようにしたいかもしれません。応答が存在する場合に要求された変異体と関連付けられるべきエンティティヘッダの形で新しいまたは更新されたメタ情報を含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "If the client is a user agent, it SHOULD NOT change its document view from that which caused the request to be sent. This response is primarily intended to allow input for actions to take place without causing a change to the user agent's active document view, although any new or updated metainformation SHOULD be applied to the document currently in the user agent's active view.",
      "ja": "クライアントはユーザエージェントである場合、それは、要求が送信される原因となったことから、そのドキュメントのビューを変更しないでください。この応答は、主に、任意の新しいまたは更新されたメタ情報は、ユーザエージェントのアクティブなビューで、現在の文書に適用されるべきであるが、ユーザエージェントのアクティブドキュメントビューに変更を生じさせることなく、場所を取るべきアクションのための入力を可能にすることを意図しています。"
    },
    {
      "indent": 3,
      "text": "The 204 response MUST NOT include a message-body, and thus is always terminated by the first empty line after the header fields.",
      "ja": "204応答は、メッセージボディを含めることはできませんので、常にヘッダフィールドの後の最初の空行で終了します。"
    },
    {
      "indent": 0,
      "text": "10.2.6 205 Reset Content",
      "section_title": true,
      "ja": "10.2.6 205リセットコンテンツ"
    },
    {
      "indent": 3,
      "text": "The server has fulfilled the request and the user agent SHOULD reset the document view which caused the request to be sent. This response is primarily intended to allow input for actions to take place via user input, followed by a clearing of the form in which the input is given so that the user can easily initiate another input action. The response MUST NOT include an entity.",
      "ja": "サーバーは要求を満たしており、ユーザーエージェントは、要求の送信元となったドキュメントビューをリセットする必要があります。この応答は、主にアクションをユーザが容易に別の入力動作を開始できるように、入力が与えられた形のクリアに続くユーザ入力を介して行われるようにするための入力を可能にするように意図されています。レスポンスはエンティティを含んではいけません。"
    },
    {
      "indent": 0,
      "text": "10.2.7 206 Partial Content",
      "section_title": true,
      "ja": "10.2.7 206部分コンテンツ"
    },
    {
      "indent": 3,
      "text": "The server has fulfilled the partial GET request for the resource. The request MUST have included a Range header field (section 14.35) indicating the desired range, and MAY have included an If-Range header field (section 14.27) to make the request conditional.",
      "ja": "サーバはリソースに対する部分的GET要求を満たしています。要求は、所望の範囲を示すRangeヘッダフィールド（セクション14.35）を含んでいなければなりません、そして要求を条件付きにする場合-Rangeヘッダフィールド（セクション14.27）が含まれている可能性があります。"
    },
    {
      "indent": 3,
      "text": "The response MUST include the following header fields:",
      "ja": "応答は、次ヘッダフィールドを含める必要があります。"
    },
    {
      "indent": 6,
      "text": "- Either a Content-Range header field (section 14.16) indicating the range included with this response, or a multipart/byteranges Content-Type including Content-Range fields for each part. If a Content-Length header field is present in the response, its value MUST match the actual number of OCTETs transmitted in the message-body.",
      "ja": " - 各部分のコンテンツレンジフィールドを含むこの応答、またはマルチパート/ byterangesのContent-Typeに含ま範囲を示すいずれかのContent-Rangeヘッダフィールド（セクション14.16）。 Content-Lengthヘッダフィールドは、応答中に存在する場合、その値は、メッセージ本文に送信されたオクテットの実際の数と一致しなければなりません。"
    },
    {
      "indent": 6,
      "text": "- Date",
      "ja": " - 日"
    },
    {
      "indent": 6,
      "text": "- ETag and/or Content-Location, if the header would have been sent in a 200 response to the same request",
      "ja": " -  Etag及び/又はコンテンツの場所、ヘッダが同じリクエストに対して200応答して送信されたかどう"
    },
    {
      "indent": 6,
      "text": "- Expires, Cache-Control, and/or Vary, if the field-value might differ from that sent in any previous response for the same variant",
      "ja": " - は、のCache-Controlの有効期限、および/またはフィールド値が同じバリアントに対する以前の応答で送信されたものと異なる可能性がある場合、ヴァリ"
    },
    {
      "indent": 3,
      "text": "If the 206 response is the result of an If-Range request that used a strong cache validator (see section 13.3.3), the response SHOULD NOT include other entity-headers. If the response is the result of an If-Range request that used a weak validator, the response MUST NOT include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers. Otherwise, the response MUST include all of the entity-headers that would have been returned with a 200 (OK) response to the same request.",
      "ja": "206応答は、強いキャッシュバリデータを使用した場合、Range要求の結果である場合には（セクション13.3.3を参照）、応答は、他のエンティティヘッダを含むべきではありません。応答が弱いバリデータを使用した場合、Range要求の結果である場合、応答は、他のエンティティヘッダを含めることはできません。これは、キャッシュされたエンティティボディと更新ヘッダーの間の不整合を防ぐことができます。そうでなければ、応答は同じ要求に対して200（OK）応答で返されたであろうエンティティヘッダのすべてを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "A cache MUST NOT combine a 206 response with other previously cached content if the ETag or Last-Modified headers do not match exactly, see 13.5.4.",
      "ja": "ETagまたはLast-Modifiedのヘッダが正確に一致しない場合、キャッシュは、他の以前にキャッシュされたコンテンツと206応答を組み合わせてはならない、13.5.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "A cache that does not support the Range and Content-Range headers MUST NOT cache 206 (Partial) responses.",
      "ja": "レンジとContent-レンジヘッダをサポートしていないキャッシュは206（部分的な）レスポンスをキャッシュしてはなりません。"
    },
    {
      "indent": 0,
      "text": "10.3 Redirection 3xx",
      "section_title": true,
      "ja": "10.3リダイレクション3XX"
    },
    {
      "indent": 3,
      "text": "This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request. The action required MAY be carried out by the user agent without interaction with the user if and only if the method used in the second request is GET or HEAD. A client SHOULD detect infinite redirection loops, since such loops generate network traffic for each redirection.",
      "ja": "ステータスコードのこのクラスは、さらにアクションが要求を満たすためにユーザエージェントによってとられる必要があることを示しています。そして第2の要求に使用される方法である場合にのみ、GETまたはHEAD場合に必要なアクションは、ユーザとの対話なしでユーザエージェントによって行うことができます。このようなループは、各リダイレクト用のネットワークトラフィックを生成するので、クライアントは、無限のリダイレクトループを検出する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: previous versions of this specification recommended a maximum of five redirections. Content developers should be aware that there might be clients that implement such a fixed limitation.",
      "ja": "注意：この仕様の以前のバージョンでは、5つのリダイレクトの最大推奨。コンテンツ開発者は、このような一定の制限を実装するクライアントがあるかもしれないことに注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.1 300 Multiple Choices",
      "section_title": true,
      "ja": "10.3.1 300複数の選択肢"
    },
    {
      "indent": 3,
      "text": "The requested resource corresponds to any one of a set of representations, each with its own specific location, and agent-driven negotiation information (section 12) is being provided so that the user (or user agent) can select a preferred representation and redirect its request to that location.",
      "ja": "ユーザ（又はユーザエージェント）が好ましい表現を選択し、リダイレクトすることができるように要求されたリソースは、それ自身の特定の位置、及びエージェント駆動型ネゴシエーション情報（セクション12）とのそれぞれが提供されている表現の集合のいずれかに対応し、そのその場所への要求。"
    },
    {
      "indent": 3,
      "text": "Unless it was a HEAD request, the response SHOULD include an entity containing a list of resource characteristics and location(s) from which the user or user agent can choose the one most appropriate. The entity format is specified by the media type given in the Content-Type header field. Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed automatically. However, this specification does not define any standard for such automatic selection.",
      "ja": "それがHEAD要求でない限り、反応は、ユーザーまたはユーザーエージェントが最も適切なものを選択することができ、そこからリソース特性および位置（単数または複数）のリストを含むエンティティを含むべきです。エンティティフォーマットはContent-Typeヘッダフィールドで指定されたメディアタイプによって指定されます。フォーマットやユーザエージェントの能力に応じて、最も適切な選択の選択が自動的に実行することができます。しかし、この仕様書は、そのような自動選択のための任意の標準を定義していません。"
    },
    {
      "indent": 3,
      "text": "If the server has a preferred choice of representation, it SHOULD include the specific URI for that representation in the Location field; user agents MAY use the Location field value for automatic redirection. This response is cacheable unless indicated otherwise.",
      "ja": "サーバが表現の好ましい選択肢を持っている場合、それはLocationフィールドでその表現のための特定のURIを含むべきです。ユーザエージェントは、自動リダイレクトのための場所]フィールド値を使用するかもしれません。特に指示がない限り、このレスポンスはキャッシュ可能です。"
    },
    {
      "indent": 0,
      "text": "10.3.2 301 Moved Permanently",
      "section_title": true,
      "ja": "10.3.2 301が永久的に移動"
    },
    {
      "indent": 3,
      "text": "The requested resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs. Clients with link editing capabilities ought to automatically re-link references to the Request-URI to one or more of the new references returned by the server, where possible. This response is cacheable unless indicated otherwise.",
      "ja": "要求されたリソースは新しい恒久的なURIが割り当てられており、このリソースへの将来の参照が返されたURIのいずれかを使用すべきです。リンク編集機能を持つクライアントは、可能であれば、サーバによって返された新しい参照の一つ以上へのRequest-URIへと自動的に再リンクが参照するべきです。特に指示がない限り、このレスポンスはキャッシュ可能です。"
    },
    {
      "indent": 3,
      "text": "The new permanent URI SHOULD be given by the Location field in the response. Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).",
      "ja": "新しい恒久的なURIは、応答でLocationフィールドによって与えられるべきです。リクエストメソッドがHEADだった場合を除き、レスポンスのエンティティは新しいURIへのハイパーリンクで短いハイパーテキストのメモを含むべきです。"
    },
    {
      "indent": 3,
      "text": "If the 301 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.",
      "ja": "301のステータスコードがGETやHEAD以外の要求に応答して受信された場合、それをユーザが確認できない限り、この要求が発行された条件を変更する可能性があるため、ユーザエージェントは自動的に、要求をリダイレクトしてはなりません。"
    },
    {
      "indent": 6,
      "text": "Note: When automatically redirecting a POST request after receiving a 301 status code, some existing HTTP/1.0 user agents will erroneously change it into a GET request.",
      "ja": "注意：自動的に301のステータスコードを受信した後、POSTリクエストをリダイレクトすると、いくつかの既存のHTTP / 1.0ユーザエージェントが誤ってGETリクエストにそれを変更します。"
    },
    {
      "indent": 0,
      "text": "10.3.3 302 Found",
      "section_title": true,
      "ja": "10.3.3 302が見つかりました"
    },
    {
      "indent": 3,
      "text": "The requested resource resides temporarily under a different URI. Since the redirection might be altered on occasion, the client SHOULD continue to use the Request-URI for future requests. This response is only cacheable if indicated by a Cache-Control or Expires header field.",
      "ja": "要求されたリソースが一時的に別のURIに存在します。リダイレクトが機会に変更される可能性があるため、クライアントは将来のリクエストのためのRequest-URIを使い続けるべきです。この応答は、キャッシュコントロールによって示される場合にのみキャッシュ可能であるか、Expiresヘッダーフィールド。"
    },
    {
      "indent": 3,
      "text": "The temporary URI SHOULD be given by the Location field in the response. Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).",
      "ja": "一時的なURIは、レスポンス内のLocationフィールドによって与えられるべきです。リクエストメソッドがHEADだった場合を除き、レスポンスのエンティティは新しいURIへのハイパーリンクで短いハイパーテキストのメモを含むべきです。"
    },
    {
      "indent": 3,
      "text": "If the 302 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.",
      "ja": "302のステータスコードがGETやHEAD以外の要求に応答して受信された場合、それをユーザが確認できない限り、この要求が発行された条件を変更する可能性があるため、ユーザエージェントは自動的に、要求をリダイレクトしてはなりません。"
    },
    {
      "indent": 6,
      "text": "Note: RFC 1945 and RFC 2068 specify that the client is not allowed to change the method on the redirected request. However, most existing user agent implementations treat 302 as if it were a 303 response, performing a GET on the Location field-value regardless of the original request method. The status codes 303 and 307 have been added for servers that wish to make unambiguously clear which kind of reaction is expected of the client.",
      "ja": "注意：RFC 1945およびRFC 2068は、クライアントがリダイレクトされたリクエストのメソッドを変更することが許可されていないことを指定します。それは関係なく、元の要求メソッドのLocationフィールド値にGETを行う、303応答であるかのようしかし、ほとんどの既存のユーザエージェントの実装302を扱います。ステータスコード303および307は、クライアントの期待されている反応の種類を明確に明らかにすることを希望するサーバーに対して追加されました。"
    },
    {
      "indent": 0,
      "text": "10.3.4 303 See Other",
      "section_title": true,
      "ja": "10.3.4 303を参照してくださいその他"
    },
    {
      "indent": 3,
      "text": "The response to the request can be found under a different URI and SHOULD be retrieved using a GET method on that resource. This method exists primarily to allow the output of a POST-activated script to redirect the user agent to a selected resource. The new URI is not a substitute reference for the originally requested resource. The 303 response MUST NOT be cached, but the response to the second (redirected) request might be cacheable.",
      "ja": "要求に対する応答が、異なるURIの下に見つけることができ、そのリソース上のGETメソッドを使用して取得されるべきです。この方法は、選択されたリソースへのユーザエージェントをリダイレクトするPOST活性化スクリプトの出力を可能にするために主に存在します。新しいURIは、最初に要求されたリソースの代わりの参照ではありません。 303レスポンスはキャッシュされてはならないが、2番目の（リダイレクト）要求に対する応答がキャッシュ可能であるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The different URI SHOULD be given by the Location field in the response. Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).",
      "ja": "別のURIは、レスポンス内のLocationフィールドによって与えられるべきです。リクエストメソッドがHEADだった場合を除き、レスポンスのエンティティは新しいURIへのハイパーリンクで短いハイパーテキストのメモを含むべきです。"
    },
    {
      "indent": 6,
      "text": "Note: Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303.",
      "ja": "注：多くの事前HTTP / 1.1ユーザエージェントは303のステータスを理解していません。そのようなクライアントとの相互運用性が問題である場合303のためにここに記載したように、ほとんどのユーザエージェントは、302応答に反応するので、302のステータスコードが、代わりに使用することができます。"
    },
    {
      "indent": 0,
      "text": "10.3.5 304 Not Modified",
      "section_title": true,
      "ja": "10.3.5 304は変更されません"
    },
    {
      "indent": 3,
      "text": "If the client has performed a conditional GET request and access is allowed, but the document has not been modified, the server SHOULD respond with this status code. The 304 response MUST NOT contain a message-body, and thus is always terminated by the first empty line after the header fields.",
      "ja": "クライアントが条件付きGETリクエストを実行し、アクセスが許可されていますが、文書が変更されていない場合、サーバーはこのステータスコードで応答する必要があります。 304応答は、メッセージ本体を含んではならないので、常にヘッダフィールドの後の最初の空行で終了します。"
    },
    {
      "indent": 3,
      "text": "The response MUST include the following header fields:",
      "ja": "応答は、次ヘッダフィールドを含める必要があります。"
    },
    {
      "indent": 6,
      "text": "- Date, unless its omission is required by section 14.18.1",
      "ja": " - 日付、その省略はセクション14.18.1で必要とされない限り、"
    },
    {
      "indent": 3,
      "text": "If a clockless origin server obeys these rules, and proxies and clients add their own Date to any response received without one (as already specified by [RFC 2068], section 14.19), caches will operate correctly.",
      "ja": "（すでに[RFC 2068]、セクション14.19で指定）クロックレスオリジンサーバは、これらの規則に従うと、プロキシとクライアントが1ずに受信したレスポンスに自分の日を追加した場合、キャッシュは正しく動作します。"
    },
    {
      "indent": 6,
      "text": "- ETag and/or Content-Location, if the header would have been sent in a 200 response to the same request",
      "ja": " -  Etag及び/又はコンテンツの場所、ヘッダが同じリクエストに対して200応答して送信されたかどう"
    },
    {
      "indent": 6,
      "text": "- Expires, Cache-Control, and/or Vary, if the field-value might differ from that sent in any previous response for the same variant",
      "ja": " - は、のCache-Controlの有効期限、および/またはフィールド値が同じバリアントに対する以前の応答で送信されたものと異なる可能性がある場合、ヴァリ"
    },
    {
      "indent": 3,
      "text": "If the conditional GET used a strong cache validator (see section 13.3.3), the response SHOULD NOT include other entity-headers. Otherwise (i.e., the conditional GET used a weak validator), the response MUST NOT include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers.",
      "ja": "条件付きGETが（セクション13.3.3を参照してください）強いキャッシュバリデータを使用した場合、レスポンスは他のエンティティヘッダを含めるべきではありません。そうでない場合（すなわち、条件付きGETが弱いバリデータを使用）、応答は、他のエンティティヘッダを含めることはできません。これは、キャッシュされたエンティティボディと更新ヘッダーの間の不整合を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "If a 304 response indicates an entity not currently cached, then the cache MUST disregard the response and repeat the request without the conditional.",
      "ja": "304レスポンスが現在キャッシュされていないエンティティを示している場合は、キャッシュはレスポンスを無視し、条件なしで要求を繰り返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If a cache uses a received 304 response to update a cache entry, the cache MUST update the entry to reflect any new field values given in the response.",
      "ja": "キャッシュは、キャッシュエントリを更新するために受信された304レスポンスを使用している場合、キャッシュはレスポンスで与えられた任意の新しいフィールド値を反映するためにエントリを更新する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.6 305 Use Proxy",
      "section_title": true,
      "ja": "10.3.6 305プロキシを使用"
    },
    {
      "indent": 3,
      "text": "The requested resource MUST be accessed through the proxy given by the Location field. The Location field gives the URI of the proxy. The recipient is expected to repeat this single request via the proxy. 305 responses MUST only be generated by origin servers.",
      "ja": "要求されたリソースはLocationフィールドによって与えられるプロキシ経由でアクセスする必要があります。 LocationフィールドはプロキシのURIを提供します。受信者は、プロキシを経由してこの単一の要求を繰り返すことが予想されます。 305個の応答が唯一のオリジンサーバによって生成されなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: RFC 2068 was not clear that 305 was intended to redirect a single request, and to be generated by origin servers only. Not observing these limitations has significant security consequences.",
      "ja": "注意：RFC 2068は、305が単一の要求をリダイレクトすることを意図していたことは明らかではなかった、とだけオリジンサーバによって生成されます。これらの制限を観察しないと、重大なセキュリティ上の影響があります。"
    },
    {
      "indent": 0,
      "text": "10.3.7 306 (Unused)",
      "section_title": true,
      "ja": "10.3.7 306（未使用）"
    },
    {
      "indent": 3,
      "text": "The 306 status code was used in a previous version of the specification, is no longer used, and the code is reserved.",
      "ja": "306のステータスコードは、もはや使用されている仕様の以前のバージョンで使用されなかった、そしてコードが予約されています。"
    },
    {
      "indent": 0,
      "text": "10.3.8 307 Temporary Redirect",
      "section_title": true,
      "ja": "10.3.8 307一時的なリダイレクト"
    },
    {
      "indent": 3,
      "text": "The requested resource resides temporarily under a different URI. Since the redirection MAY be altered on occasion, the client SHOULD continue to use the Request-URI for future requests. This response is only cacheable if indicated by a Cache-Control or Expires header field.",
      "ja": "要求されたリソースが一時的に別のURIに存在します。リダイレクトを機会に変えることができるので、クライアントは将来のリクエストのためのRequest-URIを使い続けるべきです。この応答は、キャッシュコントロールによって示される場合にのみキャッシュ可能であるか、Expiresヘッダーフィールド。"
    },
    {
      "indent": 3,
      "text": "The temporary URI SHOULD be given by the Location field in the response. Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s) , since many pre-HTTP/1.1 user agents do not understand the 307 status. Therefore, the note SHOULD contain the information necessary for a user to repeat the original request on the new URI.",
      "ja": "一時的なURIは、レスポンス内のLocationフィールドによって与えられるべきです。リクエストメソッドがHEADだった場合を除き、多くの事前HTTP / 1.1ユーザエージェントは307のステータスを理解していないことから、レスポンスのエンティティは、新しいURIへのハイパーリンクで短いハイパーテキストのメモを含むべきです。そのため、ノートは新しいURIに元の要求を繰り返すユーザーのために必要な情報を含むべきです。"
    },
    {
      "indent": 3,
      "text": "If the 307 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.",
      "ja": "307のステータスコードがGETやHEAD以外の要求に応答して受信された場合、それをユーザが確認できない限り、この要求が発行された条件を変更する可能性があるため、ユーザエージェントは自動的に、要求をリダイレクトしてはなりません。"
    },
    {
      "indent": 0,
      "text": "10.4 Client Error 4xx",
      "section_title": true,
      "ja": "10.4クライアントエラーの4xx"
    },
    {
      "indent": 3,
      "text": "The 4xx class of status code is intended for cases in which the client seems to have erred. Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition. These status codes are applicable to any request method. User agents SHOULD display any included entity to the user.",
      "ja": "ステータスコードの4xxのクラスは、クライアントが誤りを犯しているようだここで例を対象としています。 HEADリクエストに応答するとき以外は、サーバはエラー状況の説明を含むエンティティを含むべきである、それは一時的または永久的な状態であるかどうか。これらのステータスコードはどんなリクエストメソッドに適用されます。ユーザーエージェントは、ユーザーに任意の含まれたエンティティが表示されます。"
    },
    {
      "indent": 3,
      "text": "If the client is sending data, a server implementation using TCP SHOULD be careful to ensure that the client acknowledges receipt of the packet(s) containing the response, before the server closes the input connection. If the client continues sending data to the server after the close, the server's TCP stack will send a reset packet to the client, which may erase the client's unacknowledged input buffers before they can be read and interpreted by the HTTP application.",
      "ja": "クライアントがデータを送信している場合は、TCPを使用してサーバの実装では、サーバが入力接続を閉じる前に、クライアントは、応答を含むパケット（S）の受信を確認することを保証するために注意する必要があります。クライアントが終了後にデータをサーバーに送信し続けた場合は、サーバのTCPスタックは、彼らが読んで、HTTPアプリケーションによって解釈される前に、クライアントの未確認の入力バッファを消去する可能性がある、クライアントにリセットパケットを送信します。"
    },
    {
      "indent": 0,
      "text": "10.4.1 400 Bad Request",
      "section_title": true,
      "ja": "10.4.1 400不正な要求"
    },
    {
      "indent": 3,
      "text": "The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications.",
      "ja": "リクエストの文法が間違っているため、サーバで解釈することができませんでした。クライアントは修正して再度要求してください。"
    },
    {
      "indent": 0,
      "text": "10.4.2 401 Unauthorized",
      "section_title": true,
      "ja": "10.4.2 401権限"
    },
    {
      "indent": 3,
      "text": "The request requires user authentication. The response MUST include a WWW-Authenticate header field (section 14.47) containing a challenge applicable to the requested resource. The client MAY repeat the request with a suitable Authorization header field (section 14.8). If the request already included Authorization credentials, then the 401 response indicates that authorization has been refused for those credentials. If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user SHOULD be presented the entity that was given in the response, since that entity might include relevant diagnostic information. HTTP access authentication is explained in \"HTTP Authentication: Basic and Digest Access Authentication\" [43].",
      "ja": "要求は、ユーザの認証が必要です。応答は、要求されたリソースに適用可能なチャレンジを含むWWW-Authenticateヘッダフィールド（セクション14.47）を含まなければなりません。クライアントは、適切なAuthorizationヘッダフィールド（セクション14.8）でリクエストを繰り返してもよいです。要求が既に認証資格情報が含まれている場合、401レスポンスは認証がこれらの資格情報のために拒否されたことを示しています。 401レスポンスが前の応答と同じ課題が含まれており、ユーザエージェントはすでに少なくとも一度認証を試みた場合、ユーザーはそのエンティティは、関連する診断情報を含めることがあるため、応答で与えられたエンティティーを提示されるべきです。 [43]：HTTPアクセス認証が「基本とダイジェストアクセス認証HTTP認証」で説明されています。"
    },
    {
      "indent": 0,
      "text": "10.4.3 402 Payment Required",
      "section_title": true,
      "ja": "10.4.3 402支払いが必要"
    },
    {
      "indent": 3,
      "text": "This code is reserved for future use.",
      "ja": "このコードは、将来の使用のために予約されています。"
    },
    {
      "indent": 0,
      "text": "10.4.4 403 Forbidden",
      "section_title": true,
      "ja": "10.4.4 403禁止"
    },
    {
      "indent": 3,
      "text": "The server understood the request, but is refusing to fulfill it. Authorization will not help and the request SHOULD NOT be repeated. If the request method was not HEAD and the server wishes to make public why the request has not been fulfilled, it SHOULD describe the reason for the refusal in the entity. If the server does not wish to make this information available to the client, the status code 404 (Not Found) can be used instead.",
      "ja": "サーバーは要求を理解したが、それを実行することを拒否しています。承認は助けにはなりませんし、要求が繰り返されるべきではありません。リクエストメソッドがHEADではなかったとサーバが要求が満たされていない理由を公表することを希望する場合は、エンティティで拒否の理由を説明する必要があります。サーバはクライアントがこの情報を利用できるようにしたくない場合は、ステータスコード404（見つかりません）が代わりに使用することができます。"
    },
    {
      "indent": 0,
      "text": "10.4.5 404 Not Found",
      "section_title": true,
      "ja": "10.4.5 404が見つかりません"
    },
    {
      "indent": 3,
      "text": "The server has not found anything matching the Request-URI. No indication is given of whether the condition is temporary or permanent. The 410 (Gone) status code SHOULD be used if the server knows, through some internally configurable mechanism, that an old resource is permanently unavailable and has no forwarding address. This status code is commonly used when the server does not wish to reveal exactly why the request has been refused, or when no other response is applicable.",
      "ja": "サーバーは、Request-URIに一致するものを見つけていません。表示なしは、条件が一時的または恒久的であるかどうかについて説明されていません。 410（ゴーン）ステータスコードは、サーバが知っている場合、古いリソースが恒久的に利用できないことを、いくつかの内部的に設定可能なメカニズムを介して、使用して何の転送アドレスを持っていてはなりません。サーバは、要求が拒否された理由を正確に明らかにすることを希望していないとき、または他の応答が適用されない場合は、このステータスコードは一般的に使用されます。"
    },
    {
      "indent": 0,
      "text": "10.4.6 405 Method Not Allowed",
      "section_title": true,
      "ja": "10.4.6 405メソッドは許可されていません"
    },
    {
      "indent": 3,
      "text": "The method specified in the Request-Line is not allowed for the resource identified by the Request-URI. The response MUST include an Allow header containing a list of valid methods for the requested resource.",
      "ja": "リクエストラインで指定されたメソッドは、Request-URIによって識別されるリソースに対して許可されていません。応答は、要求されたリソースのための有効な方法のリストを含む許可ヘッダを含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.4.7 406 Not Acceptable",
      "section_title": true,
      "ja": "10.4.7 406受け入れられません"
    },
    {
      "indent": 3,
      "text": "The resource identified by the request is only capable of generating response entities which have content characteristics not acceptable according to the accept headers sent in the request.",
      "ja": "リクエストによって識別されたリソースは、リクエストで送信受け入れるヘッダによれば受け入れられないコンテンツ特性を持つ応答エンティティを生成することができるだけです。"
    },
    {
      "indent": 3,
      "text": "Unless it was a HEAD request, the response SHOULD include an entity containing a list of available entity characteristics and location(s) from which the user or user agent can choose the one most appropriate. The entity format is specified by the media type given in the Content-Type header field. Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed automatically. However, this specification does not define any standard for such automatic selection.",
      "ja": "それがHEAD要求でない限り、反応は、ユーザーまたはユーザーエージェントが最も適切なものを選択することができ、そこから入手可能なエンティティの特性及び位置（単数または複数）のリストを含むエンティティを含むべきです。エンティティフォーマットはContent-Typeヘッダフィールドで指定されたメディアタイプによって指定されます。フォーマットやユーザエージェントの能力に応じて、最も適切な選択の選択が自動的に実行することができます。しかし、この仕様書は、そのような自動選択のための任意の標準を定義していません。"
    },
    {
      "indent": 6,
      "text": "Note: HTTP/1.1 servers are allowed to return responses which are not acceptable according to the accept headers sent in the request. In some cases, this may even be preferable to sending a 406 response. User agents are encouraged to inspect the headers of an incoming response to determine if it is acceptable.",
      "ja": "注：HTTP / 1.1サーバは要求で送信される受入れヘッダーに応じて受け入れられない応答を返すことが許可されています。いくつかのケースでは、これも406応答を送信することが好ましいかもしれません。ユーザエージェントは、それが許容可能であるかどうかを決定するために、着信応答のヘッダを検査することが奨励されます。"
    },
    {
      "indent": 3,
      "text": "If the response could be unacceptable, a user agent SHOULD temporarily stop receipt of more data and query the user for a decision on further actions.",
      "ja": "レスポンスが受け入れられないことができれば、ユーザエージェントは一時的に、より多くのデータの受信を停止し、さらにアクションの決定のためにユーザに問い合わせるべきです。"
    },
    {
      "indent": 0,
      "text": "10.4.8 407 Proxy Authentication Required",
      "section_title": true,
      "ja": "10.4.8 407プロキシ認証が必要"
    },
    {
      "indent": 3,
      "text": "This code is similar to 401 (Unauthorized), but indicates that the client must first authenticate itself with the proxy. The proxy MUST return a Proxy-Authenticate header field (section 14.33) containing a challenge applicable to the proxy for the requested resource. The client MAY repeat the request with a suitable Proxy-Authorization header field (section 14.34). HTTP access authentication is explained in \"HTTP Authentication: Basic and Digest Access Authentication\" [43].",
      "ja": "このコードは401（Unauthorized）に似ていますが、クライアントはまず自分をプロキシで認証しなければならないことを示しています。プロキシは、要求されたリソースのプロキシに適用チャレンジを含むプロキシ認証ヘッダフィールド（セクション14.33）を返さなければなりません。クライアントは、適切なProxy-Authorizationヘッダフィールド（セクション14.34）でリクエストを繰り返してもよいです。 [43]：HTTPアクセス認証が「基本とダイジェストアクセス認証HTTP認証」で説明されています。"
    },
    {
      "indent": 0,
      "text": "10.4.9 408 Request Timeout",
      "section_title": true,
      "ja": "10.4.9 408リクエストタイムアウト"
    },
    {
      "indent": 3,
      "text": "The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.",
      "ja": "クライアントは、サーバが待機するように調製された時間内に要求を生成しませんでした。クライアントは、それ以降の時間に変更することなく、要求を繰り返してもよいです。"
    },
    {
      "indent": 0,
      "text": "10.4.10 409 Conflict",
      "section_title": true,
      "ja": "10.4.10 409競合"
    },
    {
      "indent": 3,
      "text": "The request could not be completed due to a conflict with the current state of the resource. This code is only allowed in situations where it is expected that the user might be able to resolve the conflict and resubmit the request. The response body SHOULD include enough information for the user to recognize the source of the conflict. Ideally, the response entity would include enough information for the user or user agent to fix the problem; however, that might not be possible and is not required.",
      "ja": "要求は、リソースの現在の状態との競合に完了することができませんでした。このコードは、唯一のユーザが矛盾を解決し、要求を再送信することができるかもしれないことが予想される状況では許可されています。レスポンスボディはユーザが競合のソースを認識するための十分な情報を含むべきです。理想的には、応答エンティティは、問題を解決するために、ユーザやユーザエージェントのための十分な情報が含まれます。しかし、それは可能ではないかもしれませんし、必要ありません。"
    },
    {
      "indent": 3,
      "text": "Conflicts are most likely to occur in response to a PUT request. For example, if versioning were being used and the entity being PUT included changes to a resource which conflict with those made by an earlier (third-party) request, the server might use the 409 response to indicate that it can't complete the request. In this case, the response entity would likely contain a list of the differences between the two versions in a format defined by the response Content-Type.",
      "ja": "競合は、PUT要求に応答して発生する可能性が最も高いです。例えば、バージョンが使用されたエンティティであるPUTは、サーバが要求を完了できないことを示すために、409応答を使用することがあり、以前の（サードパーティ）によって作られたものと矛盾要求リソースへの変更が含まれている場合。この場合、レスポンスエンティティは、おそらくレスポンスのContent-Typeで定義された形式の2つのバージョン間の相違点のリストが含まれます。"
    },
    {
      "indent": 0,
      "text": "10.4.11 410 Gone",
      "section_title": true,
      "ja": "10.4.11 410ゴーン"
    },
    {
      "indent": 3,
      "text": "The requested resource is no longer available at the server and no forwarding address is known. This condition is expected to be considered permanent. Clients with link editing capabilities SHOULD delete references to the Request-URI after user approval. If the server does not know, or has no facility to determine, whether or not the condition is permanent, the status code 404 (Not Found) SHOULD be used instead. This response is cacheable unless indicated otherwise.",
      "ja": "要求されたリソースは、サーバーとなし、転送先アドレスが知られている時に使用できなくなりました。この状態は永久的と見なされることが予想されます。リンク編集機能を持つクライアントは、ユーザーの承認後のRequest-URIへの参照を削除する必要があります。サーバは状態が永久的であるかどうか、知っている、または決定するための施設を持っていないいない場合は、ステータスコード404（見つかりません）が代わりに使用する必要があります。特に指示がない限り、このレスポンスはキャッシュ可能です。"
    },
    {
      "indent": 3,
      "text": "The 410 response is primarily intended to assist the task of web maintenance by notifying the recipient that the resource is intentionally unavailable and that the server owners desire that remote links to that resource be removed. Such an event is common for limited-time, promotional services and for resources belonging to individuals no longer working at the server's site. It is not necessary to mark all permanently unavailable resources as \"gone\" or to keep the mark for any length of time -- that is left to the discretion of the server owner.",
      "ja": "410応答は、主にリソースが意図的に利用できない受信者に通知することによって、サーバーの所有者がそのリソースへのリモートリンクが削除されることを望んでいることをウェブメンテナンスの作業を支援するためのものです。このようなイベントは、期間限定、プロモーションサービスのために、サーバーのサイトで働いて、もはや個人に属するリソースのための一般的です。サーバーの所有者の裁量に任されている - 「ゴーン」として、すべての永久利用できないリソースをマークするか、時間の任意の長さのためのマークを維持する必要はありません。"
    },
    {
      "indent": 0,
      "text": "10.4.12 411 Length Required",
      "section_title": true,
      "ja": "10.4.12 411の長さは必須"
    },
    {
      "indent": 3,
      "text": "The server refuses to accept the request without a defined Content-Length. The client MAY repeat the request if it adds a valid Content-Length header field containing the length of the message-body in the request message.",
      "ja": "サーバーは、Content-Lengthが定義させずに要求を受け入れることを拒否します。それは要求メッセージにメッセージボディの長さを含む有効なContent-Lengthヘッダフィールドを追加する場合、クライアントはリクエストを繰り返す事ができます。"
    },
    {
      "indent": 0,
      "text": "10.4.13 412 Precondition Failed",
      "section_title": true,
      "ja": "10.4.13 412前提条件の失敗"
    },
    {
      "indent": 3,
      "text": "The precondition given in one or more of the request-header fields evaluated to false when it was tested on the server. This response code allows the client to place preconditions on the current resource metainformation (header field data) and thus prevent the requested method from being applied to a resource other than the one intended.",
      "ja": "それはサーバで試験したときにリクエストヘッダフィールドの一つ以上で与えられた前提条件が偽に評価しました。この応答コードは、クライアントが現在のリソースメタ情報（ヘッダフィールドデータ）に前提条件を置き、従って意図以外のリソースに適用されることから、要求されたメソッドを防止することを可能にします。"
    },
    {
      "indent": 0,
      "text": "10.4.14 413 Request Entity Too Large",
      "section_title": true,
      "ja": "10.4.14 413要求エンティティが大きすぎます"
    },
    {
      "indent": 3,
      "text": "The server is refusing to process a request because the request entity is larger than the server is willing or able to process. The server MAY close the connection to prevent the client from continuing the request.",
      "ja": "サーバは、要求エンティティが、サーバが喜んまたは処理することができるよりも大きいため、要求を処理するために拒否されます。サーバーは、クライアントがリクエストを継続することを防止するために、接続を閉じます。"
    },
    {
      "indent": 3,
      "text": "If the condition is temporary, the server SHOULD include a Retry-After header field to indicate that it is temporary and after what time the client MAY try again.",
      "ja": "条件が一時的である場合、サーバはそれが一時的なもので、何時間後にクライアントが再試行してください可能性があることを示すために再試行-Afterヘッダフィールドを含むべきです。"
    },
    {
      "indent": 0,
      "text": "10.4.15 414 Request-URI Too Long",
      "section_title": true,
      "ja": "10.4.15 414のRequest-URIが長すぎます"
    },
    {
      "indent": 3,
      "text": "The server is refusing to service the request because the Request-URI is longer than the server is willing to interpret. This rare condition is only likely to occur when a client has improperly converted a POST request to a GET request with long query information, when the client has descended into a URI \"black hole\" of redirection (e.g., a redirected URI prefix that points to a suffix of itself), or when the server is under attack by a client attempting to exploit security holes present in some servers using fixed-length buffers for reading or manipulating the Request-URI.",
      "ja": "サーバは、サーバが解釈していく所存ですよりも、リクエスト-URIが長くなるため、要求のサービスを拒否しています。このまれな状況では、クライアントがリダイレクションのURI「ブラックホール」（例えば、指すリダイレクトURI接頭辞に降りたときに、クライアントが正しく、長いクエリ情報をGETリクエストにPOSTリクエストを変換した場合、自身の接尾辞）、またはサーバが読み取りまたは要求URIを操作するための固定長のバッファを使用して、いくつかのサーバに存在するセキュリティホールを悪用しようとするクライアントによって攻撃を受けているとき。"
    },
    {
      "indent": 0,
      "text": "10.4.16 415 Unsupported Media Type",
      "section_title": true,
      "ja": "10.4.16 415サポートされていないメディアタイプ"
    },
    {
      "indent": 3,
      "text": "The server is refusing to service the request because the entity of the request is in a format not supported by the requested resource for the requested method.",
      "ja": "リクエストのエンティティは、要求されたメソッドのために要求されたリソースによってサポートされていない形式であるため、サーバはリクエストのサービスを拒否しています。"
    },
    {
      "indent": 0,
      "text": "10.4.17 416 Requested Range Not Satisfiable",
      "section_title": true,
      "ja": "10.4.17 416要求された範囲に充足されません"
    },
    {
      "indent": 3,
      "text": "A server SHOULD return a response with this status code if a request included a Range request-header field (section 14.35), and none of the range-specifier values in this field overlap the current extent of the selected resource, and the request did not include an If-Range request-header field. (For byte-ranges, this means that the first-byte-pos of all of the byte-range-spec values were greater than the current length of the selected resource.)",
      "ja": "要求がレンジリクエストヘッダフィールド（セクション14.35）が含まれており、この分野で範囲指定子値のいずれもが選択されたリソースの現在の範囲と重複しない、と要求がなかった場合、サーバは、このステータスコードで応答を返すべきですもしレンジリクエストヘッダフィールドを含みます。 （バイト範囲については、これはバイト範囲スペック値のすべての最初のバイト-posが選択されたリソースの現在の長さよりも大きかったことを意味します。）"
    },
    {
      "indent": 3,
      "text": "When this status code is returned for a byte-range request, the response SHOULD include a Content-Range entity-header field specifying the current length of the selected resource (see section 14.16). This response MUST NOT use the multipart/byteranges content-type.",
      "ja": "このステータスコードは、バイト範囲要求に対して返されたとき、応答が選択されたリソースの現在の長さを指定するコンテンツレンジエンティティヘッダフィールドを含むべきである（セクション14.16を参照）。この応答は、マルチパート/ byterangesのコンテンツタイプを使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "10.4.18 417 Expectation Failed",
      "section_title": true,
      "ja": "10.4.18 417期待に失敗しました"
    },
    {
      "indent": 3,
      "text": "The expectation given in an Expect request-header field (see section 14.20) could not be met by this server, or, if the server is a proxy, the server has unambiguous evidence that the request could not be met by the next-hop server.",
      "ja": "期待リクエストヘッダフィールドで与えられた期待値は、（セクション14.20を参照）、このサーバによって満たすことができなかった、または、サーバがプロキシである場合、サーバは、要求がネクストホップサーバによって満たされなかったことを明確な証拠を持っています。"
    },
    {
      "indent": 0,
      "text": "10.5 Server Error 5xx",
      "section_title": true,
      "ja": "10.5サーバーエラー5xxの"
    },
    {
      "indent": 3,
      "text": "Response status codes beginning with the digit \"5\" indicate cases in which the server is aware that it has erred or is incapable of performing the request. Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition. User agents SHOULD display any included entity to the user. These response codes are applicable to any request method.",
      "ja": "数字「5」から始まるレスポンスステータスコードは、サーバが、それが誤りを犯したり、要求を実行することができないしていることを認識している例を示しています。 HEADリクエストに応答するとき以外は、サーバはエラー状況の説明を含むエンティティを含むべきである、それは一時的または永久的な状態であるかどうか。ユーザーエージェントは、ユーザーに任意の含まれたエンティティが表示されます。これらの応答コードはどんなリクエストメソッドに適用されます。"
    },
    {
      "indent": 0,
      "text": "10.5.1 500 Internal Server Error",
      "section_title": true,
      "ja": "10.5.1 500内部サーバーエラー"
    },
    {
      "indent": 3,
      "text": "The server encountered an unexpected condition which prevented it from fulfilling the request.",
      "ja": "サーバーは、要求を満たすことを妨げる予期しない状態に遭遇しました。"
    },
    {
      "indent": 0,
      "text": "10.5.2 501 Not Implemented",
      "section_title": true,
      "ja": "10.5.2 501が実装されていません"
    },
    {
      "indent": 3,
      "text": "The server does not support the functionality required to fulfill the request. This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.",
      "ja": "サーバは要求を満たすために必要な機能をサポートしていません。これは、サーバがリクエストメソッドを認識しないし、すべてのリソースに対して、それに対応する機能がない適切な対応です。"
    },
    {
      "indent": 0,
      "text": "10.5.3 502 Bad Gateway",
      "section_title": true,
      "ja": "10.5.3 502不正なゲートウェイ"
    },
    {
      "indent": 3,
      "text": "The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request.",
      "ja": "サーバは、ゲートウェイまたはプロキシとして動作しながら、それが要求を満たすためにしようとしてアクセスアップストリームサーバから無効な応答を受け取りました。"
    },
    {
      "indent": 0,
      "text": "10.5.4 503 Service Unavailable",
      "section_title": true,
      "ja": "10.5.4 503サービスを使用できません"
    },
    {
      "indent": 3,
      "text": "The server is currently unable to handle the request due to a temporary overloading or maintenance of the server. The implication is that this is a temporary condition which will be alleviated after some delay. If known, the length of the delay MAY be indicated in a Retry-After header. If no Retry-After is given, the client SHOULD handle the response as it would for a 500 response.",
      "ja": "サーバーは、現在サーバーの一時的な過負荷またはメンテナンスのためにリクエストを処理することができません。含意は、これはしばらく待つと緩和される一時的な状態であるということです。既知の場合、遅延の長さは、リトライ後ヘッダに示されてもよいです。何のリトライ後が指定されていない場合、クライアントは、応答それは500応答の場合と同じように処理する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: The existence of the 503 status code does not imply that a server must use it when becoming overloaded. Some servers may wish to simply refuse the connection.",
      "ja": "注意：503のステータスコードの存在が過負荷になるときに、サーバがそれを使用しなければならないことを意味するものではありません。一部のサーバーは、単に接続を拒否することもできます。"
    },
    {
      "indent": 0,
      "text": "10.5.5 504 Gateway Timeout",
      "section_title": true,
      "ja": "10.5.5 504ゲートウェイタイムアウト"
    },
    {
      "indent": 3,
      "text": "The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server specified by the URI (e.g. HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed to access in attempting to complete the request.",
      "ja": "サーバーは、ゲートウェイまたはプロキシとして動作している間、それが完了しようとする中でのアクセスに必要なURI（例えばHTTP、FTP、LDAP）、またはいくつかの他の補助のサーバ（例えばDNS）で指定した上流サーバからタイムリーな応答を受信しませんでしたリクエスト。"
    },
    {
      "indent": 6,
      "text": "Note: Note to implementors: some deployed proxies are known to return 400 or 500 when DNS lookups time out.",
      "ja": "注意：実装者への注意：いくつかの展開プロキシがDNSに時間をルックアップの時に400または500を返すことが知られています。"
    },
    {
      "indent": 0,
      "text": "10.5.6 505 HTTP Version Not Supported",
      "section_title": true,
      "ja": "10.5.6 505 HTTPバージョンはサポートされません"
    },
    {
      "indent": 3,
      "text": "The server does not support, or refuses to support, the HTTP protocol version that was used in the request message. The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described in section 3.1, other than with this error message. The response SHOULD contain an entity describing why that version is not supported and what other protocols are supported by that server.",
      "ja": "サーバがサポートする、または、要求メッセージで使用されたHTTPプロトコルのバージョンをサポートすることを拒否していません。サーバーは、このエラーメッセージよりも他のセクション3.1に記載されているように、それができない、またはクライアントと同じメジャーバージョンを使用して要求を完了することが不本意であることを示しています。応答はそのバージョンがサポートされておらず、他のどのようなプロトコルは、そのサーバによってサポートされている理由を記述したエンティティを含むべきです。"
    },
    {
      "indent": 0,
      "text": "11 Access Authentication",
      "ja": "11アクセス認証"
    },
    {
      "indent": 3,
      "text": "HTTP provides several OPTIONAL challenge-response authentication mechanisms which can be used by a server to challenge a client request and by a client to provide authentication information. The general framework for access authentication, and the specification of \"basic\" and \"digest\" authentication, are specified in \"HTTP Authentication: Basic and Digest Access Authentication\" [43]. This specification adopts the definitions of \"challenge\" and \"credentials\" from that specification.",
      "ja": "HTTPは認証情報を提供するために、クライアントの要求に挑戦するためにサーバーが使用すると、クライアントによることができるいくつかのオプションのチャレンジ・レスポンス認証メカニズムを提供します。 [43]：アクセス認証のための一般的なフレームワーク、および「ダイジェスト」「基本」と認証の仕様は、「基本とダイジェストアクセス認証HTTP認証」で指定されています。この仕様は、「挑戦」し、その仕様から「資格証明書」の定義を採用しています。"
    },
    {
      "indent": 0,
      "text": "12 Content Negotiation",
      "ja": "12コンテントネゴシエーション"
    },
    {
      "indent": 3,
      "text": "Most HTTP responses include an entity which contains information for interpretation by a human user. Naturally, it is desirable to supply the user with the \"best available\" entity corresponding to the request. Unfortunately for servers and caches, not all users have the same preferences for what is \"best,\" and not all user agents are equally capable of rendering all entity types. For that reason, HTTP has provisions for several mechanisms for \"content negotiation\" -- the process of selecting the best representation for a given response when there are multiple representations available.",
      "ja": "ほとんどのHTTP応答は人間のユーザによる解釈のための情報が含まれているエンティティが含まれます。当然、その要求に対応する「最良の利用可能な」エンティティをユーザに供給することが望ましいです。残念ながら、サーバやキャッシュのためではなく、すべてのユーザーが「最高」である何のために同じ嗜好を持っているし、すべてのユーザエージェントは、すべてのエンティティタイプをレンダリングも同様に実施可能わけではありません。利用可能な複数の表現がある与えられた応答のための最良の表現を選択するプロセス - そのため、HTTPは「コンテントネゴシエーション」のために、いくつかのメカニズムのための規定を持っています。"
    },
    {
      "indent": 6,
      "text": "Note: This is not called \"format negotiation\" because the alternate representations may be of the same media type, but use different capabilities of that type, be in different languages, etc.",
      "ja": "注意：代替表現等、同じメディアタイプであるが、その種類の異なる機能を使用し、異なる言語であってもよいので、これは、「フォーマットネゴシエーション」と呼ばれていません"
    },
    {
      "indent": 3,
      "text": "Any response containing an entity-body MAY be subject to negotiation, including error responses.",
      "ja": "エンティティボディを含む任意の応答がエラー応答を含め、交渉の対象となります。"
    },
    {
      "indent": 3,
      "text": "There are two kinds of content negotiation which are possible in HTTP: server-driven and agent-driven negotiation. These two kinds of negotiation are orthogonal and thus may be used separately or in combination. One method of combination, referred to as transparent negotiation, occurs when a cache uses the agent-driven negotiation information provided by the origin server in order to provide server-driven negotiation for subsequent requests.",
      "ja": "サーバー主導型とエージェント駆動の交渉：HTTPで可能なコンテンツネゴシエーションの2種類があります。交渉のこれらの二つの種類が直交しているので、別々に又は組み合わせて使用​​することができます。キャッシュは後続の要求のためのサーバ主導型ネゴシエーションを提供するために、オリジンサーバによって提供されるエージェント駆動型ネゴシエーション情報を使用するときのような透明なネゴシエーションと呼ばれる組み合わせの一つの方法は、生じます。"
    },
    {
      "indent": 0,
      "text": "12.1 Server-driven Negotiation",
      "section_title": true,
      "ja": "12.1サーバ駆動型ネゴシエーション"
    },
    {
      "indent": 3,
      "text": "If the selection of the best representation for a response is made by an algorithm located at the server, it is called server-driven negotiation. Selection is based on the available representations of the response (the dimensions over which it can vary; e.g. language, content-coding, etc.) and the contents of particular header fields in the request message or on other information pertaining to the request (such as the network address of the client).",
      "ja": "応答のための最高の表現の選択がサーバにあるアルゴリズムによってなされた場合、それは、サーバ駆動折衝と呼ばれています。選択は、利用可能な応答の表現（それが変動し得るその上寸法、例えば言語、コンテンツコーディング、等）に基づいて、要求メッセージまたは要求に関連する他の情報に特定のヘッダフィールドの内容（例えば）クライアントのネットワークアドレスなど。"
    },
    {
      "indent": 3,
      "text": "Server-driven negotiation is advantageous when the algorithm for selecting from among the available representations is difficult to describe to the user agent, or when the server desires to send its \"best guess\" to the client along with the first response (hoping to avoid the round-trip delay of a subsequent request if the \"best guess\" is good enough for the user). In order to improve the server's guess, the user agent MAY include request header fields (Accept, Accept-Language, Accept-Encoding, etc.) which describe its preferences for such a response.",
      "ja": "利用可能な表現の中から選択するためのアルゴリズムはユーザエージェントに記述することは困難である、またはサーバーが最初の応答と一緒にクライアントにその「最良の推測」を送信したいとき（避けるために、ご希望の場合、サーバ駆動型ネゴシエーションは有利であり、 「最良の推測」）は、ユーザーのために十分に良好であれば、後続の要求のラウンドトリップ遅延。サーバの推測を改善するために、ユーザエージェントは、応答に対するその選好を記載している（など、受け入れ受け入れ言語を受け入れるコードする）をリクエストヘッダのフィールドを含んでもよいです。"
    },
    {
      "indent": 3,
      "text": "Server-driven negotiation has disadvantages:",
      "ja": "サーバー駆動型ネゴシエーションは欠点があります。"
    },
    {
      "indent": 6,
      "text": "1. It is impossible for the server to accurately determine what might be \"best\" for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?).",
      "ja": "1.サーバーが正確に任意のユーザーのための「最良」であるかもしれないものを判断するのは不可能であることは、ユーザエージェントと応答（例えば使用目的の両方の機能の完全な知識を必要とすることから、利用者が欲しいん画面上に表示したり、紙に印刷するには？）。"
    },
    {
      "indent": 6,
      "text": "2. Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage of responses have multiple representations) and a potential violation of the user's privacy.",
      "ja": "2.ユーザエージェントはリクエストごとにその機能を説明持つこと（応答のわずかな割合は複数の表現を持っていることを考えると）両方の非常に非効率とユーザーのプライバシーの潜在的な侵害することができます。"
    },
    {
      "indent": 6,
      "text": "3. It complicates the implementation of an origin server and the algorithms for generating responses to a request.",
      "ja": "3.それはオリジンサーバの実装と要求に対する応答を生成するためのアルゴリズムを複雑にします。"
    },
    {
      "indent": 6,
      "text": "4. It may limit a public cache's ability to use the same response for multiple user's requests.",
      "ja": "4.これは、複数のユーザーの要求に同じ応答を使用する公開キャッシュの能力を制限する可能性があります。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 includes the following request-header fields for enabling server-driven negotiation through description of user agent capabilities and user preferences: Accept (section 14.1), Accept-Charset (section 14.2), Accept-Encoding (section 14.3), Accept-Language (section 14.4), and User-Agent (section 14.43). However, an origin server is not limited to these dimensions and MAY vary the response based on any aspect of the request, including information outside the request-header fields or within extension header fields not defined by this specification.",
      "ja": "HTTP / 1.1は、ユーザエージェントの能力とユーザ嗜好の説明を介して、サーバ・ドリブンネゴシエーションを可能にするため、次のリクエストヘッダフィールドを含む：（セクション14.1）を受け入れる（セクション14.2）・文字セットを受け入れ、受け入れエンコード（セクション14.3）、なAccept-言語（セクション14.4）、およびユーザエージェント（セクション14.43）。しかし、オリジンサーバはこれらの寸法に限定されるものではなく、リクエスト・ヘッダー・フィールド外部または本明細書で定義されていない拡張ヘッダフィールド内の情報を含む要求のいずれかの態様に基づいて、応答を変化させることができます。"
    },
    {
      "indent": 3,
      "text": "The Vary header field can be used to express the parameters the server uses to select a representation that is subject to server-driven negotiation. See section 13.6 for use of the Vary header field by caches and section 14.44 for use of the Vary header field by servers.",
      "ja": "ヴァリヘッダフィールドは、サーバがサーバ駆動型ネゴシエーションを受ける表現を選択するために使用するパラメータを発現するために使用することができます。キャッシュおよびサーバーによって異なるヘッダフィールドを使用するためのセクション14.44によって異なるヘッダフィールドを使用するためのセクション13.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "12.2 Agent-driven Negotiation",
      "section_title": true,
      "ja": "12.2エージェント駆動の交渉"
    },
    {
      "indent": 3,
      "text": "With agent-driven negotiation, selection of the best representation for a response is performed by the user agent after receiving an initial response from the origin server. Selection is based on a list of the available representations of the response included within the header fields or entity-body of the initial response, with each representation identified by its own URI. Selection from among the representations may be performed automatically (if the user agent is capable of doing so) or manually by the user selecting from a generated (possibly hypertext) menu.",
      "ja": "エージェント駆動の交渉では、応答のための最高の表現の選択は、オリジンサーバからの初期応答を受け取った後、ユーザエージェントによって行われます。選択は、それ自身のURIによって識別される各表現に、初期応答のヘッダフィールドまたはエンティティボディ内に含まれる応答の利用可能な表現のリストに基づいています。または手動で生成された（おそらくハイパーテキスト）メニューからのユーザ選択によって（ユーザエージェントがそうすることが可能である場合）表現の中から選択を自動的に行うことができます。"
    },
    {
      "indent": 3,
      "text": "Agent-driven negotiation is advantageous when the response would vary over commonly-used dimensions (such as type, language, or encoding), when the origin server is unable to determine a user agent's capabilities from examining the request, and generally when public caches are used to distribute server load and reduce network usage.",
      "ja": "公共のキャッシュがある場合、応答は、一般に、オリジンサーバは、要求を検査からユーザエージェントの能力を決定することができない（例えば、タイプ、言語、または符号化のような）一般的に使用される大きさにわたって変化し、そしてなるとき、エージェント駆動型ネゴシエーションが有利ですサーバーの負荷を分散し、ネットワークの使用量を削減するために使用。"
    },
    {
      "indent": 3,
      "text": "Agent-driven negotiation suffers from the disadvantage of needing a second request to obtain the best alternate representation. This second request is only efficient when caching is used. In addition, this specification does not define any mechanism for supporting automatic selection, though it also does not prevent any such mechanism from being developed as an extension and used within HTTP/1.1.",
      "ja": "エージェント駆動型ネゴシエーションは、最良の代替表現を得るために第2の要求を必要とするという欠点があります。キャッシュが使用されている場合は、この2番目の要求にのみ効率的です。また、拡張として開発され、HTTP / 1.1内で使用されているから、そのような機構を妨げないもののほかに、本明細書では、自動選択をサポートするための任意のメカニズムを定義しません。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable) status codes for enabling agent-driven negotiation when the server is unwilling or unable to provide a varying response using server-driven negotiation.",
      "ja": "HTTP / 1.1 300（複数の選択肢）及び406（許容できない）サーバがサーバ駆動型ネゴシエーションを使用して変化させる応答を提供したくないまたはできない場合、エージェント駆動型ネゴシエーションを可能にするためのステータスコードを定義します。"
    },
    {
      "indent": 0,
      "text": "12.3 Transparent Negotiation",
      "section_title": true,
      "ja": "12.3透過的ネゴシエーション"
    },
    {
      "indent": 3,
      "text": "Transparent negotiation is a combination of both server-driven and agent-driven negotiation. When a cache is supplied with a form of the list of available representations of the response (as in agent-driven negotiation) and the dimensions of variance are completely understood by the cache, then the cache becomes capable of performing server-driven negotiation on behalf of the origin server for subsequent requests on that resource.",
      "ja": "透明なネゴシエーションは、サーバー主導とエージェント駆動型ネゴシエーションの両方の組み合わせです。キャッシュが（エージェント駆動型ネゴシエーションにおけるように）応答の利用可能な表現のリストの形で供給され、分散の大きさが完全にキャッシュすることによって理解されている場合、キャッシュは、代わりにサーバ・ドリブンネゴシエーションを行うことが可能となりますそのリソースへの後続のリクエストのためにオリジンサーバの。"
    },
    {
      "indent": 3,
      "text": "Transparent negotiation has the advantage of distributing the negotiation work that would otherwise be required of the origin server and also removing the second request delay of agent-driven negotiation when the cache is able to correctly guess the right response.",
      "ja": "透明な交渉は、そうでない場合は、オリジンサーバーで必要とされるであろう交渉作業を配布し、キャッシュが正しく右の応答を推測できる場合も、エージェント駆動の交渉の第2の要求遅延を除去するという利点があります。"
    },
    {
      "indent": 3,
      "text": "This specification does not define any mechanism for transparent negotiation, though it also does not prevent any such mechanism from being developed as an extension that could be used within HTTP/1.1.",
      "ja": "また、HTTP / 1.1内で使用することができる拡張として開発されてから、このような機構を妨げないものの、本明細書では、透明なネゴシエーションのための任意のメカニズムを定義しません。"
    },
    {
      "indent": 0,
      "text": "13 Caching in HTTP",
      "ja": "HTTPで13キャッシング"
    },
    {
      "indent": 3,
      "text": "HTTP is typically used for distributed information systems, where performance can be improved by the use of response caches. The HTTP/1.1 protocol includes a number of elements intended to make caching work as well as possible. Because these elements are inextricable from other aspects of the protocol, and because they interact with each other, it is useful to describe the basic caching design of HTTP separately from the detailed descriptions of methods, headers, response codes, etc.",
      "ja": "HTTPは、典型的には、性能が応答キャッシュを使用することによって改善することができる分散情報システムに使用されます。 HTTP / 1.1プロトコルが可能と同様にキャッシュを動作させるように意図要素の数を含みます。これらの要素はプロトコルの他の側面からほどけないあるので、それらが互いに相互作用しているため、それ等の方法、ヘッダ、応答コードの詳細な説明は別にHTTPの基本的なキャッシュ設計を記述するために有用です"
    },
    {
      "indent": 3,
      "text": "Caching would be useless if it did not significantly improve performance. The goal of caching in HTTP/1.1 is to eliminate the need to send requests in many cases, and to eliminate the need to send full responses in many other cases. The former reduces the number of network round-trips required for many operations; we use an \"expiration\" mechanism for this purpose (see section 13.2). The latter reduces network bandwidth requirements; we use a \"validation\" mechanism for this purpose (see section 13.3).",
      "ja": "それはパフォーマンスを大幅に改善しなかった場合はキャッシングは役に立たないだろう。 HTTP / 1.1におけるキャッシングの目標は、多くの場合、要求を送信する必要性を排除するために、および他の多くの例では、完全な応答を送信する必要性を排除することです。前者は、多くの操作に必要なネットワーク・ラウンドトリップの回数を減らします。我々は、この目的のために「有効期限」のメカニズムを（セクション13.2を参照）を使用します。後者は、ネットワーク帯域幅の要件を低減します。我々は、この目的のための「検証」のメカニズムを（セクション13.3を参照）を使用します。"
    },
    {
      "indent": 3,
      "text": "Requirements for performance, availability, and disconnected operation require us to be able to relax the goal of semantic transparency. The HTTP/1.1 protocol allows origin servers, caches, and clients to explicitly reduce transparency when necessary. However, because non-transparent operation may confuse non-expert users, and might be incompatible with certain server applications (such as those for ordering merchandise), the protocol requires that transparency be relaxed",
      "ja": "パフォーマンス、可用性、および切断操作のための要件は、意味の透明性の目標を緩和することができることを求めています。 HTTP / 1.1プロトコルは、必要なときにオリジンサーバ、キャッシュ、クライアントが明示的に透明性を減らすことができます。しかし、非透過的な操作は、非専門家のユーザーを混乱させ、そして（例えば発注商品のためのものなど）、特定のサーバアプリケーションとの互換性がない可能性があるため、プロトコルは、透明性が緩和されている必要があります"
    },
    {
      "indent": 6,
      "text": "- only by an explicit protocol-level request when relaxed by client or origin server",
      "ja": " - 唯一の明示的なプロトコルレベルの要求により、クライアントやオリジンサーバによって緩和するとき"
    },
    {
      "indent": 6,
      "text": "- only with an explicit warning to the end user when relaxed by cache or client",
      "ja": " - 専用キャッシュやクライアントによって緩和エンドユーザーへの明示的な警告と"
    },
    {
      "indent": 3,
      "text": "Therefore, the HTTP/1.1 protocol provides these important elements:",
      "ja": "従って、HTTP / 1.1プロトコルは、これらの重要な要素を提供します。"
    },
    {
      "indent": 6,
      "text": "1. Protocol features that provide full semantic transparency when this is required by all parties.",
      "ja": "これはすべての当事者によって要求されたときに、完全な意味的な透過性を提供1.プロトコル機能。"
    },
    {
      "indent": 6,
      "text": "2. Protocol features that allow an origin server or user agent to explicitly request and control non-transparent operation.",
      "ja": "オリジンサーバやユーザエージェントが明示的に要求し、非透過的な操作を制御することを可能にする2プロトコル機能。"
    },
    {
      "indent": 6,
      "text": "3. Protocol features that allow a cache to attach warnings to responses that do not preserve the requested approximation of semantic transparency.",
      "ja": "キャッシュは、意味の透明性の要求された近似値を保存しない応答に警告を添付できるようにする3.プロトコル機能。"
    },
    {
      "indent": 3,
      "text": "A basic principle is that it must be possible for the clients to detect any potential relaxation of semantic transparency.",
      "ja": "基本的な原理は、クライアントは、意味の透明性のいずれかの潜在的な緩和を検出することが可能でなければならないということです。"
    },
    {
      "indent": 6,
      "text": "Note: The server, cache, or client implementor might be faced with design decisions not explicitly discussed in this specification. If a decision might affect semantic transparency, the implementor ought to err on the side of maintaining transparency unless a careful and complete analysis shows significant benefits in breaking transparency.",
      "ja": "注：サーバー、キャッシュ、またはクライアントの実装者は、明示的にこの仕様で説明されていないデザインの決定に直面するかもしれません。判決は、意味の透明性に影響を与える可能性がある場合、実装者は慎重かつ完全な分析は、透明性を壊すことで大きなメリットを示していない限り、透明性を維持するのに越しべきです。"
    },
    {
      "indent": 0,
      "text": "13.1.1 Cache Correctness",
      "section_title": true,
      "ja": "13.1.1キャッシュの正当性"
    },
    {
      "indent": 3,
      "text": "A correct cache MUST respond to a request with the most up-to-date response held by the cache that is appropriate to the request (see sections 13.2.5, 13.2.6, and 13.12) which meets one of the following conditions:",
      "ja": "正しいキャッシュは、次のいずれかの条件を満たしている要求に適したキャッシュに保持された最新の応答（セクション13.2.5、13.2.6を参照して、13.12）で要求に応答しなければなりません"
    },
    {
      "indent": 6,
      "text": "1. It has been checked for equivalence with what the origin server would have returned by revalidating the response with the origin server (section 13.3);",
      "ja": "1.これは、オリジンサーバがオリジンサーバ（セクション13.3）との応答を再検証によって返されていたものとの等価性をチェックされています。"
    },
    {
      "indent": 6,
      "text": "2. It is \"fresh enough\" (see section 13.2). In the default case, this means it meets the least restrictive freshness requirement of the client, origin server, and cache (see section 14.9); if the origin server so specifies, it is the freshness requirement of the origin server alone.",
      "ja": "2.それは「十分に新鮮」である（セクション13.2を参照してください）。デフォルトの場合、これは（セクション14.9を参照）、クライアント、オリジンサーバ、およびキャッシュの最も制限の新鮮さの要件を満たしていること。オリジンサーバがそう指定されている場合、それだけではオリジンサーバの鮮度要件です。"
    },
    {
      "indent": 9,
      "text": "If a stored response is not \"fresh enough\" by the most restrictive freshness requirement of both the client and the origin server, in carefully considered circumstances the cache MAY still return the response with the appropriate Warning header (see section 13.1.5 and 14.46), unless such a response is prohibited (e.g., by a \"no-store\" cache-directive, or by a \"no-cache\" cache-request-directive; see section 14.9).",
      "ja": "保存された応答は、クライアントとオリジンサーバの両方の最も制限鮮度要件によって「十分に新鮮」でない場合は、慎重に検討の状況でキャッシュがまだ適切な警告ヘッダーを持つ応答を返してもよい（セクション13.1.5と14.46を参照してください） 、このような応答は禁止されていない限り（例えば、「無店舗」キャッシュ・ディレクティブによって、または「キャッシュなし」のキャッシュ・リクエスト・ディレクティブによって、セクション14.9を参照してください）。"
    },
    {
      "indent": 6,
      "text": "3. It is an appropriate 304 (Not Modified), 305 (Proxy Redirect), or error (4xx or 5xx) response message.",
      "ja": "3.これは、適切な304（変更されていません）、305（プロキシリダイレクト）、またはエラー（4XXまたは5xxの）応答メッセージです。"
    },
    {
      "indent": 3,
      "text": "If the cache can not communicate with the origin server, then a correct cache SHOULD respond as above if the response can be correctly served from the cache; if not it MUST return an error or warning indicating that there was a communication failure.",
      "ja": "キャッシュはオリジンサーバと通信できない場合は、正しいキャッシュはレスポンスが正しくキャッシュから提供できるのであれば、上記のように対応すべきです。ない場合には、通信障害があったことを示すエラーまたは警告を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a cache receives a response (either an entire response, or a 304 (Not Modified) response) that it would normally forward to the requesting client, and the received response is no longer fresh, the cache SHOULD forward it to the requesting client without adding a new Warning (but without removing any existing Warning headers). A cache SHOULD NOT attempt to revalidate a response simply because that response became stale in transit; this might lead to an infinite loop. A user agent that receives a stale response without a Warning MAY display a warning indication to the user.",
      "ja": "キャッシュは、キャッシュがなくて要求元のクライアントに転送すべきで、それは通常、前方に要求しているクライアントへのだろう、と受け取ったレスポンスがもはや新鮮で​​ないこと（全体の応答、または304（未修正）応答のいずれか）を応答を受信した場合新しい警告を追加します（ただし、既存の警告ヘッダを削除せずに）。キャッシュは、そのレスポンスが輸送中の古くなったというだけの理由で応答を再検証を試みるべきではありません。これは無限ループにつながる可能性があります。警告なしに失効応答を受信するユーザエージェントは、ユーザに警告表示を表示してもよいです。"
    },
    {
      "indent": 0,
      "text": "13.1.2 Warnings",
      "section_title": true,
      "ja": "13.1.2警告"
    },
    {
      "indent": 3,
      "text": "Whenever a cache returns a response that is neither first-hand nor \"fresh enough\" (in the sense of condition 2 in section 13.1.1), it MUST attach a warning to that effect, using a Warning general-header. The Warning header and the currently defined warnings are described in section 14.46. The warning allows clients to take appropriate action.",
      "ja": "キャッシュは、最初の手も（セクション13.1.1における条件2の意味で）「十分に新鮮」でもない応答を返すときはいつでも、それは警告一般的なヘッダを使用して、その旨の警告を添付しなければなりません。警告ヘッダと現在定義されている警告はセクション14.46に記載されています。警告はクライアントが適切な行動を取ることができます。"
    },
    {
      "indent": 3,
      "text": "Warnings MAY be used for other purposes, both cache-related and otherwise. The use of a warning, rather than an error status code, distinguish these responses from true failures.",
      "ja": "警告は、キャッシュ関連とそれ以外の両方の、他の目的に使用することができます。警告ではなく、エラーステータスコードの使用は、真の障害からこれらの応答を区別する。"
    },
    {
      "indent": 3,
      "text": "Warnings are assigned three digit warn-codes. The first digit indicates whether the Warning MUST or MUST NOT be deleted from a stored cache entry after a successful revalidation:",
      "ja": "警告は3桁の警告-コードが割り当てられています。最初の数字は、警告または成功した再検証した後、保存されたキャッシュエントリから削除してはならない必要があるかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "1xx Warnings that describe the freshness or revalidation status of the response, and so MUST be deleted after a successful revalidation. 1XX warn-codes MAY be generated by a cache only when validating a cached entry. It MUST NOT be generated by clients.",
      "ja": "これの1xx応答の鮮度や再検証のステータスを記述する警告し、成功した再検証後に削除されなければなりません。 1XXは警告-コードをキャッシュされたエントリを検証した場合にのみキャッシュすることによって生成することができます。これは、クライアントによって生成されてはなりません。"
    },
    {
      "indent": 3,
      "text": "2xx Warnings that describe some aspect of the entity body or entity headers that is not rectified by a revalidation (for example, a lossy compression of the entity bodies) and which MUST NOT be deleted after a successful revalidation.",
      "ja": "（例えば、エンティティ体の非可逆圧縮）再検証によって整流されておらず、成功した再検証後に削除してはいけませんどのエンティティ体またはエンティティヘッダのいくつかの態様を説明2XX警告。"
    },
    {
      "indent": 3,
      "text": "See section 14.46 for the definitions of the codes themselves.",
      "ja": "コード自体の定義についてはセクション14.46を参照してください。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.0 caches will cache all Warnings in responses, without deleting the ones in the first category. Warnings in responses that are passed to HTTP/1.0 caches carry an extra warning-date field, which prevents a future HTTP/1.1 recipient from believing an erroneously cached Warning.",
      "ja": "HTTP / 1.0キャッシュは、最初のカテゴリにものを削除することなく、応答のすべての警告をキャッシュします。 HTTP / 1.0のキャッシュに渡される応答の警告が誤ってキャッシュされた警告を信じるから、将来のHTTP / 1.1受信者を防ぎ、余分な警告日付フィールドを運びます。"
    },
    {
      "indent": 3,
      "text": "Warnings also carry a warning text. The text MAY be in any appropriate natural language (perhaps based on the client's Accept headers), and include an OPTIONAL indication of what character set is used.",
      "ja": "警告は、警告テキストを運びます。テキストは、任意の適切な自然言語であってもよい（多分クライアントのAcceptヘッダに基づいて）、および文字セットが使用されているもののオプション表示を含みます。"
    },
    {
      "indent": 3,
      "text": "Multiple warnings MAY be attached to a response (either by the origin server or by a cache), including multiple warnings with the same code number. For example, a server might provide the same warning with texts in both English and Basque.",
      "ja": "複数の警告が同じコード番号を持つ複数の警告を含む応答（オリジンサーバによって、またはキャッシュのいずれかによって）に取り付けられてもよいです。例えば、サーバが英語とバスク語の両方のテキストと同じ警告を提供するかもしれません。"
    },
    {
      "indent": 3,
      "text": "When multiple warnings are attached to a response, it might not be practical or reasonable to display all of them to the user. This version of HTTP does not specify strict priority rules for deciding which warnings to display and in what order, but does suggest some heuristics.",
      "ja": "複数の警告がレスポンスに添付されている場合は、ユーザーにそれらのすべてを表示するのは実用的または合理的ではないかもしれません。 HTTPのこのバージョンは、警告を表示するかを決めるために、どのような順序で完全優先規則を指定しませんが、いくつかのヒューリスティックを提案ありません。"
    },
    {
      "indent": 0,
      "text": "13.1.3 Cache-control Mechanisms",
      "section_title": true,
      "ja": "13.1.3キャッシュ制御メカニズム"
    },
    {
      "indent": 3,
      "text": "The basic cache mechanisms in HTTP/1.1 (server-specified expiration times and validators) are implicit directives to caches. In some cases, a server or client might need to provide explicit directives to the HTTP caches. We use the Cache-Control header for this purpose.",
      "ja": "HTTP / 1.1の基本的なキャッシュ・メカニズム（サーバー指定の有効期限とバリデータ）は、キャッシュへの暗黙のディレクティブです。いくつかのケースでは、サーバやクライアントはHTTPキャッシュに明示的な指示を提供する必要があるかもしれません。私たちは、この目的のためのCache-Controlヘッダーを使用しています。"
    },
    {
      "indent": 3,
      "text": "The Cache-Control header allows a client or server to transmit a variety of directives in either requests or responses. These directives typically override the default caching algorithms. As a general rule, if there is any apparent conflict between header values, the most restrictive interpretation is applied (that is, the one that is most likely to preserve semantic transparency). However, in some cases, cache-control directives are explicitly specified as weakening the approximation of semantic transparency (for example, \"max-stale\" or \"public\").",
      "ja": "Cache-Controlヘッダは、クライアントまたはサーバが要求または応答のいずれかのディレクティブの様々なを送信することができます。これらのディレクティブは、通常、デフォルトのキャッシングアルゴリズムを上書きします。ヘッダ値の間に明らかな矛盾がある場合は、原則として、最も限定的な解釈が適用される（すなわち、意味論的透明性を維持する可能性が最も高いもの）。しかし、いくつかのケースでは、キャッシュ制御ディレクティブを明示的に意味の透明性の近似値を弱めるとして指定されている（例えば、「MAX-古い」または「パブリック」）。"
    },
    {
      "indent": 3,
      "text": "The cache-control directives are described in detail in section 14.9.",
      "ja": "キャッシュ制御指令はセクション14.9に詳細に記載されています。"
    },
    {
      "indent": 0,
      "text": "13.1.4 Explicit User Agent Warnings",
      "section_title": true,
      "ja": "13.1.4明示的なユーザーエージェントの警告"
    },
    {
      "indent": 3,
      "text": "Many user agents make it possible for users to override the basic caching mechanisms. For example, the user agent might allow the user to specify that cached entities (even explicitly stale ones) are never validated. Or the user agent might habitually add \"Cache-Control: max-stale=3600\" to every request. The user agent SHOULD NOT default to either non-transparent behavior, or behavior that results in abnormally ineffective caching, but MAY be explicitly configured to do so by an explicit action of the user.",
      "ja": "多くのユーザエージェントは、それが可能なユーザーは、基本的なキャッシュメカニズムを無効にできるようにするため。例えば、ユーザーエージェントは、ユーザーがキャッシュされたエンティティ（でも、明示的に古いものは）検証されないことを指定することができる場合があります。すべてのリクエストに：またはユーザエージェントは、習慣的に「MAX-古い= 3600のCache-Control」を追加することがあります。ユーザーエージェントは、非透明行動、または異常無効キャッシュにつながる行動のいずれかをデフォルトとはならず、明示的にユーザーの明示的なアクションによってそうするように構成されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "If the user has overridden the basic caching mechanisms, the user agent SHOULD explicitly indicate to the user whenever this results in the display of information that might not meet the server's transparency requirements (in particular, if the displayed entity is known to be stale). Since the protocol normally allows the user agent to determine if responses are stale or not, this indication need only be displayed when this actually happens. The indication need not be a dialog box; it could be an icon (for example, a picture of a rotting fish) or some other indicator.",
      "ja": "ユーザーは基本的なキャッシュメカニズムをオーバーライドしている場合、これは（表示されたエンティティが陳腐であることが知られている場合は、特に）サーバーの透明性の要件を満たしていない可能性があり、情報の表示になりたび、ユーザーエージェントは、ユーザーに明示的に示す必要があります。プロトコルは、通常、応答が失効されているかどうか判定するためにユーザーエージェントを可能にするので、これは実際に発生したとき、この指示は、表示される必要があります。表示は、ダイアログボックスである必要はありません。それは（例えば、腐った魚の絵）アイコンまたはいくつかの他のインジケータとすることができます。"
    },
    {
      "indent": 3,
      "text": "If the user has overridden the caching mechanisms in a way that would abnormally reduce the effectiveness of caches, the user agent SHOULD continually indicate this state to the user (for example, by a display of a picture of currency in flames) so that the user does not inadvertently consume excess resources or suffer from excessive latency.",
      "ja": "ユーザが異常キャッシュの有効性を減少させる方法でキャッシングメカニズムをオーバーライドしている場合、ユーザエージェントはユーザにこの状態を示して継続すべきである（例えば、炎の通貨の画像の表示によって）ユーザよううっかり過剰なリソースを消費したり過度の待ち時間を患っていません。"
    },
    {
      "indent": 0,
      "text": "13.1.5 Exceptions to the Rules and Warnings",
      "section_title": true,
      "ja": "ルールと警告する13.1.5例外"
    },
    {
      "indent": 3,
      "text": "In some cases, the operator of a cache MAY choose to configure it to return stale responses even when not requested by clients. This decision ought not be made lightly, but may be necessary for reasons of availability or performance, especially when the cache is poorly connected to the origin server. Whenever a cache returns a stale response, it MUST mark it as such (using a Warning header) enabling the client software to alert the user that there might be a potential problem.",
      "ja": "いくつかのケースでは、キャッシュのオペレータは、クライアントによって要求されていない場合でも、古くなったレスポンスを返すように設定することを選択するかもしれません。この決定は軽く作られるべきではないが、キャッシュが不十分オリジンサーバに接続している場合は特に、可用性やパフォーマンス上の理由から必要な場合があります。キャッシュが古くなったレスポンスを返すたびに、それは潜在的な問題があるかもしれないことをユーザに警告するために、クライアントソフトウェアを有効にする（警告ヘッダーを使用して）そのようにマークする必要があります。"
    },
    {
      "indent": 3,
      "text": "It also allows the user agent to take steps to obtain a first-hand or fresh response. For this reason, a cache SHOULD NOT return a stale response if the client explicitly requests a first-hand or fresh one, unless it is impossible to comply for technical or policy reasons.",
      "ja": "また、ユーザエージェントが最初の手や新鮮な応答を取得するための措置をとることができます。クライアントが明示的に最初の手や新鮮なものを要求した場合、技術的または政策的な理由のために遵守することは不可能でない限り、このような理由から、キャッシュは、古くなったレスポンスを返すべきではありません。"
    },
    {
      "indent": 0,
      "text": "13.1.6 Client-controlled Behavior",
      "section_title": true,
      "ja": "13.1.6クライアント制御の挙動"
    },
    {
      "indent": 3,
      "text": "While the origin server (and to a lesser extent, intermediate caches, by their contribution to the age of a response) are the primary source of expiration information, in some cases the client might need to control a cache's decision about whether to return a cached response without validating it. Clients do this using several directives of the Cache-Control header.",
      "ja": "オリジンサーバ（およびより少ない程度に、中間キャッシュは、レスポンスの年齢への貢献により）有効期限情報の主要なソースですが、いくつかのケースでは、クライアントはキャッシュされたを返すかどうかについてのキャッシュの決定を制御する必要がある場合がありますそれを検証せずに応答。クライアントは、こののCache-Controlヘッダのいくつかのディレクティブを使用してください。"
    },
    {
      "indent": 3,
      "text": "A client's request MAY specify the maximum age it is willing to accept of an unvalidated response; specifying a value of zero forces the cache(s) to revalidate all responses. A client MAY also specify the minimum time remaining before a response expires. Both of these options increase constraints on the behavior of caches, and so cannot further relax the cache's approximation of semantic transparency.",
      "ja": "クライアントの要求は、未検証応答を受け入れることを望んで最大の年齢を指定することもできます。ゼロの値を指定すると、すべての応答を再検証するためにキャッシュ（複数可）を強制します。また、クライアントは、応答の有効期限が切れる前に、残りの最小時間を指定してもよいです。これらのオプションのどちらも、キャッシュの行動に制約を延ばすため、さらに意味の透明性のキャッシュの近似値を緩和することはできません。"
    },
    {
      "indent": 3,
      "text": "A client MAY also specify that it will accept stale responses, up to some maximum amount of staleness. This loosens the constraints on the caches, and so might violate the origin server's specified constraints on semantic transparency, but might be necessary to support disconnected operation, or high availability in the face of poor connectivity.",
      "ja": "クライアントはまた、古さのいくつかの最大量までの古くなったレスポンスを、受け入れるように指定することができます。これは、キャッシュ上の制約を緩めると、その意味の透明性のオリジンサーバの指定された制約に違反するかもしれませんが、貧しい人々の接続の顔に切断操作、または高可用性をサポートする必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "13.2 Expiration Model",
      "section_title": true,
      "ja": "13.2有効期限モデル"
    },
    {
      "indent": 0,
      "text": "13.2.1 Server-Specified Expiration",
      "section_title": true,
      "ja": "13.2.1サーバ指定の有効期限"
    },
    {
      "indent": 3,
      "text": "HTTP caching works best when caches can entirely avoid making requests to the origin server. The primary mechanism for avoiding requests is for an origin server to provide an explicit expiration time in the future, indicating that a response MAY be used to satisfy subsequent requests. In other words, a cache can return a fresh response without first contacting the server.",
      "ja": "HTTPキャッシュはキャッシュが完全にオリジンサーバへの要求を避けることができたときに最適に動作します。リクエストを回避するための主要なメカニズムは、応答が後続の要求を満たすために使用され得ることを示し、将来的に明示的な有効期限を提供するために、オリジンサーバのためのものです。言い換えれば、キャッシュが最初のサーバーに接触することなく、新鮮な応答を返すことができます。"
    },
    {
      "indent": 3,
      "text": "Our expectation is that servers will assign future explicit expiration times to responses in the belief that the entity is not likely to change, in a semantically significant way, before the expiration time is reached. This normally preserves semantic transparency, as long as the server's expiration times are carefully chosen.",
      "ja": "私たちの期待はサーバが有効期限に達する前に、エンティティは、意味的に重要な方法で、変更される可能性はないという信念で応答に将来の明示的な有効期限を割り当てるということです。これは通常、サーバーの有効期限が慎重に選択されている限り、意味の透明性を維持します。"
    },
    {
      "indent": 3,
      "text": "The expiration mechanism applies only to responses taken from a cache and not to first-hand responses forwarded immediately to the requesting client.",
      "ja": "有効期限のメカニズムは、要求元のクライアントに即座に転送最初の手の応答にキャッシュから取られた応答にのみ適用されません。"
    },
    {
      "indent": 3,
      "text": "If an origin server wishes to force a semantically transparent cache to validate every request, it MAY assign an explicit expiration time in the past. This means that the response is always stale, and so the cache SHOULD validate it before using it for subsequent requests. See section 14.9.4 for a more restrictive way to force revalidation.",
      "ja": "オリジンサーバがすべての要求を検証するために意味的に透過キャッシュを強制したい場合、それは過去に明示的に有効期限を割り当てることができます。これは、応答は常に古いことを意味し、そのキャッシュが後続の要求のためにそれを使用する前にそれを検証する必要があります。再検証を強制するより限定的な方法については項14.9.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "If an origin server wishes to force any HTTP/1.1 cache, no matter how it is configured, to validate every request, it SHOULD use the \"must-revalidate\" cache-control directive (see section 14.9).",
      "ja": "オリジンサーバがすべての要求を検証するために、関係なく、それがどのように構成されるか、任意のHTTP / 1.1キャッシュを強制しないことを望む場合、それは（セクション14.9を参照してください）「MUST-再検証」キャッシュ制御ディレクティブを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Servers specify explicit expiration times using either the Expires header, or the max-age directive of the Cache-Control header.",
      "ja": "サーバーは有効期限のヘッダー、またはのCache-Controlヘッダのmax-ageディレクティブのいずれかを使用して明示的に有効期限を指定します。"
    },
    {
      "indent": 3,
      "text": "An expiration time cannot be used to force a user agent to refresh its display or reload a resource; its semantics apply only to caching mechanisms, and such mechanisms need only check a resource's expiration status when a new request for that resource is initiated. See section 13.13 for an explanation of the difference between caches and history mechanisms.",
      "ja": "有効期限は、その表示を更新したり、リソースを再ロードするためにユーザーエージェントを強制するために使用することはできません。そのセマンティクスはキャッシングメカニズムにのみ適用され、そしてそのようなメカニズムは、そのリソースに対する新しい要求が開始されたときに、リソースの有効期限の状態を確認するだけです。キャッシュと履歴メカニズムの違いの説明についてはセクション13.13を参照してください。"
    },
    {
      "indent": 0,
      "text": "13.2.2 Heuristic Expiration",
      "section_title": true,
      "ja": "13.2.2ヒューリスティック有効期限"
    },
    {
      "indent": 3,
      "text": "Since origin servers do not always provide explicit expiration times, HTTP caches typically assign heuristic expiration times, employing algorithms that use other header values (such as the Last-Modified time) to estimate a plausible expiration time. The HTTP/1.1 specification does not provide specific algorithms, but does impose worst-case constraints on their results. Since heuristic expiration times might compromise semantic transparency, they ought to used cautiously, and we encourage origin servers to provide explicit expiration times as much as possible.",
      "ja": "オリジンサーバは常に明示的に有効期限を提供しないので、HTTPキャッシュは、典型的にもっともらしい有効期限を推定するために（例えば、最終更新時刻などの）他のヘッダ値を使用するアルゴリズムを採用し、ヒューリスティック有効期限を割り当てます。 HTTP / 1.1仕様では、特定のアルゴリズムを提供していませんが、その結果に最悪の場合の制約を課すん。ヒューリスティック有効期限は、意味の透明性を損なう可能性があるので、慎重に使用するべき、と私たちは可能な限り明示的に有効期限を提供するために、オリジンサーバを奨励します。"
    },
    {
      "indent": 0,
      "text": "13.2.3 Age Calculations",
      "section_title": true,
      "ja": "13.2.3年齢計算"
    },
    {
      "indent": 3,
      "text": "In order to know if a cached entry is fresh, a cache needs to know if its age exceeds its freshness lifetime. We discuss how to calculate the latter in section 13.2.4; this section describes how to calculate the age of a response or cache entry.",
      "ja": "キャッシュされたエントリが新鮮であるかどうかを知るためには、キャッシュはその年齢がその新鮮寿命を超えたかどうかを知る必要があります。私たちは、セクション13.2.4で、後者の計算方法を話し合います。このセクションでは、レスポンスやキャッシュエントリの年齢を計算する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "In this discussion, we use the term \"now\" to mean \"the current value of the clock at the host performing the calculation.\" Hosts that use HTTP, but especially hosts running origin servers and caches, SHOULD use NTP [28] or some similar protocol to synchronize their clocks to a globally accurate time standard.",
      "ja": "この議論では、我々は意味し、「今すぐ」という用語を使用して「計算を行うホストのクロックの現在の値を。」特にHTTPを使用するホストが、オリジンサーバとキャッシュを実行しているホストは、NTP [28]またはグローバル正確な時刻標準に自分のクロックを同期するためにいくつかの類似したプロトコルを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 requires origin servers to send a Date header, if possible, with every response, giving the time at which the response was generated (see section 14.18). We use the term \"date_value\" to denote the value of the Date header, in a form appropriate for arithmetic operations.",
      "ja": "HTTP / 1.1は、（セクション14.18を参照してください）応答が生成された時間を与えて、可能な場合は、すべての応答で、Dateヘッダを送信するためにオリジンサーバが必要です。我々は、算術演算のために適切な形で、日付ヘッダの値を表すために、用語「DATE_VALUE」を使用します。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 uses the Age response-header to convey the estimated age of the response message when obtained from a cache. The Age field value is the cache's estimate of the amount of time since the response was generated or revalidated by the origin server.",
      "ja": "HTTP / 1.1は、キャッシュから取得したときに応答メッセージの推定年齢を伝えるため年齢レスポンスヘッダを使用します。 Ageフィールドの値は、応答が生成またはオリジンサーバで再検証してからの時間の量のキャッシュの推定値です。"
    },
    {
      "indent": 3,
      "text": "In essence, the Age value is the sum of the time that the response has been resident in each of the caches along the path from the origin server, plus the amount of time it has been in transit along network paths.",
      "ja": "本質的に、年齢の値は、応答がオリジンサーバから経路に沿ってキャッシュのそれぞれに常駐していた時間の合計、プラス、それは、ネットワーク経路に沿って走行していた時間の量です。"
    },
    {
      "indent": 3,
      "text": "We use the term \"age_value\" to denote the value of the Age header, in a form appropriate for arithmetic operations.",
      "ja": "我々は、算術演算のために適切な形で、年齢ヘッダの値を表すために、用語「age_value」を使用します。"
    },
    {
      "indent": 3,
      "text": "A response's age can be calculated in two entirely independent ways:",
      "ja": "レスポンスの年齢は、二つの完全に独立した方法で計算することができます。"
    },
    {
      "indent": 6,
      "text": "1. now minus date_value, if the local clock is reasonably well synchronized to the origin server's clock. If the result is negative, the result is replaced by zero.",
      "ja": "1.今マイナスDATE_VALUE、ローカルクロックが合理的にオリジンサーバのクロックに同期されている場合。結果が負の場合、結果はゼロに置き換えられます。"
    },
    {
      "indent": 6,
      "text": "2. age_value, if all of the caches along the response path implement HTTP/1.1.",
      "ja": "2. age_value、応答経路に沿ったキャッシュのすべてがHTTP / 1.1実装する場合。"
    },
    {
      "indent": 3,
      "text": "Given that we have two independent ways to compute the age of a response when it is received, we can combine these as",
      "ja": "我々はそれを受信したときの応答の年齢を計算するための2つの独立した方法を持っていることを考えると、我々は、これらを組み合わせることができます"
    },
    {
      "indent": 7,
      "text": "corrected_received_age = max(now - date_value, age_value)",
      "ja": "corrected_received_age = MAX（今 -  DATE_VALUE、age_value）"
    },
    {
      "indent": 3,
      "text": "and as long as we have either nearly synchronized clocks or all-HTTP/1.1 paths, one gets a reliable (conservative) result.",
      "ja": "そして限り、私たちはほぼ同期したクロックまたは全て-HTTP / 1.1のパスのいずれかを持っているように、一つは信頼性の高い（保守的な）結果を取得します。"
    },
    {
      "indent": 3,
      "text": "Because of network-imposed delays, some significant interval might pass between the time that a server generates a response and the time it is received at the next outbound cache or client. If uncorrected, this delay could result in improperly low ages.",
      "ja": "そのため、ネットワークに課した遅延のため、いくつかの重要な間隔は、サーバーが応答を生成し、時間は、それが次のアウトバウンドのキャッシュやクライアントで受信された時間の間を通過することがあります。補正されていない場合は、この遅延は不適当に低い年齢層につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Because the request that resulted in the returned Age value must have been initiated prior to that Age value's generation, we can correct for delays imposed by the network by recording the time at which the request was initiated. Then, when an Age value is received, it MUST be interpreted relative to the time the request was initiated, not the time that the response was received. This algorithm results in conservative behavior no matter how much delay is experienced. So, we compute:",
      "ja": "返さ年齢値になったリクエストはその年齢値の世代の前に開始されている必要があるため、私たちは、要求が開始された時刻を記録することにより、ネットワークによって課される遅延を補正することができます。年齢値が受信されたときに、その要求が開始された時刻ではなく、応答が受信された時刻に関連して解釈しなければなりません。このアルゴリズムは関係なく経験しているどのくらいの遅延保守的な行動になりません。そこで、我々は計算します"
    },
    {
      "indent": 6,
      "text": "corrected_initial_age = corrected_received_age + (now - request_time)",
      "ja": "corrected_initial_age = corrected_received_age +（今 -  REQUEST_TIME）"
    },
    {
      "indent": 3,
      "text": "where \"request_time\" is the time (according to the local clock) when the request that elicited this response was sent.",
      "ja": "ここで、「REQUEST_TIME」は、この応答を誘発し、要求が送信された時刻（ローカルクロックに応じて）です。"
    },
    {
      "indent": 3,
      "text": "Summary of age calculation algorithm, when a cache receives a response:",
      "ja": "キャッシュは、応答を受け取る年齢計算アルゴリズムの概要："
    },
    {
      "indent": 6,
      "text": "/*\n * age_value\n *      is the value of Age: header received by the cache with\n *              this response.\n * date_value\n *      is the value of the origin server's Date: header\n * request_time\n *      is the (local) time when the cache made the request\n *              that resulted in this cached response\n * response_time\n *      is the (local) time when the cache received the\n *              response\n * now\n *      is the current (local) time\n */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "apparent_age = max(0, response_time - date_value);\ncorrected_received_age = max(apparent_age, age_value);\nresponse_delay = response_time - request_time;\ncorrected_initial_age = corrected_received_age + response_delay;\nresident_time = now - response_time;\ncurrent_age   = corrected_initial_age + resident_time;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The current_age of a cache entry is calculated by adding the amount of time (in seconds) since the cache entry was last validated by the origin server to the corrected_initial_age. When a response is generated from a cache entry, the cache MUST include a single Age header field in the response with a value equal to the cache entry's current_age.",
      "ja": "キャッシュエントリのてcurrent_ageは、キャッシュエントリがcorrected_initial_ageにオリジンサーバによって最後に検証されてからの時間（秒数）を加算して算出されます。応答がキャッシュエントリから生成された場合、キャッシュは、キャッシュ・エントリのてcurrent_ageに等しい値に応じて、単一の年齢ヘッダーフィールドを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The presence of an Age header field in a response implies that a response is not first-hand. However, the converse is not true, since the lack of an Age header field in a response does not imply that the response is first-hand unless all caches along the request path are compliant with HTTP/1.1 (i.e., older HTTP caches did not implement the Age header field).",
      "ja": "応答における年齢ヘッダフィールドの存在は、応答が最初の手ではないことを意味します。応答における年齢ヘッダフィールドの欠如が要求パスに沿ってすべてのキャッシュがHTTP / 1.1（すなわちに準拠していない限り、応答は最初の手で、古いHTTPキャッシュがなかったことを意味するものではないので、逆は真ではありません）年齢ヘッダフィールドを実装します。"
    },
    {
      "indent": 0,
      "text": "13.2.4 Expiration Calculations",
      "section_title": true,
      "ja": "13.2.4有効期限の計算"
    },
    {
      "indent": 3,
      "text": "In order to decide whether a response is fresh or stale, we need to compare its freshness lifetime to its age. The age is calculated as described in section 13.2.3; this section describes how to calculate the freshness lifetime, and to determine if a response has expired. In the discussion below, the values can be represented in any form appropriate for arithmetic operations.",
      "ja": "応答が新鮮か古いであるかどうかを決定するために、我々はその年齢にその新鮮寿命を比較する必要があります。セクション13.2.3に記載されているように、年齢が算出されます。このセクションでは、新鮮寿命を計算し、その応答の期限が切れているかどうかを判断する方法について説明します。以下の説明では、値は算術演算のために適切な任意の形態で表現することができます。"
    },
    {
      "indent": 3,
      "text": "We use the term \"expires_value\" to denote the value of the Expires header. We use the term \"max_age_value\" to denote an appropriate value of the number of seconds carried by the \"max-age\" directive of the Cache-Control header in a response (see section 14.9.3).",
      "ja": "私たちは、Expiresヘッダの値を示すために、用語「expires_value」を使用します。私たちは、（セクション14.9.3を参照してください）応答のCache-Controlヘッダの「最大エージング」ディレクティブによって運ばれた秒数の適切な値を示すために、用語「max_age_value」を使用します。"
    },
    {
      "indent": 3,
      "text": "The max-age directive takes priority over Expires, so if max-age is present in a response, the calculation is simply:",
      "ja": "MAX-ageディレクティブは、max-年齢が応答に存在しているのであれば、計算は単純で、有効期限よりも優先されます："
    },
    {
      "indent": 6,
      "text": "freshness_lifetime = max_age_value",
      "ja": "freshness_lifetime = max_age_value"
    },
    {
      "indent": 3,
      "text": "Otherwise, if Expires is present in the response, the calculation is:",
      "ja": "応答中に存在している有効期限が切れるとそうでない場合、計算は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "freshness_lifetime = expires_value - date_value",
      "ja": "freshness_lifetime = expires_value  -  DATE_VALUE"
    },
    {
      "indent": 3,
      "text": "Note that neither of these calculations is vulnerable to clock skew, since all of the information comes from the origin server.",
      "ja": "すべての情報は、オリジンサーバから来ているので、これらの計算のどちらも、クロック・スキューに対して脆弱であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If none of Expires, Cache-Control: max-age, or Cache-Control: s-maxage (see section 14.9.3) appears in the response, and the response does not include other restrictions on caching, the cache MAY compute a freshness lifetime using a heuristic. The cache MUST attach Warning 113 to any response whose age is more than 24 hours if such warning has not already been added.",
      "ja": "MAXAGE、またはのCache-Control：のいずれも、のCache-Control期限切れない場合は、S-MAXAGE（セクション14.9.3を参照してください）応答に表示され、応答はキャッシュ上の他の制限が含まれていない、新鮮さを計算することができるキャッシュヒューリスティックを使用して寿命。キャッシュは、その年齢、そのような警告がまだ追加されていない場合は24時間以上である任意の応答に113警告添付する必要があります。"
    },
    {
      "indent": 3,
      "text": "Also, if the response does have a Last-Modified time, the heuristic expiration value SHOULD be no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.",
      "ja": "レスポンスがLast-Modifiedの時間を持っている場合も、ヒューリスティック有効期限の値はその時以来、間隔のある割合以下であってはなりません。この画分の典型的な設定は10％であるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The calculation to determine if a response has expired is quite simple:",
      "ja": "応答の期限が切れているかどうかを判断するための計算が非常に簡単です："
    },
    {
      "indent": 6,
      "text": "response_is_fresh = (freshness_lifetime > current_age)",
      "ja": "response_is_fresh =（鮮度寿命> CURRENT_PAGE）"
    },
    {
      "indent": 0,
      "text": "13.2.5 Disambiguating Expiration Values",
      "section_title": true,
      "ja": "13.2.5有効期限値を曖昧に"
    },
    {
      "indent": 3,
      "text": "Because expiration values are assigned optimistically, it is possible for two caches to contain fresh values for the same resource that are different.",
      "ja": "有効期限の値が楽観割り当てられているので2つのキャッシュが異なる同じリソースのための新鮮な値が含まれてすることが可能です。"
    },
    {
      "indent": 3,
      "text": "If a client performing a retrieval receives a non-first-hand response for a request that was already fresh in its own cache, and the Date header in its existing cache entry is newer than the Date on the new response, then the client MAY ignore the response. If so, it MAY retry the request with a \"Cache-Control: max-age=0\" directive (see section 14.9), to force a check with the origin server.",
      "ja": "検索を実行するクライアントは、すでに独自のキャッシュで新鮮でした要求に対する非最初の手の応答を受信して​​、その既存のキャッシュエントリ内のDateヘッダが新しいレスポンスの日付よりも新しい場合、クライアントは無視してもよい（MAY）応答。もしそうなら、それはして要求を再試行してもよい（MAY）「のCache-Control：最大エージング= 0」を指示し（セクション14.9を参照）、オリジンサーバとのチェックを強制します。"
    },
    {
      "indent": 3,
      "text": "If a cache has two fresh responses for the same representation with different validators, it MUST use the one with the more recent Date header. This situation might arise because the cache is pooling responses from other caches, or because a client has asked for a reload or a revalidation of an apparently fresh cache entry.",
      "ja": "キャッシュは異なるバリデータと同じ表現のための2つの新鮮なレスポンスを持っている場合、それはより多くの最近のDateヘッダを持つものを使用しなければなりません。キャッシュが他のキャッシュからの応答をプールしているため、またはクライアントがリロードまたは明らかに新鮮なキャッシュエントリの再検証を求めているため、このような状況が発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "13.2.6 Disambiguating Multiple Responses",
      "section_title": true,
      "ja": "13.2.6複数の応答を曖昧に"
    },
    {
      "indent": 3,
      "text": "Because a client might be receiving responses via multiple paths, so that some responses flow through one set of caches and other responses flow through a different set of caches, a client might receive responses in an order different from that in which the origin server sent them. We would like the client to use the most recently generated response, even if older responses are still apparently fresh.",
      "ja": "いくつかの応答がキャッシュの1つのセットを通って流れ、他の応答がキャッシュの異なるセットを流れるように、クライアントが複数のパスを経由して応答を受信する可能性があるため、クライアントはオリジンサーバがそれらを送っているとは異なる順序で応答を受け取ることがあります。私たちは、古いレスポンスがまだ明らかに新鮮であっても、クライアントが最後に生成された応答を使用したいと思います。"
    },
    {
      "indent": 3,
      "text": "Neither the entity tag nor the expiration value can impose an ordering on responses, since it is possible that a later response intentionally carries an earlier expiration time. The Date values are ordered to a granularity of one second.",
      "ja": "後に応答が意図的に以前の有効期限を運ぶことも可能であるため、エンティティタグや有効期限の値のいずれもが、応答に順序を課すことができます。日付値は、1秒の細かさに命じています。"
    },
    {
      "indent": 3,
      "text": "When a client tries to revalidate a cache entry, and the response it receives contains a Date header that appears to be older than the one for the existing entry, then the client SHOULD repeat the request unconditionally, and include",
      "ja": "クライアントがキャッシュエントリを再検証しようとし、それが受け取る応答は、既存のエントリの1よりも古いように見えるDateヘッダが含まれている場合、クライアントは無条件に要求を繰り返すと、含むべきです"
    },
    {
      "indent": 7,
      "text": "Cache-Control: max-age=0",
      "ja": "Cache-Control：最大エージング= 0"
    },
    {
      "indent": 3,
      "text": "to force any intermediate caches to validate their copies directly with the origin server, or",
      "ja": "オリジンサーバと直接自分のコピーを検証するために任意の中間キャッシュを強制する、またはします"
    },
    {
      "indent": 7,
      "text": "Cache-Control: no-cache",
      "ja": "Cache-Control：キャッシュなし"
    },
    {
      "indent": 3,
      "text": "to force any intermediate caches to obtain a new copy from the origin server.",
      "ja": "オリジンサーバから新しいコピーを取得するために任意の中間キャッシュを強制します。"
    },
    {
      "indent": 3,
      "text": "If the Date values are equal, then the client MAY use either response (or MAY, if it is being extremely prudent, request a new response). Servers MUST NOT depend on clients being able to choose deterministically between responses generated during the same second, if their expiration times overlap.",
      "ja": "日付値が等しい場合、クライアントは、（新しい応答を要求し、それは非常に賢明されている場合、またはMAY）応答のいずれかを使用するかもしれません。サーバーは、クライアントがその満了時間が重なった場合、同じ秒の間に生成された応答の間で決定論的に選択することができることに依存してはなりません。"
    },
    {
      "indent": 0,
      "text": "13.3 Validation Model",
      "section_title": true,
      "ja": "13.3検証モデル"
    },
    {
      "indent": 3,
      "text": "When a cache has a stale entry that it would like to use as a response to a client's request, it first has to check with the origin server (or possibly an intermediate cache with a fresh response) to see if its cached entry is still usable. We call this \"validating\" the cache entry. Since we do not want to have to pay the overhead of retransmitting the full response if the cached entry is good, and we do not want to pay the overhead of an extra round trip if the cached entry is invalid, the HTTP/1.1 protocol supports the use of conditional methods.",
      "ja": "キャッシュは、クライアントの要求に対する応答として使用したいという古いエントリを持っている場合、それは最初にキャッシュされたエントリがまだ使用可能かどうかを確認するためにオリジンサーバ（あるいは新鮮なレスポンスを持つ中間キャッシュ）に確認する必要があります。私たちは、この「有効」キャッシュエントリを呼び出します。私たちは、キャッシュされたエントリが良好であれば、完全な応答を再送するオーバーヘッドを支払うことをしたくない、とキャッシュされたエントリが無効な場合、私たちは余分なラウンドトリップのオーバーヘッドを支払うことをしたくない、HTTP / 1.1プロトコルがサポートするので、条件付きの方法の使用。"
    },
    {
      "indent": 3,
      "text": "The key protocol features for supporting conditional methods are those concerned with \"cache validators.\" When an origin server generates a full response, it attaches some sort of validator to it, which is kept with the cache entry. When a client (user agent or proxy cache) makes a conditional request for a resource for which it has a cache entry, it includes the associated validator in the request.",
      "ja": "条件付きメソッドをサポートするための主要なプロトコル機能は、に関するものであり、「キャッシュバリデータ。」オリジンサーバが完全な応答を生成するときに、キャッシュエントリに保持され、それにバリデータのいくつかの並べ替えを添付します。クライアント（ユーザエージェントまたはプロキシキャッシュ）がキャッシュエントリを持っているリソースのための条件付き要求を行う際に、その要求に関連したバリデータを含みます。"
    },
    {
      "indent": 3,
      "text": "The server then checks that validator against the current validator for the entity, and, if they match (see section 13.3.3), it responds with a special status code (usually, 304 (Not Modified)) and no entity-body. Otherwise, it returns a full response (including entity-body). Thus, we avoid transmitting the full response if the validator matches, and we avoid an extra round trip if it does not match.",
      "ja": "彼らは（セクション13.3.3を参照）と一致する場合、サーバは、その後、エンティティの現在のバリデータに対してそのバリデータをチェックし、そして、それは特別なステータスコード（通常、304（変更不可））と無エンティティボディで応答します。それ以外の場合は、（エンティティボディを含む）完全な応答を返します。したがって、我々は、バリデータが一致した場合、完全な応答を送信しないよう、それが一致しない場合、私たちは余分なラウンドトリップを避けます。"
    },
    {
      "indent": 3,
      "text": "In HTTP/1.1, a conditional request looks exactly the same as a normal request for the same resource, except that it carries a special header (which includes the validator) that implicitly turns the method (usually, GET) into a conditional.",
      "ja": "HTTP / 1.1では、条件付き要求は、それが条件に暗黙的方法を回す特別なヘッダを（バリデータを含む）（通常、GET）を担持することを除いて、同じリソースに対する通常の要求と全く同じに見えます。"
    },
    {
      "indent": 3,
      "text": "The protocol includes both positive and negative senses of cache-validating conditions. That is, it is possible to request either that a method be performed if and only if a validator matches or if and only if no validators match.",
      "ja": "プロトコルは、キャッシュ検証条件の正および負の感覚の両方を含みます。すなわち、いずれかの方法があればのみバリデータと一致する場合、または場合行わないバリデータが一致しない場合にのみすることを要求することが可能です。"
    },
    {
      "indent": 6,
      "text": "Note: a response that lacks a validator may still be cached, and served from cache until it expires, unless this is explicitly prohibited by a cache-control directive. However, a cache cannot do a conditional retrieval if it does not have a validator for the entity, which means it will not be refreshable after it expires.",
      "ja": "注意：バリデータが欠けている応答がまだキャッシュされ、これは明示的にキャッシュ制御ディレクティブで禁止されていない限り、それは、有効期限が切れるまでキャッシュから提供することができます。それが満了した後、それがリフレッシュされないことを意味するエンティティのためのバリデータを持っていない場合は、キャッシュは条件検索を行うことができません。"
    },
    {
      "indent": 0,
      "text": "13.3.1 Last-Modified Dates",
      "section_title": true,
      "ja": "13.3.1のLast-Modified日付"
    },
    {
      "indent": 3,
      "text": "The Last-Modified entity-header field value is often used as a cache validator. In simple terms, a cache entry is considered to be valid if the entity has not been modified since the Last-Modified value.",
      "ja": "Last-Modifiedエンティティヘッダフィールド値はしばしばキャッシュバリデータとして使用されています。簡単に言えば、キャッシュエントリは、エンティティがLast-Modifiedの値から変更されていない場合に有効であると考えられています。"
    },
    {
      "indent": 0,
      "text": "13.3.2 Entity Tag Cache Validators",
      "section_title": true,
      "ja": "13.3.2エンティティタグのキャッシュバリ"
    },
    {
      "indent": 3,
      "text": "The ETag response-header field value, an entity tag, provides for an \"opaque\" cache validator. This might allow more reliable validation in situations where it is inconvenient to store modification dates, where the one-second resolution of HTTP date values is not sufficient, or where the origin server wishes to avoid certain paradoxes that might arise from the use of modification dates.",
      "ja": "ETagレスポンスヘッダフィールド値、エンティティタグは、「不透明な」キャッシュ・バリデータを提供します。これは、HTTP日付値の1秒の解像度が十分でない、またはオリジンサーバは、変更日の使用から生じる可能性のある特定のパラドックスを避けたい場所、それが店の修正日に不便である状況で、より信頼性の検証を、許可するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Entity Tags are described in section 3.11. The headers used with entity tags are described in sections 14.19, 14.24, 14.26 and 14.44.",
      "ja": "エンティティタグは、セクション3.11で説明されています。エンティティタグと共に使用されるヘッダはセクション14.19、14.24、14.26及び14.44に記載されています。"
    },
    {
      "indent": 0,
      "text": "13.3.3 Weak and Strong Validators",
      "section_title": true,
      "ja": "13.3.3弱いと強いバリ"
    },
    {
      "indent": 3,
      "text": "Since both origin servers and caches will compare two validators to decide if they represent the same or different entities, one normally would expect that if the entity (the entity-body or any entity-headers) changes in any way, then the associated validator would change as well. If this is true, then we call this validator a \"strong validator.\"",
      "ja": "オリジンサーバとキャッシュの両方が、彼らは同じまたは異なるエンティティを表すかどうかを判断するために、2つのバリデータを比較しますので、一つは通常期待されるものであれば、エンティティ（エンティティボディまたは任意のエンティティヘッダ）どのような方法の変化、そして関連するバリデータは希望同様に変更します。これが本当であれば、私たちは「強いバリ。」このバリデータを呼び出します"
    },
    {
      "indent": 3,
      "text": "However, there might be cases when a server prefers to change the validator only on semantically significant changes, and not when insignificant aspects of the entity change. A validator that does not always change when the resource changes is a \"weak validator.\"",
      "ja": "サーバが唯一の意味的に重要な変更にバリデータを変更することを好む、といないとき、エンティティの変更の些細な側面しかし、ケースがあるかもしれません。リソースの変更は常に変化していないバリデータは「弱いバリデータ」です。"
    },
    {
      "indent": 3,
      "text": "Entity tags are normally \"strong validators,\" but the protocol provides a mechanism to tag an entity tag as \"weak.\" One can think of a strong validator as one that changes whenever the bits of an entity changes, while a weak value changes whenever the meaning of an entity changes. Alternatively, one can think of a strong validator as part of an identifier for a specific entity, while a weak validator is part of an identifier for a set of semantically equivalent entities.",
      "ja": "エンティティタグ「は、強力なバリデータ」は、通常であるが、プロトコルは、ASエンティティタグをタグ付けするためのメカニズムを提供「弱いです」。一つは、エンティティの意味が変更されるたびに、弱い値が変化しながら、エンティティの変更のたびビットを変更するものとして強いバリデータと考えることができます。弱いバリデータが意味的に等価なエンティティのセットのための識別子の一部である別の方法として、一つは、特定のエンティティの識別子の一部などの強力なバリデータと考えることができます。"
    },
    {
      "indent": 6,
      "text": "Note: One example of a strong validator is an integer that is incremented in stable storage every time an entity is changed.",
      "ja": "注：強力なバリデータの一例は、安定したストレージにエンティティが変更されるたびに増分される整数です。"
    },
    {
      "indent": 6,
      "text": "An entity's modification time, if represented with one-second resolution, could be a weak validator, since it is possible that the resource might be modified twice during a single second.",
      "ja": "リソースが単一の第2中に2回変更される可能性があるということができるので、エンティティの変更時間は、1秒の分解能で表されている場合、弱いバリデータである可能性があります。"
    },
    {
      "indent": 6,
      "text": "Support for weak validators is optional. However, weak validators allow for more efficient caching of equivalent objects; for example, a hit counter on a site is probably good enough if it is updated every few days or weeks, and any value during that period is likely \"good enough\" to be equivalent.",
      "ja": "弱いバリデータのサポートはオプションです。しかし、弱いバリデータは、同等のオブジェクトのより効率的なキャッシングを可能にします。それはすべての数日または数週間を更新し、その期間中の任意の値が同等である可能性が高い「十分」であるされている場合、たとえば、サイト上のヒットカウンタは、おそらく十分です。"
    },
    {
      "indent": 3,
      "text": "A \"use\" of a validator is either when a client generates a request and includes the validator in a validating header field, or when a server compares two validators.",
      "ja": "サーバは、2つのバリデータを比較したときにクライアントが要求を生成して検証ヘッダフィールドにバリデータを含む、またはいずれかのときにバリデータの「使用」があります。"
    },
    {
      "indent": 3,
      "text": "Strong validators are usable in any context. Weak validators are only usable in contexts that do not depend on exact equality of an entity. For example, either kind is usable for a conditional GET of a full entity. However, only a strong validator is usable for a sub-range retrieval, since otherwise the client might end up with an internally inconsistent entity.",
      "ja": "強力なバリデータは、任意のコンテキストで使用可能です。弱いバリデータは、エンティティの正確な等価性に依存しないコンテキストでのみ使用可能です。例えば、いずれかの種類は、完全なエンティティの条件付きGETのために使用可能です。そうでない場合、クライアントが内部矛盾エンティティに終わるかもしれないので、唯一の強力なバリデータは、サブ範囲の検索のために使用可能です。"
    },
    {
      "indent": 3,
      "text": "Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.",
      "ja": "クライアントは、単純な（非サブレンジ）を発行し、弱いバリデータや強いバリデータのいずれかとのリクエストを得ることができます。クライアントは、要求の他の形態で弱いバリデータを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "The only function that the HTTP/1.1 protocol defines on validators is comparison. There are two validator comparison functions, depending on whether the comparison context allows the use of weak validators or not:",
      "ja": "HTTP / 1.1プロトコルは、バリデータに定義のみ機能は比較です。比較コンテキストが弱いバリデータかどうかの使用を許可するかどうかに応じて、2つのバリデータの比較機能は、あります。"
    },
    {
      "indent": 6,
      "text": "- The strong comparison function: in order to be considered equal, both validators MUST be identical in every way, and both MUST NOT be weak.",
      "ja": " - 強い比較機能：等しいと見なされるためには、両方のバリデータはあらゆる方法で同じでなければならない、との両方が弱いしているはずがありません。"
    },
    {
      "indent": 6,
      "text": "- The weak comparison function: in order to be considered equal, both validators MUST be identical in every way, but either or both of them MAY be tagged as \"weak\" without affecting the result.",
      "ja": " - 弱い比較機能：等しいと見なされるためには、両方のバリデータは、あらゆる方法で同一でなければならないが、それらのいずれかまたは両方が結果に影響を与えることなく、「弱い」としてタグ付けすることができます。"
    },
    {
      "indent": 3,
      "text": "An entity tag is strong unless it is explicitly tagged as weak. Section 3.11 gives the syntax for entity tags.",
      "ja": "それが明示的に弱いとしてタグ付けされていない限り、エンティティタグは強いです。セクション3.11は、エンティティタグの構文を示します。"
    },
    {
      "indent": 3,
      "text": "A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules:",
      "ja": "最終更新時刻は、要求の中のバリデータとして使用した場合、次の規則を使用して、それが強いと推定することが可能である場合を除き、暗黙的に弱いです。"
    },
    {
      "indent": 6,
      "text": "- The validator is being compared by an origin server to the actual current validator for the entity and,",
      "ja": " - バリデータは、エンティティの実際の現在のバリデータにオリジンサーバによって比較しています、"
    },
    {
      "indent": 6,
      "text": "- That origin server reliably knows that the associated entity did not change twice during the second covered by the presented validator.",
      "ja": " - それオリジンサーバは、確実に関連するエンティティが提示バリでカバー第二中に2回変更されていないことを知っています。"
    },
    {
      "indent": 3,
      "text": "or",
      "ja": "または"
    },
    {
      "indent": 6,
      "text": "- The validator is about to be used by a client in an If-Modified-Since or If-Unmodified-Since header, because the client has a cache entry for the associated entity, and",
      "ja": " - バリデータは、クライアントが関連するエンティティのためのキャッシュエントリを有しているので、もし変性-ので場合、または非改変-ので、ヘッダにクライアントによって使用されようとしている、および"
    },
    {
      "indent": 6,
      "text": "- That cache entry includes a Date value, which gives the time when the origin server sent the original response, and",
      "ja": " - そのキャッシュエントリがオリジンサーバが元の応答を送信した時刻を与えるDate値を含み、"
    },
    {
      "indent": 6,
      "text": "- The presented Last-Modified time is at least 60 seconds before the Date value.",
      "ja": " - 提示のLast-Modified時間が日付値前に、少なくとも60秒です。"
    },
    {
      "indent": 3,
      "text": "or",
      "ja": "または"
    },
    {
      "indent": 6,
      "text": "- The validator is being compared by an intermediate cache to the validator stored in its cache entry for the entity, and",
      "ja": " - バリデータは、エンティティのキ​​ャッシュエントリに格納されたバリの中間キャッシュによって比較し、されています"
    },
    {
      "indent": 6,
      "text": "- That cache entry includes a Date value, which gives the time when the origin server sent the original response, and",
      "ja": " - そのキャッシュエントリがオリジンサーバが元の応答を送信した時刻を与えるDate値を含み、"
    },
    {
      "indent": 6,
      "text": "- The presented Last-Modified time is at least 60 seconds before the Date value.",
      "ja": " - 提示のLast-Modified時間が日付値前に、少なくとも60秒です。"
    },
    {
      "indent": 3,
      "text": "This method relies on the fact that if two different responses were sent by the origin server during the same second, but both had the same Last-Modified time, then at least one of those responses would have a Date value equal to its Last-Modified time. The arbitrary 60- second limit guards against the possibility that the Date and Last-Modified values are generated from different clocks, or at somewhat different times during the preparation of the response. An implementation MAY use a value larger than 60 seconds, if it is believed that 60 seconds is too short.",
      "ja": "この方法は、二つの異なるレスポンスが同じ秒の間、オリジンサーバによって送信されますが、両方が同じ最終更新時刻を持っていた場合、それらの応答の少なくとも一つはそのLast-Modifiedのと同じ日付値を持っているという事実に依存しています時間。日付およびLast-Modifiedの値が応答の調製中に異なるクロックから、または幾分異なる時間に生成される可能性に対して任意60-第二限界ガード。 60秒は短すぎると考えられている場合、実装は、60秒以上の値を使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "If a client wishes to perform a sub-range retrieval on a value for which it has only a Last-Modified time and no opaque validator, it MAY do this only if the Last-Modified time is strong in the sense described here.",
      "ja": "クライアントは、それが唯一のLast-Modified時間なし、不透明なバリデータを持っている値にサブ範囲検索を実行したい場合、それは最終更新時刻は、ここで説明した意味での強い場合にのみ、これを行うことができます。"
    },
    {
      "indent": 3,
      "text": "A cache or origin server receiving a conditional request, other than a full-body GET request, MUST use the strong comparison function to evaluate the condition.",
      "ja": "フルボディGETリクエスト以外の条件付きリクエストを受信キャッシュやオリジンサーバは、条件を評価するために強い比較機能を使わなければなりません。"
    },
    {
      "indent": 3,
      "text": "These rules allow HTTP/1.1 caches and clients to safely perform sub-range retrievals on values that have been obtained from HTTP/1.0 servers.",
      "ja": "これらのルールは、HTTP / 1.1キャッシュやクライアントが安全にHTTP / 1.0サーバから得られた値にサブレンジ回収のを実行することができます。"
    },
    {
      "indent": 0,
      "text": "13.3.4 Rules for When to Use Entity Tags and Last-Modified Dates",
      "section_title": true,
      "ja": "エンティティタグとLast-Modifiedの日付を使用するときのための13.3.4のルール"
    },
    {
      "indent": 3,
      "text": "We adopt a set of rules and recommendations for origin servers, clients, and caches regarding when various validator types ought to be used, and for what purposes.",
      "ja": "私たちは、さまざまなバリデータタイプが使用されるべき、と何の目的でに関するオリジンサーバ、クライアント、およびキャッシュのためのルールや推奨事項のセットを採用しています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 origin servers:",
      "ja": "HTTP / 1.1オリジンサーバ："
    },
    {
      "indent": 6,
      "text": "- SHOULD send an entity tag validator unless it is not feasible to generate one.",
      "ja": " -  1を生成することは不可能でない限り、エンティティタグバリデータを送るべきです。"
    },
    {
      "indent": 6,
      "text": "- MAY send a weak entity tag instead of a strong entity tag, if performance considerations support the use of weak entity tags, or if it is unfeasible to send a strong entity tag.",
      "ja": " - パフォーマンスの考慮が弱いエンティティタグの使用をサポートしている場合、強いエンティティタグの代わりに弱いエンティティタグを送ったり、強いエンティティタグを送信することは実現不可能である場合にしてもよい（MAY）。"
    },
    {
      "indent": 6,
      "text": "- SHOULD send a Last-Modified value if it is feasible to send one, unless the risk of a breakdown in semantic transparency that could result from using this date in an If-Modified-Since header would lead to serious problems.",
      "ja": " -  1を送信することが可能であるならば、Last-Modifiedの値を送るべきでない限り、この日付を使用することから生じる可能性の意味的透明性の崩壊の危険場合 - 変更-Sinceヘッダが深刻な問題につながります。"
    },
    {
      "indent": 3,
      "text": "In other words, the preferred behavior for an HTTP/1.1 origin server is to send both a strong entity tag and a Last-Modified value.",
      "ja": "言い換えれば、HTTP / 1.1オリジンサーバのための好適な動作は、強いエンティティタグとLast-Modified値の両方を送信することです。"
    },
    {
      "indent": 3,
      "text": "In order to be legal, a strong entity tag MUST change whenever the associated entity value changes in any way. A weak entity tag SHOULD change whenever the associated entity changes in a semantically significant way.",
      "ja": "合法的であるために、強いエンティティタグは、何らかの方法でたびに関連付けられたエンティティ値の変更を変更しなければなりません。関連するエンティティを意味的に重要な方法で変更されるたびに弱いエンティティタグを変更する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: in order to provide semantically transparent caching, an origin server must avoid reusing a specific strong entity tag value for two different entities, or reusing a specific weak entity tag value for two semantically different entities. Cache entries might persist for arbitrarily long periods, regardless of expiration times, so it might be inappropriate to expect that a cache will never again attempt to validate an entry using a validator that it obtained at some point in the past.",
      "ja": "注意：意味的に透過キャッシングを提供するために、オリジンサーバは、二つの異なるエンティティのための特定の強いエンティティタグ値を再利用する、または2つの意味的に異なるエンティティのための特定の弱いエンティティタグ値の再利用を避けなければなりません。キャッシュエントリは関係なく、有効期限の、任意の長期間持続可能性があるので、キャッシュは再び、それは過去のある時点で取得したバリデータを使用してエントリを検証しようとしないことを期待するのは不適切かもしれません。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 clients:",
      "ja": "HTTP / 1.1クライアント："
    },
    {
      "indent": 6,
      "text": "- If an entity tag has been provided by the origin server, MUST use that entity tag in any cache-conditional request (using If-Match or If-None-Match).",
      "ja": " - エンティティタグがオリジンサーバによって提供されている場合、任意のキャッシュ条件付き要求にそのエンティティタグを使用しなければならない（もしマッチまたは場合-なしマッチ使用）。"
    },
    {
      "indent": 6,
      "text": "- If only a Last-Modified value has been provided by the origin server, SHOULD use that value in non-subrange cache-conditional requests (using If-Modified-Since).",
      "ja": " -  Last-Modified値のみがオリジンサーバによって提供されている場合は、（変更される場合は--以来使用して）非サブレンジキャッシュ条件付きリクエストでその値を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "- If only a Last-Modified value has been provided by an HTTP/1.0 origin server, MAY use that value in subrange cache-conditional requests (using If-Unmodified-Since:). The user agent SHOULD provide a way to disable this, in case of difficulty.",
      "ja": " -  Last-Modified値のみがHTTP / 1.0オリジンサーバによって提供されている場合は、サブレンジキャッシュ条件付きリクエスト（場合非改変-以来使用して:)でその値を使用するかもしれません。ユーザエージェントは、困難な場合には、これを無効にする方法を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "- If both an entity tag and a Last-Modified value have been provided by the origin server, SHOULD use both validators in cache-conditional requests. This allows both HTTP/1.0 and HTTP/1.1 caches to respond appropriately.",
      "ja": " - エンティティタグとLast-Modified値の両方がオリジンサーバによって提供されている場合は、キャッシュ条件付きリクエストの両方のバリデータを使うべきです。これは、両方のHTTP / 1.0およびHTTP / 1.1キャッシュが適切に対応することができます。"
    },
    {
      "indent": 3,
      "text": "An HTTP/1.1 origin server, upon receiving a conditional request that includes both a Last-Modified date (e.g., in an If-Modified-Since or If-Unmodified-Since header field) and one or more entity tags (e.g., in an If-Match, If-None-Match, or If-Range header field) as cache validators, MUST NOT return a response status of 304 (Not Modified) unless doing so is consistent with all of the conditional header fields in the request.",
      "ja": "例えば（および1つまたは複数のエンティティタグに（もし修飾-ので又は場合-ので非改変ヘッダフィールドに、例えば）最終更新日時の両方を含む条件付きの要求を受信するHTTP / 1.1オリジンサーバ、場合 - なし - マッチキャッシュバリデータとして、304の応答ステータスを返してはならない場合はレンジヘッダフィールド）場合はマッチ、または（そうすることが要求における条件付きヘッダフィールドのすべてと一致していない限り）変更されていません。"
    },
    {
      "indent": 3,
      "text": "An HTTP/1.1 caching proxy, upon receiving a conditional request that includes both a Last-Modified date and one or more entity tags as cache validators, MUST NOT return a locally cached response to the client unless that cached response is consistent with all of the conditional header fields in the request.",
      "ja": "HTTP / 1.1キャッシュプロキシ、そのキャッシュされた応答は、すべてのと一致していない限りキャッシュバリデータとして最終更新日時と1つ以上のエンティティタグの両方が含ま条件付きリクエストを受信すると、クライアントにローカルにキャッシュされたレスポンスを返してはなりません要求の条件ヘッダフィールド。"
    },
    {
      "indent": 6,
      "text": "Note: The general principle behind these rules is that HTTP/1.1 servers and clients should transmit as much non-redundant information as is available in their responses and requests. HTTP/1.1 systems receiving this information will make the most conservative assumptions about the validators they receive.",
      "ja": "注：これらのルールの背後にある一般的な原則は、その応答やリクエストで利用可能であるとしてHTTP / 1.1サーバとクライアントが同じくらい非冗長情報を送信すべきであるということです。この情報を受信するHTTP / 1.1システムでは、彼らが受け取るバリデータについての最も保守的な仮定を行います。"
    },
    {
      "indent": 6,
      "text": "HTTP/1.0 clients and caches will ignore entity tags. Generally, last-modified values received or used by these systems will support transparent and efficient caching, and so HTTP/1.1 origin servers should provide Last-Modified values. In those rare cases where the use of a Last-Modified value as a validator by an HTTP/1.0 system could result in a serious problem, then HTTP/1.1 origin servers should not provide one.",
      "ja": "HTTP / 1.0クライアントとキャッシュはエンティティタグを無視します。一般的に、最後に変更された値は、受信または透明で効率的なキャッシングをサポートするこれらのシステムで使用され、そのHTTP / 1.1オリジンサーバはLast-Modifiedの値を提供する必要があります。 HTTP / 1.0システムにより、バリなどのLast-Modified値の使用は深刻な問題につながる可能性があり、それらのまれなケースでは、その後、HTTP / 1.1オリジンサーバは、1を提供してはなりません。"
    },
    {
      "indent": 0,
      "text": "13.3.5 Non-validating Conditionals",
      "section_title": true,
      "ja": "13.3.5非検証を条件文"
    },
    {
      "indent": 3,
      "text": "The principle behind entity tags is that only the service author knows the semantics of a resource well enough to select an appropriate cache validation mechanism, and the specification of any validator comparison function more complex than byte-equality would open up a can of worms. Thus, comparisons of any other headers (except Last-Modified, for compatibility with HTTP/1.0) are never used for purposes of validating a cache entry.",
      "ja": "エンティティタグの原理は、サービス作成者が適切なキャッシュ検証メカニズムを選択しても十分なリソース、およびワームの缶を開けるだろうバイト平等よりも複雑な任意のバリデータの比較機能の仕様の意味を知っているということです。このように、（HTTP / 1.0との互換性のため、-最終更新日を除く）他のヘッダの比較は、キャッシュエントリを検証する目的のために使用されることはありません。"
    },
    {
      "indent": 0,
      "text": "13.4 Response Cacheability",
      "section_title": true,
      "ja": "13.4レスポンスキャッシング可能"
    },
    {
      "indent": 3,
      "text": "Unless specifically constrained by a cache-control (section 14.9) directive, a caching system MAY always store a successful response (see section 13.8) as a cache entry, MAY return it without validation if it is fresh, and MAY return it after successful validation. If there is neither a cache validator nor an explicit expiration time associated with a response, we do not expect it to be cached, but certain caches MAY violate this expectation (for example, when little or no network connectivity is available). A client can usually detect that such a response was taken from a cache by comparing the Date header to the current time.",
      "ja": "特にキャッシュ制御（セクション14.9）指令によって制約されない限り、常に正常な応答を格納することができるキャッシュシステムは、キャッシュエントリとして（セクション13.8を参照）、それが新鮮であれば、検証せずにそれを返すことができ、検証が成功した後、それを返すかもしれません。キャッシュバリデータも応答に関連する明示的な有効期限もないがあれば、我々はそれがキャッシュされることを期待していないが、特定のキャッシュはこの期待に違反する可能性（例えば、ほとんど、あるいは全くネットワーク接続が利用可能な場合）。クライアントは通常、このような応答は、現在の時刻に日付ヘッダを比較することにより、キャッシュから取られたことを検出することができます。"
    },
    {
      "indent": 6,
      "text": "Note: some HTTP/1.0 caches are known to violate this expectation without providing any Warning.",
      "ja": "注意：一部のHTTP / 1.0キャッシュはどんな警告を提供せずに、この期待に違反することが知られています。"
    },
    {
      "indent": 3,
      "text": "However, in some cases it might be inappropriate for a cache to retain an entity, or to return it in response to a subsequent request. This might be because absolute semantic transparency is deemed necessary by the service author, or because of security or privacy considerations. Certain cache-control directives are therefore provided so that the server can indicate that certain resource entities, or portions thereof, are not to be cached regardless of other considerations.",
      "ja": "しかし、いくつかのケースでは、エンティティを保持するキャッシュには不適切かもしれない、または後続の要求に応答して、それを返すこと。これは絶対的な意味論的な透明性がサービスの著者によって必要と判断されたためである、か、セキュリティやプライバシーの配慮のかもしれません。サーバは、特定のリソースエンティティ、またはその一部は、関係なく、他の考慮事項のキャッシュされていないことを示すことができるように、特定のキャッシュ制御ディレクティブしたがって設けられています。"
    },
    {
      "indent": 3,
      "text": "Note that section 14.8 normally prevents a shared cache from saving and returning a response to a previous request if that request included an Authorization header.",
      "ja": "14.8は、通常、その要求は、Authorizationヘッダが含まれている場合、以前の要求への応答を保存して戻るの共有キャッシュを防止する部分に留意されたいです。"
    },
    {
      "indent": 3,
      "text": "A response received with a status code of 200, 203, 206, 300, 301 or 410 MAY be stored by a cache and used in reply to a subsequent request, subject to the expiration mechanism, unless a cache-control directive prohibits caching. However, a cache that does not support the Range and Content-Range headers MUST NOT cache 206 (Partial Content) responses.",
      "ja": "キャッシュ制御指令がキャッシングを禁止しない限り、200、203、206、300、301または410のステータスコードと受信した応答は、有効期限機構に従う、キャッシュによって記憶され、後続の要求に対する応答に使用されるかもしれません。しかし、レンジ及びコンテンツレンジヘッダをサポートしていないキャッシュは206（部分コンテンツ）レスポンスをキャッシュしてはなりません。"
    },
    {
      "indent": 3,
      "text": "A response received with any other status code (e.g. status codes 302 and 307) MUST NOT be returned in a reply to a subsequent request unless there are cache-control directives or another header(s) that explicitly allow it. For example, these include the following: an Expires header (section 14.21); a \"max-age\", \"s-maxage\", \"must-revalidate\", \"proxy-revalidate\", \"public\" or \"private\" cache-control directive (section 14.9).",
      "ja": "キャッシュ制御ディレクティブまたは明示的に許可し、別のヘッダ（単数または複数）がない限り（例えば、ステータスコード302及び307）、他のステータスコードと、受信した応答は、後続の要求に対する応答で返されてはいけません。例えば、これらは、以下を含む：Expiresヘッダ（セクション14.21）を、 \"MAXAGE\"、 \"S-MAXAGE\"、 \"MUST-再検証\"、 \"プロキシ再検証\"、 \"パブリック\" または \"プライベート\" キャッシュ制御ディレクティブ（セクション14.9）。"
    },
    {
      "indent": 0,
      "text": "13.5 Constructing Responses From Caches",
      "section_title": true,
      "ja": "キャッシュからの13.5構築の回答"
    },
    {
      "indent": 3,
      "text": "The purpose of an HTTP cache is to store information received in response to requests for use in responding to future requests. In many cases, a cache simply returns the appropriate parts of a response to the requester. However, if the cache holds a cache entry based on a previous response, it might have to combine parts of a new response with what is held in the cache entry.",
      "ja": "HTTPキャッシュの目的は、将来の要求に応答での使用のための要求に応じて受信した情報を格納することです。多くの場合、キャッシュは単に依頼者への応答の適切な部分を返します。キャッシュは、以前の応答に基づいて、キャッシュエントリを保持している場合は、それがキャッシュエントリに保持されているものを使用して新しい応答のパーツを組み合わせることが必要になる場合があります。"
    },
    {
      "indent": 0,
      "text": "13.5.1 End-to-end and Hop-by-hop Headers",
      "section_title": true,
      "ja": "13.5.1エンドツーエンド・ツーとホップバイホップヘッダ"
    },
    {
      "indent": 3,
      "text": "For the purpose of defining the behavior of caches and non-caching proxies, we divide HTTP headers into two categories:",
      "ja": "キャッシュや非キャッシュプロキシの動作を定義する目的のために、我々は二つのカテゴリーにHTTPヘッダを分割します："
    },
    {
      "indent": 6,
      "text": "- End-to-end headers, which are transmitted to the ultimate recipient of a request or response. End-to-end headers in responses MUST be stored as part of a cache entry and MUST be transmitted in any response formed from a cache entry.",
      "ja": " - 要求または応答の最終的な受信者に送信されるエンドツーエンドヘッダ。応答におけるエンドツーエンドヘッダはキャッシュエントリの一部として格納する必要があり、キャッシュエントリから形成される任意の応答で送信されなければなりません。"
    },
    {
      "indent": 6,
      "text": "- Hop-by-hop headers, which are meaningful only for a single transport-level connection, and are not stored by caches or forwarded by proxies.",
      "ja": " - 単一のトランスポート・レベルの接続のために意味のあるホップバイホップヘッダ、およびキャッシュによって記憶またはプロキシによって転送されません。"
    },
    {
      "indent": 3,
      "text": "The following HTTP/1.1 headers are hop-by-hop headers:",
      "ja": "以下のHTTP / 1.1ヘッダはホップバイホップヘッダは以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "- Connection - Keep-Alive - Proxy-Authenticate - Proxy-Authorization - TE - Trailers - Transfer-Encoding - Upgrade",
      "ja": " - 接続 - キープアライブ - プロキシ認証 - プロキシ認証 -  TE  - トレーラー - 転送 - エンコード - アップグレード"
    },
    {
      "indent": 3,
      "text": "All other headers defined by HTTP/1.1 are end-to-end headers.",
      "ja": "HTTP / 1.1で定義された他のすべてのヘッダーは、エンドツーエンドのヘッダーです。"
    },
    {
      "indent": 3,
      "text": "Other hop-by-hop headers MUST be listed in a Connection header, (section 14.10) to be introduced into HTTP/1.1 (or later).",
      "ja": "他のホップバイホップヘッダは接続ヘッダ、HTTP / 1.1（またはそれ以降）に導入される（セクション14.10）にリストされなければなりません。"
    },
    {
      "indent": 0,
      "text": "13.5.2 Non-modifiable Headers",
      "section_title": true,
      "ja": "13.5.2変更できないヘッダ"
    },
    {
      "indent": 3,
      "text": "Some features of the HTTP/1.1 protocol, such as Digest Authentication, depend on the value of certain end-to-end headers. A transparent proxy SHOULD NOT modify an end-to-end header unless the definition of that header requires or specifically allows that.",
      "ja": "このようなダイジェスト認証などのHTTP / 1.1プロトコルのいくつかの特徴は、特定のエンド・ツー・エンドのヘッダの値に依存します。そのヘッダの定義が必要または特異ことを可能にしない限り、透過プロキシは、エンドツーエンドのヘッダを変更しないでください。"
    },
    {
      "indent": 3,
      "text": "A transparent proxy MUST NOT modify any of the following fields in a request or response, and it MUST NOT add any of these fields if not already present:",
      "ja": "透過プロキシは、要求または応答で、次のいずれかのフィールドを変更してはいけませんし、まだ存在しない場合には、これらのフィールドのいずれかを追加しないでください。"
    },
    {
      "indent": 6,
      "text": "- Content-Location",
      "ja": " - コンテンツの場所"
    },
    {
      "indent": 6,
      "text": "- Content-MD5",
      "ja": " - のContent-MD5"
    },
    {
      "indent": 6,
      "text": "- ETag",
      "ja": " - のETag"
    },
    {
      "indent": 6,
      "text": "- Last-Modified",
      "ja": "- 最終更新日"
    },
    {
      "indent": 3,
      "text": "A transparent proxy MUST NOT modify any of the following fields in a response:",
      "ja": "透過プロキシは、応答で、次のいずれかのフィールドを変更してはいけません。"
    },
    {
      "indent": 6,
      "text": "- Expires",
      "ja": " - 有効期限"
    },
    {
      "indent": 3,
      "text": "but it MAY add any of these fields if not already present. If an Expires header is added, it MUST be given a field-value identical to that of the Date header in that response.",
      "ja": "既に存在していない場合、それは、これらのフィールドのいずれかを追加するかもしれません。ヘッダが付加されている有効期限が切れた場合、その応答にDateヘッダと同じフィールド値を与えなければなりません。"
    },
    {
      "indent": 3,
      "text": "A proxy MUST NOT modify or add any of the following fields in a message that contains the no-transform cache-control directive, or in any request:",
      "ja": "プロキシは、無変換キャッシュ制御ディレクティブを含むメッセージで、または任意の要求で、次のいずれかのフィールドを変更したり、追加してはいけません。"
    },
    {
      "indent": 6,
      "text": "- Content-Encoding",
      "ja": " - コンテンツのエンコーディング"
    },
    {
      "indent": 6,
      "text": "- Content-Range",
      "ja": " - コンテンツレンジ"
    },
    {
      "indent": 6,
      "text": "- Content-Type",
      "ja": " - のContent-Type"
    },
    {
      "indent": 3,
      "text": "A non-transparent proxy MAY modify or add these fields to a message that does not include no-transform, but if it does so, it MUST add a Warning 214 (Transformation applied) if one does not already appear in the message (see section 14.46).",
      "ja": "非透過プロキシは、無変換含まれませんが、それがそうする場合は、1つは、すでにメッセージに表示されていない場合、それは警告214（変換が適用される）を追加しなければならないメッセージにこれらのフィールドを変更したり、追加MAY（セクションを参照してください14.46）。"
    },
    {
      "indent": 6,
      "text": "Warning: unnecessary modification of end-to-end headers might cause authentication failures if stronger authentication mechanisms are introduced in later versions of HTTP. Such authentication mechanisms MAY rely on the values of header fields not listed here.",
      "ja": "警告：強力な認証メカニズムは、HTTPのそれ以降のバージョンで導入されている場合は、エンドツーエンドのヘッダーの不要な変更は、認証の失敗の原因となることがあります。このような認証メカニズムは、ここに記載されていないヘッダフィールドの値に依存してもよいです。"
    },
    {
      "indent": 3,
      "text": "The Content-Length field of a request or response is added or deleted according to the rules in section 4.4. A transparent proxy MUST preserve the entity-length (section 7.2.2) of the entity-body, although it MAY change the transfer-length (section 4.4).",
      "ja": "要求又は応答のコンテンツ長フィールドは、セクション4.4の規則に従って追加または削除されています。それは転送長（セクション4.4）を変更することができるが、透過プロキシは、エンティティボディのエンティティ長さ（セクション7.2.2）を保持しなければなりません。"
    },
    {
      "indent": 0,
      "text": "13.5.3 Combining Headers",
      "section_title": true,
      "ja": "13.5.3組み合わせるヘッダ"
    },
    {
      "indent": 3,
      "text": "When a cache makes a validating request to a server, and the server provides a 304 (Not Modified) response or a 206 (Partial Content) response, the cache then constructs a response to send to the requesting client.",
      "ja": "キャッシュは、サーバーへの検証要求を行い、サーバは304（未修正）応答または206（部分コンテンツ）応答を提供する場合、キャッシュは、要求しているクライアントに送信する応答を構築します。"
    },
    {
      "indent": 3,
      "text": "If the status code is 304 (Not Modified), the cache uses the entity-body stored in the cache entry as the entity-body of this outgoing response. If the status code is 206 (Partial Content) and the ETag or Last-Modified headers match exactly, the cache MAY combine the contents stored in the cache entry with the new contents received in the response and use the result as the entity-body of this outgoing response, (see 13.5.4).",
      "ja": "ステータスコードは304（未修正）された場合、キャッシュは、この発信応答のエンティティボディとしてキャッシュエントリに格納されたエンティティボディを使用します。ステータスコードが206（部分コンテンツ）であるとのETagまたはLast-Modifiedのヘッダが完全に一致した場合は、新しい内容でキャッシュエントリに格納されたコンテンツを組み合わせることができるキャッシュは応答して受信し、のエンティティボディとして結果を使用しますこの送信応答、（13.5.4を参照）。"
    },
    {
      "indent": 3,
      "text": "The end-to-end headers stored in the cache entry are used for the constructed response, except that",
      "ja": "キャッシュエントリに格納されたエンド・ツー・エンドのヘッダはことを除いて、構築応答に使用されます"
    },
    {
      "indent": 6,
      "text": "- any stored Warning headers with warn-code 1xx (see section 14.46) MUST be deleted from the cache entry and the forwarded response.",
      "ja": " - 警告コード1XX（セクション14.46を参照）を有する任意の格納された警告ヘッダはキャッシュエントリと転送応答から削除されなければなりません。"
    },
    {
      "indent": 6,
      "text": "- any stored Warning headers with warn-code 2xx MUST be retained in the cache entry and the forwarded response.",
      "ja": " - 警告コード2XXを有する任意の格納された警告ヘッダはキャッシュエントリと転送応答して保持されなければなりません。"
    },
    {
      "indent": 6,
      "text": "- any end-to-end headers provided in the 304 or 206 response MUST replace the corresponding headers from the cache entry.",
      "ja": " -  304または206応答して提供される任意のエンド・ツー・エンドヘッダはキャッシュエントリから対応するヘッダーを交換しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Unless the cache decides to remove the cache entry, it MUST also replace the end-to-end headers stored with the cache entry with corresponding headers received in the incoming response, except for Warning headers as described immediately above. If a header field-name in the incoming response matches more than one header in the cache entry, all such old headers MUST be replaced.",
      "ja": "キャッシュは、キャッシュエントリを削除することを決定しない限り、それはまた、対応するヘッダを持つキャッシュエントリに格納されたエンドツーエンドのヘッダを交換する必要があり、直ちに上記のようにヘッダ警告を除いて、着信応答して受信。入ってきたレスポンスのヘッダフィールド名がキャッシュエントリに複数のヘッダと一致する場合、そのようなすべての古いヘッダを交換する必要があります。"
    },
    {
      "indent": 3,
      "text": "In other words, the set of end-to-end headers received in the incoming response overrides all corresponding end-to-end headers stored with the cache entry (except for stored Warning headers with warn-code 1xx, which are deleted even if not overridden).",
      "ja": "換言すれば、エンド・ツー・エンドのヘッダのセットは、着信応答して受信された削除されてもされていない警告コード1XXと格納された警告ヘッダを除いて（キャッシュエントリに格納されているすべての対応するエンドツーエンドのヘッダをオーバーライド上書き）。"
    },
    {
      "indent": 6,
      "text": "Note: this rule allows an origin server to use a 304 (Not Modified) or a 206 (Partial Content) response to update any header associated with a previous response for the same entity or sub-ranges thereof, although it might not always be meaningful or correct to do so. This rule does not allow an origin server to use a 304 (Not Modified) or a 206 (Partial Content) response to entirely delete a header that it had provided with a previous response.",
      "ja": "注：このルールはオリジンサーバが同じエンティティまたはその部分範囲の以前の応答に関連する任意のヘッダを更新する304（変更せず）又は206（部分コンテンツ）応答を使用することができ、それは必ずしも意味がないかもしれないがあるいはそうすることが正しいです。この規則は、オリジンサーバが完全にそれが以前のレスポンスを提供していたヘッダを削除するには、304（変更不可）または206（部分コンテンツ）応答を使用することはできません。"
    },
    {
      "indent": 0,
      "text": "13.5.4 Combining Byte Ranges",
      "section_title": true,
      "ja": "13.5.4バイト範囲を組み合わせます"
    },
    {
      "indent": 3,
      "text": "A response might transfer only a subrange of the bytes of an entity-body, either because the request included one or more Range specifications, or because a connection was broken prematurely. After several such transfers, a cache might have received several ranges of the same entity-body.",
      "ja": "応答は、要求は、1つ以上の範囲の仕様が含まれているため、または接続が早期に破壊されたためのいずれかで、エンティティボディのバイトのサブレンジのみを転送するかもしれません。いくつかのような転送の後、キャッシュは同じエンティティボディのいくつかの範囲を受け取っている場合があります。"
    },
    {
      "indent": 3,
      "text": "If a cache has a stored non-empty set of subranges for an entity, and an incoming response transfers another subrange, the cache MAY combine the new subrange with the existing set if both the following conditions are met:",
      "ja": "キャッシュがエンティティに対するサブレンジの保存された非空のセットを持って、着信応答が別のサブレンジを転送した場合は、次の両方の条件が満たされた場合、キャッシュは既存のセットと新しいサブレンジを組み合わせることができます。"
    },
    {
      "indent": 6,
      "text": "- Both the incoming response and the cache entry have a cache validator.",
      "ja": " - 受信応答とキャッシュエントリの両方がキャッシュバリデータを持っています。"
    },
    {
      "indent": 6,
      "text": "- The two cache validators match using the strong comparison function (see section 13.3.3).",
      "ja": " -  2つのキャッシュバリデータは、強力な比較機能（セクション13.3.3を参照）を使用して一致します。"
    },
    {
      "indent": 3,
      "text": "If either requirement is not met, the cache MUST use only the most recent partial response (based on the Date values transmitted with every response, and using the incoming response if these values are equal or missing), and MUST discard the other partial information.",
      "ja": "いずれかの要件が満たされていない場合、キャッシュは、最新のパーシャルレスポンス（すべての応答で送信日付値に基づいて、これらの値が等しいか、不足している場合、着信応答を使用）を使用しなければならない、と他の部分的な情報を捨てなければなりません。"
    },
    {
      "indent": 0,
      "text": "13.6 Caching Negotiated Responses",
      "section_title": true,
      "ja": "13.6キャッシング交渉の回答"
    },
    {
      "indent": 3,
      "text": "Use of server-driven content negotiation (section 12.1), as indicated by the presence of a Vary header field in a response, alters the conditions and procedure by which a cache can use the response for subsequent requests. See section 14.44 for use of the Vary header field by servers.",
      "ja": "サーバ主導型コンテンツネゴシエーション（セクション12.1）の使用は、応答が変化するヘッダフィールドの存在によって示されるように、キャッシュは後続の要求に対する応答を使用することが可能な条件及び手順を変更します。サーバによって異なるヘッダフィールドを使用するためのセクション14.44を参照してください。"
    },
    {
      "indent": 3,
      "text": "A server SHOULD use the Vary header field to inform a cache of what request-header fields were used to select among multiple representations of a cacheable response subject to server-driven negotiation. The set of header fields named by the Vary field value is known as the \"selecting\" request-headers.",
      "ja": "サーバは、ザ・リクエスト・ヘッダー・フィールドは、サーバ駆動型ネゴシエーションにキャッシュ可能な応答対象の複数の表現の間で選択するために使用されたもののキャッシュに通知するヘッダフィールドを変化使用すべきです。ヴァリフィールド値によって指定されたヘッダフィールドのセットは、「選択」リクエストヘッダとして知られています。"
    },
    {
      "indent": 3,
      "text": "When the cache receives a subsequent request whose Request-URI specifies one or more cache entries including a Vary header field, the cache MUST NOT use such a cache entry to construct a response to the new request unless all of the selecting request-headers present in the new request match the corresponding stored request-headers in the original request.",
      "ja": "キャッシュは、そのリクエストURIヴァリヘッダフィールドを含む1つ以上のキャッシュエントリを指定する選択要求ヘッダーのすべてに存在しない限り、キャッシュが新しい要求に対する応答を構築するために、このようなキャッシュ・エントリを使用してはいけません、その後の要求を受信した場合新しいリクエストは、元の要求に対応する格納されたリクエストヘッダを一致します。"
    },
    {
      "indent": 3,
      "text": "The selecting request-headers from two requests are defined to match if and only if the selecting request-headers in the first request can be transformed to the selecting request-headers in the second request by adding or removing linear white space (LWS) at places where this is allowed by the corresponding BNF, and/or combining multiple message-header fields with the same field name following the rules about message headers in section 4.2.",
      "ja": "2つの要求場合に一致するように定義され、最初の要求で選択要求ヘッダは場所に線形空白（LWS）を追加または削除することによって第2の要求で選択要求ヘッダーに変換することができる場合にのみ、から選択リクエストヘッダここで、これは、対応するBNFによって許可され、および/またはセクション4.2におけるメッセージヘッダに関する規則以下同じフィールド名を持つ複数のメッセージヘッダフィールドを組み合わせています。"
    },
    {
      "indent": 3,
      "text": "A Vary header field-value of \"*\" always fails to match and subsequent requests on that resource can only be properly interpreted by the origin server.",
      "ja": "Aは、「*」のヘッダフィールド値が常に一致するように失敗し、そのリソース上の後続の要求のみを適切にオリジンサーバによって解釈することができます変更します。"
    },
    {
      "indent": 3,
      "text": "If the selecting request header fields for the cached entry do not match the selecting request header fields of the new request, then the cache MUST NOT use a cached entry to satisfy the request unless it first relays the new request to the origin server in a conditional request and the server responds with 304 (Not Modified), including an entity tag or Content-Location that indicates the entity to be used.",
      "ja": "キャッシュされたエントリのための選択要求ヘッダフィールドは、新しい要求の選択要求ヘッダフィールドと一致しない場合は、最初の条件付きでオリジンサーバに新しい要求を中継しない限り、キャッシュは、要求を満たすためにキャッシュされたエントリを使用してはなりません要求とサーバが使用するエンティティを表すエンティティタグやコンテンツの場所を含め、（変更不可）304で応答します。"
    },
    {
      "indent": 3,
      "text": "If an entity tag was assigned to a cached representation, the forwarded request SHOULD be conditional and include the entity tags in an If-None-Match header field from all its cache entries for the resource. This conveys to the server the set of entities currently held by the cache, so that if any one of these entities matches the requested entity, the server can use the ETag header field in its 304 (Not Modified) response to tell the cache which entry is appropriate. If the entity-tag of the new response matches that of an existing entry, the new response SHOULD be used to update the header fields of the existing entry, and the result MUST be returned to the client.",
      "ja": "エンティティタグがキャッシュされた表現に割り当てられている場合、転送された要求は、条件付きであるとリソースのすべてのキャッシュ・エントリからIf-None-Matchヘッダフィールドのエンティティタグを含むべきです。これらのエンティティのいずれかが要求されたエンティティと一致した場合、サーバはどのエントリキャッシュを伝えるためにその304（未修正）応答にETagヘッダフィールドを使用できるように、これは、サーバーに現在キャッシュに保持されているエンティティのセットを伝えます適切です。新しいレスポンスのエンティティタグが既存のエントリと一致する場合、新たな応答は、既存のエントリのヘッダ・フィールドを更新するために使用する必要があり、その結果がクライアントに返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If any of the existing cache entries contains only partial content for the associated entity, its entity-tag SHOULD NOT be included in the If-None-Match header field unless the request is for a range that would be fully satisfied by that entry.",
      "ja": "既存のキャッシュエントリのいずれかが関連するエンティティのための唯一の部分コンテンツが含まれている場合は、要求が完全にそのエントリによって満たされることになる範囲である場合を除き、そのエンティティタグはIf-None-Matchヘッダフィールドに含まれるべきではありません。"
    },
    {
      "indent": 3,
      "text": "If a cache receives a successful response whose Content-Location field matches that of an existing cache entry for the same Request-]URI, whose entity-tag differs from that of the existing entry, and whose Date is more recent than that of the existing entry, the existing entry SHOULD NOT be returned in response to future requests and SHOULD be deleted from the cache.",
      "ja": "キャッシュはその内容、場所フィールドと一致する正常な応答を受信した場合、エンティティタグ既存のエントリ、のとは異なり、その日に同じ要求 - ] URIのための既存のキャッシュエントリのそれは、既存のものよりも新しいですエントリは、既存のエントリは、将来の要求に応じて返されるべきではなく、キャッシュから削除する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.7 Shared and Non-Shared Caches",
      "section_title": true,
      "ja": "13.7共有および非共有キャッシュ"
    },
    {
      "indent": 3,
      "text": "For reasons of security and privacy, it is necessary to make a distinction between \"shared\" and \"non-shared\" caches. A non-shared cache is one that is accessible only to a single user. Accessibility in this case SHOULD be enforced by appropriate security mechanisms. All other caches are considered to be \"shared.\" Other sections of this specification place certain constraints on the operation of shared caches in order to prevent loss of privacy or failure of access controls.",
      "ja": "セキュリティとプライバシーの理由から、「共有」と「非共有」キャッシュ間の区別をする必要があります。非共有キャッシュは、単一のユーザにアクセス可能なものです。この場合、アクセシビリティは、適切なセキュリティメカニズムによって施行されるべきです。他のすべてのキャッシュは「共有」していると考えられます共有キャッシュの動作に一定の制約この仕様の場所の他のセクションプライバシーやアクセス制御の失敗の損失を防止するためです。"
    },
    {
      "indent": 0,
      "text": "13.8 Errors or Incomplete Response Cache Behavior",
      "section_title": true,
      "ja": "13.8エラーや不完全なレスポンスキャッシュの動作"
    },
    {
      "indent": 3,
      "text": "A cache that receives an incomplete response (for example, with fewer bytes of data than specified in a Content-Length header) MAY store the response. However, the cache MUST treat this as a partial response. Partial responses MAY be combined as described in section 13.5.4; the result might be a full response or might still be partial. A cache MUST NOT return a partial response to a client without explicitly marking it as such, using the 206 (Partial Content) status code. A cache MUST NOT return a partial response using a status code of 200 (OK).",
      "ja": "（例えば、Content-Lengthヘッダで指定されたよりも、データの少ないバイトを有する）の不完全な応答を受信したキャッシュは、応答を格納することができます。しかし、キャッシュはパーシャルレスポンスとしてこれを扱わなければなりません。セクション13.5.4に記載されているように、部分的応答を組み合わせてもよいです。結果は完全なレスポンスかもしれませんか、まだ部分的かもしれません。キャッシュは206（部分コンテンツ）ステータスコードを使用して、明示的にそのようにマーキングすることなく、クライアントへの部分的な応答を返してはなりません。キャッシュは、200（OK）のステータスコードを使用して、部分的な応答を返してはなりません。"
    },
    {
      "indent": 3,
      "text": "If a cache receives a 5xx response while attempting to revalidate an entry, it MAY either forward this response to the requesting client, or act as if the server failed to respond. In the latter case, it MAY return a previously received response unless the cached entry includes the \"must-revalidate\" cache-control directive (see section 14.9).",
      "ja": "エントリを再検証しようとしたときにキャッシュが5xxの応答を受信した場合、要求元のクライアントにこのレスポンスを転送することができるのいずれか、またはサーバが応答に失敗したかのように行動します。キャッシュされたエントリが「マスト再検証」キャッシュ制御ディレクティブ（セクション14.9を参照）を備えていない限り、後者の場合には、以前に受信したレスポンスを返すことができます。"
    },
    {
      "indent": 0,
      "text": "13.9 Side Effects of GET and HEAD",
      "section_title": true,
      "ja": "GETとHEADの13.9副作用"
    },
    {
      "indent": 3,
      "text": "Unless the origin server explicitly prohibits the caching of their responses, the application of GET and HEAD methods to any resources SHOULD NOT have side effects that would lead to erroneous behavior if these responses are taken from a cache. They MAY still have side effects, but a cache is not required to consider such side effects in its caching decisions. Caches are always expected to observe an origin server's explicit restrictions on caching.",
      "ja": "オリジンサーバは明示的にその応答のキャッシュを禁止していない限り、すべてのリソースへのGETとHEADメソッドのアプリケーションは、これらの応答がキャッシュから取られている場合、誤った行動につながる副作用を持つべきではありません。彼らはまだ副作用があるかもしれませんが、キャッシュはそのキャッシング決定において、このような副作用を考慮することが必要とされていません。キャッシュは常にキャッシュ上のオリジンサーバの明示的な制限を遵守することが期待されています。"
    },
    {
      "indent": 3,
      "text": "We note one exception to this rule: since some applications have traditionally used GETs and HEADs with query URLs (those containing a \"?\" in the rel_path part) to perform operations with significant side effects, caches MUST NOT treat responses to such URIs as fresh unless the server provides an explicit expiration time. This specifically means that responses from HTTP/1.0 servers for such URIs SHOULD NOT be taken from a cache. See section 9.1.1 for related information.",
      "ja": "私たちは、このルールに例外を注意：一部のアプリケーションでは、伝統的に使用しているので、（rel_pathの一部に含むもの「？」）をクエリのURLでGETおよびヘッド重大な副作用を使用して操作を実行するために、キャッシュが新鮮なようなURIに応答を扱うてはなりませんサーバーは、明示的な有効期限を提供していない限り。これは、具体的には、URIのHTTPからの応答/ 1.0のサーバーがキャッシュから取られるべきではないことを意味しています。関連情報については、セクション9.1.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "13.10 Invalidation After Updates or Deletions",
      "section_title": true,
      "ja": "更新または削除した後、13.10の無効化"
    },
    {
      "indent": 3,
      "text": "The effect of certain methods performed on a resource at the origin server might cause one or more existing cache entries to become non-transparently invalid. That is, although they might continue to be \"fresh,\" they do not accurately reflect what the origin server would return for a new request on that resource.",
      "ja": "オリジンサーバのリソース上で実行される特定の方法の効果は、1つの以上の既存のキャッシュエントリが非透過無効になる場合があります。それは、彼らがであり続けるかもしれないが、「新鮮な、」彼らは正確にオリジンサーバはそのリソース上の新しい要求のために戻ってくるものを反映していない、です。"
    },
    {
      "indent": 3,
      "text": "There is no way for the HTTP protocol to guarantee that all such cache entries are marked invalid. For example, the request that caused the change at the origin server might not have gone through the proxy where a cache entry is stored. However, several rules help reduce the likelihood of erroneous behavior.",
      "ja": "HTTPプロトコルでは、そのようなすべてのキャッシュエントリが無効とマークされることを保証する方法はありません。例えば、オリジンサーバに変更を生じたリクエストはキャッシュエントリが保存されているプロキシを経ていない可能性があります。しかし、いくつかのルールは誤った行動の可能性を減らすのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "In this section, the phrase \"invalidate an entity\" means that the cache will either remove all instances of that entity from its storage, or will mark these as \"invalid\" and in need of a mandatory revalidation before they can be returned in response to a subsequent request.",
      "ja": "このセクションでは、フレーズ「エンティティを無効には、」キャッシュがそのストレージからそのエンティティのすべてのインスタンスを削除するか、または、彼らはに応じて返すことができます前に、「無効」と必須の再検証の必要があるとして、これらをマークすることを意味します後続の要求。"
    },
    {
      "indent": 3,
      "text": "Some HTTP methods MUST cause a cache to invalidate an entity. This is either the entity referred to by the Request-URI, or by the Location or Content-Location headers (if present). These methods are:",
      "ja": "いくつかのHTTPメソッドは、エンティティを無効にするキャッシュを起こす必要があります。これは、いずれかのエンティティは、Request-URIによって参照される、又はロケーション若しくはコンテンツロケーションヘッダー（存在する場合）によります。これらのメソッドは以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "- PUT",
      "ja": " -  PUT"
    },
    {
      "indent": 6,
      "text": "- DELETE",
      "ja": " -  DELETE"
    },
    {
      "indent": 6,
      "text": "- POST",
      "ja": "- 役職"
    },
    {
      "indent": 3,
      "text": "In order to prevent denial of service attacks, an invalidation based on the URI in a Location or Content-Location header MUST only be performed if the host part is the same as in the Request-URI.",
      "ja": "ホスト部分がRequest-URIと同じである場合、サービス拒否攻撃を防止するために、場所またはコンテンツロケーションヘッダにURIに基づいて、無効化のみを実行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A cache that passes through requests for methods it does not understand SHOULD invalidate any entities referred to by the Request-URI.",
      "ja": "それは理解していないメソッドの要求を通過したキャッシュは、Request-URIで参照されるすべてのエンティティを無効にすべきです。"
    },
    {
      "indent": 0,
      "text": "13.11 Write-Through Mandatory",
      "section_title": true,
      "ja": "13.11ライトスルー必須"
    },
    {
      "indent": 3,
      "text": "All methods that might be expected to cause modifications to the origin server's resources MUST be written through to the origin server. This currently includes all methods except for GET and HEAD. A cache MUST NOT reply to such a request from a client before having transmitted the request to the inbound server, and having received a corresponding response from the inbound server. This does not prevent a proxy cache from sending a 100 (Continue) response before the inbound server has sent its final reply.",
      "ja": "オリジンサーバのリソースへの変更を引き起こすことが予想されるすべてのメソッドは、オリジンサーバに通じ書かなければなりません。これは現在GETとHEAD以外のすべての方法を含みます。インバウンドサーバにリクエストを送信した、と受信サーバーから対応する応答を受信した前にキャッシュは、クライアントから、このような要求に応答してはなりません。これは、受信サーバーがその最終的な返事を送った前に、100（続行）応答を送信プロキシキャッシュを防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "The alternative (known as \"write-back\" or \"copy-back\" caching) is not allowed in HTTP/1.1, due to the difficulty of providing consistent updates and the problems arising from server, cache, or network failure prior to write-back.",
      "ja": "（「ライトバック」または「コピー・バック」キャッシュとして知られている）の代替が原因書込み禁止する前に、一貫した更新と、サーバ、キャッシュ、またはネットワーク障害から生じる問題を提供することの難しさに、HTTP / 1.1で許可されていませんバック。"
    },
    {
      "indent": 0,
      "text": "13.12 Cache Replacement",
      "section_title": true,
      "ja": "13.12キャッシュ置換"
    },
    {
      "indent": 3,
      "text": "If a new cacheable (see sections 14.9.2, 13.2.5, 13.2.6 and 13.8) response is received from a resource while any existing responses for the same resource are cached, the cache SHOULD use the new response to reply to the current request. It MAY insert it into cache storage and MAY, if it meets all other requirements, use it to respond to any future requests that would previously have caused the old response to be returned. If it inserts the new response into cache storage the rules in section 13.5.3 apply.",
      "ja": "同じリソースに対する既存のレスポンスがキャッシュされている間に、新しいキャッシュ可能なレスポンスがリソースから受信される（セクション14.9.2、13.2.5、13.2.6および13.8を参照）した場合、キャッシュは現在に返信する新しいレスポンスを使用すべきです要求。それは他のすべての要件を満たしている場合は、以前の古いレスポンスが返される原因となったであろう将来の要求に応えるためにそれを使用して、キャッシュの保存およびMAYにそれを挿入することができます。それはキャッシュストレージに新しい応答を挿入した場合はセクション13.5.3のルールが適用されます。"
    },
    {
      "indent": 6,
      "text": "Note: a new response that has an older Date header value than existing cached responses is not cacheable.",
      "ja": "注意：既存のキャッシュされた応答よりも古いDateヘッダ値を持つ新しいレスポンスはキャッシュ可能ではありません。"
    },
    {
      "indent": 0,
      "text": "13.13 History Lists",
      "section_title": true,
      "ja": "13.13履歴リスト"
    },
    {
      "indent": 3,
      "text": "User agents often have history mechanisms, such as \"Back\" buttons and history lists, which can be used to redisplay an entity retrieved earlier in a session.",
      "ja": "ユーザーエージェントは、多くの場合、このようなセッションで、以前取得したエンティティを再表示するために使用することができ、「戻る」ボタンと履歴リスト、など歴史メカニズムを、持っています。"
    },
    {
      "indent": 3,
      "text": "History mechanisms and caches are different. In particular history mechanisms SHOULD NOT try to show a semantically transparent view of the current state of a resource. Rather, a history mechanism is meant to show exactly what the user saw at the time when the resource was retrieved.",
      "ja": "履歴メカニズムとキャッシュは異なります。特に履歴メカニズムはリソースの現在の状態の意味的に透視図を表示しないようにしてください。むしろ、履歴メカニズムはリソースが取得されたときに、ユーザが一度に見て正確に何を表示するように意図されています。"
    },
    {
      "indent": 3,
      "text": "By default, an expiration time does not apply to history mechanisms. If the entity is still in storage, a history mechanism SHOULD display it even if the entity has expired, unless the user has specifically configured the agent to refresh expired history documents.",
      "ja": "デフォルトでは、有効期限は履歴メカニズムには適用されません。実体がストレージ内に残っている場合、ユーザーが期限切れの歴史文書を更新するエージェントを特に設定していない限り、履歴メカニズムは、エンティティが期限切れになった場合でも、それが表示されます。"
    },
    {
      "indent": 3,
      "text": "This is not to be construed to prohibit the history mechanism from telling the user that a view might be stale.",
      "ja": "これは、ビューが古いかもしれないユーザーに伝えるから履歴メカニズムを禁止すると解釈されるべきではありません。"
    },
    {
      "indent": 6,
      "text": "Note: if history list mechanisms unnecessarily prevent users from viewing stale resources, this will tend to force service authors to avoid using HTTP expiration controls and cache controls when they would otherwise like to. Service authors may consider it important that users not be presented with error messages or warning messages when they use navigation controls (such as BACK) to view previously fetched resources. Even though sometimes such resources ought not to cached, or ought to expire quickly, user interface considerations may force service authors to resort to other means of preventing caching (e.g. \"once-only\" URLs) in order not to suffer the effects of improperly functioning history mechanisms.",
      "ja": "注意：履歴リストメカニズムが不必要に古くなったリソースを表示してからユーザーを防ぐならば、これは彼らがそうしたいとき、HTTPの有効期限コントロールとキャッシュコントロールを使用しないように、サービス作成者を強制する傾向があります。サービス作成者は、それが重要な彼らは、以前にフェッチされたリソースを表示する（例えばBACKなど）のナビゲーションコントロールを使用する場合、ユーザーがエラーメッセージや警告メッセージが提示されていないことを考えることができます。にもかかわらず、時にはそのようなリソースは、ユーザインタフェースの考慮が不適切機能の影響を受けないようにするためにキャッシュを防止する他の手段（例えば、「一度だけ」のURL）に頼るサービス著者を強制することがあり、キャッシュされた、またはすぐに期限切れにするべきであるべきではありません歴史・メカニズム。"
    },
    {
      "indent": 0,
      "text": "14 Header Field Definitions",
      "ja": "14のヘッダーフィールドの定義"
    },
    {
      "indent": 3,
      "text": "This section defines the syntax and semantics of all standard HTTP/1.1 header fields. For entity-header fields, both sender and recipient refer to either the client or the server, depending on who sends and who receives the entity.",
      "ja": "このセクションでは、すべての標準HTTP / 1.1ヘッダフィールドの構文と意味論を定義します。エンティティヘッダフィールドの場合、送信者と受信者の両方を送信し、誰エンティティの受信者に応じて、クライアントまたはサーバのいずれかを参照してください。"
    },
    {
      "indent": 0,
      "text": "14.1 Accept",
      "section_title": true,
      "ja": "14.1受け入れます"
    },
    {
      "indent": 3,
      "text": "The Accept request-header field can be used to specify certain media types which are acceptable for the response. Accept headers can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.",
      "ja": "受け入れリクエストヘッダフィールドは、応答のために許容される特定のメディアタイプを指定するために使用することができます。受け入れヘッダは、要求は、特にインライン画像要求の場合のように、所望の種類の小さなセットに限定されることを示すために使用することができます。"
    },
    {
      "indent": 7,
      "text": "Accept         = \"Accept\" \":\"\n                 #( media-range [ accept-params ] )",
      "raw": true
    },
    {
      "indent": 7,
      "text": "media-range    = ( \"*/*\"\n                 | ( type \"/\" \"*\" )\n                 | ( type \"/\" subtype )\n                 ) *( \";\" parameter )\naccept-params  = \";\" \"q\" \"=\" qvalue *( accept-extension )\naccept-extension = \";\" token [ \"=\" ( token | quoted-string ) ]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The asterisk \"*\" character is used to group media types into ranges,\nwith \"*/*\" indicating all media types and \"type/*\" indicating all\nsubtypes of that type. The media-range MAY include media type\nparameters that are applicable to that range.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each media-range MAY be followed by one or more accept-params, beginning with the \"q\" parameter for indicating a relative quality factor. The first \"q\" parameter (if any) separates the media-range parameter(s) from the accept-params. Quality factors allow the user or user agent to indicate the relative degree of preference for that media-range, using the qvalue scale from 0 to 1 (section 3.9). The default value is q=1.",
      "ja": "各メディア範囲は、相対品質係数を示すための「Q」パラメータで始まる、一つ以上の-paramsはを受け入れるが続いてもよいです。最初の「Q」パラメータは（もしあれば）を受け入れる-paramsはからメディア範囲パラメータ（単数または複数）を分離します。品質係数は0から1（セクション3.9）へのqvalue尺度を使用して、ユーザーまたはユーザーエージェントは、そのメディア範囲に対する嗜好の相対的な程度を示すことを可能にします。デフォルト値はq = 1です。"
    },
    {
      "indent": 6,
      "text": "Note: Use of the \"q\" parameter name to separate media type parameters from Accept extension parameters is due to historical practice. Although this prevents any media type parameter named \"q\" from being used with a media range, such an event is believed to be unlikely given the lack of any \"q\" parameters in the IANA media type registry and the rare usage of any media type parameters in Accept. Future media types are discouraged from registering any parameter named \"q\".",
      "ja": "注意：拡張パラメータを受け入れるとは別のメディアタイプパラメータを「Q」パラメータ名の使用は歴史的な練習によるものです。これは、メディアの範囲で使用されることから、「Q」という名前の任意のメディアタイプパラメータを防ぎますが、このようなイベントは、IANAメディアタイプレジストリと任意のメディアタイプのまれな使用方法のいずれかの「Q」のパラメータの欠如与えられたそうであると考えられています受け入れのパラメータ。将来のメディアタイプは、「Q」という名前の任意のパラメータを登録することは推奨されています。"
    },
    {
      "indent": 3,
      "text": "The example",
      "ja": "例"
    },
    {
      "indent": 7,
      "text": "Accept: audio/*; q=0.2, audio/basic",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SHOULD be interpreted as \"I prefer audio/basic, but send me any audio type if it is the best available after an 80% mark-down in quality.\"",
      "ja": "「私は基本/オーディオ好むが、それは品質に80％のマークダウン後に利用可能な最善のであれば私に任意のオーディオタイプを送信してください。」と解釈されるべきです"
    },
    {
      "indent": 3,
      "text": "If no Accept header field is present, then it is assumed that the client accepts all media types. If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.",
      "ja": "何のAcceptヘッダーフィールドが存在しない場合、クライアントはすべてのメディアタイプを受け入れることが想定されます。 Acceptヘッダフィールドが存在し、サーバが受け入れる合成フィールドの値に応じて許容される応答を送信できない場合、サーバは406（許容できない）応答を送信するかどう。"
    },
    {
      "indent": 3,
      "text": "A more elaborate example is",
      "ja": "より複雑な例があります"
    },
    {
      "indent": 7,
      "text": "Accept: text/plain; q=0.5, text/html,\n        text/x-dvi; q=0.8, text/x-c",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Verbally, this would be interpreted as \"text/html and text/x-c are the preferred media types, but if they do not exist, then send the text/x-dvi entity, and if that does not exist, send the text/plain entity.\"",
      "ja": "口頭で、これはテキスト/ htmlとテキスト/ XC」として解釈される好適なメディアタイプがありますが、それらが存在しない場合は、テキスト/ X-DVIエンティティを送信し、それが存在しない場合は、テキスト/平野を送信エンティティ。\""
    },
    {
      "indent": 3,
      "text": "Media ranges can be overridden by more specific media ranges or specific media types. If more than one media range applies to a given type, the most specific reference has precedence. For example,",
      "ja": "メディアの範囲は、より具体的なメディアの範囲または特定のメディアタイプで上書きすることができます。複数のメディアの範囲が指定されたタイプに適用された場合は、最も具体的な言及が優先されます。例えば、"
    },
    {
      "indent": 7,
      "text": "Accept: text/*, text/html, text/html;level=1, */*",
      "raw": true
    },
    {
      "indent": 3,
      "text": "have the following precedence:",
      "ja": "次の優先順位があります。"
    },
    {
      "indent": 7,
      "text": "1) text/html;level=1\n2) text/html\n3) text/*\n4) */*",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The media type quality factor associated with a given type is determined by finding the media range with the highest precedence which matches that type. For example,",
      "ja": "所与のタイプに関連付けられたメディアタイプの品質係数は、そのタイプに一致する最も高い優先順位を有するメディア範囲を見つけることによって決定されます。例えば、"
    },
    {
      "indent": 7,
      "text": "Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,\n        text/html;level=2;q=0.4, */*;q=0.5",
      "raw": true
    },
    {
      "indent": 3,
      "text": "would cause the following values to be associated:",
      "ja": "次の値が関連していることが原因となります"
    },
    {
      "indent": 7,
      "text": "text/html;level=1         = 1\ntext/html                 = 0.7\ntext/plain                = 0.3 image/jpeg                = 0.5\ntext/html;level=2         = 0.4\ntext/html;level=3         = 0.7",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Note: A user agent might be provided with a default set of quality values for certain media ranges. However, unless the user agent is a closed system which cannot interact with other rendering agents, this default set ought to be configurable by the user.",
      "ja": "注意：ユーザエージェントは、あるメディアレンジのための品質値のデフォルトセットで提供される可能性があります。ユーザエージェントが他のレンダリングエージェントと対話することはできませんクローズドシステムである場合を除きしかし、このデフォルトセットは、ユーザが設定可能であるべきです。"
    },
    {
      "indent": 0,
      "text": "14.2 Accept-Charset",
      "section_title": true,
      "ja": "14.2のAccept-文字セット"
    },
    {
      "indent": 3,
      "text": "The Accept-Charset request-header field can be used to indicate what character sets are acceptable for the response. This field allows clients capable of understanding more comprehensive or special-purpose character sets to signal that capability to a server which is capable of representing documents in those character sets.",
      "ja": "受け入れ、文字セットリクエストヘッダフィールドは、応答のために許容されるどんな文字セットを示すために使用することができます。このフィールドは、より包括的なまたは特殊目的の文字を理解できるクライアントは、これらの文字セットでドキュメントを表現することのできるサーバにその機能を通知するために設定できます。"
    },
    {
      "indent": 6,
      "text": "Accept-Charset = \"Accept-Charset\" \":\" 1#( ( charset | \"*\" )[ \";\" \"q\" \"=\" qvalue ] )",
      "ja": "= \"同意-文字セット\" \" - 文字セットを受け入れる：\" 1＃（（文字セット| \"*\"）[ \";\" \"Q\" \"=\" のqvalue]）"
    },
    {
      "indent": 3,
      "text": "Character set values are described in section 3.4. Each charset MAY be given an associated quality value which represents the user's preference for that charset. The default value is q=1. An example is",
      "ja": "文字セットの値は、セクション3.4に記載されています。各文字セットは、その文字セットに対するユーザの嗜好を表す関連付けられた品質値を与えられてもよいです。デフォルト値はq = 1です。例があります"
    },
    {
      "indent": 6,
      "text": "Accept-Charset: iso-8859-5, unicode-1-1;q=0.8",
      "ja": "受け入れ、文字セット：ISO-8859-5、ユニコード1-1; Qが= 0.8"
    },
    {
      "indent": 3,
      "text": "The special value \"*\", if present in the Accept-Charset field, matches every character set (including ISO-8859-1) which is not mentioned elsewhere in the Accept-Charset field. If no \"*\" is present in an Accept-Charset field, then all character sets not explicitly mentioned get a quality value of 0, except for ISO-8859-1, which gets a quality value of 1 if not explicitly mentioned.",
      "ja": "特殊な値「*」は、受け入れ-文字セットのフィールドに存在する場合、他の場所でのAccept-文字セットのフィールドに記載されていない（ISO-8859-1を含む）すべての文字セットと一致します。何の「*」は受け入れ-文字セットのフィールドに存在しない場合、すべての文字がない明示的に言及したが、明示的に言及されていない場合は1の品質値を取得ISO-8859-1、を除いて、0の品質値を取得設定します。"
    },
    {
      "indent": 3,
      "text": "If no Accept-Charset header is present, the default is that any character set is acceptable. If an Accept-Charset header is present, and if the server cannot send a response which is acceptable according to the Accept-Charset header, then the server SHOULD send an error response with the 406 (not acceptable) status code, though the sending of an unacceptable response is also allowed.",
      "ja": "何のAccept-文字セットヘッダが存在しない場合、デフォルトでは、任意の文字セットが許容可能であるということです。受け入れ、文字セットヘッダが存在し、サーバーが受け入れ、文字セットヘッダに応じて許容される応答を送信できない場合、サーバは、送信が、406（許容できない）ステータスコードとエラー応答を送信する必要がある場合容認できない応答も許可されています。"
    },
    {
      "indent": 0,
      "text": "14.3 Accept-Encoding",
      "section_title": true,
      "ja": "14.3のAccept-エンコーディング"
    },
    {
      "indent": 3,
      "text": "The Accept-Encoding request-header field is similar to Accept, but restricts the content-codings (section 3.5) that are acceptable in the response.",
      "ja": "Accept-Encodingリクエスト・ヘッダー・フィールドは、そのまま使用することが同様であるが、応答に許容される内容コーディング（セクション3.5）を制限します。"
    },
    {
      "indent": 7,
      "text": "Accept-Encoding = \"Accept-Encoding\" \":\"",
      "ja": "受け入れエンコード= \"にAccept-エンコーディングを\" \"：\""
    },
    {
      "indent": 7,
      "text": " 1#( codings [ \";\" \"q\" \"=\" qvalue ] ) codings = ( content-coding | \"*\" )",
      "ja": "1＃（コーディング[ \";\" \"Q\" \"=\" のqvalue]）コーディング=（| \"*\" コンテンツコーディング）"
    },
    {
      "indent": 3,
      "text": "Examples of its use are:",
      "ja": "その使用の例は以下のとおりです。"
    },
    {
      "indent": 7,
      "text": "Accept-Encoding: compress, gzip\nAccept-Encoding:\nAccept-Encoding: *\nAccept-Encoding: compress;q=0.5, gzip;q=1.0\nAccept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A server tests whether a content-coding is acceptable, according to an Accept-Encoding field, using these rules:",
      "ja": "：コンテンツ・コーディングはこれらのルールを使用して、受け入れをコードフィールドによれば、許容可能であるか否かをサーバ・テスト"
    },
    {
      "indent": 6,
      "text": "1. If the content-coding is one of the content-codings listed in the Accept-Encoding field, then it is acceptable, unless it is accompanied by a qvalue of 0. (As defined in section 3.9, a qvalue of 0 means \"not acceptable.\")",
      "ja": "コンテンツ符号化のAccept-Encodingフィールドに記載されている内容コーディングのいずれかである場合、それは0（のqvalueを伴うされていない限り、セクション3.9で定義されているように1、それは、許容される、0手段のqvalue \"受け付けできません。\"）"
    },
    {
      "indent": 6,
      "text": "2. The special \"*\" symbol in an Accept-Encoding field matches any available content-coding not explicitly listed in the header field.",
      "ja": "2.特別には「*」にAccept-Encodingフィールド内のシンボルは、任意の利用可能なコンテンツコードを明示的ヘッダフィールドにリストされていないと一致しました。"
    },
    {
      "indent": 6,
      "text": "3. If multiple content-codings are acceptable, then the acceptable content-coding with the highest non-zero qvalue is preferred.",
      "ja": "複数のコンテンツ・コーディングが許容される場合3.その後に許容されるコンテンツコーディング最高非ゼロのqvalueを有することが好ましいです。"
    },
    {
      "indent": 6,
      "text": "4. The \"identity\" content-coding is always acceptable, unless specifically refused because the Accept-Encoding field includes \"identity;q=0\", or because the field includes \"*;q=0\" and does not explicitly include the \"identity\" content-coding. If the Accept-Encoding field-value is empty, then only the \"identity\" encoding is acceptable.",
      "ja": "フィールドが含まれているため、「Q 0 =同一性」、または「*; q = 0で」と明示的に「含まれていません。4.「アイデンティティ」コンテンツコーディングが受け入れ-Encodingフィールドが含まれているため、特に拒否しない限り、常に受け入れられますアイデンティティ」コンテンツコーディング。受け入れエンコードフィールド値が空の場合、唯一の「アイデンティティ」エンコードが可能です。"
    },
    {
      "indent": 3,
      "text": "If an Accept-Encoding field is present in a request, and if the server cannot send a response which is acceptable according to the Accept-Encoding header, then the server SHOULD send an error response with the 406 (Not Acceptable) status code.",
      "ja": "もし受け入れエンコーディングフィールドは要求に存在し、サーバが受け入れる-Encodingヘッダに従って許容される応答を送信できない場合、サーバは406（許容できない）ステータスコードとエラー応答を送信すべきです。"
    },
    {
      "indent": 3,
      "text": "If no Accept-Encoding field is present in a request, the server MAY assume that the client will accept any content coding. In this case, if \"identity\" is one of the available content-codings, then the server SHOULD use the \"identity\" content-coding, unless it has additional information that a different content-coding is meaningful to the client.",
      "ja": "何のAccept-Encodingフィールドがリクエストに存在しない場合、サーバーは、クライアントがどんな内容コーディングを受け入れることを仮定してもよいです。この場合、「同一性」は、それが異なるコンテンツコードは、クライアントにとって意味のあることを、追加情報を持っていない限り、サーバーは、「アイデンティティ」コンテンツコーディングを使用すべきである、可能な内容コーディングの一つです。"
    },
    {
      "indent": 6,
      "text": "Note: If the request does not include an Accept-Encoding field, and if the \"identity\" content-coding is unavailable, then content-codings commonly understood by HTTP/1.0 clients (i.e.,",
      "ja": "注：（要求のAccept-Encodingフィールドが含まれていない場合、および「同一性」は、コンテンツコードが利用できない場合、その後、内容コーディングは、一般に、HTTP / 1.0クライアントによって理解される、すなわち、"
    },
    {
      "indent": 6,
      "text": "\"gzip\" and \"compress\") are preferred; some older clients improperly display messages sent with other content-codings. The server might also make this decision based on information about the particular user-agent or client.",
      "ja": "「GZIP」および「圧縮」）が好ましいです。一部の古いクライアントは不適切な他の内容コーディングで送信されたメッセージを表示します。また、サーバは、特定のユーザーエージェントまたはクライアントの情報に基づいて、この決定を行う可能性があります。"
    },
    {
      "indent": 6,
      "text": "Note: Most HTTP/1.0 applications do not recognize or obey qvalues associated with content-codings. This means that qvalues will not work and are not permitted with x-gzip or x-compress.",
      "ja": "注：ほとんどのHTTP / 1.0アプリケーションは、内容コーディングに関連したqvaluesを認識したり従いません。これはqvaluesは動作しませんし、X-gzipやX-圧縮で許可されていないことを意味します。"
    },
    {
      "indent": 0,
      "text": "14.4 Accept-Language",
      "section_title": true,
      "ja": "14.4受け入れ言語"
    },
    {
      "indent": 3,
      "text": "The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request. Language tags are defined in section 3.10.",
      "ja": "Accept-Languageリクエストヘッダフィールドは、そのまま使用することが同様であるが、要求に対する応答として好ましい自然言語のセットを制限します。言語タグは、セクション3.10で定義されています。"
    },
    {
      "indent": 7,
      "text": "Accept-Language = \"Accept-Language\" \":\"\n                  1#( language-range [ \";\" \"q\" \"=\" qvalue ] )\nlanguage-range  = ( ( 1*8ALPHA *( \"-\" 1*8ALPHA ) ) | \"*\" )",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each language-range MAY be given an associated quality value which represents an estimate of the user's preference for the languages specified by that range. The quality value defaults to \"q=1\". For example,",
      "ja": "各言語範囲は、その範囲で指定された言語に対するユーザの嗜好の推定値を表す関連する品質値を与えられてもよいです。 「Q = 1」に品質値をデフォルトとします。例えば、"
    },
    {
      "indent": 7,
      "text": "Accept-Language: da, en-gb;q=0.8, en;q=0.7",
      "ja": "受け入れ-言語：DA、EN-GB; Q = 0.8、EN; Q = 0.7"
    },
    {
      "indent": 3,
      "text": "would mean: \"I prefer Danish, but will accept British English and other types of English.\" A language-range matches a language-tag if it exactly equals the tag, or if it exactly equals a prefix of the tag such that the first tag character following the prefix is \"-\". The special range \"*\", if present in the Accept-Language field, matches every tag not matched by any other range present in the Accept-Language field.",
      "ja": "意味するだろう：「私はデンマークを好むが、イギリス英語と英語の他のタイプを受け入れます。」 「 - 」それは正確にタグを等しい場合、またはそれが正確に接頭辞に続く最初のタグ文字があるように、タグの接頭辞と等しい場合、言語の範囲は、言語タグに一致します。特別な範囲「*」は、にAccept-Languageフィールドに存在する場合、受け入れる言語をフィールドに存在する任意の他の範囲で一致していないすべてのタグに一致します。"
    },
    {
      "indent": 6,
      "text": "Note: This use of a prefix matching rule does not imply that language tags are assigned to languages in such a way that it is always true that if a user understands a language with a certain tag, then this user will also understand all languages with tags for which this tag is a prefix. The prefix rule simply allows the use of prefix tags if this is the case.",
      "ja": "注：接頭辞の一致ルールの使用は、その言語タグは、ユーザが特定のタグが付けられた言語を理解している場合、このユーザーはまた、タグですべての言語を理解することは常に真であるように言語に割り当てられている意味するものではありません。そのため、このタグは、接頭辞です。このような場合には、プレフィックス規則は単にプレフィックスタグの使用を可能にします。"
    },
    {
      "indent": 3,
      "text": "The language quality factor assigned to a language-tag by the Accept-Language field is the quality value of the longest language-range in the field that matches the language-tag. If no language-range in the field matches the tag, the language quality factor assigned is 0. If no Accept-Language header is present in the request, the server",
      "ja": "Accept-Languageフィールドによって言語タグに割り当てられた言語の品質係数は、言語タグに一致するフィールドの中で最も長い言語範囲の品質値です。フィールドには、言語範囲がタグと一致しない場合は何のAccept-Languageヘッダーは、サーバ要求に存在しない場合、割り当てられた言語の品質係数は0です。"
    },
    {
      "indent": 3,
      "text": "SHOULD assume that all languages are equally acceptable. If an Accept-Language header is present, then all languages which are assigned a quality factor greater than 0 are acceptable.",
      "ja": "すべての言語が等しく受け入れられることを前提とすべきです。受け入れ言語をヘッダが存在する場合、すべての言語0より大きいが、許容される品質係数を割り当てられます。"
    },
    {
      "indent": 3,
      "text": "It might be contrary to the privacy expectations of the user to send an Accept-Language header with the complete linguistic preferences of the user in every request. For a discussion of this issue, see section 15.1.4.",
      "ja": "すべてのリクエストで、ユーザの完全な言語的な好みでのAccept-Languageヘッダを送信するために、ユーザーのプライバシーの期待に反するかもしれません。この問題の議論については、セクション15.1.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "As intelligibility is highly dependent on the individual user, it is recommended that client applications make the choice of linguistic preference available to the user. If the choice is not made available, then the Accept-Language header field MUST NOT be given in the request.",
      "ja": "明瞭度は、個々の利用者に大きく依存しているとして、クライアントアプリケーションは、ユーザへの言語の好みの選択が利用できるようにすることをお勧めします。選択が利用できるようにされていない場合は、たAccept-Languageヘッダフィールドは、リクエストに与えてはなりません。"
    },
    {
      "indent": 6,
      "text": "Note: When making the choice of linguistic preference available to the user, we remind implementors of the fact that users are not familiar with the details of language matching as described above, and should provide appropriate guidance. As an example, users might assume that on selecting \"en-gb\", they will be served any kind of English document if British English is not available. A user agent might suggest in such a case to add \"en\" to get the best matching behavior.",
      "ja": "注：ユーザーへの言語の好みの選択肢を利用可能にするとき、私たちは、ユーザーが上記のように、言語マッチングの詳細に精通していない、と適切なガイダンスを提供するべきであるという事実の実装を思い出させます。例として、ユーザは、イギリス英語が利用できない場合、彼らは英語の文書のいずれかの種類を提供されます「EN-GB」を選択の上にそれを想定することがあります。ユーザエージェントはベストマッチングの動作を取得するには、「EN」を追加するような場合にはお勧めかもしれません。"
    },
    {
      "indent": 0,
      "text": "14.5 Accept-Ranges",
      "section_title": true,
      "ja": "14.5のAccept-範囲"
    },
    {
      "indent": 6,
      "text": "The Accept-Ranges response-header field allows the server to\nindicate its acceptance of range requests for a resource:",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Accept-Ranges     = \"Accept-Ranges\" \":\" acceptable-ranges\nacceptable-ranges = 1#range-unit | \"none\"",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Origin servers that accept byte-range requests MAY send",
      "ja": "バイト範囲要求を受け入れるオリジンサーバは送るかもしれません"
    },
    {
      "indent": 10,
      "text": "Accept-Ranges: bytes",
      "ja": "受け入れ-範囲：バイト"
    },
    {
      "indent": 6,
      "text": "but are not required to do so. Clients MAY generate byte-range requests without having received this header for the resource involved. Range units are defined in section 3.12.",
      "ja": "しかし、その必要はありません。クライアントは、関連するリソースのためにこのヘッダーを受信せずに、バイト範囲要求を生成してもよいです。レンジユニットは、セクション3.12で定義されています。"
    },
    {
      "indent": 6,
      "text": "Servers that do not accept any kind of range request for a resource MAY send",
      "ja": "リソースの範囲要求のいずれかの種類を受け入れないサーバは送るかもしれません"
    },
    {
      "indent": 10,
      "text": "Accept-Ranges: none",
      "ja": "受け入れ-範囲：なし"
    },
    {
      "indent": 6,
      "text": "to advise the client not to attempt a range request.",
      "ja": "範囲要求を試みないクライアントに助言します。"
    },
    {
      "indent": 0,
      "text": "14.6 Age",
      "section_title": true,
      "ja": "１４。６ あげ"
    },
    {
      "indent": 6,
      "text": "The Age response-header field conveys the sender's estimate of the\namount of time since the response (or its revalidation) was\ngenerated at the origin server. A cached response is \"fresh\" if\nits age does not exceed its freshness lifetime. Age values are\ncalculated as specified in section 13.2.3.",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Age = \"Age\" \":\" age-value\nage-value = delta-seconds",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Age values are non-negative decimal integers, representing time in seconds.",
      "ja": "年齢値は、秒単位の時間を表す、負でない小数の整数です。"
    },
    {
      "indent": 6,
      "text": "If a cache receives a value larger than the largest positive integer it can represent, or if any of its age calculations overflows, it MUST transmit an Age header with a value of 2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST include an Age header field in every response generated from its own cache. Caches SHOULD use an arithmetic type of at least 31 bits of range.",
      "ja": "キャッシュは、最大の正の整数よりも大きな値を受信した場合には表すことができ、又はその年齢計算オーバーフローのいずれかの場合には、2147483648（2 ^ 31）の値と年齢ヘッダを送信しなければなりません。キャッシュを含むHTTP / 1.1サーバは、自身のキャッシュから生成されたすべての応答に年齢ヘッダフィールドを含まなければなりません。キャッシュは、範囲の少なくとも31ビットの算術型を使用すべきです。"
    },
    {
      "indent": 0,
      "text": "14.7 Allow",
      "section_title": true,
      "ja": "14.7許可"
    },
    {
      "indent": 6,
      "text": "The Allow entity-header field lists the set of methods supported\nby the resource identified by the Request-URI. The purpose of this\nfield is strictly to inform the recipient of valid methods\nassociated with the resource. An Allow header field MUST be\npresent in a 405 (Method Not Allowed) response.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Allow = \"Allow\" \":\" #Method",
      "ja": "= \"は \"許可\" 許可：\" #Method"
    },
    {
      "indent": 6,
      "text": "Example of use:",
      "ja": "使用例："
    },
    {
      "indent": 10,
      "text": "Allow: GET, HEAD, PUT",
      "ja": "許可：GET、HEAD、PUT"
    },
    {
      "indent": 6,
      "text": "This field cannot prevent a client from trying other methods. However, the indications given by the Allow header field value SHOULD be followed. The actual set of allowed methods is defined by the origin server at the time of each request.",
      "ja": "このフィールドは、他の方法を試してからクライアントを防ぐことはできません。しかし、許可ヘッダフィールド値によって与えられた指示に従わされるべきです。許可された方法の実際のセットは、各要求時に、オリジンサーバによって定義されます。"
    },
    {
      "indent": 6,
      "text": "The Allow header field MAY be provided with a PUT request to recommend the methods to be supported by the new or modified resource. The server is not required to support these methods and SHOULD include an Allow header in the response giving the actual supported methods.",
      "ja": "許可ヘッダフィールドは、新規または変更されたリソースによってサポートされる方法を推奨するPUT要求を設けてもよいです。サーバは、これらのメソッドをサポートするために必要とされず、実際にサポートされている方法を与える応答して許可ヘッダーを含むべきです。"
    },
    {
      "indent": 6,
      "text": "A proxy MUST NOT modify the Allow header field even if it does not understand all the methods specified, since the user agent might have other means of communicating with the origin server.",
      "ja": "ユーザエージェントがオリジンサーバとの通信の他の手段を持っているかもしれないので、それは、指定されたすべてのメソッドを理解していない場合でも、プロキシはAllowヘッダーフィールドを変更してはいけません。"
    },
    {
      "indent": 0,
      "text": "14.8 Authorization",
      "section_title": true,
      "ja": "14.8認証"
    },
    {
      "indent": 6,
      "text": "A user agent that wishes to authenticate itself with a server--\nusually, but not necessarily, after receiving a 401 response--does\nso by including an Authorization request-header field with the\nrequest.  The Authorization field value consists of credentials\ncontaining the authentication information of the user agent for\nthe realm of the resource being requested.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Authorization = \"Authorization\" \":\" credentials",
      "ja": "認証=「認可」「：」の資格情報"
    },
    {
      "indent": 6,
      "text": "HTTP access authentication is described in \"HTTP Authentication: Basic and Digest Access Authentication\" [43]. If a request is authenticated and a realm specified, the same credentials SHOULD be valid for all other requests within this realm (assuming that the authentication scheme itself does not require otherwise, such as credentials that vary according to a challenge value or using synchronized clocks).",
      "ja": "[43]：HTTPアクセス認証は、「基本とダイジェストアクセス認証HTTP認証」に記載されています。要求が認証され、領域が指定されている場合は、同じ資格情報が（例えば、チャレンジ値に応じて、または同期したクロックを用いて変化資格情報として、認証方式自体が他を必要としないと仮定して）、この領域内の他のすべての要求に対して有効である必要があり。"
    },
    {
      "indent": 6,
      "text": "When a shared cache (see section 13.7) receives a request containing an Authorization field, it MUST NOT return the corresponding response as a reply to any other request, unless one of the following specific exceptions holds:",
      "ja": "共有キャッシュは（セクション13.7を参照）Authorizationフィールドを含むリクエストを受信すると、以下の特定の例外のいずれかが成立しない限り、それは、他の要求に対する応答として、対応する応答を返してはなりません。"
    },
    {
      "indent": 6,
      "text": "1. If the response includes the \"s-maxage\" cache-control directive, the cache MAY use that response in replying to a subsequent request. But (if the specified maximum age has passed) a proxy cache MUST first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate the new request. (This is the defined behavior for s-maxage.) If the response includes \"s-maxage=0\", the proxy MUST always revalidate it before re-using it.",
      "ja": "1.応答は、「S-MAXAGE」キャッシュ制御ディレクティブが含まれている場合、キャッシュは、後続の要求に応答してその応答を使用するかもしれません。 （指定された最大年齢が経過している場合）でも、プロキシキャッシュは、最初のオリジンサーバが新しい要求を認証できるようにするために、新たなリクエストからリクエストヘッダを使用して、オリジンサーバでそれを再検証しなければなりません。応答が「= 0 S-MAXAGE」が含まれている場合（これは、S-MAXAGEための定義された動作である。）、プロキシは常にそれを再使用する前にそれを再検証しなければなりません。"
    },
    {
      "indent": 6,
      "text": "2. If the response includes the \"must-revalidate\" cache-control directive, the cache MAY use that response in replying to a subsequent request. But if the response is stale, all caches MUST first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate the new request.",
      "ja": "2.応答が「MUST-再検証」キャッシュ制御ディレクティブが含まれている場合、キャッシュは、後続の要求に応答してその応答を使用するかもしれません。レスポンスが古くなっている場合でも、すべてのキャッシュは、最初のオリジンサーバが新しい要求を認証できるようにするために、新たなリクエストからリクエストヘッダを使用して、オリジンサーバでそれを再検証しなければなりません。"
    },
    {
      "indent": 6,
      "text": "3. If the response includes the \"public\" cache-control directive, it MAY be returned in reply to any subsequent request.",
      "ja": "3.応答が「公共」キャッシュ制御ディレクティブが含まれている場合、それはそれ以降の要求に対する応答で返されることがあります。"
    },
    {
      "indent": 0,
      "text": "14.9 Cache-Control",
      "section_title": true,
      "ja": "14.9のCache-Control"
    },
    {
      "indent": 3,
      "text": "The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. The directives specify behavior intended to prevent caches from adversely interfering with the request or response. These directives typically override the default caching algorithms. Cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive is to be given in the response.",
      "ja": "Cache-Control一般ヘッダフィールドは、要求/応答チェーンに沿ったすべてのキャッシングメカニズムが従わなければならないディレクティブを指定するために使用されます。ディレクティブは、要求または応答に悪影響を及ぼすからキャッシュを行わないようにするための動作を指定します。これらのディレクティブは、通常、デフォルトのキャッシングアルゴリズムを上書きします。リクエスト内のディレクティブの存在は同じディレクティブは対応して与えられることにあることを意味するものではないという点で、キャッシュのディレクティブは単方向です。"
    },
    {
      "indent": 6,
      "text": "Note that HTTP/1.0 caches might not implement Cache-Control and might only implement Pragma: no-cache (see section 14.32).",
      "ja": "キャッシュなし（項14.32を参照してください）：1.0キャッシュがのCache-Controlを実装していない可能性がありますとだけプラグマを実装するかもしれない/そのHTTPに注意してください。"
    },
    {
      "indent": 3,
      "text": "Cache directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to specify a cache-directive for a specific cache.",
      "ja": "ディレクティブは、要求/応答チェーンに沿ってすべての受信者に適用可能であるかもしれないので、キャッシュディレクティブは関係なく、そのアプリケーションに対するそれらの重要性の、プロキシまたはゲートウェイアプリケーションが通過しなければなりません。特定のキャッシュのキャッシュ・ディレクティブを指定することはできません。"
    },
    {
      "indent": 4,
      "text": "Cache-Control = \"Cache-Control\" \":\" 1#cache-directive",
      "ja": "Cache-Control = \"のCache-Control\" \"：\" 1つの＃キャッシュディレクティブ"
    },
    {
      "indent": 4,
      "text": "cache-directive = cache-request-directive | cache-response-directive",
      "ja": "キャッシュ・ディレクティブ=キャッシュ要求ディレクティブ|キャッシュ・レスポンスディレクティブ"
    },
    {
      "indent": 4,
      "text": "cache-request-directive = \"no-cache\" ; Section 14.9.1 | \"no-store\" ; Section 14.9.2 | \"max-age\" \"=\" delta-seconds ; Section 14.9.3, 14.9.4 | \"max-stale\" [ \"=\" delta-seconds ] ; Section 14.9.3 | \"min-fresh\" \"=\" delta-seconds ; Section 14.9.3 | \"no-transform\" ; Section 14.9.5 | \"only-if-cached\" ; Section 14.9.4 | cache-extension ; Section 14.9.6",
      "ja": "キャッシュ・リクエスト・ディレクティブ=「キャッシュなし」。セクション14.9.1 | 「無店舗ません」。セクション14.9.2 | 「MAX-年齢」「=」デルタ - 秒。セクション14.9.3、14.9.4 | \"MAX-古い\" [ \"=\" デルタ秒];セクション14.9.3 | 「MIN-新鮮」「=」デルタ - 秒。セクション14.9.3 | 「無変換ありません」。セクション14.9.5 | 「キャッシュされただけ-場合、」;セクション14.9.4 |キャッシュの拡張;セクション14.9.6"
    },
    {
      "indent": 5,
      "text": "cache-response-directive = \"public\" ; Section 14.9.1 | \"private\" [ \"=\" <\"> 1#field-name <\"> ] ; Section 14.9.1 | \"no-cache\" [ \"=\" <\"> 1#field-name <\"> ]; Section 14.9.1 | \"no-store\" ; Section 14.9.2 | \"no-transform\" ; Section 14.9.5 | \"must-revalidate\" ; Section 14.9.4 | \"proxy-revalidate\" ; Section 14.9.4 | \"max-age\" \"=\" delta-seconds ; Section 14.9.3 | \"s-maxage\" \"=\" delta-seconds ; Section 14.9.3 | cache-extension ; Section 14.9.6",
      "ja": "キャッシュ・レスポンス・ディレクティブ=「公共」。セクション14.9.1 | \"プライベート\" [ \"=\" < \"> 1＃フィールド名<\">];セクション14.9.1 | \"ノーキャッシュ\" [ \"=\" < \"> 1＃フィールド名<\">]。セクション14.9.1 | 「無店舗ません」。セクション14.9.2 | 「無変換ありません」。セクション14.9.5 | 「-再検証しなければなりません」。セクション14.9.4 | 「プロキシ再検証」。セクション14.9.4 | 「MAX-年齢」「=」デルタ - 秒。セクション14.9.3 | \"S-MAXAGE\" \"=\" デルタ - 秒。セクション14.9.3 |キャッシュの拡張;セクション14.9.6"
    },
    {
      "indent": 4,
      "text": "cache-extension = token [ \"=\" ( token | quoted-string ) ]",
      "ja": "キャッシュ延長=トークン[「=」（トークン|引用符で囲まれた文字列）]"
    },
    {
      "indent": 3,
      "text": "When a directive appears without any 1#field-name parameter, the directive applies to the entire request or response. When such a directive appears with a 1#field-name parameter, it applies only to the named field or fields, and not to the rest of the request or response. This mechanism supports extensibility; implementations of future versions of the HTTP protocol might apply these directives to header fields not defined in HTTP/1.1.",
      "ja": "ディレクティブは任意の1＃フィールド名パラメータなしで表示された場合、ディレクティブは全体の要求または応答に適用されます。そのようなディレクティブは1＃フィールド名パラメーターを指定して表示されたら、それは要求または応答の残りの部分にのみ名前のフィールドまたはフィールドに適用され、そしてません。このメカニズムは、拡張性をサポートしています。 HTTPプロトコルの将来のバージョンの実装では、HTTP / 1.1で定義されていないフィールドをヘッダにこれらのディレクティブを適用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "The cache-control directives can be broken down into these general categories:",
      "ja": "キャッシュ制御ディレクティブは、これらの一般的なカテゴリに分けることができます。"
    },
    {
      "indent": 6,
      "text": "- Restrictions on what are cacheable; these may only be imposed by the origin server.",
      "ja": " - キャッシュ可能であるかの制限。これらはオリジンサーバによって課される可能性があります。"
    },
    {
      "indent": 6,
      "text": "- Restrictions on what may be stored by a cache; these may be imposed by either the origin server or the user agent.",
      "ja": " - キャッシュによって格納することができるものに制限。これらはオリジンサーバやユーザエージェントのどちらかによって課せられます。"
    },
    {
      "indent": 6,
      "text": "- Modifications of the basic expiration mechanism; these may be imposed by either the origin server or the user agent.",
      "ja": " - 基本的な満期メカニズムの修正;これらはオリジンサーバやユーザエージェントのどちらかによって課せられます。"
    },
    {
      "indent": 6,
      "text": "- Controls over cache revalidation and reload; these may only be imposed by a user agent.",
      "ja": " - キャッシュ再検証とリロード統制。これらは、ユーザーエージェントによって課される可能性があります。"
    },
    {
      "indent": 6,
      "text": "- Control over transformation of entities.",
      "ja": " - エンティティの変換に対する制御。"
    },
    {
      "indent": 6,
      "text": "- Extensions to the caching system.",
      "ja": " - キャッシュシステムへの拡張。"
    },
    {
      "indent": 0,
      "text": "14.9.1 What is Cacheable",
      "section_title": true,
      "ja": "14.9.1キャッシュ可能とは何か"
    },
    {
      "indent": 3,
      "text": "By default, a response is cacheable if the requirements of the request method, request header fields, and the response status indicate that it is cacheable. Section 13.4 summarizes these defaults for cacheability. The following Cache-Control response directives allow an origin server to override the default cacheability of a response:",
      "ja": "リクエストメソッド、リクエストヘッダフィールド、応答ステータスの要件は、それがキャッシュ可能であることを示している場合、デフォルトで、応答がキャッシュ可能です。 13.4節は、キャッシュ可能性のために、これらのデフォルト値をまとめたもの。以下のCache-Controlレスポンス・ディレクティブは、オリジンサーバが応答のデフォルトのキャッシュ可能性を上書きすることができます："
    },
    {
      "indent": 3,
      "text": "public Indicates that the response MAY be cached by any cache, even if it would normally be non-cacheable or cacheable only within a non-shared cache. (See also Authorization, section 14.8, for additional details.)",
      "ja": "国民は応答が、それは通常、唯一の非共有キャッシュ内のキャッシュ不能またはキャッシュ可能だろうしても、任意のキャッシュによってキャッシュされることを示しています。 （詳細については、また許可、セクション14.8を参照してください。）"
    },
    {
      "indent": 3,
      "text": "private Indicates that all or part of the response message is intended for a single user and MUST NOT be cached by a shared cache. This allows an origin server to state that the specified parts of the response are intended for only one user and are not a valid response for requests by other users. A private (non-shared) cache MAY cache the response.",
      "ja": "私的には、全部または応答メッセージの一部は、単一のユーザーを対象とし、共有キャッシュでキャッシュされてはならないことを示します。これは、オリジンサーバが応答の指定された部分が一つだけのユーザーを対象としており、他のユーザーによるリクエストに対する有効な応答ではありませんされていることを述べることができます。プライベート（非共有）キャッシュはレスポンスをキャッシュしてもよいです。"
    },
    {
      "indent": 7,
      "text": "Note: This usage of the word private only controls where the\nresponse may be cached, and cannot ensure the privacy of the\nmessage content.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "no-cache If the no-cache directive does not specify a field-name, then a cache MUST NOT use the response to satisfy a subsequent request without successful revalidation with the origin server. This allows an origin server to prevent caching even by caches that have been configured to return stale responses to client requests.",
      "ja": "ノーキャッシュノーキャッシュディレクティブは、フィールド名を指定していない場合は、キャッシュがオリジンサーバに成功した再検証せずに後続の要求を満たすために応答を使用してはなりません。これも、クライアントの要求に古くなったレスポンスを返すように設定されているキャッシュによるキャッシングを防ぐために、オリジンサーバが可能になります。"
    },
    {
      "indent": 6,
      "text": "If the no-cache directive does specify one or more field-names, then a cache MAY use the response to satisfy a subsequent request, subject to any other restrictions on caching. However, the specified field-name(s) MUST NOT be sent in the response to a subsequent request without successful revalidation with the origin server. This allows an origin server to prevent the re-use of certain header fields in a response, while still allowing caching of the rest of the response.",
      "ja": "キャッシュなしディレクティブは、1つまたは複数のフィールド名を指定しない場合、キャッシュは、キャッシュ上の他の制限を受ける後続の要求を満たすために応答を使用するかもしれません。ただし、指定したフィールド名（複数可）オリジンサーバで成功した再検証せずに次の要求に応答して送ってはいけません。これは、まだ応答の残りのキャッシングを可能にしながら、応答における特定のヘッダフィールドの再使用を防止するために、オリジンサーバが可能になります。"
    },
    {
      "indent": 7,
      "text": "Note: Most HTTP/1.0 caches will not recognize or obey this directive.",
      "ja": "注：ほとんどのHTTP / 1.0キャッシュはこのディレクティブを認識したり従わないであろう。"
    },
    {
      "indent": 0,
      "text": "14.9.2 What May be Stored by Caches",
      "section_title": true,
      "ja": "14.9.2キャッシュによって保存することができるどのような"
    },
    {
      "indent": 3,
      "text": "no-store The purpose of the no-store directive is to prevent the inadvertent release or retention of sensitive information (for example, on backup tapes). The no-store directive applies to the entire message, and MAY be sent either in a response or in a request. If sent in a request, a cache MUST NOT store any part of either this request or any response to it. If sent in a response, a cache MUST NOT store any part of either this response or the request that elicited it. This directive applies to both non-shared and shared caches. \"MUST NOT store\" in this context means that the cache MUST NOT intentionally store the information in non-volatile storage, and MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.",
      "ja": "無店舗ディレクティブの目的を無保管していない（例えば、バックアップテープ上の）機密情報の不注意な解放または保持を防ぐためです。無店舗ディレクティブはメッセージ全体に適用され、それに応答して、または要求のいずれかで送信されるかもしれません。リクエストで送信した場合、キャッシュはこのリクエストかそれへの応答のいずれかの任意の部分を格納してはなりません。応答で送信された場合、キャッシュはこのレスポンスやそれを誘発し、要求のいずれかの任意の部分を格納してはなりません。このディレクティブは非共有と共有の両方のキャッシュに適用されます。この文脈で「保存てはならない」キャッシュが意図的に不揮発性ストレージに情報を格納してはいけませんし、それを転送した後、できるだけ速やかに揮発性の記憶装置から情報を削除するにはベストエフォート型試みを作る必要があります。"
    },
    {
      "indent": 6,
      "text": "Even when this directive is associated with a response, users might explicitly store such a response outside of the caching system (e.g., with a \"Save As\" dialog). History buffers MAY store such responses as part of their normal operation.",
      "ja": "このディレクティブは、応答に関連付けられている場合でも、ユーザーが明示的に（ダイアログ「名前を付けて保存」で、例えば）キャッシュシステムの外にそのような応答を保存することがあります。履歴バッファは、それらの通常の操作の一部として、このような応答を格納することができます。"
    },
    {
      "indent": 6,
      "text": "The purpose of this directive is to meet the stated requirements of certain users and service authors who are concerned about accidental releases of information via unanticipated accesses to cache data structures. While the use of this directive might improve privacy in some cases, we caution that it is NOT in any way a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.",
      "ja": "このディレクティブの目的は、データ構造をキャッシュする予期せぬアクセスを介した情報の不慮のリリースを懸念している特定のユーザーとサービス作者の述べた要件を満たすことです。このディレクティブを使用すると、いくつかのケースでは、プライバシーを向上させるかもしれませんが、我々はそれがどのような方法で、プライバシーを確​​保するための信頼できるか、十分なメカニズムではないことを警告します。特に、悪意のあるまたは妥協キャッシュは認識したり、このディレクティブを遵守し、通信ネットワークは盗聴に対して脆弱であるかもしれないではないかもしれません。"
    },
    {
      "indent": 0,
      "text": "14.9.3 Modifications of the Basic Expiration Mechanism",
      "section_title": true,
      "ja": "基本的な有効期限機構の14.9.3変更"
    },
    {
      "indent": 3,
      "text": "The expiration time of an entity MAY be specified by the origin server using the Expires header (see section 14.21). Alternatively, it MAY be specified using the max-age directive in a response. When the max-age cache-control directive is present in a cached response, the response is stale if its current age is greater than the age value given (in seconds) at the time of a new request for that resource. The max-age directive on a response implies that the response is cacheable (i.e., \"public\") unless some other, more restrictive cache directive is also present.",
      "ja": "エンティティの有効期限は、有効期限ヘッダを使用して、オリジンサーバによって指定することができる（セクション14.21を参照）。また、それは応答のmax-ageディレクティブを使用して指定することができます。最大エージングキャッシュ制御ディレクティブは、キャッシュされたレスポンスに存在している場合は、その現在の年齢がそのリソースに対する新しい要求時に（秒）与えられた年齢値よりも大きい場合、レスポンスは古いです。応答上のmax-ageディレクティブは、他のいくつかの、より制限のキャッシュディレクティブも存在しない限り、応答が（すなわち、「パブリック」）キャッシュ可能であることを意味します。"
    },
    {
      "indent": 3,
      "text": "If a response includes both an Expires header and a max-age directive, the max-age directive overrides the Expires header, even if the Expires header is more restrictive. This rule allows an origin server to provide, for a given response, a longer expiration time to an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be useful if certain HTTP/1.0 caches improperly calculate ages or expiration times, perhaps due to desynchronized clocks.",
      "ja": "応答は両方を含むヘッダとmax-ageディレクティブを満了した場合、ヘッダは、より限定的である有効期限も、最大エージングディレクティブは、Expiresヘッダを上書きします。このルールは、HTTP / 1.1（以降）に、与えられた応答のために、HTTP / 1.0キャッシュよりもキャッシュを長い有効期限を提供するために、オリジンサーバが可能になります。特定のHTTP / 1.0キャッシュが不適切おそらく非同期クロックに、年齢や有効期限を計算する場合に便利かもしれません。"
    },
    {
      "indent": 3,
      "text": "Many HTTP/1.0 cache implementations will treat an Expires value that is less than or equal to the response Date value as being equivalent to the Cache-Control response directive \"no-cache\". If an HTTP/1.1 cache receives such a response, and the response does not include a Cache-Control header field, it SHOULD consider the response to be non-cacheable in order to retain compatibility with HTTP/1.0 servers.",
      "ja": "多くのHTTP / 1.0キャッシュ実装はキャッシュ制御応答指令「キャッシュなし」と同等であるとして応答日付値以下の値を期限切れに扱います。 HTTP / 1.1キャッシュは、このような応答を受信し、応答がCache-Controlヘッダフィールドが含まれていない場合は、HTTP / 1.0のサーバとの互換性を保持するためにキャッシュ不能であることを応答を検討すべきです。"
    },
    {
      "indent": 7,
      "text": "Note: An origin server might wish to use a relatively new HTTP\ncache control feature, such as the \"private\" directive, on a\nnetwork including older caches that do not understand that\nfeature. The origin server will need to combine the new feature\nwith an Expires field whose value is less than or equal to the\nDate value. This will prevent older caches from improperly\ncaching the response.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "s-maxage If a response includes an s-maxage directive, then for a shared cache (but not for a private cache), the maximum age specified by this directive overrides the maximum age specified by either the max-age directive or the Expires header. The s-maxage directive also implies the semantics of the proxy-revalidate directive (see section 14.9.4), i.e., that the shared cache must not use the entry after it becomes stale to respond to a subsequent request without first revalidating it with the origin server. The s-maxage directive is always ignored by a private cache.",
      "ja": "S-MAXAGE応答をS-MAXAGE指令が含まれている場合、（ただし、プライベートキャッシュの）共有キャッシュのために、このディレクティブによって指定された最大年齢はMAXAGEディレクティブまたは有効期限ヘッダのいずれかによって指定された最大年齢をオーバーライド。 S-MAXAGEディレクティブはまた、プロキシ再検証ディレクティブの意味を暗示し、それがその後の要求に応答するために古くなった後に共有キャッシュは最初にそれを再確認なしのエントリを使用してはならないこと、すなわち、（セクション14.9.4を参照してください）オリジンサーバ。 S-MAXAGEディレクティブは常に民間キャッシュによって無視されます。"
    },
    {
      "indent": 3,
      "text": "Note that most older caches, not compliant with this specification, do not implement any cache-control directives. An origin server wishing to use a cache-control directive that restricts, but does not prevent, caching by an HTTP/1.1-compliant cache MAY exploit the requirement that the max-age directive overrides the Expires header, and the fact that pre-HTTP/1.1-compliant caches do not observe the max-age directive.",
      "ja": "最も古いキャッシュは、この仕様に準拠していない、任意のキャッシュ制御ディレクティブを実装していないことに注意してください。オリジンサーバが制限キャッシュ制御ディレクティブを使用したいが、MAX-ageディレクティブはExpiresヘッダを上書きします要件を利用することができるHTTP / 1.1準拠のキャッシュにより、キャッシュを防ぐことはできませんし、実際にその前のHTTP /1.1-compliantキャッシュは、max-ageディレクティブを観察していません。"
    },
    {
      "indent": 3,
      "text": "Other directives allow a user agent to modify the basic expiration mechanism. These directives MAY be specified on a request:",
      "ja": "他のディレクティブは、ユーザエージェントが基本満期メカニズムを修正することができます。これらのディレクティブは、リクエストに応じて指定することができます。"
    },
    {
      "indent": 3,
      "text": "max-age Indicates that the client is willing to accept a response whose age is no greater than the specified time in seconds. Unless max-stale directive is also included, the client is not willing to accept a stale response.",
      "ja": "最大エージングは​​、クライアントがその年齢秒で指定した時間よりも大きくない応答を受け入れることを望んでいることを示します。 MAX-古いディレクティブも含まれていない限り、クライアントは古くなったレスポンスを受け入れることを望んでいません。"
    },
    {
      "indent": 3,
      "text": "min-fresh Indicates that the client is willing to accept a response whose freshness lifetime is no less than its current age plus the specified time in seconds. That is, the client wants a response that will still be fresh for at least the specified number of seconds.",
      "ja": "分-フレッシュは、クライアントがその新鮮生涯その現在の年齢プラス秒で指定された時間以上である応答を受け入れることを望んでいることを示します。これは、クライアントがまだ秒の少なくとも指定された数のために新鮮になります応答を望んでいる、です。"
    },
    {
      "indent": 3,
      "text": "max-stale Indicates that the client is willing to accept a response that has exceeded its expiration time. If max-stale is assigned a value, then the client is willing to accept a response that has exceeded its expiration time by no more than the specified number of seconds. If no value is assigned to max-stale, then the client is willing to accept a stale response of any age.",
      "ja": "MAX-古いは、クライアントがその有効期限を超過した応答を受け入れる用意があることを示します。 MAX-古いに値が割り当てられている場合、クライアントは、指定された秒数を超えないことによって、その有効期限を超過した応答を受け入れていく所存です。値がMAX-陳腐に割り当てられていない場合は、クライアントはすべての年齢の古い応答を受け入れていく所存です。"
    },
    {
      "indent": 3,
      "text": "If a cache returns a stale response, either because of a max-stale directive on a request, or because the cache is configured to override the expiration time of a response, the cache MUST attach a Warning header to the stale response, using Warning 110 (Response is stale).",
      "ja": "キャッシュは、いずれかのための要求にMAX-失効指示の失効応答を返した場合、キャッシュは、応答の有効期限を無効にするように構成されているため、あるいは、キャッシュが警告110を使用して、古くなった応答に警告ヘッダを添付しなければなりません（レスポンスは古くなっています）。"
    },
    {
      "indent": 3,
      "text": "A cache MAY be configured to return stale responses without validation, but only if this does not conflict with any \"MUST\"-level requirements concerning cache validation (e.g., a \"must-revalidate\" cache-control directive).",
      "ja": "キャッシュは、検証されずに古くなったレスポンスを返すように設定することができるが、これはキャッシュの検証（例えば、「MUST-再検証」キャッシュ制御ディレクティブ）に関する任意の「MUST」レベルの要件と競合しない場合にのみ。"
    },
    {
      "indent": 3,
      "text": "If both the new request and the cached entry include \"max-age\" directives, then the lesser of the two values is used for determining the freshness of the cached entry for that request.",
      "ja": "新しい要求とキャッシュされたエントリの両方が「最大エージング」ディレクティブが含まれている場合、2つの値の小さい方がその要求のためにキャッシュされたエントリの鮮度を決定するために使用されます。"
    },
    {
      "indent": 0,
      "text": "14.9.4 Cache Revalidation and Reload Controls",
      "section_title": true,
      "ja": "14.9.4キャッシュの再検証と再読み込みコントロール"
    },
    {
      "indent": 3,
      "text": "Sometimes a user agent might want or need to insist that a cache revalidate its cache entry with the origin server (and not just with the next cache along the path to the origin server), or to reload its cache entry from the origin server. End-to-end revalidation might be necessary if either the cache or the origin server has overestimated the expiration time of the cached response. End-to-end reload may be necessary if the cache entry has become corrupted for some reason.",
      "ja": "時には、ユーザーエージェントが欲しいかキャッシュがオリジンサーバ（だけでなく、オリジンサーバーへのパスに沿って次キャッシュを持つ）とのキャッシュエントリを再検証することを主張するために、またはオリジンサーバからそのキャッシュエントリをリロードする必要がある場合があります。キャッシュやオリジンサーバのどちらかがキャッシュされたレスポンスの有効期限を過大評価した場合、エンド・ツー・エンドの再検証が必要になる場合があります。キャッシュエントリが何らかの理由で破損した場合、エンド・ツー・エンドのリロードが必要になることがあります。"
    },
    {
      "indent": 3,
      "text": "End-to-end revalidation may be requested either when the client does not have its own local cached copy, in which case we call it \"unspecified end-to-end revalidation\", or when the client does have a local cached copy, in which case we call it \"specific end-to-end revalidation.\"",
      "ja": "クライアントは、私たちは「不特定のエンド・ツー・エンドの再検証」と呼んで、その場合には、独自のローカルにキャッシュされたコピーを持っていない場合、エンドツーエンドの再検証は、いずれかを要求することができる、またはクライアントがローカルにキャッシュされたコピーを持っていたときに、中その場合、我々はそれを呼び出す「特定のエンド・ツー・エンドの再検証。」"
    },
    {
      "indent": 3,
      "text": "The client can specify these three kinds of action using Cache-Control request directives:",
      "ja": "クライアントはのCache-Control要求ディレクティブを使用して、アクションのこれらの3種類の指定できます。"
    },
    {
      "indent": 3,
      "text": "End-to-end reload The request includes a \"no-cache\" cache-control directive or, for compatibility with HTTP/1.0 clients, \"Pragma: no-cache\". Field names MUST NOT be included with the no-cache directive in a request. The server MUST NOT use a cached copy when responding to such a request.",
      "ja": "エンドツーエンドの要求は「キャッシュなし」キャッシュ制御ディレクティブが含まれたり、HTTP / 1.0クライアントとの互換性のために、「プラグマ：キャッシュなし」リロード。フィールド名は、要求におけるキャッシュなしディレクティブに含んではいけません。そのような要求に応答するとき、サーバは、キャッシュされたコピーを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "Specific end-to-end revalidation The request includes a \"max-age=0\" cache-control directive, which forces each cache along the path to the origin server to revalidate its own entry, if any, with the next cache or server. The initial request includes a cache-validating conditional with the client's current validator.",
      "ja": "特定のエンド・ツー・エンドの再検証要求があれば次のキャッシュまたはサーバーに、独自のエントリを再検証するために、オリジンサーバーへのパスに沿って各キャッシュを強制的に「MAX-年齢= 0」キャッシュ制御ディレクティブが含まれています。最初のリクエストは、キャッシュ・検証し、クライアントの現在のバリデータとの条件付き。"
    },
    {
      "indent": 3,
      "text": "Unspecified end-to-end revalidation The request includes \"max-age=0\" cache-control directive, which forces each cache along the path to the origin server to revalidate its own entry, if any, with the next cache or server. The initial request does not include a cache-validating conditional; the first cache along the path (if any) that holds a cache entry for this resource includes a cache-validating conditional with its current validator.",
      "ja": "未指定のエンドツーエンド再検証要求があれば次のキャッシュまたはサーバーに、独自のエントリを再検証するために、オリジンサーバーへのパスに沿って各キャッシュを強制的に「MAX-年齢= 0」キャッシュ制御ディレクティブが含まれています。最初のリクエストは、キャッシュの検証の条件が含まれていません。このリソースのキャッシュ・エントリを保持するパス（もしあれば）に沿った第1のキャッシュは、キャッシュ検証現在のバリと条件を含みます。"
    },
    {
      "indent": 3,
      "text": "max-age When an intermediate cache is forced, by means of a max-age=0 directive, to revalidate its own cache entry, and the client has supplied its own validator in the request, the supplied validator might differ from the validator currently stored with the cache entry. In this case, the cache MAY use either validator in making its own request without affecting semantic transparency.",
      "ja": "最大エージング中間キャッシュが独自のキャッシュエントリを再検証するために、最大エージング= 0ディレクティブによって、強制され、そしてクライアントが要求して、独自のバリデータを提供してきました、供給バリデータは、現在保存されたバリデータと異なる場合がありますキャッシュエントリを持ちます。この場合、キャッシュは、意味の透明性に影響を与えることなく、独自の要求を行うことでバリデータのいずれかを使用するかもしれません。"
    },
    {
      "indent": 6,
      "text": "However, the choice of validator might affect performance. The best approach is for the intermediate cache to use its own validator when making its request. If the server replies with 304 (Not Modified), then the cache can return its now validated copy to the client with a 200 (OK) response. If the server replies with a new entity and cache validator, however, the intermediate cache can compare the returned validator with the one provided in the client's request, using the strong comparison function. If the client's validator is equal to the origin server's, then the intermediate cache simply returns 304 (Not Modified). Otherwise, it returns the new entity with a 200 (OK) response.",
      "ja": "しかし、バリデータの選択がパフォーマンスに影響を与える可能性があります。最善のアプローチは、その要求を行う際に、独自のバリデータを使用するための中間キャッシュのためです。サーバは304（変更不可）で応答した場合、キャッシュは200（OK）応答をクライアントに今、検証のコピーを返すことができます。サーバが新しいエンティティとキャッシュバリデータで応答した場合は、しかし、中間キャッシュは強い比較機能を使用して、クライアントの要求に提供される一つで返されたバリデータを比較することができます。クライアントのバリデータがオリジンサーバのと同じであれば、中間キャッシュは単純に304（変更されていない）を返します。それ以外の場合は、200（OK）応答で新しいエンティティを返します。"
    },
    {
      "indent": 6,
      "text": "If a request includes the no-cache directive, it SHOULD NOT include min-fresh, max-stale, or max-age.",
      "ja": "要求はキャッシュなしのディレクティブが含まれている場合、それは、新鮮な最小最大 - 古い、または最大エージングを含めないでください。"
    },
    {
      "indent": 3,
      "text": "only-if-cached In some cases, such as times of extremely poor network connectivity, a client may want a cache to return only those responses that it currently has stored, and not to reload or revalidate with the origin server. To do this, the client may include the only-if-cached directive in a request. If it receives this directive, a cache SHOULD either respond using a cached entry that is consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status. However, if a group of caches is being operated as a unified system with good internal connectivity, such a request MAY be forwarded within that group of caches.",
      "ja": "いくつかのケースでは、キャッシュされた場合にのみ、このような極めて悪いネットワーク接続の時間として、クライアントはキャッシュが現在保存されたことのみ応答を返すようにしたいことがあり、かつリロードまたはオリジンサーバで再検証しません。これを行うには、クライアントはリクエストでのみ-IF-キャッシュされたディレクティブを含むことができます。それはこの指令を受信した場合、キャッシュは、いずれかの要求の他の制約と一致しているキャッシュされたエントリを使用して応答する、または504（ゲートウェイタイムアウト）ステータスで応答する必要があります。キャッシュのグループが良好な内部接続で統一されたシステムとして動作している場合は、そのような要求は、キャッシュのそのグループ内で転送されてもよいです。"
    },
    {
      "indent": 3,
      "text": "must-revalidate Because a cache MAY be configured to ignore a server's specified expiration time, and because a client request MAY include a max-stale directive (which has a similar effect), the protocol also includes a mechanism for the origin server to require revalidation of a cache entry on any subsequent use. When the must-revalidate directive is present in a response received by a cache, that cache MUST NOT use the entry after it becomes stale to respond to a subsequent request without first revalidating it with the origin server. (I.e., the cache MUST do an end-to-end revalidation every time, if, based solely on the origin server's Expires or max-age value, the cached response is stale.)",
      "ja": "キャッシュは、サーバーの指定された有効期限を無視するように構成することができ、クライアントの要求は（同様の効果を持っている）MAX-古いディレクティブが含まれる可能性があるため、プロトコルはまた、再検証を要求するオリジンサーバのための機構を備えているため、再検証する必要があります任意のその後の使用上のキャッシュエントリの。必携再検証ディレクティブは、キャッシュが受信した応答中に存在する場合、それは最初にオリジンサーバとそれを再検証せずに、後続の要求に応答するために古くなった後、そのキャッシュエントリを使用してはなりません。 （のみに基づいて、場合つまり、キャッシュは、エンド・ツー・エンドの再検証を毎回行う必要がありますオリジンサーバの有効期限や最大エージング値は、キャッシュされたレスポンスが古くなっています。）"
    },
    {
      "indent": 6,
      "text": "The must-revalidate directive is necessary to support reliable operation for certain protocol features. In all circumstances an HTTP/1.1 cache MUST obey the must-revalidate directive; in particular, if the cache cannot reach the origin server for any reason, it MUST generate a 504 (Gateway Timeout) response.",
      "ja": "必携再検証ディレクティブは、特定のプロトコル機能の信頼性の高い動作をサポートするために必要です。すべての状況ではHTTP / 1.1キャッシュは必見-再検証指示に従わなければなりません。キャッシュが何らかの理由でオリジンサーバに到達できない場合は特に、それは504（ゲートウェイタイムアウト）応答を生成しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Servers SHOULD send the must-revalidate directive if and only if failure to revalidate a request on the entity could result in incorrect operation, such as a silently unexecuted financial transaction. Recipients MUST NOT take any automated action that violates this directive, and MUST NOT automatically provide an unvalidated copy of the entity if revalidation fails.",
      "ja": "サーバーは必見再検証指示を送るべきである場合に限り、そのような静かに未実行の金融取引として正しくない動作になる可能性が実体上の要求を再検証に失敗。受信者はこの指示に違反する自動化された行動を取るてはならない、と再検証が失敗した場合、自動的にエンティティの未検証のコピーを提供してはなりません。"
    },
    {
      "indent": 6,
      "text": "Although this is not recommended, user agents operating under severe connectivity constraints MAY violate this directive but, if so, MUST explicitly warn the user that an unvalidated response has been provided. The warning MUST be provided on each unvalidated access, and SHOULD require explicit user confirmation.",
      "ja": "これはお勧めしませんが、厳しい接続制約の下で操作するユーザエージェントは、このディレクティブに違反するかもしれませんが、もしそうであれば、明示的に未検証のレスポンスが提供されたことをユーザーに警告しなければなりません。警告は、各未検証のアクセスに提供されなければならない、と明示的なユーザの確認を要求する必要があります。"
    },
    {
      "indent": 3,
      "text": "proxy-revalidate The proxy-revalidate directive has the same meaning as the must-revalidate directive, except that it does not apply to non-shared user agent caches. It can be used on a response to an authenticated request to permit the user's cache to store and later return the response without needing to revalidate it (since it has already been authenticated once by that user), while still requiring proxies that service many users to revalidate each time (in order to make sure that each user has been authenticated). Note that such authenticated responses also need the public cache control directive in order to allow them to be cached at all.",
      "ja": "プロキシ再検証ディレクティブをプロキシ再検証、非共有ユーザエージェントキャッシュには適用されないことを除いて、必見再検証ディレクティブと同じ意味を持っています。まだ必要としながら、プロキシはに多くのユーザー、サービス、保存し、後で（それはすでにそのユーザが一度認証されたので）それを再検証する必要なしに応答を返すために、ユーザーのキャッシュを可能にするために、認証要求への応答に使用することができます（各ユーザーが認証されていることを確認するために）毎回再検証。このように認証応答はまた、彼らはまったくキャッシュされることを可能にするために公共のキャッシュ制御ディレクティブが必要であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "14.9.5 No-Transform Directive",
      "section_title": true,
      "ja": "14.9.5無変換指令"
    },
    {
      "indent": 3,
      "text": "no-transform Implementors of intermediate caches (proxies) have found it useful to convert the media type of certain entity bodies. A non-transparent proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link.",
      "ja": "中間キャッシュ（プロキシ）の無変換実装者は、それが有用な特定のエンティティボディのメディアタイプを変換することが分かってきました。非透過プロキシは、例えば、キャッシュスペースを節約するか、低速リンク上のトラフィックの量を削減するために、画像フォーマット間の変換可能性があります。"
    },
    {
      "indent": 6,
      "text": "Serious operational problems occur, however, when these transformations are applied to entity bodies intended for certain kinds of applications. For example, applications for medical imaging, scientific data analysis and those using end-to-end authentication, all depend on receiving an entity body that is bit for bit identical to the original entity-body.",
      "ja": "これらの変換は、アプリケーションの特定の種類のために意図されたエンティティボディに適用した場合、深刻な操作上の問題は、しかし、起こります。例えば、医療用画像、科学的データ分析とエンドツーエンド認証を使用してそれらのためのアプリケーションは、すべての元のエンティティボディと同一ビットのビットであるエンティティボディを受信するに依存します。"
    },
    {
      "indent": 6,
      "text": "Therefore, if a message includes the no-transform directive, an intermediate cache or proxy MUST NOT change those headers that are listed in section 13.5.2 as being subject to the no-transform directive. This implies that the cache or proxy MUST NOT change any aspect of the entity-body that is specified by these headers, including the value of the entity-body itself.",
      "ja": "メッセージが無変換命令を含む場合したがって、中間キャッシュまたはプロキシは、無変換指令を受けることとして、セクション13.5.2に記載されているこれらのヘッダを変更しないでください。これは、キャッシュまたはプロキシは、エンティティボディ自体の値を含むこれらのヘッダによって指定されるエンティティボディの任意の態様を変更してはいけませんことを意味します。"
    },
    {
      "indent": 0,
      "text": "14.9.6 Cache Control Extensions",
      "section_title": true,
      "ja": "14.9.6キャッシュ制御拡張機能"
    },
    {
      "indent": 3,
      "text": "The Cache-Control header field can be extended through the use of one or more cache-extension tokens, each with an optional assigned value. Informational extensions (those which do not require a change in cache behavior) MAY be added without changing the semantics of other directives. Behavioral extensions are designed to work by acting as modifiers to the existing base of cache directives. Both the new directive and the standard directive are supplied, such that applications which do not understand the new directive will default to the behavior specified by the standard directive, and those that understand the new directive will recognize it as modifying the requirements associated with the standard directive. In this way, extensions to the cache-control directives can be made without requiring changes to the base protocol.",
      "ja": "キャッシュ制御ヘッダフィールドは、オプションの割り当てられた値を有する1つ以上のキャッシュ拡張トークン、それぞれの使用を通じて拡張することができます。情報の拡張（キャッシュの振る舞いの変更を必要としないもの）は、他のディレクティブの意味を変えずに追加される場合があります。行動拡張がキャッシュディレクティブの既存のベースへの修飾子として作用することによって動作するように設計されています。どちらも新しいディレクティブと標準ディレクティブは、新しいディレクティブを理解していないアプリケーションは、標準のディレクティブで指定された動作がデフォルトになりますように、供給され、新しいディレクティブを理解しているものは、標準的に関連付けられている要件を変更すると、それを認識します指令。このように、キャッシュ制御指令への拡張は、ベースプロトコルへの変更を必要とせずに行うことができます。"
    },
    {
      "indent": 3,
      "text": "This extension mechanism depends on an HTTP cache obeying all of the cache-control directives defined for its native HTTP-version, obeying certain extensions, and ignoring all directives that it does not understand.",
      "ja": "この拡張メカニズムは、特定の拡張子に従うと、それは理解していないすべてのディレクティブを無視して、そのネイティブHTTP-バージョン用に定義されたキャッシュ制御ディレクティブのすべてに従うHTTPキャッシュに依存します。"
    },
    {
      "indent": 3,
      "text": "For example, consider a hypothetical new response directive called community which acts as a modifier to the private directive. We define this new directive to mean that, in addition to any non-shared cache, any cache which is shared only by members of the community named within its value may cache the response. An origin server wishing to allow the UCI community to use an otherwise private response in their shared cache(s) could do so by including",
      "ja": "たとえば、プライベートディレクティブの修飾子として機能し、コミュニティと呼ばれる架空の新しい応答ディレクティブを考えます。私たちは、任意の非共有キャッシュに加えて、唯一のその値の範囲内という名前のコミュニティのメンバーによって共有されているすべてのキャッシュがレスポンスをキャッシュしてもよい、ということを意味するために、この新しいディレクティブを定義します。 UCIコミュニティは彼らの共有キャッシュ（複数可）で特に民間応答を使用できるようにしたいオリジンサーバは、以下を含むことによって行うことができ"
    },
    {
      "indent": 7,
      "text": "Cache-Control: private, community=\"UCI\"",
      "ja": "Cache-Control：プライベート、コミュニティ= \"UCI\""
    },
    {
      "indent": 3,
      "text": "A cache seeing this header field will act correctly even if the cache does not understand the community cache-extension, since it will also see and understand the private directive and thus default to the safe behavior.",
      "ja": "キャッシュはコミュニティのキャッシュ拡張を理解していない場合でも、それはまた、参照とプライベートディレクティブを理解し、したがって、安全な振る舞いをデフォルトとしますので、このヘッダフィールドを見キャッシュは、正しく動作します。"
    },
    {
      "indent": 3,
      "text": "Unrecognized cache-directives MUST be ignored; it is assumed that any cache-directive likely to be unrecognized by an HTTP/1.1 cache will be combined with standard directives (or the response's default cacheability) such that the cache behavior will remain minimally correct even if the cache does not understand the extension(s).",
      "ja": "認識できないキャッシュ・ディレクティブを無視しなければなりません。それが想定されているすべてのキャッシュ・ディレクティブキャッシュ動作は、キャッシュが拡張を理解していない場合でも、最小限正しいままにするような標準ディレクティブ（または応答のデフォルトのキャッシュ可能）と組み合わされるHTTP / 1.1キャッシュで認識できない可能性が高いです（秒）。"
    },
    {
      "indent": 0,
      "text": "14.10 Connection",
      "section_title": true,
      "ja": "14.10接続"
    },
    {
      "indent": 3,
      "text": "The Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections.",
      "ja": "接続一般的なヘッダフィールドは、送信者がその特定の接続のために所望され、さらに接続を介してプロキシによって通信されてはいけませんオプションを指定することを可能にします。"
    },
    {
      "indent": 3,
      "text": "The Connection header has the following grammar:",
      "ja": "接続ヘッダは、次の文法を有します。"
    },
    {
      "indent": 7,
      "text": "Connection = \"Connection\" \":\" 1#(connection-token)\nconnection-token  = token",
      "raw": true
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token. Connection options are signaled by the presence of a connection-token in the Connection header field, not by any corresponding additional header field(s), since the additional header field may not be sent if there are no parameters associated with that connection option.",
      "ja": "HTTP / 1.1プロキシはメッセージが転送される前に、接続ヘッダフィールドを解析して、各接続トークンは、この分野では、接続トークンと同じ名前を持つメッセージから任意のヘッダフィールド（複数可）を削除する必要があります。その接続オプションに関連付けられたパラメータがない場合は、追加ヘッダフィールドは送信されないかもしれないので、接続オプションは、接続ヘッダフィールドではなく、任意の対応する追加のヘッダフィールド（複数可）によって接続トークンの存在によってシグナリングされます。"
    },
    {
      "indent": 3,
      "text": "Message headers listed in the Connection header MUST NOT include end-to-end headers, such as Cache-Control.",
      "ja": "接続ヘッダに記載されているメッセージヘッダーは、キャッシュ・コントロールのようなエンド・ツー・エンドのヘッダを含んではいけません。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 defines the \"close\" connection option for the sender to signal that the connection will be closed after completion of the response. For example,",
      "ja": "HTTP / 1.1接続が応答が完了した後に閉鎖されることを知らせるために、送信者のための「クローズ」接続オプションを定義します。例えば、"
    },
    {
      "indent": 7,
      "text": "Connection: close",
      "ja": "接続：近いです"
    },
    {
      "indent": 3,
      "text": "in either the request or the response header fields indicates that the connection SHOULD NOT be considered `persistent' (section 8.1) after the current request/response is complete.",
      "ja": "要求又は応答ヘッダフィールドのいずれかに現在の要求/応答が完了した後、接続が `永続」（セクション8.1）とみなされるべきではないことを示しています。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 applications that do not support persistent connections MUST include the \"close\" connection option in every message.",
      "ja": "持続的な接続をサポートしていないHTTP / 1.1のアプリケーションは、すべてのメッセージで「クローズ」接続オプションを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "A system receiving an HTTP/1.0 (or lower-version) message that includes a Connection header MUST, for each connection-token in this field, remove and ignore any header field(s) from the message with the same name as the connection-token. This protects against mistaken forwarding of such header fields by pre-HTTP/1.1 proxies. See section 19.6.2.",
      "ja": "このフィールドの各接続トークン、connection-と同じ名前を持つメッセージから任意のヘッダフィールド（複数可）を削除し、無視しなければならない接続ヘッダを含むHTTP / 1.0（以下バージョン）メッセージを受信するシステムトークン。これは、事前HTTP / 1.1プロキシによって、このようなヘッダフィールドの誤った転送から保護します。セクション19.6.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "14.11 Content-Encoding",
      "section_title": true,
      "ja": "14.11コンテンツのエンコーディング"
    },
    {
      "indent": 3,
      "text": "The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. Content-Encoding is primarily used to allow a document to be compressed without losing the identity of its underlying media type.",
      "ja": "コンテンツ符号化エンティティ - ヘッダフィールドはメディアタイプの修飾子として使用されます。存在する場合、その値は、追加のコンテンツコーディングが復号メカニズムはContent-Typeヘッダフィールドによって参照されるメディアタイプを得るために適用されなければならないもの、したがってエンティティボディに適用されてきたものを示しています。コンテンツのエンコーディングは、主に文書がその根底にあるメディアタイプのアイデンティティを失わずに圧縮することができるようにするために使用されます。"
    },
    {
      "indent": 7,
      "text": "Content-Encoding = \"Content-Encoding\" \":\" 1#content-coding",
      "ja": "コンテンツのエンコード=「コンテンツエンコード」「：」1＃内容コーディング"
    },
    {
      "indent": 3,
      "text": "Content codings are defined in section 3.5. An example of its use is",
      "ja": "内容コーディングはセクション3.5で定義されています。その使用の例があります"
    },
    {
      "indent": 7,
      "text": "Content-Encoding: gzip",
      "ja": "コンテンツエンコード：gzipで"
    },
    {
      "indent": 3,
      "text": "The content-coding is a characteristic of the entity identified by the Request-URI. Typically, the entity-body is stored with this encoding and is only decoded before rendering or analogous usage. However, a non-transparent proxy MAY modify the content-coding if the new coding is known to be acceptable to the recipient, unless the \"no-transform\" cache-control directive is present in the message.",
      "ja": "コンテンツコードは、Request-URIによって識別されるエンティティの特性です。典型的には、エンティティボディはこのエンコーディングで記​​憶されるのみレンダリングまたは類似の使用の前に復号されます。しかし、新たなコーディングが受信者に許容可能であることが知られている場合は非透過プロキシは、コンテンツコードを修正することができ、「無変換」キャッシュ制御ディレクティブない限り、メッセージ中に存在しています。"
    },
    {
      "indent": 3,
      "text": "If the content-coding of an entity is not \"identity\", then the response MUST include a Content-Encoding entity-header (section 14.11) that lists the non-identity content-coding(s) used.",
      "ja": "エンティティの内容コーディングは「同一」でない場合、応答は、使用される非同一（S）コンテンツコードを一覧表示し、コンテンツ符号化エンティティヘッダ（セクション14.11）を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the content-coding of an entity in a request message is not acceptable to the origin server, the server SHOULD respond with a status code of 415 (Unsupported Media Type).",
      "ja": "要求メッセージ内のエンティティの内容コーディングがオリジンサーバに対して許容できない場合、サーバは415（サポートされていないメディアタイプ）のステータスコードで応答すべきです。"
    },
    {
      "indent": 3,
      "text": "If multiple encodings have been applied to an entity, the content codings MUST be listed in the order in which they were applied. Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.",
      "ja": "複数のエンコーディングがエンティティに適用されている場合は、コンテンツのコーディングは、それらが適用された順にリストされなければなりません。符号化パラメータに関する追加情報は、本明細書で定義されていない他のエンティティヘッダフィールドによって提供されてもよいです。"
    },
    {
      "indent": 0,
      "text": "14.12 Content-Language",
      "section_title": true,
      "ja": "14.12コンテンツの言語"
    },
    {
      "indent": 3,
      "text": "The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body.",
      "ja": "コンテンツ言語エンティティヘッダフィールドは、同封のエンティティの対象読者の自然言語（複数可）を記述する。これは、エンティティボディ内で使用されるすべての言語と同等ではないかもしれないことに注意してください。"
    },
    {
      "indent": 7,
      "text": "Content-Language = \"Content-Language\" \":\" 1#language-tag",
      "ja": "コンテンツ言語=の \"Content-言語\" \"：\" 1＃言語タグ"
    },
    {
      "indent": 3,
      "text": "Language tags are defined in section 3.10. The primary purpose of Content-Language is to allow a user to identify and differentiate entities according to the user's own preferred language. Thus, if the body content is intended only for a Danish-literate audience, the appropriate field is",
      "ja": "言語タグは、セクション3.10で定義されています。コンテンツ言語の主な目的は、ユーザーがユーザー自身の好みの言語に応じて、エンティティを識別し、区別できるようにすることです。本文の内容のみデンマーク読み書き聴衆のために意図されている場合このように、適切なフィールドがあります"
    },
    {
      "indent": 7,
      "text": "Content-Language: da",
      "ja": "コンテンツ言語：ダ"
    },
    {
      "indent": 3,
      "text": "If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended.",
      "ja": "何のContent-言語が指定されていない場合、デフォルトでは、コンテンツは、すべての言語の視聴者のために意図されていることです。これは、送信者が、それは任意の自然言語に固有であると考えて、または送信者は、それが意図されている言語用の知らないことをしないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Multiple languages MAY be listed for content that is intended for multiple audiences. For example, a rendition of the \"Treaty of Waitangi,\" presented simultaneously in the original Maori and English versions, would call for",
      "ja": "複数の言語では、複数の聴衆のために意図されているコンテンツのために表示されることがあります。たとえば、オリジナルのマオリ語版と英語版に同時に提示の演出「ワイタンギ条約は、」、のために呼び出します"
    },
    {
      "indent": 7,
      "text": "Content-Language: mi, en",
      "ja": "コンテンツ言語：私、"
    },
    {
      "indent": 3,
      "text": "However, just because multiple languages are present within an entity does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as \"A First Lesson in Latin,\" which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include \"en\".",
      "ja": "しかし、複数の言語がエンティティ内に存在しているという理由だけで、それが複数の言語の聴衆のために意図されていることを意味するものではありません。例は明らかに英語を読み書き聴衆が使用することを意図しているような初心者の言語プライマー、「ラテン語で最初のレッスン、」だろう。この場合、コンテンツ言語が適切にのみ「EN」が含まれるであろう。"
    },
    {
      "indent": 3,
      "text": "Content-Language MAY be applied to any media type -- it is not limited to textual documents.",
      "ja": "コンテンツ言語は、任意のメディアタイプにも適用することができる - それは、テキスト文書に限定されるものではありません。"
    },
    {
      "indent": 0,
      "text": "14.13 Content-Length",
      "section_title": true,
      "ja": "14.13コンテンツの長さ"
    },
    {
      "indent": 3,
      "text": "The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.",
      "ja": "Content-Lengthエンティティヘッダフィールドは、受信者に送信されるか、または、HEADメソッドの場合には、送信されたであろうエンティティボディのサイズを持っていた、オクテットの10進数で、エンティティボディのサイズを示しますリクエストはGETして。"
    },
    {
      "indent": 7,
      "text": "Content-Length = \"Content-Length\" \":\" 1*DIGIT",
      "ja": "Content-Length = \"のContent-Length\" \"：\" 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "An example is",
      "ja": "例があります"
    },
    {
      "indent": 7,
      "text": "Content-Length: 3495",
      "ja": "コンテンツの長さ：3495"
    },
    {
      "indent": 3,
      "text": "Applications SHOULD use this field to indicate the transfer-length of the message-body, unless this is prohibited by the rules in section 4.4.",
      "ja": "これはセクション4.4の規則によって禁止されない限り、アプリケーションは、メッセージボディの転送長さを示すためにこのフィールドを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Any Content-Length greater than or equal to zero is a valid value. Section 4.4 describes how to determine the length of a message-body if a Content-Length is not given.",
      "ja": "0以上の任意のContent-Lengthは有効な値です。 4.4節は、コンテンツの長さが指定されていない場合はメッセージボディの長さを決定する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "Note that the meaning of this field is significantly different from the corresponding definition in MIME, where it is an optional field used within the \"message/external-body\" content-type. In HTTP, it SHOULD be sent whenever the message's length can be determined prior to being transferred, unless this is prohibited by the rules in section 4.4.",
      "ja": "このフィールドの意味は、それが「message / external-body」というコンテンツ・タイプ内で使用されるオプションのフィールドであるMIME、に対応する定義とは有意に異なることに注意してください。メッセージの長さは、前に転送されることに決定することができるときはいつでも、これはセクション4.4の規則によって禁止されない限り、HTTPにおいては、送信されるべきです。"
    },
    {
      "indent": 0,
      "text": "14.14 Content-Location",
      "section_title": true,
      "ja": "14.14コンテンツの場所"
    },
    {
      "indent": 3,
      "text": "The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource's URI. A server SHOULD provide a Content-Location for the variant corresponding to the response entity; especially in the case where a resource has multiple entities associated with it, and those entities actually have separate locations by which they might be individually accessed, the server SHOULD provide a Content-Location for the particular variant which is returned.",
      "ja": "コンテンツロケーションエンティティヘッダフィールドは、そのエンティティは、要求されたリソースのURIから離れた場所からアクセス可能である場合、メッセージで囲まれたエンティティのリソースの場所を供給するために使用され得ます。サーバは、応答エンティティに対応する変異体のためのコンテンツの場所を提供すべきです。特に、リソースがそれに関連付けられた複数のエンティティを持っており、それらのエンティティは、実際に彼らは個別にアクセスされるかもしれないことで、別の場所を持っている場合には、サーバが返され、特定の変異体のためのContent-場所を提供する必要があります。"
    },
    {
      "indent": 7,
      "text": "Content-Location = \"Content-Location\" \":\"\n                  ( absoluteURI | relativeURI )",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value of Content-Location also defines the base URI for the entity.",
      "ja": "コンテンツロケーションの値はまた、エンティティのベースURIを定義します。"
    },
    {
      "indent": 3,
      "text": "The Content-Location value is not a replacement for the original requested URI; it is only a statement of the location of the resource corresponding to this particular entity at the time of the request. Future requests MAY specify the Content-Location URI as the request-URI if the desire is to identify the source of that particular entity.",
      "ja": "コンテンツの場所の値は、元の要求されたURIに代わるものではありません。それは、要求時に、この特定のエンティティに対応するリソースの場所の唯一の文です。欲求がその特定のエンティティのソースを特定することである場合には、将来の要求は、要求URIとしてContent-場所URIを指定するかもしれません。"
    },
    {
      "indent": 3,
      "text": "A cache cannot assume that an entity with a Content-Location different from the URI used to retrieve it can be used to respond to later requests on that Content-Location URI. However, the Content-Location can be used to differentiate between multiple entities retrieved from a single requested resource, as described in section 13.6.",
      "ja": "キャッシュは、URIは異なるコンテンツの場所を持つエンティティは、そのコンテンツの場所URIの後のリクエストに応答するために使用することができます取得するために使用されることを想定することはできません。しかし、コンテンツの場所は、セクション13.6で説明したように、単一の要求されたリソースから取得複数のエンティティを区別するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "If the Content-Location is a relative URI, the relative URI is interpreted relative to the Request-URI.",
      "ja": "コンテンツの場所が相対URIであれば、相対URIは、Request-URIに関連して解釈されます。"
    },
    {
      "indent": 3,
      "text": "The meaning of the Content-Location header in PUT or POST requests is undefined; servers are free to ignore it in those cases.",
      "ja": "PUTやPOSTリクエストのContent-Locationヘッダーの意味は定義されていません。サーバーは、これらのケースではそれを無視するのは自由です。"
    },
    {
      "indent": 0,
      "text": "14.15 Content-MD5",
      "section_title": true,
      "ja": "14.15のContent-MD5"
    },
    {
      "indent": 3,
      "text": "The Content-MD5 entity-header field, as defined in RFC 1864 [23], is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)",
      "ja": "コンテンツ-MD5エンティティヘッダフィールドは、[23] RFC 1864で定義されるように、エンティティボディのエンドツーエンドのメッセージ完全性チェック（MIC）を提供する目的のためにエンティティボディのMD5ダイジェストです。 （注意：MICは、輸送中のエンティティボディの偶発変更を検出するための良いですが、悪意のある攻撃に対する証拠ではありません。）"
    },
    {
      "indent": 8,
      "text": "Content-MD5   = \"Content-MD5\" \":\" md5-digest\nmd5-digest   = <base64 of 128 bit MD5 digest as per RFC 1864>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Content-MD5 header field MAY be generated by an origin server or client to function as an integrity check of the entity-body. Only origin servers or clients MAY generate the Content-MD5 header field; proxies and gateways MUST NOT generate it, as this would defeat its value as an end-to-end integrity check. Any recipient of the entity-body, including gateways and proxies, MAY check that the digest value in this header field matches that of the entity-body as received.",
      "ja": "Content-MD5ヘッダフィールドはエンティティボディの整合性チェックとして機能するようにオリジンサーバやクライアントによって生成されてもよいです。唯一のオリジンサーバまたはクライアントがコンテンツ-MD5ヘッダフィールドを生成するかもしれません。これは、エンドツーエンドの整合性チェックとしての価値を台無しにしてしまうようプロキシやゲートウェイは、それを生成してはなりません。ゲートウェイやプロキシを含むエンティティボディの受信者は、受信したこのヘッダフィールドのダイジェスト値がエンティティボディのものと一致することを確認することができます。"
    },
    {
      "indent": 3,
      "text": "The MD5 digest is computed based on the content of the entity-body, including any content-coding that has been applied, but not including any transfer-encoding applied to the message-body. If the message is received with a transfer-encoding, that encoding MUST be removed prior to checking the Content-MD5 value against the received entity.",
      "ja": "MD5ダイジェストは、メッセージボディに適用される転送符号化を含む、適用された任意のコンテンツの符号化を含むエンティティボディの内容に基づいて計算され、しかしされていません。メッセージが転送エンコーディングで受信された場合、その符号化は、受信エンティティに対してコンテンツ-MD5値をチェックする前に除去しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This has the result that the digest is computed on the octets of the entity-body exactly as, and in the order that, they would be sent if no transfer-encoding were being applied.",
      "ja": "これは、ダイジェストが正確、及びNO転送符号化が適用されないされていた場合、それらが送信される、ようにするためのようにエンティティボディのオクテットに計算されるという結果を有しています。"
    },
    {
      "indent": 3,
      "text": "HTTP extends RFC 1864 to permit the digest to be computed for MIME\ncomposite media-types (e.g., multipart/* and message/rfc822), but\nthis does not change how the digest is computed as defined in the\npreceding paragraph.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "There are several consequences of this. The entity-body for composite types MAY contain many body-parts, each with its own MIME and HTTP headers (including Content-MD5, Content-Transfer-Encoding, and Content-Encoding headers). If a body-part has a Content-Transfer-Encoding or Content-Encoding header, it is assumed that the content of the body-part has had the encoding applied, and the body-part is included in the Content-MD5 digest as is -- i.e., after the application. The Transfer-Encoding header field is not allowed within body-parts.",
      "ja": "これのいくつかの影響があります。複合タイプのエンティティボディは、多くの身体部分を含んでいてもよく、（コンテンツ-MD5、コンテンツ転送エンコード、およびコンテンツ符号化ヘッダを含む）それ自身のMIMEとHTTPヘッダをそれぞれ。本体部分は、コンテンツ転送エンコードまたはContent-Encodingヘッダーを持っている場合、身体部分の含有量は、符号化が適用されてきた、となるように本体部分がContent-MD5ダイジェストに含まれるものとします - すなわち、塗布した後。転送符号化ヘッダフィールドは、本体部分内に許可されていません。"
    },
    {
      "indent": 3,
      "text": "Conversion of all line breaks to CRLF MUST NOT be done before computing or checking the digest: the line break convention used in the text actually transmitted MUST be left unaltered when computing the digest.",
      "ja": "CRLFにすべての改行の変換は、コンピューティングの前に行うか、ダイジェストをチェックしてはならない：ダイジェストを計算するときに実際に送信されたテキストで使用される改行規則が変更されないままにされなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: while the definition of Content-MD5 is exactly the same for HTTP as in RFC 1864 for MIME entity-bodies, there are several ways in which the application of Content-MD5 to HTTP entity-bodies differs from its application to MIME entity-bodies. One is that HTTP, unlike MIME, does not use Content-Transfer-Encoding, and does use Transfer-Encoding and Content-Encoding. Another is that HTTP more frequently uses binary content types than MIME, so it is worth noting that, in such cases, the byte order used to compute the digest is the transmission byte order defined for the type. Lastly, HTTP allows transmission of text types with any of several line break conventions and not just the canonical form using CRLF.",
      "ja": "注：コンテンツ-MD5の定義は、MIMEエンティティ・ボディのためのRFC 1864のようにHTTPのためのまったく同じである一方で、HTTPエンティティ・ボディへのContent-MD5のアプリケーションは、MIME ENTITY-への応用と異なっているいくつかの方法がありますボディ。一つはHTTPは、MIMEとは異なり、コンテンツ転送エンコードを使用して、転送エンコードおよびContent-encodingを使用していないということです。別のHTTPがより頻繁MIMEよりバイナリコンテンツタイプを使用することであるので、そのようなケースでは、ダイジェストを計算するために使用されるバイト順序がタイプに対して定義された送信バイトオーダーである、ことは注目に値します。最後に、HTTPは、いくつかの改行規則のいずれかとしませCRLFを使用して、単に標準的な形式とテキストタイプの伝送を可能にします。"
    },
    {
      "indent": 0,
      "text": "14.16 Content-Range",
      "section_title": true,
      "ja": "14.16コンテンツレンジ"
    },
    {
      "indent": 3,
      "text": "The Content-Range entity-header is sent with a partial entity-body to specify where in the full entity-body the partial body should be applied. Range units are defined in section 3.12.",
      "ja": "コンテンツ範囲エンティティヘッダは、完全エンティティボディに身体部分が適用されるべき場所を指定する部分エンティティボディで送信されます。レンジユニットは、セクション3.12で定義されています。"
    },
    {
      "indent": 7,
      "text": "Content-Range = \"Content-Range\" \":\" content-range-spec",
      "ja": "コンテンツレンジ=の \"Content-レンジ\" \"：\" コンテンツレンジスペック"
    },
    {
      "indent": 7,
      "text": "content-range-spec = byte-content-range-spec byte-content-range-spec = bytes-unit SP byte-range-resp-spec \"/\" ( instance-length | \"*\" )",
      "ja": "コンテンツレンジ仕様=バイトコンテンツレンジ仕様バイトコンテンツレンジ仕様=バイトユニットSPのバイト範囲-RESP仕様 \"/\"（例えば、長さ| \"*\"）"
    },
    {
      "indent": 7,
      "text": "byte-range-resp-spec = (first-byte-pos \"-\" last-byte-pos) | \"*\" instance-length = 1*DIGIT",
      "ja": "バイト範囲-RESP-スペック=（最初のバイト-POS \" - \" 最後のバイト-POS）| \"*\" インスタンス長= 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "The header SHOULD indicate the total length of the full entity-body, unless this length is unknown or difficult to determine. The asterisk \"*\" character means that the instance-length is unknown at the time when the response was generated.",
      "ja": "この長さは未知又は決定することは困難である場合を除き、ヘッダは、完全なエンティティボディの全長を示すべきです。アスタリスク「*」の文字は、インスタンスの長さは、応答が生成された時点では不明であることを意味しています。"
    },
    {
      "indent": 3,
      "text": "Unlike byte-ranges-specifier values (see section 14.35.1), a byte-range-resp-spec MUST only specify one range, and MUST contain absolute byte positions for both the first and last byte of the range.",
      "ja": "バイト範囲指定子値（セクション14.35.1を参照）とは異なり、バイト範囲-RESP仕様は、1つの範囲を指定しなければならない、そして範囲の最初と最後のバイトの両方の絶対バイト位置を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "A byte-content-range-spec with a byte-range-resp-spec whose last-byte-pos value is less than its first-byte-pos value, or whose instance-length value is less than or equal to its last-byte-pos value, is invalid. The recipient of an invalid byte-content-range-spec MUST ignore it and any content transferred along with it.",
      "ja": "最後のバイト-POS値は、その最初のバイト-POS値未満であるか、またはそのインスタンス長の値より小さいかまたはその直前に入っに等しいバイト範囲-RESP仕様のバイト・コンテンツレンジスペックバイト-POS値は、無効です。無効なバイトコンテンツレンジ仕様の受信者は、それに沿って転送されるコンテンツを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A server sending a response with status code 416 (Requested range not satisfiable) SHOULD include a Content-Range field with a byte-range-resp-spec of \"*\". The instance-length specifies the current length of the selected resource. A response with status code 206 (Partial Content) MUST NOT include a Content-Range field with a byte-range-resp-spec of \"*\".",
      "ja": "（要求された範囲にない）ステータスコード416で応答を送信するサーバは、「*」のバイト範囲-RESP-スペックでのContent-Rangeフィールドを含むべきです。例えば、長さが選択されたリソースの現在の長さを指定します。ステータスコード206（部分コンテンツ）との回答は、「*」のバイト範囲-RESP-スペックでのContent-Rangeフィールドを含んではいけません。"
    },
    {
      "indent": 3,
      "text": "Examples of byte-content-range-spec values, assuming that the entity contains a total of 1234 bytes:",
      "ja": "エンティティ1234バイトの合計が含まれていることを仮定バイトコンテンツレンジスペック値の例："
    },
    {
      "indent": 6,
      "text": ". The first 500 bytes: bytes 0-499/1234",
      "ja": "。最初の500バイト：0から499/1234バイト"
    },
    {
      "indent": 6,
      "text": ". The second 500 bytes: bytes 500-999/1234",
      "ja": "。第500バイト：500-999 / 1234バイト"
    },
    {
      "indent": 6,
      "text": ". All except for the first 500 bytes: bytes 500-1233/1234",
      "ja": "。バイト500-1233 / 1234：すべての最初の500のバイトを除きます"
    },
    {
      "indent": 6,
      "text": ". The last 500 bytes: bytes 734-1233/1234",
      "ja": "。最後の500バイト：バイト734から1233/1234"
    },
    {
      "indent": 3,
      "text": "When an HTTP message includes the content of a single range (for example, a response to a request for a single range, or to a request for a set of ranges that overlap without any holes), this content is transmitted with a Content-Range header, and a Content-Length header showing the number of bytes actually transferred. For example,",
      "ja": "HTTPメッセージが単一の範囲（単一の範囲について、または任意の孔なし重複範囲の一連の要求への要求に対して、例えば、応答）の内容を含む場合、このコンテンツは、コンテンツレンジで送信されますヘッダ、実際に転送されたバイトの数を示すContent-Lengthヘッダ。例えば、"
    },
    {
      "indent": 7,
      "text": "HTTP/1.1 206 Partial content\nDate: Wed, 15 Nov 1995 06:25:24 GMT\nLast-Modified: Wed, 15 Nov 1995 04:58:08 GMT\nContent-Range: bytes 21010-47021/47022\nContent-Length: 26012\nContent-Type: image/gif",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When an HTTP message includes the content of multiple ranges (for example, a response to a request for multiple non-overlapping ranges), these are transmitted as a multipart message. The multipart media type used for this purpose is \"multipart/byteranges\" as defined in appendix 19.2. See appendix 19.6.3 for a compatibility issue.",
      "ja": "HTTPメッセージが複数の範囲の内容を含む場合（例えば、複数の非重複範囲の要求への応答）が、これらはマルチパートメッセージとして送信されます。この目的のために使用されるマルチメディアタイプは、付録19.2で定義された「マルチパート/ byteranges」です。互換性の問題については、付録19.6.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "A response to a request for a single range MUST NOT be sent using the multipart/byteranges media type. A response to a request for multiple ranges, whose result is a single range, MAY be sent as a multipart/byteranges media type with one part. A client that cannot decode a multipart/byteranges message MUST NOT ask for multiple byte-ranges in a single request.",
      "ja": "単一範囲要求に対する応答は、マルチパート/ byterangesメディアタイプを使用して送信してはいけません。その結果、単一の範囲である複数の範囲に対する要求に対する応答は、一部で、マルチパート/ byterangesメディアタイプとして送信されても​​よいです。マルチパートをデコードすることができないクライアントは/メッセージは、単一の要求で複数のbyterangesをお願いしてはならないbyteranges。"
    },
    {
      "indent": 3,
      "text": "When a client requests multiple byte-ranges in one request, the server SHOULD return them in the order that they appeared in the request.",
      "ja": "クライアントが一つのリクエストで複数のバイトレンジを要求すると、サーバーは、彼らが要求に登場した順序でそれらを返すべきです。"
    },
    {
      "indent": 3,
      "text": "If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist. (Normally, this means return a 200 response containing the full entity).",
      "ja": "それは構文的に無効であるため、サーバーはバイト範囲スペックを無視した場合、サーバーは、無効なR​​angeヘッダフィールドが存在しなかったかのようにリクエストを扱うべきです。 （通常、これは、完全なエンティティを含む200応答を返すことを意味します）。"
    },
    {
      "indent": 3,
      "text": "If the server receives a request (other than one including an If-Range request-header field) with an unsatisfiable Range request-header field (that is, all of whose byte-range-spec values have a first-byte-pos value greater than the current length of the selected resource), it SHOULD return a response code of 416 (Requested range not satisfiable) (section 10.4.17).",
      "ja": "サーバが充足不可能な範囲リクエスト・ヘッダー・フィールドで要求を（もしレンジリクエストヘッダフィールドを含む以外）（受信した場合つまり、そのバイト範囲仕様値の全ては、より大きな最初のバイト-POS値を有します選択されたリソースの現在の長さ）よりも、要求された（416の応答コードを返すべきで充足しない範囲で）（セクション10.4.17）。"
    },
    {
      "indent": 6,
      "text": "Note: clients cannot depend on servers to send a 416 (Requested range not satisfiable) response instead of a 200 (OK) response for an unsatisfiable Range request-header, since not all servers implement this request-header.",
      "ja": "注：いないすべてのサーバがこのリクエスト・ヘッダーを実装するためのクライアントは、416（リクエストを充足しない範囲）の代わりに充足不能レンジリクエストヘッダ200（OK）応答の応答を送信するためにサーバに依存することができません。"
    },
    {
      "indent": 0,
      "text": "14.17 Content-Type",
      "section_title": true,
      "ja": "14.17のContent-Type"
    },
    {
      "indent": 3,
      "text": "The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.",
      "ja": "Content-Typeエンティティヘッダフィールドは、受信者に送信されたエンティティボディのメディアタイプを示し、または、HEADメソッドの場合には、送信されたであろうメディアタイプがGETされリクエストがありました。"
    },
    {
      "indent": 7,
      "text": "Content-Type = \"Content-Type\" \":\" media-type",
      "ja": "Content-Typeの= \"Content-Typeの\" \"：\" メディアタイプ"
    },
    {
      "indent": 3,
      "text": "Media types are defined in section 3.7. An example of the field is",
      "ja": "メディアタイプは、セクション3.7で定義されています。フィールドの例です。"
    },
    {
      "indent": 7,
      "text": "Content-Type: text/html; charset=ISO-8859-4",
      "ja": "コンテンツタイプ：text / htmlの。文字セット= ISO-8859-4"
    },
    {
      "indent": 3,
      "text": "Further discussion of methods for identifying the media type of an entity is provided in section 7.2.1.",
      "ja": "エンティティのメディアタイプを同定するための方法のさらなる議論は、セクション7.2.1に設けられています。"
    },
    {
      "indent": 0,
      "text": "14.18 Date",
      "section_title": true,
      "ja": "14.18日"
    },
    {
      "indent": 3,
      "text": "The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822. The field value is an HTTP-date, as described in section 3.3.1; it MUST be sent in RFC 1123 [8]-date format.",
      "ja": "セクション3.3.1に記載したように日一般ヘッダフィールドは、フィールドの値はHTTP-日付であるRFC 822にORIG-日付と同じセマンティクスを有する、メッセージが発信された日時を表します。これは、RFC 1123 [8] -date形式で送信されなければなりません。"
    },
    {
      "indent": 7,
      "text": "Date = \"Date\" \":\" HTTP-date",
      "ja": "日付= \"日\" \"：\" HTTP-日"
    },
    {
      "indent": 3,
      "text": "An example is",
      "ja": "例があります"
    },
    {
      "indent": 7,
      "text": "Date: Tue, 15 Nov 1994 08:12:31 GMT",
      "ja": "日付：火曜、1994年11月15日午前8時12分31秒GMT"
    },
    {
      "indent": 3,
      "text": "Origin servers MUST include a Date header field in all responses, except in these cases:",
      "ja": "オリジンサーバは、これらの場合を除いて、すべての応答にDateヘッダフィールドを含める必要があります。"
    },
    {
      "indent": 6,
      "text": "1. If the response status code is 100 (Continue) or 101 (Switching Protocols), the response MAY include a Date header field, at the server's option.",
      "ja": "1.応答ステータスコードが100（続行）または101である場合には（プロトコルの切り替え）、応答がサーバのオプションで、Dateヘッダフィールドを含んでいてもよいです。"
    },
    {
      "indent": 6,
      "text": "2. If the response status code conveys a server error, e.g. 500 (Internal Server Error) or 503 (Service Unavailable), and it is inconvenient or impossible to generate a valid Date.",
      "ja": "2.レスポンスステータスコードは、サーバエラーを搬送する場合、例えば500（内部サーバーエラー）または503（サービスを使用できません）、有効な日付を生成するために、不便または不可能です。"
    },
    {
      "indent": 6,
      "text": "3. If the server does not have a clock that can provide a reasonable approximation of the current time, its responses MUST NOT include a Date header field. In this case, the rules in section 14.18.1 MUST be followed.",
      "ja": "3.サーバーは、現在の時間の合理的な近似を提供することができます時計を持っていない場合、その応答はDateヘッダフィールドを含んではいけません。この場合、セクション14.18.1のルールに従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "A received message that does not have a Date header field MUST be assigned one by the recipient if the message will be cached by that recipient or gatewayed via a protocol which requires a Date. An HTTP implementation without a clock MUST NOT cache responses without revalidating them on every use. An HTTP cache, especially a shared cache, SHOULD use a mechanism, such as NTP [28], to synchronize its clock with a reliable external standard.",
      "ja": "メッセージは、その受信者によってキャッシュまたは日を要するプロトコルを介してゲートウェイ処理される場合日ヘッダーフィールドを持っていない受信メッセージは、受信者によっていずれかを割り当てなければなりません。時計のないHTTPの実装は、すべての使用にそれらを再確認せずにレスポンスをキャッシュしてはなりません。 HTTPキャッシュ、特に共有キャッシュは、信頼性の高い外部標準とそのクロックを同期させるためには、そのようなNTP [28]として、メカニズムを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD only send a Date header field in messages that include an entity-body, as in the case of the PUT and POST requests, and even then it is optional. A client without a clock MUST NOT send a Date header field in a request.",
      "ja": "クライアントは、唯一のPUTやPOSTリクエストの場合のように、エンティティボディを含むメッセージにDateヘッダフィールドを送るべきである、とさえ、それはオプションです。時計のないクライアントがリクエストにDateヘッダフィールドを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "The HTTP-date sent in a Date header SHOULD NOT represent a date and time subsequent to the generation of the message. It SHOULD represent the best available approximation of the date and time of message generation, unless the implementation has no means of generating a reasonably accurate date and time. In theory, the date ought to represent the moment just before the entity is generated. In practice, the date can be generated at any time during the message origination without affecting its semantic value.",
      "ja": "日付ヘッダーで送信されるHTTP日付はメッセージの生成に続いて、日付と時刻を表すべきではありません。実装が合理的に正確な日付と時刻を生成する手段がない場合を除きこれは、メッセージの発生日時の利用可能な最善の近似を表現して下さい。理論的には、日付はエンティティが生成される直前の瞬間を表すべきです。実際には、日付はその意味値に影響を与えることなく、メッセージの発信時にいつでも生成することができます。"
    },
    {
      "indent": 0,
      "text": "14.18.1 Clockless Origin Server Operation",
      "section_title": true,
      "ja": "14.18.1クロックレスオリジナル・サーバーの運用"
    },
    {
      "indent": 3,
      "text": "Some origin server implementations might not have a clock available. An origin server without a clock MUST NOT assign Expires or Last-Modified values to a response, unless these values were associated with the resource by a system or user with a reliable clock. It MAY assign an Expires value that is known, at or before server configuration time, to be in the past (this allows \"pre-expiration\" of responses without storing separate Expires values for each resource).",
      "ja": "いくつかのオリジンサーバの実装が可能なクロックを持っていない可能性があります。時計のないオリジンサーバは、これらの値は信頼性の高いクロックを持つシステムまたはユーザーによってリソースに関連付けられた場合を除き、応答に値を期限切れになるかのLast-Modified割り当ててはなりません。それは（これは、別個の記憶せず応答の「前有効期限」を可能にする、各リソースの値を有効期限）は、過去にあると、サーバーの構成時またはそれ以前に、知られている有効期限の値を割り当てることができます。"
    },
    {
      "indent": 0,
      "text": "14.19 ETag",
      "section_title": true,
      "ja": "14.19のETag"
    },
    {
      "indent": 3,
      "text": "The ETag response-header field provides the current value of the entity tag for the requested variant. The headers used with entity tags are described in sections 14.24, 14.26 and 14.44. The entity tag MAY be used for comparison with other entities from the same resource (see section 13.3.3).",
      "ja": "ETagレスポンス・ヘッダー・フィールドは、要求されたバリアントのエンティティタグの現在の値を提供します。エンティティタグと共に使用されるヘッダはセクション14.24、14.26及び14.44に記載されています。エンティティタグは、同じリソース（セクション13.3.3を参照）から他のエンティティとの比較のために使用されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "ETag = \"ETag\" \":\" entity-tag",
      "ja": "ETag = \"ETagを\" \"：\" エンティティタグ"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 6,
      "text": "ETag: \"xyzzy\" ETag: W/\"xyzzy\" ETag: \"\"",
      "ja": "ETag： \"XYZZY\" のETag：W / \"XYZZY\" のETag： \"\""
    },
    {
      "indent": 0,
      "text": "14.20 Expect",
      "section_title": true,
      "ja": "14.20期待"
    },
    {
      "indent": 3,
      "text": "The Expect request-header field is used to indicate that particular server behaviors are required by the client.",
      "ja": "期待リクエストヘッダフィールドは、特定のサーバビヘイビアがクライアントによって要求されていることを示すために使用されます。"
    },
    {
      "indent": 6,
      "text": "Expect = \"Expect\" \":\" 1#expectation",
      "ja": "= \" \"期待\" 期待：\" 1つの＃期待"
    },
    {
      "indent": 6,
      "text": "expectation = \"100-continue\" | expectation-extension expectation-extension = token [ \"=\" ( token | quoted-string ) *expect-params ] expect-params = \";\" token [ \"=\" ( token | quoted-string ) ]",
      "ja": "期待= \"100-続けます\" |期待-延長期待-延長=トークン[ \"=\"（トークン|引用符で囲まれた文字列）*期待-のparams]期待-のparams = \";\"トークン[ \"=\"（トークン|引用符で囲まれた文字列）]"
    },
    {
      "indent": 3,
      "text": "A server that does not understand or is unable to comply with any of the expectation values in the Expect field of a request MUST respond with appropriate error status. The server MUST respond with a 417 (Expectation Failed) status if any of the expectations cannot be met or, if there are other problems with the request, some other 4xx status.",
      "ja": "理解したり、適切なエラー状態で応答しなければならない要求の期待分野での期待値のいずれかを順守することができませんしないサーバー。期待のいずれかの場合、サーバは417（期待に失敗しました）状態で応じなければなりませんリクエスト、いくつかの他の4xxのステータスを持つ他の問題がある場合は、会ったりすることはできません。"
    },
    {
      "indent": 3,
      "text": "This header field is defined with extensible syntax to allow for future extensions. If a server receives a request containing an Expect field that includes an expectation-extension that it does not support, it MUST respond with a 417 (Expectation Failed) status.",
      "ja": "このヘッダーフィールドは、将来の拡張を可能にする拡張可能な構文で定義されています。サーバーがサポートしていないことを期待-拡張子を含む期待フィールドを含む要求を受信した場合、それは417（期待に失敗しました）状態で応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "Comparison of expectation values is case-insensitive for unquoted tokens (including the 100-continue token), and is case-sensitive for quoted-string expectation-extensions.",
      "ja": "期待値の比較は（100-継続トークンを含む）引用符で囲まれていないトークンの大文字と小文字が区別され、そして引用文字列の期待値の拡張のための大文字と小文字が区別されます。"
    },
    {
      "indent": 3,
      "text": "The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST return a 417 (Expectation Failed) status if it receives a request with an expectation that it cannot meet. However, the Expect request-header itself is end-to-end; it MUST be forwarded if the request is forwarded.",
      "ja": "期待機構は、ホップバイホップである：それは満たすことができないことを見込んで要求を受信した場合、すなわち、HTTP / 1.1プロキシが417（期待失敗）ステータスを返さなければなりません。しかし、期待リクエストヘッダ自体は、エンドツーエンドです。要求が転送されている場合、それは転送されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Many older HTTP/1.0 and HTTP/1.1 applications do not understand the Expect header.",
      "ja": "多くの古いHTTP / 1.0とHTTP / 1.1のアプリケーションが期待ヘッダを理解していません。"
    },
    {
      "indent": 3,
      "text": "See section 8.2.3 for the use of the 100 (continue) status.",
      "ja": "100（継続）状態を使用するためのセクション8.2.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "14.21 Expires",
      "section_title": true,
      "ja": "14.21有効期限"
    },
    {
      "indent": 3,
      "text": "The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache (either a proxy cache or a user agent cache) unless it is first validated with the origin server (or with an intermediate cache that has a fresh copy of the entity). See section 13.2 for further discussion of the expiration model.",
      "ja": "エンティティヘッダフィールドは、応答が古くなったとみなされた後の日付/時間を与える有効期限。それが最初のオリジンサーバ（またはエンティティの新しいコピーを持っている中間キャッシュを有する）で検証されていない限り、古いキャッシュエントリは、通常、キャッシュ（プロキシキャッシュまたはユーザー・エージェント・キャッシュのいずれか）によって返さなくてもよいです。期限モデルのさらなる議論についてはセクション13.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time.",
      "ja": "有効期限フィールドの存在は、元のリソースを変更したりする前に、またはその時間の後、に存在しなくなることを意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "The format is an absolute date and time as defined by HTTP-date in section 3.3.1; it MUST be in RFC 1123 date format:",
      "ja": "フォーマットは、セクション3.3.1にHTTP-日付によって定義される絶対日付と時刻です。それは、RFC 1123の日付フォーマットでなければなりません。"
    },
    {
      "indent": 6,
      "text": "Expires = \"Expires\" \":\" HTTP-date",
      "ja": "\"HTTP-日付：=\" \"有効期限\" 有効期限"
    },
    {
      "indent": 3,
      "text": "An example of its use is",
      "ja": "その使用の例があります"
    },
    {
      "indent": 6,
      "text": "Expires: Thu, 01 Dec 1994 16:00:00 GMT",
      "ja": "有効期限：木、1994年12月1日16時00分00秒GMT"
    },
    {
      "indent": 6,
      "text": "Note: if a response includes a Cache-Control field with the max-age directive (see section 14.9.3), that directive overrides the Expires field.",
      "ja": "注：応答が（セクション14.9.3を参照）のmax-ageディレクティブとのCache-Controlフィールドが含まれている場合、そのディレクティブは、フィールドを有効期限よりも優先されます。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 clients and caches MUST treat other invalid date formats, especially including the value \"0\", as in the past (i.e., \"already expired\").",
      "ja": "HTTP / 1.1クライアントとキャッシュは過去の（すなわち、「すでに期限切れ」）のように、特に値が「0」を含め、他の不正な日付形式を扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "To mark a response as \"already expired,\" an origin server sends an Expires date that is equal to the Date header value. (See the rules for expiration calculations in section 13.2.4.)",
      "ja": "応答をマークするには、「すでに期限切れ、」オリジンサーバはDateヘッダの値に等しい日付を有効期限送信します。 （セクション13.2.4における有効期限の計算のための規則を参照してください。）"
    },
    {
      "indent": 3,
      "text": "To mark a response as \"never expires,\" an origin server sends an Expires date approximately one year from the time the response is sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one year in the future.",
      "ja": "応答をマークするには、「無期限に、」オリジンサーバは、応答が送信された時点から約1年の日付を有効期限送信します。 HTTP / 1.1サーバは、将来的には一年以上の日付を有効期限送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "The presence of an Expires header field with a date value of some time in the future on a response that otherwise would by default be non-cacheable indicates that the response is cacheable, unless indicated otherwise by a Cache-Control header field (section 14.9).",
      "ja": "そうでない場合は、デフォルトで非キャッシュ可能であろうことを応答に将来のある時点の日付値とExpiresヘッダーフィールドの存在は、キャッシュ制御ヘッダフィールド（セクション14.9）によって、特に断らない限り応答は、キャッシュ可能であることを示し。"
    },
    {
      "indent": 0,
      "text": "14.22 From",
      "section_title": true,
      "ja": "14.22から"
    },
    {
      "indent": 3,
      "text": "The From request-header field, if given, SHOULD contain an Internet e-mail address for the human user who controls the requesting user agent. The address SHOULD be machine-usable, as defined by \"mailbox\" in RFC 822 [9] as updated by RFC 1123 [8]:",
      "ja": "リクエストヘッダフィールドから、与えられた場合には、要求元のユーザエージェントを制御し、人間のユーザのためのインターネット電子メールアドレスを含むべきです。 RFC 822の「メールボックス」によって定義されるアドレスは、機械使用可能であるべきである[9] RFC 1123によって更新される[8]。"
    },
    {
      "indent": 7,
      "text": "From = \"From\" \":\" mailbox",
      "ja": "「メールボックス：」「から」=から"
    },
    {
      "indent": 3,
      "text": "An example is:",
      "ja": "例は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "From: webmaster@w3.org",
      "ja": "投稿者：webmaster@w3.org"
    },
    {
      "indent": 3,
      "text": "This header field MAY be used for logging purposes and as a means for identifying the source of invalid or unwanted requests. It SHOULD NOT be used as an insecure form of access protection. The interpretation of this field is that the request is being performed on behalf of the person given, who accepts responsibility for the method performed. In particular, robot agents SHOULD include this header so that the person responsible for running the robot can be contacted if problems occur on the receiving end.",
      "ja": "このヘッダーフィールドは、ロギングのために、無効または不要なリクエストの送信元を識別するための手段として使用することができます。これは、アクセス保護の安全でない形として使用しないでください。このフィールドの解釈は、要求が実行される方法のために責任を負う与えられた人に代わって行われていることです。問題は、受信側で発生した場合、ロボットを動作させるための責任者に連絡することができるように、特に、ロボットエージェントは、このヘッダを含むべきです。"
    },
    {
      "indent": 3,
      "text": "The Internet e-mail address in this field MAY be separate from the Internet host which issued the request. For example, when a request is passed through a proxy the original issuer's address SHOULD be used.",
      "ja": "この分野では、インターネットの電子メールアドレスは、要求を発行したインターネットホストから分離することができます。要求がプロキシを通過するときたとえば、元の発行者のアドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD NOT send the From header field without the user's approval, as it might conflict with the user's privacy interests or their site's security policy. It is strongly recommended that the user be able to disable, enable, and modify the value of this field at any time prior to a request.",
      "ja": "それは、ユーザーのプライバシーの利益や自分のサイトのセキュリティポリシーと競合する可能性がありますように、クライアントは、ユーザーの承認なしFromヘッダーフィールド送るべきではありません。強く、ユーザーが要求する前に、任意の時点で、無効化、有効化、およびこのフィールドの値を変更することができることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "14.23 Host",
      "section_title": true,
      "ja": "14.23ホスト"
    },
    {
      "indent": 3,
      "text": "The Host request-header field specifies the Internet host and port number of the resource being requested, as obtained from the original URI given by the user or referring resource (generally an HTTP URL, as described in section 3.2.2). The Host field value MUST represent the naming authority of the origin server or gateway given by the original URL. This allows the origin server or gateway to differentiate between internally-ambiguous URLs, such as the root \"/\" URL of a server for multiple host names on a single IP address.",
      "ja": "元のURIから得られるホストリクエストヘッダフィールドは、ユーザによって与えられるまたは（セクション3.2.2で説明したように、一般にHTTPのURL）リソースを参照し、要求されたリソースのインターネットホストとポート番号を指定します。 Hostフィールド値は、元のURLで指定したオリジンサーバやゲートウェイの命名機関を表現しなければなりません。これは、オリジンサーバやゲートウェイは、単一のIPアドレスに複数のホスト名のために、ルートなどの内部であいまいなURLを、サーバーの「/」URLを区別することができます。"
    },
    {
      "indent": 7,
      "text": "Host = \"Host\" \":\" host [ \":\" port ] ; Section 3.2.2",
      "ja": "ホスト= \"ホスト\" \"：\" ホスト[ \"：\" ポート]; 3.2.2項"
    },
    {
      "indent": 3,
      "text": "A \"host\" without any trailing port information implies the default port for the service requested (e.g., \"80\" for an HTTP URL). For example, a request on the origin server for <http://www.w3.org/pub/WWW/> would properly include:",
      "ja": "後続のポート情報なしに「ホスト」とは、（HTTPのURLのために、例えば、「80」）、要求されたサービスのためのデフォルトのポートを意味しています。たとえば、<http://www.w3.org/pub/WWW/>のためのオリジンサーバ上の要求が適切に含まれます："
    },
    {
      "indent": 7,
      "text": "GET /pub/WWW/ HTTP/1.1\nHost: www.w3.org",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A client MUST include a Host header field in all HTTP/1.1 request messages . If the requested URI does not include an Internet host name for the service being requested, then the Host header field MUST be given with an empty value. An HTTP/1.1 proxy MUST ensure that any request message it forwards does contain an appropriate Host header field that identifies the service being requested by the proxy. All Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message which lacks a Host header field.",
      "ja": "クライアントは、すべてのHTTP / 1.1リクエストメッセージにHostヘッダフィールドを含まなければなりません。要求されたURIが要求されたサービスのためのインターネットホスト名が含まれていない場合、Hostヘッダフィールドが空の値を指定する必要があります。 HTTP / 1.1プロキシは、それが転送し、任意の要求メッセージがプロキシによって要求されたサービスを識別する適切なホストヘッダーフィールドが含まれていることを確実にしなければなりません。すべてのインターネットベースのHTTP / 1.1サーバは、Hostヘッダフィールドを持たない任意のHTTP / 1.1リクエストメッセージに400（不正な要求）ステータスコードで応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "See sections 5.2 and 19.6.1.1 for other requirements relating to Host.",
      "ja": "ホストに関連する他の要件については、セクション5.2および19.6.1.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "14.24 If-Match",
      "section_title": true,
      "ja": "14.24もしマッチ"
    },
    {
      "indent": 3,
      "text": "The If-Match request-header field is used with a method to make it conditional. A client that has one or more entities previously obtained from the resource can verify that one of those entities is current by including a list of their associated entity tags in the If-Match header field. Entity tags are defined in section 3.11. The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. It is also used, on updating requests, to prevent inadvertent modification of the wrong version of a resource. As a special case, the value \"*\" matches any current entity of the resource.",
      "ja": "もしマッチリクエストヘッダフィールドは、条件付きにする方法に使用されます。以前資源から得られた1つまたは複数のエンティティを持っているクライアントは、これらのエンティティの一つがIf-Matchヘッダフィールドでそれに関連するエンティティタグのリストを含むことにより、現在であることを確認することができます。エンティティタグは、セクション3.11で定義されています。この機能の目的は最小のトランザクションオーバーヘッドでキャッシュされた情報の効率的な更新を可能にすることです。また、リソースの間違ったバージョンの不注意な変更を防ぐために、更新要求に、使用されています。特別な場合として、値「*」はリソースのいずれかの現在のエンティティと一致します。"
    },
    {
      "indent": 7,
      "text": "If-Match = \"If-Match\" \":\" ( \"*\" | 1#entity-tag )",
      "ja": "もしマッチ=「もしマッチ」「：」（「*」| 1＃エンティティタグ）"
    },
    {
      "indent": 3,
      "text": "If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-Match header) on that resource, or if \"*\" is given and any current entity exists for that resource, then the server MAY perform the requested method as if the If-Match header field did not exist.",
      "ja": "エンティティタグのいずれかがそのリソース上の（もしマッチヘッダなし）同様のGET要求に応答して返されたであろうエンティティのエンティティタグと一致する場合、「*」は、所与の任意の現在のエンティティが存在する場合、またはIf-Matchヘッダフィールドが存在しなかったかのようにそのリソースのために、サーバは要求されたメソッドを実行することができます。"
    },
    {
      "indent": 3,
      "text": "A server MUST use the strong comparison function (see section 13.3.3) to compare the entity tags in If-Match.",
      "ja": "サーバは、もしマッチにエンティティタグを比較すること（セクション13.3.3を参照してください）強い比較機能を使わなければなりません。"
    },
    {
      "indent": 3,
      "text": "If none of the entity tags match, or if \"*\" is given and no current entity exists, the server MUST NOT perform the requested method, and MUST return a 412 (Precondition Failed) response. This behavior is most useful when the client wants to prevent an updating method, such as PUT, from modifying a resource that has changed since the client last retrieved it.",
      "ja": "「*」与えられた場合、またはエンティティのいずれも試合をタグおよびno現在のエンティティが存在しない場合、サーバは要求されたメソッドを実行してはならない、と412（前提条件が失敗した）応答を返さなければなりません。クライアントは、クライアントが最後にそれを取得した後に変更されたリソースを変更するのは、そのようなPUTなど、更新方法を阻止しようとすると、この現象が最も有用です。"
    },
    {
      "indent": 3,
      "text": "If the request would, without the If-Match header field, result in anything other than a 2xx or 412 status, then the If-Match header MUST be ignored.",
      "ja": "要求は、If-Matchヘッダフィールドなしで、2XXまたは412ステータス以外をもたらす場合、もしマッチヘッダは無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The meaning of \"If-Match: *\" is that the method SHOULD be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section 14.44) exists, and MUST NOT be performed if the representation does not exist.",
      "ja": "意味は、「場合マッチ：*」メソッドがオリジンサーバによって選択された表現が存在する（またはキャッシュによって、おそらくセクション14.44を参照してください、ヴァリメカニズムを使用して）場合に実行されるべきであり、場合に実行されてはならないことです表現は存在しません。"
    },
    {
      "indent": 3,
      "text": "A request intended to update a resource (e.g., a PUT) MAY include an If-Match header field to signal that the request method MUST NOT be applied if the entity corresponding to the If-Match value (a single entity tag) is no longer a representation of that resource. This allows the user to indicate that they do not wish the request to be successful if the resource has been changed without their knowledge. Examples:",
      "ja": "もし一致値（単一のエンティティタグ）に対応するエンティティがもはやない場合、要求メソッドを適用してはならないことを知らせるためにIf-Matchヘッダフィールドを含むかもしれリソース（例えば、PUT）を更新することを意図要求そのリソースの表現。これにより、ユーザーは、リソースが彼らの知識がなくても変更されている場合、彼らが成功するために要求を希望していないことを示すことができます。例："
    },
    {
      "indent": 7,
      "text": "If-Match: \"xyzzy\"\nIf-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-Match: *",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The result of a request having both an If-Match header field and either an If-None-Match or an If-Modified-Since header fields is undefined by this specification.",
      "ja": "If-Matchヘッダフィールドの両方を有する要求の結果のいずれかは、IF-なしマッチ場合、または修飾-ためのヘッダフィールドはこの仕様書で定義されていません。"
    },
    {
      "indent": 0,
      "text": "14.25 If-Modified-Since",
      "section_title": true,
      "ja": "14.25変更 - 開始"
    },
    {
      "indent": 3,
      "text": "The If-Modified-Since request-header field is used with a method to make it conditional: if the requested variant has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message-body.",
      "ja": "もし修飾-のでリクエストヘッダフィールドを条件付きそれを作るための方法で使用される：要求された変異体は、このフィールドで指定された時間以降に変更されていない場合、エンティティはサーバから返されないであろう。代わりに、304（変更されない）応答は、任意のメッセージボディなしに返されます。"
    },
    {
      "indent": 7,
      "text": "If-Modified-Since = \"If-Modified-Since\" \":\" HTTP-date",
      "ja": "変更 - 開始= \"場合 - 変更 - ので\" \"：\" HTTP-日"
    },
    {
      "indent": 3,
      "text": "An example of the field is:",
      "ja": "フィールドの例は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT",
      "ja": "変更 - 開始：土、1994年10月29日午後7時43分31秒GMT"
    },
    {
      "indent": 3,
      "text": "A GET method with an If-Modified-Since header and no Range header requests that the identified entity be transferred only if it has been modified since the date given by the If-Modified-Since header. The algorithm for determining this includes the following cases:",
      "ja": "ヘッダ場合-ので修飾とを有するGETメソッドがあれば修飾-ので、ヘッダにより指定された日付以降に変更された場合に識別されたエンティティにのみ転送されないRangeヘッダを要求します。これを決定するためのアルゴリズムは、以下の例が含まれています。"
    },
    {
      "indent": 6,
      "text": "a) If the request would normally result in anything other than a 200 (OK) status, or if the passed If-Modified-Since date is invalid, the response is exactly the same as for a normal GET. A date which is later than the server's current time is invalid.",
      "ja": "a）の要求は、通常は200（OK）ステータス以外の何かにつながる、または変更された場合は、-ので日付渡されたが無効である場合、レスポンスは通常のGETとまったく同じである。場合後でサーバーの現在時刻よりも日付が無効です。"
    },
    {
      "indent": 6,
      "text": "b) If the variant has been modified since the If-Modified-Since date, the response is exactly the same as for a normal GET.",
      "ja": "変異体は、以降に変更された場合b）の場合は修飾-ので日付、応答が正確に通常GETの場合と同じです。"
    },
    {
      "indent": 6,
      "text": "c) If the variant has not been modified since a valid If-Modified-Since date, the server SHOULD return a 304 (Not Modified) response.",
      "ja": "バリアントが変更された場合は、-ので、有効開始日以降に変更されていない場合c）に、サーバは304（未修正）応答を返すべきです。"
    },
    {
      "indent": 3,
      "text": "The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead.",
      "ja": "この機能の目的は最小のトランザクションオーバーヘッドでキャッシュされた情報の効率的な更新を可能にすることです。"
    },
    {
      "indent": 6,
      "text": "Note: The Range request-header field modifies the meaning of If-Modified-Since; see section 14.35 for full details.",
      "ja": "注：範囲リクエストヘッダフィールドが変更した場合-以来の意味を変更します。完全な詳細についてはセクション14.35を参照してください。"
    },
    {
      "indent": 6,
      "text": "Note: If-Modified-Since times are interpreted by the server, whose clock might not be synchronized with the client.",
      "ja": "注意：変更した場合は-ので時間がそのクロッククライアントと同期されない可能性があり、サーバーによって解釈されています。"
    },
    {
      "indent": 6,
      "text": "Note: When handling an If-Modified-Since header field, some servers will use an exact date comparison function, rather than a less-than function, for deciding whether to send a 304 (Not Modified) response. To get best results when sending an If-Modified-Since header field for cache validation, clients are advised to use the exact date string received in a previous Last-Modified header field whenever possible.",
      "ja": "注：もし-Modified-Sinceヘッダー・フィールドを扱うときは、いくつかのサーバは304（未修正）応答を送信するかどうかを決定するために、というより少なくより機能よりも、正確な日付の比較関数を使用します。キャッシュ検証のためであれば-Modified-Sinceヘッダー・フィールドを送信する際に最良の結果を得るために、クライアントは以前のLast-Modifiedヘッダフィールド可能な限りで受信し、正確な日付文字列を使用することをお勧めします。"
    },
    {
      "indent": 6,
      "text": "Note: If a client uses an arbitrary date in the If-Modified-Since header instead of a date taken from the Last-Modified header for the same request, the client should be aware of the fact that this date is interpreted in the server's understanding of time. The client should consider unsynchronized clocks and rounding problems due to the different encodings of time between the client and server. This includes the possibility of race conditions if the document has changed between the time it was first requested and the If-Modified-Since date of a subsequent request, and the possibility of clock-skew-related problems if the If-Modified-Since date is derived from the client's clock without correction to the server's clock. Corrections for different time bases between client and server are at best approximate due to network latency.",
      "ja": "注意：クライアントは、If-Modifiedの-Sinceヘッダの代わりに同じ要求のためのLast-Modifiedヘッダから撮影日の内の任意の日付を使用している場合、クライアントはこの日付がサーバの理解で解釈されているという事実を認識しておく必要があり時間の。クライアントは非同期のクロックと、クライアントとサーバの間の時間の異なるエンコーディングによる丸めの問題を考慮する必要があります。文書は、それが最初に要求された時間との間で変更された場合、これは競合状態の可能性を含む後続の要求の日付場合-ため修飾、およびクロック・スキューに関連する問題の可能性があれば修飾-ので、場合日付サーバのクロックに補正することなく、クライアントのクロックから導出されます。クライアントとサーバの間の異なる時間基準の補正はネットワークの遅延によるせいぜい近似しています。"
    },
    {
      "indent": 3,
      "text": "The result of a request having both an If-Modified-Since header field and either an If-Match or an If-Unmodified-Since header fields is undefined by this specification.",
      "ja": "リクエストの結果は、ヘッダフィールド場合-ため修飾した両方の場合マッチ場合、または非改変-のでヘッダーフィールドのいずれかは、本明細書によって定義されていません。"
    },
    {
      "indent": 0,
      "text": "14.26 If-None-Match",
      "section_title": true,
      "ja": "14.26もし-なしマッチ"
    },
    {
      "indent": 3,
      "text": "The If-None-Match request-header field is used with a method to make it conditional. A client that has one or more entities previously obtained from the resource can verify that none of those entities is current by including a list of their associated entity tags in the If-None-Match header field. The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. It is also used to prevent a method (e.g. PUT) from inadvertently modifying an existing resource when the client believes that the resource does not exist.",
      "ja": "もし-なしマッチリクエストヘッダフィールドは、条件付きにする方法に使用されます。以前資源から得られた1つまたは複数のエンティティを持っているクライアントは、これらのエンティティのいずれもIf-None-Matchヘッダフィールド内のそれに関連するエンティティタグのリストを含むことにより、現在ではないことを確認することができます。この機能の目的は最小のトランザクションオーバーヘッドでキャッシュされた情報の効率的な更新を可能にすることです。また、クライアントは、リソースが存在しないと考えているときに誤って既存のリソースを変更することから（例えばPUT）メソッドを防止するために使用されます。"
    },
    {
      "indent": 3,
      "text": "As a special case, the value \"*\" matches any current entity of the resource.",
      "ja": "特別な場合として、値「*」はリソースのいずれかの現在のエンティティと一致します。"
    },
    {
      "indent": 7,
      "text": "If-None-Match = \"If-None-Match\" \":\" ( \"*\" | 1#entity-tag )",
      "ja": "もし-なしマッチ= \"もし-なし - マッチ\" \"：\"（ \"*\" | 1＃エンティティタグ）"
    },
    {
      "indent": 3,
      "text": "If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-None-Match header) on that resource, or if \"*\" is given and any current entity exists for that resource, then the server MUST NOT perform the requested method, unless required to do so because the resource's modification date fails to match that supplied in an If-Modified-Since header field in the request. Instead, if the request method was GET or HEAD, the server SHOULD respond with a 304 (Not Modified) response, including the cache-related header fields (particularly ETag) of one of the entities that matched. For all other request methods, the server MUST respond with a status of 412 (Precondition Failed).",
      "ja": "エンティティタグのいずれかが「*」が与えられた場合、そのリソース上（If-None-Matchヘッダなし）と同様のGET要求に応答して返送、またはされていたであろうエンティティと任意の現在のエンティティタグが一致した場合リソースの変更日はリクエストであれば-Modified-Sinceヘッダー・フィールドで供給されるものと一致しなかったので、そうするために必要な場合を除き、エンティティは、そのリソースのために存在し、その後、サーバは要求されたメソッドを実行してはなりません。リクエストメソッドがGETまたはHEADであった場合、代わりに、サーバは、一致したエンティティのいずれのキャッシュに関連するヘッダフィールド（特にETagの）を含む、304（変更されていません）応答で応答すべきです。他のすべてのリクエストメソッドの場合、サーバは412の状態で応じなければなりません（前提条件に失敗しました）。"
    },
    {
      "indent": 3,
      "text": "See section 13.3.3 for rules on how to determine if two entities tags match. The weak comparison function can only be used with GET or HEAD requests.",
      "ja": "2つのエンティティが試合をタグかどうかを確認する方法に関する規則のためのセクション13.3.3を参照してください。弱い比較機能は、GETやHEADリクエストで使用することができます。"
    },
    {
      "indent": 3,
      "text": "If none of the entity tags match, then the server MAY perform the requested method as if the If-None-Match header field did not exist, but MUST also ignore any If-Modified-Since header field(s) in the request. That is, if no entity tags match, then the server MUST NOT return a 304 (Not Modified) response.",
      "ja": "エンティティタグの一致のいずれも、If-None-Matchヘッダフィールドが存在しなかったかのように、サーバは、要求されたメソッドを実行しなくてもよいが、また変更した場合-ので要求内のヘッダフィールド（複数可）は、任意の無視しなければならない場合。それは何のエンティティタグが一致しない場合、サーバは304（未修正）応答を返してはならない、です。"
    },
    {
      "indent": 3,
      "text": "If the request would, without the If-None-Match header field, result in anything other than a 2xx or 304 status, then the If-None-Match header MUST be ignored. (See section 13.3.4 for a discussion of server behavior when both If-Modified-Since and If-None-Match appear in the same request.)",
      "ja": "リクエストは、If-None-Matchヘッダフィールドなし、の2xxまたは304ステータス以外の何かにつながる場合は、If-None-Matchヘッダは無視しなければなりません。 （変更した場合は-ので両方となし、マッチした場合、同じ要求に表示され、サーバの動作についての説明は、セクション13.3.4を参照してください。）"
    },
    {
      "indent": 3,
      "text": "The meaning of \"If-None-Match: *\" is that the method MUST NOT be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section 14.44) exists, and SHOULD be performed if the representation does not exist. This feature is intended to be useful in preventing races between PUT operations.",
      "ja": "表現はオリジンサーバによって選択された場合、このメソッドは（またはキャッシュでのセクション14.44を参照してください、おそらくヴァリメカニズムを使用して、）を行ってはならないことで存在し、実行する必要があります。「*場合 - なし - マッチ」の意味表現が存在しない場合。この機能は、PUT操作間レースを予防するのに有用であることを意図しています。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 7,
      "text": "If-None-Match: \"xyzzy\"\nIf-None-Match: W/\"xyzzy\"\nIf-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-None-Match: W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\"\nIf-None-Match: *",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The result of a request having both an If-None-Match header field and either an If-Match or an If-Unmodified-Since header fields is undefined by this specification.",
      "ja": "If-None-Matchヘッダフィールドの両方ともしマッチ場合、または非改変-のでヘッダフィールドこの仕様によって定義されていないのいずれかを有する要求の結果。"
    },
    {
      "indent": 0,
      "text": "14.27 If-Range",
      "section_title": true,
      "ja": "14.27もしレンジ"
    },
    {
      "indent": 3,
      "text": "If a client has a partial copy of an entity in its cache, and wishes to have an up-to-date copy of the entire entity in its cache, it could use the Range request-header with a conditional GET (using either or both of If-Unmodified-Since and If-Match.) However, if the condition fails because the entity has been modified, the client would then have to make a second request to obtain the entire current entity-body.",
      "ja": "クライアントがそのキャッシュにエンティティの部分的なコピーを持っており、そのキャッシュにエンティティ全体の最新のコピーを持っているしたい場合は、いずれかまたは両方を使用して（条件付きGETでレンジリクエストヘッダを使用することができますエンティティが変更されているので、条件が失敗した場合の場合、未修飾-以来とIF-マッチ。）ただし、クライアントは、全体の現在のエンティティボディを取得するために第2の要求を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "The If-Range header allows a client to \"short-circuit\" the second request. Informally, its meaning is `if the entity is unchanged, send me the part(s) that I am missing; otherwise, send me the entire new entity'.",
      "ja": "もし-Rangeヘッダは「短絡」第2の要求にクライアントを可能にします。非公式に、その意味は、エンティティが変更されなかった場合は、私が行方不明だ部分（複数可）を送る `です。そうでない場合は、私の全体の新しいエンティティ」を送信します。"
    },
    {
      "indent": 8,
      "text": "If-Range = \"If-Range\" \":\" ( entity-tag | HTTP-date )",
      "ja": "もしレンジ= \"IF-範囲\" \"：\"（エンティティタグ| HTTP-日）"
    },
    {
      "indent": 3,
      "text": "If the client has no entity tag for an entity, but does have a Last-Modified date, it MAY use that date in an If-Range header. (The server can distinguish between a valid HTTP-date and any form of entity-tag by examining no more than two characters.) The If-Range header SHOULD only be used together with a Range header, and MUST be ignored if the request does not include a Range header, or if the server does not support the sub-range operation.",
      "ja": "クライアントは、エンティティのエンティティタグがありませんが、最終更新日時を持っている場合、それは、If-Rangeヘッダにその日付を使用するかもしれません。 （サーバは、有効なHTTP日付と2つ以下の文字を調べることによって、エンティティタグの任意の形式を区別することができる。）の場合、RangeヘッダのみRangeヘッダと一緒に使用する必要があり、要求がない場合は無視しなければなりませんサーバは、サブ範囲の動作をサポートしていない場合、Rangeヘッダを含むか、またはしません。"
    },
    {
      "indent": 3,
      "text": "If the entity tag given in the If-Range header matches the current entity tag for the entity, then the server SHOULD provide the specified sub-range of the entity using a 206 (Partial content) response. If the entity tag does not match, then the server SHOULD return the entire entity using a 200 (OK) response.",
      "ja": "もし-Rangeヘッダで与えられたエンティティタグは、エンティティの現在のエンティティタグと一致する場合、サーバは206（部分コンテンツ）応答を使用して、エンティティの指定されたサブ範囲を提供すべきです。エンティティタグが一致しない場合、サーバは200（OK）応答を使用してエンティティ全体を返すべきです。"
    },
    {
      "indent": 0,
      "text": "14.28 If-Unmodified-Since",
      "section_title": true,
      "ja": "14.28の場合、変更されていない、ので、"
    },
    {
      "indent": 3,
      "text": "The If-Unmodified-Since request-header field is used with a method to make it conditional. If the requested resource has not been modified since the time specified in this field, the server SHOULD perform the requested operation as if the If-Unmodified-Since header were not present.",
      "ja": "もし非改変-のでリクエストヘッダフィールドは、条件付きにする方法に使用されます。要求されたリソースがこのフィールドに指定された時間以降に変更されていない場合、サーバがあるかのように要求された操作を実行する必要がある場合、未修飾-ので、ヘッダが存在しません。"
    },
    {
      "indent": 3,
      "text": "If the requested variant has been modified since the specified time, the server MUST NOT perform the requested operation, and MUST return a 412 (Precondition Failed).",
      "ja": "要求されたバリアントが指定した時刻以降に変更された場合、サーバは要求された操作を実行してはならない、と412（前提条件が失敗した）を返さなければなりません。"
    },
    {
      "indent": 6,
      "text": "If-Unmodified-Since = \"If-Unmodified-Since\" \":\" HTTP-date",
      "ja": "もし非改変-以来= \" \"の場合、未修飾-以来\"：\" HTTP-日"
    },
    {
      "indent": 3,
      "text": "An example of the field is:",
      "ja": "フィールドの例は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT",
      "ja": "もし非改変-以降：土、1994年10月29日午前19時43分31秒GMT"
    },
    {
      "indent": 3,
      "text": "If the request normally (i.e., without the If-Unmodified-Since header) would result in anything other than a 2xx or 412 status, the If-Unmodified-Since header SHOULD be ignored.",
      "ja": "要求が正常に（即ち、もし非改変-のでヘッダなし）の2xxまたは412ステータス以外をもたらす場合、もし非改変-ので、ヘッダは無視されるべきです。"
    },
    {
      "indent": 3,
      "text": "If the specified date is invalid, the header is ignored.",
      "ja": "指定された日付が無効である場合、ヘッダは無視されます。"
    },
    {
      "indent": 3,
      "text": "The result of a request having both an If-Unmodified-Since header field and either an If-None-Match or an If-Modified-Since header fields is undefined by this specification.",
      "ja": "リクエストの結果は、もし非改変-ので、両方のヘッダフィールドを有するとIF-なしマッチ場合、または修飾-ためのヘッダーフィールドのいずれかは、本明細書によって定義されていません。"
    },
    {
      "indent": 0,
      "text": "14.29 Last-Modified",
      "section_title": true,
      "ja": "14.29のLast-Modified"
    },
    {
      "indent": 3,
      "text": "The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.",
      "ja": "Last-Modifiedエンティティヘッダフィールドは、オリジンサーバがバリアントが最後に変更されたと考えていた日付と時刻を示しています。"
    },
    {
      "indent": 7,
      "text": "Last-Modified = \"Last-Modified\" \":\" HTTP-date",
      "ja": "= \"Last-Modifiedの\" \"のLast-Modified：\" HTTP-日"
    },
    {
      "indent": 3,
      "text": "An example of its use is",
      "ja": "その使用の例があります"
    },
    {
      "indent": 7,
      "text": "Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT",
      "ja": "最終更新：火、1994年12時45分26秒GMT 11月15日"
    },
    {
      "indent": 3,
      "text": "The exact meaning of this header field depends on the implementation of the origin server and the nature of the original resource. For files, it may be just the file system last-modified time. For entities with dynamically included parts, it may be the most recent of the set of last-modify times for its component parts. For database gateways, it may be the last-update time stamp of the record. For virtual objects, it may be the last time the internal state changed.",
      "ja": "このヘッダフィールドの正確な意味はオリジンサーバの実装と、元のリソースの性質に依存します。ファイルの場合、それは最終更新時刻だけで、ファイルシステムであってもよいです。動的に含まれる部品を持つエンティティの場合は、その構成部品のための最後の変更時間のセットの最新のかもしれません。データベース・ゲートウェイの場合は、レコードの最後の更新のタイムスタンプかもしれません。仮想オブジェクトの場合、それは、内部状態が変更された最後の時間がかかるかもしれません。"
    },
    {
      "indent": 3,
      "text": "An origin server MUST NOT send a Last-Modified date which is later than the server's time of message origination. In such cases, where the resource's last modification would indicate some time in the future, the server MUST replace that date with the message origination date.",
      "ja": "オリジンサーバは、メッセージ発信のサーバの時刻より後の最終更新日時を送ってはいけません。リソースの最後の変更が将来のある時点を示すことになるような場合では、サーバーは、メッセージの発信日付で、その日付を交換しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An origin server SHOULD obtain the Last-Modified value of the entity as close as possible to the time that it generates the Date value of its response. This allows a recipient to make an accurate assessment of the entity's modification time, especially if the entity changes near the time that the response is generated.",
      "ja": "オリジンサーバは、その応答の日付値を生成し、時間にできるだけ近いエンティティのLast-Modifiedの値を取得する必要があります。これは、企業が、応答が生成された時間の近くに変わる場合は特に、受信者がエンティティの更新時刻の正確な評価を行うことができます。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.",
      "ja": "HTTP / 1.1サーバは、Last-Modifiedの実現可能な時はいつでも送るべきです。"
    },
    {
      "indent": 0,
      "text": "14.30 Location",
      "section_title": true,
      "ja": "14.30場所"
    },
    {
      "indent": 3,
      "text": "The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. For 201 (Created) responses, the Location is that of the new resource which was created by the request. For 3xx responses, the location SHOULD indicate the server's preferred URI for automatic redirection to the resource. The field value consists of a single absolute URI.",
      "ja": "ロケーションレスポンスヘッダフィールドは、新しいリソースの要求または識別を完了するためのRequest-URI以外の場所に受信者をリダイレクトするために使用されます。 201（作成された）応答のために、場所は要求によって作成された新しいリソースのものです。 3XX応答の場合、場所は、リソースへの自動リダイレクトするために、サーバーの優先URIを示すべきです。フィールドの値は、単一の絶対URIから成ります。"
    },
    {
      "indent": 7,
      "text": "Location = \"Location\" \":\" absoluteURI",
      "ja": "場所= \"場所\" \"：\" absoluteURIで"
    },
    {
      "indent": 3,
      "text": "An example is:",
      "ja": "例は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "Location: http://www.w3.org/pub/WWW/People.html",
      "ja": "場所：http://www.w3.org/pub/WWW/People.html"
    },
    {
      "indent": 6,
      "text": "Note: The Content-Location header field (section 14.14) differs from Location in that the Content-Location identifies the original location of the entity enclosed in the request. It is therefore possible for a response to contain header fields for both Location and Content-Location. Also see section 13.10 for cache requirements of some methods.",
      "ja": "注：コンテンツロケーション要求で囲まれたエンティティの元の位置を識別するのContent-Locationヘッダフィールド（セクション14.14）は、ロケーションとは異なります。応答は、ロケーションおよびコンテンツの場所の両方のためのヘッダーフィールドを含むことがことが可能です。また、いくつかのメソッドのキャッシュ要件についてはセクション13.10を参照してください。"
    },
    {
      "indent": 0,
      "text": "14.31 Max-Forwards",
      "section_title": true,
      "ja": "14.31マックス・フォワード"
    },
    {
      "indent": 3,
      "text": "The Max-Forwards request-header field provides a mechanism with the TRACE (section 9.8) and OPTIONS (section 9.2) methods to limit the number of proxies or gateways that can forward the request to the next inbound server. This can be useful when the client is attempting to trace a request chain which appears to be failing or looping in mid-chain.",
      "ja": "マックスを転送リクエストヘッダフィールドは、次のインバウンドサーバに要求を転送することができるプロキシまたはゲートウェイの数を制限するTRACE（セクション9.8）とオプション（セクション9.2）の方法とメカニズムを提供します。クライアントは、中鎖に失敗またはループしているように見えるリクエストチェーンをトレースしようとしている場合に便利です。"
    },
    {
      "indent": 7,
      "text": "Max-Forwards = \"Max-Forwards\" \":\" 1*DIGIT",
      "ja": "マックス・フォワード=「マックス・フォワード」「：」1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "The Max-Forwards value is a decimal integer indicating the remaining number of times this request message may be forwarded.",
      "ja": "最大転送した値は、この要求メッセージが転送される残り回数を示す10進整数です。"
    },
    {
      "indent": 3,
      "text": "Each proxy or gateway recipient of a TRACE or OPTIONS request containing a Max-Forwards header field MUST check and update its value prior to forwarding the request. If the received value is zero (0), the recipient MUST NOT forward the request; instead, it MUST respond as the final recipient. If the received Max-Forwards value is greater than zero, then the forwarded message MUST contain an updated Max-Forwards field with a value decremented by one (1).",
      "ja": "Max-Forwardsヘッダーフィールドを含むTRACEまたはOPTIONS要求の各プロキシまたはゲートウェイ受信者は、要求を転送する前にその値を確認して更新しなければなりません。受信された値がゼロ（0）である場合、受信者は、要求を転送してはいけません。その代わり、それは最終的に受信者として応答しなければなりません。受信された最大転送した値がゼロよりも大きい場合、転送されたメッセージは、一（1）だけ減分値で更新最大転送しフィールドを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Max-Forwards header field MAY be ignored for all other methods defined by this specification and for any extension methods for which it is not explicitly referred to as part of that method definition.",
      "ja": "最大Forwardsヘッダフィールドはこの仕様で定義されたすべての他の方法のために、それが明示的メソッド定義の一部と呼ばされていない任意の拡張メソッドのために無視することができます。"
    },
    {
      "indent": 0,
      "text": "14.32 Pragma",
      "section_title": true,
      "ja": "14.x2プラグマ"
    },
    {
      "indent": 3,
      "text": "The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives.",
      "ja": "プラグマ一般ヘッダフィールドは、要求/応答チェーンに沿った任意の受信者に適用される可能性のある実装固有のディレクティブを含めるために使用されます。すべてのプラグマ指令はプロトコルの観点から任意の動作を指定します。しかし、いくつかのシステムは、その行動がディレクティブと一致している必要になる場合があります。"
    },
    {
      "indent": 7,
      "text": "Pragma            = \"Pragma\" \":\" 1#pragma-directive\npragma-directive  = \"no-cache\" | extension-pragma\nextension-pragma  = token [ \"=\" ( token | quoted-string ) ]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When the no-cache directive is present in a request message, an application SHOULD forward the request toward the origin server even if it has a cached copy of what is being requested. This pragma directive has the same semantics as the no-cache cache-directive (see section 14.9) and is defined here for backward compatibility with HTTP/1.0. Clients SHOULD include both header fields when a no-cache request is sent to a server not known to be HTTP/1.1 compliant.",
      "ja": "キャッシュなしのディレクティブが要求メッセージ中に存在する場合、それは要求されているもののキャッシュされたコピーを持っている場合でも、アプリケーションがオリジンサーバに向けて要求を転送する必要があります。このプラグマディレクティブは、キャッシュなしのキャッシュ・ディレクティブ（セクション14.9を参照）と同じ意味を持っており、HTTP / 1.0との後方互換性のためにここで定義されています。キャッシュなしの要求が準拠したHTTP / 1.1であることが知られていないサーバーに送信されたときにクライアントが両方のヘッダフィールドを含むべきです。"
    },
    {
      "indent": 3,
      "text": "Pragma directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to specify a pragma for a specific recipient; however, any pragma directive not relevant to a recipient SHOULD be ignored by that recipient.",
      "ja": "ディレクティブは、要求/応答チェーンに沿ってすべての受信者に適用可能であるかもしれないので、プラグマ指令は関係なく、そのアプリケーションに対するそれらの重要性の、プロキシまたはゲートウェイアプリケーションが通過しなければなりません。特定の受信者のためのプラグマを指定することはできません。ただし、受信者に関係のない任意のプラグマディレクティブは、その受信者によって無視されるべきです。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 caches SHOULD treat \"Pragma: no-cache\" as if the client had sent \"Cache-Control: no-cache\". No new Pragma directives will be defined in HTTP.",
      "ja": "HTTP / 1.1扱うべきキャッシュ \"プラグマ：キャッシュなし\" クライアントが \"：キャッシュなしのCache-Control\" 送られたかのように。新しいプラグマディレクティブは、HTTPで定義されません。"
    },
    {
      "indent": 6,
      "text": "Note: because the meaning of \"Pragma: no-cache as a response header field is not actually specified, it does not provide a reliable replacement for \"Cache-Control: no-cache\" in a response",
      "ja": "注意：応答でキャッシュなし 『：のCache-Control：「キャッシュなしレスポンスヘッダフィールドは、実際に指定されていないとして、それは信頼性の高い代替を提供していないプラグマ』の意味ので、"
    },
    {
      "indent": 0,
      "text": "14.33 Proxy-Authenticate",
      "section_title": true,
      "ja": "14.33プロキシ認証"
    },
    {
      "indent": 3,
      "text": "The Proxy-Authenticate response-header field MUST be included as part of a 407 (Proxy Authentication Required) response. The field value consists of a challenge that indicates the authentication scheme and parameters applicable to the proxy for this Request-URI.",
      "ja": "プロキシ認証レスポンス・ヘッダー・フィールドは、407（プロキシ認証が必要）応答の一部として含まれなければなりません。フィールド値はこのRequest-URIに対してプロキシに適用できる認証スキームとパラメータを示し挑戦で構成されています。"
    },
    {
      "indent": 7,
      "text": "Proxy-Authenticate = \"Proxy-Authenticate\" \":\" 1#challenge",
      "ja": "プロキシ認証は=「プロキシ認証」「：」1つの＃挑戦"
    },
    {
      "indent": 3,
      "text": "The HTTP access authentication process is described in \"HTTP Authentication: Basic and Digest Access Authentication\" [43]. Unlike WWW-Authenticate, the Proxy-Authenticate header field applies only to the current connection and SHOULD NOT be passed on to downstream clients. However, an intermediate proxy might need to obtain its own credentials by requesting them from the downstream client, which in some circumstances will appear as if the proxy is forwarding the Proxy-Authenticate header field.",
      "ja": "[43]：HTTPアクセス認証プロセスは、「基本とダイジェストアクセス認証HTTP認証」に記載されています。 WWW認証とは異なり、Proxy-Authenticateヘッダフィールドは現在の接続にのみ適用され、下流のクライアントに渡されるべきではありません。しかし、中間プロキシはプロキシがProxy-Authenticateヘッダフィールドを転送しているかのように、いくつかの状況で表示される、下流のクライアントからそれらを要求することにより、独自の資格情報を取得する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "14.34 Proxy-Authorization",
      "section_title": true,
      "ja": "14.34プロキシ認証"
    },
    {
      "indent": 3,
      "text": "The Proxy-Authorization request-header field allows the client to identify itself (or its user) to a proxy which requires authentication. The Proxy-Authorization field value consists of credentials containing the authentication information of the user agent for the proxy and/or realm of the resource being requested.",
      "ja": "プロキシ認証リクエストヘッダフィールドは、クライアントが認証を必要とするプロキシにそれ自体（又はそのユーザ）を識別することを可能にします。プロキシ認証フィールド値は、プロキシおよび/または要求されたリソースのレルムのユーザエージェントの認証情報を含む資格情報から成ります。"
    },
    {
      "indent": 7,
      "text": "Proxy-Authorization = \"Proxy-Authorization\" \":\" credentials",
      "ja": "プロキシ認証=「プロキシ認証」「：」の資格情報"
    },
    {
      "indent": 3,
      "text": "The HTTP access authentication process is described in \"HTTP Authentication: Basic and Digest Access Authentication\" [43] . Unlike Authorization, the Proxy-Authorization header field applies only to the next outbound proxy that demanded authentication using the Proxy-Authenticate field. When multiple proxies are used in a chain, the",
      "ja": "[43]：HTTPアクセス認証プロセスは、「基本とダイジェストアクセス認証HTTP認証」に記載されています。許可とは異なり、Proxy-Authorizationヘッダフィールドは、プロキシ認証フィールドを使用して認証を要求し、次のアウトバウンドプロキシに適用されます。複数のプロキシがチェーンで使用される場合、"
    },
    {
      "indent": 3,
      "text": "Proxy-Authorization header field is consumed by the first outbound proxy that was expecting to receive credentials. A proxy MAY relay the credentials from the client request to the next proxy if that is the mechanism by which the proxies cooperatively authenticate a given request.",
      "ja": "Proxy-Authorizationヘッダフィールドは、認証情報を受信するように期待していた最初のアウトバウンドプロキシによって消費されます。それはプロキシが協調与えられた要求を認証するメカニズムがある場合、プロキシは、次のプロキシにクライアント要求から資格情報を中継することができます。"
    },
    {
      "indent": 0,
      "text": "14.35 Range",
      "section_title": true,
      "ja": "14.35レンジ"
    },
    {
      "indent": 0,
      "text": "14.35.1 Byte Ranges",
      "section_title": true,
      "ja": "14.35.1バイト範囲"
    },
    {
      "indent": 3,
      "text": "Since all HTTP entities are represented in HTTP messages as sequences of bytes, the concept of a byte range is meaningful for any HTTP entity. (However, not all clients and servers need to support byte-range operations.)",
      "ja": "すべてのHTTPエンティティがバイトの配列のようなHTTPメッセージで表現されているので、バイト範囲の概念は、任意のHTTPエンティティの意味があります。 （ただし、すべてのクライアントとサーバーは、バイト範囲操作をサポートする必要はありません。）"
    },
    {
      "indent": 3,
      "text": "Byte range specifications in HTTP apply to the sequence of bytes in the entity-body (not necessarily the same as the message-body).",
      "ja": "HTTPにおけるバイト範囲仕様は、エンティティボディのバイトのシーケンス（メッセージボディとして必ずしも同じではない）に適用されます。"
    },
    {
      "indent": 3,
      "text": "A byte range operation MAY specify a single range of bytes, or a set of ranges within a single entity.",
      "ja": "バイト範囲の動作はバイトの単一の範囲、または単一のエンティティ内の範囲のセットを指定するかもしれません。"
    },
    {
      "indent": 7,
      "text": "ranges-specifier = byte-ranges-specifier\nbyte-ranges-specifier = bytes-unit \"=\" byte-range-set\nbyte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )\nbyte-range-spec = first-byte-pos \"-\" [last-byte-pos]\nfirst-byte-pos  = 1*DIGIT\nlast-byte-pos   = 1*DIGIT",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first-byte-pos value in a byte-range-spec gives the byte-offset of the first byte in a range. The last-byte-pos value gives the byte-offset of the last byte in the range; that is, the byte positions specified are inclusive. Byte offsets start at zero.",
      "ja": "バイト範囲仕様の最初のバイト-POS値は、バイトオフセット範囲内の最初のバイトを与えます。最後のバイト-POS値は、バイト・オフセットの範囲内の最後のバイトのを与えます。つまり、指定されたバイト位置が含まれています。バイト・オフセットはゼロから始まります。"
    },
    {
      "indent": 3,
      "text": "If the last-byte-pos value is present, it MUST be greater than or equal to the first-byte-pos in that byte-range-spec, or the byte-range-spec is syntactically invalid. The recipient of a byte-range-set that includes one or more syntactically invalid byte-range-spec values MUST ignore the header field that includes that byte-range-set.",
      "ja": "最後のバイト-POS値が存在する場合、そのバイト範囲仕様の最初のバイト-POS以上である必要があり、またはバイト範囲仕様は、構文的に無効です。そのバイト範囲設定含むヘッダフィールドを無視しなければならない一つ以上の構文的に無効なバイト範囲仕様値を含むバイト範囲セットの受取人。"
    },
    {
      "indent": 3,
      "text": "If the last-byte-pos value is absent, or if the value is greater than or equal to the current length of the entity-body, last-byte-pos is taken to be equal to one less than the current length of the entity-body in bytes.",
      "ja": "最後のバイト-POS値は存在しないか、または値がより大きいまたはエンティティボディの現在の長さと等しい場合、最後のバイト-POSは、エンティティの現在の長さよりも小さいものと同じであるとみなされる場合バイトで-body。"
    },
    {
      "indent": 3,
      "text": "By its choice of last-byte-pos, a client can limit the number of bytes retrieved without knowing the size of the entity.",
      "ja": "最後のバイト-POSのその選択により、クライアントは、エンティティのサイズを知らなくても、検索したバイト数を制限することができます。"
    },
    {
      "indent": 7,
      "text": "suffix-byte-range-spec = \"-\" suffix-length\nsuffix-length = 1*DIGIT",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A suffix-byte-range-spec is used to specify the suffix of the entity-body, of a length given by the suffix-length value. (That is, this form specifies the last N bytes of an entity-body.) If the entity is shorter than the specified suffix-length, the entire entity-body is used.",
      "ja": "サフィックス・バイト範囲仕様は、接尾語長の値によって指定された長さの、エンティティボディのサフィックスを指定するために使用されます。 （すなわち、このフォームは、エンティティボディの最後のNバイトを指定する。）エンティティは、指定された接尾語長より短い場合、全体のエンティティボディが使用されます。"
    },
    {
      "indent": 3,
      "text": "If a syntactically valid byte-range-set includes at least one byte-range-spec whose first-byte-pos is less than the current length of the entity-body, or at least one suffix-byte-range-spec with a non-zero suffix-length, then the byte-range-set is satisfiable. Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set is unsatisfiable, the server SHOULD return a response with a status of 416 (Requested range not satisfiable). Otherwise, the server SHOULD return a response with a status of 206 (Partial Content) containing the satisfiable ranges of the entity-body.",
      "ja": "構文的に有効なバイト範囲セットは、少なくとも一つのバイト範囲仕様が含まれている場合、その最初のバイト-POSは、エンティティボディの現在の長さよりも小さい、または非有する少なくとも一つのサフィックス・バイト範囲仕様-zeroサフィックス長は、次いで、バイト範囲セットが充足可能です。それ以外の場合は、バイト範囲-セットが充足不能です。バイト範囲セットが充足不能である場合、サーバーは416の状態（要求された範囲に充足しない）との応答を返すべきです。そうしないと、サーバはエンティティボディの満足できる範囲を含む206（部分コンテンツ）の状態に応答を返すべきです。"
    },
    {
      "indent": 3,
      "text": "Examples of byte-ranges-specifier values (assuming an entity-body of length 10000):",
      "ja": "（長さ10000のエンティティボディと仮定）バイト範囲指定子値の例："
    },
    {
      "indent": 6,
      "text": "- The first 500 bytes (byte offsets 0-499, inclusive): bytes=0- 499",
      "ja": " - 最初の500バイト（バイトオフセット0から499までの範囲）：バイト= 0〜499"
    },
    {
      "indent": 6,
      "text": "- The second 500 bytes (byte offsets 500-999, inclusive): bytes=500-999",
      "ja": " - 第500バイト（バイトオフセット500-999、包括的）：バイト= 500-999"
    },
    {
      "indent": 6,
      "text": "- The final 500 bytes (byte offsets 9500-9999, inclusive): bytes=-500",
      "ja": " - 最終的な500バイト（バイトオフセット9500から9999までの範囲）：バイト= -500"
    },
    {
      "indent": 6,
      "text": "- Or bytes=9500-",
      "ja": " - またはバイト= 9500-"
    },
    {
      "indent": 6,
      "text": "- The first and last bytes only (bytes 0 and 9999): bytes=0-0,-1",
      "ja": " - 最初と最後のバイトのみ（バイト0及び9999）：バイト= 0-0、-1"
    },
    {
      "indent": 6,
      "text": "- Several legal but not canonical specifications of the second 500 bytes (byte offsets 500-999, inclusive): bytes=500-600,601-999 bytes=500-700,601-999",
      "ja": " -  2番目の500バイト（バイトオフセット500-999、包括的）のいくつかの法的しかし正規のない仕様：バイト= 500-600,601-999バイト= 500-700,601-999"
    },
    {
      "indent": 0,
      "text": "14.35.2 Range Retrieval Requests",
      "section_title": true,
      "ja": "14.35.2範囲検索要求"
    },
    {
      "indent": 3,
      "text": "HTTP retrieval requests using conditional or unconditional GET methods MAY request one or more sub-ranges of the entity, instead of the entire entity, using the Range request header, which applies to the entity returned as the result of the request:",
      "ja": "エンティティに適用され、条件付き又は無条件のGETメソッドがRange要求ヘッダーを使用して、全体ではなく、エンティティのエンティティの1つ以上のサブ範囲を、要求することができる使用して、HTTP検索要求は、要求の結果として返されます。"
    },
    {
      "indent": 6,
      "text": "Range = \"Range\" \":\" ranges-specifier",
      "ja": "レンジ=「範囲」「：」範囲指定子"
    },
    {
      "indent": 3,
      "text": "A server MAY ignore the Range header. However, HTTP/1.1 origin servers and intermediate caches ought to support byte ranges when possible, since Range supports efficient recovery from partially failed transfers, and supports efficient partial retrieval of large entities.",
      "ja": "サーバーは、Rangeヘッダを無視するかもしれません。範囲が部分的に失敗した転送の効率的な回収をサポートし、大規模な事業体の効率的な部分的な検索をサポートしているので、HTTP / 1.1オリジンサーバと中間キャッシュは、可能な場合はバイト範囲をサポートするべきです。"
    },
    {
      "indent": 3,
      "text": "If the server supports the Range header and the specified range or ranges are appropriate for the entity:",
      "ja": "サーバがRangeヘッダをサポートしている場合、指定された範囲または範囲は、エンティティのために適切です。"
    },
    {
      "indent": 6,
      "text": "- The presence of a Range header in an unconditional GET modifies what is returned if the GET is otherwise successful. In other words, the response carries a status code of 206 (Partial Content) instead of 200 (OK).",
      "ja": " - 無条件GETにおけるRangeヘッダの存在はGETが他の成功した場合に返されるものを変更します。換言すれば、応答は、代わりに200（OK）206のステータスコード（部分コンテンツ）を運びます。"
    },
    {
      "indent": 6,
      "text": "- The presence of a Range header in a conditional GET (a request using one or both of If-Modified-Since and If-None-Match, or one or both of If-Unmodified-Since and If-Match) modifies what is returned if the GET is otherwise successful and the condition is true. It does not affect the 304 (Not Modified) response returned if the conditional is false.",
      "ja": " - 条件付きGETにおけるRangeヘッダの存在（一方または両方使用して要求した場合は、以来修飾及び場合-なしマッチ、または1つまたは両方の場合、未修飾-ため及び場合マッチ）が返されるものを変更しますGETは、そうでない場合は成功し、条件がtrueの場合。これは、条件付きがfalseの場合に返さ304（未修正）応答には影響を与えません。"
    },
    {
      "indent": 3,
      "text": "In some cases, it might be more appropriate to use the If-Range header (see section 14.27) in addition to the Range header.",
      "ja": "場合によっては、Rangeヘッダに加えたIf-Rangeヘッダ（セクション14.27を参照）を使用する方が適切かもしれません。"
    },
    {
      "indent": 3,
      "text": "If a proxy that supports ranges receives a Range request, forwards the request to an inbound server, and receives an entire entity in reply, it SHOULD only return the requested range to its client. It SHOULD store the entire received response in its cache if that is consistent with its cache allocation policies.",
      "ja": "範囲をサポートしているプロキシが範囲要求を受信した場合、インバウンドサーバに要求を転送し、応答にエンティティ全体を受信し、それだけでそのクライアントに要求された範囲を返すべきです。それは、そのキャッシュの割り当てポリシーと一致している場合は、そのキャッシュに全体受信した応答を格納する必要があります。"
    },
    {
      "indent": 0,
      "text": "14.36 Referer",
      "section_title": true,
      "ja": "14.36リファラー"
    },
    {
      "indent": 3,
      "text": "The Referer[sic] request-header field allows the client to specify, for the server's benefit, the address (URI) of the resource from which the Request-URI was obtained (the \"referrer\", although the header field is misspelled.) The Referer request-header allows a server to generate lists of back-links to resources for interest, logging, optimized caching, etc. It also allows obsolete or mistyped links to be traced for maintenance. The Referer field MUST NOT be sent if the Request-URI was obtained from a source that does not have its own URI, such as input from the user keyboard.",
      "ja": "リファラーの[sic]リクエストヘッダフィールドは、クライアントが、サーバの利益のために、リクエストURIが取得されたリソースのアドレス（URI）を指定することを可能にする（ヘッダフィールドをスペルミスしているが、「リファラー」と。）リファラーリクエストヘッダには、サーバがそれはまた時代遅れやタイプミスのリンクがメンテナンスのためにトレースすることを可能にするなど関心、ロギング、最適化されたキャッシュのためのリソースへのバックリンクのリストを生成することができます。リクエストURIは、ユーザのキーボードからの入力として、それ自身のURIを持たないソースから入手した場合リファラーフィールドを送ってはいけません。"
    },
    {
      "indent": 7,
      "text": "Referer = \"Referer\" \":\" ( absoluteURI | relativeURI )",
      "ja": "リファラー= \"リファラー\" \"：\"（absoluteURIで| relativeURI）"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 7,
      "text": "Referer: http://www.w3.org/hypertext/DataSources/Overview.html",
      "ja": "リファラー：http://www.w3.org/hypertext/DataSources/Overview.html"
    },
    {
      "indent": 3,
      "text": "If the field value is a relative URI, it SHOULD be interpreted relative to the Request-URI. The URI MUST NOT include a fragment. See section 15.1.3 for security considerations.",
      "ja": "フィールド値が相対URIである場合、それは、Request-URIに対して解釈されるべきです。 URIには、フラグメントを含んではいけません。セキュリティ上の考慮事項についてはセクション15.1.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "14.37 Retry-After",
      "section_title": true,
      "ja": "14.37リトライした後、"
    },
    {
      "indent": 3,
      "text": "The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client. This field MAY also be used with any 3xx (Redirection) response to indicate the minimum time the user-agent is asked wait before issuing the redirected request. The value of this field can be either an HTTP-date or an integer number of seconds (in decimal) after the time of the response.",
      "ja": "リトライ後レスポンスヘッダフィールドは、サービスを要求しているクライアントに利用できないと予想される時間の長さを示すために503（サービス利用不可）応答と共に使用することができます。このフィールドは、ユーザーエージェントがリダイレクトされたリクエストを発行する前に待機を依頼される最小時間を示すために、任意の300番台（リダイレクト）応答で使用されるかもしれません。このフィールドの値は、応答の時間後にHTTP-日付または（10進数）秒の整数のいずれかであり得ます。"
    },
    {
      "indent": 7,
      "text": "Retry-After = \"Retry-After\" \":\" ( HTTP-date | delta-seconds )",
      "ja": "リトライ後= \"再試行-後\" \"：\"（HTTP-日|デルタ秒）"
    },
    {
      "indent": 3,
      "text": "Two examples of its use are",
      "ja": "その使用の2つの例は、"
    },
    {
      "indent": 7,
      "text": "Retry-After: Fri, 31 Dec 1999 23:59:59 GMT\nRetry-After: 120",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the latter example, the delay is 2 minutes.",
      "ja": "後者の例では、遅延は2分です。"
    },
    {
      "indent": 0,
      "text": "14.38 Server",
      "section_title": true,
      "ja": "14.38サーバー"
    },
    {
      "indent": 3,
      "text": "The Server response-header field contains information about the software used by the origin server to handle the request. The field can contain multiple product tokens (section 3.8) and comments identifying the server and any significant subproducts. The product tokens are listed in order of their significance for identifying the application.",
      "ja": "サーバーレスポンスヘッダフィールドは、リクエストを処理するためにオリジンサーバによって使用されているソフトウェアに関する情報が含まれています。フィールドは、サーバと、任意の有意なサブプロダクトを識別する複数の製品トークン（セクション3.8）とコメントを含むことができます。製品トークンはアプリケーションを識別するためのその重要性の順に記載されています。"
    },
    {
      "indent": 7,
      "text": "Server = \"Server\" \":\" 1*( product | comment )",
      "ja": "サーバー= \"サーバー\" \"：\" 1 *（製品|コメント）"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 7,
      "text": "Server: CERN/3.0 libwww/2.17",
      "ja": "サーバー：CERN / 3.0のlibwww / 2.17"
    },
    {
      "indent": 3,
      "text": "If the response is being forwarded through a proxy, the proxy application MUST NOT modify the Server response-header. Instead, it SHOULD include a Via field (as described in section 14.45).",
      "ja": "応答がプロキシを介して転送されている場合は、プロキシ・アプリケーションは、サーバーの応答ヘッダを変更してはいけません。 （セクション14.45で説明したように）代わりに、Viaフィールドを含むべきです。"
    },
    {
      "indent": 6,
      "text": "Note: Revealing the specific software version of the server might allow the server machine to become more vulnerable to attacks against software that is known to contain security holes. Server implementors are encouraged to make this field a configurable option.",
      "ja": "注：サーバーの特定のソフトウェアバージョンを明らかにすることは、サーバー・マシンがセキュリティホールを含むことが知られているソフトウェアに対する攻撃に対してより脆弱になることを許可することがあります。サーバーの実装者は、このフィールド設定可能なオプションにすることが奨励されています。"
    },
    {
      "indent": 0,
      "text": "14.39 TE",
      "section_title": true,
      "ja": "１４。３９ て"
    },
    {
      "indent": 3,
      "text": "The TE request-header field indicates what extension transfer-codings it is willing to accept in the response and whether or not it is willing to accept trailer fields in a chunked transfer-coding. Its value may consist of the keyword \"trailers\" and/or a comma-separated list of extension transfer-coding names with optional accept parameters (as described in section 3.6).",
      "ja": "TEリクエストヘッダフィールドは、応答して、チャンク転送符号化におけるトレーラフィールドを受け入れる意志があるか否かを受け入れる意志があるもの拡張転送コーディングを示します。その値は、キーワード「予告編」および/または任意受け入れるパラメータ（セクション3.6で説明したように）を有する拡張転送コーディング名のカンマ区切りリストから構成されてもよいです。"
    },
    {
      "indent": 7,
      "text": "TE        = \"TE\" \":\" #( t-codings )\nt-codings = \"trailers\" | ( transfer-extension [ accept-params ] )",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The presence of the keyword \"trailers\" indicates that the client is willing to accept trailer fields in a chunked transfer-coding, as defined in section 3.6.1. This keyword is reserved for use with transfer-coding values even though it does not itself represent a transfer-coding.",
      "ja": "キーワード「トレーラー」の存在は、クライアントがセクション3.6.1で定義されているように、チャンク転送コーディングでトレーラーフィールドを受け入れることを望んでいることを示しています。このキーワードは、それ自体が転送コーディングを示すものではありませんが転送コーディング値を使用するために予約されています。"
    },
    {
      "indent": 3,
      "text": "Examples of its use are:",
      "ja": "その使用の例は以下のとおりです。"
    },
    {
      "indent": 7,
      "text": "TE: deflate\nTE:\nTE: trailers, deflate;q=0.5",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The TE header field only applies to the immediate connection. Therefore, the keyword MUST be supplied within a Connection header field (section 14.10) whenever TE is present in an HTTP/1.1 message.",
      "ja": "TEヘッダフィールドは直接の接続に適用されます。 TEは、HTTP / 1.1メッセージに存在しているときはいつでもそのため、キーワードは、Connectionヘッダフィールド（セクション14.10）内に供給されなければなりません。"
    },
    {
      "indent": 3,
      "text": "A server tests whether a transfer-coding is acceptable, according to a TE field, using these rules:",
      "ja": "サーバ・テスト転送コーディングは、これらのルールを使用して、TEフィールドに従って、許容可能であるかどうか。"
    },
    {
      "indent": 6,
      "text": "1. The \"chunked\" transfer-coding is always acceptable. If the keyword \"trailers\" is listed, the client indicates that it is willing to accept trailer fields in the chunked response on behalf of itself and any downstream clients. The implication is that, if given, the client is stating that either all downstream clients are willing to accept trailer fields in the forwarded response, or that it will attempt to buffer the response on behalf of downstream recipients.",
      "ja": "1.「チャンク」転送コーディングは常に可能です。キーワード「トレーラー」が表示されている場合、クライアントは、それ自体の代理と任意のダウンストリームクライアント上のチャンク応じて、トレーラーのフィールドを受け入れることを望んでいることを示しています。含意は与えられた場合、クライアントはすべてのダウンストリームのクライアントのいずれかが転送応答トレーラーフィールドを受け入れて喜んでであることを示す、またはそれは下流の受信者に代わって応答をバッファリングしようとすることです、ということです。"
    },
    {
      "indent": 9,
      "text": "Note: HTTP/1.1 does not define any means to limit the size of a chunked response such that a client can be assured of buffering the entire response.",
      "ja": "注意：HTTP / 1.1クライアントが応答全体をバッファリングを保証することができるようなチャンク応答の大きさを制限するいかなる手段を定義していません。"
    },
    {
      "indent": 6,
      "text": "2. If the transfer-coding being tested is one of the transfer-codings listed in the TE field, then it is acceptable unless it is accompanied by a qvalue of 0. (As defined in section 3.9, a qvalue of 0 means \"not acceptable.\")",
      "ja": "2.転送コーディングテストされ、セクション3.9で定義されるように、それが0ののqvalue（伴うされていない限り、それが許容されるTEフィールドにリストされた転送コーディングの1つは、0手段のqvalue「でない場合許容できます。」）"
    },
    {
      "indent": 6,
      "text": "3. If multiple transfer-codings are acceptable, then the acceptable transfer-coding with the highest non-zero qvalue is preferred. The \"chunked\" transfer-coding always has a qvalue of 1.",
      "ja": "複数の転送コーディングが許容される場合3.その後に許容される転送コーディング最高非ゼロのqvalueを有することが好ましいです。転送コーディングは常に1ののqvalueを持つ「チャンク」。"
    },
    {
      "indent": 3,
      "text": "If the TE field-value is empty or if no TE field is present, the only transfer-coding is \"chunked\". A message with no transfer-coding is always acceptable.",
      "ja": "TEフィールド値が空であるか、何のTEフィールドが存在しない場合は、専用の転送コーディングがある場合は、「チャンク」。無転送コーディングのメッセージは常に許容されます。"
    },
    {
      "indent": 0,
      "text": "14.40 Trailer",
      "section_title": true,
      "ja": "14.40トレーラー"
    },
    {
      "indent": 3,
      "text": "The Trailer general field value indicates that the given set of header fields is present in the trailer of a message encoded with chunked transfer-coding.",
      "ja": "トレーラー一般的なフィールド値は、ヘッダフィールドの所定のセットは、チャンク転送符号化で符号化されたメッセージのトレーラーに存在することを示します。"
    },
    {
      "indent": 7,
      "text": "Trailer = \"Trailer\" \":\" 1#field-name",
      "ja": "トレーラー=「予告編」「：」1＃フィールド名"
    },
    {
      "indent": 3,
      "text": "An HTTP/1.1 message SHOULD include a Trailer header field in a message using chunked transfer-coding with a non-empty trailer. Doing so allows the recipient to know which header fields to expect in the trailer.",
      "ja": "HTTP / 1.1メッセージは、チャンク転送符号化の非空のトレーラとを使用して、メッセージトレーラーヘッダフィールドを含むべきです。そうすることで、受信者がトレーラーに期待しているヘッダフィールドを知ることができます。"
    },
    {
      "indent": 3,
      "text": "If no Trailer header field is present, the trailer SHOULD NOT include any header fields. See section 3.6.1 for restrictions on the use of trailer fields in a \"chunked\" transfer-coding.",
      "ja": "何のトレーラーヘッダーフィールドが存在しない場合は、トレーラーは、任意のヘッダフィールドを含むべきではありません。 「チャンク」転送コーディングでトレーラーフィールドの使用上の制限については、セクション3.6.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Message header fields listed in the Trailer header field MUST NOT include the following header fields:",
      "ja": "トレーラーヘッダーフィールドにリストされたメッセージヘッダーフィールドは、以下のヘッダフィールドを含んではいけません。"
    },
    {
      "indent": 6,
      "text": ". Transfer-Encoding",
      "ja": "。転送エンコーディング"
    },
    {
      "indent": 6,
      "text": ". Content-Length",
      "ja": "。コンテンツの長さ"
    },
    {
      "indent": 6,
      "text": ". Trailer",
      "ja": "。トレーラー"
    },
    {
      "indent": 0,
      "text": "14.41 Transfer-Encoding",
      "section_title": true,
      "ja": "14.41転送エンコーディング"
    },
    {
      "indent": 3,
      "text": "The Transfer-Encoding general-header field indicates what (if any) type of transformation has been applied to the message body in order to safely transfer it between the sender and the recipient. This differs from the content-coding in that the transfer-coding is a property of the message, not of the entity.",
      "ja": "変換の種類安全に送信者と受信者の間に転送するためにメッセージボディに適用されている（存在する場合）は、転送エンコード一般的なヘッダフィールドは何を示しています。これは転送コーディングがメッセージのではなく、エンティティのプロパティであることを符号化コンテンツとは異なります。"
    },
    {
      "indent": 5,
      "text": "Transfer-Encoding = \"Transfer-Encoding\" \":\" 1#transfer-coding",
      "ja": "転送エンコード=「転送エンコーディング」「：」1つの＃転送コーディング"
    },
    {
      "indent": 3,
      "text": "Transfer-codings are defined in section 3.6. An example is:",
      "ja": "転送コーディングは、セクション3.6で定義されています。例は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "Transfer-Encoding: chunked",
      "ja": "転送エンコード：チャンク"
    },
    {
      "indent": 3,
      "text": "If multiple encodings have been applied to an entity, the transfer-codings MUST be listed in the order in which they were applied. Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.",
      "ja": "複数のエンコーディングがエンティティに適用されている場合は、転送コーディングは、それらが適用された順にリストされなければなりません。符号化パラメータに関する追加情報は、本明細書で定義されていない他のエンティティヘッダフィールドによって提供されてもよいです。"
    },
    {
      "indent": 3,
      "text": "Many older HTTP/1.0 applications do not understand the Transfer-Encoding header.",
      "ja": "多くの古いHTTP / 1.0のアプリケーションは、転送-Encodingヘッダを理解していません。"
    },
    {
      "indent": 0,
      "text": "14.42 Upgrade",
      "section_title": true,
      "ja": "14.42アップグレード"
    },
    {
      "indent": 3,
      "text": "The Upgrade general-header allows the client to specify what additional communication protocols it supports and would like to use if the server finds it appropriate to switch protocols. The server MUST use the Upgrade header field within a 101 (Switching Protocols) response to indicate which protocol(s) are being switched.",
      "ja": "アップグレードの一般ヘッダは、クライアントがサポートしている追加の通信プロトコルを指定することができますし、サーバーがプロトコルをスイッチすることが適当であると認める場合に使用したいと思います。サーバは、どのプロトコル（単数または複数）に切り替えられていることを示すために101（スイッチングプロトコル）応答内のアップグレードヘッダーフィールドを使用しなければなりません。"
    },
    {
      "indent": 7,
      "text": "Upgrade = \"Upgrade\" \":\" 1#product",
      "ja": "= \" \"アップグレード\" アップグレード：\" 1つの＃製品"
    },
    {
      "indent": 3,
      "text": "For example,",
      "ja": "例えば、"
    },
    {
      "indent": 7,
      "text": "Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11",
      "ja": "HTTP / 2.0 / 1.3 SHTTP、IRC / 6.9、RTA / X11：アップグレード"
    },
    {
      "indent": 3,
      "text": "The Upgrade header field is intended to provide a simple mechanism for transition from HTTP/1.1 to some other, incompatible protocol. It does so by allowing the client to advertise its desire to use another protocol, such as a later version of HTTP with a higher major version number, even though the current request has been made using HTTP/1.1. This eases the difficult transition between incompatible protocols by allowing the client to initiate a request in the more commonly supported protocol while indicating to the server that it would like to use a \"better\" protocol if available (where \"better\" is determined by the server, possibly according to the nature of the method and/or resource being requested).",
      "ja": "アップグレードヘッダフィールドは、いくつかの他の、互換性のないプロトコルにHTTP / 1.1から移行するための簡単なメカニズムを提供することを意図しています。これは、現在のリクエストがHTTP / 1.1を使用して作られているにもかかわらず、そのような高いメジャーバージョン番号を持つHTTPの以降のバージョンとして、クライアントが別のプロトコルを使用するという願望を宣伝できるようにすることで、そうします。利用できる（ここで「良好」サーバによって判定された場合、それは「より良い」プロトコルを使用したいサーバーに示しているが、これは、より一般的にサポートされるプロトコルで要求を開始するクライアントを可能にすることにより、互換性のないプロトコル間困難な遷移を容易におそらく方法及び/又はリソースの性質に応じて）要求されています。"
    },
    {
      "indent": 3,
      "text": "The Upgrade header field only applies to switching application-layer protocols upon the existing transport-layer connection. Upgrade cannot be used to insist on a protocol change; its acceptance and use by the server is optional. The capabilities and nature of the application-layer communication after the protocol change is entirely dependent upon the new protocol chosen, although the first action after changing the protocol MUST be a response to the initial HTTP request containing the Upgrade header field.",
      "ja": "アップグレードヘッダフィールドは、既存のトランスポート層接続時にアプリケーション層プロトコルの切り替えにも適用されます。アップグレードは、プロトコルの変更を主張するために使用することはできません。サーバによるその受諾と使用は任意です。プロトコルを変更した後の最初のアクションは、アップグレードヘッダフィールドを含む最初のHTTP要求に応答しなければならないが、プロトコル変更後のアプリケーション層通信の能力および性質は、選択された新しいプロトコルに完全に依存しています。"
    },
    {
      "indent": 3,
      "text": "The Upgrade header field only applies to the immediate connection. Therefore, the upgrade keyword MUST be supplied within a Connection header field (section 14.10) whenever Upgrade is present in an HTTP/1.1 message.",
      "ja": "Upgradeヘッダフィールドは直接の接続に適用されます。したがって、アップグレード・キーワードは、アップグレードがHTTP / 1.1メッセージに存在しているときはいつでも接続ヘッダフィールド（セクション14.10）内に供給されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Upgrade header field cannot be used to indicate a switch to a protocol on a different connection. For that purpose, it is more appropriate to use a 301, 302, 303, or 305 redirection response.",
      "ja": "Upgradeヘッダフィールドは異なる接続でプロトコルへの切り替えを指示するために使用することができません。そのためには、301、302、303、または305リダイレクト応答を使用することがより適切です。"
    },
    {
      "indent": 3,
      "text": "This specification only defines the protocol name \"HTTP\" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of section 3.1 and future updates to this specification. Any token can be used as a protocol name; however, it will only be useful if both the client and server associate the name with the same protocol.",
      "ja": "本明細書のセクション3.1および将来のアップデートのHTTPバージョンルールによって定義されるように、この仕様は、ハイパーテキスト転送プロトコルのファミリが使用するプロトコル名「HTTP」を定義します。任意のトークンは、プロトコル名として使用することができます。クライアントとサーバーの両方が同じプロトコルに名前を関連付ける場合しかし、それだけで有用であろう。"
    },
    {
      "indent": 0,
      "text": "14.43 User-Agent",
      "section_title": true,
      "ja": "14.43のUser-Agent"
    },
    {
      "indent": 3,
      "text": "The User-Agent request-header field contains information about the user agent originating the request. This is for statistical purposes, the tracing of protocol violations, and automated recognition of user agents for the sake of tailoring responses to avoid particular user agent limitations. User agents SHOULD include this field with requests. The field can contain multiple product tokens (section 3.8) and comments identifying the agent and any subproducts which form a significant part of the user agent. By convention, the product tokens are listed in order of their significance for identifying the application.",
      "ja": "User-Agentリクエストヘッダフィールドは、リクエストを発信するユーザエージェントに関する情報が含まれています。これは、統計目的、プロトコル違反の追跡、および特定のユーザエージェントの制限を回避するために応答を調整するためにユーザエージェントの自動化された認識のためです。ユーザエージェントはリクエストにこのフィールドを含むべきです。フィールドは、複数の製品トークン（セクション3.8）とする薬剤を同定するコメントやユーザエージェントの重要な部分を形成する任意のサブプロダクトを含むことができます。慣例により、製品トークンはアプリケーションを識別するためのその重要性の順に記載されています。"
    },
    {
      "indent": 7,
      "text": "User-Agent = \"User-Agent\" \":\" 1*( product | comment )",
      "ja": "User-Agent = \"ユーザエージェント\" \"：\" 1 *（製品|コメント）"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 7,
      "text": "User-Agent: CERN-LineMode/2.15 libwww/2.17b3",
      "ja": "User-Agent：CERN-ラインモード（LineMode！）/ 2.15のlibwww / 2.17b3"
    },
    {
      "indent": 0,
      "text": "14.44 Vary",
      "section_title": true,
      "ja": "14.44はヴァリ"
    },
    {
      "indent": 3,
      "text": "The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation. For uncacheable or stale responses, the Vary field value advises the user agent about the criteria that were used to select the representation. A Vary field value of \"*\" implies that a cache cannot determine from the request headers of a subsequent request whether this response is the appropriate representation. See section 13.6 for use of the Vary header field by caches.",
      "ja": "ヴァリフィールドの値は、応答がキャッシュを再検証することなく、後続の要求に応答するために応答を使用することが許可されているか否かを、新鮮であるが、完全に、決定リクエスト・ヘッダー・フィールドの集合を示します。キャッシュ不可または古い応答のために、ヴァリフィールド値は、表現を選択するために使用された基準について、ユーザーエージェントを助言します。 Aは、「*」のフィールドの値を変化キャッシュは、この応答が適切であるかどうかを後続リクエストのリクエストヘッダから決定することができないことを意味します。キャッシュによって異なるヘッダフィールドの使用のためのセクション13.6を参照。"
    },
    {
      "indent": 7,
      "text": "Vary = \"Vary\" \":\" ( \"*\" | 1#field-name )",
      "ja": "= \" \"異なる\" ヴァリ：\"（ \"*\" | 1＃フィールド名）"
    },
    {
      "indent": 3,
      "text": "An HTTP/1.1 server SHOULD include a Vary header field with any cacheable response that is subject to server-driven negotiation. Doing so allows a cache to properly interpret future requests on that resource and informs the user agent about the presence of negotiation on that resource. A server MAY include a Vary header field with a non-cacheable response that is subject to server-driven negotiation, since this might provide the user agent with useful information about the dimensions over which the response varies at the time of the response.",
      "ja": "HTTP / 1.1サーバは、サーバ駆動の交渉の対象となる任意のキャッシュ可能な応答に応じて変動ヘッダフィールドを含むべきです。そうすることでキャッシュが適切にそのリソースに今後の要求を解釈することを可能にし、そのリソース上の交渉の存在についてユーザエージェントに通知します。サーバーは、この応答は、応答時に変化する上に寸法に関する有用な情報をユーザエージェントを提供するかもしれないので、サーバ駆動型ネゴシエーションを受けるキャッシュ不可能な応答とともに変化するヘッダ・フィールドを含んでいてもよいです。"
    },
    {
      "indent": 3,
      "text": "A Vary field value consisting of a list of field-names signals that the representation selected for the response is based on a selection algorithm which considers ONLY the listed request-header field values in selecting the most appropriate representation. A cache MAY assume that the same selection will be made for future requests with the same values for the listed field names, for the duration of time for which the response is fresh.",
      "ja": "Aは、応答のために選択された表現が最も適切な表現を選択することでのみ記載されているリクエスト・ヘッダー・フィールドの値を考慮した選択アルゴリズムに基づいてフィールド名信号のリストからなるフィールド値を変更します。キャッシュは、同じ選択が応答が新鮮である時間の長さのために記載されているフィールド名、値が同じである、今後の要求のために作られることを仮定してもよいです。"
    },
    {
      "indent": 3,
      "text": "The field-names given are not limited to the set of standard request-header fields defined by this specification. Field names are case-insensitive.",
      "ja": "与えられたフィールド名は、本明細書で定義されている標準リクエストヘッダフィールドのセットに限定されません。フィールド名は大文字と小文字を区別しません。"
    },
    {
      "indent": 3,
      "text": "A Vary field value of \"*\" signals that unspecified parameters not limited to the request-headers (e.g., the network address of the client), play a role in the selection of the response representation. The \"*\" value MUST NOT be generated by a proxy server; it may only be generated by an origin server.",
      "ja": "Aは、不特定のパラメータは、リクエストヘッダ（例えば、クライアントのネットワーク・アドレス）に限定されるものではなく、「*」信号のフィールドの値を変え、応答表現の選択において役割を果たす。 「*」の値は、プロキシサーバによって生成されてはなりません。それだけでオリジンサーバによって生成することができます。"
    },
    {
      "indent": 0,
      "text": "14.45 Via",
      "section_title": true,
      "ja": "14.45経由"
    },
    {
      "indent": 3,
      "text": "The Via general-header field MUST be used by gateways and proxies to indicate the intermediate protocols and recipients between the user agent and the server on requests, and between the origin server and the client on responses. It is analogous to the \"Received\" field of RFC 822 [9] and is intended to be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of all senders along the request/response chain.",
      "ja": "経由一般ヘッダフィールドは、ユーザエージェントとのリクエストでサーバーとの間の中間プロトコルと受信者を示すためにゲートウェイやプロキシによって使用され、オリジンサーバと応答上のクライアントの間でなければなりません。これは、[9] RFC 822の「受信」フィールドに類似していると、メッセージの転送を追跡要求ループを回避し、そして要求/応答チェーンに沿ってすべての送信者のプロトコル能力を識別するために使用されることが意図されます。"
    },
    {
      "indent": 6,
      "text": "Via = \"Via\" \":\" 1#( received-protocol received-by [ comment ] ) received-protocol = [ protocol-name \"/\" ] protocol-version protocol-name = token protocol-version = token received-by = ( host [ \":\" port ] ) | pseudonym pseudonym = token",
      "ja": "「1＃（受信プロトコルで受信することにより[コメント]）を受信プロトコル= [プロトコル名「/」]プロトコルバージョンプロトコル名=トークンプロトコルバージョン=トークンが受信されたバイ=：=「を介して」」を介して（ホスト[ \"：\" ポート]）|仮名仮名=トークン"
    },
    {
      "indent": 3,
      "text": "The received-protocol indicates the protocol version of the message received by the server or client along each segment of the request/response chain. The received-protocol version is appended to the Via field value when the message is forwarded so that information about the protocol capabilities of upstream applications remains visible to all recipients.",
      "ja": "受信プロトコルは、要求/応答チェーンの各セグメントに沿って、サーバまたはクライアントによって受信されたメッセージのプロトコルバージョンを示しています。メッセージが転送されたときに上流のアプリケーションのプロトコル能力に関する情報がすべての受信者に表示されたままとなるよう受信プロトコルバージョンは、Viaフィールドの値に追加されます。"
    },
    {
      "indent": 3,
      "text": "The protocol-name is optional if and only if it would be \"HTTP\". The received-by field is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, it MAY be replaced by a pseudonym. If the port is not given, it MAY be assumed to be the default port of the received-protocol.",
      "ja": "それは、「HTTP」だろうと場合にのみ場合、プロトコル名はオプションです。受信して、フィールドは、通常は、その後、メッセージを転送し、受信者のサーバーまたはクライアントのホストおよびオプションのポート番号です。本物のホストは機密情報であるとみなされた場合しかし、それは仮名で置き換えてもよいです。ポートが指定されていない場合は、受信したプロトコルのデフォルトポートであると仮定することができます。"
    },
    {
      "indent": 3,
      "text": "Multiple Via field values represents each proxy or gateway that has forwarded the message. Each recipient MUST append its information such that the end result is ordered according to the sequence of forwarding applications.",
      "ja": "フィールド値を介して複数のメッセージを転送した各プロキシまたはゲートウェイを表します。各受信者は、最終的な結果は、転送アプリケーションの順序に従って順序付けされるように、その情報を追加しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Comments MAY be used in the Via header field to identify the software of the recipient proxy or gateway, analogous to the User-Agent and Server header fields. However, all comments in the Via field are optional and MAY be removed by any recipient prior to forwarding the message.",
      "ja": "コメントは、ユーザエージェントとサーバのヘッダフィールドに類似し、受信者プロキシまたはゲートウェイのソフトウェアを識別するためにViaヘッダーフィールドで使用されるかもしれません。しかし、Viaフィールド内のすべてのコメントはオプションであり、メッセージを転送する前に受信者によって除去することができます。"
    },
    {
      "indent": 3,
      "text": "For example, a request message could be sent from an HTTP/1.0 user agent to an internal proxy code-named \"fred\", which uses HTTP/1.1 to forward the request to a public proxy at nowhere.com, which completes the request by forwarding it to the origin server at www.ics.uci.edu. The request received by www.ics.uci.edu would then have the following Via header field:",
      "ja": "例えば、要求メッセージは、内部プロキシコードネーム「フレッド」によって要求を完了nowhere.comで公衆プロキシに要求を転送するHTTP / 1.1を使用するHTTP / 1.0ユーザエージェントから送信することができますwww.ics.uci.eduでオリジンサーバに転送します。 www.ics.uci.eduで受信した要求は、Viaヘッダーフィールド以下があります："
    },
    {
      "indent": 7,
      "text": "Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)",
      "ja": "ビア：1.0フレッド、1.1 nowhere.com（アパッチ/ 1.1）"
    },
    {
      "indent": 3,
      "text": "Proxies and gateways used as a portal through a network firewall SHOULD NOT, by default, forward the names and ports of hosts within the firewall region. This information SHOULD only be propagated if explicitly enabled. If not enabled, the received-by host of any host behind the firewall SHOULD be replaced by an appropriate pseudonym for that host.",
      "ja": "ネットワークファイアウォール経由のポータルとして使用するプロキシとゲートウェイは、デフォルトでは、ファイアウォール領域内のホストの名前とポートを転送すべきではありません。明示的に有効にした場合、この情報にのみ伝搬されるべきです。有効でない場合は、受信して、ファイアウォールの背後にある任意のホストのホスト、そのホストのための適切なペンネームで交換する必要があります。"
    },
    {
      "indent": 3,
      "text": "For organizations that have strong privacy requirements for hiding internal structures, a proxy MAY combine an ordered subsequence of Via header field entries with identical received-protocol values into a single such entry. For example,",
      "ja": "内部構造を隠蔽するための強力なプライバシー要件を持っている組織では、プロキシは、そのような単一のエントリに、同一の受信プロトコル値を持つViaヘッダーフィールドエントリの順序付きサブシーケンスを組み合わせることができます。例えば、"
    },
    {
      "indent": 7,
      "text": "Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy",
      "ja": "ビア：1.0リッキー、1.1エセル、1.1フレッド、1.0ルーシー"
    },
    {
      "indent": 8,
      "text": "could be collapsed to",
      "ja": "に折りたたむことができ"
    },
    {
      "indent": 7,
      "text": "Via: 1.0 ricky, 1.1 mertz, 1.0 lucy",
      "ja": "ビア：1.0リッキー、1.1メルツ、1.0ルーシー"
    },
    {
      "indent": 3,
      "text": "Applications SHOULD NOT combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms. Applications MUST NOT combine entries which have different received-protocol values.",
      "ja": "彼らはすべて同じ組織の管理下にあり、ホストが既に偽名に置き換えられていない限り、アプリケーションは、複数のエントリを結合すべきではありません。アプリケーションは、異なる受信プロトコル値を持つエントリを組み合わせてはなりません。"
    },
    {
      "indent": 0,
      "text": "14.46 Warning",
      "section_title": true,
      "ja": "14.46警告"
    },
    {
      "indent": 3,
      "text": "The Warning general-header field is used to carry additional information about the status or transformation of a message which might not be reflected in the message. This information is typically used to warn about a possible lack of semantic transparency from caching operations or transformations applied to the entity body of the message.",
      "ja": "警告一般的なヘッダフィールドは、メッセージに反映されないかもしれないメッセージのステータスまたは変換に関する追加情報を搬送するために使用されます。この情報は、典型的には、メッセージのエンティティボディに適用される操作または変換をキャッシュから意味の透明性の可能性の欠如について警告するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Warning headers are sent with responses using:",
      "ja": "警告ヘッダは使用して応答して送信されます。"
    },
    {
      "indent": 7,
      "text": "Warning = \"Warning\" \":\" 1#warning-value",
      "ja": "警告=「警告」「：」1＃警告値"
    },
    {
      "indent": 7,
      "text": "warning-value = warn-code SP warn-agent SP warn-text [SP warn-date]",
      "ja": "警告値=警告コードSP警告エージェントSP警告テキスト[SP警告日付]"
    },
    {
      "indent": 7,
      "text": "warn-code = 3DIGIT warn-agent = ( host [ \":\" port ] ) | pseudonym ; the name or pseudonym of the server adding ; the Warning header, for use in debugging warn-text = quoted-string warn-date = <\"> HTTP-date <\">",
      "ja": "警告コード= 3DIGIT警告エージェント=（ホスト[ \"：\" ポート]）|ペンネーム;追加するサーバーの名前または仮名。警告ヘッダー、デバッグでの使用がために警告するテキスト=引用符で囲まれた文字列を警告日付= <「> HTTP-日<」>"
    },
    {
      "indent": 3,
      "text": "A response MAY carry more than one Warning header.",
      "ja": "応答は、複数の警告ヘッダを搬送することができます。"
    },
    {
      "indent": 3,
      "text": "The warn-text SHOULD be in a natural language and character set that is most likely to be intelligible to the human user receiving the response. This decision MAY be based on any available knowledge, such as the location of the cache or user, the Accept-Language field in a request, the Content-Language field in a response, etc. The default language is English and the default character set is ISO-8859-1.",
      "ja": "警告テキストは、応答を受け取る人間のユーザに理解できる可能性が最も高い自然言語と文字セットにする必要があります。この決定は、このようなキャッシュやユーザの場所として、任意の利用可能な知識に基づくことができる、などのデフォルト言語要求内のAccept-言語フィールド、レスポンスのContent-Languageフィールドには、英語とデフォルトの文字セットですISO-8859-1です。"
    },
    {
      "indent": 3,
      "text": "If a character set other than ISO-8859-1 is used, it MUST be encoded in the warn-text using the method described in RFC 2047 [14].",
      "ja": "文字は、ISO-8859-1以外が使用されて設定されている場合、それは、RFC 2047 [14]に記載の方法を用いて、警告テキストにエンコードされなければなりません。"
    },
    {
      "indent": 3,
      "text": "Warning headers can in general be applied to any message, however some specific warn-codes are specific to caches and can only be applied to response messages. New Warning headers SHOULD be added after any existing Warning headers. A cache MUST NOT delete any Warning header that it received with a message. However, if a cache successfully validates a cache entry, it SHOULD remove any Warning headers previously attached to that entry except as specified for specific Warning codes. It MUST then add any Warning headers received in the validating response. In other words, Warning headers are those that would be attached to the most recent relevant response.",
      "ja": "警告ヘッダは一般に、しかし、いくつかの特定は、警告・コードがキャッシュに特異的であるとのみ応答メッセージに適用することができる、任意のメッセージにも適用することができます。新しい警告ヘッダは、既存の警告ヘッダーの後に追加する必要があります。キャッシュは、それがメッセージを受け取ったすべての警告ヘッダを削除してはなりません。キャッシュがうまくキャッシュエントリを検証する場合は、それは以前に特定の警告コードのために指定された場合を除き、そのエントリに接続されているすべての警告ヘッダを削除する必要があります。その後、検証を受けて受信したすべての警告ヘッダを追加しなければなりません。言い換えれば、警告ヘッダは、関連する最新の応答に取り付けられるものです。"
    },
    {
      "indent": 3,
      "text": "When multiple Warning headers are attached to a response, the user agent ought to inform the user of as many of them as possible, in the order that they appear in the response. If it is not possible to inform the user of all of the warnings, the user agent SHOULD follow these heuristics:",
      "ja": "複数の警告ヘッダーが応答に添付されている場合、ユーザーエージェントは、彼らが応答に表示されるためには、それらの可能な限り多くのユーザーに知らせるべきです。それは警告のすべてのユーザに知らせることができない場合、ユーザエージェントは、これらの経験則に従ってください："
    },
    {
      "indent": 6,
      "text": "- Warnings that appear early in the response take priority over those appearing later in the response.",
      "ja": " - 初期応答で表示される警告が応答の後半で登場するものを優先します。"
    },
    {
      "indent": 6,
      "text": "- Warnings in the user's preferred character set take priority over warnings in other character sets but with identical warn-codes and warn-agents.",
      "ja": " - ユーザの好みの文字で警告が他の文字セットに警告よりも優先しているが同一で、コードを警告して、薬を警告しています。"
    },
    {
      "indent": 3,
      "text": "Systems that generate multiple Warning headers SHOULD order them with this user agent behavior in mind.",
      "ja": "複数の警告ヘッダを生成するシステムは念頭に置いて、このユーザエージェントの行動でそれらを注文する必要があります。"
    },
    {
      "indent": 3,
      "text": "Requirements for the behavior of caches with respect to Warnings are stated in section 13.1.2.",
      "ja": "警告に関するキャッシュの振る舞いの要件は、セクション13.1.2に記載されています。"
    },
    {
      "indent": 3,
      "text": "This is a list of the currently-defined warn-codes, each with a recommended warn-text in English, and a description of its meaning.",
      "ja": "これは、現在定義されて警告する - コードのリストである、お勧めとのそれぞれは英語でテキストを警告し、その意味の説明。"
    },
    {
      "indent": 3,
      "text": "110 Response is stale MUST be included whenever the returned response is stale.",
      "ja": "110応答返される応答が失効しているときはいつでも含まなければならない陳腐です。"
    },
    {
      "indent": 3,
      "text": "111 Revalidation failed MUST be included if a cache returns a stale response because an attempt to revalidate the response failed, due to an inability to reach the server.",
      "ja": "応答を再確認しようとする試みが失敗したため、キャッシュが原因のサーバーに到達することができないため、古くなったレスポンスを返す場合、再検証が失敗した111を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "112 Disconnected operation SHOULD be included if the cache is intentionally disconnected from the rest of the network for a period of time.",
      "ja": "キャッシュが意図時間の期間のためのネットワークの残りの部分から切断された場合112切断動作が含まれるべきです。"
    },
    {
      "indent": 3,
      "text": "113 Heuristic expiration MUST be included if the cache heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater than 24 hours.",
      "ja": "キャッシュが発見的に24時間よりも大きいとレスポンスの年齢が24時間以上である新鮮寿命を選択した場合は113ヒューリスティック有効期限が含まれなければなりません。"
    },
    {
      "indent": 3,
      "text": "199 Miscellaneous warning The warning text MAY include arbitrary information to be presented to a human user, or logged. A system receiving this warning MUST NOT take any automated action, besides presenting the warning to the user.",
      "ja": "警告文は、任意の情報を含んでいてもよい199その他の警告が人間のユーザに提示、または記録されています。この警告を受けたシステムは、ユーザに警告を提示するほか、任意の自動化された行動をしてはなりません。"
    },
    {
      "indent": 3,
      "text": "214 Transformation applied MUST be added by an intermediate cache or proxy if it applies any transformation changing the content-coding (as specified in the Content-Encoding header) or media-type (as specified in the Content-Type header) of the response, or the entity-body of the response, unless this Warning code already appears in the response.",
      "ja": "214形質転換は、それが応答の任意のコンテンツコードを変更変換（コンテンツエンコードヘッダで指定されるように）、またはメディアタイプ（Content-Typeヘッダで指定されるように）適用される場合、中間キャッシュまたはプロキシによって追加されなければならない適用しましたまたは応答のエンティティボディは、この警告コードはすでに対応して表示されていない限り。"
    },
    {
      "indent": 3,
      "text": "299 Miscellaneous persistent warning The warning text MAY include arbitrary information to be presented to a human user, or logged. A system receiving this warning MUST NOT take any automated action.",
      "ja": "警告文は、任意の情報を含んでいてもよい299その他の永続的な警告が人間のユーザに提示、または記録されています。この警告を受けたシステムは、任意の自動化された行動をしてはなりません。"
    },
    {
      "indent": 3,
      "text": "If an implementation sends a message with one or more Warning headers whose version is HTTP/1.0 or lower, then the sender MUST include in each warning-value a warn-date that matches the date in the response.",
      "ja": "実装バージョンHTTP / 1.0以下である一つ以上の警告ヘッダを持つメッセージを送信する場合、送信者は、各警告値に応答して、日付と一致警告日付を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an implementation receives a message with a warning-value that includes a warn-date, and that warn-date is different from the Date value in the response, then that warning-value MUST be deleted from the message before storing, forwarding, or using it. (This prevents bad consequences of naive caching of Warning header fields.) If all of the warning-values are deleted for this reason, the Warning header MUST be deleted as well.",
      "ja": "実装は警告日付を含む警告値を持つメッセージを受信し、その警告日付は、応答の日付値と異なる場合、その警告値は、格納、転送、または前にメッセージから削除する必要がありますそれを使用。 （これは、ヘッダフィールドを警告のナイーブキャッシングの悪い影響を防止する。）警報値の全てが、この理由のために削除された場合、警告ヘッダも削除しなければなりません。"
    },
    {
      "indent": 0,
      "text": "14.47 WWW-Authenticate",
      "section_title": true,
      "ja": "14.47 WWW認証"
    },
    {
      "indent": 3,
      "text": "The WWW-Authenticate response-header field MUST be included in 401 (Unauthorized) response messages. The field value consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the Request-URI.",
      "ja": "WWW認証応答ヘッダフィールドは401（不正な）応答メッセージに含まれなければなりません。フィールドの値は、Request-URIに適用可能な認証方式（S）とパラメータを示す少なくとも一つのチャレンジから成ります。"
    },
    {
      "indent": 7,
      "text": "WWW-Authenticate = \"WWW-Authenticate\" \":\" 1#challenge",
      "ja": "WWW認証は= \"WWW認証\" \"：\" 1つの＃挑戦"
    },
    {
      "indent": 3,
      "text": "The HTTP access authentication process is described in \"HTTP Authentication: Basic and Digest Access Authentication\" [43]. User agents are advised to take special care in parsing the WWW-Authenticate field value as it might contain more than one challenge, or if more than one WWW-Authenticate header field is provided, the contents of a challenge itself can contain a comma-separated list of authentication parameters.",
      "ja": "[43]：HTTPアクセス認証プロセスは、「基本とダイジェストアクセス認証HTTP認証」に記載されています。ユーザエージェントは、それが複数の課題が含まれている可能性がある、または複数のWWW-Authenticateヘッダフィールドが用意されている場合、挑戦自体の内容がカンマ区切りを含めることができるようWWW認証フィールド値を解析するには、特別な注意を払うことをお勧めします認証パラメータのリスト。"
    },
    {
      "indent": 0,
      "text": "15 Security Considerations",
      "ja": "15のセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section is meant to inform application developers, information providers, and users of the security limitations in HTTP/1.1 as described by this document. The discussion does not include definitive solutions to the problems revealed, though it does make some suggestions for reducing security risks.",
      "ja": "このセクションでは、この文書で説明するように、アプリケーション開発者、情報提供者、およびHTTP / 1.1でのセキュリティ制限をユーザーに知らせるためのものです。それはセキュリティリスクを軽減するためのいくつかの提案を行いんが議論は、明らかに問題の決定的な解決策が含まれていません。"
    },
    {
      "indent": 0,
      "text": "15.1 Personal Information",
      "section_title": true,
      "ja": "15.1個人情報"
    },
    {
      "indent": 3,
      "text": "HTTP clients are often privy to large amounts of personal information (e.g. the user's name, location, mail address, passwords, encryption keys, etc.), and SHOULD be very careful to prevent unintentional leakage of this information via the HTTP protocol to other sources. We very strongly recommend that a convenient interface be provided for the user to control dissemination of such information, and that designers and implementors be particularly careful in this area. History shows that errors in this area often create serious security and/or privacy problems and generate highly adverse publicity for the implementor's company.",
      "ja": "HTTPクライアントは、多くの場合、個人情報を大量に関与している（例えば、ユーザの名前、場所、メールアドレス、パスワード、暗号化キーなど）、および他のソースへのHTTPプロトコルを介して、この意図しない情報の漏洩を防ぐために非常に注意する必要があります。我々は非常に強く便利なインターフェイスは、このような情報の普及を制御するためにユーザに提供することをお勧めします、そしてデザイナーと実装者は、この分野では特に注意すること。歴史は、この分野でのエラーは、多くの場合、深刻なセキュリティおよび/またはプライバシーの問題を作成し、実装者の会社にとって非常に不利な広報を生成することを示しています。"
    },
    {
      "indent": 0,
      "text": "15.1.1 Abuse of Server Log Information",
      "section_title": true,
      "ja": "サーバーログ情報の乱用15.1.1"
    },
    {
      "indent": 3,
      "text": "A server is in the position to save personal data about a user's requests which might identify their reading patterns or subjects of interest. This information is clearly confidential in nature and its handling can be constrained by law in certain countries. People using the HTTP protocol to provide data are responsible for ensuring that such material is not distributed without the permission of any individuals that are identifiable by the published results.",
      "ja": "サーバーは、自分の読書パターンや興味の対象を特定する可能性があるユーザーの要求に関する個人データを保存する立場にあります。この情報は、自然の中で明確に機密であり、その取り扱いが特定の国の法律で制約することができます。データを提供するために、HTTPプロトコルを使っている人は、このような材料が公開された結果によって特定されているすべての人の許可なしに配布されていないことを確実にする責任があります。"
    },
    {
      "indent": 0,
      "text": "15.1.2 Transfer of Sensitive Information",
      "section_title": true,
      "ja": "機密情報の15.1.2転送"
    },
    {
      "indent": 3,
      "text": "Like any generic data transfer protocol, HTTP cannot regulate the content of the data that is transferred, nor is there any a priori method of determining the sensitivity of any particular piece of information within the context of any given request. Therefore, applications SHOULD supply as much control over this information as possible to the provider of that information. Four header fields are worth special mention in this context: Server, Via, Referer and From.",
      "ja": "任意の汎用データ転送プロトコルと同様に、HTTPは、転送されるデータの内容を規制することができない、またそこには、任意の所与の要求のコンテキスト内の情報の任意の特定の部分の感度を決定するための任意の先験的な方法です。したがって、アプリケーションは、情報の提供者に可能なこの情報上にできるだけ多くの制御を提供する必要があります。 4つのヘッダーフィールドは、この文脈で特に言及する価値がある：サーバー、経由、リファラーやから。"
    },
    {
      "indent": 3,
      "text": "Revealing the specific software version of the server might allow the server machine to become more vulnerable to attacks against software that is known to contain security holes. Implementors SHOULD make the Server header field a configurable option.",
      "ja": "サーバーの特定のソフトウェアバージョンを明らかにすることは、サーバー・マシンは、セキュリティホールを含むことが知られているソフトウェアに対する攻撃に対してより脆弱になることを許可することがあります。実装者は、Serverヘッダフィールド設定可能なオプションにするべきです。"
    },
    {
      "indent": 3,
      "text": "Proxies which serve as a portal through a network firewall SHOULD take special precautions regarding the transfer of header information that identifies the hosts behind the firewall. In particular, they SHOULD remove, or replace with sanitized versions, any Via fields generated behind the firewall.",
      "ja": "ネットワークファイアウォールを介してポータルとして機能するプロキシは、ファイアウォールの背後のホストを識別するヘッダ情報の転送に関する特別な予防措置を取るべきです。特に、それらは削除すべきである、または消毒のバージョン、ファイアウォールの背後に生成されたのViaフィールドと交換してください。"
    },
    {
      "indent": 3,
      "text": "The Referer header allows reading patterns to be studied and reverse links drawn. Although it can be very useful, its power can be abused if user details are not separated from the information contained in the Referer. Even when the personal information has been removed, the Referer header might indicate a private document's URI whose publication would be inappropriate.",
      "ja": "Refererヘッダは、読取パターンが研究と描か逆方向リンクすることを可能にします。それは非常に便利ですが、ユーザーの詳細がリファラーに含まれる情報から分離されていない場合は、その力を悪用される可能性が。個人情報が削除された場合でも、Refererヘッダは、その出版不適切であるプライベート文書のURIを示している可能性があります。"
    },
    {
      "indent": 3,
      "text": "The information sent in the From field might conflict with the user's privacy interests or their site's security policy, and hence it SHOULD NOT be transmitted without the user being able to disable, enable, and modify the contents of the field. The user MUST be able to set the contents of this field within a user preference or application defaults configuration.",
      "ja": "Fromフィールドで送られる情報は、ユーザーのプライバシーの利益や自分のサイトのセキュリティポリシーと競合する可能性があります、したがって、それは、ユーザが、無効化、有効化、およびフィールドの内容を変更できずに送信されるべきではありません。ユーザは、ユーザの嗜好やアプリケーションのデフォルト構成内のこのフィールドの内容を設定できなければなりません。"
    },
    {
      "indent": 3,
      "text": "We suggest, though do not require, that a convenient toggle interface be provided for the user to enable or disable the sending of From and Referer information.",
      "ja": "私たちは便利なトグルインターフェースはからの送信とリファラー情報を有効または無効にするユーザーのために提供されることを必要としないものの、示唆しています。"
    },
    {
      "indent": 3,
      "text": "The User-Agent (section 14.43) or Server (section 14.38) header fields can sometimes be used to determine that a specific client or server have a particular security hole which might be exploited. Unfortunately, this same information is often used for other valuable purposes for which HTTP currently has no better mechanism.",
      "ja": "ユーザエージェント（セクション14.43）またはサーバ（セクション14.38）ヘッダフィールドは、時々、特定のクライアントまたはサーバが悪用される可能性がある特定のセキュリティホールを有することを決定するために使用することができます。残念ながら、これと同じ情報は、多くの場合、HTTPには現在、より良い仕組みを持っている他の貴重な目的のために使用されます。"
    },
    {
      "indent": 0,
      "text": "15.1.3 Encoding Sensitive Information in URI's",
      "section_title": true,
      "ja": "15.1.3 URIの中に機密情報を符号化します"
    },
    {
      "indent": 3,
      "text": "Because the source of a link might be private information or might reveal an otherwise private information source, it is strongly recommended that the user be able to select whether or not the Referer field is sent. For example, a browser client could have a toggle switch for browsing openly/anonymously, which would respectively enable/disable the sending of Referer and From information.",
      "ja": "リンクのソースは、個人情報であるかもしれない、あるいは民間の情報源を明らかにする可能性があるため、強く、ユーザがリファラーフィールドが送信されたかどうかを選択できるようにすることをお勧めします。たとえば、ブラウザクライアントは、それぞれのRefererを送信し、情報から有効/無効にすることになる、公然/匿名で閲覧するためのトグルスイッチを持つことができます。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT include a Referer header field in a (non-secure) HTTP request if the referring page was transferred with a secure protocol.",
      "ja": "参照ページがセキュアプロトコルで転送されていた場合、クライアントは、（非セキュア）HTTPリクエストにRefererヘッダフィールドを含むべきではありません。"
    },
    {
      "indent": 3,
      "text": "Authors of services which use the HTTP protocol SHOULD NOT use GET based forms for the submission of sensitive data, because this will cause this data to be encoded in the Request-URI. Many existing servers, proxies, and user agents will log the request URI in some place where it might be visible to third parties. Servers can use POST-based form submission instead",
      "ja": "これは、このデータが要求URIでエンコードされるようになりますので、HTTPプロトコルを使用するサービスの作成者は、機密データの提出をベースGETフォームを使用しないでください。多くの既存のサーバ、プロキシ、ユーザエージェントは、それが第三者に見えるかもしれないいくつかの場所でリクエストURIを記録します。サーバーは、代わりにPOSTベースのフォーム送信を使用することができます"
    },
    {
      "indent": 0,
      "text": "15.1.4 Privacy Issues Connected to Accept Headers",
      "section_title": true,
      "ja": "ヘッダを受け入れるに接続15.1.4プライバシー問題"
    },
    {
      "indent": 3,
      "text": "Accept request-headers can reveal information about the user to all servers which are accessed. The Accept-Language header in particular can reveal information the user would consider to be of a private nature, because the understanding of particular languages is often strongly correlated to the membership of a particular ethnic group. User agents which offer the option to configure the contents of an Accept-Language header to be sent in every request are strongly encouraged to let the configuration process include a message which makes the user aware of the loss of privacy involved.",
      "ja": "アクセスされたすべてのサーバーにユーザーに関する情報を明らかにすることができリクエストヘッダを受け入れます。具体的には受け入れ言語をヘッダには、ユーザが特定の言語の理解がしばしば強く特定の民族グループのメンバーシップに相関しているので、プライベートな性質のものであると考えるでしょう情報を明らかにすることができます。リクエストごとに送信されるのAccept-Languageヘッダの内容を設定するオプションを提供するユーザエージェントは強く設定プロセスが関与プライバシーの損失を認識して、ユーザを作成、メッセージを含めるようにすることが奨励されています。"
    },
    {
      "indent": 3,
      "text": "An approach that limits the loss of privacy would be for a user agent to omit the sending of Accept-Language headers by default, and to ask the user whether or not to start sending Accept-Language headers to a server if it detects, by looking for any Vary response-header fields generated by the server, that such sending could improve the quality of service.",
      "ja": "ユーザーエージェントは、デフォルトでは、送信のたAccept-Languageヘッダを省略すると、それが検出された場合見ることで、サーバにたAccept-Languageヘッダの送信を開始するかどうかをユーザーに依頼するため、プライバシーの損失を制限アプローチは次のようになりますいずれかのそのような送信は、サービスの品質を向上させることができることを、サーバによって生成された応答ヘッダフィールドを変更します。"
    },
    {
      "indent": 3,
      "text": "Elaborate user-customized accept header fields sent in every request, in particular if these include quality values, can be used by servers as relatively reliable and long-lived user identifiers. Such user identifiers would allow content providers to do click-trail tracking, and would allow collaborating content providers to match cross-server click-trails or form submissions of individual users. Note that for many users not behind a proxy, the network address of the host running the user agent will also serve as a long-lived user identifier. In environments where proxies are used to enhance privacy, user agents ought to be conservative in offering accept header configuration options to end users. As an extreme privacy measure, proxies could filter the accept headers in relayed requests. General purpose user agents which provide a high degree of header configurability SHOULD warn users about the loss of privacy which can be involved.",
      "ja": "精巧なユーザカスタマイズは、これらが品質値を含む場合、比較的信頼性が高く長寿命のユーザ識別子として、サーバで使用することができ、特に、すべての要求で送信されたヘッダフィールドを受け入れます。このようなユーザ識別子は、コンテンツプロバイダーがクリック道の追跡を行うことができるようになる、とクロスサーバクリックトレイルや個々のユーザーのフォームの送信に一致するように、コンテンツプロバイダを共同で可能になります。ないプロキシの背後にある多くのユーザーのために、ユーザエージェントを実行しているホストのネットワークアドレスも長命のユーザ識別子として機能することに注意してください。プロキシがプライバシーを強化するために使用されている環境では、ユーザエージェントは、エンドユーザに、ヘッダの構成オプションを受け入れる提供に保守的であるべきです。極端なプライバシー対策として、プロキシが中継された要求で受け入れるヘッダをフィルタリングすることができます。ヘッダ設定機能の高度を提供汎用ユーザエージェントが関与することができ、プライバシーの喪失についてユーザーに警告すべきです。"
    },
    {
      "indent": 0,
      "text": "15.2 Attacks Based On File and Path Names",
      "section_title": true,
      "ja": "ファイルとパス名に基づいて15.2攻撃"
    },
    {
      "indent": 3,
      "text": "Implementations of HTTP origin servers SHOULD be careful to restrict the documents returned by HTTP requests to be only those that were intended by the server administrators. If an HTTP server translates HTTP URIs directly into file system calls, the server MUST take special care not to serve files that were not intended to be delivered to HTTP clients. For example, UNIX, Microsoft Windows, and other operating systems use \"..\" as a path component to indicate a directory level above the current one. On such a system, an HTTP server MUST disallow any such construct in the Request-URI if it would otherwise allow access to a resource outside those intended to be accessible via the HTTP server. Similarly, files intended for reference only internally to the server (such as access control files, configuration files, and script code) MUST be protected from inappropriate retrieval, since they might contain sensitive information. Experience has shown that minor bugs in such HTTP server implementations have turned into security risks.",
      "ja": "HTTPオリジンサーバの実装はサーバー管理者のみが意図したものであることをHTTPリクエストによって返された文書を制限することに注意する必要があります。 HTTPサーバがファイルシステムコールに直接HTTP URIを変換した場合、サーバはHTTPクライアントに配信されることを意図していなかったファイルを提供していない特別な注意を払わなければなりません。たとえば、UNIX、Microsoft Windowsの、および他のオペレーティングシステムは、現在の1以上のディレクトリレベルを示すために「..」パスコンポーネントとして使用します。それはそうでない場合はHTTPサーバを経由してアクセスできるようにすることを意図したもの外のリソースへのアクセスを可能にする場合、このようなシステムでは、HTTPサーバは、Request-URIのいずれかのような構築物を禁止しなければなりません。同様に、ファイルがサーバーにのみ内部参照のために意図さ彼らは機密情報が含まれているかもしれないので（例えば、アクセス制御ファイル、構成ファイル、およびスクリプトコードなど）、不適切な検索から保護されなければなりません。経験は、このようなHTTPサーバ実装におけるマイナーなバグはセキュリティリスクになっていることが示されています。"
    },
    {
      "indent": 0,
      "text": "15.3 DNS Spoofing",
      "section_title": true,
      "ja": "15.3 DNSスプーフィング"
    },
    {
      "indent": 3,
      "text": "Clients using HTTP rely heavily on the Domain Name Service, and are thus generally prone to security attacks based on the deliberate mis-association of IP addresses and DNS names. Clients need to be cautious in assuming the continuing validity of an IP number/DNS name association.",
      "ja": "HTTPを使用しているクライアントは、ドメインネームサービスに大きく依存しているため、IPアドレスとDNS名の故意の誤関連付けに基づいてセキュリティ攻撃に対する一般的傾向があります。クライアントは、IP番号/ DNS名協会の継続的な妥当性を仮定して慎重にする必要があります。"
    },
    {
      "indent": 3,
      "text": "In particular, HTTP clients SHOULD rely on their name resolver for confirmation of an IP number/DNS name association, rather than caching the result of previous host name lookups. Many platforms already can cache host name lookups locally when appropriate, and they SHOULD be configured to do so. It is proper for these lookups to be cached, however, only when the TTL (Time To Live) information reported by the name server makes it likely that the cached information will remain useful.",
      "ja": "具体的には、HTTPクライアントではなく、以前のホスト名ルックアップの結果をキャッシュするよりも、IP数/ DNS名協会の確認のために自分の名前リゾルバに頼るべきです。適切な場合、多くのプラットフォームでは、すでにローカルホスト名のルックアップをキャッシュすることができ、そして彼らがそうするように設定する必要があります。これらの検索がキャッシュされることはネームサーバによって報告されたTTL（生存時間）の情報が、それはおそらく、キャッシュされた情報が有用残ることになりときにのみ、しかし、適切です。"
    },
    {
      "indent": 3,
      "text": "If HTTP clients cache the results of host name lookups in order to achieve a performance improvement, they MUST observe the TTL information reported by DNS.",
      "ja": "HTTPクライアントがパフォーマンスの向上を実現するために、ホスト名ルックアップの結果をキャッシュする場合は、DNSによって報告されたTTL情報を守らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If HTTP clients do not observe this rule, they could be spoofed when a previously-accessed server's IP address changes. As network renumbering is expected to become increasingly common [24], the possibility of this form of attack will grow. Observing this requirement thus reduces this potential security vulnerability.",
      "ja": "HTTPクライアントがこのルールを守らない場合、彼らは時に以前にアクセスしたサーバのIPアドレスの変更を詐称することができます。ネットワークリナンバリングが[24]、ますます一般的になることが予想されるので、この形式の攻撃の可能性が大きくなります。この要件を観察するため、この潜在的なセキュリティ上の脆弱性を低減します。"
    },
    {
      "indent": 3,
      "text": "This requirement also improves the load-balancing behavior of clients for replicated servers using the same DNS name and reduces the likelihood of a user's experiencing failure in accessing sites which use that strategy.",
      "ja": "この要件は、同じDNS名を使用して複製サーバー用のクライアントのロードバランシングの動作を改善し、その戦略を使用してサイトにアクセスするには、ユーザーの経験故障の可能性を低減します。"
    },
    {
      "indent": 0,
      "text": "15.4 Location Headers and Spoofing",
      "section_title": true,
      "ja": "15.4場所ヘッダーおよびなりすまし"
    },
    {
      "indent": 3,
      "text": "If a single server supports multiple organizations that do not trust one another, then it MUST check the values of Location and Content-Location headers in responses that are generated under control of said organizations to make sure that they do not attempt to invalidate resources over which they have no authority.",
      "ja": "単一のサーバーが相互に信頼していない複数の組織をサポートしている場合、それは、彼らがその上のリソースを無効にしようとしないことを確認すると、組織の制御下で生成された応答における位置の値とContent-場所ヘッダをチェックしなければなりません彼らは何の権限を持っていません。"
    },
    {
      "indent": 0,
      "text": "15.5 Content-Disposition Issues",
      "section_title": true,
      "ja": "15.5コンテンツの処分問題"
    },
    {
      "indent": 3,
      "text": "RFC 1806 [35], from which the often implemented Content-Disposition (see section 19.5.1) header in HTTP is derived, has a number of very serious security considerations. Content-Disposition is not part of the HTTP standard, but since it is widely implemented, we are documenting its use and risks for implementors. See RFC 2183 [49] (which updates RFC 1806) for details.",
      "ja": "HTTPでしばしば実施コンテンツの廃棄（セクション19.5.1を参照）ヘッダが由来するRFC 1806 [35]は、非常に深刻なセキュリティ問題の数を有しています。コンテンツ配置はHTTP標準の一部ではありませんが、それは広く実装されているので、我々は、実装のためのその使用とリスクを文書化しています。詳細については、（RFC 1806に更新）[49] RFC 2183を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.6 Authentication Credentials and Idle Clients",
      "section_title": true,
      "ja": "15.6認証資格とアイドル状態のクライアント"
    },
    {
      "indent": 3,
      "text": "Existing HTTP clients and user agents typically retain authentication information indefinitely. HTTP/1.1. does not provide a method for a server to direct clients to discard these cached credentials. This is a significant defect that requires further extensions to HTTP. Circumstances under which credential caching can interfere with the application's security model include but are not limited to:",
      "ja": "既存のHTTPクライアントとユーザエージェントは、一般的に無期限に認証情報を保持します。 HTTP / 1.1。これらのキャッシュされた資格情報を破棄し、直接クライアントにサーバーのための方法を提供していません。これは、HTTPへのさらなる拡張が必要重要な欠陥です。資格情報のキャッシュは、アプリケーションのセキュリティモデルに干渉する可能性がある状況には、これらに限定されません："
    },
    {
      "indent": 6,
      "text": "- Clients which have been idle for an extended period following which the server might wish to cause the client to reprompt the user for credentials.",
      "ja": " - サーバは、クライアントが資格情報をユーザーに求めるプロンプトは表示させたいかもしれない次の拡張期間アイドル状態になっているクライアント。"
    },
    {
      "indent": 6,
      "text": "- Applications which include a session termination indication (such as a `logout' or `commit' button on a page) after which the server side of the application `knows' that there is no further reason for the client to retain the credentials.",
      "ja": " - アプリケーションの `のサーバ側は、クライアントが認証情報を保持するためのさらなる理由がないことを知っているの後に（例えば`ログアウト「や `コミット」のページ上のボタンなど）セッション終了表示を含むアプリケーション。"
    },
    {
      "indent": 3,
      "text": "This is currently under separate study. There are a number of work-arounds to parts of this problem, and we encourage the use of password protection in screen savers, idle time-outs, and other methods which mitigate the security problems inherent in this problem. In particular, user agents which cache credentials are encouraged to provide a readily accessible mechanism for discarding cached credentials under user control.",
      "ja": "これは、別の研究中です。そこ回避策の数は、この問題の部分にあり、我々はスクリーンセーバー、アイドルタイムアウト、およびこの問題に固有のセキュリティ上の問題を軽減する他の方法でパスワード保護を使用することを奨励します。具体的には、資格情報をキャッシュするユーザエージェントは、ユーザの管理下にキャッシュされた資格情報を破棄するために容易にアクセスできる仕組みを提供することが奨励されています。"
    },
    {
      "indent": 0,
      "text": "15.7 Proxies and Caching",
      "section_title": true,
      "ja": "15.7プロキシとキャッシング"
    },
    {
      "indent": 3,
      "text": "By their very nature, HTTP proxies are men-in-the-middle, and represent an opportunity for man-in-the-middle attacks. Compromise of the systems on which the proxies run can result in serious security and privacy problems. Proxies have access to security-related information, personal information about individual users and organizations, and proprietary information belonging to users and content providers. A compromised proxy, or a proxy implemented or configured without regard to security and privacy considerations, might be used in the commission of a wide range of potential attacks.",
      "ja": "その性質上、HTTPプロキシは、男性・イン・ザ・ミドルであり、man-in-the-middle攻撃の機会を表しています。システムの妥協は、どのプロキシの実行は、深刻なセキュリティとプライバシーの問題をもたらす可能性があります。プロキシは、セキュリティ関連の情報、個々のユーザーや組織、およびユーザーやコンテンツプロバイダに属する専有情報について、個人情報へのアクセス権を持っています。妥協プロキシ、またはセキュリティやプライバシーの配慮に関係なく実装または設定されたプロキシは、潜在的な攻撃の広い範囲の手数料で使用される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Proxy operators should protect the systems on which proxies run as they would protect any system that contains or transports sensitive information. In particular, log information gathered at proxies often contains highly sensitive personal information, and/or information about organizations. Log information should be carefully guarded, and appropriate guidelines for use developed and followed. (Section 15.1.1).",
      "ja": "プロキシ事業者は、彼らが含まれている情報や機密情報を輸送する任意のシステムを保護するようプロキシが実行されているシステムを保護する必要があります。具体的には、プロキシで収集した情報は、多くの場合、機密性の高い個人情報が含まれている、および/または組織に関する情報ログ。ログ情報は、慎重に守られるべき、との使用のために適切なガイドラインが開発され、続きます。 （15.1.1項）。"
    },
    {
      "indent": 3,
      "text": "Caching proxies provide additional potential vulnerabilities, since the contents of the cache represent an attractive target for malicious exploitation. Because cache contents persist after an HTTP request is complete, an attack on the cache can reveal information long after a user believes that the information has been removed from the network. Therefore, cache contents should be protected as sensitive information.",
      "ja": "キャッシュの内容が悪質な搾取のための魅力的な標的を表すため、キャッシュプロキシは、追加の潜在的な脆弱性を提供します。 HTTPリクエストが完了した後でキャッシュの内容が持続するので、キャッシュへの攻撃は、ユーザーが情報をネットワークから削除されたことを信じてずっと後に情報を明らかにすることができます。そのため、キャッシュの内容は、機密情報として保護しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Proxy implementors should consider the privacy and security implications of their design and coding decisions, and of the configuration options they provide to proxy operators (especially the default configuration).",
      "ja": "プロキシの実装は、その設計やコーディングの意思決定のプライバシーとセキュリティの影響を考慮すべきである、と設定オプションの彼らは、代理事業者（特にデフォルトの設定）に提供しています。"
    },
    {
      "indent": 3,
      "text": "Users of a proxy need to be aware that they are no trustworthier than the people who run the proxy; HTTP itself cannot solve this problem.",
      "ja": "プロキシのユーザーは、プロキシを実行する人よりもtrustworthierされないことに注意する必要があります。 HTTP自体は、この問題を解決することはできません。"
    },
    {
      "indent": 3,
      "text": "The judicious use of cryptography, when appropriate, may suffice to protect against a broad range of security and privacy attacks. Such cryptography is beyond the scope of the HTTP/1.1 specification.",
      "ja": "暗号の賢明な使用は、適切な場合、セキュリティとプライバシー広範囲の攻撃から保護するために十分です。このような暗号は、HTTP / 1.1仕様の範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "15.7.1 Denial of Service Attacks on Proxies",
      "section_title": true,
      "ja": "プロキシ上のサービス攻撃の拒否15.7.1"
    },
    {
      "indent": 3,
      "text": "They exist. They are hard to defend against. Research continues. Beware.",
      "ja": "彼らは存在します。彼らは身を守るのは難しいです。研究は継続されます。注意してください。"
    },
    {
      "indent": 0,
      "text": "16 Acknowledgments",
      "ja": "16の謝辞"
    },
    {
      "indent": 3,
      "text": "This specification makes heavy use of the augmented BNF and generic constructs defined by David H. Crocker for RFC 822 [9]. Similarly, it reuses many of the definitions provided by Nathaniel Borenstein and Ned Freed for MIME [7]. We hope that their inclusion in this specification will help reduce past confusion over the relationship between HTTP and Internet mail message formats.",
      "ja": "この仕様はRFC 822のためのデビッド・H.クロッカーによって定義され、拡張BNFを多用し、一般的な構造を作る[9]。同様に、MIME [7]のためのナサニエル・ボレンスタインとネッドフリードによって提供される定義の多くを再利用します。私たちは、この仕様での包含はHTTPとインターネットメールメッセージ形式の関係上、過去の混乱を減らすのに役立つことを願っています。"
    },
    {
      "indent": 3,
      "text": "The HTTP protocol has evolved considerably over the years. It has benefited from a large and active developer community--the many people who have participated on the www-talk mailing list--and it is that community which has been most responsible for the success of HTTP and of the World-Wide Web in general. Marc Andreessen, Robert Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc VanHeyningen deserve special recognition for their efforts in defining early aspects of the protocol.",
      "ja": "HTTPプロトコルでは、年間で大幅に進化してきました。 WWWトークメーリングリストに参加した多くの人々 -   - それは、大規模かつ活発な開発者コミュニティの恩恵を受けており、それがでHTTPのワールド・ワイド・ウェブの成功のために最も責任のコミュニティとなっていたということです一般的。マーク・アンドリーセン、ロバート・カイリュー、ダニエル・W・コノリー、ボブ・デニー、ジョン・フランクス、ジャン=フランソワ・Groffの、フィリップM.ハラム - ベイカー、ホーコンW.リー、アリ・ルオトナン、ロブ・マックール、ルー・モントゥリ、デイブ・ラゲット、トニー・サンダース、およびマルク・VanHeyningenは、プロトコルの初期の側面を定義する際に彼らの努力のための特別な認識に値します。"
    },
    {
      "indent": 3,
      "text": "This document has benefited greatly from the comments of all those participating in the HTTP-WG. In addition to those already mentioned, the following individuals have contributed to this specification:",
      "ja": "このドキュメントでは、HTTP-WGに参加するすべての者のコメントから大きな恩恵を受けています。すでに述べたものに加えて、以下の個人はこの仕様に貢献しています："
    },
    {
      "indent": 7,
      "text": "Gary Adams                  Ross Patterson\nHarald Tveit Alvestrand     Albert Lunde\nKeith Ball                  John C. Mallery\nBrian Behlendorf            Jean-Philippe Martin-Flatin\nPaul Burchard               Mitra\nMaurizio Codogno            David Morris\nMike Cowlishaw              Gavin Nicol\nRoman Czyborra              Bill Perry\nMichael A. Dolan            Jeffrey Perry\nDavid J. Fiander            Scott Powers\nAlan Freier                 Owen Rees\nMarc Hedlund                Luigi Rizzo\nGreg Herlihy                David Robinson\nKoen Holtman                Marc Salomon\nAlex Hopmann                Rich Salz\nBob Jernigan                Allan M. Schiffman\nShel Kaphan                 Jim Seidman\nRohit Khare                 Chuck Shotton\nJohn Klensin                Eric W. Sink\nMartijn Koster              Simon E. Spero\nAlexei Kosut                Richard N. Taylor\nDavid M. Kristol            Robert S. Thau\nDaniel LaLiberte            Bill (BearHeart) Weinman\nBen Laurie                  Francois Yergeau\nPaul J. Leach               Mary Ellen Zurko\nDaniel DuBois               Josh Cohen",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Much of the content and presentation of the caching design is due to suggestions and comments from individuals including: Shel Kaphan, Paul Leach, Koen Holtman, David Morris, and Larry Masinter.",
      "ja": "SHEL Kaphan、ポールリーチ、公園Holtman、デビッド・モリス、およびラリーMasinter：キャッシュ設計の内容とプレゼンテーションの多くは、以下を含む個人からの提案やコメントによるものです。"
    },
    {
      "indent": 3,
      "text": "Most of the specification of ranges is based on work originally done by Ari Luotonen and John Franks, with additional input from Steve Zilles.",
      "ja": "範囲の仕様のほとんどは、もともとスティーブZillesからの追加入力で、アリ・ルオトナンとジョン・フランクスによって行われた作業に基づいています。"
    },
    {
      "indent": 3,
      "text": "Thanks to the \"cave men\" of Palo Alto. You know who you are.",
      "ja": "パロアルトの「洞窟の男性」に感謝します。あなたはあなたが誰であるか知っています。"
    },
    {
      "indent": 3,
      "text": "Jim Gettys (the current editor of this document) wishes particularly to thank Roy Fielding, the previous editor of this document, along with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and Larry Masinter for their help. And thanks go particularly to Jeff Mogul and Scott Lawrence for performing the \"MUST/MAY/SHOULD\" audit.",
      "ja": "ジム・ゲティーズ（このドキュメントの現在のエディタ）は、特にジョン・クレンシン、ジェフムガール人、ポール・リーチ、デイブ・クリストル、公園Holtman、ジョン・フランクス、ジョシュ・コーエン、アレックスHopmannとともに、ロイ・フィールディング、この文書の前の編集者に感謝したいです、彼らの助けのためのスコット・ローレンス、およびラリーMasinter。そして、おかげで「MUST / MAY / SHOULD」監査を行うために、特にジェフムガール人とスコット・ローレンスに行きます。"
    },
    {
      "indent": 3,
      "text": "The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik Frystyk implemented RFC 2068 early, and we wish to thank them for the discovery of many of the problems that this document attempts to rectify.",
      "ja": "Apacheグループ、アンセルムベアード・スミス、ジグソーパズルの著者、とヘンリクFrystykは早期RFC 2068を実装し、そして私たちは、この文書が是正しようとする問題の多くの発見のためにそれらに感謝したいです。"
    },
    {
      "indent": 0,
      "text": "17 References",
      "ja": "17の参考文献"
    },
    {
      "indent": 3,
      "text": "[1] Alvestrand, H., \"Tags for the Identification of Languages\", RFC 1766, March 1995.",
      "ja": "[1] Alvestrand、H.、 \"言語識別のためのタグ\"、RFC 1766、1995年3月。"
    },
    {
      "indent": 3,
      "text": "[2] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey, D. and B. Alberti, \"The Internet Gopher Protocol (a distributed document search and retrieval protocol)\", RFC 1436, March 1993.",
      "ja": "[2] Anklesaria、F.、McCahill、M.、リンドナー、P.、ジョンソン、D.、トーリー、D.およびB.アルベルティ、 \"インターネットゴーファープロトコル（分散文書検索及び検索プロトコル）\"、RFC 1436 、1993年3月。"
    },
    {
      "indent": 3,
      "text": "[3] Berners-Lee, T., \"Universal Resource Identifiers in WWW\", RFC 1630, June 1994.",
      "ja": "[3]バーナーズ=リー、T.、 \"WWWにおけるユニバーサルリソース識別子\"、RFC 1630、1994年6月。"
    },
    {
      "indent": 3,
      "text": "[4] Berners-Lee, T., Masinter, L. and M. McCahill, \"Uniform Resource Locators (URL)\", RFC 1738, December 1994.",
      "ja": "[4]バーナーズ=リー、T.、Masinter、LとM. McCahill、 \"ユニフォームリソースロケータ（URL）\"、RFC 1738、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[5] Berners-Lee, T. and D. Connolly, \"Hypertext Markup Language - 2.0\", RFC 1866, November 1995.",
      "ja": "[5]バーナーズ=リー、T.、およびD.コノリー、 \"ハイパーテキストマークアップ言語 -  2.0\"、RFC 1866、1995年11月。"
    },
    {
      "indent": 3,
      "text": "[6] Berners-Lee, T., Fielding, R. and H. Frystyk, \"Hypertext Transfer Protocol -- HTTP/1.0\", RFC 1945, May 1996.",
      "ja": "[6]バーナーズ=リー、T.、フィールディング、R.、およびH. Frystyk、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.0\"、RFC 1945、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[7] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", RFC 2045, November 1996.",
      "ja": "[7]フリード、N.とN. Borenstein、 \"マルチパーパスインターネットメールエクステンション（MIME）第一部：インターネットメッセージ本体のフォーマット\"、RFC 2045、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[8] Braden, R., \"Requirements for Internet Hosts -- Communication Layers\", STD 3, RFC 1123, October 1989.",
      "ja": "[8]ブレーデン、R.、 \"インターネットホストのための要件 - 通信層\"、STD 3、RFC 1123、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[9] Crocker, D., \"Standard for The Format of ARPA Internet Text Messages\", STD 11, RFC 822, August 1982.",
      "ja": "[9]クロッカー、D.、 \"ARPAインターネットテキストメッセージの形式の規格\"、STD 11、RFC 822、1982年8月。"
    },
    {
      "indent": 3,
      "text": "[10] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R., Sui, J., and M. Grinbaum, \"WAIS Interface Protocol Prototype Functional Specification,\" (v1.5), Thinking Machines Corporation, April 1990.",
      "ja": "[10]デイビス、F.、カーレ、B.、モリス、H.、セーラム、J.、シェン、T.、王、R.、隋、J.、およびM. Grinbaum、「WAISインタフェースプロトコルプロトタイプ機能仕様、」（V1.5）、Machines社、1990年4月を考えます。"
    },
    {
      "indent": 3,
      "text": "[11] Fielding, R., \"Relative Uniform Resource Locators\", RFC 1808, June 1995.",
      "ja": "[11]フィールディング、R.、 \"相対的なユニフォームリソースロケータ\"、RFC 1808、1995年6月。"
    },
    {
      "indent": 3,
      "text": "[12] Horton, M. and R. Adams, \"Standard for Interchange of USENET Messages\", RFC 1036, December 1987.",
      "ja": "[12]ホートン、M.およびR.アダムス、 \"USENETメッセージの交換のための標準的な\"、RFC 1036、1987年12月。"
    },
    {
      "indent": 3,
      "text": "[13] Kantor, B. and P. Lapsley, \"Network News Transfer Protocol\", RFC 977, February 1986.",
      "ja": "[13]カンター、B.およびP.ラプスリー、 \"ネットワークニュース転送プロトコル\"、RFC 977、1986年2月。"
    },
    {
      "indent": 3,
      "text": "[14] Moore, K., \"MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text\", RFC 2047, November 1996.",
      "ja": "[14]ムーア、K.、 \"MIME（多目的インターネットメール拡張）パート3：非ASCIIテキストのためのメッセージヘッダの拡張\"、RFC 2047、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[15] Nebel, E. and L. Masinter, \"Form-based File Upload in HTML\", RFC 1867, November 1995.",
      "ja": "[15]ネーベル、E.およびL. Masinter、 \"HTMLでフォームベースのファイルアップロード\"、RFC 1867、1995年11月。"
    },
    {
      "indent": 3,
      "text": "[16] Postel, J., \"Simple Mail Transfer Protocol\", STD 10, RFC 821, August 1982.",
      "ja": "[16]ポステル、J.、 \"簡易メール転送プロトコル\"、STD 10、RFC 821、1982年8月。"
    },
    {
      "indent": 3,
      "text": "[17] Postel, J., \"Media Type Registration Procedure\", RFC 1590, November 1996.",
      "ja": "[17]ポステル、J.、 \"メディアタイプの登録手順\"、RFC 1590、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[18] Postel, J. and J. Reynolds, \"File Transfer Protocol\", STD 9, RFC 959, October 1985.",
      "ja": "[18]ポステル、J.、およびJ.レイノルズ、 \"ファイル転送プロトコル\"、STD 9、RFC 959、1985年10月。"
    },
    {
      "indent": 3,
      "text": "[19] Reynolds, J. and J. Postel, \"Assigned Numbers\", STD 2, RFC 1700, October 1994.",
      "ja": "[19]レイノルズ、J.およびJ.ポステル、 \"割り当て番号\"、STD 2、RFC 1700、1994年10月。"
    },
    {
      "indent": 3,
      "text": "[20] Sollins, K. and L. Masinter, \"Functional Requirements for Uniform Resource Names\", RFC 1737, December 1994.",
      "ja": "[20] Sollins、K.とL. Masinter、 \"統一リソース名のための機能要件\"、RFC 1737、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[21] US-ASCII. Coded Character Set - 7-Bit American Standard Code for Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.",
      "ja": "[21] US-ASCII。コード化文字セット - 情報交換のための7ビットの米国標準コード。標準ANSI X3.4-1986、ANSI、1986。"
    },
    {
      "indent": 3,
      "text": "[22] ISO-8859. International Standard -- Information Processing -- 8-bit Single-Byte Coded Graphic Character Sets -- Part 1: Latin alphabet No. 1, ISO-8859-1:1987. Part 2: Latin alphabet No. 2, ISO-8859-2, 1987. Part 3: Latin alphabet No. 3, ISO-8859-3, 1988. Part 4: Latin alphabet No. 4, ISO-8859-4, 1988. Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988. Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987. Part 7: Latin/Greek alphabet, ISO-8859-7, 1987. Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988. Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.",
      "ja": "[22] ISO-8859。国際規格 - 情報処理 -  8ビット・シングルバイト・コード化図形文字セット - パート1：ラテンアルファベット1号、ISO-8859-1：1987。パート2：ラテンアルファベット番号2、ISO-8859-2、1987パート3：ラテンアルファベット3号、ISO-8859-3、1988パート4：ラテンアルファベット番号4、ISO-8859-4、1988その5：ラテン/キリル文字、ISO-8859-5、1988パート6：ラテン/アラビア文字、ISO-8859-6、1987パート7：ラテン/ギリシャ語のアルファベット、ISO-8859-7、1987年パート8：ラテン/ヘブライ語のアルファベット、ISO-8859-8、1988年パート9：ラテンアルファベット5号、ISO-8859-9、1990。"
    },
    {
      "indent": 3,
      "text": "[23] Meyers, J. and M. Rose, \"The Content-MD5 Header Field\", RFC 1864, October 1995.",
      "ja": "[23]マイヤーズ、J.とM.ローズ、 \"コンテンツ-MD5ヘッダーフィールド\"、RFC 1864、1995年10月。"
    },
    {
      "indent": 3,
      "text": "[24] Carpenter, B. and Y. Rekhter, \"Renumbering Needs Work\", RFC 1900, February 1996.",
      "ja": "[24]大工、B.およびY. Rekhter、 \"リナンバリングは作業が必要\"、RFC 1900、1996年2月。"
    },
    {
      "indent": 3,
      "text": "[25] Deutsch, P., \"GZIP file format specification version 4.3\", RFC 1952, May 1996.",
      "ja": "[25]ドイツ、P.、 \"GZIPファイル形式の仕様バージョン4.3\"、RFC 1952、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[26] Venkata N. Padmanabhan, and Jeffrey C. Mogul. \"Improving HTTP Latency\", Computer Networks and ISDN Systems, v. 28, pp. 25-35, Dec. 1995. Slightly revised version of paper in Proc. 2nd International WWW Conference '94: Mosaic and the Web, Oct. 1994, which is available at http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat ency.html.",
      "ja": "[26]ヴェンカタN. Padmanabhan、およびジェフリーC.モーグル。 、コンピュータネットワークとISDNシステム、V。28頁。25-35「HTTPレイテンシの改善」、12月1995年は少しPROCで紙のバージョンを改訂します。第2回国際WWW会議'94：モザイクとhttp://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat ency.htmlで利用できるウェブ、1994年10月、。"
    },
    {
      "indent": 3,
      "text": "[27] Joe Touch, John Heidemann, and Katia Obraczka. \"Analysis of HTTP Performance\", <URL: http://www.isi.edu/touch/pubs/http-perf96/>, ISI Research Report ISI/RR-98-463, (original report dated Aug. 1996), USC/Information Sciences Institute, August 1998.",
      "ja": "[27]ジョー・タッチ、ジョンHeidemann、およびカティアObraczka。 \"HTTPパフォーマンスの分析\"、<URL：http://www.isi.edu/touch/pubs/http-perf96/>、ISI研究報告ISI / RR-98から463、（1996年8月日付で元のレポート）、 USC /情報科学研究所、1998年8月。"
    },
    {
      "indent": 3,
      "text": "[28] Mills, D., \"Network Time Protocol (Version 3) Specification, Implementation and Analysis\", RFC 1305, March 1992.",
      "ja": "[28]ミルズ、D.、 \"ネットワーク時間プロトコル（バージョン3）仕様、実装と分析\"、RFC 1305、1992年3月。"
    },
    {
      "indent": 3,
      "text": "[29] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3\", RFC 1951, May 1996.",
      "ja": "[29]ドイツ、P.、 \"DEFLATE圧縮データフォーマット仕様バージョン1.3\"、RFC 1951、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[30] S. Spero, \"Analysis of HTTP Performance Problems,\" http://sunsite.unc.edu/mdma-release/http-prob.html.",
      "ja": "[30] S.スペロ、 \"HTTPパフォーマンスの問題の分析、\" http://sunsite.unc.edu/mdma-release/http-prob.html。"
    },
    {
      "indent": 3,
      "text": "[31] Deutsch, P. and J. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, May 1996.",
      "ja": "[31]ドイツ、P。及びJ. Gailly氏、 \"ZLIB圧縮データフォーマット仕様バージョン3.3\"、RFC 1950、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[32] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P., Luotonen, A., Sink, E. and L. Stewart, \"An Extension to HTTP: Digest Access Authentication\", RFC 2069, January 1997.",
      "ja": "[32]フランクス、J.、ハラム・ベイカー、P.、Hostetler、J.、リーチ、P.、Luotonen、A.、シンク、E.およびL.スチュワート、 \"HTTPへの拡張：ダイジェストアクセス認証\"、 RFC 2069、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[33] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2068, January 1997.",
      "ja": "[33]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\"、RFC 2068、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[34] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[34]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[35] Troost, R. and Dorner, S., \"Communicating Presentation Information in Internet Messages: The Content-Disposition Header\", RFC 1806, June 1995.",
      "ja": "[35] Troost、R.とドルナー、S.、 \"インターネット・メッセージでプレゼンテーション情報を伝える：のContent-Dispositionヘッダー\"、RFC 1806、1995年6月。"
    },
    {
      "indent": 3,
      "text": "[36] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, \"Use and Interpretation of HTTP Version Numbers\", RFC 2145, May 1997. [jg639]",
      "ja": "[36]モーグル、J.、フィールディング、R.、ゲティス、J.及びH. Frystyk、 \"使用とHTTPバージョン番号の解釈\"、RFC 2145、1997年5月[jg639]"
    },
    {
      "indent": 3,
      "text": "[37] Palme, J., \"Common Internet Message Headers\", RFC 2076, February 1997. [jg640]",
      "ja": "[37]パルメ、J.、 \"一般的なインターネットメッセージヘッダ\"、RFC 2076、1997年2月[jg640]"
    },
    {
      "indent": 3,
      "text": "[38] Yergeau, F., \"UTF-8, a transformation format of Unicode and ISO-10646\", RFC 2279, January 1998. [jg641]",
      "ja": "[38] Yergeau、F.、 \"UTF-8、UnicodeとISO-10646の変換フォーマット\"、RFC 2279、1998年1月[jg641]"
    },
    {
      "indent": 3,
      "text": "[39] Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud'hommeaux, E., Lie, H., and C. Lilley. \"Network Performance Effects of HTTP/1.1, CSS1, and PNG,\" Proceedings of ACM SIGCOMM '97, Cannes France, September 1997.[jg642]",
      "ja": "[39]ニールセン、H。F.、ゲティス、J.、ベアード - スミス、A.、Prud'hommeaux、E.、リー、H.、およびC.リリー。 \"HTTP / 1.1、CSS1、およびPNGのネットワークパフォーマンスの影響、\" ACMのSIGCOMM '97の議事録、カンヌ、フランス、1997年9月[jg642]"
    },
    {
      "indent": 3,
      "text": "[40] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types\", RFC 2046, November 1996. [jg643]",
      "ja": "[40]解放され、N.とN. Borenstein、 \"マルチパーパスインターネットメールエクステンション（MIME）パート2：メディアタイプ\"、RFC 2046、1996年11月[jg643]"
    },
    {
      "indent": 3,
      "text": "[41] Alvestrand, H., \"IETF Policy on Character Sets and Languages\", BCP 18, RFC 2277, January 1998. [jg644]",
      "ja": "[41] Alvestrand、H.、 \"文字セットと言語のIETF方針\"、BCP 18、RFC 2277、1998年1月[jg644]"
    },
    {
      "indent": 3,
      "text": "[42] Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform Resource Identifiers (URI): Generic Syntax and Semantics\", RFC 2396, August 1998. [jg645]",
      "ja": "[42]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：一般的な構文及びセマンティクス\"、RFC 2396、1998年8月[jg645]"
    },
    {
      "indent": 3,
      "text": "[43] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., Sink, E. and L. Stewart, \"HTTP Authentication: Basic and Digest Access Authentication\", RFC 2617, June 1999. [jg646]",
      "ja": "[43]フランクス、J.、ハラム・ベイカー、P.、Hostetler、J.、ローレンス、S.、リーチ、P.、Luotonen、A.、シンク、E.およびL.スチュワート、「HTTP認証：基本とダイジェストアクセス認証」、RFC 2617、1999年6月[jg646]"
    },
    {
      "indent": 3,
      "text": "[44] Luotonen, A., \"Tunneling TCP based protocols through Web proxy servers,\" Work in Progress. [jg647]",
      "ja": "進行中[44] Luotonen、A.、 \"Webプロキシサーバー経由でトンネリングTCPベースのプロトコル、\" ワーク。 [jg647]"
    },
    {
      "indent": 3,
      "text": "[45] Palme, J. and A. Hopmann, \"MIME E-mail Encapsulation of Aggregate Documents, such as HTML (MHTML)\", RFC 2110, March 1997.",
      "ja": "[45]パルメ、J.及びA. Hopmann、RFC 2110、1997年3月 \"は、HTML（MHTML）として集約文書のMIME電子メールカプセル化\"。"
    },
    {
      "indent": 3,
      "text": "[46] Bradner, S., \"The Internet Standards Process -- Revision 3\", BCP 9, RFC 2026, October 1996.",
      "ja": "[46]ブラドナーの、S.、 \"インターネット標準化プロセス - リビジョン3\"、BCP 9、RFC 2026、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[47] Masinter, L., \"Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)\", RFC 2324, 1 April 1998.",
      "ja": "[47] Masinter、L.、 \"ハイパーテキストコーヒーポット制御プロトコル（HTCPCP / 1.0）\"、RFC 2324、1998年4月1日。"
    },
    {
      "indent": 3,
      "text": "[48] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples\", RFC 2049, November 1996.",
      "ja": "[48]フリード、N.とN. Borenstein、 \"マルチパーパスインターネットメールエクステンション（MIME）パート5：適合基準と例\"、RFC 2049、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[49] Troost, R., Dorner, S. and K. Moore, \"Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field\", RFC 2183, August 1997.",
      "ja": "[49] Troost、R.、ドルナー、S.とK.ムーア、 \"インターネット・メッセージでプレゼンテーション情報を伝える：コンテンツ-Dispositionヘッダーフィールド\"、RFC 2183、1997年8月。"
    },
    {
      "indent": 0,
      "text": "18 Authors' Addresses",
      "ja": "18本の著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Roy T. Fielding Information and Computer Science University of California, Irvine Irvine, CA 92697-3425, USA",
      "ja": "ロイT.フィールディング情報とカリフォルニアのコンピュータサイエンス大学、アーヴァイン、CA 92697-3425、USA"
    },
    {
      "indent": 3,
      "text": "Fax: +1 (949) 824-1715 EMail: fielding@ics.uci.edu",
      "ja": "ファックス：+1（949）824-1715 Eメール：fielding@ics.uci.edu"
    },
    {
      "indent": 3,
      "text": "James Gettys World Wide Web Consortium MIT Laboratory for Computer Science 545 Technology Square Cambridge, MA 02139, USA",
      "ja": "コンピュータサイエンス545技術正方形のケンブリッジ、MA 02139、USAジェームスゲティスワールド・ワイド・ウェブ・コンソーシアムMIT研究所"
    },
    {
      "indent": 3,
      "text": "Fax: +1 (617) 258 8682 EMail: jg@w3.org",
      "ja": "ファックス：+1（617）258 8682 Eメール：jg@w3.org"
    },
    {
      "indent": 3,
      "text": "Jeffrey C. Mogul Western Research Laboratory Compaq Computer Corporation 250 University Avenue Palo Alto, California, 94305, USA",
      "ja": "ジェフリーC.モーグル西研究所コンパックコンピュータ株式会社250大学アベニューパロアルト、カリフォルニア、94305、USA"
    },
    {
      "indent": 3,
      "text": "EMail: mogul@wrl.dec.com",
      "ja": "メールアドレス：mogul@wrl.dec.com"
    },
    {
      "indent": 3,
      "text": "Henrik Frystyk Nielsen World Wide Web Consortium MIT Laboratory for Computer Science 545 Technology Square Cambridge, MA 02139, USA",
      "ja": "ヘンリック・フリスティック・ニールセンのWorld Wide Web ConsortiumのMITコンピュータサイエンス研究所545テクノロジー・スクエアケンブリッジ、MA 02139、USAについて"
    },
    {
      "indent": 3,
      "text": "Fax: +1 (617) 258 8682 EMail: frystyk@w3.org",
      "ja": "ファックス：+1（617）258 8682 Eメール：frystyk@w3.org"
    },
    {
      "indent": 3,
      "text": "Larry Masinter Xerox Corporation 3333 Coyote Hill Road Palo Alto, CA 94034, USA",
      "ja": "ラリーMasinterゼロックス・コーポレーション3333コヨーテヒルロードパロアルト、CA 94034、USA"
    },
    {
      "indent": 3,
      "text": "EMail: masinter@parc.xerox.com",
      "ja": "メールアドレス：masinter@parc.xerox.com"
    },
    {
      "indent": 3,
      "text": "Paul J. Leach Microsoft Corporation 1 Microsoft Way Redmond, WA 98052, USA",
      "ja": "ポール・J.リーチマイクロソフト社1マイクロソフト道レドモンド、WA 98052、USA"
    },
    {
      "indent": 3,
      "text": "EMail: paulle@microsoft.com",
      "ja": "メールアドレス：paulle@microsoft.com"
    },
    {
      "indent": 3,
      "text": "Tim Berners-Lee Director, World Wide Web Consortium MIT Laboratory for Computer Science 545 Technology Square Cambridge, MA 02139, USA",
      "ja": "ティム・バーナーズ=リー・ディレクター、コンピュータサイエンス545技術正方形のケンブリッジ、MA 02139、USAのためのWorld Wide Web ConsortiumのMIT研究所"
    },
    {
      "indent": 3,
      "text": "Fax: +1 (617) 258 8682 EMail: timbl@w3.org",
      "ja": "ファックス：+1（617）258 8682 Eメール：timbl@w3.org"
    },
    {
      "indent": 0,
      "text": "19 Appendices",
      "ja": "19本の付録"
    },
    {
      "indent": 0,
      "text": "19.1 Internet Media Type message/http and application/http",
      "section_title": true,
      "ja": "19.1インターネットメディアタイプのメッセージ/ httpおよびアプリケーション/ HTTP"
    },
    {
      "indent": 3,
      "text": "In addition to defining the HTTP/1.1 protocol, this document serves as the specification for the Internet media type \"message/http\" and \"application/http\". The message/http type can be used to enclose a single HTTP request or response message, provided that it obeys the MIME restrictions for all \"message\" types regarding line length and encodings. The application/http type can be used to enclose a pipeline of one or more HTTP request or response messages (not intermixed). The following is to be registered with IANA [17].",
      "ja": "HTTP / 1.1プロトコルを定義することに加えて、この文書は、インターネットメディアタイプ「メッセージ/ HTTP」および「アプリケーション/ HTTP」の仕様として機能します。メッセージ/ HTTPタイプは、それが行の長さ及び符号化に関するすべての「メッセージ」タイプのMIMEの制限に従うことを条件とする、単一のHTTP要求または応答メッセージを囲むために使用することができます。アプリケーション/ HTTPタイプは、1つ以上のHTTP要求または応答メッセージのパイプラインを囲むために使用することができる（混合しません）。以下は、IANA [17]に登録します。"
    },
    {
      "indent": 7,
      "text": "Media Type name:         message\nMedia subtype name:      http\nRequired parameters:     none\nOptional parameters:     version, msgtype\n version: The HTTP-Version number of the enclosed message\n          (e.g., \"1.1\"). If not present, the version can be\n          determined from the first line of the body.\n msgtype: The message type -- \"request\" or \"response\". If not\n          present, the type can be determined from the first\n          line of the body.\nEncoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n                         permitted\nSecurity considerations: none",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Media Type name: application Media subtype name: http Required parameters: none Optional parameters: version, msgtype version: The HTTP-Version number of the enclosed messages (e.g., \"1.1\"). If not present, the version can be determined from the first line of the body. msgtype: The message type -- \"request\" or \"response\". If not present, the type can be determined from the first line of the body. Encoding considerations: HTTP messages enclosed by this type are in \"binary\" format; use of an appropriate Content-Transfer-Encoding is required when transmitted via E-mail. Security considerations: none",
      "ja": "メディアタイプ名：アプリケーションメディアサブタイプ名：HTTP必須パラメータ：なしオプションのパラメータ：バージョン、MSGTYPEバージョン：同封のメッセージのHTTP-バージョン番号（例えば、「1.1」）。存在しない場合、バージョンは、本体の最初の行から決定することができます。 MSGTYPE：メッセージタイプ - 「要求」または「応答」。存在しない場合は、タイプは、本体の最初の行から決定することができます。エンコードの考慮事項：このタイプで囲まれたHTTPメッセージは、「バイナリ」形式になっています。 Eメールを介して送信時に適切なコンテンツ転送エンコードの使用が必要とされます。セキュリティの考慮事項：なし"
    },
    {
      "indent": 0,
      "text": "19.2 Internet Media Type multipart/byteranges",
      "section_title": true,
      "ja": "19.2インターネットメディアタイプマルチパート/ byteranges"
    },
    {
      "indent": 3,
      "text": "When an HTTP 206 (Partial Content) response message includes the content of multiple ranges (a response to a request for multiple non-overlapping ranges), these are transmitted as a multipart message-body. The media type for this purpose is called \"multipart/byteranges\".",
      "ja": "HTTP 206（部分コンテンツ）応答メッセージが複数の範囲（複数の非重複範囲要求に対する応答）の内容を含む場合、これらはマルチパートメッセージボディとして送信されます。この目的のためにメディアタイプは「マルチパート/ byteranges」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "The multipart/byteranges media type includes two or more parts, each with its own Content-Type and Content-Range fields. The required boundary parameter specifies the boundary string used to separate each body-part.",
      "ja": "マルチパートは/メディアタイプは、独自のContent-TypeとContent-レンジフィールドを持つ2つ以上の部品、それぞれが含まれてbyteranges。必要な境界パラメータは、各身体部分を分離するために使用された境界文字列を指定します。"
    },
    {
      "indent": 7,
      "text": "Media Type name:         multipart\nMedia subtype name:      byteranges\nRequired parameters:     boundary\nOptional parameters:     none\nEncoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n                         permitted\nSecurity considerations: none",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 206 Partial Content Date: Wed, 15 Nov 1995 06:25:24 GMT Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES",
      "ja": "HTTP / 1.1 206部分コンテンツ日：水曜日、1995年11月15日午前6時25分24秒GMTのLast-Modified：水曜日、1995年11月15日午前4時58分08秒GMTのコンテンツタイプ：マルチパート/ byteranges。境界= THIS_STRING_SEPARATES"
    },
    {
      "indent": 3,
      "text": "--THIS_STRING_SEPARATES Content-type: application/pdf Content-range: bytes 500-999/8000",
      "ja": "アプリケーション/ PDFコンテンツ-範囲：500-999 / 8000バイトのContent-typeが--THIS_STRING_SEPARATES"
    },
    {
      "indent": 3,
      "text": "...the first range... --THIS_STRING_SEPARATES Content-type: application/pdf Content-range: bytes 7000-7999/8000",
      "ja": "アプリケーション/ PDFコンテンツ-範囲：...最初の範囲...には、Content-typeを--THIS_STRING_SEPARATESバイト7000から7999/8000"
    },
    {
      "indent": 3,
      "text": "...the second range --THIS_STRING_SEPARATES--",
      "ja": "... 2番目の範囲--THIS_STRING_SEPARATES--"
    },
    {
      "indent": 6,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 6,
      "text": "1) Additional CRLFs may precede the first boundary string in the entity.",
      "ja": "1）追加のCRLFは、エンティティの最初の境界文字列の前にあります。"
    },
    {
      "indent": 6,
      "text": "2) Although RFC 2046 [40] permits the boundary string to be quoted, some existing implementations handle a quoted boundary string incorrectly.",
      "ja": "2）RFC 2046 [40]は、境界文字列は引用することを可能にするが、いくつかの既存の実装が誤って引用された境界文字列を扱います。"
    },
    {
      "indent": 6,
      "text": "3) A number of browsers and servers were coded to an early draft of the byteranges specification to use a media type of multipart/x-byteranges, which is almost, but not quite compatible with the version documented in HTTP/1.1.",
      "ja": "3）ブラウザおよびサーバの数はほぼであるマルチパート/ X-byterangesのメディアタイプを使用するbyteranges仕様の初期ドラフトに符号化されたが、HTTP / 1.1で文書バージョンと非常に互換性がなかったです。"
    },
    {
      "indent": 0,
      "text": "19.3 Tolerant Applications",
      "section_title": true,
      "ja": "19.3トレラントアプリケーション"
    },
    {
      "indent": 3,
      "text": "Although this document specifies the requirements for the generation of HTTP/1.1 messages, not all applications will be correct in their implementation. We therefore recommend that operational applications be tolerant of deviations whenever those deviations can be interpreted unambiguously.",
      "ja": "この文書はHTTP / 1.1メッセージの生成のための要求事項を規定していますが、必ずしもすべてのアプリケーションがその実施に正しくなります。そこで我々は、これらのずれが明確に解釈することができますいつでも業務アプリケーションは、偏差の許容性にすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD be tolerant in parsing the Status-Line and servers tolerant when parsing the Request-Line. In particular, they SHOULD accept any amount of SP or HT characters between fields, even though only a single SP is required.",
      "ja": "クライアントがリクエストラインの解析時にステータスラインとサーバ寛容を解析するには寛容であるべきです。特に、それらはただ一つのSPが必要とされていても、フィールド間のSPやHTの文字の任意の量を受け入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "The line terminator for message-header fields is the sequence CRLF. However, we recommend that applications, when parsing such headers, recognize a single LF as a line terminator and ignore the leading CR.",
      "ja": "メッセージヘッダフィールドのラインターミネータは、配列CRLFです。しかし、我々はそのようなヘッダを解析するとき、アプリケーションが、行終端として単一のLFを認識し、主要なCRを無視することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The character set of an entity-body SHOULD be labeled as the lowest common denominator of the character codes used within that body, with the exception that not labeling the entity is preferred over labeling the entity with the labels US-ASCII or ISO-8859-1. See section 3.7.1 and 3.4.1.",
      "ja": "エンティティボディの文字セットは、エンティティを標識しませラベルUS-ASCIIまたはISO-8859-1でエンティティを標識するよりも好ましいことを除いて、その体内で使用される文字コードの最小公分母としてラベル付けされるべき1。セクション3.7.1と3.4.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Additional rules for requirements on parsing and encoding of dates and other potential problems with date encodings include:",
      "ja": "日付と日付のエンコーディングを持つ他の潜在的な問題の解析とエンコーディングに関する要件のための追加ルールは、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "- HTTP/1.1 clients and caches SHOULD assume that an RFC-850 date which appears to be more than 50 years in the future is in fact in the past (this helps solve the \"year 2000\" problem).",
      "ja": " -  HTTP / 1.1クライアントとキャッシュは将来的には50年以上であるように思われるRFC-850日付が（これは「2000年」の問題を解決するのに役立ちます）過去の事実であることを前提とすべきです"
    },
    {
      "indent": 6,
      "text": "- An HTTP/1.1 implementation MAY internally represent a parsed Expires date as earlier than the proper value, but MUST NOT internally represent a parsed Expires date as later than the proper value.",
      "ja": " -  HTTP / 1.1の実装は、内部的に解析されたが適正値よりも早いと日付を有効期限が、内部的に解析されたが、後に適切な値よりも日付を期限切れに表現してはならない表すことができます。"
    },
    {
      "indent": 6,
      "text": "- All expiration-related calculations MUST be done in GMT. The local time zone MUST NOT influence the calculation or comparison of an age or expiration time.",
      "ja": " - すべての有効期限に関連する計算は、GMTで行わなければなりません。ローカルタイムゾーンは、年齢や有効期限の計算や比較に影響を及ぼしてはなりません。"
    },
    {
      "indent": 6,
      "text": "- If an HTTP header incorrectly carries a date value with a time zone other than GMT, it MUST be converted into GMT using the most conservative possible conversion.",
      "ja": " -  HTTPヘッダが誤ってGMT以外の時間帯と日付の値を搬送する場合、それは最も保守的な可能変換を使用してGMTに変換されなければなりません。"
    },
    {
      "indent": 0,
      "text": "19.4 Differences Between HTTP Entities and Entities",
      "section_title": true,
      "ja": "HTTPエンティティとエンティティ間の19.4違い"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 uses many of the constructs defined for Internet Mail (RFC 822 [9]) and the Multipurpose Internet Mail Extensions (MIME [7]) to allow entities to be transmitted in an open variety of representations and with extensible mechanisms. However, RFC 2045 discusses mail, and HTTP has a few features that are different from those described in RFC 2045. These differences were carefully chosen to optimize performance over binary connections, to allow greater freedom in the use of new media types, to make date comparisons easier, and to acknowledge the practice of some early HTTP servers and clients.",
      "ja": "HTTP / 1.1は、インターネットメール用に定義された構築物の多くを使用する（RFC 822 [9]）および多目的インターネットメール拡張（MIME [7]）エンティティが表現のオープン多様でかつ拡張可能なメカニズムを用いて送信されることを可能にします。ただし、RFC 2045には、メールを論じ、およびHTTPは、これらの違いは慎重に日付を作るために、新しいメディアタイプを使用することでより大きな自由を可能にするために、バイナリ接続でのパフォーマンスを最適化するために選択されたRFC 2045に記載されたものと異なっているいくつかの機能を持っています比較が簡単に、そしていくつかの初期のHTTPサーバおよびクライアントの練習を確認します。"
    },
    {
      "indent": 3,
      "text": "This appendix describes specific areas where HTTP differs from RFC 2045. Proxies and gateways to strict MIME environments SHOULD be aware of these differences and provide the appropriate conversions where necessary. Proxies and gateways from MIME environments to HTTP also need to be aware of the differences because some conversions might be required.",
      "ja": "この付録では、HTTPは、厳密なMIME環境へのRFC 2045プロキシやゲートウェイとは異なり、特定の領域は、これらの違いを認識し、必要に応じ適切な変換を提供すべきで記述する。 MIME環境からHTTPへのプロキシやゲートウェイはまた、いくつかの変換が必要になる場合がありますので、違いを認識する必要があります。"
    },
    {
      "indent": 0,
      "text": "19.4.1 MIME-Version",
      "section_title": true,
      "ja": "19.4.1 MIME-バージョン"
    },
    {
      "indent": 3,
      "text": "HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY include a single MIME-Version general-header field to indicate what version of the MIME protocol was used to construct the message. Use of the MIME-Version header field indicates that the message is in full compliance with the MIME protocol (as defined in RFC 2045[7]). Proxies/gateways are responsible for ensuring full compliance (where possible) when exporting HTTP messages to strict MIME environments.",
      "ja": "HTTPは、MIME準拠のプロトコルではありません。しかしながら、HTTP / 1.1のメッセージは、メッセージを構成するために使用されたMIMEプロトコルのバージョンを示すために、単一のMIME-版一般的なヘッダフィールドを含んでいてもよいです。 MIMEバージョンのヘッダフィールドの使用は、（RFC 2045で定義されている[7]）メッセージは、MIMEプロトコルに完全に準拠していることを示しています。プロキシ/ゲートウェイは、厳密なMIME環境へのHTTPメッセージをエクスポートするときに（可能な場合）の完全遵守を確保する責任があります。"
    },
    {
      "indent": 7,
      "text": "MIME-Version = \"MIME-Version\" \":\" 1*DIGIT \".\" 1*DIGIT",
      "ja": "MIME-バージョン= \"MIME-バージョン\" \"：\" 1 * DIGIT \"\"。 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "MIME version \"1.0\" is the default for use in HTTP/1.1. However, HTTP/1.1 message parsing and semantics are defined by this document and not the MIME specification.",
      "ja": "MIMEバージョン「1.0」HTTP / 1.1で使用するためのデフォルトです。しかし、HTTP / 1.1メッセージの解析と意味については、このドキュメントではなくMIME仕様で定義されています。"
    },
    {
      "indent": 0,
      "text": "19.4.2 Conversion to Canonical Form",
      "section_title": true,
      "ja": "Canonicalはフォームへの変換19.4.2"
    },
    {
      "indent": 3,
      "text": "RFC 2045 [7] requires that an Internet mail entity be converted to canonical form prior to being transferred, as described in section 4 of RFC 2049 [48]. Section 3.7.1 of this document describes the forms allowed for subtypes of the \"text\" media type when transmitted over HTTP. RFC 2046 requires that content with a type of \"text\" represent line breaks as CRLF and forbids the use of CR or LF outside of line break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate a line break within text content when a message is transmitted over HTTP.",
      "ja": "RFC 2045 [7] RFC 2049 [48]のセクション4で説明したように、インターネット・メール・エンティティは、前に転送されることに標準形に変換することを必要とします。このドキュメントのセクション3.7.1には、HTTPを介して送信時に「テキスト」メディアタイプのサブタイプのために許可されている形式について説明します。 RFC 2046には、「テキスト」の種類と内容はCRLFとしてラインブレイクを表すことが必要と改行シーケンスの外でCRまたはLFの使用を禁止します。 HTTPは、メッセージがHTTPを介して送信されるとき、テキストコンテンツ内の改行を示すためにCRLF、むき出しのCR、およびむき出しのLFを可能にします。"
    },
    {
      "indent": 3,
      "text": "Where it is possible, a proxy or gateway from HTTP to a strict MIME environment SHOULD translate all line breaks within the text media types described in section 3.7.1 of this document to the RFC 2049 canonical form of CRLF. Note, however, that this might be complicated by the presence of a Content-Encoding and by the fact that HTTP allows the use of some character sets which do not use octets 13 and 10 to represent CR and LF, as is the case for some multi-byte character sets.",
      "ja": "それが可能な場合、HTTPから厳密なMIME環境へのプロキシやゲートウェイは、CRLFのRFC 2049標準的な形式に、この文書のセクション3.7.1に記述されたテキストメディアタイプ内のすべての改行を変換すべきです。これはコンテンツのエンコードの存在によっておよびHTTPは、いくつかの場合のように、CRとLFを表現するためにオクテット13と10を使用していないいくつかの文字セットを使用することができますという事実によって複雑になるかもしれないこと、しかし、注意してくださいマルチバイト文字セット。"
    },
    {
      "indent": 3,
      "text": "Implementors should note that conversion will break any cryptographic checksums applied to the original content unless the original content is already in canonical form. Therefore, the canonical form is recommended for any content that uses such checksums in HTTP.",
      "ja": "実装者は、元のコンテンツが正規の形式で既にある場合を除き、変換は、オリジナルのコンテンツに適用されるすべての暗号チェックサムを破るだろうことに注意してください。したがって、正規の形式はHTTPで、このようなチェックサムを使用するすべてのコンテンツに対して推奨されています。"
    },
    {
      "indent": 0,
      "text": "19.4.3 Conversion of Date Formats",
      "section_title": true,
      "ja": "日付の書式の変換19.4.3"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 uses a restricted set of date formats (section 3.3.1) to simplify the process of date comparison. Proxies and gateways from other protocols SHOULD ensure that any Date header field present in a message conforms to one of the HTTP/1.1 formats and rewrite the date if necessary.",
      "ja": "HTTP / 1.1は日付比較の処理を簡単にするために、日付形式（セクション3.3.1）の制限されたセットを使用します。他のプロトコルからのプロキシ及びゲートウェイは、メッセージ中に存在する任意の日付ヘッダフィールドは、HTTP / 1.1のいずれかの形式に準拠していることを確認し、必要に応じて日付を書き換えるべきです。"
    },
    {
      "indent": 0,
      "text": "19.4.4 Introduction of Content-Encoding",
      "section_title": true,
      "ja": "コンテンツエンコーディングの19.4.4はじめに"
    },
    {
      "indent": 3,
      "text": "RFC 2045 does not include any concept equivalent to HTTP/1.1's Content-Encoding header field. Since this acts as a modifier on the media type, proxies and gateways from HTTP to MIME-compliant protocols MUST either change the value of the Content-Type header field or decode the entity-body before forwarding the message. (Some experimental applications of Content-Type for Internet mail have used a media-type parameter of \";conversions=<content-coding>\" to perform a function equivalent to Content-Encoding. However, this parameter is not part of RFC 2045.)",
      "ja": "RFC 2045は、HTTP / 1.1のContent-Encodingヘッダフィールドに任意の概念相当が含まれていません。これは、メディアタイプの修飾として作用するため、HTTPからMIME準拠のプロトコルにプロキシ及びゲートウェイは、Content-Typeヘッダフィールドの値を変更したり、メッセージを転送する前に、エンティティボディをデコードする必要があります。インターネットメール用のContent-Typeの（いくつかの実験的なアプリケーションは、のメディアタイプパラメータを使用している「;変換は= <コンテンツコーディング>」コンテンツ・エンコードと同等の機能を実行するためにしかし、このパラメータはRFC 2045の一部ではありません。 ）"
    },
    {
      "indent": 0,
      "text": "19.4.5 No Content-Transfer-Encoding",
      "section_title": true,
      "ja": "19.4.5ノーコンテンツ転送エンコード"
    },
    {
      "indent": 3,
      "text": "HTTP does not use the Content-Transfer-Encoding (CTE) field of RFC 2045. Proxies and gateways from MIME-compliant protocols to HTTP MUST remove any non-identity CTE (\"quoted-printable\" or \"base64\") encoding prior to delivering the response message to an HTTP client.",
      "ja": "前提供にエンコードする（「quoted-printable形式」または「BASE64」）以外のアイデンティティCTEを削除する必要がありますHTTPは、HTTPにRFCのコンテンツ転送エンコード（CTE）フィールド2045プロキシとMIME準拠のプロトコルからのゲートウェイを使用していませんHTTPクライアントへの応答メッセージ。"
    },
    {
      "indent": 3,
      "text": "Proxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct format and encoding for safe transport on that protocol, where \"safe transport\" is defined by the limitations of the protocol being used. Such a proxy or gateway SHOULD label the data with an appropriate Content-Transfer-Encoding if doing so will improve the likelihood of safe transport over the destination protocol.",
      "ja": "HTTPからMIME準拠のプロトコルにプロキシ及びゲートウェイは、メッセージが「安全輸送」が使用されているプロトコルの制限によって定義されるプロトコルの安全な輸送のための正しいフォーマット及び符号化であることを保証する責任があります。そうすることは先のプロトコル上で、安全な輸送の可能性を向上させる場合には、このようなプロキシやゲートウェイは、適切なコンテンツ転送エンコードを使用してデータにラベルを付けるべきです。"
    },
    {
      "indent": 0,
      "text": "19.4.6 Introduction of Transfer-Encoding",
      "section_title": true,
      "ja": "転送エンコードの19.4.6はじめに"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 introduces the Transfer-Encoding header field (section 14.41). Proxies/gateways MUST remove any transfer-coding prior to forwarding a message via a MIME-compliant protocol.",
      "ja": "HTTP / 1.1は、転送エンコードヘッダーフィールド（セクション14.41）を導入します。プロキシ/ゲートウェイは、任意の転送コーディング前MIME準拠のプロトコルを介してメッセージを転送するのを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "A process for decoding the \"chunked\" transfer-coding (section 3.6) can be represented in pseudo-code as:",
      "ja": "：転送符号化（セクション3.6）のように疑似コードで表すことができる「チャンク」をデコードするためのプロセス"
    },
    {
      "indent": 7,
      "text": "length := 0\nread chunk-size, chunk-extension (if any) and CRLF\nwhile (chunk-size > 0) {\n   read chunk-data and CRLF\n   append chunk-data to entity-body\n   length := length + chunk-size\n   read chunk-size and CRLF\n}\nread entity-header\nwhile (entity-header not empty) {\n   append entity-header to existing header fields\n   read entity-header\n}\nContent-Length := length\nRemove \"chunked\" from Transfer-Encoding",
      "raw": true
    },
    {
      "indent": 0,
      "text": "19.4.7 MHTML and Line Length Limitations",
      "section_title": true,
      "ja": "19.4.7 MHTMLとライン長さの制限"
    },
    {
      "indent": 3,
      "text": "HTTP implementations which share code with MHTML [45] implementations need to be aware of MIME line length limitations. Since HTTP does not have this limitation, HTTP does not fold long lines. MHTML messages being transported by HTTP follow all conventions of MHTML, including line length limitations and folding, canonicalization, etc., since HTTP transports all message-bodies as payload (see section 3.7.2) and does not interpret the content or any MIME header lines that might be contained therein.",
      "ja": "MHTMLでコードを共有するHTTP実装は、[45]の実装は、MIME行の長さの制限に注意する必要があります。 HTTPは、この制限はありませんので、HTTPは長い行を折り畳まれていません。 HTTPは、ペイロードとして、すべてのメッセージ・ボディを搬送するためMHTMLメッセージは、HTTPによって搬送され、等線路長の制限と折り、正規化を含む、MHTMLのすべての規則に従う（セクション3.7.2参照）、コンテンツまたは任意のMIMEヘッダを解釈することはありませんそこに含まれている可能性のあるライン。"
    },
    {
      "indent": 0,
      "text": "19.5 Additional Features",
      "section_title": true,
      "ja": "19.5その他の機能"
    },
    {
      "indent": 3,
      "text": "RFC 1945 and RFC 2068 document protocol elements used by some existing HTTP implementations, but not consistently and correctly across most HTTP/1.1 applications. Implementors are advised to be aware of these features, but cannot rely upon their presence in, or interoperability with, other HTTP/1.1 applications. Some of these describe proposed experimental features, and some describe features that experimental deployment found lacking that are now addressed in the base HTTP/1.1 specification.",
      "ja": "RFC 1945およびいくつかの既存のHTTP実装で使用されるRFC 2068文書プロトコル要素ではなく、一貫して正しくほとんどのHTTP / 1.1のアプリケーション間。実装者は、これらの機能を意識することをお勧めしますが、その中に存在する、または他のHTTP / 1.1アプリケーションとの相互運用性に頼ることはできません。これらのいくつかは、提案された実験的な機能について説明し、いくつかの実験的な展開は、今ベースHTTP / 1.1の仕様で対処される欠けた機能について説明します。"
    },
    {
      "indent": 3,
      "text": "A number of other headers, such as Content-Disposition and Title, from SMTP and MIME are also often implemented (see RFC 2076 [37]).",
      "ja": "SMTPとMIMEからそのようなコンテンツの廃棄やタイトルなどの他のヘッダの数は、しばしば（RFC 2076 [37]参照）が実装されています。"
    },
    {
      "indent": 0,
      "text": "19.5.1 Content-Disposition",
      "section_title": true,
      "ja": "19.5.1コンテンツ処分"
    },
    {
      "indent": 3,
      "text": "The Content-Disposition response-header field has been proposed as a means for the origin server to suggest a default filename if the user requests that the content is saved to a file. This usage is derived from the definition of Content-Disposition in RFC 1806 [35].",
      "ja": "コンテンツディスポジションレスポンスヘッダフィールドは、ユーザがコンテンツをファイルに保存されていることを要求した場合、デフォルトのファイル名を示唆するためにオリジンサーバのための手段として提案されています。この用法は、RFC 1806 [35]にコンテンツの廃棄の定義から導出されます。"
    },
    {
      "indent": 8,
      "text": "content-disposition = \"Content-Disposition\" \":\"\n                      disposition-type *( \";\" disposition-parm )\ndisposition-type = \"attachment\" | disp-extension-token\ndisposition-parm = filename-parm | disp-extension-parm\nfilename-parm = \"filename\" \"=\" quoted-string\ndisp-extension-token = token\ndisp-extension-parm = token \"=\" ( token | quoted-string )",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An example is",
      "ja": "例があります"
    },
    {
      "indent": 8,
      "text": "Content-Disposition: attachment; filename=\"fname.ext\"",
      "ja": "コンテンツディスポジション：添付ファイル;ファイル名= \"fname.ext\""
    },
    {
      "indent": 3,
      "text": "The receiving user agent SHOULD NOT respect any directory path information present in the filename-parm parameter, which is the only parameter believed to apply to HTTP implementations at this time. The filename SHOULD be treated as a terminal component only.",
      "ja": "受信ユーザエージェントは、この時点でHTTPの実装に適用すると考えられる唯一のパラメータであるファイル名PARMパラメーター、中に存在する任意のディレクトリのパス情報を尊重すべきではありません。ファイル名は、末端構成要素として扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "If this header is used in a response with the application/octet-stream content-type, the implied suggestion is that the user agent should not display the response, but directly enter a `save response as...' dialog.",
      "ja": "このヘッダは、アプリケーション/オクテットストリームコンテンツタイプと応答で使用されている場合、暗黙の提案は、ユーザエージェントが応答を表示するが、直接 `として応答を保存...」ダイアログに入るべきではないということです。"
    },
    {
      "indent": 3,
      "text": "See section 15.5 for Content-Disposition security issues.",
      "ja": "コンテンツディスポジションのセキュリティ問題のためのセクション15.5を参照してください。"
    },
    {
      "indent": 0,
      "text": "19.6 Compatibility with Previous Versions",
      "section_title": true,
      "ja": "以前のバージョンとの互換性19.6"
    },
    {
      "indent": 3,
      "text": "It is beyond the scope of a protocol specification to mandate compliance with previous versions. HTTP/1.1 was deliberately designed, however, to make supporting previous versions easy. It is worth noting that, at the time of composing this specification (1996), we would expect commercial HTTP/1.1 servers to:",
      "ja": "これは、以前のバージョンの遵守を強制するために、プロトコル仕様の範囲を超えています。 HTTP / 1.1が故意に設計された、しかし、簡単に以前のバージョンをサポートするようにします。なお、本明細書（1996）を構成する時に、私たちは、商業HTTP / 1.1サーバへの期待、ということは注目に値します。"
    },
    {
      "indent": 6,
      "text": "- recognize the format of the Request-Line for HTTP/0.9, 1.0, and 1.1 requests;",
      "ja": " -  HTTP / 0.9、1.0の要求ラインのフォーマットを認識し、そして1.1リクエスト。"
    },
    {
      "indent": 6,
      "text": "- understand any valid request in the format of HTTP/0.9, 1.0, or 1.1;",
      "ja": " -  HTTP / 0.9、1.0、または1.1の形式であらゆる有効な要求を理解します。"
    },
    {
      "indent": 6,
      "text": "- respond appropriately with a message in the same major version used by the client.",
      "ja": " - クライアントによって使用されるのと同じメジャーバージョンでのメッセージで適切に対応。"
    },
    {
      "indent": 3,
      "text": "And we would expect HTTP/1.1 clients to:",
      "ja": "そして、我々は、HTTP / 1.1クライアントへの期待します："
    },
    {
      "indent": 6,
      "text": "- recognize the format of the Status-Line for HTTP/1.0 and 1.1 responses;",
      "ja": " -  HTTP / 1.0と1.1レスポンスのステータスラインのフォーマットを認識し、"
    },
    {
      "indent": 6,
      "text": "- understand any valid response in the format of HTTP/0.9, 1.0, or 1.1.",
      "ja": " -  HTTP / 0.9、1.0、または1.1の形式で任意の有効な応答を理解しています。"
    },
    {
      "indent": 3,
      "text": "For most implementations of HTTP/1.0, each connection is established by the client prior to the request and closed by the server after sending the response. Some implementations implement the Keep-Alive version of persistent connections described in section 19.7.1 of RFC 2068 [33].",
      "ja": "HTTP / 1.0のほとんどの実装では、各接続を要求する前に、応答を送信した後に、サーバーによって閉じられ、クライアントによって確立されています。いくつかの実装は、RFC 2068 [33]のセクション19.7.1に記載の永続的な接続のキープアライブバージョンを実装します。"
    },
    {
      "indent": 0,
      "text": "19.6.1 Changes from HTTP/1.0",
      "section_title": true,
      "ja": "HTTP / 1.0からの変更点19.6.1"
    },
    {
      "indent": 3,
      "text": "This section summarizes major differences between versions HTTP/1.0 and HTTP/1.1.",
      "ja": "このセクションでは、バージョンHTTP / 1.0とHTTP / 1.1の主な違いをまとめたもの。"
    },
    {
      "indent": 0,
      "text": "19.6.1.1 Changes to Simplify Multi-homed Web Servers and Conserve IP Addresses",
      "ja": "19.6.1.1変更は、マルチホームWebサーバーと節約IPアドレスを簡単にするために"
    },
    {
      "indent": 3,
      "text": "The requirements that clients and servers support the Host request-header, report an error if the Host request-header (section 14.23) is missing from an HTTP/1.1 request, and accept absolute URIs (section 5.1.2) are among the most important changes defined by this specification.",
      "ja": "クライアントとサーバがホストリクエストヘッダ（セクション14.23）はHTTP / 1.1リクエストから欠落している場合、エラーを報告し、ホストリクエストヘッダをサポートし、絶対的なURI（セクション5.1.2）を受け入れるの要件は、最も重要なの一つですこの仕様で定義された変更。"
    },
    {
      "indent": 3,
      "text": "Older HTTP/1.0 clients assumed a one-to-one relationship of IP addresses and servers; there was no other established mechanism for distinguishing the intended server of a request than the IP address to which that request was directed. The changes outlined above will allow the Internet, once older HTTP clients are no longer common, to support multiple Web sites from a single IP address, greatly simplifying large operational Web servers, where allocation of many IP addresses to a single host has created serious problems. The Internet will also be able to recover the IP addresses that have been allocated for the sole purpose of allowing special-purpose domain names to be used in root-level HTTP URLs. Given the rate of growth of the Web, and the number of servers already deployed, it is extremely important that all implementations of HTTP (including updates to existing HTTP/1.0 applications) correctly implement these requirements:",
      "ja": "古いHTTP / 1.0クライアントは、IPアドレスやサーバの1対1の関係を仮定しました。その要求が向けられた先のIPアドレスより要求の意図したサーバーを区別するための他の確立されたメカニズムがありませんでした。上記で概説した変更が大幅に単一のホストに多くのIPアドレスの割り当てが深刻な問題を作成している大規模な運用Webサーバーを、簡素化し、単一のIPアドレスからの複数のWebサイトをサポートするために、一度古いHTTPクライアントはもはや共通している、インターネットを許可しません。インターネットはまた、専用のドメイン名は、ルートレベルのHTTP URLで使用できるようにすることを唯一の目的のために割り当てられているIPアドレスを回復することができます。 Web、およびすでに展開されたサーバーの数の成長率を考えると、（既存のHTTP / 1.0アプリケーションのアップデートを含む）HTTPのすべての実装が正しくこれらの要件を実装することが非常に重要です。"
    },
    {
      "indent": 6,
      "text": "- Both clients and servers MUST support the Host request-header.",
      "ja": " - クライアントとサーバの両方がホストリクエストヘッダをサポートしなければなりません。"
    },
    {
      "indent": 6,
      "text": "- A client that sends an HTTP/1.1 request MUST send a Host header.",
      "ja": " -  HTTP / 1.1リクエストを送信するクライアントは、Hostヘッダを送らなければなりません。"
    },
    {
      "indent": 6,
      "text": "- Servers MUST report a 400 (Bad Request) error if an HTTP/1.1 request does not include a Host request-header.",
      "ja": " -  HTTP / 1.1リクエストがHostリクエストヘッダが含まれていない場合、サーバーは400（不正な要求）エラーを報告しなければなりません。"
    },
    {
      "indent": 6,
      "text": "- Servers MUST accept absolute URIs.",
      "ja": " - サーバは絶対URIを受け入れなければなりません。"
    },
    {
      "indent": 0,
      "text": "19.6.2 Compatibility with HTTP/1.0 Persistent Connections",
      "section_title": true,
      "ja": "HTTP / 1.0永続接続で19.6.2の互換性"
    },
    {
      "indent": 3,
      "text": "Some clients and servers might wish to be compatible with some previous implementations of persistent connections in HTTP/1.0 clients and servers. Persistent connections in HTTP/1.0 are explicitly negotiated as they are not the default behavior. HTTP/1.0 experimental implementations of persistent connections are faulty, and the new facilities in HTTP/1.1 are designed to rectify these problems. The problem was that some existing 1.0 clients may be sending Keep-Alive to a proxy server that doesn't understand Connection, which would then erroneously forward it to the next inbound server, which would establish the Keep-Alive connection and result in a hung HTTP/1.0 proxy waiting for the close on the response. The result is that HTTP/1.0 clients must be prevented from using Keep-Alive when talking to proxies.",
      "ja": "いくつかのクライアントとサーバは、HTTP / 1.0のクライアントとサーバーでの持続的な接続のいくつかの以前の実装と互換性があることを望むかもしれません。彼らはデフォルトの動作ではないので、HTTP / 1.0での持続的な接続を明示的に交渉されています。 HTTP /持続的接続の1.0実験的な実装が故障しており、HTTP / 1.1での新施設は、これらの問題を是正するために設計されています。問題は、いくつかの既存の1.0のクライアントは、その後誤ってキープアライブ接続を確立し、ハングアップにつながる次のインバウンドサーバに転送します接続を理解していないプロキシサーバにキープアライブ送信することができるということでしたHTTP / 1.0プロキシが応答に近いのを待っています。結果は、HTTP / 1.0クライアントはキープアライブプロキシに話したときに使用しないようにしなければならないということです。"
    },
    {
      "indent": 3,
      "text": "However, talking to proxies is the most important use of persistent connections, so that prohibition is clearly unacceptable. Therefore, we need some other mechanism for indicating a persistent connection is desired, which is safe to use even when talking to an old proxy that ignores Connection. Persistent connections are the default for HTTP/1.1 messages; we introduce a new keyword (Connection: close) for declaring non-persistence. See section 14.10.",
      "ja": "しかし、プロキシに話をすることは持続的な接続の最も重要な用途であるので、その禁止は明らかに受け入れられません。したがって、我々はコネクションを無視し、古いプロキシに話をするときにも使用しても安全であることが望まれる永続的な接続を示すための他のいくつかのメカニズムが必要です。持続的接続はHTTP / 1.1メッセージのデフォルトです。非永続性を宣言するために：私たちは、新しいキーワード（クローズ接続）を導入します。セクション14.10を参照してください。"
    },
    {
      "indent": 3,
      "text": "The original HTTP/1.0 form of persistent connections (the Connection: Keep-Alive and Keep-Alive header) is documented in RFC 2068. [33]",
      "ja": "永続的な接続の元のHTTP / 1.0形式（接続：キープアライブとキープアライブヘッダ）は、RFC 2068 [33]に記載されて"
    },
    {
      "indent": 1,
      "text": "19.6.3 Changes from",
      "section_title": true,
      "ja": "から19.6.3の変更点"
    },
    {
      "indent": 3,
      "text": "This specification has been carefully audited to correct and disambiguate key word usage; RFC 2068 had many problems in respect to the conventions laid out in RFC 2119 [34].",
      "ja": "この仕様は、慎重にキーワードの使用法を修正し、明確にするために監査を受けてきました。 RFC 2068は、RFC 2119 [34]でレイアウト規則に関しての多くの問題を抱えていました。"
    },
    {
      "indent": 3,
      "text": "Clarified which error code should be used for inbound server failures (e.g. DNS failures). (Section 10.5.5).",
      "ja": "インバウンドサーバの障害（例えば、DNS障害）のために使用すべきエラーコードを明らかにしました。 （10.5.5項）。"
    },
    {
      "indent": 3,
      "text": "CREATE had a race that required an Etag be sent when a resource is first created. (Section 10.2.2).",
      "ja": "CREATEリソースが最初に作成されたときに送信されたEtagを必要とレースを持っていました。 （10.2.2項）。"
    },
    {
      "indent": 3,
      "text": "Content-Base was deleted from the specification: it was not implemented widely, and there is no simple, safe way to introduce it without a robust extension mechanism. In addition, it is used in a similar, but not identical fashion in MHTML [45].",
      "ja": "それは広く実装されていなかった、堅牢な拡張機構なしにそれを導入する簡単な、安全な方法はありません：コンテンツ・ベースは仕様から削除されました。加えて、MHTML [45]に類似するが、同一でない方法で使用されています。"
    },
    {
      "indent": 3,
      "text": "Transfer-coding and message lengths all interact in ways that required fixing exactly when chunked encoding is used (to allow for transfer encoding that may not be self delimiting); it was important to straighten out exactly how message lengths are computed. (Sections 3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)",
      "ja": "転送符号化およびメッセージは、すべてのチャンクエンコーディングが（自己区切りではないかもしれない転送符号化を可能にするために）使用さを正確に固定する必要の方法で相互作用長さ;メッセージの長さが計算されている正確にどのようにまっすぐにすることが重要でした。 （セクション3.6、4.4、7.2.2、13.5.2、14.13、14.16）"
    },
    {
      "indent": 3,
      "text": "A content-coding of \"identity\" was introduced, to solve problems discovered in caching. (section 3.5)",
      "ja": "「アイデンティティ」の内容コーディングは、キャッシングで発見された問題を解決するために、導入されました。 （セクション3.5）"
    },
    {
      "indent": 3,
      "text": "Quality Values of zero should indicate that \"I don't want something\" to allow clients to refuse a representation. (Section 3.9)",
      "ja": "ゼロの品質値は、クライアントが表現を拒否できるようにする「私が何かを望んでいない」ことを示す必要があります。 （3.9節）"
    },
    {
      "indent": 3,
      "text": "The use and interpretation of HTTP version numbers has been clarified by RFC 2145. Require proxies to upgrade requests to highest protocol version they support to deal with problems discovered in HTTP/1.0 implementations (Section 3.1)",
      "ja": "HTTPのバージョン番号の使用及び解釈は、RFC 2145で明らかにされている彼らはHTTP / 1.0の実装（3.1節）で発見された問題に対処するためにサポートする最上位のプロトコルバージョンに要求をアップグレードするためにプロキシを要求"
    },
    {
      "indent": 3,
      "text": "Charset wildcarding is introduced to avoid explosion of character set names in accept headers. (Section 14.2)",
      "ja": "文字セットのワイルドカードを受け入れるヘッダーに文字セット名の爆発を避けるために導入されます。 （14.2節）"
    },
    {
      "indent": 3,
      "text": "A case was missed in the Cache-Control model of HTTP/1.1; s-maxage was introduced to add this missing case. (Sections 13.4, 14.8, 14.9, 14.9.3)",
      "ja": "場合は、HTTP / 1.1ののCache-Controlモデルで逃しました。 S-MAXAGEは、この不足している場合を追加するために導入されました。 （セクション13.4、14.8、14.9、14.9.3）"
    },
    {
      "indent": 3,
      "text": "The Cache-Control: max-age directive was not properly defined for responses. (Section 14.9.3)",
      "ja": "Cache-Control：MAX-ageディレクティブが適切に応答するために定義されていませんでした。 （セクション14.9.3）"
    },
    {
      "indent": 3,
      "text": "There are situations where a server (especially a proxy) does not know the full length of a response but is capable of serving a byterange request. We therefore need a mechanism to allow byteranges with a content-range not indicating the full length of the message. (Section 14.16)",
      "ja": "サーバー（特に代理）は、応答の全長を知っているが、バイトレンジ要求にサービスを提供することができない状況があります。したがって、我々は、メッセージの全長を示していないコンテンツの範囲とbyteranges可能にするメカニズムを必要とします。 （セクション14.16）"
    },
    {
      "indent": 3,
      "text": "Range request responses would become very verbose if all meta-data were always returned; by allowing the server to only send needed headers in a 206 response, this problem can be avoided. (Section 10.2.7, 13.5.3, and 14.27)",
      "ja": "すべてのメタデータが常に返された場合、範囲要求応答が非常に冗長になります。サーバが唯一の206応答に必要なヘッダーを送信できるようにすることで、この問題を回避することができます。 （セクション10.2.7、13.5.3、および14.27）"
    },
    {
      "indent": 3,
      "text": "Fix problem with unsatisfiable range requests; there are two cases: syntactic problems, and range doesn't exist in the document. The 416 status code was needed to resolve this ambiguity needed to indicate an error for a byte range request that falls outside of the actual contents of a document. (Section 10.4.17, 14.16)",
      "ja": "充足不能範囲要求と問題を修正しました。そこに2例ある：構文上の問題は、その範囲は、文書内に存在しません。 416のステータスコードは、文書の実際の内容の外にあるバイト範囲要求のエラーを示すために必要な、この曖昧さを解決するために必要でした。 （セクション10.4.17、14.16）"
    },
    {
      "indent": 3,
      "text": "Rewrite of message transmission requirements to make it much harder for implementors to get it wrong, as the consequences of errors here can have significant impact on the Internet, and to deal with the following problems:",
      "ja": "ここでのエラーの結果は、インターネット上で大きな影響を与える可能性があり、かつ、次のような問題に対処するためとして、それははるかに困難実装者はそれが間違って取得するために作るためのメッセージの送信要件の書き換え："
    },
    {
      "indent": 6,
      "text": "1. Changing \"HTTP/1.1 or later\" to \"HTTP/1.1\", in contexts where this was incorrectly placing a requirement on the behavior of an implementation of a future version of HTTP/1.x",
      "ja": "1.これは間違ってHTTP / 1.1の将来のバージョンの実装の振る舞いに要件を置きました文脈で、「HTTP / 1.1」に「HTTP / 1.1以降の変更」"
    },
    {
      "indent": 6,
      "text": "2. Made it clear that user-agents should retry requests, not \"clients\" in general.",
      "ja": "2.は、それが明確なユーザーエージェントがリクエストではなく、一般的には、「クライアント」を再試行することを作りました。"
    },
    {
      "indent": 6,
      "text": "3. Converted requirements for clients to ignore unexpected 100 (Continue) responses, and for proxies to forward 100 responses, into a general requirement for 1xx responses.",
      "ja": "予期しない100（続行）応答を無視するクライアントのために、との1xx応答のための一般的な要件に、100の応答を転送するためのプロキシ3.変換された要件。"
    },
    {
      "indent": 6,
      "text": "4. Modified some TCP-specific language, to make it clearer that non-TCP transports are possible for HTTP.",
      "ja": "4.非TCPトランスポートは、HTTPのために可能であることは、それをより明確にするために、いくつかのTCP固有の言語を変更しました。"
    },
    {
      "indent": 6,
      "text": "5. Require that the origin server MUST NOT wait for the request body before it sends a required 100 (Continue) response.",
      "ja": "5.は、それが必要な100（続行）応答を送信する前に、オリジンサーバがリクエストボディを待つてはならないことを要求します。"
    },
    {
      "indent": 6,
      "text": "6. Allow, rather than require, a server to omit 100 (Continue) if it has already seen some of the request body.",
      "ja": "それはすでにリクエストボディのいくつかを見ている場合6.許可、必要ではなく、サーバは100（続行）を省略します。"
    },
    {
      "indent": 6,
      "text": "7. Allow servers to defend against denial-of-service attacks and broken clients.",
      "ja": "7.サーバは、サービス拒否攻撃や壊れたクライアントを防御することを許可します。"
    },
    {
      "indent": 3,
      "text": "This change adds the Expect header and 417 status code. The message transmission requirements fixes are in sections 8.2, 10.4.18, 8.1.2.2, 13.11, and 14.20.",
      "ja": "この変化は期待ヘッダと417ステータスコードを付加します。メッセージ伝送要件の修正は、セクション8.2、10.4.18、8.1.2.2、13.11、および14.20です。"
    },
    {
      "indent": 3,
      "text": "Proxies should be able to add Content-Length when appropriate. (Section 13.5.2)",
      "ja": "プロキシは、適切な場合のContent-Lengthを追加することができるはずです。 （13.5.2項）"
    },
    {
      "indent": 3,
      "text": "Clean up confusion between 403 and 404 responses. (Section 10.4.4, 10.4.5, and 10.4.11)",
      "ja": "403と404応答の間に混乱をクリーンアップします。 （セクション10.4.4、10.4.5、および10.4.11）"
    },
    {
      "indent": 3,
      "text": "Warnings could be cached incorrectly, or not updated appropriately. (Section 13.1.2, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning also needed to be a general header, as PUT or other methods may have need for it in requests.",
      "ja": "警告は間違ってキャッシュされた、または適切に更新されていないことでした。 （セクション13.1.2、13.2.4、13.5.2、13.5.3、14.9.3、及び14.46）PUTまたは他の方法が要求でそれを必要とするかもしれませんが、また、一般的なヘッダであることを必要と警告。"
    },
    {
      "indent": 3,
      "text": "Transfer-coding had significant problems, particularly with interactions with chunked encoding. The solution is that transfer-codings become as full fledged as content-codings. This involves adding an IANA registry for transfer-codings (separate from content codings), a new header field (TE) and enabling trailer headers in the future. Transfer encoding is a major performance benefit, so it was worth fixing [39]. TE also solves another, obscure, downward interoperability problem that could have occurred due to interactions between authentication trailers, chunked encoding and HTTP/1.0 clients.(Section 3.6, 3.6.1, and 14.39)",
      "ja": "転送コーディングは、特にチャンクエンコーディングとの相互作用で、重大な問題を抱えていました。ソリューションは、内容コーディングなどの本格的なようになっている転送コーディングです。これは、（コンテンツコーディングとは別の）転送コーディングのためのIANAレジストリ、新しいヘッダフィールド（TE）を添加し、将来的にトレーラヘッダを有効にすることを含みます。転送符号化は、主要なパフォーマンス上の利点であり、それは[39]固定価値がありました。 TEはまた、原因認証トレーラとの間の相互作用に発生したかもしれない別の、不明瞭、下方に相互運用性の問題を解決し、符号化及びHTTP / 1.0クライアントをチャンク（3.6節、3.6.1、および14.39）"
    },
    {
      "indent": 3,
      "text": "The PATCH, LINK, UNLINK methods were defined but not commonly implemented in previous versions of this specification. See RFC 2068 [33].",
      "ja": "PATCH、LINKは、メソッドが定義されているが、一般的に、本明細書の以前のバージョンで実装されなかったリンクを解除します。 RFC 2068 [33]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The Alternates, Content-Version, Derived-From, Link, URI, Public and Content-Base header fields were defined in previous versions of this specification, but not commonly implemented. See RFC 2068 [33].",
      "ja": "派生-からのリンク、URI、公共およびContent-基本ヘッダフィールド、代替デバイス、コンテンツのバージョンは、この仕様の以前のバージョンで定義されていますが、一般的に実装されていませんでした。 RFC 2068 [33]を参照してください。"
    },
    {
      "indent": 0,
      "text": "20 Index",
      "ja": "20インデックス"
    },
    {
      "indent": 3,
      "text": "Please see the PostScript version of this RFC for the INDEX.",
      "ja": "INDEXのため、このRFCのPostScript版を参照してください。"
    },
    {
      "indent": 0,
      "text": "21. Full Copyright Statement",
      "section_title": true,
      "ja": "21.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1999）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}