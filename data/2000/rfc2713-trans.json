{
  "title": {
    "text": "RFC 2713 - Schema for Representing Java(tm) Objects in an LDAP Directory",
    "ja": "RFC 2713 - Javaの（TM）を表すためのスキーマは、LDAPディレクトリ内のオブジェクト"
  },
  "number": 2713,
  "created_at": "2019-10-29 03:46:39.268080+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                            V. Ryan\nRequest for Comments: 2713                                   S. Seligman\nCategory: Informational                                           R. Lee\n                                                  Sun Microsystems, Inc.\n                                                            October 1999",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Schema for Representing Java(tm) Objects in an LDAP Directory",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1999）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document defines the schema for representing Java(tm) objects in an LDAP directory [LDAPv3]. It defines schema elements to represent a Java serialized object [Serial], a Java marshalled object [RMI], a Java remote object [RMI], and a JNDI reference [JNDI].",
      "ja": "この文書では、LDAPディレクトリ[のLDAPv3]でJava（登録商標）オブジェクトを表すためのスキーマを定義します。それは[シリアル] Javaの直列化されたオブジェクトを表すためにスキーマ要素を定義し、Javaの整列オブジェクト[RMI]、Javaリモートオブジェクト[RMI]、およびJNDI参照[JNDI]。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document assumes that the reader has a general knowledge of the Java programming language [Java]. For brevity we use the term \"Java object\" in place of \"object in the Java programming language\" throughout this text.",
      "ja": "この文書は、読者がJavaプログラミング言語[ジャワ]の一般的な知識を持っていることを前提としています。簡潔にするため、私たちは、このテキストを通して、「Javaプログラミング言語のオブジェクト」の代わりに用語「Javaオブジェクト」を使用します。"
    },
    {
      "indent": 3,
      "text": "Traditionally, LDAP directories have been used to store data. Users and programmers think of the directory as a hierarchy of directory entries, each containing a set of attributes. You look up an entry from the directory and extract the attribute(s) of interest. For example, you can look up a person's telephone number from the directory. Alternatively, you can search the directory for entries with a particular set of attributes. For example, you can search for all persons in the directory with the surname \"Smith\".",
      "ja": "伝統的に、LDAPディレクトリには、データを格納するために使用されています。ユーザーとプログラマは、各属性のセットを含む、ディレクトリエントリの階層としてディレクトリを考えます。あなたは、ディレクトリからエントリを検索し、興味のある属性（複数可）を抽出します。たとえば、ディレクトリからその人の電話番号を調べることができます。また、あなたは、特定の属性セットを持つエントリのためのディレクトリを検索することができます。たとえば、姓「スミス」とディレクトリ内のすべての人のために検索することができます。"
    },
    {
      "indent": 3,
      "text": "For applications written in the Java programming language, a kind of data that is typically shared are Java objects themselves. For such applications, it makes sense to be able to use the directory as a repository for Java objects. The directory provides a centrally administered, and possibly replicated, service for use by Java applications distributed across the network.",
      "ja": "Javaプログラミング言語で書かれたアプリケーションでは、一般的に共有されているデータの種類には、Javaはオブジェクト自体です。このようなアプリケーションの場合は、Javaオブジェクトのリポジトリとしてディレクトリを使用できるようにするには理にかなっています。ディレクトリは、ネットワーク上に分散Javaアプリケーションによる使用のために、集中管理、およびおそらく複製サービスを提供します。"
    },
    {
      "indent": 3,
      "text": "For example, an application server might use the directory for \"registering\" objects representing the services that it manages, so that a client can later search the directory to locate those services as it needs.",
      "ja": "たとえば、アプリケーション・サーバは、クライアントが後でそれが必要としてそれらのサービスを検索するディレクトリを検索できるように、それは、管理サービスを表す「登録」オブジェクトのためのディレクトリを使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "The motivation for this document is to define a common way for applications to store and retrieve Java objects from the directory. Using this common schema, any Java application that needs to read or store Java objects in the directory can do so in an interoperable way.",
      "ja": "このドキュメントのための動機は、ディレクトリからJavaオブジェクトを格納および取得するアプリケーションのための一般的な方法を定義することです。この共通のスキーマを使用して、ディレクトリ内のJavaオブジェクトを読み取るか、保存する必要がある任意のJavaアプリケーションは、相互運用可能な方法で行うことができます。"
    },
    {
      "indent": 0,
      "text": "2 Representation of Java Objects",
      "ja": "Javaオブジェクトの2表現"
    },
    {
      "indent": 3,
      "text": "This document defines schema elements to represent three types of Java objects: a Java serialized object, a Java marshalled object, and a JNDI reference. A Java remote object is stored as either a Java marshalled object or a JNDI reference.",
      "ja": "Javaの直列化されたオブジェクト、Java（登録商標）マーシャリングオブジェクト、およびJNDI参照：このドキュメントでは、Javaオブジェクトの三種類を表すためにスキーマ要素を定義します。 Javaリモートオブジェクトは、JavaオブジェクトマーシャリングまたはJNDI参照のいずれかとして記憶されています。"
    },
    {
      "indent": 0,
      "text": "2.1 Common Representations",
      "section_title": true,
      "ja": "2.1一般的な表現"
    },
    {
      "indent": 3,
      "text": "A Java object is stored in the LDAP directory by using the object class javaObject. This is the base class from which other Java object related classes derive: javaSerializedObject, javaMarshalledObject, and javaNamingReference. javaObject is an abstract object class, which means that a javaObject cannot exist by itself in the directory; only auxiliary or structural subclasses of it can exist in the directory.",
      "ja": "Javaオブジェクトは、オブジェクトクラスの関数javaObjectを使用して、LDAPディレクトリに格納されています。 javaSerializedObject、javaMarshalledObject、およびjavaNamingReferenceを：これは、他のJavaオブジェクトに関連するクラスが派生する基本クラスです。関数javaObjectは、関数javaObjectがディレクトリに単独で存在することができないことを意味する抽象オブジェクト・クラスです。それの補助または構造サブクラスのみがディレクトリに存在することができます。"
    },
    {
      "indent": 3,
      "text": "The object class javaContainer represents a directory entry dedicated to storing a Java object. It is a structural object class. In cases where a subclass of javaObject is mixed in with another structural object class, javaContainer is not required.",
      "ja": "オブジェクトクラスjavaContainerは、Javaオブジェクトを格納する専用のディレクトリエントリを表します。これは、構造化オブジェクトクラスです。関数javaObjectのサブクラスを別の構造化オブジェクト・クラスで混合される場合には、javaContainerが必要とされません。"
    },
    {
      "indent": 3,
      "text": "The definitions for the object classes javaObject and javaContainer are presented in Section 4.",
      "ja": "オブジェクトクラス関数javaObjectとjavaContainerの定義はセクション4に示されています。"
    },
    {
      "indent": 3,
      "text": "The javaObject class has one mandatory attribute (javaClassName) and four optional attributes (javaClassNames, javaCodebase, javaDoc, description). javaClassName is a single valued attribute that is used to store the fully qualified name of the object's Java class (for example, \"java.lang.String\"). This may be the object's most derived class's name, but does not have to be; that of a superclass or interface in some cases might be most appropriate. This attribute is intended for storing the name of the object's \"distinguished\" class, that is, the class or interface with which the object should be identified.",
      "ja": "関数javaObjectクラスは、1つの必須属性（javaClassName）と4つのオプション属性（javaClassNames、javaCodebase、Javadocの説明を）持っています。 javaClassNameは、オブジェクトのJavaクラス（例えば、「java.lang.Stringで」）の完全修飾名を格納するために使用される単一値の属性です。これは、オブジェクトの最も派生クラスの名前かもしれないが、する必要はありません。いくつかのケースでは、スーパークラスまたはインタフェースのことは、最も適切であるかもしれません。この属性は、オブジェクトを識別すべきでクラスまたはインタフェースであるオブジェクトの「区別」クラスの名前を格納するためのものです。"
    },
    {
      "indent": 3,
      "text": "javaClassNames is a multivalued attribute that is used to store the fully qualified names of the object's Java classes and interfaces (for example, \"java.lang.Byte\"). Like all multivalued attributes, the javaClassNames attribute's values are unordered and so no one value is more \"distinguished\" than the others. This attribute is intended for storing an object's class and interface names and those of its ancestor classes and interfaces, although the list of values does not have to be complete. If the javaClassNames attribute is present, it should include the value of javaClassName.",
      "ja": "javaClassNamesは、オブジェクトのJavaクラスおよびインタフェース（例えば、「java.lang.Byteの」）の完全修飾名を格納するために使用される複数値属性です。すべての複数値属性と同じように、javaClassNames属性の値は順不同であり、そう誰も値が他よりも「区別」ではありません。値のリストは完全である必要はありませんが、この属性は、オブジェクトのクラスとインタフェース名とその祖先クラスおよびインタフェースのそれらを格納するためのものです。 javaClassNames属性が存在する場合、それはjavaClassNameの値を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, suppose an object is stored in the directory with a javaClassName attribute of \"java.io.FilePermission\", and a javaClassNames attribute of {\"java.security.Permission\", \"java.io.FilePermission\", \"java.security.Guard\", \"java.io.Serializable\"}. An application searching a directory for Java objects might use javaClassName to produce a summary of the names and types of Java objects in that directory. Another application might use the javaClassNames attribute to find, for example, all java.security.Permission objects.",
      "ja": "例えば、オブジェクトは「java.io.FilePermission」のjavaClassName属性を持つディレクトリに格納され、仮定{「java.security.Permissionの」、「java.io.FilePermission」、「java.securityのjavaClassNames属性.Guard」、 \"java.io.Serializableの\"}。 Javaオブジェクトのディレクトリを検索するアプリケーションは、そのディレクトリ内のJavaオブジェクトの名前とタイプの要約を生成するためにjavaClassNameを使用する場合があります。別の用途は、例えば、javaClassNamesを見つけるために、属性をすべてjava.security.Permissionのオブジェクトを使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "javaCodebase is a multivalued attribute that is used to store the location(s) of the object's class definition. javaDoc is used to store a pointer (URL) to the Java documentation for the class. description is used to store a textual description of a Java object and is defined in [v3Schema]. The definitions of these attributes are presented in Section 3.",
      "ja": "javaCodebaseは、オブジェクトのクラス定義の場所（複数可）を格納するために使用される多値属性です。 Javadocは、クラスのJavaドキュメントへのポインタ（URL）を格納するために使用されます。説明は、Javaオブジェクトのテキスト記述を格納するために使用され、[v3Schema]で定義されています。これらの属性の定義は、第3章で提示されています。"
    },
    {
      "indent": 0,
      "text": "2.2 Serialized Objects",
      "section_title": true,
      "ja": "2.2シリアライズされたオブジェクト"
    },
    {
      "indent": 3,
      "text": "To \"serialize\" an object means to convert its state into a byte stream in such a way that the byte stream can be converted back into a copy of the object. A Java object is \"serializable\" if its class or any of its superclasses implements either the java.io.Serializable interface or its subinterface java.io.Externalizable. \"Deserialization\" is the process of converting the serialized form of an object back into a copy of the object. When an object is serialized, the entire tree of objects rooted at the object is also serialized. When it is deserialized, the tree is reconstructed. For example, suppose a serializable Book object contains (a serializable field of) an array of Page objects. When a Book object is serialized, so is the array of Page objects.",
      "ja": "オブジェクトは、バイトストリームをオブジェクトのコピーに逆変換することができるような方法でバイトストリームにその状態を変換することを意味「シリアライズ」するには。そのクラスまたはそのスーパークラスのいずれかがjava.io.Serializableインタフェースまたはそのサブインターフェイスjava.io.Externalizableのいずれかを実装している場合はJavaオブジェクトは、「直列化可能」です。 「デシリアライゼーションは、」バックオブジェクトのコピーにオブジェクトの直列化形式を変換する処理です。オブジェクトがシリアル化されたときに、オブジェクトをルートオブジェクトのツリー全体もシリアライズされます。それが非直列化されると、ツリーが再構築されます。例えば、直列化可能なブックオブジェクトは（の直列化可能フィールド）ページオブジェクトの配列が含まれていると。 Bookオブジェクトが直列化された場合、そのページオブジェクトの配列です。"
    },
    {
      "indent": 3,
      "text": "The Java platform specifies a default algorithm by which serializable objects are serialized. A Java class can also override this default serialization with its own algorithm. [Serial] describes object serialization in detail.",
      "ja": "Javaプラットフォームは、直列化オブジェクトがシリアライズされるデフォルトアルゴリズムを指定します。 Javaクラスは、独自のアルゴリズムにより、このデフォルトのシリアライズをオーバーライドすることができます。 [シリアル]詳細にオブジェクトのシリアル化を記載しています。"
    },
    {
      "indent": 3,
      "text": "When an object is serialized, information that identifies its class is recorded in the serialized stream. However, the class's definition (\"class file\") itself is not recorded. It is the responsibility of the system that is deserializing the object to determine the mechanism to use for locating and loading the associated class definitions. For example, the Java application might include in its classpath a JAR file containing the class definitions of the serialized object, or load the class definitions using information from the directory, as explained below.",
      "ja": "オブジェクトは、直列化されたときに、そのクラスを識別する情報は、シリアル化さストリームに記録されています。しかし、クラスの定義（「クラスファイル」）自体は記録されません。これは、関連するクラス定義を配置し、ロードするために使用するメカニズムを決定するために、オブジェクトをデシリアライズされたシステムの責任です。例えば、Javaアプリケーションは、そのクラスパスに直列化されたオブジェクトのクラス定義を含むJARファイルが含まれる場合があり、以下に説明するように、ディレクトリからの情報を使用して、クラス定義をロードします。"
    },
    {
      "indent": 0,
      "text": "2.2.1 Representation in the Directory",
      "section_title": true,
      "ja": "Directoryの2.2.1表現"
    },
    {
      "indent": 3,
      "text": "A serialized object is represented in the directory by the attributes javaClassName, javaClassNames, javaCodebase, and javaSerializedData, as defined in Section 3. The mandatory attribute, javaSerializedData, contains the serialized form of the object. Although the serialized form already contains the class name, the mandatory javaClassName attribute also records the class name of the serialized object so that applications can determined class information without having to first deserialize the object. The optional javaClassNames attribute is used to record additional class information about the serialized object. The optional javaCodebase attribute is used to record the locations of the class definitions needed to deserialize the serialized object.",
      "ja": "必須属性、javaSerializedDataは、オブジェクトの直列化された形態を含むセクション3で定義されるように直列化されたオブジェクトは、属性javaClassName、javaClassNames、javaCodebase、及びjavaSerializedDataによってディレクトリに示されています。シリアル化されたフォームは、すでにクラス名が含まれていますが、アプリケーションは最初のオブジェクトをデシリアライズすることなく、クラス情報を判断できるように、必須javaClassName属性もシリアライズされたオブジェクトのクラス名を記録します。オプションのjavaClassNames属性はシリアライズされたオブジェクトに関する追加のクラス情報を記録するために使用されます。オプションのjavaCodebase属性は、直列化されたオブジェクトをデシリアライズするために必要なクラス定義の位置を記録するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A directory entry that contains a serialized object is represented by the object class javaSerializedObject, which is a subclass of javaObject. javaSerializedObject is an auxiliary object class, which means that it needs to be mixed in with a structural object class. javaSerializedObject's definition is given in Section 4.",
      "ja": "直列化されたオブジェクトを含むディレクトリエントリは、関数javaObjectのサブクラスであるオブジェクト・クラスjavaSerializedObject、で表されます。 javaSerializedObjectは、構造化オブジェクト・クラスと混合する必要があることを意味し、補助オブジェクト・クラスです。 javaSerializedObjectの定義は、第4節で与えられています。"
    },
    {
      "indent": 0,
      "text": "2.3 Marshalled Objects",
      "section_title": true,
      "ja": "2.3マーシャリングオブジェクト"
    },
    {
      "indent": 3,
      "text": "To \"marshal\" an object means to record its state and codebase(s) in such a way that when the marshalled object is \"unmarshalled,\" a copy of the original object is obtained, possibly by automatically loading the class definitions of the object. You can marshal any object that is serializable or remote (that is, implements the java.rmi.Remote interface). Marshalling is like serialization, except marshalling also records codebases. Marshalling is different from serialization in that marshalling treats remote objects specially. If an object is a java.rmi.Remote object, marshalling records the remote object's \"stub\" (see Section 2.5), instead of the remote object itself. Like serialization, when an object is marshalled, the entire tree of objects rooted at the object is marshalled. When it is unmarshalled, the tree is reconstructed.",
      "ja": "オブジェクトが整列オブジェクトであるように、その状態とコードベース（S）を記録することを意味する「マーシャル」を「非整列化、」元のオブジェクトのコピーは、おそらく自動的にオブジェクトのクラス定義をロードすることによって、得られます。あなたは（つまり、あるはjava.rmi.Remoteインタフェースを実装）は、シリアライズまたはリモートで任意のオブジェクトをマーシャリングすることができます。マーシャリングもコードベースを記録以外マーシャリングは、直列化のようなものです。マーシャリングは、マーシャリングにシリアライゼーションとは異なる特別なリモートオブジェクトを扱います。オブジェクトがjava.rmi.Remoteインタフェースオブジェクトである場合は、マーシャリングではなく、リモートオブジェクト自体の、（2.5節を参照）がリモートオブジェクトの「スタブ」を記録します。オブジェクトが整列されたときにシリアル化のような、オブジェクトをルートオブジェクトのツリー全体が整列されています。それが非整列化されると、ツリーが再構築されます。"
    },
    {
      "indent": 3,
      "text": "A \"marshalled\" object is the represented by the java.rmi.MarshalledObject class. Here's an example of how to create MarshalledObjects for serializable and remote objects:",
      "ja": "「整列」オブジェクトがjava.rmi.MarshalledObjectクラスによって表されます。ここでは、シリアライズおよびリモートオブジェクトのMarshalledObjectsを作成する方法の例を示します。"
    },
    {
      "indent": 7,
      "text": "java.io.Serializable sobj = ...;\njava.rmi.MarshalledObject mobj1 =\n    new java.rmi.MarshalledObject(sobj);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "java.rmi.Remote robj = ...;\njava.rmi.MarshalledObject mobj2 =\n    new java.rmi.MarshalledObject(robj);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Then, to retrieve the original objects from the MarshalledObjects, do as follows:",
      "ja": "その後、次のようにMarshalledObjectsから元のオブジェクトを取得し、実行します。"
    },
    {
      "indent": 7,
      "text": "java.io.Serializable sobj = (java.io.Serializable) mobj1.get();\njava.io.Remote rstub = (java.io.Remote) mobj2.get();",
      "raw": true
    },
    {
      "indent": 3,
      "text": "MarshalledObject is available only on the Java 2 Platform, Standard Edition, v1.2, and higher releases.",
      "ja": "MarshalledObjectには、Java 2プラットフォーム、標準版、バージョン1.2、およびそれ以降のリリースで提供されています。"
    },
    {
      "indent": 0,
      "text": "2.3.1 Representation in the Directory",
      "section_title": true,
      "ja": "Directoryの2.3.1表現"
    },
    {
      "indent": 3,
      "text": "A marshalled object is represented in the directory by the attributes javaClassName, javaClassNames, and javaSerializedData, as defined in Section 3. The mandatory attribute, javaSerializedData, contains the serialized form of the marshalled object (that is, the serialized form of a MarshalledObject instance). The mandatory javaClassName attribute records the distinguished class name of the object before it has been marshalled. The optional javaClassNames attribute is used to record additional class information about the object before it has been marshalled.",
      "ja": "マーシャリングオブジェクトが属性javaClassName、javaClassNames、及びjavaSerializedDataによってディレクトリで表され、セクション3で定義されるように、必須属性、javaSerializedDataは、整列化オブジェクトの直列化されたフォームを含む（すなわちれるMarshalledObjectのインスタンスの直列化された形式です） 。それが整列化される前に必須javaClassName属性は、オブジェクトの識別クラス名を記録します。オプションのjavaClassNames属性は、それが整列化された前のオブジェクトに関する追加のクラス情報を記録するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A directory entry that contains a marshalled object is represented by the object class javaMarshalledObject, which is a subclass of javaObject. javaMarshalledObject is an auxiliary object class, which means that it needs to be mixed in with a structural object class. javaMarshalledObject's definition is given in Section 4.",
      "ja": "マーシャリングオブジェクトを含むディレクトリエントリは、関数javaObjectのサブクラスであるオブジェクト・クラスjavaMarshalledObject、で表されます。 javaMarshalledObjectは、構造化オブジェクト・クラスと混合する必要があることを意味し、補助オブジェクト・クラスです。 javaMarshalledObjectの定義は、第4節で与えられています。"
    },
    {
      "indent": 3,
      "text": "As evident in this description, a javaMarshalledObject differs from a javaSerializedObject only in the interpretation of the javaClassName and javaClassNames attributes.",
      "ja": "この説明で明らかなように、javaMarshalledObjectはjavaClassNameとjavaClassNames属性の解釈にjavaSerializedObjectとは異なります。"
    },
    {
      "indent": 0,
      "text": "2.4 JNDI References",
      "section_title": true,
      "ja": "2.4 JNDI参照"
    },
    {
      "indent": 3,
      "text": "Java Naming and Directory Interface(tm) (JNDI) is a directory access API specified in the Java programming language [JNDI]. It provides an object-oriented view of the directory, allowing Java objects to be added to and retrieved from the directory without requiring the client to manage data representation issues.",
      "ja": "Javaネーミングとディレクトリインターフェース（TM）（JNDI）は、Javaプログラミング言語[JNDI]で指定されたディレクトリアクセスAPIです。これは、Javaオブジェクトは、データ表現の問題を管理するためのクライアントを必要とせずに添加し、ディレクトリから取得できるように、ディレクトリのオブジェクト指向のビューを提供します。"
    },
    {
      "indent": 3,
      "text": "JNDI defines the notion of a \"reference\" for use when an object cannot be stored in the directory directly, or when it is inappropriate or undesirable to do so. An object with an associated reference is stored in the directory indirectly, by storing its reference instead.",
      "ja": "JNDIは、オブジェクトが直接ディレクトリに格納することができない場合に使用するための「基準」の概念を定義する、またはそれが不適切又は望ましくないときにそうします。関連する参照を持つオブジェクトは、代わりに、その参照を格納することにより、間接的にディレクトリに格納されています。"
    },
    {
      "indent": 0,
      "text": "2.4.1 Contents of a Reference",
      "section_title": true,
      "ja": "リファレンスの内容2.4.1"
    },
    {
      "indent": 3,
      "text": "A JNDI reference is a Java object of class javax.naming.Reference. It consists of class information about the object being referenced and an ordered list of addresses. An address is a Java object of class javax.naming.RefAddr. Each address contains information on how to construct the object.",
      "ja": "JNDI参照は、クラスjavax.naming.ReferenceののJavaオブジェクトです。これは、参照されたオブジェクトとアドレスの順序付きリストに関するクラス情報で構成されています。アドレスは、クラスjavax.naming.RefAddrのJavaオブジェクトです。各アドレスは、オブジェクトを作成する方法についての情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "A common use for JNDI references is to represent connections to a network service such as a database, directory, or file system. Each address may then identify a \"communications endpoint\" for that service, containing information on how to contact the service. Multiple addresses may arise for various reasons, such as replication or the object offering interfaces over more than one communication mechanism.",
      "ja": "JNDI参照の一般的な使用法は、このようなデータベース、ディレクトリ、またはファイルシステムなどのネットワークサービスへの接続を表すためです。各アドレスは、サービスへの連絡方法に関する情報を含む、そのサービスの「通信エンドポイント」を識別することができます。複数のアドレスは、複製または複数の通信機構の上にインターフェイスを提供するオブジェクトのような種々の理由で生じ得ます。"
    },
    {
      "indent": 3,
      "text": "A reference also contains information to assist in the creation of an instance of the object to which the reference refers. It contains the Java class name of that object, and the class name and location of the object factory to be used to create the object. The procedures for creating an object given its reference and the reverse are described in [JNDI].",
      "ja": "参照は、参照の参照先オブジェクトのインスタンスの作成を支援するための情報を含みます。これは、そのオブジェクトのJavaクラス名、およびオブジェクトを作成するために使用するオブジェクトファクトリのクラス名と場所が含まれています。その基準とは逆指定されたオブジェクトを作成するための手順は、[JNDI]に記載されています。"
    },
    {
      "indent": 0,
      "text": "2.4.2 Representation in the Directory",
      "section_title": true,
      "ja": "Directoryの2.4.2表現"
    },
    {
      "indent": 3,
      "text": "A JNDI reference is stored in the directory by using the attributes javaClassName, javaClassNames, javaCodebase, javaReferenceAddress, and javaFactory, defined in Section 3. These attributes store information corresponding to the contents of a reference described above. javaReferenceAddress is a multivalued optional attribute for storing reference addresses. javaFactory is the optional attribute for storing the object factory's fully qualified class name. The mandatory javaClassName attribute is used to store the name of the distinguished class of the object. The optional javaClassNames attribute is used to record additional class and interface names. The optional javaCodebase attribute is used to store the locations of the object factory's and the object's class definitions.",
      "ja": "JNDI参照は、これらの属性は、上記の基準の内容に対応する情報を格納セクション3で定義された属性javaClassName、javaClassNames、javaCodebase、javaReferenceAddress、及びjavaFactoryを使用してディレクトリに格納されています。 javaReferenceAddressは、参照アドレスを格納するための複数値オプションの属性です。 javaFactoryは、オブジェクトファクトリの完全修飾クラス名を格納するためのオプションの属性です。必須javaClassName属性は、オブジェクトの識別クラスの名前を格納するために使用されます。オプションのjavaClassNames属性は、追加のクラスやインタフェースの名前を記録するために使用されます。オプションのjavaCodebase属性は、オブジェクトファクトリのオブジェクトのクラス定義の位置を格納するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A directory entry containing a JNDI reference is represented by the object class javaNamingReference, which is a subclass of javaObject. javaNamingReference is an auxiliary object class, which means that it needs to be mixed in with a structural object class. javaNamingReference's definition is given in Section 4.",
      "ja": "JNDI参照を含むディレクトリエントリは、関数javaObjectのサブクラスであるオブジェクト・クラスjavaNamingReference、で表されます。 javaNamingReferenceは、構造化オブジェクト・クラスと混合する必要があることを意味し、補助オブジェクト・クラスです。 javaNamingReferenceの定義は、第4節で与えられています。"
    },
    {
      "indent": 0,
      "text": "2.5 Remote Objects",
      "section_title": true,
      "ja": "2.5リモートオブジェクト"
    },
    {
      "indent": 3,
      "text": "The Java Remote Method Invocation (RMI) system [RMI] is a mechanism that enables an object on one Java virtual machine to invoke methods on an object in another Java virtual machine. Any object whose methods can be invoked in this way must implement the java.rmi.Remote interface. When such an object is invoked, its arguments are marshalled and sent from the local virtual machine to the remote one, where the arguments are unmarshalled and used. When the method terminates, the results are marshalled from the remote machine and sent to the caller's virtual machine.",
      "ja": "Javaリモートメソッド呼び出し（RMI）システム[RMI]別のJava仮想マシン内のオブジェクトのメソッドを呼び出すために、1台のJava仮想マシン上で物体を可能にするメカニズムです。その方法はjava.rmi.Remoteインタフェースを実装する必要があり、このように呼び出すことができる任意のオブジェクト。そのようなオブジェクトが呼び出されると、その引数がマーシャリング及び引数が非整列化して使用している遠隔一つにローカル仮想マシンから送信されます。メソッドが終了すると、結果がリモートマシンから整列化し、呼び出し側の仮想マシンに送信されます。"
    },
    {
      "indent": 3,
      "text": "To make a remote object accessible to other virtual machines, a program typically registers it with the RMI registry. The program supplies to the RMI registry the string name of the remote object and the remote object itself. When a program wants to access a remote object, it supplies the object's string name to the RMI registry on the same machine as the remote object. The RMI registry returns to the caller a reference (called \"stub\") to the remote object. When the program receives the stub for the remote object, it can invoke methods on the remote object (through the stub). A program can also obtain references to remote objects as a result of remote calls to other remote objects or from other naming services. For example, the program can look up a reference to a remote object from an LDAP server that supports the schema defined in this document.",
      "ja": "他の仮想マシンへのリモートオブジェクトにアクセスできるようにするには、プログラムは通常、RMIレジストリに登録します。リモートオブジェクトのRMIレジストリ文字列の名前とリモートオブジェクト自体にプログラムを供給します。プログラムは、リモートオブジェクトにアクセスしたい場合は、リモートオブジェクトと同じマシン上のRMIレジストリにオブジェクトの文字列名を提供します。 RMIレジストリは、呼び出し元に、リモートオブジェクトへの（「スタブ」と呼ばれる）の参照を返します。プログラムは、リモートオブジェクトのスタブを受信すると、（スタブを介して）リモートオブジェクト上のメソッドを呼び出すことができます。プログラムは、他のリモートオブジェクトへの、または他のネーミングサービスからのリモート呼び出しの結果として、リモートオブジェクトへの参照を取得することができます。例えば、プログラムは、この文書で定義されたスキーマをサポートしているLDAPサーバからリモートオブジェクトへの参照を調べることができます。"
    },
    {
      "indent": 3,
      "text": "The string name accepted by the RMI registry has the syntax \"rmi://hostname:port/remoteObjectName\", where \"hostname\" and \"port\" identify the machine and port on which the RMI registry is running, respectively, and \"remoteObjectName\" is the string name of the remote object. \"hostname\", \"port\", and the prefix, \"rmi:\", are optional. If \"hostname\" is not specified, it defaults to the local host. If \"port\" is not specified, it defaults to 1099. If \"remoteObjectName\" is not specified, then the object being named is the RMI registry itself. See [RMI] for details.",
      "ja": "RMIレジストリが受け付ける文字列名は、構文「RMIを：//ホスト名：ポート/ remoteObjectName」は、「ホスト名」と「ポート」は、それぞれ、RMIレジストリが稼働しているマシンとポートを特定し、「remoteObjectName」リモートオブジェクトの文字列名です。 「ホスト名」、「ポート」、および接頭辞、「RMI：」、オプションです。ローカルホストへの「ホスト名」を指定されていない場合、それがデフォルトになります。 1099への「ポート」を指定されていない場合は、デフォルトで「remoteObjectName」が指定されていない場合、命名されているオブジェクトは、RMIレジストリそのものです。詳細については、[RMI]を参照してください。"
    },
    {
      "indent": 3,
      "text": "RMI can be supported using different protocols: the Java Remote Method Protocol (JRMP) and the Internet Inter-ORB Protocol (IIOP). The JRMP is a specialized protocol designed for RMI; the IIOP is the standard protocol for communication between CORBA objects [CORBA]. RMI over IIOP allows Java remote objects to communicate with CORBA objects which might be written in a non-Java programming language [RMI-IIOP].",
      "ja": "Javaリモートメソッドプロトコル（JRMP）とインターネットORB間プロトコル（IIOP）：RMIは、異なるプロトコルを使用してサポートすることができます。 JRMPは、RMIのために設計された特殊なプロトコルです。 IIOPは、CORBAオブジェクト[CORBA]との間の通信のための標準プロトコルです。 IIOP上のRMIは、Javaリモートオブジェクトは、Java以外のプログラミング言語[RMI-IIOP]に書き込まれるかもしれないCORBAオブジェクトと通信することを可能にします。"
    },
    {
      "indent": 0,
      "text": "2.5.1 Representation in the Directory",
      "section_title": true,
      "ja": "Directoryの2.5.1表現"
    },
    {
      "indent": 3,
      "text": "Remote objects that use the IIOP are represented in the directory as CORBA object references [CORBA-LDAP]. Remote objects that use the JRMP are represented in the directory in one of two ways: as a marshalled object, or as a JNDI reference.",
      "ja": "IIOPを使用するリモートオブジェクトは、CORBAオブジェクト参照[CORBA-LDAP]などのディレクトリで表現されています。 JRMPを使用するリモートオブジェクトは、次のいずれかの方法でディレクトリで表されます。整列化オブジェクトとして、またはJNDIリファレンスとして。"
    },
    {
      "indent": 3,
      "text": "A marshalled object records the codebases of the remote object's stub and any serializable or remote objects that it references, and replaces remote objects with their stubs. To store a Remote object as a marshalled object (java.rmi.MarshalledObject), you first create a java.rmi.MarshalledObject instance for it.",
      "ja": "整列化されたオブジェクトは、リモートオブジェクトのスタブとそれが参照する任意のシリアル化可能またはリモートオブジェクトのコードベースを記録し、そのスタブとリモートオブジェクトを置き換えます。整列化されたオブジェクト（java.rmi.MarshalledObject）としてリモートオブジェクトを格納するには、まずそれをjava.rmi.MarshalledObjectインスタンスを作成します。"
    },
    {
      "indent": 7,
      "text": "java.rmi.Remote robj = ...;\njava.rmi.MarshalledObject mobj =\n    new java.rmi.MarshalledObject(robj);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "You can then store the MarshalledObject instance as a javaMarshalledObject. The javaClassName attribute should contain the fully qualified name of the distinguished class of the remote object. The javaClassNames attribute should contain the names of the classes and interfaces of the remote object. To read the remote object back from the directory, first deserialize the contents of the javaSerializedData to get a MarshalledObject (mobj), then retrieve it from the MarshalledObject as follows:",
      "ja": "その後、javaMarshalledObjectとしてMarshalledObjectとインスタンスを格納することができます。 javaClassName属性は、リモートオブジェクトの識別クラスの完全修飾名を含める必要があります。 javaClassNames属性は、リモートオブジェクトのクラスとインタフェースの名前が含まれている必要があります。次のようにバックディレクトリからリモートオブジェクトを読み取るには、まずれるMarshalledObject（MOBJ）を取得するためにjavaSerializedDataの内容をデシリアライズ、そしてれるMarshalledObjectからそれを取り出します。"
    },
    {
      "indent": 7,
      "text": "java.rmi.Remote robj = (java.rmi.Remote)mobj.get();",
      "ja": "java.rmi.Remote robj =（はjava.rmi.Remote）mobj.get（）;"
    },
    {
      "indent": 3,
      "text": "This returns the remote stub, which you can then use to invoke remote methods.",
      "ja": "これは、リモートメソッドを呼び出すために使用できるリモートスタブを返します。"
    },
    {
      "indent": 3,
      "text": "MarshalledObject is available only on the Java 2 Platform, Standard Edition, v1.2 and higher releases. Therefore, a remote object stored as a MarshalledObject can only be read by clients using the the Java 2 Platform, Standard Edition, v1.2 or higher releases.",
      "ja": "MarshalledObjectには、Java 2プラットフォーム、標準版、バージョン1.2およびそれ以降のリリースで提供されています。したがって、れるMarshalledObjectとして格納されたリモートオブジェクトは、Java 2プラットフォーム、標準版、バージョン1.2以降のリリースを使用しているクライアントによって読み取ることができます。"
    },
    {
      "indent": 3,
      "text": "To store a remote object as a JNDI reference, you first create a javax.naming.Reference object instance for it using the remote object's string name as it has been, or will be, recorded with the RMI registry, with the additional restriction that the \"rmi:\" prefix must be present. Here's an example:",
      "ja": "JNDI参照としてリモートオブジェクトを格納するには、それがあったように、あなたは最初にリモートオブジェクトの文字列名を使用して、それのためのjavax.naming.Referenceのオブジェクトのインスタンスを作成するか、または、追加の制限で、RMIレジストリに記録されますこと「RMI：」接頭辞が存在しなければなりません。ここでは例を示します。"
    },
    {
      "indent": 7,
      "text": "javax.naming.Reference ref = new javax.naming.Reference(\n  obj.getClass().getName(),\n  new javax.naming.StringRefAddr(\"URL\",\n      \"rmi://rserver/AppRemoteObjectX\"));",
      "raw": true
    },
    {
      "indent": 3,
      "text": "You then store the javax.naming.Reference instance as a javaNamingReference. The advantage of using a JNDI reference is that this can be done without a reference to the remote object. In fact, the remote object does not have to exist at the time that this recording in the directory is made. The remote object needs to exist and be bound with the RMI registry when the object is looked up from the directory.",
      "ja": "その後、javaNamingReferenceとしてjavax.naming.Referenceのインスタンスを格納します。 JNDI参照を使用する利点は、これがリモートオブジェクトを参照することなく行うことができることです。実際には、リモートオブジェクトは、ディレクトリにこの記録が行われた時点で存在している必要はありません。リモートオブジェクトが存在すると、オブジェクトがディレクトリから検索されRMIレジストリにバインドする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.6 Serialized Objects Vs. Marshalled Objects Vs. References",
      "section_title": true,
      "ja": "2.6シリアライズされたオブジェクト対。整列化されたオブジェクトの対。リファレンス"
    },
    {
      "indent": 3,
      "text": "The object classes defined in this document store different aspects of the Java objects.",
      "ja": "オブジェクトクラスは、Javaオブジェクトのこのドキュメントストアさまざまな側面で定義されています。"
    },
    {
      "indent": 3,
      "text": "A javaSerializedObject or a serializable object stored as a javaMarshalledObject represents the object itself, while a javaNamingReference or a remote object stored as a javaMarshalledObject represents a \"pointer\" to the object.",
      "ja": "javaNamingReference又はjavaMarshalledObjectとして格納されているリモートオブジェクトがオブジェクトへの「ポインタ」を表しているjavaSerializedObject又はjavaMarshalledObjectとして格納シリアライズオブジェクトは、オブジェクト自体を表します。"
    },
    {
      "indent": 3,
      "text": "When storing a serializable object in the directory, you have a choice of storing it as a javaSerializedObject or a javaMarshalledObject. The javaSerializedObject object class provides the basic way in which to store serializable objects. When you create an LDAP entry using the javaSerializableObject object class, you must explicitly set the javaCodebase attribute if you want readers of that entry to know where to load the class definitions of the object. When you create an LDAP entry using the javaMarshalledObject object class, you use the MarshalledObject class. The MarshalledObject class uses the RMI infrastructure available on the Java platform to automate how codebase information is gathered and recorded, thus freeing you from having to set the javaCodebase attribute. On the other hand, the javaCodebase attribute is human-readable and can be updated easily by using text-based tools without having to change other parts of the entry. This allows you, for instance, to move the class definitions to another location and then update the javaCodebase attribute to reflect the move without having to update the serialized object itself.",
      "ja": "ディレクトリ内の直列化可能なオブジェクトを格納するときは、javaSerializedObjectやjavaMarshalledObjectとしてそれを保存するかを選択できます。 javaSerializedObjectオブジェクトクラスは、直列化可能オブジェクトを格納するための基本的な方法を提供します。あなたはjavaSerializableObjectオブジェクトクラスを使用してLDAPエントリを作成するときは、そのエントリの読者はどこオブジェクトのクラス定義をロードするために知りたい場合は、明示的にjavaCodebase属性を設定する必要があります。あなたはjavaMarshalledObjectオブジェクトクラスを使用してLDAPエントリを作成するときは、MarshalledObjectとクラスを使用します。 MarshalledObjectとクラスは、このようにjavaCodebase属性を設定することからあなたを解放し、収集し、記録する方法のコードベースの情報を自動化するためのJavaプラットフォーム上で利用可能RMIインフラストラクチャを使用しています。一方、javaCodebase属性は、人間が読めるし、エントリの他の部分を変更することなく、テキストベースのツールを使って簡単に更新することができます。これは、あなたが別の場所にクラス定義を移動して、シリアライズされたオブジェクト自体を更新することなく、動きを反映するためにjavaCodebase属性を更新するために、たとえば、ことができます。"
    },
    {
      "indent": 3,
      "text": "A javaNamingReference provides a way of recording address information about an object which itself is not directly stored in the directory. A remote object stored as a javaMarshalledObject also records address information (the object's \"stub\") of an object which itself is not directory stored in the directory. In other words, you can think of these as compact representations of the information required to access the object.",
      "ja": "javaNamingReferenceは、それ自体が直接ディレクトリに格納されていないオブジェクトのアドレス情報を記録する方法を提供します。 javaMarshalledObjectとして格納されたリモートオブジェクトは、ディレクトリに格納されたディレクトリではない、それ自体オブジェクトのアドレス情報（オブジェクトの「スタブ」）を記録します。言い換えれば、あなたは、オブジェクトにアクセスするために必要な情報のコンパクト表現としてこれらを考えることができます。"
    },
    {
      "indent": 3,
      "text": "A javaNamingReference typically consists of a small number of human-readable strings. Standard text-based tools for directory administration may therefore be used to add, read, or modify reference entries -- if so desired -- quite easily. Serialized and marshalled objects are not intended to be read or manipulated directly by humans.",
      "ja": "javaNamingReferenceは通常、人間が読める形式の文字列の数が少ないから構成されています。所望であれば -   - 非常に簡単ディレクトリ管理のための標準的なテキストベースのツールは、従って、追加読み取り、または基準のエントリを変更するために使用することができます。直列化と整列化されたオブジェクトを読み取るか、人間が直接操作することを意図していません。"
    },
    {
      "indent": 0,
      "text": "3 Attribute Type Definitions",
      "ja": "3つの属性タイプの定義"
    },
    {
      "indent": 3,
      "text": "The following attribute types are defined in this document:",
      "ja": "次の属性タイプは、この文書で定義されています。"
    },
    {
      "indent": 7,
      "text": "javaClassName\njavaClassNames\njavaCodebase\njavaSerializedData\njavaFactory\njavaReferenceAddress\njavaDoc",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1 javaClassName",
      "section_title": true,
      "ja": "3.1 javaClassName"
    },
    {
      "indent": 3,
      "text": "This attribute stores the fully qualified name of the Java object's \"distinguished\" class or interface (for example, \"java.lang.String\"). It is a single-valued attribute. This attribute's syntax is ' Directory String' and its case is significant.",
      "ja": "この属性は、Javaオブジェクトの「区別」クラスまたはインタフェース（例えば、「java.lang.Stringで」）の完全修飾名を格納します。これは、単一値の属性です。この属性の構文は、「ディレクトリ文字列」であり、その場合は重要です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.6\n  NAME 'javaClassName'\n  DESC 'Fully qualified name of distinguished Java class or\n        interface'\n  EQUALITY caseExactMatch\n  SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n  SINGLE-VALUE\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2 javaCodebase",
      "section_title": true,
      "ja": "3.2 javaCodebase"
    },
    {
      "indent": 3,
      "text": "This attribute stores the Java class definition's locations. It specifies the locations from which to load the class definition for the class specified by the javaClassName attribute. Each value of the attribute contains an ordered list of URLs, separated by spaces. For example, a value of \"url1 url2 url3\" means that the three (possibly interdependent) URLs (url1, url2, and url3) form the codebase for loading in the Java class definition.",
      "ja": "この属性は、Javaクラス定義の場所を格納します。それはjavaClassName属性で指定されたクラスのクラス定義をロードするために、そこから場所を指定します。属性の各値はスペースで区切られたURLの順序付きリストが含まれています。例えば、「URL1 URL2 URL3」の値は3（おそらく相互に依存する）のURL（URL1、URL2、URL3とは）、Javaクラス定義のローディングのためのコードベースを形成することを意味します。"
    },
    {
      "indent": 3,
      "text": "If the javaCodebase attribute contains more than one value, each value is an independent codebase. That is, there is no relationship between the URLs in one value and those in another; each value can be viewed as an alternate source for loading the Java class definition. See [Java] for information regarding class loading.",
      "ja": "javaCodebase属性が複数の値が含まれている場合は、各値は、独立したコードベースです。すなわち、一つの値内のURLと他のものとの間には関係がない、です。各値は、Javaクラス定義をロードするための代替ソースと見なすことができます。クラスのロードに関する情報については、[Javaの]を参照してください。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'IA5 String' and its case is significant.",
      "ja": "この属性の構文は、「IA5文字列」であり、その場合は重要です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.7\n  NAME 'javaCodebase'\n  DESC 'URL(s) specifying the location of class definition'\n  EQUALITY caseExactIA5Match\n  SYNTAX 1.3.6.1.4.1.1466.115.121.1.26\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3 javaClassNames",
      "section_title": true,
      "ja": "3.3 javaClassNames"
    },
    {
      "indent": 3,
      "text": "This attribute stores the Java object's fully qualified class or interface names (for example, \"java.lang.String\"). It is a multivalued attribute. When more than one value is present, each is the name of a class or interface, or ancestor class or interface, of this object.",
      "ja": "この属性は、Javaオブジェクトの完全修飾クラスまたはインタフェースの名前（例えば、「java.lang.Stringで」）を格納します。これは、複数値属性です。複数の値が存在する場合、各々は、このオブジェクトのクラスまたはインタフェースの名前、または先祖クラスまたはインタフェースです。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Directory String' and its case is significant.",
      "ja": "この属性の構文は、「ディレクトリ文字列」であり、その場合は重要です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.13\n  NAME 'javaClassNames'\n  DESC 'Fully qualified Java class or interface name'\n  EQUALITY caseExactMatch\n  SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.4 javaSerializedData",
      "section_title": true,
      "ja": "3.4 javaSerializedData"
    },
    {
      "indent": 3,
      "text": "This attribute stores the serialized form of a Java object. The serialized form is described in [Serial].",
      "ja": "この属性は、Javaオブジェクトの直列化された形式を格納します。直列化された形式は、[シリアル]に記載されています。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Octet String'.",
      "ja": "この属性の構文は、「オクテット文字列」です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.8\n  NAME 'javaSerializedData\n  DESC 'Serialized form of a Java object'\n  SYNTAX 1.3.6.1.4.1.1466.115.121.1.40\n  SINGLE-VALUE\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.5 javaFactory",
      "section_title": true,
      "ja": "3.5 javaFactory"
    },
    {
      "indent": 3,
      "text": "This attribute stores the fully qualified class name of the object factory (for example, \"com.wiz.jndi.WizObjectFactory\") that can be used to create an instance of the object identified by the javaClassName attribute.",
      "ja": "この属性は、javaClassName属性によって識別されるオブジェクトのインスタンスを作成するために使用できるオブジェクトファクトリ（例えば、「com.wiz.jndi.WizObjectFactory」）の完全修飾クラス名を格納します。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Directory String' and its case is significant.",
      "ja": "この属性の構文は、「ディレクトリ文字列」であり、その場合は重要です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.10\n  NAME 'javaFactory'\n  DESC 'Fully qualified Java class name of a JNDI object factory'\n  EQUALITY caseExactMatch\n  SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n  SINGLE-VALUE\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.6 javaReferenceAddress",
      "section_title": true,
      "ja": "3.6 javaReferenceAddress"
    },
    {
      "indent": 3,
      "text": "This attribute represents the sequence of addresses of a JNDI reference. Each of its values represents one address, a Java object of type javax.naming.RefAddr. Its value is a concatenation of the address type and address contents, preceded by a sequence number (the order of addresses in a JNDI reference is significant). For example:",
      "ja": "この属性は、JNDI参照のアドレスのシーケンスを表します。その値の各々は、1つのアドレス、タイプjavax.naming.RefAddrのJavaオブジェクトを表します。その値は、シーケンス番号（JNDI参照内のアドレスの順序は重要である）が先行アドレスタイプおよびアドレスの内容の連結です。例えば："
    },
    {
      "indent": 7,
      "text": "#0#TypeA#ValA\n#1#TypeB#ValB\n#2#TypeC##rO0ABXNyABpq...",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In more detail, the value is encoded as follows:",
      "ja": "以下のようにより詳細には、値が符号化されます。"
    },
    {
      "indent": 3,
      "text": "The delimiter is the first character of the value. For readability the character '#' is recommended when it is not otherwise used anywhere in the value, but any character may be used subject to restrictions given below.",
      "ja": "区切り文字は、値の最初の文字です。読みやすくするために、文字「＃」がそれがそうでない場合、値のどこでも使用されていない場合に推奨されますが、任意の文字は、下記の制限の対象に使用することができます。"
    },
    {
      "indent": 3,
      "text": "The first delimiter is followed by the sequence number. The sequence number of an address is its position in the JNDI reference, with the first address being numbered 0. It is represented by its shortest string form, in decimal notation.",
      "ja": "最初の区切りは、シーケンス番号が続きます。これは10進数表記で、その最短の文字列形式で表され、最初のアドレスが0の番号を付けた状態で、アドレスのシーケンス番号は、JNDI参照内の位置です。"
    },
    {
      "indent": 3,
      "text": "The sequence number is followed by a delimiter, then by the address type, and then by another delimiter. If the address is of Java class javax.naming.StringRefAddr, then this delimiter is followed by the value of the address contents (which is a string). Otherwise, this delimiter is followed immediately by another delimiter, and then by the Base64 encoding of the serialized form of the entire address.",
      "ja": "シーケンス番号は、アドレスの種類によって、そして次に別の区切り文字で、デリミタが続きます。アドレスは、Javaクラスjavax.naming.StringRefAddrである場合、この区切り文字は（文字列である）アドレスの内容の値が続きます。そうでなければ、この区切り文字がすぐに別の区切り文字によって、その後アドレス全体の直列化形式のBase64エンコーディングが続きます。"
    },
    {
      "indent": 3,
      "text": "The delimiter may be any character other than a digit or a character contained in the address type. In addition, if the address contents is a string, the delimiter may not be the first character of that string.",
      "ja": "デリミタは、数字またはアドレスの種類に含まれる文字以外の文字であってもよいです。アドレスの内容が文字列である場合に加えて、区切り文字は、その文字列の最初の文字ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'Directory String' and its case is significant. It can contain multiple values.",
      "ja": "この属性の構文は、「ディレクトリ文字列」であり、その場合は重要です。これは、複数の値を含めることができます。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.11\n  NAME 'javaReferenceAddress'\n  DESC 'Addresses associated with a JNDI Reference'\n  EQUALITY caseExactMatch\n  SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.7 javaDoc",
      "section_title": true,
      "ja": "3.7のJavadoc"
    },
    {
      "indent": 3,
      "text": "This attribute stores a pointer to the Java documentation for the class. It's value is a URL. For example, the following URL points to the specification of the java.lang.String class: http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html",
      "ja": "この属性は、クラスのJavaドキュメントへのポインタを格納します。これは、URLの値です。たとえば、java.lang.Stringクラスの仕様に次のURLのポイント：http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html"
    },
    {
      "indent": 3,
      "text": "This attribute's syntax is 'IA5 String' and its case is significant.",
      "ja": "この属性の構文は、「IA5文字列」であり、その場合は重要です。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.12\n  NAME 'javaDoc'\n  DESC 'The Java documentation for the class'\n  EQUALITY caseExactIA5Match\n  SYNTAX 1.3.6.1.4.1.1466.115.121.1.26\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4 Object Class Definitions",
      "ja": "4つのオブジェクトクラス定義"
    },
    {
      "indent": 3,
      "text": "The following object classes are defined in this document:",
      "ja": "次のオブジェクト・クラスは、この文書で定義されています。"
    },
    {
      "indent": 7,
      "text": "javaContainer\njavaObject\njavaSerializedObject\njavaMarshalledObject\njavaNamingReference",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.1 javaContainer",
      "section_title": true,
      "ja": "4.1 javaContainer"
    },
    {
      "indent": 3,
      "text": "This structural object class represents a container for a Java object.",
      "ja": "この構造的なオブジェクトのクラスは、Javaオブジェクトのコンテナを表します。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.1\n  NAME 'javaContainer'\n  DESC 'Container for a Java object'\n  SUP top\n  STRUCTURAL\n  MUST ( cn )\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2 javaObject",
      "section_title": true,
      "ja": "4.2関数javaObject"
    },
    {
      "indent": 3,
      "text": "This abstract object class represents a Java object. A javaObject cannot exist in the directory; only auxiliary or structural subclasses of it can exist in the directory.",
      "ja": "この抽象オブジェクトクラスは、Javaオブジェクトを表します。関数javaObjectは、ディレクトリに存在することはできません。それの補助または構造サブクラスのみがディレクトリに存在することができます。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.4\n  NAME 'javaObject'\n  DESC 'Java object representation'\n  SUP top\n  ABSTRACT\n  MUST ( javaClassName )\n  MAY ( javaClassNames $\n        javaCodebase $\n        javaDoc $\n        description )\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3 javaSerializedObject",
      "section_title": true,
      "ja": "4.3 javaSerializedObject"
    },
    {
      "indent": 3,
      "text": "This auxiliary object class represents a Java serialized object. It must be mixed in with a structural object class.",
      "ja": "この補助オブジェクトクラスは、Javaのシリアライズされたオブジェクトを表します。これは、構造化オブジェクトクラスで混合しなければなりません。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.5\n  NAME 'javaSerializedObject'\n  DESC 'Java serialized object'\n  SUP javaObject\n  AUXILIARY\n  MUST ( javaSerializedData )\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.4 javaMarshalledObject",
      "section_title": true,
      "ja": "4.4 javaMarshalledObject"
    },
    {
      "indent": 3,
      "text": "This auxiliary object class represents a Java marshalled object. It must be mixed in with a structural object class.",
      "ja": "この補助オブジェクトクラスは、Javaの整列化されたオブジェクトを表します。これは、構造化オブジェクトクラスで混合しなければなりません。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.8\n  NAME 'javaMarshalledObject'\n  DESC 'Java marshalled object'\n  SUP javaObject\n  AUXILIARY\n  MUST ( javaSerializedData )\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5 javaNamingReference",
      "section_title": true,
      "ja": "4.5 Jvnamingareferens"
    },
    {
      "indent": 3,
      "text": "This auxiliary object class represents a JNDI reference. It must be mixed in with a structural object class.",
      "ja": "この補助オブジェクト・クラスは、JNDI参照を表します。これは、構造化オブジェクトクラスで混合しなければなりません。"
    },
    {
      "indent": 7,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.7\n  NAME 'javaNamingReference'\n  DESC 'JNDI reference'\n  SUP javaObject\n  AUXILIARY\n  MAY ( javaReferenceAddress $\n        javaFactory )\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "Serializing an object and storing it into the directory enables (a copy of) the object to be examined and used outside the environment in which it was originally created. The directory entry containing the serialized object could be read and modified within the constraints imposed by the access control mechanisms of the directory. If an object contains sensitive information or information that could be misused outside of the context in which it was created, the object should not be stored in the directory. For more details on security issues relating to serialization in general, see [Serial].",
      "ja": "オブジェクトをシリアル化し、ディレクトリにそれを格納するオブジェクトを調べ、それが最初に作成された環境の外部で使用される（のコピー）が可能となります。直列化されたオブジェクトを含むディレクトリエントリが読み出され、ディレクトリのアクセス制御機構によって課される制約の範囲内で変更することができます。オブジェクトはそれが作成されたコンテキストの外に悪用される可能性があり、機密情報または情報が含まれている場合は、オブジェクトは、ディレクトリに格納されているべきではありません。一般的にシリアライズに関連するセキュリティ上の問題の詳細については、[シリアル]を参照してください。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgements",
      "section_title": true,
      "ja": "6.謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Joseph Fialli, Peter Jones, Roger Riggs, Bob Scheifler, and Ann Wollrath of Sun Microsystems for their comments and suggestions.",
      "ja": "我々は彼らのコメントや提案をジョセフFialli、ピーター・ジョーンズ、ロジャー・リッグス、ボブScheifler、およびSun Microsystems社のアンWollrathに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 3,
      "text": "[CORBA] The Object Management Group, \"Common Object Request Broker Architecture Specification 2.0,\" http://www.omg.org",
      "ja": "[CORBA]オブジェクト・マネジメント・グループ、「共通オブジェクト・リクエスト・ブローカ・アーキテクチャ仕様2.0、」http://www.omg.org"
    },
    {
      "indent": 3,
      "text": "[CORBA-LDAP] Ryan, V., Lee, R. and S. Seligman, \"Schema for Representing CORBA Object References in an LDAP Directory\", RFC 2714, October 1999.",
      "ja": "[CORBA-LDAP]ライアン、V.、リー、R.とS.セリグマン、 \"LDAPディレクトリのCORBAオブジェクト参照を表すためのスキーマ\"、RFC 2714、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[Java] Ken Arnold and James Gosling, \"The Java(tm) Programming Language,\" Second Edition, ISBN 0-201-31006-6.",
      "ja": "[Javaの]ケン・アーノルドとジェームズ・ゴスリング、第2版、ISBN 0-201-31006-6の \"Java（TM）は言語、プログラミング\"。"
    },
    {
      "indent": 3,
      "text": "[JNDI] Java Software, Sun Microsystems, Inc., \"The Java(tm) Naming and Directory Interface (tm) Specification,\" February 1998. http://java.sun.com/products/jndi/",
      "ja": "[JNDI] Javaソフトウェア、サン・マイクロシステムズ社、 \"ジャワ（tm）のネーミングとディレクトリインタフェース（TM）仕様、\" 1998年2月http://java.sun.com/products/jndi/"
    },
    {
      "indent": 3,
      "text": "[LDAPv3] Wahl, M., Howes, T. and S. Kille, \"Lightweight Directory Access Protocol (v3)\", RFC 2251, December 1997.",
      "ja": "【のLDAPv3]ワール、M.、ハウズ、T.およびS. Kille、 \"軽量のディレクトリアクセスプロトコル（V3）\"、RFC 2251、1997年12月。"
    },
    {
      "indent": 3,
      "text": "[RMI] Java Software, Sun Microsystems, Inc., \"Remote Method Invocation,\" November 1998. http://java.sun.com/products/jdk/1.2/docs/guide/rmi",
      "ja": "[RMI] Javaソフトウェア、サン・マイクロシステムズ社、「リモートメソッド呼び出し、」1998年11月http://java.sun.com/products/jdk/1.2/docs/guide/rmi"
    },
    {
      "indent": 3,
      "text": "[RMI-IIOP] IBM and Java Software, Sun Microsystems, Inc., \"RMI over IIOP\", June 1999. http://java.sun.com/products/rmi-iiop/",
      "ja": "[RMI-IIOP] IBMとJavaソフトウェア、サン・マイクロシステムズ社、 \"IIOPオーバーRMI\"、1999年6月http://java.sun.com/products/rmi-iiop/"
    },
    {
      "indent": 3,
      "text": "[Serial] Java Software, Sun Microsystems, Inc., \"Object Serialization Specification,\" November 1998. http://java.sun.com/products/jdk/1.2/docs/guide/ serialization",
      "ja": "[シリアル] Javaソフトウェア、サン・マイクロシステムズ社、「オブジェクト直列化仕様、」1998年11月http://java.sun.com/products/jdk/1.2/docs/guide/のシリアライズ"
    },
    {
      "indent": 3,
      "text": "[v3Schema] Wahl, M., \"A Summary of the X.500(96) User Schema for use with LDAPv3\", RFC 2256, December 1997.",
      "ja": "【v3Schema】ワール、M.、 \"のLDAPv3で使用するためのX.500（96）ユーザスキーマの概要\"、RFC 2256、1997年12月。"
    },
    {
      "indent": 0,
      "text": "8. Authors' Addresses",
      "section_title": true,
      "ja": "8.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Vincent Ryan Sun Microsystems, Inc. Mail Stop EDUB03 901 San Antonio Road Palo Alto, CA 94303 USA",
      "ja": "ヴィンセントライアンサン・マイクロシステムズ株式会社メールストップEDUB03 901サンアントニオの道パロアルト、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +353 1 819 9151 EMail: vincent.ryan@ireland.sun.com",
      "ja": "電話：+353 1 819 9151 Eメール：vincent.ryan@ireland.sun.com"
    },
    {
      "indent": 3,
      "text": "Scott Seligman Sun Microsystems, Inc. Mail Stop UCUP02-209 901 San Antonio Road Palo Alto, CA 94303 USA",
      "ja": "スコット・セリグマンサン・マイクロシステムズ株式会社メールストップUCUP02-209 901サンアントニオの道パロアルト、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 863 3222 EMail: scott.seligman@eng.sun.com",
      "ja": "電話：+1 408 863 3222 Eメール：scott.seligman@eng.sun.com"
    },
    {
      "indent": 3,
      "text": "Rosanna Lee Sun Microsystems, Inc. Mail Stop UCUP02-206 901 San Antonio Road Palo Alto, CA 94303 USA",
      "ja": "ロザンナ・リーサン・マイクロシステムズ株式会社メールストップUCUP02-206 901サンアントニオの道パロアルト、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 863 3221 EMail: rosanna.lee@eng.sun.com",
      "ja": "電話：+1 408 863 3221 Eメール：rosanna.lee@eng.sun.com"
    },
    {
      "indent": 0,
      "text": "Appendix - LDAP Schema",
      "ja": "付録 -  LDAPスキーマ"
    },
    {
      "indent": 2,
      "text": "-- Attribute types --",
      "ja": " - 属性タイプ - "
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.6 NAME 'javaClassName' DESC 'Fully qualified name of distinguished Java class or interface' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
      "ja": "（平等CaseExactMatchのSYNTAX 1.3.6.1.4.1.42.2.27.4.1.6 NAME「javaClassName」DESC「区別Javaクラスまたはインタフェースの完全修飾名」1.3.6.1.4.1.1466.115.121.1.15単一値）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.7 NAME 'javaCodebase' DESC 'URL(s) specifying the location of class definition' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 )",
      "ja": "（平等caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 'クラス定義の場所を特定するURL（S）' 1.3.6.1.4.1.42.2.27.4.1.7 NAME 'javaCodebase' DESC）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.8 NAME 'javaSerializedData' DESC 'Serialized form of a Java object' SYNTAX 1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE )",
      "ja": "（1.3.6.1.4.1.42.2.27.4.1.8名前構文1.3.6.1.4.1.1466.115.121.1.40 SINGLE-VALUE 'javaSerializedData' DESC 'Javaオブジェクトの直列化形式'）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.10 NAME 'javaFactory' DESC 'Fully qualified Java class name of a JNDI object factory' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE )",
      "ja": "（1.3.6.1.4.1.42.2.27.4.1.10 NAME 'javaFactory' DESC 'JNDIオブジェクトファクトリの完全修飾Javaクラス名が' 平等CaseExactMatchのSYNTAX 1.3.6.1.4.1.1466.115.121.1.15 SINGLE-VALUE）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.11 NAME 'javaReferenceAddress' DESC 'Addresses associated with a JNDI Reference' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "ja": "（平等CaseExactMatchのSYNTAX 1.3.6.1.4.1.1466.115.121.1.15 1.3.6.1.4.1.42.2.27.4.1.11 NAME 'javaReferenceAddress' DESC 'JNDIリファレンスに関連付けられたアドレス'）"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.1.12 NAME 'javaDoc' DESC 'The Java documentation for the class' EQUALITY caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 ) ( 1.3.6.1.4.1.42.2.27.4.1.13 NAME 'javaClassNames' DESC 'Fully qualified Java class or interface name' EQUALITY caseExactMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "ja": "（1.3.6.1.4.1.42.2.27.4.1.12 NAME 'のJavadoc' DESC 'クラスのJavaドキュメント' 平等caseExactIA5Match SYNTAX 1.3.6.1.4.1.1466.115.121.1.26）（1.3.6.1.4.1.42.2.27.4 .1.13 NAME 'javaClassNames' DESC '完全修飾Javaクラスやインタフェース名' EQUALITY CaseExactMatchのSYNTAX 1.3.6.1.4.1.1466.115.121.1.15）"
    },
    {
      "indent": 2,
      "text": "-- from RFC-2256 --",
      "ja": " -  RFC-2256から - "
    },
    {
      "indent": 2,
      "text": "( 2.5.4.13 NAME 'description' EQUALITY caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{1024} )",
      "ja": "（2.5.4.13 NAME '記述' 平等caseIgnoreMatch SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 {1024}）"
    },
    {
      "indent": 2,
      "text": "-- Object classes --",
      "ja": " - オブジェクトのクラス - "
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.1 NAME 'javaContainer' DESC 'Container for a Java object' SUP top STRUCTURAL MUST ( cn ) )",
      "ja": "（1.3.6.1.4.1.42.2.27.4.2.1 NAME 'javaContainer' DESC 'Javaオブジェクトのコンテナ' SUPトップSTRUCTURAL MUST（CN））"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.4 NAME 'javaObject' DESC 'Java object representation' SUP top ABSTRACT MUST ( javaClassName ) MAY ( javaClassNames $ javaCodebase $ javaDoc $ description ) )",
      "ja": "（1.3.6.1.4.1.42.2.27.4.2.4 NAME '関数javaObject' DESC 'Javaオブジェクト表現' SUPトップABSTRACT MUST（javaClassName）MAY（javaClassNames $ javaCodebase $のJavadoc $の説明））"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.5 NAME 'javaSerializedObject' DESC 'Java serialized object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) ) ( 1.3.6.1.4.1.42.2.27.4.2.7 NAME 'javaNamingReference' DESC 'JNDI reference' SUP javaObject AUXILIARY MAY ( javaReferenceAddress $ javaFactory ) )",
      "ja": "（1.3.6.1.4.1.42.2.27.4.2.5 NAME 'javaSerializedObject' DESCのJava直列化オブジェクト 'SUP関数javaObject AUXILIARY MUST（javaSerializedData））（1.3.6.1.4.1.42.2.27.4.2.7 NAME 'javaNamingReference' DESC「JNDI参照「SUP関数javaObject補助MAY（javaReferenceAddress $ javaFactory））"
    },
    {
      "indent": 2,
      "text": "( 1.3.6.1.4.1.42.2.27.4.2.8 NAME 'javaMarshalledObject' DESC 'Java marshalled object' SUP javaObject AUXILIARY MUST ( javaSerializedData ) )",
      "ja": "（1.3.6.1.4.1.42.2.27.4.2.8 NAME 'javaMarshalledObject' DESCのJava整列オブジェクト 'SUP関数javaObject AUXILIARY MUST（javaSerializedData））"
    },
    {
      "indent": 2,
      "text": "-- Matching rule from ISO X.520 --",
      "ja": " -  ISOのX.520からマッチングルール - "
    },
    {
      "indent": 2,
      "text": "( 2.5.13.5 NAME 'caseExactMatch' SYNTAX 1.3.6.1.4.1.1466.115.121.1.15 )",
      "ja": "（2.5.13.5 NAME 'CaseExactMatchの' SYNTAX 1.3.6.1.4.1.1466.115.121.1.15）"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1999). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1999）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}