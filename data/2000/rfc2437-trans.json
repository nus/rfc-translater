{
  "title": {
    "text": "RFC 2437 - PKCS #1: RSA Cryptography Specifications Version 2.0",
    "ja": "RFC 2437 - PKCS＃1：RSA暗号仕様バージョン2.0"
  },
  "number": 2437,
  "created_at": "2019-10-24 14:50:13.178544+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         B. Kaliski\nRequest for Comments: 2437                                    J. Staddon\nObsoletes: 2313                                         RSA Laboratories\nCategory: Informational                                     October 1998",
      "raw": true
    },
    {
      "indent": 16,
      "text": "PKCS #1: RSA Cryptography Specifications\n              Version 2.0",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.       Introduction.....................................2\n1.1      Overview.........................................3\n2.       Notation.........................................3\n3.       Key types........................................5\n3.1      RSA public key...................................5\n3.2      RSA private key..................................5\n4.       Data conversion primitives.......................6\n4.1      I2OSP............................................6\n4.2      OS2IP............................................7\n5.       Cryptographic primitives.........................8\n5.1      Encryption and decryption primitives.............8\n5.1.1    RSAEP............................................8\n5.1.2    RSADP............................................9\n5.2      Signature and verification primitives...........10\n5.2.1    RSASP1..........................................10\n5.2.2    RSAVP1..........................................11\n6.       Overview of schemes.............................11\n7.       Encryption schemes..............................12\n7.1      RSAES-OAEP......................................13\n7.1.1    Encryption operation............................13\n7.1.2    Decryption operation............................14\n7.2      RSAES-PKCS1-v1_5................................15\n7.2.1    Encryption operation............................17\n7.2.2    Decryption operation............................17\n8.       Signature schemes with appendix.................18\n8.1      RSASSA-PKCS1-v1_5...............................19\n8.1.1    Signature generation operation..................20",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8.1.2    Signature verification operation................21\n9.       Encoding methods................................22\n9.1      Encoding methods for encryption.................22\n9.1.1    EME-OAEP........................................22\n9.1.2    EME-PKCS1-v1_5..................................24\n9.2      Encoding methods for signatures with appendix...26\n9.2.1    EMSA-PKCS1-v1_5.................................26\n10.      Auxiliary Functions.............................27\n10.1     Hash Functions..................................27\n10.2     Mask Generation Functions.......................28\n10.2.1   MGF1............................................28\n11.      ASN.1 syntax....................................29\n11.1     Key representation..............................29\n11.1.1   Public-key syntax...............................30\n11.1.2   Private-key syntax..............................30\n11.2     Scheme identification...........................31\n11.2.1   Syntax for RSAES-OAEP...........................31\n11.2.2   Syntax for RSAES-PKCS1-v1_5.....................32\n11.2.3   Syntax for RSASSA-PKCS1-v1_5....................33\n12       Patent Statement................................33\n12.1     Patent statement for the RSA algorithm..........34\n13.      Revision history................................35\n14.      References......................................35\n         Security Considerations.........................37\n         Acknowledgements................................37\n         Authors' Addresses..............................38\n         Full Copyright Statement........................39",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This memo is the successor to RFC 2313. This document provides recommendations for the implementation of public-key cryptography based on the RSA algorithm [18], covering the following aspects:",
      "ja": "このメモは、この文書では、以下の側面をカバーする、RSAアルゴリズムに基づく公開鍵暗号を実施するための[18]の推奨事項を提供するRFC 2313の後継です。"
    },
    {
      "indent": 6,
      "text": "-cryptographic primitives -encryption schemes -signature schemes with appendix -ASN.1 syntax for representing keys and for identifying the schemes",
      "ja": "-cryptographicプリミティブは-encryptionスキームは、キーを表すと方式を識別するための付録-ASN.1構文を使用してスキームを-signature"
    },
    {
      "indent": 3,
      "text": "The recommendations are intended for general application within computer and communications systems, and as such include a fair amount of flexibility. It is expected that application standards based on these specifications may include additional constraints. The recommendations are intended to be compatible with draft standards currently being developed by the ANSI X9F1 [1] and IEEE P1363 working groups [14]. This document supersedes PKCS #1 version 1.5 [20].",
      "ja": "勧告は、コンピュータおよび通信システム内の一般的な用途のために意図され、そのようなものとして、柔軟性のかなりの量が含まれます。これらの仕様に基づいてアプリケーションの基準は、追加の制約を含むことができることが期待されています。お薦め現在ANSI X9F1によって開発されているドラフト標準規格と互換性があるように意図されている[1]、IEEE P1363ワーキンググループ[14]。この文書では、PKCS＃1バージョン1.5 [20]を優先します。"
    },
    {
      "indent": 3,
      "text": "Editor's note. It is expected that subsequent versions of PKCS #1 may cover other aspects of the RSA algorithm such as key size, key generation, key validation, and signature schemes with message recovery.",
      "ja": "編集者注。 PKCS＃1の次のバージョンは、キーのサイズ、キー生成、キー検証、メッセージの回収を伴う署名方式としてRSAアルゴリズムの他の側面を覆ってもよいことが予想されます。"
    },
    {
      "indent": 0,
      "text": "1.1 Overview",
      "section_title": true,
      "ja": "1.1概要"
    },
    {
      "indent": 3,
      "text": "The organization of this document is as follows:",
      "ja": "次のように本書の構成は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "-Section 1 is an introduction. -Section 2 defines some notation used in this document. -Section 3 defines the RSA public and private key types. -Sections 4 and 5 define several primitives, or basic mathematical operations. Data conversion primitives are in Section 4, and cryptographic primitives (encryption-decryption, signature-verification) are in Section 5. -Section 6, 7 and 8 deal with the encryption and signature schemes in this document. Section 6 gives an overview. Section 7 defines an OAEP-based [2] encryption scheme along with the method found in PKCS #1 v1.5. Section 8 defines a signature scheme with appendix; the method is identical to that of PKCS #1 v1.5. -Section 9 defines the encoding methods for the encryption and signature schemes in Sections 7 and 8. -Section 10 defines the hash functions and the mask generation function used in this document. -Section 11 defines the ASN.1 syntax for the keys defined in Section 3 and the schemes gives in Sections 7 and 8. -Section 12 outlines the revision history of PKCS #1. -Section 13 contains references to other publications and standards.",
      "ja": "-section 1のご紹介です。 -section 2は、この文書で使用されるいくつかの表記法を定義します。 -section 3は、RSA公開鍵と秘密鍵のタイプを定義します。 -sections 4及び図5は、いくつかのプリミティブ、または基本的な数学演算を規定します。データ変換プリミティブは、第4、及び暗号プリミティブ（暗号復号、署名検証）であり、第5の節6にこの文書に記載されている暗号化および署名方式と7と8の取引です。第6節では概要を説明します。セクション7は、PKCS＃1 V1.5で見つかった方法と共にOAEPベースの[2]の暗号化方式を定義します。セクション8は、付録付き署名方式を定義します。この方法は、PKCS＃1 V1.5のものと同一です。 -section 9セクション7で暗号化及び署名方式の符号化方法を定義し8の節10は、ハッシュ関数と本書で使用されるマスク生成関数を定義します。 -section 11は、第3節で定義されたキーのASN.1構文を定義し、スキームは、セクション7に与え、8 -section 12はPKCS＃1の改訂履歴を概説します。 -section 13は、他の出版物や標準への参照が含まれています。"
    },
    {
      "indent": 0,
      "text": "2. Notation",
      "section_title": true,
      "ja": "2.記法"
    },
    {
      "indent": 3,
      "text": "(n, e) RSA public key",
      "ja": "（N、e）はRSA公開鍵"
    },
    {
      "indent": 3,
      "text": "c ciphertext representative, an integer between 0 and n-1",
      "ja": "C暗号文代表、0とn-1の間の整数"
    },
    {
      "indent": 3,
      "text": "C ciphertext, an octet string",
      "ja": "Cの暗号文、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "d private exponent",
      "ja": "Dプライベート指数"
    },
    {
      "indent": 3,
      "text": "dP p's exponent, a positive integer such that: e(dP)\\equiv 1 (mod(p-1))",
      "ja": "DP Pの指数、つまり、このような正の整数：E（DP）\\当量1（MOD（P-1））"
    },
    {
      "indent": 3,
      "text": "dQ q's exponent, a positive integer such that: e(dQ)\\equiv 1 (mod(q-1))",
      "ja": "DQ Qの指数、正の整数ように：E（DQ）\\当量1（MOD（Q-1））"
    },
    {
      "indent": 3,
      "text": "e public exponent",
      "ja": "電子公開指数"
    },
    {
      "indent": 3,
      "text": "EM encoded message, an octet string",
      "ja": "EMエンコードされたメッセージ、オクテットストリング"
    },
    {
      "indent": 3,
      "text": "emLen intended length in octets of an encoded message",
      "ja": "emLenは、エンコードされたメッセージのオクテットの長さを意図しました"
    },
    {
      "indent": 3,
      "text": "H hash value, an output of Hash",
      "ja": "Hハッシュ値、ハッシュの出力"
    },
    {
      "indent": 3,
      "text": "Hash hash function",
      "ja": "ハッシュハッシュ関数"
    },
    {
      "indent": 3,
      "text": "hLen output length in octets of hash function Hash",
      "ja": "ハッシュ関数HashのオクテットさhLen出力長"
    },
    {
      "indent": 3,
      "text": "K RSA private key",
      "ja": "K RSA秘密鍵"
    },
    {
      "indent": 3,
      "text": "k length in octets of the modulus",
      "ja": "モジュラスのオクテットにおけるk長"
    },
    {
      "indent": 3,
      "text": "l intended length of octet string",
      "ja": "オクテットストリングのL意図長"
    },
    {
      "indent": 3,
      "text": "lcm(.,.) least common multiple of two nonnegative integers",
      "ja": "LCM（。、。）は、2つの非負整数の最小公倍数"
    },
    {
      "indent": 3,
      "text": "m message representative, an integer between 0 and n-1",
      "ja": "m個のメッセージ代表、0とn-1の間の整数"
    },
    {
      "indent": 3,
      "text": "M message, an octet string",
      "ja": "Mメッセージ、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "MGF mask generation function",
      "ja": "MGFマスク生成関数"
    },
    {
      "indent": 3,
      "text": "n modulus",
      "ja": "n個の係数"
    },
    {
      "indent": 3,
      "text": "P encoding parameters, an octet string",
      "ja": "P符号化パラメータ、オクテットストリング"
    },
    {
      "indent": 3,
      "text": "p,q prime factors of the modulus",
      "ja": "P、Q係数の素因数"
    },
    {
      "indent": 3,
      "text": "qInv CRT coefficient, a positive integer less than p such: q(qInv)\\equiv 1 (mod p)",
      "ja": "qInv CRT係数、Pそのようなより小さい正の整数：Q（qInv）\\当量1（MOD P）"
    },
    {
      "indent": 3,
      "text": "s signature representative, an integer between 0 and n-1",
      "ja": "S署名代表、0とn-1の間の整数"
    },
    {
      "indent": 3,
      "text": "S signature, an octet string",
      "ja": "S署名、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "x a nonnegative integer",
      "ja": "X非負整数"
    },
    {
      "indent": 3,
      "text": "X an octet string corresponding to x",
      "ja": "xに対応Xオクテットストリング"
    },
    {
      "indent": 3,
      "text": "\\xor bitwise exclusive-or of two octet strings",
      "ja": "\\ XORビット単位の排他的論理和の2つのオクテット文字列"
    },
    {
      "indent": 3,
      "text": "\\lambda(n) lcm(p-1, q-1), where n = pq",
      "ja": "\\ラムダ（N）LCM（P-1、Q-1）、N = PQ"
    },
    {
      "indent": 3,
      "text": "|| concatenation operator",
      "ja": "||連結演算子"
    },
    {
      "indent": 3,
      "text": "||.|| octet length operator",
      "ja": "||。||オクテット長演算子"
    },
    {
      "indent": 0,
      "text": "3. Key types",
      "section_title": true,
      "ja": "3.キータイプ"
    },
    {
      "indent": 3,
      "text": "Two key types are employed in the primitives and schemes defined in this document: RSA public key and RSA private key. Together, an RSA public key and an RSA private key form an RSA key pair.",
      "ja": "RSA公開鍵とRSA秘密鍵：二つのキータイプは、この文書で定義されたプリミティブとのスキームで採用されています。一緒に、RSA公開鍵とRSA鍵ペアの形RSA秘密鍵。"
    },
    {
      "indent": 0,
      "text": "3.1 RSA public key",
      "section_title": true,
      "ja": "3.1 RSA公開鍵"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, an RSA public key consists of two components:",
      "ja": "このドキュメントの目的のためには、RSA公開鍵は、次の2つのコンポーネントで構成されています。"
    },
    {
      "indent": 3,
      "text": "n, the modulus, a nonnegative integer e, the public exponent, a nonnegative integer",
      "ja": "nは、弾性率、非負整数e、公開指数、非負整数"
    },
    {
      "indent": 3,
      "text": "In a valid RSA public key, the modulus n is a product of two odd primes p and q, and the public exponent e is an integer between 3 and n-1 satisfying gcd (e, \\lambda(n)) = 1, where \\lambda(n) = lcm (p-1,q-1). A recommended syntax for interchanging RSA public keys between implementations is given in Section 11.1.1; an implementation's internal representation may differ.",
      "ja": "有効なRSA公開鍵では、モジュラスNは2つの奇素数pとq、および公開指数eの生成物は、ここでGCD（例えば、\\ラムダ（N））= 1を満たす3とn-1の間の整数であります\\ラムダ（N）= LCM（P-1、Q-1）。実装間のRSA公開鍵を交換するための推奨される構文は、11.1.1項に与えられています。実装の内部表現は異なる場合があります。"
    },
    {
      "indent": 0,
      "text": "3.2 RSA private key",
      "section_title": true,
      "ja": "3.2 RSA秘密鍵"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, an RSA private key may have either of two representations.",
      "ja": "このドキュメントの目的のために、RSA秘密鍵は、2つの表現のいずれかを有することができます。"
    },
    {
      "indent": 3,
      "text": "1. The first representation consists of the pair (n, d), where the components have the following meanings:",
      "ja": "1.第1の表現は、成分は以下の意味を有する対（N、D）、から構成されています。"
    },
    {
      "indent": 3,
      "text": "n, the modulus, a nonnegative integer d, the private exponent, a nonnegative integer",
      "ja": "nは、弾性率、非負整数d、プライベート指数、非負整数"
    },
    {
      "indent": 3,
      "text": "2. The second representation consists of a quintuple (p, q, dP, dQ, qInv), where the components have the following meanings:",
      "ja": "前記第2の表現は、成分は以下の意味を有する五重（P、Q、DP、dQの、qInv）、から構成されています。"
    },
    {
      "indent": 3,
      "text": "p, the first factor, a nonnegative integer q, the second factor, a nonnegative integer dP, the first factor's exponent, a nonnegative integer dQ, the second factor's exponent, a nonnegative integer qInv, the CRT coefficient, a nonnegative integer",
      "ja": "P、第一因子、非負整数q、二因子、非負整数のdP、第一因子の指数、非負整数のdQ、第二の因子の指数、非負整数qInv、CRT係数、非負整数"
    },
    {
      "indent": 3,
      "text": "In a valid RSA private key with the first representation, the modulus n is the same as in the corresponding public key and is the product of two odd primes p and q, and the private exponent d is a positive integer less than n satisfying:",
      "ja": "第1の表現のある有効なRSA秘密鍵では、モジュラスNは、対応する公開鍵と同じであり、2つの奇数の素数pとqの積であり、プライベート指数dは正の整数未満N満足です。"
    },
    {
      "indent": 3,
      "text": "ed \\equiv 1 (mod \\lambda(n))",
      "ja": "編\\当量1（MOD \\ラムダ（N））"
    },
    {
      "indent": 3,
      "text": "where e is the corresponding public exponent and \\lambda(n) is as defined above.",
      "ja": "eが対応する公開指数および\\ラムダである場合（n）は上記で定義した通りです。"
    },
    {
      "indent": 3,
      "text": "In a valid RSA private key with the second representation, the two factors p and q are the prime factors of the modulus n, the exponents dP and dQ are positive integers less than p and q respectively satisfying",
      "ja": "第二の表現のある有効なRSA秘密鍵では、二つの要因p及びqは、モジュラスNの素因数であり、指数DP及びDQはpおよびq未満の正の整数をそれぞれ満足しています"
    },
    {
      "indent": 3,
      "text": "e(dP)\\equiv 1(mod(p-1)) e(dQ)\\equiv 1(mod(q-1)),",
      "ja": "E（DP）\\当量1（MOD（P-1））E（DQ）\\当量1（MOD（Q-1））、"
    },
    {
      "indent": 3,
      "text": "and the CRT coefficient qInv is a positive integer less than p satisfying:",
      "ja": "そしてCRT係数qInvはP未満満たす正の整数です。"
    },
    {
      "indent": 3,
      "text": "q(qInv)\\equiv 1 (mod p).",
      "ja": "Q（qInv）\\当量1（モッズP）。"
    },
    {
      "indent": 3,
      "text": "A recommended syntax for interchanging RSA private keys between implementations, which includes components from both representations, is given in Section 11.1.2; an implementation's internal representation may differ.",
      "ja": "両方の表現から構成要素を含む実装の間のRSA秘密鍵を交換するための推奨される構文は、セクション11.1.2に記載されています。実装の内部表現は異なる場合があります。"
    },
    {
      "indent": 0,
      "text": "4. Data conversion primitives",
      "section_title": true,
      "ja": "4.データ変換プリミティブ"
    },
    {
      "indent": 3,
      "text": "Two data conversion primitives are employed in the schemes defined in this document:",
      "ja": "二つのデータ変換プリミティブは、この文書で定義されたスキームで採用されています。"
    },
    {
      "indent": 3,
      "text": "I2OSP: Integer-to-Octet-String primitive OS2IP: Octet-String-to-Integer primitive",
      "ja": "I2OSP：整数ツーオクテット文字列プリミティブOS2IP：オクテット文字列から整数プリミティブ"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, and consistent with ASN.1 syntax, an octet string is an ordered sequence of octets (eight-bit bytes). The sequence is indexed from first (conventionally, leftmost) to last (rightmost). For purposes of conversion to and from integers, the first octet is considered the most significant in the following conversion primitives",
      "ja": "ASN.1構文で、かつ一貫したこのドキュメントの目的のためには、オクテット文字列はオクテット（8ビットバイト）の順序付けられたシーケンスです。配列（右端）が最後第1（従来は、左端）からインデックス付けされます。整数にしてからの変換のためには、最初のオクテットは、次の変換プリミティブの中で最も重要と考えられています"
    },
    {
      "indent": 0,
      "text": "4.1 I2OSP",
      "section_title": true,
      "ja": "4.1 I2OSP"
    },
    {
      "indent": 3,
      "text": "I2OSP converts a nonnegative integer to an octet string of a specified length.",
      "ja": "I2OSPは、指定された長さのオクテットストリングに非負の整数に変換します。"
    },
    {
      "indent": 3,
      "text": "I2OSP (x, l)",
      "ja": "I2OSP（X、L）"
    },
    {
      "indent": 3,
      "text": "Input: x nonnegative integer to be converted l intended length of the resulting octet string",
      "ja": "入力：得られたオクテットストリングのL意図長さを変換するX非負整数"
    },
    {
      "indent": 3,
      "text": "Output: X corresponding octet string of length l; or \"integer too large\"",
      "ja": "出力：長さLのX対応オクテットストリング。または「整数が大きすぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If x>=256^l, output \"integer too large\" and stop.",
      "section_title": true,
      "ja": "1. X> = 256 ^ L、出力 \"整数が大きすぎる\" 場合と停止。"
    },
    {
      "indent": 3,
      "text": "2. Write the integer x in its unique l-digit representation base 256:",
      "section_title": true,
      "ja": "2.独自のL桁の表現ベース256の整数xを書きます"
    },
    {
      "indent": 3,
      "text": "x = x_{l-1}256^{l-1} + x_{l-2}256^{l-2} +... + x_1 256 + x_0",
      "ja": "X = X_ {L-1} 256 {^ L-1} + X_ {L-2} 256 {^ L-2} + ... + X_1 256 + X_0"
    },
    {
      "indent": 3,
      "text": "where 0 <= x_i < 256 (note that one or more leading digits will be zero if x < 256^{l-1}).",
      "ja": "ここで、0 <= X_I <256（一つ以上の先頭の数字がゼロであれば、X <256 ^ {L-1}であることに注意）。"
    },
    {
      "indent": 3,
      "text": "3. Let the octet X_i have the value x_{l-i} for 1 <= i <= l. Output the octet string:",
      "ja": "3.オクテットX_Iが1の値をX_ {L-I} <= iは= L <てみましょう。出力オクテット文字列："
    },
    {
      "indent": 3,
      "text": "X = X_1 X_2 ... X_l.",
      "ja": "X = X_1 X_2 ... X_L。"
    },
    {
      "indent": 0,
      "text": "4.2 OS2IP",
      "section_title": true,
      "ja": "4.2 OS2IP"
    },
    {
      "indent": 3,
      "text": "OS2IP converts an octet string to a nonnegative integer.",
      "ja": "OS2IPは非負整数のオクテット列に変換します。"
    },
    {
      "indent": 3,
      "text": "OS2IP (X)",
      "ja": "OS2IP（X）"
    },
    {
      "indent": 3,
      "text": "Input: X octet string to be converted",
      "ja": "入力：Xオクテット文字列を変換します"
    },
    {
      "indent": 3,
      "text": "Output: x corresponding nonnegative integer",
      "ja": "出力：X対応する非負の整数"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Let X_1 X_2 ... X_l be the octets of X from first to last, and let x{l-i} have value X_i for 1<= i <= l.",
      "ja": "1. X_1 X_2は...最初から最後までXのオクテットであることX_Lう、及び= iは= L <a <1の値X_IをX {L-I}せ有します。"
    },
    {
      "indent": 3,
      "text": "2. Let x = x{l-1} 256^{l-1} + x_{l-2} 256^{l-2} +...+ x_1 256 + x_0.",
      "section_title": true,
      "ja": "2.レッツX = X {L-1} 256 {^ L-1} + X_ {L-2} 256 {^ L-2} + ... + X_1 256 + X_0。"
    },
    {
      "indent": 3,
      "text": "3. Output x.",
      "section_title": true,
      "ja": "3.出力X。"
    },
    {
      "indent": 0,
      "text": "5. Cryptographic primitives",
      "section_title": true,
      "ja": "5.暗号プリミティブ"
    },
    {
      "indent": 3,
      "text": "Cryptographic primitives are basic mathematical operations on which cryptographic schemes can be built. They are intended for implementation in hardware or as software modules, and are not intended to provide security apart from a scheme.",
      "ja": "暗号プリミティブは、暗号化スキームが構築できる基本的な数学的な操作です。彼らはハードウェアまたはソフトウェアモジュールとして実装することを意図しており、スキームから離れてセキュリティを提供することを意図していません。"
    },
    {
      "indent": 3,
      "text": "Four types of primitive are specified in this document, organized in pairs: encryption and decryption; and signature and verification.",
      "ja": "プリミティブの4種類の、この文書で指定されたペアで編成されています暗号化と復号化。署名と検証。"
    },
    {
      "indent": 3,
      "text": "The specifications of the primitives assume that certain conditions are met by the inputs, in particular that public and private keys are valid.",
      "ja": "プリミティブの仕様は、特定の条件が、公開鍵と秘密鍵が有効であること、特に、入力で満たされていることを前提としています。"
    },
    {
      "indent": 0,
      "text": "5.1 Encryption and decryption primitives",
      "section_title": true,
      "ja": "5.1暗号化と復号化のプリミティブ"
    },
    {
      "indent": 3,
      "text": "An encryption primitive produces a ciphertext representative from a message representative under the control of a public key, and a decryption primitive recovers the message representative from the ciphertext representative under the control of the corresponding private key.",
      "ja": "プリミティブ暗号化は、公開鍵の制御下でメッセージ代表から暗号文代表を生成し、原始的復号化は、対応する秘密鍵の制御下で暗号文代表からのメッセージ代表を回復します。"
    },
    {
      "indent": 3,
      "text": "One pair of encryption and decryption primitives is employed in the encryption schemes defined in this document and is specified here: RSAEP/RSADP. RSAEP and RSADP involve the same mathematical operation, with different keys as input.",
      "ja": "暗号化と復号化プリミティブの一つのペアは、この文書で定義された暗号化方式で採用されており、ここで指定されていますRSAEP / RSADP。 RSAEPとRSADPは、入力として、異なるキーを使用して、同じ数学的な操作を必要とします。"
    },
    {
      "indent": 3,
      "text": "The primitives defined here are the same as in the draft IEEE P1363 and are compatible with PKCS #1 v1.5.",
      "ja": "ここで定義されたプリミティブは、ドラフトIEEE P1363と同じであり、PKCS＃1 V1.5と互換性があります。"
    },
    {
      "indent": 3,
      "text": "The main mathematical operation in each primitive is exponentiation.",
      "ja": "各プリミティブの主な数学的な操作は累乗です。"
    },
    {
      "indent": 0,
      "text": "5.1.1 RSAEP",
      "section_title": true,
      "ja": "5.1.1 RSAEP"
    },
    {
      "indent": 3,
      "text": "RSAEP((n, e), m)",
      "ja": "RSAEP（（N、E）、M）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) RSA public key m message representative, an integer between 0 and n-1",
      "ja": "入力：（N、e）はRSA公開鍵Mメッセージ代表、0とn-1の間の整数"
    },
    {
      "indent": 3,
      "text": "Output: c ciphertext representative, an integer between 0 and n-1; or \"message representative out of range\"",
      "ja": "出力：C暗号文代表、0とn-1の間の整数。または「範囲外メッセージ代表」"
    },
    {
      "indent": 3,
      "text": "Assumptions: public key (n, e) is valid",
      "ja": "仮定：公開鍵（N、e）が有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the message representative m is not between 0 and n-1, output message representative out of range and stop.",
      "ja": "1.メッセージ代表mは、0とn-1の間の範囲と停止のうち出力を表すメッセージではない場合。"
    },
    {
      "indent": 3,
      "text": "2. Let c = m^e mod n.",
      "section_title": true,
      "ja": "2. C = M ^ E mod nをしましょう。"
    },
    {
      "indent": 3,
      "text": "3. Output c.",
      "section_title": true,
      "ja": "3.出力c。"
    },
    {
      "indent": 0,
      "text": "5.1.2 RSADP",
      "section_title": true,
      "ja": "5.1.2 RSADP"
    },
    {
      "indent": 3,
      "text": "RSADP (K, c)",
      "ja": "RSADP（K、C）"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "K RSA private key, where K has one of the following forms -a pair (n, d) -a quintuple (p, q, dP, dQ, qInv) c ciphertext representative, an integer between 0 and n-1",
      "ja": "Kは、以下の形式-a対（N、D）-A五重（P、Q、DP、dQの、qInv）C暗号文代表、0とn-1の間の整数のいずれかを有するK RSA秘密鍵"
    },
    {
      "indent": 3,
      "text": "Output: m message representative, an integer between 0 and n-1; or \"ciphertext representative out of range\"",
      "ja": "出力：Mメッセージ代表、0とn-1の間の整数。または「範囲外の暗号文代表」"
    },
    {
      "indent": 3,
      "text": "Assumptions: private key K is valid",
      "ja": "仮定：秘密鍵Kが有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the ciphertext representative c is not between 0 and n-1, output \"ciphertext representative out of range\" and stop.",
      "ja": "1.暗号文代表cが0とN-1、出力「暗号文代表範囲外」と停止の間にない場合。"
    },
    {
      "indent": 3,
      "text": "2. If the first form (n, d) of K is used:",
      "section_title": true,
      "ja": "Kの第一の形態（N、D）を使用する場合2。"
    },
    {
      "indent": 3,
      "text": "2.1 Let m = c^d mod n. Else, if the second form (p, q, dP, dQ, qInv) of K is used:",
      "ja": "2.1メートル= C ^ D mod nをしましょう。そうでなければ、第二の形態は、（p、qは、DPは、DQの、qInv）Kのが使用される場合："
    },
    {
      "indent": 3,
      "text": "2.2 Let m_1 = c^dP mod p.",
      "section_title": true,
      "ja": "2.2 M_1 = C ^のDPモッズpをしてみましょう。"
    },
    {
      "indent": 3,
      "text": "2.3 Let m_2 = c^dQ mod q.",
      "section_title": true,
      "ja": "2.3 M_2 = C ^ dQのモッズQましょう。"
    },
    {
      "indent": 3,
      "text": "2.4 Let h = qInv ( m_1 - m_2 ) mod p.",
      "section_title": true,
      "ja": "モッズp  - で2.4時間= qInv（M_2 M_1）してみましょう。"
    },
    {
      "indent": 3,
      "text": "2.5 Let m = m_2 + hq.",
      "section_title": true,
      "ja": "2.5メートル= M_2 + HQをしましょう。"
    },
    {
      "indent": 3,
      "text": "3. Output m.",
      "section_title": true,
      "ja": "3.出力メートル。"
    },
    {
      "indent": 0,
      "text": "5.2 Signature and verification primitives",
      "section_title": true,
      "ja": "5.2署名と検証プリミティブ"
    },
    {
      "indent": 3,
      "text": "A signature primitive produces a signature representative from a message representative under the control of a private key, and a verification primitive recovers the message representative from the signature representative under the control of the corresponding public key. One pair of signature and verification primitives is employed in the signature schemes defined in this document and is specified here: RSASP1/RSAVP1.",
      "ja": "プリミティブ署名は、秘密鍵の制御下でメッセージ代表から署名代表を生成し、原始的検証は、対応する公開鍵の制御下で署名代表からのメッセージ代表を回復します。署名と検証プリミティブの一組は、この文書で定義された署名方式に採用されており、ここで指定されている：RSASP1 / RSAVP1。"
    },
    {
      "indent": 3,
      "text": "The primitives defined here are the same as in the draft IEEE P1363 and are compatible with PKCS #1 v1.5.",
      "ja": "ここで定義されたプリミティブは、ドラフトIEEE P1363と同じであり、PKCS＃1 V1.5と互換性があります。"
    },
    {
      "indent": 3,
      "text": "The main mathematical operation in each primitive is exponentiation, as in the encryption and decryption primitives of Section 5.1. RSASP1 and RSAVP1 are the same as RSADP and RSAEP except for the names of their input and output arguments; they are distinguished as they are intended for different purposes.",
      "ja": "各プリミティブの主な数学的な操作は、セクション5.1の暗号化と復号化プリミティブのように、累乗です。 RSASP1とRSAVP1は、その入力と出力引数の名前を除いてRSADPとRSAEPと同じです。それらは異なる目的のために意図されているとして、彼らは区別されています。"
    },
    {
      "indent": 0,
      "text": "5.2.1 RSASP1",
      "section_title": true,
      "ja": "5.2.1 RSASP1"
    },
    {
      "indent": 3,
      "text": "RSASP1 (K, m)",
      "ja": "RSASP1（K、M）"
    },
    {
      "indent": 3,
      "text": "Input: K RSA private key, where K has one of the following forms: -a pair (n, d) -a quintuple (p, q, dP, dQ, qInv)",
      "ja": "入力：K RSA秘密鍵、Kは、次の形式の1つを有する：-a対（N、D）-A五重（P、Q、DP、dQの、qInv）"
    },
    {
      "indent": 3,
      "text": "m message representative, an integer between 0 and n-1",
      "ja": "m個のメッセージ代表、0とn-1の間の整数"
    },
    {
      "indent": 3,
      "text": "Output: s signature representative, an integer between 0 and n-1, or \"message representative out of range\"",
      "ja": "出力：S署名代表、0とn-1の間の整数、または「範囲外のメッセージ代表」"
    },
    {
      "indent": 3,
      "text": "Assumptions: private key K is valid",
      "ja": "仮定：秘密鍵Kが有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the message representative m is not between 0 and n-1, output \"message representative out of range\" and stop.",
      "ja": "1.メッセージ代表mが0とN-1、出力「範囲外を表すメッセージ」と停止の間にない場合。"
    },
    {
      "indent": 3,
      "text": "2. If the first form (n, d) of K is used:",
      "section_title": true,
      "ja": "Kの第一の形態（N、D）を使用する場合2。"
    },
    {
      "indent": 3,
      "text": "2.1 Let s = m^d mod n. Else, if the second form (p, q, dP, dQ, qInv) of K is used:",
      "ja": "2.1レッツS = mの^ D mod nを。そうでなければ、第二の形態は、（p、qは、DPは、DQの、qInv）Kのが使用される場合："
    },
    {
      "indent": 3,
      "text": "2.2 Let s_1 = m^dP mod p.",
      "section_title": true,
      "ja": "2.2 S_1 = M ^のDPモッズpをしてみましょう。"
    },
    {
      "indent": 3,
      "text": "2.3 Let s_2 = m^dQ mod q.",
      "section_title": true,
      "ja": "2.3 S_2 = M ^ dQのモッズQましょう。"
    },
    {
      "indent": 3,
      "text": "2.4 Let h = qInv ( s_1 - s_2 ) mod p.",
      "section_title": true,
      "ja": "モッズp  - で2.4時間= qInv（S_2 S_1）してみましょう。"
    },
    {
      "indent": 3,
      "text": "2.5 Let s = s_2 + hq.",
      "section_title": true,
      "ja": "2.5レッツS = S_2 + HQ。"
    },
    {
      "indent": 3,
      "text": "3. Output S.",
      "section_title": true,
      "ja": "3.出力S."
    },
    {
      "indent": 0,
      "text": "5.2.2 RSAVP1",
      "section_title": true,
      "ja": "5.2.2 RSAVP1"
    },
    {
      "indent": 3,
      "text": "RSAVP1 ((n, e), s)",
      "ja": "RSAVP1（（N、E）、S）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) RSA public key s signature representative, an integer between 0 and n-1",
      "ja": "入力：（N、e）はRSA公開鍵の署名を表す、0とn-1の間の整数"
    },
    {
      "indent": 3,
      "text": "Output: m message representative, an integer between 0 and n-1; or \"invalid\"",
      "ja": "出力：Mメッセージ代表、0とn-1の間の整数。または「無効」"
    },
    {
      "indent": 3,
      "text": "Assumptions: public key (n, e) is valid",
      "ja": "仮定：公開鍵（N、e）が有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the signature representative s is not between 0 and n-1, output \"invalid\" and stop.",
      "ja": "1.署名代表sは0とn-1との間にない場合、出力「無効」と止めます。"
    },
    {
      "indent": 3,
      "text": "2. Let m = s^e mod n.",
      "section_title": true,
      "ja": "2.メートル= S ^ E mod nをしてみましょう。"
    },
    {
      "indent": 3,
      "text": "3. Output m.",
      "section_title": true,
      "ja": "3.出力メートル。"
    },
    {
      "indent": 0,
      "text": "6. Overview of schemes",
      "section_title": true,
      "ja": "スキームの概要6."
    },
    {
      "indent": 3,
      "text": "A scheme combines cryptographic primitives and other techniques to achieve a particular security goal. Two types of scheme are specified in this document: encryption schemes and signature schemes with appendix.",
      "ja": "スキームは、特定のセキュリティ目標を達成するために暗号プリミティブおよび他の技術を兼ね備えています。スキームの2種類が、この文書で指定されています。暗号化方式と署名方式を付録に。"
    },
    {
      "indent": 3,
      "text": "The schemes specified in this document are limited in scope in that their operations consist only of steps to process data with a key, and do not include steps for obtaining or validating the key. Thus, in addition to the scheme operations, an application will typically include key management operations by which parties may select public and private keys for a scheme operation. The specific additional operations and other details are outside the scope of this document.",
      "ja": "この文書で指定されたスキームは、それらの操作はキーのみでデータを処理するステップからなることに範囲が限定されており、取得又は鍵を検証するための手順を含んでいません。このように、制度の運用に加えて、アプリケーションは通常、当事者がスキーム操作のための公開鍵と秘密鍵を選択することができることにより、キー管理操作が含まれます。固有の追加操作やその他の詳細は、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "As was the case for the cryptographic primitives (Section 5), the specifications of scheme operations assume that certain conditions are met by the inputs, in particular that public and private keys are valid. The behavior of an implementation is thus unspecified when a key is invalid. The impact of such unspecified behavior depends on the application. Possible means of addressing key validation include explicit key validation by the application; key validation within the public-key infrastructure; and assignment of liability for operations performed with an invalid key to the party who generated the key.",
      "ja": "暗号プリミティブ（セクション5）の場合と同様に、スキーム動作の仕様は、一定の条件が公開鍵と秘密鍵が有効であること、特に、入力で満たされていると仮定する。キーが無効であるとき、実装の振る舞いは、このように指定されていません。不特定の行動の影響は、アプリケーションによって異なります。キーの検証に取り組むの可能な手段は、アプリケーションによる明示的なキーの検証が含まれます。公開鍵インフラストラクチャ内のキーの検証。そして、キーを生成した当事者に無効なキーで実行された操作のための責任の割り当て。"
    },
    {
      "indent": 0,
      "text": "7. Encryption schemes",
      "section_title": true,
      "ja": "7.暗号化方式"
    },
    {
      "indent": 3,
      "text": "An encryption scheme consists of an encryption operation and a decryption operation, where the encryption operation produces a ciphertext from a message with a recipient's public key, and the decryption operation recovers the message from the ciphertext with the recipient's corresponding private key.",
      "ja": "暗号化方式は、暗号化操作と暗号化操作は、受信者の公開鍵でメッセージから暗号文を生成し、復号化操作は、受信者の対応する秘密鍵で暗号文からのメッセージを回復する復号化操作、から構成されています。"
    },
    {
      "indent": 3,
      "text": "An encryption scheme can be employed in a variety of applications. A typical application is a key establishment protocol, where the message contains key material to be delivered confidentially from one party to another. For instance, PKCS #7 [21] employs such a protocol to deliver a content-encryption key from a sender to a recipient; the encryption schemes defined here would be suitable key-encryption algorithms in that context.",
      "ja": "暗号化方式は、種々の用途に使用することができます。典型的なアプリケーションは、メッセージが別の関係者から秘密に配信されるキー材料を含む鍵確立プロトコルです。例えば、PKCS＃7 [21]受信者に送信者からコンテンツ暗号化キーを提供するためにそのようなプロトコルを採用し、ここで定義された暗号化方式は、そのコンテキストに適した鍵暗号化アルゴリズムになります。"
    },
    {
      "indent": 3,
      "text": "Two encryption schemes are specified in this document: RSAES-OAEP and RSAES-PKCS1-v1_5. RSAES-OAEP is recommended for new applications; RSAES-PKCS1-v1_5 is included only for compatibility with existing applications, and is not recommended for new applications.",
      "ja": "2つの暗号化方式は、この文書で指定されていますRSAES-OAEPおよびRSAES-PKCS1-v1_5のを。 RSAES-OAEPは、新しいアプリケーションのために推奨されます。 RSAES-PKCS1-v1_5のは、既存のアプリケーションとの互換性のために含まれ、そして新しいアプリケーションのために推奨されていません。"
    },
    {
      "indent": 3,
      "text": "The encryption schemes given here follow a general model similar to that employed in IEEE P1363, by combining encryption and decryption primitives with an encoding method for encryption. The encryption operations apply a message encoding operation to a message to produce an encoded message, which is then converted to an integer message representative. An encryption primitive is applied to the message representative to produce the ciphertext. Reversing this, the decryption operations apply a decryption primitive to the ciphertext to recover a message representative, which is then converted to an octet string encoded message. A message decoding operation is applied to the encoded message to recover the message and verify the correctness of the decryption.",
      "ja": "ここで所定の暗号化方式は、暗号化のための符号化方式で暗号化と復号化プリミティブを組み合わせることにより、IEEE P1363に用いられるものと同様の一般的なモデルに従います。暗号化操作は、次に整数を表すメッセージに変換され、エンコードされたメッセージを生成するメッセージに、メッセージ符号化演算を適用します。プリミティブ暗号化は、暗号文を生成することを表すメッセージに適用されます。この反転、復号動作は、次にオクテットストリング符号化されたメッセージに変換されたメッセージ代表を回復する暗号文にプリミティブ復号化を適用します。メッセージ復号動作は、メッセージを復元および復号の正当性を検証するために符号化されたメッセージに適用されます。"
    },
    {
      "indent": 0,
      "text": "7.1 RSAES-OAEP",
      "section_title": true,
      "ja": "7.1 RSAES-OAEP"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP combines the RSAEP and RSADP primitives (Sections 5.1.1 and 5.1.2) with the EME-OAEP encoding method (Section 9.1.1) EME-OAEP is based on the method found in [2]. It is compatible with the IFES scheme defined in the draft P1363 where the encryption and decryption primitives are IFEP-RSA and IFDP-RSA and the message encoding method is EME-OAEP. RSAES-OAEP can operate on messages of length up to k-2- 2hLen octets, where hLen is the length of the hash function output for EME-OAEP and k is the length in octets of the recipient's RSA modulus. Assuming that the hash function in EME-OAEP has appropriate properties, and the key size is sufficiently large, RSAEP-OAEP provides \"plaintext-aware encryption,\" meaning that it is computationally infeasible to obtain full or partial information about a message from a ciphertext, and computationally infeasible to generate a valid ciphertext without knowing the corresponding message. Therefore, a chosen-ciphertext attack is ineffective against a plaintext-aware encryption scheme such as RSAES-OAEP.",
      "ja": "RSAES-OAEPがEME-OAEP符号化方法（9.1.1項）EME-OAEPとRSAEPとRSADPプリミティブ（セクション5.1.1と5.1.2）を組み合わせた[2]に見られる方法に基づいています。これは、暗号化と復号化プリミティブはIFEP-RSAおよびIFDP-RSAであり、メッセージの符号化方法は、EME-OAEPでドラフトP1363に定義されIFES方式と互換性があります。 RSAES-OAEPはさhLenがEME-OAEPとkのハッシュ関数の出力の長さは、受信者のRSAモジュラスのオクテットの長さである2hLenオクテット-2- k個までの長さのメッセージ上で動作することができます。 EME-OAEPでハッシュ関数は、適切な特性を有し、かつ、キーサイズは十分に大きいと仮定すると、RSAEP-OAEPは、暗号文からのメッセージについての完全または部分的な情報を得ることが計算上不可能であることを意味する「平文を意識した暗号化」を提供します、および対応するメッセージを知ることなく、有効な暗号文を生成することが計算上実行不可能。したがって、選択暗号文攻撃は、RSAES-OAEPとして平文対応の暗号化方式に対しては無効です。"
    },
    {
      "indent": 3,
      "text": "Both the encryption and the decryption operations of RSAES-OAEP take the value of the parameter string P as input. In this version of PKCS #1, P is an octet string that is specified explicitly. See Section 11.2.1 for the relevant ASN.1 syntax. We briefly note that to receive the full security benefit of RSAES-OAEP, it should not be used in a protocol involving RSAES-PKCS1-v1_5. It is possible that in a protocol on which both encryption schemes are present, an adaptive chosen ciphertext attack such as [4] would be useful.",
      "ja": "RSAES-OAEPの暗号化および復号化操作の両方は、入力として、パラメータ文字列Pの値をとります。 PKCS＃1のこのバージョンでは、Pは、明示的に指定されたオクテット文字列です。関連するASN.1構文については、セクション11.2.1を参照してください。我々は簡単にそれがRSAES-PKCS1-v1_5のが関与するプロトコルで使用すべきではない、RSAES-OAEPの完全なセキュリティ上の利点を受信することに注意してください。両方の暗号化方式が存在する上でプロトコル、などの適応的選択暗号文攻撃の[4]有用であることが可能です。"
    },
    {
      "indent": 3,
      "text": "Both the encryption and the decryption operations of RSAES-OAEP take the value of the parameter string P as input. In this version of PKCS #1, P is an octet string that is specified explicitly. See Section 11.2.1 for the relevant ASN.1 syntax.",
      "ja": "RSAES-OAEPの暗号化および復号化操作の両方は、入力として、パラメータ文字列Pの値をとります。 PKCS＃1のこのバージョンでは、Pは、明示的に指定されたオクテット文字列です。関連するASN.1構文については、セクション11.2.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.1.1 Encryption operation",
      "section_title": true,
      "ja": "7.1.1暗号化の操作"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP-ENCRYPT ((n, e), M, P)",
      "ja": "RSAES-OAEP-ENCRYPT（（N、E）、M、P）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) recipient's RSA public key",
      "ja": "入力：（N、E）受信者のRSA公開鍵"
    },
    {
      "indent": 3,
      "text": "M message to be encrypted, an octet string of length at most k-2-2hLen, where k is the length in octets of the modulus n and hLen is the length in octets of the hash function output for EME-OAEP",
      "ja": "Mメッセージは、kは係数nのオクテットの長さが最もK-2-2hLen、で長のオクテット列を暗号化するとさhLenがEME-OAEPのハッシュ関数出力のオクテットの長さであります"
    },
    {
      "indent": 3,
      "text": "P encoding parameters, an octet string that may be empty",
      "ja": "P符号化パラメータを、空であってもよいオクテットストリング"
    },
    {
      "indent": 3,
      "text": "Output: C ciphertext, an octet string of length k; or \"message too long\"",
      "ja": "出力：C暗号文、長さkのオクテットストリング。または「メッセージが長すぎます」"
    },
    {
      "indent": 3,
      "text": "Assumptions: public key (n, e) is valid",
      "ja": "仮定：公開鍵（N、e）が有効です"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Apply the EME-OAEP encoding operation (Section 9.1.1.2) to the message M and the encoding parameters P to produce an encoded message EM of length k-1 octets:",
      "ja": "1.長さk-1オクテットの符号化されたメッセージEMを生成するために、メッセージM及び符号化パラメータPにEME-OAEP符号化操作（セクション9.1.1.2）を適用します。"
    },
    {
      "indent": 3,
      "text": "EM = EME-OAEP-ENCODE (M, P, k-1)",
      "ja": "EM = EME-OAEP-ENCODE（M、P、K-1）"
    },
    {
      "indent": 3,
      "text": "If the encoding operation outputs \"message too long,\" then output \"message too long\" and stop.",
      "ja": "符号化演算の出力が「メッセージが長すぎる、」次に出力「メッセージが長すぎる」と止めます。"
    },
    {
      "indent": 3,
      "text": "2. Convert the encoded message EM to an integer message representative m: m = OS2IP (EM)",
      "ja": "M = OS2IP（EM）：2.エンコードされたメッセージEMは、整数を表すメッセージmに変換します"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSAEP encryption primitive (Section 5.1.1) to the public key (n, e) and the message representative m to produce an integer ciphertext representative c:",
      "ja": "3.公開鍵（N、e）及び整数暗号文代表cを生成することを表すメッセージmに（セクション5.1.1）プリミティブRSAEP暗号化を適用します。"
    },
    {
      "indent": 3,
      "text": "c = RSAEP ((n, e), m)",
      "ja": "C = RSAEP（（N、E）、M）"
    },
    {
      "indent": 3,
      "text": "4. Convert the ciphertext representative c to a ciphertext C of length k octets: C = I2OSP (c, k)",
      "ja": "4.長さkオクテットの暗号文CのC暗号文代表換算：C = I2OSP（C、K）"
    },
    {
      "indent": 3,
      "text": "5. Output the ciphertext C.",
      "section_title": true,
      "ja": "5.出力暗号文C."
    },
    {
      "indent": 0,
      "text": "7.1.2 Decryption operation",
      "section_title": true,
      "ja": "7.1.2復号化操作"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP-DECRYPT (K, C, P)",
      "ja": "RSAES-OAEP-DECRYPT（K、C、P）"
    },
    {
      "indent": 3,
      "text": "Input: K recipient's RSA private key C ciphertext to be decrypted, an octet string of length k, where k is the length in octets of the modulus n P encoding parameters, an octet string that may be empty",
      "ja": "入力：復号化されるべきK個の受信者のRSA秘密鍵暗号文Cを、kは係数のオクテットN P符号化パラメータの長さである長さkのオクテットストリング、空であってもよいオクテットストリング"
    },
    {
      "indent": 3,
      "text": "Output: M message, an octet string of length at most k-2-2hLen, where hLen is the length in octets of the hash function output for EME-OAEP; or \"decryption error\"",
      "ja": "出力：Mメッセージ、さhLenがEME-OAEPのハッシュ関数出力のオクテットの長さである最もK-2-2hLen、で長のオクテット列。または「復号化エラー」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the length of the ciphertext C is not k octets, output \"decryption error\" and stop.",
      "ja": "1.暗号文Cの長さがオクテットをK、出力「復号エラー」と停止されていない場合。"
    },
    {
      "indent": 3,
      "text": "2. Convert the ciphertext C to an integer ciphertext representative c: c = OS2IP (C).",
      "ja": "2.整数暗号文代表cに暗号文Cを変換する：C = OS2IP（C）。"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSADP decryption primitive (Section 5.1.2) to the private key K and the ciphertext representative c to produce an integer message representative m:",
      "ja": "3.秘密鍵Kと整数を表すメッセージmを生成する暗号文代表cにRSADP復号プリミティブ（セクション5.1.2）に適用します。"
    },
    {
      "indent": 3,
      "text": "m = RSADP (K, c)",
      "ja": "M = RSADP（K、C）"
    },
    {
      "indent": 3,
      "text": "If RSADP outputs \"ciphertext out of range,\" then output \"decryption error\" and stop.",
      "ja": "「範囲外の暗号文、」RSADP出力する場合、出力「解読エラー」と止めます。"
    },
    {
      "indent": 3,
      "text": "4. Convert the message representative m to an encoded message EM of length k-1 octets: EM = I2OSP (m, k-1)",
      "ja": "EM = I2OSP（M、K-1）：4長さk-1オクテットの符号化されたメッセージEMを表すメッセージmを変換"
    },
    {
      "indent": 3,
      "text": "If I2OSP outputs \"integer too large,\" then output \"decryption error\" and stop.",
      "ja": "その後、出力「解読エラー」I2OSP出力「整数が大きすぎる」場合は、停止します。"
    },
    {
      "indent": 3,
      "text": "5. Apply the EME-OAEP decoding operation to the encoded message EM and the encoding parameters P to recover a message M:",
      "ja": "5.メッセージMを回復するためにコード化されたメッセージEM及び符号化パラメータPにEME-OAEPの復号動作を適用します。"
    },
    {
      "indent": 3,
      "text": "M = EME-OAEP-DECODE (EM, P)",
      "ja": "M（P AT）= EME-OAEP-DECODE"
    },
    {
      "indent": 3,
      "text": "If the decoding operation outputs \"decoding error,\" then output \"decryption error\" and stop.",
      "ja": "復号動作の出力が「復号エラー」、出力「復号エラー」と停止した場合。"
    },
    {
      "indent": 3,
      "text": "6. Output the message M.",
      "section_title": true,
      "ja": "6.出力メッセージM."
    },
    {
      "indent": 3,
      "text": "Note. It is important that the error messages output in steps 4 and 5 be the same, otherwise an adversary may be able to extract useful information from the type of error message received. Error message information is used to mount a chosen-ciphertext attack on PKCS #1 v1.5 encrypted messages in [4].",
      "ja": "注意。そうでなければ敵が受信したエラーメッセージの種類から有用な情報を抽出することができる場合があり、ステップ4および5でエラーメッセージ出力が同じであることが重要です。エラーメッセージ情報にPKCS＃1 V1.5暗号化されたメッセージに選択暗号文攻撃を取り付けるために使用されている[4]。"
    },
    {
      "indent": 0,
      "text": "7.2 RSAES-PKCS1-v1_5",
      "section_title": true,
      "ja": "7.2 RSAES-PKCS1-v1_5の"
    },
    {
      "indent": 3,
      "text": "RSAES-PKCS1-v1_5 combines the RSAEP and RSADP primitives with the EME-PKCS1-v1_5 encoding method. It is the same as the encryption scheme in PKCS #1 v1.5. RSAES-PKCS1-v1_5 can operate on messages of length up to k-11 octets, although care should be taken to avoid certain attacks on low-exponent RSA due to Coppersmith, et al. when long messages are encrypted (see the third bullet in the notes below and [7]).",
      "ja": "RSAES-PKCS1-v1_5のは、EME-PKCS1-v1_5の符号化方式でRSAEPとRSADPプリミティブを組み合わせ。これは、PKCS＃1 v1.5の中に暗号化方式と同じです。 RSAES-PKCS1-v1_5のは、K-11オクテットを、ケア起因ら銅細工に低指数RSA上の特定の攻撃を避けるために注意すべきである長さまでのメッセージ上で動作することができます。長いメッセージが暗号化されている場合（以下Notesの第三弾を参照し、[7]）。"
    },
    {
      "indent": 3,
      "text": "RSAES-PKCS1-v1_5 does not provide \"plaintext aware\" encryption. In particular, it is possible to generate valid ciphertexts without knowing the corresponding plaintexts, with a reasonable probability of success. This ability can be exploited in a chosen ciphertext attack as shown in [4]. Therefore, if RSAES-PKCS1-v1_5 is to be used, certain easily implemented countermeasures should be taken to thwart the attack found in [4]. The addition of structure to the data to be encoded, rigorous checking of PKCS #1 v1.5 conformance and other redundancy in decrypted messages, and the consolidation of error messages in a client-server protocol based on PKCS #1 v1.5 can all be effective countermeasures and don't involve changes to a PKCS #1 v1.5-based protocol. These and other countermeasures are discussed in [5].",
      "ja": "RSAES-PKCS1-v1_5のは「平文意識」の暗号化を提供していません。特に、成功の合理的な確率で、対応する平文を知らなくても、有効な暗号文を生成することが可能です。 [4]に示すように、この能力は選択暗号文攻撃に利用することができます。 RSAES-PKCS1-v1_5のを使用する場合したがって、特定の容易に実現対策[4]に見られる攻撃を阻止するために取られるべきです。できる限りのこと、符号化するデータへの構造、PKCS＃1 v1.5の適合および復号化されたメッセージに他の冗長性の厳格なチェック、PKCS＃1 v1.5のに基づいて、クライアント・サーバ・プロトコルでのエラーメッセージの統合の追加効果的な対策であることと、PKCS＃1 V1.5ベースのプロトコルへの変更を伴いません。これらおよび他の対策は、[5]に記載されています。"
    },
    {
      "indent": 3,
      "text": "Notes. The following passages describe some security recommendations pertaining to the use of RSAES-PKCS1-v1_5. Recommendations from version 1.5 of this document are included as well as new recommendations motivated by cryptanalytic advances made in the intervening years.",
      "ja": "ノート。以下の節ではRSAES-PKCS1-v1_5の使用に関連するいくつかのセキュリティ勧告を記述する。このドキュメントのバージョン1.5からの勧告を介在年間に作られた暗号解読の進歩によって動機づけ新しい勧告だけでなく、含まれています。"
    },
    {
      "indent": 3,
      "text": "-It is recommended that the pseudorandom octets in EME-PKCS1-v1_5 be generated independently for each encryption process, especially if the same data is input to more than one encryption process. Hastad's results [13] are one motivation for this recommendation.",
      "ja": " - それは、EME-PKCS1-v1_5の中に擬似ランダムオクテットは、同じデータが複数の暗号化プロセスへの入力である場合は特に、各暗号化処理のために独立して生成することが推奨されます。 Hastadの結果[13]は、この勧告のための1つの動機です。"
    },
    {
      "indent": 3,
      "text": "-The padding string PS in EME-PKCS1-v1_5 is at least eight octets long, which is a security condition for public-key operations that prevents an attacker from recovering data by trying all possible encryption blocks.",
      "ja": "EME-PKCS1-v1_5の中-Theパディング文字列PSは、すべての可能な暗号化ブロックを試みることによって、データを回復するから、攻撃者を防ぎ、公開鍵操作のためのセキュリティ条件である、少なくとも8つのオクテットの長さです。"
    },
    {
      "indent": 3,
      "text": "-The pseudorandom octets can also help thwart an attack due to Coppersmith et al. [7] when the size of the message to be encrypted is kept small. The attack works on low-exponent RSA when similar messages are encrypted with the same public key. More specifically, in one flavor of the attack, when two inputs to RSAEP agree on a large fraction of bits (8/9) and low-exponent RSA (e = 3) is used to encrypt both of them, it may be possible to recover both inputs with the attack. Another flavor of the attack is successful in decrypting a single ciphertext when a large fraction (2/3) of the input to RSAEP is already known. For typical applications, the message to be encrypted is short (e.g., a 128-bit symmetric key) so not enough information will be known or common between two messages to enable the attack. However, if a long message is encrypted, or if part of a message is known, then the attack may be a concern. In any case, the RSAEP-OAEP scheme overcomes the attack.",
      "ja": "-The擬似ランダムオクテットはまた、銅細工らによる攻撃を阻止することができます。 [7]暗号化されるメッセージのサイズが小さく保たれる場合。同様のメッセージが同じ公開鍵で暗号化されている場合、攻撃は、低指数RSA上で動作します。より具体的には、攻撃の1種のフレーバーで、RSAEPの2つの入力は、それらの両方を暗号化するために使用される（8/9）ビットの大部分に同意し、低指数RSA（E = 3）の場合、それが可能であってもよいです攻撃で両方の入力を回復します。攻撃のもう一つの味はRSAEPへの入力の大部分（2/3）が既にわかっている場合、単一の暗号文を解読することに成功しています。典型的な用途のために、暗号化されるメッセージが短い（例えば、128ビットの対称鍵）が十分な情報が攻撃を有効にするために、2つのメッセージ間で知られているか、または一般的であろう。しかし、もし長いメッセージは暗号化されている、またはメッセージの一部がわかっている場合、その攻撃が問題となる場合があります。いずれにせよ、RSAEP-OAEP方式は、攻撃を克服します。"
    },
    {
      "indent": 0,
      "text": "7.2.1 Encryption operation",
      "section_title": true,
      "ja": "7.2.1暗号化の操作"
    },
    {
      "indent": 3,
      "text": "RSAES-PKCS1-V1_5-ENCRYPT ((n, e), M)",
      "ja": "RSAES-PKCS1-v1_5の暗号化（（N、E）、M）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) recipient's RSA public key M message to be encrypted, an octet string of length at most k-11 octets, where k is the length in octets of the modulus n",
      "ja": "入力：暗号化する（N、E）受信者のRSA公開鍵Mメッセージ、kは係数nのオクテットの長さである最もK-11オクテットで長のオクテット列"
    },
    {
      "indent": 3,
      "text": "Output: C ciphertext, an octet string of length k; or \"message too long\"",
      "ja": "出力：C暗号文、長さkのオクテットストリング。または「メッセージが長すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Apply the EME-PKCS1-v1_5 encoding operation (Section 9.1.2.1) to the message M to produce an encoded message EM of length k-1 octets:",
      "ja": "1.長さk-1オクテットの符号化されたメッセージEMを生成するために、メッセージMにEME-PKCS1-v1_5の符号化演算（セクション9.1.2.1）を適用します。"
    },
    {
      "indent": 3,
      "text": "EM = EME-PKCS1-V1_5-ENCODE (M, k-1)",
      "ja": "MS = EME-PKCS1-v1_5のエンコード（M、K-1）"
    },
    {
      "indent": 3,
      "text": "If the encoding operation outputs \"message too long,\" then output \"message too long\" and stop.",
      "ja": "符号化演算の出力が「メッセージが長すぎる、」次に出力「メッセージが長すぎる」と止めます。"
    },
    {
      "indent": 3,
      "text": "2. Convert the encoded message EM to an integer message representative m: m = OS2IP (EM)",
      "ja": "M = OS2IP（EM）：2.エンコードされたメッセージEMは、整数を表すメッセージmに変換します"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSAEP encryption primitive (Section 5.1.1) to the public key (n, e) and the message representative m to produce an integer ciphertext representative c: c = RSAEP ((n, e), m)",
      "ja": "C = RSAEP（（N、E）、M）：3.公開鍵（N、e）及び整数暗号文代表cを生成することを表すメッセージmにRSAEP暗号プリミティブ（5.1.1項）を適用"
    },
    {
      "indent": 3,
      "text": "4. Convert the ciphertext representative c to a ciphertext C of length k octets: C = I2OSP (c, k)",
      "ja": "4.長さkオクテットの暗号文CのC暗号文代表換算：C = I2OSP（C、K）"
    },
    {
      "indent": 3,
      "text": "5. Output the ciphertext C.",
      "section_title": true,
      "ja": "5.出力暗号文C."
    },
    {
      "indent": 0,
      "text": "7.2.2 Decryption operation",
      "section_title": true,
      "ja": "7.2.2復号化操作"
    },
    {
      "indent": 3,
      "text": "RSAES-PKCS1-V1_5-DECRYPT (K, C)",
      "ja": "RSAES-PKCS1-v1_5の-DECRYPT（K、C）"
    },
    {
      "indent": 3,
      "text": "Input: K recipient's RSA private key C ciphertext to be decrypted, an octet string of length k, where k is the length in octets of the modulus n",
      "ja": "入力：kは、モジュラスNのオクテット長で復号化されるべきK個の受信者のRSA秘密鍵暗号文Cを、長さkのオクテットストリング、"
    },
    {
      "indent": 3,
      "text": "Output: M message, an octet string of length at most k-11; or \"decryption error\"",
      "ja": "出力：Mメッセージ、最もK-11における長さのオクテットストリング。または「復号化エラー」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the length of the ciphertext C is not k octets, output \"decryption error\" and stop.",
      "ja": "1.暗号文Cの長さがオクテットをK、出力「復号エラー」と停止されていない場合。"
    },
    {
      "indent": 3,
      "text": "2. Convert the ciphertext C to an integer ciphertext representative c: c = OS2IP (C).",
      "ja": "2.整数暗号文代表cに暗号文Cを変換する：C = OS2IP（C）。"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSADP decryption primitive to the private key (n, d) and the ciphertext representative c to produce an integer message representative m: m = RSADP ((n, d), c).",
      "ja": "M = RSADP（（N、D）、C）3.秘密鍵（N、D）と整数を表すメッセージmを生成する暗号文代表cにプリミティブRSADP復号を適用します。"
    },
    {
      "indent": 3,
      "text": "If RSADP outputs \"ciphertext out of range,\" then output \"decryption error\" and stop.",
      "ja": "「範囲外の暗号文、」RSADP出力する場合、出力「解読エラー」と止めます。"
    },
    {
      "indent": 3,
      "text": "4. Convert the message representative m to an encoded message EM of length k-1 octets: EM = I2OSP (m, k-1)",
      "ja": "EM = I2OSP（M、K-1）：4長さk-1オクテットの符号化されたメッセージEMを表すメッセージmを変換"
    },
    {
      "indent": 3,
      "text": "If I2OSP outputs \"integer too large,\" then output \"decryption error\" and stop.",
      "ja": "その後、出力「解読エラー」I2OSP出力「整数が大きすぎる」場合は、停止します。"
    },
    {
      "indent": 3,
      "text": "5. Apply the EME-PKCS1-v1_5 decoding operation to the encoded message EM to recover a message M: M = EME-PKCS1-V1_5-DECODE (EM).",
      "ja": "M = EME-PKCS1-v1_5のデコード（EM）：5.メッセージMを回復するためにコード化されたメッセージEMにEME-PKCS1-v1_5の復号化操作を適用します。"
    },
    {
      "indent": 3,
      "text": "If the decoding operation outputs \"decoding error,\" then output \"decryption error\" and stop.",
      "ja": "復号動作の出力が「復号エラー」、出力「復号エラー」と停止した場合。"
    },
    {
      "indent": 3,
      "text": "6. Output the message M.",
      "section_title": true,
      "ja": "6.出力メッセージM."
    },
    {
      "indent": 3,
      "text": "Note. It is important that only one type of error message is output by EME-PKCS1-v1_5, as ensured by steps 4 and 5. If this is not done, then an adversary may be able to use information extracted form the type of error message received to mount a chosen-ciphertext attack such as the one found in [4].",
      "ja": "注意。行われていない場合、攻撃者が情報抽出フォーム受信したエラーメッセージのタイプを使用することができる場合があり、ステップ4および5によって確保ようなエラーメッセージの一種類のみがEME-PKCS1-v1_5のが出力であることが重要ですこのような[4]に見られるものとして選択暗号文攻撃をマウントします。"
    },
    {
      "indent": 0,
      "text": "8. Signature schemes with appendix",
      "section_title": true,
      "ja": "付録8.署名方式"
    },
    {
      "indent": 3,
      "text": "A signature scheme with appendix consists of a signature generation operation and a signature verification operation, where the signature generation operation produces a signature from a message with a signer's private key, and the signature verification operation verifies the signature on the message with the signer's corresponding public key. To verify a signature constructed with this type of scheme it is necessary to have the message itself. In this way, signature schemes with appendix are distinguished from signature schemes with message recovery, which are not supported in this document.",
      "ja": "付録付き署名方式は、署名生成動作は署名者の秘密鍵を用いてメッセージから署名を生成する署名生成処理および署名検証処理、から成り、及び署名検証動作は、署名者の対応する公開してメッセージに署名を検証しますキー。スキームのこのタイプで構成署名を検証するために、メッセージ自体を有することが必要です。このように、付録付き署名方式については、このドキュメントではサポートされていないメッセージの回復、と署名方式とは区別されています。"
    },
    {
      "indent": 3,
      "text": "A signature scheme with appendix can be employed in a variety of applications. For instance, X.509 [6] employs such a scheme to authenticate the content of a certificate; the signature scheme with appendix defined here would be a suitable signature algorithm in that context. A related signature scheme could be employed in PKCS #7 [21], although for technical reasons, the current version of PKCS #7 separates a hash function from a signature scheme, which is different than what is done here.",
      "ja": "付録付き署名方式は、種々の用途に使用することができます。例えば、[6] X.509証明書の内容を認証するような方式を採用します。ここで定義された付録付き署名方式は、その文脈で適切な署名アルゴリズムであろう。技術的な理由のために、PKCS＃7の現在のバージョンはここで行われているものとは異なる署名方式、からハッシュ関数を分離しているが、関連する署名方式は、PKCS＃7 [21]に使用することができます。"
    },
    {
      "indent": 3,
      "text": "One signature scheme with appendix is specified in this document: RSASSA-PKCS1-v1_5.",
      "ja": "RSASSA-PKCS1-v1_5の：付録の一つの署名方式は、この文書で指定されています。"
    },
    {
      "indent": 3,
      "text": "The signature scheme with appendix given here follows a general model similar to that employed in IEEE P1363, by combining signature and verification primitives with an encoding method for signatures. The signature generation operations apply a message encoding operation to a message to produce an encoded message, which is then converted to an integer message representative. A signature primitive is then applied to the message representative to produce the signature. The signature verification operations apply a signature verification primitive to the signature to recover a message representative, which is then converted to an octet string. The message encoding operation is again applied to the message, and the result is compared to the recovered octet string. If there is a match, the signature is considered valid. (Note that this approach assumes that the signature and verification primitives have the message-recovery form and the encoding method is deterministic, as is the case for RSASP1/RSAVP1 and EMSA-PKCS1-v1_5. The signature generation and verification operations have a different form in P1363 for other primitives and encoding methods.)",
      "ja": "ここで指定された付録付き署名方式は、署名の符号化方式で署名と検証プリミティブを組み合わせることにより、IEEE P1363に用いられるものと同様の一般的なモデルに従います。署名生成操作は、次に整数を表すメッセージに変換され、エンコードされたメッセージを生成するメッセージに、メッセージ符号化演算を適用します。プリミティブ署名は、署名を生成することを表すメッセージに適用されます。署名検証動作は、次にオクテットストリングに変換されたメッセージ代表を回復するために署名にプリミティブ署名検証を適用します。メッセージエンコーディング動作が再びメッセージに適用され、その結果が回収オクテットストリングと比較されます。一致がある場合は、署名が有効であると考えられます。 （このアプローチは、署名及び検証プリミティブは、メッセージリカバリ形を有し、RSASP1 / RSAVP1とEMSA-PKCS1-v1_5のための場合のように符号化方式は、決定論的であると仮定することに注意してください。署名生成および検証動作は異なる形態を有します他のプリミティブと符号化方式のためのP1363です。）"
    },
    {
      "indent": 3,
      "text": "Editor's note. RSA Laboratories is investigating the possibility of including a scheme based on the PSS encoding methods specified in [3], which would be recommended for new applications.",
      "ja": "編集者注。 RSA研究所は、新しいアプリケーションのために推奨される[3]で指定されたPSS符号化方式に基づく方式、などの可能性を調査しています。"
    },
    {
      "indent": 0,
      "text": "8.1 RSASSA-PKCS1-v1_5",
      "section_title": true,
      "ja": "8.1 RSASSA-PKCS1-v1_5の"
    },
    {
      "indent": 3,
      "text": "RSASSA-PKCS1-v1_5 combines the RSASP1 and RSAVP1 primitives with the EME-PKCS1-v1_5 encoding method. It is compatible with the IFSSA scheme defined in the draft P1363 where the signature and verification primitives are IFSP-RSA1 and IFVP-RSA1 and the message encoding method is EMSA-PKCS1-v1_5 (which is not defined in P1363). The length of messages on which RSASSA-PKCS1-v1_5 can operate is either unrestricted or constrained by a very large number, depending on the hash function underlying the message encoding method.",
      "ja": "RSASSA-PKCS1-v1_5のは、EME-PKCS1-v1_5の符号化方式でRSASP1とRSAVP1プリミティブを組み合わせ。それは署名と検証プリミティブはIFSP  -  RSA1とIFVP-RSA1及びメッセージ符号化方式であるドラフトP1363に定義されIFSSA方式と互換性があること（P1363に定義されていない）EMSA-PKCS1-v1_5のです。 RSASSA-PKCS1-v1_5のが動作可能にメッセージの長さは無制限またはメッセージ符号化方法の基礎となるハッシュ関数に応じて、非常に大きな数によって制約のいずれかです。"
    },
    {
      "indent": 3,
      "text": "Assuming that the hash function in EMSA-PKCS1-v1_5 has appropriate properties and the key size is sufficiently large, RSASSA-PKCS1-v1_5 provides secure signatures, meaning that it is computationally infeasible to generate a signature without knowing the private key, and computationally infeasible to find a message with a given signature or two messages with the same signature. Also, in the encoding method EMSA-PKCS1-v1_5, a hash function identifier is embedded in the encoding. Because of this feature, an adversary must invert or find collisions of the particular hash function being used; attacking a different hash function than the one selected by the signer is not useful to the adversary.",
      "ja": "EMSA-PKCS1-v1_5の中にハッシュ関数は適切な特性を有し、キーサイズは、十分に大きいと仮定するとRSASSA-PKCS1-v1_5のは、秘密鍵を知らなくても、署名を生成することが計算上不可能、および計算上実行不可能であることを意味し、安全な署名を提供所与の署名または同一の署名を有する2つのメッセージを使用してメッセージを検索します。また、符号化方法EMSA-PKCS1-v1_5の中で、ハッシュ関数識別子は、符号化に埋め込まれます。この機能により、敵対者は、使用される特定のハッシュ関数の衝突を反転させるか、見つけなければなりません。署名者によって選択されたものとは異なるハッシュ関数を攻撃することは敵に有用ではありません。"
    },
    {
      "indent": 0,
      "text": "8.1.1 Signature generation operation",
      "section_title": true,
      "ja": "8.1.1署名生成動作"
    },
    {
      "indent": 3,
      "text": "RSASSA-PKCS1-V1_5-SIGN (K, M) Input: K signer's RSA private ke M message to be signed, an octet string",
      "ja": "RSASSA-PKCS1-v1_5の-SIGN（K、M）入力：Kの署名者のRSAプライベートKEのMメッセージが署名される、オクテット文字列"
    },
    {
      "indent": 3,
      "text": "Output: S signature, an octet string of length k, where k is the length in octets of the modulus n; \"message too long\" or \"modulus too short\" Steps:",
      "ja": "出力：S署名、kは係数nのオクテットの長さである長さkのオクテットストリング。 「メッセージが長すぎる」または「弾性率が短すぎる」の手順："
    },
    {
      "indent": 3,
      "text": "1. Apply the EMSA-PKCS1-v1_5 encoding operation (Section 9.2.1) to the message M to produce an encoded message EM of length k-1 octets:",
      "ja": "1.長さk-1オクテットの符号化されたメッセージEMを生成するために、メッセージMにEMSA-PKCS1-v1_5の符号化操作（9.2.1項）を適用します。"
    },
    {
      "indent": 3,
      "text": "EM = EMSA-PKCS1-V1_5-ENCODE (M, k-1)",
      "ja": "EM = EMSA-PKCS1-v1_5のエンコード（M、K-1）"
    },
    {
      "indent": 3,
      "text": "If the encoding operation outputs \"message too long,\" then output \"message too long\" and stop. If the encoding operation outputs \"intended encoded message length too short\" then output \"modulus too short\".",
      "ja": "符号化演算の出力が「メッセージが長すぎる、」次に出力「メッセージが長すぎる」と止めます。符号化操作の出力が「意図エンコードされたメッセージの長さが短すぎる」、出力「モジュラスが短すぎます」。"
    },
    {
      "indent": 3,
      "text": "2. Convert the encoded message EM to an integer message representative m: m = OS2IP (EM)",
      "ja": "M = OS2IP（EM）：2.エンコードされたメッセージEMは、整数を表すメッセージmに変換します"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSASP1 signature primitive (Section 5.2.1) to the private key K and the message representative m to produce an integer signature representative s: s = RSASP1 (K, m)",
      "ja": "3.生成するために、秘密鍵KにプリミティブRSASP1シグネチャ（5.2.1）とを表すメッセージmを適用整数署名代表S：S = RSASP1（K、M）"
    },
    {
      "indent": 3,
      "text": "4. Convert the signature representative s to a signature S of length k octets: S = I2OSP (s, k)",
      "ja": "4.署名代表sは長さkオクテットの署名Sに変換：S = I2OSP（S、K）"
    },
    {
      "indent": 3,
      "text": "5. Output the signature S.",
      "section_title": true,
      "ja": "5.出力署名S."
    },
    {
      "indent": 0,
      "text": "8.1.2 Signature verification operation",
      "section_title": true,
      "ja": "8.1.2署名検証動作"
    },
    {
      "indent": 3,
      "text": "RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)",
      "ja": "RSASSA-PKCS1-v1_5のベリファイ（（N、E）、M、S）"
    },
    {
      "indent": 3,
      "text": "Input: (n, e) signer's RSA public key M message whose signature is to be verified, an octet string S signature to be verified, an octet string of length k, where k is the length in octets of the modulus n",
      "ja": "入力：kは、モジュラスNのオクテットの長さであり、その署名を検証する（N、E）、署名者のRSA公開鍵Mメッセージ、オクテットストリングS署名を検証するため、長さkのオクテットストリング、"
    },
    {
      "indent": 3,
      "text": "Output: \"valid signature,\" \"invalid signature,\" or \"message too long\", or \"modulus too short\"",
      "ja": "出力：あまりにも長い間「有効な署名」「署名が無効」、または「メッセージ」、または「弾性短すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the length of the signature S is not k octets, output \"invalid signature\" and stop.",
      "ja": "1.署名Sの長さは、オクテットのk個の出力「無効な署名」と停止されていない場合。"
    },
    {
      "indent": 3,
      "text": "2. Convert the signature S to an integer signature representative s:",
      "section_title": true,
      "ja": "2.整数署名代表sの署名Sを変換します："
    },
    {
      "indent": 3,
      "text": "s = OS2IP (S)",
      "ja": "OS2IPのC =（C）"
    },
    {
      "indent": 3,
      "text": "3. Apply the RSAVP1 verification primitive (Section 5.2.2) to the public key (n, e) and the signature representative s to produce an integer message representative m:",
      "ja": "3.公開鍵（N、e）及び整数を表すメッセージmを生成する署名代表sまでRSAVP1確認プリミティブ（5.2.2項）を適用します。"
    },
    {
      "indent": 3,
      "text": "m = RSAVP1 ((n, e), s) If RSAVP1 outputs \"invalid\" then output \"invalid signature\" and stop.",
      "ja": "M = RSAVP1（（N、E）、S）RSAVP1は \"無効\"、出力 \"無効な署名\" を出力し、停止します。"
    },
    {
      "indent": 3,
      "text": "4. Convert the message representative m to an encoded message EM of length k-1 octets: EM = I2OSP (m, k-1)",
      "ja": "EM = I2OSP（M、K-1）：4長さk-1オクテットの符号化されたメッセージEMを表すメッセージmを変換"
    },
    {
      "indent": 3,
      "text": "If I2OSP outputs \"integer too large,\" then output \"invalid signature\" and stop.",
      "ja": "I2OSP出力が「整数大きすぎる、」、出力「無効な署名」と停止します。"
    },
    {
      "indent": 3,
      "text": "5. Apply the EMSA-PKCS1-v1_5 encoding operation (Section 9.2.1) to the message M to produce a second encoded message EM' of length k-1 octets:",
      "ja": "5.長さk-1オクテットの第2の符号化メッセージEM」を生成するためのメッセージMにEMSA-PKCS1-v1_5の符号化操作（9.2.1項）を適用します。"
    },
    {
      "indent": 3,
      "text": "EM' = EMSA-PKCS1-V1_5-ENCODE (M, k-1)",
      "ja": "EM」= EMSA-PKCS1-v1_5のエンコード（M、K-1）"
    },
    {
      "indent": 3,
      "text": "If the encoding operation outputs \"message too long,\" then output \"message too long\" and stop. If the encoding operation outputs \"intended encoded message length too short\" then output \"modulus too short\".",
      "ja": "符号化演算の出力が「メッセージが長すぎる、」次に出力「メッセージが長すぎる」と止めます。符号化操作の出力が「意図エンコードされたメッセージの長さが短すぎる」、出力「モジュラスが短すぎます」。"
    },
    {
      "indent": 3,
      "text": "6. Compare the encoded message EM and the second encoded message EM'. If they are the same, output \"valid signature\"; otherwise, output \"invalid signature.\"",
      "ja": "前記符号化されたメッセージEM及び第2の符号化メッセージEM」を比較します。それらが同じである場合、出力は「有効な署名」。それ以外の場合は、出力「無効な署名。」"
    },
    {
      "indent": 0,
      "text": "9. Encoding methods",
      "section_title": true,
      "ja": "9.エンコード方法"
    },
    {
      "indent": 3,
      "text": "Encoding methods consist of operations that map between octet string messages and integer message representatives.",
      "ja": "符号化方法は、オクテットストリングのメッセージと整数メッセージの代表との間でマッピング操作から成ります。"
    },
    {
      "indent": 3,
      "text": "Two types of encoding method are considered in this document: encoding methods for encryption, encoding methods for signatures with appendix.",
      "ja": "符号化方式の二つのタイプは、この文書では考慮されています暗号化のための方法、付録と署名のための符号化方式を符号化します。"
    },
    {
      "indent": 0,
      "text": "9.1 Encoding methods for encryption",
      "section_title": true,
      "ja": "暗号化のための9.1エンコーディング方法"
    },
    {
      "indent": 3,
      "text": "An encoding method for encryption consists of an encoding operation and a decoding operation. An encoding operation maps a message M to a message representative EM of a specified length; the decoding operation maps a message representative EM back to a message. The encoding and decoding operations are inverses.",
      "ja": "暗号化のための符号化方法は、符号化動作及び復号動作から成ります。符号化動作は、指定された長さのメッセージ代表EMにメッセージMをマッピングします。復号動作はバックメッセージにメッセージ代表EMをマッピングします。符号化及び復号化操作が逆です。"
    },
    {
      "indent": 3,
      "text": "The message representative EM will typically have some structure that can be verified by the decoding operation; the decoding operation will output \"decoding error\" if the structure is not present. The encoding operation may also introduce some randomness, so that different applications of the encoding operation to the same message will produce different representatives.",
      "ja": "メッセージの代表的なEMは、典型的には、復号動作によって確認することができるいくつかの構造を有することになります。構造が存在しない場合、復号動作は、出力「デコードエラー」になります。同じメッセージに符号化動作の異なるアプリケーションが異なる代表を生成するように符号化動作は、また、いくつかのランダム性を導入することができます。"
    },
    {
      "indent": 3,
      "text": "Two encoding methods for encryption are employed in the encryption schemes and are specified here: EME-OAEP and EME-PKCS1-v1_5.",
      "ja": "暗号化のための二つの符号化方式は、暗号化方式で採用されており、ここで指定されている：EME-OAEPとEME-PKCS1-v1_5のを。"
    },
    {
      "indent": 0,
      "text": "9.1.1 EME-OAEP",
      "section_title": true,
      "ja": "9.1.1 EME-OAEP"
    },
    {
      "indent": 3,
      "text": "This encoding method is parameterized by the choice of hash function and mask generation function. Suggested hash and mask generation functions are given in Section 10. This encoding method is based on the method found in [2].",
      "ja": "この符号化方式は、ハッシュ関数とマスク生成関数の選択によってパラメータ化されます。提案ハッシュマスク生成機能は、セクション10に与えられ、この符号化方法は、に見られる方法に基づいている[2]。"
    },
    {
      "indent": 0,
      "text": "9.1.1.1 Encoding operation",
      "section_title": true,
      "ja": "9.1.1.1符号化動作"
    },
    {
      "indent": 3,
      "text": "EME-OAEP-ENCODE (M, P, emLen)",
      "ja": "EME-OAEP-ENCODE（M、P、emLen）"
    },
    {
      "indent": 3,
      "text": "Options: Hash hash function (hLen denotes the length in octet of the hash function output) MGF mask generation function",
      "ja": "オプション：ハッシュハッシュ関数（さhLenはハッシュ関数出力のオクテットの長さを示す）MGFマスク生成関数"
    },
    {
      "indent": 3,
      "text": "Input: M message to be encoded, an octet string of length at most emLen-1-2hLen P encoding parameters, an octet string emLen intended length in octets of the encoded message, at least 2hLen+1",
      "ja": "入力：Mメッセージは最もemLen-1-2hLen Pの符号化パラメータで長のオクテット列、符号化する、オクテットストリングemLenは、エンコードされたメッセージのオクテットの長さを意図し、少なくとも2hLen + 1"
    },
    {
      "indent": 3,
      "text": "Output: EM encoded message, an octet string of length emLen; \"message too long\" or \"parameter string too long\"",
      "ja": "出力：EM符号化されたメッセージ、長さemLenのオクテットストリング。 「メッセージが長すぎる」または「パラメータ文字列が長すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the length of P is greater than the input limitation for the hash function (2^61-1 octets for SHA-1) then output \"parameter string too long\" and stop.",
      "ja": "1. Pの長さは、ハッシュ関数（SHA-1の2 ^ 61-1オクテット）、出力「パラメータ文字列が長すぎる」と停止の入力制限よりも大きい場合。"
    },
    {
      "indent": 3,
      "text": "2. If ||M|| > emLen-2hLen-1 then output \"message too long\" and stop.",
      "section_title": true,
      "ja": "2. || M ||もし> emLen-2hLen-1、出力「のメッセージが長すぎる」と止めます。"
    },
    {
      "indent": 3,
      "text": "3. Generate an octet string PS consisting of emLen-||M||-2hLen-1 zero octets. The length of PS may be 0.",
      "ja": "3. emLen- || M || -2hLen-1ゼロオクテットで構成されるオクテット列PSを生成します。 PSの長さは0であってもよいです。"
    },
    {
      "indent": 3,
      "text": "4. Let pHash = Hash(P), an octet string of length hLen.",
      "section_title": true,
      "ja": "4. pHash =ハッシュ（P）、長さhLenのオクテットストリングをしましょう。"
    },
    {
      "indent": 3,
      "text": "5. Concatenate pHash, PS, the message M, and other padding to form a data block DB as: DB = pHash || PS || 01 || M",
      "ja": "5.連結しpHash、PSなどのデータブロックDBを形成するために、メッセージM、および他のパディング：DB = pHash || PS || 01 || M"
    },
    {
      "indent": 3,
      "text": "6. Generate a random octet string seed of length hLen.",
      "section_title": true,
      "ja": "6.長さhLenのランダムオクテット文字列の種を生成します。"
    },
    {
      "indent": 3,
      "text": "7. Let dbMask = MGF(seed, emLen-hLen).",
      "section_title": true,
      "ja": "7. dbMask = MGF（種子、emLen-さhLen）してみましょう。"
    },
    {
      "indent": 3,
      "text": "8. Let maskedDB = DB \\xor dbMask.",
      "section_title": true,
      "ja": "8.レッツmaskedDB = DB \\ XOR dbMask。"
    },
    {
      "indent": 3,
      "text": "9. Let seedMask = MGF(maskedDB, hLen).",
      "section_title": true,
      "ja": "9. seedMask = MGF（maskedDB、さhLen）をしてみましょう。"
    },
    {
      "indent": 3,
      "text": "10. Let maskedSeed = seed \\xor seedMask.",
      "section_title": true,
      "ja": "10.レッツmaskedSeed =シード\\の排他的論理和seedMask。"
    },
    {
      "indent": 3,
      "text": "11. Let EM = maskedSeed || maskedDB.",
      "section_title": true,
      "ja": "11.レッツEM = maskedSeed || maskedDB。"
    },
    {
      "indent": 3,
      "text": "12. Output EM.",
      "section_title": true,
      "ja": "12.出力EM。"
    },
    {
      "indent": 0,
      "text": "9.1.1.2 Decoding operation EME-OAEP-DECODE (EM, P)",
      "section_title": true,
      "ja": "9.1.1.2復号動作EME-OAEP-DECODE（EM、P）"
    },
    {
      "indent": 3,
      "text": "Options: Hash hash function (hLen denotes the length in octet of the hash function output)",
      "ja": "オプション：ハッシュハッシュ関数（さhLenはハッシュ関数出力のオクテットの長さを示します）"
    },
    {
      "indent": 3,
      "text": "MGF mask generation function",
      "ja": "MGFマスク生成関数"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "EM encoded message, an octet string of length at least 2hLen+1 P encoding parameters, an octet string",
      "ja": "EM符号化されたメッセージ長のオクテット列少なくとも2hLen + 1 Pの符号化パラメータ、オクテットストリング"
    },
    {
      "indent": 3,
      "text": "Output: M recovered message, an octet string of length at most ||EM||-1-2hLen; or \"decoding error\"",
      "ja": "出力：Mは、メッセージ、EM || || -1-2hLen最大で長さのオクテット文字列を回復しました。または「デコードエラー」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the length of P is greater than the input limitation for the hash function (2^61-1 octets for SHA-1) then output \"parameter string too long\" and stop.",
      "ja": "1. Pの長さは、ハッシュ関数（SHA-1の2 ^ 61-1オクテット）、出力「パラメータ文字列が長すぎる」と停止の入力制限よりも大きい場合。"
    },
    {
      "indent": 3,
      "text": "2. If ||EM|| < 2hLen+1, then output \"decoding error\" and stop.",
      "section_title": true,
      "ja": "2. EM || ||もし<2hLen + 1、出力「復号エラー」と止めます。"
    },
    {
      "indent": 3,
      "text": "3. Let maskedSeed be the first hLen octets of EM and let maskedDB be the remaining ||EM|| - hLen octets.",
      "ja": "3.レッツは、EMの最初さhLenオクテットとmaskedDBが残っている|| EMなりましょうmaskedSeed || - さhLenオクテット。"
    },
    {
      "indent": 3,
      "text": "4. Let seedMask = MGF(maskedDB, hLen).",
      "section_title": true,
      "ja": "4. seedMask = MGF（maskedDB、さhLen）をしてみましょう。"
    },
    {
      "indent": 3,
      "text": "5. Let seed = maskedSeed \\xor seedMask.",
      "section_title": true,
      "ja": "5.シード= maskedSeed \\ XOR seedMaskしてみましょう。"
    },
    {
      "indent": 3,
      "text": "6. Let dbMask = MGF(seed, ||EM|| - hLen).",
      "section_title": true,
      "ja": "6. dbMask = MGF（ - さhLenシード、|| || EM）してみましょう。"
    },
    {
      "indent": 3,
      "text": "7. Let DB = maskedDB \\xor dbMask.",
      "section_title": true,
      "ja": "7. DB = maskedDB \\のXOR dbMaskをしてみましょう。"
    },
    {
      "indent": 3,
      "text": "8. Let pHash = Hash(P), an octet string of length hLen.",
      "section_title": true,
      "ja": "8. pHash =ハッシュ（P）、長さhLenのオクテットストリングをしましょう。"
    },
    {
      "indent": 3,
      "text": "9. Separate DB into an octet string pHash' consisting of the first hLen octets of DB, a (possibly empty) octet string PS consisting of consecutive zero octets following pHash', and a message M as:",
      "ja": "、およびメッセージM「としてDB、pHash次の連続ゼロのオクテットからなる（おそらく空の）オクテットストリングPSの最初さhLenオクテットから成る」オクテットストリングpHashに9.個別DB："
    },
    {
      "indent": 3,
      "text": "DB = pHash' || PS || 01 || M",
      "ja": "DB =床「|| PS || 01 || A."
    },
    {
      "indent": 3,
      "text": "If there is no 01 octet to separate PS from M, output \"decoding error\" and stop.",
      "ja": "M、出力「復号エラー」からPSを分離し、停止するには、no 01オクテットが存在しない場合。"
    },
    {
      "indent": 3,
      "text": "10. If pHash' does not equal pHash, output \"decoding error\" and stop.",
      "section_title": true,
      "ja": "10. pHash「が等しくないpHash、出力 『復号エラー』と停止を行う場合。"
    },
    {
      "indent": 3,
      "text": "11. Output M.",
      "section_title": true,
      "ja": "11.出力M."
    },
    {
      "indent": 0,
      "text": "9.1.2 EME-PKCS1-v1_5",
      "section_title": true,
      "ja": "EME-9.1.2-PKCS1 v1_5の"
    },
    {
      "indent": 3,
      "text": "This encoding method is the same as in PKCS #1 v1.5, Section 8: Encryption Process.",
      "ja": "暗号化処理：この符号化方法は、PKCS＃1 V1.5、セクション8と同じです。"
    },
    {
      "indent": 0,
      "text": "9.1.2.1 Encoding operation",
      "section_title": true,
      "ja": "9.1.2.1符号化動作"
    },
    {
      "indent": 3,
      "text": "EME-PKCS1-V1_5-ENCODE (M, emLen)",
      "ja": "EME-PKCS1-v1_5のエンコード（M、emLen）"
    },
    {
      "indent": 3,
      "text": "Input: M message to be encoded, an octet string of length at most emLen-10 emLen intended length in octets of the encoded message",
      "ja": "入力：Mメッセージは、emLen-10 emLenは、エンコードされたメッセージのオクテットの長さを意図せいぜい長のオクテット列をエンコードします"
    },
    {
      "indent": 3,
      "text": "Output: EM encoded message, an octet string of length emLen; or \"message too long\"",
      "ja": "出力：EM符号化されたメッセージ、長さemLenのオクテットストリング。または「メッセージが長すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the length of the message M is greater than emLen - 10 octets, output \"message too long\" and stop.",
      "ja": "1.メッセージMの長さがemLenよりも大きい場合 -  10オクテット、出力「あまりにも長いメッセージ」と止めます。"
    },
    {
      "indent": 3,
      "text": "2. Generate an octet string PS of length emLen-||M||-2 consisting of pseudorandomly generated nonzero octets. The length of PS will be at least 8 octets.",
      "ja": "2. ||長emLen- || Mのオクテット列PSを生成-2擬似乱数発生ゼロ以外のオクテットからなります。 PSの長さは少なくとも8つのオクテットになります。"
    },
    {
      "indent": 3,
      "text": "3. Concatenate PS, the message M, and other padding to form the encoded message EM as:",
      "ja": "3.連結しPS、メッセージM、としてコード化されたメッセージEMを形成する他のパディング。"
    },
    {
      "indent": 3,
      "text": "EM = 02 || PS || 00 || M",
      "ja": "EMは、02 = || PS || 00 || M"
    },
    {
      "indent": 3,
      "text": "4. Output EM.",
      "section_title": true,
      "ja": "4.出力EM。"
    },
    {
      "indent": 0,
      "text": "9.1.2.2 Decoding operation",
      "section_title": true,
      "ja": "9.1.2.2復号動作"
    },
    {
      "indent": 3,
      "text": "EME-PKCS1-V1_5-DECODE (EM)",
      "ja": "EME-PKCS1-v1_5のデコード（MS）"
    },
    {
      "indent": 3,
      "text": "Input: EM encoded message, an octet string of length at least 10",
      "ja": "入力：EM符号化されたメッセージ長のオクテット列の少なくとも10"
    },
    {
      "indent": 3,
      "text": "Output: M recovered message, an octet string of length at most ||EM||-10; or \"decoding error\"",
      "ja": "出力：Mがメッセージ、最大でも長のオクテット列を回収|| || EM -10。または「デコードエラー」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. If the length of the encoded message EM is less than 10, output \"decoding error\" and stop.",
      "ja": "1.エンコードされたメッセージEMの長さが10未満、出力「復号エラー」で停止します。"
    },
    {
      "indent": 3,
      "text": "2. Separate the encoded message EM into an octet string PS consisting of nonzero octets and a message M as: EM = 02 || PS || 00 || M.",
      "ja": "EMは、02 = ||：2.非ゼロオクテットと、メッセージMからなるオクテットストリングPSにエンコードされたメッセージEMを分離PS || 00 || M."
    },
    {
      "indent": 3,
      "text": "If the first octet of EM is not 02, or if there is no 00 octet to separate PS from M, output \"decoding error\" and stop.",
      "ja": "EMの最初のオクテットが02でない場合、またはM、出力「復号エラー」からPSを分離し、停止するには、no 00オクテットが存在しない場合。"
    },
    {
      "indent": 3,
      "text": "3. If the length of PS is less than 8 octets, output \"decoding error\" and stop.",
      "ja": "3. PSの長さ未満8つのオクテット、出力「復号エラー」で停止します。"
    },
    {
      "indent": 3,
      "text": "4. Output M.",
      "section_title": true,
      "ja": "4.出力M."
    },
    {
      "indent": 0,
      "text": "9.2 Encoding methods for signatures with appendix",
      "section_title": true,
      "ja": "付録と署名の9.2符号化方式"
    },
    {
      "indent": 3,
      "text": "An encoding method for signatures with appendix, for the purposes of this document, consists of an encoding operation. An encoding operation maps a message M to a message representative EM of a specified length. (In future versions of this document, encoding methods may be added that also include a decoding operation.)",
      "ja": "付録と署名の符号化方法は、この文書の目的のために、符号化動作から成ります。符号化動作は、指定された長さのメッセージ代表EMにメッセージMをマッピングします。 （この文書の将来のバージョンでは、符号化方法は、復号化動作を含むことを添加してもよいです。）"
    },
    {
      "indent": 3,
      "text": "One encoding method for signatures with appendix is employed in the encryption schemes and is specified here: EMSA-PKCS1-v1_5.",
      "ja": "付録付き署名のための1つの符号化方式は、暗号化方式で採用されており、ここで指定されていますEMSA-PKCS1-v1_5の。"
    },
    {
      "indent": 0,
      "text": "9.2.1 EMSA-PKCS1-v1_5",
      "section_title": true,
      "ja": "9.2.1 EMSA-PKCS1-v1_5の"
    },
    {
      "indent": 3,
      "text": "This encoding method only has an encoding operation.",
      "ja": "この符号化方法は、符号化動作を有しています。"
    },
    {
      "indent": 3,
      "text": "EMSA-PKCS1-v1_5-ENCODE (M, emLen)",
      "ja": "EMSA-PKCS1-v1_5のエンコード（M、emLen）"
    },
    {
      "indent": 3,
      "text": "Option: Hash hash function (hLen denotes the length in octet of the hash function output)",
      "ja": "オプション：ハッシュハッシュ関数（さhLenはハッシュ関数出力のオクテットの長さを示します）"
    },
    {
      "indent": 3,
      "text": "Input: M message to be encoded emLen intended length in octets of the encoded message, at least ||T|| + 10, where T is the DER encoding of a certain value computed during the encoding operation",
      "ja": "入力：emLenを符号化するMメッセージがエンコードされたメッセージ、少なくとも|| Tのオクテットの長さを意図|| Tは、符号化動作中に計算され、特定の値のDER符号化で+ 10、"
    },
    {
      "indent": 3,
      "text": "Output: EM encoded message, an octet string of length emLen; or \"message too long\" or \"intended encoded message length too short\"",
      "ja": "出力：EM符号化されたメッセージ、長さemLenのオクテットストリング。または「メッセージが長すぎる」または「意図エンコードされたメッセージの長さが短すぎます」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Apply the hash function to the message M to produce a hash value H:",
      "ja": "1ハッシュ値Hを生成するために、メッセージMにハッシュ関数を適用します。"
    },
    {
      "indent": 3,
      "text": "H = Hash(M).",
      "ja": "H =ハッシュ（M）。"
    },
    {
      "indent": 3,
      "text": "If the hash function outputs \"message too long,\" then output \"message too long\".",
      "ja": "ハッシュ関数の出力した場合、「メッセージが長すぎる、」その後、出力「のメッセージが長すぎます」。"
    },
    {
      "indent": 3,
      "text": "2. Encode the algorithm ID for the hash function and the hash value into an ASN.1 value of type DigestInfo (see Section 11) with the Distinguished Encoding Rules (DER), where the type DigestInfo has the syntax",
      "ja": "タイプDigestInfo構文を有する識別符号化規則（DER）とハッシュ関数とタイプDigestInfoのASN.1値にハッシュ値2.エンコードアルゴリズムID（セクション11を参照）、"
    },
    {
      "indent": 3,
      "text": "DigestInfo::=SEQUENCE{\n  digestAlgorithm  AlgorithmIdentifier,\n  digest OCTET STRING }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first field identifies the hash function and the second contains the hash value. Let T be the DER encoding.",
      "ja": "最初のフィールドは、ハッシュ関数を識別し、第二のハッシュ値を含みます。 TはDERエンコーディングとします。"
    },
    {
      "indent": 3,
      "text": "3. If emLen is less than ||T|| + 10 then output \"intended encoded message length too short\".",
      "ja": "3. emLenは|| T未満の場合は|| + 10、出力「意図エンコードされたメッセージの長さが短すぎます」。"
    },
    {
      "indent": 3,
      "text": "4. Generate an octet string PS consisting of emLen-||T||-2 octets with value FF (hexadecimal). The length of PS will be at least 8 octets.",
      "ja": "4. emLen- || T ||からなるオクテット列PSを生成-2値FF（16進数）とのオクテット。 PSの長さは少なくとも8つのオクテットになります。"
    },
    {
      "indent": 3,
      "text": "5. Concatenate PS, the DER encoding T, and other padding to form the encoded message EM as: EM = 01 || PS || 00 || T",
      "ja": "5.連結しPS、DERエンコーディングT、として符号化されたメッセージEMを形成する他のパディング：EM 01 = || PS || 00 || T"
    },
    {
      "indent": 3,
      "text": "6. Output EM.",
      "section_title": true,
      "ja": "6.出力EM。"
    },
    {
      "indent": 0,
      "text": "10. Auxiliary Functions",
      "section_title": true,
      "ja": "10.補助機能"
    },
    {
      "indent": 3,
      "text": "This section specifies the hash functions and the mask generation functions that are mentioned in the encoding methods (Section 9).",
      "ja": "このセクションでは、符号化方法（セクション9）に記載されているハッシュ関数とマスク生成関数を指定します。"
    },
    {
      "indent": 0,
      "text": "10.1 Hash Functions",
      "section_title": true,
      "ja": "10.1ハッシュ関数"
    },
    {
      "indent": 3,
      "text": "Hash functions are used in the operations contained in Sections 7, 8 and 9. Hash functions are deterministic, meaning that the output is completely determined by the input. Hash functions take octet strings of variable length, and generate fixed length octet strings. The hash functions used in the operations contained in Sections 7, 8 and 9 should be collision resistant. This means that it is infeasible to find two distinct inputs to the hash function that produce the same output. A collision resistant hash function also has the desirable property of being one-way; this means that given an output, it is infeasible to find an input whose hash is the specified output. The property of collision resistance is especially desirable for RSASSA-PKCS1-v1_5, as it makes it infeasible to forge signatures. In addition to the requirements, the hash function should yield a mask generation function (Section 10.2) with pseudorandom output.",
      "ja": "ハッシュ関数は、出力が完全に入力することによって決定されることを意味し、7、8、9ハッシュ関数が決定的であるセクションに含まれる操作に使用されます。ハッシュ関数は、可変長のオクテット文字列を取り、固定長のオクテット文字列を生成します。セクション7、図8及び図9に含まれる操作に使用されるハッシュ関数は衝突耐性であるべきです。同じ出力を生成するハッシュ関数への2つの異なる入力を見つけることは不可能であることを意味します。衝突困難ハッシュ関数はまた、一方向であるという望ましい特性を有しています。これは、出力が与えられると、そのハッシュ指定された出力である入力を見つけることが不可能であることを意味します。それは不可能署名を偽造することができるように衝突抵抗の性質は、RSASSA-PKCS1-v1_5のために特に望ましいです。要件に加えて、ハッシュ関数は擬似ランダム出力を有するマスク生成関数（セクション10.2）を得なければなりません。"
    },
    {
      "indent": 3,
      "text": "Three hash functions are recommended for the encoding methods in this document: MD2 [15], MD5 [17], and SHA-1 [16]. For the EME-OAEP encoding method, only SHA-1 is recommended. For the EMSA-PKCS1-v1_5 encoding method, SHA-1 is recommended for new applications. MD2 and MD5 are recommended only for compatibility with existing applications based on PKCS #1 v1.5.",
      "ja": "三つのハッシュ関数は、この文書に記載されている符号化方式のために推奨される：[15] MD2、MD5 [17]、およびSHA-1 [16]。 EME-OAEP符号化方式のため、唯一のSHA-1が推奨されます。 EMSA-PKCS1-v1_5の符号化方法については、SHA-1は、新しいアプリケーションのために推奨されます。 MD2とMD5だけPKCS＃1 v1.5のに基づいて既存のアプリケーションとの互換性のために推奨されています。"
    },
    {
      "indent": 3,
      "text": "The hash functions themselves are not defined here; readers are referred to the appropriate references ([15], [17] and [16]).",
      "ja": "自身がここで定義されていないハッシュ関数。読者は、適切な参照（[15]、[17]及び[16]）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Note. Version 1.5 of this document also allowed for the use of MD4 in signature schemes. The cryptanalysis of MD4 has progressed significantly in the intervening years. For example, Dobbertin [10] demonstrated how to find collisions for MD4 and that the first two rounds of MD4 are not one-way [11]. Because of these results and others (e.g. [9]), MD4 is no longer recommended. There have also been advances in the cryptanalysis of MD2 and MD5, although not enough to warrant removal from existing applications. Rogier and Chauvaud [19] demonstrated how to find collisions in a modified version of MD2. No one has demonstrated how to find collisions for the full MD5 algorithm, although partial results have been found (e.g. [8]). For new applications, to address these concerns, SHA-1 is preferred.",
      "ja": "注意。このドキュメントのバージョン1.5はまた、署名方式におけるMD4の使用を可能にしました。 MD4の暗号解読は、介在年で大幅に進歩しています。例えば、[11] Dobbertin [10] MD4のために衝突を見つける方法を実証し、MD4の最初の2ラウンドは、一方向ではないこと。なぜなら、これらの結果と他の（例えば、[9]）、MD4はもはや推奨されません。また、既存のアプリケーションから除去することを保証するものの十分ではなく、MD2とMD5の暗号解読の進展がありました。ロジェとChauvaud [19] MD2の修正バージョンで衝突を見つける方法を実証しました。部分的な結果が発見されているが誰も、完全なMD5アルゴリズムの衝突を発見する方法を示さなかった（例えば[8]）。新しいアプリケーションでは、これらの懸念に対処するために、SHA-1が好ましいです。"
    },
    {
      "indent": 0,
      "text": "10.2 Mask Generation Functions",
      "section_title": true,
      "ja": "10.2マスク生成関数"
    },
    {
      "indent": 3,
      "text": "A mask generation function takes an octet string of variable length and a desired output length as input, and outputs an octet string of the desired length. There may be restrictions on the length of the input and output octet strings, but such bounds are generally very large. Mask generation functions are deterministic; the octet string output is completely determined by the input octet string. The output of a mask generation function should be pseudorandom, that is, if the seed to the function is unknown, it should be infeasible to distinguish the output from a truly random string. The plaintext-awareness of RSAES-OAEP relies on the random nature of the output of the mask generation function, which in turn relies on the random nature of the underlying hash.",
      "ja": "マスク生成関数は、入力として、可変長と所望の出力長のオクテット列を受け取り、所望の長さのオクテット列を出力します。そこ入出力オクテット文字列の長さに制限があることが、そのような境界は、一般的に非常に大きいことがあります。マスク生成関数は決定されています。オクテットストリングの出力が完全に入力されたオクテットストリングによって決定されます。マスク生成関数の出力は、関数にシードが未知である場合には、真にランダムな文字列からの出力を区別するために実行不可能であるべきであるが、擬似ランダムであるべきです。 RSAES-OAEPの平文意識は順番に基本的なハッシュのランダム性に依存しているマスク生成関数の出力のランダムな性質に依存しています。"
    },
    {
      "indent": 3,
      "text": "One mask generation function is recommended for the encoding methods in this document, and is defined here: MGF1, which is based on a hash function. Future versions of this document may define other mask generation functions.",
      "ja": "一つのマスク生成関数は、この文書の符号化方式に推奨され、そしてここで定義される：ハッシュ関数に基づいてMGF1、。この文書の将来のバージョンは、他のマスク生成関数を定義することができます。"
    },
    {
      "indent": 0,
      "text": "10.2.1 MGF1",
      "section_title": true,
      "ja": "10.2.1 MGF1"
    },
    {
      "indent": 3,
      "text": "MGF1 is a Mask Generation Function based on a hash function.",
      "ja": "MGF1はハッシュ関数に基づいて、マスク生成関数です。"
    },
    {
      "indent": 3,
      "text": "MGF1 (Z, l)",
      "ja": "MGF1（Z、L）"
    },
    {
      "indent": 3,
      "text": "Options: Hash hash function (hLen denotes the length in octets of the hash function output)",
      "ja": "オプション：ハッシュハッシュ関数（さhLenはハッシュ関数出力のオクテットの長さを示します）"
    },
    {
      "indent": 3,
      "text": "Input: Z seed from which mask is generated, an octet string l intended length in octets of the mask, at most 2^32(hLen)",
      "ja": "入力：マスクが生成されるZ種子、マスクのオクテットの長さを意図オクテットストリングL、最大で2 ^ 32（hlen）フィールド"
    },
    {
      "indent": 3,
      "text": "Output: mask mask, an octet string of length l; or \"mask too long\"",
      "ja": "出力：マスク、マスク、長さLのオクテットストリング。または「長すぎるマスク」"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1.If l > 2^32(hLen), output \"mask too long\" and stop.",
      "section_title": true,
      "ja": "1.If Lは> 2 ^ 32（hlen）フィールド、出力 \"マスクが長すぎる\" と止めます。"
    },
    {
      "indent": 3,
      "text": "2.Let T be the empty octet string.",
      "section_title": true,
      "ja": "2.Let Tは、空のオクテット文字列です。"
    },
    {
      "indent": 3,
      "text": "3.For counter from 0 to \\lceil{l / hLen}\\rceil-1, do the following:",
      "section_title": true,
      "ja": "rceil-1 0から\\ lceil {L /さhLen} \\に3.Forカウンタ、次の操作を行います。"
    },
    {
      "indent": 3,
      "text": "a.Convert counter to an octet string C of length 4 with the primitive I2OSP: C = I2OSP (counter, 4)",
      "ja": "プリミティブI2OSPと長さ4のオクテット列Cにa.Convertカウンタ：C = I2OSP（カウンタ、4）"
    },
    {
      "indent": 3,
      "text": "b.Concatenate the hash of the seed Z and C to the octet string T: T = T || Hash (Z || C)",
      "ja": "オクテットストリングTに種子ZとCのb.Concatenateハッシュ：T = T ||ハッシュ（Z || C）"
    },
    {
      "indent": 3,
      "text": "4.Output the leading l octets of T as the octet string mask.",
      "section_title": true,
      "ja": "オクテットストリングマスクとしてTの主要Lオクテット4.Output。"
    },
    {
      "indent": 0,
      "text": "11. ASN.1 syntax",
      "section_title": true,
      "ja": "11. ASN.1構文"
    },
    {
      "indent": 0,
      "text": "11.1 Key representation",
      "section_title": true,
      "ja": "11.1キー表現"
    },
    {
      "indent": 3,
      "text": "This section defines ASN.1 object identifiers for RSA public and private keys, and defines the types RSAPublicKey and RSAPrivateKey. The intended application of these definitions includes X.509 certificates, PKCS #8 [22], and PKCS #12 [23].",
      "ja": "このセクションでは、RSA公開鍵と秘密鍵のASN.1オブジェクト識別子を定義し、タイプのRSAPublicKeyとRSAPrivateKeyを定義します。これらの定義の意図された用途は、X.509証明書、PKCS＃8 [22]、およびPKCS＃12 [23]を含みます。"
    },
    {
      "indent": 3,
      "text": "The object identifier rsaEncryption identifies RSA public and private keys as defined in Sections 11.1.1 and 11.1.2. The parameters field associated with this OID in an AlgorithmIdentifier shall have type NULL.",
      "ja": "セクション11.1.1および11.1.2に定義されているオブジェクト識別子rsaEncryptionはRSA公開鍵と秘密鍵を識別する。 AlgorithmIdentifierにこのOIDに関連したパラメータフィールドは、タイプNULLを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "rsaEncryption OBJECT IDENTIFIER ::= {pkcs-1 1}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All of the definitions in this section are the same as in PKCS #1 v1.5.",
      "ja": "このセクションの定義のすべては、PKCS＃1 v1.5のと同じです。"
    },
    {
      "indent": 0,
      "text": "11.1.1 Public-key syntax",
      "section_title": true,
      "ja": "11.1.1公開鍵構文"
    },
    {
      "indent": 3,
      "text": "An RSA public key should be represented with the ASN.1 type RSAPublicKey:",
      "ja": "RSA公開鍵はASN.1タイプのRSAPublicKeyで表現する必要があります。"
    },
    {
      "indent": 3,
      "text": "RSAPublicKey::=SEQUENCE{\n  modulus INTEGER, -- n\n  publicExponent INTEGER -- e }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(This type is specified in X.509 and is retained here for compatibility.)",
      "ja": "（このタイプは、X.509で指定されており、互換性のためにここに保持されます。）"
    },
    {
      "indent": 3,
      "text": "The fields of type RSAPublicKey have the following meanings: -modulus is the modulus n. -publicExponent is the public exponent e.",
      "ja": "タイプのRSAPublicKeyのフィールドは以下の意味があります。-modulusは、法nです。 -publicExponentは、公開指数eです。"
    },
    {
      "indent": 0,
      "text": "11.1.2 Private-key syntax",
      "section_title": true,
      "ja": "11.1.2プライベートキー構文"
    },
    {
      "indent": 3,
      "text": "An RSA private key should be represented with ASN.1 type RSAPrivateKey:",
      "ja": "RSA秘密鍵はASN.1タイプのRSAPrivateKeyで表現する必要があります。"
    },
    {
      "indent": 3,
      "text": "RSAPrivateKey ::= SEQUENCE {\n  version Version,\n  modulus INTEGER, -- n\n  publicExponent INTEGER, -- e\n  privateExponent INTEGER, -- d\n  prime1 INTEGER, -- p\n  prime2 INTEGER, -- q\n  exponent1 INTEGER, -- d mod (p-1)\n  exponent2 INTEGER, -- d mod (q-1)\n  coefficient INTEGER -- (inverse of q) mod p }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Version ::= INTEGER",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields of type RSAPrivateKey have the following meanings:",
      "ja": "型RSAPrivateKeyの各フィールドの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "-version is the version number, for compatibility with future revisions of this document. It shall be 0 for this version of the document. -modulus is the modulus n. -publicExponent is the public exponent e. -privateExponent is the private exponent d. -prime1 is the prime factor p of n. -prime2 is the prime factor q of n. -exponent1 is d mod (p-1). -exponent2 is d mod (q-1). -coefficient is the Chinese Remainder Theorem coefficient q-1 mod p.",
      "ja": "-versionは、このドキュメントの今後の改正との互換性のため、バージョン番号です。これは、ドキュメントのこのバージョンでは0でなければなりません。 -modulusは、モジュラスNです。 -publicExponentは、公開指数eです。 -privateExponentは、プライベート指数dです。 -prime1は、Nの素因数Pです。 -prime2は、Nの素因数Qです。 -exponent1は、dのmod（P-1）です。 -exponent2は、D MOD（Q-1）です。 -coefficientは、中国剰余定理係数q-1のmod Pです。"
    },
    {
      "indent": 0,
      "text": "11.2 Scheme identification",
      "section_title": true,
      "ja": "11.2 Schemeの識別"
    },
    {
      "indent": 3,
      "text": "This section defines object identifiers for the encryption and signature schemes. The schemes compatible with PKCS #1 v1.5 have the same definitions as in PKCS #1 v1.5. The intended application of these definitions includes X.509 certificates and PKCS #7.",
      "ja": "このセクションでは、暗号化および署名スキームのためのオブジェクト識別子を定義します。 PKCS＃1 V1.5と互換性スキームは、PKCS＃1 V1.5と同じ定義を有します。これらの定義の意図する用途には、X.509証明書およびPKCS＃7を含んでいます。"
    },
    {
      "indent": 0,
      "text": "11.2.1 Syntax for RSAES-OAEP",
      "section_title": true,
      "ja": "RSAES-OAEPのための11.2.1構文"
    },
    {
      "indent": 3,
      "text": "The object identifier id-RSAES-OAEP identifies the RSAES-OAEP encryption scheme.",
      "ja": "オブジェクト識別子ID-RSAES-OAEPはRSAES-OAEP暗号化方式を識別する。"
    },
    {
      "indent": 3,
      "text": "id-RSAES-OAEP OBJECT IDENTIFIER ::= {pkcs-1 7}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The parameters field associated with this OID in an AlgorithmIdentifier shall have type RSAEP-OAEP-params:",
      "ja": "AlgorithmIdentifierにこのOIDに関連したパラメータフィールドは、タイプRSAEP-OAEP-のparamsを持っていなければなりません。"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP-params ::=  SEQUENCE {\n  hashFunc [0] AlgorithmIdentifier {{oaepDigestAlgorithms}}\n    DEFAULT sha1Identifier,\n  maskGenFunc [1] AlgorithmIdentifier {{pkcs1MGFAlgorithms}}\n    DEFAULT mgf1SHA1Identifier,\n  pSourceFunc [2] AlgorithmIdentifier\n    {{pkcs1pSourceAlgorithms}}\n    DEFAULT pSpecifiedEmptyIdentifier }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields of type RSAES-OAEP-params have the following meanings:",
      "ja": "タイプRSAES-OAEP-のparamsの分野には、以下の意味を持っています："
    },
    {
      "indent": 3,
      "text": "-hashFunc identifies the hash function. It shall be an algorithm ID with an OID in the set oaepDigestAlgorithms, which for this version shall consist of id-sha1, identifying the SHA-1 hash function. The parameters field for id-sha1 shall have type NULL.",
      "ja": "-hashFuncは、ハッシュ関数を識別します。これは、このバージョンのSHA-1ハッシュ関数を識別するID-SHA1で構成するセットoaepDigestAlgorithmsでOIDとアルゴリズムIDでなければなりません。 ID-SHA1のパラメータフィールドは、タイプNULLを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "oaepDigestAlgorithms ALGORITHM-IDENTIFIER ::= {\n  {NULL IDENTIFIED BY id-sha1} }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "id-sha1 OBJECT IDENTIFIER ::=\n  {iso(1) identified-organization(3) oiw(14) secsig(3)\n    algorithms(2) 26}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The default hash function is SHA-1:\nsha1Identifier ::= AlgorithmIdentifier {id-sha1, NULL}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-maskGenFunc identifies the mask generation function. It shall be an algorithm ID with an OID in the set pkcs1MGFAlgorithms, which for this version shall consist of id-mgf1, identifying the MGF1 mask generation function (see Section 10.2.1). The parameters field for",
      "ja": "-maskGenFuncは、マスク生成機能を識別する。これは、このバージョンのMGF1マスク生成機能（10.2.1項を参照）を識別するID-MGF1で構成するセットpkcs1MGFAlgorithmsでOIDとアルゴリズムIDでなければなりません。パラメータフィールド"
    },
    {
      "indent": 3,
      "text": "id-mgf1 shall have type AlgorithmIdentifier, identifying the hash function on which MGF1 is based, where the OID for the hash function shall be in the set oaepDigestAlgorithms.",
      "ja": "ID-MGF1はハッシュ関数のOIDが設定oaepDigestAlgorithmsでなければならないMGF1が基づいているハッシュ関数を、特定タイプのAlgorithmIdentifierを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "pkcs1MGFAlgorithms ALGORITHM-IDENTIFIER ::= {\n  {AlgorithmIdentifier {{oaepDigestAlgorithms}} IDENTIFIED\n    BY id-mgf1} }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "id-mgf1 OBJECT IDENTIFIER ::= {pkcs-1 8}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The default mask generation function is MGF1 with SHA-1:",
      "ja": "デフォルトのマスク生成関数はSHA-1とMGF1です。"
    },
    {
      "indent": 3,
      "text": "mgf1SHA1Identifier ::= AlgorithmIdentifier {\n  id-mgf1, sha1Identifier }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-pSourceFunc identifies the source (and possibly the value) of the encoding parameters P. It shall be an algorithm ID with an OID in the set pkcs1pSourceAlgorithms, which for this version shall consist of id-pSpecified, indicating that the encoding parameters are specified explicitly. The parameters field for id-pSpecified shall have type OCTET STRING, containing the encoding parameters.",
      "ja": "-pSourceFuncは、符号化パラメータが明示的に指定されていることを示し、それは、このバージョンのID-pSpecifiedで構成するセットpkcs1pSourceAlgorithms、でOIDとアルゴリズムIDでなければならない符号化パラメータPの源（および恐らく値）を特定します。 ID-pSpecifiedのパラメータフィールドは、符号化パラメータを含む、タイプオクテットストリングを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "pkcs1pSourceAlgorithms ALGORITHM-IDENTIFIER ::= {\n  {OCTET STRING IDENTIFIED BY id-pSpecified} }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "id-pSpecified OBJECT IDENTIFIER ::= {pkcs-1 9}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The default encoding parameters is an empty string (so that pHash in EME-OAEP will contain the hash of the empty string):",
      "ja": "（EME-OAEPでpHashが空の文字列のハッシュを含むことになるように）デフォルトの符号化パラメータは、空の文字列です。"
    },
    {
      "indent": 3,
      "text": "pSpecifiedEmptyIdentifier ::= AlgorithmIdentifier {\n  id-pSpecified, OCTET STRING SIZE (0) }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If all of the default values of the fields in RSAES-OAEP-params are used, then the algorithm identifier will have the following value:",
      "ja": "RSAES-OAEP-のparams内のフィールドのデフォルト値のすべてが使用されている場合には、アルゴリズム識別子は、次の値を持つことになります。"
    },
    {
      "indent": 3,
      "text": "RSAES-OAEP-Default-Identifier ::= AlgorithmIdentifier {\n  id-RSAES-OAEP,\n  {sha1Identifier,\n   mgf1SHA1Identifier,\n   pSpecifiedEmptyIdentifier } }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.2.2 Syntax for RSAES-PKCS1-v1_5",
      "section_title": true,
      "ja": "RSAES-PKCS1-v1_5のための11.2.2構文"
    },
    {
      "indent": 3,
      "text": "The object identifier rsaEncryption (Section 11.1) identifies the RSAES-PKCS1-v1_5 encryption scheme. The parameters field associated with this OID in an AlgorithmIdentifier shall have type NULL. This is the same as in PKCS #1 v1.5.",
      "ja": "オブジェクト識別子rsaEncryption（セクション11.1）RSAES-PKCS1-v1_5の暗号化スキームを識別する。 AlgorithmIdentifierにこのOIDに関連したパラメータフィールドは、タイプNULLを持たなければなりません。これは、PKCS＃1 v1.5のと同じです。"
    },
    {
      "indent": 3,
      "text": "RsaEncryption   OBJECT IDENTIFIER ::= {PKCS-1 1}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.2.3 Syntax for RSASSA-PKCS1-v1_5",
      "section_title": true,
      "ja": "RSASSA-PKCS1-v1_5のための11.2.3構文"
    },
    {
      "indent": 3,
      "text": "The object identifier for RSASSA-PKCS1-v1_5 shall be one of the following. The choice of OID depends on the choice of hash algorithm: MD2, MD5 or SHA-1. Note that if either MD2 or MD5 is used then the OID is just as in PKCS #1 v1.5. For each OID, the parameters field associated with this OID in an AlgorithmIdentifier shall have type NULL.",
      "ja": "RSASSA-PKCS1-v1_5のためのオブジェクト識別子は、次のいずれかでなければなりません。 MD2、MD5やSHA-1：OIDの選択は、ハッシュアルゴリズムの選択に依存します。 MD2またはMD5のいずれかが使用されているならば、OIDはちょうどPKCS＃1 v1.5ののようであることに注意してください。各OIDのために、のAlgorithmIdentifierこのOIDに関連付けられたパラメータフィールドは、タイプNULLを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the hash function to be used is MD2, then the OID should be:",
      "ja": "使用するハッシュ関数は、MD2の場合、OIDは次のようになります。"
    },
    {
      "indent": 3,
      "text": "md2WithRSAEncryption ::= {PKCS-1 2}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the hash function to be used is MD5, then the OID should be:",
      "ja": "使用するハッシュ関数は、MD5の場合、OIDは次のようになります。"
    },
    {
      "indent": 3,
      "text": "md5WithRSAEncryption ::= {PKCS-1 4}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the hash function to be used is SHA-1, then the OID should be:",
      "ja": "使用されるハッシュ関数は、SHA-1である場合、OIDは次のようになります。"
    },
    {
      "indent": 3,
      "text": "sha1WithRSAEncryption ::= {pkcs-1 5}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the digestInfo type mentioned in Section 9.2.1 the OIDS for the digest algorithm are the following:",
      "ja": "ダイジェストアルゴリズムのOID 9.2.1項で述べたdigestInfoタイプでは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "id-SHA1 OBJECT IDENTIFIER ::=\n        {iso(1) identified-organization(3) oiw(14) secsig(3)\n         algorithms(2) 26 }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "md2 OBJECT IDENTIFIER ::=\n        {iso(1) member-body(2) US(840) rsadsi(113549)\n         digestAlgorithm(2) 2}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "md5 OBJECT IDENTIFIER ::=\n        {iso(1) member-body(2) US(840) rsadsi(113549)\n         digestAlgorithm(2) 5}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The parameters field of the digest algorithm has ASN.1 type NULL for these OIDs.",
      "ja": "ダイジェストアルゴリズムのパラメータフィールドには、これらのOIDのためのASN.1タイプNULLを持っています。"
    },
    {
      "indent": 0,
      "text": "12. Patent statement",
      "section_title": true,
      "ja": "12.特許声明"
    },
    {
      "indent": 3,
      "text": "The Internet Standards Process as defined in RFC 1310 requires a written statement from the Patent holder that a license will be made available to applicants under reasonable terms and conditions prior to approving a specification as a Proposed, Draft or Internet Standard.",
      "ja": "RFC 1310で定義されるようにインターネット標準化過程は、ライセンスが合理的用語および提案ドラフトまたはインターネット標準として仕様を承認する前に条件の下で出願人に利用可能となる特許権者から書面を必要とします。"
    },
    {
      "indent": 3,
      "text": "The Internet Society, Internet Architecture Board, Internet Engineering Steering Group and the Corporation for National Research Initiatives take no position on the validity or scope of the following patents and patent applications, nor on the appropriateness of the terms of the assurance. The Internet Society and other groups mentioned above have not made any determination as to any other intellectual property rights which may apply to the practice of this standard. Any further consideration of these matters is the user's responsibility.",
      "ja": "インターネット協会、インターネットアーキテクチャ委員会、インターネットエンジニアリング運営グループや国立研究イニシアチブのための社は、以下の特許および特許出願の有効性や適用範囲にはポジションを取るなく、また保証の条件の妥当性について。インターネット協会および上記の他のグループは、この標準の実践に適用する可能性のあるその他の知的財産権に関するどのような決意を行っていません。これらの問題のいずれかの更なる検討は、ユーザーの責任です。"
    },
    {
      "indent": 0,
      "text": "12.1 Patent statement for the RSA algorithm",
      "section_title": true,
      "ja": "RSAアルゴリズムの12.1特許声明"
    },
    {
      "indent": 3,
      "text": "The Massachusetts Institute of Technology has granted RSA Data Security, Inc., exclusive sub-licensing rights to the following patent issued in the United States:",
      "ja": "マサチューセッツ工科大学はRSA Data Security社、米国で発行された以下の特許への排他的、サブライセンス権付与しました："
    },
    {
      "indent": 3,
      "text": "Cryptographic Communications System and Method (\"RSA\"), No. 4,405,829",
      "ja": "暗号通信システムおよび方法（「RSA」）、米国特許第4405829"
    },
    {
      "indent": 3,
      "text": "RSA Data Security, Inc. has provided the following statement with regard to this patent:",
      "ja": "RSA Data Security社は、この特許に関して、次のステートメントを提供しています。"
    },
    {
      "indent": 3,
      "text": "It is RSA's business practice to make licenses to its patents available on reasonable and nondiscriminatory terms. Accordingly, RSA is willing, upon request, to grant non-exclusive licenses to such patent on reasonable and non-discriminatory terms and conditions to those who respect RSA's intellectual property rights and subject to RSA's then current royalty rate for the patent licensed. The royalty rate for the RSA patent is presently set at 2% of the licensee's selling price for each product covered by the patent. Any requests for license information may be directed to:",
      "ja": "合理的かつ非差別的条件での特許のライセンスを利用できるようにRSAのビジネス慣行です。したがって、RSAは、RSAの知的財産権およびライセンスを受けた特許のためのRSAの現在の料率の対象を尊重する人々に合理的かつ非差別条項および条件に、このような特許に非独占的ライセンスを付与するために、要求に応じて、喜んでいます。 RSAの特許料率は現在、特許によってカバーされる各製品のライセンシーの販売価格の2％に設定されています。ライセンス情報のための任意の要求を対象とすることができます。"
    },
    {
      "indent": 12,
      "text": "Director of Licensing\nRSA Data Security, Inc.\n2955 Campus Drive\nSuite 400\nSan Mateo, CA 94403",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A license under RSA's patent(s) does not include any rights to know-how or other technical information or license under other intellectual property rights. Such license does not extend to any activities which constitute infringement or inducement thereto. A licensee must make his own determination as to whether a license is necessary under patents of others.",
      "ja": "RSAの特許（複数可）の下でライセンスは、その他の知的財産権の下、またはその他の技術情報やライセンスノウハウをする権利が含まれていません。このようなライセンスが侵害または誘導それを構成するすべての活動には適用されません。ライセンシーは、ライセンスが他人の特許権の下で必要であるかどうかについての彼自身の決意をしなければなりません。"
    },
    {
      "indent": 0,
      "text": "13. Revision history",
      "section_title": true,
      "ja": "13.更新履歴"
    },
    {
      "indent": 3,
      "text": "Versions 1.0-1.3",
      "ja": "バージョン1.0から1.3"
    },
    {
      "indent": 3,
      "text": "Versions 1.0-1.3 were distributed to participants in RSA Data Security, Inc.'s Public-Key Cryptography Standards meetings in February and March 1991.",
      "ja": "バージョン1.0から1.3は、2月と1991年3月、RSA Data Security社の公開鍵暗号規格会議の参加者に配布しました。"
    },
    {
      "indent": 3,
      "text": "Version 1.4",
      "ja": "バージョン1.4"
    },
    {
      "indent": 3,
      "text": "Version 1.4 was part of the June 3, 1991 initial public release of PKCS. Version 1.4 was published as NIST/OSI Implementors' Workshop document SEC-SIG-91-18.",
      "ja": "バージョン1.4はPKCSの1991年6月3日、最初のパブリックリリースの一部でした。バージョン1.4は、NIST / OSI実装者ワークショップのドキュメントSEC-SIG-91-18として出版されました。"
    },
    {
      "indent": 3,
      "text": "Version 1.5",
      "ja": "バージョン1.5"
    },
    {
      "indent": 3,
      "text": "Version 1.5 incorporates several editorial changes, including updates to the references and the addition of a revision history. The following substantive changes were made: -Section 10: \"MD4 with RSA\" signature and verification processes were added.",
      "ja": "バージョン1.5は、参照への更新および改訂履歴の追加など、いくつかの編集上の変更が組み込まれています。以下の実質的な変更がなされた：-section 10：署名および検証プロセス「RSAとMD4」が追加されました。"
    },
    {
      "indent": 3,
      "text": "-Section 11: md4WithRSAEncryption object identifier was added.",
      "ja": "-section 11：md4WithRSAEncryptionオブジェクト識別子を加えました。"
    },
    {
      "indent": 3,
      "text": "Version 2.0 [DRAFT]",
      "ja": "バージョン2.0 [DRAFT]"
    },
    {
      "indent": 3,
      "text": "Version 2.0 incorporates major editorial changes in terms of the document structure, and introduces the RSAEP-OAEP encryption scheme. This version continues to support the encryption and signature processes in version 1.5, although the hash algorithm MD4 is no longer allowed due to cryptanalytic advances in the intervening years.",
      "ja": "バージョン2.0は、文書構造の面で主要な編集上の変更を組み込んだ、とRSAEP-OAEPの暗号化方式を導入しています。ハッシュアルゴリズムMD4がもはやによる介入年間で暗号解読の進歩に許可されているが、このバージョンは、バージョン1.5での暗号化と署名のプロセスを引き続きサポートしていません。"
    },
    {
      "indent": 0,
      "text": "14. References",
      "section_title": true,
      "ja": "14.参考文献"
    },
    {
      "indent": 3,
      "text": "[1] ANSI, ANSI X9.44: Key Management Using Reversible Public Key Cryptography for the Financial Services Industry. Work in Progress.",
      "ja": "[1] ANSI、ANSI X9.44：金融サービス業界のためのリバーシブル、公開鍵暗号を使用してキー管理。進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[2] M. Bellare and P. Rogaway. Optimal Asymmetric Encryption - How to Encrypt with RSA. In Advances in Cryptology-Eurocrypt '94, pp. 92-111, Springer-Verlag, 1994.",
      "ja": "[2] M.ベラー及びP. Rogaway。最適な非対称暗号化 -  RSAで暗号化する方法。暗号学-EUROCRYPT '94、頁92から111、シュプリンガー・フェアラーク、1994年の進歩で。"
    },
    {
      "indent": 3,
      "text": "[3] M. Bellare and P. Rogaway. The Exact Security of Digital Signatures - How to Sign with RSA and Rabin. In Advances in Cryptology-Eurocrypt '96, pp. 399-416, Springer-Verlag, 1996.",
      "ja": "[3] M.ベラー及びP. Rogaway。デジタル署名の正確なセキュリティ - どのようにRSAとラビンでサインインしてください。暗号学-EUROCRYPT '96、頁399から416、シュプリンガー・フェアラーク、1996年の進歩で。"
    },
    {
      "indent": 3,
      "text": "[4] D. Bleichenbacher. Chosen Ciphertext Attacks against Protocols Based on the RSA Encryption Standard PKCS #1. To appear in Advances in Cryptology-Crypto '98.",
      "ja": "[4] D. Bleichenbacherの。 RSA暗号化規格PKCS＃1に基づくプロトコルに対する選択暗号文攻撃。暗号学-暗号'98の進歩に表示されます。"
    },
    {
      "indent": 3,
      "text": "[5] D. Bleichenbacher, B. Kaliski and J. Staddon. Recent Results on PKCS #1: RSA Encryption Standard. RSA Laboratories' Bulletin, Number 7, June 24, 1998.",
      "ja": "[5] D. Bleichenbacherの、B. Kaliski及びJ. Staddon。 RSA暗号化規格：PKCS＃1の最近の結果。 RSA Laboratoriesの会報、数7、1998年6月24日。"
    },
    {
      "indent": 3,
      "text": "[6] CCITT. Recommendation X.509: The Directory-Authentication Framework. 1988.",
      "ja": "[6] CCITT。勧告X.509：ディレクトリ - 認証フレームワーク。 1988。"
    },
    {
      "indent": 3,
      "text": "[7] D. Coppersmith, M. Franklin, J. Patarin and M. Reiter. Low-Exponent RSA with Related Messages. In Advances in Cryptology-Eurocrypt '96, pp. 1-9, Springer-Verlag, 1996",
      "ja": "[7] D.銅細工、M.フランクリン、J. Patarin及びM.ライター。関連メッセージによる低指数RSA。暗号理論-EUROCRYPT '96、頁1-9、シュプリンガー・フェアラーク、1996年の進歩に"
    },
    {
      "indent": 3,
      "text": "[8] B. Den Boer and Bosselaers. Collisions for the Compression Function of MD5. In Advances in Cryptology-Eurocrypt '93, pp 293-304, Springer-Verlag, 1994.",
      "ja": "[8] B.デンボーアとBosselaers。 MD5の圧縮機能のための衝突。暗号学-EUROCRYPT '93、頁293から304、シュプリンガー・フェアラーク、1994年の進歩で。"
    },
    {
      "indent": 3,
      "text": "[9] B. den Boer, and A. Bosselaers. An Attack on the Last Two Rounds of MD4. In Advances in Cryptology-Crypto '91, pp.194-203, Springer-Verlag, 1992.",
      "ja": "[9] B.デンボーア、およびA. Bosselaers。 MD4の最後の2ラウンドで攻撃。暗号学-暗号'91、pp.194-203、シュプリンガー・フェアラーク、1992年の進歩で。"
    },
    {
      "indent": 3,
      "text": "[10] H. Dobbertin. Cryptanalysis of MD4. Fast Software Encryption. Lecture Notes in Computer Science, Springer-Verlag 1996, pp. 55-72.",
      "ja": "[10] H. Dobbertin。 MD4の暗号解読。高速ソフトウェア暗号化。コンピュータサイエンス、シュプリンガー・フェアラーク1996年、頁55-72で講義ノート。"
    },
    {
      "indent": 3,
      "text": "[11] H. Dobbertin. Cryptanalysis of MD5 Compress. Presented at the rump session of Eurocrypt `96, May 14, 1996",
      "ja": "[11] H. Dobbertin。 MD5圧縮の暗号解読。 EUROCRYPT `96、1996年5月14日のランプセッションで発表"
    },
    {
      "indent": 3,
      "text": "[12] H. Dobbertin.The First Two Rounds of MD4 are Not One-Way. Fast Software Encryption. Lecture Notes in Computer Science, Springer-Verlag 1998, pp. 284-292.",
      "ja": "MD4の[12] H. Dobbertin.The最初の2ラウンドは、ワンウェイではありません。高速ソフトウェア暗号化。コンピュータサイエンス、シュプリンガー・フェアラーク1998年、頁284から292での講義ノート。"
    },
    {
      "indent": 3,
      "text": "[13] J. Hastad. Solving Simultaneous Modular Equations of Low Degree. SIAM Journal of Computing, 17, 1988, pp. 336-341.",
      "ja": "[13] J. Hastad。低度の同時モジュラー方程式を解きます。コンピューティングのSIAMジャーナル、17、1988、頁336-341。"
    },
    {
      "indent": 3,
      "text": "[14] IEEE. IEEE P1363: Standard Specifications for Public Key Cryptography. Draft Version 4.",
      "ja": "[14] IEEE。 IEEE P1363：公開鍵暗号のための標準仕様。ドラフトバージョン4。"
    },
    {
      "indent": 3,
      "text": "[15] Kaliski, B., \"The MD2 Message-Digest Algorithm\", RFC 1319, April 1992.",
      "ja": "[15] Kaliski、B.、 \"MD2メッセージダイジェストアルゴリズム\"、RFC 1319、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[16] National Institute of Standards and Technology (NIST). FIPS Publication 180-1: Secure Hash Standard. April 1994.",
      "ja": "[16]米国国立標準技術研究所（NIST）。 FIPS 180-1文献：セキュアハッシュ標準。 1994年4月。"
    },
    {
      "indent": 3,
      "text": "[17] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[17]リベスト、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[18] R. Rivest, A. Shamir and L. Adleman. A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. Communications of the ACM, 21(2), pp. 120-126, February 1978.",
      "ja": "[18] R.リベスト、A.シャミル及びL.エーデルマン。デジタル署名と公開鍵暗号を得るための方法。 ACMの通信、21（2）、頁120-126、1978年2月。"
    },
    {
      "indent": 3,
      "text": "[19] N. Rogier and P. Chauvaud. The Compression Function of MD2 is not Collision Free. Presented at Selected Areas of Cryptography `95. Carleton University, Ottawa, Canada. May 18-19, 1995.",
      "ja": "[19] N.ロジェ及びP. Chauvaud。 MD2の圧縮機能は、衝突フリーではありません。暗号 `95の選択された領域で発表。カールトン大学、オタワ、カナダ。月18-19、1995。"
    },
    {
      "indent": 3,
      "text": "[20] RSA Laboratories. PKCS #1: RSA Encryption Standard. Version 1.5, November 1993.",
      "ja": "[20] RSA研究所。 PKCS＃1：RSA暗号化規格。バージョン1.5、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[21] RSA Laboratories. PKCS #7: Cryptographic Message Syntax Standard. Version 1.5, November 1993.",
      "ja": "[21] RSA研究所。 PKCS＃7：暗号メッセージ構文標準。バージョン1.5、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[22] RSA Laboratories. PKCS #8: Private-Key Information Syntax Standard. Version 1.2, November 1993.",
      "ja": "[22] RSA研究所。 PKCS＃8：プライベート・キー情報の構文標準。バージョン1.2、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[23] RSA Laboratories. PKCS #12: Personal Information Exchange Syntax Standard. Version 1.0, Work in Progress, April 1997.",
      "ja": "[23] RSA研究所。 PKCS＃12：個人情報交換シンタックス標準。バージョン1.0は、進捗状況、1997年4月に作業します。"
    },
    {
      "indent": 0,
      "text": "Security Considerations",
      "ja": "セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Security issues are discussed throughout this memo.",
      "ja": "セキュリティの問題は、このメモ中で議論されています。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document is based on a contribution of RSA Laboratories, a division of RSA Data Security, Inc. Any substantial use of the text from this document must acknowledge RSA Data Security, Inc. RSA Data Security, Inc. requests that all material mentioning or referencing this document identify this as \"RSA Data Security, Inc. PKCS #1 v2.0\".",
      "ja": "この文書は、この文書からテキストの実質的な使用は、RSAデータセキュリティを確認する必要がありRSA Laboratories社、RSA Data Security社の一部門の貢献度に基づいており、Inc.のRSA Data Security社は、すべての材料が言及または参照することを要求しますこの文書では、 \"RSA Data Security社のPKCS＃1 v2.0の\" としてこれを識別する。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Burt Kaliski RSA Laboratories East 20 Crosby Drive Bedford, MA 01730",
      "ja": "バート・カリスキーRSA研究所東20クロスビー・ドライブベッドフォード、MA 01730"
    },
    {
      "indent": 3,
      "text": "Phone: (617) 687-7000 EMail: burt@rsa.com",
      "ja": "電話：（617）687-7000 Eメール：burt@rsa.com"
    },
    {
      "indent": 3,
      "text": "Jessica Staddon RSA Laboratories West 2955 Campus Drive Suite 400 San Mateo, CA 94403",
      "ja": "ジェシカStaddon RSA研究所西2955キャンパスドライブスイート400サンマテオ、CA 94403"
    },
    {
      "indent": 3,
      "text": "Phone: (650) 295-7600 EMail: jstaddon@rsa.com",
      "ja": "電話：（650）295-7600 Eメール：jstaddon@rsa.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    }
  ]
}