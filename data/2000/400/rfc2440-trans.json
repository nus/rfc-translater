{
  "title": {
    "text": "RFC 2440 - OpenPGP Message Format",
    "ja": "RFC 2440 - OpenPGPのメッセージフォーマット"
  },
  "number": 2440,
  "created_at": "2019-10-24 16:04:08.767461+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         J. Callas\nRequest for Comments: 2440                           Network Associates\nCategory: Standards Track                                L. Donnerhacke\n                                     IN-Root-CA Individual Network e.V.\n                                                              H. Finney\n                                                     Network Associates\n                                                              R. Thayer\n                                                        EIS Corporation\n                                                          November 1998",
      "raw": true
    },
    {
      "indent": 25,
      "text": "OpenPGP Message Format",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "IESG Note",
      "ja": "IESG注意"
    },
    {
      "indent": 3,
      "text": "This document defines many tag values, yet it doesn't describe a mechanism for adding new tags (for new features). Traditionally the Internet Assigned Numbers Authority (IANA) handles the allocation of new values for future expansion and RFCs usually define the procedure to be used by the IANA. However, there are subtle (and not so subtle) interactions that may occur in this protocol between new features and existing features which result in a significant reduction in over all security. Therefore, this document does not define an extension procedure. Instead requests to define new tag values (say for new encryption algorithms for example) should be forwarded to the IESG Security Area Directors for consideration or forwarding to the appropriate IETF Working Group for consideration.",
      "ja": "この文書では、多くのタグ値を定義し、まだそれは（新機能の）新しいタグを追加するためのメカニズムを説明していません。従来、インターネット割り当て番号機関（IANA）は、通常、IANAによって使用される手順を定義し、将来の拡張およびRFCの新しい値の割り当てを処理します。しかし、すべてのセキュリティ上の有意な減少をもたらす新機能と既存機能との間のこのプロトコルで発生する可能性があり、微妙な（そして微妙ではない）の相互作用が存在します。したがって、この文書は、拡張プロシージャを定義していません。新しいタグ値を（例えば、新たな暗号化アルゴリズムのために言う）を定義する代わりに、要求は考慮のためにIESGセキュリティエリアディレクターに転送または検討のために適切なIETFワーキンググループに転送する必要があります。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document is maintained in order to publish all necessary information needed to develop interoperable applications based on the OpenPGP format. It is not a step-by-step cookbook for writing an application. It describes only the format and methods needed to read, check, generate, and write conforming packets crossing any network. It does not deal with storage and implementation questions. It does, however, discuss implementation issues necessary to avoid security flaws.",
      "ja": "このドキュメントは、OpenPGP形式に基づく相互運用可能なアプリケーションを開発するために必要なすべての必要な情報を公開するために維持されています。これは、アプリケーションを作成するためのステップバイステップの料理の本ではありません。それは、読んで確認し、生成し、任意のネットワークを横断するパケットを準拠書くために必要な唯一の形式と方法を説明しています。これは、ストレージおよびインプリメンテーションの質問に対処していません。しかし、セキュリティ上の欠陥を避けるために必要な実装上の問題を話し合うん。"
    },
    {
      "indent": 3,
      "text": "Open-PGP software uses a combination of strong public-key and symmetric cryptography to provide security services for electronic communications and data storage. These services include confidentiality, key management, authentication, and digital signatures. This document specifies the message formats used in OpenPGP.",
      "ja": "オープンPGPソフトウェアは、電子通信とデータ保存用のセキュリティサービスを提供するために、強力な公開鍵と対称暗号の組み合わせを使用しています。これらのサービスは、機密性、鍵管理、認証、およびデジタル署名が含まれます。このドキュメントは、OpenPGPのに使用されるメッセージフォーマットを指定します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": " Status of this Memo 1 IESG Note 1 Abstract 1 Table of Contents 2 1. Introduction 4 1.1. Terms 5 2. General functions 5 2.1. Confidentiality via Encryption 5 2.2. Authentication via Digital signature 6 2.3. Compression 7 2.4. Conversion to Radix-64 7 2.5. Signature-Only Applications 7 3. Data Element Formats 7 3.1. Scalar numbers 8 3.2. Multi-Precision Integers 8 3.3. Key IDs 8 3.4. Text 8 3.5. Time fields 9 3.6. String-to-key (S2K) specifiers 9 3.6.1. String-to-key (S2k) specifier types 9 3.6.1.1. Simple S2K 9 3.6.1.2. Salted S2K 10 3.6.1.3. Iterated and Salted S2K 10 3.6.2. String-to-key usage 11 3.6.2.1. Secret key encryption 11 3.6.2.2. Symmetric-key message encryption 11 4. Packet Syntax 12 4.1. Overview 12 4.2. Packet Headers 12 4.2.1. Old-Format Packet Lengths 13 4.2.2. New-Format Packet Lengths 13 4.2.2.1. One-Octet Lengths 14 4.2.2.2. Two-Octet Lengths 14 4.2.2.3. Five-Octet Lengths 14 4.2.2.4. Partial Body Lengths 14 4.2.3. Packet Length Examples 14",
      "ja": "このメモ1 IESG注1要約1目次2 1.はじめに4 1.1のステータス。利用規約5 2.一般的な機能5 2.1。暗号化5 2.2経由で機密性。デジタル署名6 2.3を介して認証。圧縮7 2.4。基数64 7 2.5への変換。 7つの3.データ要素形式7 3.1署名専用アプリケーション。スカラ番号8 3.2。多倍精度整数8 3.3。キーIDは8 3.4。テキスト8 3.5。時間フィールド9 3.6。文字列からキーへ（S2K）指定子9 3.6.1。文字列からキーへ（S2K）指定子タイプ9 3.6.1.1。シンプルS2K 9 3.6.1.2。塩漬けS2K 10 3.6.1.3。反復と塩漬けS2K 10 3.6.2。文字列からキーへの用法11 3.6.2.1。秘密鍵暗号11 3.6.2.2。共通鍵暗号化メッセージ11 4.パケット構文12 4.1。 12 4.2概要。パケットヘッダ12 4.2.1。古いフォーマットパケット長さ13 4.2.2。新フォーマットパケット長さ13 4.2.2.1。 1オクテット長14 4.2.2.2。 2オクテット長14 4.2.2.3。五オクテット長14 4.2.2.4。部分的なボディ長さ14 4.2.3。パケット長として14"
    },
    {
      "indent": 3,
      "text": "4.3. Packet Tags 15 5. Packet Types 16 5.1. Public-Key Encrypted Session Key Packets (Tag 1) 16 5.2. Signature Packet (Tag 2) 17 5.2.1. Signature Types 17 5.2.2. Version 3 Signature Packet Format 19 5.2.3. Version 4 Signature Packet Format 21 5.2.3.1. Signature Subpacket Specification 22 5.2.3.2. Signature Subpacket Types 24 5.2.3.3. Signature creation time 25 5.2.3.4. Issuer 25 5.2.3.5. Key expiration time 25 5.2.3.6. Preferred symmetric algorithms 25 5.2.3.7. Preferred hash algorithms 25 5.2.3.8. Preferred compression algorithms 26 5.2.3.9. Signature expiration time 26 5.2.3.10.Exportable Certification 26 5.2.3.11.Revocable 27 5.2.3.12.Trust signature 27 5.2.3.13.Regular expression 27 5.2.3.14.Revocation key 27 5.2.3.15.Notation Data 28 5.2.3.16.Key server preferences 28 5.2.3.17.Preferred key server 29 5.2.3.18.Primary user id 29 5.2.3.19.Policy URL 29 5.2.3.20.Key Flags 29 5.2.3.21.Signer's User ID 30 5.2.3.22.Reason for Revocation 30 5.2.4. Computing Signatures 31 5.2.4.1. Subpacket Hints 32 5.3. Symmetric-Key Encrypted Session-Key Packets (Tag 3) 32 5.4. One-Pass Signature Packets (Tag 4) 33 5.5. Key Material Packet 34 5.5.1. Key Packet Variants 34 5.5.1.1. Public Key Packet (Tag 6) 34 5.5.1.2. Public Subkey Packet (Tag 14) 34 5.5.1.3. Secret Key Packet (Tag 5) 35 5.5.1.4. Secret Subkey Packet (Tag 7) 35 5.5.2. Public Key Packet Formats 35 5.5.3. Secret Key Packet Formats 37 5.6. Compressed Data Packet (Tag 8) 38 5.7. Symmetrically Encrypted Data Packet (Tag 9) 39 5.8. Marker Packet (Obsolete Literal Packet) (Tag 10) 39 5.9. Literal Data Packet (Tag 11) 40 5.10. Trust Packet (Tag 12) 40 5.11. User ID Packet (Tag 13) 41 6. Radix-64 Conversions 41",
      "ja": "4.3。パケットタグ15 5.パケットタイプ16 5.1。公開鍵暗号化されたセッション鍵パケット（タグ1）16 5.2。署名パケット（タグ2）17 5.2.1。署名の種類17 5.2.2。バージョン3の署名パケットフォーマット19 5.2.3。バージョン4署名パケットフォーマット21 5.2.3.1。署名サブパケット仕様22 5.2.3.2。署名サブパケットタイプ24 5.2.3.3。署名作成時間25 5.2.3.4。発行者25 5.2.3.5。キー有効期限25 5.2.3.6。好適な対称アルゴリズム25 5.2.3.7。好適なハッシュアルゴリズム25 5.2.3.8。好適な圧縮アルゴリズム26 5.2.3.9。署名の有効期限26 5.2.3.10.Exportable認定26 5.2.3.11.Revocable 27 5.2.3.12.Trust署名27 5.2.3.13.Regular式27 5.2.3.14.Revocationキー27 5.2.3.15.Notationデータ28 5.2.3.16.Key失効30 5.2用のサーバーの好み28 5.2.3.17.Preferred鍵サーバ29 5.2.3.18.PrimaryユーザID 29の5.2.3.19.Policy URL 29の5.2.3.20.Key国旗29 5.2.3.21.SignerのユーザーID 30 5.2.3.22.Reason 0.4。コンピューティング署名31 5.2.4.1。サブパケットは32 5.3ヒント。共通鍵暗号化されたセッションキーパケット（タグ3）32 5.4。ワンパス署名パケット（タグ4）33 5.5。主な材質パケット34 5.5.1。主なパケットが34 5.5.1.1をバリアント。公開鍵パケット（タグ6）34 5.5.1.2。公共のサブキーパケット（タグ14）34 5.5.1.3。秘密鍵パケット（タグ5）35 5.5.1.4。秘密のサブキーパケット（タグ7）35 5.5.2。公開鍵パケット形式35 5.5.3。秘密鍵パケットフォーマット37 5.6。圧縮されたデータパケット（タグ8）38 5.7。対称的に暗号化データ・パケット（タグ9）39 5.8。マーカーパケット（廃止リテラルパケット）（タグ10）39 5.9。リテラルデータパケット（タグ11）40 5.10。トラストパケット（タグ12）40 5.11。ユーザIDパケット（タグ13）41 6基数64コンバージョン41"
    },
    {
      "indent": 3,
      "text": "6.1. An Implementation of the CRC-24 in \"C\" 42 6.2. Forming ASCII Armor 42 6.3. Encoding Binary in Radix-64 44 6.4. Decoding Radix-64 46 6.5. Examples of Radix-64 46 6.6. Example of an ASCII Armored Message 47 7. Cleartext signature framework 47 7.1. Dash-Escaped Text 47 8. Regular Expressions 48 9. Constants 49 9.1. Public Key Algorithms 49 9.2. Symmetric Key Algorithms 49 9.3. Compression Algorithms 50 9.4. Hash Algorithms 50 10. Packet Composition 50 10.1. Transferable Public Keys 50 10.2. OpenPGP Messages 52 10.3. Detached Signatures 52 11. Enhanced Key Formats 52 11.1. Key Structures 52 11.2. Key IDs and Fingerprints 53 12. Notes on Algorithms 54 12.1. Symmetric Algorithm Preferences 54 12.2. Other Algorithm Preferences 55 12.2.1. Compression Preferences 56 12.2.2. Hash Algorithm Preferences 56 12.3. Plaintext 56 12.4. RSA 56 12.5. Elgamal 57 12.6. DSA 58 12.7. Reserved Algorithm Numbers 58 12.8. OpenPGP CFB mode 58 13. Security Considerations 59 14. Implementation Nits 60 15. Authors and Working Group Chair 62 16. References 63 17. Full Copyright Statement 65",
      "ja": "6.1。 \"C\" 42 6.2でCRC-24の実装。 ASCIIアーマー42 6.3を形成します。基数64 44 6.4でバイナリをコードします。デコード基数64 46 6.5。基数64 46 6.6の例。 ASCII装甲メッセージ47 7クリアテキスト署名フレームワーク47 7.1の例。ダッシュエスケープ文字47の8.正規表現48の9.定数49 9.1。公開鍵アルゴリズム49 9.2。対称鍵アルゴリズム49 9.3。圧縮アルゴリズム50 9.4。ハッシュアルゴリズム50 10パケット組成物50 10.1。譲渡公開鍵50 10.2。 OpenPGPのメッセージ52 10.3。分離署名52の11.拡張キーフォーマット52 11.1。キー構造52 11.2。アルゴリズム54 12.1上の鍵IDと指紋53 12注意。対称アルゴリズムの設定54 12.2。その他のアルゴリズム設定55 12.2.1。圧縮設定56 12.2.2。ハッシュアルゴリズムの設定56 12.3。平文56 12.4。 RSA 56 12.5。エルガマル57 12.6。 DSA 58 12.7。予約済みアルゴリズム番号58 12.8。 OpenPGPのCFBモード58の13.セキュリティの考慮事項59本の14.実装ニト60本の15.著者とワーキンググループ議長62の16.参考資料63 17.完全な著作権声明65"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document provides information on the message-exchange packet formats used by OpenPGP to provide encryption, decryption, signing, and key management functions. It builds on the foundation provided in RFC 1991 \"PGP Message Exchange Formats.\"",
      "ja": "この文書は、暗号化、復号化、署名、および鍵管理機能を提供するためのOpenPGPで使用されるメッセージ交換パケットフォーマットについての情報を提供します。これは、RFC 1991で提供基盤の上に構築「PGPメッセージ交換フォーマット。」"
    },
    {
      "indent": 0,
      "text": "1.1. Terms",
      "section_title": true,
      "ja": "1.1。条項"
    },
    {
      "indent": 5,
      "text": "* OpenPGP - This is a definition for security software that uses\n  PGP 5.x as a basis.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "* PGP - Pretty Good Privacy. PGP is a family of software systems developed by Philip R. Zimmermann from which OpenPGP is based.",
      "ja": "* PGP  - プリティグッドプライバシー。 PGPはOpenPGPのが基づいているから、フィリップ・R. Zimmermann氏によって開発されたソフトウェア・システムのファミリーです。"
    },
    {
      "indent": 5,
      "text": "* PGP 2.6.x - This version of PGP has many variants, hence the term PGP 2.6.x. It used only RSA, MD5, and IDEA for its cryptographic transforms. An informational RFC, RFC 1991, was written describing this version of PGP.",
      "ja": "* PGP 2.6.xでは -  PGPのこのバージョンは、多くの亜種があり、したがって、用語のPGPの2.6.x.それは、その暗号化の変換のためにのみRSA、MD5、およびIDEAを使用していました。情報のRFC、RFC 1991は、PGPのこのバージョンを記述する書かれていました。"
    },
    {
      "indent": 5,
      "text": "* PGP 5.x - This version of PGP is formerly known as \"PGP 3\" in the community and also in the predecessor of this document, RFC 1991. It has new formats and corrects a number of problems in the PGP 2.6.x design. It is referred to here as PGP 5.x because that software was the first release of the \"PGP 3\" code base.",
      "ja": "* PGP 5.xの -  PGPのこのバージョンは、以前は、地域社会にも、本書の前身で「PGP 3」として知られているRFC 1991には新しいフォーマットを持っており、PGP 2.6.xの設計に多くの問題を修正。そのソフトウェアは、「PGP 3」のコードベースの最初のリリースだったので、それは、PGP 5.xのとここで呼ばれています。"
    },
    {
      "indent": 3,
      "text": "\"PGP\", \"Pretty Good\", and \"Pretty Good Privacy\" are trademarks of Network Associates, Inc. and are used with permission.",
      "ja": "「PGP」、「プリティ・グッド」、および「プリティグッドプライバシー」ネットワークアソシエイツ、Inc.の商標であり、許可を得て使用されています。"
    },
    {
      "indent": 3,
      "text": "This document uses the terms \"MUST\", \"SHOULD\", and \"MAY\" as defined in RFC 2119, along with the negated forms of those terms.",
      "ja": "このドキュメントは、「MUST」、「SHOULD」用語を使用し、それらの用語の否定形と一緒に、RFC 2119で定義されている「MAY」。"
    },
    {
      "indent": 0,
      "text": "2. General functions",
      "section_title": true,
      "ja": "2.一般的な機能"
    },
    {
      "indent": 3,
      "text": "OpenPGP provides data integrity services for messages and data files by using these core technologies:",
      "ja": "OpenPGPのは、これらのコア技術を使用してメッセージとデータファイルのデータの整合性サービスを提供しています。"
    },
    {
      "indent": 5,
      "text": "- digital signatures",
      "ja": " - デジタル署名"
    },
    {
      "indent": 5,
      "text": "- encryption",
      "ja": " - 暗号化"
    },
    {
      "indent": 5,
      "text": "- compression",
      "ja": " - 圧縮"
    },
    {
      "indent": 5,
      "text": "- radix-64 conversion",
      "ja": " - 基数64変換"
    },
    {
      "indent": 3,
      "text": "In addition, OpenPGP provides key management and certificate services, but many of these are beyond the scope of this document.",
      "ja": "また、OpenPGPのは、鍵管理や証明書サービスを提供していますが、これらの多くは、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "2.1. Confidentiality via Encryption",
      "section_title": true,
      "ja": "2.1。暗号化を介した機密性"
    },
    {
      "indent": 3,
      "text": "OpenPGP uses two encryption methods to provide confidentiality: symmetric-key encryption and public key encryption. With public-key encryption, the object is encrypted using a symmetric encryption algorithm. Each symmetric key is used only once. A new \"session key\" is generated as a random number for each message. Since it is used only once, the session key is bound to the message and transmitted with it. To protect the key, it is encrypted with the receiver's public key. The sequence is as follows:",
      "ja": "対称鍵暗号と公開鍵暗号：OpenPGPのは、機密性を提供するために、2つの暗号化方式を使用しています。公開鍵暗号では、オブジェクトは、対称暗号化アルゴリズムを使用して暗号化されます。各対称鍵は一度だけ使用されます。新しい「セッション・キー」は、各メッセージの乱数として生成されます。それは一度だけ使用されているので、セッションキーはメッセージにバインドし、それを用いて送信されます。鍵を保護するためには、受信者の公開鍵で暗号化されています。次のように順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The sender creates a message.",
      "section_title": true,
      "ja": "1.送信者はメッセージを作成します。"
    },
    {
      "indent": 3,
      "text": "2. The sending OpenPGP generates a random number to be used as a session key for this message only.",
      "ja": "2.送信のOpenPGPは、このメッセージのセッション鍵として使用される乱数を生成します。"
    },
    {
      "indent": 3,
      "text": "3. The session key is encrypted using each recipient's public key. These \"encrypted session keys\" start the message.",
      "ja": "3.セッションキーは、各受信者の公開鍵を使って暗号化されています。これらの「暗号化されたセッション鍵は、」メッセージを開始します。"
    },
    {
      "indent": 3,
      "text": "4. The sending OpenPGP encrypts the message using the session key, which forms the remainder of the message. Note that the message is also usually compressed.",
      "ja": "4.送信のOpenPGPは、メッセージの残りの部分を形成する、セッション鍵を使用してメッセージを暗号化します。メッセージは、通常は圧縮されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "5. The receiving OpenPGP decrypts the session key using the recipient's private key.",
      "ja": "5.受信のOpenPGPは、受信者の秘密鍵を使用してセッション鍵を復号します。"
    },
    {
      "indent": 3,
      "text": "6. The receiving OpenPGP decrypts the message using the session key. If the message was compressed, it will be decompressed.",
      "ja": "6.受信のOpenPGPは、セッション鍵を使用してメッセージを復号化します。メッセージが圧縮された場合は、それが解凍されます。"
    },
    {
      "indent": 3,
      "text": "With symmetric-key encryption, an object may be encrypted with a symmetric key derived from a passphrase (or other shared secret), or a two-stage mechanism similar to the public-key method described above in which a session key is itself encrypted with a symmetric algorithm keyed from a shared secret.",
      "ja": "対称鍵暗号化と、オブジェクトがパスフレーズ（または他の共有秘密）に由来する対称鍵で暗号化してもよいし、セッション鍵を用いて暗号化自体である、上述した公開鍵方法と同様の二段機構共有秘密キーから対称アルゴリズム。"
    },
    {
      "indent": 3,
      "text": "Both digital signature and confidentiality services may be applied to the same message. First, a signature is generated for the message and attached to the message. Then, the message plus signature is encrypted using a symmetric session key. Finally, the session key is encrypted using public-key encryption and prefixed to the encrypted block.",
      "ja": "デジタル署名と機密性サービスの両方が同じメッセージに適用されてもよいです。まず、署名は、メッセージのために生成され、メッセージに添付されています。その後、メッセージプラス署名は対称セッション鍵を使用して暗号化されています。最後に、セッション鍵は、公開鍵暗号を使用して暗号化し、暗号化されたブロックの前に置かれています。"
    },
    {
      "indent": 0,
      "text": "2.2. Authentication via Digital signature",
      "section_title": true,
      "ja": "2.2。デジタル署名による認証"
    },
    {
      "indent": 3,
      "text": "The digital signature uses a hash code or message digest algorithm, and a public-key signature algorithm. The sequence is as follows:",
      "ja": "デジタル署名はハッシュコードまたはメッセージダイジェストアルゴリズムと公開鍵署名アルゴリズムを使用します。次のように順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The sender creates a message.",
      "section_title": true,
      "ja": "1.送信者はメッセージを作成します。"
    },
    {
      "indent": 3,
      "text": "2. The sending software generates a hash code of the message.",
      "section_title": true,
      "ja": "2.送信ソフトウェアは、メッセージのハッシュコードを生成します。"
    },
    {
      "indent": 3,
      "text": "3. The sending software generates a signature from the hash code using the sender's private key.",
      "ja": "3.送信ソフトウェアは、送信者の秘密鍵を使用してハッシュコードから署名を生成します。"
    },
    {
      "indent": 3,
      "text": "4. The binary signature is attached to the message.",
      "section_title": true,
      "ja": "4.バイナリ署名がメッセージに添付されています。"
    },
    {
      "indent": 3,
      "text": "5. The receiving software keeps a copy of the message signature.",
      "section_title": true,
      "ja": "5.受信ソフトウェアは、メッセージの署名のコピーを保持します。"
    },
    {
      "indent": 3,
      "text": "6. The receiving software generates a new hash code for the received message and verifies it using the message's signature. If the verification is successful, the message is accepted as authentic.",
      "ja": "6.受信ソフトウェアは、受信したメッセージのために新たなハッシュコードを生成し、メッセージの署名を使用して検証します。検証に成功した場合、メッセージは本物として受け入れられています。"
    },
    {
      "indent": 0,
      "text": "2.3. Compression",
      "section_title": true,
      "ja": "2.3。圧縮"
    },
    {
      "indent": 3,
      "text": "OpenPGP implementations MAY compress the message after applying the signature but before encryption.",
      "ja": "OpenPGPの実装は署名を適用した後が、暗号化前にメッセージを圧縮することができます。"
    },
    {
      "indent": 0,
      "text": "2.4. Conversion to Radix-64",
      "section_title": true,
      "ja": "2.4。基数64への変換"
    },
    {
      "indent": 3,
      "text": "OpenPGP's underlying native representation for encrypted messages, signature certificates, and keys is a stream of arbitrary octets. Some systems only permit the use of blocks consisting of seven-bit, printable text. For transporting OpenPGP's native raw binary octets through channels that are not safe to raw binary data, a printable encoding of these binary octets is needed. OpenPGP provides the service of converting the raw 8-bit binary octet stream to a stream of printable ASCII characters, called Radix-64 encoding or ASCII Armor.",
      "ja": "暗号化されたメッセージ、署名証明書、およびキーのOpenPGPのの基礎となるネイティブ表現は、任意のオクテットストリームです。一部のシステムでは、唯一の7ビット、印刷可能なテキストからなるブロックの使用を許可します。生のバイナリデータへの安全ではないチャネルを通じてのOpenPGPのネイティブの生のバイナリオクテットを輸送するために、これらのバイナリオクテットの印刷可能なエンコードが必要とされています。 OpenPGPのは、基数64符号化またはASCII装甲と呼ばれる印刷可能なASCII文字のストリームに生の8ビットの2進オクテットのストリームを変換するサービスを提供します。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD provide Radix-64 conversions.",
      "ja": "実装は、基数64の変換を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that many applications, particularly messaging applications, will want more advanced features as described in the OpenPGP-MIME document, RFC 2015. An application that implements OpenPGP for messaging SHOULD implement OpenPGP-MIME.",
      "ja": "OpenPGP-MIMEの文書で説明したように、多くのアプリケーション、特にメッセージングアプリケーションは、より高度な機能を必要することに注意してください、RFC 2015のOpenPGP-MIMEを実装する必要があり、メッセージングのためのOpenPGPを実装するアプリケーション。"
    },
    {
      "indent": 0,
      "text": "2.5. Signature-Only Applications",
      "section_title": true,
      "ja": "2.5。署名専用アプリケーション"
    },
    {
      "indent": 3,
      "text": "OpenPGP is designed for applications that use both encryption and signatures, but there are a number of problems that are solved by a signature-only implementation. Although this specification requires both encryption and signatures, it is reasonable for there to be subset implementations that are non-comformant only in that they omit encryption.",
      "ja": "OpenPGPは、暗号化と署名の両方を使用するアプリケーションのために設計されたが、署名のみの実装によって解決される多くの問題があるれています。この仕様は、暗号化と署名の両方が必要ですが、ために、彼らは暗号化を省略するだけという点で、非comformantある実装をサブセットすることが合理的です。"
    },
    {
      "indent": 0,
      "text": "3. Data Element Formats",
      "section_title": true,
      "ja": "3.データ要素のフォーマット"
    },
    {
      "indent": 3,
      "text": "This section describes the data elements used by OpenPGP.",
      "ja": "このセクションでは、OpenPGPので使用されるデータ要素について説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Scalar numbers",
      "section_title": true,
      "ja": "3.1。スカラ番号"
    },
    {
      "indent": 3,
      "text": "Scalar numbers are unsigned, and are always stored in big-endian format. Using n[k] to refer to the kth octet being interpreted, the value of a two-octet scalar is ((n[0] << 8) + n[1]). The value of a four-octet scalar is ((n[0] << 24) + (n[1] << 16) + (n[2] << 8) + n[3]).",
      "ja": "スカラ数値は、符号なしで、常にビッグエンディアン形式で格納されます。解釈されたk番目のオクテットを参照するために、N [k]を用いて、2オクテットのスカラーの値が（（N [0] << 8）+ N [1]）。 4オクテットのスカラーの値が（（N [0] << 24）+（N [1] << 16）+（N [2] << 8）+ N [3]）。"
    },
    {
      "indent": 0,
      "text": "3.2. Multi-Precision Integers",
      "section_title": true,
      "ja": "3.2。マルチプレシジョン整数"
    },
    {
      "indent": 3,
      "text": "Multi-Precision Integers (also called MPIs) are unsigned integers used to hold large integers such as the ones used in cryptographic calculations.",
      "ja": "（ものMPIと呼ばれる）多倍精度整数は、暗号計算に使用されるものとして大きな整数を保持するために使用される符号なし整数です。"
    },
    {
      "indent": 3,
      "text": "An MPI consists of two pieces: a two-octet scalar that is the length of the MPI in bits followed by a string of octets that contain the actual integer.",
      "ja": "実際の整数を含むオクテットの文字列が続くビットでMPIの長さである2オクテットのスカラー：MPIは、2つの部分から成ります。"
    },
    {
      "indent": 3,
      "text": "These octets form a big-endian number; a big-endian number can be made into an MPI by prefixing it with the appropriate length.",
      "ja": "これらのオクテットはビッグエンディアン番号を形成します。ビッグエンディアンの数は、適切な長さでそれを付けることによってMPIにすることができます。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "(all numbers are in hexadecimal)",
      "ja": "（すべての数値は16進数です）"
    },
    {
      "indent": 3,
      "text": "The string of octets [00 01 01] forms an MPI with the value 1. The string [00 09 01 FF] forms an MPI with the value of 511.",
      "ja": "オクテット[00 01 01]の文字列は、文字列[00 09 01 FF] 511の値とMPIを形成する1値とMPIを形成します。"
    },
    {
      "indent": 3,
      "text": "Additional rules:",
      "ja": "追加のルール："
    },
    {
      "indent": 3,
      "text": "The size of an MPI is ((MPI.length + 7) / 8) + 2 octets.",
      "ja": "MPIのサイズは（（MPI.length + 7）/ 8）+ 2つのオクテットです。"
    },
    {
      "indent": 3,
      "text": "The length field of an MPI describes the length starting from its most significant non-zero bit. Thus, the MPI [00 02 01] is not formed correctly. It should be [00 01 01].",
      "ja": "MPIの長さフィールドは、その最上位非ゼロのビットから始まる長さを示します。したがって、MPI [00 02 01]が正しく形成されません。これは、[00 01 01]であるべきです。"
    },
    {
      "indent": 0,
      "text": "3.3. Key IDs",
      "section_title": true,
      "ja": "3.3。鍵ID"
    },
    {
      "indent": 3,
      "text": "A Key ID is an eight-octet scalar that identifies a key. Implementations SHOULD NOT assume that Key IDs are unique. The section, \"Enhanced Key Formats\" below describes how Key IDs are formed.",
      "ja": "キーIDは、キーを識別する8オクテットのスカラーです。実装は、キーIDは一意であることを仮定するべきではありません。以下のセクション、「拡張キーの形式は、」キーIDが形成されている方法を説明します。"
    },
    {
      "indent": 0,
      "text": "3.4. Text",
      "section_title": true,
      "ja": "3.4。テキスト"
    },
    {
      "indent": 3,
      "text": "The default character set for text is the UTF-8 [RFC2279] encoding of Unicode [ISO10646].",
      "ja": "テキストのデフォルト文字セットは、Unicode [ISO10646]のUTF-8 [RFC2279]エンコードです。"
    },
    {
      "indent": 0,
      "text": "3.5. Time fields",
      "section_title": true,
      "ja": "3.5。時間フィールド"
    },
    {
      "indent": 3,
      "text": "A time field is an unsigned four-octet number containing the number of seconds elapsed since midnight, 1 January 1970 UTC.",
      "ja": "時間フィールドは真夜中、1970年1月1日UTCからの経過秒数を含む符号なしの4オクテットの数です。"
    },
    {
      "indent": 0,
      "text": "3.6. String-to-key (S2K) specifiers",
      "section_title": true,
      "ja": "3.6。文字列からキーへ（S2K）指定子"
    },
    {
      "indent": 3,
      "text": "String-to-key (S2K) specifiers are used to convert passphrase strings into symmetric-key encryption/decryption keys. They are used in two places, currently: to encrypt the secret part of private keys in the private keyring, and to convert passphrases to encryption keys for symmetrically encrypted messages.",
      "ja": "文字列からキーへ（S2K）指定子は、対称鍵暗号化/復号化キーにパスフレーズ文字列を変換するために使用されています。彼らは現在、2つの場所で使用されます。秘密鍵リングに秘密鍵の秘密の一部を暗号化するために、対称的に暗号化されたメッセージの暗号化キーにパスフレーズを変換します。"
    },
    {
      "indent": 0,
      "text": "3.6.1. String-to-key (S2k) specifier types",
      "section_title": true,
      "ja": "3.6.1。文字列からキーへ（S2K）指定タイプ"
    },
    {
      "indent": 3,
      "text": "There are three types of S2K specifiers currently supported, as follows:",
      "ja": "次のように現在サポートされているS2K指定子の3つのタイプがあります："
    },
    {
      "indent": 0,
      "text": "3.6.1.1. Simple S2K",
      "section_title": true,
      "ja": "3.6.1.1。シンプルS2K"
    },
    {
      "indent": 3,
      "text": "This directly hashes the string to produce the key data. See below for how this hashing is done.",
      "ja": "これは、直接鍵データを生成する文字列をハッシュします。このハッシュがどのように行われるかについては、以下を参照してください。"
    },
    {
      "indent": 7,
      "text": "Octet 0:        0x00\nOctet 1:        hash algorithm",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Simple S2K hashes the passphrase to produce the session key. The manner in which this is done depends on the size of the session key (which will depend on the cipher used) and the size of the hash algorithm's output. If the hash size is greater than or equal to the session key size, the high-order (leftmost) octets of the hash are used as the key.",
      "ja": "シンプルS2Kは、セッション鍵を生成するために、パスフレーズをハッシュします。これが行われている方法は、（使用される暗号に依存します）セッションキーのサイズとハッシュアルゴリズムの出力のサイズによって異なります。ハッシュ・サイズがより大きいまたはセッション鍵のサイズに等しい場合、ハッシュの上位（左端）オクテットはキーとして使用されます。"
    },
    {
      "indent": 3,
      "text": "If the hash size is less than the key size, multiple instances of the hash context are created -- enough to produce the required key data. These instances are preloaded with 0, 1, 2, ... octets of zeros (that is to say, the first instance has no preloading, the second gets preloaded with 1 octet of zero, the third is preloaded with two octets of zeros, and so forth).",
      "ja": "ハッシュサイズは、キーのサイズよりも小さい場合、ハッシュコンテキストの複数のインスタンスが作成されます - 十分に必要な鍵データを生成します。これらのインスタンスは、ゼロの0、1、2、...オクテット（すなわち、最初のインスタンスがないプリロードを有していない、と言うことであり、第二は、ゼロの1つのオクテットがプリロードされます、第三は、ゼロの2つのオクテットがプリロードされるがプリロードされ、など）。"
    },
    {
      "indent": 3,
      "text": "As the data is hashed, it is given independently to each hash context. Since the contexts have been initialized differently, they will each produce different hash output. Once the passphrase is hashed, the output data from the multiple hashes is concatenated, first hash leftmost, to produce the key data, with any excess octets on the right discarded.",
      "ja": "データがハッシュされるように、各ハッシュコンテキストに独立して与えられます。コンテキストが別々に初期化されているので、彼らはそれぞれ異なるハッシュ出力を生成します。パスフレーズがハッシュされると、複数のハッシュからの出力データは破棄右側に余分なオクテットと、鍵データを生成するために、第1のハッシュ左端に連結されます。"
    },
    {
      "indent": 0,
      "text": "3.6.1.2. Salted S2K",
      "section_title": true,
      "ja": "3.6.1.2。塩漬けS2K"
    },
    {
      "indent": 3,
      "text": "This includes a \"salt\" value in the S2K specifier -- some arbitrary data -- that gets hashed along with the passphrase string, to help prevent dictionary attacks.",
      "ja": "いくつかの任意のデータ -   - 辞書攻撃を防ぐために、パスフレーズの文字列と一緒にハッシュされますこれは、S2K指定子の「塩」値を含んでいます。"
    },
    {
      "indent": 7,
      "text": "Octet 0:        0x01\nOctet 1:        hash algorithm\nOctets 2-9:     8-octet salt value",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Salted S2K is exactly like Simple S2K, except that the input to the hash function(s) consists of the 8 octets of salt from the S2K specifier, followed by the passphrase.",
      "ja": "塩漬けS2Kは、ハッシュ関数（複数可）への入力は、パスフレーズに続くS2K指定から塩の8つのオクテットで構成されていることを除いて、正確にシンプルS2Kのようなものです。"
    },
    {
      "indent": 0,
      "text": "3.6.1.3. Iterated and Salted S2K",
      "section_title": true,
      "ja": "3.6.1.3。反復と塩漬けS2K"
    },
    {
      "indent": 3,
      "text": "This includes both a salt and an octet count. The salt is combined with the passphrase and the resulting value is hashed repeatedly. This further increases the amount of work an attacker must do to try dictionary attacks.",
      "ja": "これは、塩とオクテット数の両方を含んでいます。塩は、パスフレーズと組み合わされ、得られた値を繰り返しハッシュされます。これはさらに、攻撃者は、辞書攻撃をしようとしなければならない仕事の量が増加します。"
    },
    {
      "indent": 7,
      "text": "Octet  0:        0x03\nOctet  1:        hash algorithm\nOctets 2-9:      8-octet salt value\nOctet  10:       count, a one-octet, coded value",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The count is coded into a one-octet number using the following formula:",
      "ja": "カウントは、次の式を使用して、1オクテットの数に符号化されます。"
    },
    {
      "indent": 7,
      "text": "#define EXPBIAS 6\n    count = ((Int32)16 + (c & 15)) << ((c >> 4) + EXPBIAS);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The above formula is in C, where \"Int32\" is a type for a 32-bit integer, and the variable \"c\" is the coded count, Octet 10.",
      "ja": "上記式は「のInt32」は32ビット整数の型であり、変数「c」はコード化されたカウント、オクテット10 C、です。"
    },
    {
      "indent": 3,
      "text": "Iterated-Salted S2K hashes the passphrase and salt data multiple times. The total number of octets to be hashed is specified in the encoded count in the S2K specifier. Note that the resulting count value is an octet count of how many octets will be hashed, not an iteration count.",
      "ja": "反復-塩漬けS2Kは、パスフレーズと塩のデータを複数回ハッシュします。ハッシュされるオクテットの総数は、S2K指定子で符号化されたカウントで指定されています。結果のカウント値がハッシュ化されますどのように多くのオクテットのオクテット数ではなく、反復回数であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Initially, one or more hash contexts are set up as with the other S2K algorithms, depending on how many octets of key data are needed. Then the salt, followed by the passphrase data is repeatedly hashed until the number of octets specified by the octet count has been hashed. The one exception is that if the octet count is less than the size of the salt plus passphrase, the full salt plus passphrase will be hashed even though that is greater than the octet count.",
      "ja": "最初は、一の以上のハッシュコンテキストは、キーデータの多くのオクテットが必要とされる方法に応じて、他のS2Kアルゴリズムと同様に設定されています。オクテット数で指定されたオクテットの数がハッシュ化されるまで続いてパスフレーズデータに続いて、塩は、繰り返しハッシュされます。唯一の例外は、オクテットカウントは塩を加えたパスフレーズのサイズよりも小さい場合、完全な塩を加えたパスフレーズがそれはオクテット数よりも大きいにもかかわらず、ハッシュ化されるということです。"
    },
    {
      "indent": 3,
      "text": "After the hashing is done the data is unloaded from the hash context(s) as with the other S2K algorithms.",
      "ja": "ハッシュが行われた後のデータは、他のS2Kアルゴリズムと同様にハッシュコンテキスト（S）からアンロードされます。"
    },
    {
      "indent": 0,
      "text": "3.6.2. String-to-key usage",
      "section_title": true,
      "ja": "3.6.2。文字列からキーへの用法"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD use salted or iterated-and-salted S2K specifiers, as simple S2K specifiers are more vulnerable to dictionary attacks.",
      "ja": "実装は塩漬けまたは反復-と-塩漬けシンプルS2K指定子は、辞書攻撃に対してより脆弱であるとして、S2K指定子を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.6.2.1. Secret key encryption",
      "section_title": true,
      "ja": "3.6.2.1。秘密鍵暗号"
    },
    {
      "indent": 3,
      "text": "An S2K specifier can be stored in the secret keyring to specify how to convert the passphrase to a key that unlocks the secret data. Older versions of PGP just stored a cipher algorithm octet preceding the secret data or a zero to indicate that the secret data was unencrypted. The MD5 hash function was always used to convert the passphrase to a key for the specified cipher algorithm.",
      "ja": "S2K指定子は、秘密データをアンロックするキーにパスフレーズを変換する方法を指定するには、秘密のキーリングに保存することができます。 PGPの古いバージョンは、単に秘密データまたは秘密データが暗号化されていないれたことを示すためにゼロに先行する暗号アルゴリズムオクテットを記憶します。 MD5ハッシュ関数は、常に指定された暗号アルゴリズムの鍵にパスフレーズを変換するために使用されました。"
    },
    {
      "indent": 3,
      "text": "For compatibility, when an S2K specifier is used, the special value 255 is stored in the position where the hash algorithm octet would have been in the old data structure. This is then followed immediately by a one-octet algorithm identifier, and then by the S2K specifier as encoded above.",
      "ja": "S2K指定子を使用した場合の互換性のために、特別な値255は、ハッシュアルゴリズムオクテットは古いデータ構造であったであろう位置に格納されます。これは、次いで、1オクテットのアルゴリズム識別子直後、及びその後S2K指定することにより、上記コードされています。"
    },
    {
      "indent": 3,
      "text": "Therefore, preceding the secret data there will be one of these possibilities:",
      "ja": "したがって、そこに秘密データに先行するこれらの可能性のいずれかになります。"
    },
    {
      "indent": 7,
      "text": "0:           secret data is unencrypted (no pass phrase)\n255:         followed by algorithm octet and S2K specifier\nCipher alg:  use Simple S2K algorithm using MD5 hash",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This last possibility, the cipher algorithm number with an implicit use of MD5 and IDEA, is provided for backward compatibility; it MAY be understood, but SHOULD NOT be generated, and is deprecated.",
      "ja": "この最後の可能性は、MD5とIDEAの暗黙用いて暗号アルゴリズムの数は、下位互換性のために提供されます。それが理解されてもよいが、生成すべきではないと推奨されていません。"
    },
    {
      "indent": 3,
      "text": "These are followed by an 8-octet Initial Vector for the decryption of the secret values, if they are encrypted, and then the secret key values themselves.",
      "ja": "これらは、それらが暗号化されている場合は、秘密の値の復号化のための8オクテット初期ベクトルが続き、その後、秘密鍵は自分自身を値です。"
    },
    {
      "indent": 0,
      "text": "3.6.2.2. Symmetric-key message encryption",
      "section_title": true,
      "ja": "3.6.2.2。対称鍵メッセージの暗号化"
    },
    {
      "indent": 3,
      "text": "OpenPGP can create a Symmetric-key Encrypted Session Key (ESK) packet at the front of a message. This is used to allow S2K specifiers to be used for the passphrase conversion or to create messages with a mix of symmetric-key ESKs and public-key ESKs. This allows a message to be decrypted either with a passphrase or a public key.",
      "ja": "OpenPGPは、メッセージの前に共通鍵暗号化されたセッション鍵（ESK）パケットを作成することができます。これは、S2K指定子は、パスフレーズの変換に使用することができるようにするか、対称鍵ESKsと公開鍵ESKsのミックスでメッセージを作成するために使用されます。これは、メッセージがいずれかのパスフレーズまたは公開鍵で復号化することを可能にします。"
    },
    {
      "indent": 3,
      "text": "PGP 2.X always used IDEA with Simple string-to-key conversion when encrypting a message with a symmetric algorithm. This is deprecated, but MAY be used for backward-compatibility.",
      "ja": "対称アルゴリズムでメッセージを暗号化する際にPGP 2.Xはいつも単純な文字列からキーへの変換とIDEAを使用します。これは推奨されませんが、下位互換性のために使用されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "4. Packet Syntax",
      "section_title": true,
      "ja": "4.パケット構文"
    },
    {
      "indent": 3,
      "text": "This section describes the packets used by OpenPGP.",
      "ja": "このセクションでは、OpenPGPので使用されるパケットを説明しています。"
    },
    {
      "indent": 0,
      "text": "4.1. Overview",
      "section_title": true,
      "ja": "4.1。概要"
    },
    {
      "indent": 3,
      "text": "An OpenPGP message is constructed from a number of records that are traditionally called packets. A packet is a chunk of data that has a tag specifying its meaning. An OpenPGP message, keyring, certificate, and so forth consists of a number of packets. Some of those packets may contain other OpenPGP packets (for example, a compressed data packet, when uncompressed, contains OpenPGP packets).",
      "ja": "OpenPGPのメッセージは、伝統的にパケットと呼ばれるレコードの数から構成されています。パケットは、その意味を指定するタグを持つデータの塊です。 OpenPGPのメッセージ、キーリング、証明書、等、パケットの数から成ります。これらのパケットの一部が他のOpenPGPパケットを含んでいてもよい（例えば、圧縮されたデータパケットは、圧縮されていない場合、OpenPGPのパケットを含んでいます）。"
    },
    {
      "indent": 3,
      "text": "Each packet consists of a packet header, followed by the packet body. The packet header is of variable length.",
      "ja": "各パケットは、パケット本体に続くパケットヘッダから成ります。パケットヘッダは可変長です。"
    },
    {
      "indent": 0,
      "text": "4.2. Packet Headers",
      "section_title": true,
      "ja": "4.2。パケットのヘッダ"
    },
    {
      "indent": 3,
      "text": "The first octet of the packet header is called the \"Packet Tag.\" It determines the format of the header and denotes the packet contents. The remainder of the packet header is the length of the packet.",
      "ja": "パケットヘッダの最初のオクテットは「パケットタグ」と呼ばれます。これは、ヘッダのフォーマットを決定し、パケットの内容を示しています。パケットヘッダの残りの部分は、パケットの長さです。"
    },
    {
      "indent": 3,
      "text": "Note that the most significant bit is the left-most bit, called bit 7. A mask for this bit is 0x80 in hexadecimal.",
      "ja": "最上位ビットがこのビットのビット7のマスクと呼ばれる最も左のビットは、16進数では0x80であることに留意されたいです。"
    },
    {
      "indent": 9,
      "text": "     +---------------+\nPTag |7 6 5 4 3 2 1 0|\n     +---------------+\nBit 7 -- Always one\nBit 6 -- New packet format if set",
      "raw": true
    },
    {
      "indent": 3,
      "text": "PGP 2.6.x only uses old format packets. Thus, software that interoperates with those versions of PGP must only use old format packets. If interoperability is not an issue, either format may be used. Note that old format packets have four bits of content tags, and new format packets have six; some features cannot be used and still be backward-compatible.",
      "ja": "PGP 2.6.xではだけで古い形式のパケットを使用しています。このように、PGPのそれらのバージョンと相互運用ソフトウェアは、古い形式のパケットを使用する必要があります。相互運用性に問題がない場合は、どちらの形式を使用することができます。古い形式のパケットがコンテンツタグの4ビットを持ち、新しいフォーマットのパケットは6を持っていることに注意してください。いくつかの機能が使用され、まだ下位互換性があることはできません。"
    },
    {
      "indent": 3,
      "text": "Old format packets contain:",
      "ja": "古い形式のパケットが含まれています。"
    },
    {
      "indent": 9,
      "text": "Bits 5-2 -- content tag\nBits 1-0 - length-type",
      "raw": true
    },
    {
      "indent": 3,
      "text": "New format packets contain:",
      "ja": "新しいフォーマットのパケットが含まれています。"
    },
    {
      "indent": 9,
      "text": "Bits 5-0 -- content tag",
      "ja": "ビット5-0  - コンテンツタグ"
    },
    {
      "indent": 0,
      "text": "4.2.1. Old-Format Packet Lengths",
      "section_title": true,
      "ja": "4.2.1。古いフォーマットのパケット長"
    },
    {
      "indent": 3,
      "text": "The meaning of the length-type in old-format packets is:",
      "ja": "古い形式のパケットの長型の意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0 - The packet has a one-octet length. The header is 2 octets long.",
      "ja": "0  - パケットは、1オクテットの長さを有します。ヘッダは2つのオクテットの長さです。"
    },
    {
      "indent": 3,
      "text": "1 - The packet has a two-octet length. The header is 3 octets long.",
      "ja": "1  - パケットは、2オクテットの長さを有します。ヘッダは、3つのオクテットの長さです。"
    },
    {
      "indent": 3,
      "text": "2 - The packet has a four-octet length. The header is 5 octets long.",
      "ja": "2  - パケットが4オクテットの長さを有します。ヘッダは、5つのオクテットの長さです。"
    },
    {
      "indent": 3,
      "text": "3 - The packet is of indeterminate length. The header is 1 octet long, and the implementation must determine how long the packet is. If the packet is in a file, this means that the packet extends until the end of the file. In general, an implementation SHOULD NOT use indeterminate length packets except where the end of the data will be clear from the context, and even then it is better to use a definite length, or a new-format header. The new-format headers described below have a mechanism for precisely encoding data of indeterminate length.",
      "ja": "3  - パケットは、不定の長さのものです。ヘッダは、1つのオクテット長であり、実装は、パケットがどのくらいかを決定しなければなりません。パケットがファイルにある場合、このパケットは、ファイルの終わりまで延びていることを意味します。一般的に、実装は、データの終わりが文脈から明らかである場合を除いて不定長のパケットを使用しません、とさえ、明確な長さ、または新しい形式のヘッダを使用する方がよいです。以下に説明する新しい形式のヘッダを正確に不定長のデータを符号化するための機構を有しています。"
    },
    {
      "indent": 0,
      "text": "4.2.2. New-Format Packet Lengths",
      "section_title": true,
      "ja": "4.2.2。新フォーマットのパケット長"
    },
    {
      "indent": 3,
      "text": "New format packets have four possible ways of encoding length:",
      "ja": "新しいフォーマットのパケットは、符号化長さの4つの可能な方法があります。"
    },
    {
      "indent": 4,
      "text": "1. A one-octet Body Length header encodes packet lengths of up to 191 octets.",
      "ja": "1. 1オクテットボディLengthヘッダは、最大191オクテットのパケット長を符号化します。"
    },
    {
      "indent": 3,
      "text": "2. A two-octet Body Length header encodes packet lengths of 192 to 8383 octets.",
      "ja": "2. 2オクテットボディLengthヘッダ192 8383オクテットのパケット長を符号化します。"
    },
    {
      "indent": 4,
      "text": "3. A five-octet Body Length header encodes packet lengths of up to 4,294,967,295 (0xFFFFFFFF) octets in length. (This actually encodes a four-octet scalar number.)",
      "ja": "3. 5オクテットボディLengthヘッダは、長さが最大4,294,967,295（0xFFFFFFFFの）オクテットのパケット長を符号化します。 （これは実際には4オクテットのスカラー数を符号化します。）"
    },
    {
      "indent": 4,
      "text": "4. When the length of the packet body is not known in advance by the issuer, Partial Body Length headers encode a packet of indeterminate length, effectively making it a stream.",
      "ja": "前記パケットボディの長さは、発行者によって事前に知られていない場合、身体部分の長さのヘッダーは効果的に流れながら、不定長のパケットを符号化します。"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. One-Octet Lengths",
      "section_title": true,
      "ja": "4.2.2.1。 1オクテット長"
    },
    {
      "indent": 3,
      "text": "A one-octet Body Length header encodes a length of from 0 to 191 octets. This type of length header is recognized because the one octet value is less than 192. The body length is equal to:",
      "ja": "1オクテットボディLengthヘッダは、0から191オクテットの長さを符号化します。 1つのオクテットの値は、本体の長さはに等しい192未満であるため、長さヘッダのこのタイプは、認識されます。"
    },
    {
      "indent": 7,
      "text": "bodyLen = 1st_octet;",
      "ja": "bodyLen = 1st_octet。"
    },
    {
      "indent": 0,
      "text": "4.2.2.2. Two-Octet Lengths",
      "section_title": true,
      "ja": "4.2.2.2。 2オクテット長"
    },
    {
      "indent": 3,
      "text": "A two-octet Body Length header encodes a length of from 192 to 8383 octets. It is recognized because its first octet is in the range 192 to 223. The body length is equal to:",
      "ja": "2オクテットボディLengthヘッダから192 8383オクテットの長さを符号化します。その最初のオクテットは192 223に本体の長さが等しい範囲であるので、それが認識されます。"
    },
    {
      "indent": 7,
      "text": "bodyLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192",
      "ja": "bodyLen =（（1st_octet  -  192）<< 8）+（2nd_octet）+ 192"
    },
    {
      "indent": 0,
      "text": "4.2.2.3. Five-Octet Lengths",
      "section_title": true,
      "ja": "4.2.2.3。五オクテット長"
    },
    {
      "indent": 3,
      "text": "A five-octet Body Length header consists of a single octet holding the value 255, followed by a four-octet scalar. The body length is equal to:",
      "ja": "5オクテットボディLengthヘッダは、4オクテットのスカラー続い値255を保持する単一のオクテットで構成されています。本体の長さはに等しいです。"
    },
    {
      "indent": 7,
      "text": "bodyLen = (2nd_octet << 24) | (3rd_octet << 16) |\n          (4th_octet << 8)  | 5th_octet",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2.2.4. Partial Body Lengths",
      "section_title": true,
      "ja": "4.2.2.4。部分的なボディ長さ"
    },
    {
      "indent": 3,
      "text": "A Partial Body Length header is one octet long and encodes the length of only part of the data packet. This length is a power of 2, from 1 to 1,073,741,824 (2 to the 30th power). It is recognized by its one octet value that is greater than or equal to 224, and less than 255. The partial body length is equal to:",
      "ja": "身体部分の長さヘッダは1つのオクテット長であり、データ・パケットの一部だけの長さを符号化します。この長さは1から1,073,741,824（30パワー2）に、2の累乗です。それは224以上であり、その1つのオクテットの値により認識され、未満255身体部分の長さに等しいです。"
    },
    {
      "indent": 7,
      "text": "partialBodyLen = 1 << (1st_octet & 0x1f);",
      "ja": "partialBodyLen = 1 <<（1st_octet＆0x1Fの）。"
    },
    {
      "indent": 3,
      "text": "Each Partial Body Length header is followed by a portion of the packet body data. The Partial Body Length header specifies this portion's length. Another length header (of one of the three types -- one octet, two-octet, or partial) follows that portion. The last length header in the packet MUST NOT be a partial Body Length header. Partial Body Length headers may only be used for the non-final parts of the packet.",
      "ja": "各身体部分の長ヘッダがパケットボディデータの部分が続きます。部分的なボディLengthヘッダは、この部分の長さを指定します。 （三種類のいずれかの -  1つのオクテット、2オクテット、又は部分的な）別の長さヘッダは、その部分に続きます。パケットの最後の長さヘッダは、部分的なボディの長さのヘッダーにすることはできません。身体部分の長ヘッダのみのパケットの非最終的な部品のために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Packet Length Examples",
      "section_title": true,
      "ja": "4.2.3。パケット長の例"
    },
    {
      "indent": 3,
      "text": "These examples show ways that new-format packets might encode the packet lengths.",
      "ja": "これらの例は、新しい形式のパケットは、パケット長をコード化する可能性がある方法を示しています。"
    },
    {
      "indent": 3,
      "text": "A packet with length 100 may have its length encoded in one octet: 0x64. This is followed by 100 octets of data.",
      "ja": "0x64：長さ100を持つパケットは、その長さが1つのオクテットで符号化されていてもよいです。これは、データの100個のオクテットが続いています。"
    },
    {
      "indent": 3,
      "text": "A packet with length 1723 may have its length coded in two octets: 0xC5, 0xFB. This header is followed by the 1723 octets of data.",
      "ja": "0xC5、0xFB：長さ1723を有するパケットは、その長さは2つのオクテットで符号化されていてもよいです。このヘッダは、データの1723個のオクテットが続きます。"
    },
    {
      "indent": 3,
      "text": "A packet with length 100000 may have its length encoded in five octets: 0xFF, 0x00, 0x01, 0x86, 0xA0.",
      "ja": "0xFFの、0x00の、0x01の、0x86で、0xA0を：長さ100000のパケットは、その長さは5つのオクテットでエンコードした可能性があります。"
    },
    {
      "indent": 3,
      "text": "It might also be encoded in the following octet stream: 0xEF, first 32768 octets of data; 0xE1, next two octets of data; 0xE0, next one octet of data; 0xF0, next 65536 octets of data; 0xC5, 0xDD, last 1693 octets of data. This is just one possible encoding, and many variations are possible on the size of the Partial Body Length headers, as long as a regular Body Length header encodes the last portion of the data. Note also that the last Body Length header can be a zero-length header.",
      "ja": "また、次のオクテットストリームに符号化される可能性があります：0xEFという、データの最初の32768オクテット。 0xE1の、データの次の2つのオクテット; 0xE0となっ、データの次のオクテット。 0xF0、データの次の65536オクテット。 0xC5、0xDD、データの最後の1693オクテット。これは単に一つの可能​​な符号化され、多くのバリエーションがあれば定期的なボディLengthヘッダは、データの最後の部分をコードするように、身体部分の長ヘッダーのサイズが可能です。最後ボディLengthヘッダは、長さゼロのヘッダであってもよいことにも留意されたいです。"
    },
    {
      "indent": 3,
      "text": "An implementation MAY use Partial Body Lengths for data packets, be they literal, compressed, or encrypted. The first partial length MUST be at least 512 octets long. Partial Body Lengths MUST NOT be used for any other packet types.",
      "ja": "実装は、圧縮、または暗号化された、彼らはリテラルで、データパケットのための部分的なボディ長を使用するかもしれません。第1の部分の長さは、少なくとも512オクテット長さでなければなりません。部分的なボディ長さは、他のパケットタイプのために使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "Please note that in all of these explanations, the total length of the packet is the length of the header(s) plus the length of the body.",
      "ja": "これらの説明の全てにおいて、パケットの全長は、ヘッダ（単数または複数）に加えて本体の長さの長さであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.3. Packet Tags",
      "section_title": true,
      "ja": "4.3。パケットタグ"
    },
    {
      "indent": 3,
      "text": "The packet tag denotes what type of packet the body holds. Note that old format headers can only have tags less than 16, whereas new format headers can have tags as great as 63. The defined tags (in decimal) are:",
      "ja": "パケットタグは、体が保持しているパケットの種類を表します。新しい形式のヘッダが（10進数）が大きい63として定義されているタグなどのタグを有することができ、一方、古いフォーマットヘッダのみ、16未満のタグを有することができることに注意しています。"
    },
    {
      "indent": 7,
      "text": "0        -- Reserved - a packet tag must not have this value\n1        -- Public-Key Encrypted Session Key Packet\n2        -- Signature Packet\n3        -- Symmetric-Key Encrypted Session Key Packet\n4        -- One-Pass Signature Packet\n5        -- Secret Key Packet\n6        -- Public Key Packet\n7        -- Secret Subkey Packet\n8        -- Compressed Data Packet\n9        -- Symmetrically Encrypted Data Packet\n10       -- Marker Packet\n11       -- Literal Data Packet\n12       -- Trust Packet",
      "raw": true
    },
    {
      "indent": 7,
      "text": "13 -- User ID Packet 14 -- Public Subkey Packet 60 to 63 -- Private or Experimental Values",
      "ja": "13  - ユーザーIDパケット14  - 公共のサブキーパケット60〜63  - プライベートまたは実験値"
    },
    {
      "indent": 0,
      "text": "5. Packet Types",
      "section_title": true,
      "ja": "5.パケットタイプ"
    },
    {
      "indent": 0,
      "text": "5.1. Public-Key Encrypted Session Key Packets (Tag 1)",
      "section_title": true,
      "ja": "5.1。公開鍵暗号化されたセッション鍵パケット（タグ1）"
    },
    {
      "indent": 3,
      "text": "A Public-Key Encrypted Session Key packet holds the session key used to encrypt a message. Zero or more Encrypted Session Key packets (either Public-Key or Symmetric-Key) may precede a Symmetrically Encrypted Data Packet, which holds an encrypted message. The message is encrypted with the session key, and the session key is itself encrypted and stored in the Encrypted Session Key packet(s). The Symmetrically Encrypted Data Packet is preceded by one Public-Key Encrypted Session Key packet for each OpenPGP key to which the message is encrypted. The recipient of the message finds a session key that is encrypted to their public key, decrypts the session key, and then uses the session key to decrypt the message.",
      "ja": "公開鍵暗号化されたセッション鍵パケットは、メッセージを暗号化するために使用されるセッション鍵を保持しています。ゼロまたはそれ以上の暗号化されたセッション鍵パケット（公開鍵のいずれかまたは共通鍵）は、暗号化されたメッセージを保持して対称的に暗号化データパケットを、先行していてもよいです。メッセージは、セッション鍵で暗号化し、セッション鍵自体を暗号化して暗号化されたセッション鍵パケット（複数可）に格納されています。対称的に暗号化データ・パケットは、メッセージが暗号化されている各のOpenPGPキーの1公開鍵暗号化されたセッション鍵パケットが先行しています。メッセージの受信者は、自分の公開鍵で暗号化されたセッション鍵を見つけたセッション鍵を復号して、メッセージを解読するためにセッションキーを使用しています。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットのボディはで構成されています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number giving the version number of the packet type. The currently defined value for packet version is 3. An implementation should accept, but not generate a version of 2, which is equivalent to V3 in all other respects.",
      "ja": " - パケットタイプのバージョン番号を与える1オクテットの数。パケットのバージョンに現在定義された値は、実装は受け入れるが、他のすべての点でV3に相当する2のバージョンを生成してはならない3です。"
    },
    {
      "indent": 5,
      "text": "- An eight-octet number that gives the key ID of the public key that the session key is encrypted to.",
      "ja": " - セッションキーが暗号化されていることに、公開鍵の鍵IDを与える8オクテットの数。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number giving the public key algorithm used.",
      "ja": " - 使用される公開鍵アルゴリズムを与える1オクテットの数。"
    },
    {
      "indent": 5,
      "text": "- A string of octets that is the encrypted session key. This string takes up the remainder of the packet, and its contents are dependent on the public key algorithm used.",
      "ja": " - 暗号化されたセッション鍵であるオクテットの列。この文字列は、パケットの残りの部分を占めており、その内容は、使用される公開鍵アルゴリズムに依存しています。"
    },
    {
      "indent": 3,
      "text": "Algorithm Specific Fields for RSA encryption",
      "ja": "RSA暗号化アルゴリズム特定フィールド"
    },
    {
      "indent": 5,
      "text": "- multiprecision integer (MPI) of RSA encrypted value m**e mod n.",
      "ja": " -  RSA暗号化値mの多倍精度整数（MPI）** E mod nを。"
    },
    {
      "indent": 3,
      "text": "Algorithm Specific Fields for Elgamal encryption:",
      "ja": "ElGamal暗号アルゴリズム特定フィールド："
    },
    {
      "indent": 5,
      "text": "- MPI of Elgamal (Diffie-Hellman) value g**k mod p.",
      "ja": " - はElgamalのMPI（ディフィー - ヘルマン）値G ** K MOD P。"
    },
    {
      "indent": 5,
      "text": "- MPI of Elgamal (Diffie-Hellman) value m * y**k mod p.",
      "ja": " - はElgamalのMPI（ディフィー - ヘルマン）値のM *のY ** K MOD P。"
    },
    {
      "indent": 3,
      "text": "The value \"m\" in the above formulas is derived from the session key as follows. First the session key is prefixed with a one-octet algorithm identifier that specifies the symmetric encryption algorithm used to encrypt the following Symmetrically Encrypted Data Packet. Then a two-octet checksum is appended which is equal to the sum of the preceding session key octets, not including the algorithm identifier, modulo 65536. This value is then padded as described in PKCS-1 block type 02 [RFC2313] to form the \"m\" value used in the formulas above.",
      "ja": "次のように、上記式の値「m」は、セッション鍵から導出されます。最初のセッションキーは以下の対称的に暗号化データパケットを暗号化するために使用される対称暗号化アルゴリズムを指定する1オクテットのアルゴリズム識別子が付いています。次いで、2オクテットのチェックサムがアルゴリズム識別子を含まない先行セッション鍵オクテット、の和に等しくなる追加され、モジュロ65536 PKCS-1ブロックタイプ02 [RFC2313]に記載されているように、この値は、その後形成するために埋め込まれ上記の式において使用される「M」値。"
    },
    {
      "indent": 3,
      "text": "Note that when an implementation forms several PKESKs with one session key, forming a message that can be decrypted by several keys, the implementation MUST make new PKCS-1 padding for each key.",
      "ja": "実装は、複数のキーによって解読可能なメッセージを形成し、1つのセッション鍵を用いていくつかのPKESKsを形成する場合、実装は各キーのための新しいPKCS-1のパディングを行う必要があります。"
    },
    {
      "indent": 3,
      "text": "An implementation MAY accept or use a Key ID of zero as a \"wild card\" or \"speculative\" Key ID. In this case, the receiving implementation would try all available private keys, checking for a valid decrypted session key. This format helps reduce traffic analysis of messages.",
      "ja": "実装は受け入れるか、「ワイルドカード」または「投機的」キーIDとしてゼロのキーIDを使用するかもしれません。この場合、受信実装は、有効な復号化されたセッション鍵の確認、利用可能なすべての秘密鍵をしようとするだろう。このフォーマットは、メッセージのトラフィック分析を減らすことができます。"
    },
    {
      "indent": 0,
      "text": "5.2. Signature Packet (Tag 2)",
      "section_title": true,
      "ja": "5.2。署名パケット（タグ2）"
    },
    {
      "indent": 3,
      "text": "A signature packet describes a binding between some public key and some data. The most common signatures are a signature of a file or a block of text, and a signature that is a certification of a user ID.",
      "ja": "署名パケットは、いくつかの公開鍵といくつかのデータ間の結合を説明します。最も一般的な署名は、ファイルまたはテキストのブロック、及びユーザIDの認証された署名の署名です。"
    },
    {
      "indent": 3,
      "text": "Two versions of signature packets are defined. Version 3 provides basic signature information, while version 4 provides an expandable format with subpackets that can specify more information about the signature. PGP 2.6.x only accepts version 3 signatures.",
      "ja": "署名パケットの2つのバージョンが定義されています。バージョン4は、署名に関する詳細情報を指定することができるサブパケットを有する拡張可能なフォーマットを提供しながら、バージョン3は、基本的な署名情報を提供します。 PGP 2.6.xではでは唯一のバージョン3人の署名を受け付けます。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST accept V3 signatures. Implementations SHOULD generate V4 signatures. Implementations MAY generate a V3 signature that can be verified by PGP 2.6.x.",
      "ja": "実装はV3署名を受け入れなければなりません。実装はV4署名を生成する必要があります。実装はPGPの2.6.x.によって検証することができるV3署名を生成してもよい（MAY）"
    },
    {
      "indent": 3,
      "text": "Note that if an implementation is creating an encrypted and signed message that is encrypted to a V3 key, it is reasonable to create a V3 signature.",
      "ja": "実装がV3キーに暗号化され暗号化され署名されたメッセージを作成している場合、V3署名を作成することが妥当であることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Signature Types",
      "section_title": true,
      "ja": "5.2.1。署名の種類"
    },
    {
      "indent": 3,
      "text": "There are a number of possible meanings for a signature, which are specified in a signature type octet in any given signature. These meanings are:",
      "ja": "任意の所定の署名で署名タイプオクテットで指定された署名のための可能な意味の数があります。これらの意味は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x00: Signature of a binary document. Typically, this means the signer owns it, created it, or certifies that it has not been modified.",
      "ja": "$ 00：バ​​イナリドキュメントの署名。通常、これは、署名者がそれを所有していること、それを作成した、またはそれが変更されていないことを証明します。"
    },
    {
      "indent": 3,
      "text": "0x01: Signature of a canonical text document. Typically, this means the signer owns it, created it, or certifies that it has not been modified. The signature is calculated over the text data with its line endings converted to <CR><LF> and trailing blanks removed.",
      "ja": "0x01の：標準テキスト文書の署名。通常、これは、署名者がそれを所有していること、それを作成した、またはそれが変更されていないことを証明します。署名は、<CR> <LF>と末尾の空白を除去するために変換され、その行末のテキストデータにわたって計算されます。"
    },
    {
      "indent": 3,
      "text": "0x02: Standalone signature. This signature is a signature of only its own subpacket contents. It is calculated identically to a signature over a zero-length binary document. Note that it doesn't make sense to have a V3 standalone signature.",
      "ja": "0×02：スタンドアロン署名。このシグネチャは、自身のサブパケット内容の署名です。これは、長さゼロのバイナリ文書上の署名と同一に計算されます。それはV3スタンドアロン署名を持っている意味がないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "0x10: Generic certification of a User ID and Public Key packet. The issuer of this certification does not make any particular assertion as to how well the certifier has checked that the owner of the key is in fact the person described by the user ID. Note that all PGP \"key signatures\" are this type of certification.",
      "ja": "0x10を：ユーザIDと公開鍵パケットの一般的な認定。この証明の発行人は証明者は、鍵の所有者が実際にユーザーIDによって記述人物であることを確認したかだけでなくに関していかなる特定のアサーションを作成しません。すべてのPGP「キー署名は」認定のこのタイプであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "0x11: Persona certification of a User ID and Public Key packet. The issuer of this certification has not done any verification of the claim that the owner of this key is the user ID specified.",
      "ja": "0x11を：ユーザIDと公開鍵パケットのペルソナ認定。この証明の発行人は、このキーの所有者が指定したユーザーIDであるという主張のいずれかの検証を行っていません。"
    },
    {
      "indent": 3,
      "text": "0x12: Casual certification of a User ID and Public Key packet. The issuer of this certification has done some casual verification of the claim of identity.",
      "ja": "0x12を：ユーザIDとPublic-Keyパケットのカジュアル認定。この証明の発行人は、身元の主張のいくつかのカジュアルな検証を行っています。"
    },
    {
      "indent": 3,
      "text": "0x13: Positive certification of a User ID and Public Key packet. The issuer of this certification has done substantial verification of the claim of identity.",
      "ja": "0x13に：ユーザーIDと公開鍵パケットの正認定。この証明の発行人は、身元の主張の実質的な検証を行っています。"
    },
    {
      "indent": 9,
      "text": "Please note that the vagueness of these certification claims is\nnot a flaw, but a feature of the system. Because PGP places\nfinal authority for validity upon the receiver of a\ncertification, it may be that one authority's casual\ncertification might be more rigorous than some other\nauthority's positive certification. These classifications allow\na certification authority to issue fine-grained claims.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "0x18: Subkey Binding Signature This signature is a statement by the top-level signing key indicates that it owns the subkey. This signature is calculated directly on the subkey itself, not on any User ID or other packets.",
      "ja": "0x18の：サブキーバインディング署名このシグネチャは、トップレベルの署名鍵によるステートメントは、サブキーを所有していることを示しています。このシグネチャは、サブキー自体ではなく、任意のユーザーIDまたは他のパケットで直接計算されます。"
    },
    {
      "indent": 3,
      "text": "0x1F: Signature directly on a key This signature is calculated directly on a key. It binds the information in the signature subpackets to the key, and is appropriate to be used for subpackets that provide information about the key, such as the revocation key subpacket. It is also appropriate for statements that non-self certifiers want to make about the key itself, rather than the binding between a key and a name.",
      "ja": "0x1Fの：このシグネチャは、キーに直接計算されたキーに直接署名。これは、鍵に署名サブパケット内の情報を結合し、そのような取り消しキーサブパケットとして鍵に関する情報を提供するサブパケットのために使用することが適当です。非自己認証機関ではなく、キーと名前の間の結合よりも、キー自体について作りたいということも文に適しています。"
    },
    {
      "indent": 3,
      "text": "0x20: Key revocation signature The signature is calculated directly on the key being revoked. A revoked key is not to be used. Only revocation signatures by the key being revoked, or by an authorized revocation key, should be considered valid revocation signatures.",
      "ja": "0x20の：キー取消署名は、署名は、キーが取り消されている上で直接計算されます。取り消されたキーが使用されるものではありません。キーによってのみ、取消し署名が取り消されている、または認定取り消しキーにより、有効な失効署名を考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "0x28: Subkey revocation signature The signature is calculated directly on the subkey being revoked. A revoked subkey is not to be used. Only revocation signatures by the top-level signature key that is bound to this subkey, or by an authorized revocation key, should be considered valid revocation signatures.",
      "ja": "0x28：サブキー失効署名は、署名が失効しているサブキーに直接計算されます。取り消されたサブキーを使用してはなりません。このサブキーにバインドされているトップレベルの署名鍵によって、または認定取り消しキーによってのみ、取消し署名は、有効な取消し署名考慮されるべきです。"
    },
    {
      "indent": 3,
      "text": "0x30: Certification revocation signature This signature revokes an earlier user ID certification signature (signature class 0x10 through 0x13). It should be issued by the same key that issued the revoked signature or an authorized revocation key The signature should have a later creation date than the signature it revokes.",
      "ja": "0x30から：証明書失効署名この署名は、以前のユーザID認証署名（0x13を介して署名クラスの0x10）を取り消します。それは取り消された署名または署名は、それが取り消された署名より後に作成日付を持つ必要があり、許可取り消しキーを発行した同じキーで発行する必要があります。"
    },
    {
      "indent": 3,
      "text": "0x40: Timestamp signature. This signature is only meaningful for the timestamp contained in it.",
      "ja": "0x40の：タイムスタンプ署名。このシグネチャは、その中に含まれるタイムスタンプのためにのみ意味があります。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Version 3 Signature Packet Format",
      "section_title": true,
      "ja": "5.2.2。バージョン3の署名パケットフォーマット"
    },
    {
      "indent": 3,
      "text": "The body of a version 3 Signature Packet contains:",
      "ja": "バージョン3の署名パケットの本体は含まれています。"
    },
    {
      "indent": 5,
      "text": "- One-octet version number (3).",
      "ja": " -  1オクテットのバージョン番号（3）。"
    },
    {
      "indent": 5,
      "text": "- One-octet length of following hashed material. MUST be 5.",
      "ja": " - ハッシュ化された材料を、以下の1オクテット長。 5でなければなりません。"
    },
    {
      "indent": 9,
      "text": "- One-octet signature type.",
      "ja": " -  1オクテット署名タイプ。"
    },
    {
      "indent": 9,
      "text": "- Four-octet creation time.",
      "ja": " -  4オクテットの作成時間。"
    },
    {
      "indent": 5,
      "text": "- Eight-octet key ID of signer.",
      "ja": " - 署名者のうち8オクテットの鍵ID。"
    },
    {
      "indent": 5,
      "text": "- One-octet public key algorithm.",
      "ja": " -  1八重奏公開鍵アルゴリズム。"
    },
    {
      "indent": 5,
      "text": "- One-octet hash algorithm.",
      "ja": " -  1オクテットのハッシュアルゴリズム。"
    },
    {
      "indent": 5,
      "text": "- Two-octet field holding left 16 bits of signed hash value.",
      "ja": " - 署名されたハッシュ値の16ビットを左に2オクテットフィールド保持します。"
    },
    {
      "indent": 5,
      "text": "- One or more multi-precision integers comprising the signature. This portion is algorithm specific, as described below.",
      "ja": " - 署名を含む1つ以上の多倍精度整数。以下に説明するように、この部分は、アルゴリズム固有です。"
    },
    {
      "indent": 3,
      "text": "The data being signed is hashed, and then the signature type and creation time from the signature packet are hashed (5 additional octets). The resulting hash value is used in the signature algorithm. The high 16 bits (first two octets) of the hash are included in the signature packet to provide a quick test to reject some invalid signatures.",
      "ja": "署名されるデータがハッシュされ、その後、署名パケットから署名タイプと作成時間（5つの追加オクテット）ハッシュされます。結果のハッシュ値が署名アルゴリズムで使用されています。ハッシュの上位16ビット（最初の2オクテット）は、いくつかの無効な署名を拒絶する簡単なテストを提供するために、署名パケットに含まれています。"
    },
    {
      "indent": 3,
      "text": "Algorithm Specific Fields for RSA signatures:",
      "ja": "RSA署名アルゴリズム特定フィールド："
    },
    {
      "indent": 5,
      "text": "- multiprecision integer (MPI) of RSA signature value m**d.",
      "ja": " -  ** D RSA署名値mの多倍精度整数（MPI）。"
    },
    {
      "indent": 3,
      "text": "Algorithm Specific Fields for DSA signatures:",
      "ja": "DSA署名アルゴリズム特定フィールド："
    },
    {
      "indent": 5,
      "text": "- MPI of DSA value r.",
      "ja": " -  DSA値rのMPI。"
    },
    {
      "indent": 5,
      "text": "- MPI of DSA value s.",
      "ja": " -  DSA値sのMPI。"
    },
    {
      "indent": 3,
      "text": "The signature calculation is based on a hash of the signed data, as described above. The details of the calculation are different for DSA signature than for RSA signatures.",
      "ja": "上記のように署名計算は、署名されたデータのハッシュに基づいています。計算の詳細はRSA署名よりもDSA署名のために異なっています。"
    },
    {
      "indent": 3,
      "text": "With RSA signatures, the hash value is encoded as described in PKCS-1 section 10.1.2, \"Data encoding\", producing an ASN.1 value of type DigestInfo, and then padded using PKCS-1 block type 01 [RFC2313]. This requires inserting the hash value as an octet string into an ASN.1 structure. The object identifier for the type of hash being used is included in the structure. The hexadecimal representations for the currently defined hash algorithms are:",
      "ja": "RSA署名と、ハッシュ値は、タイプDigestInfoのASN.1値を生成する、PKCS-1セクション10.1.2、「データ・エンコーディング」に記載されているように符号化され、その後、PKCS-1ブロックタイプ01 [RFC2313]を使用して埋め込まれます。これはASN.1構造にオクテットストリングとしてハッシュ値を挿入することが必要です。使用されるハッシュのタイプのオブジェクト識別子は、構造中に含まれています。現在定義されているハッシュアルゴリズムの16進表現です。"
    },
    {
      "indent": 5,
      "text": "- MD2: 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x02",
      "ja": " -  MD2：0x2A、0x86で、0x48、0x86で、0xF7、0x0Dを、0x02の0x02の"
    },
    {
      "indent": 5,
      "text": "- MD5: 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05",
      "ja": " -  MD5：0x2A、0x86で、0x48、0x86で、0xF7、0x0Dを、0x02の0x05で"
    },
    {
      "indent": 5,
      "text": "- RIPEMD-160: 0x2B, 0x24, 0x03, 0x02, 0x01",
      "ja": " -  RIPEMD-160：0x2Bを、0x24を、0x03の、0x02の0x01の"
    },
    {
      "indent": 5,
      "text": "- SHA-1: 0x2B, 0x0E, 0x03, 0x02, 0x1A",
      "ja": " -  SHA-1：0x2Bを、0x0Eの、0x03の、0x02の、0x1A"
    },
    {
      "indent": 3,
      "text": "The ASN.1 OIDs are:",
      "ja": "ASN.1のOIDは、次のとおりです。"
    },
    {
      "indent": 5,
      "text": "- MD2: 1.2.840.113549.2.2",
      "ja": " -  MD2：1.2.840.113549.2.2"
    },
    {
      "indent": 5,
      "text": "- MD5: 1.2.840.113549.2.5",
      "ja": " -  MD5：1.2.840.113549.2.5"
    },
    {
      "indent": 5,
      "text": "- RIPEMD-160: 1.3.36.3.2.1",
      "ja": " -  RIPEMD 160：1.3.36.3.2.1"
    },
    {
      "indent": 5,
      "text": "- SHA-1: 1.3.14.3.2.26",
      "ja": "ー しゃー１： １。３。１４。３。２。２６"
    },
    {
      "indent": 3,
      "text": "The full hash prefixes for these are:",
      "ja": "これらの完全なハッシュプレフィックスは以下のとおりです。"
    },
    {
      "indent": 7,
      "text": "MD2:        0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86,\n            0x48, 0x86, 0xF7, 0x0D, 0x02, 0x02, 0x05, 0x00,\n            0x04, 0x10",
      "raw": true
    },
    {
      "indent": 7,
      "text": "MD5: 0x30, 0x20, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10",
      "ja": "MD5：0x30を、0x20に、0x30を、0x0Cの、0x06で、0x08に、0x2A、0x86で、0x48、0x86で、0xF7、0x0Dを、0x02の0x05の、0x05を、0x00に、0x04を、0x10の"
    },
    {
      "indent": 7,
      "text": "RIPEMD-160: 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x24, 0x03, 0x02, 0x01, 0x05, 0x00, 0x04, 0x14",
      "ja": "RIPEMD-160：0x30を、0x21で、0x30から、0x09の、0x06で、0x05の、0x2Bを、0x24を、0x03の、0x02の、0x01で、0x05の、0x00に、0x04を、0x14の"
    },
    {
      "indent": 7,
      "text": "SHA-1: 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x04, 0x14",
      "ja": "SHA-1：0x30を、0x21で、0x30から、0x09の、0x06で、0x05の、0x2Bを、0x0Eの、0x03の、0x02の、0x1A、0x05を、0x00に、0x04を、0x14の"
    },
    {
      "indent": 3,
      "text": "DSA signatures MUST use hashes with a size of 160 bits, to match q, the size of the group generated by the DSA key's generator value. The hash function result is treated as a 160 bit number and used directly in the DSA signature algorithm.",
      "ja": "DSA署名は、Q、DSA鍵の生成値によって生成されたグループのサイズに一致するように、160ビットのサイズのハッシュを使用しなければなりません。ハッシュ関数の結果は、160ビットの数として扱われ、DSA署名アルゴリズムに直接使用されます。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Version 4 Signature Packet Format",
      "section_title": true,
      "ja": "5.2.3。バージョン4署名パケットフォーマット"
    },
    {
      "indent": 3,
      "text": "The body of a version 4 Signature Packet contains:",
      "ja": "バージョン4署名パケットの本体は含まれています。"
    },
    {
      "indent": 5,
      "text": "- One-octet version number (4).",
      "ja": " -  1オクテットのバージョン番号（4）。"
    },
    {
      "indent": 5,
      "text": "- One-octet signature type.",
      "ja": " -  1オクテット署名タイプ。"
    },
    {
      "indent": 5,
      "text": "- One-octet public key algorithm.",
      "ja": " -  1八重奏公開鍵アルゴリズム。"
    },
    {
      "indent": 5,
      "text": "- One-octet hash algorithm.",
      "ja": " -  1オクテットのハッシュアルゴリズム。"
    },
    {
      "indent": 5,
      "text": "- Two-octet scalar octet count for following hashed subpacket data. Note that this is the length in octets of all of the hashed subpackets; a pointer incremented by this number will skip over the hashed subpackets.",
      "ja": " -  2オクテットのスカラーオクテットは、ハッシュ化されたサブパケットのデータを、次のカウント。これは、ハッシュ化されたサブパケットの全てのオクテットの長さであることに注意してください。この数によって増分ポインタは、ハッシュ化されたサブパケットをスキップします。"
    },
    {
      "indent": 5,
      "text": "- Hashed subpacket data. (zero or more subpackets)",
      "ja": " - ハッシュサブパケットデータ。 （ゼロ以上のサブパケット）"
    },
    {
      "indent": 5,
      "text": "- Two-octet scalar octet count for following unhashed subpacket data. Note that this is the length in octets of all of the unhashed subpackets; a pointer incremented by this number will skip over the unhashed subpackets.",
      "ja": " -  2オクテットのスカラーオクテットは、未ハッシュサブパケットデータを、次のカウント。これはハッシュ解除済みのサブパケットの全てのオクテットの長さであることに注意してください。この数によって増分ポインタはハッシュ解除済みのサブパケットをスキップします。"
    },
    {
      "indent": 5,
      "text": "- Unhashed subpacket data. (zero or more subpackets)",
      "ja": " - ハッシュ解除済みサブパケットデータ。 （ゼロ以上のサブパケット）"
    },
    {
      "indent": 5,
      "text": "- Two-octet field holding left 16 bits of signed hash value.",
      "ja": " - 署名されたハッシュ値の16ビットを左に2オクテットフィールド保持します。"
    },
    {
      "indent": 5,
      "text": "- One or more multi-precision integers comprising the signature. This portion is algorithm specific, as described above.",
      "ja": " - 署名を含む1つ以上の多倍精度整数。上述したように、この部分は、アルゴリズム固有です。"
    },
    {
      "indent": 3,
      "text": "The data being signed is hashed, and then the signature data from the version number through the hashed subpacket data (inclusive) is hashed. The resulting hash value is what is signed. The left 16 bits of the hash are included in the signature packet to provide a quick test to reject some invalid signatures.",
      "ja": "署名されるデータはハッシュされ、その後、ハッシュ化されたサブパケットのデータを介して、バージョン番号（含む）から署名データがハッシュされます。結果のハッシュ値が署名されたものです。ハッシュの左の16ビットは、いくつかの無効な署名を拒絶する簡単なテストを提供するために、署名パケットに含まれています。"
    },
    {
      "indent": 3,
      "text": "There are two fields consisting of signature subpackets. The first field is hashed with the rest of the signature data, while the second is unhashed. The second set of subpackets is not cryptographically protected by the signature and should include only advisory information.",
      "ja": "署名サブパケットからなる2つのフィールドがあります。第二は、未ハッシュである最初のフィールドは、署名データの残りのハッシュされます。サブパケットの第2のセットは、暗号署名によって保護されていないとだけアドバイザリー情報を含むべきです。"
    },
    {
      "indent": 3,
      "text": "The algorithms for converting the hash function result to a signature are described in a section below.",
      "ja": "署名にハッシュ関数の結果を変換するためのアルゴリズムは以下のセクションに記載されています。"
    },
    {
      "indent": 0,
      "text": "5.2.3.1. Signature Subpacket Specification",
      "section_title": true,
      "ja": "5.2.3.1。署名サブパケットの仕様"
    },
    {
      "indent": 3,
      "text": "The subpacket fields consist of zero or more signature subpackets. Each set of subpackets is preceded by a two-octet scalar count of the length of the set of subpackets.",
      "ja": "サブパケットフィールドはゼロまたはそれ以上の署名サブパケットから成ります。サブパケットの各セットは、サブパケットの集合の長さの2つのオクテットのスカラー数によって先行されます。"
    },
    {
      "indent": 3,
      "text": "Each subpacket consists of a subpacket header and a body. The header consists of:",
      "ja": "各サブパケットは、サブパケットヘッダとボディから成ります。ヘッダはで構成されています。"
    },
    {
      "indent": 5,
      "text": "- the subpacket length (1, 2, or 5 octets)",
      "ja": " - サブパケットの長さ（1、2、または5つのオクテット）"
    },
    {
      "indent": 5,
      "text": "- the subpacket type (1 octet)",
      "ja": " - サブパケットのタイプ（1つのオクテット）"
    },
    {
      "indent": 3,
      "text": "and is followed by the subpacket specific data.",
      "ja": "そしてサブパケット固有のデータが続いています。"
    },
    {
      "indent": 3,
      "text": "The length includes the type octet but not this length. Its format is similar to the \"new\" format packet header lengths, but cannot have partial body lengths. That is:",
      "ja": "長さはタイプオクテットではなく、この長さを含んでいます。そのフォーマットは、「新しい」形式のパケットヘッダの長さと同様であるが、身体部分の長さを持つことができません。あれは："
    },
    {
      "indent": 7,
      "text": "if the 1st octet <  192, then\n    lengthOfLength = 1\n    subpacketLen = 1st_octet",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if the 1st octet >= 192 and < 255, then lengthOfLength = 2 subpacketLen = ((1st_octet - 192) << 8) + (2nd_octet) + 192",
      "ja": "もし第1オクテット> = 192 <255、次いでlengthOfLength = 2 subpacketLen =（（1st_octet  -  192）<< 8）+（2nd_octet）+ 192"
    },
    {
      "indent": 7,
      "text": "if the 1st octet = 255, then lengthOfLength = 5 subpacket length = [four-octet scalar starting at 2nd_octet]",
      "ja": "もし第1オクテット= 255、次いでlengthOfLength = 5のサブパケット長= [4オクテットのスカラー2nd_octet始まります]"
    },
    {
      "indent": 3,
      "text": "The value of the subpacket type octet may be:",
      "ja": "サブパケットタイプオクテットの値であってもよいです。"
    },
    {
      "indent": 7,
      "text": "2 = signature creation time\n3 = signature expiration time\n4 = exportable certification\n5 = trust signature\n6 = regular expression\n7 = revocable\n9 = key expiration time\n10 = placeholder for backward compatibility\n11 = preferred symmetric algorithms\n12 = revocation key\n16 = issuer key ID\n20 = notation data\n21 = preferred hash algorithms\n22 = preferred compression algorithms\n23 = key server preferences\n24 = preferred key server\n25 = primary user id\n26 = policy URL\n27 = key flags\n28 = signer's user id\n29 = reason for revocation\n100 to 110 = internal or user-defined",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD ignore any subpacket of a type that it does not recognize.",
      "ja": "実装は、それが認識しないタイプのいずれかのサブパケットを無視すべきです。"
    },
    {
      "indent": 3,
      "text": "Bit 7 of the subpacket type is the \"critical\" bit. If set, it denotes that the subpacket is one that is critical for the evaluator of the signature to recognize. If a subpacket is encountered that is marked critical but is unknown to the evaluating software, the evaluator SHOULD consider the signature to be in error.",
      "ja": "サブパケットの種類のビット7は「クリティカル」ビットです。設定されている場合、それはサブパケットが認識するために、署名の評価のために重要なものであることを示しています。サブパケットが重要なマークされていることに遭遇するが、評価ソフトウェアに認識されている場合、評価者は、署名が誤りであることを考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "An evaluator may \"recognize\" a subpacket, but not implement it. The purpose of the critical bit is to allow the signer to tell an evaluator that it would prefer a new, unknown feature to generate an error than be ignored.",
      "ja": "評価者は、サブパケットを「認識」が、それを実装しない場合があります。重要なビットの目的は、署名者は、それが無視されるよりも、エラーを発生させるために新しい、未知の機能を好む評価者に伝えることを可能にすることです。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD implement \"preferences\".",
      "ja": "実装は、「環境設定」を実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.2. Signature Subpacket Types",
      "section_title": true,
      "ja": "5.2.3.2。署名サブパケットタイプ"
    },
    {
      "indent": 3,
      "text": "A number of subpackets are currently defined. Some subpackets apply to the signature itself and some are attributes of the key. Subpackets that are found on a self-signature are placed on a user id certification made by the key itself. Note that a key may have more than one user id, and thus may have more than one self-signature, and differing subpackets.",
      "ja": "サブパケットの数は、現在定義されています。いくつかのサブパケットは、署名自体に適用され、いくつかは、キーの属性です。自己署名に見出されるサブパケットは、キー自体によって行われたユーザID認証に配置されています。キーは、複数のユーザIDを有していてもよく、したがって、複数の自己署名を有し、異なるサブパケットもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "A self-signature is a binding signature made by the key the signature refers to. There are three types of self-signatures, the certification signatures (types 0x10-0x13), the direct-key signature (type 0x1f), and the subkey binding signature (type 0x18). For certification self-signatures, each user ID may have a self-signature, and thus different subpackets in those self-signatures. For subkey binding signatures, each subkey in fact has a self-signature. Subpackets that appear in a certification self-signature apply to the username, and subpackets that appear in the subkey self-signature apply to the subkey. Lastly, subpackets on the direct key signature apply to the entire key.",
      "ja": "自己署名は、署名が指すキー製結合署名です。自己署名の3種類の認証署名（タイプ0x10-0x13）、直接鍵署名（タイプ0x1Fの）、及びサブキー結合署名（タイプ0x18の）が存在します。証明自己署名に、各ユーザIDは、これらの自己署名自己署名、および従って異なるサブパケットを有することができます。サブキー結合署名のため、実際には各サブキーは、自己署名を有します。認定自己署名に表示されるサブパケットには、ユーザ名に適用され、サブキーの自己署名に表示されるサブパケットは、サブキーに適用されます。最後に、ダイレクトキー署名のサブパケットは、キー全体に適用されます。"
    },
    {
      "indent": 3,
      "text": "Implementing software should interpret a self-signature's preference subpackets as narrowly as possible. For example, suppose a key has two usernames, Alice and Bob. Suppose that Alice prefers the symmetric algorithm CAST5, and Bob prefers IDEA or Triple-DES. If the software locates this key via Alice's name, then the preferred algorithm is CAST5, if software locates the key via Bob's name, then the preferred algorithm is IDEA. If the key is located by key id, then algorithm of the default user id of the key provides the default symmetric algorithm.",
      "ja": "ソフトウェアを実装するように狭く、できるだけ自己署名の嗜好サブパケットを解釈すべきです。例えば、キーが2つのユーザ名、アリスとボブを持っているとします。アリスは、対称アルゴリズムCAST5を好み、そしてボブはIDEAまたはトリプルDESを好むと仮定する。ソフトウェアは、アリスの名前を経由してこのキーを見つけた場合、好ましいアルゴリズムはCAST5あるソフトウェアは、ボブの名前を経由してキーを見つけた場合、その後、好ましいアルゴリズムはIDEAです。鍵が鍵IDによって配置されている場合、キーのデフォルトのユーザーIDのアルゴリズムは、デフォルトの対称アルゴリズムを提供します。"
    },
    {
      "indent": 3,
      "text": "A subpacket may be found either in the hashed or unhashed subpacket sections of a signature. If a subpacket is not hashed, then the information in it cannot be considered definitive because it is not part of the signature proper.",
      "ja": "サブパケットは、署名のハッシュあるいは未ハッシュサブパケットのセクションのいずれかで見出され得ます。サブパケットがハッシュされていない場合、それは適切な署名の一部ではないので、それに記載されている情報は、決定的と考えることはできません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.3. Signature creation time",
      "section_title": true,
      "ja": "5.2.3.3。署名作成時間"
    },
    {
      "indent": 3,
      "text": "(4 octet time field)",
      "ja": "（4オクテットのタイムフィールド）"
    },
    {
      "indent": 3,
      "text": "The time the signature was made.",
      "ja": "署名が行われた時間。"
    },
    {
      "indent": 3,
      "text": "MUST be present in the hashed area.",
      "ja": "ハッシュされた領域内に存在しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.4. Issuer",
      "section_title": true,
      "ja": "5.2.3.4。発行者"
    },
    {
      "indent": 3,
      "text": "(8 octet key ID)",
      "ja": "（8オクテット鍵ID）"
    },
    {
      "indent": 3,
      "text": "The OpenPGP key ID of the key issuing the signature.",
      "ja": "署名を発行するキーののOpenPGPキーID。"
    },
    {
      "indent": 0,
      "text": "5.2.3.5. Key expiration time",
      "section_title": true,
      "ja": "5.2.3.5。キー有効期限"
    },
    {
      "indent": 3,
      "text": "(4 octet time field)",
      "ja": "（4オクテットのタイムフィールド）"
    },
    {
      "indent": 3,
      "text": "The validity period of the key. This is the number of seconds after the key creation time that the key expires. If this is not present or has a value of zero, the key never expires. This is found only on a self-signature.",
      "ja": "キーの有効期間。これは、キーの有効期限が切れたキー作成時間後の秒数です。これが存在しないか、ゼロの値を持っている場合は、キーが期限切れになることはありません。これが唯一の自己署名に発見されました。"
    },
    {
      "indent": 0,
      "text": "5.2.3.6. Preferred symmetric algorithms",
      "section_title": true,
      "ja": "5.2.3.6。好適な対称アルゴリズム"
    },
    {
      "indent": 3,
      "text": "(sequence of one-octet values)",
      "ja": "（1オクテット値の配列）"
    },
    {
      "indent": 3,
      "text": "Symmetric algorithm numbers that indicate which algorithms the key holder prefers to use. The subpacket body is an ordered list of octets with the most preferred listed first. It is assumed that only algorithms listed are supported by the recipient's software. Algorithm numbers in section 9. This is only found on a self-signature.",
      "ja": "キー保持者が使用することを好むアルゴリズムかを示す対称アルゴリズム番号。サブパケット本体が最も好ましい最初に記載されているとのオクテットの順序付きリストです。記載されている唯一のアルゴリズムは、受信者のソフトウェアでサポートされているものとします。セクション9のアルゴリズム番号はこれだけ自己署名に発見されました。"
    },
    {
      "indent": 0,
      "text": "5.2.3.7. Preferred hash algorithms",
      "section_title": true,
      "ja": "5.2.3.7。好適なハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "(array of one-octet values)",
      "ja": "（1オクテット値の配列）"
    },
    {
      "indent": 3,
      "text": "Message digest algorithm numbers that indicate which algorithms the key holder prefers to receive. Like the preferred symmetric algorithms, the list is ordered. Algorithm numbers are in section 6. This is only found on a self-signature.",
      "ja": "メッセージは、鍵保持者が受け取ることを好むアルゴリズムかを示すアルゴリズム番号をダイジェスト。好適な対称アルゴリズムと同様に、リストが順序付けられています。アルゴリズム番号がセクション6でこれが唯一の自己署名に発見されています。"
    },
    {
      "indent": 0,
      "text": "5.2.3.8. Preferred compression algorithms",
      "section_title": true,
      "ja": "5.2.3.8。好適な圧縮アルゴリズム"
    },
    {
      "indent": 3,
      "text": "(array of one-octet values)",
      "ja": "（1オクテット値の配列）"
    },
    {
      "indent": 3,
      "text": "Compression algorithm numbers that indicate which algorithms the key holder prefers to use. Like the preferred symmetric algorithms, the list is ordered. Algorithm numbers are in section 6. If this subpacket is not included, ZIP is preferred. A zero denotes that uncompressed data is preferred; the key holder's software might have no compression software in that implementation. This is only found on a self-signature.",
      "ja": "キー保持者が使用することを好むアルゴリズムかを示す圧縮アルゴリズム番号。好適な対称アルゴリズムと同様に、リストが順序付けられています。このサブパケットが含まれていない場合、アルゴリズム番号がセクション6であり、ZIPが好ましいです。ゼロは、非圧縮データが好ましいことを意味します。キーホルダーのソフトウェアは、その実装には圧縮ソフトを持っていないかもしれません。これが唯一の自己署名に発見されました。"
    },
    {
      "indent": 0,
      "text": "5.2.3.9. Signature expiration time",
      "section_title": true,
      "ja": "5.2.3.9。署名の有効期限"
    },
    {
      "indent": 3,
      "text": "(4 octet time field)",
      "ja": "（4オクテットのタイムフィールド）"
    },
    {
      "indent": 3,
      "text": "The validity period of the signature. This is the number of seconds after the signature creation time that the signature expires. If this is not present or has a value of zero, it never expires.",
      "ja": "署名の有効期間。これは、署名の有効期限が切れた署名の作成時間後の秒数です。これが存在しないか、ゼロの値を持っている場合、それが期限切れになることはありません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.10. Exportable Certification",
      "section_title": true,
      "ja": "5.2.3.10。エクスポート可能な証明"
    },
    {
      "indent": 3,
      "text": "(1 octet of exportability, 0 for not, 1 for exportable)",
      "ja": "（エクスポート可能の1つのオクテット、0ではないため、エクスポートのために1）"
    },
    {
      "indent": 3,
      "text": "This subpacket denotes whether a certification signature is \"exportable\", to be used by other users than the signature's issuer. The packet body contains a boolean flag indicating whether the signature is exportable. If this packet is not present, the certification is exportable; it is equivalent to a flag containing a 1.",
      "ja": "このサブパケットは、認証署名は、署名の発行者以外のユーザーによって使用されるように、「エクスポート」であるかどうかを示しています。パケット本体は、署名がエクスポート可能であるかどうかを示すブールフラグが含ま。このパケットが存在しない場合、証明書はエクスポート可能です。それは1を含むフラグに相当します。"
    },
    {
      "indent": 3,
      "text": "Non-exportable, or \"local\", certifications are signatures made by a user to mark a key as valid within that user's implementation only. Thus, when an implementation prepares a user's copy of a key for transport to another user (this is the process of \"exporting\" the key), any local certification signatures are deleted from the key.",
      "ja": "非エクスポート、または「ローカル」、認定は、そのユーザーの実装内で有効としてキーをマークするために、ユーザによって行われた署名があります。実装は他のユーザーへの輸送のための鍵のユーザーのコピーを準備する際にこのように、（これはキー「エクスポート」のプロセスがある）、任意のローカル認証署名はキーから削除されます。"
    },
    {
      "indent": 3,
      "text": "The receiver of a transported key \"imports\" it, and likewise trims any local certifications. In normal operation, there won't be any, assuming the import is performed on an exported key. However, there are instances where this can reasonably happen. For example, if an implementation allows keys to be imported from a key database in addition to an exported key, then this situation can arise.",
      "ja": "輸送キーの受信機は、「輸入」も、同様に任意のローカル認証をトリミング。通常の動作では、インポート、エクスポートキー上で実行されると仮定すると、いずれかが存在しないであろう。しかし、これは合理的に起こることができる場合があります。実装は、キーがエクスポートキーに加えて、鍵データベースからインポートすることを可能にする場合、例えば、このような状況が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some implementations do not represent the interest of a single user (for example, a key server). Such implementations always trim local certifications from any key they handle.",
      "ja": "いくつかの実装では、（例えば、鍵サーバ）単一のユーザーの関心を表すものではありません。このような実装は、常に彼らが扱う任意のキーからローカル認証をトリミングします。"
    },
    {
      "indent": 0,
      "text": "5.2.3.11. Revocable",
      "section_title": true,
      "ja": "5.2.3.11。取消"
    },
    {
      "indent": 3,
      "text": "(1 octet of revocability, 0 for not, 1 for revocable)",
      "ja": "（取消の1つのオクテット、0ではないため、取り消しのための1）"
    },
    {
      "indent": 3,
      "text": "Signature's revocability status. Packet body contains a boolean flag indicating whether the signature is revocable. Signatures that are not revocable have any later revocation signatures ignored. They represent a commitment by the signer that he cannot revoke his signature for the life of his key. If this packet is not present, the signature is revocable.",
      "ja": "署名の取消状況。パケット本体は、署名が取消可能であるかどうかを示すブールフラグが含ま。取消可能でない署名は無視それ以降の取消し署名を持っています。彼らは、彼が彼のキーの人生のために彼の署名を取り消すことはできません署名者のコミットメントを表しています。このパケットが存在しない場合、署名は取消可能です。"
    },
    {
      "indent": 0,
      "text": "5.2.3.12. Trust signature",
      "section_title": true,
      "ja": "5.2.3.12。トラスト署名"
    },
    {
      "indent": 3,
      "text": "(1 octet \"level\" (depth), 1 octet of trust amount)",
      "ja": "（1つのオクテット「レベル」（深さ）、信頼量の1つのオクテット）"
    },
    {
      "indent": 3,
      "text": "Signer asserts that the key is not only valid, but also trustworthy, at the specified level. Level 0 has the same meaning as an ordinary validity signature. Level 1 means that the signed key is asserted to be a valid trusted introducer, with the 2nd octet of the body specifying the degree of trust. Level 2 means that the signed key is asserted to be trusted to issue level 1 trust signatures, i.e. that it is a \"meta introducer\". Generally, a level n trust signature asserts that a key is trusted to issue level n-1 trust signatures. The trust amount is in a range from 0-255, interpreted such that values less than 120 indicate partial trust and values of 120 or greater indicate complete trust. Implementations SHOULD emit values of 60 for partial trust and 120 for complete trust.",
      "ja": "署名者は、鍵が指定されたレベルで、有効なだけでなく、信頼できるだけではないと主張しています。レベル0は、通常の有効署名と同じ意味を持ちます。レベル1は、署名されたキーは、信頼の度合いを指定し、本体の第二オクテットで、有効な信頼できる紹介者であることをアサートされていることを意味します。レベル2は、署名されたキーは、それが「メタイントロデューサ」である、すなわちことを、レベル1信頼署名を発行するために、信頼されるようにアサートされることを意味します。一般的に、レベルnの信頼署名鍵は、レベルn-1の信頼シグネチャを発行する信頼されていると主張しています。信頼量が0〜255の範囲であり、値は120未満が部分的に信頼を示し、120以上の値が完全な信頼を示すように解釈されます。実装は、完全な信頼のための部分的な信頼と120のために60の値を発するべきです。"
    },
    {
      "indent": 0,
      "text": "5.2.3.13. Regular expression",
      "section_title": true,
      "ja": "5.2.3.13。正規表現"
    },
    {
      "indent": 3,
      "text": "(null-terminated regular expression)",
      "ja": "（nullで終わる正規表現）"
    },
    {
      "indent": 3,
      "text": "Used in conjunction with trust signature packets (of level > 0) to limit the scope of trust that is extended. Only signatures by the target key on user IDs that match the regular expression in the body of this packet have trust extended by the trust signature subpacket. The regular expression uses the same syntax as the Henry Spencer's \"almost public domain\" regular expression package. A description of the syntax is found in a section below.",
      "ja": "拡張された信頼の範囲を限定する（レベル> 0の）信頼署名パケットと共に使用。このパケットの体内での正規表現に一致するユーザーIDのターゲット・キーによってのみ署名が信頼は信頼署名サブパケットで拡張しました。正規表現はHenry Spencerの「ほとんどパブリックドメイン」正規表現のパッケージと同じ構文を使用しています。構文の説明は以下のセクションに見られます。"
    },
    {
      "indent": 0,
      "text": "5.2.3.14. Revocation key",
      "section_title": true,
      "ja": "5.2.3.14。失効キー"
    },
    {
      "indent": 3,
      "text": "(1 octet of class, 1 octet of algid, 20 octets of fingerprint)",
      "ja": "（クラスの1つのオクテット、algidの1つのオクテット、指紋の20オクテット）"
    },
    {
      "indent": 3,
      "text": "Authorizes the specified key to issue revocation signatures for this key. Class octet must have bit 0x80 set. If the bit 0x40 is set, then this means that the revocation information is sensitive. Other bits are for future expansion to other kinds of authorizations. This is found on a self-signature.",
      "ja": "このキーの失効署名を発行するために、指定されたキーを許可します。クラスオクテットはビット0x80を設定する必要があります。ビットの0x40が設定されている場合、これは、失効情報が敏感であることを意味します。他のビットは、権限の他の種類の将来の拡張のためのものです。これは、自己署名に発見されました。"
    },
    {
      "indent": 3,
      "text": "If the \"sensitive\" flag is set, the keyholder feels this subpacket contains private trust information that describes a real-world sensitive relationship. If this flag is set, implementations SHOULD NOT export this signature to other users except in cases where the data needs to be available: when the signature is being sent to the designated revoker, or when it is accompanied by a revocation signature from that revoker. Note that it may be appropriate to isolate this subpacket within a separate signature so that it is not combined with other subpackets that need to be exported.",
      "ja": "「感受性」フラグが設定されている場合、キーホルダーは、このサブパケットが実世界の敏感な関係を説明し、民間信用情報が含まれて感じています。このフラグが設定されている場合、実装はデータが利用できるようにする必要がある場合場合を除いて、他のユーザーにこの署名をエクスポートしないでください。署名が指定された失効者に送信されている場合、またはそれは、その失効者からの失効署名が添付されている場合。それをエクスポートする必要が他のサブパケットと結合されないように、別々の署名内のこのサブパケットを分離するために適切であり得ることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "5.2.3.15. Notation Data",
      "section_title": true,
      "ja": "5.2.3.15。表記データ"
    },
    {
      "indent": 7,
      "text": "(4 octets of flags, 2 octets of name length (M),\n                    2 octets of value length (N),\n                    M octets of name data,\n                    N octets of value data)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This subpacket describes a \"notation\" on the signature that the issuer wishes to make. The notation has a name and a value, each of which are strings of octets. There may be more than one notation in a signature. Notations can be used for any extension the issuer of the signature cares to make. The \"flags\" field holds four octets of flags.",
      "ja": "このサブパケットは、発行者が行いたい署名の「表記」を記載しています。表記法は、名前とオクテットストリングである各々が値を有します。署名に複数の表記があってもよいです。表記は、署名の発行者が作成する気に任意の拡張子を使用することができます。 「フラグ」フィールドには、フラグの4つのオクテットを保持しています。"
    },
    {
      "indent": 3,
      "text": "All undefined flags MUST be zero. Defined flags are:",
      "ja": "すべての未定義のフラグはゼロでなければなりません。定義されたフラグは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "First octet: 0x80 = human-readable. This note is text, a note\n                    from one person to another, and has no\n                    meaning to software.\nOther octets: none.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.2.3.16. Key server preferences",
      "section_title": true,
      "ja": "5.2.3.16。鍵サーバの環境設定"
    },
    {
      "indent": 3,
      "text": "(N octets of flags)",
      "ja": "（フラグのNオクテット）"
    },
    {
      "indent": 3,
      "text": "This is a list of flags that indicate preferences that the key holder has about how the key is handled on a key server. All undefined flags MUST be zero.",
      "ja": "これは、キー保持者は鍵が鍵サーバ上で処理されるかについて持っていることを選好を示すフラグのリストです。すべての未定義のフラグはゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "First octet: 0x80 = No-modify the key holder requests that this key only be modified or updated by the key holder or an administrator of the key server.",
      "ja": "最初のオクテット：このキーのみ変更または鍵の所有者またはキーサーバーの管理者によって更新されることは0x80 =無修正キーホルダー要求。"
    },
    {
      "indent": 3,
      "text": "This is found only on a self-signature.",
      "ja": "これが唯一の自己署名に発見されました。"
    },
    {
      "indent": 0,
      "text": "5.2.3.17. Preferred key server",
      "section_title": true,
      "ja": "5.2.3.17。優先キーサーバー"
    },
    {
      "indent": 3,
      "text": "(String)",
      "ja": "（文字列）"
    },
    {
      "indent": 3,
      "text": "This is a URL of a key server that the key holder prefers be used for updates. Note that keys with multiple user ids can have a preferred key server for each user id. Note also that since this is a URL, the key server can actually be a copy of the key retrieved by ftp, http, finger, etc.",
      "ja": "これは、キー保持者が更新のために使用することが好む鍵サーバのURLです。複数のユーザIDを持つキーはユーザID毎に優先キーサーバを有することができることに留意されたいです。注意また、そのこれはURLであるため、鍵サーバは、実際など、FTP、HTTP、指で取り出されたキーのコピーをすることができ"
    },
    {
      "indent": 0,
      "text": "5.2.3.18. Primary user id",
      "section_title": true,
      "ja": "5.2.3.18。プライマリユーザID"
    },
    {
      "indent": 3,
      "text": "(1 octet, boolean)",
      "ja": "（1つのオクテット、ブール値）"
    },
    {
      "indent": 3,
      "text": "This is a flag in a user id's self signature that states whether this user id is the main user id for this key. It is reasonable for an implementation to resolve ambiguities in preferences, etc. by referring to the primary user id. If this flag is absent, its value is zero. If more than one user id in a key is marked as primary, the implementation may resolve the ambiguity in any way it sees fit.",
      "ja": "これは、このユーザIDは、このキーのための主要なユーザIDであるか否かを述べてユーザIDの自己署名にフラグです。実装は、プライマリユーザIDを参照することによって等好みに曖昧さを解消することが合理的です。このフラグが存在しない場合、その値はゼロです。キーに複数のユーザIDをプライマリとしてマークされている場合、実装は、それが適当と考えるどのような方法であいまいさを解決することができます。"
    },
    {
      "indent": 0,
      "text": "5.2.3.19. Policy URL",
      "section_title": true,
      "ja": "5.2.3.19。ポリシーURL"
    },
    {
      "indent": 3,
      "text": "(String)",
      "ja": "（文字列）"
    },
    {
      "indent": 3,
      "text": "This subpacket contains a URL of a document that describes the policy that the signature was issued under.",
      "ja": "このサブパケットは、署名が下に発行されたポリシーを記述した文書のURLが含まれています。"
    },
    {
      "indent": 0,
      "text": "5.2.3.20. Key Flags",
      "section_title": true,
      "ja": "5.2.3.20。キーフラグ"
    },
    {
      "indent": 3,
      "text": "(Octet string)",
      "ja": "（オクテット文字列）"
    },
    {
      "indent": 3,
      "text": "This subpacket contains a list of binary flags that hold information about a key. It is a string of octets, and an implementation MUST NOT assume a fixed size. This is so it can grow over time. If a list is shorter than an implementation expects, the unstated flags are considered to be zero. The defined flags are:",
      "ja": "このサブパケットは、鍵に関する情報を保持するバイナリフラグのリストが含まれています。これは、オクテットの文字列で、実装は、固定サイズを仮定してはいけません。それは時間をかけて成長できるようにするためです。リストには、実装が期待するよりも短い場合、暗黙のフラグがゼロであると考えられています。定義されたフラグは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "First octet:",
      "ja": "最初のオクテット："
    },
    {
      "indent": 7,
      "text": "0x01 - This key may be used to certify other keys.",
      "ja": "0x01の - このキーは他のキーを証明するために使用することができます。"
    },
    {
      "indent": 7,
      "text": "0x02 - This key may be used to sign data.",
      "ja": "0×02  - このキーは、データに署名するために使用することができます。"
    },
    {
      "indent": 7,
      "text": "0x04 - This key may be used to encrypt communications.",
      "ja": "0x04を - このキーは、通信を暗号化するために使用することができます。"
    },
    {
      "indent": 7,
      "text": "0x08 - This key may be used to encrypt storage.",
      "ja": "0x08に - このキーは、ストレージを暗号化するために使用することができます。"
    },
    {
      "indent": 7,
      "text": "0x10 - The private component of this key may have been split by a secret-sharing mechanism.",
      "ja": "0x10の - このキーのプライベートコンポーネントは、秘密共有メカニズムによって分割された可能性があります。"
    },
    {
      "indent": 7,
      "text": "0x80 - The private component of this key may be in the possession of more than one person.",
      "ja": "0x80  - このキーのプライベートコンポーネントは、複数の人の所有物であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Usage notes:",
      "ja": "使用上の注意："
    },
    {
      "indent": 3,
      "text": "The flags in this packet may appear in self-signatures or in certification signatures. They mean different things depending on who is making the statement -- for example, a certification signature that has the \"sign data\" flag is stating that the certification is for that use. On the other hand, the \"communications encryption\" flag in a self-signature is stating a preference that a given key be used for communications. Note however, that it is a thorny issue to determine what is \"communications\" and what is \"storage.\" This decision is left wholly up to the implementation; the authors of this document do not claim any special wisdom on the issue, and realize that accepted opinion may change.",
      "ja": "このパケットのフラグは、自己署名または証明書の署名に表示される場合があります。彼らは声明を作っている人によって異なるものを意味する - 例えば、「符号データ」フラグを持つ認証署名は、認証がその使用のためのものであることを述べています。一方、自己署名における「通信暗号化」フラグが指定された鍵が通信に用いる嗜好を述べています。 「コミュニケーション」とは何か、何であるかを判断する厄介な問題であることは注意してください「ストレージ」。この決定は、完全実装に任されています。本書の著者は問題に特別な知恵を主張し、受け入れられた意見は変更される可能性があることに気付いていません。"
    },
    {
      "indent": 3,
      "text": "The \"split key\" (0x10) and \"group key\" (0x80) flags are placed on a self-signature only; they are meaningless on a certification signature. They SHOULD be placed only on a direct-key signature (type 0x1f) or a subkey signature (type 0x18), one that refers to the key the flag applies to.",
      "ja": "「分割鍵」（0×10）及び「グループキー」（0x80の）フラグは、自己署名上に配置されています。彼らは、認証、署名の意味がありません。彼らは直接鍵署名（タイプ0x1Fの）またはサブキー署名（タイプ0x18の）、フラグが適用されるキーを指す一方に配置されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.2.3.21. Signer's User ID",
      "section_title": true,
      "ja": "5.2.3.21。署名者のユーザーID"
    },
    {
      "indent": 3,
      "text": "This subpacket allows a keyholder to state which user id is responsible for the signing. Many keyholders use a single key for different purposes, such as business communications as well as personal communications. This subpacket allows such a keyholder to state which of their roles is making a signature.",
      "ja": "このサブパケットは、ユーザーID、署名のために責任がある状態にキーホルダーを可能にします。多くのキーホルダーは、このようなビジネスコミュニケーションだけでなく、個人的なコミュニケーションなど、さまざまな目的のために、単一のキーを使用します。このサブパケットは、署名を行っている役割の状態にそのようなキーホルダーを可能にします。"
    },
    {
      "indent": 0,
      "text": "5.2.3.22. Reason for Revocation",
      "section_title": true,
      "ja": "5.2.3.22。失効の理由"
    },
    {
      "indent": 3,
      "text": "(1 octet of revocation code, N octets of reason string)",
      "ja": "（失効コードの1つのオクテット、理由文字列のNオクテット）"
    },
    {
      "indent": 3,
      "text": "This subpacket is used only in key revocation and certification revocation signatures. It describes the reason why the key or certificate was revoked.",
      "ja": "このサブパケットは、唯一の鍵の失効と証明書の失効署名に使用されています。これは、キーまたは証明書が失効した理由を説明しています。"
    },
    {
      "indent": 3,
      "text": "The first octet contains a machine-readable code that denotes the reason for the revocation:",
      "ja": "最初のオクテットは取り消しの理由を表す機械可読コードが含まれています。"
    },
    {
      "indent": 7,
      "text": "0x00 - No reason specified (key revocations or cert revocations)\n0x01 - Key is superceded (key revocations)\n0x02 - Key material has been compromised (key revocations)\n0x03 - Key is no longer used (key revocations)\n0x20 - User id information is no longer valid (cert revocations)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Following the revocation code is a string of octets which gives information about the reason for revocation in human-readable form (UTF-8). The string may be null, that is, of zero length. The length of the subpacket is the length of the reason string plus one.",
      "ja": "人間が読める形式（UTF-8）で失効の理由に関する情報を提供オクテットの文字列が失効コードを以下に示します。文字列は、長さがゼロの、すなわち、ヌルであってもよいです。サブパケットの長さは、理由文字列に1を足した長さです。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Computing Signatures",
      "section_title": true,
      "ja": "5.2.4。コンピューティング署名"
    },
    {
      "indent": 3,
      "text": "All signatures are formed by producing a hash over the signature data, and then using the resulting hash in the signature algorithm.",
      "ja": "すべての署名は、署名データに対するハッシュを生成し、次に署名アルゴリズムで得られたハッシュを使用して形成されています。"
    },
    {
      "indent": 3,
      "text": "The signature data is simple to compute for document signatures (types 0x00 and 0x01), for which the document itself is the data. For standalone signatures, this is a null string.",
      "ja": "署名データは、文書自体がデータであるため文書署名（タイプ0x00から0x01の）のための計算が簡単です。スタンドアロンの署名については、これはヌル文字列です。"
    },
    {
      "indent": 3,
      "text": "When a signature is made over a key, the hash data starts with the octet 0x99, followed by a two-octet length of the key, and then body of the key packet. (Note that this is an old-style packet header for a key packet with two-octet length.) A subkey signature (type 0x18) then hashes the subkey, using the same format as the main key. Key revocation signatures (types 0x20 and 0x28) hash only the key being revoked.",
      "ja": "署名はキー上に形成されている場合、ハッシュデータは、2オクテットのキーの長さ、およびキーパケットの次に本体続い、オクテット0x99で始まります。 （これは2オクテット長のキーパケットの旧式のパケットヘッダであることに留意されたい。）サブキー署名（タイプ0x18の）は、メインキーと同じ形式を使用して、サブキーをハッシュ。鍵無効化署名（種類は0x20との0x28）取り消されているハッシュキーだけ。"
    },
    {
      "indent": 3,
      "text": "A certification signature (type 0x10 through 0x13) hashes the user id being bound to the key into the hash context after the above data. A V3 certification hashes the contents of the name packet, without any header. A V4 certification hashes the constant 0xb4 (which is an old-style packet header with the length-of-length set to zero), a four-octet number giving the length of the username, and then the username data.",
      "ja": "認証署名（0x13にスルー型の0x10）は、上記データの後ハッシュコンテキストにキーにバインドされたユーザIDをハッシュ。 V3認証は、任意のヘッダなしで、名前パケットの内容をハッシュ。 V4認証は（長さの長さがゼロに設定され、古いスタイルのパケットヘッダである）定数0xb4、ユーザ名の長さを与える4オクテットの数、及びその後ユーザ名データをハッシュ。"
    },
    {
      "indent": 3,
      "text": "Once the data body is hashed, then a trailer is hashed. A V3 signature hashes five octets of the packet body, starting from the signature type field. This data is the signature type, followed by the four-octet signature time. A V4 signature hashes the packet body starting from its first field, the version number, through the end of the hashed subpacket data. Thus, the fields hashed are the signature version, the signature type, the public key algorithm, the hash algorithm, the hashed subpacket length, and the hashed subpacket body.",
      "ja": "データ本体がハッシュされると、その後、トレーラがハッシュされます。 V3署名は、署名タイプフィールドから開始して、パケットボディの5つのオクテットをハッシュ。このデータは、4オクテット署名時間に続いて、署名タイプ、です。 V4署名はハッシュサブパケットデータの最後まで、その最初のフィールドから始まるパケットボディ、バージョン番号をハッシュ。したがって、ハッシュのフィールドは、署名バージョン、署名タイプ、公開鍵アルゴリズム、ハッシュアルゴリズム、ハッシュ化されたサブパケットの長さ、およびハッシュサブパケット体です。"
    },
    {
      "indent": 3,
      "text": "V4 signatures also hash in a final trailer of six octets: the version of the signature packet, i.e. 0x04; 0xFF; a four-octet, big-endian number that is the length of the hashed data from the signature packet (note that this number does not include these final six octets.",
      "ja": "すなわち0x04の、署名パケットのバージョン; V4署名も6つのオクテットの最終トレーラー内のハッシュ0xFFを、署名パケットからハッシュデータの長さ4オクテット、ビッグエンディアン数（この数は、これらの最後の6つのオクテットを含んでいないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "After all this has been hashed, the resulting hash field is used in the signature algorithm, and placed at the end of the signature packet.",
      "ja": "すべてこれはハッシュされた後、結果として得られるハッシュフィールドが署名アルゴリズムで使用され、署名パケットの末尾に配置されています。"
    },
    {
      "indent": 0,
      "text": "5.2.4.1. Subpacket Hints",
      "section_title": true,
      "ja": "5.2.4.1。サブパケットのヒント"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD put the two mandatory subpackets, creation time and issuer, as the first subpackets in the subpacket list, simply to make it easier for the implementer to find them.",
      "ja": "実装は単にそれが簡単に実装者はそれらを見つけるできるようにすること、サブパケットリストの最初のサブパケットとして、2つの必須サブパケット、作成時間や発行者を置く必要があります。"
    },
    {
      "indent": 3,
      "text": "It is certainly possible for a signature to contain conflicting information in subpackets. For example, a signature may contain multiple copies of a preference or multiple expiration times. In most cases, an implementation SHOULD use the last subpacket in the signature, but MAY use any conflict resolution scheme that makes more sense. Please note that we are intentionally leaving conflict resolution to the implementer; most conflicts are simply syntax errors, and the wishy-washy language here allows a receiver to be generous in what they accept, while putting pressure on a creator to be stingy in what they generate.",
      "ja": "署名はサブパケットに矛盾する情報が含まれていることが確かに可能です。例えば、署名は、嗜好又は複数の有効期限の複数のコピーを含んでいてもよいです。ほとんどの場合、実装は署名で最後のサブパケットを使用すべきであるが、より理にかなって任意の紛争解決方式を使用することができます。我々は意図的に実装に紛争解決を残していることに注意してください。ほとんどの競合は、単に構文エラーがあり、作成者に圧力をかけてすることは、彼らが生成するものでけちことながら、ここにwishy-washy言語は、受信機は、彼らが受け入れるものに寛大にすることができます。"
    },
    {
      "indent": 3,
      "text": "Some apparent conflicts may actually make sense -- for example, suppose a keyholder has an V3 key and a V4 key that share the same RSA key material. Either of these keys can verify a signature created by the other, and it may be reasonable for a signature to contain an issuer subpacket for each key, as a way of explicitly tying those keys to the signature.",
      "ja": "いくつかの明白な矛盾が実際に意味をなすこと - たとえば、キーホルダーがV3キーと同じRSA鍵材料を共有V4キーを持っているとします。これらのキーのいずれかが他方によって作成された署名を検証することができ、そして署名が明示的に署名にこれらのキーを結ぶの方法として、各キーの発行者のサブパケットを含むことが合理的であってもよいです。"
    },
    {
      "indent": 0,
      "text": "5.3. Symmetric-Key Encrypted Session-Key Packets (Tag 3)",
      "section_title": true,
      "ja": "5.3。共通鍵暗号化されたセッションキーパケット（タグ3）"
    },
    {
      "indent": 3,
      "text": "The Symmetric-Key Encrypted Session Key packet holds the symmetric-key encryption of a session key used to encrypt a message. Zero or more Encrypted Session Key packets and/or Symmetric-Key Encrypted Session Key packets may precede a Symmetrically Encrypted Data Packet that holds an encrypted message. The message is encrypted with a session key, and the session key is itself encrypted and stored in the Encrypted Session Key packet or the Symmetric-Key Encrypted Session Key packet.",
      "ja": "共通鍵暗号化されたセッション鍵パケットは、メッセージを暗号化するために使用されるセッションキーの対称鍵暗号を保持しています。ゼロまたはそれ以上の暗号化されたセッション鍵パケットおよび/または共通鍵暗号化されたセッション鍵パケットは暗号化されたメッセージを保持して対称的に暗号化データパケットに先行していてもよいです。メッセージは、セッション鍵で暗号化され、セッション鍵自体が暗号化されたセッションキーパケットや共通鍵暗号化されたセッションキーパケットに暗号化して保存されます。"
    },
    {
      "indent": 3,
      "text": "If the Symmetrically Encrypted Data Packet is preceded by one or more Symmetric-Key Encrypted Session Key packets, each specifies a passphrase that may be used to decrypt the message. This allows a message to be encrypted to a number of public keys, and also to one or more pass phrases. This packet type is new, and is not generated by PGP 2.x or PGP 5.0.",
      "ja": "対称的に暗号化データパケットが一つ以上の対称キー暗号化セッション鍵パケットが先行する場合、それぞれがメッセージを解読するために使用することができるパスフレーズを指定します。これは、メッセージが公開鍵の数に、また一つ以上のパスフレーズに暗号化することができます。このパケットタイプは新しく、PGP 2.xまたはPGP 5.0によって生成されていません。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットのボディはで構成されています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet version number. The only currently defined version is 4.",
      "ja": " -  1オクテットのバージョン番号。唯一の現在定義されているバージョンは4です。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number describing the symmetric algorithm used.",
      "ja": " - 使用される対称アルゴリズムを説明する1オクテットの数。"
    },
    {
      "indent": 5,
      "text": "- A string-to-key (S2K) specifier, length as defined above.",
      "ja": " - 上記で定義された文字列・ツー・キー（S2K）指定子、長さ。"
    },
    {
      "indent": 5,
      "text": "- Optionally, the encrypted session key itself, which is decrypted with the string-to-key object.",
      "ja": " - 必要に応じて、文字列のキーオブジェクトで復号する暗号化されたセッション鍵自体、。"
    },
    {
      "indent": 3,
      "text": "If the encrypted session key is not present (which can be detected on the basis of packet length and S2K specifier size), then the S2K algorithm applied to the passphrase produces the session key for decrypting the file, using the symmetric cipher algorithm from the Symmetric-Key Encrypted Session Key packet.",
      "ja": "暗号化されたセッション鍵は、（パケット長とS2K指定子サイズに基づいて検出することができる）が存在しない場合は、S2Kアルゴリズムは、パスフレーズに適用対称の対称暗号化アルゴリズムを使用して、ファイルを解読するためのセッションキーを生成します暗号化されたセッション鍵パケット-key。"
    },
    {
      "indent": 3,
      "text": "If the encrypted session key is present, the result of applying the S2K algorithm to the passphrase is used to decrypt just that encrypted session key field, using CFB mode with an IV of all zeros. The decryption result consists of a one-octet algorithm identifier that specifies the symmetric-key encryption algorithm used to encrypt the following Symmetrically Encrypted Data Packet, followed by the session key octets themselves.",
      "ja": "暗号化されたセッションキーが存在する場合は、パスフレーズにS2Kアルゴリズムを適用した結果は、すべてゼロのIVとCFBモードを使用して、ちょうどその暗号化されたセッションキーフィールドを復号化するために使用されます。復号結果は、セッションキーオクテット自身が続く次対称的に暗号化データパケットを暗号化するために使用される対称鍵暗号化アルゴリズムを指定する1オクテットのアルゴリズム識別子で構成されています。"
    },
    {
      "indent": 3,
      "text": "Note: because an all-zero IV is used for this decryption, the S2K specifier MUST use a salt value, either a Salted S2K or an Iterated-Salted S2K. The salt value will insure that the decryption key is not repeated even if the passphrase is reused.",
      "ja": "注：全てゼロIVは、この復号化に使用されているので、S2K指定子は塩漬けS2Kまたは反復-塩漬けS2Kのいずれか、塩の値を使用しなければなりません。ソルト値は、復号鍵は、パスフレーズが再利用されている場合でも繰り返されないことを保証します。"
    },
    {
      "indent": 0,
      "text": "5.4. One-Pass Signature Packets (Tag 4)",
      "section_title": true,
      "ja": "5.4。ワンパス署名パケット（タグ4）"
    },
    {
      "indent": 3,
      "text": "The One-Pass Signature packet precedes the signed data and contains enough information to allow the receiver to begin calculating any hashes needed to verify the signature. It allows the Signature Packet to be placed at the end of the message, so that the signer can compute the entire signed message in one pass.",
      "ja": "ワンパス署名パケットは、署名されたデータに先行し、受信機は、署名を検証するために必要なハッシュを計算することを開始することを可能にするのに十分な情報を含んでいます。署名者は、ワンパスで全署名されたメッセージを計算することができるように、それは、署名パケットは、メッセージの最後に配置されることを可能にします。"
    },
    {
      "indent": 3,
      "text": "A One-Pass Signature does not interoperate with PGP 2.6.x or earlier.",
      "ja": "ワンパス署名は、PGP 2.6.xでは以前との相互運用性はありません。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットのボディはで構成されています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet version number. The current version is 3.",
      "ja": " -  1オクテットのバージョン番号。現在のバージョンは3です。"
    },
    {
      "indent": 5,
      "text": "- A one-octet signature type. Signature types are described in section 5.2.1.",
      "ja": " -  1オクテット署名タイプ。署名タイプは、セクション5.2.1に記載されています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number describing the hash algorithm used.",
      "ja": " - 使用されるハッシュアルゴリズムを説明する1オクテットの数。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number describing the public key algorithm used.",
      "ja": " - 使用される公開鍵アルゴリズムを説明する1オクテットの数。"
    },
    {
      "indent": 5,
      "text": "- An eight-octet number holding the key ID of the signing key.",
      "ja": " - 署名キーのキーIDを保持する8オクテットの数。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number holding a flag showing whether the signature is nested. A zero value indicates that the next packet is another One-Pass Signature packet that describes another signature to be applied to the same message data.",
      "ja": " - 署名がネストされているかどうかを示すフラグを保持する1オクテットの数。ゼロ値は、次のパケットが同じメッセージデータに適用される別の署名を記述する別のワンパス署名パケットであることを示しています。"
    },
    {
      "indent": 3,
      "text": "Note that if a message contains more than one one-pass signature, then the signature packets bracket the message; that is, the first signature packet after the message corresponds to the last one-pass packet and the final signature packet corresponds to the first one-pass packet.",
      "ja": "メッセージが複数のワンパス署名を含む場合、署名パケットはメッセージを囲むことに注意してください。つまり、メッセージの後の最初の署名パケットは、最後のパスのパケットに対応し、最終的な署名パケットは、最初のパスのパケットに相当します。"
    },
    {
      "indent": 0,
      "text": "5.5. Key Material Packet",
      "section_title": true,
      "ja": "5.5。鍵データパケット"
    },
    {
      "indent": 3,
      "text": "A key material packet contains all the information about a public or private key. There are four variants of this packet type, and two major versions. Consequently, this section is complex.",
      "ja": "キー材料パケットは、パブリックまたはプライベートキーに関するすべての情報が含まれています。このパケットタイプの4つの変異体、および2つのメジャーバージョンがあります。したがって、このセクションでは、複雑です。"
    },
    {
      "indent": 0,
      "text": "5.5.1. Key Packet Variants",
      "section_title": true,
      "ja": "5.5.1。キーパケットバリアント"
    },
    {
      "indent": 0,
      "text": "5.5.1.1. Public Key Packet (Tag 6)",
      "section_title": true,
      "ja": "5.5.1.1。公開鍵パケット（タグ6）"
    },
    {
      "indent": 3,
      "text": "A Public Key packet starts a series of packets that forms an OpenPGP key (sometimes called an OpenPGP certificate).",
      "ja": "公開鍵パケットは、OpenPGPのキーを（時にはのOpenPGP証明書と呼ばれる）を形成する一連のパケットを開始します。"
    },
    {
      "indent": 0,
      "text": "5.5.1.2. Public Subkey Packet (Tag 14)",
      "section_title": true,
      "ja": "5.5.1.2。公共のサブキーパケット（タグ14）"
    },
    {
      "indent": 3,
      "text": "A Public Subkey packet (tag 14) has exactly the same format as a Public Key packet, but denotes a subkey. One or more subkeys may be associated with a top-level key. By convention, the top-level key provides signature services, and the subkeys provide encryption services.",
      "ja": "公共のサブキーパケット（タグ14）は、公開鍵パケットとまったく同じ形式を持っていますが、サブキーを表します。一つ以上のサブキーは、トップレベルの鍵に関連付けることができます。慣例により、トップレベルのキーは、署名サービスを提供し、サブキーは、暗号化サービスを提供しています。"
    },
    {
      "indent": 3,
      "text": "Note: in PGP 2.6.x, tag 14 was intended to indicate a comment packet. This tag was selected for reuse because no previous version of PGP ever emitted comment packets but they did properly ignore them. Public Subkey packets are ignored by PGP 2.6.x and do not cause it to fail, providing a limited degree of backward compatibility.",
      "ja": "注意：PGP 2.6.xの中で、タグ14は、コメントパケットを示すことを意図していました。 PGPの以前のバージョンでは、これまでのコメントパケットを放出されないが、彼らは適切にそれらを無視なかったので、このタグは、再利用のために選択しました。公共のサブキーパケットは、PGP 2.6.xではによって無視され、下位互換性の限られた程度を提供し、それが失敗することはありません。"
    },
    {
      "indent": 0,
      "text": "5.5.1.3. Secret Key Packet (Tag 5)",
      "section_title": true,
      "ja": "5.5.1.3。秘密鍵パケット（タグ5）"
    },
    {
      "indent": 3,
      "text": "A Secret Key packet contains all the information that is found in a Public Key packet, including the public key material, but also includes the secret key material after all the public key fields.",
      "ja": "秘密鍵パケットは、公開鍵材料を含む公開鍵パケットで発見されたすべての情報が含まれていますが、また、すべての公開鍵フィールドの後に、秘密鍵の材料を含みます。"
    },
    {
      "indent": 0,
      "text": "5.5.1.4. Secret Subkey Packet (Tag 7)",
      "section_title": true,
      "ja": "5.5.1.4。秘密のサブキーパケット（タグ7）"
    },
    {
      "indent": 3,
      "text": "A Secret Subkey packet (tag 7) is the subkey analog of the Secret Key packet, and has exactly the same format.",
      "ja": "秘密サブキーパケット（タグ7）は、秘密鍵パケットのサブキーアナログであり、全く同じフォーマットを有します。"
    },
    {
      "indent": 0,
      "text": "5.5.2. Public Key Packet Formats",
      "section_title": true,
      "ja": "5.5.2。公開鍵パケット形式"
    },
    {
      "indent": 3,
      "text": "There are two versions of key-material packets. Version 3 packets were first generated by PGP 2.6. Version 2 packets are identical in format to Version 3 packets, but are generated by PGP 2.5 or before. V2 packets are deprecated and they MUST NOT be generated. PGP 5.0 introduced version 4 packets, with new fields and semantics. PGP 2.6.x will not accept key-material packets with versions greater than 3.",
      "ja": "キー材料パケットの2つのバージョンがあります。バージョン3つのパケットは、最初にPGP 2.6によって生成されました。バージョン2つのパケットは、バージョン3つのパケットのフォーマットは同一であるが、PGP 2.5によって以前に生成されます。 V2パケットは廃止され、彼らが生成されてはなりません。 PGP 5.0は、新しいフィールドとセマンティクスを持つバージョン4つのパケットを、導入しました。 PGP 2.6.xでは、3よりも大きいバージョンとキー材料パケットを受け入れません。"
    },
    {
      "indent": 3,
      "text": "OpenPGP implementations SHOULD create keys with version 4 format. An implementation MAY generate a V3 key to ensure interoperability with old software; note, however, that V4 keys correct some security deficiencies in V3 keys. These deficiencies are described below. An implementation MUST NOT create a V3 key with a public key algorithm other than RSA.",
      "ja": "OpenPGPの実装はバージョン4形式のキーを作成する必要があります。実装は、古いソフトウェアとの相互運用性を確保するために、V3キーを生成してもよい（MAY）。しかし、そのV4キーがV3キーでいくつかのセキュリティ上の欠陥を修正し、注意してください。これらの欠陥は、以下に記載されています。実装はRSA以外の公開鍵アルゴリズムとV3キーを作成してはいけません。"
    },
    {
      "indent": 3,
      "text": "A version 3 public key or public subkey packet contains:",
      "ja": "バージョン3の公開鍵または公共のサブキーパケットが含まれています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet version number (3).",
      "ja": " -  1オクテットのバージョン番号（3）。"
    },
    {
      "indent": 5,
      "text": "- A four-octet number denoting the time that the key was created.",
      "ja": " - キーが作成された時間を示す4オクテットの数。"
    },
    {
      "indent": 5,
      "text": "- A two-octet number denoting the time in days that this key is valid. If this number is zero, then it does not expire.",
      "ja": " - このキーが有効であること日数を表す2オクテットの数。この数がゼロの場合、それは有効期限はありません。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number denoting the public key algorithm of this key",
      "ja": " - このキーの公開鍵アルゴリズムを示す1オクテットの数"
    },
    {
      "indent": 5,
      "text": "- A series of multi-precision integers comprising the key material:",
      "ja": " - 鍵材料を含む多倍精度整数の一連。"
    },
    {
      "indent": 9,
      "text": "- a multiprecision integer (MPI) of RSA public modulus n;",
      "ja": " -  RSA公開モジュラスNの多倍精度整数（MPI）。"
    },
    {
      "indent": 9,
      "text": "- an MPI of RSA public encryption exponent e.",
      "ja": " -  RSA公開暗号指数eのMPI。"
    },
    {
      "indent": 3,
      "text": "V3 keys SHOULD only be used for backward compatibility because of three weaknesses in them. First, it is relatively easy to construct a V3 key that has the same key ID as any other key because the key ID is simply the low 64 bits of the public modulus. Secondly, because the fingerprint of a V3 key hashes the key material, but not its length, which increases the opportunity for fingerprint collisions. Third, there are minor weaknesses in the MD5 hash algorithm that make developers prefer other algorithms. See below for a fuller discussion of key IDs and fingerprints.",
      "ja": "V3キーは唯一の理由は、これら三の弱点の下位互換性のために使用されるべきです。まず、鍵IDは、単に公衆率の低い64ビットであるため、他のキーと同じキーIDを持つV3キーを構築することは比較的容易です。第二に、V3キーの指紋が指紋衝突の機会を増大させ、その長さを、キーマテリアルをハッシュではなくので。第三に、開発者が他のアルゴリズムを好む作るMD5ハッシュアルゴリズムではマイナーな弱点があります。鍵IDと指紋のより完全な議論については、以下を参照してください。"
    },
    {
      "indent": 3,
      "text": "The version 4 format is similar to the version 3 format except for the absence of a validity period. This has been moved to the signature packet. In addition, fingerprints of version 4 keys are calculated differently from version 3 keys, as described in section \"Enhanced Key Formats.\"",
      "ja": "バージョン4フォーマットは、有効期間が存在しないことを除いて、バージョン3の形式と同様です。これは、署名パケットに移動されました。セクションで説明したように加えて、バージョン4の鍵の指紋は、バージョン3つのキーとは異なる計算され、「拡張キーフォーマット。」"
    },
    {
      "indent": 3,
      "text": "A version 4 packet contains:",
      "ja": "バージョン4パケットが含まれています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet version number (4).",
      "ja": " -  1オクテットのバージョン番号（4）。"
    },
    {
      "indent": 5,
      "text": "- A four-octet number denoting the time that the key was created.",
      "ja": " - キーが作成された時間を示す4オクテットの数。"
    },
    {
      "indent": 5,
      "text": "- A one-octet number denoting the public key algorithm of this key",
      "ja": " - このキーの公開鍵アルゴリズムを示す1オクテットの数"
    },
    {
      "indent": 5,
      "text": "- A series of multi-precision integers comprising the key material. This algorithm-specific portion is:",
      "ja": " - 鍵材料を含む多倍精度整数の一連。このアルゴリズム固有の部分は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "Algorithm Specific Fields for RSA public keys:",
      "ja": "RSA公開鍵アルゴリズム特定フィールド："
    },
    {
      "indent": 9,
      "text": "- multiprecision integer (MPI) of RSA public modulus n;",
      "ja": " -  RSA公開モジュラスの多倍精度整数（MPI）N。"
    },
    {
      "indent": 9,
      "text": "- MPI of RSA public encryption exponent e.",
      "ja": " -  RSA公開暗号指数eのMPI。"
    },
    {
      "indent": 7,
      "text": "Algorithm Specific Fields for DSA public keys:",
      "ja": "DSA公開鍵のアルゴリズム特定フィールド："
    },
    {
      "indent": 9,
      "text": "- MPI of DSA prime p;",
      "ja": " -  DSA素数pのMPI。"
    },
    {
      "indent": 9,
      "text": "- MPI of DSA group order q (q is a prime divisor of p-1);",
      "ja": " -  DSAグループ次数qのMPI（qはP-1の素数除数です）。"
    },
    {
      "indent": 9,
      "text": "- MPI of DSA group generator g;",
      "ja": " -  DSAグループジェネレータgのMPI。"
    },
    {
      "indent": 9,
      "text": "- MPI of DSA public key value y (= g**x where x is secret).",
      "ja": " -  DSA公開鍵の値yのMPI（= G ** xは秘密であるX）。"
    },
    {
      "indent": 7,
      "text": "Algorithm Specific Fields for Elgamal public keys:",
      "ja": "Elgamal公開キーアルゴリズム特定フィールド："
    },
    {
      "indent": 9,
      "text": "- MPI of Elgamal prime p;",
      "ja": " - はElgamal素数pのMPI。"
    },
    {
      "indent": 9,
      "text": "- MPI of Elgamal group generator g;",
      "ja": " - エルガマル群ジェネレータgのMPI。"
    },
    {
      "indent": 9,
      "text": "- MPI of Elgamal public key value y (= g**x where x is secret).",
      "ja": " - はElgamal公開鍵の値yのMPI（= G ** xは秘密であるX）。"
    },
    {
      "indent": 0,
      "text": "5.5.3. Secret Key Packet Formats",
      "section_title": true,
      "ja": "5.5.3。秘密鍵パケットフォーマット"
    },
    {
      "indent": 3,
      "text": "The Secret Key and Secret Subkey packets contain all the data of the Public Key and Public Subkey packets, with additional algorithm-specific secret key data appended, in encrypted form.",
      "ja": "秘密鍵と秘密のサブキーパケットは暗号化された形式で追加追加のアルゴリズム固有の秘密鍵データと、公開鍵と公開サブキーパケットのすべてのデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "The packet contains:",
      "ja": "パケットが含まれています："
    },
    {
      "indent": 5,
      "text": "- A Public Key or Public Subkey packet, as described above",
      "ja": " - 公開鍵または公開サブキーパケットは、上述したように"
    },
    {
      "indent": 5,
      "text": "- One octet indicating string-to-key usage conventions. 0 indicates that the secret key data is not encrypted. 255 indicates that a string-to-key specifier is being given. Any other value is a symmetric-key encryption algorithm specifier.",
      "ja": " - 文字列からキーへの使用規則を示す1つのオクテット。 0は、秘密鍵データが暗号化されていないことを示しています。 255は、文字列・ツー・キー指定が与えられていることを示しています。その他の値は、対称鍵暗号アルゴリズムの指定子です。"
    },
    {
      "indent": 5,
      "text": "- [Optional] If string-to-key usage octet was 255, a one-octet symmetric encryption algorithm.",
      "ja": " - 文字列からキーへの用法のオクテットは、1オクテット対称暗号化アルゴリズム255だった場合、[オプション]。"
    },
    {
      "indent": 5,
      "text": "- [Optional] If string-to-key usage octet was 255, a string-to-key specifier. The length of the string-to-key specifier is implied by its type, as described above.",
      "ja": " - 文字列からキーへの用法のオクテットは、文字列・ツー・キー指定255だった場合は、[オプション]。上記のように、文字列・ツー・キー指定の長さは、そのタイプによって暗示されています。"
    },
    {
      "indent": 5,
      "text": "- [Optional] If secret data is encrypted, eight-octet Initial Vector (IV).",
      "ja": " -  [オプション]秘密のデータが暗号化されている場合、8オクテットの初期ベクトル（IV）。"
    },
    {
      "indent": 5,
      "text": "- Encrypted multi-precision integers comprising the secret key data. These algorithm-specific fields are as described below.",
      "ja": " - 秘密鍵データを含む多精度の整数を暗号化。これらのアルゴリズム固有のフィールドは以下のように説明されています。"
    },
    {
      "indent": 5,
      "text": "- Two-octet checksum of the plaintext of the algorithm-specific portion (sum of all octets, mod 65536).",
      "ja": " - アルゴリズム特定部分の平文の2オクテットのチェックサム（すべてのオクテットの和、MOD 65536）。"
    },
    {
      "indent": 7,
      "text": "Algorithm Specific Fields for RSA secret keys:",
      "ja": "RSA秘密鍵のためのアルゴリズム特定フィールド："
    },
    {
      "indent": 7,
      "text": "- multiprecision integer (MPI) of RSA secret exponent d.",
      "ja": " -  RSA秘密指数dの多倍精度整数（MPI）。"
    },
    {
      "indent": 7,
      "text": "- MPI of RSA secret prime value p.",
      "ja": " -  RSA秘密プライム値pのMPI。"
    },
    {
      "indent": 7,
      "text": "- MPI of RSA secret prime value q (p < q).",
      "ja": " -  RSAのMPI秘密プライム値Q（P <Q）。"
    },
    {
      "indent": 7,
      "text": "- MPI of u, the multiplicative inverse of p, mod q.",
      "ja": " -  UのMPI、Pの逆数、モッズQ。"
    },
    {
      "indent": 7,
      "text": "Algorithm Specific Fields for DSA secret keys:",
      "ja": "DSA秘密鍵のためのアルゴリズム特定フィールド："
    },
    {
      "indent": 7,
      "text": "- MPI of DSA secret exponent x.",
      "ja": " -  DSA秘密指数xのMPI。"
    },
    {
      "indent": 7,
      "text": "Algorithm Specific Fields for Elgamal secret keys:",
      "ja": "エルガマル秘密鍵のためのアルゴリズム特定フィールド："
    },
    {
      "indent": 7,
      "text": "- MPI of Elgamal secret exponent x.",
      "ja": " - はElgamal秘密指数xのMPI。"
    },
    {
      "indent": 3,
      "text": "Secret MPI values can be encrypted using a passphrase. If a string-to-key specifier is given, that describes the algorithm for converting the passphrase to a key, else a simple MD5 hash of the passphrase is used. Implementations SHOULD use a string-to-key specifier; the simple hash is for backward compatibility. The cipher for encrypting the MPIs is specified in the secret key packet.",
      "ja": "秘密のMPI値は、パスフレーズを使用して暗号化することができます。文字列のキー指定子が与えられた場合、それがキーにパスフレーズを変換するためのアルゴリズムを説明し、パスフレーズの他に、単純なMD5ハッシュが使用されています。実装は、文字列・ツー・キー指定を使用する必要があります。簡単なハッシュは、下位互換性のためです。 MPIを暗号化するための暗号は秘密鍵パケットに指定されています。"
    },
    {
      "indent": 3,
      "text": "Encryption/decryption of the secret data is done in CFB mode using the key created from the passphrase and the Initial Vector from the packet. A different mode is used with V3 keys (which are only RSA) than with other key formats. With V3 keys, the MPI bit count prefix (i.e., the first two octets) is not encrypted. Only the MPI non-prefix data is encrypted. Furthermore, the CFB state is resynchronized at the beginning of each new MPI value, so that the CFB block boundary is aligned with the start of the MPI data.",
      "ja": "機密データの暗号化/復号化は、パスフレーズとパケットから初期ベクトルから作成したキーを使用してCFBモードで実行されます。異なるモードは、他のキーのフォーマットよりも（のみRSAある）V3キーと共に使用されます。 V3キーで、MPIビットカウントプレフィックス（すなわち、最初の2つのオクテット）が暗号化されていません。唯一のMPI非プレフィックスデータが暗号化されています。 CFBブロック境界がMPIデータの開始と整合されるように、さらに、CFB状態は、それぞれの新しいMPI値の先頭に再同期されます。"
    },
    {
      "indent": 3,
      "text": "With V4 keys, a simpler method is used. All secret MPI values are encrypted in CFB mode, including the MPI bitcount prefix.",
      "ja": "V4キーで、より簡単な方法が使用されています。すべての秘密のMPI値は、MPIのBITCOUNTのプレフィックスを含む、CFBモードで暗号化されています。"
    },
    {
      "indent": 3,
      "text": "The 16-bit checksum that follows the algorithm-specific portion is the algebraic sum, mod 65536, of the plaintext of all the algorithm-specific octets (including MPI prefix and data). With V3 keys, the checksum is stored in the clear. With V4 keys, the checksum is encrypted like the algorithm-specific data. This value is used to check that the passphrase was correct.",
      "ja": "アルゴリズム特定部分に続く16ビットのチェックサムは、（MPIプレフィックスとデータを含む）すべてのアルゴリズム特定のオクテットの平文の代数和、MOD 65536、です。 V3キーを使用すると、チェックサムが明確に格納されます。 V4キーで、チェックサムは、アルゴリズム固有のデータのように暗号化されています。この値は、パスフレーズが正しかったことを確認するために使用されます。"
    },
    {
      "indent": 0,
      "text": "5.6. Compressed Data Packet (Tag 8)",
      "section_title": true,
      "ja": "5.6。圧縮されたデータパケット（タグ8）"
    },
    {
      "indent": 3,
      "text": "The Compressed Data packet contains compressed data. Typically, this packet is found as the contents of an encrypted packet, or following a Signature or One-Pass Signature packet, and contains literal data packets.",
      "ja": "圧縮データパケットは、圧縮されたデータが含まれています。典型的には、このパケットは、暗号化されたパケットの内容として見出され、または署名またはワンパス署名パケットに続く、およびリテラルデータパケットを含んでいます。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットのボディはで構成されています。"
    },
    {
      "indent": 5,
      "text": "- One octet that gives the algorithm used to compress the packet.",
      "ja": " - パケットを圧縮するために使用されるアルゴリズムを与える一つのオクテット。"
    },
    {
      "indent": 5,
      "text": "- The remainder of the packet is compressed data.",
      "ja": " - パケットの残りの部分は、圧縮されたデータです。"
    },
    {
      "indent": 3,
      "text": "A Compressed Data Packet's body contains an block that compresses some set of packets. See section \"Packet Composition\" for details on how messages are formed.",
      "ja": "圧縮されたデータパケットの体は、パケットのいくつかのセットを圧縮ブロックが含まれています。メッセージが形成されている方法の詳細については、「パケット構成」を参照してください。"
    },
    {
      "indent": 3,
      "text": "ZIP-compressed packets are compressed with raw RFC 1951 DEFLATE blocks. Note that PGP V2.6 uses 13 bits of compression. If an implementation uses more bits of compression, PGP V2.6 cannot decompress it.",
      "ja": "ZIP圧縮されたパケットは、生のRFC 1951 DEFLATEブロックで圧縮されています。 PGP V2.6圧縮の13ビットを使用することに留意されたいです。実装は圧縮のより多くのビットを使用している場合は、PGPのV2.6は、それを解凍することはできません。"
    },
    {
      "indent": 3,
      "text": "ZLIB-compressed packets are compressed with RFC 1950 ZLIB-style blocks.",
      "ja": "ZLIB-圧縮されたパケットは、RFC 1950 ZLIBスタイルのブロックで圧縮されています。"
    },
    {
      "indent": 0,
      "text": "5.7. Symmetrically Encrypted Data Packet (Tag 9)",
      "section_title": true,
      "ja": "5.7。対称的に暗号化データ・パケット（タグ9）"
    },
    {
      "indent": 3,
      "text": "The Symmetrically Encrypted Data packet contains data encrypted with a symmetric-key algorithm. When it has been decrypted, it will typically contain other packets (often literal data packets or compressed data packets).",
      "ja": "対称的に暗号化されたデータパケットは、共通鍵暗号で暗号化されたデータが含まれています。それが復号化されたとき、それは一般的に他のパケット（多くの場合、リテラルデータパケットまたは圧縮されたデータパケット）を含んでいます。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットのボディはで構成されています。"
    },
    {
      "indent": 5,
      "text": "- Encrypted data, the output of the selected symmetric-key cipher operating in PGP's variant of Cipher Feedback (CFB) mode.",
      "ja": " - 暗号化データ、暗号フィードバック（CFB）モードのPGPのバリアントで動作選択対称鍵暗号の出力。"
    },
    {
      "indent": 3,
      "text": "The symmetric cipher used may be specified in an Public-Key or Symmetric-Key Encrypted Session Key packet that precedes the Symmetrically Encrypted Data Packet. In that case, the cipher algorithm octet is prefixed to the session key before it is encrypted. If no packets of these types precede the encrypted data, the IDEA algorithm is used with the session key calculated as the MD5 hash of the passphrase.",
      "ja": "使用される対称暗号は対称的に暗号化データパケットの前に、公開鍵や共通鍵暗号化されたセッションキーパケットに指定することができます。それが暗号化される前に、その場合には、暗号アルゴリズムのオクテットは、セッションキーの前に置かれています。これらのタイプのパケットが暗号化されたデータに先行していない場合は、IDEAアルゴリズムは、パスフレーズのMD5ハッシュとして計算セッションキーで使用されています。"
    },
    {
      "indent": 3,
      "text": "The data is encrypted in CFB mode, with a CFB shift size equal to the cipher's block size. The Initial Vector (IV) is specified as all zeros. Instead of using an IV, OpenPGP prefixes a 10-octet string to the data before it is encrypted. The first eight octets are random, and the 9th and 10th octets are copies of the 7th and 8th octets, respectively. After encrypting the first 10 octets, the CFB state is resynchronized if the cipher block size is 8 octets or less. The last 8 octets of ciphertext are passed through the cipher and the block boundary is reset.",
      "ja": "データは暗号のブロックサイズに等しいCFBシフトサイズと、CFBモードで暗号化されています。初期ベクトル（IV）はすべてゼロとして指定されています。それが暗号化される前に、代わりにIVを使用しての、OpenPGPのは、データへの10オクテット文字列を接頭辞。最初の8つのオクテットはランダムであり、9日と10オクテットは、それぞれ、7,8オクテットのコピーです。最初の10個のオクテットを暗号化した後、CFB状態は暗号ブロックサイズが8つのオクテット以下である場合に再同期化されます。暗号文の最後の8つのオクテットは、暗号を通過され、ブロック境界がリセットされます。"
    },
    {
      "indent": 3,
      "text": "The repetition of 16 bits in the 80 bits of random data prefixed to the message allows the receiver to immediately check whether the session key is incorrect.",
      "ja": "メッセージに接頭辞ランダムデータの80ビットを16ビットの繰り返しは、受信機は直ちにセッションキーが誤っているかどうかをチェックすることを可能にします。"
    },
    {
      "indent": 0,
      "text": "5.8. Marker Packet (Obsolete Literal Packet) (Tag 10)",
      "section_title": true,
      "ja": "5.8。マーカーパケット（廃止リテラルパケット）（タグ10）"
    },
    {
      "indent": 3,
      "text": "An experimental version of PGP used this packet as the Literal packet, but no released version of PGP generated Literal packets with this tag. With PGP 5.x, this packet has been re-assigned and is reserved for use as the Marker packet.",
      "ja": "PGPの実験的なバージョンは、リテラルパケットとしてこのパケットを使用しますが、PGPのないリリースされたバージョンでは、このタグを持つリテラルのパケットを生成しません。 PGP 5.xではでは、このパケットは再割り当てされていて、マーカーパケットとして使用するために予約されています。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットのボディはで構成されています。"
    },
    {
      "indent": 5,
      "text": "- The three octets 0x50, 0x47, 0x50 (which spell \"PGP\" in UTF-8).",
      "ja": " -  3つのオクテット0x50を、0x47、0x50を（UTF-8でのスペル \"PGP\"）。"
    },
    {
      "indent": 3,
      "text": "Such a packet MUST be ignored when received. It may be placed at the beginning of a message that uses features not available in PGP 2.6.x in order to cause that version to report that newer software is necessary to process the message.",
      "ja": "受け取ったとき、そのようなパケットを無視しなければなりません。それは、新しいソフトウェアがメッセージを処理する必要があることを報告して、そのバージョンを引き起こすために、PGP 2.6.xではでは利用できない機能を使用して、メッセージの先頭に配置することができます。"
    },
    {
      "indent": 0,
      "text": "5.9. Literal Data Packet (Tag 11)",
      "section_title": true,
      "ja": "5.9。リテラルデータパケット（タグ11）"
    },
    {
      "indent": 3,
      "text": "A Literal Data packet contains the body of a message; data that is not to be further interpreted.",
      "ja": "リテラルデータパケットは、メッセージの本文が含まれています。さらに解釈されるべきではないデータ。"
    },
    {
      "indent": 3,
      "text": "The body of this packet consists of:",
      "ja": "このパケットのボディはで構成されています。"
    },
    {
      "indent": 5,
      "text": "- A one-octet field that describes how the data is formatted.",
      "ja": " - データをフォーマットする方法を説明します1オクテットフィールド。"
    },
    {
      "indent": 3,
      "text": "If it is a 'b' (0x62), then the literal packet contains binary data. If it is a 't' (0x74), then it contains text data, and thus may need line ends converted to local form, or other text-mode changes. RFC 1991 also defined a value of 'l' as a 'local' mode for machine-local conversions. This use is now deprecated.",
      "ja": "それは「B」（0x62）である場合には、リテラルパケットは、バイナリデータが含まれています。それは「T」（0x74）である場合、それは、テキストデータを含み、従ってラインがローカルフォーム、または他のテキストモードの変化に変換終了する必要があるかもしれません。 RFC 1991も機械局所変換のための「ローカル」モードと「L」の値を定義しました。この使用は廃止されます。"
    },
    {
      "indent": 5,
      "text": "- File name as a string (one-octet length, followed by file name), if the encrypted data should be saved as a file.",
      "ja": " - （ファイル名に続く1オクテット長、）文字列としてファイル名、暗号化されたデータをファイルとして保存する必要がある場合。"
    },
    {
      "indent": 3,
      "text": "If the special name \"_CONSOLE\" is used, the message is considered to be \"for your eyes only\". This advises that the message data is unusually sensitive, and the receiving program should process it more carefully, perhaps avoiding storing the received data to disk, for example.",
      "ja": "特別な名前「_CONSOLE」が使用されている場合、メッセージは「あなたの目だけのため」であると考えられています。これは、メッセージデータが異常に敏感であることを助言、及び受信プログラムは、おそらく、例えば、ディスクに受信したデータを格納する回避、より慎重に処理しなければなりません。"
    },
    {
      "indent": 5,
      "text": "- A four-octet number that indicates the modification date of the file, or the creation time of the packet, or a zero that indicates the present time.",
      "ja": " - ファイルの変更日、またはパケットの作成時、または現在時刻を示すゼロを示す4オクテットの数。"
    },
    {
      "indent": 5,
      "text": "- The remainder of the packet is literal data.",
      "ja": " - パケットの残りの部分は、リテラルデータです。"
    },
    {
      "indent": 3,
      "text": "Text data is stored with <CR><LF> text endings (i.e. network-normal line endings). These should be converted to native line endings by the receiving software.",
      "ja": "テキストデータは、<CR> <LF>テキスト終末（すなわち、ネットワーク正常行末）が格納されています。これらは、受信ソフトウェアによってネイティブの行末に変換する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.10. Trust Packet (Tag 12)",
      "section_title": true,
      "ja": "5.10。トラストパケット（タグ12）"
    },
    {
      "indent": 3,
      "text": "The Trust packet is used only within keyrings and is not normally exported. Trust packets contain data that record the user's specifications of which key holders are trustworthy introducers, along with other information that implementing software uses for trust information.",
      "ja": "トラストパケットはキーリング内で使用され、正常にエクスポートされません。トラストパケットは、ソフトウェアを実装する信頼情報に使用する他の情報と共に、キーホルダーが信頼できる紹介者であるユーザの仕様を記録したデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "Trust packets SHOULD NOT be emitted to output streams that are transferred to other users, and they SHOULD be ignored on any input other than local keyring files.",
      "ja": "トラストパケットを他のユーザーに転送された出力ストリームに放出すべきではないと彼らはローカルの鍵リングファイル以外の入力時に無視されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.11. User ID Packet (Tag 13)",
      "section_title": true,
      "ja": "5.11。ユーザIDパケット（タグ13）"
    },
    {
      "indent": 3,
      "text": "A User ID packet consists of data that is intended to represent the name and email address of the key holder. By convention, it includes an RFC 822 mail name, but there are no restrictions on its content. The packet length in the header specifies the length of the user id. If it is text, it is encoded in UTF-8.",
      "ja": "ユーザーIDパケットは、鍵の所有者の名前と電子メールアドレスを表すことが意図されているデータで構成されています。慣例では、それはRFC 822メール名が含まれていますが、その内容に制限はありません。ヘッダ内のパケット長は、ユーザIDの長さを指定します。それがテキストである場合は、UTF-8でエンコードされます。"
    },
    {
      "indent": 0,
      "text": "6. Radix-64 Conversions",
      "section_title": true,
      "ja": "前記基数64コンバージョン"
    },
    {
      "indent": 3,
      "text": "As stated in the introduction, OpenPGP's underlying native representation for objects is a stream of arbitrary octets, and some systems desire these objects to be immune to damage caused by character set translation, data conversions, etc.",
      "ja": "冒頭で述べたように、オブジェクトのためのOpenPGPの基礎となるネイティブ表現は、任意のオクテットストリームである、と一部のシステムでは、文字セット変換、データ変換などによって引き起こされる損傷に対して免疫するこれらのオブジェクトを望みます"
    },
    {
      "indent": 3,
      "text": "In principle, any printable encoding scheme that met the requirements of the unsafe channel would suffice, since it would not change the underlying binary bit streams of the native OpenPGP data structures. The OpenPGP standard specifies one such printable encoding scheme to ensure interoperability.",
      "ja": "原理的には、安全でないチャネルの要件を満たし、任意の印刷可能な符号化方式は、ネイティブのOpenPGPデータ構造の基礎となるバイナリビットストリームを変更しないので、十分であろう。 OpenPGPの標準は、相互運用性を確保するためにそのような印刷可能な符号化方式を指定します。"
    },
    {
      "indent": 3,
      "text": "OpenPGP's Radix-64 encoding is composed of two parts: a base64 encoding of the binary data, and a checksum. The base64 encoding is identical to the MIME base64 content-transfer-encoding [RFC2231, Section 6.8]. An OpenPGP implementation MAY use ASCII Armor to protect the raw binary data.",
      "ja": "バイナリデータのbase64エンコード、およびチェックサム：のOpenPGPの基数64の符号化は、2つの部分から構成されています。 Base64エンコードは、MIME base64でコンテンツ転送をコードする[RFC2231、セクション6.8]と同一です。 OpenPGPの実装は、生のバイナリデータを保護するためにASCIIアーマーを使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "The checksum is a 24-bit CRC converted to four characters of radix-64 encoding by the same MIME base64 transformation, preceded by an equals sign (=). The CRC is computed by using the generator 0x864CFB and an initialization of 0xB704CE. The accumulation is done on the data before it is converted to radix-64, rather than on the converted data. A sample implementation of this algorithm is in the next section.",
      "ja": "チェックサムは、等号（=）が先行同じMIMEのBASE64変換によって、基数64の符号化の4つの文字に変換する24ビットCRCです。 CRCは、発電0x864CFBと0xB704CEの初期化を使用して計算されます。むしろ、変換後のデータに比べて、基数64のように変換される前の蓄積は、データ上で行われます。このアルゴリズムの実装例は、次のセクションです。"
    },
    {
      "indent": 3,
      "text": "The checksum with its leading equal sign MAY appear on the first line after the Base64 encoded data.",
      "ja": "その先頭の等号とチェックサムはBase64でエンコードされたデータの後の最初の行に表示されることがあります。"
    },
    {
      "indent": 3,
      "text": "Rationale for CRC-24: The size of 24 bits fits evenly into printable base64. The nonzero initialization can detect more errors than a zero initialization.",
      "ja": "CRC-24の理論的根拠：24ビットのサイズが印刷可能BASE64に均等に収まります。ゼロ以外の初期化は、ゼロ初期以上のエラーを検出することができます。"
    },
    {
      "indent": 0,
      "text": "6.1. An Implementation of the CRC-24 in \"C\"",
      "section_title": true,
      "ja": "6.1。 「C」のCRC-24の実装"
    },
    {
      "indent": 7,
      "text": "#define CRC24_INIT 0xb704ceL\n#define CRC24_POLY 0x1864cfbL",
      "raw": true
    },
    {
      "indent": 7,
      "text": "typedef long crc24;\ncrc24 crc_octets(unsigned char *octets, size_t len)\n{\n    crc24 crc = CRC24_INIT;\n    int i;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    while (len--) {\n        crc ^= (*octets++) << 16;\n        for (i = 0; i < 8; i++) {\n            crc <<= 1;\n            if (crc & 0x1000000)\n                crc ^= CRC24_POLY;\n        }\n    }\n    return crc & 0xffffffL;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.2. Forming ASCII Armor",
      "section_title": true,
      "ja": "6.2。 ASCIIアーマーを形成します"
    },
    {
      "indent": 3,
      "text": "When OpenPGP encodes data into ASCII Armor, it puts specific headers around the data, so OpenPGP can reconstruct the data later. OpenPGP informs the user what kind of data is encoded in the ASCII armor through the use of the headers.",
      "ja": "OpenPGPのは、ASCII装甲にデータを符号化するときのOpenPGPは後でデータを再構築することができますので、それは、データの周りに特定のヘッダーを置きます。 OpenPGPのは、ヘッダーを使用してASCIIの鎧でエンコードされたデータの種類をユーザーに通知します。"
    },
    {
      "indent": 3,
      "text": "Concatenating the following data creates ASCII Armor:",
      "ja": "次のデータを連結すると、ASCIIアーマーを作成します。"
    },
    {
      "indent": 5,
      "text": "- An Armor Header Line, appropriate for the type of data",
      "ja": " - データのタイプに適したアーマーヘッダー行、"
    },
    {
      "indent": 5,
      "text": "- Armor Headers",
      "ja": " - アーマーヘッダ"
    },
    {
      "indent": 5,
      "text": "- A blank (zero-length, or containing only whitespace) line",
      "ja": " - ブランク（ゼロ長、または空白のみを含む）ライン"
    },
    {
      "indent": 5,
      "text": "- The ASCII-Armored data",
      "ja": " -  ASCII装甲データ"
    },
    {
      "indent": 5,
      "text": "- An Armor Checksum",
      "ja": " - アーマーチェックサム"
    },
    {
      "indent": 5,
      "text": "- The Armor Tail, which depends on the Armor Header Line.",
      "ja": " - アーマーヘッダー行に依存アーマーテール、。"
    },
    {
      "indent": 3,
      "text": "An Armor Header Line consists of the appropriate header line text surrounded by five (5) dashes ('-', 0x2D) on either side of the header line text. The header line text is chosen based upon the type of data that is being encoded in Armor, and how it is being encoded. Header line texts include the following strings:",
      "ja": "ヘッダ行のテキストのいずれかの側に - （0x2D「」）アーマーヘッダーライン5（5）破線で囲まれた適切なヘッダ行テキストから成ります。ヘッダ行テキストはアーマーで符号化され、そしてそれがどのように符号化されているデータの種類に基づいて選択されます。ヘッダ行のテキストは、以下の文字列が含まれます。"
    },
    {
      "indent": 3,
      "text": "BEGIN PGP MESSAGE Used for signed, encrypted, or compressed files.",
      "ja": "署名、暗号化、または圧縮されたファイルに使用するPGPメッセージを開始します。"
    },
    {
      "indent": 3,
      "text": "BEGIN PGP PUBLIC KEY BLOCK Used for armoring public keys",
      "ja": "PGP PUBLIC KEY BLOCKは、公開鍵を外装に使用されるBEGIN"
    },
    {
      "indent": 3,
      "text": "BEGIN PGP PRIVATE KEY BLOCK Used for armoring private keys",
      "ja": "秘密鍵を外装に使用するPGP秘密鍵ブロックをBEGIN"
    },
    {
      "indent": 3,
      "text": "BEGIN PGP MESSAGE, PART X/Y Used for multi-part messages, where the armor is split amongst Y parts, and this is the Xth part out of Y.",
      "ja": "装甲はY部分の間で分割されたマルチパートメッセージに使用PGPメッセージ、PART X / Yを開始し、これは、YのうちのX番目の一部であります"
    },
    {
      "indent": 3,
      "text": "BEGIN PGP MESSAGE, PART X Used for multi-part messages, where this is the Xth part of an unspecified number of parts. Requires the MESSAGE-ID Armor Header to be used.",
      "ja": "これは部品の不特定多数のX番目の一部であるPGPメッセージ、マルチパートメッセージで使用しPART Xを、BEGIN。 MESSAGE-IDアーマーヘッダーを使用することが必要です。"
    },
    {
      "indent": 3,
      "text": "BEGIN PGP SIGNATURE Used for detached signatures, OpenPGP/MIME signatures, and natures following clearsigned messages. Note that PGP 2.x s BEGIN PGP MESSAGE for detached signatures.",
      "ja": "clearsignedメッセージ以下の分離署名、OpenPGPの/ MIME署名、および性質のために使用するPGP SIGNATUREを開始します。 PGP 2.xのsが分離署名のためのPGPメッセージをBEGINことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The Armor Headers are pairs of strings that can give the user or the receiving OpenPGP implementation some information about how to decode or use the message. The Armor Headers are a part of the armor, not a part of the message, and hence are not protected by any signatures applied to the message.",
      "ja": "装甲ヘッダは、ユーザーまたは受信のOpenPGP実装にメッセージを解読や使用方法に関するいくつかの情報を与えることができ、文字列のペアです。装甲ヘッダは、装甲の一部ではなく、メッセージの一部であるので、メッセージに適用される署名によって保護されていません。"
    },
    {
      "indent": 3,
      "text": "The format of an Armor Header is that of a key-value pair. A colon (':' 0x38) and a single space (0x20) separate the key and value. OpenPGP should consider improperly formatted Armor Headers to be corruption of the ASCII Armor. Unknown keys should be reported to the user, but OpenPGP should continue to process the message.",
      "ja": "アーマーヘッダのフォーマットは、キーと値のペアです。コロン（「：」0x38）と単一のスペース（0x20の）キーと値を分離します。 OpenPGPのは、ASCIIアーマーの破損であることを不適切にフォーマットアーマーヘッダを考慮すべきです。不明なキーがユーザに報告しなければならないが、OpenPGPのは、メッセージを処理し続けるべきです。"
    },
    {
      "indent": 3,
      "text": "Currently defined Armor Header Keys are:",
      "ja": "現在、定義されたアーマーヘッダーキーは以下のとおりです。"
    },
    {
      "indent": 5,
      "text": "- \"Version\", that states the OpenPGP Version used to encode the message.",
      "ja": " -  OpenPGPのバージョンがメッセージをエンコードするために使用されると述べ、「バージョン」、。"
    },
    {
      "indent": 5,
      "text": "- \"Comment\", a user-defined comment.",
      "ja": " - 、ユーザー定義のコメントを「コメント」。"
    },
    {
      "indent": 5,
      "text": "- \"MessageID\", a 32-character string of printable characters. The string must be the same for all parts of a multi-part message that uses the \"PART X\" Armor Header. MessageID strings should be unique enough that the recipient of the mail can associate all the parts of a message with each other. A good checksum or cryptographic hash function is sufficient.",
      "ja": " - 「メッセージID」、印刷可能文字の32文字の文字列。文字列は、「部品X」アーマーヘッダを使用するマルチパートメッセージのすべての部分で同じでなければなりません。メッセージID文字列は、メールの受信者が相互にメッセージのすべての部分を関連付けることができることを十分に一意である必要があります。良いチェックサムまたは暗号化ハッシュ関数で十分です。"
    },
    {
      "indent": 5,
      "text": "- \"Hash\", a comma-separated list of hash algorithms used in this message. This is used only in clear-signed messages.",
      "ja": " - 「ハッシュ」、このメッセージに使用されるハッシュアルゴリズムのコンマ区切りリスト。これが唯一のクリア署名付きメッセージで使用されます。"
    },
    {
      "indent": 5,
      "text": "- \"Charset\", a description of the character set that the plaintext is in. Please note that OpenPGP defines text to be in UTF-8 by default. An implementation will get best results by translating into and out of UTF-8. However, there are many instances where this is easier said than done. Also, there are communities of users who have no need for UTF-8 because they are all happy with a character set like ISO Latin-5 or a Japanese character set. In such instances, an implementation MAY override the UTF-8 default by using this header key. An implementation MAY implement this key and any translations it cares to; an implementation MAY ignore it and assume all text is UTF-8.",
      "ja": " - 。「文字セット」、文字の記述は平文がであることを設定したOpenPGPは、デフォルトでUTF-8にするために、テキストを定義することに注意してください。実装はへとUTF-8のうち、翻訳することによって、最良の結果を得ることができます。しかし、これを行うよりも簡単に言われて、多くの場合があります。また、彼らはすべてのISOラテン-5または日本語文字セットのような文字セットに満足しているので、UTF-8を必要としないユーザーのコミュニティがあります。このような場合には、実装がこのヘッダのキーを使用して、UTF-8のデフォルトを無効にすることができます。実装は、このキーとそれが気に任意の変換を実装してもよい（MAY）。実装はそれを無視し、すべてのテキストはUTF-8であると仮定してもよい（MAY）。"
    },
    {
      "indent": 7,
      "text": "The MessageID SHOULD NOT appear unless it is in a multi-part message. If it appears at all, it MUST be computed from the finished (encrypted, signed, etc.) message in a deterministic fashion, rather than contain a purely random value. This is to allow the legitimate recipient to determine that the MessageID cannot serve as a covert means of leaking cryptographic key information.",
      "ja": "それはマルチパートメッセージでない限り、メッセージIDは表示されません。それがすべて表示された場合、それは完成から計算されなければならない、純粋にランダムな値が含まれているのではなく、決定論的な方法でメッセージを（暗号化など、署名しました）。これは、正当な受信者がメッセージIDは、暗号鍵情報を漏洩する秘密の手段として機能しないことを決定できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "The Armor Tail Line is composed in the same manner as the Armor Header Line, except the string \"BEGIN\" is replaced by the string \"END.\"",
      "ja": "アーマーテールラインは、文字列の文字列に置き換えられ、「BEGIN」を除いて、アーマーヘッダー行と同様に構成されて「END。」"
    },
    {
      "indent": 0,
      "text": "6.3. Encoding Binary in Radix-64",
      "section_title": true,
      "ja": "6.3。基数64でバイナリをコードします"
    },
    {
      "indent": 3,
      "text": "The encoding process represents 24-bit groups of input bits as output strings of 4 encoded characters. Proceeding from left to right, a 24-bit input group is formed by concatenating three 8-bit input groups. These 24 bits are then treated as four concatenated 6-bit groups, each of which is translated into a single digit in the Radix-64 alphabet. When encoding a bit stream with the Radix-64 encoding, the bit stream must be presumed to be ordered with the most-significant-bit first. That is, the first bit in the stream will be the high-order bit in the first 8-bit octet, and the eighth bit will be the low-order bit in the first 8-bit octet, and so on.",
      "ja": "符号化プロセスは、4つのエンコードされた文字の出力列として入力ビットの24ビットのグループを表します。左から右に進むと、24ビットの入力グループは3つの8ビット入力グループを連結することによって形成されています。これらの24ビットは、基数64アルファベットの一桁に翻訳され、それぞれが4つの連結された6ビットのグループとして扱われます。基数64のエンコードとビットストリームを符号化するとき、ビットストリームは、まず最上位ビットと一緒に注文すると推定されなければなりません。すなわち、ストリームの最初のビットは、最初の8ビットオクテットの上位ビットとなり、第8ビットはように最初の8ビットオクテットの下位ビットである、とし、です。"
    },
    {
      "indent": 9,
      "text": "+--first octet--+-second octet--+--third octet--+\n|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|\n+-----------+---+-------+-------+---+-----------+\n|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|\n+--1.index--+--2.index--+--3.index--+--4.index--+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each 6-bit group is used as an index into an array of 64 printable characters from the table below. The character referenced by the index is placed in the output string.",
      "ja": "各6ビットグループは、以下の表から64個の印刷可能文字の配列へのインデックスとして使用されます。インデックスで参照される文字は、出力文字列に配置されます。"
    },
    {
      "indent": 5,
      "text": "Value Encoding Value Encoding Value Encoding Value Encoding 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w (pad) = 15 P 32 g 49 x 16 Q 33 h 50 y",
      "ja": "値エンコーディング値エンコーディング値エンコーディング値34 I 51 Z 1 B 18 S 35 J 52 0 2 C 19 T 36 K 53 1 3 D 20 U 37リットル54 2 4 E 21、V 38メートル55 3 5 F 17 R 0エンコーディング22 W 39 N 56 4 6 G 23 X 40 O 57 5 7 H 24 Y 41、P 58 6 8 I 25、Z 42、Q 59 7 9 26 J 43 R 60 8 10 K 27、B 44、S 61 9 11 L 28 C 45トン62 + 12 M 29、D 46、U 13分の63 N 30、E 47、V 14 O 31 48 F（パッド）= 15 P 32グラム49 X 16 Q 33 H 50 Y、W"
    },
    {
      "indent": 3,
      "text": "The encoded output stream must be represented in lines of no more than 76 characters each.",
      "ja": "符号化された出力ストリームを超えない76個の文字それぞれの行で表現されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Special processing is performed if fewer than 24 bits are available at the end of the data being encoded. There are three possibilities:",
      "ja": "未満の24ビットは符号化されたデータの最後に利用可能である場合、特別な処理が行われます。 3つの可能性があります。"
    },
    {
      "indent": 4,
      "text": "1. The last data group has 24 bits (3 octets). No special processing is needed.",
      "ja": "1.最後のデータグループは、24ビット（3オクテット）を有しています。特別な処理は必要ありません。"
    },
    {
      "indent": 4,
      "text": "2. The last data group has 16 bits (2 octets). The first two 6-bit groups are processed as above. The third (incomplete) data group has two zero-value bits added to it, and is processed as above. A pad character (=) is added to the output.",
      "ja": "2.最後のデータグループは、16ビット（2オクテット）を有しています。最初の2つの6ビットグループは、上記のように処理されます。第三の（不完全な）データグループは、それに追加した2つのゼロ値ビットを有しており、上記のように処理されます。パッド文字（=）の出力に加算されます。"
    },
    {
      "indent": 4,
      "text": "3. The last data group has 8 bits (1 octet). The first 6-bit group is processed as above. The second (incomplete) data group has four zero-value bits added to it, and is processed as above. Two pad characters (=) are added to the output.",
      "ja": "3.最後のデータ群は、8ビット（1オクテット）を有しています。最初の6ビットグループは、上記のように処理されます。第二の（不完全な）データグループは、それに加え4ゼロ値ビットを有しており、上記のように処理されます。二つのパッド文字（=）は、出力に追加されます。"
    },
    {
      "indent": 0,
      "text": "6.4. Decoding Radix-64",
      "section_title": true,
      "ja": "6.4。デコード基数64"
    },
    {
      "indent": 3,
      "text": "Any characters outside of the base64 alphabet are ignored in Radix-64 data. Decoding software must ignore all line breaks or other characters not found in the table above.",
      "ja": "base64でアルファベット以外の文字は、基数64のデータでは無視されます。デコードソフトウェアは、上記の表には見られないすべての改行または他の文字を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In Radix-64 data, characters other than those in the table, line breaks, and other white space probably indicate a transmission error, about which a warning message or even a message rejection might be appropriate under some circumstances.",
      "ja": "基数64では、データ、テーブル内の文字以外の文字、改行、およびその他のホワイトスペースは、おそらく警告メッセージ、あるいはメッセージの拒否は、いくつかの状況下で適切であるかもしれないかについて、伝送エラーを示します。"
    },
    {
      "indent": 3,
      "text": "Because it is used only for padding at the end of the data, the occurrence of any \"=\" characters may be taken as evidence that the end of the data has been reached (without truncation in transit). No such assurance is possible, however, when the number of octets transmitted was a multiple of three and no \"=\" characters are present.",
      "ja": "それはデータの末尾にのみパディングのために使用されるため、任意の「=」文字の発生は、データの端部が（輸送中の切り捨てなし）に達したことを証拠として採用されてもよいです。送信されたオクテットの数が3の倍数であった場合、そのような保証は、しかしながら、可能であり、ノー「=」文字が存在しています。"
    },
    {
      "indent": 0,
      "text": "6.5. Examples of Radix-64",
      "section_title": true,
      "ja": "6.5。基数64の例"
    },
    {
      "indent": 7,
      "text": "Input data:  0x14fb9c03d97e\nHex:     1   4    f   b    9   c     | 0   3    d   9    7   e\n8-bit:   00010100 11111011 10011100  | 00000011 11011001\n11111110\n6-bit:   000101 001111 101110 011100 | 000000 111101 100111\n111110\nDecimal: 5      15     46     28       0      61     37     62\nOutput:  F      P      u      c        A      9      l      +",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Input data: 0x14fb9c03d9 Hex: 1 4 f b 9 c | 0 3 d 9 8-bit: 00010100 11111011 10011100 | 00000011 11011001 pad with 00 6-bit: 000101 001111 101110 011100 | 000000 111101 100100 Decimal: 5 15 46 28 0 61 36 pad with = Output: F P u c A 9 k =",
      "ja": "入力データ：0x14fb9c03d9六角：1つの4 F bの9個のC | 0 3 D 9 8ビット：00010100 11111011 10011100 | 00 6ビットで00000011 11011001パッド：000101 001111 101110 011100 | 000000 111101 100100進：=出力と5 15 46 28 0 61 36パッド：9 K C F PのU ="
    },
    {
      "indent": 7,
      "text": "Input data: 0x14fb9c03 Hex: 1 4 f b 9 c | 0 3 8-bit: 00010100 11111011 10011100 | 00000011 pad with 0000 6-bit: 000101 001111 101110 011100 | 000000 110000 Decimal: 5 15 46 28 0 48 pad with = = Output: F P u c A w = =",
      "ja": "入力データ：0x14fb9c03六角：1つの4 F bの9 C | 0 3 8ビット：00010100 11111011 10011100 | 0000 6ビットで00000011パッド：000101 001111 101110 011100 | 000000 110000進数：5 15 46 28 0 48 = =出力とパッド：F P U C A = W ="
    },
    {
      "indent": 0,
      "text": "6.6. Example of an ASCII Armored Message",
      "section_title": true,
      "ja": "6.6。 ASCII装甲メッセージの例"
    },
    {
      "indent": 2,
      "text": "-----BEGIN PGP MESSAGE-----\nVersion: OpenPrivacy 0.99",
      "raw": true
    },
    {
      "indent": 2,
      "text": "yDgBO22WxBHv7O8X7O/jygAEzol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzS\nvBSFjNSiVHsuAA==\n=njUN\n-----END PGP MESSAGE-----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that this example is indented by two spaces.",
      "ja": "この例では、二つのスペースでインデントされていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "7. Cleartext signature framework",
      "section_title": true,
      "ja": "7.クリアテキスト署名フレームワーク"
    },
    {
      "indent": 3,
      "text": "It is desirable to sign a textual octet stream without ASCII armoring the stream itself, so the signed text is still readable without special software. In order to bind a signature to such a cleartext, this framework is used. (Note that RFC 2015 defines another way to clear sign messages for environments that support MIME.)",
      "ja": "ストリーム自体を外装ASCIIせずに、テキストのオクテットストリームに署名することが望ましいので、署名したテキストは、特別なソフトウェアなしでまだ読めるです。そのようなクリアテキストに署名を結合するために、このフレームワークが使用されます。 （つまりRFC 2015は、MIMEをサポートする環境のためにサインメッセージをクリアする別の方法を定義します。）"
    },
    {
      "indent": 3,
      "text": "The cleartext signed message consists of:",
      "ja": "クリアテキスト署名されたメッセージの構成は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "- The cleartext header '-----BEGIN PGP SIGNED MESSAGE-----' on a\n  single line,",
      "raw": true
    },
    {
      "indent": 5,
      "text": "- One or more \"Hash\" Armor Headers,",
      "ja": " -  1つ以上の「ハッシュ」アーマーヘッダ、"
    },
    {
      "indent": 5,
      "text": "- Exactly one empty line not included into the message digest,",
      "ja": " - 正確に1つの空行がメッセージダイジェストに含まれていません、"
    },
    {
      "indent": 5,
      "text": "- The dash-escaped cleartext that is included into the message digest,",
      "ja": " - メッセージダイジェストの中に含まれているダッシュエスケープ平文"
    },
    {
      "indent": 5,
      "text": "- The ASCII armored signature(s) including the '-----BEGIN PGP\n  SIGNATURE-----' Armor Header and Armor Tail Lines.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the \"Hash\" armor header is given, the specified message digest algorithm is used for the signature. If there are no such headers, MD5 is used, an implementation MAY omit them for V2.x compatibility. If more than one message digest is used in the signature, the \"Hash\" armor header contains a comma-delimited list of used message digests.",
      "ja": "「ハッシュ」装甲ヘッダが指定された場合、指定されたメッセージは、アルゴリズムが、署名のために使用されるダイジェスト。そのようなヘッダが存在しない場合は、MD5が使用され、実装がV2.xでは互換性のためにそれらを省略することができます。複数のメッセージダイジェストが署名に使用される場合、「ハッシュ」装甲ヘッダが使用されるメッセージダイジェストのカンマ区切りリストを含みます。"
    },
    {
      "indent": 3,
      "text": "Current message digest names are described below with the algorithm IDs.",
      "ja": "現在のメッセージダイジェスト名は、アルゴリズムIDに以下に記載されています。"
    },
    {
      "indent": 0,
      "text": "7.1. Dash-Escaped Text",
      "section_title": true,
      "ja": "7.1。ダッシュエスケープ文字"
    },
    {
      "indent": 3,
      "text": "The cleartext content of the message must also be dash-escaped.",
      "ja": "メッセージのクリアテキスト内容もダッシュエスケープする必要があります。"
    },
    {
      "indent": 3,
      "text": "Dash escaped cleartext is the ordinary cleartext where every line starting with a dash '-' (0x2D) is prefixed by the sequence dash '-' (0x2D) and space ' ' (0x20). This prevents the parser from recognizing armor headers of the cleartext itself. The message digest is computed using the cleartext itself, not the dash escaped form.",
      "ja": "「 - 」 - （0x20の）「（0x2D）とスペース」「」（0x2D）シーケンスダッシュが付けられダッシュはクリアテキストがダッシュで始まるすべての行は、通常のクリアテキストで脱出しました。これは、クリアテキスト自体の装甲ヘッダを認識することから、パーサーを防ぐことができます。メッセージダイジェストは、クリアテキスト自体を使用して計算されて、いないダッシュは、フォームを免れました。"
    },
    {
      "indent": 3,
      "text": "As with binary signatures on text documents, a cleartext signature is\ncalculated on the text using canonical <CR><LF> line endings.  The\nline ending (i.e. the <CR><LF>) before the '-----BEGIN PGP\nSIGNATURE-----' line that terminates the signed text is not\nconsidered part of the signed text.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Also, any trailing whitespace (spaces, and tabs, 0x09) at the end of any line is ignored when the cleartext signature is calculated.",
      "ja": "また、任意の末尾の空白（スペース、タブ、0x09の）平文署名が計算されるとき、任意の行の最後に無視されます。"
    },
    {
      "indent": 0,
      "text": "8. Regular Expressions",
      "section_title": true,
      "ja": "8.正規表現"
    },
    {
      "indent": 3,
      "text": "A regular expression is zero or more branches, separated by '|'. It matches anything that matches one of the branches.",
      "ja": "「|」正規表現で区切られた、ゼロ以上の分岐です。これは、分岐の1つに一致するものと一致しました。"
    },
    {
      "indent": 3,
      "text": "A branch is zero or more pieces, concatenated. It matches a match for the first, followed by a match for the second, etc.",
      "ja": "ブランチはゼロ個以上、連結です。なお、第2、等のための一致に続く最初の一致を、一致します"
    },
    {
      "indent": 3,
      "text": "A piece is an atom possibly followed by '*', '+', or '?'. An atom followed by '*' matches a sequence of 0 or more matches of the atom. An atom followed by '+' matches a sequence of 1 or more matches of the atom. An atom followed by '?' matches a match of the atom, or the null string.",
      "ja": "作品は、「+」、または「？」、おそらく「*」が続く原子です。 「*」が続くアトムは、アトムの0以上のシーケンスにマッチします。 「+」に続く原子は原子の1つの以上のシーケンスにマッチし。続くアトム「？」アトムの一致、またはヌル文字列にマッチします。"
    },
    {
      "indent": 3,
      "text": "An atom is a regular expression in parentheses (matching a match for the regular expression), a range (see below), '.' (matching any single character), '^' (matching the null string at the beginning of the input string), '$' (matching the null string at the end of the input string), a '\\' followed by a single character (matching that character), or a single character with no other significance (matching that character).",
      "ja": "原子は、括弧内の正規表現（正規表現の一致を照合）、範囲（以下を参照）です「」 （任意の一文字にマッチする）、「^」（入力文字列の先頭にヌル文字列にマッチする）、「$」（入力文字列の最後にnull文字列にマッチする）、「\\」は、単一の文字が続きます（その文字にマッチする）、または全く他の意味（その文字に一致する）を有する単一の文字。"
    },
    {
      "indent": 3,
      "text": "A range is a sequence of characters enclosed in '[]'. It normally matches any single character from the sequence. If the sequence begins with '^', it matches any single character not from the rest of the sequence. If two characters in the sequence are separated by '-', this is shorthand for the full list of ASCII characters between them (e.g. '[0-9]' matches any decimal digit). To include a literal ']' in the sequence, make it the first character (following a possible '^'). To include a literal '-', make it the first or last character.",
      "ja": "範囲は、「[]」で囲まれた文字のシーケンスです。これは、通常のシーケンスから任意の1文字に一致します。シーケンスは「^」で始まる場合、それはないシーケンスの残りの部分から任意の1文字に一致します。 「 - 」配列内の2つの文字がで分離されている場合、これは、それらの間のASCII文字の完全なリスト（例えば「[0-9]」任意の10進数字と一致する）の短縮形です。順番に「]」リテラルを含めるには、それ（「^」可能に続く）最初の文字します。 「 - 」リテラルを含めるには、その最初または最後の文字にします。"
    },
    {
      "indent": 0,
      "text": "9. Constants",
      "section_title": true,
      "ja": "9.定数"
    },
    {
      "indent": 3,
      "text": "This section describes the constants used in OpenPGP.",
      "ja": "このセクションでは、OpenPGPの中で使用される定数を記述します。"
    },
    {
      "indent": 3,
      "text": "Note that these tables are not exhaustive lists; an implementation MAY implement an algorithm not on these lists.",
      "ja": "これらのテーブルは網羅的リストではないことに注意してください。実装は、これらのリストにないアルゴリズムを実装してもよいです。"
    },
    {
      "indent": 3,
      "text": "See the section \"Notes on Algorithms\" below for more discussion of the algorithms.",
      "ja": "アルゴリズムのより多くの議論については、以下のセクション「アルゴリズム上の注意」を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.1. Public Key Algorithms",
      "section_title": true,
      "ja": "9.1。公開鍵アルゴリズム"
    },
    {
      "indent": 7,
      "text": "ID           Algorithm\n--           ---------\n1          - RSA (Encrypt or Sign)\n2          - RSA Encrypt-Only\n3          - RSA Sign-Only\n16         - Elgamal (Encrypt-Only), see [ELGAMAL]\n17         - DSA (Digital Signature Standard)\n18         - Reserved for Elliptic Curve\n19         - Reserved for ECDSA\n20         - Elgamal (Encrypt or Sign)",
      "raw": true
    },
    {
      "indent": 7,
      "text": "21 - Reserved for Diffie-Hellman (X9.42, as defined for IETF-S/MIME) 100 to 110 - Private/Experimental algorithm.",
      "ja": "21  - プライベート/実験的アルゴリズム -  100 110（IETF-S / MIMEについて定義した通り、X9.42）のDiffie-Hellmanのために予約されています。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement DSA for signatures, and Elgamal for encryption. Implementations SHOULD implement RSA keys. Implementations MAY implement any other algorithm.",
      "ja": "実装は、暗号化のための署名のためのDSA、とはElgamalを実装しなければなりません。実装はRSAキーを実装する必要があります。実装は、他のアルゴリズムを実装してもよいです。"
    },
    {
      "indent": 0,
      "text": "9.2. Symmetric Key Algorithms",
      "section_title": true,
      "ja": "9.2。対称鍵アルゴリズム"
    },
    {
      "indent": 7,
      "text": "ID           Algorithm\n--           ---------\n0          - Plaintext or unencrypted data\n1          - IDEA [IDEA]\n2          - Triple-DES (DES-EDE, as per spec -\n             168 bit key derived from 192)\n3          - CAST5 (128 bit key, as per RFC 2144)\n4          - Blowfish (128 bit key, 16 rounds) [BLOWFISH]\n5          - SAFER-SK128 (13 rounds) [SAFER]\n6          - Reserved for DES/SK\n7          - Reserved for AES with 128-bit key",
      "raw": true
    },
    {
      "indent": 7,
      "text": "8 - Reserved for AES with 192-bit key 9 - Reserved for AES with 256-bit key 100 to 110 - Private/Experimental algorithm.",
      "ja": "8から192ビットキー9とAESのために予約 - プライベート/実験的アルゴリズム -  256ビット鍵100〜110とAESのために予約。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement Triple-DES. Implementations SHOULD implement IDEA and CAST5.Implementations MAY implement any other algorithm.",
      "ja": "実装は、トリプルDESを実装しなければなりません。実装はIDEAを実装する必要がありますし、CAST5.Implementationsは、他のアルゴリズムを実装してもよいです。"
    },
    {
      "indent": 0,
      "text": "9.3. Compression Algorithms",
      "section_title": true,
      "ja": "9.3。圧縮アルゴリズム"
    },
    {
      "indent": 7,
      "text": "ID           Algorithm\n--           ---------\n0          - Uncompressed\n1          - ZIP (RFC 1951)\n2          - ZLIB (RFC 1950)\n100 to 110 - Private/Experimental algorithm.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement uncompressed data. Implementations SHOULD implement ZIP. Implementations MAY implement ZLIB.",
      "ja": "実装は、非圧縮データを実装しなければなりません。実装はZIPを実装する必要があります。実装はZLIBを実施することができます。"
    },
    {
      "indent": 0,
      "text": "9.4. Hash Algorithms",
      "section_title": true,
      "ja": "9.4。ハッシュアルゴリズム"
    },
    {
      "indent": 7,
      "text": "ID           Algorithm                              Text Name\n--           ---------                              ---- ----\n1          - MD5                                    \"MD5\"\n2          - SHA-1                                  \"SHA1\"\n3          - RIPE-MD/160                            \"RIPEMD160\"\n4          - Reserved for double-width SHA (experimental)\n5          - MD2                                    \"MD2\"\n6          - Reserved for TIGER/192                 \"TIGER192\"\n7          - Reserved for HAVAL (5 pass, 160-bit)\n\"HAVAL-5-160\"\n100 to 110 - Private/Experimental algorithm.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Implementations MUST implement SHA-1. Implementations SHOULD implement MD5.",
      "ja": "実装は、SHA-1を実装しなければなりません。実装はMD5を実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "10. Packet Composition",
      "section_title": true,
      "ja": "10.パケット組成"
    },
    {
      "indent": 3,
      "text": "OpenPGP packets are assembled into sequences in order to create messages and to transfer keys. Not all possible packet sequences are meaningful and correct. This describes the rules for how packets should be placed into sequences.",
      "ja": "OpenPGPのパケットは、メッセージを作成するとキーを転送するために、系列に組み立てられています。いないすべての可能なパケットシーケンスが有意義かつ正確です。これは、パケットがシーケンスに置かれるべきであるかのルールを説明しています。"
    },
    {
      "indent": 0,
      "text": "10.1. Transferable Public Keys",
      "section_title": true,
      "ja": "10.1。譲渡公開鍵"
    },
    {
      "indent": 3,
      "text": "OpenPGP users may transfer public keys. The essential elements of a transferable public key are:",
      "ja": "OpenPGPユーザは、公開鍵を転送することができます。譲渡公開鍵の不可欠な要素は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "- One Public Key packet",
      "ja": " - 一つの公開鍵パケット"
    },
    {
      "indent": 5,
      "text": "- Zero or more revocation signatures",
      "ja": " - ゼロ以上の取消し署名"
    },
    {
      "indent": 5,
      "text": "- One or more User ID packets",
      "ja": " -  1つの以上のユーザーIDパケット"
    },
    {
      "indent": 5,
      "text": "- After each User ID packet, zero or more signature packets (certifications)",
      "ja": " - 各ユーザIDパケットの後、ゼロまたはそれ以上の署名パケット（認証）"
    },
    {
      "indent": 5,
      "text": "- Zero or more Subkey packets",
      "ja": " - ゼロ以上のサブキーパケット"
    },
    {
      "indent": 5,
      "text": "- After each Subkey packet, one signature packet, optionally a revocation.",
      "ja": " - 必要に応じて各サブキーパケット、1つのシグネチャパケット、失効した後。"
    },
    {
      "indent": 3,
      "text": "The Public Key packet occurs first. Each of the following User ID packets provides the identity of the owner of this public key. If there are multiple User ID packets, this corresponds to multiple means of identifying the same unique individual user; for example, a user may have more than one email address, and construct a User ID for each one.",
      "ja": "公開鍵パケットが最初に発生します。以下のユーザーIDパケットのそれぞれは、この公開鍵の所有者の身元を提供します。複数のユーザーIDパケットが存在する場合、これは、同じユニークユーザ個人を特定の複数の手段に対応します。例えば、ユーザーが複数のメールアドレスを持ち、各1のユーザIDを構築することができます。"
    },
    {
      "indent": 3,
      "text": "Immediately following each User ID packet, there are zero or more signature packets. Each signature packet is calculated on the immediately preceding User ID packet and the initial Public Key packet. The signature serves to certify the corresponding public key and user ID. In effect, the signer is testifying to his or her belief that this public key belongs to the user identified by this user ID.",
      "ja": "直ちに各ユーザIDのパケットに続く、ゼロまたはそれ以上の署名パケットが存在します。各署名パケットは、直前のユーザIDのパケットと最初の公開鍵パケットに基づいて計算されます。署名は、対応する公開鍵とユーザIDを証明するのに役立ちます。実際には、署名者は、この公開鍵がこのユーザIDで識別されるユーザーに属することを彼または彼女の信念に証言しています。"
    },
    {
      "indent": 3,
      "text": "After the User ID packets there may be one or more Subkey packets. In general, subkeys are provided in cases where the top-level public key is a signature-only key. However, any V4 key may have subkeys, and the subkeys may be encryption-only keys, signature-only keys, or general-purpose keys.",
      "ja": "ユーザーIDパケットの後一個の以上のSubkeyパケットがあるかもしれません。一般に、サブキーが最上位の公開鍵は、署名のみのキーである場合に設けられています。しかし、任意のV4キーがサブキーを持っていること、およびサブキーは、暗号化キーのみ、署名のみのキー、または汎用キーかもしれません。"
    },
    {
      "indent": 3,
      "text": "Each Subkey packet must be followed by one Signature packet, which should be a subkey binding signature issued by the top level key.",
      "ja": "各サブキーパケットは、トップレベルの鍵が発行したサブキー結合署名でなければならない1つのシグネチャパケットが続かなければなりません。"
    },
    {
      "indent": 3,
      "text": "Subkey and Key packets may each be followed by a revocation Signature packet to indicate that the key is revoked. Revocation signatures are only accepted if they are issued by the key itself, or by a key that is authorized to issue revocations via a revocation key subpacket in a self-signature by the top level key.",
      "ja": "サブキーとキー・パケットは、各キーが取り消されたことを示すために、失効署名パケットが続いてもよいです。彼らはキー自体によって、またはトップレベルのキーによって自己署名における失効キーのサブパケットを経由して取消しを発行することを許可されたキーによって発行された場合は失効署名のみが受け入れられます。"
    },
    {
      "indent": 3,
      "text": "Transferable public key packet sequences may be concatenated to allow transferring multiple public keys in one operation.",
      "ja": "譲渡公開鍵パケットシーケンスは、1回の操作で複数の公開鍵を転送できるように連結されてもよいです。"
    },
    {
      "indent": 0,
      "text": "10.2. OpenPGP Messages",
      "section_title": true,
      "ja": "10.2。 OpenPGPのメッセージ"
    },
    {
      "indent": 3,
      "text": "An OpenPGP message is a packet or sequence of packets that corresponds to the following grammatical rules (comma represents sequential composition, and vertical bar separates alternatives):",
      "ja": "OpenPGPのメッセージは、次の文法規則（コンマがシーケンシャル組成を表し、垂直バーの選択肢を分離する）に対応するパケットまたはパケットの配列です。"
    },
    {
      "indent": 3,
      "text": "OpenPGP Message :- Encrypted Message | Signed Message | Compressed Message | Literal Message.",
      "ja": "OpenPGPのメッセージ： - 暗号化されたメッセージ|署名付きのメッセージ|圧縮されたメッセージ| literalメッセージ。"
    },
    {
      "indent": 3,
      "text": "Compressed Message :- Compressed Data Packet.",
      "ja": "圧縮されたメッセージ： - 圧縮されたデータパケット。"
    },
    {
      "indent": 3,
      "text": "Literal Message :- Literal Data Packet.",
      "ja": "literalメッセージ： - リテラルデータパケット。"
    },
    {
      "indent": 3,
      "text": "ESK :- Public Key Encrypted Session Key Packet | Symmetric-Key Encrypted Session Key Packet.",
      "ja": "ESK： - 公開鍵暗号化されたセッション鍵パケット|共通鍵暗号化されたセッション鍵パケット。"
    },
    {
      "indent": 3,
      "text": "ESK Sequence :- ESK | ESK Sequence, ESK.",
      "ja": "CSRシーケンス： -  CSR |シーケンスCSR、CSR。"
    },
    {
      "indent": 3,
      "text": "Encrypted Message :- Symmetrically Encrypted Data Packet | ESK Sequence, Symmetrically Encrypted Data Packet.",
      "ja": "暗号化されたメッセージ： - 対称的に暗号化データパケット| ESKシーケンス、対称的に暗号化データパケット。"
    },
    {
      "indent": 3,
      "text": "One-Pass Signed Message :- One-Pass Signature Packet, OpenPGP Message, Corresponding Signature Packet.",
      "ja": "ワンパス署名付きメッセージ： - ワンパス署名パケット、OpenPGPのメッセージ、署名パケット対応。"
    },
    {
      "indent": 3,
      "text": "Signed Message :- Signature Packet, OpenPGP Message | One-Pass Signed Message.",
      "ja": "署名付きメッセージ： - 署名パケット、OpenPGPのメッセージ|ワンパス署名されたメッセージ。"
    },
    {
      "indent": 3,
      "text": "In addition, decrypting a Symmetrically Encrypted Data packet and",
      "ja": "また、対称的に暗号化されたデータパケットを復号化し、"
    },
    {
      "indent": 3,
      "text": "decompressing a Compressed Data packet must yield a valid OpenPGP Message.",
      "ja": "圧縮データパケットを解凍することは、有効なOpenPGPのメッセージを生成しなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.3. Detached Signatures",
      "section_title": true,
      "ja": "10.3。分離署名"
    },
    {
      "indent": 3,
      "text": "Some OpenPGP applications use so-called \"detached signatures.\" For example, a program bundle may contain a file, and with it a second file that is a detached signature of the first file. These detached signatures are simply a signature packet stored separately from the data that they are a signature of.",
      "ja": "いくつかのOpenPGPアプリケーションがいわゆる「分離署名」を使用します例えば、プログラム・バンドルは、最初のファイルの分離署名である第二のファイルのファイルを含み、それにすることができます。これら取り外し署名は単にそれらが署名されているデータとは別に格納された署名パケットです。"
    },
    {
      "indent": 0,
      "text": "11. Enhanced Key Formats",
      "section_title": true,
      "ja": "11.拡張キーの形式"
    },
    {
      "indent": 0,
      "text": "11.1. Key Structures",
      "section_title": true,
      "ja": "11.1。キー構造"
    },
    {
      "indent": 3,
      "text": "The format of an OpenPGP V3 key is as follows. Entries in square brackets are optional and ellipses indicate repetition.",
      "ja": "次のようにのOpenPGP V3キーのフォーマットがあります。角括弧内のエントリはオプションであり、楕円は繰り返しを示しています。"
    },
    {
      "indent": 11,
      "text": "RSA Public Key\n   [Revocation Self Signature]\n    User ID [Signature ...]\n   [User ID [Signature ...] ...]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each signature certifies the RSA public key and the preceding user ID. The RSA public key can have many user IDs and each user ID can have many signatures.",
      "ja": "各署名は、RSA公開鍵と前のユーザIDを証明します。 RSA公開鍵は、多くのユーザーIDを持つことができ、各ユーザーIDには、多くの署名を持つことができます。"
    },
    {
      "indent": 3,
      "text": "The format of an OpenPGP V4 key that uses two public keys is similar except that the other keys are added to the end as 'subkeys' of the primary key.",
      "ja": "2つのパブリックキーを使用したOpenPGP V4キーのフォーマットは、他のキーが主キーの「サブキー」として末端に付加されていることを除いて同様です。"
    },
    {
      "indent": 11,
      "text": "Primary-Key\n   [Revocation Self Signature]\n   [Direct Key Self Signature...]\n    User ID [Signature ...]\n   [User ID [Signature ...] ...]\n   [[Subkey [Binding-Signature-Revocation]\n           Primary-Key-Binding-Signature] ...]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A subkey always has a single signature after it that is issued using the primary key to tie the two keys together. This binding signature may be in either V3 or V4 format, but V4 is preferred, of course.",
      "ja": "サブキーには、常に一緒に2つのキーを結びつけるために、主キーを使用して発行され、それの後に単一の署名を持っています。この結合シグネチャは、V3またはV4フォーマットのいずれかであってもよいが、V4は、もちろん、好ましいです。"
    },
    {
      "indent": 3,
      "text": "In the above diagram, if the binding signature of a subkey has been revoked, the revoked binding signature may be removed, leaving only one signature.",
      "ja": "サブキーの結合署名が失効している場合、上記の図では、失効結合署名は唯一の署名を残して、除去することができます。"
    },
    {
      "indent": 3,
      "text": "In a key that has a main key and subkeys, the primary key MUST be a key capable of signing. The subkeys may be keys of any other type. There may be other constructions of V4 keys, too. For example, there may be a single-key RSA key in V4 format, a DSA primary key with an RSA encryption key, or RSA primary key with an Elgamal subkey, etc.",
      "ja": "主キーとサブキーを有するキーでは、主キーは、署名のキーことができなければなりません。サブキーは、他のタイプのキーであってもよいです。あまりにも、V4キーの他の構造があるかもしれません。例えば、V4形式、エルガマルサブキーとRSA暗号鍵とDSA主キー、又はRSA主キー、等に単一キーのRSAキーが存在してもよいです"
    },
    {
      "indent": 3,
      "text": "It is also possible to have a signature-only subkey. This permits a primary key that collects certifications (key signatures) but is used only used for certifying subkeys that are used for encryption and signatures.",
      "ja": "署名のみのサブキーを持つことも可能です。これは、認証（キー署名）を収集しますが、暗号化と署名に使用されているサブキーを証明するためにのみ使用使用されている主キーを可能にします。"
    },
    {
      "indent": 0,
      "text": "11.2. Key IDs and Fingerprints",
      "section_title": true,
      "ja": "11.2。鍵IDと指紋"
    },
    {
      "indent": 3,
      "text": "For a V3 key, the eight-octet key ID consists of the low 64 bits of the public modulus of the RSA key.",
      "ja": "V3キーに、8オクテットの鍵IDは、RSA鍵の公開率の低い64ビットから成ります。"
    },
    {
      "indent": 3,
      "text": "The fingerprint of a V3 key is formed by hashing the body (but not the two-octet length) of the MPIs that form the key material (public modulus n, followed by exponent e) with MD5.",
      "ja": "V3キーのフィンガープリントはMD5と（指数e続い公共モジュラスN）鍵材料を形成するのMPIの本体（ただし2オクテット長）をハッシュすることによって形成されています。"
    },
    {
      "indent": 3,
      "text": "A V4 fingerprint is the 160-bit SHA-1 hash of the one-octet Packet Tag, followed by the two-octet packet length, followed by the entire Public Key packet starting with the version field. The key ID is the low order 64 bits of the fingerprint. Here are the fields of the hash material, with the example of a DSA key:",
      "ja": "V4指紋は、バージョンフィールドから始まる全体の公開鍵パケットに続く2オクテットのパケット長に続く1オクテットパケットタグ、の160ビットSHA-1ハッシュです。鍵IDは指紋の64ビットの下位です。ここでDSAキーの例とハッシュ材料のフィールドは、以下のとおりです。"
    },
    {
      "indent": 2,
      "text": "a.1) 0x99 (1 octet)",
      "ja": "A.1）0x99（1つのオクテット）"
    },
    {
      "indent": 2,
      "text": "a.2) high order length octet of (b)-(f) (1 octet)",
      "ja": "（F）（1つのオクテット） - （B）のA.2）高次長オクテット"
    },
    {
      "indent": 2,
      "text": "a.3) low order length octet of (b)-(f) (1 octet)",
      "ja": "（B）のA.3）下位長オクテット - （F）（1つのオクテット）"
    },
    {
      "indent": 4,
      "text": "b) version number = 4 (1 octet);",
      "ja": "B）バージョン番号= 4（1オクテット）。"
    },
    {
      "indent": 4,
      "text": "c) time stamp of key creation (4 octets);",
      "ja": "キーの作成（4つのオクテット）のc）のタイムスタンプ。"
    },
    {
      "indent": 4,
      "text": "d) algorithm (1 octet): 17 = DSA (example);",
      "ja": "D）アルゴリズム（1つのオクテット）：17 = DSA（例）"
    },
    {
      "indent": 4,
      "text": "e) Algorithm specific fields.",
      "ja": "e）のアルゴリズム特定のフィールド。"
    },
    {
      "indent": 3,
      "text": "Algorithm Specific Fields for DSA keys (example):",
      "ja": "DSAキーのアルゴリズム特定フィールド（例）："
    },
    {
      "indent": 2,
      "text": "e.1) MPI of DSA prime p;",
      "ja": "DSA素数pのE.1）MPI。"
    },
    {
      "indent": 2,
      "text": "e.2) MPI of DSA group order q (q is a prime divisor of p-1);",
      "ja": "E.2）DSAグループ次数qのMPI（qはP-1）の主要な除数です。"
    },
    {
      "indent": 2,
      "text": "e.3) MPI of DSA group generator g;",
      "ja": "E.3）DSAグループジェネレータgのMPI。"
    },
    {
      "indent": 2,
      "text": "e.4) MPI of DSA public key value y (= g**x where x is secret).",
      "ja": "E.4）DSA公開鍵の値yのMPI（= G ** xは秘密であるX）。"
    },
    {
      "indent": 3,
      "text": "Note that it is possible for there to be collisions of key IDs -- two different keys with the same key ID. Note that there is a much smaller, but still non-zero probability that two different keys have the same fingerprint.",
      "ja": "同じキーIDを持つ2つの異なるキー - 鍵IDの衝突が存在することが可能であることに注意してください。二つの異なるキーが同じ指紋を持っていることをはるかに小さいが、それでもゼロでない可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Also note that if V3 and V4 format keys share the same RSA key material, they will have different key ids as well as different fingerprints.",
      "ja": "また、V3とV4形式キーが同じRSAキーマテリアルを共有している場合、それらは異なる鍵IDならびに異なる指紋を持っていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "12. Notes on Algorithms",
      "section_title": true,
      "ja": "アルゴリズム12.注意事項"
    },
    {
      "indent": 0,
      "text": "12.1. Symmetric Algorithm Preferences",
      "section_title": true,
      "ja": "12.1。対称アルゴリズムの設定"
    },
    {
      "indent": 3,
      "text": "The symmetric algorithm preference is an ordered list of algorithms that the keyholder accepts. Since it is found on a self-signature, it is possible that a keyholder may have different preferences. For example, Alice may have TripleDES only specified for \"alice@work.com\" but CAST5, Blowfish, and TripleDES specified for \"alice@home.org\".",
      "ja": "対称アルゴリズムの好みはキーホルダーが受け入れるアルゴリズムの順序付きリストです。それは、自己署名に見つけられるので、キーホルダーが異なる好みを有する可能性があります。例えば、アリスは「alice@home.org」に指定しただけで、「alice@work.com」が、CAST5、Blowfishのために指定されたトリプルDES、およびトリプルDESを有することができます。"
    },
    {
      "indent": 3,
      "text": "Note that it is also possible for preferences to be in a subkey's binding signature.",
      "ja": "好みがサブキーの結合署名でもすることも可能であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Since TripleDES is the MUST-implement algorithm, if it is not explicitly in the list, it is tacitly at the end. However, it is good form to place it there explicitly. Note also that if an implementation does not implement the preference, then it is implicitly a TripleDES-only implementation.",
      "ja": "TripleDESはMUST-実装するアルゴリズムであるので、それはリストに明示的でない場合、それは終わりで暗黙です。しかし、明示的にそこにそれを置くために良い形です。実装は好みを実装していない場合にも注意してください、それは暗黙的にトリプルDESのみの実装であること。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST not use a symmetric algorithm that is not in the recipient's preference list. When encrypting to more than one recipient, the implementation finds a suitable algorithm by taking the intersection of the preferences of the recipients. Note that the MUST-implement algorithm, TripleDES, ensures that the intersection is not null. The implementation may use any mechanism to pick an algorithm in the intersection.",
      "ja": "実装は、受信者の優先リストにない対称アルゴリズムを使用してはいけません。複数の受信者に暗号化する場合、実装は、受信者の好みの交差点を取ることによって、適切なアルゴリズムを発見します。 MUST-実装するアルゴリズム、トリプルDESは、交差点がnullでないことを保証することに注意してください。実装は、交差点におけるアルゴリズムを選択する任意の機構を使用することができます。"
    },
    {
      "indent": 3,
      "text": "If an implementation can decrypt a message that a keyholder doesn't have in their preferences, the implementation SHOULD decrypt the message anyway, but MUST warn the keyholder than protocol has been violated. (For example, suppose that Alice, above, has software that implements all algorithms in this specification. Nonetheless, she prefers subsets for work or home. If she is sent a message encrypted with IDEA, which is not in her preferences, the software warns her that someone sent her an IDEA-encrypted message, but it would ideally decrypt it anyway.)",
      "ja": "実装はキーホルダーが自分の好みではありませんメッセージを復号化できた場合、実装はとにかくメッセージを解読する必要がありますが、プロトコルが違反しているよりも、キーホルダーに警告しなければなりません。 （例えば、アリスは、上記のように、この仕様ではすべてのアルゴリズムを実装するソフトウェアを持っていることとします。それにもかかわらず、彼女は仕事や家庭のためのサブセットを好む。彼女は彼女の好みではありませんIDEAで暗号化されたメッセージを、送信された場合、ソフトウェアは警告します彼女は、誰かが彼女にIDEAで暗号化されたメッセージを送っていることが、それは理想的にとにかくそれを解読するでしょう。）"
    },
    {
      "indent": 3,
      "text": "An implementation that is striving for backward compatibility MAY consider a V3 key with a V3 self-signature to be an implicit preference for IDEA, and no ability to do TripleDES. This is technically non-compliant, but an implementation MAY violate the above rule in this case only and use IDEA to encrypt the message, provided that the message creator is warned. Ideally, though, the implementation would follow the rule by actually generating two messages, because it is possible that the OpenPGP user's implementation does not have IDEA, and thus could not read the message. Consequently, an implementation MAY, but SHOULD NOT use IDEA in an algorithm conflict with a V3 key.",
      "ja": "下位互換性のために努力している実装は、IDEAのための暗黙の好み、とのTripleDESを行うには能力があることをV3自己署名付きV3のキーを考慮することができます。これは技術的には非対応ですが、実装はこの場合のみ上記のルールに違反してメッセージを暗号化するためにIDEAを使用することができるが、メッセージ作成者が警告していることを条件とします。理想的には、しかし、実装は、OpenPGPのユーザーの実装はIDEAを持っていない可能性があるので、実際には2つのメッセージを生成することによって、ルールに従ってしまうため、メッセージを読むことができませんでした。その結果、実装かもしれないが、V3キーとアルゴリズムの競合にIDEAを使用しないでください。"
    },
    {
      "indent": 0,
      "text": "12.2. Other Algorithm Preferences",
      "section_title": true,
      "ja": "12.2。その他のアルゴリズム設定"
    },
    {
      "indent": 3,
      "text": "Other algorithm preferences work similarly to the symmetric algorithm preference, in that they specify which algorithms the keyholder accepts. There are two interesting cases that other comments need to be made about, though, the compression preferences and the hash preferences.",
      "ja": "彼らはキーホルダーが受け入れるアルゴリズムを指定その他のアルゴリズムの嗜好は、対称アルゴリズム嗜好と同様に動作します。 2興味深い例は、他のコメントが、しかし、圧縮好みやハッシュの好みについてなされる必要があることがあります。"
    },
    {
      "indent": 0,
      "text": "12.2.1. Compression Preferences",
      "section_title": true,
      "ja": "12.2.1。圧縮設定"
    },
    {
      "indent": 3,
      "text": "Compression has been an integral part of PGP since its first days. OpenPGP and all previous versions of PGP have offered compression. And in this specification, the default is for messages to be compressed, although an implementation is not required to do so. Consequently, the compression preference gives a way for a keyholder to request that messages not be compressed, presumably because they are using a minimal implementation that does not include compression. Additionally, this gives a keyholder a way to state that it can support alternate algorithms.",
      "ja": "圧縮は、その最初の日以来、PGPの不可欠な一部となっています。 OpenPGPとPGPのすべての以前のバージョンでは、圧縮を提供してきました。実装はそうする必要はありませんが、この仕様では、デフォルトでは、圧縮されるメッセージです。これにより、圧縮選好は、それらが圧縮を含まない最小限の実装を使用しているので、おそらくメッセージは、圧縮されていない要求にキーホルダーのための方法を提供します。また、これはキーホルダーにそれは別のアルゴリズムをサポートできることを述べるための方法を提供します。"
    },
    {
      "indent": 3,
      "text": "Like the algorithm preferences, an implementation MUST NOT use an algorithm that is not in the preference vector. If the preferences are not present, then they are assumed to be [ZIP(1), UNCOMPRESSED(0)].",
      "ja": "アルゴリズムの好みのように、実装は、嗜好ベクトルではないアルゴリズムを使用してはなりません。選好が存在しない場合、それらは、[ZIP（1）、圧縮解除（0）]であると仮定されます。"
    },
    {
      "indent": 0,
      "text": "12.2.2. Hash Algorithm Preferences",
      "section_title": true,
      "ja": "12.2.2。アルゴリズムの設定をハッシュ"
    },
    {
      "indent": 3,
      "text": "Typically, the choice of a hash algorithm is something the signer does, rather than the verifier, because a signer does not typically know who is going to be verifying the signature. This preference, though, allows a protocol based upon digital signatures ease in negotiation.",
      "ja": "署名者は、一般的に署名を検証しようとしている人を知っていないため、一般的には、ハッシュアルゴリズムの選択は、むしろ検証よりも、署名者が行う何か、です。この設定は、しかし、交渉におけるデジタル署名の容易さに基づくプロトコルを可能にします。"
    },
    {
      "indent": 3,
      "text": "Thus, if Alice is authenticating herself to Bob with a signature, it makes sense for her to use a hash algorithm that Bob's software uses. This preference allows Bob to state in his key which algorithms Alice may use.",
      "ja": "アリスが署名してボブに自分自身を認証している場合、彼女はボブのソフトウェアが使用するハッシュアルゴリズムを使用するためにこのように、それは理にかなっています。この設定は、ボブがアリスが使用する可能性アルゴリズムの彼のキーに述べることができます。"
    },
    {
      "indent": 0,
      "text": "12.3. Plaintext",
      "section_title": true,
      "ja": "12.3。プレーンテキスト"
    },
    {
      "indent": 3,
      "text": "Algorithm 0, \"plaintext\", may only be used to denote secret keys that are stored in the clear. Implementations must not use plaintext in Symmetrically Encrypted Data Packets; they must use Literal Data Packets to encode unencrypted or literal data.",
      "ja": "アルゴリズム0、「平文」は、唯一明らかに保存されている秘密鍵を示すために使用されてもよいです。実装は対称的に暗号化データパケットに平文を使用してはなりません。彼らは暗号化されていないか、リテラルデータをエンコードするためにリテラルデータパケットを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "12.4. RSA",
      "section_title": true,
      "ja": "12.4。 RSA"
    },
    {
      "indent": 3,
      "text": "There are algorithm types for RSA-signature-only, and RSA-encrypt-only keys. These types are deprecated. The \"key flags\" subpacket in a signature is a much better way to express the same idea, and generalizes it to all algorithms. An implementation SHOULD NOT create such a key, but MAY interpret it.",
      "ja": "そこRSA署名のみのためのアルゴリズムのタイプがあり、RSA暗号化専用鍵。これらのタイプは推奨されません。署名で「キーフラグ」のサブパケットは、同じ考えを表現するより良い方法であり、すべてのアルゴリズムにそれを一般化します。実装は、このようなキーを作成することはできませんが、それを解釈するかもしれません。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT implement RSA keys of size less than 768 bits.",
      "ja": "実装は768ビット未満のサイズのRSA鍵を実装すべきではありません。"
    },
    {
      "indent": 3,
      "text": "It is permissible for an implementation to support RSA merely for backward compatibility; for example, such an implementation would support V3 keys with IDEA symmetric cryptography. Note that this is an exception to the other MUST-implement rules. An implementation that supports RSA in V4 keys MUST implement the MUST-implement features.",
      "ja": "実装は単に下位互換性のためにRSAをサポートすることは許されて。例えば、そのような実装は、IDEA、対称暗号とV3キーをサポートします。これは他のMUST-実装ルールの例外であることに注意してください。 V4キーでRSAをサポートする実装はMUST-実装する機能を実装しなければなりません。"
    },
    {
      "indent": 0,
      "text": "12.5. Elgamal",
      "section_title": true,
      "ja": "12.5。エルガマル"
    },
    {
      "indent": 3,
      "text": "If an Elgamal key is to be used for both signing and encryption, extra care must be taken in creating the key.",
      "ja": "エルガマル鍵は署名と暗号化の両方に使用する場合は、細心の注意は、キーを作成する際に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "An ElGamal key consists of a generator g, a prime modulus p, a secret exponent x, and a public value y = g^x mod p.",
      "ja": "エルガマルキーは生成元g、素数モジュラスp、秘密指数X、及び公共の値y = G ^ X MOD Pから成ります。"
    },
    {
      "indent": 3,
      "text": "The generator and prime must be chosen so that solving the discrete log problem is intractable. The group g should generate the multiplicative group mod p-1 or a large subgroup of it, and the order of g should have at least one large prime factor. A good choice is to use a \"strong\" Sophie-Germain prime in choosing p, so that both p and (p-1)/2 are primes. In fact, this choice is so good that implementors SHOULD do it, as it avoids a small subgroup attack.",
      "ja": "離散対数問題を解決することは難治性であるように、発電機と首相が選ばれなければなりません。グループGは乗法群のmod P-1またはその大きなサブグループを生成する必要があり、及びGの順序は、少なくとも一つの大きな素因数を有するべきです。良い選択は、両方のpと（P-1）/ 2が素数になるように、Pを選択する際に「強い」ソフィー・ジェルマン素数を使用することです実際には、この選択は、それが小さなサブグループ攻撃を避けるよう実装者は、それを行う必要がありますように良いです。"
    },
    {
      "indent": 3,
      "text": "In addition, a result of Bleichenbacher [BLEICHENBACHER] shows that if the generator g has only small prime factors, and if g divides the order of the group it generates, then signatures can be forged. In particular, choosing g=2 is a bad choice if the group order may be even. On the other hand, a generator of 2 is a fine choice for an encryption-only key, as this will make the encryption faster.",
      "ja": "また、Bleichenbacherの[Bleichenbacherの]の結果は、発電機Gが少ない素因数を有するならば、Gは、それが生成するグループの順序を分割する場合、署名が偽造することができることを示しています。グループ順序が偶数であってもよい場合、特に、G = 2を選択することが悪い選択です。一方、2の発電機は、これが速い暗号化を行いますと、暗号化キーだけの罰金選択肢です。"
    },
    {
      "indent": 3,
      "text": "While verifying Elgamal signatures, note that it is important to test that r and s are less than p. If this test is not done then signatures can be trivially forged by using large r values of approximately twice the length of p. This attack is also discussed in the Bleichenbacher paper.",
      "ja": "ElGamal署名を確認しながら、rとsがP未満でテストすることが重要であることに注意。このテストが行​​われない場合、シグネチャは自明Pの約2倍の長さの大きなR値を用いて偽造することができます。この攻撃は、Bleichenbacherの論文で説明されています。"
    },
    {
      "indent": 3,
      "text": "Details on safe use of Elgamal signatures may be found in [MENEZES], which discusses all the weaknesses described above.",
      "ja": "エルガマル署名の安全な使用に関する詳細は、上記のすべての弱点を説明した、[メネゼス]に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "If an implementation allows Elgamal signatures, then it MUST use the algorithm identifier 20 for an Elgamal public key that can sign.",
      "ja": "実装はエルガマル署名を許可している場合、それは署名することができはElgamal公開鍵アルゴリズム識別子20を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT implement Elgamal keys of size less than 768 bits. For long-term security, Elgamal keys should be 1024 bits or longer.",
      "ja": "実装は768ビット未満のサイズののElGamal鍵を実装すべきではありません。長期的なセキュリティのために、エルガマルキーが1024ビット以上でなければなりません。"
    },
    {
      "indent": 0,
      "text": "12.6. DSA",
      "section_title": true,
      "ja": "12.6。 DSA"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD NOT implement DSA keys of size less than 768 bits. Note that present DSA is limited to a maximum of 1024 bit keys, which are recommended for long-term use.",
      "ja": "実装は768ビット未満のサイズのDSA鍵を実装すべきではありません。本DSAは、長期の使用に推奨される1024ビットキーの最大値に制限されることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "12.7. Reserved Algorithm Numbers",
      "section_title": true,
      "ja": "12.7。予約済みアルゴリズム番号"
    },
    {
      "indent": 3,
      "text": "A number of algorithm IDs have been reserved for algorithms that would be useful to use in an OpenPGP implementation, yet there are issues that prevent an implementor from actually implementing the algorithm. These are marked in the Public Algorithms section as \"(reserved for)\".",
      "ja": "アルゴリズムIDの数は、OpenPGPの実装で使用するのに有用であろうアルゴリズムのために予約されているが、まだ実際にアルゴリズムを実装から実装を妨げる問題があります。これらは、「（のために予約）」として公開アルゴリズムセクションにマークされています。"
    },
    {
      "indent": 3,
      "text": "The reserved public key algorithms, Elliptic Curve (18), ECDSA (19), and X9.42 (21) do not have the necessary parameters, parameter order, or semantics defined.",
      "ja": "予約済み公開鍵アルゴリズム、楕円曲線（18）、ECDSA（19）、及びX9.42（21）は、定義された必要なパラメータ、パラメータの順序、または意味を持ちません。"
    },
    {
      "indent": 3,
      "text": "The reserved symmetric key algorithm, DES/SK (6), does not have semantics defined.",
      "ja": "予約された共通鍵暗号、DES / SKは（6）、定義された意味を持っていません。"
    },
    {
      "indent": 3,
      "text": "The reserved hash algorithms, TIGER192 (6), and HAVAL-5-160 (7), do not have OIDs. The reserved algorithm number 4, reserved for a double-width variant of SHA1, is not presently defined.",
      "ja": "予約されたハッシュアルゴリズム、TIGER192（6）、およびHAVAL-5-160（7）、OIDを持っていません。 SHA1のダブル幅の変形のために予約予約アルゴリズム番号4は、現在定義されていません。"
    },
    {
      "indent": 3,
      "text": "We have reserver three algorithm IDs for the US NIST's Advanced Encryption Standard. This algorithm will work with (at least) 128, 192, and 256-bit keys. We expect that this algorithm will be selected from the candidate algorithms in the year 2000.",
      "ja": "私たちは、米国のNISTの高度暗号化標準のためのリザーバー3つのアルゴリズムのIDを持っています。このアルゴリズムは、192、128（少なくとも）、および256ビットの鍵で動作します。私たちは、このアルゴリズムは、2000年に候補アルゴリズムから選択されることを期待しています。"
    },
    {
      "indent": 0,
      "text": "12.8. OpenPGP CFB mode",
      "section_title": true,
      "ja": "12.8。 OpenPGPのCFBモード"
    },
    {
      "indent": 3,
      "text": "OpenPGP does symmetric encryption using a variant of Cipher Feedback Mode (CFB mode). This section describes the procedure it uses in detail. This mode is what is used for Symmetrically Encrypted Data Packets; the mechanism used for encrypting secret key material is similar, but described in those sections above.",
      "ja": "OpenPGPのは、暗号フィードバックモード（CFBモード）のバリアントを使用して対称暗号化を行います。このセクションでは、それが具体的に使用する手順を説明します。このモードは、対称的に暗号化データパケットのために使用されるものです。秘密鍵を暗号化するために使用されるメカニズムは類似しているが、上記のもののセクションで説明しました。"
    },
    {
      "indent": 3,
      "text": "OpenPGP CFB mode uses an initialization vector (IV) of all zeros, and prefixes the plaintext with ten octets of random data, such that octets 9 and 10 match octets 7 and 8. It does a CFB \"resync\" after encrypting those ten octets.",
      "ja": "OpenPGPのCFBモードでは、すべてゼロの初期化ベクトル（IV）を使用し、ランダムデータの10個のオクテットで平文をプレフィックス、オクテット9,10一致オクテット7および8は、それがこれらの10個のオクテットを暗号化した後、CFB「リシンク」がないようにします。"
    },
    {
      "indent": 3,
      "text": "Note that for an algorithm that has a larger block size than 64 bits, the equivalent function will be done with that entire block. For example, a 16-octet block algorithm would operate on 16 octets, and then produce two octets of check, and then work on 16-octet blocks.",
      "ja": "64ビットよりも大きいブロックサイズを有するアルゴリズムに対して、同等の機能は、そのブロック全体で行われることに留意されたいです。例えば、16オクテットのブロックアルゴリズムは、16個のオクテットで動作し、そして、チェックの2つのオクテットを生成し、次いで、16オクテットブロックに働くだろう。"
    },
    {
      "indent": 3,
      "text": "Step by step, here is the procedure:",
      "ja": "ステップバイステップで、ここでの手順は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The feedback register (FR) is set to the IV, which is all zeros.",
      "section_title": true,
      "ja": "1.フィードバックレジスタ（FR）がすべてゼロであるIV、に設定されています。"
    },
    {
      "indent": 3,
      "text": "2. FR is encrypted to produce FRE (FR Encrypted). This is the encryption of an all-zero value.",
      "ja": "2. FRは、FRE（FR暗号化）を生成するために暗号化されています。これは、すべてのゼロ値の暗号化です。"
    },
    {
      "indent": 3,
      "text": "3. FRE is xored with the first 8 octets of random data prefixed to the plaintext to produce C1-C8, the first 8 octets of ciphertext.",
      "ja": "3. FREはC1-C8、暗号文の最初の8つのオクテットを生成するために、平文に接頭ランダムデータの最初の8つのオクテットとXORされます。"
    },
    {
      "indent": 3,
      "text": "4. FR is loaded with C1-C8.",
      "section_title": true,
      "ja": "4. FRは、C1-C8がロードされています。"
    },
    {
      "indent": 3,
      "text": "5. FR is encrypted to produce FRE, the encryption of the first 8 octets of ciphertext.",
      "ja": "5. FRはFRE、暗号文の最初の8つのオクテットの暗号化を生成するために暗号化されています。"
    },
    {
      "indent": 3,
      "text": "6. The left two octets of FRE get xored with the next two octets of data that were prefixed to the plaintext. This produces C9-C10, the next two octets of ciphertext.",
      "ja": "6. FREの左の2つのオクテットは、平文の前に付けられたデータの次の2つのオクテットとXORます。これは、C9-C10、暗号文の次の2つのオクテットを生成します。"
    },
    {
      "indent": 3,
      "text": "7. (The resync step) FR is loaded with C3-C10.",
      "section_title": true,
      "ja": "7.（再同期ステップ）FRは、C3-C10がロードされます。"
    },
    {
      "indent": 3,
      "text": "8. FR is encrypted to produce FRE.",
      "section_title": true,
      "ja": "8. FRは、FREを生産するために暗号化されています。"
    },
    {
      "indent": 3,
      "text": "9. FRE is xored with the first 8 octets of the given plaintext, now that we have finished encrypting the 10 octets of prefixed data. This produces C11-C18, the next 8 octets of ciphertext.",
      "ja": "9. FREは、今私たちが先頭にデータの10オクテットの暗号化が終了したことを、与えられた平文の最初の8つのオクテットとXORされます。これは、C11-C18、暗号文の次の8オクテットを生成します。"
    },
    {
      "indent": 3,
      "text": "10. FR is loaded with C11-C18",
      "section_title": true,
      "ja": "10. FRは、C11-C18がロードされています"
    },
    {
      "indent": 3,
      "text": "11. FR is encrypted to produce FRE.",
      "section_title": true,
      "ja": "11. FRは、FREを生産するために暗号化されています。"
    },
    {
      "indent": 3,
      "text": "12. FRE is xored with the next 8 octets of plaintext, to produce the next 8 octets of ciphertext. These are loaded into FR and the process is repeated until the plaintext is used up.",
      "ja": "12. FREは、暗号文の次の8つのオクテットを生成するために、平文の次の8つのオクテットとXORされます。これらは、FRにロードされ、平文が使い果たされるまで、プロセスが繰り返されます。"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "As with any technology involving cryptography, you should check the current literature to determine if any algorithms used here have been found to be vulnerable to attack.",
      "ja": "暗号化を含む任意の技術と同じように、あなたはここで使用される任意のアルゴリズムが攻撃に対して脆弱であることが判明しているかどうかを判断するために現在の文献を確認してください。"
    },
    {
      "indent": 3,
      "text": "This specification uses Public Key Cryptography technologies. Possession of the private key portion of a public-private key pair is assumed to be controlled by the proper party or parties.",
      "ja": "この仕様は、公開鍵暗号技術を使用しています。公開鍵と秘密鍵のペアの秘密鍵部分の所持は、適切な当事者によって制御されているものとします。"
    },
    {
      "indent": 3,
      "text": "Certain operations in this specification involve the use of random numbers. An appropriate entropy source should be used to generate these numbers. See RFC 1750.",
      "ja": "本明細書における特定の操作は、乱数の使用を含みます。適切なエントロピー源は、これらの番号を生成するために使用する必要があります。 RFC 1750を参照してください。"
    },
    {
      "indent": 3,
      "text": "The MD5 hash algorithm has been found to have weaknesses (pseudo-collisions in the compress function) that make some people deprecate its use. They consider the SHA-1 algorithm better.",
      "ja": "MD5ハッシュアルゴリズムは、一部の人々は、その使用を非推奨にする（圧縮関数の擬似衝突）弱点を持っていることが判明しています。彼らは、より良いSHA-1アルゴリズムを検討してください。"
    },
    {
      "indent": 3,
      "text": "Many security protocol designers think that it is a bad idea to use a single key for both privacy (encryption) and integrity (signatures). In fact, this was one of the motivating forces behind the V4 key format with separate signature and encryption keys. If you as an implementor promote dual-use keys, you should at least be aware of this controversy.",
      "ja": "多くのセキュリティプロトコルの設計者は、プライバシー（暗号化）と整合性（署名）の両方のための単一のキーを使用することが悪いアイデアだと思います。実際には、これは個別の署名と暗号化キーでV4キーの形式の背後にある動機力の一つでした。あなたが実装者としてのデュアルユースの鍵を宣伝する場合は、少なくとも、この論争に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "The DSA algorithm will work with any 160-bit hash, but it is sensitive to the quality of the hash algorithm, if the hash algorithm is broken, it can leak the secret key. The Digital Signature Standard (DSS) specifies that DSA be used with SHA-1. RIPEMD-160 is considered by many cryptographers to be as strong. An implementation should take care which hash algorithms are used with DSA, as a weak hash can not only allow a signature to be forged, but could leak the secret key. These same considerations about the quality of the hash algorithm apply to Elgamal signatures.",
      "ja": "DSAアルゴリズムは、任意の160ビットハッシュで動作しますが、それはハッシュアルゴリズムが壊れている場合は、秘密鍵を漏らすことができ、ハッシュアルゴリズムの品質に敏感です。デジタル署名標準（DSS）は、DSAはSHA-1を使用することを指定します。 RIPEMD-160はとして強いと多くの暗号学者によって考えられています。弱いハッシュが署名を偽造することを許可することができないだけではなく、秘密鍵を漏らす可能性があるので実装は、ハッシュアルゴリズムがDSAで使用されて世話をする必要があります。ハッシュアルゴリズムの品質に関するこれらの同じ考慮事項がエルガマル署名に適用されます。"
    },
    {
      "indent": 3,
      "text": "If you are building an authentication system, the recipient may specify a preferred signing algorithm. However, the signer would be foolish to use a weak algorithm simply because the recipient requests it.",
      "ja": "あなたが認証システムを構築している場合、受信者は、好適な署名アルゴリズムを指定することもできます。しかし、署名者は、受信者がそれを要求しているため、単純に弱いアルゴリズムを使用する愚かなことです。"
    },
    {
      "indent": 3,
      "text": "Some of the encryption algorithms mentioned in this document have been analyzed less than others. For example, although CAST5 is presently considered strong, it has been analyzed less than Triple-DES. Other algorithms may have other controversies surrounding them.",
      "ja": "この文書に記載された暗号化アルゴリズムのいくつかは他よりも少ない分析されています。 CAST5が現在強いと考えられているが、例えば、それは、トリプルDESよりも少ない分析されています。他のアルゴリズムは、それらを囲む他の論争を有することができます。"
    },
    {
      "indent": 3,
      "text": "Some technologies mentioned here may be subject to government control in some countries.",
      "ja": "ここで言及したいくつかの技術は、いくつかの国では、政府のコントロールを受ける可能性があります。"
    },
    {
      "indent": 0,
      "text": "14. Implementation Nits",
      "section_title": true,
      "ja": "14.実装ニト"
    },
    {
      "indent": 3,
      "text": "This section is a collection of comments to help an implementer, particularly with an eye to backward compatibility. Previous implementations of PGP are not OpenPGP-compliant. Often the differences are small, but small differences are frequently more vexing than large differences. Thus, this list of potential problems and gotchas for a developer who is trying to be backward-compatible.",
      "ja": "このセクションでは、特に、下位互換性に目で、実装を支援するコメントのコレクションです。 PGPの前の実装では、OpenPGPのに準拠していません。多くの場合、違いは小さいですが、小さな違いが頻繁に大きな差よりも厄介です。このように、下位互換性があるようにしようとしている開発者のための潜在的な問題や落とし穴のリスト。"
    },
    {
      "indent": 5,
      "text": "* PGP 5.x does not accept V4 signatures for anything other than key material.",
      "ja": "* PGP 5.xのは、鍵材料以外の何のためのV4署名を受け付けません。"
    },
    {
      "indent": 5,
      "text": "* PGP 5.x does not recognize the \"five-octet\" lengths in new-format headers or in signature subpacket lengths.",
      "ja": "* PGP 5.xでは、新しい形式のヘッダや署名サブパケットの長さに「5オクテット」の長さを認識しません。"
    },
    {
      "indent": 5,
      "text": "* PGP 5.0 rejects an encrypted session key if the keylength differs from the S2K symmetric algorithm. This is a bug in its validation function.",
      "ja": "キー長がS2K対称アルゴリズムと異なる場合* PGP 5.0は、暗号化されたセッション鍵を拒否します。これは、その検証機能のバグです。"
    },
    {
      "indent": 5,
      "text": "* PGP 5.0 does not handle multiple one-pass signature headers and trailers. Signing one will compress the one-pass signed literal and prefix a V3 signature instead of doing a nested one-pass signature.",
      "ja": "* PGP 5.0は、複数のワンパス署名ヘッダとトレーラを処理しません。 1は1パスリテラル署名圧縮し、ネストされた1パスの署名をしているのではなく、V3署名を接頭辞ます署名。"
    },
    {
      "indent": 5,
      "text": "* When exporting a private key, PGP 2.x generates the header \"BEGIN PGP SECRET KEY BLOCK\" instead of \"BEGIN PGP PRIVATE KEY BLOCK\". All previous versions ignore the implied data type, and look directly at the packet data type.",
      "ja": "秘密鍵をエクスポートする場合*、PGP 2.xでは、ヘッダではなく、 \"BEGIN PGP PRIVATE KEY BLOCK\" の \"PGP SECRET KEY BLOCKをBEGIN\" が生成されます。すべての以前のバージョンでは、暗黙のデータ型を無視して、パケット・データ・タイプを直接見。"
    },
    {
      "indent": 5,
      "text": "* In a clear-signed signature, PGP 5.0 will figure out the correct hash algorithm if there is no \"Hash:\" header, but it will reject a mismatch between the header and the actual algorithm used. The \"standard\" (i.e. Zimmermann/Finney/et al.) version of PGP 2.x rejects the \"Hash:\" header and assumes MD5. There are a number of enhanced variants of PGP 2.6.x that have been modified for SHA-1 signatures.",
      "ja": "*クリア署名署名は、何「ハッシュ」が存在しない場合PGP 5.0は正しいハッシュアルゴリズムを把握しますヘッダは、それはヘッダおよび使用される実際のアルゴリズムとの間のミスマッチを拒否します。 PGP 2.xのの「標準」（すなわち、ツィンマーマン/フィニー/ら）のバージョンは「ハッシュ：」拒否ヘッダとMD5を想定しています。 SHA-1署名のために変更されたPGP 2.6.xのの増強された変異体の数があります。"
    },
    {
      "indent": 5,
      "text": "* PGP 5.0 can read an RSA key in V4 format, but can only recognize it with a V3 keyid, and can properly use only a V3 format RSA key.",
      "ja": "* PGP 5.0は、V4形式のRSAキーを読み取ることができますが、唯一のV3の鍵IDとそれを認識することができ、かつ適切のみV3形式RSAキーを使用することができます。"
    },
    {
      "indent": 5,
      "text": "* Neither PGP 5.x nor PGP 6.0 recognize Elgamal Encrypt and Sign keys. They only handle Elgamal Encrypt-only keys.",
      "ja": "*どちらもPGP 5.xのもPGP 6.0ははElgamal暗号化を認識し、鍵に署名します。彼らは唯一のはElgamal暗号化専用キーを処理します。"
    },
    {
      "indent": 5,
      "text": "* There are many ways possible for two keys to have the same key material, but different fingerprints (and thus key ids). Perhaps the most interesting is an RSA key that has been \"upgraded\" to V4 format, but since a V4 fingerprint is constructed by hashing the key creation time along with other things, two V4 keys created at different times, yet with the same key material will have different fingerprints.",
      "ja": "*同じキー材料が、異なる指紋（したがって、キーID）を持つための2つのキーのための可能な多くの方法があります。おそらく最も興味深いのは、V4形式に「アップグレード」されていますが、V4の指紋が他のものと一緒にキー作成時間をハッシュすることによって構成されているため、異なる時間に作成された2つのV4キー、まだ同じ鍵材料とRSAキーです異なる指紋を持つことになります。"
    },
    {
      "indent": 5,
      "text": "* If an implementation is using zlib to interoperate with PGP 2.x, then the \"windowBits\" parameter should be set to -13.",
      "ja": "実装がPGP 2.xのと相互運用するためにzlibを使用している場合*、その後、「windowBits」パラメータは-13に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "15. Authors and Working Group Chair",
      "section_title": true,
      "ja": "15.著者とワーキンググループ議長"
    },
    {
      "indent": 3,
      "text": "The working group can be contacted via the current chair:",
      "ja": "現在のいすを通してワーキンググループに連絡することができます。"
    },
    {
      "indent": 3,
      "text": "John W. Noerenberg, II Qualcomm, Inc 6455 Lusk Blvd San Diego, CA 92131 USA",
      "ja": "ジョン・W. Noerenberg、II韓国コム株式会社6455ラスクブルバードサンディエゴ、CA 92131 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 619-658-3510 EMail: jwn2@qualcomm.com",
      "ja": "電話：+1 619-658-3510電子メール：jwn2@qualcomm.com"
    },
    {
      "indent": 3,
      "text": "The principal authors of this memo are:",
      "ja": "このメモの主な著者は、以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Jon Callas Network Associates, Inc. 3965 Freedom Circle Santa Clara, CA 95054, USA",
      "ja": "ジョン・カラスネットワークアソシエイツ株式会社3965自由サークルサンタクララ、CA 95054、USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408-346-5860 EMail: jon@pgp.com, jcallas@nai.com",
      "ja": "電話：+1 408-346-5860 Eメール：jon@pgp.com、jcallas@nai.com"
    },
    {
      "indent": 3,
      "text": "Lutz Donnerhacke IKS GmbH Wildenbruchstr. 15 07745 Jena, Germany",
      "ja": "ルッツDonnerhacke ICS社Wildenbruchstr。 15 07745イエナ、ドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49-3641-675642 EMail: lutz@iks-jena.de",
      "ja": "電話：+ 49-3641-675642電子メール：lutz@iks-jena.de"
    },
    {
      "indent": 3,
      "text": "Hal Finney Network Associates, Inc. 3965 Freedom Circle Santa Clara, CA 95054, USA",
      "ja": "ハル・フィニーネットワークアソシエイツ株式会社3965自由サークルサンタクララ、CA 95054、USA"
    },
    {
      "indent": 3,
      "text": "EMail: hal@pgp.com",
      "ja": "メールアドレス：hal@pgp.com"
    },
    {
      "indent": 3,
      "text": "Rodney Thayer EIS Corporation Clearwater, FL 33767, USA",
      "ja": "ロドニーセイヤーEIS株式会社クリアウォーター、FL 33767、USA"
    },
    {
      "indent": 3,
      "text": "EMail: rodney@unitran.com",
      "ja": "メールアドレス：rodney@unitran.com"
    },
    {
      "indent": 3,
      "text": "This memo also draws on much previous work from a number of other authors who include: Derek Atkins, Charles Breed, Dave Del Torto, Marc Dyksterhouse, Gail Haspert, Gene Hoffman, Paul Hoffman, Raph Levien, Colin Plumb, Will Price, William Stallings, Mark Weaver, and Philip R. Zimmermann.",
      "ja": "また、このメモは含ま他の著者の数から多くの前の仕事に描画します：デレク・アトキンス、チャールズ品種、デイブ・デルTorto、マルク・Dyksterhouse、ゲイルHaspert、ジーン・ホフマン、ポール・ホフマン、ラフ・レビアン、コリン・プラム、ウィル価格、ウィリアム・ストーリングスを、マーク・ウィーバー、そしてフィリップ・R. Zimmermann氏。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16.参考文献"
    },
    {
      "indent": 3,
      "text": "[BLEICHENBACHER] Bleichenbacher, Daniel, \"Generating ElGamal signatures without knowing the secret key,\" Eurocrypt 96. Note that the version in the proceedings has an error. A revised version is available at the time of writing from <ftp://ftp.inf.ethz.ch/pub/publications/papers/ti/isc /ElGamal.ps>",
      "ja": "[Bleichenbacherの] Bleichenbacherの、ダニエル、手続におけるバージョンがエラーを持っていることをEUROCRYPT 96注意「の秘密鍵を、知らずの生成のElGamal署名」。改訂版は、<ftp://ftp.inf.ethz.ch/pub/publications/papers/ti/isc /ElGamal.ps>からの書き込みの時点で利用可能です"
    },
    {
      "indent": 3,
      "text": "[BLOWFISH] Schneier, B. \"Description of a New Variable-Length Key, 64-Bit Block Cipher (Blowfish)\" Fast Software Encryption, Cambridge Security Workshop Proceedings (December 1993), Springer-Verlag, 1994, pp191-204",
      "ja": "[フグ]シュナイアー、B.「新可変長キーの説明、64ビットブロック暗号（ふぐ）」高速ソフトウェア暗号化、ケンブリッジセキュリティワークショップ議事録（1993年12月）、シュプリンガー・フェアラーク、1994、pp191-204"
    },
    {
      "indent": 20,
      "text": "<http://www.counterpane.com/bfsverlag.html>",
      "ja": "＜ｈっｔｐ：／／ｗっｗ。こうんてｒぱね。こｍ／ｂｆｓゔぇｒぁｇ。ｈｔｍｌ＞"
    },
    {
      "indent": 3,
      "text": "[DONNERHACKE] Donnerhacke, L., et. al, \"PGP263in - an improved international version of PGP\", ftp://ftp.iks-jena.de/mitarb/lutz/crypt/software/pgp/",
      "ja": "【DONNERHACKE] Donnerhacke、L.、ら。ら、「PGP263in  - とPGPの改善国際版、」ftp://ftp.iks-jena.de/mitarb/lutz/crypt/software/pgp/"
    },
    {
      "indent": 3,
      "text": "[ELGAMAL] T. ElGamal, \"A Public-Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms,\" IEEE Transactions on Information Theory, v. IT-31, n. 4, 1985, pp. 469-472.",
      "ja": "【ELGAMAL] T.エルガマル、「公開鍵暗号や離散対数に基づく署名方式、」情報理論に関するIEEEトランザクション、V。IT-31、N。 4、1985、頁469-472。"
    },
    {
      "indent": 3,
      "text": "[IDEA] Lai, X, \"On the design and security of block ciphers\", ETH Series in Information Processing, J.L. Massey (editor), Vol. 1, Hartung-Gorre Verlag Knostanz, Technische Hochschule (Zurich), 1992",
      "ja": "情報処理における「ブロック暗号のデザインとセキュリティについて」[IDEA]ライ、X、ETHシリーズ、J。L.マッセイ（編集者）、巻。 1、アルトゥング-Gorre Verlag社Knostanz、TECHNISCHE音楽大学（チューリッヒ）、1992"
    },
    {
      "indent": 3,
      "text": "[ISO-10646] ISO/IEC 10646-1:1993. International Standard -- Information technology -- Universal Multiple-Octet Coded Character Set (UCS) -- Part 1: Architecture and Basic Multilingual Plane. UTF-8 is described in Annex R, adopted but not yet published. UTF-16 is described in Annex Q, adopted but not yet published.",
      "ja": "[ISO-10646] ISO / IEC 10646-1：1993。国際規格 - 情報技術 - ユニバーサルマルチオクテット符号化文字セット（UCS） - 第1部：アーキテクチャと基本多言語面。 UTF-8は、附属書Rに記述採用したがまだ公開されていません。 UTF-16は、附属書Qで説明した採用が、まだ公表されていません。"
    },
    {
      "indent": 3,
      "text": "[MENEZES] Alfred Menezes, Paul van Oorschot, and Scott Vanstone, \"Handbook of Applied Cryptography,\" CRC Press, 1996.",
      "ja": "[メネゼス]アルフレッド・メネゼス、ポール・バン・オアーショー、とスコット・バンストーン、「応用暗号のハンドブック」CRCプレス、1996。"
    },
    {
      "indent": 3,
      "text": "[RFC822] Crocker, D., \"Standard for the format of ARPA Internet text messages\", STD 11, RFC 822, August 1982.",
      "ja": "[RFC822]クロッカー、D.、 \"ARPAインターネットテキストメッセージの形式の規格\"、STD 11、RFC 822、1982年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1423] Balenson, D., \"Privacy Enhancement for Internet Electronic Mail: Part III: Algorithms, Modes, and Identifiers\", RFC 1423, October 1993.",
      "ja": "[RFC1423] Balenson、D.、 \"インターネット電子メールのためのプライバシー増進：パートIII：アルゴリズム、モード、および識別子\"、RFC 1423、1993年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1641] Goldsmith, D. and M. Davis, \"Using Unicode with MIME\", RFC 1641, July 1994.",
      "ja": "[RFC1641]ゴールドスミス、D。およびM.デイヴィス、 \"MIMEでUnicodeを使用する\"、RFC 1641、1994年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC1750] Eastlake, D., Crocker, S. and J. Schiller, \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[RFC1750]イーストレイク、D.、クロッカー、S.とJ.シラー、 \"セキュリティのためのランダム性に関する推奨事項\"、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1951] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3.\", RFC 1951, May 1996.",
      "ja": "[RFC1951]ドイツ、P.、 \"DEFLATE圧縮データフォーマット仕様バージョン1.3。\"、RFC 1951、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1983] Malkin, G., \"Internet Users' Glossary\", FYI 18, RFC 1983, August 1996.",
      "ja": "[RFC1983]マルキン、G.、 \"インターネットユーザーの用語集\"、FYI 18、RFC 1983、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1991] Atkins, D., Stallings, W. and P. Zimmermann, \"PGP Message Exchange Formats\", RFC 1991, August 1996.",
      "ja": "[RFC1991]アトキンス、D.、ストーリングス、W.およびP.ツィンマーマン、 \"PGPメッセージ交換フォーマット\"、RFC 1991、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2015] Elkins, M., \"MIME Security with Pretty Good Privacy (PGP)\", RFC 2015, October 1996.",
      "ja": "[RFC2015]エルキンズ、M.、 \"プリティグッドプライバシーとMIMEセキュリティ（PGP）\"、RFC 2015、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2231] Borenstein, N. and N. Freed, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies.\", RFC 2231, November 1996.",
      "ja": "[RFC2231] Borenstein、N.とN.フリード、 \"多目的インターネットメール拡張（MIME）第一部：インターネットメッセージ本体のフォーマット。\"、RFC 2231、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Level\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、BCP 14、RFC 2119、1997年3月 \"のRFCsにおける使用のためのキーワードは、要求レベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2144] Adams, C., \"The CAST-128 Encryption Algorithm\", RFC 2144, May 1997.",
      "ja": "[RFC2144]アダムス、C.、 \"CAST-128暗号化アルゴリズム\"、RFC 2144、1997年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2279] Yergeau., F., \"UTF-8, a transformation format of Unicode and ISO 10646\", RFC 2279, January 1998.",
      "ja": "[RFC2279] Yergeau。、F.、 \"UTF-8、UnicodeとISO 10646の変換フォーマット\"、RFC 2279、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2313] Kaliski, B., \"PKCS #1: RSA Encryption Standard version 1.5\", RFC 2313, March 1998.",
      "ja": "[RFC2313] Kaliski、B.、 \"PKCS＃1：RSA暗号化規格バージョン1.5\"、RFC 2313、1998年3月。"
    },
    {
      "indent": 3,
      "text": "[SAFER] Massey, J.L. \"SAFER K-64: One Year Later\", B. Preneel, editor, Fast Software Encryption, Second International Workshop (LNCS 1008) pp212-241, Springer-Verlag 1995",
      "ja": "[SAFER]マッセイ、J。L. \"SAFER K-64：一年後\"、B. Preneel、エディタ、高速ソフトウェア暗号化、第二に国際ワークショップ（LNCS 1008）pp212-241、シュプリンガー・フェアラーク1995"
    },
    {
      "indent": 0,
      "text": "17. Full Copyright Statement",
      "section_title": true,
      "ja": "17.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    }
  ]
}