{
  "title": {
    "text": "RFC 2203 - RPCSEC_GSS Protocol Specification",
    "ja": "RFC 2203 - RPCSEC_GSSプロトコル仕様"
  },
  "number": 2203,
  "created_at": "2019-10-17 22:36:20.760854+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          M. Eisler\nRequest for Comments: 2203                                       A. Chiu\nCategory: Standards Track                                        L. Ling\n                                                          September 1997",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "RPCSEC_GSS Protocol Specification",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements.  Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol.  Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo describes an ONC/RPC security flavor that allows RPC protocols to access the Generic Security Services Application Programming Interface (referred to henceforth as GSS-API).",
      "ja": "このメモは、RPCプロトコルは一般的なセキュリティサービスアプリケーションプログラミングインターフェイス（以下、GSS-APIと呼ばれる）にアクセスすることを可能にするONC / RPCセキュリティ風味を説明します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . . 2 2.  The ONC RPC Message Protocol . . . . . . . . . . . . . . . . . 2 3.  Flavor Number Assignment . . . . . . . . . . . . . . . . . . . 3 4.  New auth_stat Values . . . . . . . . . . . . . . . . . . . . . 3 5.  Elements of the RPCSEC_GSS Security Protocol . . . . . . . . . 3 5.1.  Version Selection  . . . . . . . . . . . . . . . . . . . . . 5 5.2.  Context Creation . . . . . . . . . . . . . . . . . . . . . . 5 5.2.1.  Mechanism and QOP Selection  . . . . . . . . . . . . . . . 5 5.2.2.  Context Creation Requests  . . . . . . . . . . . . . . . . 6 5.2.3.  Context Creation Responses . . . . . . . . . . . . . . . . 8 5.2.3.1.  Context Creation Response - Successful Acceptance  . . . 8 5.2.3.1.1.  Client Processing of Successful Context Creation Responses  . . . . . . . . . . . . . . . . . . . . . . 9 5.2.3.2.  Context Creation Response - Unsuccessful Cases . . . . . 9 5.3.  RPC Data Exchange  . . . . . . . . . . . . . . . . . . . .  10 5.3.1.  RPC Request Header . . . . . . . . . . . . . . . . . . .  10 5.3.2.  RPC Request Data . . . . . . . . . . . . . . . . . . . .  11 5.3.2.1.  RPC Request Data - No Data Integrity . . . . . . . . .  11 5.3.2.2.  RPC Request Data - With Data Integrity . . . . . . . .  11 5.3.2.3.  RPC Request Data - With Data Privacy . . . . . . . . .  12 5.3.3.  Server Processing of RPC Data Requests . . . . . . . . .  12 5.3.3.1.  Context Management . . . . . . . . . . . . . . . . . .  12 5.3.3.2.  Server Reply - Request Accepted  . . . . . . . . . . .  14 5.3.3.3.  Server Reply - Request Denied  . . . . . . . . . . . .  15",
      "ja": "1.はじめに。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 2 2. ONC RPCメッセージプロトコルを。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 2 3.フレーバー番号の割り当て。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 3つの4.新しいauth_stat値。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 RPCSEC_GSSセキュリティプロトコルの3つの5.要素。 。 。 。 。 。 。 。 。 3 5.1。バージョンの選択。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 5 5.2。コンテキスト作成。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 5 5.2.1。メカニズムとQOPの選択。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 5 5.2.2。コンテキスト作成要求。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 6 5.2.3。コンテキスト作成応答。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 8 5.2.3.1。コンテキスト作成応答 - 成功受け入れ。 。 。 8 5.2.3.1.1。成功したコンテキスト作成応答のクライアント処理。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 9 5.2.3.2。コンテキスト作成応答 - 失敗事例。 。 。 。 。 9 5.3。 RPCデータ交換。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 10 5.3.1。 RPCリクエスト・ヘッダー。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 10 5.3.2。 RPC要求データ。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 11 5.3.2.1。 RPC要求データ - データなしの整合性。 。 。 。 。 。 。 。 。 11 5.3.2.2。 RPC要求データ - データ整合性。 。 。 。 。 。 。 。 11 5.3.2.3。 RPC要求データ - データプライバシー付き。 。 。 。 。 。 。 。 。 12 5.3.3。 RPCデータ要求のサーバ処理。 。 。 。 。 。 。 。 。 12 5.3.3.1。コンテキスト管理。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 12 5.3.3.2。サーバの応答は - 受け付けた要求します。 。 。 。 。 。 。 。 。 。 。 14 5.3.3.3。サーバの応答 - 要求は拒否されました。 。 。 。 。 。 。 。 。 。 。 。 15"
    },
    {
      "indent": 3,
      "text": "5.3.3.4.  Mapping of GSS-API Errors to Server Responses  . . . .  16 5.3.3.4.1.  GSS_GetMIC() Failure . . . . . . . . . . . . . . . .  16 5.3.3.4.2.  GSS_VerifyMIC() Failure  . . . . . . . . . . . . . .  16 5.3.3.4.3.  GSS_Unwrap() Failure . . . . . . . . . . . . . . . .  16 5.3.3.4.4.  GSS_Wrap() Failure . . . . . . . . . . . . . . . . .  16 5.4.  Context Destruction  . . . . . . . . . . . . . . . . . . .  17 6.  Set of GSS-API Mechanisms  . . . . . . . . . . . . . . . . .  17 7.  Security Considerations  . . . . . . . . . . . . . . . . . .  18 7.1.  Privacy of Call Header . . . . . . . . . . . . . . . . . .  18 7.2.  Sequence Number Attacks  . . . . . . . . . . . . . . . . .  18 7.2.1.  Sequence Numbers Above the Window  . . . . . . . . . . .  18 7.2.2.  Sequence Numbers Within or Below the Window  . . . . . .  18 7.3.  Message Stealing Attacks . . . . . . . . . . . . . . . . .  19 Appendix A. GSS-API Major Status Codes . . . . . . . . . . . . .  20 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . .  22 Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . .  23",
      "ja": "5.3.3.4。サーバの応答にGSS-APIエラーのマッピング。 。 。 。 16 5.3.3.4.1。 GSS_GetMIC（）失敗。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 16 5.3.3.4.2。 GSS_VerifyMIC（）失敗。 。 。 。 。 。 。 。 。 。 。 。 。 。 16 5.3.3.4.3。 gss_unwrap（）失敗。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 16 5.3.3.4.4。 GSS_Wrap（）失敗。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 16 5.4。コンテキスト破壊。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 GSS-APIメカニズムの17 6.設定します。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 17の7.セキュリティの考慮。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 18 7.1。コールヘッダーのプライバシー。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 18 7.2。シーケンス番号攻撃。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 18 7.2.1。ウィンドウの上にシーケンス番号。 。 。 。 。 。 。 。 。 。 。 18 7.2.2。ウィンドウ内の以下のシーケンス番号。 。 。 。 。 。 18 7.3。メッセージには、攻撃を盗みます。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 19付録A. GSS-APIの主なステータスコード。 。 。 。 。 。 。 。 。 。 。 。 。 20の謝辞。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 22本の著者のアドレス。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 。 23"
    },
    {
      "indent": 0,
      "text": "1.  Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the protocol used by the RPCSEC_GSS security flavor.  Security flavors have been called authentication flavors for historical reasons. This memo recognizes that there are two other security services besides authentication, integrity, and privacy, and so defines a new RPCSEC_GSS security flavor.",
      "ja": "この文書では、RPCSEC_GSSセキュリティ風味が使用するプロトコルを記述します。セキュリティフレーバーは歴史的な理由のための認証のフレーバーと呼ばれています。このメモは他の二つのセキュリティサービスは、認証、整合性、およびプライバシーのほかに存在していることを認識し、その新しいRPCSEC_GSSセキュリティ風味を定義します。"
    },
    {
      "indent": 3,
      "text": "The protocol is described using the XDR language [Srinivasan-xdr]. The reader is assumed to be familiar with ONC RPC and the security flavor mechanism [Srinivasan-rpc].  The reader is also assumed to be familiar with the GSS-API framework [Linn].  The RPCSEC_GSS security flavor uses GSS-API interfaces to provide security services that are independent of the underlying security mechanism.",
      "ja": "プロトコルは、XDR言語[スリニヴァサン-XDR]を用いて説明します。読者は、ONC RPCセキュリティ風味機構[スリニヴァサン-RPC]に精通しているものとします。読者はまた、GSS-APIフレームワーク[リン]に精通しているものとします。 RPCSEC_GSSセキュリティ風味は、基礎となるセキュリティ・メカニズムに依存しないセキュリティサービスを提供するために、GSS-APIインタフェースを使用しています。"
    },
    {
      "indent": 0,
      "text": "2.  The ONC RPC Message Protocol",
      "section_title": true,
      "ja": "2. ONC RPCメッセージプロトコル"
    },
    {
      "indent": 3,
      "text": "This memo refers to the following XDR types of the ONC RPC protocol, which are described in the document entitled Remote Procedure Call Protocol Specification Version 2 [Srinivasan-rpc]:",
      "ja": "このメモは、リモートプロシージャコールプロトコル仕様バージョン2 [スリニヴァサン-RPC]と題する文書に記載されているONC RPCプロトコル、以下のXDRの種類を指します。"
    },
    {
      "indent": 6,
      "text": "msg_type reply_stat auth_flavor accept_stat reject_stat auth_stat opaque_auth rpc_msg call_body reply_body accepted_reply rejected_reply",
      "ja": "MSG_TYPE reply_stat auth_flavor accept_stat reject_stat auth_stat opaque_auth rpc_msg call_body reply_body accepted_reply rejected_reply"
    },
    {
      "indent": 0,
      "text": "3.  Flavor Number Assignment",
      "section_title": true,
      "ja": "3.フレーバー番号の割り当て"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS security flavor has been assigned the value of 6:",
      "ja": "RPCSEC_GSSセキュリティ風味は、6の値が割り当てられています。"
    },
    {
      "indent": 6,
      "text": "enum auth_flavor { ... RPCSEC_GSS = 6      /* RPCSEC_GSS security flavor */ };",
      "ja": "列挙auth_flavor {... RPCSEC_GSS = 6 / * RPCSEC_GSSセキュリティ風味* /}。"
    },
    {
      "indent": 0,
      "text": "4.  New auth_stat Values",
      "section_title": true,
      "ja": "4.新しいauth_stat値"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS requires the addition of two new values to the auth_stat enumerated type definition:",
      "ja": "RPCSEC_GSSはauth_stat列挙型の定義には2つの新しい値を追加する必要があります。"
    },
    {
      "indent": 6,
      "text": "enum auth_stat { ... /* * RPCSEC_GSS errors */ RPCSEC_GSS_CREDPROBLEM = 13, RPCSEC_GSS_CTXPROBLEM = 14 };",
      "ja": "列挙auth_stat {... / * * RPCSEC_GSSエラー* / RPCSEC_GSS_CREDPROBLEM = 13、RPCSEC_GSS_CTXPROBLEM = 14}。"
    },
    {
      "indent": 3,
      "text": "The descriptions of these two new values are defined later in this memo.",
      "ja": "これら二つの新しい値の説明は後でこのメモで定義されています。"
    },
    {
      "indent": 0,
      "text": "5.  Elements of the RPCSEC_GSS Security Protocol",
      "section_title": true,
      "ja": "RPCSEC_GSSセキュリティプロトコルの5要素"
    },
    {
      "indent": 3,
      "text": "An RPC session based on the RPCSEC_GSS security flavor consists of three phases: context creation, RPC data exchange, and context destruction.  In the following discussion, protocol elements for these three phases are described.",
      "ja": "コンテキスト作成、RPCのデータ交換、およびコンテキストの破壊：RPCSEC_GSSセキュリティ風味に基づいてRPCセッションは、3つのフェーズで構成されています。以下の説明では、これらの3つの相のプロトコルの要素が記載されています。"
    },
    {
      "indent": 3,
      "text": "The following description of the RPCSEC_GSS protocol uses some of the definitions within XDR language description of the RPC protocol.",
      "ja": "RPCSEC_GSSプロトコルの以下の説明は、RPCプロトコルのXDR言語記述内の定義の一部を使用します。"
    },
    {
      "indent": 3,
      "text": "Context creation and destruction use control messages that are not dispatched to service procedures registered by an RPC server.  The program and version numbers used in these control messages are the same as the RPC service's program and version numbers.  The procedure number used is NULLPROC (zero).  A field in the credential information (the gss_proc field which is defined in the rpc_gss_cred_t structure below) specifies whether a message is to be interpreted as a control message or a regular RPC message.  If this field is set to RPCSEC_GSS_DATA, no control action is implied; in this case, it is a regular data message.  If this field is set to any other value, a control action is implied.  This is described in the following sections.",
      "ja": "RPCサーバーによって登録されたサービス手順に派遣されていないコンテキストの作成と破棄の使用制御メッセージ。これらの制御メッセージで使用されるプログラムとバージョン番号は、RPCサービスのプログラムとバージョン番号と同じです。使用した手順番号はNULLPROC（ゼロ）です。資格情報（以下rpc_gss_cred_t構造で定義されているgss_procフィールド）のフィールドは、メッセージが、制御メッセージまたは定期的なRPCメッセージとして解釈されるべきであるかどうかを指定します。このフィールドはRPCSEC_GSS_DATAに設定されている場合は、何の制御動作を意味するものではありません。この場合は、通常のデータメッセージです。このフィールドは他の値に設定されている場合は、制御動作が暗示されます。これは、次のセクションで説明されています。"
    },
    {
      "indent": 3,
      "text": "Just as with normal RPC data exchange messages, the transaction identifier (the xid field in struct rpc_msg), should be set to unique values on each call for context creation and context destruction.",
      "ja": "ただ、通常のRPCデータ交換メッセージ、トランザクション識別子（構造体rpc_msgでXIDフィールド）と同様に、コンテキスト作成し、コンテキスト破壊のため呼び出しごとに一意の値に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following definitions are used for describing the protocol.",
      "ja": "以下の定義は、プロトコルを記述するために使用されます。"
    },
    {
      "indent": 6,
      "text": "/* RPCSEC_GSS control procedures */",
      "ja": "/ * RPCSEC_GSS制御手順* /"
    },
    {
      "indent": 6,
      "text": "enum rpc_gss_proc_t { RPCSEC_GSS_DATA = 0, RPCSEC_GSS_INIT = 1, RPCSEC_GSS_CONTINUE_INIT = 2, RPCSEC_GSS_DESTROY = 3 };",
      "ja": "列挙rpc_gss_proc_t {RPCSEC_GSS_DATA = 0、RPCSEC_GSS_INIT = 1、RPCSEC_GSS_CONTINUE_INIT = 2、RPCSEC_GSS_DESTROY = 3}。"
    },
    {
      "indent": 6,
      "text": "/* RPCSEC_GSS services */",
      "ja": "/ * RPCSEC_GSSサービス* /"
    },
    {
      "indent": 6,
      "text": "enum rpc_gss_service_t { /* Note: the enumerated value for 0 is reserved. */ rpc_gss_svc_none = 1, rpc_gss_svc_integrity = 2, rpc_gss_svc_privacy = 3 };",
      "ja": "列挙rpc_gss_service_t {/ *注：0列挙値が予約されています。 * / rpc_gss_svc_none = 1、rpc_gss_svc_integrity = 2、rpc_gss_svc_privacy = 3}。"
    },
    {
      "indent": 6,
      "text": "/* Credential */",
      "ja": "/ *資格* /"
    },
    {
      "indent": 6,
      "text": "/* * Note: version 0 is reserved for possible future * definition of a version negotiation protocol * */ #define RPCSEC_GSS_VERS_1 1",
      "ja": "/ * *注：バージョン0は、可能な将来のために予約されている*バージョン交渉プロトコル* * /の#define RPCSEC_GSS_VERS_1 1の定義"
    },
    {
      "indent": 6,
      "text": "struct rpc_gss_cred_t { union switch (unsigned int version) { /* version of RPCSEC_GSS */ case RPCSEC_GSS_VERS_1: struct { rpc_gss_proc_t gss_proc;  /* control procedure */ unsigned int seq_num;   /* sequence number */ rpc_gss_service_t service; /* service used */ opaque handle<>;       /* context handle */ } rpc_gss_cred_vers_1_t;",
      "ja": "構造体rpc_gss_cred_t {組合スイッチ（unsigned int型バージョン）{/ * * RPCSEC_GSSのバージョン/ケースRPCSEC_GSS_VERS_1：構造体{rpc_gss_proc_tのgss_proc。 / *制御手順* / unsigned int型SEQ_NUM。 / *シーケンス番号* / rpc_gss_service_tサービス。 / *サービスを使用* /不透明なハンドル<>。 / *コンテキストハンドル* /} rpc_gss_cred_vers_1_t。"
    },
    {
      "indent": 6,
      "text": "    }\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Maximum sequence number value */",
      "ja": "/ *最大シーケンス番号値* /"
    },
    {
      "indent": 6,
      "text": "#define MAXSEQ 0x80000000",
      "ja": "#define MAXSEQは0x80000000"
    },
    {
      "indent": 0,
      "text": "5.1.  Version Selection",
      "section_title": true,
      "ja": "5.1。バージョン選択"
    },
    {
      "indent": 3,
      "text": "This document defines just one protocol version (RPCSEC_GSS_VERS_1). The client should assume that the server supports RPCSEC_GSS_VERS_1 and issue a Context Creation message (as described in the section RPCSEC_GSS_VERS_1, the RPC response will have a reply_stat of MSG_DENIED, a rejection status of AUTH_ERROR, and an auth_stat of AUTH_REJECTED_CRED.",
      "ja": "この文書では、ただ一つのプロトコルバージョン（RPCSEC_GSS_VERS_1）を定義します。クライアントは、サーバがRPCSEC_GSS_VERS_1をサポートしていることを前提とし、コンテキスト作成メッセージを発行する（セクションRPCSEC_GSS_VERS_1で説明したように、RPC応答はMSG_DENIEDのreply_stat、AUTH_ERRORの拒否状況、およびAUTH_REJECTED_CREDのauth_statがありますする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.  Context Creation",
      "section_title": true,
      "ja": "5.2。コンテキスト作成"
    },
    {
      "indent": 3,
      "text": "Before RPC data is exchanged on a session using the RPCSEC_GSS flavor, a context must be set up between the client and the server. Context creation may involve zero or more RPC exchanges.  The number of exchanges depends on the security mechanism.",
      "ja": "RPCデータはRPCSEC_GSSの風味を使用してセッション上で交換される前に、コンテキストは、クライアントとサーバーの間で設定する必要があります。コンテキストの作成は、ゼロ以上のRPCの交換を含むことができます。取引所の数は、セキュリティ・メカニズムに依存します。"
    },
    {
      "indent": 0,
      "text": "5.2.1.  Mechanism and QOP Selection",
      "section_title": true,
      "ja": "5.2.1。メカニズムとQOPの選択"
    },
    {
      "indent": 3,
      "text": "There is no facility in the RPCSEC_GSS protocol to negotiate GSS-API mechanism identifiers or QOP values. At minimum, it is expected that implementations of the RPCSEC_GSS protocol provide a means to:",
      "ja": "GSS-APIメカニズム識別子またはQOP値を交渉するRPCSEC_GSSプロトコルでの機能はありません。最低でも、RPCSEC_GSSプロトコルの実装をする手段を提供することが期待されます。"
    },
    {
      "indent": 3,
      "text": "*    specify mechanism identifiers, QOP values, and RPCSEC_GSS service values on the client side, and to",
      "ja": "*クライアント側の機構識別子、QOP値、およびRPCSEC_GSSサービス値を指定して、へ"
    },
    {
      "indent": 3,
      "text": "*    enforce mechanism identifiers, QOP values, and RPCSEC_GSS service values on a per-request basis on the server side.",
      "ja": "*サーバ側の要求ごとに機構識別子、QOP値、およびRPCSEC_GSSサービス値を強制。"
    },
    {
      "indent": 3,
      "text": "It is necessary that above capabilities exist so that applications have the means to conform the required set of required set of <mechanism, QOP, service> tuples (See the section entitled Set of GSS-API Mechanisms).  An application may negotiate <mechanism, QOP, service> selection within its protocol or via an out of band protocol. Hence it may be necessary for RPCSEC_GSS implementations to provide programming interfaces for the specification and enforcement of <mechanism, QOP, service>.",
      "ja": "アプリケーションが<メカニズム、QOP、サービス>タプル（GSS-APIメカニズムのセットのセクションを参照）に必要な一連の必要なセットを適合させる手段を持っているように、上記の機能が存在することが必要です。アプリケーションは、そのプロトコル内またはバンドプロトコルのうち経由<機構、QOP、サービス>選択を交渉することができます。 RPCSEC_GSS実装は<機構、QOP、サービス>の仕様及び実施のためのプログラミングインタフェースを提供するために、従って、それが必要であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Additionally, implementations may depend on negotiation schemes constructed as pseudo-mechanisms under the GSS-API.  Because such schemes are below the GSS-API layer, the RPCSEC_GSS protocol, as specified in this document, can make use of them.",
      "ja": "また、実装はGSS-API下擬似機構として構築ネゴシエーション方式に依存してもよいです。そのようなスキームは、GSS-API層の下にあるので、RPCSEC_GSSプロトコルは、この文書で指定され、それらを利用することができます。"
    },
    {
      "indent": 0,
      "text": "5.2.2.  Context Creation Requests",
      "section_title": true,
      "ja": "5.2.2。コンテキスト作成要求"
    },
    {
      "indent": 3,
      "text": "The first RPC request from the client to the server initiates context creation.  Within the RPC message protocol's call_body structure, rpcvers is set to 2. prog and vers are always those for the service being accessed.  The proc is always set to NULLPROC (zero).",
      "ja": "クライアントからサーバへの最初のRPC要求は、コンテキストの作成を開始します。 RPCメッセージプロトコルのcall_body構造内、rpcvers 2. PROGに設定され、VERSは常にアクセスされるサービスのためのものです。 PROCは常にNULLPROC（ゼロ）に設定されています。"
    },
    {
      "indent": 3,
      "text": "Within the RPC message protocol's cred structure, flavor is set to RPCSEC_GSS (6).  The opaque data of the cred structure (the body field) constituting the credential encodes the rpc_gss_cred_t structure defined previously.",
      "ja": "RPCメッセージプロトコルのcred構造内に、風味がRPCSEC_GSS（6）に設定されています。信任状をなすCRED構造（ボディ・フィールド）の不透明なデータは、以前に定義されたrpc_gss_cred_t構造を符号化します。"
    },
    {
      "indent": 3,
      "text": "The values of the fields contained in the rpc_gss_cred_t structure are set as follows.  The version field is set to the version of the RPCSEC_GSS protocol the client wants to use.  The remainder of this memo documents version RPCSEC_GSS_VERS_1 of RPCSEC_GSS, and so the version field would be set to RPCSEC_GSS_VERS_1.  The gss_proc field must be set to RPCSEC_GSS_INIT for the first creation request.  In subsequent creation requests, the gss_proc field must be set to RPCSEC_GSS_CONTINUE_INIT.  In a creation request, the seq_num and service fields are undefined and both must be ignored by the server. In the first creation request, the handle field is NULL (opaque data of zero length).  In subsequent creation requests, handle must be equal to the value returned by the server.  The handle field serves as the identifier for the context, and will not change for the duration of the context, including responses to RPCSEC_GSS_CONTINUE_INIT.",
      "ja": "次のようにrpc_gss_cred_t構造に含まれるフィールドの値が設定されています。バージョンフィールドは、クライアントが使用したいRPCSEC_GSSプロトコルのバージョンに設定されています。 RPCSEC_GSSのこのメモドキュメントのバージョンRPCSEC_GSS_VERS_1、およびそのバージョンフィールドの残りはRPCSEC_GSS_VERS_1に設定されます。 gss_procフィールドは、最初の作成要求のためにRPCSEC_GSS_INITに設定する必要があります。その後の作成要求では、gss_procフィールドがRPCSEC_GSS_CONTINUE_INITに設定する必要があります。作成要求では、SEQ_NUMとサービスのフィールドが定義されていないとの両方が、サーバによって無視されなければなりません。最初の作成要求では、ハンドルフィールドがNULL（ゼロ長さの不透明なデータ）です。その後の作成要求では、ハンドルは、サーバから返された値と同じでなければなりません。ハンドルフィールドは、コンテキストの識別子として機能し、RPCSEC_GSS_CONTINUE_INITに対する応答を含むコンテキストの持続時間のために変更されません。"
    },
    {
      "indent": 3,
      "text": "The verifier field in the RPC message header is also described by the opaque_auth structure.  All creation requests have the NULL verifier (AUTH_NONE flavor with zero length opaque data).",
      "ja": "RPCメッセージヘッダーの検証フィールドもopaque_auth構造によって記述されます。すべての作成要求は、NULL検証（ゼロ長の不透明データとAUTH_NONEの風味を）持っています。"
    },
    {
      "indent": 3,
      "text": "Following the verifier are the call data (procedure specific parameters).  Note that the proc field of the call_body structure is set to NULLPROC, and thus normally there would be zero octets following the verifier.  However, since there is no RPC data exchange during a context creation, it is safe to transfer information following the verifier.  It is necessary to \"overload\" the call data in this way, rather than pack the GSS-API token into the RPC header, because RPC Version 2 restricts the amount of data that can be sent in the header.  The opaque body of the credential and verifier fields can be each at most 400 octets long, and GSS tokens can be longer than 800 octets.",
      "ja": "検証次のコールデータ（手順特定のパラメータ）があります。 call_body構造のPROCフィールドがNULLPROCに設定されているので、通常検証次のゼロオクテットが存在するであろうことに留意されたいです。コンテキスト作成時に何のRPCデータ交換がないのでしかし、検証以下の情報を転送しても安全です。これは、このように通話データ「過負荷」する必要があるのではなく、RPCバージョン2は、ヘッダで送信できるデータの量を制限しているため、RPCヘッダーにGSS-APIトークンを詰めます。資格とベリファイアフィールドの不透明体は、それぞれ最大で400オクテットの長さにすることができ、およびGSSトークンは800オクテットよりも長くすることができます。"
    },
    {
      "indent": 3,
      "text": "The call data for a context creation request is described by the following structure for all creation requests:",
      "ja": "コンテキスト作成要求のためのコールデータはすべて作成要求のために、以下の構造によって記述されています。"
    },
    {
      "indent": 6,
      "text": "struct rpc_gss_init_arg { opaque gss_token<>; };",
      "ja": "構造体rpc_gss_init_arg {不透明gss_token <>。 }。"
    },
    {
      "indent": 3,
      "text": "Here, gss_token is the token returned by the call to  GSS-API's GSS_Init_sec_context() routine, opaquely encoded.  The value of this field will likely be different in each creation request, if there is more than one creation request.  If no token is returned by the call to GSS_Init_sec_context(), the context must have been created (assuming no errors), and there will not be any more creation requests.",
      "ja": "ここで、gss_tokenは不透明にエンコードされたGSS-APIのもしGSS_Init_sec_context（）ルーチンへの呼び出しによって返されたトークンです。複数の作成要求があった場合、このフィールドの値はおそらく、それぞれの作成要求では異なるであろう。何もトークンがもしGSS_Init_sec_context（）への呼び出しによって返されない場合、コンテキストは（エラーがないと仮定して）作成されている必要があり、そしてそれ以上の作成要求がありません。"
    },
    {
      "indent": 3,
      "text": "When GSS_Init_sec_context() is called, the parameters replay_det_req_flag and sequence_req_flag must be turned off. The reasons for this are:",
      "ja": "もしGSS_Init_sec_context（）が呼び出されたとき、パラメータreplay_det_req_flagとsequence_req_flagはオフにされなければなりません。その理由は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "*    ONC RPC can be used over unreliable transports and provides no layer to reliably re-assemble messages. Thus it is possible for gaps in message sequencing to occur, as well as out of order messages.",
      "ja": "* ONCのRPCは、信頼性の低いトランスポート上で使用し、確実に組み立て直すのメッセージへの層を提供することはできません。メッセージの順序付けにギャップが発生するためしたがって、ならびに順序メッセージのうち、可能です。"
    },
    {
      "indent": 3,
      "text": "*    RPC servers can be multi-threaded, and thus the order in which GSS-API messages are signed or wrapped can be different from the order in which the messages are verified or unwrapped, even if the requests are sent on reliable transports.",
      "ja": "* RPCサーバは、マルチスレッドすることができ、したがって、GSS-APIメッセージが署名またはラップされる順序は、要求が信頼できるトランスポートに送信された場合でも、メッセージが検証される順序と異なるまたは開封することができます。"
    },
    {
      "indent": 3,
      "text": "*    To maximize convenience of implementation, the order in which an ONC RPC entity will verify the header and verify/unwrap the body of an RPC call or reply is left unspecified.",
      "ja": "*実装の利便性を最大にするために、ONCのRPCエンティティはRPCコールまたは応答の本体をヘッダを確認し、確認/アンラップする順序は不定残されます。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS protocol provides for protection from replay attack, yet tolerates out-of-order delivery or processing of messages and tolerates dropped requests.",
      "ja": "RPCSEC_GSSプロトコルは、リプレイ攻撃からの保護を提供し、まだメッセージと許容のアウトオブオーダーの配信や処理が要求を落とし許容します。"
    },
    {
      "indent": 0,
      "text": "5.2.3.  Context Creation Responses",
      "section_title": true,
      "ja": "5.2.3。コンテキスト作成応答"
    },
    {
      "indent": 0,
      "text": "5.2.3.1.  Context Creation Response - Successful Acceptance",
      "section_title": true,
      "ja": "5.2.3.1。コンテキスト作成応答 - 成功受け入れ"
    },
    {
      "indent": 3,
      "text": "The response to a successful creation request has an MSG_ACCEPTED response with a status of SUCCESS.  The results field encodes a response with the following structure:",
      "ja": "正常に作成要求に対する応答は、成功のステータスでMSG_ACCEPTED応答を有します。結果フィールドは、以下の構造を持つレスポンスをコード"
    },
    {
      "indent": 6,
      "text": "struct rpc_gss_init_res { opaque handle<>; unsigned int gss_major; unsigned int gss_minor; unsigned int seq_window; opaque gss_token<>; };",
      "ja": "構造体rpc_gss_init_res {不透明なハンドル<>。 unsigned int型gss_major。 unsigned int型gss_minor。 unsigned int型seq_window。不透明gss_token <>。 }。"
    },
    {
      "indent": 3,
      "text": "Here, handle is non-NULL opaque data that serves as the context identifier. The client must use this value in all subsequent requests whether control messages or otherwise).  The gss_major and gss_minor fields contain the results of the call to GSS_Accept_sec_context() executed by the server.  The values for the gss_major field are defined in Appendix A of this document.  The values for the gss_minor field are GSS-API mechanism specific and are defined in the mechanism's specification.  If gss_major is not one of GSS_S_COMPLETE or GSS_S_CONTINUE_NEEDED, the context setup has failed; in this case handle and gss_token must be set to NULL by the server.  The value of gss_minor is dependent on the value of gss_major and the security mechanism used.  The gss_token field contains any token returned by the GSS_Accept_sec_context() call executed by the server.  A token may be returned for both successful values of gss_major.  If the value is GSS_S_COMPLETE, it indicates that the server is not expecting any more tokens, and the RPC Data Exchange phase must begin on the subsequent request from the client. If the value is GSS_S_CONTINUE_NEEDED, the server is expecting another token.  Hence the client must send at least one more creation request (with gss_proc set to RPCSEC_GSS_CONTINUE_INIT in the request's credential) carrying the required token.",
      "ja": "ここで、ハンドルは、コンテキスト識別子として機能する非NULL不透明なデータです。クライアントは、後続のすべての要求の制御メッセージかそうでない）でこの値を使用する必要があります。 gss_majorとgss_minorフィールドは、サーバーで実行される場合gss_accept_sec_context（）の呼び出しの結果が含まれています。 gss_majorフィールドの値は、このドキュメントの付録Aで定義されています。 gss_minorフィールドの値は、特定のGSS-APIメカニズムであり、メカニズムの仕様で定義されています。 GSS_S_COMPLETEまたはGSS_S_CONTINUE_NEEDEDの1 gss_majorでない場合は、コンテキストの設定に失敗しました。この場合、ハンドルとgss_tokenにサーバによってNULLに設定する必要があります。 gss_minorの値はgss_majorの値と使用されるセキュリティメカニズムに依存しています。 gss_tokenフィールドには、サーバーで実行される場合gss_accept_sec_context（）の呼び出しによって返されたすべてのトークンが含まれています。トークンはgss_majorの成功値の両方のために返されることがあります。値がGSS_S_COMPLETEであれば、サーバは、それ以上のトークンを期待していないことを示し、およびRPCデータ交換フェーズでは、クライアントからの後続の要求に始めなければなりません。値がGSS_S_CONTINUE_NEEDEDであるならば、サーバは別のトークンを期待しています。したがって、クライアントは、必要なトークンを運ぶ（リクエストの資格でRPCSEC_GSS_CONTINUE_INITに設定gss_procで）少なくとももう1つの作成要求を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "In a successful response, the seq_window field is set to the sequence window length supported by the server for this context.  This window specifies the maximum number of client requests that may be outstanding for this context. The server will accept \"seq_window\" requests at a time, and these may be out of order.  The client may use this number to determine the number of threads that can simultaneously send requests on this context.",
      "ja": "正常な応答では、seq_windowフィールドは、このコンテキストのサーバーでサポートされているシーケンスウィンドウの長さに設定されています。このウィンドウには、このような状況のために優れたかもしれクライアント要求の最大数を指定します。サーバは一度「seq_window」要求を受け入れる、これらは順不同でもあります。クライアントは同時に、このコンテキストで要求を送信できるスレッドの数を決定するために、この番号を使用することができます。"
    },
    {
      "indent": 3,
      "text": "If gss_major is GSS_S_COMPLETE, the verifier's (the verf element in the response) flavor field is set to RPCSEC_GSS, and the body field set to the checksum of the seq_window (in network order). The QOP used for this checksum is 0 (zero), which is the default QOP.  For all other values of gss_major, a NULL verifier (AUTH_NONE flavor with zero-length opaque data) is used.",
      "ja": "GSS_S_COMPLETE、RPCSEC_GSSに設定されているフレーバーフィールド検証者（応答VERF素子）、及び（ネットワーク順）seq_windowのチェックサムに設定ボディフィールドgss_majorある場合。 QOPは、このチェックサムのために使用されるデフォルトのQOPであり、0（ゼロ）です。 gss_majorの他のすべての値について、NULL検証（ゼロ長の不透明データとAUTH_NONEフレーバ）が使用されます。"
    },
    {
      "indent": 0,
      "text": "5.2.3.1.1.  Client Processing of Successful Context Creation Responses",
      "section_title": true,
      "ja": "5.2.3.1.1。成功したコンテキスト作成応答のクライアント処理"
    },
    {
      "indent": 3,
      "text": "If the value of gss_major in the response is GSS_S_CONTINUE_NEEDED, then the client, per the GSS-API specification, must invoke GSS_Init_sec_context() using the token returned in gss_token in the context creation response. The client must then generate a context creation request, with gss_proc set to RPCSEC_GSS_CONTINUE_INIT.",
      "ja": "応答でgss_majorの値がGSS_S_CONTINUE_NEEDEDであるならば、クライアントは、GSS-APIの仕様ごとに、コンテキスト作成応答でgss_tokenで返されたトークンを使用して）（もしGSS_Init_sec_contextを呼び出す必要があります。次に、クライアントはRPCSEC_GSS_CONTINUE_INITに設定gss_procして、コンテキスト作成要求を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the value of gss_major in the response is GSS_S_COMPLETE, and if the client's previous invocation of GSS_Init_sec_context() returned a gss_major value of GSS_S_CONTINUE_NEEDED, then the client, per the GSS-API specification, must invoke GSS_Init_sec_context() using the token returned in gss_token in the context creation response. If GSS_Init_sec_context() returns GSS_S_COMPLETE, the context is successfully set up, and the RPC data exchange phase must begin on the subsequent request from the client.",
      "ja": "応答でgss_majorの値がGSS_S_COMPLETEである場合、およびもしGSS_Init_sec_context（）のクライアントの以前の呼び出しがGSS_S_CONTINUE_NEEDEDのgss_major値を返した場合、クライアントは、GSS-APIの仕様ごとに、gss_tokenで返されたトークンを使用して）（もしGSS_Init_sec_contextを呼び出す必要がありますコンテキスト作成応答インチもしGSS_Init_sec_context（）はGSS_S_COMPLETEを返した場合、コンテキストは正常に設定されており、RPCデータ交換フェーズでは、クライアントからの後続の要求に始めなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.2.  Context Creation Response - Unsuccessful Cases",
      "section_title": true,
      "ja": "5.2.3.2。コンテキスト作成応答 - 失敗事例"
    },
    {
      "indent": 3,
      "text": "An MSG_ACCEPTED reply (to a creation request) with an acceptance status of other than SUCCESS has a NULL verifier (flavor set to AUTH_NONE, and zero length opaque data in the body field), and is formulated as usual for different status values.",
      "ja": "SUCCESS以外の受付状態を持つ（作成要求に）MSG_ACCEPTED応答がNULL検証（AUTH_NONEに設定風味、および本文フィールドにゼロ長の不透明データ）を有し、異なる状態値の通常として製剤化されます。"
    },
    {
      "indent": 3,
      "text": "An MSG_DENIED reply (to a creation request) is also formulated as usual.  Note that MSG_DENIED could be returned because the server's RPC implementation does not recognize the RPCSEC_GSS security flavor. RFC 1831 does not specify the appropriate reply status in this instance, but common implementation practice appears to be to return a rejection status of AUTH_ERROR with an auth_stat of AUTH_REJECTEDCRED. Even though two new values (RPCSEC_GSS_CREDPROBLEM and RPCSEC_GSS_CTXPROBLEM) have been defined for the auth_stat type, neither of these two can be returned in responses to context creation requests.  The auth_stat new values can be used for responses to normal (data) requests.  This is described later.",
      "ja": "（作成要求に）MSG_DENIED返事もいつものように定式化されます。サーバーのRPCの実装はRPCSEC_GSSセキュリティ風味を認識しないためMSG_DENIEDを返すことができることに注意してください。 RFC 1831は、この例では、適切な応答ステータスを指定しませんが、一般的な実装の実践はAUTH_REJECTEDCREDのauth_statでAUTH_ERRORの拒絶のステータスを返すようにように見えます。二つの新しい値（RPCSEC_GSS_CREDPROBLEMとRPCSEC_GSS_CTXPROBLEM）はauth_statタイプのために定義されているにもかかわらず、これらの二つのどちらがコンテキスト作成要求への応答で返すことができます。 auth_stat新しい値は、通常の（データ）の要求への応答に使用することができます。これについては後述します。"
    },
    {
      "indent": 3,
      "text": "MSG_DENIED might also be returned if the RPCSEC_GSS version number in the credential is not supported on the server. In that case, the server returns a rejection status of AUTH_ERROR, with an auth_stat of",
      "ja": "資格でのRPCSEC_GSSのバージョン番号は、サーバーでサポートされていない場合MSG_DENIEDも返されることがあります。その場合、サーバはauth_statと、AUTH_ERRORの拒絶反応の状態を返します"
    },
    {
      "indent": 3,
      "text": "AUTH_REJECTED_CRED.",
      "ja": "AUTH_REJECTED_CRED。"
    },
    {
      "indent": 0,
      "text": "5.3.  RPC Data Exchange",
      "section_title": true,
      "ja": "5.3。 RPCデータ交換"
    },
    {
      "indent": 3,
      "text": "The data exchange phase is entered after a context has been successfully set up. The format of the data exchanged depends on the security service used for the request.  Although clients can change the security service and QOP used on a per-request basis, this may not be acceptable to all RPC services; some RPC services may \"lock\" the data exchange phase into using the QOP and service used on the first data exchange message.  For all three modes of service (no data integrity, data integrity, data privacy), the RPC request header has the same format.",
      "ja": "コンテキストが正常に設定された後、データ交換フェーズが入力されます。交換されるデータの形式は、要求に使用するセキュリティサービスに依存します。クライアントがリクエストごとに使用するセキュリティサービスとQOPを変更することができますが、これはすべてのRPCサービスへの許容できない場合があります。いくつかのRPCサービスは、最初のデータ交換メッセージで使用されるQOPとサービスを使用してにデータ交換フェーズを「ロック」があります。サービスのすべての3つのモード（NOデータ整合性、データ完全性、データプライバシー）のために、RPC要求ヘッダは、同じフォーマットを有します。"
    },
    {
      "indent": 0,
      "text": "5.3.1.  RPC Request Header",
      "section_title": true,
      "ja": "5.3.1。 RPCリクエスト・ヘッダー"
    },
    {
      "indent": 3,
      "text": "The credential has the opaque_auth structure described earlier.  The flavor field is set to RPCSEC_GSS.  The credential body is created by XDR encoding the rpc_gss_cred_t structure listed earlier into an octet stream, and then opaquely encoding this octet stream as the body field.",
      "ja": "資格は、前述のopaque_auth構造を有しています。フレーバーフィールドはRPCSEC_GSSに設定されています。信任状体は、XDRがオクテットストリームに以前記載されているrpc_gss_cred_t構造をコードし、そしてその後、不透明体フィールドとして、このオクテットのストリームを符号化することによって作成されます。"
    },
    {
      "indent": 3,
      "text": "Values of the fields contained in the rpc_gss_cred_t structure are set as follows.  The version field is set to same version value that was used to create the context, which within the scope of this memo will always be RPCSEC_GSS_VERS_1.  The gss_proc field is set to RPCSEC_GSS_DATA.  The service field is set to indicate the desired service (one of rpc_gss_svc_none, rpc_gss_svc_integrity, or rpc_gss_svc_privacy).  The handle field is set to the context handle value received from the RPC server during context creation.  The seq_num field can start at any value below MAXSEQ, and must be incremented (by one or more) for successive requests.  Use of sequence numbers is described in detail when server processing of the request is discussed.",
      "ja": "次のようにrpc_gss_cred_t構造に含まれるフィールドの値が設定されています。バージョンフィールドは、このメモの範囲内に常にRPCSEC_GSS_VERS_1あろうコンテキストを作成するために使用されたのと同じバージョンの値に設定されています。 gss_procフィールドはRPCSEC_GSS_DATAに設定されています。サービスフィールドは、所望のサービス（rpc_gss_svc_none、rpc_gss_svc_integrity、又はrpc_gss_svc_privacyのいずれか）を示すために設定されています。ハンドルフィールドは、コンテキストの作成中にRPCサーバーから受信したコンテキスト・ハンドルの値に設定されています。 SEQ_NUMフィールドはMAXSEQ以下の任意の値で始めることができ、連続する要求のための（一つ又は複数によって）インクリメントされなければなりません。要求のサーバ処理が議論されている場合、シーケンス番号の使用は詳細に記載されています。"
    },
    {
      "indent": 3,
      "text": "The verifier has the opaque_auth structure described earlier.  The flavor field is set to RPCSEC_GSS.  The body field is set as follows. The checksum of the RPC header (up to and including the credential) is computed using the GSS_GetMIC() call with the desired QOP.  This returns the checksum as an opaque octet stream and its length.  This is encoded into the body field.  Note that the QOP is not explicitly specified anywhere in the request.  It is implicit in the checksum or encrypted data.  The same QOP value as is used for the header checksum must also be used for the data (for checksumming or encrypting), unless the service used for the request is rpc_gss_svc_none.",
      "ja": "検証者は、前述opaque_auth構造を有しています。フレーバーフィールドはRPCSEC_GSSに設定されています。次のように体のフィールドが設定されています。 （資格までを含む）RPCヘッダのチェックサムは、所望のQOPとGSS_GetMIC（）コールを使用して計算されます。これは、不透明なオクテットストリームとその長さとチェックサムを返します。これは、体内のフィールドに符号化されています。 QOPを明示的にどこにでも要求で指定されていないことに注意してください。これは、チェックサムまたは暗号化されたデータに内在します。要求に使用されるサービスはrpc_gss_svc_noneない限り、ヘッダチェックサムのために使用されるのと同じQOP値はまた、（チェックサムまたは暗号化するための）データのために使用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.2.  RPC Request Data",
      "section_title": true,
      "ja": "5.3.2。 RPC要求データ"
    },
    {
      "indent": 0,
      "text": "5.3.2.1.  RPC Request Data - No Data Integrity",
      "section_title": true,
      "ja": "5.3.2.1。 RPC要求データ - いいえ、データの整合性"
    },
    {
      "indent": 3,
      "text": "If the service specified is rpc_gss_svc_none, the data (procedure arguments) are not integrity or privacy protected.  They are sent in exactly the same way as they would be if the AUTH_NONE flavor were used (following the verifier).  Note, however, that since the RPC header is integrity protected, the sender will still be authenticated in this case.",
      "ja": "指定されたサービスがrpc_gss_svc_noneであれば、データ（手続きの引数）は、整合性やプライバシー保護されていません。彼らはAUTH_NONEの風味が（検証以下）を使用した場合、彼らはだろうとまったく同じ方法で送信されます。 RPCヘッダが完全性保護されているため、送信者は依然としてこの場合、認証されること、しかし、注意してください。"
    },
    {
      "indent": 0,
      "text": "5.3.2.2.  RPC Request Data - With Data Integrity",
      "section_title": true,
      "ja": "5.3.2.2。 RPC要求データ - データ整合性"
    },
    {
      "indent": 3,
      "text": "When data integrity is used, the request data is represented as follows:",
      "ja": "データの整合性を使用する場合は、次のように、要求データが表されます。"
    },
    {
      "indent": 6,
      "text": "struct rpc_gss_integ_data { opaque databody_integ<>; opaque checksum<>; };",
      "ja": "構造体rpc_gss_integ_data {不透明databody_integ <>。不透明なチェックサム<>。 }。"
    },
    {
      "indent": 3,
      "text": "The databody_integ field is created as follows.  A structure consisting of a sequence number followed by the procedure arguments is constructed. This is shown below as the type rpc_gss_data_t:",
      "ja": "次のようにdatabody_integフィールドが作成されます。プロシージャ引数に続くシーケンス番号からなる構造が構築されます。これは、型rpc_gss_data_tとして以下に示します。"
    },
    {
      "indent": 6,
      "text": "struct rpc_gss_data_t { unsigned int seq_num; proc_req_arg_t arg; };",
      "ja": "構造体rpc_gss_data_t {unsigned int型SEQ_NUM。 proc_req_arg_tのarg; }。"
    },
    {
      "indent": 3,
      "text": "Here, seq_num must have the same value as in the credential.  The type proc_req_arg_t is the procedure specific XDR type describing the procedure arguments (and so is not specified here).  The octet stream corresponding to the XDR encoded rpc_gss_data_t structure and its length are placed in the databody_integ field. Note that because the XDR type of databody_integ is opaque, the XDR encoding of databody_integ will include an initial four octet length field, followed by the XDR encoded octet stream of rpc_gss_data_t.",
      "ja": "ここで、SEQ_NUMは、資格情報と同じ値を持つ必要があります。型proc_req_arg_tは、プロシージャ引数を記述する手順特定XDR型である（したがって、ここで指定されていません）。 XDRエンコードさrpc_gss_data_t構造とその長さに対応するオクテットストリームはdatabody_integフィールドに配置されます。 databody_integのXDR型が不透明であるため、databody_integのXDRエンコーディングはrpc_gss_data_tのXDR符号化されたオクテットストリームに続く最初の4つのオクテットの長さフィールドを含むことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The checksum field represents the checksum of the XDR encoded octet stream corresponding to the XDR encoded rpc_gss_data_t structure (note, this is not the checksum of the databody_integ field).  This is obtained using the GSS_GetMIC() call, with the same QOP as was used to compute the header checksum (in the verifier). The",
      "ja": "チェックサムフィールドはXDRエンコードさrpc_gss_data_t構造（注、これはdatabody_integフィールドのチェックサムではない）に対応するXDRエンコードされたオクテットのストリームのチェックサムを表します。これは、（検証者における）ヘッダチェックサムを計算するために使用したのと同じQOPと、GSS_GetMIC（）コールを用いて得られます。ザ・"
    },
    {
      "indent": 3,
      "text": "GSS_GetMIC() call returns the checksum as an opaque octet stream and its length. The checksum field of struct rpc_gss_integ_data has an XDR type of opaque. Thus the checksum length from GSS_GetMIC() is encoded as a four octet  length field, followed by the checksum, padded to a multiple of four octets.",
      "ja": "GSS_GetMIC（）呼び出しは、不透明なオクテットストリームとその長としてチェックサムを返します。構造体rpc_gss_integ_dataのチェックサムフィールドは、不透明のXDRの種類があります。したがってGSS_GetMICからチェックサムの長さ（）は、4つのオクテット長フィールドとして符号化チェックサムが続き、4つのオクテットの倍数に水増し。"
    },
    {
      "indent": 0,
      "text": "5.3.2.3.  RPC Request Data - With Data Privacy",
      "section_title": true,
      "ja": "5.3.2.3。 RPC要求データ - データプライバシー付き"
    },
    {
      "indent": 3,
      "text": "When data privacy is used, the request data is represented as follows:",
      "ja": "データのプライバシーを使用すると、以下のように、要求データが表されます。"
    },
    {
      "indent": 6,
      "text": "struct rpc_gss_priv_data { opaque databody_priv<> };",
      "ja": "構造体rpc_gss_priv_data {不透明databody_priv <>}。"
    },
    {
      "indent": 3,
      "text": "The databody_priv field is created as follows.  The rpc_gss_data_t structure described earlier is constructed again in the same way as for the case of data integrity.  Next, the GSS_Wrap() call is invoked to encrypt the octet stream corresponding to the rpc_gss_data_t structure, using the same value for QOP (argument qop_req to GSS_Wrap()) as was used for the header checksum (in the verifier) and conf_req_flag (an argument to GSS_Wrap()) of TRUE.  The GSS_Wrap() call returns an opaque octet stream (representing the encrypted rpc_gss_data_t structure) and its length, and this is encoded as the databody_priv field. Since databody_priv has an XDR type of opaque, the length returned by GSS_Wrap() is encoded as the four octet length, followed by the encrypted octet stream (padded to a multiple of four octets).",
      "ja": "次のようにdatabody_privフィールドが作成されます。前述しrpc_gss_data_t構造は、データの整合性の場合と同じ方法で再び構成されています。次に、にGSS_Wrap（）呼び出しは（QOP（検証中）ヘッダチェックサムのために使用されたようにconf_req_flag（にGSS_Wrap（）に対する引数qop_req）に対して同じ値を使用して、rpc_gss_data_t構造に対応するオクテットストリームを暗号化するために呼び出されますTRUEのにGSS_Wrap（））の引数。 GSS_Wrap（）呼び出しは、不透明なオクテットストリーム（暗号化rpc_gss_data_t構造を示す）とその長さを返し、これはdatabody_privフィールドとして符号化されます。 databody_privが不透明のXDR型、にGSS_Wrap（によって返された長さ）を有しているので、（4つのオクテットの倍数に水増し）暗号化されたオクテットストリームに続く4つのオクテット長として符号化されます。"
    },
    {
      "indent": 0,
      "text": "5.3.3.  Server Processing of RPC Data Requests",
      "section_title": true,
      "ja": "5.3.3。 RPCデータ要求のサーバー処理"
    },
    {
      "indent": 0,
      "text": "5.3.3.1.  Context Management",
      "section_title": true,
      "ja": "5.3.3.1。コンテキスト管理"
    },
    {
      "indent": 3,
      "text": "When a request is received by the server, the following are verified to be acceptable:",
      "ja": "要求がサーバによって受信されると、以下が許容可能であると確認されています。"
    },
    {
      "indent": 3,
      "text": "*    the version number in the credential",
      "ja": "*資格にバージョン番号"
    },
    {
      "indent": 3,
      "text": "*    the service specified in the credential",
      "ja": "*資格で指定されたサービス"
    },
    {
      "indent": 3,
      "text": "*    the context handle specified in the credential",
      "ja": "資格で指定*コンテキストハンドル"
    },
    {
      "indent": 3,
      "text": "*    the header checksum in the verifier (via GSS_VerifyMIC())",
      "ja": "*検証におけるヘッダチェックサム（GSS_VerifyMIC介して（））"
    },
    {
      "indent": 3,
      "text": "*    the sequence number (seq_num) specified in the credential (more on this follows)",
      "ja": "*資格情報で指定されたシーケンス番号（SEQ_NUM）が（この詳細は以下）"
    },
    {
      "indent": 3,
      "text": "The gss_proc field in the credential must be set to RPCSEC_GSS_DATA for data requests (otherwise, the message will be interpreted as a control message).",
      "ja": "資格でgss_procフィールドは、データ要求（そうでなければ、メッセージは、制御メッセージとして解釈される）ためRPCSEC_GSS_DATAに設定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server maintains a window of \"seq_window\" sequence numbers, starting with the last sequence number seen and extending backwards. If a sequence number higher than the last number seen is received (AND if GSS_VerifyMIC() on the header checksum from the verifier returns GSS_S_COMPLETE), the window is moved forward to the new sequence number.  If the last sequence number seen is N, the server is prepared to receive requests with sequence numbers in the range N through (N - seq_window + 1), both inclusive.  If the sequence number received falls below this range, it is silently discarded.  If the sequence number is within this range, and the server has not seen it, the request is accepted, and the server turns on a bit to \"remember\" that this sequence number has been seen.  If the server determines that it has already seen a sequence number within the window, the request is silently discarded. The server should select a seq_window value based on the number requests it expects to process simultaneously. For example, in a threaded implementation seq_window might be equal to the number of server threads. There are no known security issues with selecting a large window. The primary issue is how much space the server is willing to allocate to keep track of requests received within the window.",
      "ja": "サーバーは後方見て拡張最後のシーケンス番号で始まる、「seq_window」シーケンス番号のウィンドウを維持します。受信さ見最後の番号よりも大きいシーケンス番号（検証者からヘッダチェックサムには、AND GSS_VerifyMIC場合（）GSS_S_COMPLETEを返した場合）、ウィンドウは、新しいシーケンス番号に前進させます。両方とも、包括 - 見られる最後のシーケンス番号がNである場合、サーバは、（seq_window + 1 N）を介して、範囲N内のシーケンス番号との要求を受け取るように準備されます。シーケンス番号がこの範囲を下回る受け取った場合、それを黙って破棄されます。シーケンス番号がこの範囲内であり、サーバがそれを見ていない場合は、要求が受け入れられ、およびサーバは、このシーケンス番号が見られたことを「記憶」するビットをオンにしています。サーバがすでにウィンドウ内のシーケンス番号を見ていると判断した場合、要求は黙って破棄されます。サーバは、それが同時に処理することを期待数の要求に基づいてseq_window値を選択する必要があります。例えば、ねじ実装seq_windowにサーバ・スレッドの数に等しいかもしれません。大きな窓を選択するとは、既知のセキュリティ上の問題はありません。主な問題は、サーバがウィンドウ内に受信要求を追跡するために割り当てることが喜んでどのくらいのスペースです。"
    },
    {
      "indent": 3,
      "text": "The reason for discarding requests silently is that the server is unable to determine if the duplicate or out of range request was due to a sequencing problem in the client, network, or the operating system, or due to some quirk in routing, or a replay attack by an intruder.  Discarding the request allows the client to recover after timing out, if indeed the duplication was unintentional or well intended.  Note that a consequence of the silent discard is that clients may increment the seq_num by more than one. The effect of this is that the window will move forward more quickly. It is not believed that there is any benefit to doing this.",
      "ja": "黙って要求を廃棄する理由は、サーバがクライアント、ネットワークにおけるシーケンシングの問題、またはオペレーティングシステムによるもので、重複する場合は範囲​​要求のうち、決定することができないということである、または原因ルーティングにおけるいくつかのいたずらに、またはリプレイ侵入者による攻撃。確かに重複が意図しないまたはウェル意図した場合は、要求を破棄することは、クライアントがタイムアウトした後に回復することができます。サイレント破棄の結果は、クライアントが複数でSEQ_NUMをインクリメントすることであることに注意してください。この効果は、ウィンドウがより迅速に前進するということです。これを行うに何らかの利益があるとは考えられません。"
    },
    {
      "indent": 3,
      "text": "Note that the sequence number algorithm requires that the client increment the sequence number even if it is retrying a request with the same RPC transaction identifier.  It is not infrequent for clients to get into a situation where they send two or more attempts and a slow server sends the reply for the first attempt. With RPCSEC_GSS, each request and reply will have a unique sequence number. If the client wishes to improve turn around time on the RPC call, it can cache the RPCSEC_GSS sequence number of each request it sends. Then when it receives a response with a matching RPC transaction identifier, it can compute the checksum of each sequence number in the cache to try to match the checksum in the reply's verifier.",
      "ja": "シーケンス番号アルゴリズムは、クライアントが同じRPCトランザクション識別子を使用して要求を再試行する場合でも、シーケンス番号をインクリメントすることを必要とすることに注意してください。クライアントは、彼らが二つ以上の試行を送信し、遅いサーバが最初の試みのために応答を送信し、状況に取得することはまれではありません。 RPCSEC_GSSでは、各要求と応答は、固有のシーケンス番号を持つことになります。クライアントがRPCコールのターンアラウンドタイムを改善したい場合は、それが送信する各リクエストのRPCSEC_GSSシーケンス番号をキャッシュすることができます。それが一致するRPCトランザクション識別子で応答を受信したときに、それは回答者の検証でチェックサムと一致するようにしようとするために、キャッシュ内の各シーケンス番号のチェックサムを計算することができます。"
    },
    {
      "indent": 3,
      "text": "The data is decoded according to the service specified in the credential.  In the case of integrity or privacy, the server ensures that the QOP value is acceptable, and that it is the same as that used for the header checksum in the verifier.  Also, in the case of integrity or privacy, the server will reject the message (with a reply status of MSG_ACCEPTED, and an acceptance status of GARBAGE_ARGS) if the sequence number embedded in the request body is different from the sequence number in the credential.",
      "ja": "データは、資格で指定されたサービスに応じてデコードされます。完全性またはプライバシの場合には、サーバは、QOP値が許容可能であることを保証し、それが検証内のヘッダチェックサムのために使用されるものと同じです。リクエストボディに埋め込まれたシーケンス番号は、資格のシーケンス番号と異なる場合にも、完全性またはプライバシの場合には、サーバは、（MSG_ACCEPTEDの応答ステータスと、及びGARBAGE_ARGSの受付状態）メッセージを拒否します。"
    },
    {
      "indent": 0,
      "text": "5.3.3.2.  Server Reply - Request Accepted",
      "section_title": true,
      "ja": "5.3.3.2。サーバの応答 - 受理をリクエスト"
    },
    {
      "indent": 3,
      "text": "An MSG_ACCEPTED reply to a request in the data exchange phase will have the verifier's (the verf element in the response) flavor field set to RPCSEC_GSS, and the body field set to the checksum (the output of GSS_GetMIC()) of the sequence number (in network order) of the corresponding request.  The QOP used is the same as the QOP used for the corresponding request.",
      "ja": "（MSG_ACCEPTEDはRPCSEC_GSSに設定風味フィールド検証者（応答VERF要素）を有することになるデータ交換相における要求に応答し、ボディ・フィールドは、シーケンス番号のチェックサム（GSS_GetMIC（）の出力）に設定します対応する要求のネットワーク順序）です。使用QOPがQOPは、対応する要求のために使用したものと同じです。"
    },
    {
      "indent": 3,
      "text": "If the status of the reply is not SUCCESS, the rest of the message is formatted as usual.",
      "ja": "回答のステータスがSUCCESSでない場合は、メッセージの残りの部分はいつものようにフォーマットされます。"
    },
    {
      "indent": 3,
      "text": "If the status of the message is SUCCESS, the format of the rest of the message depends on the service specified in the corresponding request message. Basically, what follows the verifier in this case are the procedure results, formatted in different ways depending on the requested service.",
      "ja": "メッセージのステータスがSUCCESSの場合は、メッセージの残りのフォーマットは、対応する要求メッセージに指定されたサービスに依存します。基本的に、どのようなこのケースで検証し、次のことは要求されたサービスに応じて、さまざまな方法でフォーマットされた、プロシージャの結果です。"
    },
    {
      "indent": 3,
      "text": "If no data integrity was requested, the procedure results are formatted as for the AUTH_NONE security flavor.",
      "ja": "何のデータの整合性が要求されなかった場合は、プロシージャの結果はAUTH_NONEセキュリティ風味のためとしてフォーマットされています。"
    },
    {
      "indent": 3,
      "text": "If data integrity was requested, the results are encoded in exactly the same way as the procedure arguments were in the corresponding request.  See the section 'RPC Request Data - With Data Integrity.' The only difference is that the structure representing the procedure's result - proc_res_arg_t - must be substituted in place of the request argument structure proc_req_arg_t.  The QOP used for the checksum must be the same as that used for constructing the reply verifier.",
      "ja": "データの整合性が要求された場合は手続きの引数が対応する要求であったように、結果は全く同じ方法でエンコードされています。セクション「RPC要求データ。 - データ保全性」を参照してください。 proc_res_arg_t  -   - 要求引数構造proc_req_arg_tの代わりに置換されなければならない唯一の違いは、プロシージャの結果を表す構造があることです。チェックサムのために使用さQOPは、返信検証を構築するために使用されたものと同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "If data privacy was requested, the results are encoded in exactly the same way as the procedure arguments were in the corresponding request.  See the section 'RPC Request Data - With Data Privacy.' The QOP used for  encryption must be the same as that used for constructing the reply verifier.",
      "ja": "データプライバシーが要求された場合は手続きの引数が対応する要求であったように、結果は全く同じ方法でエンコードされています。セクション「RPC要求データを - データのプライバシーと。」を参照してください暗号化に使用されるQOPは、返信検証を構築するために使用されたものと同じでなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.3.3.  Server Reply - Request Denied",
      "section_title": true,
      "ja": "5.3.3.3。サーバの応答 - 要求が拒否されました"
    },
    {
      "indent": 3,
      "text": "An MSG_DENIED reply (to a data request) is formulated as usual.  Two new values (RPCSEC_GSS_CREDPROBLEM and RPCSEC_GSS_CTXPROBLEM) have been defined for the auth_stat type.  When the reason for denial of the request is a reject_stat of AUTH_ERROR, one of the two new auth_stat values could be returned in addition to the existing values.  These two new values have special significance from the existing reasons for denial of a request.",
      "ja": "（データ要求に）MSG_DENIED応答は通常通り製剤化されます。二つの新しい値（RPCSEC_GSS_CREDPROBLEMとRPCSEC_GSS_CTXPROBLEM）はauth_statタイプのために定義されています。リクエストの拒否理由はAUTH_ERRORのreject_statである場合には、二つの新しいauth_stat値の一つは、既存の値に加えて返すことができます。これら二つの新しい値は、要求の拒否のための既存の理由から、特別な意味を持っています。"
    },
    {
      "indent": 3,
      "text": "The server maintains a list of contexts for the clients that are currently in session with it.  Normally, a context is destroyed when the client ends the session corresponding to it.  However, due to resource constraints, the server may destroy a context prematurely (on an LRU basis, or if the server machine is rebooted, for example). In this case, when a client request comes in, there may not be a context corresponding to its handle. The server rejects the request, with the reason RPCSEC_GSS_CREDPROBLEM in this case.  Upon receiving this error, the client must refresh the context - that is, reestablish it after destroying the old one - and try the request again.  This error is also returned if the context handle matches that of a different context that was allocated after the client's context was destroyed (this will be detected by a failure in verifying the header checksum).",
      "ja": "サーバは、それとのセッションに現在あるクライアントのためのコンテキストのリストを維持します。クライアントは、それに対応するセッションを終了したとき、通常、コンテキストは破棄されます。しかし、リソースの制約のために、サーバは、（LRUベースで、またはサーバマシンを再起動する場合、例えば）早期コンテキストを破棄してもよいです。クライアントのリクエストが来たときに、この場合には、そのハンドルに対応するコンテキストがない可能性があります。サーバーは、この場合の理由RPCSEC_GSS_CREDPROBLEMと、要求を拒否します。 、つまり古いものを破壊した後、それを再確立 -   - このエラーを受信すると、クライアントはコンテキストを更新する必要があり、要求を再試行してください。コンテキスト・ハンドルは、クライアントのコンテキストが破壊された後に割り当てられた異なるコンテキスト（これはヘッダチェックサム検証に失敗することによって検出される）と一致する場合に、このエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If the GSS_VerifyMIC() call on the header checksum (contained in the verifier) fails to return GSS_S_COMPLETE, the server rejects the request and returns an auth_stat of RPCSEC_GSS_CREDPROBLEM.",
      "ja": "（検証に含まれる）ヘッダチェックサムにGSS_VerifyMIC（）呼び出しはGSS_S_COMPLETEを返すことに失敗した場合、サーバは要求を拒否し、RPCSEC_GSS_CREDPROBLEMのauth_statを返します。"
    },
    {
      "indent": 3,
      "text": "When the client's sequence number exceeds the maximum the server will allow, the server will reject the request with the reason RPCSEC_GSS_CTXPROBLEM.  Also, if security credentials become stale while in use (due to ticket expiry in the case of the Kerberos V5 mechanism, for example), the failures which result cause the RPCSEC_GSS_CTXPROBLEM reason to be returned.  In these cases also, the client must refresh the context, and retry the request.",
      "ja": "クライアントのシーケンス番号がサーバーが許可する最大値を超えた場合、サーバーは理由RPCSEC_GSS_CTXPROBLEMで要求を拒否します。セキュリティ資格情報が古くなった場合も、使用している（例えばケルベロスV5機構の場合、チケットの有効期限、のために）、結果として障害がRPCSEC_GSS_CTXPROBLEMの理由が返されることになりながら。また、これらのケースでは、クライアントはコンテキストを更新し、要求を再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "For other errors, retrying will not rectify the problem and the client must not refresh the context until the problem causing the client request to be denied is rectified.",
      "ja": "その他のエラーの場合、再試行は、問題を是正せず、クライアントの要求が拒否される原因となった問題が修正されるまで、クライアントはコンテキストを更新してはいけません。"
    },
    {
      "indent": 3,
      "text": "If the version field in the credential does not match the version of RPCSEC_GSS that was used when the context was created, the AUTH_BADCRED value is returned.",
      "ja": "資格でバージョンフィールドは、コンテキストが作成されたときに使用されたRPCSEC_GSSのバージョンと一致しない場合は、AUTH_BADCRED値が返されます。"
    },
    {
      "indent": 3,
      "text": "If there is a problem with the credential, such a bad length, illegal control procedure, or an illegal service, the appropriate auth_stat status is AUTH_BADCRED.",
      "ja": "資格は、そのような悪い長さ、違法な制御手順、または違法なサービスに問題がある場合は、適切なauth_statステータスはAUTH_BADCREDです。"
    },
    {
      "indent": 3,
      "text": "Other errors can be returned as appropriate.",
      "ja": "その他のエラーは、必要に応じて返すことができます。"
    },
    {
      "indent": 0,
      "text": "5.3.3.4.  Mapping of GSS-API Errors to Server Responses",
      "section_title": true,
      "ja": "5.3.3.4。サーバの応答にGSS-APIエラーのマッピング"
    },
    {
      "indent": 3,
      "text": "During the data exchange phase, the server may invoke GSS_GetMIC(), GSS_VerifyMIC(), GSS_Unwrap(), and GSS_Wrap(). If any of these routines fail to return GSS_S_COMPLETE, then various unsuccessful responses can be returned. The are described as follows for each of the aforementioned four interfaces.",
      "ja": "データ交換フェーズの間、サーバーはGSS_GetMIC（）を呼び出すことができる、GSS_VerifyMIC（）はgss_unwrap（）、およびにGSS_Wrap（）。これらのルーチンのいずれかがGSS_S_COMPLETEを返すのに失敗した場合は、その後、様々な失敗の応答を返すことができます。ザは、上記4つのインターフェイスのそれぞれについて、以下のように記載されています。"
    },
    {
      "indent": 0,
      "text": "5.3.3.4.1.  GSS_GetMIC() Failure",
      "section_title": true,
      "ja": "5.3.3.4.1。 GSS_GetMIC（）の失敗"
    },
    {
      "indent": 3,
      "text": "When GSS_GetMIC() is called to generate the verifier in the response, a failure results in an RPC response with a reply status of MSG_DENIED, reject status of AUTH_ERROR and an auth status of RPCSEC_GSS_CTXPROBLEM.",
      "ja": "GSS_GetMIC（）が応答して検証を生成するために呼び出されたとき、MSG_DENIEDの応答ステータスとRPC応答の失敗の結果は、AUTH_ERRORのステータスとRPCSEC_GSS_CTXPROBLEMの認証ステータスを拒否する。"
    },
    {
      "indent": 3,
      "text": "When GSS_GetMIC() is called to sign the call results (service is rpc_gss_svc_integrity), a failure results in no RPC response being sent. Since ONC RPC server applications will typically control when a response is sent, the failure indication will be returned to the server application and it can take appropriate action (such as logging the error).",
      "ja": "GSS_GetMICは、（）（サービスがrpc_gss_svc_integrityある）コール結果に署名するために呼び出された場合、無RPC応答の失敗の結果が送られています。応答が送信されるときONC RPCサーバーアプリケーションは、典型的に制御するので、失敗指示は、サーバ・アプリケーションに返されると、それは（このようなエラーをロギングなど）適切な処置をとることができます。"
    },
    {
      "indent": 0,
      "text": "5.3.3.4.2.  GSS_VerifyMIC() Failure",
      "section_title": true,
      "ja": "5.3.3.4.2。 GSS_VerifyMIC（）の失敗"
    },
    {
      "indent": 3,
      "text": "When GSS_VerifyMIC() is called to verify the verifier in request, a failure results in an RPC response with a reply status of MSG_DENIED, reject status of AUTH_ERROR and an auth status of RPCSEC_GSS_CREDPROBLEM.",
      "ja": "GSS_VerifyMICは（）要求で検証を検証するために呼び出されたとき、MSG_DENIEDの応答ステータスとRPC応答の失敗の結果は、AUTH_ERRORのステータスとRPCSEC_GSS_CREDPROBLEMの認証ステータスを拒否する。"
    },
    {
      "indent": 3,
      "text": "When GSS_VerifyMIC() is called to verify the call arguments (service is rpc_gss_svc_integrity), a failure results in an RPC response with a reply status of MSG_ACCEPTED, and an acceptance status of GARBAGE_ARGS.",
      "ja": "GSS_VerifyMICは、（）（サービスがrpc_gss_svc_integrityある）呼び出しの引数を検証するために呼び出されると、MSG_ACCEPTEDの返信状況、およびGARBAGE_ARGSの受け入れ状況とRPC応答の失敗の結果。"
    },
    {
      "indent": 0,
      "text": "5.3.3.4.3.  GSS_Unwrap() Failure",
      "section_title": true,
      "ja": "5.3.3.4.3。 gss_unwrap（）の失敗"
    },
    {
      "indent": 3,
      "text": "When GSS_Unwrap() is called to decrypt the call arguments (service is rpc_gss_svc_privacy), a failure results in an RPC response with a reply status of MSG_ACCEPTED, and an acceptance status of GARBAGE_ARGS.",
      "ja": "gss_unwrap（）はMSG_ACCEPTEDの返信状況とRPCの応答、およびGARBAGE_ARGSの受け入れ状況で失敗した結果、（サービスがrpc_gss_svc_privacyある）呼び出しの引数を復号化するために呼び出されたとき。"
    },
    {
      "indent": 0,
      "text": "5.3.3.4.4.  GSS_Wrap() Failure",
      "section_title": true,
      "ja": "5.3.3.4.4。 GSS_Wrap（）の失敗"
    },
    {
      "indent": 3,
      "text": "When GSS_Wrap() is called to encrypt the call results (service is rpc_gss_svc_privacy), a failure results in no RPC response being sent. Since ONC RPC server applications will typically control when a response is sent, the failure indication will be returned to the application and it can take appropriate action (such as logging the error).",
      "ja": "GSS_Wrap（）が（サービスがrpc_gss_svc_privacyある）コール結果を暗号化するために呼び出されると、無RPC応答の失敗の結果が送られています。応答が送信されるときONC RPCサーバーアプリケーションは、典型的に制御するので、故障表示がアプリケーションに返され、それは（このようなエラーをロギングなど）適切な処置をとることができます。"
    },
    {
      "indent": 0,
      "text": "5.4.  Context Destruction",
      "section_title": true,
      "ja": "5.4。コンテキスト破壊"
    },
    {
      "indent": 3,
      "text": "When the client is done using the session, it must send a control message informing the server that it no longer requires the context. This message is formulated just like a data request packet, with the following differences:  the credential has gss_proc set to RPCSEC_GSS_DESTROY, the procedure specified in the header is NULLPROC, and there are no procedure arguments.  The sequence number in the request must be valid, and the header checksum in the verifier must be valid, for the server to accept the message.  The server sends a response as it would to a data request.  The client and server must then destroy the context for the session.",
      "ja": "クライアントがセッションを使用して行われた場合、それはもはやコンテキストを必要とするサーバーを通知する制御メッセージを送信する必要があります。このメッセージは、以下の違いが、単にデータ要求パケットのように定式化される：クレデンシャルがRPCSEC_GSS_DESTROYに設定gss_proc有し、ヘッダで指定された手順はNULLPROCであり、およびNO手順引数が存在しません。リクエストのシーケンス番号が有効でなければならず、検証のヘッダチェックサムがメッセージを受け入れるサーバに対して、有効でなければなりません。サーバはデータ要求をするために同じような応答を送信します。クライアントとサーバは、セッションのコンテキストを破棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the request to destroy the context fails for some reason, the client need not take any special action.  The server must be prepared to deal with situations where clients never inform the server that they no longer are in session and so don't need the server to maintain a context.  An LRU mechanism or an aging mechanism should be employed by the server to clean up in such cases.",
      "ja": "コンテキストを破壊するための要求が何らかの理由で失敗した場合、クライアントは特別な行動を取る必要はありません。サーバーは、クライアントが、彼らはもはやセッションにあるので、コンテキストを維持するためにサーバを必要としないサーバーに通知したことがない状況に対処するために準備する必要があります。 LRU機構や老化のメカニズムは、そのような場合にクリーンアップするために、サーバによって採用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.  Set of GSS-API Mechanisms",
      "section_title": true,
      "ja": "GSS-APIメカニズムの6セット"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS is effectively a \"pass-through\" to the GSS-API layer, and as such it is inappropriate for the RPCSEC_GSS specification to enumerate a minimum set of required security mechanisms and/or quality of protections.",
      "ja": "RPCSEC_GSSを効果GSS-API層に「パススルー」であり、RPCSEC_GSS仕様は必要なセキュリティメカニズム及び/又は保護の質の最小セットを列挙するようなことは不適切です。"
    },
    {
      "indent": 3,
      "text": "If an application protocol specification references RPCSEC_GSS, the protocol specification must list a mandatory set of { mechanism, QOP, service } triples, such that an implementation cannot claim conformance to the protocol specification unless it implements the set of triples. Within each triple, mechanism is a GSS-API security mechanism, QOP is a valid quality-of-protection within the mechanism, and service is either rpc_gss_svc_integrity or rpc_gss_svc_privacy.",
      "ja": "アプリケーションプロトコル仕様参照RPCSEC_GSS場合、プロトコル仕様は、トリプルの集合を実装しない限り、実装がプロトコル仕様への適合を主張することができないように、必須の集合{機構、QOP、サービス}トリプルをリストしなければなりません。各トリプルの中で、この機構は、GSS-APIセキュリティー・メカニズムで、QOPは、有効な保護品質メカニズムの中で、サービスはrpc_gss_svc_integrityかrpc_gss_svc_privacyのいずれかです。"
    },
    {
      "indent": 3,
      "text": "For example, a network filing protocol built on RPC that depends on RPCSEC_GSS for security, might require that Kerberos V5 with the default QOP using the rpc_gss_svc_integrity service be supported by implementations conforming to the network filing protocol specification.",
      "ja": "たとえば、セキュリティのためRPCSEC_GSSに依存RPC上に構築されたネットワークファイリングプロトコルは、rpc_gss_svc_integrityサービスを使用して、デフォルトのQOPでのKerberos V5はネットワークファイリングプロトコル仕様に準拠した実装によってサポートされていることが必要になる場合があります。"
    },
    {
      "indent": 0,
      "text": "7.  Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1.  Privacy of Call Header",
      "section_title": true,
      "ja": "7.1。コールヘッダーのプライバシー"
    },
    {
      "indent": 3,
      "text": "The reader will note that for the privacy option, only the call arguments and results are encrypted. Information about the application in the form of RPC program number, program version number, and program procedure number is transmitted in the clear. Encrypting these fields in the RPC call header would have changed the size and format of the call header. This would have required revising the RPC protocol which was beyond the scope of this proposal. Storing the encrypted numbers in the credential would have obviated a protocol change, but would have introduced more overloading of fields and would have made implementations of RPC more complex. Even if the fields were encrypted somehow, in most cases an attacker can determine the program number and version number by examining the destination address of the request and querying the rpcbind service on the destination host [Srinivasan-bind].  In any case, even by not encrypting the three numbers, RPCSEC_GSS still improves the state of security over what existing RPC services have had available previously. Implementors of new RPC services that are concerned about this risk may opt to design in a \"sub-procedure\" field that is included in the service specific call arguments.",
      "ja": "読者は、プライバシーオプションのために、唯一の呼び出しの引数と結果が暗号化されていることに注意します。 RPCプログラム番号、プログラムのバージョン番号、およびプログラムの手順番号の形式でアプリケーションに関する情報が平文で送信されます。 RPC呼び出しヘッダでこれらのフィールドを暗号化は、呼ヘッダのサイズとフォーマットを変更したことになります。これは、この提案の範囲を超えていたRPCプロトコルを見直し必要としました。資格で暗号化された番号を格納することは、プロトコルの変更を不要にしているだろうが、フィールドのより多くのオーバーロードを導入しているだろうとRPCの実装はより複雑に作られているだろう。フィールドが何らかの形で暗号化された場合であっても、ほとんどの場合、攻撃者は、要求の宛先アドレスを調べ、宛先ホスト[スリニバサンバインド]上のrpcbindサービスを照会することによって、プログラム番号とバージョン番号を確認することができます。いずれの場合でも、でも3つの数値を暗号化しないことによって、RPCSEC_GSSはまだ既存のRPCサービスは、以前に利用できる持っていたものを上のセキュリティの状態を改善します。このリスクを懸念している新しいRPCサービスの実装者は、サービス固有の呼び出しの引数に含まれている「サブプロシージャ」フィールドに設計することを選ぶことがあります。"
    },
    {
      "indent": 0,
      "text": "7.2.  Sequence Number Attacks",
      "section_title": true,
      "ja": "7.2。シーケンス番号攻撃"
    },
    {
      "indent": 0,
      "text": "7.2.1.  Sequence Numbers Above the Window",
      "section_title": true,
      "ja": "7.2.1。ウィンドウの上にシーケンス番号"
    },
    {
      "indent": 3,
      "text": "An attacker cannot coax the server into raising the sequence number beyond the range the legitimate client is aware of (and thus engineer a denial of server attack) without constructing an RPC request that will pass the header checksum. If the cost of verifying the header checksum is sufficiently large (depending on the speed of the processor doing the checksum and the cost of checksum algorithm), it is possible to envision a denial of service attack (vandalism, in the form of wasting processing resources) whereby the attacker sends requests that are above the window. The simplest method might be for the attacker to monitor the network traffic and then choose a sequence number that is far above the current sequence number. Then the attacker can send bogus requests using the above window sequence number.",
      "ja": "攻撃者は、正当なクライアントが認識している範囲を超えて、シーケンス番号を上げるにサーバを同軸（したがって、サーバー拒否攻撃をエンジニア）ヘッダチェックサムを渡しますRPCリクエストを構築せずにすることはできません。ヘッダチェックサムの検証コストが十分に大きい場合（プロセッサチェックサムとチェックサムアルゴリズムのコストを行うの速度に応じて）、処理リソースを浪費の形で、サービス攻撃（破壊行為の拒否を想定することが可能です）これにより、攻撃者は、ウィンドウの上にあるリクエストを送信します。攻撃者がネットワークトラフィックを監視して、はるかに現在のシーケンス番号の上にあるシーケンス番号を選択するための最も簡単な方法があるかもしれません。その後、攻撃者は、上記のウィンドウシーケンス番号を使用して偽のリクエストを送信することができます。"
    },
    {
      "indent": 0,
      "text": "7.2.2.  Sequence Numbers Within or Below the Window",
      "section_title": true,
      "ja": "7.2.2。ウィンドウ内の以下のシーケンス番号"
    },
    {
      "indent": 3,
      "text": "If the attacker sends requests that are within or below the window, then even if the header checksum is successfully verified, the server will silently discard the requests because the server assumes it has already processed the request. In this case, a server can optimize by skipping the header checksum verification if the sequence number is below the window, or if it is within the window, not attempt the checksum verification if the sequence number has already been seen.",
      "ja": "攻撃者は、ウィンドウ内または下にあるリクエストを送信した場合、ヘッダのチェックサムが正常に確認された場合でも、サーバーは、要求を既に処理していると仮定しているため、その後、サーバは静かに要求を破棄します。この場合、シーケンス番号がウィンドウの下にある場合、サーバは、ヘッダチェックサム検証をスキップすることにより最適化することができ、またはそれは、ウィンドウ内にある場合、シーケンス番号が既に見られた場合、チェックサム検証を実行しません。"
    },
    {
      "indent": 0,
      "text": "7.3.  Message Stealing Attacks",
      "section_title": true,
      "ja": "7.3。攻撃を盗むメッセージ"
    },
    {
      "indent": 3,
      "text": "This proposal does not address attacks where an attacker can block or steal messages without being detected by the server. To implement such protection would be tantamount to assuming a state in the RPC service. RPCSEC_GSS does not worsen this situation.",
      "ja": "この提案は、攻撃者がサーバーによって検出されることなく、メッセージをブロックしたり盗むことができる攻撃には対応していません。このような保護を実装するには、RPCサービスの状態を仮定することと等しいだろう。 RPCSEC_GSSは、この状況を悪化させていません。"
    },
    {
      "indent": 0,
      "text": "Appendix A. GSS-API Major Status Codes",
      "ja": "付録A. GSS-APIの主なステータスコード"
    },
    {
      "indent": 3,
      "text": "The GSS-API definition [Linn] does not include numerical values for the various GSS-API major status codes. It is expected that this will be addressed in future RFC. Until then, this appendix defines the values for each GSS-API major status code listed in the GSS-API definition.  If in the future, the GSS-API definition defines values for the codes that are different than what follows, then implementors of RPCSEC_GSS will be obliged to map them into the values defined below. If in the future, the GSS-API definition defines additional status codes not defined below, then the RPCSEC_GSS definition will subsume those additional values.",
      "ja": "GSS-APIの定義[リン]様々なGSS-APIの主要なステータスコードの数値が含まれていません。将来のRFCで対処されることが期待されます。それまでは、この付録では、GSS-APIの定義に記載されている各GSS-APIの主要なステータスコードの値を定義します。将来的には、GSS-APIの定義は次のものとは異なっているコードの値を定義した場合は、RPCSEC_GSSの実装は、以下に定義された値にそれらをマッピングすることが義務付けされます。将来的には、GSS-APIの定義は、以下に定義されていない追加のステータスコードを定義した場合は、RPCSEC_GSS定義は、これらの追加の値を包摂します。"
    },
    {
      "indent": 3,
      "text": "Here are the definitions of each GSS_S_* major status that the implementor of RPCSEC_GSS can expect in the gss_major major field of rpc_gss_init_res.  These definitions are not in RPC description language form.  The numbers are in base 16 (hexadecimal):",
      "ja": "ここではRPCSEC_GSSの実装がrpc_gss_init_resのgss_major主要な分野で期待することができ、各GSS_S_ *主な状態の定義があります。これらの定義は、RPC記述言語形式ではありません。数字は、ベース16（16進数）です。"
    },
    {
      "indent": 6,
      "text": "GSS_S_COMPLETE                  0x00000000 GSS_S_CONTINUE_NEEDED           0x00000001 GSS_S_DUPLICATE_TOKEN           0x00000002 GSS_S_OLD_TOKEN                 0x00000004 GSS_S_UNSEQ_TOKEN               0x00000008 GSS_S_GAP_TOKEN                 0x00000010 GSS_S_BAD_MECH                  0x00010000 GSS_S_BAD_NAME                  0x00020000 GSS_S_BAD_NAMETYPE              0x00030000 GSS_S_BAD_BINDINGS              0x00040000 GSS_S_BAD_STATUS                0x00050000 GSS_S_BAD_MIC                   0x00060000 GSS_S_BAD_SIG                   0x00060000 GSS_S_NO_CRED                   0x00070000 GSS_S_NO_CONTEXT                0x00080000 GSS_S_DEFECTIVE_TOKEN           0x00090000 GSS_S_DEFECTIVE_CREDENTIAL      0x000a0000 GSS_S_CREDENTIALS_EXPIRED       0x000b0000 GSS_S_CONTEXT_EXPIRED           0x000c0000 GSS_S_FAILURE                   0x000d0000 GSS_S_BAD_QOP                   0x000e0000 GSS_S_UNAUTHORIZED              0x000f0000 GSS_S_UNAVAILABLE               0x00100000 GSS_S_DUPLICATE_ELEMENT         0x00110000 GSS_S_NAME_NOT_MN               0x00120000 GSS_S_CALL_INACCESSIBLE_READ    0x01000000 GSS_S_CALL_INACCESSIBLE_WRITE   0x02000000 GSS_S_CALL_BAD_STRUCTURE        0x03000000",
      "ja": "GSS_S_COMPLETE 0x00000000のGSS_S_CONTINUE_NEEDED 0x00000001のGSS_S_DUPLICATE_TOKEN 0x00000002 0x00000004 GSS_S_OLD_TOKEN GSS_S_UNSEQ_TOKEN 0x00000008 0x00000010 GSS_S_GAP_TOKEN GSS_S_BAD_MECH 0x00010000 0x00020000 GSS_S_BAD_NAME GSS_S_BAD_NAMETYPE 0x00030000 0x00040000 GSS_S_BAD_BINDINGS GSS_S_BAD_STATUS 0x00050000 0x00060000 GSS_S_BAD_MIC GSS_S_BAD_SIG 0x00060000 0x00070000 GSS_S_NO_CRED GSS_S_NO_CONTEXT 0x00080000 0x00090000 GSS_S_DEFECTIVE_TOKEN GSS_S_DEFECTIVE_CREDENTIAL 0x000a0000 GSS_S_CREDENTIALS_EXPIRED 0x000b0000 GSS_S_CONTEXT_EXPIRED 0x000c0000 GSS_S_FAILURE 0x000d0000 GSS_S_BAD_QOP 0x000e0000 GSS_S_UNAUTHORIZED 0x000f0000 GSS_S_UNAVAILABLE 0x00100000 GSS_S_DUPLI CATE_ELEMENT 0x00110000 0x00120000 GSS_S_NAME_NOT_MN GSS_S_CALL_INACCESSIBLE_READが0x01000000 0x02000000 GSS_S_CALL_INACCESSIBLE_WRITE GSS_S_CALL_BAD_STRUCTURE 0x03000000"
    },
    {
      "indent": 3,
      "text": "Note that the GSS-API major status is split into three fields as follows:",
      "ja": "次のようにGSS-APIの主要なステータスは三つのフィールドに分割されることに注意してください："
    },
    {
      "indent": 6,
      "text": "  Most Significant Bit                     Least Significant Bit\n  |------------------------------------------------------------|\n  | Calling Error | Routine Error  |    Supplementary Info     |\n  |------------------------------------------------------------|\nBit 31           24 23            16 15                        0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Up to one status in the Calling Error field can be logically ORed with up to one status in the Routine Error field which in turn can be logically ORed with zero or more statuses in the Supplementary Info field. If the resulting major status has a non-zero Calling Error and/or a non-zero Routine Error, then the applicable GSS-API operation has failed.  For purposes of RPCSEC_GSS, this means that the GSS_Accept_sec_context() call executed by the server has failed.",
      "ja": "呼び出しエラーフィールド内の1つの状態までは、論理的に順番に論理的に補足情報フィールドにゼロまたはそれ以上の状態とORすることができますルーチンエラーフィールドに最大1つの状態とORすることができます。その結果、主要なステータスがゼロ以外の呼び出しエラーおよび/または非ゼロのルーチンのエラーを持っている場合は、該当するGSS-API操作が失敗しました。 RPCSEC_GSSの目的のために、これは、サーバーで実行される場合gss_accept_sec_context（）の呼び出しが失敗したことを意味します。"
    },
    {
      "indent": 3,
      "text": "If the major status is equal GSS_S_COMPLETE, then this indicates the absence of any Errors or Supplementary Info.",
      "ja": "主要な状態が等しいGSS_S_COMPLETEである場合、これは誤りや補足情報がないことを示します。"
    },
    {
      "indent": 3,
      "text": "The meanings of most of the GSS_S_* status are defined in the GSS-API definition, which the exceptions of:",
      "ja": "GSS_S_ *状況のほとんどの意味はGSS-APIの定義の例外が定義されています。"
    },
    {
      "indent": 3,
      "text": "GSS_S_BAD_MIC       This code has the same meaning as GSS_S_BAD_SIG.",
      "ja": "GSS_S_BAD_MICこのコードはGSS_S_BAD_SIGと同じ意味を持ちます。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CALL_INACCESSIBLE_READ A required input parameter could not be read.",
      "ja": "GSS_S_CALL_INACCESSIBLE_READ A必要な入力パラメータを読み取ることができませんでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CALL_INACCESSIBLE_WRITE A required input parameter could not be written.",
      "ja": "GSS_S_CALL_INACCESSIBLE_WRITE A必要な入力パラメータを書き込むことができませんでした。"
    },
    {
      "indent": 3,
      "text": "GSS_S_CALL_BAD_STRUCTURE A parameter was malformed.",
      "ja": "GSS_S_CALL_BAD_STRUCTUREは、パラメータが不正な形式でした。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Much of the protocol was based on the AUTH_GSSAPI security flavor developed by Open Vision Technologies [Jaspan].  In particular, we acknowledge Barry Jaspan, Marc Horowitz, John Linn, and Ellen McDermott.",
      "ja": "プロトコルの多くは、オープン・ビジョン・テクノロジーズが開発したAUTH_GSSAPIセキュリティ風味[Jaspan]に基づいていました。特に、我々はバリーJaspan、マーク・ホロウィッツ、ジョン・リン、とエレンマクダーモットを認めます。"
    },
    {
      "indent": 3,
      "text": "Raj Srinivasan designed RPCSEC_GSS [Eisler] with input from Mike Eisler.  Raj, Roland Schemers, Lin Ling, and Alex Chiu contributed to Sun Microsystems' implementation of RPCSEC_GSS.",
      "ja": "ラジスリニバサンは、マイク・アイスラーからの入力とRPCSEC_GSS [アイスラー]を設計しました。ラジ、ローランドSchemers、リン・リング、そしてアレックス・チウはRPCSEC_GSSのSun Microsystemsの実装に貢献しました。"
    },
    {
      "indent": 3,
      "text": "Brent Callaghan, Marc Horowitz, Barry Jaspan, John Linn, Hilarie Orman, Martin Rex, Ted Ts'o, and John Wroclawski analyzed the specification and gave valuable feedback.",
      "ja": "ブレントキャラハン、マーク・ホロウィッツ、バリーJaspan、ジョン・リン、ヒラリーオーマン、マーティン・レックス、テッドTs'oさん、ジョンWroclawskiは、仕様を分析し、貴重なフィードバックを与えました。"
    },
    {
      "indent": 3,
      "text": "Steve Nahm and Kathy Slattery reviewed various drafts of this specification.",
      "ja": "スティーブ・Nahmとキャシースラッタリーは、本明細書の様々なドラフトをレビューしました。"
    },
    {
      "indent": 3,
      "text": "Much of content of Appendix A was excerpted from John Wray's Work in Progress on GSS-API Version 2 C-bindings.",
      "ja": "付録Aのコンテンツの多くは、GSS-APIバージョン2 C-バインディング上で進行中のジョン・レーの作品から抜粋されました。"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "リファレンス"
    },
    {
      "indent": 3,
      "text": "[Eisler]            Eisler, M., Schemers, R., and Srinivasan, R. (1996).  \"Security Mechanism Independence in ONC RPC,\" Proceedings of the Sixth Annual USENIX Security Symposium, pp. 51-65.",
      "ja": "【アイスラー]アイスラー、M.、Schemers、R.、およびスリニバサン、R.（1996）。 「ONC RPCでのセキュリティメカニズムの独立、」第6回USENIXセキュリティシンポジウム、頁51-65。"
    },
    {
      "indent": 3,
      "text": "[Jaspan]            Jaspan, B. (1995). \"GSS-API Security for ONC RPC,\" `95 Proceedings of The Internet Society Symposium on Network and Distributed System Security, pp. 144- 151.",
      "ja": "【Jaspan] Jaspan、B.（1995）。 「ONC RPC用GSS-APIセキュリティー、」ネットワーク上のインターネット協会シンポジウムと分散システムセキュリティの `95回の議事録、頁。144- 151。"
    },
    {
      "indent": 3,
      "text": "[Linn]              Linn, J., \"Generic Security Service Application Program Interface, Version 2\", RFC 2078, January 1997.",
      "ja": "[リン]リン、J.、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェース、バージョン2\"、RFC 2078、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[Srinivasan-bind]   Srinivasan, R., \"Binding Protocols for ONC RPC Version 2\", RFC 1833, August 1995.",
      "ja": "[スリニバサンバインド]スリニバサン、R.、RFC 1833、1995年8月 \"ONC RPCバージョン2への結合プロトコル\"。"
    },
    {
      "indent": 3,
      "text": "[Srinivasan-rpc]    Srinivasan, R., \"RPC: Remote Procedure Call Protocol Specification Version 2\", RFC 1831, August 1995.",
      "ja": "[スリニバサン-RPC]スリニバサン、R.、 \"RPC：リモートプロシージャコールプロトコル仕様バージョン2\"、RFC 1831、1995年8月。"
    },
    {
      "indent": 3,
      "text": "[Srinivasan-xdr]    Srinivasan, R., \"XDR: External Data Representation Standard\", RFC 1832, August 1995.",
      "ja": "[スリニバサン-XDR]スリニバサン、R.、 \"XDR：外部データ表現標準\"、RFC 1832、1995年8月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Michael Eisler Sun Microsystems, Inc. M/S UCOS03 2550 Garcia Avenue Mountain View, CA 94043",
      "ja": "マイケル・アイスラーサン・マイクロシステムズ株式会社M / S UCOS03 2550ガルシア・アベニューマウンテンビュー、CA 94043"
    },
    {
      "indent": 3,
      "text": "Phone: +1 (719) 599-9026 EMail: mre@eng.sun.com",
      "ja": "電話：+1（719）599-9026 Eメール：mre@eng.sun.com"
    },
    {
      "indent": 3,
      "text": "Alex Chiu Sun Microsystems, Inc. M/S UMPK17-203 2550 Garcia Avenue Mountain View, CA 94043",
      "ja": "アレックス・チウサン・マイクロシステムズ株式会社M / S UMPK17-203 2550ガルシア・アベニューマウンテンビュー、CA 94043"
    },
    {
      "indent": 3,
      "text": "Phone: +1 (415) 786-6465 EMail: hacker@eng.sun.com",
      "ja": "電話：+1（415）786-6465 Eメール：hacker@eng.sun.com"
    },
    {
      "indent": 3,
      "text": "Lin Ling Sun Microsystems, Inc. M/S UMPK17-201 2550 Garcia Avenue Mountain View, CA 94043",
      "ja": "リン・リングサン・マイクロシステムズ株式会社M / S UMPK17-201 2550ガルシア・アベニューマウンテンビュー、CA 94043"
    },
    {
      "indent": 3,
      "text": "Phone: +1 (415) 786-5084 EMail: lling@eng.sun.com",
      "ja": "電話：+1（415）786-5084 Eメール：lling@eng.sun.com"
    }
  ]
}