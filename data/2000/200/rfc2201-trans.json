{
  "title": {
    "text": "RFC 2201 - Core Based Trees (CBT) Multicast Routing Architecture",
    "ja": "RFC 2201 - コアベースの木（CBT）マルチキャストルーティングのアーキテクチャ"
  },
  "number": 2201,
  "created_at": "2019-10-17 22:07:49.138682+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       A. Ballardie\nRequest for Comments: 2201                                    Consultant\nCategory: Experimental                                    September 1997",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Core Based Trees (CBT) Multicast Routing Architecture",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo defines an Experimental Protocol for the Internet community.  This memo does not specify an Internet standard of any kind.  Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのためにExperimentalプロトコルを定義します。このメモはどんな種類のインターネット標準を指定しません。改善のための議論や提案が要求されています。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "CBT is a multicast routing architecture that builds a single delivery tree per group which is shared by all of the group's senders and receivers.  Most multicast algorithms build one multicast tree per sender (subnetwork), the tree being rooted at the sender's subnetwork.  The primary advantage of the shared tree approach is that it typically offers more favourable scaling characteristics than all other multicast algorithms.",
      "ja": "CBTは、グループの送信者と受信者のすべてによって共有されるグループごとに単一の配信ツリーを構築するマルチキャストルーティングアーキテクチャです。ほとんどのマルチキャストアルゴリズムは、送信者ごとに1つのマルチキャストツリー（サブネットワーク）を構築、ツリーは、送信者のサブネットワークをルートとしています。共有ツリーのアプローチの主な利点は、通常、他のすべてのマルチキャストのアルゴリズムよりも有利なスケーリング特性を提供することです。"
    },
    {
      "indent": 3,
      "text": "The CBT protocol [1] is a network layer multicast routing protocol that builds and maintains a shared delivery tree for a multicast group.  The sending and receiving of multicast data by hosts on a subnetwork conforms to the traditional IP multicast service model [2].",
      "ja": "CBTプロトコル[1]はビルド及びマルチキャストグループの共有配信ツリーを維持するネットワークレイヤマルチキャストルーティングプロトコルです。送信およびサブネットワーク上のホストがマルチキャストデータを受信すると、従来のIPマルチキャストサービスモデルに準拠している[2]。"
    },
    {
      "indent": 3,
      "text": "CBT is progressing through the IDMR working group of the IETF.  The CBT protocol is described in an accompanying document [1]. For this, and all IDMR-related documents, see http://www.cs.ucl.ac.uk/ietf/idmr",
      "ja": "CBTは、IETFのIDMRワーキンググループによって進められています。 CBTプロトコルは、添付文書に記載されている[1]。この、およびすべてのIDMR関連の書類については、http://www.cs.ucl.ac.uk/ietf/idmrを参照してください"
    },
    {
      "indent": 0,
      "text": "TABLE OF CONTENTS",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Background...................................................  2 2. Introduction.................................................  2 3. Source Based Tree Algorithms.................................  3 3.1 Distance-Vector Multicast Algorithm......................  4 3.2 Link State Multicast Algorithm...........................  5 3.3 The Motivation for Shared Trees..........................  5 4. CBT - The New Architecture...................................  7 4.1 Design Requirements......................................  7 4.2 Components & Functions...................................  8 4.2.1 CBT Control Message Retransmission Strategy........ 10 4.2.2 Non-Member Sending................................. 11 5. Interoperability with Other Multicast Routing Protocols ..... 11",
      "ja": "1.背景............................................... .... 2 2.はじめ.......................................... ....... 2 3.ソースベースのツリーアルゴリズム................................. 3 3.1距離 - ベクトルマルチキャストアルゴリズム...................... 4 3.2リンクステートマルチキャストアルゴリズム.................. ......... 5 3.3共有ツリーのための動機.......................... 5 4. CBT  - 新しいアーキテクチャ7つの4.1設計要件を................................... ........... ........................... 7つの4.2コンポーネントと機能.................. ................. 8 4.2.1 CBT制御メッセージの再送戦略........送信10 4.2.2非加盟........他のマルチキャストルーティングプロトコルで......................... 11 5.相互運用性..... 11"
    },
    {
      "indent": 3,
      "text": "6. Core Router Discovery........................................ 11 6.1 Bootstrap Mechanism Overview............................. 12 7. Summary ..................................................... 13 8. Security Considerations...................................... 13 Acknowledgements ............................................... 14 References ..................................................... 14 Author Information.............................................. 15",
      "ja": "6.コアルーター検出........................................ 11 6.1ブートストラップメカニズムの概要............................. 12 7.まとめ................. .................................... 13の8.セキュリティの考慮事項......... ............................. 13謝辞................... ............................ 14の参照.................... 14著者情報................................. .............. ................................ 15"
    },
    {
      "indent": 0,
      "text": "1.  Background",
      "section_title": true,
      "ja": "1.背景"
    },
    {
      "indent": 3,
      "text": "Shared trees were first described by Wall in his investigation into low-delay approaches to broadcast and selective broadcast [3]. Wall concluded that delay will not be minimal, as with shortest-path trees, but the delay can be kept within bounds that may be acceptable.  Back then, the benefits and uses of multicast were not fully understood, and it wasn't until much later that the IP multicast address space was defined (class D space [4]). Deering's work [2] in the late 1980's was pioneering in that he defined the IP multicast service model, and invented algorithms which allow hosts to arbitrarily join and leave a multicast group. All of Deering's multicast algorithms build source-rooted delivery trees, with one delivery tree per sender subnetwork. These algorithms are documented in [2].",
      "ja": "共有ツリーは、第1の低遅延に彼の調査に壁によって記載されたブロードキャスト及び選択的ブロードキャストに接近[3]。壁は、遅延が最短パス木と同様に、最小でないという結論が、遅延が許容できる範囲内に維持することができます。当時、利点及びマルチキャストの用途は完全には理解されていなかった、それはずっと後にIPマルチキャストアドレス空間が定義されたことまでではなかった（クラスD空間[4]）。ディーリングの作品は[2] 1980年代後半に、彼はIPマルチキャストサービスモデルを定義していることで先駆的、およびホストは任意のマルチキャストグループに参加して残すことができるようにするアルゴリズムを考案しました。ディーリングのマルチキャストアルゴリズムのすべては、送信者のサブネットワークごとに配信ツリーで、ソース・根ざし配信ツリーを構築します。これらのアルゴリズムは、[2]に記載されています。"
    },
    {
      "indent": 3,
      "text": "After several years practical experience with multicast, we see a diversity of multicast applications and correspondingly, a wide variety of multicast application requirements.  For example, distributed interactive simulation (DIS) applications have strict requirements in terms of join latency, group membership dynamics, group sender populations, far exceeding the requirements of many other multicast applications.",
      "ja": "マルチキャストで数年間実務経験の後、我々はそれに応じてマルチキャストアプリケーションの多様性と、マルチキャストアプリケーション要件の多種多様を参照してください。例えば、分散型インタラクティブシミュレーション（DIS）のアプリケーションは、はるかに多くの他のマルチキャストアプリケーションの要件を超えて、レイテンシ、グループメンバーシップのダイナミクス、グループの送信者集団を、参加の面で厳格な要件を持っています。"
    },
    {
      "indent": 3,
      "text": "The multicast-capable part of the Internet, the MBONE, continues to expand rapidly.  The obvious popularity and growth of multicast means that the scaling aspects of wide-area multicasting cannot be overlooked; some predictions talk of thousands of groups being present at any one time in the Internet.",
      "ja": "インターネットのマルチキャスト対応部分、MBONEは、急速に拡大し続けています。マルチキャストの明白な人気と成長は、広域マルチキャストのスケーリング側面は見過ごすことができないことを意味します。いくつかの予測は、グループの数千人がインターネットでいずれかの時点で存在すると話しています。"
    },
    {
      "indent": 3,
      "text": "We evaluate scalability in terms of network state maintenance, bandwidth efficiency, and protocol overhead. Other factors that can affect these parameters include sender set size, and wide-area distribution of group members.",
      "ja": "私たちは、ネットワーク状態の維持、帯域幅の効率化、およびプロトコルのオーバーヘッドの面でスケーラビリティを評価します。これらのパラメータに影響を与える可能性が他の要因には、送信者のセット・サイズ、およびグループメンバーの広域分布が含まれます。"
    },
    {
      "indent": 0,
      "text": "2.  Introduction",
      "section_title": true,
      "ja": "2.はじめに"
    },
    {
      "indent": 3,
      "text": "Multicasting on the local subnetwork does not require either the presence of a multicast router or the implementation of a multicast routing algorithm; on most shared media (e.g. Ethernet), a host, which need not necessarily be a group member, simply sends a multicast data packet, which is received by any member hosts connected to the same medium.",
      "ja": "ローカルサブネットワーク上のマルチキャストは、マルチキャストルータの存在またはマルチキャストルーティングアルゴリズムの実装のいずれかを必要としません。必ずしもグループのメンバである必要はない、ほとんどの共有媒体（例えばイーサネット（登録商標））、ホスト上、単に同じ培地に接続された任意のメンバホストによって受信されたマルチキャストデータパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "For multicasts to extend beyond the scope of the local subnetwork, the subnet must have a multicast-capable router attached, which itself is attached (possibly \"virtually\") to another multicast-capable router, and so on. The collection of these (virtually) connected multicast routers forms the Internet's MBONE.",
      "ja": "マルチキャストは、ローカルサブネットワークの範囲を超えて拡張するために、サブネットように別のマルチキャスト対応ルータに（おそらく「事実」）取り付けられており、それ自体、添付のマルチキャスト対応ルータを有していなければなりません。これらの（仮想的に）接続マルチキャストルータのコレクションは、インターネットのMBONEを形成しています。"
    },
    {
      "indent": 3,
      "text": "All multicast routing protocols make use of IGMP [5], a protocol that operates between hosts and multicast router(s) belonging to the same subnetwork. IGMP enables the subnet's multicast router(s) to monitor group membership presence on its directly attached links, so that if multicast data arrives, it knows over which of its links to send a copy of the packet.",
      "ja": "すべてのマルチキャストルーティングプロトコルは、IGMP [5]は、ホストと同じサブネットに属しているマルチキャストルータ（複数可）との間で動作するプロトコルを利用します。 IGMPは、マルチキャストデータが到着した場合、それはパケットのコピーを送信するために、そのリンクのその上に認識できるように、その直接接続されたリンク上のグループメンバーシップの有無を監視するために、サブネットのマルチキャストルータ（複数可）を可能にします。"
    },
    {
      "indent": 3,
      "text": "In our description of the MBONE so far, we have assumed that all multicast routers on the MBONE are running the same multicast routing protocol. In reality, this is not the case; the MBONE is a collection of autonomously administered multicast regions, each region defined by one or more multicast-capable border routers. Each region independently chooses to run whichever multicast routing protocol best suits its needs, and the regions interconnect via the \"backbone region\", which currently runs the Distance Vector Multicast Routing Protocol (DVMRP) [6]. Therefore, it follows that a region's border router(s) must interoperate with DVMRP.",
      "ja": "MBONEの私たちの説明ではこれまでのところ、我々はMBONE上のすべてのマルチキャストルータは、同じマルチキャストルーティングプロトコルを実行していることを前提としています。実際には、これはそうではありません。 MBONEは、1つまたは複数のマルチキャスト対応の境界ルータによって定義された各領域自律投与マルチキャスト領域の集合です。各領域は、独立して現在の距離ベクトルマルチキャストルーティングプロトコル（DVMRP）を実行する「骨格領域」を介して、マルチキャストルーティングプロトコルは、最良のニーズに合った方を実行することを選択し、及び領域相互接続[6]。したがって、地域の境界ルータ（s）はDVMRPと相互運用しなければならないことになります。"
    },
    {
      "indent": 3,
      "text": "Different algorithms use different techniques for establishing a distribution tree. If we classify these algorithms into source-based tree algorithms and shared tree algorithms, we'll see that the different classes have considerably different scaling characteristics, and the characteristics of the resulting trees differ too, for example, average delay. Let's look at source-based tree algorithms first.",
      "ja": "異なるアルゴリズムは、ディストリビューションツリーを確立するための様々な技術を使用しています。私たちは、ソースベースのツリーアルゴリズムと共有ツリーアルゴリズムにこれらのアルゴリズムを分類した場合、我々は、異なるクラスはかなり異なるスケーリング特性を有し、そして得られた木の特性は、例えば、あまりにも平均遅延を異なっていることがわかります。のは、最初のソースベースのツリーアルゴリズムを見てみましょう。"
    },
    {
      "indent": 0,
      "text": "3.  Source-Based Tree Algorithms",
      "section_title": true,
      "ja": "3.ソースベースのツリーアルゴリズム"
    },
    {
      "indent": 3,
      "text": "The strategy we'll use for motivating (CBT) shared tree multicast is based, in part, in explaining the characteristics of source-based tree multicast, in particular its scalability.",
      "ja": "私たちはやる気のために使用します戦略（CBT）共有ツリーマルチキャストは一部で、そのスケーラビリティ特に、ソースベースのツリーマルチキャストの特徴を説明するには、ベースにしています。"
    },
    {
      "indent": 3,
      "text": "Most source-based tree multicast algorithms are often referred to as \"dense-mode\" algorithms; they assume that the receiver population densely populates the domain of operation, and therefore the accompanying overhead (in terms of state, bandwidth usage, and/or processing costs) is justified.  Whilst this might be the case in a local environment, wide-area group membership tends to be sparsely distributed throughout the Internet.  There may be \"pockets\" of denseness, but if one views the global picture, wide-area groups tend to be sparsely distributed.",
      "ja": "ほとんどのソースベースのツリーマルチキャストアルゴリズムは、多くの場合、「密モード」アルゴリズムと呼ばれています。彼らは、受信人口が密集し、操作のドメインを移入し、それゆえ添付（状態の点では、帯域幅の使用、および/または処理コスト）オーバーヘッドが正当化されることを前提としています。これはローカル環境での場合であるかもしれない一方で、広域グループメンバーシップはまばらインターネット全体に分散される傾向があります。そこ緻密性の「ポケット」であってもよいが、1は全体像を見た場合、広域グループがまばらに分布する傾向があります。"
    },
    {
      "indent": 3,
      "text": "Source-based multicast trees are either built by a distance-vector style algorithm, which may be implemented separately from the unicast routing algorithm (as is the case with DVMRP), or the multicast tree may be built using the information present in the underlying unicast routing table (as is the case with PIM-DM [7]). The other algorithm used for building source-based trees is the link-state algorithm (a protocol instance being M-OSPF [8]).",
      "ja": "ソースベースのマルチキャストツリーはいずれかユニキャストルーティングアルゴリズムは別に実施することができる距離ベクトル形式のアルゴリズムによって構築される（DVMRPの場合のように）、又はマルチキャストツリーは、基礎となるユニキャスト中に存在する情報を使用して構築することができますルーティングテーブル（PIM-DMの場合のように[7]）。ソースベースのツリーを構築するために使用される他のアルゴリズムは、リンクステートアルゴリズム（M-OSPFあるプロトコルインスタンス[8]）です。"
    },
    {
      "indent": 0,
      "text": "3.1.  Distance-Vector Multicast Algorithm",
      "section_title": true,
      "ja": "3.1。距離ベクトルマルチキャストアルゴリズム"
    },
    {
      "indent": 3,
      "text": "The distance-vector multicast algorithm builds a multicast delivery tree using a variant of the Reverse-Path Forwarding technique [9]. The technique basically is as follows: when a multicast router receives a multicast data packet, if the packet arrives on the interface used to reach the source of the packet, the packet is forwarded over all outgoing interfaces, except leaf subnets with no members attached.  A \"leaf\" subnet is one which no router would use to reach the souce of a multicast packet. If the data packet does not arrive over the link that would be used to reach the source, the packet is discarded.",
      "ja": "距離ベクトルマルチキャストアルゴリズムは、逆パス転送技術の変形を用いて、マルチキャスト配信ツリーを構築する[9]。パケットは、パケットの送信元に到達するために使用されるインターフェイスに到着した場合、マルチキャストルータは、マルチキャストデータパケットを受信した場合、パケットが結合しないメンバーとリーフサブネットを除き、すべての発信インターフェイスを介して転送される：技術は、基本的に以下の通りです。 「リーフ」のサブネットには、ルータがマルチキャストパケットの源泉に到達するために使用しないだろうものです。データパケットが送信元に到達するために使用されるリンクの上に到着しない場合、パケットは破棄されます。"
    },
    {
      "indent": 3,
      "text": "This constitutes a \"broadcast & prune\" approach to multicast tree construction; when a data packet reaches a leaf router, if that router has no membership registered on any of its directly attached subnetworks, the router sends a prune message one hop back towards the source. The receiving router then checks its leaf subnets for group membership, and checks whether it has received a prune from all of its downstream routers (downstream with respect to the source). If so, the router itself can send a prune upstream over the interface leading to the source.",
      "ja": "これは、マルチキャストツリーの構築へ「放送＆プルーン」アプローチを構成しています。データパケットがリーフルータに到達したときにルータがその直接接続されているサブネットワークのいずれかに登録されたメンバーシップを持っていない場合は、ルータが戻っソースへのプルーンメッセージ1つのホップを送信します。受信ルータは、グループメンバーシップのためにその葉サブネットをチェックし、それがその下流のルータの全てからプルーンを受信したか否かをチェックする（ソースに対して下流）。その場合、ルータ自体がソースにつながるインターフェイスを介して上流のプルーンを送ることができます。"
    },
    {
      "indent": 3,
      "text": "The sender and receiver of a prune message must cache the <source, group> pair being reported, for a \"lifetime\" which is at the granularity of minutes. Unless a router's prune information is refreshed by the receipt of a new prune for <source, group> before its \"lifetime\" expires, that information is removed, allowing data to flow over the branch again. State that expires in this way is referred to as \"soft state\".",
      "ja": "プルーンメッセージの送信者と受信者は分の単位である「寿命」を報告されている<ソース、グループ>ペアをキャッシュしなければなりません。ルータのプルーン情報は、その「寿命」は、有効期限が切れる前に<ソース、グループ>のための新たなプルーンの受信によって更新されていない場合、その情報は、データが再び枝の上に流れるように、削除されます。このように失効状態を「ソフト状態」と呼ぶことにします。"
    },
    {
      "indent": 3,
      "text": "Interestingly, routers that do not lead to group members are incurred the state overhead incurred by prune messages. For wide-area multicasting, which potentially has to support many thousands of active groups, each of which may be sparsely distributed, this technique clearly does not scale.",
      "ja": "興味深いことに、グループメンバーにつながらないルータは、Pruneメッセージによって生じた状態のオーバーヘッドが発生しています。潜在的にまばらに分散させることができるそれぞれが活性基の数千をサポートしなければならない広域マルチキャスト、のために、この技術は明らかにスケールしません。"
    },
    {
      "indent": 0,
      "text": "3.2.  Link-State Multicast Algorithm",
      "section_title": true,
      "ja": "3.2。リンクステートマルチキャストアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Routers implementing a link state algorithm periodically collect reachability information to their directly attached neighbours, then flood this throughout the routing domain in so-called link state update packets. Deering extended the link state algorithm for multicasting by having a router additionally detect group membership changes on its incident links before flooding this information in link state packets.",
      "ja": "定期的に直接接続されたネイバーに到達可能性情報を収集し、リンクステートアルゴリズムを実装するルータは、その後、いわゆるリンク状態更新パケットのルーティングドメイン全体にこれをあふれさせます。デアリングは、ルータがさらにリンク状態パケットにこの情報をあふれさせる前に、その入射リンク上のグループメンバーシップの変更を検出したことにより、マルチキャストのためのリンク状態アルゴリズムを拡張しました。"
    },
    {
      "indent": 3,
      "text": "Each router then, has a complete, up-to-date image of a domain's topology and group membership. On receiving a multicast data packet, each router uses its membership and topology information to calculate a shortest-path tree rooted at the sender subnetwork. Provided the calculating router falls within the computed tree, it forwards the data packet over the interfaces defined by its calculation. Hence, multicast data packets only ever traverse routers leading to members, either directly attached, or further downstream. That is, the delivery tree is a true multicast tree right from the start.",
      "ja": "その後、各ルータは、ドメインのトポロジおよびグループメンバーシップの完全な、最新の画像を持っています。マルチキャストデータパケットを受信すると、各ルータは、送信側のサブネットワークをルートと最短パスツリーを計算し、そのメンバーシップとトポロジー情報を使用しています。提供される計算のルータは、計算されたツリー内に入ると、その演算により定義されたインタフェースを介してデータパケットを転送します。したがって、マルチキャストデータパケットしかトラバースルータは、直接取り付けられた、またはさらに下流、メンバーにつながります。これは、配信ツリーが最初から真のマルチキャストツリーの権利である、です。"
    },
    {
      "indent": 3,
      "text": "However, the flooding (reliable broadcasting) of group membership information is the predominant factor preventing the link state multicast algorithm being applicable over the wide-area.  The other limiting factor is the processing cost of the Dijkstra calculation to compute the shortest-path tree for each active source.",
      "ja": "しかし、グループメンバーシップ情報の氾濫（信頼性の高い放送）が広域にわたり適用されてリンク状態マルチキャストアルゴリズムを防ぐ主な要因です。他の制限要因は、各アクティブ・ソースの最短パス木を計算するダイクストラ計算の処理コストです。"
    },
    {
      "indent": 0,
      "text": "3.3.  The Motivation for Shared Trees",
      "section_title": true,
      "ja": "3.3。共有ツリーのための動機"
    },
    {
      "indent": 3,
      "text": "The algorithms described in the previous sections clearly motivate the need for a multicast algorithm(s) that is more scalable. CBT was designed primarily to address the topic of scalability; a shared tree architecture offers an improvement in scalability over source tree architectures by a factor of the number of active sources (where source is usually a subnetwork aggregate).  Source trees scale O(S * G), since a distinct delivery tree is built per active source. Shared trees eliminate the source (S) scaling factor; all sources use the same shared tree, and hence a shared tree scales O(G).  The implication of this is that applications with many active senders, such as distributed interactive simulation applications, and distributed video-gaming (where most receivers are also senders), have a significantly lesser impact on underlying multicast routing if shared trees are used.",
      "ja": "前のセクションで説明したアルゴリズムは明らかに、より拡張性のあるマルチキャストアルゴリズム（複数可）の必要性を動機づける。 CBTは、拡張性の話題に対処するために主に設計されました。共有ツリーアーキテクチャは、（ソースは、通常、サブネットワークの集合体である）、アクティブソースの数倍にソースツリーアーキテクチャ上の拡張性の向上を提供します。異なる配信ツリーがアクティブソースごとに構築されているので、ソースツリーは、O（S * G）をスケール。共有ツリーは、スケーリング係数ソース（S）を排除します。すべてのソースは、同じ共有ツリーを使用し、従って、共有ツリーがO（G）をスケーリングします。これの意味するところは、共有ツリーが使用される場合、このような分散型のインタラクティブシミュレーション・アプリケーションなどの多くのアクティブの送信者、および（ほとんどの受信機はまた、送信者である）は、分散ビデオゲームとアプリケーションは、基礎となるマルチキャストルーティングに有意に少ない影響を有することです。"
    },
    {
      "indent": 3,
      "text": "In the \"back of the envelope\" table below we compare the amount of state required by CBT and DVMRP for different group sizes with different numbers of active sources:",
      "ja": "下の表「封筒の裏」で、我々は、アクティブなソースの数が異なる別のグループの大きさのためにCBTとDVMRPによって必要な状態の量を比較します："
    },
    {
      "indent": 2,
      "text": "|--------------|---------------------------------------------------|\n|  Number of   |                |                |                 |\n|    groups    |        10      |       100      |        1000     |\n====================================================================\n|  Group size  |                |                |                 |\n| (# members)  |        20      |       40       |         60      |\n-------------------------------------------------------------------|\n| No. of srcs  |    |     |     |    |     |     |    |     |      |\n|  per group   |10% | 50% |100% |10% | 50% |100% |10% | 50% | 100% |\n--------------------------------------------------------------------\n| No. of DVMRP |    |     |     |    |     |     |    |     |      |\n|    router    |    |     |     |    |     |     |    |     |      |\n|   entries    | 20 | 100 | 200 |400 | 2K  | 4K  | 6K | 30K | 60K  |\n--------------------------------------------------------------------\n| No. of CBT   |                |                |                 |\n|  router      |                |                |                 |\n|  entries     |       10       |       100      |       1000      |\n|------------------------------------------------------------------|",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 1: Comparison of DVMRP and CBT Router State",
      "ja": "図1：DVMRPとCBTルータの状態の比較"
    },
    {
      "indent": 3,
      "text": "Shared trees also incur significant bandwidth and state savings compared with source trees; firstly, the tree only spans a group's receivers (including links/routers leading to receivers) -- there is no cost to routers/links in other parts of the network. Secondly, routers between a non-member sender and the delivery tree are not incurred any cost pertaining to multicast, and indeed, these routers need not even be multicast-capable -- packets from non-member senders are encapsulated and unicast to a core on the tree.",
      "ja": "共有ツリーは、ソースツリーと比較して有意な帯域幅と状態の節約を招きます。まず、木は（受信機につながるリンク/ルータを含む）グループの受信機にまたがる - ネットワークの他の部分のルータ/リンクへのコストはありません。第二に、非会員の送信者と配信ツリーとの間のルータがマルチキャストに関連する任意のコストを負担されていない、実際、これらのルータもマルチキャスト対応である必要はない - 非会員の送信者からのパケットは、上のコアに封入されたユニキャストされますツリー。"
    },
    {
      "indent": 3,
      "text": "The figure below illustrates a core based tree.",
      "ja": "以下の図は、コアベースのツリーを示す図です。"
    },
    {
      "indent": 11,
      "text": "b      b     b-----b\n \\     |     |\n  \\    |     |\n   b---b     b------b\n  /     \\  /                   KEY....\n /       \\/\nb         X---b-----b          X = Core\n         / \\                   b = on-tree router\n        /   \\\n       /     \\\n       b      b------b\n      / \\     |\n     /   \\    |\n    b     b   b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Figure 2: CBT Tree",
      "ja": "図2：CBTツリー"
    },
    {
      "indent": 0,
      "text": "4.  CBT - The New Architecture",
      "section_title": true,
      "ja": "4. CBT  - 新しいアーキテクチャ"
    },
    {
      "indent": 0,
      "text": "4.1.  Design Requirements",
      "section_title": true,
      "ja": "4.1。設計要件"
    },
    {
      "indent": 3,
      "text": "The CBT shared tree design was geared towards several design objectives:",
      "ja": "CBT共有ツリーのデザインは、いくつかの設計目標に向けました。"
    },
    {
      "indent": 3,
      "text": "o    scalability - the CBT designers decided not to sacrifice CBT's O(G) scaling characteric to optimize delay using SPTs, as does PIM.  This was an important design decision, and one, we think, was taken with foresight; once multicasting becomes ubiquitous, router state maintenance will be a predominant scaling factor. It is possible in some circumstances to improve/optimize the delay of shared trees by other means. For example, a broadcast-type lecture with a single sender (or limited set of infrequently changing senders) could have its core placed in the locality of the sender, allowing the CBT to emulate a shortest-path tree (SPT) whilst still maintaining its O(G) scaling characteristic. More generally, because CBT does not incur source-specific state, it is particularly suited to many sender applications.",
      "ja": "Oスケーラビリティ -  PIMが行うようCBT設計者は、CBTのO（G）SPTはを使用して遅延を最適化するcharactericスケーリングを犠牲にしないことを決定しました。これは重要な設計上の決定だった、もう一つは、私たちが考える、先見の明で撮影されました。マルチキャストがユビキタスになると、ルータの状態の維持には、支配的なスケーリングファクターとなります。これは、他の手段によって共有ツリーの遅延を最適化する/改善するために、いくつかの状況で可能です。例えば、単一の送信者（またはまれに変更する送信者の限られたセット）と放送型講義は、そのコアが依然として維持しながら、最短経路ツリー（SPT）をエミュレートするためにCBTを可能にする、送信者の地域に配置されている可能性があり、そのO（G）特性をスケーリングします。 CBTは、ソース固有の状態が発生しないので、より一般的には、それは多くの送信元アプリケーションに特に適しています。"
    },
    {
      "indent": 3,
      "text": "o    robustness - source-based tree algorithms are clearly robust; a sender simply sends its data, and intervening routers \"conspire\" to get the data where it needs to, creating state along the way. This is the so-called \"data driven\" approach -- there is no set-up protocol involved.",
      "ja": "O堅牢性 - ソースベースのツリーアルゴリズムは明らかに頑丈です。送信者は、単にそのデータを送信し、介在ルータは道に沿って状態を作り出す、それが必要なデータを取得するには、「共謀します」。関与なしセットアッププロトコルはありません - これは、アプローチ、いわゆる「データ駆動型」です。"
    },
    {
      "indent": 8,
      "text": "It is not as easy to achieve the same degree of robustness in shared tree algorithms; a shared tree's core router maintains connectivity between all group members, and is thus a single point of failure.  Protocol mechanisms must be present that ensure a core failure is detected quickly, and the tree reconnected quickly using a replacement core router.",
      "ja": "共有ツリーアルゴリズムにおける堅牢性と同程度を達成するために簡単ではありません。共有ツリーのコアルータは、すべてのグループメンバー間の接続を維持し、したがって、単一障害点です。プロトコルメカニズムは、コアの障害を迅速に検出、およびツリーが交換コア・ルータを使用して迅速に再接続されていることを確認し、その存在していなければなりません。"
    },
    {
      "indent": 3,
      "text": "o    simplicity - the CBT protocol is relatively simple compared to most other multicast routing protocols. This simplicity can lead to enhanced performance compared to other protocols.",
      "ja": "O単純 -  CBTプロトコルは、他のほとんどのマルチキャストルーティングプロトコルに比べて比較的簡単です。このシンプルさは、他のプロトコルに比べて性能の向上につながることができます。"
    },
    {
      "indent": 3,
      "text": "o    interoperability - from a multicast perspective, the Internet is a collection of heterogeneous multicast regions. The protocol interconnecting these multicast regions is currently DVMRP [6]; any regions not running DVMRP connect to the DVMRP \"backbone\" as stub regions.  CBT has well-defined interoperability mechanisms with DVMRP [15].",
      "ja": "Oの相互運用性 - マルチキャストの観点から、インターネットは異質マルチキャスト地域の集まりです。これらのマルチキャスト領域を相互接続プロトコルは現在、DVMRPである[6]。任意の領域はDVMRPがスタブ領域としてDVMRP「バックボーン」への接続動作していません。 CBTは、DVMRP [15]との相互運用性のメカニズムを明確に定義されています。"
    },
    {
      "indent": 0,
      "text": "4.2.  CBT Components & Functions",
      "section_title": true,
      "ja": "4.2。 CBTコンポーネントと機能"
    },
    {
      "indent": 3,
      "text": "The CBT protocol is designed to build and maintain a shared multicast distribution tree that spans only those networks and links leading to interested receivers.",
      "ja": "CBTプロトコルは興味を持って受信機につながるだけでこれらのネットワークとのリンクにまたがる共有マルチキャスト配信ツリーを構築し、維持するように設計されています。"
    },
    {
      "indent": 3,
      "text": "To achieve this, a host first expresses its interest in joining a group by multicasting an IGMP host membership report [5] across its attached link. On receiving this report, a local CBT aware router invokes the tree joining process (unless it has already) by generating a JOIN_REQUEST message, which is sent to the next hop on the path towards the group's core router (how the local router discovers which core to join is discussed in section 6). This join message must be explicitly acknowledged (JOIN_ACK) either by the core router itself, or by another router that is on the unicast path between the sending router and the core, which itself has already successfully joined the tree.",
      "ja": "これを達成するために、ホストは最初に取り付けたリンクを介してIGMPホストメンバーシップレポート[5]をマルチキャストすることにより、グループへの参加にその関心を表現しています。 （それが既に持っている場合を除き）このレポートを受信すると、ローカルCBT認識ルータは、グループのコア・ルータに向かって経路上の次のホップに送信されるJOIN_REQUESTメッセージ、（コアどのローカルルータの発見を生成することによって、木接合プロセスを呼び出します参加する）のセクション6に記載されています。この参加メッセージは、明示的にコアルータ自体によって、または既に正常ツリーに参加している自分自身送信ルータとコアとの間のユニキャスト経路上にある別のルータ、のいずれかによって（JOIN_ACK）を認めなければなりません。"
    },
    {
      "indent": 3,
      "text": "The join message sets up transient join state in the routers it traverses, and this state consists of <group, incoming interface, outgoing interface>. \"Incoming interface\" and \"outgoing interface\" may be \"previous hop\" and \"next hop\", respectively, if the corresponding links do not support multicast transmission. \"Previous hop\" is taken from the incoming control packet's IP source address, and \"next hop\" is gleaned from the routing table - the next hop to the specified core address. This transient state eventually times out unless it is \"confirmed\" with a join acknowledgement (JOIN_ACK) from upstream. The JOIN_ACK traverses the reverse path of the corresponding join message, which is possible due to the presence of the transient join state.  Once the acknowledgement reaches the router that originated the join message, the new receiver can receive traffic sent to the group.",
      "ja": "参加メッセージは、過渡が横断ルータ状態の参加設定し、この状態では、<グループ、着信インターフェース、出力インターフェース>で構成されています。対応するリンクがマルチキャスト送信をサポートしていない場合は「受信インターフェース」と「発信インターフェース」は、それぞれ「前ホップ」と「ネクストホップ」であってもよいです。 「前ホップ」は、着信制御パケットのIPソースアドレスから取得され、そして「次のホップ」は、ルーティングテーブルから収集された - 指定されたコアのアドレスの次のホップ。最終的にタイムアウトし、それがある場合を除き、この過渡状態では、上流からの参加確認（JOIN_ACK）で「確認しました」。 JOIN_ACKは過渡参加状態が存在することが可能である対応する参加メッセージの逆のパスを横切ります。確認が参加メッセージを発信したルータに到達すると、新しい受信機がグループに送信されたトラフィックを受信することができます。"
    },
    {
      "indent": 3,
      "text": "Loops cannot be created in a CBT tree because a) there is only one active core per group, and b) tree building/maintenance scenarios which may lead to the creation of tree loops are avoided.  For example, if a router's upstream neighbour becomes unreachable, the router immediately \"flushes\" all of its downstream branches, allowing them to individually rejoin if necessary.  Transient unicast loops do not pose a threat because a new join message that loops back on itself will never get acknowledged, and thus eventually times out.",
      "ja": "A）がグループごとに1つだけアクティブなコアであり、ツリーループの創出につながる可能性B）ツリー構築/維持シナリオが回避されるため、ループはCBTツリー内に作成することができません。たとえば、ルータの上流ネイバーが到達不能になった場合、ルータはすぐに「フラッシュ」その下流の枝のすべて、必要に応じて、個別に再参加することができます。自身に戻り、新しい参加メッセージが最終的にタイムアウトこれを認めない、と飽きないだろうので、一時的なユニキャストループが脅威をもたらすことはありません。"
    },
    {
      "indent": 3,
      "text": "The state created in routers by the sending or receiving of a JOIN_ACK is bi-directional - data can flow either way along a tree \"branch\", and the state is group specific - it consists of the group address and a list of local interfaces over which join messages for the group have previously been acknowledged. There is no concept of \"incoming\" or \"outgoing\" interfaces, though it is necessary to be able to distinguish the upstream interface from any downstream interfaces. In CBT, these interfaces are known as the \"parent\" and \"child\" interfaces, respectively.",
      "ja": "データがツリー「枝」に沿っていずれかの方法を流すことができ、状態は、グループ特異的である -   - 送信またはJOIN_ACKを受信することにより、ルータで作成状態は、双方向であり、それはグループ・アドレスとローカルインタフェースのリスト上から成りどのグループのメッセージを参加は、以前に認識されています。任意の下流インタフェースから上流のインタフェースを区別できるようにする必要があるが、「受信」または「送信」インターフェースの概念は、存在しません。 CBTでは、これらのインタフェースは、それぞれ、「親」と「子」インターフェースとして知られています。"
    },
    {
      "indent": 3,
      "text": "With regards to the information contained in the multicast forwarding cache, on link types not supporting native multicast transmission an on-tree router must store the address of a parent and any children. On links supporting multicast however, parent and any child information is represented with local interface addresses (or similar identifying information, such as an interface \"index\") over which the parent or child is reachable.",
      "ja": "リンクタイプのマルチキャスト転送キャッシュに含まれている情報に関しては、上のツリールータネイティブマルチキャスト送信ANをサポートしていないと、親のアドレスと任意の子供を格納する必要があります。しかし、マルチキャストをサポートするリンクを、親と子の情報は、親または子が到達可能である上に（例えばインターフェース「インデックス」として、または同様の識別情報、）ローカルインターフェイスアドレスで表されています。"
    },
    {
      "indent": 3,
      "text": "When a multicast data packet arrives at a router, the router uses the group address as an index into the multicast forwarding cache. A copy of the incoming multicast data packet is forwarded over each interface (or to each address) listed in the entry except the incoming interface.",
      "ja": "マルチキャストデータパケットがルータに到着すると、ルータは、マルチキャスト転送キャッシュへのインデックスとしてグループアドレスを使用しています。着信マルチキャストデータパケットのコピーは、着信インターフェイス以外のエントリにリストされた各インターフェイス（または各アドレス）を介して転送されます。"
    },
    {
      "indent": 3,
      "text": "Each router that comprises a CBT multicast tree, except the core router, is responsible for maintaining its upstream link, provided it has interested downstream receivers, i.e. the child interface list is not NULL. A child interface is one over which a member host is directly attached, or one over which a downstream on-tree router is attached.  This \"tree maintenance\" is achieved by each downstream router periodically sending a \"keepalive\" message (ECHO_REQUEST) to its upstream neighbour, i.e. its parent router on the tree. One keepalive message is sent to represent entries with the same parent, thereby improving scalability on links which are shared by many groups.  On multicast capable links, a keepalive is multicast to the \"all-cbt-routers\" group (IANA assigned as 224.0.0.15); this has a suppressing effect on any other router for which the link is its parent link.  If a parent link does not support multicast transmission, keepalives are unicast.",
      "ja": "コアルータを除き、その上流リンクを維持する責任があり、CBTマルチキャストツリーを構成する各ルータは、それが、下流の受信機を興味している、すなわち子インターフェイスリストがNULLではないが提供されます。子インターフェースは、メンバーホストが直接結合している上に一つ又は下流にツリールータが結合している上です。この「ツリーメンテナンス」は、各ダウンストリームルータは定期的にその上流隣接、ツリー上で、すなわち親ルータに「キープアライブ」メッセージ（ECHO_REQUEST）を送信することによって達成されます。一のキープアライブメッセージは、それによって多くのグループによって共有されているリンク上のスケーラビリティを向上させる、同じ親を持つエントリを表すために送信されます。マルチキャスト可能なリンク上で、キープアライブは、「全CBT-ルータ」基（224.0.0.15として割り当てIANA）にマルチキャストされます。これは、リンクがその親リンクされている他のルータ上の抑制効果を持っています。親リンクがマルチキャスト伝送をサポートしていない場合、キープアライブはユニキャストです。"
    },
    {
      "indent": 3,
      "text": "The receipt of a keepalive message over a valid child interface immediately prompts a response (ECHO_REPLY), which is either unicast or multicast, as appropriate.",
      "ja": "有効な子インタフェースを介してキープアライブメッセージの受信は、即座に適切なように、ユニキャストまたはマルチキャストのいずれかで応答（ECHO_REPLY）を促します。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST does not contain any group information; the ECHO_REPLY does, but only periodically. To maintain consistent information between parent and child, the parent periodically reports, in a ECHO_REPLY, all groups for which it has state, over each of its child interfaces for those groups. This group-carrying echo reply is not prompted explicitly by the receipt of an echo request message.  A child is notified of the time to expect the next echo reply message containing group information in an echo reply prompted by a child's echo request. The frequency of parent group reporting is at the granularity of minutes.",
      "ja": "ECHO_REQUESTは、任意のグループの情報が含まれていません。 ECHO_REPLYはありませんが、唯一の定期的。親と子の間で一貫性のある情報を維持するために、親は定期的にそれらのグループのためにその子の各インタフェースを介して、ECHO_REPLYで、それは状態を持っているすべてのグループを報告します。このグループ保有エコー応答は、エコー要求メッセージの受信によって明示的に要求されません。子供は子供のエコー要求により促さエコー応答におけるグループ情報を含む次のエコー応答メッセージを期待するのは時間が通知されます。親グループの報告の頻度は、分の粒度です。"
    },
    {
      "indent": 3,
      "text": "It cannot be assumed all of the routers on a multi-access link have a uniform view of unicast routing; this is particularly the case when a multi-access link spans two or more unicast routing domains. This could lead to multiple upstream tree branches being formed (an error condition) unless steps are taken to ensure all routers on the link agree which is the upstream router for a particular group. CBT routers attached to a multi-access link participate in an explicit election mechanism that elects a single router, the designated router (DR), as the link's upstream router for all groups. Since the DR might not be the link's best next-hop for a particular core router, this may result in join messages being re-directed back across a multi-access link. If this happens, the re-directed join message is unicast across the link by the DR to the best next-hop, thereby preventing a looping scenario.  This re-direction only ever applies to join messages.  Whilst this is suboptimal for join messages, which are generated infrequently, multicast data never traverses a link more than once (either natively, or encapsulated).",
      "ja": "ユニキャストルーティングの均一なビューを有するマルチアクセスリンク上のルータのすべてを仮定することはできません。これは、特に、マルチアクセスリンクは、2つの以上のユニキャストルーティングドメインにまたがる場合です。これは、ステップが、リンク上のすべてのルータが特定のグループのアップストリームルータである同意を確認するために取られない限り、（エラー状態）に形成された複数の上流の木の枝につながる可能性があります。マルチアクセスリンクに接続CBTルータは、すべてのグループのリンクのアップストリームルータとして、単一ルータ、指定ルータ（DR）を選出明示的な選択メカニズムに関与します。 DRは、特定のコアルータのリンクの最高次のホップではないかもしれないので、これはマルチアクセスリンクを介して戻って再指向されるメッセージに参加することがあります。この場合、再指向は、メッセージがそれによってループシナリオを防止する、最良の次ホップへのDRによってリンクを介してユニキャストであるジョイン。この再方向は今までのメッセージを参加に適用されます。これが頻繁に発生したJoinメッセージのための次善のであるが、マルチキャストデータは、（いずれかのネイティブ、またはカプセル化された）複数回リンクを横断することはありません。"
    },
    {
      "indent": 3,
      "text": "In all but the exception case described above, all CBT control messages are multicast over multicast supporting links to the \"all-cbt-routers\" group, with IP TTL 1. When a CBT control message is sent over a non-multicast supporting link, it is explicitly addressed to the appropriate next hop.",
      "ja": "CBT制御メッセージを非マルチキャスト支持リンクを介して送信されると全てが、上記の例外の場合に、すべてのCBT制御メッセージは、IP TTL 1と「全CBT-ルータ」グループへのリンクをサポートするマルチキャスト介してマルチキャストされますそれが明示的に適切な次のホップにアドレス指定されています。"
    },
    {
      "indent": 0,
      "text": "4.2.1.  CBT Control Message Retransmission Strategy",
      "section_title": true,
      "ja": "4.2.1。 CBT制御メッセージの再送信戦略"
    },
    {
      "indent": 3,
      "text": "Certain CBT control messages illicit a response of some sort. Lack of response may be due to an upstream router crashing, or the loss of the original message, or its response. To detect these events, CBT retransmits those control messages for which it expects a response, if that response is not forthcoming within the retransmission-interval, which varies depending on the type of message involved. There is an upper bound (typically 3) on the number of retransmissions of the original message before an exception condition is raised.",
      "ja": "特定のCBT制御メッセージは、ある種の応答を誘発（illicit）。応答の欠如は、上流のルータのクラッシュ、または元のメッセージの喪失、またはその応答に起因し得ます。これらのイベントを検出するために、CBTは、その応答が関与するメッセージの種類に応じて異なり、再送間隔、内来るべきでない場合、それは、応答を期待しているため、これらの制御メッセージを再送します。例外条件が発生する前に、上限（通常は3）元のメッセージの再送回数にあります。"
    },
    {
      "indent": 3,
      "text": "For example, the exception procedure for lack of response to an ECHO_REQUEST is to send a QUIT_NOTIFICATION upstream and a FLUSH_TREE message downstream for the group. If this is router has group members attached, it restarts the joining process to the group's core.",
      "ja": "例えば、ECHO_REQUESTに対する応答の欠如の例外手順は、上流QUIT_NOTIFICATIONとグループに対する下流FLUSH_TREEメッセージを送信することです。これでルータがグループのメンバーが接続されている場合、それはグループのコアへの接合プロセスを再起動します。"
    },
    {
      "indent": 0,
      "text": "4.2.2.  Non-Member Sending",
      "section_title": true,
      "ja": "4.2.2。非加盟送信"
    },
    {
      "indent": 3,
      "text": "If a non-member sender's local router is already on-tree for the group being sent to, the subnet's upstream router simply forwards the data packet over all outgoing interfaces corresponding to that group's forwarding cache entry. This is in contrast to PIM-SM [18] which must encapsulate data from a non-member sender, irrespective of whether the local router has joined the tree. This is due to PIM's uni-directional state.",
      "ja": "非会員の送信者のローカルルータがに送信されるグループのためにツリーすでにある場合は、サブネットの上流のルータは単にそのグループの転送キャッシュエントリに対応するすべての発信インターフェイス上でデータパケットを転送します。これは、PIM-SMにかかわらずローカルルータがツリーに参加しているかどうか、非会員の送信者からのデータをカプセル化しなければならない[18]とは対照的です。これは、PIMの片方向の状態によるものです。"
    },
    {
      "indent": 3,
      "text": "If the sender's subnet is not attached to the group tree, the local DR must encapsulate the data packet and unicast it to the group's core router, where it is decapsulated and disseminated over all tree interfaces, as specified by the core's forwarding cache entry for the group. The data packet encapsulation method is IP-in-IP [14].",
      "ja": "送信者のサブネットがグループツリーに接続されていない場合、ローカルDRは、データパケットをカプセル化しなければならないとするコアの転送キャッシュ・エントリによって指定されるように、それはデカプセル化し、すべてのツリーインターフェイス上で播種されたグループのコアルーター、それをユニキャストグループ。データ・パケットのカプセル化法は、IPインIP [14]です。"
    },
    {
      "indent": 3,
      "text": "Routers in between a non-member sender and the group's core need not know anything about the multicast group, and indeed may even be multicast-unaware. This makes CBT particulary attractive for applications with non-member senders.",
      "ja": "非会員の送信者とグループのコア間でのルータは、マルチキャストグループについて何を知っている必要はなく、実際にはさらにマルチキャスト認識しないことがあります。これは、非メンバーの送信者とアプリケーションのためのCBTのparticularyが魅力。"
    },
    {
      "indent": 0,
      "text": "5.  Interoperability with Other Multicast Routing Protocols",
      "section_title": true,
      "ja": "他のマルチキャストルーティングプロトコルとの相互運用性5。"
    },
    {
      "indent": 3,
      "text": "See \"interoperability\" in section 4.1.",
      "ja": "4.1節では、「相互運用性」を参照してください。"
    },
    {
      "indent": 3,
      "text": "The interoperability mechanisms for interfacing CBT with DVMRP are defined in [15].",
      "ja": "DVMRPとCBTをインタフェースするための相互運用性のメカニズムが[15]で定義されています。"
    },
    {
      "indent": 0,
      "text": "6.  Core Router Discovery",
      "section_title": true,
      "ja": "6.コアルーター検出"
    },
    {
      "indent": 3,
      "text": "Core router discovery is by far the most controversial and difficult aspect of shared tree multicast architectures, particularly in the context of inter-domain multicast routing (IDMR).  There have been many proposals over the past three years or so, including advertising core addresses in a multicast session directory like \"sdr\" [11], manual placement, and the HPIM [12] approach of strictly dividing up",
      "ja": "コアルータの発見は、特にドメイン間マルチキャストルーティング（IDMR）の文脈では、共有ツリーマルチキャストアーキテクチャのこれまでで最も物議を醸すと困難な側面です。 「SDR」[11]、手動で配置し、厳密に分割するのHPIM [12]のアプローチのようなマルチキャストセッションディレクトリ内の広告コアアドレスなど、過去3年ほどかけて多くの提案がなされています"
    },
    {
      "indent": 3,
      "text": "the multicast address space into many \"hierarchical scopes\" and using explicit advertising of core routers between scope levels.",
      "ja": "多くの「階層スコープ」とスコープレベル間のコアルータの明示的な広告を使用してへのマルチキャストアドレス空間。"
    },
    {
      "indent": 3,
      "text": "There are currently two options for CBTv2 [1] core discovery; the \"bootstrap\" mechamism, and manual placement. The bootstrap mechanisms (as currently specified with the PIM sparse mode protocol [18]) is applicable only to intra-domain core discovery, and allows for a \"plug & play\" type operation with minimal configuration. The disadvantage of the bootstrap mechanism is that it is much more difficult to affect the shape, and thus optimality, of the resulting distribution tree. Also, it must be implemented by all CBT routers within a domain.",
      "ja": "CBTv2 [1]コア発見のための2つのオプションが現在ありません。 「ブートストラップ」mechamism、および手動配置。ブートストラップ機構（現在PIMスパースモードプロトコルで指定されているように[18]）のみイントラドメインコア発見に適用可能であり、最小構成の「プラグアンドプレイ」タイプの操作を可能にします。ブートストラップ機構の欠点は、形状に影響を与えることがはるかに困難であることであり、したがって、得られた配信ツリーの最適。また、ドメイン内のすべてのCBTルータで実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Manual configuration of leaf routers with <core, group> mappings is the other option (note: leaf routers only); this imposes a degree of administrative burden - the mapping for a particular group must be coordinated across all leaf routers to ensure consistency. Hence, this method does not scale particularly well. However, it is likely that \"better\" trees will result from this method, and it is also the only available option for inter-domain core discovery currently available.",
      "ja": "<コア、グループ>マッピングでリーフルータの手動設定は、他のオプションです（注：リーフルータのみ）。これは、管理負担の度合いを課し - 特定のグループのためのマッピングは、一貫性を確保するため、すべてのリーフルータ間で調整する必要があります。従って、この方法は、特に良好にスケールしません。しかし、「より良い」の木は、この方法に起因する可能性がある、そしてそれはまた、現在利用可能なドメイン間のコアの発見のためにのみ利用可能なオプションです。"
    },
    {
      "indent": 0,
      "text": "6.1.  Bootstrap Mechanism Overview",
      "section_title": true,
      "ja": "6.1。ブートストラップメカニズムの概要"
    },
    {
      "indent": 3,
      "text": "It is unlikely at this stage that the bootstrap mechanism will be appended to a well-known network layer protocol, such as IGMP [5] or ICMP [13], though this would facilitate its ubiquitous (intra-domain) deployment.  Therefore, each multicast routing protocol requiring the bootstrap mechanism must implement it as part of the multicast routing protocol itself.",
      "ja": "ブートストラップ機構は、IGMPのような周知のネットワーク層プロトコルに付加されることを、この段階ではそうである[5]またはICMP [13]、これはそのユビキタス（イントラドメイン）の展開を容易にするであろうけれども。したがって、ブートストラップ機構を必要とする各マルチキャストルーティングプロトコルは、マルチキャストルーティングプロトコル自体の一部として実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A summary of the operation of the bootstrap mechanism follows. It is assumed that all routers within the domain implement the \"bootstrap\" protocol, or at least forward bootstrap protocol messages.",
      "ja": "ブートストラップ機構の動作の概要は次の通りです。ドメイン内のすべてのルータが「ブートストラップ」プロトコル、または少なくとも前方のブートストラッププロトコルメッセージを実装することを想定しています。"
    },
    {
      "indent": 3,
      "text": "A subset of the domain's routers are configured to be CBT candidate core routers. Each candidate core router periodically (default every 60 secs) advertises itself to the domain's Bootstrap Router (BSR), using  \"Core Advertisement\" messages.  The BSR is itself elected dynamically from all (or participating) routers in the domain.  The domain's elected BSR collects \"Core Advertisement\" messages from candidate core routers and periodically advertises a candidate core set (CC-set) to each other router in the domain, using traditional hopby-hop unicast forwarding. The BSR uses \"Bootstrap Messages\" to advertise the CC-set. Together, \"Core Advertisements\" and \"Bootstrap Messages\" comprise the \"bootstrap\" protocol.",
      "ja": "ドメインのルータのサブセットは、CBT候補コアルータになるように構成されています。定期的に各候補のコアルータは、（すべての60秒デフォルト）「コア広告」メッセージを使用して、ドメインのブートストラップルータ（BSR）に自分自身をアドバタイズします。 BSRは、それ自体は、ドメイン内のすべての（または参加する）のルータから動的に選出されます。ドメインの選出されたBSRは、候補コアルータから「コア広告」のメッセージを収集し、定期的に伝統的なhopbyホップユニキャスト転送を使用して、ドメイン内の各他のルータへの候補コアセット（CC-セット）をアドバタイズします。 BSRは、CC-セットを宣伝するために、「ブートストラップメッセージ」を使用しています。一緒に、「コア広告」と「ブートストラップメッセージ」「ブートストラップ」プロトコルを含みます。"
    },
    {
      "indent": 3,
      "text": "When a router receives an IGMP host membership report from one of its directly attached hosts, the local router uses a hash function on the reported group address, the result of which is used as an index into the CC-set. This is how local routers discover which core to use for a particular group.",
      "ja": "ルータが直接接続されたホストのいずれかからIGMPホストメンバシップレポートを受信した場合、ローカルルータは、報告されたグループアドレス、CC-セットへのインデックスとして使用された結果にハッシュ関数を使用します。これは、ローカルルータが特定のグループに使用するコアを発見する方法です。"
    },
    {
      "indent": 3,
      "text": "Note the hash function is specifically tailored such that a small number of consecutive groups always hash to the same core. Furthermore, bootstrap messages can carry a \"group mask\", potentially limiting a CC-set to a particular range of groups. This can help reduce traffic concentration at the core.",
      "ja": "ハッシュ関数は、具体的に連続したグループの数が少ない常に同じコアにハッシュするように調整されます。また、ブートストラップメッセージは、潜在的にグループの特定の範囲にCC-セットを制限する、「グループ・マスク」を運ぶことができます。これは、コアでトラフィックの集中を軽減することができます。"
    },
    {
      "indent": 3,
      "text": "If a BSR detects a particular core as being unreachable (it has not announced its availability within some period), it deletes the relevant core from the CC-set sent in its next bootstrap message. This is how a local router discovers a group's core is unreachable; the router must re-hash for each affected group and join the new core after removing the old state. The removal of the \"old\" state follows the sending of a QUIT_NOTIFICATION upstream, and a FLUSH_TREE message downstream.",
      "ja": "BSRは、（それがある期間内にその利用可能性を発表していない）到達不能であると特定のコアを検出した場合、その次のブートストラップメッセージで送信されたCC-セットから関連するコアを削除します。これは、ローカルルータがグループのコアが到達不能である発見する方法です。ルータは、影響を受ける各グループのためのハッシュを再古い状態を削除した後に新しいコアに参加する必要があります。 「古い」状態の除去は、下流、上流QUIT_NOTIFICATION、およびFLUSH_TREEメッセージの送信に続きます。"
    },
    {
      "indent": 0,
      "text": "7.  Summary",
      "section_title": true,
      "ja": "7.まとめ"
    },
    {
      "indent": 3,
      "text": "This document presents an architecture for intra- and inter-domain multicast routing.  We motivated this architecture by describing how an inter-domain multicast routing algorithm must scale to large numbers of groups present in the internetwork, and discussed why most other existing algorithms are less suited to inter-domain multicast routing.  We followed by describing the features and components of the architecture, illustrating its simplicity and scalability.",
      "ja": "この文書では、分子内およびドメイン間マルチキャストルーティングのためのアーキテクチャを提示します。我々は、ドメイン間マルチキャストルーティングアルゴリズムは、インターネットに存在するグループの多数に拡大しなければならないどのように記述することによって、このアーキテクチャを動機付け、および他のほとんどの既存のアルゴリズムは、ドメイン間マルチキャストルーティングにはあまり適してい理由について議論しました。我々は、その単純さとスケーラビリティを示し、アーキテクチャの機能およびコンポーネントを記述が続きます。"
    },
    {
      "indent": 0,
      "text": "8.  Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Security considerations are not addressed in this memo.",
      "ja": "セキュリティの考慮事項は、このメモで扱われません。"
    },
    {
      "indent": 3,
      "text": "Whilst multicast security is a topic of ongoing research, multicast applications (users) nevertheless have the ability to take advantage of security services such as encryption or/and authentication provided such services are supported by the applications.",
      "ja": "マルチキャストセキュリティが進行中の研究のテーマであるが、マルチキャストアプリケーション（ユーザーが）それにもかかわらず、このようなサービスは、アプリケーションでサポートされて提供されるこのような暗号化または/および認証などのセキュリティサービスを利用する能力を持っています。"
    },
    {
      "indent": 3,
      "text": "RFCs 1949 and 2093/2094 discuss different ways of distributing multicast key material, which can result in the provision of network layer access control to a multicast distribution tree.",
      "ja": "RFCの1949年と2094分の2093マルチキャスト配信ツリーへのネットワーク層のアクセス制御の提供につながることができマルチキャスト鍵材料を配布するさまざまな方法を、議論します。"
    },
    {
      "indent": 3,
      "text": "[19] offers a synopsis of multicast security threats and proposes some possible counter measures.",
      "ja": "[19]マルチキャストセキュリティの脅威の概要を提供しており、いくつかの可能な対策を提案しています。"
    },
    {
      "indent": 3,
      "text": "Beyond these, little published work exists on the topic of multicast security.",
      "ja": "これら以外にも、少し公表された研究は、マルチキャスト、セキュリティの話題に存在します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Special thanks goes to Paul Francis, NTT Japan, for the original brainstorming sessions that brought about this work.",
      "ja": "特別な感謝は、この作品をもたらした元ブレーンストーミングセッションのために、ポール・フランシス、NTT日本に行きます。"
    },
    {
      "indent": 3,
      "text": "Clay Shields' work on OCBT [17] identified various failure scenarios with a multi-core architecture, resulting in the specification of a single core architecture.",
      "ja": "OCBT [17]に粘土シールズの作業は、単一のコアアーキテクチャの仕様で得られ、マルチコアアーキテクチャと様々な障害シナリオを同定しました。"
    },
    {
      "indent": 3,
      "text": "Others that have contributed to the progress of CBT include Ken Carlberg, Eric Crawley, Jon Crowcroft, Mark Handley, Ahmed Helmy, Nitin Jain, Alan O'Neill, Steven Ostrowsksi, Radia Perlman, Scott Reeve, Benny Rodrig, Martin Tatham, Dave Thaler, Sue Thompson, Paul White, and other participants of the IETF IDMR working group.",
      "ja": "CBTの進歩に貢献した他は、ケン・カールバーグ氏、エリック・クローリー、ジョンクロウクロフト、マーク・ハンドリー、アーメド・ヘルミー、ニティン・ジェイン、アラン・オニール、スティーブンOstrowsksi、ラディア・パールマン、スコット・リーブ、ベニーRodrig、マーチンTatham氏、デーブターラーが含まれます、スー・トンプソン、ポール・ホワイト、そしてIETF IDMRワーキンググループの他の参加者。"
    },
    {
      "indent": 3,
      "text": "Thanks also to 3Com Corporation and British Telecom Plc for funding this work.",
      "ja": "この作業に資金を提供するためにも、3Com社（株）とブリティッシュテレコムピーエルシーに感謝します。"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "リファレンス"
    },
    {
      "indent": 3,
      "text": "[1] Ballardie, A., \"Core Based Trees (CBT version 2) Multicast Routing: Protocol Specification\", RFC 2189, September 1997.",
      "ja": "[1] Ballardie、A.、 \"コアベースツリー（CBTバージョン2）マルチキャストルーティング：プロトコル仕様\"、RFC 2189、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[2] Multicast Routing in a Datagram Internetwork; S. Deering, PhD Thesis, 1991; ftp://gregorio.stanford.edu/vmtp/sd-thesis.ps.",
      "ja": "[2]データグラムインターネットワークにおけるマルチキャストルーティング。 S.デアリング、博士論文、1991; ftp://gregorio.stanford.edu/vmtp/sd-thesis.ps。"
    },
    {
      "indent": 3,
      "text": "[3] Mechanisms for Broadcast and Selective Broadcast; D. Wall; PhD thesis, Stanford University, June 1980. Technical Report #90.",
      "ja": "[3]ブロードキャスト及び選択的ブロードキャストするためのメカニズム。 D.ウォール;博士論文、スタンフォード大学、6月1980テクニカルレポート＃90。"
    },
    {
      "indent": 3,
      "text": "[4] Reynolds, J., and J. Postel, \"Assigned Numbers\", STD 2, RFC 1700, October 1994.",
      "ja": "[4]レイノルズ、J.、およびJ.ポステル、 \"割り当て番号\"、STD 2、RFC 1700、1994年10月。"
    },
    {
      "indent": 3,
      "text": "[5] Internet Group Management Protocol, version 2 (IGMPv2); W. Fenner; Work In Progress.",
      "ja": "[5]インターネットグループ管理プロトコル、バージョン2（IGMPv2の）; W.フェナー;進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[6] Distance Vector Multicast Routing Protocol (DVMRP); T. Pusateri; Work In Progress.",
      "ja": "[6]距離ベクトルマルチキャストルーティングプロトコル（DVMRP）。 T. Pusateri;進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[7] Protocol Independent Multicast (PIM) Dense Mode Specification; D. Estrin et al; ftp://netweb.usc.edu/pim, Work In Progress.",
      "ja": "[7]プロトコル独立マルチキャスト（PIM）稠密モード指定。 D. Estrinら。 ftp://netweb.usc.edu/pim、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[8] Moy, J., \"Multicast Extensions to OSPF\", RFC 1584, March 1994.",
      "ja": "[8]モイ、J.、 \"OSPFへのマルチキャスト拡張機能\"、RFC 1584、1994年3月。"
    },
    {
      "indent": 3,
      "text": "[9] Reverse path forwarding of  broadcast packets; Y.K. Dalal and R.M.  Metcalfe; Communications of the ACM, 21(12):1040--1048, 1978.",
      "ja": "ブロードキャストパケットの[9]逆方向パス転送。 Y.K. DalalとR.M.メトカーフ; 1040--1048、1978：ACM、21（12）の通信。"
    },
    {
      "indent": 3,
      "text": "[10] Some Issues for an Inter-Domain Multicast Routing Protocol; D. Meyer;  Work In Progress.",
      "ja": "[10]ドメイン間マルチキャストルーティングプロトコルのためのいくつかの問題。 D.マイヤー;進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[11] SDP: Session Description Protocol; M. Handley and V. Jacobson; Work In Progress.",
      "ja": "[11] SDP：セッション記述プロトコル。 M.ハンドレー及びV.ヤコブソン。進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[12] Hierarchical Protocol Independent Multicast; M. Handley, J. Crowcroft, I. Wakeman.  Available from: http://www.cs.ucl.ac.uk/staff/M.Handley/hpim.ps  and ftp://cs.ucl.ac.uk/darpa/IDMR/hpim.ps   Work done 1995.",
      "ja": "[12]階層プロトコル独立マルチキャスト。 M.ハンドレー、J.クロウクロフト、I.ウェイクマン。 http://www.cs.ucl.ac.uk/staff/M.Handley/hpim.psと1995年に行わftp://cs.ucl.ac.uk/darpa/IDMR/hpim.ps仕事：から入手可能。"
    },
    {
      "indent": 3,
      "text": "[13] Postel, J., \"Internet Control Message Protocol (ICMP)\", STD 5, RFC 792, September 1981.",
      "ja": "[13]ポステル、J.、 \"インターネット制御メッセージプロトコル（ICMP）\"、STD 5、RFC 792、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[14] Perkins, C., \"IP Encapsulation within IP\", RFC 2003, October 1996.",
      "ja": "[14]パーキンス、C.、 \"IP内IPカプセル化\"、RFC 2003、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[15] CBT - Dense Mode Multicast Interoperability; A. Ballardie; Work In Progress.",
      "ja": "[15] CBT  - 稠密モードマルチキャスト相互運用。 A. Ballardie;進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[16] Performance and Resource Cost Comparisons of Multicast Routing Algorithms for Distributed Interactive Simulation Applications; T. Billhartz, J. Bibb Cain, E.  Farrey-Goudreau, and D. Feig. Available from: http://www.epm.ornl.gov/~sgb/pubs.html; July 1995.",
      "ja": "[16]分散型インタラクティブシミュレーションアプリケーションのためのマルチキャストルーティングアルゴリズムのパフォーマンスとリソースのコスト比較。 T. Billhartz、J.ビブカイン、E. Farrey-Goudreau、およびD. Feig。以下からの利用：http://www.epm.ornl.gov/~sgb/pubs.html。 1995年7月。"
    },
    {
      "indent": 3,
      "text": "[17] The Ordered Core Based Tree Protocol; C. Shields and J.J. Garcia- Luna-Aceves; In Proceedings of IEEE Infocom'97, Kobe, Japan, April 1997; http://www.cse.ucsc.edu/research/ccrg/publications/info-comm97ocbt.ps.gz",
      "ja": "[17]順序付きコアベースツリープロトコル。 C.シールズとJ.J. Garcia-ルナ-ACEVES。 IEEE Infocom'97、神戸、日本、1997年4月の議事録。 http://www.cse.ucsc.edu/research/ccrg/publications/info-comm97ocbt.ps.gz"
    },
    {
      "indent": 3,
      "text": "[18] Estrin, D., et. al., \"Protocol Independent Multicast-Sparse Mode (PIM-SM): Protocol Specification\", RFC 2117, June 1997.",
      "ja": "[18] Estrin、D.、ら。ら、 \"プロトコル独立マルチキャスト - スパースモード（PIM-SM）：プロトコル仕様\"。、RFC 2117、1997年6月。"
    },
    {
      "indent": 3,
      "text": "[19] Multicast-Specific Security Threats and Counter-Measures; A. Ballardie and J. Crowcroft; In Proceedings \"Symposium on Network and Distributed System Security\", February 1995, pp.2-16.",
      "ja": "[19]マルチキャスト固有のセキュリティの脅威と対策。 A. BallardieおよびJ.クロウクロフト。議事録には「ネットワーク上のシンポジウムと分散システムセキュリティ」、1995年2月、pp.2-16。"
    },
    {
      "indent": 0,
      "text": "Author Information",
      "ja": "著者の情報"
    },
    {
      "indent": 3,
      "text": "Tony Ballardie, Research Consultant",
      "ja": "トニーBallardie、リサーチ・コンサルタント"
    },
    {
      "indent": 3,
      "text": "EMail: ABallardie@acm.org",
      "ja": "メールアドレス：ABallardie@acm.org"
    }
  ]
}