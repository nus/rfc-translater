{
  "title": {
    "text": "RFC 2334 - Server Cache Synchronization Protocol (SCSP)",
    "ja": "RFC 2334 - サーバキャッシュ同期プロトコル（SCSP）"
  },
  "number": 2334,
  "created_at": "2019-10-23 10:03:38.810609+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         J. Luciani\nRequest for Comments: 2334                                  Bay Networks\nCategory: Standards Track                                    G. Armitage\n                                                                Bellcore\n                                                              J. Halpern\n                                                               Newbridge\n                                                            N. Doraswamy\n                                                            Bay Networks\n                                                              April 1998",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Server Cache Synchronization Protocol (SCSP)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes the Server Cache Synchronization Protocol (SCSP) and is written in terms of SCSP's use within Non Broadcast Multiple Access (NBMA) networks; although, a somewhat straight forward usage is applicable to BMA networks. SCSP attempts to solve the generalized cache synchronization/cache-replication problem for distributed protocol entities. However, in this document, SCSP is couched in terms of the client/server paradigm in which distributed server entities, which are bound to a Server Group (SG) through some means, wish to synchronize the contents (or a portion thereof) of their caches which contain information about the state of clients being served.",
      "ja": "この文書では、サーバキャッシュ同期プロトコル（SCSP）を説明し、非ブロードキャストマルチアクセス（NBMA）ネットワーク内のSCSPの使用の観点で書かれています。なお、幾分単純使用は、BMAのネットワークにも適用可能です。 SCSPは、分散プロトコルエンティティのための一般的なキャッシュの同期化/キャッシュ・レプリケーションの問題を解決しようとします。しかし、この文書では、SCSPは、いくつかの手段を介してサーバー・グループ（SG）にバインドされているサーバーの実体を、分散したクライアント/サーバパラダイムの観点で表現され、内容（またはその一部）を同期したい自分のクライアントの状態に関する情報が含まれているキャッシュが提供されています。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this document, are to be interpreted as described in [10].",
      "ja": "彼らは、この文書に表示される[10]で説明したように解釈される際のキーワードは、REQUIREDは、、、、、MAY、推奨、およびオプションのすべきでないないものとものとしてはなりませんしなければなりません。"
    },
    {
      "indent": 3,
      "text": "It is perhaps an obvious goal for any protocol to not limit itself to a single point of failure such as having a single server in a client/server paradigm. Even when there are redundant servers, there still remains the problem of cache synchronization; i.e., when one server becomes aware of a change in state of cache information then that server must propagate the knowledge of the change in state to all servers which are actively mirroring that state information. Further, this must be done in a timely fashion without putting undue resource strains on the servers. Assuming that the state information kept in the server cache is the state of clients of the server, then in order to minimize the burden placed upon the client it is also highly desirable that clients need not have complete knowledge of all servers which they may use. However, any mechanism for synchronization should not preclude a client from having access to several (or all) servers. Of course, any solution must be reasonably scalable, capable of using some auto-configuration service, and lend itself to a wide range of authentication methodologies.",
      "ja": "それはおそらく、このようなクライアント/サーバパラダイムで単一のサーバーを持つように単一障害点に自分自身を制限しないために、任意のプロトコルのための明確な目標です。冗長サーバが存在する場合であっても、まだキャッシュ同期の問題が残されています。 1台のサーバがキャッシュ情報の状態の変化に気付いたとき、すなわち、そのサーバは、積極的にその状態情報をミラーリングしているすべてのサーバに状態の変化についての知識を伝播しなければなりません。さらに、これはサーバー上の過度の資源株をかけることなく、タイムリーに行われなければなりません。サーバーのキャッシュに保存状態情報は、サーバのクライアントの状態であると仮定すると、クライアント上に置か負担を最小限に抑えるためには、クライアントは、彼らが使用することができ、すべてのサーバーの完全な知識を持っていない必要があることも非常に望ましいです。しかし、同期のための任意のメカニズムは、いくつかの（またはすべて）のサーバーへのアクセス権を持っていることから、クライアントを排除すべきではありません。もちろん、任意の解決策は、いくつかの自動構成サービスを使用することのできる合理的にスケーラブルで、認証方法の広い範囲に自分自身を貸す必要があります。"
    },
    {
      "indent": 3,
      "text": "This document describes the Server Cache Synchronization Protocol (SCSP). SCSP solves the generalized server synchronization/cache-replication problem while addressing the issues described above. SCSP synchronizes caches (or a portion of the caches) of a set of server entities of a particular protocol which are bound to a Server Group (SG) through some means (e.g., all NHRP servers belonging to a Logical IP Subnet (LIS)[1]). The client/server protocol which a particular server uses is identified by a Protocol ID (PID). SGs are identified by an ID which, not surprisingly, is called a SGID. Note, therefore, that the combination PID/SGID identifies both the client/server protocol for which the servers of the SG are being synchronized as well as the instance of that protocol. This implies that multiple instances of the same protocol may be in operation at the same time and have their servers synchronized independently of each other. An example of types of information that must be synchronized can be seen in NHRP[2] using IP where the information includes the registered clients' IP to NBMA mappings in the SG LIS.",
      "ja": "この文書では、サーバキャッシュ同期プロトコル（SCSP）について説明します。上記の課題に対応しつつSCSPは、一般的なサーバーの同期/キャッシュ・レプリケーションの問題を解決します。 SCSPは[何らかの手段を通じてサーバーグループ（SG）にバインドされている特定のプロトコルの論理IPサブネットに属している（例えば、すべてのNHRPサーバ（LIS）のサーバエンティティのセットのキャッシュ（または、キャッシュの一部）を同期させます1]）。特定のサーバが使用するクライアント/サーバプロトコルは、プロトコルID（PID）によって識別されます。 SGSが、驚くことではないが、SGIDと呼ばれるIDで識別されます。組み合わせPID / SGIDは、SGのサーバがそのプロトコルのインスタンスと同様に同期されているクライアント/サーバプロトコルの両方を識別すること、したがって、注意してください。これは、同じプロトコルの複数のインスタンスを同時に操作であってもよく、それらのサーバは互いに独立して同期していることを意味します。同期されなければならない情報のタイプの例は、情報は、SG LISにおけるNBMAマッピングに登録され、クライアントのIPアドレスを含むIPを使用してNHRP [2]に見ることができます。"
    },
    {
      "indent": 3,
      "text": "The simplest way to understand SCSP is to understand that the algorithm used here is quite similar to that used in OSPF[3]. In fact, if the reader wishes to understand more details of the tradeoffs and reliability aspects of SCSP, they should refer to the Hello, Database Synchronization, and Flooding Procedures in OSPF [3].",
      "ja": "SCSPを理解する最も簡単な方法は、ここで使用されるアルゴリズムは、OSPF [3]に使用されるものと非常に似ていることを理解することです。読者はSCSPのトレードオフと信頼性の側面の詳細を理解したい場合は実際には、彼らはOSPFでのHello、データベース同期、およびフラッディング手順を参照する必要があります[3]。"
    },
    {
      "indent": 3,
      "text": "As described later, the protocol goes through three phases. The first, very brief phase is the hello phase where two devices determine that they can talk to each other. Following that is database synchronization. The operation of SCSP assumes that up to the point when new information is received, two entities have the same data available. The database synchronization phase ensures this.",
      "ja": "後述するように、プロトコルは、次の3つのフェーズを通過します。まず、非常に短い相は、2つのデバイスは、彼らがお互いに話すことができると判断したハロー相です。以下のことがデータベースの同期です。 SCSPの操作は、新たな情報が受信される時点まで、2つのエンティティが利用可能に同じデータを持っていることを前提としています。データベースの同期フェーズは、これを保証します。"
    },
    {
      "indent": 3,
      "text": "In database synchronization, the two neighbors exchange summary information about each entry in their database. Summaries are used since the database itself is potentially quite large. Based on these summaries, the neighbors can determine if there is information that each needs from the other. If so, that is requested and provided. Therefore, at the end of this phase of operation, the two neighbors have the same data in their databases.",
      "ja": "データベースの同期では、2人の隣人は、データベース内の各エントリについての概要情報を交換します。データベース自体が潜在的にかなり大きいので概要は使用されています。それぞれが他から必要な情報がある場合にこれらの要約に基づいて、隣人は決定することができます。もしそうなら、それは要求され、提供されます。そのため、操作のこの段階の終わりに、2人の隣人は彼らのデータベースに同じデータを持っています。"
    },
    {
      "indent": 3,
      "text": "After that, the entities enter and remain in flooding state. In flooding state, any new information that is learned is sent to all neighbors, except the one (if any) that the information was learned from. This causes all new information in the system to propagate to all nodes, thus restoring the state that everyone knows the same thing. Flooding is done reliably on each link, so no pattern of low rate packet loss will cause a disruption. (Obviously, a sufficiently high rate of packet loss will cause the entire neighbor relationship to come down, but if the link does not work, then that is what one wants.)",
      "ja": "その後、エンティティが入り、洪水状態のままとなります。フラッディング状態では、学習した新しい情報は、情報がから学習されたことを1（もしあれば）を除いて、すべてのネイバーに送信されます。これにより、誰もが同じことを知っている状態を回復、すべてのノードに伝搬するために、システム内のすべての新しい情報が発生します。洪水は、各リンク上で確実に行われているので、低レートのパケットロスのないパターンは、混乱を引き起こすことはないでしょう。 （もちろん、パケット損失の十分に高い割合は、全体のネイバー関係が降りてくることになりますが、リンクが機能しない場合は、その一つが望んでいるものです。）"
    },
    {
      "indent": 3,
      "text": "Because the database synchronization procedure is run whenever a link comes up, the system robustly ensures that all participating nodes have all available information. It properly recovers from partitions, and copes with other failures.",
      "ja": "リンクが起動したときに、データベースの同期手順が実行されるため、システムが確実にすべての参加ノードは、利用可能なすべての情報を持っていることを保証します。これは、適切にパーティションから回復、およびその他の障害に対処します。"
    },
    {
      "indent": 3,
      "text": "The SCSP specification is not useful as a stand alone protocol. It must be coupled with the use of an SCSP Protocol Specific specification which defines how a given protocol would make use of the synchronization primitives supplied by SCSP. Such specification will be done in separate documents; e.g., [8] [9].",
      "ja": "SCSPの仕様は、スタンドアローンプロトコルとして有用ではありません。これは、与えられたプロトコルは、SCSPにより供給される同期プリミティブを利用する方法を定義SCSPプロトコル固有仕様の使用と結合されなければなりません。このような仕様では、別の文書で行われます。例えば、[8] [9]。"
    },
    {
      "indent": 0,
      "text": "2. Overview",
      "section_title": true,
      "ja": "2.概要"
    },
    {
      "indent": 3,
      "text": "SCSP places no topological requirements upon the SG. Obviously, however, the resultant graph must span the set of servers to be synchronized. SCSP borrows its cache distribution mechanism from the link state protocols [3,4]. However, unlike those technologies, there is no mandatory Shortest Path First (SPF) calculation, and SCSP imposes no additional memory requirements above and beyond that which is required to save the cached information which would exist regardless of the synchronization technology.",
      "ja": "SCSPはSGには何トポロジカルな要件を課すません。明らかに、しかし、結果のグラフは、同期するサーバーのセットにまたがる必要があります。 SCSPは、リンクステートプロトコル[3,4]からそのキャッシュ分配機構を借用します。しかし、これらの技術とは異なり、そこには必須最短パス優先（SPF）計算がされていない、とSCSPは、上記にかかわらず、同期技術​​の存在することになるキャッシュされた情報を保存するために必要とされるもの以外の追加メモリ要件を課していません。"
    },
    {
      "indent": 3,
      "text": "In order to give a frame of reference for the following discussion, the terms Local Server (LS), Directly Connected Server (DCS), and Remote Server (RS) are introduced. The LS is the server under scrutiny; i.e., all statements are made from the perspective of the LS when discussing the SCSP protocol. The DCS is a server which is directly connected to the LS; e.g., there exists a VC between the LS and DCS. Thus, every server is a DCS from the point of view of every other server which connects to it directly, and every server is an LS which has zero or more DCSs directly connected to it. From the perspective of an LS, an RS is a server, separate from the LS, which is not directly connected to the LS (i.e., an RS is always two or more hops away from an LS whereas a DCS is always one hop away from an LS).",
      "ja": "以下の議論のための参照のフレームを与えるために、用語ローカルサーバ（LS）、直接接続サーバー（DCS）、およびリモートサーバ（RS）が導入されています。 LSは精査の下でサーバです。 SCSPプロトコルを議論する場合、すなわち、すべての文は、LSの観点から作られています。 DCSは直接LSに接続されたサーバです。例えば、LSとDCSの間のVCが存在します。したがって、すべてのサーバが直接に接続する他のすべてのサーバの観点からはDCSであり、すべてのサーバが直接に接続されたゼロ個以上のDCSを有するLSです。 LSの観点から、RSがサーバであるDCSは、1つのホップから常にあるのに対し、直接LS（すなわち、RSと接続されていないLSから別離れLSから常に2つの以上のホップでありますLS）。"
    },
    {
      "indent": 3,
      "text": "SCSP contains three sub protocols: the \"Hello\" protocol, the \"Cache Alignment\" protocol, and the \"Cache State Update\" protocol. The \"Hello\" protocol is used to ascertain whether a DCS is operational and whether the connection between the LS and DCS is bidirectional, unidirectional, or non-functional. The \"Cache Alignment\" (CA) protocol allows an LS to synchronize its entire cache with that of the cache of its DCSs. The \"Cache State Update\" (CSU) protocol is used to update the state of cache entries in servers for a given SG. Sections 2.1, 2.2, and 2.3 contain a more in-depth explanation of the Hello, CA, and CSU protocols and the messages they use.",
      "ja": "「こんにちは」プロトコル、「キャッシュアラインメント」プロトコル、および「キャッシュ状態更新」プロトコル：SCSPは三つのサブプロトコルが含まれています。 「こんにちは」プロトコルは、DCSが動作しているか否かを確認するために使用され、LSとDCSとの間の接続は、双方向一方向、又は非機能的であるかどうか。 「キャッシュアラインメント」（CA）プロトコルは、LSはそののDCSのキャッシュのことで、そのキャッシュ全体を同期させることができます。 「キャッシュ状態更新」（CSU）プロトコルは、与えられたSGのためのサーバにキャッシュエントリの状態を更新するために使用されます。セクション2.1、2.2、および2.3こんにちは、CA、およびCSUプロトコルと、彼らが使用するメッセージのより詳細な説明が含まれています。"
    },
    {
      "indent": 3,
      "text": "SCSP based synchronization is performed on a per protocol instance basis. That is, a separate instance of SCSP is run for each instance of the given protocol running in a given box. The protocol is identified in SCSP via a Protocol ID and the instance of the protocol is identified by a Server Group ID (SGID). Thus the PID/SGID pair uniquely identify an instance of SCSP. In general, this is not an issue since it is seldom the case that many instances of a given protocol (which is distributed and needs cache synchronization) are running within the same physical box. However, when this is the case, there is a mechanism called the Family ID (described briefly in the Hello Protocol) which enables a substantial reduction in maintenance traffic at little real cost in terms of control. The use of the Family ID mechanism, when appropriate for a given protocol which is using SCSP, will be fully defined in the given SCSP protocol specific specification.",
      "ja": "SCSPベースの同期は、プロトコルインスタンスごとに基づいて行われます。つまり、SCSPの別のインスタンスは、所与のボックスで実行されている特定のプロトコルのインスタンスごとに実行されます。プロトコルは、プロトコルIDを介しSCSPに識別され、プロトコルのインスタンスがサーバーグループID（SGID）によって識別されます。したがってPID / SGIDペアが一意にSCSPのインスタンスを識別する。それはめったに（分散キャッシュの同期を必要とされる）特定のプロトコルの多くのインスタンスが同じ物理ボックス内で実行されている場合ではないので、一般的に、これは問題ではありません。しかし、これが事実であるとき、メカニズムはファミリーIDが呼ばれるコントロールの面で少し実際のコストで保守トラフィックを大幅に削減を可能にする（Helloプロトコルで簡単に説明）。ファミリーIDメカニズムの使用、SCSPを使用している特定のプロトコルのために適切な、完全所与SCSPプロトコル固有の仕様で定義されます。"
    },
    {
      "indent": 12,
      "text": "           +---------------+\n           |               |\n  +------->|     DOWN      |<-------+\n  |        |               |        |\n  |        +---------------+        |\n  |            |       ^            |\n  |            |       |            |\n  |            |       |            |\n  |            |       |            |\n  |            @       |            |\n  |        +---------------+        |\n  |        |               |        |\n  |        |    WAITING    |        |\n  |     +--|               |--+     |\n  |     |  +---------------+  |     |\n  |     |    ^           ^    |     |\n  |     |    |           |    |     |\n  |     @    |           |    @     |\n+---------------+     +---------------+\n| BIDIRECTIONAL |---->| UNIDIRECTIONAL|\n|               |     |               |\n|  CONNECTION   |<----|  CONNECTION   |\n+---------------+     +---------------+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 1: Hello Finite State Machine (HFSM)",
      "ja": "図1：こんにちは、有限状態機械（HFSM）"
    },
    {
      "indent": 0,
      "text": "2.1 Hello Protocol",
      "section_title": true,
      "ja": "2.1 Helloプロトコル"
    },
    {
      "indent": 3,
      "text": "\"Hello\" messages are used to ascertain whether a DCS is operational and whether the connections between the LS and DCS are bidirectional, unidirectional, or non-functional. In order to do this, every LS MUST periodically send a Hello message to its DCSs.",
      "ja": "「Hello」メッセージは、DCSが動作しているかどうか、およびLSとDCSとの間の接続は、双方向単方向、または非機能的であるかどうかを確認するために使用されています。これを行うためには、すべてのLSは、定期的にそののDCSにHelloメッセージを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "An LS must be configured with a list of NBMA addresses which represent the addresses of peer servers in a SG to which the LS wishes to have a direct connection for the purpose of running SCSP; that is, these addresses are the addresses of would-be DCSs. The mechanism for the configuration of an LS with these NBMA address is beyond the scope of this document; although one possible mechanism would be an autoconfiguration server.",
      "ja": "LSは、LSは、SCSPを実行する目的のための直接接続を有することを望むたSG内のピアサーバーのアドレスを表すNBMAアドレスのリストを設定する必要があります。つまり、これらのアドレスは-なりのDCSのアドレスです。これらNBMAアドレスを持つLSの構成のための機構は、この文書の範囲外です。一つの可能​​なメカニズムは、自動構成サーバになりますが。"
    },
    {
      "indent": 3,
      "text": "An LS has a Hello Finite State Machine (HFSM) associated with each of its DCSs (see Figure 1) for a given SG, and the HFSM monitors the state of the connectivity between the servers.",
      "ja": "LSは、与えられたSGのために（図1参照）、そののDCSのそれぞれに関連付けられたハロー有限状態機械（HFSM）を有し、HFSMは​​、サーバ間の接続の状態を監視します。"
    },
    {
      "indent": 3,
      "text": "The HFSM starts in the \"Down\" State and transitions to the \"Waiting\" State after NBMA level connectivity has been established. Once in the Waiting State, the LS starts sending Hello messages to the DCS. The Hello message includes: a Sender ID which is set to the LS's ID (LSID), zero or more Receiver IDs which identify the DCSs from which the LS has recently heard a Hello message (as described below), and a HelloInterval and DeadFactor which will be described below. At this point, the DCS may or may not already be sending its own Hello messages to the LS.",
      "ja": "HFSMは​​NBMAレベルの接続が確立された状態の後に「待機中」に「ダウン」状態と遷移で開始します。いったん待機状態では、LSがDCSへのHelloメッセージの送信を開始します。 Helloメッセージは、（後述のように）LSは最近、Helloメッセージを聞いたからのDCSを識別するLSのID（LSID）、ゼロまたはそれ以上の受信機IDに設定されている送信者ID、及びHelloIntervalのとDeadFactorれます以下に説明します。この時点で、DCSは、またはすでにLSに独自のHelloメッセージを送信してもしなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "When the LS receives a Hello message from one of its DCSs, the LS checks to see if its LSID is in one of the Receiver ID fields of that message which it just received, and the LS saves the Sender ID from that Hello message. If the LSID is in one of the Receiver ID fields then the LS transitions the HFSM to the Bidirectional Connection state otherwise it transitions the HFSM into the Unidirectional Connection state. The Sender ID which was saved is the DCS's ID (DCSID). At some point before the next time that the LS sends its own Hello message to the DCS, the LS will check the saved DCSID against a list of Receiver IDs which the LS uses when sending the LS's own Hello messages. If the DCSID is not found in the list of Receiver IDs then it is added to that list before the LS sends its Hello message.",
      "ja": "LSは、そのLSIDはそれだけで受信したメッセージの受信者ID分野の一つであるかどうかを確認するためにそののDCS、LSは、小切手のいずれかからHelloメッセージを受信し、LSは、そのHelloメッセージから送信者IDを保存します。 LSIDは、レシーバIDフィールドのいずれかである場合、LSは、双方向接続状態にHFSMは​​、それ以外の場合は、単方向接続状態にHFSMを移行移行します。保存された送信者IDは、DCSのID（DCSID）です。 LSがDCSに独自のHelloメッセージを送信することを次回までにいくつかの時点で、LSはLS自身のHelloメッセージを送信するときにLSが使用する受信機のIDのリストに対して保存されたDCSIDをチェックします。 DCSIDがReceiver IDのリストに見つからない場合LSがHelloメッセージを送信する前に、それがそのリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "Hello messages also contain a HelloInterval and a DeadFactor. The Hello interval advertises the time (in seconds) between sending of consecutive Hello messages by the server which is sending the \"current\" Hello message. That is, if the time between reception of Hello messages from a DCS exceeds the HelloInterval advertised by that DCS then the next Hello message is to be considered late by the LS. If the LS does not receive a Hello message, which contains the LS's LSID in one of the Receiver ID fields, within the interval HelloInterval*DeadFactor seconds (where DeadFactor was advertised by the DCS in a previous Hello message) then the LS MUST consider the DCS to be stalled. At which point one of two things will happen: 1) if any Hello messages have been received during the last HelloInterval*DeadFactor seconds then the LS should transition the HFSM for that DCS to the Unidirectional Connection State; otherwise, the LS should transition the HFSM for that DCS to the Waiting State and remove the DCSID from the Receiver ID list.",
      "ja": "こんにちは、メッセージもHelloIntervalのとDeadFactorが含まれています。こんにちは間隔は、「現在の」Helloメッセージを送信しているサーバーでの連続したHelloメッセージの送信間隔（秒単位）をアドバタイズします。 DCSからHelloメッセージの受信の間の時間が、そのDCS次Helloメッセージは、LSによって遅く考えられるべきであることにより、アドバタイズHelloIntervalが後援を超える場合には、です。 LSが間隔内にレシーバIDフィールドのいずれかにLSのLSIDが含まれているHelloメッセージを、受信しない場合はHelloIntervalの*（DeadFactorは、前のHelloメッセージにDCSによってアドバタイズされた）DeadFactor秒は、LSは考慮しなければなりませんDCSが停止されます。その時点で、2つのうちの1つが起こります：任意のHelloメッセージが最後HelloIntervalの* DeadFactor秒の間に受信されている場合1）その後、LSは、単方向接続状態へのDCSのためのHFSMを移行する必要があります。そうでない場合は、LSは待機状態にそのDCSのためのHFSMを移行し、レシーバーIDリストからDCSIDを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the Hello Protocol is on a per PID/SGID basis. Thus, for example, if there are two servers (one in SG A and the other in SG B) associated with an NBMA address X and another two servers (also one in SG A and the other in SG B) associated with NBMA address Y and there is a suitable point-to-point VC between the NBMA addresses then there are two HFSMs running on each side of the VC (one per PID/SGID).",
      "ja": "Helloプロトコルは、PID / SGIDごとにあることに注意してください。したがって、例えば、NBMAアドレスYに関連付けられたNBMAアドレスXと他の二つのサーバ（SG BのSG Aおよび他に、1）に関連付けられた2台のサーバ（SG BのSG Aにおける一方及び他方）が存在する場合そして、NBMAの間の適切なポイント・ツー・ポイントVCは、次にVC（PID / SGID 1つ）の各側に実行している2つのHFSMsがあるが対処されます。"
    },
    {
      "indent": 3,
      "text": "Hello messages contain a list of Receiver IDs instead of a single Receiver ID in order to make use of point to multipoint connections. While there is an HFSM per DCS, an LS MUST send only a single Hello message to its DCSs attached as leaves of a point to multipoint connection. The LS does this by including DCSIDs in the list of Receiver IDs when the LS's sends its next Hello message. Only the DCSIDs from non-stalled DCSs from which the LS has heard a Hello message are included.",
      "ja": "helloメッセージは、接続をポイントツーマルチポイントを利用するためには代わりに、単一の受信機IDのレシーバIDのリストが含まれています。 DCSあたりHFSMありますが、LSは、接続をポイントツーマルチポイントの葉として添付ののDCSへの唯一のHelloメッセージを送らなければなりません。 LSは、その次のHelloメッセージを送信するときのLSのレシーバーIDのリストでDCSIDsを含むことによってこれを行います。唯一のLSがHelloメッセージを聞いていたから、非失速のDCSからDCSIDsが含まれています。"
    },
    {
      "indent": 3,
      "text": "Any abnormal event, such as receiving a malformed SCSP message, causes the HFSM to transition to the Waiting State; however, a loss of NBMA connectivity causes the HFSM to transition to the Down State. Until the HFSM is in the Bidirectional Connection State, if any properly formed SCSP messages other than Hello messages are received then those messages MUST be ignored (this is for the case where, for example, there is a point to multipoint connection involved).",
      "ja": "このような不正なSCSPメッセージを受信するような異常なイベントは、待機状態に遷移するHFSMを引き起こします。しかし、NBMA接続の損失はHFSMがダウン状態に遷移させます。 HFSMは​​、双方向接続状態になるまで、Helloメッセージ以外の任意の適切に形成されSCSPメッセージが受信されたこれらのメッセージを無視する必要がある場合、（このことは、例えば、関係接続をポイントツーマルチポイントがある、場合です）。"
    },
    {
      "indent": 14,
      "text": "     +------------+\n     |            |\n+--->|    DOWN    |\n|    |            |\n|    +------------+\n|          |\n^          |\n|          @\n|    +------------+\n|    |Master/Slave|\n|-<--|            |<---+\n|    |Negotiation |    |\n|    +------------+    |\n|          |           |\n^          |           ^\n|          @           |\n|    +------------+    |\n|    |   Cache    |    |\n|-<--|            |-->-|\n|    | Summarize  |    |\n|    +------------+    |\n|          |           |\n^          |           ^\n|          @           |\n|    +------------+    |\n|    |   Update   |    |\n|-<--|            |-->-|\n|    |   Cache    |    |\n|    +------------+    |\n|          |           |\n^          |           ^\n|          @           |\n|    +------------+    |\n|    |            |    |\n+-<--|  Aligned   |-->-+\n     |            |\n     +------------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 2: Cache Alignment Finite State Machine",
      "ja": "図2：キャッシュアラインメント有限状態マシン"
    },
    {
      "indent": 0,
      "text": "2.2 Cache Alignment Protocol",
      "section_title": true,
      "ja": "2.2キャッシュアラインメントプロトコル"
    },
    {
      "indent": 3,
      "text": "\"Cache Alignment\" (CA) messages are used by an LS to synchronize its cache with that of the cache of each of its DCSs. That is, CA messages allow a booting LS to synchronize with each of its DCSs. A CA message contains a CA header followed by zero or more Cache State Advertisement Summary records (CSAS records).",
      "ja": "「キャッシュアラインメント」（CA）のメッセージは、そののDCSのそれぞれのキャッシュのようにそのキャッシュを同期するためにLSで使用されています。これは、CAメッセージがブートLSはそののDCSのそれぞれと同期できるようにする、です。 CAメッセージは、ゼロ以上のキャッシュステート広告サマリーレコード（CSASレコード）に続くCAヘッダを含んでいます。"
    },
    {
      "indent": 3,
      "text": "An LS has a Cache Alignment Finite State Machine (CAFSM) associated (see Figure 2) with each of its DCSs on a per PID/SGID basis, and the CAFSM monitors the state of the cache alignment between the servers. The CAFSM starts in the Down State. The CAFSM is associated with an HFSM, and when that HFSM reaches the Bidirectional State, the CAFSM transitions to the Master/Slave Negotiation State. The Master/Slave Negotiation State causes either the LS or DCS to take on the role of master over the cache alignment process. In a sense, the master server sets the tempo for the cache alignment.",
      "ja": "LSは、PID / SGID単位あたりにそののDCSのそれぞれに関連付けられたキャッシュアラインメント有限状態機械（CAFSM）を（図2参照）を有し、CAFSMは、サーバー間のキャッシュ整列の状態を監視します。 CAFSMはダウン状態で起動します。 CAFSMは、マスター/スレーブネゴシエーション状態にHFSMに関連付けられ、そのHFSM双方向状態に達したときに、CAFSM遷移されます。マスター/スレーブネゴシエーションステートは、LSやDCSのどちらかがキャッシュ整列プロセスの上にマスターの役割を担うようになります。ある意味では、マスターサーバーは、キャッシュの位置合わせのためのテンポを設定します。"
    },
    {
      "indent": 3,
      "text": "When the LS's CAFSM reaches the Master/Slave Negotiation State, the LS will send a CA message to the DCS associated with the CAFSM. The format of CA messages are described in Section B.2.1. The first CA message which the LS sends includes no CSAS records and a CA header which contains the LSID in the Sender ID field, the DCSID in the Receiver ID field, a CA sequence number, and three bits. These three bits are the M (Master/Slave) bit, the I (Initialization of master) bit, and the O (More) bit. In the first CA message sent by the LS to a particular DCS, the M, O, and I bits are set to one. If the LS does not receive a CA message from the DCS in CAReXmtInterval seconds then it resends the CA message it just sent. The LS continues to do this until the CAFSM transitions to the Cache Summarize State or until the HFSM transitions out of the Bidirectional State. Any time the HFSM transitions out of the Bidirectional State, the CAFSM transitions to the Down State.",
      "ja": "LSのCAFSMは、マスター/スレーブネゴシエーションステートに到達すると、LSはCAFSMに関連付けられてDCSにCAメッセージを送信します。 CAメッセージのフォーマットは、セクションB.2.1で説明されています。 LSが送信する最初のCAメッセージはCSAS記録および送信者IDフィールドでLSIDを含んCAヘッダ全く含まない、受信IDフィールドにDCSID、CAシーケンス番号、及び3ビット。これら3つのビットは、M（マスタ/スレーブ）ビット、Iビット（マスターの初期化）、およびO（詳細）ビットです。特定のDCS、M、O、及びIビットが1に設定されているにLSによって送信された最初のCAメッセージ内。 LSはCAReXmtInterval秒でDCSからCAメッセージを受信しない場合、それはそれだけで送信されたCAメッセージを再送信します。 LSは、キャッシュ[集計州または双方向ステートのうちHFSM遷移するまでCAFSM遷移するまでこれを実行し続けています。いつでもHFSMは​​、双方向状態からダウン状態にCAFSM遷移を遷移します。"
    },
    {
      "indent": 0,
      "text": "2.2.1 Master Slave Negotiation State",
      "section_title": true,
      "ja": "2.2.1マスタスレーブネゴシエーションステート"
    },
    {
      "indent": 3,
      "text": "When the LS receives a CA message from the DCS while in the Master/Slave Negotiation State, the role the LS plays in the exchange depends on packet processing as follows:",
      "ja": "マスター/スレーブネゴシエーションステートにいる間LSがDCSからCAメッセージを受信すると、以下のように、為替での役割LSの演劇は、パケットの処理に依存します。"
    },
    {
      "indent": 3,
      "text": "1) If the CA from the DCS has the M, I, and O bits set to one and there are no CSAS records in the CA message and the Sender ID as specified in the DCS's CA message is larger than the LSID then",
      "ja": "DCSからCAが1にセットM、I、およびOビットを有しており、DCSのCAメッセージで指定されないCSASレコードがCAメッセージおよび送信者IDに存在しない場合1）をLSIDより大きい"
    },
    {
      "indent": 5,
      "text": "a) The timer counting down the CAReXmtInterval is stopped. b) The CAFSM corresponding to that DCS transitions to the Cache Summarize State and the LS takes on the role of slave. c) The LS adopts the CA sequence number it received in the CA message as its own CA sequence number. d) The LS sends a CA message to the DCS which is formated as follows: the M and I bits are set to zero, the Sender ID field is set to the LSID, the Receiver ID field is set to the DCSID, and the CA sequence number is set to the CA sequence number that appeared in the DCS's CA message. If there are CSAS records to be sent (i.e., if the LS's cache is not empty), and if all of them will not fit into this CA message then the O bit is set to one and the initial set of CSAS records are included in the CA message; otherwise the O bit is set to zero and if any CSAS Records need to be sent then those records are included in the CA message.",
      "ja": "A）CAReXmtIntervalをカウントダウンタイマーが停止しています。 b）はそのDCSに対応CAFSMはキャッシュ集計状態に遷移し、LSは、スレーブの役割を引き受けます。 C）LSは、それ自身のCA配列番号としてCAメッセージで受信CAシーケンス番号を採用しています。 D）LSは、次のようにフォーマットされているDCSにCAメッセージを送信：M及びIビットはゼロに設定され、送信者IDフィールドはLSIDに設定され、受信機IDフィールドはDCSIDに設定され、CAシーケンス番号は、DCSのCAメッセージに登場CAのシーケンス番号に設定されています。 （LSのキャッシュが空でない場合、すなわち、）、およびそれらのすべてが、その後Oビットが1に設定されている。このCAメッセージとCSASレコードの最初のセットに収まらない場合に含まれて送信されるCSAS記録がある場合CAメッセージ。それ以外の場合はOビットがゼロに設定され、任意のCSAS記録はその後、送信する必要がある場合は、それらのレコードは、CAメッセージに含まれています。"
    },
    {
      "indent": 3,
      "text": "2) If the CA message from the DCS has the M and I bits off and the Sender ID as specified in the DCS's CA message is smaller than the LSID then",
      "ja": "2）DCSからCAメッセージは、Mを有しており、私はオフビット及びDCSのCAメッセージで指定されている送信者IDがLSIDよりも小さい場合"
    },
    {
      "indent": 5,
      "text": "a) The timer counting down the CAReXmtInterval is stopped. b) The CAFSM corresponding to that DCS transitions to the Cache Summarize State and the LS takes on the role of master. c) The LS must process the received CA message. An explanation of CA message processing is given below. d) The LS sends a CA message to the DCS which is formated as follows: the M bit is set to one, I bit is set to zero, the Sender ID field is set to the LSID, the Receiver ID field is set to the DCSID, and the LS's current CA sequence number is incremented by one and placed in the CA message. If there are any CSAS records to be sent from the LS to the DCS (i.e., if the LS's cache is not empty) then the O bit is set to one and the initial set of CSAS records are included in the CA message that the LS is sending to the DCS.",
      "ja": "A）CAReXmtIntervalをカウントダウンタイマーが停止しています。 b）はそのDCSに対応CAFSMはキャッシュ集計状態に遷移し、LSはマスターの役割を引き受けます。 C）LSは、受信したCAメッセージを処理しなければなりません。 CAメッセージ処理の説明を以下に示します。 D）LSは、次のようにフォーマットされているDCSにCAメッセージを送信する：Mビットが1に設定され、Iビットがゼロに設定され、送信者IDフィールドはLSIDに設定され、受信機IDフィールドがに設定されていますDCSID、及びLSの現在のCAシーケンス番号を1インクリメントし、CAメッセージに配置されます。 DCSにLSから送信される任意のCSAS記録が（すなわち、LSのキャッシュが空でない場合）がある場合、Oビットが1に設定され、LSことCSASレコードの最初のセットは、CAメッセージに含まれていますDCSに送信されます。"
    },
    {
      "indent": 3,
      "text": "3) Otherwise, the packet must be ignored.",
      "ja": "3）それ以外の場合、パケットは無視されなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2.2 The Cache Summarize State",
      "section_title": true,
      "ja": "キャッシュ集計状態は2.2.2"
    },
    {
      "indent": 3,
      "text": "At any given time, the master or slave have at most one outstanding CA message. Once the LS's CAFSM has transitioned to the Cache Summarize State the sequence of exchanges of CA messages occurs as follows:",
      "ja": "任意の時点で、マスタまたはスレーブは最大1つの優れたCAメッセージを持っています。 LSのCAFSMがキャッシュ集計状態に移行した後は、次のようにCAメッセージの交換のシーケンスが発生します。"
    },
    {
      "indent": 3,
      "text": "1) If the LS receives a CA message with the M bit set incorrectly (e.g., the M bit is set in the CA of the DCS and the LS is master) or if the I bit is set then the CAFSM transitions back to the Master/Slave Negotiation State.",
      "ja": "1）LSは、MとCAメッセージは、例えば、MビットはDCSのCAに設定し、LSがマスターである）、またはIビットがセットされている場合、CAFSMバックマスターに移行される（正しく設定ビットを受信した場合/スレーブネゴシエーションステート。"
    },
    {
      "indent": 3,
      "text": "2) If the LS is master and the LS receives a CA message with a CA sequence number which is one less than the LS's current CA sequence number then the message is a duplicate and the message MUST be discarded.",
      "ja": "LSがマスターであり、LSは、LSの現在のCAのシーケンス番号よりも1つ少ないCAシーケンス番号とCAメッセージを受信した場合2）メッセージが重複していると、メッセージは破棄されなければなりません。"
    },
    {
      "indent": 3,
      "text": "3) If the LS is master and the LS receives a CA message with a CA sequence number which is equal to the LS's current CA sequence number then the CA message MUST be processed. An explanation of \"CA message processing\" is given below. As a result of having received the CA message from the DCS the following will occur:",
      "ja": "3）LSがマスターであり、LSは、次にCAメッセージが処理されなければならないLSの現在のCA配列の数に等しいCAシーケンス番号とCAメッセージを受信した場合。 「CAメッセージ処理」の説明は以下のとおりです。以下に、発生するDCSからCAメッセージを受信した結果："
    },
    {
      "indent": 5,
      "text": "a) The timer counting down the CAReXmtInterval is stopped. b) The LS must process any CSAS records in the received CA message. c) Increment the LS's CA sequence number by one. d) The cache exchange continues as follows:",
      "ja": "A）CAReXmtIntervalをカウントダウンタイマーが停止しています。 b）のLSは、受信CAメッセージ内の任意のCSASレコードを処理する必要があります。 c）のいずれかでLSのCAのシーケンス番号をインクリメントします。次のようにd）のキャッシュ交換が続きます："
    },
    {
      "indent": 7,
      "text": "1) If the LS has no more CSAS records to send and the received CA message has the O bit off then the CAFSM transitions to the Update Cache State. 2) If the LS has no more CSAS records to send and the received CA message has the O bit on then the LS sends back a CA message (with new CA sequence number) which contains no CSAS records and with the O bit off. Reset the timer counting down the CAReXmtInterval. 3) If the LS has more CSAS records to send then the LS sends the next CA message with the LS's next set of CSAS records. If LS is sending its last set of CSAS records then the O bit is set off otherwise the O bit is set on. Reset the timer counting down the CAReXmtInterval.",
      "ja": "1）LSを送信するためにこれ以上のCSAS記録を持っていないし、受信したCAメッセージをオフ、その後CAFSM遷移アップデートキャッシュの状態にOビットを持っています。場合2）LSを送信するためにそれ以上CSASレコードを持っていない、受信したCAメッセージが全くCSASレコードを含まず、OのビットをオフにしLSは、新しいCAシーケンス番号とCAメッセージ（返信その後にOビット）を有している場合。 CAReXmtIntervalをカウントダウンタイマーをリセットします。 LSを送信するために多くのCSAS記録を持っている場合3）その後、LSはLS年代CSASレコードの次のセットで次のCAメッセージを送信します。 LSはCSASレコードのその最後のセットを送信している場合は、Oビットはそうでない場合はオフに設定されているOビットがオンに設定されています。 CAReXmtIntervalをカウントダウンタイマーをリセットします。"
    },
    {
      "indent": 3,
      "text": "4) If the LS is slave and the LS receives a CA message with a CA sequence number which is equal to the LS's current CA sequence number then the CA message is a duplicate and the LS MUST resend the CA message which it had just sent to the DCS.",
      "ja": "4）LSは、スレーブであり、LSは、LSの現在のCA配列の数に等しいCAシーケンス番号のCAメッセージを受信し、次にCAメッセージが重複しているとLSは、それだけに送られたCAメッセージを再送する必要がある場合DCS。"
    },
    {
      "indent": 3,
      "text": "5) If the LS is slave and the LS receives a CA message with a CA sequence number which is one more than the LS's current CA sequence number then the message is valid and MUST be processed. An explanation of \"CA message processing\" is given below. As a result of having received the CA message from the DCS the following will occur:",
      "ja": "LSがスレーブであり、LSは、LSの現在のCA配列の数より1多いCAシーケンス番号とCAメッセージを受信した場合5）、メッセージが有効であり、処理されなければなりません。 「CAメッセージ処理」の説明は以下のとおりです。以下に、発生するDCSからCAメッセージを受信した結果："
    },
    {
      "indent": 5,
      "text": "a) The LS must process any CSAS records in the received CA message. b) Set the LS's CA sequence number to the CA sequence number in the CA message. c) The cache exchange continues as follows:",
      "ja": "a）のLSは、受信CAメッセージ内の任意のCSASレコードを処理する必要があります。 b）はCAメッセージでCAのシーケンス番号にLSのCAのシーケンス番号を設定します。次のようにC）キャッシュ交換が続きます："
    },
    {
      "indent": 7,
      "text": "1) If the LS had just sent a CA message with the O bit off and the received CA message has the O bit off then the CAFSM transitions to the Update Cache State and the LS sends a CA message with no CSAS records and with the O bit off. 2) If the LS still has CSAS records to send then the LS MUST send a CA message with CSAS records in it.",
      "ja": "LSが持っていた場合は1）だけオフOビットとCAメッセージを送信し、受信したCAメッセージがオフOビットを持って、その後の更新キャッシュの状態にCAFSM遷移とLSはありませんCSAS記録とし、OとCAメッセージを送信します少しオフ。 LSはまだ続い送信するためにCSAS記録を持っている場合2）LSは、その中にCSAS記録とCAメッセージを送らなければなりません。"
    },
    {
      "indent": 9,
      "text": "a) If the message being sent from the LS to the DCS does not contain the last CSAS records that the LS needs to send then the CA message is sent with the O bit on. b) If the message being sent from the LS to the DCS does contain the last CSAS records that the LS needs to send and the CA message just received from the DCS had the O bit off then the CA message is sent with the O bit off, and the LS transitions the CAFSM to the Update Cache State. c) If the message being sent from the LS to the DCS does contain the last CSAS records that the LS needs to send and the CA message just received from the DCS had the O bit on then the CA message is sent with the O bit off and the alignment process continues.",
      "ja": "DCSにLSから送信されたメッセージが含まれていない場合a）の最後のCSASはLSは、その後、CAメッセージが上のOビットで送信される送信する必要があることを記録します。 DCSにLSから送信されたメッセージが含まれていない場合b）の最後のCSASはLSを送信する必要があるとちょうどDCSから受信したCAメッセージは、Oビットがオフその後、CAメッセージがオフOビットで送信されたことを記録します、およびLSは、アップデートキャッシュの状態にCAFSMを移行します。 DCSにLSから送信されたメッセージが含まれていない場合c）の最後のCSASはLSを送信する必要があるとちょうどDCSから受信したCAメッセージは、その後、CAメッセージがオフOビットで送信されるにOビットを持っていたことを記録します配向処理が継続されます。"
    },
    {
      "indent": 3,
      "text": "6) If the LS is slave and the LS receives a CA message with a CA sequence number that is neither equal to nor one more than the current LS's CA sequence number then an error has occurred and the CAFSM transitions to the Master/Slave Negotiation State.",
      "ja": "6）LSスレーブであり、LSは、現在のLSのエラーが発生したCAのシーケンス番号とマスター/スレーブネゴシエーション状態にCAFSM遷移に等しいももう一つもないCAシーケンス番号とCAメッセージを受信した場合。"
    },
    {
      "indent": 3,
      "text": "Note that if the LS was slave during the CA process then the LS upon transitioning the CAFSM to the Update Cache state MUST keep a copy of the last CA message it sent and the LS SHOULD set a timer equal to CAReXmtInterval. If either the timer expires or the LS receives a CSU Solicit (CSUS) message (CSUS messages are described in Section 2.2.3) from the DCS then the LS releases the copy of the CA message. The reason for this is that if the DCS (which is master) loses the last CA message sent by the LS then the DCS will resend its previous CA message with the last CA Sequence number used. If that were to occur the LS would need to resend its last sent CA message as well.",
      "ja": "LSは、CAプロセス中に奴隷だった場合、その後の更新キャッシュの状態にCAFSMの移行時にLSはそれが最後に送信されたCAメッセージのコピーを保持しなければならないし、LSはCAReXmtIntervalに等しいタイマーを設定すべきであることに注意してください。タイマーのどちらかの期限が切れるか、LSがDCSから（CSUSメッセージは、セクション2.2.3で説明されている）CSU要請（CSUS）メッセージを受信した場合、LSは、CAメッセージのコピーを解放します。この理由は、DCSである（マスター）はLSによって送信された最後のCAメッセージを失うならば、DCSは、最後に使用CAシーケンス番号とその前のCAメッセージを再送することです。それが発生した場合LSは、同様にその最後の送信されたCAメッセージを再送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2.2.1 \"CA message processing\":",
      "section_title": true,
      "ja": "2.2.2.1 \"CAメッセージ処理\"："
    },
    {
      "indent": 3,
      "text": "The LS makes a list of those cache entries which are more \"up to date\" in the DCS than the LS's own cache. This list is called the CSA Request List (CRL). See Section 2.4 for a description of what it means for a CSA (Client State Advertisement) record or CSAS record to be more \"up to date\" than an LS's cache entry.",
      "ja": "LSは、より多くの「最新に」DCSでLS自身のキャッシュよりも、それらのキャッシュエントリのリストを作成します。このリストは、CSAの要求リスト（CRL）と呼ばれています。それはLSのキャッシュエントリーよりも「最新に」もっとするCSA（クライアント状態アドバタイズメント）レコードまたはCSAS記録のために何を意味するのかについては、2.4節を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.2.3 The Update Cache State",
      "section_title": true,
      "ja": "アップデートキャッシュの状態は2.2.3"
    },
    {
      "indent": 3,
      "text": "If the CRL of the associated CAFSM of the LS is empty upon transition into the Update Cache State then the CAFSM immediately transitions into the Aligned State.",
      "ja": "LSの関連するCAFSMのCRLが更新キャッシュの状態への移行時に空の場合、CAFSMは、直ちに配向状態に遷移します。"
    },
    {
      "indent": 3,
      "text": "If the CRL is not empty upon transition into the Update Cache State then the LS solicits the DCS to send the CSA records corresponding to the summaries (i.e., CSAS records) which the LS holds in its CRL. The solicited CSA records will contain the entirety of the cached information held in the DCS's cache for the given cache entry. The LS solicits the relevant CSA records by forming CSU Solicit (CSUS) messages from the CRL. See Section B.2.4 for the description of the CSUS message format. The LS then sends the CSUS messages to the DCS. The DCS responds to the CSUS message by sending to the LS one or more",
      "ja": "CRLが更新キャッシュ状態への遷移時に空でない場合、LSは、LSは、そのCRLに保持要約（即ち、CSASレコード）に対応するCSAレコードを送信するようにDCSを勧誘します。募集CSAレコードは、与えられたキャッシュエントリのためのDCSのキャッシュに開催されたキャッシュされた情報の全てが含まれています。 LSは、CRLからCSU要請（CSUS）メッセージを形成することにより、関連するCSAレコードを要求します。 CSUSメッセージフォーマットの説明については、セクションB.2.4を参照してください。 LSは、DCSにCSUSメッセージを送信します。 DCSは、LS 1つまたは複数に送信することにより、CSUSメッセージに応答します"
    },
    {
      "indent": 3,
      "text": "CSU Request messages containing the entirety of newer cached information identified in the CSUS message. Upon receiving the CSU Request the LS will send one or more CSU Replies as described in Section 2.3. Note that the LS may have at most one CSUS message outstanding at any given time.",
      "ja": "CSUSメッセージで識別新しいキャッシュされた情報の全てを含むCSU要求メッセージ。 LSは、1つまたは複数のCSUを送信しますCSUリクエストを受信すると、2.3節で説明したように返信します。 LSは、任意の時点で、優れた高々1つのCSUSメッセージを持っていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Just before the first CSUS message is sent from an LS to the DCS associated with the CAFSM, a timer is set to CSUSReXmtInterval seconds. If all the CSA records corresponding to the CSAS records in the CSUS message have not been received by the time that the timer expires then a new CSUS message will be created which contains all the CSAS records for which no appropriate CSA record has been received plus additional CSAS records not covered in the previous CSUS message. The new CSUS message is then sent to the DCS. If, at some point before the timer expires, all CSA record updates have been received for all the CSAS records included in the previously sent CSUS message then the timer is stopped. Once the timer is stopped, if there are additional CSAS records that were not covered in the previous CSUS message but were in the CRL then the timer is reset and a new CSUS message is created which contains only those CSAS records from the CRL which have not yet been sent to the DCS. This process continues until all the CSA records corresponding CSAS records that were in the CRL have been received by the LS. When the LS has a completely updated cache then the LS transitions CAFSM associated with the DCS to the Aligned State.",
      "ja": "最初のCSUSメッセージはCAFSMに関連付けられているDCSにLSから送信される直前に、タイマーがCSUSReXmtInterval秒に設定されています。 CSUSメッセージにCSASレコードに対応するすべてのCSAレコードは、タイマーは、新しいCSUSメッセージは何の適切なCSAレコードが受信されなかっ加え、追加されたすべてのCSASレコードが含まれていますが作成されます有効期限が切れるまでに受信されていない場合CSAS記録は、以前のCSUSメッセージに記載されていません。新しいCSUSメッセージはその後、DCSに送信されます。 、タイマーが切れる前に、いくつかの点で、すべてのCSAのレコード更新が以前に送信されたCSUSメッセージに含まれるすべてのCSAS記録のために受信された場合、タイマーが停止しています。タイマーが停止されると、以前のCSUSメッセージでカバーされますがCRLにあったていなかった追加のCSAS記録がある場合は、その後、タイマーがリセットされ、新しいCSUSメッセージは持っていないCRLからのみCSASレコードが含まれて作成されますまだDCSに送信されて。 CRLにあったCSAS記録を、対応するすべてのCSAレコードは、LSによって受信されるまで、このプロセスは継続します。 LSはその後、配向状態にDCSに関連したLS遷移のCAFSMを完全に更新されたキャッシュを持っている場合。"
    },
    {
      "indent": 3,
      "text": "If an LS receives a CSUS message or a CA message with a Receiver ID which is not the LS's LSID then the message must be discarded and ignored. This is necessary since an LS may be a leaf of a point to multipoint connection with other servers in the SG.",
      "ja": "LSはCSUSメッセージまたはそのメッセージは破棄され、無視されなければならないLSのLSIDではありませんレシーバIDとCAメッセージを受信した場合。 LSがSG内の他のサーバとの接続をポイントツーマルチポイントの葉であってもよいので、これは必要です。"
    },
    {
      "indent": 0,
      "text": "2.2.4 The Aligned State",
      "section_title": true,
      "ja": "配向状態を2.2.4"
    },
    {
      "indent": 3,
      "text": "While in the Aligned state, an LS will perform the Cache State Update Protocol as described in Section 2.3.",
      "ja": "2.3節で説明したように整列された状態にある間、LSは、キャッシュの状態更新プロトコルを実行します。"
    },
    {
      "indent": 3,
      "text": "Note that an LS may receive a CSUS message while in the Aligned State and, the LS MUST respond to the CSUS message with the appropriate CSU Request message in a similar fashion to the method previously described in Section 2.2.3.",
      "ja": "LSは、配向状態にある間CSUSメッセージを表示することと、LSは、以前のセクション2.2.3に記載の方法と同様の方法で、適切なCSUリクエストメッセージでCSUSメッセージに応答しなければならないことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "2.3 Cache State Update Protocol",
      "section_title": true,
      "ja": "2.3キャッシュの状態更新プロトコル"
    },
    {
      "indent": 3,
      "text": "\"Cache State Update\" (CSU) messages are used to dynamically update the state of cache entries in servers on a given PID/SGID basis. CSU messages contain zero or more \"Cache State Advertisement\" (CSA) records each of which contains its own snapshot of the state of a particular cache entry. An LS may send/receive a CSU to/from a DCS only when the corresponding CAFSM is in either the Aligned State or the Update Cache State.",
      "ja": "「キャッシュ状態更新」（CSU）のメッセージが動的に与えられたPID / SGIDベースでサーバにキャッシュエントリの状態を更新するために使用されています。 CSUメッセージが含まれているゼロ以上の「キャッシュ状態アドバタイズメント」（CSA）は、特定のキャッシュエントリの状態の独自のスナップショットが含まれ、それぞれが記録されます。 LSは、対応するCAFSMが配向状態またはアップデートキャッシュのいずれかの状態にあるときだけに/ DCSからCSUを送信/受信することがあります。"
    },
    {
      "indent": 3,
      "text": "There are two types of CSU messages: CSU Requests and CSU Replies. See Sections B.2.2 and B.2.3 respectively for message formats. A CSU Request message is sent from an LS to one or more DCSs for one of two reasons: either the LS has received a CSUS message and MUST respond only to the DCS which originated the CSUS message, or the LS has become aware of a change of state of a cache entry. An LS becomes aware of a change of state of a cache entry either through receiving a CSU Request from one of its DCSs or as a result of a change of state being observed in a cached entry originated by the LS. In the former case, the LS will send a CSU Request to each of its DCSs except the DCS from which the LS became aware of the change in state. In the latter case, the LS will send a CSU Request to each of its DCSs. The change in state of a particular cache entry is noted in a CSA record which is then appended to the end of the CSU Request message mandatory part. In this way, state changes are propagated throughout the SG.",
      "ja": "CSU要求とCSUの回答：CSUメッセージの2種類があります。メッセージ・フォーマットのために、それぞれのセクションB.2.2とB.2.3を参照してください。 LSはCSUSメッセージを受信しただけCSUSメッセージを発信したDCSに応答しなければならないか、LSは、変化に気付いた：CSU Requestメッセージは、二つの理由のいずれか一の以上のDCSへLSから送信されますキャッシュエントリの状態。 LSはそののDCSの一つから又はLSによって発信キャッシュエントリに観察される状態の変化の結果としてCSU要求を受信介してキャッシュ・エントリのいずれかの状態の変化に気付きます。前者の場合、LSはLSは、状態の変化を意識するようになりました、そこからDCS以外ののDCSのそれぞれにCSUリクエストを送信します。後者の場合、LSは、そののDCSのそれぞれにCSUリクエストを送信します。特定のキャッシュ・エントリの状態の変化は、その後、CSU Requestメッセージ必須部分の最後に追加されCSAレコードに留意されたいです。このように、状態変化は、SG全体に伝播されます。"
    },
    {
      "indent": 3,
      "text": "Examples of such changes in state are as follows:",
      "ja": "次のように状態のそのような変化の例は次の通りであります："
    },
    {
      "indent": 7,
      "text": "1) a server receives a request from a client to add an entry to\n   its cache,\n2) a server receives a request from a client to remove an entry\n   from its cache,\n3) a cache entry has timed out in the server's cache, has been\n   refreshed in the server's cache, or has been administratively\n   modified.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When an LS receives a CSU Request from one of its DCSs, the LS acknowledges one or more CSA Records which were contained in the CSU Request by sending a CSU Reply. The CSU Reply contains one or more CSAS records which correspond to those CSA records which are being acknowledged. Thus, for example, if a CSA record is dropped (or delayed in processing) by the LS because there are insufficient resources to process it then a corresponding CSAS record is not included in the CSU Reply to the DCS.",
      "ja": "LSはそののDCSの一つからCSU要求を受信すると、LSは、CSU返信を送信することによって、CSUリクエストに含まれた一つ以上のCSAレコードを認めます。 CSU返信が認められているものをCSAレコードに対応する1件の以上のCSAS記録が含まれています。それを処理するのに十分なリソースがあるためCSAレコードはLSによってドロップ（または処理に遅延）されている場合したがって、例えば、対応するCSAS記録がDCSにCSU応答に含まれていません。"
    },
    {
      "indent": 3,
      "text": "Note that an LS may send multiple CSU Request messages before receiving a CSU Reply acknowledging any of the CSA Records contained in the CSU Requests. Note also that a CSU Reply may contain acknowledgments for CSA Records from multiple CSU Requests. Thus, the terms \"request\" and \"reply\" may be a bit confusing.",
      "ja": "LSは、CSU要求に含まれるCSAレコードのいずれかを認める返信CSUを受信する前に、複数のCSUリクエストメッセージを送信することがあります。 CSU返信が複数のCSU要求からCSAレコードの確認応答を含むことができることにも注意してください。したがって、用語「リクエスト」とは少し混乱することができる「返信」。"
    },
    {
      "indent": 3,
      "text": "Note that a CSA Record contains a CSAS Record followed by client/server protocol specific information contained in a cache entry (see Section B.2.0.2 for CSAS record format information and",
      "ja": "CSAのレコードがCSASのレコードがキャッシュエントリに含まれているクライアント/サーバプロトコル固有の情報に続いて含まれていることに注意してください（CSAS記録フォーマット情報については、セクションB.2.0.2を参照し、"
    },
    {
      "indent": 3,
      "text": "Section B.2.2.1 for CSA record format information). When a CSA record is considered by the LS to represent cached information which is more \"up to date\" (see Section 2.4) than the cached information contained within the cache of the LS then two things happen: 1) the LS's cache is updated with the more up to date information, and 2) the LS sends a CSU Request containing the CSA Record to each of its DCSs except the one from which the CSA Record arrived. In this way, state changes are propagated within the PID/SGID. Of course, at some point, the LS will also acknowledge the reception of the CSA Record by sending the appropriate DCS a CSU Reply message containing the corresponding CSAS Record.",
      "ja": "CSAレコード形式情報のセクションB.2.2.1）。 CSAレコードは、より「最新」であるキャッシュされた情報を表現するためにLSで考えた場合、2つのことが起こるLSのキャッシュに含まれるキャッシュされた情報よりも（2.4節を参照）：1）LSのキャッシュがで更新されます最新情報を複数、及び2）LSはCSAレコードが到着したから1を除いて、そののDCSの各CSAレコードを含むCSU Requestを送信します。このように、状態変化がPID / SGID内を伝播されています。もちろん、いくつかの点で、LSは、対応するCSASレコードを含む適切なDCS CSU応答メッセージを送信することによって、CSAレコードの受信を確認します。"
    },
    {
      "indent": 3,
      "text": "When an LS sends a new CSU Request, the LS keeps track of the outstanding CSA records in that CSU Request and to which DCSs the LS sent the CSU Request. For each DCS to which the CSU Request was sent, a timer set to CSUReXmtInterval seconds is started just prior to sending the CSU Request. This timer is associated with the CSA Records contained in that CSU Request such that if that timer expires prior to having all CSA Records acknowledged from that DCS then (and only then) a CSU Request is re-sent by the LS to that DCS. However, the re-sent CSU Request only contains those CSA Records which have not yet been acknowledged. If all CSA Records associated with a timer becomes acknowledged then the timer is stopped. Note that the re-sent CSA Records follow the same time-out and retransmit rules as if they were new. Retransmission will occur a configured number of times for a given CSA Record and if acknowledgment fails to occur then an \"abnormal event\" has occurred at which point the then the HFSM associated with the DCS is transitioned to the Waiting State.",
      "ja": "LSは、新しいCSUリクエストを送信すると、LSはそのCSU Requestに優れCSAレコードを追跡し、LSは、CSUリクエストを送っDCSSしています。各DCSはどのCSUリクエストが送信されたために、CSUReXmtInterval秒にタイマーセットは、CSUリクエストを送信する直前に開始されました。このタイマーは、そのCSUリクエストに含まれるCSAレコードに関連付けられているように、タイマが満了した場合、すべてのCSAレコードを有することに先立って認めていることから、そのDCS次いで（のみ次に）CSUリクエストがそのDCSにLSによって再送信されます。しかし、再送信されたCSUリクエストはまだ確認されていないものをCSAのレコードが含まれています。タイマーに関連するすべてのCSAレコードは、その後認めになった場合、タイマーは停止されます。彼らは新しいであるかのように再送信されたCSAのレコードが同じタイムアウトおよび再送信の規則に従っていることに注意してください。再送は、所定のCSAレコードの時間の設定された番号を発生し、確認応答が起こらないならば、「異常事象」は、その後DCSに関連付けHFSMが待機状態に遷移される時点で発生しています。"
    },
    {
      "indent": 3,
      "text": "A CSA Record instance is said to be on a \"DCS retransmit queue\" when it is associated with the previously mentioned timer. Only the most up-to-date CSA Record is permitted to be queued to a given DCS retransmit queue. Thus, if a less up-to-date CSA Record is queued to the DCS retransmit queue when a newer CSA Record instance is about to be queued to that DCS retransmit queue then the older CSA Record instance is dequeued and disassociated with its timer immediately prior to enqueuing the newer instance of the CSA Record.",
      "ja": "CSAレコードのインスタンスは、それが前述したタイマーに関連付けられている「DCSの再送信キュー」になると言われています。のみ最新のCSAレコードは、与えられたDCSの再送信キューにキューイングすることが許可されています。このように、少ない最新のCSAレコードは、新しいCSAレコードインスタンスは、その後古いCSAレコードインスタンスがデキューし、そのタイマーとの関連付けが解除されたDCSの再送信キューにキューイングされようとしているDCSの再送信キューに格納されている場合の直前CSAのレコードの新しいインスタンスをエンキューします。"
    },
    {
      "indent": 3,
      "text": "When an LS receives a CSU Reply from one of its DCSs then the LS checks each CSAS record in the CSU Reply against the CSAS Record portion of the CSA Records which are queued to the DCS retransmit queue.",
      "ja": "LSは、LSのDCS次にチェックDCS再送信キューにキューイングされているCSAレコードのCSAS記録部に対してCSU応答に各CSASレコードの一つからCSU返信を受信した場合。"
    },
    {
      "indent": 5,
      "text": "1) If there exists an exact match between the CSAS record portion of the CSA record and a CSAS Record in the CSU Reply then that CSA Record is considered to be acknowledged and is thus dequeued from the DCS retransmit queue and is disassociated with its timer.",
      "ja": "1）CSAレコードのCSAS記録部とCSAレコードは認めていると考えられるので、DCS再送信キューからデキューされ、そのタイマーと関連付けが解除されていること次にCSU応答にCSASレコード間の正確な一致が存在する場合。"
    },
    {
      "indent": 5,
      "text": "2) If there exists a match between the CSAS record portion of the CSA record and a CSAS Record in the CSU Reply except for the CSA Sequence number then",
      "ja": "2）次に、CSAのシーケンス番号を除いCSU応答のCSAレコードのCSAS記録部とCSAS記録の間に一致が存在する場合"
    },
    {
      "indent": 7,
      "text": "a) If the CSA Record queued to the DCS retransmit queue has a CSA Sequence Number which is greater than the CSA Sequence Number in the CSAS Record of the the CSU Reply then the CSAS Record in the CSU Reply is ignored. b) If the CSA Record queued to the DCS retransmit queue has a CSA Sequence Number which is less than the CSA Sequence Number in the CSAS Record of the the CSU Reply then CSA Record which is queued to the DCS retransmit queue is dequeued and the CSA Record is disassociated with its timer. Further, a CSUS Message is sent to that DCS which sent the more up-to-date CSAS Record. All normal CSUS processing occurs as if the CSUS were sent as part of the CA protocol.",
      "ja": "A）CSAのレコードは、DCSの再送信キューにキューイングされている場合は、CSU返信後、CSUの返信でCSAS記録が無視されるのCSASレコードにCSAシーケンス番号よりも大きいCSAシーケンス番号を持っています。 B）CSAレコードは、DCS再送信キューにキューイングされている場合デキューされるDCS再送信キューにキューイングされたCSU返信次いでCSAレコードのCSAS記録におけるCSAのシーケンス番号とCSA未満であるCSAシーケンス番号を有します録音は、そのタイマーとの関連付けが解除されます。さらに、CSUSメッセージは、より最新のCSAS録音を送っているDCSに送信されます。 CSUSがCAプロトコルの一部として送信されたかのようにすべての通常CSUS処理が発生します。"
    },
    {
      "indent": 3,
      "text": "When an LS receives a CSU Request message which contains a CSA Record which contains a CSA Sequence Number which is smaller than the CSA Sequence number of the cached CSA then the LS MUST acknowledge the CSA record in the CSU Request but it MUST do so by sending a CSU Reply message containing the CSAS Record portion of the CSA Record stored in the cache and not the CSAS Record portion of the CSA Record contained in the CSU Request.",
      "ja": "LSは、LSがCSU RequestにCSA記録を確認する必要がありますが、送信することによって、そうしなければならない、キャッシュされたCSAのCSAのシーケンス番号よりも小さいCSAシーケンス番号が含まれているCSAのレコードが含まれているCSU Requestメッセージを受信すると、 CSAレコードのCSAS記録部分を含むCSU Replyメッセージは、キャッシュに格納され、CSAレコードのCSAS記録部は、CSUリクエストに含まれていません。"
    },
    {
      "indent": 3,
      "text": "An LS responds to CSUS messages from its DCSs by sending CSU Request messages containing the appropriate CSA records to the DCS. If an LS receives a CSUS message containing a CSAS record for an entry which is no longer in its database (e.g., the entry timed out and was discarded after the Cache Alignment exchange completed but before the entry was requested through a CSUS message), then the LS will respond by copying the CSAS Record from the CSUS message into a CSU Request message and the LS will set the N bit signifying that this record is a NULL record since the cache entry no longer exists in the LS's cache. Note that in this case, the \"CSA Record\" included in the CSU Request to signify the NULL cache entry is literally only a CSAS Record since no client/server protocol specific information exists for the cache entry.",
      "ja": "LSは、DCSに適切なCSAレコードを含むCSUリクエストメッセージを送信することにより、そのDCSはからCSUSメッセージに応答します。 LSは、そのデータベースでなくなったエントリのCSAS記録を含むCSUSメッセージを受信した場合、その後、（例えば、エントリがタイムアウトし、完了したキャッシュの整合交換後に廃棄されましたが、エントリがCSUSメッセージを介して要求された前） LSは、CSUリクエストメッセージにCSUSメッセージからCSASのレコードをコピーすることによって応答し、LSは、キャッシュ・エントリがもはやLSのキャッシュに存在するので、このレコードはNULLレコードではないことを意味するNビットをセットします。何のクライアント/サーバプロトコル固有の情報は、キャッシュエントリのために存在していないので、この場合には、NULLキャッシュエントリを意味するCSU Requestに含まれる「CSAのレコードは」文字通り唯一のCSAS記録であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If an LS receives a CSA Record in a CSU Request from a DCS for which the LS has an identical CSA record posted to the corresponding DCS's DCS retransmit queue then the CSA Record on the DCS retransmit queue is considered to be implicitly acknowledged. Thus, the CSA Record is dequeued from the DCS retransmit queue and is disassociated with its timer. The CSA Record sent by the DCS MUST still be acknowledged by the LS in a CSU Reply, however. This is useful in the case of point to multipoint connections where the rule that \"when an LS receives a CSA record from a DCS, that LS floods the CSA Record to every DCS except the DCS from which it was received\" might be broken.",
      "ja": "LSはLSが同一CSAレコードは、対応するDCSのDCSの再送信キューにポストしていたためにDCSからCSU RequestにCSAのレコードを受ける場合は、DCSの再送キュー上のCSAレコードは暗黙のうちに認めていると考えられます。このように、CSAのレコードは、DCSの再送信キューからデキューされ、そのタイマーとの関連付けが解除されます。 DCSにより送信されたCSAのレコードはまだしかし、CSUの返信でLSによって承認されなければなりません。これはどこ壊れている可能性があります「LSは、それが受信されたDCSを除くすべてのDCSへのCSAのレコードをフラッディングしているが、LS、DCSからCSAレコードを受け取る」というルールの接続をポイントツーマルチポイントの場合に便利です。"
    },
    {
      "indent": 3,
      "text": "If an LS receives a CSU with a Receiver ID which is not equal to the LSID and is not set to all 0xFFs then the CSU must be discarded and ignored. This is necessary since the LS may be a leaf of a point to multipoint connection with other servers in the LS's SG.",
      "ja": "LSは、LSIDに等しくない場合、次いで、CSUは廃棄され、無視されなければならない全て0xFFsに設定されていない受信機IDとCSUを受信した場合。 LSはLSのSG内の他のサーバーとの接続をポイントツーマルチポイントの葉かもしれないので、これが必要です。"
    },
    {
      "indent": 3,
      "text": "An LS MAY send a CSU Request to the all 0xFFs Receiver ID when the LS is a root of a point to multipoint connection with a set of its DCSs. If an LS receives a CSU Request with the all 0xFFs Receiver ID then it MUST use the Sender ID in the CSU Request as the Receiver ID of the CSU Reply (i.e., it MUST unicast its response to the sender of the request) when responding. If the LS wishes to send a CSU Request to the all 0xFFs Receiver ID then it MUST create a time-out and retransmit timer for each of the DCSs which are leaves of the point to multipoint connection prior to sending the CSU Request. If in this case, the time-out and retransmit timer expires for a given DCS prior to acknowledgment of a given CSA Record then the LS MUST use the specific DCSID as the Receiver ID rather than the all 0xFFs Receiver ID. Similarly, if it is necessary to re-send a CSA Record then the LS MUST specify the specific DCSID as the Receiver ID rather than the all 0xFFs Receiver ID.",
      "ja": "LSは、そののDCSのセットとの接続をポイントツーマルチポイントのルートであるとき、LSは、すべての0xFFsレシーバIDにCSUの要求を送信することができます。 LSは、すべて0xFFsレシーバIDとCSU Requestを受信した場合、それは応答CSU返信の受信機ID（すなわち、それは、要求の送信者への応答をユニキャストしなければならない）としてCSUリクエストで送信者IDを使用しなければなりません。 LSはすべて0xFFsレシーバーIDにCSUリクエストを送信したい場合、それはタイムアウトを作成して、CSUリクエストを送信する前に、接続をポイントツーマルチポイントの葉あるのDCSごとにタイマーを再送信しなければなりません。この場合には、タイムアウトおよび再送信タイマーが前に与えられたCSAのレコードの確認に与えられたDCSのための有効期限が切れた場合、LSは、レシーバIDではなく、すべての0xFFsレシーバIDとして特定DCSIDを使用しなければなりません。それは再送信CSA記録する必要がある場合も同様に、その後、LSはなく、すべての0xFFsレシーバIDより受信IDとして特定DCSIDを指定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that if a set of servers are in a full mesh of point to multipoint connections, and one server of that mesh sends a CSU Request into that full mesh, and the sending server sends the CSA Records in the CSU Request to the all 0xFFs Receiver ID then it would not be necessary for every other server in the mesh to source their own CSU Request containing those CSA Records into the mesh in order to properly flood the CSA Records. This is because every server in the mesh would have heard the CSU Request and would have processed the included CSA Records as appropriate. Thus, a server in a full mesh could consider the mesh to be a single logical port and so the rule that \"when an LS receives a CSA record from a DCS, that LS floods the CSA Record to every DCS except the DCS from which it was received\" is not broken. A receiving server in the full mesh would still need to acknowledge the CSA records with CSU Reply messages which contain the LSID of the replying server as the Sender ID and the ID of the server which sent the CSU Request as the Receiver ID field. In the time out and retransmit case, the Receiver ID of the CSU Request would be set to the specific DCSID which did not acknowledge the CSA Record (as opposed to the all 0xFFs Receiver ID). Since a full mesh emulates a broadcast media for the servers attached to the full mesh, use of SCSP on a broadcast medium might use this technique as well. Further discussion of this use of a full mesh or use of a broadcast media is left to the client/server protocol specific documents.",
      "ja": "一連のサーバーが接続をポイントツーマルチポイントのフルメッシュであり、そのメッシュの1台のサーバがそのフルメッシュにCSUリクエストを送信し、送信側のサーバーはすべて0xFFs ReceiverにCSU RequestにCSAのレコードを送信する場合がありますメッシュ内の他のすべてのサーバーが正しくCSAレコードをあふれさせるためにメッシュにそれらのCSAのレコードを含む、独自のCSUリクエストを調達するためのIDは、それが必要ではないでしょう。メッシュ内のすべてのサーバは、CSUリクエストを聞いたことがあるでしょうし、必要に応じて含まCSAレコードを処理していたからです。このように、フルメッシュ内のサーバーは、それはLS、単一の論理ポートとそのLSがDCSからCSAレコードを受け取る」というルールであることをメッシュを検討することもでき、それから、DCSを除くすべてのDCSへのCSAのレコードをフラッディング」壊れていない受信されました。フルメッシュでの受信サーバは、まだ送信者IDとして返信するサーバーのLSIDとレシーバIDフィールドとしてCSUリクエストを送信し、サーバーのIDを含むメッセージを返信CSUとCSAレコードを確認する必要があります。タイムアウトと再送信の場合、CSUリクエストの受信側IDは、CSAレコード（すべて0xFFsレシーバIDとは反対に）認めていなかった特定のDCSIDに設定されます。フルメッシュがフルメッシュに接続されたサーバのための放送メディアをエミュレートしているので、放送媒体上SCSPの使用は、同様にこの技術を使用することがあります。フルメッシュや放送メディアの使用この使用のさらなる議論は、クライアント/サーバプロトコル特定の文書に残されています。"
    },
    {
      "indent": 0,
      "text": "2.4 The meaning of \"More Up To Date\"/\"Newness\"",
      "section_title": true,
      "ja": "2.4「より最新の状態」/「新しさ」の意味に"
    },
    {
      "indent": 3,
      "text": "During the cache alignment process and during normal CSU processing, a CSAS Record is compared against the contents of an LS's cache entry to decide whether the information contained in the record is more \"up to date\" than the corresponding cache entry of the LS.",
      "ja": "キャッシュ整列プロセス中及び通常のCSU処理中、CSASレコードは、レコードに含まれる情報は、よりLSの対応するキャッシュエントリより「最新」であるか否かを決定するLSのキャッシュ・エントリのコンテンツと比較されます。"
    },
    {
      "indent": 3,
      "text": "There are three pieces of information which are used in determining whether a record contains information which is more \"up to date\" than the information contained in the cache entry of an LS which is processing the record: 1) the Cache Key, 2) the Originator which is described by an Originator ID (OID), and 3) the CSA Sequence number. See Section B.2.0.2 for more information on these fields.",
      "ja": "レコードは、レコードを処理しているLSのキャッシュエントリーに含まれる情報よりも多くの「最新」である情報が含まれているかどうかを決定する際に使用されている3件の情報があります：1）キャッシュキー、2）オリジネータID（OID）、および3）CSAシーケンス番号で記述される発信。これらのフィールドの詳細については、セクションB.2.0.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Given these three pieces of information, a CSAS record (be it part of a CSA Record or be it stand-alone) is considered to be more \"up to date\" than the information contained in the cache of an LS if all of the following are true:",
      "ja": "これら3件の情報が与えられ、CSAS記録が（それはCSA記録の一部であるか、またはそれはスタンドアローンも）次のすべての場合はLSのキャッシュに含まれている情報よりも、「最新に」もっとあると考えられています真であります："
    },
    {
      "indent": 5,
      "text": "1) The Cache Key in the CSAS Record matches the stored Cache Key in the LS's cache entry, 2) The OID in the CSAS Record matches the stored OID in the LS's cache entry, 3) The CSA Sequence Number in the CSAS Record is greater than CSA Sequence Number in the LS's cache entry.",
      "ja": "1）CSAS録音でのキャッシュのキーは、LSのキャッシュエントリに保存されたキャッシュキーに一致する2）CSASレコード内のOIDは3）CSASレコードにCSAシーケンス番号が大きい、LSのキャッシュエントリーに保存されているOIDと一致しましたLSのキャッシュエントリーにおけるCSAのシーケンス番号より。"
    },
    {
      "indent": 0,
      "text": "Discussion and Conclusions",
      "ja": "考察と結論"
    },
    {
      "indent": 3,
      "text": "While the above text is couched in terms of synchronizing the knowledge of the state of a client within the cache of servers contained in a SG, this solution generalizes easily to any number of database synchronization problems (e.g., LECS synchronization).",
      "ja": "上記テキストがSGに含まれるサーバのキャッシュ内にクライアントの状態の知識を同期させるという観点で表現されているが、この解決策は、データベース同期の問題（例えば、LECS同期）の任意の数に容易に一般化します。"
    },
    {
      "indent": 3,
      "text": "SCSP defines a generic flooding protocol. There are a number of related issues relative to cache maintenance and topology maintenance which are more appropriately defined in the client/server protocol specific documents; for example, it might be desirable to define a generic cache entry time-out mechanism for a given protocol or to advertise adjacency information between servers so that one could obtain a topo-map of the servers in a SG. When mechanisms like these are desirable, they will be defined in the client/server protocol specific documents.",
      "ja": "SCSPは、一般的なフラッディングプロトコルを定義します。より適切にクライアント/サーバプロトコル特定のドキュメントで定義されているキャッシュのメンテナンスやトポロジのメンテナンスに対する関連する問題がいくつかあります。例えば、与えられたプロトコルのための一般的なキャッシュエントリのタイムアウトメカニズムを定義するために、または1つが、SG内のサーバーのトポマップを得ることができるように、サーバー間で隣接情報を広告することが望ましいかもしれません。このようなメカニズムが望まれているとき、彼らは、特定のドキュメントのクライアント/サーバプロトコルで定義されます。"
    },
    {
      "indent": 0,
      "text": "Appendix A: Terminology and Definitions",
      "ja": "付録A：用語と定義"
    },
    {
      "indent": 3,
      "text": "CA Message - Cache Alignment Message These messages allow an LS to synchronize its entire cache with that of the cache of one of its DCSs.",
      "ja": "CAメッセージ - キャッシュアラインメントメッセージこれらのメッセージは、LSがそののDCSの1のキャッシュのものと全体のキャッシュを同期することができます。"
    },
    {
      "indent": 3,
      "text": "CAFSM - Cache Alignment Finite State Machine The CAFSM monitors the state of the cache alignment between an LS and a particular DCS. There exists one CAFSM per DCS as seen from an LS.",
      "ja": "CAFSM  - キャッシュアラインメント有限状態機械ザCAFSMはLSと特定のDCSとの間のキャッシュ整列の状態を監視します。 LSから見たDCSにつき1 CAFSMが存在します。"
    },
    {
      "indent": 3,
      "text": "CSA Record - Cache State Advertisement Record A CSA is a record within a CSU message which identifies an update to the status of a \"particular\" cache entry.",
      "ja": "CSA録音 - キャッシュステート広告録音A CSA「は、特定の」キャッシュエントリの状態に更新を特定CSUメッセージ内のレコードです。"
    },
    {
      "indent": 3,
      "text": "CSAS Record - Cache State Advertisement Summary Record A CSAS contains a summary of the information in a CSA. A server will send CSAS records describing its cache entries to another server during the cache alignment process. CSAS records are also included in a CSUS messages when an LS wants to request the entire CSA from the DCS. The LS is requesting the CSA from the DCS because the LS believes that the DCS has a more recent view of the state of the cache entry in question.",
      "ja": "CSASレコード - キャッシュ状態アドバタイズメントの概要レコードのA CSASはCSA内の情報の要約が含まれています。サーバーは、キャッシュ整列プロセス中に別のサーバーにそのキャッシュエントリを記述したCSASレコードを送信します。 LSがDCSから全体CSAを要求したい場合CSASレコードもCSUSメッセージに含まれています。 LSがDCSは、当該キャッシュエントリの状態のより最近のビューを持っていると信じているので、LSがDCSからCSAを要求しています。"
    },
    {
      "indent": 3,
      "text": "CSU Message - Cache State Update message This is a message sent from an LS to its DCSs when the LS becomes aware of a change in state of a cache entry.",
      "ja": "CSUメッセージ -  LSは、キャッシュエントリの状態の変化に気付いたときに、このキャッシュ州Updateメッセージは、そののDCSへのLSから送信されたメッセージです。"
    },
    {
      "indent": 3,
      "text": "CSUS Message - Cache State Update Solicit Message This message is sent by an LS to its DCS after the LS and DCS have exchanged CA messages. The CSUS message contains one or more CSAS records which represent solicitations for entire CSA records (as opposed to just the summary information held in the CSAS).",
      "ja": "CSUSメッセージ -  LSとDCSは、CAメッセージを交換した後にキャッシュの状態更新要請メッセージこのメッセージは、そのDCSにLSによって送信されます。 CSUSメッセージは、（CSASに保持されているだけで、要約情報とは対照的に）全体のCSAレコードの勧誘を表す1つの以上のCSASのレコードを含みます。"
    },
    {
      "indent": 3,
      "text": "DCS - Directly Connected Server The DCS is a server which is directly connected to the LS; e.g., there exists a VC between the LS and DCS. This term, along with the terms LS and RS, is used to give a frame of reference when talking about servers and their synchronization. Unless explicitly stated to the contrary, there is no implied difference in functionality between a DCS, LS, and RS.",
      "ja": "DCS  - 直接接続されたサーバは、DCSは直接LSに接続されたサーバです。例えば、LSとDCSの間のVCが存在します。この用語は、用語のLSとRSと一緒に、サーバーとその同期の話をするときの参照のフレームを与えるために使用されます。明示的に反対の記述がない限り、DCS、LS、RSとの間の機能には暗黙の違いはありません。"
    },
    {
      "indent": 3,
      "text": "HFSM - Hello Finite State Machine An LS has a HFSM associated with each of its DCSs. The HFSM monitors the state of the connectivity between the LS and a particular DCS.",
      "ja": "HFSM  - こんにちは、有限状態機械アンLSは、そののDCSのそれぞれに関連するHFSMを持っています。 HFSMは​​LSと特定のDCSとの間の接続の状態を監視します。"
    },
    {
      "indent": 3,
      "text": "LS - Local Server The LS is the server under scrutiny; i.e., all statements are made from the perspective of the LS. This term, along with the terms DCS and RS, is used to give a frame of reference when talking about servers and their synchronization. Unless explicitly stated to the contrary, there is no implied difference in functionality between a DCS, LS, and RS.",
      "ja": "LS  - ローカルサーバLSは精査の下でサーバです。すなわち、すべてのステートメントは、LSの観点から作られています。この用語は、用語のDCSとRSと一緒に、サーバーとその同期の話をするときの参照のフレームを与えるために使用されます。明示的に反対の記述がない限り、DCS、LS、RSとの間の機能には暗黙の違いはありません。"
    },
    {
      "indent": 3,
      "text": "LSID - Local Server ID The LSID is a unique token that identifies an LS. This value might be taken from the protocol address of the LS.",
      "ja": "LSID  - ローカルサーバIDザ・LSIDはLSを識別する一意のトークンです。この値は、LSのプロトコルアドレスから取得される可能性があります。"
    },
    {
      "indent": 3,
      "text": "PID - Protocol ID This field contains an identifier which identifies the client/server protocol which is making use of SCSP for the given message. The assignment of Protocol IDs for this field is given over to IANA as described in Section C.",
      "ja": "PID  - プロトコルIDこのフィールドは、指定されたメッセージのSCSPを利用しているクライアント/サーバプロトコルを識別する識別子を含みます。セクションC.で説明したようにこのフィールドのためのプロトコルIDの割り当てはIANAに上に与えられ"
    },
    {
      "indent": 3,
      "text": "RS - Remote Server (RS) From the perspective of an LS, an RS is a server, separate from the LS, which is not directly connected to the LS (i.e., an RS is always two or more hops away from an LS whereas a DCS is always one hop away from an LS). Unless otherwise stated an RS refers to a server in the SG. This term, along with the terms LS and DCS, is used to give a frame of reference when talking about servers and their synchronization. Unless explicitly stated to the contrary, there is no implied difference in functionality between a DCS, LS, and RS.",
      "ja": "RS  -  LSの観点からリモートサーバー（RS）、RS直接LSに接続されていないLSから別のサーバーには、（すなわち、RSが離れ、一方、LSから常に2つの以上のホップですDCSは、1つのホップLSから）常にあります。それ以外の場合はRSを明記しない限りSGでサーバを指します。この用語は、用語のLSとDCSと一緒に、サーバーとその同期の話をするときの参照のフレームを与えるために使用されます。明示的に反対の記述がない限り、DCS、LS、RSとの間の機能には暗黙の違いはありません。"
    },
    {
      "indent": 3,
      "text": "SG - Server Group The SCSP synchronizes caches (or a portion of the caches) of a set of server entities which are bound to a SG through some means (e.g., all servers belonging to a Logical IP Subnet (LIS)[1]). Thus an SG is just a grouping of servers around some commonality.",
      "ja": "SG  - サーバーグループについてSCSPは、何らかの手段を通じてSGにバインドされているサーバーのエンティティのセットのキャッシュ（または、キャッシュの一部）を同期させる（例えば、論理IPサブネット（LIS）に属するすべてのサーバー[1]）。したがって、SGはいくつかの共通点の周りのサーバだけのグループです。"
    },
    {
      "indent": 3,
      "text": "SGID - Server Group ID This ID is a 16 bit identification field that uniquely identifies the instance client/server protocol for which the servers of the SG are being synchronized. This implies that multiple instances of the same protocol may be in operation at the same time and have their servers synchronized independently of each other.",
      "ja": "SGID  - サーバグループIDこのIDは一意にSGのサーバが同期されているインスタンス・クライアント/サーバプロトコルを識別する16ビットの識別フィールドです。これは、同じプロトコルの複数のインスタンスを同時に操作であってもよく、それらのサーバは互いに独立して同期していることを意味します。"
    },
    {
      "indent": 0,
      "text": "Appendix B: SCSP Message Formats",
      "ja": "付録B：SCSPメッセージ形式"
    },
    {
      "indent": 3,
      "text": "This section of the appendix includes the message formats for SCSP. SCSP protocols are LLC/SNAP encapsulated with an LLC=0xAA-AA-03 and OUI=0x00-00-5e and PID=0x00-05.",
      "ja": "付録のこのセクションでは、SCSPのためのメッセージフォーマットを含んでいます。 SCSPプロトコルは、LLC = 0xAAを-AA-03およびOUI = 0x00-00-5eとPID = 0x00-05でカプセル化LLC / SNAPです。"
    },
    {
      "indent": 3,
      "text": "SCSP has 3 parts to every packet: the fixed part, the mandatory part, and the extensions part. The fixed part of the message exists in every packet and is shown below. The mandatory part is specific to the particular message type (i.e., CA, CSU Request/Reply, Hello, CSUS) and, it includes (among other packet elements) a Mandatory Common Part and zero or more records each of which contains information pertinent to the state of a particular cache entry (except in the case of a Hello message) whose information is being synchronized within a SG. The extensions part contains the set of extensions for the SCSP message.",
      "ja": "固定部分、必須部分、および拡張部分：SCSPはパケットごとに3つの部分があります。メッセージの固定部分は、すべてのパケットに存在し、以下に示されています。必須部分は、必須の共通部分とに関連する情報が含まれている各々がゼロ以上のレコードが（他のパケットの要素のうち）を含む、特定のメッセージタイプ（すなわち、CA、CSUリクエスト/応答、ハロー、CSUS）に特異的であり情報SG内に同期されている（Helloメッセージの場合を除いて）特定のキャッシュ・エントリの状態。拡張部分は、SCSPメッセージの拡張セットが含まれています。"
    },
    {
      "indent": 3,
      "text": "In the following message formats, the fields marked as \"unused\" MUST be set to zero upon transmission of such a message and ignored upon receipt of such a message.",
      "ja": "次のメッセージの形式で、「未使用」とマークされたフィールドは、メッセージの送信時にゼロに設定しなければならなくて、このようなメッセージの受信時には無視されます。"
    },
    {
      "indent": 0,
      "text": "B.1 Fixed Part",
      "ja": "B.1固定部"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Version    |  Type Code    |        Packet Size            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Checksum             |      Start Of Extensions      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Version This is the version of the SCSP protocol being used. The current version is 1.",
      "ja": "バージョンは、これはSCSPプロトコルのバージョンが使用されています。現在のバージョンは1です。"
    },
    {
      "indent": 3,
      "text": "Type Code This is the code for the message type (e.g., Hello (5), CSU Request(2), CSU Reply(3), CSUS (4), CA (1)).",
      "ja": "このタイプのコードは、メッセージタイプのコードである（例えば、ハロー（5）、CSUリクエスト（2）、CSU返信（3）、CSUS（4）、CA（1））。"
    },
    {
      "indent": 3,
      "text": "Packet Size The total length of the SCSP packet, in octets (excluding link layer and/or other protocol encapsulation).",
      "ja": "（リンク層及び/又は他のプロトコルカプセル化を除く）オクテットのパケットサイズSCSPパケットの全長。"
    },
    {
      "indent": 3,
      "text": "Checksum The standard IP checksum over the entire SCSP packet starting at the fixed header. If the packet is an odd number of bytes in length then this calculation is performed as if a byte set to 0x00 is appended to the end of the packet.",
      "ja": "チェックサム固定ヘッダから始まる全体SCSPパケットにわたって標準IPチェックサム。パケットの長さがバイト数が奇数である場合には0x00に設定されたバイトは、パケットの最後に付加されているかのように、この計算が行われます。"
    },
    {
      "indent": 3,
      "text": "Start Of Extensions This field is coded as zero when no extensions are present in the message. If extensions are present then this field will be coded with the offset from the top of the fixed header to the beginning of the first extension.",
      "ja": "何の拡張子がメッセージ内に存在しない場合の拡張機能の開始は、このフィールドはゼロとして符号化されます。拡張機能が存在している場合、このフィールドは、最初の拡張の先頭に固定されたヘッダの先頭からのオフセットを用いて符号化されます。"
    },
    {
      "indent": 0,
      "text": "B.2.0 Mandatory Part",
      "ja": "B.2.0必須パート"
    },
    {
      "indent": 3,
      "text": "The mandatory part of the SCSP packet contains the operation specific information for a given message type (e.g., SCSP Cache State Update Request/Reply, etc.), and it includes (among other packet elements) a Mandatory Common Part (described in Section B.2.0.1) and zero or more records each of which contains information pertinent to the state of a particular cache entry (except in the case of a Hello message) whose information is being synchronized within a SG. These records may, depending on the message type, be either Cache State Advertisement Summary (CSAS) Records (described in Section B.2.0.2) or Cache State Advertisement (CSA) Records (described in Section B.2.2.1). CSA Records contain a summary of a cache entry's information (i.e., a CSAS Record) plus some additional client/server protocol specific information. The mandatory common part format and CSAS Record format is shown immediately below, prior to showing their use in SCSP messages, in order to prevent replication within the message descriptions.",
      "ja": "セクションBに記載SCSPパケットの必須の部分（他のパケット要素間）特定のメッセージ・タイプ（例えば、SCSPキャッシュ状態更新要求/応答、等）のための操作固有の情報が含まれ、それが含む必須共通部（ .2.0.1）情報SG内に同期されているHelloメッセージの場合を除き、特定のキャッシュ・エントリ（）の状態に関連する情報が含まれている各々がゼロ以上のレコード。これらのレコードは、メッセージの種類に応じて、どちらかのことかもしれキャッシュ状態アドバタイズメントの概要（CSAS）レコード（セクションB.2.0.2を参照）またはキャッシュ状態アドバタイズメント（セクションB.2.2.1で説明）（CSA）のレコード。 CSAレコードは、キャッシュエントリの情報の要約（すなわち、CSASレコード）に加えて、いくつかの追加のクライアント/サーバプロトコル固有の情報が含まれています。必須の共通部分フォーマットとCSASレコードフォーマットは、メッセージ記述内複製を防止するために、前SCSPメッセージにおけるそれらの使用を示すために、すぐ下に示されます。"
    },
    {
      "indent": 0,
      "text": "B.2.0.1 Mandatory Common Part",
      "ja": "B.2.0.1必須共通パート"
    },
    {
      "indent": 3,
      "text": "Sections B.2.1 through B.2.5 have a substantial overlap in format. This overlapping format is called the mandatory common part and its format is shown below:",
      "ja": "B.2.5介しB.2.1のセクションでは、フォーマットの実質的な重複を有します。このオーバーラップ形式は必須共通部分と呼ばれ、そのフォーマットを以下に示します。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Protocol ID           |        Server Group ID        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            unused             |             Flags             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Sender ID Len | Recvr ID Len  |       Number of Records       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  Sender ID (variable length)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Receiver ID (variable length)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Protocol ID This field contains an identifier which identifies the client/server protocol which is making use of SCSP for the given message. The assignment of Protocol IDs for this field is given over to IANA as described in Section C. Protocols with current documents have the following defined values:",
      "ja": "プロトコルIDこのフィールドは、指定されたメッセージのSCSPを利用しているクライアント/サーバプロトコルを識別する識別子を含みます。現在の文書で、セクションC.プロトコルで説明したように、この分野のプロトコルIDの割り当てはIANAにオーバー与えられ、次のように定義された値を持っています："
    },
    {
      "indent": 7,
      "text": "1 - ATMARP\n2 - NHRP\n3 - MARS\n4 - DHCP\n5 - LNNI",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Server Group ID This ID is uniquely identifies the instance of a given client/server protocol for which servers are being synchronized.",
      "ja": "サーバーグループIDこのIDは一意のサーバーが同期されているかのために与えられたクライアント/サーバプロトコルのインスタンスを識別しています。"
    },
    {
      "indent": 3,
      "text": "Flags The Flags field is message specific, and its use will be described in the specific message format sections below.",
      "ja": "フラグのフラグフィールドは、メッセージ特異的であり、その使用は以下の特定のメッセージフォーマットのセクションで説明します。"
    },
    {
      "indent": 3,
      "text": "Sender ID Len This field holds the length in octets of the Sender ID.",
      "ja": "送信者IDレンは、このフィールドには、Sender IDのオクテットの長さを保持しています。"
    },
    {
      "indent": 3,
      "text": "Recvr ID Len This field holds the length in octets of the Receiver ID.",
      "ja": "Recvr IDレンは、このフィールドは、受信側IDのオクテットの長さを保持しています。"
    },
    {
      "indent": 3,
      "text": "Number of Records This field contains the number of additional records associated with the given message. The exact format of these records is specific to the message and will be described for each message type in the sections below.",
      "ja": "レコード数は、このフィールドには、与えられたメッセージに関連する追加のレコード数が含まれています。これらのレコードの正確なフォーマットは、メッセージに固有のものであり、以下のセクションで、各メッセージタイプに対して説明します。"
    },
    {
      "indent": 3,
      "text": "Sender ID This is an identifier assigned to the server which is sending the given message. One possible assignment might be the protocol address of the sending server.",
      "ja": "この送信者IDは、与えられたメッセージを送信しているサーバに割り当てられた識別子です。一つの可能​​な割り当ては、送信側サーバーのプロトコルアドレスであるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Receiver ID This is an identifier assigned to the server which is to receive the given message. One possible assignment might be the protocol address of the server which is to receive the given message.",
      "ja": "受信機IDは、これは、与えられたメッセージを受信することでサーバーに割り当てられた識別子です。一つの可能​​な割り当ては、与えられたメッセージを受信するサーバのプロトコル・アドレスであるかもしれません。"
    },
    {
      "indent": 0,
      "text": "B.2.0.2 Cache State Advertisement Summary Record (CSAS record)",
      "ja": "B.2.0.2キャッシュステート広告要約レコード（CSASレコード）"
    },
    {
      "indent": 3,
      "text": "CSAS records contain a summary of information contained in a cache entry of a given client/server database which is being synchronized through the use of SCSP. The summary includes enough information for SCSP to look into the client/server database for the appropriate database cache entry and then compare the \"newness\" of the summary against the \"newness\" of the cached entry.",
      "ja": "CSAS記録はSCSPを使用して同期されている特定のクライアント/サーバー・データベースのキャッシュエントリに含まれている情報の要約が含まれています。概要はSCSPが適切なデータベースキャッシュエントリのクライアント/サーバー・データベースに見て、その後、キャッシュされたエントリの「新しさ」に対する要約の「新しさ」を比較するための十分な情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "Note that CSAS records do not contain a Server Group ID (SGID) nor do they contain a Protocol ID. These IDs are necessary to identify which protocol and which instance of that protocol for which the summary is applicable. These IDs are present in the mandatory common part of each message.",
      "ja": "CSAS記録がサーバーグループID（SGID）が含まれていないないし、プロトコルIDが含まれていないことに注意してください。これらのIDは、どのプロトコルと要約が適用されるため、そのプロトコルのどのインスタンスを識別するために必要です。これらのIDは、各メッセージの必須の共通部分に存在しています。"
    },
    {
      "indent": 3,
      "text": "Note also that the values of the Hop Count and Record Length fields of a CSAS Record are dependent on whether the CSAS record exists as a \"stand-alone\" record or whether the CSAS record is \"embedded\" in CSA Record. This is further described below.",
      "ja": "ホップカウントとCSASレコードのレコード長フィールドの値がCSAS記録が「スタンドアローン」レコードとしてまたはCSAS記録がCSA録音中に「埋め込まれた」されているかどうかが存在するかどうかに依存していることにも注意してください。これは、以下でさらに説明します。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Hop Count           |        Record Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Cache Key Len |  Orig ID Len  |N|          unused             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       CSA Sequence Number                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Cache Key  ...                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Originator ID   ...                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Hop Count This field represents the number of hops that the record may take before being dropped. Thus, at each server that the record traverses, the Hop Count is decremented. This field is set to 1 when the CSAS record is a \"stand-alone\" record (i.e., it is not embedded within a CSA record) since summaries do not go beyond one hop during the cache alignment process. If a CSAS record is \"embedded\" within a CSA record then the Hop Count is set to an administratively defined value which is almost certainly greater than or equal to the the cardinality of the SG minus one. Note that an exception to the previous rule occurs when the CSA Record is carried within a CSU Request which was sent in response to a solicitation (i.e., in response to a CSAS Record which was sent in a CSUS message); in which case, the Hop Count SHOULD be set to 1.",
      "ja": "ホップは、このフィールドは、レコードが削除される前に取ることのホップ数を表してカウントします。したがって、レコードが通過する各サーバーで、ホップ数が減少されます。このフィールドは、要約はキャッシュ整列プロセス中に1つのホップを超えていないので、CSAS記録は、「スタンドアローン」のレコード（すなわち、それはCSAレコード内に埋め込まれていない）であるとき、1に設定されています。 CSASレコードがCSAレコード内の「組み込み」である場合、ホップカウントがほぼ確実以上SGマイナス1のカーディナリティに等しい管理定義された値に設定されています。 CSAレコードが勧誘に応答して送信されたCSUリクエスト内で実行されるときに、前の規則の例外が発生することに留意されたい（すなわち、CSUSメッセージで送信されたCSASレコードに応答して）。その場合には、ホップ数が1に設定されるべきです。"
    },
    {
      "indent": 3,
      "text": "Record Length If the CSAS record is a \"stand-alone\" record then this value is 12+\"Cache Key Leng\"+\"Orig ID Len\" in bytes; otherwise, this value is set to 12+\"Cache Key Leng\"+\"Orig ID Len\"+ sizeof(\"Client/Server Protocol Specific Part for cache entry\"). The size of the Client/Server Protocol Specific Part may be obtained from the client/server protocol specific document for the given Protocol ID.",
      "ja": "レコード長CSAS記録は、「スタンドアローン」のレコードである場合、この値はバイト単位で12+「キャッシュキーレン」+「ORIG IDレン」です。そうでない場合は、この値は「キャッシュキーレン」+「ORIG IDレン」+はsizeof（「キャッシュエントリのためのクライアント/サーバプロトコル特定の部分」）12+に設定されています。クライアント/サーバプロトコル特定の部分の大きさは、与えられたプロトコルIDのためのクライアント/サーバプロトコル特定の文書から得ることができます。"
    },
    {
      "indent": 3,
      "text": "Cache Key Len Length of the Cache Key field in bytes.",
      "ja": "バイト単位でのキャッシュのキーフィールドのキャッシュキーレンの長さ。"
    },
    {
      "indent": 3,
      "text": "Orig ID Len. Length of the Originator ID field in bytes.",
      "ja": "ORIG IDレン。バイト単位のオリジネータIDフィールドの長さ。"
    },
    {
      "indent": 3,
      "text": "N The \"N\" bit signifies that this CSAS Record is actually a Null record. This bit is only used in a CSAS Record contained in a CSU Request/Reply which is sent in response to a CSUS message. It is possible that an LS may receive a solicitation for a CSA record when the cache entry represented by the solicited CSA Record no longer exists in the LS's cache (see Section 2.3 for details). In this case, the LS copies the CSAS Record directly from the CSUS message into the CSU Request, and the LS sets the N bit signifying that the cache entry does not exist any longer. The DCS which solicited the CSA record which no longer exists will still respond with a CSU Reply. This bit is usually set to zero.",
      "ja": "N「N」ビットは、このCSAS録音が実際にヌルレコードであることを意味します。このビットは、CSUリクエストに含まCSAS記録にのみ使用されている/ CSUSメッセージに応答して送信された返信。 LSが募っCSAのレコードによって表されるキャッシュエントリはもはや（詳細は2.3節を参照）LSのキャッシュに存在しているCSAレコードの勧誘を受けることが可能です。この場合、LSコピーCSUリクエストにCSUSメッセージから直接CSAS記録し、LSは、キャッシュ・エントリがもはや存在しないことを意味するNビットをセットします。もはや、まだCSU返信で応答しますが存在するCSAレコードを募集DCS。このビットは、通常はゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "CSA Sequence Number This field contains a sequence number that identifies the \"newness\" of a CSA record instance being summarized. A \"larger\" sequence number means a more recent advertisement. Thus, if the state of part (or all) of a cache entry needs to be updated then the CSA record advertising the new state MUST contain a CSA Sequence Number which is larger than the one corresponding to the previous advertisement. This number is assigned by the originator of the CSA record. The CSA Sequence Number may be assigned by the originating server or by the client which caused its server to advertise its existence.",
      "ja": "CSAシーケンス番号このフィールドは、要約されているCSAレコードインスタンスの「新しさ」を特定するシーケンス番号が含まれています。 「大きな」シーケンス番号は、より最近の広告を意味します。したがって、場合キャッシュエントリの一部（または全部）の状態が新しい状態を宣伝CSAレコードは、前の広告に対応するものよりも大きくなっているCSAシーケンス番号を含まなければならない、更新する必要があります。この番号は、CSAレコードの創始者によって割り当てられます。 CSAシーケンス番号は、発信サーバーまたはそのサーバーがその存在を通知させ、クライアントによって割り当てすることができます。"
    },
    {
      "indent": 5,
      "text": "The CSA Sequence Number is a signed 32 bit number. Within the CSA Sequence Number space, the number -2^31 (0x80000000) is reserved. Thus, the usable portion of the CSA Sequence Number space for a given Cache Key is between the numbers -2^31+1 (0x80000001) and 2^31-1 (0x7fffffff). An LS uses -2^31+1 the first time it originates a CSA Record for a cache entry that it created. Each time the cache entry is modified in some manner and when that modification needs to be synchronized with the other servers in the SG, the LS increments the CSA Sequence number associated with the given Cache Key and uses that new CSA Sequence Number when advertising the update. If it is ever the case that a given CSA Sequence Number has reached 2^31-2 and the associated cache entry has been modified such that an update must be sent to the rest of the servers in the SG then the given cache entry MUST first be purged from the SG by the LS by sending a CSA Record which causes the cache entry to be removed from other servers and this CSA Record carries a CSA Sequence Number of 2^31-1. The exact packet format and mechanism by which a cache entry is purged is defined in the appropriate protocol specific document. After the purging CSA Record has been acknowledged by each DCS, an LS will then send a new CSA Record carrying the updated information, and this new CSA Record will carry a CSA Sequence Number of -2^31+1.",
      "ja": "CSAのシーケンス番号は、符号付き32ビット数です。 CSAシーケンス番号空間内に、数-2 ^ 31（0x80000000の）予約されています。したがって、所与のキャッシュキーのCSAシーケンス番号空間の使用可能な部分は、数字-2 ^ 31 + 1（0x80000001）と2 ^ 31-1（0x7FFFFFFFで）の間です。 LSは、使用-2 ^ 31 + 1、それが作成されたキャッシュエントリのCSAレコードを発信初めて。キャッシュエントリが何らかの方法で変更され、その変更がSG内の他のサーバーと同期する必要がある場合に、LSが与えられたキャッシュキーに関連付けられているCSAのシーケンス番号をインクリメントし、更新を通知するときにその新しいCSAシーケンス番号を使用していますたびに。それは与えられたCSAのシーケンス番号が2 ^ 31-2と関連するキャッシュエントリに達した場合、これまでであれば更新はその後、SG内のサーバーの残りの部分に送られなければならないように修正された特定のキャッシュエントリ最初MUST他のサーバーから削除するキャッシュエントリを引き起こし、このCSAのレコードが2 ^ 31-1のCSAのシーケンス番号を運ぶCSAのレコードを送信することにより、LSでSGからパージします。キャッシュエントリがパージされる正確なパケットフォーマットおよび機構は、適切なプロトコル特有のドキュメントで定義されています。パージCSAレコードは、各DCSによって承認された後、LSは、その後の-2 ^ 31 + 1 CSAシーケンス番号を搬送する更新された情報を搬送する新たなCSAレコード、この新しいCSAレコードを送信します。"
    },
    {
      "indent": 5,
      "text": "After a restart occurs and after the restarting LS's CAFSM has achieved the Aligned state, if an update to an existing cache entry needs to be synchronized or a new cache entry needs to be synchronized then the ensuing CSA Record MUST contain a CSA Sequence Number which is unique within the SG for the given OID and Cache Key. The RECOMMENDED method of obtaining this number (unless explicitly stated to the contrary in the protocol specific document) is to set the CSA Sequence Number in the CSA Record to the CSA Sequence Number associated with the existing cache entry (if an out of date cache entry already exists and zero if not) plus a configured constant. Note that the protocol specific document may require that all cache entries containing the OID of the restarting LS be purged prior to updating the cache entries; in this case, the updating CSA Record will still contain a CSA Sequence Number set to the CSA Sequence Number associated with the previously existing cache entry plus a configured constant.",
      "ja": "再起動が発生すると、既存のキャッシュエントリへの更新を同期させる必要があるか、または新しいキャッシュエントリはその後、その後のCSAレコードがあるCSAシーケンス番号を含まなければならない同期させる必要がある場合は、再起動LSのCAFSM後、配向状態を達成した後、与えられたOIDとキャッシュキーのためのSG内で一意。 （明示的プロトコル特定文書に反する記載がない限り）、この番号を取得する推奨される方法は、（既存のキャッシュエントリに関連付けられたCSAのシーケンス番号にCSAレコードにCSAシーケンス番号を設定する場合、日付・キャッシュ・エントリのうちすでに存在し、ゼロでない場合）に加えて構成さ定数。プロトコル固有の文書が再起動LSのOIDを含むすべてのキャッシュエントリがキャッシュエントリを更新する前にパージされることを必要とするかもしれないことに注意してください。この場合には、更新CSAのレコードは、まだ既存のキャッシュエントリに加えて、設定済みの定数に関連付けられているCSAシーケンス番号に設定CSAのシーケンス番号が含まれています。"
    },
    {
      "indent": 3,
      "text": "Cache Key This is a database lookup key that uniquely identifies a piece of data which the originator of a CSA Record wishes to synchronize with its peers for a given \"Protocol ID/Server Group ID\" pair. This key will generally be a small opaque byte string which SCSP will associate with a given piece of data in a cache. Thus, for example, an originator might assign a particular 4 byte string to the binding of an IP address with that of an ATM address. Generally speaking, the originating server of a CSA record is responsible for generating a Cache Key for every element of data that the the given server originates and which the server wishes to synchronize with its peers in the SG.",
      "ja": "キャッシュキーは、これは一意にCSAのレコードの創始者は、与えられた「プロトコルID /サーバグループID」ペアのピアと同期したいデータの一部を識別し、データベースの検索キーです。このキーは、一般的にSCSPがキャッシュ内のデータの特定の部分に関連付けるだろう小さな不透明なバイトの文字列になります。したがって、例えば、発信者はATMアドレスのそれとIPアドレスの結合に特に4バイトの文字列を割り当てることができます。一般的に言って、CSAレコードの元のサーバーは、サーバーが希望する特定のサーバーの発信元とはSG内のピアと同期するデータのすべての要素のためのキャッシュキーを生成するための責任があります。"
    },
    {
      "indent": 3,
      "text": "Originator ID This field contains an ID administratively assigned to the server which is the originator of CSA Records.",
      "ja": "オリジネータIDこのフィールドは、管理CSAレコードの創始者であるサーバに割り当てられたIDが含まれています。"
    },
    {
      "indent": 0,
      "text": "B.2.1 Cache Alignment (CA)",
      "ja": "B.2.1キャッシュアラインメント（CA）"
    },
    {
      "indent": 3,
      "text": "The Cache Alignment (CA) message allows an LS to synchronize its entire cache with that of the cache of its DCSs within a server group. The CA message type code is 1. The CA message mandatory part format is as follows:",
      "ja": "キャッシュアライメント（CA）メッセージは、LSは、サーバグループ内ののDCSのキャッシュのものとその全体のキャッシュを同期化することを可能にします。 CAメッセージタイプコードCAメッセージ必須部分形式1である以下の通りであります："
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     CA  Sequence Number                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Mandatory Common Part                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          CSAS Record                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                             .......\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          CSAS Record                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "CA Sequence Number A value which provides a unique identifier to aid in the sequencing of the cache alignment process. A \"larger\" sequence number means a more recent CA message. The slave server always copies the sequence number from the master server's previous CA message into its current CA message which it is sending and the the slave acknowledges the master's CA message. Since the initial CA process is lock-step, if the slave does not receive the same sequence number which it previously received then the information in the slave's previous CA message is implicitly acknowledged. Note that there is a separate CA Sequence Number space associated with each CAFSM.",
      "ja": "CAシーケンス番号キャッシュ整列プロセスのシーケンシングを補助するためのユニークな識別子を提供する値。 「大きな」シーケンス番号は、より最近のCAメッセージを意味します。スレーブサーバは常にコピーし、それが送信されると、スレーブは、マスタのCAメッセージを認識し、現在のCAメッセージにマスターサーバーの以前のCAメッセージからシーケンス番号。初期CAプロセスがロックステップであるので、スレーブは、それが以前に受信した同一のシーケンス番号を受信しない場合、スレーブの以前のCAメッセージ内の情報は、暗黙的に認められています。各CAFSMに関連した別のCAのシーケンス番号空間があることに注意してください。"
    },
    {
      "indent": 5,
      "text": "Whenever it is necessary to (re)start cache alignment and the CAFSM enters the Master/Slave Negotiation state, the CA Sequence Number should be set to a value not previously seen by the DCS. One possible scheme is to use the machine's time of day counter.",
      "ja": "それはする必要があるたびに（再）キャッシュアライメントを開始しCAFSMは、CAのシーケンス番号が以前DCSによって見られていない値に設定する必要があり、マスター/スレーブネゴシエーション状態に入ります。一つの可能​​なスキームは、日カウンタのマシンの時間を使用することです。"
    },
    {
      "indent": 3,
      "text": "Mandatory Common Part The mandatory common part is described in detail in Section B.2.0.1. There are two fields in the mandatory common part whose codings are specific to a given message type. These fields are the \"Number of Records\" field and the \"Flags\" field.",
      "ja": "必須の共通部分は必須の共通部分は、セクションB.2.0.1に詳細に記載されています。コーディング与えられたメッセージのタイプに固有の必須の共通部分の2つのフィールドがあります。これらのフィールドは、フィールド「レコード数」と「フラグ」フィールドです。"
    },
    {
      "indent": 5,
      "text": "Number of Records The Number of Records field of the mandatory common part for the CA message gives the number of CSAS Records appended to the CA message mandatory part.",
      "ja": "レコード数は、CAメッセージのための必須の共通部分のレコードのフィールドの数は、CAメッセージの必須パートに添付さCSASレコードの数を示します。"
    },
    {
      "indent": 5,
      "text": "Flags The Flags field of the mandatory common part for the CA message has the following format:",
      "ja": "フラグは、CAメッセージのための必須の共通部分のFlagsフィールドの形式は次のとおりです。"
    },
    {
      "indent": 7,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|M|I|O|         unused          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "M This bit is part of the negotiation process for the cache alignment. When this bit is set then the sender of the CA message is indicating that it wishes to lead the alignment process. This bit is the \"Master/Slave bit\".",
      "ja": "Mこのビットは、キャッシュの位置合わせのための交渉プロセスの一部です。このビットが設定されているときにCAメッセージの送信者は、配向処理を導くことを望むことを示しています。このビットは、「マスター/スレーブビット」です。"
    },
    {
      "indent": 7,
      "text": "I When set, this bit indicates that the sender of the CA message believes that it is in a state where it is negotiating for the status of master or slave. This bit is the \"Initialization bit\".",
      "ja": "I設定されている場合、このビットは、CAメッセージの送信者は、それがマスタまたはスレーブの状態のために交渉された状態であると考えていることを示しています。このビットは、「初期化ビット」です。"
    },
    {
      "indent": 7,
      "text": "O This bit indicates that the sender of the CA message has more CSAS records to send. This implies that the cache alignment process must continue. This bit is the \"mOre bit\" despite its dubious name.",
      "ja": "Oこのビットは、CAメッセージの送信者が送信するためのより多くのCSAS記録を持っていることを示しています。これは、キャッシュ配向処理が継続しなければならないことを意味します。このビットは、その怪しげな名前にもかかわらず、「より少し」です。"
    },
    {
      "indent": 5,
      "text": "All other fields of the mandatory common part are coded as described in Section B.2.0.1.",
      "ja": "セクションB.2.0.1で説明したように義務的な共通部分の他のすべてのフィールドがコード化されています。"
    },
    {
      "indent": 3,
      "text": "CSAS record The CA message appends CSAS records to the end of its mandatory part. These CSAS records are NOT embedded in CSA records. See Section B.2.0.2 for details on CSAS records.",
      "ja": "CSAS記録は、CAメッセージは、その必須部分の最後にCSASレコードを追加します。これらのCSAS記録はCSAレコードに埋め込まれていません。 CSASレコードの詳細については、セクションB.2.0.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "B.2.2 Cache State Update Request (CSU Request)",
      "ja": "B.2.2キャッシュの状態更新要求（CSUリクエスト）"
    },
    {
      "indent": 3,
      "text": "The Cache State Update Request (CSU Request) message is used to update the state of cache entries in servers which are directly connected to the server sending the message. A CSU Request message is sent from one server (the LS) to directly connected server (the DCS) when the LS observes changes in the state of one or more cache entries. An LS observes such a change in state by either receiving a CSU request which causes an update to the LS's database or by observing a change of state of a cached entry originated by the LS. The change in state of a cache entry is noted in a CSU message by appending a \"Cache State Advertisement\" (CSA) record to the end of the mandatory part of the CSU Request as shown below.",
      "ja": "キャッシュの状態更新要求（CSU要求）メッセージが直接メッセージを送信するサーバに接続しているサーバにキャッシュエントリの状態を更新するために使用されます。 LSは、1つまたは複数のキャッシュ・エントリの状態の変化を観察するときCSU要求メッセージが一つのサーバ（LS）に直接接続するサーバ（DCS）から送られてきます。 LSは、LSのデータベースまたはLSによって発信キャッシュエントリの状態の変化を観察することによって更新を引き起こすCSU要求を受信するのいずれかによって状態のそのような変化を観察します。キャッシュ・エントリの状態の変化は、以下に示すように、CSUリクエストの必須の部分の末尾に「キャッシュステート広告」（CSA）レコードを追加することによって、CSUメッセージに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The CSU Request message type code is 2. The CSU Request message mandatory part format is as follows:",
      "ja": "CSU Requestメッセージタイプコードは、次のようにCSU Requestメッセージ必須部分形式は2です。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Mandatory Common Part                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         CSA Record                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                           .......\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         CSA Record                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Mandatory Common Part The mandatory common part is described in detail in Section B.2.0.1. There are two fields in the mandatory common part whose codings are specific to a given message type. These fields are the \"Number of Records\" field and the \"Flags\" field.",
      "ja": "必須の共通部分は必須の共通部分は、セクションB.2.0.1に詳細に記載されています。コーディング与えられたメッセージのタイプに固有の必須の共通部分の2つのフィールドがあります。これらのフィールドは、フィールド「レコード数」と「フラグ」フィールドです。"
    },
    {
      "indent": 5,
      "text": "Number of Records The Number of Records field of the mandatory common part for the CSU Request message gives the number of CSA Records appended to the CSU Request message mandatory part.",
      "ja": "レコード数CSU Requestメッセージに必須の共通部分のレコードのフィールドの数はCSU Requestメッセージの必須パートに追加CSAレコードの数を示します。"
    },
    {
      "indent": 5,
      "text": "Flags Currently, there are no flags defined for the Flags field of the mandatory common part for the CSU Request message.",
      "ja": "旗は現在、CSUリクエストメッセージのための必須の共通部分のFlagsフィールドに定義されたフラグはありません。"
    },
    {
      "indent": 5,
      "text": "All other fields of the mandatory common part are coded as described in Section B.2.0.1.",
      "ja": "セクションB.2.0.1で説明したように義務的な共通部分の他のすべてのフィールドがコード化されています。"
    },
    {
      "indent": 3,
      "text": "CSA Record See Section B.2.2.1.",
      "ja": "CSAのレコードは、セクションB.2.2.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "B.2.2.1 Cache State Advertisement Record (CSA record)",
      "ja": "B.2.2.1キャッシュステート広告レコード（CSAレコード）"
    },
    {
      "indent": 3,
      "text": "CSA records contain the information necessary to relate the current state of a cache entry in an SG to the servers being synchronized. CSA records contain a CSAS Record header and a client/server protocol specific part. The CSAS Record includes enough information for SCSP to look into the client/server database for the appropriate database cache entry and then compare the \"newness\" of the summary against the \"newness\" of the cached entry. If the information contained in the CSA is more new than the cached entry of the receiving server then the cached entry is updated accordingly with the contents of the CSA Record. The client/server protocol specific part of the CSA Record is documented separately for each such protocol. Examples of the protocol specific parts for NHRP and ATMARP are shown in [8] and [9] respectively.",
      "ja": "CSAレコードは同期され、サーバへのSGでキャッシュエントリの現在の状態を関連付けるために必要な情報が含まれています。 CSAレコードはCSASレコードヘッダおよびクライアント/サーバプロトコルの特定の部分が含まれています。 CSAS録音はSCSPが適切なデータベースキャッシュエントリのクライアント/サーバー・データベースに見て、その後、キャッシュされたエントリの「新しさ」に対する要約の「新しさ」を比較するための十分な情報が含まれています。 CSAに含まれる情報は、受信サーバのキャッシュされたエントリよりも新しいものである場合は、キャッシュされたエントリはCSAレコードの内容に応じて更新されます。クライアント/サーバプロトコルCSAレコードの特定の部分は、このような各プロトコルに対して別々に文書化されています。 NHRPとATMARPためのプロトコル特定部分の例は、[8]、[9]は、それぞれに示されています。"
    },
    {
      "indent": 3,
      "text": "The amount of information carried by a specific CSA record may exceed the size of a link layer PDU. Hence, such CSA records MUST be fragmented across a number of CSU Request messages. The method by which this is done, is client/server protocol specific and is documented in the appropriate protocol specific document.",
      "ja": "特定のCSAレコードによって搬送される情報の量は、リンク層PDUのサイズを超えることができます。したがって、そのようなCSAレコードはCSUリクエストメッセージの数を横切って断片化されなければなりません。これが行われることにより、この方法では、クライアント/サーバプロトコル固有のものであり、適切なプロトコル特定の文書に記載されています。"
    },
    {
      "indent": 3,
      "text": "The content of a CSA record is as follows:",
      "ja": "次のようにCSAレコードの内容は次のとおりです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          CSAS Record                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Client/Server Protocol Specific Part for cache entry ...    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "CSAS Record See Section B.2.0.2 for rules and format for filling out a CSAS Record when it is \"embedded\" in a CSA Record.",
      "ja": "CSASのレコードは、それがCSA録音中に「埋め込まれた」されたときにCSAS録音を記入するためのルールと形式については、セクションB.2.0.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Client/Server Protocol Specific Part for cache entry This field contains the fields which are specific to the protocol specific portion of SCSP processing. The particular set of fields are defined in separate documents for each protocol user of SCSP. The Protocol ID, which identifies which protocol is using SCSP in the given packet, is located in the mandatory part of the message.",
      "ja": "キャッシュエントリのためのクライアント/サーバプロトコル固有の部分は、このフィールドは、SCSP処理のプロトコル特定部分に固有のフィールドが含まれています。フィールドの特定のセットは、SCSPの各プロトコルをユーザのために別の文書で定義されています。所与のパケットにSCSPを使用しているプロトコルを識別するプロトコルIDは、メッセージの必須の部分に位置しています。"
    },
    {
      "indent": 0,
      "text": "B.2.3 Cache State Update Reply (CSU Reply)",
      "ja": "B.2.3キャッシュ州Update返信（CSU返信）"
    },
    {
      "indent": 3,
      "text": "The Cache State Update Reply (CSU Reply) message is sent from a DCS to an LS to acknowledge one or more CSA records which were received in a CSU Request. Reception of a CSA record in a CSU Request is acknowledged by including a CSAS record in the CSU Reply which corresponds to the CSA record being acknowledged. The CSU Reply message is the same in format as the CSU Request message except for the following: the type code is 3, only CSAS Records (rather than CSA records) are returned, and only those CSAS Records for which CSA Records are being acknowledged are returned. This implies that a given LS sending a CSU Request may not receive an acknowledgment in a single CSU Reply for all the CSA Records included in the CSU Request.",
      "ja": "キャッシュ状態更新応答（CSU応答）メッセージはCSU要求で受信した一つ以上のCSAレコードを確認するためにLSにDCSから送信されます。 CSUリクエストでCSAレコードの受信は、CSAレコードが確認されているに対応CSU返信でCSAS記録を含むことによって認められています。タイプコードが3である、（むしろCSAレコードより）のみCSASレコードが返され、CSAレコードは認められているだけCSAS記録するためのものである：以下を除いCSUリクエストメッセージは次のようにCSU Replyメッセージの形式は同じです戻ってきた。これは、CSUリクエストを送信して与えられたLSレコードがCSUリクエストに含まれるすべてのCSAのための単一のCSUの返信で確認を受けることができないことを意味します。"
    },
    {
      "indent": 0,
      "text": "B.2.4 Cache State Update Solicit Message (CSUS message)",
      "ja": "B.2.4キャッシュの状態更新要請メッセージ（CSUSメッセージ）"
    },
    {
      "indent": 3,
      "text": "This message allows one server (LS) to solicit the entirety of CSA record data stored in the cache of a directly connected server (DCS). The DCS responds with CSU Request messages containing the appropriate CSA records. The CSUS message type code is 4. The CSUS message format is the same as that of the CSU Reply message. CSUS messages solicit CSU Requests from only one server (the one identified by the Receiver ID in the Mandatory Part of the message).",
      "ja": "このメッセージは、一つのサーバ（LS）が直接接続されたサーバ（DCS）のキャッシュに格納されているCSAレコードデータの全体を求めることを可能にします。 DCSは、適切なCSAのレコードを含むCSUリクエストメッセージで応答します。 CSUSメッセージタイプコードはCSUSメッセージフォーマットは、CSU Replyメッセージと同じである4です。 CSUSメッセージは一つだけのサーバ（メッセージの必須部分にレシーバーIDで識別される1）からCSU要求を募ります。"
    },
    {
      "indent": 0,
      "text": "B.2.5 Hello:",
      "ja": "B.2.5こんにちは："
    },
    {
      "indent": 3,
      "text": "The Hello message is used to check connectivity between the sending server (the LS) and one of its directly connected neighbor servers (the DCSs). The Hello message type code is 5. The Hello message mandatory part format is as follows:",
      "ja": "Helloメッセージを送信し、サーバ（LS）と直接接続され、隣接サーバ（のDCS）のうちの1つとの間の接続性をチェックするために使用されます。 HelloメッセージタイプコードHelloメッセージ必須部分フォーマット5であり、以下の通りであります："
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         HelloInterval         |          DeadFactor           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            unused             |          Family ID            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Mandatory Common Part                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Additional Receiver ID Record                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                            .........\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Additional Receiver ID Record                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "HelloInterval The hello interval advertises the time between sending of consecutive Hello Messages. If the LS does not receive a Hello message from the DCS (which contains the LSID as a Receiver ID) within the HelloInterval advertised by the DCS then the DCS's Hello is considered to be late. Also, the LS MUST send its own Hello message to a DCS within the HelloInterval which it advertised to the DCS in the LS's previous Hello message to that DCS (otherwise the DCS would consider the LS's Hello to be late).",
      "ja": "HelloIntervalのhelloインターバルは、連続したhelloメッセージの送信間の時間をアドバタイズします。 LSがDCSによってアドバタイズHelloIntervalの内（受信機のIDとしてLSIDが含まれています）DCSからHelloメッセージを受信しない場合、DCSのHelloが遅くなると考えられます。また、LSは、それがそのDCSへのLSの以前のHelloメッセージにDCSにアドバタイズHelloIntervalの内DCSに独自のHelloメッセージを送らなければなりません（そうでない場合はDCSは遅刻してLSのHelloを検討します）。"
    },
    {
      "indent": 3,
      "text": "DeadFactor This is a multiplier to the HelloInterval. If an LS does not receive a Hello message which contains the LS's LSID as a Receiver ID within the interval HelloInterval*DeadFactor from a given DCS, which advertised the HelloInterval and DeadFactor in a previous Hello message, then the LS MUST consider the DCS to be stalled; at this point, one of two things MUST happen: 1) if the LS has received any Hello messages from the DCS during this time then the LS transitions the corresponding HFSM to the Unidirectional State; otherwise, 2) the LS transitions the corresponding HFSM to the Waiting State.",
      "ja": "DeadFactorこれはHelloIntervalの乗算器です。 LSが間隔内に受信側IDとしてLSのLSIDが含まれているHelloメッセージを受信しない場合はHelloIntervalの*前回のHelloメッセージにHelloIntervalのとDeadFactorを宣伝与えDCSからDeadFactor、その後、LSは、DCSがあることを考慮しなければなりませんストールしました。この時点では、2つのうちの1つが行われる必要があります：LSは、この期間中にDCSから任意のHelloメッセージを受信したならば、LSは単方向状態に対応HFSMを遷移1）。それ以外の場合は、2）LSは待機状態に対応するHFSMを移行します。"
    },
    {
      "indent": 3,
      "text": "Family ID This is an opaque bit string which is used to refer to an aggregate of Protocol ID/SGID pairs. Only a single HFSM is run for all Protocol ID/SGID pairs assigned to a Family ID. Thus, there is a one to many mapping between the single HFSM and the CAFSMs corresponding to each of the Protocol ID/SGID pairs. This might have the net effect of substantially reducing HFSM maintenance traffic. See the protocol specific SCSP documents for further details.",
      "ja": "ファミリーIDこれは、プロトコルID / SGIDペアの集合体を指すために使用される不透明なビット列です。唯一の単一HFSMは​​ファミリーIDに割り当てられているすべてのプロトコルID / SGIDのペアのために実行されます。したがって、単一HFSM及びプロトコルID / SGID対の各々に対応するCAFSMsの間の多くのマッピングへの1つがあります。これは、実質的にHFSMの保守トラフィックを減らすの正味の効果を持っているかもしれません。詳細については、プロトコル固有のSCSPの文書を参照してください。"
    },
    {
      "indent": 3,
      "text": "Mandatory Common Part The mandatory common part is described in detail in Section B.2.0.1. There are two fields in the mandatory common part whose codings are specific to a given message type. These fields are the \"Number of Records\" field and the \"Flags\" field.",
      "ja": "必須の共通部分は必須の共通部分は、セクションB.2.0.1に詳細に記載されています。コーディング与えられたメッセージのタイプに固有の必須の共通部分の2つのフィールドがあります。これらのフィールドは、フィールド「レコード数」と「フラグ」フィールドです。"
    },
    {
      "indent": 5,
      "text": "Number of Records The Number of Records field of the mandatory common part for the Hello message contains the number of \"Additional Receiver ID\" records which are included in the Hello. Additional Receiver ID records contain a length field and a Receiver ID field. Note that the count in \"Number of Records\" does NOT include the Receiver ID which is included in the Mandatory Common Part.",
      "ja": "レコード数は、Helloメッセージのための必須の共通部分のレコードのフィールドの数は、ハローに含まれている「追加レシーバーID」のレコードの数が含まれています。追加のレシーバIDレコードは、長さフィールドとレシーバーIDフィールドが含まれています。 「レコード数」のカウントは必須の共通部分に含まれるレシーバIDが含まれていないことに注意してください。"
    },
    {
      "indent": 5,
      "text": "Flags Currently, there are no flags defined for the Flags field of the mandatory common part for the Hello message.",
      "ja": "旗は現在、Helloメッセージのための必須の共通部分のFlagsフィールドに定義されたフラグはありません。"
    },
    {
      "indent": 5,
      "text": "All other fields of the mandatory common part are coded as described in Section B.2.0.1.",
      "ja": "セクションB.2.0.1で説明したように義務的な共通部分の他のすべてのフィールドがコード化されています。"
    },
    {
      "indent": 3,
      "text": "Additional Receiver ID Record This record contains a length field followed by a Receiver ID. Since it is conceivable that the length of a given Receiver ID may vary even within an SG, each additional Receiver ID heard (beyond the first one) will have both its length in bytes and value encoded in an \"Additional Receiver ID Record\". Receiver IDs are IDs of a DCS from which the LS has heard a recent Hello (i.e., within DeadFactor*HelloInterval as advertised by the DCS in a previous Hello message).",
      "ja": "追加のレシーバID Recordこのレコードは、受信側IDが続く長さフィールドが含まれています。それは所与の受信機IDの長さがあってもSG内で変化し得ることが考えられるので、各追加の受信機IDは、「追加の受信機IDレコード」に符号化されたバイト値で、その長さの両方を有することになる（最初のものを超えて）聞きました。受信機IDはLS（すなわち、前回のHelloメッセージにDCSによってアドバタイズされるようDeadFactor * HelloIntervalの内）最近ハローを聞いているからDCSのIDです。"
    },
    {
      "indent": 5,
      "text": "The format for this record is as follows:",
      "ja": "次のようにこのレコードの形式は次のとおりです。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Rec ID Len   |                 Receiver ID                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the LS has not heard from any DCS then the LS sets the Hello message fields as follows: Recvr ID Len is set to zero and no storage is allocated for the Receiver ID in the Common Mandatory Part, \"Number of Records\" is set to zero, and no storage is allocated for \"Additional Receiver ID Records\".",
      "ja": "LSは、任意のDCSから聞いていない場合は次のようにLSは、Helloメッセージのフィールドを設定します。Recvr IDレンがゼロに設定され、何のストレージは、共通の必須部分にレシーバーIDは、「レコードの数を」割り当てられていないに設定されていますゼロ、ノーストレージは、「追加のレシーバIDレコード」に割り当てられています。"
    },
    {
      "indent": 3,
      "text": "If the LS has heard from exactly one DCS then the LS sets the Hello message fields as follows: the Receiver ID of the DCS which was heard and the length of that Receiver ID are encoded in the Common Mandatory Part, \"Number of Records\" is set to zero, and no storage is allocated for \"Additional Receiver ID Records\".",
      "ja": "LSは正確に一つのDCSから聞いていた場合は、次のようにLSがHelloメッセージのフィールドを設定し、その後：聞いた、そのレシーバIDの長さは一般的な必須部分でエンコードされているDCSの受信側IDを、「レコード数」でありますゼロに設定され、何のストレージは、「追加のレシーバーIDレコード」のために割り当てられていません。"
    },
    {
      "indent": 3,
      "text": "If the LS has heard from two or more DCSs then the LS sets the Hello message fields as follows: the Receiver ID of the first DCS which was heard and the length of that Receiver ID are encoded in the Common Mandatory Part, \"Number of Records\" is set to the number of \"Additional\" DCSs heard, and for each additional DCS an \"Additional Receiver ID Record\" is formed and appended to the end of the Hello message.",
      "ja": "「、レコードの数を聞いた最初のDCSのレシーバIDとそのレシーバーIDの長さは一般的な必須部分でエンコードされている：LSが二つ以上から聞いた場合のDCSは、LSは、次のようにHelloメッセージのフィールドを設定し、 \"の数に設定されている『追加』のDCSは、聞いて、各追加DCSは、『追加の受信機IDレコードは、』形成され、Helloメッセージの最後に追加。"
    },
    {
      "indent": 0,
      "text": "B.3 Extensions Part",
      "ja": "B.3拡張パート"
    },
    {
      "indent": 3,
      "text": "The Extensions Part, if present, carries one or more extensions in {Type, Length, Value} triplets.",
      "ja": "拡張部分は、存在する場合、{タイプ、長さ、値}のトリプレット内の1つ以上の拡張機能を運びます。"
    },
    {
      "indent": 3,
      "text": "Extensions have the following format:",
      "ja": "拡張機能の形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Type               |           Length              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Value...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Type The extension type code (see below).",
      "ja": "拡張タイプコードを入力し（下記参照）。"
    },
    {
      "indent": 3,
      "text": "Length The length in octets of the value (not including the Type and Length fields; a null extension will have only an extension header and a length of zero).",
      "ja": "長さ値のオクテットの長さ（タイプと長さフィールドを含まない;ヌル拡張は、拡張ヘッダとゼロの長さを有するであろう）。"
    },
    {
      "indent": 3,
      "text": "When extensions exist, the extensions part is terminated by the End of Extensions extension, having Type = 0 and Length = 0.",
      "ja": "拡張子が存在する場合、拡張部分は、タイプ= 0とLength = 0を持つ、拡張機能拡張の終わりで終了します。"
    },
    {
      "indent": 3,
      "text": "Extensions may occur in any order but any particular extension type may occur only once in an SCSP packet. An LS MUST NOT change the order of extensions.",
      "ja": "拡張機能は、任意の順序で行うことができるが、任意の特定の拡張型は、SCSPパケットに一度だけ発生する可能性があります。 LSは、拡張子の順序を変更しないでください。"
    },
    {
      "indent": 0,
      "text": "B.3.0 The End Of Extensions",
      "ja": "拡張子のB.3.0終了"
    },
    {
      "indent": 4,
      "text": "Type = 0\nLength = 0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When extensions exist, the extensions part is terminated by the End Of Extensions extension.",
      "ja": "拡張子が存在する場合、拡張部分は拡張機能拡張の終りで終了します。"
    },
    {
      "indent": 0,
      "text": "B.3.1 SCSP Authentication Extension",
      "ja": "B.3.1 SCSP認証拡張機能"
    },
    {
      "indent": 3,
      "text": "Type = 1 Length = variable",
      "ja": "タイプ= 1本の長さ=変数"
    },
    {
      "indent": 3,
      "text": "The SCSP Authentication Extension is carried in SCSP packets to convey the authentication information between an LS and a DCS in the same SG.",
      "ja": "SCSP認証拡張は、同じSGにLSとDCSの間で認証情報を伝えるためにSCSPパケットで運ばれます。"
    },
    {
      "indent": 3,
      "text": "Authentication is done pairwise on an LS to DCS basis; i.e., the authentication extension is generated at each LS. If a received packet fails the authentication test then an \"abnormal event\" has occurred. The packet is discarded and this event is logged.",
      "ja": "認証は、DCSごとにLSに対で行われます。すなわち、認証拡張は、各LSで生成されます。受信したパケットが認証試験に失敗した場合は、「異常事象は、」発生しました。パケットが破棄され、このイベントがログに記録されます。"
    },
    {
      "indent": 3,
      "text": "The presence or absence of authentication is a local matter.",
      "ja": "認証の有無がローカルの問題です。"
    },
    {
      "indent": 0,
      "text": "B.3.1.1 Header Format",
      "ja": "B.3.1.1ヘッダー形式"
    },
    {
      "indent": 3,
      "text": "The authentication header has the following format:",
      "ja": "認証ヘッダは、以下の形式を有します。"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Security Parameter Index (SPI)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+ Authentication Data... -+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Security Parameter Index (SPI) can be thought of as an index into a table that maintains the keys and other information such as hash algorithm. LS and DCS communicate either off-line using manual keying or online using a key management protocol to populate this table. The receiving SCSP entity always allocates the SPI and the parameters associated with it.",
      "ja": "セキュリティパラメータインデックス（SPI）は、ハッシュアルゴリズムのようなキーおよび他の情報を保持するテーブルへのインデックスとして考えることができます。 LSとDCSは、この表を移入する鍵管理プロトコルを使用して手動キーイングまたはオンラインを使用してオフラインのいずれかで通信します。受信SCSPエンティティは常にSPIおよびそれに関連するパラメータを割り当てます。"
    },
    {
      "indent": 3,
      "text": "The authentication data field contains the MAC (Message Authentication Code) calculated over the entire SCSP payload. The length of this field is dependent on the hash algorithm used to calculate the MAC.",
      "ja": "認証データフィールドは、全体SCSPペイロードにわたって計算MAC（メッセージ認証コード）を含みます。このフィールドの長さは、MACを計算するために使用されるハッシュアルゴリズムに依存します。"
    },
    {
      "indent": 0,
      "text": "B.3.1.2 Supported Hash Algorithms",
      "ja": "B.3.1.2サポートされているハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "The default hash algorithm to be supported is HMAC-MD5-128 [11]. HMAC is safer than normal keyed hashes. Other hash algorithms MAY be supported by def.",
      "ja": "サポートされるデフォルトのハッシュアルゴリズムは、HMAC-MD5-128である[11]。 HMACは、通常のキー付きハッシュよりも安全です。他のハッシュアルゴリズムは、DEFによってサポートされるかもしれません。"
    },
    {
      "indent": 3,
      "text": "IANA will assign the numbers to identify the algorithm being used as described in Section C.",
      "ja": "セクションC.で説明したようにIANAは、使用されるアルゴリズムを識別するために番号を割り当てます"
    },
    {
      "indent": 0,
      "text": "B.3.1.3 SPI and Security Parameters Negotiation",
      "ja": "B.3.1.3 SPIおよびセキュリティパラメータのネゴシエーション"
    },
    {
      "indent": 3,
      "text": "SPI's can be negotiated either manually or using an Internet Key Management protocol. Manual keying MUST be supported. The following parameters are associated with the tuple <SPI, DCS ID>- lifetime, Algorithm, Key. Lifetime indicates the duration in seconds for which the key is valid. In case of manual keying, this duration can be infinite. Also, in order to better support manual keying, there may be multiple tuples active at the same time (DCS ID being the same).",
      "ja": "SPIのは、手動またはインターネット鍵管理プロトコルを使用してネゴシエートすることができます。手動キー入力をサポートしなければなりません。生涯、アルゴリズム、キー - 次のパラメータは、タプル<SPI、DCS ID>に関連付けられています。寿命は、キーが有効である秒数を示します。手動キー入力の場合には、この期間は無限にすることができます。また、より良好な手動キーイングをサポートするために、（DCS IDは同じである）同時にアクティブ複数のタプルが存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "Any Internet standard key management protocol MAY be used to negotiate the SPI and parameters.",
      "ja": "任意のインターネット標準の鍵管理プロトコルは、SPIとパラメータを交渉するために使用されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "B.3.1.4 Message Processing",
      "ja": "B.3.1.4メッセージ処理"
    },
    {
      "indent": 3,
      "text": "At the time of adding the authentication extension header, LS looks up in a table to fetch the SPI and the security parameters based on the DCS ID. If there are no entries in the table and if there is support for key management, the LS initiates the key management protocol to fetch the necessary parameters. The LS then calculates the hash by zeroing authentication data field before calculating the MAC on the sending end. The result replaces in the zeroed authentication data field. If key management is not supported and authentication is mandatory, the packet is dropped and this information is logged.",
      "ja": "認証拡張ヘッダを追加する時に、LSはSPIとDCS IDに基づいて、セキュリティパラメータを取得するために、テーブルで検索します。そこにはエントリがテーブルにありませんし、鍵管理のためのサポートがある場合、LSは、必要なパラメータを取得するための鍵管理プロトコルを開始する場合。 LSは、送信側でMACを計算する前に認証データフィールドをゼロにすることによって、ハッシュを計算します。結果はゼロ化された認証データフィールドに置き換えられます。鍵管理がサポートされていないと、認証が必須の場合、パケットはドロップされ、この情報が記録されます。"
    },
    {
      "indent": 3,
      "text": "When receiving traffic, an LS fetches the parameters based on the SPI and its ID. The authentication data field is extracted before zeroing out to calculate the hash. It computes the hash on the entire payload and if the hash does not match, then an \"abnormal event\" has occurred.",
      "ja": "トラフィックを受信した場合、LSは、SPI、そのIDに基づいてパラメータを取り出します。認証データフィールドは、ハッシュを計算してゼロにする前に抽出されます。これは、ペイロード全体にハッシュを計算し、ハッシュが一致しない場合は、「異常事象は、」発生しました。"
    },
    {
      "indent": 0,
      "text": "B.3.1.5 Security Considerations",
      "ja": "B.3.1.5セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "It is important that the keys chosen are strong as the security of the entire system depends on the keys being chosen properly and the correct implementation of the algorithms.",
      "ja": "システム全体のセキュリティが適切に選択された鍵とアルゴリズムの正しい実装に依存して選ばれたキーが強いことが重要です。"
    },
    {
      "indent": 3,
      "text": "SCSP has a peer to peer trust model. It is recommended to use an Internet standard key management protocol to negotiate the keys between the neighbors. Transmitting the keys in clear text, if other methods of negotiation is used, compromises the security completely.",
      "ja": "SCSPは、信頼モデルをピア・ツー・ピアを持っています。近隣諸国との間の鍵を交渉するために、インターネットの標準的な鍵管理プロトコルを使用することをお勧めします。交渉の他の方法が使用されている場合はクリアテキストでキーを送信し、完全なセキュリティを危うくします。"
    },
    {
      "indent": 3,
      "text": "Data integrity covers the entire SCSP payload. This guarantees that the message was not modified and the source is authenticated as well. If authentication extension is not used or if the security is compromised, then SCSP servers are liable to both spoofing attacks, active attacks and passive attacks.",
      "ja": "データの整合性は、全体SCSPペイロードをカバーしています。これは、メッセージが変更されていないことを保証し、ソースも同様に認証されます。認証拡張が使用されていない場合、またはセキュリティが侵害された場合、その後、SCSPサーバは、スプーフィング攻撃、能動的攻撃や受動的攻撃の両方に責任を負います。"
    },
    {
      "indent": 3,
      "text": "There is no mechanism to encrypt the messages. It is assumed that a standard layer 3 confidentiality mechanism will be used to encrypt and decrypt messages. As integrity is calculated on an SCSP message and not on each record, there is an implied trust between all the servers in a domain. It is recommend to use the security extension between all the servers in a domain and not just a subset servers.",
      "ja": "メッセージを暗号化するメカニズムはありません。標準のレイヤ3機密性のメカニズムは、メッセージの暗号化と復号化に使用されることが想定されます。整合性がSCSPメッセージではなく、各レコードに基づいて計算されるので、ドメイン内のすべてのサーバー間の暗黙の信頼があります。これは、すべてのドメイン内のサーバーだけではなく、一部のサーバ間のセキュリティ拡張機能を使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Any SCSP server is susceptible to Denial of Service (DOS) attacks. A rouge host can inundate its neighboring SCSP server with SCSP packets. However, if the authentication option is used, SCSP databases will not become corrupted, as the bogus packets will be discarded when the authentication check fails.",
      "ja": "どれSCSPサーバーは、サービス拒否（DoS）攻撃を受けやすいです。ルージュのホストは、SCSPパケットとその隣接SCSPサーバを氾濫することができます。認証オプションが使用されている場合は認証チェックが失敗したときに偽のパケットが破棄されるようにしかし、SCSPデータベースは、破損していないだろう。"
    },
    {
      "indent": 3,
      "text": "Due to the pairwise authentication model of SCSP, the information received from any properly authenticated server is trusted and propagated throughout the server group. Consequently, if security of any SCSP server is compromised, the entire database becomes vulnerable to curruption originating from the compromised server.",
      "ja": "SCSPのペアごとの認証モデルに、任意の適切に認証サーバから受信した情報は、信頼されたサーバーグループ全体に伝播します。任意SCSPサーバのセキュリティが侵害された場合、結果として、データベース全体が損なわサーバから発信curruptionに対して脆弱になります。"
    },
    {
      "indent": 0,
      "text": "B.3.2 SCSP Vendor-Private Extension",
      "ja": "B.3.2 SCSPベンダーのプライベート拡張"
    },
    {
      "indent": 4,
      "text": "Type = 2\nLength = variable",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The SCSP Vendor-Private Extension is carried in SCSP packets to convey vendor-private information between an LS and a DCS in the same SG and is thus of limited use. If a finer granularity (e.g., CSA record level) is desired then then given client/server protocol specific SCSP document MUST define such a mechanism. Obviously, however, such a protocol specific mechanism might look exactly like this extension. The Vendor Private Extension MAY NOT appear more than once in an SCSP packet for a given Vendor ID value.",
      "ja": "SCSPベンダープライベート拡張は同じSGにLSとDCSの間のベンダープライベート情報を伝えるためにSCSPパケットで運ばれ、したがって、限られた使用です。より細かい粒度（例えば、CSAレコードレベル）クライアント/サーバプロトコル特定SCSP文書を与え、次いで、所望される場合、このような機構を定義しなければなりません。明らかに、しかし、そのようなプロトコル特有のメカニズムは、まさにこの拡張機能のようになります。ベンダーのプライベート拡張は、与えられたベンダーID値のSCSPパケットで複数回表示されない場合があります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  Vendor ID                    |  Data....     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Vendor ID 802 Vendor ID as assigned by the IEEE [7].",
      "ja": "ベンダーID 802ベンダID IEEEによって割り当てられた[7]。"
    },
    {
      "indent": 3,
      "text": "Data The remaining octets after the Vendor ID in the payload are vendor-dependent data.",
      "ja": "データは、ペイロード内のベンダーID後の残りのオクテットは、ベンダーに依存するデータです。"
    },
    {
      "indent": 3,
      "text": "If the receiver does not handle this extension, or does not match the Vendor ID in the extension then the extension may be completely ignored by the receiver.",
      "ja": "受信機はこの拡張機能に対応していない、または拡張子でベンダーIDと一致しない場合、拡張子が完全に受信機によって無視されることがあります。"
    },
    {
      "indent": 0,
      "text": "C. IANA Considerations",
      "ja": "C. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Any and all requests for value assignment from the various number spaces described in this document require proper documentation. Possible forms of documentation include, but are not limited to, RFCs or the product of another cooperative standards body (e.g., the MPOA and LANE subworking group of the ATM Forum). Other requests may also be accepted, under the advice of a \"designated expert\". (Contact the IANA for the contact information of the current expert.)",
      "ja": "この文書に記載されている種々の数のスペースから値の割り当てのための任意およびすべての要求は、適切な書類が必要です。ドキュメントの可能な形態としては、RFCのまたは別の協調標準化団体（例えば、MPOAおよびATMフォーラムのLANE subworking群）の生成物に限定されるものではありません。その他の要求も、「指定された専門家」の助言の下、受け入れられます。 （現在の専門家の連絡先情報については、IANAにお問い合わせください。）"
    },
    {
      "indent": 0,
      "text": "References",
      "ja": "リファレンス"
    },
    {
      "indent": 3,
      "text": "[1] Laubach, M., and J. Halpern, \"Classical IP and ARP over ATM\", Laubach, RFC 2225, April 1998.",
      "ja": "[1]ラウバッハ、M.、およびJ.アルペルン、 \"古典IPおよびATM上ARP\"、ラウバッハ、RFC 2225、1998年4月。"
    },
    {
      "indent": 3,
      "text": "[2] Luciani, J., Katz, D., Piscitello, D., Cole, B., and N. Doraswamy, \"NMBA Next Hop Resolution Protocol (NHRP)\", RFC 2332, April 1998.",
      "ja": "[2]ルチアーニ、J.、カッツ、D.、Piscitello、D.、コール、B.、およびN. Doraswamy、 \"NMBAネクストホップ解決プロトコル（NHRP）\"、RFC 2332、1998年4月。"
    },
    {
      "indent": 3,
      "text": "[3] Moy, J., \"OSPF Version 2\", STD 54, RFC 2328, April 1998.",
      "ja": "[3]モイ、J.、 \"OSPFバージョン2\"、STD 54、RFC 2328、1998年4月。"
    },
    {
      "indent": 3,
      "text": "[4] \"P-NNI V1\", Dykeman, Goguen, 1996.",
      "ja": "[4] \"P-NNI V1\"、Dykeman、Goguen、1996。"
    },
    {
      "indent": 3,
      "text": "[5] Armitage, G., \"Support for Multicast over UNI 3.0/3.1 based ATM Networks\", RFC 2022, November 1996.",
      "ja": "[5]アーミテージ、G.、 \"UNI 3.0 / 3.1以上のマルチキャストのサポートベースのATMネットワーク\"、RFC 2022、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[6] Keene, \"LAN Emulation over ATM Version 2 - LNNI specification\", btd-lane-lnni-02.08",
      "ja": "[6]キーン、 \"ATM版上LANエミュレーション2  -  LNNI仕様\"、BTD-レーン-lnni 02.08"
    },
    {
      "indent": 3,
      "text": "[7] Reynolds, J., and J. Postel, \"Assigned Numbers\", STD 2, RFC 1700, October 1994.",
      "ja": "[7]レイノルズ、J.、およびJ.ポステル、 \"割り当て番号\"、STD 2、RFC 1700、1994年10月。"
    },
    {
      "indent": 3,
      "text": "[8] Luciani, J., \"A Distributed NHRP Service Using SCSP\", RFC 2335, April 1998.",
      "ja": "[8]ルチアーニ、J.、 \"SCSPを用いた分散NHRPサービス\"、RFC 2335、1998年4月。"
    },
    {
      "indent": 3,
      "text": "[9] Luciani, J., \"A Distributed ATMARP Service Using SCSP\", Work In Progress.",
      "ja": "[9]ルチアーニ、J.、 \"SCSPを用いた分散ATMARPサービス\" は、進行中の作業します。"
    },
    {
      "indent": 3,
      "text": "[10] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[10]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[11] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[11] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This memo is a distillation of issues raised during private discussions, on the IP-ATM mailing list, and during the Dallas IETF (12/95). Thanks to all who have contributed but particular thanks to following people (in no particular order): Barbara Fox of Harris and Jeffries; Colin Verrilli of IBM; Raj Nair, and Matthew Doar of Ascom Nexion; Andy Malis of Cascade; Andre Fredette of Bay Networks; James Watt of Newbridge; and Carl Marcinik of Fore.",
      "ja": "このメモは、IP-ATMメーリングリスト上、およびダラスIETF（95分の12）の間に、民間の議論の中に提起された問題の蒸留です。以下の人（順不同）に貢献したすべての人が、特定の感謝のおかげ：ハリスとジェフリーズのバーバラ・フォックス。 IBMのコリン・Verrilli。ラジNairさん、そしてアスコムNexionのマシューDoar。カスケードのアンディMalis。ベイネットワークのアンドレFredette。ニューブリッジのジェームズ・ワット。フォアのカールMarcinik。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "James V. Luciani Bay Networks, Inc. 3 Federal Street, BL3-03 Billerica, MA 01821",
      "ja": "ジェームスV.ルチアーニベイネットワーク株式会社3連邦ストリート、BL3-03ビレリカ、MA 01821"
    },
    {
      "indent": 3,
      "text": "Phone: +1-978-916-4734 EMail: luciani@baynetworks.com",
      "ja": "電話：+ 1-978-916-4734 Eメール：luciani@baynetworks.com"
    },
    {
      "indent": 3,
      "text": "Grenville Armitage Bell Labs Lucent Technologies 101 Crawfords Corner Road Holmdel, NJ 07733",
      "ja": "グレンヴィルアーミテージベル研究所ルーセント・テクノロジーズ101 Crawfordsコーナー道路ホルムデル、NJ 07733"
    },
    {
      "indent": 3,
      "text": "Phone: +1 201 829 2635 EMail: gja@lucent.com",
      "ja": "電話：+1 201 829 2635 Eメール：gja@lucent.com"
    },
    {
      "indent": 3,
      "text": "Joel M. Halpern Newbridge Networks Corp. 593 Herndon Parkway Herndon, VA 22070-5241",
      "ja": "ジョエルM.ハルパーンニューブリッジネットワークス社593ハーンドンパークウェイハーンドン、バージニア州22070から5241"
    },
    {
      "indent": 3,
      "text": "Phone: +1-703-708-5954 EMail: jhalpern@Newbridge.COM",
      "ja": "電話：+ 1-703-708-5954 Eメール：jhalpern@Newbridge.COM"
    },
    {
      "indent": 3,
      "text": "Naganand Doraswamy Bay Networks, Inc. 3 Federal St, BL3-03 Billerice, MA 01821",
      "ja": "Naganand Doraswamyベイネットワーク株式会社3連邦セント、BL3-03 Billerice、MA 01821"
    },
    {
      "indent": 3,
      "text": "Phone: +1-978-916-1323 EMail: naganand@baynetworks.com",
      "ja": "電話：+ 1-978-916-1323 Eメール：naganand@baynetworks.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (1998). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（1998）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    }
  ]
}