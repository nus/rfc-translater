<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 8298 - Self-Clocked Rate Adaptation for Multimedia 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8298</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <button type="button" class="btn btn-light btn-sm">
      <a href="https://tools.ietf.org/html/rfc8298">Orig</a>
    </button>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 8298 - Self-Clocked Rate Adaptation for Multimedia 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc8298">
              https://tools.ietf.org/html/rfc8298
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 8298 - マルチメディアのためのセルフクロックレートアダプテーション</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                      I. Johansson
Request for Comments: 8298                                     Z. Sarker
Category: Experimental                                       Ericsson AB
ISSN: 2070-1721                                            December 2017
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              Self-Clocked Rate Adaptation for Multimedia
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo describes a rate adaptation algorithm for conversational media services such as interactive video. The solution conforms to the packet conservation principle and uses a hybrid loss-and-delay-based congestion control algorithm. The algorithm is evaluated over both simulated Internet bottleneck scenarios as well as in a Long Term Evolution (LTE) system simulator and is shown to achieve both low latency and high video throughput in these scenarios.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、インタラクティブなビデオなどの会話メディアサービスのためのレート適応アルゴリズムを記述する。溶液は、パケット保存原理に準拠しており、ハイブリッド損失及び遅延に基づく輻輳制御アルゴリズムを使用します。アルゴリズムは、ロングタームエボリューション（LTE）システムシミュレータの両方シミュレートされたインターネットのボトルネックシナリオにわたって同様に評価され、これらのシナリオでは、低レイテンシ及び高ビデオ・スループットを両立することが示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 7841のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8298.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8298で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  Wireless (LTE) Access Properties  . . . . . . . . . . . .   4
     1.2.  Why is it a self-clocked algorithm? . . . . . . . . . . .   5
   2.  Requirements Language . . . . . . . . . . . . . . . . . . . .   5
   3.  Overview of SCReAM Algorithm  . . . . . . . . . . . . . . . .   6
     3.1.  Network Congestion Control  . . . . . . . . . . . . . . .   8
     3.2.  Sender Transmission Control . . . . . . . . . . . . . . .   9
     3.3.  Media Rate Control  . . . . . . . . . . . . . . . . . . .   9
   4.  Detailed Description of SCReAM  . . . . . . . . . . . . . . .  10
     4.1.  SCReAM Sender . . . . . . . . . . . . . . . . . . . . . .  10
       4.1.1.  Constants and Parameter Values  . . . . . . . . . . .  10
         4.1.1.1.  Constants . . . . . . . . . . . . . . . . . . . .  11
         4.1.1.2.  State Variables . . . . . . . . . . . . . . . . .  12
       4.1.2.  Network Congestion Control  . . . . . . . . . . . . .  14
         4.1.2.1.  Reaction to Packet Loss and ECN . . . . . . . . .  17
         4.1.2.2.  Congestion Window Update  . . . . . . . . . . . .  17
         4.1.2.3.  Competing Flows Compensation  . . . . . . . . . .  20
         4.1.2.4.  Lost Packet Detection . . . . . . . . . . . . . .  22
         4.1.2.5.  Send Window Calculation . . . . . . . . . . . . .  23
         4.1.2.6.  Packet Pacing . . . . . . . . . . . . . . . . . .  24
         4.1.2.7.  Resuming Fast Increase Mode . . . . . . . . . . .  24
         4.1.2.8.  Stream Prioritization . . . . . . . . . . . . . .  24
       4.1.3.  Media Rate Control  . . . . . . . . . . . . . . . . .  25
     4.2.  SCReAM Receiver . . . . . . . . . . . . . . . . . . . . .  28
       4.2.1.  Requirements on Feedback Elements . . . . . . . . . .  28
       4.2.2.  Requirements on Feedback Intensity  . . . . . . . . .  30
   5.  Discussion  . . . . . . . . . . . . . . . . . . . . . . . . .  31
   6.  Suggested Experiments . . . . . . . . . . . . . . . . . . . .  31
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  32
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  32
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  33
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  33
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  34
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  36
   Authors&#39; Addresses  . . . . . . . . . . . . . . . . . . . . . . .  36
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion in the Internet occurs when the transmitted bitrate is higher than the available capacity over a given transmission path. Applications that are deployed in the Internet have to employ congestion control to achieve robust performance and to avoid congestion collapse in the Internet. Interactive real-time communication imposes a lot of requirements on the transport; therefore, a robust, efficient rate adaptation for all access types is an important part of interactive real-time communications, as the transmission channel bandwidth can vary over time. Wireless access such as LTE, which is an integral part of the current Internet, increases the importance of rate adaptation as the channel bandwidth of a default LTE bearer [QoS-3GPP] can change considerably in a very short time frame. Thus, a rate adaptation solution for interactive real-time media, such as WebRTC [RFC7478], should be both quick and be able to operate over a large range in channel capacity. This memo describes Self-Clocked Rate Adaptation for Multimedia (SCReAM), a solution that implements congestion control for RTP streams [RFC3550]. While SCReAM was originally devised for WebRTC, it can also be used for other applications where congestion control of RTP streams is necessary. SCReAM is based on the self-clocking principle of TCP and uses techniques similar to what is used in the rate adaptation algorithm based on Low Extra Delay Background Transport (LEDBAT) [RFC6817]. SCReAM is not entirely self-clocked as it augments self-clocking with pacing and a minimum send rate. SCReAM can take advantage of Explicit Congestion Notification (ECN) in cases where ECN is supported by the network and the hosts. However, ECN is not required for the basic congestion control functionality in SCReAM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信されたビットレートが所定の伝送路を介して利用可能な容量よりも高い場合、インターネットの輻輳が発生します。インターネットで展開されたアプリケーションは堅牢な性能を達成するために、インターネットでの輻輳崩壊を回避するために、輻輳制御を採用する必要があります。インタラクティブなリアルタイム通信は、輸送上の要件の多くを課し、伝送チャネル帯域幅が時間とともに変化することができるように、したがって、すべてのアクセスタイプに対して堅牢で効率的なレート適応は、インタラクティブなリアルタイム通信の重要な部分です。現在のインターネットの不可欠な部分であるようなLTEなどの無線アクセスは、非常に短い時間枠内で大きく変化することができ、デフォルトのLTEベアラ[QoSの-3GPP]のチャネル帯域幅のようなレート適合の重要性を増大させます。したがって、このようなのWebRTC [RFC7478]などの対話型リアルタイムメディア、のためのレート適応溶液は、両方の迅速であることと、チャネル容量に大きな範囲にわたって動作することができなければなりません。このメモは、マルチメディアのためのセルフクロックレート適応（スクリーム）、RTPストリーム[RFC3550]のための輻輳制御を実現するソリューションを記載しています。スクリームは、もともとのWebRTCのために考案されたが、それはまた、RTPの輻輳制御が必要なストリームを他の用途に使用することができます。 SCREAMは、TCPのセルフクロッキングの原則に基づいており、低余分な遅延の背景トランスポート（LEDBAT）に基づくレート適応アルゴリズムで使用されているものと同様の技術を使用しています[RFC6817]されます。 SCREAMは完全に自己クロックさ、それは自己クロックペーシングおよび最小送信レートを強化するようではありません。スクリームは、ECNは、ネットワークおよびホストによってサポートされている場合には明示的輻輳通知（ECN）を利用することができます。しかし、ECNはSCREAMにおける基本的な輻輳制御機能は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Wireless (LTE) Access Properties
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. ワイヤレス（LTE）アクセスプロパティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[WIRELESS-TESTS] describes the complications that can be observed in wireless environments. Wireless access such as LTE typically cannot guarantee a given bandwidth; this is true especially for default bearers. The network throughput can vary considerably, for instance, in cases where the wireless terminal is moving around. Even though LTE can support bitrates well above 100 Mbps, there are cases when the available bitrate can be much lower; examples are situations with high network load and poor coverage. An additional complication is that the network throughput can drop for short time intervals (e.g., at handover); these short glitches are initially very difficult to distinguish from more permanent reductions in throughput.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[WIRELESS-TESTS]は、ワイヤレス環境で観察することができる合併症を記述する。 LTEなどの無線アクセスは、典型的には、所定の帯域幅を保証することはできません。これは特に、デフォルトベアラのために真です。ネットワークスループットは、無線端末が動き回っている場合には、例えば、大幅に変化させることができます。 LTEは、ビットレートを十分に上記の100 Mbpsをサポートすることができるにもかかわらず、利用可能なビットレートがはるかに低くすることができる場合があります。例は、高いネットワーク負荷とカバレッジが悪いとの状況です。付加的な複雑さは、ネットワークのスループットが、短い時間間隔（例えば、ハンドオーバ時）のためにドロップすることができるということです。これらの短いグリッチは当初、スループットのより恒久的な削減と区別するのが非常に困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike wireline bottlenecks with large statistical multiplexing, it is not possible to try to maintain a given bitrate when congestion is detected with the hope that other flows will yield. This is because there are generally few other flows competing for the same bottleneck. Each user gets its own variable throughput bottleneck, where the throughput depends on factors like channel quality, network load, and historical throughput. The bottom line is, if the throughput drops, the sender has no other option than to reduce the bitrate. Once the radio scheduler has reduced the resource allocation for a bearer, a flow (which is using RTP Media Congestion Avoidance Techniques (RMCAT)) in that bearer aims to reduce the sending rate quite quickly (within one RTT) in order to avoid excessive queuing delay or packet loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大規模な統計的多重化と有線のボトルネックとは異なり、混雑が他のフローが得られることを期待して検出されたときに与えられたビットレートを維持しようとすることはできません。一般的に、同じボトルネックを競合するいくつかの他のフローがあるためです。各ユーザは、スループットは、チャネル品質、ネットワークの負荷、および過去のスループット等の要因に依存する独自の可変スループットのボトルネックを、取得します。一番下の行は、スループットが低下した場合、送信者は、ビットレートを削減するよりも、他のオプションを持っていない、です。ラジオ・スケジューラは、ベアラのリソース割り当てを削減していたら、そのベアラで（RTPメディア輻輳回避技術（RMCAT）を使用している）の流れは、過度のキューイングを避けるために、（1 RTT以内）、かなり素早く送信レートを削減することを目指して遅延やパケットロス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Why is it a self-clocked algorithm?
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. なぜそれがセルフクロックアルゴリズムですか？
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Self-clocked congestion control algorithms provide a benefit over their rate-based counterparts in that the former consists of two adaptation mechanisms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セルフクロック輻輳制御アルゴリズムは、前者は、2つの適応機構からなることをそのレートベースの対応物を超える利点を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A congestion window computation that evolves over a longer timescale (several RTTs) especially when the congestion window evolution is dictated by estimated delay (to minimize vulnerability to, e.g., short-term delay variations).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oより長い時間スケール輻輳ウィンドウの発生が推定された遅延によって決定され、特に、（いくつかのRTT）にわたって進化輻輳ウィンドウ計算は、（脆弱性、例えば、短期遅延変動を最小化します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A fine-grained congestion control given by the self-clocking; it operates on a shorter time scale (1 RTT). The benefits of self-clocking are also elaborated upon in [TFWC].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
自己クロッキングによって与えられるきめ細かな輻輳制御をO。それは短い時間スケール（1 RTT）上で動作します。セルフクロッキングの利点も[TFWC]には詳述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A rate-based congestion control algorithm typically adjusts the rate based on delay and loss. The congestion detection needs to be done with a certain time lag to avoid overreaction to spurious congestion events such as delay spikes. Despite the fact that there are two or more congestion indications, the outcome is that there is still only one mechanism to adjust the sending rate. This makes it difficult to reach the goals of high throughput and prompt reaction to congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レートベースの輻輳制御アルゴリズムは、典型的には、遅延と損失に基づいてレートを調整します。輻輳検出は、このような遅延スパイクなどのスプリアス輻輳イベントへの過剰反応を避けるために、一定の時間差で行われる必要があります。二つ以上の混雑指摘があるという事実にもかかわらず、結果は、送信レートを調整するための唯一のメカニズムがまだあるということです。これは、それが困難な高いスループットと輻輳への迅速な反応の目標を達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.必要な言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Overview of SCReAM Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SCREAMアルゴリズムの3概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The core SCReAM algorithm has similarities to the concepts of self-clocking used in TCP-friendly window-based congestion control [TFWC] and follows the packet conservation principle. The packet conservation principle is described as a key factor behind the protection of networks from congestion [Packet-conservation].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コアSCREAMアルゴリズムは、[TFWC] TCPフレンドリーウィンドウベースの輻輳制御に使用される自己クロッキングの概念に類似していると、パケットの保全の原則に従います。パケット保存原理は、輻輳[パケット保全]からネットワークの保護の背後にある重要な要因として記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In SCReAM, the receiver of the media echoes a list of received RTP packets and the timestamp of the RTP packet with the highest sequence number back to the sender in feedback packets. The sender keeps a list of transmitted packets, their respective sizes, and the time they were transmitted. This information is used to determine the number of bytes that can be transmitted at any given time instant. A congestion window puts an upper limit on how many bytes can be in flight, i.e., transmitted but not yet acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スクリームでは、メディアの受信機は、受信したRTPパケットのリストと、フィードバックパケットで送信者に最も高いシーケンス番号を有するRTPパケットのタイムスタンプをエコーし​​ます。送信者は送信されたパケット、彼らのそれぞれのサイズ、およびそれらが送信された時間のリストを保持します。この情報は、任意の所与の時点で送信することができるバイトの数を決定するために使用されます。輻輳ウィンドウは、送信がまだ認められていない、すなわち飛行、中にすることができますどのように多くのバイト数の上限を置きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The congestion window is determined in a way similar to LEDBAT [RFC6817]. LEDBAT is a congestion control algorithm that uses send and receive timestamps to estimate the queuing delay (from now on denoted &#34;qdelay&#34;) along the transmission path. This information is used to adjust the congestion window. The use of LEDBAT ensures that the end-to-end latency is kept low. [LEDBAT-delay-impact] shows that LEDBAT has certain inherent issues that make it counteract its purpose of achieving low delay. The general problem described in the paper is that the base delay is offset by LEDBAT&#39;s own queue buildup. The big difference with using LEDBAT in the SCReAM context lies in the facts that the source is rate limited and that the RTP queue must be kept short (preferably empty). In addition, the output from a video encoder is rarely constant bitrate; static content (talking heads, for instance) gives almost zero video bitrate. This yields two useful properties when LEDBAT is used with SCReAM; they help to avoid the issues described in [LEDBAT-delay-impact]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳ウィンドウはLEDBAT [RFC6817]と同様に決定されます。 LEDBATは、伝送路に沿って（今から示される「qdelay」に）キューイング遅延を推定するためにタイムスタンプを送受信使用輻輳制御アルゴリズムです。この情報は、輻輳ウィンドウを調整するために使用されます。 LEDBATの使用は、エンドツーエンドのレイテンシが低く保たれていることを保証します。 [LEDBAT遅延衝撃]はLEDBATは、それが低遅延を達成するその目的に対抗する特定の固有の問題を有していることを示しています。論文に記載されている一般的な問題は、ベース遅延がLEDBAT自身のキューの蓄積によって相殺されていることです。 SCREAMコンテキストでLEDBATを使用しての大きな違いは、ソースがレート制限され、RTPキューは、（好ましくは空）短くしなければならないことという事実です。また、ビデオエンコーダからの出力はめったに一定のビットレートです。静的コンテンツ（例えば、頭を話しては）ほぼゼロビデオビットレートを提供します。 LEDBATが叫び声とともに使用されているとき、これは2つの有用な性質を与えます。彼らは[LEDBAT-遅延の影響]に記載されている問題を回避するために役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. There is always a certain probability that SCReAM is short of data to transmit; this means that the network queue will become empty every once in a while.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.悲鳴が送信すべきデータが不足している一定の確率は常にあります。これは、ネットワークキューがたまにで空になることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The max video bitrate can be lower than the link capacity. If the max video bitrate is 5 Mbps and the capacity is 10 Mbps, then the network queue will become empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.最大ビデオビットレートはリンク容量よりも低くすることができます。最大ビデオビットレートは5 Mbpsですし、容量が10 Mbpsの場合は、ネットワークキューが空になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is sufficient that any of the two conditions above is fulfilled to make the base delay update properly. Furthermore, [LEDBAT-delay-impact] describes an issue with short-lived competing flows. In SCReAM, these short-lived flows will cause the self-clocking to slow down, thereby building up the RTP queue; in turn, this results in a reduced media video bitrate. Thus, SCReAM slows the bitrate more when there are competing short-lived flows than the traditional use of LEDBAT does. The basic functionality in the use of LEDBAT in SCReAM is quite simple; however, there are a few steps in order to make the concept work with conversational media:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記2つの条件のいずれかが適切にベース遅延更新を行うことが満たされていればよいです。また、[LEDBAT遅延衝撃]は短命競合フローの問題を記載しています。悲鳴では、これらの短命フローは、自己クロックは、それによってRTPキューを構築し、スローダウンするようになります。今度は、これが減少し、メディアのビデオビットレートになります。したがって、SCREAMはLEDBATの伝統的な使用よりも、競合短命の流れがあるビットレートより遅くなります。 SCREAMでLEDBATの使用における基本的な機能は非常に簡単です。しかし、会話のメディアとのコンセプトの作品を作るために、いくつかのステップがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Congestion window validation techniques. These are similar to the method described in [RFC7661]. Congestion window validation ensures that the congestion window is limited by the actual number bytes in flight; this is important especially in the context of rate-limited sources such as video. Lack of congestion window validation would lead to a slow reaction to congestion as the congestion window does not properly reflect the congestion state in the network. The allowed idle period in this memo is shorter than in [RFC7661]; this to avoid excessive delays in the cases where, e.g., wireless throughput has decreased during a period where the output bitrate from the media coder has been low (for instance, due to inactivity). Furthermore, this memo allows for more relaxed rules for when the congestion window is allowed to grow; this is necessary as the variable output bitrate generally means that the congestion window is often underutilized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの輻輳ウィンドウ検証方法。これらは、[RFC7661]に記載された方法と同様です。輻輳ウィンドウ検証は、輻輳ウィンドウが飛行中の実際の数のバイトによって制限されることを保証します。これは、特にビデオなどのレート制限ソースのコンテキストで重要です。輻輳ウィンドウが正しく、ネットワーク内の輻輳状態を反映していないとして、輻輳ウィンドウ検証の欠如は混雑に遅い反応につながります。このメモでは許さアイドル期間は、[RFC7661]でよりも短くなっています。例えば、無線スループットがメディア・コーダからの出力ビットレートは、（例えば、非活動に起因する）、低されている期間中に減少した場合に過度の遅延を回避するために、この。また、このメモは、輻輳ウィンドウを成長させるときのために、よりリラックスしたルールが可能になります。可変出力ビットレートは、一般的に輻輳ウィンドウは、多くの場合、十分に活用されていないことを意味する、これは必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Fast increase mode makes the bitrate increase faster when no congestion is detected. It makes the media bitrate ramp up within 5 to 10 seconds. The behavior is similar to TCP slowstart. Fast increase mode is exited when congestion is detected. However, fast increase mode can resume if the congestion level is low; this enables a reasonably quick rate increase in case link throughput increases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳が検出されないときO高速増加モードは、より高速なビットレートの増加になります。これは、メディアビットレートが5〜10秒以内に立ち上げることができます。動作はTCPのスロースタートに似ています。輻輳が検出されたときに、高速増加モードが解除されます。輻輳レベルが低い場合は、高速の増加モードが再開することができます。これはケースリンクのスループットの増加で合理的に速いレートの増加を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A qdelay trend is computed for earlier detection of incipient congestion; as a result, it reduces jitter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O qdelay傾向が初期輻輳の早期検出のために計算されます。その結果として、それは、ジッタを低減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Addition of a media rate control function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メディア・レート制御機能の追加、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Use of inflection points in the media rate calculation to achieve reduced jitter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oメディアレート計算における変曲点の使用は減少し、ジッタを実現しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Adjustment of qdelay target for better performance when competing with other loss-based congestion-controlled flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他の損失ベースの輻輳制御フローと競合する、より良い性能のためqdelayターゲットのO調整。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above-mentioned features will be described in more detail in Sections 3.1 to 3.3. The full details are described in Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記の特徴は、3.3セクション3.1でより詳細に説明します。詳細は、4章で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                    +---------------------------+
                    |        Media encoder      |
                    +---------------------------+
                        ^                  |
                        |                  |(1)
                        |(3)              RTP
                        |                  V
                        |            +-----------+
                   +---------+       |           |
                   | Media   |  (2)  |   Queue   |
                   | rate    |&lt;------|           |
                   | control |       |RTP packets|
                   +---------+       |           |
                                     +-----------+
                                           |
                                           |(4)
                                          RTP
                                           |
                                           v
              +------------+       +--------------+
              |  Network   |  (7)  |    Sender    |
          +--&gt;| congestion |------&gt;| Transmission |
          |   |  control   |       |   Control    |
          |   +------------+       +--------------+
          |                                |
          |-------------RTCP----------|    |(5)
              (6)                     |   RTP
                                      |    v
                                  +------------+
                                  |     UDP    |
                                  |   socket   |
                                  +------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Figure 1: SCReAM Sender Functional View
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図1：スクリームの送信者機能を表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SCReAM algorithm consists of three main parts: network congestion control, sender transmission control, and media rate control. All of these parts reside at the sender side. Figure 1 shows the functional overview of a SCReAM sender. The receiver-side algorithm is very simple in comparison, as it only generates feedback containing acknowledgements of received RTP packets and an ECN count.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークの輻輳制御、送信元伝送制御、およびメディアレート制御：スクリームアルゴリズムは、3つの主要部分からなります。これらの部品のすべては、送信側に存在します。図1は、スクリーム送信者の機能の概要を示しています。それだけで受信したRTPパケット及びECN数の確認応答を含むフィードバックを生成するように受信側のアルゴリズムは、比較して非常に簡単です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Network Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. ネットワーク輻輳制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The network congestion control sets an upper limit on how much data can be in the network (bytes in flight); this limit is called CWND (congestion window) and is used in the sender transmission control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークの輻輳制御は、ネットワーク（飛行中のバイト）であることができるデータ量の上限を設定します。この制限は、CWND（輻輳ウィンドウ）と呼ばれ、送信者の送信制御に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SCReAM congestion control method uses techniques similar to LEDBAT [RFC6817] to measure the qdelay. As is the case with LEDBAT, it is not necessary to use synchronized clocks in the sender and receiver in order to compute the qdelay. However, it is necessary that they use the same clock frequency, or that the clock frequency at the receiver can be inferred reliably by the sender. Failure to meet this requirement leads to malfunction in the SCReAM congestion control algorithm due to incorrect estimation of the network queue delay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スクリーム輻輳制御方法はqdelayを測定するために[RFC6817]をLEDBATと同様の技術を使用します。 LEDBATと同様に、qdelayを計算するために送信側と受信側で同期したクロックを使用する必要はありません。しかし、彼らが同じクロック周波数を使用すること、または受信機のクロック周波数は送信者が確実に推測することができるようにする必要があります。この要件を満たすために失敗は、ネットワークキュー遅延の不正確な推定にSCREAMの輻輳制御アルゴリズムの故障につながります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SCReAM sender calculates the congestion window based on the feedback from the SCReAM receiver. The congestion window is allowed to increase if the qdelay is below a predefined qdelay target; otherwise, the congestion window decreases. The qdelay target is typically set to 50-100 ms. This ensures that the queuing delay is kept low. The reaction to loss or ECN events leads to an instant reduction of CWND. Note that the source rate-limited nature of real-time media, such as video, typically means that the queuing delay will mostly be below the given delay target. This is contrary to the case where large files are transmitted using LEDBAT congestion control and the queuing delay will stay close to the delay target.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCREAMの送信者はSCREAMの受信機からのフィードバックに基づいて輻輳ウィンドウを計算します。輻輳ウィンドウはqdelayが所定qdelay目標を下回っている場合に増加させます。それ以外の場合は、輻輳ウィンドウが低下します。 qdelayターゲットは通常、50〜100ミリ秒に設定されています。これは、キューイング遅延が低く保たれていることを保証します。損失やECNイベントへの反応がCWNDの瞬時低下につながります。ビデオなどのリアルタイムメディアのソースレート制限性質は、典型的には、キューイング遅延がほとんど与えられた遅延目標を下回るであろうことを意味することに留意されたいです。これは、大きなファイルをLEDBAT輻輳制御を使用して送信される場合とは逆で、キューイング遅延は遅延目標に近いままになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Sender Transmission Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 送信者送信制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sender transmission control limits the output of data, given by the relation between the number of bytes in flight and the congestion window. Packet pacing is used to mitigate issues with ACK compression that MAY cause increased jitter and/or packet loss in the media traffic. Packet pacing limits the packet transmission rate given by the estimated link throughput. Even if the send window allows for the transmission of a number of packets, these packets are not transmitted immediately; rather, they are transmitted in intervals given by the packet size and the estimated link throughput.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信側伝送制御は、飛行中のバイト数および輻輳ウィンドウの間の関係によって与えられたデータの出力を制限します。パケットペーシングは、メディアトラフィックにジッタの増加および/またはパケット損失を引き起こす可能性がACK圧縮の問題を緩和するために使用されています。パケットペーシングは、推定リンクスループットにより与えられたパケットの伝送レートを制限します。送信ウィンドウは、パケットの数の送信を可能にする場合でも、これらのパケットが直ちに送信されません。むしろ、彼らはパケットサイズと推定リンクスループットにより一定間隔で送信されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Media Rate Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. メディアレート制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The media rate control serves to adjust the media bitrate to ramp up quickly enough to get a fair share of the system resources when link throughput increases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メディア・レート制御は、システムリソースのリンクのスループットが高くなるの公正なシェアを得るために十分に素早くを立ち上げ、メディアのビットレートを調整するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reaction to reduced throughput MUST be prompt in order to avoid getting too much data queued in the RTP packet queue(s) in the sender. The media bitrate is decreased if the RTP queue size exceeds a threshold.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スループットの低下への反応は、送信側でのRTPパケットキュー（複数可）にキューイングあまりにも多くのデータを避けるために、迅速でなければなりません。 RTPキューサイズがしきい値を超えた場合は、メディアのビットレートが低下しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cases where the sender&#39;s frame queues increase rapidly, such as in the case of a Radio Access Type (RAT) handover, the SCReAM sender MAY implement additional actions, such as discarding of encoded media frames or frame skipping in order to ensure that the RTP queues are drained quickly. Frame skipping results in the frame rate being temporarily reduced. Which method to use is a design choice and is outside the scope of this algorithm description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信側のフレームキューは、無線アクセス・タイプ（RAT）ハンドオーバの場合のように、急激に増加場合には、スクリームの送信者は、RTPことを確実にするために、このような符号化メディアフレームまたはフレームスキップの廃棄などの追加のアクションを実装することができますキューはすぐに排出されます。フレームレートの結果をスキップフレームが一時的に低下しています。使用する方法を、設計上の選択であり、このアルゴリズム記述の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Detailed Description of SCReAM
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SCREAMの4.詳細な説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. SCReAM Sender
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. スクリームの送信者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the sender-side algorithm in more detail. It is split between the network congestion control, sender transmission control, and media rate control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、より詳細に、送信者側のアルゴリズムを記述しています。これは、ネットワークの輻輳制御、送信側伝送制御、およびメディア・レート制御の間で分割されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SCReAM sender implements media rate control and an RTP queue for each media type or source, where RTP packets containing encoded media frames are temporarily stored for transmission. Figure 1 shows the details when a single media source (or stream) is used. A transmission scheduler (not shown in the figure) is added to support multiple streams. The transmission scheduler can enforce differing priorities between the streams and act like a coupled congestion controller for multiple flows. Support for multiple streams is implemented in [SCReAM-CPP-implementation].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スクリーム送信者は、メディア速度制御及び符号化されたメディアフレームを含むRTPパケットが一時的に伝送するために記憶されている各メディアタイプまたはソースのためのRTPキューを実装します。図1は、単一のメディアソース（またはストリーム）が使用されている詳細を示しています。送信スケジューラは、（図示しない）複数のストリームをサポートするために追加されます。送信スケジューラは、複数のフローのために結合された輻輳制御装置のような流れと行為の間に異なる優先度を適用することができます。複数のストリームのサポートは[スクリーム-CPP-実装]に実装されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Media frames are encoded and forwarded to the RTP queue (1) in Figure 1. The media rate adaptation adapts to the size of the RTP queue (2) and provides a target rate for the media encoder (3). The RTP packets are picked from the RTP queue (4), for multiple flows from each RTP queue based on some defined priority order or simply in a round-robin fashion, by the sender transmission controller. The sender transmission controller (in case of multiple flows a transmission scheduler) sends the RTP packets to the UDP socket (5). In the general case, all media SHOULD go through the sender transmission controller and is limited so that the number of bytes in flight is less than the congestion window. RTCP packets are received (6) and the information about the bytes in flight and congestion window is exchanged between the network congestion control and the sender transmission control (7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メディアフレームは、メディアレート適応は、RTPキュー（2）のサイズに適応し、メディアエンコーダ（3）のための目標速度を提供する符号化され、図1にRTPキュー（1）に転送されます。 RTPパケットは、送信元送信制御部によって、いくつかの定義された優先順位にまたは単にラウンドロビン方式に基づいて、各RTPキューから複数のフローのために、RTPキュー（4）から採取されます。送信側伝送制御装置（複数の場合には、送信スケジューラを流れる）UDPソケットにRTPパケットを送信する（5）。一般的な場合では、すべてのメディアは、送信者の送信制御部を通過し、飛行中のバイト数が輻輳ウィンドウよりも小さくなるように制限されるべきです。 RTCPパケットは、（6）受信され、飛行中のバイト数および輻輳ウィンドウに関する情報は、ネットワーク輻輳制御及び送信側伝送制御（7）との間で交換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Constants and Parameter Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. 定数およびパラメータ値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Constants and state variables are listed in this section. Temporary variables are not listed; instead, they are appended with &#39;_t&#39; in the pseudocode to indicate their local scope.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定数と状態変数は、このセクションに記載されています。一時的な変数が表示されていません。代わりに、彼らはローカルスコープを示すために、擬似コードで「_t」が付加されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1.1. Constants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1.1。定数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RECOMMENDED values, within parentheses &#34;()&#34;, for the constants are deduced from experiments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定数の括弧内の推奨値は、「（）」、実験から推定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QDELAY_TARGET_LO (0.1 s) Target value for the minimum qdelay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小qdelayためQDELAY_TARGET_LO（0.1秒）が目標値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QDELAY_TARGET_HI (0.4 s) Target value for the maximum qdelay. This parameter provides an upper limit to how much the target qdelay (qdelay_target) can be increased in order to cope with competing loss-based flows. However, the target qdelay does not have to be initialized to this high value, as it would increase end-to-end delay and also make the rate control and congestion control loops sluggish.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大qdelayためQDELAY_TARGET_HI（0.4秒）が目標値。このパラメータは、ターゲットqdelay（qdelay_target）が競合損失ベースのフローに対応するために増加させることができるどのくらいに上限を提供します。それは、エンドツーエンド遅延が増加し、また、レート制御と輻輳制御が低迷ループになるだろうしかし、ターゲットqdelayは、この高い値に初期化する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QDELAY_WEIGHT (0.1) Averaging factor for qdelay_fraction_avg.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_fraction_avgためQDELAY_WEIGHT（0.1）平均化係数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QDELAY_TREND_TH (0.2) Threshold for the detection of incipient congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期輻輳を検出するためのQDELAY_TREND_TH（0.2）が閾値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MIN_CWND (3000 bytes) Minimum congestion window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MIN_CWND（3000バイト）の最小輻輳ウィンドウ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAX_BYTES_IN_FLIGHT_HEAD_ROOM (1.1) Headroom for the limitation of CWND.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAX_BYTES_IN_FLIGHT_HEAD_ROOM CWNDの制限のために（1.1）ヘッドルーム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GAIN (1.0) Gain factor for congestion window adjustment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GAIN（1.0）輻輳ウィンドウの調整のための係数を得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BETA_LOSS (0.8) CWND scale factor due to loss event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
損失事象に起因BETA_LOSS（0.8）CWNDスケールファクタ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BETA_ECN (0.9) CWND scale factor due to ECN event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECNイベントに起因BETA_ECN（0.9）CWNDスケールファクタ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BETA_R (0.9) Scale factor for target rate due to loss event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目標レートのために起因する損失イベントにBETA_R（0.9）スケールファクタ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MSS (1000 byte) Maximum segment size = Max RTP packet size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MSS（1,000バイト）最大セグメントサイズ=最大RTPパケットサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RATE_ADJUST_INTERVAL (0.2 s) Interval between media bitrate adjustments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メディアビットレート調整の間RATE_ADJUST_INTERVAL（0.2秒）間隔。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TARGET_BITRATE_MIN Minimum target bitrate in bps (bits per second).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TARGET_BITRATE_MIN最小BPSにおける目標ビットレート（ビット毎秒）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TARGET_BITRATE_MAX Maximum target bitrate in bps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BPSでTARGET_BITRATE_MAX最大目標ビットレート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RAMP_UP_SPEED (200000 bps/s) Maximum allowed rate increase speed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RAMP_UP_SPEED（200000のBPS / s）の最大許容レートの増加速度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRE_CONGESTION_GUARD (0.0..1.0) Guard factor against early congestion onset. A higher value gives less jitter, possibly at the expense of a lower link utilization. This value MAY be subject to tuning depending on e.g., media coder characteristics. Experiments with H264 and VP8 indicate that 0.1 is a suitable value. See [SCReAM-CPP-implementation] and [SCReAM-implementation-experience] for evaluation of a real implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
早期輻輳発症に対するPRE_CONGESTION_GUARD（0.0..1.0）ガード要因。高い値は、おそらく下のリンク利用を犠牲にして、以下のジッタを提供します。この値は、例えば、メディア符号化特性に応じてチューニングを受ける可能性があります。 H264およびVP8を用いた実験は、0.1が適切な値であることを示しています。実際の実装の評価のために[SCREAM-CPP-実装]を参照してくださいし、[SCREAM-実装経験]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TX_QUEUE_SIZE_FACTOR (0.0..2.0) Guard factor against RTP queue buildup. This value MAY be subject to tuning depending on, e.g., media coder characteristics. Experiments with H264 and VP8 indicate that 1.0 is a suitable value. See [SCReAM-CPP-implementation] and [SCReAM-implementation-experience] for evaluation of a real implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPキュー蓄積に対するTX_QUEUE_SIZE_FACTOR（0.0..2.0）ガード要因。この値は、例えば、メディア符号化特性に応じてチューニングを受ける可能性があります。 H264およびVP8を用いた実験では1.0が適切な値であることを示しています。実際の実装の評価のために[SCREAM-CPP-実装]を参照してくださいし、[SCREAM-実装経験]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP_QDELAY_TH (0.02 s) RTP queue delay threshold for a target rate reduction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目標レート低減のためRTP_QDELAY_TH（0.02秒）RTPキュー遅延しきい値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TARGET_RATE_SCALE_RTP_QDELAY (0.95) Scale factor for target rate when RTP qdelay threshold exceeds RTP_QDELAY_TH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TARGET_RATE_SCALE_RTP_QDELAY RTPのqdelay閾値はRTP_QDELAY_THを超える目標レートに対して（0.95）スケール因子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QDELAY_TREND_LO (0.2) Threshold value for qdelay_trend.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_trendためQDELAY_TREND_LO（0.2）が閾値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
T_RESUME_FAST_INCREASE (5 s) Time span until fast increase mode can be resumed, given that the qdelay_trend is below QDELAY_TREND_LO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速増加モードまでT_RESUME_FAST_INCREASE（5秒）の時間スパンはqdelay_trendがQDELAY_TREND_LO未満であることを考えると、再開することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RATE_PACE_MIN (50000 bps) Minimum pacing rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RATE_PACE_MIN（50000 bpsの）最小ペーシングレート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1.2. State Variables
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1.2。状態変数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values within parentheses &#34;()&#34; indicate initial values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
括弧内の値は、「（）」の初期値を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_target (QDELAY_TARGET_LO) qdelay target, a variable qdelay target is introduced to manage cases where a fixed qdelay target would otherwise starve the RMCAT flow under such circumstances (e.g., FTP competes for the bandwidth over the same bottleneck). The qdelay target is allowed to vary between QDELAY_TARGET_LO and QDELAY_TARGET_HI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_target（QDELAY_TARGET_LO）qdelay対象、可変qdelayターゲットは、固定qdelay対象がそうでなければそのような状況（例えば、FTPは同じボトルネック上の帯域幅について競合する）下RMCATフローを餓死になるケースを管理するために導入されます。 qdelayターゲットはQDELAY_TARGET_LOとQDELAY_TARGET_HIとの間で変化することが許されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_fraction_avg (0.0) Fractional qdelay filtered by the Exponentially Weighted Moving Average (EWMA).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_fraction_avg指数加重移動平均（EWMA）によってフィルタリング（0.0）フラクショナルqdelay。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_fraction_hist[20] ({0,..,0}) Vector of the last 20 fractional qdelay samples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_fraction_hist [20]（{0、...、0}）最後に20個の分数qdelayサンプルのベクトル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_trend (0.0) qdelay trend; indicates incipient congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_trend（0.0）qdelayトレンド。初期輻輳を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_trend_mem (0.0) Low-pass filtered version of qdelay_trend.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_trend_mem qdelay_trendの（0.0）ローパスフィルタリングされたバージョン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_norm_hist[100] ({0,..,0}) Vector of the last 100 normalized qdelay samples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_norm_hist [100]（{0、...、0}）最後の100個の正規qdelayサンプルのベクトル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in_fast_increase (true) True if in fast increase mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in_fast_increase（真）、高速増加モードの場合はtrue。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cwnd (MIN_CWND) Congestion window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CWND（MIN_CWND）輻輳ウィンドウ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bytes_newly_acked (0) The number of bytes that was acknowledged with the last received acknowledgement, i.e., bytes acknowledged since the last CWND update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bytes_newly_acked（0）最後に受信した確認応答で認められたバイト数、すなわち、最後のCWND更新以来認めバイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max_bytes_in_flight (0) The maximum number of bytes in flight over a sliding time window, i.e., transmitted but not yet acknowledged bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max_bytes_in_flight（0）はスライディングタイムウィンドウにわたって飛行中の最大バイト数は、即ち、送信まだバイトを認めません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
send_wnd (0) Upper limit to how many bytes can currently be transmitted. Updated when cwnd is updated and when RTP packet is transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
send_wnd現在送信することができるどのように多くのバイト（0）が上限。 cwndが更新されたときに更新され、RTPパケットが送信される場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
target_bitrate (0 bps) Media target bitrate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
target_bitrate（0 BPS）メディアのターゲットビットレート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
target_bitrate_last_max (1 bps) Inflection point of the media target bitrate, i.e., the last known highest target_bitrate. Used to limit bitrate increase speed close to the last known congestion point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メディアターゲットビットレートのtarget_bitrate_last_max（1つのBPS）変曲点、すなわち、最後の既知の最高target_bitrate。最後の既知の輻輳点に近いビットレートの増加速度を制限するために使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_transmit (0.0 bps) Measured transmit bitrate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_transmit（0.0 BPS）測定送信ビットレート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_ack (0.0 bps) Measured throughput based on received acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_ack（0.0 BPS）は、受信確認応答に基づいて測定されたスループット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_media (0.0 bps) Measured bitrate from the media encoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_media（0.0 BPS）は、メディアエンコーダからビットレートを測定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_media_median (0.0 bps) Median value of rate_media, computed over more than 10 s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_media_median（0.0 BPS）rate_mediaの中央値は、10秒以上にわたって計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
s_rtt (0.0s) Smoothed RTT (in seconds), computed with a similar method to that described in [RFC6298].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298]で説明したのと同様の方法で計算s_rtt（0.0s）（秒）平滑化RTT、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rtp_queue_size (0 bits) Sum of the sizes of RTP packets in queue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rtp_queue_size（0ビット）キュー内のRTPパケットの合計サイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rtp_size (0 byte) Size of the last transmitted RTP packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に送信されたRTPパケットのrtp_size（0バイト）のサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
loss_event_rate (0.0) The estimated fraction of RTTs with lost packets detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
loss_event_rate（0.0）検出された失われたパケットとのRTTの推定分数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Network Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. ネットワーク輻輳制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section explains the network congestion control, which performs two main functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、2つの主要な機能を実行するネットワークの輻輳制御を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Computation of congestion window at the sender: This gives an upper limit to the number of bytes in flight.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信側の輻輳ウィンドウの計算○：これは、飛行中のバイト数に上限を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Calculation of send window at the sender: RTP packets are transmitted if allowed by the relation between the number of bytes in flight and the congestion window. This is controlled by the send window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの計算は、送信者にウィンドウを送る：飛行中のバイト数および輻輳ウィンドウとの関係で許可されていればRTPパケットが送信されます。これは、送信ウィンドウによって制御されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCReAM is a window-based and byte-oriented congestion control protocol, where the number of bytes transmitted is inferred from the size of the transmitted RTP packets. Thus, a list of transmitted RTP packets and their respective transmission times (wall-clock time) MUST be kept for further calculation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スクリームは、送信されたバイト数が送信されたRTPパケットのサイズから推測されるウィンドウベースとバイト指向の輻輳制御プロトコルです。したがって、送信されたRTPパケットとそれらのそれぞれの伝送時間（ウォールクロック時間）のリストは、さらなる計算のために保持しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The number of bytes in flight (bytes_in_flight) is computed as the sum of the sizes of the RTP packets ranging from the RTP packet most recently transmitted, down to but not including the acknowledged packet with the highest sequence number. This can be translated to the difference between the highest transmitted byte sequence number and the highest acknowledged byte sequence number. As an example: If an RTP packet with sequence number SN is transmitted and the last acknowledgement indicates SN-5 as the highest received sequence number, then bytes_in_flight is computed as the sum of the size of RTP packets with sequence number SN-4, SN-3, SN-2, SN-1, and SN. It does not matter if, for instance, the packet with sequence number SN-3 was lost -- the size of RTP packet with sequence number SN-3 will still be considered in the computation of bytes_in_flight.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
飛行中のバイト数（bytes_in_flight）はシーケンス番号が最大である定評パケットを含むまでではなく、最も最近に送信されたRTPパケットに至るまでRTPパケットのサイズの合計として計算されます。これは、最も高い透過バイトのシーケンス番号と最高認めバイトのシーケンス番号の差に変換することができます。例として：シーケンス番号SNのRTPパケットが送信され、最後の確認応答が最高受信シーケンス番号としてSN-5を示している場合、シーケンス番号SN-4、SNのRTPパケットのサイズの和として計算されるbytes_in_flight -3、SN-2、SN-1、およびSN。シーケンス番号SN-3のRTPパケットのサイズは、まだbytes_in_flightの計算に考慮されます - 例えば、シーケンス番号SN-3のパケットが失われた、かどうかは問題ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, a variable bytes_newly_acked is incremented with a value corresponding to how much the highest sequence number has increased since the last feedback. As an example: If the previous acknowledgement indicated the highest sequence number N and the new acknowledgement indicated N+3, then bytes_newly_acked is incremented by a value equal to the sum of the sizes of RTP packets with sequence number N+1, N+2, and N+3. Packets that are lost are also included, which means that even though, e.g., packet N+2 was lost, its size is still included in the update of bytes_newly_acked. The bytes_newly_acked variable is reset to zero after a CWND update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、bytes_newly_acked変数は最高のシーケンス番号が、最後のフィードバック以降増加しているどのくらいに相当する値でインクリメントされます。例として：シーケンス番号N + 1のRTPパケットのサイズの合計に等しい値だけインクリメント以前の肯定応答は、最も高いシーケンス番号Nと新しい確認応答は、次にbytes_newly_acked、N + 3を示し示される場合、N + 2 、およびN + 3。失われたパケットもbytes_newly_ackedであっても、例えば、N + 2が失われたパケットは、そのサイズがまだ更新に含まれることを意味し、含まれています。 bytes_newly_acked変数はCWND更新後にゼロにリセットされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The feedback from the receiver is assumed to consist of the following elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機からのフィードバックは、次の要素から構成されているものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A list of received RTP packets&#39; sequence numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したRTPパケットのシーケンス番号のリストO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The wall-clock timestamp corresponding to the received RTP packet with the highest sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oウォールクロックタイムスタンプは、最も高いシーケンス番号を有する受信したRTPパケットに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The accumulated number of ECN-CE-marked packets (n_ECN). Here, &#34;CE&#34; refers to &#34;Congestion Experienced&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECN-CEマーク付きのパケット（n_ECN）の累積数O。ここで、「CE」は「輻輳が経験」を指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the sender receives RTCP feedback, the qdelay is calculated as outlined in [RFC6817]. A qdelay sample is obtained for each received acknowledgement. No smoothing of the qdelay is performed; however, some smoothing occurs anyway because the CWND computation is a low-pass filter function. A number of variables are updated as illustrated by the pseudocode below; temporary variables are appended with &#39;_t&#39;. As mentioned in Section 6, calculation of the proper congestion window and media bitrate may benefit from additional optimizations to handle very high and very low bitrates, and from additional damping to handle periodic packet bursts. Some such optimizations are implemented in [SCReAM-CPP-implementation], but they do not form part of the specification of SCReAM at this time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者がRTCPフィードバックを受信した場合、[RFC6817]に概説するように、qdelayが算出されます。 qdelayサンプルは、各受信された肯定応答を得られます。 qdelayのいかなる平滑化が実行されません。 CWND計算は、ローパスフィルタ機能であるためしかし、いくつかの平滑化は、とにかく起こります。以下の擬似コードによって示されるように、変数の数が更新されます。一時変数を「_t」が付加されています。第6節で述べたように、適切な輻輳ウィンドウとメディアビットレートの計算は非常に高く、非常に低いビットレートを処理するために追加の最適化から利益を得ることができる、及び付加減衰から周期パケットバーストを処理します。いくつかのような最適化は、[SCREAM-CPP-実装]で実装されているが、彼らは、この時点でのスクリームの明細書の一部を形成するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;CODE BEGINS&gt; update_variables(qdelay): qdelay_fraction_t = qdelay / qdelay_target # Calculate moving average qdelay_fraction_avg = (1 - QDELAY_WEIGHT) * qdelay_fraction_avg + QDELAY_WEIGHT * qdelay_fraction_t update_qdelay_fraction_hist(qdelay_fraction_t) # Compute the average of the values in qdelay_fraction_hist avg_t = average(qdelay_fraction_hist) # R is an autocorrelation function of qdelay_fraction_hist, # with the mean (DC component) removed, at lag K # The subtraction of the scalar avg_t from # qdelay_fraction_hist is performed element-wise a_t = R(qdelay_fraction_hist-avg_t, 1) / R(qdelay_fraction_hist-avg_t, 0) # Calculate qdelay trend qdelay_trend = min(1.0, max(0.0, a_t * qdelay_fraction_avg)) # Calculate a &#39;peak-hold&#39; qdelay_trend; this gives a memory # of congestion in the past qdelay_trend_mem = max(0.99 * qdelay_trend_mem, qdelay_trend) &lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
update_variables（qdelay）&lt;CODEが始まる&gt;：qdelay_fraction_t = qdelay / qdelay_target＃平均qdelay_fraction_avg =（1  -  QDELAY_WEIGHT）移動計算* qdelay_fraction_avg + QDELAY_WEIGHT * qdelay_fraction_tのupdate_qdelay_fraction_hist（qdelay_fraction_t）＃はqdelay_fraction_hist avg_t =平均（qdelay_fraction_hist）の値の平均を計算します＃Rは、qdelay_fraction_histの自己相関関数である平均（DC成分）を除去と＃、ラグK位に＃qdelay_fraction_histからスカラーavg_tの減算は要素ごとA_tと= R（qdelay_fraction_hist-avg_t、1）/ R（実行されますqdelay_fraction_hist-avg_t、0）＃を計算qdelay傾向qdelay_trend =分（1.0、MAX（0.0、A_tと* qdelay_fraction_avg））＃ &#39;ピークホールド&#39; qdelay_trendを計算します。これは&lt;CODEが終了&gt;過去qdelay_trend_mem = MAX（150 * qdelay_trend_mem、qdelay_trend）に輻輳のメモリ＃を与えます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The qdelay fraction is sampled every 50 ms, and the last 20 samples are stored in a vector (qdelay_fraction_hist). This vector is used in the computation of a qdelay trend that gives a value between 0.0 and 1.0 depending on the estimated congestion level. The prediction coefficient &#39;a_t&#39; has positive values if qdelay shows an increasing or decreasing trend; thus, an indication of congestion is obtained before the qdelay target is reached. As a side effect, if qdelay decreases, it&#39;s taken as a sign of congestion; however, experiments have shown that this is beneficial, as increasing or decreasing queue delay is an indication that the transmit rate is very close to the path capacity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay分率は50ms毎にサンプリングされ、そして最後の20個のサンプルは、ベクター（qdelay_fraction_hist）に格納されています。このベクターは、推定された輻輳レベルに応じて0.0と1.0の間の値を与えるqdelay傾向の計算に使用されます。 qdelayが増加または減少傾向を示す場合予測係数「A_tと」は正の値を有します。 qdelayターゲットに到達する前にこのように、輻輳の指標が得られます。 qdelayが減少した場合の副作用として、それは輻輳の兆候としています。しかし、実験では、キュー遅延を増減する送信レートは、パス能力に非常に近いことを示しているように、これは、有益であることが示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The autocorrelation function &#39;R&#39; is defined as follows. Let x be a vector constituting N values, the biased autocorrelation function for a given lag=k for the vector x is given by.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように自己相関関数R「」が定義されています。 X所与の遅延のためのN値を構成するベクター、バイアスされた自己相関関数で=ベクトルxに対するkは次式で与えられてみよう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                 n=N-k
         R(x,k) = SUM x(n) * x(n + k)
                 n=1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prediction coefficient is further multiplied with qdelay_fraction_avg to reduce sensitivity to increasing qdelay when it is very small. The 50 ms sampling is a simplification that could have the effect that the same qdelay is sampled several times; however, this does not pose any problem, as the vector is only used to determine if the qdelay is increasing or decreasing. The qdelay_trend is utilized in the media rate control to indicate incipient congestion and to determine when to exit from fast increase mode. qdelay_trend_mem is used to enforce a less aggressive rate increase after congestion events. The function update_qdelay_fraction_hist(..) removes the oldest element and adds the latest qdelay_fraction element to the qdelay_fraction_hist vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予測係数は、さらに、それが非常に小さい場合qdelay増加に対する感度を低減するためにqdelay_fraction_avgと乗算されます。 50ミリ秒のサンプリングは、同じqdelayを複数回サンプリングされる効果を有する可能性が簡略化です。ベクターのみqdelayが増加または減少しているかどうかを決定するために使用されるが、これは、問題を提起しません。 qdelay_trendは、初期の輻輳を指示するとき、高速増加モードを終了するかを決定するためにメディア・レート制御に利用されます。 qdelay_trend_memは輻輳イベントの後にあまり積極的で速度増加を強制するために使用されます。関数update_qdelay_fraction_hist（..）は最も古い要素を削除し、qdelay_fraction_histベクトルに最新qdelay_fraction要素が追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.1. Reaction to Packet Loss and ECN
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.1。パケット損失やECNへの反応
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A loss event is indicated if one or more RTP packets are declared missing. The loss detection is described in Section 4.1.2.4. Once a loss event is detected, further detected lost RTP packets SHOULD be ignored for a full smoothed round-trip time; the intention is to limit the congestion window decrease to at most once per round trip.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つ以上のRTPパケットが欠落していると宣言された場合の損失イベントが表示されます。損失の検出は、4.1.2.4節に記述されています。損失事象が検出されると、さらに失われたRTPパケットは、完全な平滑化往復時間のために無視されるべき検出。その意図は、最高1回のラウンドトリップごとに輻輳ウィンドウの減少を制限することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The congestion window back-off due to loss events is deliberately a bit less than is the case with TCP Reno, for example. TCP is generally used to transmit whole files; the file is then like a source with an infinite bitrate until the whole file has been transmitted. SCReAM, on the other hand, has a source whose rate is limited to a value close to the available transmit rate and often below that value; the effect is that SCReAM has less opportunity to grab free capacity than a TCP-based file transfer. To compensate for this, it is RECOMMENDED to let SCReAM reduce the congestion window less than what is the case with TCP when loss events occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳ウィンドウ損失事象に起因するバックオフが故意例えば、TCPリノの場合よりも少し小さいです。 TCPは、一般的に、全体のファイルを送信するために使用されます。ファイル全体が送信されるまでファイルは無限のビットレートとの源のように、その後です。スクリームは、一方で、その速度利用可能な送信レートに近く、多くの場合、その値以下の値に制限されたソースを有します。効果はSCREAMは、TCPベースのファイル転送よりも空き容量をつかむために少ないチャンスを持っていることです。これを補うために、悲鳴が少ない損失事象が発生したTCPの場合のものよりも輻輳ウィンドウを縮小させるために推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An ECN event is detected if the n_ECN counter in the feedback report has increased since the previous received feedback. Once an ECN event is detected, the n_ECN counter is ignored for a full smoothed round-trip time; the intention is to limit the congestion window decrease to at most once per round trip. The congestion window back-off due to an ECN event MAY be smaller than if a loss event occurs. This is in line with the idea outlined in [ALT-BACKOFF] to enable ECN marking thresholds lower than the corresponding packet drop thresholds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィードバックレポートでn_ECNカウンタが前回受け取ったフィードバック以降増加している場合ECNイベントが検出されました。 ECNイベントが検出されると、n_ECNカウンタはフル平滑化往復時間では無視されます。その意図は、最高1回のラウンドトリップごとに輻輳ウィンドウの減少を制限することです。バックオフによるECNイベントに輻輳ウィンドウは、損失事象が発生した場合よりも小さくすることができます。これは、対応するパケットのドロップしきい値より低いしきい値をECNマーキングを可能にするために、[ALT-BACKOFF]に概説考えと一致しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.2. Congestion Window Update
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.2。輻輳ウィンドウの更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The update of the congestion window depends on if loss, ECN-marking, or neither of the two occurs. The pseudocode below describes the actions for each case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
損失は​​、ECN-マーキング、または2のどちらが発生した場合、輻輳ウィンドウの更新が依存します。擬似コードは、以下の各ケースのアクションについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;CODE BEGINS&gt; on congestion event(qdelay): # Either loss or ECN mark is detected in_fast_increase = false if (is loss) # Loss is detected cwnd = max(MIN_CWND, cwnd * BETA_LOSS) else # No loss, so it is then an ECN mark cwnd = max(MIN_CWND, cwnd * BETA_ECN) end adjust_qdelay_target(qdelay) #compensating for competing flows calculate_send_window(qdelay, qdelay_target)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
輻輳イベント（qdelay）に&lt;CODEが開始されます&gt;：それはその後になるようです（損失）＃損失は、CWND = MAX（MIN_CWND、CWND * BETA_LOSS）他＃損失なし検出された場合、＃のいずれかの損失やECNマークがin_fast_increase = falseを検出しましたフローの競合のため#compensating ECNマークのcwnd = MAX（MIN_CWND、CWND * BETA_ECN）エンドadjust_qdelay_target（qdelay）がcalculate_send_window（qdelay、qdelay_target）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
# When no congestion event on acknowledgement(qdelay): update_bytes_newly_acked() update_cwnd(bytes_newly_acked) adjust_qdelay_target(qdelay) # compensating for competing flows calculate_send_window(qdelay, qdelay_target) check_to_resume_fast_increase() &lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
肯定応答（qdelay）に輻輳イベント＃：update_bytes_newly_acked（）update_cwnd（bytes_newly_acked）adjust_qdelay_target（qdelay）＃は、競合フローを補償しないが（（qdelay、qdelay_target）check_to_resume_fast_increaseをcalculate_send_window）&lt;CODEが終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The methods are described in detail below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
方法は、以下に詳細に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The congestion window update is based on qdelay, except for the occurrence of loss events (one or more lost RTP packets in one RTT) or ECN events, which were described earlier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳ウィンドウの更新は、前述した損失事象の発生（1 RTT内の1つまたは複数の失われたRTPパケット）またはECNイベントを除き、qdelayに基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pseudocode for the update of the congestion window is found below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳ウィンドウの更新のための擬似コードは、以下の発見されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt; update_cwnd(bytes_newly_acked): # In fast increase mode? if (in_fast_increase) if (qdelay_trend &gt;= QDELAY_TREND_TH) # Incipient congestion detected; exit fast increase mode in_fast_increase = false else # No congestion yet; increase cwnd if it # is sufficiently used # Additional slack of bytes_newly_acked is # added to ensure that CWND growth occurs # even when feedback is sparse if (bytes_in_flight * 1.5 + bytes_newly_acked &gt; cwnd) cwnd = cwnd + bytes_newly_acked end return end end
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが始まる&gt; update_cwnd（bytes_newly_acked）：速い上昇モードでは＃？ IF（qdelay_trend&gt; = QDELAY_TREND_TH）＃初生輻輳が検出された場合（in_fast_increase）。終了速い増加はまだありません＃混雑そうでない場合はfalseモードin_fast_increase =;それは＃が十分にされてbytes_newly_acked＃の＃追加のたるみを使用している場合にcwndを増加すると、そのCWND成長＃フィードバックはまばらである場合でも（bytes_in_flight * 1.5 + bytes_newly_acked&gt;のcwnd）のcwnd = cwndを+ bytes_newly_ackedエンド・リターン・エンド・エンドの発生を確実にするために追加しました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
# Not in fast increase mode # off_target calculated as with LEDBAT off_target_t = (qdelay_target - qdelay) / qdelay_target
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
/ qdelay_target  - ＃速く増加モード＃のoff_targetはLEDBATのoff_target_t =（qdelay qdelay_target）のように計算されていません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
gain_t = GAIN # Adjust congestion window cwnd_delta_t = gain_t * off_target_t * bytes_newly_acked * MSS / cwnd if (off_target_t &gt; 0 &amp;&amp; bytes_in_flight * 1.25 + bytes_newly_acked &lt;= cwnd) # No cwnd increase if window is underutilized # Additional slack of bytes_newly_acked is # added to ensure that CWND growth occurs # even when feedback is sparse cwnd_delta_t = 0; end
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
gain_tウィンドウがbytes_newly_ackedの＃追加のたるみを十分に活用されている場合= GAIN＃は輻輳ウィンドウcwnd_delta_t = gain_t * off_target_t * bytes_newly_acked * MSS / cwndの場合（off_target_t&gt; 0 &amp;&amp; bytes_in_flight * bytes_newly_acked 1.25 + &lt;=のcwnd）＃ないのcwndの増加を調整します。＃が追加されますフィードバックが疎cwnd_delta_t = 0であってもCWND成長が＃を発生することを確実にします。終わり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
# Apply delta cwnd += cwnd_delta_t # limit cwnd to the maximum number of bytes in flight cwnd = min(cwnd, max_bytes_in_flight * MAX_BYTES_IN_FLIGHT_HEAD_ROOM) cwnd = max(cwnd, MIN_CWND)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
＃飛行CWND =分の最大バイト数（CWND、max_bytes_in_flight * MAX_BYTES_IN_FLIGHT_HEAD_ROOM）CWND = MAX（CWND、MIN_CWND）にデルタCWND + = cwnd_delta_t位リミットCWNDを適用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEはENDS&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CWND is updated differently depending on whether or not the congestion control is in fast increase mode, as controlled by the variable in_fast_increase.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変数in_fast_increaseによって制御されるようCWNDは、輻輳制御は、高速増加モードであるか否かに応じて異なる更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in fast increase mode, the congestion window is increased with the number of newly acknowledged bytes as long as the window is sufficiently used. Sparse feedback can potentially limit congestion window growth; therefore, additional slack is added, given by the number of newly acknowledged bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
速い上昇モードでは、輻輳ウィンドウは限りウィンドウが十分に使用されているとして、新たに認めたバイト数を増加させた場合。スパースフィードバックは、潜在的に輻輳ウィンドウの成長を制限することができます。従って、追加のスラックは、新たに受け付けたバイト数によって与えられ、加算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The congestion window growth when in_fast_increase is false is dictated by the relation between qdelay and qdelay_target; congestion window growth is limited if the window is not used sufficiently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in_fast_increaseはqdelayとqdelay_targetとの関係によって決定された偽の輻輳ウィンドウの成長;ウィンドウが十分に使用されていない場合には、輻輳ウィンドウの成長が限定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCReAM calculates the GAIN in a similar way to what is specified in [RFC6817]. However, [RFC6817] specifies that the CWND increase is limited by an additional function controlled by a constant ALLOWED_INCREASE. This additional limitation is removed in this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スクリームは[RFC6817]で指定されているものと同様のゲインを算出します。しかしながら、[RFC6817]はCWNDの増加が一定ALLOWED_INCREASEによって制御される付加機能によって制限されることを指定します。この追加の制限は、本明細書中に除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Further, the CWND is limited by max_bytes_in_flight and MIN_CWND. The limitation of the congestion window by the maximum number of bytes in flight over the last 5 seconds (max_bytes_in_flight) avoids possible overestimation of the throughput after, for example, idle periods. An additional MAX_BYTES_IN_FLIGHT_HEAD_ROOM provides slack to allow for a certain amount of variability in the media coder output rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、CWNDはmax_bytes_in_flightとMIN_CWNDによって制限されています。最後の5秒（max_bytes_in_flight）上飛行中の最大バイト数による輻輳ウィンドウの制限は、例えば、アイドル期間後スループットの可能な過大評価を回避します。追加MAX_BYTES_IN_FLIGHT_HEAD_ROOMメディアコーダ出力速度の変動の一定量を可能にするためにたるみを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.3. Competing Flows Compensation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.3。競合フロー報酬
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is likely that a flow using the SCReAM algorithm will have to share congested bottlenecks with other flows that use a more aggressive congestion control algorithm (for example, large FTP flows using loss-based congestion control). The worst condition occurs when the bottleneck queues are of tail-drop type with a large buffer size. SCReAM takes care of such situations by adjusting the qdelay_target when loss-based flows are detected, as shown in the pseudocode below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCREAMアルゴリズムを使用して流れがより積極的な輻輳制御アルゴリズム（例えば、大規模なFTP、損失ベースの輻輳制御を使用して流れる）を使用する他のフローと輻輳ボトルネックを共有しなければならない可能性があります。ボトルネックキューが大きなバッファサイズを持つテールドロップタイプであるとき、最悪の状態が発生します。スクリームは、損失ベースのフローが検出されると、以下の擬似コードに示すように、qdelay_targetを調整することにより、このような状況の世話をします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;CODE BEGINS&gt; adjust_qdelay_target(qdelay) qdelay_norm_t = qdelay / QDELAY_TARGET_LOW update_qdelay_norm_history(qdelay_norm_t) # Compute variance qdelay_norm_var_t = VARIANCE(qdelay_norm_history(200)) # Compensation for competing traffic # Compute average qdelay_norm_avg_t = AVERAGE(qdelay_norm_history(50)) # Compute upper limit to target delay new_target_t = qdelay_norm_avg_t + sqrt(qdelay_norm_var_t) new_target_t *= QDELAY_TARGET_LO if (loss_event_rate &gt; 0.002) # Packet losses detected qdelay_target = 1.5 * new_target_t else if (qdelay_norm_var_t &lt; 0.2) # Reasonably safe to set target qdelay qdelay_target = new_target_t else # Check if target delay can be reduced; this helps prevent # the target delay from being locked to high values forever if (new_target_t &lt; QDELAY_TARGET_LO) # Decrease target delay quickly, as measured queuing # delay is lower than target qdelay_target = max(qdelay_target * 0.5, new_target_t) else # Decrease target delay slowly qdelay_target *= 0.9 end end end
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
&lt;CODEが開始&gt; adjust_qdelay_target（qdelay）qdelay_norm_t = qdelay / QDELAY_TARGET_LOW update_qdelay_norm_history（qdelay_norm_t）競合トラフィック＃計算平均qdelay_norm_avg_t = AVERAGE（qdelay_norm_history（50））＃計算上限は、＃計算分散qdelay_norm_var_t = VARIANCE（qdelay_norm_history（200））＃補償（qdelay_norm_var_t &lt;0.2）＃目標を設定してかなり安全qdelay qdelay_target = new_target_t他の＃チェック場合（loss_event_rate&gt; 0.002）＃パケット損失が他のnew_target_t * 1.5 = qdelay_targetを検出した場合に遅延new_target_t = qdelay_norm_avg_t + SQRT（qdelay_norm_var_t）new_target_t * = QDELAY_TARGET_LOをターゲットに目標遅延を低減させることができるならば、これは（* 0.5、new_target_t qdelay_target）他に＃を小さく目標遅延永遠に迅速（new_target_t &lt;QDELAY_TARGET_LO）＃の減少対象遅れた場合、測定された＃遅延キューイングするターゲットqdelay_target = maxよりも低い高い値にロックされてから位に目標遅延を防ぐことができますゆっくりqdelay_target * = 0.9エンドエンドエンド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
 # Apply limits qdelay_target = min(QDELAY_TARGET_HI, qdelay_target) qdelay_target = max(QDELAY_TARGET_LO, qdelay_target) &lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
＃制限を適用&lt;CODEが終了&gt; =分（QDELAY_TARGET_HI、qdelay_target）qdelay_target = MAX（QDELAY_TARGET_LO、qdelay_target）qdelay_target
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two temporary variables are calculated. qdelay_norm_avg_t is the long-term average queue delay, qdelay_norm_var_t is the long-term variance of the queue delay. A high qdelay_norm_var_t indicates that the queue delay changes; this can be an indication that bottleneck bandwidth is reduced or that a competing flow has just entered. Thus, it indicates that it is not safe to adjust the queue delay target.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの一時変数が計算されます。 qdelay_norm_avg_tはqdelay_norm_var_tがキュー遅延の長期分散で、長期的な平均キュー遅延です。高qdelay_norm_var_tは、キュー遅延が変化していることを示しています。これは、帯域幅が減少または競合する流れがちょうど入ったことをされたボトルネックに表示することができます。したがって、キュー遅延目標を調整するために安全ではないことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A low qdelay_norm_var_t indicates that the queue delay is relatively stable. The reason could be that the queue delay is low, but it could also be that a competing flow is causing the bottleneck to reach the point that packet losses start to occur, in which case the queue delay will stay relatively high for a longer time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
低qdelay_norm_var_tは、キュー遅延が比較的安定していることを示しています。その理由は、キュー遅延が低いことが考えられますが、それはまた、競合の流れがボトルネックがキュー遅延が長い時間のために、比較的高いままになり、その場合、パケットロスが発生し始めることをポイントに到達する原因になっている可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The queue delay target is allowed to be increased if either the loss event rate is above a given threshold or qdelay_norm_var_t is low. Both these conditions indicate that a competing flow may be present. In all other cases, the queue delay target is decreased.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キュー遅延ターゲットはいずれかの損失イベント率が所定の閾値を上回る又はqdelay_norm_var_tが低い場合に高くすることができます。これらの両方の条件は、競合するフローが存在し得ることを示しています。他のすべての例では、キューの遅延目標は減少します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function that adjusts the qdelay_target is simple and could produce false positives and false negatives. The case that self-inflicted congestion by the SCReAM algorithm may be falsely interpreted as the presence of competing loss-based FTP flows is a false positive. The opposite case -- where the algorithm fails to detect the presence of a competing FTP flow -- is a false negative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
qdelay_targetを調整機能はシンプルで、偽陽性と偽陰性を作り出すことができます。スクリームアルゴリズムによって自傷行為輻輳が誤っ損失ベースのFTP競合の存在として解釈されること場合は、偽陽性で流れます。逆の場合 - アルゴリズムは、競合FTPフローの存在を検出するために失敗した - 偽陰性です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Extensive simulations have shown that the algorithm performs well in LTE test cases and that it also performs well in simple bandwidth-limited bottleneck test cases with competing FTP flows. However, the potential failure of the algorithm cannot be completely ruled out. A false positive (i.e., when self-inflicted congestion is mistakenly identified as competing flows) is especially problematic when it leads to increasing the target queue delay, which can cause the end-to-end delay to increase dramatically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
豊富なシミュレーションは、アルゴリズムは、LTEのテストケースでうまく実行し、それはまた、競合FTPフローに簡単な帯域幅が制限されたボトルネックのテストケースでも実行することが示されています。しかし、アルゴリズムの潜在的な故障を完全に排除することはできません。それはエンドツーエンド遅延が大幅に増加する可能性がターゲットキュー遅延を増加につながる場合、偽陽性（すなわち、自傷行為輻輳が誤っ競合フローとして識別された場合）は特に問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If it is deemed unlikely that competing flows occur over the same bottleneck, the algorithm described in this section MAY be turned off. One such case is QoS-enabled bearers in 3GPP-based access such as LTE. However, when sending over the Internet, often the network conditions are not known for sure, so in general it is not possible to make safe assumptions on how a network is used and whether or not competing flows share the same bottleneck. Therefore, turning this algorithm off must be considered with caution, as it can lead to basically zero throughput if competing with loss-based traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、競合フローは同じボトルネックの上に起こる可能性は低いと判断される場合は、このセクションで説明するアルゴリズムは、オフにすることができます。そのような場合は、LTEのような3GPPベースのアクセスにおけるQoS対応ベアラです。インターネット上で送信するとき、一般的には、ネットワークの使用方法にして、競合するフローは同じボトルネックを共有するかどうか、安全な仮定をすることはできませんので、しかし、多くの場合、ネットワークの状態は、確実に知られていません。損失ベースのトラフィックと競合した場合、それは基本的にゼロスループットにつながることができますしたがって、このアルゴリズムをオフにすることは、慎重に検討する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.4. Lost Packet Detection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.4。ロストパケット検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lost packet detection is based on the received sequence number list. A reordering window SHOULD be applied to prevent packet reordering from triggering loss events. The reordering window is specified as a time unit, similar to the ideas behind Recent ACKnowledgement (RACK) [RACK]. The computation of the reordering window is made possible by means of a lost flag in the list of transmitted RTP packets. This flag is set if the received sequence number list indicates that the given RTP packet is missing. If later feedback indicates that a previously lost marked packet was indeed received, then the reordering window is updated to reflect the reordering delay. The reordering window is given by the difference in time between the event that the packet was marked as lost and the event that it was indicated as successfully received. Loss is detected if a given RTP packet is not acknowledged within a time window (indicated by the reordering window) after an RTP packet with a higher sequence number was acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロストパケット検出は、受信したシーケンス番号のリストに基づいています。並べ替えウィンドウには、損失イベントをトリガするパケットの並べ替えを防ぐために適用されるべきです。再順序付け窓は、最近の肯定応答（RACK）[RACK]後ろのアイデアと同様の時間単位として指定されています。再順序付け窓の計算は、送信されたRTPパケットのリストで失われたフラグによって可能となります。受信したシーケンス番号のリストが与えられたRTPパケットが欠落していることを示している場合、このフラグが設定されています。後でフィードバックが以前に失われたマークされたパケットが実際に受信したことを示す場合、並べ替えウィンドウは、並べ替え遅延を反映するように更新されます。並べ替えウィンドウが失われたとして、パケットがマークされている場合、それが成功したとして示されている受信されたことをイベント間の時間差で与えられます。より高いシーケンス番号を有するRTPパケットが認められた後に所定のRTPパケットを（再順序付け窓で示される）時間ウィンドウ内に確認されない場合に損失が検出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.5. Send Window Calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.5。ウィンドウの計算を送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic design principle behind packet transmission in SCReAM is to allow transmission only if the number of bytes in flight is less than the congestion window. There are, however, two reasons why this strict rule will not work optimally:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCREAMにおけるパケット送信の背後にある基本的な設計原理は、飛行中のバイト数は、輻輳ウィンドウよりも小さい場合にのみ送信を可能にすることです。この厳格なルールが最適に動作しません理由は2つ、しかし、があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Bitrate variations: Media sources such as video encoders generally produce frames whose size always vary to a larger or smaller extent. The RTP queue absorbs the natural variations in frame sizes. However, the RTP queue should be as short as possible to prevent the end-to-end delay from increasing. To achieve that, the media rate control takes the RTP queue size into account when the target bitrate for the media is computed. A strict &#39;send only when bytes in flight is less than the congestion window&#39; rule can cause the RTP queue to grow simply because the send window is limited; in turn, this can cause the target bitrate to be pushed down. The consequence is that the congestion window will not increase, or will increase very slowly, because the congestion window is only allowed to increase when there is a sufficient amount of data in flight. The final effect is that the media bitrate increases very slowly or not at all.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットレート変動（O）、ビデオエンコーダなどのメディアソースは、一般に、サイズが常に大きいまたは小さい程度に変化したフレームを生成します。 RTPキューは、フレームサイズの自然変動を吸収します。しかし、RTPキューの増加をエンドツーエンド遅延を防ぐために、できるだけ短くしてください。メディアのターゲットビットレートが計算されたときにそれを達成するために、メディア・レート制御を考慮にRTPキューのサイズを取ります。厳格な「送るだけで飛行中のバイトは、輻輳ウィンドウよりも小さいときに」送信ウィンドウが限られているため、単純に成長するRTPキューを引き起こす可能性がありますルールは、今度は、これは、ターゲットビットレートが押し下げされることがあります。その結果は、輻輳ウィンドウのみ飛行中に十分な量のデータがある場合に増加することが許可されているので、輻輳ウィンドウは、増加しない、または非常にゆっくりと増加することです。最終的な効果は、すべてのメディアのビットレートが高くなるという非常にゆっくりかではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Reverse (feedback) path congestion: Especially in transport over buffer-bloated networks, the one-way delay in the reverse direction can jump due to congestion. The effect is that the acknowledgements are delayed, and the self-clocking is temporarily halted, even though the forward path is not congested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oリバース（フィードバック）経路の混雑：特にバッファ肥大化ネットワーク上で搬送中の、逆方向の一方向遅延は、輻輳にジャンプすることができます。効果は確認応答が遅れている、と自己クロッキングが一時的順方向経路が混雑していなくても、停止していることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The send window is adjusted depending on qdelay, its relation to the qdelay target, and the relation between the congestion window and the number of bytes in flight. A strict rule is applied when qdelay is higher than qdelay_target, to avoid further queue buildup in the network. For cases when qdelay is lower than the qdelay_target, a more relaxed rule is applied. This allows the bitrate to increase quickly when no congestion is detected while still being able to exhibit stable behavior in congested situations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信ウィンドウはqdelay、qdelayターゲットとの関係、および混雑ウィンドウ及び飛行中のバイト数との関係に応じて調整されます。 qdelayがqdelay_targetより高い場合、厳格なルールは、ネットワーク内のさらにキューの蓄積を回避するために、適用されます。 qdelayがqdelay_targetよりも低い場合は、よりリラックスしたルールが適用されます。これは、輻輳がまだ混雑状況で安定した挙動を示すことができることながら検出されなかった場合、ビットレートが急速に増加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The send window is given by the relation between the adjusted congestion window and the amount of bytes in flight according to the pseudocode below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信ウィンドウが調整された混雑ウィンドウ及び以下の疑似コードに応じて飛行中のバイトの量との関係によって与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt; calculate_send_window(qdelay, qdelay_target) # send window is computed differently depending on congestion level if (qdelay &lt;= qdelay_target) send_wnd = cwnd + MSS - bytes_in_flight else send_wnd = cwnd - bytes_in_flight end &lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt; calculate_send_window（qdelay、qdelay_target）＃ウィンドウを送信する（qdelay &lt;= qdelay_target）send_wnd = CWND + MSS場合輻輳レベルに応じて異なる計算される -  bytes_in_flight他send_wnd = CWND  - エンドbytes_in_flight &lt;CODEが終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The send window is updated whenever an RTP packet is transmitted or an RTCP feedback messaged is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信ウィンドウは、RTPパケットが送信されるたびに更新されるか、メッセージが送らRTCPのフィードバックを受けています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.6. Packet Pacing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.6。パケットペーシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet pacing is used in order to mitigate coalescing, i.e., when packets are transmitted in bursts, with the risks of increased jitter and potentially increased packet loss. Packet pacing also mitigates possible issues with queue overflow due to key-frame generation in video coders. The time interval between consecutive packet transmissions is greater than or equal to t_pace, where t_pace is given by the equations below :
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットペーシングは合体、すなわち、パケットはジッタの増加のリスクと、バーストで送信され、潜在的に増加しているパケット損失を緩和するために使用されます。パケットペーシングはまた、ビデオコーダでのキーフレームの発生によるキューのオーバーフローを持つ可能性の問題を軽減します。連続したパケット伝送間の時間間隔は、以上t_paceは、以下の式によって与えられるt_pace、に等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;CODE BEGINS&gt; pace_bitrate = max (RATE_PACE_MIN, cwnd * 8 / s_rtt) t_pace = rtp_size * 8 / pace_bitrate &lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;CODE BEGINS&gt; pace_bitrate = MAX（RATE_PACE_MIN、CWND * 8 / s_rtt）t_pace = rtp_size * 8 / pace_bitrate &lt;CODEを終了します&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rtp_size is the size of the last transmitted RTP packet, and s_rtt is the smoothed round trip time. RATE_PACE_MIN is the minimum pacing rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rtp_sizeは、最後に送信RTPパケットのサイズで、かつs_rttは平滑化往復時間です。 RATE_PACE_MINは、最小ペーシングレートです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.7. Resuming Fast Increase Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.7。高速増加モードを再開
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fast increase mode can resume in order to speed up the bitrate increase if congestion abates. The condition to resume fast increase mode (in_fast_increase = true) is that qdelay_trend is less than QDELAY_TREND_LO for T_RESUME_FAST_INCREASE seconds or more.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速増加モードは、輻輳が弱まる場合、ビットレートの増加をスピードアップするために再開することができます。速い増加モード（in_fast_increase = true）を再開するための条件はqdelay_trendがT_RESUME_FAST_INCREASE秒以上QDELAY_TREND_LO未満であるということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.8. Stream Prioritization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2.8。ストリームの優先順位付け
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SCReAM algorithm makes a good distinction between network congestion control and media rate control. This is easily extended to many streams -- RTP packets from two or more RTP queues are scheduled at the rate permitted by the network congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCREAMアルゴリズムは、ネットワークの輻輳制御とメディアレート制御との間に良好な区別を行います。これは簡単に多くのストリームに拡張されている - 二つ以上のRTPキューからRTPパケットは、ネットワークの輻輳制御によって許可レートでスケジュールされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The scheduling can be done by means of a few different scheduling regimes. For example, the method for coupled congestion control specified in [COUPLED-CC] can be used. One implementation of SCReAM [SCReAM-CPP-implementation] uses credit-based scheduling. In credit-based scheduling, credit is accumulated by queues as they wait for service and is spent while the queues are being serviced. For instance, if one queue is allowed to transmit 1000 bytes, then a credit of 1000 bytes is allocated to the other unscheduled queues. This principle can be extended to weighted scheduling, where the credit allocated to unscheduled queues depends on the relative weights. The latter is also implemented in [SCReAM-CPP-implementation].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スケジューリングは、いくつかの異なるスケジューリング政権によって行うことができます。例えば、[共役型CC]で指定された結合された輻輳制御のための方法を用いることができます。 SCREAM [SCREAM-CPP-実装]のいずれかの実装では、クレジットベースのスケジューリングを使用しています。彼らはサービスを待って、待ち行列がサービスされている間に費やされているとして、クレジットベースのスケジューリングでは、クレジットはキューによって蓄積されます。 1つのキューが1000のバイトを送信することが許可されている場合たとえば、その後、1000バイトの信用は他の予定外のキューに割り当てられています。この原則は、予定外のキューに割り当てられたクレジットが相対的な重みに依存加重スケジューリング、に拡張することができます。後者はまた、[スクリーム-CPP-実装]に実装されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3. Media Rate Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3. メディアレート制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The media rate control algorithm is executed at regular intervals, indicated by RATE_ADJUSTMENT_INTERVAL, with the exception of a prompt reaction to loss events. The media rate control operates based on the size of the RTP packet send queue and observed loss events. In addition, qdelay_trend is also considered in the media rate control in order to reduce the amount of induced network jitter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メディア・レート制御アルゴリズムは、損失事象に迅速に反応を除いて、RATE_ADJUSTMENT_INTERVALによって示される、規則的な間隔で実行されます。メディアレート制御は、RTPパケットの送信キューのサイズに基づいており、損失事象を観察して動作します。また、qdelay_trendも誘導されるネットワーク・ジッタの量を低減するために、メディア・レート制御であると考えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The role of the media rate control is to strike a reasonable balance between a low amount of queuing in the RTP queue(s) and a sufficient amount of data to send in order to keep the data path busy. Setting the media rate control too cautiously leads to possible underutilization of network capacity; this can cause the flow to become starved out by other more opportunistic traffic. On the other hand, setting it too aggressively leads to increased jitter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メディアレート制御の役割は、多忙なデータパスを維持するために、RTPキュー（複数可）にキューイングの量が少ないと送信するための十分な量のデータとの間に合理的なバランスを取ることです。あまりにも慎重メディアレート制御を設定すると、ネットワーク容量の可能性不十分な利用につながります。これは、流れが、他の多くの日和見トラフィックによって不足になることがあります。一方、あまりにも積極的にそれを設定すると、ジッタの増加につながります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The target_bitrate is adjusted depending on the congestion state. The target bitrate can vary between a minimum value (TARGET_BITRATE_MIN) and a maximum value (TARGET_BITRATE_MAX). TARGET_BITRATE_MIN SHOULD be set to a low enough value to prevent RTP packets from becoming queued up when the network throughput is reduced. The sender SHOULD also be equipped with a mechanism that discards RTP packets when the network throughput becomes very low and RTP packets are excessively delayed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
target_bitrateが輻輳状態に応じて調整されます。目標ビットレートは、最小値（TARGET_BITRATE_MIN）と最大値（TARGET_BITRATE_MAX）の間で変化させることができます。 TARGET_BITRATE_MINは、ネットワークのスループットが低下すると、最大キューイングさになるからRTPパケットを防ぐために十分に低い値に設定する必要があります。送信者は、ネットワークのスループットが非常に低くなり、RTPパケットが過度に遅延されるときにRTPパケットを破棄機構を装備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the overall bitrate adjustment, two network throughput estimates are computed :
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全体的なビットレート調整のために、2つのネットワークのスループットの推定値が計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rate_transmit: The measured transmit bitrate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oのrate_transmit：測定された送信ビットレート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rate_ack: The ACKed bitrate, i.e., the volume of ACKed bits per second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_ack O：ACKさビットレート、すなわち毎秒ACKさのビットの容積。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both estimates are updated every 200 ms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらの推定値は200ms毎に更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current throughput, current_rate, is computed as the maximum value of rate_transmit and rate_ack. The rationale behind the use of rate_ack in addition to rate_transmit is that rate_transmit is affected also by the amount of data that is available to transmit, thus a lack of data to transmit can be seen as reduced throughput that can cause an unnecessary rate reduction. To overcome this shortcoming, rate_ack is used as well. This gives a more stable throughput estimate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のスループット、current_rateは、rate_transmitとrate_ackの最大値として計算されます。 rate_transmitに加えrate_ackの使用の背後にある理論的根拠はrate_transmitは、このように送信すべきデータの欠如は、不要な速度低下を引き起こす可能性が減少し、スループットとみなすことができ、送信するために利用可能であるデータの量によっても影響されることです。この欠点を克服するために、rate_ackも同様に使用されています。これは、より安定したスループットの推定を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rate change behavior depends on whether a loss or ECN event has occurred and whether the congestion control is in fast increase mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
率の変化挙動は、損失やECNイベントが発生したかどうかと、輻輳制御は、高速増加モードであるかどうかによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODE BEGINS&gt; # The target_bitrate is updated at a regular interval according # to RATE_ADJUST_INTERVAL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;CODEが始まる&gt;＃target_bitrateはRATE_ADJUST_INTERVALへ＃に従って定期的に更新されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
on loss: # Loss event detected target_bitrate = max(BETA_R * target_bitrate, TARGET_BITRATE_MIN) exit on ecn_mark: # ECN event detected target_bitrate = max(BETA_ECN * target_bitrate, TARGET_BITRATE_MIN) exit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
損失に：＃損失イベントecn_mark上target_bitrate = MAX（BETA_R * target_bitrate、TARGET_BITRATE_MIN）終了を検出します。＃ECNイベントtarget_bitrate = MAX（BETA_ECN * target_bitrate、TARGET_BITRATE_MIN）の出口を検出
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ramp_up_speed_t = min(RAMP_UP_SPEED, target_bitrate / 2.0) scale_t = (target_bitrate - target_bitrate_last_max) / target_bitrate_last_max scale_t = max(0.2, min(1.0, (scale_t * 4)^2)) # min scale_t value 0.2, as the bitrate should be allowed to # increase slowly. This prevents locking the rate to # target_bitrate_last_max if (in_fast_increase = true) increment_t = ramp_up_speed_t * RATE_ADJUST_INTERVAL increment_t *= scale_t target_bitrate += increment_t else current_rate_t = max(rate_transmit, rate_ack) # Compute a bitrate change delta_rate_t = current_rate_t * (1.0 - PRE_CONGESTION_GUARD * queue_delay_trend) - TX_QUEUE_SIZE_FACTOR * rtp_queue_size # Limit a positive increase if close to target_bitrate_last_max if (delta_rate_t &gt; 0) delta_rate_t *= scale_t delta_rate_t = min(delta_rate_t, ramp_up_speed_t * RATE_ADJUST_INTERVAL)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ramp_up_speed_t =分（RAMP_UP_SPEED、target_bitrate / 2.0）scale_t =（target_bitrate  -  target_bitrate_last_max）scale_t値0.2分/ target_bitrate_last_max scale_t = MAX（0.2分（1.0、（scale_t * 4）^ 2））＃、ビットレートが許容されるべきです＃徐々に増加します。 * PRE_CONGESTION_GUARD  - これは＃target_bitrate_last_max場合（in_fast_increase =真）increment_t = ramp_up_speed_t * RATE_ADJUST_INTERVALのincrement_t * = scale_t target_bitrate + = increment_t他current_rate_t = MAX（rate_transmit、rate_ack）＃計算ビットレート変更delta_rate_t = current_rate_t *（1.0率をロック防止しますqueue_delay_trend） -  TX_QUEUE_SIZE_FACTOR正増加target_bitrate_last_maxに近い場合* rtp_queue_size位リミットIF（delta_rate_t&gt; 0）delta_rate_t * = scale_t delta_rate_t =分（delta_rate_t、ramp_up_speed_t * RATE_ADJUST_INTERVAL）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 end target_bitrate += delta_rate_t # Force a slight reduction in bitrate if RTP queue # builds up rtp_queue_delay_t = rtp_queue_size / current_rate_t if (rtp_queue_delay_t &gt; RTP_QDELAY_TH) target_bitrate *= TARGET_RATE_SCALE_RTP_QDELAY end end
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTPキュー＃はrtp_queue_delay_t = rtp_queue_size / current_rate_t場合（rtp_queue_delay_t&gt; RTP_QDELAY_TH）target_bitrate * = TARGET_RATE_SCALE_RTP_QDELAYエンドエンドを構築場合target_bitrate + = delta_rate_t＃は、ビットレートのわずかな減少を強制終了
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_media_limit_t = max(current_rate_t, max(rate_media, rtp_rate_median)) rate_media_limit_t *= (2.0 - qdelay_trend_mem) target_bitrate = min(target_bitrate, rate_media_limit_t) target_bitrate = min(TARGET_BITRATE_MAX, max(TARGET_BITRATE_MIN, target_bitrate)) &lt;CODE ENDS&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_media_limit_t = MAX（current_rate_t、MAX（rate_media、rtp_rate_median））rate_media_limit_t * =（2.0  -  qdelay_trend_mem）target_bitrate =分（target_bitrate、rate_media_limit_t）target_bitrate =分（TARGET_BITRATE_MAX、MAX（TARGET_BITRATE_MIN、target_bitrate））&lt;CODEが終了&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In case of a loss event, the target_bitrate is updated and the rate change procedure is exited. Otherwise, the rate change procedure continues. The rationale behind the rate reduction due to loss is that a congestion window reduction will take effect, and a rate reduction proactively prevents RTP packets from being queued up when the transmit rate decreases due to the reduced congestion window. A similar rate reduction happens when ECN events are detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
損失事象の場合には、target_bitrateが更新され、レート変更手続きを終了します。それ以外の場合は、レート変更手続きは継続されます。損失の速度低下の背後にある理論的根拠は、輻輳ウィンドウの減少が有効になり、送信率が低下すると速度の減少が積極的により減少輻輳ウィンドウまでキューに入れられているから、RTPパケットを防ぐことです。 ECNイベントが検出されたときに同様の速度の低下が起こります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rate update frequency is limited by RATE_ADJUST_INTERVAL, unless a loss event occurs. The value is based on experimentation with real-life limitations in video coders taken into account [SCReAM-CPP-implementation]. A too short interval is shown to make the rate control loop in video coders more unstable; a too long interval makes the overall congestion control sluggish.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
損失イベントが発生しない限り、レートの更新頻度は、RATE_ADJUST_INTERVALによって制限されます。値が考慮されたビデオコーダにおける現実の制限の実験[SCREAM-CPP-実装]に基づいています。短すぎる間隔は、ビデオコーダにおける速度制御ループをより不安定にすることが示されています。あまりにも長い間の間隔は、全体的な輻輳制御が低迷なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in fast increase mode (in_fast_increase = true), the bitrate increase is given by the desired ramp-up speed (RAMP_UP_SPEED). The ramp-up speed is limited when the target bitrate is low to avoid rate oscillation at low bottleneck bitrates. The setting of RAMP_UP_SPEED depends on preferences. A high setting such as 1000 kbps/s makes it possible to quickly get high-quality media; however, this is at the expense of increased jitter, which can manifest itself as choppy video rendering, for example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高速増加モード（in_fast_increase =真）で、ビットレートの増加は、所望のランプアップ速度（RAMP_UP_SPEED）によって与えられる場合。ターゲットビットレートが低いボトルネックのビットレートでのレートの振動を避けるために、低いときランプアップ速度が制限されています。 RAMP_UP_SPEEDの設定は好みに依存します。 1000年kbpsのような高い設定は、/ sが素早く高品質なメディアを取得することが可能になります。しかし、これは、例えば、途切れビデオレンダリングとして現れることができるジッタの増加の費用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in_fast_increase is false, the bitrate increase is given by the current bitrate and is also controlled by the estimated RTP queue and the qdelay trend, thus it is sufficient that an increased congestion level is sensed by the network congestion control to limit the bitrate. The target_bitrate_last_max is updated when congestion is detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in_fast_increaseが偽である場合、ビットレートの増加は、現在のビットレートによって与えられ、また、推定されたRTPキューとqdelay傾向によって制御され、したがって、増加し、輻輳レベルがビットレートを制限するために、ネットワークの輻輳制御によって感知されることで十分です。輻輳が検出されたときにtarget_bitrate_last_maxが更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the target_bitrate is within the defined min and max values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、target_bitrateは、定義された最小値と最大値の範囲内です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The aware reader may notice the dependency on the qdelay in the computation of the target bitrate; this manifests itself in the use of the qdelay_trend. As these parameters are used also in the network congestion control, one may suspect some odd interaction between the media rate control and the network congestion control. This is in fact the case if the parameter PRE_CONGESTION_GUARD is set to a high value. The use of qdelay_trend in the media rate control is solely to reduce jitter; the dependency can be removed by setting PRE_CONGESTION_GUARD=0. The effect is a somewhat larger rate increase after congestion, at the expense of increased jitter in congested situations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認識リーダは、ターゲットビットレートの計算にqdelayの依存性に気づくことができます。これはqdelay_trendの使用で現れます。これらのパラメータは、ネットワークの輻輳制御にも使用されるように、一方がメディアレート制御とネットワークの輻輳制御の間にいくつかの奇妙な相互作用を疑うことができます。パラメータPRE_CONGESTION_GUARDが高い値に設定されている場合、これは実際にはそうです。メディアレート制御におけるqdelay_trendの使用は、ジッタを低減するためだけです。依存性はPRE_CONGESTION_GUARD = 0を設定することによって除去することができます。効果は、輻輳状況におけるジッタの増加を犠牲にして輻輳後幾分大きい速度上昇、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. SCReAM Receiver
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.  SCREAMレシーバー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The simple task of the SCReAM receiver is to feed back acknowledgements of received packets and total ECN count to the SCReAM sender. In addition, the receive time of the RTP packet with the highest sequence number is echoed back. Upon reception of each RTP packet, the receiver MUST maintain enough information to send the aforementioned values to the SCReAM sender via an RTCP transport-layer feedback message. The frequency of the feedback message depends on the available RTCP bandwidth. The requirements on the feedback elements and the feedback interval are described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCREAM受信機の簡単な作業ではSCREAMの送信者に受信したパケットと総ECN数の確認応答をフィードバックすることです。また、シーケンス番号が最大であるRTPパケットの受信時刻がエコーバックされます。各RTPパケットを受信すると、受信機は、RTCPトランスポート層フィードバックメッセージを介してスクリーム送信者に前述の値を送信するのに十分な情報を維持しなければなりません。フィードバックメッセージの頻度は、利用可能なRTCP帯域幅に依存します。フィードバック要素とフィードバック間隔に関する要件は以下の通りです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Requirements on Feedback Elements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. フィードバック要素上の要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following feedback elements are REQUIRED for basic functionality in SCReAM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のフィードバック要素は悲鳴で基本的な機能のために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A list of received RTP packets. This list SHOULD be sufficiently long to cover all received RTP packets. This list can be realized with the Loss RLE (Run Length Encoding) Report Block in [RFC3611].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信したRTPパケットのリストO。このリストは、すべての受信したRTPパケットをカバーするのに十分な長さであるべきです。このリストは、損失RLE（ランレングス符号化）[RFC3611]でレポート・ブロックを実現することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A wall-clock timestamp corresponding to the received RTP packet with the highest sequence number is required in order to compute the qdelay. This can be realized by means of the Packet Receipt Times Report Block in [RFC3611]. begin_seq MUST be set to the highest received sequence number (which has possibly wrapped around); end_seq MUST be set to begin_seq+1 modulo 65536. The timestamp clock MAY be set according to [RFC3611], i.e., equal to the RTP timestamp clock. Detailed individual packet receive times are not necessary, as SCReAM does currently not describe how they can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O最も高いシーケンス番号を有する受信したRTPパケットに対応するウォールクロックタイムスタンプはqdelayを計算するために必要とされます。これは、[RFC3611]でのパケット受信タイムズレポート・ブロックを用いて実現することができます。 begin_seqは（おそらく周りに巻き付けられた）最高の受信されたシーケンス番号に設定しなければなりません。 end_seqはタイムスタンプクロックをRTPタイムスタンプクロックに等しく、[RFC3611]、即ち、に応じて設定すればよい+ 1モジュロ65536をbegin_seqに設定されなければなりません。詳細個々のパケットスクリームは現在、彼らがどのように使用できるかを記述していないと時間は、必要ありません受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic feedback needed for SCReAM involves the use of the Loss RLE Report Block and the Packet Receipt Times Report Block as shown in Figure 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図2に示すように、悲鳴のために必要な基本的なフィードバックが消失RLEレポート・ブロックとパケット受信タイムズレポート・ブロックの使用を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |V=2|P|reserved |   PT=XR=207   |             length            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                              SSRC                             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     BT=2      | rsvd. |  T=0  |         block length          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                        SSRC of source                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          begin_seq            |             end_seq           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          chunk 1              |             chunk 2           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       :                              ...                              :
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          chunk n-1            |             chunk n           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     BT=3      | rsvd. |  T=0  |         block length          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                        SSRC of source                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          begin_seq            |             end_seq           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |       Receipt time of packet begin_seq                        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 2: Basic Feedback Message for SCReAM, Based on RFC 3611
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図2：スクリームのための基本的なフィードバックメッセージ、RFC 3611に基づいて、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a typical use case, no more than four Loss RLE chunks are needed, thus the feedback message will be 44 bytes. It is obvious from Figure 2 that there is a lot of redundant information in the feedback message. A more optimized feedback format, including the additional feedback elements listed below, could reduce the feedback message size a bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
典型的な使用例では、4つ以下損失RLEチャンクは、このようにフィードバックメッセージは44バイトとなり、必要とされています。これは、冗長な情報の多くは、フィードバック・メッセージ内に存在することが図2から明らかです。下記の追加のフィードバック要素を含む、より最適化されたフィードバックの形式は、フィードバックメッセージのサイズを少し減らすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An additional feedback element that can improve the performance of SCReAM is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCREAMのパフォーマンスを向上させることができ、追加のフィードバック要素は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Accumulated number of ECN-CE-marked packets (n_ECN). For instance, this can be realized with the ECN Feedback Report Format in [RFC6679]. The given feedback report format is slightly overkill, as SCReAM would do quite well with only a counter that increments by one for each received packet with the ECN-CE codepoint set. The more bulky format could nevertheless be useful for, e.g., ECN black-hole detection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ECN-CEマーク付きのパケット（n_ECN）のO累積数。例えば、これは[RFC6679]でECNフィードバックレポート形式で実現することができます。スクリームはごとに1つだけインクリメントがECN-CEコードポイントを設定してパケットを受信しただけカウンタと非常によく行うように指定されたフィードバックレポートフォーマットは、わずかに過剰です。より嵩高いフォーマットは、それにもかかわらず、例えば、ECNブラックホールの検出に有用であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Requirements on Feedback Intensity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. フィードバック強度上の要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCReAM benefits from relatively frequent feedback. It is RECOMMENDED that a SCReAM implementation follows the guidelines below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
比較的頻繁なフィードバックから利益を悲鳴。 SCREAMの実装は、以下のガイドラインに従うことを推奨します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The feedback interval depends on the media bitrate. At low bitrates, it is sufficient with a feedback interval of 100 to 400 ms; while at high bitrates, a feedback interval of roughly 20 ms is preferred. At very high bitrates, even shorter feedback intervals MAY be needed in order to keep the self-clocking in SCReAM working well. One indication that feedback is too sparse is that the SCReAM implementation cannot reach high bitrates, even in uncongested links. More frequent feedback might solve this issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィードバック間隔は、メディアビットレートに依存します。低ビットレートでは、100〜400ミリ秒のフィードバック間隔で十分です。高いビットレートでながら、約20ミリ秒のフィードバック間隔が好ましいです。非常に高いビットレートで、さらに短いフィードバック間隔がうまく機能して悲鳴に自己クロッキングを維持するために必要かもしれません。フィードバックがあまりにも希薄であることを一つの指標はSCREAMの実装も非輻輳リンクで、高ビットレートに到達できないということです。より頻繁なフィードバックは、この問題を解決する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The numbers above can be formulated as a feedback interval function that can be useful for the computation of the desired RTCP bandwidth. The following equation expresses the feedback rate:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数字は、上記所望のRTCP帯域幅の計算のために有用であり得るフィードバック間隔の関数として処方することができます。次の式は、フィードバックレートを表現します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
rate_fb = min(50, max(2.5, rate_media / 10000))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
rate_fb =分（50、MAX（2.5、rate_media / 10000））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_media is the RTP media bitrate expressed in bps; rate_fb is the feedback rate expressed in packets/s. Converting to feedback interval, we get:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rate_mediaはBPSで発現RTPメディアビットレートです。 rate_fbパケット/秒で表現さ帰還率です。フィードバック間隔への変換、我々が得ます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
fb_int = 1.0 / min(50, max(2.5, rate_media / 10000))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
fb_int = 1.0 /分（50、MAX（2.5、rate_media / 10000））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transmission interval is not critical. So, in the case of multi-stream handling between two hosts, the feedback for two or more synchronization sources (SSRCs) can be bundled to save UDP/IP overhead. However, the final realized feedback interval SHOULD not exceed 2*fb_int in such cases, meaning that a scheduled feedback transmission event should not be delayed more than fb_int.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信間隔は重要ではありません。したがって、2つのホスト間のマルチストリーム処理の場合には、二つ以上の同期ソース（SSRCs）のフィードバックは、UDP / IPのオーバーヘッドを保存するために同梱することができます。しかし、最終的な実現フィードバック間隔は、スケジュールフィードバック送信イベントがfb_intより遅延されるべきではないことを意味し、そのような場合には2 * fb_intを超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCReAM works with AVPF regular mode; immediate or early mode is not required by SCReAM but can nonetheless be useful for RTCP messages not directly related to SCReAM, such as those specified in [RFC4585]. It is RECOMMENDED to use reduced-size RTCP [RFC5506], where regular full compound RTCP transmission is controlled by trr-int as described in [RFC4585].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCREAMはAVPF通常モードで動作します。即時または早期モードは悲鳴によって必要とされていないが、それにもかかわらず、このような[RFC4585]で指定されたものとして直接悲鳴に関連していないRTCPメッセージ、するのに役立ちます。 [RFC4585]に記載されているように正規フル複合RTCP送信がTRR-INTによって制御される縮小RTCP [RFC5506]を使用することが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.ディスカッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section covers a few discussion points.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、いくつかの論点をカバーしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clock drift: SCReAM can suffer from the same issues with clock drift as is the case with LEDBAT [RFC6817]. However, Appendix A.2 in [RFC6817] describes ways to mitigate issues with clock drift.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oクロックドリフト：LEDBAT [RFC6817]と同様にスクリームクロックドリフトと同じ問題に苦しむことができます。ただし、[RFC6817]の付録A.2は、クロックドリフトの問題を軽減する方法を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Support for alternate ECN semantics: This specification adopts the proposal in [ALT-BACKOFF] to reduce the congestion window less when ECN-based congestion events are detected. Future work on Low Loss, Low Latency for Scalable throughput (L4S) may lead to updates in a future document that describes SCReAM support for L4S.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O代替ECNセマンティクスのサポートは、この仕様では、ECNベースの輻輳イベントが検出されたときより少ない輻輳ウィンドウを減少させるために、[ALT-BACKOFF]に提案を採用しています。低損失の今後の作業は、スケーラブルなスループットのための低遅延（L4S）はL4SためSCREAMのサポートについて説明し、今後の文書での更新につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A new transport-layer feedback message (as specified in RFC 4585) could be standardized if the use of the already existing RTCP extensions as described in Section 4.2 is not deemed sufficient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション4.2で説明したように、既存のRTCP拡張の使用は十分とみなされていない場合、O新しいトランスポート層フィードバックメッセージは、（RFC 4585で指定されるように）標準化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The target bitrate given by SCReAM is the bitrate including the RTP and Forward Error Correction (FEC) overhead. The media encoder SHOULD take this overhead into account when the media bitrate is set. This means that the media coder bitrate SHOULD be computed as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
悲鳴によって与えられた目標ビットレートoをRTPおよび前方誤り訂正（FEC）オーバーヘッドを含むビットレートです。メディアビットレートが設定されている場合、メディアエンコーダは、アカウントにこのオーバーヘッドを取る必要があります。これは、メディアコーダービットレートは次のように計算されるべきであることを意味します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
media_rate = target_bitrate - rtp_plus_fec_overhead_bitrate
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
media_rate = target_bitrate  -  rtp_plus_fec_overhead_bitrate
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
It is not necessary to make a 100% perfect compensation for the overhead, as the SCReAM algorithm will inherently compensate for moderate errors. Under-compensating for the overhead has the effect of increasing jitter, while overcompensating will cause the bottleneck link to become underutilized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SCREAMアルゴリズムは、本質的に、中程度の誤差を補償しますように、オーバーヘッドのために100％完璧な補償をする必要はありません。オーバーヘッドを補償の下に、過補償がボトルネックリンクが十分に利用されていないとなってしまいますが、増加ジッタの影響を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Suggested Experiments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.推奨実験
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCReAM has been evaluated in a number of different ways, mostly in a simulator. The OpenWebRTC implementation work ([OpenWebRTC] and [SCReAM-implementation]) involved extensive testing with artificial bottlenecks with varying bandwidths and using two different video coders (OpenH264 and VP9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCREAMは、ほとんどのシミュレータで、いくつかの異なる方法で評価されています。 OpenWebRTC実装作業（[OpenWebRTC]及び[スクリーム-実装]）の帯域幅を変化させる2つの異なるビデオコーダ（OpenH264とVP9）を用いて人工的なボトルネックとの広範なテストを含んでいました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Preferably, further experiments will be done by means of implementation in real clients and web browsers. RECOMMENDED experiments are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
好ましくは、さらなる実験では、実際のクライアントやWebブラウザに実装によって行われます。推奨の実験は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Trials with various access technologies: EDGE/3G/4G, Wi-Fi, DSL. Some experiments have already been carried out with LTE access; see [SCReAM-CPP-implementation] and [SCReAM-implementation-experience].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EDGE / 3G / 4G、のWi-Fi、DSL：様々なアクセス技術とOトライアル。いくつかの実験では、すでにLTEアクセスで行われています。 [SCREAM-CPP-実装]を参照し、[SCREAM-実装経験]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Trials with different kinds of media: Audio, video, slideshow content. Evaluation of multi-stream handling in SCReAM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーディオ、ビデオ、スライドショーコンテンツ：メディアの種類とOトライアル。 SCREAMにおけるマルチストリーム処理の評価。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Evaluation of functionality of the compensation mechanism when there are competing flows: Evaluate how SCReAM performs with competing TCP-like traffic and to what extent the compensation for competing flows causes self-inflicted congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O補償機構の機能の評価は、競合するフローがある場合：悲鳴が競合するTCPのようなトラフィックで実行する方法を評価し、どの程度の競合フローに対する補償が自ら招い輻輳が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Determine proper parameters: A set of default parameters are given that makes SCReAM work over a reasonably large operation range. However, for very low or very high bitrates, it may be necessary to use different values for the RAMP_UP_SPEED, for instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O適切なパラメータを決定します。デフォルトパラメータのセットは、合理的に大きな動作範囲にわたりSCREAMの仕事を作ること与えられています。しかしながら、非常に低いまたは非常に高いビットレートのために、例えば、RAMP_UP_SPEEDに異なる値を使用する必要があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Experimentation with further improvements to the congestion window and media bitrate calculation. [SCReAM-CPP-implementation] implements some optimizations, not described in this memo, that improve performance slightly. Further experiments are likely to lead to more optimizations of the algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O輻輳ウィンドウとメディアのビットレート計算へのさらなる改善と実験。 [スクリーム-CPP-実装]はわずかに性能を向上させるこのメモに記載されていないいくつかの最適化を実装します。さらなる実験は、アルゴリズムのより最適化につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document does not require any IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、IANAのアクションを必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The feedback can be vulnerable to attacks similar to those that can affect TCP. It is therefore RECOMMENDED that the RTCP feedback is at least integrity protected. Furthermore, as SCReAM is self-clocked, a malicious middlebox can drop RTCP feedback packets and thus cause the self-clocking in SCReAM to stall. However, this attack is mitigated by the minimum send rate maintained by SCReAM when no feedback is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィードバックは、TCPに影響を与えることができるものと同様の攻撃に対して脆弱であることができます。したがって、RTCPフィードバックは、少なくとも完全性を保護することをお勧めします。さらに、SCREAMはセルフクロックであるとして、悪質なミドルは、RTCPフィードバックパケットをドロップすることができますので、SCREAMにおける自己クロッキングが失速する原因となります。しかし、この攻撃は何のフィードバックが受信されないとき悲鳴によって維持最小送信レートによって軽減されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &#34;RTP: A Transport Protocol for Real-Time Applications&#34;, STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, &lt;https://www.rfc-editor.org/info/rfc3550&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550] Schulzrinneと、H.、Casner、S.、フレデリック、R.、およびV.ヤコブソン、 &#34;RTP：リアルタイムアプリケーションのためのトランスポートプロトコル&#34;、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 &lt;https://www.rfc-editor.org/info/rfc3550&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3611] Friedman, T., Ed., Caceres, R., Ed., and A. Clark, Ed., &#34;RTP Control Protocol Extended Reports (RTCP XR)&#34;, RFC 3611, DOI 10.17487/RFC3611, November 2003, &lt;https://www.rfc-editor.org/info/rfc3611&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3611]フリードマン、T.、エド。、カセレス、R.、エド。、およびA.クラーク、エド。、 &#34;RTP制御プロトコル拡張レポート（RTCP XR）&#34;、RFC 3611、DOI 10.17487 / RFC3611、2003年11月、 &lt;https://www.rfc-editor.org/info/rfc3611&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4585] Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey, &#34;Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)&#34;, RFC 4585, DOI 10.17487/RFC4585, July 2006, &lt;https://www.rfc-editor.org/info/rfc4585&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4585]オット、J.、ウェンガー、S.、佐藤、N.、Burmeister、C.、およびJ.レイ「ベースのフィードバック（RTP / AVPF）リアルタイムトランスポート制御プロトコル（RTCP）の拡張RTPプロファイル」、RFC 4585、DOI 10.17487 / RFC4585、2006年7月、&lt;https://www.rfc-editor.org/info/rfc4585&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5506] Johansson, I. and M. Westerlund, &#34;Support for Reduced-Size Real-Time Transport Control Protocol (RTCP): Opportunities and Consequences&#34;, RFC 5506, DOI 10.17487/RFC5506, April 2009, &lt;https://www.rfc-editor.org/info/rfc5506&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5506]ヨハンソン、I.およびM.ウェスター、 &#34;縮小リアルタイムトランスポート制御プロトコル（RTCP）のサポート：機会と帰結&#34;、RFC 5506、DOI 10.17487 / RFC5506、2009年4月、&lt;https：//でWWW .rfc-editor.org /情報/ rfc5506&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, &#34;Computing TCP&#39;s Retransmission Timer&#34;, RFC 6298, DOI 10.17487/RFC6298, June 2011, &lt;https://www.rfc-editor.org/info/rfc6298&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298]パクソン、V.、オールマン、M.、チュー、J.、およびM.サージェント、 &#34;コンピューティングTCPの再送信タイマー&#34;、RFC 6298、DOI 10.17487 / RFC6298、2011年6月、&lt;HTTPS：//www.rfc- editor.org/info/rfc6298&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6817] Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind, &#34;Low Extra Delay Background Transport (LEDBAT)&#34;, RFC 6817, DOI 10.17487/RFC6817, December 2012, &lt;https://www.rfc-editor.org/info/rfc6817&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6817] Shalunov、S.、ヘーゼル、G.、アイアンガー、J.、およびM. Kuehlewind、 &#34;低余分な遅延の背景トランスポート（LEDBAT）&#34;、RFC 6817、DOI 10.17487 / RFC6817、2012年12月、&lt;https：//でwww.rfc-editor.org/info/rfc6817&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B.、 &#34;RFC 2119個のキーワードに小文字VS大文字の曖昧さ&#34;、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https://www.rfc-editor.org/info/ rfc8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ALT-BACKOFF] Khademi, N., Welzl, M., Armitage, G., and G. Fairhurst, &#34;TCP Alternative Backoff with ECN (ABE)&#34;, Work in Progress, draft-ietf-tcpm-alternativebackoff-ecn-04, November 2017.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ALT-BACKOFF] Khademi、N.、Welzl、M.、アーミテージ、G.、およびG. Fairhurst、 &#34;ECNとTCP代替バックオフ（ABE）&#34;、進行中で働いて、ドラフトIETF-tcpm-alternativebackoff-ecn- 04、2017年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[COUPLED-CC] Islam, S., Welzl, M., and S. Gjessing, &#34;Coupled congestion control for RTP media&#34;, Work in Progress, draft-ietf-rmcat-coupled-cc-07, September 2017.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[COUPLED-CC]イスラム教、S.、Welzl、M.、およびS. Gjessing、 &#34;RTPメディア用輻輳制御を結合&#34;、進行中で働いて、ドラフトIETF-rmcat結合-CC-07、2017年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LEDBAT-delay-impact] Ros, D. and M. Welzl, &#34;Assessing LEDBAT&#39;s Delay Impact&#34;, IEEE Communications Letters, Vol. 17, No. 5, DOI 10.1109/LCOMM.2013.040213.130137, May 2013, &lt;http://home.ifi.uio.no/michawe/research/publications/ ledbat-impact-letters.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LEDBAT遅延衝撃]ロス、D.およびM. Welzl、「LEDBATの遅延の影響を評価する」、IEEE通信レター、巻。 17、第5号、DOI 10.1109 / LCOMM.2013.040213.130137、2013年5月、&lt;http://home.ifi.uio.no/michawe/research/publications/ ledbat-衝撃letters.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OpenWebRTC] Ericsson Research, &#34;OpenWebRTC&#34;, &lt;http://www.openwebrtc.org&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OpenWebRTC]エリクソンリサーチ、 &#34;OpenWebRTC&#34; &lt;http://www.openwebrtc.org&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Packet-conservation] Jacobson, V., &#34;Congestion Avoidance and Control&#34;, ACM SIGCOMM Computer Communication Review, DOI 10.1145/52325.52356, August 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[パケット保全]ヤコブソン、V.、 &#34;輻輳回避とコントロール&#34;、ACM SIGCOMMコンピュータコミュニケーションレビュー、DOI 10.1145 / 52325.52356、1988年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QoS-3GPP] 3GPP, &#34;Policy and charging control architecture&#34;, 3GPP TS 23.203, July 2017, &lt;http://www.3gpp.org/ftp/specs/archive/23_series/23.203/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[QoSの-3GPP] 3GPP、 &#34;ポリシーおよび課金制御アーキテクチャ&#34;、3GPP TS 23.203、2017年7月、&lt;http://www.3gpp.org/ftp/specs/archive/23_series/23.203/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RACK] Cheng, Y., Cardwell, N., and N. Dukkipati, &#34;RACK: a time-based fast loss detection algorithm for TCP&#34;, Work in Progress, draft-ietf-tcpm-rack-02, March 2017.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RACK]チェン、Y.、カードウェル、N.、およびN. Dukkipati、 &#34;RACK：TCPのタイムベースの高速な損失検出アルゴリズム&#34; が進行中で働いて、ドラフト-IETF-tcpmラック-02、2017年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679] Westerlund, M., Johansson, I., Perkins, C., O&#39;Hanlon, P., and K. Carlberg, &#34;Explicit Congestion Notification (ECN) for RTP over UDP&#34;, RFC 6679, DOI 10.17487/RFC6679, August 2012, &lt;https://www.rfc-editor.org/info/rfc6679&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679]ウェスター、M.、ヨハンソン、I.、パーキンス、C.、オハンロン、P.、およびK.カールバーグ、 &#34;明示的輻輳通知UDP上のRTPのための（ECN）&#34;、RFC 6679、DOI 10.17487 / RFC6679 、2012年8月、&lt;https://www.rfc-editor.org/info/rfc6679&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7478] Holmberg, C., Hakansson, S., and G. Eriksson, &#34;Web Real-Time Communication Use Cases and Requirements&#34;, RFC 7478, DOI 10.17487/RFC7478, March 2015, &lt;https://www.rfc-editor.org/info/rfc7478&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7478] Holmbergの、C.、Hakansson、S.、およびG.エリクソン、 &#34;ウェブリアルタイム通信ユースケースと要件&#34;、RFC 7478、DOI 10.17487 / RFC7478、2015年3月、&lt;HTTPS：//www.rfc- editor.org/info/rfc7478&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7661] Fairhurst, G., Sathiaseelan, A., and R. Secchi, &#34;Updating TCP to Support Rate-Limited Traffic&#34;, RFC 7661, DOI 10.17487/RFC7661, October 2015, &lt;https://www.rfc-editor.org/info/rfc7661&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7661] Fairhurst、G.、Sathiaseelan、A.、およびR. Secchi、 &#34;サポートするためのTCPの更新レート制限トラフィック&#34;、RFC 7661、DOI 10.17487 / RFC7661、2015年10月、&lt;HTTPS：//www.rfc-editor .ORG /情報/ rfc7661&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCReAM-CPP-implementation] Ericsson Research, &#34;SCReAM - Mobile optimised congestion control algorithm&#34;, &lt;https://github.com/EricssonResearch/scream&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[スクリーム-CPP-実装]エリクソンリサーチ、 &#34;スクリーム - モバイル最適化された輻輳制御アルゴリズム&#34;、&lt;https://github.com/EricssonResearch/scream&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCReAM-implementation] Ericsson Research, &#34;OpenWebRTC specific GStreamer plugins&#34;, &lt;https://github.com/EricssonResearch/ openwebrtc-gst-plugins&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[スクリーム-実装]エリクソンリサーチ、 &#34;OpenWebRTC特定のGStreamerプラグイン&#34;、&lt;https://github.com/EricssonResearch/ openwebrtc-GST-プラグイン&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCReAM-implementation-experience] Sarker, Z. and I. Johansson, &#34;Updates on SCReAM: An implementation experience&#34;, November 2015, &lt;https://www.ietf.org/proceedings/94/slides/ slides-94-rmcat-8.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCREAM-実装経験] Sarker、Z.およびI.ヨハンソン、 &#34;SCREAMのアップデート：実装経験&#34;、2015年11月、&lt;https://www.ietf.org/proceedings/94/slides/スライド-94- rmcat-8.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TFWC] Choi, S. and M. Handley, &#34;Fairer TCP-Friendly Congestion Control Protocol for Multimedia Streaming Applications&#34;, DOI 10.1145/1364654.1364717, December 2007, &lt;http://www-dept.cs.ucl.ac.uk/staff/M.Handley/papers/ tfwc-conext.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TFWC]チェ、S.とM.ハンドリー、 &#34;マルチメディアストリーミングアプリケーションのためのより公正なTCPフレンドリー輻輳制御プロトコル&#34;、DOI 10.1145 / 1364654.1364717、2007年12月、&lt;http://www-dept.cs.ucl.ac.uk /staff/M.Handley/papers/ tfwc-conext.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[WIRELESS-TESTS] Sarker, Z., Johansson, I., Zhu, X., Fu, J., Tan, W., and M. Ramalho, &#34;Evaluation Test Cases for Interactive Real-Time Media over Wireless Networks&#34;, Work in Progress, draft-ietf-rmcat-wireless-tests-04, May 2017.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[WIRELESS-TESTS] Sarker、Z.、ヨハンソン、I.、朱、X.、フー、J.、タン、W.、およびM. Ramalho、 &#34;無線ネットワーク上でインタラクティブなリアルタイムメディアの評価テスト・ケース&#34;、ドラフト-IETF-rmcat-無線テスト-04、2017月、進行中の作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We would like to thank the following people for their comments, questions, and support during the work that led to this memo: Markus Andersson, Bo Burman, Tomas Frankkila, Frederic Gabin, Laurits Hamm, Hans Hannu, Nikolas Hermanns, Stefan Haakansson, Erlendur Karlsson, Daniel Lindstroem, Mats Nordberg, Jonathan Samuelsson, Rickard Sjoeberg, Robert Swain, Magnus Westerlund, and Stefan Aalund. Many additional thanks to RMCAT chairs Karen E. E. Nielsen and Mirja Kuehlewind for patiently reading, suggesting improvements and also for asking all the difficult but necessary questions. Thanks to Stefan Holmer, Xiaoqing Zhu, Safiqul Islam, and David Hayes for the additional review of this document. Thanks to Ralf Globisch for taking time to try out SCReAM in his challenging low-bitrate use cases, Robert Hedman for finding a few additional flaws in the running code, and Gustavo Garcia and &#39;miseri&#39; for code contributions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルクス・アンダーソン、ボービルマ、トマスFrankkila、フレデリック・ギャバン、Lauritsハム、ハンス・ハンヌ、ニコラスHermanns、ステファンHaakansson、Erlendurを：私たちは、このメモにつながっ作業中に彼らのコメント、質問、およびサポートのために、以下の人々に感謝したいと思いますカールソン、ダニエルLindstroem、マットノードバーグ、ジョナサン・サミュエルソン、リカードSjoeberg、ロバート・スウェイン、マグヌスウェスター、そしてステファンAalund。 RMCATに多くの追加のおかげで、辛抱強く読み取るためのカレンE. E.ニールセンとMirja Kuehlewindの議長を務めるの改善を示唆し、また、すべての困難はなく、必要な質問をするため。このドキュメントの追加審査のためのステファンHolmer、暁朱、Safiqulイスラム教、そしてデビッド・ヘイズに感謝します。彼の挑戦的な低ビットレートのユースケースで悲鳴を試すために時間を割いてラルフGlobischのおかげで、実行中のコードにいくつかの追加の欠陥を見つけるためのロバートHedman、とグスタボ・ガルシアとコードの貢献のための「miseri」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ingemar Johansson Ericsson AB Laboratoriegraend 11 Luleaa 977 53 Sweden
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インゲマル・ヨハンソン、エリクソンAB Laboratoriegraend 11 Luleaa 977 53スウェーデン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +46 730783289 Email: ingemar.s.johansson@ericsson.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+46 730783289 Eメール：ingemar.s.johansson@ericsson.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Zaheduzzaman Sarker Ericsson AB Laboratoriegraend 11 Luleaa 977 53 Sweden
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SAARC labaratriigrainda C 977 53ルーレオsbedenaのJahedujjamanaのeriksasana
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +46 761153743 Email: zaheduzzaman.sarker@ericsson.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+46 761153743 Eメール：zaheduzzaman.sarker@ericsson.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
