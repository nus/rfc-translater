<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 2227 - Simple Hit-Metering and Usage-Limiting for HTTP 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">2227</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 2227 - Simple Hit-Metering and Usage-Limiting for HTTP 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc2227">
              https://tools.ietf.org/html/rfc2227
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 2227 - HTTP用のシンプルなヒット・メーターと使用制限</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                           J. Mogul
Request for Comments: 2227                                        DECWRL
Category: Standards Track                                       P. Leach
                                                               Microsoft
                                                            October 1997
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            Simple Hit-Metering and Usage-Limiting for HTTP
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (1997). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（1997）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ABSTRACT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document proposes a simple extension to HTTP, using a new &#34;Meter&#34; header, which permits a limited form of demographic information (colloquially called &#34;hit-counts&#34;) to be reported by caches to origin servers, in a more efficient manner than the &#34;cache-busting&#34; techniques currently used. It also permits an origin server to control the number of times a cache uses a cached response, and outlines a technique that origin servers can use to capture referral information without &#34;cache-busting.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、より効率的な方法で、オリジンサーバにキャッシュによって報告される（口語的に「ヒット数」と呼ばれる）人口統計情報の限られたフォームを許可する新しい「メーター」ヘッダを使用して、HTTPへの単純な拡張を提案しています「キャッシュの無効化」の技術が現在使用します。また、キャッシュは、キャッシュされた応答を使用し、オリジンサーバがなくて参照情報をキャプチャするために使用できる技術について概説する回数を制御するためにオリジンサーバを許可する「キャッシュつぶしを。」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TABLE OF CONTENTS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1 Introduction 2 1.1 Goals, non-goals, and limitations 3 1.2 Brief summary of the design 4 1.3 Terminology 5 2 Overview 5 2.1 Discussion 7 3 Design concepts 8 3.1 Implementation of the &#34;metering subtree&#34; 8 3.2 Format of the Meter header 10 3.3 Negotiation of hit-metering and usage-limiting 10 3.4 Transmission of usage reports 14 3.5 When to send usage reports 15 3.6 Subdivision of usage-limits 16
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1つのはじめに2つの1.1ゴール、非目標、限界設計4 1.3用語メーターヘッダ10 3.3の「計量サブツリー」8 3.2形式の5 2概要5 2.1考察7~3設計コンセプト8 3.1実装の3 1.2簡単な要約使用状況レポートを利用限度16 15 3.6区を送信する場合にヒット計量および使用の10 3.4伝送を利用制限のネゴシエーションが14 3.5を報告します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4 Analysis 17 4.1 Approximation accuracy for counting users 18 4.2 What about &#34;Network Computers&#34;? 19 4.3 Critical-path delay analysis 19 5 Specification 20 5.1 Specification of Meter header and directives 20 5.2 Abbreviations for Meter directives 23 5.3 Counting rules 24 5.3.1 Counting rules for hit-metering 24 5.3.2 Counting rules for usage-limiting 25 5.3.3 Equivalent algorithms are allowed 26 5.4 Counting rules: interaction with Range requests 27 5.5 Implementation by non-caching proxies 27 5.6 Implementation by cooperating caches 28 6 Examples 28 6.1 Example of a complete set of exchanges 28 6.2 Protecting against HTTP/1.0 proxies 30 6.3 More elaborate examples 30 7 Interactions with content negotiation 31 7.1 Treatment of responses carrying a Vary header 31 7.2 Interaction with Transparent Content Negotiation 32 8 A Note on Capturing Referrals 32 9 Alternative proposals 33 10 Security Considerations 34 11 Acknowledgments 35 12 References 35 13 Authors&#39; Addresses 36 14 Full Copyright Statement 37
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どのような「ネットワークコンピュータ」についてユーザー18 4.2をカウントするための4分析17 4.1近似精度？メーター5.2略語がヒット計量23の5.3カウントルール25 5.3使用が制限24の5.3.2カウントルールを24の5.3.1カウントルールをディレクティブ20 19 4.3クリティカルパス遅延解析19 5仕様20 5.1メーターヘッダの仕様とディレクティブ0.3同等のアルゴリズムは26の5.4カウントルールを許可されています。レンジとの相互作用は、27 5.6実装HTTP / 1.0プロキシ30からの保護交換28 6.2の完全なセットのキャッシュ28 6例28 6.1の例を協力することによって、非キャッシュプロキシによって27 5.5実装を要求します6.3より複雑な例キャプチャ照会に透過的内容ネゴシエーション32 8注意と共に変化するヘッダ31 7.2インタラクション32の9の代替案33の10セキュリティの考慮事項34 11謝辞35 12参考文献35本の13本の著者を運ぶ応答のコンテンツネゴシエーション31 7.1治療と30の7インタラクション36 &#39;14完全な著作権声明37をアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1 Introduction
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1はじめに
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a variety of reasons, content providers want to be able to collect information on the frequency with which their content is accessed. This desire leads to some of the &#34;cache-busting&#34; done by existing servers. (&#34;Cache-busting&#34; is the use by servers of techniques intended to prevent caching of responses; it is unknown exactly how common this is.) This kind of cache-busting is done not for the purpose of maintaining transparency or security properties, but simply to collect demographic information. Some cache-busting is also done to provide different advertising images to appear on the same page (i.e., each retrieval of the page sees a different ad).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
様々な理由から、コンテンツ・プロバイダは、その内容がアクセスされる頻度に関する情報を収集することができるようにしたいです。この願望は、「キャッシュの無効化」既存のサーバーで行うの一部につながります。 （「キャッシュの無効化」の応答のキャッシュを防止することを目的と技術のサーバによって使用される;これが正確にどのように共通不明）キャッシュの無効化のこの種のは、透明性やセキュリティ性を維持する目的ではない行われますが、単に人口統計情報を収集します。いくつかのキャッシュの無効化も（すなわち、ページの各検索が異なる広告を見て）同じページに表示されるように異なる広告画像を提供するために行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This proposal supports a model similar to that of publishers of hard-copy publications: such publishers (try to) report to their advertisers how many people read an issue of a publication at least once; they don&#39;t (try to) report how many times a reader re-reads an issue. They do this by counting copies published, and then try to estimate, for their publication, on average how many people read a single copy at least once. The key point is that the results aren&#39;t exact, but are still useful. Another model is that of coding inquiries in such a way that the advertiser can tell which publication produced the inquiry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この提案は、ハードコピー出版物の発行者のものと同様のモデルをサポートします。多くの人が少なくとも一度は出版物の問題を読んでどのように彼らの広告主に、このような出版社は（しよう）レポートを。彼らは（しよう）読者が問題を再読み込み回数を報告しません。彼らは、公表されたコピーをカウントすることでこれを行い、その後、多くの人が少なくとも一度は単一のコピーを読んでどのように平均的には、彼らの出版のために、推定してみてください。キーポイントは、結果が正確ではありませんが、それでも有用であることです。別のモデルは、広告主が問い合わせを生成どの出版伝えることができるような方法で問い合わせを符号化するものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1 Goals, non-goals, and limitations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1目標、非目標、および制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 already allows origin servers to prevent caching of responses, and evidence exists [9] that at least some of the time, this is being done for the sole purpose of collecting counts of the number of accesses of specific pages. Some of this evidence is inferred from the study of proxy traces; some is based on explicit statements of the intention of the operators of Web servers. Information collected this way might or might not be of actual use to the people who collect it; the fact is that they want to collect it, or already do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1は、すでにオリジンサーバが応答のキャッシュを防ぐことができます、との証拠は、[9]少なくとも時間の一部、これは特定のページのアクセス数のカウントを収集する唯一の目的のために行われていることが存在します。この証拠のいくつかは、プロキシトレースの研究から推測されます。いくつかは、Webサーバのオペレータの意思の明示的な文に基づいています。またはそれを集める人々に実際の使用ではないかもしれないかもしれない、このように収集された情報。事実は、彼らはそれを収集したい、またはすでにそうということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The goal of this proposal is to provide an optional performance optimization for this use of HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この提案の目標は、HTTP / 1.1のこの使用のためのオプションのパフォーマンスの最適化を提供することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Optional: no server or proxy is required to implement it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - オプション：なし、サーバーやプロキシは、それを実装するために必要とされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Proxy-centered: there is no involvement on the part of end-client implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - プロキシ中心：エンドクライアント実装の一部には関与はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Solely a performance optimization: it provides no information or functionality that is not already available in HTTP/1.1. The intent is to improve performance overall, and reduce latency for almost all interactions; latency might be increased for a small fraction of HTTP interactions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - もっぱらパフォーマンスの最適化：それはHTTP / 1.1ですでに利用可能でない何の情報や機能を提供していません。その意図は、全体的なパフォーマンスを改善し、ほぼすべての相互作用のための待ち時間を短縮することです。待ち時間は、HTTPの相互作用のごく一部のために増加されることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Best-efforts: it does not guarantee the accuracy of the reported information, although it does provide accurate results in the absence of persistent network failures or host crashes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ベスト努力：それは永続的なネットワーク障害またはホストのクラッシュが存在しない場合に正確な結果を提供しませんが、それは、報告された情報の正確さを保証するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Neutral with respect to privacy: it reveals to servers no information about clients that is not already available through the existing features of HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - プライバシーに関してニュートラル：それはサーバにHTTP / 1.1の既存の機能を通じて、すでに利用可能でないクライアントに関する情報を明らかにしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The goals of this specification do not include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様の目標は含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Solving the entire problem of efficiently obtaining extensive information about requests made via proxies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 効率的なプロキシを経由して行われた要求に関する広範な情報を取得する全体の問題を解決します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Improving the protection of user privacy (although our proposal may reduce the transfer of user-specific information to servers, it does not prevent it).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - （私たちの提案は、サーバへのユーザ固有の情報の伝達を低減かもしれないが、それはそれを防ぐことはできません）ユーザーのプライバシーの保護を改善します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Preventing or encouraging the use of log-exchange mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 予防またはログ・交換メカニズムの使用を奨励します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Avoiding all forms of &#34;cache-busting&#34;, or even all cache-busting done for gathering counts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 「キャッシュの無効化」、あるいはすべてのキャッシュの無効化収集カウントのために行わのすべてのフォームを避けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This design has certain potential limitations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この設計は、特定の潜在的な制限があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If it is not deployed widely in both proxies and servers, it will provide little benefit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - それはプロキシとサーバの両方に広く展開されていない場合、それは少しの利益を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- It may, by partially solving the hit-counting problem, reduce the pressure to adopt more complete solutions, if any become available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - いずれかが利用可能になった場合は、部分的にヒットカウントの問題を解くことによって、より完全なソリューションを採用する圧力を減らすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Even if widely deployed, it might not be widely used, and so might not significantly improve performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 広く展開されている場合であっても、それが広く使用されないことがあり、そのため、パフォーマンスが大幅に改善されない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These potential limitations might not be problems in actual practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの潜在的な制限は、実際には問題ではないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2 Brief summary of the design
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
デザインの1.2簡単な要約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section is included for people not wishing to read the entire document; it is not a specification for the proposed design, and over-simplifies many aspects of the design.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、文書全体を読むことを望まない人々のために含まれています。それは、提案された設計のための仕様ではなく、設計の多くの側面を過剰に簡素化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The goal of this design is to eliminate the need for origin servers to use &#34;cache-busting&#34; techniques, when this is done just for the purpose of counting the number of users of a resource. (Cache-busting includes techniques such as setting immediate Expiration dates, or sending &#34;Cache-control: private&#34; in each response.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、リソースの利用者数をカウントする目的のためだけに行われたときに、この設計の目標は、オリジンサーバは、「キャッシュの無効化」技術を使用するための必要性を排除することです。 （「キャッシュ制御：プライベート」キャッシュの無効化は、そのような即時有効期限を設定し、または送信するなどの手法が含まれる。各応答を）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The design adds a new &#34;Meter&#34; header to HTTP; the header is always protected by the &#34;Connection&#34; header, and so is always hop-by-hop. This mechanism allows the construction of a &#34;metering subtree&#34;, which is a connected subtree of proxies, rooted at an origin server. Only those proxies that explicitly volunteer to join in the metering subtree for a resource participate in hit-metering, but those proxies that do volunteer are required to make their best effort to provide accurate counts. When a hit-metered response is forwarded outside of the metering subtree, the forwarding proxy adds &#34;Cache-control: s-maxage=0&#34;, so that other proxies (outside the metering subtree) are forced to forward all requests to a server in the metering subtree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デザインは、HTTPに新しい「メーター」ヘッダを追加します。ヘッダは常に「接続」ヘッダによって保護され、したがって常にホップバイホップです。この機構は、オリジンサーバをルートプロキシの接続部分木である「計量サブツリー」の構築を可能にします。明示的リソースのための計量サブツリーに参加するボランティアのみプロキシはヒット計量に参加しますが、ボランティアを行うこれらのプロキシは、正確なカウントを提供するために最善の努力をする必要があります。ヒット計量された応答が計量サブツリーの外に転送されると、転送プロキシは、「キャッシュ・コントロール：S-MAXAGE = 0」を付加、（計量サブツリー外）他のプロキシは、サーバへのすべての要求を転送することを余儀なくされているように、計量サブツリー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NOTE: the HTTP/1.1 specification does not currently define a &#34;s-maxage&#34; Cache-control directive. The HTTP working group has decided to add such a directive to the next revision of the HTTP/1.1 specification [7].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：HTTP / 1.1仕様では、現在「S-MAXAGE」キャッシュ制御ディレクティブを定義していません。 HTTPワーキンググループは、HTTP / 1.1仕様書[7]の次のリビジョンに、そのような指示を追加することを決定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Meter header carries zero or more directives, similar to the way that the Cache-control header carries directives. Proxies may use certain Meter directives to volunteer to do hit-metering for a resource. If a proxy does volunteer, the server may use certain directives to require that a response be hit-metered. Finally, proxies use a &#34;count&#34; Meter directive to report the accumulated hit counts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーターヘッダは、キャッシュ制御ヘッダは、ディレクティブを運ぶ方法と同様のゼロまたはそれ以上の指令を、運びます。プロキシは、リソースのためのヒット計量を行うためにボランティア活動する特定のメーターディレクティブを使用することができます。プロキシがボランティアをしている場合、サーバーは応答がヒット計量することを必要とする特定のディレクティブを使用することができます。最後に、プロキシは累積ヒット数を報告するための「カウント」メーターディレクティブを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Meter mechanism can also be used by a server to limit the number of uses that a cache may make of a cached response, before revalidating it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーターのメカニズムは、キャッシュがそれを再確認する前に、キャッシュされたレスポンスを行うことができる用途の数を制限するために、サーバで使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The full specification includes complete rules for counting &#34;uses&#34; of a response (e.g., non-conditional GETs) and &#34;reuses&#34; (conditional GETs). These rules ensure that the results are entirely consistent in all cases, except when systems or networks fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全な仕様は、応答の「用途」（例えば、非条件付き取得）および「再利用」（条件取得）をカウントするための完全な規則を含みます。これらのルールは、結果がシステムやネットワークに障害が発生する場合を除き、すべてのケースで完全に一致していることを確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3 Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document uses terms defined and explained in the HTTP/1.1 specification [4], including &#34;origin server,&#34; &#34;resource,&#34; &#34;hop-by-hop,&#34; &#34;unconditional GET,&#34; and &#34;conditional GET.&#34; The reader is expected to be familiar with the HTTP/1.1 specification and its terminology.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、定義された用語を使用し、「オリジンサーバ」、「リソース」、「ホップバイホップ」、「無条件GET」と「条件付きGETを含むHTTP / 1.1仕様[4]で説明しました」読者は、HTTP / 1.1の仕様とその用語に精通していることが予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHOULD&#34;, SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;NOT MUST&#34;、 &#34;REQUIRED&#34;、NOT」、 &#34;RECOMMENDED SHOULD &#34;SHOULD&#34;&#34;、 &#34;MAY&#34;、および &#34;&#34; OPTIONALは、RFC 2119に記載されるように解釈されるべきである[1 ]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2 Overview
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The design described in this document introduces several new features to HTTP:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書で説明した設計は、HTTPにいくつかの新機能が導入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Hit-metering: allows an origin server to obtain reasonably accurate counts of the number of clients using a resource instance via a proxy cache, or a hierarchy of proxy caches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ヒット計量は：オリジンサーバがプロキシキャッシュ、またはプロキシキャッシュの階層を経由して、リソースのインスタンスを使用しているクライアントの数の合理的に正確なカウントを得ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Usage-limiting: allows an origin server to control the number of times a cached response may be used by a proxy cache, or a hierarchy of proxy caches, before revalidation with the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 使用制限は：オリジンサーバと再検証する前に、キャッシュされた応答は、プロキシキャッシュまたはプロキシ・キャッシュの階層によって使用されることができる回数を制御するために、オリジンサーバが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These new non-mandatory features require minimal new protocol support, no change in protocol version, relatively little overhead in message headers. The design adds no additional network round-trips in any critical path that directly affects user-perceived latency (see section 4.3 for an analysis).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの新しい非必須の機能は、メッセージヘッダ内のプロトコルバージョン、比較的少ないオーバーヘッドに変化を最小限新しいプロトコルのサポートを必要としません。デザインは、直接ユーザ知覚の待ち時間に影響を与えるクリティカルパスには、追加のネットワーク・ラウンドトリップを（分析のためのセクション4.3を参照）を追加しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The primary goal of hit-metering and usage-limiting is to obviate the need for an origin server to send &#34;Cache-control: s-maxage=0&#34; with responses for resources whose value is not likely to change immediately. In other words, in cases where the only reason for contacting the origin server on every request that might otherwise be satisfied by a proxy cache entry is to allow the server to collect demographic information or to control the number of times a cache entry is used, the extension proposed here will avoid a significant amount of unnecessary network traffic and latency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「：= 0 S-MAXAGEのCache-Controlの」価値すぐに変更される可能性が低いリソースに対する回答でヒット-計量と使用制限の主な目的は、送信するオリジンサーバの必要性を回避することです。言い換えれば、場合によってはそれ以外の場合は、プロキシキャッシュエントリによって満たされるかもしれないすべての要求にオリジンサーバを接触させるための唯一の理由は、サーバが人口統計情報を収集したり、キャッシュエントリが使用される回数を制御できるようにすることであり、ここで提案されている拡張子は不要なネットワークトラフィックと待ち時間を大幅に回避します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This design introduces one new &#34;Meter&#34; header, which is used both in HTTP request messages and HTTP response messages. The Meter header is used to transmit a number of directives and reports. In particular, all negotiation of the use of hit-metering and usage limits is done using this header. No other changes to the existing HTTP/1.1 specification [4] are proposed in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この設計は、HTTPリクエストメッセージとHTTP応答メッセージの両方に使用される一つの新たな「メーター」ヘッダを導入します。メーターヘッダはディレクティブとレポートの数を送信するために使用されます。具体的には、ヒット計量および使用制限の使用のすべての交渉は、このヘッダを使用して行われます。既存のHTTP / 1.1仕様[4]に他の変更は、本文書で提案されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This design also introduces several new concepts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この設計は、いくつかの新しい概念が導入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. The concepts of a &#34;use&#34; of a cache entry, which is when a proxy returns its entity-body in response to a conditional or non-conditional request, and the &#34;reuse&#34; of a cache entry, which is when a proxy returns a 304 (Not Modified) response to a conditional request which is satisfied by that cache entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.プロキシは、条件付き又は無条件要求に応答してそのエンティティボディを返す場合であるキャッシュエントリの「使用」の概念、およびプロキシのキャッシュエントリの「リユース」、そのキャッシュ・エントリによって満たされる条件付きの要求に304（変更されていません）応答を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. The concept of a hit-metered resource, for which proxy caches make a best-effort attempt to report accurate counts of uses and/or reuses to the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.ヒット計量リソースの概念は、プロキシキャッシュは用途の正確な数を報告するベストエフォート型試みを行い、および/またはオリジンサーバに再利用しているため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. The concept of a usage-limited resource, for which the origin server expects proxy caches to limit the number of uses and/or reuses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前記オリジンサーバは、プロキシキャッシュが使用および/または再利用の数を制限することを期待するために使用が制限されたリソースの概念。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The new Meter directives and reports interact to allow proxy caches and servers to cooperate in the collection of demographic data. The goal is a best-efforts approximation of the true number of uses and/or reuses, not a guaranteed exact count.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいメーターディレクティブとレポートは、プロキシキャッシュおよびサーバは人口統計データの収集に協力することを可能にするために相互作用します。目標は、用途および/または再利用ではなく、保証正確な数の真数の最高の努力の近似です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The new Meter directives also allow a server to bound the inaccuracy of a particular hit-count, by bounding the number of uses between reports. It can also, for example, bound the number of times the same ad is shown because of caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいメーターディレクティブは、サーバーがレポート間の使用回数をバウンディングことで、特定のヒット数の不正確さをバインドすることができます。また、例えば、同じ広告があるため、キャッシュの表示された回数をバインドすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 7.1 describes a way to use server-driven content negotiation (the Vary header) that allows an HTTP origin server to flexibly separate requests into categories and count requests by category. Implementation of such a categorized hit counting is likely to be a very small modification to most implementations of Vary; some implementations may not require any modification at all.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7.1節では、HTTPオリジンサーバのカテゴリとカテゴリ別にカウント要求に柔軟に個別の要求を可能にする、サーバー駆動型コンテンツネゴシエーション（ヴァリヘッダ）を使用する方法を説明します。このように分類ヒットカウントの実装はヴァリのほとんどの実装に非常に小さな変更である可能性が高いです。いくつかの実装は、まったく変更を必要としなくてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1 Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1ディスカッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Mapping this onto the publishing model, a proxy cache would increment the use-count for a cache entry once for each unconditional GET done for the entry, and once for each conditional GET that results in sending a copy of the entry to update a client&#39;s invalid cached copy. Conditional GETs that result in 304 (Not Modified) are not included in the use-count, because they do not result in a new user seeing the page, but instead signify a repeat view by a user that had seen it before. However, 304 responses are counted in the reuse-count. HEADs are not counted at all, because their responses do not contain an entity-body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出版モデルにこれをマッピング、プロキシキャッシュは、クライアントの無効を更新するために、エントリのコピーを送信し、その結果、各条件付きGETのために一度エントリーのために行われ、各無条件GETのために一度キャッシュエントリの使用カウントをインクリメントし、そしてだろうキャッシュされたコピー。条件は304で、その結果を取得し、彼らはページを見て、新しいユーザーになり、代わりに前にそれを見ていたユーザーが繰り返し表示を意味しないため、（変更不可）、使用カウントに含まれません。しかし、304の応答は、再利用回数にカウントされます。それらの応答は、エンティティボディを含まないのでヘッドが、すべてではカウントされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Meter directives apply only to shared proxy caches, not to end-client (or other single-user) caches. Single user caches should not use Meter, because their hits will be automatically counted as a result of the unconditional GET with which they first fetch the page, from either the origin-server or from a proxy cache. Their subsequent conditional GETs do not result in a new user seeing the page.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーターディレクティブは、エンドクライアントにない（または他のシングルユーザ）キャッシュを共有プロキシ・キャッシュにのみ適用されます。彼らのヒット曲が自動的に彼らが最初にどちらかの原点-サーバーまたはプロキシキャッシュから、ページの取得されて無条件のGETの結果としてカウントされますので、単一のユーザー・キャッシュは、メーターを使用しないでください。彼らのその後の条件は、ページを見て、新しいユーザーにはなりません取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The mechanism specified here counts GETs; other methods either do not result in a page for the user to read, aren&#39;t cached, or are &#34;written-through&#34; and so can be directly counted by the origin server. (If, in the future, a &#34;cachable POST&#34; came into existence, whereby the entity-body in the POST request was used to select a cached response, then such POSTs would have to be treated just like GETs.) The applicability of hit-metering to any new HTTP methods that might be defined in the future is currently unspecifiable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで指定されたメカニズムを取得数えます。他の方法が読むためのユーザーのページにはなりません。どちらか、キャッシュされていない、または「スルーを書かれて」いるので、直接、オリジンサーバによってカウントすることができます。 （将来的には、「キャッシュ可能POSTは、」POSTリクエスト内のエンティティ・ボディがキャッシュされた応答を選択するために使用したところ、そのようなポストが扱わなければならないだけのGET好き、存在に入って来た、場合。）ヒットの適用将来的に定義されている可能性のある新しいHTTPメソッドに-meteringは現在unspecifiableです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of multiple caches along a path, a proxy cache does the obvious summation when it receives a use-count or reuse-count in a request from another cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは他のキャッシュからの要求に使用するカウントまたは再使用カウントを受信したときに経路に沿って複数のキャッシュの場合には、プロキシキャッシュは明らか加算を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3 Design concepts
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3つのデザインコンセプト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to allow the introduction of hit-metering and usage-limiting without requiring a protocol revision, and to ensure a reasonably close approximation of accurate counts, the negotiation of metering and usage-limiting is done hop-by-hop, not end-to-end. If one considers the &#34;tree&#34; of proxies that receive, store, and forward a specific response, the intent of this design is that within some (possibly null) &#34;metering subtree&#34;, rooted at the origin server, all proxies are using the hit-metering and/or usage-limiting requested by the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヒット計測とを導入できるようにするためにホップバイホップに行われたプロトコルの改訂を必要とせずに使用を制限し、正確な数の合理的近似、計量及び利用制限の交渉を確保するために、エンドではありません最後まで。 1は、店舗を受け、特定の応答を転送プロキシの「木」を考慮した場合、この設計の意図は、オリジンサーバをルートといくつかの（nullの可能性がある）「計量サブツリー」内に、すべてのプロキシがヒットを使用していることです-meteringおよび/または利用制限オリジンサーバから要求されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxies at the leaves of this subtree will insert a &#34;Cache-control: s-maxage=0&#34; directive, which forces all other proxies (below this subtree) to check with a leaf of the metering subtree on every request. However, it does not prevent them from storing and using the response, if the revalidation succeeds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このサブツリーの葉のプロキシは、「キャッシュ・コントロール：S-MAXAGE = 0」を挿入します（このサブツリーの下に）他のすべてのプロキシを強制的に指示、リクエストごとに計量サブツリーの葉に確認します。しかし、それは保存と再検証が成功した場合、応答を使用してからそれらを防ぐことはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
No proxy is required to implement hit-metering or usage-limiting. However, any proxy that transmits the Meter header in a request MUST implement every unconditional requirement of this specification, without exception or amendment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いいえプロキシはヒット計量や利用制限を実施するために必要とされません。ただし、例外又は修正することなく、本明細書のすべての無条件の要件を実装しなければならない要求にメーターヘッダを送信する任意のプロキシ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is a conservative design, which may sometimes fail to take advantage of hit-metering support in proxies outside the metering subtree. However, it is likely that without the reliability offered by a conservative design, managers of origin servers with requirements for accurate approximations will not take advantage of any hit-metering proposal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは時々計量サブツリー外のプロキシでヒット計量サポートを利用するために失敗することがあり保守的なデザインです。しかし、保守的な設計が提供する信頼性なしに、正確な近似のための要件とオリジンサーバの管理者が任意のヒット計量提案を活用していない可能性が高いです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The hit-metering/usage-limiting mechanism is designed to avoid any extra network round-trips in the critical path of any client request, and (as much as possible) to avoid excessively lengthening HTTP messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヒット測光/利用制限機構が過剰に延長HTTPメッセージを避けるために（可能な限り）任意のクライアント要求のクリティカルパスに余分なネットワーク・ラウンドトリップを回避するように設計されており、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Meter header is used to transmit both negotiation information and numeric information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーターヘッダは、ネゴシエーション情報と数値情報の両方を送信するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A formal specification for the Meter header appears in section 5; the following discussion uses an informal approach to improve clarity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーターヘッダの形式仕様は、セクション5に表示され、以下の議論は、明瞭性を改善するための非公式なアプローチを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 Implementation of the &#34;metering subtree&#34;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
「計量サブツリー」の3.1実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;metering subtree&#34; approach is implemented in a simple, straightforward way by defining the new &#34;Meter&#34; header as one that MUST always be protected by a Connection header in every request or response. I.e., if the Meter header is present in an HTTP message, that message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「計量サブツリー」アプローチは、常にすべての要求または応答の接続ヘッダによって保護されなければならないものとして、新たな「メーター」ヘッダを定義することによって、単純な、簡単な方法で実装されています。即ち、メータヘッダがHTTPメッセージ内に存在する場合、そのメッセージ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. MUST contain &#34;Connection: meter&#34;, and MUST be handled according to the HTTP/1.1 specification of the Connection header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.「接続：メーター」含まなければなりません、と接続ヘッダのHTTP / 1.1仕様に従って処理されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. MUST NOT be sent in response to a request from a client whose version number is less than HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.バージョン番号HTTP / 1.1未満であるクライアントからの要求に応じて送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. MUST NOT be accepted from a client whose version number is less than HTTP/1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.は、そのバージョン番号HTTP / 1.1未満であるクライアントから受け入れてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The reason for the latter two restrictions is to protect against proxies that might not properly implement the Connection header. Otherwise, a subtree that includes an HTTP/1.0 proxy might erroneously appear to be a metering subtree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
後者の2つの制約の理由は、適切にConnectionヘッダを実装していない可能性がありますプロキシから保護することです。それ以外の場合は、HTTP / 1.0プロキシが含まれるサブツリーが誤って計量サブツリーのように見えるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: It appears that for the Connection header mechanism to function correctly, a system receiving an HTTP/1.0 (or lower-version) message that includes a Connection header must act as if this header, and all of the headers it protects, ought to have been removed from the message by an intermediate proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：正しく機能するために接続ヘッダ機構に、接続ヘッダを含むシステム受信HTTP / 1.0（以下バージョン）メッセージがこのヘッダかのように行動しなければならない、そしてそれが保護ヘッダの全てと思われるべき中間プロキシがメッセージから除去されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although RFC2068 does not specifically require this behavior, it appears to be implied. Otherwise, one could not depend on the stated property (section 14.10) that the protected options &#34;MUST NOT be communicated by proxies over further connections.&#34; This should probably be clarified in a subsequent draft of the HTTP/1.1 specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC2068は、特にこの動作を必要としませんが、暗示しているように見えます。そうでなければ、人は保護されたオプションは、「さらに接続を介してプロキシによって伝達してはならない。」と述べているプロパティ（セクション14.10）に依存しませんでしたこれはおそらく、HTTP / 1.1仕様のその後の草案で明らかにされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification does not, in any way, propose a modification of the specification of the Connection header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様は、どのような方法で、接続ヘッダの仕様の変更を提案していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
From the point of view of an origin server, the proxies in a metering subtree work together to obey usage limits and to maintain accurate usage counts. When an origin server specifies a usage limit, a proxy in the metering subtree may subdivide this limit among its children in the subtree as it sees fit. Similarly, when a proxy in the subtree receives a usage report, it ensures that the hits represented by this report are summed properly and reported to the origin server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバの観点から、計量サブツリー内のプロキシは、使用制限を遵守するために、正確な使用カウントを維持するために一緒に働きます。オリジンサーバが使用制限を指定すると、計量サブツリー内のプロキシは、それが適当と考えるようサブツリーでの子供たちの間でこの制限を細分化することがあります。サブツリー内のプロキシが使用状況レポートを受信したとき同様に、それはこの報告書に代表されるヒットが適切に加算され、オリジンサーバに報告されることが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a proxy forwards a hit-metered or usage-limited response to a client (proxy or end-client) not in the metering subtree, it MUST omit the Meter header, and it MUST add &#34;Cache-control: s-maxage=0&#34; to the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシがヒット計量又はクライアント（プロキシまたはエンドクライアント）へない計量サブツリーにおける使用制限応答を転送する場合は、メーターヘッダを省略する必要があり、それが「キャッシュ・コントロールを追加する必要がありますS-MAXAGE = 0 「応答へ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Format of the Meter header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
メーターヘッダの3.2フォーマット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Meter header is used to carry zero or more directives. Multiple Meter headers may occur in an HTTP message, but according to the rules in section 4.2 of the HTTP/1.1 specification [4], they may be combined into a single header (and should be so combined, to reduce overhead).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーターヘッダはゼロまたはそれ以上の指令を運ぶために使用されます。複数メーターヘッダはHTTPメッセージで起こり得るが、HTTP / 1.1仕様のセクション4.2の規則に従って、[4]、それらは単一のヘッダに結合されてもよい（そしてオーバーヘッドを低減するために、合成されるべきです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, the following sequence of Meter headers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、メーターヘッダの以下の配列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Meter: max-uses=3
       Meter: max-reuses=10
       Meter: do-report
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
may be expressed as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のように表すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meter: max-uses=3, max-reuses=10, do-report
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーター：MAX-用途= 3、MAX-再利用= 10、行う-レポート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 Negotiation of hit-metering and usage-limiting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ヒット計測と使用制限の3.3交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An origin server that wants to collect hit counts for a resource, by simply forcing all requests to bypass any proxy caches, would respond to requests on the resource with &#34;Cache-control: s-maxage=0&#34;. (An origin server wishing to prevent HTTP/1.0 proxies from improperly caching the response could also send both &#34;Expires: &lt;now&gt;&#34;, to prevent such caching, and &#34;Cache-control: max-age=NNNN&#34;, to allow newer proxies to cache the response).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単に任意のプロキシキャッシュをバイパスするすべての要求を強制することにより、リソースのためのヒット数を収集したいオリジンサーバは、とリソースの要求に応答する「キャッシュ・コントロール：S-MAXAGE = 0」。 「キャッシュ・コントロール：最大年齢は= NNNN」は、キャッシングを防ぐために、そして：（オリジンサーバが不適切にも両方送ることができます応答をキャッシュからHTTP / 1.0プロキシを防ぐために希望する「&lt;今&gt;有効期限」、新しいプロキシを許可します）応答をキャッシュします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The purpose of the Meter header is to obviate the need for &#34;Cache-control: s-maxage=0&#34; within a metering subtree. Thus, any proxy may negotiate the use of hit-metering and/or usage-limiting with the next-hop server. If this server is the origin server, or is already part of a metering subtree (rooted at the origin server), then it may complete the negotiation, thereby extending the metering subtree to include the new proxy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
計量サブツリー内：「= 0 S-MAXAGEキャッシュ制御」メーターヘッダの目的は、の必要性を回避することです。したがって、任意のプロキシがヒット計量及び/又は使用制限ネクストホップサーバとの使用を交渉することができます。このサーバは、オリジンサーバである、又は既に（オリジンサーバをルート）計量サブツリーの一部である場合、それは新たなプロキシを含むように計量サブツリーを延びる、ネゴシエーションを完了することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To start the negotiation, a proxy sends its request with one of the following Meter directives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
交渉を開始するには、プロキシは以下のメーターディレクティブのいずれかでその要求を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
will-report-and-limit indicates that the proxy is willing and able to return usage reports and will obey any usage-limits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
意志-レポートおよび制限プロキシが使用状況レポートを返すようにし、任意の利用制限に従います意思と能力であることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
wont-report indicates that the proxy will obey usage-limits but will not send usage reports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文句を言わない - 報告書は、プロキシが利用制限に従いますが、使用状況レポートを送信しないことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
wont-limit indicates that the proxy will not obey usage-limits but will send usage reports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文句を言わない制限は、プロキシが利用制限に従わないであろうが、使用状況レポートを送信することを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy willing to neither obey usage-limits nor send usage reports MUST NOT transmit a Meter header in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
利用制限に従わなかったり、使用レポートを送信どちらに喜んプロキシはリクエストにメーターヘッダを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By definition, an empty Meter header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義により、空メーターヘッダ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meter:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーター：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
is equivalent to &#34;Meter: will-report-and-limit&#34;, and so, by the definition of the Connection header (see section 14.10 of the HTTP/1.1 specification [4]), a request that contains
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「メーター：意志・レポート・アンド・リミット」と同等であるので、接続ヘッダの定義で（HTTP / 1.1仕様のセクション14.10を参照[4]）が含ま要求
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Connection: Meter
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続：メーター
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
and no explicit Meter header is equivalent to a request that contains
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そして明示的なメーターヘッダが含ま要求に相当しません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Connection: Meter
       Meter: will-report-and-limit
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This makes the default case more efficient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これはデフォルトの場合は、より効率的になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An origin server that is not interested in metering or usage-limiting the requested resource simply ignores the Meter header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
計量又は使用制限に興味がないオリジンサーバ要求されたリソースは、単にメーターヘッダを無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server wants the proxy to do hit-metering and/or usage-limiting, its response should include one or more of the following Meter directives:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバがプロキシがヒット計量および/または利用制限をしたい場合は、その応答は以下のメーター指示の一つ以上を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For hit-metering:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヒット計量の場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
do-report specifies that the proxy MUST send usage reports to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
やる-報告書は、プロキシがサーバに使用状況レポートを送信する必要があることを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
dont-report specifies that the proxy SHOULD NOT send usage reports to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドント・レポートは、プロキシがサーバに利用状況レポートを送信しないように指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
timeout=NNN sets a metering timeout of NNN minutes, from the time that this response was originated, for the reporting of a hit-count. If the proxy has a non-zero hit count for this response when the timeout expires, it MUST send a report to the server at or before that time. Implies &#34;do-report&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムアウト= NNNは、この応答はヒット数の報告のために、発信された時点から、NNN分の計量タイムアウトを設定します。タイムアウトが満了したときにプロキシがこの応答のための非ゼロのヒット数を持っている場合、それはその時に以前のサーバーにレポートを送らなければなりません。 「やる・レポート」を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By definition, an empty Meter header in a response, or any Meter header that does not contain &#34;dont-report&#34;, means &#34;Meter: do-report&#34;; this makes a common case more efficient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義では、応答で空メーターヘッダ、または「ドント・レポート」が含まれていない任意のメーターヘッダは、「メーター：-報告を行う」という意味します。これは一般的なケースは、より効率的になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: an origin server using the metering timeout mechanism to bound the collection period over which hit-counts are obtained should adjust the timeout values in the responses it sends so that all responses generated within that period reach their metering timeouts at or before the end of that period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：その期間内に発生したすべての応答がの終わりか前に計量タイムアウトに達するように、カウントを打つ上で収集期間をバインドするために計量タイムアウトメカニズムを使用して、オリジンサーバが得られるが、それが送信する応答にタイムアウト値を調整する必要がありますその期間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the origin server simply sends a constant metering timeout T with each response for a resource, the reports that it receives will reflect activity over a period whose duration is between T and N*T (in the worst case), where N is the maximum depth of the metering subtree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバは、単にリソースに対する各応答で一定計量タイムアウトTを送信する場合、それが受信したレポートは、その期間TとNが最大（最悪の場合）N * Tとの間の期間にわたって活動を反映します計量サブツリーの深さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For usage-limiting
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
利用制限します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
max-uses=NNN sets an upper limit of NNN &#34;uses&#34; of the response, not counting its immediate forwarding to the requesting end-client, for all proxies in the following subtree taken together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAX-用途= NNNは、一緒になって、次のサブツリー内のすべてのプロキシに、要求元のエンドクライアントへの即時転送を数えていない、応答のNNN「用途」の上限を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
max-reuses=NNN sets an upper limit of NNN &#34;reuses&#34; of the response for all proxies in the following subtree taken together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAX-再利用= NNNは、NNNの上限を設定し、一緒になって、以下のサブツリー内のすべてのプロキシに対する応答の「再利用」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a proxy has exhausted its allocation of &#34;uses&#34; or &#34;reuses&#34; for a cache entry, it MUST revalidate the cache entry (using a conditional request) before returning it in a response. (The proxy SHOULD use this revalidation message to send a usage report, if one was requested and it is time to send it. See sections 3.4 and 3.5.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシは、キャッシュ・エントリは、「使用」または「再利用」のその割り当てを使い果たした場合、それは応答でそれを戻す前に（条件付きの要求を使用して）キャッシュエントリを再検証しなければなりません。 （1が要求されたと、それを送信する時間である場合、プロキシは、使用状況レポートを送信するには、この再検証メッセージを使用すべきである。セクション3.4と3.5を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These Meter response-directives apply only to the specific response that they are attached to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのメーターレスポンス・ディレクティブは、彼らだけが接続されていることを特定の応答に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the limit on &#34;uses&#34; set by the max-uses directive does not include the use of the response to satisfy the end-client request that caused the proxy&#39;s request to the server. This counting rule supports the notion of a cache-initiated prefetch: a cache may issue a prefetch request, receive a max-uses=0 response, store that response, and then return that response (without revalidation) when a client makes an actual request for the resource. However, each such response may be used at most once in this way, so the origin server maintains precise control over the number of actual uses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAX-用途ディレクティブによって設定された「用途」の制限は、サーバーへのプロキシの要求を引き起こしたエンドクライアントの要求を満たすために、応答の使用を含んでいないことに注意してください。このカウントルールは、キャッシュが開始したプリフェッチの概念をサポートします。クライアントは、実際の要求を行う際にキャッシュは、MAX-用途= 0の応答を受信し、プリフェッチ要求を発行している応答を保存した後、（再検証せずに）その応答を返すことがあります。リソースのため。しかしながら、このような各応答は、このように多くとも一度だけ使用することができるので、オリジンサーバは、実際の用途の数を正確に制御を維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server MUST NOT send a Meter header that would require a proxy to do something that it has not yet offered to do. A proxy receiving a Meter response-directive asking the proxy to do something it did not volunteer to do SHOULD ignore that directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、それはまだやることを申し出ていない何かをするためにプロキシを必要とするメーターヘッダを送ってはいけません。応答指令、それはそのディレクティブを無視すべきでやってボランティアしませんでした何かをするプロキシを尋ねるメーターを受けプロキシ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy receiving a Meter header in a response MUST either obey it, or it MUST revalidate the corresponding cache entry on every access. (I.e., if it chooses not to obey the Meter header in a response, it MUST act as if the response included &#34;Cache-control: s-maxage=0&#34;.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答メーターヘッダを受信したプロキシはそれに従わなければならないか、それがすべてのアクセスに対応するキャッシュエントリを再検証しなければなりません。 （それが応答してメーターヘッダに従うしないことを選択した場合、すなわち、応答が含まれている場合のように作用しなければならない「キャッシュ制御：S-MAXAGE = 0」とします。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: a proxy that has not sent the Meter header in a request for the given resource, and which has therefore not volunteered to honor Meter directives in a response, is not required to honor them. If, in this situation, the server does send a Meter header in a response, this is a protocol error. However, based on the robustness principle, the proxy may choose to interpret the Meter header as an implicit request to include &#34;Cache-control: s-maxage=0&#34; when it forwards the response, since this preserves the apparent intention of the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：指定されたリソースに対する要求にメーターヘッダを送信していないプロキシ、したがって応答メーター指示を尊重するために志願していない、それらを尊重する必要がありません。このような状況では、サーバが応答してメーターヘッダを送信しない場合、これは、プロトコル・エラーです。これは、サーバーの見かけの意図を維持するので、それは、応答を転送する場合：しかし、堅牢性の原則に基づいて、プロキシは、「S-MAXAGE = 0のCache-Control」を含むように、暗黙的な要求としてメーターヘッダを解釈することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy that receives the Meter header in a request may ignore it only to the extent that this is consistent with its own duty to the next-hop server. If the received Meter request header is inconsistent with that duty, or if no Meter request header is received and the response from the next-hop server requests any form of metering or limiting, then the proxy MUST add &#34;Cache-control: s-maxage=0&#34; to any response it forwards for that request. (A proxy SHOULD NOT add or change the Expires header or max-age Cache-control directive.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求にメーターヘッダを受信したプロキシは、このネクストホップサーバに独自のデューティと一致する程度まで、それを無視することができます。受信メーターリクエストヘッダがその義務と矛盾する、または全くメーター要求ヘッダが受信されない場合、次のホップのサーバからの応答が計量又は制限の任意の形式を要求し、プロキシは、「キャッシュ・コントロールを追加する必要がある場合：S-MAXAGE = 0&#34; の応答には、その要求のために転送します。 （プロキシは、ヘッダーまたは最大エージングキャッシュ制御ディレクティブを有効期限を追加したり、変更しないでください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, if proxy A receives a GET request from proxy B for URL X with &#34;Connection: Meter&#34;, but proxy A&#39;s cached response for URL does not include any Meter directives, then proxy A may ignore the metering offer from proxy B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
たとえば、プロキシAは、「接続：メーター」とURLのX用のプロキシBからのGETリクエストを受信した場合、しかし、URLのプロキシAのキャッシュされた応答は、任意のメーターディレクティブが含まれていない場合、プロキシAは、プロキシBから計量プランを無視すること
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, if proxy A has previously told the origin server &#34;Meter: wont-limit&#34; (implying will-report), and the cached response contains &#34;Meter: do-report&#34;, and proxy B&#39;s request includes &#34;Meter: wont-report&#34;, then proxy B&#39;s offer is inconsistent with proxy A&#39;s duty to the origin server. Therefore, in this case proxy A must add &#34;Cache-control: s-maxage=0&#34; when it returns the cached response to proxy B, and must not include a Meter header in this response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、プロキシAは以前にオリジンサーバ告げた場合：（意志-レポートを意味している）「メーターを文句を言わない制限」、およびキャッシュされたレスポンスが含まれている「メーター：-報告を行う」、およびプロキシBの要求は、「メーター：文句を言わない - 報告書」には、 、その後、プロキシBの申し出は、オリジンサーバーへのプロキシAの義務と矛盾しています。したがって、この場合にはプロキシ・Aは、「キャッシュ・コントロール：S-MAXAGE = 0」を追加する必要があり、それは、プロキシBにキャッシュされた応答を返し、この応答メータヘッダを含んではならない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a server does not want to use the Meter mechanism, and will not want to use it any time soon, it may send this directive:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、メーターのメカニズムを使用したくないし、いつでもすぐにそれを使用したくない場合は、このディレクティブを送信することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
wont-ask recommends that the proxy SHOULD NOT send any Meter directives to this server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文句を言わない-尋ねるプロキシは、このサーバに任意のメーター指示を送るべきではないことをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The proxy SHOULD remember this fact for up to 24 hours. This avoids virtually all unnecessary overheads for servers that do not wish to use or support the Meter header. (This directive also implies &#34;dont-report&#34;.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシは、最大24時間のためにこの事実を忘れてはなりません。これは、事実上すべてのメーターヘッダーを使用するか、またはサポートしたくないサーバーには不要なオーバーヘッドを回避することができます。 （このディレクティブは「いけない-レポート」を意味します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4 Transmission of usage reports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
使用状況レポートの3.4送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To transmit a usage report, a proxy sends the following Meter header in a request on the appropriate resource:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
使用レポートを送信するために、プロキシは、適切なリソースに要求で次メーターヘッダを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meter: count=NNN/MMM
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーター：数= NNN / MMM
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first integer indicates the count of uses of the cache entry since the last report; the second integer indicates the count of reuses of the entry (see section 5.3 for rules on counting uses and reuses). The transmission of a &#34;count&#34; directive in a request with no other Meter directive is also defined as an implicit transmission of a &#34;will-report-and-limit&#34; directive, to optimize the common case. (A proxy not willing to honor usage-limits would send &#34;Meter: count=NNN/MMM, wont-limit&#34; for its reports.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の整数は前回の報告以降、キャッシュエントリの用途の数を示します。 2番目の整数は、エントリの再利用の回数（カウント使用および再利用に関するルールのセクション5.3を参照）を示しています。ない他のメーター指令と要求で「カウント」指令の送信はまた、一般的なケースを最適化するために、「意志・レポート・アンド・リミット」命令の暗黙の送信として定義されます。 （利用制限が送ります称えることを望んでいないプロキシ：そのレポートの「メーターを文句を言わない制限、= NNN / MMMを数えます」。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that when a proxy forwards a client&#39;s request and receives a response, the response that the proxy sends immediately to the requesting client is not counted as a &#34;use&#34;. I.e., the reported count is the number of times the cache entry was used, and not the number of times that the response was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシは、クライアントの要求を転送し、応答を受信したときに、プロキシが要求しているクライアントに即座に送信する応答が「使用」としてカウントされないことに注意してください。すなわち、報告されたカウントは、キャッシュエントリが使用された回数ではなく、応答が使用された回数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy SHOULD NOT transmit &#34;Meter: count=0/0&#34;, since this conveys no useful information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシは、「メーター：数= 0/0」を送信すべきではない、これは有用な情報を伝えるないので。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Usage reports MUST always be transmitted as part of a conditional request (such as a GET or HEAD), since the information in the conditional header (e.g., If-Modified-Since or If-None-Match) is required for the origin server to know which instance of a resource is being counted. Proxys forwarding usage reports up the metering subtree MUST NOT change the contents of the conditional header, since otherwise this would result in incorrect counting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（変更した場合-ので又は場合-なしマッチ例えば、）条件ヘッダ内の情報は、原点サーバーに必要とされるので、使用レポートは常に、（例えばGETまたはHEADのような）条件要求の一部として送信されなければなりませんカウントされているリソースのどのインスタンスを知っています。そうでない場合は、これは間違ったカウントにつながるので、計量サブツリーまで使用レポートを転送するのproxysは、条件付きのヘッダの内容を変更しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A usage report MUST NOT be transmitted as part of a forwarded request that includes multiple entity tags in an If-None-Match or If-Match header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
使用レポートは、If-なしマッチ場合やマッチヘッダ内の複数のエンティティタグを含む転送要求の一部として送信してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: a proxy that offers its willingness to do hit-metering (report usage) must count both uses and reuses. It is not possible to negotiate the reporting of one but not the other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：ヒット計量（レポートの使用状況）を行うためにその意思を提供しています両方の用途をカウントしなければなりませんし、再利用するプロキシを。 1つはなく、他の報告を交渉することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5 When to send usage reports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
使用状況レポートを送信するために3.5
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy that has offered to send usage reports to its parent in the metering subtree MUST send a usage report in each of these situations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
計量サブツリー内の親への使用レポートを送信するために提供したプロキシは、これらの各状況での使用状況レポートを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. When it forwards a conditional GET on the resource instance on behalf of one of its clients (if the GET is conditional on at most one entity-tag).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.（GETは最大1つのエンティティタグを条件であれば）、それはそのクライアントのいずれかに代わってリソースインスタンス上の条件付きGETを転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. When it forwards a conditional HEAD on the resource instance on behalf of one of its clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.それはそのクライアントのいずれかに代わってリソースインスタンス上の条件付きのHEADを転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. When it must generate a conditional GET to satisfy a client request because the max-uses limit has been exceeded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それが限度を超えた最大は、使用しているため、クライアントの要求を満たすために、条件付きGETを生成する必要があります。3.。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Upon expiration of a metering timeout associated with a cache entry that has a non-zero hit-count.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非ゼロのヒット数を持つキャッシュエントリに関連付けられた計量タイムアウトの満了4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. When it removes the corresponding non-zero hit-count entry from its storage for any reason including:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.それは、任意の理由でその記憶装置から対応する非ゼロヒットカウントエントリを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            - the proxy needs the storage space for another
              hit-count entry.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- the proxy is not able to store more than one response per resource, and a request forwarded on behalf of a client has resulted in the receipt of a new response (one with a different entity-tag or last-modified time).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - プロキシは、リソースごとに複数の応答を保存することができず、クライアントに代わって転送された要求は、新たな応答（異なるエンティティタグや最終更新時間1）の受信をもたらしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that a cache might continue to store hit-count information even after having deleted the body of the response, so it is not necessary to report the hit-count when deleting the body; it is only necessary to report it if the proxy is about to &#34;forget&#34; a non-zero value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、応答の本体を削除した後でさえもヒットカウント情報を格納し続ける可能性があることに注意してください、身体を削除するときのヒットカウントを報告する必要はありませんので。プロキシがゼロ以外の値を「忘れる」しようとしている場合、それを報告することが必要なだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(Section 5.3 explains how hit-counts become zero or non-zero.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（5.3節には、ヒット数がゼロまたは非ゼロになる方法を説明します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the usage report is being sent because the proxy is about to remove the hit-count entry from its storage, or because of an expired metering timeout:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシがその記憶装置から、または有効期限が切れているため計量タイムアウトのヒットカウントエントリを削除しようとしているので、使用状況レポートを送信されている場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The proxy MUST send the report as part of a conditional HEAD request on the resource instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - プロキシは、リソースインスタンス上の条件付きのHEAD要求の一部としてレポートを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The proxy is not required to retry the HEAD request if it fails (this is a best-efforts design). To improve accuracy, however, the proxy SHOULD retry failed HEAD requests, subject to resource constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - それは（これは最高の努力の設計で）失敗した場合、プロキシはHEADリクエストを再試行する必要はありません。精度を向上させるために、しかし、プロキシは、リソースの制約を受け、失敗したHEADリクエストを再試行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The proxy is not required to serialize any other operation on the completion of this request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - プロキシは、この要求の完了時に他の操作をシリアル化する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: proxy implementors are strongly encouraged to batch several HEAD-based reports to the same server, when possible, over a single persistent connection, to reduce network overhead as much as possible. This may involve a non-naive algorithm for scheduling the deletion of hit-count entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：可能な場合は、プロキシ実装が強く、同じサーバーへのバッチいくつかのHEADベースのレポートに奨励され、単一の持続的接続を介して、できるだけネットワークのオーバーヘッドを削減します。これは、ヒットカウントエントリの削除をスケジュールするための非ナイーブなアルゴリズムを含むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the usage count is sent because of an arriving request that also carries a &#34;count&#34; directive, the proxy MUST combine its own (possibly zero) use and reuse counts with the arriving counts, and then attempt to forward the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
使用回数が原因でも「カウント」ディレクティブを運ぶ到着要求で送信された場合、プロキシは使用（多分ゼロ）、独自に組み合わせて、到着カウントしてカウントを再利用して、要求を転送しようとしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, the proxy is not required to forward an arriving request with a &#34;count&#34; directive, provided that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、プロキシは「カウント」ディレクティブで到着要求を転送するために必要とされていない、それを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- it can reply to the request using a cached response, in compliance with other requirements of the HTTP specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - それは、HTTP仕様のその他の要求事項を遵守して、キャッシュされた応答を使用して要求に応答することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- such a response does not exceed a max-uses limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - このような応答は、制限値を、使用して最大を超えていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- it is not required to forward the request because of an expired metering timeout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 有効期限が切れているため計量タイムアウトの要求を転送する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an arriving request carries a &#34;count&#34; directive, and the proxy no longer has a cache entry for the resource, the proxy MUST forward the &#34;count&#34; directive. (This is, in any case, what a proxy without a suitable cache entry would normally do for any valid request it receives.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
到着した要求は「カウント」ディレクティブを運ばないし、プロキシは、もはやリソースのキャッシュエントリを持っている場合、プロキシは「カウント」ディレクティブを転送する必要があります。 （これは、適切なキャッシュエントリのないプロキシは、通常、それが受け取る任意の有効な要求のために何をするのか、いずれにしても、です。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6 Subdivision of usage-limits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
利用制限の3.6区
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When an origin server specifies a usage limit, a proxy in the metering subtree may subdivide this limit among its children in the subtree as it sees fit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバが使用制限を指定すると、計量サブツリー内のプロキシは、それが適当と考えるようサブツリーでの子供たちの間でこの制限を細分化することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, consider the situation with two proxies P1 and P2, each of which uses proxy P3 as a way to reach origin server S. Imagine that S sends P3 a response with
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、オリジンサーバS. SはP3にして応答を送信することを想像して到達する方法として、プロキシP3を使用して、それぞれが、2つのプロキシP1とP2との状況を考えます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meter: max-uses=10
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーター：MAX-用途= 10
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The proxies use that response to satisfy the current requesting end-client. The max-uses directive in this example allows the combination of P1, P2, and P3 together to satisfy 10 additional end-client uses (unconditional GETs) for the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシは、現在の要求のエンドクライアントを満足させるためにその応答を使用しています。この例ではMAX-用途ディレクティブは一緒にP1、P2、およびP3の組み合わせがリソースの10追加のエンドクライアント用途（無条件取得）を満足することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification does not constrain how P3 divides up that allocation among itself and the other proxies. For example, P3 could retain all of max-use allocation for itself. In that case, it would forward the response to P1 and/or P2 with
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
P3は、自身と他のプロキシの間でその割り当てを分割する方法この仕様は制限しません。例えば、P3は、自身の最大使用の割り当てのすべてを保持できます。その場合には、P1および/またはP2とに応答を転送することになります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meter: max-uses=0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーター：MAX-用途= 0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
P3 might also divide the allocation equally among P1 and P2, retaining none for itself (which may be the right choice if P3 has few or no other clients). In this case, it could send
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
P3はまた、（P3がいくつかを持っていないか、他のクライアント場合に正しい選択であってもよい）自体のいずれを保持しない、P1とP2の間で均等に割り当てを分割するかもしれません。この場合、それは送ることができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meter: max-uses=5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーター：MAX-用途= 5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
to the proxy (P1 or P2) that made the initial request, and then record in some internal data structure that it &#34;owes&#34; the other proxy the rest of the allocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の要求を行ったプロキシ（P1またはP2）、そしてそれは割り当ての残りの部分を他のプロキシ「を負って」いくつかの内部データ構造のレコードへ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that this freedom to choose the max-uses value applies to the origin server, as well. There is no requirement that an origin server send the same max-uses value to all caches. For example, it might make sense to send &#34;max-uses=2&#34; the first time one hears from a cache, and then double the value (up to some maximum limit) each time one gets a &#34;use-count&#34; from that cache. The idea is that the faster a cache is using up its max-use quota, the more likely it will be to report a use-count value before removing the cache entry. Also, high and frequent use-counts imply a corresponding high efficiency benefit from allowing caching.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAX-用途値を選択するには、この自由は、同様に、オリジンサーバに適用されることに注意してください。オリジンサーバがすべてのキャッシュに同じMAX-用途値を送信する必要はありません。例えば、それは感覚を送信するために作るかもしれない「MAX-用途を= 2」1は、（いくつかの上限まで）1は、そのキャッシュから「使用カウント」を取得するたびに、キャッシュから聞き、その後、値を倍に初めて。アイデアは、より高速なキャッシュがその最大使用クォータを使用している、より多くの可能性が高いが、それがキャッシュエントリを削除する前に、使用カウント値を報告することになるということです。また、高い頻繁利用カウントはキャッシングを可能にするから対応する高効率の利点を暗示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Again, the details of such heuristics would be outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
再び、そのようなヒューリスティックの詳細は、本明細書の範囲外であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4 Analysis
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4つの分析
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section includes informal analyses of several aspects of hit-metering:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、ヒット計量のいくつかの側面の非公式な分析が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. the accuracy of results when applied to counting users (section 4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.カウントユーザ（セクション4.1）に適用される結果の精度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. the problem of counting users whose browsers do not include caches, such as Network Computers (section 4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.そのブラウザのユーザーは、このようなネットワークコンピュータ]（セクション4.2）のようにキャッシュを含まないカウントの問題。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. delays imposed on &#34;critical paths&#34; for HTTP operations (section 4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP操作のための「クリティカルパス」（セクション4.3）に課さ3.遅延。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 Approximation accuracy for counting users
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ユーザーをカウントする4.1近似精度
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For many (but not all) service operators, the single most important aspect of the request stream is the number of distinct users who have retrieved a particular entity within a given period (e.g., during a given day). The hit-metering mechanism is designed to provide an origin server with an approximation of the number of users that reference a given resource. The intent of the design is that the precision of this approximation is consistent with the goals of simplicity and optional implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くの（全てではない）は、サービス事業者のために、要求ストリームの単一の最も重要な側面は、所定の期間（例えば、所与の日の間）内の特定のエンティティを取得した異なるユーザーの数です。ヒット計量機構は、与えられたリソースを参照するユーザーの数の近似値とオリジンサーバを提供するように設計されます。設計の意図は、この近似の精度は、シンプルさと、オプションの実装の目標と一致していることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Almost all Web users use client software that maintains local caches, and the state of the art of local-caching technology is quite effective. (Section 4.2 discusses the case where end-client caches are small or non-existent.) Therefore, assuming an effective and persistent end-client cache, each individual user who retrieves an entity does exactly one GET request that results in a 200 or 203 response, or a 206 response that includes the first byte of the entity. If a proxy cache maintains and reports an accurate use-count of such retrievals, then its reported use-count will closely approximate the number of distinct users who have retrieved the entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ほとんどすべてのWebユーザーは、ローカルキャッシュを保持し、クライアントソフトウェアを使用して、ローカルキャッシング技術の分野の状態は非常に効果的です。 （セクション4.2は、エンドクライアントキャッシュが小さいか存在しない場合を説明します。）したがって、効果的かつ持続的なエンドクライアントキャッシュを想定し、エンティティを取得個々のユーザは、200または203をもたらす正確に一つのGET要求を行います応答、またはエンティティの最初のバイトを含む206応答。プロキシキャッシュを維持し、そのような回収の正確な使用カウントを報告する場合、その報告の使用カウントは密接にエンティティを取得した個別のユーザーの数を概算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are some circumstances under which this approximation can break down. For example, if an entity stays in a proxy cache for much longer than it persists in the typical client cache, and users often re-reference the entity, then this scheme will tend to over-count the number of users. Or, if the cache-management policy implemented in typical client caches is biased against retaining certain kinds of frequently re-referenced entities (such as very large images), the use-counts reported will tend to overestimate the user-counts for such entities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この近似を打破することができ、その下、いくつかの状況があります。実体が長いくらいのプロキシキャッシュに留まる場合例えば、それは典型的なクライアント・キャッシュに固執するよりも、ユーザーが頻繁に再参照エンティティ、その後、この方式は、ユーザーの数をカウント以上になる傾向があります。典型的なクライアントキャッシュに実装されたキャッシュ管理ポリシーが（例えば、非常に大きな画像など）が頻繁に再参照エンティティの特定の種類を保持に対して付勢されている場合や、報告された使用-カウントは、そのようなエンティティのためにユーザー数を過大評価する傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Browser log analysis has shown that when a user revisits a resource, this is almost always done very soon after the previous visit, almost always with fewer than eight intervening references [11]. Although this result might not apply universally, it implies that almost all reuses will hit in the end-client cache, and will not be seen as unconditional GETs by a proxy cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブラウザのログ解析は、ユーザーがリソースを再訪する場合、これはほとんど常に8つの介在参照[11]よりも少ないと、ほとんどの場合、前回の訪問の後すぐに行われていることが示されています。この結果は普遍的に適用されないかもしれませんが、それはほとんどすべての再利用は、エンドクライアントキャッシュにヒットすることを意味し、無条件でプロキシキャッシュによってにつれて見られることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The existing (HTTP/1.0) &#34;cache-busting&#34; mechanisms for counting distinct users will certainly overestimate the number of users behind a proxy, since it provides no reliable way to distinguish between a user&#39;s initial request and subsequent repeat requests that might have been conditional GETs, had not cache-busting been employed. The
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは、ユーザーの最初の要求と条件付きであったかもしれない、後続の再送要求を区別するための信頼できる方法を提供していないので、個別のユーザをカウントするため、既存の（HTTP / 1.0）、「キャッシュの無効化」のメカニズムは、確かに、プロキシの背後にあるユーザーの数を過大評価しますGET、キャッシュの無効化に使用されていませんでした。ザ・
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;Cache-control: s-maxage=0&#34; feature of HTTP/1.1 does allow the separation of use-counts and reuse-counts, provided that no HTTP/1.0 proxy caches intervene.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTPの：「キャッシュ・コントロールS-MAXAGE = 0」の特徴は、/ 1.1が使用-カウントや再利用・カウントの分離を可能にし、何のHTTP / 1.0プロキシキャッシュが介入しないことを条件とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that if there is doubt about the validity of the results of hit-metering a given set of resources, the server can employ cache-busting techniques for short periods, to establish a baseline for validating the hit-metering results. Various approaches to this problem are discussed in a paper by James Pitkow [9].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リソースのヒット計量与えられた一連の結果の妥当性については疑問がある場合、サーバはヒット計量結果を検証するためのベースラインを確立するために、短期間のキャッシュ無効化の手法を採用することができることに注意してください。この問題に対する様々なアプローチがジェームズPitkow [9]の論文に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2 What about &#34;Network Computers&#34;?
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2「ネットワークコンピュータ」はどう？
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The analysis in section 4.1 assumed that &#34;almost all Web users&#34; have client caches. If the Network Computers (NC) model becomes popular, however, then this assumption may be faulty: most proposed NCs have no disk storage, and relatively little RAM. Many Personal Digital Assistants (PDAs), which sometimes have network access, have similar constraints. Such client systems may do little or no caching of HTTP responses. This means that a single user might well generate many unconditional GETs that yield the same response from a proxy cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.1節での分析では、「ほとんどすべてのWebユーザーは、」クライアントのキャッシュを持っていると仮定しました。ネットワークコンピュータ（NC）モデルが人気になった場合、しかし、その後、この仮定に問題がある可能性があります。ほとんどの提案のNCは何のディスク・ストレージ、および比較的少ないRAMを持っていません。時々、ネットワークアクセスを持っている多くの携帯情報端末（PDA）は、同様の制約があります。このようなクライアントシステムは、HTTP応答のほとんど、あるいはまったくキャッシングを行うことができます。これは、単一のユーザーは、多くの無条件降伏それにプロキシキャッシュから同じ応答を取得し生成する可能性があることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First note that the hit-metering design in this document, even with such clients, provides an approximation no worse than available with unmodified HTTP/1.1: the counts that a proxy would return to an origin server would represent exactly the number of requests that the proxy would forward to the server, if the server simply specifies &#34;Cache-control: s-maxage=0&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
でも、そのようなクライアントとの最初のノートこのドキュメントのヒット計量デザインそれは、非修飾HTTP / 1.1で利用できるよりも悪くない近似値を提供します。プロキシがオリジンサーバに戻ってくる数はリクエストの正確数を表すことになりサーバは単に「：= 0 S-MAXAGEのCache-Control」をを指定している場合、プロキシは、サーバーに転送します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, it may be possible to improve the accuracy of these hit-counts by use of some heuristics at the proxy. For example, the proxy might note the IP address of the client, and count only one GET per client address per response. This is not perfect: for example, it fails to distinguish between NCs and certain other kinds of hosts. The proxy might also use the heuristic that only those clients that never send a conditional GET should be treated this way, although we are not at all certain that NCs will never send conditional GETs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、プロキシでいくつかの経験則を使用することにより、これらのヒットカウントの精度を向上させることができます。たとえば、プロキシはクライアントのIPアドレスをメモして、応答あたりのクライアントアドレスごとに1つだけGETをカウントする可能性があります。これは完璧ではない：例えば、それはのNCとホストの特定の他の種類を区別するために失敗しました。プロキシはまた、我々は、すべてのNC取得​​条件を送信することはありませんと確信はありませんが、条件付きGETを送信しないクライアントだけが、このように扱われるべきであるヒューリスティックを使用する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the solution to this problem appears to require heuristics based on the actual behavior of NCs (or perhaps a new HTTP protocol feature that allows unambiguous detection of cacheless clients), it appears to be premature to specify a solution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この問題を解決するには、NCの実際の動作に基づいてヒューリスティック（あるいはキャッシュレスクライアントの明確な検出を可能にする新しいHTTPプロトコル機能）を必要とするように見えるので、解決策を指定するのは時期尚早であるように思われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3 Critical-path delay analysis
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3クリティカル・パスの遅延解析
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In systems (such as the Web) where latency is at issue, there is usually a tree of steps which depend on one another, in such a way that the final result cannot be accomplished until all of its predecessors have been. Since the tree structure admits some parallelism, it is not necessary to add up the timings for each step to discover the latency for the entire process. But any single path through this dependency tree cannot be parallelized, and the longest such path is the one whose length (in units of seconds) determines the overall latency. This is the &#34;critical path&#34;, because no matter how much shorter one makes any other path, that cannot change the overall latency for the final result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
待ち時間が問題である（例えばウェブのような）システムでは、前任者のすべてがされるまで、最終的な結果を達成することができないように、相互に依存する手順のツリーが通常存在します。ツリー構造は、いくつかの並列性を認めているので、全体のプロセスのための待ち時間を発見するために、各ステップのタイミングを追加する必要はありません。この依存関係ツリーを介して、任意の単一のパスが並列化することができず、最長のそのような経路は、その長さ（秒単位で）全体的な待ち時間を決定するものです。どんなにはるかに短い1は、最終的な結果のための全体的な待ち時間を変更することはできません、他のパスを、作るので、これは、「クリティカル・パス」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If one views the final result, for a Web request, as rendering a page at a browser, or otherwise acting on the result of a request, clearly some network round trips (e.g., exchanging TCP SYN packets if the connection doesn&#39;t already exist) are on the critical path. This hit-metering design does add some round-trips for reporting non-zero counts when a cache entry is removed, but, by design, these are off any critical path: they may be done in parallel with any other operation, and require only &#34;best efforts&#34;, so a proxy does not have to serialize other operations with their success or failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1は、ブラウザでページをレンダリングする、またはその他の要求の結果に作用するよう、Web要求のために、最終的な結果を表示する場合、接続が存在しない場合は、明らかにいくつかのネットワーク・ラウンドトリップ（例えば、TCP SYNパケットを交換します）クリティカルパス上にあります。このヒット計量設計は、キャッシュエントリが削除されたときに非ゼロカウントを報告するためのいくつかのラウンドトリップを追加しない、しかし、設計によって、これらは、いずれのクリティカルパスオフになっている：彼らは他の操作と並行して行うことができる、とだけ必要「最善の努力」、そのプロキシがその成否に他の操作をシリアル化する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clearly, anything that changes network utilization (either increasing or decreasing it) can indirectly affect user-perceived latency. Our expectation is that hit-metering, on average, will reduce loading and so even its indirect effects should not add network round-trips in any critical path. But there might be a few specific instances where the added non-critical-path operations (specifically, usage reports upon cache-entry removal) delay an operation on a critical path. This is an unavoidable problem in datagram networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
明らかに、ネットワーク使用率を変更するものは、（増加またはそれは減少のいずれか）、間接的にユーザ知覚の待ち時間に影響を与えることができます。私たちの期待はそのヒット計量で、平均して、負荷を軽減し、そうであってもその間接的な影響は、いずれのクリティカルパスでのネットワーク・ラウンドトリップを追加しないでください。しかし、追加非クリティカル・パスの操作は（具体的には、キャッシュ・エントリの削除時に使用状況レポート）がクリティカルパス上の操作を遅らせるいくつかの特定のインスタンスがあるかもしれません。これは、データグラムネットワークで避けられない問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5 Specification
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5仕様
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 Specification of Meter header and directives
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
メーターヘッダ及び指令の5.1仕様
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Meter general-header field is used to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーター一般的なヘッダフィールドをするために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Negotiate the use of hit-metering and usage-limiting among origin servers and proxy caches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - オリジンサーバとプロキシのキャッシュの中でヒット計量と使用制限の使用を交渉します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Report use counts and reuse counts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - レポートの使用回数と再利用カウント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementation of the Meter header is optional for both proxies and origin servers. However, any proxy that transmits the Meter header in a request MUST implement every requirement of this specification, without exception or amendment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーターヘッダーの実装は、プロキシとオリジンサーバの両方のためのオプションです。しかし、要求にメーターヘッダを送信する任意のプロキシは、例外又は修正することなく、本明細書のすべての要件を実装しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Meter header MUST always be protected by a Connection header. A proxy that does not implement the Meter header MUST NOT pass it through to another system (see section 5.5 for how a non-caching proxy may comply with this specification). If a Meter header is received in a message whose version is less than HTTP/1.1, it MUST be ignored (because it has clearly flowed through a proxy that does not implement Meter).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーターヘッダは常に接続ヘッダによって保護されなければなりません。メーターヘッダを実装していないプロキシは、他のシステム（非キャッシュプロキシは、この仕様に準拠することができる方法についてはセクション5.5を参照）にそれを通過してはいけません。メーターヘッダは、そのバージョンHTTP / 1.1未満であるメッセージで受信された場合（それが明確器を実装していないプロキシを介して流入したため）、それは無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy that has received a response with a version less than HTTP/1.1, and therefore from a server (or another proxy) that does not implement the Meter header, SHOULD NOT send Meter request directives to that server, because these would simply waste bandwidth. This recommendation does not apply if the proxy is currently hit-metering or usage-limiting any responses from that server. If the proxy receives a HTTP/1.1 or higher response from such a server, it should cease its suppression of the Meter directives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらは、単に廃棄帯域幅になるので、そのサーバにメーター要求指令を送るべきではありません、メーターヘッダを実装していない、したがってサーバ（または別のプロキシ）からHTTP / 1.1未満のバージョンで応答を受信したプロキシ、及び。プロキシが現在または使用を制限する、そのサーバーからの応答に計量をヒットされている場合は、この勧告は適用されません。プロキシは、サーバからのHTTP / 1.1以上応答を受信した場合、それはメーターディレクティブのその抑制を中止すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All proxies sending the Meter header MUST adhere to the &#34;metering subtree&#34; design described in section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーターヘッダを送信するすべてのプロキシは、セクション3で説明した「計量サブツリー」設計に準拠しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Meter = &#34;Meter&#34; &#34;:&#34; 0#meter-directive
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーター=「メーター」「：」0＃メートルディレクティブ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
meter-directive = meter-request-directive | meter-response-directive | meter-report-directive
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メートルの指令=メートル要求ディレクティブ|メートル応答ディレクティブ|メートルレポートディレクティブ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
meter-request-directive = &#34;will-report-and-limit&#34; | &#34;wont-report&#34; | &#34;wont-limit&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メートルの要求指令=「意志-レポートと制限」| 「文句を言わない - 報告書」| 「文句を言わないリミット」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
meter-report-directive = | &#34;count&#34; &#34;=&#34; 1*DIGIT &#34;/&#34; 1*DIGIT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メートルレポートディレクティブ= | &#34;カウント&#34; &#34;=&#34; 1 * DIGIT &#34;/&#34; 1 * DIGIT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
meter-response-directive = &#34;max-uses&#34; &#34;=&#34; 1*DIGIT | &#34;max-reuses&#34; &#34;=&#34; 1*DIGIT | &#34;do-report&#34; | &#34;dont-report&#34; | &#34;timeout&#34; &#34;=&#34; 1*DIGIT | &#34;wont-ask&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
= &#34;MAX-用途&#34; &#34;=&#34; 1 * DIGITメートル応答ディレクティブ| &#34;MAX-再利用&#34; &#34;=&#34; 1 * DIGIT | 「やる・レポート」| 「ドント・レポート」| &#34;タイムアウト&#34; &#34;=&#34; 1 * DIGIT | 「文句を言わない、頼みます」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A meter-request-directive or meter-report-directive may only appear in an HTTP request message. A meter-response-directive may only appear in an HTTP response directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メートルリクエストディレクティブまたはメートルレポートディレクティブのみHTTPリクエストメッセージに表示されることがあります。メートル応答ディレクティブは、HTTPレスポンスディレクティブに表示される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An empty Meter header in a request means &#34;Meter: will-report-and-limit&#34;. An empty Meter header in a response, or any other response including one or more Meter headers without the &#34;dont-report&#34; or &#34;wont-ask&#34; directive, implies &#34;Meter: do-report&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求に空メーターヘッダは「メーター：意志・レポート・アンド・リミット」を意味します。応答に空メーターヘッダ、または「ドント・レポート」や「文句を言わない、頼む」ディレクティブなしの一つ以上のメーターヘッダを含む任意の他の応答、「メーター：DO-レポート」を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The meaning of the meter-request-directives are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のようメートル要求ディレクティブの意味は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
will-report-and-limit indicates that the proxy is willing and able to return usage reports and will obey any usage-limits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
意志-レポートおよび制限プロキシが使用状況レポートを返すようにし、任意の利用制限に従います意思と能力であることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
wont-report indicates that the proxy will obey usage-limits but will not send usage reports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文句を言わない - 報告書は、プロキシが利用制限に従いますが、使用状況レポートを送信しないことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
wont-limit indicates that the proxy will not obey usage-limits but will send usage reports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文句を言わない制限は、プロキシが利用制限に従わないであろうが、使用状況レポートを送信することを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy willing neither to obey usage-limits nor to send usage reports MUST NOT transmit a Meter header in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
利用制限に従うためにも使用状況レポートを送信するためにどちら喜んプロキシはリクエストにメーターヘッダを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The meaning of the meter-report-directives are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のようメートルレポートディレクティブの意味は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
count &#34;=&#34; 1*DIGIT &#34;/&#34; 1*DIGIT Both digit strings encode decimal integers. The first integer indicates the count of uses of the cache entry since the last report; the second integer indicates the count of reuses of the entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どちらの数字列は小数点整数を符号化する &#34;=&#34; 1 * DIGIT &#34;/&#34; 1 * DIGIT数えます。最初の整数は前回の報告以降、キャッシュエントリの用途の数を示します。 2番目の整数は、エントリの再利用の数を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 5.3 specifies the counting rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.3節では、カウントルールを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The meaning of the meter-response-directives are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のようメートル応答ディレクティブの意味は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
max-uses &#34;=&#34; 1*DIGIT sets an upper limit on the number of &#34;uses&#34; of the response, not counting its immediate forwarding to the requesting end-client, for all proxies in the following subtree taken together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAX-用途「=」1 * DIGITは一緒になって、次のサブツリー内のすべてのプロキシに、要求元のエンドクライアントへの即時転送を数えていない、レスポンスの「用途」の数の上限を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
max-reuses &#34;=&#34; 1*DIGIT sets an upper limit on the number of &#34;reuses&#34; of the response for all proxies in the following subtree taken together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAX-再利用は、「=」1 * DIGITは、一緒になって、以下のサブツリー内のすべてのプロキシに対する応答の「再利用」の数に上限を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
do-report specifies that the proxy MUST send usage reports to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
やる-報告書は、プロキシがサーバに使用状況レポートを送信する必要があることを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
dont-report specifies that the proxy SHOULD NOT send usage reports to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドント・レポートは、プロキシがサーバに利用状況レポートを送信しないように指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
timeout &#34;=&#34; 1*DIGIT sets a metering timeout of the specified number of minutes (not seconds) after the origination of this response (as indicated by its &#34;Date&#34; header). If the proxy has a non-zero hit count for this response when the timeout expires, it MUST send a report to the server at or before that time. Timeouts should be implemented with an accuracy of plus or minus one minute. Implies &#34;do-report&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムアウト「=」1 * DIGITは、この応答の発信分後の指定された数（ない秒）（その「日」ヘッダによって示される）の計量タイムアウトを設定します。タイムアウトが満了したときにプロキシがこの応答のための非ゼロのヒット数を持っている場合、それはその時に以前のサーバーにレポートを送らなければなりません。タイムアウトは、プラスの精度でまたは1分減じたものに実装する必要があります。 「やる・レポート」を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
wont-ask specifies that the proxy SHOULD NOT send any Meter headers to the server. The proxy should forget this advice after a period of no more than 24 hours.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシがサーバーに任意のメーターヘッダを送信しないように指定し文句を言わない、尋ねます。プロキシは、せいぜい24時間後に、このアドバイスを忘れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 5.3 specifies the counting rules, and in particular specifies a somewhat non-obvious interpretation of the max-uses value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.3節では、カウントルールを指定し、具体的にはMAX-用途値の多少の非自明な解釈を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 Abbreviations for Meter directives
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
メーターディレクティブの5.2略語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To allow for the most efficient possible encoding of Meter headers, we define abbreviated forms of all Meter directives. These are exactly semantically equivalent to their non-abbreviated counterparts. All systems implementing the Meter header MUST implement both the abbreviated and non-abbreviated forms. Implementations SHOULD use the abbreviated forms in normal use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーターヘッダの最も効率的な可能性のエンコーディングを可能にするために、我々はすべてのメーター指示の省略形式を定義します。これらは、非省略対応に正確に意味的に等価です。メーターヘッダを実装するすべてのシステムは略すおよび非省略形の両方を実装しなければなりません。実装は、通常の使用では省略形を使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The abbreviated forms of Meter directive are shown below, with the corresponding non-abbreviated literals in the comments:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メーター指示の省略形は、コメントに対応する非略記リテラルと、以下に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abb-Meter = &#34;Meter&#34; &#34;:&#34; 0#abb-meter-directive
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図メーター=「M」「」0＃図メートルディレクティブ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
abb-meter-directive = abb-meter-request-directive | abb-meter-response-directive | abb-meter-report-directive
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ABBメートルの指令= ABBメートルの要求ディレクティブ| ABBメートル応答ディレクティブ| ABBメートルレポートディレクティブ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
abb-meter-request-directive = &#34;w&#34; ; &#34;will-report-and-limit&#34; | &#34;x&#34; ; &#34;wont-report&#34; | &#34;y&#34; ; &#34;wont-limit&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ABBメートルの要求指令=「W」。 「-報告します-と制限」| &#34;バツ&#34; ; 「文句を言わない - 報告書」| &#34;Y&#34;; 「文句を言わないリミット」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
abb-meter-report-directive = | &#34;c&#34; &#34;=&#34; 1*DIGIT &#34;/&#34; 1*DIGIT ; &#34;count&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ABBメートルレポートディレクティブ= | &#34;C&#34; &#34;=&#34; 1 * DIGIT &#34;/&#34; 1 * DIGIT。 &#34;カウント&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
abb-meter-response-directive = &#34;u&#34; &#34;=&#34; 1*DIGIT ; &#34;max-uses&#34; | &#34;r&#34; &#34;=&#34; 1*DIGIT ; &#34;max-reuses&#34; | &#34;d&#34; ; &#34;do-report&#34; | &#34;e&#34; ; &#34;dont-report&#34; | &#34;t&#34; &#34;=&#34; 1*DIGIT ; &#34;timeout&#34; | &#34;n&#34; ; &#34;wont-ask&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ABBメートル応答指令=「U」「=」1 * DIGIT。 &#34;MAX-用途&#34; | &#34;R&#34; &#34;=&#34; 1 * DIGIT。 &#34;MAX-再利用&#34; | &#34;D&#34;; 「やる・レポート」| 「E」。 「ドント・レポート」| &#34;T&#34; &#34;=&#34; 1 * DIGIT。 「タイムアウト」| 「n」は、 「文句を言わない、頼みます」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: although the Abb-Meter BNF rule is defined separately from the Meter rule, one may freely mix abbreviated and non-abbreviated Meter directives in the same header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：アッベメーターBNF規則は、メータールールとは別に定義されているが、一方が自由に同じヘッダに略記非略記メーターディレクティブを混合することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3 Counting rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3カウントルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Note: please remember that hit-counts and usage-counts are
      associated with individual responses, not with resources.  A cache
      entry that, over its lifetime, holds more than one response is
      also not a &#34;response&#34;, in this particular sense.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Let R be a cached response, and V be the value of the Request-URI and selecting request-headers (if any, see section 14.43 of the HTTP/1.1 specification [4]) that would select R if contained in a request. We define a &#34;use&#34; of R as occurring when the proxy returns its stored copy of R in a response with any of the following status codes: a 200 (OK) status; a 203 (Non-Authoritative Information) status; or a 206 (Partial Content) status when the response contains byte #0 of the entity (see section 5.4 for a discussion of Range requests).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要求に含まれている場合はRを選択する（もしあれば、HTTP / 1.1仕様書[4]のセクション14.43を参照のこと）Rは、キャッシュされた応答であるとすると、Vは、Request-URIおよび選択要求ヘッダの値です。我々は、プロキシは、次のステータスコードのいずれかと反応してRのその格納されたコピーを返す場合に発生するようにRの「使用」を定義：200（OK）ステータス。 203（非信頼できる情報）の状態。または応答は、エンティティのバイト＃0が含まれている206（部分コンテンツ）の状態は（範囲要求の議論のためのセクション5.4を参照します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: when a proxy forwards a client&#39;s request and receives a response, the response that the proxy sends immediately to the requesting client is not counted as a &#34;use&#34;. I.e., the reported count is the number of times the cache entry was used, and not the number of times that the response was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：プロキシが、クライアントの要求を転送し、応答を受信したときに、プロキシが要求しているクライアントに即座に送信する応答は、「使用」としてカウントされません。すなわち、報告されたカウントは、キャッシュエントリが使用された回数ではなく、応答が使用された回数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We define a &#34;reuse&#34; of R as as occurring when the proxy responds to a request selecting R with a 304 (Not Modified) status, unless that request is a Range request that does not specify byte #0 of the entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その要求は、エンティティのバイト＃0を指定していない範囲の要求でない限り、私たちは、プロキシが（変更不可）304とRを選択する要求に応答するときに発生するとして、ステータスをRの「再利用」を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1 Counting rules for hit-metering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ヒット計量用5.3.1カウントルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy participating in hit-metering for a cache response R maintains two counters, CU and CR, associated with R. When a proxy first stores R in its cache, it sets both CU and CR to 0 (zero). When a subsequent client request results in a &#34;use&#34; of R, the proxy increments CU. When a subsequent client request results in a &#34;reuse&#34; of R, the proxy increments CR. When a subsequent client request selecting R (i.e., including V) includes a &#34;count&#34; Meter directive, the proxy increments CU and CR using the corresponding values in the directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシ最初の記憶は、そのキャッシュ中のRと、キャッシュレスポンスRのヒット計量に参加プロキシはR.に関連する2つのカウンタ、CU及びCRを維持し、それはCUとCRの両方が0（ゼロ）に設定します。 Rの「使用」の場合、その後のクライアント要求の結果、プロキシは、CUをインクリメントします。 Rの「リユース」の場合、後続のクライアント要求の結果、プロキシは、CRをインクリメントします。 Rを選択し、その後のクライアント要求が（すなわち、Vを含む）メータ指示を「カウント」を含む場合、プロキシは、指令に対応する値を用いてCU及びCRをインクリメントします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the proxy sends a request selecting R (i.e., including V) to the inbound server, it includes a &#34;count&#34; Meter directive with the current CU and CR as the parameter values. If this request was caused by the proxy&#39;s receipt of a request from a client, upon receipt of the server&#39;s response, the proxy sets CU and CR to the number of uses and reuses, respectively, that may have occurred while the request was in progress. (These numbers are likely, but not certain, to be zero.) If the proxy&#39;s request was a final HEAD-based report, it need no longer maintain the CU and CR values, but it may also set them to the number of intervening uses and reuses and retain them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシはインバウンドサーバにR（すなわち、Vなど）を選択する要求を送信すると、パラメータ値として現在のCUとCRとのメーター指示を「カウント」を含みます。この要求は、サーバーの応答を受信すると、クライアントからの要求のプロキシの受信によって引き起こされた場合、プロキシはリクエストの進行中に発生した可能性があり、それぞれの用途や再利用、数にCUとCRを設定します。 （これらの数値はゼロであることが、特定の可能性が高いが、そうではありません。）プロキシの要求は、それはもはや、CUおよびCR値を維持する必要はない最終HEADベースのレポートだったが、それはまた、介在使用回数にそれらを設定している場合そして再利用し、それらを保持しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2 Counting rules for usage-limiting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2カウントルールの使用制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy participating in usage-limiting for a response R maintains either or both of two counters TU and TR, as appropriate, for that resource. TU and TR are incremented in just the same way as CU and CR, respectively. However, TU is zeroed only upon receipt of a &#34;max-uses&#34; Meter directive for that response (including the initial receipt). Similarly, TR is zeroed only upon receipt of a &#34;max-reuses&#34; Meter directive for that response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rは、そのリソースのため、いずれかの維持又は二カウンタTU及びTRの両方、などの適切な応答を利用制限に参加代理。 TU及びTRは、それぞれ、CuおよびCrなどちょうど同じようにインクリメントされます。しかし、TUだけ（初期領収書を含む）は、その応答のための「MAX-用途」メーターの指示を受信したときにゼロになります。同様に、TRは、それだけで応答のための「MAX-再利用」メーターの指示を受信したときにゼロになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy participating in usage-limiting for a response R also stores values MU and/or MR associated with R. When it receives a response including only a max-uses value, it sets MU to that value and MR to infinity. When it receives a response including only a max-reuses value, it sets MR to that value and MU to infinity. When it receives a response including both max-reuses and max-reuses values, it sets MU and MR to those values, respectively. When it receives a subsequent response including neither max-reuses nor max-reuses values, it sets both MU and MR to infinity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
利用制限にも対応Rために店舗に参加プロキシは、それが唯一の値をmaxは、使用を含む応答を受信するとMU及び/又はMRはR.関連付けられた値は、無限にその値およびMRへのMUを設定します。それが唯一のmax-再利用値を含む応答を受信すると、それは無限大にその値とMUにMRを設定します。それはMAX-再利用し、値maxは、再利用の両方を含む応答を受信すると、それは、それぞれ、これらの値にMUとMRを設定します。それはMAX-再利用もMAX-再利用する価値もないなど、その後の応答を受信すると、それは無限にMUとMRの両方を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a proxy participating in usage-limiting for a response R receives a request that would cause a &#34;use&#34; of R, and TU &gt;= MU, it MUST forward the request to the server. If it receives a request that would cause a &#34;reuse&#34; of R, and TR &gt;= MR, it MUST forward the request to the server. If (in either case) the proxy has already forwarded a previous request to the server and is waiting for the response, it should delay further handling of the new request until the response arrives (or times out); it SHOULD NOT have two revalidation requests pending at once that select the same response, unless these are Range requests selecting different subranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参加代理応答のために使用が制限場合RはRの「使用」を引き起こす要求を受信し、TUは&gt; = MUは、それがサーバーに要求を転送しなければなりません。それはRの「リユース」を引き起こす要求を受信し、TR&gt; = MR場合は、サーバーに要求を転送しなければなりません。 （いずれの場合も）プロキシがすでにサーバーに以前の要求を転送したし、応答を待っている場合、応答が（またはタイムアウトに）到着するまで、それは新しい要求のさらなる処理を遅らせる必要があります。これらは異なるサブレンジを選択する範囲要求されない限り、同じ応答を選択し、一度に保留中2つの再検証要求を持つべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is a special case of this rule for the &#34;max-uses&#34; directive: if the proxy receives a response with &#34;max-uses=0&#34; and does not forward it to a requesting client, the proxy should set a flag PF associated with R. If R is true, then when a request arrives while if TU &gt;= MU, if the PF flag is set, then the request need not be forwarded to the server (provided that this is not required by other caching rules). However, the PF flag MUST be cleared on any use of the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「MAX-用途」ディレクティブは、この規則の特別なケースがあります：プロキシは、「MAX-用途= 0」との応答を受信し、要求元のクライアントに転送しない場合は、プロキシが関連付けられたフラグPFを設定する必要がありますPFフラグが設定されている場合、TUは&gt; = MUが、その要求をサーバに転送する必要がない場合（これは、他のキャッシュ・ルールによって必要とされないことを条件とする）しながら、要求が到着したときR.場合Rは、その後、真です。しかし、PFフラグは、応答のいずれかの使用をきれいにしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: the &#34;PF&#34; flag is so named because this feature is useful only for caches that could issue a &#34;prefetch&#34; request before an actual client request for the response. A proxy not implementing prefetching need not implement the PF flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：この機能は唯一の応答のための実際のクライアント要求の前に「プリフェッチ」要求を発行することができ、キャッシュのために有用であるため、「PF」フラグは、そのように命名されます。プリフェッチを実装していないプロキシは、PFフラグを実装する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.3 Equivalent algorithms are allowed
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.3等価アルゴリズムが許可されています
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any other algorithm that exhibits the same external behavior (i.e., generates exactly the same requests from the proxy to the server) as the one in this section is explicitly allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクション内の1つを明示的に許可されるのと同じ外部動作（すなわち、プロキシからサーバへ正確に同じ要求を生成する）を示す任意の他のアルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: in most cases, TU will be equal to CU, and TR will be equal to CR. The only two cases where they could differ are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：ほとんどの場合、TUは、CUに等しくなり、そしてTRはCRに等しくなります。彼らは異なる可能性がある唯一の2例は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. The proxy issues a non-conditional request for the resource using V, while TU and/or TR are non-zero, and the server&#39;s response includes a new &#34;max-uses&#34; and/or &#34;max-reuses&#34; directive (thus zeroing TU and/or TR, but not CU and CR).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TUおよび/またはTRが非ゼロであり、かつサーバの応答は、このように（新しい「MAX-用途」および/または「MAX-再利用」ディレクティブを含み、一方1.プロキシは、Vを使用して、リソースの非条件付きリクエストを発行しますゼロ化TU及び/又はTRはなく、CU及びCR）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. The proxy issues a conditional request reporting the hit-counts (and thus zeroing CU and CR, but not TU or TR), but the server&#39;s response does not include a new &#34;max-uses&#34; and/or &#34;max-reuses&#34; directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.プロキシは、ヒット数を報告し、条件付きリクエストを発行する（したがって、CUとCRをゼロではなく、TUまたはTR）が、サーバーの応答は新しい「MAX-用途」および/または「MAX-再利用」が含まれていません。指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To solve the first case, the proxy has several implementation options
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のケースを解決するために、プロキシは、いくつかの実装オプションを持っています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Always store TU and TR separately from CU and CR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 常にCU及びCR別にTUとTRを格納します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Create &#34;shadow&#34; copies of TU and TR when this situation arises (analogous to &#34;copy on write&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - このような状況が発生した場合（「コピーオンライト」に類似）TUとTRの「影」のコピーを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Generate a HEAD-based usage report when the non-conditional request is sent (or when the &#34;max-uses=0&#34; is received), causing CU and CR to be zeroed (analogous in some ways to a &#34;memory barrier&#34; instruction).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 「メモリバリア」命令にいくつかの点で類似した（CU及びCRはゼロにさせる、非条件付きの要求が送信される（または「MAX-使用= 0」を受信したとき）、ヘッドベース使用状況レポートを生成します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the second case, the server implicitly has removed the usage-limit(s) on the response (by setting MU and/or MR to infinity), and so the fact that, say, TU is different from CU is not significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第二のケースでは、サーバは、暗黙的に（無限にMU及び/又はMRを設定することによって）応答に対する利用制限（単数または複数）を除去しており、いわば、TUは、Cuとは異なる、という事実は重要ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: It may also be possible to eliminate the PF flag by sending extra HEAD-based usage-report requests, but we recommend against this; it is better to allocate an extra bit per entry than to transmit extra requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、余分なHEADベースの利用レポート要求を送信することにより、PFフラグを排除することが可能かもしれないが、我々はこれに反対をお勧めします。注：余分な要求を送信するよりも、エントリごとの余分なビットを割り当てることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4 Counting rules: interaction with Range requests
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4カウントルール：範囲要求との相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.1 allows a client to request sub-ranges of a resource. A client might end up issuing several requests with the net effect of receiving one copy of the resource. For uniformity of the results seen by origin servers, proxies need to observe a rule for counting these references, although it is not clear that one rule generates accurate results in every case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.1は、クライアントがリソースのサブ範囲を要求することができます。クライアントはリソースのコピーを受け取るの正味の効果を持ついくつかの要求を発行することに終わるかもしれません。一つのルールはすべてのケースで正確な結果を生成することは明らかではないがオリジンサーバによって見られた結果の均一性のために、プロキシは、これらの参照をカウントするためのルールを遵守する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The rule established in this specification is that proxies count as a &#34;use&#34; or &#34;reuse&#34; only those Range requests that result in the return of byte #0 of the resource. The rationale for this rule is that in almost every case, an end-client will retrieve the beginning of any resource that it references at all, and that it will seldom retrieve any portion more than once. Therefore, this rule appears to meet the goal of a &#34;best-efforts&#34; approximation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様に設立されたルールは、プロキシは、「使用」としてカウントまたはリソースのバイト＃0のリターンにつながるのみ範囲要求を「再利用」ということです。このルールの理論的根拠は、ほとんどの場合には、エンドクライアントは、それがすべてで参照するすべてのリソースの先頭を取得し、それはめったに回以上の任意の部分を取得していないということだろうということです。したがって、このルールは、「最高の努力」近似の目標を達成するために表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5 Implementation by non-caching proxies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
非キャッシュプロキシ5.5実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A non-caching proxy may participate in the metering subtree; this is strongly recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非キャッシュプロキシは、計量サブツリーに参加することができます。これを強くお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A non-caching proxy (HTTP/1.1 or higher) that participates in the metering subtree SHOULD forward Meter headers on both requests and responses, with the appropriate Connection headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
計量サブツリーに関与する非キャッシュプロキシ（HTTP / 1.1以上）は、適切な接続ヘッダーと、要求と応答の両方にメーターヘッダを転送すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a non-caching proxy forwards Meter headers, it MUST comply with these restrictions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非キャッシュプロキシはメーターヘッダを転送する場合は、これらの制限を遵守しなければなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. If the proxy forwards Meter headers in responses, such a response MUST NOT be returned to any request except the one that elicited it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.プロキシが応答でメーターヘッダを転送する場合は、そのような応答は、それを誘発したもの以外のすべての要求に戻ってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Once a non-caching proxy starts forwarding Meter headers, it should not arbitrarily stop forwarding them (or else reports may be lost).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.非キャッシュプロキシはメーターヘッダの転送を開始したら、それは任意にそれらの転送を停止べきではない（または他のレポートは失われる可能性があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proxy that caches some responses and not others, for whatever reason, may choose to implement the Meter header as a caching proxy for the responses that it caches, and as a non-caching proxy for the responses that it does not cache, as long as its external behavior with respect to any particularly response is fully consistent with this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、何らかの理由で、いくつかの回答ではなく他人をキャッシュプロキシは限り、それはキャッシュすること応答のキャッシュプロキシとして、それがキャッシュしないことを応答の非キャッシュプロキシとしてメーターヘッダーを実装することもできます任意特に応答に対するその外部動作として本明細書に完全に一致しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6 Implementation by cooperating caches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
キャッシュを連携することにより、5.6実装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Several HTTP cache implementations, most notably the Harvest/Squid cache [2], create cooperative arrangements between several caches. If such caches use a protocol other than HTTP to communicate between themselves, such as the Internet Cache Protocol (ICP) [12], and if they implement the Meter header, then they MUST act to ensure that their cooperation does not violate the intention of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのHTTPキャッシュの実装は、最も顕著な収穫/イカキャッシュは、[2]、いくつかのキャッシュ間の協力体制を作成します。このようなキャッシュは、インターネットキャッシュプロトコル（ICP）[12]のように、それらの間の通信にHTTP以外のプロトコルを使用している場合、彼らはメーターヘッダを実装する場合、そして、彼らは彼らの協力がの意図に違反しないことを確実にするために行動しなければなりませんこの仕様。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In particular, if one member of a group of cooperating caches agrees with a server to hit-meter a particular response, and then passes this response via a non-HTTP protocol to a second cache in the group, the caches MUST ensure that the server which requested the metering receives reports that appropriately account for any uses or resues made by the second cache. Similarly, if the first cache agreed to usage-limit the response, the total number of uses by the group of caches MUST be limited to the agreed-upon number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
協働キャッシュのグループの1人のメンバーが特定の応答をメートルをヒットするサーバと一致し、そのグループ内の第二のキャッシュに非HTTPプロトコルを介して、この応答を渡す場合、特に、キャッシュはそのサーバを確実にしなければなりませんその計量が適切にセカンドキャッシュによって行われた任意の用途やresuesを占めて報告を受けるよう要請しました。最初のキャッシュが利用制限応答に同意した場合、同様に、キャッシュのグループによる使用の総数は、合意された数に制限されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6 Examples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 Example of a complete set of exchanges
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
交換の完全なセットの6.1例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This example shows how the protocol is intended to be used most of the time: for hit-metering without usage-limiting. Entity bodies are omitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
利用制限せずにヒット計量用：この例では、プロトコルは、ほとんどの時間を使用することを意図している方法を示しています。エンティティボディは省略されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client sends request to a proxy:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントはプロキシにリクエストを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET http://foo.com/bar.html HTTP/1.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET http://foo.com/bar.html HTTP / 1.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The proxy forwards request to the origin server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシ転送は、オリジンサーバに要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       GET /bar.html HTTP/1.1
       Host: foo.com
       Connection: Meter
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
thus offering (implicitly) &#34;will-report-and-limit&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これ提供する（暗黙的に）「-報告します-と制限」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server responds to the proxy:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、プロキシに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 200 OK
       Date: Fri, 06 Dec 1996 18:44:29 GMT
       Cache-control: max-age=3600
       Connection: meter
       Etag: &#34;abcde&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
thus (implicitly) requiring &#34;do-report&#34; (but not requiring usage-limiting).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これ（暗黙的に）「やる-報告書」を必要とする（ただし、使用制限を必要としません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The proxy responds to the client:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシはクライアントに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 200 OK
       Date: Fri, 06 Dec 1996 18:44:29 GMT
       Etag: &#34;abcde&#34;
       Cache-control: max-age=3600, proxy-mustcheck
       Age: 1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the proxy does not know if its client is an end-system, or a proxy that doesn&#39;t do metering, it adds the &#34;proxy-mustcheck&#34; directive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのクライアントはエンドシステム、または計量をしないプロキシであればプロキシがわからないので、それは「プロキシmustcheck」ディレクティブを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another client soon asks for the resource:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別のクライアントがすぐにリソースを要求します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET http://foo.com/bar.html HTTP/1.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET http://foo.com/bar.html HTTP / 1.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
and the proxy sends the same response as it sent to the other client, except (perhaps) for the Age value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは年齢値のために（おそらく）を除いて、他のクライアントに送信されたとして、およびプロキシは同じ応答を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After an hour has passed, a third client asks for the response:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時間が経過した後、第三のクライアントは、応答を要求します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET http://foo.com/bar.html HTTP/1.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET http://foo.com/bar.html HTTP / 1.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
But now the response&#39;s max-age has been exceeded, so the proxy revalidates the response with the origin server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、今の応答の最大エージングを超えているので、プロキシはオリジンサーバとの応答を再検証します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       GET /bar.html HTTP/1.1
       If-None-Match: &#34;abcde&#34;
       Host: foo.com
       Connection: Meter
       Meter: count=1/0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
thus simultaneously fulfilling its duties to validate the response and to report the one &#34;use&#34; that wasn&#39;t forwarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これと同時に応答を検証し、転送されなかった一つの「使用」を報告してその職務を果たします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The origin server responds:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジンサーバが応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 304 Not Modified
       Date: Fri, 06 Dec 1996 19:44:29 GMT
       Cache-control: max-age=3600
       Etag: &#34;abcde&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
so the proxy can use the original response to reply to the new client; the proxy also zeros the use-count it associates with that response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのプロキシは、新しいクライアントに返信する元の応答を使用することができます。プロキシは、それがその応答に関連付け使用カウントをゼロに。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another client soon asks for the resource:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別のクライアントがすぐにリソースを要求します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET http://foo.com/bar.html HTTP/1.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GET http://foo.com/bar.html HTTP / 1.1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
and the proxy sends the appropriate response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そして、プロキシが適切な応答を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After another few hours, the proxy decides to remove the cache entry. When it does so, it sends to the origin server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別の数時間後に、プロキシはキャッシュエントリを削除することを決定しました。それはそうと、それはオリジンサーバに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HEAD /bar.html HTTP/1.1
       If-None-Match: &#34;abcde&#34;
       Host: foo.com
       Connection: Meter
       Meter: count=1/0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
reporting that one more use of the response was satisfied from the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答の1回の以上の使用がキャッシュから満たされたことを報告。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 Protecting against HTTP/1.0 proxies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 HTTP / 1.0のプロキシからの保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An origin server that does not want HTTP/1.0 caches to store the response at all, and is willing to have HTTP/1.0 end-system clients generate excess GETs (which will be forwarded by HTTP/1.0 proxies) could send this for its reply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.0キャッシュはまったく応答を格納したい、としないオリジンサーバは持って喜んでHTTP / 1.0エンドシステムのクライアントは、過剰は（HTTP / 1.0プロキシによって転送される）その応答のためにこれを送ることができGETを生成します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 200 OK
       Cache-control: max-age=3600
       Connection: meter
       Etag: &#34;abcde&#34;
       Expires: Sun, 06 Nov 1994 08:49:37 GMT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP/1.0 caches will see the ancient Expires header, but HTTP/1.1 caches will see the max-age directive and will ignore Expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HTTP / 1.0キャッシュは、古代にはExpiresヘッダを見ますが、HTTPう/ 1.1キャッシュは、max-ageディレクティブが表示され、有効期限を無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: although most major HTTP/1.0 proxy implementations observe the Expires header, it is possible that some are in use that do not. Use of the Expires header to prevent caching by HTTP/1.0 proxies might not be entirely reliable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：ほとんどの主要なHTTP / 1.0プロキシの実装では、Expiresヘッダを観察するが、一部にはない使用されている可能性があります。使用は、HTTPによるキャッシングを防ぐためにExpiresヘッダ/ 1.0プロキシが完全に信頼できない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 More elaborate examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3より複雑な例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here is a request from a proxy that is willing to hit-meter but is not willing to usage-limit:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでヒットメートルをしていく所存ですが、利用限度に望んでいないプロキシからの要求は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       GET /bar.html HTTP/1.1
       Host: foo.com
       Connection: Meter
       Meter: wont-limit
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here is a response from an origin server that does not want hit counting, but does want &#34;uses&#34; limited to 3, and &#34;reuses&#34; limited to 6:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
：ここでは、カウントを打つ必要はありませんが、3に制限「を使用しています」、および6に限ら「再利用」したいんオリジンサーバからの応答があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 200 OK
       Cache-control: max-age=3600
       Connection: meter
       Etag: &#34;abcde&#34;
       Expires: Sun, 06 Nov 1994 08:49:37 GMT
       Meter: max-uses=3, max-reuses=6, dont-report
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here is the same example with abbreviated Meter directive names:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでは省略メーターディレクティブの名前と同じ例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HTTP/1.1 200 OK
       Cache-control: max-age=3600
       Connection: meter
       Etag: &#34;abcde&#34;
       Expires: Sun, 06 Nov 1994 08:49:37 GMT
       Meter:u=3,r=6,e
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
7 Interactions with content negotiation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテンツネゴシエーションと7つの相互作用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes two aspects of the interaction between hit-metering and &#34;content-negotiated&#34; resources:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、ヒット計量および「コンテンツネゴシエーション」のリソース間の相互作用の2つの側面について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. treatment of responses carrying a Vary header (section 7.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヴァリヘッダを運ぶ応答の1治療（セクション7.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. treatment of responses that use the proposed Transparent Content Negotiation mechanism (section 7.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
提案された透過的内容ネゴシエーションメカニズム（セクション7.2）を使用して応答の2治療。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1 Treatment of responses carrying a Vary header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
ヴァリヘッダを運ぶ応答7.1治療
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Separate counts should be kept for each combination of the headers named in the Vary header for the Request-URI (what [4] calls &#34;the selecting request-headers&#34;), even if they map to the same entity-tag. This rule has the effect of counting hits on each variant, if there are multiple variants of a page available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別個のカウントは、それらが同じエンティティタグにマッピングしても、リクエストURI（[4]「選択リクエストヘッダ」と呼ぶもの）に対して変化ヘッダで指定されたヘッダーの組み合わせ毎に保たれるべきです。使用可能なページの複数の亜種が存在する場合、このルールは、各バリアントにヒットをカウントする効果があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: This interaction between Vary and the hit-counting directives allows the origin server a lot of flexibility in specifying how hits should be counted. In essence, the origin server uses the Vary mechanism to divide the requests for a resource into arbitrary categories, based on the request- headers. (We will call these categories &#34;request-patterns&#34;.) Since a proxy keeps its hit-counts for each request-pattern, rather than for each resource, the origin server can obtain separate statistics for many aspects of an HTTP request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：間のこの相互作用が異なり、ヒットカウントディレクティブは、ヒットをカウントする方法を指定するにはオリジンサーバに多くの柔軟性を可能にします。本質的に、オリジンサーバは、ザが要求 - ヘッダに基づいて、任意のカテゴリにリソースの要求を分割するための機構を変え使用します。 （私たちは、「リクエスト・パターン」、これらのカテゴリを呼び出します。）プロキシが、むしろ各リソースのよりも、各要求パターンのためにそのヒットカウントを維持しているため、オリジンサーバがHTTPリクエストの多くの側面に別々の統計情報を取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, if a page varied based on the value of the User-Agent header in the requests, then hit counts would be kept for each different flavor of browser. But it is in fact more general than that; because multiple header combinations can map to the same variant, it also enables the origin server to count the number of times (e.g.) the Swahili version of a page was requested, even though it is only available in English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
たとえば、リクエストのUser-Agentヘッダの値に基づいて変化ページならば、カウントは、ブラウザのそれぞれ異なる味のために維持されるだろうヒット。しかし、それは実際にはそれよりも一般的です。複数のヘッダの組み合わせが同じバリアントにマップすることができますので、それはまた、英語でのみ提供されていても、ページのスワヒリ語バージョンが要求された（例えば）の回数をカウントするためにオリジンサーバを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a proxy does not support the Vary mechanism, then [4] says that it MUST NOT cache any response that carries a Vary header, and hence need not implement any aspect of this hit-counting or usage-limiting design for varying resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシが変動メカニズムをサポートしていない場合は、[4]、それはヘッダを異なるため、その資源を変化させるため、このヒットカウントまたは利用制限デザインのあらゆる側面を実装する必要はありません搬送する任意の応答をキャッシュしてはならないと述べています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Note: this also implies that if a proxy supports the Vary
       mechanism but is not willing to maintain independent hit-counts
       for each variant response in its cache, then it must follow at
       least one of these rules:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. It must not use the Meter header in a request to offer to hit-meter or usage-limit responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.これは、ヒットメートルまたは利用制限応答するために提供することを要求してメーターヘッダーを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. If it does offer to hit-meter or usage-limit responses, and then receives a response that includes both a Vary header and a Meter header with a directive that it cannot satisfy, then the proxy must not cache the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.それは、または利用制限応答メートルを打つために提供し、その後、その後、プロキシが応答をキャッシュしてはならない、それは満たすことができないというディレクティブでヘッダとメーターVaryヘッダの両方を含む応答を受信しなければ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In other words, a proxy is allowed to partially implement the Vary mechanism with respect to hit-metering, as long as this has no externally visible effect on its ability to comply with the Meter specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
言い換えれば、プロキシがあれば、これはメーターの仕様に準拠する能力には、外部から目に見える効果を有するように、部分的にヒット計量しに対して変化機構を実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This approach works for counting almost any aspect of the request stream, without embedding any specific list of countable aspects in the specification or proxy implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このアプローチは、仕様またはプロキシ実装で可算の態様のいずれかの特定のリストを埋め込むことなく、要求ストリームのほぼすべての側面をカウントするために働きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2 Interaction with Transparent Content Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
透明なコンテンツネゴシエーションと7.2の相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[A description of the interaction between this design and the proposed Transparent Content Negotiation (TCN) design [6] will be made available in a later document.]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【この設計提案透明コンテンツネゴシエーション（TCN）設計との間の相互作用の記述は、[6]、後で文書で利用可能となります。]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
8 A Note on Capturing Referrals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャプチャ紹介で8注意事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is alleged that some advertisers want to pay content providers, not by the &#34;hit&#34;, but by the &#34;nibble&#34; -- the number of people who actually click on the ad to get more information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実際にはより多くの情報を取得するために、広告をクリックした人の数 - しかし、「ニブル」によって、一部の広告主がいない「ヒット」により、コンテンツプロバイダを支払うことをしたいと主張しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Now, HTTP already has a mechanism for doing this: the &#34;Referer&#34; header. However, perhaps it ought to be disabled for privacy reasons -- according the HTTP/1.1 spec:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「リファラー」ヘッダー：今、HTTPはすでにこれを行うための機構を備えています。しかし、おそらくそれは、プライバシー上の理由で無効にされるべきである -  HTTP / 1.1仕様によると：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       &#34;Because the source of the link may be private information or may
       reveal an otherwise private information source, it is strongly
       recommended that the user be able to select whether or not the
       Referer field is sent.&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, in the case of ads, the source of the link actually wants to let the referred-to page know where the reference came from.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、広告の場合は、リンクのソースは、実際に参照がどこから来たのか言及-にページを知らせたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This does not require the addition of any extra mechanism, but rather can use schemes that embed the referrer in the URI in a manner similar to this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、余分なメカニズムを追加する必要はありませんが、むしろこれと同様にURIでリファラを埋め込む手法を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
http://www.blah.com/ad-reference?from=site1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ｈっｔｐ：／／ｗっｗ。ｂぁｈ。こｍ／あｄーれふぇれんせ？ｆろｍ＝して１
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Such a URI should point to a resource (perhaps a CGI script) which returns a 302 redirect to the real page
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
URI 302を返すリソース（おそらくCGIスクリプト）を指している必要があり、このような実ページにリダイレクト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
http://www.blah.com/ad-reference.html
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ｈっｔｐ：／／ｗっｗ。ｂぁｈ。こｍ／あｄーれふぇれんせ。ｈｔｍｌ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Proxies which do not cache 302s will cause one hit on the redirection page per use, but the real page will get cached. Proxies which do cache 302s and report hits on the cached 302s will behave optimally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
302Sをキャッシュしないプロキシは、使用ごとにリダイレクトページに1件のヒットが発生しますが、実際のページがキャッシュされます。キャッシュされた302S上のキャッシュ302Sを行い、報告書がヒットプロキシが最適に動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This approach has the advantage that it works whether or not the end-client has disabled the use of Referer. Combined with the rest of the hit-metering proposal in this design, this approach allows, for example, an advertiser to know how often a reference to an advertisement was made from a particular page.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このアプローチは、それがエンドクライアントは、リファラーの使用を無効にしているか否かの作品という利点があります。この設計でヒット計量提案の残りの部分と合わせて、このアプローチは、例えば、広告主は、広告への参照は、特定のページから作られた頻度を知ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
9 Alternative proposals
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
9つの代替案
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There might be a number of other ways of gathering demographic and usage information; other mechanisms might respond to a different set of needs than this proposal does. This proposal certainly does not preclude the proposal or deployment of other such mechanisms, and many of them may be complementary to and compatible with the mechanism proposed here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
人口統計と使用情報を収集する他のいくつかの方法があるかもしれません。他のメカニズムは、この提案が行うよりも、ニーズの異なるセットに反応する可能性があります。この提案は、確かに他のそのようなメカニズムの提案や導入を妨げるものではない、それらの多くは、ここで提案されたメカニズムを持つと相補的と互換性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There has been some speculation that statistical sampling methods might be used to gather reasonably accurate data. One such proposal is to manipulate cache expiration times so that selected resources are uncachable for carefully chosen periods, allowing servers to accurately count accesses during those periods. The hit-metering mechanism proposed here is entirely complementary to that approach, since it could be used to reduce the cost of gathering those counts. James Pitkow has written a paper comparing an earlier draft of this hit-metering proposal with sampling approaches [9].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
統計的サンプリング法が合理的に正確なデータを収集するために使用されるかもしれないことをいくつかの憶測がなされてきました。そのような提案は、選択したリソースは、慎重に選ばれた期間のキャッシュ不可能になるように、それらの期間中にアクセスするサーバが正確にカウントすることができ、キャッシュの有効期限の時間を操作することです。これらのカウントを集めるのコストを削減するために使用する可能性があるので、ここで提案したヒット計量機構は、そのアプローチに完全に相補的です。ジェームズPitkowは、サンプリング手法[9]このヒット計量提案の以前の草案を比較した紙を書いています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phillip Hallam-Baker has proposed using a log-exchange protocol [5], by which a server could request a proxy&#39;s logs by making an HTTP request to the proxy. This proposal asserts that it is &#34;believed to operate correctly in configurations involving multiple proxies&#34;, but it is not clear that this is true if an outer proxy is used as a (one-way) firewall. The proposal also leaves a number of open issues, such as how an origin server can be sure that all of the proxies in the request subtree actually support log-exchange. It is also not clear how this proposal couples a proxy&#39;s support of log-exchange to a server&#39;s permission to cache a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバがプロキシにHTTP要求を行うことで、プロキシのログを要求する可能性があることでフィリップ・ハーラム・ベイカーは、[5]ログ交換プロトコルを使用して提案しています。この提案は、それが「複数のプロキシを含む構成で正常に動作すると思われる」と主張するが、外側のプロキシは（片道）ファイアウォールとして使用されている場合、これが真実であることは明らかではありません。提案はまた、オリジンサーバがリクエストサブツリーのプロキシのすべてが実際にログ交換をサポートすることを確認することができますどのようなオープンな問題の数を残します。この提案のカップルサーバーの許可にログ交換のプロキシのサポートが応答をキャッシュする方法も明確ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For general background on the topic of Web measurement standards, see the discussion by Thomas P. Novak and Donna L. Hoffman [8]. Also see the &#34;Privacy and Demographics Overview&#34; page maintained by by the World Wide Web Consortium [10], which includes a pointer to some tentative proposals for gathering consumer demographics (not just counting references) [3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウェブ測定基準のトピックに関する一般的な背景については、トーマスP.ノバックとドナ・L.ホフマン[8]によって議論を参照してください。また、消費者の人口統計を収集するためのいくつかの暫定的な提案へのポインタ（だけでなく、カウント参照）が含まれるワールド・ワイド・ウェブ・コンソーシアム[10]、によってによって維持「プライバシーおよび人口統計概要」ページを参照してください[3]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
10 Security Considerations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
10のセキュリティの考慮事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Which outbound clients should a server (proxy or origin) trust to report hit counts? A malicious proxy could easily report a large number of hits on some page, and thus perhaps cause a large payment to a content provider from an advertiser. To help avoid this possibility, a proxy may choose to only relay usage counts received from its outbound proxies to its inbound servers when the proxies have authenticated themselves using Proxy-Authorization and/or they are on a list of approved proxies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、アウトバウンドのクライアントはヒット数を報告するサーバー（プロキシまたは原点）信頼すべき？悪質なプロキシは、簡単にいくつかのページ上のヒットの数が多いを報告し、したがって、おそらく、広告主からコンテンツプロバイダに大きな支払いを引き起こす可能性があります。この可能性を避けるために、プロキシはプロキシ認証を使用して自分自身を認証したときにプロキシはそのインバウンドサーバへのアウトバウンドプロキシから受信した使用カウントを中継することを選択でき、および/またはそれらが承認されたプロキシのリストに載っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is not possible to enforce usage limits if a proxy is willing to cheat (i.e., it offers to limit usage but then ignores a server&#39;s Meter directive).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシが（すなわち、それは使用を制限するために提供していますが、その後、サーバーのメーターの指示を無視）カンニングして喜んでいる場合には、使用制限を強制することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Regarding privacy: it appears that the design in this document does not reveal any more information about individual users than would already be revealed by implementation of the existing HTTP/1.1 support for &#34;Cache-control: max-age=0, proxy-revalidate&#34; or &#34;Cache-control: s-maxage=0&#34;. It may, in fact, help to conceal certain aspects of the organizational structure on the outbound side of a proxy. In any case, the conflict between user requirements for anonymity and origin server requirements for demographic information cannot be resolved by purely technical means.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プライバシーについて：「：最大エージング= 0、プロキシ再検証のCache-Control」この文書のデザインはすでに用の既存のHTTP / 1.1のサポートの実装によって明らかにされるよりも、個々のユーザーについてのより多くの情報を明らかにしないことが表示されますまたは &#34;キャッシュ・コントロール：S-MAXAGE = 0&#34;。それは、実際には、プロキシの発信側にある組織構造の特定の側面を隠すために役立つかもしれません。いずれにせよ、人口統計学的情報のための匿名性とオリジンサーバの要件については、ユーザの要求間の競合は、純粋に技術的手段によって解決することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
11 Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
11の謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We gratefully acknowledge the constructive comments received from Anselm Baird-Smith, Ted Hardie, Koen Holtman (who suggested the technique described in section 8), Dave Kristol, Ari Luotonen, Patrick R. McManus, Ingrid Melve, and James Pitkow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
我々は感謝しアンセルムベアード・スミス、テッドハーディー、（セクション8に記載された技術を提案し）公園Holtman、デイブ・クリストル、アリ・ルオトナン、パトリック・R.マクマナス、イングリッドMelve、そしてジェームズPitkowから受信した建設的なコメントを認めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
12 References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
12の参考文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Anwat Chankhunthod, Peter B. Danzig, Chuck Neerdaels, Michael F. Schwartz, and Kurt J. Worrell. A Hierarchical Internet Object Cache. Proc. 1996 USENIX Technical Conf., San Diego, January, 1996, pp. 153-163.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Anwat Chankhunthod、ピーターB.ダンツィヒ、チャックNeerdaels、マイケルF.シュワルツ、およびクルトJ. Worrellの。階層的なインターネットオブジェクト・キャッシュ。 PROC。 1996 USENIX技術コンファレンス。、サンディエゴ、1996年1月、頁153-163。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Daniel W. Connolly. Proposals for Gathering Consumer Demographics. http://www.w3.org/pub/WWW/Demographics/Proposals.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.ダニエル・W・コノリー。収集消費者人口統計の提案。 http://www.w3.org/pub/WWW/Demographics/Proposals.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Fielding, R., Gettys, J., Mogul, J., Nielsen, H. and T. Berners-Lee, &#34;Hypertext Transfer Protocol -- HTTP/1.1,&#34; RFC 2068, January, 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.フィールディング、R.、ゲティス、J.、モーグル、J.、ニールセン、H.、およびT.バーナーズ - リー、 &#34;ハイパーテキスト転送プロトコル -  HTTP / 1.1&#34;、RFC 2068、1997年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. Phillip M. Hallam-Baker. Notification for Proxy Caches. W3C Working Draft WD-proxy-960221, World Wide Web Consortium, February, 1996. http://www.w3.org/pub/WWW/TR/WD-proxy.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.フィリップM.ハラム - ベイカー。プロキシキャッシュの通知。 WD-プロキシ-960221 W3Cワーキングドラフト、ワールドワイドウェブコンソーシアム、2月、1996年http://www.w3.org/pub/WWW/TR/WD-proxy.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. Holtman, K., and A. Mutz, &#34;Transparent Content Negotiation in HTTP&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. Holtman、K.、およびA. MUTZ、 &#34;HTTPで透明なコンテンツネゴシエーション&#34;、進行中の作業します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
7. Mogul, J., &#34;Forcing HTTP/1.1 proxies to revalidate responses&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7.ムガール人、J.、進行中で働いて「応答を再検証するためにHTTP / 1.1プロキシを強制」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
8. Thomas P. Novak and Donna L. Hoffman. New Metrics for New Media: Toward the Development of Web Measurement Standards. This is a draft paper, currently available at http:// www2000.ogsm.vanderbilt.edu/novak/web.standards/webstand.html. Cited by permission of the author; do not quote or cite without permission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
8.トーマスP.ノバックとドナL.ホフマン。ニューメディアのための新しい指標：ウェブ計量標準の開発に向けて。 // www2000.ogsm.vanderbilt.edu/novak/web.standards/webstand.html：これは、httpで現在利用可能なドラフト紙、です。著者の許可を得て引用しました。引用や許可なしに引用しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
9. James Pitkow. In search of reliable usage data on the WWW. Proc. Sixth International World Wide Web Conference, Santa Clara, CA, April, 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
9.ジェームズPitkow。 WWW上の信頼性の使用データの検索で。 PROC。第6回国際ワールドワイドウェブ会議、カリフォルニア州サンタクララ、1997年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
10. Joseph Reagle, Rohit Khare, Dan Connolly, and Tim Berners-Lee. Privacy and Demographics Overview. http://www.w3.org/pub/WWW/Demographics/.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
10.ジョセフReagle、ロフィット・クヘア、ダン・コノリー、とティム・バーナーズ=リー。プライバシーと人口統計の概要。 http://www.w3.org/pub/WWW/Demographics/。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
11. Linda Tauscher and Saul Greenberg. Revisitation Patterns in World Wide Web Navigation. Research Report 96/587/07, Department of Computer Science, University of Calgary, March, 1996. http://www.cpsc.ucalgary.ca/projects/grouplab/ papers/96WebReuse/TechReport96.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
11.リンダTauscherサウルグリーンバーグ。ワールド・ワイド・ウェブナビゲーションで再閲覧パターン。研究報告96/587/07、コンピュータサイエンス、カルガリー大学の学部3月、1996年http://www.cpsc.ucalgary.ca/projects/grouplab/ペーパー/ 96WebReuse / TechReport96.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
12. Wessels, D., and K. Claffy &#34;Internet Cache Protocol (ICP), version 2&#34;, RFC 2186, September 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
12.ウェッセル、D.、およびK. Claffy &#34;インターネットキャッシュプロトコル（ICP）、バージョン2&#34;、RFC 2186、1997年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
13 Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
13本の著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jeffrey C. Mogul Western Research Laboratory Digital Equipment Corporation 250 University Avenue Palo Alto, California, 94305, U.S.A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジェフリーC.モーグル西研究所ディジタル・イクイップメント・コーポレーション250大学アベニューパロアルト、カリフォルニア、94305、U.S.A.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: mogul@wrl.dec.com Phone: 1 415 617 3304 (email preferred)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：mogul@wrl.dec.com電話：1 415 617 3304（電子メール優先）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Paul J. Leach Microsoft 1 Microsoft Way Redmond, Washington, 98052, U.S.A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポール・J.リーチマイクロソフト1マイクロソフト道、レッドモンド、ワシントン、98052、U.S.A.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: paulle@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：paulle@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
14 Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
14完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (1997). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（1997）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implmentation may be prepared, copied, published andand distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピー、公表andand配布することができることを説明したり、そのimplmentationを支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
