<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 6940 - REsource LOcation And Discovery (RELOAD) Base Protocol 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6940</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <button type="button" class="btn btn-light btn-sm">
      <a href="https://tools.ietf.org/html/rfc6940">Orig</a>
    </button>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6940 - REsource LOcation And Discovery (RELOAD) Base Protocol 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc6940">
              https://tools.ietf.org/html/rfc6940
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6940 - リソースの場所と発見（RELOAD）基本プロトコル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                       C. Jennings
Request for Comments: 6940                                         Cisco
Category: Standards Track                               B. Lowekamp, Ed.
ISSN: 2070-1721                                                    Skype
                                                             E. Rescorla
                                                              RTFM, Inc.
                                                                S. Baset
                                                          H. Schulzrinne
                                                     Columbia University
                                                            January 2014
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         REsource LOcation And Discovery (RELOAD) Base Protocol
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines REsource LOcation And Discovery (RELOAD), a peer-to-peer (P2P) signaling protocol for use on the Internet. A P2P signaling protocol provides its clients with an abstract storage and messaging service between a set of cooperating peers that form the overlay network. RELOAD is designed to support a P2P Session Initiation Protocol (P2PSIP) network, but can be utilized by other applications with similar requirements by defining new usages that specify the Kinds of data that need to be stored for a particular application. RELOAD defines a security model based on a certificate enrollment service that provides unique identities. NAT traversal is a fundamental service of the protocol. RELOAD also allows access from &#34;client&#34; nodes that do not need to route traffic or store data for others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、リソースロケーションとディスカバリー（リロード）、ピア・ツー・ピア（P2P）は、インターネット上で使用するためのシグナリングプロトコルを定義します。 P2Pシグナリングプロトコルは、オーバーレイネットワークを形成ピア協働のセットとの間の抽象ストレージとメッセージングサービスを顧客に提供します。リロードがP2Pセッション開始プロトコル（P2PSIP）ネットワークをサポートするように設計されているが、特定の用途のために保存する必要があるデータの種類を指定する新たな用途を定義することによって、同様の要件を持つ他のアプリケーションで利用することができます。 RELOADは、ユニークなIDを提供し、証明書の登録サービスに基づいたセキュリティモデルを定義します。 NATトラバーサルは、プロトコルの基本的なサービスです。 RELOADまた、トラフィックのルーティングや他人のためにデータを格納する必要はありません「クライアント」のノードからのアクセスを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6940.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6940で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   7
     1.1.  Basic Setting . . . . . . . . . . . . . . . . . . . . . .   8
     1.2.  Architecture  . . . . . . . . . . . . . . . . . . . . . .  10
       1.2.1.  Usage Layer . . . . . . . . . . . . . . . . . . . . .  13
       1.2.2.  Message Transport . . . . . . . . . . . . . . . . . .  13
       1.2.3.  Storage . . . . . . . . . . . . . . . . . . . . . . .  14
       1.2.4.  Topology Plug-in  . . . . . . . . . . . . . . . . . .  15
       1.2.5.  Forwarding and Link Management Layer  . . . . . . . .  16
     1.3.  Security  . . . . . . . . . . . . . . . . . . . . . . . .  16
     1.4.  Structure of This Document  . . . . . . . . . . . . . . .  17
   2.  Requirements Language . . . . . . . . . . . . . . . . . . . .  18
   3.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  18
   4.  Overlay Management Overview . . . . . . . . . . . . . . . . .  21
     4.1.  Security and Identification . . . . . . . . . . . . . . .  21
       4.1.1.  Shared-Key Security . . . . . . . . . . . . . . . . .  23
     4.2.  Clients . . . . . . . . . . . . . . . . . . . . . . . . .  23
       4.2.1.  Client Routing  . . . . . . . . . . . . . . . . . . .  24
       4.2.2.  Minimum Functionality Requirements for Clients  . . .  25
     4.3.  Routing . . . . . . . . . . . . . . . . . . . . . . . . .  25
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     4.4.  Connectivity Management . . . . . . . . . . . . . . . . .  29
     4.5.  Overlay Algorithm Support . . . . . . . . . . . . . . . .  30
       4.5.1.  Support for Pluggable Overlay Algorithms  . . . . . .  30
       4.5.2.  Joining, Leaving, and Maintenance Overview  . . . . .  30
     4.6.  First-Time Setup  . . . . . . . . . . . . . . . . . . . .  32
       4.6.1.  Initial Configuration . . . . . . . . . . . . . . . .  32
       4.6.2.  Enrollment  . . . . . . . . . . . . . . . . . . . . .  32
       4.6.3.  Diagnostics . . . . . . . . . . . . . . . . . . . . .  33
   5.  Application Support Overview  . . . . . . . . . . . . . . . .  33
     5.1.  Data Storage  . . . . . . . . . . . . . . . . . . . . . .  33
       5.1.1.  Storage Permissions . . . . . . . . . . . . . . . . .  34
       5.1.2.  Replication . . . . . . . . . . . . . . . . . . . . .  35
     5.2.  Usages  . . . . . . . . . . . . . . . . . . . . . . . . .  36
     5.3.  Service Discovery . . . . . . . . . . . . . . . . . . . .  36
     5.4.  Application Connectivity  . . . . . . . . . . . . . . . .  36
   6.  Overlay Management Protocol . . . . . . . . . . . . . . . . .  37
     6.1.  Message Receipt and Forwarding  . . . . . . . . . . . . .  37
       6.1.1.  Responsible ID  . . . . . . . . . . . . . . . . . . .  38
       6.1.2.  Other ID  . . . . . . . . . . . . . . . . . . . . . .  38
       6.1.3.  Opaque ID . . . . . . . . . . . . . . . . . . . . . .  40
     6.2.  Symmetric Recursive Routing . . . . . . . . . . . . . . .  41
       6.2.1.  Request Origination . . . . . . . . . . . . . . . . .  41
       6.2.2.  Response Origination  . . . . . . . . . . . . . . . .  42
     6.3.  Message Structure . . . . . . . . . . . . . . . . . . . .  42
       6.3.1.  Presentation Language . . . . . . . . . . . . . . . .  43
         6.3.1.1.  Common Definitions  . . . . . . . . . . . . . . .  44
       6.3.2.  Forwarding Header . . . . . . . . . . . . . . . . . .  46
         6.3.2.1.  Processing Configuration Sequence Numbers . . . .  49
         6.3.2.2.  Destination and Via Lists . . . . . . . . . . . .  50
         6.3.2.3.  Forwarding Option . . . . . . . . . . . . . . . .  52
       6.3.3.  Message Contents Format . . . . . . . . . . . . . . .  53
         6.3.3.1.  Response Codes and Response Errors  . . . . . . .  54
       6.3.4.  Security Block  . . . . . . . . . . . . . . . . . . .  57
     6.4.  Overlay Topology  . . . . . . . . . . . . . . . . . . . .  60
       6.4.1.  Topology Plug-in Requirements . . . . . . . . . . . .  60
       6.4.2.  Methods and Types for Use by Topology Plug-ins  . . .  61
         6.4.2.1.  Join  . . . . . . . . . . . . . . . . . . . . . .  61
         6.4.2.2.  Leave . . . . . . . . . . . . . . . . . . . . . .  62
         6.4.2.3.  Update  . . . . . . . . . . . . . . . . . . . . .  63
         6.4.2.4.  RouteQuery  . . . . . . . . . . . . . . . . . . .  63
         6.4.2.5.  Probe . . . . . . . . . . . . . . . . . . . . . .  65
     6.5.  Forwarding and Link Management Layer  . . . . . . . . . .  67
       6.5.1.  Attach  . . . . . . . . . . . . . . . . . . . . . . .  67
         6.5.1.1.  Request Definition  . . . . . . . . . . . . . . .  68
         6.5.1.2.  Response Definition . . . . . . . . . . . . . . .  70
         6.5.1.3.  Using ICE with RELOAD . . . . . . . . . . . . . .  71
         6.5.1.4.  Collecting STUN Servers . . . . . . . . . . . . .  71
         6.5.1.5.  Gathering Candidates  . . . . . . . . . . . . . .  72
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         6.5.1.6.  Prioritizing Candidates . . . . . . . . . . . . .  72
         6.5.1.7.  Encoding the Attach Message . . . . . . . . . . .  73
         6.5.1.8.  Verifying ICE Support . . . . . . . . . . . . . .  74
         6.5.1.9.  Role Determination  . . . . . . . . . . . . . . .  74
         6.5.1.10. Full ICE  . . . . . . . . . . . . . . . . . . . .  74
         6.5.1.11. No-ICE  . . . . . . . . . . . . . . . . . . . . .  75
         6.5.1.12. Subsequent Offers and Answers . . . . . . . . . .  75
         6.5.1.13. Sending Media . . . . . . . . . . . . . . . . . .  75
         6.5.1.14. Receiving Media . . . . . . . . . . . . . . . . .  75
       6.5.2.  AppAttach . . . . . . . . . . . . . . . . . . . . . .  75
         6.5.2.1.  Request Definition  . . . . . . . . . . . . . . .  76
         6.5.2.2.  Response Definition . . . . . . . . . . . . . . .  77
       6.5.3.  Ping  . . . . . . . . . . . . . . . . . . . . . . . .  77
         6.5.3.1.  Request Definition  . . . . . . . . . . . . . . .  77
         6.5.3.2.  Response Definition . . . . . . . . . . . . . . .  77
       6.5.4.  ConfigUpdate  . . . . . . . . . . . . . . . . . . . .  78
         6.5.4.1.  Request Definition  . . . . . . . . . . . . . . .  78
         6.5.4.2.  Response Definition . . . . . . . . . . . . . . .  79
     6.6.  Overlay Link Layer  . . . . . . . . . . . . . . . . . . .  80
       6.6.1.  Future Overlay Link Protocols . . . . . . . . . . . .  81
         6.6.1.1.  HIP . . . . . . . . . . . . . . . . . . . . . . .  82
         6.6.1.2.  ICE-TCP . . . . . . . . . . . . . . . . . . . . .  82
         6.6.1.3.  Message-Oriented Transports . . . . . . . . . . .  82
         6.6.1.4.  Tunneled Transports . . . . . . . . . . . . . . .  82
       6.6.2.  Framing Header  . . . . . . . . . . . . . . . . . . .  83
       6.6.3.  Simple Reliability  . . . . . . . . . . . . . . . . .  84
         6.6.3.1.  Stop and Wait Sender Algorithm  . . . . . . . . .  85
       6.6.4.  DTLS/UDP with SR  . . . . . . . . . . . . . . . . . .  86
       6.6.5.  TLS/TCP with FH, No-ICE . . . . . . . . . . . . . . .  86
       6.6.6.  DTLS/UDP with SR, No-ICE  . . . . . . . . . . . . . .  87
     6.7.  Fragmentation and Reassembly  . . . . . . . . . . . . . .  87
   7.  Data Storage Protocol . . . . . . . . . . . . . . . . . . . .  88
     7.1.  Data Signature Computation  . . . . . . . . . . . . . . .  90
     7.2.  Data Models . . . . . . . . . . . . . . . . . . . . . . .  91
       7.2.1.  Single Value  . . . . . . . . . . . . . . . . . . . .  91
       7.2.2.  Array . . . . . . . . . . . . . . . . . . . . . . . .  92
       7.2.3.  Dictionary  . . . . . . . . . . . . . . . . . . . . .  92
     7.3.  Access Control Policies . . . . . . . . . . . . . . . . .  93
       7.3.1.  USER-MATCH  . . . . . . . . . . . . . . . . . . . . .  93
       7.3.2.  NODE-MATCH  . . . . . . . . . . . . . . . . . . . . .  93
       7.3.3.  USER-NODE-MATCH . . . . . . . . . . . . . . . . . . .  93
       7.3.4.  NODE-MULTIPLE . . . . . . . . . . . . . . . . . . . .  94
     7.4.  Data Storage Methods  . . . . . . . . . . . . . . . . . .  94
       7.4.1.  Store . . . . . . . . . . . . . . . . . . . . . . . .  94
         7.4.1.1.  Request Definition  . . . . . . . . . . . . . . .  94
         7.4.1.2.  Response Definition . . . . . . . . . . . . . . . 100
         7.4.1.3.  Removing Values . . . . . . . . . . . . . . . . . 101
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       7.4.2.  Fetch . . . . . . . . . . . . . . . . . . . . . . . . 102
         7.4.2.1.  Request Definition  . . . . . . . . . . . . . . . 102
         7.4.2.2.  Response Definition . . . . . . . . . . . . . . . 104
       7.4.3.  Stat  . . . . . . . . . . . . . . . . . . . . . . . . 105
         7.4.3.1.  Request Definition  . . . . . . . . . . . . . . . 105
         7.4.3.2.  Response Definition . . . . . . . . . . . . . . . 106
       7.4.4.  Find  . . . . . . . . . . . . . . . . . . . . . . . . 107
         7.4.4.1.  Request Definition  . . . . . . . . . . . . . . . 108
         7.4.4.2.  Response Definition . . . . . . . . . . . . . . . 108
       7.4.5.  Defining New Kinds  . . . . . . . . . . . . . . . . . 109
   8.  Certificate Store Usage . . . . . . . . . . . . . . . . . . . 110
   9.  TURN Server Usage . . . . . . . . . . . . . . . . . . . . . . 110
   10. Chord Algorithm . . . . . . . . . . . . . . . . . . . . . . . 112
     10.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . 113
     10.2.  Hash Function  . . . . . . . . . . . . . . . . . . . . . 114
     10.3.  Routing  . . . . . . . . . . . . . . . . . . . . . . . . 114
     10.4.  Redundancy . . . . . . . . . . . . . . . . . . . . . . . 114
     10.5.  Joining  . . . . . . . . . . . . . . . . . . . . . . . . 115
     10.6.  Routing Attaches . . . . . . . . . . . . . . . . . . . . 116
     10.7.  Updates  . . . . . . . . . . . . . . . . . . . . . . . . 117
       10.7.1.  Handling Neighbor Failures . . . . . . . . . . . . . 118
       10.7.2.  Handling Finger Table Entry Failure  . . . . . . . . 119
       10.7.3.  Receiving Updates  . . . . . . . . . . . . . . . . . 119
       10.7.4.  Stabilization  . . . . . . . . . . . . . . . . . . . 120
         10.7.4.1.  Updating the Neighbor Table  . . . . . . . . . . 120
         10.7.4.2.  Refreshing the Finger Table  . . . . . . . . . . 121
         10.7.4.3.  Adjusting Finger Table Size  . . . . . . . . . . 122
         10.7.4.4.  Detecting Partitioning . . . . . . . . . . . . . 122
     10.8.  Route Query  . . . . . . . . . . . . . . . . . . . . . . 123
     10.9.  Leaving  . . . . . . . . . . . . . . . . . . . . . . . . 123
   11. Enrollment and Bootstrap  . . . . . . . . . . . . . . . . . . 124
     11.1.  Overlay Configuration  . . . . . . . . . . . . . . . . . 124
       11.1.1.  RELAX NG Grammar . . . . . . . . . . . . . . . . . . 132
     11.2.  Discovery through Configuration Server . . . . . . . . . 134
     11.3.  Credentials  . . . . . . . . . . . . . . . . . . . . . . 135
       11.3.1.  Self-Generated Credentials . . . . . . . . . . . . . 137
     11.4.  Contacting a Bootstrap Node  . . . . . . . . . . . . . . 138
   12. Message Flow Example  . . . . . . . . . . . . . . . . . . . . 138
   13. Security Considerations . . . . . . . . . . . . . . . . . . . 144
     13.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . 144
     13.2.  Attacks on P2P Overlays  . . . . . . . . . . . . . . . . 145
     13.3.  Certificate-Based Security . . . . . . . . . . . . . . . 145
     13.4.  Shared-Secret Security . . . . . . . . . . . . . . . . . 147
     13.5.  Storage Security . . . . . . . . . . . . . . . . . . . . 147
       13.5.1.  Authorization  . . . . . . . . . . . . . . . . . . . 147
       13.5.2.  Distributed Quota  . . . . . . . . . . . . . . . . . 148
       13.5.3.  Correctness  . . . . . . . . . . . . . . . . . . . . 148
       13.5.4.  Residual Attacks . . . . . . . . . . . . . . . . . . 149
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     13.6.  Routing Security . . . . . . . . . . . . . . . . . . . . 149
       13.6.1.  Background . . . . . . . . . . . . . . . . . . . . . 150
       13.6.2.  Admissions Control . . . . . . . . . . . . . . . . . 150
       13.6.3.  Peer Identification and Authentication . . . . . . . 151
       13.6.4.  Protecting the Signaling . . . . . . . . . . . . . . 151
       13.6.5.  Routing Loops and DoS Attacks  . . . . . . . . . . . 152
       13.6.6.  Residual Attacks . . . . . . . . . . . . . . . . . . 152
   14. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 153
     14.1.  Well-Known URI Registration  . . . . . . . . . . . . . . 153
     14.2.  Port Registrations . . . . . . . . . . . . . . . . . . . 153
     14.3.  Overlay Algorithm Types  . . . . . . . . . . . . . . . . 154
     14.4.  Access Control Policies  . . . . . . . . . . . . . . . . 154
     14.5.  Application-ID . . . . . . . . . . . . . . . . . . . . . 155
     14.6.  Data Kind-ID . . . . . . . . . . . . . . . . . . . . . . 155
     14.7.  Data Model . . . . . . . . . . . . . . . . . . . . . . . 156
     14.8.  Message Codes  . . . . . . . . . . . . . . . . . . . . . 156
     14.9.  Error Codes  . . . . . . . . . . . . . . . . . . . . . . 158
     14.10. Overlay Link Types . . . . . . . . . . . . . . . . . . . 159
     14.11. Overlay Link Protocols . . . . . . . . . . . . . . . . . 159
     14.12. Forwarding Options . . . . . . . . . . . . . . . . . . . 160
     14.13. Probe Information Types  . . . . . . . . . . . . . . . . 160
     14.14. Message Extensions . . . . . . . . . . . . . . . . . . . 161
     14.15. Reload URI Scheme  . . . . . . . . . . . . . . . . . . . 161
       14.15.1.  URI Registration  . . . . . . . . . . . . . . . . . 162
     14.16. Media Type Registration  . . . . . . . . . . . . . . . . 162
     14.17. XML Namespace Registration . . . . . . . . . . . . . . . 163
       14.17.1.  Config URL  . . . . . . . . . . . . . . . . . . . . 164
       14.17.2.  Config Chord URL  . . . . . . . . . . . . . . . . . 164
   15. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . 164
   16. References  . . . . . . . . . . . . . . . . . . . . . . . . . 165
     16.1.  Normative References . . . . . . . . . . . . . . . . . . 165
     16.2.  Informative References . . . . . . . . . . . . . . . . . 167
   Appendix A.  Routing Alternatives . . . . . . . . . . . . . . . . 171
     A.1.  Iterative vs. Recursive . . . . . . . . . . . . . . . . . 171
     A.2.  Symmetric vs. Forward Response  . . . . . . . . . . . . . 171
     A.3.  Direct Response . . . . . . . . . . . . . . . . . . . . . 172
     A.4.  Relay Peers . . . . . . . . . . . . . . . . . . . . . . . 173
     A.5.  Symmetric Route Stability . . . . . . . . . . . . . . . . 173
   Appendix B.  Why Clients? . . . . . . . . . . . . . . . . . . . . 174
     B.1.  Why Not Only Peers? . . . . . . . . . . . . . . . . . . . 174
     B.2.  Clients as Application-Level Agents . . . . . . . . . . . 175
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines REsource LOcation And Discovery (RELOAD), a peer-to-peer (P2P) signaling protocol for use on the Internet. RELOAD provides a generic, self-organizing overlay network service, allowing nodes to route messages to other nodes and to store and retrieve data in the overlay. RELOAD provides several features that are critical for a successful P2P protocol for the Internet:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、リソースロケーションとディスカバリー（リロード）、ピア・ツー・ピア（P2P）は、インターネット上で使用するためのシグナリングプロトコルを定義します。 RELOADは、一般的な、自己組織化オーバレイネットワークサービスを提供して他のノードにメッセージをルーティングノードを可能とオーバーレイ内のデータを格納および取得します。 RELOADは、インターネットのための成功したP2Pプロトコルのための重要ないくつかの機能を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security Framework: A P2P network will often be established among a set of peers that do not trust each other. RELOAD leverages a central enrollment server to provide credentials for each peer, which can then be used to authenticate each operation. This greatly reduces the possible attack surface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティフレームワーク：P2Pネットワークは、多くの場合、お互いを信頼していないピアのセットの中で確立されます。リロードが各操作を認証するために使用することができ、各ピアの資格情報を提供するために、中央登録サーバを活用します。これは非常に可能性攻撃面を減らします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Usage Model: RELOAD is designed to support a variety of applications, including P2P multimedia communications with the Session Initiation Protocol (SIP) [SIP-RELOAD]. RELOAD allows the definition of new application usages, each of which can define its own data types, along with the rules for their use. This allows RELOAD to be used with new applications through a simple documentation process that supplies the details for each application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用モデル：リロードは、セッション開始プロトコル（SIP）[SIPリロード]を有するP2Pマルチメディア通信を含む様々なアプリケーションをサポートするように設計されています。 RELOADは、それらの使用のためのルールと一緒に、独自のデータ型を定義することができますそれぞれの新しいアプリケーション用法、を定義できます。これは、RELOADは、各アプリケーションの詳細を提供する簡単な文書化プロセスを通じて、新たなアプリケーションで使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NAT Traversal: RELOAD is designed to function in environments where many, if not most, of the nodes are behind NATs or firewalls. Operations for NAT traversal are part of the base design, including using Interactive Connectivity Establishment (ICE) [RFC5245] to establish new RELOAD or application protocol connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NATトラバーサル：RELOADは、ノードの多く、そうでない場合は、ほとんどがNATのか、ファイアウォールの背後にある環境で機能するように設計されています。 NATトラバーサルのための操作が新しいリロードまたはアプリケーションプロトコル接続を確立するためにインタラクティブ接続確立（ICE）[RFC5245]を使用することを含む、ベースの設計の一部です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optimized Routing: The very nature of overlay algorithms introduces a requirement that peers participating in the P2P network route requests on behalf of other peers in the network. This introduces a load on those other peers in the form of bandwidth and processing power. RELOAD has been defined with a simple, lightweight forwarding header, thus minimizing the amount of effort for intermediate peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最適化されたルーティング：オーバーレイアルゴリズムの本質は、ネットワーク内の他のピアに代わってP2Pネットワークのルート要求に参加しているピアの要件を紹介します。これは、帯域幅および処理能力の形態のものの他のピアの負荷を導入します。リロードは、このように中間ピアの努力の量を最小限に抑える、簡単、軽量転送ヘッダで定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pluggable Overlay Algorithms: RELOAD has been designed with an abstract interface to the overlay layer to simplify implementing a variety of structured (e.g., distributed hash tables (DHTs)) and unstructured overlay algorithms. The idea here is that RELOAD provides a generic structure that can fit most types of overlay topologies (ring, hyperspace, etc.). To instantiate an actual network, you combine RELOAD with a specific overlay algorithm, which defines how to construct the overlay topology and route messages efficiently within it. This specification also defines how RELOAD is used with the Chord-based [Chord] DHT algorithm, which is mandatory to implement. Specifying a default &#34;mandatory-to-implement&#34; overlay algorithm promotes interoperability, while extensibility allows selection of overlay algorithms optimized for a particular application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プラグ可能なオーバーレイアルゴリズム：リロードが構造化された（例えば、分散ハッシュテーブル（のDHT））および非構造化オーバーレイアルゴリズムの様々な実施簡素化するオーバレイ層に抽象インターフェースで設計されています。ここでの考え方は、RELOADは、オーバーレイ・トポロジー（リング、ハイパースペース、など）のほとんどの種類を収めることができ、一般的な構造を提供することです。実際のネットワークをインスタンス化するには、効率的にその中にオーバーレイ・トポロジーやルート、メッセージを構築する方法を定義し、特定のオーバーレイ・アルゴリズム、とRELOADを兼ね備えています。本明細書はまた、リロードを実装するために必須であるコードベースの[コード] DHTアルゴリズムと一緒に使用される方法を定義します。拡張性は、特定のアプリケーション用に最適化されたオーバーレイアルゴリズムの選択を可能にしながら、デフォルトの「実装に必須の」オーバーレイアルゴリズムを指定すると、相互運用性を促進します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Support for Clients: RELOAD clients differ from RELOAD peers primarily in that they do not store information on behalf of other nodes in the overlay. Rather, they use the overlay only to locate users and resources, as well as to store information and to contact other nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのサポート：RELOADクライアントは主に、彼らは、オーバーレイ内の他のノードに代わって情報を格納しないことにRELOADピアとは異なります。むしろ、彼らは唯一のユーザーとリソースを検索するだけでなく、情報を保存するために、他のノードに連絡するオーバーレイを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These properties were designed specifically to meet the requirements for a P2P protocol to support SIP. This document defines the base protocol for the distributed storage and location service, as well as critical usage for NAT traversal. The SIP Usage itself is described separately in [SIP-RELOAD]. RELOAD is not limited to usage by SIP and could serve as a tool for supporting other P2P applications with similar needs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのプロパティは、SIPをサポートするためのP2Pプロトコルのための要件を満たすために特別に設計されました。この文書は、基本分散ストレージおよび位置サービスのためのプロトコル、ならびにNATトラバーサルのための重要な使用法を定義します。 SIPの使用自体は、[SIPリロード]に別々に記載されています。 RELOADはSIPでの使用に限定されるものではなく、同様のニーズに合わせて他のP2Pアプリケーションをサポートするためのツールとして役立ち得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Basic Setting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 標準設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this section, we provide a brief overview of the operational setting for RELOAD. A RELOAD Overlay Instance consists of a set of nodes arranged in a partly connected graph. Each node in the overlay is assigned a numeric Node-ID for the lifetime of the node, which, together with the specific overlay algorithm in use, determines its position in the graph and the set of nodes it connects to. The Node-ID is also tightly coupled to the certificate (see Section 13.3). The figure below shows a trivial example which isn&#39;t drawn from any particular overlay algorithm, but was chosen for convenience of representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、RELOADのための動作設定の概要を説明します。 RELOADオーバーレイインスタンスは、部分的に接続されたグラフに配置されたノードのセットからなります。オーバーレイ内の各ノードは、一緒になって、使用中の特定のオーバーレイアルゴリズムと、そのグラフ中の位置と、それが接続するノードの集合を決定し、ノードの寿命の数値ノードIDが割り当てられます。ノードIDもしっかり証明書に結合される（セクション13.3を参照）。以下の図は、任意の特定のオーバーレイアルゴリズムから引き出されていない簡単な例を示しているが、表現の便宜のために選択しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +--------+              +--------+              +--------+
      | Node 10|--------------| Node 20|--------------| Node 30|
      +--------+              +--------+              +--------+
          |                       |                       |
          |                       |                       |
      +--------+              +--------+              +--------+
      | Node 40|--------------| Node 50|--------------| Node 60|
      +--------+              +--------+              +--------+
          |                       |                       |
          |                       |                       |
      +--------+              +--------+              +--------+
      | Node 70|--------------| Node 80|--------------| Node 90|
      +--------+              +--------+              +--------+
                                  |
                                  |
                              +--------+
                              | Node 85|
                              |(Client)|
                              +--------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the graph is not fully connected, when a node wants to send a message to another node, it may need to route it through the network. For instance, Node 10 can talk directly to nodes 20 and 40, but not to Node 70. In order to send a message to Node 70, it would first send it to Node 40, with instructions to pass it along to Node 70. Different overlay algorithms will have different connectivity graphs, but the general idea behind all of them is to allow any node in the graph to efficiently reach every other node within a small number of hops.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グラフは、ノードが別のノードにメッセージを送信したいとき、それはネットワークを介してルーティングすることが必要になる場合があり、完全に接続されていないため。それは最初のノードの異なる70に沿って通過させるように指示して、40をノードに送信し、例えば、ノード10は、ノード20及び40に直接話すことができるではなく、70をノードにメッセージを送信するために70のノードにオーバーレイアルゴリズムが異なる接続グラフを持っていますが、それらのすべての背後にある一般的な考え方は、グラフ内の任意のノードを効率的にホップ数の少ない内他のすべてのノードに到達できるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RELOAD network is not only a messaging network. It is also a storage network, albeit one designed for small-scale transient storage rather than for bulk storage of large objects. Records are stored under numeric addresses, called Resource-IDs, which occupy the same space as node identifiers. Peers are responsible for storing the data associated with some set of addresses, as determined by their Node-ID. For instance, we might say that every peer is responsible for storing any data value which has an address less than or equal to its own Node-ID, but greater than the next lowest Node-ID. Thus, Node 20 would be responsible for storing values 11-20.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADネットワークだけでなく、メッセージングネットワークです。これは、小規模な一過性記憶のためにではなく、大きなオブジェクトのバルク・ストレージ用に設計された1つあるが、また、ストレージネットワークです。レコードは、数値アドレスの下に格納され、ノード識別子と同じスペースを占有リソース-IDは、と呼ばれます。そのノードIDによって決定されたピアは、アドレスの一部のセットに関連するデータを格納するための責任があります。例えば、我々は、すべてのピアが未満か、自身のノードIDと同じアドレスを持つ任意のデータ値を格納するための責任が、次に低いノードIDよりも大きいことを言うかもしれません。したがって、ノード20は、値11-20を格納するための責任を負うことになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD also supports clients. These are nodes which have Node-IDs but do not participate in routing or storage. For instance, in the figure above, Node 85 is a client. It can route to the rest of the RELOAD network via Node 80, but no other node will route through it, and Node 90 is still responsible for addresses in the range [81..90]. We refer to non-client nodes as peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADもクライアントをサポートします。これらは、ノードIDを持っていますが、ルーティングやストレージに参加しないノードです。例えば、上の図では、ノード85は、クライアントです。これはノード80を介してリロードネットワークの残りの部分へのルートができ、それを介して他のノードをルーティング、およびノー​​ド90は依然として範囲[81..90]のアドレスの原因です。私たちは、ピアとして非クライアント・ノードを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other applications (for instance, SIP) can be defined on top of RELOAD and can use these two basic RELOAD services to provide their own services.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（例えば、SIPのための）他のアプリケーションは、RELOADの上に定義することができ、独自のサービスを提供するために、これらの二つの基本的なRELOADサービスを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Architecture
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. 建築
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD is fundamentally an overlay network. The following figure shows the layered RELOAD architecture.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADは、基本的にオーバーレイネットワークです。次の図は、層状リロードアーキテクチャを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Application
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
応用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        +-------+  +-------+
        | SIP   |  | XMPP  |  ...
        | Usage |  | Usage |
        +-------+  +-------+
    ------------------------------------ Messaging Service Boundary
    +------------------+     +---------+
    |     Message      |&lt;---&gt;| Storage |
    |    Transport     |     +---------+
    +------------------+           ^
           ^       ^               |
           |       v               v
           |     +-------------------+
           |     |    Topology       |
           |     |    Plug-in        |
           |     +-------------------+
           |         ^
           v         v
        +------------------+
        |  Forwarding &amp;    |
        | Link Management  |
        +------------------+
    ------------------------------------ Overlay Link Service Boundary
         +-------+  +-------+
         |TLS    |  |DTLS   |  ...
         |Overlay|  |Overlay|
         |Link   |  |Link   |
         +-------+  +-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The major components of RELOAD are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADの主要なコンポーネントは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Usage Layer: Each application defines a RELOAD Usage, which is a set of data Kinds and behaviors which describe how to use the services provided by RELOAD. These usages all talk to RELOAD through a common Message Transport Service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用法・レイヤー：各アプリケーションにはRELOADが提供するサービスを利用する方法を説明し、データの種類や行動のセットですRELOAD使用状況を、定義されています。これらの用途は、すべての話は、共通のメッセージ・トランスポートサービスを通じてリロードします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message Transport: Handles end-to-end reliability, manages request state for the usages, and forwards Store and Fetch operations to the Storage component. It delivers message responses to the component initiating the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージトランスポートは：、エンドツーエンドの信頼性を処理する用途に要求状態を管理し、転送ストレージコンポーネントに操作を保存し、取得します。これは、要求を開始するコンポーネントにメッセージ応答を実現します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Storage: The Storage component is responsible for processing messages relating to the storage and retrieval of data. It talks directly to the Topology Plug-in to manage data replication and migration, and it talks to the Message Transport component to send and receive messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージ：ストレージコンポーネントは、データの記憶および検索に関連するメッセージを処理する責任があります。これは、データの複製や移行を管理するためのトポロジプラグインに直接話し、それがメッセージを送受信するメッセージ・トランスポート・コンポーネントに話しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Topology Plug-in: The Topology Plug-in is responsible for implementing the specific overlay algorithm being used. It uses the Message Transport component to send and receive overlay management messages, the Storage component to manage data replication, and the Forwarding Layer to control hop-by-hop message forwarding. This component superficially parallels conventional routing algorithms, but is more tightly coupled to the Forwarding Layer, because there is no single &#34;Routing Table&#34; equivalent used by all overlay algorithms. The Topology Plug-in has two functions: constructing the local forwarding instructions and selecting the operational topology (i.e., creating links by sending overlay management messages).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トポロジプラグイン：トポロジプラグインが使用されている特定のオーバーレイ・アルゴリズムを実装するための責任があります。これは、ホップバイホップのメッセージの転送を制御するために、オーバーレイ管理メッセージを送受信するメッセージ・トランスポート・コンポーネント、データ・レプリケーションを管理するためのストレージ・コンポーネント、および転送レイヤを使用しています。すべてのオーバーレイアルゴリズムによって使用される単一の「ルーティングテーブル」と等価が存在しないため、このコンポーネントは、表面的に従来のルーティングアルゴリズムに匹敵するが、より緊密に転送レイヤに結合されています。トポロジプラグインは、2つの機能を持っている：ローカルフォワーディング指示を構築し、運用トポロジー（すなわち、オーバーレイ管理メッセージを送信することにより、リンクを作成する）を選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Forwarding and Link Management Layer: Stores and implements the Routing Table by providing packet forwarding services between nodes. It also handles establishing new links between nodes, including setting up connections for overlay links across NATs using ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイヤを転送し、リンク管理：店舗とノード間でパケット転送サービスを提供することにより、ルーティングテーブルを実装します。また、ICEを使用してNATを越えオーバーレイリンクの接続を設定するなど、ノード間の新しいリンクを確立する処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Overlay Link Layer: Responsible for actually transporting traffic directly between nodes. Transport Layer Security (TLS) [RFC5246] and Datagram Transport Layer Security (DTLS) [RFC6347] are the currently defined &#34;overlay link layer&#34; protocols used by RELOAD for hop-by-hop communication. Each such protocol includes the appropriate provisions for per-hop framing and hop-by-hop ACKs needed by unreliable underlying transports. New protocols can be defined, as described in Sections 6.6.1 and 11.1. As this document defines only TLS and DTLS, we use those terms throughout the remainder of the document with the understanding that some future specification may add new overlay link layers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイリンク層：実際には、ノード間で直接トラフィックを輸送するための責任。トランスポート層セキュリティ（TLS）[RFC5246]及びデータグラムトランスポート層セキュリティ（DTLS）[RFC6347]はホップバイホップ通信のリロードで使用される、現在定義された「オーバーレイリンク層」プロトコルです。各そのようなプロトコルは、信頼性の低い基礎となるトランスポートによって必要とされるホップ毎フレーミングおよびホップバイホップのACKのための適切な規定を含みます。セクション6.6.1と11.1で説明したように、新しいプロトコルは、定義することができます。この文書は唯一のTLSとDTLSを定義するように、我々はいくつかの将来の仕様は、新たなオーバーレイリンクレイヤを追加することも理解した上で、文書の残りの部分でこれらの用語を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To further clarify the roles of the various layers, the following figure parallels the architecture with each layer&#39;s role from an overlay perspective and implementation layer in the Internet:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに様々な層の役割を明確にするために、次の図は、インターネットでのオーバーレイの視点と実装層から各層の役割を持つアーキテクチャに匹敵します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    Internet    | Internet Model  |
    Model       |   Equivalent    |          Reload
                |   in Overlay    |       Architecture
   -------------+-----------------+------------------------------------
                |                 |    +-------+  +-------+
                |  Application    |    | SIP   |  | XMPP  |  ...
                |                 |    | Usage |  | Usage |
                |                 |    +-------+  +-------+
                |                 |  ----------------------------------
                |                 |+------------------+     +---------+
                |   Transport     ||     Message      |&lt;---&gt;| Storage |
                |                 ||    Transport     |     +---------+
                |                 |+------------------+           ^
                |                 |       ^       ^               |
                |                 |       |       v               v
   Application  |                 |       |     +-------------------+
                |   (Routing)     |       |     |     Topology      |
                |                 |       |     |     Plug-in       |
                |                 |       |     +-------------------+
                |                 |       |         ^
                |                 |       v         v
                |    Network      |    +------------------+
                |                 |    |  Forwarding &amp;    |
                |                 |    | Link Management  |
                |                 |    +------------------+
                |                 |  ----------------------------------
   Transport    |      Link       |     +-------+  +------+
                |                 |     |TLS    |  |DTLS  |  ...
                |                 |     +-------+  +------+
   -------------+-----------------+------------------------------------
     Network    |
                |
       Link     |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the above components, nodes may communicate with a central provisioning infrastructure (not shown) to get configuration information, authentication credentials, and the initial set of nodes to communicate with to join the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記成分に加えて、ノードは、設定情報、認証証明書、およびオーバーレイに参加すると通信するノードの初期セットを取得する（図示せず）の中央プロビジョニングインフラストラクチャと通信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.1. Usage Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.1. 使い方レイヤー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The top layer, called the Usage Layer, has application usages, such as the SIP Registration Usage [SIP-RELOAD], that use the abstract Message Transport Service provided by RELOAD. The goal of this layer is to implement application-specific usages of the generic overlay services provided by RELOAD. The Usage defines how a specific application maps its data into something that can be stored in the overlay, where to store the data, how to secure the data, and finally how applications can retrieve and use the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トップ層は、RELOAD提供する抽象メッセージトランスポートサービスを使用するようにSIP登録使い方などのアプリケーション用法、[SIP-RELOAD]を、持っている、使用レイヤと呼ばれます。この層の目的は、RELOADによって提供される汎用オーバーレイ・サービスのアプリケーション固有の用法を実装することです。使用法は、特定のアプリケーションは、アプリケーションがデータを取得して使用することができますどのように最終的にデータを保護する方法、データを格納するためのオーバーレイに格納することができ、何かにそのデータをマップする方法を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The architecture diagram shows both a SIP Usage and an XMPP Usage. A single application may require multiple usages; for example, a voicemail feature in a softphone application that stores links to the messages in the overlay would require a different usage than the type of rendezvous service of XMPP or SIP. A usage may define multiple Kinds of data that are stored in the overlay and may also rely on Kinds originally defined by other usages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アーキテクチャ図は、SIPの使用とXMPPの使用の両方を示しています。単一アプリケーションは、複数の用途を必要とするかもしれません。例えば、オーバーレイ内のメッセージへのリンクを保存するソフトフォンアプリケーションでのボイスメール機能は、XMPPまたはSIPのランデブーサービスの種類とは異なる用法を必要とします。用法は、オーバーレイに格納され、また、もともと他の用途によって規定される種類に依存することができるデータの複数種類を定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the security and storage policies for each Kind are dictated by the usage defining the Kind, the usages may be coupled with the Storage component to provide security policy enforcement and to implement appropriate storage strategies according to the needs of the usage. The exact implementation of such an interface is outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各種類のセキュリティ、そしてストレージポリシーが種類を定義し、使用によって決定されるため、使用法は、セキュリティポリシーの適用を提供し、利用状況のニーズに応じて適切なストレージ戦略を実行するためにストレージ・コンポーネントと結合することができます。そのようなインタフェースの正確な実装は、本明細書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.2. Message Transport
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.2. メッセージトランスポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Message Transport component provides a generic message routing service for the overlay. The Message Transport layer is responsible for end-to-end message transactions. Each peer is identified by its location in the overlay, as determined by its Node-ID. A component that is a client of the Message Transport can perform two basic functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージトランスポートコンポーネントは、オーバーレイのための一般的なメッセージルーティングサービスを提供します。メッセージ・トランスポート・レイヤは、エンドツーエンドのメッセージトランザクションを担当しています。そのノードIDによって決定されるように、各ピアは、オーバレイにおけるその位置によって識別されます。メッセージ交通のクライアントであるコンポーネントは、2つの基本的な機能を実行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Send a message to a given peer specified by Node-ID or to the peer responsible for a particular Resource-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OノードIDによって、または特定のリソース-IDを担当するピアに指定された指定されたピアにメッセージを送ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Receive messages that other peers sent to a Node-ID or Resource-ID for which the receiving peer is responsible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O他のピアが受信ピアが担当するノードIDまたはリソース-IDに送信されたメッセージを受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All usages rely on the Message Transport component to send and receive messages from peers. For instance, when a usage wants to store data, it does so by sending Store requests. Note that the Storage component and the Topology Plug-in are themselves clients of the Message Transport, because they need to send and receive messages from other peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての用法がピアからメッセージを送受信するメッセージ・トランスポート・コンポーネントに依存しています。たとえば、ときの使用は、それがストアリクエストを送信することで、データを保存したいと考えています。彼らは他のピアからのメッセージを送受信する必要があるため、ストレージ・コンポーネントとトポロジプラグインは、自分自身のメッセージ交通のクライアントであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Message Transport Service is responsible for end-to-end reliability, which is accomplished by timer-based retransmissions. Unlike the Internet transport layer, however, this layer does not provide congestion control. RELOAD is a request-response protocol, with no more than two pairs of request-response messages used in typical transactions between pairs of nodes; therefore, there are no opportunities to observe and react to end-to-end congestion. As with all Internet applications, implementers are strongly discouraged from writing applications that react to loss by immediately retrying the transaction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ・トランスポートサービスは、タイマーベースの再送信することによって達成されるエンドツーエンドの信頼性、責任があります。インターネット輸送層とは異なり、しかし、この層は、輻輳制御を提供していません。リロードは、ノードの対の間の典型的なトランザクションで使用要求応答メッセージの2つ以下の対と、要求 - 応答プロトコルです。そのため、エンド・ツー・エンドする輻輳を観察し、反応するいかなる機会はありません。すべてのインターネットアプリケーションと同様に、実装者は強く、すぐに再試行するトランザクションによって損失に反応するアプリケーションを書くことから落胆されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Message Transport Service is similar to those described as providing &#34;key-based routing&#34; (KBR) [wikiKBR], although as RELOAD supports different overlay algorithms (including non-DHT overlay algorithms) that calculate keys (storage indices, not encryption keys) in different ways, the actual interface needs to accept Resource Names rather than actual keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードキー（ストレージ指標ではなく、暗号鍵）を計算（非DHTオーバーレイ・アルゴリズムを含む）は、異なるオーバーレイ・アルゴリズムをサポートしているがメッセージ・トランスポート・サービスは、「キーベースのルーティング」（KBR）wikiKBR]提供するものとして記載したものと同様ですさまざまな方法で、実際のインターフェースはリソース名ではなく、実際のキーを受け入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Forwarding and Link Management layers are responsible for maintaining the overlay in the face of changes in the available nodes and underlying network supporting the overlay (the Internet). They also handle congestion control between overlay neighbors, and exchange routing updates and data replicas in addition to forwarding end-to-end messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送とリンク管理層は、使用可能なノードとオーバーレイ（インターネット）をサポートする基礎となるネットワークの変化に直面してオーバーレイを維持する責任があります。彼らはまた、エンドツーエンドのメッセージの転送に加えて、オーバーレイ近隣諸国との間の輻輳制御、およびExchangeルーティングアップデートやデータの複製を処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Real-world experience has shown that a fixed timeout for the end-to-end retransmission timer is sufficient for practical overlay networks. This timer is adjustable via the overlay configuration. As the overlay configuration can be rapidly updated, this value could be dynamically adjusted at coarse time scales, although algorithms for determining how to accomplish this are beyond the scope of this specification. In many cases, however, other means of improving network performance, such as having the Topology Plug-in remove lossy links from use in overlay routing or reducing the overall hop count of end-to-end paths, will be more effective than simply increasing the retransmission timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実世界での経験は、エンドツーエンド再送タイマの固定タイムアウトが実用的なオーバーレイネットワークのために十分であることが示されています。このタイマーは、オーバーレイの設定を介して調節可能です。オーバーレイの設定を迅速に更新することができるようにこれを達成する方法を決定するためのアルゴリズムは、本明細書の範囲外であるが、この値は、動的に、粗い時間スケールで調整することができます。しかし、多くの場合、そのようなトポロジプラグインは、オーバーレイルーティングまたはエンドツーエンドパスの全体的なホップ数を減少させるのに使用から損失性リンクを削除有するようなネットワークパフォーマンスを向上させる他の手段は、単に増加よりも効果的であろう再送タイマ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.3. Storage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.3. ストレージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the major functions of RELOAD is storage of data, that is, allowing nodes to store data in the overlay and to retrieve data stored by other nodes or by themselves. The Storage component is responsible for processing data storage and retrieval messages. For instance, the Storage component might receive a Store request for a given resource from the Message Transport. It would then query the appropriate usage before storing the data value(s) in its local data store and sending a response to the Message Transport for delivery to the requesting node. Typically, these messages will come from other nodes, but depending on the overlay topology, a node might be responsible for storing data for itself as well, especially if the overlay is small.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードの主要な機能の一つは、ノードがオーバーレイにデータを格納するために、他のノードによって、またはそれ自体によって格納されたデータを取得することを可能にする、である、データの記憶装置です。ストレージ・コンポーネントは、データの格納と取得メッセージを処理する責任があります。例えば、ストレージ・コンポーネントは、Message交通から与えられたリソースのためのストア要求を受け取ることがあります。これは、そのローカル・データ・ストア内のデータ値（S）を格納し、要求ノードに配信するためにメッセージ・トランスポートへの応答を送信する前に、適切な使用を問い合わせることになります。典型的には、これらのメッセージは、他のノードから来るが、オーバーレイ・トポロジによって、ノードは、オーバーレイが小さい場合は特に、同様に自身のデータを格納するための責任を負うかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer&#39;s Node-ID determines the set of resources that it will be responsible for storing. However, the exact mapping between these is determined by the overlay algorithm in use. The Storage component will only receive a Store request from the Message Transport if this peer is responsible for that Resource-ID. The Storage component is notified by the Topology Plug-in when the Resource-IDs for which it is responsible change, and the Storage component is then responsible for migrating resources to other peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアのノードIDは、それが保存を担当するリソースのセットを決定します。しかし、これらの間の正確なマッピングは、使用中のオーバーレイアルゴリズムによって決定されます。このピアがそのリソース-IDに責任がある場合のストレージ・コンポーネントは、メッセージ転送からのストア要求を受け取ることになります。リソース-IDは、それが責任の変更であるため、およびストレージ・コンポーネントは、他のピアにリソースを移行するための責任があるとき、ストレージ・コンポーネントは、トポロジプラグインで通知されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.4. Topology Plug-in
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.4. トポロジプラグイン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD is explicitly designed to work with a variety of overlay algorithms. In order to facilitate this, the overlay algorithm implementation is provided by a Topology Plug-in so that each overlay can select an appropriate overlay algorithm that relies on the common RELOAD core protocols and code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADは、明示的にオーバーレイの様々なアルゴリズムで動作するように設計されています。各オーバーレイは、共通RELOADコアプロトコル、コードに依存して適切なオーバーレイアルゴリズムを選択できるようにこれを容易にするために、オーバーレイ・アルゴリズムの実装は、トポロジプラグインによって提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Topology Plug-in is responsible for maintaining the overlay algorithm Routing Table, which is consulted by the Forwarding and Link Management Layer before routing a message. When connections are made or broken, the Forwarding and Link Management Layer notifies the Topology Plug-in, which adjusts the Routing Table as appropriate. The Topology Plug-in will also instruct the Forwarding and Link Management Layer to form new connections as dictated by the requirements of the overlay algorithm Topology. The Topology Plug-in issues periodic update requests through Message Transport to maintain and update its Routing Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トポロジプラグインは、メッセージをルーティングする前に、転送とリンク管理レイヤから相談されたオーバーレイアルゴリズムルーティングテーブルを維持する責任があります。接続が行わまたは壊れている場合は、転送とリンク管理層は、トポロジプラグイン、適切にルーティングテーブルを調整通知します。トポロジプラグインも、オーバーレイアルゴリズムトポロジの要件によって指示されるように、新たな接続を形成するために、転送とリンク管理レイヤを指示します。トポロジのプラグインのルーティングテーブルを維持し、更新するためのメッセージ・トランスポートを介して定期的に更新要求を発行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As peers enter and leave, resources may be stored on different peers, so the Topology Plug-in also keeps track of which peers are responsible for which resources. As peers join and leave, the Topology Plug-in instructs the Storage component to issue resource migration requests as appropriate, in order to ensure that other peers have whatever resources they are now responsible for. The Topology Plug-in is also responsible for providing for redundant data storage to protect against loss of information in the event of a peer failure and to protect against compromised or subversive peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが出入りとして、リソースが異なるピアに格納することができるので、トポロジプラグインも、ピアがどのリソースに責任があるかを追跡します。ピアが参加したままとして、トポロジプラグインは、他のピアは、彼らが今を担当しているどんなリソースがあることを確認するために、必要に応じてリソースの移行要求を発行するストレージ・コンポーネントに指示します。トポロジプラグインはまた、ピアの障害発生時に情報の損失から保護するため、および損傷し又は破壊ピアから保護するための冗長データ記憶を提供する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.5. Forwarding and Link Management Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.5. 転送とリンク管理レイヤ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Forwarding and Link Management Layer is responsible for getting a message to the next peer, as determined by the Topology Plug-in. This layer establishes and maintains the network connections as needed by the Topology Plug-in. This layer is also responsible for setting up connections to other peers through NATs and firewalls using ICE, and it can elect to forward traffic using relays for NAT and firewall traversal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送とリンク管理層は、トポロジプラグインによって決定されるように、次のピアにメッセージを取得するための責任があります。この層は、確立し、トポロジプラグインにより、必要に応じてネットワーク接続を維持します。この層はまた、ICEを使用してNATのファイアウォールを介して他のピアへの接続を設定するための責任があり、そしてそれはNATやファイアウォール越えのためのリレーを使用してトラフィックを転送することを選択することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion control is implemented at this layer to protect the Internet paths used to form the link in the overlay. Additionally, retransmission is performed to improve the reliability of end-to-end transactions. The relation of this layer to the Message Transport Layer can be likened to the relation of the link-level congestion control and retransmission in modern wireless networks ` to Internet transport protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳制御は、オーバーレイにリンクを形成するために使用されるインターネット・パスを保護するために、この層に実装されています。また、再送信は、エンドツーエンドのトランザクションの信頼性を向上させるために行われます。メッセージトランスポート層にこの層の関係は、インターネットトランスポートプロトコルに近代的な無線ネットワークにおけるリンク・レベルの輻輳制御と再送の関係 `に例えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This layer provides a generic interface that allows the Topology Plug-in to control the overlay and resource operations and messages. Because each overlay algorithm is defined and functions differently, we generically refer to the table of other peers that the overlay algorithm maintains and uses to route requests as a Routing Table. The Topology Plug-in actually owns the Routing Table, and forwarding decisions are made by querying the Topology Plug-in for the next hop for a particular Node-ID or Resource-ID. If this node is the destination of the message, the message is delivered to the Message Transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この層は、トポロジプラグインがオーバーレイやリソース操作とメッセージを制御することを可能にする一般的なインタフェースを提供します。各オーバーレイアルゴリズムは異なって定義及び関数されているので、我々は、一般的にオーバーレイアルゴリズムがルーティングテーブルとしてルート要求に維持し、使用している他のピアのテーブルを参照します。トポロジプラグインは、実際には、ルーティングテーブルを所有し、転送の決定は、特定のノードIDまたはリソース-IDのための次のホップのトポロジプラグイン照会することによって行われます。このノードは、メッセージの宛先である場合、メッセージは、メッセージトランスポートに送達されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This layer also utilizes a framing header to encapsulate messages as they are forwarded along each hop. This header aids reliability congestion control, flow control, etc. It has meaning only in the context of that individual link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この層はまた、それらが各ホップに沿って転送されるメッセージをカプセル化するフレーミングヘッダを利用します。それだけで、個々のリンクの文脈で意味があり、このヘッダ補助信頼輻輳制御、フロー制御、等。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Forwarding and Link Management Layer sits on top of the Overlay Link Layer protocols that carry the actual traffic. This specification defines how to use DTLS and TLS protocols to carry RELOAD messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送とリンク管理層は、実際のトラフィックを運ぶオーバーレイリンク層プロトコルの上に座っています。この仕様は、RELOADメッセージを運ぶためにDTLSとTLSプロトコルを使用する方法を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. セキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD&#39;s security model is based on each node having one or more public key certificates. In general, these certificates will be assigned by a central server, which also assigns Node-IDs, although self-signed certificates can be used in closed networks. These credentials can be leveraged to provide communications security for RELOAD messages. RELOAD provides communications security at three levels:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADのセキュリティモデルは、一つ以上の公開鍵証明書を持つ各ノードに基づいています。自己署名証明書が閉じたネットワークで使用することができるが、一般的に、これらの証明書は、また、ノードIDを割り当てる中央サーバによって割り当てられます。これらの資格情報は、RELOADメッセージ用の通信セキュリティを提供するために活用することができます。 RELOADは3つのレベルで通信のセキュリティを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connection level: Connections between nodes are secured with TLS, DTLS, or potentially some to-be-defined future protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続レベル：ノード間の接続はTLS、DTLSで固定された、または潜在的将来のプロトコルには、定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message level: Each RELOAD message is signed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージレベル：各リロードメッセージが署名されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Object Level: Stored objects are signed by the creating node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブジェクト・レベル：格納されたオブジェクトを作成ノードによって署名されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These three levels of security work together to allow nodes to verify the origin and correctness of data they receive from other nodes, even in the face of malicious activity by other nodes in the overlay. RELOAD also provides access control built on top of these communications security features. Because the peer responsible for storing a piece of data can validate the signature on the data being stored, it can determine whether or not a given operation is permitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一緒にセキュリティの仕事のこれらの3つのレベルは、ノードがオーバーレイ内の他のノードでも、悪質な行為に直面して、彼らは他のノードから受信したデータの起源と正しいかどうかを検証できるようにします。 RELOADはまた、これらの通信のセキュリティ機能の上に構築されたアクセス制御を提供します。データの一部を格納する責任ピアが格納されたデータに署名を検証することができるので、特定の操作が許可されているか否かを判断することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD also provides an optional shared-secret-based admission control feature using shared secrets and TLS pre-shared keys (PSK) or TLS Secure Remote Password (SRP). In order to form a TLS connection to any node in the overlay, a new node needs to know the shared overlay key, thus restricting access to authorized users only. This feature is used together with certificate-based access control, not as a replacement for it. It is typically used when self-signed certificates are being used but would generally not be used when the certificates were all signed by an enrollment server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リモート・パスワード（SRP）を確保共有秘密とTLS事前共有鍵（PSK）を使用して、オプションの共有秘密ベースのアドミッション制御機能を提供するか、TLSもリロードします。オーバーレイ内の任意のノードへのTLS接続を形成するためには、新しいノードは、このように許可されたユーザーのみにアクセスを制限する、共有オーバーレイキーを知る必要があります。この機能はありません、それに代わるものとして、証明書ベースのアクセスコントロールと一緒に使用されています。これは、自己署名証明書を使用している際に一般的に使用されますが、証明書はすべての登録サーバによって署名された際に一般的に使用されないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. Structure of This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. このドキュメントの構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remainder of this document is structured as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように、この文書の残りの部分は構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 3 provides definitions of terms used in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O第3節では、本書で使用される用語の定義を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 4 provides an overview of the mechanisms used to establish and maintain the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O部4は、オーバーレイを確立し、維持するために使用されるメカニズムの概要を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 5 provides an overview of the mechanism RELOAD provides to support other applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O第5節では、RELOADは、他のアプリケーションをサポートするために提供メカニズムの概要を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 6 defines the protocol messages that RELOAD uses to establish and maintain the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O部6は、リロードがオーバーレイを確立し、維持するために使用するプロトコルのメッセージを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 7 defines the protocol messages that are used to store and retrieve data using RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O部7は、リロードを使用してデータを格納および検索するために使用されたプロトコルメッセージを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 8 defines the Certificate Store Usages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O部8には、証明書ストアの用途を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 9 defines the TURN Server Usage needed to locate TURN (Traversal Using Relays around NAT) servers for NAT traversal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O部9は、NATトラバーサルのために（トラバーサルがNATの周りにリレーを使用して）サーバをTURNを見つけるために必要なTURNサーバーの使用法を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 10 defines a specific Topology Plug-in using a Chord-based algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O部10は、特定のトポロジプラグインを定義するコードベースのアルゴリズムを使用して。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 11 defines the mechanisms that new RELOAD nodes use to join the overlay for the first time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O部11は、新たなリロードノードが初めてオーバーレイを結合するために使用するメカニズムを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 12 provides an extended example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O部12は、拡張された例を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.必要な言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はRFC 2119 [RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Terms in this document are defined in-line when used and are also defined below for reference. The definitions in this section use terminology and concepts that are not explained until later in the specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書に記載されている用語を使用するときにインライン定義され、また、参考のために以下に定義されています。このセクションの定義は後明細書にまで説明されていない用語や概念を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Admitting Peer (AP): A peer in the overlay which helps the Joining Node join the Overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加するノードがオーバーレイに参加役立つオーバーレイ内のピア：ピア（AP）を認めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bootstrap Node: A network node used by Joining Nodes to help locate the Admitting Peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブートストラップノード：認めるピアを見つけやすくするためにノードの参加が使用するネットワークノード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client: A host that is able to store data in and retrieve data from the overlay, but does not participate in routing or data storage for the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント：にデータを格納し、オーバーレイからデータを取得することができますが、オーバーレイのためのルーティングやデータストレージに参加していないホスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Configuration Document: An XML document containing all the Overlay Parameters for one overlay instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定文書：1つのオーバーレイインスタンスのすべてのオーバーレイパラメータを含むXML文書。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connection Table: Contains connection information for the set of nodes to which a node is directly connected, which include nodes that are not yet available for routing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続テーブルは：まだルーティングのために利用できないノードを含むノードが直接接続されたノードのセットの接続情報が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Destination List: A list of Node-IDs, Resource-IDs, and Opaque IDs through which a message is to be routed, in strict order. A single Node-ID, Resource-ID, or Opaque ID is a trivial form of Destination List. When multiple Node-IDs are specified, a Destination List is a loose source route. The list is reduced hop by hop, and does not include the source but does include the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先リスト：メッセージは、厳密な順序で、ルーティングされる、それを通してノードIDは、リソース-ID、および不透明IDのリスト。単一ノードID、リソース-ID、または不透明なIDは、宛先リストの些細な形です。複数のノードのIDが指定されている場合は、送信先リストには、ルーズソースルートです。リストには、ホップでホップを低減し、かつソースが含まれていませんが、先が含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DHT: A distributed hash table. A DHT is an abstract storage service realized by storing the contents of the hash table across a set of peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DHT：分散ハッシュテーブル。 DHTは、ピアのセットにわたってハッシュテーブルの内容を格納することによって実現する抽象ストレージサービスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ID: A generic term for any kind of identifiers in an Overlay. This document specifies an ID as being an Application-ID, a Kind-ID, a Node-ID, a transaction ID, a component ID, a response ID, a Resource-ID, or an Opaque ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ID：オーバーレイ中の識別子のいずれかの種類の総称。この文書は、アプリケーションID、種類-ID、ノードID、トランザクションID、部品ID、応答ID、リソース-ID、または不透明なIDであるとIDを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Joining Node (JN): A node that is attempting to become a peer in a particular Overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定のオーバーレイ内のピアになることを試みているノード：ノード（IN）を接合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kind: A Kind defines a particular type of data that can be stored in the overlay. Applications define new Kinds to store the data they use. Each Kind is identified with a unique integer called a Kind-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類：種類は、オーバーレイに格納できるデータの特定のタイプを定義します。アプリケーションは、彼らが使用するデータを格納するための新しい種類を定義します。各種類は、種類-IDと呼ばれる固有の整数で識別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kind-ID: A unique 32-bit value identifying a Kind. Kind-IDs are either private or allocated by IANA (see Section 14.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類-ID：種類を識別する一意の32ビット値。種類-IDは、プライベートまたはIANA（14.6節を参照）によって割り当てられたいずれかです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum Request Lifetime: The maximum time a request will wait for a response. This value is equal to the value of the overlay reliability value (defined in Section 11.1) multiplied by the number of transmissions (defined in Section 6.2.1), and so defaults to 15 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大要求の有効期間：要求が応答を待つ最大時間。この値は、（セクション6.2.1で定義された）送信の数を乗じた（セクション11.1で定義された）オーバーレイ信頼度の値に等しく、15秒そうデフォルト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Node: The term &#34;node&#34; refers to a host that may be either a peer or a client. Because RELOAD uses the same protocol for both clients and peers, much of the text applies equally to both. Therefore, we use &#34;node&#34; when the text applies to both clients and peers, and we use the more specific term (i.e., &#34;client&#34; or &#34;peer&#34;) when the text applies only to clients or only to peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノード：用語「ノード」は、ピアまたはクライアントのいずれかとすることができるホストを指します。 RELOADは、クライアントとピアの両方で同じプロトコルを使用しているため、テキストの多くは両方にも同様に適用されます。したがって、テキストは、クライアント及びピアの両方に適用されたときに、我々は、「ノード」を使用し、テキストのみをクライアントにのみピアに適用されたときに、我々は、より具体的な用語（すなわち、「クライアント」または「ピア」）を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Node-ID: A value of fixed but configurable length that uniquely identifies a node. Node-IDs of all 0s and all 1s are reserved. A value of 0 is not used in the wire protocol, but can be used to indicate an invalid node in implementations and APIs. The Node-ID of all 1s is used on the wire protocol as a wildcard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードID：一意のノードを識別する固定の値が、設定可能な長さ。すべて0とすべて1のノードIDが予約されています。 0の値は、ワイヤプロトコルで使用されていないが、実装およびAPIに無効なノードを示すために使用することができます。すべて1のノードIDは、ワイルドカードとしてワイヤプロトコルに使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Overlay Algorithm: An overlay algorithm defines the rules for determining which peers in an overlay store a particular piece of data and for determining a topology of interconnections amongst peers in order to find a piece of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイアルゴリズム：オーバーレイ・アルゴリズムは、オーバーレイ内のピアは、特定のデータを格納するかを決定するために、データの一部を見つけるためにピア間の相互接続のトポロジーを決定するための規則を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Overlay Instance: A specific overlay algorithm and the collection of peers that are collaborating to provide read and write access to it. Any number of overlay instances can be running in an IP network at a time, and each operates in isolation of the others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイインスタンス：特定のオーバーレイアルゴリズムと読んで、それへの書き込みアクセスを提供するために協力している仲間の集まり。オーバーレイインスタンスの任意の数は、一度に、IPネットワークで実行することができ、それぞれが他の分離で動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Overlay Parameters: A set of values that are shared among all nodes in an overlay. The overlay parameters are distributed in an XML document called the Configuration Document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイパラメータ：オーバレイ内のすべてのノード間で共有されている値のセット。オーバーレイパラメータを設定文書と呼ばれるXML文書で配布されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer: A host that is participating in the overlay. Peers are responsible for holding some portion of the data that has been stored in the overlay, and they are responsible for routing messages on behalf of other hosts as needed by the Overlay Algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピア：オーバーレイに参加しているホスト。ピアは、オーバーレイに格納されたデータの一部を保持するための責任がある、と彼らはオーバーレイアルゴリズムにより、必要に応じて他のホストの代わりにメッセージをルーティングする責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer Admission: The act of admitting a node (the Joining Node) into an Overlay. After the admission process is over, the Joining Node is a fully functional peer of the overlay. During the admission process, the Joining Node may need to present credentials to prove that it has sufficient authority to join the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピア入場​​：オーバーレイ内のノード（参加するノード）を認める行為。入場処理が終わった後、参加するノードは、オーバーレイの完全に機能するピアです。入学プロセス中、参加ノードは、それがオーバーレイに参加するための十分な権限を持っていることを証明するための資格情報を提示する必要があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resource: An object or group of objects stored in a P2P network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソース：P2Pネットワークに格納されたオブジェクトまたはオブジェクトのグループ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resource-ID: A value that identifies some resources and which is used as a key for storing and retrieving the resource. Often this is not human friendly/readable. One way to generate a Resource-ID is by applying a mapping function to some other unique name (e.g., user name or service name) for the resource. The Resource-ID is used by the distributed database algorithm to determine the peer or peers that are responsible for storing the data for the overlay. In structured P2P networks, Resource-IDs are generally fixed length and are formed by hashing the Resource Name. In unstructured networks, Resource Names may be used directly as Resource-IDs and may be of variable length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースID：いくつかのリソースを識別する値とどのは、リソースを保存し、検索するためのキーとして使用されます。多くの場合、これは、読み出し/優しい人間ではありません。リソース-IDを生成するための一つの方法は、リソースのためのいくつかの他の一意の名前（例えば、ユーザ名、またはサービス名）にマッピング関数を適用することによってです。リソース-IDは、オーバーレイのためのデータを格納するための責任があるピアまたはピアを決定するために、分散データベース・アルゴリズムによって使用されます。構造化P2Pネットワークでは、リソース-IDは、一般的に長さが固定されており、リソース名をハッシュすることによって形成されています。構造化されていないネットワークでは、リソース名は、リソースIDとして直接使用することができる可変長であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resource Name: The name by which a resource is identified. In unstructured P2P networks, the Resource Name is sometimes used directly as a Resource-ID. In structured P2P networks, the Resource Name is typically mapped into a Resource-ID by using the string as the input to hash function. Structured and unstructured P2P networks are described in [RFC5694]. A SIP resource, for example, is often identified by its AOR (address-of-record), which is an example of a Resource Name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソース名：リソースを識別するための名前。非構造化P2Pネットワークでは、リソース名は、時々、リソース-IDとして直接使用されます。構造化P2Pネットワークでは、リソース名は、典型的には、関数をハッシュするために、入力として文字列を使用して、リソース-IDにマッピングされます。構造化および非構造化P2Pネットワークは、[RFC5694]に記載されています。 SIPリソースは、例えば、多くの場合、リソース名の例であり、そのAOR（アドレス・オブ・レコード）によって識別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Responsible Peer: The peer that is responsible for a specific resource, as defined by the Topology Plug-in algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
責任ピア：トポロジプラグインアルゴリズムによって定義されるように、特定のリソースを担当するピア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Routing Table: The set of directly connected peers which a node can use to forward overlay messages. In normal operation, these peers will all be in the Connection Table, but not vice versa, because some peers may not yet be available for routing. Peers may send messages directly to peers that are in their Connection Tables, but may forward messages to peers that are not in their Connection Table only through peers that are in the Routing Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングテーブル：ノードはオーバーレイメッセージを転送するために使用することができ、直接接続されたピアのセット。いくつかのピアがまだルーティングのために利用可能ではないかもしれないので、通常の動作では、これらのピアは、全てではなく、その逆、接続テーブルであろう。ピアはその接続テーブルにあるピアに直接メッセージを送ることが、唯一のルーティングテーブルにあるピアを通じて接続テーブルにないピアにメッセージを転送することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Successor Replacement Hold-Down Time: The amount of time to wait before starting replication when a new successor is found; it defaults to 30 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後継交換ホールドダウンタイム：新しい後継者が発見された場合、レプリケーションを開始するまでの待機時間。それは30秒にデフォルト設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transaction ID: A randomly chosen identifier selected by the originator of a request that is used to correlate requests and responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランザクションID：要求と応答を相関させるために使用される要求の発信者によって選択されたランダムに選択された識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Usage: The definition of a set of data structures (data Kinds) that an application wants to store in the overlay. A usage may also define a set of network protocols (Application IDs) that can be tunneled over TLS or DTLS direct connections between nodes. For example, the SIP Usage defines a SIP registration data Kind, which contains information on how to reach a SIP endpoint, and two Application IDs corresponding to the SIP and SIPS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用法：アプリケーションがオーバーレイに保存したいデータ構造（データ種類）のセットの定義。用法はまた、ノード間のTLSまたはDTLS直接接続を介してトンネリングすることができるネットワークプロトコル（アプリケーションのID）のセットを定義することができます。例えば、SIPの使用は、SIPエンドポイントに到達する方法についての情報が含まSIP登録データの種類を定義し、SIPに対応する2つのアプリケーションIDおよびプロトコルをSIPS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
User: A physical person identified by the certificates assigned to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザー：自分に割り当てられた証明書によって識別される物理人物。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
User Name: A name identifying a user of the overlay, typically used as a Resource Name or as a label on a resource that identifies the user owning the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザ名：一般的にリソース名として、またはリソースを所有するユーザを識別するリソース上のラベルとして使用されるオーバーレイのユーザを識別する名前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Overlay Management Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.オーバーレイ管理の概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most basic function of RELOAD is as a generic overlay network. Nodes need to be able to join the overlay, form connections to other nodes, and route messages through the overlay to nodes to which they are not directly connected. This section provides an overview of the mechanisms that perform these functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADの最も基本的な機能は、一般的なオーバーレイネットワークとしてあります。ノードは、それらが直接接続されていないためにノードにオーバーレイを介してオーバーレイ、他のノードへのフォームの接続、およびルーティングメッセージに参加できるようにする必要があります。このセクションでは、これらの機能を実行するメカニズムの概要を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Security and Identification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. セキュリティと識別
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The overlay parameters are specified in a Configuration Document. Because the parameters include security-critical information, such as the certificate signing trust anchors, the Configuration Document needs to be retrieved securely. The initial Configuration Document is either initially fetched over HTTPS or manually provisioned. Subsequent Configuration Document updates are received either as a result of being refreshed periodically by the configuration server, or, more commonly, by being flood-filled through the overlay, which allows for fast propagation once an update is pushed. In the latter case, updates are via digital signatures that trace back to the initial Configuration Document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイパラメータを設定文書で指定されています。パラメータは、このような証明書の署名信頼アンカーとしてセキュリティ上重要な情報が含まれているため、構成ドキュメントを安全に取得する必要があります。初期設定文書は、最初はHTTPS経由で取得するか、手動でプロビジョニングのどちらかです。後続の構成ドキュメントの更新は、いずれかの更新が押されると、高速増殖を可能にオーバーレイを介してフラッド充填されることによって、より一般的には、コンフィギュレーション・サーバによって定期的にリフレッシュ、またはされた結果として受信されます。後者の場合、更新は初期設定文書に遡るデジタル署名を介してです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every node in the RELOAD overlay is identified by a Node-ID. The Node-ID is used for three major purposes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADオーバーレイ内のすべてのノードは、ノードIDで識別されます。ノードIDは、三つの主要な目的のために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To address the node itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oはノード自体に対処するために。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To determine the node&#39;s position in the overlay topology (if the overlay is structured; overlays do not need to be structured).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイ・トポロジ内のノードの位置を決定するために、O（オーバーレイが構成されている場合は、オーバーレイを構造化する必要はありません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To determine the set of resources for which the node is responsible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oは、ノードが担当するリソースのセットを決定するには。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each node has a certificate [RFC5280] containing its Node-ID in a subjectAltName extension, which is unique within an overlay instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ノードは、オーバーレイ・インスタンス内で一意であるsubjectAltName拡張にそのノードIDを含む証明書[RFC5280]を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificate serves multiple purposes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書は、複数の目的を果たします：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It entitles the user to store data at specific locations in the Overlay Instance. Each data Kind defines the specific rules for determining which certificates can access each Resource-ID/Kind-ID pair. For instance, some Kinds might allow anyone to write at a given location, whereas others might restrict writes to the owner of a single certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれはオーバーレイインスタンス内の特定の場所にデータを保存するために、ユーザー資格を与えます。各データ種類は、各リソース-ID /種類-IDのペアにアクセスすることができる証明書を決定するための特定の規則を定義します。例えば、いくつかの種類は、他の人が単一の証明書の所有者への書き込みを制限する可能性がある一方で、誰もが、与えられた場所に書き込むことができる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It entitles the user to operate a node that has a Node-ID found in the certificate. When the node forms a connection to another peer, it uses this certificate so that a node connecting to it knows it is connected to the correct node. (Technically, a TLS or DTLS association with client authentication is formed.) In addition, the node can sign messages, thus providing integrity and authentication for messages which are sent from the node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは、証明書に見出されるノードIDを有するノードを操作するユーザが権利を与え。ノードが別のピアへの接続を形成する場合、それに接続するノードは、それが正しいノードに接続されている知っているように、この証明書を使用します。 （技術的には、クライアント認証を有するTLSまたはDTLS関連付けが形成されている。）また、ノードは、このように、ノードから送信されるメッセージの完全性及び認証を提供する、メッセージに署名することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It entitles the user to use the user name found in the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは証明書で見つかったユーザー名を使用するユーザー資格を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a user has more than one device, typically they would get one certificate for each device. This allows each device to act as a separate peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーが複数のデバイスを持っている場合は、通常、彼らは各デバイスの証明書を1つになるだろう。これは、各装置が別個のピアとして動作することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD supports multiple certificate issuance models. The first is based on a central enrollment process, which allocates a unique name and Node-ID and puts them in a certificate for the user. All peers in a particular Overlay Instance have the enrollment server as a trust anchor and so can verify any other peer&#39;s certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADは、複数の証明書発行のモデルをサポートしています。最初は、一意の名前とノードIDを割り当て、ユーザーの証明書でそれらを置く中央の登録プロセスに基づいています。特にオーバーレイインスタンスのすべてのピアは、トラストアンカーとして登録サーバーを持っているので、他のピアの証明書を確認することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second model is useful in settings, when a group of users want to set up an overlay network but are not concerned about attack by other users in the network. For instance, users on a LAN might want to set up a short-term ad hoc network without going to the trouble of setting up an enrollment server. RELOAD supports the use of self-generated, self-signed certificates. When self-signed certificates are used, the node also generates its own Node-ID and user name. The Node-ID is computed as a digest of the public key, to prevent Node-ID theft. Note that the relevant cryptographic property for the digest is partial preimage resistance. Collision resistance is not needed, because an attacker who can create two nodes with the same Node-ID but a different public key obtains no advantage. This model is still subject to a number of known attacks (most notably, Sybil attacks [Sybil]) and can be safely used only in closed networks where users are mutually trusting. Another drawback of this approach is that the user&#39;s data is then tied to their key, so if a key is changed, any data stored under their Node-ID needs to be re-stored. This is not an issue for centrally issued Node-IDs provided that the Certification Authority (CA) reissues the same Node-ID when a new certificate is generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーのグループは、オーバーレイネットワークを設定したいが、ネットワーク内の他のユーザーによる攻撃を懸念していないときに、第2のモデルは、設定に有用です。たとえば、LAN上のユーザは、登録サーバーをセットアップのトラブルに行かずにアドホックネットワークの短期を設定することもできます。 RELOADは自己生成、自己署名証明書の使用をサポートしています。自己署名証明書が使用される場合、ノードは、自身のノードID及びユーザ名を生成します。ノードIDは、ノードIDの盗難を防止するために、公開鍵のダイジェストとして計算されます。ダイジェストに関連する暗号化プロパティは、部分的なプリイメージ抵抗であることに注意してください。同じノードIDを持つ2つのノードを作成しますが、異なる公開鍵は何の利点を得ることができない攻撃者ので、衝突抵抗は、必要とされていません。このモデルは、依然として既知の攻撃（特に、シビル攻撃[シビル]）の数の対象であり、安全にのみ、ユーザーが互いに信頼している閉じたネットワークで使用することができます。キーが変更されるので、もしこのアプローチの別の欠点は、ユーザーのデータは、その後、そのキーに結び付けられていることを、自分のノードIDの下で保存されたデータを再保存する必要があります。これは、新しい証明書が生成されると、証明機関（CA）が同じノードIDを再発行することを提供一元発行ノードIDの問題ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general principle here is that the security mechanisms (TLS or DTLS at the data link layer and message signatures at the message transport layer) are always used, even if the certificates are self-signed. This allows for a single set of code paths in the systems, with the only difference being whether certificate verification is used to chain to a single root of trust.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで一般的な原理は、証明書は自己署名された場合でも、セキュリティ・メカニズム（メッセージのトランスポート層のデータリンク層及びメッセージ署名でTLSまたはDTLS）が常に使用されるということです。これは、唯一の違いは、証明書の検証は、信頼の単一ルートにチェーンに使用されているかどうかであると、システム内のコードパスの単一のセットを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Shared-Key Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. 共有鍵セキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD also provides an admission control system based on shared keys. In this model, the peers all share a single key which is used to authenticate the peer-to-peer connections via TLS-PSK [RFC4279] or TLS-SRP [RFC5054].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードは、共有鍵に基づいてアドミッション制御システムを提供します。 TLS-PSK [RFC4279]またはTLS-SRP [RFC5054]を介してピア・ツー・ピア接続を認証するために使用され、このモデルにおいて、ピアすべての共有単一のキー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Clients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. クライアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD defines a single protocol that is used both as the peer protocol and as the client protocol for the overlay. Having a single protocol simplifies implementation, particularly for devices that may act in either role, and allows clients to inject messages directly into the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードピアプロトコルとして、およびオーバーレイのクライアントプロトコルの両方として使用される単一のプロトコルを定義します。単一のプロトコルを有することは、特にいずれかの役割で作用することができる装置のために、実装を簡素化し、そしてクライアントがオーバーレイに直接メッセージを注入することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We use the term &#34;peer&#34; to identify a node in the overlay that routes messages for nodes other than those to which it is directly connected. Peers also have storage responsibilities. We use the term &#34;client&#34; to refer to nodes that do not have routing or storage responsibilities. When text applies to both peers and clients, we will simply refer to such devices as &#34;nodes&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、それが直接接続されているもの以外の他のノードのルートメッセージことオーバーレイ内のノードを識別するために、用語「ピア」を使用します。ピアは、ストレージの責任を持っています。私たちは、ルーティングやストレージの責任を持たないノードを参照するために、「クライアント」という用語を使用します。テキストは、ピアとクライアントの両方に適用された場合、我々は単に「ノード」などのデバイスを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD&#39;s client support allows nodes that are not participating in the overlay as peers to utilize the same implementation and to benefit from the same security mechanisms as the peers. Clients possess and use certificates that authorize the user to store data at certain locations in the overlay. The Node-ID in the certificate is used to identify the particular client as a member of the overlay and to authenticate its messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADのクライアントサポートはピアとしてオーバーレイに参加していないノードが同じ実装を利用すると、ピアと同じセキュリティ・メカニズムの恩恵を受けることができます。クライアントは、オーバーレイ内の特定の場所にデータを保存するために、ユーザーを認証する証明書を所有し、使用しています。証明書内のノードIDは、オーバーレイのメンバとして特定のクライアントを識別し、そのメッセージを認証するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In RELOAD, unlike some other designs, clients are not first-class entities. From the perspective of a peer, a client is a node that has connected to the overlay, but that has not yet taken steps to insert itself into the overlay topology. It might never do so (if it&#39;s a client), or it might eventually do so (if it&#39;s just a node that is taking a long time to join). The routing and storage rules for RELOAD provide for correct behavior by peers regardless of whether other nodes attached to them are clients or peers. Of course, a client implementation needs to know that it intends to be a client, but this localizes complexity only to that node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADでは、いくつかの他のデザインとは異なり、クライアントは、ファーストクラスのエンティティではありません。ピアの観点から、クライアントは、オーバーレイに接続されたノードであり、それはまだオーバーレイ・トポロジに自身を挿入するための措置を講じていません。それは（それがクライアントの場合）ので、決してしないかもしれない、またはそれは最終的に（それが参加するのに長い時間がかかっているだけのノードの場合）そうかもしれません。リロードのルーティングおよびストレージ・ルールに関係なく、それらに取り付けられた他のノードがクライアントまたはピアであるかどうかのピアによって正しい動作を提供します。もちろん、クライアントの実装は、それがクライアントになろうとすることを知っている必要がありますが、これはそのノードのみを複雑に局在化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For more discussion about the motivation for RELOAD&#39;s client support, see Appendix B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADのクライアントをサポートするためのモチベーションについての詳細な議論については、付録Bを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Client Routing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. クライアントのルーティング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients may insert themselves in the overlay in two ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、2つの方法でオーバーレイで自分自身を挿入することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Establish a connection to the peer responsible for the client&#39;s Node-ID in the overlay. Then, requests may be sent from/to the client using its Node-ID in the same manner as if it were a peer, because the responsible peer in the overlay will handle the final step of routing to the client. This may require a TURN [RFC5766] relay in cases where NATs or firewalls prevent a client from forming a direct connection with its responsible peer. Note that clients that choose this option need to process Update messages from the peer (Section 6.4.2.3). These updates can indicate that the peer is no longer responsible for the client&#39;s Node-ID. The client would then need to form a connection to the appropriate peer. Failure to do so will result in the client no longer receiving messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oオーバーレイで、クライアントのノードIDを担当するピアへの接続を確立します。オーバーレイに責任ピアはクライアントへのルーティングの最終ステップを処理するため、次に、要求は、それがピアであるかのように同じ方法で、そのノードIDを使用して、クライアントへ/から送信されても​​よいです。これは、のNATまたはファイアウォールがその責任ピアとの直接接続を形成することからクライアントを防ぐ場合にTURN [RFC5766]中継を必要とするかもしれません。このオプションを選択し、クライアントがピア（セクション6.4.2.3）からの更新メッセージを処理する必要があることに注意してください。これらのアップデートは、ピアは、もはやクライアントのノードIDの責任であることを示すことはできません。クライアントは、適切なピアへの接続を形成する必要があります。そうしないと、メッセージを受信しなくなったクライアントになりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Establish a connection with an arbitrary peer in the overlay (perhaps based on network proximity or an inability to establish a direct connection with the responsible peer). In this case, the client will rely on RELOAD&#39;s Destination List feature (Section 6.3.2.2) to ensure reachability. The client can initiate requests, and any node in the overlay that knows the Destination List to its current location can reach it, but the client is not directly reachable using only its Node-ID. If the client is to receive incoming requests from other members of the overlay, the Destination List needed to reach the client needs to be learnable via other mechanisms, such as being stored in the overlay by a usage. A client connected this way using a certificate with only a single Node-ID can proceed to use the connection without performing an Attach (Section 6.5.1). A client wishing to connect using this mechanism with a certificate with multiple Node-IDs can use a Ping (Section 6.5.3) to probe the Node-ID of the node to which it is connected before performing the Attach.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O（おそらくネットワーク近接又は責任ピアと直接接続を確立できないことに基づいて）オーバーレイの任意のピアとの接続を確立します。この場合、クライアントは、到達可能性を確保するために、RELOADの送信先リスト機能（6.3.2.2項）に依存しています。クライアントが要求を開始することができ、かつ、現在の場所に宛先リストを知っているオーバーレイ内の任意のノードは、それに到達することができますが、クライアントはそのノードIDを使用して、直接到達できません。クライアントは、オーバーレイの他のメンバーからの着信要求を受信する場合は、クライアントに到達するために必要な宛先リストは、このような使用によってオーバーレイに格納されているなど、他のメカニズムを介して学習可能である必要があります。クライアント（セクション6.5.1）に取り付け行うことなく接続を使用するように進むことができ、単一のノードIDと証明書を使用して、このように接続されています。ノードのノードIDをプローブするためのPing（セクション6.5.3）を使用することができ、複数のノードIDを持つ証明書を使用してこのメ​​カニズムを使用して接続することを望むクライアントは、それが取り付け行う前に接続されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Minimum Functionality Requirements for Clients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. クライアントの最小機能要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node may act as a client simply because it does not have the capacity or need to act as a peer in the overlay, or because it does not even have an implementation of the Topology Plug-in defined in Section 6.4.1, needed to act as a peer in the overlay. In order to exchange RELOAD messages with a peer, a client needs to meet a minimum level of functionality. Such a client will:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードは、それが能力を持っているか、オーバーレイ内のピアとして機能する必要はありませんという理由だけで、クライアントとして動作することができる、またはそれもトポロジプラグインに必要な6.4.1項で定義されているの実装を持っていないため、オーバーレイ内のピアとして動作します。ピアとRELOADメッセージを交換するためには、クライアントは、機能の最小レベルを満たしている必要があります。このようなクライアントは以下となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Implement RELOAD&#39;s connection-management operations that are used to establish the connection with the peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oピアとの接続を確立するために使用されているRELOADの接続管理操作を実装します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Implement RELOAD&#39;s data retrieval methods (with client functionality).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O（クライアント機能付き）RELOADのデータ検索メソッドを実装します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Be able to calculate Resource-IDs used by the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oオーバーレイで使用される資源のIDを計算することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Possess security credentials needed by the overlay that it is implementing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれが実装されるオーバーレイで必要なセキュリティ資格情報を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client speaks the same protocol as the peers, knows how to calculate Resource-IDs, and signs its requests in the same manner as peers. While a client does not necessarily require a full implementation of the overlay algorithm, calculating the Resource-ID requires an implementation of an appropriate algorithm for the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ピアと同じプロトコルを話す資源のIDを計算する方法を知っている、とピアと同様にその要求に署名します。クライアントは必ずしもオーバーレイアルゴリズムの完全な実装を必要としませんが、リソース-IDを計算することは、オーバーレイのための適切なアルゴリズムを実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Routing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. ルーティング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section discusses the capabilities of RELOAD&#39;s routing layer and the protocol features used to implement the capabilities, and provides a brief overview of how they are used. Appendix A discusses some alternative designs and the trade-offs that would be necessary to support them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、RELOADのルーティング層の能力と機能を実装するために使用されるプロトコルの機能について説明し、その使用方法の概要を簡単に説明します。付録Aには、それらをサポートするために必要であろういくつかの代替設計とのトレードオフについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD&#39;s routing provides the following capabilities:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADのルーティングには、次の機能を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resource-based Routing: RELOAD supports routing messages based solely on the name of the resource. Such messages are delivered to a node that is responsible for that resource. Both structured and unstructured overlays are supported, so the route may not be deterministic for all Topology Plug-ins.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースベースのルーティング：RELOADは、リソースの名前のみに基づいてルーティングメッセージをサポートしています。このようなメッセージは、そのリソースを担当するノードに配信されます。ルートは、すべてのトポロジプラグインのための決定論的ではないかもしれないので、どちらも構造化および非構造化オーバーレイは、サポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Node-based Routing: RELOAD supports routing messages to a specific node in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードベースのルーティング：RELOADオーバーレイ内の特定のノードへのメッセージのルーティングをサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients: RELOAD supports requests from and to clients that do not participate in overlay routing. The clients are located via either of the mechanisms described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント：RELOADは、オーバーレイルーティングに参加していないクライアントからとへの要求をサポートしています。クライアントは、上述の機構のいずれかを介して配置されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NAT Traversal: RELOAD supports establishing and using connections between nodes separated by one or more NATs, including locating peers behind NATs for those overlays allowing/requiring it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NATトラバーサル：リロードが確立し、それを必要とする/許可これらのオーバーレイのためのNATの背後のピアを突き止めるなど、一つ以上のNATにより分離ノード間の接続を使用してサポート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Low State: RELOAD&#39;s routing algorithms do not require significant state (i.e., state linear or greater in the number of outstanding messages that have passed through it) to be stored on intermediate peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロー状態：リロードのルーティングアルゴリズムは、中間ピアに保存する（それを通過した未処理のメッセージの数、すなわち、状態の線形以上）有意な状態を必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Routability in Unstable Topologies: Overlay topology changes constantly in an overlay of moderate size due to the failure of individual nodes and links in the system. RELOAD&#39;s routing allows peers to reroute messages when a failure is detected, and replies can be returned to the requesting node as long as the peers that originally forwarded the successful request do not fail before the response is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不安定なトポロジでのルータビリティ：システム内の個々のノードやリンクの故障による適度なサイズのオーバーレイで常にオーバーレイトポロジの変更。 RELOADのルーティングは、障害が検出されたときにピアがメッセージを再ルーティングすることを可能にする、との回答はもともと、応答が返される前に失敗しない成功した要求を転送しピア限り、要求元のノードに戻すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD&#39;s routing utilizes three basic mechanisms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADのルーティングは、3つの基本的なメカニズムを利用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Destination Lists: While, in principle, it is possible to just inject a message into the overlay with a single Node-ID as the destination, RELOAD provides a source-routing capability in the form of &#34;Destination Lists&#34;. A Destination List provides a list of the nodes through which a message flows in order (i.e., it is loose source routed). The minimal Destination List contains just a single value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先リスト：、原理的には、それだけ先として単一ノードIDとオーバーレイにメッセージを注入することは可能であるが、リロードが「宛先リスト」の形でソースルーティング機能を提供します。宛先リストは、メッセージが順に流れるノード（すなわち、それがルーティングルーズソースである）のリストを提供します。最小限の宛先リストは、単に単一の値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Via Lists: In order to allow responses to follow the same path as requests, each message also contains a &#34;Via List&#34;, which is appended to by each node a message traverses. This Via List can then be inverted and used as a Destination List for the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リストを介し：応答が要求と同じ経路に従うことを可能にするために、各メッセージは、メッセージが通過する各ノードによって付加された「を介してリスト」が含ま。この経由リストは、その後反転して、応答の宛先リストとして使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RouteQuery: The RouteQuery method allows a node to query a peer for the next hop it will use to route a message. This method is useful for diagnostics and for iterative routing (see Section 6.4.2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RouteQuery：RouteQuery方法ノードがルートにメッセージを使用する次のホップのピアを照会することを可能にします。この方法は、診断のための反復ルーティングのために有用である（6.4.2.4項を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic routing mechanism that RELOAD uses is symmetric recursive. We will first describe symmetric recursive routing and then discuss its advantages in terms of the requirements discussed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードが使用する基本的なルーティングメカニズムは、対称再帰的です。まず、対称再帰ルーティングを説明した後、上述の要件の点でその利点について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Symmetric recursive routing requires that a request message follow a path through the overlay to the destination: each peer forwards the message closer to its destination. The return path of the response goes through the same nodes as the request (though it may also go through some new intermediate nodes due to topology changes). Note that a failure on the reverse path caused by a topology change after the request was sent will be handled by the end-to-end retransmission of the response as described in Section 6.2.1. For example, the following figure shows a message following a route from A to Z through B and X:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ピアは、近い目的地へメッセージを転送：対称再帰ルーティング要求メッセージは宛先へのオーバーレイを通る経路をたどることが必要です。 （それはまた、トポロジの変更に起因するいくつかの新しい中間ノードを経由するかもしれないが）、応答のリターンパスは、要求と同じノードを経由します。セクション6.2.1に記載したように、要求が送信された後、トポロジ変化による逆の経路上の障害が応答のエンド・ツー・エンドの再送によって処理されることに留意されたいです。たとえば、次の図は、BおよびXを介してAからZまでの経路を、次のメッセージを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   A         B         X         Z
   -------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ----------&gt;
   Dest=Z
            ----------&gt;
            Via=A
            Dest=Z
                      ----------&gt;
                      Via=A,B
                      Dest=Z
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      &lt;----------
                       Dest=X,B,A
            &lt;----------
               Dest=B,A
   &lt;----------
        Dest=A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this figure does not indicate whether A is a client or peer. A forwards its request to B, and the response is returned to A in the same manner regardless of A&#39;s role in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この図は、Aは、クライアントまたはピアであるかを示すものではありませんので注意してください。 Bへ転送し、その要求、および応答に関係なく、オーバーレイにおけるAの役割のと同じ方法で、Aに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This figure shows use of full Via Lists by intermediate peers B and X. However, if B and/or X are willing to store state, then they may elect to truncate the lists and save the truncated information internally using the transaction ID as a key to allow it to be retrieved later. Later, when the response message arrives, the transaction ID would be used to recover the truncated information and return the response message along the path from which the request arrived. This option requires a greater amount of state to be stored on intermediate peers, but saves a small amount of bandwidth and reduces the need for modifying the message en route. Selection of this mode of operation is a choice for the individual peer; the techniques are interoperable even on a single message. The figure below shows B using full Via Lists, but X truncating them to X1 and saving the state internally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この図は、Bおよび/またはXは、状態を保存するために喜んでいる場合は、その後、彼らはリストを切り捨てることを選ぶことができるし、キーとしてトランザクションIDを使用して、内部で切り捨てられた情報を保存し、中間ピアBおよびXで表示されますフル経由の使用を示しそれは、後で取得できるようにします。応答メッセージが到着したときに、後で、トランザクションIDは、切り捨てられた情報を回復し、要求が到着し、そこからパスに沿って応答メッセージを返すために使用されます。このオプションは、中間ピアに格納される状態のより多くの量を必要とするが、少量の帯域幅を節約し、途中でメッセージを修正するための必要性を低減します。この動作モードの選択は、個々のピアのための選択です。技術は、1つでもメッセージの相互運用が可能です。下の図は、フル経由リストを使用してBを示しているが、Xは、X1にそれらを切り捨て、内部状態を保存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   A         B         X         Z
   -------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ----------&gt;
   Dest=Z
            ----------&gt;
            Via=A
            Dest=Z
                      ----------&gt;
                      Via=X1
                      Dest=Z
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      &lt;----------
                        Dest=X,X1
              &lt;----------
                 Dest=B,A
   &lt;----------
        Dest=A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As before, when B receives the message, B creates a Via List consisting of [A]. However, instead of sending [A, B], X creates an opaque ID X1 which maps internally to [A, B] (perhaps by being an encryption of [A, B]) and then forwards to Z with only X1 as the Via List. When the response arrives at X, it maps X1 back to [A, B], then inverts it to produce the new Destination List [B, A], and finally routes it to B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bがメッセージを受信したときに前のように、Bは、ビアリスト[A]からなる生成します。しかし、代わりに[A、B]を送信する、Xは、ビアとしてのみX1とZに転送し、[A、B]（おそらく[A、B]の暗号化であることによる）の内部マッピング不透明IDのX1を作成リスト。応答がXに到着すると、それは、バック[A、B]にX1をマッピングし、新しい宛先リストを生成するために、それを反転させ、[B、A]、そして最終的にBへのルートを
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD also supports a basic iterative &#34;routing&#34; mode, in which the intermediate peers merely return a response indicating the next hop, but do not actually forward the message to that next hop themselves. Iterative routing is implemented using the RouteQuery method (see Section 6.4.2.4), which requests this behavior. Note that iterative routing is selected only by the initiating node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADは、中間ピアは単にネクストホップを示す応答を返しますが、実際に自分自身を次のようにメッセージを転送ホップしないで基本的な反復「ルーティング」モードをサポートしています。反復ルーティングは、この動作を要求RouteQuery法（セクション6.4.2.4を参照）を用いて実装されます。反復ルーティングのみ開始ノードによって選択されることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Connectivity Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 接続の管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to provide efficient routing, a peer needs to maintain a set of direct connections to other peers in the Overlay Instance. Due to the presence of NATs, these connections often cannot be formed directly. Instead, we use the Attach request to establish a connection. Attach uses Interactive Connectivity Establishment (ICE) [RFC5245] to establish the connection. It is assumed that the reader is familiar with ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
効率的なルーティングを提供するために、ピアは、オーバーレイ・インスタンス内の他のピアへの直接接続のセットを維持する必要があります。原因のNATが存在するため、これらの接続は、多くの場合、直接形成することはできません。代わりに、我々は、接続を確立するためにアタッチ要求を使用します。取り付けは、接続を確立するためにインタラクティブ接続確立（ICE）[RFC5245]を使用しています。読者はICEに精通していることを想定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Say that peer A wishes to form a direct connection to peer B, either to join the overlay or to add more connections in its Routing Table. It gathers ICE candidates and packages them up in an Attach request, which it sends to B through usual overlay routing procedures. B does its own candidate gathering and sends back a response with its candidates. A and B then do ICE connectivity checks on the candidate pairs. The result is a connection between A and B. At this point, A and B MAY send messages directly between themselves without going through other overlay peers. In other words, A and B are in each other&#39;s Connection Tables. They MAY then execute an Update process, resulting in additions to each other&#39;s Routing Tables, and may then become able to route messages through each other to other overlay nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのピアAがBをピアへの直接接続を形成するために、いずれかのオーバーレイに参加する、またはそのルーティングテーブル内の複数の接続を追加したいと言います。これは、ICE候補を収集し、それが通常のオーバーレイルーティング手続きを経てBに送信アタッチ要求、でそれらをパッケージ化します。 Bは、独自候補の収集を行い、その候補者との応答を返します。 AとBは、候補対上のICE接続性チェックを行います。結果はこの時点で、AとBの間の接続で、AとBは、他のオーバーレイ・ピアを経由せず、直接自分たちの間でメッセージを送信することができます。換言すれば、A及びBは、互いの接続テーブルです。そして、彼らは互いのルーティングテーブルへの追加をもたらす、更新処理を実行してもよいし、次いで他のオーバレイノードに互いに介してメッセージをルーティングできるようになることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two cases where Attach is not used. The first is when a peer is joining the overlay and is not connected to any peers. In order to support this case, a small number of bootstrap nodes typically need to be publicly accessible so that new peers can directly connect to them. Section 11 contains more detail on this. The second case is when a client connects to a peer at an arbitrary IP address, rather than to its responsible peer, as described in the second bullet point of Section 4.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用されていない取り付け2つのケースがあります。最初は、ピアがオーバレイに参加して、任意のピアに接続されていない場合です。新しいピアはそれらに直接接続することができるように、このケースをサポートするために、ブートストラップ・ノードの数が少ない一般的にパブリックにアクセスする必要があります。第11節は、この上の詳細が含まれています。セクション4.2.1の2番目の箇条書きに記載されているように、クライアントは、任意のIPアドレスのピアにはなく、その責任を負うピアに接続するときに、第2の場合です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, a peer needs to maintain connections to all of the peers near it in the Overlay Instance and to enough other peers to have efficient routing (the details on what &#34;enough&#34; and &#34;near&#34; mean depend on the specific overlay). If a peer cannot form a connection to some other peer, this is not necessarily a disaster; overlays can route correctly even without fully connected links. However, a peer needs to try to maintain the specified Routing Table defined by the Topology Plug-in algorithm and needs to form new connections if it detects that it has fewer direct connections than specified by the algorithm. This also implies that peers, in accordance with the Topology Plug-in algorithm, need to periodically verify that the connected peers are still alive and, if not, need to try to re-form the connections or form alternate ones. See Section 10.7.4.3 for an example on how a specific overlay algorithm implements these constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的には、ピアは、効率的なルーティング（「十分」と「近い」は、特定のオーバーレイに依存意味内容の詳細を）持っているオーバーレイインスタンスで十分な他のピアへのそれに近いピアのすべてへの接続を維持する必要があります。ピアが他のピアへの接続を形成することができない場合は、これは必ずしも災害ではありません。オーバーレイでも完全に接続されたリンクのない正しくルーティングすることができます。しかし、ピアはトポロジープラグインアルゴリズムによって定義され、それがアルゴリズムによって指定されたよりも少ないの直接接続を持っていることを検出した場合、新たな接続を形成する必要がある指定されたルーティングテーブルを維持しようとする必要があります。これはまた、ピアは、トポロジプラグインアルゴリズムに従って、定期的に接続されたピアがまだ生きていると、そうでない場合は、再形成接続しようとするか、別のものを形成する必要があることを確認する必要があることを意味します。特定のオーバーレイ・アルゴリズムは、これらの制約を実装方法の例については、セクション10.7.4.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Overlay Algorithm Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. オーバーレイアルゴリズムのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Topology Plug-in allows RELOAD to support a variety of overlay algorithms. This specification defines a DHT based on Chord, which is mandatory to implement, but the base RELOAD protocol is designed to support a variety of overlay algorithms. The information needed to implement this DHT is fully contained in this specification, but it is easier to understand if you are familiar with Chord-based [Chord] DHTs. A nice tutorial can be found at [wikiChord].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トポロジプラグインは、RELOADは、オーバーレイの様々なアルゴリズムをサポートすることができます。この仕様は、実装するために必須であるコードに基づいてDHTを定義するが、ベースリロードプロトコルは、オーバーレイ・アルゴリズムの様々なサポートするように設計されています。このDHTを実装するために必要な情報は完全にこの仕様に含まれているが、あなたがコードベースの[コード]のDHTに精通している場合は理解しやすいです。すてきなチュートリアルでは、[wikiChord]で見つけることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. Support for Pluggable Overlay Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. プラグイン可能なオーバーレイアルゴリズムのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD defines three methods for overlay maintenance: Join, Update, and Leave. However, the contents of these messages, when they are sent, and their precise semantics are specified by the actual overlay algorithm, which is specified by configuration for all nodes in the overlay and thus is known to nodes before they attempt to join the overlay. RELOAD merely provides a framework of commonly needed methods that provide uniformity of notation (and ease of debugging) for a variety of overlay algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加Update、および残す：RELOADはオーバーレイメンテナンスのための3つのメソッドを定義します。しかし、それらが送信され、その正確な意味は、オーバーレイ内のすべてのノードの設定によって指定されたので、彼らは、オーバーレイに参加する前のノードに知られている実際のオーバーレイアルゴリズムによって指定されているこれらのメッセージの内容。 RELOAD単にオーバーレイアルゴリズムの様々な表記（およびデバッグの容易さ）の均一性を提供する一般的必要なメソッドのフレームワークを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. Joining, Leaving, and Maintenance Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2.  、参加残し、およびメンテナンスの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a new peer wishes to join the Overlay Instance, it will need a Node-ID that it is allowed to use and a set of credentials which match that Node-ID. When an enrollment server is used, the Node-ID used is the one found in the certificate received from the enrollment server. The details of the joining procedure are defined by the overlay algorithm, but the general steps for joining an Overlay Instance are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいピアがオーバーレイインスタンスへの参加を希望する場合、使用を許可されているノードIDとそのノードIDと一致する資格情報のセットが必要になります。登録サーバを使用した場合、ノードID使用は、登録サーバから受信した証明書に見出されるものです。接合手順の詳細は、オーバーレイ・アルゴリズムによって定義されるが、オーバーレイインスタンスを結合するための一般的な手順がされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Form connections to some other peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oいくつかの他のピアへの接続を形成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Acquire the data values this peer is responsible for storing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oこのピアが格納するための責任があるデータ値を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Inform the other peers which were previously responsible for that data that this peer has taken over responsibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O以前にこのピアが責任を引き継いだそのデータを担当した他のピアに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first thing the peer needs to do is to form a connection to some bootstrap node. Because this is the first connection the peer makes, these nodes will need public IP addresses so that they can be connected to directly. Once a peer has connected to one or more bootstrap nodes, it can form connections in the usual way, by routing Attach messages through the overlay to other nodes. After a peer has connected to the overlay for the first time, it can cache the set of past adjacencies which have public IP addresses and can attempt to use them as future bootstrap nodes. Note that this requires some notion of which addresses are likely to be public as discussed in Section 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが行う必要がある最初の事はいくつかのブートストラップノードへの接続を形成することです。これは、ピアが行う最初の接続であるため、彼らは直接に接続することができるように、これらのノードは、パブリックIPアドレスが必要になります。ピアは、1つまたは複数のブートストラップノードに接続されたならば、それは他のノードへのオーバーレイを介してメッセージを添付ルーティングすることによって、通常の方法で接続を形成することができます。ピアが初めてのオーバーレイに接続した後、それはパブリックIPアドレスを持っているし、将来のブートストラップ・ノードとしてそれらを使用しようとすることができ、過去隣接のセットをキャッシュすることができます。これは、アドレスが9節で説明したように、公開する可能性があるそのうちのいくつかの概念が必要であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a peer has connected to a bootstrap node, it then needs to take up its appropriate place in the overlay. This requires two major operations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、ブートストラップノードに接続された後、それは、オーバーレイ内の適切な場所を取る必要があります。これは、2つの主要な操作を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Form connections to other peers in the overlay to populate its Routing Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそのルーティングテーブルを取り込むために、オーバーレイ内の他のピアへの接続を形成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get a copy of the data it is now responsible for storing, and assume responsibility for that data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは今で格納するための責任があるデータのコピーを取得し、そのデータの責任を負います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second operation is performed by contacting the Admitting Peer (AP), the node which is currently responsible for the relevant section of the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第2の動作を認めるピア（AP）、現在のオーバーレイの関連部分を担っているノードを接触させることによって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The details of this operation depend mostly on the overlay algorithm involved, but a typical case would be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この動作の詳細は、関連するオーバーレイ・アルゴリズムに主に依存するが、典型的なケースは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. JN sends a Join request to AP announcing its intention to join.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. JN参加する意向を発表APへの参加要求を送信します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. AP sends a Join response.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. APは、参加応答を送信します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. AP does a sequence of Stores to JN to give it the data it will need.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. APはそれにそれが必要とするデータを与えることJNに店舗のシーケンスを行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. AP does Updates to JN and to other peers to tell them about its own Routing Table. At this point, both JN and AP consider JN responsible for some section of the Overlay Instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. APは、自身のルーティングテーブルについて、それらを伝えるためにJNにし、他のピアにアップデートを行います。この時点で、JNとAPの両方がオーバーレイインスタンスのいくつかのセクションのためのJNが責任を考えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. JN makes its own connections to the appropriate peers in the Overlay Instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. JNは、オーバーレイのインスタンス内の適切なピアへの独自の接続を確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After this process completes, JN is a full member of the Overlay Instance and can process Store/Fetch requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロセスが完了した後、JNはオーバーレイインスタンスのフルメンバーであり、要求をフェッチ/ストアを処理することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the first node is a special case. When ordinary nodes cannot form connections to the bootstrap nodes, then they are not part of the overlay. However, the first node in the overlay can obviously not connect to other nodes. In order to support this case, potential first nodes (which can also initially serve as bootstrap nodes) need to somehow be instructed that they are the entire overlay, rather than part of an existing overlay (e.g., by comparing their IP address to the bootstrap IP addresses in the configuration file).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のノードが、特別な場合であることに留意されたいです。通常のノードは、ブートストラップ・ノードへの接続を形成することができない場合には、それらは、オーバーレイの一部ではありません。しかし、オーバーレイ内の最初のノードは、明らかに他のノードに接続できません。このケースをサポートするために、（また、最初にブートストラップノードを提供することができます）潜在的な最初のノードが何らかの形でブートストラップに自分のIPアドレスを比較することで、彼らは全体のオーバーレイではなく、既存のオーバーレイ（例えばの一部であることを指示する必要がありますコンフィギュレーションファイル内のIPアドレス）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that clients do not perform either of these operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはこれらのいずれかの操作を実行しないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. First-Time Setup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. 初回のセットアップ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Previous sections addressed how RELOAD works after a node has connected. This section provides an overview of how users get connected to the overlay for the first time. RELOAD is designed so that users can start with the name of the overlay they wish to join and perhaps an account name and password, and can leverage these into having a working peer with minimal user intervention. This helps avoid the problems that have been experienced with conventional SIP clients in which users need to manually configure a large number of settings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前のセクションでは、ノードが接続された後RELOADがどのように機能するかを扱いました。このセクションでは、ユーザーが最初にオーバーレイに接続されている取得する方法の概要を説明します。ユーザーは、おそらくアカウント名とパスワードを参加したいオーバーレイの名前で開始することができ、かつ最小限のユーザー介入で作業ピアを持つにこれらを活用することができるようにRELOADに設計されています。これにより、ユーザーは手動での設定の大規模な数を設定する必要のある従来のSIPクライアントで経験されてきた問題を回避するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. Initial Configuration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. 初期設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the first phase of the setup process, the user starts with the name of the overlay and uses it to download an initial set of overlay configuration parameters. The node does a DNS SRV [RFC2782] lookup on the overlay name to get the address of a configuration server. It can then connect to this server with HTTPS [RFC2818] to download a Configuration Document which contains the basic overlay configuration parameters as well as a set of bootstrap nodes which can be used to join the overlay. The details of the relationships between names in the HTTPS certificates and the overlay names are described in Section 11.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セットアッププロセスの最初の段階では、ユーザがオーバーレイの名前で始まり、オーバーレイの設定パラメータの初期セットをダウンロードするためにそれを使用しています。ノードは、コンフィギュレーションサーバのアドレスを取得するには、オーバーレイ名のDNS SRV [RFC2782]のルックアップを行います。その後、基本的なオーバーレイの設定パラメータと同様にオーバーレイを結合するために使用することができ、ブートストラップ・ノードのセットが含まれている構成ドキュメントをダウンロードするにはHTTPS [RFC2818]で、このサーバーに接続することができます。 HTTPS証明書とオーバーレイ名に名との間の関係の詳細については、セクション11.2で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a node already has the valid Configuration Document that it received by an out-of-band method, this step can be skipped. Note that this out-of-band method needs to provide authentication and integrity, because the Configuration Document contains the trust anchors used by the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードがすでにそれはアウトオブバンド方式で受信した有効な設定文書を持っている場合は、このステップをスキップすることができます。設定文書がオーバーレイで使用されるトラストアンカーが含まれているため、このアウトオブバンド方式は、認証と完全性を提供する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. Enrollment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. 入会
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the overlay is using centralized enrollment, then a user needs to acquire a certificate before joining the overlay. The certificate attests both to the user&#39;s name within the overlay and to the Node-IDs which they are permitted to operate. In this case, the Configuration Document will contain the address of an enrollment server which can be used to obtain such a certificate and will also contain the trust anchor, so this document must be retrieved securely (see Section 11.2). The enrollment server may (and probably will) require some sort of account name for the user and a password before issuing the certificate. The enrollment server&#39;s ability to ensure attackers cannot get a large number of certificates for the overlay is one of the cornerstones of RELOAD&#39;s security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイは、中央集中型の登録を使用している場合、ユーザーはオーバーレイに参加する前に、証明書を取得する必要があります。証明書は、オーバーレイ内およびそれらが動作することが許可されているノードIDにユーザー名の両方を証明しています。この場合、構成ドキュメントは、そのような証明書を取得するために使用することができ、また、トラストアンカーが含まれていますので、この文書は（11.2節を参照してください）しっかりと検索しなければならない登録サーバーのアドレスが含まれます。登録サーバは（おそらくます）ユーザーのアカウント名のいくつかの並べ替えや、証明書を発行する前にパスワードが必要な場合があります。オーバーレイのための多数の証明書を取得することはできません攻撃者を確保するための登録サーバーの能力はRELOADのセキュリティの基礎の一つです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. Diagnostics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. 診断
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Significant advice around managing a RELOAD overlay and extensions for diagnostics are described in [P2P-DIAGNOSTICS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
診断のためのRELOADオーバーレイと拡張を管理周りの重要なアドバイスは、[P2P-DIAGNOSTICS]で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Application Support Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.アプリケーションサポートの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD is not intended to be used alone, but rather as a substrate for other applications. These applications can use RELOAD for a variety of purposes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADはなく、むしろ、他のアプリケーションのための基質として、単独で使用されるものではありません。これらのアプリケーションは、様々な目的のためにRELOADを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To store data in the overlay and to retrieve data stored by other nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイ内のデータを格納するために、他のノードにより格納されたデータを取得するために、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As a discovery mechanism for services such as TURN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようTURNなどのサービスのための検出メカニズムとして、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To form direct connections which can be used to transmit application-level messages without using the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイを使用することなく、アプリケーションレベルのメッセージを送信するために使用することができる直接接続を形成するために、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides an overview of these services.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、これらのサービスの概要を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Data Storage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. データストレージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD provides operations to Store and Fetch data. Each location in the Overlay Instance is referenced by a Resource-ID. However, each location may contain data elements corresponding to multiple Kinds (e.g., certificate and SIP registration). Similarly, there may be multiple elements of a given Kind, as shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADは、データを格納し、取得するための操作を提供します。オーバーレイ・インスタンス内の各位置は、リソース-IDによって参照されます。しかし、各位置は、複数の種類（例えば、証明書及びSIP登録）に対応するデータ要素を含んでいてもよいです。以下に示すように、同様に、特定の種類の複数の要素が存在してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      +--------------------------------+
                      |            Resource-ID         |
                      |                                |
                      | +------------+  +------------+ |
                      | |   Kind 1   |  |   Kind 2   | |
                      | |            |  |            | |
                      | | +--------+ |  | +--------+ | |
                      | | | Value  | |  | | Value  | | |
                      | | +--------+ |  | +--------+ | |
                      | |            |  |            | |
                      | | +--------+ |  | +--------+ | |
                      | | | Value  | |  | | Value  | | |
                      | | +--------+ |  | +--------+ | |
                      | |            |  +------------+ |
                      | | +--------+ |                 |
                      | | | Value  | |                 |
                      | | +--------+ |                 |
                      | +------------+                 |
                      +--------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each Kind is identified by a Kind-ID, which is a code point either assigned by IANA or allocated out of a private range. As part of the Kind definition, protocol designers may define constraints (such as limits on size) on the values which may be stored. For many Kinds, the set may be restricted to a single value, while some sets may be allowed to contain multiple identical items, and others may have only unique items. Note that a Kind may be employed by multiple usages, and new usages are encouraged to use previously defined Kinds where possible. We define the following data models in this document, although other usages can define their own structures:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各種類は、種類-ID、コード点IANAによって割り当てられた、またはプライベート範囲の外に割り当てられているいずれかによって識別されます。種類の定義の一部として、プロトコル設計者は、記憶されてもよい値に（例えば、サイズの制限などの）制約を定義することができます。多くの種類のために、いくつかのセットは、複数の同一の項目を含有させることができるがセットには、単一の値に制限することができる、他のものは唯一のユニークなアイテムを持っていることがあります。種類が複数の用途で採用されてもよい、および新しい用途を可能な限り先に定義された種類を使用することが推奨されることに留意されたいです。他の用途は、独自の構造を定義することができますが、私たちは、この文書に以下のデータモデルを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
single value: There can be at most one item in the set, and any value overwrites the previous item.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一の値は：セットの中で最もつの項目が存在することができ、任意の値は、前の項目を上書きします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
array: Many values can be stored and addressed by a numeric index.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配列：多くの値が保存され、数値インデックスによって対処することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dictionary: The values stored are indexed by a key. Often, this key is one of the values from the certificate of the peer sending the Store request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
辞書：キーでインデックス化されて格納された値。多くの場合、このキーは、ストアリクエストを送信ピアの証明書のいずれかの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to protect stored data from tampering by other nodes, each stored value is individually digitally signed by the node which created it. When a value is retrieved, the digital signature can be verified to detect tampering. If the certificate used to verify the stored value signature expires, the value can no longer be retrieved (although it may not be immediately garbage collected by the storing node), and the creating node will need to store the value again if it desires that the stored value continue to be available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のノードによって改ざんから格納されたデータを保護するために、各格納された値は、個々にデジタルそれを作成したノードによって署名されます。値が取得されると、デジタル署名は、改ざんを検出するために検証することができます。証明書が格納された値の署名が期限切れに検証するために使用される場合（それは記憶ノードによって収集直ちにごみではないかもしれないが）、値はもはや取得することができない、そしてそれが望む場合に作成ノードは再び値を格納する必要があります保存された値が利用可能であり続けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. Storage Permissions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. ストレージの権限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A major issue in peer-to-peer storage networks is minimizing the burden of becoming a peer and, in particular, minimizing the amount of data which any peer needs to store for other nodes. RELOAD addresses this issue by allowing any given node to store data only at a small number of locations in the overlay, with those locations being determined by the node&#39;s certificate. When a peer uses a Store request to place data at a location authorized by its certificate, it signs that data with the private key that corresponds to its certificate. Then the peer responsible for storing the data is able to verify that the peer issuing the request is authorized to make that request. Each data Kind defines the exact rules for determining what certificate is appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアツーピアストレージネットワークにおける大きな課題は、ピアになる負担を最小限に抑え、特に、任意のピアが他のノードのために保存する必要があるデータの量を最小化されます。これらの位置は、ノードの証明書によって決定されると、のみオーバーレイ内の位置の小さな数のデータを格納するための任意のノードを可能にすることによって、アドレスにこの問題をリロード。ピアは、その証明書が承認した場所にデータを配置するストア要求を使用すると、その証明書に対応する秘密鍵を使用して、そのデータに署名します。そして、データを格納するための責任を負うピアが要求を発行するピアがその要求をするために許可されていることを確認することができます。各データ種類は、証明書が適切であるかを決定するための正確な規則を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most natural rule is that a certificate authorizes a user to store data keyed with their user name X. Thus, only a user with a certificate for &#34;alice@example.org&#34; could write to that location in the overlay (see Section 11.3). However, other usages can define any rules they choose, including publicly writable values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最も自然なルールは、証明書はこのように自分のユーザー名Xでキーデータを格納するためのユーザを許可、「alice@example.org」のための証明書を持つユーザーだけがオーバーレイでその場所に書き込むことができることである（11.3節を参照してください） 。しかし、他の用途には、公に書き込み可能な値を含めて、彼らが選択した任意のルールを定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The digital signature over the data serves two purposes. First, it allows the peer responsible for storing the data to verify that this Store is authorized. Second, it provides integrity for the data. The signature is saved along with the data value (or values) so that any reader can verify the integrity of the data. Of course, the responsible peer can &#34;lose&#34; the value, but it cannot undetectably modify it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データに対するデジタル署名は2つの目的を果たします。まず、それはこのお店が許可されていることを確認するために、データを格納するためのピアが責任を負うことができます。第二に、それはデータの整合性を提供します。任意のリーダがデータの整合性を検証することができるように、署名は、データ値（または値）と一緒に保存されています。もちろん、責任ピアは値を「失う」ことができますが、それは検出できない、それを変更することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size requirements of the data being stored in the overlay are variable. For instance, a SIP AOR and voicemail differ widely in the storage size. RELOAD leaves it to the usage and overlay configuration to limit size imbalances of various Kinds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイに格納されるデータのサイズ要件が可変です。例えば、SIP AORとボイスメールは、記憶サイズが大きく異なります。リロードは、各種のサイズの不均衡を制限するために使用し、オーバーレイの設定にそれを残します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2. Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2. レプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Replication in P2P overlays can be used to provide:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P2Pオーバーレイでのレプリケーションは、提供するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
persistence: if the responsible peer crashes and/or if the storing peer leaves the overlay
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
持続性：責任あるピアがクラッシュした場合、および/または保存するピアがオーバーレイを離れた場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
security: to guard against DoS attacks by the responsible peer or routing attacks to that responsible peer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティ：その責任を負うピアに責任ピアまたはルーティング攻撃によるDoS攻撃を防ぐために
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
load balancing: to balance the load of queries for popular resources
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロードバランシング：人気のリソースのためのクエリの負荷を分散します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A variety of schemes are used in P2P overlays to achieve some of these goals. Common techniques include replicating on neighbors of the responsible peer, randomly locating replicas around the overlay, and replicating along the path to the responsible peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
様々なスキームは、これらの目標の一部を達成するためにP2Pオーバーレイで使用されています。一般的な技術は、責任あるピアの隣人に複製ランダムオーバーレイの周りのレプリカを見つけ、そして責任あるピアへの経路に沿って複製します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The core RELOAD specification does not specify a particular replication strategy. Instead, the first level of replication strategies is determined by the overlay algorithm, which can base the replication strategy on its particular topology. For example, Chord places replicas on successor peers, which will take over responsibility if the responsible peer fails [Chord].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コアRELOAD仕様は、特定のレプリケーション戦略を指定していません。代わりに、複製戦略の最初のレベルは、その特定のトポロジーに複製戦略の基礎ができるオーバーレイアルゴリズムによって決定されます。例えば、コードは、責任ピアが[コード]失敗した場合に責任を引き継ぐ後継ピア、上のレプリカを配置します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If additional replication is needed, for example, if data persistence is particularly important for a particular usage, then that usage may specify additional replication, such as implementing random replications by inserting a different well-known constant into the Resource Name used to store each replicated copy of the resource. Such replication strategies can be added independently of the underlying algorithm, and their usage can be determined based on the needs of the particular usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加の複製が必要な場合、データの永続性は、特定の使用のために特に重要である場合、例えば、その使用は、そのような挿入することによってランダム複製を実現するように、追加の複製を指定することができるリソース名に定数が各複製を記憶するために使用される周知の異なりますリソースのコピー。このような複製戦略は根本的なアルゴリズムとは独立して追加することができ、その使用方法は、特定の使用の必要性に基づいて決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Usages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 用途
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By itself, the distributed storage layer provides only the infrastructure on which applications are built. In order to do anything useful, a usage needs to be defined. Each usage needs to specify several things:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単独で、分散ストレージ層は、アプリケーションが構築されているだけのインフラストラクチャを提供します。便利な何かをするためには、使用法を定義する必要があります。それぞれの使用量は、いくつかのものを指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Register Kind-ID code points for any Kinds that the usage defines (Section 14.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用定義（セクション14.6）、任意の種類のOレジスタ種類-IDコードポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Define the data structure for each of the Kinds (the value member in Section 7.2). If the data structure contains character strings, conversion rules between characters and the binary storage need to be specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O種類（セクション7.2の値部材）のそれぞれのためのデータ構造を定義します。データ構造は文字列が含まれている場合は、文字とバイナリストレージ間の変換規則を指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Define access control rules for each of the Kinds (Section 7.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O種類（7.3節）のそれぞれについて、アクセス制御ルールを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Define how the Resource Name is used to form the Resource-ID where each Kind is stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oリソース名は、それぞれの種類が格納されているリソース-IDを形成するために使用される方法を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Describe how values will be merged when a network partition is being healed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oネットワークパーティションが癒されているときの値をマージする方法を説明してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Kinds defined by a usage may also be applied to other usages. However, a need for different parameters, such as a different access control model, would imply the need to create a new Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用法によって定義種類は、他の用途にも適用することができます。しかし、必要性は、異なるアクセス制御モデルなど、さまざまなパラメータのために、新しい種類を作成する必要性を暗示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Service Discovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. サービス検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD does not currently define a generic service discovery algorithm as part of the base protocol, although a simplistic TURN-specific discovery mechanism is provided. A variety of service discovery algorithms can be implemented as extensions to the base protocol, such as the service discovery algorithm ReDIR [opendht-sigcomm05] and [REDIR-RELOAD].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単純TURN固有ディスカバリ機構が設けられているがリロードは、現在、基本プロトコルの一部として汎用サービス発見アルゴリズムを定義していません。サービス発見アルゴリズムの様々なそのようなサービス発見アルゴリズムREDIR [opendht-sigcomm05]および[REDIRリロード]などの基本プロトコルの拡張として実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Application Connectivity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. アプリケーション接続
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no requirement that a RELOAD Usage needs to use RELOAD&#39;s primitives for establishing its own communication if it already possesses its own means of establishing connections. For example, one could design a RELOAD-based resource discovery protocol which used HTTP to retrieve the actual data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADの使用は、それがすでに接続を確立する独自の手段を持っている場合は、独自の通信を確立するためRELOADのプリミティブを使用する必要がある必要はありません。例えば、一方が実際のデータを取得するためにHTTPを使用RELOADベースのリソースディスカバリプロトコルを設計することができました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For more common situations, however, it is the overlay itself -- rather than an external authority such as DNS -- which is used to establish a connection. RELOAD provides connectivity to applications using the AppAttach method. For example, if a P2PSIP node wishes to establish a SIP dialog with another P2PSIP node, it will use AppAttach to establish a direct connection with the other node. This new connection is separate from the peer protocol connection. It is a dedicated DTLS or TLS flow used only for the SIP dialog.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いうよりも、DNSなどの外部の権威 -   - 接続を確立するために使用される、より一般的な状況では、しかし、それはオーバーレイそのものです。 RELOADはAppAttachメソッドを使用してアプリケーションへの接続を提供します。 P2PSIPノードが別のP2PSIPノードとのSIPダイアログを確立することを希望する場合、それは他のノードとの直接接続を確立するためにAppAttachを使用します。この新しい接続はピアプロトコル接続から分離されています。これは、SIPダイアログのためにのみ使用される専用DTLSまたはTLSの流れです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Overlay Management Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.オーバーレイ管理プロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section defines the basic protocols used to create, maintain, and use the RELOAD overlay network. We start by defining the basic concept of how message destinations are interpreted when routing messages. We then describe the symmetric recursive routing model, which is RELOAD&#39;s default routing algorithm. Finally, we define the message structure and the messages used to join and maintain the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、作成、保守、およびRELOADのオーバーレイネットワークを使用するために使用される基本的なプロトコルを定義します。私たちは、メッセージをルーティングするときにメッセージの送信先がどのように解釈されるかの基本的な概念を定義することから始めます。私たちは、その後、RELOADのデフォルトのルーティングアルゴリズムである対称再帰ルーティングモデルを、説明します。最後に、私たちは、メッセージ構造およびオーバーレイに参加し、維持するために使用されるメッセージを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Message Receipt and Forwarding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. メッセージ受信および転送
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a node receives a message, it first examines the overlay, version, and other header fields to determine whether the message is one it can process. If any of these are incorrect, as defined in Section 6.3.2, it is an error and the message MUST be discarded. The peer SHOULD generate an appropriate error, but local policy can override this and cause the message to be silently dropped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードがメッセージを受信すると、最初のメッセージは、それが処理できるものであるかどうかを決定するためにオーバーレイ、バージョン、及び他のヘッダフィールドを検査します。これらのいずれかが正しくない場合は、6.3.2項で定義されるように、それは誤りであるとのメッセージを捨てなければなりません。ピアは、適切なエラーを生成する必要がありますが、ローカルポリシーは、このメソッドをオーバーライドし、静かに落下するメッセージを引き起こす可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the peer has determined that the message is correctly formatted (note that this does not include signature-checking on intermediate nodes as the message may be fragmented), it examines the first entry on the Destination List. There are three possible cases here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、メッセージが正しくフォーマットされていることを決定すると、宛先リストの最初のエントリを調べ、（メッセージが断片化されるように、これは中間ノードの署名チェックを含まないことに留意されたいです）。ここでは三つの可能なケースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The first entry on the Destination List is an ID for which the peer is responsible. A peer is always responsible for the wildcard Node-ID. Handling of this case is described in Section 6.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oを宛先リストの最初のエントリは、ピアが担当するIDです。ピアは、常にワイルドカードノードIDを担当しています。この場合の取扱いは、6.1.1項で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The first entry on the Destination List is an ID for which another peer is responsible. Handling of this case is described in Section 6.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oを宛先リストの最初のエントリは、別のピアが担当するIDです。この場合の取扱いは、セクション6.1.2に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The first entry on the Destination List is an opaque ID that is being used for Destination List compression. Handling of this case is described in Section 6.1.3. Note that opaque IDs can be distinguished from Node-IDs and Resource-IDs on the wire as described in Section 6.3.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oを送信先リスト上の最初のエントリは、宛先リスト圧縮のために使用されている不透明なIDです。この場合の取扱いは、6.1.3項で説明されています。セクション6.3.2.2に記載されるように、不透明なIDがワイヤにノードIDおよびリソース-IDを区別することができることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These cases are handled as discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの場合は、後述するように処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. Responsible ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. 責任ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the first entry on the Destination List is an ID for which the peer is responsible, there are several (mutually exclusive) subcases to consider.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先リストの最初のエントリは、ピアが担当するIDであれば、考慮すべきいくつかの（相互に排他的）サブケースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the entry is a Resource-ID, then it MUST be the only entry on the Destination List. If there are other entries, the message MUST be silently dropped. Otherwise, the message is destined for this node, so the node MUST verify the signature as described in Section 7.1 and MUST pass it to the upper layers. &#34;Upper layers&#34; is used here to mean the components above the &#34;Overlay Link Service Boundary&#34; line in the figure in Section 1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エントリは、リソース-IDである場合は、O、それは宛先リストの唯一のエントリでなければなりません。他のエントリが存在する場合、メッセージは静かに下げなければなりません。そうでない場合、メッセージはこのノードを宛先とするため、ノードは、セクション7.1で説明したように、署名を検証しなければならなくて、上位層に渡す必要があります。 「上位層は」1.2節では、図中の「オーバーレイリンクサービス境界」行以上の成分を意味するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the entry is a Node-ID which equals this node&#39;s Node-ID, then the message is destined for this node. If it is the only entry on the Destination List, the message is destined for this node and so the node passes it to the upper layers. Otherwise, the node removes the entry from the Destination List and repeats the routing process with the next entry on the Destination List. If the message is a response and list compression was used, then the node first modifies the Destination List to reinsert the saved state, e.g., by unpacking any opaque IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エントリは、このノードのノードIDに等しいノードIDである場合、O、メッセージは、このノードに宛てています。それは先リスト上の唯一のエントリがある場合は、メッセージがこのノードに宛てので、ノードが上位層に渡しています。そうしないと、ノードは宛先リストからエントリを削除し、宛先リストに次のエントリを持つルーティング処理を繰り返します。メッセージが応答して、リスト圧縮が使用された場合は、ノードは、最初の任意の不透明なIDをアンパックすることにより、例えば、保存された状態を再挿入するために宛先リストを変更します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the entry is the wildcard Node-ID (all &#34;1&#34;s), the message is destined for this node, and the node passes the message to the upper layers. A message with a wildcard Node-ID as its first entry is never forwarded; it is consumed locally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エントリは、ワイルドカードノードID（全て「1」）である場合、O、メッセージがこのノード宛の、及びノードが上位層にメッセージを渡しています。その最初のエントリとしてワイルドカードノードIDを持つメッセージが転送されることはありません。それがローカルに消費されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the entry is a Node-ID which is not equal to this node, then the node MUST drop the message silently unless the Node-ID corresponds to a node which is directly connected to this node (i.e., a client). In the latter case, the node MUST attempt to forward the message to the destination node as described in the next section (though this may fail for connectivity reasons, because the TTL has expired, or because of some other error.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エントリは、ノードIDこのノードに等しくない場合、ノードIDは、直接ノード（すなわち、クライアント）に接続されているノードに対応しない限り、O、ノードは静かにメッセージを削除する必要があります。後者の場合、ノードは、次のセクションで説明したように、宛先ノードにメッセージを転送しようとしなければならない（これが原因でいくつかの他のエラーのTTLが満了したため、接続の理由で失敗する、またはかもしれません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this process implies that in order to address a message to &#34;the peer that controls region X&#34;, a sender sends to Resource-ID X, not Node-ID X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロセスは、「領域Xを制御ピア」にメッセージをアドレス指定するために、送信者がリソースIDするX、ないノードID Xを送信することを意味することに注意してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. Other ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. 他のID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the first entry on the Destination List is neither an opaque ID nor an ID the peer is responsible for, then the peer MUST forward the message towards that entry. This means that it MUST select one of the peers to which it is connected and which is most likely to be responsible (according to the Topology Plug-in) for the first entry on the Destination List. For the CHORD-RELOAD topology, the routing to the most likely responsible node is explained in Section 10.3. If the first entry on the Destination List is in the peer&#39;s Connection Table, the peer MUST forward the message to that peer directly. Otherwise, the peer consults the Routing Table to forward the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先リストの最初のエントリは、不透明なIDやピアが担当するIDでもない場合、ピアは、そのエントリに向けてメッセージを転送しなければなりません。これは、それが接続されている送信先リストの最初のエントリのために（トポロジプラグインに応じて）責任がある可能性が最も高いであるピアの1つを選択しなければならないことを意味します。 CHORD-RELOADトポロジの場合は、最も可能性の高い責任のノードへのルーティングは、セクション10.3で説明されています。宛先リストの最初のエントリは、ピアの接続テーブル内にある場合、ピアは直接そのピアにメッセージを転送しなければなりません。そうでない場合、ピアは、メッセージを転送するルーティングテーブルを参照します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any intermediate peer which forwards a RELOAD request MUST ensure that if it receives a response to that message, the response can be routed back through the set of nodes through which the request passed. The peer selects one of these approaches:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロード要求を転送する任意の中間ピアは、それがそのメッセージに対する応答を受信した場合、応答は要求が通過したノードのセットを戻すことができることを確認しなければなりません。ピアは、これらのアプローチのいずれかを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The peer can add an entry to the Via List in the forwarding header that will enable it to determine the correct node. This is done by appending to the Via List the Node-ID of the node from which the request was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oピアは正しいノードを決定することを可能にする転送ヘッダINを介してリストにエントリを追加することができます。これは、経由リストへのリクエストを受信したノードのノードIDを追加することで行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The peer can keep per-transaction state which will allow it to determine the correct node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oピアは、それが正しいノードを決定することを可能にするごとトランザクション状態を維持することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example of the first strategy, consider an example with nodes A, B, C, D, and E. If node D receives a message from node C with Via List [A, B], then D would forward to the next node E with Via List [A, B, C]. Now, if E wants to respond to the message, it reverses the Via List to produce the Destination List, resulting in [D, C, B, A]. When D forwards the response to C, the Destination List will contain [C, B, A].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードDを経由リスト[A、B]と、ノードCからのメッセージを受信した場合、最初の戦略の一例としては、Dが次のノードに転送するであろう、ノードA、B、C、D、およびEを用いて例を考えます経由一覧[A、B、C]とE。 Eは、メッセージに応答したい場合さて、それは[D、C、B、A]が得られ、宛先リストを生成するために経由リストを反転させます。 DがCに応答を転送する場合、送信先リストは[C、B、A]を含有するであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example of the second strategy, if node D receives a message from node C with transaction ID X (as assigned by A) and Via List [A, B], it could store [X, C] in its state database and forward the message with the Via List unchanged. When D receives the response, it consults its state database for transaction ID X, determines that the request came from C, and forwards the response to C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードDは、トランザクションID X（Aによって割り当てられる）を介してリスト[A、B]と、ノードCからのメッセージを受信した場合に、第2の戦略の一例として、これは、その状態データベースと前方に[X、C]を記憶することができます経由リストとメッセージ変わりません。 Dは、応答を受信すると、それは、トランザクションID Xのためにその状態データベースを参照要求がCから来たと判断し、Cに応答を転送します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intermediate peers which modify the Via List are not required to simply add entries. The only requirement is that the peer MUST be able to reconstruct the correct Destination List on the return route. RELOAD provides explicit support for this functionality in the form of opaque IDs, which can replace any number of Via List entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
経由リストを変更する中間ピアは、単純にエントリを追加する必要はありません。唯一の要件は、ピアが復路上の正しい宛先リストを再構築することができなければならないということです。 RELOADは、経由リストの項目の任意の数を置き換えることができ、不透明のID、の形でこの機能を明示的にサポートを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For instance, in the above example, Node D might send E a Via List containing only the opaque ID I. E would then use the Destination List [D, I] to send its return message. When D processes this Destination List, it would detect that I is an opaque ID, recover the Via List [A, B, C], and reverse that to produce the correct Destination List [C, B, A] before sending it to C. This feature is called &#34;list compression&#34;. Possibilities for an opaque ID include a compressed and/or encrypted version of the original Via List and an index into a state database containing the original Via List, but the details are a local matter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、上記の例では、ノードDは、不透明なIDのI. Eを含む経由リストはそのリターン・メッセージを送信するために[私は、D]宛先リストを使用するEを送信することがあります。 Dは、この宛先リストを処理するとき、それは、私が不透明IDであることを検出経由リスト[A、B、C]を回復、及びCに送信する前に、正しい宛先リスト[C、B、A]を生成するためにその逆になります。この機能は、「リスト圧縮」と呼ばれています。不透明なIDの可能性は、元の経由リストの圧縮および/または暗号化されたバージョンとオリジナルの経由リストを含む状態データベースへのインデックスが含まれるが、詳細はローカルの問題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No matter what mechanism for storing Via List state is used, if an intermediate peer exits the overlay, then on the return trip the message cannot be forwarded and will be dropped. The ordinary timeout and retransmission mechanisms provide stability over this type of failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
中間ピアがメッセージを転送することはできません帰りに、その後、オーバーレイを終了し、削除されます場合はどんなに経由リストの状態を格納するためのどのようなメカニズムは、使用されません。通常、タイムアウトおよび再送信メカニズムは、このタイプの障害の上に安定性を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if an intermediate peer retains per-transaction state instead of modifying the Via List, it needs some mechanism for timing out that state; otherwise, its state database will grow without bound. Whatever algorithm is used, unless a FORWARD_CRITICAL forwarding option (Section 6.3.2.3) or an overlay configuration option explicitly indicates this state is not needed, the state MUST be maintained for at least the value of the overlay-reliability-timer configuration parameter and MAY be kept longer. Future extensions, such as [P2PSIP-RELAY], may define mechanisms for determining when this state does not need to be retained.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
中間ピアが経由リストを修正するのではなく、トランザクションごとの状態を保持している場合、それはその状態をタイミングするためのいくつかのメカニズムを必要とすることに注意してください。そうでない場合は、その状態データベースは無制限に大きくなります。 FORWARD_CRITICAL転送オプション（セクション6.3.2.3）またはオーバーレイの設定オプションが明示的状態は、少なくともオーバーレイ信頼タイマー設定パラメータの値もよく維持されなければならない、この状態が必要でないことを示さない限り、使用されるどのようなアルゴリズム長く保持すること。このような[P2PSIPリレー]などの将来の拡張は、この状態を保持する必要がない場合を決定するためのメカニズムを定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no requirement to ensure that a request issued after the receipt of a response follows the same path as the response. As a consequence, there is no requirement to use either of the mechanisms described above (Via List or state retention) when processing a response message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答の受領後に発行された要求は応答と同じ経路をたどることを確実にする必要はありません。その結果、応答メッセージを処理するとき（VIAリストまたは状態保持）上述したメカニズムのいずれかを使用する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node receiving a request from another node MUST ensure that any response to that request exits that node with a Destination List equal to the concatenation of the Node-ID of the node from which the request was received with the Via List in the original request. The intermediate node normally learns the Node-ID that the other node is using via an Attach, but a node using a certificate with a single Node-ID MAY elect not to send an Attach (see Section 4.2.1, bullet 2). If a node with a certificate with multiple Node-IDs attempts to route a message other than a Ping or Attach through a node without performing an Attach, the receiving node MUST reject the request with an Error_Forbidden error. The node MUST implement support for returning responses to a Ping or Attach request made by a Joining Node Attaching to its responsible peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のノードからの要求を受信したノードは、その要求に対する応答が要求元の要求のViaリストで受信されたノードのノードIDの連結に等しい宛先リストと、そのノードから出ることを確実にしなければなりません。中間ノードは、通常アタッチを介して他のノードが使用しているノードIDを学習するが、単一のノードIDと証明書を使用して、ノードが（、弾丸2セクション4.2.1を参照）を添付送信しないように選択することができます。複数のノードIDを持つ証明書を使用してノードをルートするには、ping以外のメッセージを試みるか、取り付け行うことなく、ノードを介して接続した場合、受信ノードはError_Forbiddenエラーで要求を拒絶しなければなりません。ノードがpingに応答を返すためのサポートを実装するか、その責任のピアへの接続、参加するノードからの要求を添付する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.3. Opaque ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.3. 不透明なID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the first entry on the Destination List is an opaque ID (e.g., a compressed Via List), the peer MUST replace the entry with the original Via List that it replaced and then re-examine the Destination List to determine which of the three cases in Section 6.1 now applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先リストの最初のエントリは、不透明なID（例えば、圧縮経由リスト）である場合、ピアは3例どれを決定するために再検討宛先リスト、それを交換することを本来の経由リストのエントリを交換しなければなりません。 6.1節で今適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Symmetric Recursive Routing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 対称再帰ルーティング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section defines RELOAD&#39;s Symmetric Recursive Routing algorithm, which is the default algorithm used by nodes to route messages through the overlay. All implementations MUST implement this routing algorithm. An overlay MAY be configured to use alternative routing algorithms, and alternative routing algorithms MAY be selected on a per-message basis. That is, a node in an overlay which supports Symmetric Recursive Routing and some other routing algorithm called XXX might use Symmetric Recursive Routing some of the time and XXX at other times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、オーバーレイを介してメッセージをルーティングするためにノードによって使用される既定のアルゴリズムであるリロードの対称再帰ルーティング・アルゴリズムを定義します。すべての実装は、このルーティングアルゴリズムを実装しなければなりません。オーバーレイは、代替ルーティングアルゴリズムを使用するように構成されてもよく、別のルーティングアルゴリズムは、メッセージ毎に選択することができます。つまり、対称再帰ルーティングをサポートし、オーバーレイ内のノードであるとXXXと呼ばれるいくつかの他のルーティングアルゴリズムは、他の回で対称再帰ルーティングの時間とXXXの一部を使用することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. Request Origination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. リクエストオリジ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to originate a message to a given Node-ID or Resource-ID, a node MUST construct an appropriate Destination List. The simplest such Destination List is a single entry containing the Node-ID or Resource-ID. The resulting message MUST be forwarded to its destination via the normal overlay routing mechanisms. The node MAY also construct a more complicated Destination List for source routing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所定のノードIDまたはリソース-IDにメッセージを発信するために、ノードは、適切な宛先のリストを構築しなければなりません。最も単純な宛先リストは、ノードIDまたはリソース-IDを含む単一のエントリです。得られたメッセージは、通常のオーバーレイルーティングメカニズムを介して宛先に転送されなければなりません。ノードは、ソースルーティングのためのより複雑な送信先リストを構築することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the message is constructed, the node sends the message to an adjacent peer. If the first entry on the Destination List is directly connected, then the message MUST be routed down that connection. Otherwise, the Topology Plug-in MUST be consulted to determine the appropriate next hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージが構築されると、ノードは、隣接ピアにメッセージを送信します。宛先リストの最初のエントリが直接接続されている場合は、そのメッセージは、その接続ダウンルーティングする必要があります。それ以外の場合は、トポロジプラグインは、適切な次のホップを決定するために相談しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parallel requests for a resource are a common solution to improve reliability in the face of churn or subversive peers. Parallel searches for usage-specified replicas are managed by the usage layer, for instance, by having the usage store data at multiple Resource-IDs, with the requesting node sending requests to each of those Resource-IDs. However, a single request MAY also be routed through multiple adjacent peers, even when they are known to be suboptimal, to improve reliability [vulnerabilities-acsac04]. Such parallel searches MAY be specified by the Topology Plug-in, in which case it would return multiple next hops and the request would be routed to all of them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースの並列要求が解約又は破壊仲間の顔の信頼性を向上させるための一般的なソリューションです。利用指定レプリカの並列検索は、例えば、それらのリソース-IDのそれぞれに要求を送信する要求ノードと、複数の資源のIDで利用ストアデータを有することにより、使用層によって管理されています。しかし、単一の要求は、[脆弱性-acsac04】信頼性を向上させるために、それらは準最適であることが知られている場合でも、複数の隣接ピアを介してルーティングすることができます。このような並列検索は、それが複数の次のホップを返すと、要求はそれらのすべてにルーティングされ、その場合には、トポロジプラグインで指定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because messages can be lost in transit through the overlay, RELOAD incorporates an end-to-end reliability mechanism. When an originating node transmits a request, it MUST set a timer to the current overlay-reliability-timer. If a response has not been received when the timer fires, the request MUST be retransmitted with the same transaction identifier. The request MAY be retransmitted up to 4 times, for a total of 5 messages. After the timer for the fifth transmission fires, the message MUST be considered to have failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージは、オーバーレイを通じて輸送中に失われる可能性があるため、RELOADは、エンドツーエンドの信頼性のメカニズムが組み込まれています。発信元ノードが要求を送信すると、それは現在のオーバーレイ信頼性タイマーにタイマーを設定しなければなりません。とき、タイマーが起動応答が受信されていない場合、要求は同じトランザクション識別子を再送信しなければなりません。要求は5つのメッセージの合計のために、4回まで再送信されることができます。第五の伝送火災のためのタイマーの後、メッセージが失敗したと考えなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the originating node will be doing both end-to-end and hop-by-hop retransmissions, the end-by-end retransmission procedure is not followed by intermediate nodes. They follow the hop-by-hop reliability procedure described in Section 6.6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
発信元ノードは、両方のエンド・ツー・エンドとホップバイホップ再送を行うことになるが、エンド・バイ・エンド再送手順は、中間ノードが続きません。彼らは、セクション6.6.3で説明したホップバイホップ信頼性の手順に従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above algorithm can result in multiple requests being delivered to a node. Receiving nodes MUST generate semantically equivalent responses to retransmissions of the same request (this can be determined by the transaction ID) if the request is received within the maximum request lifetime (15 seconds). For some requests (e.g., Fetch), this can be accomplished merely by processing the request again. For other requests (e.g., Store), it may be necessary to maintain state for the duration of the request lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記のアルゴリズムは、ノードに配信される複数の要求をもたらすことができます。受信ノードは、同じ要求の再送要求が最大リクエストライフタイム（15秒）内に受信された場合（これは、トランザクションIDによって決定することができる）と意味的に同等の応答を生成しなければなりません。いくつかの要求（例えば、フェッチ）のために、これは再び要求を処理するだけで達成することができます。他の要求（例えば、ストア）のために、要求寿命の期間の状態を維持する必要があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. Response Origination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. レスポンスオリジ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer sends a response to a request using this routing algorithm, it MUST construct the Destination List by reversing the order of the entries on the Via List. This has the result that the response traverses the same peers as the request traversed, except in reverse order (symmetric routing) and possibly with extra nodes (loose routing).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがこのルーティングアルゴリズムを使用して要求に対する応答を送信すると、それは経由リスト上のエントリの順序を逆にすることによって宛先リストを作成する必要があります。この応答は、逆の順序（対称ルーティング）およびおそらく余分なノードと（ルーズルーティング）を除いて、要求が横断同じピアを横断するという結果を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Message Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. メッセージ構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD is a message-oriented request/response protocol. The messages are encoded using binary fields. All integers are represented in network byte order. The general philosophy behind the design was to use Type, Length, Value (TLV) fields to allow for extensibility. However, for the parts of a structure that were required in all messages, we just define these in a fixed position, as adding a type and length for them is unnecessary and would only increase bandwidth and introduce new potential interoperability issues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードがメッセージ指向要求/応答プロトコルです。メッセージは、バイナリフィールドを使用してエンコードされています。すべての整数はネットワークバイトオーダーで表されます。デザインの背後にある一般的な哲学は、拡張性を可能にするタイプ、長さ、値（TLV）フィールドを使用することでした。しかし、すべてのメッセージに必要とされた構造の部品のために、私たちはこれらが彼らのためにタイプと長さを追加するなど、一定の位置に定義することは不要であり、唯一の帯域幅を増加し、新たな可能性、相互運用性の問題を導入します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each message has three parts, which are concatenated, as shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各メッセージは、以下に示すように、連結された3つの部分を有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-------------------------+
     |    Forwarding Header    |
     +-------------------------+
     |    Message Contents     |
     +-------------------------+
     |     Security Block      |
     +-------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of these parts are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにこれらの部品の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Forwarding Header: Each message has a generic header which is used to forward the message between peers and to its final destination. This header is the only information that an intermediate peer (i.e., one that is not the target of a message) needs to examine. Section 6.3.2 describes the format of this part.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送ヘッダ：各メッセージは、ピア間で、その最終的な宛先にメッセージを転送するために使用される一般的なヘッダを有しています。このヘッダは、中間ピア（すなわち、メッセージの対象ではないもの）を調べる必要がある唯一の情報です。 6.3.2項では、この部分の形式について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message Contents: The message being delivered between the peers. From the perspective of the forwarding layer, the contents are opaque; however, they are interpreted by the higher layers. Section 6.3.3 describes the format of this part.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ内容：メッセージは、ピア間で配信されます。転送レイヤの観点から、コンテンツは不透明です。しかし、彼らは、上位層によって解釈されます。 6.3.3項では、この部分の形式について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security Block: A security block containing certificates and a digital signature over the &#34;Message Contents&#34; section. Note that this signature can be computed without parsing the message contents. All messages MUST be signed by their originator. Section 6.3.4 describes the format of this part.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティブロック：「メッセージの内容」セクションの上に証明書とデジタル署名を含むセキュリティブロック。この署名は、メッセージの内容を解析することなく計算することができることに留意されたいです。すべてのメッセージは、その発信元によって署名されなければなりません。 6.3.4項では、この部分の形式について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. Presentation Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. プレゼンテーション言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The structures defined in this document are defined using a C-like syntax based on the presentation language used to define TLS [RFC5246]. Advantages of this style include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書で定義された構造は、TLS [RFC5246]を定義するために使用されるプレゼンテーション言語に基づいて、Cのような構文を使用して定義されています。このスタイルの利点は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is familiar enough that most readers can grasp it quickly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oほとんどの読者はすぐにそれを把握することができることを十分に熟知しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The ability to define nested structures allows a separation between high-level and low-level message structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネストされた構造を定義する能力oをハイレベルとローレベルのメッセージ構造との間の分離を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It has a straightforward wire encoding that allows quick implementation, but the structures can be comprehended without knowing the encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは迅速な実装を可能にする簡単なワイヤエンコーディングを持っていますが、構造は、エンコーディングを知らなくても把握することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is possible to mechanically compile encoders and decoders.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O機械的にエンコーダとデコーダをコンパイルすることが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several idiosyncrasies of this language are worth noting:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この言語のいくつかの特異性は注目に値します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All lengths are denoted in bytes, not objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oすべての長さはバイトではなく、オブジェクトで表されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Variable-length values are denoted like arrays, with angle brackets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O可変長値は角括弧で、アレイのように示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;select&#34; is used to indicate variant structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O「を選択し、」バリアントの構造を示すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For instance, &#34;uint16 array&lt;0..2^8-2&gt;;&#34; represents up to 254 bytes, which corresponds to up to 127 values of two bytes (16 bits) each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、 &#34;uint16の配列&lt;0..2 ^ 8-2&gt;;&#34; 2バイト（16ビット）毎の最大値127に相当する254のバイトまでを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A repetitive structure member shares a common notation with a member containing a variable-length block of data. The latter always starts with &#34;opaque&#34;, whereas the former does not. For instance, the following denotes a variable block of data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
繰り返し構造部材を共有データの可変長ブロックを含む部材と共通の表記法。前者はないのに対し、後者は常に、「不透明」で始まります。例えば、以下は、データの可変長ブロックを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
opaque data&lt;0..2^32-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
不透明なデータ&lt;0..2 ^ 32-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
whereas the following denotes a list of 0, 1, or more instances of the Name element:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、Name要素の0、1、または複数のインスタンスのリストを示し、一方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Name names&lt;0..2^32-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
名前に名前を付け、&lt;0..2 ^ 32-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.1. Common Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.1。共通の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides an introduction to the presentation language used throughout RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、RELOAD全体で使用されるプレゼンテーション言語を紹介します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An enum represents an enumerated type. The values associated with each possibility are represented in parentheses, and the maximum value is represented as a nameless value, for purposes of describing the width of the containing integral type. For instance, Boolean represents a true or false:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙型は、列挙型を表します。各可能性に関連する値は括弧内に表され、そして最大値を含む一体型の幅を説明するために、無名の値として表されます。例えば、ブールは、真または偽を表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         enum { false(0), true(1), (255) } Boolean;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A boolean value is either a 1 or a 0. The max value of 255 indicates that this is represented as a single byte on the wire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブール値は、255の最大値は、これは、ワイヤ上の単一バイトとして表されていることを示す1または0のいずれかです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NodeId, shown below, represents a single Node-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下に示すNODEIDは、単一のノードIDを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
typedef opaque NodeId[NodeIdLength];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
typedefの不透明NODEID [NodeIdLength]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A NodeId is a fixed-length structure represented as a series of bytes, with the most significant byte first. The length is set on a per-overlay basis within the range of 16-20 bytes (128 to 160 bits). (See Section 11.1 for how NodeIdLength is set.) Note that the use of &#34;typedef&#34; here is an extension to the TLS language, but its meaning should be relatively obvious. Also note that the [ size ] syntax defines a fixed-length element that does not include the length of the element in the on-the-wire encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NODEIDは、最上位バイトと、バイト列として表される固定長の構造です。長さは、16〜20バイト（128〜160ビット）の範囲内当たりオーバーレイに基づいて設定されます。 （NodeIdLengthの設定方法については、セクション11.1を参照してください。）「のtypedef」の使用は、ここでTLS言語への拡張であるが、その意味は、比較的明白でなければならないことに注意してください。また、[サイズ]構文はオン・ザ・ワイヤエンコーディングの要素の長さを含んでいない固定長の要素を定義することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ResourceId, shown below, represents a single Resource-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下に示すRESOURCEIDは、単一のリソース-IDを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
typedef opaque ResourceId&lt;0..2^8-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
typedefの不透明RESOURCEID &lt;0..2 ^ 8-1&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like a NodeId, a ResourceId is an opaque string of bytes, but unlike NodeIds, ResourceIds are variable length, up to 254 bytes (2040 bits) in length. On the wire, each ResourceId is preceded by a single length byte (allowing lengths up to 255 bytes). Thus, the 3-byte value &#34;FOO&#34; would be encoded as: 03 46 4f 4f. Note the &lt; range &gt; syntax defines a variable length element that includes the length of the element in the on-the-wire encoding. The number of bytes to encode the length on the wire is derived by range; i.e., it is the minimum number of bytes which can encode the largest range value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NODEIDように、RESOURCEIDバイトの不透明な文字列であるが、ノード識別子とは異なり、ResourceIdsは、長さが254バイト（2040ビット）まで、可変長です。ワイヤ上の、各RESOURCEIDは、（255バイトまでの長さを可能にする）単一の長さのバイトが先行します。 03 46 4F 4F：したがって、3バイトの値「FOO」はとして符号化されるであろう。 &lt;範囲&gt;構文がオン・ザ・ワイヤ符号化における要素の長さを含む可変長の要素を定義する注意。バイト数は、範囲によって導出されたワイヤ上の長さを符号化します。すなわち、それは、最大範囲値を符号化することができる最小バイト数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A more complicated example is IpAddressPort, which represents a network address and can be used to carry either an IPv6 or IPv4 address:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より複雑な例では、ネットワークアドレスを表すとIPv6又はIPv4アドレスのどちらかを運ぶために使用することができるIpAddressPort、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        enum { invalidAddressType(0), ipv4_address(1), ipv6_address(2),
             (255) } AddressType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          uint32                  addr;
          uint16                  port;
        } IPv4AddrPort;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          uint128                 addr;
          uint16                  port;
        } IPv6AddrPort;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          AddressType             type;
          uint8                   length;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
select (type) { case ipv4_address: IPv4AddrPort v4addr_port;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
（タイプ）{ケースipv4_address選択：IPv4AddrPortのv4addr_portと、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
case ipv6_address: IPv6AddrPort v6addr_port;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
ケースはipv6_address：IPv6AddrPortのv6addr_portを。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            /* This structure can be extended */
          };
        } IpAddressPort;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first two fields in the structure are the same no matter what kind of address is being represented:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造体の最初の2つのフィールドが表現されているアドレスの種類に関係なく、同じではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type: The type of address (IPv4 or IPv6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ：アドレスのタイプ（IPv4またはIPv6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length: The length of the rest of the structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ：構造体の残りの部分の長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By having the type and the length appear at the beginning of the structure regardless of the kind of address being represented, an implementation which does not understand new address type X can still parse the IpAddressPort field and then discard it if it is not needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプと長さを有することによりかかわらず、新しいアドレスタイプXはまだIpAddressPortフィールドを解析し、それが必要とされていない場合は、それを破棄することができます理解していない実装を表現しているアドレスの種類の構造の先頭に表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rest of the IpAddressPort structure is either an IPv4AddrPort or an IPv6AddrPort. Both of these simply consist of an address represented as an integer and a 16-bit port. As an example, here is the wire representation of the IPv4 address &#34;192.0.2.1&#34; with port &#34;6084&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IpAddressPort構造の残りの部分はIPv4AddrPortかIPv6AddrPortのいずれかです。これらの両方は、単に整数と16ビットポートとして表されるアドレスから成ります。一例として、ここではポート「6084」のIPv4アドレス「192.0.2.1」のワイヤ表現です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             01           ; type    = IPv4
             06           ; length  = 6
             c0 00 02 01  ; address = 192.0.2.1
             17 c4        ; port    = 6084
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless a given structure that uses a select explicitly allows for unknown types in the select, any unknown type SHOULD be treated as a parsing error, and the whole message SHOULD be discarded with no response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
選択を使用し、所与の構造が明示的に選択中の未知のタイプを可能にしない限り、任意の未知のタイプは、解析エラーとして扱われるべきであり、メッセージ全体が応答なしで廃棄されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. Forwarding Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. 転送ヘッダ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The forwarding header is defined as a ForwardingHeader structure, as shown below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下に示すように、転送ヘッダは、ForwardingHeader構造として定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          uint32             relo_token;
          uint32             overlay;
          uint16             configuration_sequence;
          uint8              version;
          uint8              ttl;
          uint32             fragment;
          uint32             length;
          uint64             transaction_id;
          uint32             max_response_length;
          uint16             via_list_length;
          uint16             destination_list_length;
          uint16             options_length;
          Destination        via_list[via_list_length];
          Destination        destination_list
                               [destination_list_length];
          ForwardingOption   options[options_length];
        } ForwardingHeader;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the structure are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
relo_token: The first four bytes identify this message as a RELOAD message. This field MUST contain the value 0xd2454c4f (the string &#34;RELO&#34; with the high bit of the first byte set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
relo_token：最初の4つのバイトは、リロードメッセージとしてメッセージを識別する。このフィールドには値0xd2454c4f（最初のバイトのセットの高ビットの文字列「RELO」）を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay: The 32-bit checksum/hash of the overlay being used. This MUST be formed by taking the lower 32 bits of the SHA-1 [RFC3174] hash of the overlay name. The purpose of this field is to allow nodes to participate in multiple overlays and to detect accidental misconfiguration. This is not a security-critical function. The overlay name MUST consist of a sequence of characters that would be allowable as a DNS name. Specifically, as it is used in a DNS lookup, it will need to be compliant with the grammar for the domain as specified in Section 2.3.1 of [RFC1035].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイ：オーバーレイの32ビットチェックサム/ハッシュが使用されています。これは、オーバーレイ名のSHA-1 [RFC3174]ハッシュの下位32ビットを取ることによって形成されなければなりません。このフィールドの目的は、ノードが複数のオーバーレイに参加すると、偶然の設定ミスを検出することができるようにすることです。これは、セキュリティ上重要な機能ではありません。オーバーレイ名がDNS名として許容だろう文字の並びで構成する必要があります。それはDNSルックアップで使用されるよう具体的には、[RFC1035]のセクション2.3.1で指定されたドメインの文法に準拠する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
configuration_sequence: The sequence number of the configuration file. See Section 6.3.2.1 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
configuration_sequence：設定ファイルのシーケンス番号。詳細については、6.3.2.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version: The version of the RELOAD protocol being used times 10. RELOAD version numbers are fixed-point decimal numbers between fixed-point integer between 0.1 and 25.4. This document describes version 1.0, with a value of 0x0a. (Note that versions used prior to the publication of this RFC used version number 0.1.) Nodes MUST reject messages with other versions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バージョン：リロードプロトコルのバージョンが回使用されている10.リロードバージョン番号0.1と25.4との間の固定小数点整数との間の固定小数点小数番号です。この文書では、0x0Aの値と、バージョン1.0について説明します。 （従来、このRFCの出版物に使用されるバージョンは、バージョン番号0.1を使用することに留意されたい。）ノードは、他のバージョンでメッセージを拒絶しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ttl: An 8-bit field indicating the number of iterations, or hops, a message can experience before it is discarded. The TTL (time-to-live) value MUST be decremented by one at every hop along the route the message traverses just before transmission. If a received message has a TTL of 0 and the message is not destined for the receiving node, then the message MUST NOT be propagated further, and an Error_TTL_Exceeded error should be generated. The initial value of the TTL SHOULD be 100 and MUST NOT exceed 100 unless defined otherwise by the overlay configuration. Implementations which receive messages with a TTL greater than the current value of initial-ttl (or the default of 100) MUST discard the message and send an Error_TTL_Exceeded error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TTL：反復、またはホップの数を示す8ビットのフィールドは、その前に体験することができ、メッセージは破棄されます。 TTL（生存時間）値は、メッセージが単に送信する前に横断する経路に沿ったすべてのホップに1ずつデクリメントされなければなりません。受信したメッセージが0のTTLを有し、メッセージが受信ノードに宛てていない場合、メッセージはさらに伝播してはいけません、そしてError_TTL_Exceededエラーが発生しなければなりません。 TTLの初期値は100であるべきであり、オーバーレイ構成によって特に定義されない限り、100を超えてはなりません。初期TTL（又は100のデフォルト）の現在の値よりも大きいTTLと共にメッセージを受信する実装は、メッセージを破棄してError_TTL_Exceededエラーを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment: This field is used to handle fragmentation. The high bit (0x80000000) MUST be set for historical reasons. If the next bit (0x40000000) is set to 1, it indicates that this is the last (or only) fragment. The next six bits (0x20000000 through 0x01000000) are reserved and SHOULD be set to zero. The remainder of the field is used to indicate the fragment offset; see Section 6.7 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグメント：このフィールドは、断片化を処理するために使用されます。高ビット（0×80000000）は、歴史的な理由のために設定しなければなりません。次のビット（0x40000000から）が1に設定されている場合、これが最後の（または唯一の）断片であることを示しています。次の6ビット（が0x01000000スルー0x20000000）が予約され、ゼロに設定されるべきです。フィールドの残りの部分は、フラグメントオフセットを示すために使用されます。詳細については、セクション6.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length: The count in bytes of the size of the message, including the header, after the eventual fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ：ヘッダを含むメッセージのサイズのバイトのカウント、最終的な断片化後。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
transaction_id: A unique 64-bit number that identifies this transaction and also allows receivers to disambiguate transactions which are otherwise identical. In order to provide a high probability that transaction IDs are unique, they MUST be randomly generated. Responses use the same transaction ID as the request to which they correspond. Transaction IDs are also used for fragment reassembly. See Section 6.7 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TRANSACTION_ID：このトランザクションを識別し、また、受信機が他の点では同一である取引を明確にすることを可能にする固有の64ビット数。トランザクションIDが一意であることを高い確率を提供するために、彼らはランダムに生成されなければなりません。応答は、彼らが対応する要求と同じトランザクションIDを使用します。トランザクションIDはまた、フラグメント再構成のために使用されています。詳細については、セクション6.7を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max_response_length: The maximum size in bytes of a response. This is used by requesting nodes to avoid receiving (unexpected) very large responses. If this value is non-zero, responding peers MUST check that any response would not exceed it and if so generate an Error_Incompatible_with_Overlay value. This value SHOULD be set to zero for responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max_response_length：応答のバイト単位の最大サイズ。これは、（予期しない）非常に大きな応答を受信しないようにするためにノードに要求することによって使用されています。この値がゼロ以外の場合は、応答ピアはそうError_Incompatible_with_Overlay値を生成する場合は任意の応答はそれを超えないことをチェックしなければなりません。この値は、応答のためにゼロに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
via_list_length: The length of the Via List in bytes. Note that in this field and the following two length fields, we depart from the usual variable-length convention of having the length immediately precede the value, in order to make it easier for hardware decoding engines to quickly determine the length of the header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
via_list_length：バイト単位経由リストの長さ。このフィールド次の2つの長さフィールドに、我々はそれが簡単にハードウェア復号化エンジンを迅速ヘッダの長さを決定するために作るためには、長さがすぐ値の前に有する通常の可変長規則から逸脱することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination_list_length: The length of the Destination List in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination_list_length：バイト単位の送信先リストの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
options_length: The length of the header options in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
options_length：バイトのヘッダオプションの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
via_list: The via_list contains the sequence of destinations through which the message has passed. The via_list starts out empty and grows as the message traverses each peer. In stateless cases, the previous hop that the message is from is appended to the Via List as specified in Section 6.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
via_list：via_listは、メッセージが通過した目的地の配列を含みます。 via_listは空から始まり、メッセージが各ピアを横断するように成長します。ステートレスな場合には、6.1.2項で指定されたメッセージは、経由リストに追加されたからである前のホップ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination_list: The destination_list contains a sequence of destinations through which the message should pass. The Destination List is constructed by the message originator. The first element on the Destination List is where the message goes next. Generally, the list shrinks as the message traverses each listed peer, though if list compression is used, this may not be true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination_list：destination_listは、メッセージが通過する必要があり、それを通して目的地の配列を含みます。宛先リストは、メッセージの発信者によって構成されています。メッセージは次の行くところ宛先リストの最初の要素があります。リスト圧縮が使用される場合、これは真ではないかもしれないけれども、メッセージは、リストされた各ピアを横断するように、一般的に、リストが収縮します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
options: Contains a series of ForwardingOption entries. See Section 6.3.2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプション：ForwardingOptionの一連のエントリが含まれています。 6.3.2.3項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.1. Processing Configuration Sequence Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.1。処理構成のシーケンス番号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to be part of the overlay, a node MUST have a copy of the overlay Configuration Document. In order to allow for configuration document changes, each version of the Configuration Document MUST contain a sequence number which MUST be monotonically increasing mod 65535. Because the sequence number may, in principle, wrap, greater than or less than are interpreted by modulo arithmetic as in TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイの一部であるために、ノードは、オーバーレイ設定文書のコピーが必要です。シーケンス番号は、原則的に包むことができるので、構成ドキュメントの変更を可能にするために、設定文書の各バージョンは、以上のようにモジュロ演算によって解釈されるよりも、単調MOD 65535を増加しなければならないシーケンス番号を含まなければなりませんTCPインチ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a destination node receives a request, it MUST check that the configuration_sequence field is equal to its own configuration sequence number. If they do not match, the node MUST generate an error, either Error_Config_Too_Old or Error_Config_Too_New. In addition, if the configuration file in the request is too old, the node MUST generate a ConfigUpdate message to update the requesting node. This allows new Configuration Documents to propagate quickly throughout the system. The one exception to this rule is that if the configuration_sequence field is equal to 65535 and the message type is ConfigUpdate, then the message MUST be accepted regardless of the receiving node&#39;s configuration sequence number. Since 65535 is a special value, peers sending a new configuration when the configuration sequence is currently 65534 MUST set the configuration sequence number to 0 when they send a new configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先ノードが要求を受信すると、configuration_sequenceフィールドは、独自の設定のシーケンス番号と等しいことをチェックしなければなりません。彼らが一致しない場合、ノードは、Error_Config_Too_OldまたはError_Config_Too_Newのいずれかを、エラーを発生させなければなりません。リクエストで設定ファイルが古すぎる場合また、ノードが要求ノードを更新するためにあるConfigUpdateメッセージを発生させなければなりません。これは、新しい構成文書がシステム全体に急速に伝播することができます。このルールの唯一の例外はconfiguration_sequenceフィールドが65535に等しく、メッセージの種類があるConfigUpdateである場合、メッセージは関係なく、受信ノードの構成シーケンス番号の受け入れなければならないことです。 65535は特別な値であるので、彼らは新しい構成を送信するときに、コンフィギュレーション・シーケンスは現在65534のときに新しい設定を送信するピアは0に設定シーケンス番号を設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.2. Destination and Via Lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.2。目的地や経由リスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Destination List and Via List are sequences of Destination values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先リストを介して一覧デスティネーション値の配列であります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum { invalidDestinationType(0), node(1), resource(2),
            opaque_id_type(3), /* 128-255 not allowed */ (255) }
          DestinationType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
select (destination_type) { case node: NodeId node_id;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
選択（destination_type）{ケースノード：NODEID NODE_ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
case resource: ResourceId resource_id;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ケースの資源：RESOURCEID RESOURCE_ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
case opaque_id_type: opaque opaque_id&lt;0..2^8-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ケースopaque_id_type：不透明opaque_id &lt;0..2 ^ 8-1&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* This structure may be extended with new types */
     } DestinationData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct {
        DestinationType         type;
        uint8                   length;
        DestinationData         destination_data;
     } Destination;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct {
        uint16               opaque_id; /* Top bit MUST be 1 */
     } Destination;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the destination structure is a 16-bit integer, then the first bit MUST be set to 1, and it MUST be treated as if it were a full structure with a DestinationType of opaque_id_type and an opaque_id that was 2 bytes long with the value of the 16-bit integer. If the destination structure starts with DestinationType, then the first bit MUST be set to 0, and the destination structure must use a TLV structure with the following contents:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先の構造は、16ビットの整数である場合、最初のビットが1に設定しなければなりません、そして、それはopaque_id_typeのおよびDestinationTypeの値と2バイト長であったopaque_idと完全構造であったかのように扱われなければなりません16ビット整数。先の構造は、およびDestinationTypeで始まる場合、最初のビットが0に設定しなければなりません、宛先構造は、次の内容でTLV構造を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The type of the DestinationData Payload Data Unit (PDU). It may be one of &#34;node&#34;, &#34;resource&#34;, or &#34;opaque_id_type&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DestinationDataペイロードデータユニット（PDU）のタイプを入力します。これは、「ノード」、「リソース」、または「opaque_id_type」のいずれであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length of the destination_data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さdestination_dataの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination_data The destination value itself, which is an encoded DestinationData structure that depends on the value of &#34;type&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「タイプ」の値に依存する符号化されたDestinationData構造である宛先値そのもの、destination_data。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the destination structure encodes a Type, Length, Value. The Length field specifies the length of the DestinationData values, which allows the addition of new DestinationTypes. It also allows an implementation which does not understand a given DestinationType to skip over it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先の構造は、タイプ、長さ、値をコード化することに留意されたいです。 Lengthフィールドは、新しいDestinationTypesの追加を可能にする、DestinationData値の長さを指定します。また、それをスキップするために与えられたおよびDestinationTypeを理解していない実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DestinationData can be one of three types:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DestinationDataは、3種類のいずれかになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
node A Node-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードIDをノード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
opaque A compressed list of Node-IDs and an eventual Resource-ID. Because this value has been compressed by one of the peers, it is meaningful only to that peer and cannot be decoded by other peers. Thus, it is represented as an opaque string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードIDの不透明圧縮リストと最終的な資源ID。この値は、ピアの1つによって圧縮されているため、それだけでそのピアに有意義であり、他のピアによって復号することができません。したがって、不透明な文字列として表現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource The Resource-ID of the resource which is desired. This type MUST appear only in the final location of a Destination List and MUST NOT appear in a Via List. It is meaningless to try to route through a resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所望されるリソースのリソース-IDリソース。このタイプは、唯一の宛先リストの最終的な場所に現れなければならないし、経由リストに現れてはいけません。リソースを経由するようにしようとすることは無意味です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible encoding of the 16-bit integer version as an opaque identifier is to encode an index into a Connection Table. To avoid misrouting responses in the event a response is delayed and the Connection Table entry has changed, the identifier SHOULD be split between an index and a generation counter for that index. When a Node first joins the overlay, the generation counters SHOULD be initialized to random values. An implementation MAY use 12 bits for the Connection Table index and 3 bits for the generation counter. (Note that this does not suggest a 4096-entry Connection Table for every peer, only the ability to encode for a larger Connection Table.) When a Connection Table slot is used for a new connection, the generation counter is incremented (with wrapping). Connection Table slots are used on a rotating basis to maximize the time interval between uses of the same slot for different connections. When routing a message to an entry in the Destination List encoding a Connection Table entry, the peer MUST confirm that the generation counter matches the current generation counter of that index before forwarding the message. If it does not match, the message MUST be silently dropped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明な識別子として16ビット整数バージョンの一つの可能​​な符号化は、接続テーブルへのインデックスを符号化することです。応答が遅延され、接続テーブルエントリが変更された場合にmisrouting応答を回避するために、識別子は、そのインデックスのインデックスと生成カウンタ間で分割されるべきです。ノードは最初のオーバーレイに参加すると、生成カウンタは、ランダムな値に初期化する必要があります。実装は、世代カウンタの接続テーブルインデックスの12ビットと3ビットを使用するかもしれません。接続テーブルスロットが新しい接続に使用されている場合（これは、すべてのピアの大きい接続テーブルをコードする唯一の能力を4096エントリ接続テーブルを示唆していないことに留意されたい。）、世代カウンタが（ラップで）増分されます。接続テーブルスロットは、異なる接続のために同じスロットの使用の間の時間間隔を最大にするために回転的に使用されます。接続テーブルエントリをコードする送信先リストのエントリにメッセージをルーティングする場合、ピアは、世代カウンタがメッセージを転送する前にそのインデックスの現在の世代カウンターと一致することを確認しなければなりません。それが一致しない場合、メッセージは静かに下げなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.3. Forwarding Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.3。転送オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Forwarding header can be extended with forwarding header options, which are a series of ForwardingOption structures:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送ヘッダはForwardingOption構造のシリーズである転送ヘッダ・オプションと拡張することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    enum { invalidForwardingOptionType(0), (255) }
      ForwardingOptionType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
      ForwardingOptionType      type;
      uint8                     flags;
      uint16                    length;
      select (type) {
            /* This type may be extended */
      };
    } ForwardingOption;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ForwardingOption consists of the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ForwardingOptionは、以下の値で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The type of the option. This structure allows for unknown options types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションの種類を入力します。この構造は、未知のオプションタイプが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flags Three flags are defined: FORWARD_CRITICAL(0x01), DESTINATION_CRITICAL(0x02), and RESPONSE_COPY(0x04). These flags MUST NOT be set in a response. If the FORWARD_CRITICAL flag is set, any peer that would forward the message but does not understand this option MUST reject the request with an Error_Unsupported_Forwarding_Option error response. If the DESTINATION_CRITICAL flag is set, any node that generates a response to the message but does not understand the forwarding option MUST reject the request with an Error_Unsupported_Forwarding_Option error response. If the RESPONSE_COPY flag is set, any node generating a response MUST copy the option from the request to the response except that the RESPONSE_COPY, FORWARD_CRITICAL, and DESTINATION_CRITICAL flags MUST be cleared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フラグ3つのフラグが定義されています。FORWARD_CRITICAL（0x01の）、DESTINATION_CRITICAL（0×02）、及びRESPONSE_COPY（0×04）。これらのフラグは対応して設定してはいけません。 FORWARD_CRITICALフラグが設定されている場合は、メッセージを転送しますが、このオプションを理解していない任意のピアはError_Unsupported_Forwarding_Optionエラー応答で要求を拒絶しなければなりません。 DESTINATION_CRITICALフラグが設定されている場合、メッセージへの応答を生成するが、転送オプションを理解していない任意のノードがError_Unsupported_Forwarding_Optionエラー応答で要求を拒絶しなければなりません。 RESPONSE_COPYフラグが設定されている場合、応答を生成する任意のノードは、リクエストからRESPONSE_COPY、FORWARD_CRITICAL、及びDESTINATION_CRITICALフラグがクリアされなければならないことを除いて応答するためのオプションをコピーする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length of the rest of the structure. Note that a 0 length may be reasonable if the mere presence of the option is meaningful and no value is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長構造の残りの部分の長さ。オプションの単なる存在は有意義であり、値が必要とされない場合は0の長さが妥当であってもよいことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
option The option value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションオプションの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3. Message Contents Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3. メッセージ内容のフォーマット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second major part of a RELOAD message is the contents part, which is defined by MessageContents:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードメッセージの第二の主要な部分はMessageContentsによって定義されるコンテンツの一部です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { invalidMessageExtensionType(0),
          (2^16-1) } MessageExtensionType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
     MessageExtensionType  type;
     Boolean               critical;
     opaque                extension_contents&lt;0..2^32-1&gt;;
   } MessageExtension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
     uint16                 message_code;
     opaque                 message_body&lt;0..2^32-1&gt;;
     MessageExtension       extensions&lt;0..2^32-1&gt;;
   } MessageContents;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにこの構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
message_code This indicates the message that is being sent. The code space is broken up as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、送信されるメッセージを示しmessage_codeに。次のようにコードスペースを分割されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x0 Invalid Message Code. This code will never be assigned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x0の無効なメッセージコード。このコードは、割り当てられたことはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x1 .. 0x7FFF Requests and responses. These code points are always paired, with requests being an odd value and the corresponding response being the request code plus 1. Thus, &#34;probe_request&#34; (the Probe request) has the value 1 and &#34;probe_answer&#34; (the Probe response) has the value 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x1の... 0x7FFFの要求と応答。これらのコードポイントは常に要求が奇数値であると、対応する応答がこのよう要求コード1を加えた状態で、対になっている、「プローブリクエスト」（プローブリクエスト）が値1を有し、「probe_answer」（プローブ応答）の値を有します2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x8000 .. 0xFFFE Reserved
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x8000の.. 0xFFFEという予約
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0xFFFF Error
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
エラーが0xFFFF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The message codes are defined in Section 14.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
メッセージコードは、セクション14.8で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
message_body The message body itself, represented as a variable-length string of bytes. The bytes themselves are dependent on the code value. See the sections describing the various RELOAD methods (Join, Update, Attach, Store, Fetch, etc.) for the definitions of the payload contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バイトの可変長文字列として表され、メッセージ本体自体を、MESSAGE_BODY。バイト自体はコード値に依存しています。ペイロードの内容の定義について（など、フェッチ、アタッチ、ストアを更新しよう）、各種RELOAD方法を記述したセクションを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extensions Extensions to the message. Currently no extensions are defined, but new extensions can be defined by the process described in Section 14.14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージの拡張機能拡張機能。現在のところ、拡張が定義されていないが、新しい拡張機能は、セクション14.14に記載の方法で定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All extensions have the following form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての拡張機能は次の形式を持っています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The extension type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張タイプを入力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
critical Whether this extension needs to be understood in order to process the message. If critical = True and the recipient does not understand the message, it MUST generate an Error_Unknown_Extension error. If critical = False, the recipient MAY choose to process the message even if it does not understand the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この拡張機能は、メッセージを処理するために理解する必要があるかどうかを重要。 =重要な真と受信者がメッセージを理解していない場合、それはError_Unknown_Extensionエラーを発生させなければなりません。重要= Falseの場合、受信者は、それが拡張を理解していない場合でも、メッセージを処理するために選ぶかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extension_contents The contents of the extension (which are extension dependent).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（拡張依存している）拡張の内容をextension_contents。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The subsections 6.4.2, 6.5, and 7 describe structures that are inserted inside the message_body member, depending on the value of the message_code value. For example, a message_code value of join_req means that the structure named JoinReq is inserted inside message_body. This document does not contain a mapping between message_code values and structure names, as the conversion between the two is obvious.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブセクション6.4.2、6.5、および7はmessage_codeに値の値に応じMESSAGE_BODY部材の内部に挿入される構造を記述する。例えば、join_reqのmessage_codeに値がJoinReq命名構造がMESSAGE_BODYの内側に挿入されることを意味します。両者の間の変換は明らかなようにこの文書は、message_codeに値と構造体名の間のマッピングが含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, this document uses the name of the structure without the &#34;Req&#34; or &#34;Ans&#34; suffix to mean the execution of a transaction consisting of the matching request and answer. For example, when the text says &#34;perform an Attach&#34;, it must be understood as performing a transaction composed of an AttachReq and an AttachAns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、このドキュメントは、マッチング要求と回答からなるトランザクションの実行を意味する「必須」または「答」接尾辞なしで構造体の名前を使用しています。たとえば、テキストは言うとき、それはAttachReqとAttachAnsで構成されるトランザクションを実行するものとして理解されなければならない、「アタッチを実行」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3.1. Response Codes and Response Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3.1。レスポンスコードとレスポンスのエラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node processing a request MUST return its status in the message_code field. If the request was a success, then the message code MUST be set to the response code that matches the request (i.e., the next code up). The response payload is then as defined in the request/response descriptions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求を処理ノードはmessage_codeにフィールドにそのステータスを返さなければなりません。リクエストが成功した場合は、メッセージコードは、要求（すなわち、次のコードまで）と一致する応答コードに設定しなければなりません。要求/応答記述で定義された応答ペイロードは次にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the request has failed, then the message code MUST be set to 0xffff (error) and the payload MUST be an error_response message, as shown below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求が失敗した場合、メッセージコードが0xffffの（エラー）に設定しなければならなくて、以下に示すように、ペイロードは、error_responseメッセージでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the message code is 0xFFFF, the payload MUST be an ErrorResponse:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージコードが0xFFFFである場合、ペイロードははErrorResponseなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         public struct {
           uint16             error_code;
           opaque             error_info&lt;0..2^16-1&gt;;
         } ErrorResponse;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにこの構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
error_code A numeric error code indicating the error that occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
発生したエラーを示す数値エラーコードをERROR_CODE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
error_info An optional arbitrary byte string. Unless otherwise specified, this will be a UTF-8 text string that provides further information about what went wrong. Developers are encouraged to include enough diagnostic information to be useful in error_info. The specific text to be used and any relevant language or encoding thereof is left to the implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションの任意のバイトの文字列をERROR_INFO。特に指定しない限り、これは何が悪かったのかについての更なる情報を提供してUTF-8のテキスト文字列になります。開発者は、ERROR_INFOに有用であることが十分な診断情報を含めることをお勧めします。使用する特定のテキストおよび任意の関連する言語またはそのコードは、実装に委ねられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following error code values are defined. The numeric values for these are defined in Section 14.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のエラーコード値が定義されています。これらの数値の値は、セクション14.9で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Forbidden The requesting node does not have permission to make this request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Forbidden要求ノードは、この要求をする権限がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Not_Found The resource or node cannot be found or does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERROR_NOT_FOUNDリソースまたはノードが見つからないか、存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Request_Timeout A response to the request has not been received in a suitable amount of time. The requesting node MAY resend the request at a later time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求に対する応答Error_Request_Timeout時間の適切な量で受信されていません。要求ノードは、後で要求を再送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Data_Too_Old A store cannot be completed because the storage_time precedes the existing value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
storage_timeは、既存の値の前にあるため店を完了することができませんError_Data_Too_Old。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Data_Too_Large A store cannot be completed because the requested object exceeds the size limits for that Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求されたオブジェクトは、その種のサイズ制限を超えているためError_Data_Too_Largeストアが完了することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Generation_Counter_Too_Low A store cannot be completed because the generation counter precedes the existing value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生成カウンタは、既存の値の前にあるためError_Generation_Counter_Too_Lowストアが完了することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Incompatible_with_Overlay A peer receiving the request is using a different overlay, overlay algorithm, or hash algorithm, or some other parameter that is inconsistent with the overlay configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求を受信Error_Incompatible_with_Overlayピアは異なるオーバーレイ、オーバーレイアルゴリズムまたはハッシュアルゴリズム、またはオーバーレイの設定と矛盾しているいくつかの他のパラメータを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Unsupported_Forwarding_Option A node received the request with a forwarding options flagged as critical, but the node does not support this option. See Section 6.3.2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Unsupported_Forwarding_Optionノードは、重要としてフラグ付け転送オプションで要求を受けたが、ノードは、このオプションをサポートしていません。 6.3.2.3項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_TTL_Exceeded A peer received the request in which the TTL was decremented to zero. See Section 6.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_TTL_Exceededピアは、TTLがゼロにデクリメントされた要求を受信しました。 6.3.2項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Message_Too_Large A peer received a request that was too large. See Section 6.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Message_Too_Largeピアが大きすぎたリクエストを受けました。 6.6節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Response_Too_Large A node would have generated a response that is too large per the max_response_length field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Response_Too_Largeノードはmax_response_lengthフィールドごとに大きすぎる応答を生成しているだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Config_Too_Old A destination node received a request with a configuration sequence that is too old. See Section 6.3.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先ノードが古すぎる設定シーケンスで要求を受けError_Config_Too_Old。 6.3.2.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Config_Too_New A destination node received a request with a configuration sequence that is too new. See Section 6.3.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Config_Too_New宛先ノードが新しすぎる設定シーケンスで要求を受信しました。 6.3.2.1項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Unknown_Kind A destination peer received a request with an unknown Kind-ID. See Section 7.4.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Unknown_Kind宛先ピアは、未知の種類-IDで要求を受信しました。セクション7.4.1.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_In_Progress An Attach to this peer is already in progress. See Section 6.5.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_In_Progress Anがこのピアにアタッチすでに進行中です。 6.5.1.2項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Unknown_Extension A destination node received a request with an unknown extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Unknown_Extension宛先ノードは、未知の拡張子を持つ要求を受信しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Invalid_Message Something about this message is invalid, but it does not fit the other error codes. When this message is sent, implementations SHOULD provide some meaningful description in error_info to aid in debugging.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージに関するError_Invalid_Messageの何かが無効であるが、それは他のエラーコードが適合しません。このメッセージが送信されると、実装は、デバッグを支援するためにERROR_INFOにいくつかの意味のある説明を提供すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Exp_A For the purposes of experimentation. It is not meant for vendor-specific use of any sort and MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実験の目的のためにError_Exp_A。これは、あらゆる種類のベンダー固有の使用のために意図されていないと業務展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Exp_B For the purposes of experimentation. It is not meant for vendor-specific use of any sort and MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実験の目的のためにError_Exp_B。これは、あらゆる種類のベンダー固有の使用のために意図されていないと業務展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.4. Security Block
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.4. セキュリティブロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third part of a RELOAD message is the security block. The security block is represented by a SecurityBlock structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードメッセージの第3の部分は、セキュリティブロックです。セキュリティブロックはSecurityBlock構造によって表されます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
      CertificateType     type;   // From RFC 6091
      opaque              certificate&lt;0..2^16-1&gt;;
   } GenericCertificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
      GenericCertificate certificates&lt;0..2^16-1&gt;;
      Signature          signature;
   } SecurityBlock;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificates A bucket of certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書証明書のバケツ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature A signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名署名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificates bucket SHOULD contain all the certificates necessary to verify every signature in both the message and the internal message objects, except for those certificates in a root-cert element of the current configuration file. This is the only location in the message which contains certificates, thus allowing only a single copy of each certificate to be sent. In systems that have an alternative certificate distribution mechanism, some certificates MAY be omitted. However, unless an alternative mechanism for immediately generating certificates, such as shared secret security (Section 13.4) is used, implementers MUST include all referenced certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書のバケットは、現在の構成ファイルのルート証明書の要素にこれらの証明書を除き、メッセージおよび内部メッセージオブジェクトの両方のすべての署名を検証するために必要なすべての証明書を、含むべきです。これにより、各証明書の単一のコピーが送信されることを可能にする、証明書を含むメッセージの唯一の場所です。代替証明書配布メカニズムを持っているシステムでは、いくつかの証明書は省略されるかもしれません。そのような共有秘密セキュリティ（セクション13.4）として直ちに発生証明書のための別の機構が使用されていない限りしかし、実装者は、すべての参照証明書を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE TO IMPLEMENTERS: This requirement implies that a peer storing data is obligated to retain certificates for the data that it holds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装者への注意：この要件は、ピア格納したデータは、それが保持するデータの証明書を保持する義務があることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each certificate is represented by a GenericCertificate structure, which has the following contents:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各証明書は以下の内容を有するGenericCertificate構造、によって表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The type of the certificate, as defined in [RFC6091]. Only the use of X.509 certificates is defined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6091]で定義されるように、証明書の種類を入力します。 X.509証明書の使用は、本文書で定義されているだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate The encoded version of the certificate. For X.509 certificates, it is the Distinguished Encoding Rules (DER) form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書証明書の符号化されたバージョン。 X.509証明書の場合は、識別符号化規則（DER）の形です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The signature is computed over the payload and parts of the forwarding header. In case of a Store, the payload MUST contain an additional signature computed as described in Section 7.1. All signatures MUST be formatted using the Signature element. This element is also used in other contexts where signatures are needed. The input structure to the signature computation MAY vary depending on the data element being signed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名は、ペイロードと転送ヘッダの部分にわたって計算されます。店の場合には、ペイロードは、セクション7.1で説明したように計算された追加の署名を含まなければなりません。すべての署名は、署名要素を使用してフォーマットされなければなりません。この要素はまた、署名が必要とされている他の文脈で使用されています。署名計算への入力構造は、署名されるデータ要素に依存して変化し得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     enum { invalidSignerIdentityType(0),
            cert_hash(1), cert_hash_node_id(2),
            none(3)
            (255) } SignerIdentityType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct {
       select (identity_type) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         case cert_hash;
           HashAlgorithm      hash_alg;              // From TLS
           opaque             certificate_hash&lt;0..2^8-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
case cert_hash_node_id: HashAlgorithm hash_alg; // From TLS opaque certificate_node_id_hash&lt;0..2^8-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
ケースcert_hash_node_id：HashAlgorithmのhash_alg。 // TLS不透明certificate_node_id_hashから&lt;0..2 ^ 8-1&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         case none:
           /* empty */
         /* This structure may be extended with new types if necessary*/
       };
     } SignerIdentityValue;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct {
       SignerIdentityType     identity_type;
       uint16                 length;
       SignerIdentityValue    identity[SignerIdentity.length];
     } SignerIdentity;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct {
        SignatureAndHashAlgorithm     algorithm;   // From TLS
        SignerIdentity                identity;
        opaque                        signature_value&lt;0..2^16-1&gt;;
     } Signature;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Signature construct contains the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シグネチャー構築物は、以下の値が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
algorithm The signature algorithm in use. The algorithm definitions are found in the IANA TLS SignatureAlgorithm and HashAlgorithm registries. All implementations MUST support RSASSA-PKCS1-v1_5 [RFC3447] signatures with SHA-256 hashes [RFC6234].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用中の署名アルゴリズムをアルゴリズムです。アルゴリズムの定義は、IANA TLSのsignatureAlgorithmとHashAlgorithmレジストリで発見されています。すべての実装は、SHA-256ハッシュ[RFC6234]とRSASSA-PKCS1-v1_5の[RFC3447]の署名をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
identity The identity, as defined in the two paragraphs following this list, used to form the signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アイデンティティアイデンティティ、署名を形成するために使用されるこのリストは、次の2つの段落で定義された通りです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature_value The value of the signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名の値をsignature_value。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that storage operations allow for special values of algorithm and identity. See the Store Request definition (Section 7.4.1.1) and the Fetch Response definition (Section 7.4.2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ストレージ操作がアルゴリズムとアイデンティティの特別な値を許容することに注意してください。ストア要求の定義（セクション7.4.1.1）とフェッチ応答の定義（7.4.2.2項）を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two permitted identity formats, one for a certificate with only one Node-ID and one for a certificate with multiple Node-IDs. In the first case, the cert_hash type MUST be used. The hash_alg field is used to indicate the algorithm used to produce the hash. The certificate_hash contains the hash of the certificate object (i.e., the DER-encoded certificate).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つの許可アイデンティティ形式、唯一1つのノードIDを持つ証明書用と複数のNode-IDを持つ証明書のための1があります。最初のケースでは、cert_hashタイプが使用されなければなりません。 hash_algフィールドは、ハッシュを生成するために使用するアルゴリズムを示すために使用されます。 certificate_hash証明書オブジェクト（すなわち、DER符号化された証明書）のハッシュを含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the second case, the cert_hash_node_id type MUST be used. The hash_alg is as in cert_hash, but the cert_hash_node_id is computed over the NodeId used to sign concatenated with the certificate; i.e., H(NodeId || certificate). The NodeId is represented without any framing or length fields, as simple raw bytes. This is safe because NodeIds are a fixed length for a given overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後者の場合、cert_hash_node_idタイプが使用されなければなりません。 hash_algはcert_hashと同様であるが、cert_hash_node_idは、証明書と連結署名するために使用NODEIDにわたって計算されます。即ち、H（NODEID ||証明書）。 NODEIDは、単純な生のバイトとして、任意のフレーミングまたは長さフィールドなしで表されています。ノード識別子が与えられたオーバーレイの固定長であるため、これは安全です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For signatures over messages, the input to the signature is computed over:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ上の署名は、署名への入力は上に計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
overlay || transaction_id || MessageContents || SignerIdentity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
オーバーレイ|| TRANSACTION_ID || MessageContents || SignerIdentity
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where overlay and transaction_id come from the forwarding header and || indicates concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、オーバーレイとは、転送ヘッダから来るTRANSACTION_ID ||連結を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The input to signatures over data values is different and is described in Section 7.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ値上の署名の入力は異なり、セクション7.1に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All RELOAD messages MUST be signed. Intermediate nodes do not verify signatures. Upon receipt (and fragment reassembly, if needed), the destination node MUST verify the signature and the authorizing certificate. If the signature fails, the implementation SHOULD simply drop the message and MUST NOT process it. This check provides a minimal level of assurance that the sending node is a valid part of the overlay, and it provides cryptographic authentication of the sending node. In addition, responses MUST be checked as follows by the requesting node:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてRELOADメッセージが署名する必要があります。中間ノードは、署名を検証しません。 （必要な場合及び断片再組み立て）を受信すると、宛先ノードは、署名および認可証明書を検証しなければなりません。署名が失敗した場合、実装は単にメッセージをドロップする必要があり、それを処理してはいけません。このチェックは、送信ノードは、オーバーレイの有効な部分であり、それは、送信ノードの暗号認証を提供することを保証する最低限のレベルを提供します。要求ノードで次のように加えて、応答がチェックしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The response to a message sent to a Node-ID MUST have been sent by that Node-ID unless the response has been sent to the wildcard Node-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答がワイルドカードノードIDに送信されていない限り、1ノードIDに送信されたメッセージへの応答は、そのノードIDによって送信されていなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The response to a message sent to a Resource-ID MUST have been sent by a Node-ID which is at least as close to the target Resource-ID as any node in the requesting node&#39;s Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.リソース-IDに送信されたメッセージへの応答は、要求ノードのネイバーテーブル内の任意のノードとターゲットリソース-IDと少なくとも限り近いノードIDによって送信されていなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second condition serves as a primitive check for responses from wildly wrong nodes but is not a complete check. Note that in periods of churn, it is possible for the requesting node to obtain a closer neighbor while the request is outstanding. This will cause the response to be rejected and the request to be retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第2の条件は、乱暴に間違ったノードからの応答のための原始的なチェックとして機能しますが、完全なチェックではありません。要求が未処理であるが、要求ノードが近い隣人を得るための解約の期間において、それが可能であることに留意されたいです。これは、応答が拒否され、要求が再送されることになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, some methods (especially Store) have additional authentication requirements, which are described in the sections covering those methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加えて、いくつかの方法（特に店）これらのメソッドをカバーするセクションで説明される追加の認証要件を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Overlay Topology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. オーバーレイトポロジ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in previous sections, RELOAD defines a default overlay topology (CHORD-RELOAD) but allows for other topologies through the use of Topology Plug-ins. This section describes the requirements for new Topology Plug-ins and the methods that RELOAD provides for overlay topology maintenance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前のセクションで説明したように、リロードが既定のオーバレイ・トポロジー（CHORDリロード）を定義が、トポロジ・プラグインの使用を介して他のトポロジを可能にします。このセクションでは、新しいトポロジプラグインおよびRELOADは、オーバーレイ・トポロジーの維持を提供する方法のための要件について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1. Topology Plug-in Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1. トポロジプラグインの要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When specifying a new overlay algorithm, at least the following MUST be described:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいオーバーレイアルゴリズムを指定する場合、少なくとも次のように説明しなければなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Joining procedures, including the contents of the Join message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O Joinメッセージの内容を含む、手続きに参加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stabilization procedures, including the contents of the Update message, the frequency of topology probes and keepalives, and the mechanism used to detect when peers have disconnected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更新メッセージの内容、トポロジープローブとキープアライブの頻度、およびピアが切断しているときを検出するために使用する機構を備えO安定化手順。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Exit procedures, including the contents of the Leave message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Leaveメッセージの内容を含むOの終了手続き、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The length of the Resource-IDs and for DHTs the hash algorithm to compute the hash of an identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソース-IDの長さOとのDHTsの識別子のハッシュを計算するハッシュアルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The procedures that peers use to route messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがメッセージをルーティングするために使用するプロシージャO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The replication strategy used to ensure data redundancy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データの冗長性を確保するために使用、複製戦略O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All overlay algorithms MUST specify maintenance procedures that send Updates to clients and peers that have established connections to the peer responsible for a particular ID when the responsibility for that ID changes. Because tracking this information is difficult, overlay algorithms MAY simply specify that an Update is sent to all members of the Connection Table whenever the range of IDs for which the peer is responsible changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのオーバーレイ・アルゴリズムは、特定のIDを担当するピアへの接続を確立しているクライアントとピアにアップデートを送信する保守手順を指定しなければならないときにIDの変更のための責任。この情報を追跡することは困難であるため、オーバーレイアルゴリズムは単にピアが担当変更IDの範囲をされているときはいつでも更新を接続テーブルのすべてのメンバーに送信されることを指定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2. Methods and Types for Use by Topology Plug-ins
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2. トポロジプラグインによる使用のための方法およびタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the methods that Topology Plug-ins use to join, leave, and maintain the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、トポロジプラグインは、参加したまま、およびオーバーレイを維持するために使用する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.1. Join
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.1。加わります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A new peer (which already has credentials) uses the JoinReq message to join the overlay. The JoinReq is sent to the responsible peer depending on the routing mechanism described in the Topology Plug-in. This message notifies the responsible peer that the new peer is taking over some of the overlay and that it needs to synchronize its state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（すでに資格情報を持つ）新しいピアは、オーバーレイに参加するJoinReqメッセージを使用しています。 JoinReqはトポロジプラグインに記載のルーティングメカニズムに応じて責任をピアに送信されます。このメッセージは、新しいピアは、オーバーレイの一部の上に、それはその状態を同期する必要があることを取っている責任をピアに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
            NodeId                joining_peer_id;
            opaque                overlay_specific_data&lt;0..2^16-1&gt;;
         } JoinReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The minimal JoinReq contains only the Node-ID which the sending peer wishes to assume. Overlay algorithms MAY specify other data to appear in this request. Receivers of the JoinReq MUST verify that the joining_peer_id field matches the Node-ID used to sign the message and, if not, the message MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小JoinReqは送信ピアが想定したいだけのNode-IDを含んでいます。オーバーレイアルゴリズムは、この要求に表示される他のデータを指定するかもしれません。メッセージがError_Forbiddenエラーで拒否されなければならないない場合JoinReqの受信機は、joining_peer_idフィールドがメッセージに署名するために使用される-IDは、ノードと一致することを確認しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because joins may be executed only between nodes which are directly adjacent, receiving peers MUST verify that any JoinReq they receive arrives from a transport channel that is bound to the Node-ID to be assumed by the Joining Node. Implementations MUST use DTLS anti-replay mechanisms, thus preventing replay attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
唯一の直接隣接するノード間で実行され得る参加ので、受信ピアは、それらが受け取る任意JoinReqは、参加するノードが想定されるノードIDにバインドされたトランスポートチャネルから到来することを確かめなければなりません。実装は、このようにリプレイ攻撃を防ぐ、DTLSアンチリプレイメカニズムを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the request succeeds, the responding peer responds with a JoinAns message, as defined below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストが成功した場合、以下に定義されるように、応答ピアが、JoinAnsメッセージで応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
            opaque                overlay_specific_data&lt;0..2^16-1&gt;;
         } JoinAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the request succeeds, the responding peer MUST follow up by executing the right sequence of Stores and Updates to transfer the appropriate section of the overlay space to the Joining Node. In addition, overlay algorithms MAY define data to appear in the response payload that provides additional information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストが成功した場合は、応答するピアは、参加するノードにオーバーレイスペースの適切なセクションを転送する店舗やアップデートの権利シーケンスを実行することでフォローアップしなければなりません。また、オーバーレイアルゴリズムは、追加情報を提供する応答ペイロードに表示するデータを定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Joining Nodes MUST verify that the signature on the JoinAns message matches the expected target (i.e., the adjacency over which they are joining). If not, they MUST discard the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参加ノードはJoinAnsメッセージ上の署名が（すなわち、隣接がその上、それらが接合されている）、予想される標的と一致していることを確認しなければなりません。そうでない場合、彼らはメッセージを捨てなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, nodes which cannot form connections SHOULD report an error to the user. However, implementations MUST provide some mechanism whereby nodes can determine that they are potentially the first node and can take responsibility for the overlay. (The idea is to avoid having ordinary nodes try to become responsible for the entire overlay during a partition.) This specification does not mandate any particular mechanism, but a configuration flag or setting seems appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般に、接続を形成することができないノードは、ユーザにエラーを報告しなければなりません。ノードは、それらが、潜在的に、最初のノードであり、オーバーレイのための責任を取ることができると判断できるが、実装は、いくつかのメカニズムを提供しなければなりません。この仕様は、任意の特定のメカニズムを強制しません（アイデアは。通常のノードがパーティションの間にオーバーレイ全体の責任になることを試みることを避けるためにある）が、構成フラグや設定が適切であるように思われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.2. Leave
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.2。去ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LeaveReq message is used to indicate that a node is exiting the overlay. A node SHOULD send this message to each peer with which it is directly connected prior to exiting the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LeaveReqメッセージは、ノードがオーバーレイを出ていることを示すために使用されます。ノードは、それが直接オーバーレイを出る前に接続している各ピアにこのメッセージを送信すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
            NodeId                leaving_peer_id;
            opaque                overlay_specific_data&lt;0..2^16-1&gt;;
         } LeaveReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LeaveReq contains only the Node-ID of the leaving peer. Overlay algorithms MAY specify other data to appear in this request. Receivers of the LeaveReq MUST verify that the leaving_peer_id field matches the Node-ID used to sign the message and, if not, the message MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LeaveReqは残して、ピアの唯一のノードIDが含まれています。オーバーレイアルゴリズムは、この要求に表示される他のデータを指定するかもしれません。メッセージがError_Forbiddenエラーで拒否されなければならないない場合LeaveReqの受信機は、leaving_peer_idフィールドがメッセージに署名するために使用される-IDは、ノードと一致することを確認しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because leaves may be executed only between nodes which are directly adjacent, receiving peers MUST verify that any LeaveReq they receive arrives from a transport channel that is bound to the Node-ID to be assumed by the leaving peer. This also prevents replay attacks, provided that DTLS anti-replay is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
葉のみ直接隣接するノード間で実行されてもよいので、受信ピアは、それらが受け取る任意LeaveReqは離脱ピアによって想定されるノードIDにバインドされたトランスポートチャネルから到来することを確かめなければなりません。これはまた、DTLSアンチリプレイが使用されていることを提供し、リプレイ攻撃を防ぐことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving a Leave request, a peer MUST update its own Routing Table and send the appropriate Store/Update sequences to re-stabilize the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
離脱要求を受信すると、ピアは、自身のルーティングテーブルを更新し、オーバーレイを再安定化するために、適切な保存/更新シーケンスを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LeaveAns is an empty message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LeaveAnsは空のメッセージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.3. Update
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.3。更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Update is the primary overlay-specific maintenance message. It is used by the sender to notify the recipient of the sender&#39;s view of the current state of the overlay (that is, its routing state), and it is up to the recipient to take whatever actions are appropriate to deal with the state change. In general, peers send Update messages to all their adjacencies whenever they detect a topology shift.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更新は、プライマリオーバーレイ固有のメンテナンスメッセージで。 （つまり、そのルーティング状態である）オーバーレイの現在の状態の送信者の表示の受信者に通知するために送信者によって使用され、それが状態変化に対処するために適切などんな行動取るように受け手次第です。彼らはトポロジーシフトを検出するたびに一般的には、ピアは、すべての隣接に更新メッセージを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer receives an Attach request with the send_update flag set to True (Section 6.4.2.4.1), it MUST send an Update message back to the sender of the Attach request after completion of the corresponding ICE check and TLS connection. Note that the sender of such an Attach request may not have joined the overlay yet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが真（セクション6.4.2.4.1）に設定send_updateフラグをアタッチ要求を受信した場合は、対応するICEチェックとのTLS接続の完了後、バックアタッチ要求の送信元に更新メッセージを送らなければなりません。そのようなANアタッチ要求の送信者がまだオーバーレイに参加していないかもしれないことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer detects through an Update that it is no longer responsible for any data value it is storing, it MUST attempt to Store a copy to the correct node unless it knows the newly responsible node already has a copy of the data. This prevents data loss during large-scale topology shifts, such as the merging of partitioned overlays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、それはもはやそれが保存されている任意のデータ値を担当していないUpdateを通じて検出すると、それはすでに、新たに担当するノードを認識しているデータのコピーを持っていない限り、それが正しいノードにコピーを保存しようとしなければなりません。これは、パーティション・オーバーレイのマージとして、大規模なトポロジーシフト時のデータ損失を防止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the UpdateReq message are completely overlay specific. The UpdateAns response is expected to be either success or an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpdateReqメッセージの内容が完全にオーバーレイ特異的です。 UpdateAns応答が成功またはエラーのいずれかであることが予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4. RouteQuery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4。 RouteQuery
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RouteQuery request allows the sender to ask a peer where they would route a message directed to a given destination. In other words, a RouteQuery for a destination X requests the Node-ID for the node that the receiving peer would next route to in order to get to X. A RouteQuery can also request that the receiving peer initiate an Update request to transfer the receiving peer&#39;s Routing Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RouteQuery要求は、送信者が、彼らが経路指定された宛先に向けられたメッセージを希望ピアを依頼することを可能にします。換言すれば、先XのためRouteQueryは、受信ピアが受信ピアが受信を転送するために更新要求をも要求することができるX. A RouteQueryに到達するために、次のルートを開始するであろう、そのノードのノードIDを要求しますピアのルーティングテーブル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One important use of the RouteQuery request is to support iterative routing. The sender selects one of the peers in its Routing Table and sends it a RouteQuery message with the destination field set to the Node-ID or Resource-ID to which it wishes to route. The receiving peer responds with information about the peers to which the request would be routed. The sending peer MAY then use the Attach method to attach to that peer(s) and repeat the RouteQuery. Eventually, the sender gets a response from a peer that is closest to the identifier in the destination field as determined by the Topology Plug-in. At that point, the sender can send messages directly to that peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RouteQuery要求の一つの重要な用途は、反復ルーティングをサポートすることです。送信者は、そのルーティングテーブル内のピアの1つを選択し、それを、それが経路を希望するノードIDまたはリソース-IDに設定された宛先フィールドを有するRouteQueryメッセージを送信します。受信ピアは、要求がルーティングされるであろうにピアに関する情報で応答します。送信ピアは、そのピア（複数）に付着しRouteQueryを繰り返す取り付け方法を使用することができます。最終的に、送信者は、トポロジプラグインによって決定される宛先フィールド内の識別子に最も近いピアから応答を取得します。その時点で、送信者はそのピアに直接メッセージを送ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4.1。要求定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A RouteQueryReq message indicates the peer or resource that the requesting node is interested in. It also contains a &#34;send_update&#34; option that allows the requesting node to request a full copy of the other peer&#39;s Routing Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RouteQueryReqメッセージは、要求ノードが興味を持っているピアまたはリソースを示しています。また、要求ノードは、他のピアのルーティングテーブルの完全なコピーを要求することを可能にする「send_update」オプションが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
           Boolean                send_update;
           Destination            destination;
           opaque                 overlay_specific_data&lt;0..2^16-1&gt;;
         } RouteQueryReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the RouteQueryReq message are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにRouteQueryReqメッセージの内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
send_update A single byte. This may be set to True to indicate that the requester wishes the responder to initiate an Update request immediately. Otherwise, this value MUST be set to False.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1バイトをsend_update。これは、要求者がすぐに更新要求を開始するレスポンダを望んでいることを示すために、Trueに設定することができます。それ以外の場合、この値はfalseに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination The destination which the requester is interested in. This may be any valid destination object, including a Node-ID, opaque ID, or Resource-ID. Note: If implementations are using opaque IDs for privacy purposes, answering RouteQueryReqs for opaque IDs will allow the requester to translate an opaque ID. Implementations MAY wish to consider limiting the use of RouteQuery for opaque IDs in such cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先要求者が興味を持っている宛先が、これは、ノードID、不透明なID、またはリソース-IDを含む、任意の有効な宛先オブジェクトであってもよいです。注意：実装は、プライバシーのために不透明なIDを使用している場合は、不透明なIDのRouteQueryReqsに答えることは要求者が不透明なIDを変換することができます。実装は、このようなケースでは、不透明なIDのRouteQueryの使用を制限することを検討してすることもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay_specific_data Other data as appropriate for the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイのための適切な他のデータoverlay_specific_data。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4.2。レスポンスの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A response to a successful RouteQueryReq request is a RouteQueryAns message. This message is completely overlay specific.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功RouteQueryReq要求に対する応答はRouteQueryAnsメッセージです。このメッセージは、完全にオーバーレイ固有のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5. Probe
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5。調査
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Probe provides primitive &#34;exploration&#34; services: it allows a node to determine which resources another node is responsible for. A probe can be addressed to a specific Node-ID or to the peer controlling a given location (by using a Resource-ID). In either case, the target node responds with a simple response containing some status information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プローブは、原始的な「探査」のサービスを提供します。それは、ノードが他のノードが担当しているリソースを決定することができます。プローブは、特定のノードIDまたは（リソース-IDを使用して）指定された位置を制御ピアにア​​ドレス指定することができます。いずれの場合においても、ターゲット・ノードは、いくつかのステータス情報を含む単純な応答で応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5.1。要求定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ProbeReq message contains a list (potentially empty) of the pieces of status information that the requester would like the responder to provide.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ProbeReqメッセージは、要求が応答を提供したいとステータス情報のリスト（潜在的に空の）を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        enum { invalidProbeInformationType(0), responsible_set(1),
               num_resources(2), uptime(3), (255) }
             ProbeInformationType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          ProbeInformationType     requested_info&lt;0..2^8-1&gt;;
        } ProbeReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The currently defined values for ProbeInformationType are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ProbeInformationTypeのための現在定義されている値は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responsible_set Indicates that the peer should Respond with the fraction of the overlay for which the responding peer is responsible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responsible_setは、ピアが応答するピアが責任を負うオーバーレイの割合で応答すべきであることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
num_resources Indicates that the peer should Respond with the number of resources currently being stored by the peer. Note that multiple values under the same Resource-ID are counted only once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
num_resourcesは、ピアが現在のピアによって格納されているリソースの数で応答すべきであることを示します。同じリソース-IDの下の複数の値を一度だけカウントされることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uptime Indicates that the peer should Respond with how long the peer has been up, in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
稼働時間は、ピアがピアが秒にアップしているどのくらいの時間で応答すべきであることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5.2。レスポンスの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A successful ProbeAns response contains the information elements requested by the peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功ProbeAns応答は、ピアによって要求された情報要素が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
           select (type) {
             case responsible_set:
               uint32             responsible_ppb;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             case num_resources:
               uint32             num_resources;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
case uptime: uint32 uptime;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
ケースの稼働時間：UINT32稼働時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             /* This type may be extended */
           };
         } ProbeInformationData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
           ProbeInformationType    type;
           uint8                   length;
           ProbeInformationData    value;
         } ProbeInformation;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
           ProbeInformation        probe_info&lt;0..2^16-1&gt;;
         } ProbeAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ProbeAns message contains a sequence of ProbeInformation structures. Each has a &#34;length&#34; indicating the length of the following value field. This structure allows for unknown option types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ProbeAnsメッセージはProbeInformation構造体の配列を含みます。それぞれが次の値フィールドの長さを示す「長さ」を有します。この構造体は、未知のオプションタイプが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the current possible Probe information types is a 32-bit unsigned integer. For type &#34;responsible_ppb&#34;, it is the fraction of the overlay for which the peer is responsible, in parts per billion. For type &#34;num_resources&#34;, it is the number of resources the peer is storing. For the type &#34;uptime&#34;, it is the number of seconds the peer has been up.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在可能なプローブ情報タイプの各々は、32ビットの符号なし整数です。タイプ「responsible_ppb」の場合は、ピアは10億分の1で、担当するオーバーレイの割合です。タイプ「num_resources」の場合は、ピアが保存されるリソースの数です。タイプ「稼働時間」のために、それはピアがアップされている秒数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The responding peer SHOULD include any values that the requesting node requested and that it recognizes. They SHOULD be returned in the requested order. Any other values MUST NOT be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答するピアは、要求側ノードが要求された任意の値を含み、それは認識するべきです。彼らは、要求された順序で返されるべきです。その他の値が返されてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. Forwarding and Link Management Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. 転送とリンク管理レイヤ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each node maintains connections to a set of other nodes defined by the Topology Plug-in. This section defines the methods RELOAD uses to form and maintain connections between nodes in the overlay. Three methods are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ノードは、トポロジプラグインによって定義された他のノードのセットへの接続を維持します。このセクションでは、リロードが形成し、オーバーレイ内のノード間の接続を維持するために使用するメソッドを定義します。 3つの方法が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attach Used to form RELOAD connections between nodes using ICE for NAT traversal. When node A wants to connect to node B, it sends an Attach message to node B through the overlay. The Attach contains A&#39;s ICE parameters. B responds with its ICE parameters, and the two nodes perform ICE to form connection. Attach also allows two nodes to connect via No-ICE instead of full ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NATトラバーサルのためのICEを使用してノード間のRELOAD接続を形成するために用いられる取り付けます。ノードAがノードBに接続したい場合には、オーバレイを介してノードBにメッセージを添付し送信します。アタッチAのICEパラメータが含まれています。 Bは、そのICEパラメータで応答し、そして2つのノードは接続を形成するために、ICEを行います。取り付けはまた、2つのノードが代わりにフルICEの無ICE経由で接続することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AppAttach Used to form application-layer connections between nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AppAttachは、ノード間のアプリケーション層の接続を形成するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ping A simple request/response which is used to verify connectivity of the target peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピングターゲットピアの接続を確認するために使用される単純な要求/応答。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1. Attach
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1. アタッチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node sends an Attach request when it wishes to establish a direct Overlay Link connection to another node for the purpose of sending RELOAD messages. A client that can establish a connection directly need not send an Attach, as described in the second bullet of Section 4.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードは、それがRELOADメッセージを送信する目的のために別のノードへの直接オーバーレイのリンク接続を確立したい場合、要求を添付し送信します。接続を確立することができ、クライアントは、直接4.2.1節の第二箇条書きで説明したように、添付し送信する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 6.1, an Attach may be routed to either a Node-ID or a Resource-ID. An Attach routed to a specific Node-ID will fail if that node is not reached. An Attach routed to a Resource-ID will establish a connection with the peer currently responsible for that Resource-ID, which may be useful in establishing a direct connection to the responsible peer for use with frequent or large resource updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6.1節で述べたように、アタッチノードIDまたはリソース-IDのいずれかにルーティングすることができます。そのノードに到達していない場合に失敗します。特定のノードIDにルーティング接続します。アタッチリソース-IDにルーティングは、頻繁または大規模なリソースの更新で使用するための責任を負うピアへの直接接続を確立するのに有用であり得る、そのリソース-IDのために、現在担当するピアとの接続を確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Attach, in and of itself, does not result in updating the Routing Table of either node. That function is performed by Updates. If node A has Attached to node B, but has not received any Updates from B, it MAY route messages which are directly addressed to B through that channel, but it MUST NOT route messages through B to other peers via that channel. The process of Attaching is separate from the process of becoming a peer (using Join and Update), to prevent half-open states where a node has started to form connections but is not really ready to act as a peer. Thus, clients (unlike peers) can simply Attach without sending Join or Update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それ自体は、いずれかのノードのルーティングテーブルを更新することにはなりません、アタッチ。この関数は、アップデートによって行われます。ノードAがノードBに取り付けられているが、Bから更新を受信して​​いない場合、そのMAY経路直接そのチャネルを介してBにアドレス指定されるメッセージが、それMUST NOT、そのチャネルを介して他のピアにBを通るルートメッセージ。取り付ける工程は、ノードが接続を形成するために始めたが、実際には、ピアとして機能する準備ができていないたハーフオープン状態を防ぐために（参加し、Updateを使用して）ピア、なるためのプロセスから分離されています。このように、（ピアとは違って）クライアントは、単に参加したり更新送信せずに接続することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.1。要求定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Attach request message contains the requesting node ICE connection parameters formatted into a binary structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アタッチ要求メッセージは、バイナリ構造にフォーマット要求ノードICE接続パラメータを含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        enum { invalidOverlayLinkType(0), DTLS-UDP-SR(1),
               DTLS-UDP-SR-NO-ICE(3), TLS-TCP-FH-NO-ICE(4),
               (255) } OverlayLinkType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        enum { invalidCandType(0),
               host(1), srflx(2), /* RESERVED(3), */ relay(4),
               (255) } CandType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          opaque                name&lt;0..2^16-1&gt;;
          opaque                value&lt;0..2^16-1&gt;;
        } IceExtension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          IpAddressPort         addr_port;
          OverlayLinkType       overlay_link;
          opaque                foundation&lt;0..255&gt;;
          uint32                priority;
          CandType              type;
          select (type) {
            case host:
              ;          /* Empty */
            case srflx:
            case relay:
              IpAddressPort     rel_addr_port;
          };
          IceExtension          extensions&lt;0..2^16-1&gt;;
        } IceCandidate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          opaque                ufrag&lt;0..2^8-1&gt;;
          opaque                password&lt;0..2^8-1&gt;;
          opaque                role&lt;0..2^8-1&gt;;
          IceCandidate          candidates&lt;0..2^16-1&gt;;
          Boolean               send_update;
        } AttachReqAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values contained in AttachReqAns are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AttachReqAnsに含まれる値は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ufrag The username fragment (from ICE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（ICE）からユーザ名フラグメントをufrag。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
password The ICE password.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パスワードICEのパスワード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
role An active/passive/actpass attribute from RFC 4145 [RFC4145]. This value MUST be &#34;passive&#34; for the offerer (the peer sending the Attach request) and &#34;active&#34; for the answerer (the peer sending the Attach response).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
役割RFC 4145 [RFC4145]からアクティブ/パッシブ/ actpass属性。この値は、回答（アタッチ応答を送信したピア）用の申出は、「受動的」（ピアがアタッチ要求を送信）と「アクティブ」でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
candidates One or more ICE candidate values, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
候補者一の以上のICE候補値を、以下に説明するように。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
send_update Has the same meaning as the send_update field in RouteQueryReq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
send_updateはRouteQueryReqでsend_updateフィールドと同じ意味を持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ICE candidate is represented as an IceCandidate structure, which is a direct translation of the information from the ICE string structures, with the exception of the component ID. Since there is only one component, it is always 1, and thus left out of the structure. The remaining values are specified as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ICE候補を構成要素IDを除いて、ICE列構造からの情報の直接変換であるIceCandidate構造として表されます。唯一つの成分があるので、それは常に1であるため、構造の外に放置しました。次のように残りの値が指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
addr_port Corresponds to the ICE connection-address and port productions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
addr_portはICE接続アドレスとポートの制作に対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay_link Corresponds to the ICE transport production. Overlay Link protocols used with No-ICE MUST specify &#34;No-ICE&#34; in their description. Future overlay link values can be added by defining new OverlayLinkType values in the IANA registry as described in Section 14.10. Future extensions to the encapsulation or framing that provide for backward compatibility with the previously specified encapsulation or framing values MUST use the same OverlayLinkType value that was previously defined. OverlayLinkType protocols are defined in Section 6.6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay_linkはICE輸送生産に対応します。無ICEで使用されるオーバレイリンクプロトコルは、その説明に「いいえ-ICE」を指定してはなりません。将来のオーバーレイリンク値は、セクション14.10で説明したようにIANAレジストリに新しいOverlayLinkType値を定義することで追加することができます。以前に指定されたカプセル化やフレーミングの値との下位互換性を提供するカプセル化やフレーミングに将来の拡張は、以前に定義されたのと同じOverlayLinkType値を使用しなければなりません。 OverlayLinkTypeプロトコルは6.6節で定義されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A single AttachReqAns MUST NOT include both candidates whose OverlayLinkType protocols use ICE (the default) and candidates that specify &#34;No-ICE&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
シングルAttachReqAnsが「NO-ICE」を指定しない両方そのOverlayLinkTypeプロトコルICE（デフォルト）を使用して候補者と候補者を含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
foundation Corresponds to the ICE foundation production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
財団は、ICEの基礎生産に対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
priority Corresponds to the ICE priority production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
優先順位は、ICEの優先順位の生産に対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type Corresponds to the ICE cand-type production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプは、ICEのCAND型の生産に対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rel_addr_port Corresponds to the ICE rel-addr and rel-port productions. It is present only for types &#34;relay&#34;, &#34;prfix&#34;, and &#34;srflx&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rel_addr_portは、ICEのREL-addrとREL-ポート制作に対応します。それが唯一のタイプの「リレー」、「prfix」、および「srflx」のために存在しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extensions ICE extensions. The name and value fields correspond to binary translations of the equivalent fields in the ICE extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張ICE拡張。名前と値のフィールドは、ICE拡張の等価フィールドのバイナリ翻訳に対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These values should be generated using the procedures described in Section 6.5.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの値は、セクション6.5.1.3に記載された手順を使用して生成されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.2。レスポンスの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a peer receives an Attach request, it MUST determine how to process the request as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがアタッチ要求を受信した場合、それは次のように要求を処理する方法を決定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the peer has not initiated an Attach request to the originating peer of this Attach request, it MUST process this request and SHOULD generate its own response with an AttachReqAns. It should then begin ICE checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが開始されていない場合は、O、それはこの要求を処理しなければならないとAttachReqAnsを持つ独自の応答を生成する必要があります、このアタッチ要求の元のピアに要求を取り付けます。その後、ICEのチェックを開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the peer has already sent an Attach request to and received the response from the originating peer of this Attach request and, as a result, an ICE check and TLS connection are in progress, then it SHOULD generate an Error_In_Progress error instead of an AttachReqAns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oピアがすでににリクエストを取り付け、この発信元ピアから応答を受信したリクエストを接続し、その結果、ICEチェック及びTLS接続が進行中であり、それは代わりAttachReqAnsのError_In_Progressエラーを生成する必要が送信された場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the peer has already sent an Attach request to but not yet received the response from the originating peer of this Attach request, it SHOULD apply the following tie-breaker heuristic to determine how to handle this Attach request and the incomplete Attach request it has sent out:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oピアがすでにまだこのアタッチ要求の発信元ピアから応答を受信して​​いないけれども、それはこのアタッチ要求し、それが有する不完全アタッチ要求の処理方法を決定するために、次のタイブレーカのヒューリスティックを適用する必要に接続要求を送信した場合送り出さ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* If the peer&#39;s own Node-ID is smaller when compared as big-endian unsigned integers, it MUST cancel retransmission of its own incomplete Attach request. It MUST then process this Attach request, generate an AttachReqAns response, and proceed with the corresponding ICE check.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
*ビッグエンディアン符号なし整数として比較したときに、ピア自身のノードIDが小さい場合、それは独自の取り付けの不完全な要求の再送信をキャンセルする必要があります。それは、これは、要求を取り付けAttachReqAns応答を生成し、対応するICEチェックを続行処理しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* If the peer&#39;s own Node-ID is larger when compared as big-endian unsigned integers, it MUST generate an Error_In_Progress error to this Attach request, and then proceed to wait for and complete the Attach and the corresponding ICE check it has originated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ビッグエンディアン符号なし整数として比較したときに、ピア自身のノードIDが大きい場合*は、このアタッチ要求にError_In_Progressエラーを生成し、次に待つために進み、取り付け、対応するICEは、それが発信したチェック完了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the peer is overloaded or detects some other kind of error, it MAY generate an error instead of an AttachReqAns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが過負荷状態やエラーのいくつかの他の種類を検出している場合は、O、それは代わりにAttachReqAnsのエラーを生成することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer receives an Attach response, it SHOULD parse the response and begin its own ICE checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがアタッチ応答を受信すると、応答を解析し、独自のICEチェックを開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.3. Using ICE with RELOAD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.3。 RELOADとICEを使用して
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the profile of ICE that is used with RELOAD. RELOAD implementations MUST implement full ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、RELOADで使用されているICEのプロファイルを記述する。 RELOAD実装はフルICEを実装しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In ICE, as defined by [RFC5245], the Session Description Protocol (SDP) is used to carry the ICE parameters. In RELOAD, this function is performed by a binary encoding in the Attach method. This encoding is more restricted than the SDP encoding because the RELOAD environment is simpler:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5245]で定義されるようにICEに、セッション記述プロトコル（SDP）は、ICEパラメータを搬送するために使用されます。 RELOADにおいて、この機能は、取り付け方法で二進符号化することによって行われます。 RELOAD環境が単純であるため、このエンコーディングは、SDPのエンコードよりも制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Only a single media stream is supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oのみ単一のメディアストリームがサポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In this case, the &#34;stream&#34; refers not to RTP or other types of media, but rather to a connection for RELOAD itself or other application-layer protocols, such as SIP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oここで、「ストリーム」がないRTP又は他のタイプのメディアに、むしろSIPなどリロード自体または他のアプリケーション層プロトコルのための接続を指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RELOAD allows only for a single offer/answer exchange. Unlike the usage of ICE within SIP, there is never a need to send a subsequent offer to update the default candidates to match the ones selected by ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RELOADは、単一のオファー/アンサー交換が可能になります。 SIP内のICEの使用方法とは異なり、ICEによって選択されたものと一致するように、デフォルトの候補を更新するために、後続のオファーを送信する必要は決してありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An agent follows the ICE specification as described in [RFC5245] with the changes and additional procedures described in the subsections below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のサブセクションで説明する変更と追加手順と[RFC5245]に記載されているように、エージェントは、ICEの仕様に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.4. Collecting STUN Servers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.4。 STUNサーバーの収集
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICE relies on the node having one or more Session Traversal Utilities for NAT (STUN) servers to use. In conventional ICE, it is assumed that nodes are configured with one or more STUN servers through some out-of-band mechanism. This is still possible in RELOAD, but RELOAD also learns STUN servers as it connects to other peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICEは、一つ以上を使用するNATのセッショントラバーサルユーティリティ（STUN）は、サーバを有するノードに依存しています。従来のICEにおいては、ノードは、いくつかのアウトオブバンド機構を介して1つまたは複数のSTUNサーバで構成されているものとします。これは、RELOADには可能ですが、それは他のピアに接続するようRELOADもSTUNサーバを学習します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer on a well-provisioned wide-area overlay will be configured with one or more bootstrap nodes. These nodes make an initial list of STUN servers. However, as the peer forms connections with additional peers, it builds more peers that it can use like STUN servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
よくプロビジョニング広域オーバーレイ上のピアは、一つ以上のブートストラップ・ノードで構成されます。これらのノードはSTUNサーバの初期リストを作成します。しかし、追加のピアとのピアフォーム接続として、それはSTUNサーバのように使用することができるという多くのピアを構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because complicated NAT topologies are possible, a peer may need more than one STUN server. Specifically, a peer that is behind a single NAT will typically observe only two IP addresses in its STUN checks: its local address and its server reflexive address from a STUN server outside its NAT. However, if more NATs are involved, a peer may learn additional server reflexive addresses (which vary based on where in the topology the STUN server is). To maximize the chance of achieving a direct connection, a peer SHOULD group other peers by the peer-reflexive addresses it discovers through them. It SHOULD then select one peer from each group to use as a STUN server for future connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複雑なNATトポロジが可能であるため、ピアは、複数のSTUNサーバーが必要な場合があります。そのローカルアドレスとNATの外側STUNサーバーからそのサーバー再帰アドレス：具体的には、単一のNATの背後にあるピアは、典型的には、そのSTUNチェックで唯一の2つのIPアドレスを観察します。複数のNATが含まれる場合は、ピアは、（トポロジでSTUNサーバがどこに基づいて変化する）追加のサーバ再帰アドレスを学習することができます。直接接続を達成するための機会を最大化するために、ピアはそれがそれらを介して、ピア再帰アドレスによるグループ他のピアを発見するべきです。これは、将来の接続のためのSTUNサーバーとして使用するために、各グループから1つのピアを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Only peers to which the peer currently has connections may be used. If the connection to that host is lost, it MUST be removed from the list of STUN servers, and a new server from the same group MUST be selected unless there are no others servers in the group, in which case some other peer MAY be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、現在の接続を使用することができる持っているにピアのみ。そのホストへの接続が失われた場合、それはSTUNサーバのリストから削除されなければならない、と何も他のサーバがグループ内に存在しない場合を除き、同じグループから新しいサーバーは、いくつかの他のピアが使用される場合には、選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.5. Gathering Candidates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.5。候補者を集めます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a node wishes to establish a connection for the purposes of RELOAD signaling or application signaling, it follows the process of gathering candidates as described in Section 4 of ICE [RFC5245]. RELOAD utilizes a single component. Consequently, gathering for these &#34;streams&#34; requires a single component. In the case where a node has not yet found a TURN server, the agent would not include a relayed candidate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードリロードシグナリングまたはアプリケーションシグナリングの目的のための接続を確立することを望む場合には、ICE [RFC5245]のセクション4で説明したように候補を収集するプロセスに従います。 RELOADは、単一のコンポーネントを利用しています。したがって、これらの「ストリーム」を集め、単一の構成要素を必要とします。ノードがまだTURNサーバを発見していない場合には、薬剤は、中継候補が含まれないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ICE specification assumes that an ICE agent is configured with, or somehow knows of, TURN and STUN servers. RELOAD provides a way for an agent to learn these by querying the overlay, as described in Sections 6.5.1.4 and 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICE仕様では、ICEエージェントがで構成されていることを前提とし、または何らかの形で、TURNとSTUNサーバを知っています。リロード剤は、セクション6.5.1.4および9に記載されているように、オーバーレイを照会することによって、これらを学習するための方法を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The default candidate selection described in Section 4.1.4 of ICE is ignored; defaults are not signaled or utilized by RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICEの第4.1.4項で説明するデフォルトの候補の選択は無視されます。デフォルトはシグナリングまたはリロードすることによって利用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An alternative to using the full ICE supported by the Attach request is to use the No-ICE mechanism by providing candidates with &#34;No-ICE&#34; Overlay Link protocols. Configuration for the overlay indicates whether or not these Overlay Link protocols can be used. An overlay MUST be either all ICE or all No-ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アタッチ要求でサポートされているフルICEを使用する代わりに、「いいえ-ICE」オーバーレイリンクプロトコルで候補者を提供することにより、無ICEメカニズムを使用することです。オーバーレイの設定は、これらのオーバーレイリンクプロトコルが使用可能かどうかを示します。オーバーレイは、すべてのICEまたは全てノー-ICEのいずれかでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No-ICE will not work in all the scenarios where ICE would work, but in some cases, particularly those with no NATs or firewalls, it will work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
無ICEは、ICEが働くだろうすべてのシナリオでは動作しませんしませんが、いくつかのケースでは、特になしのNATやファイアウォールを持つものは、それが動作します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.6. Prioritizing Candidates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.6。優先順位付け候補
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Standardization of additional protocols for use with ICE is expected, including TCP [RFC6544] and protocols such as the Stream Control Transmission Protocol (SCTP) [RFC4960] and Datagram Congestion Control Protocol (DCCP) [RFC4340]. UDP encapsulations for SCTP and DCCP would expand the Overlay Link protocols available for RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICEで使用するための追加のプロトコルの標準化は、TCP [RFC6544]及びそのようなストリーム制御伝送プロトコル（SCTP）[RFC4960]及びデータグラム輻輳制御プロトコル（DCCP）[RFC4340]などのプロトコルを含め、期待されています。 SCTPやDCCPのためのUDPカプセル化は、RELOADために利用可能なオーバーレイリンクプロトコルを拡張します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When additional protocols are available, the following prioritization is RECOMMENDED:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加のプロトコルが使用可能な場合は、以下の優先順位付けをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Highest priority is assigned to protocols that offer well-understood congestion and flow control without head-of-line blocking, for example, SCTP without message ordering, DCCP, and those protocols encapsulated using UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O最高優先度は十分に理解輻輳を提供し、メッセージの順序、DCCPことなく、例えば、ヘッドオブラインブロッキングなしSCTPをフロー制御プロトコルに割り当てられ、これらのプロトコルは、UDPを使用してカプセル化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Second highest priority is assigned to protocols that offer well-understood congestion and flow control, but that have head-of-line blocking, such as TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O次の優先順位は、よく理解さ輻輳を提供し、フロー制御プロトコルに割り当てられ、それはTCPのようなヘッドオブラインブロッキングを有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Lowest priority is assigned to protocols encapsulated over UDP that do not implement well-established congestion control algorithms. The DTLS/UDP with Simple Reliability (SR) overlay link protocol is an example of such a protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O最低優先順位が十分に確立さ輻輳制御アルゴリズムを実装していないUDP上でカプセル化プロトコルに割り当てられています。単純な信頼性（SR）オーバーレイリンクプロトコルDTLS / UDPは、このようなプロトコルの一例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Head-of-line blocking is undesirable in an Overlay Link protocol, because the messages carried on a RELOAD link are independent, rather than stream-oriented. Therefore, if message N on a link is lost, delaying message N+1 on that same link until N is successfully retransmitted does nothing other than increase the latency for the transaction of message N+1, as they are unrelated to each other. Therefore, while the high quality, performance, and availability of modern TCP implementations makes them very attractive, their performance as Overlay Link protocols is not optimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADリンクで運ばメッセージは独立した、というよりストリーム指向であるため、ヘッドオブラインブロッキングは、オーバーレイリンクプロトコルでは望ましくありません。したがって、リンク上のメッセージNが失われた場合、Nが正常に再送信されるまで、同じリンク上のメッセージN + 1を遅らせる彼らはお互いに関係のないよう、メッセージのトランザクションのための待ち時間を増やす以外に何もN + 1もしません。現代のTCP実装の高品質、パフォーマンス、可用性、それらは非常に魅力的つつ、オーバーレイリンクプロトコルとしてのパフォーマンスが最適ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that none of the protocols defined in this document meets these conditions, but it is expected that new Overlay Link protocols defined in the future will fill this gap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書で定義されたプロトコルのどれもが、これらの条件を満たしていないことに注意してください、将来的に定義された新しいオーバーレイリンクプロトコルは、このギャップを埋めることが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.7. Encoding the Attach Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.7。アタッチメッセージを符号化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 4.3 of ICE describes procedures for encoding the SDP for conveying RELOAD candidates. Instead of actually encoding an SDP message, the candidate information (IP address and port and transport protocol, priority, foundation, type, and related address) is carried within the attributes of the Attach request or its response. Similarly, the username fragment and password are carried in the Attach message or its response. Section 6.5.1 describes the detailed attribute encoding for Attach. The Attach request and its response do not contain any default candidates or the ice-lite attribute, as these features of ICE are not used by RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICEの4.3節には、RELOAD候補を搬送するためのSDPを符号化するための手順を説明します。代わりに、実際にSDPメッセージを符号化する、候補情報（IPアドレス、ポートおよびトランスポートプロトコル、優先順位、ファンデーション、タイプ、および関連するアドレス）アタッチ要求やその応答の属性の中に運ばれます。同様に、ユーザ名断片とパスワードが添付メッセージまたはその応答で搬送されています。セクション6.5.1は、取り付けのための詳細な属性のエンコーディングを示しています。リクエストを取り付け、ICEのこれらの機能はRELOADによって使用されないように、その応答は、任意のデフォルトの候補や氷-liteの属性が含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the Attach request contains the candidate information and short term credentials, it is considered as an offer for a single media stream that happens to be encoded in a format different than SDP, but is otherwise considered a valid offer for the purposes of following the ICE specification. Similarly, the Attach response is considered a valid answer for the purposes of following the ICE specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストを接続候補情報と短期資格情報が含まれているので、SDPとは異なるフォーマットでエンコードされたまたま単一のメディアストリームのための提供であると考えられるが、それ以外ICEを以下の目的のために有効なオファーを考えられています仕様。同様に、アタッチ応答は、ICEの仕様を以下の目的のために有効な回答と考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.8. Verifying ICE Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.8。確認ICEのサポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An agent MUST skip the verification procedures in Sections 5.1 and 6.1 of ICE. Since RELOAD requires full ICE from all agents, this check is not required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エージェントは、セクション5.1とICEの6.1での検証手順をスキップしなければなりません。 RELOADは、すべてのエージェントからのフルICEを必要とするので、このチェックは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.9. Role Determination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.9。役割決定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The roles of controlling and controlled, as described in Section 5.2 of ICE, are still utilized with RELOAD. However, the offerer (the entity sending the Attach request) will always be controlling, and the answerer (the entity sending the Attach response) will always be controlled. The connectivity checks MUST still contain the ICE-CONTROLLED and ICE-CONTROLLING attributes, however, even though the role reversal capability for which they are defined will never be needed with RELOAD. This is to allow for a common codebase between ICE for RELOAD and ICE for SDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICEのセクション5.2で説明したように、制御および制御の役割は、まだリロードして利用されています。しかし、提供者（アタッチ要求を送信するエンティティ）は常に制御され、回答（アタッチ応答を送信するエンティティ）は常に制御されます。接続性チェックは、まだ彼らが定義されている役割の反転能力はRELOADを必要とすることはありませんにもかかわらず、しかし、ICE-制御され、ICE制御属性を含まなければなりません。これは、SDPのためにRELOADとICEのためのICEとの間で共通のコードベースを可能にすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10. Full ICE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10。フルICE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the overlay uses ICE, connectivity checks and nominations are used as in regular ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイは、ICEを使用する場合、接続性チェックと指名は通常のICEのように使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.1. Connectivity Checks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.1。接続性チェック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The processes of forming check lists in Section 5.7 of ICE, scheduling checks in Section 5.8, and checking connectivity checks in Section 7 are used with RELOAD without change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、ICEの5.7節にチェックリストを構成するセクション5.8にチェックをスケジュールし、セクション7で接続性チェックをチェックするプロセスは変更せずにRELOADと一緒に使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.2. Concluding ICE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.2。結論ICE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedures in Section 8 of ICE are followed to conclude ICE, with the following exceptions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICEの第8章の手順は、以下の例外を除いて、ICEを締結するために従わされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The controlling agent MUST NOT attempt to send an updated offer once the state of its single media stream reaches Completed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O制御剤は、単一のメディアストリームの状態が完了に達すると、更新のオファーを送信することを試みてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Once the state of ICE reaches Completed, the agent can immediately free all unused candidates. This is because RELOAD does not have the concept of forking, and thus the three-second delay in Section 8.3 of ICE does not apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICEが到達の状態が完了したら、O、エージェントは、すべての未使用の候補すぐに解放することができます。 RELOADはフォークの概念がないので、ICEのセクション8.3で3秒の遅延が適用されないためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.3. Media Keepalives
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.3。メディアキープアライブ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN MUST be utilized for the keepalives described in Section 10 of ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUNは、ICEのセクション10に記載のキープアライブするために利用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.11. No-ICE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.11。無ICEありません
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No-ICE is selected when either side has provided &#34;no ICE&#34; Overlay Link candidates. STUN is not used for connectivity checks when doing No-ICE; instead, the DTLS or TLS handshake (or similar security layer of future overlay link protocols) forms the connectivity check. The certificate exchanged during the TLS or DTLS handshake MUST match the node which sent the AttachReqAns, and if it does not, the connection MUST be closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらかの側が「ノーICE」オーバーレイリンクの候補を提供した際ませ-ICEが選択されていません。無ICEをやっていないとき、STUNは、接続性チェックのために使用されていません。代わりに、DTLSまたはTLSハンドシェイク（または将来のオーバーレイリンク・プロトコルの同様のセキュリティ層）が接続性チェックを形成しています。証明書はAttachReqAnsを送信したノードと一致しなければならないTLSまたはDTLSハンドシェーク中に交換し、そうでない場合は、接続が閉じられなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.12. Subsequent Offers and Answers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.12。その後のオファーと回答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An agent MUST NOT send a subsequent offer or answer. Thus, the procedures in Section 9 of ICE MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エージェントは、その後の申し出または回答を送ってはいけません。このように、ICEの第9節の手順を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.13. Sending Media
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.13。送信するメディア
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedures of Section 11 of ICE apply to RELOAD as well. However, in this case, the &#34;media&#34; takes the form of application-layer protocols (e.g., RELOAD) over TLS or DTLS. Consequently, once ICE processing completes, the agent will begin TLS or DTLS procedures to establish a secure connection. The node that sent the Attach request MUST be the TLS server. The other node MUST be the TLS client. The server MUST request TLS client authentication. The nodes MUST verify that the certificate presented in the handshake matches the identity of the other peer as found in the Attach message. Once the TLS or DTLS signaling is complete, the application protocol is free to use the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICEのセクション11の手順は、同様にリロードする適用されます。しかし、この場合には、「メディア」は、TLSまたはDTLSオーバーアプリケーション層プロトコル（例えば、RELOAD）の形をとります。 ICEの処理が完了すると結果的に、エージェントは、安全な接続を確立するために、TLSまたはDTLS手続きを開始します。アタッチ要求を送信したノードは、TLSサーバでなければなりません。他のノードは、TLSクライアントでなければなりません。サーバはTLSクライアント認証を要求しなければなりません。ノードがアタッチメッセージで見られるようなハンドシェイクに提示された証明書は、他のピアのアイデンティティと一致することを確認しなければなりません。 TLSまたはDTLSシグナリングが完了すると、アプリケーションプロトコルは、接続を使用して自由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The concept of a previous selected pair for a component does not apply to RELOAD, since ICE restarts are not possible with RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICEの再起動がRELOADでは不可能なので、コンポーネントの前の選択されたペアの概念は、RELOADには適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.14. Receiving Media
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.14。受信メディア
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An agent MUST be prepared to receive packets for the application protocol (TLS or DTLS carrying RELOAD) at any time. The jitter and RTP considerations in Section 11 of ICE do not apply to RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エージェントは、いつでもアプリケーションプロトコル（TLSまたはリロードを運ぶDTLS）のためのパケットを受信するように準備しなければなりません。 ICEの第11節で、ジッタとRTPの考慮事項がRELOADには適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2. AppAttach
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2.  Appattac
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node sends an AppAttach request when it wishes to establish a direct connection to another node for the purposes of sending application-layer messages. AppAttach is nearly identical to Attach, except for the purpose of the connection: it is used to transport non-RELOAD &#34;media&#34;. A separate request is used to avoid implementer confusion between the two methods (this was found to be a real problem with initial implementations). The AppAttach request and its response contain an application attribute, which indicates what protocol is to be run over the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはアプリケーション層メッセージを送信する目的のために別のノードへの直接接続を確立することを望む場合、ノードはAppAttach要求を送信します。 AppAttachは、接続の目的を除いて、アタッチとほぼ同じである：非RELOAD「メディア」を輸送するのに使用されます。別リクエストは2つの方法の間の実装の混乱を避けるために使用される（これは初期の実装と実際の問題であることが判明しました）。 AppAttach要求とその応答は、プロトコルが接続を介して実行されるかを示すアプリケーション属性が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2.1。要求定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An AppAttachReq message contains the requesting node&#39;s ICE connection parameters formatted into a binary structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AppAttachReqメッセージは、バイナリ構造にフォーマット要求ノードのICE接続パラメータを含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          opaque                  ufrag&lt;0..2^8-1&gt;;
          opaque                  password&lt;0..2^8-1&gt;;
          uint16                  application;
          opaque                  role&lt;0..2^8-1&gt;;
          IceCandidate            candidates&lt;0..2^16-1&gt;;
        } AppAttachReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values contained in AppAttachReq and AppAttachAns are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AppAttachReqとAppAttachAnsに含まれる値は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ufrag The username fragment (from ICE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（ICE）からユーザ名フラグメントをufrag。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
password The ICE password.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パスワードICEのパスワード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
application A 16-bit Application-ID, as defined in the Section 14.5. This number represents the IANA-registered application that is going to send data on this connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションA 16ビットアプリケーションID、セクション14.5で定義された通りです。この数は、この接続でデータを送信するために起こっているIANA-登録されたアプリケーションを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
role An active/passive/actpass attribute from RFC 4145 [RFC4145].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
役割RFC 4145 [RFC4145]からアクティブ/パッシブ/ actpass属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
candidates One or more ICE candidate values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
候補者一つ以上のICE候補値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application using the connection that is set up with this request is responsible for providing traffic of sufficient frequency to keep the NAT and Firewall binding alive. Applications will often send traffic every 25 seconds to ensure this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この要求で設定された接続を使用しているアプリケーションは、NATを維持するために十分な周波数のトラフィックを提供し、ファイアウォールが生きて結合する責任があります。アプリケーションは、多くの場合、これを確実にするために25秒ごとにトラフィックを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2.2。レスポンスの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a peer receives an AppAttach request, it SHOULD process the request and generate its own response with a AppAttachAns. It should then begin ICE checks. When a peer receives an AppAttach response, it SHOULD parse the response and begin its own ICE checks. If the Application ID is not supported, the peer MUST reply with an Error_Not_Found error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがAppAttach要求を受信した場合、その要求を処理しAppAttachAnsを持つ独自の応答を生成する必要があります。その後、ICEのチェックを開始する必要があります。ピアがAppAttach応答を受信すると、応答を解析し、独自のICEチェックを開始する必要があります。アプリケーションIDがサポートされていない場合、ピアはERROR_NOT_FOUNDエラーで応答しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          opaque                  ufrag&lt;0..2^8-1&gt;;
          opaque                  password&lt;0..2^8-1&gt;;
          uint16                  application;
          opaque                  role&lt;0..2^8-1&gt;;
          IceCandidate            candidates&lt;0..2^16-1&gt;;
        } AppAttachAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meaning of the fields is the same as in the AppAttachReq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールドの意味はAppAttachReqと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3. Ping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3.  Pingの
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ping is used to test connectivity along a path. A ping can be addressed to a specific Node-ID, to the peer controlling a given location (by using a Resource-ID), or to the wildcard Node-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pingのは、パスに沿って接続性をテストするために使用されます。 pingが（リソース-IDを使用して）、またはワイルドカードノードIDに付与された位置を制御するピアに、特定のノードIDに対処することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3.1。要求定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PingReq structure is used to make a Ping request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PingReq構造は、Ping要求を行うために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          opaque&lt;0..2^16-1&gt; padding;
        } PingReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Ping request is empty of meaningful contents. However, it may contain up to 65535 bytes of padding to facilitate the discovery of overlay maximum packet sizes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ping要求は、意味のある内容の空です。しかし、それはオーバーレイ最大パケットサイズの発見を容易にするために、パディングの最大65535のバイトが含まれていてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3.2。レスポンスの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A successful PingAns response contains the information elements requested by the peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功PingAns応答は、ピアによって要求された情報要素が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
           uint64                 response_id;
           uint64                 time;
         } PingAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PingAns message contains the following elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PingAnsメッセージには、次の要素が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
response_id A randomly generated 64-bit response ID. This is used to distinguish Ping responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランダムに生成された64ビットの応答IDをRESPONSE_ID。これは、pingの応答を区別するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time The time when the Ping response was created, represented in the same way as storage_time, defined in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
時間のPing応答が作成された時間は、7節で定義されたstorage_time、同じ方法で表現しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4. ConfigUpdate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4. あるConfigUpdate
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ConfigUpdate method is used to push updated configuration data across the overlay. Whenever a node detects that another node has old configuration data, it MUST generate a ConfigUpdate request. The ConfigUpdate request allows updating of two kinds of data: the configuration data (Section 6.3.2.1) and the Kind information (Section 7.4.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あるConfigUpdate方法は、オーバーレイ全体で更新された設定データをプッシュするために使用されます。ノードが別のノードが古い構成データを持っていることを検出するたびに、それはあるConfigUpdate要求を発生させなければなりません。構成データ（セクション6.3.2.1）と種類の情報（セクション7.4.1.1）：あるConfigUpdate要求は、2種類のデータの更新を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4.1。要求定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ConfigUpdateReq structure is used to provide updated configuration information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ConfigUpdateReq構造が更新された構成情報を提供するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        enum { invalidConfigUpdateType(0), config(1), kind(2), (255) }
             ConfigUpdateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        typedef uint32           KindId;
        typedef opaque           KindDescription&lt;0..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          ConfigUpdateType       type;
          uint32                 length;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
select (type) { case config: opaque config_data&lt;0..2^24-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
（タイプ）{ケースの設定選択：不透明CONFIG_DATA &lt;0..2 ^ 24-1&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
case kind: KindDescription kinds&lt;0..2^24-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
ケースの種類：KindDescriptionの種類&lt;0..2 ^ 24-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            /* This structure may be extended with new types */
          };
        } ConfigUpdateReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ConfigUpdateReq message contains the following elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ConfigUpdateReqメッセージには、次の要素が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The type of the contents of the message. This structure allows for unknown content types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージの内容の種類を入力します。この構造は、未知のコンテンツタイプが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length of the remainder of the message. This is included to preserve backward compatibility and is 32 bits instead of 24 to facilitate easy conversion between network and host byte order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長メッセージの残りの長さ。これは、下位互換性を維持するために含まれ、代わりに24の32ビットがネットワークとホストバイトオーダーとの間の容易な変換を容易にするためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
config_data (type==config) The contents of the Configuration Document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONFIG_DATA（タイプ==設定）設定文書の内容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kinds (type==kind) One or more XML kind-block productions (see Section 11.1). These MUST be encoded with UTF-8 and assume a default namespace of &#34;urn:ietf:params:xml:ns:p2p:config-base&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類（タイプ==一種）は、1つまたは複数のXML種類ブロックプロダクション（11.1節を参照してください）。これらは、UTF-8でエンコードされ、 &#34;壷：IETF：のparams：XML：NS：P2Pます。config-ベース&#34; のデフォルトの名前空間を想定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4.2。レスポンスの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ConfigUpdateAns structure is used to respond to a ConfigUpdateReq request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ConfigUpdateAns構造はConfigUpdateReq要求に応答するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
        } ConfigUpdateAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the ConfigUpdateReq is of type &#34;config&#34;, it MUST be processed only if all the following are true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
：ConfigUpdateReqはタイプ「設定」である場合、すべて、以下に該当する場合にのみ、処理しなければなりません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The sequence number in the document is greater than the current configuration sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O文書内のシーケンス番号は、現在のコンフィギュレーション・シーケンス番号よりも大きいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Configuration Document is correctly digitally signed (see Section 11 for details on signatures).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O設定文書が正しくデジタル（署名の詳細については、セクション11を参照）が署名されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, appropriate errors MUST be generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そうでない場合、適切なエラーが生成されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the ConfigUpdateReq is of type &#34;kind&#34;, it MUST be processed only if it is correctly digitally signed by an acceptable Kind signer (i.e., one listed in the current configuration file). Details on the kind-signer field in the configuration file are described in Section 11.1. In addition, if the Kind update conflicts with an existing known Kind (i.e., it is signed by a different signer), then it should be rejected with an Error_Forbidden error. This should not happen in correctly functioning overlays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ConfigUpdateReqタイプ「種類」である場合、それが正しくデジタル的に許容される種類署名者により署名されている場合、それは唯一の処理されなければならない（すなわち、現在の設定ファイルにリストされているもの）。設定ファイルの種類、署名者のフィールドの詳細については、セクション11.1で説明されています。加えて、既存の知られている種類（すなわち、それは異なる署名者によって署名されている）を有する種類の更新の競合場合、それはError_Forbiddenエラーで拒否されるべきです。これが正常に機能オーバーレイでは発生しないはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the update is acceptable, then the node MUST reconfigure itself to match the new information. This may include adding permissions for new Kinds, deleting old Kinds, or even, in extreme circumstances, exiting and re-entering the overlay, if, for instance, the DHT algorithm has changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更新が許容可能である場合、ノードは、新しい情報に一致するように自分自身を再構成する必要があります。これは、例えば、DHTアルゴリズムが変更された場合など、新たな種類のアクセス権を追加古い種類の削除、あるいは、極端な状況では、オーバーレイを終了し、再入力含むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an implementation misses enough ConfigUpdates that include key changes, it is possible that it will no longer be able to verify new valid ConfigUpdates. In this case, the only available recovery mechanism is to attempt to retrieve a new Configuration Document, typically by the mechanisms used for initial bootstrapping. It is up to implementers whether or how to decide to employ this sort of recovery mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、キーの変更を含め、十分なConfigUpdatesをミスした場合、もはや新しい有効なConfigUpdatesを確認することができなくなる可能性があります。この場合は、のみ利用可能なリカバリメカニズムは、典型的には、初期ブートストラップに使用されるメカニズムによって、新しい設定文書を取得しようとすることです。これは、回復メカニズムのこの種を採用することを決定するために、実装までかどうか方法です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response for ConfigUpdate is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
あるConfigUpdateの応答は空です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. Overlay Link Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. オーバーレイリンク層
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD can use multiple Overlay Link protocols to send its messages. Because ICE is used to establish connections (see Section 6.5.1.3), RELOAD nodes are able to detect which Overlay Link protocols are offered by other nodes and establish connections between them. Any link protocol needs to be able to establish a secure, authenticated connection and to provide data origin authentication and message integrity for individual data elements. RELOAD currently supports three Overlay Link protocols:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADは、そのメッセージを送信するために、複数のオーバーレイ・リンク・プロトコルを使用することができます。 ICEは（セクション6.5.1.3を参照）接続を確立するために使用されているので、RELOADノードは、オーバーレイリンクプロトコルは、他のノードによって提供されると、それらの間の接続を確立しているかを検出することができます。任意のリンクプロトコルは、セキュア、認証された接続を確立するために、個々のデータ要素のためのデータ発信元認証とメッセージの完全性を提供するために、できるようにする必要があります。 RELOADは現在、3つのオーバーレイリンクプロトコルをサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DTLS [RFC6347] over UDP with Simple Reliability (SR) (OverlayLinkType=DTLS-UDP-SR)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単純な信頼性（SR）とUDP上O DTLS [RFC6347]（OverlayLinkType = DTLS-UDP-SR）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TLS [RFC5246] over TCP with Framing Header, No-ICE (OverlayLinkType=TLS-TCP-FH-NO-ICE)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレーミングヘッダ、無氷TCPオーバーO TLS [RFC5246]（OverlayLinkType = TLS-TCP-FH-NO-ICE）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DTLS [RFC6347] over UDP with SR, No-ICE (OverlayLinkType=DTLS-UDP-SR-NO-ICE)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O DTLS SRとUDPオーバー[RFC6347]、無ICE（OverlayLinkType = DTLS-UDP-SR-NO-ICE）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that although UDP does not properly have &#34;connections&#34;, both TLS and DTLS have a handshake that establishes a similar, stateful association. We refer to these as &#34;connections&#34; for the purposes of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPは適切に「接続」を持っていませんが、TLSとDTLSの両方が同様の、ステートフルな関連付けを確立ハンドシェイクを持っていることに注意してください。私たちは、この文書の目的のための「接続」としてこれらを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a peer receives a message that is larger than the value of max-message-size defined in the overlay configuration, the peer SHOULD send an Error_Message_Too_Large error and then close the TLS or DTLS session from which the message was received. Note that this error can be sent and the session closed before the peer receives the complete message. If the forwarding header is larger than the max- message-size, the receiver SHOULD close the TLS or DTLS session without sending an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがオーバーレイ構成で定義された最大メッセージサイズの値よりも大きいメッセージを受信した場合、ピアはError_Message_Too_Largeエラーを送信し、そのメッセージを受信したTLSまたはDTLSセッションを閉じる必要があります。このエラーが送信され、ピアが完全なメッセージを受け取る前にセッションを閉じることができることに注意してください。転送ヘッダは、MAX-メッセージサイズより大きい場合、受信機はエラーを送信することなく、TLSまたはDTLSセッションを閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RELOAD mechanism requires that failed links be quickly removed from the Routing Table so end-to-end retransmission can handle lost messages. Overlay Link protocols MUST be designed with a mechanism that quickly signals a likely failure, and implementations SHOULD quickly act to remove a failed link from the Routing Table when receiving this signal. The entry can be restored if it proves to resume functioning, or it can be replaced at some point in the future if necessary. Section 10.7.2 contains more details specific to the CHORD-RELOAD Topology Plug-in.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADメカニズムが失敗したリンクはすぐにそうエンドツーエンド再送が失われたメッセージを処理することができますルーティングテーブルから削除されている必要があります。オーバーレイリンクプロトコルは迅速おそらく失敗したことを知らせる機構を設計する必要があり、かつ実装が迅速にこの信号を受信した場合にルーティングテーブルから、故障したリンクを削除するように行動しなければなりません。それが機能して再開することを証明している場合は、エントリを復元することができ、または必要であれば、それは将来のある時点で交換することができます。セクション10.7.2は、CHORD-RELOADトポロジプラグインに固有の詳細が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Framing Header (FH) is used to frame messages and provide timing when used on a reliable stream-based transport protocol. Simple Reliability (SR) uses the FH to provide congestion control and partial reliability when using unreliable message-oriented transport protocols. We will first define each of these algorithms in Sections 6.6.2 and 6.6.3, and then define Overlay Link protocols that use them in Sections 6.6.4, 6.6.5, and 6.6.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フレーミングヘッダ（FH）は、メッセージフレームで信頼性の高いストリームベースのトランスポートプロトコルに使用されたときのタイミングを提供するために使用されます。単純な信頼性（SR）は、信頼できないメッセージ指向のトランスポートプロトコルを使用する場合、輻輳制御と部分的信頼性を提供するために、FHを使用します。私たちは、最初のセクション6.6.2と6.6.3でこれらのアルゴリズムのそれぞれを定義し、セクション6.6.4、6.6.5、および6.6.6でそれらを使用するオーバーレイリンクプロトコルを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: We expect future Overlay Link protocols to define replacements for all components of these protocols, including the Framing Header. The three protocols that we will discuss have been chosen for simplicity of implementation and reasonable performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：私たちは、フレーミングヘッダを含むこれらのプロトコルのすべてのコンポーネントのための代替品を定義するために、将来のオーバーレイリンクプロトコルを期待しています。私たちが議論する3つのプロトコルを実装し、妥当なパフォーマンスを簡単にするために選択されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1. Future Overlay Link Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1. 今後のオーバーレイリンクプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible to define new link-layer protocols and apply them to a new overlay using the &#34;overlay-link-protocol&#34; configuration directive (see Section 11.1.). However, any new protocols MUST meet the following requirements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいリンク層プロトコルを定義し、「オーバーレイ・リンク・プロトコル」の設定ディレクティブを使用して、新しいオーバーレイに適用することが可能である（11.1節を参照してください。）。しかし、任意の新しいプロトコルは、次の要件を満たす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoint authentication: When a node forms an association with another endpoint, it MUST be possible to cryptographically verify that the endpoint has a given Node-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイント認証：ノードが別のエンドポイントとのアソシエーションを形成する場合、それはエンドポイントが与えられたノードIDを有していることを確認暗号ことができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Traffic origin authentication and integrity: When a node receives traffic from another endpoint, it MUST be possible to cryptographically verify that the traffic came from a given association and that it has not been modified in transit from the other endpoint in the association. The overlay link protocol MUST also provide replay prevention/detection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トラフィック送信元認証と完全性：ノードが別のエンドポイントからのトラフィックを受信した場合、トラフィックが特定の団体から来て、それが関連して、他のエンドポイントからのトランジットで変更されていないことことを確認し、暗号が可能でなければなりません。オーバーレイ・リンクプロトコルはまた、リプレイ防止/検出を提供しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Traffic confidentiality: When a node sends traffic to another endpoint, it MUST NOT be possible for a third party that is not involved in the association to determine the contents of that traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トラフィックの機密性：ノードが別のエンドポイントにトラフィックを送信すると関連して関与しない第三者がそのトラフィックの内容を決定するために、それが可能にすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any new overlay protocol MUST be defined via Standards Action [RFC5226]. See Section 14.11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての新しいオーバーレイプロトコルが標準化アクション[RFC5226]で定義されなければなりません。セクション14.11を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.1. HIP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.1。 HIP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a Host Identity Protocol Based Overlay Networking Environment (HIP BONE) [RFC6079], HIP [RFC5201] provides connection management (e.g., NAT traversal and mobility) and security for the overlay network. The P2PSIP Working Group has expressed interest in supporting a HIP-based link protocol. Such support would require specifying such details as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホストアイデンティティプロトコルベースのオーバレイネットワーク環境（寛骨）[RFC6079]、HIP [RFC5201]にオーバーレイ・ネットワークの接続管理（例えば、NATトラバーサル及び移動度）とセキュリティを提供します。 P2PSIPワーキンググループでは、HIPベースのリンクプロトコルをサポートすることに関心を表明しています。このようなサポートは、このような詳細を指定する必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o How to issue certificates which provide identities meaningful to the HIP base exchange. We anticipate that this would require a mapping between Overlay Routable Cryptographic Hash Identifiers (ORCHIDs) and NodeIds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O HIPベース交換に意味のあるIDを提供証明書を発行する方法。これはオーバーレイルーティング可能な暗号学的ハッシュ識別子（蘭）とノード識別子との間のマッピングが必要となることを期待しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o How to carry the HIP I1 and I2 messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O HIP I1とI2のメッセージを伝える方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o How to carry RELOAD messages over HIP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O HIP上RELOADメッセージを伝える方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HIP-RELOAD] documents work in progress on using RELOAD with the HIP BONE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HIP-RELOAD]文書は、股関節の骨とRELOADを使用して進行中の作業します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.2. ICE-TCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.2。 ICE-TCP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ICE-TCP RFC [RFC6544] allows TCP to be supported as an Overlay Link protocol that can be added using ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICE-TCP RFC [RFC6544]はTCPがICEを使用して追加することができるオーバーレイリンク・プロトコルとしてサポートすることを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.3. Message-Oriented Transports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.3。メッセージ指向トランスポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Modern message-oriented transports offer high performance and good congestion control, and they avoid head-of-line blocking in case of lost data. These characteristics make them preferable as underlying transport protocols for RELOAD links. SCTP without message ordering and DCCP are two examples of such protocols. However, currently they are not well-supported by commonly available NATs, and specifications for ICE session establishment are not available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
近代的なメッセージ指向のトランスポートは、高い性能と優れた輻輳制御を提供し、彼らは失われたデータの場合にはヘッドオブラインブロッキングを避けます。これらの特性は、RELOADリンクの基礎となるトランスポートプロトコル、それらに好適にします。メッセージの順序とDCCPのないSCTPは、そのようなプロトコルの2つの例です。しかし、現在、彼らは一般的に利用可能なNATのことで、よくサポートされていない、とICEのセッション確立のための仕様は使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.4. Tunneled Transports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.4。トンネル化トランスポート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As of the time of this writing, there is significant interest in the IETF community in tunneling other transports over UDP, which is motivated by the situation that UDP is well-supported by modern NAT hardware and by the fact that performance similar to a native implementation can be achieved. Currently, SCTP, DCCP, and a generic tunneling extension are being proposed for message-oriented protocols. Once ICE traversal has been specified for these tunneled protocols, they should be straightforward to support as overlay link protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これを書いている時点では、ネイティブ実装と同等の性能UDPは、近代的なNATのハードウェアによって、実際によくサポートされている状況によって動機づけされるUDP、オーバートンネリング他のトランスポートでのIETFコミュニティに大きな関心があります達成することができます。現在、SCTP、DCCP、および一般的なトンネリングの拡張子は、メッセージ指向のプロトコルのために提案されています。 ICEトラバーサルは、これらのトンネリングプロトコル用に指定されていたら、彼らはのように、オーバーレイリンクプロトコルをサポートするのは簡単でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.2. Framing Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.2. フレーミングヘッダー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to support unreliable links and to allow for quick detection of link failures when using reliable end-to-end transports, each message is wrapped in a very simple framing layer (FramedMessage), which is used only for each hop. This layer contains a sequence number which can then be used for ACKs. The same header is used for both reliable and unreliable transports for simplicity of implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
信頼できないリンクをサポートし、信頼性の高いエンドツーエンドのトランスポートを使用している場合、リンク障害の迅速な検出を可能にするために、各メッセージは、唯一の各ホップのために使用されている非常にシンプルなフレーミング層（FramedMessage）、に包まれています。この層は、その後のACKのために使用することができるシーケンス番号が含まれています。同じヘッダは、実装を簡単にするために信頼性が高く信頼性の低いトランスポートの両方に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definition of FramedMessage is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FramedMessageの定義は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        enum { data(128), ack(129), (255) } FramedMessageType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          FramedMessageType       type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          select (type) {
            case data:
              uint32              sequence;
              opaque              message&lt;0..2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            case ack:
              uint32              ack_sequence;
              uint32              received;
          };
        } FramedMessage;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The type field of the PDU is set to indicate whether the message is data or an acknowledgement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PDUのタイプフィールドは、メッセージがデータ又は確認応答であるかどうかを示すために設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the message is of type &#34;data&#34;, then the remainder of the PDU is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージのタイプが「データ」である場合、次のようにPDUの残りの部分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequence The sequence number. This increments by one for each framed message sent over this transport session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号をシーケンス。これは、このトランスポート・セッションを介して送信される各フレームのメッセージに1つずつ増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
message The message that is being transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージが送信されるメッセージ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each connection has it own sequence number space. Initially, the value is zero, and it increments by exactly one for each message sent over that connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各接続は、それ自身のシーケンス番号空間があります。最初に、値はゼロであり、それは、その接続を介して送信されるメッセージごとに正確に1つ増分します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the receiver receives a message, it SHOULD immediately send an ACK message. The receiver MUST keep track of the 32 most recent sequence numbers received on this association in order to generate the appropriate ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信者がメッセージを受信すると、それはすぐにACKメッセージを送るべきです。受信機は、適切なACKを生成するために、この関連で受信された32個の最新のシーケンス番号を追跡する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the PDU is of type &#34;ack&#34;, the contents are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PDUはタイプ「ACK」である場合は、次のように内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ack_sequence The sequence number of the message being acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認知されたメッセージのシーケンス番号をack_sequence。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
received A bitmask indicating if each of the previous 32 sequence numbers before this packet has been among the 32 packets most recently received on this connection. When a packet is received with a sequence number N, the receiver looks at the sequence number of the 32 previously received packets on this connection. We call the previously received packet number M. For each of the previous 32 packets, if the sequence number M is less than N but greater than N-32, the N-M bit of the received bitmask is set to one; otherwise, it is set to zero. Note that a bit being set to one indicates positively that a particular packet was received, but a bit being set to zero means only that it is unknown whether or not the packet has been received, because it might have been received before the 32 most recently received packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以前の32個のシーケンス番号のそれぞれは、このパケットは最も最近、この接続上で受信されたパケットのうち32される前かどうかを示すビットマスクを受信しました。パケットは、シーケンス番号Nで受信された場合、受信機は、この接続上で32の以前に受信したパケットのシーケンス番号を調べ。シーケンス番号MがNよりも小さいが、N-32よりも大きい場合、我々は、受信したビットマスクのN-Mビットが1にセットされ、前の32のパケットの各々について、以前に受信したパケットの数Mを呼び出します。それ以外の場合はゼロに設定されています。 1に設定されているビットは、特定のパケットを受信したことを確実に示しますが、ゼロに設定されているビットは、それが最近32前に受信されている場合がありますので、パケットを受信したか否かは不明であるだけ、ということを意味します受信したパケット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The received field bits in the ACK provide a high degree of redundancy so that the sender can figure out which packets the receiver has received and can then estimate packet loss rates. If the sender also keeps track of the time at which recent sequence numbers have been sent, the RTT (round-trip time) can be estimated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者が受信した受信機をパケットと、パケット損失率を推定することができる把握できるように、ACKにおける受信電界ビットは、冗長性の高い程度を提供します。送信者はまた、最近のシーケンス番号が送られてきたした時間を追跡した場合は、RTT（ラウンドトリップ時間）を推定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that because retransmissions receive new sequence numbers, multiple ACKs may be received for the same message. This approach provides more information than traditional TCP sequence numbers, but care must be taken when applying algorithms designed based on TCP&#39;s stream-oriented sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再送信は、新しいシーケンス番号を受け取るために、複数のACKが同じメッセージのために受信することができることに注意してください。このアプローチは、従来のTCPシーケンス番号よりも多くの情報を提供しますが、TCPのストリーム指向のシーケンス番号に基づいて設計されたアルゴリズムを適用する際には注意が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.3. Simple Reliability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.3. シンプルな信頼性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When RELOAD is carried over DTLS or another unreliable link protocol, it needs to be used with a reliability and congestion control mechanism, which is provided on a hop-by-hop basis. The basic principle is that each message, regardless of whether or not it carries a request or response, will get an ACK and be reliably retransmitted. The receiver&#39;s job is very simple, and is limited to just sending ACKs. All the complexity is at the sender side. This allows the sending implementation to trade off performance versus implementation complexity without affecting the wire protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードがDTLSまたは別の信頼できないリンクプロトコルを介して搬送されるとき、それはホップバイホップベースで提供される信頼性と輻輳制御機構と共に使用する必要があります。基本的な原理は、各メッセージが、関係なく、それは、要求または応答を運ぶかどうかの、ACKを取得し、確実に再送信されるということです。受信機の仕事は非常に簡単で、単にACKを送信することに限定されています。すべての複雑さは、送信側です。これは、送信の実装は、ワイヤプロトコルに影響を与えることなく、実装の複雑さ対性能のトレードオフすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the receiver&#39;s role is limited to providing packet acknowledgements, a wide variety of congestion control algorithms can be implemented on the sender side while using the same basic wire protocol. The sender algorithm used MUST meet the requirements of [RFC5405].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機の役割がパケットの確認応答を提供することに限られているため、同じ基本的なワイヤプロトコルを使用しながら、輻輳制御アルゴリズムの多様な送信側で実現することができます。 [RFC5405]の要件を満たす必要があります使用差出人アルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.3.1. Stop and Wait Sender Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.3.1。送信者のアルゴリズムを停止して待って
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes one possible implementation of a sender algorithm for Simple Reliability. It is adequate for overlays running on underlying networks with low latency and loss (LANs) or low-traffic overlays on the Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、簡単な信頼性のために、送信者のアルゴリズムの一つの可能​​な実装について説明します。これは、インターネット上で低遅延と損失（のLAN）または低トラフィックのオーバーレイを持つネットワークの基礎となる上で実行されているオーバーレイには十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node MUST NOT have more than one unacknowledged message on the DTLS connection at a time. Note that because retransmissions of the same message are given new sequence numbers, there may be multiple unacknowledged sequence numbers in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードは、一度にDTLS接続で複数の未確認のメッセージを持ってはいけません。同じメッセージの再送が新しいシーケンス番号が付与されているので、使用中の複数の未確認のシーケンス番号があるかもしれないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTO (Retransmission TimeOut) is based on an estimate of the RTT. The value for RTO is calculated separately for each DTLS session. Implementations can use a static value for RTO or a dynamic estimate, which will result in better performance. For implementations that use a static value, the default value for RTO is 500 ms. Nodes MAY use smaller values of RTO if it is known that all nodes are within the local network. The default RTO MAY be set to a larger value, which is RECOMMENDED if it is known in advance (such as on high-latency access links) that the RTT is larger.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTO（再送タイムアウト）RTTの推定値に基づいています。 RTOの値は、各DTLSセッションに対して別々に計算されます。実装は、より良い性能をもたらすRTOまたは動的推定のために静的な値を、使用することができます。静的な値を使用して実装するため、RTOのデフォルト値は500ミリ秒です。すべてのノードがローカルネットワーク内にあることが知られている場合、ノードは、RTOの小さい値を使用することができます。デフォルトRTOは、RTTが大きいこと（このような高レイテンシアクセスリンク上など）が予め分かっている場合に推奨されるより大きな値とすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations that use a dynamic estimate to compute the RTO MUST use the algorithm described in RFC 6298 [RFC6298], with the exception that the value of RTO SHOULD NOT be rounded up to the nearest second, but instead rounded up to the nearest millisecond. The RTT of a successful STUN transaction from the ICE stage is used as the initial measurement for formula 2.2 of RFC 6298. The sender keeps track of the time each message was sent for all recently sent messages. Any time an ACK is received, the sender can compute the RTT for that message by looking at the time the ACK was received and the time when the message was sent. This is used as a subsequent RTT measurement for formula 2.3 of RFC 6298 to update the RTO estimate. (Note that because retransmissions receive new sequence numbers, all received ACKs are used.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTOを計算するために動的推定値を使用する実装はRTOの値は最も近い秒に丸め、その代わりに、最も近いミリ秒単位に切り上げされるべきではないことを除いて、RFC 6298 [RFC6298]に記載されたアルゴリズムを使用しなければなりません。 ICE段階から成功したSTUNトランザクションのRTTは、RFC 6298.の式2.2送信者が各メッセージはすべて、最近送信されたメッセージを送った時間を追跡のための初期測定値として使用されます。 ACKが受信されるときはいつでも、送信側はACKを受信した時刻とメッセージが送信された時点で見ることにより、そのメッセージのRTTを計算することができます。これはRTO推定値を更新するために、RFC 6298の式2.3のための後続のRTT測定値として使用されます。 （再送信は、新しいシーケンス番号を受け取るために、受信したすべてのACKが使用されていることに注意してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An initiating node SHOULD retransmit a message if it has not received an ACK after an interval of RTO (transit nodes do not retransmit at this layer). The node MUST double the time to wait after each retransmission. For each retransmission, the sequence number MUST be incremented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはRTOの間隔（トランジットノードは、この層で再送信していない）の後にACKを受信しなかった場合、開始ノードがメッセージを再送信すべきです。ノードは、各再送信後の待機時間を倍にしなければなりません。各再送信のために、シーケンス番号がインクリメントされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Retransmissions continue until a response is received, until a total of 5 requests have been sent, until there has been a hard ICMP error [RFC1122], or until a TLS alert indicating the end of the connection has been sent or received. The sender knows a response was received when it receives an ACK with a sequence number that indicates it is a response to one of the transmissions of this message. For example, assuming an RTO of 500 ms, requests would be sent at times 0 ms, 500 ms, 1500 ms, 3500 ms, and 7500 ms. If all retransmissions for a message fail, then the sending node SHOULD close the connection routing the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答が受信されるまで、ハードICMPエラー[RFC1122]があったまで5つの要求の合計は、送信されるまで、または接続の終了を示すTLSアラートが送信または受信されるまで再送信は、継続します。送信者は、それはそれは、このメッセージの送信の1への応答であることを示しているシーケンス番号を持つACKを受信したときに応答が受信された知っています。例えば、500ミリ秒のRTOを仮定すると、要求は時間0ミリ秒、500ミリ秒、1500ミリ秒、3500ミリ秒、7500ミリ秒で送信されることになります。メッセージのすべての再送信が失敗した場合、送信ノードは、メッセージをルーティングする接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To determine when a link might be failing without waiting for the final timeout, observe when no ACKs have been received for an entire RTO interval, and then wait for three retransmissions to occur beyond that point. If no ACKs have been received by the time the third retransmission occurs, it is RECOMMENDED that the link be removed from the Routing Table. The link MAY be restored to the Routing Table if ACKs resume before the connection is closed, as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リンクは、最終的なタイムアウトを待たずに失敗する可能性がある場合を判断するには、no ACKが全体のRTO間隔のために受信していないし、そのポイントを超えて発生するために、3つの再送信を待つされていたときに観察します。何らのACKが3回目の再送が発生した時間によって受信されていない場合は、リンクはルーティングテーブルから削除することを推奨されています。接続前のACK再開が閉じている場合、上述のように、リンクは、ルーティングテーブルを復元することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender MUST wait 10 ms between receipt of an ACK and transmission of the next message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信側は、ACKを受信すると、次のメッセージの送信の間に10ミリ秒待たなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.4. DTLS/UDP with SR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.4.  SRとDTLS / UDP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This overlay link protocol consists of DTLS over UDP while implementing the SR protocol. STUN connectivity checks and keepalives are used. Any compliant sender algorithm may be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SRプロトコルを実装しながら、このオーバーレイリンクプロトコルはUDP上でDTLSで構成されています。 STUN接続性チェックとキープアライブが使用されています。どれ準拠した送信者のアルゴリズムを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.5. TLS/TCP with FH, No-ICE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.5.  FH、無ICEとのTLS / TCP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This overlay link protocol consists of TLS over TCP with the framing header. Because ICE is not used, STUN connectivity checks are not used upon establishing the TCP connection, nor are they used for keepalives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオーバーレイ・リンク・プロトコルは、フレーミングヘッダとTCP上TLSから成ります。 ICEが使用されていないので、STUNの接続性チェックは、TCP接続を確立するときに使用されていない、また彼らは、キープアライブのために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the TCP layer&#39;s application-level timeout is too slow to be useful for overlay routing, the Overlay Link implementation MUST use the framing header to measure the RTT of the connection and calculate an RTO as specified in Section 2 of [RFC6298]. The resulting RTO is not used for retransmissions, but rather as a timeout to indicate when the link SHOULD be removed from the Routing Table. It is RECOMMENDED that such a connection be retained for 30 seconds to determine if the failure was transient before concluding the link has failed permanently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPレイヤのアプリケーションレベルのタイムアウトがオーバーレイルーティングのために有用であるには余りにも遅いため、オーバーレイリンクの実装は、[RFC6298]のセクション2で指定されるように接続のRTTを測定し、RTOを算出するフレーミングヘッダを使用しなければなりません。得られたRTOは再送のためではなく、リンクはルーティングテーブルから除去されるべきであるときを示すためのタイムアウトとして使用されていません。障害がリンクを締結する前に、一過性でかどうかを判断するために30秒間保持され、このような接続は永久に失敗したことが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When sending candidates for TLS/TCP with FH, No-ICE, a passive candidate MUST be provided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FH、無ICEとのTLS / TCPの候補を送信する場合、パッシブ候補が提供されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.6. DTLS/UDP with SR, No-ICE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.6.  SRとDTLS / UDP、無ICE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This overlay link protocol consists of DTLS over UDP while implementing the Simple Reliability protocol. Because ICE is not used, no STUN connectivity checks or keepalives are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シンプルな信頼性プロトコルを実装しながら、このオーバーレイリンクプロトコルはUDP上でDTLSで構成されています。 ICEが使用されていないので、何のSTUNの接続性チェックやキープアライブは使用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7. Fragmentation and Reassembly
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7. フラグメンテーションおよび再構成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to allow transmission over datagram protocols such as DTLS, RELOAD messages may be fragmented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えばDTLSとしてデータグラムプロトコル上での伝送を可能にするために、リロードメッセージを断片化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any node along the path can fragment the message, but only the final destination reassembles the fragments. When a node takes a packet and fragments it, each fragment has a full copy of the forwarding header, but the data after the forwarding header is broken up into appropriately sized chunks. The size of the payload chunks needs to take into account space to allow the Via and Destination Lists to grow. Each fragment MUST contain a full copy of the Via List, Destination List, and ForwardingOptions and MUST contain at least 256 bytes of the message body. If these elements cannot fit within the MTU of the underlying datagram protocol, RELOAD fragmentation is not performed, and IP-layer fragmentation is allowed to occur. The length field MUST contain the size of the message after fragmentation. When a message MUST be fragmented, it SHOULD be split into equal-sized fragments that are no larger than the Path MTU (PMTU) of the next overlay link minus 32 bytes. This is to allow the Via List to grow before further fragmentation is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
経路に沿った任意のノードは、メッセージを断片化することができるが、唯一の最終的な宛先は、断片を再構成します。ノードがパケットおよびフラグメントをとるとき、各フラグメントは、転送ヘッダの完全なコピーを有しているが、転送ヘッダの後のデータは適切なサイズのチャンクに分割されます。ペイロードチャンクのサイズは、ビアと宛先リストが成長できるように、アカウントのスペースを考慮する必要があります。各フラグメントは経由リスト、送信先リスト、およびForwardingOptionsの完全なコピーを含まなければならないし、メッセージ本体の少なくとも256のバイトを含まなければなりません。これらの要素は、基礎となるデータグラムプロトコルのMTUに収まることができない場合は、RELOADの断片化は行われず、IP層の断片化が発生することが許可されています。長さフィールドは、断片化した後、メッセージのサイズを含まなければなりません。メッセージが断片化する必要がある場合、それは次のオーバーレイリンクマイナス32バイトのパスMTU（PMTU）よりも大きくない同じサイズの断片に分割されるべきです。これは、さらに断片化が必要とされる前に、経由リストが成長できるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this fragmentation is not optimal for the end-to-end path -- a message may be refragmented multiple times as it traverses the overlay, but it is assembled only at the final destination. This option has been chosen as it is far easier to implement than end-to-end (e2e) PMTU discovery across an ever-changing overlay and it effectively addresses the reliability issues of relying on IP-layer fragmentation. However, Ping can be used to allow e2e PMTU discovery to be implemented if desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この断片化は、エンドツーエンドのパスのための最適ではないことに注意してください - メッセージは、オーバーレイを横断するように複数回refragmentedてもよいが、それが唯一の最終目的地で組み立てられます。刻々と変化するオーバーレイ全体のエンド・ツー・エンド（E2E）PMTU発見よりも実装がはるかに簡単であるため、このオプションが選択されていて、それが効果的にIP層の断片化に頼るの信頼性の問題に対処しています。ただし、Pingが必要であればE2E PMTU検出を実施することができるようにするために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receipt of a fragmented message by the intended peer, the peer holds the fragments in a holding buffer until the entire message has been received. The message is then reassembled into a single message and processed. In order to mitigate denial-of-service (DoS) attacks, receivers SHOULD time out incomplete fragments after the maximum request lifetime (15 seconds). This time was derived from looking at the end-to-end retransmission time and saving fragments long enough for the full end-to-end retransmissions to take place. Ideally, the receiver would have enough buffer space to deal with as many fragments as can arrive in the maximum request lifetime. However, if the receiver runs out of buffer space to reassemble a message, it MUST drop the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ全体が受信されるまで意図ピアによって断片化されたメッセージを受信すると、ピアは、保持バッファ内の断片を保持します。メッセージが単一のメッセージに再構築され処理されます。サービス拒否（DoS）攻撃を軽減するために、受信機は、最大要求寿命（15秒）の後に、不完全な断片をタイムアウトすべきです。この時間は、エンドツーエンドの再送信時間を見て、完全なエンドツーエンドの再送信が行われるようにするために十分な長さの断片を保存するに由来するものでした。理想的には、受信機は、最大要求寿命に到着できる限り多くの断片に対処するために十分なバッファ領域を持っているでしょう。受信者がメッセージを再構築するために、バッファ領域が不足している場合しかし、それはメッセージを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fragment field of the forwarding header is used to encode fragmentation information. The offset is the number of bytes between the end of the forwarding header and the start of the data. The first fragment therefore has an offset of 0. The last fragment indicator MUST be appropriately set. If the message is not fragmented, it is simply treated as if it is the only fragment: the last fragment bit is set and the offset is 0, resulting in a fragment value of 0xC0000000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
転送ヘッダのフラグメント領域は断片化情報を符号化するために使用されます。オフセットは、転送ヘッダの終わりとデータの開始との間のバイト数です。最初のフラグメントは、したがって最後のフラグメント指標を適切に設定する必要があり、0のオフセットを有します。 0xC0000000の断片値が得られ、0最後のフラグメントビットがセットされ、オフセットである：メッセージが断片化されていない場合、それが唯一のフラグメントであるかのように、単に処理されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The reason for this definition of the fragment field is that originally, the high bit was defined in part of the specification as &#34;is fragmented&#34;, so there was some specification ambiguity about how to encode messages with only one fragment. This ambiguity was resolved in favor of always encoding as the &#34;last&#34; fragment with offset 0, thus simplifying the receiver code path, but resulting in the high bit being redundant. Because messages MUST be set with the high bit set to 1, implementations SHOULD discard any message with it set to 0. Implementations (presumably legacy ones) which choose to accept such messages MUST either ignore the remaining bits or ensure that they are 0. They MUST NOT try to interpret as fragmented messages with the high bit set low.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：フラグメントフィールドのこの定義理由は本来、高ビットが「断片化されている」と本明細書の一部に定義されているので、一つの断片でメッセージをエンコードする方法のいくつかの仕様の曖昧さが存在したということです。この曖昧さは、このように受信機のコードパスを簡略化するが、高ビットが冗長であることになり、オフセット0で常に「最後」断片としてコードを支持して解決しました。メッセージが1に設定された高ビットで設定しなければならないので、それは残りのビットを無視するか、確保しなければならないのいずれかで、このようなメッセージを受け入れることを選択0実装（おそらく従来のもの）に設定し、実装は、それらが0であることを、任意のメッセージを破棄すべきである彼ら低設定された高ビットと同じように断片化されたメッセージを解釈しようとしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Data Storage Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.データストレージプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD provides a set of generic mechanisms for storing and retrieving data in the Overlay Instance. These mechanisms can be used for new applications simply by defining new code points and a small set of rules. No new protocol mechanisms are required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードがオーバーレイインスタンスにデータを格納し検索するための一般的な機構のセットを提供します。これらのメカニズムは単に新しいコードポイントとルールの小さなセットを定義することにより、新たな用途に使用することができます。新しいプロトコルメカニズムは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic unit of stored data is a single StoredData structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
格納されたデータの基本単位は、単一StoredData構造です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          uint32                  length;
          uint64                  storage_time;
          uint32                  lifetime;
          StoredDataValue         value;
          Signature               signature;
        } StoredData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにこの構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The size of the StoredData structure, in bytes, excluding the size of length itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さ自体のサイズを除くバイト長StoredData構造のサイズ、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
storage_time The time when the data was stored, represented as the number of milliseconds elapsed since midnight Jan 1, 1970 UTC, not counting leap seconds. This will have the same values for seconds as standard UNIX or POSIX time. More information can be found at [UnixTime]. Any attempt to store a data value with a storage time before that of a value already stored at this location MUST generate an Error_Data_Too_Old error. This prevents rollback attacks. The node SHOULD make a best-effort attempt to use a correct clock to determine this number. However, the protocol does not require synchronized clocks: the receiving peer uses the storage time in the previous store, not its own clock. Clock values are used so that when clocks are generally synchronized, data may be stored in a single transaction, rather than querying for the value of a counter before the actual store.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データが格納されていた時間をstorage_time、うるう秒をカウントしない、深夜1970年1月1日UTCからの経過ミリ秒数として表現。これは、標準のUNIXまたはPOSIX時間秒に同じ値を持つことになります。詳しくは、[UnixTime]で見ることができます。既にこの場所に格納された値の前の蓄積時間でデータ値を格納しようとすると、Error_Data_Too_Oldエラーが発生しなければなりません。これは、ロールバック攻撃を防ぐことができます。ノードは、この番号を決定するために、正しいクロックを使用するためのベストエフォート型試みを行う必要があります。しかし、このプロトコルは同期したクロックを必要としない：受信ピアは、前の店ではなく、自身のクロックで蓄積時間を使用しています。クロックは、一般的に同期している場合、データはなく、実際の店舗の前にカウンタの値をクエリよりも、単一のトランザクション内に格納することができるように、クロックの値が使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If a node attempting to store new data in response to a user request (rather than as an overlay maintenance operation such as occurs when healing the overlay from a partition) is rejected with an Error_Data_Too_Old error, the node MAY elect to perform its store using a storage_time that increments the value used with the previous store (this may be obtained by doing a Fetch). This situation may occur when the clocks of nodes storing to this location are not properly synchronized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（そのようなパーティションからオーバーレイを治癒するときに発生としてではなく、オーバーレイ・メンテナンス操作のような）ユーザ要求に応答して新たなデータを格納しようとするノードがError_Data_Too_Oldエラーで拒否された場合、ノードが使用して、ストアを実行することを選択することができます以前のストア（これはフェッチを行うことによって得ることができる）で使用される値をインクリメントstorage_time。この場所に格納するノードのクロックが適切に同期されていない場合、このような状況が発生することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lifetime The validity period for the data, in seconds, starting from the time the peer receives the StoreReq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
寿命データの有効期間は、秒単位で、ピアがStoreReqを受信した時点から始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
value The data value itself, as described in Section 7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.2で説明したように、データ値自体を重視。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature A signature, as defined in Section 7.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.1で定義されるように署名の署名、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each Resource-ID specifies a single location in the Overlay Instance. However, each location may contain multiple StoredData values, distinguished by Kind-ID. The definition of a Kind describes both the data values which may be stored and the data model of the data. Some data models allow multiple values to be stored under the same Kind-ID. Section 7.2 describes the available data models. Thus, for instance, a given Resource-ID might contain a single-value element stored under Kind-ID X and an array containing multiple values stored under Kind-ID Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各リソース-IDは、オーバーレイインスタンス内の単一の場所を指定します。しかし、各位置は親切-IDによって識別複数StoredData値を含んでいてもよいです。種類の定義が格納され得るデータ値及びデータのデータ・モデルの両方を記載しています。一部のデータモデルは、複数の値が同じ種類-IDの下で保存することを可能にします。 7.2節では、利用可能なデータモデルについて簡単に説明します。したがって、例えば、特定のリソース-IDは親切-ID Y.下で保存種類-ID X下で保存単一値要素と複数の値を含む配列を含むかもしれません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Data Signature Computation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. データ署名の計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each StoredData element is individually signed. However, the signature also must be self-contained and must cover the Kind-ID and Resource-ID, even though they are not present in the StoredData structure. The input to the signature algorithm is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各StoredData要素を個別に署名されています。ただし、署名はまた、彼らはStoredData構造に存在しないにもかかわらず、自己完結型でなければならず、種類-IDとリソースIDをカバーしなければなりません。署名アルゴリズムに入力されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
resource_id || kind || storage_time || StoredDataValue || SignerIdentity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RESOURCE_ID ||種類|| storage_time || StoredDataValue || SignerIdentity
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where || indicates concatenation and where these values are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どこ||連結を示し、これらの値は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource_id The Resource-ID where this data is stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このデータが格納されているリソース-IDをRESOURCE_ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind-ID for this data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類このデータの種類-ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
storage_time The contents of the storage_time data value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
storage_timeデータ値の内容をstorage_time。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StoredDataValue The contents of the stored data value, as described in the previous sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前のセクションで説明したように、記憶されたデータ値の内容をStoredDataValue。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SignerIdentity The signer identity, as defined in Section 6.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6.3.4項で定義されているようSignerIdentity署名者の身元、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the signature has been computed, the signature is represented using a signature element, as described in Section 6.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名が計算されると、セクション6.3.4に記載したように、署名は、署名要素を用いて表現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there is no necessary relationship between the validity window of a certificate and the expiry of the data it is authenticating. When signatures are verified, the current time MUST be compared to the certificate validity period. Stored data MAY be set to expire after the signing certificate&#39;s validity period. Such signatures are not considered valid after the signing certificate expires. Implementations may &#34;garbage collect&#34; such data at their convenience, either by purging it automatically (perhaps by setting the upper bound on data storage to the lifetime of the signing certificate) or by simply leaving it in place until it expires naturally and relying on users of that data to notice the expired signing certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書の有効性ウィンドウとそれが認証しているデータの有効期限の間に必要な関係が存在しないことに注意してください。署名が検証される場合、現在時刻が証明書の有効期間と比較されなければなりません。保存されたデータは、署名証明書の有効期間後に失効するように設定することができます。署名証明書の有効期限が切れた後にこのような署名が有効と見なされません。実装は（おそらく署名証明書の有効期間にデータストレージの上限を設定することで）自動的にパージすることによって、あるいは単にそれが自然に切れるまでの場所でそれを残して、ユーザーに頼るのいずれかによって、自分の都合の良いときに、このようなデータを「ごみ収集」も期限切れの署名証明書を気づくためにそのデータの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Data Models
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. データモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol currently defines the following data models:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルは、現在、以下のデータモデルを定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o single value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一の値O
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o array
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o dictionary
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O辞書
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These are represented with the StoredDataValue structure. The actual data model is known from the Kind being stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらは、StoredDataValue構造で表現されています。実際のデータモデルが格納されている種類から知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          Boolean                exists;
          opaque                 value&lt;0..2^32-1&gt;;
        } DataValue;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          select (DataModel) {
            case single_value:
              DataValue             single_value_entry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            case array:
              ArrayEntry            array_entry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
case dictionary: DictionaryEntry dictionary_entry;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
ケース辞書：DictionaryEntryのdictionary_entry。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            /* This structure may be extended */
          };
        } StoredDataValue;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections discuss the properties of each data model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のセクションでは、各データモデルの性質を議論します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. Single Value
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. 単一値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single-value element is a simple sequence of bytes. There may be only one single-value element for each Resource-ID, Kind-ID pair.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一値要素には、バイトの単純な配列です。各リソース-ID、種類-IDのペアのためにただ1つの値の要素があってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single value element is represented as a DataValue, which contains the following two elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一値の要素は、次の2つの要素を含むDataValueは、のように表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
exists This value indicates whether the value exists at all. If it is set to False, it means that no value is present. If it is True, this means that a value is present. This gives the protocol a mechanism for indicating nonexistence as opposed to emptiness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この値は、値がまったく存在するかどうかを示す存在します。それがFalseに設定されている場合は、値が存在しないことを意味します。それがTrueの場合、この値が存在することを意味します。これは、プロトコルを空虚とは対照的に存在しないことを示すための機構を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
value The stored data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
格納されたデータを評価。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. Array
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. アレイ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An array is a set of opaque values addressed by an integer index. Arrays are zero based. Note that arrays can be sparse. For instance, a Store of &#34;X&#34; at index 2 in an empty array produces an array with the values [ NA, NA, &#34;X&#34;]. Future attempts to fetch elements at index 0 or 1 will return values with &#34;exists&#34; set to False.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アレイは、整数インデックスによってアドレス指定不透明値のセットです。配列はゼロベースです。配列はスパースできることに注意してください。例えば、空の配列のインデックス2に「X」のストア値[NA、NA、「X」]の配列を生成します。インデックス0または1で要素をフェッチする将来の試みがFalseに設定された「存在する」との値を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An array element is represented as an ArrayEntry:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アレイ素子はArrayEntryとして表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
           uint32                  index;
           DataValue               value;
         } ArrayEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
index The index of the data element in the array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
索引配列内のデータ要素のインデックス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
value The stored data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
格納されたデータを評価。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.3. Dictionary
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.3. 辞書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A dictionary is a set of opaque values indexed by an opaque key, with one value for each key. A single dictionary entry is represented as a DictionaryEntry:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
辞書は、各キーに対して1つの値と、不透明な鍵によってインデックスさ不透明値のセットです。単一の辞書エントリはDictionaryEntryのように表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
typedef opaque DictionaryKey&lt;0..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
不透明DictionaryKey &lt;0..2 ^ 16-1&gt;のtypedef。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
           DictionaryKey          key;
           DataValue              value;
         } DictionaryEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
key The dictionary key for this value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この値の辞書キーをキーを押します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
value The stored data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
格納されたデータを評価。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Access Control Policies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. アクセス制御ポリシー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every Kind which is storable in an overlay MUST be associated with an access control policy. This policy defines whether a request from a given node to operate on a given value should succeed or fail. It is anticipated that only a small number of generic access control policies are required. To that end, this section describes a small set of such policies, and Section 14.4 establishes a registry for new policies, if required. Each policy has a short string identifier which is used to reference it in the Configuration Document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイに保存可能であるあらゆる種類は、アクセス制御ポリシーに関連付ける必要があります。このポリシーは、指定された値で動作する所与のノードからの要求が成功するか失敗するかどうかを定義します。一般的なアクセス制御ポリシーのほんの数が必要であることが予想されます。そのために、このセクションでは、このような政策の小さなセットを説明し、必要に応じてセクション14.4には、新しいポリシーのレジストリを確立します。各ポリシーは、設定文書で参照するために使用される短い文字列の識別子を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following policies, the term &#34;signer&#34; refers to the signer of the StoredValue object and, in the case of non-replica stores, to the signer of the StoreReq message. That is, in a non-replica store, both the signer of the StoredValue and the signer of the StoreReq MUST conform to the policy. In the case of a replica store, the signer of the StoredValue MUST conform to the policy, and the StoreReq itself MUST be checked as described in Section 7.4.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のポリシーでは、用語「署名者」はStoredValueオブジェクトの署名者に及び、非レプリカ店舗の場合には、StoreReqメッセージの署名者を指します。すなわち、非レプリカ店においては、両方StoredValueの署名者とStoreReqの署名者は、ポリシーに準拠しなければなりません。レプリカ・ストアの場合には、StoredValueの署名者は、ポリシーに準拠しなければならない、そして、セクション7.4.1.1に記載されるようにStoreReq自身がチェックしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.1. USER-MATCH
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.1.  USER-MATCH
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the USER-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer&#39;s certificate has a user name which hashes (using the hash function for the overlay) to the Resource-ID for the resource. Recall that the certificate may, depending on the overlay configuration, be self-signed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
USER-MATCHポリシーで、指定された値が書き込まれた（または上書き）しなければならない場合と署名者の証明書は、リソースのリソース-IDに（オーバーレイのハッシュ関数を使用して）ハッシュユーザー名を持っている場合のみ。証明書は、オーバーレイの構成に応じて、自己署名することができることを想起されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.2. NODE-MATCH
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.2.  NODE-MATCH
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NODE-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer&#39;s certificate has a specified Node-ID which hashes (using the hash function for the overlay) to the Resource-ID for the resource and that Node-ID is the one indicated in the SignerIdentity value cert_hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NODE-MATCHポリシーで、所定の値（または上書き）が書き込まなければならない場合と署名者の証明書は、リソースのリソース-IDに（オーバーレイのためのハッシュ関数を用いて）ハッシュ指定されたノード-IDを有する場合にのみ、及びそのノードIDはSignerIdentity値cert_hashに示されるものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.3. USER-NODE-MATCH
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.3.  USER-NODE-MATCH
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The USER-NODE-MATCH policy may be used only with dictionary types. In the USER-NODE-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer&#39;s certificate has a user name which hashes (using the hash function for the overlay) to the Resource-ID for the resource. In addition, the dictionary key MUST be equal to the Node-ID in the certificate, and that Node-ID MUST be the one indicated in the SignerIdentity value cert_hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
USER-NODE-MATCH政策は、辞書型で使用することができます。 USER-NODE-MATCHポリシーで、指定された値が書き込まれた（または上書き）しなければならない場合と署名者の証明書は、リソースのリソース-IDに（オーバーレイのハッシュ関数を使用して）ハッシュユーザー名を持っている場合のみ。また、辞書のキーは、証明書内のノードIDに等しくなければならず、そのノードIDはSignerIdentity値cert_hashに示されているものでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.4. NODE-MULTIPLE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.4.  NODE-MULTIPLE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NODE-MULTIPLE policy, a given value MUST be written (or overwritten) if and only if the signer&#39;s certificate contains a Node-ID such that H(Node-ID || i) is equal to the Resource-ID for some small integer value of i and that Node-ID is the one indicated in the SignerIdentity value cert_hash. When this policy is in use, the maximum value of i MUST be specified in the Kind definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NODE-複数のポリシーでは、指定された値が書き込まれた（または上書き）しなければならない場合と署名者の証明書が含まれている場合にのみ、ノードID Hは（ノードID || i）は、いくつかの小規模のリソース-IDに等しくなるようにiとそのノードIDの整数値はSignerIdentity値cert_hashに示されるものです。このポリシーを使用している場合は、私の最大値は、種類の定義で指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that because i is not carried on the wire, the verifier MUST iterate through potential i values, up to the maximum value, to determine whether a store is acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iは、ワイヤ上に担持されていないため、検証者は、潜在的なi値を反復しなければならないことに注意し、最大値まで、ストアが許容可能であるかどうかを決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Data Storage Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. データストレージメソッド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD provides several methods for storing and retrieving data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADは、データを格納および取得するためのいくつかのメソッドを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Store values in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイ中のOストアの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Fetch values from the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oオーバーレイから値を取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stat: Get metadata about values in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O統計：オーバーレイの値についてのメタデータを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Find the values stored at an individual peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O個々のピアに格納された値を検索します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These methods are described in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのメソッドは、次のセクションで説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. Store
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. 格納
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Store method is used to store data in the overlay. The format of the Store request depends on the data model, which is determined by the Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
店舗方法は、オーバーレイ内のデータを格納するために使用されます。ストア要求のフォーマットは種類によって決定されたデータモデルに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1。要求定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A StoreReq message is a sequence of StoreKindData values, each of which represents a sequence of stored values for a given Kind. The same Kind-ID MUST NOT be used twice in a given store request. Each value is then processed in turn. These operations MUST be atomic. If any operation fails, the state MUST be rolled back to what it was before the request was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StoreReqメッセージは、特定の種類のために格納された値のシーケンスを表すそれぞれがStoreKindData値のシーケンスです。同じ種類-IDは、与えられたストアリクエストで二回使用してはいけません。各値は、順番に処理されます。これらの操作はアトミックでなければなりません。すべての操作が失敗した場合、状態は要求が受信される前にそれが何だったかにロールバックする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The store request is defined by the StoreReq structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストア要求はStoreReq構造によって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           KindId                 kind;
           uint64                 generation_counter;
           StoredData             values&lt;0..2^32-1&gt;;
       } StoreKindData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           ResourceId             resource;
           uint8                  replica_number;
           StoreKindData          kind_data&lt;0..2^32-1&gt;;
       } StoreReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single Store request stores data of a number of Kinds to a single resource location. The contents of the structure are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のリソース・ロケーションへ種類数の単一のストアリクエストデータを格納します。構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource The resource at which to store.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保存するのリソースをリソース。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
replica_number The number of this replica. When a storing peer saves replicas to other peers, each peer is assigned a replica number, starting from 1, that is sent in the Store message. This field is set to 0 when a node is storing its own data. This allows peers to distinguish replica writes from original writes. Different topologies may choose to allocate or interpret the replica number differently (see Section 10.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このレプリカの数をreplica_number。格納ピアが他のピアへのレプリカを保存すると、各ピアは、それがストアメッセージで送信され、1から出発して、レプリカ番号が割り当てられます。ノードは、自身のデータを記憶している場合、このフィールドは0に設定されています。これは、ピアがレプリカがオリジナルの書き込みから書き込みを区別することができます。異なるトポロジー（項10.4を参照）、異なるレプリカ番号を割り当てるか、解釈することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind_data A series of elements, one for each Kind of data to be stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind_data要素の系列は、データの種類毎に一つが格納されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The peer MUST check that it is responsible for the resource if the replica number is zero; if it is not, the peer must reject the request. The peer MUST check that it expects to be a replica for the resource and that the request sender is consistent with being the responsible node (i.e., that the receiving peer does not know of a better node) if the replica number is nonzero; if the request sender is not consistent, it should reject the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、レプリカの数がゼロであれば、それは資源のために責任があることをチェックしなければなりません。そうでない場合、ピアは要求を拒否しなければなりません。ピアは、それがリソースの要求の送信者が担当ノードであると一貫していることをレプリカであると想定していることを確認しなければならない（即ち、受信ピアは、より良いノードを知っていないこと）レプリカ数がゼロであれば、リクエストの送信者が一貫していない場合、それは要求を拒否しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each StoreKindData element represents the data to be stored for a single Kind-ID. The contents of the element are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各StoreKindData要素は、単一種類-IDのために格納されるデータを表します。要素の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind-ID. Implementations MUST reject requests corresponding to unknown Kinds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類種類-ID。実装は、未知の種類に対応する要求を拒絶しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
generation_counter The expected current state of the generation counter (approximately the number of times that this object has been written; see below for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生成カウンタの予想される現在の状態generation_counter（このオブジェクトが書き込まれたこと回数の約数と、詳細については以下を参照されたいです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
values The value or values to be stored. This may contain one or more stored_data values, depending on the data model associated with each Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値または値の値が格納されます。これは、各種類に関連付けられたデータ・モデルに応じて、1つ以上のstored_data値を含んでいてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The peer MUST perform the following checks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、以下のチェックを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Kind-ID is known and supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O種類-IDが知られており、サポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The signatures over each individual data element, if any, are valid. If this check fails, the request MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各個々のデータ要素上の署名O、もしあれば、有効です。このチェックが失敗した場合、要求はError_Forbiddenエラーで拒否されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Each element is signed by a credential which is authorized to write this Kind at this Resource-ID. If this check fails, the request MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの各要素は、このリソース-IDにこの種の書き込みを許可されている資格情報によって署名されています。このチェックが失敗した場合、要求はError_Forbiddenエラーで拒否されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For original (non-replica) stores, the StoreReq is signed by a credential which is authorized to write this Kind at this Resource-ID. If this check fails, the request MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O元の（非レプリカ）を格納するために、StoreReqこのリソース-IDにこの種の書き込みを許可されている資格情報によって署名されています。このチェックが失敗した場合、要求はError_Forbiddenエラーで拒否されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For replica stores, the StoreReq is signed by a Node-ID which is a plausible node to either have originally stored the value or have been in the replica set. What this means is overlay specific, but in the case of the Chord-based DHT defined in this specification, replica StoreReqs MUST come from nodes which are either in the known replica set for a given resource or which are closer than some node in the replica set. If this check fails, the request MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oレプリカを格納するため、StoreReqは、いずれかの妥当ノードが本来の値を記憶されているか、レプリカセットにされているあるノードIDによって署名されています。これが意味することは、特定のオーバーレイであるが、本明細書で定義されているコードベースのDHTの場合には、レプリカStoreReqsは、与えられたリソースまたはそのレプリカにいくつかのノードよりも近くにあるために知られている複製セットのいずれかのノードから来なければなりませんセットする。このチェックが失敗した場合、要求はError_Forbiddenエラーで拒否されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For original (non-replica) stores, the peer MUST check that if the generation counter is nonzero, it equals the current value of the generation counter for this Kind. This feature allows the generation counter to be used in a way similar to the HTTP ETag feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O元の（非レプリカ）を格納するために、ピアは、世代カウンタがゼロ以外の場合、それはこの種の生成カウンタの現在の値に等しいことをチェックしなければなりません。この機能は、生成カウンタは、HTTPのETag機能と同様に使用することが可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For replica Stores, the peer MUST set the generation counter to match the generation counter in the message and MUST NOT check the generation counter against the current value. Replica Stores MUST NOT use a generation counter of 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レプリカストアのO、ピアがメッセージに生成カウンタに一致するように世代カウンタを設定しなければならないと現在の値に対して生成カウンタをチェックしてはいけません。レプリカの店舗は0の世代カウンタを使用してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The storage time values are greater than that of any values which would be replaced by this Store.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージoを時間の値は、このお店によって置換される任意の値よりも大きいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The size and number of the stored values are consistent with the limits specified in the overlay configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
格納された値の大きさと数oをオーバーレイ設定で指定された範囲と一致しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the data is signed with identity_type set to &#34;none&#34; and/or SignatureAndHashAlgorithm values set to {0, 0} (&#34;anonymous&#34; and &#34;none&#34;), the StoreReq MUST be rejected with an Error_forbidden error. Only synthesized data returned by the storage can use these values (see Section 7.4.2.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データが「なし」及び/又は{0,0}（「匿名」と「なし」）に設定SignatureAndHashAlgorithm値に設定identity_typeで署名されている場合は、O、StoreReqはError_forbiddenエラーで拒否されなければなりません。ストレージによって返さのみ合成されたデータは、これらの値を使用することができます（7.4.2.2項を参照してください）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If all these checks succeed, the peer MUST attempt to store the data values. For non-replica stores, if the store succeeds and the data is changed, then the peer MUST increase the generation counter by at least 1. If there are multiple stored values in a single StoreKindData, it is permissible for the peer to increase the generation counter by only 1 for the entire Kind-ID or by 1 or more than 1 for each value. Accordingly, all stored data values MUST have a generation counter of 1 or greater. 0 is used in the Store request to indicate that the generation counter should be ignored for processing this request. However, the responsible peer should increase the stored generation counter and should return the correct generation counter in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらすべてのチェックが成功した場合、ピアは、データ値を格納しようとしなければなりません。ストアが成功し、データが変更された場合、単一StoreKindDataに複数記憶された値がある場合、ピアは、少なくとも1で生成カウンタを増やす必要があり、ピアが生成を増加させるための非レプリカ格納するため、それは許容されます唯一1全体種類-IDまたは1もしくは各値に対して1以上によって、カウンタ。したがって、すべての記憶されたデータ値は、1以上の世代カウンタを持たなければなりません。 0が生成カウンタは、この要求を処理するために無視されるべきであることを示すためにストア要求で使用されています。しかし、責任あるピアが保​​存された世代カウンタを増やす必要があり、それに応じて正しい生成カウンタを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer stores data previously stored by another node (e.g., for replicas or topology shifts), it MUST adjust the lifetime value downward to reflect the amount of time the value was stored at the peer. The adjustment SHOULD be implemented by an algorithm equivalent to the following: at the time the peer initially receives the StoreReq, it notes the local time T. When it then attempts to do a StoreReq to another node, it should decrement the lifetime value by the difference between the current local time and T.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピア格納データが以前に別のノードにより格納された場合（例えば、複製またはトポロジシフトのために）、その値は、ピアで保存した時間の量を反映するように下方にライフタイム値を調整する必要があります。調整は次のようなアルゴリズムと同等によって実施されるべきである：ピアは、最初StoreReqを受信する時、それは、別のノードにStoreReqを実行しようとローカル時間Tノート、それはによって寿命値をデクリメントする必要があり現在のローカル時間とT.との違い
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless otherwise specified by the usage, if a peer attempts to store data previously stored by another node (e.g., for replicas or topology shifts) and that store fails with either an Error_Generation_Counter_Too_Low or an Error_Data_Too_Old error, the peer MUST fetch the newer data from the peer generating the error and use that to replace its own copy. This rule allows resynchronization after partitions heal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが以前に（複製またはトポロジシフト用など、）別のノードにより格納されたデータを格納しようとし、そのストアがError_Generation_Counter_Too_Low又はError_Data_Too_Oldエラーのいずれかで失敗し、ピアから新しいデータを取得する必要がある場合はそうでなければ、使用することによって指定されない限りエラーを生成するピアと、自身のコピーを置き換えるためにそれを使用。この規則は、パーティションが治癒した後に再同期することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a network partition is being healed and unless otherwise specified, the default merging rule is to act as if all the values that need to be merged were stored and as if the order they were stored in corresponds to the stored time values associated with (and carried in) their values. Because the stored time values are those associated with the peer which did the writing, clock skew is generally not an issue. If two nodes are on different partitions, write to the same location, and have clock skew, this can create merge conflicts. However, because RELOAD deliberately segregates storage so that data from different users and peers is stored in different locations, and a single peer will typically only be in a single network partition, this case will generally not arise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークパーティションが癒されていると、特に指定のない限り、デフォルトのマージルールがマージされる必要があるすべての値が格納されているかのように、オーダーは、それらが関連付けられて保存された時間値に対応して格納されているかのよう行動するときに（とそれらの値）で実施しました。保存された時間値は、書き込みをしたピアに関連するものであるため、クロック・スキューは、一般的に問題ではありません。 2つのノードが異なるパーティション上にある場合は、同じ場所に書き込み、およびクロック・スキューを持っている、これは、マージの競合を作成することができます。リロードが意図的にストレージを分離するため、異なるユーザとピアからのデータは、異なる場所に格納され、単一のピアは、典型的には、単一のネットワーク・パーティションになるようしかし、この場合は、一般的に発生しないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The properties of stores for each data model are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように各データ・モデルの格納の特性は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
single-value: A store of a new single-value element creates the element if it does not exist and overwrites any existing value with the new value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一値：新しい単一値要素のストアが存在しない場合、要素を作成し、新しい値で既存の値を上書きします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
array: A store of an array entry replaces (or inserts) the given value at the location specified by the index. Because arrays are sparse, a store past the end of the array extends it with nonexistent values (exists = False) as required. A store at index 0xffffffff places the new value at the end of the array, regardless of the length of the array. The resulting StoredData has the correct index value when it is subsequently fetched.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アレイ：アレイエントリのストアは、インデックスにより指定された位置に指定された値を置換（または挿入）。アレイが疎であるため、必要に応じて、アレイの端過去ストアが存在しない値（偽=存在）でそれを拡張します。インデックスは0xFFFFFFFFでストアにかかわらず、配列の長さの、アレイの末尾に新たな値を置きます。それは続いてフェッチされるときに得StoredData正しいインデックス値を有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dictionary: A store of a dictionary entry replaces (or inserts) the given value at the location specified by the dictionary key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
辞書：辞書エントリのストアは、辞書キーで指定された位置に指定された値を置換（または挿入）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following figure shows the relationship between these structures for an example store which stores the following values at resource &#34;1234&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の図は、リソース「1234」で、以下の値を記憶する例えば記憶装置のためのこれらの構造との関係を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value &#34;abc&#34; is in the single-value location for Kind X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O値「ABC」が種類Xの単一の値の場所にあります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value &#34;foo&#34; at index 0 is in the array for Kind Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oインデックス0の値「fooが」種類Y.の配列であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value &#34;bar&#34; at index 1 is in the array for Kind Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oインデックス1の値「バー」が種類Y.の配列であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                     Store
                                resource=1234
                              replica_number = 0
                                   /      \
                                  /        \
                      StoreKindData        StoreKindData
                  kind=X (Single-Value)    kind=Y (Array)
                generation_counter = 99    generation_counter = 107
                           |                    /\
                           |                   /  \
                       StoredData             /    \
             storage_time = xxxxxxx          /      \
                   lifetime = 86400         /        \
                   signature = XXXX        /          \
                           |               |           |
                           |        StoredData       StoredData
                           |    storage_time =       storage_time =
                           |          yyyyyyyy       zzzzzzz
                           |  lifetime = 86400       lifetime = 33200
                           |  signature = YYYY       signature = ZZZZ
                           |               |           |
                    StoredDataValue        |           |
                     value=&#34;abc&#34;           |           |
                                           |           |
                                  StoredDataValue  StoredDataValue
                                        index=0      index=1
                                     value=&#34;foo&#34;    value=&#34;bar&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2。レスポンスの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In response to a successful Store request, the peer MUST return a StoreAns message containing a series of StoreKindResponse elements, which contains the current value of the generation counter for each Kind-ID, as well as a list of the peers where the data will be replicated by the node processing the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功したストア要求に応答して、ピアは各種類-IDの生成カウンタの現在の値を含むStoreKindResponseエレメントのシリーズを含むStoreAnsメッセージ、並びにデータがされるピアのリストを返さなければなりません要求を処理ノードによって複製しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          KindId                  kind;
          uint64                  generation_counter;
          NodeId                  replicas&lt;0..2^16-1&gt;;
        } StoreKindResponse;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          StoreKindResponse       kind_responses&lt;0..2^16-1&gt;;
        } StoreAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of each StoreKindResponse are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各StoreKindResponseの内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind-ID being represented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類種類-IDが表されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
generation_counter The current value of the generation counter for that Kind-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この種-IDの生成カウンタの現在の値をgeneration_counter。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
replicas The list of other peers at which the data was/will be replicated. In overlays and applications where the responsible peer is intended to store redundant copies, this allows the storing node to independently verify that the replicas have in fact been stored. It does this verification by using the Stat method (see Section 7.4.3). Note that the storing node is not required to perform this verification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データは/複製されたときの他のピアのリストをレプリカ。オーバーレイ責任ピアが冗長コピーを格納することが意図されているアプリケーションでは、これは記憶ノードは、独立してレプリカが実際に格納されていることを確認することを可能にします。これは、統計法を用いて、この検証を行います（セクション7.4.3を参照してください）。保存するノードは、この検証を実行するために必要とされていないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response itself is just StoreKindResponse values packed end to end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答自体は、エンドツーエンドを詰めだけStoreKindResponse値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If any of the generation counters in the request precede the corresponding stored generation counter, then the peer MUST fail the entire request and respond with an Error_Generation_Counter_Too_Low error. The error_info in the ErrorResponse MUST be a StoreAns response containing the correct generation counter for each Kind and the replica list, which will be empty. For original (non-replica) stores, a node which receives such an error SHOULD attempt to fetch the data and, if the storage_time value is newer, replace its own data with that newer data. This rule improves data consistency in the case of partitions and merges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求で生成カウンターのいずれかが、対応する記憶された世代カウンタの前にいる場合、ピアは、要求全体が失敗しError_Generation_Counter_Too_Lowエラーで応答しなければなりません。 ErrorResponseにERROR_INFOは空になり、各種類の正しい世代カウンタとレプリカリストを含むStoreAns応答でなければなりません。元の（非レプリカ）を格納するために、そのようなエラーを受信したノードはstorage_time値の方が新しい場合は、その新しいデータに独自のデータを交換し、データをフェッチしようとすべきです。この規則は、パーティションとマージした場合のデータの一貫性を向上させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the data being stored is too large for the allowed limit by the given usage, then the peer MUST fail the request and generate an Error_Data_Too_Large error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
格納されたデータは、所与の使用によって許容される限界のために大きすぎる場合には、ピアは、要求を失敗とError_Data_Too_Largeエラーが発生しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If any type of request tries to access a data Kind that the peer does not know about, the peer MUST fail the request and generate an Error_Unknown_Kind error. The error_info in the Error_Response is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求のいずれかのタイプは、ピアが認識できないデータの種類にアクセスしようとすると、ピアは、要求を失敗し、Error_Unknown_Kindエラーを発生させなければなりません。 Error_ResponseでERROR_INFOは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
KindId unknown_kinds&lt;0..2^8-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
KindId unknown_kinds &lt;0..2 ^ 8-1&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
which lists all the Kinds that were unrecognized. A node which receives this error MUST generate a ConfigUpdate message which contains the appropriate Kind definition (assuming which, in fact, a Kind which was defined in the configuration document was used).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、未認識だったすべての種類を示しています。このエラーを受信したノードは、（実際には、構成ドキュメントに定義された種類を使用した、と仮定して）適切な種類の定義が含まれているあるConfigUpdateメッセージを生成しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3. Removing Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3。値を削除します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD does not have an explicit Remove operation. Rather, values are Removed by storing &#34;nonexistent&#34; values in their place. Each DataValue contains a boolean value called &#34;exists&#34; which indicates whether a value is present at that location. In order to effectively remove a value, the owner stores a new DataValue with &#34;exists&#34; set to False:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADは、明示的な削除操作を持っていません。むしろ、値がその場所に「存在しない」値を格納することによって除去されます。各DataValueは値がその位置に存在するか否かを示す「存在」と呼ばれるブール値を含みます。効果的に値を除去するために、所有者がFalseに設定された「存在」で新しいDataValueはを格納します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
exists = False
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
= Falseの存在
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
value = {} (0 length)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
値= {}（0長さ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The owner SHOULD use a lifetime for the nonexistent value that is at least as long as the remainder of the lifetime of the value it is replacing. Otherwise, it is possible for the original value to be accidentally or maliciously re-stored after the storing node has expired it. Note that a window of vulnerability for replay attack still exists after the original lifetime has expired (as with any store). This attack can be mitigated by doing a nonexistent store with a very long lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者は、それが置換されている値の寿命の残りの部分と少なくとも同じ長さで存在しない値の有効期間を使用すべきです。それ以外の場合は、記憶ノードは、それが満了した後に元の値が誤って又は故意に再格納することが可能です。オリジナルの寿命は、（任意の店舗と同じように）有効期限が切れた後にリプレイ攻撃の脆弱性のウィンドウがまだ存在することに注意してください。この攻撃は、非常に長い寿命と、存在しない店舗を行うことによって緩和することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Storing nodes MUST treat these nonexistent values the same way they treat any other stored value, including overwriting the existing value, replicating them, and aging them out as necessary when the lifetime expires. When a stored nonexistent value&#39;s lifetime expires, it is simply removed from the storing node, as happens when any other stored value expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保存ノードは、これらの存在しない値に彼らは、既存の値を上書きし、それらを複製し、寿命が満了したときに、必要に応じてそれらを老化含む他の格納された値を、治療と同じように扱わなければなりません。格納され、存在しない値の寿命が満了すると、他の記憶された値が期限切れになったときに起こるように、単に、記憶ノードから除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that in the case of arrays and dictionaries, expiration may create an implicit, unsigned &#34;nonexistent&#34; value to represent a gap in the data structure, as might happen when any value is aged out.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれかの値が期限切れになるときに起こるかもしれないように配列及び辞書の場合には、有効期限は、データ構造内のギャップを表す暗黙の、符号なしの「存在しない」値を作成してもよいことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, this value isn&#39;t persistent, nor is it replicated. It is simply synthesized by the storing node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、この値は永続的ではない、またそれが複製されます。単に記憶ノードによって合成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. Fetch
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. フェッチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Fetch request retrieves one or more data elements stored at a given Resource-ID. A single Fetch request can retrieve multiple different Kinds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フェッチ要求は、特定のリソース-IDに格納された1つの以上のデータ要素を検索します。 1回のフェッチ要求は、複数の異なる種類を取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2.1。要求定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fetch requests are defined by the FetchReq structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フェッチ要求はFetchReq構造によって定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          int32            first;
          int32            last;
        } ArrayRange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          KindId                  kind;
          uint64                  generation;
          uint16                  length;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          select (DataModel) {
            case single_value: ;    /* Empty */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
case array: ArrayRange indices&lt;0..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
ケース配列：ArrayRangeインデックス&lt;0..2 ^ 16-1&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
case dictionary: DictionaryKey keys&lt;0..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
ケース辞書：DictionaryKeyキー&lt;0..2 ^ 16-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            /* This structure may be extended */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          } model_specifier;
        } StoredDataSpecifier;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          ResourceId              resource;
          StoredDataSpecifier     specifiers&lt;0..2^16-1&gt;;
        } FetchReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the Fetch requests are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように取得要求の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource The Resource-ID to fetch from.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソース-IDから取得するリソース。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
specifiers A sequence of StoredDataSpecifier values, each specifying some of the data values to retrieve.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StoredDataSpecifier値のシーケンスを指定子、データ値の一部を特定それぞれ取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each StoredDataSpecifier specifies a single Kind of data to retrieve and, if appropriate, the subset of values that are to be retrieved. The contents of the StoredDataSpecifier structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各StoredDataSpecifierは、適切な場合には、取得したいデータの一種類、取得される値のサブセットを指定します。次のようにStoredDataSpecifier構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind-ID of the data being fetched. Implementations SHOULD reject requests corresponding to unknown Kinds unless specifically configured otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類データの種類-IDがフェッチされます。実装は、特に他に設定されていない限り、未知の種類に対応する要求を拒否すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DataModel The data model of the data. This is not transmitted on the wire, but comes from the definition of the Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データのDataModelはデータモデル。これは、ワイヤ上で送信されますが、種類の定義から来ていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
generation The last generation counter that the requesting node saw. This may be used to avoid unnecessary fetches, or it may be set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
世代要求ノードが見たことを最後の世代カウンター。これにより、不要なフェッチを回避するために使用することができる、またはそれはゼロに設定されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length of the rest of the structure, thus allowing extensibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さは構造の残りの部分の長さは、このような拡張を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
model_specifier A reference to the data value being requested within the data model specified for the Kind. For instance, if the data model is &#34;array&#34;, it might specify some subset of the values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
model_specifierデータ値への言及は、種類に指定されたデータモデル内で要求されています。データモデルは、「アレイ」である場合例えば、それはいくつかの値のサブセットを指定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The model_specifier is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにmodel_specifierは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the data model is single value, the specifier is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データモデルは、単一の値である場合には、O、指定子は空です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the data model is array, the specifier contains a list of ArrayRange elements, each of which contains two integers. The first integer is the beginning of the range, and the second is the end of the range. 0 is used to indicate the first element, and 0xffffffff is used to indicate the final element. The first integer MUST be less than or equal to the second. While multiple ranges MAY be specified, they MUST NOT overlap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データモデルはアレイの場合、O、指定子は2つの整数を含んでいるそれぞれが、ArrayRange要素のリストを含みます。最初の整数は、範囲の始まりであり、第二は、範囲の端部です。 0は、最初の要素を示すために使用され、0xFFFFFFFFのは、最終要素を示すために使用されます。最初の整数は、第二のより小さいか等しくなければなりません。複数の範囲を指定することができるが、彼らは重複してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the data model is dictionary, then the specifier contains a list of the dictionary keys being requested. If no keys are specified, then this is a wildcard fetch and all key-value pairs are returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データモデルは辞書であればO、そして指定子は、要求されている辞書のキーのリストが含まれています。何のキーが指定されていない場合、これは、ワイルドカードがフェッチされ、すべてのキーと値のペアが返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The generation counter is used to indicate the requester&#39;s expected state of the storing peer. If the generation counter in the request matches the stored counter, then the storing peer returns a response with no StoredData values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
世代カウンタが記憶ピアの要求者の期待される状態を示すために使用されます。要求で生成カウンタが格納されているカウンタと一致した場合、記憶ピアはないStoredData値を有する応答を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2.2。レスポンスの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response to a successful Fetch request is a FetchAns message containing the data requested by the requester.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功したフェッチ要求に対する応答は、要求者から要求されたデータを含むFetchAnsメッセージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
           KindId                 kind;
           uint64                 generation;
           StoredData             values&lt;0..2^32-1&gt;;
         } FetchKindResponse;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
           FetchKindResponse      kind_responses&lt;0..2^32-1&gt;;
         } FetchAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FetchAns structure contains a series of FetchKindResponse structures. There MUST be one FetchKindResponse element for each Kind-ID in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FetchAns構造はFetchKindResponse構造のシリーズが含まれています。各種類-ID要求の中に1つのFetchKindResponse要素があるに違いありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the FetchKindResponse structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにFetchKindResponse構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind that this structure is for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構造がためのものであること種類種類。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
generation The generation counter for this Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この種の生成生成カウンタを。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
values The relevant values. If the generation counter in the request matches the generation counter in the stored data, then no StoredData values are returned. Otherwise, all relevant data values MUST be returned. A nonexistent value (i.e., one which the node has no knowledge of) is represented by a synthetic value with &#34;exists&#34; set to False and has an empty signature. Specifically, the identity_type is set to &#34;none&#34;, the SignatureAndHashAlgorithm values are set to {0, 0} (&#34;anonymous&#34; and &#34;none&#34;, respectively), and the signature value is of zero length. This removes the need for the responding node to do signatures for values which do not exist. These signatures are unnecessary, as the entire response is signed by that node. Note that entries which have been removed by the procedure given in Section 7.4.1.3 and which have not yet expired also have exists = False, but have valid signatures from the node which did the store.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連する値を値。要求で生成カウンタが格納されたデータで生成カウンタと一致する場合、次に何StoredData値が返されません。それ以外の場合は、関連するすべてのデータ値を返さなければなりません。存在しない値（ノードの知識を持たない、すなわち、1）がFalseに設定され、空の署名を持っている「存在」を有する合成値で表されます。具体的には、identity_typeが「なし」に設定されている、SignatureAndHashAlgorithm値を（それぞれ、「匿名」と「なし」）{0,0}に設定し、署名値はゼロ長であるれています。これは、存在しない値のための署名を行うには応答ノードの必要性を取り除きます。全体の応答は、そのノードによって署名されているように、これらの署名は、不要です。節7.4.1.3に与えられた手順で削除されていると、まだまた、期限が切れていないそのエントリは= Falseの存在持っていますが、店舗をしたノードから有効な署名を持っていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receipt of a FetchAns message, nodes MUST verify the signatures on all the received values. Any values with invalid signatures (including expired certificates) MUST be discarded. Note that this implies that implementations which wish to store data for long periods of time must have certificates with appropriate expiration dates or must re-store periodically. Implementations MAY return the subset of values with valid signatures, but in that case, they SHOULD somehow signal to the application that a partial response was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FetchAnsメッセージを受信すると、ノードが全ての受信値に対して署名を検証しなければなりません。 （期限切れの証明書を含む）無効な署名を持つ任意の値は捨てなければなりません。これは長期間のデータを保存したいの実装は、適切な有効期限を持つ証明書を持っている必要がありますか、定期的に再格納しなければならないことを意味することに注意してください。実装は、有効な署名を持つ値のサブセットを返してもよいが、その場合には、彼らは何とかパーシャルレスポンスを受信したアプリケーションに知らせるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is one subtle point about signature computation on arrays. If the storing node uses the append feature (where the index=0xffffffff), then the index in the StoredData that is returned will not match that used by the storing node, which would break the signature. In order to avoid this issue, the index value in the array is set to zero before the signature is computed. This implies that malicious storing nodes can reorder array entries without being detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アレイ上の署名演算約微妙な点があります。記憶ノードは、追記機能（インデックス= 0xFFFFFFFFの）を使用している場合、返されるStoredDataのインデックスは、署名を破ることになる記憶ノードによって使用されるものと一致しないであろう。署名が計算される前に、この問題を回避するために、配列のインデックス値はゼロに設定されています。これは、悪意のある記憶ノードが検出されることなく、アレイエントリを並べ替えることができることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. Stat
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. 状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Stat request is used to get metadata (length, generation counter, digest, etc.) for a stored element without retrieving the element itself. The name is from the UNIX stat(2) system call, which performs a similar function for files in a file system. It also allows the requesting node to get a list of matching elements without requesting the entire element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スタット要求は素子自体を取得することなく、格納された要素の（など、長さ、世代カウンタダイジェスト）メタデータを取得するために使用されます。名前は、ファイルシステム内のファイルに対して同様の機能を実行するUNIXのstat（2）システムコールからです。それはまた、要求ノードが全体の要素を要求することなく、一致する要素のリストを取得することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3.1。要求定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Stat request is identical to the Fetch request. It simply specifies the elements to get metadata about.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Statの要求がフェッチ要求と同じです。これは、単にに関するメタデータを取得するための要素を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          ResourceId              resource;
          StoredDataSpecifier     specifiers&lt;0..2^16-1&gt;;
        } StatReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3.2。レスポンスの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Stat response contains the same sort of entries that a Fetch response would contain. However, instead of containing the element data, it contains metadata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スタット応答は、フェッチ応答が含まれますエントリの同じ種類が含まれています。しかし、代わりに要素データを含んでいると、それはメタデータが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          Boolean                exists;
          uint32                 value_length;
          HashAlgorithm          hash_algorithm;
          opaque                 hash_value&lt;0..255&gt;;
        } MetaData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          uint32                 index;
          MetaData               value;
        } ArrayEntryMeta;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          DictionaryKey          key;
          MetaData               value;
        } DictionaryEntryMeta;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          select (DataModel) {
            case single_value:
              MetaData              single_value_entry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            case array:
              ArrayEntryMeta        array_entry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
case dictionary: DictionaryEntryMeta dictionary_entry;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
ケース辞書：DictionaryEntryMetaのdictionary_entry。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            /* This structure may be extended */
          };
        } MetaDataValue;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          uint32                  value_length;
          uint64                  storage_time;
          uint32                  lifetime;
          MetaDataValue           metadata;
        } StoredMetaData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          KindId                 kind;
          uint64                 generation;
          StoredMetaData         values&lt;0..2^32-1&gt;;
        } StatKindResponse;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          StatKindResponse      kind_responses&lt;0..2^32-1&gt;;
        } StatAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The structures used in StatAns parallel those used in FetchAns: a response consists of multiple StatKindResponse values, one for each Kind that was in the request. The contents of the StatKindResponse are the same as those in the FetchKindResponse, except that the values list contains StoredMetaData entries instead of StoredData entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StatAnsに使用される構造はFetchAnsに使用されるものを平行：応答は、複数StatKindResponse値から構成要求にあった各種類に対して1つ。 StatKindResponseの内容は、値リストではなくStoredDataエントリのStoredMetaDataのエントリが含まれていることを除いて、FetchKindResponseと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the StoredMetaData structure are the same as the corresponding fields in StoredData, except that there is no signature field and the value is a MetaDataValue rather than a StoredDataValue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StoredMetaData構造の内容は、そこには、署名フィールドがないと値がMetaDataValueなくStoredDataValueであることを除いて、StoredDataの対応するフィールドと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A MetaDataValue is a variant structure, like a StoredDataValue, except for the types of each arm, which replace DataValue with MetaData.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MetaDataValueは、メタデータとDataValueはを置き換える各アームの種類を除いて、StoredDataValueように、変異体構造です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The only new structure is MetaData, which has the following contents:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
唯一の新しい構造は、以下の内容を持つメタデータ、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
exists Same as in DataValue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DataValueは内と同じ存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
value_length The length of the stored value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
格納された値の長さをvalue_length。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hash_algorithm The hash algorithm used to perform the digest of the value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値のダイジェストを実行するために使用されるハッシュアルゴリズムをhash_algorithm。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hash_value A digest using hash_algorithm on the value field of the DataValue, including its 4 leading length bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その4つの先頭の長さバイトを含むDataValueはの値フィールド、上hash_algorithmを用いHASH_VALUE Aダイジェスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4. Find
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4. 見つける
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Find request can be used to explore the Overlay Instance. A Find request for a Resource-ID R and a Kind-ID T retrieves the Resource-ID, if any, of the resource of Kind T known to the target peer which is closest to R. This method can be used to walk the Overlay Instance by iteratively fetching R_n+1=nearest(1 + R_n).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
検索要求は、オーバーレイインスタンスを探索するために使用することができます。リソースID-Rや種類-IDがあればTは、この方法は、オーバーレイを歩くために使用することができるR.に最も近いターゲットピアに知られている種類Tのリソースを、リソース-IDを検索するための検索要求繰り返しフェッチによってインスタンスたR_n + 1 =最も近い（1 +たR_n）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4.1。要求定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FindReq message contains a Resource-ID and a series of Kind-IDs identifying the resource the peer is interested in.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FindReqメッセージは、リソースID及びピアが興味のあるリソースを識別する品種IDの系列を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     struct {
       ResourceId                 resource;
       KindId                     kinds&lt;0..2^8-1&gt;;
     } FindReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The request contains a list of Kind-IDs which the Find is for, as indicated below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエストは、以下に示すように、検索は、のためにある種類-IDのリストが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource The desired Resource-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目的のリソース-IDリソース。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kinds The desired Kind-IDs. Each value MUST appear only once. Otherwise, the request MUST be rejected with an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類、所望の品種IDは。各値は、一度だけ現れなければなりません。そうしないと、要求はエラーで拒絶しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4.2。レスポンスの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A response to a successful Find request is a FindAns message containing the closest Resource-ID on the peer for each Kind specified in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功した検索要求に対する応答は、要求で指定された各種類のピアに最も近いリソース-IDを含むFindAnsメッセージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
      KindId                      kind;
      ResourceId                  closest;
    } FindKindData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
      FindKindData                results&lt;0..2^16-1&gt;;
    } FindAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the processing peer is not responsible for the specified Resource-ID, it SHOULD return an Error_Not_Found error code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
処理ピアが指定されたリソース-IDの責任ではない場合、それはERROR_NOT_FOUNDエラーコードを返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each Kind-ID in the request, the response MUST contain a FindKindData indicating the closest Resource-ID for that Kind-ID, unless the Kind is not allowed to be used with Find, in which case a FindKindData for that Kind-ID MUST NOT be included in the response. If a Kind-ID is not known, then the corresponding Resource-ID MUST be 0. Note that different Kind-IDs may have different closest Resource-IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類が検索で使用することを許可されていない場合を除き、各種類-ID要求では、応答は、その種類-ID、最も近いリソース-IDを示すFindKindDataを含まなければならない、場合FindKindDataその種類-IDのための絶対必要応答に含まれていません。種類-IDが知られていない場合は、対応するリソース-IDは、異なる種類-IDが最も近い異なるリソース-IDを有していてもよいことが0注意していなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response is simply a series of FindKindData elements, one per Kind, concatenated end to end. The contents of each element are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答は、単にFindKindData要素、種類ごとに、端部に連結端の系列です。各要素の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類種類-ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
closest The closest Resource-ID to the specified Resource-ID. It is 0 if no Resource-ID is known.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定されたリソース-IDに最も近い最も近いリソース-ID。何のリソース-IDが知られていない場合は0です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the response does not contain the contents of the data stored at these Resource-IDs. If the requester wants this, it must retrieve it using Fetch.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答は、これらの資源のIDで保存されたデータの内容が含まれていないことに注意してください。依頼者がこれを望んでいるなら、それはフェッチ使用して、それを取得する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5. Defining New Kinds
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5. 新しい種類の定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two ways to define a new Kind. The first is by writing a document and registering the Kind-ID with IANA. This is the preferred method for Kinds which may be widely used and reused. The second method is to simply define the Kind and its parameters in the Configuration Document using the section of Kind-ID space set aside for private use. This method MAY be used to define ad hoc Kinds in new overlays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい種類を定義する2つの方法があります。最初は、ドキュメントを書くとIANAと種類-IDを登録することです。これは、広く使用され、再使用することができる種類の好ましい方法です。第二の方法は、単に種類、私的使用のために確保した種類-ID空間の部分を使用して設定文書でそのパラメータを定義することです。このメソッドは、新しいオーバーレイでアドホック種類を定義するために使用されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However a Kind is defined, the definition MUST include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類が定義されているが、定義が含まれている必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The meaning of the data to be stored (in some textual form).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（いくつかのテキスト形式で）格納されるデータの意味O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Kind-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類-ID O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The data model (single value, array, dictionary, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oデータ・モデル（単一値、アレイ、辞書、等）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The access control model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセス制御モデルO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, when Kinds are registered with IANA, each Kind is assigned a short string name which is used to refer to it in Configuration Documents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類のIANAに登録されている場合に加えて、各種類の構成ドキュメントにそれを参照するために使用される短い文字列名が割り当てられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While each Kind needs to define what data model is used for its data, this does not mean that it must define new data models. Where practical, Kinds should use the existing data models. The intention is that the basic data model set be sufficient for most applications/ usages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各種類は、そのデータに使用されるどのようなデータモデルを定義する必要がありますが、これは新しいデータモデルを定義しなければならないという意味ではありません。どこに実用的な、種類は、既存のデータモデルを使用する必要があります。その意図は、基本的なデータモデルセットは、ほとんどのアプリケーション/用途のために十分であることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Certificate Store Usage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. [証明書ストアの使用状況
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Certificate Store Usage allows a node to store its certificate in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書ストアの使用状況は、ノードがオーバーレイでその証明書を保存することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A user/node MUST store its certificate at Resource-IDs derived from two Resource Names:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザ/ノードは、2つのリソースの名前に由来する資源のIDでその証明書を格納しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The user name in the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書内のユーザー名O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Node-ID in the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードID証明書中のO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that in the second case, the certificate for a peer is not stored at its Node-ID but rather at a hash of its Node-ID. The intention here (as is common throughout RELOAD) is to avoid making a peer responsible for its own data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二の場合には、ピアの証明書は、そのノードIDではなく、むしろ、そのノードIDのハッシュに格納されていないことに留意されたいです。ここでの意図は、（RELOADを通じて一般的であるように）独自のデータを担当するピアを避けることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New certificates are stored at the end of the list. This structure allows users to store an old and a new certificate that both have the same Node-ID, which allows for migration of certificates when they are renewed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい証明書は、リストの最後に格納されています。この構造は、ユーザーが古いとの両方が同じノードID、それらが更新されたときに、証明書の移行を可能にした新しい証明書を保存することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This usage defines the following Kinds:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この使用法は、次の種類が定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Name: CERTIFICATE_BY_NODE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前：CERTIFICATE_BY_NODE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Model: The data model for CERTIFICATE_BY_NODE data is array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データモデル：CERTIFICATE_BY_NODEデータのためのデータモデルは、配列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access Control: NODE-MATCH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセス制御：NODE-MATCH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Name: CERTIFICATE_BY_USER
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前：CERTIFICATE_BY_USER
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Model: The data model for CERTIFICATE_BY_USER data is array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データモデル：CERTIFICATE_BY_USERデータのためのデータモデルは、配列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access Control: USER-MATCH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセスコントロール：USER-MATCH
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. TURN Server Usage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. TURNサーバーの使用法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TURN Server Usage allows a RELOAD peer to advertise that it is prepared to be a TURN server, as defined in [RFC5766]. When a node starts up, it joins the overlay network and forms several connections in the process. If the ICE stage in any of these connections returns a reflexive address that is not the same as the peer&#39;s perceived address, then the peer is behind a NAT and SHOULD NOT be a candidate for a TURN server. Additionally, if the peer&#39;s IP address is in the private address space range as defined by [RFC1918], then it is also
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TURNサーバの使用リロードピアが[RFC5766]で定義されるように、TURNサーバであるように準備されることをアドバタイズすることを可能にします。ノードは、起動時には、オーバーレイネットワークに参加し、その過程でいくつかの接続を形成しています。これらの接続のいずれかのICEステージは、ピアの認知アドレスと同じではありません再帰のアドレスを返す場合、ピアはNATの背後にあるとTURNサーバーの候補べきではありません。 [RFC1918]で定義されているピアのIPアドレスがプライベートアドレス空間の範囲内にある場合はさらに、それはまたです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHOULD NOT be a candidate for a TURN server. Otherwise, the peer SHOULD assume that it is a potential TURN server and follow the procedures below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TURNサーバの候補とすべきではありません。そうでない場合、ピアは、それが潜在的なTURNサーバであることを前提とすべきであり、以下の手順に従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the node is a candidate for a TURN server, it will insert some pointers in the overlay so that other peers can find it. The overlay configuration file specifies a turn-density parameter that indicates how many times each TURN server SHOULD record itself in the overlay. Typically, this should be set to the reciprocal of the estimate of what percentage of peers will act as TURN servers. If the turn-density is not set to zero, for each value, called d, between 1 and turn-density, the peer forms a Resource Name by concatenating its Node-ID and the value d. This Resource Name is hashed to form a Resource-ID. The address of the peer is stored at that Resource-ID using type TURN-SERVICE and the TurnServer object:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードがTURNサーバーの候補である場合には、他のピアがそれを見つけることができるように、それはオーバーレイでいくつかのポインタを挿入します。オーバーレイ設定ファイルには、各TURNサーバーがオーバーレイで自分自身を記録する回数を示しターン密度パラメータを指定します。通常、これはTURNサーバとして動作するピアの何パーセントの推定値の逆数に設定する必要があります。ターン密度がゼロに設定されていない場合、各値に対して、1およびターン密度と、Dと呼ばれ、ピアは、そのノードIDおよび値Dを連結することによって、リソース名を形成します。このリソース名は、リソースIDを形成するためにハッシュされます。ピアのアドレスは、タイプTURN-SERVICEとTurnServerオブジェクトを使用して、そのリソース-IDに格納されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
          uint8                   iteration;
          IpAddressPort           server_address;
        } TurnServer;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにこの構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iteration The d value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d値の繰り返し。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server_address The address at which the TURN server can be contacted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TURNサーバが連絡可能なアドレスSERVER_ADDRESS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Correct functioning of this algorithm depends on having turn-density be a reasonable estimate of the reciprocal of the proportion of nodes in the overlay that can act as TURN servers. If the turn-density value in the configuration file is too low, the process of finding TURN servers becomes more expensive, as multiple candidate Resource-IDs must be probed to find a TURN server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：このアルゴリズムが正しく機能は、ターン密度がTURNサーバとして機能することができ、オーバーレイ内のノードの割合の逆数の合理的な見積りも持つに依存します。設定ファイルのターン濃度値が低すぎる場合は、複数の候補リソース-IDがTURNサーバーを見つけるために精査しなければならないとして、TURNサーバを見つけるプロセスは、より高価になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peers that provide this service need to support the TURN extensions to STUN for media relay, as defined in [RFC5766].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このサービスを提供するピアは、[RFC5766]で定義されるように、メディアリレーのためにSTUNするTURN拡張をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This usage defines the following Kind to indicate that a peer is willing to act as a TURN server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この使用は、ピアは、TURNサーバとして機能する意思があることを示すために、次の種類を定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Name: TURN-SERVICE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前：TURN-SERVICE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Model: The TURN-SERVICE Kind stores a single value for each Resource-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データモデル：TURN-サービス種別は、各リソース-IDのための単一の値を格納します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access Control: NODE-MULTIPLE, with a maximum iteration of counter 20.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アクセス制御：NODE-MULTIPLE、カウンタ20の最大反復を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peers MAY find other servers by selecting a random Resource-ID and then doing a Find request for the appropriate Kind-ID with that Resource-ID. The Find request gets routed to a random peer based on the Resource-ID. If that peer knows of any servers, they will be returned. The returned response may be empty if the peer does not know of any servers, in which case the process gets repeated with some other random Resource-ID. As long as the ratio of servers relative to peers is not too low, this approach will result in finding a server relatively quickly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、ランダムなリソース-IDを選択し、そのリソース-IDとの適切な種類-IDのための検索要求を行うことによって、他のサーバーを見つけることができます。検索要求は、リソース-IDに基づいて、ランダムなピアにルーティングされます。そのピアは、すべてのサーバーを知っているならば、彼らが返されます。ピアは、プロセスが他のいくつかのランダムなリソース-IDを用いて繰り返します。その場合には任意のサーバ、を知っていない場合に返されるレスポンスは空になることがあります。限りピアに対するサーバの比率が低すぎないように、このアプローチは、比較的速く、サーバーを見つけることになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note to implementers: The certificates used by TurnServer entries need to be retained, as described in Section 6.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装者への注意：TurnServerエントリによって使用される証明書は、セクション6.3.4で説明したように、保持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Chord Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.コードアルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm is assigned the name CHORD-RELOAD to indicate that it is an adaptation of the basic Chord-based DHT algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、それが基本的なコードベースのDHTアルゴリズムの適応であることを示すために名前CHORD-RELOADが割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm differs from the Chord algorithm that was originally presented in [Chord]. It has been updated based on more recent research results and implementation experiences, and to adapt it to the RELOAD protocol. Here is a short list of differences:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアルゴリズムは、もともと[コード]で提示されたコード・アルゴリズムとは異なります。これは、より多くの最近の研究成果や実装の経験に基づいて更新されている、とRELOADプロトコルに適合するように。ここでの違いの短いリストは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The original Chord algorithm specified that a single predecessor and a successor list be stored. The CHORD-RELOAD algorithm attempts to have more than one predecessor and successor. The predecessor sets help other neighbors learn their successor list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oオリジナルコードのアルゴリズムは、単一の先行および後続リストが格納されることを指定しました。 CHORD-RELOADアルゴリズムは、複数の前任者と後継者を持ってしようとします。前身のセットは、他の隣人が自分の後継者リストを学ぶのを助けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The original Chord specification and analysis called for iterative routing. RELOAD specifies recursive routing. In addition to the performance implications, the cost of NAT traversal dictates recursive routing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
反復ルーティングを求め、元のコードの仕様及び分析O。 RELOADは、再帰的なルーティングを指定します。パフォーマンスへの影響に加えて、NATトラバーサルのコストは、再帰的なルーティングを決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Finger Table entries are indexed in the opposite order. Original Chord specifies finger[0] as the immediate successor of the peer. CHORD-RELOAD specifies finger[0] as the peer 180 degrees around the ring from the peer. This change was made to simplify discussion and implementation of variable-sized Finger Tables. However, with either approach, no more than O(log N) entries should typically be stored in a Finger Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oフィンガーテーブルエントリは、逆の順序で索引付けされています。オリジナルコードは[0]ピアの直接の後継者として指を指定します。 CHORDリロード180度ピアからリングの周りにピアとして[0]指を指定します。この変更は、可変サイズのフィンガーテーブルの議論と実装を簡素化するために作られました。しかし、O超えないアプローチ、のいずれかで（Nログ）エントリは、典型的には、フィンガーテーブルに格納されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The stabilize() and fix_fingers() algorithms in the original Chord algorithm are merged into a single periodic process. Stabilization is implemented slightly differently because of the larger neighborhood, and fix_fingers is not as aggressive to reduce load, nor does it search for optimal matches of the Finger Table entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定化（）とfix_fingers O（元のコード・アルゴリズムで）アルゴリズムは、単一の周期的プロセスにマージされます。安定化があるため、より大きな近所の若干異なる実装されており、fix_fingersは、負荷を軽減するなど積極的ではない、またそれは、フィンガーテーブルエントリの最適な一致を検索しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RELOAD allows for a 128-bit hash instead of a 160-bit hash, as RELOAD is not designed to be used in networks with close to or more than 2^128 nodes or objects (and it is hard to see how one would assemble such a network).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oリロードリロードが1がアセンブルする方法を参照するに近い又は2つの以上^ 128のノードまたはオブジェクト（およびそれが困難であるとネットワークで使用されるように設計されていないように、代わりに160ビットのハッシュの128ビットのハッシュを可能にしますそのようなネットワーク）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RELOAD uses randomized finger entries, as described in Section 10.7.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション10.7.4.2で説明したように、O RELOADは、無作為化、指のエントリを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The CHORD-RELOAD algorithm allows the use of either reactive or periodic recovery. The original Chord paper used periodic recovery. Reactive recovery provides better performance in small overlays, but is believed to be unstable in large overlays (greater than 1000) with high levels of churn [handling-churn-usenix04]. The overlay configuration file specifies a &#34;chord-reactive&#34; element that indicates whether reactive recovery should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O CHORD-RELOADアルゴリズムは、いずれかの反応性または定期的な回復を使用することができます。オリジナルのコード・ペーパーでは、定期的な回復を使用しました。反応性の回復は[取り扱い-チャーン-usenix04]小さなオーバーレイでより良い性能を提供するが、解約の高レベルの大きいオーバーレイ（1000より大きい）で不安定であると考えられます。オーバーレイの設定ファイルは、反応性の回復を使用するかどうかを示す「和音反応性」の要素を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm described here, CHORD-RELOAD, is a modified version of the Chord algorithm. In Chord (and in the algorithm described here), nodes are arranged in a ring, with node n being adjacent to nodes n-1 and n+1 and with all arithmetic being done modulo 2^{k}, where k is the length of the Node-ID in bits, so that node 2^{k} - 1 is directly before node 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで説明するアルゴリズムは、CHORDリロードは、コード・アルゴリズムの修正版です。コード内の（およびここで説明されたアルゴリズムに）、ノードはノードと、リング状に配置されたn個のノードに隣接するN-1及びN + 1と全ての演算は、kは長さ2 ^ {K}モジュロ行われるとされビットにおけるノードID、その結果、ノード2 ^ {K}の -  1ノード0の直前にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each peer keeps track of a Finger Table and a Neighbor Table. The Neighbor Table contains at least the three peers before and after this peer in the DHT ring. There may not be three entries in all cases, such as small rings or while the ring topology is changing. The first entry in the Finger Table contains the peer halfway around the ring from this peer, the second entry contains the peer that is 1/4th of the way around, the third entry contains the peer that is 1/8th of the way around, and so on. Fundamentally, the Chord DHT can be thought of as a doubly linked list formed by knowing the successors and predecessor peers in the Neighbor Table, sorted by the Node-ID. As long as the successor peers are correct, the DHT will return the correct result. The pointers to the prior peers are kept to enable the insertion of new peers into the list structure. Keeping multiple predecessor and successor pointers makes it possible to maintain the integrity of the data structure even when consecutive peers simultaneously fail. The Finger Table forms a skip list [wikiSkiplist] so that entries in the linked list can be found in O(log(N)) time instead of the typical O(N) time that a linked list would provide, where N represents the number of nodes in the DHT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ピアは指表とネイバーテーブルを追跡します。ネイバーテーブルは、DHTリングで、このピアの前と後の少なくとも3つのピアが含まれています。リングトポロジが変化している間あり、このような小さなリングなど、すべての場合に3つのエントリ、であってもなくてもよいです。フィンガーテーブルの最初のエントリは、このピアからのリングの周りピア途中を含み、第2のエントリは、回避する方法の1/4であるピアが含まれ、3番目のエントリは、回避する方法の1/8であるピアが含ま等々。基本的に、コードDHTは、ノードIDでソート、ネイバーテーブルに後継と先行ピアを知ることによって形成される二重リンクリストとして考えることができます。限り後継ピアが正しいとして、DHTは、正しい結果を返します。前のピアへのポインタは、リスト構造に新しいピアの挿入を可能にするために保管されています。複数の前任者と後継者のポインタを維持する連続したピアが同時に故障してもデータ構造の整合性を維持することが可能となります。フィンガーテーブルNが数を表すリンクされたリスト内のエントリがOで見つけることができることをスキップリスト[wikiSkiplist]ので（ログ（N））にリンクされたリストを提供する代わりに、典型的なO（N）時間の時間を、形成しますDHT内のノードの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Neighbor Table and Finger Table entries contain logical Node-IDs as values, but the actual mapping of an IP level addressing information to reach that Node-ID is kept in the Connection Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネイバーテーブルとフィンガーテーブルエントリは、値として、論理ノードIDを含むが、そのノードIDに到達するアドレス情報をIPレベルの実際のマッピングは、接続テーブルに保持されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer, x, is responsible for a particular Resource-ID, k, if k is less than or equal to x and k is greater than p, where p is the Node-ID of the previous peer in the Neighbor Table. Care must be taken when computing to note that all math is modulo 2^128.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kがx以下であり、kは、pはネイバーテーブル内の前のピアのノードIDであるPよりも大きい場合、ピア、xは、特定のリソース-ID、Kの責任です。すべての数学は、法2 ^ 128であることに注意することは計算するときには注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Hash Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. ハッシュ関数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For this Chord-based Topology Plug-in, the size of the Resource-ID is 128 bits. The hash of a Resource-ID MUST be computed using SHA-1 [RFC3174], and then the SHA-1 result MUST be truncated to the most significant 128 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このコードベースのトポロジプラグインのために、リソース-IDのサイズは128ビットです。リソース-IDのハッシュは、SHA-1 [RFC3174]を使用して計算しなければなりません、そして、次にSHA-1の結果は、最上位128ビットに切り詰めなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. Routing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. ルーティング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Routing Table is conceptually the union of the Neighbor Table and the Finger Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングテーブルは、概念的にはネイバーテーブルと指表の労働組合です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a peer is not responsible for a Resource-ID k, but is directly connected to a node with Node-ID k, then it MUST route the message to that node. Otherwise, it MUST route the request to the peer in the Routing Table that has the largest Node-ID that is in the interval between the peer and k. If no such node is found, the peer finds the smallest Node-ID that is greater than k and MUST route the message to that node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、リソースID Kを担当していない場合、しかし、直接ノードID kにノードに接続され、それは、そのノードへのルートメッセージをなければなりません。それ以外の場合は、ピアとkとの間隔である最大ノードIDを有するルーティングテーブル内のピアへのルートリクエストをする必要があります。そのようなノードが見つからない場合、ピアは、そのノードにメッセージKなければならず、ルートよりも大きい最小ノードIDを見つけます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. Redundancy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. 冗長性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer receives a Store request for Resource-ID k and it is responsible for Resource-ID k, it MUST store the data and return a success response. It MUST then send a Store request to its successor in the Neighbor Table and to that peer&#39;s successor, incrementing the replica number for each successor. Note that these Store requests are addressed to those specific peers, even though the Resource-ID they are being asked to store is outside the range that they are responsible for. The peers receiving these SHOULD check that they came from an appropriate predecessor in their Neighbor Table and that they are in a range that this predecessor is responsible for. Then, they MUST store the data. They do not themselves perform further Stores, because they can determine that they are not responsible for the Resource-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがリソース-ID kのストア要求を受信し、それが資源-ID kの責任がある場合は、データを保存し、成功応答を返さなければなりません。その後、各後継者のためのレプリカ番号をインクリメント、ネイバーテーブルにそのピアの後継者にその後継にストア要求を送らなければなりません。これらのストア要求は、彼らが店に求められているリソース-IDは、彼らが担当している範囲外であっても、それらの特定のピアに対処していることに注意してください。これらを受けたピアは、彼らが自分のネイバーテーブルに、彼らはこの前任者が担当する範囲内にあることを適切な前任者からのものであることを確認する必要があります。その後、彼らはデータを保存しなければなりません。彼らは資源-IDについては責任を負いませんことを確認することができますので、彼ら自身が、さらに店舗を実行しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this Topology Plug-in does not use the replica number for purposes other than knowing the difference between a replica and a non-replica.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このトポロジプラグインは、レプリカと非レプリカの違いを知ること以外の目的でのレプリカ番号を使用していないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Managing replicas as the overlay changes is described in Section 10.7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイの変更などの管理レプリカは、セクション10.7.3に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sequential replicas used in this overlay algorithm protect against peer failure but not against malicious peers. Additional replication from the Usage is required to protect resources from such attacks, as discussed in Section 13.5.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオーバーレイアルゴリズムで使用されるシーケンシャルレプリカがピア障害に対してではなく、悪意のあるピアから守ります。セクション13.5.4で説明したように使用からの追加の複製は、このような攻撃からリソースを保護する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. Joining
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. 接合
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The join process for a Joining Node (JN) with Node-ID n is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードID nに参加するノード（JN）のためのプロセスに参加以下の通りであります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. JN MUST connect to its chosen bootstrap node, as specified in Section 11.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. JNは、セクション11.4で指定されるように、その選択されたブートストラップ・ノードに接続する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. JN SHOULD send an Attach request to the Admitting Peer (AP) for Resource-ID n+1. The &#34;send_update&#34; flag can be used to acquire the Routing Table of AP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. JNは、リソースID N + 1のために認めるピア（AP）に接続要求を送信すべきです。 「send_update」フラグは、APのルーティングテーブルを取得するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. JN SHOULD send Attach requests to initiate connections to each of the peers in the Neighbor Table as well as to the desired peers in the Finger Table. Note that this does not populate their Routing Tables, but only their Connection Tables, so JN will not get messages that it is expected to route to other nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. JNは、ネイバーテーブル内のピアの各々に、ならびにフィンガーテーブル内の所望のピアへの接続を開始する要求を取り付け送ります。 JNは、それが他のノードへの経路に期待されているメッセージを取得することはできませんので、これは自分のルーティングテーブルが、唯一その接続テーブルを移入しないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. JN MUST enter into its Routing Table all the peers that it has successfully contacted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. JNは、そのルーティングテーブルにそれが正常に接触したことを、すべてのピアを入力する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. JN MUST send a Join to AP. The AP MUST send the response to the Join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. JNは、APへの参加を送らなければなりません。 APは、参加への応答を送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. AP MUST do a series of Store requests to JN to store the data that JN will be responsible for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. APはJNが担当となり、データを保存するためにJNにストア一連の要求を行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. AP MUST send JN an Update explicitly labeling JN as its predecessor. At this point, JN is part of the ring and is responsible for a section of the overlay. AP MAY now forget any data which is assigned to JN and not AP. AP SHOULD NOT forget any data where AP is the replica set for the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. APはJNに明示的にその前身としてJNを標識するアップデートを送らなければなりません。この時点で、JNはリングの一部であり、オーバーレイのセクションを担当しています。 APは現在、JNはなくAPに割り当てられているすべてのデータを忘れる可能性。 APは、APがデータのレプリカセットで任意のデータを忘れてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. The AP MUST send an Update to all of its neighbors (including JN) with the new values of its neighbor set (including JN).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. APは、（JN含む）その隣接セットの新しい値（JN含む）その隣人のすべてにアップデートを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. JN MUST send Updates to all of the peers in its Neighbor Table.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. JNは、そのネイバーテーブル内のピアのすべての更新を送らなければなりません。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If JN sends an Attach to AP with send_update, it immediately knows most of its expected neighbors from AP&#39;s Routing Table update and MAY directly connect to them. This is the RECOMMENDED procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JNはsend_updateでAPへのアタッチを送信した場合、それはすぐにAPのルーティングテーブルの更新からその期待隣人のほとんどを知っているし、それらに直接接続することができます。これは推奨手順です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If for some reason JN does not get AP&#39;s Routing Table, it MAY still populate its Neighbor Table incrementally. It SHOULD send a Ping directed at Resource-ID n+1 (directly after its own Resource-ID). This allows JN to discover its own successor. Call that node p0. JN then SHOULD send a Ping to p0+1 to discover its successor (p1). This process MAY be repeated to discover as many successors as desired. The values for the two peers before p will be found at a later stage, when n receives an Update. An alternate procedure is to send Attaches to those nodes rather than Pings, which form the connections immediately, but may be slower if the nodes need to collect ICE candidates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何らかの理由でJNはAPのルーティングテーブルを取得していない場合、それはまだインクリメンタルそのネイバーテーブルを移入するかもしれません。これは、（直接、独自のリソース-ID後）リソース-ID N + 1に向けピングを送ります。これは、JNは、自身の後継者を発見することができます。そのノードP0を呼び出します。 JNは、その後継者（P1）を発見するために、P0 + 1へのPingを送信すべきです。このプロセスは、必要な数の後継者を発見するために繰り返してもよいです。 nが更新を受信したとき、P前の2つのピアの値は、後の段階で発見されます。別の手法はすぐに接続を形成するというよりピングそれらのノードにアタッチを送信するが、ノードはICE候補を収集する必要がある場合に遅くなることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to set up its i&#39;th Finger Table entry, JN MUST send an Attach to peer n+2^(128-i). This will be routed to a peer in approximately the right location around the ring. (Note that the first entry in the Finger Table has i=1 and not i=0 in this formulation.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのi番目のフィンガーテーブルエントリを設定するために、JNは、n + 2 ^（128-i）をピアにアタッチ送らなければなりません。これは、リングの周りに約右の場所でのピアにルーティングされます。 （フィンガーテーブルの最初のエントリは、この製剤中、I = 1としない、I = 0を有することに留意されたいです。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Joining Node MUST NOT send any Update message placing itself in the overlay until it has successfully completed an Attach with each peer that should be in its Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはそのネイバーテーブルにする必要があり、各ピアで接続し正常に完了するまで、参加するノードは、オーバーレイで自分自身を配置する任意のUpdateメッセージを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. Routing Attaches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. ルーティングアタッチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer needs to Attach to a new peer in its Neighbor Table, it MUST source-route the Attach request through the peer from which it learned the new peer&#39;s Node-ID. Source-routing these requests allows the overlay to recover from instability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアがネイバーテーブルに新しいピアにアタッチする必要がある場合、ソースルートをしなければならない、それは新しいピアのノードIDを学習したピアを通じて要求を取り付けます。ソースルーティングこれらの要求は、オーバーレイが不安定から回復することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All other Attach requests, such as those for new Finger Table entries, are routed conventionally through the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のすべては、このような新しいフィンガーテーブルエントリのものとの要求を、アタッチ、オーバーレイを通じて従来ルーティングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. アップデート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Update for this DHT is defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このDHTの更新は、以下のように定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        enum { invalidChordUpdateType(0),
               peer_ready(1), neighbors(2), full(3), (255) }
             ChordUpdateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        struct {
           uint32                 uptime;
           ChordUpdateType        type;
           select (type){
            case peer_ready:                   /* Empty */
              ;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            case neighbors:
              NodeId              predecessors&lt;0..2^16-1&gt;;
              NodeId              successors&lt;0..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            case full:
              NodeId              predecessors&lt;0..2^16-1&gt;;
              NodeId              successors&lt;0..2^16-1&gt;;
              NodeId              fingers&lt;0..2^16-1&gt;;
          };
        } ChordUpdate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;uptime&#34; field contains the time this peer has been up in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「稼働時間」フィールドは、このピアが秒にアップしていた時間が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;type&#34; field contains the type of the update, which depends on the reason the update was sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「タイプ」フィールドには、アップデートが送信された理由によって異なり、更新の種類が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
peer_ready This peer is ready to receive messages. This message is used to indicate that a node which has Attached is a peer and can be routed through. It is also used as a connectivity check to non-neighbor peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
peer_readyこのピアは、メッセージを受信する準備ができています。このメッセージは、添付したノードがピアとを介してルーティングすることができることを示すために使用されます。また、非隣接ピアへの接続性チェックとして使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
neighbors This version is sent to members of the Chord Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
隣人はこのバージョンでは、コード・ネイバーテーブルのメンバーに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
full This version is sent to peers which request an Update with a RouteQueryReq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フルこのバージョンはRouteQueryReqで更新を要求するピアに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the message is of type &#34;neighbors&#34;, then the contents of the message will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージは、タイプ「隣人」である場合には、メッセージの内容は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
predecessors The predecessor set of the Updating peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前任更新ピアの前身セット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
successors The successor set of the Updating peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後継更新ピアの後継セット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the message is of type &#34;full&#34;, then the contents of the message will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージは、「完全な」型である場合には、メッセージの内容は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
predecessors The predecessor set of the Updating peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前任更新ピアの前身セット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
successors The successor set of the Updating peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後継更新ピアの後継セット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fingers The Finger Table of the Updating peer, in numerically ascending order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指数値的に昇順で更新ピアの指表、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MUST maintain an association (via Attach) to every member of its neighbor set. A peer MUST attempt to maintain at least three predecessors and three successors, even though this will not be possible if the ring is very small. It is RECOMMENDED that O(log(N)) predecessors and successors be maintained in the neighbor set. There are many ways to estimate N, some of which are discussed in [DHT-RELOAD].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、その隣接セットのすべてのメンバーに（経由アタッチ）アソシエーションを維持しなければなりません。ピアは、リングが非常に小さい場合、これはできませんにもかかわらず、少なくとも3人の前任者と後継者3を維持しようとしなければなりません。 O（ログ（N））前任者と後継者が近隣セット内に維持されることが推奨されます。 [DHTリロード]で議論されているいくつかのNを推定する多くの方法があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.1. Handling Neighbor Failures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.1. 近隣障害の処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every time a connection to a peer in the Neighbor Table is lost (as determined by connectivity pings or the failure of some request), the peer MUST remove the entry from its Neighbor Table and replace it with the best match it has from the other peers in its Routing Table. If using reactive recovery, the peer MUST send an immediate Update to all nodes in its Neighbor Table. The update will contain all the Node-IDs of the current entries of the table (after the failed one has been removed). Note that when replacing a successor, the peer SHOULD delay the creation of new replicas for the successor replacement hold-down time (30 seconds) after removing the failed entry from its Neighbor Table in order to allow a triggered update to inform it of a better match for its Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（接続のpingまたはいくつかの要求の失敗によって決定される）ネイバーテーブル内のピアへの接続が失われるたびに、ピアはそのネイバーテーブルからエントリを削除し、それが他のピアから持っている最高の試合と交換する必要がありますそのルーティングテーブルインチ反応性の回復を使用している場合、ピアはそのネイバーテーブル内のすべてのノードへの即時更新を送らなければなりません。更新は、テーブルの現在のエントリすべてのNode-IDが含まれます（失敗した1が除去された後）。後継者を交換する際、ピアはトリガー更新が良いのそれを通知することを可能にするためにそのネイバーテーブルから失敗したエントリを削除した後に後継交換ホールドダウンタイム（30秒）のための新しいレプリカの作成を遅らせるべきであることに注意してくださいそのネイバーテーブルに一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the neighbor failure affects the peer&#39;s range of responsible IDs, then the Update MUST be sent to all nodes in its Connection Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
隣人の失敗が責任IDのピアの範囲に影響を与えている場合、アップデートはその接続テーブル内のすべてのノードに送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MAY attempt to reestablish connectivity with a lost neighbor either by waiting additional time to see if connectivity returns or by actively routing a new Attach to the lost peer. Details for these procedures are beyond the scope of this document. In the case of an attempt to reestablish connectivity with a lost neighbor, the peer MUST be removed from the Neighbor Table. Such a peer is returned to the Neighbor Table once connectivity is reestablished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、失われた隣人のいずれかの接続が戻るか、積極的に失われたピアへのアタッチ新しいをルーティングすることによりかどうかを確認するための追加の時間を待って接続を再確立しようとすることができます。これらの手順の詳細は、このドキュメントの範囲を超えています。失われたネイバーとの接続を再確立しようとする試みの場合には、ピアは、ネイバーテーブルから除去されなければなりません。接続が再確立されると、このようなピアはネイバーテーブルに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If connectivity is lost to all successor peers in the Neighbor Table, then this peer SHOULD behave as if it is joining the network and MUST use Pings to find a peer and send it a Join. If connectivity is lost to all the peers in the Finger Table, this peer SHOULD assume that it has been disconnected from the rest of the network, and it SHOULD periodically try to join the DHT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続がネイバーテーブル内のすべての後継者ピアに失われた場合、このピアは、それがネットワークに参加しているかのように振る舞うべきとピアを見つけて参加し、それを送信するためにpingを使用しなければなりません。接続が指表内のすべてのピアに失われた場合、このピアは、それが残りのネットワークから切断されていると仮定すべきで、それが定期的にDHTに参加してみてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.2. Handling Finger Table Entry Failure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.2. フィンガーテーブルエントリの失敗の取り扱い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a Finger Table entry is found to have failed (as determined by connectivity pings or the failure of some request), all references to the failed peer MUST be removed from the Finger Table and replaced with the closest preceding peer from the Finger Table or Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィンガーテーブルエントリが（接続のpingまたはいくつかの要求の失敗によって決定されるように）失敗したと判明した場合、失敗したピアへのすべての参照は、フィンガーテーブルから削除し、最も近い先行フィンガーテーブルからピアまたは近隣に置き換える必要がありますテーブル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If using reactive recovery, the peer MUST initiate a search for a new Finger Table entry, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
反応性の回復を使用している場合は、以下に説明するように、ピアは、新しいフィンガーテーブルエントリの検索を開始しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.3. Receiving Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.3. 更新を受け取ります
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer x receives an Update request, it examines the Node-IDs in the UpdateReq and at its Neighbor Table and decides if this UpdateReq would change its Neighbor Table. This is done by taking the set of peers currently in the Neighbor Table and comparing them to the peers in the Update request. There are two major cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアxが更新要求を受信すると、それはUpdateReqに、そのネイバーテーブルにノードIDを調べ、このUpdateReqそのネイバーテーブルを変更するかどうかを決定します。これは、ネイバーテーブルに、現在のピアのセットを取り、更新要求にピアにそれらを比較することによって行われます。二つの主要なケースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The UpdateReq contains peers that match x&#39;s Neighbor Table, so no change is needed to the neighbor set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpdateReq oをそう何の変化が隣接セットに必要とされていない、ピアに一致するXのネイバーテーブルが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The UpdateReq contains peers that x does not know about that should be in x&#39;s Neighbor Table; i.e., they are closer than entries in the Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpdateReq oをxがそれについて知っていないことをピアがXのネイバーテーブルに含まれていなければなりません。すなわち、それらは、ネイバーテーブル内のエントリよりも近いです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the first case, no change is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のケースでは、変更は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the second case, x MUST attempt to Attach to the new peers, and if it is successful, it MUST adjust its neighbor set accordingly. Note that x can maintain the now inferior peers as neighbors, but it MUST remember the closer ones.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後者の場合、xは新しいピアにアタッチしようとしなければならない、そしてそれが成功した場合、それはその隣人がそれに応じて設定を調整しなければなりません。 xは隣人として今劣るピアを維持できることに注意してください、それが近いものを覚えておく必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After any Pings and Attaches are done, if the Neighbor Table changes and the peer is using reactive recovery, the peer MUST send an Update request to each member of its Connection Table. These Update requests are what end up filling in the predecessor/successor tables of peers that this peer is a neighbor to. A peer MUST NOT enter itself in its successor or predecessor table and instead should leave the entries empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意ピング及び付着が行われた後ネイバーテーブルの変更及びピアが、反応性の回復を使用している場合、ピアは、接続テーブルの各メンバーに更新要求を送信しなければなりません。これらの更新要求は、このピアがネイバーがあることが、ピアの前身/後継テーブルを埋め終わるものです。ピアは、その後継者や前身のテーブルで自分自身を入力してはならないし、代わりに空のエントリを残す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If peer x is responsible for a Resource-ID R and x discovers that the replica set for R (the next two nodes in its successor set) has changed, it MUST send a Store for any data associated with R to any new node in the replica set. It SHOULD NOT delete data from peers which have left the replica set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアxがリソース-IDのRの責任であり、xはR（その後継セット内の次の二つのノード）に設定されたレプリカが変更されたことを検出した場合、それは任意の新しいノードにRに関連する任意のデータのためのストアを送らなければなりませんレプリカセット。これは、レプリカセットを残してきたピアからデータを削除しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When peer x detects that it is no longer in the replica set for a resource R (i.e., there are three predecessors between x and R), it SHOULD delete all data associated with R from its local store.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアXは、それがリソースRのためのレプリカセットにもはやであることを検出しない場合（すなわち、XとRの間に3つの先行がある）は、そのローカルストアからRに関連するすべてのデータを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer discovers that its range of responsible IDs has changed, it MUST send an Update to all entries in its Connection Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアが責任IDのその範囲が変更されたことを検出すると、その接続テーブル内のすべてのエントリへの更新を送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4. Stabilization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4. 安定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are four components to stabilization:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安定化の4つのコンポーネントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Exchange Updates with all peers in its Neighbor Table to exchange state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのネイバーテーブル内のすべてのピアと1交流更新が状態を交換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Search for better peers to place in its Finger Table.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
その指表に配置するより良いピア2.検索。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Search to determine if the current Finger Table size is sufficiently large.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在のフィンガーテーブルのサイズが十分に大きいかどうかを決定する3.検索。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Search to determine if the overlay has partitioned and needs to recover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイが分割して回復する必要がありましたかどうかを判断する4.検索。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.1. Updating the Neighbor Table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.1。ネイバーテーブルを更新します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MUST periodically send an Update request to every peer in its Neighbor Table. The purpose of this is to keep the predecessor and successor lists up to date and to detect failed peers. The default time is about every ten minutes, but the configuration server SHOULD set this in the Configuration Document using the &#34;chord-update-interval&#34; element (denominated in seconds). A peer SHOULD randomly offset these Update requests so they do not occur all at once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、定期的にそのネイバーテーブル内のすべてのピアへの更新要求を送らなければなりません。この目的は、前任者と後継最新のリストを維持するために、失敗したピアを検出することです。デフォルトの時間は約10分ごとですが、コンフィギュレーションサーバは、（秒建て）「和音更新間隔」要素を使用して設定文書でこれを設定すべきです。彼らは一度にすべてを発生しないので、ピアはランダムにこれらのアップデート要求を相殺すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.2. Refreshing the Finger Table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.2。指表を更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MUST periodically search for new peers to replace invalid entries in the Finger Table. For peer x, the i&#39;th Finger Table entry is valid if it is in the range [ x+2^( 128-i ), x+2^( 128-(i-1) )-1 ]. Invalid entries occur in the Finger Table when a previous Finger Table entry has failed or when no peer has been found in that range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは定期的に指表に無効なエントリを置き換えるために、新しい仲間を探さなければなりません。それが範囲内にある場合、ピアXは、i番目のフィンガーテーブルエントリが有効である[X + 2 ^（128-I）中、X + 2 ^（128（I-1））-1]。以前のフィンガーテーブルエントリが失敗した場合、または全くピアがその範囲内に見つかりませんでしたときに無効なエントリは、フィンガーテーブルにおいて生じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two possible methods for searching for new peers for the Finger Table entries are presented:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィンガーテーブルエントリのための新たなピアを検索するための2つの方法が提示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternative 1: A peer selects one entry in the Finger Table from among the invalid entries. It pings for a new peer for that Finger Table entry. The selection SHOULD be exponentially weighted to attempt to replace earlier (lower i) entries in the Finger Table. A simple way to implement this selection is to search through the Finger Table entries from i=1, and each time an invalid entry is encountered, send a Ping to replace that entry with probability 0.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1代替：ピアが無効なエントリの中からフィンガーテーブル内の1つのエントリを選択します。これは、そのフィンガーテーブルエントリのための新しいピアのためにpingします。選択は、指数関数的に指表に以前（下I）のエントリを交換しようとして重み付けされるべきである（SHOULD）。この選択を実装するための簡単な方法は、I = 1からフィンガーテーブルエントリを検索することで、無効なエントリが検出されるたびに、確率0.5でそのエントリを交換するには、pingを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternative 2: A peer monitors the Update messages received from its connections to observe when an Update indicates a peer that would be used to replace an invalid Finger Table entry, i, and flags that entry in the Finger Table. Every &#34;chord-ping-interval&#34; seconds, the peer selects from among those flagged candidates using an exponentially weighted probability, as above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2代替：更新が無効フィンガーテーブルエントリ、I、およびフラグフィンガーテーブル内のエントリを置き換えるために使用されるピアを示している場合、ピアが観察するその接続から受信した更新メッセージを監視します。すべての「弦のping間隔」秒、ピアは上記のように、指数関数的に重み付けされた確率を使用して候補者をフラグが立てられたものの中から選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When searching for a better entry, the peer SHOULD send the Ping to a Node-ID selected randomly from that range. Random selection is preferred over a search for strictly spaced entries to minimize the effect of churn on overlay routing [minimizing-churn-sigcomm06]. An implementation or subsequent specification MAY choose a method for selecting Finger Table entries other than choosing randomly within the range. Any such alternate methods SHOULD be employed only on Finger Table stabilization and not for the selection of initial Finger Table entries unless the alternative method is faster and imposes less overhead on the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より良好なエントリを検索する場合、ピアは、その範囲からランダムに選択されたノードIDに対するpingを送信すべきです。ランダム選択は、[最小限 - チャーン -  sigcomm06]オーバーレイルーティングに解約の影響を最小限にするために、厳密に離間エントリを検索するよりも好ましいです。実装またはその後の仕様の範囲内でランダムに選択する以外のフィンガーテーブルエントリを選択する方法を選択することができます。別の方法は、高速で、オーバーレイ上のより少ないオーバーヘッドを課すしない限り、任意のそのような代替的な方法は、フィンガーテーブル安定ではなく、最初のフィンガーテーブルエントリの選択のために使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer SHOULD NOT send Ping requests looking for new finger table entries more often than the configuration element &#34;chord-ping-interval&#34;, which defaults to 3600 seconds (one per hour).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、Pingのがより頻繁にされ、3600秒（1時間に1）デフォルトの設定要素「弦のping間隔」、より新しいフィンガーテーブルのエントリを探していたリクエスト送るべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MAY choose to keep connections to multiple peers that can act for a given Finger Table entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアは、与えられたフィンガーテーブルエントリのために行動することができます複数のピアへの接続を維持するために選ぶかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.3. Adjusting Finger Table Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.3。フィンガーテーブルサイズの調整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Finger Table has fewer than 16 entries, the node SHOULD attempt to discover more fingers to grow the size of the table to 16. The value 16 was chosen to ensure high odds of a node maintaining connectivity to the overlay even with strange network partitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指表が16個の未満のエントリがある場合は、ノードは16に値16を、テーブルのサイズを拡張するために複数の指を発見しようとすべきであるにも奇妙なネットワークパーティションでオーバーレイへの接続を維持したノードの高確率を確実にするために選ばれました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For many overlays, 16 Finger Table entries will be enough, but as an overlay grows very large, more than 16 entries may be required in the Finger Table for efficient routing. An implementation SHOULD be capable of increasing the number of entries in the Finger Table to 128 entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのオーバーレイのために、16フィンガーテーブルエントリは十分であるが、オーバーレイが非常に大きくなるように、16のを超えるエントリは、効率的なルーティングのためのフィンガーテーブルにおいて必要とされてもよいです。実装は、128個のエントリにフィンガーテーブル内のエントリの数を増加させることができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although log(N) entries are all that are required for optimal performance, careful implementation of stabilization will result in no additional traffic being generated when maintaining a Finger Table larger than log(N) entries. Implementers are encouraged to make use of RouteQuery and algorithms for determining where new Finger Table entries may be found. Complete details of possible implementations are outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ログ（N）のエントリは、最適なパフォーマンスのために必要とされる全てであるが、安定化の慎重な実装は、エントリ（N）ログより大きいフィンガーテーブルを維持するときに生成されない追加のトラフィックをもたらすであろう。実装者は、新たなフィンガーテーブルエントリは見つけることができる場所を決定するためのRouteQueryとアルゴリズムを利用するように奨励されています。可能な実施形態の完全な詳細は、本明細書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A simple approach to sizing the Finger Table is to ensure that the Finger Table is large enough to contain at least the final successor in the peer&#39;s Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指表サイジングへの単純なアプローチは、指の表は、ピアのネイバーテーブルに少なくとも最後の後継者を収容するのに十分な大きさであることを確認することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.4. Detecting Partitioning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.4。パーティションを検出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To detect that a partitioning has occurred and to heal the overlay, a peer P MUST periodically repeat the discovery process used in the initial join for the overlay to locate an appropriate bootstrap node, B. P SHOULD then send a Ping for its own Node-ID routed through B. If a response is received from peer S&#39;, which is not P&#39;s successor, then the overlay is partitioned and P SHOULD send an Attach to S&#39; routed through B, followed by an Update sent to S&#39;. (Note that S&#39; may not be in P&#39;s Neighbor Table once the overlay is healed, but the connection will allow S&#39; to discover appropriate neighbor entries for itself via its own stabilization.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パーティショニングが発生したことを検出すると、オーバーレイを癒すために、ピアPは、定期的に適切なブートストラップノードを検索するオーバーレイの参加最初に使用される発見プロセスを繰り返す必要があり、B. Pはその後、自身のノード - のためのPingを送信すべきです応答がピアSから受信した場合B.を介してルーティングID &#39;Pの後継者ではない、その後、オーバーレイが分配され、Pは、Sに取り付け送ります「Sに送られた更新を行い、Bを介してルーティング。 （つまり、Sなお、「オーバーレイが治癒されるとPのネイバーテーブルにないかもしれませんが、接続はSができるようになります」独自の安定化を介して、自分自身のための適切なネイバーエントリを発見します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Future specifications may describe alternative mechanisms for determining when to repeat the discovery process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将来の仕様は、検出プロセスを繰り返すときを決定するための代替メカニズムを記述することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8. Route Query f.in 3
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8. ルートクエリは、3 f.in
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       For CHORD-RELOAD, the RouteQueryReq contains no additional
       information.  The RouteQueryAns contains the single Node-ID of
       the next peer to which the responding peer would have routed the
       request message in recursive routing:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
         NodeId                  next_peer;
      } ChordRouteQueryAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにこの構造体の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
next_peer The peer to which the responding peer would route the message in order to deliver it to the destination listed in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
next_peerにピア応答するピアルート要求に記載されている宛先に配信するためにメッセージになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the requester has set the send_update flag, the responder SHOULD initiate an Update immediately after sending the RouteQueryAns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リクエスタがsend_updateフラグを設定している場合、応答者はすぐにRouteQueryAnsを送信した後、アップデートを開始すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9. Leaving
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9. 退出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support extensions, such as [DHT-RELOAD], peers SHOULD send a Leave request to all members of their Neighbor Table before exiting the Overlay Instance. The overlay_specific_data field MUST contain the ChordLeaveData structure, defined below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
こうした[DHT-RELOAD]などの拡張機能をサポートするために、ピアはオーバーレイのインスタンスを終了する前に自分のネイバーテーブルのすべてのメンバーに離脱要求を送るべきです。 overlay_specific_dataフィールドは、以下のように定義さ、ChordLeaveData構造を含まなければなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              enum { invalidChordLeaveType(0),
                      from_succ(1), from_pred(2), (255) }
                    ChordLeaveType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               struct {
                 ChordLeaveType         type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
select (type) { case from_succ: NodeId successors&lt;0..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
（タイプ）{ケースfrom_succ選択：NODEID後継&lt;0..2 ^ 16-1&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                    case from_pred:
                      NodeId           predecessors&lt;0..2^16-1&gt;;
                  };
               } ChordLeaveData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;type&#34; field indicates whether the Leave request was sent by a predecessor or a successor of the recipient:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「タイプ」フィールドは、休暇要求が前身または受信者の後継者によって送信されたかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
from_succ The Leave request was sent by a successor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
離脱要求from_succ後継者によって送信されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
from_pred The Leave request was sent by a predecessor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
from_pred離脱要求は、前任者によって送信されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the type of the request is &#34;from_succ&#34;, the contents will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求のタイプは「from_succ」である場合、その内容は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
successors The sender&#39;s successor list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者の後継者リストを後継者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the type of the request is &#34;from_pred&#34;, the contents will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求のタイプは「from_pred」である場合、その内容は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
predecessors The sender&#39;s predecessor list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者の前任者のリストを前任者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any peer which receives a Leave for a peer n in its neighbor set MUST follow procedures as if it had detected a peer failure as described in Section 10.7.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション10.7.1に記載されているように、それはピア障害を検出したかのようにその隣接セット内のピアnの脱退を受信する任意のピアは、手順に従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Enrollment and Bootstrap
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.登録とブートストラップ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The section defines the format of the configuration data as well the process to join a new overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクションは、プロセスが新しいオーバーレイに参加するだけでなく、構成データのフォーマットを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Overlay Configuration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. オーバーレイの設定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines a new content type &#34;application/p2p-overlay+xml&#34; for a MIME entity that contains overlay information. An example document is shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、オーバーレイ情報が含まれているMIMEエンティティのための新しいコンテンツタイプ「アプリケーション/ P2Pオーバーレイ+ XML」を定義します。文書例を以下に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;overlay xmlns=&#34;urn:ietf:params:xml:ns:p2p:config-base&#34; xmlns:ext=&#34;urn:ietf:params:xml:ns:p2p:config-ext1&#34; xmlns:chord=&#34;urn:ietf:params:xml:ns:p2p:config-chord&#34;&gt; &lt;configuration instance-name=&#34;overlay.example.org&#34; sequence=&#34;22&#34; expiration=&#34;2002-10-10T07:00:00Z&#34; ext:ext-example=&#34;stuff&#34; &gt; &lt;topology-plugin&gt; CHORD-RELOAD &lt;/topology-plugin&gt; &lt;node-id-length&gt;16&lt;/node-id-length&gt; &lt;root-cert&gt; MIIDJDCCAo2gAwIBAgIBADANBgkqhkiG9w0BAQUFADBwMQswCQYDVQQGEwJVUzET MBEGA1UECBMKQ2FsaWZvcm5pYTERMA8GA1UEBxMIU2FuIEpvc2UxDjAMBgNVBAoT BXNpcGl0MSkwJwYDVQQLEyBTaXBpdCBUZXN0IENlcnRpZmljYXRlIEF1dGhvcml0 eTAeFw0wMzA3MTgxMjIxNTJaFw0xMzA3MTUxMjIxNTJaMHAxCzAJBgNVBAYTAlVT MRMwEQYDVQQIEwpDYWxpZm9ybmlhMREwDwYDVQQHEwhTYW4gSm9zZTEOMAwGA1UE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;？xml version = &#34;1.0&#34; エンコード= &#34;UTF-8&#34;？&gt; &lt;オーバーレイのxmlns = &#34;壷：IETF：のparams：XML：NS：P2Pます。config-ベース&#34; のxmlns：EXT = &#34;壷：IETF：のparams：XML ：NS：P2P：CONFIG-EXT1&#34; のxmlns：コード= &#34;URN：IETF：paramsは：XML：NS：P2P：CONFIG-コード&#34;&gt; &lt;構成インスタンス名= &#34;overlay.example.org&#34; 配列= &#34;22&#34; 満了= &#34;2002-10-10T07：00：00Z&#34; EXT：EXT-例= &#34;もの&#34;&gt; &lt;トポロジ・プラグイン&gt; CHORDリロード&lt;/トポロジ・プラグイン&gt; &lt;ノードID、長さ&gt; 16 &lt;/ノードID-長さ&gt; &lt;ルート証明書&gt; MIIDJDCCAo2gAwIBAgIBADANBgkqhkiG9w0BAQUFADBwMQswCQYDVQQGEwJVUzET MBEGA1UECBMKQ2FsaWZvcm5pYTERMA8GA1UEBxMIU2FuIEpvc2UxDjAMBgNVBAoT BXNpcGl0MSkwJwYDVQQLEyBTaXBpdCBUZXN0IENlcnRpZmljYXRlIEF1dGhvcml0 eTAeFw0wMzA3MTgxMjIxNTJaFw0xMzA3MTUxMjIxNTJaMHAxCzAJBgNVBAYTAlVT MRMwEQYDVQQIEwpDYWxpZm9ybmlhMREwDwYDVQQHEwhTYW4gSm9zZTEOMAwGA1UE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ChMFc2lwaXQxKTAnBgNVBAsTIFNpcGl0IFRlc3QgQ2VydGlmaWNhdGUgQXV0aG9y aXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDIh6DkcUDLDyK9BEUxkud +nJ4xrCVGKfgjHm6XaSuHiEtnfELHM+9WymzkBNzZpJu30yzsxwfKoIKugdNUrD4 N3viCicwcN35LgP/KnbN34cavXHr4ZlqxH+OdKB3hQTpQa38A7YXdaoz6goW2ft5 Mi74z03GNKP/G9BoKOGd5QIDAQABo4HNMIHKMB0GA1UdDgQWBBRrRhcU6pR2JYBU bhNU2qHjVBShtjCBmgYDVR0jBIGSMIGPgBRrRhcU6pR2JYBUbhNU2qHjVBShtqF0 pHIwcDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExETAPBgNVBAcT CFNhbiBKb3NlMQ4wDAYDVQQKEwVzaXBpdDEpMCcGA1UECxMgU2lwaXQgVGVzdCBD ZXJ0aWZpY2F0ZSBBdXRob3JpdHmCAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0B AQUFAAOBgQCWbRvv1ZGTRXxbH8/EqkdSCzSoUPrs+rQqR0xdQac9wNY/nlZbkR3O qAezG6Sfmklvf+DOg5RxQq/+Y6I03LRepc7KeVDpaplMFGnpfKsibETMipwzayNQ QgUf4cKBiF+65Ue7hZuDJa2EMv8qW4twEhGDYclpFU9YozyS1OhvUg== &lt;/root-cert&gt; &lt;root-cert&gt; YmFkIGNlcnQK &lt;/root-cert&gt; &lt;enrollment-server&gt;https://example.org&lt;/enrollment-server&gt; &lt;enrollment-server&gt;https://example.net&lt;/enrollment-server&gt; &lt;self-signed-permitted digest=&#34;sha1&#34;&gt;false&lt;/self-signed-permitted&gt; &lt;bootstrap-node address=&#34;192.0.0.1&#34; port=&#34;6084&#34; /&gt; &lt;bootstrap-node address=&#34;192.0.2.2&#34; port=&#34;6084&#34; /&gt; &lt;bootstrap-node address=&#34;2001:DB8::1&#34; port=&#34;6084&#34; /&gt; &lt;turn-density&gt; 20 &lt;/turn-density&gt; &lt;clients-permitted&gt; false &lt;/clients-permitted&gt; &lt;no-ice&gt; false &lt;/no-ice&gt; &lt;chord:chord-update-interval&gt; 400&lt;/chord:chord-update-interval&gt; &lt;chord:chord-ping-interval&gt;30&lt;/chord:chord-ping-interval&gt; &lt;chord:chord-reactive&gt; true &lt;/chord:chord-reactive&gt; &lt;shared-secret&gt; password &lt;/shared-secret&gt; &lt;max-message-size&gt;4000&lt;/max-message-size&gt; &lt;initial-ttl&gt; 30 &lt;/initial-ttl&gt; &lt;overlay-reliability-timer&gt; 3000 &lt;/overlay-reliability-timer&gt; &lt;overlay-link-protocol&gt;TLS&lt;/overlay-link-protocol&gt; &lt;configuration-signer&gt;47112162e84c69ba&lt;/configuration-signer&gt; &lt;kind-signer&gt; 47112162e84c69ba &lt;/kind-signer&gt; &lt;kind-signer&gt; 6eba45d31a900c06 &lt;/kind-signer&gt; &lt;bad-node&gt; 6ebc45d31a900c06 &lt;/bad-node&gt; &lt;bad-node&gt; 6ebc45d31a900ca6 &lt;/bad-node&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ChMFc2lwaXQxKTAnBgNVBAsTIFNpcGl0IFRlc3QgQ2VydGlmaWNhdGUgQXV0aG9y aXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDIh6DkcUDLDyK9BEUxkud + nJ4xrCVGKfgjHm6XaSuHiEtnfELHM + 9WymzkBNzZpJu30yzsxwfKoIKugdNUrD4 N3viCicwcN35LgP / KnbN34cavXHr4ZlqxH + OdKB3hQTpQa38A7YXdaoz6goW2ft5 Mi74z03GNKP / G9BoKOGd5QIDAQABo4HNMIHKMB0GA1UdDgQWBBRrRhcU6pR2JYBU bhNU2qHjVBShtjCBmgYDVR0jBIGSMIGPgBRrRhcU6pR2JYBUbhNU2qHjVBShtqF0 pHIwcDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExETAPBgNVBAcT CFNhbiBKb3NlMQ4wDAYDVQQKEwVzaXBpdDEpMCcGA1UECxMgU2lwaXQgVGVzdCBD ZXJ0aWZpY2F0ZSBBdXRob3JpdHmCAQAwDAYDVR0TBAUwAwEB / zANBgkqhkiG9w0B AQUFAAOBgQCWbRvv1ZGTRXxbH8 / EqkdSCzSoUPrs + rQqR0xdQac9wNY / nlZbkR3O qAezG6Sfmklvf + DOg5RxQq / + Y6I03LRepc7KeVDpaplMFGnpfKsibETMipwzayNQ QgUf4cKBiF + 65Ue7hZuDJa2EMv8qW4twEhGDYclpFU9YozyS1OhvUg == &lt;/ルート証明書&gt; &lt;ルート証明書&gt; YmFkIGNlcnQK &lt;/ルート証明書&gt; &lt;登録サーバ&gt; https://example.org &lt;/登録サーバ&gt; &lt;登録サーバ&gt; https://example.net &lt;/登録サーバ&gt; &lt;自己署名許可ダイジェスト= &#34;SHA1&#34;&gt;偽&lt;/自己署名-あたりmitted&gt; &lt;ブートストラップ・ノードアドレス= &#34;192.0.0.1&#34; ポート= &#34;6084&#34; /&gt; &lt;ブートストラップ・ノードアドレス= &#34;192.0.2.2&#34; ポート= &#34;6084&#34; /&gt; &lt;ブートストラップ・ノードアドレス= &#34;2001：DB8 :: 1&#34; ポート= &#34;6084&#34; /&gt; &lt;ターン密度&gt; 20 &lt;/ターン密度&gt; &lt;クライアント許可&gt;偽&lt;/クライアント許可&gt; &lt;無氷&gt; &lt;偽/無氷&gt; &lt;和音：chord-更新間隔&gt; 400 &lt;/コード：コード更新間隔&gt; &lt;コード：コードのping間隔&gt; 30 &lt;/コード：コードのping間隔&gt; &lt;コード：コード反応&gt;真&lt;/コード：コード反応&gt; &lt;共有秘密&gt;パスワード&lt;/共有秘密&gt; &lt;最大メッセージサイズ&gt; 4000 &lt;/最大メッセージサイズ&gt; &lt;初期-TTL&gt; 30 &lt;/初期-TTL&gt; &lt;オーバーレイ・信頼性・タイマー&gt; 3000 &lt; /オーバーレイ信頼性タイマー&gt; &lt;オーバーレイリンクプロトコル&gt; TLS &lt;/オーバーレイリンクプロトコル&gt; &lt;構成-署名&gt; 47112162e84c69ba &lt;/構成-署名&gt; &lt;種類-署名&gt; 47112162e84c69ba &lt;/種類-署名&gt; &lt;kind-署名者&gt; 6eba45d31a900c06 &lt;/種類-署名&gt; &lt;悪いノード&gt; 6ebc45d31a900c06 &lt;/不良ノード&gt; &lt;悪いノード&gt; 6ebc45d31a900ca6 &lt;/不良ノード&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
&lt;ext:example-extension&gt; foo &lt;/ext:example-extension&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
&lt;EXT：例拡張&gt; FOO &lt;/ EXT：たとえば、拡張&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
&lt;mandatory-extension&gt; urn:ietf:params:xml:ns:p2p:config-ext1 &lt;/mandatory-extension&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
&lt;必須の拡張&gt; URN：IETF：paramsは：XML：NS：P2P：CONFIG-EXT1 &lt;/必須の拡張&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
&lt;required-kinds&gt; &lt;kind-block&gt; &lt;kind name=&#34;SIP-REGISTRATION&#34;&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
&lt;所要の種類&gt; &lt;種類のブロック&gt; &lt;種類名= &#34;SIP-REGISTRATION&#34;&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
 &lt;data-model&gt;SINGLE&lt;/data-model&gt; &lt;access-control&gt;USER-MATCH&lt;/access-control&gt; &lt;max-count&gt;1&lt;/max-count&gt; &lt;max-size&gt;100&lt;/max-size&gt; &lt;/kind&gt; &lt;kind-signature&gt; VGhpcyBpcyBub3QgcmlnaHQhCg== &lt;/kind-signature&gt; &lt;/kind-block&gt; &lt;kind-block&gt; &lt;kind id=&#34;2000&#34;&gt; &lt;data-model&gt;ARRAY&lt;/data-model&gt; &lt;access-control&gt;NODE-MULTIPLE&lt;/access-control&gt; &lt;max-node-multiple&gt;3&lt;/max-node-multiple&gt; &lt;max-count&gt;22&lt;/max-count&gt; &lt;max-size&gt;4&lt;/max-size&gt; &lt;ext:example-kind-extension&gt; 1 &lt;/ext:example-kind-extension&gt; &lt;/kind&gt; &lt;kind-signature&gt; VGhpcyBpcyBub3QgcmlnaHQhCg== &lt;/kind-signature&gt; &lt;/kind-block&gt; &lt;/required-kinds&gt; &lt;/configuration&gt; &lt;signature&gt; VGhpcyBpcyBub3QgcmlnaHQhCg== &lt;/signature&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;データモデル&gt;単一の&lt;/データモデル&gt; &lt;アクセス制御&gt; USER-MATCH &lt;/アクセス制御&gt; &lt;MAX-カウント&gt; 1 &lt;/最大カウント&gt; &lt;最大サイズ&gt; 100 &lt;/最大サイズ&gt; &lt;/種類&gt; &lt;種類署名&gt; VGhpcyBpcyBub3QgcmlnaHQhCg == &lt;/種類署名&gt; &lt;/一種ブロック&gt; &lt;種類のブロック&gt; &lt;種類ID = &#34;2000&#34;&gt; &lt;データモデル&gt; ARRAY &lt;/データモデル&gt; &lt;アクセス制御&gt; NODE-複数の&lt;/アクセス制御&gt; &lt;MAX-ノード多&gt; 3 &lt;/ MAX-ノード多重&gt; &lt;MAX-カウント&gt; 22 &lt;/最大カウント&gt; &lt;最大サイズ&gt; 4 &lt;/最大-size&gt; &lt;EXT：例種延長&gt; 1 &lt;/ EXT：例種延長&gt; &lt;/種類&gt; &lt;種類署名&gt; VGhpcyBpcyBub3QgcmlnaHQhCg == &lt;/種類署名&gt; &lt;/一種ブロック&gt; &lt;/必要-kinds&gt; &lt;/構成&gt; &lt;署名&gt; VGhpcyBpcyBub3QgcmlnaHQhCg == &lt;/署名&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;configuration instance-name=&#34;other.example.net&#34;&gt; &lt;/configuration&gt; &lt;signature&gt; VGhpcyBpcyBub3QgcmlnaHQhCg== &lt;/signature&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
&lt;構成インスタンス名= &#34;other.example.net&#34;&gt; &lt;/構成&gt; &lt;署名&gt; VGhpcyBpcyBub3QgcmlnaHQhCg == &lt;/署名&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
&lt;/overlay&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
&lt;/オーバーレイ&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file MUST be a well-formed XML document, and it SHOULD contain an encoding declaration in the XML declaration. The file MUST use the UTF-8 character encoding. The namespaces for the elements defined in this specification are urn:ietf:params:xml:ns:p2p:config-base and urn:ietf:params:xml:ns:p2p:config-chord.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルは、整形式XML文書でなければなりません、そして、それはXML宣言にエンコーディング宣言を含むべきです。ファイルはUTF-8文字エンコーディングを使用しなければなりません。本明細書で定義された要素のためのネームスペースはURNである：IETF：paramsは：XML：NS：P2P：CONFIG-ベースとURN：IETF：paramsは：XML：NS：P2P：CONFIG-コード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that elements or attributes that are defined as type xsd:boolean in the RELAX NG schema (Section 11.1.1) have two lexical representations, &#34;1&#34; or &#34;true&#34; for the concept true, and &#34;0&#34; or &#34;false&#34; for the concept false. Whitespace and case processing follows the rules of [OASIS.relax_ng] and XML Schema Datatypes [W3C.REC-xmlschema-2-20041028].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、RELAX NGスキーマ（セクション11.1.1）のboolean 2つの語彙表現を持っている「1」または「真」真の概念のために、「0」または「false」の場合：要素または属性型XSDとして定義されていることに注意してくださいコンセプトはfalse。空白とケース処理のルール[OASIS.relax_ng]及びXMLスキーマデータ型を次の[W3C.REC-XMLSCHEMA-2から20041028]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file MAY contain multiple &#34;configuration&#34; elements, where each one contains the configuration information for a different overlay. Each configuration element MAY be followed by signature elements that provide a signature over the preceding configuration element. Each configuration element has the following attributes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファイルには、それぞれが異なるオーバーレイの設定情報が含まれている複数の「設定」の要素を含んでいてもよいです。各構成要素は、前述の構成要素の上に署名を提供する署名要素が続いてもよいです。各構成要素は次の属性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
instance-name The name of the overlay (referred to as &#34;overlay name&#34; in this specification)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイ（本明細書では「オーバーレイ名」という。）の名称をインスタンス名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
expiration Time in the future at which this overlay configuration is no longer valid. The node SHOULD retrieve a new copy of the configuration at a randomly selected time that is before the expiration time. Note that if the certificates expire before a new configuration is retried, the node will not be able to validate the configuration file. All times MUST conform to the Internet date/time format defined in [RFC3339] and be specified using UTC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将来的には有効期限はどの時にこのオーバーレイの設定が有効ではありません。ノードは、有効期限の前にあるランダムに選択された時点での構成の新しいコピーを取得する必要があります。新しい設定を再試行する前に、証明書の有効期限が切れた場合、ノードは、構成ファイルを検証することはできないことに注意してください。すべての回は、[RFC3339]で定義されたインターネットの日付/時刻形式に従わなければなりませんし、UTCを使用して指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequence A monotonically increasing sequence number between 0 and 2^16-2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス0から2 ^ 16-2の間で単調に増加するシーケンス番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inside each overlay element, the following elements can occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各オーバーレイ要素の内部では、以下の要素が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
topology-plug-in This element defines the overlay algorithm being used. If missing, the default is &#34;CHORD-RELOAD&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トポロジ・プラグインこの要素は使用されているオーバーレイアルゴリズムを定義します。不足している場合は、デフォルトでは「CHORD-RELOAD」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
node-id-length This element contains the length of a NodeId (NodeIdLength), in bytes. This value MUST be between 16 (128 bits) and 20 (160 bits). If this element is not present, the default of 16 is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードIDの長さは、この要素はバイト単位で、NODEID（NodeIdLength）の長さを含みます。この値は16（128ビット）および20（160ビット）の間でなければなりません。この要素が存在しない場合、16のデフォルトが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
root-cert This element contains a base-64-encoded X.509v3 certificate that is a root trust anchor used to sign all certificates in this overlay. There can be more than one root-cert element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この要素をルート証明書ルートトラストアンカーは、このオーバーレイですべての証明書に署名するために使用されたBase 64エンコードX.509v3証明書が含まれています。複数のルート証明書の要素が存在する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enrollment-server This element contains the URL at which the enrollment server can be reached in a &#34;url&#34; element. This URL MUST be of type &#34;https:&#34;. More than one enrollment-server element MAY be present. Note that there is no necessary relationship between the overlay name/ configuration server name and the enrollment server name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録サーバは、この要素は、登録サーバは、「URL」要素に到達可能なURLが含まれています。このURLは型でなければなりません「HTTPS：」。複数の登録-server要素が存在してもよいです。オーバーレイ名/コンフィギュレーション・サーバ名と登録サーバ名の間には、必要な関係が存在しないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
self-signed-permitted This element indicates whether self-signed certificates are permitted. If it is set to &#34;true&#34;, then self-signed certificates are allowed, in which case the enrollment-server and root-cert elements MAY be absent. Otherwise, it SHOULD be absent, but MAY be set to &#34;false&#34;. This element also contains an attribute &#34;digest&#34;, which indicates the digest to be used to compute the Node-ID. Valid values for this parameter are &#34;sha1&#34; and &#34;sha256&#34;, representing SHA-1 [RFC3174] and SHA-256 [RFC6234], respectively. Implementations MUST support both of these algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
自己署名許可この要素は、自己署名証明書が許可されているかどうかを示します。それが「真」に設定されている場合、自己署名証明書は、その場合には、登録サーバとルート証明書の要素が存在しなくてもよく、許可されています。それ以外の場合は不在である必要がありますが、「偽」に設定することができます。この要素はまた、ノードIDを計算するために使用されるダイジェストを示しており、「ダイジェスト」属性が含まれています。このパラメータの有効な値は、それぞれ、SHA-1 [RFC3174]及びSHA-256 [RFC6234]を表す &#34;SHA1&#34; および &#34;SHA256&#34; です。実装は、これらのアルゴリズムの両方をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bootstrap-node This element represents the address of one of the bootstrap nodes. It has an attribute called &#34;address&#34; that represents the IP address (either IPv4 or IPv6, since they can be distinguished) and an optional attribute called &#34;port&#34; that represents the port and defaults to 6084. The IPv6 address is in typical hexadecimal form using standard period and colon separators as specified in [RFC5952]. More than one bootstrap-node element MAY be present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブートストラップノードこの要素は、ブートストラップノードのいずれかのアドレスを表します。 （それらは区別することができるので、IPv4またはIPv6のいずれか）には、IPアドレスを示す「アドレス」と呼ばれる属性を有し、6084.ザIPv6アドレスのポートと既定値を表し、「ポート」と呼ばれるオプションの属性は、典型的な16進形式であります[RFC5952]で指定されるように、標準的な期間及び結腸セパレータを使用。複数のブートストラップノードの要素が存在してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
turn-density This element is a positive integer that represents the approximate reciprocal of density of nodes that can act as TURN servers. For example, if 5% of the nodes can act as TURN servers, this element would be set to 20. If it is not present, the default value is 1. If there are no TURN servers in the overlay, it is set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ターン密度をこの要素は、TURNサーバとして機能できるノードの密度の近似逆数を表す正の整数です。ノードの5％TURNサーバとして機能することができる場合、それが存在しない場合、例えば、この要素は、オーバーレイにはTURNサーバが存在しない場合、デフォルト値は、それがゼロに設定されている、1で20に設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clients-permitted This element represents whether clients are permitted or whether all nodes must be peers. If clients are permitted, the element MUST be set to &#34;true&#34; or be absent. If the nodes are not allowed to remain clients after the initial join, the element MUST be set to &#34;false&#34;. There is currently no way for the overlay to enforce this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この要素は、クライアントが許可されるかどうか、またはすべてのノードがピアでなければならないか否かを示すクライアントが許可します。クライアントが許可されている場合は、要素が「真」に設定するか、または存在しないことがなければなりません。初期に参加した後、ノードがクライアントままに許可されていない場合は、要素が「偽」に設定しなければなりません。オーバーレイはこれを強制するための方法はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no-ice This element represents whether nodes are REQUIRED to use the &#34;No-ICE&#34; Overlay Link protocols in this overlay. If it is absent, it is treated as if it were set to &#34;false&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
無氷は、この要素は、ノードは、このオーバーレイで「いいえ-ICE」オーバーレイ・リンク・プロトコルを使用する必要があるかどうかを表していません。それが存在しない場合は、それが「偽」に設定されているかのように扱われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chord-update-interval The update frequency for the CHORD-RELOAD Topology Plug-in (see Section 10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コード更新間隔CHORDリロードトポロジプラグインの更新頻度（セクション10を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chord-ping-interval The Ping frequency for the CHORD-RELOAD Topology Plug-in (see Section 10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
和音のping間隔CHORD-RELOADトポロジプラグイン（セクション10を参照）のためのPingの頻度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chord-reactive Whether reactive recovery SHOULD be used for this overlay. It is set to &#34;true&#34; or &#34;false&#34;. If missing, the default is &#34;true&#34; (see Section 10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
和音反応性反応性回復は、このオーバーレイのために使用すべきかどうか。それは、「true」または「false」に設定されています。不足している場合は、デフォルトが「真」である（セクション10を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
shared-secret If shared secret mode is used, this element contains the shared secret. The security guarantee here is that any agent which is able to access the Configuration Document (presumably protected by some sort of HTTP access control or network topology) is able to recover the shared secret and hence join the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有秘密共有秘密モードを使用する場合は、この要素は、共有秘密が含まれています。ここでは、セキュリティの保証は（おそらくHTTPアクセス制御やネットワークトポロジのいくつかの並べ替えで保護）設定文書にアクセスすることができる任意の薬剤は、共有秘密を回復するので、オーバーレイに参加することが可能であることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-message-size Maximum size, in bytes, of any message in the overlay. If this value is not present, the default is 5000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大メッセージサイズの最大サイズ（バイト単位）、オーバーレイ内の任意のメッセージ。この値が存在しない場合、デフォルトは5000です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initial-ttl Initial default TTL for messages (see Section 6.3.2). If this value is not present, the default is 100.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージのための初期-TTL初期のデフォルトTTL（セクション6.3.2を参照してください）。この値が存在しない場合、デフォルトは100です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay-reliability-timer Default value for the end-to-end retransmission timer for messages, in milliseconds. If not present, the default value is 3000. The value MUST be at least 200 milliseconds, which means the minimum time delay before dropping a link is 1000 milliseconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミリ秒単位でのメッセージのエンドツーエンド再送タイマー、のオーバーレイ・信頼性・タイマーのデフォルト値。存在しない場合、デフォルト値は3000である値は、リンクを削除する前に、最小の遅延時間が1000ミリ秒であることを意味している、少なくとも200ミリ秒でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay-link-protocol Indicates a permissible overlay link protocol (see Section 6.6.1 for requirements for such protocols). An arbitrary number of these elements may appear. If none appear, then this implies the default value, &#34;TLS&#34;, which refers to the use of TLS and DTLS. If one or more elements appear, then no default value applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイ・リンク・プロトコルは、（そのようなプロトコルのための要件については、6.6.1項を参照）、許容オーバーレイリンクプロトコルを示します。これらの要素の任意の数が表示されてもよいです。何も表示されない場合、これはTLSとDTLSの使用を意味するデフォルト値、「TLS」を、意味しています。一個の以上の要素が表示された場合は、デフォルト値は適用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind-signer This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID is allowed to sign Kinds. Identifying kind-signer by Node-ID instead of certificate allows the use of short-lived certificates without constantly having to provide an updated configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類、署名者は、これは16進数で単一のノードIDが含まれており、このノードIDを持つ証明書は種類に署名するために許可されていることを示しています。代わりに、証明書のノードIDによって特定の種類、署名者は、常に更新された設定ファイルを提供することなく、短命の証明書を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
configuration-signer This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID is allowed to sign configurations for this instance-name. Identifying the signer by Node-ID instead of certificate allows the use of short-lived certificates without constantly having to provide an updated configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構成、署名者は、これは16進数で単一のノードIDが含まれており、このノードIDを持つ証明書は、このインスタンス名の構成を署名するために許可されていることを示しています。代わりに、証明書のノードIDによって署名者を特定することは常に更新された設定ファイルを提供することなく、短命の証明書を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad-node This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID MUST NOT be considered valid. This allows certificate revocation. An arbitrary number of these elements can be provided. Note that because certificates may expire, bad-node entries need be present only for the lifetime of the certificate. Technically speaking, bad Node-IDs may be reused after their certificates have expired. The requirement for Node-IDs to be pseudorandomly generated gives this event a vanishing probability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
悪いノードこれは16進数で、単一ノードIDが含まれており、このノードIDを持つ証明書が有効と見なされてはならないことを示しています。これは、証明書の失効を可能にします。これらの要素の任意の数を設けることができます。証明書の期限が切れる可能性があるため、不正なノードのエントリが唯一の証明書の有効期間のために存在する必要があります。その証明書の期限が切れた後に技術的に言えば、悪いノードIDは再利用してもよいです。疑似ランダムに生成されるノードIDの要件は、このイベントに消失確率を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mandatory-extension This element contains the name of an XML namespace that a node joining the overlay MUST support. The presence of a mandatory-extension element does not require the extension to be used in the current configuration file, but can indicate that it may be used in the future. Note that the namespace is case-sensitive, as specified in Section 2.3 of [w3c-xml-namespaces]. More than one mandatory-extension element MAY be present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必須拡張この要素は、オーバーレイに参加するノードがサポートしなければならないXML名前空間の名前が含まれています。必須の伸長要素の存在は、現在の構成ファイルで使用される拡張を必要としないが、それは将来的に使用することができることを示すことができます。 [W3C-XML-名前空間]のセクション2.3で指定された名前空間は、大文字と小文字が区別されることに留意されたいです。複数の必須拡張要素が存在してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inside each configuration element, the required-kinds element MAY also occur. This element indicates the Kinds that members MUST support and contains multiple kind-block elements that each define a single Kind that MUST be supported by nodes in the overlay. Each kind-block consists of a single kind element and a kind-signature. The kind element defines the Kind. The kind-signature is the signature computed over the kind element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各構成要素の中では、必要な-種類の要素も発生することがあります。この要素は、メンバーがサポートしなければならないの種類を示し、各オーバーレイ内のノードによってサポートされなければならない一種類を定義する複数種類のブロック要素を含みます。各種類のブロックは、一種類の元素と種類署名から成ります。親切な要素は、種類を定義します。種類署名は、一種の元素に対して計算署名です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each kind element has either an id attribute or a name attribute. The name attribute is a string representing the Kind (the name registered to IANA), while the id is an integer Kind-ID allocated out of private space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各種類の要素にはid属性やname属性のいずれかを持っています。 IDは整数種類-IDプライベート空間の外に割り当てられている間name属性は、種類（IANAに登録された名前）を表す文字列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the kind element MUST contain the following elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、親切な要素は、以下の要素を含まなければなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-count The maximum number of values which members of the overlay must support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイのメンバーがサポートしなければならない値の最大数を最大カウント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
data-model The data model to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用するデータ・モデルのデータモデル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-size The maximum size of individual values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
個々の値の最大サイズ最大サイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
access-control The access control model to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用するアクセス制御モデルをアクセス制御します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The kind element MAY also contain the following element:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
親切な要素は、次の要素が含まれる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-node-multiple If the access control is NODE-MULTIPLE, this element MUST be included. This indicates the maximum value for the i counter. It MUST be an integer greater than 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAX-ノード多重アクセス制御はNODE-MULTIPLEの場合、この要素を含まなければなりません。これは私カウンタの最大値を示します。これは、0より大きい整数でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All of the non-optional values MUST be provided. If the Kind is registered with IANA, the data-model and access-control elements MUST match those in the Kind registration, and clients MUST ignore them in favor of the IANA versions. Multiple kind-block elements MAY be present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非オプション値のすべてが提供されなければなりません。種類は、IANAに登録されている場合は、データ・モデルおよびアクセス制御要素は、種類登録のものと一致しなければならない、とクライアントは、IANAのバージョンの賛成でそれらを無視しなければなりません。複数種類のブロック要素が存在してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The kind-block element also MUST contain a &#34;kind-signature&#34; element. This signature is computed across the kind element from the beginning of the first &lt; of the kind element to the end of the last &gt; of the kind element in the same way as the signature element described later in this section. kind-block elements MUST be signed by a node listed in the kind-signers block of the current configuration. Receivers MUST verify the signature prior to accepting a kind-block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類ブロック要素は、「種類署名」要素を含まなければなりません。この署名は、このセクションで後述する署名要素と同様に、種類要素の最初の開始から&lt;種類の要素の最後の最後に&gt;一種要素を横切って計算されます。種類ブロック要素は、現在の構成の種類、署名者のブロックにリストされたノードによって署名されなければなりません。受信機は、従来品種ブロックを受け入れるに署名を検証しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The configuration element MUST be treated as a binary blob that cannot be changed -- including any whitespace changes -- or the signature will break. The signature MUST be computed by taking each configuration element and starting from, and including, the first &lt; at the start of &lt;configuration&gt; up to and including the &gt; in &lt;/ configuration&gt; and treating this as a binary blob that MUST be signed using the standard SecurityBlock defined in Section 6.3.4. The SecurityBlock MUST be base-64 encoded using the base64 alphabet from [RFC4648] and MUST be put in the signature element following the configuration object in the configuration file. Any configuration file MUST be signed by one of the configuration-signer elements from the previous extant configuration. Recipients MUST verify the signature prior to accepting the configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
空白の変更を含む -   - 構成要素を変更することはできないバイナリBLOBとして扱わなければならない、または署名が解除されます。署名は、各構成要素を取り、から出発し、そしてなど、最初の&lt;まで&lt;構成&gt;の開始時を含む&gt;に&lt;/構成&gt;と使用して署名されなければならないバイナリブロブとしてこれを処理することによって計算されなければなりません6.3.4項で定義された標準SecurityBlock。 SecurityBlockは[RFC4648]からBASE64アルファベットを使用して、BASE64符号化されなければならないと、構成ファイル内の構成オブジェクト以下の署名要素に入れなければなりません。任意のコンフィギュレーション・ファイルは、前の現存構成からの構成、署名要素のいずれかによって署名されなければなりません。受信者は、従来の設定ファイルを受け入れるに署名を検証しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a node receives a new configuration file, it MUST change its configuration to meet the new requirements. This may require the node to exit the DHT and rejoin. If a node is not capable of supporting the new requirements, it MUST exit the overlay. If some information about a particular Kind changes from what the node previously knew about the Kind (for example, the max size), the new information in the configuration files overrides any previously learned information. If any Kind data was signed by a node that is no longer allowed to sign Kinds, that Kind MUST be discarded along with any stored information of that Kind. Note that forcing an avalanche restart of the overlay with a configuration change that requires rejoining the overlay may result in serious performance problems, including total collapse of the network if configuration parameters are not properly considered. Such an event may be necessary in case of a compromised CA or similar problem, but for large overlays, it should be avoided in almost all circumstances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードは、新しい設定ファイルを受信すると、それは新しい要件を満たすために、その構成を変更する必要があります。これは、DHTを終了し、再参加するノードが必要な場合があります。ノードが新しい要件をサポートすることができない場合は、オーバーレイを終了する必要があります。ノードは、以前種類（例えば、最大サイズ）について知っていたから、特定の種類の変更に関するいくつかの情報場合は、コンフィギュレーションファイルに新しい情報が、以前に学習した情報を上書きします。あらゆる種類のデータがもはや種類の署名を許可されたノードによって署名された場合、その種類は、その種の任意の格納された情報と一緒に廃棄しなければなりません。設定パラメータが適切に考慮されていない場合は、オーバーレイを再結合すると、ネットワーク全体の崩壊を含め、深刻なパフォーマンスの問題をもたらす可能性が必要で、構成変更にオーバーレイの雪崩の再起動を強制することに注意してください。そのようなイベントが損なわCAまたは類似の問題が発生した場合に必要であるかもしれないが、大きなオーバーレイのために、それはほとんどすべての状況で避けるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1. RELAX NG Grammar
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1.  NG文法をRELAX
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The grammar for the configuration data is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンフィギュレーション・データのための文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
namespace chord = &#34;urn:ietf:params:xml:ns:p2p:config-chord&#34; namespace local = &#34;&#34; default namespace p2pcf = &#34;urn:ietf:params:xml:ns:p2p:config-base&#34; namespace rng = &#34;http://relaxng.org/ns/structure/1.0&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名前空間和音= &#34;壷：IETF：のparams：XML：NS：P2Pます。config-和音&#34; 名前空間ローカル= &#34;&#34; デフォルトの名前空間p2pcf = &#34;壷：IETF：のparams：XML：NS：P2Pます。config-ベース&#34; の名前空間RNG = &#34; http://relaxng.org/ns/structure/1.0&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
anything = (element * { anything } | attribute * { text } | text)*
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何も=（要素* {何} |属性* {テキスト} |テキスト）*
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
foreign-elements = element * - (p2pcf:* | local:* | chord:*) { anything }* foreign-attributes = attribute * - (p2pcf:*|local:*|chord:*) { text }* foreign-nodes = (foreign-attributes | foreign-elements)*
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
外国要素=エレメント*  - （p2pcf：* |ローカル：* |和音：*）{何} *外国属性=属性*  - （p2pcf：* |ローカル：* |和音：*）{テキスト} * foreign-ノード=（外国属性|外国要素）*
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
start = element p2pcf:overlay { overlay-element }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
=エレメントp2pcfを開始しますオーバーレイ{オーバーレイ要素}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay-element &amp;= element configuration { attribute instance-name { xsd:string }, attribute expiration { xsd:dateTime }?, attribute sequence { xsd:long }?, foreign-attributes*, parameter }+ overlay-element &amp;= element signature { attribute algorithm { signature-algorithm-type }?, xsd:base64Binary }*
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイ要素＆=素子の構成{インスタンス名{XSD属性：文字列を}、属性の有効期限{XSD：外国属性*長い}？、パラメータ：dateTimeの}？属性配列{XSD} +オーバーレイ要素＆=エレメント署名{属性アルゴリズム{署名アルゴリズムタイプ}？のxsd：base64Binaryの} *
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature-algorithm-type |= &#34;rsa-sha1&#34; signature-algorithm-type |= xsd:string # signature alg extensions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名アルゴリズム型| = &#34;RSA-SHA1&#34; 署名アルゴリズム型| =のxsd：文字列＃署名ALG機能拡張
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
parameter &amp;= element topology-plugin { topology-plugin-type }? topology-plugin-type |= xsd:string # topo plugin extensions parameter &amp;= element max-message-size { xsd:unsignedInt }? parameter &amp;= element initial-ttl { xsd:int }? parameter &amp;= element root-cert { xsd:base64Binary }* parameter &amp;= element required-kinds { kind-block* }? parameter &amp;= element enrollment-server { xsd:anyURI }* parameter &amp;= element kind-signer { xsd:string }* parameter &amp;= element configuration-signer { xsd:string }* parameter &amp;= element bad-node { xsd:string }* parameter &amp;= element no-ice { xsd:boolean }? parameter &amp;= element shared-secret { xsd:string }? parameter &amp;= element overlay-link-protocol { xsd:string }* parameter &amp;= element clients-permitted { xsd:boolean }? parameter &amp;= element turn-density { xsd:unsignedByte }? parameter &amp;= element node-id-length { xsd:int }? parameter &amp;= element mandatory-extension { xsd:string }* parameter &amp;= foreign-elements*
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメーター＆=要素トポロジプラグイン{トポロジ・プラグインタイプ}？トポロジ・プラグイン型| =のxsd：文字列＃トポプラグイン拡張パラメータ＆=要素の最大メッセージサイズ{のxsd：unsignedInt型}？パラメーター＆=エレメント初期TTL {XSD：INT}？パラメーター＆=エレメントルート証明書{XSD：base64Binaryの} *パラメータ＆=エレメント所要種類{種類ブロック*}？パラメーター＆=エレメント登録サーバ{XSD：anyURIの} *パラメータ＆=要素の種類、署名者{XSD：文字列} *パラメータ＆=要素の構成、署名者{XSD：文字列} *パラメータ＆=エレメント悪いノード{XSD：列} *パラメータ＆=エレメント無氷{XSD：ブール}？パラメーター＆=エレメント共有秘密{XSD：文字列}？パラメーター＆=要素オーバーレイリンクプロトコル{XSD：文字列} *パラメータ＆=エレメントクライアント許可{XSD：ブール}？パラメーター＆=エレメントターン密度{XSD：なunsignedByte}？パラメーター＆=要素ノードID長{XSD：INT}？パラメーター＆=エレメント必須の拡張{XSD：文字列} *パラメータ＆=外国要素*
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
parameter &amp;= element self-signed-permitted { attribute digest { self-signed-digest-type }, xsd:boolean }? self-signed-digest-type |= &#34;sha1&#34; self-signed-digest-type |= xsd:string # signature digest extensions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメーター＆=素子の自己署名許可は、{：ブール、{自己署名ダイジェスト型}ダイジェストXSD属性}？自己署名ダイジェスト型| =「SHA1」自己署名ダイジェスト型| =のxsd：文字列＃署名は、拡張をダイジェスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
parameter &amp;= element bootstrap-node { attribute address { xsd:string }, attribute port { xsd:int }? }*
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パラメーター＆=エレメントブートストラップノード{属性アドレス{XSD：INT}：文字列}、ポート{XSD属性？ } *
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind-block = element kind-block { element kind { ( attribute name { kind-names } | attribute id { xsd:unsignedInt } ), kind-parameter } &amp; element kind-signature { attribute algorithm { signature-algorithm-type }?, xsd:base64Binary }? }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類ブロック=エレメント種類ブロック{要素は一種{（}品種名{属性名|属性ID {XSD：unsignedInt型}）、種別パラメータ}＆素子種類署名{属性アルゴリズム{署名アルゴリズムタイプ}？ 、XSD：base64Binaryの}？ }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind-parameter &amp;= element max-count { xsd:int } kind-parameter &amp;= element max-size { xsd:int } kind-parameter &amp;= element max-node-multiple { xsd:int }?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種別パラメータ＆=エレメント最大カウント{XSD：INT}種類パラメータ＆=要素の最大サイズ{XSD：INT}種類パラメータ＆=エレメントMAX-ノード複数{XSD：INT}？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind-parameter &amp;= element data-model { data-model-type } data-model-type |= &#34;SINGLE&#34; data-model-type |= &#34;ARRAY&#34; data-model-type |= &#34;DICTIONARY&#34; data-model-type |= xsd:string # data model extensions kind-parameter &amp;= element access-control { access-control-type } access-control-type |= &#34;USER-MATCH&#34; access-control-type |= &#34;NODE-MATCH&#34; access-control-type |= &#34;USER-NODE-MATCH&#34; access-control-type |= &#34;NODE-MULTIPLE&#34; access-control-type |= xsd:string # access control extensions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種別パラメータ＆=要素データモデル{データ機種}データモデル型| =「SINGLE」データモデル型| =「アレイ」データモデル型| =「辞書」データモデル - タイプ| =のxsd：文字列＃データモデルの拡張種類パラメータ＆=要素アクセス制御{アクセス制御型}アクセス制御型| = &#34;USER-MATCH&#34; アクセス制御型| = &#34;NODE-MATCH&#34;アクセス制御型| = &#34;USER-NODE-MATCH&#34; アクセス制御型| = &#34;NODE-複数の&#34; アクセス制御型| =のxsd：文字列＃アクセス制御の拡張
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind-parameter &amp;= foreign-elements*
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類パラメータ＆=外国要素*
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind-names |= &#34;TURN-SERVICE&#34; kind-names |= &#34;CERTIFICATE_BY_NODE&#34; kind-names |= &#34;CERTIFICATE_BY_USER&#34; kind-names |= xsd:string # kind extensions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類・名称| = &#34;TURN-SERVICE&#34; の種類・名称| = &#34;CERTIFICATE_BY_NODE&#34; 親切-名| = &#34;CERTIFICATE_BY_USER&#34; 親切-名| =のxsd：文字列＃1種類の拡張子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
# Chord specific parameters topology-plugin-type |= &#34;CHORD-RELOAD&#34; parameter &amp;= element chord:chord-ping-interval { xsd:int }? parameter &amp;= element chord:chord-update-interval { xsd:int }? parameter &amp;= element chord:chord-reactive { xsd:boolean }?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
＃コード固有のパラメータ・トポロジー・プラグイン型| = &#34;CHORDリロード&#34; パラメータ＆=エレメントコード：コードのping間隔{XSD：INT}？パラメーター＆=エレメントコード：コード更新間隔{XSD：INT}？パラメーター＆=エレメントコード：コード反応{XSD：ブール}？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Discovery through Configuration Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. コンフィギュレーション・サーバを通じて発見
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a node first enrolls in a new overlay, it starts with a discovery process to find a configuration server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードは、最初に新しいオーバーレイに入学すると、それは構成サーバーを見つけるために、検出プロセスを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The node MAY start by determining the overlay name. This value MUST be provided by the user or some other out-of-band provisioning mechanism. The out-of-band mechanism MAY also provide an optional URL for the configuration server. If a URL for the configuration server is not provided, the node MUST do a DNS SRV query using a Service name of &#34;reload-config&#34; and a protocol of TCP to find a configuration server and form the URL by appending a path of &#34;/.well-known/reload-config&#34; to the overlay name. This uses the &#34;well-known URI&#34; framework defined in [RFC5785]. For example, if the overlay name was example.com, the URL would be &#34;https://example.com/.well-known/reload-config&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードは、オーバーレイ名を決定することにより開始することができます。この値は、ユーザまたは他の何らかのアウトオブバンドプロビジョニングメカニズムによって提供されなければなりません。アウトオブバンドメカニズムは、コンフィギュレーションサーバ用のオプションのURLを提供することができます。コンフィギュレーションサーバのURLが提供されていない場合、ノードが構成サーバーを見つけ、/」のパスを追加することによって、URLを形成するために、「リロード-config設定を」のサービス名とTCPのプロトコルを使用してDNS SRVのクエリを実行しなければなりませんオーバーレイ名に/リロード-config設定を」.well知られています。これは[RFC5785]で定義された「よく知られているURI」フレームワークを使用します。オーバーレイ名がexample.comだった場合、URLは「https://example.com/.well-known/reload-config」になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once an address and URL for the configuration server are determined, the peer MUST form an HTTPS connection to that IP address. If an optional URL for the configuration server was provided, the certificate MUST match the domain name from the URL as described in [RFC2818]; otherwise, the certificate MUST match the overlay name as described in [RFC2818]. If the HTTPS certificates pass the name matching, the node MUST fetch a new copy of the configuration file. To do this, the peer performs a GET to the URL. The result of the HTTP GET is an XML configuration file described above. If the XML is not valid or the instance-name attribute of the overlay-element in the XML does not match the overlay name, this configurations file
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンフィギュレーションサーバのアドレスやURLが決定されると、ピアはそのIPアドレスへのHTTPS接続を形成しなければなりません。コンフィギュレーション・サーバのための任意のURLが提供された場合、証明書は、[RFC2818]に記載されているようにURLからのドメイン名と一致しなければなりません。 [RFC2818]に記載されているようにそうでなければ、証明書は、オーバーレイ名と一致しなければなりません。 HTTPS証明書は、名前の一致を渡すと、ノードは、構成ファイルの新しいコピーを取得しなければなりません。これを行うには、ピアは、URLにGETを実行します。 HTTPのGETの結果は、上記のXML設定ファイルです。 XMLが有効ではありませんか、XMLでのオーバーレイ要素のインスタンス名属性がオーバーレイ名と一致しない、これはファイルを構成した場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHOULD be discarded. Otherwise, the new configuration MUST replace any previously learned configuration file for this overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
廃棄すべき。そうでない場合は、新しいコンフィギュレーションは、このオーバーレイの任意の以前に学んだ設定ファイルを置き換える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For overlays that do not use a configuration server, nodes MUST obtain the configuration information needed to join the overlay through some out-of-band approach, such as an XML configuration file sent over email.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構成サーバーを使用しないオーバーレイの場合は、ノードは、電子メールを介して送信されるXML設定ファイルなどの一部のアウトオブバンドアプローチを通じて、オーバーレイに参加するために必要な設定情報を取得する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. Credentials
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. 資格情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Configuration Document contains an enrollment-server element, credentials are REQUIRED to join the Overlay Instance. A peer which does not yet have credentials MUST contact the enrollment server to acquire them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定文書が登録-server要素が含まれている場合、資格情報がオーバーレイインスタンスに参加するために必要とされています。まだ資格情報を持っていないピアは、それらを取得するために登録サーバに接続しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD defines its own trivial certificate request protocol. We would have liked to have used an existing protocol, but were concerned about the implementation burden of even the simplest of those protocols, such as [RFC5272] and [RFC5273]. The objective was to have a protocol which could be easily implemented in a Web server which the operator did not control (e.g., in a hosted service) and which was compatible with the existing certificate-handling tooling as used with the Web certificate infrastructure. This means accepting bare PKCS#10 requests and returning a single bare X.509 certificate. Although the MIME types for these objects are defined, none of the existing protocols support exactly this model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADは、独自の些細な証明書の要求のプロトコルを定義します。私たちは、既存のプロトコルを使用していると言っていますが、そのような[RFC5272]と[RFC5273]のように、これらのプロトコルの最も単純なの実装の負担を懸念しているだろう。目的は、容易に（ホスティングサービスで、例えば）オペレータは制御しなかったWebサーバに実装することができ、ウェブ証明書インフラストラクチャで使用されるように、既存の証明書ハンドリングツールと互換性があったプロトコルを持っていることでした。これは、裸のPKCS＃10の要求を受け入れ、単一の裸のX.509証明書を返すことを意味します。これらのオブジェクトのMIMEタイプが定義されていますが、既存のプロトコルのいずれもが、まさにこのモデルをサポートしていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificate request protocol MUST be performed over HTTPS. The server certificate MUST match the overlay name as described in [RFC2818]. The request MUST be an HTTP POST with the parameters encoded as described in [RFC2388] and with the following properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書要求プロトコルはHTTPS上で実行されなければなりません。 [RFC2818]に記載されているように、サーバ証明書は、オーバーレイ名と一致しなければなりません。要求は、[RFC2388]に、次のプロパティで説明したようにエンコードされたパラメータを持つHTTP POSTでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If authentication is required, there MUST be form parameters of &#34;password&#34; and &#34;username&#34; containing the user&#39;s account name and password in the clear (hence the need for HTTPS). The username and password strings MUST be UTF-8 strings compared as binary objects. Applications using RELOAD SHOULD define any needed string preparation as per [RFC4013] or its successor documents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証が必要な場合は、O、「パスワード」およびクリア（HTTPS用故に必要）で、ユーザーのアカウント名とパスワードを含む「ユーザー名」の形式のパラメータがあるに違いありません。ユーザー名とパスワードの文字列はバイナリオブジェクトとして比較UTF-8文字列でなければなりません。 RELOADを使用するアプリケーションは、[RFC4013]やその後継文書ごとに、必要な文字列の準備を定義する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If more than one Node-ID is required, there MUST be a form parameter of &#34;nodeids&#34; containing the number of Node-IDs required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のノードIDが必要な場合はO、必要なノードIDの数を含む「ノード識別子」の形式パラメータがなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There MUST be a form parameter of &#34;csr&#34; with a content type of &#34;application/pkcs10&#34;, as defined in [RFC2311], that contains the certificate signing request (CSR).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2311]で定義されるように、O、「アプリケーション/ PKCS10」のコンテンツタイプの「CSR」のフォームパラメータが存在しなければならないことは、証明書署名要求（CSR）を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Accept header MUST contain the type &#34;application/pkix-cert&#34;, indicating the type that is expected in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O受け入れヘッダが応答して予想されるタイプを示す、タイプ「アプリケーション/ PKIX-CERT」を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The enrollment server MUST authenticate the request using the provided account name and password. The reason for using the RFC 2388 &#34;multipart/form-data&#34; encoding is so that the password parameter will not be encoded in the URL, to reduce the chance of accidental leakage of the password. If the authentication succeeds and the requested user name in the CSR is acceptable, the server MUST generate and return a certificate for the CSR in the &#34;csr&#34; parameter of the request. The SubjectAltName field in the certificate MUST contain the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録サーバは、提供されたアカウント名とパスワードを使用して要求を認証しなければなりません。パスワードパラメータは、パスワードの偶発漏れの可能性を減らすために、URLにエンコードされないように、RFC 2388「マルチパート/フォームデータ」エンコーディングを使用する理由はあります。認証が成功し、CSRにおける要求されたユーザ名が許容される場合は、サーバが生成し、リクエストの「CSR」パラメータでCSRの証明書を返さなければなりません。証明書のSubjectAltNameフィールドには、次の値を含まなければなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o One or more Node-IDs which MUST be cryptographically random [RFC4086]. Each MUST be chosen by the enrollment server in such a way that it is unpredictable to the requesting user. For example, the user MUST NOT be informed of potential (random) Node-IDs prior to authenticating. Each is placed in the subjectAltName using the uniformResourceIdentifier type, each MUST contain RELOAD URI, as described in Section 14.15, and each MUST contain a Destination List with a single entry of type &#34;node_id&#34;. The enrollment server SHOULD maintain a mapping of users to Node-IDs and if the same user returns (e.g., to have their certificate re-issued), the enrollment server should return the same Node-IDs, thus avoiding the need for implementations to re-store all their data when their certificates expire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号ランダム[RFC4086]されなければならない1つまたは複数のノードIDは、O。それぞれは、それが要求しているユーザに予測不可能であるような方法で登録サーバによって選択されなければなりません。たとえば、ユーザーが認証する前に潜在的な（ランダム）ノードのIDを知らされてはなりません。各々がuniformResourceIdentifierでタイプを使用してのsubjectAltNameに配置され、セクション14.15に記載されているようにそれぞれが、リロードURIを含まなければなりません、そして各タイプの単一のエントリ「NODE_ID」と宛先リストを含まなければなりません。登録サーバーは-IDのノードへのユーザーのマッピングを維持する必要がありますし、同じユーザーが戻るが、（例えば、その証明書の再発行を持っている）場合、登録サーバーは、実装が再するため、必要性を回避、同じノードIDを返す必要があります-storeその証明書の有効期限が切れるすべてのデータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A single name (the &#34;user name&#34;) that this user is allowed to use in the overlay, using type rfc822Name. Enrollment servers SHOULD take care to allow only legal characters in the name (e.g., no embedded NULs), rather than simply accepting any name provided by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このユーザーがタイプrfc822Nameでを使用して、オーバーレイでの使用を許可されている単一の名前（「ユーザ名」）O。登録サーバは、単にが提供する任意の名前を受け入れるのではなく、名前でのみ有効な文字（例えば、埋め込まれていないNULs）を許可するように注意する必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
the user. In some usages, the right side of the user name will match the overlay name, but there is no requirement for this match in this specification. Applications using this specification MAY define such a requirement or MAY otherwise limit the allowed range of allowed user names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ユーザー。いくつかの用途では、ユーザー名の右側には、オーバーレイ名と一致しますが、この仕様では、この試合のための必要はありません。この仕様を使用するアプリケーションは、このような要件を定義するか、またはそうでなければ許可されたユーザ名の許容範囲を制限することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SubjectAltName field in the certificate MUST NOT contain any identities other than those listed above. The subject distinguished name in the certificate MUST be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書のSubjectAltNameフィールドには、上記以外のアイデンティティを含めることはできません。証明書のサブジェクト識別名は空でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificate MUST be returned as type &#34;application/pkix-cert&#34;, as defined in [RFC2585], with an HTTP status code of 200 OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2585]で定義されるように証明書が200 OKのHTTPステータスコードと、タイプ「アプリケーション/ PKIX-CERT」として返さなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certificate processing errors SHOULD result in an HTTP return code of 403 Forbidden, along with a body of type &#34;text/plain&#34; and body that consists of one of the tokens defined in the following list:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書処理エラーは、次のリストに定義されたトークンのいずれかから成るタイプのボディ「text / plainの」とボディと一緒に、禁断403のHTTPリターンコードをもたらすはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
failed_authentication The account name and password combination used in the HTTPS request was not valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPSリクエストで使用したアカウント名とパスワードの組み合わせが有効ではありませんでしたfailed_authentication。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
username_not_available The requested user name in the CSR was not acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CSRに要求されたユーザ名をusername_not_availableは受け入れませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Node-IDs_not_available The number of Node-IDs requested was not acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードIDの数は、要求されたノードIDs_not_availableは受け入れませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad_CSR There was some other problem with the CSR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad_CSR CSRと他のいくつかの問題が発生しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client receives an unknown token in the body, it SHOULD treat it as a failure for an unknown reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが体内に不明なトークンを受信した場合、それが原因不明の障害として扱うべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST check that the returned certificate chains back to one of the certificates received in the &#34;root-cert&#34; list of the overlay configuration data (including PKIX BasicConstraints checks). The node then reads the certificate to find the Node-ID it can use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、バック（PKIXの基本制約チェックを含む）オーバーレイ設定データの「ルート証明書」リストで受信した証明書のいずれかにその返された証明書チェーンをチェックしなければなりません。ノードは、それが使用できるノードIDを検索し、証明書を読み込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.1. Self-Generated Credentials
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.1. 自己生成の資格情報
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the &#34;self-signed-permitted&#34; element is present in the configuration and is set to &#34;true&#34;, then a node MUST generate its own self-signed certificate to join the overlay. The self-signed certificate MAY contain any user name of the user&#39;s choice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「自己署名許可」要素は、構成内に存在し、「真」に設定されている場合、ノードはオーバーレイに参加する独自の自己署名証明書を生成しなければなりません。自己署名証明書は、ユーザが選択した任意のユーザ名を含むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For self-signed certificates containing only one Node-ID, the Node-ID MUST be computed by applying the digest specified in the self-signed-permitted element to the DER representation of the user&#39;s public key (more specifically, the subjectPublicKeyInfo) and taking the high-order bits. For self-signed certificates containing multiple Node-IDs, the index of the Node-ID (from 1 to the number of Node-IDs needed) must be prepended as a 4-byte big-endian integer to the DER representation of the user&#39;s public key and taking the high-order bits. When accepting a self-signed certificate, nodes MUST check that the Node-ID and public keys match. This prevents Node-ID theft.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
唯一のノードIDを含む自己署名証明書のために、ノードIDは、ユーザの公開鍵（より具体的には、SubjectPublicKeyInfoで）のDER表現に自己署名許可要素で指定されたダイジェストを適用しとることによって計算されなければなりません上位ビット。複数のノードIDを含む自己署名証明書のために、ノードID（1から必要なノードIDの数まで）のインデックスは、ユーザの公開のDER表現に4バイトのビッグエンディアン整数として付加されなければなりませんキーと上位ビットを取ります。自己署名証明書を受け付けると、ノードは、ノードIDおよび公開鍵が一致していることを確認しなければなりません。これは、ノードIDの盗難を防止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the node has constructed a self-signed certificate, it MAY join the overlay. It MUST store its certificate in the overlay (Section 8), but SHOULD look to see if the user name is already taken and, if so, choose another user name. Note that this provides protection only against accidental name collisions. Name theft is still possible. If protection against name theft is desired, then the enrollment service MUST be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードは、自己署名証明書を作成したら、それはオーバーレイに参加することができます。これは、オーバーレイ（8節）にその証明書を保存しなければなりませんが、ユーザー名がすでに使用されているかどうかを確認して、そうであれば、別のユーザー名を選択することになります。これが唯一の偶然の名前の衝突に対する保護を提供することに注意してください。名前の盗難はまだ可能です。名前の盗難に対する保護を希望する場合には、登録サービスを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. Contacting a Bootstrap Node
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. ブートストラップノードへの問い合わせ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to join the overlay, the Joining Node MUST contact a node in the overlay. Typically this means contacting the bootstrap nodes, since they are reachable by the local peer or have public IP addresses. If the Joining Node has cached a list of peers that it has previously been connected with in this overlay, as an optimization it MAY attempt to use one or more of them as bootstrap nodes before falling back to the bootstrap nodes listed in the configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバレイに参加するために、参加するノードは、オーバーレイ内のノードに連絡しなければなりません。彼らはローカルピアによって到達可能であるか、パブリックIPアドレスを持っているので、通常、これは、ブートストラップ・ノードを接触させることを意味します。参加ノードは、それ以前にこのオーバーレイにして接続されたことをピアのリストをキャッシュしている場合は、最適化としてはバックコンフィギュレーションファイルにリストされたブートストラップ・ノードに落ちる前に、ブートストラップ・ノードとしてそれらの一つ以上を使用しようとするかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When contacting a bootstrap node, the Joining Node MUST first form the DTLS or TLS connection to the bootstrap node and then send an Attach request over this connection with the destination Resource-ID set to the Joining Node&#39;s Node-ID plus 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブートストラップ・ノードに接触するとき、参加するノードは、最初のブートストラップノードにDTLSまたはTLS接続を形成した後、先リソース-IDを使用してこの接続を介してアタッチ要求を送信しなければならない参加するノードのノードIDプラス1に設定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the requester node finally does receive a response from some responding node, it MUST use the Node-ID in the response to start sending requests to join the Overlay Instance as described in Section 6.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要求ノードが最終的にいくつかの応答ノードからの応答を受信した場合、それは、6.4節で説明したようにオーバーレイインスタンスに参加するリクエストの送信を開始するために応答してノードIDを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a node has successfully joined the overlay network, it will have direct connections to several peers. Some MAY be added to the cached bootstrap nodes list and used in future boots. Peers that are not directly connected MUST NOT be cached. The suggested number of peers to cache is 10. Algorithms for determining which peers to cache are beyond the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードが正常にオーバーレイネットワークに参加した後、それはいくつかのピアへの直接接続を持っています。いくつかは、キャッシュされたブートストラップ・ノードのリストに追加され、将来のブーツに使用されるかもしれません。直接接続されていないピアは、キャッシュされてはなりません。キャッシュへのピアの提案数は、本明細書の範囲を超えてキャッシュするためにどのピアを決定するための10のアルゴリズムです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Message Flow Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.メッセージフロー例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following abbreviations are used in the message flow diagrams: JN = Joining Node, AP = Admitting Peer, NP = next peer after the AP, NNP = next next peer which is the peer after NP, PP = previous peer before the AP, PPP = previous previous peer which is the peer before the PP, BP = bootstrap node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の略語は、メッセージフロー図で使用されている：JN =ノードの参加、APはAP前NP、PP =前ピア後ピアであるAP、NNP =次の次のピア後ピア、NP =次のピアを認める= PPPは= PP、BP =ブートストラップノードの前にピアである前前ピア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example, we assume that JN has formed a connection to one of the bootstrap nodes. JN then sends an Attach through that peer to a Resource-ID of itself plus 1 (JN+1). It gets routed to the AP, because JN is not yet part of the overlay. When AP responds, JN and the AP use ICE to set up a connection and then set up DTLS. Once AP has connected to JN, AP sends to JN an Update to populate its Routing Table. The following example shows the Update happening after the DTLS connection is formed, but it could also happen before, in which case the Update would often be routed through other nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例では、JNは、ブートストラップノードの一つへの接続を形成していると仮定する。 JNは、次いで、それ自体のリソース-IDプラス1（JN + 1）へのピアを介して接続し送信します。 JNはまだオーバーレイの一部ではないので、それは、APにルーティングされます。 APが応答すると、JNとAPは、接続を設定するためにICEを使用して、DTLSを設定します。 APはJNに接続したら、APは、そのルーティングテーブルを移入するアップデートをJNに送ります。次の例では、DTLS接続が形成された後の更新が起こって示しているが、また、アップデートは、多くの場合、他のノードを経由してルーティングされるであろう場合には、前に発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachReq Dest=JN+1|         |         |         |         |
        |----------------------------------------------------------&gt;|
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachReq Dest=JN+1|         |
        |         |         |         |&lt;----------------------------|
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachAns          |         |
        |         |         |         |----------------------------&gt;|
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachAns          |         |         |         |         |
        |&lt;----------------------------------------------------------|
        |         |         |         |         |         |         |
        |ICE      |         |         |         |         |         |
        |&lt;===========================&gt;|         |         |         |
        |         |         |         |         |         |         |
        |TLS      |         |         |         |         |         |
        |&lt;...........................&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The JN then forms connections to the appropriate neighbors, such as NP, by sending an Attach which gets routed via other nodes. When NP responds, JN and NP use ICE and DTLS to set up a connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JNは、他のノードを介してルーティングされた添付を送信することによって、このようなNPのような適切な近隣への接続を形成します。 NPが応答すると、JN及びNPは、接続を設定するためにICEとDTLSを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachReq NP       |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachReq NP       |         |
        |         |         |         |--------&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachAns|         |         |
        |         |         |         |&lt;--------|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachAns|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |ICE      |         |         |         |         |         |
        |&lt;=====================================&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |TLS      |         |         |         |         |         |
        |&lt;.....................................&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The JN also needs to populate its Finger Table (for the Chord-based DHT). It issues an Attach to a variety of locations around the overlay. The diagram below shows JN sending an Attach halfway around the Chord ring to the JN + 2^127.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JNは、（コードベースのDHTのために）、そのフィンガーテーブルを移入する必要があります。これは、オーバーレイ各地のさまざまな取り付けを発行します。以下の図は、JN + 2 ^ 127 JNにChordリングの周りに半添付の送信を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       JN        NP        XX        TP
        |         |         |         |
        |         |         |         |
        |         |         |         |
        |AttachReq JN+2&lt;&lt;126|         |
        |--------&gt;|         |         |
        |         |         |         |
        |         |         |         |
        |         |AttachReq JN+2&lt;&lt;126|
        |         |--------&gt;|         |
        |         |         |         |
        |         |         |         |
        |         |         |AttachReq JN+2&lt;&lt;126
        |         |         |--------&gt;|
        |         |         |         |
        |         |         |         |
        |         |         |AttachAns|
        |         |         |&lt;--------|
        |         |         |         |
        |         |         |         |
        |         |AttachAns|         |
        |         |&lt;--------|         |
        |         |         |         |
        |         |         |         |
        |AttachAns|         |         |
        |&lt;--------|         |         |
        |         |         |         |
        |ICE      |         |         |
        |&lt;===========================&gt;|
        |         |         |         |
        |TLS      |         |         |
        |&lt;...........................&gt;|
        |         |         |         |
        |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once JN has a reasonable set of connections, it is ready to take its place in the DHT. It does this by sending a Join to AP. AP sends a series of Store requests to JN to store the data that JN will be responsible for. AP then sends JN an Update that explicitly labels JN as its predecessor. At this point, JN is part of the ring and is responsible for a section of the overlay. AP can now forget any data which is assigned to JN and not to AP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JNは、接続の合理的なセットを持っていたら、DHTでその場所を取る準備ができています。これは、APへの参加を送信することでこれを行います。 APは、JNはを担当するデータを格納するためのJNにストア一連の要求を送信します。 APは、JN明示的にその前身としてJNのラベルの更新を送信します。この時点で、JNはリングの一部であり、オーバーレイのセクションを担当しています。 APは現在、JNにしていないAPに割り当てられているすべてのデータを忘れることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |JoinReq  |         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |JoinAns  |         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreReq Data A    |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreAns |         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreReq Data B    |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreAns |         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Chord, JN&#39;s Neighbor Table needs to contain its own predecessors. It couldn&#39;t connect to them previously, because it did not yet know their addresses. However, now that it has received an Update from AP, as in the previous diagram, it has AP&#39;s predecessors, which are also its own, so it sends Attaches to them. Below, it is shown connecting only to AP&#39;s closest predecessor, PP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コードでは、JNのネイバーテーブルには、独自の前任者を含める必要があります。それはまだ自分のアドレスを知らなかったので、それは、以前にそれらに接続できませんでした。しかし、今では前回の図のように、APから更新を受け取ったこと、それはまた、自身のあるAPの前任者を、持っているので、それらに添付し送信します。以下は、それが唯一のAPの最も近い前身、PPに接続されているように。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachReq Dest=PP  |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |AttachReq Dest=PP  |         |         |
        |         |         |&lt;--------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |AttachAns|         |         |         |
        |         |         |--------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachAns|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |TLS      |         |         |         |         |         |
        |...................|         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |------------------&gt;|         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |&lt;------------------|         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        |--------------------------------------&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |&lt;--------------------------------------|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, now that JN has a copy of all the data and is ready to route messages and receive requests, it sends Updates to everyone in its Routing Table to tell them it is ready to go. Below, it is shown sending such an update to TP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、今JNは、すべてのデータのコピーを持っており、メッセージをルーティング準備ができているとの要求を受け取ること、行く準備ができて、それらを伝えるために、そのルーティングテーブルの全員に更新を送信します。以下は、そのTPに、このような更新を送信して示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           JN        NP        XX        TP
            |         |         |         |
            |         |         |         |
            |         |         |         |
            |UpdateReq|         |         |
            |----------------------------&gt;|
            |         |         |         |
            |         |         |         |
            |UpdateAns|         |         |
            |&lt;----------------------------|
            |         |         |         |
            |         |         |         |
            |         |         |         |
            |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
図6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. 概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD provides a generic storage service, albeit one designed to be useful for P2PSIP. In this section, we discuss security issues that are likely to be relevant to any usage of RELOAD. More background information can be found in [RFC5765].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADはP2PSIPのために有用であるように設計された1つはいえ、一般的なストレージ・サービスを提供しています。このセクションでは、RELOADのいずれかの使用方法に関連する可能性のあるセキュリティ上の問題を議論します。より多くの背景情報は、[RFC5765]に見出すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In any Overlay Instance, any given user depends on a number of peers with which they have no well-defined relationship except that they are fellow members of the Overlay Instance. In practice, these other nodes may be friendly, lazy, curious, or outright malicious. No security system can provide complete protection in an environment where most nodes are malicious. The goal of security in RELOAD is to provide strong security guarantees of some properties even in the face of a large number of malicious nodes and to allow the overlay to function correctly in the face of a modest number of malicious nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれのオーバーレイインスタンスでは、任意のユーザーは、彼らがオーバーレイインスタンスの仲間のメンバーであることを除いてノー明確に定義された関係を持っているとピアの数に依存します。実際には、これらの他のノードは、フレンドリー怠惰な、好奇心、あるいはあからさまな悪意があるかもしれません。いいえ、セキュリティシステムは、ほとんどのノードが悪意のある環境の中で完全な保護を提供することはできません。 RELOADにおけるセキュリティの目標は、さえ悪意のあるノードの多数の顔にいくつかのプロパティの強力なセキュリティ保証を提供し、オーバーレイが悪意のあるノードのささやかな数の顔に正しく機能できるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P2PSIP deployments require the ability to authenticate both peers and resources (users) without the active presence of a trusted entity in the system. We describe two mechanisms. The first mechanism is based on public key certificates and is suitable for general deployments. The second is an admission control mechanism based on an overlay-wide shared symmetric key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P2PSIPの展開は、システム内の信頼できるエンティティの積極的な存在なしのピアとリソース（ユーザー）の両方を認証する機能を必要とします。我々は2つのメカニズムを説明します。第1の機構は、公開鍵証明書に基づいており、一般的な展開に適しています。第二は、オーバーレイ全体の共有対称鍵に基づいたアドミッション制御メカニズムです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. Attacks on P2P Overlays
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2.  P2Pオーバーレイに対する攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two basic functions provided by overlay nodes are storage and routing: some peer is responsible for storing a node&#39;s data and for allowing a third node to fetch this stored data, while other peers are responsible for routing messages to and from the storing nodes. Each of these issues is covered in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバレイノードによって提供される2つの基本機能は、ストレージ及びルーティングである：いくつかのピアがノードのデータを格納するため、および他のピアは、および記憶ノードからのメッセージをルーティングする責任がありながら、第3のノードは、この格納されたデータをフェッチすることを可能にする責任があります。これらの問題のそれぞれは、次のセクションで覆われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P2P overlays are subject to attacks by subversive nodes that may attempt to disrupt routing, corrupt or remove user registrations, or eavesdrop on signaling. The certificate-based security algorithms we describe in this specification are intended to protect overlay routing and user registration information in RELOAD messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P2Pオーバーレイは、ルーティングを破壊破損またはユーザ登録を削除する、またはシグナル伝達を盗聴しようと試みることができる破壊ノードによる攻撃を受けやすいです。私たちはこの仕様で説明した証明書ベースのセキュリティアルゴリズムはRELOADメッセージにオーバーレイルーティングとユーザ登録情報を保護することを意図しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To protect the signaling from attackers pretending to be valid nodes (or nodes other than themselves), the first requirement is to ensure that all messages are received from authorized members of the overlay. For this reason, RELOAD MUST transport all messages over a secure channel (TLS and DTLS are defined in this document) which provides message integrity and authentication of the directly communicating peer. In addition, messages and data MUST be digitally signed with the sender&#39;s private key, providing end-to-end security for communications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有効なノード（または自分以外のノード）のふりをし、攻撃者からのシグナリングを保護するために、最初の要件は、すべてのメッセージがオーバーレイの認可メンバーから受信されることを保証することです。この理由のため、リロードは、メッセージの完全性と直接通信するピアの認証を提供するセキュアチャネル（TLSとDTLSこの文書で定義されている）上のすべてのメッセージを転送しなければなりません。また、メッセージやデータをデジタル通信用のエンドツーエンドのセキュリティを提供し、送信者の秘密鍵で署名されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. Certificate-Based Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. 証明書ベースのセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification stores users&#39; registrations and possibly other data in an overlay network. This requires a solution both to securing this data and to securing, as well as possible, the routing in the overlay. Both types of security are based on requiring that every entity in the system (whether user or peer) authenticate cryptographically using an asymmetric key pair tied to a certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、オーバーレイネットワークにユーザの登録およびおそらく他のデータを格納します。これは、このデータを保護および固定の両方のソリューションを必要とするだけでなく、可能な限り、オーバーレイにルーティング。セキュリティの両方のタイプは、システム内のすべてのエンティティ（ユーザまたはピアかどうか）は暗号証明書に関連付けられて非対称鍵ペアを使用して認証することを要求に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a user enrolls in the Overlay Instance, they request or are assigned a unique name, such as &#34;alice@dht.example.net&#34;. These names MUST be unique and are meant to be chosen and used by humans much like a SIP address-of-record (AOR) or an email address. The user
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーがオーバーレイインスタンスに登録するとき、彼らは要求したり、そのような「alice@dht.example.net」として、ユニークな名前が割り当てられています。これらの名前は一意である必要があり、選ばれたとSIPアドレス・オブ・レコード（AOR）または電子メールアドレスなどの多くの人が使用することを意図しています。ユーザー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MUST also be assigned one or more Node-IDs by the central enrollment authority. Both the name and the Node-IDs are placed in the certificate, along with the user&#39;s public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、中央の登録機関によって一つ以上のNode-IDを割り当てなければなりません。名前とノードIDの両方が利用者の公開鍵と一緒に、証明書に配置されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each certificate enables an entity to act in two sorts of roles:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各証明書は、役割の2種類で行動するエンティティを可能にします：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As a user, storing data at specific Resource-IDs in the Overlay Instance corresponding to the user name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーとしてO、ユーザー名に対応するオーバーレイインスタンスの特定の資源のIDでデータを記憶します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As a overlay peer with the Node-IDs listed in the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書に記載されているノードIDを持つオーバーレイピアとしてO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that since only users of this Overlay Instance need to validate a certificate, this usage does not require a global Public Key Infrastructure (PKI). Instead, certificates MUST be signed by a central enrollment authority which acts as the certificate authority for the Overlay Instance. This authority signs each node&#39;s certificate. Because each node possesses the CA&#39;s certificate (which they receive upon enrollment), they can verify the certificates of the other entities in the overlay without further communication. Because the certificates contain the user&#39;s/node&#39;s public key, communications from the user/node can, in turn, be verified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオーバーレイインスタンスのユーザーのみが証明書を検証する必要があるため、この使用方法は、グローバルな公開鍵基盤（PKI）を必要としないことに注意してください。代わりに、証明書はオーバーレイインスタンスの認証局として機能し、中央登録機関によって署名されなければなりません。この権限は、各ノードの証明書に署名します。各ノードは、（彼らは入学時に受信）CAの証明書を持っているので、彼らはさらに通信せずに、オーバーレイ内の他のエンティティの証明書を検証することができます。証明書は、ユーザーの/ノードの公開鍵が含まれているため、ユーザ/ノードからの通信は、順番に、確認することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If self-signed certificates are used, then the security provided is significantly decreased, since attackers can mount Sybil attacks. In addition, attackers cannot trust the user names in certificates (although they can trust the Node-IDs, because they are cryptographically verifiable). This scheme may be appropriate for some small deployments, such as a small office or an ad hoc overlay set up among participants in a meeting where all hosts on the network are trusted. Some additional security can be provided by using the shared secret admission control scheme as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
自己署名証明書が使用されている場合、攻撃者は、シビル攻撃をマウントすることができるので、その後、提供されるセキュリティは、大幅に減少しています。 （彼らはノードIDを信頼することができますが、彼らは暗号的に検証されているので、）また、攻撃者は、証明書でユーザー名を信頼することはできません。この方式では、このような小規模オフィスやネットワーク上のすべてのホストが信頼されている会議の参加者の間で設定するアドホックオーバーレイなどの一部の小規模な展開のために適切かもしれません。いくつかの追加のセキュリティだけでなく、共有秘密受付制御方式を使用することにより提供することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because all stored data is signed by the owner of the data, the storing node can verify that the storer is authorized to perform a store at that Resource-ID and also can allow any consumer of the data to verify the provenance and integrity of the data when it retrieves it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての記憶されたデータは、データの所有者によって署名されているため、記憶ノードは、記憶手段がそのリソース-IDで保存の実行を許可されていることを確認することができ、また、データの任意の消費者は、データの出所と整合性を検証できるようにすることができとき、それはそれを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that RELOAD does not itself provide a revocation/status mechanism (although certificates may, of course, include Online Certificate Status Protocol [OCSP] responder information). Thus, certificate lifetimes SHOULD be chosen to balance the compromise window versus the cost of certificate renewal. Because RELOAD is already designed to operate in the face of some fraction of malicious nodes, this form of compromise is not fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（証明書は、当然のことながら、[OCSP]情報のレスポンダオンライン証明書状態プロトコル挙げられるが）をRELOAD自体が失効/ステータスメカニズムを提供しないことに注意してください。このように、証明書の有効期限は、証明書の更新の費用対妥協ウィンドウのバランスをとるように選択する必要があります。 RELOADはすでに悪意のあるノードのいくつかの画分の顔で動作するように設計されているので、妥協のこの形式は致命的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All implementations MUST implement certificate-based security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての実装は、証明書ベースのセキュリティを実装しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. Shared-Secret Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. 共有秘密のセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD also supports a shared secret admission control scheme that relies on a single key that is shared among all members of the overlay. It is appropriate for small groups that wish to form a private network without complexity. In shared secret mode, all the peers MUST share a single symmetric key which is used to key TLS-PSK or TLS-SRP mode. A peer which does not know the key cannot form TLS connections with any other peer and therefore cannot join the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADもオーバーレイのすべてのメンバー間で共有される単一のキーに依存している共有秘密受付制御方式をサポートしています。これは、複雑させずにプライベートネットワークを形成したい小グループに適しています。共有シークレットモードでは、すべてのピアは、鍵TLS-PSKまたはTLS-SRPモードに使用される単一の対称鍵を共有しなければなりません。鍵を知らないピアは他のピアとのTLS接続を形成することができないため、オーバーレイに参加することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One natural approach to a shared-secret scheme is to use a user-entered password as the key. The difficulty with this is that in TLS-PSK mode, such keys are very susceptible to dictionary attacks. If passwords are used as the source of shared keys, then TLS-SRP is a superior choice, because it is not subject to dictionary attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共有秘密スキームに対する一つの自然なアプローチをキーとして、ユーザが入力したパスワードを使用することです。これの難しさは、TLS-PSKモードでは、このようなキーは辞書攻撃に非常に敏感であるということです。パスワードが共有鍵のソースとして使用している場合、それは辞書攻撃の対象ではないので、その後、TLS-SRPは、優れた選択肢です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5. Storage Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5. ストレージセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When certificate-based security is used in RELOAD, any given Resource-ID/Kind-ID pair is bound to some small set of certificates. In order to write data, the writer must prove possession of the private key for one of those certificates. Moreover, all data is stored, signed with the same private key that was used to authorize the storage. This set of rules makes questions of authorization and data integrity, which have historically been thorny for overlays, relatively simple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書ベースのセキュリティがRELOADに使用されている場合は、任意のリソース-ID /種類-IDのペアは、証明書のいくつかの小さなセットにバインドされています。データを書き込むために、ライターは、それらの証明書のいずれかの秘密鍵の所有を証明しなければなりません。また、すべてのデータが、記憶された記憶装置を認証するために使用された同じプライベートキーで署名されています。ルールのこのセットは、歴史的にオーバーレイのために厄介なされている認証とデータの整合性の問題は、比較的簡単になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.1. Authorization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.1. 認定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a node wants to store some value, it MUST first digitally sign the value with its own private key. It then sends a Store request that contains both the value and the signature towards the storing peer (which is defined by the Resource Name construction algorithm for that particular Kind of value).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードは、いくつかの値を格納したい場合は、最初にデジタル自身の秘密鍵で値を署名する必要があります。次に、（値の特定の種類のリソース名構築アルゴリズムによって定義される）を記憶するピアに向かっ値と署名の両方を含む記憶要求を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the storing peer receives the request, it MUST determine whether the storing node is authorized to store at this Resource-ID/Kind-ID pair. Determining this requires comparing the user&#39;s identity to the requirements of the access control model (see Section 7.3). If it satisfies those requirements, the user is authorized to write, pending quota checks, as described in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
格納ピアが要求を受信すると、記憶ノードはこのリソース-ID /種類-IDペアで保存することを許可されているかどうかを決定しなければなりません。これを決定すること（セクション7.3を参照）アクセス制御モデルの要件にユーザーのIDを比較することが必要です。それはこれらの要件を満たす場合、ユーザは、次のセクションで説明したように、クォータチェックペンディング、書き込みを許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, consider a certificate with the following properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、次のプロパティを持つ証明書を検討してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          User name: alice@dht.example.com
          Node-ID:   013456789abcdef
          Serial:    1234
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If Alice wishes to Store a value of the &#34;SIP Location&#34; Kind, the Resource Name will be the SIP AOR &#34;sip:alice@dht.example.com&#34;. The Resource-ID will be determined by hashing the Resource Name. Because SIP Location uses the USER-NODE-MATCH policy, it first verifies that the user name in the certificate hashes to the requested Resource-ID. It then verifies that the Node-ID in the certificate matches the dictionary key being used for the store. If both of these checks succeed, the Store is authorized. Note that because the access control model is different for different Kinds, the exact set of checks will vary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アリスは、「SIP場所」種類の値を格納したい場合は、リソース名は、SIP AOR「：alice@dht.example.com SIP」になります。リソース-IDは、リソース名をハッシュすることによって決定されます。 SIP場所は、USER-NODE-MATCHポリシーを使用しているので、それは最初に要求されたリソース-IDに証明書ハッシュにそのユーザー名を確認します。その後、ノードID証明書ストアに使用されている辞書のキーと一致することを確認します。これらのチェックの両方が成功した場合、ストアが許可されています。アクセス制御モデルは、異なる種類の異なるため、検査の正確なセットが変化することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.2. Distributed Quota
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.2. 分散クォータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Being a peer in an Overlay Instance carries with it the responsibility to store data for a given region of the Overlay Instance. However, allowing nodes to store unlimited amounts of data would create unacceptable burdens on peers and would also enable trivial denial-of-service (DoS) attacks. RELOAD addresses this issue by requiring configurations to define maximum sizes for each Kind of stored data. Attempts to store values exceeding this size MUST be rejected. (If peers are inconsistent about this, then strange artifacts will happen when the zone of responsibility shifts and a different peer becomes responsible for overlarge data.) Because each Resource-ID/Kind-ID pair is bound to a small set of certificates, these size restrictions also create a distributed quota mechanism, with the quotas administered by the central configuration server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイ・インスタンス内のピアであることは、それにオーバーレイインスタンスの所定の領域のデータを格納するための責任を運びます。しかし、許可のノードがピアで許容できない負担を作成し、データの無制限の量を格納するためにも些細なサービス拒否（DoS）攻撃を可能にします。格納されたデータの種類毎に最大サイズを定義するために構成を要求することによって、アドレスにこの問題をリロード。このサイズを超える値を格納するための試みは拒絶しなければなりません。 （ピアはこのことについて矛盾している場合は責任シフトのゾーンと異なるピアがoverlargeデータの責任になった場合、その後、奇妙なアーティファクトが発生します。）各リソース-ID /種類-IDのペアは、証明書の小さなセットにバインドされているため、これらのサイズ制限は、中央構成サーバによって投与クォータと、分散クォータ機構を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Allowing different Kinds of data to have different size restrictions allows new usages the flexibility to define limits that fit their needs without requiring all usages to have expansive limits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なるサイズの制限を持つように異なる種類のデータを許可すると、新たな用法に広大な限界を持っているすべての使用を必要とせずに自分のニーズに合わせて制限を定義するための柔軟性を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.3. Correctness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.3. 正しいこと
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because each stored value is signed, it is trivial for any retrieving node to verify the integrity of the stored value. More care needs to be taken to prevent version rollback attacks. Rollback attacks on storage are prevented by the use of store times and lifetime values in each store. A lifetime represents the latest time at which the data is valid and thus limits (although does not completely prevent) the ability of the storing node to perform a rollback attack on retrievers. In order to prevent a rollback attack at the time of the Store request, it is REQUIRED that storage times be monotonically increasing. Storing peers MUST reject Store requests with storage times smaller than or equal to those that they are currently storing. In addition, a fetching node which receives a data value with a storage time older than the result of the previous fetch knows that a rollback has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各格納された値が署名されているため、任意の検索ノードが格納された値の整合性を検証することは自明です。より多くの注意がバージョンロールバック攻撃を防ぐために取られる必要があります。ストレージ上のロールバック攻撃は、各店舗で店舗時間および寿命値を使用することによって防止されます。寿命は、データが有効であり、従って制限された最新の時間（完全に防止しないが）レトリバーにロールバック攻撃を実行するために記憶ノードの能力を表します。ストア要求時のロールバックの攻撃を防ぐためには、その保存時間が単調に増加することが必要です。保存ピアは、現在保存されているものに格納倍以下としてストア要求を拒絶しなければなりません。また、蓄積時間と前の結果フェッチより古いデータ値を受信フェッチノードは、ロールバックが発生したことを知ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.4. Residual Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.4. 残留攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanisms described here provide a high degree of security, but some attacks remain possible. Most simply, it is possible for storing peers to refuse to store a value (i.e., they reject any request). In addition, a storing peer can deny knowledge of values which it has previously accepted. To some extent, these attacks can be ameliorated by attempting to store to and retrieve from replicas, but a retrieving node does not know whether or not it should try this, as there is a cost to doing so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで説明するメカニズムは、高度のセキュリティを提供しますが、いくつかの攻撃が可能に残ります。最も単純に、それは（つまり、彼らはすべての要求を拒否）値を格納することを拒否するためにピアを格納することも可能です。また、記憶ピアは、それが以前に受け入れられた値の知識を拒否することができます。ある程度、これらの攻撃は、に保管し、レプリカから取得しようとすることによって改善することができますが、検索ノードは、そうすることにコストがあるとして、それは、これを試す必要があるかどうか分かりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificate-based authentication scheme prevents a single peer from being able to forge data owned by other peers. Furthermore, although a subversive peer can refuse to return data resources for which it is responsible, it cannot return forged data, because it cannot provide authentication for such registrations. Therefore, parallel searches for redundant registrations can mitigate most of the effects of a compromised peer. The ultimate reliability of such an overlay is a statistical question based on the replication factor and the percentage of compromised peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書ベースの認証方式は、他のピアが所有するデータを偽造することができることから、単一のピアを防止します。破壊ピアは、それが担当するデータリソースを返すことを拒否することができますが、それは、そのような登録のための認証を提供することができないので、さらに、それは、偽造データを返すことはできません。したがって、冗長登録のための並列検索は損なわピアの効果のほとんどを軽減することができます。そのようなオーバーレイの究極の信頼性は、複製因子と妥協ピアの割合に基づいて統計的な質問です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, when a Kind is multivalued (e.g., an array data model), the storing peer can return only some subset of the values, thus biasing its responses. This can be countered by using single values rather than sets, but that makes coordination between multiple storing agents much more difficult. This is a trade-off that must be made when designing any usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
種類（例えば、配列データ・モデル）多値された場合に加えて、格納ピアは、このようにその応答をバイアス値の一部のみのサブセットを返すことができます。これは、単一の値ではなく、セットを使用することによって対抗することができ、それは、複数の収納エージェント間の調整がはるかに困難になります。これは、任意の使用を設計する際に行わなければならないトレードオフです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6. Routing Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6. ルーティングセキュリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the storage security system guarantees (within limits) the integrity of the stored data, routing security focuses on stopping the attacker from performing a DoS attack that misroutes requests in the overlay. There are a few obvious observations to make about this. First, it is easy to ensure that an attacker is at least a valid node in the Overlay Instance. Second, this is a DoS attack only. Third, if a large percentage of the nodes on the Overlay Instance are controlled by the attacker, it is probably impossible to perfectly secure against this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストレージ・セキュリティ・システムは、（制限内で）格納されたデータの整合性を保証するため、ルーティングのセキュリティは、オーバーレイに要求をmisroutes DoS攻撃を行う攻撃者を停止するに焦点を当てています。これについて作るためにいくつかの明白な観察があります。まず、攻撃者は、少なくともオーバーレイインスタンスで有効なノードであることを保証するのは簡単です。第二に、これが唯一のDoS攻撃です。オーバーレイインスタンス上のノードの大部分は、攻撃者によって制御されている場合には第三に、それはおそらく、このに対して完全に安全なのは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.1. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.1. バックグラウンド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, attacks on DHT routing are mounted by the attacker arranging to route traffic through one or two nodes that it controls. In the Eclipse attack [Eclipse], the attacker tampers with messages to and from nodes for which it is on-path with respect to a given victim node. This allows it to pretend to be all the nodes that are reachable through it. In the Sybil attack [Sybil], the attacker registers a large number of nodes and is therefore able to capture a large amount of the traffic through the DHT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的に、DHTルーティング上の攻撃はそれが制御する一つ又は二つのノードを介してトラフィックをルーティングに配置する攻撃者によって実装されています。 Eclipseの攻撃[エクリプス]において、攻撃者は、所与の犠牲者ノードに対してオンパスされたノードへ及びからのメッセージを改ざん。これは、それを介して到達可能なすべてのノードのふりをすることができます。シビル攻撃[シビル]において、攻撃者は、多数のノードを登録し、従って、DHTを介して大量のトラフィックをキャプチャすることが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both the Eclipse and Sybil attacks require the attacker to be able to exercise control over her Node-IDs. The Sybil attack requires the creation of a large number of peers. The Eclipse attack requires that the attacker be able to impersonate specific peers. In both cases, RELOAD attempts to mitigate these attacks by the use of centralized, certificate-based admission control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらもEclipseとシビル攻撃は彼女のノードIDが支配力を行使することができるように、攻撃者が必要です。シビル攻撃は、多数のピアを作成する必要があります。 Eclipseの攻撃は、攻撃者が特定のピアを偽装できることが必要です。両方の場合において、集中、証明書ベースのアドミッション制御を使用することによってこれらの攻撃を軽減する試みをリロード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.2. Admissions Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.2. 入学コントロール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Admission to a RELOAD Overlay Instance is controlled by requiring that each peer have a certificate containing its Node-ID. The requirement to have a certificate is enforced by using certificate-based mutual authentication on each connection. (Note: the following applies only when self-signed certificates are not used.) Whenever a peer connects to another peer, each side automatically checks that the other has a suitable certificate. These Node-IDs MUST be randomly assigned by the central enrollment server. This has two benefits:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADオーバーレイインスタンスへの入場は、それぞれ、そのノードIDを含む証明書を持っているピアことを要求することによって制御されます。証明書を持っている必要は各接続に証明書ベースの相互認証を使用して実施されます。 （注：以下に、自己署名証明書が使用されていない場合にのみ適用される）ピアが別のピアに接続するたびに、それぞれの側は、自動的に他の適切な証明書を持っていることをチェックします。これらのノードIDは、ランダムに中央登録サーバによって割り当てられなければなりません。これには2つの利点があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It allows the enrollment server to limit the number of Node-IDs issued to any individual user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oこれは、登録サーバは個々のユーザーに対して発行されたノードIDの数を制限することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It prevents the attacker from choosing specific Node-IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは、特定のノードのIDを選択するから、攻撃者を防ぐことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first property allows protection against Sybil attacks (provided that the enrollment server uses strict rate-limiting policies). The second property deters but does not completely prevent Eclipse attacks. Because an Eclipse attacker must impersonate peers on the other side of the attacker, the attacker must have a certificate for suitable Node-IDs, which requires him to repeatedly query the enrollment server for new certificates, which will match only by chance. From the attacker&#39;s perspective, the difficulty is that if the attacker has only a small number of certificates, the region of the Overlay Instance he is impersonating appears to be very sparsely populated by comparison to the victim&#39;s local region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初のプロパティは、（登録サーバは、厳密なレート制限ポリシーを使用している場合）シビル攻撃に対する保護を可能にします。第二の特性を抑止するが、完全にEclipseの攻撃を防ぐことはできません。 Eclipseの攻撃者は、攻撃者の反対側のピアを偽装する必要があるため、攻撃者は何度だけ偶然一致する新しい証明書、入学のためのサーバーを照会するために彼を必要とする適切なノードIDの証明書を持っている必要があります。攻撃者は、証明書のほんの数を持っている場合、攻撃者の視点から、難しさは、彼が偽装されたオーバーレイインスタンスの領域は非常にまばらに被害者の地元地域との比較によって移植されるように見えるということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.3. Peer Identification and Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.3. 識別と認証ピア
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, whenever a peer engages in overlay activity that might affect the Routing Table, it must establish its identity. This happens in two ways. First, whenever a peer establishes a direct connection to another peer, it authenticates via certificate-based mutual authentication. All messages between peers are sent over this protected channel, and therefore the peers can verify the data origin of the last-hop peer for requests and responses without further cryptography.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的には、ピアはルーティングテーブルに影響を与える可能性があることオーバーレイ活動に従事したときに、それはそのアイデンティティを確立する必要があります。これは、2つの方法で行われます。ピアが別のピアへの直接接続を確立するたびに、まず、それが証明書ベースの相互認証を介して認証します。ピア間のすべてのメッセージは、この保護されたチャネルを介して送信されますので、ピアはさらに、暗号化せずに、要求と応答のための最後のホップピアのデータ発信元を確認することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some situations, however, it is desirable to be able to establish the identity of a peer with whom one is not directly connected. The most natural case is when a peer Updates its state. At this point, other peers may need to update their view of the overlay structure, but they need to verify that the Update message came from the actual peer rather than from an attacker. To prevent having a peer accept Update messages from an attacker, all overlay routing messages are signed by the peer that generated them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの状況では、しかし、1が直接接続されていない人とピアのアイデンティティを確立することができることが望ましいです。ピアがその状態を更新したときに最も自然なケースがあります。この時点で、他のピアは、オーバーレイ構造のビューを更新する必要があるかもしれないが、彼らは、Updateメッセージは、実際のピアからではなく、攻撃者から来ていることを確認する必要があります。ピアが攻撃者からの更新メッセージを受け入れる有する防ぐために、すべてのオーバーレイルーティングメッセージは、それらを生成したピアによって署名されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For messages that impact the topology of the overlay, replay is typically prevented by having the information come directly from, or be verified by, the nodes that claimed to have generated the update. Data storage replay detection is done by signing the time of the node that generated the signature on the Store request, thus providing a time-based replay protection, but the time synchronization is needed only between peers that can write to the same location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイのトポロジーに影響を与えるメッセージの場合、再生は、典型的には、情報を持っていることによって阻止されるから直接、または更新が発生したと主張ノードによって検証されます。データ・ストレージ・リプレイ検出は、このように時間ベースのリプレイ保護を提供し、ストア要求の署名を生成したノードの時間に署名することによって行われるが、時間同期は、同じ場所に書き込むことができるピア間で必要とされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.4. Protecting the Signaling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.4. シグナリングの保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal here is to stop an attacker from knowing who is signaling what to whom. An attacker is unlikely to be able to observe the activities of a specific individual, given the randomization of IDs and routing based on the present peers discussed above. Furthermore, because messages can be routed using only the header information, the actual body of the RELOAD message can be encrypted during transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでの目標は、どのような誰にシグナリングをしている人を知ってからの攻撃を停止することです。攻撃者は、上述した本ピアに基づいて、IDおよびルーティングのランダム化を考慮すると、特定の個人の活動を観察することはできそうにありません。メッセージは、ヘッダ情報のみを使用してルーティングすることができるのでさらに、リロードメッセージの実際のボディは、送信時に暗号化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two lines of defense here. The first is the use of TLS or DTLS for each communications link between peers. This provides protection against attackers who are not members of the overlay. The second line of defense is to digitally sign each message. This prevents adversarial peers from modifying messages in flight, even if they are on the routing path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここでは、防衛の2行があります。最初は、ピア間の各通信リンクのためのTLSまたはDTLSを使用することです。これは、オーバーレイのメンバーではない攻撃者に対する保護を提供します。防衛の2行目は、デジタル各メッセージに署名することです。これは、彼らがルーティングパス上にある場合でも、飛行中のメッセージを修正するから敵対ピアを防ぐことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.5. Routing Loops and DoS Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.5. ルーティングループやDoS攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source-routing mechanisms are known to create the possibility for DoS amplification, especially by the induction of routing loops [RFC5095]. In order to limit amplification, the initial-ttl value in the configuration file SHOULD be set to a value slightly larger than the longest expected path through the network. For Chord, experience has shown that log(2) of the number of nodes in the network + 5 is a safe bound. Because nodes are required to enforce the initial-ttl as the maximum value, an attacker cannot achieve an amplification factor greater than initial-ttl, thus limiting the additional capabilities provided by source routing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソースルーティングメカニズムは、特にルーティングループ[RFC5095]の誘導により、DoSの増幅のための可能性を作成することが知られています。増幅を制限するために、構成ファイル内の初期TTL値は、ネットワークを介して最長の予想経路よりも僅かに大きい値に設定する必要があります。コードのために、経験は、ネットワーク+ 5内のノードの数のログ（2）安全で結合している示されています。ノードは最大値として初期TTLを適用する必要があるため、攻撃者は、このようにソースルーティングによって提供される追加機能を制限する、初期TTLよりも大きい増幅率を達成することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to prevent the use of loops for targeted implementation attacks, implementations SHOULD check the Destination List for duplicate entries and discard such records with an &#34;Error_Invalid_Message&#34; error. This does not completely prevent loops, but it does require that at least one attacker node be part of the loop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目標実現の攻撃のためのループの使用を防ぐために、実装は、重複したエントリの宛先リストを確認する必要がありますし、「Error_Invalid_Message」エラーで、このようなレコードを破棄します。これは、完全にループを妨げないが、それは、少なくとも一つの攻撃ノードがループの一部であることを必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.6. Residual Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.6. 残留攻撃
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The routing security mechanisms in RELOAD are designed to contain rather than eliminate attacks on routing. It is still possible for an attacker to mount a variety of attacks. In particular, if an attacker is able to take up a position on the overlay routing between A and B, it can make it appear as if B does not exist or is disconnected. It can also advertise false network metrics in an attempt to reroute traffic. However, these are primarily DoS attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD内のルーティングセキュリティメカニズムが含まれているのではなく、ルーティングへの攻撃を排除するために設計されています。攻撃者は、攻撃の様々なマウントすることは可能です。具体的には、攻撃者はAとBとの間のルーティングオーバレイ上の位置を取ることができる場合、それはBが存在しないか、切断されたかのように見せることができます。また、トラフィックを再ルーティングするための試みで、偽のネットワークメトリックをアドバタイズできます。しかし、これらは主にDoS攻撃です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificate-based security scheme secures the namespace, but if an individual peer is compromised or if an attacker obtains a certificate from the CA, then a number of subversive peers can still appear in the overlay. While these peers cannot falsify responses to resource queries, they can respond with error messages, effecting a DoS attack on the resource registration. They can also subvert routing to other compromised peers. To defend against such attacks, a resource search must still consist of parallel searches for replicated registrations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書ベースのセキュリティスキームは、名前空間を確保しますが、個々のピアが侵害された場合や、攻撃者がCAから証明書を取得した場合、その後、破壊ピアの数はまだオーバーレイで表示されます。これらのピアがクエリをリソースへの回答を改ざんすることはできませんが、彼らは、リソース登録にDoS攻撃を行うと、エラーメッセージで応答することができます。彼らはまた、他の妥協のピアへのルーティング覆すことができます。このような攻撃を防御するには、リソース検索は、まだ複製され、登録のための並列検索で構成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains the new code points registered by this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、この文書が登録した新しいコードポイントが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. Well-Known URI Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. よく知られているURIの登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has registered a &#34;well-known URI&#34; as described in [RFC5785]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5785]に記載されているようにIANA「は、周知のURI」を登録しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           +----------------------------+----------------------+
           | URI suffix:                | reload-config        |
           | Change controller:         | IETF &lt;iesg@ietf.org&gt; |
           | Specification document(s): | RFC 6940             |
           | Related information:       | None                 |
           +----------------------------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. Port Registrations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. ポートの登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has already allocated a TCP port for the main peer-to-peer protocol. This port had the name p2psip-enroll and the port number of 6084. Per this document, IANA has updated this registration to change the service name to reload-config.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは既にメインピア・ツー・ピア・プロトコルのTCPポートを割り当てました。このポートは、名前のP2PSIP-登録し、この文書毎6084.のポート番号を持っていた、IANAは-config設定を再ロードするためにサービス名を変更するには、この登録を更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has made the following port registration:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、次のポートの登録を行いました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------------------------+-------------------------------------+
   | Registration Technical      | IETF Chair &lt;chair@ietf.org&gt;         |
   | Contact                     |                                     |
   | Registration Owner          | IETF &lt;iesg@ietf.org&gt;                |
   | Transport Protocol          | TCP                                 |
   | Port Number                 | 6084                                |
   | Service Name                | reload-config                       |
   | Description                 | Peer-to-Peer Infrastructure         |
   |                             | Configuration                       |
   +-----------------------------+-------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. Overlay Algorithm Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. オーバーレイのアルゴリズムタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Overlay Algorithm Types&#34; Registry. Entries in this registry are strings denoting the names of overlay algorithms, as described in Section 11.1 of [RFC6940]. The registration policy for this registry is &#34;IETF Review&#34; [RFC522]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOADオーバーレイアルゴリズムの種類」レジストリを作成しました。 [RFC6940]のセクション11.1で説明したように、このレジストリのエントリは、オーバーレイアルゴリズムの名前を表す文字列です。このレジストリの登録ポリシーは、「IETFレビュー」[RFC522]です。このレジストリの初期の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      +----------------+-----------+
                      | Algorithm Name | Reference |
                      +----------------+-----------+
                      | CHORD-RELOAD   |  RFC 6940 |
                      | EXP-OVERLAY    |  RFC 6940 |
                      +----------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value EXP-OVERLAY has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値EXP-OVERLAYは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4. Access Control Policies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4. アクセス制御ポリシー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Access Control Policies&#34; Registry. Entries in this registry are strings denoting access control policies, as described in Section 7.3 of [RFC6940]. New entries in this registry SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOADアクセス制御ポリシー」レジストリを作成しました。 [RFC6940]のセクション7.3で説明したように、このレジストリのエントリは、アクセス制御ポリシーを表す文字列です。このレジストリ内の新しいエントリは、標準アクション[RFC5226]を経由して登録するものとします。このレジストリの初期の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      +-----------------+-----------+
                      | Access Policy   | Reference |
                      +-----------------+-----------+
                      | USER-MATCH      |  RFC 6940 |
                      | NODE-MATCH      |  RFC 6940 |
                      | USER-NODE-MATCH |  RFC 6940 |
                      | NODE-MULTIPLE   |  RFC 6940 |
                      | EXP-MATCH       |  RFC 6940 |
                      +-----------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value EXP-MATCH has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値EXP-MATCHは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5. Application-ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5. アプリケーションID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Application-ID&#34; Registry. Entries in this registry are 16-bit integers denoting Application-IDs, as described in Section 6.5.2 of [RFC6940]. Code points in the range 1 to 32767 SHALL be registered via Standards Action [RFC5226]. Code points in the range 32768 to 61440 SHALL be registered via Expert Review [RFC5226]. Code points in the range 61441 to 65534 are reserved for private use. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOADアプリケーションID」レジストリを作成しました。 [RFC6940]のセクション6.5.2に記載したように、このレジストリのエントリは、アプリケーションIDを表す16ビットの整数です。 32767の範囲1のコードポイントは標準アクション[RFC5226]を介して、登記しなければなりません。 61440の範囲32768のコードポイントがエキスパートレビュー[RFC5226]を介して、登記しなければなりません。範囲内のコードポイント61441〜65534は、私的使用のために予約されています。このレジストリの初期の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +-------------+----------------+-------------------------------+
     | Application | Application-ID |                 Specification |
     +-------------+----------------+-------------------------------+
     | INVALID     |              0 |                      RFC 6940 |
     | SIP         |           5060 | Reserved for use by SIP Usage |
     | SIP         |           5061 | Reserved for use by SIP Usage |
     | Reserved    |          65535 |                      RFC 6940 |
     +-------------+----------------+-------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.6. Data Kind-ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.6. データ種類-ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Data Kind-ID&#34; registry. Entries in this registry are 32-bit integers denoting data Kinds, as described in Section 5.2 of [RFC6940]. Code points in the range 0x00000001 to 0x7FFFFFFF SHALL be registered via Standards Action [RFC5226]. Code points in the range 0x8000000 to 0xF0000000 SHALL be registered via Expert Review [RFC5226]. Code points in the range 0xF0000001 to 0xFFFFFFFE are reserved for private use via the Kind description mechanism described in Section 11 of [RFC6940]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOADデータ種類-ID」のレジストリを作成しました。 [RFC6940]のセクション5.2に記載したように、このレジストリ内のエントリは、データの種類を示す32ビット整数です。 0x7FFFFFFFでの範囲は0x00000001のコードポイントが標準アクション[RFC5226]を介して、登記しなければなりません。 0xf0000000の範囲0x8000000のコードポイントはエキスパートレビュー[RFC5226]を介して、登記しなければなりません。 0xFFFFFFFEの範囲0xF0000001のコードポイントは、[RFC6940]のセクション11に記載された種類の説明機構を介して私的使用のために予約されています。このレジストリの初期の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +---------------------+------------+-----------+
             | Kind                |    Kind-ID | Reference |
             +---------------------+------------+-----------+
             | INVALID             |        0x0 |  RFC 6940 |
             | TURN-SERVICE        |        0x2 |  RFC 6940 |
             | CERTIFICATE_BY_NODE |        0x3 |  RFC 6940 |
             | CERTIFICATE_BY_USER |       0x10 |  RFC 6940 |
             | Reserved            | 0x7fffffff |  RFC 6940 |
             | Reserved            | 0xfffffffe |  RFC 6940 |
             +---------------------+------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.7. Data Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.7. データ・モデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Data Model&#34; registry. Entries in this registry are strings denoting data models, as described in Section 7.2 of [RFC6940]. New entries in this registry SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOADデータモデル」のレジストリを作成しました。 [RFC6940]のセクション7.2に記載したように、このレジストリ内のエントリは、データ・モデルを表す文字列です。このレジストリ内の新しいエントリは、標準アクション[RFC5226]を経由して登録するものとします。このレジストリの初期の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        +------------+-----------+
                        | Data Model | Reference |
                        +------------+-----------+
                        | INVALID    |  RFC 6940 |
                        | SINGLE     |  RFC 6940 |
                        | ARRAY      |  RFC 6940 |
                        | DICTIONARY |  RFC 6940 |
                        | EXP-DATA   |  RFC 6940 |
                        | RESERVED   |  RFC 6940 |
                        +------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value EXP-DATA has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値EXP-DATAは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.8. Message Codes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.8. メッセージコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Message Codes&#34; registry. Entries in this registry are 16-bit integers denoting method codes, as described in Section 6.3.3 of [RFC6940]. These codes SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOADメッセージ・コード」のレジストリを作成しました。 [RFC6940]のセクション6.3.3に記載したように、このレジストリのエントリは、メソッドコードを表す16ビットの整数です。これらのコードは、標準アクション[RFC5226]を経由して登録するものとします。このレジストリの初期の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------------------+----------------+-----------+
   | Message Code Name                   |     Code Value | Reference |
   +-------------------------------------+----------------+-----------+
   | invalidMessageCode                  |            0x0 |  RFC 6940 |
   | probe_req                           |            0x1 |  RFC 6940 |
   | probe_ans                           |            0x2 |  RFC 6940 |
   | attach_req                          |            0x3 |  RFC 6940 |
   | attach_ans                          |            0x4 |  RFC 6940 |
   | Unassigned                          |            0x5 |           |
   | Unassigned                          |            0x6 |           |
   | store_req                           |            0x7 |  RFC 6940 |
   | store_ans                           |            0x8 |  RFC 6940 |
   | fetch_req                           |            0x9 |  RFC 6940 |
   | fetch_ans                           |            0xA |  RFC 6940 |
   | Unassigned (was remove_req)         |            0xB |  RFC 6940 |
   | Unassigned (was remove_ans)         |            0xC |  RFC 6940 |
   | find_req                            |            0xD |  RFC 6940 |
   | find_ans                            |            0xE |  RFC 6940 |
   | join_req                            |            0xF |  RFC 6940 |
   | join_ans                            |           0x10 |  RFC 6940 |
   | leave_req                           |           0x11 |  RFC 6940 |
   | leave_ans                           |           0x12 |  RFC 6940 |
   | update_req                          |           0x13 |  RFC 6940 |
   | update_ans                          |           0x14 |  RFC 6940 |
   | route_query_req                     |           0x15 |  RFC 6940 |
   | route_query_ans                     |           0x16 |  RFC 6940 |
   | ping_req                            |           0x17 |  RFC 6940 |
   | ping_ans                            |           0x18 |  RFC 6940 |
   | stat_req                            |           0x19 |  RFC 6940 |
   | stat_ans                            |           0x1A |  RFC 6940 |
   | Unassigned (was attachlite_req)     |           0x1B |  RFC 6940 |
   | Unassigned (was attachlite_ans)     |           0x1C |  RFC 6940 |
   | app_attach_req                      |           0x1D |  RFC 6940 |
   | app_attach_ans                      |           0x1E |  RFC 6940 |
   | Unassigned (was app_attachlite_req) |           0x1F |  RFC 6940 |
   | Unassigned (was app_attachlite_ans) |           0x20 |  RFC 6940 |
   | config_update_req                   |           0x21 |  RFC 6940 |
   | config_update_ans                   |           0x22 |  RFC 6940 |
   | exp_a_req                           |           0x23 |  RFC 6940 |
   | exp_a_ans                           |           0x24 |  RFC 6940 |
   | exp_b_req                           |           0x25 |  RFC 6940 |
   | exp_b_ans                           |           0x26 |  RFC 6940 |
   | Reserved                            | 0x8000..0xFFFE |  RFC 6940 |
   | error                               |         0xFFFF |  RFC 6940 |
   +-------------------------------------+----------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values exp_a_req, exp_a_ans, exp_b_req, and exp_b_ans have been made available for the purposes of experimentation. These values are not meant for vendor-specific use of any sort, and they MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値exp_a_req、exp_a_ans、exp_b_req、およびexp_b_ansは、実験の目的のために利用可能になっています。これらの値は、あらゆる種類のベンダー固有の使用のために意図されていない、と彼らは業務展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9. Error Codes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9. エラーコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Error Code&#34; registry. Entries in this registry are 16-bit integers denoting error codes, as described in Section 6.3.3.1 of [RFC6940]. New entries SHALL be defined via Standards Action [RFC5226]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOADエラーコード」レジストリを作成しました。 [RFC6940]のセクション6.3.3.1に記載されているように、このレジストリのエントリは、エラーコードを表す16ビットの整数です。新しいエントリは標準アクション[RFC5226]で定義されるものとする（SHALL）。このレジストリの初期の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------------------------------+----------------+-----------+
   | Error Code Name                     |     Code Value | Reference |
   +-------------------------------------+----------------+-----------+
   | invalidErrorCode                    |            0x0 |  RFC 6940 |
   | Unassigned                          |            0x1 |           |
   | Error_Forbidden                     |            0x2 |  RFC 6940 |
   | Error_Not_Found                     |            0x3 |  RFC 6940 |
   | Error_Request_Timeout               |            0x4 |  RFC 6940 |
   | Error_Generation_Counter_Too_Low    |            0x5 |  RFC 6940 |
   | Error_Incompatible_with_Overlay     |            0x6 |  RFC 6940 |
   | Error_Unsupported_Forwarding_Option |            0x7 |  RFC 6940 |
   | Error_Data_Too_Large                |            0x8 |  RFC 6940 |
   | Error_Data_Too_Old                  |            0x9 |  RFC 6940 |
   | Error_TTL_Exceeded                  |            0xA |  RFC 6940 |
   | Error_Message_Too_Large             |            0xB |  RFC 6940 |
   | Error_Unknown_Kind                  |            0xC |  RFC 6940 |
   | Error_Unknown_Extension             |            0xD |  RFC 6940 |
   | Error_Response_Too_Large            |            0xE |  RFC 6940 |
   | Error_Config_Too_Old                |            0xF |  RFC 6940 |
   | Error_Config_Too_New                |           0x10 |  RFC 6940 |
   | Error_In_Progress                   |           0x11 |  RFC 6940 |
   | Error_Exp_A                         |           0x12 |  RFC 6940 |
   | Error_Exp_B                         |           0x13 |  RFC 6940 |
   | Error_Invalid_Message               |           0x14 |  RFC 6940 |
   | Reserved                            | 0x8000..0xFFFE |  RFC 6940 |
   +-------------------------------------+----------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values Error_Exp_A and Error_Exp_B have been made available for the purposes of experimentation. These values are not meant for vendor-specific use of any sort, and they MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値Error_Exp_AとError_Exp_Bは、実験の目的のために利用可能になっています。これらの値は、あらゆる種類のベンダー固有の使用のために意図されていない、と彼らは業務展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.10. Overlay Link Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.10. オーバーレイリンク・タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Overlay Link Registry&#34;. Entries in this registry are 8-bit integers, as described in Section 6.5.1.1 of [RFC6940]. For more information on the link types defined here, see Section 6.6 of [RFC6940]. New entries SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOADオーバーレイリンクレジストリ」を作成しました。 [RFC6940]のセクション6.5.1.1に記載されているように、このレジストリのエントリは、8ビットの整数です。ここで定義されたリンクの種類の詳細については、[RFC6940]のセクション6.6を参照してください。新しいエントリは標準アクション[RFC5226]で定義されるものとする（SHALL）。このレジストリは、最初は以下の値が移入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                 +--------------------+------+-----------+
                 | Protocol           | Code | Reference |
                 +--------------------+------+-----------+
                 | INVALID-PROTOCOL   |    0 |  RFC 6940 |
                 | DTLS-UDP-SR        |    1 |  RFC 6940 |
                 | DTLS-UDP-SR-NO-ICE |    3 |  RFC 6940 |
                 | TLS-TCP-FH-NO-ICE  |    4 |  RFC 6940 |
                 | EXP-LINK           |    5 |  RFC 6940 |
                 | Reserved           |  255 |  RFC 6940 |
                 +--------------------+------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value EXP-LINK has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値EXP-LINKは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.11. Overlay Link Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.11. オーバーレイリンクプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Overlay Link Protocol Registry&#34;. Entries in this registry are strings denoting protocols as described in Section 11.1 of this document and SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOADオーバーレイリンクプロトコルレジストリ」を作成しました。このレジストリのエントリはこのドキュメントのセクション11.1に記載されており、標準アクション[RFC5226]で定義されるものとする（SHALL）などのプロトコルを示す文字列です。このレジストリは、最初は以下の値が移入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       +---------------+-----------+
                       | Link Protocol | Reference |
                       +---------------+-----------+
                       | TLS           |  RFC 6940 |
                       | EXP-PROTOCOL  |  RFC 6940 |
                       +---------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value EXP-PROTOCOL has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値EXP-PROTOCOLは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.12. Forwarding Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.12. 転送オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Forwarding Option Registry&#34;. Entries in this registry are 8-bit integers denoting options, as described in Section 6.3.2.3 of [RFC6940]. Values between 1 and 127 SHALL be defined via Standards Action [RFC5226]. Entries in this registry between 128 and 254 SHALL be defined via Specification Required [RFC5226]. This registry has been initially populated with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOAD転送オプションレジストリ」を作成しました。 [RFC6940]のセクション6.3.2.3に記載されているように、このレジストリのエントリは、オプションを表す8ビットの整数です。 1と127の間の値は、標準アクション[RFC5226]を介して定義されなければなりません。 128と254の間のこのレジストリのエントリは、仕様が必要[RFC5226]を介して定義されなければなりません。このレジストリは、最初は以下の値が移入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +-------------------------+------+-----------+
              | Forwarding Option       | Code | Reference |
              +-------------------------+------+-----------+
              | invalidForwardingOption |    0 |  RFC 6940 |
              | exp-forward             |    1 |  RFC 6940 |
              | Reserved                |  255 |  RFC 6940 |
              +-------------------------+------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value exp-forward has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値EXPフォワードは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.13. Probe Information Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.13. プローブ情報の種類
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Probe Information Type Registry&#34;. Entries are 8-bit integers denoting types as described in Section 6.4.2.5.1 of [RFC6940] and SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOADプローブ情報タイプレジストリ」を作成しました。エントリは、[RFC6940]のセクション6.4.2.5.1に記載されており、標準アクション[RFC5226]で定義されるとおりでなければならないタイプを示す8ビットの整数です。このレジストリは、最初は以下の値が移入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                 +--------------------+------+-----------+
                 | Probe Option       | Code | Reference |
                 +--------------------+------+-----------+
                 | invalidProbeOption |    0 |  RFC 6940 |
                 | responsible_set    |    1 |  RFC 6940 |
                 | num_resources      |    2 |  RFC 6940 |
                 | uptime             |    3 |  RFC 6940 |
                 | exp-probe          |    4 |  RFC 6940 |
                 | Reserved           |  255 |  RFC 6940 |
                 +--------------------+------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value exp-probe has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値EXP-プローブは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.14. Message Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.14. メッセージ拡張機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Extensions Registry&#34;. Entries in this registry are 8-bit integers denoting extensions as described in Section 6.3.3 of [RFC6940] and SHALL be defined via Specification Required [RFC5226]. This registry has been initially populated with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANAは、「RELOAD拡張レジストリ」を作成しました。このレジストリのエントリは、[RFC6940]のセクション6.3.3に記載した仕様が必要[RFC5226]で定義されるとおりでなければならない拡張機能を示す8ビットの整数です。このレジストリは、最初は以下の値が移入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           +-----------------------------+--------+-----------+
           | Extensions Name             |   Code | Reference |
           +-----------------------------+--------+-----------+
           | invalidMessageExtensionType |    0x0 |  RFC 6940 |
           | exp-ext                     |    0x1 |  RFC 6940 |
           | Reserved                    | 0xFFFF |  RFC 6940 |
           +-----------------------------+--------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value exp-ext has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値EXP-extは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.15. Reload URI Scheme
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.15.  URIスキームをリロード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the scheme for a reload URI, which can be used to refer to either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、いずれかを指すために使用することができるリロードURIのためのスキームを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A peer, e.g., as used in a certificate (see Section 11.3 of [RFC6940]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアO、例えば、証明書で使用される（[RFC6940]のセクション11.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A resource inside a peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピア内部リソースO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reload URI is defined using a subset of the URI schema specified in Appendix A of RFC 3986 [RFC3986] and the associated URI Guidelines [RFC4395] per the following ABNF syntax:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードURIは、以下のABNF構文ごとにRFC 3986 [RFC3986]の付録Aおよび関連するURIガイドライン[RFC4395]で指定されたURIスキーマのサブセットを使用して定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RELOAD-URI = &#34;reload://&#34; destination &#34;@&#34; overlay &#34;/&#34; [specifier] destination = 1*HEXDIG overlay = reg-name specifier = 1*HEXDIG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RELOAD-URI = &#34;リロード：//&#34; 先 &#34;@&#34; オーバーレイ &#34;/&#34; [指定]先= 1 * HEXDIGオーバーレイ= REG-名指定子= 1 * HEXDIG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definitions of these productions are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにこれらの作品の定義は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination A hexadecimal-encoded Destination List object (i.e., multiple concatenated Destination objects with no length prefix prior to the object as a whole).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先進符号化された宛先リストオブジェクト（前全体としてオブジェクトにない長さプレフィックス付き即ち、複数の連結された宛先オブジェクト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay The name of the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オーバーレイの名前をオーバーレイ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
specifier A hexadecimal-encoded StoredDataSpecifier indicating the data element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ要素を表す16進符号化されたStoredDataSpecifierを指定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If no specifier is present, this URI addresses the peer which can be reached via the indicated Destination List at the indicated overlay name. If a specifier is present, the URI addresses the data value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何も指定子が存在しない場合は、このURIが示されたオーバーレイ名で指示された宛先リストを介して到達することができ、ピアに対応しています。指定子が存在する場合、URIは、データ値に対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.15.1. URI Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.15.1.  URIの登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following summarizes the information necessary to register the reload URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、リロードURIを登録するために必要な情報をまとめたもの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI Scheme Name: reload
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URIスキーム名：リロード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status: permanent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ステータス：永久
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI Scheme Syntax: see Section 14.15 of RFC 6940
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URIスキーム構文：RFC 6940のセクション14.15を参照してください
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI Scheme Semantics: The reload URI is intended to be used as a reference to a RELOAD peer or resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URIスキーム意味：リロードURIをリロードピアまたはリソースへの参照として使用されることが意図されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding Considerations: The reload URI is not intended to be human-readable text, so it is encoded entirely in US-ASCII.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコーディングに関する注意事項：それはUS-ASCIIで完全にエンコードされているので、リロードURIは、人間が読めるテキストであることを意図したものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications/protocols that Use this URI Scheme: The RELOAD protocol described in RFC 6940.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このURIスキームを使用するアプリケーション/プロトコル：RFC 6940で説明RELOADプロトコル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interoperability Considerations: See RFC 6940.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相互運用性に関する注意事項：RFC 6940を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security Considerations: See RFC 6940
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティの考慮事項：参照してください。RFC 6940
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Contact: Cullen Jennings &lt;fluffy@cisco.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
連絡先：カレン・ジェニングス&lt;fluffy@cisco.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Author/Change Controller: IESG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者/変更コントローラ：IESG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
References: RFC 6940
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参考文献：RFC 6940
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.16. Media Type Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.16. メディアタイプ登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type Name: application
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプ名：アプリケーション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subtype Name: p2p-overlay+xml
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サブタイプ名：P2Pオーバーレイ+ xmlの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Required Parameters: none
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必要なパラメータ：なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optional Parameters: none
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションパラメータ：なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding Considerations: Must be binary encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
留意事項をコードする：バイナリエンコードする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security Considerations: This media type is typically not used to transport information that needs to be kept confidential. However, there are cases where it is integrity of the information is important. For these cases, using a digital signature is RECOMMENDED. One way of doing this is specified in RFC 6940. In the case when the media includes a shared-secret element, the contents of the file MUST be kept confidential or else anyone who can see the shared secret can affect the RELOAD overlay network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティの考慮：このメディアタイプは、一般的に機密を維持する必要がある情報を輸送するのに使用されていません。しかし、それは情報の整合性が重要である場合があります。このような場合のために、デジタル署名を使用することは推奨されています。これを行う1つの方法は、メディアが共有秘密要素を含む場合にはRFC 6940.に指定され、ファイルの内容が秘密にしなければならないか、または他の共有秘密を見ることができる誰もがRELOADオーバレイネットワークに影響を与えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interoperability Considerations: No known interoperability consideration beyond those identified for application/xml in [RFC3023].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相互運用性に関する注意事項：[RFC3023]でアプリケーション/ xmlのために特定されたものを超えない既知の相互運用性の検討。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Published Specification: RFC 6940
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公開された仕様：RFC 6940
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that Use this Media Type: The type is used to configure the peer-to-peer overlay networks defined in RFC 6940.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメディアタイプを使用するアプリケーション：タイプは、RFC 6940で定義されたピア・ツー・ピアオーバーレイネットワークを構成するために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional Information: The syntax for this media type is specified in Section 11.1 of [RFC6940]. The contents MUST be valid XML that is compliant with the RELAX NG grammar specified in RFC 6940 and that use the UTF-8[RFC3629] character encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加情報：このメディアタイプの構文は、[RFC6940]のセクション11.1に指定されています。内容は、RFC 6940で指定されたRELAX NG文法に準拠しており、それはUTF-8 [RFC3629]の文字エンコードを使用し、有効なXMLでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Magic Number(s): none
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
マジックナンバー（S）：なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
File Extension(s): relo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RELO：拡張（複数可）ファイル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Macintosh File Type Code(s): none
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Macintoshのファイルタイプコード（S）：なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Person &amp; Email Address to Contact for Further Information: Cullen Jennings &lt;fluffy@cisco.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
人と詳細のために連絡するEメー​​ルアドレス：カレン・ジェニングス&lt;fluffy@cisco.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intended Usage: COMMON
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
意図した使用法：COMMON
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Restrictions on Usage: None
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用上の制限：なし
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Author: Cullen Jennings &lt;fluffy@cisco.com&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著者：カレン・ジェニングス&lt;fluffy@cisco.com&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change Controller: IESG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変更コントローラ：IESG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17. XML Namespace Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17.  XML名前空間の登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document registers two URIs for the config and config-chord XML namespaces in the IETF XML registry defined in [RFC3688].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは[RFC3688]で定義されたIETF XMLレジストリの設定とCONFIG-コードXML名前空間のための2つのURIを登録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17.1. Config URL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17.1. コンフィグURL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI: urn:ietf:params:xml:ns:p2p:config-base
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI：URN：IETF：のparams：XML：NS：P2Pます。config-ベース
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Registrant Contact: IESG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録者連絡先：IESG。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML: N/A, the requested URIs are XML namespaces
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML：N / A、要求されたURIは、XML名前空間です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17.2. Config Chord URL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17.2. コンフィグ和音URL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI: urn:ietf:params:xml:ns:p2p:config-chord
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI：URN：IETF：のparams：XML：NS：P2Pます。config-和音
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Registrant Contact: The IESG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録者連絡先：IESG。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML: N/A, the requested URIs are XML namespaces
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML：N / A、要求されたURIは、XML名前空間です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification is a merge of the &#34;REsource LOcation And Discovery (RELOAD)&#34; document by David A. Bryan, Marcia Zangrilli, and Bruce B. Lowekamp; the &#34;Address Settlement by Peer to Peer&#34; document by Cullen Jennings, Jonathan Rosenberg, and Eric Rescorla; the &#34;Security Extensions for RELOAD&#34; document by Bruce B. Lowekamp and James Deverick; the &#34;A Chord-based DHT for Resource Lookup in P2PSIP&#34; by Marcia Zangrilli and David A. Bryan; and the Peer-to-Peer Protocol (P2PP) document by Salman A. Baset, Henning Schulzrinne, and Marcin Matuszewski. Thanks to the authors of [RFC5389] for text included from that document. Vidya Narayanan provided many comments and improvements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、デビッド・A・ブライアン、マーシャZangrilli、そしてブルースB. Lowekampによる「資源の場所とディスカバリー（RELOAD）」文書のマージです。カレンジェニングス、ジョナサン・ローゼンバーグ、そしてエリックレスコラ、文書を「ピアツーピアによるアドレス決済」。ブルースB. LowekampとジェームズDeverickによる「セキュリティ拡張機能RELOADための」文書。マーシャZangrilliとDavid A.ブライアンによる「P2PSIPにおけるリソースのルックアップのためのAコードベースのDHT」。そしてサルマンA. BASET、ヘンイング・シュルツリン、及びマルチンMatuszewskiによるピア・ツー・ピア・プロトコル（P2PP）ドキュメント。テキストのための[RFC5389]の作者のおかげでその文書から含まれています。 Vidyaナラヤナンは多くのコメントや改善を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ideas and text for the Chord-specific extension data to the Leave mechanisms were provided by Jouni Maenpaa, Gonzalo Camarillo, and Jani Hautakorpi.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
休暇メカニズムに和音固有の拡張データのためのアイデアやテキストはJouni Maenpaa、ゴンサロ・カマリロ、およびヤニHautakorpiによって提供されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to the many people who contributed, including Ted Hardie, Michael Chen, Dan York, Das Saumitra, Lyndsay Campbell, Brian Rosen, David Bryan, Dave Craig, and Julian Cain. Extensive last call comments were provided by Jouni Maenpaa, Roni Even, Gonzalo Camarillo, Ari Keranen, John Buford, Michael Chen, Frederic-Philippe Met, Mary Barnes, Roland Bless, David Bryan, and Polina Goltsman. Special thanks to Marc Petit-Huguenin, who provided an amazing amount of detailed review.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
テッド・ハーディ、マイケル・チェン、ダン・ニューヨーク、ダスSaumitra、リンゼー・キャンベル、ブライアン・ローゼン、デヴィッド・ブライアン、デイブ・クレイグ、そしてジュリアン・カインを含む貢献し、多くの人々に感謝します。豊富なラストコールコメントはJouni Maenpaa、ロニでも、ゴンサロ・カマリロ、アリKeranen、ジョン・ビュフォード、マイケル・チェン、フレデリック・フィリップメット、メアリー・バーンズ、ローランドが祝福、デヴィッド・ブライアン、およびポリーナGoltsmanによって提供されました。詳細なレビューの驚くべき量を提供マルク・プティ・Huguenin、に感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dean Willis and Marc Petit-Huguenin helped resolve and provided text to fix many comments received during the IESG review.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ディーンウィリスとマルク・プティ・Hugueninは解決助けとIESGレビュー中に受信した多くのコメントを修正するためのテキストを提供しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OASIS.relax_ng] Bray, T. and M. Murata, &#34;RELAX NG Specification&#34;, December 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【OASIS.relax_ng]ブレイ、T.及びM.村田、2001年12月 &#34;NG仕様RELAX&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1918] Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E. Lear, &#34;Address Allocation for Private Internets&#34;, BCP 5, RFC 1918, February 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1918] Rekhter、Y.、モスコウィッツ、R.、Karrenberg、D.、グルート、G.、およびE.リア、 &#34;個人的なインターネットのための配分&#34;、BCP 5、RFC 1918、1996年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2388] Masinter, L., &#34;Returning Values from Forms: multipart/ form-data&#34;, RFC 2388, August 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2388] Masinter、L.、 &#34;フォームからの値返す：multipart / form-data&#34; を、RFC 2388、1998年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2585] Housley, R. and P. Hoffman, &#34;Internet X.509 Public Key Infrastructure Operational Protocols: FTP and HTTP&#34;, RFC 2585, May 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2585] Housley氏、R.とP.ホフマン、 &#34;インターネットX.509公開鍵基盤運用プロトコル：FTPやHTTP&#34;、RFC 2585、1999年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, &#34;A DNS RR for specifying the location of services (DNS SRV)&#34;, RFC 2782, February 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2782] Gulbrandsenの、A.、いるVixie、P.、およびL. Esibov、 &#34;サービスの場所を特定するためのDNS RR（DNSのSRV）&#34;、RFC 2782、2000年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2818] Rescorla, E., &#34;HTTP Over TLS&#34;, RFC 2818, May 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2818]レスコラ、E.、 &#34;TLSオーバーHTTP&#34;、RFC 2818、2000年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3023] Murata, M., St. Laurent, S., and D. Kohn, &#34;XML Media Types&#34;, RFC 3023, January 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3023]村田、M.、サンローラン、S.、およびD.コーン、 &#34;XMLのメディアタイプ&#34;、RFC 3023、2001年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3174] Eastlake, D. and P. Jones, &#34;US Secure Hash Algorithm 1 (SHA1)&#34;, RFC 3174, September 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3174]イーストレイク、D.とP.ジョーンズは、 &#34;米国は、ハッシュアルゴリズム1（SHA1）を確保&#34;、RFC 3174、2001年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3339] Klyne, G., Ed. and C. Newman, &#34;Date and Time on the Internet: Timestamps&#34;, RFC 3339, July 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3339] Klyne、G.、エド。そして、C.ニューマン、「インターネット上の日付と時刻：タイムスタンプ」、RFC 3339、2002年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3447] Jonsson, J. and B. Kaliski, &#34;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1&#34;, RFC 3447, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3447]ジョンソン、J.とB. Kaliski、 &#34;公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン2.1&#34;、RFC 3447、2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3629] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, STD 63, RFC 3629, November 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3629] Yergeau、F.、 &#34;UTF-8、ISO 10646の変換フォーマット&#34;、STD 63、RFC 3629、2003年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, &#34;Uniform Resource Identifier (URI): Generic Syntax&#34;, STD 66, RFC 3986, January 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 &#34;ユニフォームリソース識別子（URI）：汎用構文&#34;、STD 66、RFC 3986、2005年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4279] Eronen, P. and H. Tschofenig, &#34;Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)&#34;, RFC 4279, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4279] Eronen、P.とH. Tschofenig、RFC 4279 &#34;トランスポート層セキュリティ（TLS）のための事前共有鍵暗号の組み合わせ&#34;、2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4395] Hansen, T., Hardie, T., and L. Masinter, &#34;Guidelines and Registration Procedures for New URI Schemes&#34;, BCP 35, RFC 4395, February 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4395]ハンセン、T.、ハーディ、T.、およびL. Masinter、 &#34;新しいURIスキームのためのガイドラインと登録手順&#34;、BCP 35、RFC 4395、2006年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648] Josefsson, S., &#34;The Base16, Base32, and Base64 Data Encodings&#34;, RFC 4648, October 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648] Josefsson氏、S.、 &#34;Base16、Base32、およびBase64でデータエンコーディング&#34;、RFC 4648、2006年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5226] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 5226, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5226] Narten氏、T.とH. Alvestrand、 &#34;RFCsにIANA問題部に書くためのガイドライン&#34;、BCP 26、RFC 5226、2008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5245] Rosenberg, J., &#34;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols&#34;, RFC 5245, April 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5245]ローゼンバーグ、J.、 &#34;インタラクティブ接続確立（ICE）：オファー/回答プロトコルのためのネットワークアドレス変換（NAT）トラバーサルのための議定書&#34;、RFC 5245、2010年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, August 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246]ダークス、T.およびE.レスコラ、 &#34;トランスポート層セキュリティ（TLS）プロトコルバージョン1.2&#34;、RFC 5246、2008年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5272] Schaad, J. and M. Myers, &#34;Certificate Management over CMS (CMC)&#34;, RFC 5272, June 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5272] Schaad、J.とM.マイヤーズ、 &#34;CMSオーバー証明書の管理（CMC）&#34;、RFC 5272、2008年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5273] Schaad, J. and M. Myers, &#34;Certificate Management over CMS (CMC): Transport Protocols&#34;, RFC 5273, June 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5273] Schaad、J.とM.マイヤーズ、 &#34;CMS（CMC）以上の証明書の管理：トランスポートプロトコル&#34;、RFC 5273、2008年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &#34;Session Traversal Utilities for NAT (STUN)&#34;, RFC 5389, October 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389]ローゼンバーグ、J.、マーイ、R.、マシューズ、P.、およびD.翼、 &#34;NAT（STUN）のセッショントラバーサルユーティリティ&#34;、RFC 5389、2008年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405] Eggert, L. and G. Fairhurst, &#34;Unicast UDP Usage Guidelines for Application Designers&#34;, BCP 145, RFC 5405, November 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405]エッゲルト、L.とG. Fairhurst、 &#34;アプリケーションデザイナーのためのユニキャストUDPの使用上の注意事項&#34;、BCP 145、RFC 5405、2008年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5766] Mahy, R., Matthews, P., and J. Rosenberg, &#34;Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)&#34;, RFC 5766, April 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5766]マーイ、R.、マシューズ、P.、およびJ.ローゼンバーグ、 &#34;トラバーサルNAT（TURN）の周りにリレーを使用してリレー拡張NAT（STUN）のセッショントラバーサルユーティリティに&#34;、RFC 5766、2010年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5952] Kawamura, S. and M. Kawashima, &#34;A Recommendation for IPv6 Address Text Representation&#34;, RFC 5952, August 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5952]川村、S.とM.川島、RFC 5952、2010年8月、 &#34;IPv6アドレスのテキスト表現のための勧告&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6091] Mavrogiannopoulos, N. and D. Gillmor, &#34;Using OpenPGP Keys for Transport Layer Security (TLS) Authentication&#34;, RFC 6091, February 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6091] Mavrogiannopoulos、N.およびD. Gillmor氏、RFC 6091、2011年2月 &#34;トランスポート層セキュリティ（TLS）認証のためのOpenPGPキーの使用&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6234] Eastlake, D. and T. Hansen, &#34;US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)&#34;, RFC 6234, May 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6234]イーストレイク、D.とT.ハンセンは、 &#34;米国は、ハッシュアルゴリズム（SHAとSHAベースのHMACとHKDF）を確保&#34;、RFC 6234、2011年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, &#34;Computing TCP&#39;s Retransmission Timer&#34;, RFC 6298, June 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298]パクソン、V.、オールマン、M.、チュー、J.、およびM.サージェント、 &#34;コンピューティングTCPの再送信タイマー&#34;、RFC 6298、2011年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347] Rescorla, E. and N. Modadugu, &#34;Datagram Transport Layer Security Version 1.2&#34;, RFC 6347, January 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347]レスコラ、E.およびN. Modadugu、 &#34;データグラムトランスポート層セキュリティバージョン1.2&#34;、RFC 6347、2012年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.REC-xmlschema-2-20041028] Malhotra, A. and P. Biron, &#34;XML Schema Part 2: Datatypes Second Edition&#34;, World Wide Web Consortium Recommendation REC-xmlschema-2-20041028, October 2004, &lt;http://www.w3.org/TR/2004/REC-xmlschema-2-20041028&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.REC-XMLSCHEMA-2から20041028]マルホトラ、A.、およびP.ビロン、 &#34;XMLスキーマパート2：データ型第二版&#34;、World Wide Web Consortium（W3C）の勧告REC-XMLSCHEMA-2から20041028、2004年10月、&lt;のhttp： //www.w3.org/TR/2004/REC-xmlschema-2-20041028&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[w3c-xml-namespaces] Bray, T., Hollander, D., Layman, A., Tobin, R., and University of Edinburgh and W3C, &#34;Namespaces in XML 1.0 (Third Edition)&#34;, December 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C-XML-名前空間]ブレイ、T.、オランダ、D.、素人、A.、トービン、R.、エディンバラとW3Cの大学、 &#34;XML 1.0での名前空間（第3版）&#34;、2008年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Chord] Stoica, I., Morris, R., Liben-Nowell, D., Karger, D., Kaashoek, M., Dabek, F., and H. Balakrishnan, &#34;Chord: A Scalable Peer-to-peer Lookup Protocol for Internet Applications&#34;, IEEE/ACM Transactions on Networking Volume 11, Issue 1, 17-32, Feb 2003, 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[コード] Stoicaの、I.、モリス、R.、リベニ-Nowell、D.、カーガー、D.、Kaashoek、M.、Dabek、F.、及びH.バラクリシュナン、「コード：スケーラブルなピアツーピアネットワーク11巻、1号、17-32、2003年2月、2001年のインターネットアプリケーション」、IEEE / ACM取引のためのルックアップのプロトコル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DHT-RELOAD] Maenpaa, J. and G. Camarillo, &#34;A Self-tuning Distributed Hash Table (DHT) for REsource LOcation And Discovery (RELOAD)&#34;, Work in Progress, August 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DHTリロード] Maenpaa、J.及びG.カマリロ、進歩、2013年8月に働いて「リソースロケーションとディスカバリー（リロード）するためのハッシュテーブル（DHT）分散セルフチューニング」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Eclipse] Singh, A., Ngan, T., Druschel, T., and D. Wallach, &#34;Eclipse Attacks on Overlay Networks: Threats and Defenses&#34;, INFOCOM 2006, April 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Eclipseの]シン、A.、ンガン、T.、Druschel、T.、およびD.ウォラック、 &#34;オーバレイネットワーク上のEclipseの攻撃：脅威と防御&#34;、インフォコム2006年、2006年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2P-DIAGNOSTICS] Song, H., Jiang, X., Even, R., and D. Bryan, &#34;P2P Overlay Diagnostics&#34;, Work in Progress, August 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2P-DIAGNOSTICS]ソング、H.、江、X.、でも、R.、およびD.ブライアン、 &#34;P2Pオーバーレイ診断&#34;、進歩、2013年8月での作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2PSIP-RELAY] Zong, N., Jiang, X., Even, R., and Y. Zhang, &#34;An extension to RELOAD to support Relay Peer Routing&#34;, Work in Progress, October 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2PSIP-RELAY]宗、N.、江、X.、でも、R.、およびY.チャンは、進歩、2013年10月に、ワーク &#34;拡張子が中継ピアのルーティングをサポートするためにリロードします&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REDIR-RELOAD] Maenpaa, J. and G. Camarillo, &#34;Service Discovery Usage for REsource LOcation And Discovery (RELOAD)&#34;, Work in Progress, August 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REDIRリロード] Maenpaa、J.およびG.キャマリロ、「リソースロケーションとディスカバリー（リロード）するためのサービス発見の使用」、進歩、2013年8月に働いています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1035] Mockapetris, P., &#34;Domain names - implementation and specification&#34;, STD 13, RFC 1035, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1035] Mockapetris、P.、 &#34;ドメイン名 - 実装及び仕様&#34;、STD 13、RFC 1035、1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, October 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122]ブレーデン、R.、 &#34;インターネットホストのための要件 - 通信層&#34;、STD 3、RFC 1122、1989年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2311] Dusse, S., Hoffman, P., Ramsdell, B., Lundblade, L., and L. Repka, &#34;S/MIME Version 2 Message Specification&#34;, RFC 2311, March 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2311] Dusse、S.、ホフマン、P.、Ramsdell、B.、Lundblade、L.、及びL. Repka、 &#34;S / MIMEバージョン2メッセージ仕様&#34;、RFC 2311、1998年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3688] Mealling, M., &#34;The IETF XML Registry&#34;, BCP 81, RFC 3688, January 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3688] Mealling、M.、 &#34;IETF XMLレジストリ&#34;、BCP 81、RFC 3688、2004年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4013] Zeilenga, K., &#34;SASLprep: Stringprep Profile for User Names and Passwords&#34;, RFC 4013, February 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4013] Zeilenga、K.、 &#34;SASLprep：ユーザ名とパスワードのためのstringprepプロフィール&#34;、RFC 4013、2005年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086]イーストレーク、D.、シラー、J.、およびS.クロッカー、 &#34;セキュリティのためのランダム要件&#34;、BCP 106、RFC 4086、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4145] Yon, D. and G. Camarillo, &#34;TCP-Based Media Transport in the Session Description Protocol (SDP)&#34;, RFC 4145, September 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4145]ヨン、D.とG.カマリロ、 &#34;TCPベースのセッション記述プロトコル（SDP）にメディアトランスポート&#34;、RFC 4145、2005年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4340] Kohler, E., Handley, M., and S. Floyd, &#34;Datagram Congestion Control Protocol (DCCP)&#34;, RFC 4340, March 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4340]コーラー、E.、ハンドリー、M.、およびS.フロイド、 &#34;データグラム輻輳制御プロトコル（DCCP）&#34;、RFC 4340、2006年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4787] Audet, F. and C. Jennings, &#34;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP&#34;, BCP 127, RFC 4787, January 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4787] Audet、F.とC.ジェニングス、 &#34;ネットワークアドレス変換（NAT）ユニキャストUDPのための行動の要件&#34;、BCP 127、RFC 4787、2007年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4960] Stewart, R., &#34;Stream Control Transmission Protocol&#34;, RFC 4960, September 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4960]スチュワート、R.、 &#34;ストリーム制御伝送プロトコル&#34;、RFC 4960、2007年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5054] Taylor, D., Wu, T., Mavrogiannopoulos, N., and T. Perrin, &#34;Using the Secure Remote Password (SRP) Protocol for TLS Authentication&#34;, RFC 5054, November 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5054]テイラー、D.、呉、T.、Mavrogiannopoulos、N.、およびT.ペリン、 &#34;セキュアリモートパスワードの使い方（SRP）TLS認証のためのプロトコル&#34;、RFC 5054、2007年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5095] Abley, J., Savola, P., and G. Neville-Neil, &#34;Deprecation of Type 0 Routing Headers in IPv6&#34;, RFC 5095, December 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5095] Abley、J.、Savola、P.、およびG.ネビル・ニール、RFC 5095、2007年12月の &#34;IPv6におけるタイプ0ルーティングヘッダの廃止&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5201] Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &#34;Host Identity Protocol&#34;, RFC 5201, April 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5201]モスコウィッツ、R.、Nikander、P.、Jokela、P.、およびT.ヘンダーソン、 &#34;ホストアイデンティティプロトコル&#34;、RFC 5201、2008年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &#34;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 5280, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5694] Camarillo, G., Ed., and IAB, &#34;Peer-to-Peer (P2P) Architecture: Definition, Taxonomies, Examples, and Applicability&#34;, RFC 5694, November 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5694]キャマリロ、G.、エド、およびIAB、 &#34;ピア・ツー・ピア（P2P）アーキテクチャ：定義、分類法、例、および適用性&#34;、RFC 5694、2009年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5765] Schulzrinne, H., Marocco, E., and E. Ivov, &#34;Security Issues and Solutions in Peer-to-Peer Systems for Realtime Communications&#34;, RFC 5765, February 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5765] Schulzrinneと、H.、Marocco、E.、およびE. Ivov、 &#34;セキュリティの問題やリアルタイムコミュニケーションのためのピア・ツー・ピアシステムにおけるソリューション&#34;、RFC 5765、2010年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5785] Nottingham, M. and E. Hammer-Lahav, &#34;Defining Well-Known Uniform Resource Identifiers (URIs)&#34;, RFC 5785, April 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5785]ノッティンガム、M.とE.ハンマー -  Lahav、 &#34;既知のUniform Resource Identifier（URI）を定義&#34;、RFC 5785、2010年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6079] Camarillo, G., Nikander, P., Hautakorpi, J., Keranen, A., and A. Johnston, &#34;HIP BONE: Host Identity Protocol (HIP) Based Overlay Networking Environment (BONE)&#34;, RFC 6079, January 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6079]キャマリロ、G.、Nikander、P.、Hautakorpi、J.、Keranen、A.、およびA.ジョンストン、 &#34;HIP骨：ホストアイデンティティプロトコル（HIP）ベースのオーバレイネットワーク環境（骨）&#34;、RFC 6079、 2011年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6544] Rosenberg, J., Keranen, A., Lowekamp, B., and A. Roach, &#34;TCP Candidates with Interactive Connectivity Establishment (ICE)&#34;, RFC 6544, March 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6544]ローゼンバーグ、J.、Keranen、A.、Lowekamp、B.、およびA.ローチ、RFC 6544、2012年3月 &#34;インタラクティブ接続確立（ICE）とTCP候補&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7086] Keranen, A., Camarillo, G., and J. Maenpaa, &#34;Host Identity Protocol-Based Overlay Networking Environment (HIP BONE) Instance Specification for REsource LOcation And Discovery (RELOAD)&#34;, RFC 7086, January 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7086] Keranen、A.、カマリロ、G.、およびJ. Maenpaa、 &#34;ホストアイデンティティプロトコルベースのオーバレイネットワーク環境（寛骨）リソースロケーションと発見のためのインスタンス仕様（リロード）&#34;、RFC 7086、2014年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SIP-RELOAD] Jennings, C., Lowekamp, B., Rescorla, E., Baset, S., Schulzrinne, H., and T. Schmidt, &#34;A SIP Usage for RELOAD&#34;, Work in Progress, July 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SIPリロード]ジェニングス、C.、Lowekamp、B.、レスコラ、E.、BASET、S.、Schulzrinneと、H.、およびT.シュミット、 &#34;リロードのSIPの使用&#34;、進歩、2013年7月に働いています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sybil] Douceur, J., &#34;The Sybil Attack&#34;, IPTPS 02, March 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[シビル]ドゥスール、J.、 &#34;シビル・アタック&#34;、2002年3月、02 IPTPS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UnixTime] Wikipedia, &#34;Unix Time&#34;, 2013, &lt;http://en.wikipedia.org/w/ index.php?title=Unix_time&amp;oldid=551527446&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UnixTime]ウィキペディア、 &#34;Unixの時間&#34;、2013年、&lt;http://en.wikipedia.org/w/のindex.php？タイトル= UNIX_TIME＆oldid = 551527446&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[bryan-design-hotp2p08] Bryan, D., Lowekamp, B., and M. Zangrilli, &#34;The Design of a Versatile, Secure P2PSIP Communications Architecture for the Public Internet&#34;, Hot-P2P&#39;08, 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ブライアン・デザインhotp2p08]ブライアン、D.、Lowekamp、B.、およびM. Zangrilli、「万能の設計、公衆インターネットのためのセキュアなP2PSIPコミュニケーションアーキテクチャ」、ホットP2P&#39;08、2008。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[handling-churn-usenix04] Rhea, S., Geels, D., Roscoe, T., and J. Kubiatowicz, &#34;Handling Churn in a DHT&#34;, In Proc. of the USENIX Annual Technical Conference June 2004 USENIX 2004, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[処理 - チャーン -  usenix04]レア、S.、Geels、D.、ロスコー、T.、およびJ. Kubiatowiczは、PROCで、 &#34;DHTにチャーンを処理します&#34;。 USENIX年次専門技術セミナー2004年6月USENIX 2004、2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[lookups-churn-p2p06] Wu, D., Tian, Y., and K. Ng, &#34;Analytical Study on Improving DHT Lookup Performance under Churn&#34;, IEEE P2P&#39;06, 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[検索-解約-p2p06]呉、D.、天、Y.、およびK.ン、 &#34;解約下DHTルックアップパフォーマンスの向上に関する解析的検討&#34;、IEEE P2P&#39;06、2006。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[minimizing-churn-sigcomm06] Godfrey, P., Shenker, S., and I. Stoica, &#34;Minimizing Churn in Distributed Systems&#34;, SIGCOMM 2006, 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[最小限 - チャーン -  sigcomm06]ゴッド、P.、Shenker、S.、およびI.ストイカ、 &#34;分散システムにおける最小化チャーン&#34;、SIGCOMM 2006 2006
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[non-transitive-dhts-worlds05] Freedman, M., Lakshminarayanan, K., Rhea, S., and I. Stoica, &#34;Non-Transitive Connectivity and DHTs&#34;, WORLDS&#39;05, 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[非推移-のDHT-worlds05]フリードマン、M.、Lakshminarayanan、K.、レア、S.、およびI.ストイカ、 &#34;非推移コネクタとのDHT&#34;、WORLDS&#39;05 2005。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[opendht-sigcomm05] Rhea, S., Godfrey, B., Karp, B., Kubiatowicz, J., Ratnasamy, S., Shenker, S., Stoica, I., and H. Yu, &#34;OpenDHT: A Public DHT and its Uses&#34;, SIGCOMM&#39;05, 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[opendht-sigcomm05]レア、S.、ゴッド、B.、カープ、B.、Kubiatowicz、J.、Ratnasamy、S.、Shenker、S.、ストイカ、I.、およびH.優、「OpenDHT：公共DHTおよびその使用方法」、SIGCOMM&#39;05、2005。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[vulnerabilities-acsac04] Srivatsa, M. and L. Liu, &#34;Vulnerabilities and Security Threats in Structured Peer-to-Peer Systems: A Quantitative Analysis&#34;, ACSAC 2004, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[脆弱性-acsac04] Srivatsa、M.およびL.劉、 &#34;構造化ピアツーピアシステムの脆弱性とセキュリティの脅威：定量的分析&#34;、ACSAC 2004、2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[wikiChord] Wikipedia, &#34;Chord (peer-to-peer)&#34;, 2013, &lt;http://en.wikipedia.org/w/ index.php?title=Chord_%28peer-to-peer%29&amp;oldid=549516287&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【wikiChord]ウィキペディア、 &#34;コード（ピア・ツー・ピア）&#34; 2013年、&lt;http://en.wikipedia.org/w/ index.phpを？タイトル= Chord_％28peerツー・ピア％29＆oldid = 549516287&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[wikiKBR] Wikipedia, &#34;Key-based routing&#34;, 2013, &lt;en.wikipedia.org/w/ index.php?title=Key-based_routing&amp;oldid=543850833&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[wikiKBR]ウィキペディア、 &#34;キーベースのルーティング&#34;、2013年、&lt;en.wikipedia.org/w/のindex.php？タイトル=キーbased_routing＆oldid = 543850833&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[wikiSkiplist] Wikipedia, &#34;Skip list&#34;, 2013, &lt;http://en.wikipedia.org/w/ index.php?title=Skip_list&amp;oldid=551304213&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[wikiSkiplist]ウィキペディアは、2013年、 &#34;リストをスキップ&#34; &lt;http://en.wikipedia.org/w/のindex.php？タイトル= Skip_list＆oldid = 551304213&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A. Routing Alternatives
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録A.ルーティング代替
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Significant discussion has been focused on the selection of a routing algorithm for P2PSIP. This section discusses the motivations for selecting symmetric recursive routing for RELOAD and describes the extensions that would be required to support additional routing algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重要な議論がP2PSIPのルーティングアルゴリズムの選択が注目されています。このセクションでは、RELOADのための対称再帰ルーティングを選択するための動機を説明し、追加のルーティングアルゴリズムをサポートするために必要となる拡張機能について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1. Iterative vs. Recursive
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1。再帰対反復
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Iterative routing has a number of advantages. It is easier to debug, consumes fewer resources on intermediate peers, and allows the querying peer to identify and route around misbehaving peers [non-transitive-dhts-worlds05]. However, in the presence of NATs, iterative routing is intolerably expensive, because a new connection must be established for each hop (using ICE) [bryan-design-hotp2p08].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
反復ルーティングは多くの利点を有します。これは、デバッグが容易である中間ピアに、より少ないリソースを消費し、クエリピアがピアを誤動作周り[非推移-のDHT-worlds05]を識別して経路を可能にします。新しい接続が（ICEを使用して）各ホップのために確立されなければならないのでしかし、NATの存在下で、反復ルーティングは[ブライアン・デザインhotp2p08]、耐えられないほど高価です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Iterative routing is supported through the RouteQuery mechanism and is primarily intended for debugging. It also allows the querying peer to evaluate the routing decisions made by the peers at each hop, consider alternatives, and perhaps detect at what point the forwarding path fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
反復ルーティングはRouteQuery機構を介して支持され、主にデバッグのために意図されています。また、各ホップでピアによって作られたルーティング決定を評価する代替案を検討し、そしておそらく転送パスに障害が発生したどの地点で検出するための照会ピアすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2. Symmetric vs. Forward Response
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2。フォワードレスポンス対対称
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An alternative to the symmetric recursive routing method used by RELOAD is forward-only routing, where the response is routed to the requester as if it were a new message initiated by the responder. (In the previous example, Z sends the response to A as if it were sending a request.) Forward-only routing requires no state in either the message or intermediate peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リロードで使用される対称再帰ルーティング法に代わるものは、それが応答によって開始さ新しいメッセージであるかのように応答を要求者に送られる順方向専用ルーティングです。 （それは、要求を送信したかのように、前の例では、Zは、への応答を送信する。）順方向専用ルーティングは、メッセージまたは中間ピアのいずれかでない状態を必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The drawback of forward-only routing is that it does not work when the overlay is unstable. For example, if A is in the process of joining the overlay and is sending a Join request to Z, it is not yet reachable via forward-only routing. Even if it is established in the overlay, if network failures produce temporary instability, A may not be reachable (and may be trying to stabilize its network connectivity via Attach messages).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前方のみのルーティングの欠点は、オーバーレイが不安定な場合、それは動作しないということです。 Aは、オーバレイに参加する過程であり、Zへの参加要求を送信している場合、例えば、それはまだ前方にのみルーティングを介して到達可能ではありません。それは、オーバーレイで確立されている場合でも、ネットワーク障害が一時的な不安定性をもたらすならば、Aは到達可能ではないかもしれない（と添付したメッセージを経由して、ネットワークの接続性を安定させるためにしようとすることができます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, forward-only responses are less likely to reach the querying peer than symmetric recursive ones are, because the forward path is more likely to have a failed peer than is the request path (which was just tested to route the request) [non-transitive-dhts-worlds05].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フォワードパスは、[非（単にルート要求に試験された）要求パスがより失敗したピアを持っている可能性が高いため、さらに、前方のみ応答は、対称的な再帰的なものでより問合せピアに到達する可能性が低いです推移-のDHT-worlds05]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An extension to RELOAD that supports forward-only routing but relies on symmetric responses as a fallback would be possible, but due to the complexities of determining when to use forward-only routing and when to fallback to symmetric routing, we have chosen not to include it as an option at this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それをリロードする拡張機能は、順方向専用のルーティングをサポートしていますが、フォールバックが可能なように、対称応答に依存しているが、原因前方のみのルーティングを使用するかを決定し、とき対称ルーティングにフォールバックするの複雑さに、私たちは含めないことを選択しましたそれこの時点でオプションとして。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.3. Direct Response
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.3。ダイレクトレスポンス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another routing option is direct response routing, in which the response is returned directly to the querying node. In the previous example, if A encodes its IP address in the request, then Z can simply deliver the response directly to A. In the absence of NATs or other connectivity issues, this is the optimal routing technique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別のルーティングオプションは、応答が照会ノードに直接戻される直接応答ルーティング、です。前の例では、Aは、要求にそのIPアドレスを符号化する場合、Zは、単にのNATまたは他の接続の問題が存在しない場合にはAに直接応答を提供することができ、これは、最適なルーティング技術です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The challenge of implementing direct response routing is the presence of NATs. There are a number of complexities that must be addressed. In this discussion, we will continue our assumption that A issued the request and Z is generating the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ダイレクトレスポンスルーティングを実装するという課題は、NATの存在です。取り組まなければならない複雑さの数があります。この議論では、Aは、要求を発行し、Zは、応答を生成している私たちの仮定を継続していきます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The IP address listed by A may be unreachable, either due to NAT or firewall rules. Therefore, a direct response technique must fallback to symmetric response [non-transitive-dhts-worlds05]. The hop-by-hop ACKs used by RELOAD allow Z to determine when A has received the message (and the TLS negotiation will provide earlier confirmation that A is reachable), but this fallback requires a timeout that will increase the response latency whenever A is not reachable from Z.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O Aによって記載されているIPアドレスは、どちらかによるNATやファイアウォールのルールに到達できないことがあります。したがって、ダイレクトレスポンス技術は、対称応答[非推移-のDHT-worlds05]にフォールバックしなければなりません。リロードで使用されるホップバイホップACKはZ Aがメッセージを受信したときを決定するために（およびTLSネゴシエーションは、Aが到達可能であることは、以前の確認を提供することになる）可能に、このフォールバックがAであるときはいつでも応答待ち時間を増加するタイムアウトを必要とZ.から到達できません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Whenever A is behind a NAT it, will have multiple candidate IP addresses, each of which must be advertised to ensure connectivity. Therefore, Z will need to attempt multiple connections to deliver the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Aは、NATの背後にあるときはいつでもOそれは、接続性を確保するために宣伝されている必要があり、それぞれが、複数の候補のIPアドレスを持つことになります。したがって、Zは、応答を提供するために複数の接続を試みる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o One (or all) of A&#39;s candidate addresses may route from Z to a different device on the Internet. In the worst case, these nodes may actually be running RELOAD on the same port. Therefore, it is absolutely necessary to establish a secure connection to authenticate A before delivering the response. This step diminishes the efficiency of direct response routing, because multiple round-trips are required before the message can be delivered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Aの候補アドレスのいずれか（またはすべて）O経路Zからインターネット上の別のデバイスにしてもよいです。最悪の場合には、これらのノードは、実際には同じポートでRELOADを実行することができます。したがって、応答を配信する前に認証するためのセキュアな接続を確立するために絶対に必要です。メッセージが配信される前に、複数のラウンドトリップを必要とするため、この手順は、直接応答ルーティングの効率を減少させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If A is behind a NAT and does not have a connection already established with Z, there are only two ways the direct response will work. The first is that A and Z must both be behind the same NAT, in which case the NAT is not involved. In the more common case, when Z is outside A&#39;s NAT, the response will be received only if A&#39;s NAT implements endpoint-independent filtering. As the choice of filtering mode conflates application transparency with security [RFC4787] and no clear recommendation is available, the prevalence of this feature in future devices remains unclear.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O AがNATの背後にあると、既にZで確立された接続を持っていない場合は、直接の応答が動作する唯一の2つの方法があります。最初は、AとZの両方NATが関与していない場合には、同じNATの背後でなければならないことです。 ZがAのNATの外側にある場合に、より一般的なケースでは、応答は、AのNATがエンドポイント非依存フィルタリングを実装した場合にのみ受信されます。フィルタリングモードの選択は、[RFC4787]と明確な勧告が利用可能であるセキュリティとアプリケーションの透明性を融合しますと、将来のデバイスでは、この機能の有病率は依然として不明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An extension to RELOAD that supports direct response routing but relies on symmetric responses as a fallback would be possible, but due to the complexities of determining when to use direct response routing and when to fallback to symmetric routing, and the reduced performance for responses to peers behind restrictive NATs, we have chosen not to include it as an option at this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それをリロードする拡張子は直接応答ルーティングをサポートするが、代替が可能であるように対称的な応答に依存しているが、原因決定の複雑さにするとき、対称ルーティングにフォールバックに直接応答ルーティングとを使用する場合、およびピアへの応答のための性能低下制限NATの背後に、我々はこの時点ではオプションとして、それを含めるしないことを選択しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4. Relay Peers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4。リレーピア
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2PSIP-RELAY] has proposed implementing a form of direct response by having A identify a peer, Q, that will be directly reachable by any other peer. A uses Attach to establish a connection with Q and advertises Q&#39;s IP address in the request sent to Z. Z sends the response to Q, which relays it to A. This then reduces the latency to two hops, and Z is negotiating a secure connection to Q.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2PSIPリレー]は、他のピアによって直接到達可能になり、ピア、Qを、特定有することによって直接応答の形式を実装提案しています。用途はQとの接続を確立するために取り付け、Z. Zに送信された要求におけるQのIPアドレスは、2つのホップに待ち時間を短縮これA.に中継Qに対する応答を送信アドバタイズ、およびZは、安全な接続を交渉していますQ.へ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This technique relies on the relative population of nodes such as A that require relay peers and peers such as Q that are capable of serving as a relay peer. It also requires nodes to be able to identify which category they are in. This identification problem has turned out to be hard to solve and is still an open area of exploration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この技術は、中継ピアとして機能することが可能であるようなQとして中継ピアとのピアを必要とするノードの相対的な集団に依存しています。それはまた、彼らはしているどのカテゴリに識別できるようにするには、ノードが必要です。この識別問題を解決するのは難しいことが判明し、まだ探査の開口面積でいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An extension to RELOAD that supports relay peers is possible, but due to the complexities of implementing such an alternative, we have not added such a feature to RELOAD at this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それをリロードする拡張機能は、リレーのピアが可能ですサポートしていますが、そのような代替の実装の複雑さのために、我々はこの時点でリロードするなどの機能を追加していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A concept similar to relay peers, essentially choosing a relay peer at random, has previously been suggested to solve problems of pair-wise non-transitivity [non-transitive-dhts-worlds05], but deterministic filtering provided by NATs makes random relay peers no more likely to work than the responding peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本質的にランダムで中継ピアを選択するピアを中継する同様の概念は、以前に[非推移-のDHT-worlds05]ペアワイズ非推移の問題を解決するために提案されているが、NATのが提供する確定的なフィルタリングが無いランダムリレーピアを作ります応答側のピアよりも動作する可能性が高いです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.5. Symmetric Route Stability
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.5。対称ルートの安定性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A common concern about symmetric recursive routing has been that one or more peers along the request path may fail before the response is received. The significance of this problem essentially depends on the response latency of the overlay. An overlay that produces slow responses will be vulnerable to churn, whereas responses that are delivered very quickly are vulnerable only to failures that occur over that small interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対称再帰ルーティングに関する一般的な懸念は、応答が受信される前に、要求パスに沿った1つ以上のピアが失敗することがありました。この問題の重要性は、本質的に、オーバーレイの応答の待ち時間に依存します。非常に迅速に配信された応答は、それだけで小さな間隔で発生する障害に対して脆弱であるのに対し、遅い応答を生成し、オーバーレイは、解約する脆弱になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The other aspect of this issue is whether the request itself can be successfully delivered. Assuming typical connection maintenance intervals, the time period between the last maintenance and the request being sent will be orders of magnitude greater than the delay between the request being forwarded and the response being received. Therefore, if the path was stable enough to be available to route the request, it is almost certainly going to remain available to route the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この問題の他の側面は、要求自体が正常に配信することができるかどうかです。代表的な接続メンテナンス間隔を仮定すると、最後のメンテナンスおよび送信される要求の間の時間期間は、転送される要求及び受信される応答との間の遅延よりも大きい大きさのオーダーであろう。パスがルート要求に利用できるようにするために十分安定していた場合はそのため、ほぼ確実にルーティングするために応答可能なままになるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An overlay that is unstable enough to suffer this type of failure frequently is unlikely to be able to support reliable functionality regardless of the routing mechanism. However, regardless of the stability of the return path, studies show that in the event of high churn, iterative routing is a better solution to ensure request completion [lookups-churn-p2p06] [non-transitive-dhts-worlds05]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このタイプの障害を受けるに十分に不安定であるオーバーレイは頻繁にかかわらず、ルーティングメカニズムの信頼性の高い機能をサポートすることができることはほとんどありません。しかし、関係なく、復路の安定性、研究が高い解約の場合には、反復ルーティングは要求の完了を確保するためのより良い解決策であることを示す[ルックアップ・チャーン-p2p06] [非推移-のDHT-worlds05]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, because RELOAD retries the end-to-end request, that retry will address the issues of churn that remain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOADは、エンドツーエンドの要求を再試行するため、最後に、そのリトライが残るチャーンの問題に対処します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix B. Why Clients?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録B.なぜクライアント？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a wide variety of reasons a node may act as a client rather than as a peer. This section outlines some of those scenarios and how the client&#39;s behavior changes based on its capabilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ノードがクライアントとしてではなく、ピアとして作用することができる理由のさまざまながあります。このセクションでは、これらのシナリオのいくつかを概説し、どのようにクライアントの動作の変更、その能力に基づきます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.1. Why Not Only Peers?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.1。なぜピアだけ？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a number of reasons, a particular node may be forced to act as a client even though it is willing to act as a peer. These include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くの理由により、特定のノードは、ピアとして機能して喜んであってもクライアントとして動作するように強制することができます。これらは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The node does not have appropriate network connectivity, typically because it has a low-bandwidth network connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oノードは、それが低帯域幅のネットワーク接続を持っている一般的にあるため、適切なネットワーク接続を持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The node may not have sufficient resources, such as computing power, storage space, or battery power.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oノードは、計算能力、記憶容量、またはバッテリ電源として十分なリソースを有していなくてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The overlay algorithm may dictate specific requirements for peer selection. These may include participating in the overlay to determine trustworthiness, controlling the number of peers in the overlay to reduce overly long routing paths, and ensuring minimum application uptime before a node can join as a peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oオーバーレイアルゴリズムは、ピア選択のための特定の要件を指示することができます。これらは、信頼性を決定するために、オーバーレイに参加過度に長いルーティング経路を減少させるために、オーバーレイ内のピアの数を制御し、ノードがピアとして参加する前に、最小のアプリケーションの稼働時間を確保含むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ultimate criteria for a node to become a peer are determined by the overlay algorithm and specific deployment. A node acting as a client that has a full implementation of RELOAD and the appropriate overlay algorithm is capable of locating its responsible peer in the overlay and using Attach to establish a direct connection to that peer. In that way, it may elect to be reachable under either of the routing approaches listed above. Particularly for overlay algorithms that elect nodes to serve as peers based on trustworthiness or population, the overlay algorithm may require such a client to locate itself at a particular place in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアになるノードのための究極の基準は、オーバーレイアルゴリズムと特定の展開によって決定されます。リロードの完全な実装を持ち、適切なオーバーレイアルゴリズムがオーバーレイでその責任ピアの位置を特定し、そのピアへの直接接続を確立するために取り付け使用することができるクライアントとして動作するノード。そのようにして、上記ルーティングアプローチのいずれかの下に到達することを選択することができます。特に信頼性や人口に基づいてピアとして機能するノードを選出オーバーレイアルゴリズムのために、オーバーレイ・アルゴリズムは、オーバーレイ内の特定の場所で自分自身を見つけるために、このようなクライアントが必要な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.2. Clients as Application-Level Agents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.2。アプリケーションレベルのエージェントとしてのクライアント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SIP defines an extensive protocol for registration and security between a client and its registrar/proxy server(s). Any SIP device can act as a client of a RELOAD-based P2PSIP overlay if it contacts a peer that implements the server-side functionality required by the SIP protocol. In this case, the peer would be acting as if it were the user&#39;s peer and would need the appropriate credentials for that user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SIPは、クライアントとそのレジストラ/プロキシサーバー（複数可）との間の登録及びセキュリティのための広範なプロトコルを定義します。接触SIPプロトコルによって必要とされるサーバ側の機能を実装した場合、ピア任意のSIPデバイスリロードベースP2PSIPオーバーレイのクライアントとして動作することができます。この場合、ピアは、それがユーザーのピアであるかのように働くことになると、そのユーザーの適切な資格情報が必要になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application-level support for clients is defined by a usage. A usage offering support for application-level clients should specify how the security of the system is maintained when the data is moved between the application and RELOAD layers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントのためのアプリケーションレベルのサポートは、使用によって定義されます。アプリケーションレベルのクライアントのためのサポートを提供する使用は、データがアプリケーションとリロード層との間を移動する際に、システムのセキュリティが維持される方法を指定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cullen Jennings Cisco 400 3rd Avenue SW, Suite 350 Calgary Canada
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カレン・ジェニングスのCisco 400第三アベニューSW、スイート350カナダカルガリー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: fluffy@cisco.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：fluffy@cisco.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bruce B. Lowekamp (editor) Skype Palo Alto, CA USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブルースB. Lowekamp（エディタ）スカイプパロアルト、CA USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: bbl@lowekamp.net
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：bbl@lowekamp.net
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eric Rescorla RTFM, Inc. 2064 Edgewood Drive Palo Alto, CA 94303 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エリックレスコラRTFM、Inc.の2064エッジウッドドライブパロアルト、CA 94303 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 650 678 2350 EMail: ekr@rtfm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 650 678 2350 Eメール：ekr@rtfm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Salman A. Baset Columbia University 1214 Amsterdam Avenue New York, NY USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サルマンA. BASETコロンビア大学1214アムステルダムアベニューニューヨーク、NY USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: salman@cs.columbia.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：salman@cs.columbia.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Henning Schulzrinne Columbia University 1214 Amsterdam Avenue New York, NY USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘニングSchulzrinneとコロンビア大学1214アムステルダムアベニューニューヨーク、NY USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: hgs@cs.columbia.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：hgs@cs.columbia.edu
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
