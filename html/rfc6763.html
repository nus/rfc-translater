<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 6763 - DNS-Based Service Discovery 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6763 - DNS-Based Service Discovery 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc6763">
              https://tools.ietf.org/html/rfc6763
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6763 - DNSベースのサービス発見</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                       S. Cheshire
Request for Comments: 6763                                   M. Krochmal
Category: Standards Track                                     Apple Inc.
ISSN: 2070-1721                                            February 2013
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      DNS-Based Service Discovery
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies how DNS resource records are named and structured to facilitate service discovery. Given a type of service that a client is looking for, and a domain in which the client is looking for that service, this mechanism allows clients to discover a list of named instances of that desired service, using standard DNS queries. This mechanism is referred to as DNS-based Service Discovery, or DNS-SD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、DNSリソースレコードの名前やサービスの発見を容易にするために、どのように構成されるかを指定します。クライアントが探しているサービスの種類、およびクライアントがそのサービスを探してされているドメインを考えると、このメカニズムは、標準のDNSクエリを使用して、クライアントがその希望するサービスの名前付きインスタンスのリストを発見することができます。この機構は、DNSベースのサービスディスカバリ、またはDNS-SDと呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6763.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6763で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................3
   2. Conventions and Terminology Used in This Document ...............5
   3. Design Goals ....................................................5
   4. Service Instance Enumeration (Browsing) .........................6
      4.1. Structured Service Instance Names ..........................6
      4.2. User Interface Presentation ................................9
      4.3. Internal Handling of Names .................................9
   5. Service Instance Resolution ....................................10
   6. Data Syntax for DNS-SD TXT Records .............................11
      6.1. General Format Rules for DNS TXT Records ..................11
      6.2. DNS-SD TXT Record Size ....................................12
      6.3. DNS TXT Record Format Rules for Use in DNS-SD .............13
      6.4. Rules for Keys in DNS-SD Key/Value Pairs ..................14
      6.5. Rules for Values in DNS-SD Key/Value Pairs ................16
      6.6. Example TXT Record ........................................17
      6.7. Version Tag ...............................................17
      6.8. Service Instances with Multiple TXT Records ...............18
   7. Service Names ..................................................19
      7.1. Selective Instance Enumeration (Subtypes) .................21
      7.2. Service Name Length Limits ................................23
   8. Flagship Naming ................................................25
   9. Service Type Enumeration .......................................27
   10. Populating the DNS with Information ...........................27
   11. Discovery of Browsing and Registration Domains (Domain
       Enumeration) ..................................................28
   12. DNS Additional Record Generation ..............................30
      12.1. PTR Records ..............................................30
      12.2. SRV Records ..............................................30
      12.3. TXT Records ..............................................31
      12.4. Other Record Types .......................................31
   13. Working Examples ..............................................31
      13.1. What web pages are being advertised from dns-sd.org? .....31
      13.2. What printer-configuration web pages are there? ..........31
      13.3. How do I access the web page called &#34;Service
            Discovery&#34;? ..............................................32
   14. IPv6 Considerations ...........................................32
   15. Security Considerations .......................................32
   16. IANA Considerations ...........................................32
   17. Acknowledgments ...............................................33
   18. References ....................................................33
      18.1. Normative References .....................................33
      18.2. Informative References ...................................34
   Appendix A. Rationale for Using DNS as a Basis for Service
               Discovery .............................................37
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Appendix B. Ordering of Service Instance Name Components ..........38
      B.1. Semantic Structure ........................................38
      B.2. Network Efficiency ........................................39
      B.3. Operational Flexibility ...................................39
   Appendix C. What You See Is What You Get ..........................40
   Appendix D. Choice of Factory-Default Names .......................42
   Appendix E. Name Encodings in the Domain Name System ..............44
   Appendix F. &#34;Continuous Live Update&#34; Browsing Model ...............45
   Appendix G. Deployment History ....................................47
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies how DNS resource records are named and structured to facilitate service discovery. Given a type of service that a client is looking for, and a domain in which the client is looking for that service, this mechanism allows clients to discover a list of named instances of that desired service, using standard DNS queries. This mechanism is referred to as DNS-based Service Discovery, or DNS-SD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、DNSリソースレコードの名前やサービスの発見を容易にするために、どのように構成されるかを指定します。クライアントが探しているサービスの種類、およびクライアントがそのサービスを探してされているドメインを考えると、このメカニズムは、標準のDNSクエリを使用して、クライアントがその希望するサービスの名前付きインスタンスのリストを発見することができます。この機構は、DNSベースのサービスディスカバリ、またはDNS-SDと呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document proposes no change to the structure of DNS messages, and no new operation codes, response codes, resource record types, or any other new DNS protocol values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、DNSメッセージの構造への変更、および新しい操作コード、応答コード、リソースレコードタイプ、または任意の他の新しいDNSプロトコル値を提案していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies that a particular service instance can be described using a DNS SRV [RFC2782] and DNS TXT [RFC1035] record. The SRV record has a name of the form &#34;&lt;Instance&gt;.&lt;Service&gt;.&lt;Domain&gt;&#34; and gives the target host and port where the service instance can be reached. The DNS TXT record of the same name gives additional information about this instance, in a structured form using key/value pairs, described in Section 6. A client discovers the list of available instances of a given service type using a query for a DNS PTR [RFC1035] record with a name of the form &#34;&lt;Service&gt;.&lt;Domain&gt;&#34;, which returns a set of zero or more names, which are the names of the aforementioned DNS SRV/TXT record pairs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、特定のサービスインスタンスがDNS SRV [RFC2782]とDNS TXT [RFC1035]レコードを使用して記述することができることを指定します。 SRVレコードは、「&lt;サービス&gt;。&lt;ドメイン&gt;。&lt;インスタンス&gt;」の形式の名前を持ち、サービスインスタンスが到達できるターゲットホストとポートを提供します。同じ名前のDNS TXTレコードは、クライアントがDNSのPTRのクエリを使用して、指定されたサービスタイプの使用可能なインスタンスのリストを発見第6節で説明した、キー/値のペアを使用して構造化された形式で、このインスタンスに関する追加情報を提供します[RFC1035]の形式の名前を持つレコード「&lt;サービス&gt;。&lt;ドメイン&gt;」、前述のDNS SRV / TXTレコードペアの名前でゼロ以上の名前のセットを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification is compatible with both Multicast DNS [RFC6762] and with today&#39;s existing Unicast DNS server and client software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様は、マルチキャストDNS [RFC6762]今日の既存のユニキャストDNSサーバとクライアントソフトウェアの両方と互換性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When used with Multicast DNS, DNS-SD can provide zero-configuration operation -- just connect a DNS-SD/mDNS device, and its services are advertised on the local link with no further user interaction [ZC].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSと共に使用される場合、DNS-SDは、ゼロコンフィギュレーション動作を提供することができる - ちょうどDNS-SD /のmDNSデバイスを接続し、そのサービスがない、さらなるユーザ対話[ZC]とローカルリンク上でアドバタイズされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When used with conventional Unicast DNS, some configuration will usually be required -- such as configuring the device with the DNS domain(s) in which it should advertise its services, and configuring it with the DNS Update [RFC2136] [RFC3007] keys to give it permission to do so. In rare cases, such as a secure corporate network behind a firewall where no DNS Update keys are required, zero-configuration operation may be achieved by simply having the device register its services in a default registration domain learned from the network (see Section 11, &#34;Discovery of Browsing and Registration Domains&#34;), but this is the exception and usually security credentials will be required to perform DNS updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このように[RFC3007]キーを、そのサービスを広告するべきDNSドメイン（単数または複数）とデバイスを構成し、DNSアップデート[RFC2136]とそれを構成するよう - 従来のユニキャストDNSで使用される場合、いくつかの設定は、通常必要とされますそれをそうする許可を与えます。このようなしDNSの更新キーは必要ありませんファイアウォールの背後にあるセキュアな企業ネットワークとしてまれでは、ゼロコンフィギュレーション操作が単純にデバイスがネットワークから学んだデフォルトの登録ドメインにそのサービスを登録することによって達成することができる（セクション11を参照してください「閲覧の発見と登録ドメイン」）が、これは例外であり、通常はセキュリティ証明書には、DNS更新を実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that when using DNS-SD with Unicast DNS, the Unicast DNS-SD service does NOT have to be provided by the same DNS server hardware that is currently providing an organization&#39;s conventional host name lookup service. While many people think of &#34;DNS&#34; exclusively in the context of mapping host names to IP addresses, in fact, &#34;the DNS is a general (if somewhat limited) hierarchical database, and can store almost any kind of data, for almost any purpose&#34; [RFC2181]. By delegating the &#34;_tcp&#34; and &#34;_udp&#34; subdomains, all the workload related to DNS-SD can be offloaded to a different machine. This flexibility, to handle DNS-SD on the main DNS server or not, at the network administrator&#39;s discretion, is one of the benefits of using DNS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユニキャストDNSでDNS-SDを使用した場合、ユニキャストDNS-SDサービスは、現在、組織の従来のホスト名の検索サービスを提供している、同じDNSサーバのハードウェアによって提供されている必要はないことに注意してください。多くの人が独占的にIPアドレスへのマッピングホスト名の文脈で「DNS」を考えながら、実際には、「DNSは、一般的な（多少制限されている場合）、階層型データベースで、ほぼすべての目的のために、ほとんどあらゆる種類のデータを格納することができます&#34;[RFC2181]。 「_tcp」と「_udp」サブドメインを委任することにより、DNS-SDに関連するすべてのワークロードは、別のマシンにオフロードすることができます。この柔軟性は、メインのDNSサーバー上のDNS-SDを処理するかどうか、ネットワーク管理者の裁量で、DNSを使用しての利点の1つです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Even when the DNS-SD functions are delegated to a different machine, the benefits of using DNS remain: it is mature technology, well understood, with multiple independent implementations from different vendors, a wide selection of books published on the subject, and an established workforce experienced in its operation. In contrast, adopting some other service discovery technology would require every site in the world to install, learn, configure, operate, and maintain some entirely new and unfamiliar server software. Faced with these obstacles, it seems unlikely that any other service discovery technology could hope to compete with the ubiquitous deployment that DNS already enjoys. For further discussion, see Appendix A, &#34;Rationale for Using DNS as a Basis for Service Discovery&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
、異なるベンダーの複数の独立した実装と、それがよく理解、成熟した技術である被写体に出版された書籍の幅広い選択、および確立された：DNS-SDの機能を別のマシンに委任されている場合でも、DNSを使用する利点は残ります従業員は、その動作中に経験しました。これとは対照的に、他のいくつかのサービス発見技術を採用して、インストールを学び、設定、運用、およびいくつかの全く新しい、不慣れなサーバソフトウェアを維持するために、世界のすべてのサイトを必要とします。これらの障害に直面し、他のサービス発見技術は、DNSがすでに楽しんでユビキタスな展開と競争することを望むことができるとは考えにくいです。さらなる議論については、付録A、「サービス発見のための基礎としてDNSを使用するための理論的根拠」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is written for two audiences: for developers creating application software that offers or accesses services on the network, and for developers creating DNS-SD libraries to implement the advertising and discovery mechanisms. For both audiences, understanding the entire document is helpful. For developers creating application software, this document provides guidance on choosing instance names, service names, and other aspects that play a role in creating a good overall user experience. However, also understanding the underlying DNS mechanisms used to provide the service discovery facilities helps application developers understand the capabilities and limitations of those underlying mechanisms (e.g., name length limits). For library developers writing software to construct the DNS records (to advertise a service) and generate the DNS queries (to discover and use a service), understanding the ultimate user-experience goals helps them provide APIs that can meet those goals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、二つの観客のために書かれている：提供していますか、ネットワーク上のサービスにアクセスし、広告や発見メカニズムを実装するためにDNS-SDライブラリを作成する開発者のためのアプリケーションソフトウェアを作成する開発者のため。両方の観客のために、文書全体を理解することは有用です。アプリケーション・ソフトウェアを作成する開発者は、この文書には、インスタンス名、サービス名、および優れた全体的なユーザーエクスペリエンスを作成する上で役割を果たしている他の側面を選択するためのガイダンスを提供します。しかし、また、サービス・ディスカバリ機能を提供するために使用する基本的なDNSの仕組みを理解することは、アプリケーション開発者は、これらの基礎となるメカニズム（例えば、名前の長さ制限）の能力と限界を理解するのに役立ちます。 （サービスを宣伝するために）DNSレコードを構築し、DNSクエリを生成するためのソフトウェアを書いてライブラリの開発者（サービスを発見し、使用する）のために、究極のユーザー・エクスペリエンスの目標を理解することは、彼らがそれらの目標を達成できるAPIを提供するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Conventions and Terminology Used in This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
この文書で使用される2.表記と用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in &#34;Key words for use in RFCs to Indicate Requirement Levels&#34; [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はあります「要求レベルを示すためのRFCsにおける使用のためのキーワード」[RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Design Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.設計目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Of the many properties a good service discovery protocol needs to have, three of particular importance are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
良いサービス発見プロトコルを持っている必要があります多くのプロパティのうち、特に重要な3は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(i) The ability to query for services of a certain type in a certain logical domain, and receive in response a list of named instances (network browsing or &#34;Service Instance Enumeration&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（I）という名前のインスタンス（ネットワークブラウジングや「サービスインスタンス列挙」）のリストを特定の論理ドメインで特定のタイプのサービスを照会し、それに応答して受信する機能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(ii) Given a particular named instance, the ability to efficiently resolve that instance name to the required information a client needs to actually use the service, i.e., IP address and port number, at the very least (Service Instance Resolution).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（ⅱ）特定の名前付きインスタンス、効率的にクライアントが実際にサービスを使用する必要がある、すなわち、IPアドレスとポート番号、非常に少なくとも、（サービスインスタンス解像度）、必要な情報に、そのインスタンス名を解決する能力を与えられました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(iii) Instance names should be relatively persistent. If a user selects their default printer from a list of available choices today, then tomorrow they should still be able to print on that printer -- even if the IP address and/or port number where the service resides have changed -- without the user (or their software) having to repeat the step (i) (the initial network browsing) a second time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（ⅲ）インスタンス名は、比較的永続的でなければなりません。たとえIPアドレスおよび/またはサービスの存在が変更されているポート番号を -   - ユーザーせずに、ユーザが利用可能な選択肢のリスト今日から、デフォルトのプリンタを選択した場合、その後、明日彼らはまだそのプリンタで印刷することができるはずです（またはそのソフトウェア）工程（i）（初期ネットワークブラウジング）は、第2の時間を繰り返すこと。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, if it is to become successful, a service discovery protocol should be so simple to implement that virtually any device capable of implementing IP should not have any trouble implementing the service discovery software as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それが成功になるのであればまた、サービス発見プロトコルは、IPを実装することが可能な任意のデバイスは、任意のトラブルにもサービス発見ソフトウェアを実装してはならないという事実を実装するために非常にシンプルでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These goals are discussed in more detail in the remainder of this document. A more thorough treatment of service discovery requirements may be found in &#34;Requirements for a Protocol to Replace the AppleTalk Name Binding Protocol (NBP)&#34; [RFC6760]. That document draws upon examples from two decades of operational experience with AppleTalk to develop a list of universal requirements that are broadly applicable to any potential service discovery protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの目標は、この文書の残りの部分でより詳細に議論されています。サービス発見の要件のより完全な治療は、[RFC6760]「プロトコル（NBP）に結合AppleTalkの名前を交換するためのプロトコルのための要件」に見出すことができます。その文書には、任意の潜在的なサービス発見プロトコルに広く適用されている普遍的な要件のリストを開発するためのAppleTalkと運用経験の二十年からの例に描画します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Service Instance Enumeration (Browsing)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.サービスインスタンス列挙（閲覧）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Traditional DNS SRV records [RFC2782] are useful for locating instances of a particular type of service when all the instances are effectively indistinguishable and provide the same service to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
伝統的なDNS SRVレコード[RFC2782]は、すべてのインスタンスが有効に区別できない、クライアントに同じサービスを提供する場合、サービスの特定の型のインスタンスを配置するのに有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, SRV records with the (hypothetical) name &#34;_http._tcp.example.com.&#34; would allow a client to discover servers implementing the &#34;_http._tcp&#34; service (i.e., web servers) for the &#34;example.com.&#34; domain. The unstated assumption is that all these servers offer an identical set of web pages, and it doesn&#39;t matter to the client which of the servers it uses, as long as it selects one at random according to the weight and priority rules laid out in the DNS SRV specification [RFC2782].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、（架空の）名前を持つSRVレコード「_http._tcp.example.com。」クライアントが「example.com。」のための「_http._tcp」サービス（すなわち、Webサーバ）を実装したサーバを発見できるようになりますドメイン。暗黙の仮定は、すべてのこれらのサーバーは、Webページの同じセットを提供することであり、それは、それがにレイアウト重みと優先順位のルールに従ってランダムに一つを選択して、それが使用するサーバのクライアントには関係ありません。 DNSのSRV仕様[RFC2782]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Instances of other kinds of service are less easily interchangeable. If a word processing application were to look up the (hypothetical) SRV record &#34;_ipp._tcp.example.com.&#34; to find the list of Internet Printing Protocol (IPP) [RFC2910] printers at Example Co., then picking one at random and printing on it would probably not be what the user wanted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスの他の種類のインスタンスはそれほど簡単に交換可能です。ワードプロセッシングアプリケーションは、（仮想）SRVレコードルックアップするためにした場合は、「_ipp._tcp.example.comを。」インターネット印刷プロトコル（IPP）[RFC2910]例（株）でのプリンタ、そしておそらくユーザーが望んではないでしょうその上にランダムと印刷時のものを選ぶのリストを検索します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The remainder of this section describes how SRV records may be used in a slightly different way, to allow a user to discover the names of all available instances of a given type of service, and then select, from that list, the particular instance they desire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションの残りの部分は、SRVレコードがそのリスト、彼らが望む特定のインスタンスから、サービスの所与のタイプのすべての利用可能なインスタンスの名前を発見し、選択することをユーザに可能にするために、わずかに異なる方法で使用することができる方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Structured Service Instance Names
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。構造化されたサービスインスタンス名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document borrows the logical service-naming syntax and semantics from DNS SRV records, but adds one level of indirection. Instead of requesting records of type &#34;SRV&#34; with name &#34;_ipp._tcp.example.com.&#34;, the client requests records of type &#34;PTR&#34; (pointer from one name to another in the DNS namespace) [RFC1035].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、DNS SRVレコードからの論理サービス命名構文と意味を借りたが、間接のいずれかのレベルが追加されます。代わりに、名前とタイプ「SRV」のレコードを要求するの「_ipp._tcp.example.comは。」、クライアントが「PTR」（1名からDNS名前空間内の別のポインタ）[RFC1035]タイプのレコードを要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In effect, if one thinks of the domain name &#34;_ipp._tcp.example.com.&#34; as being analogous to an absolute path to a directory in a file system, then DNS-SD&#39;s PTR lookup is akin to performing a listing of that directory to find all the entries it contains. (Remember that domain names are expressed in reverse order compared to path names -- an absolute path name starts with the root on the left and is read from left to right, whereas a fully qualified domain name starts with the root on the right and is read from right to left. If the fully qualified domain name &#34;_ipp._tcp.example.com.&#34; were expressed as a file system path name, it would be &#34;/com/example/_tcp/_ipp&#34;.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実際には、1ドメイン名を考えるならば、「_ipp._tcp.example.com。」ファイルシステムのディレクトリへの絶対パスに類似していると、その後、DNS-SDのPTRルックアップは、それに含まれるすべてのエントリを検索し、そのディレクトリのリストを実行するのに似ています。 （名前はパス名と比較して逆の順序で発現されるドメインを覚えている - 絶対パス名は、左のルートから始まり、左から右に読まれる、完全修飾ドメイン名が右側ルートから始まり、であるのに対し右から左に読む。完全修飾ドメイン名「_ipp._tcp.example.comが。」ファイルシステムのパス名として表現された場合、それは「/ COM /例/ _tcp / _ipp」になります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The result of this PTR lookup for the name &#34;&lt;Service&gt;.&lt;Domain&gt;&#34; is a set of zero or more PTR records giving Service Instance Names of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「&lt;サービス&gt; &lt;ドメイン&gt;」名前のためにこのPTR検索の結果は、フォームのサービスインスタンス名を与え、ゼロ以上のPTRレコードのセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Service Instance Name = &lt;Instance&gt; . &lt;Service&gt; . &lt;Domain&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス名= &lt;インスタンス&gt;。 &lt;サービス&gt;。 &lt;ドメイン&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For explanation of why the components are in this order, see Appendix B, &#34;Ordering of Service Instance Name Components&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンポーネントは、この順序になっている理由については、付録B、「サービスインスタンス名のコンポーネントの順序」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Instance Names
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1。インスタンス名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &lt;Instance&gt; portion of the Service Instance Name is a user-friendly name consisting of arbitrary Net-Unicode text [RFC5198]. It MUST NOT contain ASCII control characters (byte values 0x00-0x1F and 0x7F) [RFC20] but otherwise is allowed to contain any characters, without restriction, including spaces, uppercase, lowercase, punctuation -- including dots -- accented characters, non-Roman text, and anything else that may be represented using Net-Unicode. For discussion of why the &lt;Instance&gt; name should be a user-visible, user-friendly name rather than an invisible machine-generated opaque identifier, see Appendix C, &#34;What You See Is What You Get&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス名の&lt;インスタンス&gt;部分は、任意のネットユニコードテキスト[RFC5198]からなるユーザーフレンドリーな名前です。非アクセント付き文字、 - ドットを含む - それは、スペース、大文字、小文字、句読点を含め、制限なく、ASCII制御文字（バイト値0x00-0x1F及び0x7Fの）[RFC20]を含めることはできませんが、それ以外の任意の文字を含むように許可されていますローマのテキスト、およびネットUnicodeを使って表現することができる何か他のもの。 &lt;インスタンス&gt;の名前は、付録Cを参照してください、ユーザに見える、ユーザーフレンドリーな名前ではなく、目に見えない機械生成の不透明な識別子であるべき理由の説明については、「あなたは何を参照してくださいあなたが得るものです」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &lt;Instance&gt; portion of the name of a service being offered on the network SHOULD be configurable by the user setting up the service, so that he or she may give it an informative name. However, the device or service SHOULD NOT require the user to configure a name before it can be used. A sensible choice of default name can in many cases allow the device or service to be accessed without any manual configuration at all. The default name should be short and descriptive, and SHOULD NOT include the device&#39;s Media Access Control (MAC) address, serial number, or any similar incomprehensible hexadecimal string in an attempt to make the name globally unique. For discussion of why &lt;Instance&gt; names don&#39;t need to be (and SHOULD NOT be) made unique at the factory, see Appendix D, &#34;Choice of Factory-Default Names&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼または彼女はそれを有益な名前を与えることができるように、ネットワーク上で提供されるサービスの名前の&lt;インスタンス&gt;の部分は、サービスを設定し、ユーザが設定可能であるべきです。ただし、デバイスまたはサービスは、それを使用する前に名前を設定するには、ユーザを必要とすべきではありません。デフォルトの名前の賢明な選択は、多くの場合、デバイスまたはサービスは、まったくの手動設定なしでアクセスすることができるようにすることができます。デフォルトの名前は短く、説明的であるべきであり、デバイスのメディアアクセス制御（MAC）アドレス、シリアル番号、または名前をグローバルに一意にするための試みで、任意の同様の不可解な16進数の文字列を含むべきではありません。なぜ&lt;インスタンス&gt;の名前の議論についてである必要はありません（とすべきではありません）付録D、「工場出荷時のデフォルト名の選択」を参照してください、工場で固有のもの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This &lt;Instance&gt; portion of the Service Instance Name is stored directly in the DNS as a single DNS label of canonical precomposed UTF-8 [RFC3629] &#34;Net-Unicode&#34; (Unicode Normalization Form C) [RFC5198] text. For further discussion of text encodings, see Appendix E, &#34;Name Encodings in the Domain Name System&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス名のこの&lt;インスタンス&gt;部分は、正規合成済みUTF-8 [RFC3629]「ネットユニコード」（Unicodeの正規化形式C）[RFC5198]テキストの単一DNSラベルとしてDNSに直接格納されています。テキストエンコーディングのさらなる議論については、付録E、「ドメインネームシステム名エンコーディング」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS labels are currently limited to 63 octets in length. UTF-8 encoding can require up to four octets per Unicode character, which means that in the worst case, the &lt;Instance&gt; portion of a name could be limited to fifteen Unicode characters. However, the Unicode characters with longer octet lengths under UTF-8 encoding tend to be the more rarely used ones, and tend to be the ones that convey greater meaning per character.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNSラベルは現在、長さが63個のオクテットに制限されています。 UTF-8エンコーディングは、最悪の場合には、名前の&lt;インスタンス&gt;の部分は、15個のUnicode文字に制限することができることを意味し、Unicode文字ごとに最大4つのオクテットを必要とすることができます。ただし、UTF-8エンコーディングの下の長いオクテット長のUnicode文字がまれに使用されるものになる傾向があり、そして文字ごとに大きな意味を伝えるものになる傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that any character in the commonly used 16-bit Unicode Basic Multilingual Plane [Unicode6] can be encoded with no more than three octets of UTF-8 encoding. This means that an instance name can contain up to 21 Kanji characters, which is a sufficiently expressive name for most purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的に使用される16ビットの任意の文字がUnicode基本多言語面[Unicode6] UTF-8エンコーディングの3つ以下のオクテットで符号化することができることに留意されたいです。これは、インスタンス名は、ほとんどの目的のために十分に表現力豊かな名前である21の漢字、まで含むことができることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Service Names
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2。サービス名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &lt;Service&gt; portion of the Service Instance Name consists of a pair of DNS labels, following the convention already established for SRV records [RFC2782]. The first label of the pair is an underscore character followed by the Service Name [RFC6335]. The Service Name identifies what the service does and what application protocol it uses to do it. The second label is either &#34;_tcp&#34; (for application protocols that run over TCP) or &#34;_udp&#34; (for all others). For more details, see Section 7, &#34;Service Names&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス名の&lt;サービス&gt;の部分は、すでにSRVレコード[RFC2782]のために設立条約以下、DNSラベルのペアで構成されています。ペアの最初のラベルは、サービス名[RFC6335]に続いてアンダースコア文字です。サービス名は、サービスが何を識別し、それはそれを行うために使用するもののアプリケーションプロトコル。第二の標識は、（TCP上で実行するアプリケーションプロトコルのための）「_tcp」または（他のすべてのための）「_udp」のいずれかです。詳細については、第7節、「サービス名」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3. Domain Names
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3。ドメイン名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &lt;Domain&gt; portion of the Service Instance Name specifies the DNS subdomain within which those names are registered. It may be &#34;local.&#34;, meaning &#34;link-local Multicast DNS&#34; [RFC6762], or it may be a conventional Unicast DNS domain name, such as &#34;ietf.org.&#34;, &#34;cs.stanford.edu.&#34;, or &#34;eng.us.ibm.com.&#34; Because Service Instance Names are not host names, they are not constrained by the usual rules for host names [RFC1033] [RFC1034] [RFC1035], and rich-text service subdomains are allowed and encouraged, for example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス名の&lt;ドメイン&gt;の部分は、それらの名前が登録されている範囲内のDNSサブドメインを指定します。それは、「リンクローカルマルチキャストDNS」[RFC6762]を意味し、「ローカル」であってもよいし、またはそれのような、従来のユニキャストDNSドメイン名であり、「ietf.org。」、「cs.stanford.edu。」、または&#34;eng.us.ibm.com。&#34;サービスインスタンス名をホスト名されていないので、それらは例えば、許可および奨励されているホスト名[RFC1033] [RFC1034] [RFC1035]、およびリッチテキストサービスサブドメインのための通常の規則によって制約されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Building 2, 1st Floor . example . com . Building 2, 2nd Floor . example . com . Building 2, 3rd Floor . example . com . Building 2, 4th Floor . example . com .
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2、1階を構築します。例。コム。 2、2階を構築します。例。コム。ビル2、3階。例。コム。 2、4階を構築します。例。コム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, because Service Instance Names are not constrained by the limitations of host names, this document recommends that they be stored in the DNS, and communicated over the wire, encoded as straightforward canonical precomposed UTF-8 [RFC3629] &#34;Net-Unicode&#34; (Unicode Normalization Form C) [RFC5198] text. In cases where the DNS server returns a negative response for the name in question, client software MAY choose to retry the query using the &#34;Punycode&#34; algorithm [RFC3492] to convert the UTF-8 name to an IDNA &#34;A-label&#34; [RFC5890], beginning with the top-level label, then issuing the query
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス名がホスト名の制限によって制約されないので、また、この文書は、彼らが簡単正規合成済みUTF-8 [RFC3629]「ネットユニコード」としてエンコード、DNSに格納され、ワイヤを介して通信することをお勧めします（Unicodeの正規化形式C）[RFC5198]のテキスト。 DNSサーバーが問題の名前のための否定応答を返す場合には、クライアント・ソフトウェアは、[RFC5890をIDNA「A-ラベル」にUTF-8名を変換するために、「ピュニコード」アルゴリズム[RFC3492]を使用してクエリを再試行することを選択するかもしれません]、その後、クエリを発行し、トップレベルのラベルで始まります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
repeatedly, with successively more labels translated to IDNA A-labels each time, and giving up if it has converted all labels to IDNA A-labels and the query still fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
繰り返し、連続的に複数のラベルをIDNA A-ラベルにそれぞれの時間を翻訳し、それがIDNA A-ラベルにすべてのラベルを変換し、クエリがまだ失敗した場合にあきらめ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. User Interface Presentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。ユーザインタフェースプレゼンテーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The names resulting from the Service Instance Enumeration PTR lookup are presented to the user in a list for the user to select one (or more). Typically, only the first label is shown (the user-friendly &lt;Instance&gt; portion of the name).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス列挙PTRルックアップの結果の名前を1つ（または複数）を選択したユーザーのリストでユーザーに提示されています。典型的には、最初のラベル（名前のユーザーフレンドリー&lt;インスタンス&gt;部分）が示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the common case the &lt;Service&gt; and &lt;Domain&gt; are already known to the client software, these having been provided implicitly by the user in the first place, by the act of indicating the service being sought, and the domain in which to look for it. Note that the software handling the response should be careful not to make invalid assumptions though, since it *is* possible, though rare, for a service enumeration in one domain to return the names of services in a different domain. Similarly, when using subtypes (see Section 7.1, &#34;Selective Instance Enumeration&#34;) the &lt;Service&gt; of the discovered instance may not be exactly the same as the &lt;Service&gt; that was requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的なケース&lt;サービス&gt;にし、&lt;ドメイン&gt;はすでにクライアントソフトウェアに知られている、これらは、求められているサービスを示す行為、そして見にドメインによって、最初の場所で、ユーザによって暗黙的に提供されていましたそれのための。それは*異なるドメインにサービスの名前を返すために一つのドメインでのサービス列挙のために、しかしまれ、*可能であるため、応答を処理するソフトウェアは、しかし、無効な仮定をしないように注意しなければならないことに注意してください。サブタイプを使用する場合も同様に、（セクション7.1を参照してください、「選択インスタンスの列挙」）を発見し、インスタンスの&lt;サービス&gt;は、要求された&lt;サービス&gt;とまったく同じではないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For further discussion of Service Instance Enumeration (browsing) user-interface considerations, see Appendix F, &#34;&#39;Continuous Live Update&#39; Browsing Model&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス列挙（ブラウジング）ユーザインタフェースの考慮事項の更なる議論については、付録F、「「連続してライブアップデート[閲覧のモデル」を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once the user has selected the desired named instance, the Service Instance Name may then be used immediately, or saved away in some persistent user-preference data structure for future use, depending on what is appropriate for the application in question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザが所望の名前付きインスタンスを選択すると、サービスインスタンス名は、問題のアプリケーションに適しているものに応じて、将来の使用のためにすぐに使用する、またはいくつかの永続的なユーザー・プリファレンスデータ構造に離れて保存することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Internal Handling of Names
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。名前の内部処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If client software takes the &lt;Instance&gt;, &lt;Service&gt;, and &lt;Domain&gt; portions of a Service Instance Name and internally concatenates them together into a single string, then because the &lt;Instance&gt; portion is allowed to contain any characters, including dots, appropriate precautions MUST be taken to ensure that DNS label boundaries are properly preserved. Client software can do this in a variety of ways, such as character escaping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントソフトウェアは、&lt;サービス&gt;、&lt;インスタンス&gt;をとり、サービスインスタンス名の&lt;ドメイン&gt;部分と、内部で単一の文字列に一緒にそれらを連結した場合は、&lt;インスタンス&gt;の部分は、ドットを含む任意の文字を含むことが許されているので、適切な予防措置は、DNSラベルの境界が適切に保存されているように注意する必要があります。クライアントソフトウェアは、このような文字のエスケープなど、さまざまな方法でこれを行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document RECOMMENDS that if concatenating the three portions of a Service Instance Name, any dots in the &lt;Instance&gt; portion be escaped following the customary DNS convention for text files: by preceding literal dots with a backslash (so &#34;.&#34; becomes &#34;\.&#34;). Likewise, any backslashes in the &lt;Instance&gt; portion should also be escaped by preceding them with a backslash (so &#34;\&#34; becomes &#34;\\&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、サービスインスタンス名の3つの部分を連結する場合は、&lt;インスタンス&gt;の部分にドットがテキストファイルの慣習DNS規則以下のエスケープすることをお勧めします：「」そう（バックスラッシュとリテラルのドットを先行することによって、\「となります。 「）。同様に、&lt;インスタンス&gt;の部分でのバックスラッシュは、（「\」「\\」になりそう）、バックスラッシュを前に付けてエスケープする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Having done this, the three components of the name may be safely concatenated. The backslash-escaping allows literal dots in the name (escaped) to be distinguished from label-separator dots (not escaped), and the resulting concatenated string may be safely passed to standard DNS APIs like res_query(), which will interpret the backslash-escaped string as intended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これを行った、名前の3つの成分が安全に連結することができます。バックスラッシュエスケープはbackslash-を解釈する名前にリテラルドット（エスケープされません）ラベルセパレータードットと区別するために（エスケープ）、そして得られた連結した文字列を安全にres_query（のような標準のDNSのAPIに渡すことができる）、ことができます意図したとおりに文字列をエスケープ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Service Instance Resolution
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.サービスインスタンス決議
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client needs to contact a particular service, identified by a Service Instance Name, previously discovered via Service Instance Enumeration (browsing), it queries for the SRV and TXT records of that name. The SRV record for a service gives the port number and target host name where the service may be found. The TXT record gives additional information about the service, as described in Section 6, &#34;Data Syntax for DNS-SD TXT Records&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが以前にサービスインスタンスの列挙（ブラウジング）を経由して発見されたサービスインスタンス名で識別される特定のサービスを、連絡する必要がある場合、その名前のSRVとTXTレコードを照会します。サービスのSRVレコードは、サービスを見つけることができるポート番号とターゲットホスト名を与えます。第6章、「DNS-SD TXTレコードのデータの構文」で説明したようにTXTレコードは、サービスに関する追加情報を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SRV records are extremely useful because they remove the need for preassigned port numbers. There are only 65535 TCP port numbers available. These port numbers are traditionally allocated one per application protocol [RFC6335]. Some protocols like the X Window System have a block of 64 TCP ports allocated (6000-6063). Using a different TCP port for each different instance of a given service on a given machine is entirely sensible, but allocating each application its own large static range, as was done for the X Window System, is not a practical way to do that. On any given host, most TCP ports are reserved for services that will never run on that particular host in its lifetime. This is very poor utilization of the limited port space. Using SRV records allows each host to allocate its available port numbers dynamically to those services actually running on that host that need them, and then advertise the allocated port numbers via SRV records. Allocating the available listening port numbers locally on a per-host basis as needed allows much better utilization of the available port space than today&#39;s centralized global allocation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らは事前に割り当てられたポート番号の必要性を取り除くため、SRVレコードは非常に便利です。利用可能な唯一の65535 TCPポート番号があります。これらのポート番号は、伝統的に、アプリケーションプロトコル[RFC6335]に1つずつ割り当てられます。 Xウィンドウシステムのようないくつかのプロトコルは、割り当てられた64個のTCPポート（6000から6063）のブロックを有しています。 Xウィンドウシステムのために行われたように、所与のマシン上の特定のサービスのそれぞれ異なるインスタンスの異なるTCPポートは、完全に賢明であるが、各アプリケーションに独自の大きな静的範囲を割り当てる使用して、それを実行するための実用的な方法ではありません。任意のホストでは、ほとんどのTCPポートは、その一生の間に、特定のホスト上で実行されることはありませんサービスのために予約されています。これは、限られたポート空間の非常に悪い利用です。 SRVレコードを使用すると、各ホストが実際にそれらを必要とするホスト上で実行されているこれらのサービスに動的に使用可能なポート番号を割り当てることができ、その後、SRVレコードを介して、割り当てられたポート番号を宣伝します。必要に応じて、ホストごとにローカルに利用できるリスニングポート番号を割り当てると、今日の集中型のグローバルな配分よりも利用できるポート空間のより良い利用を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the event that more than one SRV is returned, clients MUST correctly interpret the priority and weight fields -- i.e., lower-numbered priority servers should be used in preference to higher-numbered priority servers, and servers with equal priority should be selected randomly in proportion to their relative weights. However, in the overwhelmingly common case, a single advertised DNS-SD service instance is described by exactly one SRV record, and in this common case the priority and weight fields of the SRV record SHOULD both be set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数のSRVが返された場合には、クライアントが正しく優先度と重みフィールドを解釈しなければならない - すなわち、優先順位の低いサーバーでは、より高い番号の優先順位のサーバに優先して使用すべきである、と同じ優先度を持つサーバは、ランダムに選択されなければなりませんそれらの相対的な重みに比例インチしかし、圧倒的に一般的なケースでは、単一アドバタイズDNS-SDサービスインスタンスは、正確に一つのSRVレコードにより記述される、この一般的な場合ではSRVレコードの優先度と重みフィールドは両方ともゼロに設定されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Data Syntax for DNS-SD TXT Records
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
DNS-SD TXTレコードの6.データの構文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some services discovered via Service Instance Enumeration may need more than just an IP address and port number to completely identify the service instance. For example, printing via the old Unix LPR (port 515) protocol [RFC1179] often specifies a queue name [BJP]. This queue name is typically short and cryptic, and need not be shown to the user. It should be regarded the same way as the IP address and port number: it is another component of the addressing information required to identify a specific instance of a service being offered by some piece of hardware. Similarly, a file server may have multiple volumes, each identified by its own volume name. A web server typically has multiple pages, each identified by its own URL. In these cases, the necessary additional data is stored in a TXT record with the same name as the SRV record. The specific nature of that additional data, and how it is to be used, is service-dependent, but the overall syntax of the data in the TXT record is standardized, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス列挙経由で発見されたいくつかのサービスが完全にサービスインスタンスを識別するだけでIPアドレスとポート番号を超える必要があるかもしれません。例えば、古いUnixのLPR経由の印刷（ポート515）プロトコル[RFC1179]は、多くの場合、キュー名[BJP]を指定します。このキュー名は、一般的に短く、不可解であり、ユーザに表示する必要はありません。これは、IPアドレスとポート番号と同じようにみなされるべきである：それはハードウェアのいくつかの部分によって提供されるサービスの特定のインスタンスを識別するために必要なアドレス指定情報の別の構成要素です。同様に、ファイルサーバは、複数のボリューム、独自のボリューム名によって識別された各を有することができます。 Webサーバは通常、複数のページに、独自のURLによって識別された各があります。これらのケースでは、必要な追加データは、SRVレコードと同じ名前のTXTレコードに格納されています。特定のその追加データの性質、そしてどのようにそれを使用するには、サービスに依存しているが、後述のようにTXTレコード内のデータの全体的な構文は、標準化されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Every DNS-SD service MUST have a TXT record in addition to its SRV record, with the same name, even if the service has no additional data to store and the TXT record contains no more than a single zero byte. This allows a service to have explicit control over the Time to Live (TTL) of its (empty) TXT record, rather than using the default negative caching TTL, which would otherwise be used for a &#34;no error no answer&#34; DNS response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのDNS-SDサービスは、サービスを格納するために追加のデータを持っていないし、TXTレコードは、単一のゼロバイトよりも多く含まれていない場合でも、同じ名前で、そのSRVレコードに加えて、TXTレコードを持たなければなりません。これは、サービスではなくそれ以外の場合は、「エラーなし無回答」DNS応答のために使用されるデフォルトのネガティブキャッシュのTTLを、使用するよりも、その（空）TXTレコードの生存時間を明示的に制御（TTL）を持つことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that this requirement for a mandatory TXT record applies exclusively to DNS-SD service advertising, i.e., services advertised using the PTR+SRV+TXT convention specified in this document. It is not a requirement of SRV records in general. The DNS SRV record datatype [RFC2782] may still be used in other contexts without any requirement for accompanying PTR and TXT records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必須TXTレコードのこの要件は、すなわちDNS-SDサービス広告、のみに適用されることに注意してください、サービスは、この文書で指定されたPTR + SRV + TXT規則を使用して宣伝しました。これは、一般的にはSRVレコードの要件ではありません。 DNS SRVレコードのデータ型[RFC2782]はまだPTRとTXTレコードを伴うための任意の必要とせずに、他の文脈で使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. General Format Rules for DNS TXT Records
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1。 DNS TXTレコードのための一般的なフォーマットルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A DNS TXT record can be up to 65535 (0xFFFF) bytes long. The total length is indicated by the length given in the resource record header in the DNS message. There is no way to tell directly from the data alone how long it is (e.g., there is no length count at the start, or terminating NULL byte at the end).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNSのTXTレコードが長いバイトまで65535（0xFFFFの）にすることができます。全長は、DNSメッセージ内のリソースレコードヘッダに所定の長さで示されています。それは（例えば、開始時に何の長さの数が存在しない、または末尾にNULLバイトを終端する）であるどのくらいのデータのみから直接指示する方法はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that when using Multicast DNS [RFC6762] the maximum packet size is 9000 bytes, including the IP header, UDP header, and DNS message header, which imposes an upper limit on the size of TXT records of about 8900 bytes. In practice the maximum sensible size of a DNS-SD TXT record is smaller even than this, typically at most a few hundred bytes, as described below in Section 6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS [RFC6762]を使用する場合、最大パケットサイズは約8900バイトのTXTレコードのサイズに上限を課すIPヘッダ、UDPヘッダ、およびDNSメッセージヘッダを含め9000バイトであることに留意されたいです。実際にはDNS-SDのTXTレコードの最大賢明なサイズは、6.2節で後述するように、一般的に、百高々数バイトでもこれよりも小さくなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The format of the data within a DNS TXT record is one or more strings, packed together in memory without any intervening gaps or padding bytes for word alignment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS TXTレコード内のデータのフォーマットは、ワードアライメントのための任意の介在ギャップまたはパディングバイトなしでメモリに一緒に詰め込ま一つ以上の文字列です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The format of each constituent string within the DNS TXT record is a single length byte, followed by 0-255 bytes of text data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS TXTレコード内の各構成要素の文字列の形式は、テキストデータの0〜255バイトに続く、単一の長さのバイトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These format rules for TXT records are defined in Section 3.3.14 of the DNS specification [RFC1035] and are not specific to DNS-SD. DNS-SD specifies additional rules for what data should be stored in those constituent strings when used for DNS-SD service advertising, i.e., when used to describe services advertised using the PTR+SRV+TXT convention specified in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TXTレコードのこれらのフォーマットルールはDNS仕様[RFC1035]のセクション3.3.14で定義され、DNS-SDに対して特異的ではないれています。サービスを記述するために使用する場合、DNS-SDは、すなわち、DNS-SDサービス広告に使用する場合のデータは、これらの構成要素の文字列に格納する必要があります何のために追加のルールを指定し、この文書で指定されたPTR + SRV + TXT規則を使用して宣伝しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An empty TXT record containing zero strings is not allowed [RFC1035]. DNS-SD implementations MUST NOT emit empty TXT records. DNS-SD clients MUST treat the following as equivalent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ゼロの文字列を含む空のTXTレコードは、[RFC1035]を許可されていません。 DNS-SDの実装では、空のTXTレコードを放出してはなりません。 DNS-SDクライアントは同等のものとして、以下を扱わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A TXT record containing a single zero byte. (i.e., a single empty string.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O TXTレコードは、単一のゼロバイトを含みます。 （すなわち、単一の空の文字列）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o An empty (zero-length) TXT record. (This is not strictly legal, but should one be received, it should be interpreted as the same as a single empty string.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
空（ゼロ長）TXTレコードO。 （これは厳密には合法ではなく、一方が受信されなければならない、それは単一の空の文字列と同じように解釈されるべきです。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o No TXT record. (i.e., an NXDOMAIN or no-error-no-answer response.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ノーTXTレコードO。 （すなわち、NXDOMAINまたは全く誤り無応答応答）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. DNS-SD TXT Record Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2。 DNS-SD TXTレコードサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The total size of a typical DNS-SD TXT record is intended to be small -- 200 bytes or less.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
200バイト以下 - 典型的なDNS-SD TXTレコードの合計サイズを小さくすることが意図されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In cases where more data is justified (e.g., LPR printing [BJP]), keeping the total size under 400 bytes should allow it to fit in a single 512-byte DNS message [RFC1035].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
より多くのデータが正当化される場合には（例えば、LPR印刷[BJP]）、400バイトの下で合計サイズを維持することは、単一の512バイトのDNSメッセージ[RFC1035]に適合することを可能にするべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In extreme cases where even this is not enough, keeping the size of the TXT record under 1300 bytes should allow it to fit in a single 1500-byte Ethernet packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
でも、これは十分ではありません極端なケースでは、1300バイトの下にTXTレコードのサイズを維持することは、単一1500バイトのイーサネットパケットに収まるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using TXT records larger than 1300 bytes is NOT RECOMMENDED at this time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1300バイトを超えるTXTレコードを使用すると、この時点ではお勧めしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that some Ethernet hardware vendors offer chipsets with Multicast DNS [RFC6762] offload, so that computers can sleep and still be discoverable on the network. Early versions of such chipsets were sometimes quite limited: for example, some were (unwisely) limited to handling TXT records no larger than 256 bytes (which meant that LPR printer services with larger TXT records did not work). Developers should be aware of this real-world limitation, and should understand that even hardware which is otherwise perfectly capable may have low-power and sleep modes that are more limited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンピュータがネットワーク上で発見することが、まだ寝てできるように、いくつかのイーサネットハードウェアベンダーは、マルチキャストDNS [RFC6762]オフロードでのチップセットを提供することに注意してください。そのようなチップセットの初期のバージョンは、時には非常に限られていた：例えば、いくつかは（愚か）TXTを扱うに限定されていた（大きなTXTレコードを持つLPRプリンタサービスが機能しなかったことを意味）大きくない256バイト以下を記録します。開発者は、この現実世界の制限に注意する必要があり、そうでなければ完全に可能であってもハードウェアがより限定されている低消費電力とスリープモードを有していてもよいことを理解すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. DNS TXT Record Format Rules for Use in DNS-SD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3。 DNS-SDで使用するためのDNS TXTレコード形式のルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS-SD uses DNS TXT records to store arbitrary key/value pairs conveying additional information about the named service. Each key/value pair is encoded as its own constituent string within the DNS TXT record, in the form &#34;key=value&#34; (without the quotation marks). Everything up to the first &#39;=&#39; character is the key (Section 6.4). Everything after the first &#39;=&#39; character to the end of the string (including subsequent &#39;=&#39; characters, if any) is the value (Section 6.5). No quotation marks are required around the value, even if it contains spaces, &#39;=&#39; characters, or other punctuation marks. Each author defining a DNS-SD profile for discovering instances of a particular type of service should define the base set of key/value attributes that are valid for that type of service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS-SDは、名前のサービスに関する追加情報を伝える任意のキー/値のペアを格納するDNS TXTレコードを使用しています。各キー/値のペアは、フォーム（引用符で）「キー=値」で、DNS TXTレコード内独自の構成文字列として符号化されます。最初の「=」文字までのすべてが、キー（6.4節）です。 （その後の「=」文字を含め、もしあれば）文字列の最後に最初の「=」文字の後のすべてが値（6.5節）です。いいえ引用符は、スペース、「=」文字、または他の句読点が含まれていても、値の周りに必要ありません。サービスのタイプに対して有効なキー/値属性の基本セットを定義する必要があり、サービスの特定の型のインスタンスを発見するためのDNS-SDプロファイルを定義各著者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using this standardized key/value syntax within the TXT record makes it easier for these base definitions to be expanded later by defining additional named attributes. If an implementation sees unknown keys in a service TXT record, it MUST silently ignore them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TXTレコード内この標準化されたキー/値の構文を使用すると、追加の名前付き属性を定義することで、後に拡大するこれらの基本定義については、それが容易になります。実装は、サービスTXTレコードに未知の鍵を見れば、それは静かにそれらを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The target host name and TCP (or UDP) port number of the service are given in the SRV record. This information -- target host name and port number -- MUST NOT be duplicated using key/value attributes in the TXT record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスのターゲットホスト名とTCP（またはUDP）ポート番号は、SRVレコードに記載されています。この情報 - ターゲットホスト名とポート番号は -  TXTレコード内のキー/値の属性を使用して複製してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intention of DNS-SD TXT records is to convey a small amount of useful additional information about a service. Ideally, it should not be necessary for a client to retrieve this additional information before it can usefully establish a connection to the service. For a well-designed application protocol, even if there is no information at all in the TXT record, it should be possible, knowing only the host name, port number, and protocol being used, to communicate with that listening process and then perform version- or feature-negotiation to determine any further options or capabilities of the service instance. For example, when connecting to an AFP (Apple Filing Protocol) server [AFP] over TCP, the client enters into a protocol exchange with the server to determine which version of AFP the server implements and which optional features or capabilities (if any) are available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS-SD TXTレコードの意図は、サービスに関する有用な追加少量の情報を伝えることです。それは有効サービスへの接続を確立する前に、クライアントがこの追加情報を取得するために理想的には、それは必要ありません。うまく設計されたアプリケーションプロトコルのために、全くTXTレコードの情報がない場合でも、そのリスニング・プロセスと通信するために、使用した後のバージョンを実行している唯一のホスト名、ポート番号、およびプロトコルを知って、可能であるべきです - サービスインスタンスのいずれかの更なるオプションや機能を判断したり、機能ネゴシエーション。 TCP上AFP（アップルファイリングプロトコル）サーバ[AFP]に接続するとき、例えば、クライアントは、AFPのバージョンサーバーが実装とを決定するために、サーバとのプロトコル交換に入る任意の特徴または機能（もしあれば）であります利用可能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For protocols designed with adequate in-band version- and feature-negotiation, any information in the TXT record should be viewed as a performance optimization -- when a client discovers many instances of a service, the TXT record allows the client to know some rudimentary information about each instance without having to open a TCP connection to each one and interrogate every service instance separately. Care should be taken when doing this to ensure that the information in the TXT record is in agreement with the information that would be retrieved by a client connecting over TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インバンドバージョン - と機能ネゴシエーション十分なで設計されたプロトコルの場合は、TXTレコードの任意の情報は、パフォーマンスの最適化として見るべきである - クライアントがサービスの多くのインスタンスを発見したとき、TXTレコードは、クライアントが、いくつかの初歩的なを知ることができます各1へのTCP接続をオープンして、個別にすべてのサービスインスタンスに質問することなく、各インスタンスについての情報。 TXTレコード内の情報は、TCP上で接続しているクライアントによって取得されるだろう情報と一致していることを確認するためにこれを行う際には注意が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are legacy protocols that provide no feature negotiation capability, and in these cases it may be useful to convey necessary information in the TXT record. For example, when printing using LPR [RFC1179], the LPR protocol provides no way for the client to determine whether a particular printer accepts PostScript, what version of PostScript, etc. In this case it is appropriate to embed this information in the TXT record [BJP], because the alternative would be worse -- passing around written instructions to the users, arcane manual configuration of &#34;/etc/printcap&#34; files, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
何の特徴交渉能力を提供していないし、これらのケースでは、TXTレコードに必要な情報を伝えるために有用である可能性があるレガシープロトコルがあります。例えば、LPR [RFC1179]を使用して印刷する場合、LPRプロトコルは、特定のプリンタは、ポストスクリプトを受け入れるかどうか決定するために、クライアントのための方法を提供しない、どのようなポストスクリプトのバージョンなどこの場合、TXTレコードにこの情報を埋め込むことが適切です[BJP]、代替が悪くなりますので、 - などの「/ etc / printcapの」ファイルのユーザーに周りに書かれた説明書を渡し、難解な手動設定
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The engineering decision about what keys to define for the TXT record needs to be decided on a case-by-case basis for each service type. For some service types it is appropriate to communicate information via the TXT record as well as (or instead of) via in-band communication in the application protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TXTレコードのために定義するものをキーに関するエンジニアリングの決定は、各サービスタイプのケースバイケースで決定する必要があります。いくつかのサービスタイプのためには、アプリケーションプロトコルにおけるインバンド通信を介して、TXTレコード、並びに（又は代わりに）を介して情報を通信するために適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Rules for Keys in DNS-SD Key/Value Pairs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4。 DNS-SDキー/値のペア内のキーのルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key MUST be at least one character. DNS-SD TXT record strings beginning with an &#39;=&#39; character (i.e., the key is missing) MUST be silently ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キーは、少なくとも1つの文字でなければなりません。 「=」文字（すなわち、キーが欠落している）で始まるDNS-SD TXTレコードの文字列は黙って無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key SHOULD be no more than nine characters long. This is because it is beneficial to keep packet sizes small for the sake of network efficiency. When using DNS-SD in conjunction with Multicast DNS [RFC6762] this is important because multicast traffic is especially expensive on 802.11 wireless networks [IEEEW], but even when using conventional Unicast DNS, keeping the TXT records small helps improve the chance that responses will fit within the original DNS 512-byte size limit [RFC1035]. Also, each constituent string of a DNS TXT record is limited to 255 bytes, so excessively long keys reduce the space available for that key&#39;s values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キーは9文字以下であってはなりません。ネットワーク効率のために小さなパケット・サイズを維持するために有益であるためです。マルチキャストDNS [RFC6762]と連動してDNS-SDを使用する場合は、マルチキャストトラフィックは802.11ワイヤレスネットワーク[IEEEW]には特に高価であるが、従来のユニキャストDNSを使用する場合でも、TXTを維持することは、小さな記録の応答はする可能性を向上させることができますので、これは重要です元のDNS 512バイトのサイズ制限[RFC1035]内に収まります。また、DNSのTXTレコードの各構成文字列は255バイトに制限されているので、過度に長いキーは、そのキーの値のために利用可能なスペースを削減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The keys in key/value pairs can be as short as a single character. A key name needs only to be unique and unambiguous within the context of the service type for which it is defined. A key name is intended solely to be a machine-readable identifier, not a human-readable essay giving detailed discussion of the purpose of a parameter, with a URL for a web page giving yet more details of the specification. For ease of development and debugging, it can be valuable to use key names that are mnemonic textual names, but excessively verbose keys are wasteful and inefficient, hence the recommendation to keep them to nine characters or fewer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キー/値ペアのキーは単一の文字だけ短くすることができます。キー名は、それが定義されているサービスの種類のコンテキスト内で一意かつ明確にする必要があります。キーの名前は、機械読み取り可能な識別子、まだ仕様の詳細を与えるWebページのURLを、パラメータの目的の詳細な議論を与える人間が読めるエッセイであることを単に意図しています。開発とデバッグを容易にするため、9文字以下にそれらを維持するので、勧告、ニーモニックテキストの名前であるキー名を使用して、貴重なことができますが、過度に詳細なキーが無駄と非効率的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The characters of a key MUST be printable US-ASCII values (0x20-0x7E) [RFC20], excluding &#39;=&#39; (0x3D).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キーの文字が &#39;=&#39;（0x3D）を除く印刷可能なUS-ASCII値（0x20-0x7E）[RFC20]、でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Spaces in the key are significant, whether leading, trailing, or in the middle -- so don&#39;t include any spaces unless you really intend that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
鍵にスペースが先頭、末尾、または途中でかどうか、重要である - あなたは本当にそれを意図しない限り、スペースが含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Case is ignored when interpreting a key, so &#34;papersize=A4&#34;, &#34;PAPERSIZE=A4&#34;, and &#34;Papersize=A4&#34; are all identical.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケースは鍵を解釈するときに無視するので、 &#34;用紙サイズ= A4&#34;、 &#34;PAPERSIZE = A4&#34;、および &#34;用紙サイズ= A4&#34; すべて同じですされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If there is no &#39;=&#39; in a DNS-SD TXT record string, then it is a boolean attribute, simply identified as being present, with no value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
何「=」は、DNS-SD TXTレコードの文字列に存在しない場合、それは単に値なしで、存在しているとして識別、論理属性です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A given key SHOULD NOT appear more than once in a TXT record. The reason for this simplifying rule is to facilitate the creation of client libraries that parse the TXT record into an internal data structure (such as a hash table or dictionary object that maps from keys to values) and then make that abstraction available to client code. The rule that a given key may not appear more than once simplifies these abstractions because they aren&#39;t required to support the case of returning more than one value for a given key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定されたキーは、TXTレコードで複数回表示されません。この簡略化ルールの理由は、その後、クライアントコードへの抽象化を利用できるようにする（例えば値にキーからマッピングするハッシュテーブルまたは辞書オブジェクトのような）内部データ構造にTXTレコードを解析するクライアントライブラリの作成を容易にすることです。彼らは与えられたキーに複数の値を返す場合をサポートするために必要とされていないため、指定されたキーが複数回表示されない場合がありますルールは、これらの抽象化を簡素化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a client receives a TXT record containing the same key more than once, then the client MUST silently ignore all but the first occurrence of that attribute. For client implementations that process a DNS-SD TXT record from start to end, placing key/value pairs into a hash table using the key as the hash table key, this means that if the implementation attempts to add a new key/value pair into the table and finds an entry with the same key already present, then the new entry being added should be silently discarded instead. Client implementations that retrieve key/value pairs by searching the TXT record for the requested key should search the TXT record from the start and simply return the first matching key they find.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが複数回同じキーを含むTXTレコードを受信した場合、クライアントは黙ってその属性の最初の発生はなく、すべてを無視しなければなりません。ハッシュテーブルのキーとしてキーを使用して、ハッシュテーブルにキー/値のペアを配置し、開始から終了までDNS-SDのTXTレコードを処理するクライアント実装のために、このことは実装がに新しいキー/値のペアを追加しようとした場合テーブルは、新しいエントリがサイレント代わりに廃棄されるべき追加され、既に存在する同じキーを持つエントリを検索します。要求されたキーのTXTレコードを検索して、キー/値のペアを取得するクライアントの実装は、最初からTXTレコードを検索し、単に彼らが見つけ、最初に一致したキーを返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When examining a TXT record for a given key, there are therefore four categories of results that may be returned:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定されたキーのTXTレコードを調べるとき、返されることがあり、結果の4つのカテゴリがありますので。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Attribute not present (Absent)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
存在しない*属性（不在）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Attribute present, with no value (e.g., &#34;passreq&#34; -- password required for this service)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*値なしで、現在の属性（例えば、「PASSREQ」 - このサービスのために必要なパスワード）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Attribute present, with empty value (e.g., &#34;PlugIns=&#34; -- the server supports plugins, but none are presently installed)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*空の値を用いて、本項目（例えば、「プラグイン=」 - サーバーはプラグインをサポートしていますが、どれが現在インストールされていません）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Attribute present, with non-empty value (e.g., &#34;PlugIns=JPEG,MPEG2,MPEG4&#34;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*空でない値で、本項目（例えば、 &#34;プラグイン= JPEG、MPEG2、MPEG4&#34;）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each author defining a DNS-SD profile for discovering instances of a particular type of service should define the interpretation of these different kinds of result. For example, for some keys, there may be a natural true/false boolean interpretation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各著者は、結果のこれらの異なる種類の解釈を定義する必要があり、サービスの特定の型のインスタンスを発見するためにDNS-SDプロファイルを定義します。例えば、いくつかのキーのために、自然の真/偽のブール値の解釈があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Absent implies &#39;false&#39; * Present implies &#39;true&#39;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*プレゼントは意味*不在が意味する「false」に「真」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For other keys it may be sensible to define other semantics, such as value/no-value/unknown:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他のキーのためにそのような値/無価値/未知のような他のセマンティクスを定義するために賢明であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Present with value implies that value. (e.g., &#34;Color=4&#34; for a four-color ink-jet printer or &#34;Color=6&#34; for a six-color ink-jet printer)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*値と現在ではその値を意味します。 （例えば、「色= 4」6色インクジェットプリンタ用の4色インクジェットプリンタ又は「色= 6」の場合）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Present with empty value implies &#39;false&#39;. (e.g., not a color printer)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*空の値を持つ現状が「偽」を意味します。 （例えば、ないカラープリンタ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Absent implies &#39;Unknown&#39;. (e.g., a print server connected to some unknown printer where the print server doesn&#39;t actually know if the printer does color or not -- which gives a very bad user experience and should be avoided wherever possible)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*不在は「不明」を意味します。 （ - 非常に悪いユーザー体験を提供し、可能な限り避けるべきであるプリンタはカラーまたはしない場合、例えば、いくつかの未知のプリンタに接続され、プリントサーバーは、プリントサーバーは、実際には把握していない場合）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that this is a hypothetical example, not an example of actual key/value keys used by DNS-SD network printers, which are documented in the &#34;Bonjour Printing Specification&#34; [BJP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仮説例ではなく、「Bonjourの印刷仕様」[BJP]に記載されているDNS-SDネットワークプリンタで使用される実際のキー/値キーの一例であることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. Rules for Values in DNS-SD Key/Value Pairs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5。 DNS-SDキー/値のペアの値のルール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If there is an &#39;=&#39; in a DNS-SD TXT record string, then everything after the first &#39;=&#39; to the end of the string is the value. The value can contain any eight-bit values including &#39;=&#39;. The value MUST NOT be enclosed in additional quotation marks or any similar punctuation; any quotation marks, or leading or trailing spaces, are part of the value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS-SD TXTレコードの文字列に「=」がある場合は、すべての後に、文字列の末尾に「=」最初の値です。値は「=」を含む任意の8ビット値を含むことができます。値は、追加の引用符または任意の類似の句読点で囲んではいけません。任意の引用符、または先頭または末尾のスペースは、値の一部です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The value is opaque binary data. Often the value for a particular attribute will be US-ASCII [RFC20] or UTF-8 [RFC3629] text, but it is legal for a value to be any binary data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
値は不透明なバイナリデータです。多くの場合、特定の属性の値は、US-ASCII [RFC20]またはUTF-8 [RFC3629]のテキストになりますが、それは任意のバイナリデータと値のための法的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Generic debugging tools should generally display all attribute values as a hex dump, with accompanying text alongside displaying the UTF-8 interpretation of those bytes, except for attributes where the debugging tool has embedded knowledge that the value is some other kind of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的なデバッグツールは、一般的に、すべてのデバッグツールは、値がデータの他のいくつかの一種であるという知識が埋め込まれている属性を除き、これらのバイトのUTF-8の解釈を表示すると一緒にテキストを伴って、進ダンプとして属性値を表示する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors defining DNS-SD profiles SHOULD NOT generically convert binary attribute data types into printable text using hexadecimal representation, Base-64 [RFC4648], or Unix-to-Unix (UU) encoding, merely for the sake of making the data appear to be printable text when seen in a generic debugging tool. Doing this simply bloats the size of the TXT record, without actually making the data any more understandable to someone looking at it in a generic debugging tool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS-SDプロファイルを定義著者は一般的であるように見える単にデータを作成するために、16進表現、ベース64 [RFC4648]、またはUNIXからUNIX（UU）エンコーディングを使用して印刷可能なテキストにバイナリ属性データ型を変換すべきではありません一般的なデバッグツールで見られる印刷可能なテキスト。これを実行するだけで、実際に任意のより理解しやすい一般的なデバッグツールでそれを見て誰かにデータを加えることなく、TXTレコードのサイズをbloats。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. Example TXT Record
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6。例TXTレコードの
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TXT record below contains three syntactically valid key/value strings. (The meaning of these key/value pairs, if any, would depend on the definitions pertaining to the service in question that is using them.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TXTレコードは、以下の3構文的に有効なキー/値の文字列が含まれています。 （これらのキー/値ペアの意味は、もしあれば、それらを使用している当該サービスに関する定義に依存するであろう。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        -------------------------------------------------------
        | 0x09 | key=value | 0x08 | paper=A4 | 0x07 | passreq |
        -------------------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7. Version Tag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7。バージョン日
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is recommended that authors defining DNS-SD profiles include an attribute of the form &#34;txtvers=x&#34;, where &#34;x&#34; is a decimal version number in US-ASCII [RFC20] text (e.g., &#34;txtvers=1&#34; or &#34;txtvers=8&#34;), in their definition, and require it to be the first key/value pair in the TXT record. This information in the TXT record can be useful to help clients maintain backwards compatibility with older implementations if it becomes necessary to change or update the specification over time. Even if the profile author doesn&#39;t anticipate the need for any future incompatible changes, having a version number in the TXT record provides useful insurance should incompatible changes become unavoidable [RFC6709]. Clients SHOULD ignore TXT records with a txtvers number higher (or lower) than the version(s) they know how to interpret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS-SDプロファイルを定義する著者は、「x」はUS-ASCII [RFC20]テキスト（例えば、「txtvers = 1」または「txtversの小数点バージョン番号があるフォーム「txtvers = xで」、の属性を含めることをお勧めします= 8&#34; ）、その定義において、TXTレコードの最初のキー/値のペアであることを必要と。 TXTレコードでこの情報は、時間をかけて仕様を変更または更新することが必要になった場合、クライアントは後方古い実装との互換性を維持するために役立ちます。プロファイル作成者が任意の将来の互換性のない変更の必要性を予想していない場合であっても、TXTレコードのバージョン番号を持つことが有益な保険を提供して互換性のない変更が避けられない[RFC6709]になるはずです。クライアントは、彼らがどのように解釈するかを知っているバージョンよりも高い（または低い）txtvers番号（複数可）でTXTレコードを無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the version number in the txtvers tag describes the version of the specification governing the defined keys and the meaning of those keys for that particular TXT record, not the version of the application protocol that will be used if the client subsequently decides to contact that service. Ideally, every DNS-SD TXT record specification starts at txtvers=1 and stays that way forever. Improvements can be made by defining new keys that older clients silently ignore. The only reason to increment the version number is if the old specification is subsequently found to be so horribly broken that there&#39;s no way to do a compatible forward revision, so the txtvers number has to be incremented to tell all the old clients they should just not even try to understand this new TXT record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
txtversタグ内のバージョン番号が定義されたキーを管理する仕様のバージョンと、その特定のTXTレコードのこれらのキーの意味ではなく、クライアントがその後それに連絡することを決定した場合に使用されるアプリケーションプロトコルのバージョンを記述していることに注意してくださいサービス。理想的には、すべてのDNS-SD TXTレコード仕様はtxtvers = 1から始まり、永遠にその方法をご利用いただけます。改善は古いクライアントは黙って無視する新しいキーを定義することによって作製することができます。古い仕様は、その後そう恐ろしく互換性の前方改正を行う方法はありませんことを壊れたことが判明した場合、バージョン番号をインクリメントする唯一の理由は、そうtxtvers数は、彼らはただいけないすべての古いクライアントに伝えるためにインクリメントする必要がありますでも、この新しいTXTレコードを理解しよう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If there is a need to indicate which version number(s) of the application protocol the service implements, the recommended key for this is &#34;protovers&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスが実装アプリケーションプロトコルのバージョン番号（複数可）を示すために必要がある場合は、このための推奨されるキーは、「protovers」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.8. Service Instances with Multiple TXT Records
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.8。複数のTXTレコードを持つサービスインスタンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Generally speaking, every DNS-SD service instance has exactly one TXT record. However, it is possible for a particular protocol&#39;s DNS-SD advertising specification to state that it allows multiple TXT records. In this case, each TXT record describes a different variant of the same logical service, offered using the same underlying protocol on the same port, described by the same SRV record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的に言えば、すべてのDNS-SDサービスインスタンスは、1つのTXTレコードを持っています。しかし、それは、複数のTXTレコードを可能な状態に特定のプロトコルのDNS-SD広告の仕様が可能です。この場合、各TXTレコードが同じ論理サービスの異なる変異体を記載し、同一のSRVレコードによって説明したのと同じポート上で同じ基本プロトコルを使用して提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Having multiple TXT records to describe a single service instance is very rare, and to date, of the many hundreds of registered DNS-SD service types [SN], only one makes use of this capability, namely LPR printing [BJP]. This capability is used when a printer conceptually supports multiple logical queue names, where each different logical queue name implements a different page description language, such as 80-column monospaced plain text, seven-bit Adobe PostScript, eight-bit (&#34;binary&#34;) PostScript, or some proprietary page description language. When multiple TXT records are used to describe multiple logical LPR queue names for the same underlying service, printers include two additional keys in each TXT record: &#39;qtotal&#39;, which specifies the total number of TXT records associated with this SRV record, and &#39;priority&#39;, which gives the printer&#39;s relative preference for this particular TXT record. Clients then select the most preferred TXT record that meets the client&#39;s needs [BJP]. The only reason multiple TXT records are used is because the LPR protocol lacks in-band feature-negotiation capabilities for the client and server to agree on a data representation for the print job, so this information has to be communicated out-of-band instead using the DNS-SD TXT records. Future protocol designs should not follow this bad example by mimicking this inadequacy of the LPR printing protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一のサービスインスタンスを記述するために、複数のTXTレコードを持つことは非常に稀であり、現在までに、登録済みのDNS-SDサービスタイプ[SN]の何百もの、一つだけは、[BJP]この機能を使用すること、すなわち、LPR印刷を行います。プリンタは概念的に80カラムは、プレーンテキスト、7ビットのAdobe PostScriptの、8ビット（「バイナリ」）モノスペースなど、それぞれ異なる論理キュー名が異なるページ記述言語を実装し、複数の論理キュー名を、サポートしている場合は、この機能は使用されていますPostScript、またはいくつかの独自のページ記述言語。このSRVレコードに関連付けられたTXTレコードの合計数を指定「QTOTAL」、および「優先順位：複数のTXTレコードが同じ基本サービスのための複数の論理LPRキュー名を記述するために使用されている場合、プリンタは、各TXTレコード内の2つの追加のキーを含みますこの特定のTXTレコードのプリンタの相対的優先します」、。クライアントは、クライアントのニーズ[BJP]を満たしている最も好ましいTXTレコードを選択します。 LPRプロトコルは、クライアントと印刷ジョブのデータ表現に同意するサーバのインバンド機能ネゴシエーション機能がないため、複数のTXTレコードが使用されている唯一の理由はあるので、この情報は、アウトオブバンドの代わりに通信する必要がありますDNS-SD TXTレコードを使用しました。将来のプロトコルの設計は、LPR印刷プロトコルのこの不備を模倣することによって、この悪い例に従うべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Service Names
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.サービス名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &lt;Service&gt; portion of a Service Instance Name consists of a pair of DNS labels, following the convention already established for SRV records [RFC2782].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス名の&lt;サービス&gt;の部分は、すでにSRVレコード[RFC2782]のために設立条約以下、DNSラベルのペアで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first label of the pair is an underscore character followed by the Service Name [RFC6335]. The Service Name identifies what the service does and what application protocol it uses to do it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ペアの最初のラベルは、サービス名[RFC6335]に続いてアンダースコア文字です。サービス名は、サービスが何を識別し、それはそれを行うために使用するもののアプリケーションプロトコル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For applications using TCP, the second label is &#34;_tcp&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPを使用するアプリケーションでは、第二の標識は「_tcp」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For applications using any transport protocol other than TCP, the second label is &#34;_udp&#34;. This applies to all other transport protocols, including User Datagram Protocol (UDP), Stream Control Transmission Protocol (SCTP) [RFC4960], Datagram Congestion Control Protocol (DCCP) [RFC4340], Adobe&#39;s Real Time Media Flow Protocol (RTMFP), etc. In retrospect, perhaps the SRV specification should not have used the &#34;_tcp&#34; and &#34;_udp&#34; labels at all, and instead should have used a single label &#34;_srv&#34; to carve off a subdomain of DNS namespace for this use, but that specification is already published and deployed. At this point there is no benefit in changing established practice. While &#34;_srv&#34; might be aesthetically nicer than &#34;_udp&#34;, it is not a user-visible string, and all that is required protocol-wise is (i) that it be a label that can form a DNS delegation point, and (ii) that it be short so that it does not take up too much space in the packet, and in this respect either &#34;_udp&#34; or &#34;_srv&#34; is equally good. Thus, it makes sense to use &#34;_tcp&#34; for TCP-based services and &#34;_udp&#34; for all other transport protocols -- which are in fact, in today&#39;s world, often encapsulated over UDP -- rather than defining a new subdomain for every new transport protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP以外のトランスポートプロトコルを使用するアプリケーションでは、第二の標識は「_udp」です。これは、ユーザーデータグラムプロトコル（UDP）、ストリーム制御伝送プロトコル（SCTP）[RFC4960]、データグラム輻輳制御プロトコル（DCCP）[RFC4340]を含め、他のすべてのトランスポートプロトコルに適用され、Adobe社のリアルタイムメディアフロープロトコル（RTMFP）など振り返ってみると、おそらくSRV仕様は全く「_tcp」と「_udp」のラベルを使用しているべきではありません、代わりにこの使用のためのDNS名前空間のサブドメインをオフに彫るために単一のラベル「_srv」を使用している必要がありますが、その仕様がありますすでに公表して展開。この時点で、慣例を変えるには利点がありません。 「_srvは」「_udp」より審美的によりよいかもしれませんが、それはユーザーに見える文字列ではなく、すべてのことは、プロトコルごとの要求され、それがDNS委任ポイントを形成することができるラベルであること（I）であると、（ii ）それは「_udp」または「_srv」のいずれかをパケットにあまりにも多くのスペースを取り、この点ではないように、それが短いことが同様に良いです。今日の世界では、実際にはあり、多くの場合、UDP上でカプセル化 -   - したがって、それは他のすべてのトランスポートプロトコルのTCPベースのサービスのための「_tcp」を使用しても意味と「_udp」を作るのではなく、すべての新しいのための新しいサブドメインを定義しますトランスポートプロトコル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that this usage of the &#34;_udp&#34; label for all protocols other than TCP applies exclusively to DNS-SD service advertising, i.e., services advertised using the PTR+SRV+TXT convention specified in this document. It is not a requirement of SRV records in general. Other specifications that are independent of DNS-SD and not intended to interoperate with DNS-SD records are not in any way constrained by how DNS-SD works just because they also use the DNS SRV record datatype [RFC2782]; they are free to specify their own naming conventions as appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP以外のすべてのプロトコルの「_udp」ラベルのこの用法はつまりDNS-SDサービス広告、のみに適用されることに注意してください、サービスは、この文書で指定されたPTR + SRV + TXT規則を使用して宣伝しました。これは、一般的にはSRVレコードの要件ではありません。 DNS-SDの独立したDNS-SDレコードと相互運用することを意図していないその他の仕様は、彼らはまた、DNS SRVレコードのデータ型[RFC2782]を使用するという理由だけでDNS-SDがどのように動作するかによって制約どのような方法ではありません。彼らは、必要に応じて、独自の命名規則を指定するのは自由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The rules for Service Names [RFC6335] state that they may be no more than fifteen characters long (not counting the mandatory underscore), consisting of only letters, digits, and hyphens, must begin and end with a letter or digit, must not contain consecutive hyphens, and must contain at least one letter. The requirement to contain at least one letter is to disallow Service Names such as &#34;80&#34; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らは、これ以上15文字以下で、（必須アンダースコアを数えていない）、長いだけで、文字、数字、およびハイフンからなるかもしれ含んではならない、始まり、文字または数字で終わらなければならないことをサービス名[RFC6335]の状態のためのルール連続したハイフン、および少なくとも1つの文字が含まれている必要があります。少なくとも1つの文字を格納するための要件は、このような「80」として、またはサービス名を禁止することです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;6000-6063&#34;, which could be misinterpreted as port numbers or port number ranges. While both uppercase and lowercase letters may be used for mnemonic clarity, case is ignored for comparison purposes, so the strings &#34;HTTP&#34; and &#34;http&#34; refer to the same service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポート番号またはポート番号の範囲として誤って解釈される可能性が「6000から6063」、。大文字と小文字の両方の文字がニーモニック明確にするために使用することができるが、場合は、比較のために無視されているので、文字列「HTTP」と「HTTP」と同じサービスを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Wise selection of a Service Name is important, and the choice is not always as obvious as it may appear.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス名のワイズ選択が重要であり、その選択は常に、それは見かけほど明白ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In many cases, the Service Name merely names and refers to the on-the-wire message format and semantics being used. FTP is &#34;ftp&#34;, IPP printing is &#34;ipp&#34;, and so on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くの場合、サービス名単に名前と使用されているオン・ワイヤーメッセージフォーマット及びセマンティクスを指します。 FTPは、IPP印刷がように &#34;IPP&#34; で、かつ、 &#34;FTP&#34; です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, it is common to &#34;borrow&#34; an existing protocol and repurpose it for a new task. This is entirely sensible and sound engineering practice, but that doesn&#39;t mean that the new protocol is providing the same semantic service as the old one, even if it borrows the same message formats. For example, the network music sharing protocol implemented by iTunes on Macintosh and Windows is built upon &#34;HTTP GET&#34; commands. However, that does *not* mean that it is sensible or useful to try to access one of these music servers by connecting to it with a standard web browser. Consequently, the DNS-SD service advertised (and browsed for) by iTunes is &#34;_daap._tcp&#34; (Digital Audio Access Protocol), not &#34;_http._tcp&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、既存のプロトコルを「借り」と新しいタスクのためにそれを再利用するのが一般的です。これは完全に賢明かつ健全なエンジニアリングの実践であるが、それは新しいプロトコルは、それが同じメッセージ形式を借りていても、古いものと同じ意味的なサービスを提供していることを意味するものではありません。たとえば、MacintoshとWindows上のiTunesで実装ネットワーク音楽共有プロトコルは、「HTTP GET」コマンドに基づいて構築されます。しかし、それは* *標準的なWebブラウザとそれに接続することによって、これらの音楽サーバのいずれかにアクセスしようとする賢明または有用であることを意味するものではありません。その結果、DNS-SDサービスは、公示（およびため閲覧）のiTunesによる「_daap._tcp」（デジタル・オーディオ・アクセス・プロトコル）ではなく、「_http._tcp」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If iTunes were to advertise that it offered &#34;_http._tcp&#34; service, that would cause iTunes servers to appear in conventional web browsers (Safari, Camino, OmniWeb, Internet Explorer, Firefox, Chrome, etc.), which is of little use since an iTunes music library offers no HTML pages containing human-readable content that a web browser could display.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
iTunesは、それは以降ほとんど役に立たないのiTunesサーバは、従来のWebブラウザ（Safariの、カミノ、のOmniWeb、Internet ExplorerやFirefoxの、クロムなど）に表示される原因となる「_http._tcp」サービスを、提供することを宣伝していた場合iTunesの音楽ライブラリには、Webブラウザが表示することができ、人間が読めるコンテンツを含むいかなるHTMLページを提供しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Equally, if iTunes were to browse for &#34;_http._tcp&#34; service, that would cause it to discover generic web servers, such as the embedded web servers in devices like printers, which is of little use since printers generally don&#39;t have much music to offer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同様に、iTunesはプリンタは、一般的に多くの音楽を持っていないので、ほとんど使用され、それは、プリンタなどのデバイスの内蔵Webサーバなどの一般的なWebサーバを、発見する原因となる「_http._tcp」サービス、を参照した場合提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Analogously, Sun Microsystems&#39;s Network File System (NFS) is built on top of Sun Microsystems&#39;s Remote Procedure Call (Sun RPC) mechanism, but that doesn&#39;t mean it makes sense for an NFS server to advertise that it provides &#34;Sun RPC&#34; service. Likewise, Microsoft&#39;s Server Message Block (SMB) file service is built on top of Netbios running over IP, but that doesn&#39;t mean it makes sense for an SMB file server to advertise that it provides &#34;Netbios-over-IP&#34; service. The DNS-SD name of a service needs to encapsulate both the &#34;what&#34; (semantics) and the &#34;how&#34; (protocol implementation) of the service, since knowledge of both is necessary for a client to use the service meaningfully. Merely advertising that a service was built on top of Sun RPC is no use if the client has no idea what the service does.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同様に、サン・マイクロシステムズのネットワークファイルシステム（NFS）はSun Microsystemsののリモートプロシージャコール（日RPC）メカニズムの上に構築され、それはNFSサーバは、それが「日RPC」サービスを提供することを宣伝することは理にかなっているという意味ではありません。同様に、Microsoftのサーバーメッセージブロック（SMB）ファイルサービスは、IP上で実行されているのNetBIOSの上に構築されていますが、それはそれはそれは、「NetBIOSのオーバーIP」サービスを提供することを宣伝するためにSMBファイルサーバ用に理にかなっているという意味ではありません。サービスのDNS-SD名は、両方の知識が意味のあるサービスを使用するクライアントのために必要があるため、「何を」（セマンティクス）とサービスの「どのように」（プロトコル実装）の両方をカプセル化する必要があります。クライアントがサービスが何をするかわかりません場合は、単にサービスは、Sun RPCの上に構築されたことを宣伝しても無駄です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another common question is whether the service type advertised by iTunes should be &#34;_daap._http._tcp.&#34; This would also be incorrect. Similarly, a protocol designer implementing a network service that happens to use the Simple Object Access Protocol [SOAP] should not feel compelled to have &#34;_soap&#34; appear somewhere in the Service Name. Part of the confusion here is that the presence of &#34;_tcp&#34; or &#34;_udp&#34; in the &lt;Service&gt; portion of a Service Instance Name has led people to assume that the visible structure of the &lt;Service&gt; should reflect the private internal structure of how the protocol was implemented. This is not correct. All that is required is that the service be identified by some unique opaque Service Name. Making the Service Name be English text that is at least marginally descriptive of what the service does may be convenient, but it is by no means essential.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他の一般的な質問はiTunesのによって広告サービスタイプがあるべきかどうかである「_daap._http._tcp。」また、これは正しくないだろう。同様に、[SOAP]シンプルオブジェクトアクセスプロトコルを使用するために起こるネットワーク・サービスを実装するプロトコルの設計者は、「_soap」を持っているために強いと感じてはいけませんどこかサービス名で表示されます。ここでの混乱の一部は、&lt;サービス&gt;サービスインスタンス名の部分がつながっている人では「_tcp」または「_udp」の存在は、&lt;サービス&gt;の目に見える構造がどのようにのプライベート内部構造を反映すべきであると仮定することですプロトコルが実装されました。これは正しくありません。必要とされるすべてのサービスがいくつかのユニークな不透明なサービス名で識別されることです。サービス名は、サービスが何をするかの少なくともわずか記述である英語のテキストで作ることは都合がよいが、それは決して不可欠であることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Selective Instance Enumeration (Subtypes)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。選択インスタンスの列挙（サブタイプ）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document does not attempt to define a sophisticated (e.g., Turing complete, or even regular expression) query language for service discovery, nor do we believe one is necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントでは、サービスの発見のための（例えば、チューリングが完了、あるいは正規表現）洗練されたクエリ言語を定義しようとしない、また我々は1つが必要であると考えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, there are some limited circumstances where narrowing the set of results may be useful. For example, many network printers offer a web-based user interface, for management and administration, using HTML/HTTP. A web browser wanting to discover all advertised web pages issues a query for &#34;_http._tcp.&lt;Domain&gt;&#34;. On the other hand, there are cases where users wish to manage printers specifically, not to discover web pages in general, and it is good accommodate this. In this case, we define the &#34;_printer&#34; subtype of &#34;_http._tcp&#34;, and to discover only the subset of pages advertised as having that subtype property, the web browser issues a query for &#34;_printer._sub._http._tcp.&lt;Domain&gt;&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、結果のセットを狭くすることに有用であり得るいくつかの限定された状況があります。たとえば、多くのネットワークプリンタは、HTML / HTTPを使用して、管理・運営のために、Webベースのユーザインターフェイスを提供します。すべてのアドバタイズされたWebページを発見したいWebブラウザは、クエリのために発行し、「_http._tcpを。&lt;ドメイン&gt;」。一方、ユーザーは一般的にWebページを発見していない、特にプリンタを管理したい、これに対応良い場合があります。この場合、私たちは「_http._tcp」の「_printer」サブタイプを定義し、そのサブタイプの性質を持つものとして宣伝ページのサブセットのみを発見するために、Webブラウザは_printer._sub._http._tcp」のクエリを発行します。&lt;ドメイン&gt;」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Safari web browser on Mac OS X 10.5 &#34;Leopard&#34; and later uses subtypes in this way. If an &#34;_http._tcp&#34; service is discovered both via &#34;_printer._sub._http._tcp&#34; browsing and via &#34;_http._tcp&#34; browsing then it is displayed in the &#34;Printers&#34; section of Safari&#39;s UI. If a service is discovered only via &#34;_http._tcp&#34; browsing then it is displayed in the &#34;Webpages&#34; section of Safari&#39;s UI. This can be seen by using the commands below on Mac OS X to advertise two &#34;fake&#34; services. The service instance &#34;A web page&#34; is displayed in the &#34;Webpages&#34; section of Safari&#39;s Bonjour list, while the instance &#34;A printer&#39;s web page&#34; is displayed in the &#34;Printers&#34; section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
後にはMac OS X 10.5「Leopardの」と上のSafariウェブブラウザには、このようにサブタイプを使用しています。 「_http._tcp」サービス「は_printer._sub._http._tcp」ブラウジング経由して「_http._tcp」ブラウジング経由の両方が発見された場合、それはSafariのUIの「プリンタ」セクションに表示されます。サービスは唯一の「_http._tcp」ブラウジングを経て発見された場合、それはSafariのUIの「Webページ」セクションに表示されます。これは、二つの「偽」のサービスを宣伝するためのMac OS X上で以下のコマンドを使用して見ることができます。例えば「プリンタのウェブページは、」「プリンタ」セクションに表示されている間、サービスインスタンス「Webページは」SafariのBonjourのリストの「Webページ」セクションに表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
dns-sd -R &#34;A web page&#34; _http._tcp local 100 dns-sd -R &#34;A printer&#39;s web page&#34; _http._tcp,_printer local 101
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS-SD -Rローカル100 DNS-SD -R &#34;プリンタのWebページ&#34; _http._tcp _http._tcp &#34;Webページ&#34;、地元の101 _printer
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the advertised web page&#39;s Service Instance Name is unchanged by the use of subtypes -- it is still something of the form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アドバタイズされたWebページのサービスインスタンス名は、サブタイプの使用により変更されていないことに注意してください - それはまだ形のものです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;The Server._http._tcp.example.com.&#34;, and the advertised web page is still discoverable using a standard browsing query for services of type &#34;_http._tcp&#34;. The subdomain in which HTTP server SRV records are registered defines the namespace within which HTTP server names are unique. Additional subtypes (e.g., &#34;_printer&#34;) of the basic service type (e.g., &#34;_http._tcp&#34;) serve to allow clients to query for a narrower set of results, not to create more namespace.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「Server._http._tcp.example.com。」、およびアドバタイズされたウェブページは、タイプ「_http._tcp」のサービスのための標準的なブラウジングクエリを使用して、まだ発見です。 HTTPサーバのSRVレコードが登録されているサブドメインは、HTTPサーバ名がユニークである内の名前空間を定義します。基本的なサービスの種類（例えば、「_http._tcp」）の追加のサブタイプ（例えば、「_printer」）は、クライアントがより多くの名前空間を作成するのではなく、結果の狭いセットを照会できるようにするのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using DNS zone file syntax, the service instance &#34;A web page&#34; is advertised using one PTR record, while the instance &#34;A printer&#39;s web page&#34; is advertised using two: the primary service type and the additional subtype. Even though the &#34;A printer&#39;s web page&#34; service is advertised two different ways, both PTR records refer to the name of the same SRV+TXT record pair:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
主なサービスタイプと追加のサブタイプを：インスタンスながら、「プリンタのWebページを」「ウェブページを」1つのPTRレコードを使用してアドバタイズされたDNSゾーンファイルの構文を使用して、サービスインスタンスは、2を使用してアドバタイズされます。 「プリンタのウェブページ」サービスは2種類の方法が宣伝されていても、両方のPTRレコードが同じSRV + TXTレコードのペアの名前を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
; One PTR record advertises &#34;A web page&#34; _http._tcp.local. PTR A\032web\032page._http._tcp.local.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
;一つのPTRレコードは、「Webページ」_http._tcp.localアドバタイズします。 PTR A \ 032web \ 032page._http._tcp.local。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
; Two different PTR records advertise &#34;A printer&#39;s web page&#34; _http._tcp.local. PTR A\032printer&#39;s\032web\032page._http._tcp.local. _printer._sub._http._tcp.local. PTR A\032printer&#39;s\032web\032page._http._tcp.local.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
;二つの異なるPTRレコードは、「プリンタのウェブページ」_http._tcp.localを宣伝します。 PTR A \ \ 032web \ 032page._http._tcp.localだ032printer。 _printer._sub._http._tcp.local。 PTR A \ \ 032web \ 032page._http._tcp.localだ032printer。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Subtypes are appropriate when it is desirable for different kinds of client to be able to browse for services at two levels of granularity. In the example above, we describe two classes of HTTP clients: general web browsing clients that are interested in all web pages, and specific printer management tools that would like to discover only web UI pages advertised by printers. The set of HTTP servers on the network is the same in both cases; the difference is that some clients want to discover all of them, whereas other clients only want to find the subset of HTTP servers whose purpose is printer administration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントの種類は、2つの粒度でサービスを参照できるようにすることが望ましい場合のサブタイプが適切です。すべてのWebページに興味がある一般的なWebブラウジングのクライアント、およびプリンタによって広告のみのWeb UIページを発見したい特定のプリンタ管理ツール：上記の例では、HTTPクライアントの2つのクラスを記述します。ネットワーク上のHTTPサーバーのセットは、どちらの場合も同じです。違いは、他のクライアントが唯一の目的プリンタ管理であるHTTPサーバのサブセットを検索するのに対し、いくつかのクライアントは、それらのすべてを発見したいということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Subtypes are only appropriate in two-level scenarios such as this one, where some clients want to find the full set of services of a given type, and at the same time other clients only want to find some subset. Generally speaking, if there is no client that wants to find the entire set, then it&#39;s neither necessary nor desirable to use the subtype mechanism. If all clients are browsing for some particular subtype, and no client exists that browses for the parent type, then a new Service Name representing the logical service should be defined, and software should simply advertise and browse for that particular service type directly. In particular, just because a particular network service happens to be implemented in terms of some other underlying protocol, like HTTP, Sun RPC, or SOAP, doesn&#39;t mean that it&#39;s sensible for that service to be defined as a subtype of &#34;_http&#34;, &#34;_sunrpc&#34;, or &#34;_soap&#34;. That would only be useful if there were some class of client for which it is sensible to say, &#34;I want to discover a service on the network, and I don&#39;t care what it does, as long as it does it using the SOAP XML RPC mechanism.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サブタイプは、いくつかのクライアントが指定した型のサービスの完全なセットを見つけたいなど、この1のような2つのレベルのシナリオ、にのみ適切であると同時に、他のクライアントは、一部だけのサブセットを見つけたいです。それはサブタイプのメカニズムを使用する必要も望ましくもないですが、セット全体を見つけたいクライアントがない場合一般的に言えば。すべてのクライアントは、いくつかの特定のサブタイプのために閲覧されており、どのクライアントがその親タイプにブラウズ存在しない場合は、論理的なサービスを表す新しいサービス名を定義すべきである、とソフトウェアは、単純に広告を掲載し、直接その特定のサービスタイプを参照する必要があります。具体的には、特定のネットワークサービスはHTTP、日RPC、またはSOAPのように、他のいくつかの基本的なプロトコルの観点で実施することが起こるという理由だけで、そのサービスは「_HTTP」のサブタイプとして定義することが賢明だという意味ではありません、 &#34;_sunrpc&#34;、または &#34;_soap&#34;。私がネットワーク上のサービスを発見したい」、と言って賢明であるため、クライアントのいくつかのクラスがあった場合には、唯一有用であろう、と私は、それがSOAPを使用してそれをしないよう、それが何をするか気にしませんXMLのRPCメカニズム。」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Subtype strings are not required to begin with an underscore, though they often do. As with the TXT record key/value pairs, the list of possible subtypes, if any (including whether some or all begin with an underscore) are defined and specified separately for each basic service type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らは頻繁に行うもののサブタイプの文字列は、アンダースコアで始める必要はありません。 TXTレコードのキー/値のペアのように、任意の（一部または全部が下線で始まるかどうかを含む）場合に可能なサブタイプのリストは、各基本サービスタイプのために定義され、別途指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Subtype strings (e.g., &#34;_printer&#34; in the example above) may be constructed using arbitrary 8-bit data values. In many cases these data values may be UTF-8 [RFC3629] representations of text, or even (as in the example above) plain ASCII [RFC20], but they do not have to be. Note, however, that even when using arbitrary 8-bit data for subtype strings, DNS name comparisons are still case-insensitive, so (for example) the byte values 0x41 and 0x61 will be considered equivalent for subtype comparison purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サブタイプ文字列（例えば、上記の例では「_printer」）任意の8ビットのデータ値を使用して構築することができます。多くの場合、これらのデータ値は、テキストのUTF-8 [RFC3629]の表現であってもよいし、あるいは（上記の例のように）、プレーンASCII [RFC20]、それらはである必要はありません。サブタイプ文字列を任意の8ビットのデータを用いた場合でも、DNS名の比較はまだ大文字と小文字を区別しないこと、しかし、注意ので、（例えば）バイト値0×41との0x61は、サブタイプ比較目的のために等価であるとみなされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Service Name Length Limits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。サービス名の長さ制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As specified above, Service Names are allowed to be no more than fifteen characters long. The reason for this limit is to conserve bytes in the domain name for use both by the network administrator (choosing service domain names) and by the end user (choosing instance names).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記のように、サービス名は、これ以上15文字以下の長であることを認めています。この制限の理由は、（サービスドメイン名を選択する）ネットワーク管理者とエンドユーザー（インスタンス名を選択する）ことで、両方の使用のためのドメイン名でバイトを節約することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A fully qualified domain name may be up to 255 bytes long, plus one byte for the final terminating root label at the end. Domain names used by DNS-SD take the following forms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全修飾ドメイン名の長さは最大255バイト、プラス最後に、最終的な終端ルートラベルの1つのバイトかもしれません。 DNS-SDで使用されるドメイン名は次の形式を取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 &lt;sn&gt;._tcp . &lt;servicedomain&gt; . &lt;parentdomain&gt;. &lt;Instance&gt; . &lt;sn&gt;._tcp . &lt;servicedomain&gt; . &lt;parentdomain&gt;. &lt;sub&gt;._sub . &lt;sn&gt;._tcp . &lt;servicedomain&gt; . &lt;parentdomain&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;SN&gt; ._ TCP。 &lt;servicedomain&gt;。 &lt;parentdomain&gt;。 &lt;インスタンス&gt;。 &lt;SN&gt; ._ TCP。 &lt;servicedomain&gt;。 &lt;parentdomain&gt;。 &lt;サブ&gt; ._サブ。 &lt;SN&gt; ._ TCP。 &lt;servicedomain&gt;。 &lt;parentdomain&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first example shows the name used for PTR queries. The second shows a Service Instance Name, i.e., the name of the service&#39;s SRV and TXT records. The third shows a subtype browsing name, i.e., the name of a PTR record pointing to a Service Instance Name (see Section 7.1, &#34;Selective Instance Enumeration&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の例では、PTRクエリに使用される名前を示します。第二は、サービスインスタンス名、すなわち、サービスのSRVとTXTレコードの名前が表示されます。第三は、（セクション7.1、「選択的インスタンスの列挙」を参照）PTRレコードの名前は、サービスインスタンス名を指し、すなわち、サブタイプ閲覧名を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Service Name &lt;sn&gt; may be up to 15 bytes, plus the underscore and length byte, making a total of 17. Including the &#34;_udp&#34; or &#34;_tcp&#34; and its length byte, this makes 22 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス名は、&lt;SN&gt;これは22バイトになり、「_udp」または「_tcp」と、その長さバイトを含め17の合計を作る、最大15バイト、プラスアンダー長さバイトであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The instance name &lt;Instance&gt; may be up to 63 bytes. Including the length byte used by the DNS format when the name is stored in a packet, that makes 64 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
インスタンス名&lt;インスタンス&gt;は、最大63のバイトかもしれません。名前は64バイトになり、パケットに格納されている場合、DNSフォーマットで使用される長さバイトを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When using subtypes, the subtype identifier is allowed to be up to 63 bytes, plus the length byte, making 64. Including the &#34;_sub&#34; and its length byte, this makes 69 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サブタイプを使用する場合は、サブタイプ識別子は「_sub」とその長さバイトを含む64を作り、最大63バイト、プラス長さバイトであることを許可され、これは69バイトになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Typically, DNS-SD service records are placed into subdomains of their own beneath a company&#39;s existing domain name. Since these subdomains are intended to be accessed through graphical user interfaces, not typed on a command line, they are frequently long and descriptive. Including the length byte, the user-visible service domain may be up to 64 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的に、DNS-SDサービスレコードは、同社の既存のドメイン名の下に、独自のサブドメインに配置されています。これらのサブドメインは、コマンド行に入力しないグラフィカル・ユーザ・インターフェースを介してアクセスされることが意図されているので、それらはしばしば長くて記述されています。長さバイトを含む、ユーザ可視サービスドメインは、最大64バイトであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Of our available 255 bytes, we have now accounted for 69+22+64 = 155 bytes. This leaves 100 bytes to accommodate the organization&#39;s existing domain name &lt;parentdomain&gt;. When used with Multicast DNS, &lt;parentdomain&gt; is &#34;local.&#34;, which easily fits. When used with parent domains of 100 bytes or less, the full functionality of DNS-SD is available without restriction. When used with parent domains longer than 100 bytes, the protocol risks exceeding the maximum possible length of domain names, causing failures. In this case, careful choice of short &lt;servicedomain&gt; names can help avoid overflows. If the &lt;servicedomain&gt; and &lt;parentdomain&gt; are too long, then service instances with long instance names will not be discoverable or resolvable, and applications making use of long subtype names may fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちの利用可能255バイト、我々は今、69 + 22 + 64 = 155バイトを占めています。これは、組織の既存のドメイン名&lt;parentdomain&gt;に対応するために、100のバイトを残します。マルチキャストDNSを使用する場合、&lt;parentdomain&gt;「ローカル」です、簡単にフィットしています。 100バイト以下の親ドメインと一緒に使用すると、DNS-SDの全機能を制限することなく使用可能です。 100バイトより長い親ドメインで使用される場合、プロトコルは、障害の原因となる、ドメイン名の最大長を超える恐れがあります。この場合、短い&lt;servicedomain&gt;名前の慎重な選択は、オーバーフローを避けるのを助けることができます。 &lt;servicedomain&gt;と&lt;parentdomain&gt;が長すぎる場合は、長いインスタンス名を持つサービスインスタンスは、発見や解決できないだろう、と長いサブタイプ名を利用するアプリケーションが失敗することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because of this constraint, we choose to limit Service Names to 15 characters or less. Allowing more characters would not increase the expressive power of the protocol and would needlessly reduce the maximum &lt;parentdomain&gt; length that may be safely used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この制約のため、我々は、15文字以下にするサービス名を制限することを選択しました。複数の文字を可能にするプロトコルの表現力を増加させないであろうと不安全に使用することができる最大&lt;parentdomain&gt;長さを減少させるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that &lt;Instance&gt; name lengths affect the maximum number of services of a given type that can be discovered in a given &lt;servicedomain&gt;. The largest Unicast DNS response than can be sent (typically using TCP, not UDP) is 64 kB. Using DNS name compression, a Service Instance Enumeration PTR record requires 2 bytes for the (compressed) name, plus 10 bytes for type, class, ttl, and rdata length. The rdata of the PTR record requires up to 64 bytes for the &lt;Instance&gt; part of the name, plus 2 bytes for a name compression pointer to the common suffix, making a maximum of 78 bytes total. This means that using maximum-sized &lt;Instance&gt; names, up to 839 instances of a given service type can be discovered in a given &lt;servicedomain&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;インスタンス&gt;の名前の長さは、&lt;servicedomain&gt;与えられた中で発見することができ、指定された型のサービスの最大数に影響を与えることに注意してください。 （通常は、UDPをTCPを使用していない）送ることができるよりも最大のユニキャストDNS応答は64 KBです。 DNS名圧縮を使用して、サービスインスタンス列挙PTRレコードは、（圧縮）名の2バイト、プラスタイプ、クラス、TTL、およびRDATA長さ10バイトを必要とします。 PTRレコードのRDATAは、78バイトの合計の最大値を作る、&lt;インスタンス&gt;名の一部、プラスコモンサフィックスに名前圧縮ポインタのために2つのバイトを64のバイトまで必要とします。これは、特定のサービスタイプの最大839件のインスタンスが与えられた&lt;servicedomain&gt;で発見することができ、最大サイズの&lt;インスタンス&gt;の名前を使用していることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS aggregates response packets, so it does not have the same hard limit, but in practice it is also useful for up to a few hundred instances of a given service type, but probably not thousands.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答パケットを集約するので、何千人もが同じハード制限はありませんが、実際には、それはまた、特定のサービスタイプの最大数百インスタンスに便利ですが、おそらくありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, displaying even 100 instances in a flat list is probably too many to be helpful to a typical user. If a network has more than 100 instances of a given service type, it&#39;s probably appropriate to divide those services into logical subdomains by building, by floor, by department, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、フラットなリストでも、100のインスタンスを表示することは、一般的なユーザーに有用であることが、おそらくあまりにも多くのです。ネットワークは、特定のサービスタイプの100件の以上のインスタンスがある場合、それはなど、部署によって、床により、構築することにより、論理的なサブドメインにそれらのサービスを分割するために、おそらく適切です
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Flagship Naming
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.主力ネーミング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In some cases, there may be several network protocols available that all perform roughly the same logical function. For example, the printing world has the lineprinter (LPR) protocol [RFC1179] and the Internet Printing Protocol (IPP) [RFC2910], both of which cause printed sheets to be emitted from printers in much the same way. In addition, many printer vendors send their own proprietary page description language (PDL) data over a TCP connection to TCP port 9100, herein referred to generically as the &#34;pdl-datastream&#34; protocol. In an ideal world, we would have only one network printing protocol, and it would be sufficiently good that no one felt a compelling need to invent a different one. However, in practice, multiple legacy protocols do exist, and a service discovery protocol has to accommodate that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのケースでは、すべてがほぼ同じ論理機能を実行することに利用可能ないくつかのネットワークプロトコルが存在してもよいです。例えば、印刷の世界では、印刷されたシートは、ほぼ同じ方法でプリンターから放出させるどちらもlineprinter（LPR）プロトコル[RFC1179]とインターネット印刷プロトコル（IPP）[RFC2910]を有します。加えて、多くのプリンタベンダーがTCPポート9100へのTCP接続を介して、それらの独自のページ記述言語（PDL）データを送信し、本明細書では「PDL-データストリーム」プロトコルとして総称します。理想的な世界では、我々は唯一のネットワーク印刷プロトコルを持っているでしょうし、誰もが異なるものを発明する説得力の必要性を感じていないことを十分に良いでしょう。しかし、実際には、複数のレガシープロトコルが存在しない、とサービス発見プロトコルはそれを受け入れる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many printers implement all three printing protocols: LPR, IPP, and pdl-datastream. For the benefit of clients that may speak only one of those protocols, all three are advertised.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LPR、IPP、およびPDL-データストリーム：多くのプリンタは、3つのすべての印刷プロトコルを実装します。一つだけ、これらのプロトコルのを話すことが、クライアントの利益のために、3つのすべてが宣伝されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, some clients may implement two, or all three of those printing protocols. When a client looks for all three service types on the network, it will find three distinct services -- an LPR service, an IPP service, and a pdl-datastream service -- all of which cause printed sheets to be emitted from the same physical printer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ただし、一部のクライアントは、2つ、またはそれらの印刷プロトコルのすべての3つを実装することができます。 LPRサービス、IPPサービス、およびPDL-データストリームサービス -   - シートが同じ物理から放出されることが印刷された原因となるすべてが、クライアントがネットワーク上のすべての3つのサービスタイプを探すとき、それは、3つの異なるサービスを検索しますプリンタ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In a case like this, where multiple protocols all perform effectively the same function, a client may browse for all the service types it supports and display all the discovered instance names in a single aggregated list. Where the same instance name is discovered more than once because that entity supports more than one service type (e.g. a single printer which implements multiple printing protocols) the duplicates should be suppressed and the name should appear only once in the list. When the user indicates their desire to print on a given named printer, the printing client is responsible for choosing which of the available protocols will best achieve the desired effect, without, for example, requiring the user to make a manual choice between LPR and IPP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数のプロトコルのすべてが効果的に同じ機能を実行し、このような場合では、クライアントは、それがサポートするすべてのサービスタイプを参照し、単一の集約リスト内のすべての発見されたインスタンス名を表示することがあります。そのエンティティが複数のサービスタイプ（複数の印刷プロトコルを実装して、例えば単一のプリンタ）をサポートするため、同じインスタンス名が複数回検出された場合、重複を抑制しなければならないと名前が一度だけリストに表示されます。ユーザーが指定した名前のプリンタで印刷する意欲を示している場合、印刷クライアントはLPRとIPPの間で手動選択をすることをユーザーに要求する、例えば、なし、最高の所望の効果を達成する利用可能なプロトコルの選択する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described so far, this all works very well. However, consider the case of: some future printer that only supports IPP printing, and some other future printer that only supports pdl-datastream printing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これまでに説明したように、このすべてが非常にうまく機能します。唯一のIPP印刷、およびのみPDL-データストリームの印刷をサポートしていますいくつかの他の将来のプリンタをサポートしているいくつかの将来のプリンタ：しかし、の場合を考えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The namespaces for different service types are intentionally disjoint (it is acceptable and desirable to be able to have both a file server called &#34;Sales Department&#34; and a printer called &#34;Sales Department&#34;). However, it is not desirable, in the common case, to allow two different printers both to be called &#34;Sales Department&#34; merely because those two printers implement different printing protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さまざまなサービスタイプのための名前空間は、（「営業部」と呼ばれるファイル・サーバや「営業部」と呼ばれるプリンタの両方を持つことができるように許容できると望ましい）意図的に互いに素です。しかし、それは両方とも、これらの2台のプリンタが異なる印刷プロトコルを実装するだけであるため、「営業部」と呼ばれるように二つの異なるプリンタを可能にするために、一般的な場合には、望ましいことではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To help guard against this, when there are two or more network protocols that perform roughly the same logical function, one of the protocols is declared the &#34;flagship&#34; of the fleet of related protocols. Typically the flagship protocol is the oldest and/or best-known protocol of the set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このに対してガードを助けるために、ほぼ同じ論理機能を実行する2つの以上のネットワークプロトコルが存在する場合には、プロトコルの一つは、関連するプロトコルの艦隊の「旗艦」を宣言しています。典型的には、フラッグシッププロトコルは、セットの最も古い及び/又は最もよく知られたプロトコルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a device does not implement the flagship protocol, then it instead creates a placeholder SRV record (priority=0, weight=0, port=0, target host = host name of device) with that name. If, when it attempts to create this SRV record, it finds that a record with the same name already exists, then it knows that this name is already taken by some other entity implementing at least one of the protocols from the fleet, and it must choose another. If no SRV record already exists, then the act of creating it stakes a claim to that name so that future devices in the same protocol fleet will detect a conflict when they try to use it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
装置が主力プロトコルを実装していない場合、それは代わりに、プレースホルダSRVレコードを作成する（優先度= 0、重量= 0、ポート= 0、ターゲットホストデバイスの=ホスト名）は、その名前を持ちます。それは、このSRVレコードを作成しようとしたとき、それは同じ名前のレコードが既に存在することを発見し、場合、それは、この名前は、すでにいくつかの他のエンティティは、艦隊からのプロトコルのうちの少なくとも一つを実装することによって取られていることを知っているし、それがなければなりません別のものを選びます。何のSRVレコードがすでに存在していない場合、彼らはそれを使用しようとすると、その名前にそれを主張する杭を作成する行為と同じプロトコル艦隊における将来のデバイスは、競合を検出しますように。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: When used with Multicast DNS [RFC6762], the target host field of the placeholder SRV record MUST NOT be the empty root label. The SRV record needs to contain a real target host name in order for the Multicast DNS conflict detection rules to operate. If two different devices were to create placeholder SRV records both using a null target host name (just the root label), then the two SRV records would be seen to be in agreement, and no conflict would be detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：マルチキャストDNS [RFC6762]で使用する場合、プレースホルダのSRVレコードのターゲットホストフィールドが空のルートラベルにすることはできません。 SRVレコードは、マルチキャストDNS競合の検出ルールが動作するためには、実際のターゲットホスト名を含める必要があります。 2つの異なるデバイスがnullターゲットホスト名（ちょうどルートラベル）を使用して、両方のプレースホルダのSRVレコードを作成した場合、2つのSRVレコードが一致していることが見られる、と何の競合が検出されないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By defining a common well-known flagship protocol for the class, future devices that may not even know about each other&#39;s protocols establish a common ground where they can coordinate to verify uniqueness of names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クラスに共通のよく知られたフラッグシップ・プロトコルを定義することで、でもお互いのプロトコルについて知らないかもしれない将来のデバイスは、彼らが名前の一意性を確認するために調整できる共通の基盤を確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
No PTR record is created advertising the presence of empty flagship SRV records, since they do not represent a real service being advertised, and hence are not (and should not be) discoverable via Service Instance Enumeration (browsing).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いいえPTRレコードは、サービスインスタンスの列挙（ブラウジング）を経由して発見、彼らが公示されている実際のサービスを表すものではありませ、ひいてはではありません（とすべきではない）ないので、空の主力SRVレコードの存在を宣伝作成されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Service Type Enumeration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.サービスタイプ列挙
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In general, a normal client is not interested in finding *every* service on the network, just the services that the client knows how to use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的には、通常のクライアントは、*ネットワーク上のすべての*サービスは、クライアントが使用する方法を知っているだけのサービスを見つけることに興味がないです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, for problem diagnosis and network management tools, it may be useful for network administrators to find the list of advertised service types on the network, even if those Service Names are just opaque identifiers and not particularly informative in isolation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワーク管理者は、これらのサービス名は、ちょうど不透明な識別子と分離する際に特に有益でない場合でも、ネットワーク上の広告を出してサービスタイプのリストを探してしかし、問題の診断およびネットワーク管理ツールのために、それが有用である可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For this purpose, a special meta-query is defined. A DNS query for PTR records with the name &#34;_services._dns-sd._udp.&lt;Domain&gt;&#34; yields a set of PTR records, where the rdata of each PTR record is the two-label &lt;Service&gt; name, plus the same domain, e.g., &#34;_http._tcp.&lt;Domain&gt;&#34;. Including the domain in the PTR rdata allows for slightly better name compression in Unicast DNS responses, but only the first two labels are relevant for the purposes of service type enumeration. These two-label service types can then be used to construct subsequent Service Instance Enumeration PTR queries, in this &lt;Domain&gt; or others, to discover instances of that service type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この目的のために、特別なメタクエリが定義されています。名前のPTRレコードのDNSクエリ「_services._dns-sd._udp。&lt;ドメイン&gt;は、」各PTRレコードのRDATAは、二ラベル&lt;サービス&gt;名前、プラスと同じドメインであるPTRレコードのセットを、もたらし例えば、 &#34;_http._tcp。&lt;ドメイン&gt;&#34;。 PTRのRDATA内ドメインを含むユニキャストDNS応答でわずかに良い名前を圧縮することができますが、唯一の最初の2つのラベルは、サービスタイプ列挙の目的のために関連しています。これら二つのラベルサービスタイプは、この&lt;ドメイン&gt;等で、そのサービスタイプのインスタンスを検出するために、その後のサービスインスタンス列挙PTRクエリを構築するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Populating the DNS with Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.情報とDNSを移植
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
How a service&#39;s PTR, SRV, and TXT records make their way into the DNS is outside the scope of this document, but, for illustrative purposes, some examples are given here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスのPTR、SRV、およびTXTレコードを作るどのようにDNSへの道は、この文書の範囲外であるが、例示の目的のために、いくつかの例がここに与えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On some networks, the administrator might manually enter the records into the name server&#39;s configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のネットワークでは、管理者が手動でネームサーバーの設定ファイルにレコードを入力することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A network monitoring tool could output a standard zone file to be read into a conventional DNS server. For example, a tool that can find networked PostScript laser printers using AppleTalk NBP could find the list of printers, communicate with each one to find its IP address, PostScript version, installed options, etc., and then write out a DNS zone file describing those printers and their capabilities using DNS resource records. That information would then be available to IP-only clients that implement DNS-SD but not AppleTalk NBP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力標準のゾーンファイルを可能性のあるネットワーク監視ツールは、従来のDNSサーバに読み込まれます。例えば、AppleTalkのNBPを使用して、ネットワークのPostScriptレーザプリンタを見つけることができるツールは、プリンタのリストを見つけることができ、そのIPアドレス、PostScript版、インストールオプション、等を見つけるために、それぞれと通信し、次に説明するDNSゾーンファイルを書き出しますDNSリソースレコードを使用してこれらのプリンタとその機能。この情報は、DNS-SDはなく、AppleTalkのNBPを実装するIPのみのクライアントで使用可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A printer manager device that has knowledge of printers on the network through some other management protocol could also output a zone file or use DNS Update [RFC2136] [RFC3007].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、ゾーン・ファイルを出力またはDNSアップデート[RFC2136]、[RFC3007]を使用することができるいくつかの他の管理プロトコルを介してネットワーク上のプリンタの知識を有するプリンタ管理装置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Alternatively, a printer manager device could implement enough of the DNS protocol that it is able to answer DNS queries directly, and Example Co.&#39;s main DNS server could delegate the &#34;_ipp._tcp.example.com.&#34; subdomain to the printer manager device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、プリンタマネージャデバイスは、直接DNSクエリに答えることが可能であるDNSプロトコルの十分に実装することができ、および例（株）の主要なDNSサーバーは委任することができ、「_ipp._tcp.example.com。」プリンタマネージャのデバイスへのサブドメイン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IP printers could use Dynamic DNS Update [RFC2136] [RFC3007] to automatically register their own PTR, SRV, and TXT records with the DNS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPプリンタは自動的にDNSサーバに自分のPTR、SRV、およびTXTレコードを登録するダイナミックDNSアップデート[RFC2136] [RFC3007]を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Zeroconf printers answer Multicast DNS queries on the local link for their own PTR, SRV, and TXT names ending with &#34;.local.&#34; [RFC6762].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Zeroconfをプリンタはで終わる自分のPTR、SRV、およびTXT名のローカルリンク上のマルチキャストDNSクエリに答える「.localの。」 [RFC6762]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Discovery of Browsing and Registration Domains (Domain Enumeration)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
閲覧と登録ドメインの11ディスカバリー（ドメイン列挙）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One of the motivations for DNS-based Service Discovery is to enable a visiting client (e.g., a Wi-Fi-equipped [IEEEW] laptop computer, tablet, or mobile telephone) arriving on a new network to discover what services are available on that network, without any manual configuration. The logic that discovering services without manual configuration is a good idea also dictates that discovering recommended registration and browsing domains without manual configuration is a similarly good idea.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNSベースのサービス発見のための動機の一つが訪れるクライアント（例えば、のWi-Fiを搭載した[IEEEW]ラップトップコンピュータ、タブレット、または携帯電話）のサービスがその上で使用可能なものを発見するために、新しいネットワークに到着できるようにすることですネットワーク、任意の手動設定なし。手動設定なしでサービスを発見するのも良いアイデアですロジックは、手動設定せずにお勧めの登録と閲覧のドメインを発見すると、同様に良い考えであることを指示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This discovery is performed using DNS queries, using Unicast or Multicast DNS. Five special RR names are reserved for this purpose:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この発見は、ユニキャストまたはマルチキャストDNSを使用して、DNSクエリを使用して行われます。ファイブ特別RR名は、この目的のために予約されています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          b._dns-sd._udp.&lt;domain&gt;.
         db._dns-sd._udp.&lt;domain&gt;.
          r._dns-sd._udp.&lt;domain&gt;.
         dr._dns-sd._udp.&lt;domain&gt;.
         lb._dns-sd._udp.&lt;domain&gt;.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By performing PTR queries for these names, a client can learn, respectively:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの名前のためのPTRクエリを実行することにより、クライアントはそれぞれ、学ぶことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A list of domains recommended for browsing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oドメインのリストは、ブラウジングのためにお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A single recommended default domain for browsing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブラウジングのための単一の推奨されるデフォルトのドメインO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A list of domains recommended for registering services using Dynamic Update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oドメインのリストには、動的更新を使用してサービスを登録するための推奨しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A single recommended default domain for registering services.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスを登録するための単一の推奨されるデフォルトのドメインO。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The &#34;legacy browsing&#34; or &#34;automatic browsing&#34; domain(s). Sophisticated client applications that care to present choices of domain to the user use the answers learned from the previous four queries to discover the domains to present. In contrast, many current applications browse without specifying an explicit domain, allowing the operating system to automatically select an appropriate domain on their behalf. It is for this class of application that the &#34;automatic browsing&#34; query is provided, to allow the network administrator to communicate to the client operating systems which domain(s) should be used automatically for these applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O「レガシーブラウジング」または「自動ブラウジング」のドメイン（秒）。利用者へのドメインの選択肢を提示する気に洗練されたクライアントアプリケーションが提示するドメインを発見する前の4つのクエリから学んだの回答を使用しています。これとは対照的に、多くの現在のアプリケーションは、オペレーティング・システムが自動的に代わって適切なドメインを選択できるように、明示的なドメインを指定せずに参照します。これは、ネットワーク管理者がどのドメイン（単数または複数）は、これらのアプリケーションに自動的に使用されなければならないクライアントオペレーティングシステムと通信できるようにするために、「自動ブラウジング」クエリが提供されているアプリケーションのこのクラスのためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These domains are purely advisory. The client or user is free to register services and/or browse in any domains. The purpose of these special queries is to allow software to create a user interface that displays a useful list of suggested choices to the user, from which the user may make an informed selection, or ignore the offered suggestions and manually enter their own choice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのドメインは純粋に助言しています。クライアントまたはユーザーがサービスを登録および/または任意のドメインで閲覧は無料です。これらの特別なクエリの目的は、ユーザが情報の選択を行う、または提供の提案を無視して、手動で自分の選択を入力することができ、そこからユーザへの提案の選択肢の便利なリストを表示するユーザーインターフェイスを作成するためのソフトウェアをできるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &lt;domain&gt; part of the Domain Enumeration query name may be &#34;local.&#34; (meaning &#34;perform the query using link-local multicast&#34;) or it may be learned through some other mechanism, such as the DHCP &#34;Domain&#34; option (option code 15) [RFC2132], the DHCP &#34;Domain Search&#34; option (option code 119) [RFC3397], or IPv6 Router Advertisement Options [RFC6106].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;ドメイン&gt;は、ドメイン列挙クエリ名の一部は「ローカル」であり得ます。 （「リンクローカルマルチキャストを使用してクエリを実行する」を意味する）か、DHCPなど、いくつかの他の機構を介して知ることができる「ドメイン」オプション（オプションコード15）[RFC2132]、DHCP「ドメイン検索」オプション（オプションコード119）[RFC3397]、またはIPv6ルータ広告オプション[RFC6106]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &lt;domain&gt; part of the query name may also be derived a different way, from the host&#39;s IP address. The host takes its IP address and calculates the logical AND of that address and its subnet mask, to derive the &#39;base&#39; address of the subnet (the &#39;network address&#39; of that subnet, or, equivalently, the IP address of the &#39;all-zero&#39; host address on that subnet). It then constructs the conventional DNS &#34;reverse mapping&#34; name corresponding to that base address, and uses that as the &lt;domain&gt; part of the name for the queries described above. For example, if a host has the address 192.168.12.34, with the subnet mask 255.255.0.0, then the &#39;base&#39; address of the subnet is 192.168.0.0, and to discover the recommended automatic browsing domain(s) for devices on this subnet, the host issues a DNS PTR query for the name &#34;lb._dns-sd._udp.0.0.168.192.in-addr.arpa.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クエリ名の&lt;ドメイン&gt;の部分は、ホストのIPアドレスから、別の方法を導出することができます。ホストは、サブネットの「ベース」のアドレス（そのサブネットの「ネットワークアドレス」、または、同等に、「すべてのIPアドレスを導き出すために、そのIPアドレスを受け取り、論理AND、そのアドレスとサブネットマスクのを算出し、そのサブネット上-zero」ホストアドレス）。これは、そのベースアドレスに対応する従来のDNS「逆マッピング」名を構築し、上述したクエリの名前の&lt;ドメイン&gt;一部としてそれを使用します。ホストは、サブネットマスク255.255.0.0とアドレス192.168.12.34を、持っている場合たとえば、その後、サブネットの「ベース」のアドレスは192.168.0.0であり、この上のデバイスのために推奨される自動ブラウジングドメイン（複数可）を発見しますサブネット、ホストは名前のためのDNS PTRクエリを発行「lb._dns-sd._udp.0.0.168.192.in-addr.arpaを。」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Equivalent address-derived Domain Enumeration queries should also be done for the host&#39;s IPv6 address(es).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
等価アドレス由来のドメイン列挙クエリーは、ホストのIPv6アドレス（複数可）のために行われるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Address-derived Domain Enumeration queries SHOULD NOT be done for IPv4 link-local addresses [RFC3927] or IPv6 link-local addresses [RFC4862].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
住所由来のドメイン列挙クエリーは、IPv4リンクローカルアドレス[RFC3927]またはIPv6リンクローカルアドレス[RFC4862]のために行われるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sophisticated clients may perform Domain Enumeration queries both in &#34;local.&#34; and in one or more unicast domains, using both name-derived and address-derived queries, and then present the user with an combined result, aggregating the information received from all sources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
洗練されたクライアントは、ドメイン列挙の中に両方のクエリを実行する「ローカル」。および1つ以上のユニキャストドメインで、すべてのソースから受信した情報を集約し、合成結果をユーザに提示し、名前由来およびアドレス由来のクエリーの両方を使用して、そして。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. DNS Additional Record Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. DNSの追加レコードの生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS has an efficiency feature whereby a DNS server may place additional records in the additional section of the DNS message. These additional records are records that the client did not explicitly request, but the server has reasonable grounds to expect that the client might request them shortly, so including them can save the client from having to issue additional queries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNSは、DNSサーバがDNSメッセージの追加セクションに追加のレコードを配置することができることにより、効率の特徴を有しています。これらの追加のレコードは、クライアントが明示的に要求していないレコードですが、サーバーはので、それらは追加のクエリを発行することからクライアントを保存することができます含め、クライアントはすぐにそれらを要求する可能性があることを期待する合理的な根拠を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section recommends which additional records SHOULD be generated to improve network efficiency, for both Unicast and Multicast DNS-SD responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、追加のレコードがユニキャストとマルチキャストDNS-SD応答の両方のために、ネットワークの効率を改善するために生成されるべきお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that while servers SHOULD add these additional records for efficiency purposes, as with all DNS additional records, it is the client&#39;s responsibility to determine whether or not to trust them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバは、効率のために、これらの追加レコードを追加する必要がありますが、すべてのDNSレコードの追加と同様に、彼らを信頼するかどうかを決定するために、クライアントの責任であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Generally speaking, stub resolvers that talk to a single recursive name server for all their queries will trust all records they receive from that recursive name server (whom else would they ask?). Recursive name servers that talk to multiple authoritative name servers should verify that any records they receive from a given authoritative name server are &#34;in bailiwick&#34; for that server, and ignore them if not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的に言えば、すべてのクエリに対して、単一の再帰ネームサーバと通信スタブリゾルバは、（彼らは他の誰に頼む？）彼らはその再帰ネームサーバから受信したすべてのレコードを信頼します。複数の権威ネームサーバに話を再帰ネームサーバは、彼らが与えられた権威ネームサーバから受信したすべてのレコードは、そのサーバー用の「bailiwick中」であることを確認し、ない場合はそれらを無視すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients MUST be capable of functioning correctly with DNS servers (and Multicast DNS Responders) that fail to generate these additional records automatically, by issuing subsequent queries for any further record(s) they require. The additional-record generation rules in this section are RECOMMENDED for improving network efficiency, but are not required for correctness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、彼らが必要とする、さらにレコード（複数可）に対する後続のクエリを発行することにより、自動的にこれらの追加レコードを生成するために失敗するDNSサーバ（およびマルチキャストDNS応答者）で正しく機能することができなければなりません。このセクションで追加のレコード生成規則は、ネットワークの効率を改善するために推奨されているが、正確さのために必要とされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. PTR Records
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1。 PTRレコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When including a DNS-SD Service Instance Enumeration or Selective Instance Enumeration (subtype) PTR record in a response packet, the server/responder SHOULD include the following additional records:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答パケットでDNS-SDサービスインスタンス列挙または選択インスタンスの列挙（サブタイプ）PTRレコードを含む場合は、サーバー/レスポンダは、以下の追加のレコードを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The SRV record(s) named in the PTR rdata. o The TXT record(s) named in the PTR rdata. o All address records (type &#34;A&#34; and &#34;AAAA&#34;) named in the SRV rdata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PTRのRDATAで命名SRVレコード（複数可）、O。 PTRのRDATAで命名TXTレコード（複数可）、O。 SRVのRDATAで指定されているすべてのアドレスレコード（タイプ「A」と「AAAA」）、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. SRV Records
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2。 SRVレコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When including an SRV record in a response packet, the server/responder SHOULD include the following additional records:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答パケットでSRVレコードを含む場合は、サーバー/レスポンダは、以下の追加のレコードを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o All address records (type &#34;A&#34; and &#34;AAAA&#34;) named in the SRV rdata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SRVのRDATAで指定されているすべてのアドレスレコード（タイプ「A」と「AAAA」）、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. TXT Records
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3。 TXTレコード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When including a TXT record in a response packet, no additional records are required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答パケットでTXTレコードを含む場合には、追加のレコードは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4. Other Record Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.4。他のレコードタイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In response to address queries, or other record types, no new additional records are recommended by this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アドレスの問い合わせ、または他のレコードの種類に応じて、新たな追加のレコードは、このドキュメントで推奨されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Working Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.作業の例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following examples were prepared using standard unmodified nslookup and standard unmodified BIND running on GNU/Linux.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の実施例は、標準的な無修正nslookupコマンドおよびGNU / Linux上で実行されている標準の未修正のBINDを使用して調製しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: In real products, this information is obtained and presented to the user using graphical network browser software, not command-line tools. However, if you wish, you can try these examples for yourself as you read along, using the nslookup command already available on most Unix machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：実際の製品では、この情報が取得され、グラフィカルなネットワークブラウザソフトウェアを使用してユーザに提示さではなく、コマンドラインツール。あなたが望むなら、あなたが一緒に読んしかし、あなたはほとんどのUnixマシン上ですでに利用可能なnslookupコマンドを使用して、自分のためにこれらの例を試すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. What web pages are being advertised from dns-sd.org?
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1。どのようなウェブページはdns-sd.orgから宣伝されていますか？
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
nslookup -q=ptr _http._tcp.dns-sd.org. _http._tcp.dns-sd.org name = Zeroconf._http._tcp.dns-sd.org _http._tcp.dns-sd.org name = Multicast\032DNS._http._tcp.dns-sd.org _http._tcp.dns-sd.org name = Service\032Discovery._http._tcp.dns-sd.org _http._tcp.dns-sd.org name = Stuart&#39;s\032Printer._http._tcp.dns-sd.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
nslookupコマンド-q = PTR _http._tcp.dns-sd.org。 _http._tcp.dns-sd.org名= Zeroconf._http._tcp.dns-sd.org _http._tcp.dns-sd.org名=マルチキャスト\ 032DNS._http._tcp.dns-sd.org _http._tcp。 dns-sd.org名=サービス\ 032Discovery._http._tcp.dns-sd.org _http._tcp.dns-sd.org名=スチュアートの\ 032Printer._http._tcp.dns-sd.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Answer: There are four, called &#34;Zeroconf&#34;, &#34;Multicast DNS&#34;, &#34;Service Discovery&#34;, and &#34;Stuart&#39;s Printer&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
回答：「Zeroconfを」と呼ばれる4つがあります、「マルチキャストDNS」を、「サービス発見」、および「スチュアートのプリンタ」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that nslookup escapes spaces as &#34;\032&#34; for display purposes, but a graphical DNS-SD browser should not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのnslookupコマンドが表示目的のために、「\ 032」のようにスペースをエスケープしますが、グラフィカルなDNS-SDブラウザはすべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. What printer-configuration web pages are there?
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2。どのようなプリンタの設定のWebページがありますか？
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
nslookup -q=ptr _printer._sub._http._tcp.dns-sd.org. _printer._sub._http._tcp.dns-sd.org name = Stuart&#39;s\032Printer._http._tcp.dns-sd.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
nslookupコマンド-q = PTR _printer._sub._http._tcp.dns-sd.org。 _printer._sub._http._tcp.dns-sd.org名=スチュアートの\ 032Printer._http._tcp.dns-sd.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Answer: &#34;Stuart&#39;s Printer&#34; is the web configuration UI of a network printer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
回答：「スチュアートのプリンタは」ネットワークプリンタのWeb構成UIです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. How do I access the web page called &#34;Service Discovery&#34;?
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3。どのように私は「サービス発見」と呼ばれるWebページにアクセスできますか？
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
nslookup -q=any &#34;Service\032Discovery._http._tcp.dns-sd.org.&#34; Service\032Discovery._http._tcp.dns-sd.org priority = 0, weight = 0, port = 80, host = dns-sd.org Service\032Discovery._http._tcp.dns-sd.org text = &#34;txtvers=1&#34; &#34;path=/&#34; dns-sd.org nameserver = ns1.dns-sd.org dns-sd.org internet address = 64.142.82.154 ns1.dns-sd.org internet address = 64.142.82.152
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
nslookupコマンド-q =任意の &#34;サービス\ 032Discovery._http._tcp.dns-sd.org。&#34;サービス\ 032Discovery._http._tcp.dns-sd.org優先= 0、重量= 0、ポート= 80、ホスト= dns-sd.orgサービス\ 032Discovery._http._tcp.dns-sd.orgテキスト=「txtvers = 1&#34; &#34;パス= /&#34; dns-sd.orgネームサーバ= ns1.dns-sd.org dns-sd.orgインターネットアドレス= 64.142.82.154 ns1.dns-sd.orgインターネットアドレス= 64.142.82.152
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Answer: You need to connect to dns-sd.org port 80, path &#34;/&#34;. The address for dns-sd.org is also given (64.142.82.154).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
回答：あなたはポート80をdns-sd.orgに接続する必要があり、パス「/」。 dns-sd.orgのためのアドレスは、（64.142.82.154）与えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. IPv6 Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. IPv6の上の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPv6 has only minor differences from IPv4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPv6は、IPv4からわずかな違いがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The address of the SRV record&#39;s target host is given by the appropriate IPv6 &#34;AAAA&#34; address records instead of (or in addition to) IPv4 &#34;A&#34; records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SRVレコードのターゲットホストのアドレスは、適切なIPv6の「AAAA」アドレスレコードの代わりに（またはそれに加えて）のIPv4「」のレコードで与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Address-based Domain Enumeration queries are performed using names under the IPv6 reverse-mapping tree, which is different from the IPv4 reverse-mapping tree and has longer names in it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アドレスベースのドメイン列挙クエリは、IPv4の逆マッピングツリーとは異なり、その中に長い名前を持っているIPv6の逆マッピングツリー、下の名前を使用して実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since DNS-SD is just a specification for how to name and use records in the existing DNS system, it has no specific additional security requirements over and above those that already apply to DNS queries and DNS updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS-SDは、既存のDNSシステム内のレコードに名前を付け、使用方法のためだけの仕様ですので、それは、特定の追加のセキュリティ要件を超えると、すでにDNSクエリーとDNSの更新に適用されるもの以上を持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For DNS queries, DNS Security Extensions (DNSSEC) [RFC4033] should be used where the authenticity of information is important.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
情報の信憑性が重要であるDNSクエリの場合は、DNSセキュリティ拡張機能（DNSSEC）[RFC4033]は使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For DNS updates, secure updates [RFC2136] [RFC3007] should generally be used to control which clients have permission to update DNS records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNSの更新については、安全な更新[RFC2136] [RFC3007]は、一般的にDNSレコードを更新する権限を持っているクライアントを制御するために使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA manages the namespace of unique Service Names [RFC6335].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、ユニークなサービス名[RFC6335]の名前空間を管理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a protocol service advertising specification includes subtypes, these should be documented in the protocol specification in question and/or in the &#34;notes&#34; field of the registration request sent to IANA. In the event that a new subtype becomes relevant after a protocol specification has been published, this can be recorded by requesting that IANA add it to the &#34;notes&#34; field. For example, vendors of network printers advertise their embedded web servers using the subtype _printer. This allows printer management clients to browse for only printer-related web servers by browsing for the _printer subtype. While the existence of the _printer subtype of _http._tcp is not directly relevant to the HTTP protocol specification, it is useful to record this usage in the IANA registry to help avoid another community of developers inadvertently using the same subtype string for a different purpose. The namespace of possible subtypes is separate for each different service type. For example, the existence of the _printer subtype of _http._tcp does not imply that the _printer subtype is defined or has any meaning for any other service type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコルサービスの広告仕様がサブタイプを含む場合、これらは、および/またはIANAに送信された登録要求の「ノート」フィールドに問題のプロトコル仕様で文書化されなければなりません。プロトコル仕様が公開された後に新しいサブタイプが関連になった場合には、これはIANAは、「ノート」フィールドに追加することを要求することにより記録することができます。たとえば、ネットワークプリンタのベンダーは、サブタイプ_printerを使用して、埋め込みWebサーバを宣伝します。これは、プリンタ管理クライアントは_printerサブタイプをブラウズするだけで、プリンタ関連のWebサーバを参照することができます。 _http._tcpの_printerサブタイプの存在がHTTPプロトコル仕様とは直接関係ありませんが、不注意に異なる目的のために、同じサブタイプの文字列を使用している開発者の別のコミュニティを避けるためにIANAレジストリにこの用法を記録するのに便利です。可能なサブタイプの名前空間には、それぞれ異なるサービスタイプの別のものです。例えば、_http._tcpの_printerサブタイプの存在が_printerサブタイプが定義されたり、他のサービスタイプのいずれかの意味を持っていることを意味するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When IANA records a Service Name registration, if the new application protocol is one that conceptually duplicates existing functionality of an older protocol, and the implementers desire the Flagship Naming behavior described in Section 8, then the registrant should request that IANA record the name of the flagship protocol in the &#34;notes&#34; field of the new registration. For example, the registrations for &#34;ipp&#34; and &#34;pdl-datastream&#34; both reference &#34;printer&#34; as the flagship name for this family of printing-related protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、サービス名の登録を記録すると、新しいアプリケーション・プロトコルは、概念的に古いプロトコルの既存の機能と重複するものであり、実装者は、第8章で説明旗艦命名動作を望む場合は、登録者がIANAはの名前を記録することを要求する必要があります新規登録の「ノート」フィールドに主力プロトコル。例えば、「IPP」と印刷関連プロトコルのこのファミリーのための主力名として「PDL-データストリーム」の両方の基準「プリンタ」の登録。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The concepts described in this document have been explored, developed, and implemented with help from Ran Atkinson, Richard Brown, Freek Dijkstra, Ralph Droms, Erik Guttman, Pasi Sarolahti, Pekka Savola, Mark Townsley, Paul Vixie, Bill Woodcock, and others. Special thanks go to Bob Bradley, Josh Graessley, Scott Herscher, Rory McGuire, Roger Pantos, and Kiren Sekar for their significant contributions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書に記載された概念は、探求開発、および蘭アトキンソン、リチャード・ブラウン、フリークダイクストラ、ラルフDroms、エリック・ガットマン、パシSarolahti、ペッカSavola、マークTownsley、ポール・ヴィクシー、ビル・ウッドコック、そして他人からの助けを借りて実施されています。特別な感謝は彼らの重要な貢献のためのボブ・ブラッドリー、ジョシュGraessley、スコットHerscher、ロリー・マクガイア、ロジャーPantos、およびKirenスカールに行きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC20] Cerf, V., &#34;ASCII format for network interchange&#34;, RFC 20, October 1969.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC20]サーフ、V.、 &#34;ネットワークの交換のためのASCIIフォーマット&#34;、RFC 20、1969年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1033] Lottor, M., &#34;Domain Administrators Operations Guide&#34;, RFC 1033, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1033] Lottor、M.、 &#34;ドメイン管理者操作ガイド&#34;、RFC 1033、1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1034] Mockapetris, P., &#34;Domain names - concepts and facilities&#34;, STD 13, RFC 1034, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1034] Mockapetris、P.、 &#34;ドメイン名 - 概念と設備&#34;、STD 13、RFC 1034、1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1035] Mockapetris, P., &#34;Domain names - implementation and specification&#34;, STD 13, RFC 1035, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1035] Mockapetris、P.、 &#34;ドメイン名 - 実装及び仕様&#34;、STD 13、RFC 1035、1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, &#34;A DNS RR for specifying the location of services (DNS SRV)&#34;, RFC 2782, February 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2782] Gulbrandsenの、A.、いるVixie、P.、およびL. Esibov、 &#34;サービスの場所を特定するためのDNS RR（DNSのSRV）&#34;、RFC 2782、2000年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3492] Costello, A., &#34;Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)&#34;, RFC 3492, March 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3492]コステロ、A.、 &#34;ピュニコード：アプリケーションにおける国際化ドメイン名のUnicodeのブートストリングのエンコード（IDNA）&#34;、RFC 3492、2003年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3629] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, STD 63, RFC 3629, November 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3629] Yergeau、F.、 &#34;UTF-8、ISO 10646の変換フォーマット&#34;、STD 63、RFC 3629、2003年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3927] Cheshire, S., Aboba, B., and E. Guttman, &#34;Dynamic Configuration of IPv4 Link-Local Addresses&#34;, RFC 3927, May 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3927]チェシャー、S.、Aboba、B.、およびE.ガットマン、 &#34;IPv4のリンクローカルアドレスの動的構成&#34;、RFC 3927、2005年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4862] Thomson, S., Narten, T., and T. Jinmei, &#34;IPv6 Stateless Address Autoconfiguration&#34;, RFC 4862, September 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4862]トムソン、S.、Narten氏、T.、およびT.神明、 &#34;IPv6のステートレスアドレス自動設定&#34;、RFC 4862、2007年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5198] Klensin, J. and M. Padlipsky, &#34;Unicode Format for Network Interchange&#34;, RFC 5198, March 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5198] Klensin、J.とM. Padlipsky、 &#34;ネットワークインターチェンジのUnicodeフォーマット&#34;、RFC 5198、2008年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5890] Klensin, J., &#34;Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework&#34;, RFC 5890, August 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5890] Klensin、J.、 &#34;アプリケーション（IDNA）のための国際化ドメイン名：定義とドキュメントフレームワーク&#34;、RFC 5890、2010年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6335] Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S. Cheshire, &#34;Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry&#34;, BCP 165, RFC 6335, August 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6335]コットン、M.、エッゲルト、L.、タッチ、J.、ウェスター、M.、およびS.チェシャー、「IANA（Internet Assigned Numbers Authority）のサービス名とトランスポートプロトコルポート番号レジストリの管理のための手順」、BCP 165、RFC 6335、2011年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AFP] Mac OS X Developer Library, &#34;Apple Filing Protocol Programming Guide&#34;, &lt;http://developer.apple.com/ documentation/Networking/Conceptual/AFP/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AFP]のMac OS Xの開発ライブラリ、 &#34;アップルファイリングプロトコルプログラミングガイド&#34;、&lt;http://developer.apple.com/ドキュメント/ネットワーク/概念/ AFP /&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BJ] Apple Bonjour Open Source Software, &lt;http://developer.apple.com/bonjour/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BJ]アップルのBonjourオープンソースソフトウェア、&lt;http://developer.apple.com/bonjour/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BJP] Bonjour Printing Specification, &lt;https://developer.apple.com/bonjour/ printing-specification/bonjourprinting-1.0.2.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【BJP] Bonjourの印刷仕様&lt;https://developer.apple.com/bonjour/印刷仕様/ bonjourprinting-1.0.2.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IEEEW] IEEE 802 LAN/MAN Standards Committee, &lt;http://standards.ieee.org/wireless/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IEEEW] IEEE 802 LAN / MAN標準委員会、&lt;http://standards.ieee.org/wireless/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[NIAS] Cheshire, S., &#34;Discovering Named Instances of Abstract Services using DNS&#34;, Work in Progress, July 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「DNSを使用して抽象サービスの名前付きインスタンスを検出」[NIAS]チェシャー、S.、進歩、2001年7月での作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[NSD] &#34;NsdManager | Android Developer&#34;, June 2012, &lt;http://developer.android.com/reference/android/ net/nsd/NsdManager.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[NSD] &#34;NsdManager | Androidデベロッパー&#34;、2012年6月、&lt;http://developer.android.com/reference/android/ネット/ NSD / NsdManager.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1179] McLaughlin, L., &#34;Line printer daemon protocol&#34;, RFC 1179, August 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1179]マクラフリン、L.、 &#34;ラインプリンタデーモンプロトコル&#34;、RFC 1179、1990年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2132] Alexander, S. and R. Droms, &#34;DHCP Options and BOOTP Vendor Extensions&#34;, RFC 2132, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2132]アレクサンダー、S.とR. Droms、 &#34;DHCPオプションとBOOTPベンダー拡張機能&#34;、RFC 2132、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2136] Vixie, P., Ed., Thomson, S., Rekhter, Y., and J. Bound, &#34;Dynamic Updates in the Domain Name System (DNS UPDATE)&#34;, RFC 2136, April 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2136]いるVixie、P.編、トムソン、S.、Rekhter、Y.、およびJ.はバウンド、 &#34;ドメインネームシステムにおける動的更新（DNS更新）&#34;、RFC 2136、1997年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2181] Elz, R. and R. Bush, &#34;Clarifications to the DNS Specification&#34;, RFC 2181, July 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;DNS仕様の明確化&#34; [RFC2181]エルツ、R.とR.ブッシュ、RFC 2181、1997年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2910] Herriot, R., Ed., Butler, S., Moore, P., Turner, R., and J. Wenn, &#34;Internet Printing Protocol/1.1: Encoding and Transport&#34;, RFC 2910, September 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2910]エリオ、R.、エド、バトラー、S.、ムーア、P.、ターナー、R.、およびJ. Wenn、 &#34;インターネット印刷プロトコル/ 1.1：コード化とTransport&#34;、RFC 2910、2000年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4960] Stewart, R., Ed., &#34;Stream Control Transmission Protocol&#34;, RFC 4960, September 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4960]スチュワート、R.、エド。、 &#34;ストリーム制御伝送プロトコル&#34;、RFC 4960、2007年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3007] Wellington, B., &#34;Secure Domain Name System (DNS) Dynamic Update&#34;, RFC 3007, November 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3007]ウェリントン、B.、RFC 3007、2000年11月 &#34;ドメインネームシステム（DNS）動的更新をセキュア&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4340] Kohler, E., Handley, M., and S. Floyd, &#34;Datagram Congestion Control Protocol (DCCP)&#34;, RFC 4340, March 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4340]コーラー、E.、ハンドリー、M.、およびS.フロイド、 &#34;データグラム輻輳制御プロトコル（DCCP）&#34;、RFC 4340、2006年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3397] Aboba, B. and S. Cheshire, &#34;Dynamic Host Configuration Protocol (DHCP) Domain Search Option&#34;, RFC 3397, November 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3397] Aboba、B.とS.チェシャー、 &#34;動的ホスト構成プロトコル（DHCP）ドメイン検索オプション&#34;、RFC 3397、2002年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4033] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &#34;DNS Security Introduction and Requirements&#34;, RFC 4033, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4033]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 &#34;DNSセキュリティ序論と要件&#34;、RFC 4033、2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4648] Josefsson, S., &#34;The Base16, Base32, and Base64 Data Encodings&#34;, RFC 4648, October 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4648] Josefsson氏、S.、 &#34;Base16、Base32、およびBase64でデータエンコーディング&#34;、RFC 4648、2006年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4795] Aboba, B., Thaler, D., and L. Esibov, &#34;Link-local Multicast Name Resolution (LLMNR)&#34;, RFC 4795, January 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4795] Aboba、B.、ターラー、D.、およびL. Esibov、 &#34;リンクローカルマルチキャスト名前解決（LLMNR）&#34;、RFC 4795、2007年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6106] Jeong, J., Park, S., Beloeil, L., and S. Madanapalli, &#34;IPv6 Router Advertisement Options for DNS Configuration&#34;, RFC 6106, November 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6106]チョン、J.、公園、S.、Beloeilの、L.、およびS. Madanapalli、 &#34;DNS設定のためのIPv6ルータアドバタイズメントのオプション&#34;、RFC 6106、2010年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6281] Cheshire, S., Zhu, Z., Wakikawa, R., and L. Zhang, &#34;Understanding Apple&#39;s Back to My Mac (BTMM) Service&#34;, RFC 6281, June 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6281]チェシャー、S.、朱、Z.、Wakikawa、R.、およびL.チャン、RFC 6281、2011年6月に &#34;どこでもMy Mac（BTMM）サービスにAppleのバックを理解します&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6709] Carpenter, B., Aboba, B., Ed., and S. Cheshire, &#34;Design Considerations for Protocol Extensions&#34;, RFC 6709, September 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6709]大工、B.、Aboba、B.、エド。、およびS.チェシャー、 &#34;プロトコル拡張のための設計上の考慮事項&#34;、RFC 6709、2012年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6760] Cheshire, S. and M. Krochmal, &#34;Requirements for a Protocol to Replace the AppleTalk Name Binding Protocol (NBP)&#34;, RFC 6760, February 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6760]チェシャー、S.及びM. Krochmal、RFC 6760、2013年2月 &#34;プロトコル（NBP）に結合AppleTalkの名前を交換するためのプロトコルのための要件&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6762] Cheshire, S. and M. Krochmal, &#34;Multicast DNS&#34;, RFC 6762, February 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6762]チェシャー、S.及びM. Krochmal、 &#34;マルチキャストDNS&#34;、RFC 6762、2013年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SN] IANA, &#34;Service Name and Transport Protocol Port Number Registry&#34;, &lt;http://www.iana.org/assignments/ service-names-port-numbers/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SN] IANA、「サービス名とトランスポートプロトコルポート番号レジストリ」、&lt;http://www.iana.org/assignments/サービス名・ポート番号/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SOAP] Mitra, N., &#34;SOAP Version 1.2 Part 0: Primer&#34;, W3C Proposed Recommendation 24 June 2003, &lt;http://www.w3.org/TR/2003/REC-soap12-part0-20030624&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SOAP]ミトラ、N.、 &#34;SOAPバージョン1.2パート0：入門&#34;、W3C勧告案2003年6月24日、&lt;http://www.w3.org/TR/2003/REC-soap12-part0-20030624&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Unicode6] The Unicode Consortium. The Unicode Standard, Version 6.0.0, (Mountain View, CA: The Unicode Consortium, 2011. ISBN 978-1-936213-01-6) &lt;http://www.unicode.org/versions/Unicode6.0.0/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【Unicode6]ユニコードコンソーシアム。 Unicode標準、バージョン6.0.0、（カリフォルニア州マウンテンビュー：ユニコードコンソーシアム、2011年ISBN 978-1-936213-01-6）&lt;http://www.unicode.org/versions/Unicode6.0.0/&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ZC] Cheshire, S. and D. Steinberg, &#34;Zero Configuration Networking: The Definitive Guide&#34;, O&#39;Reilly Media, Inc., ISBN 0-596-10100-7, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ZC]チェシャー、S.およびD.スタインバーグ、 &#34;ゼロ構成ネットワーキング：Definitive Guideの&#34;、オライリーメディア社、ISBN 0-596-10100-7、2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A. Rationale for Using DNS as a Basis for Service Discovery
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス発見のための基礎としてDNSを使用するための付録A.根拠
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Over the years, there have been many proposed ways to do network service discovery with IP, but none achieved ubiquity in the marketplace. Certainly none has achieved anything close to the ubiquity of today&#39;s deployment of DNS servers, clients, and other infrastructure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
長年にわたり、IPとネットワークサービス検出を行うために多くの提案の方法があったが、いずれも市場で広く普及を達成していません。確かにどれもDNSサーバ、クライアント、およびその他のインフラの今日の展開の遍在に近い何かを達成していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The advantage of using DNS as the basis for service discovery is that it makes use of those existing servers, clients, protocols, infrastructure, and expertise. Existing network analyzer tools already know how to decode and display DNS packets for network debugging.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス検出のための基礎としてDNSを使用する利点は、それらの既存のサーバー、クライアント、プロトコル、インフラストラクチャ、および専門知識を利用していることです。既存のネットワークアナライザツールは、すでにネットワークのデバッグのためのDNSパケットをデコードして表示する方法を知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For ad hoc networks such as Zeroconf environments, peer-to-peer multicast protocols are appropriate. Using DNS-SD running over Multicast DNS [RFC6762] provides zero-configuration ad hoc service discovery, while maintaining the DNS-SD semantics and record types described here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのような環境のZeroconfとしてアドホックネットワークでは、ピア・ツー・ピア・マルチキャストプロトコルが適切です。ここで説明するDNS-SDセマンティクスとレコードタイプを維持しながら、マルチキャストDNS [RFC6762]上で実行されているDNS-SDを使用すると、ゼロコンフィギュレーションアドホック・サービスの発見を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In larger networks, a high volume of enterprise-wide IP multicast traffic may not be desirable, so any credible service discovery protocol intended for larger networks has to provide some facility to aggregate registrations and lookups at a central server (or servers) instead of working exclusively using multicast. This requires some service discovery aggregation server software to be written, debugged, deployed, and maintained. This also requires some service discovery registration protocol to be implemented and deployed for clients to register with the central aggregation server. Virtually every company with an IP network already runs a DNS server, and DNS already has a dynamic registration protocol [RFC2136] [RFC3007]. Given that virtually every company already has to operate and maintain a DNS server anyway, it makes sense to take advantage of this expertise instead of also having to learn, operate, and maintain a different service registration server. It should be stressed again that using the same software and protocols doesn&#39;t necessarily mean using the same physical piece of hardware. The DNS-SD service discovery functions do not have to be provided by the same piece of hardware that is currently providing the company&#39;s DNS name service. The &#34;_tcp.&lt;Domain&gt;&#34; and &#34;_udp.&lt;Domain&gt;&#34; subdomains may be delegated to a different piece of hardware. However, even when the DNS-SD service is being provided by a different piece of hardware, it is still the same familiar DNS server software, with the same configuration file syntax, the same log file format, and so forth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
大規模なネットワークでは、企業全体のIPマルチキャストトラフィックの高い量は望ましくないかもしれないので、大規模なネットワークのために意図され、任意の信頼できるサービス発見プロトコルは、集約登録およびルックアップ中央サーバに（またはサーバ）へのいくつかの機能を提供しなければならない代わりに、作業の専用のマルチキャストを使用。これは、書かれたデバッグ、配備、および維持するために、いくつかのサービス発見集計サーバソフトウェアが必要です。また、これは、中央集約サーバに登録するクライアントのために実装され、展開されるいくつかのサービス発見プロトコル登録が必要です。事実上、IPネットワークとすべての企業は、すでにDNSサーバを実行し、DNSはすでに動的登録プロトコル[RFC2136] [RFC3007]を持っています。ほぼすべての企業がすでにとにかくDNSサーバを運用し、維持しなければならないことを考えると、それは代わりにも、学び動作し、異なるサービス登録サーバを維持するので、この専門知識を活用するために理にかなっています。同じソフトウェアとプロトコルを使用することは必ずしもハードウェアの物理的に同じ曲を使用して意味しないことを再度強調されるべきです。 DNS-SDサービスディスカバリ機能は、現在、同社のDNSネームサービスを提供しているハードウェアの同じ部分によって提供されている必要はありません。 「_tcp。&lt;ドメイン&gt;」と「_udp。&lt;ドメイン&gt;」サブドメインは、ハードウェアの異なる部分に委任することができます。しかし、DNS-SDサービスは、ハードウェアの異なる部分によって提供されている場合でも、それは同じおなじみのDNSサーバソフトウェアは、など、同じコンフィギュレーション・ファイルの構文、同じログファイル形式、およびで、まだです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Service discovery needs to be able to provide appropriate security. DNS already has existing mechanisms for security [RFC4033].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス発見は、適切なセキュリティを提供できるようにする必要があります。 DNSはすでにセキュリティ[RFC4033]のための既存のメカニズムを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In summary:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要約すれば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Service discovery requires a central aggregation server. DNS already has one: a DNS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス発見は、中央集約サーバが必要です。 DNSサーバー：DNSはすでに1を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Service discovery requires a service registration protocol. DNS already has one: DNS Dynamic Update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス発見は、サービス登録プロトコルが必要です。 DNS動的更新：DNSはすでに1を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Service discovery requires a query protocol. DNS already has one: DNS queries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス発見は、クエリプロトコルが必要です。 DNSクエリ：DNSはすでに1を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Service discovery requires security mechanisms. DNS already has security mechanisms: DNSSEC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス検出は、セキュリティ・メカニズムが必要です。 DNSSEC：DNSはすでにセキュリティメカニズムを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Service discovery requires a multicast mode for ad hoc networks. Using DNS-SD in conjunction with Multicast DNS provides this, using peer-to-peer multicast instead of a DNS server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス検出は、アドホックネットワークのためのマルチキャストモードを必要とします。マルチキャストDNSと組み合わせて使用​​してDNS-SDは、ピアツーピアマルチキャスト代わりのDNSサーバを使用して、これを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It makes more sense to use the existing software that every network needs already, instead of deploying an entire parallel system just for service discovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それだけでなく、サービス発見のための全体の並列システムを展開するすべてのネットワークが既に必要既存のソフトウェアを、使用する方が理にかなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix B. Ordering of Service Instance Name Components
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス名のコンポーネントの付録B.発注
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There have been questions about why services are named using DNS Service Instance Names of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスは、フォームのDNSサービスインスタンス名を使用して命名されている理由についての質問がありました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Service Instance Name = &lt;Instance&gt; . &lt;Service&gt; . &lt;Domain&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス名= &lt;インスタンス&gt;。 &lt;サービス&gt;。 &lt;ドメイン&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
instead of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
の代わりに：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Service Instance Name = &lt;Service&gt; . &lt;Instance&gt; . &lt;Domain&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスインスタンス名= &lt;サービス&gt;。 &lt;インスタンス&gt;。 &lt;ドメイン&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are three reasons why it is beneficial to name service instances with the parent domain as the most-significant (rightmost) part of the name, then the abstract service type as the next-most significant, and then the specific instance name as the least-significant (leftmost) part of the name. These reasons are discussed below in Sections B.1, B.2, and B.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは名前の最上位（右端）の部分、次の最も重要なように、その後、抽象サービスの種類、および少なくともなど、特定のインスタンス名として親ドメインとネームサービスインスタンスに有益である3つの理由があります。 -significant（一番左）名前の一部。これらの理由は、セクションB.1、B.2、およびB.3に以下に議論されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1. Semantic Structure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1。意味構造
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The facility being provided by browsing (&#34;Service Instance Enumeration&#34;) is effectively enumerating the leaves of a tree structure. A given domain offers zero or more services. For each of those service types, there may be zero or more instances of that service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（「サービスインスタンス列挙」）を参照して提供されている施設は、効果的なツリー構造の葉を列挙しています。与えられたドメインは、ゼロ以上のサービスを提供しています。これらのサービスの種類ごとに、そのサービスのゼロ以上のインスタンスが存在してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The user knows what type of service they are seeking. (If they are running an FTP client, they are looking for FTP servers. If they have a document to print, they are looking for entities that speak some known printing protocol.) The user knows in which organizational or geographical domain they wish to search. (The user does not want a single flat list of every single printer on the planet, even if such a thing were possible.) What the user does not know in advance is whether the service they seek is offered in the given domain, or if so, the number of instances that are offered and the names of those instances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザーは、彼らが求めているサービスの種類を知っています。 （彼らはFTPクライアントを実行している場合、彼らはFTPサーバを探しています。彼らは印刷する文書を持っている場合、彼らはいくつかの既知の印刷プロトコルを話すエンティティを探しています。）ユーザーは、彼らが検索したい組織や地理的なドメインに知っています。 （ユーザーはそのようなことが可能であったとしても、地球上のすべての単一のプリンタの単一のフラットリストを望んでいません。）ユーザが事前に知っていない彼らは何を求めてサービスが特定のドメインに、または場合は提供されているかどうかでありますそう、提供されているインスタンスの数とそれらのインスタンスの名前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hence, having the instance names be the leaves of the tree is consistent with this semantic model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
したがって、インスタンス名がツリーの葉も持つことは、このセマンティックモデルと一致しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Having the service types be the terminal leaves of the tree would imply that the user knows the domain name and the name of the service instance, but doesn&#39;t have any idea what the service does. We would argue that this is a less useful model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスタイプは、ツリーの末端葉は、ユーザーがドメイン名とサービス・インスタンスの名前を知っているが、サービスが何をするか任意のアイデアを持っていないことを暗示することがあります。我々は、これはあまり有用なモデルであることを主張するだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2. Network Efficiency
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2。ネットワーク効率
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a DNS response contains multiple answers, name compression works more effectively if all the names contain a common suffix. If many answers in the packet have the same &lt;Service&gt; and &lt;Domain&gt;, then each occurrence of a Service Instance Name can be expressed using only the &lt;Instance&gt; part followed by a two-byte compression pointer referencing a previous appearance of &#34;&lt;Service&gt;.&lt;Domain&gt;&#34;. This efficiency would not be possible if the &lt;Service&gt; component appeared first in each name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS応答は複数回答が含まれている場合、すべての名前が共通のサフィックスが含まれている場合は、名前の圧縮をより効果的に機能します。パケット内の多くの答えが同じ&lt;サービス&gt;と&lt;ドメイン&gt;持っている場合、サービスインスタンス名の各出現は、&lt;」の前の外観を参照する全角圧縮ポインタ続いのみ&lt;インスタンス&gt;一部を使用して表すことができます。サービス&gt;。&lt;ドメイン&gt;」。 &lt;サービス&gt;コンポーネントはそれぞれの名前で最初に現れた場合、この効率は不可能であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3. Operational Flexibility
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3。運用の柔軟性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This name structure allows subdomains to be delegated along logical service boundaries. For example, the network administrator at Example Co. could choose to delegate the &#34;_tcp.example.com.&#34; subdomain to a different machine, so that the machine handling service discovery doesn&#39;t have to be the machine that handles other day-to-day DNS operations. (It *can* be the same machine if the administrator so chooses, but the administrator is free to make that choice.) Furthermore, if the network administrator wishes to delegate all information related to IPP printers to a machine dedicated to that specific task, this is easily done by delegating the &#34;_ipp._tcp.example.com.&#34; subdomain to the desired machine. It is also convenient to set security policies on a per-zone/per-subdomain basis. For example, the administrator may choose to enable DNS Dynamic Update [RFC2136] [RFC3007] for printers registering in the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この名前の構造は、サブドメインは、論理サービスの境界に沿って委任することができます。たとえば、例（株）のネットワーク管理者は、委任することを選択することができる「_tcp.example.comを。」別のマシンにサブドメイン、機械処理サービスの発見は、他の日々のDNS操作を処理マシンである必要はありませんように。 （管理者がそう選択したが、管理者がその選択をすることが自由であればそれは* *同じマシンすることができます。）また、ネットワーク管理者は、その特定のタスクに専用のマシンにIPPプリンターに関連するすべての情報を委任することを希望する場合、これは簡単に委譲することによって行われている「_ipp._tcp.example.com。」目的のマシンにサブドメイン。また、ゾーンごとの/あたりのサブドメインごとにセキュリティポリシーを設定すると便利です。たとえば、管理者が登録してプリンタ用のDNS動的更新[RFC2136] [RFC3007]を可能にすることもできます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;_ipp._tcp.example.com.&#34; subdomain, but not for other zones/subdomains. This easy flexibility would not exist if the &lt;Service&gt; component appeared first in each name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;_ipp._tcp.example.com。&#34;サブドメインではなく、他のゾーン/サブドメインのために。 &lt;サービス&gt;コンポーネントはそれぞれの名前で最初に現れた場合、この簡単な柔軟性は存在しなかったでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix C. What You See Is What You Get
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録C.あなたは何を参照してくださいあなたが得るものです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some service discovery protocols decouple the true service identifier from the name presented to the user. The true service identifier used by the protocol is an opaque unique identifier, often represented using a long string of hexadecimal digits, which should never be seen by the typical user. The name presented to the user is merely one of the decorative ephemeral attributes attached to this opaque identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのサービス発見プロトコルは、ユーザに提示名前から真のサービス識別子を切り離します。プロトコルによって使用される真のサービス識別子が不透明一意の識別子であり、多くの場合、典型的なユーザによって見られてはならない16進数の長い文字列を使用して表現。ユーザに提示名前は単に、この不透明な識別子に添付装飾はかない属性の1つです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The problem with this approach is that it decouples user perception from network reality:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このアプローチの問題点は、ネットワークの現実からユーザーの知覚を切り離すことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* What happens if there are two service instances, with different unique ids, but they have inadvertently been given the same user-visible name? If two instances appear in an on-screen list with the same name, how does the user know which is which?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
* 2つのサービスインスタンスがある場合はどう異なる固有のIDで、たまたま、彼らが誤って同じユーザーに見える名前を与えられていますか？ 2つのインスタンスが同じ名前で、画面上のリストに表示された場合、どのユーザーがどのである知っているのですか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Suppose a printer breaks down, and the user replaces it with another printer of the same make and model, and configures the new printer with the exact same name as the one being replaced: &#34;Stuart&#39;s Printer&#34;. Now, when the user tries to print, the on-screen print dialog tells them that their selected default printer is &#34;Stuart&#39;s Printer&#34;. When they browse the network to see what is there, they see a printer called &#34;Stuart&#39;s Printer&#34;, yet when the user tries to print, they are told that the printer &#34;Stuart&#39;s Printer&#34; can&#39;t be found. The hidden internal unique identifier that the software is trying to find on the network doesn&#39;t match the hidden internal unique identifier of the new printer, even though its apparent &#34;name&#34; and its logical purpose for being there are the same. To remedy this, the user typically has to delete the print queue they have created, and then create a new (apparently identical) queue for the new printer, so that the new queue will contain the right hidden internal unique identifier. Having all this hidden information that the user can&#39;t see makes for a confusing and frustrating user experience, and exposing long, ugly hexadecimal strings to the user and forcing them to understand what they mean is even worse.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「スチュアートのプリンタ」：*プリンタが故障し、ユーザーが同じ製造元とモデルの別のプリンタに置き換えられ、そして交換されるものとまったく同じ名前を持つ新しいプリンタを設定したとします。ユーザーが印刷しようとしたときに今、オンスクリーン印刷ダイアログは、それらの選択デフォルトのプリンタは「スチュアートのプリンタ」であることを彼らに伝えます。彼らはそこにあるものを見るためにネットワークを参照すると、彼らは「スチュアートのプリンタ」と呼ばれるプリンタを参照してください、まだユーザーが印刷しようとしたとき、彼らはプリンタ「スチュアートのプリンタは、」見つからないことを告げています。ソフトウェアは、その見かけの「名前」とあるためにその論理的な目的は同じあるにもかかわらず、新しいプリンタの隠された内部の一意の識別子と一致していないネットワーク上で検索しようとしている隠された内部のユニークな識別子。この問題を解決するには、ユーザーは通常、新しいキューが右に隠された内部のユニークな識別子を含んでいますように、自分が作成したプリントキューを削除し、新しいプリンタのための新たな（明らかに同じ）キューを作成する必要があります。ユーザーは混乱し、イライラするユーザー体験になりを見ることができないことをすべて、この隠された情報を持って、ユーザーに長く、醜い進数の文字列を露出させ、彼らが何を意味するかを理解するためにそれらを強制することはさらに悪くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Suppose an existing printer is moved to a new department, and given a new name and a new function. Changing the user-visible name of that piece of hardware doesn&#39;t change its hidden internal unique identifier. Users who had previously created a print queue for that printer will still be accessing the same hardware by its unique identifier, even though the logical service that used to be offered by that hardware has ceased to exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*既存のプリンタは、新しい部署に移動し、新しい名前と新しい機能を与えられていると仮定します。ハードウェアのその部分のユーザに見える名前を変更すると、その隠された内部の一意の識別子を変更しません。以前にそのプリンタのプリントキューを作成していたユーザーは、そのハードウェアで提供されるために使用される論理的なサービスが存在しなくなったとしても、そのユニークな識別子で、同じハードウェアにアクセスします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Solving these problems requires the user or administrator to be aware of the supposedly hidden unique identifier, and to set its value correctly as hardware is moved around, repurposed, or replaced, thereby contradicting the notion that it is a hidden identifier that human users never need to deal with. Requiring the user to understand this expert behind-the-scenes knowledge of what is *really* going on is just one more burden placed on the user when they are trying to diagnose why their computers and network devices are not working as expected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの問題を解決することはおそらく隠された一意の識別子を認識するように、ユーザーや管理者を必要とし、ハードウェアは、それによって人間のユーザが必要とすることはありません隠された識別子であるという概念と矛盾する、周りに移動し再利用、または交換されるように正しくその値を設定しますに対処します。上に行く* *本当に何であるかのこの専門家舞台裏知識を理解するために、ユーザーを要求することは、彼らが期待通りに自分のコンピュータとネットワークデバイスが動作しない理由を診断しようとしているときに、ユーザに置かただ1人の以上の負担です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These anomalies and counterintuitive behaviors can be eliminated by maintaining a tight bidirectional one-to-one mapping between what the user sees on the screen and what is really happening &#34;behind the curtain&#34;. If something is configured incorrectly, then that is apparent in the familiar day-to-day user interface that everyone understands, not in some little-known, rarely used &#34;expert&#34; interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの異常や直感に反する行動は、ユーザーが実際に「カーテンの後ろに」何が起こっているか、画面上で見て、どのような間の緊密な双方向の1対1のマッピングを維持することによって解消することができます。何かが間違って設定されている場合は、それは誰もが理解おなじみの日々のユーザーインターフェイスではなく、いくつかのあまり知られていない、めったに使われない「専門家」のインターフェースには明らかです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In summary: in DNS-SD the user-visible name is also the primary identifier for a service. If the user-visible name is changed, then conceptually the service being offered is a different logical service -- even though the hardware offering the service may have stayed the same. If the user-visible name doesn&#39;t change, then conceptually the service being offered is the same logical service -- even if the hardware offering the service is new hardware brought in to replace some old equipment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要約する：DNS-SDユーザ可視名は、サービスのための主要な識別子です。ユーザーに表示名が変更された場合、概念的に提供されるサービスは、異なる論理的サービスである - サービスを提供するハードウェアが同じ宿泊している場合でも。ユーザに見える名前が変更されない場合は、概念的に提供されているサービスは、同じ論理サービスである - サービスを提供するハードウェアは、いくつかの古い機器を置き換えるために持って来られ、新しいハードウェアであっても。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are certainly arguments on both sides of this debate. Nonetheless, the designers of any service discovery protocol have to make a choice between having the primary identifiers be hidden, or having them be visible, and these are the reasons that we chose to make them visible. We&#39;re not claiming that there are no disadvantages of having primary identifiers be visible. We considered both alternatives, and we believe that the few disadvantages of visible identifiers are far outweighed by the many problems caused by use of hidden identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この議論の両側に引数が確かにあります。それにもかかわらず、任意のサービス発見プロトコルの設計者は、主識別子が隠された、またはそれらが見えるようになるかの選択を行う必要があり、これらは、我々は彼らが見えるようにすることを選んだ理由は。私たちは、主識別子が表示されたのない欠点がないことを主張していません。我々は両方の選択肢を検討し、私たちは目に見える識別子のいくつかの欠点がはるかに隠された識別子を使用することによって引き起こされる多くの問題が上回ると考えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix D. Choice of Factory-Default Names
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
工場出荷時のデフォルト名の付録D.選択
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a DNS-SD service is advertised using Multicast DNS [RFC6762], if there is already another service of the same type advertising with the same name then automatic name conflict resolution will occur. As described in the Multicast DNS specification [RFC6762], upon detecting a conflict, the service should:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS-SDサービスは、マルチキャストDNS [RFC6762]を使用してアドバタイズされたときに存在する場合、すでに同じ名前を持つ同じタイプの広告の別のサービスは、自動的に名前の競合解決が発生します。マルチキャストDNS仕様[RFC6762]に記載されているように、衝突を検出すると、サービスがすべき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Automatically select a new name (typically by appending or incrementing a digit at the end of the name), 2. Try advertising with the new name, and 3. Upon success, record the new name in persistent storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.は自動的に、（通常は名前の末尾に数字を追加するか、インクリメントすることによって）新しい名前を選択し、新しい名前を持つ2トライ広告、成功時に3、永続ストレージに新しい名前を記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This renaming behavior is very important, because it is key to providing user-friendly instance names in the out-of-the-box factory-default configuration. Some product developers apparently have not realized this, because there are some products today where the factory-default name is distinctly unfriendly, containing random-looking strings of characters, such as the device&#39;s Ethernet address in hexadecimal. This is unnecessary and undesirable, because the point of the user-visible name is that it should be friendly and meaningful to human users. If the name is not unique on the local network then the protocol will remedy this as necessary. It is ironic that many of the devices with this design mistake are network printers, given that these same printers also simultaneously support AppleTalk-over-Ethernet, with nice user-friendly default names (and automatic conflict detection and renaming). Some examples of good factory-default names are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはすぐに工場出荷時のデフォルト設定でユーザーフレンドリーなインスタンス名を提供するための鍵であるため、この名前変更の動作は、非常に重要です。工場出荷時のデフォルトの名前は、このような16進数のデバイスのイーサネットアドレスなどの文字のランダムに見える文字列を含む、明らかに非友好的であるいくつかの製品、今日があるため、一部の製品開発者は明らかに、これを実現していません。ユーザに見える名前のポイントは、それが人間のユーザに優しいと意味のあるべきであるということであるので、これは、不必要かつ望ましくありません。名前は、ローカルネットワーク上で一意でない場合、プロトコルは、必要に応じてこの問題を解決します。この設計ミスと機器の多くは、これらの同じプリンタでも同時に素敵なユーザーフレンドリーなデフォルト名（および自動競合検出および名前の変更）で、AppleTalkをオーバー・イーサネットをサポートすることを考えると、ネットワークプリンタであることを皮肉です。良い工場出荷時のデフォルトの名前のいくつかの例は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Brother 5070N Canon W2200 HP LaserJet 4600 Lexmark W840 Okidata C5300 Ricoh Aficio CL7100 Xerox Phaser 6200DX
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブラザー5070NキヤノンW2200のHPのLaserJet 4600のLexmark W840のOkidata C5300 RICOH AFICIO CL7100ゼロックスフェイザー6200DX
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To make the case for why adding long, ugly factory-unique serial numbers to the end of names is neither necessary nor desirable, consider the cases where the user has (a) only one network printer, (b) two network printers, and (c) many network printers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
なぜ名前の最後に長い、醜い工場出荷時に固有のシリアル番号を追加するためのケースを作るためには必要でも望ましくもない、（ユーザーが（a）の唯一のネットワークプリンタを持っている場合、（b）は2台のネットワークプリンタ、およびを検討C）多くのネットワークプリンタ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(a) In the case where the user has only one network printer, a simple name like (to use a vendor-neutral example) &#34;Printer&#34; is more user-friendly than an ugly name like &#34;Printer_0001E68C74FB&#34;. Appending ugly hexadecimal goop to the end of the name to make sure the name is unique is irrelevant to a user who only has one printer anyway.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（a）は、ユーザが一つだけのネットワークプリンタを持っている場合は、（ベンダー中立の例を使用するために）「プリンタ」のような単純な名前は、よりユーザーフレンドリー「Printer_0001E68C74FB」のような醜い名を超えています。名前が一意であることを確認するには、名前の末尾に醜い進無神経な人を追加することだけとにかく1台のプリンタを持っているユーザーには無関係です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(b) In the case where the user gets a second network printer, having the new printer detect that the name &#34;Printer&#34; is already in use and automatically name itself &#34;Printer (2)&#34; instead, provides a good user experience. For most users, remembering that the old printer is &#34;Printer&#34; and the new one is &#34;Printer (2)&#34; is easy and intuitive. Seeing a printer called &#34;Printer_0001E68C74FB&#34; and another called &#34;Printer_00306EC3FD1C&#34; is a lot less helpful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（b）は、ユーザが第2のネットワークプリンタを取得する場合には、新しいプリンタ名「プリンタ」が既に使用中であることを検出し、自動的に名前を有する「プリンタ（2）」の代わりに、優れたユーザ体験を提供します。ほとんどのユーザーのために、古いプリンタが「プリンタ」で、新しいものであることを思い出して、「プリンタと、（2）」簡単で直感的です。 「Printer_0001E68C74FB」と呼ばれるプリンタを見て、「Printer_00306EC3FD1C」と呼ばれる別のことはずっと少なく便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(c) In the case of a network with ten network printers, seeing a list of ten names all of the form &#34;Printer_xxxxxxxxxxxx&#34; has effectively taken what was supposed to be a list of user-friendly rich-text names (supporting mixed case, spaces, punctuation, non-Roman characters, and other symbols) and turned it into just about the worst user interface imaginable: a list of incomprehensible random-looking strings of letters and digits. In a network with a lot of printers, it would be advisable for the people setting up the printers to take a moment to give each one a descriptive name, but in the event they don&#39;t, presenting the users with a list of sequentially numbered printers is a much more desirable default user experience than showing a list of raw Ethernet addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
10台のネットワークプリンタとのネットワークの場合には（C）、（10名「Printer_xxxxxxxxxxxxは」効果的にユーザーフレンドリーなリッチテキスト名のリストになるはずだったものを撮影したフォームのすべてのリストを見て大文字と小文字をサポートし、文字と数字の不可解ランダムに見える文字列のリスト：スペース、句読点、非ローマ字、その他の記号）とは、単に想像最悪のユーザーインターフェースについてにそれを回しました。プリンタの設定、人々はそれぞれの名前を与えるために時間を割いするプリンタの多くのネットワークでは、それが賢明だろうが、イベントでは、彼らは、番号順のリストをユーザーに提示する、しないでくださいプリンタは、生のイーサネットアドレスのリストを示すよりもはるかに望ましいデフォルトのユーザーエクスペリエンスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix E. Name Encodings in the Domain Name System
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドメインネームシステムの付録E.名のエンコーディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although the original DNS specifications [RFC1033] [RFC1034] [RFC1035] recommend that host names contain only letters, digits, and hyphens (because of the limitations of the typing-based user interfaces of that era), Service Instance Names are not host names. Users generally access a service by selecting it from a list presented by a user interface, not by typing in its Service Instance Name. &#34;Clarifications to the DNS Specification&#34; [RFC2181] directly discusses the subject of allowable character set in Section 11 (&#34;Name syntax&#34;), and explicitly states that the traditional letters-digits-hyphens rule applies only to conventional host names:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリジナルのDNSの仕様[RFC1033]が、[RFC1034] [RFC1035]は、そのホスト名がサービスインスタンス名、（なぜならその時代のタイピングベースのユーザー・インターフェースの制限の）文字、数字、およびハイフンのみが含まれているお勧めします名前をホストしていています。ユーザーは、一般的に、ユーザインタフェースによってではなく、そのサービスインスタンス名を入力して提示されたリストから選択してサービスにアクセスします。 「DNS仕様の明確化」[RFC2181]は、直接第11節（「名前の構文」）に設定された許容文字の主題を議論し、明示的に伝統的な文字 - 数字 - ハイフンルールのみ、従来のホスト名に適用されると述べています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Occasionally it is assumed that the Domain Name System serves only the purpose of mapping Internet host names to data, and mapping Internet addresses to host names. This is not correct, the DNS is a general (if somewhat limited) hierarchical database, and can store almost any kind of data, for almost any purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時折ドメインネームシステムをホスト名にのみデータにマッピングするインターネットホスト名の目的、およびマッピングのインターネットアドレスを提供するものとします。これは、DNSは、（多少制限されている場合）、一般的な階層型データベースであり、ほぼすべての目的のために、ほとんどあらゆる種類のデータを格納することができ、正しくありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The DNS itself places only one restriction on the particular labels that can be used to identify resource records. That one restriction relates to the length of the label and the full name. The length of any one label is limited to between 1 and 63 octets. A full domain name is limited to 255 octets (including the separators). The zero length full name is defined as representing the root of the DNS tree, and is typically written and displayed as &#34;.&#34;. Those restrictions aside, any binary string whatever can be used as the label of any resource record. Similarly, any binary string can serve as the value of any record that includes a domain name as some or all of its value (SOA, NS, MX, PTR, CNAME, and any others that may be added). Implementations of the DNS protocols must not place any restrictions on the labels that can be used. In particular, DNS servers must not refuse to serve a zone because it contains labels that might not be acceptable to some DNS client programs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS自体は、リソースレコードを識別するために使用することができ、特定のラベルにのみつの制限を配置します。それつの制限は、ラベルの長さとフルネームに関するものです。いずれかのラベルの長さは1〜63オクテットに制限されています。完全なドメイン名が（セパレータを含む）255オクテットに制限されています。ゼロ長フルネームは、DNSツリーのルートを表すものとして定義され、典型的に書き込まれたように表示されます「」。これらの制限はさておき、任意のリソースレコードのラベルとして使用することができますどのような任意のバイナリ文字列。同様に、任意のバイナリ文字列がその値（SOA、NS、MX、PTR、CNAME、および添加することができる任意の他のもの）の一部または全部としてドメイン名を含む任意のレコードの値としての役割を果たすことができます。 DNSプロトコルの実装は使用することができ、ラベル上の任意の制限を置かないでなければなりません。それは一部のDNSクライアントプログラムに受け入れられない可能性がありますラベルが含まれているため、具体的には、DNSサーバーは、ゾーンにサービスを提供することを拒否してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that just because DNS-based Service Discovery supports arbitrary UTF-8-encoded names doesn&#39;t mean that any particular user or administrator is obliged to make use of that capability. Any user is free, if they wish, to continue naming their services using only letters, digits, and hyphens, with no spaces, capital letters, or other punctuation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNSベースのサービス探索は任意のUTF-8でエンコードされた名前をサポートしているという理由だけで、特定のユーザーや管理者がその機能を利用するために義務があることを意味しないことに注意してください。彼らはスペースなし、大文字、または他の句読点と、唯一の文字、数字、ハイフンを使用してそのサービスを命名継続し、希望する場合は、すべてのユーザーが、無料です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix F. &#34;Continuous Live Update&#34; Browsing Model
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録F.「連続ライブアップデート」ブラウズモデル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Of particular concern in the design of DNS-SD, especially when used in conjunction with ad hoc Multicast DNS, is the dynamic nature of service discovery in a changing network environment. Other service discovery protocols seem to have been designed with an implicit unstated assumption that the usage model is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アドホックマルチキャストDNSと組み合わせて使用​​する場合、DNS-SDの設計で特に懸念されるの、特に、変化するネットワーク環境におけるサービスの発見の動的な性質です。その他のサービス発見プロトコルが利用モデルであることを暗黙の暗黙の前提に設計されているように見えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(a) client software calls the service discovery API, (b) service discovery code spends a few seconds getting a list of instances available at a particular moment in time, and then (c) client software displays the list for the user to select from.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（a）は、クライアント・ソフトウェアは、（b）は、サービス発見コードは時間の特定の瞬間に利用可能なインスタンスのリストを取得し、数秒を費やし、その後、（c）は、クライアントソフトウェアから選択したユーザーのリストが表示され、サービス検出APIを呼び出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Superficially this usage model seems reasonable, but the problem is that it&#39;s too optimistic. It only considers the success case, where the software immediately finds the service instance the user is looking for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表面的にこの使用モデルは、合理的なようだが、問題は、それはあまりにも楽観的だということです。それだけでソフトウェアが即座にユーザーが探しているサービスインスタンスを見つけた成功事例を、考慮しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case where the user is looking for (say) a particular printer, and that printer is not turned on or not connected, the user first has to attempt to remedy the problem, and then has to click a &#34;refresh&#34; button to retry the service discovery to find out whether they were successful. Because nothing happens instantaneously in networking, and packets can be lost, necessitating some number of retransmissions, a service discovery search is not instantaneous and typically takes a few seconds. As a result, a fairly typical user experience is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザーが特定のプリンタ（例えば）を探して、そのプリンタがオンになっていないか、接続されていない、ユーザーが最初の問題を解決しようとする必要があり、その後、再試行して「リフレッシュ」ボタンをクリックする必要がありますされている場合には彼らが成功したかどうかを調べるためのサービス発見。何がネットワークに瞬時に起こりませんし、パケットが再送信をいくつか必要と、失われる可能性があるため、サービス発見検索は瞬時ではなく、典型的には数秒かかります。その結果、かなり一般的なユーザーエクスペリエンスは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(a) display an empty window, (b) display some animation like a searchlight sweeping back and forth for ten seconds, and then (c) at the end of the ten-second search, display a static list showing what was discovered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（a）は（b）の前後に10秒間掃引サーチライトのようないくつかのアニメーションを表示するには、空のウィンドウを表示させ、（c）は10秒の検索の終わりに、発見されたものを示す静的リストを表示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Every time the user clicks the &#34;refresh&#34; button they have to endure another ten-second wait, and every time the discovered list is finally shown at the end of the ten-second wait, it&#39;s already beginning to get stale and out-of-date the moment it&#39;s displayed on the screen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザーは、彼らが別の10秒の待ち時間を耐えなければならボタン、および発見リストは最終的に10秒待ちの最後に表示されるたびに「リフレッシュ」をクリックするたびに、すでに陳腐得るために始めて、アウトオブ日付それが画面上に表示されます瞬間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The service discovery user experience that the DNS-SD designers had in mind has some rather different properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS-SDの設計者が念頭に置いていたサービス発見のユーザーエクスペリエンスは、いくつかのかなり異なる特性を持っています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Displaying the initial list of discovered services should be effectively instantaneous -- i.e., typically 0.1 seconds, not 10 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.発見サービスの初期リストを表示すると効果的に瞬時でなければならない - すなわち、典型的には0.1秒ではなく10秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. The list of discovered services should not be getting stale and out-of-date from the moment it&#39;s displayed. The list should be &#39;live&#39; and should continue to update as new services are discovered. Because of the delays, packet losses, and retransmissions inherent in networking, it is to be expected that sometimes, after the initial list is displayed showing the majority of discovered services, a few remaining stragglers may continue to trickle in during the subsequent few seconds. Even after this stable list has been built and displayed, it should remain &#39;live&#39; and should continue to update. At any future time, be it minutes, hours, or even days later, if a new service of the desired type is discovered, it should be displayed in the list automatically, without the user having to click a &#34;refresh&#34; button or take any other explicit action to update the display.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.発見されたサービスのリストは、それが表示されます瞬間から古くなったと古くなってはいけません。リストは「ライブ」であるべきで、新しいサービスが発見されているように更新し続けなければなりません。そのため、遅延、パケットロス、およびネットワークに固有の再送信のために、それは最初のリストが検出されたサービスの大半を示す表示された後、時々、いくつかの残りの落伍者は、その後の数秒の間でトリクル充電を継続することが予想されます。この安定したリストが構築され、表示された後であっても、それは「ライブ」残るべきと更新し続けるべきです。所望のタイプの新しいサービスが発見された場合、将来の時点で、それは「リフレッシュ」ボタンをクリックするか、いずれかを取るために持つユーザーせずに、自動的にリストに表示されなければならない、それは数分、数時間、または数日後にすること表示を更新するために、他の明示的なアクション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. With users getting in the habit of leaving service discovery windows open, and expecting them to show a continuous &#39;live&#39; view of current network reality, this gives us an additional requirement: deletion of stale services. When a service discovery list shows just a static snapshot at a moment in time, then the situation is simple: either a service was discovered and appears in the list, or it was not and does not. However, when our list is live and updates continuously with the discovery of new services, then this implies the corollary: when a service goes away, it needs to *disappear* from the service discovery list. Otherwise, the service discovery list would simply grow monotonically over time, accreting stale data, and would require a periodic &#34;refresh&#34; (or complete dismissal and recreation) to restore correct display.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
古くなったサービスの削除：オープンサービス発見ウィンドウを残して、現在のネットワークの現実の連続「ライブ」ビューを表示するためにそれらを期待するのが習慣になってユーザーと3.が、これは私たちに、追加の要件を提供します。サービスのいずれかが発見され、リストに表示され、またはそうではありませんでしたとされていません。サービス発見リストが時間内に、現時点では単なる静的なスナップショットを示していた場合、その後、状況は単純です。私たちのリストには、ライブで、新たなサービスの発見と継続的に更新するときしかし、これは当然の結果を意味します。サービスがなくなったとき、それは*サービス発見リストから*消えている必要があります。そうでない場合は、サービス発見リストは、単に古いデータを降着、時間の経過とともに単調に成長すると、正しい表示を復元するために定期的に「リフレッシュ」（または完全な解雇やレクリエーションを）必要となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Another consequence of users leaving service discovery windows open for extended periods of time is that these windows should update not only in response to services coming and going, but also in response to changes in configuration and connectivity of the client machine itself. For example, if a user opens a service discovery window when the client machine has no network connectivity, then the window will typically appear empty, with no discovered services. When the user connects an Ethernet cable or joins an 802.11 [IEEEW] wireless network the window should then automatically populate with discovered services, without requiring any explicit user action. If the user disconnects the Ethernet cable or turns off 802.11 wireless then all the services discovered via that network interface should automatically disappear. If the user switches from one 802.11 wireless access point to another, the service discovery window should automatically update to remove all the services discovered via the old wireless access point, and add all the services discovered via the new one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.長時間のオープンサービス発見ウィンドウを残して、ユーザーの他の結果は、これらのウィンドウが出入りサービスに応じて、だけでなく、クライアントマシン自体の構成や接続性の変化に対応していないだけで更新しなければならないことです。クライアントマシンが何のネットワーク接続がない場合、ユーザはサービス発見ウィンドウを開く場合、例えば、ウィンドウは通常ありません発見されたサービスで、空に表示されます。ユーザは、イーサネットケーブルを接続するか、明示的なユーザアクションを必要とせずに、ウィンドウが自動的に検出されたサービスを取り込むべき802.11 [IEEEW無線ネットワークに参加するとき。ユーザーは、Ethernetケーブルを切断または802.11無線をオフにした場合は、そのネットワークインターフェースを介して検出されたすべてのサービスが自動的に消えるはずです。別の802.11ワイヤレス・アクセス・ポイントからユーザー切り替えた場合は、サービス発見ウィンドウが自動的に古い無線アクセスポイントを介して検出されたすべてのサービスを削除し、新しいものを経由して発見されたすべてのサービスを追加して更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix G. Deployment History
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録G.展開の歴史
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In July 1997, in an email to the net-thinkers@thumper.vmeng.com mailing list, Stuart Cheshire first proposed the idea of running the AppleTalk Name Binding Protocol [RFC6760] over IP. As a result of this and related IETF discussions, the IETF Zeroconf working group was chartered September 1999. After various working group discussions and other informal IETF discussions, several Internet-Drafts were written that were loosely related to the general themes of DNS and multicast, but did not address the service discovery aspect of NBP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1997年7月、net-thinkers@thumper.vmeng.comメーリングリストへの電子メールで、スチュアートチェシャーは、最初のIP上でプロトコル[RFC6760]をバインディングのAppleTalk名を実行しているのアイデアを提案しました。この結果、関連IETFの議論として、IETFのZeroconfワーキンググループは、さまざまなワーキンググループディスカッションや他の非公式IETF議論の後1999年9月にチャーターされた緩くDNSおよびマルチキャストの一般的なテーマに関連していたというインターネットドラフトが書かれていたいくつかの、しかし、NBPのサービス発見側面に対処していませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In April 2000, Stuart Cheshire registered IPv4 multicast address 224.0.0.251 with IANA and began writing code to test and develop the idea of performing NBP-like service discovery using Multicast DNS, which was documented in a group of three Internet-Drafts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2000年4月には、スチュアート・チェシャーはIANAでIPv4マルチキャストアドレス224.0.0.251を登録し、テストし、3インターネットドラフトのグループに記載されたマルチキャストDNSを使用して、NBPのようなサービス・ディスカバリを実行する考えを開発するためにコードを書き始めました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o &#34;Requirements for a Protocol to Replace the AppleTalk Name Binding Protocol (NBP)&#34; [RFC6760] is an overview explaining the AppleTalk Name Binding Protocol, because many in the IETF community had little first-hand experience using AppleTalk, and confusion in the IETF community about what AppleTalk NBP did was causing confusion about what would be required in an IP-based replacement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFコミュニティの多くは、AppleTalkを使用少し最初の手の経験を持っていた、とIETFにおける混乱ので、O [RFC6760]「AppleTalkの名前バインディングプロトコル（NBP）を交換するためのプロトコルのための要件は、」プロトコルを、バインディングのAppleTalk名を説明する概要ですAppleTalkのNBPが何をしたかについてのコミュニティは、IPベースの交換に必要となるかについて混乱を引き起こしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o &#34;Discovering Named Instances of Abstract Services using DNS&#34; [NIAS], which later became this document, proposed a way to perform NBP-like service discovery using DNS-compatible names and record types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oこの文書の後半になりました[NIAS]、「DNSを使用して抽象サービスの名前付きインスタンスの検出」、DNS互換の名前とレコードタイプを使用してNBPのようなサービス・ディスカバリを実行する方法を提案しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o &#34;Multicast DNS&#34; [RFC6762] specifies a way to transport those DNS-compatible queries and responses using IP multicast, for zero-configuration environments where no conventional Unicast DNS server was available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O「マルチキャストDNS」[RFC6762]は全く従来のユニキャストDNSサーバが利用できなかったゼロ設定環境では、IPマルチキャストを用いたものDNS互換クエリおよび応答を転送する方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In 2001, an update to Mac OS 9 added resolver library support for host name lookup using Multicast DNS. If the user typed a name such as &#34;MyPrinter.local.&#34; into any piece of networking software that used the standard Mac OS 9 name lookup APIs, then those name lookup APIs would recognize the name as a dot-local name and query for it by sending simple one-shot Multicast DNS queries to 224.0.0.251:5353. This enabled the user to, for example, enter the name &#34;MyPrinter.local.&#34; into their web browser in order to view a printer&#39;s status and configuration web page, or enter the name &#34;MyPrinter.local.&#34; into the printer setup utility to create a print queue for printing documents on that printer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2001年にはMac OS 9へのアップデートは、マルチキャストDNSを使用してホスト名のルックアップのためのリゾルバライブラリのサポートを追加しました。ユーザーは、次のような名前を入力した場合、「MyPrinter.local。」標準のMac OS 9名前検索APIを使用するネットワークソフトウェアのどの部分に、それらの名前検索APIは224.0.0.251に、単純なワンショットマルチキャストDNSクエリを送信することで、そのためのドットローカル名およびクエリとして名を認識することとなります。 5353。これは、例えば、名前の入力をユーザーに有効「MyPrinter.localを。」プリンタのステータスと設定のWebページを表示する、または名前を入力するために、自分のWebブラウザに「MyPrinter.localを。」プリンタ設定ユーティリティにそのプリンタへの印刷文書の印刷キューを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS responder software, with full service discovery, first began shipping to end users in volume with the launch of Mac OS X 10.2 &#34;Jaguar&#34; in August 2002, and network printer makers (who had historically supported AppleTalk in their network printers and were receptive to IP-based technologies that could offer them similar ease-of-use) started adopting Multicast DNS shortly thereafter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSの応答ソフトウェアは、フルサービスの発見と、最初の2002年8月にはMac OS X 10.2「ジャガー」の打ち上げとボリュームにエンドユーザに出荷を開始した、と歴史的にそのネットワークプリンタでのAppleTalkをサポートし、受容したしたネットワークプリンタメーカー（それらに類似した使いやすさを提供できるIPベースの技術）に、その後まもなく、マルチキャストDNSを採用し始めました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In September 2002, Apple released the source code for the mDNSResponder daemon as Open Source under Apple&#39;s standard Apple Public Source License (APSL).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2002年9月、AppleはAppleの標準のApple Public Source License（APSL）の下でオープンソースとしてmDNSResponderデーモンのソースコードを公開しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS responder software became available for Microsoft Windows users in June 2004 with the launch of Apple&#39;s &#34;Rendezvous for Windows&#34; (now &#34;Bonjour for Windows&#34;), both in executable form (a downloadable installer for end users) and as Open Source (one of the supported platforms within Apple&#39;s body of cross-platform code in the publicly accessible mDNSResponder CVS source code repository) [BJ].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答ソフトウェアは、実行形式（エンドユーザー用のダウンロードインストーラ）におけるオープンソース（1として両方Appleの「Windows用のランデブー」（現在の「Windows用のBonjour」）の発売と2004年6月のMicrosoft Windowsユーザーのために利用できるようになりました一般にアクセス可能mDNSResponder CVSソースコードリポジトリでのクロスプラットフォームコードのAppleの体内でサポートされるプラットフォーム）[BJ]の。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In August 2006, Apple re-licensed the cross-platform mDNSResponder source code under the Apache License, Version 2.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2006年8月に、AppleはApacheライセンスの下で、クロスプラットフォームmDNSResponderのソースコード、バージョン2.0を再ライセンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to desktop and laptop computers running Mac OS X and Microsoft Windows, Multicast DNS is now implemented in a wide range of hardware devices, such as Apple&#39;s &#34;AirPort&#34; wireless base stations, iPhone and iPad, and in home gateways from other vendors, network printers, network cameras, TiVo DVRs, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デスクトップおよびラップトップコンピュータは、Mac OS XおよびMicrosoft Windowsを実行していることに加えて、マルチキャストDNSは現在、アップルの「AirMacの」無線基地局、iPhoneやiPadなどのハードウェアデバイスの広い範囲で、および他のベンダーからホームゲートウェイに実装されていますネットワークプリンタ、ネットワークカメラ、ティーボのデジタルビデオレコーダーなど
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Open Source community has produced many independent implementations of Multicast DNS, some in C like Apple&#39;s mDNSResponder daemon, and others in a variety of different languages including Java, Python, Perl, and C#/Mono.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オープンソースコミュニティは、JavaやPython、Perlの、およびC＃/モノラルを含む異なるさまざまな言語でマルチキャストDNS、AppleのmDNSResponderデーモンのようなCでのいくつかの、および他の多くの独立した実装を生産しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In January 2007, the IETF published the Informational RFC &#34;Link-Local Multicast Name Resolution (LLMNR)&#34; [RFC4795], which is substantially similar to Multicast DNS, but incompatible in some small but important ways. In particular, the LLMNR design explicitly excluded support for service discovery, which made it an unsuitable candidate for a protocol to replace AppleTalk NBP [RFC6760].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2007年1月、IETFは、情報RFC、実質的にマルチキャストDNSに似ていますが、いくつかの小さいながらも重要な点で互換性がありません「リンクローカルマルチキャスト名前解決（LLMNR）」[RFC4795]を、発表しました。特に、LLMNRの設計は明示的にAppleTalkのNBP [RFC6760]を置き換えるためのプロトコルには適さない候補作られ、サービスの発見のためのサポートを除外しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While the original focus of Multicast DNS and DNS-Based Service Discovery was for zero-configuration environments without a conventional Unicast DNS server, DNS-Based Service Discovery also works using Unicast DNS servers, using DNS Update [RFC2136] [RFC3007] to create service discovery records and standard DNS queries to query for them. Apple&#39;s Back to My Mac service, launched with Mac OS X 10.5 &#34;Leopard&#34; in October 2007, uses DNS-Based Service Discovery over Unicast DNS [RFC6281].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSおよびDNSベースのサービス発見の元の焦点は、従来のユニキャストDNSサーバなしでゼロコンフィギュレーション環境のためだったが、DNSベースのサービスディスカバリーは、サービスを作成するために、DNSアップデート[RFC2136] [RFC3007]を使用して、ユニキャストDNSサーバを使用して動作します探索レコードと標準DNSクエリは、彼らのために照会します。 2007年10月にはMac OS X 10.5 &#34;Leopardの&#34; で起動でもMy MacサービスにAppleのバックは、ユニキャストDNS [RFC6281]の上にDNSベースのサービス探索を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In June 2012, Google&#39;s Android operating system added native support for DNS-SD and Multicast DNS with the android.net.nsd.NsdManager class in Android 4.1 &#34;Jelly Bean&#34; (API Level 16) [NSD].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2012年6月には、GoogleのAndroidオペレーティングシステムは、[NSD]アンドロイド4.1 &#34;ジェリービーン&#34;（APIレベル16）でandroid.net.nsd.NsdManagerクラスでDNS-SDおよびマルチキャストDNSのネイティブサポートを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stuart Cheshire Apple Inc. 1 Infinite Loop Cupertino, CA 95014 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スチュアートチェシャーれたApple Inc. 1無限ループクパチーノ、CA 95014 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 408 974 3207 EMail: cheshire@apple.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 408 974 3207 Eメール：cheshire@apple.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Marc Krochmal Apple Inc. 1 Infinite Loop Cupertino, CA 95014 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルク・KrochmalされたApple Inc. 1無限ループクパチーノ、CA 95014 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 408 974 4368 EMail: marc@apple.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 408 974 4368 Eメール：marc@apple.com
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
