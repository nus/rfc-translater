<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 8154 - Parallel NFS (pNFS) Small Computer System Interface (SCSI) Layout 日本語訳</title>

  
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
    <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 8154 - Parallel NFS (pNFS) Small Computer System Interface (SCSI) Layout 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc8154">
              https://tools.ietf.org/html/rfc8154
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 8154 - パラレルNFS（pNFSの）小型コンピュータシステムインタフェース（SCSI）のレイアウト</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                        C. Hellwig
Request for Comments: 8154                                      May 2017
Category: Standards Track
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Parallel NFS (pNFS) Small Computer System Interface (SCSI) Layout
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パラレルNFS（pNFSの）小型コンピュータシステムインタフェース（SCSI）のレイアウト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Parallel Network File System (pNFS) allows a separation between the metadata (onto a metadata server) and data (onto a storage device) for a file. The Small Computer System Interface (SCSI) layout type is defined in this document as an extension to pNFS to allow the use of SCSI-based block storage devices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
並列ネットワークファイルシステム（pNFSの）ファイルの（メタデータサーバに）メタデータおよびデータ（記憶装置への）との間の分離を可能にします。小型コンピュータシステムインタフェース（SCSI）のレイアウトタイプは、SCSIベースのブロックストレージデバイスの使用を可能にするためのpNFSの拡張として、この文書で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8154.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8154で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Conventions Used in This Document . . . . . . . . . . . .   4
     1.2.  General Definitions . . . . . . . . . . . . . . . . . . .   4
     1.3.  Code Components Licensing Notice  . . . . . . . . . . . .   5
     1.4.  XDR Description . . . . . . . . . . . . . . . . . . . . .   5
   2.  SCSI Layout Description . . . . . . . . . . . . . . . . . . .   7
     2.1.  Background and Architecture . . . . . . . . . . . . . . .   7
     2.2.  layouttype4 . . . . . . . . . . . . . . . . . . . . . . .   8
     2.3.  GETDEVICEINFO . . . . . . . . . . . . . . . . . . . . . .   8
       2.3.1.  Volume Identification . . . . . . . . . . . . . . . .   8
       2.3.2.  Volume Topology . . . . . . . . . . . . . . . . . . .  10
     2.4.  Data Structures: Extents and Extent Lists . . . . . . . .  12
       2.4.1.  Layout Requests and Extent Lists  . . . . . . . . . .  15
       2.4.2.  Layout Commits  . . . . . . . . . . . . . . . . . . .  16
       2.4.3.  Layout Returns  . . . . . . . . . . . . . . . . . . .  17
       2.4.4.  Layout Revocation . . . . . . . . . . . . . . . . . .  17
       2.4.5.  Client Copy-on-Write Processing . . . . . . . . . . .  17
       2.4.6.  Extents Are Permissions . . . . . . . . . . . . . . .  18
       2.4.7.  Partial-Block Updates . . . . . . . . . . . . . . . .  19
       2.4.8.  End-of-File Processing  . . . . . . . . . . . . . . .  20
       2.4.9.  Layout Hints  . . . . . . . . . . . . . . . . . . . .  20
       2.4.10. Client Fencing  . . . . . . . . . . . . . . . . . . .  21
     2.5.  Crash Recovery Issues . . . . . . . . . . . . . . . . . .  22
     2.6.  Recalling Resources: CB_RECALL_ANY  . . . . . . . . . . .  23
     2.7.  Transient and Permanent Errors  . . . . . . . . . . . . .  23
     2.8.  Volatile Write Caches . . . . . . . . . . . . . . . . . .  24
   3.  Enforcing NFSv4 Semantics . . . . . . . . . . . . . . . . . .  24
     3.1.  Use of Open Stateids  . . . . . . . . . . . . . . . . . .  25
     3.2.  Enforcing Security Restrictions . . . . . . . . . . . . .  26
     3.3.  Enforcing Locking Restrictions  . . . . . . . . . . . . .  26
   4.  Security Considerations . . . . . . . . . . . . . . . . . . .  27
   5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  28
   6.  Normative References  . . . . . . . . . . . . . . . . . . . .  28
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  29
   Author&#39;s Address  . . . . . . . . . . . . . . . . . . . . . . . .  30
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1 shows the overall architecture of a Parallel NFS (pNFS) system:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1は、パラレルNFS（pNFSの）システムの全体的なアーキテクチャを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        +-----------+
        |+-----------+                                 +-----------+
        ||+-----------+                                |           |
        |||           |       NFSv4.1 + pNFS           |           |
        +||  Clients  |&lt;------------------------------&gt;|   Server  |
         +|           |                                |           |
          +-----------+                                |           |
               |||                                     +-----------+
               |||                                           |
               |||                                           |
               ||| Storage        +-----------+              |
               ||| Protocol       |+-----------+             |
               ||+----------------||+-----------+  Control   |
               |+-----------------|||           |    Protocol|
               +------------------+||  Storage  |------------+
                                   +|  Systems  |
                                    +-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The overall approach is that pNFS-enhanced clients obtain sufficient information from the server to enable them to access the underlying storage (on the storage systems) directly. See Section 12 of [RFC5661] for more details. This document is concerned with access from pNFS clients to storage devices over block storage protocols based on the SCSI Architecture Model [SAM-5], e.g., the Fibre Channel Protocol (FCP), Internet SCSI (iSCSI), or Serial Attached SCSI (SAS). pNFS SCSI layout requires block-based SCSI command sets, for example, SCSI Block Commands [SBC3]. While SCSI command sets for non-block-based access exist, these are not supported by the SCSI layout type, and all future references to SCSI storage devices will imply a block-based SCSI command set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
全体的なアプローチは、pNFSの強化、クライアントが直接（ストレージ・システム上の）基礎となるストレージにアクセスすることを可能にするために、サーバから十分な情報を入手することです。詳細については、[RFC5661]のセクション12を参照してください。このドキュメントは、に基づいて、ブロックストレージプロトコルを介してストレージデバイスへのpNFSクライアントからのアクセスに関係しているSCSIアーキテクチャモデル[SAM-5]、例えば、ファイバ・チャネル・プロトコル（FCP）、インターネットSCSI（iSCSI）、またはシリアルアタッチドSCSI（SAS ）。 pNFSのSCSIレイアウトは、例えば、ブロック・ベースのSCSIコマンドセットを、必要、SCSIブロックコマンド[SBC3]。非ブロック・ベースのアクセスのためのSCSIコマンド・セットが存在するが、これらは、SCSIのレイアウトタイプでサポートされていない、とSCSIストレージデバイスへのすべての将来の参照は、ブロックベースのSCSIコマンドセットを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Server to Storage System protocol, called the &#34;Control Protocol&#34;, is not of concern for interoperability, although it will typically be the same SCSI-based storage protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは通常、同じSCSIベースのストレージプロトコルになりますが、ストレージシステムのプロトコルにサーバーは、「制御プロトコル」と呼ばれる、相互運用性についての心配ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is based on [RFC5663] and makes changes to the block layout type to provide a better pNFS layout protocol for SCSI-based storage devices. Despite these changes, [RFC5663] remains the defining document for the existing block layout type. pNFS Block Disk Protection [RFC6688] is unnecessary in the context of the SCSI layout type because the new layout type provides mandatory disk access protection as part of the layout type definition. In contrast to [RFC5663], this document uses SCSI protocol features to provide reliable fencing by using SCSI persistent reservations, and it can provide reliable and efficient device discovery by using SCSI device identifiers instead of having to rely on probing all devices potentially attached to a client. This new layout type also optimizes the Input/Output (I/O) path by reducing the size of the LAYOUTCOMMIT payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは[RFC5663]に基づいており、SCSIベースのストレージデバイスのためのより良いのpNFSレイアウトプロトコルを提供するために、ブロックレイアウトタイプに変更を加えています。これらの変化にもかかわらず、[RFC5663]は、既存のブロック・レイアウト・タイプの定義文書のままです。新しいレイアウトタイプはレイアウトタイプ定義の一部として必須ディスクアクセス保護を提供するため、pNFSのブロックディスク保護[RFC6688]はSCSIのレイアウトタイプの文脈では不要です。 [RFC5663]とは対照的に、このドキュメントは、SCSI永続予約を使用して、信頼性のフェンシングを提供するために、SCSIプロトコルの機能を使用し、そしてそれは、潜在的に取り付けられた代わりに、すべてのデバイスをプロービングに頼らのSCSIデバイス識別子を使用して、信頼性の高い効率的なデバイス検出を提供することができますクライアント。この新しいレイアウトタイプもLAYOUTCOMMITペイロードのサイズを小さくすることにより、入力/出力（I / O）パスを最適化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The above two paragraphs summarize the major functional differences from [RFC5663]. There are other minor differences, e.g., the &#34;base&#34; volume type in this specification is used instead of the &#34;simple&#34; volume type in [RFC5663], but there are no significant differences in the data structures that describe the volume topology above this level (Section 2.3.2) or in the data structures that describe extents (Section 2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の二つの段落は、[RFC5663]からの主な機能の違いをまとめたもの。他のマイナーな違いは例えば、本明細書では「ベース」ボリュームタイプではなく、[RFC5663]で「シンプル」ボリュームタイプの使用されている、ありますが、このレベルを超えるボリュームのトポロジーを記述したデータ構造に有意差はありません（2.3.2）またはエクステント（2.4節）を記述するデータ構造インチ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Conventions Used in This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。このドキュメントの表記規則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はあります[RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. General Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。一般的な定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following definitions are provided for the purpose of providing an appropriate context for the reader.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の定義は、読者のために適切なコンテキストを提供する目的のために提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Byte: an octet, i.e., a datum exactly 8 bits in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト：オクテット、即ち、基準長さが正確に8ビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client: the entity that accesses the NFS server&#39;s resources. The client may be an application that contains the logic to access the NFS server directly. The client may also be the traditional operating system client that provides remote file system services for a set of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント：NFSサーバーのリソースにアクセスするエンティティ。クライアントは直接NFSサーバーにアクセスするためのロジックが含まれているアプリケーションであってもよいです。また、クライアントはアプリケーションのセットのためにリモートファイルシステムのサービスを提供し、伝統的なオペレーティングシステムのクライアントであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Server: the entity responsible for coordinating client access to a set of file systems and is identified by a server owner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー：ファイルシステムのセットへのクライアントアクセスを調整し、サーバーの所有者で識別されるための責任を負うエンティティ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Metadata Server (MDS): a pNFS server that provides metadata information for a file system object. It also is responsible for generating layouts for file system objects. Note that the MDS is also responsible for directory-based operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メタデータサーバ（MDS）：ファイル・システム・オブジェクトのメタデータ情報を提供するのpNFSサーバ。また、ファイルシステム・オブジェクトのレイアウトを生成するための責任があります。 MDSは、ディレクトリベースの操作に責任があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Code Components Licensing Notice
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3。コードコンポーネントのライセンスに関するお知らせ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The external data representation (XDR) description and scripts for extracting the XDR description are Code Components as described in Section 4 of &#34;Legal Provisions Relating to IETF Documents&#34; [LEGAL]. These Code Components are licensed according to the terms of Section 4 of &#34;Legal Provisions Relating to IETF Documents&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「IETFドキュメントに関連法規定」[法的]のセクション4で説明したように外部データ表現（XDR）の説明とXDR記述を抽出するためのスクリプトは、コードコンポーネントです。これらのコードコンポーネントは、「IETFドキュメントに関連法規定」の第4章の条項に従ってライセンスされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. XDR Description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4。 XDR説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document contains the XDR [RFC4506] description of the NFSv4.1 SCSI layout protocol. The XDR description is embedded in this document in a way that makes it simple for the reader to extract into a ready-to-compile form. The reader can feed this document into the following shell script to produce the machine-readable XDR description of the NFSv4.1 SCSI layout:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、NFSv4.1 SCSIレイアウトプロトコルのXDR [RFC4506]の記述が含まれています。 XDRの説明は、それが単純な読者がすぐにコンパイル形式に抽出することを可能にするように、この文書に埋め込まれています。リーダはNFSv4.1 SCSIレイアウトの機械可読XDR記述を生成するために、次のシェル・スクリプトにこの文書を供給することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#!/bin/sh grep &#39;^ *///&#39; $* | sed &#39;s?^ */// ??&#39; | sed &#39;s?^ *///$??&#39;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ます。＃！/ bin / shのはgrep &#39;^ * ///&#39; $ * | SEDの？^ * /// ?? &#39; | SEDの？^ * /// $ ?? &#39;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
That is, if the above script is stored in a file called &#34;extract.sh&#34;, and this document is in a file called &#34;spec.txt&#34;, then the reader can do:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記のスクリプトは、その後、読者が行うことができ、「extract.sh」と呼ばれるファイルに保存されており、この文書は「spec.txt」というファイルになっている場合には、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
sh extract.sh &lt; spec.txt &gt; scsi_prot.x
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SH extract.sh &lt;spec.txt&gt; scsi_prot.x
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The effect of the script is to remove leading white space from each line, plus a sentinel sequence of &#34;///&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スクリプトの効果は、主要な白の各ラインからのスペース、プラス「///」のセンチネル配列を除去することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The embedded XDR file header follows. Subsequent XDR descriptions with the sentinel sequence are embedded throughout the document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
埋め込みXDRファイルヘッダは以下の通りです。センチネル配列とそれに続くXDRの説明は文書全体に埋め込まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the XDR code contained in this document depends on types from the NFSv4.1 nfs4_prot.x file [RFC5662]. This includes both NFS types that end with a 4, such as offset4, length4, etc., as well as more generic types such as uint32_t and uint64_t.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書に含まれるXDRコードは[RFC5662]ファイルnfs4_prot.x NFSv4.1の種類に依存することに留意されたいです。これは、NFS等OFFSET4、LENGTH4、として4で終わるタイプ、並びにのuint32_tとuint64_tを、より一般的なタイプの両方を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /// /*
       ///  * This code was derived from RFC 8154.
       ///  * Please reproduce this note if possible.
       ///  */
       /// /*
       ///  * Copyright (c) 2017 IETF Trust and the persons
       ///  * identified as authors of the code.  All rights reserved.
       ///  *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       ///  * Redistribution and use in source and binary forms, with
       ///  * or without modification, are permitted provided that the
       ///  * following conditions are met:
       ///  *
       ///  * - Redistributions of source code must retain the above
       ///  *   copyright notice, this list of conditions and the
       ///  *   following disclaimer.
       ///  *
       ///  * - Redistributions in binary form must reproduce the above
       ///  *   copyright notice, this list of conditions and the
       ///  *   following disclaimer in the documentation and/or other
       ///  *   materials provided with the distribution.
       ///  *
       ///  * - Neither the name of Internet Society, IETF or IETF
       ///  *   Trust, nor the names of specific contributors, may be
       ///  *   used to endorse or promote products derived from this
       ///  *   software without specific prior written permission.
       ///  *
       ///  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
       ///  *   AND CONTRIBUTORS &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED
       ///  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
       ///  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
       ///  *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
       ///  *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
       ///  *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
       ///  *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
       ///  *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
       ///  *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
       ///  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
       ///  *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
       ///  *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
       ///  *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
       ///  *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
       ///  */
       ///
       /// /*
       ///  *      nfs4_scsi_layout_prot.x
       ///  */
       ///
       /// %#include &#34;nfsv41.h&#34;
       ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. SCSI Layout Description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. SCSIレイアウトの説明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Background and Architecture
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1。背景とアーキテクチャ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fundamental storage model supported by SCSI storage devices is a logical unit (LU) consisting of a sequential series of fixed-size blocks. Logical units used as devices for NFS SCSI layouts, and the SCSI initiators used for the pNFS metadata server and clients, MUST support SCSI persistent reservations as defined in [SPC4].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCSIストレージデバイスによってサポートされる基本的なストレージ・モデルは、固定サイズのブロックのシーケンシャル一連なる論理ユニット（LU）です。 [SPC4]で定義されているNFS SCSIレイアウトのためのデバイス、およびpNFSのメタデータ・サーバとクライアントのために使用されるSCSIイニシエータとして使用される論理ユニットは、SCSI Persistent Reservationをサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A pNFS layout for this SCSI class of storage is responsible for mapping from an NFS file (or portion of a file) to the blocks of storage volumes that contain the file. The blocks are expressed as extents with 64-bit offsets and lengths using the existing NFSv4 offset4 and length4 types. Clients MUST be able to perform I/O to the block extents without affecting additional areas of storage (especially important for writes); therefore, extents MUST be aligned to logical block size boundaries of the underlying logical units (typically 512 or 4096 bytes). For complex volume topologies, the server MUST ensure extents are aligned to the logical block size boundaries of the largest logical block size in the volume topology.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ストレージのこのSCSIクラスのpNFSのレイアウトは、ファイルを含むストレージボリュームのブロックにNFSファイル（またはファイルの一部）からのマッピングを担当します。ブロックは、既存のNFSv4 OFFSET4とLENGTH4タイプを使用して、64ビットのオフセットおよび長さを有するエクステントとして表されます。クライアントは、ストレージ（書き込みのために特に重要）の追加的な分野に影響を与えることなく、ブロックのエクステントにI / Oを実行できなければなりません。従って、エクステントは、基礎となる論理ユニット（典型的には512または4096バイト）の論理ブロックサイズの境界に整列されなければなりません。複雑なボリュームトポロジでは、エクステントを確保しなければならないサーバーは、ボリュームトポロジで最大の論理ブロックサイズの論理ブロックサイズの境界に整列されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The pNFS operation for requesting a layout (LAYOUTGET) includes the &#34;layoutiomode4 loga_iomode&#34; argument, which indicates whether the requested layout is for read-only use or read-write use. A read-only layout may contain holes that are read as zero, whereas a read-write layout will contain allocated but uninitialized storage in those holes (read as zero, can be written by client). This document also supports client participation in copy-on-write (e.g., for file systems with snapshots) by providing both read-only and uninitialized storage for the same range in a layout. Reads are initially performed on the read-only storage, with writes going to the uninitialized storage. After the first write that initializes the uninitialized storage, all reads are performed to that now-initialized writable storage, and the corresponding read-only storage is no longer used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レイアウト（LAYOUTGET）を要求するためのpNFS動作が要求されたレイアウトは、読み取り専用使用または読み取りと書き込み用であるかどうかを示す「layoutiomode4 loga_iomode」引数を含みます。読み書きレイアウトが割り当てられたが、これらの穴に初期化されていないストレージが（クライアントによって記述することができ、0として読ま）含有するであろう一方、読み取り専用レイアウトは、0として読まれる穴を含むことができます。また、このドキュメントは、読み取り専用の両方のレイアウトで同じ範囲および未初期化ストレージを提供することにより、コピー・オン・ライト（例えば、スナップショットのファイルシステムの場合）に、クライアントの参加をサポートします。最初に書き込みが初期化されていないストレージに行くと、読み出し専用の記憶装置上で実行されている読み込みます。初期化されていない記憶領域を初期化する最初の書き込みの後、全てはその今初期化書き込み可能なストレージに行われない読み取り、対応する読み取り専用ストレージはもはや使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SCSI layout solution expands the security responsibilities of the pNFS clients, and there are a number of environments where the mandatory-to-implement security properties for NFS cannot be satisfied. The additional security responsibilities of the client follow, and a full discussion is present in Section 4 (&#34;Security Considerations&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCSIレイアウトソリューションは、pNFSのクライアントのセキュリティ責任を展開し、NFSのための実装に必須のセキュリティプロパティを満たすことができない環境の数があります。クライアントの追加のセキュリティの責任は、次のとおりと十分な議論は、第4節（「セキュリティに関する考慮事項」）に存在しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Typically, SCSI storage devices provide access control mechanisms (e.g., Logical Unit Number (LUN) mapping and/or masking), which operate at the granularity of individual hosts, not individual blocks. For this reason, block-based protection must be provided by the client software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O典型的には、SCSIストレージデバイスは、個々のホストではなく、個々のブロックの粒度で動作するアクセス制御機構（例えば、論理ユニット番号（LUN）マッピング及び/又はマスキング）を提供します。このため、ブロックベースの保護は、クライアントソフトウェアによって提供されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Similarly, SCSI storage devices typically are not able to validate NFS locks that apply to file regions. For instance, if a file is covered by a mandatory read-only lock, the server can ensure that only readable layouts for the file are granted to pNFS clients. However, it is up to each pNFS client to ensure that the readable layout is used only to service read requests and not to allow writes to the existing parts of the file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O同様に、SCSIストレージデバイスは、典型的には、領域をファイルに適用NFSロックを検証することができません。ファイルは必須読み取り専用ロックでカバーされている場合たとえば、サーバーは、ファイルのための唯一の読み込み可能なレイアウトはpNFSのクライアントに付与されていることを確認することができます。しかし、それは読みやすいレイアウトはサービスが要求を読み込み、ファイルの既存の部品への書き込みを許可していないだけに使用されていることを確認するために、それぞれのpNFSクライアント次第です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since SCSI storage devices are generally not capable of enforcing such file-based security, in environments where pNFS clients cannot be trusted to enforce such policies, pNFS SCSI layouts MUST NOT be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCSIストレージデバイスは、一般的なファイルベースのセキュリティを強化することができないので、pNFSのクライアントは、このようなポリシーを適用するために信頼することができない環境では、pNFSのSCSIレイアウトを使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. layouttype4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2。 layouttype4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The layout4 type defined in [RFC5662] is extended with a new value as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように[RFC5662]で定義さlayout4タイプが新たな値に拡張されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        enum layouttype4 {
            LAYOUT4_NFSV4_1_FILES   = 1,
            LAYOUT4_OSD2_OBJECTS    = 2,
            LAYOUT4_BLOCK_VOLUME    = 3,
            LAYOUT4_SCSI            = 5
        };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines the structure associated with the layouttype4 value LAYOUT4_SCSI. [RFC5661] specifies the loc_body structure as an XDR type &#34;opaque&#34;. The opaque layout is uninterpreted by the generic pNFS client layers but obviously must be interpreted by the layout type implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書はlayouttype4値LAYOUT4_SCSIに関連付けられた構造を定義します。 [RFC5661]は「不透明」XDRタイプとしてloc_body構造を指定します。不透明なレイアウトは、汎用のpNFSクライアント層に解釈されることなくされているが、明らかにレイアウトタイプの実装によって解釈されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. GETDEVICEINFO
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3。 GETDEVICEINFO
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1. Volume Identification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1。ボリューム識別
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCSI targets implementing [SPC4] export unique LU names for each LU through the Device Identification Vital Product Data (VPD) page (page code 0x83), which can be obtained using the INQUIRY command with the Enable VPD (EVPD) bit set to one. This document uses a subset of this information to identify LUs backing pNFS SCSI layouts. The
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
有効VPD（EVPD）とINQUIRYコマンドを使用して得ることができるデバイス識別を介して重要製品データ（VPD）ページ（ページコード0x83の）を各LUの[SPC4]エクスポート固有のLU名を実装するSCSIターゲットは、一つにビットセット。この文書では、LUのバッキングのpNFSのSCSIレイアウトを識別するために、この情報のサブセットを使用しています。ザ・
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Device Identification VPD page descriptors used to identify LUs for use with pNFS SCSI layouts must adhere to the following restrictions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pNFSのSCSIレイアウトで使用するためのLUを識別するために使用されるデバイス識別VPDページ記述子は、次の制限に従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. The &#34;ASSOCIATION&#34; MUST be set to 0 (The &#34;DESIGNATOR&#34; field is associated with the addressed logical unit).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.「会合」は（「指示」フィールドがアドレス指定論理ユニットに関連付けられている）を0に設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. The &#34;DESIGNATOR TYPE&#34; MUST be set to one of four values that are required for the mandatory logical unit name in Section 7.7.3 of [SPC4], as explicitly listed in the &#34;pnfs_scsi_designator_type&#34; enumeration:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.「指示種別」として明示的に「pnfs_scsi_designator_type」列挙に記載されている、[SPC4]のセクション7.7.3に必須の論理ユニット名に必要とされる4つの値のいずれかに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PS_DESIGNATOR_T10 - based on T10 vendor ID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PS_DESIGNATOR_T10  -  T10のベンダーIDに基づいて、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PS_DESIGNATOR_EUI64 - based on EUI-64
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PS_DESIGNATOR_EUI64  -  EUI-64に基づきます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PS_DESIGNATOR_NAA - Network Address Authority (NAA)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Parsadesignatoranam  - ネットワーク局（NA）をアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PS_DESIGNATOR_NAME - SCSI name string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PS_DESIGNATOR_NAME  -  SCSI名文字列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Any other association or designator type MUST NOT be used. Use of T10 vendor IDs is discouraged when one of the other types can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.その他の会合または指示タイプを使用してはいけません。他のタイプのいずれかを使用することができたときにT10ベンダーIDの使用は推奨されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;CODE SET&#34; VPD page field is stored in the &#34;sbv_code_set&#34; field of the &#34;pnfs_scsi_base_volume_info4&#34; data structure, the &#34;DESIGNATOR TYPE&#34; is stored in &#34;sbv_designator_type&#34;, and the DESIGNATOR is stored in &#34;sbv_designator&#34;. Due to the use of an XDR array, the &#34;DESIGNATOR LENGTH&#34; field does not need to be set separately. Only certain combinations of &#34;sbv_code_set&#34; and &#34;sbv_designator_type&#34; are valid; please refer to [SPC4] for details, and note that ASCII MAY be used as the code set for UTF-8 text that contains only printable ASCII characters. Note that a Device Identification VPD page MAY contain multiple descriptors with the same association, code set, and designator type. Thus, NFS clients MUST check all the descriptors for a possible match to &#34;sbv_code_set&#34;, &#34;sbv_designator_type&#34;, and &#34;sbv_designator&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「コードセット」VPDページフィールドが「pnfs_scsi_base_volume_info4」データ構造の「sbv_code_set」フィールドに格納され、「指示タイプは」「sbv_designator_type」に格納され、指示が「sbv_designator」に格納されます。 XDR配列の使用に、「指示のLENGTH」フィールドには、個別に設定する必要はありません。 「sbv_code_set」と「sbv_designator_type」の特定の組み合わせのみが有効です。詳細については、[SPC4]を参照して、そのASCIIのみ印刷可能なASCII文字を含むUTF-8文字のコードセットとして使用することがありますのでご注意ください。デバイス識別VPDページが同じアソシエーション、コード・セット、および指示タイプに複数の記述子を含むことができることに留意されたいです。したがって、NFSクライアントは、「sbv_code_set」、「sbv_designator_type」、および「sbv_designator」に可能な一致するすべての記述子をチェックしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Storage devices such as storage arrays can have multiple physical network interfaces that need not be connected to a common network, resulting in a pNFS client having simultaneous multipath access to the same storage volumes via different ports on different networks. Selection of one or multiple ports to access the storage device is left up to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このようなストレージアレイなどの記憶装置は、異なるネットワーク上の異なるポートを介して、同一のストレージ・ボリュームへの同時マルチアクセスを有するのpNFSクライアントで得られた、共通のネットワークに接続される必要はなく、複数の物理ネットワーク・インターフェースを有することができます。ストレージデバイスにアクセスするための1つのまたは複数のポートの選択は、クライアントに任されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Additionally, the server returns a persistent reservation key in the &#34;sbv_pr_key&#34; field. See Section 2.4.10 for more details on the use of persistent reservations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、サーバは「sbv_pr_key」フィールドに永続予約キーを返します。永続予約の使用方法の詳細については、セクション2.4.10を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2. Volume Topology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2。ボリュームトポロジ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The pNFS SCSI layout volume topology is expressed in terms of the volume types described below. The individual components of the topology are contained in an array, and components MAY refer to other components by using array indices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pNFSのSCSIレイアウトボリュームトポロジは、後述するボリュームの種類の観点で表現されます。トポロジーの個々の成分は、アレイに含まれ、そしてコンポーネントは、配列インデックスを使用して、他の構成要素を指すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// enum pnfs_scsi_volume_type4 {
   ///     PNFS_SCSI_VOLUME_SLICE  = 1,  /* volume is a slice of
   ///                                      another volume */
   ///     PNFS_SCSI_VOLUME_CONCAT = 2,  /* volume is a
   ///                                      concatenation of
   ///                                      multiple volumes */
   ///     PNFS_SCSI_VOLUME_STRIPE = 3   /* volume is striped across
   ///                                      multiple volumes */
   ///     PNFS_SCSI_VOLUME_BASE   = 4,  /* volume maps to a single
   ///                                      LU */
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// /*
   ///  * Code sets from SPC-4.
   ///  */
   /// enum pnfs_scsi_code_set {
   ///     PS_CODE_SET_BINARY     = 1,
   ///     PS_CODE_SET_ASCII      = 2,
   ///     PS_CODE_SET_UTF8       = 3
   /// };
   ///
   /// /*
   ///  * Designator types taken from SPC-4.
   ///  *
   ///  * Other values are allocated in SPC-4 but are not mandatory to
   ///  * implement or aren&#39;t logical unit names.
   ///  */
   /// enum pnfs_scsi_designator_type {
   ///     PS_DESIGNATOR_T10      = 1,
   ///     PS_DESIGNATOR_EUI64    = 2,
   ///     PS_DESIGNATOR_NAA      = 3,
   ///     PS_DESIGNATOR_NAME     = 8
   /// };
   ///
   /// /*
   ///  * Logical unit name + reservation key.
   ///  */
   /// struct pnfs_scsi_base_volume_info4 {
   ///     pnfs_scsi_code_set             sbv_code_set;
   ///     pnfs_scsi_designator_type      sbv_designator_type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ///     opaque                         sbv_designator&lt;&gt;;
   ///     uint64_t                       sbv_pr_key;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// struct pnfs_scsi_slice_volume_info4 {
   ///     offset4  ssv_start;            /* offset of the start of
   ///                                       the slice in bytes */
   ///     length4  ssv_length;           /* length of slice in
   ///                                       bytes */
   ///     uint32_t ssv_volume;           /* array index of sliced
   ///                                       volume */
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ///
   /// struct pnfs_scsi_concat_volume_info4 {
   ///     uint32_t  scv_volumes&lt;&gt;;       /* array indices of volumes
   ///                                       that are concatenated */
   /// };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ///
   /// struct pnfs_scsi_stripe_volume_info4 {
   ///     length4  ssv_stripe_unit;      /* size of stripe in bytes */
   ///     uint32_t ssv_volumes&lt;&gt;;        /* array indices of
   ///                                       volumes that are striped
   ///                                       across -- MUST be same
   ///                                       size */
   /// };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ///
   /// union pnfs_scsi_volume4 switch (pnfs_scsi_volume_type4 type) {
   ///     case PNFS_SCSI_VOLUME_BASE:
   ///         pnfs_scsi_base_volume_info4 sv_simple_info;
   ///     case PNFS_SCSI_VOLUME_SLICE:
   ///         pnfs_scsi_slice_volume_info4 sv_slice_info;
   ///     case PNFS_SCSI_VOLUME_CONCAT:
   ///         pnfs_scsi_concat_volume_info4 sv_concat_info;
   ///     case PNFS_SCSI_VOLUME_STRIPE:
   ///         pnfs_scsi_stripe_volume_info4 sv_stripe_info;
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// /* SCSI layout-specific type for da_addr_body */
   /// struct pnfs_scsi_deviceaddr4 {
   ///     pnfs_scsi_volume4 sda_volumes&lt;&gt;; /* array of volumes */
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;pnfs_scsi_deviceaddr4&#34; data structure is a structure that allows arbitrarily complex nested volume structures to be encoded. The types of aggregations that are allowed are stripes, concatenations, and slices. Note that the volume topology expressed in the &#34;pnfs_scsi_deviceaddr4&#34; data structure will always resolve to a set of &#34;pnfs_scsi_volume_type4&#34; PNFS_SCSI_VOLUME_BASE. The array of volumes is ordered such that the root of the volume hierarchy is the last element of the array. Concat, slice, and stripe volumes MUST refer to volumes defined by lower indexed elements of the array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「pnfs_scsi_deviceaddr4」データ構造は、任意の複雑なネストされたボリューム構造が符号化されることを可能にする構造です。許可されている集計の種類は、ストライプ、の連結、およびスライスされています。 「pnfs_scsi_deviceaddr4」データ構造で表現ボリュームトポロジは、常に「pnfs_scsi_volume_type4」PNFS_SCSI_VOLUME_BASEのセットに解決されることに注意してください。ボリュームの配列は、ボリューム階層のルートは、配列の最後の要素であるように命じています。連結、スライス、ストライプ・ボリュームは、アレイの下側インデックス付き要素によって定義されたボリュームを参照しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;pnfs_scsi_deviceaddr4&#34; data structure is returned by the server as the storage-protocol-specific opaque field &#34;da_addr_body&#34; in the &#34;device_addr4&#34; data structure by a successful GETDEVICEINFO operation [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「pnfs_scsi_deviceaddr4」データ構造が成功GETDEVICEINFO操作により「device_addr4」データ構造におけるストレージプロトコル固有の不透明なフィールド「da_addr_body」[RFC5661]としてサーバによって返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As noted above, all &#34;device_addr4&#34; data structures eventually resolve to a set of volumes of type PNFS_SCSI_VOLUME_BASE. Complicated volume hierarchies may be composed of dozens of volumes, each with several components; thus, the device address may require several kilobytes. The client SHOULD be prepared to allocate a large buffer to contain the result. In the case of the server returning NFS4ERR_TOOSMALL, the client SHOULD allocate a buffer of at least gdir_mincount_bytes to contain the expected result and retry the GETDEVICEINFO request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上述のように、すべての「device_addr4」データ構造は、最終的に型PNFS_SCSI_VOLUME_BASEのボリュームのセットに解決します。複雑なボリューム階層は、ボリューム、いくつかのコンポーネントとそれぞれ数十から構成されてもよいです。このように、デバイスのアドレスは、数キロバイトが必要な場合があります。クライアントが結果を格納するための大きなバッファを割り当てるために準備する必要があります。 NFS4ERR_TOOSMALLを返すサーバの場合には、クライアントは、期待される結果を含み、GETDEVICEINFO要求を再試行する少なくともgdir_mincount_bytesのバッファを割り当てる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. Data Structures: Extents and Extent Lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4。データ構造：エクステントとエクステントリスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A pNFS SCSI layout is a list of extents within a flat array of data blocks in a volume. The details of the volume topology can be determined by using the GETDEVICEINFO operation. The SCSI layout describes the individual block extents on the volume that make up the file. The offsets and length contained in an extent are specified in units of bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pNFSのSCSIレイアウトは、ボリューム内のデータ・ブロックのフラットアレイ内のエクステントのリストです。ボリュームトポロジの詳細はGETDEVICEINFO操作を使用して決定することができます。 SCSIのレイアウトは、ファイルを構成するボリューム上の個々のブロックのエクステントを記述する。エクステントに含まれるオフセットと長さをバイト単位で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// enum pnfs_scsi_extent_state4 {
   ///     PNFS_SCSI_READ_WRITE_DATA = 0, /* the data located by
   ///                                       this extent is valid
   ///                                       for reading and
   ///                                       writing. */
   ///     PNFS_SCSI_READ_DATA      = 1,  /* the data located by this
   ///                                       extent is valid for
   ///                                       reading only; it may not
   ///                                       be written. */
   ///     PNFS_SCSI_INVALID_DATA   = 2,  /* the location is valid; the
   ///                                       data is invalid.  It is a
   ///                                       newly (pre-)allocated
   ///                                       extent.  The client MUST
   ///                                       not read from this
   ///                                       space. */
   ///     PNFS_SCSI_NONE_DATA      = 3   /* the location is invalid.
   ///                                       It is a hole in the file.
   ///                                       The client MUST NOT read
   ///                                       from or write to this
   ///                                       space. */
   /// };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ///
   /// struct pnfs_scsi_extent4 {
   ///     deviceid4    se_vol_id;         /* id of the volume on
   ///                                        which extent of file is
   ///                                        stored */
   ///     offset4      se_file_offset;    /* starting byte offset
   ///                                        in the file */
   ///     length4      se_length;         /* size in bytes of the
   ///                                        extent */
   ///     offset4      se_storage_offset; /* starting byte offset
   ///                                        in the volume */
   ///     pnfs_scsi_extent_state4 se_state;
   ///                                     /* state of this extent */
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /// /* SCSI layout-specific type for loc_body */
   /// struct pnfs_scsi_layout4 {
   ///     pnfs_scsi_extent4 sl_extents&lt;&gt;;
   ///                                    /* extents that make up this
   ///                                       layout */
   /// };
   ///
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SCSI layout consists of a list of extents that map the regions of the file to locations on a volume. The &#34;se_storage_offset&#34; field within each extent identifies a location on the volume specified by the &#34;se_vol_id&#34; field in the extent. The &#34;se_vol_id&#34; itself is shorthand for the whole topology of the volume on which the file is stored. The client is responsible for translating this volume-relative offset into an offset on the appropriate underlying SCSI LU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCSIのレイアウトは、ボリューム上の場所にファイルの領域をマッピングするエクステントのリストで構成されます。各エクステント内の「se_storage_offset」フィールドは、エクステントに「se_vol_id」フィールドによって指定されたボリューム上の位置を特定します。 「se_vol_id」自体は、ファイルが保存されているボリュームのトポロジ全体の省略形です。クライアントは、適切な基盤となるのSCSI LUにオフセットへのオフセットこのボリューム相対を変換する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each extent maps a region of the file onto a portion of the specified LU. The &#34;se_file_offset&#34;, &#34;se_length&#34;, and &#34;se_state&#34; fields for an extent returned from the server are valid for all extents. In contrast, the interpretation of the &#34;se_storage_offset&#34; field depends on the value of &#34;se_state&#34; as follows (in increasing order):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各エクステントは、指定されたLUの部分にファイルの領域をマッピングします。サーバから返されたエクステントの「se_file_offset」、「se_length」、および「se_state」のフィールドは、すべてのエクステントのために有効です。対照的に、「se_storage_offset」フィールドの解釈は、（昇順で）次のように「se_state」の値に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PNFS_SCSI_READ_WRITE_DATA &#34;se_storage_offset&#34; is valid and points to valid/initialized data that can be read and written.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PNFS_SCSI_READ_WRITE_DATA「se_storage_offsetは」読み書き可能な有効/初期化されたデータを有効とポイントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PNFS_SCSI_READ_DATA &#34;se_storage_offset&#34; is valid and points to valid/initialized data that can only be read. Write operations are prohibited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PNFS_SCSI_READ_DATA「se_storage_offsetは、」読み取り専用ことができ、有効/初期化されたデータを有効とポイントです。書き込み操作が禁止されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PNFS_SCSI_INVALID_DATA &#34;se_storage_offset&#34; is valid but points to invalid, uninitialized data. This data MUST not be read from the disk until it has been initialized. A read request for a PNFS_SCSI_INVALID_DATA extent MUST fill the user buffer with zeros, unless the extent is covered by a PNFS_SCSI_READ_DATA extent of a copy-on-write file system. Write requests MUST write whole server-sized blocks to the disk; bytes not initialized by the user MUST be set to zero. Any write to storage in a PNFS_SCSI_INVALID_DATA extent changes the written portion of the extent to PNFS_SCSI_READ_WRITE_DATA; the pNFS client is responsible for reporting this change via LAYOUTCOMMIT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PNFS_SCSI_INVALID_DATA「se_storage_offset」は無効、初期化されていないデータに有効ですが、ポイントです。それが初期化されるまで、このデータは、ディスクから読み取られてはなりません。エクステントは、コピーオンライトファイルシステムのPNFS_SCSI_READ_DATAの程度によって覆われていない限りPNFS_SCSI_INVALID_DATAエクステントの読み出し要求は、ゼロでユーザバッファを満たさなければなりません。書き込み要求は、ディスクへのサーバ全体サイズのブロックを記述する必要があります。ユーザーが初期化されていないバイトをゼロに設定しなければなりません。 PNFS_SCSI_INVALID_DATAエクステントの記憶への書き込みはPNFS_SCSI_READ_WRITE_DATA程度の書かれた部分を変更します。 pNFSのクライアントはLAYOUTCOMMIT経由でこの変更を報告する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PNFS_SCSI_NONE_DATA &#34;se_storage_offset&#34; is not valid, and this extent MAY not be used to satisfy write requests. Read requests MAY be satisfied by zero-filling as for PNFS_SCSI_INVALID_DATA. PNFS_SCSI_NONE_DATA extents MAY be returned by requests for readable extents; they are never returned if the request was for a writable extent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PNFS_SCSI_NONE_DATA「se_storage_offsetは、」有効ではありませんが、この範囲は、書き込み要求を満たすために使用することはできません。 PNFS_SCSI_INVALID_DATA用としてゼロフィリングによって満たすことができるのリクエストをお読みください。 PNFS_SCSI_NONE_DATAエクステントが読める程度の要求によって返されることがあります。リクエストが書き込み可能な範囲のためだった場合、彼らが返されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An extent list contains all relevant extents in increasing order of the se_file_offset of each extent; any ties are broken by increasing order of the extent state (se_state).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
範囲リストは、各エクステントのse_file_offsetの昇順に関連するすべてのエクステントが含まれています。任意関係は、エクステント状態（se_state）の順序を増加させることによって破壊されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.1. Layout Requests and Extent Lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.1。要求とエクステントリストのレイアウト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each request for a layout specifies at least three parameters: file offset, desired size, and minimum size. If the status of a request indicates success, the extent list returned MUST meet the following criteria:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルオフセット、所望の大きさ、および最小サイズ：レイアウトのための各要求は、少なくとも3つのパラメータを指定します。リクエストのステータスが成功を示す場合、エクステントリストが返され、次の条件を満たしている必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A request for a readable (but not writable) layout MUST return either PNFS_SCSI_READ_DATA or PNFS_SCSI_NONE_DATA extents. It SHALL NOT return PNFS_SCSI_INVALID_DATA or PNFS_SCSI_READ_WRITE_DATA extents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O読み取り可能な（しかし書き込み可能ではない）のレイアウトの要求がPNFS_SCSI_READ_DATA又はPNFS_SCSI_NONE_DATAエクステントのいずれかを返さなければなりません。それはPNFS_SCSI_INVALID_DATAまたはPNFS_SCSI_READ_WRITE_DATAエクステントを返さないものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A request for a writable layout MUST return PNFS_SCSI_READ_WRITE_DATA or PNFS_SCSI_INVALID_DATA extents, and it MAY return additional PNFS_SCSI_READ_DATA extents for ranges covered by PNFS_SCSI_INVALID_DATA extents to allow client-side copy-on-write operations. A request for a writable layout SHALL NOT return PNFS_SCSI_NONE_DATA extents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O書き込み可能なレイアウトのための要求がPNFS_SCSI_READ_WRITE_DATAまたはPNFS_SCSI_INVALID_DATAエクステントを返さなければならない、そしてそれは、クライアント側のコピー・オン・ライト操作を許可するようPNFS_SCSI_INVALID_DATAエクステントでカバー範囲のための追加PNFS_SCSI_READ_DATAエクステントを返してもよいです。書き込み可能なレイアウトのための要求はPNFS_SCSI_NONE_DATAエクステントを返さないものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The first extent in the list MUST contain the requested starting offset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oリストの最初のエクステントは、オフセット要求の開始を含まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The total size of extents within the requested range MUST cover at least the minimum size. One exception is allowed: the total size MAY be smaller if only readable extents were requested and EOF is encountered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O要求された範囲内のエクステントの合計サイズが少なくとも最小サイズをカバーしなければなりません。一つの例外が許可されている：のみ読み込み可能なエクステントが要求されたとEOFが発生した場合の合計サイズが小さくてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Extents in the extent list MUST be logically contiguous for a read-only layout. For a read-write layout, the set of writable extents (i.e., excluding PNFS_SCSI_READ_DATA extents) MUST be logically contiguous. Every PNFS_SCSI_READ_DATA extent in a read-write layout MUST be covered by one or more PNFS_SCSI_INVALID_DATA extents. This overlap of PNFS_SCSI_READ_DATA and PNFS_SCSI_INVALID_DATA extents is the only permitted extent overlap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O範囲リスト内のエクステントは、読み取り専用のレイアウトのための論理的に連続している必要があります。読み書きレイアウト（すなわち、PNFS_SCSI_READ_DATAエクステントを除く）書き込み可能なエクステントの集合は、論理的に連続していなければなりません。読み書きレイアウト内のすべてのPNFS_SCSI_READ_DATAの範囲は、一つ以上のPNFS_SCSI_INVALID_DATAエクステントによって覆われている必要があります。 PNFS_SCSI_READ_DATAとPNFS_SCSI_INVALID_DATAエクステントのこの重なりは、許可された範囲の重複です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Extents MUST be ordered in the list by starting offset, with PNFS_SCSI_READ_DATA extents preceding PNFS_SCSI_INVALID_DATA extents in the case of equal se_file_offsets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oエクステントは等しいse_file_offsetsの場合にPNFS_SCSI_INVALID_DATAエクステントの前PNFS_SCSI_READ_DATAエクステントと、開始オフセットによってリストに注文する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
According to [RFC5661], if the minimum requested size, loga_minlength, is zero, this is an indication to the metadata server that the client desires any layout at offset loga_offset or less that the metadata server has &#34;readily available&#34;. Given the lack of a clear definition of this phrase, in the context of the SCSI layout type, when loga_minlength is zero, the metadata server SHOULD do the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最小の要求されたサイズ、loga_minlengthは、ゼロであれば、[RFC5661]によれば、これは、クライアントがメタデータサーバは、「容易に入手可能」を有することオフセットloga_offset以下で任意のレイアウトを希望するメタデータ・サーバへの指示です。 loga_minlengthがゼロの場合、このフレーズの明確な定義の欠如を考えると、SCSIのレイアウトタイプのコンテキストで、メタデータサーバは、次の操作を行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o when processing requests for readable layouts, return all such layouts, even if some extents are in the PNFS_SCSI_NONE_DATA state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
読みやすいレイアウトの要求を処理する際、O、いくつかのエクステントがPNFS_SCSI_NONE_DATA状態にある場合でも、そのようなすべてのレイアウトを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o when processing requests for writable layouts, return extents that can be returned in the PNFS_SCSI_READ_WRITE_DATA state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
書き込み可能なレイアウトのための要求を処理するとき、O、PNFS_SCSI_READ_WRITE_DATA状態に戻すことができエクステントを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.2. Layout Commits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.2。レイアウトは、コミット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     ///
     /// /* SCSI layout-specific type for lou_body */
     ///
     /// struct pnfs_scsi_range4 {
     ///     offset4      sr_file_offset;   /* starting byte offset
     ///                                       in the file */
     ///     length4      sr_length;        /* size in bytes */
     /// };
     ///
     /// struct pnfs_scsi_layoutupdate4 {
     ///     pnfs_scsi_range4 slu_commit_list&lt;&gt;;
     ///                                    /* list of extents that
     ///                                     * now contain valid data.
     ///                                     */
     /// };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;pnfs_scsi_layoutupdate4&#34; data structure is used by the client as the SCSI layout-specific argument in a LAYOUTCOMMIT operation. The &#34;slu_commit_list&#34; field is a list covering regions of the file layout that were previously in the PNFS_SCSI_INVALID_DATA state but have been written by the client and SHOULD now be considered in the PNFS_SCSI_READ_WRITE_DATA state. The extents in the commit list MUST be disjoint and MUST be sorted by sr_file_offset. Implementors should be aware that a server MAY be unable to commit regions at a granularity smaller than a file system block (typically 4 KB or 8 KB). As noted above, the block size that the server uses is available as an NFSv4 attribute, and any extents included in the &#34;slu_commit_list&#34; MUST be aligned to this granularity and have a size that is a multiple of this granularity. Since the block in question is in state PNFS_SCSI_INVALID_DATA, byte ranges not written SHOULD be filled with zeros. This applies even if it appears that the area being written is beyond what the client believes to be the end of file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「pnfs_scsi_layoutupdate4」データ構造はLAYOUTCOMMIT操作でSCSIレイアウト固有の引数としてクライアントによって使用されます。 「slu_commit_list」フィールドはPNFS_SCSI_INVALID_DATA状態で以前にあったが、クライアントによって書かれていると、今PNFS_SCSI_READ_WRITE_DATA状態で考慮すべきファイルレイアウトの領域をカバーするリストです。コミットリスト内のエクステントは互いに素でなければならないとsr_file_offsetでソートする必要があります。実装は、サーバがファイル・システム・ブロック（典型的には4キロバイトまたは8 KB）より小さい粒度で領域をコミットすることができない可能性があることに注意すべきです。上述したように、サーバが使用するブロックサイズはNFSv4の属性として使用可能であり、任意のエクステントは「slu_commit_list」に含まれるこの粒状に位置合わせし、この粒度の倍数のサイズを持っている必要があります。当該ブロックは、状態PNFS_SCSI_INVALID_DATAであるので、書き込まれていないバイト範囲をゼロで埋めされるべきです。これは、書かれているエリアは、クライアントがファイルの終わりであると信じるものを超えていると思われる場合にも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.3. Layout Returns
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.3。レイアウトを返します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A LAYOUTRETURN operation represents an explicit release of resources by the client. This MAY be done in response to a CB_LAYOUTRECALL or before any recall, in order to avoid a future CB_LAYOUTRECALL. When the LAYOUTRETURN operation specifies a LAYOUTRETURN4_FILE return type, then the &#34;layoutreturn_file4&#34; data structure specifies the region of the file layout that is no longer needed by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LAYOUTRETURN操作は、クライアントによるリソースの明示的な解放を表しています。これは、将来CB_LAYOUTRECALLを避けるために、CB_LAYOUTRECALLに応じて、または任意のリコール前に行うことができます。 LAYOUTRETURN操作がLAYOUTRETURN4_FILEの戻り値の型を指定すると、その後、「layoutreturn_file4」データ構造はもはやクライアントが必要とするファイルレイアウトの領域を特定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The LAYOUTRETURN operation is done without any data specific to the SCSI layout. The opaque &#34;lrf_body&#34; field of the &#34;layoutreturn_file4&#34; data structure MUST have length zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LAYOUTRETURN操作は、SCSIのレイアウトに固有のデータなしで行われます。 「layoutreturn_file4」データ構造の不透明な「lrf_body」フィールドは、長さゼロでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.4. Layout Revocation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.4。レイアウト失効
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Layouts MAY be unilaterally revoked by the server due to the client&#39;s lease time expiring or the client failing to return a layout that has been recalled in a timely manner. For the SCSI layout type, this is accomplished by fencing off the client from access to storage as described in Section 2.4.10. When this is done, it is necessary that all I/Os issued by the fenced-off client be rejected by the storage. This includes any in-flight I/Os that the client issued before the layout was revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レイアウトは、一方的にタイムリーにリコールされたレイアウトを返すために失敗によるクライアントのリース時間期限切れまたはサーバからクライアントに取り消すことができます。 SCSIのレイアウトタイプの場合、これは、セクション2.4.10で説明したようにストレージへのアクセスからクライアントをオフフェンシングことによって達成されます。これが行われると、フェンスオフクライアントによって発行されたすべてのI / Oがストレージによって拒否されることが必要です。これは、任意のは、飛行中のI / Oをレイアウトする前に発行したクライアントが取り消されたことが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the granularity of this operation can only be at the host/ LU level. Thus, if one of a client&#39;s layouts is unilaterally revoked by the server, it will effectively render useless *all* of the client&#39;s layouts for files located on the storage units comprising the volume. This may render useless the client&#39;s layouts for files in other file systems. See Section 2.4.10.5 for a discussion of recovery from fencing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この操作の粒度でのみホスト/ LUレベルであってもよいことに留意されたいです。クライアントのレイアウトのいずれかが一方的にサーバーによって取り消された場合このように、それが効果的に役に立たないレンダリングされます*ボリュームを構成するストレージユニット上にあるファイルのためのクライアントのレイアウトのすべての*。これは、他のファイルシステム内のファイルの役に立たないクライアントのレイアウトをレンダリングすることがあります。フェンシングからの回復の議論については、セクション2.4.10.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.5. Client Copy-on-Write Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.5。クライアントのコピー・オン・ライト処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copy-on-write is a mechanism used to support file and/or file system snapshots. When writing to unaligned regions, or to regions smaller than a file system block, the writer MUST copy the portions of the original file data to a new location on disk. This behavior can be implemented either on the client or the server. The paragraphs below describe how a pNFS SCSI layout client implements access to a file that requires copy-on-write semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コピー・オン・ライトは、ファイルおよび/またはファイルシステムのスナップショットをサポートするために使用されるメカニズムです。アラインされていない領域に、またはファイルシステムのブロックよりも小さい領域に書き込むときに、書き込みは、ディスク上の新たな場所に元のファイルデータの一部をコピーする必要があります。この動作は、クライアントまたはサーバー上で実装することができます。以下の段落では、pNFSのSCSIレイアウトクライアントは、コピーオンライトセマンティクスを必要とし、ファイルへのアクセスを実装する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Distinguishing the PNFS_SCSI_READ_WRITE_DATA and PNFS_SCSI_READ_DATA extent types in combination with the allowed overlap of PNFS_SCSI_READ_DATA extents with PNFS_SCSI_INVALID_DATA extents allows copy-on-write processing to be done by pNFS clients. In classic NFS, this operation would be done by the server. Since pNFS enables clients to do direct block access, it is useful for clients to participate in copy-on-write operations. All SCSI pNFS clients MUST support this copy-on-write processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PNFS_SCSI_INVALID_DATAエクステントとPNFS_SCSI_READ_DATAエクステントの許容オーバーラップと組み合わせてPNFS_SCSI_READ_WRITE_DATAとPNFS_SCSI_READ_DATAエクステントタイプを区別することは、コピーオンライト処理のpNFSクライアントによって行われることを可能にします。古典的なNFSでは、この操作は、サーバーによって行われます。 pNFSの直接ブロックアクセスを行うために、クライアントを可能にするので、クライアントはコピーオンライト操作に参加するために、それは便利です。すべてのSCSI pNFSのクライアントは、このコピー・オン・ライト処理をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client wishes to write data covered by a PNFS_SCSI_READ_DATA extent, it MUST have requested a writable layout from the server; that layout will contain PNFS_SCSI_INVALID_DATA extents to cover all the data ranges of that layout&#39;s PNFS_SCSI_READ_DATA extents. More precisely, for any se_file_offset range covered by one or more PNFS_SCSI_READ_DATA extents in a writable layout, the server MUST include one or more PNFS_SCSI_INVALID_DATA extents in the layout that cover the same se_file_offset range. When performing a write to such an area of a layout, the client MUST effectively copy the data from the PNFS_SCSI_READ_DATA extent for any partial blocks of se_file_offset and range, merge in the changes to be written, and write the result to the PNFS_SCSI_INVALID_DATA extent for the blocks for that se_file_offset and range. That is, if entire blocks of data are to be overwritten by an operation, the corresponding PNFS_SCSI_READ_DATA blocks need not be fetched, but any partial-block writes MUST be merged with data fetched via PNFS_SCSI_READ_DATA extents before storing the result via PNFS_SCSI_INVALID_DATA extents. For the purposes of this discussion, &#34;entire blocks&#34; and &#34;partial blocks&#34; refer to the block size of the server&#39;s file system. Storing of data in a PNFS_SCSI_INVALID_DATA extent converts the written portion of the PNFS_SCSI_INVALID_DATA extent to a PNFS_SCSI_READ_WRITE_DATA extent; all subsequent reads MUST be performed from this extent; the corresponding portion of the PNFS_SCSI_READ_DATA extent MUST NOT be used after storing data in a PNFS_SCSI_INVALID_DATA extent. If a client writes only a portion of an extent, the extent MAY be split at block-aligned boundaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがPNFS_SCSI_READ_DATAの程度によってカバーされたデータを書き込みしたいときは、サーバーから書き込み可能なレイアウトを要求していなければなりません。そのレイアウトは、そのレイアウトのPNFS_SCSI_READ_DATAエクステントのすべてのデータの範囲をカバーするためにPNFS_SCSI_INVALID_DATAのエクステントが含まれています。より正確には、書き込み可能なレイアウトの1つ以上のPNFS_SCSI_READ_DATAエクステントによって覆わ任意se_file_offset範囲について、サーバは同じse_file_offset範囲をカバーレイアウト内の1つまたは複数のPNFS_SCSI_INVALID_DATAエクステントを含まなければなりません。レイアウトのような領域への書き込みを行う場合、クライアントは、効果的に書き込まれるように変更をマージし、se_file_offset及び範囲の任意の部分ブロックのためPNFS_SCSI_READ_DATAエクステントからデータをコピーし、そしてためPNFS_SCSI_INVALID_DATAの程度に結果を書き込む必要がありますそのse_file_offsetおよび範囲のためのブロック。データのブロック全体を操作することによって上書きされる場合には、である、対応するPNFS_SCSI_READ_DATAブロックがフェッチされる必要はなく、任意の部分的なブロック書き込みはPNFS_SCSI_INVALID_DATAエクステントを介して結果を格納する前PNFS_SCSI_READ_DATAエクステントを介して取り込まれたデータとマージしなければなりません。この議論の目的のために、「ブロック全体」と「部分ブロックは、」サーバのファイルシステムのブロックサイズを参照してください。 PNFS_SCSI_INVALID_DATAエクステントのデータの格納はPNFS_SCSI_READ_WRITE_DATAエクステントにPNFS_SCSI_INVALID_DATAエクステントの書かれた部分を変換します。後続のすべてがこの範囲から実行されなければならない読み出します。 PNFS_SCSI_READ_DATAエクステントの対応する部分がPNFS_SCSI_INVALID_DATAエクステントにデータを格納した後に使用してはいけません。クライアントはある程度の一部のみを書き込んだ場合、範囲はブロックアライン境界で分割することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client wishes to write data to a PNFS_SCSI_INVALID_DATA extent that is not covered by a PNFS_SCSI_READ_DATA extent, it MUST treat this write identically to a write to a file not involved with copy-on-write semantics. Thus, data MUST be written in at least block-sized increments and aligned to multiples of block-sized offsets, and unwritten portions of blocks MUST be zero filled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがPNFS_SCSI_READ_DATAの範囲で覆われていないPNFS_SCSI_INVALID_DATAエクステントにデータを書き込むことを希望する場合、それはコピーオンライトセマンティクスに関与していないファイルへの書き込みと同一にこの書き込みを扱わなければなりません。したがって、データは、少なくともブロックサイズ単位で書き込まれ、ブロックサイズオフセットの倍数に揃え、そしてブロックの未書き込み部分はゼロで埋めなければならないれなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.6. Extents Are Permissions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.6。エクステントは、パーミッションです
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Layout extents returned to pNFS clients grant permission to read or write; PNFS_SCSI_READ_DATA and PNFS_SCSI_NONE_DATA are read-only (PNFS_SCSI_NONE_DATA reads as zeros), and PNFS_SCSI_READ_WRITE_DATA and PNFS_SCSI_INVALID_DATA are read-write (PNFS_SCSI_INVALID_DATA reads as zeros; any write converts it to PNFS_SCSI_READ_WRITE_DATA). This is the only means a client has of obtaining permission to perform direct I/O to storage devices; a pNFS client MUST NOT perform direct I/O operations that are not permitted by an extent held by the client. Client adherence to this rule places the pNFS server in control of potentially conflicting storage device operations, enabling the server to determine what does conflict and how to avoid conflicts by granting and recalling extents to/from clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レイアウトエクステントは、クライアントが読み書きする権限を付与するのpNFSに戻りました。 PNFS_SCSI_READ_DATAとPNFS_SCSI_NONE_DATAは（PNFS_SCSI_NONE_DATAがゼロとして読み取る）読み取り専用、およびPNFS_SCSI_READ_WRITE_DATAとPNFS_SCSI_INVALID_DATAは（PNFS_SCSI_INVALID_DATAはゼロとして読み出し、任意の書き込みがPNFS_SCSI_READ_WRITE_DATAに変換）読み書きされています。これは、クライアントがストレージデバイスへのダイレクトI / Oを実行するために許可を得るのがある意味です。 pNFSのクライアントは、クライアントが保持している範囲で許可されていないダイレクトI / O操作を実行してはなりません。この規則へのクライアント順守は、競合とどのようにクライアントからの/へのエクステントを付与し、リコールによる競合を回避するために何をするかを決定するためにサーバーを有効にする、潜在的にストレージデバイス操作の競合の制御でのpNFSサーバを配置します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a client makes a layout request that conflicts with an existing layout delegation, the request will be rejected with the error NFS4ERR_LAYOUTTRYLATER. This client is then expected to retry the request after a short interval. During this interval, the server SHOULD recall the conflicting portion of the layout delegation from the client that currently holds it. This reject-and-retry approach does not prevent client starvation when there is contention for the layout of a particular file. For this reason, a pNFS server SHOULD implement a mechanism to prevent starvation. One possibility is that the server can maintain a queue of rejected layout requests. Each new layout request can be checked to see if it conflicts with a previous rejected request, and if so, the newer request can be rejected. Once the original requesting client retries its request, its entry in the rejected request queue can be cleared, or the entry in the rejected request queue can be removed when it reaches a certain age.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、既存のレイアウトの代表団と競合するレイアウト要求を行った場合、要求はエラーNFS4ERR_LAYOUTTRYLATERで拒否されます。このクライアントは、その後、短い間隔の後、要求を再試行することが期待されます。この間、サーバーは現在、それを保持しているクライアントからレイアウトの代表団の相反する部分を思い出すべきです。特定のファイルのレイアウトのための競合がある場合に再試行拒否-と-アプローチは、クライアントの飢餓を防ぐことはできません。このため、pNFSのサーバは、飢餓を防ぐためのメカニズムを実装する必要があります。一つの可能​​性は、サーバーが拒否されたレイアウト要求のキューを維持することができるということです。それぞれの新しいレイアウトの要求は、それが以前の拒否要求と矛盾するかどうかを確認するためにチェックすることができ、そうであれば、新しい要求は拒否することができます。要求元のクライアントが要求を再試行すると、拒否されたリクエスト・キュー内のエントリをクリアすることができ、またはそれは一定の年齢に達したときに拒否された要求キュー内のエントリを除去することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4 supports mandatory locks and share reservations. These are mechanisms that clients can use to restrict the set of I/O operations that are permissible to other clients. Since all I/O operations ultimately arrive at the NFSv4 server for processing, the server is in a position to enforce these restrictions. However, with pNFS layouts, I/Os will be issued from the clients that hold the layouts directly to the storage devices that host the data. These devices have no knowledge of files, mandatory locks, or share reservations, and they are not in a position to enforce such restrictions. For this reason, the NFSv4 server MUST NOT grant layouts that conflict with mandatory locks or share reservations. Further, if a conflicting mandatory lock request or a conflicting OPEN request arrives at the server, the server MUST recall the part of the layout in conflict with the request before granting the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4のは強制ロックと共有の予約をサポートしています。これらは、クライアントが他のクライアントに許容されるI / O操作のセットを制限するために使用できるメカニズムです。すべてのI / O操作は、最終的に処理するためのNFSv4サーバに到着するので、サーバは、これらの制限を強制する位置にあります。しかし、pNFSのレイアウトと、I / Oは、直接データをホストするストレージデバイスへのレイアウトを保持し、クライアントから発行されます。これらのデバイスは、ファイル、強制ロック、または共有の予約の知識がない、と彼らは、そのような制限を実施する立場にはありません。このため、NFSv4サーバは、その強制ロックまたは共有の予約との競合のレイアウトを許可してはなりません。競合必須ロック要求や矛盾OPEN要求がサーバーに到着した場合はさらに、サーバは、要求を許可する前に、要求との競合でのレイアウトの一部をリコールしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.7. Partial-Block Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.7。パーシャルブロックのアップデート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCSI storage devices do not provide byte granularity access and can only perform read and write operations atomically on a block granularity. Writes to SCSI storage devices thus require read-modify-write cycles to write data that is smaller than the block size or that is otherwise not block aligned. Write operations from multiple clients to the same block can thus lead to data corruption even if the byte range written by the applications does not overlap. When there are multiple clients who wish to access the same block, a pNFS server MUST avoid these conflicts by implementing a concurrency control policy of single writer XOR multiple readers for a given data block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCSIストレージデバイスは、バイト粒度のアクセスを提供しないとだけブロックの粒度でアトミック読み取りおよび書き込み操作を行うことができます。 SCSIストレージデバイスに書き込み、したがってブロックサイズよりも小さいか、そうでなければ整列ブロックされていないデータを書き込むためにリード・モディファイ・ライト・サイクルを必要とします。アプリケーションによって書かれたバイト範囲が重複していない場合でも、このようにデータの破損につながることができ、同じブロックに複数のクライアントからの操作を書きます。同じブロックにアクセスすることを希望する複数のクライアントが存在する場合には、pNFSのサーバは、与えられたデータブロックのための単一のライターXOR複数のリーダーの同時実行制御ポリシーを実装することにより、これらの競合を回避しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.8. End-of-File Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.8。ファイル終了処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The end-of-file location can be changed in two ways: implicitly as the result of a WRITE or LAYOUTCOMMIT beyond the current end of file or explicitly as the result of a SETATTR request. Typically, when a file is truncated by an NFSv4 client via the SETATTR call, the server frees any disk blocks belonging to the file that are beyond the new end-of-file byte and MUST write zeros to the portion of the new end-of-file block beyond the new end-of-file byte. These actions render semantically invalid any pNFS layouts that refer to the blocks that are freed or written. Therefore, the server MUST recall from clients the portions of any pNFS layouts that refer to blocks that will be freed or written by the server before effecting the file truncation. These recalls may take time to complete; as explained in [RFC5661], if the server cannot respond to the client SETATTR request in a reasonable amount of time, it SHOULD reply to the client with the error NFS4ERR_DELAY.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンドオブファイル位置は、2つの方法で変更することができる。暗黙ファイルの現在の末尾を越えてWRITE又はLAYOUTCOMMITの結果として、または明示的SETATTR要求の結果として。ファイルはSETATTR呼び出しによってNFSv4クライアントによって切断されている場合、通常、サーバーは、新しいファイルの終端バイトを超えているファイルに属するすべてのディスクブロックを解放し、新しいエンドの部分にゼロを書き込む必要があります新しいファイルの終わりバイトを超え-fileブロック。これらのアクションは、解放されたか、書かれているブロックを参照して、意味的に無効な任意のpNFSのレイアウトをレンダリングします。そのため、サーバは、クライアントからのファイルの切り捨てを行う前に、解放されたか、サーバーによって書き込まれるブロックを参照するすべてのpNFSのレイアウトの一部をリコールしなければなりません。これらのリコールが完了するまでに時間がかかる場合があります。 [RFC5661]で説明したように、サーバーが妥当な時間内のクライアントSETATTR要求に応答できない場合、それはエラーNFS4ERR_DELAYでクライアントに返信すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Blocks in the PNFS_SCSI_INVALID_DATA state that lie beyond the new end-of-file block present a special case. The server has reserved these blocks for use by a pNFS client with a writable layout for the file, but the client has yet to commit the blocks, and they are not yet a part of the file mapping on disk. The server MAY free these blocks while processing the SETATTR request. If so, the server MUST recall any layouts from pNFS clients that refer to the blocks before processing the truncate. If the server does not free the PNFS_SCSI_INVALID_DATA blocks while processing the SETATTR request, it need not recall layouts that refer only to the PNFS_SCSI_INVALID_DATA blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいエンド・オブ・ファイルブロックを越えた位置にあるPNFS_SCSI_INVALID_DATA状態でのブロックは特殊なケースを提示します。サーバーは、ファイルの書き込み可能なレイアウトでのpNFSクライアントが使用するためにこれらのブロックを予約していますが、クライアントはブロックをコミットするためにまだ持っている、と彼らはまだ、ディスク上のファイル・マッピングの一部ではありません。 SETATTR要求を処理している間、サーバーは、これらのブロックを解放するかもしれません。その場合、サーバーは、TRUNCATEを処理する前にブロックを参照のpNFSクライアントから任意のレイアウトをリコールしなければなりません。 SETATTR要求を処理している間、サーバがPNFS_SCSI_INVALID_DATAブロックを解放していない場合、それはPNFS_SCSI_INVALID_DATAブロックのみを参照レイアウトを思い出す必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a file is extended implicitly by a WRITE or LAYOUTCOMMIT beyond the current end of file, or extended explicitly by a SETATTR request, the server need not recall any portions of any pNFS layouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ファイルは、ファイルの現在の末尾を越えてWRITEまたはLAYOUTCOMMITによって暗黙的に拡張し、またはSETATTR要求によって明示的に延長された場合、サーバーはpNFSのレイアウトの任意の部分を思い出す必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.9. Layout Hints
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.9。レイアウトのヒント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The layout hint attribute specified in [RFC5661] is not supported by the SCSI layout, and the pNFS server MUST reject setting a layout hint attribute with a loh_type value of LAYOUT4_SCSI_VOLUME during OPEN or SETATTR operations. On a file system only supporting the SCSI layout, a server MUST NOT report the layout_hint attribute in the supported_attrs attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5661]で指定されたレイアウトヒント属性はSCSIレイアウトによってサポートされていない、とのpNFSサーバは、OPENまたはSETATTR操作中LAYOUT4_SCSI_VOLUMEのloh_type値を有するレイアウトヒント属性を設定拒絶しなければなりません。唯一のSCSIのレイアウトをサポートするファイルシステムでは、サーバはsupported_attrs属性でlayout_hint属性を報告してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10. Client Fencing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10。クライアントフェンシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The pNFS SCSI protocol must handle situations in which a system failure, typically a network connectivity issue, requires the server to unilaterally revoke extents from a client after the client fails to respond to a CB_LAYOUTRECALL request. This is implemented by fencing off a non-responding client from access to the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pNFSのSCSIプロトコルは、システム障害、一般的にネットワーク接続の問題は、クライアントがCB_LAYOUTRECALL要求への応答に失敗した後、一方的にクライアントからのエクステントを取り消すために、サーバーを必要とする状況に対処しなければなりません。これは、ストレージデバイスへのアクセスから非応答クライアントをオフフェンシングによって実装されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The pNFS SCSI protocol implements fencing using persistent reservations (PRs), similar to the fencing method used by existing shared disk file systems. By placing a PR of type &#34;Exclusive Access - Registrants Only&#34; on each SCSI LU exported to pNFS clients, the MDS prevents access from any client that does not have an outstanding device ID that gives the client a reservation key to access the LU and allows the MDS to revoke access to the logical unit at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pNFSのSCSIプロトコルは、既存の共有ディスク・ファイル・システムで使用されるフェンシング方法と同様の永続的予約（PRS）を用い、フェンシングを実装します。 「排他アクセス - のみの登録者」タイプのPRを配置することにより、各SCSI LUには、pNFSのクライアントにエクスポートし、MDSは、クライアントにLUにアクセスするための予約キーを提供し、可能にする優れたデバイスIDを持っていない任意のクライアントからのアクセスを防止しますMDSは、いつでも、論理ユニットへのアクセスを取り消します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10.1. PRs -- Key Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10.1。 PR  - キー生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To allow fencing individual systems, each system MUST use a unique persistent reservation key. [SPC4] does not specify a way to generate keys. This document assigns the burden to generate unique keys to the MDS, which MUST generate a key for itself before exporting a volume and a key for each client that accesses SCSI layout volumes. Individuals keys for each volume that a client can access are permitted but not required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
個々のシステムをフェンシングできるようにするには、各システムは、独自の永続予約キーを使用しなければなりません。 [SPC4は]キーを生成する方法を指定しません。この文書では、ボリュームとSCSIレイアウトボリュームにアクセスする各クライアントの鍵をエクスポートする前に、自分自身のための鍵を生成しなければならないMDSに固有のキーを生成するための負担を割り当てます。クライアントがアクセスできる各ボリュームの個人キーが許可されますが必須ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10.2. PRs -- MDS Registration and Reservation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10.2。 PR  -  MDSの登録と予約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Before returning a PNFS_SCSI_VOLUME_BASE volume to the client, the MDS needs to prepare the volume for fencing using PRs. This is done by registering the reservation generated for the MDS with the device using the &#34;PERSISTENT RESERVE OUT&#34; command with a service action of &#34;REGISTER&#34;, followed by a &#34;PERSISTENT RESERVE OUT&#34; command with a service action of &#34;RESERVE&#34; and the &#34;TYPE&#34; field set to 8h (Exclusive Access - Registrants Only). To make sure all I_T nexuses (see Section 3.1.45 of [SAM-5]) are registered, the MDS SHOULD set the &#34;All Target Ports&#34; (ALL_TG_PT) bit when registering the key or otherwise ensure the registration is performed for each target port, and it MUST perform registration for each initiator port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントにPNFS_SCSI_VOLUME_BASEボリュームを戻す前に、MDSは、使用してのPRをフェンシング用のボリュームを準備する必要があります。これは、「RESERVE」のサービスアクションで「永続予約OUT」コマンドに続く「REGISTER」のサービスアクションで「永続予約OUT」コマンドを使用して、デバイスとMDS用に生成された予約を登録することによって行われますし、 8Hに設定し、「TYPE」フィールド（排他アクセス - のみ登録者）。必ずすべてのI_Tのnexusesが（[SAM-5]のセクション3.1.45を参照）が登録されているようにするには、MDSは、キーを登録するときに、「すべてのターゲットポート」（ALL_TG_PT）ビットを設定するか、そうでない場合は登録が各ターゲットに対して実行されていることを確認すべきですポートは、それが各イニシエータポートの登録を実行しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10.3. PRs -- Client Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10.3。 PR  - クライアント登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Before performing the first I/O to a device returned from a GETDEVICEINFO operation, the client will register the registration key returned in sbv_pr_key with the storage device by issuing a &#34;PERSISTENT RESERVE OUT&#34; command with a service action of REGISTER with the &#34;SERVICE ACTION RESERVATION KEY&#34; set to the reservation key returned in sbv_pr_key. To make sure all I_T nexuses are registered, the client SHOULD set the &#34;All Target Ports&#34; (ALL_TG_PT) bit when registering the key or otherwise ensure the registration is performed for each target port, and it MUST perform registration for each initiator port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GETDEVICEINFO操作から返されたデバイスへの最初のI / Oを実行する前に、登録キーを登録するクライアントは、「サービス・アクションでREGISTERのサービスアクションで「永続OUT RESERVE」コマンドを発行することにより、記憶装置とsbv_pr_keyで返さsbv_pr_keyで返さ予約キーに設定予約キー」。すべてのI_Tのnexusesが登録されていることを確認するには、クライアントは「すべてのターゲットポート」に設定すべきである（ALL_TG_PT）ビットキーを登録するか、そうでない場合は登録が各ターゲットポートに対して実行されていることを確認し、そしてそれは、各イニシエータポートの登録を実行しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client stops using a device earlier returned by GETDEVICEINFO, it MUST unregister the earlier registered key by issuing a &#34;PERSISTENT RESERVE OUT&#34; command with a service action of &#34;REGISTER&#34; with the &#34;RESERVATION KEY&#34; set to the earlier registered reservation key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは以前GETDEVICEINFOによって返されたデバイスの使用を停止したときに、それは以前に登録した予約キーに設定し、「予約キー」と「REGISTER」のサービスアクションで「永続予約OUT」コマンドを発行することにより、以前の登録キーの登録を解除しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10.4. PRs -- Fencing Action
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10.4。 PR  - フェンシングアクション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In case of a non-responding client, the MDS fences the client by issuing a &#34;PERSISTENT RESERVE OUT&#34; command with the service action set to &#34;PREEMPT&#34; or &#34;PREEMPT AND ABORT&#34;, the &#34;RESERVATION KEY&#34; field set to the server&#39;s reservation key, the service action &#34;RESERVATION KEY&#34; field set to the reservation key associated with the non-responding client, and the &#34;TYPE&#34; field set to 8h (Exclusive Access - Registrants Only).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非応答クライアントの場合は、MDSは、「PREEMPT」または「PREEMPTアボート」に設定されたサービスアクションを指定して、コマンドを「永続予約をOUT」を発行して、クライアントをフェンスサーバーの予約に設定し、「予約キー」フィールドキー、非応答クライアントに関連付けられた予約キーに設定されたサービスアクション「予約キー」フィールド、および8Hに設定し、「TYPE」フィールド（排他アクセスは - 登録者のみ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After the MDS preempts a client, all client I/O to the LU fails. The client SHOULD at this point return any layout that refers to the device ID that points to the LU. Note that the client can distinguish I/O errors due to fencing from other errors based on the &#34;RESERVATION CONFLICT&#34; SCSI status. Refer to [SPC4] for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MDSは、クライアントを先取りした後、LUへのすべてのクライアントI / Oは失敗します。クライアントは、この時点でLUを指すデバイスIDを意味任意のレイアウトを返すべきです。クライアントが「RESERVATION CONFLICT」SCSIステータスに基づいて、他のエラーからフェンシングのためにI / Oエラーを区別できることに注意してください。詳細については、[SPC4]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10.5. Client Recovery after a Fence Action
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.10.5。フェンスアクション後のクライアント回復
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client that detects a &#34;RESERVATION CONFLICT&#34; SCSI status (I/O error) on the storage devices MUST commit all layouts that use the storage device through the MDS, return all outstanding layouts for the device, forget the device ID, and unregister the reservation key. Future GETDEVICEINFO calls MAY refer to the storage device again, in which case the client will perform a new registration based on the key provided (via sbv_pr_key) at that time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ストレージデバイス上の「予約の競合」SCSIステータス（I / Oエラー）を検出し、クライアントは、MDSを介してストレージデバイスを使用するすべてのレイアウトをコミットするデバイスのすべての未処理のレイアウトを返し、デバイスIDを忘れて、登録を解除しなければなりません予約キー。将来GETDEVICEINFOは、クライアントがその時点で（sbv_pr_key経由で）提供されたキーに基づいて新規登録を行います。その場合には、再度、ストレージ・デバイスを参照することが呼び出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5. Crash Recovery Issues
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5。クラッシュリカバリの問題
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A critical requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts. These requirements and a full discussion of crash recovery issues are covered in Section 8.4 (&#34;Crash Recovery&#34;) of the NFSv4.1 specification [RFC5661]. This document contains additional crash recovery material specific only to the SCSI layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クラッシュリカバリの重要な要件は、他に障害が発生したときにクライアントとサーバーの両方が知っていることです。さらに、クライアントがサーバを再起動してデータの一貫性のあるビューを見ることが必要です。これらの要件とクラッシュリカバリの問題の完全な議論はNFSv4.1仕様[RFC5661]のセクション8.4（「クラッシュリカバリ」）で覆われています。この文書では、唯一のSCSIレイアウトに固有の追加クラッシュリカバリ材料が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server crashes while the client holds a writable layout, the client has written data to blocks covered by the layout, and the blocks are still in the PNFS_SCSI_INVALID_DATA state, the client has two options for recovery. If the data that has been written to these blocks is still cached by the client, the client can simply re-write the data via NFSv4 once the server has come back online. However, if the data is no longer in the client&#39;s cache, the client MUST NOT attempt to source the data from the data servers. Instead, it SHOULD attempt to commit the blocks in question to the server during the server&#39;s recovery grace period by sending a LAYOUTCOMMIT with the &#34;loca_reclaim&#34; flag set to true. This process is described in detail in Section 18.42.4 of [RFC5661].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーがクラッシュしたクライアントは、書き込み可能なレイアウトを保持している間は、クライアントはレイアウトによってカバーされたブロックにデータを書き込んだ、とブロックがPNFS_SCSI_INVALID_DATA状態で残っている場合は、クライアントは回復のための2つのオプションがあります。これらのブロックに書き込まれたデータがまだクライアントによってキャッシュされている場合、サーバーがオンラインに戻ってきた後、クライアントは単純なNFSv4経由でデータを再作成することができます。データがクライアントのキャッシュされなくなった場合は、クライアントは、データ・サーバからのデータをソースしようとしないてはなりません。代わりに、それがtrueに設定された「loca_reclaim」フラグでLAYOUTCOMMITを送信することで、サーバーの回復の猶予期間中にサーバーに問題のブロックをコミットしようとすべきです。このプロセスは、[RFC5661]のセクション18.42.4に詳細に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6. Recalling Resources: CB_RECALL_ANY
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6。想起リソース：CB_RECALL_ANY
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server MAY decide that it cannot hold all of the state for layouts without running out of resources. In such a case, it is free to recall individual layouts using CB_LAYOUTRECALL to reduce the load, or it MAY choose to request that the client return any layout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはリソースが不足することなく、レイアウトの状態のすべてを保持することはできませんことを決定することができます。このような場合には、負荷を軽減するCB_LAYOUTRECALLを使用して、個々のレイアウトをリコールして自由である、またはそれは、クライアントが任意のレイアウトを返すことを要求するために選ぶかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NFSv4.1 specification [RFC5661] defines the following types:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFSv4.1仕様[RFC5661]は、次のタイプが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
const RCA4_TYPE_MASK_BLK_LAYOUT = 4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CONST RCA4_TYPE_MASK_BLK_LAYOUT = 4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct CB_RECALL_ANY4args {
              uint32_t      craa_objects_to_keep;
              bitmap4       craa_type_mask;
       };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the server sends a CB_RECALL_ANY request to a client specifying the RCA4_TYPE_MASK_BLK_LAYOUT bit in craa_type_mask, the client SHOULD immediately respond with NFS4_OK and then asynchronously return complete file layouts until the number of files with layouts cached on the client is less than craa_object_to_keep.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバがcraa_type_maskでRCA4_TYPE_MASK_BLK_LAYOUTビットを指定してクライアントにCB_RECALL_ANY要求を送信すると、クライアントはすぐにNFS4_OKで応答して、非同期的にクライアントにキャッシュレイアウトを持つファイルの数craa_object_to_keep未満になるまで、完全なファイルのレイアウトを返すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.7. Transient and Permanent Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.7。過渡および恒久エラー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server may respond to LAYOUTGET with a variety of error statuses. These errors can convey transient conditions or more permanent conditions that are unlikely to be resolved soon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、エラー状態の様々なLAYOUTGETに応答することができます。これらのエラーは、過渡状態またはすぐに解決されそうにない、より恒久的な条件を伝えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The error NFS4ERR_RECALLCONFLICT indicates that the server has recently issued a CB_LAYOUTRECALL to the requesting client, making it necessary for the client to respond to the recall before processing the layout request. A client can wait for that recall to be received and processed, or it can retry as NFS4ERR_TRYLATER, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エラーNFS4ERR_RECALLCONFLICTは、サーバが、最近それが必要なクライアントは、レイアウトの要求を処理する前にリコールへの対応できるようにすること、要求元のクライアントにCB_LAYOUTRECALLを発行したことを示しています。そのリコールが受信して処理するため、クライアントは待つことができる、または以下に説明するように、それは、NFS4ERR_TRYLATERとして再試行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The error NFS4ERR_TRYLATER is used to indicate that the server cannot immediately grant the layout to the client. This may be due to constraints on writable sharing of blocks by multiple clients or to a conflict with a recallable lock (e.g., a delegation). In either case, a reasonable approach for the client is to wait several milliseconds and retry the request. The client SHOULD track the number of retries, and if forward progress is not made, the client SHOULD abandon the attempt to get a layout and perform READ and WRITE operations by sending them to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エラーNFS4ERR_TRYLATERは、サーバーはすぐにクライアントにレイアウトを付与することはできませんことを示すために使用されます。これは、複数のクライアントによって、またはリコールロック（例えば、委任）と競合するブロックの書き込み可能な共有上の制約のためであってもよいです。いずれの場合も、クライアントのための合理的なアプローチは、数ミリ秒待ってから、要求を再試行することです。クライアントは、再試行の回数を追跡する必要があり、前方の進歩がなされていない場合、クライアントは、レイアウトを取得し、READを実行しようとする試みを放棄し、サーバーに送信することにより、操作を記述する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The error NFS4ERR_LAYOUTUNAVAILABLE MAY be returned by the server if layouts are not supported for the requested file or its containing file system. The server MAY also return this error code if the server is in the process of migrating the file from secondary storage, there is a conflicting lock that would prevent the layout from being granted, or any other reason causes the server to be unable to supply the layout. As a result of receiving NFS4ERR_LAYOUTUNAVAILABLE, the client SHOULD abandon the attempt to get a layout and perform READ and WRITE operations by sending them to the MDS. It is expected that a client will not cache the file&#39;s layoutunavailable state forever. In particular, when the file is closed or opened by the client, issuing a new LAYOUTGET is appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レイアウトは要求されたファイルまたはそれを含むファイルシステムのためにサポートされていない場合は、エラーNFS4ERR_LAYOUTUNAVAILABLEは、サーバーによって返されることがあります。サーバは、二次記憶装置からファイルを移行するプロセスにある場合、サーバは、このエラーコードを返してもよい、そこ付与されるのレイアウトを妨げる競合ロックがある、または任意の他の理由は、サーバが提供することができないことが原因レイアウト。 NFS4ERR_LAYOUTUNAVAILABLEを受信した結果として、クライアントは、レイアウトを取得しようとする試みを放棄し、READを実行し、MDSに送信することにより、操作を記述する必要があります。クライアントが永遠にファイルのlayoutunavailable状態をキャッシュしないことが期待されます。ファイルがクライアントによって閉じたり開いたりしたとき特に、新しいLAYOUTGETを発行することは適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8. Volatile Write Caches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.8。揮発性書き込みキャッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many storage devices implement volatile write caches that require an explicit flush to persist the data from write operations to stable storage. Storage devices implementing [SBC3] should indicate a volatile write cache by setting the Write Cache Enable (WCE) bit to 1 in the Caching mode page. When a volatile write cache is used, the pNFS server MUST ensure the volatile write cache has been committed to stable storage before the LAYOUTCOMMIT operation returns by using one of the SYNCHRONIZE CACHE commands.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くのストレージデバイスは、安定したストレージへの書き込み操作からデータを永続化するために、明示的なフラッシュを必要と揮発性書き込みキャッシュを実装します。 [SBC3]を実行するストレージデバイスは書き込みキャッシュがキャッシュモードページ中1（WCE）ビットを有効に設定することにより、揮発性の書き込みキャッシュを示すべきです。揮発性の書き込みキャッシュを使用する場合は、pNFSのサーバは、揮発性の書き込みキャッシュを同期さCACHEコマンドのいずれかを使用してLAYOUTCOMMIT操作が戻る前に安定したストレージにコミットされていることを確認しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Enforcing NFSv4 Semantics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.施行NFSv4のセマンティクス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The functionality provided by SCSI persistent reservations makes it possible for the MDS to control access by individual client machines to specific LUs. Individual client machines may be allowed to or prevented from reading or writing to certain block devices. Finer-grained access control methods are not generally available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCSI永続予約により提供される機能は、それが可能MDSは、特定のLUへの個々のクライアントマシンからのアクセスを制御できるようになります。個々のクライアントマシンはに許可されるか、読んだり、特定のブロック・デバイスへの書き込みを防止することができます。きめ細かいアクセス制御方法は、一般的に利用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For this reason, certain responsibilities for enforcing NFSv4 semantics, including security and locking, are delegated to pNFS clients when SCSI layouts are being used. The metadata server&#39;s role is to only grant layouts appropriately, and the pNFS clients have to be trusted to only perform accesses allowed by the layout extents they currently hold (e.g., not access storage for files on which a layout extent is not held). In general, the server will not be able to prevent a client that holds a layout for a file from accessing parts of the physical disk not covered by the layout. Similarly, the server will not be able to prevent a client from accessing blocks covered by a layout that it has already returned. The pNFS client must respect the layout model for this mapping type to appropriately respect NFSv4 semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCSIレイアウトが使用されている場合に、このような理由から、一定の責任は、セキュリティやロックなど、NFSv4のセマンティクスを施行するため、pNFSのクライアントに委任されています。メタデータサーバーの役割が適切にのみ付与レイアウトにある、とのpNFSクライアントは、彼らが現在保有レイアウトエクステント（例えば、レイアウトエクステントが開催されていないファイルのストレージにアクセスできません）で許可された唯一の実行のアクセスに信頼される必要があります。一般的には、サーバは、レイアウトでカバーされていない物理ディスクの部分へのアクセスからファイルのレイアウトを保持しているクライアントを防ぐことはできません。同様に、サーバはすでに戻ってきたレイアウトでカバーブロックにアクセスするクライアントを防ぐことはできません。 pNFSのクライアントが適切にNFSv4のセマンティクスを尊重するために、このマッピングタイプのためのレイアウトモデルを尊重しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Furthermore, there is no way for the storage to determine the specific NFSv4 entity (principal, openowner, lockowner) on whose behalf the I/O operation is being done. This fact may limit the functionality to be supported and require the pNFS client to implement server policies other than those describable by layouts. In cases in which layouts previously granted become invalid, the server has the option of recalling them. In situations in which communication difficulties prevent this from happening, layouts may be revoked by the server. This revocation is accompanied by changes in persistent reservation that have the effect of preventing SCSI access to the LUs in question by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、I / O動作が行われて、その代わりに特定のNFSv4エンティティ（プリンシパル、openowner、lockowner）を決定するためのストレージのための方法はありません。この事実は、サポートされる機能を制限し、レイアウトによって記述可能なもの以外のサーバーポリシーを実装するためのpNFSクライアントが必要な場合があります。以前に付与されて無効になってレイアウトした例では、サーバはそれらをリコールするオプションがあります。通信の問題が起こってからこれを防止する状況では、レイアウトは、サーバによって取り消されてもよいです。この取り消しは、クライアントによって、質問内のLUへのSCSIアクセスを防止する効果を持つ永続予約の変化を伴っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Use of Open Stateids
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。オープンのstateidsの使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The effective implementation of these NFSv4 semantic constraints is complicated by the different granularities of the actors for the different types of the functionality to be enforced:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのNFSv4意味制約の効果的な実施が適用される機能の種類ごとに俳優の異なる粒度によって複雑になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o To enforce security constraints for particular principals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
oは、特定のプリンシパルのセキュリティ制約を強制します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o To enforce locking constraints for particular owners (openowners and lockowners).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oは、特定の所有者（openownersとlockowners）のための固定制約を強制します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fundamental to enforcing both of these sorts of constraints is the principle that a pNFS client must not issue a SCSI I/O operation unless it possesses both:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは両方を所有していない限り、制約のこれらの種類の両方を強化する基本的には、pNFSのクライアントは、SCSI I / O操作を発行してはならないという原則です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A valid open stateid for the file in question, performing the I/O that allows I/O of the type in question, which is associated with the openowner and principal on whose behalf the I/O is to be done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その代理としてI / Oのopenownerと元本と関連している問題のタイプのI / Oを可能にするI / Oを実行し、問題のファイルの有効なオープンのstateid、oを行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A valid layout stateid for the file in question that covers the byte range on which the I/O is to be done and that allows I/O of that type to be done.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
I / Oを行う必要があり、それはそのタイプのI / Oが行われることを可能にする上でバイト範囲をカバーして問題のファイルの有効なレイアウトのstateid O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As a result, if the equivalent of I/O with an anonymous or write-bypass stateid is to be done, it MUST NOT by done using the pNFS SCSI layout type. The client MAY attempt such I/O using READs and WRITEs that do not use pNFS and are directed to the MDS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
匿名または書き込みバイパスのstateidとのI / Oの同等を行う必要がある場合、結果として、それはでpNFSのSCSIのレイアウトタイプを使用して行われてはなりません。クライアントが使用して、このようなI / Oを試みるかもしれない読み込み、pNFSのを使用していないとMDSに向けられている書き込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When open stateids are revoked, due to lease expiration or any form of administrative revocation, the server MUST recall all layouts that allow I/O to be done on any of the files for which open revocation happens. When there is a failure to successfully return those layouts, the client MUST be fenced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オープンのstateidsは、有効期限や管理失効の任意のフォームをリースすることにより取り消された場合、サーバは、I / Oがオープン失効が発生したためファイルのいずれかで行うことを可能にするすべてのレイアウトをリコールしなければなりません。首尾よくそれらのレイアウトを返すために障害が発生した場合、クライアントはフェンスで囲まなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Enforcing Security Restrictions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。セキュリティ制限を強制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The restriction noted above provides adequate enforcement of appropriate security restriction when the principal issuing the I/O is the same as that opening the file. The server is responsible for checking that the I/O mode requested by the OPEN is allowed for the principal doing the OPEN. If the correct sort of I/O is done on behalf of the same principal, then the security restriction is thereby enforced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上述の制限は、それがファイルを開くようにI / Oを発行する主体が同一である適切なセキュリティ制限の適切な執行を提供します。サーバは、OPENから要求されたI / OモードはOPENをやっプリンシパルに対して許可されていることを確認する責任があります。 I / Oの正しいソートが同じ校長に代わって行われている場合、セキュリティ制限は、それによって強制されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If I/O is done by a principal different from the one that opened the file, the client SHOULD send the I/O to be performed by the metadata server rather than doing it directly to the storage device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
I / Oは、ファイルを開いたものから校長異なることによって行われた場合、I / Oを送るべきであるクライアントは、ストレージ・デバイスに直接それをやってするのではなく、メタデータサーバによって実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Enforcing Locking Restrictions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3。ロックの制限を強制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Mandatory enforcement of whole-file locking by means of share reservations is provided when the pNFS client obeys the requirement set forth in Section 3.1. Since performing I/O requires a valid open stateid, an I/O that violates an existing share reservation would only be possible when the server allows conflicting open stateids to exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pNFSのクライアントは、セクション3.1に記載された要件に従うとき、共有の予約による全ファイルのロックの強制執行が提供されています。 I / Oを行うことが有効なオープンなstateidを必要とするので、サーバが存在し、オープンのstateids相反する可能にする場合、既存の共有の予約を侵害I / Oにのみ可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The nature of the SCSI layout type is that such implementation/ enforcement of mandatory byte-range locks is very difficult. Given that layouts are granted to clients rather than owners, the pNFS client is in no position to successfully arbitrate among multiple lockowners on the same client. Suppose lockowner A is doing a write and, while the I/O is pending, lockowner B requests a mandatory byte-range lock for a byte range potentially overlapping the pending I/O. In such a situation, the lock request cannot be granted while the I/O is pending. In a non-pNFS environment, the server would have to wait for pending I/O before granting the mandatory byte-range lock. In the pNFS environment, the server does not issue the I/O and is thus in no position to wait for its completion. The server may recall such layouts, but in doing so, it has no way of distinguishing those being used by lockowners A and B, making it difficult to allow B to perform I/O while forbidding A from doing so. Given this fact, the MDS need to successfully recall all layouts that overlap the range being locked before returning a successful response to the LOCK request. While the lock is in effect, the server SHOULD respond to requests for layouts that overlap a currently locked area with
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCSIのレイアウトタイプの性質は必須バイト範囲ロックのような実装/執行は非常に困難であるということです。レイアウトは、クライアントではなく、所有者に付与されていることを考えると、pNFSのクライアントが正常に同じクライアント上で複数のlockowners間で仲裁がない位置にあります。仮定lockowner Aはlockowner Bが潜在的に保留中のI / Oを重ねバイト範囲の必須バイト範囲ロックを要求し、I / Oが保留されている間、書き込みを行うと、されています。このような状況では、ロック要求は、I / Oが保留されている間付与することはできません。非pNFSの環境では、サーバーは必須バイト範囲ロックを許可する前にI / Oを保留するために待たなければなりません。 pNFSの環境では、サーバは、I / Oを発行していないし、その完了を待つ必要がない位置にあるように。サーバーは、このようなレイアウトを思い出すかもしれないが、そうすることで、それは難しいそうすることから、Aを禁止しながら、Bは、I / Oを実行できるようになって、lockowners AおよびBで使用されているそれらを区別する方法がありません。この事実を考えると、MDSが正常にLOCK要求に対する正常な応答を返す前にロックされている範囲をオーバーラップするすべてのレイアウトをリコールする必要があります。ロックが有効である間、サーバーはで現在ロックされているエリアをオーバーラップレイアウトへの要求に応じる必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_LAYOUTUNAVAILABLE. To simplify the required logic, a server MAY do this for all layout requests on the file in question as long as there are any byte-range locks in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NFS4ERR_LAYOUTUNAVAILABLE。必要なロジックを簡素化するために、サーバは限り効果で任意のバイト範囲ロックがあるとして、問題のファイルのすべてのレイアウト要求のためにこれを行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given these difficulties, it may be difficult for servers supporting mandatory byte-range locks to also support SCSI layouts. Servers can support advisory byte-range locks instead. The NFSv4 protocol currently has no way of determining whether byte-range lock support on a particular file system will be mandatory or advisory, except by trying operation, which would conflict if mandatory locking is in effect. Therefore, to avoid confusion, servers SHOULD NOT switch between mandatory and advisory byte-range locking based on whether any SCSI layouts have been obtained or whether a client that has obtained a SCSI layout has requested a byte-range lock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの問題を考えると、それはまた、SCSIのレイアウトをサポートするために必須のバイト範囲ロックをサポートするサーバのための難しいかもしれません。サーバーは代わりに助言バイト範囲ロックをサポートすることができます。 NFSv4プロトコルは、現在、特定のファイルシステム上のバイト範囲ロックサポートが強制ロックが有効である場合に競合する試み操作により除き、必須または諮問であろうかどうかを決定する方法がありません。そのため、混乱を避けるために、サーバは、任意のSCSIのレイアウトが得られているか、SCSIのレイアウトを取得したクライアントは、バイト範囲ロックを要求したかどうかかどうかに基づいて、必須と助言バイト範囲ロックを切り替えるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.セキュリティについての考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Access to SCSI storage devices is logically at a lower layer of the I/O stack than NFSv4; hence, NFSv4 security is not directly applicable to protocols that access such storage directly. Depending on the protocol, some of the security mechanisms provided by NFSv4 (e.g., encryption and cryptographic integrity) may not be available or may be provided via different means. At one extreme, pNFS with SCSI layouts can be used with storage access protocols (e.g., Serial Attached SCSI [SAS3]) that provide essentially no security functionality. At the other extreme, pNFS may be used with storage protocols such as iSCSI [RFC7143] that can provide significant security functionality. It is the responsibility of those administering and deploying pNFS with a SCSI storage access protocol to ensure that appropriate protection is provided to that protocol (physical security is a common means for protocols not based on IP). In environments where the security requirements for the storage protocol cannot be met, pNFS SCSI layouts SHOULD NOT be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCSIストレージデバイスへのアクセスが可能なNFSv4よりI / Oスタックの下層に論理的です。したがって、NFSv4のセキュリティは、直接、このようなストレージへのアクセスプロトコルに直接適用することはできません。プロトコルに応じて、NFSv4の（例えば、暗号化および暗号完全性）によって提供されるセキュリティメカニズムの一部が利用できない場合があり、または異なる手段を介して提供されてもよいです。一方の極端で、SCSIレイアウトとpNFSのは本質的にセキュリティ機能を提供しないストレージ・アクセス・プロトコル（例えば、シリアル接続SCSI [SAS3]）と共に使用することができます。他の極端で、pNFSのは、重要なセキュリティ機能を提供することができるようなiSCSIなどのストレージプロトコル[RFC7143]と共に使用することができます。適切な保護が（物理的なセキュリティがIPに基づいていないプロトコルのための一般的な手段である）、そのプロトコルに提供されることを保証するために、SCSIストレージ・アクセス・プロトコルとのそれらの投与および展開のpNFSの責任です。ストレージプロトコルのためのセキュリティ要件を満たすことができない環境では、pNFSのSCSIレイアウトを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When using IP-based storage protocols such as iSCSI, IPsec should be used as outlined in [RFC3723] and updated in [RFC7146].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えばiSCSIのようなIPベースのストレージプロトコルを使用する場合は、[RFC3723]に概説されて、[RFC7146]に更新されるように、IPsecが使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When security is available for a storage protocol, it is generally at a different granularity and with a different notion of identity than NFSv4 (e.g., NFSv4 controls user access to files, and iSCSI controls initiator access to volumes). The responsibility for enforcing appropriate correspondences between these security layers is placed upon the pNFS client. As with the issues in the first paragraph of this section, in environments where the security requirements are such that client-side protection from access to storage outside of the layout is not sufficient, pNFS SCSI layouts SHOULD NOT be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュリティは、ストレージプロトコルのために利用可能である場合、それは異なる粒度でとのNFSv4よりアイデンティティの異なる概念で一般的である（例えば、NFSv4のファイルへのユーザアクセスを制御し、およびiSCSIボリュームへのイニシエータのアクセスを制御します）。これらのセキュリティ層の間の適切な対応を実施するための責任はpNFSのクライアント上に配置されます。このセクションの最初の段落の問題と同様に、セキュリティ要件は、レイアウトの外側のストレージへのアクセスから、クライアント側の保護が十分でないようなものである環境では、pNFSのSCSIレイアウトを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA has assigned a new pNFS layout type in the &#34;pNFS Layout Types Registry&#34; as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにIANAは「pNFSのレイアウトタイプレジストリ」に新pNFSのレイアウトタイプを割り当てています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Layout Type Name: LAYOUT4_SCSI Value: 0x00000005 RFC: RFC 8154 How: L Minor Versions: 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レイアウトタイプ名：LAYOUT4_SCSI値：0x00000005のRFC：RFC 8154方法：Lマイナーバージョン：1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[LEGAL] IETF Trust, &#34;Legal Provisions Relating to IETF Documents&#34;, March 2015, &lt;http://trustee.ietf.org/docs/ IETF-Trust-License-Policy.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[LEGAL] IETFトラスト、 &#34;IETFドキュメントに関連法規定&#34;、2015年3月、&lt;http://trustee.ietf.org/docs/ IETF-トラスト・ライセンス・Policy.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;http://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3723] Aboba, B., Tseng, J., Walker, J., Rangan, V., and F. Travostino, &#34;Securing Block Storage Protocols over IP&#34;, RFC 3723, DOI 10.17487/RFC3723, April 2004, &lt;http://www.rfc-editor.org/info/rfc3723&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3723] Aboba、B.、ツェン、J.、ウォーカー、J.、Rangan、V.、およびF. Travostino、 &#34;IP経由のセキュリティ保護ブロック・ストレージプロトコル&#34;、RFC 3723、DOI 10.17487 / RFC3723、2004年4月、&lt;HTTP ：//www.rfc-editor.org/info/rfc3723&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4506] Eisler, M., Ed., &#34;XDR: External Data Representation Standard&#34;, STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, &lt;http://www.rfc-editor.org/info/rfc4506&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4506]アイスラー、M.、エド、 &#34;XDR：外部データ表現標準&#34;。、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、&lt;http://www.rfc-editor.org/info/rfc4506 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 Protocol&#34;, RFC 5661, DOI 10.17487/RFC5661, January 2010, &lt;http://www.rfc-editor.org/info/rfc5661&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5661] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 &#34;ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1つのプロトコル&#34;、RFC 5661、DOI 10.17487 / RFC5661、 2010年1月、&lt;http://www.rfc-editor.org/info/rfc5661&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5662] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., &#34;Network File System (NFS) Version 4 Minor Version 1 External Data Representation Standard (XDR) Description&#34;, RFC 5662, DOI 10.17487/RFC5662, January 2010, &lt;http://www.rfc-editor.org/info/rfc5662&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5662] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 &#34;ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1外部データ表現標準（XDR）の説明&#34;、RFC 5662、DOI 10.17487 / RFC5662、2010年1月、&lt;http://www.rfc-editor.org/info/rfc5662&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5663] Black, D., Fridella, S., and J. Glasgow, &#34;Parallel NFS (pNFS) Block/Volume Layout&#34;, RFC 5663, DOI 10.17487/RFC5663, January 2010, &lt;http://www.rfc-editor.org/info/rfc5663&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5663]黒、D.、Fridella、S.、およびJ.グラスゴー、 &#34;パラレルNFS（pNFSの）ブロック/ボリュームレイアウト&#34;、RFC 5663、DOI 10.17487 / RFC5663、2010年1月、&lt;HTTP：//www.rfc- editor.org/info/rfc5663&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6688] Black, D., Ed., Glasgow, J., and S. Faibish, &#34;Parallel NFS (pNFS) Block Disk Protection&#34;, RFC 6688, DOI 10.17487/RFC6688, July 2012, &lt;http://www.rfc-editor.org/info/rfc6688&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6688]ブラック、D.、エド、グラスゴー、J.、およびS. Faibish、 &#34;パラレルNFS（pNFSの）ブロックディスク保護&#34;、RFC 6688、DOI 10.17487 / RFC6688、2012年7月、&lt;HTTP：// WWW。 rfc-editor.org/info/rfc6688&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7143] Chadalapaka, M., Satran, J., Meth, K., and D. Black, &#34;Internet Small Computer System Interface (iSCSI) Protocol (Consolidated)&#34;, RFC 7143, DOI 10.17487/RFC7143, April 2014, &lt;http://www.rfc-editor.org/info/rfc7143&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7143] Chadalapaka、M.、Satran、J.、メタ、K.、およびD.ブラック、 &#34;インターネット小型コンピュータシステムインタフェース（iSCSIの）プロトコル（連結）&#34;、RFC 7143、DOI 10.17487 / RFC7143、2014年4月、&lt; http://www.rfc-editor.org/info/rfc7143&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7146] Black, D. and P. Koning, &#34;Securing Block Storage Protocols over IP: RFC 3723 Requirements Update for IPsec v3&#34;, RFC 7146, DOI 10.17487/RFC7146, April 2014, &lt;http://www.rfc-editor.org/info/rfc7146&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;IP上のブロック・ストレージプロトコルの保護：のIPsec v3のRFC 3723要件の更新&#34; [RFC7146]ブラック、D.とP. KONING、RFC 7146、DOI 10.17487 / RFC7146、2014年4月、&lt;のhttp：//www.rfc-editor .ORG /情報/ rfc7146&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SAM-5] INCITS Technical Committee T10, &#34;Information Technology - SCSI Architecture Model - 5 (SAM-5)&#34;, ANSI INCITS 515-2016, 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SAM-5] INCITS T10技術委員会、 &#34;情報技術 -  SCSIアーキテクチャモデル -  5（SAM-5）&#34;、ANSI INCITS 515から2016、2016。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SAS3] INCITS Technical Committee T10, &#34;Information technology - Serial Attached SCSI-3 (SAS-3)&#34;, ANSI INCITS 519-2014, ISO/IEC 14776-154, 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SAS3] INCITS T10技術委員会、 &#34;情報技術 - シリアル接続SCSI-3（SAS3）&#34;、ANSI INCITS 519から2014、ISO / IEC 14776から154、2014。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SBC3] INCITS Technical Committee T10, &#34;Information Technology - SCSI Block Commands - 3 (SBC-3)&#34;, ANSI INCITS 514-2014, ISO/IEC 14776-323, 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SBC3] INCITS T10技術委員会、 &#34;情報技術 -  SCSIブロックコマンド -  3（SBC3）&#34;、ANSI INCITS 514から2014、ISO / IEC 14776から323、2014。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SPC4] INCITS Technical Committee T10, &#34;Information Technology - SCSI Primary Commands - 4 (SPC-4)&#34;, ANSI INCITS 513-2015, 2015.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SPC4] INCITS T10技術委員会、 &#34;情報技術 -  SCSIプライマリコマンド -  4（SPC4）&#34;、ANSI INCITS 513から2015、2015。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Large parts of this document were copied verbatim from [RFC5663], and some parts were inspired by it. Thank to David Black, Stephen Fridella, and Jason Glasgow for their work on the pNFS block/volume layout protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書の大部分は、[RFC5663]からそのままコピーし、そしていくつかの部分は、それに触発されました。 pNFSのブロック/ボリュームレイアウトのプロトコル上の自分の仕事のためにデビッド・ブラック、スティーブンFridella、そしてジェイソン・グラスゴーに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
David Black, Robert Elliott, and Tom Haynes provided a thorough review of drafts of this document, and their input led to the current form of the document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デビッド・ブラック、ロバート・エリオット、そしてトム・ヘインズは、この文書の草稿の徹底的な見直しを提供し、その入力は、ドキュメントの現在のフォームにつながりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
David Noveck provided ample feedback to various drafts of this document, wrote the section on enforcing NFSv4 semantics, and rewrote various sections to better catch the intent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デビッドNoveckは、このドキュメントの様々なドラフトに十分なフィードバックを提供しNFSv4のセマンティクスを施行する上でセクションを書いた、より良い意図をキャッチするためにさまざまなセクションを書き直しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Christoph Hellwig
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クリストフHellwigさん
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Email: hch@lst.de
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メール：hch@lst.de
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
