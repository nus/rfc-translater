<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 8446 - The Transport Layer Security (TLS) Protocol Version 1.3 日本語訳</title>

  
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
    <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 8446 - The Transport Layer Security (TLS) Protocol Version 1.3 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc8446">
              https://tools.ietf.org/html/rfc8446
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 8446 - Transport Layer Security（TLS）プロトコルバージョン1.3</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 8446                                       Mozilla
Obsoletes: 5077, 5246, 6961                                  August 2018
Updates: 5705, 6066
Category: Standards Track
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        The Transport Layer Security (TLS) Protocol Version 1.3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies version 1.3 of the Transport Layer Security (TLS) protocol. TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントでは、Transport Layer Security（TLS）プロトコルのバージョン1.3を指定しています。 TLSを使用すると、クライアント/サーバーアプリケーションは、盗聴、改ざん、メッセージの偽造を防ぐように設計された方法で、インターネット経由で通信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077, 5246, and 6961. This document also specifies new requirements for TLS 1.2 implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは、RFC 5705および6066を更新し、RFC 5077、5246、および6961を廃止します。このドキュメントは、TLS 1.2実装の新しい要件も指定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これはインターネット標準化過程の文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8446.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在のステータス、エラッタ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8446で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright（c）2018 IETF Trustおよび文書作成者として特定された人物。 全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、この文書の発行日に有効なBCP 78およびIETF文書に関するIETFトラストの法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの資料が含まれている場合があります。この資料の一部の著作権を管理している人は、IETFトラストに、IETF標準プロセス外でそのような資料の変更を許可する権利を付与していない可能性があります。そのような資料の著作権を管理している人物から適切なライセンスを取得しないと、このドキュメントはIETF標準プロセス外で変更されず、その派生物はIETF標準プロセス外で作成されません。RFCとしての公開用にフォーマットするか、英語以外の言語に翻訳する場合を除きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................6
      1.1. Conventions and Terminology ................................7
      1.2. Major Differences from TLS 1.2 .............................8
      1.3. Updates Affecting TLS 1.2 ..................................9
   2. Protocol Overview ..............................................10
      2.1. Incorrect DHE Share .......................................14
      2.2. Resumption and Pre-Shared Key (PSK) .......................15
      2.3. 0-RTT Data ................................................17
   3. Presentation Language ..........................................19
      3.1. Basic Block Size ..........................................19
      3.2. Miscellaneous .............................................20
      3.3. Numbers ...................................................20
      3.4. Vectors ...................................................20
      3.5. Enumerateds ...............................................21
      3.6. Constructed Types .........................................22
      3.7. Constants .................................................23
      3.8. Variants ..................................................23
   4. Handshake Protocol .............................................24
      4.1. Key Exchange Messages .....................................25
           4.1.1. Cryptographic Negotiation ..........................26
           4.1.2. Client Hello .......................................27
           4.1.3. Server Hello .......................................31
           4.1.4. Hello Retry Request ................................33
      4.2. Extensions ................................................35
           4.2.1. Supported Versions .................................39
           4.2.2. Cookie .............................................40
           4.2.3. Signature Algorithms ...............................41
           4.2.4. Certificate Authorities ............................45
           4.2.5. OID Filters ........................................45
           4.2.6. Post-Handshake Client Authentication ...............47
           4.2.7. Supported Groups ...................................47
           4.2.8. Key Share ..........................................48
           4.2.9. Pre-Shared Key Exchange Modes ......................51
           4.2.10. Early Data Indication .............................52
           4.2.11. Pre-Shared Key Extension ..........................55
      4.3. Server Parameters .........................................59
           4.3.1. Encrypted Extensions ...............................60
           4.3.2. Certificate Request ................................60
      4.4. Authentication Messages ...................................61
           4.4.1. The Transcript Hash ................................63
           4.4.2. Certificate ........................................64
           4.4.3. Certificate Verify .................................69
           4.4.4. Finished ...........................................71
      4.5. End of Early Data .........................................72
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      4.6. Post-Handshake Messages ...................................73
           4.6.1. New Session Ticket Message .........................73
           4.6.2. Post-Handshake Authentication ......................75
           4.6.3. Key and Initialization Vector Update ...............76
   5. Record Protocol ................................................77
      5.1. Record Layer ..............................................78
      5.2. Record Payload Protection .................................80
      5.3. Per-Record Nonce ..........................................82
      5.4. Record Padding ............................................83
      5.5. Limits on Key Usage .......................................84
   6. Alert Protocol .................................................85
      6.1. Closure Alerts ............................................87
      6.2. Error Alerts ..............................................88
   7. Cryptographic Computations .....................................90
      7.1. Key Schedule ..............................................91
      7.2. Updating Traffic Secrets ..................................94
      7.3. Traffic Key Calculation ...................................95
      7.4. (EC)DHE Shared Secret Calculation .........................95
           7.4.1. Finite Field Diffie-Hellman ........................95
           7.4.2. Elliptic Curve Diffie-Hellman ......................96
      7.5. Exporters .................................................97
   8. 0-RTT and Anti-Replay ..........................................98
      8.1. Single-Use Tickets ........................................99
      8.2. Client Hello Recording ....................................99
      8.3. Freshness Checks .........................................101
   9. Compliance Requirements .......................................102
      9.1. Mandatory-to-Implement Cipher Suites .....................102
      9.2. Mandatory-to-Implement Extensions ........................103
      9.3. Protocol Invariants ......................................104
   10. Security Considerations ......................................106
   11. IANA Considerations ..........................................106
   12. References ...................................................109
      12.1. Normative References ....................................109
      12.2. Informative References ..................................112
   Appendix A. State Machine ........................................120
     A.1. Client ....................................................120
     A.2. Server ....................................................121
   Appendix B. Protocol Data Structures and Constant Values .........122
     B.1. Record Layer ..............................................122
     B.2. Alert Messages ............................................123
     B.3. Handshake Protocol ........................................124
       B.3.1. Key Exchange Messages .................................125
       B.3.2. Server Parameters Messages ............................131
       B.3.3. Authentication Messages ...............................132
       B.3.4. Ticket Establishment ..................................132
       B.3.5. Updating Keys .........................................133
     B.4. Cipher Suites .............................................133
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Appendix C. Implementation Notes .................................134
     C.1. Random Number Generation and Seeding ......................134
     C.2. Certificates and Authentication ...........................135
     C.3. Implementation Pitfalls ...................................135
     C.4. Client Tracking Prevention ................................137
     C.5. Unauthenticated Operation .................................137
   Appendix D. Backward Compatibility ...............................138
     D.1. Negotiating with an Older Server ..........................139
     D.2. Negotiating with an Older Client ..........................139
     D.3. 0-RTT Backward Compatibility ..............................140
     D.4. Middlebox Compatibility Mode ..............................140
     D.5. Security Restrictions Related to Backward Compatibility ...141
   Appendix E. Overview of Security Properties ......................142
     E.1. Handshake .................................................142
       E.1.1. Key Derivation and HKDF ...............................145
       E.1.2. Client Authentication .................................146
       E.1.3. 0-RTT .................................................146
       E.1.4. Exporter Independence .................................146
       E.1.5. Post-Compromise Security ..............................146
       E.1.6. External References ...................................147
     E.2. Record Layer ..............................................147
       E.2.1. External References ...................................148
     E.3. Traffic Analysis ..........................................148
     E.4. Side-Channel Attacks ......................................149
     E.5. Replay Attacks on 0-RTT ...................................150
       E.5.1. Replay and Exporters ..................................151
     E.6. PSK Identity Exposure .....................................152
     E.7. Sharing PSKs ..............................................152
     E.8. Attacks on Static RSA .....................................152
   Contributors .....................................................153
   Author&#39;s Address .................................................160
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The primary goal of TLS is to provide a secure channel between two communicating peers; the only requirement from the underlying transport is a reliable, in-order data stream. Specifically, the secure channel should provide the following properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの主な目標は、通信する2つのピア間に安全なチャネルを提供することです。 基礎となるトランスポートからの唯一の要件は、信頼性のある順序どおりのデータストリームです。 具体的には、セキュアチャネルは次のプロパティを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Authentication: The server side of the channel is always authenticated; the client side is optionally authenticated. Authentication can happen via asymmetric cryptography (e.g., RSA [RSA], the Elliptic Curve Digital Signature Algorithm (ECDSA) [ECDSA], or the Edwards-Curve Digital Signature Algorithm (EdDSA) [RFC8032]) or a symmetric pre-shared key (PSK).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-認証：チャネルのサーバー側は常に認証されます。 クライアント側はオプションで認証されます。 認証は、非対称暗号化（RSA [RSA]、楕円曲線デジタル署名アルゴリズム（ECDSA）[ECDSA]、またはEdwards-Curveデジタル署名アルゴリズム（EdDSA）[RFC8032]）または対称事前共有キー（たとえば、 PSK）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Confidentiality: Data sent over the channel after establishment is only visible to the endpoints. TLS does not hide the length of the data it transmits, though endpoints are able to pad TLS records in order to obscure lengths and improve protection against traffic analysis techniques.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-機密性：確立後にチャネルを介して送信されるデータは、エンドポイントにのみ表示されます。 TLSは、送信するデータの長さを隠しませんが、エンドポイントは長さを隠してトラフィック分析技術に対する保護を改善するためにTLSレコードを埋め込むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Integrity: Data sent over the channel after establishment cannot be modified by attackers without detection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-整合性：確立後にチャネルを介して送信されたデータは、検出されない限り攻撃者によって変更できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These properties should be true even in the face of an attacker who has complete control of the network, as described in [RFC3552]. See Appendix E for a more complete statement of the relevant security properties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3552]で説明されているように、これらのプロパティは、ネットワークを完全に制御している攻撃者に直面した場合でも正しいはずです。 関連するセキュリティプロパティのより完全な記述については、付録Eを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS consists of two primary components:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、2つの主要なコンポーネントで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A handshake protocol (Section 4) that authenticates the communicating parties, negotiates cryptographic modes and parameters, and establishes shared keying material. The handshake protocol is designed to resist tampering; an active attacker should not be able to force the peers to negotiate different parameters than they would if the connection were not under attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-通信相手を認証し、暗号化モードとパラメーターをネゴシエートし、共有キー情報を確立するハンドシェイクプロトコル（セクション4）。 ハンドシェイクプロトコルは、改ざんに耐えるように設計されています。 アクティブな攻撃者は、接続が攻撃を受けていない場合にピアとは異なるパラメータをネゴシエートさせることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A record protocol (Section 5) that uses the parameters established by the handshake protocol to protect traffic between the communicating peers. The record protocol divides traffic up into a series of records, each of which is independently protected using the traffic keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-ハンドシェイクプロトコルによって確立されたパラメータを使用して、通信するピア間のトラフィックを保護するレコードプロトコル（セクション5）。 レコードプロトコルは、トラフィックを一連のレコードに分割します。各レコードは、トラフィックキーを使用して個別に保護されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS is application protocol independent; higher-level protocols can layer on top of TLS transparently. The TLS standard, however, does not specify how protocols add security with TLS; how to initiate TLS handshaking and how to interpret the authentication certificates exchanged are left to the judgment of the designers and implementors of protocols that run on top of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSはアプリケーションプロトコルに依存しません。 高レベルのプロトコルは、TLSの上に透過的にレイヤリングできます。 ただし、TLS標準は、プロトコルがTLSでセキュリティを追加する方法を指定していません。 TLSハンドシェイクの開始方法と、交換された認証証明書の解釈方法は、TLSの上で実行されるプロトコルの設計者と実装者の判断に委ねられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines TLS version 1.3. While TLS 1.3 is not directly compatible with previous versions, all versions of TLS incorporate a versioning mechanism which allows clients and servers to interoperably negotiate a common version if one is supported by both peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントでは、TLSバージョン1.3を定義しています。 TLS 1.3は以前のバージョンと直接の互換性はありませんが、TLSのすべてのバージョンには、クライアントとサーバーが両方のピアでサポートされている場合に共通バージョンを相互運用可能にネゴシエートできるバージョン管理メカニズムが組み込まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document supersedes and obsoletes previous versions of TLS, including version 1.2 [RFC5246]. It also obsoletes the TLS ticket mechanism defined in [RFC5077] and replaces it with the mechanism defined in Section 2.2. Because TLS 1.3 changes the way keys are derived, it updates [RFC5705] as described in Section 7.5. It also changes how Online Certificate Status Protocol (OCSP) messages are carried and therefore updates [RFC6066] and obsoletes [RFC6961] as described in Section 4.4.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは、バージョン1.2 [RFC5246]を含む、TLSの以前のバージョンに取って代わります。 また、[RFC5077]で定義されたTLSチケットメカニズムを廃止し、セクション2.2で定義されたメカニズムに置き換えます。 TLS 1.3はキーの導出方法を変更するため、セクション7.5で説明されているように[RFC5705]を更新します。 また、オンライン証明書ステータスプロトコル（OCSP）メッセージの搬送方法も変更するため、セクション4.4.2.1で説明されているように[RFC6066]を更新し、[RFC6961]を廃止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Conventions and Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。 規約と用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」 この文書の「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように、ここに示すようにすべての大文字で表示される場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following terms are used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の用語が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
client: The endpoint initiating the TLS connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント：TLS接続を開始するエンドポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
connection: A transport-layer connection between two endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続：2つのエンドポイント間のトランスポート層接続。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
endpoint: Either the client or server of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンドポイント：接続のクライアントまたはサーバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
handshake: An initial negotiation between client and server that establishes the parameters of their subsequent interactions within TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェイク：TLS内の後続の相互作用のパラメーターを確立するクライアントとサーバー間の最初のネゴシエーション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
peer: An endpoint. When discussing a particular endpoint, &#34;peer&#34; refers to the endpoint that is not the primary subject of discussion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピア：エンドポイント。 特定のエンドポイントについて議論するとき、「ピア」とは、議論の主要な主題ではないエンドポイントを指します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
receiver: An endpoint that is receiving records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信者：レコードを受信しているエンドポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
sender: An endpoint that is transmitting records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者：レコードを送信しているエンドポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
server: The endpoint that did not initiate the TLS connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー：TLS接続を開始しなかったエンドポイント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Major Differences from TLS 1.2
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。 TLS 1.2との主な違い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following is a list of the major functional differences between TLS 1.2 and TLS 1.3. It is not intended to be exhaustive, and there are many minor differences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下は、TLS 1.2とTLS 1.3の主な機能の違いのリストです。 網羅的であることは意図されておらず、多くの小さな違いがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The list of supported symmetric encryption algorithms has been pruned of all algorithms that are considered legacy. Those that remain are all Authenticated Encryption with Associated Data (AEAD) algorithms. The cipher suite concept has been changed to separate the authentication and key exchange mechanisms from the record protection algorithm (including secret key length) and a hash to be used with both the key derivation function and handshake message authentication code (MAC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サポートされている対称暗号化アルゴリズムのリストは、レガシーと見なされるすべてのアルゴリズムから削除されました。 残っているのは、すべて関連データを使用した認証暗号化（AEAD）アルゴリズムです。 暗号スイートの概念が変更され、認証とキー交換メカニズムをレコード保護アルゴリズム（秘密キーの長さを含む）およびキー派生機能とハンドシェイクメッセージ認証コード（MAC）の両方で使用されるハッシュから分離しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A zero round-trip time (0-RTT) mode was added, saving a round trip at connection setup for some application data, at the cost of certain security properties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-ゼロラウンドトリップタイム（0-RTT）モードが追加され、特定のセキュリティプロパティを犠牲にして、一部のアプリケーションデータの接続セットアップ時のラウンドトリップが節約されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Static RSA and Diffie-Hellman cipher suites have been removed; all public-key based key exchange mechanisms now provide forward secrecy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-静的RSAおよびDiffie-Hellman暗号スイートが削除されました。 すべての公開鍵ベースの鍵交換メカニズムは、前方秘密を提供するようになりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- All handshake messages after the ServerHello are now encrypted. The newly introduced EncryptedExtensions message allows various extensions previously sent in the clear in the ServerHello to also enjoy confidentiality protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-ServerHello後のすべてのハンドシェイクメッセージが暗号化されます。 新しく導入されたEncryptedExtensionsメッセージにより、ServerHelloで以前に平文で送信されたさまざまな拡張機能も機密保護を享受できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The key derivation functions have been redesigned. The new design allows easier analysis by cryptographers due to their improved key separation properties. The HMAC-based Extract-and-Expand Key Derivation Function (HKDF) is used as an underlying primitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-主要な派生関数が再設計されました。 新しい設計により、鍵分離特性が改善されているため、暗号作成者による分析が容易になります。 HMACベースの抽出および拡張キー派生関数（HKDF）は、基になるプリミティブとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The handshake state machine has been significantly restructured to be more consistent and to remove superfluous messages such as ChangeCipherSpec (except when needed for middlebox compatibility).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-ハンドシェイクステートマシンが大幅に再構築されて、一貫性が向上し、ChangeCipherSpecなどの不要なメッセージが削除されました（ミドルボックスの互換性に必要な場合を除く）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Elliptic curve algorithms are now in the base spec, and new signature algorithms, such as EdDSA, are included. TLS 1.3 removed point format negotiation in favor of a single point format for each curve.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-現在、楕円曲線アルゴリズムは基本仕様に含まれており、EdDSAなどの新しい署名アルゴリズムが含まれています。 TLS 1.3は、各曲線の単一のポイント形式を支持して、ポイント形式のネゴシエーションを削除しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Other cryptographic improvements were made, including changing the RSA padding to use the RSA Probabilistic Signature Scheme (RSASSA-PSS), and the removal of compression, the Digital Signature Algorithm (DSA), and custom Ephemeral Diffie-Hellman (DHE) groups.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-RSA確率的署名スキーム（RSASSA-PSS）を使用するためのRSAパディングの変更、圧縮の削除、デジタル署名アルゴリズム（DSA）、およびカスタムEphemeral Diffie-Hellman（DHE）グループを含む、その他の暗号化の改善が行われました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The TLS 1.2 version negotiation mechanism has been deprecated in favor of a version list in an extension. This increases compatibility with existing servers that incorrectly implemented version negotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLS 1.2バージョンネゴシエーションメカニズムは、拡張機能のバージョンリストを優先して廃止されました。 これにより、バージョンネゴシエーションを誤って実装した既存のサーバーとの互換性が向上します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Session resumption with and without server-side state as well as the PSK-based cipher suites of earlier TLS versions have been replaced by a single new PSK exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サーバー側の状態がある場合とない場合のセッション再開、および以前のTLSバージョンのPSKベースの暗号スイートは、単一の新しいPSK交換に置き換えられました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- References have been updated to point to the updated versions of RFCs, as appropriate (e.g., RFC 5280 rather than RFC 3280).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-必要に応じて、RFCの更新されたバージョンを指すように参照が更新されました（RFC 3280ではなくRFC 5280など）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Updates Affecting TLS 1.2
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3。 TLS 1.2に影響する更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines several changes that optionally affect implementations of TLS 1.2, including those which do not also support TLS 1.3:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントでは、TLS 1.3をサポートしないものも含め、TLS 1.2の実装にオプションで影響するいくつかの変更を定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A version downgrade protection mechanism is described in Section 4.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-バージョンダウングレード保護メカニズムについては、セクション4.1.3で説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- RSASSA-PSS signature schemes are defined in Section 4.2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-RSASSA-PSS署名スキームは、セクション4.2.3で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The &#34;supported_versions&#34; ClientHello extension can be used to negotiate the version of TLS to use, in preference to the legacy_version field of the ClientHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「supported_versions」ClientHello拡張機能を使用して、ClientHelloのlegacy_versionフィールドに優先して、使用するTLSのバージョンをネゴシエートできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The &#34;signature_algorithms_cert&#34; extension allows a client to indicate which signature algorithms it can validate in X.509 certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-&#34;signature_algorithms_cert&#34;拡張により、クライアントはX.509証明書で検証できる署名アルゴリズムを示すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Additionally, this document clarifies some compliance requirements for earlier versions of TLS; see Section 9.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、このドキュメントでは、TLSの以前のバージョンのいくつかのコンプライアンス要件を明確にしています。 セクション9.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.プロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cryptographic parameters used by the secure channel are produced by the TLS handshake protocol. This sub-protocol of TLS is used by the client and server when first communicating with each other. The handshake protocol allows peers to negotiate a protocol version, select cryptographic algorithms, optionally authenticate each other, and establish shared secret keying material. Once the handshake is complete, the peers use the established keys to protect the application-layer traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セキュアチャネルで使用される暗号化パラメーターは、TLSハンドシェイクプロトコルによって生成されます。 TLSのこのサブプロトコルは、クライアントとサーバーが最初に相互に通信するときに使用されます。 ハンドシェイクプロトコルにより、ピアはプロトコルバージョンをネゴシエートし、暗号化アルゴリズムを選択し、必要に応じて互いを認証し、共有秘密鍵素材を確立できます。 ハンドシェイクが完了すると、ピアは確立されたキーを使用して、アプリケーション層のトラフィックを保護します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A failure of the handshake or other protocol error triggers the termination of the connection, optionally preceded by an alert message (Section 6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェイクの失敗またはその他のプロトコルエラーは、接続の終了をトリガーし、オプションでアラートメッセージが続きます（セクション6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS supports three basic key exchange modes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、3つの基本的なキー交換モードをサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- (EC)DHE (Diffie-Hellman over either finite fields or elliptic curves)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-（EC）DHE（有限体または楕円曲線上のディフィー・ヘルマン）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- PSK-only
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-PSKのみ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- PSK with (EC)DHE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-（EC）DHEを使用したPSK
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1 below shows the basic full TLS handshake:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の図1は、基本的な完全なTLSハンドシェイクを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*       --------&gt;
                                                  ServerHello  ^ Key
                                                 + key_share*  | Exch
                                            + pre_shared_key*  v
                                        {EncryptedExtensions}  ^  Server
                                        {CertificateRequest*}  v  Params
                                               {Certificate*}  ^
                                         {CertificateVerify*}  | Auth
                                                   {Finished}  v
                               &lt;--------  [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}              --------&gt;
       [Application Data]      &lt;-------&gt;  [Application Data]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +  Indicates noteworthy extensions sent in the
                 previously noted message.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Indicates optional or situation-dependent messages/extensions that are not always sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*常に送信されるとは限らない、オプションまたは状況依存のメッセージ/拡張子を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
{} Indicates messages protected using keys derived from a [sender]_handshake_traffic_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
{} [sender] _handshake_traffic_secretから派生したキーを使用して保護されたメッセージを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[] Indicates messages protected using keys derived from [sender]_application_traffic_secret_N.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[] [sender] _application_traffic_secret_Nから派生したキーを使用して保護されたメッセージを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1: Message Flow for Full TLS Handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1：完全なTLSハンドシェイクのメッセージフロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The handshake can be thought of as having three phases (indicated in the diagram above):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェイクは、3つのフェーズ（上記の図に示されている）を持っていると考えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Key Exchange: Establish shared keying material and select the cryptographic parameters. Everything after this phase is encrypted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-鍵交換：共有鍵素材を確立し、暗号化パラメーターを選択します。 このフェーズ以降はすべて暗号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Server Parameters: Establish other handshake parameters (whether the client is authenticated, application-layer protocol support, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サーバーパラメータ：他のハンドシェイクパラメータを確立します（クライアントが認証されているかどうか、アプリケーション層プロトコルのサポートなど）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Authentication: Authenticate the server (and, optionally, the client) and provide key confirmation and handshake integrity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-認証：サーバー（およびオプションでクライアント）を認証し、キーの確認とハンドシェイクの整合性を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the Key Exchange phase, the client sends the ClientHello (Section 4.1.2) message, which contains a random nonce (ClientHello.random); its offered protocol versions; a list of symmetric cipher/HKDF hash pairs; either a set of Diffie-Hellman key shares (in the &#34;key_share&#34; (Section 4.2.8) extension), a set of pre-shared key labels (in the &#34;pre_shared_key&#34; (Section 4.2.11) extension), or both; and potentially additional extensions. Additional fields and/or messages may also be present for middlebox compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キー交換フェーズでは、クライアントは、ランダムなナンス（ClientHello.random）を含むClientHello（セクション4.1.2）メッセージを送信します。 提供されているプロトコルバージョン。 対称暗号/ HKDFハッシュペアのリスト。 Diffie-Hellmanキー共有のセット（「key_share」（セクション4.2.8）拡張内）、事前共有キーラベルのセット（「pre_shared_key」（セクション4.2.11）拡張内）、またはその両方。 潜在的に追加の拡張機能。 ミドルボックスの互換性のために、追加のフィールドやメッセージも存在する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server processes the ClientHello and determines the appropriate cryptographic parameters for the connection. It then responds with its own ServerHello (Section 4.1.3), which indicates the negotiated connection parameters. The combination of the ClientHello and the ServerHello determines the shared keys. If (EC)DHE key establishment is in use, then the ServerHello contains a &#34;key_share&#34; extension with the server&#39;s ephemeral Diffie-Hellman share; the server&#39;s share MUST be in the same group as one of the client&#39;s shares. If PSK key establishment is in use, then the ServerHello contains a &#34;pre_shared_key&#34; extension indicating which of the client&#39;s offered PSKs was selected. Note that implementations can use (EC)DHE and PSK together, in which case both extensions will be supplied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーはClientHelloを処理し、接続に適切な暗号化パラメーターを決定します。 その後、ネゴシエートされた接続パラメータを示す独自のServerHello（セクション4.1.3）で応答します。 ClientHelloとServerHelloの組み合わせにより、共有キーが決まります。 （EC）DHEキーの確立が使用されている場合、ServerHelloにはサーバーの一時的なDiffie-Hellman共有を含む「key_share」拡張が含まれます。 サーバーの共有は、クライアントの共有の1つと同じグループに属している必要があります。 PSKキーの確立が使用中の場合、ServerHelloには、クライアントが提供するPSKのどれが選択されたかを示す「pre_shared_key」拡張が含まれます。 実装では（EC）DHEとPSKを一緒に使用できることに注意してください。その場合、両方の拡張機能が提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server then sends two messages to establish the Server Parameters:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次に、サーバーは2つのメッセージを送信してサーバーパラメーターを確立します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EncryptedExtensions: responses to ClientHello extensions that are not required to determine the cryptographic parameters, other than those that are specific to individual certificates. [Section 4.3.1]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
EncryptedExtensions：個々の証明書に固有のもの以外の、暗号化パラメーターを決定する必要のないClientHello拡張機能への応答。 [セクション4.3.1]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateRequest: if certificate-based client authentication is desired, the desired parameters for that certificate. This message is omitted if client authentication is not desired. [Section 4.3.2]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateRequest：証明書ベースのクライアント認証が必要な場合、その証明書に必要なパラメーター。 クライアント認証が望ましくない場合、このメッセージは省略されます。 [セクション4.3.2]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finally, the client and server exchange Authentication messages. TLS uses the same set of messages every time that certificate-based authentication is needed. (PSK-based authentication happens as a side effect of key exchange.) Specifically:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後に、クライアントとサーバーは認証メッセージを交換します。 TLSは、証明書ベースの認証が必要になるたびに同じメッセージのセットを使用します。 （PSKベースの認証は、鍵交換の副作用として発生します。）特に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Certificate: The certificate of the endpoint and any per-certificate extensions. This message is omitted by the server if not authenticating with a certificate and by the client if the server did not send CertificateRequest (thus indicating that the client should not authenticate with a certificate). Note that if raw public keys [RFC7250] or the cached information extension [RFC7924] are in use, then this message will not contain a certificate but rather some other value corresponding to the server&#39;s long-term key. [Section 4.4.2]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
証明書：エンドポイントの証明書および証明書ごとの拡張。 このメッセージは、証明書で認証されていない場合はサーバーによって省略され、サーバーがCertificateRequestを送信しなかった場合はクライアントによって省略されます（したがって、クライアントが証明書で認証されないことを示します）。 生の公開鍵[RFC7250]またはキャッシュされた情報拡張[RFC7924]が使用されている場合、このメッセージには証明書が含まれず、サーバーの長期鍵に対応する他の値が含まれます。 [セクション4.4.2]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateVerify: A signature over the entire handshake using the private key corresponding to the public key in the Certificate message. This message is omitted if the endpoint is not authenticating via a certificate. [Section 4.4.3]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateVerify：証明書メッセージ内の公開キーに対応する秘密キーを使用した、ハンドシェイク全体にわたる署名。 エンドポイントが証明書を介して認証していない場合、このメッセージは省略されます。 [セクション4.4.3]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finished: A MAC (Message Authentication Code) over the entire handshake. This message provides key confirmation, binds the endpoint&#39;s identity to the exchanged keys, and in PSK mode also authenticates the handshake. [Section 4.4.4]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
終了：ハンドシェイク全体にわたるMAC（メッセージ認証コード）。 このメッセージはキーの確認を提供し、エンドポイントのIDを交換されたキーにバインドし、PSKモードではハンドシェイクも認証します。 [セクション4.4.4]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon receiving the server&#39;s messages, the client responds with its Authentication messages, namely Certificate and CertificateVerify (if requested), and Finished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーのメッセージを受信すると、クライアントは認証メッセージ、つまりCertificateとCertificateVerify（要求された場合）、およびFinishedで応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At this point, the handshake is complete, and the client and server derive the keying material required by the record layer to exchange application-layer data protected through authenticated encryption. Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3. Note that while the server may send Application Data prior to receiving the client&#39;s Authentication messages, any data sent at that point is, of course, being sent to an unauthenticated peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この時点で、ハンドシェイクは完了し、クライアントとサーバーは、認証された暗号化によって保護されたアプリケーション層のデータを交換するためにレコード層が必要とするキー情報を取得します。 セクション2.3で指定されている場合を除き、Finishedメッセージを送信する前にアプリケーションデータを送信してはなりません。 サーバーは、クライアントの認証メッセージを受信する前にアプリケーションデータを送信できますが、その時点で送信されるデータは、認証されていないピアに送信されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Incorrect DHE Share
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1。 不正なDHE共有
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client has not provided a sufficient &#34;key_share&#34; extension (e.g., it includes only DHE or ECDHE groups unacceptable to or unsupported by the server), the server corrects the mismatch with a HelloRetryRequest and the client needs to restart the handshake with an appropriate &#34;key_share&#34; extension, as shown in Figure 2. If no common cryptographic parameters can be negotiated, the server MUST abort the handshake with an appropriate alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが十分な &#34;key_share&#34;拡張を提供していない場合（たとえば、サーバーで受け入れられない、またはサポートされないDHEまたはECDHEグループのみが含まれる）、サーバーはHelloRetryRequestで不一致を修正し、クライアントは適切なハンドシェイクを再開する必要があります 図2に示すように、「key_share」拡張。共通の暗号化パラメータをネゴシエートできない場合、サーバーは適切なアラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        ClientHello
        + key_share             --------&gt;
                                                  HelloRetryRequest
                                &lt;--------               + key_share
        ClientHello
        + key_share             --------&gt;
                                                        ServerHello
                                                        + key_share
                                              {EncryptedExtensions}
                                              {CertificateRequest*}
                                                     {Certificate*}
                                               {CertificateVerify*}
                                                         {Finished}
                                &lt;--------       [Application Data*]
        {Certificate*}
        {CertificateVerify*}
        {Finished}              --------&gt;
        [Application Data]      &lt;-------&gt;        [Application Data]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             Figure 2: Message Flow for a Full Handshake with
                           Mismatched Parameters
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The handshake transcript incorporates the initial ClientHello/HelloRetryRequest exchange; it is not reset with the new ClientHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：ハンドシェイクのトランスクリプトには、最初のClientHello / HelloRetryRequest交換が組み込まれています。 新しいClientHelloではリセットされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS also allows several optimized variants of the basic handshake, as described in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSでは、次のセクションで説明するように、基本的なハンドシェイクのいくつかの最適化されたバリアントも使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Resumption and Pre-Shared Key (PSK)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2。 再開と事前共有キー（PSK）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although TLS PSKs can be established out of band, PSKs can also be established in a previous connection and then used to establish a new connection (&#34;session resumption&#34; or &#34;resuming&#34; with a PSK). Once a handshake has completed, the server can send the client a PSK identity that corresponds to a unique key derived from the initial handshake (see Section 4.6.1). The client can then use that PSK identity in future handshakes to negotiate the use of the associated PSK. If the server accepts the PSK, then the security context of the new connection is cryptographically tied to the original connection and the key derived from the initial handshake is used to bootstrap the cryptographic state instead of a full handshake. In TLS 1.2 and below, this functionality was provided by &#34;session IDs&#34; and &#34;session tickets&#34; [RFC5077]. Both mechanisms are obsoleted in TLS 1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS PSKは帯域外で確立できますが、PSKは以前の接続で確立してから、新しい接続の確立に使用することもできます（「セッション再開」またはPSKとの「再開」）。 ハンドシェイクが完了すると、サーバーはクライアントに最初のハンドシェイクから派生した一意のキーに対応するPSK IDを送信できます（セクション4.6.1を参照）。 その後、クライアントはそのPSK IDを将来のハンドシェイクで使用して、関連付けられたPSKの使用をネゴシエートできます。 サーバーがPSKを受け入れる場合、新しい接続のセキュリティコンテキストは元の接続に暗号で結び付けられ、最初のハンドシェイクから派生したキーは、完全なハンドシェイクではなく暗号状態をブートストラップするために使用されます。 TLS 1.2以前では、この機能は「セッションID」と「セッションチケット」[RFC5077]によって提供されていました。 両方のメカニズムはTLS 1.3で廃止されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PSKs can be used with (EC)DHE key exchange in order to provide forward secrecy in combination with shared keys, or can be used alone, at the cost of losing forward secrecy for the application data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PSKは、（EC）DHEキー交換で使用して、共有キーと組み合わせて転送秘密を提供するか、単独で使用できますが、アプリケーションデータの転送秘密が失われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 3 shows a pair of handshakes in which the first handshake establishes a PSK and the second handshake uses it:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図3は、最初のハンドシェイクがPSKを確立し、2番目のハンドシェイクがそれを使用するハンドシェイクのペアを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initial Handshake:
          ClientHello
          + key_share               --------&gt;
                                                          ServerHello
                                                          + key_share
                                                {EncryptedExtensions}
                                                {CertificateRequest*}
                                                       {Certificate*}
                                                 {CertificateVerify*}
                                                           {Finished}
                                    &lt;--------     [Application Data*]
          {Certificate*}
          {CertificateVerify*}
          {Finished}                --------&gt;
                                    &lt;--------      [NewSessionTicket]
          [Application Data]        &lt;-------&gt;      [Application Data]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Subsequent Handshake:
          ClientHello
          + key_share*
          + pre_shared_key          --------&gt;
                                                          ServerHello
                                                     + pre_shared_key
                                                         + key_share*
                                                {EncryptedExtensions}
                                                           {Finished}
                                    &lt;--------     [Application Data*]
          {Finished}                --------&gt;
          [Application Data]        &lt;-------&gt;      [Application Data]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 3: Message Flow for Resumption and PSK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図3：再開とPSKのメッセージフロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As the server is authenticating via a PSK, it does not send a Certificate or a CertificateVerify message. When a client offers resumption via a PSK, it SHOULD also supply a &#34;key_share&#34; extension to the server to allow the server to decline resumption and fall back to a full handshake, if needed. The server responds with a &#34;pre_shared_key&#34; extension to negotiate the use of PSK key establishment and can (as shown here) respond with a &#34;key_share&#34; extension to do (EC)DHE key establishment, thus providing forward secrecy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーはPSKを介して認証を行うため、証明書またはCertificateVerifyメッセージは送信しません。 クライアントがPSKを介して再開を提供する場合、サーバーが再開を拒否し、必要に応じて完全なハンドシェイクにフォールバックできるように、サーバーに「key_share」拡張機能も提供する必要があります。 サーバーはPSKキー確立の使用をネゴシエートするために「pre_shared_key」拡張機能で応答し、（ここに示すように）「key_share」拡張機能で応答して（EC）DHEキーを確立し、前方秘匿性を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When PSKs are provisioned out of band, the PSK identity and the KDF hash algorithm to be used with the PSK MUST also be provisioned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PSKが帯域外でプロビジョニングされる場合、PSKアイデンティティとPSKで使用されるKDFハッシュアルゴリズムもプロビジョニングする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: When using an out-of-band provisioned pre-shared secret, a critical consideration is using sufficient entropy during the key generation, as discussed in [RFC4086]. Deriving a shared secret from a password or other low-entropy sources is not secure. A low-entropy secret, or password, is subject to dictionary attacks based on the PSK binder. The specified PSK authentication is not a strong password-based authenticated key exchange even when used with Diffie-Hellman key establishment. Specifically, it does not prevent an attacker that can observe the handshake from performing a brute-force attack on the password/pre-shared key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：帯域外でプロビジョニングされた事前共有シークレットを使用する場合、[RFC4086]で説明されているように、鍵の生成時に十分なエントロピーを使用することが重要な考慮事項です。 パスワードまたは他の低エントロピーソースから共有シークレットを取得することは安全ではありません。 低エントロピーシークレット、またはパスワードは、PSKバインダに基づいた辞書攻撃の影響を受けます。 指定されたPSK認証は、Diffie-Hellmanキー確立で使用される場合でも、強力なパスワードベースの認証キー交換ではありません。 具体的には、ハンドシェイクを監視できる攻撃者がパスワード/事前共有キーに対してブルートフォース攻撃を実行することを防ぎません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. 0-RTT Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3。 0-RTTデータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When clients and servers share a PSK (either obtained externally or via a previous handshake), TLS 1.3 allows clients to send data on the first flight (&#34;early data&#34;). The client uses the PSK to authenticate the server and to encrypt the early data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバーが（外部または以前のハンドシェイクを介して取得された）PSKを共有する場合、TLS 1.3により、クライアントは最初のフライトでデータ（「初期データ」）を送信できます。 クライアントはPSKを使用してサーバーを認証し、初期データを暗号化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As shown in Figure 4, the 0-RTT data is just added to the 1-RTT handshake in the first flight. The rest of the handshake uses the same messages as for a 1-RTT handshake with PSK resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図4に示すように、最初のフライトで0-RTTデータが1-RTTハンドシェイクに追加されます。 ハンドシェイクの残りは、PSK再開を伴う1-RTTハンドシェイクと同じメッセージを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         ClientHello
         + early_data
         + key_share*
         + psk_key_exchange_modes
         + pre_shared_key
         (Application Data*)     --------&gt;
                                                         ServerHello
                                                    + pre_shared_key
                                                        + key_share*
                                               {EncryptedExtensions}
                                                       + early_data*
                                                          {Finished}
                                 &lt;--------       [Application Data*]
         (EndOfEarlyData)
         {Finished}              --------&gt;
         [Application Data]      &lt;-------&gt;        [Application Data]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               +  Indicates noteworthy extensions sent in the
                  previously noted message.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Indicates optional or situation-dependent messages/extensions that are not always sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*常に送信されるとは限らない、オプションまたは状況依存のメッセージ/拡張子を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
() Indicates messages protected using keys derived from a client_early_traffic_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（）client_early_traffic_secretから派生したキーを使用して保護されたメッセージを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
{} Indicates messages protected using keys derived from a [sender]_handshake_traffic_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
{} [sender] _handshake_traffic_secretから派生したキーを使用して保護されたメッセージを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[] Indicates messages protected using keys derived from [sender]_application_traffic_secret_N.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[] [sender] _application_traffic_secret_Nから派生したキーを使用して保護されたメッセージを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 4: Message Flow for a 0-RTT Handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図4：0-RTTハンドシェイクのメッセージフロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IMPORTANT NOTE: The security properties for 0-RTT data are weaker than those for other kinds of TLS data. Specifically:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
重要な注意：0-RTTデータのセキュリティプロパティは、他の種類のTLSデータのセキュリティプロパティよりも脆弱です。 具体的には：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. This data is not forward secret, as it is encrypted solely under keys derived using the offered PSK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.このデータは、提供されたPSKを使用して導出されたキーの下でのみ暗号化されるため、前方秘密ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. There are no guarantees of non-replay between connections. Protection against replay for ordinary TLS 1.3 1-RTT data is provided via the server&#39;s Random value, but 0-RTT data does not depend on the ServerHello and therefore has weaker guarantees. This is especially relevant if the data is authenticated either with TLS client authentication or inside the application protocol. The same warnings apply to any use of the early_exporter_master_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.接続間の非再生の保証はありません。 通常のTLS 1.3 1-RTTデータのリプレイに対する保護はサーバーのランダム値を介して提供されますが、0-RTTデータはServerHelloに依存しないため、保証が弱くなります。 これは、データがTLSクライアント認証またはアプリケーションプロトコル内で認証される場合に特に関連します。 同じ警告は、early_exporter_master_secretの使用にも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
0-RTT data cannot be duplicated within a connection (i.e., the server will not process the same data twice for the same connection), and an attacker will not be able to make 0-RTT data appear to be 1-RTT data (because it is protected with different keys). Appendix E.5 contains a description of potential attacks, and Section 8 describes mechanisms which the server can use to limit the impact of replay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続内で0-RTTデータを複製することはできません（つまり、サーバーは同じ接続に対して同じデータを2回処理しません）。攻撃者は0-RTTデータを1-RTTデータのように見せることはできません。 異なるキーで保護されています）。 付録E.5には、潜在的な攻撃の説明が含まれ、セクション8では、サーバーがリプレイの影響を制限するために使用できるメカニズムについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Presentation Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.プレゼンテーション言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document deals with the formatting of data in an external representation. The following very basic and somewhat casually defined presentation syntax will be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントでは、外部表現でのデータのフォーマットを扱います。 次の非常に基本的な、やや不定に定義されたプレゼンテーション構文が使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Basic Block Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。 基本ブロックサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The representation of all data items is explicitly specified. The basic data block size is one byte (i.e., 8 bits). Multiple-byte data items are concatenations of bytes, from left to right, from top to bottom. From the byte stream, a multi-byte item (a numeric in the following example) is formed (using C notation) by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのデータ項目の表現は明示的に指定されます。 基本的なデータブロックサイズは1バイト（つまり、8ビット）です。 複数バイトのデータ項目は、左から右へ、上から下へのバイトの連結です。 バイトストリームから、マルチバイト項目（次の例では数値）が（C表記を使用して）形成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) | ... | byte[n-1];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
値=（byte [0] &lt;&lt; 8 *（n-1））| （バイト[1] &lt;&lt; 8 *（n-2））| ... | バイト[n-1];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This byte ordering for multi-byte values is the commonplace network byte order or big-endian format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチバイト値のこのバイト順序は、一般的なネットワークバイト順序またはビッグエンディアン形式です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Miscellaneous
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。 その他
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Comments begin with &#34;/*&#34; and end with &#34;*/&#34;.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Optional components are denoted by enclosing them in &#34;[[ ]]&#34; (double brackets).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプションのコンポーネントは、「[[]]」（二重括弧）で囲むことによって示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Single-byte entities containing uninterpreted data are of type opaque.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
解釈されないデータを含むシングルバイトエンティティは、不透明タイプです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A type alias T&#39; for an existing type T is defined by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
既存のタイプTのタイプエイリアスT &#39;は、以下によって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T T&#39;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T T &#39;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3。 数字
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The basic numeric data type is an unsigned byte (uint8). All larger numeric data types are constructed from a fixed-length series of bytes concatenated as described in Section 3.1 and are also unsigned. The following numeric types are predefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
基本的な数値データ型は、符号なしバイト（uint8）です。 すべての大きな数値データ型は、セクション3.1で説明されているように連結された固定長の一連のバイトから構築され、符号もありません。 次の数値タイプが事前定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All values, here and elsewhere in the specification, are transmitted in network byte (big-endian) order; the uint32 represented by the hex bytes 01 02 03 04 is equivalent to the decimal value 16909060.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここおよび仕様の別の場所にあるすべての値は、ネットワークバイト（ビッグエンディアン）順序で送信されます。 16進バイト01 02 03 04で表されるuint32は、10進値16909060と同等です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Vectors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4。 ベクトル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A vector (single-dimensioned array) is a stream of homogeneous data elements. The size of the vector may be specified at documentation time or left unspecified until runtime. In either case, the length declares the number of bytes, not the number of elements, in the vector. The syntax for specifying a new type, T&#39;, that is a fixed-length vector of type T is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ベクトル（一次元配列）は、同種のデータ要素のストリームです。 ベクターのサイズは、ドキュメント作成時に指定するか、実行時まで指定しないままにすることができます。 どちらの場合でも、長さはベクトルの要素数ではなくバイト数を宣言します。 T型の固定長ベクトルである新しい型T &#39;を指定するための構文は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T T&#39;[n];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T T &#39;[n];
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here, T&#39; occupies n bytes in the data stream, where n is a multiple of the size of T. The length of the vector is not included in the encoded stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで、T &#39;はデータストリームでnバイトを占有します。nはTのサイズの倍数です。ベクトルの長さはエンコードされたストリームに含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the following example, Datum is defined to be three consecutive bytes that the protocol does not interpret, while Data is three consecutive Datum, consuming a total of nine bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の例では、プロトコルが解釈しない3つの連続したバイトとしてDatumが定義されていますが、Dataは合計9つのバイトを消費する3つの連続したDatumです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* three consecutive 3-byte vectors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Variable-length vectors are defined by specifying a subrange of legal lengths, inclusively, using the notation &lt;floor..ceiling&gt;. When these are encoded, the actual length precedes the vector&#39;s contents in the byte stream. The length will be in the form of a number consuming as many bytes as required to hold the vector&#39;s specified maximum (ceiling) length. A variable-length vector with an actual length field of zero is referred to as an empty vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
可変長ベクトルは、表記&lt;floor..ceiling&gt;を使用して、有効な長さのサブ範囲を包括的に指定することによって定義されます。 これらがエンコードされると、実際の長さがバイトストリーム内のベクターのコンテンツに先行します。 長さは、ベクトルの指定された最大（天井）長を保持するのに必要なバイト数を消費する数値の形式になります。 実際の長さフィールドがゼロの可変長ベクトルは、空のベクトルと呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T T&#39;&lt;floor..ceiling&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T T &#39;&lt;床..天井&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the following example, &#34;mandatory&#34; is a vector that must contain between 300 and 400 bytes of type opaque. It can never be empty. The actual length field consumes two bytes, a uint16, which is sufficient to represent the value 400 (see Section 3.3). Similarly, &#34;longer&#34; can represent up to 800 bytes of data, or 400 uint16 elements, and it may be empty. Its encoding will include a two-byte actual length field prepended to the vector. The length of an encoded vector must be an exact multiple of the length of a single element (e.g., a 17-byte vector of uint16 would be illegal).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の例では、「必須」は不透明型の300〜400バイトを含む必要があるベクトルです。 空にすることはできません。 実際の長さフィールドは、値400を表すのに十分なuint16という2バイトを消費します（セクション3.3を参照）。 同様に、「long」は最大800バイトのデータ、または400 uint16要素を表すことができ、空の場合もあります。 そのエンコードには、ベクトルの前に付加される2バイトの実際の長さフィールドが含まれます。 エンコードされたベクトルの長さは、単一の要素の長さの正確な倍数でなければなりません（たとえば、uint16の17バイトのベクトルは不正です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      opaque mandatory&lt;300..400&gt;;
            /* length field is two bytes, cannot be empty */
      uint16 longer&lt;0..800&gt;;
            /* zero to 400 16-bit unsigned integers */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Enumerateds
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5。 列挙
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An additional sparse data type, called &#34;enum&#34; or &#34;enumerated&#34;, is available. Each definition is a different type. Only enumerateds of the same type may be assigned or compared. Every element of an enumerated must be assigned a value, as demonstrated in the following example. Since the elements of the enumerated are not ordered, they can be assigned any unique value, in any order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「enum」または「enumerated」と呼ばれる追加のスパースデータ型が利用可能です。 各定義は異なるタイプです。 同じタイプの列挙のみを割り当てまたは比較できます。 次の例に示すように、列挙型のすべての要素に値を割り当てる必要があります。 列挙型の要素は順序付けされていないため、任意の一意の値を任意の順序で割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Future extensions or additions to the protocol may define new values. Implementations need to be able to parse and ignore unknown values unless the definition of the field states otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコルの将来の拡張または追加により、新しい値が定義される可能性があります。 実装では、フィールドの定義に特に明記されていない限り、未知の値を解析および無視できる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An enumerated occupies as much space in the byte stream as would its maximal defined ordinal value. The following definition would cause one byte to be used to carry fields of type Color.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙型は、バイトストリーム内で、定義された最大の順序値と同じくらいのスペースを占有します。 次の定義により、Color型のフィールドを保持するために1バイトが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { red(3), blue(5), white(7) } Color;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One may optionally specify a value without its associated tag to force the width definition without defining a superfluous element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプションで、関連付けられたタグなしで値を指定して、余分な要素を定義せずに幅を強制的に定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the following example, Taste will consume two bytes in the data stream but can only assume the values 1, 2, or 4 in the current version of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の例では、Tasteはデータストリームで2バイトを消費しますが、プロトコルの現在のバージョンでは値1、2、または4のみを想定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The names of the elements of an enumeration are scoped within the defined type. In the first example, a fully qualified reference to the second element of the enumeration would be Color.blue. Such qualification is not required if the target of the assignment is well specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙の要素の名前は、定義された型内でスコープされます。 最初の例では、列挙の2番目の要素への完全修飾参照はColor.blueになります。 割り当ての対象が明確に指定されている場合、そのような資格は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The names assigned to enumerateds do not need to be unique. The numerical value can describe a range over which the same name applies. The value includes the minimum and maximum inclusive values in that range, separated by two period characters. This is principally useful for reserving regions of the space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙に割り当てられる名前は一意である必要はありません。 数値は、同じ名前が適用される範囲を説明できます。 値には、2つのピリオド文字で区切られた、その範囲の最小値と最大値が含まれます。 これは、主にスペースの領域を予約するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { sad(0), meh(1..254), happy(255) } Mood;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Constructed Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6。 構築型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure types may be constructed from primitive types for convenience. Each specification declares a new, unique type. The syntax used for definitions is much like that of C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造型は、便宜上、プリミティブ型から構築できます。 各仕様は、新しい一意の型を宣言します。 定義に使用される構文は、Cの構文によく似ています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } T;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fixed- and variable-length vector fields are allowed using the standard vector syntax. Structures V1 and V2 in the variants example (Section 3.8) demonstrate this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
標準ベクトル構文を使用して、固定長および可変長のベクトルフィールドを使用できます。 バリアントの例（セクション3.8）の構造V1およびV2は、これを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fields within a structure may be qualified using the type&#39;s name, with a syntax much like that available for enumerateds. For example, T.f2 refers to the second field of the previous declaration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
構造体内のフィールドは、列挙型で使用可能な構文によく似た構文で、型の名前を使用して修飾できます。 たとえば、T.f2は前の宣言の2番目のフィールドを参照します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. Constants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7。 定数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Fields and variables may be assigned a fixed value using &#34;=&#34;, as in:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィールドと変数には、次のように「=」を使用して固定値を割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          T1 f1 = 8;  /* T.f1 must always be 8 */
          T2 f2;
      } T;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8。 バリエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Defined structures may have variants based on some knowledge that is available within the environment. The selector must be an enumerated type that defines the possible variants the structure defines. Each arm of the select (below) specifies the type of that variant&#39;s field and an optional field label. The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義された構造には、環境内で利用可能な知識に基づいたバリアントが含まれる場合があります。 セレクターは、構造が定義する可能性のあるバリアントを定義する列挙型である必要があります。 選択の各アーム（下）は、そのバリアントのフィールドのタイプとオプションのフィールドラベルを指定します。 実行時にバリアントを選択するメカニズムは、プレゼンテーション言語で規定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
          select (E) {
              case e1: Te1 [[fe1]];
              case e2: Te2 [[fe2]];
              ....
              case en: Ten [[fen]];
          };
      } Tv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { apple(0), orange(1) } VariantTag;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          uint16 number;
          opaque string&lt;0..10&gt;; /* variable length */
      } V1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          VariantTag type;
          select (VariantRecord.type) {
              case apple:  V1;
              case orange: V2;
          };
      } VariantRecord;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Handshake Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.ハンドシェイクプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The handshake protocol is used to negotiate the security parameters of a connection. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext or TLSCiphertext structures which are processed and transmitted as specified by the current active connection state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェイクプロトコルは、接続のセキュリティパラメータをネゴシエートするために使用されます。 ハンドシェイクメッセージはTLSレコード層に提供され、現在のアクティブな接続状態の指定に従って処理および送信される1つ以上のTLSPlaintextまたはTLSCiphertext構造内にカプセル化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          client_hello(1),
          server_hello(2),
          new_session_ticket(4),
          end_of_early_data(5),
          encrypted_extensions(8),
          certificate(11),
          certificate_request(13),
          certificate_verify(15),
          finished(20),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* remaining bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an &#34;unexpected_message&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコルメッセージは、セクション4.4.1で定義され、セクション2の図に示されている順序で送信する必要があります。予期しない順序でハンドシェイクメッセージを受信するピアは、「unexpected_message」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
New handshake message types are assigned by IANA as described in Section 11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション11で説明されているように、新しいハンドシェイクメッセージタイプはIANAによって割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Key Exchange Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。 キー交換メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key exchange messages are used to determine the security capabilities of the client and the server and to establish shared secrets, including the traffic keys used to protect the rest of the handshake and the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キー交換メッセージは、クライアントとサーバーのセキュリティ機能を決定し、ハンドシェイクとデータの残りを保護するために使用されるトラフィックキーを含む共有シークレットを確立するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Cryptographic Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1。 暗号交渉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In TLS, the cryptographic negotiation proceeds by the client offering the following four sets of options in its ClientHello:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSでは、暗号ネゴシエーションは、ClientHelloで次の4つのオプションセットを提供するクライアントによって続行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A list of cipher suites which indicates the AEAD algorithm/HKDF hash pairs which the client supports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-クライアントがサポートするAEADアルゴリズム/ HKDFハッシュペアを示す暗号スイートのリスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A &#34;supported_groups&#34; (Section 4.2.7) extension which indicates the (EC)DHE groups which the client supports and a &#34;key_share&#34; (Section 4.2.8) extension which contains (EC)DHE shares for some or all of these groups.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-クライアントがサポートする（EC）DHEグループを示す「supported_groups」（セクション4.2.7）拡張、およびこれらのグループの一部またはすべての（EC）DHE共有を含む「key_share」（セクション4.2.8）拡張 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A &#34;signature_algorithms&#34; (Section 4.2.3) extension which indicates the signature algorithms which the client can accept. A &#34;signature_algorithms_cert&#34; extension (Section 4.2.3) may also be added to indicate certificate-specific signature algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-クライアントが受け入れることができる署名アルゴリズムを示す「signature_algorithms」（セクション4.2.3）拡張。 「signature_algorithms_cert」拡張機能（セクション4.2.3）を追加して、証明書固有の署名アルゴリズムを示すこともできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A &#34;pre_shared_key&#34; (Section 4.2.11) extension which contains a list of symmetric key identities known to the client and a &#34;psk_key_exchange_modes&#34; (Section 4.2.9) extension which indicates the key exchange modes that may be used with PSKs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-クライアントが認識している対称キーIDのリストを含む「pre_shared_key」（セクション4.2.11）拡張と、PSKで使用できるキー交換モードを示す「psk_key_exchange_modes」（セクション4.2.9）拡張。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server does not select a PSK, then the first three of these options are entirely orthogonal: the server independently selects a cipher suite, an (EC)DHE group and key share for key establishment, and a signature algorithm/certificate pair to authenticate itself to the client. If there is no overlap between the received &#34;supported_groups&#34; and the groups supported by the server, then the server MUST abort the handshake with a &#34;handshake_failure&#34; or an &#34;insufficient_security&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーがPSKを選択しない場合、これらのオプションの最初の3つは完全に直交します。サーバーは、暗号スイート、（EC）DHEグループ、鍵確立用の鍵共有、および認証する署名アルゴリズム/証明書ペアを個別に選択します それ自体をクライアントに。 受信した「supported_groups」とサーバーがサポートするグループの間に重複がない場合、サーバーは「handshake_failure」または「insufficient_security」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client&#39;s &#34;psk_key_exchange_modes&#34; extension (at present, PSK alone or with (EC)DHE). Note that if the PSK can be used without (EC)DHE, then non-overlap in the &#34;supported_groups&#34; parameters need not be fatal, as it is in the non-PSK case discussed in the previous paragraph.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーがPSKを選択する場合、クライアントの「psk_key_exchange_modes」拡張（現在、PSK単独または（EC）DHEを使用）で示されるセットから鍵確立モードも選択する必要があります。 PSKを（EC）DHEなしで使用できる場合、前の段落で説明した非PSKの場合のように、「supported_groups」パラメーターの非重複が致命的である必要はないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server selects an (EC)DHE group and the client did not offer a compatible &#34;key_share&#34; extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが（EC）DHEグループを選択し、クライアントが初期ClientHelloで互換性のある「key_share」拡張を提供しなかった場合、サーバーはHelloRetryRequest（セクション4.1.4）メッセージで応答しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server successfully selects parameters and does not require a HelloRetryRequest, it indicates the selected parameters in the ServerHello as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーがパラメーターを正常に選択し、HelloRetryRequestを必要としない場合、ServerHelloで選択されたパラメーターを次のように示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If PSK is being used, then the server will send a &#34;pre_shared_key&#34; extension indicating the selected key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-PSKが使用されている場合、サーバーは選択されたキーを示す「pre_shared_key」拡張子を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- When (EC)DHE is in use, the server will also provide a &#34;key_share&#34; extension. If PSK is not being used, then (EC)DHE and certificate-based authentication are always used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-（EC）DHEが使用されている場合、サーバーは「key_share」拡張機能も提供します。 PSKが使用されていない場合、（EC）DHEおよび証明書ベースの認証が常に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- When authenticating via a certificate, the server will send the Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3) messages. In TLS 1.3 as defined by this document, either a PSK or a certificate is always used, but not both. Future documents may define how to use them together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-証明書を介して認証する場合、サーバーは証明書（セクション4.4.2）および証明書検証（セクション4.4.3）メッセージを送信します。 このドキュメントで定義されているTLS 1.3では、PSKまたは証明書のいずれかが常に使用されますが、両方は使用されません。 将来のドキュメントは、それらを一緒に使用する方法を定義するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server is unable to negotiate a supported set of parameters (i.e., there is no overlap between the client and server parameters), it MUST abort the handshake with either a &#34;handshake_failure&#34; or &#34;insufficient_security&#34; fatal alert (see Section 6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーがサポートされているパラメーターのセットをネゴシエートできない場合（つまり、クライアントとサーバーのパラメーターが重複していない場合）、「handshake_failure」または「insufficient_security」致命的アラートでハンドシェイクを中止する必要があります（セクション6を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Client Hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2。 クライアントこんにちは
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message. The client will also send a ClientHello when the server has responded to its ClientHello with a HelloRetryRequest. In that case, the client MUST send the same ClientHello without modification, except as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが最初にサーバーに接続するとき、ClientHelloを最初のTLSメッセージとして送信する必要があります。 サーバーは、HelloRetryRequestでClientHelloに応答したときに、クライアントもClientHelloを送信します。 その場合、クライアントは次の場合を除いて、変更せずに同じClientHelloを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If a &#34;key_share&#34; extension was supplied in the HelloRetryRequest, replacing the list of shares with a list containing a single KeyShareEntry from the indicated group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「key_share」拡張機能がHelloRetryRequestで指定された場合、指定されたグループの単一のKeyShareEntryを含むリストで共有のリストを置き換えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Removing the &#34;early_data&#34; extension (Section 4.2.10) if one was present. Early data is not permitted after a HelloRetryRequest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「early_data」拡張機能（4.2.10項）が存在する場合は削除します。 HelloRetryRequestの後の初期データは許可されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Including a &#34;cookie&#34; extension if one was provided in the HelloRetryRequest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-HelloRetryRequestで「Cookie」拡張機能が提供された場合、その拡張機能を含めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Updating the &#34;pre_shared_key&#34; extension if present by recomputing the &#34;obfuscated_ticket_age&#34; and binder values and (optionally) removing any PSKs which are incompatible with the server&#39;s indicated cipher suite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「obfuscated_ticket_age」とバインダーの値を再計算し、（オプションで）サーバーの指定された暗号スイートと互換性のないPSKを削除することにより、「pre_shared_key」拡張機能を更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Optionally adding, removing, or changing the length of the &#34;padding&#34; extension [RFC7685].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-オプションで、「パディング」拡張機能の長さを追加、削除、または変更します[RFC7685]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Other modifications that may be allowed by an extension defined in the future and present in the HelloRetryRequest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-将来定義され、HelloRetryRequestに存在する拡張機能によって許可される可能性があるその他の変更。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an &#34;unexpected_message&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3は再ネゴシエーションを禁止しているため、サーバーがTLS 1.3をネゴシエートし、それ以外の時間にClientHelloを受信した場合、「unexpected_message」アラートで接続を終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version. In particular, it MUST NOT negotiate TLS 1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが以前のバージョンのTLSとのTLS接続を確立し、再ネゴシエーションでTLS 1.3 ClientHelloを受信した場合、以前のプロトコルバージョンを保持する必要があります。 特に、TLS 1.3をネゴシエートしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      uint16 ProtocolVersion;
      opaque Random[32];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      uint8 CipherSuite[2];    /* Cryptographic suite selector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id&lt;0..32&gt;;
          CipherSuite cipher_suites&lt;2..2^16-2&gt;;
          opaque legacy_compression_methods&lt;1..2^8-1&gt;;
          Extension extensions&lt;8..2^16-1&gt;;
      } ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_version: In previous versions of TLS, this field was used for version negotiation and represented the highest version number supported by the client. Experience has shown that many servers do not properly implement version negotiation, leading to &#34;version intolerance&#34; in which the server rejects an otherwise acceptable ClientHello with a version number higher than it supports. In TLS 1.3, the client indicates its version preferences in the &#34;supported_versions&#34; extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. TLS 1.3 ClientHellos are identified as having a legacy_version of 0x0303 and a supported_versions extension present with 0x0304 as the highest version indicated therein. (See Appendix D for details about backward compatibility.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_version：TLSの以前のバージョンでは、このフィールドはバージョンネゴシエーションに使用され、クライアントでサポートされている最大のバージョン番号を表していました。 多くのサーバーはバージョンネゴシエーションを適切に実装していないため、サーバーがサポートするバージョン番号よりも高いバージョンのClientHelloを拒否する「バージョン不寛容」につながることが経験からわかっています。 TLS 1.3では、クライアントは「supported_versions」拡張子（セクション4.2.1）でバージョン設定を示し、legacy_versionフィールドは0x0303（TLS 1.2のバージョン番号）に設定する必要があります。 TLS 1.3 ClientHellosは、legacy_versionが0x0303であり、supported_versions拡張子がその中に示されている最高バージョンとして0x0304であると識別されます。 （後方互換性の詳細については、付録Dを参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
random: 32 bytes generated by a secure random number generator. See Appendix C for additional information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
random：安全な乱数ジェネレーターによって生成された32バイト。 追加情報については、付録Cを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_session_id: Versions of TLS before TLS 1.3 supported a &#34;session resumption&#34; feature which has been merged with pre-shared keys in this version (see Section 2.2). A client which has a cached session ID set by a pre-TLS 1.3 server SHOULD set this field to that value. In compatibility mode (see Appendix D.4), this field MUST be non-empty, so a client not offering a pre-TLS 1.3 session MUST generate a new 32-byte value. This value need not be random but SHOULD be unpredictable to avoid implementations fixating on a specific value (also known as ossification). Otherwise, it MUST be set as a zero-length vector (i.e., a zero-valued single byte length field).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_session_id：TLS 1.3より前のTLSのバージョンは、このバージョンの事前共有キーとマージされた「セッション再開」機能をサポートしていました（セクション2.2を参照）。 TLS 1.3以前のサーバーによって設定されたキャッシュセッションIDを持つクライアントは、このフィールドをその値に設定する必要があります。 互換性モード（付録D.4を参照）では、このフィールドは空でない必要があるため、TLS 1.3以前のセッションを提供しないクライアントは新しい32バイト値を生成する必要があります。 この値はランダムである必要はありませんが、実装が特定の値に固定されるのを避けるために予測不可能である必要があります（オッシフィケーションとも呼ばれます）。 それ以外の場合、長さゼロのベクトル（つまり、ゼロ値の単一バイト長フィールド）として設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher_suites: A list of the symmetric cipher options supported by the client, specifically the record protection algorithm (including secret key length) and a hash to be used with HKDF, in descending order of client preference. Values are defined in Appendix B.4. If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual. If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher_suites：クライアントがサポートする対称暗号オプションのリスト、具体的には、レコード保護アルゴリズム（秘密鍵の長さを含む）およびHKDFで使用されるハッシュを、クライアントの優先度の降順で示します。 値は付録B.4で定義されています。 サーバーが認識、サポート、または使用を希望しない暗号スイートがリストに含まれている場合、サーバーはそれらの暗号スイートを無視し、残りの暗号スイートを通常どおりに処理する必要があります。 クライアントがPSKキーの確立を試みている場合、PSKに関連付けられたハッシュを示す少なくとも1つの暗号スイートをアドバタイズする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_compression_methods: Versions of TLS before 1.3 supported compression with the list of supported compression methods being sent in this field. For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the &#34;null&#34; compression method in prior versions of TLS. If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an &#34;illegal_parameter&#34; alert. Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_compression_methods：1.3より前のTLSのバージョンは、このフィールドで送信されるサポートされている圧縮方法のリストで圧縮をサポートしていました。 すべてのTLS 1.3 ClientHelloについて、このベクトルには、ゼロに設定された正確に1バイトが含まれている必要があります。これは、以前のバージョンのTLSの「null」圧縮方式に対応します。 このフィールドの他の値でTLS 1.3 ClientHelloを受信した場合、サーバーは「illegal_parameter」アラートでハンドシェイクを中止する必要があります。 TLS 1.3サーバーは、他の圧縮方法を含むTLS 1.2または以前のClientHellosを受信する場合があり、（そのような以前のバージョンをネゴシエートする場合）TLSの適切な以前のバージョンの手順に従う必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
extensions: Clients request extended functionality from servers by sending data in the extensions field. The actual &#34;Extension&#34; format is defined in Section 4.2. In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS. Servers MUST ignore unrecognized extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張機能：クライアントは、拡張機能フィールドにデータを送信して、サーバーに拡張機能を要求します。 実際の「拡張」フォーマットは、セクション4.2で定義されています。 TLS 1.3では、ClientHelloとTLSの以前のバージョンとの互換性を維持するために機能が拡張機能に移行したため、特定の拡張機能の使用は必須です。 サーバーは認識されない拡張子を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All versions of TLS allow an extensions field to optionally follow the compression_methods field. TLS 1.3 ClientHello messages always contain extensions (minimally &#34;supported_versions&#34;, otherwise, they will be interpreted as TLS 1.2 ClientHello messages). However, TLS 1.3 servers might receive ClientHello messages without an extensions field from prior versions of TLS. The presence of extensions can be detected by determining whether there are bytes following the compression_methods field at the end of the ClientHello. Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined. TLS 1.3 servers will need to perform this check first and only attempt to negotiate TLS 1.3 if the &#34;supported_versions&#34; extension is present. If negotiating a version of TLS prior to 1.3, a server MUST check that the message either contains no data after legacy_compression_methods or that it contains a valid extensions block with no data following. If not, then it MUST abort the handshake with a &#34;decode_error&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSのすべてのバージョンでは、オプションで拡張フィールドをcompression_methodsフィールドの後に続けることができます。 TLS 1.3 ClientHelloメッセージには、常に拡張子が含まれます（最小で「supported_versions」、それ以外の場合、TLS 1.2 ClientHelloメッセージとして解釈されます）。ただし、TLS 1.3サーバーは、以前のバージョンのTLSから拡張フィールドのないClientHelloメッセージを受信する場合があります。拡張機能の存在は、ClientHelloの最後のcompression_methodsフィールドに続くバイトがあるかどうかを判断することで検出できます。このオプションのデータを検出する方法は、可変長フィールドを持つ通常のTLS方法とは異なりますが、拡張機能が定義される前のTLSとの互換性のために使用されることに注意してください。 TLS 1.3サーバーは、最初にこのチェックを実行する必要があり、「supported_versions」拡張機能が存在する場合にのみTLS 1.3をネゴシエートしようとします。 1.3より前のバージョンのTLSをネゴシエートする場合、サーバーは、legacy_compression_methodsの後にメッセージにデータが含まれていないか、データが後続しない有効な拡張ブロックが含まれていることを確認する必要があります。そうでない場合、「decode_error」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが拡張機能を使用して追加機能を要求し、この機能がサーバーによって提供されていない場合、クライアントはハンドシェイクを中止することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message. If early data is in use, the client may transmit early Application Data (Section 2.3) while waiting for the next handshake message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientHelloメッセージを送信した後、クライアントはServerHelloまたはHelloRetryRequestメッセージを待ちます。 初期データが使用されている場合、クライアントは次のハンドシェイクメッセージを待っている間に初期アプリケーションデータ（2.3節）を送信できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3. Server Hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3。 サーバーこんにちは
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server will send this message in response to a ClientHello message to proceed with the handshake if it is able to negotiate an acceptable set of handshake parameters based on the ClientHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、ClientHelloに基づいてハンドシェイクパラメータの許容セットをネゴシエートできる場合、ClientHelloメッセージへの応答としてこのメッセージを送信してハンドシェイクを続行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id_echo&lt;0..32&gt;;
          CipherSuite cipher_suite;
          uint8 legacy_compression_method = 0;
          Extension extensions&lt;6..2^16-1&gt;;
      } ServerHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_version: In previous versions of TLS, this field was used for version negotiation and represented the selected version number for the connection. Unfortunately, some middleboxes fail when presented with new values. In TLS 1.3, the TLS server indicates its version using the &#34;supported_versions&#34; extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2. (See Appendix D for details about backward compatibility.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_version：TLSの以前のバージョンでは、このフィールドはバージョンネゴシエーションに使用され、接続用に選択されたバージョン番号を表していました。 残念ながら、新しい値を提示すると一部のミドルボックスが失敗します。 TLS 1.3では、TLSサーバーは「supported_versions」拡張子（セクション4.2.1）を使用してバージョンを示し、legacy_versionフィールドは0x0303（TLS 1.2のバージョン番号）に設定する必要があります。 （後方互換性の詳細については、付録Dを参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
random: 32 bytes generated by a secure random number generator. See Appendix C for additional information. The last 8 bytes MUST be overwritten as described below if negotiating TLS 1.2 or TLS 1.1, but the remaining bytes MUST be random. This structure is generated by the server and MUST be generated independently of the ClientHello.random.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
random：安全な乱数ジェネレーターによって生成された32バイト。 追加情報については、付録Cを参照してください。 TLS 1.2またはTLS 1.1をネゴシエートする場合、最後の8バイトは以下で説明するように上書きする必要がありますが、残りのバイトはランダムでなければなりません。 この構造はサーバーによって生成され、ClientHello.randomとは独立して生成されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_session_id_echo: The contents of the client&#39;s legacy_session_id field. Note that this field is echoed even if the client&#39;s value corresponded to a cached pre-TLS 1.3 session which the server has chosen not to resume. A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_session_id_echo：クライアントのlegacy_session_idフィールドの内容。 クライアントの値が、サーバーが再開しないことを選択したキャッシュされたTLS 1.3以前のセッションに対応していても、このフィールドはエコーされることに注意してください。 ClientHelloで送信したものと一致しないlegacy_session_id_echoフィールドを受信したクライアントは、「illegal_parameter」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher_suite: The single cipher suite selected by the server from the list in ClientHello.cipher_suites. A client which receives a cipher suite that was not offered MUST abort the handshake with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
cipher_suite：ClientHello.cipher_suitesのリストからサーバーによって選択された単一の暗号スイート。 提供されなかった暗号スイートを受け取るクライアントは、「illegal_parameter」アラートでハンドシェイクを中止しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_compression_method: A single byte which MUST have the value 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_compression_method：値0を持つ必要がある単一バイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
extensions: A list of extensions. The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version. All TLS 1.3 ServerHello messages MUST contain the &#34;supported_versions&#34; extension. Current ServerHello messages additionally contain either the &#34;pre_shared_key&#34; extension or the &#34;key_share&#34; extension, or both (when using a PSK with (EC)DHE key establishment). Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張機能：拡張機能のリスト。 ServerHelloには、暗号化コンテキストを確立し、プロトコルバージョンをネゴシエートするために必要な拡張のみを含める必要があります。 すべてのTLS 1.3 ServerHelloメッセージには、「supported_versions」拡張子を含める必要があります。 現在のServerHelloメッセージには、「pre_shared_key」拡張機能または「key_share」拡張機能のいずれか、または両方が含まれます（PSKを（EC）DHEキー確立で使用する場合）。 他の拡張機能（セクション4.2を参照）は、EncryptedExtensionsメッセージで個別に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For reasons of backward compatibility with middleboxes (see Appendix D.4), the HelloRetryRequest message uses the same structure as the ServerHello, but with Random set to the special value of the SHA-256 of &#34;HelloRetryRequest&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ミドルボックスとの下位互換性のため（付録D.4を参照）、HelloRetryRequestメッセージはServerHelloと同じ構造を使用しますが、Randomは「HelloRetryRequest」のSHA-256の特別な値に設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91 C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91 C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this value, process it as described in Section 4.1.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイプserver_helloのメッセージを受信すると、実装は最初にRandom値を調べ、この値に一致する場合、セクション4.1.4で説明されているように処理する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3 has a downgrade protection mechanism embedded in the server&#39;s random value. TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3には、サーバーのランダム値に埋め込まれたダウングレード保護メカニズムがあります。 ClientHelloに応答してTLS 1.2以下をネゴシエートするTLS 1.3サーバーは、ServerHelloでランダム値の最後の8バイトを特別に設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.2をネゴシエートする場合、TLS 1.3サーバーは、ランダム値の最後の8バイトをバイトに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
44 4F 57 4E 47 52 44 01
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
44 4F 57 4E 47 52 44 01
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.1以下をネゴシエートする場合、TLS 1.3サーバーは必須であり、TLS 1.2サーバーは、ServerHello.Random値の最後の8バイトをバイトに設定する必要があります（SHOULD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
44 4F 57 4E 47 52 44 00
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
44 4F 57 4E 47 52 44 00
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values. TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below. If a match is found, the client MUST abort the handshake with an &#34;illegal_parameter&#34; alert. This mechanism provides limited protection against downgrade attacks over and above what is provided by the Finished exchange: because the ServerKeyExchange, a message present in TLS 1.2 and below, includes a signature over both random values, it is not possible for an active attacker to modify the random values without detection as long as ephemeral ciphers are used. It does not provide downgrade protection when static RSA is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.2以下を示すServerHelloを受信するTLS 1.3クライアントは、最後の8バイトがこれらの値のいずれとも等しくないことを確認する必要があります。 TLS 1.2クライアントは、ServerHelloがTLS 1.1以下を示している場合、最後の8バイトが2番目の値と等しくないことも確認する必要があります。 一致が見つかった場合、クライアントは「illegal_parameter」アラートでハンドシェイクを中止する必要があります。 このメカニズムは、Finished Exchangeが提供するもの以上のダウングレード攻撃に対する限定的な保護を提供します：ServerKeyExchange（TLS 1.2以下に存在するメッセージ）には両方のランダムな値に対する署名が含まれているため、アクティブな攻撃者が変更することはできません はかない暗号が使用されている限り、検出されないランダムな値。 静的RSAが使用されている場合、ダウングレード保護は提供されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: This is a change from [RFC5246], so in practice many TLS 1.2 clients and servers will not behave as specified above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：これは[RFC5246]からの変更であるため、実際には多くのTLS 1.2クライアントおよびサーバーは上記のように動作しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a &#34;protocol_version&#34; alert. Note that renegotiation is not possible when TLS 1.3 has been negotiated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.2以前で再ネゴシエーションを実行し、再ネゴシエーション中にTLS 1.3 ServerHelloを受信するレガシーTLSクライアントは、「protocol_version」アラートでハンドシェイクを中止しなければなりません。 TLS 1.3がネゴシエートされた場合、再ネゴシエーションは不可能であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.4. Hello Retry Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.4。 ハローリトライリクエスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server will send this message in response to a ClientHello message if it is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake. As discussed in Section 4.1.3, the HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning. However, for convenience we discuss &#34;HelloRetryRequest&#34; throughout this document as if it were a distinct message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、許容可能なパラメーターセットを見つけることができるが、ClientHelloにハンドシェイクを続行するための十分な情報が含まれていない場合、ClientHelloメッセージへの応答としてこのメッセージを送信します。 セクション4.1.3で説明したように、HelloRetryRequestの形式はServerHelloメッセージと同じで、legacy_version、legacy_session_id_echo、cipher_suite、およびlegacy_compression_methodフィールドの意味は同じです。 ただし、便宜上、このドキュメント全体で「HelloRetryRequest」を個別のメッセージであるかのように説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server&#39;s extensions MUST contain &#34;supported_versions&#34;. Additionally, it SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair. As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the &#34;cookie&#34; (see Section 4.2.2) extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーの拡張機能には、「supported_versions」を含める必要があります。 さらに、クライアントが正しいClientHelloペアを生成するために必要な拡張機能の最小限のセットを含める必要があります。 ServerHelloと同様に、HelloRetryRequestには、オプションで「cookie」（セクション4.2.2を参照）拡張を除き、ClientHelloでクライアントによって最初に提供されなかった拡張を含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using &#34;supported_versions&#34;. Clients MUST abort the handshake with an &#34;illegal_parameter&#34; alert if the HelloRetryRequest would not result in any change in the ClientHello. If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), it MUST abort the handshake with an &#34;unexpected_message&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HelloRetryRequestを受信したクライアントは、セクション4.1.3で指定されているlegacy_version、legacy_session_id_echo、cipher_suite、およびlegacy_compression_methodを確認し、「supported_versions」を使用してバージョンを判断することから始めて、拡張機能を処理する必要があります。 HelloRetryRequestによってClientHelloが変更されない場合、クライアントは「illegal_parameter」アラートでハンドシェイクを中止する必要があります。 クライアントが同じ接続で2番目のHelloRetryRequestを受信した場合（つまり、ClientHelloがHelloRetryRequestへの応答としてそれ自体であった場合）、「unexpected_message」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello. The HelloRetryRequest extensions defined in this specification are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それ以外の場合、クライアントはHelloRetryRequestのすべての拡張機能を処理し、2番目に更新されたClientHelloを送信する必要があります。 この仕様で定義されているHelloRetryRequest拡張機能は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- supported_versions (see Section 4.2.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-supported_versions（セクション4.2.1を参照）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- cookie (see Section 4.2.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-Cookie（セクション4.2.2を参照）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- key_share (see Section 4.2.8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-key_share（セクション4.2.8を参照）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client which receives a cipher suite that was not offered MUST abort the handshake. Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then this will happen automatically). Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
提供されなかった暗号スイートを受信したクライアントは、ハンドシェイクを中止しなければなりません。 サーバーは、適合した更新済みClientHelloを受信するときに、同じ暗号スイートをネゴシエートすることを確認する必要があります（サーバーがネゴシエーションの最初のステップとして暗号スイートを選択した場合、これは自動的に行われます）。 ServerHelloを受信すると、クライアントは、ServerHelloで提供される暗号スイートがHelloRetryRequestの暗号スイートと同じであることを確認する必要があります。そうでなければ、「illegal_parameter」アラートでハンドシェイクを中止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, in its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite. This allows the client to avoid having to compute partial hash transcripts for multiple hashes in the second ClientHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、更新されたClientHelloでは、クライアントは、選択した暗号スイートのハッシュ以外のハッシュに関連付けられた事前共有キーを提供するべきではありません。 これにより、クライアントは2番目のClientHelloで複数のハッシュの部分的なハッシュトランスクリプトを計算する必要がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The value of selected_version in the HelloRetryRequest &#34;supported_versions&#34; extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an &#34;illegal_parameter&#34; alert if the value changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HelloRetryRequest &#34;supported_versions&#34;拡張のselected_versionの値はServerHelloに保持されなければならず、値が変更された場合、クライアントは &#34;illegal_parameter&#34;アラートでハンドシェイクを中止しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。 拡張機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A number of TLS messages contain tag-length-value encoded extensions structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くのTLSメッセージには、タグ長値エンコードされた拡張構造が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        ExtensionType extension_type;
        opaque extension_data&lt;0..2^16-1&gt;;
    } Extension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここに：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- &#34;extension_type&#34; identifies the particular extension type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「extension_type」は、特定の拡張タイプを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- &#34;extension_data&#34; contains information specific to the particular extension type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「extension_data」には、特定の拡張機能タイプに固有の情報が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The list of extension types is maintained by IANA as described in Section 11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション11で説明されるように、拡張タイプのリストはIANAによって維持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response. The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages. The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message. The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張機能は通常、要求/応答形式で構成されますが、一部の拡張機能は、対応する応答のない単なる指標です。 クライアントはClientHelloメッセージで拡張要求を送信し、サーバーはServerHello、EncryptedExtensions、HelloRetryRequest、およびCertificateメッセージで拡張応答を送信します。 サーバーは、CertificateRequestメッセージで拡張要求を送信し、クライアントは証明書メッセージで応答する場合があります。 サーバーは、要求されていない拡張機能をNewSessionTicketで送信することもできますが、クライアントはこれらに直接応答しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the &#34;cookie&#34; extension in the HelloRetryRequest. Upon receiving such an extension, an endpoint MUST abort the handshake with an &#34;unsupported_extension&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リモートエンドポイントが対応する拡張要求を送信しなかった場合、HelloRetryRequestの「cookie」拡張を除き、実装は拡張応答を送信してはなりません。 このような拡張機能を受信すると、エンドポイントは「unsupported_extension」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest). If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の表は、CH（ClientHello）、SH（ServerHello）、EE（EncryptedExtensions）、CT（Certificate）、CR（CertificateRequest）、NST（NewSessionTicket）、およびHRRの表記を使用して、特定の拡張機能が表示される可能性があるメッセージを示しています （HelloRetryRequest）。 実装が認識し、出現するメッセージに指定されていない拡張機能を受け取った場合、「illegal_parameter」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------------------------------------------------+-------------+
   | Extension                                        |     TLS 1.3 |
   +--------------------------------------------------+-------------+
   | server_name [RFC6066]                            |      CH, EE |
   |                                                  |             |
   | max_fragment_length [RFC6066]                    |      CH, EE |
   |                                                  |             |
   | status_request [RFC6066]                         |  CH, CR, CT |
   |                                                  |             |
   | supported_groups [RFC7919]                       |      CH, EE |
   |                                                  |             |
   | signature_algorithms (RFC 8446)                  |      CH, CR |
   |                                                  |             |
   | use_srtp [RFC5764]                               |      CH, EE |
   |                                                  |             |
   | heartbeat [RFC6520]                              |      CH, EE |
   |                                                  |             |
   | application_layer_protocol_negotiation [RFC7301] |      CH, EE |
   |                                                  |             |
   | signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
   |                                                  |             |
   | client_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | server_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | padding [RFC7685]                                |          CH |
   |                                                  |             |
   | key_share (RFC 8446)                             | CH, SH, HRR |
   |                                                  |             |
   | pre_shared_key (RFC 8446)                        |      CH, SH |
   |                                                  |             |
   | psk_key_exchange_modes (RFC 8446)                |          CH |
   |                                                  |             |
   | early_data (RFC 8446)                            | CH, EE, NST |
   |                                                  |             |
   | cookie (RFC 8446)                                |     CH, HRR |
   |                                                  |             |
   | supported_versions (RFC 8446)                    | CH, SH, HRR |
   |                                                  |             |
   | certificate_authorities (RFC 8446)               |      CH, CR |
   |                                                  |             |
   | oid_filters (RFC 8446)                           |          CR |
   |                                                  |             |
   | post_handshake_auth (RFC 8446)                   |          CH |
   |                                                  |             |
   | signature_algorithms_cert (RFC 8446)             |      CH, CR |
   +--------------------------------------------------+-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of &#34;pre_shared_key&#34; (Section 4.2.11) which MUST be the last extension in the ClientHello (but can appear anywhere in the ServerHello extensions block). There MUST NOT be more than one extension of the same type in a given extension block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
異なるタイプの複数の拡張機能が存在する場合、ClientHelloの最後の拡張機能である必要がある「pre_shared_key」（セクション4.2.11）を除き、拡張機能は任意の順序で表示できます（ただし、ServerHello拡張機能ブロックのどこにでも表示できます） 。 特定の拡張ブロックに同じタイプの拡張が複数あってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each handshake even when in resumption-PSK mode. However, 0-RTT parameters are those negotiated in the previous handshake; mismatches may require rejecting 0-RTT (see Section 4.2.10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.2とは異なり、TLS 1.3では、再開PSKモードであっても、ハンドシェイクごとに拡張機能がネゴシエートされます。 ただし、0-RTTパラメーターは、前のハンドシェイクでネゴシエートされたパラメーターです。 不一致の場合、0-RTTの拒否が必要になる場合があります（セクション4.2.10を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are subtle (and not so subtle) interactions that may occur in this protocol between new features and existing features which may result in a significant reduction in overall security. The following considerations should be taken into account when designing new extensions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このプロトコルでは、新しい機能と既存の機能の間で微妙な（それほど微妙ではない）相互作用が発生し、全体的なセキュリティが大幅に低下する可能性があります。 新しい拡張機能を設計するときは、次の考慮事項を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Some cases where a server does not agree to an extension are error conditions (e.g., the handshake cannot continue), and some are simply refusals to support particular features. In general, error alerts should be used for the former and a field in the server extension response for the latter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サーバーが拡張機能に同意しない場合はエラー状態（例：ハンドシェイクを継続できない）であり、特定の機能をサポートするための単なる拒否です。 一般に、前者にはエラーアラートを使用し、後者にはサーバーエクステンションレスポンスのフィールドを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Extensions should, as far as possible, be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages. This principle should be followed regardless of whether the feature is believed to cause a security problem. Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase. Designers and implementors should be aware of the fact that until the handshake has been authenticated, active attackers can modify messages and insert, remove, or replace extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-拡張機能は、可能な限り、ハンドシェイクメッセージの操作によって特定の機能の使用（または不使用）を強制する攻撃を防ぐように設計する必要があります。 機能がセキュリティ問題を引き起こすと考えられるかどうかに関係なく、この原則に従う必要があります。 多くの場合、拡張フィールドがFinishedメッセージハッシュへの入力に含まれているという事実で十分ですが、拡張機能がハンドシェイクフェーズで送信されるメッセージの意味を変更する場合は細心の注意が必要です。 設計者と実装者は、ハンドシェイクが認証されるまで、アクティブな攻撃者がメッセージを変更し、拡張機能を挿入、削除、または置換できるという事実を認識する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Supported Versions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1。 サポートされているバージョン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions&lt;2..254&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;supported_versions&#34; extension is used by the client to indicate which versions of TLS it supports and by the server to indicate which version it is using. The extension contains a list of supported versions in preference order, with the most preferred version first. Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which they are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, they MUST be present as well).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「supported_versions」拡張機能は、クライアントがサポートするTLSのバージョンを示すために、サーバーが使用しているバージョンを示すために使用されます。 拡張機能には、サポートされているバージョンのリストが優先順に含まれており、最も優先されるバージョンが最初になります。 この仕様の実装は、ネゴシエートする準備ができているすべてのバージョンのTLSを含むClientHelloでこの拡張機能を送信する必要があります（この仕様では、少なくとも0x0304を意味しますが、TLSの以前のバージョンがネゴシエートできる場合、それらも存在しなければなりません（MUST） ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later. Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この拡張が存在しない場合、ClientHello.legacy_versionが0x0304以降であっても、この仕様に準拠し、TLS 1.2もサポートするサーバーは、[RFC5246]で指定されているTLS 1.2以前をネゴシエートしなければなりません。 サーバーは、legacy_version 0x0304以降でClientHelloを受信すると、ハンドシェイクを中止できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the &#34;supported_versions&#34; extension to determine client preferences. Servers MUST only select a version of TLS present in that extension and MUST ignore any unknown versions that are present in that extension. Note that this mechanism makes it possible to negotiate a version prior to TLS 1.2 if one side supports a sparse range. Implementations of TLS 1.3 which choose to support prior versions of TLS SHOULD support TLS 1.2. Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この拡張がClientHelloに存在する場合、サーバーはバージョンネゴシエーションにClientHello.legacy_version値を使用してはならず、「supported_versions」拡張のみを使用してクライアントの設定を決定する必要があります。 サーバーは、その拡張機能に存在するTLSのバージョンのみを選択する必要があり、その拡張機能に存在する不明なバージョンは無視する必要があります。 このメカニズムにより、一方がスパース範囲をサポートしている場合、TLS 1.2より前のバージョンをネゴシエートできることに注意してください。 TLSの以前のバージョンをサポートすることを選択するTLS 1.3の実装は、TLS 1.2をサポートする必要があります。 サーバーは、この拡張子を含むClientHellosを受信する準備ができていなければなりませんが、バージョンのリストに0x0304は含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the &#34;supported_versions&#34; extension. A server which negotiates TLS 1.3 MUST respond by sending a &#34;supported_versions&#34; extension containing the selected version value (0x0304). It MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2). Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to parse the ServerHello in order to read the extension). If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the &#34;supported_versions&#34; extension to determine the selected version. If the &#34;supported_versions&#34; extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3より前のバージョンのTLSをネゴシエートするサーバーは、ServerHello.versionを設定する必要があり、「supported_versions」拡張を送信してはなりません。 TLS 1.3をネゴシエートするサーバーは、選択されたバージョン値（0x0304）を含む「supported_versions」拡張機能を送信することによって応答する必要があります。 ServerHello.legacy_versionフィールドを0x0303（TLS 1.2）に設定する必要があります。 クライアントは、ServerHelloの残りを処理する前にこの拡張機能を確認する必要があります（ただし、拡張機能を読み取るにはServerHelloを解析する必要があります）。 この拡張機能が存在する場合、クライアントはServerHello.legacy_version値を無視する必要があり、「supported_versions」拡張機能のみを使用して選択したバージョンを決定する必要があります。 ServerHelloの「supported_versions」拡張機能にクライアントが提供していないバージョンが含まれているか、TLS 1.3より前のバージョンが含まれている場合、クライアントは「illegal_parameter」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Cookie
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2。 クッキー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque cookie&lt;1..2^16-1&gt;;
      } Cookie;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cookies serve two primary purposes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cookieは、主に2つの目的に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Allowing the server to force the client to demonstrate reachability at their apparent network address (thus providing a measure of DoS protection). This is primarily useful for non-connection-oriented transports (see [RFC6347] for an example of this).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サーバーがクライアントに見かけのネットワークアドレスでの到達可能性を強制することを許可する（したがって、DoS保護の手段を提供する）。 これは主に非接続指向のトランスポートに役立ちます（この例については[RFC6347]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Allowing the server to offload state to the client, thus allowing it to send a HelloRetryRequest without storing any state. The server can do this by storing the hash of the ClientHello in the HelloRetryRequest cookie (protected with some suitable integrity protection algorithm).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サーバーがクライアントに状態をオフロードできるようにするため、状態を保存せずにHelloRetryRequestを送信できます。 サーバーは、ClientHelloのハッシュをHelloRetryRequest Cookie（適切な整合性保護アルゴリズムで保護されている）に保存することでこれを実行できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When sending a HelloRetryRequest, the server MAY provide a &#34;cookie&#34; extension to the client (this is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello). When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a &#34;cookie&#34; extension in the new ClientHello. Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HelloRetryRequestを送信するとき、サーバーはクライアントに「cookie」拡張機能を提供することができます（これは、送信される可能性がある拡張機能はClientHelloに表示される拡張機能のみであるという通常の規則の例外です）。 新しいClientHelloを送信するとき、クライアントは、HelloRetryRequestで受信した拡張機能の内容を、新しいClientHelloの「cookie」拡張機能にコピーする必要があります。 クライアントは、後続の接続で最初のClientHelloでCookieを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5). Since the server is not storing any state, this will appear as if it were the first message to be received. Servers operating statelessly MUST ignore these records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーがステートレスに動作している場合、最初と2番目のClientHelloの間でchange_cipher_spec型の保護されていないレコードを受信する場合があります（セクション5を参照）。 サーバーは状態を保存していないため、これが最初に受信されるメッセージであるかのように表示されます。 ステートレスに動作するサーバーはこれらのレコードを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. Signature Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3。 署名アルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures. The &#34;signature_algorithms_cert&#34; extension applies to signatures in certificates, and the &#34;signature_algorithms&#34; extension, which originally appeared in TLS 1.2, applies to signatures in CertificateVerify messages. The keys found in certificates MUST also be of appropriate type for the signature algorithms they are used with. This is a particular issue for RSA keys and PSS signatures, as described below. If no &#34;signature_algorithms_cert&#34; extension is present, then the &#34;signature_algorithms&#34; extension also applies to signatures appearing in certificates. Clients which desire the server to authenticate itself via a certificate MUST send the &#34;signature_algorithms&#34; extension. If a server is authenticating via a certificate and the client has not sent a &#34;signature_algorithms&#34; extension, then the server MUST abort the handshake with a &#34;missing_extension&#34; alert (see Section 9.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3は、デジタル署名で使用できる署名アルゴリズムを示す2つの拡張機能を提供します。 「signature_algorithms_cert」拡張機能は証明書の署名に適用され、TLS 1.2で最初に登場した「signature_algorithms」拡張機能は、CertificateVerifyメッセージの署名に適用されます。 証明書で見つかったキーは、使用される署名アルゴリズムに適したタイプでなければなりません。 これは、以下で説明するように、RSAキーとPSS署名の特定の問題です。 「signature_algorithms_cert」拡張機能が存在しない場合、「signature_algorithms」拡張機能は、証明書に表示される署名にも適用されます。 サーバーが証明書を介して自身を認証することを望むクライアントは、「signature_algorithms」拡張を送信しなければなりません。 サーバーが証明書を介して認証を行い、クライアントが「signature_algorithms」拡張を送信していない場合、サーバーは「missing_extension」アラートでハンドシェイクを中止しなければなりません（セクション9.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;signature_algorithms_cert&#34; extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities. TLS 1.2 implementations SHOULD also process this extension. Implementations which have the same policy in both cases MAY omit the &#34;signature_algorithms_cert&#34; extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「signature_algorithms_cert」拡張機能が追加され、証明書およびTLS自体のさまざまなアルゴリズムのセットをサポートする実装がその機能を明確に通知できるようになりました。 TLS 1.2実装は、この拡張機能も処理する必要があります。 どちらの場合も同じポリシーを持つ実装では、「signature_algorithms_cert」拡張機能を省略できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;extension_data&#34; field of these extensions contains a SignatureSchemeList value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの拡張機能の「extension_data」フィールドには、SignatureSchemeList値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* Reserved Code Points */
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          SignatureScheme supported_signature_algorithms&lt;2..2^16-2&gt;;
      } SignatureSchemeList;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: This enum is named &#34;SignatureScheme&#34; because there is already a &#34;SignatureAlgorithm&#34; type in TLS 1.2, which this replaces. We use the term &#34;signature algorithm&#34; throughout the text.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：この列挙型の名前は「SignatureScheme」です。これは、TLS 1.2に「SignatureAlgorithm」タイプが既に存在するためです。 テキスト全体で「署名アルゴリズム」という用語を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each SignatureScheme value lists a single signature algorithm that the client is willing to verify. The values are indicated in descending order of preference. Note that a signature algorithm takes as input an arbitrary-length message, rather than a digest. Algorithms which traditionally act on a digest should be defined in TLS to first hash the input with a specified hash algorithm and then proceed as usual. The code point groups listed above have the following meanings:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各SignatureScheme値には、クライアントが検証を希望する単一の署名アルゴリズムがリストされます。 値は優先順位の降順で示されます。 署名アルゴリズムは、ダイジェストではなく、任意の長さのメッセージを入力として使用することに注意してください。 従来はダイジェストに作用するアルゴリズムをTLSで定義して、指定されたハッシュアルゴリズムで最初に入力をハッシュしてから、通常どおりに続行する必要があります。 上記のコードポイントグループには、次の意味があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSASSA-PKCS1-v1_5 algorithms: Indicates a signature algorithm using RSASSA-PKCS1-v1_5 [RFC8017] with the corresponding hash algorithm as defined in [SHS]. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in &#34;signature_algorithms&#34; and &#34;signature_algorithms_cert&#34; for backward compatibility with TLS 1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSASSA-PKCS1-v1_5アルゴリズム：[SASS]で定義された対応するハッシュアルゴリズムとともにRSASSA-PKCS1-v1_5 [RFC8017]を使用する署名アルゴリズムを示します。 これらの値は、証明書（セクション4.4.2.2を参照）に現れる署名のみを参照し、TLS 1.2との後方互換性のために「signature_algorithms」および「signature_algorithms_cert」に現れる場合がありますが、署名付きTLSハンドシェイクメッセージで使用するために定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ECDSA algorithms: Indicates a signature algorithm using ECDSA [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA] and FIPS 186-4 [DSS], and the corresponding hash algorithm as defined in [SHS]. The signature is represented as a DER-encoded [X690] ECDSA-Sig-Value structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ECDSAアルゴリズム：ECDSA [ECDSA]、ANSI X9.62 [ECDSA]およびFIPS 186-4 [DSS]で定義された対応する曲線、および[SHS]で定義された対応するハッシュアルゴリズムを使用した署名アルゴリズムを示します。 署名は、DERエンコード[X690] ECDSA-Sig-Value構造として表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSASSA-PSS RSAE algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the output of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the rsaEncryption OID [RFC5280].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSASSA-PSS RSAEアルゴリズム：マスク生成機能1でRSASSA-PSS [RFC8017]を使用する署名アルゴリズムを示します。マスク生成機能で使用されるダイジェストと署名されるダイジェストは、両方とも[SHS]で定義された対応するハッシュアルゴリズムです。 ソルトの長さは、ダイジェストアルゴリズムの出力の長さと等しくなければなりません。 公開鍵がX.509証明書で運ばれる場合、rsaEncryption OID [RFC5280]を使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EdDSA algorithms: Indicates a signature algorithm using EdDSA as defined in [RFC8032] or its successors. Note that these correspond to the &#34;PureEdDSA&#34; algorithms and not the &#34;prehash&#34; variants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
EdDSAアルゴリズム：[RFC8032]で定義されているEdDSAを使用した署名アルゴリズムまたはその後継を示します。 これらは「prehash」バリアントではなく、「PureEdDSA」アルゴリズムに対応していることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSASSA-PSS PSS algorithms: Indicates a signature algorithm using RSASSA-PSS [RFC8017] with mask generation function 1. The digest used in the mask generation function and the digest being signed are both the corresponding hash algorithm as defined in [SHS]. The length of the Salt MUST be equal to the length of the digest algorithm. If the public key is carried in an X.509 certificate, it MUST use the RSASSA-PSS OID [RFC5756]. When used in certificate signatures, the algorithm parameters MUST be DER encoded. If the corresponding public key&#39;s parameters are present, then the parameters in the signature MUST be identical to those in the public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSASSA-PSS PSSアルゴリズム：RSASSA-PSS [RFC8017]とマスク生成機能1を使用した署名アルゴリズムを示します。マスク生成機能で使用されるダイジェストと署名されるダイジェストは、両方とも[SHS]で定義された対応するハッシュアルゴリズムです。 ソルトの長さは、ダイジェストアルゴリズムの長さと等しくなければなりません。 公開鍵がX.509証明書で運ばれる場合、RSASSA-PSS OID [RFC5756]を使用しなければなりません。 証明書の署名で使用する場合、アルゴリズムパラメータはDERエンコードする必要があります。 対応する公開鍵のパラメータが存在する場合、署名のパラメータは公開鍵のパラメータと同一でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Legacy algorithms: Indicates algorithms which are being deprecated because they use algorithms with known weaknesses, specifically SHA-1 which is used in this context with either (1) RSA using RSASSA-PKCS1-v1_5 or (2) ECDSA. These values refer solely to signatures which appear in certificates (see Section 4.4.2.2) and are not defined for use in signed TLS handshake messages, although they MAY appear in &#34;signature_algorithms&#34; and &#34;signature_algorithms_cert&#34; for backward compatibility with TLS 1.2. Endpoints SHOULD NOT negotiate these algorithms but are permitted to do so solely for backward compatibility. Clients offering these values MUST list them as the lowest priority (listed after all other algorithms in SignatureSchemeList). TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レガシーアルゴリズム：既知の脆弱性を持つアルゴリズム、具体的には（1）RSASSA-PKCS1-v1_5を使用するRSAまたは（2）ECDSAでこのコンテキストで使用されるSHA-1を使用するため、非推奨のアルゴリズムを示します。 これらの値は、証明書（セクション4.4.2.2を参照）に現れる署名のみを参照し、TLS 1.2との後方互換性のために「signature_algorithms」および「signature_algorithms_cert」に現れる場合がありますが、署名付きTLSハンドシェイクメッセージで使用するために定義されていません。 エンドポイントはこれらのアルゴリズムをネゴシエートするべきではありませんが、下位互換性のためだけにネゴシエートすることが許可されています。 これらの値を提供するクライアントは、それらを最も低い優先度（SignatureSchemeListの他のすべてのアルゴリズムの後にリストされる）としてリストしなければなりません。 TLS 1.3サーバーは、有効な証明書チェーンが作成されない限り、SHA-1署名付き証明書を提供してはなりません（セクション4.4.2.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path (see [RFC5280], Section 3.2). A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the &#34;signature_algorithms&#34; extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
自己署名証明書またはトラストアンカー証明書の署名は、証明書パスを開始するため、検証されません（[RFC5280]、セクション3.2を参照）。 証明書パスを開始する証明書は、「signature_algorithms」拡張機能でサポートされているとしてアドバタイズされていない署名アルゴリズムを使用する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that TLS 1.2 defines this extension differently. TLS 1.3 implementations willing to negotiate TLS 1.2 MUST behave in accordance with the requirements of [RFC5246] when negotiating that version. In particular:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.2はこの拡張を異なる方法で定義することに注意してください。 TLS 1.2をネゴシエートする意思のあるTLS 1.3実装は、そのバージョンをネゴシエートするときに[RFC5246]の要件に従って動作する必要があります。 特に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- TLS 1.2 ClientHellos MAY omit this extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLS 1.2 ClientHellosは、この拡張機能を省略できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- In TLS 1.2, the extension contained hash/signature pairs. The pairs are encoded in two octets, so SignatureScheme values have been allocated to align with TLS 1.2&#39;s encoding. Some legacy pairs are left unallocated. These algorithms are deprecated as of TLS 1.3. They MUST NOT be offered or negotiated by any implementation. In particular, MD5 [SLOTH], SHA-224, and DSA MUST NOT be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLS 1.2では、拡張機能にハッシュ/署名のペアが含まれていました。 ペアは2オクテットでエンコードされるため、SignatureScheme値はTLS 1.2のエンコードに合わせて割り当てられています。 一部のレガシーペアは未割り当てのままです。 これらのアルゴリズムは、TLS 1.3で非推奨になりました。 実装によって提供または交渉してはなりません。 特に、MD5 [SLOTH]、SHA-224、およびDSAは使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- ECDSA signature schemes align with TLS 1.2&#39;s ECDSA hash/signature pairs. However, the old semantics did not constrain the signing curve. If TLS 1.2 is negotiated, implementations MUST be prepared to accept a signature that uses any curve that they advertised in the &#34;supported_groups&#34; extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-ECDSA署名スキームは、TLS 1.2のECDSAハッシュ/署名のペアと一致します。 ただし、古いセマンティクスは署名曲線を制約しませんでした。 TLS 1.2がネゴシエートされる場合、「supported_groups」拡張でアドバタイズした曲線を使用する署名を受け入れるように実装を準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Implementations that advertise support for RSASSA-PSS (which is mandatory in TLS 1.3) MUST be prepared to accept a signature using that scheme even when TLS 1.2 is negotiated. In TLS 1.2, RSASSA-PSS is used with RSA cipher suites.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-RSASSA-PSS（TLS 1.3では必須です）のサポートをアドバタイズする実装は、TLS 1.2がネゴシエートされる場合でも、そのスキームを使用して署名を受け入れるように準備する必要があります。 TLS 1.2では、RSASA暗号スイートでRSASSA-PSSが使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4. Certificate Authorities
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.4。 認証局
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;certificate_authorities&#34; extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「certificate_authorities」拡張は、エンドポイントがサポートする認証局（CA）を示すために使用され、証明書の選択をガイドするために受信エンドポイントによって使用される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The body of the &#34;certificate_authorities&#34; extension consists of a CertificateAuthoritiesExtension structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「certificate_authorities」拡張の本体は、CertificateAuthoritiesExtension構造で構成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque DistinguishedName&lt;1..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque DistinguishedName &lt;1..2 ^ 16-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          DistinguishedName authorities&lt;3..2^16-1&gt;;
      } CertificateAuthoritiesExtension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
authorities: A list of the distinguished names [X501] of acceptable certificate authorities, represented in DER-encoded [X690] format. These distinguished names specify a desired distinguished name for a trust anchor or subordinate CA; thus, this message can be used to describe known trust anchors as well as a desired authorization space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
機関：DERエンコード[X690]形式で表される、受け入れ可能な認証機関の識別名[X501]のリスト。 これらの識別名は、トラストアンカーまたは下位CAに必要な識別名を指定します。 したがって、このメッセージを使用して、既知のトラストアンカーと目的の承認スペースを説明できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client MAY send the &#34;certificate_authorities&#34; extension in the ClientHello message. The server MAY send it in the CertificateRequest message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、ClientHelloメッセージで「certificate_authorities」拡張機能を送信する場合があります。 サーバーは、それをCertificateRequestメッセージで送信する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;trusted_ca_keys&#34; extension [RFC6066], which serves a similar purpose but is more complicated, is not used in TLS 1.3 (although it may appear in ClientHello messages from clients which are offering prior versions of TLS).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「trusted_ca_keys」拡張機能[RFC6066]は、同様の目的を果たしますが、より複雑ですが、TLS 1.3では使用されません（以前のバージョンのTLSを提供しているクライアントからのClientHelloメッセージに表示される場合があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.5. OID Filters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.5。 OIDフィルター
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;oid_filters&#34; extension allows servers to provide a set of OID/value pairs which it would like the client&#39;s certificate to match. This extension, if provided by the server, MUST only be sent in the CertificateRequest message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「oid_filters」拡張機能を使用すると、サーバーは、クライアントの証明書と一致させる一連のOID /値ペアを提供できます。 この拡張機能は、サーバーによって提供される場合、CertificateRequestメッセージでのみ送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque certificate_extension_oid&lt;1..2^8-1&gt;;
          opaque certificate_extension_values&lt;0..2^16-1&gt;;
      } OIDFilter;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          OIDFilter filters&lt;0..2^16-1&gt;;
      } OIDFilterExtension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
filters: A list of certificate extension OIDs [RFC5280] with their allowed value(s) and represented in DER-encoded [X690] format. Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage). If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes. For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well). However, the client MUST ignore and skip any unrecognized certificate extension OIDs. If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an &#34;unsupported_certificate&#34; alert. Any given OID MUST NOT appear more than once in the filters list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィルター：証明書拡張OID [RFC5280]とその許容値のリストで、DERエンコード[X690]形式で表されます。一部の証明書拡張OIDでは、複数の値が許可されています（例：拡張キー使用法）。サーバーに空でないフィルターリストが含まれている場合、応答に含まれるクライアント証明書には、クライアントが認識する指定された拡張OIDがすべて含まれている必要があります。クライアントによって認識される各拡張OIDについて、指定されたすべての値がクライアント証明書に存在する必要があります（ただし、証明書には他の値もある場合があります）。ただし、クライアントは、認識されていない証明書拡張OIDを無視してスキップする必要があります。クライアントが必要な証明書拡張OIDの一部を無視し、要求を満たさない証明書を提供した場合、サーバーはその裁量でクライアント認証なしで接続を続行するか、「unsupported_certificate」アラートでハンドシェイクを中止できます。指定されたOIDは、フィルターリストに複数回表示してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types. Depending on the type, matching certificate extension values are not necessarily bitwise-equal. It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PKIX RFCは、さまざまな証明書拡張OIDとそれに対応する値タイプを定義します。 タイプによっては、一致する証明書拡張値は必ずしもビットごとに等しいとは限りません。 TLS実装は、証明書拡張OIDを使用して証明書選択を実行するためにPKIライブラリに依存することが予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines matching rules for two standard certificate extensions defined in [RFC5280]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは、[RFC5280]で定義された2つの標準証明書拡張のマッチングルールを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-要求でアサートされたすべてのキー使用ビットがキー使用証明書拡張でもアサートされている場合、証明書のキー使用拡張はリクエストと一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension. The special anyExtendedKeyUsage OID MUST NOT be used in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-証明書内の拡張キー使用法拡張機能は、要求に含まれるすべてのキー目的OIDが拡張キー使用法証明書拡張機能でも見つかった場合、要求と一致します。 特別なanyExtendedKeyUsage OIDをリクエストで使用してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Separate specifications may define matching rules for other certificate extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別の仕様では、他の証明書拡張機能のマッチングルールを定義できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.6. Post-Handshake Client Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.6。 ハンドシェイク後のクライアント認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;post_handshake_auth&#34; extension is used to indicate that a client is willing to perform post-handshake authentication (Section 4.6.2). Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension. Servers MUST NOT send this extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「post_handshake_auth」拡張機能は、クライアントがポストハンドシェイク認証を実行する意思があることを示すために使用されます（セクション4.6.2）。 サーバーは、この拡張機能を提供しないクライアントにハンドシェイク後のCertificateRequestを送信してはなりません。 サーバーはこの拡張機能を送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {} PostHandshakeAuth;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {} PostHandshakeAuth;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;extension_data&#34; field of the &#34;post_handshake_auth&#34; extension is zero length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「post_handshake_auth」拡張機能の「extension_data」フィールドの長さはゼロです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.7. Supported Groups
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.7。 サポートされているグループ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When sent by the client, the &#34;supported_groups&#34; extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントによって送信される場合、「supported_groups」拡張機能は、クライアントがキー交換のためにサポートする名前付きグループを、最も優先度の高いものから最も優先度の低いものの順に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: In versions of TLS prior to TLS 1.3, this extension was named &#34;elliptic_curves&#34; and only contained elliptic curve groups. See [RFC8422] and [RFC7919]. This extension was also used to negotiate ECDSA curves. Signature algorithms are now negotiated independently (see Section 4.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：TLS 1.3より前のTLSのバージョンでは、この拡張機能は「elliptic_curves」という名前で、楕円曲線グループのみが含まれていました。 [RFC8422]および[RFC7919]を参照してください。 この拡張は、ECDSA曲線のネゴシエートにも使用されました。 署名アルゴリズムは、個別にネゴシエートされるようになりました（セクション4.2.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;extension_data&#34; field of this extension contains a &#34;NamedGroupList&#34; value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この拡張機能の「extension_data」フィールドには、「NamedGroupList」値が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum {
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* Elliptic Curve Groups (ECDHE) */
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          x25519(0x001D), x448(0x001E),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          (0xFFFF)
      } NamedGroup;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          NamedGroup named_group_list&lt;2..2^16-1&gt;;
      } NamedGroupList;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Elliptic Curve Groups (ECDHE): Indicates support for the corresponding named curve, defined in either FIPS 186-4 [DSS] or [RFC7748]. Values 0xFE00 through 0xFEFF are reserved for Private Use [RFC8126].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
楕円曲線グループ（ECDHE）：FIPS 186-4 [DSS]または[RFC7748]で定義されている、対応する名前付き曲線のサポートを示します。 値0xFE00〜0xFEFFは、プライベート使用のために予約されています[RFC8126]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finite Field Groups (DHE): Indicates support for the corresponding finite field group, defined in [RFC7919]. Values 0x01FC through 0x01FF are reserved for Private Use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
有限フィールドグループ（DHE）：[RFC7919]で定義されている、対応する有限フィールドグループのサポートを示します。 値0x01FCから0x01FFは、プライベート使用のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Items in named_group_list are ordered according to the sender&#39;s preferences (most preferred choice first).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
named_group_listの項目は、送信者の設定に従って順序付けられます（最も優先される選択肢が最初）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As of TLS 1.3, servers are permitted to send the &#34;supported_groups&#34; extension to the client. Clients MUST NOT act upon any information found in &#34;supported_groups&#34; prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their &#34;key_share&#34; extension in subsequent connections. If the server has a group it prefers to the ones in the &#34;key_share&#34; extension but is still willing to accept the ClientHello, it SHOULD send &#34;supported_groups&#34; to update the client&#39;s view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3以降、サーバーは「supported_groups」拡張機能をクライアントに送信できます。 クライアントは、ハンドシェイクが正常に完了する前に「supported_groups」で見つかった情報に基づいて行動してはなりませんが、正常に完了したハンドシェイクから学習した情報を使用して、後続の接続の「key_share」拡張で使用するグループを変更することができます。 サーバーに「key_share」拡張子のグループよりも優先されるが、ClientHelloを受け入れる意思があるグループがある場合、「supported_groups」を送信してクライアントの設定のビューを更新する必要があります。 この拡張は、クライアントが現在サポートしているかどうかにかかわらず、サーバーがサポートするすべてのグループを含む必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.8. Key Share
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.8。 キーシェア
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;key_share&#34; extension contains the endpoint&#39;s cryptographic parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「key_share」拡張には、エンドポイントの暗号化パラメーターが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients MAY send an empty client_shares vector in order to request group selection from the server, at the cost of an additional round trip (see Section 4.1.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、追加の往復の費用で、サーバーからのグループ選択を要求するために空のclient_sharesベクトルを送信することができます（セクション4.1.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          NamedGroup group;
          opaque key_exchange&lt;1..2^16-1&gt;;
      } KeyShareEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
group: The named group for the key being exchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
group：交換されるキーの名前付きグループ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
key_exchange: Key exchange information. The contents of this field are determined by the specified group and its corresponding definition. Finite Field Diffie-Hellman [DH76] parameters are described in Section 4.2.8.1; Elliptic Curve Diffie-Hellman parameters are described in Section 4.2.8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
key_exchange：鍵交換情報。 このフィールドの内容は、指定されたグループとそれに対応する定義によって決定されます。 有限フィールドDiffie-Hellman [DH76]パラメータについては、セクション4.2.8.1で説明しています。 楕円曲線Diffie-Hellmanパラメーターについては、セクション4.2.8.2で説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the ClientHello message, the &#34;extension_data&#34; field of this extension contains a &#34;KeyShareClientHello&#34; value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientHelloメッセージでは、この拡張機能の「extension_data」フィールドに「KeyShareClientHello」値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          KeyShareEntry client_shares&lt;0..2^16-1&gt;;
      } KeyShareClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
client_shares: A list of offered KeyShareEntry values in descending order of client preference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
client_shares：クライアント設定の降順で提供されるKeyShareEntry値のリスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This vector MAY be empty if the client is requesting a HelloRetryRequest. Each KeyShareEntry value MUST correspond to a group offered in the &#34;supported_groups&#34; extension and MUST appear in the same order. However, the values MAY be a non-contiguous subset of the &#34;supported_groups&#34; extension and MAY omit the most preferred groups. Such a situation could arise if the most preferred groups are new and unlikely to be supported in enough places to make pregenerating key shares for them efficient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがHelloRetryRequestを要求している場合、このベクトルは空の場合があります。 各KeyShareEntry値は、「supported_groups」拡張で提供されるグループに対応しなければならず、同じ順序で表示されなければなりません。 ただし、値は「supported_groups」拡張の不連続なサブセットである場合があり、最も優先されるグループを省略する場合があります。 そのような状況は、最も優先されるグループが新しく、それらのキー共有を効率的に事前生成するのに十分な場所でサポートされる可能性が低い場合に発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients can offer as many KeyShareEntry values as the number of supported groups it is offering, each representing a single set of key exchange parameters. For instance, a client might offer shares for several elliptic curves or multiple FFDHE groups. The key_exchange values for each KeyShareEntry MUST be generated independently. Clients MUST NOT offer multiple KeyShareEntry values for the same group. Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client&#39;s &#34;supported_groups&#34; extension. Servers MAY check for violations of these rules and abort the handshake with an &#34;illegal_parameter&#34; alert if one is violated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、提供するサポートされているグループの数と同じ数のKeyShareEntry値を提供できます。各値は、鍵交換パラメーターの単一セットを表します。 たとえば、クライアントは複数の楕円曲線または複数のFFDHEグループの共有を提供する場合があります。 各KeyShareEntryのkey_exchange値は、個別に生成する必要があります。 クライアントは、同じグループに対して複数のKeyShareEntry値を提供してはなりません。 クライアントは、クライアントの「supported_groups」拡張にリストされていないグループにKeyShareEntry値を提供してはなりません。 サーバーは、これらのルールの違反をチェックし、違反がある場合は「illegal_parameter」アラートでハンドシェイクを中止できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In a HelloRetryRequest message, the &#34;extension_data&#34; field of this extension contains a KeyShareHelloRetryRequest value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HelloRetryRequestメッセージでは、この拡張機能の「extension_data」フィールドにKeyShareHelloRetryRequest値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          NamedGroup selected_group;
      } KeyShareHelloRetryRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
selected_group: The mutually supported group the server intends to negotiate and is requesting a retried ClientHello/KeyShare for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
selected_group：サーバーがネゴシエートしようとし、再試行されたClientHello / KeyShareを要求している相互にサポートされているグループ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon receipt of this extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group which was provided in the &#34;supported_groups&#34; extension in the original ClientHello and (2) the selected_group field does not correspond to a group which was provided in the &#34;key_share&#34; extension in the original ClientHello. If either of these checks fails, then the client MUST abort the handshake with an &#34;illegal_parameter&#34; alert. Otherwise, when sending the new ClientHello, the client MUST replace the original &#34;key_share&#34; extension with one containing only a new KeyShareEntry for the group indicated in the selected_group field of the triggering HelloRetryRequest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HelloRetryRequestでこの拡張を受信すると、クライアントは、（1）selected_groupフィールドが元のClientHelloの「supported_groups」拡張で提供されたグループに対応し、（2）selected_groupフィールドがグループに対応しないことを確認する必要があります これは、元のClientHelloの「key_share」拡張機能で提供されていました。 これらのチェックのいずれかが失敗した場合、クライアントは「illegal_parameter」アラートでハンドシェイクを中止する必要があります。 それ以外の場合、新しいClientHelloを送信するとき、クライアントは、元の「key_share」拡張を、トリガーHelloRetryRequestのselected_groupフィールドに示されたグループの新しいKeyShareEntryのみを含むものに置き換えなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In a ServerHello message, the &#34;extension_data&#34; field of this extension contains a KeyShareServerHello value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ServerHelloメッセージでは、この拡張機能の「extension_data」フィールドにKeyShareServerHello値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          KeyShareEntry server_share;
      } KeyShareServerHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
server_share: A single KeyShareEntry value that is in the same group as one of the client&#39;s shares.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
server_share：クライアントの共有の1つと同じグループにある単一のKeyShareEntry値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If using (EC)DHE key establishment, servers offer exactly one KeyShareEntry in the ServerHello. This value MUST be in the same group as the KeyShareEntry value offered by the client that the server has selected for the negotiated key exchange. Servers MUST NOT send a KeyShareEntry for any group not indicated in the client&#39;s &#34;supported_groups&#34; extension and MUST NOT send a KeyShareEntry when using the &#34;psk_ke&#34; PskKeyExchangeMode. If using (EC)DHE key establishment and a HelloRetryRequest containing a &#34;key_share&#34; extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as that in the HelloRetryRequest. If this check fails, the client MUST abort the handshake with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（EC）DHEキー確立を使用する場合、サーバーはServerHelloでKeyShareEntryを1つだけ提供します。 この値は、サーバーがネゴシエートされたキー交換のために選択したクライアントによって提供されるKeyShareEntry値と同じグループになければなりません。 サーバーは、クライアントの「supported_groups」拡張で示されていないグループに対してKeyShareEntryを送信してはならず、「psk_ke」PskKeyExchangeModeを使用する場合はKeyShareEntryを送信してはなりません。 （EC）DHEキー確立を使用し、クライアントが「key_share」拡張を含むHelloRetryRequestを受信した場合、クライアントは、ServerHelloで選択したNamedGroupがHelloRetryRequestのNamedGroupと同じであることを確認する必要があります。 このチェックが失敗した場合、クライアントは「illegal_parameter」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.8.1. Diffie-Hellman Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.8.1。 Diffie-Hellmanパラメーター
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Diffie-Hellman [DH76] parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure. The opaque value contains the Diffie-Hellman public value (Y = g^X mod p) for the specified group (see [RFC7919] for group definitions) encoded as a big-endian integer and padded to the left with zeros to the size of p in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバーの両方のDiffie-Hellman [DH76]パラメーターは、KeyShare構造のKeyShareEntryの不透明なkey_exchangeフィールドにエンコードされます。 不透明な値には、ビッグエンディアン整数としてエンコードされ、サイズがゼロになるまで左側にゼロが埋め込まれた、指定されたグループ（グループ定義については[RFC7919]を参照）のDiffie-Hellmanパブリック値（Y = g ^ X mod p）が含まれます バイト単位のp。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: For a given Diffie-Hellman group, the padding results in all public keys having the same length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：特定のDiffie-Hellmanグループでは、パディングにより、すべての公開キーの長さが同じになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Peers MUST validate each other&#39;s public key Y by ensuring that 1 &lt; Y &lt; p-1. This check ensures that the remote peer is properly behaved and isn&#39;t forcing the local system into a small subgroup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピアは、1 &lt;Y &lt;p-1であることを確認することにより、互いの公開鍵Yを検証する必要があります。 このチェックにより、リモートピアが適切に動作し、ローカルシステムが小さなサブグループに強制されないことが保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.8.2. ECDHE Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.8.2。 ECDHEパラメーター
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ECDHE parameters for both clients and servers are encoded in the opaque key_exchange field of a KeyShareEntry in a KeyShare structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバーの両方のECDHEパラメーターは、KeyShare構造のKeyShareEntryの不透明なkey_exchangeフィールドでエンコードされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For secp256r1, secp384r1, and secp521r1, the contents are the serialized value of the following struct:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
secp256r1、secp384r1、およびsecp521r1の場合、内容は次の構造体のシリアル化された値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          uint8 legacy_form = 4;
          opaque X[coordinate_length];
          opaque Y[coordinate_length];
      } UncompressedPointRepresentation;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
X and Y, respectively, are the binary representations of the x and y values in network byte order. There are no internal length markers, so each number representation occupies as many octets as implied by the curve parameters. For P-256, this means that each of X and Y use 32 octets, padded on the left by zeros if necessary. For P-384, they take 48 octets each. For P-521, they take 66 octets each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
XとYは、それぞれネットワークバイト順のx値とy値のバイナリ表現です。 内部の長さマーカーはないため、各数値表現は、曲線パラメーターで示されるオクテットと同じ数のオクテットを占有します。 P-256の場合、これはXとYのそれぞれが32オクテットを使用し、必要に応じて左側にゼロが埋め込まれることを意味します。 P-384の場合、それぞれ48オクテットかかります。 P-521の場合、それぞれ66オクテットかかります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the curves secp256r1, secp384r1, and secp521r1, peers MUST validate each other&#39;s public value Q by ensuring that the point is a valid point on the elliptic curve. The appropriate validation procedures are defined in Section 4.3.7 of [ECDSA] and alternatively in Section 5.6.2.3 of [KEYAGREEMENT]. This process consists of three steps: (1) verify that Q is not the point at infinity (O), (2) verify that for Q = (x, y) both integers x and y are in the correct interval, and (3) ensure that (x, y) is a correct solution to the elliptic curve equation. For these curves, implementors do not need to verify membership in the correct subgroup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
曲線secp256r1、secp384r1、およびsecp521r1について、ピアは、ポイントが楕円曲線上の有効なポイントであることを確認することにより、互いのパブリック値Qを検証する必要があります。 適切な検証手順は、[ECDSA]のセクション4.3.7、または[KEYAGREEMENT]のセクション5.6.2.3で定義されています。 このプロセスは、3つのステップで構成されます。（1）Qが無限大（O）でないことを確認し、（2）Q =（x、y）の整数xとyが両方とも正しい間隔にあることを確認し、 ）（x、y）が楕円曲線方程式の正しい解であることを確認してください。 これらの曲線の場合、実装者は正しいサブグループのメンバーシップを確認する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For X25519 and X448, the contents of the public value are the byte string inputs and outputs of the corresponding functions defined in [RFC7748]: 32 bytes for X25519 and 56 bytes for X448.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
X25519およびX448の場合、パブリック値の内容は、[RFC7748]で定義されている対応する関数のバイト文字列入力および出力です。X25519の場合は32バイト、X448の場合は56バイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Versions of TLS prior to 1.3 permitted point format negotiation; TLS 1.3 removes this feature in favor of a single point format for each curve.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：1.3より前のバージョンのTLSでは、ポイント形式のネゴシエーションが許可されていました。 TLS 1.3は、この機能を削除して、各曲線に単一ポイント形式を採用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.9. Pre-Shared Key Exchange Modes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.9。 事前共有キー交換モード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to use PSKs, clients MUST also send a &#34;psk_key_exchange_modes&#34; extension. The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PSKを使用するには、クライアントは「psk_key_exchange_modes」拡張機能も送信する必要があります。 この拡張のセマンティクスは、クライアントがこれらのモードでPSKの使用のみをサポートすることです。これにより、このClientHelloで提供されるPSKと、NewSessionTicketを介してサーバーが提供するPSKの使用が制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client MUST provide a &#34;psk_key_exchange_modes&#34; extension if it offers a &#34;pre_shared_key&#34; extension. If clients offer &#34;pre_shared_key&#34; without a &#34;psk_key_exchange_modes&#34; extension, servers MUST abort the handshake. Servers MUST NOT select a key exchange mode that is not listed by the client. This extension also restricts the modes for use with PSK resumption. Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client&#39;s attempts at resumption fail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、「pre_shared_key」拡張機能を提供する場合、「psk_key_exchange_modes」拡張機能を提供する必要があります。 クライアントが「psk_key_exchange_modes」拡張機能なしで「pre_shared_key」を提供する場合、サーバーはハンドシェイクを中止する必要があります。 サーバーは、クライアントによってリストされていない鍵交換モードを選択してはなりません。 この拡張機能は、PSK再開で使用するモードも制限します。 サーバーは、アドバタイズされたモードと互換性のないチケットでNewSessionTicketを送信すべきではありません。 ただし、サーバーがこれを行うと、クライアントの再開の試みが失敗するという影響があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server MUST NOT send a &#34;psk_key_exchange_modes&#34; extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは「psk_key_exchange_modes」拡張機能を送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum {psk_ke（0）、psk_dhe_ke（1）、（255）} PskKeyExchangeMode;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          PskKeyExchangeMode ke_modes&lt;1..255&gt;;
      } PskKeyExchangeModes;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
psk_ke: PSK-only key establishment. In this mode, the server MUST NOT supply a &#34;key_share&#34; value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
psk_ke：PSKのみのキー確立。 このモードでは、サーバーは「key_share」値を指定してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
psk_dhe_ke: PSK with (EC)DHE key establishment. In this mode, the client and server MUST supply &#34;key_share&#34; values as described in Section 4.2.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
psk_dhe_ke：（EC）DHEキーを確立したPSK。 このモードでは、セクション4.2.8で説明されているように、クライアントとサーバーは「key_share」値を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any future values that are allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; at present, this is indicated by the presence of the &#34;key_share&#34; in the ServerHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
割り当てられる将来の値は、送信されたプロトコルメッセージがサーバーによって選択されたモードを明確に識別することを保証する必要があります。 現在、これはServerHelloの「key_share」の存在によって示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.10. Early Data Indication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.10。 早期データ表示
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a PSK is used and early data is allowed for that PSK, the client can send Application Data in its first flight of messages. If the client opts to do so, it MUST supply both the &#34;pre_shared_key&#34; and &#34;early_data&#34; extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PSKが使用され、そのPSKの初期データが許可されている場合、クライアントはメッセージの最初のフライトでアプリケーションデータを送信できます。 クライアントがそうすることを選択した場合、「pre_shared_key」と「early_data」の両方の拡張機能を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;extension_data&#34; field of this extension contains an &#34;EarlyDataIndication&#34; value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この拡張の「extension_data」フィールドには、「EarlyDataIndication」値が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {} Empty;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {}空;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (Handshake.msg_type) {
              case new_session_ticket:   uint32 max_early_data_size;
              case client_hello:         Empty;
              case encrypted_extensions: Empty;
          };
      } EarlyDataIndication;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See Section 4.6.1 for details regarding the use of the max_early_data_size field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
max_early_data_sizeフィールドの使用に関する詳細については、セクション4.6.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The parameters for the 0-RTT data (version, symmetric cipher suite, Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol, etc.) are those associated with the PSK in use. For externally provisioned PSKs, the associated values are those provisioned along with the key. For PSKs established via a NewSessionTicket message, the associated values are those which were negotiated in the connection which established the PSK. The PSK used to encrypt the early data MUST be the first PSK listed in the client&#39;s &#34;pre_shared_key&#34; extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0-RTTデータのパラメーター（バージョン、対称暗号スイート、アプリケーション層プロトコルネゴシエーション（ALPN）[RFC7301]プロトコルなど）は、使用中のPSKに関連付けられたものです。 外部でプロビジョニングされたPSKの場合、関連付けられている値は、キーとともにプロビジョニングされた値です。 NewSessionTicketメッセージを介して確立されたPSKの場合、関連付けられている値は、PSKを確立した接続でネゴシエートされた値です。 初期データの暗号化に使用されるPSKは、クライアントの「pre_shared_key」拡張機能にリストされている最初のPSKでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8). If it is not, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NewSessionTicket経由でプロビジョニングされたPSKの場合、サーバーは、選択されたPSK IDのチケット経過時間（PskIdentity.obfuscated_ticket_ageモジュロ2 ^ 32からticket_age_addを引いて計算）が、チケットが発行されてからの時間の許容範囲内であることを検証する必要があります（セクション8を参照） ）。 そうでない場合、サーバーはハンドシェイクを続行する必要がありますが、0-RTTを拒否し、このClientHelloが新鮮であると想定する他のアクションを実行するべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
0-RTT messages sent in the first flight have the same (encrypted) content types as messages of the same type sent in other flights (handshake and application_data) but are protected under different keys. After receiving the server&#39;s Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change. This message will be encrypted with the 0-RTT traffic keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のフライトで送信される0-RTTメッセージは、他のフライト（ハンドシェイクおよびapplication_data）で送信される同じタイプのメッセージと同じ（暗号化された）コンテンツタイプを持ちますが、異なるキーで保護されます。 サーバーのFinishedメッセージを受信した後、サーバーが初期データを受け入れた場合、キーの変更を示すEndOfEarlyDataメッセージが送信されます。 このメッセージは、0-RTTトラフィックキーで暗号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server which receives an &#34;early_data&#34; extension MUST behave in one of three ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「early_data」拡張機能を受信するサーバーは、次の3つの方法のいずれかで動作する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Ignore the extension and return a regular 1-RTT response. The server then skips past early data by attempting to deprotect received records using the handshake traffic key, discarding records which fail deprotection (up to the configured max_early_data_size). Once a record is deprotected successfully, it is treated as the start of the client&#39;s second flight and the server proceeds as with an ordinary 1-RTT handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-拡張機能を無視し、通常の1-RTT応答を返します。 サーバーは、ハンドシェイクトラフィックキーを使用して受信したレコードの保護を解除することにより、過去の初期データをスキップし、保護解除に失敗したレコードを破棄します（構成されたmax_early_data_sizeまで）。 レコードの保護が正常に解除されると、クライアントの2番目のフライトの開始として扱われ、サーバーは通常の1-RTTハンドシェイクと同様に処理を進めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Request that the client send another ClientHello by responding with a HelloRetryRequest. A client MUST NOT include the &#34;early_data&#34; extension in its followup ClientHello. The server then ignores early data by skipping all records with an external content type of &#34;application_data&#34; (indicating that they are encrypted), up to the configured max_early_data_size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-HelloRetryRequestで応答することにより、クライアントが別のClientHelloを送信することを要求します。 クライアントは、フォローアップClientHelloに「early_data」拡張子を含めてはなりません。 サーバーは、設定されたmax_early_data_sizeまでの「application_data」（暗号化されていることを示す）の外部コンテンツタイプを持つすべてのレコードをスキップすることにより、初期データを無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Return its own &#34;early_data&#34; extension in EncryptedExtensions, indicating that it intends to process the early data. It is not possible for the server to accept only a subset of the early data messages. Even though the server sends a message accepting early data, the actual early data itself may already be in flight by the time the server generates this message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-EncryptedExtensionsで独自の「early_data」拡張子を返し、初期データを処理するつもりであることを示します。 サーバーが初期データメッセージのサブセットのみを受け入れることはできません。 サーバーは初期データを受け入れるメッセージを送信しますが、実際の初期データ自体は、サーバーがこのメッセージを生成するまでにすでに飛行している場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client&#39;s &#34;pre_shared_key&#34; extension. In addition, it MUST verify that the following values are the same as those associated with the selected PSK:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
初期データを受け入れるために、サーバーはPSK暗号スイートを受け入れ、クライアントの「pre_shared_key」拡張機能で提供される最初のキーを選択する必要があります。 さらに、次の値が選択したPSKに関連付けられている値と同じであることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The TLS version number
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLSバージョン番号
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The selected cipher suite
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-選択された暗号スイート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The selected ALPN [RFC7301] protocol, if any
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-選択したALPN [RFC7301]プロトコル（ある場合）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These requirements are a superset of those needed to perform a 1-RTT handshake using the PSK in question. For externally established PSKs, the associated values are those provisioned along with the key. For PSKs established via a NewSessionTicket message, the associated values are those negotiated in the connection during which the ticket was established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの要件は、問題のPSKを使用して1-RTTハンドシェイクを実行するために必要な要件のスーパーセットです。 外部で確立されたPSKの場合、関連付けられている値は、キーとともにプロビジョニングされた値です。 NewSessionTicketメッセージを介して確立されたPSKの場合、関連付けられた値は、チケットが確立された接続でネゴシエートされた値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Future extensions MUST define their interaction with 0-RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
将来の拡張は、0-RTTとの相互作用を定義しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If any of these checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT). If the client attempts a 0-RTT handshake but the server rejects it, the server will generally not have the 0-RTT record protection keys and must instead use trial decryption (either with the 1-RTT handshake keys or by looking for a cleartext ClientHello in the case of a HelloRetryRequest) to find the first non-0-RTT message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのチェックのいずれかが失敗した場合、サーバーは拡張機能で応答してはならず、上記の最初の2つのメカニズムのいずれかを使用してすべての初回飛行データを破棄する必要があります（したがって、1-RTTまたは2-RTTにフォールバックします）。 クライアントが0-RTTハンドシェイクを試みても、サーバーがそれを拒否する場合、サーバーは通常0-RTTレコード保護キーを持たず、代わりにトライアル復号化を使用する必要があります（1-RTTハンドシェイクキーを使用するか、クリアテキストClientHelloを検索することにより） HelloRetryRequestの場合）、最初の非0-RTTメッセージを見つけます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server chooses to accept the &#34;early_data&#34; extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records. Specifically, if the server fails to decrypt a 0-RTT record following an accepted &#34;early_data&#34; extension, it MUST terminate the connection with a &#34;bad_record_mac&#34; alert as per Section 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが「early_data」拡張機能を受け入れることを選択した場合、初期データレコードを処理するときに、すべてのレコードに対して指定された同じエラー処理要件に準拠する必要があります。 具体的には、サーバーが受け入れられた「early_data」拡張子に続く0-RTTレコードの復号化に失敗した場合、セクション5.2に従って「bad_record_mac」アラートで接続を終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server rejects the &#34;early_data&#34; extension, the client application MAY opt to retransmit the Application Data previously sent in early data once the handshake has been completed. Note that automatic retransmission of early data could result in incorrect assumptions regarding the status of the connection. For instance, when the negotiated connection selects a different ALPN protocol from what was used for the early data, an application might need to construct different messages. Similarly, if early data assumes anything about the connection state, it might be sent in error after the handshake completes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが「early_data」拡張子を拒否した場合、クライアントアプリケーションは、ハンドシェイクが完了すると、以前のデータで以前に送信されたアプリケーションデータを再送信することを選択できます。 初期データの自動再送信により、接続のステータスに関する誤った仮定が生じる可能性があることに注意してください。 たとえば、ネゴシエートされた接続が初期データに使用されたものとは異なるALPNプロトコルを選択する場合、アプリケーションは異なるメッセージを作成する必要があります。 同様に、初期データが接続状態について何かを仮定している場合、ハンドシェイクの完了後にエラーで送信される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A TLS implementation SHOULD NOT automatically resend early data; applications are in a better position to decide when retransmission is appropriate. A TLS implementation MUST NOT automatically resend early data unless the negotiated connection selects the same ALPN protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS実装は、初期データを自動的に再送信するべきではありません。 アプリケーションは、再送信がいつ適切かを判断するのに適した立場にあります。 ネゴシエートされた接続が同じALPNプロトコルを選択しない限り、TLS実装は初期データを自動的に再送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.11. Pre-Shared Key Extension
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.11。 事前共有キー拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;pre_shared_key&#34; extension is used to negotiate the identity of the pre-shared key to be used with a given handshake in association with PSK key establishment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「pre_shared_key」拡張は、PSKキーの確立に関連して特定のハンドシェイクで使用される事前共有キーのIDをネゴシエートするために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;extension_data&#34; field of this extension contains a &#34;PreSharedKeyExtension&#34; value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この拡張機能の「extension_data」フィールドには、「PreSharedKeyExtension」値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque identity&lt;1..2^16-1&gt;;
          uint32 obfuscated_ticket_age;
      } PskIdentity;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque PskBinderEntry&lt;32..255&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明なPskBinderEntry &lt;32..255&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          PskIdentity identities&lt;7..2^16-1&gt;;
          PskBinderEntry binders&lt;33..2^16-1&gt;;
      } OfferedPsks;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (Handshake.msg_type) {
              case client_hello: OfferedPsks;
              case server_hello: uint16 selected_identity;
          };
      } PreSharedKeyExtension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
identity: A label for a key. For instance, a ticket (as defined in Appendix B.3.4) or a label for a pre-shared key established externally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
identity：キーのラベル。 たとえば、チケット（付録B.3.4で定義）または外部で確立された事前共有キーのラベル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
obfuscated_ticket_age: An obfuscated version of the age of the key. Section 4.2.11.1 describes how to form this value for identities established via the NewSessionTicket message. For identities established externally, an obfuscated_ticket_age of 0 SHOULD be used, and servers MUST ignore the value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
obfuscated_ticket_age：キーの年齢の難読化されたバージョン。 セクション4.2.11.1では、NewSessionTicketメッセージを介して確立されたIDに対してこの値を形成する方法について説明します。 外部で確立されたIDの場合、0のobfuscated_ticket_ageを使用する必要があり（SHOULD）、サーバーは値を無視しなければなりません（MUST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
identities: A list of the identities that the client is willing to negotiate with the server. If sent alongside the &#34;early_data&#34; extension (see Section 4.2.10), the first identity is the one used for 0-RTT data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アイデンティティ：クライアントがサーバーと交渉する意思があるアイデンティティのリスト。 「early_data」拡張子（セクション4.2.10を参照）と共に送信される場合、最初のIDは0-RTTデータに使用されるIDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
binders: A series of HMAC values, one for each value in the identities list and in the same order, computed as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バインダー：一連のHMAC値。IDリストの各値に1つずつ、同じ順序で、以下で説明するように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
selected_identity: The server&#39;s chosen identity expressed as a (0-based) index into the identities in the client&#39;s list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
selected_identity：クライアントのリスト内のIDへの（0ベースの）インデックスとして表されるサーバーの選択されたID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each PSK is associated with a single Hash algorithm. For PSKs established via the ticket mechanism (Section 4.6.1), this is the KDF Hash algorithm on the connection where the ticket was established. For externally established PSKs, the Hash algorithm MUST be set when the PSK is established or default to SHA-256 if no such algorithm is defined. The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各PSKは、単一のハッシュアルゴリズムに関連付けられています。 チケットメカニズム（セクション4.6.1）を介して確立されたPSKの場合、これはチケットが確立された接続でのKDFハッシュアルゴリズムです。 外部で確立されたPSKの場合、PSKが確立されたときにハッシュアルゴリズムを設定するか、そのようなアルゴリズムが定義されていない場合はデフォルトでSHA-256を設定する必要があります。 サーバーは、互換性のあるPSK（存在する場合）および暗号スイートを選択することを保証する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In TLS versions prior to TLS 1.3, the Server Name Identification (SNI) value was intended to be associated with the session (Section 3 of [RFC6066]), with the server being required to enforce that the SNI value associated with the session matches the one specified in the resumption handshake. However, in reality the implementations were not consistent on which of two supplied SNI values they would use, leading to the consistency requirement being de facto enforced by the clients. In TLS 1.3, the SNI value is always explicitly specified in the resumption handshake, and there is no need for the server to associate an SNI value with the ticket. Clients, however, SHOULD store the SNI with the PSK to fulfill the requirements of Section 4.6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3より前のTLSバージョンでは、サーバー名識別（SNI）値はセッション（[RFC6066]のセクション3）に関連付けられることを目的としており、サーバーはセッションに関連付けられたSNI値が 再開ハンドシェイクで指定されたもの。 ただし、実際には、2つの提供されたSNI値のどちらを使用するかについて実装が一貫しておらず、一貫性要件がクライアントによって事実上強制されています。 TLS 1.3では、SNI値は常に再開ハンドシェイクで明示的に指定され、サーバーがSNI値をチケットに関連付ける必要はありません。 ただし、クライアントは、セクション4.6.1の要件を満たすためにSNIをPSKに保存する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementor&#39;s note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs. Any unknown PSKs (e.g., ones not in the PSK database or encrypted with an unknown key) SHOULD simply be ignored. If no acceptable PSKs are found, the server SHOULD perform a non-PSK handshake if possible. If backward compatibility is important, client-provided, externally established PSKs SHOULD influence cipher suite selection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装者注：セッションの再開がPSKの主な使用例である場合、PSK /暗号スイートの一致要件を実装する最も簡単な方法は、最初に暗号スイートをネゴシエートし、次に互換性のないPSKを除外することです。 不明なPSK（PSKデータベースにない、または不明なキーで暗号化されたもの）は、単に無視する必要があります（SHOULD）。 受け入れ可能なPSKが見つからない場合、サーバーは、可能であれば非PSKハンドシェイクを実行する必要があります。 下位互換性が重要な場合、クライアントが提供する、外部で確立されたPSKは、暗号スイートの選択に影響を与える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Prior to accepting PSK key establishment, the server MUST validate the corresponding binder value (see Section 4.2.11.2 below). If this value is not present or does not validate, the server MUST abort the handshake. Servers SHOULD NOT attempt to validate multiple binders; rather, they SHOULD select a single PSK and validate solely the binder that corresponds to that PSK. See Section 8.2 and Appendix E.6 for the security rationale for this requirement. In order to accept PSK key establishment, the server sends a &#34;pre_shared_key&#34; extension indicating the selected identity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PSKキーの確立を受け入れる前に、サーバーは対応するバインダー値を検証する必要があります（セクション4.2.11.2を参照）。 この値が存在しないか検証されない場合、サーバーはハンドシェイクを中止しなければなりません。 サーバーは、複数のバインダーを検証しようとすべきではありません。 むしろ、単一のPSKを選択し、そのPSKに対応するバインダーのみを検証する必要があります。 この要件のセキュリティ根拠については、セクション8.2および付録E.6を参照してください。 PSKキーの確立を受け入れるために、サーバーは選択されたIDを示す「pre_shared_key」拡張を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients MUST verify that the server&#39;s selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server &#34;key_share&#34; extension is present if required by the ClientHello &#34;psk_key_exchange_modes&#34; extension. If these values are not consistent, the client MUST abort the handshake with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、サーバーのselected_identityがクライアントによって提供された範囲内にあること、サーバーがPSKに関連付けられたハッシュを示す暗号スイートを選択したこと、およびClientHello &#34;psk_key_exchange_modes&#34;拡張で必要な場合にサーバーの &#34;key_share&#34;拡張が存在することを確認しなければなりません 。 これらの値に一貫性がない場合、クライアントは「illegal_parameter」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server supplies an &#34;early_data&#34; extension, the client MUST verify that the server&#39;s selected_identity is 0. If any other value is returned, the client MUST abort the handshake with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが「early_data」拡張機能を提供する場合、クライアントはサーバーのselected_identityが0であることを確認する必要があります。他の値が返される場合、クライアントは「illegal_parameter」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;pre_shared_key&#34; extension MUST be the last extension in the ClientHello (this facilitates implementation as described below). Servers MUST check that it is the last extension and otherwise fail the handshake with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;pre_shared_key&#34;拡張は、ClientHelloの最後の拡張でなければなりません（これにより、以下で説明するように実装が容易になります）。 サーバーは、それが最後の拡張子であることを確認する必要があります。そうでなければ、「illegal_parameter」アラートでハンドシェイクに失敗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.11.1. Ticket Age
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.11.1。 チケット年齢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client&#39;s view of the age of a ticket is the time since the receipt of the NewSessionTicket message. Clients MUST NOT attempt to use tickets which have ages greater than the &#34;ticket_lifetime&#34; value which was provided with the ticket. The &#34;obfuscated_ticket_age&#34; field of each PskIdentity contains an obfuscated version of the ticket age formed by taking the age in milliseconds and adding the &#34;ticket_age_add&#34; value that was included with the ticket (see Section 4.6.1), modulo 2^32. This addition prevents passive observers from correlating connections unless tickets are reused. Note that the &#34;ticket_lifetime&#34; field in the NewSessionTicket message is in seconds but the &#34;obfuscated_ticket_age&#34; is in milliseconds. Because ticket lifetimes are restricted to a week, 32 bits is enough to represent any plausible age, even in milliseconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントのチケットの経過時間のビューは、NewSessionTicketメッセージを受信してからの時間です。 クライアントは、チケットで提供された「ticket_lifetime」値よりも長い年齢のチケットを使用してはいけません。 各PskIdentityの「obfuscated_ticket_age」フィールドには、ミリ秒単位の経過時間を取り、チケットに含まれる「ticket_age_add」値（セクション4.6.1を参照）を2 ^ 32で加算することにより形成されるチケット経過時間の難読化バージョンが含まれます。 この追加により、パッシブオブザーバーは、チケットが再利用されない限り、接続を相関させなくなります。 NewSessionTicketメッセージの「ticket_lifetime」フィールドは秒単位ですが、「obfuscated_ticket_age」はミリ秒単位であることに注意してください。 チケットの有効期間は1週間に制限されているため、ミリ秒単位であっても、妥当な年齢を表すには32ビットで十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.11.2. PSK Binder
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.11.2。 PSKバインダー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated (if via a NewSessionTicket message) and the current handshake. Each entry in the binders list is computed as an HMAC over a transcript hash (see Section 4.4.1) containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field. That is, it includes all of the ClientHello but not the binders list itself. The length fields for the message (including the overall length, the length of the extensions block, and the length of the &#34;pre_shared_key&#34; extension) are all set as if binders of the correct lengths were present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PSKバインダー値は、PSKと現在のハンドシェイク間のバインディング、およびPSKが生成されたハンドシェイク（NewSessionTicketメッセージ経由の場合）と現在のハンドシェイク間のバインディングを形成します。 バインダーリストの各エントリは、PreSharedKeyExtension.identitiesフィールドまでの部分的なClientHelloを含むトランスクリプトハッシュ（セクション4.4.1を参照）上のHMACとして計算されます。 つまり、ClientHelloのすべてが含まれますが、バインダーリスト自体は含まれません。 メッセージの長さフィールド（全体の長さ、拡張ブロックの長さ、および「pre_shared_key」拡張の長さを含む）はすべて、正しい長さのバインダーが存在するかのように設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PskBinderEntry is computed in the same way as the Finished message (Section 4.4.4) but with the BaseKey being the binder_key derived via the key schedule from the corresponding PSK which is being offered (see Section 7.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PskBinderEntryはFinishedメッセージ（セクション4.4.4）と同じ方法で計算されますが、BaseKeyは、提供されている対応するPSKからキースケジュールを介して導出されたバインダーキーです（セクション7.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the handshake includes a HelloRetryRequest, the initial ClientHello and HelloRetryRequest are included in the transcript along with the new ClientHello. For instance, if the client sends ClientHello1, its binder will be computed over:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェイクにHelloRetryRequestが含まれる場合、最初のClientHelloとHelloRetryRequestは、新しいClientHelloとともにトランスクリプトに含まれます。 たとえば、クライアントがClientHello1を送信すると、そのバインダーは次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transcript-Hash(Truncate(ClientHello1))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transcript-Hash（Truncated（ClientHello 1））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where Truncate() removes the binders list from the ClientHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Truncate（）は、ClientHelloからバインダーリストを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server responds with a HelloRetryRequest and the client then sends ClientHello2, its binder will be computed over:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーがHelloRetryRequestで応答し、クライアントがClientHello2を送信すると、そのバインダーは次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transcript-Hash(ClientHello1, HelloRetryRequest, Truncate(ClientHello2))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transcript-Hash（ClientHello 1、HelloRetry Request、Truncated（ClientHello 2））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The full ClientHello1/ClientHello2 is included in all other handshake hash computations. Note that in the first flight, Truncate(ClientHello1) is hashed directly, but in the second flight, ClientHello1 is hashed and then reinjected as a &#34;message_hash&#34; message, as described in Section 4.4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全なClientHello1 / ClientHello2は、他のすべてのハンドシェイクハッシュ計算に含まれます。 最初のフライトでは、Truncate（ClientHello1）が直接ハッシュされますが、2番目のフライトでは、ClientHello1がハッシュされ、セクション4.4.1で説明されているように「message_hash」メッセージとして再注入されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.11.3. Processing Order
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.11.3。 処理順序
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients are permitted to &#34;stream&#34; 0-RTT data until they receive the server&#39;s Finished, only then sending the EndOfEarlyData message, followed by the rest of the handshake. In order to avoid deadlocks, when accepting &#34;early_data&#34;, servers MUST process the client&#39;s ClientHello and then immediately send their flight of messages, rather than waiting for the client&#39;s EndOfEarlyData message before sending its ServerHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、サーバーのFinishedを受信するまで0-RTTデータを「ストリーミング」し、その後EndOfEarlyDataメッセージを送信し、その後にハンドシェイクの残りを送信することが許可されます。 デッドロックを回避するために、「early_data」を受け入れる場合、サーバーは、ServerHelloを送信する前にクライアントのEndOfEarlyDataメッセージを待つのではなく、クライアントのClientHelloを処理し、すぐにメッセージのフライトを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Server Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。 サーバーパラメータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The next two messages from the server, EncryptedExtensions and CertificateRequest, contain information from the server that determines the rest of the handshake. These messages are encrypted with keys derived from the server_handshake_traffic_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーからの次の2つのメッセージ、EncryptedExtensionsおよびCertificateRequestには、残りのハンドシェイクを決定するサーバーからの情報が含まれています。 これらのメッセージは、server_handshake_traffic_secretから派生したキーで暗号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. Encrypted Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1。 暗号化された拡張機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message. This is the first message that is encrypted under keys derived from the server_handshake_traffic_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのハンドシェイクで、サーバーはServerHelloメッセージの直後にEncryptedExtensionsメッセージを送信する必要があります。 これは、server_handshake_traffic_secretから派生したキーで暗号化される最初のメッセージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates. The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
EncryptedExtensionsメッセージには、保護できる拡張機能、つまり、暗号化コンテキストを確立するために必要ではないが、個々の証明書に関連付けられていない拡張機能が含まれています。 クライアントは、禁止されている拡張機能の存在についてEncryptedExtensionsをチェックする必要があり、存在する場合は「illegal_parameter」アラートでハンドシェイクを中止しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          Extension extensions&lt;0..2^16-1&gt;;
      } EncryptedExtensions;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
extensions: A list of extensions. For more information, see the table in Section 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張機能：拡張機能のリスト。 詳細については、セクション4.2の表を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. Certificate Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2。 証明書リクエスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server which is authenticating with a certificate MAY optionally request a certificate from the client. This message, if sent, MUST follow EncryptedExtensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
証明書で認証しているサーバーは、オプションでクライアントに証明書を要求できます。 このメッセージは、送信される場合、EncryptedExtensionsに従う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          Extension extensions&lt;2..2^16-1&gt;;
      } CertificateRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_request_context: An opaque string which identifies the certificate request and which will be echoed in the client&#39;s Certificate message. The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of client CertificateVerify messages). This field SHALL be zero length unless used for the post-handshake authentication exchanges described in Section 4.6.2. When requesting post-handshake authentication, the server SHOULD make the context unpredictable to the client (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the client&#39;s private key from pre-computing valid CertificateVerify messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_request_context：証明書要求を識別し、クライアントの証明書メッセージにエコーされる不透明な文字列。 certificate_request_contextは、この接続のスコープ内で一意でなければなりません（したがって、クライアントのCertificateVerifyメッセージの再生を防ぎます）。 このフィールドは、セクション4.6.2で説明されているポストハンドシェイク認証交換に使用されない限り、長さがゼロでなければなりません。 ハンドシェイク後の認証を要求する場合、サーバーは、クライアントの秘密キーに一時的にアクセスする攻撃者が有効なCertificateVerifyメッセージを事前計算することを防ぐために、コンテキストをクライアントに予測不能にする必要があります（ランダムに生成するなど）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
extensions: A set of extensions describing the parameters of the certificate being requested. The &#34;signature_algorithms&#34; extension MUST be specified, and other extensions may optionally be included if defined for this message. Clients MUST ignore unrecognized extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張機能：要求されている証明書のパラメーターを記述する拡張機能のセット。 「signature_algorithms」拡張機能を指定する必要があり、このメッセージに対して定義されている場合、他の拡張機能をオプションで含めることができます。 クライアントは認識されない拡張子を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept. In TLS 1.3, the former is expressed by sending the &#34;signature_algorithms&#34; and optionally &#34;signature_algorithms_cert&#34; extensions. The latter is expressed by sending the &#34;certificate_authorities&#34; extension (see Section 4.2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの以前のバージョンでは、CertificateRequestメッセージには、サーバーが受け入れる署名アルゴリズムと認証局のリストが含まれていました。 TLS 1.3では、前者は「signature_algorithms」およびオプションで「signature_algorithms_cert」拡張機能を送信することで表現されます。 後者は、「certificate_authorities」拡張を送信することで表現されます（セクション4.2.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the &#34;post_handshake_auth&#34; extension (see Section 4.2.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが &#34;post_handshake_auth&#34;拡張（セクション4.2を参照）を送信した場合、PSKで認証しているサーバーは、メインハンドシェイクでCertificateRequestメッセージを送信してはなりません。 .6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Authentication Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4。 認証メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As discussed in Section 2, TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished. (The PSK binders also perform key confirmation, in a similar fashion.) These three messages are always sent as the last messages in their handshake flight. The Certificate and CertificateVerify messages are only sent under certain circumstances, as defined below. The Finished message is always sent as part of the Authentication Block. These messages are encrypted under keys derived from the [sender]_handshake_traffic_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション2で説明したように、TLSは通常、認証、キーの確認、およびハンドシェイクの整合性のために、証明書、CertificateVerify、およびFinishedの共通のメッセージセットを使用します。 （PSKバインダも同様にキー確認を実行します。）これら3つのメッセージは、常にハンドシェイクフライトの最後のメッセージとして送信されます。 CertificateおよびCertificateVerifyメッセージは、以下に定義する特定の状況でのみ送信されます。 Finishedメッセージは、常に認証ブロックの一部として送信されます。 これらのメッセージは、[sender] _handshake_traffic_secretから派生したキーで暗号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The computations for the Authentication messages all uniformly take the following inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証メッセージの計算はすべて、次の入力を一様に受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The certificate and signing key to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-使用する証明書と署名キー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A Handshake Context consisting of the set of messages to be included in the transcript hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-トランスクリプトハッシュに含まれるメッセージのセットで構成されるハンドシェイクコンテキスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A Base Key to be used to compute a MAC key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-MACキーの計算に使用されるベースキー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Based on these inputs, the messages then contain:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの入力に基づいて、メッセージには以下が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Certificate: The certificate to be used for authentication, and any supporting certificates in the chain. Note that certificate-based client authentication is not available in PSK handshake flows (including 0-RTT).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
証明書：認証に使用される証明書、およびチェーン内のサポート証明書。 証明書ベースのクライアント認証は、PSKハンドシェイクフロー（0-RTTを含む）では使用できないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateVerify: A signature over the value Transcript-Hash(Handshake Context, Certificate).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateVerify：値Transcript-Hash（Handshake Context、Certificate）の署名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finished: A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
終了：ベースキーから派生したMACキーを使用して、値Transcript-Hash（Handshake Context、Certificate、CertificateVerify）に対するMAC。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following table defines the Handshake Context and MAC Base Key for each scenario:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の表は、各シナリオのハンドシェイクコンテキストとMACベースキーを定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-----------+-------------------------+-----------------------------+
   | Mode      | Handshake Context       | Base Key                    |
   +-----------+-------------------------+-----------------------------+
   | Server    | ClientHello ... later   | server_handshake_traffic_   |
   |           | of EncryptedExtensions/ | secret                      |
   |           | CertificateRequest      |                             |
   |           |                         |                             |
   | Client    | ClientHello ... later   | client_handshake_traffic_   |
   |           | of server               | secret                      |
   |           | Finished/EndOfEarlyData |                             |
   |           |                         |                             |
   | Post-     | ClientHello ... client  | client_application_traffic_ |
   | Handshake | Finished +              | secret_N                    |
   |           | CertificateRequest      |                             |
   +-----------+-------------------------+-----------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1. The Transcript Hash
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1。 トランスクリプトハッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many of the cryptographic computations in TLS make use of a transcript hash. This value is computed by hashing the concatenation of each included handshake message, including the handshake message header carrying the handshake message type and length fields, but not including record layer headers. I.e.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの暗号化計算の多くは、トランスクリプトハッシュを使用します。 この値は、含まれている各ハンドシェイクメッセージの連結をハッシュすることによって計算されます。これには、ハンドシェイクメッセージタイプと長さフィールドを含むハンドシェイクメッセージヘッダーが含まれますが、レコードレイヤーヘッダーは含まれません。 つまり、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transcript-Hash（M1、M2、... Mn）= Hash（M1 || M2 || ... || Mn）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As an exception to this general rule, when the server responds to a ClientHello with a HelloRetryRequest, the value of ClientHello1 is replaced with a special synthetic handshake message of handshake type &#34;message_hash&#34; containing Hash(ClientHello1). I.e.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この一般的な規則の例外として、サーバーがHelloRetryRequestでClientHelloに応答すると、ClientHello1の値は、Hash（ClientHello1）を含むハンドシェイクタイプ「message_hash」の特別な合成ハンドシェイクメッセージに置き換えられます。 つまり、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
      Hash(message_hash ||        /* Handshake type */
           00 00 Hash.length  ||  /* Handshake message length (bytes) */
           Hash(ClientHello1) ||  /* Hash of ClientHello1 */
           HelloRetryRequest  || ... || Mn)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The reason for this construction is to allow the server to do a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, rather than requiring it to export the entire intermediate hash state (see Section 4.2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この構成の理由は、中間ハッシュ状態全体をエクスポートするように要求するのではなく、CookieにClientHello1のハッシュのみを格納することにより、サーバーがステートレスHelloRetryRequestを実行できるようにするためです（セクション4.2.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For concreteness, the transcript hash is always taken from the following sequence of handshake messages, starting at the first ClientHello and including only those messages that were sent: ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, server CertificateRequest, server Certificate, server CertificateVerify, server Finished, EndOfEarlyData, client Certificate, client CertificateVerify, client Finished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
具体的には、トランスクリプトハッシュは常に、次の一連のハンドシェイクメッセージから取得されます。最初のClientHelloから始まり、送信されたメッセージのみが含まれます：ClientHello、HelloRetryRequest、ClientHello、ServerHello、EncryptedExtensions、server CertificateRequest、server Certificate、server CertificateVerify、 サーバー終了、EndOfEarlyData、クライアント証明書、クライアント証明書検証、クライアント終了。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In general, implementations can implement the transcript by keeping a running transcript hash value based on the negotiated hash. Note, however, that subsequent post-handshake authentications do not include each other, just the messages through the end of the main handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般に、実装は、ネゴシエートされたハッシュに基づいて実行中のトランスクリプトハッシュ値を保持することにより、トランスクリプトを実装できます。 ただし、後続のハンドシェイク後の認証には、お互いが含まれず、メインハンドシェイクの最後までのメッセージのみが含まれることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2. Certificate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2。 証明書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This message conveys the endpoint&#39;s certificate chain to the peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージは、エンドポイントの証明書チェーンをピアに伝えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、合意されたキー交換方法が認証に証明書を使用する場合は常に証明書メッセージを送信する必要があります（これには、PSKを除く、このドキュメントで定義されているすべてのキー交換方法が含まれます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2). If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the &#34;certificate_list&#34; field having length 0). A Finished message MUST be sent regardless of whether the Certificate message is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、CertificateRequestメッセージ（セクション4.3.2）を介してクライアント認証を要求した場合にのみ、クライアントは証明書メッセージを送信する必要があります。 サーバーがクライアント認証を要求したが、適切な証明書が利用できない場合、クライアントは証明書を含まない証明書メッセージを送信する必要があります（つまり、「certificate_list」フィールドの長さは0）。 証明書メッセージが空かどうかに関係なく、Finishedメッセージを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum { X509(0), RawPublicKey(2), (255) } CertificateType;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum {X509（0）、RawPublicKey（2）、（255）} CertificateType;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo&lt;1..2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              case X509:
                opaque cert_data&lt;1..2^24-1&gt;;
          };
          Extension extensions&lt;0..2^16-1&gt;;
      } CertificateEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          CertificateEntry certificate_list&lt;0..2^24-1&gt;;
      } Certificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_request_context: If this message is in response to a CertificateRequest, the value of certificate_request_context in that message. Otherwise (in the case of server authentication), this field SHALL be zero length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_request_context：このメッセージがCertificateRequestへの応答である場合、そのメッセージのcertificate_request_contextの値。 それ以外の場合（サーバー認証の場合）、このフィールドは長さがゼロでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_list: A sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_list：CertificateEntry構造のシーケンス（チェーン）。各構造には、単一の証明書と拡張機能のセットが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
extensions: A set of extension values for the CertificateEntry. The &#34;Extension&#34; format is defined in Section 4.2. Valid extensions for server certificates at present include the OCSP Status extension [RFC6066] and the SignedCertificateTimestamp extension [RFC6962]; future extensions may be defined for this message as well. Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message. Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server. If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
extensions：CertificateEntryの拡張値のセット。 「拡張」形式はセクション4.2で定義されています。 現在のサーバー証明書の有効な拡張には、OCSP Status拡張[RFC6066]およびSignedCertificateTimestamp拡張[RFC6962]が含まれます。 このメッセージにも将来の拡張が定義される可能性があります。 サーバーからの証明書メッセージの拡張子は、ClientHelloメッセージの拡張子に対応している必要があります。 クライアントからの証明書メッセージの拡張子は、サーバーからのCertificateRequestメッセージの拡張子に対応しなければなりません。 拡張機能がチェーン全体に適用される場合、最初のCertificateEntryに含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the corresponding certificate type extension (&#34;server_certificate_type&#34; or &#34;client_certificate_type&#34;) was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate. The sender&#39;s certificate MUST come in the first CertificateEntry in the list. Each following certificate SHOULD directly certify the one immediately preceding it. Because certificate validation requires that trust anchors be distributed independently, a certificate that specifies a trust anchor MAY be omitted from the chain, provided that supported peers are known to possess any omitted certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
対応する証明書タイプ拡張（「server_certificate_type」または「client_certificate_type」）がEncryptedExtensionsでネゴシエートされなかった場合、またはX.509証明書タイプがネゴシエートされた場合、各CertificateEntryにはDERエンコードされたX.509証明書が含まれます。 送信者の証明書は、リストの最初のCertificateEntryに含まれなければなりません。 次の各証明書は、その直前の証明書を直接証明する必要があります。 証明書の検証ではトラストアンカーを個別に配布する必要があるため、トラストアンカーを指定する証明書は、サポートされているピアが省略された証明書を持っていることがわかっている場合、チェーンから省略できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Prior to TLS 1.3, &#34;certificate_list&#34; ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed some flexibility. Servers sometimes send both a current and deprecated intermediate for transitional purposes, and others are simply configured incorrectly, but these cases can nonetheless be validated properly. For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：TLS 1.3より前の「certificate_list」の順序付けでは、各証明書が直前の証明書を証明する必要がありました。 ただし、一部の実装ではある程度の柔軟性がありました。 サーバーは、移行目的で現在および非推奨の中間の両方を送信する場合があり、他のサーバーは単純に誤って構成されますが、それでもこれらのケースは適切に検証できます。 最大限の互換性のために、すべての実装は、最初に存在しなければならないエンドエンティティ証明書を除いて、潜在的に無関係な証明書および任意のTLSバージョンからの任意の順序を処理するように準備する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN1_subjectPublicKeyInfo value as defined in [RFC7250], Section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RawPublicKey証明書タイプがネゴシエートされた場合、certificate_listには[RFC7250]セクション3で定義されているASN1_subjectPublicKeyInfo値を含むCertificateEntryを1つだけ含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OpenPGP証明書タイプ[RFC6091]は、TLS 1.3で使用してはなりません（MUST NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server&#39;s certificate_list MUST always be non-empty. A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server&#39;s authentication request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーのcertificate_listは常に空ではない必要があります。 クライアントは、サーバーの認証要求への応答として送信する適切な証明書がない場合、空のcertificate_listを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.1. OCSP Status and SCT Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.1。 OCSPステータスとSCT拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6066] and [RFC6961] provide extensions to negotiate the server sending OCSP responses to the client. In TLS 1.2 and below, the server replies with an empty extension to indicate negotiation of this extension and the OCSP information is carried in a CertificateStatus message. In TLS 1.3, the server&#39;s OCSP information is carried in an extension in the CertificateEntry containing the associated certificate. Specifically, the body of the &#34;status_request&#34; extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted as defined in [RFC6960].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6066]および[RFC6961]は、クライアントにOCSP応答を送信するサーバーをネゴシエートするための拡張機能を提供します。 TLS 1.2以前では、サーバーはこの拡張のネゴシエーションを示すために空の拡張で応答し、OCSP情報はCertificateStatusメッセージで運ばれます。 TLS 1.3では、サーバーのOCSP情報は、関連付けられた証明書を含むCertificateEntryの拡張で運ばれます。 具体的には、サーバーからの「status_request」拡張の本体は、[RFC6066]で定義されているCertificateStatus構造である必要があり、[RFC6960]で定義されていると解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The status_request_v2 extension [RFC6961] is deprecated. TLS 1.3 servers MUST NOT act upon its presence or information in it when processing ClientHello messages; in particular, they MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages. TLS 1.3 servers MUST be able to process ClientHello messages that include it, as it MAY be sent by clients that wish to use it in earlier protocol versions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：status_request_v2拡張機能[RFC6961]は非推奨です。 TLS 1.3サーバーは、ClientHelloメッセージを処理するときに、その存在または情報に基づいて動作してはなりません。 特に、EncryptedExtensions、CertificateRequest、またはCertificateメッセージでstatus_request_v2拡張を送信してはなりません。 TLS 1.3サーバーは、それを含むClientHelloメッセージを処理できる必要があります。これは、以前のプロトコルバージョンで使用したいクライアントから送信される場合があるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A server MAY request that a client present an OCSP response with its certificate by sending an empty &#34;status_request&#34; extension in its CertificateRequest message. If the client opts to send an OCSP response, the body of its &#34;status_request&#34; extension MUST be a CertificateStatus structure as defined in [RFC6066].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、CertificateRequestメッセージで空の「status_request」拡張を送信することにより、クライアントが証明書とともにOCSP応答を提示するように要求する場合があります。 クライアントがOCSP応答を送信することを選択した場合、その「status_request」拡張の本体は、[RFC6066]で定義されているCertificateStatus構造でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Similarly, [RFC6962] provides a mechanism for a server to send a Signed Certificate Timestamp (SCT) as an extension in the ServerHello in TLS 1.2 and below. In TLS 1.3, the server&#39;s SCT information is carried in an extension in the CertificateEntry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同様に、[RFC6962]は、サーバーがTLS 1.2以下のServerHelloの拡張として署名済み証明書タイムスタンプ（SCT）を送信するためのメカニズムを提供します。 TLS 1.3では、サーバーのSCT情報はCertificateEntryの拡張で運ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.2. Server Certificate Selection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.2。 サーバー証明書の選択
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following rules apply to the certificates sent by the server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーから送信される証明書には、次の規則が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-明示的に別の方法でネゴシエートされない限り、証明書タイプはX.509v3 [RFC5280]でなければなりません（例：[RFC7250]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The server&#39;s end-entity certificate&#39;s public key (and associated restrictions) MUST be compatible with the selected authentication algorithm from the client&#39;s &#34;signature_algorithms&#34; extension (currently RSA, ECDSA, or EdDSA).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サーバーのエンドエンティティ証明書の公開鍵（および関連する制限）は、クライアントの「signature_algorithms」拡張機能（現在はRSA、ECDSA、またはEdDSA）から選択した認証アルゴリズムと互換性がなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The certificate MUST allow the key to be used for signing (i.e., the digitalSignature bit MUST be set if the Key Usage extension is present) with a signature scheme indicated in the client&#39;s &#34;signature_algorithms&#34;/&#34;signature_algorithms_cert&#34; extensions (see Section 4.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-証明書は、クライアントの「signature_algorithms」/「signature_algorithms_cert」拡張機能で示された署名スキームを使用して、署名にキーを使用できるようにする必要があります（つまり、Key Usage拡張機能が存在する場合はdigitalSignatureビットを設定する必要があります）（セクション4.2を参照）。 3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The &#34;server_name&#34; [RFC6066] and &#34;certificate_authorities&#34; extensions are used to guide certificate selection. As servers MAY require the presence of the &#34;server_name&#34; extension, clients SHOULD send this extension, when applicable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「server_name」[RFC6066]および「certificate_authorities」拡張機能は、証明書の選択をガイドするために使用されます。 サーバーは「server_name」拡張の存在を必要とする場合があるため、クライアントは該当する場合、この拡張を送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if it is able to provide such a chain (see Section 4.2.3). Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが提供するすべての証明書は、そのようなチェーンを提供できる場合、クライアントがアドバタイズする署名アルゴリズムによって署名する必要があります（セクション4.2.3を参照）。 自己署名証明書またはトラストアンカーであると予想される証明書は、チェーンの一部として検証されないため、任意のアルゴリズムで署名することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then it SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms that are not known to be supported by the client. This fallback chain SHOULD NOT use the deprecated SHA-1 hash algorithm in general, but MAY do so if the client&#39;s advertisement permits it, and MUST NOT do so otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが、示されたサポートされているアルゴリズムを介してのみ署名された証明書チェーンを作成できない場合、クライアントがサポートしていないことがわかっているアルゴリズムを含む可能性のある選択した証明書チェーンをクライアントに送信して、ハンドシェイクを続行する必要があります。 このフォールバックチェーンは、一般的に非推奨のSHA-1ハッシュアルゴリズムを使用すべきではありませんが、クライアントの広告で許可されている場合は使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then it MUST abort the handshake with an appropriate certificate-related alert (by default, &#34;unsupported_certificate&#34;; see Section 6.2 for more information).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが提供された証明書を使用して受け入れ可能なチェーンを構築できず、ハンドシェイクを中止することを決定した場合、適切な証明書関連のアラートでハンドシェイクを中止する必要があります（デフォルトでは、「unsupported_certificate」。詳細はセクション6.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server has multiple certificates, it chooses one of them based on the above-mentioned criteria (in addition to other criteria, such as transport-layer endpoint, local configuration, and preferences).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーに複数の証明書がある場合、サーバーは上記の基準（トランスポート層エンドポイント、ローカル構成、設定などの他の基準に加えて）に基づいてそれらのいずれかを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.3. Client Certificate Selection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.3。 クライアント証明書の選択
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following rules apply to certificates sent by the client:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントから送信される証明書には、次の規則が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The certificate type MUST be X.509v3 [RFC5280], unless explicitly negotiated otherwise (e.g., [RFC7250]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-明示的に別の方法でネゴシエートされない限り、証明書タイプはX.509v3 [RFC5280]でなければなりません（例：[RFC7250]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If the &#34;certificate_authorities&#34; extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-CertificateRequestメッセージに「certificate_authorities」拡張が存在する場合、証明書チェーン内の証明書の少なくとも1つが、リストされているCAの1つによって発行される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-証明書は、セクション4.3.2で説明されているように、受け入れ可能な署名アルゴリズムを使用して署名する必要があります。 これにより、以前のバージョンのTLSで見つかった証明書署名アルゴリズムの制約が緩和されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If the CertificateRequest message contained a non-empty &#34;oid_filters&#34; extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-CertificateRequestメッセージに空でない「oid_filters」拡張が含まれている場合、エンドエンティティ証明書は、セクション4.2.5で説明されているように、クライアントによって認識される拡張OIDと一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.4. Receiving a Certificate Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.4。 証明書メッセージを受信する
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In general, detailed certificate validation procedures are out of scope for TLS (see [RFC5280]). This section provides TLS-specific requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般に、詳細な証明書検証手順はTLSの範囲外です（[RFC5280]を参照）。 このセクションでは、TLS固有の要件について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server supplies an empty Certificate message, the client MUST abort the handshake with a &#34;decode_error&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが空の証明書メッセージを提供する場合、クライアントは「decode_error」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a &#34;certificate_required&#34; alert. Also, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or abort the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが証明書を送信しない場合（つまり、空の証明書メッセージを送信する場合）、サーバーはその裁量で、クライアント認証なしでハンドシェイクを続行するか、「certificate_required」アラートでハンドシェイクを中止する場合があります。 また、証明書チェーンの一部が受け入れられない場合（たとえば、既知の信頼できるCAによって署名されていない場合）、サーバーはその裁量でハンドシェイクを続行する（クライアントが認証されていないことを考慮する）か、ハンドシェイクを中止することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a &#34;bad_certificate&#34; alert. SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a &#34;bad_certificate&#34; alert. For clarity, this means that endpoints can accept these algorithms for certificates that are self-signed or are trust anchors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MD5ハッシュを使用する署名アルゴリズムを使用して検証する必要がある証明書を受信するエンドポイントは、「bad_certificate」アラートでハンドシェイクを中止する必要があります。 SHA-1は非推奨です。SHA-1ハッシュを使用する署名アルゴリズムを使用して検証する必要がある証明書を受信するエンドポイントは、「bad_certificate」アラートでハンドシェイクを中止することをお勧めします。 明確にするため、これは、エンドポイントが自己署名証明書またはトラストアンカーである証明書に対してこれらのアルゴリズムを受け入れることができることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All endpoints are RECOMMENDED to transition to SHA-256 or better as soon as possible to maintain interoperability with implementations currently in the process of phasing out SHA-1 support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのエンドポイントは、SHA-1サポートを段階的に廃止している実装との相互運用性を維持するために、できるだけ早くSHA-256以上に移行することを推奨します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with an ECDSA key).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1つの署名アルゴリズムのキーを含む証明書は、別の署名アルゴリズム（たとえば、ECDSAキーで署名されたRSAキー）を使用して署名される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.3. Certificate Verify
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.3。 証明書検証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This message is used to provide explicit proof that an endpoint possesses the private key corresponding to its certificate. The CertificateVerify message also provides integrity for the handshake up to this point. Servers MUST send this message when authenticating via a certificate. Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty). When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージは、エンドポイントがその証明書に対応する秘密鍵を所有していることを明示的に証明するために使用されます。 CertificateVerifyメッセージは、この時点までのハンドシェイクの整合性も提供します。 サーバーは、証明書を介して認証するときにこのメッセージを送信する必要があります。 クライアントは、証明書を介して認証するたびに（つまり、証明書メッセージが空でない場合）このメッセージを送信する必要があります。 送信されると、このメッセージは、証明書メッセージの直後で、完了メッセージの直前に表示されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          SignatureScheme algorithm;
          opaque signature&lt;0..2^16-1&gt;;
      } CertificateVerify;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The algorithm field specifies the signature algorithm used (see Section 4.2.3 for the definition of this type). The signature is a digital signature using that algorithm. The content that is covered under the signature is the hash output as described in Section 4.4.1, namely:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アルゴリズムフィールドは、使用される署名アルゴリズムを指定します（このタイプの定義については、セクション4.2.3を参照してください）。 署名は、そのアルゴリズムを使用したデジタル署名です。 署名の対象となるコンテンツは、セクション4.4.1で説明されているハッシュ出力です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transcript-Hash(Handshake Context, Certificate)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トランスクリプトハッシュ（ハンドシェイクコンテキスト、証明書）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The digital signature is then computed over the concatenation of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デジタル署名は、次の連結を介して計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A string that consists of octet 32 (0x20) repeated 64 times
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-64回繰り返されるオクテット32（0x20）で構成される文字列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The context string
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-コンテキスト文字列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A single 0 byte which serves as the separator
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-セパレータとして機能する単一の0バイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The content to be signed
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-署名するコンテンツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This structure is intended to prevent an attack on previous versions of TLS in which the ServerKeyExchange format meant that attackers could obtain a signature of a message with a chosen 32-byte prefix (ClientHello.random). The initial 64-byte pad clears that prefix along with the server-controlled ServerHello.random.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この構造は、ServerKeyExchange形式により、攻撃者が選択した32バイトのプレフィックス（ClientHello.random）を持つメッセージの署名を取得できることを意味する、以前のバージョンのTLSに対する攻撃を防ぐことを目的としています。 最初の64バイトパッドは、サーバー制御のServerHello.randomとともにそのプレフィックスをクリアします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The context string for a server signature is &#34;TLS 1.3, server CertificateVerify&#34;. The context string for a client signature is &#34;TLS 1.3, client CertificateVerify&#34;. It is used to provide separation between signatures made in different contexts, helping against potential cross-protocol attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバー署名のコンテキスト文字列は「TLS 1.3、サーバー証明書検証」です。 クライアント署名のコンテキスト文字列は「TLS 1.3、クライアント証明書検証」です。 異なるコンテキストで作成された署名を分離するために使用され、潜在的なクロスプロトコル攻撃を防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, if the transcript hash was 32 bytes of 01 (this length would make sense for SHA-256), the content covered by the digital signature for a server CertificateVerify would be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
たとえば、トランスクリプトハッシュが32バイトの01であった場合（この長さはSHA-256にとって意味があります）、サーバーCertificateVerifyのデジタル署名でカバーされるコンテンツは次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2020202020202020202020202020202020202020202020202020202020202020 2020202020202020202020202020202020202020202020202020202020202020 544c5320312e332c207365727665722043657274696669636174655665726966 79 00 0101010101010101010101010101010101010101010101010101010101010101
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2020202020202020202020202020202020202020202020202020202020202020 2020202020202020202020202020202020202020202020202020202020202020 544c5320312e332c207365727665722043657274696669636174655665726966 79 00 0101010101010101010101010101010010010010010010010010010010010010010101010101010101010101010101010101010101010101010101010010
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On the sender side, the process for computing the signature field of the CertificateVerify message takes as input:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信側では、CertificateVerifyメッセージの署名フィールドを計算するプロセスが入力として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The content covered by the digital signature
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-デジタル署名の対象となるコンテンツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The private signing key corresponding to the certificate sent in the previous message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-前のメッセージで送信された証明書に対応する秘密署名キー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client&#39;s &#34;signature_algorithms&#34; extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateVerifyメッセージがサーバーによって送信される場合、サポートされていないアルゴリズムなしで有効な証明書チェーンを作成できない場合を除き、署名アルゴリズムはクライアントの「signature_algorithms」拡張で提供されるものでなければなりません（セクション4.2.3を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the &#34;signature_algorithms&#34; extension in the CertificateRequest message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントによって送信される場合、署名で使用される署名アルゴリズムは、CertificateRequestメッセージの「signature_algorithms」拡張機能のsupported_signature_algorithmsフィールドに存在するものの1つでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, the signature algorithm MUST be compatible with the key in the sender&#39;s end-entity certificate. RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in &#34;signature_algorithms&#34;. The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、署名アルゴリズムは、送信者のエンドエンティティ証明書のキーと互換性がなければなりません。 RSASA-PKCS1-v1_5アルゴリズムが「signature_algorithms」に表示されるかどうかに関係なく、RSA署名はRSASSA-PSSアルゴリズムを使用する必要があります。 SHA-1アルゴリズムは、CertificateVerifyメッセージの署名で使用してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All SHA-1 signature algorithms in this specification are defined solely for use in legacy certificates and are not valid for CertificateVerify signatures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様のすべてのSHA-1署名アルゴリズムは、レガシー証明書での使用のみを目的として定義されており、CertificateVerify署名には無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The receiver of a CertificateVerify message MUST verify the signature field. The verification process takes as input:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CertificateVerifyメッセージの受信者は、署名フィールドを検証する必要があります。 検証プロセスは入力として使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The content covered by the digital signature
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-デジタル署名の対象となるコンテンツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The public key contained in the end-entity certificate found in the associated Certificate message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-関連する証明書メッセージにあるエンドエンティティ証明書に含まれる公開鍵
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The digital signature received in the signature field of the CertificateVerify message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-CertificateVerifyメッセージの署名フィールドで受信したデジタル署名
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the verification fails, the receiver MUST terminate the handshake with a &#34;decrypt_error&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
検証に失敗した場合、受信者は「decrypt_error」アラートでハンドシェイクを終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.4. Finished
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.4。 完成した
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Finished message is the final message in the Authentication Block. It is essential for providing authentication of the handshake and of the computed keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finishedメッセージは、認証ブロックの最後のメッセージです。 ハンドシェイクと計算されたキーの認証を提供するために不可欠です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a &#34;decrypt_error&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完了メッセージの受信者は、内容が正しいことを確認しなければならず、正しくない場合は「decrypt_error」アラートで接続を終了しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive Application Data over the connection. There are two settings in which it is permitted to send data prior to receiving the peer&#39;s Finished:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サイドがFinishedメッセージを送信し、ピアからFinishedメッセージを受信して検証すると、接続を介してアプリケーションデータの送受信を開始できます。 ピアのFinishedを受信する前にデータを送信することを許可される2つの設定があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Clients sending 0-RTT data as described in Section 4.2.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.セクション4.2.10で説明されている0-RTTデータを送信するクライアント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Servers MAY send data after sending their first flight, but because the handshake is not yet complete, they have no assurance of either the peer&#39;s identity or its liveness (i.e., the ClientHello might have been replayed).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.サーバーは最初のフライトを送信した後にデータを送信できますが、ハンドシェイクがまだ完了していないため、ピアのIDまたはその活性（ClientHelloがリプレイされた可能性）の保証はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key used to compute the Finished message is computed from the Base Key defined in Section 4.4 using HKDF (see Section 7.1). Specifically:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finishedメッセージの計算に使用されるキーは、HKDFを使用してセクション4.4で定義されたベースキーから計算されます（セクション7.1を参照）。 具体的には：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
finished_key = HKDF-Expand-Label(BaseKey, &#34;finished&#34;, &#34;&#34;, Hash.length)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
finished_key = HKDF-Expand-Label（BaseKey、 &#34;finished&#34;、 &#34;&#34;、Hash.length）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque verify_data[Hash.length];
      } Finished;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The verify_data value is computed as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
verify_data値は次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
verify_data = HMAC（finished_key、Transcript-Hash（Handshake Context、Certificate *、CertificateVerify *））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Only included if present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*存在する場合のみ含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
HMAC [RFC2104] uses the Hash algorithm for the handshake. As noted above, the HMAC input can generally be implemented by a running hash, i.e., just the handshake hash at this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HMAC [RFC2104]は、ハンドシェイクにハッシュアルゴリズムを使用します。 上記のように、HMAC入力は通常、実行中のハッシュ、つまりこの時点でのハンドシェイクハッシュによって実装できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In previous versions of TLS, the verify_data was always 12 octets long. In TLS 1.3, it is the size of the HMAC output for the Hash used for the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの以前のバージョンでは、verify_dataは常に12オクテット長でした。 TLS 1.3では、ハンドシェイクに使用されるハッシュのHMAC出力のサイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Alerts and any other non-handshake record types are not handshake messages and are not included in the hash computations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：アラートおよびその他の非ハンドシェイクレコードタイプはハンドシェイクメッセージではなく、ハッシュ計算には含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2. In particular, this includes any alerts sent by the server in response to client Certificate and CertificateVerify messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finishedメッセージに続くレコードは、セクション7.2で説明されているように、適切なアプリケーショントラフィックキーの下で暗号化する必要があります。 特に、これには、クライアント証明書およびCertificateVerifyメッセージへの応答としてサーバーによって送信されるアラートが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. End of Early Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5。 初期データの終わり
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {} EndOfEarlyData;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {} EndOfEarlyData;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the server sent an &#34;early_data&#34; extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished. If the server does not send an &#34;early_data&#34; extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message. This message indicates that all 0-RTT application_data messages, if any, have been transmitted and that the following records are protected under handshake traffic keys. Servers MUST NOT send this message, and clients receiving it MUST terminate the connection with an &#34;unexpected_message&#34; alert. This message is encrypted under keys derived from the client_early_traffic_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーがEncryptedExtensionsで「early_data」拡張機能を送信した場合、クライアントはサーバーFinishedを受信した後にEndOfEarlyDataメッセージを送信する必要があります。 サーバーがEncryptedExtensionsで「early_data」拡張を送信しない場合、クライアントはEndOfEarlyDataメッセージを送信してはなりません。 このメッセージは、すべての0-RTT application_dataメッセージがあれば送信されたこと、および後続のレコードがハンドシェイクトラフィックキーで保護されていることを示します。 サーバーはこのメッセージを送信してはならず、それを受信したクライアントは「unexpected_message」アラートで接続を終了しなければなりません。 このメッセージは、client_early_traffic_secretから派生したキーで暗号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. Post-Handshake Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6。 ハンドシェイク後メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS also allows other messages to be sent after the main handshake. These messages use a handshake content type and are encrypted under the appropriate application traffic key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSでは、メインハンドシェイク後に他のメッセージを送信することもできます。 これらのメッセージはハンドシェイクコンテンツタイプを使用し、適切なアプリケーショントラフィックキーの下で暗号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. New Session Ticket Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1。 新しいセッションチケットメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message. This message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーがクライアントのFinishedメッセージを受信した後はいつでも、NewSessionTicketメッセージを送信できます。 このメッセージは、チケット値と再開マスターシークレットから派生したシークレットPSKの間に一意の関連付けを作成します（セクション7を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client MAY use this PSK for future handshakes by including the ticket value in the &#34;pre_shared_key&#34; extension in its ClientHello (Section 4.2.11). Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events (see Appendix C.4). For instance, the server might send a new ticket after post-handshake authentication in order to encapsulate the additional client authentication state. Multiple tickets are useful for clients for a variety of purposes, including:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、ClientHello（セクション4.2.11）の「pre_shared_key」拡張にチケット値を含めることにより、将来のハンドシェイクにこのPSKを使用する場合があります。 サーバーは、1つの接続で複数のチケットを送信する場合があります（それぞれの直後または特定のイベントの後）（付録C.4を参照）。 たとえば、サーバーは、追加のクライアント認証状態をカプセル化するために、ハンドシェイク後の認証後に新しいチケットを送信する場合があります。 複数のチケットは、クライアントにとって次のようなさまざまな目的に役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Opening multiple parallel HTTP connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-複数の並列HTTP接続を開きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Performing connection racing across interfaces and address families via (for example) Happy Eyeballs [RFC8305] or related techniques.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-（たとえば）Happy Eyeballs [RFC8305]または関連技術を介して、インターフェースおよびアドレスファミリ全体で接続レースを実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
元の接続を確立するために使用したものと同じKDFハッシュアルゴリズムを持つ暗号スイートでのみ、チケットを再開する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session. The latter is a performance optimization: normally, there is no reason to expect that different servers covered by a single certificate would be able to accept each other&#39;s tickets; hence, attempting resumption in that case would waste a single-use ticket. If such an indication is provided (externally or by any other means), clients MAY resume with a different SNI value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、新しいSNI値が元のセッションで提示されたサーバー証明書に対して有効である場合にのみ再開し、SNI値が元のセッションで使用された値と一致する場合にのみ再開する必要があります。 後者はパフォーマンスの最適化です。通常、単一の証明書でカバーされる異なるサーバーが互いのチケットを受け入れることができると期待する理由はありません。 したがって、その場合に再開を試みると、使い捨てチケットが無駄になります。 そのような指示が提供された場合（外部または他の手段）、クライアントは異なるSNI値で再開できます（MAY）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session. Note that if a server implementation declines all PSK identities with different SNI values, these two values are always the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
再開時に、呼び出し側アプリケーションにSNI値を報告する場合、実装は前のセッションで送信された値ではなく、再開ClientHelloで送信された値を使用する必要があります。 サーバー実装が異なるSNI値を持つすべてのPSK IDを拒否する場合、これら2つの値は常に同じであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Although the resumption master secret depends on the client&#39;s second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished. This might be appropriate in cases where the client is expected to open multiple TLS connections in parallel and would benefit from the reduced overhead of a resumption handshake, for example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：再開マスターシークレットはクライアントの2番目のフライトに依存しますが、クライアント認証を要求しないサーバーは、トランスクリプトの残りを個別に計算し、クライアントが終了するのを待つのではなく、Finishedを送信するとすぐにNewSessionTicketを送信する場合があります。 これは、クライアントが複数のTLS接続を並行して開くことが予想され、再開ハンドシェイクのオーバーヘッドの削減などの恩恵を受ける場合に適しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce&lt;0..255&gt;;
          opaque ticket&lt;1..2^16-1&gt;;
          Extension extensions&lt;0..2^16-2&gt;;
      } NewSessionTicket;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ticket_lifetime: Indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. Servers MUST NOT use any value greater than 604800 seconds (7 days). The value of zero indicates that the ticket should be discarded immediately. Clients MUST NOT cache tickets for longer than 7 days, regardless of the ticket_lifetime, and MAY delete tickets earlier based on local policy. A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ticket_lifetime：チケット発行時からのネットワークバイト順の32ビット符号なし整数として、ライフタイムを秒単位で示します。 サーバーは、604800秒（7日）を超える値を使用してはなりません。 値ゼロは、チケットをすぐに破棄する必要があることを示します。 クライアントは、ticket_lifetimeに関係なく、7日間以上チケットをキャッシュしてはならず、ローカルポリシーに基づいてチケットを早期に削除することができます。 サーバーは、ticket_lifetimeに記載されている期間よりも短い期間、チケットを有効として扱う場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ticket_age_add: A securely generated, random 32-bit value that is used to obscure the age of the ticket that the client includes in the &#34;pre_shared_key&#34; extension. The client-side ticket age is added to this value modulo 2^32 to obtain the value that is transmitted by the client. The server MUST generate a fresh value for each ticket it sends.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ticket_age_add：クライアントが「pre_shared_key」拡張に含めるチケットの有効期間をわかりにくくするために使用される、安全に生成されたランダムな32ビット値。 クライアント側のチケット経過時間は、この値に2 ^ 32を法として加算され、クライアントによって送信される値を取得します。 サーバーは、送信するチケットごとに新しい値を生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ticket_nonce: A per-ticket value that is unique across all tickets issued on this connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ticket_nonce：この接続で発行されたすべてのチケットで一意のチケットごとの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ticket: The value of the ticket to be used as the PSK identity. The ticket itself is an opaque label. It MAY be either a database lookup key or a self-encrypted and self-authenticated value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ticket：PSK IDとして使用されるチケットの値。 チケット自体は不透明なラベルです。 データベース検索キーまたは自己暗号化および自己認証値のいずれかです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
extensions: A set of extension values for the ticket. The &#34;Extension&#34; format is defined in Section 4.2. Clients MUST ignore unrecognized extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張：チケットの拡張値のセット。 「拡張」形式はセクション4.2で定義されています。 クライアントは認識されない拡張子を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sole extension currently defined for NewSessionTicket is &#34;early_data&#34;, indicating that the ticket may be used to send 0-RTT data (Section 4.2.10). It contains the following value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NewSessionTicketに現在定義されている唯一の拡張子は「early_data」であり、0-RTTデータの送信にチケットを使用できることを示します（4.2.10項）。 次の値が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
max_early_data_size: The maximum amount of 0-RTT data that the client is allowed to send when using this ticket, in bytes. Only Application Data payload (i.e., plaintext but not padding or the inner content type byte) is counted. A server receiving more than max_early_data_size bytes of 0-RTT data SHOULD terminate the connection with an &#34;unexpected_message&#34; alert. Note that servers that reject early data due to lack of cryptographic material will be unable to differentiate padding from content, so clients SHOULD NOT depend on being able to send large quantities of padding in early data records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
max_early_data_size：このチケットの使用時にクライアントが送信できる0-RTTデータの最大量（バイト単位）。 アプリケーションデータペイロード（つまり、パディングまたは内部コンテンツタイプバイトではなく、プレーンテキスト）のみがカウントされます。 max-early_data_sizeバイトを超える0-RTTデータを受信するサーバーは、「unexpected_message」アラートで接続を終了する必要があります。 暗号化材料の不足により初期データを拒否するサーバーは、コンテンツとパディングを区別できないため、クライアントは初期データレコードで大量のパディングを送信できることに依存してはならないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PSK associated with the ticket is computed as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
チケットに関連付けられたPSKは、次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HKDF-Expand-Label(resumption_master_secret,
                        &#34;resumption&#34;, ticket_nonce, Hash.length)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because the ticket_nonce value is distinct for each NewSessionTicket message, a different PSK will be derived for each ticket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ticket_nonce値はNewSessionTicketメッセージごとに異なるため、チケットごとに異なるPSKが導出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that in principle it is possible to continue issuing new tickets which indefinitely extend the lifetime of the keying material originally derived from an initial non-PSK handshake (which was most likely tied to the peer&#39;s certificate). It is RECOMMENDED that implementations place limits on the total lifetime of such keying material; these limits should take into account the lifetime of the peer&#39;s certificate, the likelihood of intervening revocation, and the time since the peer&#39;s online CertificateVerify signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
原則として、最初に非PSKハンドシェイク（ピアの証明書に結び付けられている可能性が最も高い）から最初に導出されたキー情報の有効期間を無期限に延長する新しいチケットを発行し続けることができることに注意してください。 実装では、このような鍵素材の総寿命に制限を設けることが推奨されます。 これらの制限では、ピアの証明書の有効期間、取り消しの介入の可能性、およびピアのオンラインCertificateVerify署名からの時間を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. Post-Handshake Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2。 ハンドシェイク後認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the client has sent the &#34;post_handshake_auth&#34; extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message. The client MUST respond with the appropriate Authentication messages (see Section 4.4). If the client chooses to authenticate, it MUST send Certificate, CertificateVerify, and Finished. If it declines, it MUST send a Certificate message containing no certificates followed by Finished. All of the client&#39;s messages for a given response MUST appear consecutively on the wire with no intervening messages of other types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントが「post_handshake_auth」拡張機能（セクション4.2.6を参照）を送信すると、サーバーはCertificateRequestメッセージを送信してハンドシェイクが完了した後、いつでもクライアント認証を要求できます。 クライアントは適切な認証メッセージで応答しなければなりません（セクション4.4を参照）。 クライアントが認証を選択した場合、証明書、CertificateVerify、およびFinishedを送信する必要があります。 拒否する場合、証明書を含まない証明書メッセージを送信し、その後に「完了」を送信する必要があります。 所定の応答に対するクライアントのメッセージはすべて、他のタイプのメッセージを介在させずに、連続してネットワーク上に表示される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client that receives a CertificateRequest message without having sent the &#34;post_handshake_auth&#34; extension MUST send an &#34;unexpected_message&#34; fatal alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「post_handshake_auth」拡張機能を送信せずにCertificateRequestメッセージを受信したクライアントは、「unexpected_message」致命的なアラートを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response. In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received (the certificate_request_context value allows the server to disambiguate the responses).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：クライアント認証にはユーザーへのプロンプトが含まれる可能性があるため、サーバーはCertificateRequestの送信と応答の受信の間に任意の数の他のメッセージを受信することを含め、ある程度の遅延に備えなければなりません。 さらに、複数のCertificateRequestを連続して受信するクライアントは、受信した順序とは異なる順序で応答する場合があります（certificate_request_context値により、サーバーは応答を明確にすることができます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. Key and Initialization Vector Update
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3。 キーと初期化ベクトルの更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys. This message can be sent by either peer after it has sent a Finished message. Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an &#34;unexpected_message&#34; alert. After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2. Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
KeyUpdateハンドシェイクメッセージは、送信者が送信暗号キーを更新していることを示すために使用されます。 このメッセージは、Finishedメッセージを送信した後、どちらのピアからも送信できます。 Finishedメッセージを受信する前にKeyUpdateメッセージを受信する実装は、「unexpected_message」アラートで接続を終了する必要があります。 KeyUpdateメッセージを送信した後、送信者は、セクション7.2で説明されているように計算された次世代のキーを使用して、すべてのトラフィックを送信する必要があります。 KeyUpdateを受信すると、受信者は受信キーを更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum { update_not_requested(0), update_requested(1), (255) } KeyUpdateRequest;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum {update_not_requested（0）、update_requested（1）、（255）} KeyUpdateRequest;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
request_update: Indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. If an implementation receives any other value, it MUST terminate the connection with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
request_update：KeyUpdateの受信者が独自のKeyUpdateで応答するかどうかを示します。 実装が他の値を受け取った場合、「illegal_parameter」アラートで接続を終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the request_update field is set to &#34;update_requested&#34;, then the receiver MUST send a KeyUpdate of its own with request_update set to &#34;update_not_requested&#34; prior to sending its next Application Data record. This mechanism allows either side to force an update to the entire connection, but causes an implementation which receives multiple KeyUpdates while it is silent to respond with a single update. Note that implementations may receive an arbitrary number of messages between sending a KeyUpdate with request_update set to &#34;update_requested&#34; and receiving the peer&#39;s KeyUpdate, because those messages may already be in flight. However, because send and receive keys are derived from independent traffic secrets, retaining the receive traffic secret does not threaten the forward secrecy of data sent before the sender changed keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
request_updateフィールドが「update_requested」に設定されている場合、受信者は、次のアプリケーションデータレコードを送信する前にrequest_updateを「update_not_requested」に設定して独自のKeyUpdateを送信する必要があります。 このメカニズムにより、どちらの側も接続全体を強制的に更新できますが、単一の更新で応答することをサイレントにしながら複数のKeyUpdateを受信する実装が発生します。 request_updateを &#34;update_requested&#34;に設定してKeyUpdateを送信してからピアのKeyUpdateを受信するまでの間に、実装は任意の数のメッセージを受信する可能性があることに注意してください。 ただし、送信キーと受信キーは独立したトラフィックシークレットから取得されるため、受信トラフィックシークレットを保持しても、送信者がキーを変更する前に送信されるデータの前方秘匿を脅かすことはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If implementations independently send their own KeyUpdates with request_update set to &#34;update_requested&#34; and they cross in flight, then each side will also send a response, with the result that each side increments by two generations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装がrequest_updateを &#34;update_requested&#34;に設定して独自にKeyUpdatesを個別に送信し、それらが飛行中に交差する場合、各サイドは応答を送信し、その結果、各サイドは2世代ずつ増加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys. Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key. Failure to do so may allow message truncation attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者と受信者の両方が古いキーでKeyUpdateメッセージを暗号化しなければなりません。 さらに、両方の側は、新しいキーで暗号化されたメッセージを受け入れる前に、古いキーでKeyUpdateを受信することを強制する必要があります。 そうしないと、メッセージの切り捨て攻撃が許可される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Record Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.プロトコルの記録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS record protocol takes messages to be transmitted, fragments the data into manageable blocks, protects the records, and transmits the result. Received data is verified, decrypted, reassembled, and then delivered to higher-level clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSレコードプロトコルは、送信されるメッセージを受け取り、データを管理可能なブロックに断片化し、レコードを保護し、結果を送信します。 受信したデータは、検証、復号化、再構築されてから、上位レベルのクライアントに配信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS records are typed, which allows multiple higher-level protocols to be multiplexed over the same record layer. This document specifies four content types: handshake, application_data, alert, and change_cipher_spec. The change_cipher_spec record is used only for compatibility purposes (see Appendix D.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSレコードが入力されるため、複数の高レベルプロトコルを同じレコードレイヤー上で多重化できます。 このドキュメントでは、ハンドシェイク、application_data、alert、change_cipher_specの4つのコンテンツタイプを指定しています。 change_cipher_specレコードは、互換性のためにのみ使用されます（付録D.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer&#39;s Finished message has been received and MUST simply drop it without further processing. Note that this record may appear at a point at the handshake where the implementation is expecting protected records, and so it is necessary to detect this condition prior to attempting to deprotect the record. An implementation which receives any other change_cipher_spec value or which receives a protected change_cipher_spec record MUST abort the handshake with an &#34;unexpected_message&#34; alert. If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer&#39;s Finished message, it MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は、最初のClientHelloメッセージが送信または受信された後、ピアのFinishedメッセージが受信される前に、いつでもシングルバイト値0x01で構成されるchange_cipher_spec型の暗号化されていないレコードを受信し、それ以上処理せずに単にドロップしなければなりません。 このレコードは、実装が保護されたレコードを期待しているハンドシェイクの時点で表示される可能性があるため、レコードの保護を解除する前にこの状態を検出する必要があることに注意してください。 他のchange_cipher_spec値を受け取るか、保護されたchange_cipher_specレコードを受け取る実装は、「unexpected_message」アラートでハンドシェイクを中止しなければなりません。 実装が、最初のClientHelloメッセージの前、またはピアのFinishedメッセージの後に受信したchange_cipher_specレコードを検出した場合、予期しないレコードタイプとして扱わなければなりません（ステートレスサーバーはこれらのケースを許可されたケースと区別できない場合があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations MUST NOT send record types not defined in this document unless negotiated by some extension. If a TLS implementation receives an unexpected record type, it MUST terminate the connection with an &#34;unexpected_message&#34; alert. New record content type values are assigned by IANA in the TLS ContentType registry as described in Section 11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は、何らかの拡張によってネゴシエートされない限り、このドキュメントで定義されていないレコードタイプを送信してはなりません。 TLS実装が予期しないレコードタイプを受信した場合、「unexpected_message」アラートで接続を終了する必要があります。 セクション11で説明されているように、新しいレコードコンテンツタイプ値は、TLS ContentTypeレジストリのIANAによって割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Record Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。 レコード層
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Message boundaries are handled differently depending on the underlying ContentType. Any future content types MUST specify appropriate rules. Note that these rules are stricter than what was enforced in TLS 1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レコード層は、情報ブロックを2 ^ 14バイト以下のチャンクでデータを運ぶTLSPlaintextレコードに断片化します。 メッセージ境界は、基礎となるContentTypeに応じて異なる方法で処理されます。 将来のコンテンツタイプでは、適切なルールを指定する必要があります。 これらの規則は、TLS 1.2で施行されたものよりも厳しいことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Handshake messages MAY be coalesced into a single TLSPlaintext record or fragmented across several records, provided that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェイクメッセージは、単一のTLSPlaintextレコードに結合されるか、複数のレコードに分割される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Handshake messages MUST NOT be interleaved with other record types. That is, if a handshake message is split over two or more records, there MUST NOT be any other records between them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-ハンドシェイクメッセージは、他のレコードタイプとインターリーブしてはなりません。 つまり、ハンドシェイクメッセージが2つ以上のレコードに分割される場合、それらの間に他のレコードがあってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Handshake messages MUST NOT span key changes. Implementations MUST verify that all messages immediately preceding a key change align with a record boundary; if not, then they MUST terminate the connection with an &#34;unexpected_message&#34; alert. Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-ハンドシェイクメッセージは、キーの変更にまたがってはなりません。 実装は、キー変更の直前のすべてのメッセージがレコード境界に沿っていることを確認する必要があります。 そうでない場合は、「unexpected_message」アラートで接続を終了する必要があります。 ClientHello、EndOfEarlyData、ServerHello、Finished、およびKeyUpdateメッセージはキー変更の直前に送信できるため、実装はこれらのメッセージをレコード境界に合わせて送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations MUST NOT send zero-length fragments of Handshake types, even if those fragments contain padding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は、それらのフラグメントにパディングが含まれている場合でも、ハンドシェイクタイプの長さゼロのフラグメントを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Alert messages (Section 6) MUST NOT be fragmented across records, and multiple alert messages MUST NOT be coalesced into a single TLSPlaintext record. In other words, a record with an Alert type MUST contain exactly one message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アラートメッセージ（セクション6）はレコード間で断片化してはならず、複数のアラートメッセージを単一のTLSPlaintextレコードに結合してはなりません。 言い換えると、Alertタイプのレコードには、メッセージを1つだけ含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Application Data messages contain data that is opaque to TLS. Application Data messages are always protected. Zero-length fragments of Application Data MAY be sent, as they are potentially useful as a traffic analysis countermeasure. Application Data fragments MAY be split across multiple records or coalesced into a single record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションデータメッセージには、TLSに対して不透明なデータが含まれています。 アプリケーションデータメッセージは常に保護されます。 アプリケーションデータの長さゼロのフラグメントは、トラフィック分析対策として潜在的に有用であるため、送信できます。 アプリケーションデータフラグメントは、複数のレコードに分割するか、単一のレコードに合体させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum { invalid(0), change_cipher_spec(20), alert(21), handshake(22), application_data(23), (255) } ContentType;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
列挙型{invalid（0）、change_cipher_spec（20）、alert（21）、handshake（22）、application_data（23）、（255）} ContentType;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
type: The higher-level protocol used to process the enclosed fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
type：囲まれたフラグメントの処理に使用される高レベルのプロトコル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_record_version: MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello (i.e., one not generated after a HelloRetryRequest), where it MAY also be 0x0301 for compatibility purposes. This field is deprecated and MUST be ignored for all purposes. Previous versions of TLS would use other values in this field under some circumstances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_record_version：初期ClientHello（つまり、HelloRetryRequestの後に生成されないもの）以外のTLS 1.3実装によって生成されたすべてのレコードの0x0303に設定する必要があります。互換性のために0x0301にすることもできます。 このフィールドは非推奨であり、すべての目的で無視する必要があります。 TLSの以前のバージョンでは、状況によってはこのフィールドに他の値を使用していました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
length: The length (in bytes) of the following TLSPlaintext.fragment. The length MUST NOT exceed 2^14 bytes. An endpoint that receives a record that exceeds this length MUST terminate the connection with a &#34;record_overflow&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
length：次のTLSPlaintext.fragmentの長さ（バイト単位）。 長さは2 ^ 14バイトを超えてはなりません。 この長さを超えるレコードを受信するエンドポイントは、「record_overflow」アラートで接続を終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
fragment: The data being transmitted. This value is transparent and is treated as an independent block to be dealt with by the higher-level protocol specified by the type field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フラグメント：送信されるデータ。 この値は透過的であり、typeフィールドで指定された上位プロトコルで処理される独立したブロックとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document describes TLS 1.3, which uses the version 0x0304. This version value is historical, deriving from the use of 0x0301 for TLS 1.0 and 0x0300 for SSL 3.0. In order to maximize backward compatibility, a record containing an initial ClientHello SHOULD have version 0x0301 (reflecting TLS 1.0) and a record containing a second ClientHello or a ServerHello MUST have version 0x0303 (reflecting TLS 1.2). When negotiating prior versions of TLS, endpoints follow the procedure and requirements provided in Appendix D.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントでは、バージョン0x0304を使用するTLS 1.3について説明します。 このバージョン値は歴史的であり、TLS 1.0では0x0301、SSL 3.0では0x0300を使用しています。 後方互換性を最大化するために、初期ClientHelloを含むレコードはバージョン0x0301（TLS 1.0を反映）を持ち、2番目のClientHelloまたはServerHelloを含むレコードはバージョン0x0303（TLS 1.2を反映）を持たなければなりません。 TLSの以前のバージョンをネゴシエートする場合、エンドポイントは付録Dで提供される手順と要件に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When record protection has not yet been engaged, TLSPlaintext structures are written directly onto the wire. Once record protection has started, TLSPlaintext records are protected and sent as described in the following section. Note that Application Data records MUST NOT be written to the wire unprotected (see Section 2 for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レコード保護がまだ有効になっていない場合、TLSPlaintext構造は直接ワイヤに書き込まれます。 レコード保護が開始されると、TLSPlaintextレコードは保護され、次のセクションで説明するように送信されます。 アプリケーションデータレコードは、保護されていないワイヤに書き込まれてはならないことに注意してください（詳細については、セクション2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Record Payload Protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。 ペイロード保護の記録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The record protection functions translate a TLSPlaintext structure into a TLSCiphertext structure. The deprotection functions reverse the process. In TLS 1.3, as opposed to previous versions of TLS, all ciphers are modeled as &#34;Authenticated Encryption with Associated Data&#34; (AEAD) [RFC5116]. AEAD functions provide a unified encryption and authentication operation which turns plaintext into authenticated ciphertext and back again. Each encrypted record consists of a plaintext header followed by an encrypted body, which itself contains a type and optional padding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レコード保護機能は、TLSPlaintext構造をTLSCiphertext構造に変換します。 脱保護機能はプロセスを逆にします。 TLS 1.3では、以前のバージョンのTLSとは異なり、すべての暗号は「関連データによる認証済み暗号化」（AEAD）[RFC5116]としてモデル化されています。 AEAD機能は、平文を認証済み暗号文に変換し、再び元に戻す、統一された暗号化および認証操作を提供します。 暗号化された各レコードは、プレーンテキストヘッダーとそれに続く暗号化された本文で構成されます。暗号化された本文には、タイプとオプションのパディングが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
content: The TLSPlaintext.fragment value, containing the byte encoding of a handshake or an alert message, or the raw bytes of the application&#39;s data to send.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
内容：TLSPlaintext.fragment値。ハンドシェイクまたはアラートメッセージのバイトエンコード、または送信するアプリケーションデータの生バイトを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
type: The TLSPlaintext.type value containing the content type of the record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
type：レコードのコンテンツタイプを含むTLSPlaintext.type値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
zeros: An arbitrary-length run of zero-valued bytes may appear in the cleartext after the type field. This provides an opportunity for senders to pad any TLS record by a chosen amount as long as the total stays within record size limits. See Section 5.4 for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ゼロ：ゼロ値のバイトの任意の長さの実行が、タイプフィールドの後にクリアテキストに表示される場合があります。 これにより、送信者は、合計がレコードサイズの制限内にある限り、選択した量だけTLSレコードをパディングできます。 詳細については、セクション5.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque_type: The outer opaque_type field of a TLSCiphertext record is always set to the value 23 (application_data) for outward compatibility with middleboxes accustomed to parsing previous versions of TLS. The actual content type of the record is found in TLSInnerPlaintext.type after decryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque_type：TLSCiphertextレコードの外側のopaque_typeフィールドは、以前のバージョンのTLSの解析に慣れているミドルボックスとの外部互換性のために、常に値23（application_data）に設定されます。 レコードの実際のコンテンツタイプは、復号化後にTLSInnerPlaintext.typeで見つかります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_record_version: The legacy_record_version field is always 0x0303. TLS 1.3 TLSCiphertexts are not generated until after TLS 1.3 has been negotiated, so there are no historical compatibility concerns where other values might be received. Note that the handshake protocol, including the ClientHello and ServerHello messages, authenticates the protocol version, so this value is redundant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
legacy_record_version：legacy_record_versionフィールドは常に0x0303です。 TLS 1.3 TLSCiphertextは、TLS 1.3がネゴシエートされるまで生成されないため、他の値が受信される可能性のある歴史的な互換性の問題はありません。 ClientHelloおよびServerHelloメッセージを含むハンドシェイクプロトコルはプロトコルバージョンを認証するため、この値は冗長であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
length: The length (in bytes) of the following TLSCiphertext.encrypted_record, which is the sum of the lengths of the content and the padding, plus one for the inner content type, plus any expansion added by the AEAD algorithm. The length MUST NOT exceed 2^14 + 256 bytes. An endpoint that receives a record that exceeds this length MUST terminate the connection with a &#34;record_overflow&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
length：次のTLSCiphertext.encrypted_recordの長さ（バイト単位）。これは、コンテンツとパディングの長さの合計に、内部コンテンツタイプに1つを加え、AEADアルゴリズムによって追加された拡張を加えたものです。 長さは2 ^ 14 + 256バイトを超えてはなりません。 この長さを超えるレコードを受信するエンドポイントは、「record_overflow」アラートで接続を終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
encrypted_record: The AEAD-encrypted form of the serialized TLSInnerPlaintext structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
encrypted_record：シリアル化されたTLSInnerPlaintext構造のAEAD暗号化形式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
AEAD algorithms take as input a single key, a nonce, a plaintext, and &#34;additional data&#34; to be included in the authentication check, as described in Section 2.1 of [RFC5116]. The key is either the client_write_key or the server_write_key, the nonce is derived from the sequence number and the client_write_iv or server_write_iv (see Section 5.3), and the additional data input is the record header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5116]のセクション2.1で説明されているように、AEADアルゴリズムは、入力として単一のキー、ナンス、プレーンテキスト、および認証チェックに含まれる「追加データ」を受け取ります。 キーはclient_write_keyまたはserver_write_keyのいずれかであり、ノンスはシーケンス番号とclient_write_ivまたはserver_write_iv（セクション5.3を参照）から派生し、追加のデータ入力はレコードヘッダーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
I.e.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
つまり、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
additional_data = TLSCiphertext.opaque_type || TLSCiphertext.legacy_record_version || TLSCiphertext.length
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
additional_data = TLSCiphertext.opaque_type || TLSCiphertext.legacy_record_version || TLSCiphertext.length
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The plaintext input to the AEAD algorithm is the encoded TLSInnerPlaintext structure. Derivation of traffic keys is defined in Section 7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AEADアルゴリズムへのプレーンテキスト入力は、エンコードされたTLSInnerPlaintext構造です。 トラフィックキーの派生は、セクション7.3で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The AEAD output consists of the ciphertext output from the AEAD encryption operation. The length of the plaintext is greater than the corresponding TLSPlaintext.length due to the inclusion of TLSInnerPlaintext.type and any padding supplied by the sender. The length of the AEAD output will generally be larger than the plaintext, but by an amount that varies with the AEAD algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AEAD出力は、AEAD暗号化操作からの暗号文出力で構成されます。 平文の長さは、TLSInnerPlaintext.typeと送信者が提供するパディングが含まれているため、対応するTLSPlaintext.lengthよりも長くなっています。 AEAD出力の長さは通常、平文よりも長くなりますが、AEADアルゴリズムによって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the ciphers might incorporate padding, the amount of overhead could vary with different lengths of plaintext. Symbolically,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号にはパディングが組み込まれている場合があるため、オーバーヘッドの量はプレーンテキストの長さによって異なる場合があります。 象徴的に、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
AEADEncrypted = AEAD-Encrypt(write_key, nonce, additional_data, plaintext)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AEADEncrypted = AEAD-Encrypt（write_key、nonce、additional_data、plaintext）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The encrypted_record field of TLSCiphertext is set to AEADEncrypted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSCiphertextのencrypted_recordフィールドは、AEADEncryptedに設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to decrypt and verify, the cipher takes as input the key, nonce, additional data, and the AEADEncrypted value. The output is either the plaintext or an error indicating that the decryption failed. There is no separate integrity check. Symbolically,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号化を解除して検証するために、暗号は入力としてキー、ノンス、追加データ、およびAEADEncrypted値を受け取ります。 出力は、平文または復号化が失敗したことを示すエラーです。 個別の整合性チェックはありません。 象徴的に、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
plaintext of encrypted_record = AEAD-Decrypt(peer_write_key, nonce, additional_data, AEADEncrypted)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
encrypted_recordの平文= AEAD-Decrypt（peer_write_key、nonce、additional_data、AEADEncrypted）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the decryption fails, the receiver MUST terminate the connection with a &#34;bad_record_mac&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
復号化に失敗した場合、受信者は「bad_record_mac」アラートで接続を終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion greater than 255 octets. An endpoint that receives a record from its peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST terminate the connection with a &#34;record_overflow&#34; alert. This limit is derived from the maximum TLSInnerPlaintext length of 2^14 octets + 1 octet for ContentType + the maximum AEAD expansion of 255 octets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3で使用されるAEADアルゴリズムは、255オクテットを超える拡張を生成してはなりません。 TLSCiphertext.lengthが2 ^ 14 + 256オクテットより大きいピアからレコードを受信するエンドポイントは、「record_overflow」アラートで接続を終了する必要があります。 この制限は、TLSInnerPlaintextの最大長2 ^ 14オクテット+ ContentTypeの1オクテット+最大AEAD拡張255オクテットから導出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Per-Record Nonce
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3。 レコードごとのノンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A 64-bit sequence number is maintained separately for reading and writing records. The appropriate sequence number is incremented by one after reading or writing each record. Each sequence number is set to zero at the beginning of a connection and whenever the key is changed; the first record transmitted under a particular traffic key MUST use sequence number 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
64ビットのシーケンス番号は、レコードの読み取りと書き込みのために個別に維持されます。 適切なシーケンス番号は、各レコードの読み取りまたは書き込み後に1ずつ増加します。 各シーケンス番号は、接続の開始時およびキーが変更されるたびにゼロに設定されます。 特定のトラフィックキーの下で送信される最初のレコードは、シーケンス番号0を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because the size of sequence numbers is 64-bit, they should not wrap. If a TLS implementation would need to wrap a sequence number, it MUST either rekey (Section 4.6.3) or terminate the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シーケンス番号のサイズは64ビットであるため、折り返さないでください。 TLS実装がシーケンス番号をラップする必要がある場合、キーを再生成（セクション4.6.3）するか、接続を終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each AEAD algorithm will specify a range of possible lengths for the per-record nonce, from N_MIN bytes to N_MAX bytes of input [RFC5116]. The length of the TLS per-record nonce (iv_length) is set to the larger of 8 bytes and N_MIN for the AEAD algorithm (see [RFC5116], Section 4). An AEAD algorithm where N_MAX is less than 8 bytes MUST NOT be used with TLS. The per-record nonce for the AEAD construction is formed as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各AEADアルゴリズムは、入力ごとのN_MINバイトからN_MAXバイトまでのレコードごとのノンスの可能な長さの範囲を指定します[RFC5116]。 TLSレコードごとのノンスの長さ（iv_length）は、AEADアルゴリズムの8バイトとN_MINの大きい方に設定されます（[RFC5116]、セクション] 4を参照）。 N_MAXが8バイト未満のAEADアルゴリズムは、TLSと共に使用してはなりません（MUST NOT）。 AEAD構造のレコードごとのナンスは、次のように形成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. The 64-bit record sequence number is encoded in network byte order and padded to the left with zeros to iv_length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. 64ビットのレコードシーケンス番号は、ネットワークバイト順でエンコードされ、iv_lengthまでゼロが左側に埋め込まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. The padded sequence number is XORed with either the static client_write_iv or server_write_iv (depending on the role).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.埋め込まれたシーケンス番号は、静的なclient_write_ivまたはserver_write_iv（役割に応じて）とXORされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The resulting quantity (of length iv_length) is used as the per-record nonce.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
結果の量（長さiv_length）は、レコードごとのノンスとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: This is a different construction from that in TLS 1.2, which specified a partially explicit nonce.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：これは、部分的に明示的なナンスを指定したTLS 1.2の構成とは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Record Padding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4。 レコードのパディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All encrypted TLS records can be padded to inflate the size of the TLSCiphertext. This allows the sender to hide the size of the traffic from an observer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号化されたすべてのTLSレコードをパディングして、TLSCiphertextのサイズを拡張できます。 これにより、送信者はオブザーバーからトラフィックのサイズを隠すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When generating a TLSCiphertext record, implementations MAY choose to pad. An unpadded record is just a record with a padding length of zero. Padding is a string of zero-valued bytes appended to the ContentType field before encryption. Implementations MUST set the padding octets to all zeros before encrypting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSCiphertextレコードを生成するとき、実装は埋め込みを選択できます。 パディングなしのレコードは、パディングの長さがゼロの単なるレコードです。 パディングは、暗号化の前にContentTypeフィールドに追加されるゼロ値バイトの文字列です。 実装は、暗号化の前にパディングオクテットをすべてゼロに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Application Data records may contain a zero-length TLSInnerPlaintext.content if the sender desires. This permits generation of plausibly sized cover traffic in contexts where the presence or absence of activity may be sensitive. Implementations MUST NOT send Handshake and Alert records that have a zero-length TLSInnerPlaintext.content; if such a message is received, the receiving implementation MUST terminate the connection with an &#34;unexpected_message&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者が希望する場合、アプリケーションデータレコードには長さゼロのTLSInnerPlaintext.contentが含まれる場合があります。 これにより、アクティビティの有無が重要な状況で、妥当なサイズのカバートラフィックを生成できます。 実装は、長さがゼロのTLSInnerPlaintext.contentを持つHandshakeおよびAlertレコードを送信してはなりません。 そのようなメッセージが受信された場合、受信実装は「unexpected_message」アラートで接続を終了しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The padding sent is automatically verified by the record protection mechanism; upon successful decryption of a TLSCiphertext.encrypted_record, the receiving implementation scans the field from the end toward the beginning until it finds a non-zero octet. This non-zero octet is the content type of the message. This padding scheme was selected because it allows padding of any encrypted TLS record by an arbitrary size (from zero up to TLS record size limits) without introducing new content types. The design also enforces all-zero padding octets, which allows for quick detection of padding errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信されたパディングは、レコード保護メカニズムによって自動的に検証されます。 TLSCiphertext.encrypted_recordの復号化に成功すると、受信実装は、ゼロ以外のオクテットが見つかるまで、フィールドを最後から最初に向かってスキャンします。 このゼロ以外のオクテットは、メッセージのコンテンツタイプです。 このパディング方式が選択されたのは、新しいコンテンツタイプを導入することなく、任意のサイズ（ゼロからTLSレコードサイズ制限まで）で暗号化されたTLSレコードをパディングできるためです。 この設計では、すべてゼロのパディングオクテットも適用されます。これにより、パディングエラーをすばやく検出できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations MUST limit their scanning to the cleartext returned from the AEAD decryption. If a receiving implementation does not find a non-zero octet in the cleartext, it MUST terminate the connection with an &#34;unexpected_message&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は、スキャンをAEAD復号化から返されたクリアテキストに制限する必要があります。 受信側の実装がクリアテキストでゼロ以外のオクテットを見つけられない場合、「unexpected_message」アラートで接続を終了する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The presence of padding does not change the overall record size limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14 + 1 octets. If the maximum fragment length is reduced -- as, for example, by the record_size_limit extension from [RFC8449] -- then the reduced limit applies to the full plaintext, including the content type and padding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パディングの存在は、全体的なレコードサイズの制限を変更しません。完全にエンコードされたTLSInnerPlaintextは、2 ^ 14 + 1オクテットを超えてはなりません。 [RFC8449]のrecord_size_limit拡張などにより、最大フラグメント長が短縮される場合、短縮された制限は、コンテンツタイプとパディングを含む完全なプレーンテキストに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Selecting a padding policy that suggests when and how much to pad is a complex topic and is beyond the scope of this specification. If the application-layer protocol on top of TLS has its own padding, it may be preferable to pad Application Data TLS records within the application layer. Padding for encrypted Handshake or Alert records must still be handled at the TLS layer, though. Later documents may define padding selection algorithms or define a padding policy request mechanism through TLS extensions or some other means.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パディングする時期と量を提案するパディングポリシーを選択することは複雑なトピックであり、この仕様の範囲外です。 TLS上のアプリケーション層プロトコルに独自のパディングがある場合、アプリケーション層内のアプリケーションデータTLSレコードをパディングすることが望ましい場合があります。 ただし、暗号化されたハンドシェイクまたはアラートレコードのパディングは、TLSレイヤーで処理する必要があります。 後の文書では、パディング選択アルゴリズムを定義するか、TLS拡張機能またはその他の手段を介してパディングポリシー要求メカニズムを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Limits on Key Usage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5。 キー使用の制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are cryptographic limits on the amount of plaintext which can be safely encrypted under a given set of keys. [AEAD-LIMITS] provides an analysis of these limits under the assumption that the underlying primitive (AES or ChaCha20) has no weaknesses. Implementations SHOULD do a key update as described in Section 4.6.3 prior to reaching these limits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特定のキーセットで安全に暗号化できるプレーンテキストの量には暗号化の制限があります。 [AEAD-LIMITS]は、基礎となるプリミティブ（AESまたはChaCha20）に弱点がないという仮定の下で、これらの制限の分析を提供します。 実装は、これらの制限に達する前に、セクション4.6.3で説明されているように、主要な更新を行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For AES-GCM, up to 2^24.5 full-size records (about 24 million) may be encrypted on a given connection while keeping a safety margin of approximately 2^-57 for Authenticated Encryption (AE) security. For ChaCha20/Poly1305, the record sequence number would wrap before the safety limit is reached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AES-GCMの場合、認証済み暗号化（AE）セキュリティのために約2 ^ -57の安全マージンを維持しながら、最大2 ^ 24.5のフルサイズレコード（約2,400万）を特定の接続で暗号化できます。 ChaCha20 / Poly1305の場合、安全制限に達する前にレコードシーケンス番号がラップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Alert Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.アラートプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS provides an Alert content type to indicate closure information and errors. Like other messages, alert messages are encrypted as specified by the current connection state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、閉鎖情報とエラーを示すAlertコンテンツタイプを提供します。 他のメッセージと同様に、アラートメッセージは現在の接続状態の指定に従って暗号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Alert messages convey a description of the alert and a legacy field that conveyed the severity level of the message in previous versions of TLS. Alerts are divided into two classes: closure alerts and error alerts. In TLS 1.3, the severity is implicit in the type of alert being sent, and the &#34;level&#34; field can safely be ignored. The &#34;close_notify&#34; alert is used to indicate orderly closure of one direction of the connection. Upon receiving such an alert, the TLS implementation SHOULD indicate end-of-data to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アラートメッセージは、アラートの説明と、以前のバージョンのTLSのメッセージの重大度レベルを伝達したレガシーフィールドを伝達します。 アラートは、閉鎖アラートとエラーアラートの2つのクラスに分類されます。 TLS 1.3では、送信されるアラートのタイプに重大度が暗黙的に含まれており、「レベル」フィールドは無視しても問題ありません。 「close_notify」アラートは、接続の一方向の秩序ある閉鎖を示すために使用されます。 そのようなアラートを受信すると、TLS実装はデータの終わりをアプリケーションに示す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Error alerts indicate abortive closure of the connection (see Section 6.2). Upon receiving an error alert, the TLS implementation SHOULD indicate an error to the application and MUST NOT allow any further data to be sent or received on the connection. Servers and clients MUST forget the secret values and keys established in failed connections, with the exception of the PSKs associated with session tickets, which SHOULD be discarded if possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エラーアラートは、接続の強制終了を示します（セクション6.2を参照）。 エラーアラートを受信すると、TLS実装はアプリケーションにエラーを通知する必要があり（SHOULD）、接続上でデータの送受信を許可してはなりません（MUST NOT）。 サーバーとクライアントは、セッションチケットに関連付けられているPSKを除き、失敗した接続で確立された秘密の値とキーを忘れなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All the alerts listed in Section 6.2 MUST be sent with AlertLevel=fatal and MUST be treated as error alerts when received regardless of the AlertLevel in the message. Unknown Alert types MUST be treated as error alerts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション6.2にリストされているすべてのアラートは、AlertLevel = fatalで送信する必要があり、メッセージ内のAlertLevelに関係なく受信した場合、エラーアラートとして扱わなければなりません。 不明なアラートタイプはエラーアラートとして扱わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: TLS defines two generic alerts (see Section 6) to use upon failure to parse a message. Peers which receive a message which cannot be parsed according to the syntax (e.g., have a length extending beyond the message boundary or contain an out-of-range length) MUST terminate the connection with a &#34;decode_error&#34; alert. Peers which receive a message which is syntactically correct but semantically invalid (e.g., a DHE share of p - 1, or an invalid enum) MUST terminate the connection with an &#34;illegal_parameter&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：TLSは、メッセージの解析に失敗したときに使用する2つの汎用アラート（セクション6を参照）を定義します。 構文に従って解析できないメッセージを受信するピア（たとえば、メッセージの境界を超える長さまたは範囲外の長さを含む）は、「decode_error」アラートで接続を終了する必要があります。 構文的には正しいが意味的に無効なメッセージ（たとえば、p-1のDHE共有、または無効な列挙）を受信するピアは、「illegal_parameter」アラートで接続を終了しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum { warning(1), fatal(2), (255) } AlertLevel;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum {warning（1）、fatal（2）、（255）} AlertLevel;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum { close_notify(0), unexpected_message(10), bad_record_mac(20), record_overflow(22), handshake_failure(40), bad_certificate(42), unsupported_certificate(43), certificate_revoked(44), certificate_expired(45), certificate_unknown(46), illegal_parameter(47), unknown_ca(48), access_denied(49), decode_error(50), decrypt_error(51), protocol_version(70), insufficient_security(71), internal_error(80), inappropriate_fallback(86), user_canceled(90), missing_extension(109), unsupported_extension(110), unrecognized_name(112), bad_certificate_status_response(113), unknown_psk_identity(115), certificate_required(116), no_application_protocol(120), (255) } AlertDescription;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum {close_notify（0）、unexpected_message（10）、bad_record_mac（20）、record_overflow（22）、handshake_failure（40）、bad_certificate（42）、unsupported_certificate（43）、certificate_revoked（44）、certificate_expired（45）、certificate_unknown（46 ）、illegal_parameter（47）、unknown_ca（48）、access_denied（49）、decode_error（50）、decrypt_error（51）、protocol_version（70）、不十分なセキュリティ（71）、internal_error（80）、inappropriate_fallback（86）、user_canceled（90 ）、missing_extension（109）、unsupported_extension（110）、unrecognized_name（112）、bad_certificate_status_response（113）、unknown_psk_identity（115）、certificate_required（116）、no_application_protocol（120）、（255）} AlertDescription;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Closure Alerts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1。 閉鎖アラート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバーは、切断攻撃を回避するために、接続が終了するという知識を共有する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
close_notify: This alert notifies the recipient that the sender will not send any more messages on this connection. Any data received after a closure alert has been received MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
close_notify：このアラートは、送信者がこの接続でこれ以上メッセージを送信しないことを受信者に通知します。 閉鎖アラートを受信した後に受信したデータは無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
user_canceled: This alert notifies the recipient that the sender is canceling the handshake for some reason unrelated to a protocol failure. If a user cancels an operation after the handshake is complete, just closing the connection by sending a &#34;close_notify&#34; is more appropriate. This alert SHOULD be followed by a &#34;close_notify&#34;. This alert generally has AlertLevel=warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
user_canceled：このアラートは、送信者がプロトコル障害とは無関係の何らかの理由でハンドシェイクをキャンセルしていることを受信者に通知します。 ハンドシェイクの完了後にユーザーが操作をキャンセルした場合、「close_notify」を送信して接続を閉じるだけの方が適切です。 このアラートには、「close_notify」が続く必要があります。 通常、このアラートにはAlertLevel = warningがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Either party MAY initiate a close of its write side of the connection by sending a &#34;close_notify&#34; alert. Any data received after a closure alert has been received MUST be ignored. If a transport-level close is received prior to a &#34;close_notify&#34;, the receiver cannot know that all the data that was sent has been received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どちらの当事者も、「close_notify」アラートを送信することにより、接続の書き込み側の終了を開始できます。 閉鎖アラートを受信した後に受信したデータは無視する必要があります。 「close_notify」の前にトランスポートレベルのクローズが受信された場合、受信者は送信されたすべてのデータが受信されたことを知ることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each party MUST send a &#34;close_notify&#34; alert before closing its write side of the connection, unless it has already sent some error alert. This does not have any effect on its read side of the connection. Note that this is a change from versions of TLS prior to TLS 1.3 in which implementations were required to react to a &#34;close_notify&#34; by discarding pending writes and sending an immediate &#34;close_notify&#34; alert of their own. That previous requirement could cause truncation in the read side. Both parties need not wait to receive a &#34;close_notify&#34; alert before closing their read side of the connection, though doing so would introduce the possibility of truncation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エラーアラートを既に送信していない限り、各パーティは接続の書き込み側を閉じる前に「close_notify」アラートを送信する必要があります。 これは、接続の読み取り側には影響しません。 これは、保留中の書き込みを破棄し、独自の即時の「close_notify」アラートを送信することにより、実装が「close_notify」に対応する必要があるTLS 1.3より前のTLSのバージョンからの変更であることに注意してください。 その以前の要件は、読み取り側で切り捨てを引き起こす可能性がありました。 両者は、接続の読み取り側を閉じる前に「close_notify」アラートを受信するのを待つ必要はありませんが、そうすると切り捨ての可能性が生じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation MUST receive a &#34;close_notify&#34; alert before indicating end-of-data to the application layer. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS接続が閉じられた後、TLSを使用するアプリケーションプロトコルが基礎となるトランスポートを介してデータを運ぶことができる場合、TLS実装はアプリケーション層にデータの終わりを示す前に「close_notify」アラートを受信する必要があります。 接続のオープン時やクローズ時など、TLSの使用プロファイルがデータ転送を管理する方法を規定するために、この規格の一部をとるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: It is assumed that closing the write side of a connection reliably delivers pending data before destroying the transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：接続の書き込み側を閉じると、トランスポートを破棄する前に保留中のデータが確実に配信されると想定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Error Alerts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2。 エラーアラート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Error handling in TLS is very simple. When an error is detected, the detecting party sends a message to its peer. Upon transmission or receipt of a fatal alert message, both parties MUST immediately close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSでのエラー処理は非常に簡単です。 エラーが検出されると、検出側はピアにメッセージを送信します。 致命的な警告メッセージを送信または受信すると、両方の当事者はすぐに接続を閉じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever an implementation encounters a fatal error condition, it SHOULD send an appropriate fatal alert and MUST close the connection without sending or receiving any additional data. In the rest of this specification, when the phrases &#34;terminate the connection&#34; and &#34;abort the handshake&#34; are used without a specific alert it means that the implementation SHOULD send the alert indicated by the descriptions below. The phrases &#34;terminate the connection with an X alert&#34; and &#34;abort the handshake with an X alert&#34; mean that the implementation MUST send alert X if it sends any alert. All alerts defined below in this section, as well as all unknown alerts, are universally considered fatal as of TLS 1.3 (see Section 6). The implementation SHOULD provide a way to facilitate logging the sending and receiving of alerts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装が致命的なエラー状態に遭遇するたびに、適切な致命的なアラートを送信する必要があり（SHOULD）、追加のデータを送受信しないで接続を閉じなければなりません。 この仕様の残りの部分で、「接続を終了する」および「ハンドシェイクを中止する」というフレーズが特定のアラートなしで使用される場合、実装は以下の説明で示されるアラートを送信する必要があります。 「Xアラートで接続を終了する」および「Xアラートでハンドシェイクを中止する」というフレーズは、実装がアラートを送信する場合、アラートXを送信する必要があることを意味します。 このセクションで以下で定義されるすべてのアラート、およびすべての未知のアラートは、TLS 1.3の時点で一般的に致命的と見なされます（セクション6を参照）。 実装は、アラートの送信と受信のログ記録を容易にする方法を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following error alerts are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のエラーアラートが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
unexpected_message: An inappropriate message (e.g., the wrong handshake message, premature Application Data, etc.) was received. This alert should never be observed in communication between proper implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
unexpected_message：不適切なメッセージ（間違ったハンドシェイクメッセージ、時期尚早なアプリケーションデータなど）を受信しました。 このアラートは、適切な実装間の通信では決して観察されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
bad_record_mac: This alert is returned if a record is received which cannot be deprotected. Because AEAD algorithms combine decryption and verification, and also to avoid side-channel attacks, this alert is used for all deprotection failures. This alert should never be observed in communication between proper implementations, except when messages were corrupted in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
bad_record_mac：このアラートは、保護を解除できないレコードを受信した場合に返されます。 AEADアルゴリズムは復号化と検証を組み合わせており、サイドチャネル攻撃を回避するため、このアラートはすべての保護解除エラーに使用されます。 このアラートは、ネットワーク内でメッセージが破損した場合を除き、適切な実装間の通信では決して観察されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
record_overflow: A TLSCiphertext record was received that had a length more than 2^14 + 256 bytes, or a record decrypted to a TLSPlaintext record with more than 2^14 bytes (or some other negotiated limit). This alert should never be observed in communication between proper implementations, except when messages were corrupted in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
record_overflow：長さが2 ^ 14 + 256バイトを超えるTLSCiphertextレコード、または2 ^ 14バイトを超えるTLSPlaintextレコードに暗号化解除されたレコード（またはその他のネゴシエートされた制限）が受信されました。 このアラートは、ネットワーク内でメッセージが破損した場合を除き、適切な実装間の通信では決して観察されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
handshake_failure: Receipt of a &#34;handshake_failure&#34; alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
handshake_failure： &#34;handshake_failure&#34;アラートメッセージの受信は、送信者が利用可能なオプションが与えられたセキュリティパラメーターの許容セットをネゴシエートできなかったことを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
bad_certificate: A certificate was corrupt, contained signatures that did not verify correctly, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
bad_certificate：証明書が破損しているか、正しく検証されていない署名が含まれているなど。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
unsupported_certificate: A certificate was of an unsupported type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
unsupported_certificate：証明書はサポートされていないタイプでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_revoked: A certificate was revoked by its signer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_revoked：署名者によって証明書が取り消されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_expired: A certificate has expired or is not currently valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_expired：証明書の有効期限が切れているか、現在有効ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_unknown: Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_unknown：証明書の処理中に他の（不特定の）問題が発生し、受け入れられなくなりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
illegal_parameter: A field in the handshake was incorrect or inconsistent with other fields. This alert is used for errors which conform to the formal protocol syntax but are otherwise incorrect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
illegal_parameter：ハンドシェイクのフィールドが正しくないか、他のフィールドと矛盾しています。 このアラートは、正式なプロトコル構文に準拠しているが、それ以外は誤りであるエラーに使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
unknown_ca: A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or could not be matched with a known trust anchor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
unknown_ca：有効な証明書チェーンまたは部分チェーンが受信されましたが、CA証明書が見つからないか、既知のトラストアンカーと一致しないため、証明書は受け入れられませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
access_denied: A valid certificate or PSK was received, but when access control was applied, the sender decided not to proceed with negotiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
access_denied：有効な証明書またはPSKを受信しましたが、アクセス制御が適用されたときに、送信者はネゴシエーションを続行しないことを決定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
decode_error: A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This alert is used for errors where the message does not conform to the formal protocol syntax. This alert should never be observed in communication between proper implementations, except when messages were corrupted in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
decode_error：一部のフィールドが指定された範囲外であるか、メッセージの長さが間違っていたため、メッセージをデコードできませんでした。 このアラートは、メッセージが正式なプロトコル構文に準拠していないエラーに使用されます。 このアラートは、ネットワーク内でメッセージが破損した場合を除き、適切な実装間の通信では決して観察されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
decrypt_error: A handshake (not record layer) cryptographic operation failed, including being unable to correctly verify a signature or validate a Finished message or a PSK binder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
decrypt_error：ハンドシェイク（レコード層ではない）暗号化操作が失敗しました。これには、署名を正しく検証できないか、FinishedメッセージまたはPSKバインダーを検証できないことが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
protocol_version: The protocol version the peer has attempted to negotiate is recognized but not supported (see Appendix D).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
protocol_version：ピアがネゴシエートしようとしたプロトコルバージョンは認識されますが、サポートされていません（付録Dを参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
insufficient_security: Returned instead of &#34;handshake_failure&#34; when a negotiation has failed specifically because the server requires parameters more secure than those supported by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不十分なセキュリティ：サーバーがクライアントでサポートされているパラメータよりも安全なパラメータを必要とするため、ネゴシエーションが失敗した場合に「handshake_failure」の代わりに返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
internal_error: An internal error unrelated to the peer or the correctness of the protocol (such as a memory allocation failure) makes it impossible to continue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
internal_error：ピアまたはプロトコルの正確性とは関係のない内部エラー（メモリ割り当ての失敗など）により、続行できなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
inappropriate_fallback: Sent by a server in response to an invalid connection retry attempt from a client (see [RFC7507]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不適切なフォールバック：クライアントからの無効な接続再試行に応答してサーバーによって送信されます（[RFC7507]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
missing_extension: Sent by endpoints that receive a handshake message not containing an extension that is mandatory to send for the offered TLS version or other negotiated parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
missing_extension：提供されたTLSバージョンまたはその他のネゴシエートされたパラメータの送信に必須である拡張機能を含まないハンドシェイクメッセージを受信するエンドポイントによって送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
unsupported_extension: Sent by endpoints receiving any handshake message containing an extension known to be prohibited for inclusion in the given handshake message, or including any extensions in a ServerHello or Certificate not first offered in the corresponding ClientHello or CertificateRequest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
unsupported_extension：指定されたハンドシェイクメッセージに含めることが禁止されている拡張機能を含む、または対応するClientHelloまたはCertificateRequestで最初に提供されないServerHelloまたはCertificateの拡張機能を含むハンドシェイクメッセージを受信するエンドポイントによって送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
unrecognized_name: Sent by servers when no server exists identified by the name provided by the client via the &#34;server_name&#34; extension (see [RFC6066]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
unrecognized_name：「server_name」拡張子を介してクライアントから提供された名前で識別されるサーバーが存在しない場合にサーバーによって送信されます（[RFC6066]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
bad_certificate_status_response: Sent by clients when an invalid or unacceptable OCSP response is provided by the server via the &#34;status_request&#34; extension (see [RFC6066]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
bad_certificate_status_response：無効または受け入れられないOCSP応答が「status_request」拡張機能を介してサーバーから提供されたときにクライアントによって送信されます（[RFC6066]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
unknown_psk_identity: Sent by servers when PSK key establishment is desired but no acceptable PSK identity is provided by the client. Sending this alert is OPTIONAL; servers MAY instead choose to send a &#34;decrypt_error&#34; alert to merely indicate an invalid PSK identity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
unknown_psk_identity：PSKキーの確立が必要であるが、クライアントによって受け入れ可能なPSK IDが提供されない場合にサーバーによって送信されます。 このアラートの送信はオプションです。 サーバーは、代わりに「decrypt_error」アラートを送信して、単に無効なPSK IDを示すことを選択できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_required: Sent by servers when a client certificate is desired but none was provided by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
certificate_required：クライアント証明書が必要であるが、クライアントから何も提供されなかったときにサーバーによって送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
no_application_protocol: Sent by servers when a client &#34;application_layer_protocol_negotiation&#34; extension advertises only protocols that the server does not support (see [RFC7301]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
no_application_protocol：クライアントの「application_layer_protocol_negotiation」拡張機能が、サーバーがサポートしていないプロトコルのみをアドバタイズするときにサーバーによって送信されます（[RFC7301]を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
New Alert values are assigned by IANA as described in Section 11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション11で説明されているように、新しいアラート値はIANAによって割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Cryptographic Computations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.暗号計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS handshake establishes one or more input secrets which are combined to create the actual working keying material, as detailed below. The key derivation process incorporates both the input secrets and the handshake transcript. Note that because the handshake transcript includes the random values from the Hello messages, any given handshake will have different traffic secrets, even if the same input secrets are used, as is the case when the same PSK is used for multiple connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSハンドシェイクは、1つ以上の入力シークレットを確立します。これらのシークレットを組み合わせて、実際の作業キーイングマテリアルを作成します。これについては、以下で詳しく説明します。 キー派生プロセスには、入力シークレットとハンドシェイクのトランスクリプトの両方が組み込まれています。 ハンドシェイクのトランスクリプトにはHelloメッセージからのランダムな値が含まれているため、同じPSKが複数の接続に使用される場合のように、同じ入力シークレットが使用されていても、特定のハンドシェイクには異なるトラフィックシークレットがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Key Schedule
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。 キースケジュール
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key derivation process makes use of the HKDF-Extract and HKDF-Expand functions as defined for HKDF [RFC5869], as well as the functions defined below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
鍵導出プロセスでは、HKDF [RFC5869]で定義されているHKDF-ExtractおよびHKDF-Expand関数、および以下で定義されている関数を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       HKDF-Expand-Label(Secret, Label, Context, Length) =
            HKDF-Expand(Secret, HkdfLabel, Length)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where HkdfLabel is specified as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HkdfLabelは次のように指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       struct {
           uint16 length = Length;
           opaque label&lt;7..255&gt; = &#34;tls13 &#34; + Label;
           opaque context&lt;0..255&gt; = Context;
       } HkdfLabel;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Derive-Secret(Secret, Label, Messages) = HKDF-Expand-Label(Secret, Label, Transcript-Hash(Messages), Hash.length)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Derive-Secret（Secret、Label、Messages）= HKDF-Expand-Label（Secret、Label、Transcript-Hash（Messages）、Hash.length）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Hash function used by Transcript-Hash and HKDF is the cipher suite hash algorithm. Hash.length is its output length in bytes. Messages is the concatenation of the indicated handshake messages, including the handshake message type and length fields, but not including record layer headers. Note that in some cases a zero-length Context (indicated by &#34;&#34;) is passed to HKDF-Expand-Label. The labels specified in this document are all ASCII strings and do not include a trailing NUL byte.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transcript-HashおよびHKDFで使用されるハッシュ関数は、暗号スイートハッシュアルゴリズムです。 Hash.lengthは、バイト単位の出力長です。 メッセージは、示されたハンドシェイクメッセージの連結であり、ハンドシェイクメッセージタイプと長さフィールドを含みますが、レコードレイヤヘッダーは含まれません。 場合によっては、ゼロ長のコンテキスト（ &#34;&#34;で示される）がHKDF-Expand-Labelに渡されることに注意してください。 このドキュメントで指定されているラベルはすべてASCII文字列であり、末尾のNULバイトは含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: With common hash functions, any label longer than 12 characters requires an additional iteration of the hash function to compute. The labels in this specification have all been chosen to fit within this limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：一般的なハッシュ関数では、12文字を超えるラベルを計算するには、ハッシュ関数の追加の反復が必要です。 この仕様のラベルはすべて、この制限内に収まるように選択されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Keys are derived from two input secrets using the HKDF-Extract and Derive-Secret functions. The general pattern for adding a new secret is to use HKDF-Extract with the Salt being the current secret state and the Input Keying Material (IKM) being the new secret to be added. In this version of TLS 1.3, the two input secrets are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キーは、HKDF-ExtractおよびDerive-Secret関数を使用して2つの入力シークレットから派生します。 新しいシークレットを追加する一般的なパターンは、HKDF-Extractを使用することです。ソルトは現在のシークレット状態で、入力キーイングマテリアル（IKM）は追加する新しいシークレットです。 このバージョンのTLS 1.3では、2つの入力シークレットは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- PSK (a pre-shared key established externally or derived from the resumption_master_secret value from a previous connection)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-PSK（外部で確立された、または以前の接続のresumption_master_secret値から派生した事前共有キー）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- (EC)DHE shared secret (Section 7.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-（EC）DHE共有シークレット（セクション7.4）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This produces a full key derivation schedule shown in the diagram below. In this diagram, the following formatting conventions apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これにより、次の図に示す完全なキー導出スケジュールが作成されます。 この図では、次のフォーマット規則が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- HKDF-Extract is drawn as taking the Salt argument from the top and the IKM argument from the left, with its output to the bottom and the name of the output on the right.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-HKDF-Extractは、上部からSalt引数を、左側からIKM引数を取り、その出力を下部に、出力の名前を右側に取るように描画されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Derive-Secret&#39;s Secret argument is indicated by the incoming arrow. For instance, the Early Secret is the Secret for generating the client_early_traffic_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-Derive-SecretのSecret引数は、入ってくる矢印で示されます。 たとえば、アーリーシークレットはclient_early_traffic_secretを生成するためのシークレットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- &#34;0&#34; indicates a string of Hash.length bytes set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「0」は、ゼロに設定されたHash.lengthバイトの文字列を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             0
             |
             v
   PSK -&gt;  HKDF-Extract = Early Secret
             |
             +-----&gt; Derive-Secret(., &#34;ext binder&#34; | &#34;res binder&#34;, &#34;&#34;)
             |                     = binder_key
             |
             +-----&gt; Derive-Secret(., &#34;c e traffic&#34;, ClientHello)
             |                     = client_early_traffic_secret
             |
             +-----&gt; Derive-Secret(., &#34;e exp master&#34;, ClientHello)
             |                     = early_exporter_master_secret
             v
       Derive-Secret(., &#34;derived&#34;, &#34;&#34;)
             |
             v
   (EC)DHE -&gt; HKDF-Extract = Handshake Secret
             |
             +-----&gt; Derive-Secret(., &#34;c hs traffic&#34;,
             |                     ClientHello...ServerHello)
             |                     = client_handshake_traffic_secret
             |
             +-----&gt; Derive-Secret(., &#34;s hs traffic&#34;,
             |                     ClientHello...ServerHello)
             |                     = server_handshake_traffic_secret
             v
       Derive-Secret(., &#34;derived&#34;, &#34;&#34;)
             |
             v
   0 -&gt; HKDF-Extract = Master Secret
             |
             +-----&gt; Derive-Secret(., &#34;c ap traffic&#34;,
             |                     ClientHello...server Finished)
             |                     = client_application_traffic_secret_0
             |
             +-----&gt; Derive-Secret(., &#34;s ap traffic&#34;,
             |                     ClientHello...server Finished)
             |                     = server_application_traffic_secret_0
             |
             +-----&gt; Derive-Secret(., &#34;exp master&#34;,
             |                     ClientHello...server Finished)
             |                     = exporter_master_secret
             |
             +-----&gt; Derive-Secret(., &#34;res master&#34;,
                                   ClientHello...client Finished)
                                   = resumption_master_secret
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The general pattern here is that the secrets shown down the left side of the diagram are just raw entropy without context, whereas the secrets down the right side include Handshake Context and therefore can be used to derive working keys without additional context. Note that the different calls to Derive-Secret may take different Messages arguments, even with the same secret. In a 0-RTT exchange, Derive-Secret is called with four distinct transcripts; in a 1-RTT-only exchange, it is called with three distinct transcripts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでの一般的なパターンは、図の左側に表示されるシークレットはコンテキストのない生エントロピーであり、右側のシークレットにはハンドシェイクコンテキストが含まれるため、追加のコンテキストなしで作業キーを導出するために使用できるということです。 Derive-Secretの異なる呼び出しは、同じ秘密であっても異なるメッセージ引数を取る場合があることに注意してください。 0-RTT交換では、Derive-Secretが4つの異なるトランスクリプトで呼び出されます。 1-RTTのみの交換では、3つの異なるトランスクリプトで呼び出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a given secret is not available, then the 0-value consisting of a string of Hash.length bytes set to zeros is used. Note that this does not mean skipping rounds, so if PSK is not in use, Early Secret will still be HKDF-Extract(0, 0). For the computation of the binder_key, the label is &#34;ext binder&#34; for external PSKs (those provisioned outside of TLS) and &#34;res binder&#34; for resumption PSKs (those provisioned as the resumption master secret of a previous handshake). The different labels prevent the substitution of one type of PSK for the other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
指定されたシークレットが利用できない場合、ゼロに設定されたHash.lengthバイトの文字列で構成される0値が使用されます。 これはラウンドをスキップすることを意味しないことに注意してください。したがって、PSKが使用されていない場合でも、アーリーシークレットはHKDF-Extract（0、0）のままです。 バインダキーの計算では、ラベルは外部PSK（TLSの外部でプロビジョニングされたもの）の「extバインダ」および再開PSK（以前のハンドシェイクの再開マスターシークレットとしてプロビジョニングされたもの）の「resバインダ」です。 ラベルが異なると、あるタイプのPSKが別のタイプのPSKに置き換えられなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are multiple potential Early Secret values, depending on which PSK the server ultimately selects. The client will need to compute one for each potential PSK; if no PSK is selected, it will then need to compute the Early Secret corresponding to the zero PSK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが最終的に選択するPSKに応じて、複数の潜在的なアーリーシークレット値があります。 クライアントは、潜在的なPSKごとに1つを計算する必要があります。 PSKが選択されていない場合、ゼロPSKに対応するアーリーシークレットを計算する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once all the values which are to be derived from a given secret have been computed, that secret SHOULD be erased.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特定のシークレットから導出される値がすべて計算されたら、そのシークレットを消去する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Updating Traffic Secrets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。 トラフィックシークレットの更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once the handshake is complete, it is possible for either side to update its sending traffic keys using the KeyUpdate handshake message defined in Section 4.6.3. The next generation of traffic keys is computed by generating client_/server_application_traffic_secret_N+1 from client_/server_application_traffic_secret_N as described in this section and then re-deriving the traffic keys as described in Section 7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェイクが完了すると、セクション4.6.3で定義されているKeyUpdateハンドシェイクメッセージを使用して、どちらの側でも送信トラフィックキーを更新できます。 次世代のトラフィックキーは、このセクションで説明されているようにclient_ / server_application_traffic_secret_Nからclient_ / server_application_traffic_secret_N + 1を生成し、セクション7.3で説明されているようにトラフィックキーを再導出することによって計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The next-generation application_traffic_secret is computed as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次世代のapplication_traffic_secretは次のように計算されます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       application_traffic_secret_N+1 =
           HKDF-Expand-Label(application_traffic_secret_N,
                             &#34;traffic upd&#34;, &#34;&#34;, Hash.length)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once client_/server_application_traffic_secret_N+1 and its associated traffic keys have been computed, implementations SHOULD delete client_/server_application_traffic_secret_N and its associated traffic keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
client_ / server_application_traffic_secret_N + 1とその関連トラフィックキーが計算されると、実装はclient_ / server_application_traffic_secret_Nとその関連トラフィックキーを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Traffic Key Calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3。 トラフィックキーの計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The traffic keying material is generated from the following input values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トラフィックキーイングマテリアルは、次の入力値から生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A secret value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-秘密の価値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A purpose value indicating the specific value being generated
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-生成される特定の値を示す目的値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The length of the key being generated
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-生成されるキーの長さ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The traffic keying material is generated from an input traffic secret value using:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トラフィックキーイングマテリアルは、次を使用して入力トラフィックシークレット値から生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[sender]_write_key = HKDF-Expand-Label(Secret, &#34;key&#34;, &#34;&#34;, key_length) [sender]_write_iv = HKDF-Expand-Label(Secret, &#34;iv&#34;, &#34;&#34;, iv_length)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[送信者] _write_key = HKDF-Expand-Label（Secret、 &#34;key&#34;、 &#34;&#34;、key_length）[送信者] _write_iv = HKDF-Expand-Label（Secret、 &#34;iv&#34;、 &#34;&#34;、iv_length）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[sender] denotes the sending side. The value of Secret for each record type is shown in the table below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[送信者]は送信側を示します。 各レコードタイプのSecretの値を次の表に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       +-------------------+---------------------------------------+
       | Record Type       | Secret                                |
       +-------------------+---------------------------------------+
       | 0-RTT Application | client_early_traffic_secret           |
       |                   |                                       |
       | Handshake         | [sender]_handshake_traffic_secret     |
       |                   |                                       |
       | Application Data  | [sender]_application_traffic_secret_N |
       +-------------------+---------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All the traffic keying material is recomputed whenever the underlying Secret changes (e.g., when changing from the handshake to Application Data keys or upon a key update).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
基礎となるシークレットが変更されるたびに（たとえば、ハンドシェイクからアプリケーションデータキーへの変更時、またはキーの更新時に）、すべてのトラフィックキーイングマテリアルが再計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. (EC)DHE Shared Secret Calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4。 （EC）DHE共有秘密計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. Finite Field Diffie-Hellman
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1。 有限体Diffie-Hellman
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For finite field groups, a conventional Diffie-Hellman [DH76] computation is performed. The negotiated key (Z) is converted to a byte string by encoding in big-endian form and left-padded with zeros up to the size of the prime. This byte string is used as the shared secret in the key schedule as specified above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
有限フィールドグループの場合、従来のDiffie-Hellman [DH76]計算が実行されます。 ネゴシエートされたキー（Z）は、ビッグエンディアン形式でエンコードすることによりバイト文字列に変換され、プライムのサイズまでゼロが左詰めされます。 このバイト文字列は、上記で指定されたキースケジュールで共有シークレットとして使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that this construction differs from previous versions of TLS which removed leading zeros.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この構造は、先行ゼロを削除した以前のバージョンのTLSとは異なることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. Elliptic Curve Diffie-Hellman
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2。 楕円曲線ディフィーヘルマン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For secp256r1, secp384r1, and secp521r1, ECDH calculations (including parameter and key generation as well as the shared secret calculation) are performed according to [IEEE1363] using the ECKAS-DH1 scheme with the identity map as the key derivation function (KDF), so that the shared secret is the x-coordinate of the ECDH shared secret elliptic curve point represented as an octet string. Note that this octet string (&#34;Z&#34; in IEEE 1363 terminology) as output by FE2OSP (the Field Element to Octet String Conversion Primitive) has constant length for any given field; leading zeros found in this octet string MUST NOT be truncated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
secp256r1、secp384r1、およびsecp521r1の場合、ECDH計算（パラメーターとキーの生成、および共有秘密計算を含む）は、キー派生関数（KDF）としてIDマップを使用したECKAS-DH1スキームを使用して、[IEEE1363]に従って実行されます。 共有秘密は、オクテット文字列として表されるECDH共有秘密楕円曲線点のx座標です。 FE2OSP（フィールド要素からオクテット文字列への変換プリミティブ）による出力としてのこのオクテット文字列（IEEE 1363用語では「Z」）には、任意のフィールドの長さが一定であることに注意してください。 このオクテット文字列で見つかった先行ゼロは切り捨ててはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(Note that this use of the identity KDF is a technicality. The complete picture is that ECDH is employed with a non-trivial KDF because TLS does not directly use this secret for anything other than for computing other secrets.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（ID KDFのこの使用は技術的であることに注意してください。TLSは他のシークレットの計算以外にこのシークレットを直接使用しないため、ECDHは重要なKDFで使用されます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For X25519 and X448, the ECDH calculations are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
X25519およびX448の場合、ECDH計算は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The public key to put into the KeyShareEntry.key_exchange structure is the result of applying the ECDH scalar multiplication function to the secret key of appropriate length (into scalar input) and the standard public basepoint (into u-coordinate point input).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-KeyShareEntry.key_exchange構造体に配置する公開キーは、ECDHスカラー乗算関数を適切な長さの秘密キー（スカラー入力へ）および標準公開ベースポイント（u座標ポイント入力へ）に適用した結果です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The ECDH shared secret is the result of applying the ECDH scalar multiplication function to the secret key (into scalar input) and the peer&#39;s public key (into u-coordinate point input). The output is used raw, with no processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-ECDH共有秘密は、ECDHスカラー乗算関数を秘密キー（スカラー入力へ）およびピアの公開キー（u座標点入力へ）に適用した結果です。 出力は処理せずにそのまま使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For these curves, implementations SHOULD use the approach specified in [RFC7748] to calculate the Diffie-Hellman shared secret. Implementations MUST check whether the computed Diffie-Hellman shared secret is the all-zero value and abort if so, as described in Section 6 of [RFC7748]. If implementors use an alternative implementation of these elliptic curves, they SHOULD perform the additional checks specified in Section 7 of [RFC7748].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの曲線について、実装は[RFC7748]で指定されたアプローチを使用して、Diffie-Hellman共有シークレットを計算する必要があります。 実装は、[RFC7748]のセクション6で説明されているように、計算されたDiffie-Hellman共有シークレットがすべてゼロの値であるかどうかを確認し、そうであれば中止する必要があります。 実装者がこれらの楕円曲線の代替実装を使用する場合、[RFC7748]のセクション7で指定された追加チェックを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. Exporters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5。 輸出業者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5705] defines keying material exporters for TLS in terms of the TLS pseudorandom function (PRF). This document replaces the PRF with HKDF, thus requiring a new construction. The exporter interface remains the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5705]は、TLS擬似ランダム関数（PRF）の観点からTLSのキーイングマテリアルエクスポータを定義しています。 このドキュメントでは、PRFをHKDFに置き換えているため、新しい構造が必要です。 エクスポーターのインターフェースは同じままです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The exporter value is computed as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エクスポーター値は次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS-Exporter(label, context_value, key_length) = HKDF-Expand-Label(Derive-Secret(Secret, label, &#34;&#34;), &#34;exporter&#34;, Hash(context_value), key_length)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS-Exporter（label、context_value、key_length）= HKDF-Expand-Label（Derive-Secret（Secret、label、 &#34;&#34;）、 &#34;exporter&#34;、Hash（context_value）、key_length）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Where Secret is either the early_exporter_master_secret or the exporter_master_secret. Implementations MUST use the exporter_master_secret unless explicitly specified by the application. The early_exporter_master_secret is defined for use in settings where an exporter is needed for 0-RTT data. A separate interface for the early exporter is RECOMMENDED; this avoids the exporter user accidentally using an early exporter when a regular one is desired or vice versa.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Secretは、early_exporter_master_secretまたはexporter_master_secretのいずれかです。 実装は、アプリケーションによって明示的に指定されない限り、exporter_master_secretを使用する必要があります。 early_exporter_master_secretは、0-RTTデータにエクスポーターが必要な設定で使用するために定義されます。 初期エクスポーター用の別のインターフェイスが推奨されます。 これにより、通常のエクスポーターが必要なときにエクスポーターユーザーが誤ってアーリーエクスポーターを使用することを回避できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If no context is provided, the context_value is zero length. Consequently, providing no context computes the same value as providing an empty context. This is a change from previous versions of TLS where an empty context produced a different output than an absent context. As of this document&#39;s publication, no allocated exporter label is used both with and without a context. Future specifications MUST NOT define a use of exporters that permit both an empty context and no context with the same label. New uses of exporters SHOULD provide a context in all exporter computations, though the value could be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンテキストが提供されない場合、context_valueの長さはゼロになります。 したがって、コンテキストを提供しない場合、空のコンテキストを提供する場合と同じ値が計算されます。 これは、空のコンテキストが存在しないコンテキストとは異なる出力を生成するTLSの以前のバージョンからの変更です。 このドキュメントの公開時点では、コンテキストの有無にかかわらず、割り当てられたエクスポーターラベルは使用されていません。 将来の仕様では、空のコンテキストと同じラベルを持つコンテキストを許可しないエクスポーターの使用を定義してはなりません。 エクスポーターの新しい使用方法は、値が空であっても、すべてのエクスポーターの計算にコンテキストを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Requirements for the format of exporter labels are defined in Section 4 of [RFC5705].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エクスポーターラベルの形式の要件は、[RFC5705]のセクション4で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 0-RTT and Anti-Replay
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 0-RTTおよびアンチリプレイ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As noted in Section 2.3 and Appendix E.5, TLS does not provide inherent replay protections for 0-RTT data. There are two potential threats to be concerned with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション2.3および付録E.5で述べたように、TLSは0-RTTデータに固有のリプレイ保護を提供しません。 懸念される可能性のある脅威は2つあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Network attackers who mount a replay attack by simply duplicating a flight of 0-RTT data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-一連の0-RTTデータを複製するだけでリプレイ攻撃を仕掛けるネットワーク攻撃者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Network attackers who take advantage of client retry behavior to arrange for the server to receive multiple copies of an application message. This threat already exists to some extent because clients that value robustness respond to network errors by attempting to retry requests. However, 0-RTT adds an additional dimension for any server system which does not maintain globally consistent server state. Specifically, if a server system has multiple zones where tickets from zone A will not be accepted in zone B, then an attacker can duplicate a ClientHello and early data intended for A to both A and B. At A, the data will be accepted in 0-RTT, but at B the server will reject 0-RTT data and instead force a full handshake. If the attacker blocks the ServerHello from A, then the client will complete the handshake with B and probably retry the request, leading to duplication on the server system as a whole.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-クライアントの再試行動作を利用して、サーバーがアプリケーションメッセージの複数のコピーを受信するように調整するネットワーク攻撃者。 堅牢性を重視するクライアントは、要求を再試行することでネットワークエラーに応答するため、この脅威はすでにある程度存在しています。 ただし、0-RTTは、グローバルに一貫したサーバー状態を維持しないサーバーシステムに追加のディメンションを追加します。 具体的には、サーバーシステムに複数のゾーンがあり、ゾーンAからのチケットがゾーンBで受け入れられない場合、攻撃者はClientHelloとA向けの初期データをAとBの両方に複製できます。Aでは、データが受け入れられます 0-RTT。ただし、Bでは、サーバーは0-RTTデータを拒否し、代わりに完全なハンドシェイクを強制します。 攻撃者がAからServerHelloをブロックすると、クライアントはBとのハンドシェイクを完了し、おそらくリクエストを再試行し、サーバーシステム全体での複製につながります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first class of attack can be prevented by sharing state to guarantee that the 0-RTT data is accepted at most once. Servers SHOULD provide that level of replay safety by implementing one of the methods described in this section or by equivalent means. It is understood, however, that due to operational concerns not all deployments will maintain state at that level. Therefore, in normal operation, clients will not know which, if any, of these mechanisms servers actually implement and hence MUST only send early data which they deem safe to be replayed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のクラスの攻撃は、状態を共有して0-RTTデータが最大1回しか受け入れられないようにすることで防止できます。 サーバーは、このセクションで説明する方法の1つまたは同等の手段を実装することにより、そのレベルのリプレイの安全性を提供する必要があります。 ただし、運用上の懸念により、すべての展開がそのレベルで状態を維持するとは限らないことが理解されます。 したがって、通常の運用では、クライアントはこれらのメカニズムのどれがサーバーに実際に実装されているかを知らないため、リプレイが安全であると思われる初期データのみを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to the direct effects of replays, there is a class of attacks where even operations normally considered idempotent could be exploited by a large number of replays (timing attacks, resource limit exhaustion and others, as described in Appendix E.5). Those can be mitigated by ensuring that every 0-RTT payload can be replayed only a limited number of times. The server MUST ensure that any instance of it (be it a machine, a thread, or any other entity within the relevant serving infrastructure) would accept 0-RTT for the same 0-RTT handshake at most once; this limits the number of replays to the number of server instances in the deployment. Such a guarantee can be accomplished by locally recording data from recently received ClientHellos and rejecting repeats, or by any other method that provides the same or a stronger guarantee. The &#34;at most once per server instance&#34; guarantee is a minimum requirement; servers SHOULD limit 0-RTT replays further when feasible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リプレイの直接的な効果に加えて、通常はべき等と見なされる操作でも多数のリプレイによって悪用される可能性のある攻撃のクラスがあります（付録E.5で説明するタイミング攻撃、リソース制限の枯渇など）。 これらは、すべての0-RTTペイロードを限られた回数だけ再生できるようにすることで軽減できます。 サーバーは、そのインスタンス（マシン、スレッド、または関連するサービングインフラストラクチャ内のその他のエンティティ）が、同じ0-RTTハンドシェイクに対して最大で一度だけ0-RTTを受け入れるようにする必要があります。 これにより、リプレイの数がデプロイメント内のサーバーインスタンスの数に制限されます。 このような保証は、最近受信したClientHelloからデータをローカルに記録して繰り返しを拒否するか、同じまたはより強力な保証を提供する他の方法によって実現できます。 「サーバーインスタンスごとに最大1回」の保証は最小要件です。 サーバーは、可能であれば0-RTTリプレイをさらに制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The second class of attack cannot be prevented at the TLS layer and MUST be dealt with by any application. Note that any application whose clients implement any kind of retry behavior already needs to implement some sort of anti-replay defense.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2番目のクラスの攻撃はTLSレイヤーで防ぐことができず、どのアプリケーションでも対処する必要があります。 クライアントがあらゆる種類の再試行動作を実装しているアプリケーションは、すでに何らかのアンチリプレイ防御を実装する必要があることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Single-Use Tickets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。 使い捨てチケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The simplest form of anti-replay defense is for the server to only allow each session ticket to be used once. For instance, the server can maintain a database of all outstanding valid tickets, deleting each ticket from the database as it is used. If an unknown ticket is provided, the server would then fall back to a full handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アンチリプレイ防御の最も単純な形式は、サーバーが各セッションチケットを1回しか使用できないようにすることです。 たとえば、サーバーはすべての未処理の有効なチケットのデータベースを維持し、使用中のデータベースから各チケットを削除できます。 不明なチケットが提供された場合、サーバーは完全なハンドシェイクにフォールバックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the tickets are not self-contained but rather are database keys, and the corresponding PSKs are deleted upon use, then connections established using PSKs enjoy forward secrecy. This improves security for all 0-RTT data and PSK usage when PSK is used without (EC)DHE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
チケットが自己完結型ではなくデータベースキーであり、対応するPSKが使用時に削除される場合、PSKを使用して確立された接続は前方秘匿性を享受します。 これにより、PSKが（EC）DHEなしで使用される場合に、すべての0-RTTデータとPSK使用のセキュリティが向上します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because this mechanism requires sharing the session database between server nodes in environments with multiple distributed servers, it may be hard to achieve high rates of successful PSK 0-RTT connections when compared to self-encrypted tickets. Unlike session databases, session tickets can successfully do PSK-based session establishment even without consistent storage, though when 0-RTT is allowed they still require consistent storage for anti-replay of 0-RTT data, as detailed in the following section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメカニズムでは、複数の分散サーバーが存在する環境のサーバーノード間でセッションデータベースを共有する必要があるため、自己暗号化チケットと比較して高い成功率のPSK 0-RTT接続を達成するのは困難です。 セッションデータベースとは異なり、セッションチケットは、一貫したストレージがなくてもPSKベースのセッション確立を正常に実行できますが、次のセクションで説明するように、0-RTTが許可されている場合、0-RTTデータのリプレイ防止のために一貫したストレージが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Client Hello Recording
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2。 クライアントHello Recording
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An alternative form of anti-replay is to record a unique value derived from the ClientHello (generally either the random value or the PSK binder) and reject duplicates. Recording all ClientHellos causes state to grow without bound, but a server can instead record ClientHellos within a given time window and use the &#34;obfuscated_ticket_age&#34; to ensure that tickets aren&#39;t reused outside that window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アンチリプレイの代替形式は、ClientHelloから派生した一意の値（通常はランダム値またはPSKバインダー）を記録し、重複を拒否することです。 すべてのClientHelloを記録すると状態は際限なく拡大しますが、サーバーは代わりに特定の時間枠内でClientHelloを記録し、「obfuscated_ticket_age」を使用してその枠外でチケットが再利用されないようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to implement this, when a ClientHello is received, the server first verifies the PSK binder as described in Section 4.2.11. It then computes the expected_arrival_time as described in the next section and rejects 0-RTT if it is outside the recording window, falling back to the 1-RTT handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これを実装するために、ClientHelloが受信されると、サーバーはセクション4.2.11で説明されているようにPSKバインダーを最初に検証します。 次に、次のセクションで説明するとおりexpected_arrival_timeを計算し、記録ウィンドウの外側にある場合は0-RTTを拒否し、1-RTTハンドシェイクにフォールバックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the expected_arrival_time is in the window, then the server checks to see if it has recorded a matching ClientHello. If one is found, it either aborts the handshake with an &#34;illegal_parameter&#34; alert or accepts the PSK but rejects 0-RTT. If no matching ClientHello is found, then it accepts 0-RTT and then stores the ClientHello for as long as the expected_arrival_time is inside the window. Servers MAY also implement data stores with false positives, such as Bloom filters, in which case they MUST respond to apparent replay by rejecting 0-RTT but MUST NOT abort the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
expected_arrival_timeがウィンドウ内にある場合、サーバーは一致するClientHelloを記録したかどうかを確認します。 見つかった場合、「illegal_parameter」アラートでハンドシェイクを中止するか、PSKを受け入れますが、0-RTTは拒否します。 一致するClientHelloが見つからない場合、0-RTTを受け入れ、expected_arrival_timeがウィンドウ内にある限りClientHelloを保存します。 サーバーは、ブルームフィルターなどの誤検知のあるデータストアを実装することもできます。この場合、0-RTTを拒否することで明らかなリプレイに応答する必要がありますが、ハンドシェイクを中止してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The server MUST derive the storage key only from validated sections of the ClientHello. If the ClientHello contains multiple PSK identities, then an attacker can create multiple ClientHellos with different binder values for the less-preferred identity on the assumption that the server will not verify it (as recommended by Section 4.2.11). I.e., if the client sends PSKs A and B but the server prefers A, then the attacker can change the binder for B without affecting the binder for A. If the binder for B is part of the storage key, then this ClientHello will not appear as a duplicate, which will cause the ClientHello to be accepted, and may cause side effects such as replay cache pollution, although any 0-RTT data will not be decryptable because it will use different keys. If the validated binder or the ClientHello.random is used as the storage key, then this attack is not possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーは、ClientHelloの検証済みセクションからのみストレージキーを取得する必要があります。 ClientHelloに複数のPSK IDが含まれている場合、攻撃者は、サーバーがそれを検証しないという前提で（4.2.11項で推奨されているように）、優先度の低いIDに対して異なるバインダー値を持つ複数のClientHelloを作成できます。 つまり、クライアントがPSK AおよびBを送信し、サーバーがAを好む場合、攻撃者はAのバインダーに影響を与えることなくBのバインダーを変更できます。Bのバインダーがストレージキーの一部である場合、このClientHelloは表示されません 重複として、ClientHelloが受け入れられ、リプレイキャッシュ汚染などの副作用が発生する可能性がありますが、0-RTTデータは異なるキーを使用するため解読できません。 検証済みのバインダーまたはClientHello.randomがストレージキーとして使用されている場合、この攻撃は不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because this mechanism does not require storing all outstanding tickets, it may be easier to implement in distributed systems with high rates of resumption and 0-RTT, at the cost of potentially weaker anti-replay defense because of the difficulty of reliably storing and retrieving the received ClientHello messages. In many such systems, it is impractical to have globally consistent storage of all the received ClientHellos. In this case, the best anti-replay protection is provided by having a single storage zone be authoritative for a given ticket and refusing 0-RTT for that ticket in any other zone. This approach prevents simple replay by the attacker because only one zone will accept 0-RTT data. A weaker design is to implement separate storage for each zone but allow 0-RTT in any zone. This approach limits the number of replays to once per zone. Application message duplication of course remains possible with either design.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメカニズムはすべての未処理のチケットを保存する必要がないため、高いレートの再開と0-RTTを備えた分散システムに実装する方が簡単かもしれません。ただし、 ClientHelloメッセージを受信しました。 このようなシステムの多くでは、受信したすべてのClientHelloをグローバルに一貫したストレージにすることは実用的ではありません。 この場合、単一のストレージゾーンを特定のチケットに対して権限を持たせ、他のゾーンではそのチケットの0-RTTを拒否することにより、最適なアンチリプレイ保護が提供されます。 このアプローチは、1つのゾーンのみが0-RTTデータを受け入れるため、攻撃者による単純なリプレイを防ぎます。 弱い設計では、ゾーンごとに個別のストレージを実装しますが、どのゾーンでも0-RTTを許可します。 このアプローチでは、リプレイの回数がゾーンごとに1回に制限されます。 もちろん、どちらの設計でもアプリケーションメッセージの複製は可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When implementations are freshly started, they SHOULD reject 0-RTT as long as any portion of their recording window overlaps the startup time. Otherwise, they run the risk of accepting replays which were originally sent during that period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装が新たに開始されると、記録ウィンドウの一部が起動時間と重複する限り、0-RTTを拒否する必要があります。 そうしないと、元々その期間に送信されたリプレイを受け入れるリスクがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: If the client&#39;s clock is running much faster than the server&#39;s, then a ClientHello may be received that is outside the window in the future, in which case it might be accepted for 1-RTT, causing a client retry, and then acceptable later for 0-RTT. This is another variant of the second form of attack described in Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：クライアントのクロックがサーバーのクロックよりもはるかに高速で実行されている場合、将来ウィンドウの外にあるClientHelloが受信される可能性があります。 0-RTTの場合。 これは、セクション8で説明した攻撃の2番目の形式の別の変形です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Freshness Checks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3。 鮮度チェック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because the ClientHello indicates the time at which the client sent it, it is possible to efficiently determine whether a ClientHello was likely sent reasonably recently and only accept 0-RTT for such a ClientHello, otherwise falling back to a 1-RTT handshake. This is necessary for the ClientHello storage mechanism described in Section 8.2 because otherwise the server needs to store an unlimited number of ClientHellos, and is a useful optimization for self-contained single-use tickets because it allows efficient rejection of ClientHellos which cannot be used for 0-RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientHelloはクライアントが送信した時刻を示すため、ClientHelloが最近合理的に送信された可能性があるかどうかを効率的に判断し、そのようなClientHelloに対して0-RTTのみを受け入れるか、そうでなければ1-RTTハンドシェイクにフォールバックできます。 これは、サーバーが無制限の数のClientHelloを格納する必要があるため、セクション8.2で説明されているClientHelloストレージメカニズムに必要であり、使用できないClientHelloを効率的に拒否できるため、自己完結型の使い捨てチケットの便利な最適化です 0-RTT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to implement this mechanism, a server needs to store the time that the server generated the session ticket, offset by an estimate of the round-trip time between client and server. I.e.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメカニズムを実装するために、サーバーは、サーバーがセッションチケットを生成した時間を、クライアントとサーバー間の往復時間の推定値で相殺して保存する必要があります。 つまり、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
adjusted_creation_time = creation_time + estimated_RTT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
adjusted_creation_time = creation_time + expected_RTT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This value can be encoded in the ticket, thus avoiding the need to keep state for each outstanding ticket. The server can determine the client&#39;s view of the age of the ticket by subtracting the ticket&#39;s &#34;ticket_age_add&#34; value from the &#34;obfuscated_ticket_age&#34; parameter in the client&#39;s &#34;pre_shared_key&#34; extension. The server can determine the expected_arrival_time of the ClientHello as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この値はチケットにエンコードできるため、未処理の各チケットの状態を維持する必要がなくなります。 サーバーは、クライアントの「pre_shared_key」拡張機能の「obfuscated_ticket_age」パラメーターからチケットの「ticket_age_add」値を減算することにより、クライアントのチケットの経過時間のビューを判別できます。 サーバーは、ClientHelloのexpected_arrival_timeを次のように決定できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
expected_arrival_time = adjusted_creation_time + clients_ticket_age
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
expected_arrival_time = adjust_creation_time + clients_ticket_age
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a new ClientHello is received, the expected_arrival_time is then compared against the current server wall clock time and if they differ by more than a certain amount, 0-RTT is rejected, though the 1-RTT handshake can be allowed to complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいClientHelloが受信されると、expected_arrival_timeが現在のサーバーのウォールクロック時間と比較され、一定以上の差がある場合は、1-RTTハンドシェイクを完了できますが、0-RTTは拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are several potential sources of error that might cause mismatches between the expected_arrival_time and the measured time. Variations in client and server clock rates are likely to be minimal, though potentially the absolute times may be off by large values. Network propagation delays are the most likely causes of a mismatch in legitimate values for elapsed time. Both the NewSessionTicket and ClientHello messages might be retransmitted and therefore delayed, which might be hidden by TCP. For clients on the Internet, this implies windows on the order of ten seconds to account for errors in clocks and variations in measurements; other deployment scenarios may have different needs. Clock skew distributions are not symmetric, so the optimal tradeoff may involve an asymmetric range of permissible mismatch values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
expected_arrival_timeと測定された時間との不一致を引き起こす可能性のあるエラーの原因はいくつかあります。 クライアントとサーバーのクロックレートの変動は最小になる可能性がありますが、大きな値によって絶対時間はずれている可能性があります。 ネットワーク伝播遅延は、経過時間の正当な値の不一致の最も可能性の高い原因です。 NewSessionTicketメッセージとClientHelloメッセージの両方が再送信される可能性があるため、TCPによって隠される可能性があります。 インターネット上のクライアントの場合、これは、クロックの誤差と測定値の変動を考慮して、10秒程度のウィンドウを意味します。 他の展開シナリオには異なるニーズがあります。 クロックスキューの分布は対称ではないため、最適なトレードオフには、許容される不一致値の非対称範囲が含まれる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that freshness checking alone is not sufficient to prevent replays because it does not detect them during the error window, which -- depending on bandwidth and system capacity -- could include billions of replays in real-world settings. In addition, this freshness checking is only done at the time the ClientHello is received and not when subsequent early Application Data records are received. After early data is accepted, records may continue to be streamed to the server over a longer time period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フレッシュネスチェックだけでは、エラーウィンドウ中にそれらを検出しないため、リプレイを防ぐのに十分ではないことに注意してください。 さらに、この鮮度チェックはClientHelloが受信されたときにのみ実行され、後続の初期アプリケーションデータレコードが受信されたときは実行されません。 初期のデータが受け入れられた後、レコードはより長い期間にわたってサーバーにストリーミングされ続ける可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Compliance Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.コンプライアンス要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Mandatory-to-Implement Cipher Suites
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1。 必須から実装への暗号スイート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the absence of an application profile standard specifying otherwise:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別の方法で指定するアプリケーションプロファイル標準がない場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256 [GCM] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384 [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439] cipher suites (see Appendix B.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS準拠のアプリケーションは、TLS_AES_128_GCM_SHA256 [GCM]暗号スイートを実装しなければならず、TLS_AES_256_GCM_SHA384 [GCM]およびTLS_CHACHA20_POLY1305_SHA256 [RFC8439]暗号スイートを実装する必要があります（付録B.4を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A TLS-compliant application MUST support digital signatures with rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for CertificateVerify and certificates), and ecdsa_secp256r1_sha256. A TLS-compliant application MUST support key exchange with secp256r1 (NIST P-256) and SHOULD support key exchange with X25519 [RFC7748].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS準拠のアプリケーションは、rsa_pkcs1_sha256（証明書用）、rsa_pss_rsae_sha256（CertificateVerifyおよび証明書用）、およびecdsa_secp256r1_sha256によるデジタル署名をサポートする必要があります。 TLS準拠のアプリケーションは、secp256r1（NIST P-256）との鍵交換をサポートしなければならず（MUST）、X25519 [RFC7748]との鍵交換をサポートする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Mandatory-to-Implement Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2。 必須から実装への拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the following TLS extensions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別の方法で指定するアプリケーションプロファイル標準がない場合、TLS準拠のアプリケーションは次のTLS拡張を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Supported Versions (&#34;supported_versions&#34;; Section 4.2.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サポートされているバージョン（ &#34;supported_versions&#34;;セクション4.2.1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Cookie (&#34;cookie&#34;; Section 4.2.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-クッキー（「クッキー」;セクション4.2.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Signature Algorithms (&#34;signature_algorithms&#34;; Section 4.2.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-署名アルゴリズム（ &#34;signature_algorithms&#34;;セクション4.2.3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Signature Algorithms Certificate (&#34;signature_algorithms_cert&#34;; Section 4.2.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-署名アルゴリズム証明書（ &#34;signature_algorithms_cert&#34;;セクション4.2.3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Negotiated Groups (&#34;supported_groups&#34;; Section 4.2.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-交渉済みグループ（ &#34;supported_groups&#34;;セクション4.2.7）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Key Share (&#34;key_share&#34;; Section 4.2.8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-鍵共有（ &#34;key_share&#34;;セクション4.2.8）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Server Name Indication (&#34;server_name&#34;; Section 3 of [RFC6066])
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サーバー名表示（ &#34;server_name&#34;; [RFC6066]のセクション3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All implementations MUST send and use these extensions when offering applicable features:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
適用可能な機能を提供する場合、すべての実装はこれらの拡張機能を送信して使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- &#34;supported_versions&#34; is REQUIRED for all ClientHello, ServerHello, and HelloRetryRequest messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「supported_versions」は、ClientHello、ServerHello、およびHelloRetryRequestのすべてのメッセージに必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- &#34;signature_algorithms&#34; is REQUIRED for certificate authentication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-証明書認証には「signature_algorithms」が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- &#34;supported_groups&#34; is REQUIRED for ClientHello messages using DHE or ECDHE key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-DHEまたはECDHEキー交換を使用するClientHelloメッセージには、「supported_groups」が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- &#34;key_share&#34; is REQUIRED for DHE or ECDHE key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「key_share」は、DHEまたはECDHEキー交換に必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- &#34;pre_shared_key&#34; is REQUIRED for PSK key agreement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「pre_shared_key」はPSK鍵合意に必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- &#34;psk_key_exchange_modes&#34; is REQUIRED for PSK key agreement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「psk_key_exchange_modes」は、PSKキーの合意に必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client is considered to be attempting to negotiate using this specification if the ClientHello contains a &#34;supported_versions&#34; extension with 0x0304 contained in its body. Such a ClientHello message MUST meet the following requirements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientHelloの本文に0x0304の「supported_versions」拡張が含まれている場合、クライアントはこの仕様を使用してネゴシエートしようとしていると見なされます。 このようなClientHelloメッセージは、次の要件を満たしている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If not containing a &#34;pre_shared_key&#34; extension, it MUST contain both a &#34;signature_algorithms&#34; extension and a &#34;supported_groups&#34; extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「pre_shared_key」拡張子を含まない場合、「signature_algorithms」拡張子と「supported_groups」拡張子の両方を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If containing a &#34;supported_groups&#34; extension, it MUST also contain a &#34;key_share&#34; extension, and vice versa. An empty KeyShare.client_shares vector is permitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-「supported_groups」拡張子を含む場合、「key_share」拡張子も含める必要があります（逆も同様）。 空のKeyShare.client_sharesベクトルは許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a &#34;missing_extension&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの要件に適合しないClientHelloを受信するサーバーは、「missing_extension」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Additionally, all implementations MUST support the use of the &#34;server_name&#34; extension with applications capable of using it. Servers MAY require clients to send a valid &#34;server_name&#34; extension. Servers requiring this extension SHOULD respond to a ClientHello lacking a &#34;server_name&#34; extension by terminating the connection with a &#34;missing_extension&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、すべての実装は、それを使用できるアプリケーションで「server_name」拡張機能の使用をサポートする必要があります。 サーバーは、クライアントに有効な「server_name」拡張子を送信するよう要求する場合があります。 この拡張機能を必要とするサーバーは、「missing_extension」アラートで接続を終了することにより、「server_name」拡張機能がないClientHelloに応答する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. Protocol Invariants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3。 プロトコル不変量
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes invariants that TLS endpoints and middleboxes MUST follow. It also applies to earlier versions of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、TLSエンドポイントとミドルボックスが従わなければならない不変条件について説明します。 TLSの以前のバージョンにも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS is designed to be securely and compatibly extensible. Newer clients or servers, when communicating with newer peers, should negotiate the most preferred common parameters. The TLS handshake provides downgrade protection: Middleboxes passing traffic between a newer client and newer server without terminating TLS should be unable to influence the handshake (see Appendix E.1). At the same time, deployments update at different rates, so a newer client or server MAY continue to support older parameters, which would allow it to interoperate with older endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、安全かつ互換性のある拡張が可能なように設計されています。 新しいクライアントまたはサーバーは、新しいピアと通信するときに、最も優先される共通パラメーターをネゴシエートする必要があります。 TLSハンドシェイクは、ダウングレード保護を提供します。TLSを終了せずに新しいクライアントと新しいサーバー間でトラフィックを渡すミドルボックスは、ハンドシェイクに影響を与えることができません（付録E.1を参照）。 同時に、展開は異なるレートで更新されるため、新しいクライアントまたはサーバーは古いパラメーターを引き続きサポートすることができます。これにより、古いエンドポイントとの相互運用が可能になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For this to work, implementations MUST correctly handle extensible fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これが機能するためには、実装は拡張可能なフィールドを正しく処理しなければなりません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A client sending a ClientHello MUST support all parameters advertised in it. Otherwise, the server may fail to interoperate by selecting one of those parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-ClientHelloを送信するクライアントは、その中でアドバタイズされるすべてのパラメーターをサポートする必要があります。 そうしないと、サーバーはこれらのパラメーターのいずれかを選択して相互運用できなくなる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters. Otherwise, it may fail to interoperate with newer clients. In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-ClientHelloを受信するサーバーは、認識されないすべての暗号スイート、拡張、およびその他のパラメーターを正しく無視する必要があります。 そうしないと、新しいクライアントとの相互運用に失敗する場合があります。 TLS 1.3では、CertificateRequestまたはNewSessionTicketを受信するクライアントは、認識されないすべての拡張機能も無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A middlebox which terminates a TLS connection MUST behave as a compliant TLS server (to the original client), including having a certificate which the client is willing to accept, and also as a compliant TLS client (to the original server), including verifying the original server&#39;s certificate. In particular, it MUST generate its own ClientHello containing only parameters it understands, and it MUST generate a fresh ServerHello random value, rather than forwarding the endpoint&#39;s value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLS接続を終了するミドルボックスは、（元のクライアントへの）準拠TLSサーバーとして動作する必要があります。 元のサーバーの証明書。 特に、理解できるパラメータのみを含む独自のClientHelloを生成する必要があり、エンドポイントの値を転送するのではなく、新しいServerHelloランダム値を生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that TLS&#39;s protocol requirements and security analysis only apply to the two connections separately. Safely deploying a TLS terminator requires additional security considerations which are beyond the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSのプロトコル要件とセキュリティ分析は、2つの接続に個別にのみ適用されることに注意してください。 TLSターミネータを安全に展開するには、このドキュメントの範囲を超えた追加のセキュリティ上の考慮事項が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A middlebox which forwards ClientHello parameters it does not understand MUST NOT process any messages beyond that ClientHello. It MUST forward all subsequent traffic unmodified. Otherwise, it may fail to interoperate with newer clients and servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-理解できないClientHelloパラメーターを転送するミドルボックスは、そのClientHelloを超えるメッセージを処理してはなりません。 後続のすべてのトラフィックを変更せずに転送する必要があります。 そうしないと、新しいクライアントやサーバーとの相互運用に失敗する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Forwarded ClientHellos may contain advertisements for features not supported by the middlebox, so the response may include future TLS additions the middlebox does not recognize. These additions MAY change any message beyond the ClientHello arbitrarily. In particular, the values sent in the ServerHello might change, the ServerHello format might change, and the TLSCiphertext format might change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
転送されたClientHellosには、middleboxでサポートされていない機能の広告が含まれている可能性があるため、応答には、middleboxが認識しない将来のTLS追加が含まれる場合があります。 これらの追加により、ClientHelloを超えるメッセージを任意に変更できます。 特に、ServerHelloで送信される値が変更される場合があり、ServerHello形式が変更される場合があり、TLSCiphertext形式が変更される場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The design of TLS 1.3 was constrained by widely deployed non-compliant TLS middleboxes (see Appendix D.4); however, it does not relax the invariants. Those middleboxes continue to be non-compliant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3の設計は、広く展開されている非準拠TLSミドルボックスによって制約されていました（付録D.4を参照）。 ただし、不変式は緩和されません。 これらのミドルボックスは引き続き非準拠です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Security issues are discussed throughout this memo, especially in Appendices C, D, and E.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモ全体、特に付録C、D、およびEでセキュリティの問題について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document uses several registries that were originally created in [RFC4346] and updated in [RFC8447]. IANA has updated these to reference this document. The registries and their allocation policies are below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは、[RFC4346]で最初に作成され、[RFC8447]で更新されたいくつかのレジストリを使用します。 IANAは、このドキュメントを参照するためにこれらを更新しました。 レジストリとその割り当てポリシーは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- TLS Cipher Suites registry: values with the first byte in the range 0-254 (decimal) are assigned via Specification Required [RFC8126]. Values with the first byte 255 (decimal) are reserved for Private Use [RFC8126].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLS Cipher Suitesレジストリ：0〜254（10進数）の範囲の最初のバイトを持つ値は、仕様が必要[RFC8126]によって割り当てられます。 最初のバイトが255（10進数）の値は、プライベート使用のために予約されています[RFC8126]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA has added the cipher suites listed in Appendix B.4 to the registry. The &#34;Value&#34; and &#34;Description&#34; columns are taken from the table. The &#34;DTLS-OK&#34; and &#34;Recommended&#34; columns are both marked as &#34;Y&#34; for each new cipher suite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、付録B.4にリストされている暗号スイートをレジストリに追加しました。 「値」列と「説明」列は表から取得されます。 「DTLS-OK」および「推奨」列は、新しい暗号スイートごとに「Y」としてマークされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- TLS ContentType registry: Future values are allocated via Standards Action [RFC8126].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLS ContentTypeレジストリ：将来の値は、標準アクション[RFC8126]を介して割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- TLS Alerts registry: Future values are allocated via Standards Action [RFC8126]. IANA has populated this registry with the values from Appendix B.2. The &#34;DTLS-OK&#34; column is marked as &#34;Y&#34; for all such values. Values marked as &#34;_RESERVED&#34; have comments describing their previous usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLS Alertsレジストリ：将来の値は、Standards Action [RFC8126]を介して割り当てられます。 IANAはこのレジストリに付録B.2の値を設定しました。 「DTLS-OK」列は、そのようなすべての値に対して「Y」としてマークされます。 「_RESERVED」とマークされた値には、以前の使用法を説明するコメントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- TLS HandshakeType registry: Future values are allocated via Standards Action [RFC8126]. IANA has updated this registry to rename item 4 from &#34;NewSessionTicket&#34; to &#34;new_session_ticket&#34; and populated this registry with the values from Appendix B.3. The &#34;DTLS-OK&#34; column is marked as &#34;Y&#34; for all such values. Values marked &#34;_RESERVED&#34; have comments describing their previous or temporary usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLS HandshakeTypeレジストリ：将来の値は、標準アクション[RFC8126]を介して割り当てられます。 IANAはこのレジストリを更新して、アイテム4の名前を「NewSessionTicket」から「new_session_ticket」に変更し、このレジストリに付録B.3の値を追加しました。 「DTLS-OK」列は、そのようなすべての値に対して「Y」としてマークされます。 「_RESERVED」とマークされた値には、以前の使用または一時的な使用を説明するコメントがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document also uses the TLS ExtensionType Values registry originally created in [RFC4366]. IANA has updated it to reference this document. Changes to the registry follow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは、[RFC4366]で最初に作成されたTLS ExtensionType Valuesレジストリも使用します。 IANAはこのドキュメントを参照するように更新しました。 レジストリの変更は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- IANA has updated the registration policy as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-IANAは登録ポリシーを次のように更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Values with the first byte in the range 0-254 (decimal) are assigned via Specification Required [RFC8126]. Values with the first byte 255 (decimal) are reserved for Private Use [RFC8126].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0〜254（10進数）の範囲の最初のバイトを持つ値は、仕様が必要[RFC8126]によって割り当てられます。 最初のバイトが255（10進数）の値は、プライベート使用のために予約されています[RFC8126]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- IANA has updated this registry to include the &#34;key_share&#34;, &#34;pre_shared_key&#34;, &#34;psk_key_exchange_modes&#34;, &#34;early_data&#34;, &#34;cookie&#34;, &#34;supported_versions&#34;, &#34;certificate_authorities&#34;, &#34;oid_filters&#34;, &#34;post_handshake_auth&#34;, and &#34;signature_algorithms_cert&#34; extensions with the values defined in this document and the &#34;Recommended&#34; value of &#34;Y&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-IANAは、このレジストリを更新して、「key_share」、「pre_shared_key」、「psk_key_exchange_modes」、「early_data」、「cookie」、「supported_versions」、「certificate_authorities」、「oid_filters」、「post_handshake_auth」、および「signature_algorithms_cert」拡張機能を追加しました このドキュメントで定義されている値と「推奨」値の「Y」を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- IANA has updated this registry to include a &#34;TLS 1.3&#34; column which lists the messages in which the extension may appear. This column has been initially populated from the table in Section 4.2, with any extension not listed there marked as &#34;-&#34; to indicate that it is not used by TLS 1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-IANAは、このレジストリを更新して、拡張子が表示される可能性のあるメッセージをリストする「TLS 1.3」列を追加しました。 この列は最初にセクション4.2の表から読み込まれ、TLS 1.3で使用されていないことを示すために、そこにリストされていない拡張子は「-」としてマークされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document updates an entry in the TLS Certificate Types registry originally created in [RFC6091] and updated in [RFC8447]. IANA has updated the entry for value 1 to have the name &#34;OpenPGP_RESERVED&#34;, &#34;Recommended&#34; value &#34;N&#34;, and comment &#34;Used in TLS versions prior to 1.3.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは、[RFC6091]で最初に作成され、[RFC8447]で更新されたTLS証明書タイプレジストリのエントリを更新します。 IANAは、値1のエントリの名前を「OpenPGP_RESERVED」、「推奨」値「N」、およびコメント「1.3より前のTLSバージョンで使用」に更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document updates an entry in the TLS Certificate Status Types registry originally created in [RFC6961]. IANA has updated the entry for value 2 to have the name &#34;ocsp_multi_RESERVED&#34; and comment &#34;Used in TLS versions prior to 1.3&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは、[RFC6961]で最初に作成されたTLS証明書ステータスタイプレジストリのエントリを更新します。 IANAは、値2のエントリを「ocsp_multi_RESERVED」という名前に変更し、「1.3より前のTLSバージョンで使用」というコメントを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document updates two entries in the TLS Supported Groups registry (created under a different name by [RFC4492]; now maintained by [RFC8422]) and updated by [RFC7919] and [RFC8447]. The entries for values 29 and 30 (x25519 and x448) have been updated to also refer to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは、TLS Supported Groupsレジストリの2つのエントリを更新し（[RFC4492]によって異なる名前で作成され、現在[RFC8422]によって管理されています）、[RFC7919]および[RFC8447]によって更新されます。 値29および30（x25519およびx448）のエントリは、このドキュメントも参照するように更新されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, this document defines two new registries that are maintained by IANA:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、このドキュメントでは、IANAが管理する2つの新しいレジストリを定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- TLS SignatureScheme registry: Values with the first byte in the range 0-253 (decimal) are assigned via Specification Required [RFC8126]. Values with the first byte 254 or 255 (decimal) are reserved for Private Use [RFC8126]. Values with the first byte in the range 0-6 or with the second byte in the range 0-3 that are not currently allocated are reserved for backward compatibility. This registry has a &#34;Recommended&#34; column. The registry has been initially populated with the values described in Section 4.2.3. The following values are marked as &#34;Recommended&#34;: ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512, rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, and ed25519. The &#34;Recommended&#34; column is assigned a value of &#34;N&#34; unless explicitly requested, and adding a value with a &#34;Recommended&#34; value of &#34;Y&#34; requires Standards Action [RFC8126]. IESG Approval is REQUIRED for a Y-&gt;N transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLS SignatureSchemeレジストリ：範囲0〜253（10進数）の最初のバイトを持つ値は、仕様要求[RFC8126]を介して割り当てられます。 最初のバイトが254または255（10進数）の値は、プライベート使用のために予約されています[RFC8126]。 現在割り当てられていない0〜6の範囲の最初のバイトまたは0〜3の範囲の2番目のバイトを持つ値は、下位互換性のために予約されています。 このレジストリには「推奨」列があります。 レジストリには、最初にセクション4.2.3で説明されている値が設定されています。 次の値は「推奨」としてマークされています。ecdsa_secp256r1_sha256、ecdsa_secp384r1_sha384、rsa_pss_rsae_sha256、rsa_pss_rsae_sha384、rsa_pss_rsae_sha512、rsa_pss_pss_pss_pss_pss_pss_pss_shas、psa、psa、pssa、pssa、pssa、pssa、pssa、pssa、pssa、pssa、pssa 「推奨」列には、明示的に要求されない限り「N」の値が割り当てられます。「推奨」の値が「Y」の値を追加するには、標準アクション[RFC8126]が必要です。 IESG承認は、YからNへの移行に必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- TLS PskKeyExchangeMode registry: Values in the range 0-253 (decimal) are assigned via Specification Required [RFC8126]. The values 254 and 255 (decimal) are reserved for Private Use [RFC8126]. This registry has a &#34;Recommended&#34; column. The registry has been initially populated with psk_ke (0) and psk_dhe_ke (1). Both are marked as &#34;Recommended&#34;. The &#34;Recommended&#34; column is assigned a value of &#34;N&#34; unless explicitly requested, and adding a value with a &#34;Recommended&#34; value of &#34;Y&#34; requires Standards Action [RFC8126]. IESG Approval is REQUIRED for a Y-&gt;N transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLS PskKeyExchangeModeレジストリ：0〜253（10進数）の範囲の値は、仕様が必要[RFC8126]を介して割り当てられます。 値254および255（10進数）は、プライベート使用のために予約されています[RFC8126]。 このレジストリには「推奨」列があります。 レジストリには、最初にpsk_ke（0）およびpsk_dhe_ke（1）が入力されています。 両方とも「推奨」としてマークされています。 「推奨」列には、明示的に要求されない限り「N」の値が割り当てられます。「推奨」の値が「Y」の値を追加するには、標準アクション[RFC8126]が必要です。 IESG承認は、YからNへの移行に必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1。 規範的参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DH76] Diffie, W. and M. Hellman, &#34;New directions in cryptography&#34;, IEEE Transactions on Information Theory, Vol. 22 No. 6, pp. 644-654, DOI 10.1109/TIT.1976.1055638, November 1976.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DH76] Diffie、W.およびM. Hellman、「暗号化の新しい方向」、IEEE情報理論のトランザクション、Vol。 22 No. 6、pp。644-654、DOI 10.1109 / TIT.1976.1055638、1976年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ECDSA] American National Standards Institute, &#34;Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)&#34;, ANSI ANS X9.62-2005, November 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ECDSA]米国規格協会、「金融サービス業界向け公開鍵暗号：楕円曲線デジタル署名アルゴリズム（ECDSA）」、ANSI ANS X9.62-2005、2005年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[GCM] Dworkin, M., &#34;Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC&#34;, NIST Special Publication 800-38D, DOI 10.6028/NIST.SP.800-38D, November 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[GCM] Dworkin、M。、「ブロック暗号操作モードの推奨：ガロア/カウンターモード（GCM）およびGMAC」、NIST特別出版800-38D、DOI 10.6028 / NIST.SP.800-38D、2007年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, DOI 10.17487/RFC2104, February 1997, &lt;https://www.rfc-editor.org/info/rfc2104&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2104] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：メッセージ認証のキー付きハッシュ」、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、&lt;https：//www.rfc-editor .org / info / rfc2104&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/ rfc2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5116] McGrew, D., &#34;An Interface and Algorithms for Authenticated Encryption&#34;, RFC 5116, DOI 10.17487/RFC5116, January 2008, &lt;https://www.rfc-editor.org/info/rfc5116&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5116] McGrew、D。、「認証された暗号化のためのインターフェースとアルゴリズム」、RFC 5116、DOI 10.17487 / RFC5116、2008年1月、&lt;https://www.rfc-editor.org/info/rfc5116&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &#34;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 5280, DOI 10.17487/RFC5280, May 2008, &lt;https://www.rfc-editor.org/info/rfc5280&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R.、およびW. Polk、 &#34;インターネットX.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイル &#34;、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、&lt;https://www.rfc-editor.org/info/rfc5280&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5705] Rescorla, E., &#34;Keying Material Exporters for Transport Layer Security (TLS)&#34;, RFC 5705, DOI 10.17487/RFC5705, March 2010, &lt;https://www.rfc-editor.org/info/rfc5705&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5705] Rescorla、E。、「Transport Layer Security（TLS）のキーイングマテリアルエクスポーター」、RFC 5705、DOI 10.17487 / RFC5705、2010年3月、&lt;https://www.rfc-editor.org/info/rfc5705&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5756] Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk, &#34;Updates for RSAES-OAEP and RSASSA-PSS Algorithm Parameters&#34;, RFC 5756, DOI 10.17487/RFC5756, January 2010, &lt;https://www.rfc-editor.org/info/rfc5756&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5756] Turner、S.、Brown、D.、Yiu、K.、Housley、R。、およびT. Polk、「RSAES-OAEPおよびRSASSA-PSSアルゴリズムパラメーターの更新」、RFC 5756、DOI 10.17487 / RFC5756、 2010年1月、&lt;https://www.rfc-editor.org/info/rfc5756&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5869] Krawczyk, H. and P. Eronen, &#34;HMAC-based Extract-and-Expand Key Derivation Function (HKDF)&#34;, RFC 5869, DOI 10.17487/RFC5869, May 2010, &lt;https://www.rfc-editor.org/info/rfc5869&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5869] Krawczyk、H。およびP. Eronen、「HMACベースの抽出および拡張キー派生関数（HKDF）」、RFC 5869、DOI 10.17487 / RFC5869、2010年5月、&lt;https：//www.rfc-editor .org / info / rfc5869&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6066] Eastlake 3rd, D., &#34;Transport Layer Security (TLS) Extensions: Extension Definitions&#34;, RFC 6066, DOI 10.17487/RFC6066, January 2011, &lt;https://www.rfc-editor.org/info/rfc6066&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6066] Eastlake 3rd、D。、「Transport Layer Security（TLS）Extensions：Extension Definitions」、RFC 6066、DOI 10.17487 / RFC6066、2011年1月、&lt;https://www.rfc-editor.org/info/rfc6066&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6655] McGrew, D. and D. Bailey, &#34;AES-CCM Cipher Suites for Transport Layer Security (TLS)&#34;, RFC 6655, DOI 10.17487/RFC6655, July 2012, &lt;https://www.rfc-editor.org/info/rfc6655&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6655] McGrew、D。およびD. Bailey、「トランスポート層セキュリティ（TLS）のためのAES-CCM暗号スイート」、RFC 6655、DOI 10.17487 / RFC6655、2012年7月、&lt;https://www.rfc-editor.org / info / rfc6655&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6960] Santesson, S., Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, &#34;X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP&#34;, RFC 6960, DOI 10.17487/RFC6960, June 2013, &lt;https://www.rfc-editor.org/info/rfc6960&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6960] Santesson、S.、Myers、M.、Ankney、R.、Malpani、A.、Galperin、S。、およびC. Adams、「X.509インターネット公開鍵インフラストラクチャオンライン証明書ステータスプロトコル-OCSP」、RFC 6960、DOI 10.17487 / RFC6960、2013年6月、&lt;https://www.rfc-editor.org/info/rfc6960&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6961] Pettersen, Y., &#34;The Transport Layer Security (TLS) Multiple Certificate Status Request Extension&#34;, RFC 6961, DOI 10.17487/RFC6961, June 2013, &lt;https://www.rfc-editor.org/info/rfc6961&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6961] Pettersen、Y。、「トランスポート層セキュリティ（TLS）複数証明書ステータス要求拡張」、RFC 6961、DOI 10.17487 / RFC6961、2013年6月、&lt;https://www.rfc-editor.org/info/rfc6961 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6962] Laurie, B., Langley, A., and E. Kasper, &#34;Certificate Transparency&#34;, RFC 6962, DOI 10.17487/RFC6962, June 2013, &lt;https://www.rfc-editor.org/info/rfc6962&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6962]ローリー、B。、ラングレー、A。、およびE.カスパー、「証明書の透明性」、RFC 6962、DOI 10.17487 / RFC6962、2013年6月、&lt;https://www.rfc-editor.org/info/rfc6962 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6979] Pornin, T., &#34;Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)&#34;, RFC 6979, DOI 10.17487/RFC6979, August 2013, &lt;https://www.rfc-editor.org/info/rfc6979&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6979] Pornin、T.、「デジタル署名アルゴリズム（DSA）および楕円曲線デジタル署名アルゴリズム（ECDSA）の決定論的使用法」、RFC 6979、DOI 10.17487 / RFC6979、2013年8月、&lt;https：//www.rfc- editor.org/info/rfc6979&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7301] Friedl, S., Popov, A., Langley, A., and E. Stephan, &#34;Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension&#34;, RFC 7301, DOI 10.17487/RFC7301, July 2014, &lt;https://www.rfc-editor.org/info/rfc7301&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7301]フリーデル、S。、ポポフ、A。、ラングレー、A。、およびE.ステファン、「トランスポート層セキュリティ（TLS）アプリケーション層プロトコルネゴシエーション拡張機能」、RFC 7301、DOI 10.17487 / RFC7301、2014年7月、&lt; https://www.rfc-editor.org/info/rfc7301&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7507] Moeller, B. and A. Langley, &#34;TLS Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol Downgrade Attacks&#34;, RFC 7507, DOI 10.17487/RFC7507, April 2015, &lt;https://www.rfc-editor.org/info/rfc7507&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7507] Moeller、B。、およびA. Langley、「プロトコルダウングレード攻撃を防ぐためのTLSフォールバックシグナリング暗号スイート値（SCSV）」、RFC 7507、DOI 10.17487 / RFC7507、2015年4月、&lt;https：//www.rfc-editor .org / info / rfc7507&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7748] Langley, A., Hamburg, M., and S. Turner, &#34;Elliptic Curves for Security&#34;, RFC 7748, DOI 10.17487/RFC7748, January 2016, &lt;https://www.rfc-editor.org/info/rfc7748&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7748] Langley、A.、Hamburg、M。、およびS. Turner、「セキュリティのための楕円曲線」、RFC 7748、DOI 10.17487 / RFC7748、2016年1月、&lt;https://www.rfc-editor.org/info / rfc7748&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7919] Gillmor, D., &#34;Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)&#34;, RFC 7919, DOI 10.17487/RFC7919, August 2016, &lt;https://www.rfc-editor.org/info/rfc7919&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7919] Gillmor、D。、「トランスポート層セキュリティ（TLS）のネゴシエートされた有限フィールドDiffie-Hellman一時パラメータ」、RFC 7919、DOI 10.17487 / RFC7919、2016年8月、&lt;https://www.rfc-editor.org/ info / rfc7919&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8017] Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch, &#34;PKCS #1: RSA Cryptography Specifications Version 2.2&#34;, RFC 8017, DOI 10.17487/RFC8017, November 2016, &lt;https://www.rfc-editor.org/info/rfc8017&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8017] Moriarty、K.、Ed。、Kaliski、B.、Jonsson、J.、and A. Rusch、 &#34;PKCS＃1：RSA Cryptography Specifications Version 2.2&#34;、RFC 8017、DOI 10.17487 / RFC8017、November 2016、&lt; https://www.rfc-editor.org/info/rfc8017&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8032] Josefsson, S. and I. Liusvaara, &#34;Edwards-Curve Digital Signature Algorithm (EdDSA)&#34;, RFC 8032, DOI 10.17487/RFC8032, January 2017, &lt;https://www.rfc-editor.org/info/rfc8032&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8032] Josefsson、S.およびI. Liusvaara、「Edwards-Curve Digital Signature Algorithm（EdDSA）」、RFC 8032、DOI 10.17487 / RFC8032、2017年1月、&lt;https://www.rfc-editor.org/info/ rfc8032&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8126] Cotton, M., Leiba, B., and T. Narten, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, &lt;https://www.rfc-editor.org/info/rfc8126&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCでIANA考慮事項セクションを記述するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、&lt;https：// www .rfc-editor.org / info / rfc8126&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https://www.rfc-editor.org/info/ rfc8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8439] Nir, Y. and A. Langley, &#34;ChaCha20 and Poly1305 for IETF Protocols&#34;, RFC 8439, DOI 10.17487/RFC8439, June 2018, &lt;https://www.rfc-editor.org/info/rfc8439&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8439] Nir、Y。、およびA. Langley、「ChaCha20およびIETFプロトコル用のPoly1305」、RFC 8439、DOI 10.17487 / RFC8439、2018年6月、&lt;https://www.rfc-editor.org/info/rfc8439&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHS] Dang, Q., &#34;Secure Hash Standard (SHS)&#34;, National Institute of Standards and Technology report, DOI 10.6028/NIST.FIPS.180-4, August 2015.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SHS] Dang、Q。、「Secure Hash Standard（SHS）」、米国国立標準技術研究所レポート、DOI 10.6028 / NIST.FIPS.180-4、2015年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X690] ITU-T, &#34;Information technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)&#34;, ISO/IEC 8825-1:2015, November 2015.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X690] ITU-T、「情報技術-ASN.1エンコードルール：基本エンコードルール（BER）、標準エンコードルール（CER）および識別エンコードルール（DER）の仕様」、ISO / IEC 8825-1：2015 、2015年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2。 参考資料
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AEAD-LIMITS] Luykx, A. and K. Paterson, &#34;Limits on Authenticated Encryption Use in TLS&#34;, August 2017, &lt;http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AEAD-LIMITS] Luykx、A.、K。Paterson、「TLSでの認証済み暗号化使用の制限」、2017年8月、&lt;http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BBFGKZ16] Bhargavan, K., Brzuska, C., Fournet, C., Green, M., Kohlweiss, M., and S. Zanella-Beguelin, &#34;Downgrade Resilience in Key-Exchange Protocols&#34;, Proceedings of IEEE Symposium on Security and Privacy (San Jose), DOI 10.1109/SP.2016.37, May 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BBFGKZ16]バルガヴァン、K。、ブルズカ、C。、フォーネット、C。、グリーン、M。、コールワイス、M。、およびS.ザネラ-ベグリン、「キー交換プロトコルの回復力のダウングレード」、IEEEシンポジウムの議事録 セキュリティとプライバシー（サンノゼ）、DOI 10.1109 / SP.2016.37、2016年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BBK17] Bhargavan, K., Blanchet, B., and N. Kobeissi, &#34;Verified Models and Reference Implementations for the TLS 1.3 Standard Candidate&#34;, Proceedings of IEEE Symposium on Security and Privacy (San Jose), DOI 10.1109/SP.2017.26, May 2017.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BBK17] Bhargavan、K.、Blanchet、B。、およびN. Kobeissi、「TLS 1.3標準候補の検証済みモデルおよび参照実装」、IEEE Symposium on Security and Privacy（San Jose）、DOI 10.1109 / SP。 2017.26、2017年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BDFKPPRSZZ16] Bhargavan, K., Delignat-Lavaud, A., Fournet, C., Kohlweiss, M., Pan, J., Protzenko, J., Rastogi, A., Swamy, N., Zanella-Beguelin, S., and J. Zinzindohoue, &#34;Implementing and Proving the TLS 1.3 Record Layer&#34;, Proceedings of IEEE Symposium on Security and Privacy (San Jose), May 2017, &lt;https://eprint.iacr.org/2016/1178&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BDFKPPRSZZ16] Bhargavan、K.、Delignat-Lavaud、A.、Fournet、C.、Kohlweiss、M.、Pan、J.、Protzenko、J.、Rastogi、A.、Swamy、N.、Zanella-Beguelin、S 。、およびJ. Zinzindohoue、「TLS 1.3レコード層の実装と証明」、セキュリティとプライバシーに関するIEEEシンポジウムの議事録（サンノゼ）、2017年5月、&lt;https://eprint.iacr.org/2016/1178&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Ben17a] Benjamin, D., &#34;Presentation before the TLS WG at IETF 100&#34;, November 2017, &lt;https://datatracker.ietf.org/meeting/100/materials/ slides-100-tls-sessa-tls13/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Ben17a] Benjamin、D。、「IETF 100でのTLS WGの前のプレゼンテーション」、2017年11月、&lt;https://datatracker.ietf.org/meeting/100/materials/ slides-100-tls-sessa-tls13 /&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Ben17b] Benjamin, D., &#34;Additional TLS 1.3 results from Chrome&#34;, message to the TLS mailing list, 18 December 2017, &lt;https://www.ietf.org/mail-archive/web/tls/current/ msg25168.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Ben17b] Benjamin、D。、「Chromeからの追加TLS 1.3結果」、TLSメーリングリストへのメッセージ、2017年12月18日、&lt;https://www.ietf.org/mail-archive/web/tls/current/ msg25168 .html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Blei98] Bleichenbacher, D., &#34;Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1&#34;, Proceedings of CRYPTO &#39;98, 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Blei98] Bleichenbacher、D。、「RSA暗号化標準PKCS＃1に基づくプロトコルに対する選択された暗号文攻撃」、Proceedings of CRYPTO &#39;98、1998年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BMMRT15] Badertscher, C., Matt, C., Maurer, U., Rogaway, P., and B. Tackmann, &#34;Augmented Secure Channels and the Goal of the TLS 1.3 Record Layer&#34;, ProvSec 2015, September 2015, &lt;https://eprint.iacr.org/2015/394&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BMMRT15] Badertscher、C.、Matt、C.、Maurer、U.、Rogaway、P.、およびB. Tackmann、 &#34;Augmented Secure Channels and the Goal of the TLS 1.3 Record Layer&#34;、ProvSec 2015、September 2015、&lt; https://eprint.iacr.org/2015/394&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BT16] Bellare, M. and B. Tackmann, &#34;The Multi-User Security of Authenticated Encryption: AES-GCM in TLS 1.3&#34;, Proceedings of CRYPTO 2016, July 2016, &lt;https://eprint.iacr.org/2016/564&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BT16] Bellare、M.、B。Tackmann、「認証済み暗号化のマルチユーザーセキュリティ：AES-GCM in TLS 1.3」、Proceedings of CRYPTO 2016、2016年7月、&lt;https://eprint.iacr.org/2016 / 564&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CCG16] Cohn-Gordon, K., Cremers, C., and L. Garratt, &#34;On Post-compromise Security&#34;, IEEE Computer Security Foundations Symposium, DOI 10.1109/CSF.2016.19, July 2015.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CCG16] Cohn-Gordon、K.、Cremers、C。、およびL. Garratt、「事後のセキュリティについて」、IEEE Computer Security Foundations Symposium、DOI 10.1109 / CSF.2016.19、2015年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CHECKOWAY] Checkoway, S., Maskiewicz, J., Garman, C., Fried, J., Cohney, S., Green, M., Heninger, N., Weinmann, R., Rescorla, E., and H. Shacham, &#34;A Systematic Analysis of the Juniper Dual EC Incident&#34;, Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security - CCS &#39;16, DOI 10.1145/2976749.2978395, October 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CHECKOWAY] Checkoway、S.、Maskiewicz、J.、Garman、C.、Fried、J.、Cohney、S.、Green、M.、Heninger、N.、Weinmann、R.、Rescorla、E.、およびH 。Shacham、「ジュニパーデュアルECインシデントの体系的分析」、コンピューターおよび通信セキュリティに関する2016 ACM SIGSAC会議の議事録-CCS &#39;16、DOI 10.1145 / 2976749.2978395、2016年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CHHSV17] Cremers, C., Horvat, M., Hoyland, J., Scott, S., and T. van der Merwe, &#34;Awkward Handshake: Possible mismatch of client/server view on client authentication in post-handshake mode in Revision 18&#34;, message to the TLS mailing list, 10 February 2017, &lt;https://www.ietf.org/ mail-archive/web/tls/current/msg22382.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CHHSV17] Cremers、C.、Horvat、M.、Hoyland、J.、Scott、S.、およびT. van der Merwe、 &#34;厄介なハンドシェイク：でのクライアント認証のクライアント/サーバービューの不一致の可能性 改訂18 &#34;、TLSメーリングリストへのメッセージ、2017年2月10日、&lt;https://www.ietf.org/ mail-archive / web / tls / current / msg22382.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CHSV16] Cremers, C., Horvat, M., Scott, S., and T. van der Merwe, &#34;Automated Analysis and Verification of TLS 1.3: 0-RTT, Resumption and Delayed Authentication&#34;, Proceedings of IEEE Symposium on Security and Privacy (San Jose), DOI 10.1109/SP.2016.35, May 2016, &lt;https://ieeexplore.ieee.org/document/7546518/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CHSV16] Cremers、C.、Horvat、M.、Scott、S。、およびT. van der Merwe、「TLS 1.3の自動化された分析と検証：0-RTT、再開および遅延認証」、IEEE Symposium on Securityの議事録 and Privacy（San Jose）、DOI 10.1109 / SP.2016.35、2016年5月、&lt;https://ieeexplore.ieee.org/document/7546518/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CK01] Canetti, R. and H. Krawczyk, &#34;Analysis of Key-Exchange Protocols and Their Use for Building Secure Channels&#34;, Proceedings of Eurocrypt 2001, DOI 10.1007/3-540-44987-6_28, April 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CK01] Canetti、R.およびH. Krawczyk、「鍵交換プロトコルの分析と安全なチャネルの構築のための使用」、Eurocrypt 2001の議事録、DOI 10.1007 / 3-540-44987-6_28、2001年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CLINIC] Miller, B., Huang, L., Joseph, A., and J. Tygar, &#34;I Know Why You Went to the Clinic: Risks and Realization of HTTPS Traffic Analysis&#34;, Privacy Enhancing Technologies, pp. 143-163, DOI 10.1007/978-3-319-08506-7_8, 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CLINIC] Miller、B.、Huang、L.、Joseph、A。、およびJ. Tygar、「あなたがクリニックに行った理由を知っています：HTTPSトラフィック分析のリスクと実現」、プライバシー強化技術、pp。143- 163、DOI 10.1007 / 978-3-319-08506-7_8、2014。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DFGS15] Dowling, B., Fischlin, M., Guenther, F., and D. Stebila, &#34;A Cryptographic Analysis of the TLS 1.3 Handshake Protocol Candidates&#34;, Proceedings of ACM CCS 2015, October 2015, &lt;https://eprint.iacr.org/2015/914&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DFGS15] Dowling、B.、Fischlin、M.、Guenther、F。、およびD. Stebila、「TLS 1.3ハンドシェイクプロトコル候補の暗号分析」、Proceedings of ACM CCS 2015、2015年10月、&lt;https：// eprint.iacr.org/2015/914&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DFGS16] Dowling, B., Fischlin, M., Guenther, F., and D. Stebila, &#34;A Cryptographic Analysis of the TLS 1.3 Full and Pre-shared Key Handshake Protocol&#34;, TRON 2016, February 2016, &lt;https://eprint.iacr.org/2016/081&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DFGS16] Dowling、B.、Fischlin、M.、Guenther、F。、およびD. Stebila、「TLS 1.3完全および事前共有キーハンドシェイクプロトコルの暗号分析」、TRON 2016、2016年2月、&lt;https： //eprint.iacr.org/2016/081&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DOW92] Diffie, W., van Oorschot, P., and M. Wiener, &#34;Authentication and authenticated key exchanges&#34;, Designs, Codes and Cryptography, DOI 10.1007/BF00124891, June 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DOW92] Diffie、W.、van Oorschot、P。、およびM. Wiener、「Authentication and authentication key exchanges」、Designs、Codes and Cryptography、DOI 10.1007 / BF00124891、1992年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DSS] National Institute of Standards and Technology, U.S. Department of Commerce, &#34;Digital Signature Standard (DSS)&#34;, NIST FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[DSS]米国国立標準技術研究所、米国商務省、「デジタル署名標準（DSS）」、NIST FIPS PUB 186-4、DOI 10.6028 / NIST.FIPS.186-4、2013年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[FG17] Fischlin, M. and F. Guenther, &#34;Replay Attacks on Zero Round-Trip Time: The Case of the TLS 1.3 Handshake Candidates&#34;, Proceedings of EuroS&amp;P 2017, April 2017, &lt;https://eprint.iacr.org/2017/082&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[FG17] Fischlin、M.、F。Guenther、「ラウンドトリップ時間ゼロでのリプレイ攻撃：TLS 1.3ハンドシェイク候補のケース」、EuroS＆P 2017年版、2017年4月、&lt;https://eprint.iacr.org / 2017/082&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[FGSW16] Fischlin, M., Guenther, F., Schmidt, B., and B. Warinschi, &#34;Key Confirmation in Key Exchange: A Formal Treatment and Implications for TLS 1.3&#34;, Proceedings of IEEE Symposium on Security and Privacy (San Jose), DOI 10.1109/SP.2016.34, May 2016, &lt;https://ieeexplore.ieee.org/document/7546517/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[FGSW16] Fischlin、M.、Guenther、F.、Schmidt、B.、およびB. Warinschi、 &#34;鍵交換における鍵の確認：TLS 1.3の形式的な扱いと意味&#34;、セキュリティとプライバシーに関するIEEEシンポジウムの議事録（サン Jose）、DOI 10.1109 / SP.2016.34、2016年5月、&lt;https://ieeexplore.ieee.org/document/7546517/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[FW15] Weimer, F., &#34;Factoring RSA Keys With TLS Perfect Forward Secrecy&#34;, September 2015.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[FW15] Weimer、F。、「TLS Perfect Forward SecrecyによるRSAキーのファクタリング」、2015年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HCJC16] Husak, M., Cermak, M., Jirsik, T., and P. Celeda, &#34;HTTPS traffic analysis and client identification using passive SSL/TLS fingerprinting&#34;, EURASIP Journal on Information Security, Vol. 2016, DOI 10.1186/s13635-016-0030-7, February 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HCJC16] Husak、M.、Cermak、M.、Jirsik、T。、およびP. Celeda、「パッシブSSL / TLSフィンガープリンティングを使用したHTTPSトラフィック分析およびクライアント識別」、EURASIP Journal on Information Security、Vol。 2016年、DOI 10.1186 / s13635-016-0030-7、2016年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HGFS15] Hlauschek, C., Gruber, M., Fankhauser, F., and C. Schanes, &#34;Prying Open Pandora&#39;s Box: KCI Attacks against TLS&#34;, Proceedings of USENIX Workshop on Offensive Technologies, August 2015.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HGFS15] Hlauschek、C.、Gruber、M.、Fankhauser、F.、and C. Schanes、 &#34;Prying Open Pandora&#39;s Box：KCI Attacks against TLS&#34;、Proceedings of USENIX Workshop on Offensive Technologies、August 2015。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IEEE1363] IEEE, &#34;IEEE Standard Specifications for Public Key Cryptography&#34;, IEEE Std. 1363-2000, DOI 10.1109/IEEESTD.2000.92292.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IEEE1363] IEEE、「公開鍵暗号のIEEE標準仕様」、IEEE Std。 1363-2000、DOI 10.1109 / IEEESTD.2000.92292。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[JSS15] Jager, T., Schwenk, J., and J. Somorovsky, &#34;On the Security of TLS 1.3 and QUIC Against Weaknesses in PKCS#1 v1.5 Encryption&#34;, Proceedings of ACM CCS 2015, DOI 10.1145/2810103.2813657, October 2015, &lt;https://www.nds.rub.de/media/nds/ veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[JSS15] Jager、T.、Schwenk、J。、およびJ. Somorovsky、「TLS 1.3およびPKCS＃1 v1.5暗号化の弱点に対するQUICのセキュリティについて」、Proceedings of ACM CCS 2015、DOI 10.1145 / 2810103.2813657、2015年10月、&lt;https://www.nds.rub.de/media/nds/ veroeffentlichungen/2015/8月21日/ Tls13QuicAttacks.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KEYAGREEMENT] Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R. Davis, &#34;Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography&#34;, National Institute of Standards and Technology, DOI 10.6028/NIST.SP.800-56Ar3, April 2018.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KEYAGREEMENT] Barker、E.、Chen、L.、Roginsky、A.、Vassilev、A.、and R. Davis、 &#34;Recommendation for Pair-Wise Key Establishment Schemes Using Using Discrete Logarithm Cryptography&#34;、National Institute of Standard and Technology、 DOI 10.6028 / NIST.SP.800-56Ar3、2018年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Kraw10] Krawczyk, H., &#34;Cryptographic Extraction and Key Derivation: The HKDF Scheme&#34;, Proceedings of CRYPTO 2010, August 2010, &lt;https://eprint.iacr.org/2010/264&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Kraw10] Krawczyk、H。、「暗号の抽出とキーの導出：HKDFスキーム」、Proceedings of CRYPTO 2010、2010年8月、&lt;https://eprint.iacr.org/2010/264&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Kraw16] Krawczyk, H., &#34;A Unilateral-to-Mutual Authentication Compiler for Key Exchange (with Applications to Client Authentication in TLS 1.3&#34;, Proceedings of ACM CCS 2016, October 2016, &lt;https://eprint.iacr.org/2016/711&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Kraw16] Krawczyk、H.、「鍵交換のための片側から相互への認証コンパイラー（TLS 1.3でのクライアント認証へのアプリケーションを使用）」、ACM CCS 2016年版、2016年10月、&lt;https://eprint.iacr.org / 2016/711&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KW16] Krawczyk, H. and H. Wee, &#34;The OPTLS Protocol and TLS 1.3&#34;, Proceedings of EuroS&amp;P 2016, March 2016, &lt;https://eprint.iacr.org/2015/978&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[KW16] Krawczyk、H. and H. Wee、 &#34;The OPTLS Protocol and TLS 1.3&#34;、Proceedings of EuroS＆P 2016、March 2016、&lt;https://eprint.iacr.org/2015/978&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[LXZFH16] Li, X., Xu, J., Zhang, Z., Feng, D., and H. Hu, &#34;Multiple Handshakes Security of TLS 1.3 Candidates&#34;, Proceedings of IEEE Symposium on Security and Privacy (San Jose), DOI 10.1109/SP.2016.36, May 2016, &lt;https://ieeexplore.ieee.org/document/7546519/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[LXZFH16] Li、X.、Xu、J.、Zhang、Z.、Feng、D。、およびH. Hu、「TLS 1.3候補の複数のハンドシェイクセキュリティ」、セキュリティとプライバシーに関するIEEEシンポジウムの議事録（サンノゼ） 、DOI 10.1109 / SP.2016.36、2016年5月、&lt;https://ieeexplore.ieee.org/document/7546519/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Mac17] MacCarthaigh, C., &#34;Security Review of TLS1.3 0-RTT&#34;, March 2017, &lt;https://github.com/tlswg/tls13-spec/ issues/1001&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Mac17] MacCarthaigh、C。、「TLS1.3 0-RTTのセキュリティレビュー」、2017年3月、&lt;https://github.com/tlswg/tls13-spec/ issues / 1001&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PS18] Patton, C. and T. Shrimpton, &#34;Partially specified channels: The TLS 1.3 record layer without elision&#34;, 2018, &lt;https://eprint.iacr.org/2018/634&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PS18] Patton、C.およびT. Shrimpton、「部分的に指定されたチャネル：省略のないTLS 1.3レコード層」、2018年、&lt;https://eprint.iacr.org/2018/634&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PSK-FINISHED] Scott, S., Cremers, C., Horvat, M., and T. van der Merwe, &#34;Revision 10: possible attack if client authentication is allowed during PSK&#34;, message to the TLS mailing list, 31 October 2015, &lt;https://www.ietf.org/ mail-archive/web/tls/current/msg18215.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[PSK-FINISHED] Scott、S.、Cremers、C.、Horvat、M。、およびT. van der Merwe、「Revision 10：PSK中にクライアント認証が許可された場合の攻撃の可能性」、TLSメーリングリストへのメッセージ、31 2015年10月、&lt;https://www.ietf.org/ mail-archive / web / tls / current / msg18215.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[REKEY] Abdalla, M. and M. Bellare, &#34;Increasing the Lifetime of a Key: A Comparative Analysis of the Security of Re-keying Techniques&#34;, ASIACRYPT 2000, DOI 10.1007/3-540-44448-3_42, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[REKEY] Abdalla、M.、M。Bellare、「鍵の寿命を延ばす：再鍵技術のセキュリティの比較分析」、ASIACRYPT 2000、DOI 10.1007 / 3-540-44448-3_42、2000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Res17a] Rescorla, E., &#34;Preliminary data on Firefox TLS 1.3 Middlebox experiment&#34;, message to the TLS mailing list, 5 December 2017, &lt;https://www.ietf.org/ mail-archive/web/tls/current/msg25091.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Res17a] Rescorla、E。、「Firefox TLS 1.3 Middlebox実験の予備データ」、TLSメーリングリストへのメッセージ、2017年12月5日、&lt;https://www.ietf.org/ mail-archive / web / tls / current /msg25091.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Res17b] Rescorla, E., &#34;More compatibility measurement results&#34;, message to the TLS mailing list, 22 December 2017, &lt;https://www.ietf.org/mail-archive/web/tls/current/ msg25179.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Res17b] Rescorla、E。、「その他の互換性測定結果」、TLSメーリングリストへのメッセージ、2017年12月22日、&lt;https://www.ietf.org/mail-archive/web/tls/current/ msg25179.html &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3552] Rescorla, E. and B. Korver, &#34;Guidelines for Writing RFC Text on Security Considerations&#34;, BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003, &lt;https://www.rfc-editor.org/info/rfc3552&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3552] Rescorla、E。、およびB. Korver、「セキュリティに関する考慮事項に関するRFCテキストの作成ガイドライン」、BCP 72、RFC 3552、DOI 10.17487 / RFC3552、2003年7月、&lt;https://www.rfc-editor.org/ info / rfc3552&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, &lt;https://www.rfc-editor.org/info/rfc4086&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4086] Eastlake 3rd、D.、Schiller、J。、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、2005年6月、&lt;https：//www.rfc-editor .org / info / rfc4086&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4346] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.1&#34;, RFC 4346, DOI 10.17487/RFC4346, April 2006, &lt;https://www.rfc-editor.org/info/rfc4346&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4346] Dierks、T。およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.1」、RFC 4346、DOI 10.17487 / RFC4346、2006年4月、&lt;https://www.rfc-editor.org/info / rfc4346&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4366] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, &#34;Transport Layer Security (TLS) Extensions&#34;, RFC 4366, DOI 10.17487/RFC4366, April 2006, &lt;https://www.rfc-editor.org/info/rfc4366&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4366] Blake-Wilson、S.、Nystrom、M.、Hopwood、D.、Mikkelsen、J。、およびT. Wright、「Transport Layer Security（TLS）Extensions」、RFC 4366、DOI 10.17487 / RFC4366、2006年4月 、&lt;https://www.rfc-editor.org/info/rfc4366&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4492] Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, &#34;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)&#34;, RFC 4492, DOI 10.17487/RFC4492, May 2006, &lt;https://www.rfc-editor.org/info/rfc4492&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4492] Blake-Wilson、S.、Bolyard、N.、Gupta、V.、Hawk、C。、およびB. Moeller、「Elliptic Curve Cryptography（ECC）Cipher Suites for Transport Layer Security（TLS）」、RFC 4492 、DOI 10.17487 / RFC4492、2006年5月、&lt;https://www.rfc-editor.org/info/rfc4492&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5077] Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig, &#34;Transport Layer Security (TLS) Session Resumption without Server-Side State&#34;, RFC 5077, DOI 10.17487/RFC5077, January 2008, &lt;https://www.rfc-editor.org/info/rfc5077&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5077] Salowey、J.、Zhou、H.、Eronen、P。、およびH. Tschofenig、「サーバー側の状態なしのトランスポート層セキュリティ（TLS）セッション再開」、RFC 5077、DOI 10.17487 / RFC5077、2008年1月、 &lt;https://www.rfc-editor.org/info/rfc5077&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5246] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, DOI 10.17487/RFC5246, August 2008, &lt;https://www.rfc-editor.org/info/rfc5246&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5246] Dierks、T。およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、&lt;https://www.rfc-editor.org/info / rfc5246&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5764] McGrew, D. and E. Rescorla, &#34;Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)&#34;, RFC 5764, DOI 10.17487/RFC5764, May 2010, &lt;https://www.rfc-editor.org/info/rfc5764&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5764] McGrew、D。およびE. Rescorla、「セキュアリアルタイムトランスポートプロトコル（SRTP）のキーを確立するためのデータグラムトランスポートレイヤーセキュリティ（DTLS）拡張」、RFC 5764、DOI 10.17487 / RFC5764、2010年5月、&lt;https ：//www.rfc-editor.org/info/rfc5764&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5929] Altman, J., Williams, N., and L. Zhu, &#34;Channel Bindings for TLS&#34;, RFC 5929, DOI 10.17487/RFC5929, July 2010, &lt;https://www.rfc-editor.org/info/rfc5929&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5929] Altman、J.、Williams、N。、およびL. Zhu、「TLSのチャネルバインディング」、RFC 5929、DOI 10.17487 / RFC5929、2010年7月、&lt;https://www.rfc-editor.org/info / rfc5929&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6091] Mavrogiannopoulos, N. and D. Gillmor, &#34;Using OpenPGP Keys for Transport Layer Security (TLS) Authentication&#34;, RFC 6091, DOI 10.17487/RFC6091, February 2011, &lt;https://www.rfc-editor.org/info/rfc6091&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6091] Mavrogiannopoulos、N。およびD. Gillmor、「トランスポート層セキュリティ（TLS）認証のためのOpenPGPキーの使用」、RFC 6091、DOI 10.17487 / RFC6091、2011年2月、&lt;https://www.rfc-editor.org/ info / rfc6091&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6101] Freier, A., Karlton, P., and P. Kocher, &#34;The Secure Sockets Layer (SSL) Protocol Version 3.0&#34;, RFC 6101, DOI 10.17487/RFC6101, August 2011, &lt;https://www.rfc-editor.org/info/rfc6101&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6101] Freier、A.、Karlton、P。、およびP. Kocher、「Secure Sockets Layer（SSL）Protocol Version 3.0」、RFC 6101、DOI 10.17487 / RFC6101、2011年8月、&lt;https：//www.rfc -editor.org/info/rfc6101&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6176] Turner, S. and T. Polk, &#34;Prohibiting Secure Sockets Layer (SSL) Version 2.0&#34;, RFC 6176, DOI 10.17487/RFC6176, March 2011, &lt;https://www.rfc-editor.org/info/rfc6176&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6176]ターナー、S。およびT.ポーク、「Prohibiting Secure Sockets Layer（SSL）Version 2.0」、RFC 6176、DOI 10.17487 / RFC6176、2011年3月、&lt;https://www.rfc-editor.org/info/ rfc6176&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6347] Rescorla, E. and N. Modadugu, &#34;Datagram Transport Layer Security Version 1.2&#34;, RFC 6347, DOI 10.17487/RFC6347, January 2012, &lt;https://www.rfc-editor.org/info/rfc6347&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6347] Rescorla、E。およびN. Modadugu、「データグラムトランスポートレイヤーセキュリティバージョン1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、&lt;https://www.rfc-editor.org/info/rfc6347&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6520] Seggelmann, R., Tuexen, M., and M. Williams, &#34;Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension&#34;, RFC 6520, DOI 10.17487/RFC6520, February 2012, &lt;https://www.rfc-editor.org/info/rfc6520&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6520] Seggelmann、R.、Tuexen、M。、およびM. Williams、「トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）ハートビート拡張」、RFC 6520、DOI 10.17487 / RFC6520、2012年2月、&lt;https ：//www.rfc-editor.org/info/rfc6520&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., &#34;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&#34;, RFC 7230, DOI 10.17487/RFC7230, June 2014, &lt;https://www.rfc-editor.org/info/rfc7230&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7230]フィールディング、R。、エド。 およびJ. Reschke、Ed。、「ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文とルーティング」、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、&lt;https://www.rfc-editor.org/info/ rfc7230&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7250] Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J., Weiler, S., and T. Kivinen, &#34;Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&#34;, RFC 7250, DOI 10.17487/RFC7250, June 2014, &lt;https://www.rfc-editor.org/info/rfc7250&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7250] Wouters、P.、Ed。、Tschofenig、H.、Ed。、Gilmore、J.、Weiler、S。、およびT. Kivinen、「Transport Layer Security（TLS）およびDatagram Transport LayerでのRaw公開鍵の使用」 セキュリティ（DTLS）」、RFC 7250、DOI 10.17487 / RFC7250、2014年6月、&lt;https://www.rfc-editor.org/info/rfc7250&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7465] Popov, A., &#34;Prohibiting RC4 Cipher Suites&#34;, RFC 7465, DOI 10.17487/RFC7465, February 2015, &lt;https://www.rfc-editor.org/info/rfc7465&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7465] Popov、A。、「RC4暗号スイートの禁止」、RFC 7465、DOI 10.17487 / RFC7465、2015年2月、&lt;https://www.rfc-editor.org/info/rfc7465&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7568] Barnes, R., Thomson, M., Pironti, A., and A. Langley, &#34;Deprecating Secure Sockets Layer Version 3.0&#34;, RFC 7568, DOI 10.17487/RFC7568, June 2015, &lt;https://www.rfc-editor.org/info/rfc7568&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7568]バーンズ、R。、トムソン、M。、ピロンティ、A。、およびA.ラングレー、「非推奨のSecure Sockets Layerバージョン3.0」、RFC 7568、DOI 10.17487 / RFC7568、2015年6月、&lt;https：// www。 rfc-editor.org/info/rfc7568&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7627] Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A., Langley, A., and M. Ray, &#34;Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension&#34;, RFC 7627, DOI 10.17487/RFC7627, September 2015, &lt;https://www.rfc-editor.org/info/rfc7627&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7627] Bhargavan、K.、Ed。、Delignat-Lavaud、A.、Pironti、A.、Langley、A。、およびM. Ray、「Transport Layer Security（TLS）Session Hash and Extended Master Secret Extension」、RFC 7627、DOI 10.17487 / RFC7627、2015年9月、&lt;https://www.rfc-editor.org/info/rfc7627&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7685] Langley, A., &#34;A Transport Layer Security (TLS) ClientHello Padding Extension&#34;, RFC 7685, DOI 10.17487/RFC7685, October 2015, &lt;https://www.rfc-editor.org/info/rfc7685&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7685] Langley、A。、「A Transport Layer Security（TLS）ClientHello Padding Extension」、RFC 7685、DOI 10.17487 / RFC7685、2015年10月、&lt;https://www.rfc-editor.org/info/rfc7685&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7924] Santesson, S. and H. Tschofenig, &#34;Transport Layer Security (TLS) Cached Information Extension&#34;, RFC 7924, DOI 10.17487/RFC7924, July 2016, &lt;https://www.rfc-editor.org/info/rfc7924&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7924] Santesson、S.およびH. Tschofenig、「トランスポート層セキュリティ（TLS）キャッシュ情報拡張機能」、RFC 7924、DOI 10.17487 / RFC7924、2016年7月、&lt;https://www.rfc-editor.org/info/ rfc7924&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8305] Schinazi, D. and T. Pauly, &#34;Happy Eyeballs Version 2: Better Connectivity Using Concurrency&#34;, RFC 8305, DOI 10.17487/RFC8305, December 2017, &lt;https://www.rfc-editor.org/info/rfc8305&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8305] Schinazi、D. and T. Pauly、 &#34;Happy Eyeballs Version 2：Better Connectivity Using Concurrency&#34;、RFC 8305、DOI 10.17487 / RFC8305、2017年12月、&lt;https://www.rfc-editor.org/info/ rfc8305&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8422] Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, &#34;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier&#34;, RFC 8422, DOI 10.17487/RFC8422, August 2018, &lt;https://www.rfc-editor.org/info/rfc8422&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8422] Nir、Y.、Josefsson、S。、およびM. Pegourie-Gonnard、「トランスポート層セキュリティ（TLS）バージョン1.2以前の楕円曲線暗号（ECC）暗号スイート」、RFC 8422、DOI 10.17487 / RFC8422 2018年8月、&lt;https://www.rfc-editor.org/info/rfc8422&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8447] Salowey, J. and S. Turner, &#34;IANA Registry Updates for TLS and DTLS&#34;, RFC 8447, DOI 10.17487/RFC8447, August 2018, &lt;https://www.rfc-editor.org/info/rfc8447&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8447] Salowey、J。およびS. Turner、「TLSおよびDTLSのIANAレジストリ更新」、RFC 8447、DOI 10.17487 / RFC8447、2018年8月、&lt;https://www.rfc-editor.org/info/rfc8447&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8449] Thomson, M., &#34;Record Size Limit Extension for TLS&#34;, RFC 8449, DOI 10.17487/RFC8449, August 2018, &lt;https://www.rfc-editor.org/info/rfc8449&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8449] Thomson、M。、「TLSのレコードサイズ制限拡張」、RFC 8449、DOI 10.17487 / RFC8449、2018年8月、&lt;https://www.rfc-editor.org/info/rfc8449&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RSA] Rivest, R., Shamir, A., and L. Adleman, &#34;A Method for Obtaining Digital Signatures and Public-Key Cryptosystems&#34;, Communications of the ACM, Vol. 21 No. 2, pp. 120-126, DOI 10.1145/359340.359342, February 1978.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RSA] Rivest、R.、Shamir、A。、およびL. Adleman、「デジタル署名および公開鍵暗号システムを取得する方法」、ACMの通信、Vol。 21 No. 2、pp。120-126、DOI 10.1145 / 359340.359342、1978年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SIGMA] Krawczyk, H., &#34;SIGMA: The &#39;SIGn-and-MAc&#39; Approach to Authenticated Diffie-Hellman and its Use in the IKE Protocols&#34;, Proceedings of CRYPTO 2003, DOI 10.1007/978-3-540-45146-4_24, August 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SIGMA] Krawczyk、H。、「SIGMA：認証されたDiffie-Hellmanへの「SIGn-and-MAc」アプローチとIKEプロトコルでの使用」、Proceedings of CRYPTO 2003、DOI 10.1007 / 978-3-540-45146- 4_24、2003年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SLOTH] Bhargavan, K. and G. Leurent, &#34;Transcript Collision Attacks: Breaking Authentication in TLS, IKE, and SSH&#34;, Network and Distributed System Security Symposium (NDSS 2016), DOI 10.14722/ndss.2016.23418, February 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SLOTH] Bhargavan、K.、G。Leurent、「トランスクリプト衝突攻撃：TLS、IKE、およびSSHでの認証の破壊」、ネットワークおよび分散システムセキュリティシンポジウム（NDSS 2016）、DOI 10.14722 / ndss.2016.23418、2016年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SSL2] Hickman, K., &#34;The SSL Protocol&#34;, February 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SSL2] Hickman、K。、「SSLプロトコル」、1995年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TIMING] Boneh, D. and D. Brumley, &#34;Remote Timing Attacks Are Practical&#34;, USENIX Security Symposium, August 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[タイミング] Boneh、D.、D。Brumley、「リモートタイミング攻撃は実用的」、USENIXセキュリティシンポジウム、2003年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TLS13-TRACES] Thomson, M., &#34;Example Handshake Traces for TLS 1.3&#34;, Work in Progress, draft-ietf-tls-tls13-vectors-06, July 2018.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[TLS13-TRACES] Thomson、M。、「TLS 1.3のハンドシェイクトレースの例」、Work in Progress、draft-ietf-tls-tls13-vectors-06、2018年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X501] ITU-T, &#34;Information Technology - Open Systems Interconnection - The Directory: Models&#34;, ITU-T X.501, October 2016, &lt;https://www.itu.int/rec/T-REC-X.501/en&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X501] ITU-T、「情報技術-オープンシステム相互接続-ディレクトリ：モデル」、ITU-T X.501、2016年10月、&lt;https://www.itu.int/rec/T-REC-X。 501 / en&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A. State Machine
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A.ステートマシン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This appendix provides a summary of the legal state transitions for the client and server handshakes. State names (in all capitals, e.g., START) have no formal meaning but are provided for ease of comprehension. Actions which are taken only in certain circumstances are indicated in []. The notation &#34;K_{send,recv} = foo&#34; means &#34;set the send/recv key to the given key&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この付録では、クライアントとサーバーのハンドシェイクの正当な状態遷移の概要を示します。 州名（すべての大文字、例えばSTART）には正式な意味はありませんが、理解を容易にするために提供されています。 特定の状況でのみ実行されるアクションは[]に示されています。 「K_ {send、recv} = foo」という表記は、「send / recvキーを指定のキーに設定する」ことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1. Client
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1。 クライアント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                              START &lt;----+
               Send ClientHello |        | Recv HelloRetryRequest
          [K_send = early data] |        |
                                v        |
           /                 WAIT_SH ----+
           |                    | Recv ServerHello
           |                    | K_recv = handshake
       Can |                    V
      send |                 WAIT_EE
     early |                    | Recv EncryptedExtensions
      data |           +--------+--------+
           |     Using |                 | Using certificate
           |       PSK |                 v
           |           |            WAIT_CERT_CR
           |           |        Recv |       | Recv CertificateRequest
           |           | Certificate |       v
           |           |             |    WAIT_CERT
           |           |             |       | Recv Certificate
           |           |             v       v
           |           |              WAIT_CV
           |           |                 | Recv CertificateVerify
           |           +&gt; WAIT_FINISHED &lt;+
           |                  | Recv Finished
           \                  | [Send EndOfEarlyData]
                              | K_send = handshake
                              | [Send Certificate [+ CertificateVerify]]
    Can send                  | Send Finished
    app data   --&gt;            | K_send = K_recv = application
    after here                v
                          CONNECTED
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that with the transitions as shown above, clients may send alerts that derive from post-ServerHello messages in the clear or with the early data keys. If clients need to send such alerts, they SHOULD first rekey to the handshake keys if possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の遷移では、クライアントは平文または初期データキーでpost-ServerHelloメッセージから派生したアラートを送信する場合があることに注意してください。 クライアントがそのようなアラートを送信する必要がある場合、可能であれば最初にハンドシェイクキーのキーを再生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.2. Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.2。 サーバ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                              START &lt;-----+
               Recv ClientHello |         | Send HelloRetryRequest
                                v         |
                             RECVD_CH ----+
                                | Select parameters
                                v
                             NEGOTIATED
                                | Send ServerHello
                                | K_send = handshake
                                | Send EncryptedExtensions
                                | [Send CertificateRequest]
 Can send                       | [Send Certificate + CertificateVerify]
 app data                       | Send Finished
 after   --&gt;                    | K_send = application
 here                  +--------+--------+
              No 0-RTT |                 | 0-RTT
                       |                 |
   K_recv = handshake  |                 | K_recv = early data
 [Skip decrypt errors] |    +------&gt; WAIT_EOED -+
                       |    |       Recv |      | Recv EndOfEarlyData
                       |    | early data |      | K_recv = handshake
                       |    +------------+      |
                       |                        |
                       +&gt; WAIT_FLIGHT2 &lt;--------+
                                |
                       +--------+--------+
               No auth |                 | Client auth
                       |                 |
                       |                 v
                       |             WAIT_CERT
                       |        Recv |       | Recv Certificate
                       |       empty |       v
                       | Certificate |    WAIT_CV
                       |             |       | Recv
                       |             v       | CertificateVerify
                       +-&gt; WAIT_FINISHED &lt;---+
                                | Recv Finished
                                | K_recv = application
                                v
                            CONNECTED
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix B. Protocol Data Structures and Constant Values
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録B.プロトコルのデータ構造と定数値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This appendix provides the normative protocol types and the definitions for constants. Values listed as &#34;_RESERVED&#34; were used in previous versions of TLS and are listed here for completeness. TLS 1.3 implementations MUST NOT send them but might receive them from older TLS implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この付録では、標準のプロトコルタイプと定数の定義を示します。 「_RESERVED」としてリストされている値は、TLSの以前のバージョンで使用されていたもので、完全を期すためにここにリストされています。 TLS 1.3実装はそれらを送信してはなりませんが、古いTLS実装から受信する場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1. Record Layer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1。 レコード層
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          heartbeat(24),  /* RFC 6520 */
          (255)
      } ContentType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2. Alert Messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2。 警告メッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum { warning(1), fatal(2), (255) } AlertLevel;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum {warning（1）、fatal（2）、（255）} AlertLevel;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum { close_notify(0), unexpected_message(10), bad_record_mac(20), decryption_failed_RESERVED(21), record_overflow(22), decompression_failure_RESERVED(30), handshake_failure(40), no_certificate_RESERVED(41), bad_certificate(42), unsupported_certificate(43), certificate_revoked(44), certificate_expired(45), certificate_unknown(46), illegal_parameter(47), unknown_ca(48), access_denied(49), decode_error(50), decrypt_error(51), export_restriction_RESERVED(60), protocol_version(70), insufficient_security(71), internal_error(80), inappropriate_fallback(86), user_canceled(90), no_renegotiation_RESERVED(100), missing_extension(109), unsupported_extension(110), certificate_unobtainable_RESERVED(111), unrecognized_name(112), bad_certificate_status_response(113), bad_certificate_hash_value_RESERVED(114), unknown_psk_identity(115), certificate_required(116), no_application_protocol(120), (255) } AlertDescription;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum {close_notify（0）、unexpected_message（10）、bad_record_mac（20）、decryption_failed_RESERVED（21）、record_overflow（22）、decompression_failure_RESERVED（30）、handshake_failure（40）、no_certificate_RESERVED（41）、bad_certificate（42）、unsupported_certificate ）、certificate_revoked（44）、certificate_expired（45）、certificate_unknown（46）、illegal_parameter（47）、unknown_ca（48）、access_denied（49）、decode_error（50）、decrypt_error（51）、export_restriction_RESERVED（60）、protocol_version（70 ）、不十分なセキュリティ（71）、内部エラー（80）、不適切なフォールバック（86）、ユーザーキャンセル（90）、no_renegotiation_RESERVED（100）、行方不明の拡張（109）、サポートされていない拡張（110）、証明書の未登録（111）、認識されていない名前（112）、応答しない状態 ）、bad_certificate_hash_value_RESERVED（114）、unknown_psk_identity（115）、certificate_required（116）、no_application_protocol（120）、（255）} AlertDescription;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3. Handshake Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3。 ハンドシェイクプロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          hello_request_RESERVED(0),
          client_hello(1),
          server_hello(2),
          hello_verify_request_RESERVED(3),
          new_session_ticket(4),
          end_of_early_data(5),
          hello_retry_request_RESERVED(6),
          encrypted_extensions(8),
          certificate(11),
          server_key_exchange_RESERVED(12),
          certificate_request(13),
          server_hello_done_RESERVED(14),
          certificate_verify(15),
          client_key_exchange_RESERVED(16),
          finished(20),
          certificate_url_RESERVED(21),
          certificate_status_RESERVED(22),
          supplemental_data_RESERVED(23),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.1. Key Exchange Messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.1。 キー交換メッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    uint16 ProtocolVersion;
    opaque Random[32];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    uint8 CipherSuite[2];    /* Cryptographic suite selector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
        Random random;
        opaque legacy_session_id&lt;0..32&gt;;
        CipherSuite cipher_suites&lt;2..2^16-2&gt;;
        opaque legacy_compression_methods&lt;1..2^8-1&gt;;
        Extension extensions&lt;8..2^16-1&gt;;
    } ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
        Random random;
        opaque legacy_session_id_echo&lt;0..32&gt;;
        CipherSuite cipher_suite;
        uint8 legacy_compression_method = 0;
        Extension extensions&lt;6..2^16-1&gt;;
    } ServerHello; struct {
        ExtensionType extension_type;
        opaque extension_data&lt;0..2^16-1&gt;;
    } Extension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        RESERVED(40),                               /* Used but never
                                                       assigned */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        RESERVED(46),                               /* Used but never
                                                       assigned */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        NamedGroup group;
        opaque key_exchange&lt;1..2^16-1&gt;;
    } KeyShareEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        KeyShareEntry client_shares&lt;0..2^16-1&gt;;
    } KeyShareClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        NamedGroup selected_group;
    } KeyShareHelloRetryRequest; struct {
        KeyShareEntry server_share;
    } KeyShareServerHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        uint8 legacy_form = 4;
        opaque X[coordinate_length];
        opaque Y[coordinate_length];
    } UncompressedPointRepresentation;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum {psk_ke（0）、psk_dhe_ke（1）、（255）} PskKeyExchangeMode;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        PskKeyExchangeMode ke_modes&lt;1..255&gt;;
    } PskKeyExchangeModes;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {} Empty;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {}空;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        select (Handshake.msg_type) {
            case new_session_ticket:   uint32 max_early_data_size;
            case client_hello:         Empty;
            case encrypted_extensions: Empty;
        };
    } EarlyDataIndication;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        opaque identity&lt;1..2^16-1&gt;;
        uint32 obfuscated_ticket_age;
    } PskIdentity;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque PskBinderEntry&lt;32..255&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不透明なPskBinderEntry &lt;32..255&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        PskIdentity identities&lt;7..2^16-1&gt;;
        PskBinderEntry binders&lt;33..2^16-1&gt;;
    } OfferedPsks;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    struct {
        select (Handshake.msg_type) {
            case client_hello: OfferedPsks;
            case server_hello: uint16 selected_identity;
        };
    } PreSharedKeyExtension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.1.1. Version Extension
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.1.1。 バージョン拡張
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions&lt;2..254&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.1.2. Cookie Extension
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.1.2。 Cookie拡張
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque cookie&lt;1..2^16-1&gt;;
      } Cookie;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.1.3. Signature Algorithm Extension
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.1.3。 署名アルゴリズムの拡張
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* Reserved Code Points */
          obsolete_RESERVED(0x0000..0x0200),
          dsa_sha1_RESERVED(0x0202),
          obsolete_RESERVED(0x0204..0x0400),
          dsa_sha256_RESERVED(0x0402),
          obsolete_RESERVED(0x0404..0x0500),
          dsa_sha384_RESERVED(0x0502),
          obsolete_RESERVED(0x0504..0x0600),
          dsa_sha512_RESERVED(0x0602),
          obsolete_RESERVED(0x0604..0x06FF),
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          SignatureScheme supported_signature_algorithms&lt;2..2^16-2&gt;;
      } SignatureSchemeList;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.1.4. Supported Groups Extension
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.1.4。 サポートされるグループ拡張
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          unallocated_RESERVED(0x0000),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* Elliptic Curve Groups (ECDHE) */
          obsolete_RESERVED(0x0001..0x0016),
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          obsolete_RESERVED(0x001A..0x001C),
          x25519(0x001D), x448(0x001E),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          obsolete_RESERVED(0xFF01..0xFF02),
          (0xFFFF)
      } NamedGroup;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          NamedGroup named_group_list&lt;2..2^16-1&gt;;
      } NamedGroupList;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Values within &#34;obsolete_RESERVED&#34; ranges are used in previous versions of TLS and MUST NOT be offered or negotiated by TLS 1.3 implementations. The obsolete curves have various known/theoretical weaknesses or have had very little usage, in some cases only due to unintentional server configuration issues. They are no longer considered appropriate for general use and should be assumed to be potentially unsafe. The set of curves specified here is sufficient for interoperability with all currently deployed and properly configured TLS implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「obsolete_RESERVED」範囲内の値は、TLSの以前のバージョンで使用され、TLS 1.3実装によって提供またはネゴシエートされてはなりません。 廃止された曲線には、さまざまな既知の/理論的な弱点があるか、意図しないサーバー構成の問題が原因で使用されることがほとんどありません。 それらはもはや一般的な使用に適しているとは考えられておらず、潜在的に安全でないと想定されるべきです。 ここで指定された一連の曲線は、現在展開され、適切に構成されたすべてのTLS実装との相互運用性に十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.2. Server Parameters Messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.2。 サーバーパラメータメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque DistinguishedName&lt;1..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
opaque DistinguishedName &lt;1..2 ^ 16-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          DistinguishedName authorities&lt;3..2^16-1&gt;;
      } CertificateAuthoritiesExtension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque certificate_extension_oid&lt;1..2^8-1&gt;;
          opaque certificate_extension_values&lt;0..2^16-1&gt;;
      } OIDFilter;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          OIDFilter filters&lt;0..2^16-1&gt;;
      } OIDFilterExtension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {} PostHandshakeAuth;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {} PostHandshakeAuth;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          Extension extensions&lt;0..2^16-1&gt;;
      } EncryptedExtensions;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          Extension extensions&lt;2..2^16-1&gt;;
      } CertificateRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.3. Authentication Messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.3。 認証メッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          X509(0),
          OpenPGP_RESERVED(1),
          RawPublicKey(2),
          (255)
      } CertificateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo&lt;1..2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              case X509:
                opaque cert_data&lt;1..2^24-1&gt;;
          };
          Extension extensions&lt;0..2^16-1&gt;;
      } CertificateEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          CertificateEntry certificate_list&lt;0..2^24-1&gt;;
      } Certificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          SignatureScheme algorithm;
          opaque signature&lt;0..2^16-1&gt;;
      } CertificateVerify;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque verify_data[Hash.length];
      } Finished;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.4. Ticket Establishment
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.4。 チケット設立
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce&lt;0..255&gt;;
          opaque ticket&lt;1..2^16-1&gt;;
          Extension extensions&lt;0..2^16-2&gt;;
      } NewSessionTicket;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.5. Updating Keys
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3.5。 キーの更新
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {} EndOfEarlyData;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
struct {} EndOfEarlyData;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum { update_not_requested(0), update_requested(1), (255) } KeyUpdateRequest;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
enum {update_not_requested（0）、update_requested（1）、（255）} KeyUpdateRequest;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.4. Cipher Suites
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.4。 暗号スイート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A symmetric cipher suite defines the pair of the AEAD algorithm and hash algorithm to be used with HKDF. Cipher suite names follow the naming convention:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
対称暗号スイートは、HKDFで使用されるAEADアルゴリズムとハッシュアルゴリズムのペアを定義します。 暗号スイート名は命名規則に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CipherSuite TLS_AEAD_HASH = VALUE;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CipherSuite TLS_AEAD_HASH = VALUE;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-----------+------------------------------------------------+
      | Component | Contents                                       |
      +-----------+------------------------------------------------+
      | TLS       | The string &#34;TLS&#34;                               |
      |           |                                                |
      | AEAD      | The AEAD algorithm used for record protection  |
      |           |                                                |
      | HASH      | The hash algorithm used with HKDF              |
      |           |                                                |
      | VALUE     | The two-byte ID assigned for this cipher suite |
      +-----------+------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This specification defines the following cipher suites for use with TLS 1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様では、TLS 1.3で使用する次の暗号スイートを定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +------------------------------+-------------+
              | Description                  | Value       |
              +------------------------------+-------------+
              | TLS_AES_128_GCM_SHA256       | {0x13,0x01} |
              |                              |             |
              | TLS_AES_256_GCM_SHA384       | {0x13,0x02} |
              |                              |             |
              | TLS_CHACHA20_POLY1305_SHA256 | {0x13,0x03} |
              |                              |             |
              | TLS_AES_128_CCM_SHA256       | {0x13,0x04} |
              |                              |             |
              | TLS_AES_128_CCM_8_SHA256     | {0x13,0x05} |
              +------------------------------+-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The corresponding AEAD algorithms AEAD_AES_128_GCM, AEAD_AES_256_GCM, and AEAD_AES_128_CCM are defined in [RFC5116]. AEAD_CHACHA20_POLY1305 is defined in [RFC8439]. AEAD_AES_128_CCM_8 is defined in [RFC6655]. The corresponding hash algorithms are defined in [SHS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
対応するAEADアルゴリズムAEAD_AES_128_GCM、AEAD_AES_256_GCM、およびAEAD_AES_128_CCMは、[RFC5116]で定義されています。 AEAD_CHACHA20_POLY1305は[RFC8439]で定義されています。 AEAD_AES_128_CCM_8は[RFC6655]で定義されています。 対応するハッシュアルゴリズムは[SHS]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although TLS 1.3 uses the same cipher suite space as previous versions of TLS, TLS 1.3 cipher suites are defined differently, only specifying the symmetric ciphers, and cannot be used for TLS 1.2. Similarly, cipher suites for TLS 1.2 and lower cannot be used with TLS 1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3は以前のバージョンのTLSと同じ暗号スイートスペースを使用しますが、TLS 1.3暗号スイートの定義は異なり、対称暗号のみを指定し、TLS 1.2には使用できません。 同様に、TLS 1.2以前の暗号スイートはTLS 1.3では使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
New cipher suite values are assigned by IANA as described in Section 11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション11で説明されているように、新しい暗号スイート値はIANAによって割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix C. Implementation Notes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録C.実装上の注意
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS protocol cannot prevent many common security mistakes. This appendix provides several recommendations to assist implementors. [TLS13-TRACES] provides test vectors for TLS 1.3 handshakes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSプロトコルは、多くの一般的なセキュリティの間違いを防ぐことはできません。 この付録では、実装者を支援するためのいくつかの推奨事項を示します。 [TLS13-TRACES]は、TLS 1.3ハンドシェイクのテストベクトルを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.1. Random Number Generation and Seeding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.1。 乱数の生成とシード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS requires a cryptographically secure pseudorandom number generator (CSPRNG). In most cases, the operating system provides an appropriate facility such as /dev/urandom, which should be used absent other (e.g., performance) concerns. It is RECOMMENDED to use an existing CSPRNG implementation in preference to crafting a new one. Many adequate cryptographic libraries are already available under favorable license terms. Should those prove unsatisfactory, [RFC4086] provides guidance on the generation of random values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSには、暗号で保護された疑似乱数ジェネレーター（CSPRNG）が必要です。 ほとんどの場合、オペレーティングシステムは/ dev / urandomなどの適切な機能を提供します。これは、他の（パフォーマンスなど）懸念事項がない場合に使用する必要があります。 新しい実装を作成するよりも、既存のCSPRNG実装を使用することをお勧めします。 多くの適切な暗号化ライブラリは、有利なライセンス条件の下ですでに利用可能です。 それらが不十分であると判明した場合、[RFC4086]はランダム値の生成に関するガイダンスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS uses random values (1) in public protocol fields such as the public Random values in the ClientHello and ServerHello and (2) to generate keying material. With a properly functioning CSPRNG, this does not present a security problem, as it is not feasible to determine the CSPRNG state from its output. However, with a broken CSPRNG, it may be possible for an attacker to use the public output to determine the CSPRNG internal state and thereby predict the keying material, as documented in [CHECKOWAY]. Implementations can provide extra security against this form of attack by using separate CSPRNGs to generate public and private values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、（1）ClientHelloおよびServerHelloのパブリックランダム値などのパブリックプロトコルフィールドでランダム値を使用し、（2）キー情報を生成します。 CSPRNGが適切に機能していれば、出力からCSPRNGの状態を判断することは不可能であるため、セキュリティの問題は発生しません。 ただし、CSPRNGが破損している場合、[CHECKOWAY]で文書化されているように、攻撃者がパブリック出力を使用してCSPRNGの内部状態を判断し、それによってキー情報を予測できる可能性があります。 実装では、個別のCSPRNGを使用してパブリック値とプライベート値を生成することにより、この形式の攻撃に対する追加のセキュリティを提供できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.2. Certificates and Authentication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.2。 証明書と認証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Absent a specific indication from an application profile, certificates should always be verified to ensure proper signing by a trusted certificate authority (CA). The selection and addition of trust anchors should be done very carefully. Users should be able to view information about the certificate and trust anchor. Applications SHOULD also enforce minimum and maximum key sizes. For example, certification paths containing keys or signatures weaker than 2048-bit RSA or 224-bit ECDSA are not appropriate for secure applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は証明書の整合性を検証する責任があり、一般に証明書失効メッセージをサポートする必要があります。 アプリケーションプロファイルから特定の指示がない場合、証明書は常に検証され、信頼できる認証局（CA）による適切な署名が保証されます。 トラストアンカーの選択と追加は、非常に慎重に行う必要があります。 ユーザーは、証明書とトラストアンカーに関する情報を表示できる必要があります。 アプリケーションは、キーの最小サイズと最大サイズも強制する必要があります。 たとえば、2048ビットRSAまたは224ビットECDSAよりも弱いキーまたは署名を含む証明書パスは、安全なアプリケーションには適していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.3. Implementation Pitfalls
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.3。 実装の落とし穴
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementation experience has shown that certain parts of earlier TLS specifications are not easy to understand and have been a source of interoperability and security problems. Many of these areas have been clarified in this document, but this appendix contains a short list of the most important things that require special attention from implementors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装の経験から、以前のTLS仕様の特定の部分は理解が容易ではなく、相互運用性とセキュリティの問題の原因であることが示されています。 これらの領域の多くはこのドキュメントで明確にされていますが、この付録には、実装者からの特別な注意が必要な最も重要なものの短いリストが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS protocol issues:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSプロトコルの問題：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Do you correctly handle handshake messages that are fragmented to multiple TLS records (see Section 5.1)? Do you correctly handle corner cases like a ClientHello that is split into several small fragments? Do you fragment handshake messages that exceed the maximum fragment size? In particular, the Certificate and CertificateRequest handshake messages can be large enough to require fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-複数のTLSレコードに断片化されたハンドシェイクメッセージを正しく処理していますか（セクション5.1を参照）。 いくつかの小さなフラグメントに分割されるClientHelloのようなコーナーケースを正しく処理しますか？ 最大フラグメントサイズを超えるハンドシェイクメッセージをフラグメント化しますか？ 特に、CertificateおよびCertificateRequestハンドシェイクメッセージは、断片化を必要とするほど大きくなる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Do you ignore the TLS record layer version number in all unencrypted TLS records (see Appendix D)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-暗号化されていないすべてのTLSレコードのTLSレコードレイヤーバージョン番号を無視しますか（付録Dを参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Have you ensured that all support for SSL, RC4, EXPORT ciphers, and MD5 (via the &#34;signature_algorithms&#34; extension) is completely removed from all possible configurations that support TLS 1.3 or later, and that attempts to use these obsolete capabilities fail correctly (see Appendix D)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-SSL、RC4、EXPORT暗号、およびMD5（「signature_algorithms」拡張機能を介した）のすべてのサポートが、TLS 1.3以降をサポートするすべての可能な構成から完全に削除され、これらの廃止された機能を使用しようとしても失敗することを確認しましたか（ 付録Dを参照）？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Do you handle TLS extensions in ClientHellos correctly, including unknown extensions?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-ClientHellosで、未知の拡張子を含むTLS拡張を正しく処理しますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- When the server has requested a client certificate but no suitable certificate is available, do you correctly send an empty Certificate message, instead of omitting the whole message (see Section 4.4.2)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サーバーがクライアント証明書を要求したが、適切な証明書が利用できない場合、メッセージ全体を省略するのではなく、空の証明書メッセージを正しく送信しますか（セクション4.4.2を参照）？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- When processing the plaintext fragment produced by AEAD-Decrypt and scanning from the end for the ContentType, do you avoid scanning past the start of the cleartext in the event that the peer has sent a malformed plaintext of all zeros?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-AEAD-Decryptによって生成されたプレーンテキストフラグメントを処理し、ContentTypeの末尾からスキャンするとき、ピアがすべてゼロの不正なプレーンテキストを送信した場合にクリアテキストの先頭を過ぎてスキャンすることを避けますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Do you properly ignore unrecognized cipher suites (Section 4.1.2), hello extensions (Section 4.2), named groups (Section 4.2.7), key shares (Section 4.2.8), supported versions (Section 4.2.1), and signature algorithms (Section 4.2.3) in the ClientHello?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-認識されない暗号スイート（セクション4.1.2）、hello拡張（セクション4.2）、名前付きグループ（セクション4.2.7）、キー共有（セクション4.2.8）、サポートされているバージョン（セクション4.2.1）、および ClientHelloの署名アルゴリズム（セクション4.2.3）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- As a server, do you send a HelloRetryRequest to clients which support a compatible (EC)DHE group but do not predict it in the &#34;key_share&#34; extension? As a client, do you correctly handle a HelloRetryRequest from the server?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サーバーとして、互換性のある（EC）DHEグループをサポートするが「key_share」拡張で予測しないクライアントにHelloRetryRequestを送信しますか？ クライアントとして、サーバーからのHelloRetryRequestを正しく処理しますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cryptographic details:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
暗号の詳細：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- What countermeasures do you use to prevent timing attacks [TIMING]?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-タイミング攻撃を防ぐためにどのような対策を講じていますか[タイミング]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- When using Diffie-Hellman key exchange, do you correctly preserve leading zero bytes in the negotiated key (see Section 7.4.1)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-Diffie-Hellmanキー交換を使用する場合、ネゴシエートされたキーの先行ゼロバイトを正しく保存しますか（セクション7.4.1を参照）？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Does your TLS client check that the Diffie-Hellman parameters sent by the server are acceptable (see Section 4.2.8.1)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLSクライアントは、サーバーから送信されたDiffie-Hellmanパラメーターが受け入れ可能であることを確認していますか（セクション4.2.8.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Do you use a strong and, most importantly, properly seeded random number generator (see Appendix C.1) when generating Diffie-Hellman private values, the ECDSA &#34;k&#34; parameter, and other security-critical values? It is RECOMMENDED that implementations implement &#34;deterministic ECDSA&#34; as specified in [RFC6979].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-Diffie-Hellmanプライベート値、ECDSA「k」パラメータ、およびその他のセキュリティクリティカルな値を生成するときに、強力で、最も重要な適切にシードされた乱数ジェネレーター（付録C.1を参照）を使用しますか？ [RFC6979]で指定されているように、実装が「決定論的ECDSA」を実装することが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Do you zero-pad Diffie-Hellman public key values and shared secrets to the group size (see Section 4.2.8.1 and Section 7.4.1)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-Diffie-Hellman公開キー値と共有シークレットをグループサイズにゼロパッドしますか（セクション4.2.8.1およびセクション7.4.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Do you verify signatures after making them, to protect against RSA-CRT key leaks [FW15]?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-RSA-CRTキーリーク[FW15]から保護するために、署名後に署名を検証しますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.4. Client Tracking Prevention
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.4。 クライアント追跡防止
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients SHOULD NOT reuse a ticket for multiple connections. Reuse of a ticket allows passive observers to correlate different connections. Servers that issue tickets SHOULD offer at least as many tickets as the number of connections that a client might use; for example, a web browser using HTTP/1.1 [RFC7230] might open six connections to a server. Servers SHOULD issue new tickets with every connection. This ensures that clients are always able to use a new ticket when creating a new connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、複数の接続にチケットを再利用するべきではありません。 チケットを再利用すると、パッシブオブザーバーは異なる接続を相互に関連付けることができます。 チケットを発行するサーバーは、クライアントが使用する可能性がある接続の数と少なくとも同じ数のチケットを提供する必要があります。 たとえば、HTTP / 1.1 [RFC7230]を使用するWebブラウザは、サーバーへの6つの接続を開く場合があります。 サーバーは、すべての接続で新しいチケットを発行する必要があります。 これにより、クライアントは新しい接続を作成するときに常に新しいチケットを使用できるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.5. Unauthenticated Operation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.5。 認証されていない操作
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Previous versions of TLS offered explicitly unauthenticated cipher suites based on anonymous Diffie-Hellman. These modes have been deprecated in TLS 1.3. However, it is still possible to negotiate parameters that do not provide verifiable server authentication by several methods, including:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの以前のバージョンは、匿名のDiffie-Hellmanに基づいて明示的に認証されていない暗号スイートを提供していました。 これらのモードはTLS 1.3で非推奨になりました。 ただし、次のようないくつかの方法で、検証可能なサーバー認証を提供しないパラメーターをネゴシエートすることは依然として可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Raw public keys [RFC7250].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-生の公開鍵[RFC7250]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Using a public key contained in a certificate but without validation of the certificate chain or any of its contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-証明書に含まれる公開鍵を使用しますが、証明書チェーンまたはその内容の検証は行いません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Either technique used alone is vulnerable to man-in-the-middle attacks and therefore unsafe for general use. However, it is also possible to bind such connections to an external authentication mechanism via out-of-band validation of the server&#39;s public key, trust on first use, or a mechanism such as channel bindings (though the channel bindings described in [RFC5929] are not defined for TLS 1.3). If no such mechanism is used, then the connection has no protection against active man-in-the-middle attack; applications MUST NOT use TLS in such a way absent explicit configuration or a specific application profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単独で使用されるいずれの手法も、中間者攻撃に対して脆弱であるため、一般的な使用には安全ではありません。 ただし、サーバーの公開キーの帯域外検証、最初の使用時の信頼、またはチャネルバインディングなどのメカニズムを介して、そのような接続を外部認証メカニズムにバインドすることもできます（ただし、[RFC5929] TLS 1.3には定義されていません。 そのようなメカニズムが使用されていない場合、接続はアクティブな中間者攻撃から保護されません。 アプリケーションは、明示的な構成や特定のアプリケーションプロファイルがない場合に、TLSを使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix D. Backward Compatibility
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録D.下位互換性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS protocol provides a built-in mechanism for version negotiation between endpoints potentially supporting different versions of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSプロトコルは、異なるバージョンのTLSを潜在的にサポートするエンドポイント間のバージョンネゴシエーションのための組み込みメカニズムを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.x and SSL 3.0 use compatible ClientHello messages. Servers can also handle clients trying to use future versions of TLS as long as the ClientHello format remains compatible and there is at least one protocol version supported by both the client and the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.xおよびSSL 3.0は、互換性のあるClientHelloメッセージを使用します。 サーバーは、ClientHello形式の互換性が維持され、クライアントとサーバーの両方で少なくとも1つのプロトコルバージョンがサポートされている限り、TLSの将来のバージョンを使用しようとするクライアントも処理できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Prior versions of TLS used the record layer version number (TLSPlaintext.legacy_record_version and TLSCiphertext.legacy_record_version) for various purposes. As of TLS 1.3, this field is deprecated. The value of TLSPlaintext.legacy_record_version MUST be ignored by all implementations. The value of TLSCiphertext.legacy_record_version is included in the additional data for deprotection but MAY otherwise be ignored or MAY be validated to match the fixed constant value. Version negotiation is performed using only the handshake versions (ClientHello.legacy_version and ServerHello.legacy_version, as well as the ClientHello, HelloRetryRequest, and ServerHello &#34;supported_versions&#34; extensions). In order to maximize interoperability with older endpoints, implementations that negotiate the use of TLS 1.0-1.2 SHOULD set the record layer version number to the negotiated version for the ServerHello and all records thereafter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの以前のバージョンでは、さまざまな目的でレコードレイヤーバージョン番号（TLSPlaintext.legacy_record_versionおよびTLSCiphertext.legacy_record_version）が使用されていました。 TLS 1.3以降、このフィールドは廃止されました。 TLSPlaintext.legacy_record_versionの値は、すべての実装で無視されなければなりません。 TLSCiphertext.legacy_record_versionの値は、保護解除のための追加データに含まれますが、それ以外の場合は無視されるか、固定定数値と一致するように検証される場合があります。 バージョンネゴシエーションは、ハンドシェイクバージョン（ClientHello.legacy_versionおよびServerHello.legacy_version、およびClientHello、HelloRetryRequest、およびServerHelloの「supported_versions」拡張機能）のみを使用して実行されます。 古いエンドポイントとの相互運用性を最大化するために、TLS 1.0-1.2の使用をネゴシエートする実装は、ServerHelloおよびその後のすべてのレコードのネゴシエートされたバージョンにレコード層バージョン番号を設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For maximum compatibility with previously non-standard behavior and misconfigured deployments, all implementations SHOULD support validation of certification paths based on the expectations in this document, even when handling prior TLS versions&#39; handshakes (see Section 4.4.2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以前の非標準の動作と誤って構成された展開との最大の互換性のために、以前のTLSバージョンのハンドシェイクを処理する場合でも、すべての実装は、このドキュメントの期待に基づいて証明書パスの検証をサポートする必要があります（セクション4.4.2.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.2 and prior supported an &#34;Extended Master Secret&#34; [RFC7627] extension which digested large parts of the handshake transcript into the master secret. Because TLS 1.3 always hashes in the transcript up to the server Finished, implementations which support both TLS 1.3 and earlier versions SHOULD indicate the use of the Extended Master Secret extension in their APIs whenever TLS 1.3 is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.2以前では、ハンドシェイクのトランスクリプトの大部分をマスターシークレットにダイジェストする「Extended Master Secret」[RFC7627]エクステンションがサポートされていました。 TLS 1.3は常に終了するサーバーまでトランスクリプトでハッシュするため、TLS 1.3とそれ以前のバージョンの両方をサポートする実装は、TLS 1.3が使用されるたびにAPIで拡張マスターシークレット拡張を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.1. Negotiating with an Older Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.1。 古いサーバーとの交渉
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A TLS 1.3 client who wishes to negotiate with servers that do not support TLS 1.3 will send a normal TLS 1.3 ClientHello containing 0x0303 (TLS 1.2) in ClientHello.legacy_version but with the correct version(s) in the &#34;supported_versions&#34; extension. If the server does not support TLS 1.3, it will respond with a ServerHello containing an older version number. If the client agrees to use this version, the negotiation will proceed as appropriate for the negotiated protocol. A client using a ticket for resumption SHOULD initiate the connection using the version that was previously negotiated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3をサポートしないサーバーとネゴシエートしたいTLS 1.3クライアントは、ClientHello.legacy_versionに0x0303（TLS 1.2）を含むが、「supported_versions」拡張子に正しいバージョンを含む通常のTLS 1.3 ClientHelloを送信します。 サーバーがTLS 1.3をサポートしていない場合、古いバージョン番号を含むServerHelloで応答します。 クライアントがこのバージョンの使用に同意した場合、ネゴシエートされたプロトコルに応じてネゴシエーションが適切に進行します。 再開にチケットを使用するクライアントは、以前にネゴシエートされたバージョンを使用して接続を開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that 0-RTT data is not compatible with older servers and SHOULD NOT be sent absent knowledge that the server supports TLS 1.3. See Appendix D.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0-RTTデータは古いサーバーと互換性がないため、サーバーがTLS 1.3をサポートしているという知識がない場合は送信しないでください。 付録D.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the version chosen by the server is not supported by the client (or is not acceptable), the client MUST abort the handshake with a &#34;protocol_version&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバーが選択したバージョンがクライアントでサポートされていない（または受け入れられない）場合、クライアントは「protocol_version」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some legacy server implementations are known to not implement the TLS specification properly and might abort connections upon encountering TLS extensions or versions which they are not aware of. Interoperability with buggy servers is a complex topic beyond the scope of this document. Multiple connection attempts may be required in order to negotiate a backward-compatible connection; however, this practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レガシーサーバーの実装によっては、TLS仕様を適切に実装しないことが知られており、TLS拡張機能や認識していないバージョンが検出されると接続を中断する場合があります。 バギーサーバーとの相互運用性は、このドキュメントの範囲を超える複雑なトピックです。 下位互換性のある接続をネゴシエートするには、複数の接続試行が必要になる場合があります。 ただし、この方法はダウングレード攻撃に対して脆弱であり、推奨されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.2. Negotiating with an Older Client
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.2。 古いクライアントとの交渉
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A TLS server can also receive a ClientHello indicating a version number smaller than its highest supported version. If the &#34;supported_versions&#34; extension is present, the server MUST negotiate using that extension as described in Section 4.2.1. If the &#34;supported_versions&#34; extension is not present, the server MUST negotiate the minimum of ClientHello.legacy_version and TLS 1.2. For example, if the server supports TLS 1.0, 1.1, and 1.2, and legacy_version is TLS 1.0, the server will proceed with a TLS 1.0 ServerHello. If the &#34;supported_versions&#34; extension is absent and the server only supports versions greater than ClientHello.legacy_version, the server MUST abort the handshake with a &#34;protocol_version&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSサーバーは、サポートされている最高バージョンよりも小さいバージョン番号を示すClientHelloも受信できます。 「supported_versions」拡張が存在する場合、サーバーはセクション4.2.1で説明されているようにその拡張を使用してネゴシエートしなければなりません。 「supported_versions」拡張機能が存在しない場合、サーバーはClientHello.legacy_versionおよびTLS 1.2の最小値をネゴシエートしなければなりません。 たとえば、サーバーがTLS 1.0、1.1、および1.2をサポートし、legacy_versionがTLS 1.0である場合、サーバーはTLS 1.0 ServerHelloを続行します。 「supported_versions」拡張機能がなく、サーバーがClientHello.legacy_versionよりも大きいバージョンのみをサポートする場合、サーバーは「protocol_version」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that earlier versions of TLS did not clearly specify the record layer version number value in all cases (TLSPlaintext.legacy_record_version). Servers will receive various TLS 1.x versions in this field, but its value MUST always be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの以前のバージョンでは、すべてのケースでレコード層のバージョン番号の値が明確に指定されていなかったことに注意してください（TLSPlaintext.legacy_record_version）。 サーバーはこのフィールドでさまざまなTLS 1.xバージョンを受け取りますが、その値は常に無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.3. 0-RTT Backward Compatibility
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.3。 0-RTT下位互換性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
0-RTT data is not compatible with older servers. An older server will respond to the ClientHello with an older ServerHello, but it will not correctly skip the 0-RTT data and will fail to complete the handshake. This can cause issues when a client attempts to use 0-RTT, particularly against multi-server deployments. For example, a deployment could deploy TLS 1.3 gradually with some servers implementing TLS 1.3 and some implementing TLS 1.2, or a TLS 1.3 deployment could be downgraded to TLS 1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0-RTTデータは古いサーバーと互換性がありません。 古いサーバーは古いServerHelloでClientHelloに応答しますが、0-RTTデータを正しくスキップせず、ハンドシェイクを完了できません。 これは、クライアントが0-RTTを使用しようとしたときに、特にマルチサーバー展開に対して問題を引き起こす可能性があります。 たとえば、一部のサーバーでTLS 1.3を実装し、一部のサーバーでTLS 1.2を実装して、展開でTLS 1.3を徐々に展開したり、TLS 1.3展開をTLS 1.2にダウングレードしたりできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client that attempts to send 0-RTT data MUST fail a connection if it receives a ServerHello with TLS 1.2 or older. It can then retry the connection with 0-RTT disabled. To avoid a downgrade attack, the client SHOULD NOT disable TLS 1.3, only 0-RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
0-RTTデータを送信しようとするクライアントは、TLS 1.2以前のServerHelloを受信した場合、接続に失敗する必要があります。 その後、0-RTTを無効にして接続を再試行できます。 ダウングレード攻撃を避けるために、クライアントはTLS 1.3を無効にするべきではなく、0-RTTのみを無効にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To avoid this error condition, multi-server deployments SHOULD ensure a uniform and stable deployment of TLS 1.3 without 0-RTT prior to enabling 0-RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このエラー状態を回避するために、マルチサーバー展開では、0-RTTを有効にする前に、0-RTTを使用せずにTLS 1.3を均一かつ安定して展開する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.4. Middlebox Compatibility Mode
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.4。 ミドルボックス互換モード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Field measurements [Ben17a] [Ben17b] [Res17a] [Res17b] have found that a significant number of middleboxes misbehave when a TLS client/server pair negotiates TLS 1.3. Implementations can increase the chance of making connections through those middleboxes by making the TLS 1.3 handshake look more like a TLS 1.2 handshake:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィールド測定[Ben17a] [Ben17b] [Res17a] [Res17b]は、TLSクライアント/サーバーペアがTLS 1.3をネゴシエートするとき、かなりの数のミドルボックスが誤動作することを発見しました。 実装では、TLS 1.3ハンドシェイクをTLS 1.2ハンドシェイクのように見せることにより、これらのミドルボックスを介して接続を確立する機会を増やすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The client always provides a non-empty session ID in the ClientHello, as described in the legacy_session_id section of Section 4.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-セクション4.1.2のlegacy_session_idセクションで説明されているように、クライアントは常にClientHelloで空でないセッションIDを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If not offering early data, the client sends a dummy change_cipher_spec record (see the third paragraph of Section 5) immediately before its second flight. This may either be before its second ClientHello or before its encrypted handshake flight. If offering early data, the record is placed immediately after the first ClientHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-初期データを提供しない場合、クライアントは2回目のフライトの直前にダミーのchange_cipher_specレコード（セクション5の3番目の段落を参照）を送信します。 これは、2番目のClientHelloの前、または暗号化されたハンドシェイクフライトの前のいずれかです。 初期データを提供する場合、レコードは最初のClientHelloの直後に配置されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The server sends a dummy change_cipher_spec record immediately after its first handshake message. This may either be after a ServerHello or a HelloRetryRequest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-サーバーは、最初のハンドシェイクメッセージの直後にダミーのchange_cipher_specレコードを送信します。 これは、ServerHelloまたはHelloRetryRequestの後になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When put together, these changes make the TLS 1.3 handshake resemble TLS 1.2 session resumption, which improves the chance of successfully connecting through middleboxes. This &#34;compatibility mode&#34; is partially negotiated: the client can opt to provide a session ID or not, and the server has to echo it. Either side can send change_cipher_spec at any time during the handshake, as they must be ignored by the peer, but if the client sends a non-empty session ID, the server MUST send the change_cipher_spec as described in this appendix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの変更により、TLS 1.3ハンドシェイクがTLS 1.2セッションの再開に似たものになり、ミドルボックスを介して正常に接続できる可能性が向上します。 この「互換モード」は部分的にネゴシエートされます。クライアントはセッションIDを提供するかどうかを選択でき、サーバーはそれをエコーする必要があります。 ピアは無視する必要があるため、どちらの側もハンドシェイク中にchange_cipher_specをいつでも送信できますが、クライアントが空でないセッションIDを送信する場合、サーバーはこの付録で説明するようにchange_cipher_specを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.5. Security Restrictions Related to Backward Compatibility
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D.5。 下位互換性に関連するセキュリティ制限
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations negotiating the use of older versions of TLS SHOULD prefer forward secret and AEAD cipher suites, when available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの古いバージョンの使用をネゴシエートする実装は、利用可能な場合、フォワードシークレットおよびAEAD暗号スイートを優先する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The security of RC4 cipher suites is considered insufficient for the reasons cited in [RFC7465]. Implementations MUST NOT offer or negotiate RC4 cipher suites for any version of TLS for any reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RC4暗号スイートのセキュリティは、[RFC7465]に引用されている理由により不十分であると考えられています。 実装は、何らかの理由でTLSの任意のバージョンのRC4暗号スイートを提供またはネゴシエートしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Old versions of TLS permitted the use of very low strength ciphers. Ciphers with a strength less than 112 bits MUST NOT be offered or negotiated for any version of TLS for any reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの古いバージョンでは、非常に低い強度の暗号を使用できました。 112ビット未満の強度の暗号は、何らかの理由でTLSのどのバージョンでも提供またはネゴシエートしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The security of SSL 3.0 [RFC6101] is considered insufficient for the reasons enumerated in [RFC7568], and it MUST NOT be negotiated for any reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSL 3.0 [RFC6101]のセキュリティは、[RFC7568]に列挙された理由により不十分であると見なされ、何らかの理由で交渉してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The security of SSL 2.0 [SSL2] is considered insufficient for the reasons enumerated in [RFC6176], and it MUST NOT be negotiated for any reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSL 2.0 [SSL2]のセキュリティは、[RFC6176]に列挙されている理由により不十分であると考えられ、何らかの理由で交渉してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations MUST NOT send an SSL version 2.0 compatible CLIENT-HELLO. Implementations MUST NOT negotiate TLS 1.3 or later using an SSL version 2.0 compatible CLIENT-HELLO. Implementations are NOT RECOMMENDED to accept an SSL version 2.0 compatible CLIENT-HELLO in order to negotiate older versions of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は、SSLバージョン2.0互換のCLIENT-HELLOを送信してはなりません。 実装は、SSLバージョン2.0互換のCLIENT-HELLOを使用してTLS 1.3以降をネゴシエートしてはなりません。 古いバージョンのTLSをネゴシエートするために、SSLバージョン2.0互換のCLIENT-HELLOを受け入れることは推奨されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations MUST NOT send a ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 or less. Any endpoint receiving a Hello message with ClientHello.legacy_version or ServerHello.legacy_version set to 0x0300 MUST abort the handshake with a &#34;protocol_version&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は、0x0300以下に設定されたClientHello.legacy_versionまたはServerHello.legacy_versionを送信してはなりません。 ClientHello.legacy_versionまたはServerHello.legacy_versionが0x0300に設定されたHelloメッセージを受信するエンドポイントは、「protocol_version」アラートでハンドシェイクを中止する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations MUST NOT send any records with a version less than 0x0300. Implementations SHOULD NOT accept any records with a version less than 0x0300 (but may inadvertently do so if the record version number is ignored completely).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は、0x0300未満のバージョンのレコードを送信してはなりません。 実装は、0x0300未満のバージョンのレコードを受け入れるべきではありません（ただし、レコードのバージョン番号が完全に無視された場合、誤って受け入れる可能性があります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations MUST NOT use the Truncated HMAC extension, defined in Section 7 of [RFC6066], as it is not applicable to AEAD algorithms and has been shown to be insecure in some scenarios.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は[RFC6066]のセクション7で定義されているTruncated HMAC拡張を使用してはなりません。これはAEADアルゴリズムには適用されず、一部のシナリオでは安全でないことが示されているためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix E. Overview of Security Properties
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録E.セキュリティプロパティの概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A complete security analysis of TLS is outside the scope of this document. In this appendix, we provide an informal description of the desired properties as well as references to more detailed work in the research literature which provides more formal definitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSの完全なセキュリティ分析は、このドキュメントの範囲外です。 この付録では、目的のプロパティの非公式の説明と、より正式な定義を提供する研究文献のより詳細な作業への参照を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We cover properties of the handshake separately from those of the record layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェイクのプロパティについては、レコードレイヤーのプロパティとは別に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1. Handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1。 ハンドシェーク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TLS handshake is an Authenticated Key Exchange (AKE) protocol which is intended to provide both one-way authenticated (server-only) and mutually authenticated (client and server) functionality. At the completion of the handshake, each side outputs its view of the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSハンドシェイクは、認証キー交換（AKE）プロトコルであり、一方向認証（サーバーのみ）と相互認証（クライアントとサーバー）の両方の機能を提供することを目的としています。 ハンドシェイクの完了時に、各サイドは次の値のビューを出力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A set of &#34;session keys&#34; (the various secrets derived from the master secret) from which can be derived a set of working keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-一連の作業キーを派生できる「セッションキー」（マスターシークレットから派生したさまざまなシークレット）のセット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A set of cryptographic parameters (algorithms, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-暗号化パラメーターのセット（アルゴリズムなど）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The identities of the communicating parties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-通信相手の身元。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We assume the attacker to be an active network attacker, which means it has complete control over the network used to communicate between the parties [RFC3552]. Even under these conditions, the handshake should provide the properties listed below. Note that these properties are not necessarily independent, but reflect the protocol consumers&#39; needs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
攻撃者はアクティブなネットワーク攻撃者であると想定します。つまり、当事者間の通信に使用されるネットワークを完全に制御できます[RFC3552]。 これらの条件下でも、ハンドシェイクは以下のプロパティを提供する必要があります。 これらのプロパティは必ずしも独立しているわけではありませんが、プロトコルコンシューマのニーズを反映していることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Establishing the same session keys: The handshake needs to output the same set of session keys on both sides of the handshake, provided that it completes successfully on each endpoint (see [CK01], Definition 1, part 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じセッションキーの確立：各エンドポイントで正常に完了する場合、ハンドシェイクはハンドシェイクの両側で同じセッションキーのセットを出力する必要があります（[CK01]、定義1、パート1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Secrecy of the session keys: The shared session keys should be known only to the communicating parties and not to the attacker (see [CK01], Definition 1, part 2). Note that in a unilaterally authenticated connection, the attacker can establish its own session keys with the server, but those session keys are distinct from those established by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セッションキーの機密性：共有セッションキーは、攻撃者ではなく通信側のみに知られる必要があります（[CK01]、定義1、パート2を参照）。 一方的に認証された接続では、攻撃者はサーバーとの独自のセッションキーを確立できますが、これらのセッションキーはクライアントが確立したものとは異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Peer authentication: The client&#39;s view of the peer identity should reflect the server&#39;s identity. If the client is authenticated, the server&#39;s view of the peer identity should match the client&#39;s identity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピア認証：ピアIDのクライアントのビューは、サーバーのIDを反映する必要があります。 クライアントが認証される場合、ピアIDのサーバーのビューはクライアントのIDと一致する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Uniqueness of the session keys: Any two distinct handshakes should produce distinct, unrelated session keys. Individual session keys produced by a handshake should also be distinct and independent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セッションキーの一意性：2つの異なるハンドシェイクは、無関係の無関係なセッションキーを生成する必要があります。 ハンドシェイクによって生成される個々のセッションキーも明確で独立している必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Downgrade protection: The cryptographic parameters should be the same on both sides and should be the same as if the peers had been communicating in the absence of an attack (see [BBFGKZ16], Definitions 8 and 9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ダウングレード保護：暗号化パラメーターは両側で同じであり、攻撃がない場合にピアが通信していた場合と同じである必要があります（[BBFGKZ16]、定義8および9を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Forward secret with respect to long-term keys: If the long-term keying material (in this case the signature keys in certificate-based authentication modes or the external/resumption PSK in PSK with (EC)DHE modes) is compromised after the handshake is complete, this does not compromise the security of the session key (see [DOW92]), as long as the session key itself has been erased. The forward secrecy property is not satisfied when PSK is used in the &#34;psk_ke&#34; PskKeyExchangeMode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
長期キーに関するフォワードシークレット：ハンドシェイク後に長期キー情報（この場合、証明書ベースの認証モードの署名キーまたはPSKの（EC）DHEモードの外部/再開PSK）が危険にさらされた場合 セッションキー自体が消去されている限り、これはセッションキーのセキュリティを侵害しません（[DOW92]を参照）。 PSKが &#34;psk_ke&#34; PskKeyExchangeModeで使用されている場合、forward secrecyプロパティは満たされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Key Compromise Impersonation (KCI) resistance: In a mutually authenticated connection with certificates, compromising the long-term secret of one actor should not break that actor&#39;s authentication of their peer in the given connection (see [HGFS15]). For example, if a client&#39;s signature key is compromised, it should not be possible to impersonate arbitrary servers to that client in subsequent handshakes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
鍵侵害偽装（KCI）耐性：証明書を使用した相互認証接続では、1人のアクターの長期的な秘密を侵害しても、特定の接続におけるピアのそのアクターの認証が破られることはありません（[HGFS15]を参照）。 たとえば、クライアントの署名キーが侵害された場合、後続のハンドシェイクでそのクライアントに任意のサーバーを偽装することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Protection of endpoint identities: The server&#39;s identity (certificate) should be protected against passive attackers. The client&#39;s identity should be protected against both passive and active attackers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エンドポイントIDの保護：サーバーのID（証明書）は、受動的な攻撃者から保護する必要があります。 クライアントのIDは、受動的攻撃者と能動的攻撃者の両方から保護する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Informally, the signature-based modes of TLS 1.3 provide for the establishment of a unique, secret, shared key established by an (EC)DHE key exchange and authenticated by the server&#39;s signature over the handshake transcript, as well as tied to the server&#39;s identity by a MAC. If the client is authenticated by a certificate, it also signs over the handshake transcript and provides a MAC tied to both identities. [SIGMA] describes the design and analysis of this type of key exchange protocol. If fresh (EC)DHE keys are used for each connection, then the output keys are forward secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非公式には、TLS 1.3の署名ベースのモードは、（EC）DHEキー交換によって確立され、ハンドシェイクのトランスクリプト上のサーバーの署名によって認証され、サーバーのIDに関連付けられた一意の秘密共有キーの確立を提供します MACによって。 クライアントが証明書によって認証される場合、クライアントはハンドシェイクのトランスクリプトに署名し、両方のIDに関連付けられたMACを提供します。 [SIGMA]は、このタイプの鍵交換プロトコルの設計と分析について説明しています。 各接続に新しい（EC）DHEキーが使用される場合、出力キーは前方秘密です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The external PSK and resumption PSK bootstrap from a long-term shared secret into a unique per-connection set of short-term session keys. This secret may have been established in a previous handshake. If PSK with (EC)DHE key establishment is used, these session keys will also be forward secret. The resumption PSK has been designed so that the resumption master secret computed by connection N and needed to form connection N+1 is separate from the traffic keys used by connection N, thus providing forward secrecy between the connections. In addition, if multiple tickets are established on the same connection, they are associated with different keys, so compromise of the PSK associated with one ticket does not lead to the compromise of connections established with PSKs associated with other tickets. This property is most interesting if tickets are stored in a database (and so can be deleted) rather than if they are self-encrypted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
外部PSKおよび再開PSKブートストラップ。長期共有秘密から、短期セッションキーの一意の接続ごとのセットになります。 この秘密は、以前のハンドシェイクで確立された可能性があります。 （EC）DHEキー確立を使用するPSKが使用される場合、これらのセッションキーも転送シークレットになります。 再開PSKは、接続Nによって計算され、接続N + 1を形成するために必要な再開マスターシークレットが接続Nによって使用されるトラフィックキーから分離されるように設計されています。 さらに、同じ接続で複数のチケットが確立された場合、それらは異なるキーに関連付けられるため、1つのチケットに関連付けられたPSKの侵害は、他のチケットに関連付けられたPSKで確立された接続の侵害につながりません。 このプロパティは、チケットが自己暗号化されている場合ではなく、データベースに保存されている（したがって削除できる）場合に最も興味深いものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PSK binder value forms a binding between a PSK and the current handshake, as well as between the session where the PSK was established and the current session. This binding transitively includes the original handshake transcript, because that transcript is digested into the values which produce the resumption master secret. This requires that both the KDF used to produce the resumption master secret and the MAC used to compute the binder be collision resistant. See Appendix E.1.1 for more on this. Note: The binder does not cover the binder values from other PSKs, though they are included in the Finished MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PSKバインダ値は、PSKと現在のハンドシェイクの間、およびPSKが確立されたセッションと現在のセッションの間のバインディングを形成します。 このバインディングには、元のハンドシェイクのトランスクリプトが一時的に含まれます。トランスクリプトは、再開マスターシークレットを生成する値にダイジェストされるためです。 これには、再開マスターシークレットを生成するために使用されるKDFと、バインダーを計算するために使用されるMACの両方が耐衝突性であることが必要です。 詳細については、付録E.1.1を参照してください。 注：バインダーは、他のPSKからのバインダー値をカバーしませんが、それらはFinished MACに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS does not currently permit the server to send a certificate_request message in non-certificate-based handshakes (e.g., PSK). If this restriction were to be relaxed in future, the client&#39;s signature would not cover the server&#39;s certificate directly. However, if the PSK was established through a NewSessionTicket, the client&#39;s signature would transitively cover the server&#39;s certificate through the PSK binder. [PSK-FINISHED] describes a concrete attack on constructions that do not bind to the server&#39;s certificate (see also [Kraw16]). It is unsafe to use certificate-based client authentication when the client might potentially share the same PSK/key-id pair with two different endpoints. Implementations MUST NOT combine external PSKs with certificate-based authentication of either the client or the server unless negotiated by some extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは現在、サーバーが非証明書ベースのハンドシェイク（PSKなど）でcertificate_requestメッセージを送信することを許可していません。 この制限が将来緩和される場合、クライアントの署名はサーバーの証明書を直接カバーしません。 ただし、PSKがNewSessionTicketを介して確立された場合、クライアントの署名は、PSKバインダーを介してサーバーの証明書を一時的にカバーします。 [PSK-FINISHED]は、サーバーの証明書にバインドしない構造に対する具体的な攻撃について説明しています（[Kraw16]も参照）。 クライアントが2つの異なるエンドポイントと同じPSK / key-idペアを共有する可能性がある場合、証明書ベースのクライアント認証を使用することは安全ではありません。 実装は、何らかの拡張によってネゴシエートされない限り、クライアントまたはサーバーの証明書ベースの認証と外部PSKを組み合わせてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an exporter is used, then it produces values which are unique and secret (because they are generated from a unique session key). Exporters computed with different labels and contexts are computationally independent, so it is not feasible to compute one from another or the session secret from the exported value. Note: Exporters can produce arbitrary-length values; if exporters are to be used as channel bindings, the exported value MUST be large enough to provide collision resistance. The exporters provided in TLS 1.3 are derived from the same Handshake Contexts as the early traffic keys and the application traffic keys, respectively, and thus have similar security properties. Note that they do not include the client&#39;s certificate; future applications which wish to bind to the client&#39;s certificate may need to define a new exporter that includes the full handshake transcript.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エクスポーターが使用される場合、一意の値が生成されます（一意のセッションキーから生成されるため）。 異なるラベルとコンテキストで計算されたエクスポーターは計算的に独立しているため、エクスポートされた値からセッションシークレットを計算したり、セッションシークレットを計算したりすることはできません。 注：エクスポーターは、任意の長さの値を生成できます。 エクスポーターをチャネルバインディングとして使用する場合、エクスポートされた値は、衝突抵抗を提供するのに十分な大きさでなければなりません。 TLS 1.3で提供されるエクスポーターは、初期トラフィックキーおよびアプリケーショントラフィックキーとそれぞれ同じハンドシェイクコンテキストから派生しているため、同様のセキュリティプロパティを持っています。 クライアントの証明書は含まれないことに注意してください。 クライアントの証明書にバインドしたい将来のアプリケーションは、完全なハンドシェイクトランスクリプトを含む新しいエクスポーターを定義する必要があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For all handshake modes, the Finished MAC (and, where present, the signature) prevents downgrade attacks. In addition, the use of certain bytes in the random nonces as described in Section 4.1.3 allows the detection of downgrade to previous TLS versions. See [BBFGKZ16] for more details on TLS 1.3 and downgrade.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのハンドシェイクモードで、Finished MAC（および存在する場合は署名）がダウングレード攻撃を防ぎます。 さらに、セクション4.1.3で説明されているように、ランダムナンスで特定のバイトを使用すると、以前のTLSバージョンへのダウングレードを検出できます。 TLS 1.3およびダウングレードの詳細については、[BBFGKZ16]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As soon as the client and the server have exchanged enough information to establish shared keys, the remainder of the handshake is encrypted, thus providing protection against passive attackers, even if the computed shared key is not authenticated. Because the server authenticates before the client, the client can ensure that if it authenticates to the server, it only reveals its identity to an authenticated server. Note that implementations must use the provided record-padding mechanism during the handshake to avoid leaking information about the identities due to length. The client&#39;s proposed PSK identities are not encrypted, nor is the one that the server selects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントとサーバーが共有キーを確立するのに十分な情報を交換するとすぐに、ハンドシェイクの残りは暗号化されるため、計算された共有キーが認証されていなくても、受動的な攻撃者から保護されます。 サーバーはクライアントよりも先に認証されるため、クライアントはサーバーに対して認証を行う場合、認証されたサーバーに対してのみその身元を明らかにすることができます。 実装は、長さによるアイデンティティに関する情報の漏洩を防ぐために、ハンドシェイク中に提供されたレコード埋め込みメカニズムを使用する必要があることに注意してください。 クライアントが提案するPSK IDは暗号化されず、サーバーが選択するIDも暗号化されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.1. Key Derivation and HKDF
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.1。 キーの導出とHKDF
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Key derivation in TLS 1.3 uses HKDF as defined in [RFC5869] and its two components, HKDF-Extract and HKDF-Expand. The full rationale for the HKDF construction can be found in [Kraw10] and the rationale for the way it is used in TLS 1.3 in [KW16]. Throughout this document, each application of HKDF-Extract is followed by one or more invocations of HKDF-Expand. This ordering should always be followed (including in future revisions of this document); in particular, one SHOULD NOT use an output of HKDF-Extract as an input to another application of HKDF-Extract without an HKDF-Expand in between. Multiple applications of HKDF-Expand to some of the same inputs are allowed as long as these are differentiated via the key and/or the labels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3のキー派生では、[RFC5869]で定義されているHKDFとその2つのコンポーネント、HKDF-ExtractおよびHKDF-Expandが使用されます。 HKDF構築の完全な理論的根拠は[Kraw10]に、それがTLS 1.3で使用される方法の理論的根拠は[KW16]にあります。 このドキュメント全体を通して、HKDF-Extractの各アプリケーションの後に、HKDF-Expandの1つ以上の呼び出しが続きます。 この順序は常に守られる必要があります（このドキュメントの将来の改訂版を含む）。 特に、HKDF-Extractの出力を、間にHKDF-Expandを使用せずにHKDF-Extractの別のアプリケーションへの入力として使用するべきではありません。 同じ入力のいくつかへのHKDF-Expandの複数のアプリケーションは、キーおよび/またはラベルによって区別されている限り許可されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that HKDF-Expand implements a pseudorandom function (PRF) with both inputs and outputs of variable length. In some of the uses of HKDF in this document (e.g., for generating exporters and the resumption_master_secret), it is necessary that the application of HKDF-Expand be collision resistant; namely, it should be infeasible to find two different inputs to HKDF-Expand that output the same value. This requires the underlying hash function to be collision resistant and the output length from HKDF-Expand to be of size at least 256 bits (or as much as needed for the hash function to prevent finding collisions).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
HKDF-Expandは、可変長の入力と出力の両方で疑似ランダム関数（PRF）を実装することに注意してください。 このドキュメントでのHKDFの使用のいくつかでは（たとえば、エクスポーターとresumption_master_secretを生成するため）、HKDF-Expandのアプリケーションが衝突に強いことが必要です。 つまり、同じ値を出力するHKDF-Expandへの2つの異なる入力を見つけることは不可能です。 これには、基礎となるハッシュ関数が耐衝突性であり、HKDF-Expandからの出力長が少なくとも256ビットのサイズである必要があります（または、ハッシュ関数が衝突の検出を防ぐために必要な長さ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.2. Client Authentication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.2。 クライアント認証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client that has sent authentication data to a server, either during the handshake or in post-handshake authentication, cannot be sure whether the server afterwards considers the client to be authenticated or not. If the client needs to determine if the server considers the connection to be unilaterally or mutually authenticated, this has to be provisioned by the application layer. See [CHHSV17] for details. In addition, the analysis of post-handshake authentication from [Kraw16] shows that the client identified by the certificate sent in the post-handshake phase possesses the traffic key. This party is therefore the client that participated in the original handshake or one to whom the original client delegated the traffic key (assuming that the traffic key has not been compromised).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハンドシェイク中またはハンドシェイク後の認証のいずれかで認証データをサーバーに送信したクライアントは、その後サーバーがクライアントが認証されたとみなすかどうかを確認できません。 サーバーが接続を一方的に認証するか相互認証するかをクライアントが判断する必要がある場合、これはアプリケーション層によってプロビジョニングする必要があります。 詳細については、[CHHSV17]を参照してください。 さらに、[Kraw16]からのポストハンドシェイク認証の分析は、ポストハンドシェイクフェーズで送信された証明書によって識別されるクライアントがトラフィックキーを所有していることを示しています。 したがって、このパーティは、元のハンドシェイクに参加したクライアント、または元のクライアントがトラフィックキーを委任したクライアントです（トラフィックキーが侵害されていない場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.3. 0-RTT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.3。 0-RTT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 0-RTT mode of operation generally provides security properties similar to those of 1-RTT data, with the two exceptions that the 0-RTT encryption keys do not provide full forward secrecy and that the server is not able to guarantee uniqueness of the handshake (non-replayability) without keeping potentially undue amounts of state. See Section 8 for mechanisms to limit the exposure to replay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
通常、0-RTT動作モードは1-RTTデータのセキュリティプロパティと同様のセキュリティプロパティを提供しますが、2つの例外は0-RTT暗号化キーは完全な転送秘密を提供せず、サーバーはハンドシェイクの一意性を保証できないことです。 （再生不能）潜在的に過度の量の状態を維持することなく。 リプレイへの露出を制限するメカニズムについては、セクション8を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.4. Exporter Independence
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.4。 輸出業者の独立
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The exporter_master_secret and early_exporter_master_secret are derived to be independent of the traffic keys and therefore do not represent a threat to the security of traffic encrypted with those keys. However, because these secrets can be used to compute any exporter value, they SHOULD be erased as soon as possible. If the total set of exporter labels is known, then implementations SHOULD pre-compute the inner Derive-Secret stage of the exporter computation for all those labels, then erase the [early_]exporter_master_secret, followed by each inner value as soon as it is known that it will not be needed again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
exporter_master_secretおよびearly_exporter_master_secretは、トラフィックキーに依存しないように導出されているため、これらのキーで暗号化されたトラフィックのセキュリティに対する脅威を表していません。 ただし、これらのシークレットはエクスポーター値の計算に使用できるため、できるだけ早く消去する必要があります。 エクスポーターラベルの合計セットがわかっている場合、実装は、それらすべてのラベルのエクスポーター計算の内部秘密導出ステージを事前計算し、[early_] exporter_master_secretを消去し、その後、各内部値がわかるとすぐに消去する必要があります。 二度と必要ないこと。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.5. Post-Compromise Security
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.5。 侵害後のセキュリティ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS does not provide security for handshakes which take place after the peer&#39;s long-term secret (signature key or external PSK) is compromised. It therefore does not provide post-compromise security [CCG16], sometimes also referred to as backward or future secrecy. This is in contrast to KCI resistance, which describes the security guarantees that a party has after its own long-term secret has been compromised.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、ピアの長期シークレット（署名キーまたは外部PSK）が侵害された後に行われるハンドシェイクのセキュリティを提供しません。 したがって、事後セキュリティ[CCG16]は提供されず、逆方向または将来の秘密とも呼ばれます。 これは、KCIの抵抗とは対照的です。KCIの抵抗は、長期的な秘密が侵害された後のパーティのセキュリティ保証を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.6. External References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.1.6。 外部参照
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The reader should refer to the following references for analysis of the TLS handshake: [DFGS15], [CHSV16], [DFGS16], [KW16], [Kraw16], [FGSW16], [LXZFH16], [FG17], and [BBK17].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
読者は、TLSハンドシェイクの分析について次のリファレンスを参照する必要があります。[DFGS15]、[CHSV16]、[DFGS16]、[KW16]、[Kraw16]、[FGSW16]、[LXZFH16]、[FG17]、および[BBK17] ]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.2. Record Layer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.2。 レコード層
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The record layer depends on the handshake producing strong traffic secrets which can be used to derive bidirectional encryption keys and nonces. Assuming that is true, and the keys are used for no more data than indicated in Section 5.5, then the record layer should provide the following guarantees:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レコード層は、双方向の暗号化キーとナンスを導出するために使用できる強力なトラフィックシークレットを生成するハンドシェイクに依存します。 それが真実であり、キーがセクション5.5に示されている以上のデータに使用されないと仮定すると、レコード層は次の保証を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Confidentiality: An attacker should not be able to determine the plaintext contents of a given record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
機密性：攻撃者は、特定のレコードのプレーンテキストの内容を判別できないようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Integrity: An attacker should not be able to craft a new record which is different from an existing record which will be accepted by the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
整合性：攻撃者は、受信者によって受け入れられる既存のレコードとは異なる新しいレコードを作成することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Order protection/non-replayability: An attacker should not be able to cause the receiver to accept a record which it has already accepted or cause the receiver to accept record N+1 without having first processed record N.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注文保護/非再生可能性：攻撃者は、受信者に既に受け入れたレコードを受け入れさせたり、受信者に最初のレコードNを処理させずにレコードN + 1を受け入れさせたりすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Length concealment: Given a record with a given external length, the attacker should not be able to determine the amount of the record that is content versus padding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
長さの隠蔽：指定された外部の長さのレコードが与えられた場合、攻撃者はコンテンツとパディングのレコードの量を判断できないはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Forward secrecy after key change: If the traffic key update mechanism described in Section 4.6.3 has been used and the previous generation key is deleted, an attacker who compromises the endpoint should not be able to decrypt traffic encrypted with the old key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キー変更後の秘密の転送：セクション4.6.3で説明したトラフィックキー更新メカニズムが使用され、前世代のキーが削除された場合、エンドポイントを侵害する攻撃者は、古いキーで暗号化されたトラフィックを解読できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Informally, TLS 1.3 provides these properties by AEAD-protecting the plaintext with a strong key. AEAD encryption [RFC5116] provides confidentiality and integrity for the data. Non-replayability is provided by using a separate nonce for each record, with the nonce being derived from the record sequence number (Section 5.3), with the sequence number being maintained independently at both sides; thus, records which are delivered out of order result in AEAD deprotection failures. In order to prevent mass cryptanalysis when the same plaintext is repeatedly encrypted by different users under the same key (as is commonly the case for HTTP), the nonce is formed by mixing the sequence number with a secret per-connection initialization vector derived along with the traffic keys. See [BT16] for analysis of this construction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非公式には、TLS 1.3は、強力なキーでプレーンテキストをAEADで保護することにより、これらのプロパティを提供します。 AEAD暗号化[RFC5116]は、データの機密性と整合性を提供します。 非再生可能性は、レコードごとに個別のノンスを使用することによって提供されます。ノンスは、レコードのシーケンス番号から派生し（5.3項）、シーケンス番号は両側で独立して維持されます。 したがって、順不同で配信されたレコードはAEAD保護解除エラーになります。 同じ平文が同じキーの下で異なるユーザーによって繰り返し暗号化される場合の大量暗号解析を防ぐために（HTTPの一般的な場合）、nonceは、シーケンス番号と、 交通キー。 この構造の分析については[BT16]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The rekeying technique in TLS 1.3 (see Section 7.2) follows the construction of the serial generator as discussed in [REKEY], which shows that rekeying can allow keys to be used for a larger number of encryptions than without rekeying. This relies on the security of the HKDF-Expand-Label function as a pseudorandom function (PRF). In addition, as long as this function is truly one way, it is not possible to compute traffic keys from prior to a key change (forward secrecy).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3のキー再生成手法（セクション7.2を参照）は、[REKEY]で説明したシリアルジェネレーターの構造に従います。これは、キー再生成により、キー再生成なしでより多くの暗号化にキーを使用できることを示しています。 これは、HKDF-Expand-Label関数のセキュリティを擬似ランダム関数（PRF）として使用します。 さらに、この機能が本当に1つの方法である限り、キー変更（前方秘匿性）の前からトラフィックキーを計算することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS does not provide security for data which is communicated on a connection after a traffic secret of that connection is compromised. That is, TLS does not provide post-compromise security/future secrecy/backward secrecy with respect to the traffic secret. Indeed, an attacker who learns a traffic secret can compute all future traffic secrets on that connection. Systems which want such guarantees need to do a fresh handshake and establish a new connection with an (EC)DHE exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、接続のトラフィックシークレットが危険にさらされた後に接続で通信されるデータのセキュリティを提供しません。 つまり、TLSは、トラフィックシークレットに関して、事後のセキュリティ/将来の秘密/後方の秘密を提供しません。 実際、トラフィックシークレットを学習する攻撃者は、その接続で将来のすべてのトラフィックシークレットを計算できます。 そのような保証を必要とするシステムは、新しいハンドシェイクを行い、（EC）DHE交換との新しい接続を確立する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.2.1. External References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.2.1。 外部参照
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The reader should refer to the following references for analysis of the TLS record layer: [BMMRT15], [BT16], [BDFKPPRSZZ16], [BBK17], and [PS18].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
読者は、TLSレコード層の分析について次の参照を参照する必要があります：[BMMRT15]、[BT16]、[BDFKPPRSZZ16]、[BBK17]、および[PS18]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.3. Traffic Analysis
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.3。 トラフィック分析
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS is susceptible to a variety of traffic analysis attacks based on observing the length and timing of encrypted packets [CLINIC] [HCJC16]. This is particularly easy when there is a small set of possible messages to be distinguished, such as for a video server hosting a fixed corpus of content, but still provides usable information even in more complicated scenarios.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、暗号化されたパケットの長さとタイミングの観察に基づいたさまざまなトラフィック分析攻撃を受けやすい[CLINIC] [HCJC16]。 これは、コンテンツの固定コーパスをホストするビデオサーバーなど、区別される可能性のあるメッセージの小さなセットがある場合に特に簡単ですが、さらに複雑なシナリオでも有用な情報を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS does not provide any specific defenses against this form of attack but does include a padding mechanism for use by applications: The plaintext protected by the AEAD function consists of content plus variable-length padding, which allows the application to produce arbitrary-length encrypted records as well as padding-only cover traffic to conceal the difference between periods of transmission and periods of silence. Because the padding is encrypted alongside the actual content, an attacker cannot directly determine the length of the padding but may be able to measure it indirectly by the use of timing channels exposed during record processing (i.e., seeing how long it takes to process a record or trickling in records to see which ones elicit a response from the server). In general, it is not known how to remove all of these channels because even a constant-time padding removal function will likely feed the content into data-dependent functions. At minimum, a fully constant-time server or client would require close cooperation with the application-layer protocol implementation, including making that higher-level protocol constant time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLSは、この形式の攻撃に対する特定の防御を提供しませんが、アプリケーションが使用するパディングメカニズムを含みます：AEAD機能で保護されたプレーンテキストは、コンテンツと可変長パディングで構成され、アプリケーションは任意の長さの暗号化されたレコードを作成できますまた、パディングのみでトラフィックをカバーし、送信期間と無音期間の違いを隠します。パディングは実際のコンテンツと一緒に暗号化されるため、攻撃者はパディングの長さを直接決定することはできませんが、レコード処理中に公開されたタイミングチャネルを使用して間接的に測定できる場合があります（つまり、レコードの処理にかかる時間を確認するまたはどのレコードがサーバーからの応答を引き出すかを確認するためにレコードを細流化します）。一般に、これらのすべてのチャネルを削除する方法は不明です。これは、一定時間のパディング削除関数でさえ、コンテンツをデータ依存関数に送り込む可能性が高いためです。少なくとも、完全に一定時間のサーバーまたはクライアントは、その上位レベルのプロトコルを一定時間にするなど、アプリケーション層プロトコルの実装との緊密な協力を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: Robust traffic analysis defenses will likely lead to inferior performance due to delays in transmitting packets and increased traffic volume.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：堅牢なトラフィック分析防御は、パケット送信の遅延とトラフィック量の増加により、パフォーマンスの低下につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.4. Side-Channel Attacks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.4。 サイドチャネル攻撃
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In general, TLS does not have specific defenses against side-channel attacks (i.e., those which attack the communications via secondary channels such as timing), leaving those to the implementation of the relevant cryptographic primitives. However, certain features of TLS are designed to make it easier to write side-channel resistant code:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般に、TLSにはサイドチャネル攻撃（つまり、タイミングなどのセカンダリチャネルを介して通信を攻撃する攻撃）に対する特定の防御策がなく、それらを関連する暗号プリミティブの実装に任せています。 ただし、TLSの特定の機能は、サイドチャネルに耐性のあるコードを簡単に記述できるように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Unlike previous versions of TLS which used a composite MAC-then-encrypt structure, TLS 1.3 only uses AEAD algorithms, allowing implementations to use self-contained constant-time implementations of those primitives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-複合MAC-then-encrypt構造を使用した以前のバージョンのTLSとは異なり、TLS 1.3はAEADアルゴリズムのみを使用し、実装がこれらのプリミティブの自己完結型の一定時間実装を使用できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- TLS uses a uniform &#34;bad_record_mac&#34; alert for all decryption errors, which is intended to prevent an attacker from gaining piecewise insight into portions of the message. Additional resistance is provided by terminating the connection on such errors; a new connection will have different cryptographic material, preventing attacks against the cryptographic primitives that require multiple trials.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-TLSは、すべての復号化エラーに対して均一な「bad_record_mac」アラートを使用します。これは、攻撃者がメッセージの一部を区分的に洞察することを防ぐことを目的としています。 このようなエラーで接続を終了することにより、追加の抵抗が提供されます。 新しい接続には異なる暗号化マテリアルがあり、複数の試行を必要とする暗号化プリミティブに対する攻撃を防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information leakage through side channels can occur at layers above TLS, in application protocols and the applications that use them. Resistance to side-channel attacks depends on applications and application protocols separately ensuring that confidential information is not inadvertently leaked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サイドチャネルを介した情報漏えいは、アプリケーションプロトコルおよびそれらを使用するアプリケーションで、TLSの上の層で発生する可能性があります。 サイドチャネル攻撃に対する耐性は、機密情報が不注意に漏洩しないことを保証するアプリケーションとアプリケーションプロトコルに個別に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.5. Replay Attacks on 0-RTT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.5。 0-RTTに対するリプレイ攻撃
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Replayable 0-RTT data presents a number of security threats to TLS-using applications, unless those applications are specifically engineered to be safe under replay (minimally, this means idempotent, but in many cases may also require other stronger conditions, such as constant-time response). Potential attacks include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
再生可能な0-RTTデータは、TLSを使用するアプリケーションに対して、それらのアプリケーションが再生時に安全になるように特別に設計されていない限り、多くのセキュリティ上の脅威を示します（最低限、これはべき等を意味しますが、多くの場合、他のより強い条件、例えば 時間応答）。 潜在的な攻撃には次のものがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Duplication of actions which cause side effects (e.g., purchasing an item or transferring money) to be duplicated, thus harming the site or the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-副作用（アイテムの購入や送金など）を引き起こすアクションの複製が複製されるため、サイトまたはユーザーに損害を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Attackers can store and replay 0-RTT messages in order to reorder them with respect to other messages (e.g., moving a delete to after a create).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-攻撃者は、0-RTTメッセージを保存および再生して、他のメッセージに対して並べ替えることができます（たとえば、作成後に削除を移動する）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Exploiting cache timing behavior to discover the content of 0-RTT messages by replaying a 0-RTT message to a different cache node and then using a separate connection to measure request latency, to see if the two requests address the same resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
-キャッシュタイミング動作を利用して、0-RTTメッセージを別のキャッシュノードに再生し、別の接続を使用してリクエストレイテンシを測定し、2つのリクエストが同じリソースに対応しているかどうかを確認することにより、0-RTTメッセージの内容を検出します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If data can be replayed a large number of times, additional attacks become possible, such as making repeated measurements of the speed of cryptographic operations. In addition, they may be able to overload rate-limiting systems. For a further description of these attacks, see [Mac17].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データを何度も再生できる場合、暗号化操作の速度を繰り返し測定するなど、追加の攻撃が可能になります。 さらに、レート制限システムに過負荷をかけることができます。 これらの攻撃の詳細については、[Mac17]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ultimately, servers have the responsibility to protect themselves against attacks employing 0-RTT data replication. The mechanisms described in Section 8 are intended to prevent replay at the TLS layer but do not provide complete protection against receiving multiple copies of client data. TLS 1.3 falls back to the 1-RTT handshake when the server does not have any information about the client, e.g., because it is in a different cluster which does not share state or because the ticket has been deleted as described in Section 8.1. If the application-layer protocol retransmits data in this setting, then it is possible for an attacker to induce message duplication by sending the ClientHello to both the original cluster (which processes the data immediately) and another cluster which will fall back to 1-RTT and process the data upon application-layer replay. The scale of this attack is limited by the client&#39;s willingness to retry transactions and therefore only allows a limited amount of duplication, with each copy appearing as a new connection at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最終的に、サーバーは0-RTTデータ複製を使用する攻撃から自身を保護する責任があります。セクション8で説明されているメカニズムは、TLS層での再生を防止することを目的としていますが、クライアントデータの複数のコピーの受信に対する完全な保護を提供するものではありません。 TLS 1.3は、サーバーがクライアントに関する情報を持っていない場合、たとえば、状態を共有しない別のクラスターにあるか、セクション8.1で説明されているようにチケットが削除されたため、1-RTTハンドシェイクにフォールバックします。アプリケーション層プロトコルがこの設定でデータを再送信する場合、攻撃者は、ClientHelloを元のクラスター（データを直ちに処理する）と1-RTTにフォールバックする別のクラスターの両方に送信することにより、メッセージの重複を誘発する可能性がありますアプリケーション層の再生時にデータを処理します。この攻撃の規模は、クライアントがトランザクションを再試行する意思によって制限されるため、複製が制限され、各コピーはサーバーで新しい接続として表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If implemented correctly, the mechanisms described in Sections 8.1 and 8.2 prevent a replayed ClientHello and its associated 0-RTT data from being accepted multiple times by any cluster with consistent state; for servers which limit the use of 0-RTT to one cluster for a single ticket, then a given ClientHello and its associated 0-RTT data will only be accepted once. However, if state is not completely consistent, then an attacker might be able to have multiple copies of the data be accepted during the replication window. Because clients do not know the exact details of server behavior, they MUST NOT send messages in early data which are not safe to have replayed and which they would not be willing to retry across multiple 1-RTT connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
正しく実装されている場合、セクション8.1および8.2で説明されているメカニズムにより、再生されたClientHelloとそれに関連する0-RTTデータが、一貫した状態のクラスターによって複数回受け入れられるのを防ぎます。 1つのチケットに対して0-RTTの使用を1つのクラスターに制限するサーバーの場合、特定のClientHelloとそれに関連付けられた0-RTTデータは1回しか受け入れられません。 ただし、状態が完全に一貫していない場合、攻撃者はレプリケーションウィンドウ中にデータの複数のコピーを受け入れることができる場合があります。 クライアントはサーバーの動作の正確な詳細を知らないため、リプレイするのが安全ではなく、複数の1-RTT接続で再試行したくない初期データのメッセージを送信してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Application protocols MUST NOT use 0-RTT data without a profile that defines its use. That profile needs to identify which messages or interactions are safe to use with 0-RTT and how to handle the situation when the server rejects 0-RTT and falls back to 1-RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーションプロトコルは、その使用を定義するプロファイルなしで0-RTTデータを使用してはなりません。 そのプロファイルでは、0-RTTで安全に使用できるメッセージまたは対話を特定し、サーバーが0-RTTを拒否して1-RTTにフォールバックする状況を処理する方法を識別する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, to avoid accidental misuse, TLS implementations MUST NOT enable 0-RTT (either sending or accepting) unless specifically requested by the application and MUST NOT automatically resend 0-RTT data if it is rejected by the server unless instructed by the application. Server-side applications may wish to implement special processing for 0-RTT data for some kinds of application traffic (e.g., abort the connection, request that data be resent at the application layer, or delay processing until the handshake completes). In order to allow applications to implement this kind of processing, TLS implementations MUST provide a way for the application to determine if the handshake has completed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、偶発的な誤用を避けるために、TLS実装は、アプリケーションによって特に要求されない限り、0-RTT（送信または受け入れのいずれか）を有効にしてはならず、アプリケーションによって指示されない限り、サーバーによって拒否された場合、0-RTTデータを自動的に再送信してはなりません。 サーバー側のアプリケーションは、ある種のアプリケーショントラフィックの0-RTTデータに特別な処理を実装することを希望する場合があります（たとえば、接続の中止、アプリケーション層でのデータの再送信の要求、またはハンドシェイクが完了するまで処理を遅らせる）。 アプリケーションがこの種の処理を実装できるようにするため、TLS実装は、アプリケーションがハンドシェイクが完了したかどうかを判断する方法を提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.5.1. Replay and Exporters
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.5.1。 リプレイとエクスポーター
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Replays of the ClientHello produce the same early exporter, thus requiring additional care by applications which use these exporters. In particular, if these exporters are used as an authentication channel binding (e.g., by signing the output of the exporter), an attacker who compromises the PSK can transplant authenticators between connections without compromising the authentication key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ClientHelloのリプレイは同じ初期エクスポーターを生成するため、これらのエクスポーターを使用するアプリケーションによる追加の注意が必要です。 特に、これらのエクスポーターが認証チャネルバインディングとして使用される場合（エクスポーターの出力に署名するなど）、PSKを侵害する攻撃者は、認証キーを損なうことなく、接続間で認証子を移植できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, the early exporter SHOULD NOT be used to generate server-to-client encryption keys because that would entail the reuse of those keys. This parallels the use of the early application traffic keys only in the client-to-server direction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、初期エクスポーターは、サーバーからクライアントへの暗号化キーを生成するために使用しないでください（これらのキーの再利用が必要になるため）。 これは、クライアントからサーバーへの方向でのみ、初期のアプリケーショントラフィックキーの使用と並行しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.6. PSK Identity Exposure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.6。 PSKアイデンティティ露出
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because implementations respond to an invalid PSK binder by aborting the handshake, it may be possible for an attacker to verify whether a given PSK identity is valid. Specifically, if a server accepts both external-PSK handshakes and certificate-based handshakes, a valid PSK identity will result in a failed handshake, whereas an invalid identity will just be skipped and result in a successful certificate handshake. Servers which solely support PSK handshakes may be able to resist this form of attack by treating the cases where there is no valid PSK identity and where there is an identity but it has an invalid binder identically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装はハンドシェイクを中止することで無効なPSKバインダーに応答するため、攻撃者は特定のPSK IDが有効かどうかを確認できる可能性があります。 具体的には、サーバーが外部PSKハンドシェイクと証明書ベースのハンドシェイクの両方を受け入れる場合、有効なPSK IDはハンドシェイクに失敗しますが、無効なIDはスキップされ、証明書ハンドシェイクに成功します。 PSKハンドシェイクのみをサポートするサーバーは、有効なPSK IDが存在せず、IDは存在するが無効なバインダーを持つケースを処理することにより、この形式の攻撃に抵抗できる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.7. Sharing PSKs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.7。 PSKの共有
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3 takes a conservative approach to PSKs by binding them to a specific KDF. By contrast, TLS 1.2 allows PSKs to be used with any hash function and the TLS 1.2 PRF. Thus, any PSK which is used with both TLS 1.2 and TLS 1.3 must be used with only one hash in TLS 1.3, which is less than optimal if users want to provision a single PSK. The constructions in TLS 1.2 and TLS 1.3 are different, although they are both based on HMAC. While there is no known way in which the same PSK might produce related output in both versions, only limited analysis has been done. Implementations can ensure safety from cross-protocol related output by not reusing PSKs between TLS 1.3 and TLS 1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3は、PSKを特定のKDFにバインドすることにより、PSKに対して保守的なアプローチを取ります。 対照的に、TLS 1.2では、PSKを任意のハッシュ関数およびTLS 1.2 PRFで使用できます。 したがって、TLS 1.2とTLS 1.3の両方で使用されるPSKは、TLS 1.3の1つのハッシュのみで使用する必要があります。これは、ユーザーが単一のPSKをプロビジョニングする場合は最適ではありません。 TLS 1.2とTLS 1.3の構造は異なりますが、どちらもHMACに基づいています。 同じPSKが両方のバージョンで関連する出力を生成する既知の方法はありませんが、限られた分析のみが行われています。 実装では、TLS 1.3とTLS 1.2の間でPSKを再利用しないことで、クロスプロトコル関連の出力から安全性を確保できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.8. Attacks on Static RSA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
E.8。 静的RSAへの攻撃
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although TLS 1.3 does not use RSA key transport and so is not directly susceptible to Bleichenbacher-type attacks [Blei98], if TLS 1.3 servers also support static RSA in the context of previous versions of TLS, then it may be possible to impersonate the server for TLS 1.3 connections [JSS15]. TLS 1.3 implementations can prevent this attack by disabling support for static RSA across all versions of TLS. In principle, implementations might also be able to separate certificates with different keyUsage bits for static RSA decryption and RSA signature, but this technique relies on clients refusing to accept signatures using keys in certificates that do not have the digitalSignature bit set, and many clients do not enforce this restriction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TLS 1.3はRSAキー転送を使用しないため、Bleichenbacherタイプの攻撃[Blei98]の影響を直接受けませんが、TLS 1.3サーバーもTLSの以前のバージョンのコンテキストで静的RSAをサポートしている場合、サーバーになりすます可能性があります TLS 1.3接続の場合[JSS15]。 TLS 1.3実装は、TLSのすべてのバージョンで静的RSAのサポートを無効にすることにより、この攻撃を防ぐことができます。 原則として、実装は静的RSA復号化とRSA署名用に異なるkeyUsageビットの証明書を分離することもできますが、この手法は、digitalSignatureビットが設定されていない証明書のキーを使用して署名を受け入れることを拒否するクライアントに依存し、多くのクライアントはそうします この制限を強制しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
寄稿者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Martin Abadi University of California, Santa Cruz abadi@cs.ucsc.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
カリフォルニア州マーティンアバディ大学、サンタクルーズabadi@cs.ucsc.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Christopher Allen (co-editor of TLS 1.0) Alacrity Ventures ChristopherA@AlacrityManagement.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クリストファーアレン（TLS 1.0の共同編集者）Alacrity Ventures ChristopherA@AlacrityManagement.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Richard Barnes Cisco rlb@ipv.sx
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リチャードバーンズシスコrlb@ipv.sx
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Steven M. Bellovin Columbia University smb@cs.columbia.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スティーブンM.ベロビンコロンビア大学smb@cs.columbia.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
David Benjamin Google davidben@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デビッド・ベンジャミンGoogle davidben@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Benjamin Beurdouche INRIA &amp; Microsoft Research benjamin.beurdouche@ens.fr
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Benjamin Beurdouche INRIA＆Microsoft Research benjamin.beurdouche@ens.fr
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Karthikeyan Bhargavan (editor of [RFC7627]) INRIA karthikeyan.bhargavan@inria.fr
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Karthikeyan Bhargavan（[RFC7627]の編集者）INRIA karthikeyan.bhargavan@inria.fr
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Simon Blake-Wilson (co-author of [RFC4492]) BCI sblakewilson@bcisse.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Simon Blake-Wilson（[RFC4492]の共著者）BCI sblakewilson@bcisse.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Nelson Bolyard (co-author of [RFC4492]) Sun Microsystems, Inc. nelson@bolyard.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Nelson Bolyard（[RFC4492]の共著者）Sun Microsystems、Inc. nelson@bolyard.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ran Canetti IBM canetti@watson.ibm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ran Canetti IBM canetti@watson.ibm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Matt Caswell OpenSSL matt@openssl.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Matt Caswell OpenSSL matt@openssl.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stephen Checkoway University of Illinois at Chicago sfc@uic.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スティーブン・チェックウェイイリノイ大学シカゴ校sfc@uic.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Pete Chown Skygate Technology Ltd pc@skygate.co.uk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピートチャウンスカイゲートテクノロジーリミテッドpc@skygate.co.uk
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Katriel Cohn-Gordon University of Oxford me@katriel.co.uk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オックスフォード大学カトリエル・コーン・ゴードン大学me@katriel.co.uk
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cas Cremers University of Oxford cas.cremers@cs.ox.ac.uk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オックスフォードのカスクレマーズ大学cas.cremers@cs.ox.ac.uk
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Antoine Delignat-Lavaud (co-author of [RFC7627]) INRIA antdl@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Antoine Delignat-Lavaud（[RFC7627]の共著者）INRIA antdl@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tim Dierks (co-author of TLS 1.0, co-editor of TLS 1.1 and 1.2) Independent tim@dierks.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tim Dierks（TLS 1.0の共著者、TLS 1.1および1.2の共同編集者）独立tim@dierks.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Roelof DuToit Symantec Corporation roelof_dutoit@symantec.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Roelof DuToit Symantec Corporation roelof_dutoit@symantec.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Taher Elgamal Securify taher@securify.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Taher Elgamal Securify taher@securify.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Pasi Eronen Nokia pasi.eronen@nokia.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Pasi Eronen Nokia pasi.eronen@nokia.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cedric Fournet Microsoft fournet@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cedric Fournet Microsoft fournet@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Anil Gangolli anil@busybuddha.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アニル・ガンゴリanil@busybuddha.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
David M. Garrett dave@nulldereference.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デビッド・M・ギャレットdave@nulldereference.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Illya Gerasymchuk Independent illya@iluxonchik.me
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Illya Gerasymchuk Independent illya@iluxonchik.me
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Alessandro Ghedini Cloudflare Inc. alessandro@cloudflare.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Alessandro Ghedini Cloudflare Inc. alessandro@cloudflare.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Daniel Kahn Gillmor ACLU dkg@fifthhorseman.net
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ダニエルカーンギルモアACLU dkg@fifthhorseman.net
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Matthew Green Johns Hopkins University mgreen@cs.jhu.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マシュー・グリーン・ジョンズ・ホプキンス大学mgreen@cs.jhu.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jens Guballa ETAS jens.guballa@etas.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jens Guballa ETAS jens.guballa@etas.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Felix Guenther TU Darmstadt mail@felixguenther.info
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Felix Guenther TUダルムシュタットmail@felixguenther.info
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Vipul Gupta (co-author of [RFC4492]) Sun Microsystems Laboratories vipul.gupta@sun.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Vipul Gupta（[RFC4492]の共著者）Sun Microsystems Laboratories vipul.gupta@sun.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Chris Hawk (co-author of [RFC4492]) Corriente Networks LLC chris@corriente.net
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クリス・ホーク（[RFC4492]の共著者）Corriente Networks LLC chris@corriente.net
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Kipp Hickman
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キップ・ヒックマン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Alfred Hoenes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アルフレッド・ホーネス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
David Hopwood Independent Consultant david.hopwood@blueyonder.co.uk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デビッド・ホップウッド独立コンサルタントdavid.hopwood@blueyonder.co.uk
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Marko Horvat MPI-SWS mhorvat@mpi-sws.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Marko Horvat MPI-SWS mhorvat@mpi-sws.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jonathan Hoyland Royal Holloway, University of London jonathan.hoyland@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジョナサン・ホイランドロイヤル・ホロウェイ、ロンドン大学jonathan.hoyland@gmail.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Subodh Iyengar Facebook subodh@fb.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Subodh Iyengar Facebook subodh@fb.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Benjamin Kaduk Akamai Technologies kaduk@mit.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Benjamin Kaduk Akamai Technologies kaduk@mit.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hubert Kario Red Hat Inc. hkario@redhat.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヒューバート・カリオ・レッドハット・インクhkario@redhat.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phil Karlton (co-author of SSL 3.0)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phil Karlton（SSL 3.0の共著者）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Leon Klingele Independent mail@leonklingele.de
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Leon Klingele Independent mail@leonklingele.de
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Paul Kocher (co-author of SSL 3.0) Cryptography Research paul@cryptography.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Paul Kocher（SSL 3.0の共著者）Cryptography Research paul@cryptography.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hugo Krawczyk IBM hugokraw@us.ibm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hugo Krawczyk IBM hugokraw@us.ibm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Adam Langley (co-author of [RFC7627]) Google agl@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Adam Langley（[RFC7627]の共著者）Google agl@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Olivier Levillain ANSSI olivier.levillain@ssi.gouv.fr
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オリヴィエ・レヴィランANSSI olivier.levillain@ssi.gouv.fr
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Xiaoyin Liu University of North Carolina at Chapel Hill xiaoyin.l@outlook.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ノースカロライナ州のy音Li大学、チャペルヒルxiaoyin.l@outlook.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ilari Liusvaara Independent ilariliusvaara@welho.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ilari Liusvaara独立ilariliusvaara@welho.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Atul Luykx K.U. Leuven atul.luykx@kuleuven.be
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Atul Luykx K.U. ルーベンatul.luykx@kuleuven.be
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Colm MacCarthaigh Amazon Web Services colm@allcosts.net
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Colm MacCarthaighアマゾンウェブサービスcolm@allcosts.net
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Carl Mehner USAA carl.mehner@usaa.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Carl Mehner USAA carl.mehner@usaa.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jan Mikkelsen Transactionware janm@transactionware.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヤン・ミケルセンTransactionware janm@transactionware.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bodo Moeller (co-author of [RFC4492]) Google bodo@acm.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bodo Moeller（[RFC4492]の共著者）Google bodo@acm.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Kyle Nekritz Facebook knekritz@fb.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
カイル・ネクリッツFacebook knekritz@fb.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Erik Nygren Akamai Technologies erik+ietf@nygren.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Erik Nygren Akamai Technologies erik+ietf@nygren.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Magnus Nystrom Microsoft mnystrom@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Magnus Nystromマイクロソフトmnystrom@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Kazuho Oku DeNA Co., Ltd. kazuhooku@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
奥一穂DeNA Co.、Ltd. kazuhooku@gmail.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Kenny Paterson Royal Holloway, University of London kenny.paterson@rhul.ac.uk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロンドン大学ケニー・パターソン・ロイヤル・ホロウェイkenny.paterson@rhul.ac.uk
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Christopher Patton University of Florida cjpatton@ufl.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クリストファー・パットン大学フロリダ大学cjpatton@ufl.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Alfredo Pironti (co-author of [RFC7627]) INRIA alfredo.pironti@inria.fr
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Alfredo Pironti（[RFC7627]の共著者）INRIA alfredo.pironti@inria.fr
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Andrei Popov Microsoft andrei.popov@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アンドレイ・ポポフマイクロソフトandrei.popov@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Marsh Ray (co-author of [RFC7627]) Microsoft maray@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マーシュレイ（[RFC7627]の共著者）Microsoft maray@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Robert Relyea Netscape Communications relyea@netscape.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロバート・レリエア・ネットスケープ・コミュニケーションズreliea@netscape.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Kyle Rose Akamai Technologies krose@krose.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
カイルローズアカマイテクノロジーズkrose@krose.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jim Roskind Amazon jroskind@amazon.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジム・ロスキンドAmazon jroskind@amazon.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Michael Sabin
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マイケル・サビン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Joe Salowey Tableau Software joe@salowey.net
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Joe Salowey Tableau Software joe@salowey.net
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rich Salz Akamai rsalz@akamai.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リッチザルツアカマイrsalz@akamai.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
David Schinazi Apple Inc. dschinazi@apple.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
David Schinazi Apple Inc. dschinazi@apple.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sam Scott Royal Holloway, University of London me@samjs.co.uk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロンドン大学サム・スコット・ロイヤル・ホロウェイme@samjs.co.uk
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thomas Shrimpton University of Florida teshrim@ufl.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フロリダ大学トーマス・シュリンプトン大学teshrim@ufl.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Dan Simon Microsoft, Inc. dansimon@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ダンサイモンマイクロソフト社dansimon@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Brian Smith Independent brian@briansmith.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブライアン・スミス独立brian@briansmith.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Brian Sniffen Akamai Technologies ietf@bts.evenmere.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブライアン・スニフェン・アカマイ・テクノロジーズietf@bts.evenmere.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Nick Sullivan Cloudflare Inc. nick@cloudflare.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Nick Sullivan Cloudflare Inc. nick@cloudflare.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bjoern Tackmann University of California, San Diego btackmann@eng.ucsd.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bjoern Tackmannカリフォルニア大学サンディエゴ校btackmann@eng.ucsd.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tim Taubert Mozilla ttaubert@mozilla.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tim Taubert Mozilla ttaubert@mozilla.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Martin Thomson Mozilla mt@mozilla.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マーティントムソンMozilla mt@mozilla.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hannes Tschofenig Arm Limited Hannes.Tschofenig@arm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hannes Tschofenig Arm Limited Hannes.Tschofenig@arm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sean Turner sn3rd sean@sn3rd.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ショーン・ターナーsn3rd sean@sn3rd.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Steven Valdez Google svaldez@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Steven Valdez Google svaldez@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Filippo Valsorda Cloudflare Inc. filippo@cloudflare.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Filippo Valsorda Cloudflare Inc. filippo@cloudflare.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thyla van der Merwe Royal Holloway, University of London tjvdmerwe@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thyla van der Merwe Royal Holloway、ロンドン大学tjvdmerwe@gmail.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Victor Vasiliev Google vasilvv@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Victor Vasiliev Google vasilvv@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hoeteck Wee Ecole Normale Superieure, Paris hoeteck@alum.mit.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hoeteck Wee Ecole Normale Superieure、パリhoeteck@alum.mit.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tom Weinstein
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トム・ワインスタイン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
David Wong NCC Group david.wong@nccgroup.trust
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デビッドウォンNCCグループdavid.wong@nccgroup.trust
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Christopher A. Wood Apple Inc. cawood@apple.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クリストファー・A・ウッドApple Inc. cawood@apple.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Tim Wright Vodafone timothy.wright@vodafone.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ティム・ライト・ボーダフォンtimothy.wright@vodafone.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Peter Wu Independent peter@lekensteyn.nl
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピーター・ウー・インディペンデントpeter@lekensteyn.nl
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Kazu Yamamoto Internet Initiative Japan Inc. kazu@iij.ad.jp
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
山本和一インターネットイニシアティブジャパン株式会社kazu@iij.ad.jp
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者の住所
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Eric Rescorla Mozilla
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エリック・レスコーラ・モジラ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Email: ekr@rtfm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メール：ekr@rtfm.com
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
