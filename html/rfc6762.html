<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 6762 - Multicast DNS 日本語訳</title>

  
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
    <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6762 - Multicast DNS 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc6762">
              https://tools.ietf.org/html/rfc6762
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6762 - マルチキャストDNS</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                       S. Cheshire
Request for Comments: 6762                                   M. Krochmal
Category: Standards Track                                     Apple Inc.
ISSN: 2070-1721                                            February 2013
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             Multicast DNS
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As networked devices become smaller, more portable, and more ubiquitous, the ability to operate with less configured infrastructure is increasingly important. In particular, the ability to look up DNS resource record data types (including, but not limited to, host names) in the absence of a conventional managed DNS server is useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークデバイスは、より小さく、よりポータブル、およびよりユビキタスになるにつれて、より少ない構成し、インフラストラクチャで動作する能力がますます重要になっています。特に、従来の管理DNSサーバが存在しない場合には（ホスト名、を含むが、これらに限定されない）DNSリソースレコードのデータ型を検索する機能が便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS (mDNS) provides the ability to perform DNS-like operations on the local link in the absence of any conventional Unicast DNS server. In addition, Multicast DNS designates a portion of the DNS namespace to be free for local use, without the need to pay any annual fee, and without the need to set up delegations or otherwise configure a conventional DNS server to answer for those names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS（mDNSの）は、任意の従来のユニキャストDNSサーバが存在しない場合に、ローカルリンク上のDNSのような操作を実行する能力を提供します。また、マルチキャストDNSは、DNS名前空間の部分は任意の年会費を支払う必要がなく、および委任を設定するか、そうでない場合はそれらの名前のために答えるために、従来のDNSサーバを設定する必要がなく、ローカルな使用のために自由であることを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The primary benefits of Multicast DNS names are that (i) they require little or no administration or configuration to set them up, (ii) they work when no infrastructure is present, and (iii) they work during infrastructure failures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS名の主な利点は、（i）は、彼らが（ⅱ）彼らは何のインフラが存在しない場合に動作、および（iii）は、インフラの障害時に動作し、それらを設定するにはほとんど、あるいはまったく管理や構成を必要とすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6762.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6762で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................4
   2. Conventions and Terminology Used in This Document ...............4
   3. Multicast DNS Names .............................................5
   4. Reverse Address Mapping .........................................7
   5. Querying ........................................................8
   6. Responding .....................................................13
   7. Traffic Reduction ..............................................22
   8. Probing and Announcing on Startup ..............................25
   9. Conflict Resolution ............................................31
   10. Resource Record TTL Values and Cache Coherency ................33
   11. Source Address Check ..........................................38
   12. Special Characteristics of Multicast DNS Domains ..............40
   13. Enabling and Disabling Multicast DNS ..........................41
   14. Considerations for Multiple Interfaces ........................42
   15. Considerations for Multiple Responders on the Same Machine ....43
   16. Multicast DNS Character Set ...................................45
   17. Multicast DNS Message Size ....................................46
   18. Multicast DNS Message Format ..................................47
   19. Summary of Differences between Multicast DNS and Unicast DNS ..51
   20. IPv6 Considerations ...........................................52
   21. Security Considerations .......................................52
   22. IANA Considerations ...........................................53
   23. Acknowledgments ...............................................56
   24. References ....................................................56
   Appendix A. Design Rationale for Choice of UDP Port Number ........60
   Appendix B. Design Rationale for Not Using Hashed Multicast
               Addresses .............................................61
   Appendix C. Design Rationale for Maximum Multicast DNS Name
               Length ................................................62
   Appendix D. Benefits of Multicast Responses .......................64
   Appendix E. Design Rationale for Encoding Negative Responses ......65
   Appendix F. Use of UTF-8 ..........................................66
   Appendix G. Private DNS Namespaces ................................67
   Appendix H. Deployment History ....................................67
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS and its companion technology DNS-Based Service Discovery [RFC6763] were created to provide IP networking with the ease-of-use and autoconfiguration for which AppleTalk was well-known [RFC6760]. When reading this document, familiarity with the concepts of Zero Configuration Networking [Zeroconf] and automatic link-local addressing [RFC3927] [RFC4862] is helpful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSとそのコンパニオンテクノロジーDNSベースのサービスディスカバリー[RFC6763]は、使いやすさと自動設定AppleTalkは、よく知られてあったために、[RFC6760]とのネットワークIPを提供するために作成されました。ゼロ構成ネットワーク[のZeroconf]と自動リンクローカルアドレス指定の[RFC3927] [RFC4862]の概念に、この文書、親しみを読むときに便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS borrows heavily from the existing DNS protocol [RFC1034] [RFC1035] [RFC6195], using the existing DNS message structure, name syntax, and resource record types. This document specifies no new operation codes or response codes. This document describes how clients send DNS-like queries via IP multicast, and how a collection of hosts cooperate to collectively answer those queries in a useful manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSは、既存のDNSメッセージの構造、名前の構文、およびリソースレコードタイプを使用して、既存のDNSプロトコル[RFC1034] [RFC1035] [RFC6195]から大いに借ります。この文書は、新しい操作コードまたは応答コードを指定します。この文書では、クライアントはIPマルチキャストを経由してDNSのようなクエリを送信する方法について説明し、どのようにホストの集合をまとめ便利な方法でこれらのクエリに答えるために協力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Conventions and Terminology Used in This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
この文書で使用される2.表記と用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in &#34;Key words for use in RFCs to Indicate Requirement Levels&#34; [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はあります「要求レベルを示すためのRFCsにおける使用のためのキーワード」[RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this document uses the term &#34;Multicast DNS&#34;, it should be taken to mean: &#34;Clients performing DNS-like queries for DNS-like resource records by sending DNS-like UDP query and response messages over IP Multicast to UDP port 5353&#34;. The design rationale for selecting UDP port 5353 is discussed in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「クライアントがUDPポート5353にIPマルチキャスト上でDNSのようなUDPクエリと応答メッセージを送信することにより、DNSのようなリソースレコードのDNSのようなクエリを実行する」：この文書は、「マルチキャストDNS」という用語を使用する場合、意味すると解釈されるべきです。 UDPポート5353を選択するための設計上の根拠は、付録Aで説明されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document uses the term &#34;host name&#34; in the strict sense to mean a fully qualified domain name that has an IPv4 or IPv6 address record. It does not use the term &#34;host name&#34; in the commonly used but incorrect sense to mean just the first DNS label of a host&#39;s fully qualified domain name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、IPv4またはIPv6アドレスレコードを持っている完全修飾ドメイン名を意味するように、厳密な意味での用語「ホスト名」を使用しています。これは、ホストの完全修飾ドメイン名のちょうど最初のDNSラベルを意味するために一般的に使用されるが、間違った意味での用語「ホスト名」を使用していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A DNS (or mDNS) packet contains an IP Time to Live (TTL) in the IP header, which is effectively a hop-count limit for the packet, to guard against routing loops. Each resource record also contains a TTL, which is the number of seconds for which the resource record may be cached. This document uses the term &#34;IP TTL&#34; to refer to the IP header TTL (hop limit), and the term &#34;RR TTL&#34; or just &#34;TTL&#34; to refer to the resource record TTL (cache lifetime).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS（またはのmDNS）パケットは、ルーティングループを防ぐために、効果的にパケットのホップカウント限界であるIPヘッダに（TTL）ライブするIP時間を含んでいます。各リソースレコードは、リソースレコードをキャッシュできる秒数でTTLが含まれています。この文書は、リソースレコードTTL（キャッシュの有効期間）を参照するためにIPヘッダのTTL（ホップ・リミット）、および用語「RRのTTL」または単に「TTL」を指すために、用語「IP TTL」を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS-format messages contain a header, a Question Section, then Answer, Authority, and Additional Record Sections. The Answer, Authority, and Additional Record Sections all hold resource records in the same format. Where this document describes issues that apply equally to all three sections, it uses the term &#34;Resource Record Sections&#34; to refer collectively to these three sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS形式のメッセージはその後、当局に答えて、ヘッダー、質問のセクションが含まれており、追加のレコードセクション。回答、権限、および追加のレコードセクションはすべて同じ形式でリソースレコードを保持します。このドキュメントはすべての3つのセクションに等しく適用問題について説明する場合、それは、これらの3つのセクションを総称する用語「リソースレコードセクション」を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document uses the terms &#34;shared&#34; and &#34;unique&#34; when referring to resource record sets [RFC1034]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、レコードセット[RFC1034]を資源化に言及するとき、「ユニーク」「共有」との用語を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A &#34;shared&#34; resource record set is one where several Multicast DNS responders may have records with the same name, rrtype, and rrclass, and several responders may respond to a particular query.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「共有」リソースレコードセットは、複数のマルチキャストDNSの応答は、特定のクエリに応答することができる、同じ名前、rrtype、およびrrclass、およびいくつかの応答を持つレコードを有することができるものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A &#34;unique&#34; resource record set is one where all the records with that name, rrtype, and rrclass are conceptually under the control or ownership of a single responder, and it is expected that at most one responder should respond to a query for that name, rrtype, and rrclass. Before claiming ownership of a unique resource record set, a responder MUST probe to verify that no other responder already claims ownership of that set, as described in Section 8.1, &#34;Probing&#34;. (For fault-tolerance and other reasons, sometimes it is permissible to have more than one responder answering for a particular &#34;unique&#34; resource record set, but such cooperating responders MUST give answers containing identical rdata for these records. If they do not give answers containing identical rdata, then the probing step will reject the data as being inconsistent with what is already being advertised on the network for those names.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ユニークな」リソースレコードセットは、その名前、rrtype、およびrrclassを持つすべてのレコードが単一応答の制御や所有権の下に概念的であり、最大1人の応答者は、その名のクエリに応答する必要があることが予想されるものです、rrtype、およびrrclass。ユニークなリソースレコードセットの所有権を主張する前に、応答側は「調査」、8.1節で説明したように、他のレスポンダはすでに、そのセットの所有権を主張しないことを確認するために、プローブしなければなりません。 （フォールトトレランスおよび他の理由から、時には特定の「ユニーク」リソースレコードセットに答えるつ以上の応答を持つことが許されるが、そのような協力の応答者は、これらの記録のために、同一の資源データを含む答えを与えなければならない。彼らは答えを与えていない場合同じRDATAを含む、その後、プロービング段階はすでにそれらの名前のためにネットワーク上で公示されているものと矛盾しているとのデータを拒否します。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Strictly speaking, the terms &#34;shared&#34; and &#34;unique&#34; apply to resource record sets, not to individual resource records. However, it is sometimes convenient to talk of &#34;shared resource records&#34; and &#34;unique resource records&#34;. When used this way, the terms should be understood to mean a record that is a member of a &#34;shared&#34; or &#34;unique&#34; resource record set, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
厳密に言えば、「ユニーク」「共有」という用語とはない、個々のリソースレコードにレコードセットを、リソースに適用します。しかし、それは「共有リソースレコード」と「ユニークなリソースレコード」の話に、時には便利です。この方法で使用されるとき、用語はそれぞれ、「共有」または「ユニーク」リソースレコードセットのメンバーであるレコードを意味すると理解されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Multicast DNS Names
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.マルチキャストDNS名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A host that belongs to an organization or individual who has control over some portion of the DNS namespace can be assigned a globally unique name within that portion of the DNS namespace, such as, &#34;cheshire.example.com.&#34;. For those of us who have this luxury, this works very well. However, the majority of home computer users do not have easy access to any portion of the global DNS namespace within which they have the authority to create names. This leaves the majority of home computers effectively anonymous for practical purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS名前空間の一部を制御している組織または個人に属するホストは、このような、として、DNS名前空間のその部分の中に、グローバルに一意の名前を割り当てることができる「cheshire.example.com。」。この贅沢を持っている人たちのもののために、これは非常によく動作します。しかし、自宅のコンピュータユーザーの大半は、彼らが名を作成する権限を持ってその中にグローバルなDNS名前空間の任意の部分への容易なアクセスを持っていません。これは実用的な目的のために効果的に匿名の家庭用コンピュータの大部分を残します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To remedy this problem, this document allows any computer user to elect to give their computers link-local Multicast DNS host names of the form: &#34;single-dns-label.local.&#34;. For example, a laptop computer may answer to the name &#34;MyComputer.local.&#34;. Any computer user is granted the authority to name their computer this way, provided that the chosen host name is not already in use on that link. Having named their computer this way, the user has the authority to continue utilizing that name until such time as a name conflict occurs on the link that is not resolved in the user&#39;s favor. If this happens, the computer (or its human user) MUST cease using the name, and SHOULD attempt to allocate a new unique name for use on that link. These conflicts are expected to be relatively rare for people who choose reasonably imaginative names, but it is still important to have a mechanism in place to handle them when they happen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この問題を解決するには、この文書には、任意のコンピュータのユーザーが自分のコンピュータにフォームのリンクローカルマルチキャストDNSホスト名を与えることを選択することができます：「シングルDNS-label.local」。例えば、ラップトップコンピュータは、名前に答えて、「MyComputer.local。」。任意のコンピュータユーザーは、自分のコンピュータ、このように名前を付けるために権限を付与された選択したホスト名がそのリンク上で使用されていないことを提供します。自分のコンピュータをこのように名付けられた、ユーザーは、名前の競合などの時間は、ユーザーの有利に解決されていないリンク上で発生するまでその名前を利用し継続する権限を有しています。このような場合は、コンピュータ（またはその人間のユーザは）名前を使用して停止する必要があり、そのリンク上で使用するために新しい一意の名前を割り当てることを試みるべきです。これらの競合は、合理的想像力の名前を選択するが、彼らが発生したときにそれらを処理するための場所でのメカニズムを持つことが重要である人々のために比較的まれであると予想されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies that the DNS top-level domain &#34;.local.&#34; is a special domain with special semantics, namely that any fully qualified name ending in &#34;.local.&#34; is link-local, and names within this domain are meaningful only on the link where they originate. This is analogous to IPv4 addresses in the 169.254/16 prefix or IPv6 addresses in the FE80::/10 prefix, which are link-local and meaningful only on the link where they originate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、DNSのトップレベルドメインを指定することを「.localの。」任意の完全修飾名がで終わるすなわちことを、特別なセマンティクスを持つ特殊なドメインである「.localの。」リンクローカルであり、このドメイン内の名前は、彼らだけが発信リンク上で意味があります。 IPv4のは169.254 / 16プレフィックスのアドレスまたはIPv6リンクローカルおよび有意義のみそれらが発信リンク上であるFE80 :: / 10プレフィックスのアドレスに、これは類似しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any DNS query for a name ending with &#34;.local.&#34; MUST be sent to the mDNS IPv4 link-local multicast address 224.0.0.251 (or its IPv6 equivalent FF02::FB). The design rationale for using a fixed multicast address instead of selecting from a range of multicast addresses using a hash function is discussed in Appendix B. Implementers MAY choose to look up such names concurrently via other mechanisms (e.g., Unicast DNS) and coalesce the results in some fashion. Implementers choosing to do this should be aware of the potential for user confusion when a given name can produce different results depending on external network conditions (such as, but not limited to, which name lookup mechanism responds faster).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
終わる名前のための任意のDNSクエリ「.localの。」 mDNSのIPv4リンクローカルマルチキャストアドレス224.0.0.251（またはそのIPv6の同等FF02 :: FB）に送らなければなりません。固定されたマルチキャストアドレスを使用して代わりにハッシュ関数を使用して、マルチキャストアドレスの範囲から選択するための設計原理は、付録Bインプリに説明され、同時に他の機構（例えば、ユニキャストDNS）を介して、そのような名前をルックアップすることを選択し、結果を合体MAYいくつかのファッションインチ指定された名前は、外部ネットワークの状態に応じて、異なる結果を生成する（例えば、名前のルックアップメカニズムが速く応答するが、これらに限定されない）ことができたときにこれを実行することを選択する実装者は、ユーザーの混乱の可能性に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is unimportant whether a name ending with &#34;.local.&#34; occurred because the user explicitly typed in a fully qualified domain name ending in &#34;.local.&#34;, or because the user entered an unqualified domain name and the host software appended the suffix &#34;.local.&#34; because that suffix appears in the user&#39;s search list. The &#34;.local.&#34; suffix could appear in the search list because the user manually configured it, or because it was received via DHCP [RFC2132] or via any other mechanism for configuring the DNS search list. In this respect the &#34;.local.&#34; suffix is treated no differently from any other search domain that might appear in the DNS search list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前がで終わるかどうかは重要でない「.localの。」ユーザーが明示的に終わる完全修飾ドメイン名で入力したので、「.localの。 『が発生、またはユーザーが非修飾ドメイン名を入力し、ホストソフトウェアがサフィックスを付加しているため、』 .localの。」そのサフィックスは、ユーザーの検索リストに表示されますので。 &#34;.localの。&#34;サフィックスは、ユーザーが手動で設定されているため、検索リストに表示されるか、またはそれがDHCP [RFC2132]を介して、またはDNS検索リストを構成するための他の機構を介して受信したため。この点で「.localの。」サフィックスは、DNS検索リストに表示される可能性のある他の検索ドメインから全く異なる方法で処理されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS queries for names that do not end with &#34;.local.&#34; MAY be sent to the mDNS multicast address, if no other conventional DNS server is available. This can allow hosts on the same link to continue communicating using each other&#39;s globally unique DNS names during network outages that disrupt communication with the greater Internet. When resolving global names via local multicast, it is even more important to use DNS Security Extensions (DNSSEC) [RFC4033] or other security mechanisms to ensure that the response is trustworthy. Resolving global names via local multicast is a contentious issue, and this document does not discuss it further, instead concentrating on the issue of resolving local names using DNS messages sent to a multicast address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
終わらない名前のためのDNSクエリ「.localの。」他に、通常のDNSサーバーが利用できない場合、mDNSのマルチキャストアドレスに送ってもよいです。これは、同じリンク上のホストが大きいインターネットとの通信を妨害するネットワークの停止中に、お互いのグローバルに一意なDNS名を使用して通信を継続できるようにすることができます。ローカルマルチキャスト経由でグローバル名を解決するとき、それはレスポンスが信頼できることを保証するために、DNSセキュリティ拡張機能（DNSSEC）[RFC4033]、または他のセキュリティ・メカニズムを使用することがさらに重要です。ローカルマルチキャストを介してグローバル名を解決することは争点であり、このドキュメントではなく、マルチキャストアドレスに送信されたDNSメッセージを使用してローカル名前解決の問題に集中し、さらにそれを議論していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document recommends a single flat namespace for dot-local host names, (i.e., the names of DNS &#34;A&#34; and &#34;AAAA&#34; records, which map names to IPv4 and IPv6 addresses), but other DNS record types (such as those used by DNS-Based Service Discovery [RFC6763]) may contain as many labels as appropriate for the desired usage, up to a maximum of 255 bytes, plus a terminating zero byte at the end. Name length issues are discussed further in Appendix C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、使用されているようなドットローカルホスト名、（つまり、DNS「A」の、名前とIPv4アドレスとIPv6アドレスに名前をマップする「AAAA」レコードが、）が、他のDNSレコードタイプ（のための単一のフラットな名前空間を推奨していますDNSベースのサービス発見[RFC6763]）によって255バイトの最大値、プラス端で終端0バイトに、所望の用途に適切な限り多くの標識を含んでいてもよいです。名前の長さの問題は、付録C.でさらに議論されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Enforcing uniqueness of host names is probably desirable in the common case, but this document does not mandate that. It is permissible for a collection of coordinated hosts to agree to maintain multiple DNS address records with the same name, possibly for load-balancing or fault-tolerance reasons. This document does not take a position on whether that is sensible. It is important that both modes of operation be supported. The Multicast DNS protocol allows hosts to verify and maintain unique names for resource records where that behavior is desired, and it also allows hosts to maintain multiple resource records with a single shared name where that behavior is desired. This consideration applies to all resource records, not just address records (host names). In summary: It is required that the protocol have the ability to detect and handle name conflicts, but it is not required that this ability be used for every record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホスト名の一意性を強制することは一般的な場合には、おそらく望ましいが、本書はそれを強制しません。コーディネートホストのコレクションは、おそらく負荷分散や耐障害性の理由から、同じ名前で複数のDNSアドレスレコードを維持することに同意することは許されています。この文書では、それが賢明であるかどうかを上の位置を取ることはありません。両方の動作モードがサポートされていることが重要です。マルチキャストDNSプロトコルは、ホストがその挙動が所望されるリソースレコードの一意の名前を確認し、維持することができ、そしてそれはまた、ホストがその挙動が所望される単一の共有名を使用して複数のリソースレコードを維持することを可能にします。この考慮事項は、すべてのリソースレコードだけでなく、アドレスレコード（ホスト名）に適用されます。要約：プロトコルは、名前の競合を検出し、処理する能力を持っていることが必要とされるが、この能力は、すべてのレコードを使用することを必要とされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Reverse Address Mapping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.逆アドレスマッピング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Like &#34;.local.&#34;, the IPv4 and IPv6 reverse mapping domains are also defined to be link-local:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「.LOCAL」のような、IPv4とIPv6の逆マッピングドメインはまた、リンクローカルであると定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any DNS query for a name ending with &#34;254.169.in-addr.arpa.&#34; MUST be sent to the mDNS IPv4 link-local multicast address 224.0.0.251 or the mDNS IPv6 multicast address FF02::FB. Since names under this domain correspond to IPv4 link-local addresses, it is logical that the local link is the best place to find information pertaining to those names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
終わる名前のための任意のDNSクエリ「254.169.in-addr.arpa。」 mDNSのIPv4リンクローカルマルチキャストアドレス224.0.0.251またはmDNSのIPv6マルチキャストアドレスFF02 :: FBに送らなければなりません。このドメイン下の名前はIPv4リンクローカルアドレスに対応しているので、ローカルリンクがそれらの名前に関連する情報を検索するのに最適な場所であることを論理的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Likewise, any DNS query for a name within the reverse mapping domains for IPv6 link-local addresses (&#34;8.e.f.ip6.arpa.&#34;, &#34;9.e.f.ip6.arpa.&#34;, &#34;a.e.f.ip6.arpa.&#34;, and &#34;b.e.f.ip6.arpa.&#34;) MUST be sent to the mDNS IPv6 link-local multicast address FF02::FB or the mDNS IPv4 link-local multicast address 224.0.0.251.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同様に、IPv6リンクローカルアドレスに逆マッピングドメイン内の名前（「8.efip6.arpa。」、「9.efip6.arpa。」、「aefip6.arpa。」、および「のための任意のDNSクエリbefip6.arpa。 &#34;）mDNSのIPv6リンクローカルマルチキャストアドレスFF02 :: FBかのmDNSのIPv4リンクローカルマルチキャストアドレス224.0.0.251に送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Querying
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.クエリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are two kinds of Multicast DNS queries: one-shot queries of the kind made by legacy DNS resolvers, and continuous, ongoing Multicast DNS queries made by fully compliant Multicast DNS queriers, which support asynchronous operations including DNS-Based Service Discovery [RFC6763].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6763]レガシーDNSリゾルバ、およびDNSベースのサービスディスカバリを含む非同期操作をサポートする完全準拠マルチキャストDNSのクエリアによって作られた連続、継続的なマルチキャストDNSクエリによって作られた種類のワンショットクエリを：マルチキャストDNSの2種類がありクエリです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Except in the rare case of a Multicast DNS responder that is advertising only shared resource records and no unique records, a Multicast DNS responder MUST also implement a Multicast DNS querier so that it can first verify the uniqueness of those records before it begins answering queries for them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その応答マルチキャストDNSのまれなケースでのみ共有リソースレコードなしのユニークなレコードを広告している場合を除き、それはのためのクエリに答える開始する前に、それは最初にそれらのレコードの一意性を確認できるように、マルチキャストDNS応答は、マルチキャストDNSクエリアを実装しなければなりませんそれら。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. One-Shot Multicast DNS Queries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。ワンショットマルチキャストDNSクエリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The most basic kind of Multicast DNS client may simply send standard DNS queries blindly to 224.0.0.251:5353, without necessarily even being aware of what a multicast address is. This change can typically be implemented with just a few lines of code in an existing DNS resolver library. If a name being queried falls within one of the reserved Multicast DNS domains (see Sections 3 and 4), then, rather than using the configured Unicast DNS server address, the query is instead sent to 224.0.0.251:5353 (or its IPv6 equivalent [FF02::FB]:5353). Typically, the timeout would also be shortened to two or three seconds. It&#39;s possible to make a minimal Multicast DNS resolver with only these simple changes. These queries are typically done using a high-numbered ephemeral UDP source port, but regardless of whether they are sent from a dynamic port or from a fixed port, these queries MUST NOT be sent using UDP source port 5353, since using UDP source port 5353 signals the presence of a fully compliant Multicast DNS querier, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSクライアントの最も基本的な種類は、単純に、必ずしもでもマルチキャストアドレスが何であるかを意識することなく、盲目的224.0.0.251:5353に標準のDNSクエリを送信することができます。この変更は、通常、既存のDNSリゾルバライブラリ内のわずか数行のコードで実現することができます。照会された名前は、予約されたマルチキャストDNSドメインの1つに収まる場合（セクション3および4参照）、その後、むしろ構成ユニキャストDNSサーバアドレスを使用するよりも、クエリが代わり224.0.0.251:5353（またはIPv6の同等に送られます。 [FF02 :: FB]：5353）。通常、タイムアウトは、2つまたは3秒に短縮されます。それだけでこれらの簡単な変更を最小限マルチキャストDNSリゾルバを作成することが可能です。これらのクエリは、典型的には、高い番号のはかないUDPソースポートを使用して行われるが、関係なく、動的ポートから、または固定のポートから送信されたかどうか、これらのクエリは、UDPソースポート5353を使用しているため、UDP送信元ポート5353を使用して送信してはいけません以下に説明するように、完全に準拠マルチキャストDNSクエリアの存在を知らせます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A simple DNS resolver like this will typically just take the first response it receives. It will not listen for additional UDP responses, but in many instances this may not be a serious problem. If a user types &#34;http://MyPrinter.local.&#34; into their web browser, and their simple DNS resolver just takes the first response it receives, and the user gets to see the status and configuration web page for their printer, then the protocol has met the user&#39;s needs in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このような単純なDNSリゾルバは通常、ちょうどそれが受信した最初の応答がかかります。これは、追加のUDP応答を聞くことはありませんが、多くの場合、これは深刻な問題ではないかもしれません。ユーザータイプ「のhttp：//MyPrinter.local」の場合自分のWebブラウザ、およびその簡単なDNSリゾルバはちょうどそれが受信した最初の応答を受け取り、ユーザーがプリンタの状態と設定Webページを見るために取得するには、プロトコルは、この場合には、ユーザーのニーズを満たしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While a basic DNS resolver like this may be adequate for simple host name lookup, it may not get ideal behavior in other cases. Additional refinements to create a fully compliant Multicast DNS querier are described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このような基本的なDNSリゾルバは、単純なホスト名の検索には十分かもしれないが、それは他のケースで理想的な動作を取得しない場合があります。完全に準拠マルチキャストDNSクエリアを作成するための追加の改良は、以下に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Continuous Multicast DNS Querying
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。連続マルチキャストDNSクエリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In one-shot queries, the underlying assumption is that the transaction begins when the application issues a query, and ends when the first response is received. There is another type of query operation that is more asynchronous, in which having received one response is not necessarily an indication that there will be no more relevant responses, and the querying operation continues until no further responses are required. Determining when no further responses are required depends on the type of operation being performed. If the operation is looking up the IPv4 and IPv6 addresses of another host, then no further responses are required once a successful connection has been made to one of those IPv4 or IPv6 addresses. If the operation is browsing to present the user with a list of DNS-SD services found on the network [RFC6763], then no further responses are required once the user indicates this to the user-interface software, e.g., by closing the network browsing window that was displaying the list of discovered services.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ワンショットクエリでは、根本的な前提は、アプリケーションがクエリを発行し、最初の応答を受信したときに終了したときに、トランザクションが始まることです。そこつの応答を受信した複数非同期でクエリ操作、別のタイプは、もはや関連応答があるだろうという指示は、必ずしもされていないで、さらなる応答が必要とされなくなるまで問合せ動作が継続されます。それ以上の応答が必要とされていない場合の決定は、実行されている操作の種類によって異なります。操作は、別のホストのIPv4アドレスとIPv6アドレスを探している場合は正常に接続がそれらのIPv4またはIPv6アドレスのいずれかになされた後、それ以上の応答は必要ありません。操作はネットワーク[RFC6763]で見つけDNS-SDサービスのリストをユーザに提示するために閲覧されている場合は、それ以上の応答は、ユーザがネットワークブラウジングを閉じることで、例えば、ユーザー・インターフェース・ソフトウェアにこれを示したら、必要ありません発見されたサービスのリストを表示した画面。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Imagine some hypothetical software that allows users to discover network printers. The user wishes to discover all printers on the local network, not only the printer that is quickest to respond. When the user is actively looking for a network printer to use, they open a network browsing window that displays the list of discovered printers. It would be convenient for the user if they could rely on this list of network printers to stay up to date as network printers come and go, rather than displaying out-of-date stale information, and requiring the user explicitly to click a &#34;refresh&#34; button any time they want to see accurate information (which, from the moment it is displayed, is itself already beginning to become out-of-date and stale). If we are to display a continuously updated live list like this, we need to be able to do it efficiently, without naive constant polling, which would be an unreasonable burden on the network. It is not expected that all users will be browsing to discover new printers all the time, but when a user is browsing to discover service instances for an extended period, we want to be able to support that operation efficiently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザーがネットワークプリンタを発見することを可能にするいくつかの仮想的なソフトウェアを想像してみてください。ユーザーは、ローカルネットワーク上の対応が最速であるプリンタだけでなく、すべてのプリンタを発見することを希望します。ユーザーが積極的に使用するネットワーク・プリンタを探しているときに、彼らが発見されたプリンタのリストを表示するネットワークブラウジングウィンドウを開きます。彼らは「リフレッシュをクリックすることではなく、時代遅れの古い情報を表示し、明示的にユーザーに要求するよりも、ネットワークプリンタが来ると日まで滞在するためにネットワークプリンタのリストに依存して行くことができるかどうかは、ユーザーにとって便利になります「ボタン彼らは（それが表示された瞬間から、それ自体がすでに古くおよび陳腐化し始めている、）正確な情報を表示したい任意の時間。私たちはこのような継続的に更新ライブリストを表示する場合、我々は、ネットワーク上の不合理な負担となりナイーブ定数ポーリング、なしで、効率的にそれを行うことができるようにする必要があります。すべてのユーザーが新しいプリンタのすべての時間を発見するために閲覧されますが、ユーザーが長期間サービスインスタンスを発見するために閲覧しているとき、私たちは効率的にその操作をサポートできるようにすることが期待されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Therefore, when retransmitting Multicast DNS queries to implement this kind of continuous monitoring, the interval between the first two queries MUST be at least one second, the intervals between successive queries MUST increase by at least a factor of two, and the querier MUST implement Known-Answer Suppression, as described below in Section 7.1. The Known-Answer Suppression mechanism tells responders which answers are already known to the querier, thereby allowing responders to avoid wasting network capacity with pointless repeated transmission of those answers. A querier retransmits its question because it wishes to receive answers it may have missed the first time, not because it wants additional duplicate copies of answers it already received. Failure to implement Known-Answer Suppression can result in unacceptable levels of network traffic. When the interval between queries reaches or exceeds 60 minutes, a querier MAY cap the interval to a maximum of 60 minutes, and perform subsequent queries at a steady-state rate of one query per hour. To avoid accidental synchronization when, for some reason, multiple clients begin querying at exactly the same moment (e.g., because of some common external trigger event), a Multicast DNS querier SHOULD also delay the first query of the series by a randomly chosen amount in the range 20-120 ms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の2つのクエリの間の間隔は、少なくとも一つの第二のでなければなりません、連続監視のこの種を実装するために、マルチキャストDNSクエリを再送信する場合したがって、連続したクエリとの間の間隔が少なくとも2倍増加しなければならない、とクエリアは、公知実装しなければなりません7.1節で以下に説明するように-Answer抑制、。既知解抑制機構は、それによって応答がこれらの回答の無意味な繰り返し送信で消耗ネットワーク容量を回避することができ、回答が既にクエリアに知られている応答者に伝え。それはそれはそれは既に受信回答の追加の重複コピーを望んでいないので、それは、最初の時間を逃したかもしれない答えを受けたいので、クエリアはその質問を再送信します。既知解抑制を実現するために失敗すると、ネットワークトラフィックの許容できないレベルをもたらすことができます。クエリの間隔が60分に達するか超えた場合、クエリアは60分の最大間隔をキャップし、1時間に1つのクエリの定常状態速度で後続の問合せを実行することができます。何らかの理由で、複数のクライアントが（理由はいくつかの共通の外部トリガイベントの、例えば）正確に同じ瞬間に照会し始めるとき、偶然の同期化を避けるために、マルチキャストDNSクエリアもでランダムに選ばれた量によってシリーズの最初のクエリを遅らせるべきです範囲20から120ミリ秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a Multicast DNS querier receives an answer, the answer contains a TTL value that indicates for how many seconds this answer is valid. After this interval has passed, the answer will no longer be valid and SHOULD be deleted from the cache. Before the record expiry time is reached, a Multicast DNS querier that has local clients with an active interest in the state of that record (e.g., a network browsing window displaying a list of discovered services to the user) SHOULD reissue its query to determine whether the record is still valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSクエリアが答えを受け取ると、その答えは、この答えが有効で何秒間を示すTTL値が含まれています。この間隔が経過した後、答えは無効になりますと、キャッシュから削除する必要があります。レコードの有効期限が到達する前に、そのレコードの状態に積極的に関心を持つローカルクライアントを持つマルチキャストDNSクエリア（例えば、利用者に発見されたサービスの一覧を表示するネットワークブラウジングウィンドウが）かどうかを判断するために、そのクエリを再発行すべきですレコードがまだ有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To perform this cache maintenance, a Multicast DNS querier should plan to retransmit its query after at least 50% of the record lifetime has elapsed. This document recommends the following specific strategy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このキャッシュ・メンテナンスを実行するには、マルチキャストDNSクエリアは、レコードの有効期間の少なくとも50％が経過した後にクエリを再送信するために計画する必要があります。このドキュメントでは、次の具体的な戦略を推奨しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The querier should plan to issue a query at 80% of the record lifetime, and then if no answer is received, at 85%, 90%, and 95%. If an answer is received, then the remaining TTL is reset to the value given in the answer, and this process repeats for as long as the Multicast DNS querier has an ongoing interest in the record. If no answer is received after four queries, the record is deleted when it reaches 100% of its lifetime. A Multicast DNS querier MUST NOT perform this cache maintenance for records for which it has no local clients with an active interest. If the expiry of a particular record from the cache would result in no net effect to any client software running on the querier device, and no visible effect to the human user, then there is no reason for the Multicast DNS querier to waste network capacity checking whether the record remains valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無回答が受信されない場合クエリアは85％、90％、および95％で、レコードの有効期間の80％でクエリを発行することを計画し、必要があります。答えが受信された場合、残りのTTLは、答えで与えられた値にリセットされ、このプロセスは、長いレコードの継続的な関心を持っているクエリアマルチキャストDNSなどのために繰り返されます。何の答えは4つのクエリの後に受信されない場合は、その寿命の100％に達したときに、レコードが削除されます。マルチキャストDNSクエリアは、それが積極的に関心を持つローカルクライアントを持たないため、レコードのためにこのキャッシュ・メンテナンスを行ってはなりません。キャッシュから特定のレコードの有効期限がクエリアデバイス上で実行されている任意のクライアントソフトウェアへの正味の効果が、人間のユーザに目に見える効果をもたらすだろう場合は、ネットワーク容量のチェックを無駄にするマルチキャストDNSクエリアのための理由はありませんレコードは有効のままかどうか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To avoid the case where multiple Multicast DNS queriers on a network all issue their queries simultaneously, a random variation of 2% of the record TTL should be added, so that queries are scheduled to be performed at 80-82%, 85-87%, 90-92%, and then 95-97% of the TTL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同時に、ネットワーク上の複数のマルチキャストDNSのクエリアケースを避けるために、すべての問題がそのクエリーを、クエリーが80から82パーセントで行うことが予定されているように、TTLは、追加すべきレコードの2％のランダムばらつき、85から87パーセント、90から92パーセント、及び次いでTTLの95から97パーセント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An additional efficiency optimization SHOULD be performed when a Multicast DNS response is received containing a unique answer (as indicated by the cache-flush bit being set, described in Section 10.2, &#34;Announcements to Flush Outdated Cache Entries&#34;). In this case, there is no need for the querier to continue issuing a stream of queries with exponentially increasing intervals, since the receipt of a unique answer is a good indication that no other answers will be forthcoming. In this case, the Multicast DNS querier SHOULD plan to issue its next query for this record at 80-82% of the record&#39;s TTL, as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答を一意回答（キャッシュフラッシュビットがセットされることによって示されるように、セクション10.2に記載され、「古いキャッシュエントリをフラッシュするお知らせ」）を含む受信されたときに、追加の効率の最適化を行うべきです。この場合には、ユニークな答えの領収書は、他の答えが来ることはないだろうということは良い兆候であることからクエリアは、指数関数的に増加する間隔でのクエリのストリームを発行継続するために必要はありません。この場合、マルチキャストDNSクエリアは、上述したように、レコードのTTLの80から82パーセントで、このレコードのその次のクエリを発行することを計画してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A compliant Multicast DNS querier, which implements the rules specified in this document, MUST send its Multicast DNS queries from UDP source port 5353 (the well-known port assigned to mDNS), and MUST listen for Multicast DNS replies sent to UDP destination port 5353 at the mDNS link-local multicast address (224.0.0.251 and/or its IPv6 equivalent FF02::FB).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書で指定されたルールを実装対応のマルチキャストDNSクエリアは、UDPソースポート5353（mDNSのに割り当てられたwell-knownポート）からそのマルチキャストDNSクエリを送信しなければならない、とUDP宛先ポート5353に送信された返信のマルチキャストDNSをリッスンしなければなりませんmDNSのリンクローカルマルチキャストアドレス（224.0.0.251および/またはそのIPv6の同等FF02 :: FB）で。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Multiple Questions per Query
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3。クエリごとに複数の質問
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS allows a querier to place multiple questions in the Question Section of a single Multicast DNS query message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSは、クエリアが、単一のマルチキャストDNSクエリメッセージの質問セクション内に複数の質問を配置することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The semantics of a Multicast DNS query message containing multiple questions is identical to a series of individual DNS query messages containing one question each. Combining multiple questions into a single message is purely an efficiency optimization and has no other semantic significance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の質問を含むマルチキャストDNSクエリメッセージの意味論は一つの質問をそれぞれ含む個々のDNSクエリ一連のメッセージと同じです。単一のメッセージに複数の質問を組み合わせることで、純粋に効率の最適化であり、他のセマンティックな意味を持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Questions Requesting Unicast Responses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4。ユニキャスト応答を要求する質問
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sending Multicast DNS responses via multicast has the benefit that all the other hosts on the network get to see those responses, enabling them to keep their caches up to date and detect conflicting responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャスト経由でマルチキャストDNS応答を送信すると、ネットワーク上の他のすべてのホストが最新のそれらのキャッシュを維持し、競合応答を検出するためにそれらを可能に、それらの回答を見ることが利益を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, there are situations where all the other hosts on the network don&#39;t need to see every response. Some examples are a laptop computer waking from sleep, the Ethernet cable being connected to a running machine, or a previously inactive interface being activated through a configuration change. At the instant of wake-up or link activation, the machine is a brand new participant on a new network. Its Multicast DNS cache for that interface is empty, and it has no knowledge of its peers on that link. It may have a significant number of questions that it wants answered right away, to discover information about its new surroundings and present that information to the user. As a new participant on the network, it has no idea whether the exact same questions may have been asked and answered just seconds ago. In this case, triggering a large sudden flood of multicast responses may impose an unreasonable burden on the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、ネットワーク上の他のすべてのホストは、すべての応答を確認する必要がない状況があります。いくつかの例は、スリープ状態から目覚め、ラップトップコンピュータ、ランニングマシン、または構成の変更を介して活性化される以前に非アクティブなインタフェースに接続されているイーサネットケーブルです。ウェイクアップまたはリンク活性化の瞬間に、マシンが新しいネットワーク上のブランドの新しい参加者です。そのインターフェイスのためのそのマルチキャストDNSキャッシュが空であり、それはそのリンク上のピアの知識を持ちません。それは、その新しい環境についての情報を発見し、その情報をユーザーに提示するために、それはすぐに答えて欲しい質問のかなりの数を有することができます。ネットワーク上の新しい参加者として、それはまったく同じ質問を尋ねたとわずか数秒前に回答されているかどうかわかりません。この場合、マルチキャスト応答の大きな突然の洪水をトリガすると、ネットワーク上の不当な負担を課すことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To avoid large floods of potentially unnecessary responses in these cases, Multicast DNS defines the top bit in the class field of a DNS question as the unicast-response bit. When this bit is set in a question, it indicates that the querier is willing to accept unicast replies in response to this specific query, as well as the usual multicast responses. These questions requesting unicast responses are referred to as &#34;QU&#34; questions, to distinguish them from the more usual questions requesting multicast responses (&#34;QM&#34; questions). A Multicast DNS querier sending its initial batch of questions immediately on wake from sleep or interface activation SHOULD set the unicast-response bit in those questions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのケースでは、潜在的に不要応答の大洪水を避けるために、マルチキャストDNSは、ユニキャスト応答ビットとしてDNS質問のクラスフィールドでトップビットを定義します。このビットが疑問に設定されている場合は、クエリアが、この特定のクエリに応じて、ユニキャストの回答だけでなく、通常のマルチキャスト応答を受け入れることを望んでいることを示しています。ユニキャスト応答を要求するこれらの質問は、マルチキャスト回答（「QM」の質問に）要求する、より一般的な質問と区別するために、「QU」の質問と呼ばれています。スリープまたはインタフェースの活性化からすぐにウェイク上の質問のその最初のバッチを送信するマルチキャストDNSクエリアは、これらの質問には、ユニキャスト応答ビットを設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a question is retransmitted (as described in Section 5.2), the unicast-response bit SHOULD NOT be set in subsequent retransmissions of that question. Subsequent retransmissions SHOULD be usual &#34;QM&#34; questions. After the first question has received its responses, the querier should have a large Known-Answer list (Section 7.1) so that subsequent queries should elicit few, if any, further responses. Reverting to multicast responses as soon as possible is important because of the benefits that multicast responses provide (see Appendix D). In addition, the unicast-response bit SHOULD be set only for questions that are active and ready to be sent the moment of wake from sleep or interface activation. New questions created by local clients afterwards should be treated as normal &#34;QM&#34; questions and SHOULD NOT have the unicast-response bit set on the first question of the series.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（第5.2節に記載されているように）質問が再送信されたときに、ユニキャスト応答ビットは、その質問の後続の再送信で設定しないでください。後続の再送信は、通常の「QM」の質問であるべきです。最初の質問は、そのレスポンスを受信した後、後続のクエリがいくつか、もしあれば、さらに応答を引き出す必要があるように、クエリアは大既知解リスト（7.1節）を持っている必要があります。できるだけ早くマルチキャスト応答に戻すこと（付録Dを参照）ので、マルチキャスト応答が提供する利点の重要です。また、ユニキャスト応答ビットは、アクティブ及びスリープ又は界面活性から覚醒の瞬間を送信する準備ができている質問に設定されるべきです。ローカルクライアントによって作成された新しい質問はその後、通常の「QM」の質問として扱われるべきとシリーズの最初の質問に設定されたユニキャスト応答ビットを持つべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When receiving a question with the unicast-response bit set, a responder SHOULD usually respond with a unicast packet directed back to the querier. However, if the responder has not multicast that record recently (within one quarter of its TTL), then the responder SHOULD instead multicast the response so as to keep all the peer caches up to date, and to permit passive conflict detection. In the case of answering a probe question (Section 8.1) with the unicast-response bit set, the responder should always generate the requested unicast response, but it may also send a multicast announcement if the time since the last multicast announcement of that record is more than a quarter of its TTL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユニキャスト応答ビットがセットされた質問を受信すると、レスポンダは通常、バッククエリアに向けたユニキャストパケットで応答する必要があります。応答者が最近そのレコードをマルチキャストしていない場合は、日付までのすべてのピアキャッシュを維持するために、パッシブ競合の検出を可能にするように、しかし、（そのTTLの四分の一以内）、その後、応答者が代わりに応答をマルチキャストすべきです。ユニキャスト応答ビットが設定されたプローブの質問（8.1節）を答えるの場合は、応答者は常に要求されたユニキャスト応答を生成する必要がありますが、そのレコードの最後のマルチキャストの発表以来、時間があれば、それはまた、マルチキャストアナウンスを送信することができそのTTLの4分の1以上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unicast replies are subject to all the same packet generation rules as multicast replies, including the cache-flush bit (Section 10.2) and (except when defending a unique name against a probe from another host) randomized delays to reduce network collisions (Section 6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユニキャスト応答は、ネットワーク衝突を低減するための遅延（別のホストからのプローブに対して一意の名前を守る場合を除く）キャッシュフラッシュビット（セクション10.2）を含むマルチキャスト応答、すべて同じパケット生成ルールに従うランダム化され（第6節） 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Direct Unicast Queries to Port 5353
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5。ポート5353への直接ユニキャストクエリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In specialized applications there may be rare situations where it makes sense for a Multicast DNS querier to send its query via unicast to a specific machine. When a Multicast DNS responder receives a query via direct unicast, it SHOULD respond as it would for &#34;QU&#34; questions, as described above in Section 5.4. Since it is possible for a unicast query to be received from a machine outside the local link, responders SHOULD check that the source address in the query packet matches the local subnet for that link (or, in the case of IPv6, the source address has an on-link prefix) and silently ignore the packet if not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特殊なアプリケーションでは、マルチキャストDNSクエリアは、特定のマシンにユニキャストを経由してそのクエリを送信することは理にかなっているまれな状況があるかもしれません。マルチキャストDNS応答者が直接ユニキャストクエリを受信すると、それは「QU」の質問の場合と同じように、セクション5.4で前述したように、それは、応答する必要があります。それはローカルリンク外部機器から受信するユニキャストクエリことが可能であるので、応答は、クエリパケットの送信元アドレスがIPv6の場合には、そのリンクのローカルサブネットに一致する（または、送信元アドレスが持っていることを確認する必要がありますオンリンク接頭辞）と黙っていない場合はパケットを無視します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There may be specialized situations, outside the scope of this document, where it is intended and desirable to create a responder that does answer queries originating outside the local link. Such a responder would need to ensure that these non-local queries are always answered via unicast back to the querier, since an answer sent via link-local multicast would not reach a querier outside the local link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ローカルリンク外からのクエリに応答し、応答を作成することを目的と望ましい。この文書の範囲外の特殊な状況で、あるかもしれません。リンクローカルマルチキャストを経由して送信された答えはローカルリンク外クエリアに達しないため、このような応答は、これらの非ローカルクエリは常にバッククエリアにユニキャストで答えていることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Responding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.対応
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a Multicast DNS responder constructs and sends a Multicast DNS response message, the Resource Record Sections of that message must contain only records for which that responder is explicitly authoritative. These answers may be generated because the record answers a question received in a Multicast DNS query message, or at certain other times that the responder determines than an unsolicited announcement is warranted. A Multicast DNS responder MUST NOT place records from its cache, which have been learned from other responders on the network, in the Resource Record Sections of outgoing response messages. Only an authoritative source for a given record is allowed to issue responses containing that record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答構築物およびマルチキャストDNS応答メッセージを送信すると、そのメッセージのリソースレコードセクションは、応答者が明示的に権限を持つレコードだけが含まれている必要があります。レコードがマルチキャストDNSクエリメッセージで受信した質問に答える、または特定の他の時に応答が求められていない発表が保証されているよりも判断したため、これらの答えを生成してもよいです。マルチキャストDNS応答者は、発信応答メッセージのリソースレコードのセクションでは、ネットワーク上の他のレスポンダから学習されたそのキャッシュからレコードを配置してはならず。特定のレコードの唯一の信頼できるソースは、そのレコードを含む応答を発行することを許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The determination of whether a given record answers a given question is made using the standard DNS rules: the record name must match the question name, the record rrtype must match the question qtype unless the qtype is &#34;ANY&#34; (255) or the rrtype is &#34;CNAME&#34; (5), and the record rrclass must match the question qclass unless the qclass is &#34;ANY&#34; (255). As with Unicast DNS, generally only DNS class 1 (&#34;Internet&#34;) is used, but should client software use classes other than 1, the matching rules described above MUST be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
与えられたレコードが与えられた質問に答えるかどうかの決意は、標準的なDNS規則を使用して行われますレコード名は、質問名と一致する必要があり、QTYPEが「ANY」でない限り、レコードrrtypeは、（255）質問QTYPEと一致する必要がありますかrrtypeです&#34;CNAME&#34;（5）、およびQCLASSは &#34;ANY&#34;（255）である場合を除き、レコードrrclassは、質問のQCLASSと一致する必要があります。ユニキャストDNSと同様に、一般のみDNSクラス1（「インターネット」）が使用されるが、1以外のクライアントソフトウェア使用のクラスは、上記のマッチング規則が使用されなければならないべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Multicast DNS responder MUST only respond when it has a positive, non-null response to send, or it authoritatively knows that a particular record does not exist. For unique records, where the host has already established sole ownership of the name, it MUST return negative answers to queries for records that it knows not to exist. For example, a host with no IPv6 address, that has claimed sole ownership of the name &#34;host.local.&#34; for all rrtypes, MUST respond to AAAA queries for &#34;host.local.&#34; by sending a negative answer indicating that no AAAA records exist for that name. See Section 6.1, &#34;Negative Responses&#34;. For shared records, which are owned by no single host, the nonexistence of a given record is ascertained by the failure of any machine to respond to the Multicast DNS query, not by any explicit negative response. For shared records, NXDOMAIN and other error responses MUST NOT be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それが送信するために、正、null以外の応答を持っている場合、マルチキャストDNS応答のみが応答しなければならない、またはそれが正式に特定のレコードが存在しないことを知っています。ホストがすでに名の唯一の所有権を確立した独自の記録については、それが存在しないことを知っていたレコードのクエリへの否定応答を返さなければなりません。たとえば、名前の唯一の所有権主張していないIPv6アドレスを持つホスト「host.localを。」すべてrrtypesのために、ためにAAAAクエリに応答しなければならない「host.local。」送信することにより、負の答えはノーAAAAレコードはその名前のために存在しないことを示しています。 6.1節、「否定応答」を参照してください。単一のホストによって所有されている共有の記録については、与えられたレコードが存在しないはない明示的な否定応答により、マルチキャストDNSクエリに対応するための任意のマシンの障害によって確認されます。共有レコードの場合、NXDOMAINおよびその他のエラー応答を送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS responses MUST NOT contain any questions in the Question Section. Any questions in the Question Section of a received Multicast DNS response MUST be silently ignored. Multicast DNS queriers receiving Multicast DNS responses do not care what question elicited the response; they care only that the information in the response is true and accurate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答は、質問セクション内の任意の質問を含めることはできません。受信マルチキャストDNS応答の質問セクションでのご質問は黙って無視しなければなりません。マルチキャストDNSの応答を受信マルチキャストDNSのクエリアは、応答を誘発何の問題を気にしません。彼らは、応答内の情報が真実かつ正確であることだけを気に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Multicast DNS responder on Ethernet [IEEE.802.3] and similar shared multiple access networks SHOULD have the capability of delaying its responses by up to 500 ms, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
イーサネット【IEEE.802.3]と同様の共有複数のアクセスネットワークのマルチキャストDNS応答は、以下に説明するように、最大​​500ミリ秒の応答を遅延させる能力を有するべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a large number of Multicast DNS responders were all to respond immediately to a particular query, a collision would be virtually guaranteed. By imposing a small random delay, the number of collisions is dramatically reduced. On a full-sized Ethernet using the maximum cable lengths allowed and the maximum number of repeaters allowed, an Ethernet frame is vulnerable to collisions during the transmission of its first 256 bits. On 10 Mb/s Ethernet, this equates to a vulnerable time window of 25.6 microseconds. On higher-speed variants of Ethernet, the vulnerable time window is shorter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSの応答者の大多数は、特定のクエリに即座に対応するために、すべてだった場合、衝突が事実上保証されるだろう。小さなランダム遅延を課すことで、衝突の数が劇的に減少しています。許容される最大ケーブル長を使用してフルサイズのイーサネットおよび許容リピータの最大数に、イーサネットフレームは、その最初の256ビットの伝送中に衝突に対して脆弱です。 10 MB / sのイーサネットに、これは、25.6マイクロ秒の脆弱な時間窓に相当します。イーサネットの高速バリアントでは、脆弱な時間ウィンドウは短くなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case where a Multicast DNS responder has good reason to believe that it will be the only responder on the link that will send a response (i.e., because it is able to answer every question in the query message, and for all of those answer records it has previously verified that the name, rrtype, and rrclass are unique on the link), it SHOULD NOT impose any random delay before responding, and SHOULD normally generate its response within at most 10 ms. In particular, this applies to responding to probe queries with the unicast-response bit set. Since receiving a probe query gives a clear indication that some other responder is planning to start using this name in the very near future, answering such probe queries to defend a unique record is a high priority and needs to be done without delay. A probe query can be distinguished from a normal query by the fact that a probe query contains a proposed record in the Authority Section that answers the question in the Question Section (for more details, see Section 8.2, &#34;Simultaneous Probe Tiebreaking&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クエリメッセージ内のすべての質問に答えることができるので、マルチキャストDNS応答者は、それはすなわち、応答を（送信しますリンク上でのみ応答になると信じる十分な理由がある場合には、それらの答えのすべてについてそれは以前に名前、rrtype、およびrrclass）は、リンク上で一意であることを確認したレコードは、それが応答する前に、任意のランダムな遅延を課してはならず、通常は最大で10ミリ秒内にその応答を生成する必要があります。特に、これは、ユニキャスト応答ビットが設定されたクエリをプローブする応答に適用されます。プローブクエリを受信すると、他のいくつかのレスポンダが非常に近い将来にこの名前を使用して起動することを計画していることを明らかに示しを与えるので、一意のレコードを守るために、このようなプローブの問い合わせに答えることは高い優先度で、遅滞なく行われる必要があります。プローブクエリがプローブクエリが質問セクションで質問に答える権限節で提案したレコードが含まれているという事実によって、通常のクエリと区別することができます（詳細は、8.2節を参照してください、「同時プローブタイブレイク」）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Responding without delay is appropriate for records like the address record for a particular host name, when the host name has been previously verified unique. Responding without delay is *not* appropriate for things like looking up PTR records used for DNS-Based Service Discovery [RFC6763], where a large number of responses may be anticipated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
遅滞なく対応することは、ホスト名は以前にユニーク検証された特定のホスト名のアドレスレコードなどの記録に適しています。遅滞なく対応することは* *多数の応答が予想されるDNSベースのサービスディスカバリー[RFC6763]のために使用されるPTRレコードを探しているようなものには適していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In any case where there may be multiple responses, such as queries where the answer is a member of a shared resource record set, each responder SHOULD delay its response by a random amount of time selected with uniform random distribution in the range 20-120 ms. The reason for requiring that the delay be at least 20 ms is to accommodate the situation where two or more query packets are sent back-to-back, because in that case we want a responder with answers to more than one of those queries to have the opportunity to aggregate all of its answers into a single response message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このような答えが共有リソースレコードセットのメンバであるクエリなど複数の応答が存在し得るいずれの場合においても、各レスポンダは範囲20〜120ミリ秒で一様ランダムに分布して選択された時間のランダムな量だけその応答を遅らせるべきです。その場合には、我々はこれらのクエリの複数の答えと応答者が持ちたいので、遅延が20ms以上であることが必要な理由は、二つ以上のクエリーパケットを背中合わせに送信されている状況に対応するためにあります単一の応答メッセージにその答えのすべてを集約する機会。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case where the query has the TC (truncated) bit set, indicating that subsequent Known-Answer packets will follow, responders SHOULD delay their responses by a random amount of time selected with uniform random distribution in the range 400-500 ms, to allow enough time for all the Known-Answer packets to arrive, as described in Section 7.2, &#34;Multipacket Known-Answer Suppression&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クエリが続くその後の既知の回答パケットは、応答者がに、範囲400〜500ミリ秒で一様ランダムに分布して選択された時間のランダムな量だけそれらの応答を遅らせる必要があることを示す、ビットセット（切り捨て）TCを有する場合第7.2項「マルチパケット既知解抑制」で説明したように、すべての既知解パケットが到着するのに十分な時間をかけて。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The source UDP port in all Multicast DNS responses MUST be 5353 (the well-known port assigned to mDNS). Multicast DNS implementations MUST silently ignore any Multicast DNS responses they receive where the source UDP port is not 5353.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのマルチキャストDNS応答の送信元UDPポートは5353（のmDNSに割り当てられたwell-knownポート）でなければなりません。マルチキャストDNSの実装は静かに元UDPポートが5353でない場合、彼らが受け取る任意のマルチキャストDNS応答を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The destination UDP port in all Multicast DNS responses MUST be 5353, and the destination address MUST be the mDNS IPv4 link-local multicast address 224.0.0.251 or its IPv6 equivalent FF02::FB, except when generating a reply to a query that explicitly requested a unicast response:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのマルチキャストDNS応答の宛先UDPポートは5353でなければならない、と宛先アドレスはmDNSのIPv4リンクローカルマルチキャストアドレス224.0.0.251または明示的に要求クエリに対する応答を生成する場合を除き、そのIPv6の同等FF02 :: FB、でなければなりませんユニキャスト応答：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* via the unicast-response bit, * by virtue of being a legacy query (Section 6.7), or * by virtue of being a direct unicast query.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*直接ユニキャストクエリさのおかげで、従来のクエリ（6.7節）、または*であることのおかげで*、ユニキャスト応答ビットを介し。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Except for these three specific cases, responses MUST NOT be sent via unicast, because then the &#34;Passive Observation of Failures&#34; mechanisms described in Section 10.5 would not work correctly. Other
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その後、「障害の受動的観察」は10.5節で説明したメカニズムが正常に動作しないため、これらの3つの特定の場合を除き、応答は、ユニキャスト経由で送ってはいけません。他の
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
benefits of sending responses via multicast are discussed in Appendix D. A Multicast DNS querier MUST only accept unicast responses if they answer a recently sent query (e.g., sent within the last two seconds) that explicitly requested unicast responses. A Multicast DNS querier MUST silently ignore all other unicast responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストを介した応答を送信することの利点は、彼らが最近送信されたクエリに答える場合にのみ、ユニキャスト応答を受け入れなければならクエリア付録D. AマルチキャストDNSで議論されている（例えば、最後の2秒以内に送信）、明示的にユニキャスト応答を要求しています。マルチキャストDNSクエリアは黙って他のすべてのユニキャスト応答を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To protect the network against excessive packet flooding due to software bugs or malicious attack, a Multicast DNS responder MUST NOT (except in the one special case of answering probe queries) multicast a record on a given interface until at least one second has elapsed since the last time that record was multicast on that particular interface. A legitimate querier on the network should have seen the previous transmission and cached it. A querier that did not receive and cache the previous transmission will retry its request and receive a subsequent response. In the special case of answering probe queries, because of the limited time before the probing host will make its decision about whether or not to use the name, a Multicast DNS responder MUST respond quickly. In this special case only, when responding via multicast to a probe, a Multicast DNS responder is only required to delay its transmission as necessary to ensure an interval of at least 250 ms since the last time the record was multicast on that interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
少なくとも一つの第二が経過するまでによるソフトウェアのバグまたは悪質な攻撃に過度のパケットフラッディングに対してネットワークを保護するには、マルチキャストDNSの応答は、（プローブの問い合わせに答えるの一つの特別な場合を除いて）指定されたインターフェイス上のレコードをマルチキャストてはなりませんレコードは、その特定のインターフェイス上でマルチキャストされたことを最後の時間。ネットワーク上の正当なクエリアは前回の送信を見て、それをキャッシュしている必要があります。前回の送信を受信し、キャッシュしませんでしたクエリアはその要求を再試行し、その後の応答を受信します。なぜなら、プロービングホストが名前を使用するかどうかについての決定を行います前に、限られた時間で、プローブの問い合わせに答えるの特殊なケースでは、マルチキャストDNSの応答が迅速に対応しなければなりません。プローブにマルチキャストを介して応答するときに、この特別な場合にのみ、マルチキャストDNS応答のみレコードがそのインターフェイス上でマルチキャストされた前回の少なくとも250ミリ秒の間隔を確保するために、必要に応じてその送信を遅延させるために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Negative Responses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1。否定的な反応
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the early design of Multicast DNS it was assumed that explicit negative responses would never be needed. A host can assert the existence of the set of records that it claims to exist, and the union of all such sets on a link is the set of Multicast DNS records that exist on that link. Asserting the nonexistence of every record in the complement of that set -- i.e., all possible Multicast DNS records that could exist on this link but do not at this moment -- was felt to be impractical and unnecessary. The nonexistence of a record would be ascertained by a querier querying for it and failing to receive a response from any of the hosts currently attached to the link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSの初期の設計では、明示的な否定的な反応を必要とすることはないだろうと仮定しました。ホストは、それが存在すると主張するレコードのセットの存在を主張することができ、およびリンク上のすべてのようなセットの労働組合は、そのリンク上に存在するマルチキャストDNSレコードのセットです。そのセットの補数のすべてのレコードが存在しないことを主張する - すなわち、このリンク上に存在するが、現時点ではない可能性のあるすべてのマルチキャストDNSレコードは - 非現実的かつ不必要であることを感じました。レコードの有無をクエリアそれを照会し、現在のリンクに接続されたホストのいずれかから応答を受信することができないことによって確認されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, operational experience showed that explicit negative responses can sometimes be valuable. One such example is when a querier is querying for a AAAA record, and the host name in question has no associated IPv6 addresses. In this case, the responding host knows it currently has exclusive ownership of that name, and it knows that it currently does not have any IPv6 addresses, so an explicit negative response is preferable to the querier having to retransmit its query multiple times, and eventually give up with a timeout, before it can conclude that a given AAAA record does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、運用経験は、明示的な否定的な反応が時々価値があることを示しました。クエリアがAAAAレコードを照会されたときにその一例であり、問​​題のホスト名には関連付けられているIPv6アドレスを持っていません。この場合、応答のホストは、現在その名前の排他的な所有権を持って知っている、そしてそれは、現在、IPv6アドレスを持っていないことを知っているので、明示的な否定応答は、そのクエリを複数回再送信する必要がクエリアに好ましく、最終的にそれは与えられたAAAAレコードが存在しないと結論付けることができます前に、タイムアウトをあきらめます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any time a responder receives a query for a name for which it has verified exclusive ownership, for a type for which that name has no records, the responder MUST (except as allowed in (a) below) respond asserting the nonexistence of that record using a DNS NSEC record [RFC4034]. In the case of Multicast DNS the NSEC record is not being used for its usual DNSSEC [RFC4033] security properties, but simply as a way of expressing which records do or do not exist with a given name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答者は、それがその名前にレコードを持たないためにタイプのために、排他的な所有権を検証しているの名前のクエリを受け取るときはいつでも、（以下の（a）に認められている場合を除き）レスポンダーMUSTは使用してそのレコードが存在しないことを主張対応しますDNS NSECレコード[RFC4034]。マルチキャストの場合にNSECレコードは、その通常のDNSSEC [RFC4033]のセキュリティ特性のために使用されていないDNS、単に実行または与えられた名前で存在しないレコードを表現する方法として。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On receipt of a question for a particular name, rrtype, and rrclass, for which a responder does have one or more unique answers, the responder MAY also include an NSEC record in the Additional Record Section indicating the nonexistence of other rrtypes for that name and rrclass.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答者が一の以上のユニークな答えを持っていたために特定の名前、rrtype、およびrrclassへの質問、を受信すると、レスポンダはまた、追加の記録部にNSECレコードを含むことができることが名の他rrtypesが存在しないことを示すと、 rrclass。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementers working with devices with sufficient memory and CPU resources MAY choose to implement code to handle the full generality of the DNS NSEC record [RFC4034], including bitmaps up to 65,536 bits long. To facilitate use by devices with limited memory and CPU resources, Multicast DNS queriers are only REQUIRED to be able to parse a restricted form of the DNS NSEC record. All compliant Multicast DNS implementations MUST at least correctly generate and parse the restricted DNS NSEC record format described below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
十分なメモリとCPUリソースを持つデバイスを使用する実装者は、最大65,536ビット長のビットマップを含むDNS NSECレコード[RFC4034]の完全な一般性を処理するコードを実装することを選択できます。限られたメモリやCPUリソースを持つデバイスで使用することを容易にするために、マルチキャストDNSクエリアは、唯一のDNS NSECレコードの制限された形を解析することができるようするために必要とされています。すべての準拠したマルチキャストDNSの実装は、少なくとも正常に下記の制限されたDNS NSECレコード形式を生成し、解析する必要があります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The &#39;Next Domain Name&#39; field contains the record&#39;s own name. When used with name compression, this means that the &#39;Next Domain Name&#39; field always takes exactly two bytes in the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O「次のドメイン名」フィールドは、レコードの自身の名前が含まれています。名前の圧縮で使用する場合、これは「次のドメイン名」フィールドは常にメッセージに正確に2つのバイトをとることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The Type Bit Map block number is 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O型のビットマップブロック番号は0です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The Type Bit Map block length byte is a value in the range 1-32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O型ビットマップブロック長のバイトは1〜32の範囲内の値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The Type Bit Map data is 1-32 bytes, as indicated by length byte.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O型ビットマップデータは、長さバイトで示されるように、1〜32バイトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because this restricted form of the DNS NSEC record is limited to Type Bit Map block number zero, it cannot express the existence of rrtypes above 255. Consequently, if a Multicast DNS responder were to have records with rrtypes above 255, it MUST NOT generate these restricted-form NSEC records for those names, since to do so would imply that the name has no records with rrtypes above 255, which would be false. In such cases a Multicast DNS responder MUST either (a) emit no NSEC record for that name, or (b) emit a full NSEC record containing the appropriate Type Bit Map block(s) with the correct bits set for all the record types that exist. In practice this is not a significant limitation, since rrtypes above 255 are not currently in widespread use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS NSECレコードのこの制限されたフォームは、ビットマップブロック番号ゼロを入力するために限られているので、それはそれは、これらを生成してはならない、マルチキャストDNS応答が255を超えるrrtypesのレコードを持っていた場合、結果的に255以上のrrtypesの存在を表現することはできませんそれらの名前のために制限された形式NSECレコード、そうするため、偽されるであろう、名前は255以上rrtypesではレコードを持っていないことを意味します。このような場合には、マルチキャストDNS応答は、（a）はその名前のためのNSECレコードを放出しない、または（b）その全てのレコードタイプに設定正しいビットで適切なタイプビットマップブロック（単数または複数）を含む完全NSECレコードを放出しなければならないのいずれかでが存在します。 255以上のrrtypesは、現在広く普及していないので、実際には、これは、重要な制限ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a Multicast DNS implementation receives an NSEC record where the &#39;Next Domain Name&#39; field is not the record&#39;s own name, then the implementation SHOULD ignore the &#39;Next Domain Name&#39; field and process the remainder of the NSEC record as usual. In Multicast DNS the &#39;Next Domain Name&#39; field is not currently used, but it could be used in a future version of this protocol, which is why a Multicast DNS implementation MUST NOT reject or ignore an NSEC record it receives just because it finds an unexpected value in the &#39;Next Domain Name&#39; field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSの実装では、「次へドメイン名」フィールドは、レコードの自身の名前ではありませんNSECレコードを受信した場合、その実装は、「次へドメイン名」フィールドを無視して、いつものようにNSECレコードの残りの部分を処理しなければなりません。マルチキャストDNSで「次へドメイン名」フィールドは、現在使用されていませんが、それはマルチキャストDNSの実装では、それが見つかったからといって、それが受信するNSECレコードを拒否または無視してはならない理由は、このプロトコルの将来のバージョンで使用することができ「次へドメイン名」フィールドに、予期しない値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a Multicast DNS implementation receives an NSEC record containing more than one Type Bit Map, or where the Type Bit Map block number is not zero, or where the block length is not in the range 1-32, then the Multicast DNS implementation MAY silently ignore the entire NSEC record. A Multicast DNS implementation MUST NOT ignore an entire message just because that message contains one or more NSEC record(s) that the Multicast DNS implementation cannot parse. This provision is to allow future enhancements to the protocol to be introduced in a backwards-compatible way that does not break compatibility with older Multicast DNS implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSの実装では、複数のタイプのビットマップ、又はここタイプビットマップブロック数がゼロでない場合、またはブロック長は範囲1-32でない場合、次に、マルチキャストDNS実装がサイレントMAYを含むNSECレコードを受信した場合全体NSECレコードを無視します。マルチキャストDNSの実装では、そのメッセージは、マルチキャストDNS実装が解析できないことを一つ以上のNSECレコード（複数可）を含んでいるという理由だけで全体のメッセージを無視してはいけません。この規定は、プロトコルへの将来の拡張は、古いマルチキャストDNSの実装との互換性を破壊しない後方互換性のある方法で導入できるようにすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To help differentiate these synthesized NSEC records (generated programmatically on-the-fly) from conventional Unicast DNS NSEC records (which actually exist in a signed DNS zone), the synthesized Multicast DNS NSEC records MUST NOT have the NSEC bit set in the Type Bit Map, whereas conventional Unicast DNS NSEC records do have the NSEC bit set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（実際に署名されたDNSゾーンに存在する）は、従来のユニキャストDNS NSEC記録から（オンザフライプログラムで生成された）これらの合成NSECレコードを区別するために役立つ、NSECを有してはならない合成マルチキャストDNS NSECレコードは、タイプビットにビットセット地図、従来のユニキャストDNS NSECレコードは、NSECビットセットを持っているのに対し。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TTL of the NSEC record indicates the intended lifetime of the negative cache entry. In general, the TTL given for an NSEC record SHOULD be the same as the TTL that the record would have had, had it existed. For example, the TTL for address records in Multicast DNS is typically 120 seconds (see Section 10), so the negative cache lifetime for an address record that does not exist should also be 120 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NSECレコードのTTLは、負のキャッシュエントリの意図した寿命を示しています。一般的には、NSECレコードに指定されたTTLは、レコードがなければなりませんでしたTTLと同じにする必要があり、それが存在していました。例えば、マルチキャストDNSのアドレスレコードのTTLは、典型的には、120秒（セクション10を参照）であるので、存在しないアドレスのレコードの負のキャッシュの有効期間も120秒であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A responder MUST only generate negative responses to queries for which it has legitimate ownership of the name, rrtype, and rrclass in question, and can legitimately assert that no record with that name, rrtype, and rrclass exists. A responder can assert that a specified rrtype does not exist for one of its names if it knows a priori that it has exclusive ownership of that name (e.g., names of reverse address mapping PTR records, which are derived from IP addresses, which should be unique on the local link) or if it previously claimed unique ownership of that name using probe queries for rrtype &#34;ANY&#34;. (If it were to use probe queries for a specific rrtype, then it would only own the name for that rrtype, and could not assert that other rrtypes do not exist.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答者は、それが問題の名前、rrtype、およびrrclassの合法的な所有権を持っているクエリへの否定的な反応を発生させなければなりませんし、合法的にその名前、rrtype、およびrrclass持つレコードが存在しないと主張することができます。応答者は、それがあるべきその名前の排他的所有権（IPアドレスから導出されている逆アドレスマッピングPTRレコードの例えば、名前を持っていることを先験的に知っている場合、指定rrtypeはその名のいずれかのために存在していないと主張することができますローカルリンク上で一意）、またはそれ以前に「ANY」rrtype用プローブのクエリを使用してその名前のユニークな所有権を主張している場合。 （それは特定のrrtypeためのプローブクエリを使用した場合、それだけでそのrrtypeの名前を所有し、かつ他のrrtypesが存在しないことを主張することができませんでした。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The design rationale for this mechanism for encoding negative responses is discussed further in Appendix E.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
否定応答を符号化するためのこの機構の設計原理は、付録Eにさらに議論されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Responding to Address Queries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2。クエリに対処するための対応
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a Multicast DNS responder sends a Multicast DNS response message containing its own address records, it MUST include all addresses that are valid on the interface on which it is sending the message, and MUST NOT include addresses that are not valid on that interface (such as addresses that may be configured on the host&#39;s other interfaces). For example, if an interface has both an IPv6 link-local and an IPv6 routable address, both should be included in the response message so that queriers receive both and can make their own choice about which to use. This allows a querier that only has an IPv6 link-local address to connect to the link-local address, and a different querier that has an IPv6 routable address to connect to the IPv6 routable address instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答者が、自身のアドレスレコードを含むマルチキャストDNS応答メッセージを送信すると、それは、メッセージを送信されているインターフェイス上で有効なすべてのアドレスを含まなければならない、そのインターフェイス上で有効でないアドレス（例えばを含んではいけません）ホストの他のインターフェイスに構成することができるアドレスとして。インタフェースは、IPv6リンクローカルおよびIPv6ルーティング可能なアドレスの両方を持っている場合クエリアは両方を受信し、使用についての自分の選択をすることができるように、例えば、両方のは、応答メッセージに含まれるべきです。これは、リンクローカルアドレスに接続するためのIPv6リンクローカルアドレスを持っているクエリア、代わりにIPv6のルーティング可能なアドレスに接続するためのIPv6ルーティング可能なアドレスを持つ別のクエリアすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a Multicast DNS responder places an IPv4 or IPv6 address record (rrtype &#34;A&#34; or &#34;AAAA&#34;) into a response message, it SHOULD also place any records of the other address type with the same name into the additional section, if there is space in the message. This is to provide fate sharing, so that all a device&#39;s addresses are delivered atomically in a single message, to reduce the risk that packet loss could cause a querier to receive only the IPv4 addresses and not the IPv6 addresses, or vice versa.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場合は、マルチキャストDNS応答の場所のIPv4またはIPv6アドレスレコード（rrtype「A」または「AAAA」）、応答メッセージの中に存在する場合、それはまた、追加のセクションに同じ名前を持つ他のアドレスタイプのすべてのレコードを配置する必要がありますメッセージ内のスペース。これは、すべてのデバイスのアドレスは、パケットロスがIPv4アドレスのみではなく、IPv6アドレス、またはその逆を受信するクエリアを引き起こす可能性があるというリスクを軽減するために、単一のメッセージでアトミックに配信されるように、運命の共有を提供することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the event that a device has only IPv4 addresses but no IPv6 addresses, or vice versa, then the appropriate NSEC record SHOULD be placed into the additional section, so that queriers can know with certainty that the device has no addresses of that kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クエリアは、デバイスがそのような種類のアドレスを有していないことを確実に知ることができるように、デバイスは、IPv4アドレスが、ないIPv6アドレス、またはその逆のみを有している場合に、適切なNSECレコードは、追加のセクションに配置されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some Multicast DNS responders treat a physical interface with both IPv4 and IPv6 address as a single interface with two addresses. Other Multicast DNS responders may treat this case as logically two interfaces (one with one or more IPv4 addresses, and the other with one or more IPv6 addresses), but responders that operate this way MUST NOT put the corresponding automatic NSEC records in replies they send (i.e., a negative IPv4 assertion in their IPv6 responses, and a negative IPv6 assertion in their IPv4 responses) because this would cause incorrect operation in responders on the network that work the former way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのマルチキャストDNSの応答は二つのアドレスを持つ単一のインタフェースとして、IPv4とIPv6の両方のアドレスを持つ物理インタフェースを扱います。他のマルチキャストDNSの応答は、論理的に二つのインタフェース（一個の以上のIPv6アドレスを持つ1つの以上のIPv4アドレスを持つ1、および他の）このケースを扱うことがありますが、このように動作応答は、彼らが送る応答で対応する自動NSECレコードを入れてはなりません（すなわち、そのIPv6の応答の負のIPv4主張し、そのIPv4の応答の負のIPv6アサーション）、これはかつてのように動作し、ネットワーク上のレスポンダに誤動作を引き起こすので。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Responding to Multiquestion Queries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3。 Multiquestionクエリへの対応
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS responders MUST correctly handle DNS query messages containing more than one question, by answering any or all of the questions to which they have answers. Unlike single-question queries, where responding without delay is allowed in appropriate cases, for query messages containing more than one question, all (non-defensive) answers SHOULD be randomly delayed in the range 20-120 ms, or 400-500 ms if the TC (truncated) bit is set. This is because when a query message contains more than one question, a Multicast DNS responder cannot generally be certain that other responders will not also be simultaneously generating answers to other questions in that query message. (Answers defending a name, in response to a probe for that name, are not subject to this delay rule and are still sent immediately.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSの応答が正しく、彼らが答えを持っている質問のいずれか、またはすべてに答えることによって、複数の質問を含むDNSクエリーメッセージを処理する必要があります。場合遅滞なく応答が適切な場合には許可されている単一の質問の問い合わせとは異なり、複数の質問を含むクエリメッセージに対して、すべての（非防御）の回答は、ランダム範囲20~120ミリ秒、又は400〜500ミリ秒で遅延されてくださいTC（切り捨て）ビットが設定されています。問い合わせメッセージは、複数の質問が含まれている場合、マルチキャストDNSの応答は一般的に他の応答も同時にそのクエリメッセージ内の他の質問への回答を生成しないことを確信することができないためです。 （その名前のためのプローブに応答して、名前を守る回答は、この遅延の規則の対象ではないと今でもすぐに送信されます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Response Aggregation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4。レスポンスの集約
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When possible, a responder SHOULD, for the sake of network efficiency, aggregate as many responses as possible into a single Multicast DNS response message. For example, when a responder has several responses it plans to send, each delayed by a different interval, then earlier responses SHOULD be delayed by up to an additional 500 ms if that will permit them to be aggregated with other responses scheduled to go out a little later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
可能な場合、応答者は、ネットワーク効率のために、単一のマルチキャストDNS応答メッセージにできるだけ多くの応答を集約すべきです。それは外出する予定の他の応答に集約されるためにそれらを可能にする場合たとえば、応答者はそれを送信するために計画し、いくつかの応答、異なる間隔によって遅延それぞれを持っている場合、その後、以前の応答は、追加の500ミリ秒までの遅れで表示されるべきである（SHOULD）少し後。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. Wildcard Queries (qtype &#34;ANY&#34; and qclass &#34;ANY&#34;)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5。ワイルドカードクエリ（QTYPE &#34;ANY&#34; &#34;ANY&#34; とQCLASS）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When responding to queries using qtype &#34;ANY&#34; (255) and/or qclass &#34;ANY&#34; (255), a Multicast DNS responder MUST respond with *ALL* of its records that match the query. This is subtly different from how qtype &#34;ANY&#34; and qclass &#34;ANY&#34; work in Unicast DNS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（255）「ANY」（255）「ANY」QTYPEを使用してクエリへの応答および/またはQCLASSすると、マルチキャストDNS応答は、クエリに一致するそのレコードの* ALL *で応じなければなりません。これは、ユニキャストDNSでどのQTYPE「ANY」とQCLASS「ANY」仕事から微妙に異なっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A common misconception is that a Unicast DNS query for qtype &#34;ANY&#34; will elicit a response containing all matching records. This is incorrect. If there are any records that match the query, the response is required only to contain at least one of them, not necessarily all of them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
よくある誤解は、QTYPEのためのユニキャストDNSクエリが「ANY」すべての一致するレコードを含む応答を誘発するということです。これは正しくありません。クエリに一致するすべてのレコードがある場合は、応答が唯一のそれらの少なくとも1つ、必ずしもそれらのすべてを含有することが要求されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This somewhat surprising behavior is commonly seen with caching (i.e., &#34;recursive&#34;) name servers. If a caching server receives a qtype &#34;ANY&#34; query for which it has at least one valid answer, it is allowed to return only those matching answers it happens to have already in its cache, and it is not required to reconsult the authoritative name server to check if there are any more records that also match the qtype &#34;ANY&#34; query.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このやや意外な行動は、一般的に、キャッシング（すなわち、「再帰」）ネームサーバと見られています。キャッシュサーバは、それが少なくとも1つの有効な答えを持っている「ANY」クエリをQTYPEを受信した場合、そのキャッシュにすでに持っているために起こるものだけ一致する答えを返すことが許可され、権威ネームサーバをreconsultする必要はありませんまた、QTYPE「ANY」クエリに一致する複数のレコードがあるかどうかを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, one might imagine that a query for qtype &#34;ANY&#34; for name &#34;host.example.com&#34; would return both the IPv4 (A) and the IPv6 (AAAA) address records for that host. In reality, what happens is that it depends on the history of what queries have been previously received by intervening caching servers. If a caching server has no records for &#34;host.example.com&#34;, then it will consult another server (usually the authoritative name server for the name in question), and, in that case, it will typically return all IPv4 and IPv6 address records. However, if some other host has recently done a query for qtype &#34;A&#34; for name &#34;host.example.com&#34;, so that the caching server already has IPv4 address records for &#34;host.example.com&#34; in its cache but no IPv6 address records, then it will return only the IPv4 address records it already has cached, and no IPv6 address records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、一つは「ANY」名QTYPEのクエリ「host.example.com」はIPv4の（A）と、そのホストのIPv6（AAAA）アドレスレコードの両方を返すだろうと想像するかもしれません。実際には、何が起こるか、それはクエリが以前にキャッシュサーバを介在によって受信されているものの履歴に依存することです。キャッシュサーバは、「host.example.com」のためにレコードを持っていない場合、それは別のサーバー（問題の名のために、通常は権威ネームサーバ）を協議する、と、その場合には、それは一般的に、すべてのIPv4とIPv6のアドレスを返します。記録。しかし、いくつかの他のホストは最近名前をQTYPE「A」のためのクエリを行っている場合は、「host.example.com」、キャッシュサーバはすでに「host.example.com」をそのキャッシュではなく無IPv6用のIPv4アドレスレコードを持つようにアドレスレコードは、それは、それがすでにキャッシュされているIPv4アドレスの記録、および無IPv6アドレスのレコードを返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS does not share this property that qtype &#34;ANY&#34; and qclass &#34;ANY&#34; queries return some undefined subset of the matching records. When responding to queries using qtype &#34;ANY&#34; (255) and/or qclass &#34;ANY&#34; (255), a Multicast DNS responder MUST respond with *ALL* of its records that match the query.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSは、「ANY」クエリが一致するレコードのいくつかの未定義のサブセットを返す「ANY」とQCLASS QTYPEこのプロパティを共有しません。 （255）「ANY」（255）「ANY」QTYPEを使用してクエリへの応答および/またはQCLASSすると、マルチキャストDNS応答は、クエリに一致するそのレコードの* ALL *で応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. Cooperating Multicast DNS Responders
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6。マルチキャストDNSの応答側を協力
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a Multicast DNS responder (&#34;A&#34;) observes some other Multicast DNS responder (&#34;B&#34;) send a Multicast DNS response message containing a resource record with the same name, rrtype, and rrclass as one of A&#39;s resource records, but *different* rdata, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答（「A」）は、いくつかの他のマルチキャストDNS応答（「B」）を観測した場合Aのリソースレコードの1つとして同じ名前、rrtype、およびrrclassとリソースレコードを含むマルチキャストDNS応答メッセージを送信するが、*異なります* RDATA、次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If A&#39;s resource record is intended to be a shared resource record, then this is no conflict, and no action is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aのリソースレコードは、共有リソースレコードであることを意図している場合は、O、これは競合せず、何もする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If A&#39;s resource record is intended to be a member of a unique resource record set owned solely by that responder, then this is a conflict and MUST be handled as described in Section 9, &#34;Conflict Resolution&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O Aのリソースレコードは、その応答が単独で所有しているユニークなリソースレコードセットのメンバーであることを意図している場合、これは紛争で、第9、「紛争解決」で説明したように扱われなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a Multicast DNS responder (&#34;A&#34;) observes some other Multicast DNS responder (&#34;B&#34;) send a Multicast DNS response message containing a resource record with the same name, rrtype, and rrclass as one of A&#39;s resource records, and *identical* rdata, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答（「A」）は、いくつかの他のマルチキャストDNS応答（「B」）を観察している場合は、同じAのリソースレコードの1つとして、マルチキャストDNS応答の同じ名前のリソースレコードを含むメッセージ、rrtype、およびrrclassを送り、そして* * RDATA、次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the TTL of B&#39;s resource record given in the message is at least half the true TTL from A&#39;s point of view, then no action is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージに指定されたBのリソースレコードのTTLは、図のAの時点から少なくとも半分真TTLの場合、Oは、アクションは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If the TTL of B&#39;s resource record given in the message is less than half the true TTL from A&#39;s point of view, then A MUST mark its record to be announced via multicast. Queriers receiving the record from B would use the TTL given by B and, hence, may delete the record sooner than A expects. By sending its own multicast response correcting the TTL, A ensures that the record will be retained for the desired time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージに指定されたBのリソースレコードのTTLは、図のAの点から半分以下の真TTLはO場合、そのレコードがマルチキャストを介して発表されるようにマークしなければなりません。 Bからレコードを受信クエリアは早くAが期待するよりも、レコードを削除することができる、したがって、Bによって与えられたTTLを使用します。 TTLを補正する独自のマルチキャスト応答を送信することにより、Aレコードが所望の時間保持されることを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These rules allow multiple Multicast DNS responders to offer the same data on the network (perhaps for fault-tolerance reasons) without conflicting with each other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのルールは、複数のマルチキャストDNS応答者が相互に矛盾することなく、（おそらくフォールトトレランス理由のために）ネットワーク上で同一のデータを提供することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7. Legacy Unicast Responses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7。レガシーユニキャスト応答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the source UDP port in a received Multicast DNS query is not port 5353, this indicates that the querier originating the query is a simple resolver such as described in Section 5.1, &#34;One-Shot Multicast DNS Queries&#34;, which does not fully implement all of Multicast DNS. In this case, the Multicast DNS responder MUST send a UDP response directly back to the querier, via unicast, to the query packet&#39;s source IP address and port. This unicast response MUST be a conventional unicast response as would be generated by a conventional Unicast DNS server; for example, it MUST repeat the query ID and the question given in the query message. In addition, the cache-flush bit described in Section 10.2, &#34;Announcements to Flush Outdated Cache Entries&#34;, MUST NOT be set in legacy unicast responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信したマルチキャストDNSクエリの送信元UDPポートがポート5353でない場合は、このクエリを元のクエリアが、このような完全にすべてを実装していないセクション5.1で説明した、「ワンショットマルチキャストDNSクエリ」、などの単純なリゾルバであることを示していますマルチキャストDNSの。この場合、マルチキャストDNS応答は、問い合わせパケットの送信元IPアドレスとポートに、ユニキャスト、直接バッククエリアにUDP応答を送らなければなりません。このユニキャスト応答は、従来のユニキャストDNSサーバによって生成されるような従来のユニキャスト応答でなければなりません。例えば、それは、クエリIDとクエリメッセージで与えられた質問を繰り返す必要があります。また、10.2項で説明したキャッシュフラッシュビット、「古いキャッシュエントリをフラッシュするお知らせ」、レガシーユニキャスト応答に設定してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The resource record TTL given in a legacy unicast response SHOULD NOT be greater than ten seconds, even if the true TTL of the Multicast DNS resource record is higher. This is because Multicast DNS responders that fully participate in the protocol use the cache coherency mechanisms described in Section 10, &#34;Resource Record TTL Values and Cache Coherency&#34;, to update and invalidate stale data. Were unicast responses sent to legacy resolvers to use the same high TTLs, these legacy resolvers, which do not implement these cache coherency mechanisms, could retain stale cached resource record data long after it is no longer valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レガシーユニキャスト応答で与えられたリソースレコードのTTLは、マルチキャストDNSリソースレコードの真のTTLが高くても、より大きく10秒すべきではありません。完全プロトコルに参加マルチキャストDNSの応答が更新され、古いデータを無効化するために、第10節、「リソースレコードのTTL値とキャッシュ一貫性」で説明したキャッシュ・コヒーレンシ・メカニズムを使用するためです。それはもはや有効ではずっと後に古いキャッシュされたリソースレコードのデータを保持しない可能性があり、これらのキャッシュ・コヒーレンシ・メカニズムを実装していない同じ高のTTL、これらのレガシーリゾルバを使用する従来のリゾルバに送信されたユニキャスト応答しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Traffic Reduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.トラヒック削減
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A variety of techniques are used to reduce the amount of traffic on the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
様々な技術は、ネットワーク上のトラフィックの量を減らすために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Known-Answer Suppression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。既知解抑制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a Multicast DNS querier sends a query to which it already knows some answers, it populates the Answer Section of the DNS query message with those answers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSクエリアが、それはすでにいくつかの答えを知っているにクエリを送信すると、それはそれらの答えとDNSクエリメッセージの応答セクションに移入されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Generally, this applies only to Shared records, not Unique records, since if a Multicast DNS querier already has at least one Unique record in its cache then it should not be expecting further different answers to this question, since the Unique record(s) it already has comprise the complete answer, so it has no reason to be sending the query at all. In contrast, having some Shared records in its cache does not necessarily imply that a Multicast DNS querier will not receive further answers to this query, and it is in this case that it is beneficial to use the Known-Answer list to suppress repeated sending of redundant answers that the querier already knows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSのクエリアがすでにキャッシュ内に少なくとも1つのユニークなレコードを持っているならば、それは一意のレコード（複数可）、それ以来、この質問には、さらに別の答えを期待すべきではないので、一般的に、これは、唯一の共有、レコードではなく、ユニークな記録に適用されますすでにそれがすべてでクエリを送信する理由はないので、完全な答えを備えています。これとは対照的に、そのキャッシュ内にいくつかの共有レコードを持つことは、必ずしもマルチキャストDNSクエリアは、このクエリをさらに答えを受け取ることはありませんことを意味するものではありませんし、繰り返されるの送信を抑制することが知られて-回答リストを使用することが有益であることがこのケースでありますクエリアがすでに知っていることを冗長答え。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Multicast DNS responder MUST NOT answer a Multicast DNS query if the answer it would give is already included in the Answer Section with an RR TTL at least half the correct value. If the RR TTL of the answer as given in the Answer Section is less than half of the true RR TTL as known by the Multicast DNS responder, the responder MUST send an answer so as to update the querier&#39;s cache before the record becomes in danger of expiration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それが与える答えはすでに、少なくとも半分正しい値RRのTTLと回答セクションに含まれている場合、マルチキャストDNS応答は、マルチキャストDNSクエリに答えるならありません。回答節で与えられる解答のRRのTTLは、マルチキャストDNS応答で知られているように、真のRRのTTLの半分に満たない場合は、レコードがの危険になる前にクエリアのキャッシュを更新するように、応答者は答えを送らなければなりません有効期限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because a Multicast DNS responder will respond if the remaining TTL given in the Known-Answer list is less than half the true TTL, it is superfluous for the querier to include such records in the Known-Answer list. Therefore, a Multicast DNS querier SHOULD NOT include records in the Known-Answer list whose remaining TTL is less than half of their original TTL. Doing so would simply consume space in the message without achieving the goal of suppressing responses and would, therefore, be a pointless waste of network capacity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
既知解リストに与えられた残りのTTLが半分以下の真のTTLの場合は、マルチキャストDNS応答者が対応いたしますので、それは既知解リストで、このようなレコードを含むようにクエリアのための不必要です。そのため、マルチキャストDNSクエリアは、残りのTTL元のTTLの半分以下である既知解リスト内のレコードを含めるべきではありません。そうすることで、単に応答を抑制するという目標を達成することなく、メッセージ内のスペースを消費してしまうと、そのため、ネットワーク容量の無意味な無駄になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Multicast DNS querier MUST NOT cache resource records observed in the Known-Answer Section of other Multicast DNS queries. The Answer Section of Multicast DNS queries is not authoritative. By placing information in the Answer Section of a Multicast DNS query, the querier is stating that it *believes* the information to be true. It is not asserting that the information *is* true. Some of those records may have come from other hosts that are no longer on the network. Propagating that stale information to other Multicast DNS queriers on the network would not be helpful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSクエリアは、他のマルチキャストDNSクエリの既知解節で観察されたキャッシュリソースレコードはいけません。マルチキャストDNSクエリの回答セクションは権威ではありません。マルチキャストDNSクエリの応答セクションに情報を配置することにより、クエリアが真実である*それは*信じる情報を述べています。情報が*真実*であることを主張していません。これらのレコードのいくつかは、もはやネットワーク上のある他のホストから来ている可能性があります。ネットワーク上の他のマルチキャストDNSのクエリアにその古い情報を伝播することは有益ではないでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Multipacket Known-Answer Suppression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。マルチパケット既知解抑制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sometimes a Multicast DNS querier will already have too many answers to fit in the Known-Answer Section of its query packets. In this case, it should issue a Multicast DNS query containing a question and as many Known-Answer records as will fit. It MUST then set the TC (Truncated) bit in the header before sending the query. It MUST immediately follow the packet with another query packet containing no questions and as many more Known-Answer records as will fit. If there are still too many records remaining to fit in the packet, it again sets the TC bit and continues until all the Known-Answer records have been sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時には、マルチキャストDNSクエリアは、すでにそのクエリーパケットの既知解節に収まるようにあまりにも多くの答えを持っています。この場合、それが収まるように、質問やなど、多くの既知解レコードを含むマルチキャストDNSクエリを発行する必要があります。これは、クエリを送信する前に、ヘッダ内のTC（切り捨て）ビットを設定しなければなりません。それはすぐに収まるように何の疑問やなど、より多くの既知解レコードを含まない別のクエリパケットとパケットに従わなければなりません。パケット内に収まるように残っている、あまりにも多くのレコードが残っている場合は、再度TCビットを設定し、すべての既知解レコードが送信されるまで続けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Multicast DNS responder seeing a Multicast DNS query with the TC bit set defers its response for a time period randomly selected in the interval 400-500 ms. This gives the Multicast DNS querier time to send additional Known-Answer packets before the responder responds. If the responder sees any of its answers listed in the Known-Answer lists of subsequent packets from the querying host, it MUST delete that answer from the list of answers it is planning to give (provided that no other host on the network has also issued a query for that record and is waiting to receive an answer).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCビットが設定されたマルチキャストDNSクエリを見レスポンダマルチキャストDNSは、ランダムに間隔400-500ミリ秒で選択した期間のためにその応答を延期します。これは、マルチキャストDNSに応答者が応答する前に追加の既知解パケットを送信するクエリアの時間を与えます。応答者は、クエリのホストからの後続のパケットの既知解リストに記載されているその回答のいずれかを見れば、与えることを計画している回答のリストから、その答えを削除しなければなりません（ネットワーク上の他のホストにも発行されていないことを提供そのレコードのクエリとは）答えを受け取るために待機しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the responder receives additional Known-Answer packets with the TC bit set, it SHOULD extend the delay as necessary to ensure a pause of 400-500 ms after the last such packet before it sends its answer. This opens the potential risk that a continuous stream of Known-Answer packets could, theoretically, prevent a responder from answering indefinitely. In practice, answers are never actually delayed significantly, and should a situation arise where significant delays did happen, that would be a scenario where the network is so overloaded that it would be desirable to err on the side of caution. The consequence of delaying an answer may be that it takes a user longer than usual to discover all the services on the local network; in contrast, the consequence of incorrectly answering before all the Known-Answer packets have been received would be wasted capacity sending unnecessary answers on an already overloaded network. In this (rare) situation, sacrificing speed to preserve reliable network operation is the right trade-off.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レスポンダはTCビットがセットされた追加の既知解パケットを受信した場合、それはその答えを送信する前に、最後のこのようなパケットの後に400〜500ミリ秒の一時停止を確実にするために、必要に応じて遅延を拡張する必要があります。これは、既知解パケットの連続ストリームは、理論上、無限に答えるからの応答を妨げる可能性のある潜在的なリスクを開きます。実際には、答えは実際には大幅に遅れることはありませんし、大幅な遅延が発生しなかったという状況では、ネットワークは、注意の側に誤ることが望ましいであろうことを過負荷になっているシナリオであろうと、発生する必要があります。答えを遅らせる結果は、それは、ローカルネットワーク上のすべてのサービスを発見するために通常よりも長いユーザーをかかることであってもよく、対照的に、すべての既知解パケットが受信される前に、誤って答えるの結果はすでに過負荷にネットワーク上の不要な答えを送信する能力を無駄になります。この（まれ）な状況では、信頼性の高いネットワーク運用を維持するために速度を犠牲にすることは右のトレードオフです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Duplicate Question Suppression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3。質問抑制を複製
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a host is planning to transmit (or retransmit) a query, and it sees another host on the network send a query containing the same &#34;QM&#34; question, and the Known-Answer Section of that query does not contain any records that this host would not also put in its own Known-Answer Section, then this host SHOULD treat its own query as having been sent. When multiple queriers on the network are querying for the same resource records, there is no need for them to all be repeatedly asking the same question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストが送信することを計画（または再送信）クエリを、そしてそれは、ネットワーク上の別のホストを見ている場合は、同じ「QM」という質問を含むクエリを送信し、そのクエリの既知解節は、このホストすべてのレコードが含まれていませんまた、独自の既知解セクションに入れないと、このホストが送信されたとして、独自のクエリを扱うべきです。ネットワーク上の複数のクエリアが同じリソースレコードを照会している場合は、すべてが繰り返し同じ質問をするためにそれらのための必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Duplicate Answer Suppression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4。重複回答抑制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a host is planning to send an answer, and it sees another host on the network send a response message containing the same answer record, and the TTL in that record is not less than the TTL this host would have given, then this host SHOULD treat its own answer as having been sent, and not also send an identical answer itself. When multiple responders on the network have the same data, there is no need for all of them to respond.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストは、その答えを送信するために計画している、そしてそれは、ネットワーク上の別のホストがそのレコードに同じ答えレコードを含む応答メッセージ、およびTTLを送って見た場合、このホストが与えられているだろうTTL以上である場合、このホストはSHOULD送信されたものとして、独自の答えを扱い、また同じ答えそのものを送信しません。ネットワーク上の複数の応答が同じデータを持っている場合は、それらのすべてが応答するまでの必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The opportunity for duplicate answer suppression occurs when a host has received a query, and is delaying its response for some pseudo-random interval up to 500 ms, as described elsewhere in this document, and then, before the host sends its response, it sees some other host on the network send a response message containing the same answer record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
重複回答抑制のための機会は、ホストがクエリを受信したときに発生し、ホストはその応答を送信する前に、それは見て、この文書の他の場所で説明するように、最大​​500ミリ秒にいくつかの擬似ランダム間隔でその応答を遅らせており、ネットワーク上の他のホストが同じ答えレコードを含む応答メッセージを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This feature is particularly useful when Multicast DNS Proxy Servers are in use, where there could be more than one proxy on the network giving Multicast DNS answers on behalf of some other host (e.g., because that other host is currently asleep and is not itself responding to queries).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSプロキシサーバを使用している場合、この機能は、他のホストが現在眠っていると、それ自体が応答していないため、いくつかの他のホスト（例えば、代わってマルチキャストDNSの答えを与えて、ネットワーク上の複数のプロキシがあり得る場合は、特に便利ですクエリに）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Probing and Announcing on Startup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.プロービングし、起動時に発表
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Typically a Multicast DNS responder should have, at the very least, address records for all of its active interfaces. Creating and advertising an HINFO record on each interface as well can be useful to network administrators.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
典型的には、マルチキャストDNSレスポンダは、少なくとも、そのアクティブインターフェイスのすべてのアドレスレコードを有するべきです。同様に、各インターフェイス上のHINFOレコードの作成と宣伝することは、ネットワーク管理者に便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever a Multicast DNS responder starts up, wakes up from sleep, receives an indication of a network interface &#34;Link Change&#34; event, or has any other reason to believe that its network connectivity may have changed in some relevant way, it MUST perform the two startup steps below: Probing (Section 8.1) and Announcing (Section 8.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答者が、起動眠りから目覚め、ネットワーク・インタフェース「リンクの変更」イベントの通知を受け取る、またはそのネットワーク接続が何らかの関連する方法で変更された可能性があると考えているために、他の理由があるときはいつでも、それは2を実行しなければなりません下記の起動手順：（8.1節）をプロービングし、（セクション8.3）を発表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Probing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。プロービング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first startup step is that, for all those resource records that a Multicast DNS responder desires to be unique on the local link, it MUST send a Multicast DNS query asking for those resource records, to see if any of them are already in use. The primary example of this is a host&#39;s address records, which map its unique host name to its unique IPv4 and/or IPv6 addresses. All probe queries SHOULD be done using the desired resource record name and class (usually class 1, &#34;Internet&#34;), and query type &#34;ANY&#34; (255), to elicit answers for all types of records with that name. This allows a single question to be used in place of several questions, which is more efficient on the network. It also allows a host to verify exclusive ownership of a name for all rrtypes, which is desirable in most cases. It would be confusing, for example, if one host owned the &#34;A&#34; record for &#34;myhost.local.&#34;, but a different host owned the &#34;AAAA&#34; record for that name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の起動段階は、マルチキャストDNS応答者がローカルリンク上で一意であることを望むすべてのそれらのリソースレコードのために、それはそれらのいずれかが既に使用されているかどうかを確認するために、これらのリソースレコードを求めるマルチキャストDNSクエリを送信しなければならない、ということです。これの主な例は、そのユニークなIPv4および/またはIPv6アドレスに独自のホスト名をマップするホストのアドレスレコードです。すべてのプローブのクエリは、その名前を持つすべてのレコードの種類の答えを引き出すために、（255）は、所望のリソースレコード名とクラス（通常クラス1、「インターネット」）、および「ANY」クエリタイプを使用して行われるべきです。これは、ネットワーク上の方が効率的である、単一の質問は、いくつかの質問の代わりに使用することができます。また、ほとんどの場合において望まれる、ホストはすべてrrtypesの名前の排他的な所有権を確認することができます。 1つのホストは、「myhost.local」のための「A」レコードを所有しているが、別のホストがその名前のための「AAAA」レコードを所有している場合は、例えば、混乱するでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ability to place more than one question in a Multicast DNS query is useful here, because it can allow a host to use a single message to probe for all of its resource records instead of needing a separate message for each. For example, a host can simultaneously probe for uniqueness of its &#34;A&#34; record and all its SRV records [RFC6763] in the same query message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはホストではなく、それぞれに別々のメッセージを必要とし、そのリソースレコードのすべてについて調べるために、単一のメッセージを使用する可能性があるため、マルチキャストDNSクエリに複数の質問を配置する機能は、ここに便利です。例えば、ホストは、同時に、その「A」レコードと同一のクエリメッセージ内のすべてのSRVレコード[RFC6763]の一意性を探索することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When ready to send its Multicast DNS probe packet(s) the host should first wait for a short random delay time, uniformly distributed in the range 0-250 ms. This random delay is to guard against the case where several devices are powered on simultaneously, or several devices are connected to an Ethernet hub, which is then powered on, or some other external event happens that might cause a group of hosts to all send synchronized probes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場合、そのマルチキャストDNSプローブパケット（S）ホストを送信する準備は、まず均一範囲0〜250ミリ秒で分散、短いランダム遅延時間を待たなければなりません。このランダム遅延は、複数の機器を同時に電源が入っている場合を防ぐためにある、または複数のデバイスは、その後に電源が投入されたイーサネットハブに接続されている、またはいくつかの他の外部イベントは、それがすべてのホストのグループが同期送ることがありますが起こりますプローブ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
250 ms after the first query, the host should send a second; then, 250 ms after that, a third. If, by 250 ms after the third probe, no conflicting Multicast DNS responses have been received, the host may move to the next step, announcing. (Note that probing is the one exception from the normal rule that there should be at least one second between repetitions of the same question, and the interval between subsequent repetitions should at least double.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
250ミリ秒の最初の問合せの後、ホストは、第二の送信すべきです。次いで、その後250ミリ秒、第三。 、第3のプローブの後に250ミリ秒、競合するマルチキャストDNS応答が受信されていない場合、ホストは発表、次のステップに移動することができます。 （プロービングは、少なくとも一つの同じ質問の繰り返しの間に第二の、そして以降の反復すべき少なくとも2倍の間隔がなければならないことが通常ルールの唯一の例外であることに注意してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When sending probe queries, a host MUST NOT consult its cache for potential answers. Only conflicting Multicast DNS responses received &#34;live&#34; from the network are considered valid for the purposes of determining whether probing has succeeded or failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プローブクエリを送信すると、ホストは、潜在的な答えをそのキャッシュに相談してはなりません。唯一のマルチキャストDNS応答を矛盾することは、ネットワークから「ライブ」受信探査が成功したか失敗したかどうかを決定する目的のために有効と考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to allow services to announce their presence without unreasonable delay, the time window for probing is intentionally set quite short. As a result of this, from the time the first probe packet is sent, another device on the network using that name has just 750 ms to respond to defend its name. On networks that are slow, or busy, or both, it is possible for round-trip latency to account for a few hundred milliseconds, and software delays in slow devices can add additional delay. Hence, it is important that when a device receives a probe query for a name that it is currently using, it SHOULD generate its response to defend that name immediately and send it as quickly as possible. The usual rules about random delays before responding, to avoid sudden bursts of simultaneous answers from different hosts, do not apply here since normally at most one host should ever respond to a given probe question. Even when a single DNS query message contains multiple probe questions, it would be unusual for that message to elicit a defensive response from more than one other host. Because of the mDNS multicast rate-limiting rules, the probes SHOULD be sent as &#34;QU&#34; questions with the unicast-response bit set, to allow a defending host to respond immediately via unicast, instead of potentially having to wait before replying via multicast.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスは不当な遅滞なくその存在を発表することを可能にするために、プロービングのための時間ウィンドウは、意図的に非常に短く設定されています。その結果、時間から最初のプローブパケットが送信され、その名前を使用して、ネットワーク上の他のデバイスは、その名前を守るために対応するだけで750ミリ秒を持っています。遅い、または忙しい、あるいはその両方あるネットワークでは、ラウンドトリップ遅延が数百ミリ秒を占めることが可能であり、遅いデバイスでのソフトウェアの遅延は、追加の遅延を追加することができます。したがって、デバイスは、それが現在使用している名前のためのプローブクエリを受信したとき、それはすぐにその名前を守り、可能な限り迅速にそれを送信するためにその応答を生成することが重要です。通常、最大1つのホストがこれまでに与えられたプローブの質問に応答しなければならないので、異なるホストからの同時回答の突然のバーストを避けるために、応答する前にランダムな遅延に関する通常の規則は、ここでは適用されません。単一DNSクエリメッセージは、複数のプローブの質問が含まれている場合でも、そのメッセージが複数の他のホストからの防御応答を誘発するために、それは珍しいだろう。そのためのmDNSマルチキャストレート制限ルールのため、プローブが防御ホストではなく、潜在的にマルチキャストを経由して返信する前に待機するので、ユニキャスト経由で即座に対応できるようにするために、ユニキャスト応答ビットがセットされた「QU」の質問として送ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
During probing, from the time the first probe packet is sent until 250 ms after the third probe, if any conflicting Multicast DNS response is received, then the probing host MUST defer to the existing host, and SHOULD choose new names for some or all of its resource records as appropriate. Apparently conflicting Multicast DNS responses received *before* the first probe packet is sent MUST be silently ignored (see discussion of stale probe packets in Section 8.2, &#34;Simultaneous Probe Tiebreaking&#34;, below). In the case of a host probing using query type &#34;ANY&#34; as recommended above, any answer containing a record with that name, of any type, MUST be considered a conflicting response and handled accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
競合するマルチキャストDNS応答が受信された場合、最初のプローブパケットは、第3のプローブ後に250ミリ秒まで送信された時点から、プロービング時には、その後、プロービングのホストでは、既存のホストに延期しなければならない、といくつかまたはすべてのための新しい名前を選択する必要があります必要に応じて、そのリソースレコード。どうやら最初のプローブパケットは（以下、「同時プローブタイブレイク」、セクション8.2で古いプローブパケットの議論を参照）黙って無視しなければなりません送信されます* *前に受信マルチキャストDNS応答の競合。クエリの種類を用いてプロービングホストの場合には「ANY」上記推奨されるように、その名前を持つレコードを含む任意の答えは、任意のタイプの競合反応と考えられ、それに応じて取り扱わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If fifteen conflicts occur within any ten-second period, then the host MUST wait at least five seconds before each successive additional probe attempt. This is to help ensure that, in the event of software bugs or other unanticipated problems, errant hosts do not flood the network with a continuous stream of multicast traffic. For very simple devices, a valid way to comply with this requirement is to always wait five seconds after any failed probe attempt before trying again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
15競合が任意の10秒の期間内に発生した場合、ホストは、各連続する追加のプローブを試行する前に、少なくとも5秒を待たなければなりません。これは、ソフトウェアのバグやその他の予期せぬ問題が発生した場合に、誤ったホストがマルチキャストトラフィックの連続ストリームでネットワークをあふれていない、ことを確実にするためにあります。非常に単純なデバイスの場合、この要件に準拠するための有効な方法は、任意の再試行する前に、プローブの試みを失敗した後、必ず5秒待つことです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a responder knows by other means that its unique resource record set name, rrtype, and rrclass cannot already be in use by any other responder on the network, then it SHOULD skip the probing step for that resource record set. For example, when creating the reverse address mapping PTR records, the host can reasonably assume that no other host will be trying to create those same PTR records, since that would imply that the two hosts were trying to use the same IP address, and if that were the case, the two hosts would be suffering communication problems beyond the scope of what Multicast DNS is designed to solve. Similarly, if a responder is acting as a proxy, taking over from another Multicast DNS responder that has already verified the uniqueness of the record, then the proxy SHOULD NOT repeat the probing step for those records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答者が独自のリソースレコードが既にネットワーク上の他の応答者が使用してすることはできません名前、rrtype、およびrrclassを設定し、他の手段によって知っている場合、それはそのリソースレコードセットに対するプロービングステップを飛ばしてください。逆アドレスマッピングPTRレコードを作成する場合たとえば、ホストが合理的にそれは2つのホストが同じIPアドレスを使用しようとしていたことを示唆するものであろうから、他のホストは、同じPTRレコードを作成しようとしないことを前提とし、もし可能それは、2つのホストがマルチキャストDNSを解決するために設計されているものの範囲を超えて通信の問題に悩まされることになる、ケースでした。レスポンダは、レコードの一意性を検証し、すでにしている別のマルチキャストDNS応答者から引き継いで、プロキシとして動作している場合は同様に、その後、プロキシは、それらのレコードのためのプロービング手順を繰り返しすべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Simultaneous Probe Tiebreaking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2。同時プローブタイブレイク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The astute reader will observe that there is a race condition inherent in the previous description. If two hosts are probing for the same name simultaneously, neither will receive any response to the probe, and the hosts could incorrectly conclude that they may both proceed to use the name. To break this symmetry, each host populates the query message&#39;s Authority Section with the record or records with the rdata that it would be proposing to use, should its probing be successful. The Authority Section is being used here in a way analogous to the way it is used as the &#34;Update Section&#34; in a DNS Update message [RFC2136] [RFC3007].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
賢明な読者は、前の説明に固有の競合状態があることを確認します。 2つのホストが同時に同じ名前のためのプロービングされている場合は、プローブへの応答を受信しないだろう、とホストが間違って、彼らは両方の名前を使うに進むことができると結論可能性があり、どちらも。この対称性を破るために、各ホストは、そのプロービングが成功する必要があり、使用するために提案されることをRDATAを持つレコードまたはレコードをクエリメッセージの権限セクションに移入されます。権限セクションは、それがDNS更新メッセージ[RFC2136]、[RFC3007]に「更新部」として使用されている方法と類似の方法で、ここで使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a host is probing for a group of related records with the same name (e.g., the SRV and TXT record describing a DNS-SD service), only a single question need be placed in the Question Section, since query type &#34;ANY&#34; (255) is used, which will elicit answers for all records with that name. However, for tiebreaking to work correctly in all cases, the Authority Section must contain *all* the records and proposed rdata being probed for uniqueness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストが同じ名前（DNS-SDサービスを記述するなど、SRVやTXTレコード）との関連レコードのグループのためにプロービングされている場合、唯一の単一の質問は、クエリの種類以来、質問セクションに配置する必要が「ANY」（ 255）は、その名前を持つすべてのレコードの答えを引き出すであろう、使用されています。しかし、すべての場合に正しく動作するためにタイブレイクのために、当局節は*すべての*レコードと独自性のためにプローブさに提案RDATAが含まれている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a host that is probing for a record sees another host issue a query for the same record, it consults the Authority Section of that query. If it finds any resource record(s) there which answers the query, then it compares the data of that (those) resource record(s) with its own tentative data. We consider first the simple case of a host probing for a single record, receiving a simultaneous probe from another host also probing for a single record. The two records are compared and the lexicographically later data wins. This means that if the host finds that its own data is lexicographically later, it simply ignores the other host&#39;s probe. If the host finds that its own data is lexicographically earlier, then it defers to the winning host by waiting one second, and then begins probing for this record again. The logic for waiting one second and then trying again is to guard against stale probe packets on the network (possibly even stale probe packets sent moments ago by this host itself, before some configuration change, which may be echoed back after a short delay by some Ethernet switches and some 802.11 base stations). If the winning simultaneous probe was from a real other host on the network, then after one second it will have completed its probing, and will answer subsequent probes. If the apparently winning simultaneous probe was in fact just an old stale packet on the network (maybe from the host itself), then when it retries its probing in one second, its probes will go unanswered, and it will successfully claim the name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
記録のためにプロービングされたホストが別のホストの問題に同じレコードのクエリを見ているとき、それはそのクエリの権限セクションを参照します。それは、クエリに答える任意のリソースレコード（複数可）が見つかった場合、それは自身の暫定データでその（それらの）リソースレコード（複数可）のデータを比較します。我々はまた、単一のレコードのためのプロービング別のホストからの同時プローブを受け、初のシングルレコードの探査ホストの簡単な場合を考えます。 2つのレコードが比較され、辞書順、後にデータが勝ち。これは、ホストが独自のデータを後で辞書順であることを発見した場合、それは単に他のホストのプローブを無視することを意味します。ホストは、自身のデータが辞書順で早いであることを発見した場合、それは1秒を待つことによって勝つホストに延期し、再度このレコードのプロービングを開始します。 1秒待ってから、再度試みるためのロジックは、ネットワーク上の古いプローブパケットを防ぐために（可能性も古いプローブパケットは、いくつかのことで、短い遅延の後にエコーバックすることができるいくつかの設定変更、前に、このホスト自身によって瞬間前に送られたのですイーサネットスイッチと、いくつかの802.11基地局）。受賞同時プローブは、ネットワーク上の本当の他のホストからだった場合は、1秒後には、そのプロービングを完了しているだろう、とその後のプローブにお答えします。明らかに勝っ同時プローブは、実際には（多分ホスト自体から）ネットワーク上のただの古い古いパケットだった場合、それはその1秒でのプロービング再試行するときに、そのプローブは、未回答行く、それが成功した名前を主張します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The determination of &#34;lexicographically later&#34; is performed by first comparing the record class (excluding the cache-flush bit described in Section 10.2), then the record type, then raw comparison of the binary content of the rdata without regard for meaning or structure. If the record classes differ, then the numerically greater class is considered &#34;lexicographically later&#34;. Otherwise, if the record types differ, then the numerically greater type is considered &#34;lexicographically later&#34;. If the rrtype and rrclass both match, then the rdata is compared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「辞書編集後」の決意を、最初に（10.2項に記載のキャッシュフラッシュビットを除く）レコードクラス、レコード型、意味や構造に関係なくRDATAのバイナリコンテンツの生の比較を比較することによって行われます。レコードクラスが異なる場合、数値的により大きなクラスが「辞書的に後で」と考えられています。レコードタイプが異なる場合それ以外の場合は、その後、数値的により大きなタイプが「辞書的に後で」と考えられています。 rrtypeとrrclassの両方が一致した場合、その後、RDATAが比較されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of resource records containing rdata that is subject to name compression [RFC1035], the names MUST be uncompressed before comparison. (The details of how a particular name is compressed is an artifact of how and where the record is written into the DNS message; it is not an intrinsic property of the resource record itself.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前圧縮[RFC1035]の対象となるRDATAを含むリソースレコードの場合、名前は比較の前に解凍する必要があり。 （特定の名前が圧縮されている方法の詳細は、どのように、どこでレコードがDNSメッセージに書き込まれるのアーチファクトであり、それはリソース・レコード自体の固有の特性ではありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The bytes of the raw uncompressed rdata are compared in turn, interpreting the bytes as eight-bit UNSIGNED values, until a byte is found whose value is greater than that of its counterpart (in which case, the rdata whose byte has the greater value is deemed lexicographically later) or one of the resource records runs out of rdata (in which case, the resource record which still has remaining data first is deemed lexicographically later). The following is an example of a conflict:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
生の非圧縮RDATAのバイトは、バイトを、そのバイトより大きい値を有するRDATAが、その場合、その値はその対応（のそれよりも大きい発見されるまで、8ビット符号なしの値としてバイトを解釈し、順番に比較しますみなさ辞書編集後）またはリソースレコードの一つはRDATAの不足（この場合、まだ最初のデータを残りたリソースレコード）は、後に辞書とみなされます。以下は、紛争の例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MyPrinter.local. A 169.254.99.200 MyPrinter.local. A 169.254.200.50
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MyPrinter.local。 169.254.99.200 MyPrinter.local。 169.254.200.50
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this case, 169.254.200.50 is lexicographically later (the third byte, with value 200, is greater than its counterpart with value 99), so it is deemed the winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この場合、169.254.200.50は、（第3バイトが、値200と、値99との対応物よりも大きい）後辞書であり、それが勝者と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that it is vital that the bytes are interpreted as UNSIGNED values in the range 0-255, or the wrong outcome may result. In the example above, if the byte with value 200 had been incorrectly interpreted as a signed eight-bit value, then it would be interpreted as value -56, and the wrong address record would be deemed the winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイトは0〜255の範囲の符号なしの値として解釈され、又は間違った結果が生じることが重要であることに留意されたいです。値200のバイトが誤って符号付き8ビット値として解釈されていた場合、上記の例では、それは値-56として解釈され、間違ったアドレスのレコードが勝者と見なされるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1. Simultaneous Probe Tiebreaking for Multiple Records
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1。複数のレコードの同時プローブタイブレイク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a host is probing for a set of records with the same name, or a message is received containing multiple tiebreaker records answering a given probe question in the Question Section, the host&#39;s records and the tiebreaker records from the message are each sorted into order, and then compared pairwise, using the same comparison technique described above, until a difference is found.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストは、同じ名前を持つレコードのセットのプロービングされた場合、またはメッセージが質問節で与えられたプローブの質問に答える複数のタイブレークレコードを含む受信され、ホストの記録とメッセージからタイブレークレコードは、それぞれ順にソートされています差異が検出されるまで、その後、上記と同様の比較技術を使用して、ペアワイズ比較。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The records are sorted using the same lexicographical order as described above, that is, if the record classes differ, the record with the lower class number comes first. If the classes are the same but the rrtypes differ, the record with the lower rrtype number comes first. If the class and rrtype match, then the rdata is compared bytewise until a difference is found. For example, in the common case of advertising DNS-SD services with a TXT record and an SRV record, the TXT record comes first (the rrtype value for TXT is 16) and the SRV record comes second (the rrtype value for SRV is 33).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レコードはレコードクラスが異なる場合、ある上記と同じ辞書順を、使用してソートされ、下層階級の番号を持つレコードが最初に来ます。クラスが同じであるが、rrtypesが異なる場合は、下rrtype番号を持つレコードが最初に来ます。クラスとrrtype一致する場合、RDATAは差が見つかるまでバイト単位と比較されます。例えば、TXTレコード及びSRVレコードと広告DNS-SDサービスの一般的なケースでは、TXTレコードが最初に来る（TXT用rrtype値は16である）、およびSRVレコードは第二来る（SRV用rrtype値は33であります）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When comparing the records, if the first records match perfectly, then the second records are compared, and so on. If either list of records runs out of records before any difference is found, then the list with records remaining is deemed to have won the tiebreak. If both lists run out of records at the same time without any difference being found, then this indicates that two devices are advertising identical sets of records, as is sometimes done for fault tolerance, and there is, in fact, no conflict.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レコードを比較するとき最初のレコードが完全に一致する場合、第2のレコードは、そうで比較され。どんな違いが発見された前のレコードのいずれかのリストは、レコードが不足した場合、残りのレコードを持つリストは、タイブレークを獲得しているとみなされます。両方のリストが発見されているに違いなく、同じ時刻に、レコードが不足した場合、これは時々、フォールトトレランスのために行われているように2つのデバイスが、レコードの同じセットを宣伝していることを示し、競合は、実際には、ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Announcing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3。発表
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The second startup step is that the Multicast DNS responder MUST send an unsolicited Multicast DNS response containing, in the Answer Section, all of its newly registered resource records (both shared records, and unique records that have completed the probing step). If there are too many resource records to fit in a single packet, multiple packets should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第2起動ステップは、マルチキャストDNS応答者は、その新たに登録されたリソースレコード（両方の共有、レコード、プロービングステップを完了しているユニークな記録）のすべてを回答セクションで含む未承諾マルチキャストDNS応答を送信しなければならないということです。単一のパケットに収まるようにあまりにも多くのリソースレコードがある場合は、複数のパケットを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of shared records (e.g., the PTR records used by DNS-Based Service Discovery [RFC6763]), the records are simply placed as is into the Answer Section of the DNS response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS応答の応答セクションにあるように、共有するレコードの場合には（例えば、DNSベースのサービス発見[RFC6763]で使用されるPTRレコード）は、レコードが単純に配置されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of records that have been verified to be unique in the previous step, they are placed into the Answer Section of the DNS response with the most significant bit of the rrclass set to one. The most significant bit of the rrclass for a record in the Answer Section of a response message is the Multicast DNS cache-flush bit and is discussed in more detail below in Section 10.2, &#34;Announcements to Flush Outdated Cache Entries&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前のステップで一意であることが確認されたレコードの場合には、それらが1に設定さrrclassの最上位ビットとDNS応答の回答セクションに配置されています。応答メッセージの応答セクション内のレコードのためのrrclassの最上位ビットは、マルチキャストDNSキャッシュフラッシュビットで、10.2項では、以下でより詳細に議論され、「古いキャッシュエントリをフラッシュするお知らせ」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Multicast DNS responder MUST send at least two unsolicited responses, one second apart. To provide increased robustness against packet loss, a responder MAY send up to eight unsolicited responses, provided that the interval between unsolicited responses increases by at least a factor of two with every response sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答は、少なくとも二つの迷惑応答、離れて1秒を送らなければなりません。パケット損失に対するロバスト性の増大を提供するために、レスポンダは8つの迷惑応答まで送るかもしれません、未承諾応答の間の間隔が送信されるすべての応答を少なくとも2倍で増加することを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Multicast DNS responder MUST NOT send announcements in the absence of information that its network connectivity may have changed in some relevant way. In particular, a Multicast DNS responder MUST NOT send regular periodic announcements as a matter of course.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答者は、そのネットワーク接続がいくつかの関連の方法で変更された可能性があるとの情報が存在しない場合にアナウンスを送ってはいけません。具体的には、マルチキャストDNS応答は、当然のこととして、定期的な定期的なアナウンスを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever a Multicast DNS responder receives any Multicast DNS response (solicited or otherwise) containing a conflicting resource record, the conflict MUST be resolved as described in Section 9, &#34;Conflict Resolution&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答は、競合リソースレコードを含む（特に要請又は）任意のマルチキャストDNS応答を受信するたびに第9、「競合解消」に記載されているように、競合が解決されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. Updating
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4。更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At any time, if the rdata of any of a host&#39;s Multicast DNS records changes, the host MUST repeat the Announcing step described above to update neighboring caches. For example, if any of a host&#39;s IP addresses change, it MUST re-announce those address records. The host does not need to repeat the Probing step because it has already established unique ownership of that name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストのマルチキャストDNSのいずれかのRDATAが変化を記録した場合に任意の時点で、ホストは、近隣キャッシュを更新するために、上記の発表のステップを繰り返す必要があります。たとえば、ホストのIPアドレスのいずれかの変更された場合、それは、それらのアドレスレコードを再発表しなければなりません。それは、すでにその名前のユニークな所有権を確立しているため、ホストは、プロービング手順を繰り返す必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of shared records, a host MUST send a &#34;goodbye&#34; announcement with RR TTL zero (see Section 10.1, &#34;Goodbye Packets&#34;) for the old rdata, to cause it to be deleted from peer caches, before announcing the new rdata. In the case of unique records, a host SHOULD omit the &#34;goodbye&#34; announcement, since the cache-flush bit on the newly announced records will cause old rdata to be flushed from peer caches anyway.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
共有レコードの場合、ホストは、それが新しいRDATAを発表する前に、ピア・キャッシュから削除させるように、古いRDATAのため（10.1項「さようならパケット」を参照）RR TTLをゼロに「さようなら」の発表を送らなければなりません。新たに発表されたレコードの上のキャッシュフラッシュビットが古いRDATAがとにかくピアキャッシュからフラッシュされることになりますので、ユニークなレコードの場合、ホストは、「さようなら」の発表を省略すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A host may update the contents of any of its records at any time, though a host SHOULD NOT update records more frequently than ten times per minute. Frequent rapid updates impose a burden on the network. If a host has information to disseminate which changes more frequently than ten times per minute, then it may be more appropriate to design a protocol for that specific purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストは、毎分10回以上の頻度でレコードを更新するべきではありませんが、ホストは、いつでもそのレコードのいずれかの内容を更新することができます。頻繁に迅速なアップデートは、ネットワークに負担を課します。ホストはより頻繁に毎分10回以上変更され普及するための情報を持っている場合、その特定の目的のためのプロトコルを設計することがより適切かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Conflict Resolution
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.紛争解決
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A conflict occurs when a Multicast DNS responder has a unique record for which it is currently authoritative, and it receives a Multicast DNS response message containing a record with the same name, rrtype and rrclass, but inconsistent rdata. What may be considered inconsistent is context sensitive, except that resource records with identical rdata are never considered inconsistent, even if they originate from different hosts. This is to permit use of proxies and other fault-tolerance mechanisms that may cause more than one responder to be capable of issuing identical answers on the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答が現在権威された一意のレコードを持っている場合、競合が発生し、それが同じ名前、rrtypeとrrclassが、矛盾RDATAを持つレコードを含むマルチキャストDNS応答メッセージを受信します。どのような矛盾したと見なすことができることは、彼らが異なるホストから発信しても、同一の資源データとそのリソースレコードは、矛盾したとみなされることはありませんを除いて、文脈に敏感です。これは、複数のレスポンダは、ネットワーク上の同じ答えを出すことができるように可能性がありプロキシやその他のフォールトトレランス機構の使用を可能にすることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A common example of a resource record type that is intended to be unique, not shared between hosts, is the address record that maps a host&#39;s name to its IP address. Should a host witness another host announce an address record with the same name but a different IP address, then that is considered inconsistent, and that address record is considered to be in conflict.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一意であることが意図されているリソースレコードタイプの一般的な例は、ホスト間で共有されていない、そのIPアドレスにホスト名をマップするアドレスレコードです。ホスト証人別のホストが同じ名前で異なるIPアドレスを持つアドレスレコードを発表する必要があり、その矛盾が考慮され、そのアドレスのレコードは競合していると考えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever a Multicast DNS responder receives any Multicast DNS response (solicited or otherwise) containing a conflicting resource record in any of the Resource Record Sections, the Multicast DNS responder MUST immediately reset its conflicted unique record to probing state, and go through the startup steps described above in
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答者が任意のマルチキャストDNS応答（勧誘またはそれ以外の）リソースレコードセクションのいずれかで競合リソースレコードを含むを受信するたびに、マルチキャストDNS応答者はすぐに状態をプロービングにその競合一意のレコードをリセットし、説明したスタートアップの段階を経なければなりません上記
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 8, &#34;Probing and Announcing on Startup&#34;. The protocol used in the Probing phase will determine a winner and a loser, and the loser MUST cease using the name, and reconfigure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第8章、「起動時にプロービングと発表」。プロービング段階で使用されるプロトコルは、勝者と敗者を決定し、敗者は名前を使用して中止し、再設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is very important that any host receiving a resource record that conflicts with one of its own MUST take action as described above. In the case of two hosts using the same host name, where one has been configured to require a unique host name and the other has not, the one that has not been configured to require a unique host name will not perceive any conflict, and will not take any action. By reverting to Probing state, the host that desires a unique host name will go through the necessary steps to ensure that a unique host name is obtained.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意のホストは上記のような行動を取る必要があり、独自の一つと競合するリソースレコードを受けることが非常に重要です。一つは一意のホスト名を要求するように構成されており、他のではなく、矛盾を認識しないであろう一意のホスト名を要求するように構成されていないものを有し、そしてするのと同じホスト名を使用して、二つのホストの場合任意のアクションを取ることではありません。状態をプロービングに戻すことで、一意のホスト名を希望するホストは、一意のホスト名が得られることを保証するために必要な手順を通過します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The recommended course of action after probing and failing is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにプロービングし、失敗した後のアクションの推奨コースは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Programmatically change the resource record name in an attempt to find a new name that is unique. This could be done by adding some further identifying information (e.g., the model name of the hardware) if it is not already present in the name, or appending the digit &#34;2&#34; to the name, or incrementing a number at the end of the name if one is already present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.プログラムでユニークな新しい名前を見つけるための試みでリソースレコードの名前を変更します。これは、名前に既に存在しない場合、いくつかの更なる識別情報（例えば、ハードウェアのモデル名）を追加、または名前に数字「2」を付加し、または終了時に数を増分することによって行うことができます1がすでに存在する場合は名前を付けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Probe again, and repeat as necessary until a unique name is found.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.再びプローブ、および固有の名前が見つかるまで、必要に応じて繰り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Once an available unique name has been determined, by probing without receiving any conflicting response, record this newly chosen name in persistent storage so that the device will use the same name the next time it is power-cycled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
使用可能な一意の名前が決定されるとデバイスが同じ名前を、それが電源再投入され、次の時間を使用するように3.競合する応答を受信せずに探索することによって、永続ストレージにこの新たに選択された名前を記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Display a message to the user or operator informing them of the name change. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.名前の変更を知らせるユーザまたはオペレータにメッセージを表示します。例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            The name &#34;Bob&#39;s Music&#34; is in use by another music server on
            the network.  Your music collection has been renamed to
            &#34;Bob&#39;s Music (2)&#34;.  If you want to change this name, use
            [describe appropriate menu item or preference dialog here].
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The details of how the user or operator is informed of the new name depends on context. A desktop computer with a screen might put up a dialog box. A headless server in the closet may write a message to a log file, or use whatever mechanism (email, SNMP trap, etc.) it uses to inform the administrator of error conditions. On the other hand, a headless server in the closet may not inform the user at all -- if the user cares, they will notice the name has changed, and connect to the server in the usual way (e.g., via web browser) to configure a new name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザまたはオペレータは、新しい名前が通知される方法の詳細は、文脈に依存します。画面とデスクトップコンピュータは、ダイアログボックスを出すかもしれません。クローゼットの中にヘッドレスサーバがログファイルにメッセージを書き込み、または任意のメカニズム（電子メール、SNMPトラップなど）には、エラー状況を管理者に通知するために使用を使用することができます。一方、クローゼットの中にヘッドレスサーバーは、すべてのユーザーに通知しないかもしれません - ユーザーは気にならば、彼らは名前が変更された気づくでしょう、とする（ウェブブラウザを介して、例えば）通常の方法でサーバに接続します新しい名前を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. After one minute of probing, if the Multicast DNS responder has been unable to find any unused name, it should log an error message to inform the user or operator of this fact. This situation should never occur in normal operation. The only situations that would cause this to happen would be either a deliberate denial-of-service attack, or some kind of very obscure hardware or software bug that acts like a deliberate denial-of-service attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.プロービングの1分後、マルチキャストDNS応答が未使用の名前を見つけることができなかった場合、それはこの事実のユーザまたはオペレータに知らせるためのエラーメッセージをログに記録する必要があります。この状況は、通常の操作では発生しません。これが起こることを引き起こすだけの状況が意図的なサービス拒否攻撃、あるいは意図的なDoS攻撃のような役割を果たし非常に曖昧なハードウェアやソフトウェアのバグのいくつかの種類のいずれかになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These considerations apply to address records (i.e., host names) and to all resource records where uniqueness (or maintenance of some other defined constraint) is desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの考慮事項は、レコード（すなわち、ホスト名）及び一意性（またはいくつかの他の定義された制約の維持）が望まれているすべてのリソースレコードに対処するために適用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Resource Record TTL Values and Cache Coherency
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.リソースレコードのTTL値とキャッシュ一貫性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As a general rule, the recommended TTL value for Multicast DNS resource records with a host name as the resource record&#39;s name (e.g., A, AAAA, HINFO) or a host name contained within the resource record&#39;s rdata (e.g., SRV, reverse mapping PTR record) SHOULD be 120 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リソースレコードの名前としてホスト名を持つ一般的なルール、マルチキャストDNSリソースレコードに対する推奨TTL値（例えば、A、AAAA、HINFO）として、またはリソースレコードのRDATAに含まれるホスト名（例えば、SRVは、マッピングPTRを逆転レコード）が120秒であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The recommended TTL value for other Multicast DNS resource records is 75 minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他のマルチキャストDNSリソースレコードのための推奨されるTTL値は75分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A querier with an active outstanding query will issue a query message when one or more of the resource records in its cache are 80% of the way to expiry. If the TTL on those records is 75 minutes, this ongoing cache maintenance process yields a steady-state query rate of one query every 60 minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのキャッシュ内のリソースレコードの1つ以上が満了するための方法の80％のとき、アクティブ優れたクエリとのクエリアは、クエリメッセージを発行します。それらのレコードのTTLは75分である場合は、この継続的なキャッシュの保守プロセスは60分ごとに1つのクエリの定常状態のクエリ率が得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any distributed cache needs a cache coherency protocol. If Multicast DNS resource records follow the recommendation and have a TTL of 75 minutes, that means that stale data could persist in the system for a little over an hour. Making the default RR TTL significantly lower would reduce the lifetime of stale data, but would produce too much extra traffic on the network. Various techniques are available to minimize the impact of such stale data, outlined in the five subsections below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意の分散キャッシュは、キャッシュコヒーレンシプロトコルを必要とします。マルチキャストDNSリソースレコードは、勧告に従うと、75分のTTLを持っている場合、それは古いデータを時間かけて少しのためのシステムに固執することができることを意味します。大幅に低いデフォルトのRRのTTLを作ることは、古いデータの寿命を減らすだろうが、ネットワーク上であまりにも多くの余分なトラフィックを生成します。種々の技術は、以下の5つのサブセクションで概説ような古いデータの影響を最小化するために利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Goodbye Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1。さようならパケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case where a host knows that certain resource record data is about to become invalid (for example, when the host is undergoing a clean shutdown), the host SHOULD send an unsolicited Multicast DNS response packet, giving the same resource record name, rrtype, rrclass, and rdata, but an RR TTL of zero. This has the effect of updating the TTL stored in neighboring hosts&#39; cache entries to zero, causing that cache entry to be promptly deleted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（ホストがクリーンシャットダウンを受けている場合など）ホストは、特定のリソースレコードのデータが無効になろうとしていることを知っている場合は、ホストは、同じリソースレコードの名前を与え、迷惑マルチキャストDNS応答パケットを送るべきで、rrtype 、rrclass、およびRDATAが、ゼロのRRのTTL。これは、ゼロに隣接するホストのキャッシュエントリに格納されたTTLを更新し、そのキャッシュ・エントリが速やかに削除させる効果を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Queriers receiving a Multicast DNS response with a TTL of zero SHOULD NOT immediately delete the record from the cache, but instead record a TTL of 1 and then delete the record one second later. In the case of multiple Multicast DNS responders on the network described in Section 6.6 above, if one of the responders shuts down and incorrectly sends goodbye packets for its records, it gives the other cooperating responders one second to send out their own response to &#34;rescue&#34; the records before they expire and are deleted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ゼロのTTLを持つマルチキャストDNS応答を受信するクエリアが直ちにキャッシュからレコードを削除し、その代わりに1のTTLを記録した後、1秒後のレコードを削除しないでください。上記セクション6.6に記載されているネットワーク上の複数のマルチキャストDNSの応答者の場合には、応答者の1がシャットダウンして、誤ってそのレコードにパケット別れを送信した場合、それは救助」に、独自の応答を送信するために、他の協力レスポンダに1秒を与えます「彼らは失効し、削除されたレコードの前に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Announcements to Flush Outdated Cache Entries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2。古いキャッシュエントリをフラッシュするお知らせ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever a host has a resource record with new data, or with what might potentially be new data (e.g., after rebooting, waking from sleep, connecting to a new network link, or changing IP address), the host needs to inform peers of that new data. In cases where the host has not been continuously connected and participating on the network link, it MUST first probe to re-verify uniqueness of its unique records, as described above in Section 8.1, &#34;Probing&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストは、新しいデータ、または持つとリソースレコードを持っているときは常に潜在的に新しいデータ（例えば、眠りから目覚め、再起動する新しいネットワークリンクに接続、またはIPアドレスを変更した後）、ホストはそのピアに通知する必要があるかもしれないもの新しいデータ。 8.1節で上述したように、ホストが連続的に接続され、ネットワークリンク上で参加していない場合には、第一のプローブは「プロービング」、独自のレコードの一意性を再確認しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Having completed the Probing step, if necessary, the host MUST then send a series of unsolicited announcements to update cache entries in its neighbor hosts. In these unsolicited announcements, if the record is one that has been verified unique, the host sets the most significant bit of the rrclass field of the resource record. This bit, the cache-flush bit, tells neighboring hosts that this is not a shared record type. Instead of merging this new record additively into the cache in addition to any previous records with the same name, rrtype, and rrclass, all old records with that name, rrtype, and rrclass that were received more than one second ago are declared invalid, and marked to expire from the cache in one second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
必要に応じて、プロービングステップを完了すると、ホストは、その近隣ホストのキャッシュエントリを更新するために、迷惑発表のシリーズを送らなければなりません。レコードがユニークに検証されたものである場合には、これらの迷惑の発表では、ホストは、リソースレコードのrrclassフィールドの最上位ビットを設定します。このビット、キャッシュフラッシュビットは、これは共有レコードタイプではないことを、隣接するホストに指示します。代わりに、同じ名前、rrtype、およびrrclassと以前の記録に加えてキャッシュに付加的にこの新しいレコードをマージするのは、その名前、rrtype、1秒以上前に受けたrrclass持つすべての古いレコードが無効と宣言されており、 1秒間にキャッシュから期限切れにマーク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The semantics of the cache-flush bit are as follows: normally when a resource record appears in a Resource Record Section of the DNS response it means, &#34;This is an assertion that this information is true&#34;. When a resource record appears in a Resource Record Section of the DNS response with the cache-flush bit set, it means, &#34;This is an assertion that this information is the truth and the whole truth, and anything you may have heard more than a second ago regarding records of this name/rrtype/rrclass is no longer true&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにキャッシュフラッシュビットの意味は以下のとおりです。リソースレコードは、それが意味DNS応答のリソースレコードセクションに表示され、通常時に、「これは、この情報が真実であるという主張です」。リソースレコードがキャッシュ・フラッシュビットが設定されたDNS応答のリソースレコードセクションに表示されたら、それは意味し、「これは、この情報が真実と真実であるという主張である、そしてあなたがより多くを聞いたことがあるかもしれ何も二前にこの名前/ rrtypeの記録について/ rrclassは「もはや真実ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To accommodate the case where the set of records from one host constituting a single unique RRSet is too large to fit in a single packet, only cache records that are more than one second old are flushed. This allows the announcing host to generate a quick burst of packets back-to-back on the wire containing all the members of the RRSet. When receiving records with the cache-flush bit set, all records older than one second are marked to be deleted one second in the future. One second after the end of the little packet burst, any records not represented within that packet burst will then be expired from all peer caches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一のユニークな資源レコード集合を構成する一つのホストからのレコードのセットが単一のパケット、フラッシュされる1秒以上古いだけキャッシュレコードに収まるには大きすぎる場合に対応するため。これは、発表ホストは資源レコード集合のすべてのメンバーを含むワイヤ上でバックツーバックパケットの迅速なバーストを生成することができます。キャッシュフラッシュビットがセットされたレコードを受信した場合、1秒より古いすべてのレコードは、将来的には1秒を削除するようにマークされています。一秒の小さなパケットバーストの終了後に、そのパケットのバースト内で表現されていないすべてのレコードは、すべてのピアキャッシュから期限切れになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any time a host sends a response packet containing some members of a unique RRSet, it MUST send the entire RRSet, preferably in a single packet, or if the entire RRSet will not fit in a single packet, in a quick burst of packets sent as close together as possible. The host MUST set the cache-flush bit on all members of the unique RRSet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いつでもホストがユニークな資源レコード集合の一部のメンバーを含む応答パケットを送信し、それは好ましくは単一のパケットで、全体の資源レコード集合を送らなければなりません、または全体の資源レコード集合として送信されたパケットの迅速なバーストでは、単一のパケットに収まらない場合可能性として一緒に閉じます。ホストは、ユニークな資源レコード集合のすべてのメンバーにキャッシュフラッシュビットを設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another reason for waiting one second before deleting stale records from the cache is to accommodate bridged networks. For example, a host&#39;s address record announcement on a wireless interface may be bridged onto a wired Ethernet and may cause that same host&#39;s Ethernet address records to be flushed from peer caches. The one-second delay gives the host the chance to see its own announcement arrive on the wired Ethernet, and immediately re-announce its Ethernet interface&#39;s address records so that both sets remain valid and live in peer caches.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュから古いレコードを削除する前に1秒を待っているもう一つの理由は、ブリッジネットワークに対応するためにあります。例えば、無線インターフェイス上のホストのアドレスレコードの発表は、有線イーサネットに架橋されていてもよいし、同じホストのイーサネットアドレスレコードは、ピア・キャッシュからフラッシュされることを引き起こす可能性があります。 1秒の遅延は、ホストに両方のセットが有効なままとピア・キャッシュに住むように、自身の発表は有線イーサネットに到着見て、すぐに再発表、イーサネットインターフェイスのアドレスレコードする機会を与えてくれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These rules, about when to set the cache-flush bit and about sending the entire rrset, apply regardless of *why* the response message is being generated. They apply to startup announcements as described in Section 8.3, &#34;Announcing&#34;, and to responses generated as a result of receiving query messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*応答メッセージが生成されている理由は、キャッシュフラッシュビットを設定するときについて、全体のRRセットを送るに関するこれらのルールは、*にかかわらず適用されます。彼らは、「発表」、およびクエリーメッセージを受信した結果として生成された応答に、8.3節で説明したようにアナウンスを起動するために適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cache-flush bit is only set in records in the Resource Record Sections of Multicast DNS responses sent to UDP port 5353.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュフラッシュビットのみがUDPポート5353に送信されたマルチキャストDNS応答のリソースレコードセクション内のレコードに設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cache-flush bit MUST NOT be set in any resource records in a response message sent in legacy unicast responses to UDP ports other than 5353.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュフラッシュビットは、5353以外のUDPポートにレガシーユニキャスト応答で送信された応答メッセージ内のすべてのリソースレコードに設定してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cache-flush bit MUST NOT be set in any resource records in the Known-Answer list of any query message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュフラッシュビットは、任意のクエリメッセージの既知解リスト内の任意のリソースレコードに設定してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cache-flush bit MUST NOT ever be set in any shared resource record. To do so would cause all the other shared versions of this resource record with different rdata from different responders to be immediately deleted from all the caches on the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュフラッシュビットは、これまで任意の共有リソースレコードに設定してはいけません。そうするためには、直ちにネットワーク上のすべてのキャッシュから削除するために、異なる応答が異なるRDATAと、このリソースレコードの他のすべての共有バージョンを引き起こします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cache-flush bit does *not* apply to questions listed in the Question Section of a Multicast DNS message. The top bit of the rrclass field in questions is used for an entirely different purpose (see Section 5.4, &#34;Questions Requesting Unicast Responses&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュフラッシュビットは、マルチキャストDNSメッセージの質問セクションに記載されている質問には適用されません* *ありません。質問でrrclassフィールドの上部ビットは（セクション5.4、「ユニキャスト応答の要求質問」を参照）全く異なる目的のために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the cache-flush bit is NOT part of the resource record class. The cache-flush bit is the most significant bit of the second 16-bit word of a resource record in a Resource Record Section of a Multicast DNS message (the field conventionally referred to as the rrclass field), and the actual resource record class is the least significant fifteen bits of this field. There is no Multicast DNS resource record class 0x8001. The value 0x8001 in the rrclass field of a resource record in a Multicast DNS response message indicates a resource record with class 1, with the cache-flush bit set. When receiving a resource record with the cache-flush bit set, implementations should take care to mask off that bit before storing the resource record in memory, or otherwise ensure that it is given the correct semantic interpretation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュフラッシュビットは、リソースレコードクラスの一部ではないことに注意してください。キャッシュフラッシュビットは、マルチキャストDNSメッセージ（従来rrclassフィールドと呼ばれるフィールド）のリソースレコードセクション内のリソースレコードの2番目の16ビットワードの最上位ビットであり、実際のリソースレコードクラスでありますこのフィールドの最下位15ビット。マルチキャストDNSリソースレコードのクラス0x8001はありません。マルチキャストDNS応答メッセージにおけるリソースレコードのrrclassフィールドの値0x8001は、キャッシュフラッシュビットのセットと、クラス1リソースレコードを示しています。キャッシュフラッシュビットがセットされたリソースレコードを受信した場合、実装はメモリにリソースレコードを格納する前にそのビットをマスクするために世話をする、またはそれ以外の場合は、正しい意味解釈を与えていることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The reuse of the top bit of the rrclass field only applies to conventional resource record types that are subject to caching, not to pseudo-RRs like OPT [RFC2671], TSIG [RFC2845], TKEY [RFC2930], SIG0 [RFC2931], etc., that pertain only to a particular transport level message and not to any actual DNS data. Since pseudo-RRs should never go into the Multicast DNS cache, the concept of a cache-flush bit for these types is not applicable. In particular, the rrclass field of an OPT record encodes the sender&#39;s UDP payload size, and should be interpreted as a sixteen-bit length value in the range 0-65535, not a one-bit flag and a fifteen-bit length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
rrclassフィールドの最上位ビットの再利用のみなどOPT [RFC2671]のような、TSIG [RFC2845]、TKEY [RFC2930]、SIG0 [RFC2931]、-RRを擬似しないように、キャッシュの対象となる従来のリソースレコードタイプに適用します。その特定のトランスポートレベルメッセージになく、任意の実際のDNSデータにのみ関連します。擬似のRRは、マルチキャストDNSキャッシュに入るべきではありませんので、これらのタイプのキャッシュフラッシュビットの概念が適用されません。具体的には、OPTレコードのrrclassフィールドは、送信者のUDPペイロードサイズを符号化し、範囲0-65535なく、1ビットのフラグと15ビット長で16ビット長の値として解釈されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. Cache Flush on Topology change
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3。トポロジ変更のキャッシュフラッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the hardware on a given host is able to indicate physical changes of connectivity, then when the hardware indicates such a change, the host should take this information into account in its Multicast DNS cache management strategy. For example, a host may choose to immediately flush all cache records received on a particular interface when that cable is disconnected. Alternatively, a host may choose to adjust the remaining TTL on all those records to a few seconds so that if the cable is not reconnected quickly, those records will expire from the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
与えられたホスト上のハードウェアは、ハードウェアは、このような変化を示しているときに、接続の物理的な変化を示すことができる場合は、ホストがそのマルチキャストDNSキャッシュ管理戦略の中でこの情報を考慮すべきです。例えば、ホストは直ちにそのケーブルが切断されたときにすべてのキャッシュ・レコードは、特定のインターフェイスで受信フラッシュすることを選択することができます。また、ホストは、ケーブルを迅速に再接続されていない場合は、それらのレコードがキャッシュから期限切れになるように、数秒にすべてのそれらの記録に残っているTTLを調整することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Likewise, when a host reboots, wakes from sleep, or undergoes some other similar discontinuous state change, the cache management strategy should take that information into account.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストの再起動時に同様に、スリープ状態から復帰し、またはいくつかの他の同様の不連続な状態変化を起こし、キャッシュ管理戦略は、アカウントにその情報を取る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. Cache Flush on Failure Indication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4。障害表示のキャッシュフラッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Sometimes a cache record can be determined to be stale when a client attempts to use the rdata it contains, and the client finds that rdata to be incorrect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時には、キャッシュレコードは、クライアントが含まれているRDATAを使用しようとすると、クライアントは正しくないとそのRDATAを見つけたときに古いであると判断することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, the rdata in an address record can be determined to be incorrect if attempts to contact that host fail, either because (for an IPv4 address on a local subnet) ARP requests for that address go unanswered, because (for an IPv6 address with an on-link prefix) ND requests for that address go unanswered, or because (for an address on a remote network) a router returns an ICMP &#34;Host Unreachable&#34; error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えば、アドレスレコードでRDATAは、試みは、そのホストに連絡する場合は正しくないと判断することができる失敗し、いずれかの理由そのアドレスのARP要求があるため（IPv6アドレスを持つため、未回答行く（ローカルサブネット上のIPv4アドレス用）上のリンクそのアドレスのプレフィックス）ND要求未解答に行く、または（リモートネットワーク上のアドレスのために）ルータはICMPを返すため、エラー「到達不能ホスト」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The rdata in an SRV record can be determined to be incorrect if attempts to communicate with the indicated service at the host and port number indicated are not successful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SRVレコードのRDATAは成功していない試みが示されているホストとポート番号で示されているサービスと通信する場合に誤ったと判定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The rdata in a DNS-SD PTR record can be determined to be incorrect if attempts to look up the SRV record it references are not successful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
試みはSRVレコードも参照が成功しないルックアップする場合は、DNS-SDのPTRレコードでRDATAが正しくないと判断することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The software implementing the Multicast DNS resource record cache should provide a mechanism so that clients detecting stale rdata can inform the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
古いRDATAを検出し、クライアントがキャッシュを知らせることができるように、マルチキャストDNSリソースレコードのキャッシュを実現するソフトウェアは、メカニズムを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the cache receives this hint that it should reconfirm some record, it MUST issue two or more queries for the resource record in dispute. If no response is received within ten seconds, then, even though its TTL may indicate that it is not yet due to expire, that record SHOULD be promptly flushed from the cache.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キャッシュは、それはいくつかのレコードを再確認すべきことは、このヒントを受信すると、それは紛争におけるリソースレコードのための2つ以上のクエリを発行しなければなりません。応答が10秒以内に受信されなかった場合、その後、そのTTLが、まだ有効期限が切れによるものではないことを示していても、そのレコードは、速やかに、キャッシュからフラッシュされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The end result of this is that if a printer suffers a sudden power failure or other abrupt disconnection from the network, its name may continue to appear in DNS-SD browser lists displayed on users&#39; screens. Eventually, that entry will expire from the cache naturally, but if a user tries to access the printer before that happens, the failure to successfully contact the printer will trigger the more hasty demise of its cache entries. This is a sensible trade-off between good user experience and good network efficiency. If we were to insist that printers should disappear from the printer list within 30 seconds of becoming unavailable, for all failure modes, the only way to achieve this would be for the client to poll the printer at least every 30 seconds, or for the printer to announce its presence at least every 30 seconds, both of which would be an unreasonable burden on most networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この最終結果は、プリンタがネットワークから突然停電又は他の突然の切断を受ける場合、その名前がユーザーの画面に表示されるDNS-SDブラウザリストに表示し続けることができるということです。結局、そのエントリは当然キャッシュから期限切れになりますが、ユーザーはそれが起こる前に、プリンタにアクセスしようとすると、成功したプリンタに連絡する失敗はそのキャッシュエントリのより多くの性急な崩壊の引き金となるでしょう。これは、優れたユーザーエクスペリエンスと優れたネットワーク効率の間で賢明なトレードオフです。私たちは、プリンタは、すべての故障モードのため、利用できなくなってきてから30秒以内にプリンタリストから消えなければならないと主張していた場合は、これを達成する唯一の方法は、プリンタに、少なくとも30秒ごとにポーリングするクライアントのために、またはプリンタのためになります30秒ごとに、どちらもほとんどのネットワーク上の不合理な負担となり、少なくともその存在を発表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. Passive Observation Of Failures (POOF)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5。障害の受動的な観察（POOF）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A host observes the multicast queries issued by the other hosts on the network. One of the major benefits of also sending responses using multicast is that it allows all hosts to see the responses (or lack thereof) to those queries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストは、ネットワーク上の他のホストによって発行されたマルチキャストクエリを観察します。マルチキャストを使用しても、送信応答の主な利点の1つは、それがすべてのホストがこれらのクエリに対する応答（またはその欠如）を参照してくださいすることを可能にするということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a host sees queries, for which a record in its cache would be expected to be given as an answer in a multicast response, but no such answer is seen, then the host may take this as an indication that the record may no longer be valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストがキャッシュ内のレコードは、マルチキャスト応答で答えとして与えることが予想されるため、クエリを、見ているが、そのような答えが見られない場合、ホストはレコードはもはやないかもしれないことを示すものとしてこれを取ること有効。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After seeing two or more of these queries, and seeing no multicast response containing the expected answer within ten seconds, then even though its TTL may indicate that it is not yet due to expire, that record SHOULD be flushed from the cache. The host SHOULD NOT perform its own queries to reconfirm that the record is truly gone. If every host on a large network were to do this, it would cause a lot of unnecessary multicast traffic. If host A sends multicast queries that remain unanswered, then there is no reason to suppose that host B or any other host is likely to be any more successful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
10秒以内に予想される答えを含むマルチキャスト応答をこれらのクエリの2つ以上を見ていない、と見た後、そのTTLが、まだ有効期限切れによるものではないことを示していても、そのレコードがキャッシュからフラッシュされるべきです。ホストレコードが本当になくなっていることを再確認するために、独自のクエリを実行しないでください。大規模なネットワーク上のすべてのホストがこれを行うとしたら、それは不要なマルチキャストトラフィックの多くを引き起こします。ホストAは未解決のままマルチキャストクエリーを送信した場合、ホストBまたは任意の他のホストは、任意のより多くの成功である可能性が高いと想定する理由はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The previous section, &#34;Cache Flush on Failure Indication&#34;, describes a situation where a user trying to print discovers that the printer is no longer available. By implementing the passive observation described here, when one user fails to contact the printer, all hosts on the network observe that failure and update their caches accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前のセクション、「障害表示上のフラッシュキャッシュ」、印刷しようとし、ユーザーがプリンタが使用できなくなったことを検出していない状況を説明しています。 1人のユーザがプリンタに連絡することを失敗したときに、ここで説明した受動的観測を実施することにより、ネットワーク上のすべてのホストはその失敗を観察し、それに応じてキャッシュを更新します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Source Address Check
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.送信元アドレスチェック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All Multicast DNS responses (including responses sent via unicast) SHOULD be sent with IP TTL set to 255. This is recommended to provide backwards-compatibility with older Multicast DNS queriers (implementing a draft version of this document, posted in February 2004) that check the IP TTL on reception to determine whether the packet originated on the local link. These older queriers discard all packets with TTLs other than 255.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、古いマルチキャストDNSのクエリアとの下位互換性を提供することをお勧めします255に設定（ユニキャスト経由で送信された応答を含む）すべてのマルチキャストDNS応答がIP TTLを送ってください（この文書のドラフト版を実装し、2004年2月に投稿された）ことを確認してくださいレセプションのIP TTLは、パケットがローカルリンク上の起源かどうかを判断します。これらの古いクエリアは、255以外のTTLを持つすべてのパケットを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A host sending Multicast DNS queries to a link-local destination address (including the 224.0.0.251 and FF02::FB link-local multicast addresses) MUST only accept responses to that query that originate from the local link, and silently discard any other response packets. Without this check, it could be possible for remote rogue hosts to send spoof answer packets (perhaps unicast to the victim host), which the receiving machine could misinterpret as having originated on the local link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
だけ静かにローカルリンクから発信そのクエリに対する応答を受け入れ、必要があります（224.0.0.251とFF02 :: FBリンクローカルマルチキャストアドレスを含む）、リンクローカル宛先アドレスにマルチキャストDNSクエリを送信するホストは、他の応答を破棄しますパケット。リモート不正なホストはスプーフィング回答パケットを送信するためには、このチェックがなければ、それは可能かもしれない受信機は、ローカルリンク上で発信されたと誤って解釈することができ、（おそらく被害者のホストにユニキャスト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The test for whether a response originated on the local link is done in two ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答は、ローカルリンク上の起源かどうかについての試験は、次の2つの方法で行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* All responses received with a destination address in the IP header that is the mDNS IPv4 link-local multicast address 224.0.0.251 or the mDNS IPv6 link-local multicast address FF02::FB are necessarily deemed to have originated on the local link, regardless of source IP address. This is essential to allow devices to work correctly and reliably in unusual configurations, such as multiple logical IP subnets overlayed on a single link, or in cases of severe misconfiguration, where devices are physically connected to the same link, but are currently misconfigured with completely unrelated IP addresses and subnet masks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*のmDNS IPv4リンクローカルマルチキャストアドレス224.0.0.251又はmDNSのIPv6リンクローカルマルチキャストアドレスFF02であるIPヘッダ:: FB内の宛先アドレスで受信されたすべての応答は、必ずしもかかわらず、ローカルリンク上で発信しているものとみなされます送信元IPアドレスの。これは、デバイス、またはデバイスが物理的に同じリンクに接続されているが、現在は完全に間違って設定されている深刻な設定ミスの場合には、そのような単一のリンク上に重ね複数の論理IPサブネットとして異例の構成で正しくかつ確実に動作できるようにすることが不可欠です無関係なIPアドレスとサブネットマスク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* For responses received with a unicast destination address in the IP header, the source IP address in the packet is checked to see if it is an address on a local subnet. An IPv4 source address is determined to be on a local subnet if, for (one of) the address(es) configured on the interface receiving the packet, (I &amp; M) == (P &amp; M), where I and M are the interface address and subnet mask respectively, P is the source IP address from the packet, &#39;&amp;&#39; represents the bitwise logical &#39;and&#39; operation, and &#39;==&#39; represents a bitwise equality test. An IPv6 source address is determined to be on the local link if, for any of the on-link IPv6 prefixes on the interface receiving the packet (learned via IPv6 router advertisements or otherwise configured on the host), the first &#39;n&#39; bits of the IPv6 source address match the first &#39;n&#39; bits of the prefix address, where &#39;n&#39; is the length of the prefix being considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
* IPヘッダ内のユニキャスト宛先アドレスで受信した応答のために、パケットの送信元IPアドレスは、ローカルサブネット上のアドレスであるかどうかを確認するためにチェックされます。 IPv4ソースアドレス（の1つ）IおよびMは、アドレス（ES）パケットを受信するインターフェイスで設定、（I＆M）==（P＆M）のため、もしローカルサブネット上にあると判定されインタフェースアドレスとサブネットマスクは、それぞれ、Pは、パケットの送信元IPアドレスである「＆」ビット単位の論理「と」操作を表し、「==」ビット単位の等価試験を表します。 IPv6ソースアドレスは、パケットを受信したインターフェイス上のリンク上のIPv6プレフィックス（IPv6ルータ広告を介して学習されるか、またはそうでなければ、ホスト上で設定）、最初の「n」ビットのいずれかのために、もしローカルリンク上であると判定されIPv6ソースアドレスは、「n」個のプレフィクスの長さが考慮されているプレフィックスアドレスの最初の「n」ビットと一致します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since queriers will ignore responses apparently originating outside the local subnet, a responder SHOULD avoid generating responses that it can reasonably predict will be ignored. This applies particularly in the case of overlayed subnets. If a responder receives a query addressed to the mDNS IPv4 link-local multicast address 224.0.0.251, from a source address not apparently on the same subnet as the responder (or, in the case of IPv6, from a source IPv6 address for which the responder does not have any address with the same prefix on that interface), then even if the query indicates that a unicast response is preferred (see Section 5.4, &#34;Questions Requesting Unicast Responses&#34;), the responder SHOULD elect to respond by multicast anyway, since it can reasonably predict that a unicast response with an apparently non-local source address will probably be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クエリアが明らかにローカルサブネット外からの応答を無視しますので、応答者は、それが合理的に無視される予測できるという応答を生成することは避けてください。これは特に、オーバーレイさサブネットの場合に適用されます。応答者はクエリはソースIPv6アドレスから、レスポンダー（または、IPv6の場合と同じサブネット上に明らかにソースアドレスからのmDNS IPv4リンクローカルマルチキャストアドレス224.0.0.251にない宛て受信した場合応答者がクエリは、ユニキャスト応答が好まれていることを示していても（第5.4節を参照してください「ユニキャスト応答を要求質問」）、その後、）そのインターフェイス上の同じ接頭辞を持つ任意のアドレスを持っていない、応答者は、とにかくマルチキャストで応答することを選択すべきですそれ以来、合理的に明らかに非ローカル送信元アドレスを持つユニキャスト応答は、おそらく無視されることを予測することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Special Characteristics of Multicast DNS Domains
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
マルチキャストDNSドメインの12特別な特性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unlike conventional DNS names, names that end in &#34;.local.&#34; have only local significance. The same is true of names within the IPv4 link-local reverse mapping domain &#34;254.169.in-addr.arpa.&#34; and the IPv6 link-local reverse mapping domains &#34;8.e.f.ip6.arpa.&#34;, &#34;9.e.f.ip6.arpa.&#34;, &#34;a.e.f.ip6.arpa.&#34;, and &#34;b.e.f.ip6.arpa.&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
従来のDNS名、で終わる名前とは異なり、「.localの。」唯一のローカルな意味を持っています。同じことは、IPv4リンクローカル逆マッピングドメイン内の名前の本当である「254.169.in-addr.arpa。」そして、IPv6のリンクローカル逆マッピングドメイン &#34;8.e.f.ip6.arpa。&#34;、 &#34;9.e.f.ip6.arpa。&#34;、 &#34;a.e.f.ip6.arpa。&#34;、および &#34;b.e.f.ip6.arpa。&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These names function primarily as protocol identifiers, rather than as user-visible identifiers. Even though they may occasionally be visible to end users, that is not their primary purpose. As such, these names should be treated as opaque identifiers. In particular, the string &#34;local&#34; should not be translated or localized into different languages, much as the name &#34;localhost&#34; is not translated or localized into different languages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの名前は、プロトコル識別子としてではなく、ユーザーに表示識別子として主に機能します。彼らは時折、エンドユーザーに表示されていても、それは彼らの第一の目的ではありません。そのため、これらの名前は、不透明な識別子として扱われるべきです。具体的には、「ローカル」の文字列は、「localhost」という名前のように多くは、さまざまな言語に翻訳またはローカライズされていない、別の言語に翻訳やローカライズすべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Conventional Unicast DNS seeks to provide a single unified namespace, where a given DNS query yields the same answer no matter where on the planet it is performed or to which recursive DNS server the query is sent. In contrast, each IP link has its own private &#34;.local.&#34;, &#34;254.169.in-addr.arpa.&#34; and IPv6 link-local reverse mapping namespaces, and the answer to any query for a name within those domains depends on where that query is asked. (This characteristic is not unique to Multicast DNS. Although the original concept of DNS was a single global namespace, in recent years, split views, firewalls, intranets, DNS geolocation, and the like have increasingly meant that the answer to a given DNS query has become dependent on the location of the querier.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
従来のユニキャストDNSは、指定されたDNSクエリが同じ答えに、地球上でそれを実行またはクエリが送信される再帰的なDNSサーバーたとされていない問題をもたらし、単一の統一された名前空間を、提供することを目的とします。これとは対照的に、各IPリンクは、独自のプライベート「.localの。」、 『254.169.in-addr.arpa』を持っていますそして、IPv6のリンクローカルの逆マッピングの名前空間、およびそれらのドメイン内の名前のための任意のクエリに対する答えは、そのクエリが求められている場所によって異なります。 （この特性は、マルチキャストDNSに固有のものではありません。DNSのオリジナルのコンセプトは、近年では、単一のグローバル名前空間、あったが、分割ビュー、ファイアウォール、イントラネット、DNSの地理的位置、などがますます与えられたDNSクエリに対する答えたことを意味していますクエリアの場所に依存するようになっています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IPv4 name server address for a Multicast DNS domain is 224.0.0.251. The IPv6 name server address for a Multicast DNS domain is FF02::FB. These are multicast addresses; therefore, they identify not a single host but a collection of hosts, working in cooperation to maintain some reasonable facsimile of a competently managed DNS zone. Conceptually, a Multicast DNS domain is a single DNS zone; however, its server is implemented as a distributed process running on a cluster of loosely cooperating CPUs rather than as a single process running on a single CPU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSドメインのIPv4ネームサーバのアドレスは224.0.0.251です。マルチキャストDNSドメインのIPv6ネームサーバアドレスはFF02 :: FBです。これらは、マルチキャストアドレスです。そのため、彼らは有能マネージドDNSゾーンのいくつかの合理的なファクシミリを維持するために協力して作業し、単一のホストが、ホストの集合を識別しません。概念的には、マルチキャストDNSドメインは、単一のDNSゾーンです。しかし、そのサーバは緩くなく、単一のCPU上で実行されている単一のプロセスとしてよりもCPUを協働のクラスタ上で実行されている分散プロセスとして実現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS domains are not delegated from their parent domain via use of NS (Name Server) records, and there is also no concept of delegation of subdomains within a Multicast DNS domain. Just because a particular host on the network may answer queries for a particular record type with the name &#34;example.local.&#34; does not imply anything about whether that host will answer for the name &#34;child.example.local.&#34;, or indeed for other record types with the name &#34;example.local.&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSドメインはNS（ネームサーバー）レコードの使用を介して、その親ドメインから委譲されていない、とマルチキャストDNSドメイン内のサブドメインの委任という概念もありません。ネットワーク上の特定のホストは名前で特定のレコードタイプのクエリに答えることだけであるため、「example.local。」そのホストが名前を持つ他のレコードタイプのために実際に「child.example.local」名前を答えるか、するかどうかについては何も意味しない「example.localを。」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are no NS records anywhere in Multicast DNS domains. Instead, the Multicast DNS domains are reserved by IANA, and there is effectively an implicit delegation of all Multicast DNS domains to the 224.0.0.251:5353 and [FF02::FB]:5353 multicast groups, by virtue of client software implementing the protocol rules specified in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どこでもマルチキャストDNSドメインにはNSレコードがありません。代わりに、マルチキャストDNSドメインはIANAによって予約されており、224.0.0.251:5353と[FF02 :: FB]へのすべてのマルチキャストDNSドメインの暗黙の委任効果があります：5353のマルチキャストグループは、プロトコルを実装したクライアントソフトウェアのおかげで、この文書で指定されたルール。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS zones have no SOA (Start of Authority) record. A conventional DNS zone&#39;s SOA record contains information such as the email address of the zone administrator and the monotonically increasing serial number of the last zone modification. There is no single human administrator for any given Multicast DNS zone, so there is no email address. Because the hosts managing any given Multicast DNS zone are only loosely coordinated, there is no readily available monotonically increasing serial number to determine whether or not the zone contents have changed. A host holding part of the shared zone could crash or be disconnected from the network at any time without informing the other hosts. There is no reliable way to provide a zone serial number that would, whenever such a crash or disconnection occurred, immediately change to indicate that the contents of the shared zone had changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSゾーンにはSOA（Start of Authority）レコードを持っていません。従来のDNSゾーンのSOAレコードは、ゾーン管理者の電子メールアドレスと最後のゾーンの変更の単調に増加するシリアル番号などの情報が含まれています。任意のマルチキャストDNSゾーンには、単一の人間の管理者が行われないため、メールアドレスはありません。任意のマルチキャストDNSゾーンを管理するホストのみが緩く調整されているので、ゾーンの内容が変更されているかどうかを決定するための、容易に入手可能な単調に増加するシリアル番号はありません。共有ゾーンのホスト保持部は、クラッシュまたは他のホストに通知することなく、いつでもネットワークから切断されます。このようなクラッシュや断線が発生したときに、すぐに共有ゾーンの内容が変化したことを示すために、変化するであろうゾーンのシリアル番号を提供するための信頼できる方法はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Zone transfers are not possible for any Multicast DNS zone.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ゾーン転送は、任意のマルチキャストDNSゾーンのために可能ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Enabling and Disabling Multicast DNS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.有効化と無効化マルチキャストDNS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The option to fail-over to Multicast DNS for names not ending in &#34;.local.&#34; SHOULD be a user-configured option, and SHOULD be disabled by default because of the possible security issues related to unintended local resolution of apparently global names. Enabling Multicast DNS for names not ending in &#34;.local.&#34; may be appropriate on a secure isolated network, or on some future network were machines exclusively use DNSSEC for all DNS queries, and have Multicast DNS responders capable of generating the appropriate cryptographic DNSSEC signatures, thereby guarding against spoofing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプションは、フェイルオーバーするマルチキャストDNSに名前がで終わらないために「.localの。」ユーザ設定のオプションであるべきであり、理由は明らかにグローバル名の意図しないローカル解像度に関連する潜在的なセキュリティ上の問題で、デフォルトでは無効にする必要があります。終わらない名前のマルチキャストDNSを有効にする「の.local。」セキュアな分離されたネットワーク上で適切である、または将来のネットワークにあったマシンは、排他的にそれによってなりすましに対する保護、すべてのDNSクエリに対してDNSSECを使用し、適切な暗号DNSSEC署名を生成することができるマルチキャストDNS応答者を有していてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The option to look up unqualified (relative) names by appending &#34;.local.&#34; (or not) is controlled by whether &#34;.local.&#34; appears (or not) in the client&#39;s DNS search list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
追加することによって修飾されていない（相対）名を検索するためのオプション「.localの。」 （またはしない）かどうかによって制御される「.LOCAL。」クライアントのDNS検索リストに表示されます（またはしません）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
No special control is needed for enabling and disabling Multicast DNS for names explicitly ending with &#34;.local.&#34; as entered by the user. The user doesn&#39;t need a way to disable Multicast DNS for names ending with &#34;.local.&#34;, because if the user doesn&#39;t want to use Multicast DNS, they can achieve this by simply not using those names. If a user *does* enter a name ending in &#34;.local.&#34;, then we can safely assume the user&#39;s intention was probably that it should work. Having user configuration options that can be (intentionally or unintentionally) set so that local names don&#39;t work is just one more way of frustrating the user&#39;s ability to perform the tasks they want, perpetuating the view that, &#34;IP networking is too complicated to configure and too hard to use&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別な制御が可能と明示的で終わる名前のマルチキャストDNSを無効にする必要はありません「.localの。」ユーザーが入力した通り。ユーザーは、で終わる名前のマルチキャストDNSを無効にする方法は必要ありません「の.local」を、ユーザーがマルチキャストDNSを使用したくない場合、彼らは単にそれらの名前を使用しないことによって、これを達成することができますので。ユーザーが*で終わる名前入力しない場合は「.localのを。」、そして私たちは、安全にユーザの意図は、それが動作する必要があることをおそらくだったと仮定することができます。ローカル名が動作しないように設定（意図的にまたは意図せずに）することができ、ユーザの設定オプションを持つことは、IPネットワーキングがにあまりにも複雑である」、という見解を永続、彼らが望むタスクを実行するユーザの能力をイライラのひとつの方法です「設定および使用するにはあまりにも難しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Considerations for Multiple Interfaces
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
複数のインタフェースのための14の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A host SHOULD defend its dot-local host name on all active interfaces on which it is answering Multicast DNS queries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストは、マルチキャストDNSクエリに応答しているすべてのアクティブなインターフェイス上のドットローカルホスト名を守るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the event of a name conflict on *any* interface, a host should configure a new host name, if it wishes to maintain uniqueness of its host name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはそのホスト名の一意性を維持することを希望する場合は任意の*インターフェイス*上の名前の競合が発生した場合、ホストは、新しいホスト名を設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A host may choose to use the same name (or set of names) for all of its address records on all interfaces, or it may choose to manage its Multicast DNS interfaces independently, potentially answering to a different name (or set of names) on different interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上のホストは、すべてのインターフェイス上のアドレスレコードのすべてに同じ名前（または名前のセット）を使用することを選択することができ、またはそれは、独立してそのマルチキャストDNSのインターフェイスを管理することもできます、潜在的に別の名前（または名前のセット）に答えます異なるインタフェース。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Except in the case of proxying and other similar specialized uses, addresses in IPv4 or IPv6 address records in Multicast DNS responses MUST be valid for use on the interface on which the response is being sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロキシおよび他の類似の特殊な用途の場合を除き、マルチキャストDNS応答のIPv4またはIPv6アドレスレコードのアドレスは、応答が送信されているインターフェイス上で使用するために有効である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Just as the same link-local IP address may validly be in use simultaneously on different links by different hosts, the same link-local host name may validly be in use simultaneously on different links, and this is not an error. A multihomed host with connections to two different links may be able to communicate with two different hosts that are validly using the same name. While this kind of name duplication should be rare, it means that a host that wants to fully support this case needs network programming APIs that allow applications to specify on what interface to perform a link-local Multicast DNS query, and to discover on what interface a Multicast DNS response was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じリンクローカルIPアドレスが有効に異なるホストによって異なるリンク上で同時に使用であってもよいのと同様に、同じリンクローカルホスト名が有効に異なるリンク上で同時に使用であってもよく、これはエラーではありません。二つの異なるリンクへの接続を持つマルチホームホストは有効に同じ名前を使用している二つの異なるホストと通信することができます。名前の重複のこの種のはまれである必要がありますが、それは完全にこのケースをサポートしたいホストは、アプリケーションがリンクローカルマルチキャストDNSクエリを実行するどのようなインターフェイスに指定すると、どのようなインターフェイス上で発見することができネットワークプログラミングAPIを必要としていることを意味しマルチキャストDNS応答が受信されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is one other special precaution that multihomed hosts need to take. It&#39;s common with today&#39;s laptop computers to have an Ethernet connection and an 802.11 [IEEE.802.11] wireless connection active at the same time. What the software on the laptop computer can&#39;t easily tell is whether the wireless connection is in fact bridged onto the same network segment as its Ethernet connection. If the two networks are bridged together, then packets the host sends on one interface will arrive on the other interface a few milliseconds later, and care must be taken to ensure that this bridging does not cause problems:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストが取る必要があるマルチホームで一つの他の特別な予防措置があります。これは、イーサネット接続と同時にアクティブ802.11 [IEEE.802.11]ワイヤレス接続を持つことが、今日のラップトップコンピュータで一般的です。どのようなラップトップコンピュータ上のソフトウェアは、簡単に言うことができないことは、ワイヤレス接続が実際にそのイーサネット接続と同じネットワークセグメント上に架設されているかどうかです。 2つのネットワークがブリッジ接続されている場合、ホストは数ミリ秒後に他のインターフェイスに到着しますつのインターフェイス上で送信パケット、およびケアは、このブリッジングが問題を起こさないように注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the host announces its host name (i.e., its address records) on its wireless interface, those announcement records are sent with the cache-flush bit set, so when they arrive on the Ethernet segment, they will cause all the peers on the Ethernet to flush the host&#39;s Ethernet address records from their caches. The Multicast DNS protocol has a safeguard to protect against this situation: when records are received with the cache-flush bit set, other records are not deleted from peer caches immediately, but are marked for deletion in one second. When the host sees its own wireless address records arrive on its Ethernet interface, with the cache-flush bit set, this one-second grace period gives the host time to respond and re-announce its Ethernet address records, to reinstate those records in peer caches before they are deleted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストは、その無線インタフェース上のホスト名（つまり、そのアドレスレコード）を発表したとき、それらの発表レコードは、キャッシュフラッシュビットセットで送信されますので、彼らは、イーサネットセグメントに到着したとき、彼らは、イーサネット上のすべてのピアが発生しますそれらのキャッシュからホストのEthernetアドレスレコードをフラッシュします。マルチキャストDNSプロトコルは、このような状況から保護するための安全装置があります。レコードは、キャッシュフラッシュビットのセットで受信されると、他のレコードはすぐにピア・キャッシュから削除されていませんが、1秒間に削除対象としてマークされています。ホストは、自身の無線アドレスレコードがキャッシュフラッシュビットのセットで、そのイーサネットインターフェイスに到着見た場合、この1秒の猶予期間が対応し、ピアでこれらのレコードを復元するために、そのイーサネットアドレスレコードを再発表するホスト時間を与えますキャッシュは削除される前に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described, this solves one problem, but creates another, because when those Ethernet announcement records arrive back on the wireless interface, the host would again respond defensively to reinstate its wireless records, and this process would continue forever, continuously flooding the network with traffic. The Multicast DNS protocol has a second safeguard, to solve this problem: the cache-flush bit does not apply to records received very recently, within the last second. This means that when the host sees its own Ethernet address records arrive on its wireless interface, with the cache-flush bit set, it knows there&#39;s no need to re-announce its wireless address records again because it already sent them less than a second ago, and this makes them immune from deletion from peer caches. (See Section 10.2.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
説明したように、これらのイーサネット発表レコードは、無線インターフェイスに戻って到着したとき、ホストは再びその無線レコードを回復するために防御的に応答するであろう、そしてこのプロセスが継続的にトラフィックでネットワークをフラッディング、永遠に継続するので、これは、一つの問題を解決するが、別のものを作成し、 。マルチキャストDNSプロトコルは、この問題を解決するために、第二安全装置を持っている：キャッシュフラッシュビットは、最後の秒以内に、非常に最近受信したレコードには適用されません。これは、それがすでに未満秒前にそれらを送信したため、その無線アドレスレコードを再発表する必要はもうありません知っている、ホストは独自のイーサネットアドレスレコードがキャッシュフラッシュビットのセットで、その無線インタフェースに到着見たときにことを意味し、これはピア・キャッシュからの削除からそれらを免疫なります。 （10.2節を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Considerations for Multiple Responders on the Same Machine
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
同じマシン上の複数のレスポンダのための15の注意事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is possible to have more than one Multicast DNS responder and/or querier implementation coexist on the same machine, but there are some known issues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じマシン上で複数のマルチキャストDNS応答者および/またはクエリア実装の共存を持つことが可能ですが、いくつかの既知の問題があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. Receiving Unicast Responses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1。ユニキャスト応答を受信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In most operating systems, incoming *multicast* packets can be delivered to *all* open sockets bound to the right port number, provided that the clients take the appropriate steps to allow this. For this reason, all Multicast DNS implementations SHOULD use the SO_REUSEPORT and/or SO_REUSEADDR options (or equivalent as appropriate for the operating system in question) so they will all be able to bind to UDP port 5353 and receive incoming multicast packets addressed to that port. However, unlike multicast packets, incoming unicast UDP packets are typically delivered only to the first socket to bind to that port. This means that &#34;QU&#34; responses and other packets sent via unicast will be received only by the first Multicast DNS responder and/or querier on a system. This limitation can be partially mitigated if Multicast DNS implementations detect when they are not the first to bind to port 5353, and in that case they do not request &#34;QU&#34; responses. One way to detect if there is another Multicast DNS implementation already running is to attempt binding to port 5353 without using SO_REUSEPORT and/or SO_REUSEADDR, and if that fails it indicates that some other socket is already bound to this port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ほとんどのオペレーティングシステムでは、入ってくる*マルチキャスト*パケットは、右のポート番号にバインドされているすべての*オープンソケット*に配信することができ、クライアントはこれを許可するための適切な措置をとるものとします。このため、すべてのマルチキャストDNS実装が（問題のオペレーティングシステムに応じて相当）SO_REUSEPORTおよび/またはSO_REUSEADDRオプションを使用する必要がありますので、彼らはすべてのUDPポート5353にバインドし、着信マルチキャストパケットを受信することができるようになりますそのポート宛。しかし、マルチキャストパケットとは異なり、着信ユニキャストUDPパケットは、通常、そのポートにバインドするだけで最初のソケットに配信されます。これは、「QU」応答とユニキャストを介して送信された他のパケットが最初のマルチキャストDNS応答および/またはシステム上のクエリアによって受信されることを意味します。彼らはポート5353にバインドする最初でない場合、マルチキャストDNS実装が検出され、その場合には、彼らが「QU」の応答を要求しない場合は、この制限は、部分的に緩和することができます。別のマルチキャストDNS実装がすでに実行があるかどうかを検出するための一つの方法は、SO_REUSEPORTおよび/またはSO_REUSEADDRを使用せずに、ポート5353への結合を試みることであり、それが失敗した場合には、他のいくつかのソケットがすでにこのポートにバインドされていることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. Multipacket Known-Answer lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2。マルチパケット既知解リスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a Multicast DNS querier issues a query with too many Known Answers to fit into a single packet, it divides the Known-Answer list into two or more packets. Multicast DNS responders associate the initial truncated query with its continuation packets by examining the source IP address in each packet. Since two independent Multicast DNS queriers running on the same machine will be sending packets with the same source IP address, from an outside perspective they appear to be a single entity. If both queriers happened to send the same multipacket query at the same time, with different Known-Answer lists, then they could each end up suppressing answers that the other needs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
あまりにも多くの既知の答えをクエリを発行クエリアマルチキャストDNSは、単一のパケットに収まるようにすると、2つ以上のパケットに既知解リストを分割します。マルチキャストDNSの応答は、各パケットの送信元のIPアドレスを調べることによって、その継続パケットで最初の切り捨てクエリを関連付けます。同じマシン上で実行されている2つの独立したマルチキャストDNSのクエリアは、外部の視点から、同じソースIPアドレスを持つパケットを送信されますので、それらは単一のエンティティであるように思われます。両方クエリアは異なる既知解リストを、同時に同じマルチパケットクエリを送信するために起こった場合、それらは互いに必要があるとの回答を抑えてしまう可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3. Efficiency
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3。効率
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If different clients on a machine were each to have their own independent Multicast DNS implementation, they would lose certain efficiency benefits. Apart from the unnecessary code duplication, memory usage, and CPU load, the clients wouldn&#39;t get the benefit of a shared system-wide cache, and they would not be able to aggregate separate queries into single packets to reduce network traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マシン上の異なるクライアントが自分自身の独立したマルチキャストDNSの実装を持っているそれぞれのだったら、彼らは特定の効率の利点を失うことになります。別に不要なコードの重複、メモリ使用量、およびCPUの負荷から、クライアントが共有システム全体のキャッシュの恩恵を得ないだろう、と彼らは、ネットワークトラフィックを削減するために、単一のパケットに別のクエリを集約することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4. Recommendation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4。勧告
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because of these issues, this document encourages implementers to design systems with a single Multicast DNS implementation that provides Multicast DNS services shared by all clients on that machine, much as most operating systems today have a single TCP implementation, which is shared between all clients on that machine. Due to engineering constraints, there may be situations where embedding a &#34;user-level&#34; Multicast DNS implementation in the client application software is the most expedient solution, and while this will usually work in practice, implementers should be aware of the issues outlined in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの問題のため、この文書は、そのマシン上のすべてのクライアントで共有されるマルチキャストDNSサービスを提供する単一のマルチキャストDNS実装でシステムを設計し、実装を奨励し、今日のほとんどのオペレーティングシステムなどの多くは上のすべてのクライアント間で共有される単一のTCPの実装を、持っていますそのマシン。エンジニアリングの制約のために、クライアント・アプリケーション・ソフトウェアにおける「ユーザレベル」を埋め込むマルチキャストDNS実装が最も好都合ソリューションであり、これは通常、実際に動作しますが、実装者はこの中に概説の問題を認識しておく必要があり状況があるかもしれませんセクション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. Multicast DNS Character Set
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.マルチキャストDNS文字セット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Historically, Unicast DNS has been used with a very restricted set of characters. Indeed, conventional DNS is usually limited to just twenty-six letters, ten digits and the hyphen character, not even allowing spaces or other punctuation. Attempts to remedy this for Unicast DNS have been badly constrained by the perceived need to accommodate old buggy legacy DNS implementations. In reality, the DNS specification itself actually imposes no limits on what characters may be used in names, and good DNS implementations handle any arbitrary eight-bit data without trouble. &#34;Clarifications to the DNS Specification&#34; [RFC2181] directly discusses the subject of allowable character set in Section 11 (&#34;Name syntax&#34;), and explicitly states that DNS names may contain arbitrary eight-bit data. However, the old rules for ARPANET host names back in the 1980s required host names to be just letters, digits, and hyphens [RFC1034], and since the predominant use of DNS is to store host address records, many have assumed that the DNS protocol itself suffers from the same limitation. It might be accurate to say that there could be hypothetical bad implementations that do not handle eight-bit data correctly, but it would not be accurate to say that the protocol doesn&#39;t allow names containing eight-bit data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
歴史的に、ユニキャストDNSは、文字の非常に制限されたセットで使用されてきました。確かに、従来のDNSは、通常は二十から六文字、10桁の数字とハイフン文字、いなくてもできるようにスペースやその他の句読点に限定されています。ユニキャストDNSのためにこれを是正しようとすると、ひどく古いバギーレガシーDNS実装に対応するために、知覚の必要性によって制約されています。実際には、DNSの仕様自体は、実際に文字を名前に使用することができるものには制限を課していない、との良好なDNSの実装では問題なく、任意の8ビットのデータを扱います。 「DNS仕様の明確化」[RFC2181]は、直接セクション11（「名前の構文」）に設定された許容文字の主題を議論し、明示的にDNS名は任意の8ビットのデータが含まれていてもよいと述べています。しかし、1980年代におけるARPANETホスト名の古いルールは、単に文字、数字、およびハイフン[RFC1034]であることをホスト名を必要とし、DNSの主な使用は、ホストアドレスのレコードを格納することがあるため、多くは、DNSプロトコルと仮定していますそれ自体は同じ制限を受けます。正確に8ビットのデータを処理しない架空の悪い実装があるかもしれないと言うことは正確かもしれませんが、プロトコルは8ビットのデータを含む名前を許可していないと言うことは正確ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS is a new protocol and doesn&#39;t (yet) have old buggy legacy implementations to constrain the design choices. Accordingly, it adopts the simple obvious elegant solution: all names in Multicast DNS MUST be encoded as precomposed UTF-8 [RFC3629] &#34;Net-Unicode&#34; [RFC5198] text.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSは新しいプロトコルであり、（まだ）設計上の選択を制約するために、古いバギーレガシー実装を持っていません。したがって、それは簡単な明白なエレガントなソリューションを採用しています：マルチキャストDNS内のすべての名前は、合成済みUTF-8 [RFC3629]「ネットユニコード」[RFC5198]テキストとして符号化されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some users of 16-bit Unicode have taken to stuffing a &#34;zero-width nonbreaking space&#34; character (U+FEFF) at the start of each UTF-16 file, as a hint to identify whether the data is big-endian or little-endian, and calling it a &#34;Byte Order Mark&#34; (BOM). Since there is only one possible byte order for UTF-8 data, a BOM is neither necessary nor permitted. Multicast DNS names MUST NOT contain a &#34;Byte Order Mark&#34;. Any occurrence of the Unicode character U+FEFF at the start or anywhere else in a Multicast DNS name MUST be interpreted as being an actual intended part of the name, representing (just as for any other legal unicode value) an actual literal instance of that character (in this case a zero-width non-breaking space character).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
16ビットUnicodeの一部のユーザーは、データがビッグエンディアンかリトルであるかを識別するためのヒントとして、各UTF-16ファイルの開始時に「ゼロ幅改行なしスペース」の文字（U + FEFF）を詰め込むために行きましたエンディアン、および「バイトオーダーマーク」（BOM）、それを呼び出します。 UTF-8のデータのための唯一の可能なバイト順序がありますので、BOMは必要でも許可でもありません。マルチキャストDNS名は「バイトオーダーマーク」を含めることはできません。マルチキャストDNS名にユニコード文字U + FEFF開始時またはどこか他のいずれかの発生は（単に他の法的ユニコード値のような）を表す、名前の実際の意図された一部であるように、その実際のリテラルインスタンスを解釈しなければなりません（この場合はゼロ幅改行なし空白文字）の文字。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For names that are restricted to US-ASCII [RFC0020] letters, digits, and hyphens, the UTF-8 encoding is identical to the US-ASCII encoding, so this is entirely compatible with existing host names. For characters outside the US-ASCII range, UTF-8 encoding is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
US-ASCII [RFC0020]の文字、数字、およびハイフンに制限されている名前の場合は、UTF-8エンコーディングはUS-ASCIIエンコーディングと同一ですので、これは、既存のホスト名と完全に互換性があります。 US-ASCIIの範囲外の文字については、UTF-8エンコーディングが使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS implementations MUST NOT use any other encodings apart from precomposed UTF-8 (US-ASCII being considered a compatible subset of UTF-8). The reasons for selecting UTF-8 instead of Punycode [RFC3492] are discussed further in Appendix F.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSの実装は合成済みUTF-8から離れて、他のエンコーディングを使用してはならない（US-ASCIIはUTF-8の互換性のサブセットとみなされています）。ピュニコード[RFC3492]のUTF-8の代わりに選択する理由は、付録Fにさらに議論されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The simple rules for case-insensitivity in Unicast DNS [RFC1034] [RFC1035] also apply in Multicast DNS; that is to say, in name comparisons, the lowercase letters &#34;a&#34; to &#34;z&#34; (0x61 to 0x7A) match their uppercase equivalents &#34;A&#34; to &#34;Z&#34; (0x41 to 0x5A). Hence, if a querier issues a query for an address record with the name &#34;myprinter.local.&#34;, then a responder having an address record with the name &#34;MyPrinter.local.&#34; should issue a response. No other automatic equivalences should be assumed. In particular, all UTF-8 multibyte characters (codes 0x80 and higher) are compared by simple binary comparison of the raw byte values. Accented characters are *not* defined to be automatically equivalent to their unaccented counterparts. Where automatic equivalences are desired, this may be achieved through the use of programmatically generated CNAME records. For example, if a responder has an address record for an accented name Y, and a querier issues a query for a name X, where X is the same as Y with all the accents removed, then the responder may issue a response containing two resource records: a CNAME record &#34;X CNAME Y&#34;, asserting that the requested name X (unaccented) is an alias for the true (accented) name Y, followed by the address record for Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユニキャストDNS [RFC1034]、[RFC1035]、マルチキャストDNSに適用における場合、非感受性のための単純なルール。それは、小文字「」から「Z」（0x7Aのへの0x61）は（0x5Aに0×41）「を」から「Z」をその大文字の等価物と一致する名前の比較で、と言うことです。したがって、クエリアが名前のアドレスレコードのクエリを発行した場合、「myprinter.local。」、そして名前のアドレスレコード持つ応答「MyPrinter.localを。」応答を発行する必要があります。他の自動等価性が想定されるべきではありません。具体的には、すべてのUTF-8マルチバイト文字（コードは0x80と高い）は、生のバイト値の単純なバイナリ比較によって比較されます。アクセント付き文字は、* *そのアクセントのない相手に自動的に同等になるように定義されていません。自動等価性が所望される場合、これはプログラムで生成されたCNAMEレコードの使用を介して達成することができます。レスポンダがアクセントの名前Y用のアドレスレコードを持っている、とクエリアはXが削除されたすべてのアクセントとYと同じ名前のX、のためのクエリを発行した場合、その後、応答者は、2つのリソースを含む応答を発行することができます記録：CNAMEレコードの「X CNAME Y」、要求された名前のX（アクセントのない）は、Y用のアドレスレコードに続いて、真（アクセント）名Yの別名であることを主張します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Multicast DNS Message Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.マルチキャストDNSメッセージサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 1987 DNS specification [RFC1035] restricts DNS messages carried by UDP to no more than 512 bytes (not counting the IP or UDP headers). For UDP packets carried over the wide-area Internet in 1987, this was appropriate. For link-local multicast packets on today&#39;s networks, there is no reason to retain this restriction. Given that the packets are by definition link-local, there are no Path MTU issues to consider.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1987 DNS仕様[RFC1035]はせいぜい512バイト（IPまたはUDPヘッダ数えない）にUDPによって運ばDNSメッセージを制限します。 1987年に広域インターネット上で実施したUDPパケットの場合、これは適切でした。今日のネットワーク上のリンクローカルマルチキャストパケットの場合、この制限を保持する理由はありません。パケットは、定義リンクローカルであることを考えると、考慮すべき一切のパスMTUの問題はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS messages carried by UDP may be up to the IP MTU of the physical interface, less the space required for the IP header (20 bytes for IPv4; 40 bytes for IPv6) and the UDP header (8 bytes).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
およびUDPヘッダ（8バイト）、UDPによって運ばマルチキャストDNSメッセージは、物理インターフェイスのIP MTU、IPヘッダ（IPv6の場合40バイトIPv4の20バイト）のために必要なより少ないスペースまでであり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of a single Multicast DNS resource record that is too large to fit in a single MTU-sized multicast response packet, a Multicast DNS responder SHOULD send the resource record alone, in a single IP datagram, using multiple IP fragments. Resource records this large SHOULD be avoided, except in the very rare cases where they really are the appropriate solution to the problem at hand. Implementers should be aware that many simple devices do not reassemble fragmented IP datagrams, so large resource records SHOULD NOT be used except in specialized cases where the implementer knows that all receivers implement reassembly, or where the large resource record contains optional data which is not essential for correct operation of the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シングルMTUサイズのマルチキャスト応答パケットに収まるには大きすぎる単一のマルチキャストDNSリソースレコードの場合は、マルチキャストDNS応答者は、複数のIPフラグメントを使用して、単一のIPデータグラムで、単独のリソースレコードを送るべきです。この大規模なリソースレコードは、彼らが実際に当面の問題に適切なソリューションです非常に稀なケースを除いて、避けるべきです。実装者はそれほど大きくリソースレコードは、実装者は、すべての受信機が再構築を実装することを知っている、または大規模なリソースレコードは必須ではなく、オプションのデータが含まれている特殊な場合を除いて使用されるべきではない、多くの単純なデバイスは、フラグメント化されたIPデータグラムを再構成していないことに注意する必要がありますクライアントの正しい動作のために。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Multicast DNS packet larger than the interface MTU, which is sent using fragments, MUST NOT contain more than one resource record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
断片を使用して送信されるインターフェイスMTU、より大きなマルチキャストDNSパケットは、複数のリソースレコードを含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Even when fragmentation is used, a Multicast DNS packet, including IP and UDP headers, MUST NOT exceed 9000 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フラグメンテーションが使用されている場合でも、IPおよびUDPヘッダを含むマルチキャストDNSパケットは、9000のバイトを超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that 9000 bytes is also the maximum payload size of an Ethernet &#34;Jumbo&#34; packet [Jumbo]. However, in practice Ethernet &#34;Jumbo&#34; packets are not widely used, so it is advantageous to keep packets under 1500 bytes whenever possible. Even on hosts that normally handle Ethernet &#34;Jumbo&#34; packets and IP fragment reassembly, it is becoming more common for these hosts to implement power-saving modes where the main CPU goes to sleep and hands off packet reception tasks to a more limited processor in the network interface hardware, which may not support Ethernet &#34;Jumbo&#34; packets or IP fragment reassembly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
9000のバイトはまた、イーサネット（登録商標）「ジャンボ」パケット[ジャンボ]の最大ペイロードサイズであることに留意されたいです。しかし、実際のイーサネットに「ジャンボ」パケットは、広く使用されているので、可能な限り1500バイト未満のパケットを維持することが有利であるされていません。でも、通常のイーサネット「ジャンボ」パケットとIPフラグメント再構成を扱うホスト上で、より限定されたプロセッサにパケット受信タスクオフ節電メインCPUがスリープ状態になるモードと手を実装するために、これらのホストのために、より一般的になりつつありますイーサネット「ジャンボ」パケットまたはIPフラグメント再構成をサポートしていない場合があり、ネットワークインターフェースハードウェア、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. Multicast DNS Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.マルチキャストDNSメッセージフォーマット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes specific rules pertaining to the allowable values for the header fields of a Multicast DNS message, and other message format considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、マルチキャストDNSメッセージのヘッダフィールドの許容値、及び他のメッセージフォーマットの考慮に関連する特定のルールを記述しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. ID (Query Identifier)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1。 ID（クエリ識別子）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS implementations SHOULD listen for unsolicited responses issued by hosts booting up (or waking up from sleep or otherwise joining the network). Since these unsolicited responses may contain a useful answer to a question for which the querier is currently awaiting an answer, Multicast DNS implementations SHOULD examine all received Multicast DNS response messages for useful answers, without regard to the contents of the ID field or the Question Section. In Multicast DNS, knowing which particular query message (if any) is responsible for eliciting a particular response message is less interesting than knowing whether the response message contains useful information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSの実装では、ホストブートアップ（またはスリープから目覚めまたはその他のネットワークに参加する）によって発行された未承諾の応答を聞くべきです。これらの迷惑応答がクエリアは、現在の答えを待っている質問への有益な答えが含まれている可能性があるため、マルチキャストDNSの実装は、すべてのIDフィールドの内容や質問セクションに関係なく、有益な答えをマルチキャストDNS応答メッセージを受信調べる必要があります。マルチキャストDNSでは、特定のクエリメッセージ（もしあれば）は、特定の応答メッセージを誘発する責任である知ることは応答メッセージは有用な情報を含んでいるかどうかを知ること未満興味深いです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS implementations MAY cache data from any or all Multicast DNS response messages they receive, for possible future use, provided of course that normal TTL aging is performed on these cached resource records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSの実装は、通常のTTLの老化はこれらのキャッシュされたリソースレコードに対して実行されて当然の提供、彼らは将来の使用のために、受信いずれか、またはすべてのマルチキャストDNS応答メッセージからデータをキャッシュすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In multicast query messages, the Query Identifier SHOULD be set to zero on transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストクエリーメッセージでは、クエリ識別子は、送信時にゼロに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In multicast responses, including unsolicited multicast responses, the Query Identifier MUST be set to zero on transmission, and MUST be ignored on reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
迷惑マルチキャスト応答を含むマルチキャスト応答において、クエリ識別子は、伝送上のゼロに設定しなければならなくて、受信時には無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In legacy unicast response messages generated specifically in response to a particular (unicast or multicast) query, the Query Identifier MUST match the ID from the query message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特定の（ユニキャストまたはマルチキャスト）に応答して特異的に生成された従来のユニキャスト応答メッセージクエリでは、クエリ識別子は、クエリメッセージからIDと一致しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2. QR (Query/Response) Bit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2。 QR（クエリ/レスポンス）ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In query messages the QR bit MUST be zero. In response messages the QR bit MUST be one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クエリーメッセージでQRビットがゼロでなければなりません。応答メッセージでQRビットが1でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3. OPCODE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3。 OPCODE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In both multicast query and multicast response messages, the OPCODE MUST be zero on transmission (only standard queries are currently supported over multicast). Multicast DNS messages received with an OPCODE other than zero MUST be silently ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
両方のマルチキャスト・クエリとマルチキャスト応答メッセージにおいて、オペコードが送信にゼロでなければならない（唯一の標準クエリが現在マルチキャスト上に支持されています）。ゼロ以外のOPCODEで受信したマルチキャストDNSメッセージは静かに無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.4. AA (Authoritative Answer) Bit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.4。 AA（権威回答）ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In query messages, the Authoritative Answer bit MUST be zero on transmission, and MUST be ignored on reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
照会メッセージにおいて、権威応答ビットが伝送にゼロでなければならない、受信時には無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In response messages for Multicast domains, the Authoritative Answer bit MUST be set to one (not setting this bit would imply there&#39;s some other place where &#34;better&#34; information may be found) and MUST be ignored on reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストドメインの応答メッセージでは、公式の答えビットは1に設定しなければならない（このビットを設定しないことは、「より良い」の情報を見つけることができる他のいくつかの場所があります暗示する）と、受信時に無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.5. TC (Truncated) Bit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.5。 TC（切り捨て）ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In query messages, if the TC bit is set, it means that additional Known-Answer records may be following shortly. A responder SHOULD record this fact, and wait for those additional Known-Answer records, before deciding whether to respond. If the TC bit is clear, it means that the querying host has no additional Known Answers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCビットが設定されている場合、クエリーメッセージでは、それは追加の既知解レコードはすぐに、次のことができることを意味しています。応答者は、この事実を記録し、応答するかどうかを決定する前に、これらの追加の既知解レコードを待つべき。 TCビットがクリアされている場合、それはクエリのホストが追加の既知の答えを持っていないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In multicast response messages, the TC bit MUST be zero on transmission, and MUST be ignored on reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャスト応答メッセージにおいて、TCビットが送信にゼロでなければならない、受信時には無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In legacy unicast response messages, the TC bit has the same meaning as in conventional Unicast DNS: it means that the response was too large to fit in a single packet, so the querier SHOULD reissue its query using TCP in order to receive the larger response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レガシーユニキャスト応答メッセージでは、TCビットは、従来のユニキャストDNSと同じ意味を持っている：それはクエリアが大きな応答を受信するためにTCPを使用して、そのクエリを再発行する必要がありますので、応答は、単一のパケットに収まる大きすぎたことを意味し。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.6. RD (Recursion Desired) Bit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.6。 RD（再帰要求）ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In both multicast query and multicast response messages, the Recursion Desired bit SHOULD be zero on transmission, and MUST be ignored on reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストクエリとマルチキャスト応答メッセージの両方において、再帰所望のビットは、送信にゼロでなければならず、受信時には無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.7. RA (Recursion Available) Bit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.7。 RA（再帰可能）ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In both multicast query and multicast response messages, the Recursion Available bit MUST be zero on transmission, and MUST be ignored on reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストクエリとマルチキャスト応答メッセージの両方において、再帰利用可能なビットは、送信にゼロでなければならない、受信時には無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.8. Z (Zero) Bit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.8。 Z（ゼロ）ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In both query and response messages, the Zero bit MUST be zero on transmission, and MUST be ignored on reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
両方のクエリ及びレスポンスメッセージでは、ゼロ・ビットが送信にゼロでなければならない、受信時には無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.9. AD (Authentic Data) Bit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.9。 AD（本物のデータ）ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In both multicast query and multicast response messages, the Authentic Data bit [RFC2535] MUST be zero on transmission, and MUST be ignored on reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
両方のマルチキャスト・クエリとマルチキャスト応答メッセージにおいて、本物のデータビット[RFC2535]は、送信にゼロでなければならない、受信時には無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.10. CD (Checking Disabled) Bit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.10。 CD（チェック無効）ビット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In both multicast query and multicast response messages, the Checking Disabled bit [RFC2535] MUST be zero on transmission, and MUST be ignored on reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストクエリとマルチキャスト応答メッセージの両方に、チェック無効ビット[RFC2535]送信でゼロでなければならない、受信時には無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.11. RCODE (Response Code)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.11。 RCODE（レスポンスコード）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In both multicast query and multicast response messages, the Response Code MUST be zero on transmission. Multicast DNS messages received with non-zero Response Codes MUST be silently ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストクエリーおよびマルチキャスト応答メッセージの両方で、応答コードは送信時にゼロでなければなりません。非ゼロの応答コードを受信したマルチキャストDNSメッセージは静かに無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.12. Repurposing of Top Bit of qclass in Question Section
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.12。質問セクションでQCLASSのトップビットの再利用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the Question Section of a Multicast DNS query, the top bit of the qclass field is used to indicate that unicast responses are preferred for this particular question. (See Section 5.4.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSクエリの質問セクションでは、QCLASSフィールドの先頭ビットは、ユニキャスト応答は、この特定の問題のために好ましいことを示すために使用されます。 （5.4節を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.13. Repurposing of Top Bit of rrclass in Resource Record Sections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.13。リソースレコードのセクションでrrclassのトップビットの再利用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the Resource Record Sections of a Multicast DNS response, the top bit of the rrclass field is used to indicate that the record is a member of a unique RRSet, and the entire RRSet has been sent together (in the same packet, or in consecutive packets if there are too many records to fit in a single packet). (See Section 10.2.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答のリソースレコードのセクションで、rrclassフィールドの最上位ビットは、レコードが一意の資源レコード集合のメンバーであり、全体の資源レコード集合は、同じパケットに、又は連続で（一緒に送信されたことを示すために使用されますパケット）は、単一のパケット内に収まるようにあまりにも多くのレコードがある場合。 （10.2節を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.14. Name Compression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.14。名前圧縮
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When generating Multicast DNS messages, implementations SHOULD use name compression wherever possible to compress the names of resource records, by replacing some or all of the resource record name with a compact two-byte reference to an appearance of that data somewhere earlier in the message [RFC1035].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSメッセージを生成する場合、[メッセージのどこかに早くそのデータの出現にコンパクトな2バイト参照してリソースレコード名の一部またはすべてを置き換えることで、リソースレコードの名前を圧縮するために可能な限り、実装は、名前の圧縮を使用すべきですRFC1035]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This applies not only to Multicast DNS responses, but also to queries. When a query contains more than one question, successive questions in the same message often contain similar names, and consequently name compression SHOULD be used, to save bytes. In addition, queries may also contain Known Answers in the Answer Section, or probe tiebreaking data in the Authority Section, and these names SHOULD similarly be compressed for network efficiency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、マルチキャストDNS応答に、だけでなく、クエリにないのみ適用されます。クエリが複数の質問が含まれている場合は、同じメッセージ内の連続した質問は、多くの場合、類似した名前を含み、その結果、名前圧縮はバイトを保存するために、使用されるべきです。また、クエリはまた、機関セクションの既知の答え部で回答、またはプローブのタイブレイクデータを含んでいてもよいし、これらの名前は、同様にネットワーク効率のために圧縮します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to compressing the *names* of resource records, names that appear within the *rdata* of the following rrtypes SHOULD also be compressed in all Multicast DNS messages:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リソースレコードの*名*を圧縮することに加えて、以下のrrtypesの*のRDATA *内に表示される名前は、すべてのマルチキャストDNSメッセージに圧縮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NS, CNAME, PTR, DNAME, SOA, MX, AFSDB, RT, KX, RP, PX, SRV, NSEC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NS、CNAME、PTR、DNAME、SOA、MX、AFSDB、RT、KX、RP、PX、SRV、NSEC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Until future IETF Standards Action [RFC5226] specifying that names in the rdata of other types should be compressed, names that appear within the rdata of any type not listed above MUST NOT be compressed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他のタイプのRDATAで名前が圧縮されるべきであることを指定する将来のIETF標準アクション[RFC5226]までは、上記に記載されていない任意の型の資源データの中に表示される名前は圧縮されてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations receiving Multicast DNS messages MUST correctly decode compressed names appearing in the Question Section, and compressed names of resource records appearing in other sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSメッセージを受信する実装は正しく質問セクションに表示されて圧縮された名前、および他のセクションに登場するリソースレコードの圧縮された名前をデコードしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, implementations MUST correctly decode compressed names appearing within the *rdata* of the rrtypes listed above. Where possible, implementations SHOULD also correctly decode compressed names appearing within the *rdata* of other rrtypes known to the implementers at the time of implementation, because such forward-thinking planning helps facilitate the deployment of future implementations that may have reason to compress those rrtypes. It is possible that no future IETF Standards Action [RFC5226] will be created that mandates or permits the compression of rdata in new types, but having implementations designed such that they are capable of decompressing all known types helps keep future options open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、実装が正しく上記rrtypesの* RDATAの*内に現れる圧縮名を復号しなければなりません。可能であれば、このような先進的な計画は、これらのrrtypesを圧縮する理由を有していてもよく、将来の実装の展開を促進するのに役立ちますので、実装も正しく、実装時の実装者に知られている他のrrtypesの*のRDATA *内に現れる圧縮された名前をデコードするべきです。何の将来のIETF標準化アクション[RFC5226]を義務付けたり、新しいタイプの中RDATAの圧縮を可能にすることで作成されないことも可能であるが、彼らはオープン、将来の選択肢を保持するのに役立ちますすべての既知のタイプを解凍することができるように設計実装を持ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One specific difference between Unicast DNS and Multicast DNS is that Unicast DNS does not allow name compression for the target host in an SRV record, because Unicast DNS implementations before the first SRV specification in 1996 [RFC2052] may not decode these compressed
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1996年に最初のSRV仕様前にユニキャストDNS実装[RFC2052]は、これらの圧縮復号しない可能性があるため、ユニキャストDNSとマルチキャストDNSとの間の1つの具体的な違いは、ユニキャストDNSがSRVレコードのターゲットホストの名前圧縮を許可しないことです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
records properly. Since all Multicast DNS implementations were created after 1996, all Multicast DNS implementations are REQUIRED to decode compressed SRV records correctly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
適切に記録します。すべてのマルチキャストDNSの実装は1996年以降に作成されたので、すべてのマルチキャストDNS実装が正しく圧縮されたSRVレコードをデコードするために必要とされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In legacy unicast responses generated to answer legacy queries, name compression MUST NOT be performed on SRV records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
従来のクエリに応答するために生成されたレガシーユニキャスト応答では、名前の圧縮は、SRVレコードに対して実行してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. Summary of Differences between Multicast DNS and Unicast DNS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
マルチキャストDNSおよびユニキャストDNSの違いの19まとめ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS shares, as much as possible, the familiar APIs, naming syntax, resource record types, etc., of Unicast DNS. There are, of course, necessary differences by virtue of it using multicast, and by virtue of it operating in a community of cooperating peers, rather than a precisely defined hierarchy controlled by a strict chain of formal delegations from the root. These differences are summarized below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS株、可能な限り、おなじみのAPI、ユニキャストDNSの構文、リソースレコードタイプなどを、命名。そこマルチキャストを使用して、それのおかげで必要な違いは、もちろん、あり、そしてそれのおかげではなく、ルートからの正式な代表団の厳格な連鎖によって制御正確に定義された階層よりも、協力ピアのコミュニティで動作します。これらの違いは以下のとおりであります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS... * uses multicast * uses UDP port 5353 instead of port 53 * operates in well-defined parts of the DNS namespace * has no SOA (Start of Authority) records * uses UTF-8, and only UTF-8, to encode resource record names * allows names up to 255 bytes plus a terminating zero byte * allows name compression in rdata for SRV and other record types * allows larger UDP packets * allows more than one question in a query message * defines consistent results for qtype &#34;ANY&#34; and qclass &#34;ANY&#34; queries * uses the Answer Section of a query to list Known Answers * uses the TC bit in a query to indicate additional Known Answers * uses the Authority Section of a query for probe tiebreaking * ignores the Query ID field (except for generating legacy responses) * doesn&#39;t require the question to be repeated in the response message * uses unsolicited responses to announce new records * uses NSEC records to signal nonexistence of records * defines a unicast-response bit in the rrclass of query questions * defines a cache-flush bit in the rrclass of response records * uses DNS RR TTL 0 to indicate that a record has been deleted * recommends AAAA records in the additional section when responding to rrtype &#34;A&#34; queries, and vice versa * monitors queries to perform Duplicate Question Suppression * monitors responses to perform Duplicate Answer Suppression... * ... and Ongoing Conflict Detection * ... and Opportunistic Caching
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSは... *、UTF-8を使用し、唯一のUTF-8 *何のSOA（権限の開始）レコードを持っていません* DNS名前空間の明確に定義された部品で動作する*マルチキャスト*の代わりにポート53のUDPポート5353を使用しています使用しています*リソースレコードの名前をエンコードするために* 255バイトまでの名前を可能にプラス終端のゼロバイトが* SRVや他のレコードタイプのためのRDATAに名前圧縮を可能にする、より大きなUDPパケットは、クエリメッセージに複数の質問が* QTYPEのための一貫した結果を定義することができます*ことができます「ANY」とQCLASS「ANY」クエリ*クエリIDを無視*プローブタイブレイクのクエリの権限セクションを使用しています*追加の既知の回答を示すために、クエリでTCビットを使用しています*既知の回答を一覧表示するには、クエリの応答セクションを使用しています（レガシー応答を生成するため除く）フィールド*応答メッセージが* *レコードの不存在を知らせるためにNSECレコードを使用して新しいレコードを発表する迷惑応答を使用して繰り返すことが、質問を必要としない*はのrrclassにユニキャスト応答ビットを定義しますクエリQU estions *「A」クエリ、およびその逆をrrtypeに応答するときに、追加のセクションでAAAAレコードを推奨*応答レコードのrrclassにおけるキャッシュフラッシュビット*レコードが削除されたことを示すために、DNS RR TTL 0を使用して定義モニタークエリ重複質問抑制を実行するための*重複回答抑制を実行するための応答を監視... * ...と継続的な競合の検出* ...と日和見キャッシング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. IPv6 Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. IPv6の考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An IPv4-only host and an IPv6-only host behave as &#34;ships that pass in the night&#34;. Even if they are on the same Ethernet, neither is aware of the other&#39;s traffic. For this reason, each physical link may have *two* unrelated &#34;.local.&#34; zones, one for IPv4 and one for IPv6. Since for practical purposes, a group of IPv4-only hosts and a group of IPv6-only hosts on the same Ethernet act as if they were on two entirely separate Ethernet segments, it is unsurprising that their use of the &#34;.local.&#34; zone should occur exactly as it would if they really were on two entirely separate Ethernet segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「夜に渡す船」としてIPv4のみのホストとIPv6専用ホスト振る舞います。彼らは同じイーサネット上にある場合でも、どちらの他のトラフィックを認識していません。このため、各物理リンクは* 2 *無関係「の.local」を持っていることゾーン、IPv4のための1およびIPv6のための1つ。彼らは2つの全く別個のイーサネットセグメント上であるかのように実用的な目的のためにので、IPv4専用ホストのグループと同じイーサネット行為のIPv6専用ホストのグループが、それは驚くであるのそれらの使用「.LOCAL。」それは、彼らが実際には2つのまったく別のイーサネットセグメント上にあったかのようにゾーンは正確に行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A dual-stack (v4/v6) host can participate in both &#34;.local.&#34; zones, and should register its name(s) and perform its lookups both using IPv4 and IPv6. This enables it to reach, and be reached by, both IPv4-only and IPv6-only hosts. In effect, this acts like a multihomed host, with one connection to the logical &#34;IPv4 Ethernet segment&#34;, and a connection to the logical &#34;IPv6 Ethernet segment&#34;. When such a host generates NSEC records, if it is using the same host name for its IPv4 addresses and its IPv6 addresses on that network interface, its NSEC records should indicate that the host name has both A and AAAA records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デュアルスタック（V4 / V6）ホストは、両方に参加できる「.localの。」ゾーンは、その名前を登録し、IPv4とIPv6の両方を使用して、その検索を実行すべきです。これが到達することを可能にし、かつで行くことが、両方のIPv4のみとIPv6専用ホスト。実際には、これは、一つの論理「のIPv4イーサネットセグメント」への接続、および論理「IPv6のイーサネットセグメント」に接続して、マルチホームホストのように作用します。そのようなホストはNSECレコードを生成する際に、そのIPv4アドレスとそのネットワークインターフェイス上のIPv6アドレスのために同じホスト名を使用している場合、そのNSECレコードは、ホスト名がAとAAAA両方のレコードを有することを示すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The algorithm for detecting and resolving name conflicts is, by its very nature, an algorithm that assumes cooperating participants. Its purpose is to allow a group of hosts to arrive at a mutually disjoint set of host names and other DNS resource record names, in the absence of any central authority to coordinate this or mediate disputes. In the absence of any higher authority to resolve disputes, the only alternative is that the participants must work together cooperatively to arrive at a resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前の競合を検出し、解決するためのアルゴリズムは、その性質上、参加者の協力を前提としたアルゴリズムによって、あります。その目的は、ホストのグループが、この座標又は紛争を媒介する任意の中央当局が存在しない場合に、ホスト名と他のDNSリソースレコード名の互いに素セットに到達できるようにすることです。紛争を解決するための任意の高い権限がない場合には、唯一の選択肢は、参加者が解像度に到着するために一緒に協力して作業しなければならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In an environment where the participants are mutually antagonistic and unwilling to cooperate, other mechanisms are appropriate, like manually configured DNS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参加者が相互に拮抗し、協力して不本意である環境では、他の機構は、手動で設定されたDNSのような、適切です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In an environment where there is a group of cooperating participants, but clients cannot be sure that there are no antagonistic hosts on the same physical link, the cooperating participants need to use IPsec signatures and/or DNSSEC [RFC4033] signatures so that they can distinguish Multicast DNS messages from trusted participants (which they process as usual) from Multicast DNS messages from untrusted participants (which they silently discard).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そこに協力、参加者のグループがあるが、クライアントが同じ物理リンクには拮抗ホストがないことを確認することができない環境では、協力する参加者は、彼らが区別できるように、IPsecの署名および/またはDNSSEC [RFC4033]の署名を使用する必要がありますマルチキャストDNS（彼らは静かに捨てる）信頼されていない参加者からのマルチキャストDNSメッセージから信頼され、参加者からのメッセージ（彼らはいつものように処理しています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If DNS queries for *global* DNS names are sent to the mDNS multicast address (during network outages which disrupt communication with the greater Internet) it is *especially* important to use DNSSEC, because the user may have the impression that he or she is communicating with some authentic host, when in fact he or she is really communicating with some local host that is merely masquerading as that name. This is less critical for names ending with &#34;.local.&#34;, because the user should be aware that those names have only local significance and no global authority is implied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*グローバル* DNS名のDNSクエリが（大きいインターネットとの通信を妨害するネットワークの停止中）のmDNSマルチキャストアドレスに送信されている場合、ユーザーが彼または彼女があるという印象を持っている可能性があるので、* DNSSECを使用することが重要特に*です実際には、彼または彼女は本当に単にその名前を装っているいくつかのローカルホストと通信しているとき、いくつかの本物のホストとの通信。これは、で終わる名前のためにそれほど重要では「.localの。」、ユーザーはそれらの名前が唯一のローカルな意味を持っており、グローバルな権限が暗示されていないことに注意する必要がありますので。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Most computer users neglect to type the trailing dot at the end of a fully qualified domain name, making it a relative domain name (e.g., &#34;www.example.com&#34;). In the event of network outage, attempts to positively resolve the name as entered will fail, resulting in application of the search list, including &#34;.local.&#34;, if present. A malicious host could masquerade as &#34;www.example.com.&#34; by answering the resulting Multicast DNS query for &#34;www.example.com.local.&#34;. To avoid this, a host MUST NOT append the search suffix &#34;.local.&#34;, if present, to any relative (partially qualified) host name containing two or more labels. Appending &#34;.local.&#34; to single-label relative host names is acceptable, since the user should have no expectation that a single-label host name will resolve as is. However, users who have both &#34;example.com&#34; and &#34;local&#34; in their search lists should be aware that if they type &#34;www&#34; into their web browser, it may not be immediately clear to them whether the page that appears is &#34;www.example.com&#34; or &#34;www.local&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その相対的なドメイン名（例えば、「www.example.com」）作り、完全修飾ドメイン名の末尾にドットを入力するには、ほとんどのコンピュータユーザーの怠慢。ネットワーク障害が発生した場合、を含む、検索リストのアプリケーションで、その結果、失敗する「.localの。」、存在する場合に入力として積極的に名前を解決しようとします。悪質なホストがになりすます可能性があり、「www.example.com。」 「www.example.com.local。」の結果のマルチキャストDNSクエリに答えることもできます。これを避けるために、ホストが「.localの。」検索のサフィックスを追加してはならない、存在する場合、二つ以上のラベルを含む任意の相対的な（部分的に修飾された）ホスト名に。 &#34;.LOCAL。&#34; 追加ユーザーがあるとして単一ラベルのホスト名が解決されることは期待を持つべきではないので、単一ラベルの相対ホスト名に、許容可能です。しかし、その検索リストの両方に「example.com」を持っていると「ローカル」のユーザーは、彼らが自分のWebブラウザに「WWW」と入力した場合、表示されたページは、「WWWであるかどうかを彼らにすぐに明らかではないかもしれないことに注意する必要があります.example.comと」または &#34;www.local&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS uses UDP port 5353. On operating systems where only privileged processes are allowed to use ports below 1024, no such privilege is required to use port 5353.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSは特権プロセスのみが1024未満のポートを使用することが許可されているオペレーティングシステムではUDPポート5353を使用して、そのような権限は、ポート5353を使用する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA has allocated the UDP port 5353 for the Multicast DNS protocol described in this document [SN].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、この文書[SN]に記載のマルチキャストDNSプロトコルのUDPポート5353を割り当てました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA has allocated the IPv4 link-local multicast address 224.0.0.251 for the use described in this document [MC4].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、この文書[MC4]に記載の使用のためのIPv4リンクローカルマルチキャストアドレス224.0.0.251を割り当てました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA has allocated the IPv6 multicast address set FF0X::FB (where &#34;X&#34; indicates any hexadecimal digit from &#39;1&#39; to &#39;F&#39;) for the use described in this document [MC6]. Only address FF02::FB (link-local scope) is currently in use by deployed software, but it is possible that in the future implementers may experiment with Multicast DNS using larger-scoped addresses, such as FF05::FB (site-local scope) [RFC4291].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、この文書[MC6]に記載の使用のために（「X」は「F」に「1」から任意の16進数を示す）FF0X :: FB設定IPv6マルチキャストアドレスを割り当てました。 :: FB（リンクローカルスコープ）が展開されたソフトウェアによって現在使用中であるが、今後の実装では、このようなFF05 :: FB（サイトローカルなどのより大きなスコープのアドレスを使用して、マルチキャストDNSを試すことが可能ですFF02のアドレスのみスコープ）[RFC4291]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA has implemented the following DNS records:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、次のDNSレコードを実装しています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MDNS.MCAST.NET. IN A 224.0.0.251 251.0.0.224.IN-ADDR.ARPA. IN PTR MDNS.MCAST.NET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MDNS.MCAST.NET。 224.0.0.251 251.0.0.224.IN-ADDR.ARPA、IN。 PTR MDNS.MCAST.NET、IN。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Entries for the AAAA and corresponding PTR records have not been made as there is not yet an RFC providing direction for the management of the IP6.ARPA domain relating to the IPv6 multicast address space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPv6マルチキャストアドレス空間に関連するIP6.ARPAドメインの管理のための方向性を提供するRFCはまだありませんようAAAAとPTRレコードを対応するためのエントリが行われていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The reuse of the top bit of the rrclass field in the Question and Resource Record Sections means that Multicast DNS can only carry DNS records with classes in the range 0-32767. Classes in the range 32768 to 65535 are incompatible with Multicast DNS. IANA has noted this fact, and if IANA receives a request to allocate a DNS class value above 32767, IANA will make sure the requester is aware of this implication before proceeding. This does not mean that allocations of DNS class values above 32767 should be denied, only that they should not be allowed until the requester has indicated that they are aware of how this allocation will interact with Multicast DNS. However, to date, only three DNS classes have been assigned by IANA (1, 3, and 4), and only one (1, &#34;Internet&#34;) is actually in widespread use, so this issue is likely to remain a purely theoretical one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
質問やリソースレコードのセクションでrrclassフィールドの上部ビットの再利用は、マルチキャストDNSが唯一の範囲0〜32767のクラスでDNSレコードを運ぶことができることを意味します。 65535の範囲32768のクラスは、マルチキャストDNSとの互換性がありません。 IANAはこの事実を指摘している、とIANAは32767を超えるDNSクラス値を割り当てるためのリクエストを受信した場合、IANAは、要求側が先に進む前に、この意味合いを認識していることを確認します。これは、32767以上のDNSクラス値の割り当てが依頼者は、彼らがこの割り当ては、マルチキャストDNSと対話する方法を認識していることが示されるまで、彼らは許されるべきではないだけで、拒否されるべきであることを意味するものではありません。しかし、今日まで、わずか3 DNSクラスは、IANAによって割り当てられている（1、3、及び4）、そして唯一の（1、「インターネット」）広く使用に実際にあるので、この問題は純粋に理論的な1とどまる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANA has recorded the list of domains below as being Special-Use Domain Names [RFC6761]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、特殊用途のドメイン名[RFC6761]であるとして、以下のドメインのリストを記録しました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
.local. .254.169.in-addr.arpa. .8.e.f.ip6.arpa. .9.e.f.ip6.arpa. .a.e.f.ip6.arpa. .b.e.f.ip6.arpa.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。地元。 .254.169.in-addr.arpa。 .8.e.f.ip6.arpa。 .9.e.f.ip6.arpa。 .a.e.f.ip6.arpa。 .b.e.f.ip6.arpa。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1. Domain Name Reservation Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1。ドメイン名の予約に関する注意事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The six domains listed above, and any names falling within those domains (e.g., &#34;MyPrinter.local.&#34;, &#34;34.12.254.169.in-addr.arpa.&#34;, &#34;Ink-Jet._pdl-datastream._tcp.local.&#34;) are special [RFC6761] in the following ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記6つのドメイン、及びそれらのドメイン内に入る任意の名前（例えば、「MyPrinter.local。」、「34.12.254.169.in-addr.arpa。」、「インク-Jet._pdl-datastream._tcp.local。」 ）以下の方法で特別な[RFC6761]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Users may use these names as they would other DNS names, entering them anywhere that they would otherwise enter a conventional DNS name, or a dotted decimal IPv4 address, or a literal IPv6 address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らは、他のDNS名と同じように1.ユーザーは、そうでない場合は、従来のDNS名、またはドット付き10進IPv4アドレス、またはリテラルIPv6アドレスを入力してくださいだろうとどこにでも入る、これらの名前を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since there is no central authority responsible for assigning dot-local names, and all devices on the local network are equally entitled to claim any dot-local name, users SHOULD be aware of this and SHOULD exercise appropriate caution. In an untrusted or unfamiliar network environment, users SHOULD be aware that using a name like &#34;www.local&#34; may not actually connect them to the web site they expected, and could easily connect them to a different web page, or even a fake or spoof of their intended web site, designed to trick them into revealing confidential information. As always with networking, end-to-end cryptographic security can be a useful tool. For example, when connecting with ssh, the ssh host key verification process will inform the user if it detects that the identity of the entity they are communicating with has changed since the last time they connected to that name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドットローカル名を割り当て、ローカルネットワーク上のすべてのデバイスが同じように任意のドットのローカル名を請求する権利を担当する何の中央機関がないため、ユーザーはこのことを認識し、適切な注意を払う必要があります。信頼されていないか、不慣れなネットワーク環境では、ユーザーが「www.local」のような名前を使用して、実際に彼らが期待したWebサイトに接続しない可能性があることに注意する必要があり、簡単に別のWebページ、あるいは偽物やそれらを接続することができ機密情報を明らかにそれらをだますために設計されたそれらの意図されたウェブサイトのパロディー。常にネットワークと同様に、エンドツーエンドの暗号化セキュリティは便利なツールになります。 SSHで接続するとき、それは彼らが通信しているエンティティのアイデンティティは、彼らがその名前に接続され、最後の時間以降に変更されたことを検出した場合、SSHホスト鍵の検証プロセスは、ユーザーに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Application software may use these names as they would other similar DNS names, and is not required to recognize the names and treat them specially. Due to the relative ease of spoofing dot-local names, end-to-end cryptographic security remains important when communicating across a local network, just as it is when communicating across the global Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.アプリケーション・ソフトウェアは、彼らが他の同様のDNS名を同じようにこれらの名前を使用することができ、そして名前を認識し、特別にそれらを治療するために必要されていません。ローカルネットワーク経由で通信するときに起因するドットのローカル名を偽装する比較的容易に、エンド・ツー・エンドの暗号化セキュリティは、グローバルなインターネットを介して通信するとき、それがあるのと同様に、依然として重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Name resolution APIs and libraries SHOULD recognize these names as special and SHOULD NOT send queries for these names to their configured (unicast) caching DNS server(s). This is to avoid unnecessary load on the root name servers and other name servers, caused by queries for which those name servers do not have useful non-negative answers to give, and will not ever have useful non-negative answers to give.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.名前解決のAPIやライブラリは特別として、これらの名前を認識すべきであり、その構成された（ユニキャスト）キャッシュDNSサーバ（複数可）にこれらの名前のクエリを送信することはできません。これは、これらのネームサーバを与えるために有用な非負の答えを持っていないクエリによって引き起こさルートネームサーバや他のネームサーバ、上の不要な負荷を回避することで、今までに与えるために有用な非負の答えを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Caching DNS servers SHOULD recognize these names as special and SHOULD NOT attempt to look up NS records for them, or otherwise query authoritative DNS servers in an attempt to resolve these names. Instead, caching DNS servers SHOULD generate immediate NXDOMAIN responses for all such queries they may receive (from misbehaving name resolver libraries). This is to avoid unnecessary load on the root name servers and other name servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.キャッシュDNSサーバは特別なように、これらの名前を認識すべきであり、彼らのためにNSレコードを検索、またはそれ以外の場合はこれらの名前を解決しようとする試みで権威DNSサーバに問い合わせをしないでください。代わりに、キャッシュDNSサーバは、彼らが（ネームリゾルバライブラリをふらちな事から）受け取ることができるようなすべてのクエリの即時NXDOMAIN応答を生成する必要があります。これは、ルートネームサーバや他のネームサーバに不要な負荷を避けるためです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. Authoritative DNS servers SHOULD NOT by default be configurable to answer queries for these names, and, like caching DNS servers, SHOULD generate immediate NXDOMAIN responses for all such queries they may receive. DNS server software MAY provide a configuration option to override this default, for testing purposes or other specialized uses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.権威DNSサーバは、デフォルトではこれらの名前に対するクエリに応答して、そして、DNSサーバをキャッシュするように、彼らが受け取ることができるようなすべてのクエリの即時NXDOMAIN応答を生成する必要があります、設定すべきではありません。 DNSサーバソフトウェアは、テストの目的や他の特殊な用途のために、このデフォルトを上書きする設定オプションを提供してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. DNS server operators SHOULD NOT attempt to configure authoritative DNS servers to act as authoritative for any of these names. Configuring an authoritative DNS server to act as authoritative for any of these names may not, in many cases, yield the expected result. Since name resolver libraries and caching DNS servers SHOULD NOT send queries for those names (see 3 and 4 above), such queries SHOULD be suppressed before they even reach the authoritative DNS server in question, and consequently it will not even get an opportunity to answer them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. DNSサーバのオペレータは、これらの名前のいずれかのための権威として行動する権威DNSサーバを設定しないでください。これらの名前のいずれかのための権威として行動する権威DNSサーバを設定すると、多くの場合、期待される結果が得られない場合があります。ネームリゾルバライブラリとキャッシュDNSサーバはそれらの名前のクエリを送信することはできませんので、彼らも問題の権威DNSサーバーに到達する前に、このようなクエリが抑制されるべきで、（上記3及び4を参照）、その結果、それも答えるために機会を得ることはありませんそれら。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
7. DNS Registrars MUST NOT allow any of these names to be registered in the normal way to any person or entity. These names are reserved protocol identifiers with special meaning and fall outside the set of names available for allocation by registrars. Attempting to allocate one of these names as if it were a normal domain name will probably not work as desired, for reasons 3, 4, and 6 above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7. DNSレジストラは、これらの名前のいずれかが任意の個人または団体に通常の方法で登録することを許してはなりません。これらの名前は、レジストラによって割り当てに使用できる名前のセット以外の特別な意味と秋とプロトコル識別子を予約されています。それは通常のドメイン名は、おそらく上記の理由3、4、および6のために、などの所望の動作しませんでしたかのように、これらの名前のいずれかを割り当てることをしようとしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The concepts described in this document have been explored, developed, and implemented with help from Ran Atkinson, Richard Brown, Freek Dijkstra, Erik Guttman, Kyle McKay, Pasi Sarolahti, Pekka Savola, Robby Simpson, Mark Townsley, Paul Vixie, Bill Woodcock, and others. Special thanks go to Bob Bradley, Josh Graessley, Scott Herscher, Rory McGuire, Roger Pantos, and Kiren Sekar for their significant contributions. Special thanks also to Kerry Lynn for converting the document to xml2rfc form in May 2010, and to Area Director Ralph Droms for shepherding the document through its final steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書に記載された概念は、探求開発、および蘭アトキンソン、リチャード・ブラウン、フリークダイクストラ、エリック・ガットマン、カイル・マッケイ、パシSarolahti、ペッカSavola、ロビー・シンプソン、マークTownsley、ポール・ヴィクシー、ビル・ウッドコックからの助けを借りて実施されてきましたその他。特別な感謝は彼らの重要な貢献のためのボブ・ブラッドリー、ジョシュGraessley、スコットHerscher、ロリー・マクガイア、ロジャーPantos、およびKirenスカールに行きます。その最終段階を通じて文書を牧するために2010年5月で、そして地域ディレクターラルフDromsにフォームをxml2rfcする文書を変換するためにもケリー・リンに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
24. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
24.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
24.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
24.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MC4] IANA, &#34;IPv4 Multicast Address Space Registry&#34;, &lt;http://www.iana.org/assignments/multicast-addresses/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MC4] IANA、 &#34;IPv4マルチキャストアドレス空間のレジストリ&#34;、&lt;http://www.iana.org/assignments/multicast-addresses/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MC6] IANA, &#34;IPv6 Multicast Address Space Registry&#34;, &lt;http://www.iana.org/assignments/ ipv6-multicast-addresses/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[MC6] IANA、 &#34;IPv6マルチキャストアドレス空間のレジストリ&#34;、&lt;http://www.iana.org/assignments/のIPv6マルチキャスト・アドレス/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC0020] Cerf, V., &#34;ASCII format for network interchange&#34;, RFC 20, October 1969.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC0020]サーフ、V.、 &#34;ネットワークの交換のためのASCIIフォーマット&#34;、RFC 20、1969年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1034] Mockapetris, P., &#34;Domain names - concepts and facilities&#34;, STD 13, RFC 1034, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1034] Mockapetris、P.、 &#34;ドメイン名 - 概念と設備&#34;、STD 13、RFC 1034、1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1035] Mockapetris, P., &#34;Domain names - implementation and specification&#34;, STD 13, RFC 1035, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1035] Mockapetris、P.、 &#34;ドメイン名 - 実装及び仕様&#34;、STD 13、RFC 1035、1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3629] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, STD 63, RFC 3629, November 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3629] Yergeau、F.、 &#34;UTF-8、ISO 10646の変換フォーマット&#34;、STD 63、RFC 3629、2003年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4034] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &#34;Resource Records for the DNS Security Extensions&#34;, RFC 4034, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4034]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 &#34;DNSセキュリティ拡張機能のためのリソースレコード&#34;、RFC 4034、2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5198] Klensin, J. and M. Padlipsky, &#34;Unicode Format for Network Interchange&#34;, RFC 5198, March 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5198] Klensin、J.とM. Padlipsky、 &#34;ネットワークインターチェンジのUnicodeフォーマット&#34;、RFC 5198、2008年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6195] Eastlake 3rd, D., &#34;Domain Name System (DNS) IANA Considerations&#34;, BCP 42, RFC 6195, March 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6195]イーストレイク3日、D.、 &#34;ドメインネームシステム（DNS）IANAの考慮事項&#34;、BCP 42、RFC 6195、2011年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6761] Cheshire, S. and M. Krochmal, &#34;Special-Use Domain Names&#34;, RFC 6761, February 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6761]チェシャー、S.とM. Krochmal、 &#34;特殊用途ドメイン名&#34;、RFC 6761、2013年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SN] IANA, &#34;Service Name and Transport Protocol Port Number Registry&#34;, &lt;http://www.iana.org/assignments/ service-names-port-numbers/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SN] IANA、「サービス名とトランスポートプロトコルポート番号レジストリ」、&lt;http://www.iana.org/assignments/サービス名・ポート番号/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
24.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
24.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[B4W] &#34;Bonjour for Windows&#34;, &lt;http://en.wikipedia.org/wiki/Bonjour_(software)&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[B4W] &#34;Windows用のBonjour&#34;、&lt;http://en.wikipedia.org/wiki/Bonjour_（ソフトウェア）&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BJ] Apple Bonjour Open Source Software, &lt;http://developer.apple.com/bonjour/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BJ]アップルのBonjourオープンソースソフトウェア、&lt;http://developer.apple.com/bonjour/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IEEE.802.3] &#34;Information technology - Telecommunications and information exchange between systems - Local and metropolitan area networks - Specific requirements - Part 3: Carrier Sense Multiple Access with Collision Detection (CMSA/CD) Access Method and Physical Layer Specifications&#34;, IEEE Std 802.3-2008, December 2008, &lt;http://standards.ieee.org/getieee802/802.3.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IEEE.802.3]「情報技術 - 地方とメトロポリタンエリアネットワーク -   - 電気通信及びシステム間の情報交換の具体的な要件 - パート3：衝突検出（CMSA / CD）アクセス方法および物理層仕様搬送波感知多重アクセス」、IEEE STD 802.3から2008、2008年12月、&lt;http://standards.ieee.org/getieee802/802.3.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IEEE.802.11] &#34;Information technology - Telecommunications and information exchange between systems - Local and metropolitan area networks - Specific requirements - Part 11: Wireless LAN Medium Access Control (MAC) and Physical Layer (PHY) Specifications&#34;, IEEE Std 802.11-2007, June 2007, &lt;http://standards.ieee.org/getieee802/802.11.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[IEEE.802.11]「情報技術 - 電気通信及びシステム間の情報交換 - 地方とメトロポリタンエリアネットワーク - 特定の要件 - パート11：無線LAN媒体アクセス制御（MAC）および物理層（PHY）仕様」、IEEE STD 802.11-2007 、2007年6月、&lt;http://standards.ieee.org/getieee802/802.11.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Jumbo] &#34;Ethernet Jumbo Frames&#34;, November 2009, &lt;http://www.ethernetalliance.org/library/whitepaper/ ethernet-jumbo-frames/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ジャンボ]「イーサネットジャンボフレーム」、2009年11月、&lt;http://www.ethernetalliance.org/library/whitepaper/イーサネットジャンボフレーム/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[NIAS] Cheshire, S. &#34;Discovering Named Instances of Abstract Services using DNS&#34;, Work in Progress, July 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
進歩、2001年7月に、作品「DNSを使用して抽象サービスの名前付きインスタンスを検出」[NIAS]チェシャー、S.。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[NSD] &#34;NsdManager | Android Developer&#34;, June 2012, &lt;http://developer.android.com/reference/ android/net/nsd/NsdManager.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[NSD] &#34;NsdManager | Androidデベロッパー&#34;、2012年6月、&lt;http://developer.android.com/reference/アンドロイド/ネット/ NSD / NsdManager.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2052] Gulbrandsen, A. and P. Vixie, &#34;A DNS RR for specifying the location of services (DNS SRV)&#34;, RFC 2052, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2052] Gulbrandsenの、A.及びP.いるVixie、 &#34;サービスの場所を特定するためのDNS RR（DNSのSRV）&#34;、RFC 2052、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2132] Alexander, S. and R. Droms, &#34;DHCP Options and BOOTP Vendor Extensions&#34;, RFC 2132, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2132]アレクサンダー、S.とR. Droms、 &#34;DHCPオプションとBOOTPベンダー拡張機能&#34;、RFC 2132、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2136] Vixie, P., Ed., Thomson, S., Rekhter, Y., and J. Bound, &#34;Dynamic Updates in the Domain Name System (DNS UPDATE)&#34;, RFC 2136, April 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2136]いるVixie、P.編、トムソン、S.、Rekhter、Y.、およびJ.はバウンド、 &#34;ドメインネームシステムにおける動的更新（DNS更新）&#34;、RFC 2136、1997年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2181] Elz, R. and R. Bush, &#34;Clarifications to the DNS Specification&#34;, RFC 2181, July 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;DNS仕様の明確化&#34; [RFC2181]エルツ、R.とR.ブッシュ、RFC 2181、1997年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2535] Eastlake 3rd, D., &#34;Domain Name System Security Extensions&#34;, RFC 2535, March 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2535]イーストレーク第3、D.、 &#34;ドメインネームシステムのセキュリティ拡張機能&#34;、RFC 2535、1999年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2671] Vixie, P., &#34;Extension Mechanisms for DNS (EDNS0)&#34;, RFC 2671, August 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2671]いるVixie、P.、 &#34;DNS用拡張メカニズム（EDNS0）&#34;、RFC 2671、1999年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2845] Vixie, P., Gudmundsson, O., Eastlake 3rd, D., and B. Wellington, &#34;Secret Key Transaction Authentication for DNS (TSIG)&#34;, RFC 2845, May 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2845]いるVixie、P.、グドムンソン、O.、イーストレイク3日、D.、およびB.ウェリントン、 &#34;DNSのための秘密鍵トランザクション認証（TSIG）&#34;、RFC 2845、2000年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2930] Eastlake 3rd, D., &#34;Secret Key Establishment for DNS (TKEY RR)&#34;, RFC 2930, September 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2930]イーストレーク第3、D.、 &#34;DNSのための秘密鍵確立（TKEYのRR）&#34;、RFC 2930、2000年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2931] Eastlake 3rd, D., &#34;DNS Request and Transaction Signatures ( SIG(0)s )&#34;, RFC 2931, September 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2931]イーストレイク3日、D.、 &#34;DNS要求とトランザクション署名（SIG（0）S）&#34;、RFC 2931、2000年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3007] Wellington, B., &#34;Secure Domain Name System (DNS) Dynamic Update&#34;, RFC 3007, November 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3007]ウェリントン、B.、RFC 3007、2000年11月 &#34;ドメインネームシステム（DNS）動的更新をセキュア&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3492] Costello, A., &#34;Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)&#34;, RFC 3492, March 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3492]コステロ、A.、 &#34;ピュニコード：アプリケーションにおける国際化ドメイン名のUnicodeのブートストリングのエンコード（IDNA）&#34;、RFC 3492、2003年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3927] Cheshire, S., Aboba, B., and E. Guttman, &#34;Dynamic Configuration of IPv4 Link-Local Addresses&#34;, RFC 3927, May 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3927]チェシャー、S.、Aboba、B.、およびE.ガットマン、 &#34;IPv4のリンクローカルアドレスの動的構成&#34;、RFC 3927、2005年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4033] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &#34;DNS Security Introduction and Requirements&#34;, RFC 4033, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4033]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 &#34;DNSセキュリティ序論と要件&#34;、RFC 4033、2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4291] Hinden, R. and S. Deering, &#34;IP Version 6 Addressing Architecture&#34;, RFC 4291, February 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4291] HindenとR.とS.デアリング、 &#34;IPバージョン6アドレッシング体系&#34;、RFC 4291、2006年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4795] Aboba, B., Thaler, D., and L. Esibov, &#34;Link-local Multicast Name Resolution (LLMNR)&#34;, RFC 4795, January 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4795] Aboba、B.、ターラー、D.、およびL. Esibov、 &#34;リンクローカルマルチキャスト名前解決（LLMNR）&#34;、RFC 4795、2007年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4861] Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &#34;Neighbor Discovery for IP version 6 (IPv6)&#34;, RFC 4861, September 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4861] Narten氏、T.、Nordmarkと、E.、シンプソン、W.、およびH.ソリマン、 &#34;IPバージョン6（IPv6）のための近隣探索&#34;、RFC 4861、2007年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4862] Thomson, S., Narten, T., and T. Jinmei, &#34;IPv6 Stateless Address Autoconfiguration&#34;, RFC 4862, September 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4862]トムソン、S.、Narten氏、T.、およびT.神明、 &#34;IPv6のステートレスアドレス自動設定&#34;、RFC 4862、2007年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5226] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 5226, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5226] Narten氏、T.とH. Alvestrand、 &#34;RFCsにIANA問題部に書くためのガイドライン&#34;、BCP 26、RFC 5226、2008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5890] Klensin, J., &#34;Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework&#34;, RFC 5890, August 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5890] Klensin、J.、 &#34;アプリケーション（IDNA）のための国際化ドメイン名：定義とドキュメントフレームワーク&#34;、RFC 5890、2010年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6281] Cheshire, S., Zhu, Z., Wakikawa, R., and L. Zhang, &#34;Understanding Apple&#39;s Back to My Mac (BTMM) Service&#34;, RFC 6281, June 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6281]チェシャー、S.、朱、Z.、Wakikawa、R.、およびL.チャン、RFC 6281、2011年6月、 &#34;どこでもMy Mac（BTMM）サービスにAppleのバックを理解します&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6760] Cheshire, S. and M. Krochmal, &#34;Requirements for a Protocol to Replace the AppleTalk Name Binding Protocol (NBP)&#34;, RFC 6760, February 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6760]チェシャー、S.及びM. Krochmal、RFC 6760、2013年2月 &#34;プロトコル（NBP）に結合AppleTalkの名前を交換するためのプロトコルのための要件&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6763] Cheshire, S. and M. Krochmal, &#34;DNS-Based Service Discovery&#34;, RFC 6763, February 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6763]チェシャー、S.及びM. Krochmal、 &#34;DNSベースのサービス発見&#34;、RFC 6763、2013年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Zeroconf] Cheshire, S. and D. Steinberg, &#34;Zero Configuration Networking: The Definitive Guide&#34;, O&#39;Reilly Media, Inc., ISBN 0-596-10100-7, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Zeroconfを]チェシャー、S.およびD.スタインバーグ、 &#34;ゼロ構成ネットワーキング：Definitive Guideの&#34;、オライリーメディア社、ISBN 0-596-10100-7、2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A. Design Rationale for Choice of UDP Port Number
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UDPポート番号の選択については、付録A.設計原理
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Arguments were made for and against using UDP port 53, the standard Unicast DNS port. Some of the arguments are given below. The arguments for using a different port were greater in number and more compelling, so that option was ultimately selected. The UDP port &#34;5353&#34; was selected for its mnemonic similarity to &#34;53&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
引数のためにおよびUDPポート53、標準のユニキャストDNSポートを使用してに対して行われました。引数のいくつかを以下に示します。別のポートを使用するための引数の数は大きく、より説得力だったので、そのオプションは、最終的に選ばれました。 UDPポート「5353」は、そのニーモニック類似性を「53」に選ばれました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Arguments for using UDP port 53:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UDPポート53を使用するための引数：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* This is &#34;just DNS&#34;, so it should be the same port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*これは「単なるDNS」であるので、同じポートでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* There is less work to be done updating old resolver libraries to do simple Multicast DNS queries. Only the destination address need be changed. In some cases, this can be achieved without any code changes, just by adding the address 224.0.0.251 to a configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*シンプルなマルチキャストDNSクエリを行うには、古いリゾルバライブラリの更新を行うことにするあまり仕事があります。唯一の宛先アドレスが変更される必要があります。いくつかのケースでは、これは単に設定ファイルにアドレス224.0.0.251を追加することにより、任意のコードの変更なしに達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Arguments for using a different port (UDP port 5353):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（UDPポート5353）別のポートを使用するための引数：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* This is not &#34;just DNS&#34;. This is a DNS-like protocol, but different.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*これは「単なるDNS」ではありません。これは、DNSのようなプロトコルであるが、異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Changing resolver library code to use a different port number is not hard. In some cases, this can be achieved without any code changes, just by adding the address 224.0.0.251:5353 to a configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*別のポート番号を使用するようにリゾルバライブラリのコードを変更することは難しいことではありません。いくつかのケースでは、これは単に設定ファイルにアドレス224.0.0.251:5353を追加することにより、任意のコードの変更なしに達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Using the same port number makes it hard to run a Multicast DNS responder and a conventional Unicast DNS server on the same machine. If a conventional Unicast DNS server wishes to implement Multicast DNS as well, it can still do that, by opening two sockets. Having two different port numbers allows this flexibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*同じポート番号を使用すると、それは難しいマルチキャストDNS応答者と同じマシン上で、従来のユニキャストDNSサーバーを実行することができます。従来のユニキャストDNSサーバーが同様にマルチキャストDNSを実装したい場合、それはまだ二つのソケットを開くことによって、それを行うことができます。二つの異なるポート番号を持つことは、この柔軟性を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Some VPN software hijacks all outgoing traffic to port 53 and redirects it to a special DNS server set up to serve those VPN clients while they are connected to the corporate network. It is questionable whether this is the right thing to do, but it is common, and redirecting link-local multicast DNS packets to a remote server rarely produces any useful results. It does mean, for example, that a user of such VPN software becomes unable to access their local network printer sitting on their desk right next to their computer. Using a different UDP port helps avoid this particular problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*一部のVPNソフトウェアがポート53へのすべての発信トラフィックをハイジャックし、それらが企業ネットワークに接続している間、それらのVPNクライアントにサービスを提供するように設定し、特別なDNSサーバにリダイレクトします。行うには正しいことであるかどうかは疑問であるが、それは一般的であり、リモートサーバへのリンクローカルマルチキャストDNSパケットをリダイレクトすることはめったに任意の有用な結果を生成しません。このようなVPNソフトウェアのユーザは、右隣自分のコンピュータに自分の机の上に座って自分のローカルネットワークプリンタにアクセスできなくなることを、例えば、意味があります。別のUDPポートを使用すると、この特定の問題を回避できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* On many operating systems, unprivileged software may not send or receive packets on low-numbered ports. This means that any software sending or receiving Multicast DNS packets on port 53 would have to run as &#34;root&#34;, which is an undesirable security risk. Using a higher-numbered UDP port avoids this restriction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*多くのオペレーティングシステムでは、非特権ソフトウェアは、小さい番号のポートにパケットを送信または受信できない場合があります。これは、ポート53上でマルチキャストDNSパケットを送信または受信する任意のソフトウェアは、望ましくないセキュリティ上のリスクである、「ルート」として実行しなければならないことを意味します。高い番号のUDPポートを使用することでこの制限を回避することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix B. Design Rationale for Not Using Hashed Multicast Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ハッシュマルチキャストアドレスを使用しないため、付録B.設計原理
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some discovery protocols use a range of multicast addresses, and determine the address to be used by a hash function of the name being sought. Queries are sent via multicast to the address as indicated by the hash function, and responses are returned to the querier via unicast. Particularly in IPv6, where multicast addresses are extremely plentiful, this approach is frequently advocated. For example, IPv6 Neighbor Discovery [RFC4861] sends Neighbor Solicitation messages to the &#34;solicited-node multicast address&#34;, which is computed as a function of the solicited IPv6 address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの発見プロトコルは、マルチキャストアドレスの範囲を使用して、求められている名前のハッシュ関数が使用するアドレスを決定します。クエリは、ハッシュ関数によって示されるように、アドレスにマルチキャストを介して送信され、応答は、ユニキャストを介してクエリアに戻されます。特に、マルチキャストアドレスは非常に豊富ですIPv6の、で、このアプローチは頻繁に提唱されました。例えば、IPv6の近隣探索[RFC4861]は要請IPv6アドレスの関数として計算される「要請ノードマルチキャストアドレス」に近隣要請メッセージを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are some disadvantages to using hashed multicast addresses like this in a service discovery protocol:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービス発見プロトコルでは、このようにハッシュ化されたマルチキャストアドレスを使用するいくつかの欠点があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* When a host has a large number of records with different names, the host may have to join a large number of multicast groups. Each time a host joins or leaves a multicast group, this results in Internet Group Management Protocol (IGMP) or Multicast Listener Discovery (MLD) traffic on the network announcing this fact. Joining a large number of multicast groups can place undue burden on the Ethernet hardware, which typically supports a limited number of multicast addresses efficiently. When this number is exceeded, the Ethernet hardware may have to resort to receiving all multicasts and passing them up to the host networking code for filtering in software, thereby defeating much of the point of using a multicast address range in the first place. Finally, many IPv6 stacks have a fixed limit IPV6_MAX_MEMBERSHIPS, and the code simply fails with an error if a client attempts to exceed this limit. Common values for IPV6_MAX_MEMBERSHIPS are 20 or 31.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*ホストが異なる名前を持つ多数のレコードを持っている場合は、ホストがマルチキャストグループが多数参加する必要があります。ホストがマルチキャストグループに参加するか、去るたびに、これはインターネットグループ管理プロトコル（IGMP）または、この事実を発表して、ネットワーク上のマルチキャストリスナ発見（MLD）トラフィックになります。マルチキャストグループの多数に参加することは、典型的に、効率的なマルチキャストアドレスの数が限られてサポートしているEthernetハードウェア、に過度の負担をかけることができます。この数を超えた場合は、イーサネットハードウェアは、すべてのマルチキャストを受信し、それによって、最初の場所でのマルチキャストアドレス範囲を使用してのポイントの多くを破って、ソフトウェアでフィルタリングするためのホストのネットワークコードにそれらを渡すことに頼る必要があります。最後に、多くのIPv6スタックは固定された制限IPV6_MAX_MEMBERSHIPSがあり、クライアントがこの制限を超過しようとした場合のコードは、単にエラーで失敗します。 IPV6_MAX_MEMBERSHIPSのための一般的な値は、20または31です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Multiple questions cannot be placed in one packet if they don&#39;t all hash to the same multicast address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らは同じマルチキャストアドレスにすべてのハッシュをいない場合*複数の質問には、一つのパケットに配置することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Duplicate Question Suppression doesn&#39;t work if queriers are not seeing each other&#39;s queries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クエリアが互いのクエリが表示されない場合*重複質問抑制は動作しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Duplicate Answer Suppression doesn&#39;t work if responders are not seeing each other&#39;s responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レスポンダが互いの応答が表示されない場合*重複回答の抑制は動作しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Opportunistic Caching doesn&#39;t work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*日和見キャッシュは動作しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Ongoing Conflict Detection doesn&#39;t work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*継続的な競合の検出は動作しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix C. Design Rationale for Maximum Multicast DNS Name Length
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最大マルチキャストDNS名の長さについては、付録C.デザイン理論的根拠
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS names may be up to 255 bytes long (in the on-the-wire message format), not counting the terminating zero byte at the end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS名は、端部で終端ゼロバイトをカウントしない、（オン・ザ・ワイヤメッセージの形式で）最大255バイト長であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;Domain Names - Implementation and Specification&#34; [RFC1035] says:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ドメイン名 - 実装と仕様」[RFC1035]は言います：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Various objects and parameters in the DNS have size limits. They are listed below. Some could be easily changed, others are more fundamental.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DNS内のさまざまなオブジェクトおよびパラメータは、サイズ制限を有します。彼らは以下のとおりです。いくつかは簡単に他の人が、より基本的なもの、変えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
labels 63 octets or less
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
63オクテット以下にラベルを付けます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
names 255 octets or less
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前255オクテット以下
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
the total length of a domain name (i.e., label octets and label length octets) is restricted to 255 octets or less.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ドメイン名（すなわち、ラベルオクテットとラベル長オクテット）の全長は255オクテット以下に制限されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This text does not state whether this 255-byte limit includes the terminating zero at the end of every name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このテキストは、この255バイトの制限は、すべての名前の末尾にゼロを終了含まれているかどうかを述べるものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Several factors lead us to conclude that the 255-byte limit does *not* include the terminating zero:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの要因が255バイトの制限が* *終了ゼロが含まれていないという結論に私たちを導きます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o It is common in software engineering to have size limits that are a power of two, or a multiple of a power of two, for efficiency. For example, an integer on a modern processor is typically 2, 4, or 8 bytes, not 3 or 5 bytes. The number 255 is not a power of two, nor is it to most people a particularly noteworthy number. It is noteworthy to computer scientists for only one reason -- because it is exactly one *less* than a power of two. When a size limit is exactly one less than a power of two, that suggests strongly that the one extra byte is being reserved for some specific reason -- in this case reserved, perhaps, to leave room for a terminating zero at the end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oそれは、効率のために2の累乗、又は2のべき乗の倍数であるサイズ制限を有するようにソフトウェア工学において一般的です。例えば、現代のプロセッサ上の整数は、典型的には、2、4、または8バイトではなく、3又は5バイトです。番号255は、2の累乗ではない、またそれは、ほとんどの人には特に注目に値するの数です。これは、一つだけの理由でコンピュータ科学者に注目すべきである - それは正確に一つの*以下* 2のパワーよりもあるので。予約この場合には、おそらく、端部で終端ゼロのための余地を残す - サイズ制限は、2つのパワーより正確に一つの小さい場合、それは1つの余分なバイトがいくつかの特定の理由のために予約されていることを強く示唆しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o In the case of DNS label lengths, the stated limit is 63 bytes. As with the total name length, this limit is exactly one less than a power of two. This label length limit also excludes the label length byte at the start of every label. Including that extra byte, a 63-byte label takes 64 bytes of space in memory or in a DNS message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O DNSラベルの長さの場合には、記載制限は63バイトです。総名の長さと同様に、この制限は、正確に2の累乗より少ないものです。このラベルの長さの制限は、すべてのラベルの開始時にラベルの長さのバイトを除外します。その余分なバイトを含め、63バイトのラベルは、メモリやDNSメッセージ内のスペースの64バイトを取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o It is common in software engineering for the semantic &#34;length&#34; of an object to be one less than the number of bytes it takes to store that object. For example, in C, strlen(&#34;foo&#34;) is 3, but sizeof(&#34;foo&#34;) (which includes the terminating zero byte at the end) is 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oそれは、そのオブジェクトを格納するのに要するバイト数より1つ少なくなるように、オブジェクトの意味「長さ」のためのソフトウェア工学では一般的です。例えば、Cで、strlenを（ &#34;FOO&#34;）は3であるが、はsizeof（ &#34;FOO&#34;）は（端で終端ゼロバイトを含む）4です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The text describing the total length of a domain name mentions explicitly that label length and data octets are included, but does not mention the terminating zero at the end. The zero byte at the end of a domain name is not a label length. Indeed, the value zero is chosen as the terminating marker precisely because it is not a legal length byte value -- DNS prohibits empty labels. For example, a name like &#34;bad..name.&#34; is not a valid domain name because it contains a zero-length label in the middle, which cannot be expressed in a DNS message, because software parsing the message would misinterpret a zero label-length byte as being a zero &#34;end of name&#34; marker instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oドメイン名の合計の長さを説明するテキストは、明示的にそのラベルの長さに言及し、データオクテットは含まれていますが、最後に終了するゼロを言及していません。ドメイン名の末尾のゼロのバイトは、ラベルの長さではありません。確かに、ゼロ値は、それが法的な長さバイトの値ではないからこそ終端マーカとして選択される -  DNSは、空のラベルを禁止しています。例えば、のような名前「bad..name。」メッセージを解析するソフトウェアは、マーカーゼロ「名前の末尾」であるとして、ゼロラベルの長さのバイトを誤って解釈するだろうので、それは、DNSメッセージで表現することはできません途中で長さゼロのラベルが含まれているため、有効なドメイン名ではありません代わりに。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finally, &#34;Clarifications to the DNS Specification&#34; [RFC2181] offers additional confirmation that, in the context of DNS specifications, the stated &#34;length&#34; of a domain name does not include the terminating zero byte at the end. That document refers to the root name, which is typically written as &#34;.&#34; and is represented in a DNS message by a single lone zero byte (i.e., zero bytes of data plus a terminating zero), as the &#34;zero length full name&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後に、[RFC2181]「DNS仕様の明確化は、」DNS仕様書の文脈では、ドメイン名の明記「長さ」は、最後に終了するゼロのバイトが含まれていない、追加の確認を提供しています。その文書には、通常のように書かれているルート名を指し、「」そして「ゼロ長フルネーム」のような単一の孤立ゼロバイト（すなわち、ゼロデータのバイト+終端ゼロ）によりDNSメッセージに表されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The zero length full name is defined as representing the root of the DNS tree, and is typically written and displayed as &#34;.&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ゼロ長フルネームは、DNSツリーのルートを表すものとして定義され、典型的に書き込まれたように表示されます「」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This wording supports the interpretation that, in a DNS context, when talking about lengths of names, the terminating zero byte at the end is not counted. If the root name (&#34;.&#34;) is considered to be zero length, then to be consistent, the length (for example) of &#34;org&#34; has to be 4 and the length of &#34;ietf.org&#34; has to be 9, as shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文言は、名前の長さについて話したときにDNSコンテキストで、最後に終了するゼロバイトがカウントされない、解釈をサポートしています。ルート名（「」）を一致するように、長さゼロであると見なされる場合、（例えば） 『ORG』の長さが4であることがあり、 『ietf.org』の長さとして、9なければなりません下に示された：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                                  ------
                                                 | 0x00 |   length = 0
                                                  ------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             ------------------   ------
                            | 0x03 | o | r | g | | 0x00 |   length = 4
                             ------------------   ------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      -----------------------------------------   ------
     | 0x04 | i | e | t | f | 0x03 | o | r | g | | 0x00 |   length = 9
      -----------------------------------------   ------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This means that the maximum length of a domain name, as represented in a Multicast DNS message, up to but not including the final terminating zero, must not exceed 255 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、ドメイン名の最大長は、マルチキャストDNSメッセージに示されるように、最終的な終端ゼロを含むまでではないが、255のバイトを超えてはならないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, many Unicast DNS implementers have read these RFCs differently, and argue that the 255-byte limit does include the terminating zero, and that the &#34;Clarifications to the DNS Specification&#34; [RFC2181] statement that &#34;.&#34; is the &#34;zero length full name&#34; was simply a mistake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、多くのユニキャストDNSの実装は異なり、これらのRFCを読んで、255バイトの制限は、「DNS仕様の明確化を」ゼロを終了し、そのこと[RFC2181]文を含めないと主張しています「」 「長さがゼロのフルネームは」単に間違いだったです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Hence, implementers should be aware that other Unicast DNS implementations may limit the maximum domain name to 254 bytes plus a terminating zero, depending on how that implementer interpreted the DNS specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
したがって、実装は、他のユニキャストDNS実装は、その実装がDNS仕様を解釈する方法に応じて、254バイト+終端ゼロに最大のドメイン名を制限することができることに注意すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Compliant Multicast DNS implementations MUST support names up to 255 bytes plus a terminating zero, i.e., 256 bytes total.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
準拠マルチキャストDNS実装は、最大255バイトと終了ゼロ、すなわち、256バイトの合計に名前をサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix D. Benefits of Multicast Responses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャスト応答の付録D.利点
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some people have argued that sending responses via multicast is inefficient on the network. In fact, using multicast responses can result in a net lowering of overall multicast traffic for a variety of reasons, and provides other benefits too:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部の人々は、マルチキャストを経由して応答を送信すると、ネットワーク上の非効率的であると主張してきました。実際には、マルチキャスト応答を使用すると、様々な理由のために全体的なマルチキャストトラフィックの低下、ネットにつながる、とあまりにも他の利点を提供することができます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Opportunistic Caching. One multicast response can update the caches on all machines on the network. If another machine later wants to issue the same query, and it already has the answer in its cache, it may not need to even transmit that multicast query on the network at all.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*日和見キャッシング。一つのマルチキャスト応答は、ネットワーク上のすべてのマシン上のキャッシュを更新することができます。別のマシンが後で同じクエリを発行したい、それがすでにキャッシュ内に答えを持っている場合、それは、まったくネットワーク上のマルチキャストクエリを送信する必要がないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Duplicate Query Suppression. When more than one machine has the same ongoing long-lived query running, every machine does not have to transmit its own independent query. When one machine transmits a query, all the other hosts see the answers, so they can suppress their own queries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*重複クエリ抑制。複数のマシンが同じ継続的な長命のクエリを実行している場合は、すべてのマシンは、独自の独立したクエリを送信する必要はありません。 1台のマシンがクエリを送信すると、彼らは自分自身のクエリを抑制することができるので、他のすべてのホストは、答えを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Passive Observation Of Failures (POOF). When a host sees a multicast query, but does not see the corresponding multicast response, it can use this information to promptly delete stale data from its cache. To achieve the same level of user-interface quality and responsiveness without multicast responses would require lower cache lifetimes and more frequent network polling, resulting in a higher packet rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*障害の受動的な観察（POOF）。ホストがマルチキャストクエリーを見ているが、対応するマルチキャスト応答を見ていないときは、速やかにそのキャッシュから古いデータを削除するには、この情報を使用することができます。マルチキャスト応答することなく、ユーザインタフェースの品質と応答性の同じレベルを達成するために、より高いパケットレートをもたらす、より低いキャッシュ寿命およびより頻繁なネットワーク・ポーリングを必要とするであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Passive Conflict Detection. Just because a name has been previously verified to be unique does not guarantee it will continue to be so indefinitely. By allowing all Multicast DNS responders to constantly monitor their peers&#39; responses, conflicts arising out of network topology changes can be promptly detected and resolved. If responses were not sent via multicast, some other conflict detection mechanism would be needed, imposing its own additional burden on the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*パッシブ競合検出。名前は以前に固有であることが確認されているからといって、それはそう無期限であり続ける保証するものではありません。すべてのマルチキャストDNSの応答は常に仲間の回答を監視できるようにすることで、ネットワークトポロジの変更から生じる紛争を迅速に検出して解決することができます。応答は、マルチキャストを経由して送信されなかった場合は、他のいくつかの競合検出メカニズムは、ネットワーク上の独自の追加的な負担をかけ、必要とされるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Use on devices with constrained memory resources: When using delayed responses to reduce network collisions, responders need to maintain a list recording to whom each answer should be sent. The option of multicast responses allows responders with limited storage, which cannot store an arbitrarily long list of response addresses, to choose to fail-over to a single multicast response in place of multiple unicast responses, when appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*制約メモリリソースをデバイス上で使用してください：ネットワーク衝突を減らすために遅れた応答を使用する場合、応答は、各回答が送信されるべき誰にリスト記録を維持する必要があります。マルチキャスト応答のオプションは、フェイルオーバーするために、複数のユニキャスト応答の代わりに、単一のマルチキャスト応答に、適切な場合に選択し、応答アドレスの任意の長いリストを格納することはできません限られた記憶、と応答することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Overlayed Subnets. In the case of overlayed subnets, multicast responses allow a receiver to know with certainty that a response originated on the local link, even when its source address may apparently suggest otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*オーバーレイサブネット。オーバーレイサブネットの場合は、マルチキャスト応答は、その送信元アドレスが明らかにそうでない提案するかもしれない場合でも、応答はローカルリンク上で発信されていること、受信機が確実に知ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* Robustness in the face of misconfiguration: Link-local multicast transcends virtually every conceivable network misconfiguration. Even if you have a collection of devices where every device&#39;s IP address, subnet mask, default gateway, and DNS server address are all wrong, packets sent by any of those devices addressed to a link-local multicast destination address will still be delivered to all peers on the local link. This can be extremely helpful when diagnosing and rectifying network problems, since it facilitates a direct communication channel between client and server that works without reliance on ARP, IP routing tables, etc. Being able to discover what IP address a device has (or thinks it has) is frequently a very valuable first step in diagnosing why it is unable to communicate on the local network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*設定ミスの顔で頑健性：リンクローカルマルチキャストは、事実上すべての考えられるネットワークの設定ミスを超越します。あなたはすべてのデバイスのIPアドレス、サブネットマスク、デフォルトゲートウェイ、およびDNSサーバーのアドレスはすべて間違っているデバイスのコレクションを持っている場合でも、それらのデバイスのいずれかによって送信されたパケットは、リンクローカルマルチキャストの宛先アドレス宛まだすべてに配信されますローカルリンク上のピア。ネットワークの問題を診断し、整流時にIPアドレスは、デバイスがそれを持っている（または考えているものを発見することができることなどをARPに依存せずに動作し、クライアントとサーバの間の直接通信チャネル、IPルーティングテーブルを、容易ので、これは、非常に参考にすることができ）はしばしば、ローカルネットワーク上で通信することができない理由を診断する上で非常に貴重な第一歩です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix E. Design Rationale for Encoding Negative Responses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
否定応答をエンコードするための付録E.設計原理
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Alternative methods of asserting nonexistence were considered, such as using an NXDOMAIN response, or emitting a resource record with zero-length rdata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
有無をアサートする別の方法は、そのようなNXDOMAIN応答を使用して、または長さゼロのRDATAとリソースレコードを発するように、考慮されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using an NXDOMAIN response does not work well with Multicast DNS. A Unicast DNS NXDOMAIN response applies to the entire message, but for efficiency Multicast DNS allows (and encourages) multiple responses in a single message. If the error code in the header were NXDOMAIN, it would not be clear to which name(s) that error code applied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NXDOMAIN応答を使用すると、マルチキャストDNSでうまく動作しません。ユニキャストDNS NXDOMAIN応答はメッセージ全体に適用されるが、効率のためにマルチキャストDNSは、単一のメッセージ内の複数の応答を可能にする（および奨励します）。ヘッダにエラーコードがNXDOMAINた場合、そのエラーコードが適用された名前（複数可）には明らかではないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Asserting nonexistence by emitting a resource record with zero-length rdata would mean that there would be no way to differentiate between a record that doesn&#39;t exist, and a record that does exist, with zero- length rdata. By analogy, most file systems today allow empty files, so a file that exists with zero bytes of data is not considered equivalent to a filename that does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ゼロ長RDATAとリソースレコードを放出することによって有無をアサートすることは存在しないレコード、およびゼロ長RDATAと、存在するレコードを区別する方法がないであろうことを意味します。類推すると、ほとんどのファイルシステム今日は、空のファイルを許可するので、データのゼロバイトに存在するファイルが存在しないファイル名に同等とみなされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A benefit of asserting nonexistence through NSEC records instead of through NXDOMAIN responses is that NSEC records can be added to the Additional Section of a DNS response to offer additional information beyond what the querier explicitly requested. For example, in response to an SRV query, a responder should include A record(s) giving its IPv4 addresses in the Additional Section, and an NSEC record indicating which other types it does or does not have for this name. If the responder is running on a host that does not support IPv6 (or does support IPv6 but currently has no IPv6 address on that interface) then this NSEC record in the Additional Section will indicate this absence of AAAA records. In effect, the responder is saying, &#34;Here&#39;s my SRV record, and here are my IPv4 addresses, and no, I don&#39;t have any IPv6 addresses, so don&#39;t waste your time asking&#34;. Without this information in the Additional Section, it would take the querier an additional round-trip to perform an additional query to ascertain that the target host has no AAAA records. (Arguably Unicast DNS could also benefit from this ability to express nonexistence in the Additional Section, but that is outside the scope of this document.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NSECレコードを代わりにNXDOMAIN応答を通じて不存在を主張することの利点は、NSECレコードがクエリアが明示的に要求されたものを超えて、追加情報を提供するために、DNS応答の追加セクションに追加することができるということです。例えば、SRVのクエリに応答して、応答者は追加のセクション、そしてそれがないか、この名前を持っていない他の種類を示すNSECレコードにそのIPv4アドレスを与えるレコード（複数可）を含める必要があります。応答者がIPv6をサポートしていません（またはIPv6をサポートしていないが、現在そのインターフェイスにはIPv6アドレスを持っていない）ホスト上で実行されている場合は、追加のセクションで、このNSECレコードはAAAAレコードのこの存在しないことを示します。実際には、応答者は、「ここに私のSRVレコードだし、ここに私のIPv4アドレスであり、いや、私は、任意のIPv6アドレスを持っていないので、あなたの時間を無駄に求めていない」、と言っています。追加セクションでこの情報がなければ、追加の往復は、ターゲットホストが何のAAAAレコードを持っていないことを確認するために追加のクエリを実行するためにクエリアを取るだろう。 （おそらくユニキャストDNSはまた、追加セクションに存在しないを表現するこの能力から利益を得ることができるが、それはこの文書の範囲外です。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix F. Use of UTF-8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UTF-8の付録F.使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After many years of debate, as a result of the perceived need to accommodate certain DNS implementations that apparently couldn&#39;t handle any character that&#39;s not a letter, digit, or hyphen (and apparently never would be updated to remedy this limitation), the Unicast DNS community settled on an extremely baroque encoding called &#34;Punycode&#34; [RFC3492]. Punycode is a remarkably ingenious encoding solution, but it is complicated, hard to understand, and hard to implement, using sophisticated techniques including insertion unsort coding, generalized variable-length integers, and bias adaptation. The resulting encoding is remarkably compact given the constraints, but it&#39;s still not as good as simple straightforward UTF-8, and it&#39;s hard even to predict whether a given input string will encode to a Punycode string that fits within DNS&#39;s 63-byte limit, except by simply trying the encoding and seeing whether it fits. Indeed, the encoded size depends not only on the input characters, but on the order they appear, so the same set of characters may or may not encode to a legal Punycode string that fits within DNS&#39;s 63-byte limit, depending on the order the characters appear. This is extremely hard to present in a user interface that explains to users why one name is allowed, but another name containing the exact same characters is not. Neither Punycode nor any other of the &#34;ASCII-Compatible Encodings&#34; [RFC5890] proposed for Unicast DNS may be used
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
議論の多くの年後、明らかに文字、数字、またはハイフン（どうやら、この制限を解消するために更新されないであろう決して）ではありません任意の文字を扱うことができなかった特定のDNS実装に対応するために、知覚の必要性の結果として、ユニキャストDNSコミュニティは「ピュニコード」[RFC3492]と呼ばれる非常にバロック様式のエンコーディングに落ち着きました。ピュニコードが著しく独創的な符号化方法であるが、挿入ソート解除符号化、一般化可変長整数、バイアス適応を含む洗練された技術を使用して、実装するには、複雑なハード理解し、かつ困難です。結果のエンコードは制約が与えられた非常にコンパクトですが、それはまだ簡単な直接的なUTF-8ほど良くはありません、それは与えられた入力文字列がDNSの63バイトの制限内に収まるピュニコード文字列にエンコードするかどうかを予測することさえ難しい、除きます単にエンコーディングをしようとし、それが収まるかどうかを見ることもできます。確かに、エンコードされた大きさだけでなく、入力文字に依存しますが、彼らが表示されるために、文字の同じセットは、またはオーダーに応じて、DNSの63バイトの制限内に収まる法的ピュニコード文字列にエンコードしない場合がありますので、文字が表示されます。これは、1人の名前が許可されている理由をユーザーに説明したユーザインタフェースに提示することは非常に難しいですが、まったく同じ文字を含む別の名前ではありません。ピュニコードもユニキャストDNSのために提案された「ASCIIコンパチブルエンコーディング」[RFC5890]のいずれか他方が使用されてもよいどちら
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
in Multicast DNS messages. Any text being represented internally in some other representation must be converted to canonical precomposed UTF-8 before being placed in any Multicast DNS message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSメッセージインチいくつかの他の表現で内部的に表現されている任意のテキストは、すべてのマルチキャストDNSメッセージに配置される前に、標準的な合成済みUTF-8に変換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix G. Private DNS Namespaces
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録G.プライベートDNS名前空間
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The special treatment of names ending in &#34;.local.&#34; has been implemented in Macintosh computers since the days of Mac OS 9, and continues today in Mac OS X and iOS. There are also implementations for Microsoft Windows [B4W], Linux, and other platforms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
終わる名前の特殊な治療「.localの。」 Mac OS 9の時代からMacintoshコンピュータに実装、およびMac OS XとiOSで現在も続いてきました。 Microsoft Windowsの[B4W]、Linux、および他のプラットフォームの実装もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some network operators setting up private internal networks (&#34;intranets&#34;) have used unregistered top-level domains, and some may have used the &#34;.local&#34; top-level domain. Using &#34;.local&#34; as a private top-level domain conflicts with Multicast DNS and may cause problems for users. Clients can be configured to send both Multicast and Unicast DNS queries in parallel for these names, and this does allow names to be looked up both ways, but this results in additional network traffic and additional delays in name resolution, as well as potentially creating user confusion when it is not clear whether any given result was received via link-local multicast from a peer on the same link, or from the configured unicast name server. Because of this, we recommend against using &#34;.local&#34; as a private Unicast DNS top-level domain. We do not recommend use of unregistered top-level domains at all, but should network operators decide to do this, the following top-level domains have been used on private internal networks without the problems caused by trying to reuse &#34;.local.&#34; for this purpose:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プライベート内部ネットワークを設定するいくつかのネットワークオペレータは、（「イントラネット」）未登録のトップレベルドメインを使用している、といくつかは「.localの」トップレベルドメインを使用している場合があります。マルチキャストDNSと民間トップレベルドメインの競合として「.localの」使用してユーザーのための問題を引き起こす可能性があります。クライアントは、これらの名前のために並行して、マルチキャストとユニキャストの両方のDNSクエリを送信するように設定することができ、これは名前が両方の方法を見上げたことを認めていませんが、これは追加のネットワークトラフィックと名前解決におけるさらなる遅延につながるだけでなく、潜在的なユーザーを作成します任意の所与の結果が同じリンク上で、または設定ユニキャストネームサーバからピアからリンクローカルマルチキャストを介して受信されたかどうかは明らかではない混乱。このため、我々は民間ユニキャストDNSトップレベルドメインとして「.localの」使用しないことをお勧めします。我々はすべての未登録のトップレベルドメインの使用はお勧めしませんが、事業者はこれを実行することを決定し、ネットワークする必要があり、次のトップレベルドメインを再利用しようとすることで発生する問題なくプライベート内部ネットワークで使用されている「.localの。」この目的のために：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
.intranet. .internal. .private. .corp. .home. .lan.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
.intranet。 。内部。 。民間。 .corp。 .home。 .LAN。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix H. Deployment History
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録H.展開の歴史
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In July 1997, in an email to the net-thinkers@thumper.vmeng.com mailing list, Stuart Cheshire first proposed the idea of running the AppleTalk Name Binding Protocol [RFC6760] over IP. As a result of this and related IETF discussions, the IETF Zeroconf working group was chartered September 1999. After various working group discussions and other informal IETF discussions, several Internet-Drafts were written that were loosely related to the general themes of DNS and multicast, but did not address the service discovery aspect of NBP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1997年7月、net-thinkers@thumper.vmeng.comメーリングリストへの電子メールで、スチュアートチェシャーは、最初のIP上でプロトコル[RFC6760]をバインディングのAppleTalk名を実行しているのアイデアを提案しました。この結果、関連IETFの議論として、IETFのZeroconfワーキンググループは、さまざまなワーキンググループディスカッションや他の非公式IETF議論の後1999年9月にチャーターされた緩くDNSおよびマルチキャストの一般的なテーマに関連していたというインターネットドラフトが書かれていたいくつかの、しかし、NBPのサービス発見側面に対処していませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In April 2000, Stuart Cheshire registered IPv4 multicast address 224.0.0.251 with IANA [MC4] and began writing code to test and develop the idea of performing NBP-like service discovery using Multicast DNS, which was documented in a group of three Internet-Drafts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2000年4月に、スチュアート・チェシャーはIANA [MC4]でIPv4マルチキャストアドレス224.0.0.251を登録し、テストし、3インターネットドラフトのグループに記載されたマルチキャストDNSを使用して、NBPのようなサービス・ディスカバリを実行する考えを開発するためにコードを書き始めました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o &#34;Requirements for a Protocol to Replace the AppleTalk Name Binding Protocol (NBP)&#34; [RFC6760] is an overview explaining the AppleTalk Name Binding Protocol, because many in the IETF community had little first-hand experience using AppleTalk, and confusion in the IETF community about what AppleTalk NBP did was causing confusion about what would be required in an IP-based replacement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFコミュニティの多くは、AppleTalkを使用少し最初の手の経験を持っていた、とIETFにおける混乱ので、O [RFC6760]「AppleTalkの名前バインディングプロトコル（NBP）を交換するためのプロトコルのための要件は、」プロトコルを、バインディングのAppleTalk名を説明する概要ですAppleTalkのNBPが何をしたかについてのコミュニティは、IPベースの交換に必要となるかについて混乱を引き起こしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o &#34;Discovering Named Instances of Abstract Services using DNS&#34; [NIAS] proposed a way to perform NBP-like service discovery using DNS-compatible names and record types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O [NIAS]「DNSを使用して抽象サービスの名前付きインスタンスを検出」DNS互換の名前とレコードタイプを使用してNBPのようなサービス・ディスカバリを実行する方法を提案しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o &#34;Multicast DNS&#34; (this document) specifies a way to transport those DNS-compatible queries and responses using IP multicast, for zero-configuration environments where no conventional Unicast DNS server was available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O「マルチキャストDNS」（この文書は）は、従来のユニキャストDNSサーバが利用できなかったゼロ設定環境では、IPマルチキャストを用いたものDNS互換クエリおよび応答を転送する方法を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In 2001, an update to Mac OS 9 added resolver library support for host name lookup using Multicast DNS. If the user typed a name such as &#34;MyPrinter.local.&#34; into any piece of networking software that used the standard Mac OS 9 name lookup APIs, then those name lookup APIs would recognize the name as a dot-local name and query for it by sending simple one-shot Multicast DNS queries to 224.0.0.251:5353. This enabled the user to, for example, enter the name &#34;MyPrinter.local.&#34; into their web browser in order to view a printer&#39;s status and configuration web page, or enter the name &#34;MyPrinter.local.&#34; into the printer setup utility to create a print queue for printing documents on that printer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2001年にはMac OS 9へのアップデートは、マルチキャストDNSを使用してホスト名のルックアップのためのリゾルバライブラリのサポートを追加しました。ユーザーは、次のような名前を入力した場合、「MyPrinter.local。」標準のMac OS 9名前検索APIを使用するネットワークソフトウェアのどの部分に、それらの名前検索APIは224.0.0.251に、単純なワンショットマルチキャストDNSクエリを送信することで、そのためのドットローカル名およびクエリとして名を認識することとなります。 5353。これは、例えば、名前の入力をユーザーに有効「MyPrinter.localを。」プリンタのステータスと設定のWebページを表示する、または名前を入力するために、自分のWebブラウザに「MyPrinter.localを。」プリンタ設定ユーティリティにそのプリンタへの印刷文書の印刷キューを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS responder software, with full service discovery, first began shipping to end users in volume with the launch of Mac OS X 10.2 &#34;Jaguar&#34; in August 2002, and network printer makers (who had historically supported AppleTalk in their network printers and were receptive to IP-based technologies that could offer them similar ease-of-use) started adopting Multicast DNS shortly thereafter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSの応答ソフトウェアは、フルサービスの発見と、最初の2002年8月にはMac OS X 10.2「ジャガー」の打ち上げとボリュームにエンドユーザに出荷を開始した、と歴史的にそのネットワークプリンタでのAppleTalkをサポートし、受容したしたネットワークプリンタメーカー（それらに類似した使いやすさを提供できるIPベースの技術）に、その後まもなく、マルチキャストDNSを採用し始めました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In September 2002, Apple released the source code for the mDNSResponder daemon as Open Source under Apple&#39;s standard Apple Public Source License (APSL).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2002年9月、AppleはAppleの標準のApple Public Source License（APSL）の下でオープンソースとしてmDNSResponderデーモンのソースコードを公開しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Multicast DNS responder software became available for Microsoft Windows users in June 2004 with the launch of Apple&#39;s &#34;Rendezvous for Windows&#34; (now &#34;Bonjour for Windows&#34;), both in executable form (a downloadable installer for end users) and as Open Source (one of the supported platforms within Apple&#39;s body of cross-platform code in the publicly accessible mDNSResponder CVS source code repository) [BJ].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNS応答ソフトウェアは、実行形式（エンドユーザー用のダウンロードインストーラ）におけるオープンソース（1として両方Appleの「Windows用のランデブー」（現在の「Windows用のBonjour」）の発売と2004年6月のMicrosoft Windowsユーザーのために利用できるようになりました一般にアクセス可能mDNSResponder CVSソースコードリポジトリでのクロスプラットフォームコードのAppleの体内でサポートされるプラットフォーム）[BJ]の。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In August 2006, Apple re-licensed the cross-platform mDNSResponder source code under the Apache License, Version 2.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2006年8月に、AppleはApacheライセンスの下で、クロスプラットフォームmDNSResponderのソースコード、バージョン2.0を再ライセンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to desktop and laptop computers running Mac OS X and Microsoft Windows, Multicast DNS is now implemented in a wide range of hardware devices, such as Apple&#39;s &#34;AirPort&#34; wireless base stations, iPhone and iPad, and in home gateways from other vendors, network printers, network cameras, TiVo DVRs, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デスクトップおよびラップトップコンピュータは、Mac OS XおよびMicrosoft Windowsを実行していることに加えて、マルチキャストDNSは現在、アップルの「AirMacの」無線基地局、iPhoneやiPadなどのハードウェアデバイスの広い範囲で、および他のベンダーからホームゲートウェイに実装されていますネットワークプリンタ、ネットワークカメラ、ティーボのデジタルビデオレコーダーなど
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Open Source community has produced many independent implementations of Multicast DNS, some in C like Apple&#39;s mDNSResponder daemon, and others in a variety of different languages including Java, Python, Perl, and C#/Mono.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オープンソースコミュニティは、JavaやPython、Perlの、およびC＃/モノラルを含む異なるさまざまな言語でマルチキャストDNS、AppleのmDNSResponderデーモンのようなCでのいくつかの、および他の多くの独立した実装を生産しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In January 2007, the IETF published the Informational RFC &#34;Link-Local Multicast Name Resolution (LLMNR)&#34; [RFC4795], which is substantially similar to Multicast DNS, but incompatible in some small but important ways. In particular, the LLMNR design explicitly excluded support for service discovery, which made it an unsuitable candidate for a protocol to replace AppleTalk NBP [RFC6760].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2007年1月、IETFは、情報RFC、実質的にマルチキャストDNSに似ていますが、いくつかの小さいながらも重要な点で互換性がありません「リンクローカルマルチキャスト名前解決（LLMNR）」[RFC4795]を、発表しました。特に、LLMNRの設計は明示的にAppleTalkのNBP [RFC6760]を置き換えるためのプロトコルには適さない候補作られ、サービスの発見のためのサポートを除外しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While the original focus of Multicast DNS and DNS-Based Service Discovery was for zero-configuration environments without a conventional Unicast DNS server, DNS-Based Service Discovery also works using Unicast DNS servers, using DNS Update [RFC2136] [RFC3007] to create service discovery records and standard DNS queries to query for them. Apple&#39;s Back to My Mac service, launched with Mac OS X 10.5 &#34;Leopard&#34; in October 2007, uses DNS-Based Service Discovery over Unicast DNS [RFC6281].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルチキャストDNSおよびDNSベースのサービス発見の元の焦点は、従来のユニキャストDNSサーバなしでゼロコンフィギュレーション環境のためだったが、DNSベースのサービスディスカバリーは、サービスを作成するために、DNSアップデート[RFC2136] [RFC3007]を使用して、ユニキャストDNSサーバを使用して動作します探索レコードと標準DNSクエリは、彼らのために照会します。 2007年10月にはMac OS X 10.5 &#34;Leopardの&#34; で起動でもMy MacサービスにAppleのバックは、ユニキャストDNS [RFC6281]の上にDNSベースのサービス探索を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In June 2012, Google&#39;s Android operating system added native support for DNS-SD and Multicast DNS with the android.net.nsd.NsdManager class in Android 4.1 &#34;Jelly Bean&#34; (API Level 16) [NSD].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2012年6月には、GoogleのAndroidオペレーティングシステムは、[NSD]アンドロイド4.1 &#34;ジェリービーン&#34;（APIレベル16）でandroid.net.nsd.NsdManagerクラスでDNS-SDおよびマルチキャストDNSのネイティブサポートを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stuart Cheshire Apple Inc. 1 Infinite Loop Cupertino, CA 95014 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スチュアートチェシャーれたApple Inc. 1無限ループクパチーノ、CA 95014 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 408 974 3207 EMail: cheshire@apple.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 408 974 3207 Eメール：cheshire@apple.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Marc Krochmal Apple Inc. 1 Infinite Loop Cupertino, CA 95014 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
マルク・KrochmalされたApple Inc. 1無限ループクパチーノ、CA 95014 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 408 974 4368 EMail: marc@apple.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 408 974 4368 Eメール：marc@apple.com
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
